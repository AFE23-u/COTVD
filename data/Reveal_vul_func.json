[
    {
        "code": "static int alloc_addbyter ( int output , FILE * data ) {\n struct asprintf * infop = ( struct asprintf * ) data ;\n unsigned char outc = ( unsigned char ) output ;\n if ( ! infop -> buffer ) {\n infop -> buffer = malloc ( 32 ) ;\n if ( ! infop -> buffer ) {\n infop -> fail = 1 ;\n return - 1 ;\n }\n infop -> alloc = 32 ;\n infop -> len = 0 ;\n }\n else if ( infop -> len + 1 >= infop -> alloc ) {\n char * newptr ;\n newptr = realloc ( infop -> buffer , infop -> alloc * 2 ) ;\n if ( ! newptr ) {\n infop -> fail = 1 ;\n return - 1 ;\n }\n infop -> buffer = newptr ;\n infop -> alloc *= 2 ;\n }\n infop -> buffer [ infop -> len ] = outc ;\n infop -> len ++ ;\n return outc ;\n }",
        "hash": -8228664527580018723,
        "project": "debian",
        "size": 26,
        "slice": {
            "malloc": [
                [
                    1,
                    "static int alloc_addbyter ( int output , FILE * data ) {\n"
                ],
                [
                    4,
                    " if ( ! infop -> buffer ) {\n"
                ],
                [
                    5,
                    " infop -> buffer = malloc ( 32 ) ;\n"
                ],
                [
                    6,
                    " if ( ! infop -> buffer ) {\n"
                ]
            ],
            "realloc": [
                [
                    2,
                    " struct asprintf * infop = ( struct asprintf * ) data ;\n"
                ],
                [
                    4,
                    " if ( ! infop -> buffer ) {\n"
                ],
                [
                    13,
                    " else if ( infop -> len + 1 >= infop -> alloc ) {\n"
                ],
                [
                    15,
                    " newptr = realloc ( infop -> buffer , infop -> alloc * 2 ) ;\n"
                ],
                [
                    16,
                    " if ( ! newptr ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int alloc_addbyter ( int output , FILE * data ) {\n"
                ],
                [
                    2,
                    " struct asprintf * infop = ( struct asprintf * ) data ;\n"
                ],
                [
                    4,
                    " if ( ! infop -> buffer ) {\n"
                ],
                [
                    5,
                    " infop -> buffer = malloc ( 32 ) ;\n"
                ],
                [
                    6,
                    " if ( ! infop -> buffer ) {\n"
                ],
                [
                    13,
                    " else if ( infop -> len + 1 >= infop -> alloc ) {\n"
                ],
                [
                    15,
                    " newptr = realloc ( infop -> buffer , infop -> alloc * 2 ) ;\n"
                ],
                [
                    16,
                    " if ( ! newptr ) {\n"
                ]
            ]
        }
    },
    {
        "code": "int jbig2_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n int offset = 0 ;\n Jbig2RegionSegmentInfo region_info ;\n Jbig2TextRegionParams params ;\n Jbig2Image * image = NULL ;\n Jbig2SymbolDict * * dicts = NULL ;\n int n_dicts = 0 ;\n uint16_t flags = 0 ;\n uint16_t huffman_flags = 0 ;\n Jbig2ArithCx * GR_stats = NULL ;\n int code = 0 ;\n Jbig2WordStream * ws = NULL ;\n Jbig2ArithState * as = NULL ;\n int table_index = 0 ;\n const Jbig2HuffmanParams * huffman_params = NULL ;\n if ( segment -> data_length < 17 ) goto too_short ;\n jbig2_get_region_segment_info ( & region_info , segment_data ) ;\n offset += 17 ;\n flags = jbig2_get_uint16 ( segment_data + offset ) ;\n offset += 2 ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"text region header flags 0x%04x\" , flags ) ;\n memset ( & params , 0 , sizeof ( Jbig2TextRegionParams ) ) ;\n params . SBHUFF = flags & 0x0001 ;\n params . SBREFINE = flags & 0x0002 ;\n params . LOGSBSTRIPS = ( flags & 0x000c ) >> 2 ;\n params . SBSTRIPS = 1 << params . LOGSBSTRIPS ;\n params . REFCORNER = ( Jbig2RefCorner ) ( ( flags & 0x0030 ) >> 4 ) ;\n params . TRANSPOSED = flags & 0x0040 ;\n params . SBCOMBOP = ( Jbig2ComposeOp ) ( ( flags & 0x0180 ) >> 7 ) ;\n params . SBDEFPIXEL = flags & 0x0200 ;\n params . SBDSOFFSET = ( flags & 0x7C00 ) >> 10 ;\n if ( params . SBDSOFFSET > 0x0f ) params . SBDSOFFSET -= 0x20 ;\n params . SBRTEMPLATE = flags & 0x8000 ;\n if ( params . SBDSOFFSET ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"text region has SBDSOFFSET %d\" , params . SBDSOFFSET ) ;\n }\n if ( params . SBHUFF ) {\n huffman_flags = jbig2_get_uint16 ( segment_data + offset ) ;\n offset += 2 ;\n if ( huffman_flags & 0x8000 ) jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"reserved bit 15 of text region huffman flags is not zero\" ) ;\n }\n else {\n if ( ( params . SBREFINE ) && ! ( params . SBRTEMPLATE ) ) {\n params . sbrat [ 0 ] = segment_data [ offset ] ;\n params . sbrat [ 1 ] = segment_data [ offset + 1 ] ;\n params . sbrat [ 2 ] = segment_data [ offset + 2 ] ;\n params . sbrat [ 3 ] = segment_data [ offset + 3 ] ;\n offset += 4 ;\n }\n }\n params . SBNUMINSTANCES = jbig2_get_uint32 ( segment_data + offset ) ;\n offset += 4 ;\n if ( params . SBHUFF ) {\n switch ( huffman_flags & 0x0003 ) {\n case 0 : params . SBHUFFFS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_F ) ;\n break ;\n case 1 : params . SBHUFFFS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_G ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom FS huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFFS = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid FS huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFFS == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified FS huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x000c ) >> 2 ) {\n case 0 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_H ) ;\n break ;\n case 1 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_I ) ;\n break ;\n case 2 : params . SBHUFFDS = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_J ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom DS huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFDS = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n }\n if ( params . SBHUFFDS == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified DS huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x0030 ) >> 4 ) {\n case 0 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_K ) ;\n break ;\n case 1 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_L ) ;\n break ;\n case 2 : params . SBHUFFDT = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_M ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom DT huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFDT = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n }\n if ( params . SBHUFFDT == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified DT huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x00c0 ) >> 6 ) {\n case 0 : params . SBHUFFRDW = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ;\n break ;\n case 1 : params . SBHUFFRDW = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RDW huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRDW = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid RDW huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFRDW == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RDW huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x0300 ) >> 8 ) {\n case 0 : params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ;\n break ;\n case 1 : params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RDH huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRDH = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid RDH huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFRDH == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RDH huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x0c00 ) >> 10 ) {\n case 0 : params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ;\n break ;\n case 1 : params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RDX huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRDX = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid RDX huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFRDX == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RDX huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x3000 ) >> 12 ) {\n case 0 : params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_N ) ;\n break ;\n case 1 : params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_O ) ;\n break ;\n case 3 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RDY huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRDY = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n case 2 : default : code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region specified invalid RDY huffman table\" ) ;\n goto cleanup1 ;\n break ;\n }\n if ( params . SBHUFFRDY == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RDY huffman table\" ) ;\n goto cleanup1 ;\n }\n switch ( ( huffman_flags & 0x4000 ) >> 14 ) {\n case 0 : params . SBHUFFRSIZE = jbig2_build_huffman_table ( ctx , & jbig2_huffman_params_A ) ;\n break ;\n case 1 : huffman_params = jbig2_find_table ( ctx , segment , table_index ) ;\n if ( huffman_params == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Custom RSIZE huffman table not found (%d)\" , table_index ) ;\n goto cleanup1 ;\n }\n params . SBHUFFRSIZE = jbig2_build_huffman_table ( ctx , huffman_params ) ;\n ++ table_index ;\n break ;\n }\n if ( params . SBHUFFRSIZE == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to allocate text region specified RSIZE huffman table\" ) ;\n goto cleanup1 ;\n }\n if ( huffman_flags & 0x8000 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"text region huffman flags bit 15 is set, contrary to spec\" ) ;\n }\n }\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"text region: %d x %d @ (%d,%d) %d symbols\" , region_info . width , region_info . height , region_info . x , region_info . y , params . SBNUMINSTANCES ) ;\n n_dicts = jbig2_sd_count_referred ( ctx , segment ) ;\n if ( n_dicts != 0 ) {\n dicts = jbig2_sd_list_referred ( ctx , segment ) ;\n }\n else {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"text region refers to no symbol dictionaries!\" ) ;\n goto cleanup1 ;\n }\n if ( dicts == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"unable to retrive symbol dictionaries! previous parsing error?\" ) ;\n goto cleanup1 ;\n }\n else {\n int index ;\n if ( dicts [ 0 ] == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unable to find first referenced symbol dictionary!\" ) ;\n goto cleanup1 ;\n }\n for ( index = 1 ;\n index < n_dicts ;\n index ++ ) if ( dicts [ index ] == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unable to find all referenced symbol dictionaries!\" ) ;\n n_dicts = index ;\n }\n }\n {\n int stats_size = params . SBRTEMPLATE ? 1 << 10 : 1 << 13 ;\n GR_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n if ( GR_stats == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"could not allocate GR_stats\" ) ;\n goto cleanup1 ;\n }\n memset ( GR_stats , 0 , stats_size ) ;\n }\n image = jbig2_image_new ( ctx , region_info . width , region_info . height ) ;\n if ( image == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate text region image\" ) ;\n goto cleanup2 ;\n }\n ws = jbig2_word_stream_buf_new ( ctx , segment_data + offset , segment -> data_length - offset ) ;\n if ( ws == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate ws in text region image\" ) ;\n goto cleanup2 ;\n }\n as = jbig2_arith_new ( ctx , ws ) ;\n if ( as == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate as in text region image\" ) ;\n goto cleanup2 ;\n }\n if ( ! params . SBHUFF ) {\n int SBSYMCODELEN , index ;\n int SBNUMSYMS = 0 ;\n for ( index = 0 ;\n index < n_dicts ;\n index ++ ) {\n SBNUMSYMS += dicts [ index ] -> n_symbols ;\n }\n params . IADT = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IAFS = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IADS = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IAIT = jbig2_arith_int_ctx_new ( ctx ) ;\n if ( ( params . IADT == NULL ) || ( params . IAFS == NULL ) || ( params . IADS == NULL ) || ( params . IAIT == NULL ) ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate text region image data\" ) ;\n goto cleanup3 ;\n }\n for ( SBSYMCODELEN = 0 ;\n ( 1 << SBSYMCODELEN ) < SBNUMSYMS ;\n SBSYMCODELEN ++ ) {\n }\n params . IAID = jbig2_arith_iaid_ctx_new ( ctx , SBSYMCODELEN ) ;\n params . IARI = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IARDW = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IARDH = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IARDX = jbig2_arith_int_ctx_new ( ctx ) ;\n params . IARDY = jbig2_arith_int_ctx_new ( ctx ) ;\n if ( ( params . IAID == NULL ) || ( params . IARI == NULL ) || ( params . IARDW == NULL ) || ( params . IARDH == NULL ) || ( params . IARDX == NULL ) || ( params . IARDY == NULL ) ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate text region image data\" ) ;\n goto cleanup4 ;\n }\n }\n code = jbig2_decode_text_region ( ctx , segment , & params , ( const Jbig2SymbolDict * const * ) dicts , n_dicts , image , segment_data + offset , segment -> data_length - offset , GR_stats , as , ws ) ;\n if ( code < 0 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to decode text region image data\" ) ;\n goto cleanup4 ;\n }\n if ( ( segment -> flags & 63 ) == 4 ) {\n segment -> result = jbig2_image_clone ( ctx , image ) ;\n }\n else {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"composing %dx%d decoded text region onto page at (%d, %d)\" , region_info . width , region_info . height , region_info . x , region_info . y ) ;\n jbig2_page_add_result ( ctx , & ctx -> pages [ ctx -> current_page ] , image , region_info . x , region_info . y , region_info . op ) ;\n }\n cleanup4 : if ( ! params . SBHUFF ) {\n jbig2_arith_iaid_ctx_free ( ctx , params . IAID ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARI ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARDW ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARDH ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARDX ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IARDY ) ;\n }\n cleanup3 : if ( ! params . SBHUFF ) {\n jbig2_arith_int_ctx_free ( ctx , params . IADT ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IAFS ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IADS ) ;\n jbig2_arith_int_ctx_free ( ctx , params . IAIT ) ;\n }\n jbig2_free ( ctx -> allocator , as ) ;\n jbig2_word_stream_buf_free ( ctx , ws ) ;\n cleanup2 : jbig2_free ( ctx -> allocator , GR_stats ) ;\n jbig2_image_release ( ctx , image ) ;\n cleanup1 : if ( params . SBHUFF ) {\n jbig2_release_huffman_table ( ctx , params . SBHUFFFS ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFDS ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFDT ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRDX ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRDY ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRDW ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRDH ) ;\n jbig2_release_huffman_table ( ctx , params . SBHUFFRSIZE ) ;\n }\n jbig2_free ( ctx -> allocator , dicts ) ;\n return code ;\n too_short : return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Segment too short\" ) ;\n }",
        "hash": 4991783214228010911,
        "project": "debian",
        "size": 343,
        "slice": {
            "memset": [
                [
                    1,
                    "int jbig2_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n"
                ],
                [
                    16,
                    " if ( segment -> data_length < 17 ) goto too_short ;\n"
                ],
                [
                    22,
                    " memset ( & params , 0 , sizeof ( Jbig2TextRegionParams ) ) ;\n"
                ],
                [
                    247,
                    " GR_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n"
                ],
                [
                    248,
                    " if ( GR_stats == NULL ) {\n"
                ],
                [
                    252,
                    " memset ( GR_stats , 0 , stats_size ) ;\n"
                ],
                [
                    300,
                    " code = jbig2_decode_text_region ( ctx , segment , & params , ( const Jbig2SymbolDict * const * ) dicts , n_dicts , image , segment_data + offset , segment -> data_length - offset , GR_stats , as , ws ) ;\n"
                ],
                [
                    312,
                    " cleanup4 : if ( ! params . SBHUFF ) {\n"
                ],
                [
                    313,
                    " jbig2_arith_iaid_ctx_free ( ctx , params . IAID ) ;\n"
                ],
                [
                    314,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARI ) ;\n"
                ],
                [
                    315,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARDW ) ;\n"
                ],
                [
                    316,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARDH ) ;\n"
                ],
                [
                    317,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARDX ) ;\n"
                ],
                [
                    318,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARDY ) ;\n"
                ],
                [
                    320,
                    " cleanup3 : if ( ! params . SBHUFF ) {\n"
                ],
                [
                    321,
                    " jbig2_arith_int_ctx_free ( ctx , params . IADT ) ;\n"
                ],
                [
                    322,
                    " jbig2_arith_int_ctx_free ( ctx , params . IAFS ) ;\n"
                ],
                [
                    323,
                    " jbig2_arith_int_ctx_free ( ctx , params . IADS ) ;\n"
                ],
                [
                    324,
                    " jbig2_arith_int_ctx_free ( ctx , params . IAIT ) ;\n"
                ],
                [
                    328,
                    " cleanup2 : jbig2_free ( ctx -> allocator , GR_stats ) ;\n"
                ],
                [
                    331,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFFS ) ;\n"
                ],
                [
                    332,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFDS ) ;\n"
                ],
                [
                    333,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFDT ) ;\n"
                ],
                [
                    334,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRDX ) ;\n"
                ],
                [
                    335,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRDY ) ;\n"
                ],
                [
                    336,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRDW ) ;\n"
                ],
                [
                    337,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRDH ) ;\n"
                ],
                [
                    338,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRSIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int jbig2_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n"
                ],
                [
                    16,
                    " if ( segment -> data_length < 17 ) goto too_short ;\n"
                ],
                [
                    22,
                    " memset ( & params , 0 , sizeof ( Jbig2TextRegionParams ) ) ;\n"
                ],
                [
                    247,
                    " GR_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n"
                ],
                [
                    248,
                    " if ( GR_stats == NULL ) {\n"
                ],
                [
                    252,
                    " memset ( GR_stats , 0 , stats_size ) ;\n"
                ],
                [
                    300,
                    " code = jbig2_decode_text_region ( ctx , segment , & params , ( const Jbig2SymbolDict * const * ) dicts , n_dicts , image , segment_data + offset , segment -> data_length - offset , GR_stats , as , ws ) ;\n"
                ],
                [
                    312,
                    " cleanup4 : if ( ! params . SBHUFF ) {\n"
                ],
                [
                    313,
                    " jbig2_arith_iaid_ctx_free ( ctx , params . IAID ) ;\n"
                ],
                [
                    314,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARI ) ;\n"
                ],
                [
                    315,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARDW ) ;\n"
                ],
                [
                    316,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARDH ) ;\n"
                ],
                [
                    317,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARDX ) ;\n"
                ],
                [
                    318,
                    " jbig2_arith_int_ctx_free ( ctx , params . IARDY ) ;\n"
                ],
                [
                    320,
                    " cleanup3 : if ( ! params . SBHUFF ) {\n"
                ],
                [
                    321,
                    " jbig2_arith_int_ctx_free ( ctx , params . IADT ) ;\n"
                ],
                [
                    322,
                    " jbig2_arith_int_ctx_free ( ctx , params . IAFS ) ;\n"
                ],
                [
                    323,
                    " jbig2_arith_int_ctx_free ( ctx , params . IADS ) ;\n"
                ],
                [
                    324,
                    " jbig2_arith_int_ctx_free ( ctx , params . IAIT ) ;\n"
                ],
                [
                    328,
                    " cleanup2 : jbig2_free ( ctx -> allocator , GR_stats ) ;\n"
                ],
                [
                    331,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFFS ) ;\n"
                ],
                [
                    332,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFDS ) ;\n"
                ],
                [
                    333,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFDT ) ;\n"
                ],
                [
                    334,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRDX ) ;\n"
                ],
                [
                    335,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRDY ) ;\n"
                ],
                [
                    336,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRDW ) ;\n"
                ],
                [
                    337,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRDH ) ;\n"
                ],
                [
                    338,
                    " jbig2_release_huffman_table ( ctx , params . SBHUFFRSIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int jbig2_decode_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2TextRegionParams * params , const Jbig2SymbolDict * const * dicts , const int n_dicts , Jbig2Image * image , const byte * data , const size_t size , Jbig2ArithCx * GR_stats , Jbig2ArithState * as , Jbig2WordStream * ws ) {\n uint32_t NINSTANCES ;\n uint32_t ID ;\n int32_t STRIPT ;\n int32_t FIRSTS ;\n int32_t DT ;\n int32_t DFS ;\n int32_t IDS ;\n int32_t CURS ;\n int32_t CURT ;\n int S , T ;\n int x , y ;\n bool first_symbol ;\n uint32_t index , SBNUMSYMS ;\n Jbig2Image * IB = NULL ;\n Jbig2HuffmanState * hs = NULL ;\n Jbig2HuffmanTable * SBSYMCODES = NULL ;\n int code = 0 ;\n int RI ;\n SBNUMSYMS = 0 ;\n for ( index = 0 ;\n index < n_dicts ;\n index ++ ) {\n SBNUMSYMS += dicts [ index ] -> n_symbols ;\n }\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"symbol list contains %d glyphs in %d dictionaries\" , SBNUMSYMS , n_dicts ) ;\n if ( params -> SBHUFF ) {\n Jbig2HuffmanTable * runcodes = NULL ;\n Jbig2HuffmanParams runcodeparams ;\n Jbig2HuffmanLine runcodelengths [ 35 ] ;\n Jbig2HuffmanLine * symcodelengths = NULL ;\n Jbig2HuffmanParams symcodeparams ;\n int err , len , range , r ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"huffman coded text region\" ) ;\n hs = jbig2_huffman_new ( ctx , ws ) ;\n if ( hs == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"failed to allocate storage for text region\" ) ;\n return - 1 ;\n }\n for ( index = 0 ;\n index < 35 ;\n index ++ ) {\n runcodelengths [ index ] . PREFLEN = jbig2_huffman_get_bits ( hs , 4 , & code ) ;\n if ( code < 0 ) goto cleanup1 ;\n runcodelengths [ index ] . RANGELEN = 0 ;\n runcodelengths [ index ] . RANGELOW = index ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \" read runcode%d length %d\" , index , runcodelengths [ index ] . PREFLEN ) ;\n }\n runcodeparams . HTOOB = 0 ;\n runcodeparams . lines = runcodelengths ;\n runcodeparams . n_lines = 35 ;\n runcodes = jbig2_build_huffman_table ( ctx , & runcodeparams ) ;\n if ( runcodes == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"error constructing symbol id runcode table!\" ) ;\n code = - 1 ;\n goto cleanup1 ;\n }\n symcodelengths = jbig2_new ( ctx , Jbig2HuffmanLine , SBNUMSYMS ) ;\n if ( symcodelengths == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"memory allocation failure reading symbol ID huffman table!\" ) ;\n code = - 1 ;\n goto cleanup1 ;\n }\n index = 0 ;\n while ( index < SBNUMSYMS ) {\n code = jbig2_huffman_get ( hs , runcodes , & err ) ;\n if ( err != 0 || code < 0 || code >= 35 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"error reading symbol ID huffman table!\" ) ;\n code = err ? err : - 1 ;\n goto cleanup1 ;\n }\n if ( code < 32 ) {\n len = code ;\n range = 1 ;\n }\n else {\n if ( code == 32 ) {\n if ( index < 1 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"error decoding symbol id table: run length with no antecedent!\" ) ;\n code = - 1 ;\n goto cleanup1 ;\n }\n len = symcodelengths [ index - 1 ] . PREFLEN ;\n }\n else {\n len = 0 ;\n }\n err = 0 ;\n if ( code == 32 ) range = jbig2_huffman_get_bits ( hs , 2 , & err ) + 3 ;\n else if ( code == 33 ) range = jbig2_huffman_get_bits ( hs , 3 , & err ) + 3 ;\n else if ( code == 34 ) range = jbig2_huffman_get_bits ( hs , 7 , & err ) + 11 ;\n if ( err < 0 ) goto cleanup1 ;\n }\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \" read runcode%d at index %d (length %d range %d)\" , code , index , len , range ) ;\n if ( index + range > SBNUMSYMS ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"runlength extends %d entries beyond the end of symbol id table!\" , index + range - SBNUMSYMS ) ;\n range = SBNUMSYMS - index ;\n }\n for ( r = 0 ;\n r < range ;\n r ++ ) {\n symcodelengths [ index + r ] . PREFLEN = len ;\n symcodelengths [ index + r ] . RANGELEN = 0 ;\n symcodelengths [ index + r ] . RANGELOW = index + r ;\n }\n index += r ;\n }\n if ( index < SBNUMSYMS ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"runlength codes do not cover the available symbol set\" ) ;\n }\n symcodeparams . HTOOB = 0 ;\n symcodeparams . lines = symcodelengths ;\n symcodeparams . n_lines = SBNUMSYMS ;\n jbig2_huffman_skip ( hs ) ;\n SBSYMCODES = jbig2_build_huffman_table ( ctx , & symcodeparams ) ;\n cleanup1 : jbig2_free ( ctx -> allocator , symcodelengths ) ;\n jbig2_release_huffman_table ( ctx , runcodes ) ;\n if ( SBSYMCODES == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"could not construct Symbol ID huffman table!\" ) ;\n jbig2_huffman_free ( ctx , hs ) ;\n return ( ( code != 0 ) ? code : - 1 ) ;\n }\n }\n jbig2_image_clear ( ctx , image , params -> SBDEFPIXEL ) ;\n if ( params -> SBHUFF ) {\n STRIPT = jbig2_huffman_get ( hs , params -> SBHUFFDT , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IADT , as , & STRIPT ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n STRIPT *= - ( params -> SBSTRIPS ) ;\n FIRSTS = 0 ;\n NINSTANCES = 0 ;\n while ( NINSTANCES < params -> SBNUMINSTANCES ) {\n if ( params -> SBHUFF ) {\n DT = jbig2_huffman_get ( hs , params -> SBHUFFDT , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IADT , as , & DT ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n DT *= params -> SBSTRIPS ;\n STRIPT += DT ;\n first_symbol = TRUE ;\n for ( ;\n ;\n ) {\n if ( first_symbol ) {\n if ( params -> SBHUFF ) {\n DFS = jbig2_huffman_get ( hs , params -> SBHUFFFS , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IAFS , as , & DFS ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n FIRSTS += DFS ;\n CURS = FIRSTS ;\n first_symbol = FALSE ;\n }\n else {\n if ( NINSTANCES > params -> SBNUMINSTANCES ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"too many NINSTANCES (%d) decoded\" , NINSTANCES ) ;\n break ;\n }\n if ( params -> SBHUFF ) {\n IDS = jbig2_huffman_get ( hs , params -> SBHUFFDS , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IADS , as , & IDS ) ;\n }\n if ( code ) {\n break ;\n }\n CURS += IDS + params -> SBDSOFFSET ;\n }\n if ( params -> SBSTRIPS == 1 ) {\n CURT = 0 ;\n }\n else if ( params -> SBHUFF ) {\n CURT = jbig2_huffman_get_bits ( hs , params -> LOGSBSTRIPS , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IAIT , as , & CURT ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n T = STRIPT + CURT ;\n if ( params -> SBHUFF ) {\n ID = jbig2_huffman_get ( hs , SBSYMCODES , & code ) ;\n }\n else {\n code = jbig2_arith_iaid_decode ( params -> IAID , as , ( int * ) & ID ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n if ( ID >= SBNUMSYMS ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"symbol id out of range! (%d/%d)\" , ID , SBNUMSYMS ) ;\n goto cleanup2 ;\n }\n {\n uint32_t id = ID ;\n index = 0 ;\n while ( id >= dicts [ index ] -> n_symbols ) id -= dicts [ index ++ ] -> n_symbols ;\n IB = jbig2_image_clone ( ctx , dicts [ index ] -> glyphs [ id ] ) ;\n if ( ! IB ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"missing glyph %d/%d!\" , index , id ) ;\n goto cleanup2 ;\n }\n }\n if ( params -> SBREFINE ) {\n if ( params -> SBHUFF ) {\n RI = jbig2_huffman_get_bits ( hs , 1 , & code ) ;\n }\n else {\n code = jbig2_arith_int_decode ( params -> IARI , as , & RI ) ;\n }\n if ( code < 0 ) goto cleanup2 ;\n }\n else {\n RI = 0 ;\n }\n if ( RI ) {\n Jbig2RefinementRegionParams rparams ;\n Jbig2Image * IBO ;\n int32_t RDW , RDH , RDX , RDY ;\n Jbig2Image * refimage ;\n int BMSIZE = 0 ;\n int code1 = 0 ;\n int code2 = 0 ;\n int code3 = 0 ;\n int code4 = 0 ;\n int code5 = 0 ;\n if ( ! params -> SBHUFF ) {\n code1 = jbig2_arith_int_decode ( params -> IARDW , as , & RDW ) ;\n code2 = jbig2_arith_int_decode ( params -> IARDH , as , & RDH ) ;\n code3 = jbig2_arith_int_decode ( params -> IARDX , as , & RDX ) ;\n code4 = jbig2_arith_int_decode ( params -> IARDY , as , & RDY ) ;\n }\n else {\n RDW = jbig2_huffman_get ( hs , params -> SBHUFFRDW , & code1 ) ;\n RDH = jbig2_huffman_get ( hs , params -> SBHUFFRDH , & code2 ) ;\n RDX = jbig2_huffman_get ( hs , params -> SBHUFFRDX , & code3 ) ;\n RDY = jbig2_huffman_get ( hs , params -> SBHUFFRDY , & code4 ) ;\n BMSIZE = jbig2_huffman_get ( hs , params -> SBHUFFRSIZE , & code5 ) ;\n jbig2_huffman_skip ( hs ) ;\n }\n if ( ( code1 < 0 ) || ( code2 < 0 ) || ( code3 < 0 ) || ( code4 < 0 ) || ( code5 < 0 ) ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"failed to decode data\" ) ;\n goto cleanup2 ;\n }\n IBO = IB ;\n refimage = jbig2_image_new ( ctx , IBO -> width + RDW , IBO -> height + RDH ) ;\n if ( refimage == NULL ) {\n jbig2_image_release ( ctx , IBO ) ;\n if ( params -> SBHUFF ) {\n jbig2_release_huffman_table ( ctx , SBSYMCODES ) ;\n }\n return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"couldn't allocate reference image\" ) ;\n }\n jbig2_image_clear ( ctx , refimage , 0x00 ) ;\n rparams . GRTEMPLATE = params -> SBRTEMPLATE ;\n rparams . reference = IBO ;\n rparams . DX = ( RDW >> 1 ) + RDX ;\n rparams . DY = ( RDH >> 1 ) + RDY ;\n rparams . TPGRON = 0 ;\n memcpy ( rparams . grat , params -> sbrat , 4 ) ;\n code = jbig2_decode_refinement_region ( ctx , segment , & rparams , as , refimage , GR_stats ) ;\n if ( code < 0 ) {\n jbig2_image_release ( ctx , refimage ) ;\n goto cleanup2 ;\n }\n IB = refimage ;\n jbig2_image_release ( ctx , IBO ) ;\n if ( params -> SBHUFF ) {\n jbig2_huffman_advance ( hs , BMSIZE ) ;\n }\n }\n if ( ( ! params -> TRANSPOSED ) && ( params -> REFCORNER > 1 ) ) {\n CURS += IB -> width - 1 ;\n }\n else if ( ( params -> TRANSPOSED ) && ! ( params -> REFCORNER & 1 ) ) {\n CURS += IB -> height - 1 ;\n }\n S = CURS ;\n if ( ! params -> TRANSPOSED ) {\n switch ( params -> REFCORNER ) {\n case JBIG2_CORNER_TOPLEFT : x = S ;\n y = T ;\n break ;\n case JBIG2_CORNER_TOPRIGHT : x = S - IB -> width + 1 ;\n y = T ;\n break ;\n case JBIG2_CORNER_BOTTOMLEFT : x = S ;\n y = T - IB -> height + 1 ;\n break ;\n default : case JBIG2_CORNER_BOTTOMRIGHT : x = S - IB -> width + 1 ;\n y = T - IB -> height + 1 ;\n break ;\n }\n }\n else {\n switch ( params -> REFCORNER ) {\n case JBIG2_CORNER_TOPLEFT : x = T ;\n y = S ;\n break ;\n case JBIG2_CORNER_TOPRIGHT : x = T - IB -> width + 1 ;\n y = S ;\n break ;\n case JBIG2_CORNER_BOTTOMLEFT : x = T ;\n y = S - IB -> height + 1 ;\n break ;\n default : case JBIG2_CORNER_BOTTOMRIGHT : x = T - IB -> width + 1 ;\n y = S - IB -> height + 1 ;\n break ;\n }\n }\n # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"composing glyph id %d: %dx%d @ (%d,%d) symbol %d/%d\" , ID , IB -> width , IB -> height , x , y , NINSTANCES + 1 , params -> SBNUMINSTANCES ) ;\n # endif code = jbig2_image_compose ( ctx , image , IB , x , y , params -> SBCOMBOP ) ;\n if ( code < 0 ) {\n jbig2_image_release ( ctx , IB ) ;\n goto cleanup2 ;\n }\n if ( ( ! params -> TRANSPOSED ) && ( params -> REFCORNER < 2 ) ) {\n CURS += IB -> width - 1 ;\n }\n else if ( ( params -> TRANSPOSED ) && ( params -> REFCORNER & 1 ) ) {\n CURS += IB -> height - 1 ;\n }\n NINSTANCES ++ ;\n jbig2_image_release ( ctx , IB ) ;\n }\n }\n cleanup2 : if ( params -> SBHUFF ) {\n jbig2_release_huffman_table ( ctx , SBSYMCODES ) ;\n }\n jbig2_huffman_free ( ctx , hs ) ;\n return code ;\n }",
        "hash": 4991783214228010911,
        "project": "debian",
        "size": 337,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int jbig2_decode_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2TextRegionParams * params , const Jbig2SymbolDict * const * dicts , const int n_dicts , Jbig2Image * image , const byte * data , const size_t size , Jbig2ArithCx * GR_stats , Jbig2ArithState * as , Jbig2WordStream * ws ) {\n"
                ],
                [
                    252,
                    " if ( refimage == NULL ) {\n"
                ],
                [
                    260,
                    " rparams . GRTEMPLATE = params -> SBRTEMPLATE ;\n"
                ],
                [
                    261,
                    " rparams . reference = IBO ;\n"
                ],
                [
                    262,
                    " rparams . DX = ( RDW >> 1 ) + RDX ;\n"
                ],
                [
                    263,
                    " rparams . DY = ( RDH >> 1 ) + RDY ;\n"
                ],
                [
                    264,
                    " rparams . TPGRON = 0 ;\n"
                ],
                [
                    265,
                    " memcpy ( rparams . grat , params -> sbrat , 4 ) ;\n"
                ],
                [
                    266,
                    " code = jbig2_decode_refinement_region ( ctx , segment , & rparams , as , refimage , GR_stats ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int jbig2_decode_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2TextRegionParams * params , const Jbig2SymbolDict * const * dicts , const int n_dicts , Jbig2Image * image , const byte * data , const size_t size , Jbig2ArithCx * GR_stats , Jbig2ArithState * as , Jbig2WordStream * ws ) {\n"
                ],
                [
                    252,
                    " if ( refimage == NULL ) {\n"
                ],
                [
                    260,
                    " rparams . GRTEMPLATE = params -> SBRTEMPLATE ;\n"
                ],
                [
                    261,
                    " rparams . reference = IBO ;\n"
                ],
                [
                    262,
                    " rparams . DX = ( RDW >> 1 ) + RDX ;\n"
                ],
                [
                    263,
                    " rparams . DY = ( RDH >> 1 ) + RDY ;\n"
                ],
                [
                    264,
                    " rparams . TPGRON = 0 ;\n"
                ],
                [
                    265,
                    " memcpy ( rparams . grat , params -> sbrat , 4 ) ;\n"
                ],
                [
                    266,
                    " code = jbig2_decode_refinement_region ( ctx , segment , & rparams , as , refimage , GR_stats ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int jbig2_immediate_generic_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n Jbig2RegionSegmentInfo rsi ;\n byte seg_flags ;\n int8_t gbat [ 8 ] ;\n int offset ;\n int gbat_bytes = 0 ;\n Jbig2GenericRegionParams params ;\n int code = 0 ;\n Jbig2Image * image = NULL ;\n Jbig2WordStream * ws = NULL ;\n Jbig2ArithState * as = NULL ;\n Jbig2ArithCx * GB_stats = NULL ;\n if ( segment -> data_length < 18 ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Segment too short\" ) ;\n jbig2_get_region_segment_info ( & rsi , segment_data ) ;\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"generic region: %d x %d @ (%d, %d), flags = %02x\" , rsi . width , rsi . height , rsi . x , rsi . y , rsi . flags ) ;\n seg_flags = segment_data [ 17 ] ;\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"segment flags = %02x\" , seg_flags ) ;\n if ( ( seg_flags & 1 ) && ( seg_flags & 6 ) ) jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"MMR is 1, but GBTEMPLATE is not 0\" ) ;\n if ( ! ( seg_flags & 1 ) ) {\n gbat_bytes = ( seg_flags & 6 ) ? 2 : 8 ;\n if ( 18 + gbat_bytes > segment -> data_length ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Segment too short\" ) ;\n memcpy ( gbat , segment_data + 18 , gbat_bytes ) ;\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"gbat: %d, %d\" , gbat [ 0 ] , gbat [ 1 ] ) ;\n }\n offset = 18 + gbat_bytes ;\n params . MMR = seg_flags & 1 ;\n params . GBTEMPLATE = ( seg_flags & 6 ) >> 1 ;\n params . TPGDON = ( seg_flags & 8 ) >> 3 ;\n params . USESKIP = 0 ;\n memcpy ( params . gbat , gbat , gbat_bytes ) ;\n image = jbig2_image_new ( ctx , rsi . width , rsi . height ) ;\n if ( image == NULL ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"unable to allocate generic image\" ) ;\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , \"allocated %d x %d image buffer for region decode results\" , rsi . width , rsi . height ) ;\n if ( params . MMR ) {\n code = jbig2_decode_generic_mmr ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , image ) ;\n }\n else {\n int stats_size = jbig2_generic_stats_size ( ctx , params . GBTEMPLATE ) ;\n GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n if ( GB_stats == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"unable to allocate GB_stats in jbig2_immediate_generic_region\" ) ;\n goto cleanup ;\n }\n memset ( GB_stats , 0 , stats_size ) ;\n ws = jbig2_word_stream_buf_new ( ctx , segment_data + offset , segment -> data_length - offset ) ;\n if ( ws == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"unable to allocate ws in jbig2_immediate_generic_region\" ) ;\n goto cleanup ;\n }\n as = jbig2_arith_new ( ctx , ws ) ;\n if ( as == NULL ) {\n code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"unable to allocate as in jbig2_immediate_generic_region\" ) ;\n goto cleanup ;\n }\n code = jbig2_decode_generic_region ( ctx , segment , & params , as , image , GB_stats ) ;\n }\n if ( code >= 0 ) jbig2_page_add_result ( ctx , & ctx -> pages [ ctx -> current_page ] , image , rsi . x , rsi . y , rsi . op ) ;\n else jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"error while decoding immediate_generic_region\" ) ;\n cleanup : jbig2_free ( ctx -> allocator , as ) ;\n jbig2_word_stream_buf_free ( ctx , ws ) ;\n jbig2_free ( ctx -> allocator , GB_stats ) ;\n jbig2_image_release ( ctx , image ) ;\n return code ;\n }",
        "hash": 8458201026073747179,
        "project": "debian",
        "size": 64,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int jbig2_immediate_generic_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n"
                ],
                [
                    4,
                    " int8_t gbat [ 8 ] ;\n"
                ],
                [
                    6,
                    " int gbat_bytes = 0 ;\n"
                ],
                [
                    14,
                    " jbig2_get_region_segment_info ( & rsi , segment_data ) ;\n"
                ],
                [
                    19,
                    " if ( ! ( seg_flags & 1 ) ) {\n"
                ],
                [
                    20,
                    " gbat_bytes = ( seg_flags & 6 ) ? 2 : 8 ;\n"
                ],
                [
                    21,
                    " if ( 18 + gbat_bytes > segment -> data_length ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Segment too short\" ) ;\n"
                ],
                [
                    22,
                    " memcpy ( gbat , segment_data + 18 , gbat_bytes ) ;\n"
                ],
                [
                    23,
                    " jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"gbat: %d, %d\" , gbat [ 0 ] , gbat [ 1 ] ) ;\n"
                ],
                [
                    25,
                    " offset = 18 + gbat_bytes ;\n"
                ],
                [
                    30,
                    " memcpy ( params . gbat , gbat , gbat_bytes ) ;\n"
                ],
                [
                    35,
                    " code = jbig2_decode_generic_mmr ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , image ) ;\n"
                ],
                [
                    55,
                    " code = jbig2_decode_generic_region ( ctx , segment , & params , as , image , GB_stats ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int jbig2_immediate_generic_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n"
                ],
                [
                    39,
                    " GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n"
                ],
                [
                    40,
                    " if ( GB_stats == NULL ) {\n"
                ],
                [
                    44,
                    " memset ( GB_stats , 0 , stats_size ) ;\n"
                ],
                [
                    55,
                    " code = jbig2_decode_generic_region ( ctx , segment , & params , as , image , GB_stats ) ;\n"
                ],
                [
                    61,
                    " jbig2_free ( ctx -> allocator , GB_stats ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int jbig2_immediate_generic_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n"
                ],
                [
                    4,
                    " int8_t gbat [ 8 ] ;\n"
                ],
                [
                    6,
                    " int gbat_bytes = 0 ;\n"
                ],
                [
                    14,
                    " jbig2_get_region_segment_info ( & rsi , segment_data ) ;\n"
                ],
                [
                    19,
                    " if ( ! ( seg_flags & 1 ) ) {\n"
                ],
                [
                    20,
                    " gbat_bytes = ( seg_flags & 6 ) ? 2 : 8 ;\n"
                ],
                [
                    21,
                    " if ( 18 + gbat_bytes > segment -> data_length ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , \"Segment too short\" ) ;\n"
                ],
                [
                    22,
                    " memcpy ( gbat , segment_data + 18 , gbat_bytes ) ;\n"
                ],
                [
                    23,
                    " jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"gbat: %d, %d\" , gbat [ 0 ] , gbat [ 1 ] ) ;\n"
                ],
                [
                    25,
                    " offset = 18 + gbat_bytes ;\n"
                ],
                [
                    30,
                    " memcpy ( params . gbat , gbat , gbat_bytes ) ;\n"
                ],
                [
                    35,
                    " code = jbig2_decode_generic_mmr ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , image ) ;\n"
                ],
                [
                    39,
                    " GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n"
                ],
                [
                    40,
                    " if ( GB_stats == NULL ) {\n"
                ],
                [
                    44,
                    " memset ( GB_stats , 0 , stats_size ) ;\n"
                ],
                [
                    55,
                    " code = jbig2_decode_generic_region ( ctx , segment , & params , as , image , GB_stats ) ;\n"
                ],
                [
                    61,
                    " jbig2_free ( ctx -> allocator , GB_stats ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int jbig2_decode_halftone_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , Jbig2HalftoneRegionParams * params , const byte * data , const size_t size , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n uint32_t HBPP ;\n uint32_t HNUMPATS ;\n uint8_t * * GI ;\n Jbig2Image * HSKIP = NULL ;\n Jbig2PatternDict * HPATS ;\n int i ;\n uint32_t mg , ng ;\n int32_t x , y ;\n uint8_t gray_val ;\n memset ( image -> data , params -> HDEFPIXEL , image -> stride * image -> height ) ;\n if ( params -> HENABLESKIP == 1 ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unhandled option HENABLESKIP\" ) ;\n }\n HPATS = jbig2_decode_ht_region_get_hpats ( ctx , segment ) ;\n if ( ! HPATS ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"no pattern dictionary found, skipping halftone image\" ) ;\n return - 1 ;\n }\n HNUMPATS = HPATS -> n_patterns ;\n HBPP = 0 ;\n while ( HNUMPATS > ( 1 << ++ HBPP ) ) ;\n GI = jbig2_decode_gray_scale_image ( ctx , segment , data , size , params -> HMMR , params -> HGW , params -> HGH , HBPP , params -> HENABLESKIP , HSKIP , params -> HTEMPLATE , GB_stats ) ;\n if ( ! GI ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"unable to acquire gray-scale image, skipping halftone image\" ) ;\n return - 1 ;\n }\n for ( mg = 0 ;\n mg < params -> HGH ;\n ++ mg ) {\n for ( ng = 0 ;\n ng < params -> HGW ;\n ++ ng ) {\n x = ( params -> HGX + mg * params -> HRY + ng * params -> HRX ) >> 8 ;\n y = ( params -> HGY + mg * params -> HRX - ng * params -> HRY ) >> 8 ;\n gray_val = GI [ ng ] [ mg ] ;\n if ( gray_val >= HNUMPATS ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"gray-scale image uses value %d which larger than pattern dictionary\" , gray_val ) ;\n gray_val = HNUMPATS - 1 ;\n }\n jbig2_image_compose ( ctx , image , HPATS -> patterns [ gray_val ] , x , y , params -> op ) ;\n }\n }\n for ( i = 0 ;\n i < params -> HGW ;\n ++ i ) {\n jbig2_free ( ctx -> allocator , GI [ i ] ) ;\n }\n jbig2_free ( ctx -> allocator , GI ) ;\n return 0 ;\n }",
        "hash": -3955770052982962380,
        "project": "debian",
        "size": 51,
        "slice": {
            "memset": [
                [
                    1,
                    "int jbig2_decode_halftone_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , Jbig2HalftoneRegionParams * params , const byte * data , const size_t size , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n"
                ],
                [
                    11,
                    " memset ( image -> data , params -> HDEFPIXEL , image -> stride * image -> height ) ;\n"
                ],
                [
                    41,
                    " jbig2_image_compose ( ctx , image , HPATS -> patterns [ gray_val ] , x , y , params -> op ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int jbig2_decode_halftone_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , Jbig2HalftoneRegionParams * params , const byte * data , const size_t size , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n"
                ],
                [
                    11,
                    " memset ( image -> data , params -> HDEFPIXEL , image -> stride * image -> height ) ;\n"
                ],
                [
                    41,
                    " jbig2_image_compose ( ctx , image , HPATS -> patterns [ gray_val ] , x , y , params -> op ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int jbig2_decode_generic_mmr ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image ) {\n Jbig2MmrCtx mmr ;\n const int rowstride = image -> stride ;\n byte * dst = image -> data ;\n byte * ref = NULL ;\n int y ;\n int code = 0 ;\n jbig2_decode_mmr_init ( & mmr , image -> width , image -> height , data , size ) ;\n for ( y = 0 ;\n y < image -> height ;\n y ++ ) {\n memset ( dst , 0 , rowstride ) ;\n code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n if ( code < 0 ) return code ;\n ref = dst ;\n dst += rowstride ;\n }\n return code ;\n }",
        "hash": 1286774465219423144,
        "project": "debian",
        "size": 19,
        "slice": {
            "memset": [
                [
                    1,
                    "int jbig2_decode_generic_mmr ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image ) {\n"
                ],
                [
                    3,
                    " const int rowstride = image -> stride ;\n"
                ],
                [
                    4,
                    " byte * dst = image -> data ;\n"
                ],
                [
                    10,
                    " y < image -> height ;\n"
                ],
                [
                    12,
                    " memset ( dst , 0 , rowstride ) ;\n"
                ],
                [
                    13,
                    " code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n"
                ],
                [
                    16,
                    " dst += rowstride ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int jbig2_decode_generic_mmr ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image ) {\n"
                ],
                [
                    3,
                    " const int rowstride = image -> stride ;\n"
                ],
                [
                    4,
                    " byte * dst = image -> data ;\n"
                ],
                [
                    10,
                    " y < image -> height ;\n"
                ],
                [
                    12,
                    " memset ( dst , 0 , rowstride ) ;\n"
                ],
                [
                    13,
                    " code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n"
                ],
                [
                    16,
                    " dst += rowstride ;\n"
                ]
            ]
        }
    },
    {
        "code": "int jbig2_decode_halftone_mmr ( Jbig2Ctx * ctx , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image , size_t * consumed_bytes ) {\n Jbig2MmrCtx mmr ;\n const int rowstride = image -> stride ;\n byte * dst = image -> data ;\n byte * ref = NULL ;\n int y ;\n int code = 0 ;\n const uint32_t EOFB = 0x001001 ;\n jbig2_decode_mmr_init ( & mmr , image -> width , image -> height , data , size ) ;\n for ( y = 0 ;\n y < image -> height ;\n y ++ ) {\n memset ( dst , 0 , rowstride ) ;\n code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n if ( code < 0 ) return code ;\n ref = dst ;\n dst += rowstride ;\n }\n if ( mmr . word >> 8 == EOFB ) {\n mmr . data_index += 3 ;\n }\n * consumed_bytes += mmr . data_index + ( mmr . bit_index >> 3 ) + ( mmr . bit_index > 0 ? 1 : 0 ) ;\n return code ;\n }",
        "hash": 1286774465219423144,
        "project": "debian",
        "size": 24,
        "slice": {
            "memset": [
                [
                    1,
                    "int jbig2_decode_halftone_mmr ( Jbig2Ctx * ctx , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image , size_t * consumed_bytes ) {\n"
                ],
                [
                    3,
                    " const int rowstride = image -> stride ;\n"
                ],
                [
                    4,
                    " byte * dst = image -> data ;\n"
                ],
                [
                    11,
                    " y < image -> height ;\n"
                ],
                [
                    13,
                    " memset ( dst , 0 , rowstride ) ;\n"
                ],
                [
                    14,
                    " code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n"
                ],
                [
                    17,
                    " dst += rowstride ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int jbig2_decode_halftone_mmr ( Jbig2Ctx * ctx , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image , size_t * consumed_bytes ) {\n"
                ],
                [
                    3,
                    " const int rowstride = image -> stride ;\n"
                ],
                [
                    4,
                    " byte * dst = image -> data ;\n"
                ],
                [
                    11,
                    " y < image -> height ;\n"
                ],
                [
                    13,
                    " memset ( dst , 0 , rowstride ) ;\n"
                ],
                [
                    14,
                    " code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n"
                ],
                [
                    17,
                    " dst += rowstride ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int gdev_pdf_put_params_impl ( gx_device * dev , const gx_device_pdf * save_dev , gs_param_list * plist ) {\n int ecode , code ;\n gx_device_pdf * pdev = ( gx_device_pdf * ) dev ;\n float cl = ( float ) pdev -> CompatibilityLevel ;\n bool locked = pdev -> params . LockDistillerParams , ForOPDFRead ;\n gs_param_name param_name ;\n pdev -> pdf_memory = gs_memory_stable ( pdev -> memory ) ;\n {\n gs_param_string_array ppa ;\n gs_param_string pps ;\n code = param_read_string_array ( plist , ( param_name = \"pdfmark\" ) , & ppa ) ;\n switch ( code ) {\n case 0 : code = pdfwrite_pdf_open_document ( pdev ) ;\n if ( code < 0 ) return code ;\n code = pdfmark_process ( pdev , & ppa ) ;\n if ( code >= 0 ) return code ;\n default : param_signal_error ( plist , param_name , code ) ;\n return code ;\n case 1 : break ;\n }\n code = param_read_string_array ( plist , ( param_name = \"DSC\" ) , & ppa ) ;\n switch ( code ) {\n case 0 : code = pdfwrite_pdf_open_document ( pdev ) ;\n if ( code < 0 ) return code ;\n code = pdf_dsc_process ( pdev , & ppa ) ;\n if ( code >= 0 ) return code ;\n default : param_signal_error ( plist , param_name , code ) ;\n return code ;\n case 1 : break ;\n }\n code = param_read_string ( plist , ( param_name = \"pdfpagelabels\" ) , & pps ) ;\n switch ( code ) {\n case 0 : {\n if ( ! pdev -> ForOPDFRead ) {\n cos_dict_t * const pcd = pdev -> Catalog ;\n code = pdfwrite_pdf_open_document ( pdev ) ;\n if ( code < 0 ) return code ;\n code = cos_dict_put_string ( pcd , ( const byte * ) \"/PageLabels\" , 11 , pps . data , pps . size ) ;\n if ( code >= 0 ) return code ;\n }\n else return 0 ;\n }\n default : param_signal_error ( plist , param_name , code ) ;\n return code ;\n case 1 : break ;\n }\n }\n ecode = param_read_bool ( plist , \"LockDistillerParams\" , & locked ) ;\n if ( ecode < 0 ) param_signal_error ( plist , param_name , ecode ) ;\n {\n int efo = 1 ;\n ecode = param_put_int ( plist , ( param_name = \".EmbedFontObjects\" ) , & efo , ecode ) ;\n if ( ecode < 0 ) param_signal_error ( plist , param_name , ecode ) ;\n if ( efo != 1 ) param_signal_error ( plist , param_name , ecode = gs_error_rangecheck ) ;\n }\n {\n int cdv = CoreDistVersion ;\n ecode = param_put_int ( plist , ( param_name = \"CoreDistVersion\" ) , & cdv , ecode ) ;\n if ( ecode < 0 ) return gs_note_error ( ecode ) ;\n if ( cdv != CoreDistVersion ) param_signal_error ( plist , param_name , ecode = gs_error_rangecheck ) ;\n }\n switch ( code = param_read_float ( plist , ( param_name = \"CompatibilityLevel\" ) , & cl ) ) {\n default : ecode = code ;\n param_signal_error ( plist , param_name , ecode ) ;\n break ;\n case 0 : if ( ! ( locked && pdev -> params . LockDistillerParams ) ) {\n if ( cl < ( float ) 1.15 ) cl = ( float ) 1.1 ;\n else if ( cl < ( float ) 1.25 ) cl = ( float ) 1.2 ;\n else if ( cl < ( float ) 1.35 ) cl = ( float ) 1.3 ;\n else if ( cl < ( float ) 1.45 ) cl = ( float ) 1.4 ;\n else if ( cl < ( float ) 1.55 ) cl = ( float ) 1.5 ;\n else if ( cl < ( float ) 1.65 ) cl = ( float ) 1.6 ;\n else if ( cl < ( float ) 1.75 ) cl = ( float ) 1.7 ;\n else {\n cl = ( float ) 2.0 ;\n if ( pdev -> params . TransferFunctionInfo == tfi_Preserve ) pdev -> params . TransferFunctionInfo = tfi_Apply ;\n }\n }\n case 1 : break ;\n }\n {\n gs_memory_t * mem = plist -> memory ;\n plist -> memory = pdev -> pdf_memory ;\n code = gs_param_read_items ( plist , pdev , pdf_param_items ) ;\n if ( code < 0 || ( code = param_read_bool ( plist , \"ForOPDFRead\" , & ForOPDFRead ) ) < 0 ) {\n }\n if ( code == 0 && ! pdev -> is_ps2write && ! ( locked && pdev -> params . LockDistillerParams ) ) pdev -> ForOPDFRead = ForOPDFRead ;\n plist -> memory = mem ;\n }\n if ( code < 0 ) ecode = code ;\n {\n long fon = pdev -> FirstObjectNumber ;\n if ( fon != save_dev -> FirstObjectNumber ) {\n if ( fon <= 0 || fon > 0x7fff0000 || ( pdev -> next_id != 0 && pdev -> next_id != save_dev -> FirstObjectNumber + pdf_num_initial_ids ) ) {\n ecode = gs_error_rangecheck ;\n param_signal_error ( plist , \"FirstObjectNumber\" , ecode ) ;\n }\n }\n }\n {\n static const char * const pcm_names [ ] = {\n \"DeviceGray\" , \"DeviceRGB\" , \"DeviceCMYK\" , \"DeviceN\" , 0 }\n ;\n int pcm = - 1 ;\n ecode = param_put_enum ( plist , \"ProcessColorModel\" , & pcm , pcm_names , ecode ) ;\n if ( pcm >= 0 ) {\n pdf_set_process_color_model ( pdev , pcm ) ;\n rc_decrement ( pdev -> icc_struct , \"gdev_pdf_put_params_impl, ProcessColorModel changed\" ) ;\n pdev -> icc_struct = 0 ;\n }\n }\n if ( ecode < 0 ) goto fail ;\n if ( pdev -> is_ps2write && ( code = param_read_bool ( plist , \"ProduceDSC\" , & pdev -> ProduceDSC ) ) < 0 ) {\n param_signal_error ( plist , param_name , code ) ;\n }\n if ( pdev -> PDFA < 0 || pdev -> PDFA > 3 ) {\n ecode = gs_note_error ( gs_error_rangecheck ) ;\n param_signal_error ( plist , \"PDFA\" , ecode ) ;\n goto fail ;\n }\n if ( pdev -> PDFA != 0 && pdev -> AbortPDFAX ) pdev -> PDFA = 0 ;\n if ( pdev -> PDFX && pdev -> AbortPDFAX ) pdev -> PDFX = 0 ;\n if ( pdev -> PDFX && pdev -> PDFA != 0 ) {\n ecode = gs_note_error ( gs_error_rangecheck ) ;\n param_signal_error ( plist , \"PDFA\" , ecode ) ;\n goto fail ;\n }\n if ( pdev -> PDFX && pdev -> ForOPDFRead ) {\n ecode = gs_note_error ( gs_error_rangecheck ) ;\n param_signal_error ( plist , \"PDFX\" , ecode ) ;\n goto fail ;\n }\n if ( pdev -> PDFA != 0 && pdev -> ForOPDFRead ) {\n ecode = gs_note_error ( gs_error_rangecheck ) ;\n param_signal_error ( plist , \"PDFA\" , ecode ) ;\n goto fail ;\n }\n if ( pdev -> PDFA == 1 || pdev -> PDFX || pdev -> CompatibilityLevel < 1.4 ) {\n pdev -> HaveTransparency = false ;\n pdev -> PreserveSMask = false ;\n }\n if ( pdev -> PDFX ) cl = ( float ) 1.3 ;\n if ( pdev -> PDFA != 0 && cl < 1.4 ) cl = ( float ) 1.4 ;\n pdev -> version = ( cl < 1.2 ? psdf_version_level2 : psdf_version_ll3 ) ;\n if ( pdev -> ForOPDFRead ) {\n pdev -> ResourcesBeforeUsage = true ;\n pdev -> HaveCFF = false ;\n pdev -> HavePDFWidths = false ;\n pdev -> HaveStrokeColor = false ;\n cl = ( float ) 1.2 ;\n pdev -> MaxInlineImageSize = max_long ;\n pdev -> version = psdf_version_level2 ;\n }\n else {\n pdev -> ResourcesBeforeUsage = false ;\n pdev -> HaveCFF = true ;\n pdev -> HavePDFWidths = true ;\n pdev -> HaveStrokeColor = true ;\n }\n pdev -> ParamCompatibilityLevel = cl ;\n if ( cl < 1.2 ) {\n pdev -> HaveCFF = false ;\n }\n ecode = gdev_psdf_put_params ( dev , plist ) ;\n if ( ecode < 0 ) goto fail ;\n if ( pdev -> CompatibilityLevel > 1.7 && pdev -> params . TransferFunctionInfo == tfi_Preserve ) {\n pdev -> params . TransferFunctionInfo = tfi_Apply ;\n emprintf ( pdev -> memory , \"\\nIt is not possible to preserve transfer functions in PDF 2.0\\ntransfer functions will be applied instead\\n\" ) ;\n }\n if ( pdev -> params . ConvertCMYKImagesToRGB ) {\n if ( pdev -> params . ColorConversionStrategy == ccs_CMYK ) {\n emprintf ( pdev -> memory , \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\\n\" ) ;\n }\n else {\n if ( pdev -> params . ColorConversionStrategy == ccs_Gray ) {\n emprintf ( pdev -> memory , \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\\n\" ) ;\n }\n else {\n if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n pdf_set_process_color_model ( pdev , 1 ) ;\n ecode = gsicc_init_device_profile_struct ( ( gx_device * ) pdev , NULL , 0 ) ;\n if ( ecode < 0 ) goto fail ;\n }\n }\n }\n switch ( pdev -> params . ColorConversionStrategy ) {\n case ccs_ByObjectType : case ccs_LeaveColorUnchanged : break ;\n case ccs_UseDeviceDependentColor : case ccs_UseDeviceIndependentColor : case ccs_UseDeviceIndependentColorForImages : pdev -> params . TransferFunctionInfo = tfi_Apply ;\n break ;\n case ccs_CMYK : pdev -> params . TransferFunctionInfo = tfi_Apply ;\n if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n pdf_set_process_color_model ( pdev , 2 ) ;\n ecode = gsicc_init_device_profile_struct ( ( gx_device * ) pdev , NULL , 0 ) ;\n if ( ecode < 0 ) goto fail ;\n break ;\n case ccs_Gray : pdev -> params . TransferFunctionInfo = tfi_Apply ;\n if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n pdf_set_process_color_model ( pdev , 0 ) ;\n ecode = gsicc_init_device_profile_struct ( ( gx_device * ) pdev , NULL , 0 ) ;\n if ( ecode < 0 ) goto fail ;\n break ;\n case ccs_sRGB : case ccs_RGB : pdev -> params . TransferFunctionInfo = tfi_Apply ;\n if ( ! pdev -> params . ConvertCMYKImagesToRGB ) {\n if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n pdf_set_process_color_model ( pdev , 1 ) ;\n ecode = gsicc_init_device_profile_struct ( ( gx_device * ) pdev , NULL , 0 ) ;\n if ( ecode < 0 ) goto fail ;\n }\n break ;\n default : break ;\n }\n if ( cl < 1.5f && pdev -> params . ColorImage . Filter != NULL && ! strcmp ( pdev -> params . ColorImage . Filter , \"JPXEncode\" ) ) {\n emprintf ( pdev -> memory , \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\" ) ;\n ecode = gs_note_error ( gs_error_rangecheck ) ;\n }\n if ( cl < 1.5f && pdev -> params . GrayImage . Filter != NULL && ! strcmp ( pdev -> params . GrayImage . Filter , \"JPXEncode\" ) ) {\n emprintf ( pdev -> memory , \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\" ) ;\n ecode = gs_note_error ( gs_error_rangecheck ) ;\n }\n if ( cl < 1.4f && pdev -> params . MonoImage . Filter != NULL && ! strcmp ( pdev -> params . MonoImage . Filter , \"JBIG2Encode\" ) ) {\n emprintf ( pdev -> memory , \"JBIG2Encode requires CompatibilityLevel >= 1.4 .\\n\" ) ;\n ecode = gs_note_error ( gs_error_rangecheck ) ;\n }\n if ( pdev -> HaveTrueTypes && pdev -> version == psdf_version_level2 ) {\n pdev -> version = psdf_version_level2_with_TT ;\n }\n if ( ecode < 0 ) goto fail ;\n if ( pdev -> FirstObjectNumber != save_dev -> FirstObjectNumber ) {\n if ( pdev -> xref . file != 0 ) {\n if ( gp_fseek_64 ( pdev -> xref . file , 0L , SEEK_SET ) != 0 ) {\n ecode = gs_error_ioerror ;\n goto fail ;\n }\n pdf_initialize_ids ( pdev ) ;\n }\n }\n pdev -> CompatibilityLevel = ( int ) ( cl * 10 + 0.5 ) / 10.0 ;\n if ( pdev -> OwnerPassword . size != save_dev -> OwnerPassword . size || ( pdev -> OwnerPassword . size != 0 && memcmp ( pdev -> OwnerPassword . data , save_dev -> OwnerPassword . data , pdev -> OwnerPassword . size ) != 0 ) ) {\n if ( pdev -> is_open ) {\n if ( pdev -> PageCount == 0 ) {\n gs_closedevice ( ( gx_device * ) save_dev ) ;\n return 0 ;\n }\n else emprintf ( pdev -> memory , \"Owner Password changed mid-job, ignoring.\\n\" ) ;\n }\n }\n if ( pdev -> Linearise && pdev -> is_ps2write ) {\n emprintf ( pdev -> memory , \"Can't linearise PostScript output, ignoring\\n\" ) ;\n pdev -> Linearise = false ;\n }\n if ( pdev -> Linearise && pdev -> OwnerPassword . size != 0 ) {\n emprintf ( pdev -> memory , \"Can't linearise encrypted PDF, ignoring\\n\" ) ;\n pdev -> Linearise = false ;\n }\n if ( pdev -> FlattenFonts ) pdev -> PreserveTrMode = false ;\n return 0 ;\n fail : pdev -> version = save_dev -> version ;\n pdf_set_process_color_model ( pdev , save_dev -> pcm_color_info_index ) ;\n pdev -> saved_fill_color = save_dev -> saved_fill_color ;\n pdev -> saved_stroke_color = save_dev -> saved_fill_color ;\n {\n const gs_param_item_t * ppi = pdf_param_items ;\n for ( ;\n ppi -> key ;\n ++ ppi ) memcpy ( ( char * ) pdev + ppi -> offset , ( char * ) save_dev + ppi -> offset , gs_param_type_sizes [ ppi -> type ] ) ;\n pdev -> ForOPDFRead = save_dev -> ForOPDFRead ;\n }\n return ecode ;\n }",
        "hash": 8139827869427659905,
        "project": "debian",
        "size": 269,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int gdev_pdf_put_params_impl ( gx_device * dev , const gx_device_pdf * save_dev , gs_param_list * plist ) {\n"
                ],
                [
                    3,
                    " gx_device_pdf * pdev = ( gx_device_pdf * ) dev ;\n"
                ],
                [
                    7,
                    " pdev -> pdf_memory = gs_memory_stable ( pdev -> memory ) ;\n"
                ],
                [
                    84,
                    " code = gs_param_read_items ( plist , pdev , pdf_param_items ) ;\n"
                ],
                [
                    87,
                    " if ( code == 0 && ! pdev -> is_ps2write && ! ( locked && pdev -> params . LockDistillerParams ) ) pdev -> ForOPDFRead = ForOPDFRead ;\n"
                ],
                [
                    93,
                    " if ( fon != save_dev -> FirstObjectNumber ) {\n"
                ],
                [
                    94,
                    " if ( fon <= 0 || fon > 0x7fff0000 || ( pdev -> next_id != 0 && pdev -> next_id != save_dev -> FirstObjectNumber + pdf_num_initial_ids ) ) {\n"
                ],
                [
                    107,
                    " pdf_set_process_color_model ( pdev , pcm ) ;\n"
                ],
                [
                    109,
                    " pdev -> icc_struct = 0 ;\n"
                ],
                [
                    113,
                    " if ( pdev -> is_ps2write && ( code = param_read_bool ( plist , \"ProduceDSC\" , & pdev -> ProduceDSC ) ) < 0 ) {\n"
                ],
                [
                    116,
                    " if ( pdev -> PDFA < 0 || pdev -> PDFA > 3 ) {\n"
                ],
                [
                    121,
                    " if ( pdev -> PDFA != 0 && pdev -> AbortPDFAX ) pdev -> PDFA = 0 ;\n"
                ],
                [
                    122,
                    " if ( pdev -> PDFX && pdev -> AbortPDFAX ) pdev -> PDFX = 0 ;\n"
                ],
                [
                    123,
                    " if ( pdev -> PDFX && pdev -> PDFA != 0 ) {\n"
                ],
                [
                    128,
                    " if ( pdev -> PDFX && pdev -> ForOPDFRead ) {\n"
                ],
                [
                    133,
                    " if ( pdev -> PDFA != 0 && pdev -> ForOPDFRead ) {\n"
                ],
                [
                    138,
                    " if ( pdev -> PDFA == 1 || pdev -> PDFX || pdev -> CompatibilityLevel < 1.4 ) {\n"
                ],
                [
                    139,
                    " pdev -> HaveTransparency = false ;\n"
                ],
                [
                    140,
                    " pdev -> PreserveSMask = false ;\n"
                ],
                [
                    143,
                    " if ( pdev -> PDFA != 0 && cl < 1.4 ) cl = ( float ) 1.4 ;\n"
                ],
                [
                    146,
                    " pdev -> ResourcesBeforeUsage = true ;\n"
                ],
                [
                    147,
                    " pdev -> HaveCFF = false ;\n"
                ],
                [
                    148,
                    " pdev -> HavePDFWidths = false ;\n"
                ],
                [
                    149,
                    " pdev -> HaveStrokeColor = false ;\n"
                ],
                [
                    151,
                    " pdev -> MaxInlineImageSize = max_long ;\n"
                ],
                [
                    155,
                    " pdev -> ResourcesBeforeUsage = false ;\n"
                ],
                [
                    156,
                    " pdev -> HaveCFF = true ;\n"
                ],
                [
                    157,
                    " pdev -> HavePDFWidths = true ;\n"
                ],
                [
                    158,
                    " pdev -> HaveStrokeColor = true ;\n"
                ],
                [
                    160,
                    " pdev -> ParamCompatibilityLevel = cl ;\n"
                ],
                [
                    162,
                    " pdev -> HaveCFF = false ;\n"
                ],
                [
                    166,
                    " if ( pdev -> CompatibilityLevel > 1.7 && pdev -> params . TransferFunctionInfo == tfi_Preserve ) {\n"
                ],
                [
                    168,
                    " emprintf ( pdev -> memory , \"\\nIt is not possible to preserve transfer functions in PDF 2.0\\ntransfer functions will be applied instead\\n\" ) ;\n"
                ],
                [
                    172,
                    " emprintf ( pdev -> memory , \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\\n\" ) ;\n"
                ],
                [
                    176,
                    " emprintf ( pdev -> memory , \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\\n\" ) ;\n"
                ],
                [
                    179,
                    " if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n"
                ],
                [
                    191,
                    " if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n"
                ],
                [
                    197,
                    " if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n"
                ],
                [
                    204,
                    " if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n"
                ],
                [
                    213,
                    " emprintf ( pdev -> memory , \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\" ) ;\n"
                ],
                [
                    217,
                    " emprintf ( pdev -> memory , \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\" ) ;\n"
                ],
                [
                    221,
                    " emprintf ( pdev -> memory , \"JBIG2Encode requires CompatibilityLevel >= 1.4 .\\n\" ) ;\n"
                ],
                [
                    224,
                    " if ( pdev -> HaveTrueTypes && pdev -> version == psdf_version_level2 ) {\n"
                ],
                [
                    228,
                    " if ( pdev -> FirstObjectNumber != save_dev -> FirstObjectNumber ) {\n"
                ],
                [
                    257,
                    " fail : pdev -> version = save_dev -> version ;\n"
                ],
                [
                    258,
                    " pdf_set_process_color_model ( pdev , save_dev -> pcm_color_info_index ) ;\n"
                ],
                [
                    259,
                    " pdev -> saved_fill_color = save_dev -> saved_fill_color ;\n"
                ],
                [
                    260,
                    " pdev -> saved_stroke_color = save_dev -> saved_fill_color ;\n"
                ],
                [
                    262,
                    " const gs_param_item_t * ppi = pdf_param_items ;\n"
                ],
                [
                    264,
                    " ppi -> key ;\n"
                ],
                [
                    265,
                    " ++ ppi ) memcpy ( ( char * ) pdev + ppi -> offset , ( char * ) save_dev + ppi -> offset , gs_param_type_sizes [ ppi -> type ] ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "static int gdev_pdf_put_params_impl ( gx_device * dev , const gx_device_pdf * save_dev , gs_param_list * plist ) {\n"
                ],
                [
                    238,
                    " if ( pdev -> OwnerPassword . size != save_dev -> OwnerPassword . size || ( pdev -> OwnerPassword . size != 0 && memcmp ( pdev -> OwnerPassword . data , save_dev -> OwnerPassword . data , pdev -> OwnerPassword . size ) != 0 ) ) {\n"
                ],
                [
                    251,
                    " if ( pdev -> Linearise && pdev -> OwnerPassword . size != 0 ) {\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "static int gdev_pdf_put_params_impl ( gx_device * dev , const gx_device_pdf * save_dev , gs_param_list * plist ) {\n"
                ],
                [
                    212,
                    " if ( cl < 1.5f && pdev -> params . ColorImage . Filter != NULL && ! strcmp ( pdev -> params . ColorImage . Filter , \"JPXEncode\" ) ) {\n"
                ],
                [
                    216,
                    " if ( cl < 1.5f && pdev -> params . GrayImage . Filter != NULL && ! strcmp ( pdev -> params . GrayImage . Filter , \"JPXEncode\" ) ) {\n"
                ],
                [
                    220,
                    " if ( cl < 1.4f && pdev -> params . MonoImage . Filter != NULL && ! strcmp ( pdev -> params . MonoImage . Filter , \"JBIG2Encode\" ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int gdev_pdf_put_params_impl ( gx_device * dev , const gx_device_pdf * save_dev , gs_param_list * plist ) {\n"
                ],
                [
                    3,
                    " gx_device_pdf * pdev = ( gx_device_pdf * ) dev ;\n"
                ],
                [
                    7,
                    " pdev -> pdf_memory = gs_memory_stable ( pdev -> memory ) ;\n"
                ],
                [
                    84,
                    " code = gs_param_read_items ( plist , pdev , pdf_param_items ) ;\n"
                ],
                [
                    87,
                    " if ( code == 0 && ! pdev -> is_ps2write && ! ( locked && pdev -> params . LockDistillerParams ) ) pdev -> ForOPDFRead = ForOPDFRead ;\n"
                ],
                [
                    93,
                    " if ( fon != save_dev -> FirstObjectNumber ) {\n"
                ],
                [
                    94,
                    " if ( fon <= 0 || fon > 0x7fff0000 || ( pdev -> next_id != 0 && pdev -> next_id != save_dev -> FirstObjectNumber + pdf_num_initial_ids ) ) {\n"
                ],
                [
                    107,
                    " pdf_set_process_color_model ( pdev , pcm ) ;\n"
                ],
                [
                    109,
                    " pdev -> icc_struct = 0 ;\n"
                ],
                [
                    113,
                    " if ( pdev -> is_ps2write && ( code = param_read_bool ( plist , \"ProduceDSC\" , & pdev -> ProduceDSC ) ) < 0 ) {\n"
                ],
                [
                    116,
                    " if ( pdev -> PDFA < 0 || pdev -> PDFA > 3 ) {\n"
                ],
                [
                    121,
                    " if ( pdev -> PDFA != 0 && pdev -> AbortPDFAX ) pdev -> PDFA = 0 ;\n"
                ],
                [
                    122,
                    " if ( pdev -> PDFX && pdev -> AbortPDFAX ) pdev -> PDFX = 0 ;\n"
                ],
                [
                    123,
                    " if ( pdev -> PDFX && pdev -> PDFA != 0 ) {\n"
                ],
                [
                    128,
                    " if ( pdev -> PDFX && pdev -> ForOPDFRead ) {\n"
                ],
                [
                    133,
                    " if ( pdev -> PDFA != 0 && pdev -> ForOPDFRead ) {\n"
                ],
                [
                    138,
                    " if ( pdev -> PDFA == 1 || pdev -> PDFX || pdev -> CompatibilityLevel < 1.4 ) {\n"
                ],
                [
                    139,
                    " pdev -> HaveTransparency = false ;\n"
                ],
                [
                    140,
                    " pdev -> PreserveSMask = false ;\n"
                ],
                [
                    143,
                    " if ( pdev -> PDFA != 0 && cl < 1.4 ) cl = ( float ) 1.4 ;\n"
                ],
                [
                    146,
                    " pdev -> ResourcesBeforeUsage = true ;\n"
                ],
                [
                    147,
                    " pdev -> HaveCFF = false ;\n"
                ],
                [
                    148,
                    " pdev -> HavePDFWidths = false ;\n"
                ],
                [
                    149,
                    " pdev -> HaveStrokeColor = false ;\n"
                ],
                [
                    151,
                    " pdev -> MaxInlineImageSize = max_long ;\n"
                ],
                [
                    155,
                    " pdev -> ResourcesBeforeUsage = false ;\n"
                ],
                [
                    156,
                    " pdev -> HaveCFF = true ;\n"
                ],
                [
                    157,
                    " pdev -> HavePDFWidths = true ;\n"
                ],
                [
                    158,
                    " pdev -> HaveStrokeColor = true ;\n"
                ],
                [
                    160,
                    " pdev -> ParamCompatibilityLevel = cl ;\n"
                ],
                [
                    162,
                    " pdev -> HaveCFF = false ;\n"
                ],
                [
                    166,
                    " if ( pdev -> CompatibilityLevel > 1.7 && pdev -> params . TransferFunctionInfo == tfi_Preserve ) {\n"
                ],
                [
                    168,
                    " emprintf ( pdev -> memory , \"\\nIt is not possible to preserve transfer functions in PDF 2.0\\ntransfer functions will be applied instead\\n\" ) ;\n"
                ],
                [
                    172,
                    " emprintf ( pdev -> memory , \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\\n\" ) ;\n"
                ],
                [
                    176,
                    " emprintf ( pdev -> memory , \"ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\\n\" ) ;\n"
                ],
                [
                    179,
                    " if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n"
                ],
                [
                    191,
                    " if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n"
                ],
                [
                    197,
                    " if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n"
                ],
                [
                    204,
                    " if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , \"reset default profile\\n\" ) ;\n"
                ],
                [
                    212,
                    " if ( cl < 1.5f && pdev -> params . ColorImage . Filter != NULL && ! strcmp ( pdev -> params . ColorImage . Filter , \"JPXEncode\" ) ) {\n"
                ],
                [
                    213,
                    " emprintf ( pdev -> memory , \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\" ) ;\n"
                ],
                [
                    216,
                    " if ( cl < 1.5f && pdev -> params . GrayImage . Filter != NULL && ! strcmp ( pdev -> params . GrayImage . Filter , \"JPXEncode\" ) ) {\n"
                ],
                [
                    217,
                    " emprintf ( pdev -> memory , \"JPXEncode requires CompatibilityLevel >= 1.5 .\\n\" ) ;\n"
                ],
                [
                    220,
                    " if ( cl < 1.4f && pdev -> params . MonoImage . Filter != NULL && ! strcmp ( pdev -> params . MonoImage . Filter , \"JBIG2Encode\" ) ) {\n"
                ],
                [
                    221,
                    " emprintf ( pdev -> memory , \"JBIG2Encode requires CompatibilityLevel >= 1.4 .\\n\" ) ;\n"
                ],
                [
                    224,
                    " if ( pdev -> HaveTrueTypes && pdev -> version == psdf_version_level2 ) {\n"
                ],
                [
                    228,
                    " if ( pdev -> FirstObjectNumber != save_dev -> FirstObjectNumber ) {\n"
                ],
                [
                    238,
                    " if ( pdev -> OwnerPassword . size != save_dev -> OwnerPassword . size || ( pdev -> OwnerPassword . size != 0 && memcmp ( pdev -> OwnerPassword . data , save_dev -> OwnerPassword . data , pdev -> OwnerPassword . size ) != 0 ) ) {\n"
                ],
                [
                    251,
                    " if ( pdev -> Linearise && pdev -> OwnerPassword . size != 0 ) {\n"
                ],
                [
                    257,
                    " fail : pdev -> version = save_dev -> version ;\n"
                ],
                [
                    258,
                    " pdf_set_process_color_model ( pdev , save_dev -> pcm_color_info_index ) ;\n"
                ],
                [
                    259,
                    " pdev -> saved_fill_color = save_dev -> saved_fill_color ;\n"
                ],
                [
                    260,
                    " pdev -> saved_stroke_color = save_dev -> saved_fill_color ;\n"
                ],
                [
                    262,
                    " const gs_param_item_t * ppi = pdf_param_items ;\n"
                ],
                [
                    264,
                    " ppi -> key ;\n"
                ],
                [
                    265,
                    " ++ ppi ) memcpy ( ( char * ) pdev + ppi -> offset , ( char * ) save_dev + ppi -> offset , gs_param_type_sizes [ ppi -> type ] ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int dtls1_retrieve_buffered_fragment ( SSL * s , int * ok ) {\n pitem * item ;\n hm_fragment * frag ;\n int al ;\n * ok = 0 ;\n item = pqueue_peek ( s -> d1 -> buffered_messages ) ;\n if ( item == NULL ) return 0 ;\n frag = ( hm_fragment * ) item -> data ;\n if ( frag -> reassembly != NULL ) return 0 ;\n if ( s -> d1 -> handshake_read_seq == frag -> msg_header . seq ) {\n unsigned long frag_len = frag -> msg_header . frag_len ;\n pqueue_pop ( s -> d1 -> buffered_messages ) ;\n al = dtls1_preprocess_fragment ( s , & frag -> msg_header ) ;\n if ( al == 0 ) {\n unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n }\n dtls1_hm_fragment_free ( frag ) ;\n pitem_free ( item ) ;\n if ( al == 0 ) {\n * ok = 1 ;\n return frag_len ;\n }\n ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n s -> init_num = 0 ;\n * ok = 0 ;\n return - 1 ;\n }\n else return 0 ;\n }",
        "hash": 5575425611513297119,
        "project": "debian",
        "size": 30,
        "slice": {
            "memcpy": [
                [
                    8,
                    " frag = ( hm_fragment * ) item -> data ;\n"
                ],
                [
                    14,
                    " if ( al == 0 ) {\n"
                ],
                [
                    15,
                    " unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n"
                ],
                [
                    16,
                    " memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n"
                ],
                [
                    18,
                    " dtls1_hm_fragment_free ( frag ) ;\n"
                ]
            ],
            "result": [
                [
                    8,
                    " frag = ( hm_fragment * ) item -> data ;\n"
                ],
                [
                    14,
                    " if ( al == 0 ) {\n"
                ],
                [
                    15,
                    " unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n"
                ],
                [
                    16,
                    " memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n"
                ],
                [
                    18,
                    " dtls1_hm_fragment_free ( frag ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void dtls1_stop_timer ( SSL * s ) {\n memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;\n memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;\n s -> d1 -> timeout_duration = 1 ;\n BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;\n dtls1_clear_record_buffer ( s ) ;\n }",
        "hash": -3062453801436404700,
        "project": "debian",
        "size": 7,
        "slice": {
            "memset": [
                [
                    1,
                    "void dtls1_stop_timer ( SSL * s ) {\n"
                ],
                [
                    2,
                    " memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;\n"
                ],
                [
                    3,
                    " memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;\n"
                ],
                [
                    5,
                    " BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void dtls1_stop_timer ( SSL * s ) {\n"
                ],
                [
                    2,
                    " memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;\n"
                ],
                [
                    3,
                    " memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;\n"
                ],
                [
                    5,
                    " BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n UINT8 * ptr ;\n int framesize ;\n int c , chunks ;\n int l , lines ;\n int i , j , x = 0 , y , ymax ;\n if ( bytes < 4 ) return 0 ;\n ptr = buf ;\n framesize = I32 ( ptr ) ;\n if ( framesize < I32 ( ptr ) ) return 0 ;\n if ( I16 ( ptr + 4 ) != 0xF1FA ) {\n state -> errcode = IMAGING_CODEC_UNKNOWN ;\n return - 1 ;\n }\n chunks = I16 ( ptr + 6 ) ;\n ptr += 16 ;\n for ( c = 0 ;\n c < chunks ;\n c ++ ) {\n UINT8 * data = ptr + 6 ;\n switch ( I16 ( ptr + 4 ) ) {\n case 4 : case 11 : break ;\n case 7 : lines = I16 ( data ) ;\n data += 2 ;\n for ( l = y = 0 ;\n l < lines && y < state -> ysize ;\n l ++ , y ++ ) {\n UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n int p , packets ;\n packets = I16 ( data ) ;\n data += 2 ;\n while ( packets & 0x8000 ) {\n if ( packets & 0x4000 ) {\n y += 65536 - packets ;\n if ( y >= state -> ysize ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n buf = ( UINT8 * ) im -> image [ y ] ;\n }\n else {\n buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n }\n packets = I16 ( data ) ;\n data += 2 ;\n }\n for ( p = x = 0 ;\n p < packets ;\n p ++ ) {\n x += data [ 0 ] ;\n if ( data [ 1 ] >= 128 ) {\n i = 256 - data [ 1 ] ;\n if ( x + i + i > state -> xsize ) break ;\n for ( j = 0 ;\n j < i ;\n j ++ ) {\n buf [ x ++ ] = data [ 2 ] ;\n buf [ x ++ ] = data [ 3 ] ;\n }\n data += 2 + 2 ;\n }\n else {\n i = 2 * ( int ) data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( buf + x , data + 2 , i ) ;\n data += 2 + i ;\n x += i ;\n }\n }\n if ( p < packets ) break ;\n }\n if ( l < lines ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n break ;\n case 12 : y = I16 ( data ) ;\n ymax = y + I16 ( data + 2 ) ;\n data += 4 ;\n for ( ;\n y < ymax && y < state -> ysize ;\n y ++ ) {\n UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n int p , packets = * data ++ ;\n for ( p = x = 0 ;\n p < packets ;\n p ++ , x += i ) {\n x += data [ 0 ] ;\n if ( data [ 1 ] & 0x80 ) {\n i = 256 - data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memset ( out + x , data [ 2 ] , i ) ;\n data += 3 ;\n }\n else {\n i = data [ 1 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( out + x , data + 2 , i ) ;\n data += i + 2 ;\n }\n }\n if ( p < packets ) break ;\n }\n if ( y < ymax ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n break ;\n case 13 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n break ;\n case 15 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) {\n UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n data += 1 ;\n for ( x = 0 ;\n x < state -> xsize ;\n x += i ) {\n if ( data [ 0 ] & 0x80 ) {\n i = 256 - data [ 0 ] ;\n if ( x + i > state -> xsize ) break ;\n memcpy ( out + x , data + 1 , i ) ;\n data += i + 1 ;\n }\n else {\n i = data [ 0 ] ;\n if ( x + i > state -> xsize ) break ;\n memset ( out + x , data [ 1 ] , i ) ;\n data += 2 ;\n }\n }\n if ( x != state -> xsize ) {\n state -> errcode = IMAGING_CODEC_OVERRUN ;\n return - 1 ;\n }\n }\n break ;\n case 16 : for ( y = 0 ;\n y < state -> ysize ;\n y ++ ) {\n UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n memcpy ( buf + x , data , state -> xsize ) ;\n data += state -> xsize ;\n }\n break ;\n case 18 : break ;\n default : state -> errcode = IMAGING_CODEC_UNKNOWN ;\n return - 1 ;\n }\n ptr += I32 ( ptr ) ;\n }\n return - 1 ;\n }",
        "hash": -8416645554750795024,
        "project": "debian",
        "size": 155,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n"
                ],
                [
                    6,
                    " int i , j , x = 0 , y , ymax ;\n"
                ],
                [
                    20,
                    " UINT8 * data = ptr + 6 ;\n"
                ],
                [
                    28,
                    " UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    31,
                    " data += 2 ;\n"
                ],
                [
                    39,
                    " buf = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    42,
                    " buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n"
                ],
                [
                    45,
                    " data += 2 ;\n"
                ],
                [
                    47,
                    " for ( p = x = 0 ;\n"
                ],
                [
                    50,
                    " x += data [ 0 ] ;\n"
                ],
                [
                    51,
                    " if ( data [ 1 ] >= 128 ) {\n"
                ],
                [
                    52,
                    " i = 256 - data [ 1 ] ;\n"
                ],
                [
                    53,
                    " if ( x + i + i > state -> xsize ) break ;\n"
                ],
                [
                    58,
                    " buf [ x ++ ] = data [ 3 ] ;\n"
                ],
                [
                    60,
                    " data += 2 + 2 ;\n"
                ],
                [
                    63,
                    " i = 2 * ( int ) data [ 1 ] ;\n"
                ],
                [
                    64,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    65,
                    " memcpy ( buf + x , data + 2 , i ) ;\n"
                ],
                [
                    66,
                    " data += 2 + i ;\n"
                ],
                [
                    67,
                    " x += i ;\n"
                ],
                [
                    83,
                    " UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    84,
                    " int p , packets = * data ++ ;\n"
                ],
                [
                    85,
                    " for ( p = x = 0 ;\n"
                ],
                [
                    87,
                    " p ++ , x += i ) {\n"
                ],
                [
                    88,
                    " x += data [ 0 ] ;\n"
                ],
                [
                    89,
                    " if ( data [ 1 ] & 0x80 ) {\n"
                ],
                [
                    90,
                    " i = 256 - data [ 1 ] ;\n"
                ],
                [
                    91,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    92,
                    " memset ( out + x , data [ 2 ] , i ) ;\n"
                ],
                [
                    93,
                    " data += 3 ;\n"
                ],
                [
                    96,
                    " i = data [ 1 ] ;\n"
                ],
                [
                    97,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    98,
                    " memcpy ( out + x , data + 2 , i ) ;\n"
                ],
                [
                    99,
                    " data += i + 2 ;\n"
                ],
                [
                    111,
                    " y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n"
                ],
                [
                    116,
                    " UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    117,
                    " data += 1 ;\n"
                ],
                [
                    119,
                    " x < state -> xsize ;\n"
                ],
                [
                    120,
                    " x += i ) {\n"
                ],
                [
                    121,
                    " if ( data [ 0 ] & 0x80 ) {\n"
                ],
                [
                    122,
                    " i = 256 - data [ 0 ] ;\n"
                ],
                [
                    123,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    124,
                    " memcpy ( out + x , data + 1 , i ) ;\n"
                ],
                [
                    125,
                    " data += i + 1 ;\n"
                ],
                [
                    130,
                    " memset ( out + x , data [ 1 ] , i ) ;\n"
                ],
                [
                    131,
                    " data += 2 ;\n"
                ],
                [
                    134,
                    " if ( x != state -> xsize ) {\n"
                ],
                [
                    141,
                    " y < state -> ysize ;\n"
                ],
                [
                    143,
                    " UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    144,
                    " memcpy ( buf + x , data , state -> xsize ) ;\n"
                ],
                [
                    145,
                    " data += state -> xsize ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n"
                ],
                [
                    23,
                    " case 7 : lines = I16 ( data ) ;\n"
                ],
                [
                    24,
                    " data += 2 ;\n"
                ],
                [
                    28,
                    " UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    30,
                    " packets = I16 ( data ) ;\n"
                ],
                [
                    31,
                    " data += 2 ;\n"
                ],
                [
                    42,
                    " buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n"
                ],
                [
                    44,
                    " packets = I16 ( data ) ;\n"
                ],
                [
                    45,
                    " data += 2 ;\n"
                ],
                [
                    51,
                    " if ( data [ 1 ] >= 128 ) {\n"
                ],
                [
                    52,
                    " i = 256 - data [ 1 ] ;\n"
                ],
                [
                    53,
                    " if ( x + i + i > state -> xsize ) break ;\n"
                ],
                [
                    57,
                    " buf [ x ++ ] = data [ 2 ] ;\n"
                ],
                [
                    60,
                    " data += 2 + 2 ;\n"
                ],
                [
                    64,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    65,
                    " memcpy ( buf + x , data + 2 , i ) ;\n"
                ],
                [
                    66,
                    " data += 2 + i ;\n"
                ],
                [
                    77,
                    " case 12 : y = I16 ( data ) ;\n"
                ],
                [
                    78,
                    " ymax = y + I16 ( data + 2 ) ;\n"
                ],
                [
                    79,
                    " data += 4 ;\n"
                ],
                [
                    83,
                    " UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    84,
                    " int p , packets = * data ++ ;\n"
                ],
                [
                    87,
                    " p ++ , x += i ) {\n"
                ],
                [
                    88,
                    " x += data [ 0 ] ;\n"
                ],
                [
                    89,
                    " if ( data [ 1 ] & 0x80 ) {\n"
                ],
                [
                    90,
                    " i = 256 - data [ 1 ] ;\n"
                ],
                [
                    91,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    92,
                    " memset ( out + x , data [ 2 ] , i ) ;\n"
                ],
                [
                    93,
                    " data += 3 ;\n"
                ],
                [
                    97,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    98,
                    " memcpy ( out + x , data + 2 , i ) ;\n"
                ],
                [
                    99,
                    " data += i + 2 ;\n"
                ],
                [
                    110,
                    " y < state -> ysize ;\n"
                ],
                [
                    111,
                    " y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n"
                ],
                [
                    116,
                    " UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    117,
                    " data += 1 ;\n"
                ],
                [
                    119,
                    " x < state -> xsize ;\n"
                ],
                [
                    120,
                    " x += i ) {\n"
                ],
                [
                    124,
                    " memcpy ( out + x , data + 1 , i ) ;\n"
                ],
                [
                    125,
                    " data += i + 1 ;\n"
                ],
                [
                    128,
                    " i = data [ 0 ] ;\n"
                ],
                [
                    129,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    130,
                    " memset ( out + x , data [ 1 ] , i ) ;\n"
                ],
                [
                    131,
                    " data += 2 ;\n"
                ],
                [
                    134,
                    " if ( x != state -> xsize ) {\n"
                ],
                [
                    143,
                    " UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    144,
                    " memcpy ( buf + x , data , state -> xsize ) ;\n"
                ],
                [
                    145,
                    " data += state -> xsize ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n"
                ],
                [
                    6,
                    " int i , j , x = 0 , y , ymax ;\n"
                ],
                [
                    20,
                    " UINT8 * data = ptr + 6 ;\n"
                ],
                [
                    23,
                    " case 7 : lines = I16 ( data ) ;\n"
                ],
                [
                    24,
                    " data += 2 ;\n"
                ],
                [
                    28,
                    " UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    30,
                    " packets = I16 ( data ) ;\n"
                ],
                [
                    31,
                    " data += 2 ;\n"
                ],
                [
                    39,
                    " buf = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    42,
                    " buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n"
                ],
                [
                    44,
                    " packets = I16 ( data ) ;\n"
                ],
                [
                    45,
                    " data += 2 ;\n"
                ],
                [
                    47,
                    " for ( p = x = 0 ;\n"
                ],
                [
                    50,
                    " x += data [ 0 ] ;\n"
                ],
                [
                    51,
                    " if ( data [ 1 ] >= 128 ) {\n"
                ],
                [
                    52,
                    " i = 256 - data [ 1 ] ;\n"
                ],
                [
                    53,
                    " if ( x + i + i > state -> xsize ) break ;\n"
                ],
                [
                    57,
                    " buf [ x ++ ] = data [ 2 ] ;\n"
                ],
                [
                    58,
                    " buf [ x ++ ] = data [ 3 ] ;\n"
                ],
                [
                    60,
                    " data += 2 + 2 ;\n"
                ],
                [
                    63,
                    " i = 2 * ( int ) data [ 1 ] ;\n"
                ],
                [
                    64,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    65,
                    " memcpy ( buf + x , data + 2 , i ) ;\n"
                ],
                [
                    66,
                    " data += 2 + i ;\n"
                ],
                [
                    67,
                    " x += i ;\n"
                ],
                [
                    77,
                    " case 12 : y = I16 ( data ) ;\n"
                ],
                [
                    78,
                    " ymax = y + I16 ( data + 2 ) ;\n"
                ],
                [
                    79,
                    " data += 4 ;\n"
                ],
                [
                    83,
                    " UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    84,
                    " int p , packets = * data ++ ;\n"
                ],
                [
                    85,
                    " for ( p = x = 0 ;\n"
                ],
                [
                    87,
                    " p ++ , x += i ) {\n"
                ],
                [
                    88,
                    " x += data [ 0 ] ;\n"
                ],
                [
                    89,
                    " if ( data [ 1 ] & 0x80 ) {\n"
                ],
                [
                    90,
                    " i = 256 - data [ 1 ] ;\n"
                ],
                [
                    91,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    92,
                    " memset ( out + x , data [ 2 ] , i ) ;\n"
                ],
                [
                    93,
                    " data += 3 ;\n"
                ],
                [
                    96,
                    " i = data [ 1 ] ;\n"
                ],
                [
                    97,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    98,
                    " memcpy ( out + x , data + 2 , i ) ;\n"
                ],
                [
                    99,
                    " data += i + 2 ;\n"
                ],
                [
                    110,
                    " y < state -> ysize ;\n"
                ],
                [
                    111,
                    " y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n"
                ],
                [
                    116,
                    " UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    117,
                    " data += 1 ;\n"
                ],
                [
                    119,
                    " x < state -> xsize ;\n"
                ],
                [
                    120,
                    " x += i ) {\n"
                ],
                [
                    121,
                    " if ( data [ 0 ] & 0x80 ) {\n"
                ],
                [
                    122,
                    " i = 256 - data [ 0 ] ;\n"
                ],
                [
                    123,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    124,
                    " memcpy ( out + x , data + 1 , i ) ;\n"
                ],
                [
                    125,
                    " data += i + 1 ;\n"
                ],
                [
                    128,
                    " i = data [ 0 ] ;\n"
                ],
                [
                    129,
                    " if ( x + i > state -> xsize ) break ;\n"
                ],
                [
                    130,
                    " memset ( out + x , data [ 1 ] , i ) ;\n"
                ],
                [
                    131,
                    " data += 2 ;\n"
                ],
                [
                    134,
                    " if ( x != state -> xsize ) {\n"
                ],
                [
                    141,
                    " y < state -> ysize ;\n"
                ],
                [
                    143,
                    " UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n"
                ],
                [
                    144,
                    " memcpy ( buf + x , data , state -> xsize ) ;\n"
                ],
                [
                    145,
                    " data += state -> xsize ;\n"
                ]
            ]
        }
    },
    {
        "code": "void * jas_malloc ( size_t size ) {\n void * result ;\n JAS_DBGLOG ( 101 , ( \"jas_malloc called with %zu\\n\" , size ) ) ;\n result = malloc ( size ) ;\n JAS_DBGLOG ( 100 , ( \"jas_malloc(%zu) -> %p\\n\" , size , result ) ) ;\n return result ;\n }",
        "hash": -4967913570211470865,
        "project": "debian",
        "size": 7,
        "slice": {
            "malloc": [
                [
                    1,
                    "void * jas_malloc ( size_t size ) {\n"
                ],
                [
                    3,
                    " JAS_DBGLOG ( 101 , ( \"jas_malloc called with %zu\\n\" , size ) ) ;\n"
                ],
                [
                    4,
                    " result = malloc ( size ) ;\n"
                ],
                [
                    5,
                    " JAS_DBGLOG ( 100 , ( \"jas_malloc(%zu) -> %p\\n\" , size , result ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void * jas_malloc ( size_t size ) {\n"
                ],
                [
                    3,
                    " JAS_DBGLOG ( 101 , ( \"jas_malloc called with %zu\\n\" , size ) ) ;\n"
                ],
                [
                    4,
                    " result = malloc ( size ) ;\n"
                ],
                [
                    5,
                    " JAS_DBGLOG ( 100 , ( \"jas_malloc(%zu) -> %p\\n\" , size , result ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void * jas_realloc ( void * ptr , size_t size ) {\n void * result ;\n JAS_DBGLOG ( 101 , ( \"jas_realloc called with %x,%zu\\n\" , ptr , size ) ) ;\n result = realloc ( ptr , size ) ;\n JAS_DBGLOG ( 100 , ( \"jas_realloc(%p, %zu) -> %p\\n\" , ptr , size , result ) ) ;\n return result ;\n }",
        "hash": -4967913570211470865,
        "project": "debian",
        "size": 7,
        "slice": {
            "realloc": [
                [
                    1,
                    "void * jas_realloc ( void * ptr , size_t size ) {\n"
                ],
                [
                    3,
                    " JAS_DBGLOG ( 101 , ( \"jas_realloc called with %x,%zu\\n\" , ptr , size ) ) ;\n"
                ],
                [
                    4,
                    " result = realloc ( ptr , size ) ;\n"
                ],
                [
                    5,
                    " JAS_DBGLOG ( 100 , ( \"jas_realloc(%p, %zu) -> %p\\n\" , ptr , size , result ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void * jas_realloc ( void * ptr , size_t size ) {\n"
                ],
                [
                    3,
                    " JAS_DBGLOG ( 101 , ( \"jas_realloc called with %x,%zu\\n\" , ptr , size ) ) ;\n"
                ],
                [
                    4,
                    " result = realloc ( ptr , size ) ;\n"
                ],
                [
                    5,
                    " JAS_DBGLOG ( 100 , ( \"jas_realloc(%p, %zu) -> %p\\n\" , ptr , size , result ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static gint64 ascend_seek ( wtap * wth , int * err , gchar * * err_info ) {\n int byte ;\n gint64 date_off = - 1 , cur_off , packet_off ;\n size_t string_level [ ASCEND_MAGIC_STRINGS ] ;\n guint string_i = 0 , type = 0 ;\n guint excessive_read_count = 262144 ;\n memset ( & string_level , 0 , sizeof ( string_level ) ) ;\n while ( ( ( byte = file_getc ( wth -> fh ) ) != EOF ) ) {\n excessive_read_count -- ;\n if ( ! excessive_read_count ) {\n * err = 0 ;\n return - 1 ;\n }\n for ( string_i = 0 ;\n string_i < ASCEND_MAGIC_STRINGS ;\n string_i ++ ) {\n const gchar * strptr = ascend_magic [ string_i ] . strptr ;\n size_t len = strlen ( strptr ) ;\n if ( byte == * ( strptr + string_level [ string_i ] ) ) {\n string_level [ string_i ] ++ ;\n if ( string_level [ string_i ] >= len ) {\n cur_off = file_tell ( wth -> fh ) ;\n if ( cur_off == - 1 ) {\n * err = file_error ( wth -> fh , err_info ) ;\n return - 1 ;\n }\n if ( strcmp ( strptr , ASCEND_DATE ) == 0 ) {\n date_off = cur_off - len ;\n }\n else {\n if ( date_off == - 1 ) {\n packet_off = cur_off - len ;\n }\n else {\n packet_off = date_off ;\n }\n type = ascend_magic [ string_i ] . type ;\n goto found ;\n }\n }\n }\n else {\n string_level [ string_i ] = 0 ;\n }\n }\n }\n * err = file_error ( wth -> fh , err_info ) ;\n return - 1 ;\n found : if ( file_seek ( wth -> fh , packet_off , SEEK_SET , err ) == - 1 ) return - 1 ;\n wth -> phdr . pseudo_header . ascend . type = type ;\n return packet_off ;\n }",
        "hash": 373189235956416317,
        "project": "debian",
        "size": 52,
        "slice": {
            "memset": [
                [
                    1,
                    "static gint64 ascend_seek ( wtap * wth , int * err , gchar * * err_info ) {\n"
                ],
                [
                    4,
                    " size_t string_level [ ASCEND_MAGIC_STRINGS ] ;\n"
                ],
                [
                    7,
                    " memset ( & string_level , 0 , sizeof ( string_level ) ) ;\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "static gint64 ascend_seek ( wtap * wth , int * err , gchar * * err_info ) {\n"
                ],
                [
                    15,
                    " string_i < ASCEND_MAGIC_STRINGS ;\n"
                ],
                [
                    16,
                    " string_i ++ ) {\n"
                ],
                [
                    18,
                    " size_t len = strlen ( strptr ) ;\n"
                ],
                [
                    23,
                    " if ( cur_off == - 1 ) {\n"
                ],
                [
                    27,
                    " if ( strcmp ( strptr , ASCEND_DATE ) == 0 ) {\n"
                ],
                [
                    28,
                    " date_off = cur_off - len ;\n"
                ],
                [
                    31,
                    " if ( date_off == - 1 ) {\n"
                ],
                [
                    37,
                    " type = ascend_magic [ string_i ] . type ;\n"
                ],
                [
                    49,
                    " found : if ( file_seek ( wth -> fh , packet_off , SEEK_SET , err ) == - 1 ) return - 1 ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static gint64 ascend_seek ( wtap * wth , int * err , gchar * * err_info ) {\n"
                ],
                [
                    15,
                    " string_i < ASCEND_MAGIC_STRINGS ;\n"
                ],
                [
                    17,
                    " const gchar * strptr = ascend_magic [ string_i ] . strptr ;\n"
                ],
                [
                    18,
                    " size_t len = strlen ( strptr ) ;\n"
                ],
                [
                    19,
                    " if ( byte == * ( strptr + string_level [ string_i ] ) ) {\n"
                ],
                [
                    21,
                    " if ( string_level [ string_i ] >= len ) {\n"
                ],
                [
                    27,
                    " if ( strcmp ( strptr , ASCEND_DATE ) == 0 ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gint64 ascend_seek ( wtap * wth , int * err , gchar * * err_info ) {\n"
                ],
                [
                    4,
                    " size_t string_level [ ASCEND_MAGIC_STRINGS ] ;\n"
                ],
                [
                    7,
                    " memset ( & string_level , 0 , sizeof ( string_level ) ) ;\n"
                ],
                [
                    15,
                    " string_i < ASCEND_MAGIC_STRINGS ;\n"
                ],
                [
                    16,
                    " string_i ++ ) {\n"
                ],
                [
                    17,
                    " const gchar * strptr = ascend_magic [ string_i ] . strptr ;\n"
                ],
                [
                    18,
                    " size_t len = strlen ( strptr ) ;\n"
                ],
                [
                    19,
                    " if ( byte == * ( strptr + string_level [ string_i ] ) ) {\n"
                ],
                [
                    21,
                    " if ( string_level [ string_i ] >= len ) {\n"
                ],
                [
                    23,
                    " if ( cur_off == - 1 ) {\n"
                ],
                [
                    27,
                    " if ( strcmp ( strptr , ASCEND_DATE ) == 0 ) {\n"
                ],
                [
                    28,
                    " date_off = cur_off - len ;\n"
                ],
                [
                    31,
                    " if ( date_off == - 1 ) {\n"
                ],
                [
                    37,
                    " type = ascend_magic [ string_i ] . type ;\n"
                ],
                [
                    49,
                    " found : if ( file_seek ( wth -> fh , packet_off , SEEK_SET , err ) == - 1 ) return - 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) {\n long unsigned int i ;\n unsigned char c ;\n char buf2 [ 15 ] ;\n mowgli_string_t * s = mowgli_string_create ( ) ;\n * buf2 = '\\0' ;\n * outbuffer = '\\0' ;\n if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) {\n return ;\n }\n for ( i = 0 ;\n s1 [ i ] != '\\0' ;\n i ++ ) {\n c = s1 [ i ] ;\n if ( c > 127 ) {\n snprintf ( buf2 , sizeof buf2 , \"&#%d;\n\" , c ) ;\n s -> append ( s , buf2 , strlen ( buf2 ) ) ;\n }\n else if ( c == '&' ) {\n s -> append ( s , \"&amp;\n\" , 5 ) ;\n }\n else if ( c == '<' ) {\n s -> append ( s , \"&lt;\n\" , 4 ) ;\n }\n else if ( c == '>' ) {\n s -> append ( s , \"&gt;\n\" , 4 ) ;\n }\n else if ( c == '\"' ) {\n s -> append ( s , \"&quot;\n\" , 6 ) ;\n }\n else {\n s -> append_char ( s , c ) ;\n }\n }\n memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;\n }",
        "hash": -5249292504513104172,
        "project": "debian",
        "size": 41,
        "slice": {
            "memcpy": [
                [
                    1,
                    "void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) {\n"
                ],
                [
                    5,
                    " mowgli_string_t * s = mowgli_string_create ( ) ;\n"
                ],
                [
                    7,
                    " * outbuffer = '\\0' ;\n"
                ],
                [
                    8,
                    " if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) {\n"
                ],
                [
                    37,
                    " s -> append_char ( s , c ) ;\n"
                ],
                [
                    40,
                    " memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) {\n"
                ],
                [
                    5,
                    " mowgli_string_t * s = mowgli_string_create ( ) ;\n"
                ],
                [
                    7,
                    " * outbuffer = '\\0' ;\n"
                ],
                [
                    8,
                    " if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) {\n"
                ],
                [
                    37,
                    " s -> append_char ( s , c ) ;\n"
                ],
                [
                    40,
                    " memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "ParseResult mime_parser_parse ( MIMEParser * parser , HdrHeap * heap , MIMEHdrImpl * mh , const char * * real_s , const char * real_e , bool must_copy_strings , bool eof ) {\n ParseResult err ;\n bool line_is_real ;\n const char * colon ;\n const char * line_c ;\n const char * line_s = nullptr ;\n const char * line_e = nullptr ;\n const char * field_name_first ;\n const char * field_name_last ;\n const char * field_value_first ;\n const char * field_value_last ;\n const char * field_line_first ;\n const char * field_line_last ;\n int field_name_length , field_value_length ;\n MIMEScanner * scanner = & parser -> m_scanner ;\n while ( true ) {\n err = mime_scanner_get ( scanner , real_s , real_e , & line_s , & line_e , & line_is_real , eof , MIME_SCANNER_TYPE_FIELD ) ;\n if ( err != PARSE_RESULT_OK ) {\n return err ;\n }\n line_c = line_s ;\n if ( ( line_e - line_c >= 2 ) && ( line_c [ 0 ] == ParseRules : : CHAR_CR ) && ( line_c [ 1 ] == ParseRules : : CHAR_LF ) ) {\n return PARSE_RESULT_DONE ;\n }\n if ( ( line_e - line_c >= 1 ) && ( line_c [ 0 ] == ParseRules : : CHAR_LF ) ) {\n return PARSE_RESULT_DONE ;\n }\n field_line_first = line_c ;\n field_line_last = line_e - 1 ;\n field_name_first = line_c ;\n if ( ( ! ParseRules : : is_token ( * field_name_first ) ) && ( * field_name_first != '@' ) ) {\n continue ;\n }\n colon = ( char * ) memchr ( line_c , ':' , ( line_e - line_c ) ) ;\n if ( ! colon ) {\n continue ;\n }\n field_name_last = colon - 1 ;\n while ( ( field_name_last >= field_name_first ) && is_ws ( * field_name_last ) ) {\n -- field_name_last ;\n }\n field_value_first = colon + 1 ;\n while ( ( field_value_first < line_e ) && is_ws ( * field_value_first ) ) {\n ++ field_value_first ;\n }\n field_value_last = line_e - 1 ;\n while ( ( field_value_last >= field_value_first ) && ParseRules : : is_wslfcr ( * field_value_last ) ) {\n -- field_value_last ;\n }\n field_name_length = ( int ) ( field_name_last - field_name_first + 1 ) ;\n field_value_length = ( int ) ( field_value_last - field_value_first + 1 ) ;\n if ( field_name_length >= UINT16_MAX || field_value_length >= UINT16_MAX ) {\n return PARSE_RESULT_ERROR ;\n }\n int total_line_length = ( int ) ( field_line_last - field_line_first + 1 ) ;\n if ( must_copy_strings || ( ! line_is_real ) ) {\n int length = total_line_length ;\n char * dup = heap -> duplicate_str ( field_name_first , length ) ;\n intptr_t delta = dup - field_name_first ;\n field_name_first += delta ;\n field_value_first += delta ;\n }\n int field_name_wks_idx = hdrtoken_tokenize ( field_name_first , field_name_length ) ;\n MIMEField * field = mime_field_create ( heap , mh ) ;\n mime_field_name_value_set ( heap , mh , field , field_name_wks_idx , field_name_first , field_name_length , field_value_first , field_value_length , true , total_line_length , false ) ;\n mime_hdr_field_attach ( mh , field , 1 , nullptr ) ;\n }\n }",
        "hash": 2546373479020365143,
        "project": "debian",
        "size": 68,
        "slice": {
            "memchr": [
                [
                    1,
                    "ParseResult mime_parser_parse ( MIMEParser * parser , HdrHeap * heap , MIMEHdrImpl * mh , const char * * real_s , const char * real_e , bool must_copy_strings , bool eof ) {\n"
                ],
                [
                    31,
                    " if ( ( ! ParseRules : : is_token ( * field_name_first ) ) && ( * field_name_first != '@' ) ) {\n"
                ],
                [
                    34,
                    " colon = ( char * ) memchr ( line_c , ':' , ( line_e - line_c ) ) ;\n"
                ],
                [
                    35,
                    " if ( ! colon ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "ParseResult mime_parser_parse ( MIMEParser * parser , HdrHeap * heap , MIMEHdrImpl * mh , const char * * real_s , const char * real_e , bool must_copy_strings , bool eof ) {\n"
                ],
                [
                    31,
                    " if ( ( ! ParseRules : : is_token ( * field_name_first ) ) && ( * field_name_first != '@' ) ) {\n"
                ],
                [
                    34,
                    " colon = ( char * ) memchr ( line_c , ':' , ( line_e - line_c ) ) ;\n"
                ],
                [
                    35,
                    " if ( ! colon ) {\n"
                ]
            ]
        }
    },
    {
        "code": "SPL_METHOD ( RecursiveDirectoryIterator , getChildren ) {\n zval * zpath , * zflags ;\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n spl_filesystem_object * subdir ;\n char slash = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_UNIXPATHS ) ? '/' : DEFAULT_SLASH ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n MAKE_STD_ZVAL ( zflags ) ;\n MAKE_STD_ZVAL ( zpath ) ;\n ZVAL_LONG ( zflags , intern -> flags ) ;\n ZVAL_STRINGL ( zpath , intern -> file_name , intern -> file_name_len , 1 ) ;\n spl_instantiate_arg_ex2 ( Z_OBJCE_P ( getThis ( ) ) , & return_value , 0 , zpath , zflags TSRMLS_CC ) ;\n zval_ptr_dtor ( & zpath ) ;\n zval_ptr_dtor ( & zflags ) ;\n subdir = ( spl_filesystem_object * ) zend_object_store_get_object ( return_value TSRMLS_CC ) ;\n if ( subdir ) {\n if ( intern -> u . dir . sub_path && intern -> u . dir . sub_path [ 0 ] ) {\n subdir -> u . dir . sub_path_len = spprintf ( & subdir -> u . dir . sub_path , 0 , \"%s%c%s\" , intern -> u . dir . sub_path , slash , intern -> u . dir . entry . d_name ) ;\n }\n else {\n subdir -> u . dir . sub_path_len = strlen ( intern -> u . dir . entry . d_name ) ;\n subdir -> u . dir . sub_path = estrndup ( intern -> u . dir . entry . d_name , subdir -> u . dir . sub_path_len ) ;\n }\n subdir -> info_class = intern -> info_class ;\n subdir -> file_class = intern -> file_class ;\n subdir -> oth = intern -> oth ;\n }\n }",
        "hash": 1223258652239369123,
        "project": "debian",
        "size": 30,
        "slice": {
            "strlen": [
                [
                    19,
                    " if ( intern -> u . dir . sub_path && intern -> u . dir . sub_path [ 0 ] ) {\n"
                ],
                [
                    23,
                    " subdir -> u . dir . sub_path_len = strlen ( intern -> u . dir . entry . d_name ) ;\n"
                ],
                [
                    24,
                    " subdir -> u . dir . sub_path = estrndup ( intern -> u . dir . entry . d_name , subdir -> u . dir . sub_path_len ) ;\n"
                ]
            ],
            "result": [
                [
                    19,
                    " if ( intern -> u . dir . sub_path && intern -> u . dir . sub_path [ 0 ] ) {\n"
                ],
                [
                    23,
                    " subdir -> u . dir . sub_path_len = strlen ( intern -> u . dir . entry . d_name ) ;\n"
                ],
                [
                    24,
                    " subdir -> u . dir . sub_path = estrndup ( intern -> u . dir . entry . d_name , subdir -> u . dir . sub_path_len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "SPL_METHOD ( SplFileObject , __construct ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zend_bool use_include_path = 0 ;\n char * p1 , * p2 ;\n char * tmp_path ;\n int tmp_path_len ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n intern -> u . file . open_mode = NULL ;\n intern -> u . file . open_mode_len = 0 ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"p|sbr!\" , & intern -> file_name , & intern -> file_name_len , & intern -> u . file . open_mode , & intern -> u . file . open_mode_len , & use_include_path , & intern -> u . file . zcontext ) == FAILURE ) {\n intern -> u . file . open_mode = NULL ;\n intern -> file_name = NULL ;\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n return ;\n }\n if ( intern -> u . file . open_mode == NULL ) {\n intern -> u . file . open_mode = \"r\" ;\n intern -> u . file . open_mode_len = 1 ;\n }\n if ( spl_filesystem_file_open ( intern , use_include_path , 0 TSRMLS_CC ) == SUCCESS ) {\n tmp_path_len = strlen ( intern -> u . file . stream -> orig_path ) ;\n if ( tmp_path_len > 1 && IS_SLASH_AT ( intern -> u . file . stream -> orig_path , tmp_path_len - 1 ) ) {\n tmp_path_len -- ;\n }\n tmp_path = estrndup ( intern -> u . file . stream -> orig_path , tmp_path_len ) ;\n p1 = strrchr ( tmp_path , '/' ) ;\n # if defined ( PHP_WIN32 ) || defined ( NETWARE ) p2 = strrchr ( tmp_path , '\\\\' ) ;\n # else p2 = 0 ;\n # endif if ( p1 || p2 ) {\n intern -> _path_len = ( p1 > p2 ? p1 : p2 ) - tmp_path ;\n }\n else {\n intern -> _path_len = 0 ;\n }\n efree ( tmp_path ) ;\n intern -> _path = estrndup ( intern -> u . file . stream -> orig_path , intern -> _path_len ) ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }",
        "hash": 1223258652239369123,
        "project": "debian",
        "size": 40,
        "slice": {
            "strlen": [
                [
                    21,
                    " if ( spl_filesystem_file_open ( intern , use_include_path , 0 TSRMLS_CC ) == SUCCESS ) {\n"
                ],
                [
                    22,
                    " tmp_path_len = strlen ( intern -> u . file . stream -> orig_path ) ;\n"
                ],
                [
                    23,
                    " if ( tmp_path_len > 1 && IS_SLASH_AT ( intern -> u . file . stream -> orig_path , tmp_path_len - 1 ) ) {\n"
                ],
                [
                    26,
                    " tmp_path = estrndup ( intern -> u . file . stream -> orig_path , tmp_path_len ) ;\n"
                ]
            ],
            "result": [
                [
                    21,
                    " if ( spl_filesystem_file_open ( intern , use_include_path , 0 TSRMLS_CC ) == SUCCESS ) {\n"
                ],
                [
                    22,
                    " tmp_path_len = strlen ( intern -> u . file . stream -> orig_path ) ;\n"
                ],
                [
                    23,
                    " if ( tmp_path_len > 1 && IS_SLASH_AT ( intern -> u . file . stream -> orig_path , tmp_path_len - 1 ) ) {\n"
                ],
                [
                    26,
                    " tmp_path = estrndup ( intern -> u . file . stream -> orig_path , tmp_path_len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "PHP_MINIT_FUNCTION ( spl_directory ) {\n REGISTER_SPL_STD_CLASS_EX ( SplFileInfo , spl_filesystem_object_new , spl_SplFileInfo_functions ) ;\n memcpy ( & spl_filesystem_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ;\n spl_filesystem_object_handlers . clone_obj = spl_filesystem_object_clone ;\n spl_filesystem_object_handlers . cast_object = spl_filesystem_object_cast ;\n spl_filesystem_object_handlers . get_debug_info = spl_filesystem_object_get_debug_info ;\n spl_ce_SplFileInfo -> serialize = zend_class_serialize_deny ;\n spl_ce_SplFileInfo -> unserialize = zend_class_unserialize_deny ;\n REGISTER_SPL_SUB_CLASS_EX ( DirectoryIterator , SplFileInfo , spl_filesystem_object_new , spl_DirectoryIterator_functions ) ;\n zend_class_implements ( spl_ce_DirectoryIterator TSRMLS_CC , 1 , zend_ce_iterator ) ;\n REGISTER_SPL_IMPLEMENTS ( DirectoryIterator , SeekableIterator ) ;\n spl_ce_DirectoryIterator -> get_iterator = spl_filesystem_dir_get_iterator ;\n REGISTER_SPL_SUB_CLASS_EX ( FilesystemIterator , DirectoryIterator , spl_filesystem_object_new , spl_FilesystemIterator_functions ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"CURRENT_MODE_MASK\" , SPL_FILE_DIR_CURRENT_MODE_MASK ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"CURRENT_AS_PATHNAME\" , SPL_FILE_DIR_CURRENT_AS_PATHNAME ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"CURRENT_AS_FILEINFO\" , SPL_FILE_DIR_CURRENT_AS_FILEINFO ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"CURRENT_AS_SELF\" , SPL_FILE_DIR_CURRENT_AS_SELF ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"KEY_MODE_MASK\" , SPL_FILE_DIR_KEY_MODE_MASK ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"KEY_AS_PATHNAME\" , SPL_FILE_DIR_KEY_AS_PATHNAME ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"FOLLOW_SYMLINKS\" , SPL_FILE_DIR_FOLLOW_SYMLINKS ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"KEY_AS_FILENAME\" , SPL_FILE_DIR_KEY_AS_FILENAME ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"NEW_CURRENT_AND_KEY\" , SPL_FILE_DIR_KEY_AS_FILENAME | SPL_FILE_DIR_CURRENT_AS_FILEINFO ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"OTHER_MODE_MASK\" , SPL_FILE_DIR_OTHERS_MASK ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"SKIP_DOTS\" , SPL_FILE_DIR_SKIPDOTS ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( FilesystemIterator , \"UNIX_PATHS\" , SPL_FILE_DIR_UNIXPATHS ) ;\n spl_ce_FilesystemIterator -> get_iterator = spl_filesystem_tree_get_iterator ;\n REGISTER_SPL_SUB_CLASS_EX ( RecursiveDirectoryIterator , FilesystemIterator , spl_filesystem_object_new , spl_RecursiveDirectoryIterator_functions ) ;\n REGISTER_SPL_IMPLEMENTS ( RecursiveDirectoryIterator , RecursiveIterator ) ;\n memcpy ( & spl_filesystem_object_check_handlers , & spl_filesystem_object_handlers , sizeof ( zend_object_handlers ) ) ;\n spl_filesystem_object_check_handlers . get_method = spl_filesystem_object_get_method_check ;\n # ifdef HAVE_GLOB REGISTER_SPL_SUB_CLASS_EX ( GlobIterator , FilesystemIterator , spl_filesystem_object_new_check , spl_GlobIterator_functions ) ;\n REGISTER_SPL_IMPLEMENTS ( GlobIterator , Countable ) ;\n # endif REGISTER_SPL_SUB_CLASS_EX ( SplFileObject , SplFileInfo , spl_filesystem_object_new_check , spl_SplFileObject_functions ) ;\n REGISTER_SPL_IMPLEMENTS ( SplFileObject , RecursiveIterator ) ;\n REGISTER_SPL_IMPLEMENTS ( SplFileObject , SeekableIterator ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , \"DROP_NEW_LINE\" , SPL_FILE_OBJECT_DROP_NEW_LINE ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , \"READ_AHEAD\" , SPL_FILE_OBJECT_READ_AHEAD ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , \"SKIP_EMPTY\" , SPL_FILE_OBJECT_SKIP_EMPTY ) ;\n REGISTER_SPL_CLASS_CONST_LONG ( SplFileObject , \"READ_CSV\" , SPL_FILE_OBJECT_READ_CSV ) ;\n REGISTER_SPL_SUB_CLASS_EX ( SplTempFileObject , SplFileObject , spl_filesystem_object_new_check , spl_SplTempFileObject_functions ) ;\n return SUCCESS ;\n }",
        "hash": 1223258652239369123,
        "project": "debian",
        "size": 42,
        "slice": {
            "memcpy": [
                [
                    1,
                    "PHP_MINIT_FUNCTION ( spl_directory ) {\n"
                ],
                [
                    3,
                    " memcpy ( & spl_filesystem_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ;\n"
                ],
                [
                    4,
                    " spl_filesystem_object_handlers . clone_obj = spl_filesystem_object_clone ;\n"
                ],
                [
                    5,
                    " spl_filesystem_object_handlers . cast_object = spl_filesystem_object_cast ;\n"
                ],
                [
                    6,
                    " spl_filesystem_object_handlers . get_debug_info = spl_filesystem_object_get_debug_info ;\n"
                ],
                [
                    29,
                    " memcpy ( & spl_filesystem_object_check_handlers , & spl_filesystem_object_handlers , sizeof ( zend_object_handlers ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "PHP_MINIT_FUNCTION ( spl_directory ) {\n"
                ],
                [
                    3,
                    " memcpy ( & spl_filesystem_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ;\n"
                ],
                [
                    4,
                    " spl_filesystem_object_handlers . clone_obj = spl_filesystem_object_clone ;\n"
                ],
                [
                    5,
                    " spl_filesystem_object_handlers . cast_object = spl_filesystem_object_cast ;\n"
                ],
                [
                    6,
                    " spl_filesystem_object_handlers . get_debug_info = spl_filesystem_object_get_debug_info ;\n"
                ],
                [
                    29,
                    " memcpy ( & spl_filesystem_object_check_handlers , & spl_filesystem_object_handlers , sizeof ( zend_object_handlers ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) {\n struct iso9660 * iso9660 ;\n struct isoent * np ;\n unsigned char * p ;\n size_t l ;\n int r ;\n int ffmax , parent_len ;\n static const struct archive_rb_tree_ops rb_ops = {\n isoent_cmp_node_joliet , isoent_cmp_key_joliet }\n ;\n if ( isoent -> children . cnt == 0 ) return ( 0 ) ;\n iso9660 = a -> format_data ;\n if ( iso9660 -> opt . joliet == OPT_JOLIET_LONGNAME ) ffmax = 206 ;\n else ffmax = 128 ;\n r = idr_start ( a , idr , isoent -> children . cnt , ffmax , 6 , 2 , & rb_ops ) ;\n if ( r < 0 ) return ( r ) ;\n parent_len = 1 ;\n for ( np = isoent ;\n np -> parent != np ;\n np = np -> parent ) parent_len += np -> mb_len + 1 ;\n for ( np = isoent -> children . first ;\n np != NULL ;\n np = np -> chnext ) {\n unsigned char * dot ;\n int ext_off , noff , weight ;\n size_t lt ;\n if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) l = ffmax ;\n p = malloc ( ( l + 1 ) * 2 ) ;\n if ( p == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n memcpy ( p , np -> file -> basename_utf16 . s , l ) ;\n p [ l ] = 0 ;\n p [ l + 1 ] = 0 ;\n np -> identifier = ( char * ) p ;\n lt = l ;\n dot = p + l ;\n weight = 0 ;\n while ( lt > 0 ) {\n if ( ! joliet_allowed_char ( p [ 0 ] , p [ 1 ] ) ) archive_be16enc ( p , 0x005F ) ;\n else if ( p [ 0 ] == 0 && p [ 1 ] == 0x2E ) dot = p ;\n p += 2 ;\n lt -= 2 ;\n }\n ext_off = ( int ) ( dot - ( unsigned char * ) np -> identifier ) ;\n np -> ext_off = ext_off ;\n np -> ext_len = ( int ) l - ext_off ;\n np -> id_len = ( int ) l ;\n if ( ( int ) np -> file -> basename_utf16 . length > ffmax ) {\n if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) {\n archive_set_error ( & a -> archive , errno , \"No memory\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n np -> mb_len = ( int ) iso9660 -> mbs . length ;\n if ( np -> mb_len != ( int ) np -> file -> basename . length ) weight = np -> mb_len ;\n }\n else np -> mb_len = ( int ) np -> file -> basename . length ;\n if ( parent_len + np -> mb_len > 240 ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"The regulation of Joliet extensions;\n\" \" A length of a full-pathname of `%s' is \" \"longer than 240 bytes, (p=%d, b=%d)\" , archive_entry_pathname ( np -> file -> entry ) , ( int ) parent_len , ( int ) np -> mb_len ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n if ( ( int ) l == ffmax ) noff = ext_off - 6 ;\n else if ( ( int ) l == ffmax - 2 ) noff = ext_off - 4 ;\n else if ( ( int ) l == ffmax - 4 ) noff = ext_off - 2 ;\n else noff = ext_off ;\n idr_register ( idr , np , weight , noff ) ;\n }\n idr_resolve ( idr , idr_set_num_beutf16 ) ;\n return ( ARCHIVE_OK ) ;\n }",
        "hash": -2607754285145856562,
        "project": "debian",
        "size": 72,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) {\n"
                ],
                [
                    27,
                    " if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) l = ffmax ;\n"
                ],
                [
                    29,
                    " if ( p == NULL ) {\n"
                ],
                [
                    33,
                    " memcpy ( p , np -> file -> basename_utf16 . s , l ) ;\n"
                ],
                [
                    34,
                    " p [ l ] = 0 ;\n"
                ],
                [
                    35,
                    " p [ l + 1 ] = 0 ;\n"
                ],
                [
                    36,
                    " np -> identifier = ( char * ) p ;\n"
                ],
                [
                    37,
                    " lt = l ;\n"
                ],
                [
                    38,
                    " dot = p + l ;\n"
                ],
                [
                    41,
                    " if ( ! joliet_allowed_char ( p [ 0 ] , p [ 1 ] ) ) archive_be16enc ( p , 0x005F ) ;\n"
                ],
                [
                    42,
                    " else if ( p [ 0 ] == 0 && p [ 1 ] == 0x2E ) dot = p ;\n"
                ],
                [
                    43,
                    " p += 2 ;\n"
                ],
                [
                    48,
                    " np -> ext_len = ( int ) l - ext_off ;\n"
                ],
                [
                    49,
                    " np -> id_len = ( int ) l ;\n"
                ],
                [
                    51,
                    " if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) {\n"
                ],
                [
                    64,
                    " if ( ( int ) l == ffmax ) noff = ext_off - 6 ;\n"
                ],
                [
                    65,
                    " else if ( ( int ) l == ffmax - 2 ) noff = ext_off - 4 ;\n"
                ],
                [
                    66,
                    " else if ( ( int ) l == ffmax - 4 ) noff = ext_off - 2 ;\n"
                ]
            ],
            "malloc": [
                [
                    22,
                    " np != NULL ;\n"
                ],
                [
                    28,
                    " p = malloc ( ( l + 1 ) * 2 ) ;\n"
                ],
                [
                    29,
                    " if ( p == NULL ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) {\n"
                ],
                [
                    22,
                    " np != NULL ;\n"
                ],
                [
                    27,
                    " if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) l = ffmax ;\n"
                ],
                [
                    28,
                    " p = malloc ( ( l + 1 ) * 2 ) ;\n"
                ],
                [
                    29,
                    " if ( p == NULL ) {\n"
                ],
                [
                    33,
                    " memcpy ( p , np -> file -> basename_utf16 . s , l ) ;\n"
                ],
                [
                    34,
                    " p [ l ] = 0 ;\n"
                ],
                [
                    35,
                    " p [ l + 1 ] = 0 ;\n"
                ],
                [
                    36,
                    " np -> identifier = ( char * ) p ;\n"
                ],
                [
                    37,
                    " lt = l ;\n"
                ],
                [
                    38,
                    " dot = p + l ;\n"
                ],
                [
                    41,
                    " if ( ! joliet_allowed_char ( p [ 0 ] , p [ 1 ] ) ) archive_be16enc ( p , 0x005F ) ;\n"
                ],
                [
                    42,
                    " else if ( p [ 0 ] == 0 && p [ 1 ] == 0x2E ) dot = p ;\n"
                ],
                [
                    43,
                    " p += 2 ;\n"
                ],
                [
                    48,
                    " np -> ext_len = ( int ) l - ext_off ;\n"
                ],
                [
                    49,
                    " np -> id_len = ( int ) l ;\n"
                ],
                [
                    51,
                    " if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) {\n"
                ],
                [
                    64,
                    " if ( ( int ) l == ffmax ) noff = ext_off - 6 ;\n"
                ],
                [
                    65,
                    " else if ( ( int ) l == ffmax - 2 ) noff = ext_off - 4 ;\n"
                ],
                [
                    66,
                    " else if ( ( int ) l == ffmax - 4 ) noff = ext_off - 2 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static tvbuff_t * decompress_sigcomp_message ( tvbuff_t * bytecode_tvb , tvbuff_t * message_tvb , packet_info * pinfo , proto_tree * udvm_tree , gint udvm_mem_dest , gint print_flags , gint hf_id , gint header_len , gint byte_code_state_len , gint byte_code_id_len , gint udvm_start_ip ) {\n tvbuff_t * decomp_tvb ;\n guint8 * buff = ( guint8 * ) wmem_alloc0 ( wmem_packet_scope ( ) , UDVM_MEMORY_SIZE ) ;\n char string [ 2 ] ;\n guint8 * out_buff ;\n guint32 i = 0 ;\n guint16 n = 0 ;\n guint16 m = 0 ;\n guint16 x ;\n guint k = 0 ;\n guint16 H ;\n guint16 oldH ;\n guint offset = 0 ;\n guint start_offset ;\n guint result_dest ;\n guint code_length = 0 ;\n guint8 current_instruction ;\n guint current_address ;\n guint operand_address ;\n guint input_address ;\n guint16 output_address = 0 ;\n guint next_operand_address ;\n guint8 octet ;\n guint8 msb ;\n guint8 lsb ;\n guint16 byte_copy_right ;\n guint16 byte_copy_left ;\n guint16 input_bit_order ;\n guint16 stack_location ;\n guint16 stack_fill ;\n guint16 result ;\n guint msg_end = tvb_reported_length_remaining ( message_tvb , 0 ) ;\n guint16 result_code = 0 ;\n guint16 old_input_bit_order = 0 ;\n guint16 remaining_bits = 0 ;\n guint16 input_bits = 0 ;\n guint8 bit_order = 0 ;\n gboolean outside_huffman_boundaries = TRUE ;\n gboolean print_in_loop = FALSE ;\n guint16 instruction_address ;\n guint8 no_of_state_create = 0 ;\n guint16 state_length_buff [ 5 ] ;\n guint16 state_address_buff [ 5 ] ;\n guint16 state_instruction_buff [ 5 ] ;\n guint16 state_minimum_access_length_buff [ 5 ] ;\n guint32 used_udvm_cycles = 0 ;\n guint cycles_per_bit ;\n guint maximum_UDVM_cycles ;\n guint8 * sha1buff ;\n unsigned char sha1_digest_buf [ STATE_BUFFER_SIZE ] ;\n sha1_context ctx ;\n proto_item * addr_item = NULL , * ti = NULL ;\n guint16 length ;\n guint16 at_address ;\n guint16 destination ;\n guint16 addr ;\n guint16 value ;\n guint16 p_id_start ;\n guint16 p_id_length ;\n guint16 state_begin ;\n guint16 state_length ;\n guint16 state_address ;\n guint16 state_instruction ;\n guint16 operand_1 ;\n guint16 operand_2 ;\n guint16 value_1 ;\n guint16 value_2 ;\n guint16 at_address_1 ;\n guint16 at_address_2 ;\n guint16 at_address_3 ;\n guint16 j ;\n guint16 bits_n ;\n guint16 lower_bound_n ;\n guint16 upper_bound_n ;\n guint16 uncompressed_n ;\n guint16 position ;\n guint16 ref_destination ;\n guint16 multy_offset ;\n guint16 output_start ;\n guint16 output_length ;\n guint16 minimum_access_length ;\n guint16 state_retention_priority ;\n guint16 requested_feedback_location ;\n guint16 returned_parameters_location ;\n guint16 start_value ;\n gboolean print_level_1 = FALSE ;\n gboolean print_level_2 = FALSE ;\n gboolean print_level_3 = FALSE ;\n gint show_instr_detail_level = 0 ;\n switch ( print_flags ) {\n case 0 : break ;\n case 1 : print_level_1 = TRUE ;\n show_instr_detail_level = 1 ;\n break ;\n case 2 : print_level_1 = TRUE ;\n print_level_2 = TRUE ;\n show_instr_detail_level = 1 ;\n break ;\n case 3 : print_level_1 = TRUE ;\n print_level_2 = TRUE ;\n print_level_3 = TRUE ;\n show_instr_detail_level = 2 ;\n break ;\n default : print_level_1 = TRUE ;\n show_instr_detail_level = 1 ;\n break ;\n }\n buff [ 0 ] = ( UDVM_MEMORY_SIZE >> 8 ) & 0x00FF ;\n buff [ 1 ] = UDVM_MEMORY_SIZE & 0x00FF ;\n buff [ 2 ] = 0 ;\n buff [ 3 ] = 16 ;\n buff [ 4 ] = 0 ;\n buff [ 5 ] = 1 ;\n buff [ 6 ] = ( byte_code_id_len >> 8 ) & 0x00FF ;\n buff [ 7 ] = byte_code_id_len & 0x00FF ;\n buff [ 8 ] = ( byte_code_state_len >> 8 ) & 0x00FF ;\n buff [ 9 ] = byte_code_state_len & 0x00FF ;\n code_length = tvb_reported_length_remaining ( bytecode_tvb , 0 ) ;\n cycles_per_bit = buff [ 2 ] << 8 ;\n cycles_per_bit = cycles_per_bit | buff [ 3 ] ;\n maximum_UDVM_cycles = ( ( 8 * ( header_len + msg_end ) ) + 1000 ) * cycles_per_bit ;\n proto_tree_add_uint ( udvm_tree , hf_sigcomp_message_length , bytecode_tvb , offset , 1 , msg_end ) ;\n proto_tree_add_uint ( udvm_tree , hf_sigcomp_byte_code_length , bytecode_tvb , offset , 1 , code_length ) ;\n proto_tree_add_uint ( udvm_tree , hf_sigcomp_max_udvm_cycles , bytecode_tvb , offset , 1 , maximum_UDVM_cycles ) ;\n i = udvm_mem_dest ;\n if ( print_level_3 ) proto_tree_add_uint ( udvm_tree , hf_sigcomp_load_bytecode_into_udvm_start , bytecode_tvb , offset , 1 , i ) ;\n while ( code_length > offset && i < UDVM_MEMORY_SIZE ) {\n buff [ i ] = tvb_get_guint8 ( bytecode_tvb , offset ) ;\n if ( print_level_3 ) proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_instruction_code , bytecode_tvb , offset , 1 , buff [ i ] , \" Addr: %u Instruction code(0x%02x) \" , i , buff [ i ] ) ;\n i ++ ;\n offset ++ ;\n }\n current_address = udvm_start_ip ;\n input_address = 0 ;\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_udvm_execution_stated , bytecode_tvb , offset , 1 , current_address , \"UDVM EXECUTION STARTED at Address: %u Message size %u\" , current_address , msg_end ) ;\n out_buff = ( guint8 * ) g_malloc ( UDVM_MEMORY_SIZE ) ;\n offset = 0 ;\n execute_next_instruction : if ( used_udvm_cycles > maximum_UDVM_cycles ) {\n result_code = 15 ;\n goto decompression_failure ;\n }\n used_udvm_cycles ++ ;\n current_instruction = buff [ current_address & 0xffff ] ;\n if ( show_instr_detail_level == 2 ) {\n addr_item = proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_current_instruction , bytecode_tvb , offset , 1 , current_instruction , \"Addr: %u ## %s(%d)\" , current_address , val_to_str_ext_const ( current_instruction , & udvm_instruction_code_vals_ext , \"INVALID INSTRUCTION\" ) , current_instruction ) ;\n }\n offset ++ ;\n switch ( current_instruction ) {\n case SIGCOMP_INSTR_DECOMPRESSION_FAILURE : if ( result_code == 0 ) result_code = 9 ;\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_decompression_failure , NULL , 0 , 0 , current_address , \"Addr: %u ## DECOMPRESSION-FAILURE(0)\" , current_address ) ;\n proto_tree_add_uint ( udvm_tree , hf_sigcomp_wireshark_udvm_diagnostic , NULL , 0 , 0 , result_code ) ;\n if ( output_address > 0 ) {\n decomp_tvb = tvb_new_child_real_data ( message_tvb , out_buff , output_address , output_address ) ;\n tvb_set_free_cb ( decomp_tvb , g_free ) ;\n add_new_data_source ( pinfo , decomp_tvb , \"Decompressed SigComp message(Incomplete)\" ) ;\n proto_tree_add_expert ( udvm_tree , pinfo , & ei_sigcomp_sigcomp_message_decompression_failure , decomp_tvb , 0 , - 1 ) ;\n return decomp_tvb ;\n }\n g_free ( out_buff ) ;\n return NULL ;\n break ;\n case SIGCOMP_INSTR_AND : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## AND (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n result = operand_1 & operand_2 ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_OR : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## OR (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n result = operand_1 | operand_2 ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_NOT : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" ($operand_1)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## NOT (operand_1=%u)\" , current_address , operand_1 ) ;\n }\n result = operand_1 ^ 0xffff ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_LSHIFT : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" ($operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n ti = proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n if ( operand_2 > 15 ) {\n expert_add_info ( pinfo , ti , & ei_sigcomp_invalid_shift_value ) ;\n break ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## LSHIFT (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n result = operand_1 << operand_2 ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_RSHIFT : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n ti = proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n if ( operand_2 > 15 ) {\n expert_add_info ( pinfo , ti , & ei_sigcomp_invalid_shift_value ) ;\n break ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## RSHIFT (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n result = operand_1 >> operand_2 ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_ADD : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## ADD (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n result = operand_1 + operand_2 ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n case SIGCOMP_INSTR_SUBTRACT : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## SUBTRACT (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n result = operand_1 - operand_2 ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_MULTIPLY : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## MULTIPLY (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n if ( operand_2 == 0 ) {\n result_code = 4 ;\n goto decompression_failure ;\n }\n result = operand_1 * operand_2 ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_DIVIDE : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## DIVIDE (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n if ( operand_2 == 0 ) {\n result_code = 4 ;\n goto decompression_failure ;\n }\n result = operand_1 / operand_2 ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_REMAINDER : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (operand_1, operand_2)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & operand_1 , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_1 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_1 , \"Addr: %u operand_1 %u\" , operand_address , operand_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & operand_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_operand_2 , bytecode_tvb , offset , ( next_operand_address - operand_address ) , operand_2 , \"Addr: %u operand_2 %u\" , operand_address , operand_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## REMAINDER (operand_1=%u, operand_2=%u)\" , current_address , operand_1 , operand_2 ) ;\n }\n if ( operand_2 == 0 ) {\n result_code = 4 ;\n goto decompression_failure ;\n }\n result = operand_1 - operand_2 * ( operand_1 / operand_2 ) ;\n lsb = result & 0xff ;\n msb = result >> 8 ;\n buff [ result_dest ] = msb ;\n buff [ ( result_dest + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading result %u at %u\" , result , result_dest ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_SORT_ASCENDING : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (start, n, k))\" ) ;\n }\n proto_tree_add_expert ( udvm_tree , pinfo , & ei_sigcomp_execution_of_this_instruction_is_not_implemented , bytecode_tvb , 0 , - 1 ) ;\n break ;\n case SIGCOMP_INSTR_SORT_DESCENDING : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (start, n, k))\" ) ;\n }\n proto_tree_add_expert ( udvm_tree , pinfo , & ei_sigcomp_execution_of_this_instruction_is_not_implemented , bytecode_tvb , 0 , - 1 ) ;\n break ;\n case SIGCOMP_INSTR_SHA_1 : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (position, length, destination)\" ) ;\n }\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & position ) ;\n if ( print_level_1 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_position , bytecode_tvb , offset , ( next_operand_address - operand_address ) , position , \"Addr: %u position %u\" , operand_address , position ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & length ) ;\n if ( print_level_1 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , length , \"Addr: %u Length %u\" , operand_address , length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & ref_destination , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( print_level_1 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_ref_dest , bytecode_tvb , offset , ( next_operand_address - operand_address ) , ref_destination , \"Addr: %u $destination %u\" , operand_address , ref_destination ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n used_udvm_cycles = used_udvm_cycles + length ;\n n = 0 ;\n k = position ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , 0 , - 1 , NULL , \"byte_copy_right = %u\" , byte_copy_right ) ;\n }\n sha1_starts ( & ctx ) ;\n while ( n < length ) {\n guint16 handle_now = length ;\n if ( k < byte_copy_right && byte_copy_right <= k + ( length - n ) ) {\n handle_now = byte_copy_right - position ;\n }\n if ( ( k + handle_now >= UDVM_MEMORY_SIZE ) || ( n + handle_now >= UDVM_MEMORY_SIZE ) ) {\n goto decompression_failure ;\n }\n sha1_update ( & ctx , & buff [ k ] , handle_now ) ;\n k = ( k + handle_now ) & 0xffff ;\n n = ( n + handle_now ) & 0xffff ;\n if ( k >= byte_copy_right ) {\n k = byte_copy_left ;\n }\n }\n sha1_finish ( & ctx , sha1_digest_buf ) ;\n k = ref_destination ;\n for ( n = 0 ;\n n < STATE_BUFFER_SIZE ;\n n ++ ) {\n buff [ k ] = sha1_digest_buf [ n ] ;\n k = ( k + 1 ) & 0xffff ;\n n ++ ;\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n }\n if ( print_level_2 ) {\n proto_tree_add_bytes_with_length ( udvm_tree , hf_sigcomp_calculated_sha_1 , message_tvb , 0 , - 1 , sha1_digest_buf , STATE_BUFFER_SIZE ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_LOAD : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (%%address, %%value)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & addr ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , addr , \"Addr: %u Address %u\" , operand_address , addr ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & value ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_value , bytecode_tvb , offset , ( next_operand_address - operand_address ) , value , \"Addr: %u Value %u\" , operand_address , value ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n lsb = value & 0xff ;\n msb = value >> 8 ;\n buff [ addr ] = msb ;\n buff [ ( addr + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## LOAD (%%address=%u, %%value=%u)\" , current_address , addr , value ) ;\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \" Loading bytes at %u Value %u 0x%x\" , addr , value , value ) ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_MULTILOAD : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (%%address, #n, value_0, ..., value_n-1)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & addr ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , addr , \"Addr: %u Address %u\" , operand_address , addr ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_literal_operand ( buff , operand_address , & n ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_literal_num , bytecode_tvb , offset , ( next_operand_address - operand_address ) , n , \"Addr: %u n %u\" , operand_address , n ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## MULTILOAD (%%address=%u, #n=%u, value_0, ..., value_%d)\" , current_address , addr , n , n - 1 ) ;\n }\n operand_address = next_operand_address ;\n used_udvm_cycles = used_udvm_cycles + n ;\n while ( n > 0 ) {\n n = n - 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & value ) ;\n lsb = value & 0xff ;\n msb = value >> 8 ;\n if ( addr >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n buff [ addr ] = msb ;\n buff [ ( addr + 1 ) & 0xffff ] = lsb ;\n length = next_operand_address - operand_address ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , bytecode_tvb , 0 , - 1 , \"Addr: %u Value %5u - Loading bytes at %5u Value %5u 0x%x\" , operand_address , value , addr , value , value ) ;\n }\n addr = addr + 2 ;\n operand_address = next_operand_address ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_PUSH : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (value)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & value ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_value , bytecode_tvb , offset , ( next_operand_address - operand_address ) , value , \"Addr: %u Value %u\" , operand_address , value ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## PUSH (value=%u)\" , current_address , value ) ;\n }\n current_address = next_operand_address ;\n stack_location = ( buff [ 70 ] << 8 ) | buff [ 71 ] ;\n stack_fill = ( buff [ stack_location ] << 8 ) | buff [ ( stack_location + 1 ) & 0xFFFF ] ;\n addr = ( stack_location + stack_fill * 2 + 2 ) & 0xFFFF ;\n if ( addr >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n buff [ addr ] = ( value >> 8 ) & 0x00FF ;\n buff [ ( addr + 1 ) & 0xFFFF ] = value & 0x00FF ;\n if ( stack_location >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n stack_fill = ( stack_fill + 1 ) & 0xFFFF ;\n buff [ stack_location ] = ( stack_fill >> 8 ) & 0x00FF ;\n buff [ ( stack_location + 1 ) & 0xFFFF ] = stack_fill & 0x00FF ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_POP : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (value)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & destination ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , destination , \"Addr: %u Value %u\" , operand_address , destination ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## POP (address=%u)\" , current_address , destination ) ;\n }\n current_address = next_operand_address ;\n stack_location = ( buff [ 70 ] << 8 ) | buff [ 71 ] ;\n stack_fill = ( buff [ stack_location ] << 8 ) | buff [ ( stack_location + 1 ) & 0xFFFF ] ;\n if ( stack_fill == 0 ) {\n result_code = 16 ;\n goto decompression_failure ;\n }\n if ( stack_location >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n stack_fill = ( stack_fill - 1 ) & 0xFFFF ;\n buff [ stack_location ] = ( stack_fill >> 8 ) & 0x00FF ;\n buff [ ( stack_location + 1 ) & 0xFFFF ] = stack_fill & 0x00FF ;\n addr = ( stack_location + stack_fill * 2 + 2 ) & 0xFFFF ;\n if ( addr >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n value = ( buff [ addr ] << 8 ) | buff [ ( addr + 1 ) & 0xFFFF ] ;\n if ( destination >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n buff [ destination ] = ( value >> 8 ) & 0x00FF ;\n buff [ ( destination + 1 ) & 0xFFFF ] = value & 0x00FF ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_COPY : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (position, length, destination)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & position ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_position , bytecode_tvb , offset , ( next_operand_address - operand_address ) , position , \"Addr: %u position %u\" , operand_address , position ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , length , \"Addr: %u Length %u\" , operand_address , length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & destination ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_ref_dest , bytecode_tvb , offset , ( next_operand_address - operand_address ) , destination , \"Addr: %u Destination %u\" , operand_address , destination ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## COPY (position=%u, length=%u, destination=%u)\" , current_address , position , length , destination ) ;\n }\n current_address = next_operand_address ;\n n = 0 ;\n k = destination ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , input_address , 1 , NULL , \" byte_copy_right = %u\" , byte_copy_right ) ;\n }\n while ( n < length ) {\n buff [ k ] = buff [ position ] ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_copying_value , message_tvb , input_address , 1 , buff [ position ] , \" Copying value: %u (0x%x) to Addr: %u\" , buff [ position ] , buff [ position ] , k ) ;\n }\n position = ( position + 1 ) & 0xffff ;\n k = ( k + 1 ) & 0xffff ;\n n ++ ;\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n if ( position == byte_copy_right ) {\n position = byte_copy_left ;\n }\n }\n used_udvm_cycles = used_udvm_cycles + length ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_COPY_LITERAL : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (position, length, $destination)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & position ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_position , bytecode_tvb , offset , ( next_operand_address - operand_address ) , position , \"Addr: %u position %u\" , operand_address , position ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , length , \"Addr: %u Length %u\" , operand_address , length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & ref_destination , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_ref_dest , bytecode_tvb , offset , ( next_operand_address - operand_address ) , ref_destination , \"Addr: %u destination %u\" , operand_address , ref_destination ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## COPY-LITERAL (position=%u, length=%u, $destination=%u)\" , current_address , position , length , ref_destination ) ;\n }\n current_address = next_operand_address ;\n n = 0 ;\n k = ref_destination ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , input_address , 1 , NULL , \" byte_copy_right = %u\" , byte_copy_right ) ;\n }\n while ( n < length ) {\n buff [ k ] = buff [ position ] ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_copying_value , message_tvb , input_address , 1 , buff [ position ] , \" Copying value: %u (0x%x) to Addr: %u\" , buff [ position ] , buff [ position ] , k ) ;\n }\n position = ( position + 1 ) & 0xffff ;\n k = ( k + 1 ) & 0xffff ;\n n ++ ;\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n if ( position == byte_copy_right ) {\n position = byte_copy_left ;\n }\n }\n buff [ result_dest ] = k >> 8 ;\n buff [ ( result_dest + 1 ) & 0xffff ] = k & 0x00ff ;\n used_udvm_cycles = used_udvm_cycles + length ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_COPY_OFFSET : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (offset, length, $destination)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & multy_offset ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_offset , bytecode_tvb , offset , ( next_operand_address - operand_address ) , multy_offset , \"Addr: %u offset %u\" , operand_address , multy_offset ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , length , \"Addr: %u Length %u\" , operand_address , length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = dissect_udvm_reference_operand_memory ( buff , operand_address , & ref_destination , & result_dest ) ;\n if ( next_operand_address < operand_address ) goto decompression_failure ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_ref_dest , bytecode_tvb , offset , ( next_operand_address - operand_address ) , ref_destination , \"Addr: %u $destination %u\" , operand_address , ref_destination ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## COPY-OFFSET (offset=%u, length=%u, $destination=%u)\" , current_address , multy_offset , length , result_dest ) ;\n }\n current_address = next_operand_address ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n for ( position = ref_destination , i = 0 ;\n i < multy_offset ;\n i ++ ) {\n if ( position == byte_copy_left ) {\n position = ( byte_copy_right - 1 ) & 0xffff ;\n }\n else {\n position = ( position - 1 ) & 0xffff ;\n }\n }\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , input_address , 1 , NULL , \" byte_copy_left = %u byte_copy_right = %u position= %u\" , byte_copy_left , byte_copy_right , position ) ;\n }\n n = 0 ;\n k = ref_destination ;\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , input_address , 1 , NULL , \" byte_copy_left = %u byte_copy_right = %u\" , byte_copy_left , byte_copy_right ) ;\n }\n while ( n < length ) {\n buff [ k ] = buff [ position ] ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_copying_value , message_tvb , input_address , 1 , buff [ position ] , \" Copying value: %5u (0x%x) from Addr: %u to Addr: %u\" , buff [ position ] , buff [ position ] , ( position ) , k ) ;\n }\n n ++ ;\n k = ( k + 1 ) & 0xffff ;\n position = ( position + 1 ) & 0xffff ;\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n if ( position == byte_copy_right ) {\n position = byte_copy_left ;\n }\n }\n buff [ result_dest ] = k >> 8 ;\n buff [ result_dest + 1 ] = k & 0x00ff ;\n used_udvm_cycles = used_udvm_cycles + length ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_MEMSET : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (address, length, start_value, offset)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & addr ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , addr , \"Addr: %u Address %u\" , operand_address , addr ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , length , \"Addr: %u Length %u\" , operand_address , length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & start_value ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_start_value , bytecode_tvb , offset , ( next_operand_address - operand_address ) , start_value , \"Addr: %u start_value %u\" , operand_address , start_value ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & multy_offset ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_offset , bytecode_tvb , offset , ( next_operand_address - operand_address ) , multy_offset , \"Addr: %u offset %u\" , operand_address , multy_offset ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## MEMSET (address=%u, length=%u, start_value=%u, offset=%u)\" , current_address , addr , length , start_value , multy_offset ) ;\n }\n current_address = next_operand_address ;\n n = 0 ;\n k = addr ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , input_address , 1 , NULL , \" byte_copy_left = %u byte_copy_right = %u\" , byte_copy_left , byte_copy_right ) ;\n }\n while ( n < length ) {\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n buff [ k ] = ( start_value + ( n * multy_offset ) ) & 0xff ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_storing_value , message_tvb , input_address , 1 , buff [ k ] , \" Storing value: %u (0x%x) at Addr: %u\" , buff [ k ] , buff [ k ] , k ) ;\n }\n k = ( k + 1 ) & 0xffff ;\n n ++ ;\n }\n used_udvm_cycles = used_udvm_cycles + length ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_JUMP : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (@address)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_address_operand ( buff , operand_address , & at_address , current_address ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address , \"Addr: %u @Address %u\" , operand_address , at_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## JUMP (@address=%u)\" , current_address , at_address ) ;\n }\n current_address = at_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_COMPARE : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (value_1, value_2, @address_1, @address_2, @address_3)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & value_1 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_value , bytecode_tvb , offset , ( next_operand_address - operand_address ) , value_1 , \"Addr: %u Value %u\" , operand_address , value_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & value_2 ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_value , bytecode_tvb , offset , ( next_operand_address - operand_address ) , value_2 , \"Addr: %u Value %u\" , operand_address , value_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & at_address_1 ) ;\n at_address_1 = ( current_address + at_address_1 ) & 0xffff ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address_1 , \"Addr: %u @Address %u\" , operand_address , at_address_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & at_address_2 ) ;\n at_address_2 = ( current_address + at_address_2 ) & 0xffff ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address_2 , \"Addr: %u @Address %u\" , operand_address , at_address_2 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & at_address_3 ) ;\n at_address_3 = ( current_address + at_address_3 ) & 0xffff ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address_3 , \"Addr: %u @Address %u\" , operand_address , at_address_3 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## COMPARE (value_1=%u, value_2=%u, @address_1=%u, @address_2=%u, @address_3=%u)\" , current_address , value_1 , value_2 , at_address_1 , at_address_2 , at_address_3 ) ;\n }\n if ( value_1 < value_2 ) current_address = at_address_1 ;\n if ( value_1 == value_2 ) current_address = at_address_2 ;\n if ( value_1 > value_2 ) current_address = at_address_3 ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_CALL : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (@address) (PUSH addr )\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_address_operand ( buff , operand_address , & at_address , current_address ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address , \"Addr: %u @Address %u\" , operand_address , at_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## CALL (@address=%u)\" , current_address , at_address ) ;\n }\n current_address = next_operand_address ;\n stack_location = ( buff [ 70 ] << 8 ) | buff [ 71 ] ;\n stack_fill = ( buff [ stack_location ] << 8 ) | buff [ ( stack_location + 1 ) & 0xFFFF ] ;\n addr = ( stack_location + stack_fill * 2 + 2 ) & 0xFFFF ;\n if ( addr >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n buff [ addr ] = ( current_address >> 8 ) & 0x00FF ;\n buff [ ( addr + 1 ) & 0xFFFF ] = current_address & 0x00FF ;\n stack_fill = ( stack_fill + 1 ) & 0xFFFF ;\n if ( stack_location >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n buff [ stack_location ] = ( stack_fill >> 8 ) & 0x00FF ;\n buff [ ( stack_location + 1 ) & 0xFFFF ] = stack_fill & 0x00FF ;\n current_address = at_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_RETURN : stack_location = ( buff [ 70 ] << 8 ) | buff [ 71 ] ;\n stack_fill = ( buff [ stack_location ] << 8 ) | buff [ ( stack_location + 1 ) & 0xFFFF ] ;\n if ( stack_fill == 0 ) {\n result_code = 16 ;\n goto decompression_failure ;\n }\n stack_fill = ( stack_fill - 1 ) & 0xFFFF ;\n if ( stack_location >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n buff [ stack_location ] = ( stack_fill >> 8 ) & 0x00FF ;\n buff [ ( stack_location + 1 ) & 0xFFFF ] = stack_fill & 0x00FF ;\n addr = ( stack_location + stack_fill * 2 + 2 ) & 0xFFFF ;\n at_address = ( buff [ addr ] << 8 ) | buff [ ( addr + 1 ) & 0xFFFF ] ;\n current_address = at_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_SWITCH : instruction_address = current_address ;\n if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (#n, j, @address_0, @address_1, ... , @address_n-1))\" ) ;\n }\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_literal_operand ( buff , operand_address , & n ) ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_literal_num , bytecode_tvb , offset , ( next_operand_address - operand_address ) , n , \"Addr: %u n %u\" , operand_address , n ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & j ) ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_j , bytecode_tvb , offset , ( next_operand_address - operand_address ) , j , \"Addr: %u j %u\" , operand_address , j ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n m = 0 ;\n while ( m < n ) {\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & at_address_1 ) ;\n at_address_1 = ( instruction_address + at_address_1 ) & 0xffff ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address_1 , \"Addr: %u @Address %u\" , operand_address , at_address_1 ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( j == m ) {\n current_address = at_address_1 ;\n }\n operand_address = next_operand_address ;\n m ++ ;\n }\n if ( ( j == n ) || ( j > n ) ) {\n result_code = 5 ;\n goto decompression_failure ;\n }\n if ( current_address > UDVM_MEMORY_SIZE ) {\n result_code = 6 ;\n goto decompression_failure ;\n }\n used_udvm_cycles = used_udvm_cycles + n ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_CRC : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (value, position, length, @address)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & value ) ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_value , bytecode_tvb , offset , ( next_operand_address - operand_address ) , value , \"Addr: %u Value %u\" , operand_address , value ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & position ) ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_position , bytecode_tvb , offset , ( next_operand_address - operand_address ) , position , \"Addr: %u position %u\" , operand_address , position ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & length ) ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , length , \"Addr: %u Length %u\" , operand_address , length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & at_address ) ;\n at_address = ( current_address + at_address ) & 0xffff ;\n if ( print_level_2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address , \"Addr: %u @Address %u\" , operand_address , at_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n used_udvm_cycles = used_udvm_cycles + length ;\n n = 0 ;\n k = position ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n result = 0 ;\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , 0 , - 1 , NULL , \"byte_copy_right = %u\" , byte_copy_right ) ;\n }\n while ( n < length ) {\n guint16 handle_now = length - n ;\n if ( k < byte_copy_right && byte_copy_right <= k + ( length - n ) ) {\n handle_now = byte_copy_right - k ;\n }\n if ( k + handle_now >= UDVM_MEMORY_SIZE ) goto decompression_failure ;\n result = crc16_ccitt_seed ( & buff [ k ] , handle_now , ( guint16 ) ( result ^ 0xffff ) ) ;\n k = ( k + handle_now ) & 0xffff ;\n n = ( n + handle_now ) & 0xffff ;\n if ( k >= byte_copy_right ) {\n k = byte_copy_left ;\n }\n }\n result = result ^ 0xffff ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Calculated CRC %u\" , result ) ;\n }\n if ( result != value ) {\n current_address = at_address ;\n }\n else {\n current_address = next_operand_address ;\n }\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_INPUT_BYTES : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" length, destination, @address)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , length , \"Addr: %u Length %u\" , operand_address , length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & destination ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_destination , bytecode_tvb , offset , ( next_operand_address - operand_address ) , destination , \"Addr: %u Destination %u\" , operand_address , destination ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & at_address ) ;\n at_address = ( current_address + at_address ) & 0xffff ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address , \"Addr: %u @Address %u\" , operand_address , at_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## INPUT-BYTES length=%u, destination=%u, @address=%u)\" , current_address , length , destination , at_address ) ;\n }\n n = 0 ;\n k = destination ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n if ( print_level_1 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , input_address , 1 , NULL , \" byte_copy_right = %u\" , byte_copy_right ) ;\n }\n remaining_bits = 0 ;\n input_bits = 0 ;\n while ( n < length ) {\n if ( input_address > ( msg_end - 1 ) ) {\n current_address = at_address ;\n result_code = 14 ;\n goto execute_next_instruction ;\n }\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n octet = tvb_get_guint8 ( message_tvb , input_address ) ;\n buff [ k ] = octet ;\n if ( print_level_1 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_loading_value , message_tvb , input_address , 1 , octet , \" Loading value: %u (0x%x) at Addr: %u\" , octet , octet , k ) ;\n }\n input_address ++ ;\n k = ( k + 1 ) & 0xffff ;\n n ++ ;\n }\n used_udvm_cycles = used_udvm_cycles + length ;\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_INPUT_BITS : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (length, destination, @address)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , length , \"Addr: %u length %u\" , operand_address , length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & destination ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_destination , bytecode_tvb , offset , ( next_operand_address - operand_address ) , destination , \"Addr: %u Destination %u\" , operand_address , destination ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_address_operand ( buff , operand_address , & at_address , current_address ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address , \"Addr: %u @Address %u\" , operand_address , at_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## INPUT-BITS length=%u, destination=%u, @address=%u)\" , current_address , length , destination , at_address ) ;\n }\n current_address = next_operand_address ;\n input_bit_order = buff [ 68 ] << 8 ;\n input_bit_order = input_bit_order | buff [ 69 ] ;\n if ( length > 16 ) {\n result_code = 7 ;\n goto decompression_failure ;\n }\n if ( input_bit_order > 7 ) {\n result_code = 8 ;\n goto decompression_failure ;\n }\n bit_order = ( input_bit_order & 0x0004 ) >> 2 ;\n value = decomp_dispatch_get_bits ( message_tvb , udvm_tree , bit_order , buff , & old_input_bit_order , & remaining_bits , & input_bits , & input_address , length , & result_code , msg_end , print_level_1 ) ;\n if ( result_code == 11 ) {\n current_address = at_address ;\n goto execute_next_instruction ;\n }\n msb = value >> 8 ;\n lsb = value & 0x00ff ;\n if ( destination >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n buff [ destination ] = msb ;\n buff [ ( destination + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_loading_result , message_tvb , input_address , 1 , \" Loading value: %u (0x%x) at Addr: %u, remaining_bits: %u\" , value , value , destination , remaining_bits ) ;\n }\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_INPUT_HUFFMAN : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (destination, @address, #n, bits_1, lower_bound_1,upper_bound_1, uncompressed_1, ... , bits_n, lower_bound_n,upper_bound_n, uncompressed_n)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & destination ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_destination , bytecode_tvb , offset , ( next_operand_address - operand_address ) , destination , \"Addr: %u Destination %u\" , operand_address , destination ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_address_operand ( buff , operand_address , & at_address , current_address ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_at_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , at_address , \"Addr: %u @Address %u\" , operand_address , at_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_literal_operand ( buff , operand_address , & n ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_literal_num , bytecode_tvb , offset , ( next_operand_address - operand_address ) , n , \"Addr: %u n %u\" , operand_address , n ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## INPUT-HUFFMAN (destination=%u, @address=%u, #n=%u, bits_1, lower_1,upper_1, unc_1, ... , bits_%d, lower_%d,upper_%d, unc_%d)\" , current_address , destination , at_address , n , n , n , n , n ) ;\n }\n used_udvm_cycles = used_udvm_cycles + n ;\n input_bit_order = buff [ 68 ] << 8 ;\n input_bit_order = input_bit_order | buff [ 69 ] ;\n bit_order = ( input_bit_order & 0x0002 ) >> 1 ;\n j = 1 ;\n H = 0 ;\n m = n ;\n outside_huffman_boundaries = TRUE ;\n print_in_loop = print_level_3 ;\n while ( m > 0 ) {\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & bits_n ) ;\n if ( print_in_loop ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_bits , bytecode_tvb , offset , ( next_operand_address - operand_address ) , bits_n , \"Addr: %u bits_n %u\" , operand_address , bits_n ) ;\n }\n if ( bits_n > 31 ) break ;\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & lower_bound_n ) ;\n if ( print_in_loop ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_lower_bound , bytecode_tvb , offset , ( next_operand_address - operand_address ) , lower_bound_n , \"Addr: %u lower_bound_n %u\" , operand_address , lower_bound_n ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & upper_bound_n ) ;\n if ( print_in_loop ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_upper_bound , bytecode_tvb , offset , ( next_operand_address - operand_address ) , upper_bound_n , \"Addr: %u upper_bound_n %u\" , operand_address , upper_bound_n ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & uncompressed_n ) ;\n if ( print_in_loop ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_uncompressed , bytecode_tvb , offset , ( next_operand_address - operand_address ) , uncompressed_n , \"Addr: %u uncompressed_n %u\" , operand_address , uncompressed_n ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n if ( outside_huffman_boundaries ) {\n k = decomp_dispatch_get_bits ( message_tvb , udvm_tree , bit_order , buff , & old_input_bit_order , & remaining_bits , & input_bits , & input_address , bits_n , & result_code , msg_end , print_level_1 ) ;\n if ( result_code == 11 ) {\n current_address = at_address ;\n goto execute_next_instruction ;\n }\n oldH = H ;\n H = ( H << bits_n ) | k ;\n if ( print_level_3 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_set_hu , bytecode_tvb , 0 , - 1 , NULL , \" Set H(%u) := H(%u) * 2^bits_j(%u) + k(%u)\" , H , oldH , 1 << bits_n , k ) ;\n }\n if ( ( H < lower_bound_n ) || ( H > upper_bound_n ) ) {\n outside_huffman_boundaries = TRUE ;\n }\n else {\n outside_huffman_boundaries = FALSE ;\n print_in_loop = FALSE ;\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_set_hu , bytecode_tvb , 0 , - 1 , NULL , \" H(%u) = H(%u) + uncompressed_n(%u) - lower_bound_n(%u)\" , ( H + uncompressed_n - lower_bound_n ) , H , uncompressed_n , lower_bound_n ) ;\n }\n H = H + uncompressed_n - lower_bound_n ;\n msb = H >> 8 ;\n lsb = H & 0x00ff ;\n if ( destination >= UDVM_MEMORY_SIZE - 1 ) goto decompression_failure ;\n buff [ destination ] = msb ;\n buff [ ( destination + 1 ) & 0xffff ] = lsb ;\n if ( print_level_1 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_loading_h , message_tvb , input_address , 1 , H , \" Loading H: %u (0x%x) at Addr: %u,j = %u remaining_bits: %u\" , H , H , destination , ( n - m + 1 ) , remaining_bits ) ;\n }\n }\n }\n m = m - 1 ;\n }\n if ( outside_huffman_boundaries ) {\n result_code = 10 ;\n goto decompression_failure ;\n }\n current_address = next_operand_address ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_STATE_ACCESS : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (partial_identifier_start, partial_identifier_length,state_begin, state_length, state_address, state_instruction)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & p_id_start ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_partial_identifier_start , bytecode_tvb , offset , ( next_operand_address - operand_address ) , p_id_start , \"Addr: %u partial_identifier_start %u\" , operand_address , p_id_start ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & p_id_length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_partial_identifier_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , p_id_length , \"Addr: %u partial_identifier_length %u\" , operand_address , p_id_length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_begin ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_state_begin , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_begin , \"Addr: %u state_begin %u\" , operand_address , state_begin ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_length , \"Addr: %u state_length %u\" , operand_address , state_length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_address ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_address , \"Addr: %u state_address %u\" , operand_address , state_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_instruction ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_instr , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_instruction , \"Addr: %u state_instruction %u\" , operand_address , state_instruction ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## STATE-ACCESS(31) (partial_identifier_start=%u, partial_identifier_length=%u,state_begin=%u, state_length=%u, state_address=%u, state_instruction=%u)\" , current_address , p_id_start , p_id_length , state_begin , state_length , state_address , state_instruction ) ;\n }\n current_address = next_operand_address ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n if ( print_level_2 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , message_tvb , input_address , 1 , NULL , \" byte_copy_right = %u, byte_copy_left = %u\" , byte_copy_right , byte_copy_left ) ;\n }\n result_code = udvm_state_access ( message_tvb , udvm_tree , buff , p_id_start , p_id_length , state_begin , & state_length , & state_address , & state_instruction , hf_id ) ;\n if ( result_code != 0 ) {\n goto decompression_failure ;\n }\n used_udvm_cycles = used_udvm_cycles + state_length ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_STATE_CREATE : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (state_length, state_address, state_instruction,minimum_access_length, state_retention_priority)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_length , \"Addr: %u state_length %u\" , operand_address , state_length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_address ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_address , \"Addr: %u state_address %u\" , operand_address , state_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_instruction ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_instr , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_instruction , \"Addr: %u state_instruction %u\" , operand_address , state_instruction ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & minimum_access_length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_min_acc_len , bytecode_tvb , offset , ( next_operand_address - operand_address ) , minimum_access_length , \"Addr: %u minimum_access_length %u\" , operand_address , minimum_access_length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_retention_priority ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_ret_pri , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_retention_priority , \"Addr: %u state_retention_priority %u\" , operand_address , state_retention_priority ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## STATE-CREATE(32) (state_length=%u, state_address=%u, state_instruction=%u,minimum_access_length=%u, state_retention_priority=%u)\" , current_address , state_length , state_address , state_instruction , minimum_access_length , state_retention_priority ) ;\n }\n current_address = next_operand_address ;\n no_of_state_create ++ ;\n if ( no_of_state_create > 4 ) {\n result_code = 12 ;\n goto decompression_failure ;\n }\n if ( ( minimum_access_length < 6 ) || ( minimum_access_length > STATE_BUFFER_SIZE ) ) {\n result_code = 1 ;\n goto decompression_failure ;\n }\n if ( state_retention_priority == 65535 ) {\n result_code = 13 ;\n goto decompression_failure ;\n }\n state_length_buff [ no_of_state_create ] = state_length ;\n state_address_buff [ no_of_state_create ] = state_address ;\n state_instruction_buff [ no_of_state_create ] = state_instruction ;\n state_minimum_access_length_buff [ no_of_state_create ] = minimum_access_length ;\n used_udvm_cycles = used_udvm_cycles + state_length ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n n = 0 ;\n k = state_address ;\n while ( n < state_length ) {\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n string [ 0 ] = buff [ k ] ;\n string [ 1 ] = '\\0' ;\n if ( print_level_3 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_state_value , bytecode_tvb , 0 , 0 , buff [ k ] , \" Addr: %5u State value: %u (0x%x) ASCII(%s)\" , k , buff [ k ] , buff [ k ] , format_text ( string , 1 ) ) ;\n }\n k = ( k + 1 ) & 0xffff ;\n n ++ ;\n }\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_STATE_FREE : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (partial_identifier_start, partial_identifier_length)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & p_id_start ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_partial_identifier_start , bytecode_tvb , offset , ( next_operand_address - operand_address ) , p_id_start , \"Addr: %u partial_identifier_start %u\" , operand_address , p_id_start ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & p_id_length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_partial_identifier_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , p_id_length , \"Addr: %u partial_identifier_length %u\" , operand_address , p_id_length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## STATE-FREE (partial_identifier_start=%u, partial_identifier_length=%u)\" , current_address , p_id_start , p_id_length ) ;\n }\n current_address = next_operand_address ;\n udvm_state_free ( buff , p_id_start , p_id_length ) ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_OUTPUT : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (output_start, output_length)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & output_start ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_output_start , bytecode_tvb , offset , ( next_operand_address - operand_address ) , output_start , \"Addr: %u output_start %u\" , operand_address , output_start ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & output_length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_output_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , output_length , \"Addr: %u output_length %u\" , operand_address , output_length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## OUTPUT (output_start=%u, output_length=%u)\" , current_address , output_start , output_length ) ;\n }\n current_address = next_operand_address ;\n n = 0 ;\n k = output_start ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n if ( print_level_3 ) {\n proto_tree_add_bytes_format ( udvm_tree , hf_sigcomp_byte_copy , bytecode_tvb , 0 , - 1 , NULL , \" byte_copy_right = %u\" , byte_copy_right ) ;\n }\n while ( n < output_length ) {\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n out_buff [ output_address ] = buff [ k ] ;\n string [ 0 ] = buff [ k ] ;\n string [ 1 ] = '\\0' ;\n if ( print_level_3 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_sigcomp_output_value , bytecode_tvb , 0 , - 1 , buff [ k ] , \" Output value: %u (0x%x) ASCII(%s) from Addr: %u ,output to dispatcher position %u\" , buff [ k ] , buff [ k ] , format_text ( string , 1 ) , k , output_address ) ;\n }\n k = ( k + 1 ) & 0xffff ;\n output_address ++ ;\n n ++ ;\n }\n used_udvm_cycles = used_udvm_cycles + output_length ;\n goto execute_next_instruction ;\n break ;\n case SIGCOMP_INSTR_END_MESSAGE : if ( show_instr_detail_level == 2 ) {\n proto_item_append_text ( addr_item , \" (requested_feedback_location,state_instruction, minimum_access_length,state_retention_priority)\" ) ;\n }\n start_offset = offset ;\n operand_address = current_address + 1 ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & requested_feedback_location ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_req_feedback_loc , bytecode_tvb , offset , ( next_operand_address - operand_address ) , requested_feedback_location , \"Addr: %u requested_feedback_location %u\" , operand_address , requested_feedback_location ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & returned_parameters_location ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_ret_param_loc , bytecode_tvb , offset , ( next_operand_address - operand_address ) , returned_parameters_location , \"Addr: %u returned_parameters_location %u\" , operand_address , returned_parameters_location ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_length , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_length , \"Addr: %u state_length %u\" , operand_address , state_length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_address ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_address , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_address , \"Addr: %u state_address %u\" , operand_address , state_address ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_instruction ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_instr , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_instruction , \"Addr: %u state_instruction %u\" , operand_address , state_instruction ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & minimum_access_length ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_min_acc_len , bytecode_tvb , offset , ( next_operand_address - operand_address ) , minimum_access_length , \"Addr: %u minimum_access_length %u\" , operand_address , minimum_access_length ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n operand_address = next_operand_address ;\n next_operand_address = decode_udvm_multitype_operand ( buff , operand_address , & state_retention_priority ) ;\n if ( show_instr_detail_level == 2 ) {\n proto_tree_add_uint_format ( udvm_tree , hf_udvm_state_ret_pri , bytecode_tvb , offset , ( next_operand_address - operand_address ) , state_retention_priority , \"Addr: %u state_retention_priority %u\" , operand_address , state_retention_priority ) ;\n }\n offset += ( next_operand_address - operand_address ) ;\n if ( show_instr_detail_level == 1 ) {\n proto_tree_add_none_format ( udvm_tree , hf_sigcomp_decompress_instruction , bytecode_tvb , start_offset , offset - start_offset , \"Addr: %u ## END-MESSAGE (requested_feedback_location=%u, returned_parameters_location=%u, state_length=%u, state_address=%u, state_instruction=%u, minimum_access_length=%u, state_retention_priority=%u)\" , current_address , requested_feedback_location , returned_parameters_location , state_length , state_address , state_instruction , minimum_access_length , state_retention_priority ) ;\n }\n no_of_state_create ++ ;\n if ( no_of_state_create > 4 ) {\n result_code = 12 ;\n goto decompression_failure ;\n }\n state_length_buff [ no_of_state_create ] = state_length ;\n state_address_buff [ no_of_state_create ] = state_address ;\n state_instruction_buff [ no_of_state_create ] = state_instruction ;\n state_minimum_access_length_buff [ no_of_state_create ] = minimum_access_length ;\n proto_tree_add_uint ( udvm_tree , hf_sigcomp_num_state_create , bytecode_tvb , 0 , 0 , no_of_state_create ) ;\n if ( no_of_state_create != 0 ) {\n memset ( sha1_digest_buf , 0 , STATE_BUFFER_SIZE ) ;\n n = 1 ;\n byte_copy_right = buff [ 66 ] << 8 ;\n byte_copy_right = byte_copy_right | buff [ 67 ] ;\n byte_copy_left = buff [ 64 ] << 8 ;\n byte_copy_left = byte_copy_left | buff [ 65 ] ;\n while ( n < no_of_state_create + 1 ) {\n sha1buff = ( guint8 * ) g_malloc ( state_length_buff [ n ] + 8 ) ;\n sha1buff [ 0 ] = state_length_buff [ n ] >> 8 ;\n sha1buff [ 1 ] = state_length_buff [ n ] & 0xff ;\n sha1buff [ 2 ] = state_address_buff [ n ] >> 8 ;\n sha1buff [ 3 ] = state_address_buff [ n ] & 0xff ;\n sha1buff [ 4 ] = state_instruction_buff [ n ] >> 8 ;\n sha1buff [ 5 ] = state_instruction_buff [ n ] & 0xff ;\n sha1buff [ 6 ] = state_minimum_access_length_buff [ n ] >> 8 ;\n sha1buff [ 7 ] = state_minimum_access_length_buff [ n ] & 0xff ;\n if ( print_level_3 ) {\n proto_tree_add_bytes_with_length ( udvm_tree , hf_sigcomp_sha1buff , bytecode_tvb , 0 , - 1 , sha1buff , 8 ) ;\n }\n k = state_address_buff [ n ] ;\n for ( x = 0 ;\n x < state_length_buff [ n ] ;\n x ++ ) {\n if ( k == byte_copy_right ) {\n k = byte_copy_left ;\n }\n sha1buff [ 8 + x ] = buff [ k ] ;\n k = ( k + 1 ) & 0xffff ;\n }\n sha1_starts ( & ctx ) ;\n sha1_update ( & ctx , ( guint8 * ) sha1buff , state_length_buff [ n ] + 8 ) ;\n sha1_finish ( & ctx , sha1_digest_buf ) ;\n if ( print_level_3 ) {\n proto_tree_add_bytes_with_length ( udvm_tree , hf_sigcomp_sha1_digest , bytecode_tvb , 0 , - 1 , sha1_digest_buf , STATE_BUFFER_SIZE ) ;\n }\n # if 0 udvm_state_create ( sha1buff , sha1_digest_buf , state_minimum_access_length_buff [ n ] ) ;\n # endif udvm_state_create ( sha1buff , sha1_digest_buf , STATE_MIN_ACCESS_LEN ) ;\n proto_tree_add_item ( udvm_tree , hf_sigcomp_creating_state , bytecode_tvb , 0 , - 1 , ENC_NA ) ;\n proto_tree_add_string ( udvm_tree , hf_id , bytecode_tvb , 0 , 0 , bytes_to_str ( wmem_packet_scope ( ) , sha1_digest_buf , STATE_MIN_ACCESS_LEN ) ) ;\n n ++ ;\n }\n }\n decomp_tvb = tvb_new_child_real_data ( message_tvb , out_buff , output_address , output_address ) ;\n tvb_set_free_cb ( decomp_tvb , g_free ) ;\n add_new_data_source ( pinfo , decomp_tvb , \"Decompressed SigComp message\" ) ;\n proto_tree_add_item ( udvm_tree , hf_sigcomp_sigcomp_message_decompressed , decomp_tvb , 0 , - 1 , ENC_NA ) ;\n used_udvm_cycles += state_length ;\n proto_tree_add_uint ( udvm_tree , hf_sigcomp_max_udvm_cycles , bytecode_tvb , 0 , 0 , maximum_UDVM_cycles ) ;\n proto_tree_add_uint ( udvm_tree , hf_sigcomp_used_udvm_cycles , bytecode_tvb , 0 , 0 , used_udvm_cycles ) ;\n return decomp_tvb ;\n break ;\n default : expert_add_info_format ( pinfo , addr_item , & ei_sigcomp_invalid_instruction , \"Addr %u Invalid instruction: %u (0x%x)\" , current_address , current_instruction , current_instruction ) ;\n break ;\n }\n g_free ( out_buff ) ;\n return NULL ;\n decompression_failure : proto_tree_add_expert_format ( udvm_tree , pinfo , & ei_sigcomp_decompression_failure , bytecode_tvb , 0 , - 1 , \"DECOMPRESSION FAILURE: %s\" , val_to_str ( result_code , result_code_vals , \"Unknown (%u)\" ) ) ;\n g_free ( out_buff ) ;\n return NULL ;\n }",
        "hash": -7777644912037188223,
        "project": "debian",
        "size": 1662,
        "slice": {
            "memset": [
                [
                    1602,
                    " if ( no_of_state_create != 0 ) {\n"
                ],
                [
                    1603,
                    " memset ( sha1_digest_buf , 0 , STATE_BUFFER_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1602,
                    " if ( no_of_state_create != 0 ) {\n"
                ],
                [
                    1603,
                    " memset ( sha1_digest_buf , 0 , STATE_BUFFER_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int set_wep_key ( char * string ) {\n int bit = 0 ;\n char * p , type ;\n char * tok ;\n char s [ strlen ( string ) + 1 ] ;\n u_char tmp_wkey [ 512 ] ;\n size_t tmp_wkey_len ;\n char tmp [ 128 ] ;\n memset ( GBL_WIFI -> wkey , 0 , sizeof ( GBL_WIFI -> wkey ) ) ;\n GBL_WIFI -> wkey_len = 0 ;\n strcpy ( s , string ) ;\n p = ec_strtok ( s , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n bit = atoi ( p ) ;\n if ( bit <= 0 ) SEMIFATAL_ERROR ( \"Unsupported WEP key length\" ) ;\n tmp_wkey_len = bit / 8 - WEP_IV_LEN ;\n if ( bit != 64 && bit != 128 ) SEMIFATAL_ERROR ( \"Unsupported WEP key length\" ) ;\n p = ec_strtok ( NULL , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n type = * p ;\n p = ec_strtok ( NULL , \":\" , & tok ) ;\n if ( p == NULL ) SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n if ( type == 's' ) {\n if ( strescape ( ( char * ) tmp_wkey , p ) != ( int ) tmp_wkey_len ) SEMIFATAL_ERROR ( \"Specified WEP key length does not match the given string\" ) ;\n }\n else if ( type == 'p' ) {\n if ( bit == 64 ) make_key_64 ( ( u_char * ) p , tmp_wkey ) ;\n else if ( bit == 128 ) make_key_128 ( ( u_char * ) p , tmp_wkey ) ;\n }\n else {\n SEMIFATAL_ERROR ( \"Invalid parsing of the WEP key\" ) ;\n }\n USER_MSG ( \"Using WEP key: %s\\n\" , str_tohex ( tmp_wkey , tmp_wkey_len , tmp , sizeof ( tmp ) ) ) ;\n memcpy ( GBL_WIFI -> wkey , tmp_wkey , sizeof ( GBL_WIFI -> wkey ) ) ;\n GBL_WIFI -> wkey_len = tmp_wkey_len ;\n return E_SUCCESS ;\n }",
        "hash": 9083170310480750768,
        "project": "debian",
        "size": 37,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int set_wep_key ( char * string ) {\n"
                ],
                [
                    33,
                    " USER_MSG ( \"Using WEP key: %s\\n\" , str_tohex ( tmp_wkey , tmp_wkey_len , tmp , sizeof ( tmp ) ) ) ;\n"
                ],
                [
                    34,
                    " memcpy ( GBL_WIFI -> wkey , tmp_wkey , sizeof ( GBL_WIFI -> wkey ) ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int set_wep_key ( char * string ) {\n"
                ],
                [
                    9,
                    " memset ( GBL_WIFI -> wkey , 0 , sizeof ( GBL_WIFI -> wkey ) ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "int set_wep_key ( char * string ) {\n"
                ],
                [
                    5,
                    " char s [ strlen ( string ) + 1 ] ;\n"
                ],
                [
                    11,
                    " strcpy ( s , string ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int set_wep_key ( char * string ) {\n"
                ],
                [
                    5,
                    " char s [ strlen ( string ) + 1 ] ;\n"
                ],
                [
                    9,
                    " memset ( GBL_WIFI -> wkey , 0 , sizeof ( GBL_WIFI -> wkey ) ) ;\n"
                ],
                [
                    11,
                    " strcpy ( s , string ) ;\n"
                ],
                [
                    33,
                    " USER_MSG ( \"Using WEP key: %s\\n\" , str_tohex ( tmp_wkey , tmp_wkey_len , tmp , sizeof ( tmp ) ) ) ;\n"
                ],
                [
                    34,
                    " memcpy ( GBL_WIFI -> wkey , tmp_wkey , sizeof ( GBL_WIFI -> wkey ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int encode_const ( char * string , struct filter_op * fop ) {\n char * p ;\n memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n if ( ! strncmp ( string , \"0x\" , 2 ) && isxdigit ( ( int ) string [ 2 ] ) ) {\n fop -> op . test . value = strtoul ( string , NULL , 16 ) ;\n return E_SUCCESS ;\n }\n else if ( isdigit ( ( int ) string [ 0 ] ) ) {\n fop -> op . test . value = strtoul ( string , NULL , 10 ) ;\n return E_SUCCESS ;\n }\n else if ( string [ 0 ] == '\\'' && string [ strlen ( string ) - 1 ] == '\\'' ) {\n struct ip_addr ipaddr ;\n p = strchr ( string + 1 , '\\'' ) ;\n * p = '\\0' ;\n if ( ip_addr_pton ( string + 1 , & ipaddr ) == E_SUCCESS ) {\n switch ( ntohs ( ipaddr . addr_type ) ) {\n case AF_INET : fop -> op . test . value = ntohl ( ipaddr . addr32 [ 0 ] ) ;\n break ;\n case AF_INET6 : ip_addr_cpy ( ( u_char * ) & fop -> op . test . ipaddr , & ipaddr ) ;\n break ;\n default : return - E_FATAL ;\n }\n }\n else {\n return - E_FATAL ;\n }\n return E_SUCCESS ;\n }\n else if ( string [ 0 ] == '\\\"' && string [ strlen ( string ) - 1 ] == '\\\"' ) {\n p = strchr ( string + 1 , '\\\"' ) ;\n * p = '\\0' ;\n fop -> op . test . string = ( u_char * ) strdup ( string + 1 ) ;\n fop -> op . test . slen = strescape ( ( char * ) fop -> op . test . string , ( char * ) fop -> op . test . string ) ;\n return E_SUCCESS ;\n }\n else if ( isalpha ( ( int ) string [ 0 ] ) ) {\n return get_constant ( string , & fop -> op . test . value ) ;\n }\n return - E_NOTFOUND ;\n }",
        "hash": 421700949231983751,
        "project": "debian",
        "size": 41,
        "slice": {
            "memset": [
                [
                    1,
                    "int encode_const ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    3,
                    " memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n"
                ]
            ],
            "strchr": [
                [
                    1,
                    "int encode_const ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    4,
                    " if ( ! strncmp ( string , \"0x\" , 2 ) && isxdigit ( ( int ) string [ 2 ] ) ) {\n"
                ],
                [
                    12,
                    " else if ( string [ 0 ] == '\\'' && string [ strlen ( string ) - 1 ] == '\\'' ) {\n"
                ],
                [
                    14,
                    " p = strchr ( string + 1 , '\\'' ) ;\n"
                ],
                [
                    30,
                    " else if ( string [ 0 ] == '\\\"' && string [ strlen ( string ) - 1 ] == '\\\"' ) {\n"
                ],
                [
                    31,
                    " p = strchr ( string + 1 , '\\\"' ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "int encode_const ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    4,
                    " if ( ! strncmp ( string , \"0x\" , 2 ) && isxdigit ( ( int ) string [ 2 ] ) ) {\n"
                ],
                [
                    8,
                    " else if ( isdigit ( ( int ) string [ 0 ] ) ) {\n"
                ],
                [
                    12,
                    " else if ( string [ 0 ] == '\\'' && string [ strlen ( string ) - 1 ] == '\\'' ) {\n"
                ],
                [
                    14,
                    " p = strchr ( string + 1 , '\\'' ) ;\n"
                ],
                [
                    15,
                    " * p = '\\0' ;\n"
                ],
                [
                    16,
                    " if ( ip_addr_pton ( string + 1 , & ipaddr ) == E_SUCCESS ) {\n"
                ],
                [
                    30,
                    " else if ( string [ 0 ] == '\\\"' && string [ strlen ( string ) - 1 ] == '\\\"' ) {\n"
                ],
                [
                    31,
                    " p = strchr ( string + 1 , '\\\"' ) ;\n"
                ],
                [
                    32,
                    " * p = '\\0' ;\n"
                ],
                [
                    33,
                    " fop -> op . test . string = ( u_char * ) strdup ( string + 1 ) ;\n"
                ],
                [
                    34,
                    " fop -> op . test . slen = strescape ( ( char * ) fop -> op . test . string , ( char * ) fop -> op . test . string ) ;\n"
                ],
                [
                    35,
                    " return E_SUCCESS ;\n"
                ],
                [
                    37,
                    " else if ( isalpha ( ( int ) string [ 0 ] ) ) {\n"
                ],
                [
                    38,
                    " return get_constant ( string , & fop -> op . test . value ) ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "int encode_const ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    4,
                    " if ( ! strncmp ( string , \"0x\" , 2 ) && isxdigit ( ( int ) string [ 2 ] ) ) {\n"
                ],
                [
                    12,
                    " else if ( string [ 0 ] == '\\'' && string [ strlen ( string ) - 1 ] == '\\'' ) {\n"
                ],
                [
                    30,
                    " else if ( string [ 0 ] == '\\\"' && string [ strlen ( string ) - 1 ] == '\\\"' ) {\n"
                ],
                [
                    33,
                    " fop -> op . test . string = ( u_char * ) strdup ( string + 1 ) ;\n"
                ],
                [
                    34,
                    " fop -> op . test . slen = strescape ( ( char * ) fop -> op . test . string , ( char * ) fop -> op . test . string ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int encode_const ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    3,
                    " memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n"
                ],
                [
                    4,
                    " if ( ! strncmp ( string , \"0x\" , 2 ) && isxdigit ( ( int ) string [ 2 ] ) ) {\n"
                ],
                [
                    8,
                    " else if ( isdigit ( ( int ) string [ 0 ] ) ) {\n"
                ],
                [
                    12,
                    " else if ( string [ 0 ] == '\\'' && string [ strlen ( string ) - 1 ] == '\\'' ) {\n"
                ],
                [
                    14,
                    " p = strchr ( string + 1 , '\\'' ) ;\n"
                ],
                [
                    15,
                    " * p = '\\0' ;\n"
                ],
                [
                    16,
                    " if ( ip_addr_pton ( string + 1 , & ipaddr ) == E_SUCCESS ) {\n"
                ],
                [
                    30,
                    " else if ( string [ 0 ] == '\\\"' && string [ strlen ( string ) - 1 ] == '\\\"' ) {\n"
                ],
                [
                    31,
                    " p = strchr ( string + 1 , '\\\"' ) ;\n"
                ],
                [
                    32,
                    " * p = '\\0' ;\n"
                ],
                [
                    33,
                    " fop -> op . test . string = ( u_char * ) strdup ( string + 1 ) ;\n"
                ],
                [
                    34,
                    " fop -> op . test . slen = strescape ( ( char * ) fop -> op . test . string , ( char * ) fop -> op . test . string ) ;\n"
                ],
                [
                    35,
                    " return E_SUCCESS ;\n"
                ],
                [
                    37,
                    " else if ( isalpha ( ( int ) string [ 0 ] ) ) {\n"
                ],
                [
                    38,
                    " return get_constant ( string , & fop -> op . test . value ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int encode_function ( char * string , struct filter_op * fop ) {\n char * str = strdup ( string ) ;\n int ret = - E_NOTFOUND ;\n char * name , * args ;\n int nargs = 0 , i ;\n char * * dec_args = NULL ;\n char * tok ;\n memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n name = ec_strtok ( string , \"(\" , & tok ) ;\n args = name + strlen ( name ) + 1 ;\n dec_args = decode_args ( args , & nargs ) ;\n fop -> opcode = FOP_FUNC ;\n if ( ! strcmp ( name , \"search\" ) ) {\n if ( nargs == 2 ) {\n if ( encode_offset ( dec_args [ 0 ] , fop ) == E_SUCCESS ) {\n fop -> opcode = FOP_FUNC ;\n fop -> op . func . op = FFUNC_SEARCH ;\n fop -> op . func . string = ( u_char * ) strdup ( dec_args [ 1 ] ) ;\n fop -> op . func . slen = strescape ( ( char * ) fop -> op . func . string , ( char * ) fop -> op . func . string ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Unknown offset %s \" , dec_args [ 0 ] ) ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"regex\" ) ) {\n if ( nargs == 2 ) {\n int err ;\n regex_t regex ;\n char errbuf [ 100 ] ;\n if ( encode_offset ( dec_args [ 0 ] , fop ) == E_SUCCESS ) {\n fop -> opcode = FOP_FUNC ;\n fop -> op . func . op = FFUNC_REGEX ;\n fop -> op . func . string = ( u_char * ) strdup ( dec_args [ 1 ] ) ;\n fop -> op . func . slen = strescape ( ( char * ) fop -> op . func . string , ( char * ) fop -> op . func . string ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Unknown offset %s \" , dec_args [ 0 ] ) ;\n err = regcomp ( & regex , ( const char * ) fop -> op . func . string , REG_EXTENDED | REG_NOSUB | REG_ICASE ) ;\n if ( err ) {\n regerror ( err , & regex , errbuf , sizeof ( errbuf ) ) ;\n SCRIPT_ERROR ( \"%s\" , errbuf ) ;\n }\n regfree ( & regex ) ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"pcre_regex\" ) ) {\n # ifndef HAVE_PCRE WARNING ( \"The script contains pcre_regex, but you don't have support for it.\" ) ;\n # else pcre * pregex ;\n const char * errbuf = NULL ;\n int erroff ;\n if ( nargs == 2 ) {\n if ( encode_offset ( dec_args [ 0 ] , fop ) == E_SUCCESS ) {\n fop -> opcode = FOP_FUNC ;\n fop -> op . func . op = FFUNC_PCRE ;\n fop -> op . func . string = strdup ( dec_args [ 1 ] ) ;\n fop -> op . func . slen = strlen ( fop -> op . func . string ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Unknown offset %s \" , dec_args [ 0 ] ) ;\n pregex = pcre_compile ( fop -> op . func . string , 0 , & errbuf , & erroff , NULL ) ;\n if ( pregex == NULL ) SCRIPT_ERROR ( \"%s\\n\" , errbuf ) ;\n pcre_free ( pregex ) ;\n }\n else if ( nargs == 3 ) {\n fop -> opcode = FOP_FUNC ;\n fop -> op . func . op = FFUNC_PCRE ;\n fop -> op . func . level = 5 ;\n fop -> op . func . string = strdup ( dec_args [ 1 ] ) ;\n fop -> op . func . slen = strlen ( fop -> op . func . string ) ;\n fop -> op . func . replace = strdup ( dec_args [ 2 ] ) ;\n fop -> op . func . rlen = strlen ( fop -> op . func . replace ) ;\n ret = E_SUCCESS ;\n pregex = pcre_compile ( fop -> op . func . string , 0 , & errbuf , & erroff , NULL ) ;\n if ( pregex == NULL ) SCRIPT_ERROR ( \"%s\\n\" , errbuf ) ;\n pcre_free ( pregex ) ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n # endif }\n else if ( ! strcmp ( name , \"replace\" ) ) {\n if ( nargs == 2 ) {\n fop -> op . func . op = FFUNC_REPLACE ;\n fop -> op . func . level = 5 ;\n fop -> op . func . string = ( u_char * ) strdup ( dec_args [ 0 ] ) ;\n fop -> op . func . slen = strescape ( ( char * ) fop -> op . func . string , ( char * ) fop -> op . func . string ) ;\n fop -> op . func . replace = ( u_char * ) strdup ( dec_args [ 1 ] ) ;\n fop -> op . func . rlen = strescape ( ( char * ) fop -> op . func . replace , ( char * ) fop -> op . func . replace ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"inject\" ) ) {\n if ( nargs == 1 ) {\n fop -> op . func . op = FFUNC_INJECT ;\n fop -> op . func . level = 5 ;\n fop -> op . func . string = ( u_char * ) strdup ( dec_args [ 0 ] ) ;\n fop -> op . func . slen = strlen ( ( const char * ) fop -> op . func . string ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"execinject\" ) ) {\n if ( nargs == 1 ) {\n fop -> op . func . op = FFUNC_EXECINJECT ;\n fop -> op . func . level = 5 ;\n fop -> op . func . string = ( u_char * ) strdup ( dec_args [ 0 ] ) ;\n fop -> op . func . slen = strlen ( ( const char * ) fop -> op . func . string ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"log\" ) ) {\n if ( nargs == 2 ) {\n if ( encode_offset ( dec_args [ 0 ] , fop ) == E_SUCCESS ) {\n fop -> opcode = FOP_FUNC ;\n fop -> op . func . op = FFUNC_LOG ;\n fop -> op . func . string = ( u_char * ) strdup ( dec_args [ 1 ] ) ;\n fop -> op . func . slen = strlen ( ( const char * ) fop -> op . func . string ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Unknown offset %s \" , dec_args [ 0 ] ) ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"drop\" ) ) {\n if ( nargs == 0 ) {\n fop -> op . func . op = FFUNC_DROP ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"kill\" ) ) {\n if ( nargs == 0 ) {\n fop -> op . func . op = FFUNC_KILL ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"msg\" ) ) {\n if ( nargs == 1 ) {\n fop -> op . func . op = FFUNC_MSG ;\n fop -> op . func . string = ( u_char * ) strdup ( dec_args [ 0 ] ) ;\n fop -> op . func . slen = strescape ( ( char * ) fop -> op . func . string , ( char * ) fop -> op . func . string ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"exec\" ) ) {\n if ( nargs == 1 ) {\n fop -> op . func . op = FFUNC_EXEC ;\n fop -> op . func . string = ( u_char * ) strdup ( dec_args [ 0 ] ) ;\n fop -> op . func . slen = strlen ( ( const char * ) fop -> op . func . string ) ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n else if ( ! strcmp ( name , \"exit\" ) ) {\n if ( nargs == 0 ) {\n fop -> opcode = FOP_EXIT ;\n ret = E_SUCCESS ;\n }\n else SCRIPT_ERROR ( \"Wrong number of arguments for function \\\"%s\\\" \" , name ) ;\n }\n for ( i = 0 ;\n i < nargs ;\n i ++ ) SAFE_FREE ( dec_args [ i ] ) ;\n SAFE_FREE ( dec_args ) ;\n SAFE_FREE ( str ) ;\n return ret ;\n }",
        "hash": 421700949231983751,
        "project": "debian",
        "size": 171,
        "slice": {
            "memset": [
                [
                    1,
                    "int encode_function ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    8,
                    " memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "int encode_function ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    9,
                    " name = ec_strtok ( string , \"(\" , & tok ) ;\n"
                ],
                [
                    10,
                    " args = name + strlen ( name ) + 1 ;\n"
                ],
                [
                    11,
                    " dec_args = decode_args ( args , & nargs ) ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "int encode_function ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    2,
                    " char * str = strdup ( string ) ;\n"
                ],
                [
                    9,
                    " name = ec_strtok ( string , \"(\" , & tok ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int encode_function ( char * string , struct filter_op * fop ) {\n"
                ],
                [
                    2,
                    " char * str = strdup ( string ) ;\n"
                ],
                [
                    8,
                    " memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n"
                ],
                [
                    9,
                    " name = ec_strtok ( string , \"(\" , & tok ) ;\n"
                ],
                [
                    10,
                    " args = name + strlen ( name ) + 1 ;\n"
                ],
                [
                    11,
                    " dec_args = decode_args ( args , & nargs ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * argv [ ] ) {\n libettercap_init ( ) ;\n ef_globals_alloc ( ) ;\n select_text_interface ( ) ;\n libettercap_ui_init ( ) ;\n fprintf ( stdout , \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ;\n EF_GBL -> lineno = 1 ;\n parse_options ( argc , argv ) ;\n if ( EF_GBL_OPTIONS -> source_file ) {\n yyin = fopen ( EF_GBL_OPTIONS -> source_file , \"r\" ) ;\n if ( yyin == NULL ) FATAL_ERROR ( \"Input file not found !\" ) ;\n }\n else {\n FATAL_ERROR ( \"No source file.\" ) ;\n }\n setbuf ( yyin , NULL ) ;\n setbuf ( stdout , NULL ) ;\n setbuf ( stderr , NULL ) ;\n load_tables ( ) ;\n load_constants ( ) ;\n fprintf ( stdout , \"\\n Parsing source file \\'%s\\' \" , EF_GBL_OPTIONS -> source_file ) ;\n fflush ( stdout ) ;\n ef_debug ( 1 , \"\\n\" ) ;\n if ( yyparse ( ) == 0 ) fprintf ( stdout , \" done.\\n\\n\" ) ;\n else fprintf ( stdout , \"\\n\\nThe script contains errors...\\n\\n\" ) ;\n if ( write_output ( ) != E_SUCCESS ) FATAL_ERROR ( \"Cannot write output file (%s)\" , EF_GBL_OPTIONS -> output_file ) ;\n ef_globals_free ( ) ;\n return 0 ;\n }",
        "hash": -7559567117301601597,
        "project": "debian",
        "size": 29,
        "slice": {
            "fprintf": [
                [
                    1,
                    "int main ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    10,
                    " yyin = fopen ( EF_GBL_OPTIONS -> source_file , \"r\" ) ;\n"
                ],
                [
                    17,
                    " setbuf ( stdout , NULL ) ;\n"
                ],
                [
                    21,
                    " fprintf ( stdout , \"\\n Parsing source file \\'%s\\' \" , EF_GBL_OPTIONS -> source_file ) ;\n"
                ],
                [
                    22,
                    " fflush ( stdout ) ;\n"
                ],
                [
                    24,
                    " if ( yyparse ( ) == 0 ) fprintf ( stdout , \" done.\\n\\n\" ) ;\n"
                ],
                [
                    25,
                    " else fprintf ( stdout , \"\\n\\nThe script contains errors...\\n\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    10,
                    " yyin = fopen ( EF_GBL_OPTIONS -> source_file , \"r\" ) ;\n"
                ],
                [
                    17,
                    " setbuf ( stdout , NULL ) ;\n"
                ],
                [
                    21,
                    " fprintf ( stdout , \"\\n Parsing source file \\'%s\\' \" , EF_GBL_OPTIONS -> source_file ) ;\n"
                ],
                [
                    22,
                    " fflush ( stdout ) ;\n"
                ],
                [
                    24,
                    " if ( yyparse ( ) == 0 ) fprintf ( stdout , \" done.\\n\\n\" ) ;\n"
                ],
                [
                    25,
                    " else fprintf ( stdout , \"\\n\\nThe script contains errors...\\n\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int write_output ( void ) {\n int fd ;\n struct filter_op * fop ;\n struct filter_header fh ;\n size_t ninst , i ;\n u_char * data ;\n ninst = compile_tree ( & fop ) ;\n if ( fop == NULL ) return - E_NOTHANDLED ;\n fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;\n ON_ERROR ( fd , - 1 , \"Can't create file %s\" , EF_GBL_OPTIONS -> output_file ) ;\n fprintf ( stdout , \" Writing output to \\'%s\\' \" , EF_GBL_OPTIONS -> output_file ) ;\n fflush ( stdout ) ;\n fh . magic = htons ( EC_FILTER_MAGIC ) ;\n strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;\n fh . data = sizeof ( fh ) ;\n data = create_data_segment ( & fh , fop , ninst ) ;\n write ( fd , & fh , sizeof ( struct filter_header ) ) ;\n write ( fd , data , fh . code - fh . data ) ;\n for ( i = 0 ;\n i <= ninst ;\n i ++ ) {\n print_progress_bar ( & fop [ i ] ) ;\n write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ;\n }\n close ( fd ) ;\n fprintf ( stdout , \" done.\\n\\n\" ) ;\n fprintf ( stdout , \" -> Script encoded into %d instructions.\\n\\n\" , ( int ) ( i - 1 ) ) ;\n return E_SUCCESS ;\n }",
        "hash": 131568608762928706,
        "project": "debian",
        "size": 29,
        "slice": {
            "strncpy": [
                [
                    1,
                    "int write_output ( void ) {\n"
                ],
                [
                    8,
                    " if ( fop == NULL ) return - E_NOTHANDLED ;\n"
                ],
                [
                    14,
                    " strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "int write_output ( void ) {\n"
                ],
                [
                    8,
                    " if ( fop == NULL ) return - E_NOTHANDLED ;\n"
                ],
                [
                    10,
                    " ON_ERROR ( fd , - 1 , \"Can't create file %s\" , EF_GBL_OPTIONS -> output_file ) ;\n"
                ],
                [
                    11,
                    " fprintf ( stdout , \" Writing output to \\'%s\\' \" , EF_GBL_OPTIONS -> output_file ) ;\n"
                ],
                [
                    12,
                    " fflush ( stdout ) ;\n"
                ],
                [
                    26,
                    " fprintf ( stdout , \" done.\\n\\n\" ) ;\n"
                ],
                [
                    27,
                    " fprintf ( stdout , \" -> Script encoded into %d instructions.\\n\\n\" , ( int ) ( i - 1 ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int write_output ( void ) {\n"
                ],
                [
                    8,
                    " if ( fop == NULL ) return - E_NOTHANDLED ;\n"
                ],
                [
                    10,
                    " ON_ERROR ( fd , - 1 , \"Can't create file %s\" , EF_GBL_OPTIONS -> output_file ) ;\n"
                ],
                [
                    11,
                    " fprintf ( stdout , \" Writing output to \\'%s\\' \" , EF_GBL_OPTIONS -> output_file ) ;\n"
                ],
                [
                    12,
                    " fflush ( stdout ) ;\n"
                ],
                [
                    14,
                    " strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;\n"
                ],
                [
                    26,
                    " fprintf ( stdout , \" done.\\n\\n\" ) ;\n"
                ],
                [
                    27,
                    " fprintf ( stdout , \" -> Script encoded into %d instructions.\\n\\n\" , ( int ) ( i - 1 ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "size_t compile_tree ( struct filter_op * * fop ) {\n int i = 1 ;\n struct filter_op * array = NULL ;\n struct unfold_elm * ue ;\n BUG_IF ( tree_root == NULL ) ;\n fprintf ( stdout , \" Unfolding the meta-tree \" ) ;\n fflush ( stdout ) ;\n unfold_blk ( & tree_root ) ;\n fprintf ( stdout , \" done.\\n\\n\" ) ;\n labels_to_offsets ( ) ;\n TAILQ_FOREACH ( ue , & unfolded_tree , next ) {\n if ( ue -> label == 0 ) {\n SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ;\n i ++ ;\n }\n }\n SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n array [ i - 1 ] . opcode = FOP_EXIT ;\n * fop = array ;\n return ( i ) ;\n }",
        "hash": -6351630154286607278,
        "project": "debian",
        "size": 22,
        "slice": {
            "memcpy": [
                [
                    1,
                    "size_t compile_tree ( struct filter_op * * fop ) {\n"
                ],
                [
                    11,
                    " TAILQ_FOREACH ( ue , & unfolded_tree , next ) {\n"
                ],
                [
                    12,
                    " if ( ue -> label == 0 ) {\n"
                ],
                [
                    13,
                    " SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n"
                ],
                [
                    14,
                    " memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "size_t compile_tree ( struct filter_op * * fop ) {\n"
                ],
                [
                    6,
                    " fprintf ( stdout , \" Unfolding the meta-tree \" ) ;\n"
                ],
                [
                    7,
                    " fflush ( stdout ) ;\n"
                ],
                [
                    9,
                    " fprintf ( stdout , \" done.\\n\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "size_t compile_tree ( struct filter_op * * fop ) {\n"
                ],
                [
                    6,
                    " fprintf ( stdout , \" Unfolding the meta-tree \" ) ;\n"
                ],
                [
                    7,
                    " fflush ( stdout ) ;\n"
                ],
                [
                    9,
                    " fprintf ( stdout , \" done.\\n\\n\" ) ;\n"
                ],
                [
                    11,
                    " TAILQ_FOREACH ( ue , & unfolded_tree , next ) {\n"
                ],
                [
                    12,
                    " if ( ue -> label == 0 ) {\n"
                ],
                [
                    13,
                    " SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n"
                ],
                [
                    14,
                    " memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int petite_inflate2x_1to9 ( char * buf , uint32_t minrva , uint32_t bufsz , struct cli_exe_section * sections , unsigned int sectcount , uint32_t Imagebase , uint32_t pep , int desc , int version , uint32_t ResRva , uint32_t ResSize ) {\n char * adjbuf = buf - minrva ;\n char * packed = NULL ;\n uint32_t thisrva = 0 , bottom = 0 , enc_ep = 0 , irva = 0 , workdone = 0 , grown = 0x355 , skew = 0x35 ;\n int j = 0 , oob , mangled = 0 , check4resources = 0 ;\n struct cli_exe_section * usects = NULL ;\n void * tmpsct = NULL ;\n if ( version == 2 ) packed = adjbuf + sections [ sectcount - 1 ] . rva + 0x1b8 ;\n if ( version == 1 ) {\n packed = adjbuf + sections [ sectcount - 1 ] . rva + 0x178 ;\n grown = 0x323 ;\n skew = 0x34 ;\n }\n while ( 1 ) {\n char * ssrc , * ddst ;\n uint32_t size , srva ;\n int backbytes , oldback , backsize , addsize ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , packed , 4 ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n srva = cli_readint32 ( packed ) ;\n if ( ! srva ) {\n int t , upd = 1 ;\n if ( j <= 0 ) return 1 ;\n while ( upd ) {\n upd = 0 ;\n for ( t = 0 ;\n t < j - 1 ;\n t ++ ) {\n uint32_t trva , trsz , tvsz ;\n if ( usects [ t ] . rva <= usects [ t + 1 ] . rva ) continue ;\n trva = usects [ t ] . rva ;\n trsz = usects [ t ] . rsz ;\n tvsz = usects [ t ] . vsz ;\n usects [ t ] . rva = usects [ t + 1 ] . rva ;\n usects [ t ] . rsz = usects [ t + 1 ] . rsz ;\n usects [ t ] . vsz = usects [ t + 1 ] . vsz ;\n usects [ t + 1 ] . rva = trva ;\n usects [ t + 1 ] . rsz = trsz ;\n usects [ t + 1 ] . vsz = tvsz ;\n upd = 1 ;\n }\n }\n for ( t = 0 ;\n t < j - 1 ;\n t ++ ) {\n if ( usects [ t ] . vsz != usects [ t + 1 ] . rva - usects [ t ] . rva ) usects [ t ] . vsz = usects [ t + 1 ] . rva - usects [ t ] . rva ;\n }\n if ( enc_ep ) {\n uint32_t virtaddr = pep + 5 + Imagebase , tmpep ;\n int rndm = 0 , dummy = 1 ;\n char * thunk = adjbuf + irva ;\n char * imports ;\n if ( version == 2 ) {\n while ( dummy && CLI_ISCONTAINED ( buf , bufsz , thunk , 4 ) ) {\n uint32_t api ;\n if ( ! cli_readint32 ( thunk ) ) {\n workdone = 1 ;\n break ;\n }\n imports = adjbuf + cli_readint32 ( thunk ) ;\n thunk += 4 ;\n dummy = 0 ;\n while ( CLI_ISCONTAINED ( buf , bufsz , imports , 4 ) ) {\n dummy = 0 ;\n imports += 4 ;\n if ( ! ( api = cli_readint32 ( imports - 4 ) ) ) {\n dummy = 1 ;\n break ;\n }\n if ( ( api != ( api | 0x80000000 ) ) && mangled && -- rndm < 0 ) {\n api = virtaddr ;\n virtaddr += 5 ;\n rndm = virtaddr & 7 ;\n }\n else {\n api = 0xbff01337 ;\n }\n if ( sections [ sectcount - 1 ] . rva + Imagebase < api ) enc_ep -- ;\n if ( api < virtaddr ) enc_ep -- ;\n tmpep = ( enc_ep & 0xfffffff8 ) >> 3 & 0x1fffffff ;\n enc_ep = ( enc_ep & 7 ) << 29 | tmpep ;\n }\n }\n }\n else workdone = 1 ;\n enc_ep = pep + 5 + enc_ep ;\n if ( workdone == 1 ) {\n cli_dbgmsg ( \"Petite: Old EP: %x\\n\" , enc_ep ) ;\n }\n else {\n enc_ep = usects [ 0 ] . rva ;\n cli_dbgmsg ( \"Petite: In troubles while attempting to decrypt old EP, using bogus %x\\n\" , enc_ep ) ;\n }\n }\n for ( t = 0 ;\n t < j ;\n t ++ ) {\n usects [ t ] . raw = ( t > 0 ) ? ( usects [ t - 1 ] . raw + usects [ t - 1 ] . rsz ) : 0 ;\n if ( usects [ t ] . rsz != 0 ) {\n if ( CLI_ISCONTAINED ( buf , bufsz , buf + usects [ t ] . raw , usects [ t ] . rsz ) ) {\n memmove ( buf + usects [ t ] . raw , adjbuf + usects [ t ] . rva , usects [ t ] . rsz ) ;\n }\n else {\n cli_dbgmsg ( \"Petite: Skipping section %d, Raw: %x, RSize:%x\\n\" , t , usects [ t ] . raw , usects [ t ] . rsz ) ;\n usects [ t ] . raw = t > 0 ? usects [ t - 1 ] . raw : 0 ;\n usects [ t ] . rsz = 0 ;\n }\n }\n }\n cli_dbgmsg ( \"Petite: Sections dump:\\n\" ) ;\n for ( t = 0 ;\n t < j ;\n t ++ ) cli_dbgmsg ( \"Petite: .SECT%d RVA:%x VSize:%x ROffset: %x, RSize:%x\\n\" , t , usects [ t ] . rva , usects [ t ] . vsz , usects [ t ] . raw , usects [ t ] . rsz ) ;\n if ( ! cli_rebuildpe ( buf , usects , j , Imagebase , enc_ep , ResRva , ResSize , desc ) ) {\n cli_dbgmsg ( \"Petite: Rebuilding failed\\n\" ) ;\n free ( usects ) ;\n return 1 ;\n }\n free ( usects ) ;\n return 0 ;\n }\n size = srva & 0x7fffffff ;\n if ( srva != size ) {\n check4resources = 0 ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , packed + 4 , 8 ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n bottom = cli_readint32 ( packed + 8 ) + 4 ;\n ssrc = adjbuf + cli_readint32 ( packed + 4 ) - ( size - 1 ) * 4 ;\n ddst = adjbuf + cli_readint32 ( packed + 8 ) - ( size - 1 ) * 4 ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , size * 4 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , size * 4 ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n memmove ( ddst , ssrc , size * 4 ) ;\n packed += 0x0c ;\n }\n else {\n uint32_t check1 , check2 ;\n uint8_t mydl = 0 ;\n uint8_t goback ;\n unsigned int q ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , packed + 4 , 8 ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n size = cli_readint32 ( packed + 4 ) ;\n thisrva = cli_readint32 ( packed + 8 ) ;\n packed += 0x10 ;\n if ( j >= 96 ) {\n cli_dbgmsg ( \"Petite: maximum number of sections exceeded, giving up.\\n\" ) ;\n free ( usects ) ;\n return 1 ;\n }\n if ( ! ( tmpsct = cli_realloc ( usects , sizeof ( struct cli_exe_section ) * ( j + 1 ) ) ) ) {\n if ( usects ) free ( usects ) ;\n return 1 ;\n }\n usects = ( struct cli_exe_section * ) tmpsct ;\n usects [ j ] . rva = thisrva ;\n usects [ j ] . rsz = size ;\n if ( ( int ) ( bottom - thisrva ) > 0 ) usects [ j ] . vsz = bottom - thisrva ;\n else usects [ j ] . vsz = size ;\n usects [ j ] . raw = 0 ;\n if ( ! size ) {\n j ++ ;\n continue ;\n }\n ssrc = adjbuf + srva ;\n ddst = adjbuf + thisrva ;\n for ( q = 0 ;\n q < sectcount ;\n q ++ ) {\n if ( ! CLI_ISCONTAINED ( sections [ q ] . rva , sections [ q ] . vsz , usects [ j ] . rva , usects [ j ] . vsz ) ) continue ;\n if ( ! check4resources ) {\n usects [ j ] . rva = sections [ q ] . rva ;\n usects [ j ] . rsz = thisrva - sections [ q ] . rva + size ;\n }\n break ;\n }\n if ( q == sectcount ) {\n free ( usects ) ;\n return 1 ;\n }\n j ++ ;\n if ( size < 0x10000 ) {\n check1 = 0x0FFFFC060 ;\n check2 = 0x0FFFFFC60 ;\n goback = 5 ;\n }\n else if ( size < 0x40000 ) {\n check1 = 0x0FFFF8180 ;\n check2 = 0x0FFFFF980 ;\n goback = 7 ;\n }\n else {\n check1 = 0x0FFFF8300 ;\n check2 = 0x0FFFFFB00 ;\n goback = 8 ;\n }\n if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n free ( usects ) ;\n return 1 ;\n }\n size -- ;\n * ddst ++ = * ssrc ++ ;\n backbytes = 0 ;\n oldback = 0 ;\n while ( size > 0 ) {\n oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ;\n if ( oob == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n if ( ! oob ) {\n if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n free ( usects ) ;\n return 1 ;\n }\n * ddst ++ = ( char ) ( ( * ssrc ++ ) ^ ( size & 0xff ) ) ;\n size -- ;\n }\n else {\n addsize = 0 ;\n backbytes ++ ;\n while ( 1 ) {\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backbytes = backbytes * 2 + oob ;\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n if ( ! oob ) break ;\n }\n backbytes -= 3 ;\n if ( backbytes >= 0 ) {\n backsize = goback ;\n do {\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backbytes = backbytes * 2 + oob ;\n backsize -- ;\n }\n while ( backsize ) ;\n backbytes ^= 0xffffffff ;\n addsize += 1 + ( backbytes < ( int ) check2 ) + ( backbytes < ( int ) check1 ) ;\n oldback = backbytes ;\n }\n else {\n backsize = backbytes + 1 ;\n backbytes = oldback ;\n }\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backsize = backsize * 2 + oob ;\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backsize = backsize * 2 + oob ;\n if ( ! backsize ) {\n backsize ++ ;\n while ( 1 ) {\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n backsize = backsize * 2 + oob ;\n if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n free ( usects ) ;\n return 1 ;\n }\n if ( ! oob ) break ;\n }\n backsize += 2 ;\n }\n backsize += addsize ;\n size -= backsize ;\n if ( ! CLI_ISCONTAINED ( buf , bufsz , ddst , backsize ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst + backbytes , backsize ) ) {\n free ( usects ) ;\n return 1 ;\n }\n while ( backsize -- ) {\n * ddst = * ( ddst + backbytes ) ;\n ddst ++ ;\n }\n backbytes = 0 ;\n backsize = 0 ;\n }\n }\n if ( j ) {\n int strippetite = 0 ;\n uint32_t reloc ;\n if ( usects [ j - 1 ] . rsz > grown && CLI_ISCONTAINED ( buf , bufsz , ddst - grown + 5 + 0x4f , 8 ) && cli_readint32 ( ddst - grown + 5 + 0x4f ) == 0x645ec033 && cli_readint32 ( ddst - grown + 5 + 0x4f + 4 ) == 0x1b8b188b ) {\n reloc = 0 ;\n strippetite = 1 ;\n }\n if ( ! strippetite && usects [ j - 1 ] . rsz > grown + skew && CLI_ISCONTAINED ( buf , bufsz , ddst - grown + 5 + 0x4f - skew , 8 ) && cli_readint32 ( ddst - grown + 5 + 0x4f - skew ) == 0x645ec033 && cli_readint32 ( ddst - grown + 5 + 0x4f + 4 - skew ) == 0x1b8b188b ) {\n reloc = skew ;\n strippetite = 1 ;\n }\n if ( strippetite && CLI_ISCONTAINED ( buf , bufsz , ddst - grown + 0x0f - 8 - reloc , 8 ) ) {\n uint32_t test1 , test2 ;\n test1 = cli_readint32 ( ddst - grown + 0x0f - 8 - reloc ) ^ 0x9d6661aa ;\n test2 = cli_readint32 ( ddst - grown + 0x0f - 4 - reloc ) ^ 0xe908c483 ;\n cli_dbgmsg ( \"Petite: Found petite code in sect%d(%x). Let's strip it.\\n\" , j - 1 , usects [ j - 1 ] . rva ) ;\n if ( test1 == test2 && CLI_ISCONTAINED ( buf , bufsz , ddst - grown + 0x0f - reloc , 0x1c0 - 0x0f + 4 ) ) {\n irva = cli_readint32 ( ddst - grown + 0x121 - reloc ) ;\n enc_ep = cli_readint32 ( ddst - grown + 0x0f - reloc ) ^ test1 ;\n mangled = ( ( uint32_t ) cli_readint32 ( ddst - grown + 0x1c0 - reloc ) != 0x90909090 ) ;\n cli_dbgmsg ( \"Petite: Encrypted EP: %x | Array of imports: %x\\n\" , enc_ep , irva ) ;\n }\n usects [ j - 1 ] . rsz -= grown + reloc ;\n }\n }\n check4resources ++ ;\n }\n }\n }",
        "hash": 8425497811998776592,
        "project": "debian",
        "size": 329,
        "slice": {
            "memmove": [
                [
                    1,
                    "int petite_inflate2x_1to9 ( char * buf , uint32_t minrva , uint32_t bufsz , struct cli_exe_section * sections , unsigned int sectcount , uint32_t Imagebase , uint32_t pep , int desc , int version , uint32_t ResRva , uint32_t ResSize ) {\n"
                ],
                [
                    2,
                    " char * adjbuf = buf - minrva ;\n"
                ],
                [
                    100,
                    " usects [ t ] . raw = ( t > 0 ) ? ( usects [ t - 1 ] . raw + usects [ t - 1 ] . rsz ) : 0 ;\n"
                ],
                [
                    102,
                    " if ( CLI_ISCONTAINED ( buf , bufsz , buf + usects [ t ] . raw , usects [ t ] . rsz ) ) {\n"
                ],
                [
                    103,
                    " memmove ( buf + usects [ t ] . raw , adjbuf + usects [ t ] . rva , usects [ t ] . rsz ) ;\n"
                ],
                [
                    133,
                    " ddst = adjbuf + cli_readint32 ( packed + 8 ) - ( size - 1 ) * 4 ;\n"
                ],
                [
                    134,
                    " if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , size * 4 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , size * 4 ) ) {\n"
                ],
                [
                    138,
                    " memmove ( ddst , ssrc , size * 4 ) ;\n"
                ],
                [
                    213,
                    " oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ;\n"
                ],
                [
                    266,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    279,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    294,
                    " * ddst = * ( ddst + backbytes ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "int petite_inflate2x_1to9 ( char * buf , uint32_t minrva , uint32_t bufsz , struct cli_exe_section * sections , unsigned int sectcount , uint32_t Imagebase , uint32_t pep , int desc , int version , uint32_t ResRva , uint32_t ResSize ) {\n"
                ],
                [
                    6,
                    " struct cli_exe_section * usects = NULL ;\n"
                ],
                [
                    19,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    116,
                    " if ( ! cli_rebuildpe ( buf , usects , j , Imagebase , enc_ep , ResRva , ResSize , desc ) ) {\n"
                ],
                [
                    118,
                    " free ( usects ) ;\n"
                ],
                [
                    121,
                    " free ( usects ) ;\n"
                ],
                [
                    128,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    135,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    147,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    153,
                    " if ( j >= 96 ) {\n"
                ],
                [
                    155,
                    " free ( usects ) ;\n"
                ],
                [
                    158,
                    " if ( ! ( tmpsct = cli_realloc ( usects , sizeof ( struct cli_exe_section ) * ( j + 1 ) ) ) ) {\n"
                ],
                [
                    159,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    162,
                    " usects = ( struct cli_exe_section * ) tmpsct ;\n"
                ],
                [
                    184,
                    " if ( q == sectcount ) {\n"
                ],
                [
                    185,
                    " free ( usects ) ;\n"
                ],
                [
                    204,
                    " if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n"
                ],
                [
                    205,
                    " free ( usects ) ;\n"
                ],
                [
                    214,
                    " if ( oob == - 1 ) {\n"
                ],
                [
                    215,
                    " free ( usects ) ;\n"
                ],
                [
                    219,
                    " if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n"
                ],
                [
                    220,
                    " free ( usects ) ;\n"
                ],
                [
                    230,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    231,
                    " free ( usects ) ;\n"
                ],
                [
                    235,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    236,
                    " free ( usects ) ;\n"
                ],
                [
                    245,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    246,
                    " free ( usects ) ;\n"
                ],
                [
                    261,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    262,
                    " free ( usects ) ;\n"
                ],
                [
                    266,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    267,
                    " free ( usects ) ;\n"
                ],
                [
                    274,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    275,
                    " free ( usects ) ;\n"
                ],
                [
                    279,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    280,
                    " free ( usects ) ;\n"
                ],
                [
                    289,
                    " if ( ! CLI_ISCONTAINED ( buf , bufsz , ddst , backsize ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst + backbytes , backsize ) ) {\n"
                ],
                [
                    290,
                    " free ( usects ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int petite_inflate2x_1to9 ( char * buf , uint32_t minrva , uint32_t bufsz , struct cli_exe_section * sections , unsigned int sectcount , uint32_t Imagebase , uint32_t pep , int desc , int version , uint32_t ResRva , uint32_t ResSize ) {\n"
                ],
                [
                    2,
                    " char * adjbuf = buf - minrva ;\n"
                ],
                [
                    6,
                    " struct cli_exe_section * usects = NULL ;\n"
                ],
                [
                    19,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    100,
                    " usects [ t ] . raw = ( t > 0 ) ? ( usects [ t - 1 ] . raw + usects [ t - 1 ] . rsz ) : 0 ;\n"
                ],
                [
                    102,
                    " if ( CLI_ISCONTAINED ( buf , bufsz , buf + usects [ t ] . raw , usects [ t ] . rsz ) ) {\n"
                ],
                [
                    103,
                    " memmove ( buf + usects [ t ] . raw , adjbuf + usects [ t ] . rva , usects [ t ] . rsz ) ;\n"
                ],
                [
                    116,
                    " if ( ! cli_rebuildpe ( buf , usects , j , Imagebase , enc_ep , ResRva , ResSize , desc ) ) {\n"
                ],
                [
                    118,
                    " free ( usects ) ;\n"
                ],
                [
                    121,
                    " free ( usects ) ;\n"
                ],
                [
                    128,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    133,
                    " ddst = adjbuf + cli_readint32 ( packed + 8 ) - ( size - 1 ) * 4 ;\n"
                ],
                [
                    134,
                    " if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , size * 4 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , size * 4 ) ) {\n"
                ],
                [
                    135,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    138,
                    " memmove ( ddst , ssrc , size * 4 ) ;\n"
                ],
                [
                    147,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    153,
                    " if ( j >= 96 ) {\n"
                ],
                [
                    155,
                    " free ( usects ) ;\n"
                ],
                [
                    158,
                    " if ( ! ( tmpsct = cli_realloc ( usects , sizeof ( struct cli_exe_section ) * ( j + 1 ) ) ) ) {\n"
                ],
                [
                    159,
                    " if ( usects ) free ( usects ) ;\n"
                ],
                [
                    162,
                    " usects = ( struct cli_exe_section * ) tmpsct ;\n"
                ],
                [
                    184,
                    " if ( q == sectcount ) {\n"
                ],
                [
                    185,
                    " free ( usects ) ;\n"
                ],
                [
                    204,
                    " if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n"
                ],
                [
                    205,
                    " free ( usects ) ;\n"
                ],
                [
                    213,
                    " oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ;\n"
                ],
                [
                    214,
                    " if ( oob == - 1 ) {\n"
                ],
                [
                    215,
                    " free ( usects ) ;\n"
                ],
                [
                    219,
                    " if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n"
                ],
                [
                    220,
                    " free ( usects ) ;\n"
                ],
                [
                    230,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    231,
                    " free ( usects ) ;\n"
                ],
                [
                    235,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    236,
                    " free ( usects ) ;\n"
                ],
                [
                    245,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    246,
                    " free ( usects ) ;\n"
                ],
                [
                    261,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    262,
                    " free ( usects ) ;\n"
                ],
                [
                    266,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    267,
                    " free ( usects ) ;\n"
                ],
                [
                    274,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    275,
                    " free ( usects ) ;\n"
                ],
                [
                    279,
                    " if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n"
                ],
                [
                    280,
                    " free ( usects ) ;\n"
                ],
                [
                    289,
                    " if ( ! CLI_ISCONTAINED ( buf , bufsz , ddst , backsize ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst + backbytes , backsize ) ) {\n"
                ],
                [
                    290,
                    " free ( usects ) ;\n"
                ],
                [
                    294,
                    " * ddst = * ( ddst + backbytes ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void test_rfc2231_parser ( void ) {\n const char * input = \";\n key4*=us-ascii''foo\" \";\n key*2=ba%\" \";\n key2*0=a\" \";\n key3*0*=us-ascii'en'xyz\" \";\n key*0=\\\"foo\\\"\" \";\n key2*1*=b%25\" \";\n key3*1=plop%\" \";\n key*1=baz\" ;\n const char * output [ ] = {\n \"key\" , \"foobazba%\" , \"key2*\" , \"''ab%25\" , \"key3*\" , \"us-ascii'en'xyzplop%25\" , \"key4*\" , \"us-ascii''foo\" , NULL }\n ;\n struct rfc822_parser_context parser ;\n const char * const * result ;\n unsigned int i ;\n test_begin ( \"rfc2231 parser\" ) ;\n rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;\n test_assert ( rfc2231_parse ( & parser , & result ) == 0 ) ;\n for ( i = 0 ;\n output [ i ] != NULL && result [ i ] != NULL ;\n i ++ ) test_assert ( strcmp ( output [ i ] , result [ i ] ) == 0 ) ;\n test_assert ( output [ i ] == NULL && result [ i ] == NULL ) ;\n test_end ( ) ;\n }",
        "hash": -2420110701634682108,
        "project": "debian",
        "size": 25,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static void test_rfc2231_parser ( void ) {\n"
                ],
                [
                    21,
                    " output [ i ] != NULL && result [ i ] != NULL ;\n"
                ],
                [
                    22,
                    " i ++ ) test_assert ( strcmp ( output [ i ] , result [ i ] ) == 0 ) ;\n"
                ],
                [
                    23,
                    " test_assert ( output [ i ] == NULL && result [ i ] == NULL ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static void test_rfc2231_parser ( void ) {\n"
                ],
                [
                    2,
                    " const char * input = \";\n"
                ],
                [
                    18,
                    " rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void test_rfc2231_parser ( void ) {\n"
                ],
                [
                    2,
                    " const char * input = \";\n"
                ],
                [
                    18,
                    " rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;\n"
                ],
                [
                    21,
                    " output [ i ] != NULL && result [ i ] != NULL ;\n"
                ],
                [
                    22,
                    " i ++ ) test_assert ( strcmp ( output [ i ] , result [ i ] ) == 0 ) ;\n"
                ],
                [
                    23,
                    " test_assert ( output [ i ] == NULL && result [ i ] == NULL ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void test_rfc822_parse_quoted_string ( void ) {\n const struct {\n const char * input , * output ;\n int ret ;\n }\n tests [ ] = {\n {\n \"\\\"\" , \"\" , - 1 }\n , {\n \"\\\"\\\"\" , \"\" , 0 }\n , {\n \"\\\"foo\\\"\" , \"foo\" , 0 }\n , {\n \"\\\"\\\"foo\" , \"\" , 1 }\n , {\n \"\\\"\\\"\\\"\" , \"\" , 1 }\n , {\n \"\\\"\\\\\\\"\\\"\" , \"\\\"\" , 0 }\n , {\n \"\\\"\\\\\\\\\\\"\" , \"\\\\\" , 0 }\n , {\n \"\\\"\\\\\\\\foo\\\\\\\\foo\\\\\\\\\\\"\" , \"\\\\foo\\\\foo\\\\\" , 0 }\n }\n ;\n struct rfc822_parser_context parser ;\n string_t * str = t_str_new ( 64 ) ;\n unsigned int i = 0 ;\n test_begin ( \"rfc822 parse quoted string\" ) ;\n for ( i = 0 ;\n i < N_ELEMENTS ( tests ) ;\n i ++ ) {\n rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;\n test_assert_idx ( rfc822_parse_quoted_string ( & parser , str ) == tests [ i ] . ret , i ) ;\n test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;\n str_truncate ( str , 0 ) ;\n }\n test_end ( ) ;\n }",
        "hash": -3044261571134154368,
        "project": "debian",
        "size": 38,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static void test_rfc822_parse_quoted_string ( void ) {\n"
                ],
                [
                    30,
                    " i < N_ELEMENTS ( tests ) ;\n"
                ],
                [
                    34,
                    " test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;\n"
                ]
            ],
            "strlen": [
                [
                    30,
                    " i < N_ELEMENTS ( tests ) ;\n"
                ],
                [
                    32,
                    " rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void test_rfc822_parse_quoted_string ( void ) {\n"
                ],
                [
                    30,
                    " i < N_ELEMENTS ( tests ) ;\n"
                ],
                [
                    32,
                    " rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;\n"
                ],
                [
                    34,
                    " test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void parse_content_disposition ( const char * content_disposition , const char * * filename_r ) {\n struct rfc822_parser_context parser ;\n const char * const * results , * filename2 ;\n string_t * str ;\n * filename_r = NULL ;\n if ( content_disposition == NULL ) return ;\n rfc822_parser_init ( & parser , ( const unsigned char * ) content_disposition , strlen ( content_disposition ) , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n str = t_str_new ( 32 ) ;\n if ( rfc822_parse_mime_token ( & parser , str ) < 0 ) return ;\n rfc2231_parse ( & parser , & results ) ;\n filename2 = NULL ;\n for ( ;\n * results != NULL ;\n results += 2 ) {\n if ( strcasecmp ( results [ 0 ] , \"filename\" ) == 0 ) {\n * filename_r = results [ 1 ] ;\n break ;\n }\n if ( strcasecmp ( results [ 0 ] , \"filename*\" ) == 0 ) filename2 = results [ 1 ] ;\n }\n if ( * filename_r == NULL ) {\n * filename_r = filename2 ;\n }\n }",
        "hash": -6228844445714759206,
        "project": "debian",
        "size": 25,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void parse_content_disposition ( const char * content_disposition , const char * * filename_r ) {\n"
                ],
                [
                    6,
                    " if ( content_disposition == NULL ) return ;\n"
                ],
                [
                    7,
                    " rfc822_parser_init ( & parser , ( const unsigned char * ) content_disposition , strlen ( content_disposition ) , NULL ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void parse_content_disposition ( const char * content_disposition , const char * * filename_r ) {\n"
                ],
                [
                    6,
                    " if ( content_disposition == NULL ) return ;\n"
                ],
                [
                    7,
                    " rfc822_parser_init ( & parser , ( const unsigned char * ) content_disposition , strlen ( content_disposition ) , NULL ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void * xmalloc ( size_t size ) {\n void * ptr = malloc ( size ) ;\n if ( ! ptr && ( size != 0 ) ) {\n perror ( \"xmalloc: Memory allocation failure\" ) ;\n abort ( ) ;\n }\n return ptr ;\n }",
        "hash": -6579823731174944595,
        "project": "debian",
        "size": 8,
        "slice": {
            "malloc": [
                [
                    1,
                    "void * xmalloc ( size_t size ) {\n"
                ],
                [
                    2,
                    " void * ptr = malloc ( size ) ;\n"
                ],
                [
                    3,
                    " if ( ! ptr && ( size != 0 ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void * xmalloc ( size_t size ) {\n"
                ],
                [
                    2,
                    " void * ptr = malloc ( size ) ;\n"
                ],
                [
                    3,
                    " if ( ! ptr && ( size != 0 ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "void * xcalloc ( size_t num , size_t size ) {\n void * ptr = malloc ( num * size ) ;\n if ( ptr ) {\n memset ( ptr , '\\0' , ( num * size ) ) ;\n }\n return ptr ;\n }",
        "hash": -6579823731174944595,
        "project": "debian",
        "size": 7,
        "slice": {
            "memset": [
                [
                    1,
                    "void * xcalloc ( size_t num , size_t size ) {\n"
                ],
                [
                    2,
                    " void * ptr = malloc ( num * size ) ;\n"
                ],
                [
                    3,
                    " if ( ptr ) {\n"
                ],
                [
                    4,
                    " memset ( ptr , '\\0' , ( num * size ) ) ;\n"
                ],
                [
                    6,
                    " return ptr ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "void * xcalloc ( size_t num , size_t size ) {\n"
                ],
                [
                    2,
                    " void * ptr = malloc ( num * size ) ;\n"
                ],
                [
                    4,
                    " memset ( ptr , '\\0' , ( num * size ) ) ;\n"
                ],
                [
                    6,
                    " return ptr ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void * xcalloc ( size_t num , size_t size ) {\n"
                ],
                [
                    2,
                    " void * ptr = malloc ( num * size ) ;\n"
                ],
                [
                    3,
                    " if ( ptr ) {\n"
                ],
                [
                    4,
                    " memset ( ptr , '\\0' , ( num * size ) ) ;\n"
                ],
                [
                    6,
                    " return ptr ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int slirp_smb ( SlirpState * s , const char * exported_dir , struct in_addr vserver_addr ) {\n static int instance ;\n char smb_conf [ 128 ] ;\n char smb_cmdline [ 128 ] ;\n struct passwd * passwd ;\n FILE * f ;\n passwd = getpwuid ( geteuid ( ) ) ;\n if ( ! passwd ) {\n error_report ( \"failed to retrieve user name\" ) ;\n return - 1 ;\n }\n if ( access ( CONFIG_SMBD_COMMAND , F_OK ) ) {\n error_report ( \"could not find '%s', please install it\" , CONFIG_SMBD_COMMAND ) ;\n return - 1 ;\n }\n if ( access ( exported_dir , R_OK | X_OK ) ) {\n error_report ( \"error accessing shared directory '%s': %s\" , exported_dir , strerror ( errno ) ) ;\n return - 1 ;\n }\n snprintf ( s -> smb_dir , sizeof ( s -> smb_dir ) , \"/tmp/qemu-smb.%ld-%d\" , ( long ) getpid ( ) , instance ++ ) ;\n if ( mkdir ( s -> smb_dir , 0700 ) < 0 ) {\n error_report ( \"could not create samba server dir '%s'\" , s -> smb_dir ) ;\n return - 1 ;\n }\n snprintf ( smb_conf , sizeof ( smb_conf ) , \"%s/%s\" , s -> smb_dir , \"smb.conf\" ) ;\n f = fopen ( smb_conf , \"w\" ) ;\n if ( ! f ) {\n slirp_smb_cleanup ( s ) ;\n error_report ( \"could not create samba server configuration file '%s'\" , smb_conf ) ;\n return - 1 ;\n }\n fprintf ( f , \"[global]\\n\" \"private dir=%s\\n\" \"interfaces=127.0.0.1\\n\" \"bind interfaces only=yes\\n\" \"pid directory=%s\\n\" \"lock directory=%s\\n\" \"state directory=%s\\n\" \"cache directory=%s\\n\" \"ncalrpc dir=%scalrpc\\n\" \"log file=%s/log.smbd\\n\" \"smb passwd file=%s/smbpasswd\\n\" \"security = user\\n\" \"map to guest = Bad User\\n\" \"load printers = no\\n\" \"printing = bsd\\n\" \"disable spoolss = yes\\n\" \"usershare max shares = 0\\n\" \"[qemu]\\n\" \"path=%s\\n\" \"read only=no\\n\" \"guest ok=yes\\n\" \"force user=%s\\n\" , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , exported_dir , passwd -> pw_name ) ;\n fclose ( f ) ;\n snprintf ( smb_cmdline , sizeof ( smb_cmdline ) , \"%s -l %s -s %s\" , CONFIG_SMBD_COMMAND , s -> smb_dir , smb_conf ) ;\n if ( slirp_add_exec ( s -> slirp , 0 , smb_cmdline , & vserver_addr , 139 ) < 0 || slirp_add_exec ( s -> slirp , 0 , smb_cmdline , & vserver_addr , 445 ) < 0 ) {\n slirp_smb_cleanup ( s ) ;\n error_report ( \"conflicting/invalid smbserver address\" ) ;\n return - 1 ;\n }\n return 0 ;\n }",
        "hash": 583170025160259883,
        "project": "debian",
        "size": 41,
        "slice": {
            "strerror": [
                [
                    1,
                    "static int slirp_smb ( SlirpState * s , const char * exported_dir , struct in_addr vserver_addr ) {\n"
                ],
                [
                    16,
                    " if ( access ( exported_dir , R_OK | X_OK ) ) {\n"
                ],
                [
                    17,
                    " error_report ( \"error accessing shared directory '%s': %s\" , exported_dir , strerror ( errno ) ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static int slirp_smb ( SlirpState * s , const char * exported_dir , struct in_addr vserver_addr ) {\n"
                ],
                [
                    8,
                    " if ( ! passwd ) {\n"
                ],
                [
                    16,
                    " if ( access ( exported_dir , R_OK | X_OK ) ) {\n"
                ],
                [
                    25,
                    " snprintf ( smb_conf , sizeof ( smb_conf ) , \"%s/%s\" , s -> smb_dir , \"smb.conf\" ) ;\n"
                ],
                [
                    27,
                    " if ( ! f ) {\n"
                ],
                [
                    32,
                    " fprintf ( f , \"[global]\\n\" \"private dir=%s\\n\" \"interfaces=127.0.0.1\\n\" \"bind interfaces only=yes\\n\" \"pid directory=%s\\n\" \"lock directory=%s\\n\" \"state directory=%s\\n\" \"cache directory=%s\\n\" \"ncalrpc dir=%scalrpc\\n\" \"log file=%s/log.smbd\\n\" \"smb passwd file=%s/smbpasswd\\n\" \"security = user\\n\" \"map to guest = Bad User\\n\" \"load printers = no\\n\" \"printing = bsd\\n\" \"disable spoolss = yes\\n\" \"usershare max shares = 0\\n\" \"[qemu]\\n\" \"path=%s\\n\" \"read only=no\\n\" \"guest ok=yes\\n\" \"force user=%s\\n\" , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , exported_dir , passwd -> pw_name ) ;\n"
                ],
                [
                    33,
                    " fclose ( f ) ;\n"
                ],
                [
                    34,
                    " snprintf ( smb_cmdline , sizeof ( smb_cmdline ) , \"%s -l %s -s %s\" , CONFIG_SMBD_COMMAND , s -> smb_dir , smb_conf ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int slirp_smb ( SlirpState * s , const char * exported_dir , struct in_addr vserver_addr ) {\n"
                ],
                [
                    8,
                    " if ( ! passwd ) {\n"
                ],
                [
                    16,
                    " if ( access ( exported_dir , R_OK | X_OK ) ) {\n"
                ],
                [
                    17,
                    " error_report ( \"error accessing shared directory '%s': %s\" , exported_dir , strerror ( errno ) ) ;\n"
                ],
                [
                    25,
                    " snprintf ( smb_conf , sizeof ( smb_conf ) , \"%s/%s\" , s -> smb_dir , \"smb.conf\" ) ;\n"
                ],
                [
                    27,
                    " if ( ! f ) {\n"
                ],
                [
                    32,
                    " fprintf ( f , \"[global]\\n\" \"private dir=%s\\n\" \"interfaces=127.0.0.1\\n\" \"bind interfaces only=yes\\n\" \"pid directory=%s\\n\" \"lock directory=%s\\n\" \"state directory=%s\\n\" \"cache directory=%s\\n\" \"ncalrpc dir=%scalrpc\\n\" \"log file=%s/log.smbd\\n\" \"smb passwd file=%s/smbpasswd\\n\" \"security = user\\n\" \"map to guest = Bad User\\n\" \"load printers = no\\n\" \"printing = bsd\\n\" \"disable spoolss = yes\\n\" \"usershare max shares = 0\\n\" \"[qemu]\\n\" \"path=%s\\n\" \"read only=no\\n\" \"guest ok=yes\\n\" \"force user=%s\\n\" , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , exported_dir , passwd -> pw_name ) ;\n"
                ],
                [
                    33,
                    " fclose ( f ) ;\n"
                ],
                [
                    34,
                    " snprintf ( smb_cmdline , sizeof ( smb_cmdline ) , \"%s -l %s -s %s\" , CONFIG_SMBD_COMMAND , s -> smb_dir , smb_conf ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int testit ( struct test_case_struct * tc ) {\n int retval ;\n wordexp_t we , sav_we ;\n char * dummy ;\n int bzzzt = 0 ;\n int start_offs = 0 ;\n int i ;\n if ( tc -> env ) setenv ( \"var\" , tc -> env , 1 ) ;\n else unsetenv ( \"var\" ) ;\n if ( tc -> ifs ) setenv ( \"IFS\" , tc -> ifs , 1 ) ;\n else unsetenv ( \"IFS\" ) ;\n sav_we . we_wordc = 99 ;\n sav_we . we_wordv = & dummy ;\n sav_we . we_offs = 3 ;\n we = sav_we ;\n printf ( \"Test %d (%s): \" , ++ tests , tc -> words ) ;\n if ( tc -> flags & WRDE_APPEND ) {\n if ( wordexp ( \"pre1 pre2\" , & we , tc -> flags & ~ WRDE_APPEND ) != 0 ) {\n printf ( \"FAILED setup\\n\" ) ;\n return 1 ;\n }\n }\n retval = wordexp ( tc -> words , & we , tc -> flags ) ;\n if ( tc -> flags & WRDE_DOOFFS ) start_offs = sav_we . we_offs ;\n if ( retval != tc -> retval || ( retval == 0 && we . we_wordc != tc -> wordc ) ) bzzzt = 1 ;\n else if ( retval == 0 ) {\n for ( i = 0 ;\n i < start_offs ;\n ++ i ) if ( we . we_wordv [ i ] != NULL ) {\n bzzzt = 1 ;\n break ;\n }\n for ( i = 0 ;\n i < we . we_wordc ;\n ++ i ) if ( we . we_wordv [ i + start_offs ] == NULL || strcmp ( tc -> wordv [ i ] , we . we_wordv [ i + start_offs ] ) != 0 ) {\n bzzzt = 1 ;\n break ;\n }\n }\n if ( bzzzt ) {\n printf ( \"FAILED\\n\" ) ;\n printf ( \"Test words: <%s>, need retval %d, wordc %Zd\\n\" , tc -> words , tc -> retval , tc -> wordc ) ;\n if ( start_offs != 0 ) printf ( \"(preceded by %d NULLs)\\n\" , start_offs ) ;\n printf ( \"Got retval %d, wordc %Zd: \" , retval , we . we_wordc ) ;\n if ( retval == 0 || retval == WRDE_NOSPACE ) {\n for ( i = 0 ;\n i < we . we_wordc + start_offs ;\n ++ i ) if ( we . we_wordv [ i ] == NULL ) printf ( \"NULL \" ) ;\n else printf ( \"<%s> \" , we . we_wordv [ i ] ) ;\n }\n printf ( \"\\n\" ) ;\n }\n else if ( retval != 0 && retval != WRDE_NOSPACE && ( we . we_wordc != sav_we . we_wordc || we . we_wordv != sav_we . we_wordv || we . we_offs != sav_we . we_offs ) ) {\n bzzzt = 1 ;\n printf ( \"FAILED to restore wordexp_t members\\n\" ) ;\n }\n else printf ( \"OK\\n\" ) ;\n if ( retval == 0 || retval == WRDE_NOSPACE ) wordfree ( & we ) ;\n return bzzzt ;\n }",
        "hash": 9069516812577077304,
        "project": "debian",
        "size": 60,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int testit ( struct test_case_struct * tc ) {\n"
                ],
                [
                    35,
                    " ++ i ) if ( we . we_wordv [ i + start_offs ] == NULL || strcmp ( tc -> wordv [ i ] , we . we_wordv [ i + start_offs ] ) != 0 ) {\n"
                ],
                [
                    53,
                    " else if ( retval != 0 && retval != WRDE_NOSPACE && ( we . we_wordc != sav_we . we_wordc || we . we_wordv != sav_we . we_wordv || we . we_offs != sav_we . we_offs ) ) {\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "static int testit ( struct test_case_struct * tc ) {\n"
                ],
                [
                    15,
                    " we = sav_we ;\n"
                ],
                [
                    16,
                    " printf ( \"Test %d (%s): \" , ++ tests , tc -> words ) ;\n"
                ],
                [
                    18,
                    " if ( wordexp ( \"pre1 pre2\" , & we , tc -> flags & ~ WRDE_APPEND ) != 0 ) {\n"
                ],
                [
                    19,
                    " printf ( \"FAILED setup\\n\" ) ;\n"
                ],
                [
                    23,
                    " retval = wordexp ( tc -> words , & we , tc -> flags ) ;\n"
                ],
                [
                    25,
                    " if ( retval != tc -> retval || ( retval == 0 && we . we_wordc != tc -> wordc ) ) bzzzt = 1 ;\n"
                ],
                [
                    26,
                    " else if ( retval == 0 ) {\n"
                ],
                [
                    34,
                    " i < we . we_wordc ;\n"
                ],
                [
                    40,
                    " if ( bzzzt ) {\n"
                ],
                [
                    41,
                    " printf ( \"FAILED\\n\" ) ;\n"
                ],
                [
                    42,
                    " printf ( \"Test words: <%s>, need retval %d, wordc %Zd\\n\" , tc -> words , tc -> retval , tc -> wordc ) ;\n"
                ],
                [
                    43,
                    " if ( start_offs != 0 ) printf ( \"(preceded by %d NULLs)\\n\" , start_offs ) ;\n"
                ],
                [
                    44,
                    " printf ( \"Got retval %d, wordc %Zd: \" , retval , we . we_wordc ) ;\n"
                ],
                [
                    45,
                    " if ( retval == 0 || retval == WRDE_NOSPACE ) {\n"
                ],
                [
                    47,
                    " i < we . we_wordc + start_offs ;\n"
                ],
                [
                    48,
                    " ++ i ) if ( we . we_wordv [ i ] == NULL ) printf ( \"NULL \" ) ;\n"
                ],
                [
                    49,
                    " else printf ( \"<%s> \" , we . we_wordv [ i ] ) ;\n"
                ],
                [
                    51,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    53,
                    " else if ( retval != 0 && retval != WRDE_NOSPACE && ( we . we_wordc != sav_we . we_wordc || we . we_wordv != sav_we . we_wordv || we . we_offs != sav_we . we_offs ) ) {\n"
                ],
                [
                    55,
                    " printf ( \"FAILED to restore wordexp_t members\\n\" ) ;\n"
                ],
                [
                    57,
                    " else printf ( \"OK\\n\" ) ;\n"
                ],
                [
                    58,
                    " if ( retval == 0 || retval == WRDE_NOSPACE ) wordfree ( & we ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int testit ( struct test_case_struct * tc ) {\n"
                ],
                [
                    15,
                    " we = sav_we ;\n"
                ],
                [
                    16,
                    " printf ( \"Test %d (%s): \" , ++ tests , tc -> words ) ;\n"
                ],
                [
                    18,
                    " if ( wordexp ( \"pre1 pre2\" , & we , tc -> flags & ~ WRDE_APPEND ) != 0 ) {\n"
                ],
                [
                    19,
                    " printf ( \"FAILED setup\\n\" ) ;\n"
                ],
                [
                    23,
                    " retval = wordexp ( tc -> words , & we , tc -> flags ) ;\n"
                ],
                [
                    25,
                    " if ( retval != tc -> retval || ( retval == 0 && we . we_wordc != tc -> wordc ) ) bzzzt = 1 ;\n"
                ],
                [
                    26,
                    " else if ( retval == 0 ) {\n"
                ],
                [
                    34,
                    " i < we . we_wordc ;\n"
                ],
                [
                    35,
                    " ++ i ) if ( we . we_wordv [ i + start_offs ] == NULL || strcmp ( tc -> wordv [ i ] , we . we_wordv [ i + start_offs ] ) != 0 ) {\n"
                ],
                [
                    40,
                    " if ( bzzzt ) {\n"
                ],
                [
                    41,
                    " printf ( \"FAILED\\n\" ) ;\n"
                ],
                [
                    42,
                    " printf ( \"Test words: <%s>, need retval %d, wordc %Zd\\n\" , tc -> words , tc -> retval , tc -> wordc ) ;\n"
                ],
                [
                    43,
                    " if ( start_offs != 0 ) printf ( \"(preceded by %d NULLs)\\n\" , start_offs ) ;\n"
                ],
                [
                    44,
                    " printf ( \"Got retval %d, wordc %Zd: \" , retval , we . we_wordc ) ;\n"
                ],
                [
                    45,
                    " if ( retval == 0 || retval == WRDE_NOSPACE ) {\n"
                ],
                [
                    47,
                    " i < we . we_wordc + start_offs ;\n"
                ],
                [
                    48,
                    " ++ i ) if ( we . we_wordv [ i ] == NULL ) printf ( \"NULL \" ) ;\n"
                ],
                [
                    49,
                    " else printf ( \"<%s> \" , we . we_wordv [ i ] ) ;\n"
                ],
                [
                    51,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    53,
                    " else if ( retval != 0 && retval != WRDE_NOSPACE && ( we . we_wordc != sav_we . we_wordc || we . we_wordv != sav_we . we_wordv || we . we_offs != sav_we . we_offs ) ) {\n"
                ],
                [
                    55,
                    " printf ( \"FAILED to restore wordexp_t members\\n\" ) ;\n"
                ],
                [
                    57,
                    " else printf ( \"OK\\n\" ) ;\n"
                ],
                [
                    58,
                    " if ( retval == 0 || retval == WRDE_NOSPACE ) wordfree ( & we ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int decodenetnum ( const char * num , sockaddr_u * netnum ) {\n struct addrinfo hints , * ai = NULL ;\n int err ;\n u_short port ;\n const char * cp ;\n const char * port_str ;\n char * pp ;\n char * np ;\n char name [ 80 ] ;\n REQUIRE ( num != NULL ) ;\n REQUIRE ( strlen ( num ) < sizeof ( name ) ) ;\n port_str = NULL ;\n if ( '[' != num [ 0 ] ) {\n pp = strchr ( num , ':' ) ;\n if ( NULL == pp ) cp = num ;\n else if ( NULL != strchr ( pp + 1 , ':' ) ) cp = num ;\n else {\n strlcpy ( name , num , sizeof ( name ) ) ;\n cp = name ;\n pp = strchr ( cp , ':' ) ;\n * pp = '\\0' ;\n port_str = pp + 1 ;\n }\n }\n else {\n cp = num + 1 ;\n np = name ;\n while ( * cp && ']' != * cp ) * np ++ = * cp ++ ;\n * np = 0 ;\n if ( ']' == cp [ 0 ] && ':' == cp [ 1 ] && '\\0' != cp [ 2 ] ) port_str = & cp [ 2 ] ;\n cp = name ;\n }\n ZERO ( hints ) ;\n hints . ai_flags = Z_AI_NUMERICHOST ;\n err = getaddrinfo ( cp , \"ntp\" , & hints , & ai ) ;\n if ( err != 0 ) return 0 ;\n INSIST ( ai -> ai_addrlen <= sizeof ( * netnum ) ) ;\n ZERO ( * netnum ) ;\n memcpy ( netnum , ai -> ai_addr , ai -> ai_addrlen ) ;\n freeaddrinfo ( ai ) ;\n if ( NULL == port_str || 1 != sscanf ( port_str , \"%hu\" , & port ) ) port = NTP_PORT ;\n SET_PORT ( netnum , port ) ;\n return 1 ;\n }",
        "hash": -3165265590942668664,
        "project": "debian",
        "size": 44,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int decodenetnum ( const char * num , sockaddr_u * netnum ) {\n"
                ],
                [
                    2,
                    " struct addrinfo hints , * ai = NULL ;\n"
                ],
                [
                    36,
                    " if ( err != 0 ) return 0 ;\n"
                ],
                [
                    37,
                    " INSIST ( ai -> ai_addrlen <= sizeof ( * netnum ) ) ;\n"
                ],
                [
                    38,
                    " ZERO ( * netnum ) ;\n"
                ],
                [
                    39,
                    " memcpy ( netnum , ai -> ai_addr , ai -> ai_addrlen ) ;\n"
                ],
                [
                    40,
                    " freeaddrinfo ( ai ) ;\n"
                ],
                [
                    42,
                    " SET_PORT ( netnum , port ) ;\n"
                ]
            ],
            "strchr": [
                [
                    1,
                    "int decodenetnum ( const char * num , sockaddr_u * netnum ) {\n"
                ],
                [
                    11,
                    " REQUIRE ( strlen ( num ) < sizeof ( name ) ) ;\n"
                ],
                [
                    13,
                    " if ( '[' != num [ 0 ] ) {\n"
                ],
                [
                    14,
                    " pp = strchr ( num , ':' ) ;\n"
                ],
                [
                    15,
                    " if ( NULL == pp ) cp = num ;\n"
                ],
                [
                    16,
                    " else if ( NULL != strchr ( pp + 1 , ':' ) ) cp = num ;\n"
                ],
                [
                    18,
                    " strlcpy ( name , num , sizeof ( name ) ) ;\n"
                ],
                [
                    19,
                    " cp = name ;\n"
                ],
                [
                    20,
                    " pp = strchr ( cp , ':' ) ;\n"
                ],
                [
                    21,
                    " * pp = '\\0' ;\n"
                ],
                [
                    22,
                    " port_str = pp + 1 ;\n"
                ],
                [
                    35,
                    " err = getaddrinfo ( cp , \"ntp\" , & hints , & ai ) ;\n"
                ],
                [
                    41,
                    " if ( NULL == port_str || 1 != sscanf ( port_str , \"%hu\" , & port ) ) port = NTP_PORT ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "int decodenetnum ( const char * num , sockaddr_u * netnum ) {\n"
                ],
                [
                    10,
                    " REQUIRE ( num != NULL ) ;\n"
                ],
                [
                    11,
                    " REQUIRE ( strlen ( num ) < sizeof ( name ) ) ;\n"
                ],
                [
                    13,
                    " if ( '[' != num [ 0 ] ) {\n"
                ],
                [
                    14,
                    " pp = strchr ( num , ':' ) ;\n"
                ],
                [
                    26,
                    " cp = num + 1 ;\n"
                ]
            ],
            "sscanf": [
                [
                    1,
                    "int decodenetnum ( const char * num , sockaddr_u * netnum ) {\n"
                ],
                [
                    36,
                    " if ( err != 0 ) return 0 ;\n"
                ],
                [
                    41,
                    " if ( NULL == port_str || 1 != sscanf ( port_str , \"%hu\" , & port ) ) port = NTP_PORT ;\n"
                ],
                [
                    42,
                    " SET_PORT ( netnum , port ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int decodenetnum ( const char * num , sockaddr_u * netnum ) {\n"
                ],
                [
                    2,
                    " struct addrinfo hints , * ai = NULL ;\n"
                ],
                [
                    10,
                    " REQUIRE ( num != NULL ) ;\n"
                ],
                [
                    11,
                    " REQUIRE ( strlen ( num ) < sizeof ( name ) ) ;\n"
                ],
                [
                    13,
                    " if ( '[' != num [ 0 ] ) {\n"
                ],
                [
                    14,
                    " pp = strchr ( num , ':' ) ;\n"
                ],
                [
                    15,
                    " if ( NULL == pp ) cp = num ;\n"
                ],
                [
                    16,
                    " else if ( NULL != strchr ( pp + 1 , ':' ) ) cp = num ;\n"
                ],
                [
                    18,
                    " strlcpy ( name , num , sizeof ( name ) ) ;\n"
                ],
                [
                    19,
                    " cp = name ;\n"
                ],
                [
                    20,
                    " pp = strchr ( cp , ':' ) ;\n"
                ],
                [
                    21,
                    " * pp = '\\0' ;\n"
                ],
                [
                    22,
                    " port_str = pp + 1 ;\n"
                ],
                [
                    26,
                    " cp = num + 1 ;\n"
                ],
                [
                    35,
                    " err = getaddrinfo ( cp , \"ntp\" , & hints , & ai ) ;\n"
                ],
                [
                    36,
                    " if ( err != 0 ) return 0 ;\n"
                ],
                [
                    37,
                    " INSIST ( ai -> ai_addrlen <= sizeof ( * netnum ) ) ;\n"
                ],
                [
                    38,
                    " ZERO ( * netnum ) ;\n"
                ],
                [
                    39,
                    " memcpy ( netnum , ai -> ai_addr , ai -> ai_addrlen ) ;\n"
                ],
                [
                    40,
                    " freeaddrinfo ( ai ) ;\n"
                ],
                [
                    41,
                    " if ( NULL == port_str || 1 != sscanf ( port_str , \"%hu\" , & port ) ) port = NTP_PORT ;\n"
                ],
                [
                    42,
                    " SET_PORT ( netnum , port ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int dissect_ber_GeneralizedTime ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id ) {\n char str [ 35 ] ;\n int tmp_int ;\n const guint8 * tmpstr ;\n char * strptr ;\n char first_delim [ 2 ] ;\n int first_digits ;\n char second_delim [ 2 ] ;\n int second_digits ;\n int ret ;\n gint8 ber_class ;\n gboolean pc ;\n gint32 tag ;\n guint32 len ;\n int end_offset ;\n int hoffset ;\n proto_item * cause ;\n if ( ! implicit_tag ) {\n hoffset = offset ;\n offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag ) ;\n offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL ) ;\n end_offset = offset + len ;\n if ( ( ber_class != BER_CLASS_UNI ) || ( tag != BER_UNI_TAG_GeneralizedTime ) ) {\n tvb_ensure_bytes_exist ( tvb , hoffset , 2 ) ;\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"generalized_time_expected\" , \"GeneralizedTime expected but class:%s(%d) %s tag:%d was unexpected\" , val_to_str_const ( ber_class , ber_class_codes , \"Unknown\" ) , ber_class , pc ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tag ) ;\n expert_add_info ( actx -> pinfo , cause , & ei_ber_expected_generalized_time ) ;\n if ( decode_unexpected ) {\n proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;\n dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree ) ;\n }\n return end_offset ;\n }\n }\n else {\n len = tvb_reported_length_remaining ( tvb , offset ) ;\n end_offset = offset + len ;\n }\n if ( ( len < 14 ) || ( len > 23 ) ) {\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"illegal_length\" , \"GeneralizedTime invalid length: %u\" , len ) ;\n expert_add_info_format ( actx -> pinfo , cause , & ei_ber_error_length , \"BER Error: GeneralizedTime invalid length\" ) ;\n if ( decode_unexpected ) {\n proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;\n dissect_unknown_ber ( actx -> pinfo , tvb , offset , unknown_tree ) ;\n }\n return end_offset ;\n }\n tmpstr = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , len , ENC_ASCII ) ;\n strptr = str ;\n strptr += g_snprintf ( str , 20 , \"%.4s-%.2s-%.2s %.2s:%.2s:%.2s\" , tmpstr , tmpstr + 4 , tmpstr + 6 , tmpstr + 8 , tmpstr + 10 , tmpstr + 12 ) ;\n first_delim [ 0 ] = 0 ;\n second_delim [ 0 ] = 0 ;\n ret = sscanf ( tmpstr , \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\" , & tmp_int , first_delim , & first_digits , second_delim , & second_digits ) ;\n if ( ret < 1 ) {\n cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"invalid_generalized_time\" , \"GeneralizedTime invalid format: %s\" , tmpstr ) ;\n expert_add_info ( actx -> pinfo , cause , & ei_ber_invalid_format_generalized_time ) ;\n if ( decode_unexpected ) {\n proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;\n dissect_unknown_ber ( actx -> pinfo , tvb , offset , unknown_tree ) ;\n }\n return end_offset ;\n }\n switch ( first_delim [ 0 ] ) {\n case '.' : case ',' : strptr += g_snprintf ( strptr , 5 , \"%c%.3d\" , first_delim [ 0 ] , first_digits ) ;\n switch ( second_delim [ 0 ] ) {\n case '+' : case '-' : g_snprintf ( strptr , 12 , \" (UTC%c%.4d)\" , second_delim [ 0 ] , second_digits ) ;\n break ;\n case 'Z' : g_snprintf ( strptr , 7 , \" (UTC)\" ) ;\n break ;\n case 0 : break ;\n default : break ;\n }\n break ;\n case '+' : case '-' : g_snprintf ( strptr , 12 , \" (UTC%c%.4d)\" , first_delim [ 0 ] , first_digits ) ;\n break ;\n case 'Z' : g_snprintf ( strptr , 7 , \" (UTC)\" ) ;\n break ;\n case 0 : break ;\n default : break ;\n }\n if ( hf_id >= 0 ) {\n proto_tree_add_string ( tree , hf_id , tvb , offset , len , str ) ;\n }\n offset += len ;\n return offset ;\n }",
        "hash": -7434014980763120366,
        "project": "debian",
        "size": 85,
        "slice": {
            "sscanf": [
                [
                    1,
                    "int dissect_ber_GeneralizedTime ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id ) {\n"
                ],
                [
                    6,
                    " char first_delim [ 2 ] ;\n"
                ],
                [
                    8,
                    " char second_delim [ 2 ] ;\n"
                ],
                [
                    38,
                    " if ( ( len < 14 ) || ( len > 23 ) ) {\n"
                ],
                [
                    49,
                    " strptr += g_snprintf ( str , 20 , \"%.4s-%.2s-%.2s %.2s:%.2s:%.2s\" , tmpstr , tmpstr + 4 , tmpstr + 6 , tmpstr + 8 , tmpstr + 10 , tmpstr + 12 ) ;\n"
                ],
                [
                    50,
                    " first_delim [ 0 ] = 0 ;\n"
                ],
                [
                    51,
                    " second_delim [ 0 ] = 0 ;\n"
                ],
                [
                    52,
                    " ret = sscanf ( tmpstr , \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\" , & tmp_int , first_delim , & first_digits , second_delim , & second_digits ) ;\n"
                ],
                [
                    53,
                    " if ( ret < 1 ) {\n"
                ],
                [
                    54,
                    " cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"invalid_generalized_time\" , \"GeneralizedTime invalid format: %s\" , tmpstr ) ;\n"
                ],
                [
                    63,
                    " case '.' : case ',' : strptr += g_snprintf ( strptr , 5 , \"%c%.3d\" , first_delim [ 0 ] , first_digits ) ;\n"
                ],
                [
                    65,
                    " case '+' : case '-' : g_snprintf ( strptr , 12 , \" (UTC%c%.4d)\" , second_delim [ 0 ] , second_digits ) ;\n"
                ],
                [
                    73,
                    " case '+' : case '-' : g_snprintf ( strptr , 12 , \" (UTC%c%.4d)\" , first_delim [ 0 ] , first_digits ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int dissect_ber_GeneralizedTime ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id ) {\n"
                ],
                [
                    6,
                    " char first_delim [ 2 ] ;\n"
                ],
                [
                    8,
                    " char second_delim [ 2 ] ;\n"
                ],
                [
                    38,
                    " if ( ( len < 14 ) || ( len > 23 ) ) {\n"
                ],
                [
                    49,
                    " strptr += g_snprintf ( str , 20 , \"%.4s-%.2s-%.2s %.2s:%.2s:%.2s\" , tmpstr , tmpstr + 4 , tmpstr + 6 , tmpstr + 8 , tmpstr + 10 , tmpstr + 12 ) ;\n"
                ],
                [
                    50,
                    " first_delim [ 0 ] = 0 ;\n"
                ],
                [
                    51,
                    " second_delim [ 0 ] = 0 ;\n"
                ],
                [
                    52,
                    " ret = sscanf ( tmpstr , \"%14d%1[.,+-Z]%4d%1[+-Z]%4d\" , & tmp_int , first_delim , & first_digits , second_delim , & second_digits ) ;\n"
                ],
                [
                    53,
                    " if ( ret < 1 ) {\n"
                ],
                [
                    54,
                    " cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , \"invalid_generalized_time\" , \"GeneralizedTime invalid format: %s\" , tmpstr ) ;\n"
                ],
                [
                    63,
                    " case '.' : case ',' : strptr += g_snprintf ( strptr , 5 , \"%c%.3d\" , first_delim [ 0 ] , first_digits ) ;\n"
                ],
                [
                    65,
                    " case '+' : case '-' : g_snprintf ( strptr , 12 , \" (UTC%c%.4d)\" , second_delim [ 0 ] , second_digits ) ;\n"
                ],
                [
                    73,
                    " case '+' : case '-' : g_snprintf ( strptr , 12 , \" (UTC%c%.4d)\" , first_delim [ 0 ] , first_digits ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int gs_main_finit ( gs_main_instance * minst , int exit_status , int code ) {\n i_ctx_t * i_ctx_p = minst -> i_ctx_p ;\n gs_dual_memory_t dmem = {\n 0 }\n ;\n int exit_code ;\n ref error_object ;\n char * tempnames ;\n tempnames = gs_main_tempnames ( minst ) ;\n gs_finit_push_systemdict ( i_ctx_p ) ;\n if ( minst -> init_done >= 2 ) {\n gs_main_run_string ( minst , \"/BGPrint /GetDeviceParam .special_op \\ {\n{\n <</BeginPage {\npop}\n /EndPage {\npop pop //false }\n \\ /BGPrint false /NumRenderingThreads 0>> setpagedevice}\n if}\n if \\ serverdict /.jobsavelevel get 0 eq {\n/quit}\n {\n/stop}\n ifelse \\ .systemvar exec\" , 0 , & exit_code , & error_object ) ;\n }\n if ( minst -> init_done >= 2 ) {\n int code = 0 ;\n if ( idmemory -> reclaim != 0 ) {\n code = interp_reclaim ( & minst -> i_ctx_p , avm_global ) ;\n if ( code < 0 ) {\n ref error_name ;\n if ( tempnames ) free ( tempnames ) ;\n if ( gs_errorname ( i_ctx_p , code , & error_name ) >= 0 ) {\n char err_str [ 32 ] = {\n 0 }\n ;\n name_string_ref ( imemory , & error_name , & error_name ) ;\n memcpy ( err_str , error_name . value . const_bytes , r_size ( & error_name ) ) ;\n emprintf2 ( imemory , \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\" , err_str , code ) ;\n }\n else {\n emprintf1 ( imemory , \"UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\\n\" , code ) ;\n }\n # ifdef MEMENTO_SQUEEZE_BUILD if ( code != gs_error_VMerror ) return gs_error_Fatal ;\n # else return gs_error_Fatal ;\n # endif }\n i_ctx_p = minst -> i_ctx_p ;\n }\n if ( i_ctx_p -> pgs != NULL && i_ctx_p -> pgs -> device != NULL ) {\n gx_device * pdev = i_ctx_p -> pgs -> device ;\n const char * dname = pdev -> dname ;\n rc_adjust ( pdev , 1 , \"gs_main_finit\" ) ;\n gs_main_run_string ( minst , \".uninstallpagedevice serverdict \\ /.jobsavelevel get 0 eq {\n/quit}\n {\n/stop}\n ifelse .systemvar exec\" , 0 , & exit_code , & error_object ) ;\n code = gs_closedevice ( pdev ) ;\n if ( code < 0 ) {\n ref error_name ;\n if ( gs_errorname ( i_ctx_p , code , & error_name ) >= 0 ) {\n char err_str [ 32 ] = {\n 0 }\n ;\n name_string_ref ( imemory , & error_name , & error_name ) ;\n memcpy ( err_str , error_name . value . const_bytes , r_size ( & error_name ) ) ;\n emprintf3 ( imemory , \"ERROR: %s (%d) on closing %s device.\\n\" , err_str , code , dname ) ;\n }\n else {\n emprintf2 ( imemory , \"UNKNOWN ERROR %d closing %s device.\\n\" , code , dname ) ;\n }\n }\n rc_decrement ( pdev , \"gs_main_finit\" ) ;\n if ( exit_status == 0 || exit_status == gs_error_Quit ) exit_status = code ;\n }\n gs_main_run_string ( minst , \"(%stdout) (w) file closefile (%stderr) (w) file closefile \\ serverdict /.jobsavelevel get 0 eq {\n/quit}\n {\n/stop}\n ifelse .systemexec \\ systemdict /savedinitialgstate .forceundef\" , 0 , & exit_code , & error_object ) ;\n }\n gp_readline_finit ( minst -> readline_data ) ;\n i_ctx_p = minst -> i_ctx_p ;\n if ( gs_debug_c ( ':' ) ) {\n print_resource_usage ( minst , & gs_imemory , \"Final\" ) ;\n dmprintf1 ( minst -> heap , \"%% Exiting instance 0x%p\\n\" , minst ) ;\n }\n if ( minst -> init_done >= 1 ) {\n gs_memory_t * mem_raw = i_ctx_p -> memory . current -> non_gc_memory ;\n i_plugin_holder * h = i_ctx_p -> plugin_list ;\n dmem = * idmemory ;\n code = alloc_restore_all ( i_ctx_p ) ;\n if ( code < 0 ) emprintf1 ( mem_raw , \"ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\\n\" , code ) ;\n i_iodev_finit ( & dmem ) ;\n i_plugin_finit ( mem_raw , h ) ;\n }\n if ( minst -> heap -> gs_lib_ctx -> fstdout2 && ( minst -> heap -> gs_lib_ctx -> fstdout2 != minst -> heap -> gs_lib_ctx -> fstdout ) && ( minst -> heap -> gs_lib_ctx -> fstdout2 != minst -> heap -> gs_lib_ctx -> fstderr ) ) {\n fclose ( minst -> heap -> gs_lib_ctx -> fstdout2 ) ;\n minst -> heap -> gs_lib_ctx -> fstdout2 = ( FILE * ) NULL ;\n }\n minst -> heap -> gs_lib_ctx -> stdout_is_redirected = 0 ;\n minst -> heap -> gs_lib_ctx -> stdout_to_stderr = 0 ;\n if ( tempnames ) {\n char * p = tempnames ;\n while ( * p ) {\n unlink ( p ) ;\n p += strlen ( p ) + 1 ;\n }\n free ( tempnames ) ;\n }\n gs_lib_finit ( exit_status , code , minst -> heap ) ;\n gs_free_object ( minst -> heap , minst -> lib_path . container . value . refs , \"lib_path array\" ) ;\n ialloc_finit ( & dmem ) ;\n return exit_status ;\n }",
        "hash": -7670127399145950875,
        "project": "debian",
        "size": 115,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int gs_main_finit ( gs_main_instance * minst , int exit_status , int code ) {\n"
                ],
                [
                    33,
                    " if ( gs_errorname ( i_ctx_p , code , & error_name ) >= 0 ) {\n"
                ],
                [
                    38,
                    " memcpy ( err_str , error_name . value . const_bytes , r_size ( & error_name ) ) ;\n"
                ],
                [
                    39,
                    " emprintf2 ( imemory , \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\" , err_str , code ) ;\n"
                ],
                [
                    61,
                    " if ( gs_errorname ( i_ctx_p , code , & error_name ) >= 0 ) {\n"
                ],
                [
                    66,
                    " memcpy ( err_str , error_name . value . const_bytes , r_size ( & error_name ) ) ;\n"
                ],
                [
                    67,
                    " emprintf3 ( imemory , \"ERROR: %s (%d) on closing %s device.\\n\" , err_str , code , dname ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "int gs_main_finit ( gs_main_instance * minst , int exit_status , int code ) {\n"
                ],
                [
                    9,
                    " tempnames = gs_main_tempnames ( minst ) ;\n"
                ],
                [
                    32,
                    " if ( tempnames ) free ( tempnames ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int gs_main_finit ( gs_main_instance * minst , int exit_status , int code ) {\n"
                ],
                [
                    9,
                    " tempnames = gs_main_tempnames ( minst ) ;\n"
                ],
                [
                    32,
                    " if ( tempnames ) free ( tempnames ) ;\n"
                ],
                [
                    33,
                    " if ( gs_errorname ( i_ctx_p , code , & error_name ) >= 0 ) {\n"
                ],
                [
                    38,
                    " memcpy ( err_str , error_name . value . const_bytes , r_size ( & error_name ) ) ;\n"
                ],
                [
                    39,
                    " emprintf2 ( imemory , \"ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\\n\" , err_str , code ) ;\n"
                ],
                [
                    61,
                    " if ( gs_errorname ( i_ctx_p , code , & error_name ) >= 0 ) {\n"
                ],
                [
                    66,
                    " memcpy ( err_str , error_name . value . const_bytes , r_size ( & error_name ) ) ;\n"
                ],
                [
                    67,
                    " emprintf3 ( imemory , \"ERROR: %s (%d) on closing %s device.\\n\" , err_str , code , dname ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void xps_parse_glyphs ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n fz_xml * node ;\n char * fill_uri ;\n char * opacity_mask_uri ;\n char * bidi_level_att ;\n char * fill_att ;\n char * font_size_att ;\n char * font_uri_att ;\n char * origin_x_att ;\n char * origin_y_att ;\n char * is_sideways_att ;\n char * indices_att ;\n char * unicode_att ;\n char * style_att ;\n char * transform_att ;\n char * clip_att ;\n char * opacity_att ;\n char * opacity_mask_att ;\n char * navigate_uri_att ;\n fz_xml * transform_tag = NULL ;\n fz_xml * clip_tag = NULL ;\n fz_xml * fill_tag = NULL ;\n fz_xml * opacity_mask_tag = NULL ;\n char * fill_opacity_att = NULL ;\n xps_part * part ;\n fz_font * font ;\n char partname [ 1024 ] ;\n char fakename [ 1024 ] ;\n char * subfont ;\n float font_size = 10 ;\n int subfontid = 0 ;\n int is_sideways = 0 ;\n int bidi_level = 0 ;\n fz_text * text ;\n fz_rect area ;\n fz_matrix local_ctm = * ctm ;\n bidi_level_att = fz_xml_att ( root , \"BidiLevel\" ) ;\n fill_att = fz_xml_att ( root , \"Fill\" ) ;\n font_size_att = fz_xml_att ( root , \"FontRenderingEmSize\" ) ;\n font_uri_att = fz_xml_att ( root , \"FontUri\" ) ;\n origin_x_att = fz_xml_att ( root , \"OriginX\" ) ;\n origin_y_att = fz_xml_att ( root , \"OriginY\" ) ;\n is_sideways_att = fz_xml_att ( root , \"IsSideways\" ) ;\n indices_att = fz_xml_att ( root , \"Indices\" ) ;\n unicode_att = fz_xml_att ( root , \"UnicodeString\" ) ;\n style_att = fz_xml_att ( root , \"StyleSimulations\" ) ;\n transform_att = fz_xml_att ( root , \"RenderTransform\" ) ;\n clip_att = fz_xml_att ( root , \"Clip\" ) ;\n opacity_att = fz_xml_att ( root , \"Opacity\" ) ;\n opacity_mask_att = fz_xml_att ( root , \"OpacityMask\" ) ;\n navigate_uri_att = fz_xml_att ( root , \"FixedPage.NavigateUri\" ) ;\n for ( node = fz_xml_down ( root ) ;\n node ;\n node = fz_xml_next ( node ) ) {\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.RenderTransform\" ) ) transform_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.OpacityMask\" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.Clip\" ) ) clip_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.Fill\" ) ) fill_tag = fz_xml_down ( node ) ;\n }\n fill_uri = base_uri ;\n opacity_mask_uri = base_uri ;\n xps_resolve_resource_reference ( doc , dict , & transform_att , & transform_tag , NULL ) ;\n xps_resolve_resource_reference ( doc , dict , & clip_att , & clip_tag , NULL ) ;\n xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n xps_resolve_resource_reference ( doc , dict , & opacity_mask_att , & opacity_mask_tag , & opacity_mask_uri ) ;\n if ( ! font_size_att || ! font_uri_att || ! origin_x_att || ! origin_y_att ) {\n fz_warn ( doc -> ctx , \"missing attributes in glyphs element\" ) ;\n return ;\n }\n if ( ! indices_att && ! unicode_att ) return ;\n if ( is_sideways_att ) is_sideways = ! strcmp ( is_sideways_att , \"true\" ) ;\n if ( bidi_level_att ) bidi_level = atoi ( bidi_level_att ) ;\n xps_resolve_url ( partname , base_uri , font_uri_att , sizeof partname ) ;\n subfont = strrchr ( partname , '#' ) ;\n if ( subfont ) {\n subfontid = atoi ( subfont + 1 ) ;\n * subfont = 0 ;\n }\n fz_strlcpy ( fakename , partname , sizeof fakename ) ;\n if ( style_att ) {\n if ( ! strcmp ( style_att , \"BoldSimulation\" ) ) fz_strlcat ( fakename , \"#Bold\" , sizeof fakename ) ;\n else if ( ! strcmp ( style_att , \"ItalicSimulation\" ) ) fz_strlcat ( fakename , \"#Italic\" , sizeof fakename ) ;\n else if ( ! strcmp ( style_att , \"BoldItalicSimulation\" ) ) fz_strlcat ( fakename , \"#BoldItalic\" , sizeof fakename ) ;\n }\n font = xps_lookup_font ( doc , fakename ) ;\n if ( ! font ) {\n fz_try ( doc -> ctx ) {\n part = xps_read_part ( doc , partname ) ;\n }\n fz_catch ( doc -> ctx ) {\n fz_rethrow_if ( doc -> ctx , FZ_ERROR_TRYLATER ) ;\n fz_warn ( doc -> ctx , \"cannot find font resource part '%s'\" , partname ) ;\n return ;\n }\n if ( strstr ( part -> name , \".odttf\" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n if ( strstr ( part -> name , \".ODTTF\" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n fz_try ( doc -> ctx ) {\n fz_buffer * buf = fz_new_buffer_from_data ( doc -> ctx , part -> data , part -> size ) ;\n font = fz_new_font_from_buffer ( doc -> ctx , NULL , buf , subfontid , 1 ) ;\n fz_drop_buffer ( doc -> ctx , buf ) ;\n }\n fz_catch ( doc -> ctx ) {\n fz_rethrow_if ( doc -> ctx , FZ_ERROR_TRYLATER ) ;\n fz_warn ( doc -> ctx , \"cannot load font resource '%s'\" , partname ) ;\n xps_free_part ( doc , part ) ;\n return ;\n }\n if ( style_att ) {\n font -> ft_bold = ! ! strstr ( style_att , \"Bold\" ) ;\n font -> ft_italic = ! ! strstr ( style_att , \"Italic\" ) ;\n }\n xps_select_best_font_encoding ( doc , font ) ;\n xps_insert_font ( doc , fakename , font ) ;\n fz_free ( doc -> ctx , part -> name ) ;\n fz_free ( doc -> ctx , part ) ;\n }\n if ( transform_att || transform_tag ) {\n fz_matrix transform ;\n if ( transform_att ) xps_parse_render_transform ( doc , transform_att , & transform ) ;\n if ( transform_tag ) xps_parse_matrix_transform ( doc , transform_tag , & transform ) ;\n fz_concat ( & local_ctm , & transform , & local_ctm ) ;\n }\n if ( clip_att || clip_tag ) xps_clip ( doc , & local_ctm , dict , clip_att , clip_tag ) ;\n font_size = fz_atof ( font_size_att ) ;\n text = xps_parse_glyphs_imp ( doc , & local_ctm , font , font_size , fz_atof ( origin_x_att ) , fz_atof ( origin_y_att ) , is_sideways , bidi_level , indices_att , unicode_att ) ;\n fz_bound_text ( doc -> ctx , text , NULL , & local_ctm , & area ) ;\n if ( navigate_uri_att ) xps_add_link ( doc , & area , base_uri , navigate_uri_att ) ;\n xps_begin_opacity ( doc , & local_ctm , & area , opacity_mask_uri , dict , opacity_att , opacity_mask_tag ) ;\n if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , \"SolidColorBrush\" ) ) {\n fill_opacity_att = fz_xml_att ( fill_tag , \"Opacity\" ) ;\n fill_att = fz_xml_att ( fill_tag , \"Color\" ) ;\n fill_tag = NULL ;\n }\n if ( fill_att ) {\n float samples [ 32 ] ;\n fz_colorspace * colorspace ;\n xps_parse_color ( doc , base_uri , fill_att , & colorspace , samples ) ;\n if ( fill_opacity_att ) samples [ 0 ] *= fz_atof ( fill_opacity_att ) ;\n xps_set_color ( doc , colorspace , samples ) ;\n fz_fill_text ( doc -> dev , text , & local_ctm , doc -> colorspace , doc -> color , doc -> alpha ) ;\n }\n if ( fill_tag ) {\n fz_clip_text ( doc -> dev , text , & local_ctm , 0 ) ;\n xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;\n fz_pop_clip ( doc -> dev ) ;\n }\n xps_end_opacity ( doc , opacity_mask_uri , dict , opacity_att , opacity_mask_tag ) ;\n fz_free_text ( doc -> ctx , text ) ;\n if ( clip_att || clip_tag ) fz_pop_clip ( doc -> dev ) ;\n fz_drop_font ( doc -> ctx , font ) ;\n }",
        "hash": -4421762461659142174,
        "project": "debian",
        "size": 151,
        "slice": {
            "strcmp": [
                [
                    1,
                    "void xps_parse_glyphs ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n"
                ],
                [
                    22,
                    " fz_xml * fill_tag = NULL ;\n"
                ],
                [
                    43,
                    " is_sideways_att = fz_xml_att ( root , \"IsSideways\" ) ;\n"
                ],
                [
                    46,
                    " style_att = fz_xml_att ( root , \"StyleSimulations\" ) ;\n"
                ],
                [
                    53,
                    " node ;\n"
                ],
                [
                    55,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.RenderTransform\" ) ) transform_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    56,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.OpacityMask\" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    57,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.Clip\" ) ) clip_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    58,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.Fill\" ) ) fill_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    64,
                    " xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n"
                ],
                [
                    71,
                    " if ( is_sideways_att ) is_sideways = ! strcmp ( is_sideways_att , \"true\" ) ;\n"
                ],
                [
                    80,
                    " if ( style_att ) {\n"
                ],
                [
                    81,
                    " if ( ! strcmp ( style_att , \"BoldSimulation\" ) ) fz_strlcat ( fakename , \"#Bold\" , sizeof fakename ) ;\n"
                ],
                [
                    82,
                    " else if ( ! strcmp ( style_att , \"ItalicSimulation\" ) ) fz_strlcat ( fakename , \"#Italic\" , sizeof fakename ) ;\n"
                ],
                [
                    83,
                    " else if ( ! strcmp ( style_att , \"BoldItalicSimulation\" ) ) fz_strlcat ( fakename , \"#BoldItalic\" , sizeof fakename ) ;\n"
                ],
                [
                    86,
                    " if ( ! font ) {\n"
                ],
                [
                    125,
                    " text = xps_parse_glyphs_imp ( doc , & local_ctm , font , font_size , fz_atof ( origin_x_att ) , fz_atof ( origin_y_att ) , is_sideways , bidi_level , indices_att , unicode_att ) ;\n"
                ],
                [
                    129,
                    " if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , \"SolidColorBrush\" ) ) {\n"
                ],
                [
                    130,
                    " fill_opacity_att = fz_xml_att ( fill_tag , \"Opacity\" ) ;\n"
                ],
                [
                    131,
                    " fill_att = fz_xml_att ( fill_tag , \"Color\" ) ;\n"
                ],
                [
                    132,
                    " fill_tag = NULL ;\n"
                ],
                [
                    144,
                    " xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;\n"
                ]
            ],
            "strstr": [
                [
                    95,
                    " if ( strstr ( part -> name , \".odttf\" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n"
                ],
                [
                    96,
                    " if ( strstr ( part -> name , \".ODTTF\" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n"
                ],
                [
                    108,
                    " if ( style_att ) {\n"
                ],
                [
                    109,
                    " font -> ft_bold = ! ! strstr ( style_att , \"Bold\" ) ;\n"
                ],
                [
                    110,
                    " font -> ft_italic = ! ! strstr ( style_att , \"Italic\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void xps_parse_glyphs ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n"
                ],
                [
                    22,
                    " fz_xml * fill_tag = NULL ;\n"
                ],
                [
                    43,
                    " is_sideways_att = fz_xml_att ( root , \"IsSideways\" ) ;\n"
                ],
                [
                    46,
                    " style_att = fz_xml_att ( root , \"StyleSimulations\" ) ;\n"
                ],
                [
                    53,
                    " node ;\n"
                ],
                [
                    55,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.RenderTransform\" ) ) transform_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    56,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.OpacityMask\" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    57,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.Clip\" ) ) clip_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    58,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Glyphs.Fill\" ) ) fill_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    64,
                    " xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n"
                ],
                [
                    71,
                    " if ( is_sideways_att ) is_sideways = ! strcmp ( is_sideways_att , \"true\" ) ;\n"
                ],
                [
                    80,
                    " if ( style_att ) {\n"
                ],
                [
                    81,
                    " if ( ! strcmp ( style_att , \"BoldSimulation\" ) ) fz_strlcat ( fakename , \"#Bold\" , sizeof fakename ) ;\n"
                ],
                [
                    82,
                    " else if ( ! strcmp ( style_att , \"ItalicSimulation\" ) ) fz_strlcat ( fakename , \"#Italic\" , sizeof fakename ) ;\n"
                ],
                [
                    83,
                    " else if ( ! strcmp ( style_att , \"BoldItalicSimulation\" ) ) fz_strlcat ( fakename , \"#BoldItalic\" , sizeof fakename ) ;\n"
                ],
                [
                    86,
                    " if ( ! font ) {\n"
                ],
                [
                    95,
                    " if ( strstr ( part -> name , \".odttf\" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n"
                ],
                [
                    96,
                    " if ( strstr ( part -> name , \".ODTTF\" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n"
                ],
                [
                    108,
                    " if ( style_att ) {\n"
                ],
                [
                    109,
                    " font -> ft_bold = ! ! strstr ( style_att , \"Bold\" ) ;\n"
                ],
                [
                    110,
                    " font -> ft_italic = ! ! strstr ( style_att , \"Italic\" ) ;\n"
                ],
                [
                    125,
                    " text = xps_parse_glyphs_imp ( doc , & local_ctm , font , font_size , fz_atof ( origin_x_att ) , fz_atof ( origin_y_att ) , is_sideways , bidi_level , indices_att , unicode_att ) ;\n"
                ],
                [
                    129,
                    " if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , \"SolidColorBrush\" ) ) {\n"
                ],
                [
                    130,
                    " fill_opacity_att = fz_xml_att ( fill_tag , \"Opacity\" ) ;\n"
                ],
                [
                    131,
                    " fill_att = fz_xml_att ( fill_tag , \"Color\" ) ;\n"
                ],
                [
                    132,
                    " fill_tag = NULL ;\n"
                ],
                [
                    144,
                    " xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void xps_parse_color ( xps_document * doc , char * base_uri , char * string , fz_colorspace * * csp , float * samples ) {\n char * p ;\n int i , n ;\n char buf [ 1024 ] ;\n char * profile ;\n * csp = fz_device_rgb ( doc -> ctx ) ;\n samples [ 0 ] = 1 ;\n samples [ 1 ] = 0 ;\n samples [ 2 ] = 0 ;\n samples [ 3 ] = 0 ;\n if ( string [ 0 ] == '#' ) {\n if ( strlen ( string ) == 9 ) {\n samples [ 0 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n samples [ 1 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n samples [ 2 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n samples [ 3 ] = unhex ( string [ 7 ] ) * 16 + unhex ( string [ 8 ] ) ;\n }\n else {\n samples [ 0 ] = 255 ;\n samples [ 1 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n samples [ 2 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n samples [ 3 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n }\n samples [ 0 ] /= 255 ;\n samples [ 1 ] /= 255 ;\n samples [ 2 ] /= 255 ;\n samples [ 3 ] /= 255 ;\n }\n else if ( string [ 0 ] == 's' && string [ 1 ] == 'c' && string [ 2 ] == '#' ) {\n if ( count_commas ( string ) == 2 ) sscanf ( string , \"sc#%g,%g,%g\" , samples + 1 , samples + 2 , samples + 3 ) ;\n if ( count_commas ( string ) == 3 ) sscanf ( string , \"sc#%g,%g,%g,%g\" , samples , samples + 1 , samples + 2 , samples + 3 ) ;\n }\n else if ( strstr ( string , \"ContextColor \" ) == string ) {\n fz_strlcpy ( buf , string , sizeof buf ) ;\n profile = strchr ( buf , ' ' ) ;\n if ( ! profile ) {\n fz_warn ( doc -> ctx , \"cannot find icc profile uri in '%s'\" , string ) ;\n return ;\n }\n * profile ++ = 0 ;\n p = strchr ( profile , ' ' ) ;\n if ( ! p ) {\n fz_warn ( doc -> ctx , \"cannot find component values in '%s'\" , profile ) ;\n return ;\n }\n * p ++ = 0 ;\n n = count_commas ( p ) + 1 ;\n i = 0 ;\n while ( i < n ) {\n samples [ i ++ ] = fz_atof ( p ) ;\n p = strchr ( p , ',' ) ;\n if ( ! p ) break ;\n p ++ ;\n if ( * p == ' ' ) p ++ ;\n }\n while ( i < n ) {\n samples [ i ++ ] = 0 ;\n }\n switch ( n ) {\n case 2 : * csp = fz_device_gray ( doc -> ctx ) ;\n break ;\n case 4 : * csp = fz_device_rgb ( doc -> ctx ) ;\n break ;\n case 5 : * csp = fz_device_cmyk ( doc -> ctx ) ;\n break ;\n default : * csp = fz_device_gray ( doc -> ctx ) ;\n break ;\n }\n }\n }",
        "hash": 6573793021826676268,
        "project": "debian",
        "size": 70,
        "slice": {
            "strchr": [
                [
                    1,
                    "void xps_parse_color ( xps_document * doc , char * base_uri , char * string , fz_colorspace * * csp , float * samples ) {\n"
                ],
                [
                    33,
                    " else if ( strstr ( string , \"ContextColor \" ) == string ) {\n"
                ],
                [
                    34,
                    " fz_strlcpy ( buf , string , sizeof buf ) ;\n"
                ],
                [
                    35,
                    " profile = strchr ( buf , ' ' ) ;\n"
                ],
                [
                    36,
                    " if ( ! profile ) {\n"
                ],
                [
                    40,
                    " * profile ++ = 0 ;\n"
                ],
                [
                    41,
                    " p = strchr ( profile , ' ' ) ;\n"
                ],
                [
                    42,
                    " if ( ! p ) {\n"
                ],
                [
                    43,
                    " fz_warn ( doc -> ctx , \"cannot find component values in '%s'\" , profile ) ;\n"
                ],
                [
                    49,
                    " while ( i < n ) {\n"
                ],
                [
                    50,
                    " samples [ i ++ ] = fz_atof ( p ) ;\n"
                ],
                [
                    51,
                    " p = strchr ( p , ',' ) ;\n"
                ],
                [
                    52,
                    " if ( ! p ) break ;\n"
                ],
                [
                    54,
                    " if ( * p == ' ' ) p ++ ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "void xps_parse_color ( xps_document * doc , char * base_uri , char * string , fz_colorspace * * csp , float * samples ) {\n"
                ],
                [
                    11,
                    " if ( string [ 0 ] == '#' ) {\n"
                ],
                [
                    12,
                    " if ( strlen ( string ) == 9 ) {\n"
                ],
                [
                    13,
                    " samples [ 0 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n"
                ],
                [
                    14,
                    " samples [ 1 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n"
                ],
                [
                    15,
                    " samples [ 2 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n"
                ],
                [
                    16,
                    " samples [ 3 ] = unhex ( string [ 7 ] ) * 16 + unhex ( string [ 8 ] ) ;\n"
                ],
                [
                    19,
                    " samples [ 0 ] = 255 ;\n"
                ],
                [
                    20,
                    " samples [ 1 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n"
                ],
                [
                    21,
                    " samples [ 2 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n"
                ],
                [
                    22,
                    " samples [ 3 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "void xps_parse_color ( xps_document * doc , char * base_uri , char * string , fz_colorspace * * csp , float * samples ) {\n"
                ],
                [
                    29,
                    " else if ( string [ 0 ] == 's' && string [ 1 ] == 'c' && string [ 2 ] == '#' ) {\n"
                ],
                [
                    33,
                    " else if ( strstr ( string , \"ContextColor \" ) == string ) {\n"
                ],
                [
                    34,
                    " fz_strlcpy ( buf , string , sizeof buf ) ;\n"
                ],
                [
                    35,
                    " profile = strchr ( buf , ' ' ) ;\n"
                ],
                [
                    36,
                    " if ( ! profile ) {\n"
                ]
            ],
            "sscanf": [
                [
                    1,
                    "void xps_parse_color ( xps_document * doc , char * base_uri , char * string , fz_colorspace * * csp , float * samples ) {\n"
                ],
                [
                    7,
                    " samples [ 0 ] = 1 ;\n"
                ],
                [
                    8,
                    " samples [ 1 ] = 0 ;\n"
                ],
                [
                    9,
                    " samples [ 2 ] = 0 ;\n"
                ],
                [
                    10,
                    " samples [ 3 ] = 0 ;\n"
                ],
                [
                    29,
                    " else if ( string [ 0 ] == 's' && string [ 1 ] == 'c' && string [ 2 ] == '#' ) {\n"
                ],
                [
                    30,
                    " if ( count_commas ( string ) == 2 ) sscanf ( string , \"sc#%g,%g,%g\" , samples + 1 , samples + 2 , samples + 3 ) ;\n"
                ],
                [
                    31,
                    " if ( count_commas ( string ) == 3 ) sscanf ( string , \"sc#%g,%g,%g,%g\" , samples , samples + 1 , samples + 2 , samples + 3 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void xps_parse_color ( xps_document * doc , char * base_uri , char * string , fz_colorspace * * csp , float * samples ) {\n"
                ],
                [
                    7,
                    " samples [ 0 ] = 1 ;\n"
                ],
                [
                    8,
                    " samples [ 1 ] = 0 ;\n"
                ],
                [
                    9,
                    " samples [ 2 ] = 0 ;\n"
                ],
                [
                    10,
                    " samples [ 3 ] = 0 ;\n"
                ],
                [
                    11,
                    " if ( string [ 0 ] == '#' ) {\n"
                ],
                [
                    12,
                    " if ( strlen ( string ) == 9 ) {\n"
                ],
                [
                    13,
                    " samples [ 0 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n"
                ],
                [
                    14,
                    " samples [ 1 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n"
                ],
                [
                    15,
                    " samples [ 2 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n"
                ],
                [
                    16,
                    " samples [ 3 ] = unhex ( string [ 7 ] ) * 16 + unhex ( string [ 8 ] ) ;\n"
                ],
                [
                    19,
                    " samples [ 0 ] = 255 ;\n"
                ],
                [
                    20,
                    " samples [ 1 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n"
                ],
                [
                    21,
                    " samples [ 2 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n"
                ],
                [
                    22,
                    " samples [ 3 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n"
                ],
                [
                    29,
                    " else if ( string [ 0 ] == 's' && string [ 1 ] == 'c' && string [ 2 ] == '#' ) {\n"
                ],
                [
                    30,
                    " if ( count_commas ( string ) == 2 ) sscanf ( string , \"sc#%g,%g,%g\" , samples + 1 , samples + 2 , samples + 3 ) ;\n"
                ],
                [
                    31,
                    " if ( count_commas ( string ) == 3 ) sscanf ( string , \"sc#%g,%g,%g,%g\" , samples , samples + 1 , samples + 2 , samples + 3 ) ;\n"
                ],
                [
                    33,
                    " else if ( strstr ( string , \"ContextColor \" ) == string ) {\n"
                ],
                [
                    34,
                    " fz_strlcpy ( buf , string , sizeof buf ) ;\n"
                ],
                [
                    35,
                    " profile = strchr ( buf , ' ' ) ;\n"
                ],
                [
                    36,
                    " if ( ! profile ) {\n"
                ],
                [
                    40,
                    " * profile ++ = 0 ;\n"
                ],
                [
                    41,
                    " p = strchr ( profile , ' ' ) ;\n"
                ],
                [
                    42,
                    " if ( ! p ) {\n"
                ],
                [
                    43,
                    " fz_warn ( doc -> ctx , \"cannot find component values in '%s'\" , profile ) ;\n"
                ],
                [
                    49,
                    " while ( i < n ) {\n"
                ],
                [
                    50,
                    " samples [ i ++ ] = fz_atof ( p ) ;\n"
                ],
                [
                    51,
                    " p = strchr ( p , ',' ) ;\n"
                ],
                [
                    52,
                    " if ( ! p ) break ;\n"
                ],
                [
                    54,
                    " if ( * p == ' ' ) p ++ ;\n"
                ]
            ]
        }
    },
    {
        "code": "void xps_begin_opacity ( xps_document * doc , const fz_matrix * ctm , const fz_rect * area , char * base_uri , xps_resource * dict , char * opacity_att , fz_xml * opacity_mask_tag ) {\n float opacity ;\n if ( ! opacity_att && ! opacity_mask_tag ) return ;\n opacity = 1 ;\n if ( opacity_att ) opacity = fz_atof ( opacity_att ) ;\n if ( opacity_mask_tag && ! strcmp ( fz_xml_tag ( opacity_mask_tag ) , \"SolidColorBrush\" ) ) {\n char * scb_opacity_att = fz_xml_att ( opacity_mask_tag , \"Opacity\" ) ;\n char * scb_color_att = fz_xml_att ( opacity_mask_tag , \"Color\" ) ;\n if ( scb_opacity_att ) opacity = opacity * fz_atof ( scb_opacity_att ) ;\n if ( scb_color_att ) {\n fz_colorspace * colorspace ;\n float samples [ 32 ] ;\n xps_parse_color ( doc , base_uri , scb_color_att , & colorspace , samples ) ;\n opacity = opacity * samples [ 0 ] ;\n }\n opacity_mask_tag = NULL ;\n }\n if ( doc -> opacity_top + 1 < nelem ( doc -> opacity ) ) {\n doc -> opacity [ doc -> opacity_top + 1 ] = doc -> opacity [ doc -> opacity_top ] * opacity ;\n doc -> opacity_top ++ ;\n }\n if ( opacity_mask_tag ) {\n fz_begin_mask ( doc -> dev , area , 0 , NULL , NULL ) ;\n xps_parse_brush ( doc , ctm , area , base_uri , dict , opacity_mask_tag ) ;\n fz_end_mask ( doc -> dev ) ;\n }\n }",
        "hash": 6573793021826676268,
        "project": "debian",
        "size": 27,
        "slice": {
            "strcmp": [
                [
                    1,
                    "void xps_begin_opacity ( xps_document * doc , const fz_matrix * ctm , const fz_rect * area , char * base_uri , xps_resource * dict , char * opacity_att , fz_xml * opacity_mask_tag ) {\n"
                ],
                [
                    3,
                    " if ( ! opacity_att && ! opacity_mask_tag ) return ;\n"
                ],
                [
                    6,
                    " if ( opacity_mask_tag && ! strcmp ( fz_xml_tag ( opacity_mask_tag ) , \"SolidColorBrush\" ) ) {\n"
                ],
                [
                    7,
                    " char * scb_opacity_att = fz_xml_att ( opacity_mask_tag , \"Opacity\" ) ;\n"
                ],
                [
                    8,
                    " char * scb_color_att = fz_xml_att ( opacity_mask_tag , \"Color\" ) ;\n"
                ],
                [
                    9,
                    " if ( scb_opacity_att ) opacity = opacity * fz_atof ( scb_opacity_att ) ;\n"
                ],
                [
                    10,
                    " if ( scb_color_att ) {\n"
                ],
                [
                    16,
                    " opacity_mask_tag = NULL ;\n"
                ],
                [
                    24,
                    " xps_parse_brush ( doc , ctm , area , base_uri , dict , opacity_mask_tag ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void xps_begin_opacity ( xps_document * doc , const fz_matrix * ctm , const fz_rect * area , char * base_uri , xps_resource * dict , char * opacity_att , fz_xml * opacity_mask_tag ) {\n"
                ],
                [
                    3,
                    " if ( ! opacity_att && ! opacity_mask_tag ) return ;\n"
                ],
                [
                    6,
                    " if ( opacity_mask_tag && ! strcmp ( fz_xml_tag ( opacity_mask_tag ) , \"SolidColorBrush\" ) ) {\n"
                ],
                [
                    7,
                    " char * scb_opacity_att = fz_xml_att ( opacity_mask_tag , \"Opacity\" ) ;\n"
                ],
                [
                    8,
                    " char * scb_color_att = fz_xml_att ( opacity_mask_tag , \"Color\" ) ;\n"
                ],
                [
                    9,
                    " if ( scb_opacity_att ) opacity = opacity * fz_atof ( scb_opacity_att ) ;\n"
                ],
                [
                    10,
                    " if ( scb_color_att ) {\n"
                ],
                [
                    16,
                    " opacity_mask_tag = NULL ;\n"
                ],
                [
                    24,
                    " xps_parse_brush ( doc , ctm , area , base_uri , dict , opacity_mask_tag ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int xps_parse_gradient_stops ( xps_document * doc , char * base_uri , fz_xml * node , struct stop * stops , int maxcount ) {\n fz_colorspace * colorspace ;\n float sample [ 8 ] ;\n float rgb [ 3 ] ;\n int before , after ;\n int count ;\n int i ;\n maxcount -= 2 ;\n count = 0 ;\n while ( node && count < maxcount ) {\n if ( ! strcmp ( fz_xml_tag ( node ) , \"GradientStop\" ) ) {\n char * offset = fz_xml_att ( node , \"Offset\" ) ;\n char * color = fz_xml_att ( node , \"Color\" ) ;\n if ( offset && color ) {\n stops [ count ] . offset = fz_atof ( offset ) ;\n stops [ count ] . index = count ;\n xps_parse_color ( doc , base_uri , color , & colorspace , sample ) ;\n fz_convert_color ( doc -> ctx , fz_device_rgb ( doc -> ctx ) , rgb , colorspace , sample + 1 ) ;\n stops [ count ] . r = rgb [ 0 ] ;\n stops [ count ] . g = rgb [ 1 ] ;\n stops [ count ] . b = rgb [ 2 ] ;\n stops [ count ] . a = sample [ 0 ] ;\n count ++ ;\n }\n }\n node = fz_xml_next ( node ) ;\n }\n if ( count == 0 ) {\n fz_warn ( doc -> ctx , \"gradient brush has no gradient stops\" ) ;\n stops [ 0 ] . offset = 0 ;\n stops [ 0 ] . r = 0 ;\n stops [ 0 ] . g = 0 ;\n stops [ 0 ] . b = 0 ;\n stops [ 0 ] . a = 1 ;\n stops [ 1 ] . offset = 1 ;\n stops [ 1 ] . r = 1 ;\n stops [ 1 ] . g = 1 ;\n stops [ 1 ] . b = 1 ;\n stops [ 1 ] . a = 1 ;\n return 2 ;\n }\n if ( count == maxcount ) fz_warn ( doc -> ctx , \"gradient brush exceeded maximum number of gradient stops\" ) ;\n qsort ( stops , count , sizeof ( struct stop ) , cmp_stop ) ;\n before = - 1 ;\n after = - 1 ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n if ( stops [ i ] . offset < 0 ) before = i ;\n if ( stops [ i ] . offset > 1 ) {\n after = i ;\n break ;\n }\n }\n if ( before > 0 ) {\n memmove ( stops , stops + before , ( count - before ) * sizeof ( struct stop ) ) ;\n count -= before ;\n }\n if ( after >= 0 ) count = after + 1 ;\n if ( count == 1 ) {\n stops [ 1 ] = stops [ 0 ] ;\n stops [ 0 ] . offset = 0 ;\n stops [ 1 ] . offset = 1 ;\n return 2 ;\n }\n if ( stops [ 0 ] . offset < 0 ) {\n float d = - stops [ 0 ] . offset / ( stops [ 1 ] . offset - stops [ 0 ] . offset ) ;\n stops [ 0 ] . offset = 0 ;\n stops [ 0 ] . r = lerp ( stops [ 0 ] . r , stops [ 1 ] . r , d ) ;\n stops [ 0 ] . g = lerp ( stops [ 0 ] . g , stops [ 1 ] . g , d ) ;\n stops [ 0 ] . b = lerp ( stops [ 0 ] . b , stops [ 1 ] . b , d ) ;\n stops [ 0 ] . a = lerp ( stops [ 0 ] . a , stops [ 1 ] . a , d ) ;\n }\n if ( stops [ count - 1 ] . offset > 1 ) {\n float d = ( 1 - stops [ count - 2 ] . offset ) / ( stops [ count - 1 ] . offset - stops [ count - 2 ] . offset ) ;\n stops [ count - 1 ] . offset = 1 ;\n stops [ count - 1 ] . r = lerp ( stops [ count - 2 ] . r , stops [ count - 1 ] . r , d ) ;\n stops [ count - 1 ] . g = lerp ( stops [ count - 2 ] . g , stops [ count - 1 ] . g , d ) ;\n stops [ count - 1 ] . b = lerp ( stops [ count - 2 ] . b , stops [ count - 1 ] . b , d ) ;\n stops [ count - 1 ] . a = lerp ( stops [ count - 2 ] . a , stops [ count - 1 ] . a , d ) ;\n }\n if ( stops [ 0 ] . offset > 0 ) {\n memmove ( stops + 1 , stops , count * sizeof ( struct stop ) ) ;\n stops [ 0 ] = stops [ 1 ] ;\n stops [ 0 ] . offset = 0 ;\n count ++ ;\n }\n if ( stops [ count - 1 ] . offset < 1 ) {\n stops [ count ] = stops [ count - 1 ] ;\n stops [ count ] . offset = 1 ;\n count ++ ;\n }\n return count ;\n }",
        "hash": -9028269206303312561,
        "project": "debian",
        "size": 94,
        "slice": {
            "memmove": [
                [
                    1,
                    "static int xps_parse_gradient_stops ( xps_document * doc , char * base_uri , fz_xml * node , struct stop * stops , int maxcount ) {\n"
                ],
                [
                    43,
                    " qsort ( stops , count , sizeof ( struct stop ) , cmp_stop ) ;\n"
                ],
                [
                    55,
                    " if ( before > 0 ) {\n"
                ],
                [
                    56,
                    " memmove ( stops , stops + before , ( count - before ) * sizeof ( struct stop ) ) ;\n"
                ],
                [
                    61,
                    " stops [ 1 ] = stops [ 0 ] ;\n"
                ],
                [
                    82,
                    " if ( stops [ 0 ] . offset > 0 ) {\n"
                ],
                [
                    83,
                    " memmove ( stops + 1 , stops , count * sizeof ( struct stop ) ) ;\n"
                ],
                [
                    84,
                    " stops [ 0 ] = stops [ 1 ] ;\n"
                ],
                [
                    89,
                    " stops [ count ] = stops [ count - 1 ] ;\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "static int xps_parse_gradient_stops ( xps_document * doc , char * base_uri , fz_xml * node , struct stop * stops , int maxcount ) {\n"
                ],
                [
                    10,
                    " while ( node && count < maxcount ) {\n"
                ],
                [
                    11,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"GradientStop\" ) ) {\n"
                ],
                [
                    12,
                    " char * offset = fz_xml_att ( node , \"Offset\" ) ;\n"
                ],
                [
                    13,
                    " char * color = fz_xml_att ( node , \"Color\" ) ;\n"
                ],
                [
                    14,
                    " if ( offset && color ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int xps_parse_gradient_stops ( xps_document * doc , char * base_uri , fz_xml * node , struct stop * stops , int maxcount ) {\n"
                ],
                [
                    10,
                    " while ( node && count < maxcount ) {\n"
                ],
                [
                    11,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"GradientStop\" ) ) {\n"
                ],
                [
                    12,
                    " char * offset = fz_xml_att ( node , \"Offset\" ) ;\n"
                ],
                [
                    13,
                    " char * color = fz_xml_att ( node , \"Color\" ) ;\n"
                ],
                [
                    14,
                    " if ( offset && color ) {\n"
                ],
                [
                    43,
                    " qsort ( stops , count , sizeof ( struct stop ) , cmp_stop ) ;\n"
                ],
                [
                    55,
                    " if ( before > 0 ) {\n"
                ],
                [
                    56,
                    " memmove ( stops , stops + before , ( count - before ) * sizeof ( struct stop ) ) ;\n"
                ],
                [
                    61,
                    " stops [ 1 ] = stops [ 0 ] ;\n"
                ],
                [
                    82,
                    " if ( stops [ 0 ] . offset > 0 ) {\n"
                ],
                [
                    83,
                    " memmove ( stops + 1 , stops , count * sizeof ( struct stop ) ) ;\n"
                ],
                [
                    84,
                    " stops [ 0 ] = stops [ 1 ] ;\n"
                ],
                [
                    89,
                    " stops [ count ] = stops [ count - 1 ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "void xps_parse_path ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n fz_xml * node ;\n char * fill_uri ;\n char * stroke_uri ;\n char * opacity_mask_uri ;\n char * transform_att ;\n char * clip_att ;\n char * data_att ;\n char * fill_att ;\n char * stroke_att ;\n char * opacity_att ;\n char * opacity_mask_att ;\n fz_xml * transform_tag = NULL ;\n fz_xml * clip_tag = NULL ;\n fz_xml * data_tag = NULL ;\n fz_xml * fill_tag = NULL ;\n fz_xml * stroke_tag = NULL ;\n fz_xml * opacity_mask_tag = NULL ;\n char * fill_opacity_att = NULL ;\n char * stroke_opacity_att = NULL ;\n char * stroke_dash_array_att ;\n char * stroke_dash_cap_att ;\n char * stroke_dash_offset_att ;\n char * stroke_end_line_cap_att ;\n char * stroke_start_line_cap_att ;\n char * stroke_line_join_att ;\n char * stroke_miter_limit_att ;\n char * stroke_thickness_att ;\n char * navigate_uri_att ;\n fz_stroke_state * stroke = NULL ;\n fz_matrix transform ;\n float samples [ 32 ] ;\n fz_colorspace * colorspace ;\n fz_path * path = NULL ;\n fz_path * stroke_path = NULL ;\n fz_rect area ;\n int fill_rule ;\n int dash_len = 0 ;\n fz_matrix local_ctm ;\n transform_att = fz_xml_att ( root , \"RenderTransform\" ) ;\n clip_att = fz_xml_att ( root , \"Clip\" ) ;\n data_att = fz_xml_att ( root , \"Data\" ) ;\n fill_att = fz_xml_att ( root , \"Fill\" ) ;\n stroke_att = fz_xml_att ( root , \"Stroke\" ) ;\n opacity_att = fz_xml_att ( root , \"Opacity\" ) ;\n opacity_mask_att = fz_xml_att ( root , \"OpacityMask\" ) ;\n stroke_dash_array_att = fz_xml_att ( root , \"StrokeDashArray\" ) ;\n stroke_dash_cap_att = fz_xml_att ( root , \"StrokeDashCap\" ) ;\n stroke_dash_offset_att = fz_xml_att ( root , \"StrokeDashOffset\" ) ;\n stroke_end_line_cap_att = fz_xml_att ( root , \"StrokeEndLineCap\" ) ;\n stroke_start_line_cap_att = fz_xml_att ( root , \"StrokeStartLineCap\" ) ;\n stroke_line_join_att = fz_xml_att ( root , \"StrokeLineJoin\" ) ;\n stroke_miter_limit_att = fz_xml_att ( root , \"StrokeMiterLimit\" ) ;\n stroke_thickness_att = fz_xml_att ( root , \"StrokeThickness\" ) ;\n navigate_uri_att = fz_xml_att ( root , \"FixedPage.NavigateUri\" ) ;\n for ( node = fz_xml_down ( root ) ;\n node ;\n node = fz_xml_next ( node ) ) {\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.RenderTransform\" ) ) transform_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.OpacityMask\" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Clip\" ) ) clip_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Fill\" ) ) fill_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Stroke\" ) ) stroke_tag = fz_xml_down ( node ) ;\n if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Data\" ) ) data_tag = fz_xml_down ( node ) ;\n }\n fill_uri = base_uri ;\n stroke_uri = base_uri ;\n opacity_mask_uri = base_uri ;\n xps_resolve_resource_reference ( doc , dict , & data_att , & data_tag , NULL ) ;\n xps_resolve_resource_reference ( doc , dict , & clip_att , & clip_tag , NULL ) ;\n xps_resolve_resource_reference ( doc , dict , & transform_att , & transform_tag , NULL ) ;\n xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n xps_resolve_resource_reference ( doc , dict , & stroke_att , & stroke_tag , & stroke_uri ) ;\n xps_resolve_resource_reference ( doc , dict , & opacity_mask_att , & opacity_mask_tag , & opacity_mask_uri ) ;\n if ( ! data_att && ! data_tag ) return ;\n if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , \"SolidColorBrush\" ) ) {\n fill_opacity_att = fz_xml_att ( fill_tag , \"Opacity\" ) ;\n fill_att = fz_xml_att ( fill_tag , \"Color\" ) ;\n fill_tag = NULL ;\n }\n if ( stroke_tag && ! strcmp ( fz_xml_tag ( stroke_tag ) , \"SolidColorBrush\" ) ) {\n stroke_opacity_att = fz_xml_att ( stroke_tag , \"Opacity\" ) ;\n stroke_att = fz_xml_att ( stroke_tag , \"Color\" ) ;\n stroke_tag = NULL ;\n }\n if ( stroke_att || stroke_tag ) {\n if ( stroke_dash_array_att ) {\n char * s = stroke_dash_array_att ;\n while ( * s ) {\n while ( * s == ' ' ) s ++ ;\n if ( * s ) dash_len ++ ;\n while ( * s && * s != ' ' ) s ++ ;\n }\n }\n stroke = fz_new_stroke_state_with_dash_len ( doc -> ctx , dash_len ) ;\n stroke -> start_cap = xps_parse_line_cap ( stroke_start_line_cap_att ) ;\n stroke -> dash_cap = xps_parse_line_cap ( stroke_dash_cap_att ) ;\n stroke -> end_cap = xps_parse_line_cap ( stroke_end_line_cap_att ) ;\n stroke -> linejoin = FZ_LINEJOIN_MITER_XPS ;\n if ( stroke_line_join_att ) {\n if ( ! strcmp ( stroke_line_join_att , \"Miter\" ) ) stroke -> linejoin = FZ_LINEJOIN_MITER_XPS ;\n if ( ! strcmp ( stroke_line_join_att , \"Round\" ) ) stroke -> linejoin = FZ_LINEJOIN_ROUND ;\n if ( ! strcmp ( stroke_line_join_att , \"Bevel\" ) ) stroke -> linejoin = FZ_LINEJOIN_BEVEL ;\n }\n stroke -> miterlimit = 10 ;\n if ( stroke_miter_limit_att ) stroke -> miterlimit = fz_atof ( stroke_miter_limit_att ) ;\n stroke -> linewidth = 1 ;\n if ( stroke_thickness_att ) stroke -> linewidth = fz_atof ( stroke_thickness_att ) ;\n stroke -> dash_phase = 0 ;\n stroke -> dash_len = 0 ;\n if ( stroke_dash_array_att ) {\n char * s = stroke_dash_array_att ;\n if ( stroke_dash_offset_att ) stroke -> dash_phase = fz_atof ( stroke_dash_offset_att ) * stroke -> linewidth ;\n while ( * s ) {\n while ( * s == ' ' ) s ++ ;\n if ( * s ) stroke -> dash_list [ stroke -> dash_len ++ ] = fz_atof ( s ) * stroke -> linewidth ;\n while ( * s && * s != ' ' ) s ++ ;\n }\n stroke -> dash_len = dash_len ;\n }\n }\n transform = fz_identity ;\n if ( transform_att ) xps_parse_render_transform ( doc , transform_att , & transform ) ;\n if ( transform_tag ) xps_parse_matrix_transform ( doc , transform_tag , & transform ) ;\n fz_concat ( & local_ctm , & transform , ctm ) ;\n if ( clip_att || clip_tag ) xps_clip ( doc , & local_ctm , dict , clip_att , clip_tag ) ;\n fill_rule = 0 ;\n if ( data_att ) path = xps_parse_abbreviated_geometry ( doc , data_att , & fill_rule ) ;\n else if ( data_tag ) {\n path = xps_parse_path_geometry ( doc , dict , data_tag , 0 , & fill_rule ) ;\n if ( stroke_att || stroke_tag ) stroke_path = xps_parse_path_geometry ( doc , dict , data_tag , 1 , & fill_rule ) ;\n }\n if ( ! stroke_path ) stroke_path = path ;\n if ( stroke_att || stroke_tag ) {\n fz_bound_path ( doc -> ctx , stroke_path , stroke , & local_ctm , & area ) ;\n if ( stroke_path != path && ( fill_att || fill_tag ) ) {\n fz_rect bounds ;\n fz_bound_path ( doc -> ctx , path , NULL , & local_ctm , & bounds ) ;\n fz_union_rect ( & area , & bounds ) ;\n }\n }\n else fz_bound_path ( doc -> ctx , path , NULL , & local_ctm , & area ) ;\n if ( navigate_uri_att ) xps_add_link ( doc , & area , base_uri , navigate_uri_att ) ;\n xps_begin_opacity ( doc , & local_ctm , & area , opacity_mask_uri , dict , opacity_att , opacity_mask_tag ) ;\n if ( fill_att ) {\n xps_parse_color ( doc , base_uri , fill_att , & colorspace , samples ) ;\n if ( fill_opacity_att ) samples [ 0 ] *= fz_atof ( fill_opacity_att ) ;\n xps_set_color ( doc , colorspace , samples ) ;\n fz_fill_path ( doc -> dev , path , fill_rule == 0 , & local_ctm , doc -> colorspace , doc -> color , doc -> alpha ) ;\n }\n if ( fill_tag ) {\n fz_clip_path ( doc -> dev , path , & area , fill_rule == 0 , & local_ctm ) ;\n xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;\n fz_pop_clip ( doc -> dev ) ;\n }\n if ( stroke_att ) {\n xps_parse_color ( doc , base_uri , stroke_att , & colorspace , samples ) ;\n if ( stroke_opacity_att ) samples [ 0 ] *= fz_atof ( stroke_opacity_att ) ;\n xps_set_color ( doc , colorspace , samples ) ;\n fz_stroke_path ( doc -> dev , stroke_path , stroke , & local_ctm , doc -> colorspace , doc -> color , doc -> alpha ) ;\n }\n if ( stroke_tag ) {\n fz_clip_stroke_path ( doc -> dev , stroke_path , & area , stroke , & local_ctm ) ;\n xps_parse_brush ( doc , & local_ctm , & area , stroke_uri , dict , stroke_tag ) ;\n fz_pop_clip ( doc -> dev ) ;\n }\n xps_end_opacity ( doc , opacity_mask_uri , dict , opacity_att , opacity_mask_tag ) ;\n if ( stroke_path != path ) fz_free_path ( doc -> ctx , stroke_path ) ;\n fz_free_path ( doc -> ctx , path ) ;\n path = NULL ;\n fz_drop_stroke_state ( doc -> ctx , stroke ) ;\n if ( clip_att || clip_tag ) fz_pop_clip ( doc -> dev ) ;\n }",
        "hash": -5927738579069082820,
        "project": "debian",
        "size": 173,
        "slice": {
            "strcmp": [
                [
                    1,
                    "void xps_parse_path ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n"
                ],
                [
                    16,
                    " fz_xml * fill_tag = NULL ;\n"
                ],
                [
                    17,
                    " fz_xml * stroke_tag = NULL ;\n"
                ],
                [
                    52,
                    " stroke_line_join_att = fz_xml_att ( root , \"StrokeLineJoin\" ) ;\n"
                ],
                [
                    57,
                    " node ;\n"
                ],
                [
                    59,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.RenderTransform\" ) ) transform_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    60,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.OpacityMask\" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    61,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Clip\" ) ) clip_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    62,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Fill\" ) ) fill_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    63,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Stroke\" ) ) stroke_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    64,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Data\" ) ) data_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    72,
                    " xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n"
                ],
                [
                    73,
                    " xps_resolve_resource_reference ( doc , dict , & stroke_att , & stroke_tag , & stroke_uri ) ;\n"
                ],
                [
                    75,
                    " if ( ! data_att && ! data_tag ) return ;\n"
                ],
                [
                    76,
                    " if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , \"SolidColorBrush\" ) ) {\n"
                ],
                [
                    77,
                    " fill_opacity_att = fz_xml_att ( fill_tag , \"Opacity\" ) ;\n"
                ],
                [
                    78,
                    " fill_att = fz_xml_att ( fill_tag , \"Color\" ) ;\n"
                ],
                [
                    79,
                    " fill_tag = NULL ;\n"
                ],
                [
                    81,
                    " if ( stroke_tag && ! strcmp ( fz_xml_tag ( stroke_tag ) , \"SolidColorBrush\" ) ) {\n"
                ],
                [
                    82,
                    " stroke_opacity_att = fz_xml_att ( stroke_tag , \"Opacity\" ) ;\n"
                ],
                [
                    83,
                    " stroke_att = fz_xml_att ( stroke_tag , \"Color\" ) ;\n"
                ],
                [
                    84,
                    " stroke_tag = NULL ;\n"
                ],
                [
                    86,
                    " if ( stroke_att || stroke_tag ) {\n"
                ],
                [
                    100,
                    " if ( stroke_line_join_att ) {\n"
                ],
                [
                    101,
                    " if ( ! strcmp ( stroke_line_join_att , \"Miter\" ) ) stroke -> linejoin = FZ_LINEJOIN_MITER_XPS ;\n"
                ],
                [
                    102,
                    " if ( ! strcmp ( stroke_line_join_att , \"Round\" ) ) stroke -> linejoin = FZ_LINEJOIN_ROUND ;\n"
                ],
                [
                    103,
                    " if ( ! strcmp ( stroke_line_join_att , \"Bevel\" ) ) stroke -> linejoin = FZ_LINEJOIN_BEVEL ;\n"
                ],
                [
                    136,
                    " if ( stroke_path != path && ( fill_att || fill_tag ) ) {\n"
                ],
                [
                    153,
                    " xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void xps_parse_path ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n"
                ],
                [
                    16,
                    " fz_xml * fill_tag = NULL ;\n"
                ],
                [
                    17,
                    " fz_xml * stroke_tag = NULL ;\n"
                ],
                [
                    52,
                    " stroke_line_join_att = fz_xml_att ( root , \"StrokeLineJoin\" ) ;\n"
                ],
                [
                    57,
                    " node ;\n"
                ],
                [
                    59,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.RenderTransform\" ) ) transform_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    60,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.OpacityMask\" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    61,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Clip\" ) ) clip_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    62,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Fill\" ) ) fill_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    63,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Stroke\" ) ) stroke_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    64,
                    " if ( ! strcmp ( fz_xml_tag ( node ) , \"Path.Data\" ) ) data_tag = fz_xml_down ( node ) ;\n"
                ],
                [
                    72,
                    " xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n"
                ],
                [
                    73,
                    " xps_resolve_resource_reference ( doc , dict , & stroke_att , & stroke_tag , & stroke_uri ) ;\n"
                ],
                [
                    75,
                    " if ( ! data_att && ! data_tag ) return ;\n"
                ],
                [
                    76,
                    " if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , \"SolidColorBrush\" ) ) {\n"
                ],
                [
                    77,
                    " fill_opacity_att = fz_xml_att ( fill_tag , \"Opacity\" ) ;\n"
                ],
                [
                    78,
                    " fill_att = fz_xml_att ( fill_tag , \"Color\" ) ;\n"
                ],
                [
                    79,
                    " fill_tag = NULL ;\n"
                ],
                [
                    81,
                    " if ( stroke_tag && ! strcmp ( fz_xml_tag ( stroke_tag ) , \"SolidColorBrush\" ) ) {\n"
                ],
                [
                    82,
                    " stroke_opacity_att = fz_xml_att ( stroke_tag , \"Opacity\" ) ;\n"
                ],
                [
                    83,
                    " stroke_att = fz_xml_att ( stroke_tag , \"Color\" ) ;\n"
                ],
                [
                    84,
                    " stroke_tag = NULL ;\n"
                ],
                [
                    86,
                    " if ( stroke_att || stroke_tag ) {\n"
                ],
                [
                    100,
                    " if ( stroke_line_join_att ) {\n"
                ],
                [
                    101,
                    " if ( ! strcmp ( stroke_line_join_att , \"Miter\" ) ) stroke -> linejoin = FZ_LINEJOIN_MITER_XPS ;\n"
                ],
                [
                    102,
                    " if ( ! strcmp ( stroke_line_join_att , \"Round\" ) ) stroke -> linejoin = FZ_LINEJOIN_ROUND ;\n"
                ],
                [
                    103,
                    " if ( ! strcmp ( stroke_line_join_att , \"Bevel\" ) ) stroke -> linejoin = FZ_LINEJOIN_BEVEL ;\n"
                ],
                [
                    136,
                    " if ( stroke_path != path && ( fill_att || fill_tag ) ) {\n"
                ],
                [
                    153,
                    " xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "bool ans_key_h ( connection_t * c ) {\n char from_name [ MAX_STRING_SIZE ] ;\n char to_name [ MAX_STRING_SIZE ] ;\n char key [ MAX_STRING_SIZE ] ;\n char address [ MAX_STRING_SIZE ] = \"\" ;\n char port [ MAX_STRING_SIZE ] = \"\" ;\n int cipher , digest , maclength , compression ;\n node_t * from , * to ;\n if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING \" \" MAX_STRING \" \" MAX_STRING \" %d %d %d %d \" MAX_STRING \" \" MAX_STRING , from_name , to_name , key , & cipher , & digest , & maclength , & compression , address , port ) < 7 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"ANS_KEY\" , c -> name , c -> hostname ) ;\n return false ;\n }\n if ( ! check_id ( from_name ) || ! check_id ( to_name ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s): %s\" , \"ANS_KEY\" , c -> name , c -> hostname , \"invalid name\" ) ;\n return false ;\n }\n from = lookup_node ( from_name ) ;\n if ( ! from ) {\n logger ( LOG_ERR , \"Got %s from %s (%s) origin %s which does not exist in our connection list\" , \"ANS_KEY\" , c -> name , c -> hostname , from_name ) ;\n return true ;\n }\n to = lookup_node ( to_name ) ;\n if ( ! to ) {\n logger ( LOG_ERR , \"Got %s from %s (%s) destination %s which does not exist in our connection list\" , \"ANS_KEY\" , c -> name , c -> hostname , to_name ) ;\n return true ;\n }\n if ( to != myself ) {\n if ( tunnelserver ) {\n return true ;\n }\n if ( ! to -> status . reachable ) {\n logger ( LOG_WARNING , \"Got %s from %s (%s) destination %s which is not reachable\" , \"ANS_KEY\" , c -> name , c -> hostname , to_name ) ;\n return true ;\n }\n if ( ! * address && from -> address . sa . sa_family != AF_UNSPEC && to -> minmtu ) {\n char * address , * port ;\n ifdebug ( PROTOCOL ) logger ( LOG_DEBUG , \"Appending reflexive UDP address to ANS_KEY from %s to %s\" , from -> name , to -> name ) ;\n sockaddr2str ( & from -> address , & address , & port ) ;\n send_request ( to -> nexthop -> connection , \"%s %s %s\" , c -> buffer , address , port ) ;\n free ( address ) ;\n free ( port ) ;\n return true ;\n }\n return send_request ( to -> nexthop -> connection , \"%s\" , c -> buffer ) ;\n }\n from -> status . validkey = false ;\n from -> outkey = xrealloc ( from -> outkey , strlen ( key ) / 2 ) ;\n from -> outkeylength = strlen ( key ) / 2 ;\n if ( ! hex2bin ( key , from -> outkey , from -> outkeylength ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s(%s): %s\" , \"ANS_KEY\" , from -> name , from -> hostname , \"invalid key\" ) ;\n return true ;\n }\n if ( cipher ) {\n from -> outcipher = EVP_get_cipherbynid ( cipher ) ;\n if ( ! from -> outcipher ) {\n logger ( LOG_ERR , \"Node %s (%s) uses unknown cipher!\" , from -> name , from -> hostname ) ;\n return true ;\n }\n if ( from -> outkeylength != EVP_CIPHER_key_length ( from -> outcipher ) + EVP_CIPHER_iv_length ( from -> outcipher ) ) {\n logger ( LOG_ERR , \"Node %s (%s) uses wrong keylength!\" , from -> name , from -> hostname ) ;\n return true ;\n }\n }\n else {\n from -> outcipher = NULL ;\n }\n from -> outmaclength = maclength ;\n if ( digest ) {\n from -> outdigest = EVP_get_digestbynid ( digest ) ;\n if ( ! from -> outdigest ) {\n logger ( LOG_ERR , \"Node %s (%s) uses unknown digest!\" , from -> name , from -> hostname ) ;\n return true ;\n }\n if ( from -> outmaclength > EVP_MD_size ( from -> outdigest ) || from -> outmaclength < 0 ) {\n logger ( LOG_ERR , \"Node %s (%s) uses bogus MAC length!\" , from -> name , from -> hostname ) ;\n return true ;\n }\n }\n else {\n from -> outdigest = NULL ;\n }\n if ( compression < 0 || compression > 11 ) {\n logger ( LOG_ERR , \"Node %s (%s) uses bogus compression level!\" , from -> name , from -> hostname ) ;\n return true ;\n }\n from -> outcompression = compression ;\n if ( from -> outcipher ) if ( ! EVP_EncryptInit_ex ( from -> outctx , from -> outcipher , NULL , ( unsigned char * ) from -> outkey , ( unsigned char * ) from -> outkey + EVP_CIPHER_key_length ( from -> outcipher ) ) ) {\n logger ( LOG_ERR , \"Error during initialisation of key from %s (%s): %s\" , from -> name , from -> hostname , ERR_error_string ( ERR_get_error ( ) , NULL ) ) ;\n return true ;\n }\n from -> status . validkey = true ;\n from -> sent_seqno = 0 ;\n if ( * address && * port ) {\n ifdebug ( PROTOCOL ) logger ( LOG_DEBUG , \"Using reflexive UDP address from %s: %s port %s\" , from -> name , address , port ) ;\n sockaddr_t sa = str2sockaddr ( address , port ) ;\n update_node_udp ( from , & sa ) ;\n }\n if ( from -> options & OPTION_PMTU_DISCOVERY && ! from -> mtuevent ) {\n send_mtu_probe ( from ) ;\n }\n return true ;\n }",
        "hash": -8531860357798072773,
        "project": "debian",
        "size": 102,
        "slice": {
            "strlen": [
                [
                    1,
                    "bool ans_key_h ( connection_t * c ) {\n"
                ],
                [
                    4,
                    " char key [ MAX_STRING_SIZE ] ;\n"
                ],
                [
                    18,
                    " if ( ! from ) {\n"
                ],
                [
                    27,
                    " if ( to != myself ) {\n"
                ],
                [
                    47,
                    " from -> outkey = xrealloc ( from -> outkey , strlen ( key ) / 2 ) ;\n"
                ],
                [
                    48,
                    " from -> outkeylength = strlen ( key ) / 2 ;\n"
                ],
                [
                    49,
                    " if ( ! hex2bin ( key , from -> outkey , from -> outkeylength ) ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "bool ans_key_h ( connection_t * c ) {\n"
                ],
                [
                    35,
                    " if ( ! * address && from -> address . sa . sa_family != AF_UNSPEC && to -> minmtu ) {\n"
                ],
                [
                    38,
                    " sockaddr2str ( & from -> address , & address , & port ) ;\n"
                ],
                [
                    39,
                    " send_request ( to -> nexthop -> connection , \"%s %s %s\" , c -> buffer , address , port ) ;\n"
                ],
                [
                    40,
                    " free ( address ) ;\n"
                ],
                [
                    41,
                    " free ( port ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "bool ans_key_h ( connection_t * c ) {\n"
                ],
                [
                    4,
                    " char key [ MAX_STRING_SIZE ] ;\n"
                ],
                [
                    18,
                    " if ( ! from ) {\n"
                ],
                [
                    27,
                    " if ( to != myself ) {\n"
                ],
                [
                    35,
                    " if ( ! * address && from -> address . sa . sa_family != AF_UNSPEC && to -> minmtu ) {\n"
                ],
                [
                    38,
                    " sockaddr2str ( & from -> address , & address , & port ) ;\n"
                ],
                [
                    39,
                    " send_request ( to -> nexthop -> connection , \"%s %s %s\" , c -> buffer , address , port ) ;\n"
                ],
                [
                    40,
                    " free ( address ) ;\n"
                ],
                [
                    41,
                    " free ( port ) ;\n"
                ],
                [
                    47,
                    " from -> outkey = xrealloc ( from -> outkey , strlen ( key ) / 2 ) ;\n"
                ],
                [
                    48,
                    " from -> outkeylength = strlen ( key ) / 2 ;\n"
                ],
                [
                    49,
                    " if ( ! hex2bin ( key , from -> outkey , from -> outkeylength ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret = 0 , buf_size = avpkt -> size ;\n CinepakContext * s = avctx -> priv_data ;\n s -> data = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( s -> palette_video ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n }\n cinepak_decode ( s ) ;\n if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": 6105314356608381376,
        "project": "debian",
        "size": 25,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " CinepakContext * s = avctx -> priv_data ;\n"
                ],
                [
                    14,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    15,
                    " if ( pal ) {\n"
                ],
                [
                    17,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    20,
                    " cinepak_decode ( s ) ;\n"
                ],
                [
                    21,
                    " if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " CinepakContext * s = avctx -> priv_data ;\n"
                ],
                [
                    14,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    15,
                    " if ( pal ) {\n"
                ],
                [
                    17,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    20,
                    " cinepak_decode ( s ) ;\n"
                ],
                [
                    21,
                    " if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n JvContext * s = avctx -> priv_data ;\n int buf_size = avpkt -> size ;\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = buf + buf_size ;\n int video_size , video_type , i , j ;\n video_size = AV_RL32 ( buf ) ;\n video_type = buf [ 4 ] ;\n buf += 5 ;\n if ( video_size ) {\n if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n if ( video_type == 0 || video_type == 1 ) {\n GetBitContext gb ;\n init_get_bits ( & gb , buf , 8 * FFMIN ( video_size , buf_end - buf ) ) ;\n for ( j = 0 ;\n j < avctx -> height ;\n j += 8 ) for ( i = 0 ;\n i < avctx -> width ;\n i += 8 ) decode8x8 ( & gb , s -> frame . data [ 0 ] + j * s -> frame . linesize [ 0 ] + i , s -> frame . linesize [ 0 ] , & s -> dsp ) ;\n buf += video_size ;\n }\n else if ( video_type == 2 ) {\n if ( buf + 1 <= buf_end ) {\n int v = * buf ++ ;\n for ( j = 0 ;\n j < avctx -> height ;\n j ++ ) memset ( s -> frame . data [ 0 ] + j * s -> frame . linesize [ 0 ] , v , avctx -> width ) ;\n }\n }\n else {\n av_log ( avctx , AV_LOG_WARNING , \"unsupported frame type %i\\n\" , video_type ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n if ( buf < buf_end ) {\n for ( i = 0 ;\n i < AVPALETTE_COUNT && buf + 3 <= buf_end ;\n i ++ ) {\n s -> palette [ i ] = AV_RB24 ( buf ) << 2 ;\n buf += 3 ;\n }\n s -> palette_has_changed = 1 ;\n }\n if ( video_size ) {\n s -> frame . key_frame = 1 ;\n s -> frame . pict_type = AV_PICTURE_TYPE_I ;\n s -> frame . palette_has_changed = s -> palette_has_changed ;\n s -> palette_has_changed = 0 ;\n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n }\n return buf_size ;\n }",
        "hash": 9040629826477849200,
        "project": "debian",
        "size": 57,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " JvContext * s = avctx -> priv_data ;\n"
                ],
                [
                    42,
                    " s -> palette [ i ] = AV_RB24 ( buf ) << 2 ;\n"
                ],
                [
                    47,
                    " if ( video_size ) {\n"
                ],
                [
                    52,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    11,
                    " if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 ) {\n"
                ],
                [
                    27,
                    " int v = * buf ++ ;\n"
                ],
                [
                    29,
                    " j < avctx -> height ;\n"
                ],
                [
                    30,
                    " j ++ ) memset ( s -> frame . data [ 0 ] + j * s -> frame . linesize [ 0 ] , v , avctx -> width ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " JvContext * s = avctx -> priv_data ;\n"
                ],
                [
                    11,
                    " if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 ) {\n"
                ],
                [
                    27,
                    " int v = * buf ++ ;\n"
                ],
                [
                    29,
                    " j < avctx -> height ;\n"
                ],
                [
                    30,
                    " j ++ ) memset ( s -> frame . data [ 0 ] + j * s -> frame . linesize [ 0 ] , v , avctx -> width ) ;\n"
                ],
                [
                    42,
                    " s -> palette [ i ] = AV_RB24 ( buf ) << 2 ;\n"
                ],
                [
                    47,
                    " if ( video_size ) {\n"
                ],
                [
                    52,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n TargaContext * const s = avctx -> priv_data ;\n AVFrame * picture = data ;\n AVFrame * const p = & s -> picture ;\n uint8_t * dst ;\n int stride ;\n int idlen , compr , y , w , h , bpp , flags , ret ;\n int first_clr , colors , csize ;\n bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ;\n idlen = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 1 ) ;\n compr = bytestream2_get_byte ( & s -> gb ) ;\n first_clr = bytestream2_get_le16 ( & s -> gb ) ;\n colors = bytestream2_get_le16 ( & s -> gb ) ;\n csize = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 4 ) ;\n w = bytestream2_get_le16 ( & s -> gb ) ;\n h = bytestream2_get_le16 ( & s -> gb ) ;\n bpp = bytestream2_get_byte ( & s -> gb ) ;\n flags = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , idlen ) ;\n switch ( bpp ) {\n case 8 : avctx -> pix_fmt = ( ( compr & ( ~ TGA_RLE ) ) == TGA_BW ) ? AV_PIX_FMT_GRAY8 : AV_PIX_FMT_PAL8 ;\n break ;\n case 15 : avctx -> pix_fmt = AV_PIX_FMT_RGB555LE ;\n break ;\n case 16 : avctx -> pix_fmt = AV_PIX_FMT_RGB555LE ;\n break ;\n case 24 : avctx -> pix_fmt = AV_PIX_FMT_BGR24 ;\n break ;\n case 32 : avctx -> pix_fmt = AV_PIX_FMT_BGRA ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Bit depth %i is not supported\\n\" , bpp ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( s -> picture . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> picture ) ;\n if ( ( ret = av_image_check_size ( w , h , 0 , avctx ) ) < 0 ) return ret ;\n if ( w != avctx -> width || h != avctx -> height ) avcodec_set_dimensions ( avctx , w , h ) ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( flags & 0x20 ) {\n dst = p -> data [ 0 ] ;\n stride = p -> linesize [ 0 ] ;\n }\n else {\n dst = p -> data [ 0 ] + p -> linesize [ 0 ] * ( h - 1 ) ;\n stride = - p -> linesize [ 0 ] ;\n }\n if ( colors ) {\n int pal_size , pal_sample_size ;\n if ( ( colors + first_clr ) > 256 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Incorrect palette: %i colors with offset %i\\n\" , colors , first_clr ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( csize ) {\n case 24 : pal_sample_size = 3 ;\n break ;\n case 16 : case 15 : pal_sample_size = 2 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Palette entry size %i bits is not supported\\n\" , csize ) ;\n return AVERROR_INVALIDDATA ;\n }\n pal_size = colors * pal_sample_size ;\n if ( avctx -> pix_fmt != AV_PIX_FMT_PAL8 ) bytestream2_skip ( & s -> gb , pal_size ) ;\n else {\n int t ;\n uint32_t * pal = ( ( uint32_t * ) p -> data [ 1 ] ) + first_clr ;\n if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Not enough data to read palette\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( pal_sample_size ) {\n case 3 : for ( t = 0 ;\n t < colors ;\n t ++ ) * pal ++ = bytestream2_get_le24u ( & s -> gb ) ;\n break ;\n case 2 : for ( t = 0 ;\n t < colors ;\n t ++ ) {\n uint32_t v = bytestream2_get_le16u ( & s -> gb ) ;\n v = ( ( v & 0x7C00 ) << 9 ) | ( ( v & 0x03E0 ) << 6 ) | ( ( v & 0x001F ) << 3 ) ;\n v |= ( v & 0xE0E0E0U ) >> 5 ;\n * pal ++ = v ;\n }\n break ;\n }\n p -> palette_has_changed = 1 ;\n }\n }\n if ( ( compr & ( ~ TGA_RLE ) ) == TGA_NODATA ) {\n memset ( p -> data [ 0 ] , 0 , p -> linesize [ 0 ] * h ) ;\n }\n else {\n if ( compr & TGA_RLE ) {\n int res = targa_decode_rle ( avctx , s , dst , w , h , stride , bpp ) ;\n if ( res < 0 ) return res ;\n }\n else {\n size_t img_size = w * ( ( bpp + 1 ) >> 3 ) ;\n if ( bytestream2_get_bytes_left ( & s -> gb ) < img_size * h ) {\n av_log ( avctx , AV_LOG_ERROR , \"Not enough data available for image\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( y = 0 ;\n y < h ;\n y ++ ) {\n bytestream2_get_bufferu ( & s -> gb , dst , img_size ) ;\n dst += stride ;\n }\n }\n }\n * picture = s -> picture ;\n * got_frame = 1 ;\n return avpkt -> size ;\n }",
        "hash": 7690587584364497392,
        "project": "debian",
        "size": 117,
        "slice": {
            "memset": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    92,
                    " if ( ( compr & ( ~ TGA_RLE ) ) == TGA_NODATA ) {\n"
                ],
                [
                    93,
                    " memset ( p -> data [ 0 ] , 0 , p -> linesize [ 0 ] * h ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    92,
                    " if ( ( compr & ( ~ TGA_RLE ) ) == TGA_NODATA ) {\n"
                ],
                [
                    93,
                    " memset ( p -> data [ 0 ] , 0 , p -> linesize [ 0 ] * h ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int aasc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AascContext * s = avctx -> priv_data ;\n int compr , i , stride , ret ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n compr = AV_RL32 ( buf ) ;\n buf += 4 ;\n buf_size -= 4 ;\n switch ( compr ) {\n case 0 : stride = ( avctx -> width * 3 + 3 ) & ~ 3 ;\n for ( i = avctx -> height - 1 ;\n i >= 0 ;\n i -- ) {\n memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , buf , avctx -> width * 3 ) ;\n buf += stride ;\n }\n break ;\n case 1 : bytestream2_init ( & s -> gb , buf , buf_size ) ;\n ff_msrle_decode ( avctx , ( AVPicture * ) & s -> frame , 8 , & s -> gb ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unknown compression type %d\\n\" , compr ) ;\n return AVERROR_INVALIDDATA ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": 750873883941333769,
        "project": "debian",
        "size": 33,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int aasc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    13,
                    " buf += 4 ;\n"
                ],
                [
                    18,
                    " i >= 0 ;\n"
                ],
                [
                    20,
                    " memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , buf , avctx -> width * 3 ) ;\n"
                ],
                [
                    21,
                    " buf += stride ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int aasc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    13,
                    " buf += 4 ;\n"
                ],
                [
                    18,
                    " i >= 0 ;\n"
                ],
                [
                    20,
                    " memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , buf , avctx -> width * 3 ) ;\n"
                ],
                [
                    21,
                    " buf += stride ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int bethsoftvid_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n BethsoftvidContext * vid = avctx -> priv_data ;\n char block_type ;\n uint8_t * dst ;\n uint8_t * frame_end ;\n int remaining = avctx -> width ;\n int wrap_to_next_line ;\n int code , ret ;\n int yoffset ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & vid -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n wrap_to_next_line = vid -> frame . linesize [ 0 ] - avctx -> width ;\n if ( avpkt -> side_data_elems > 0 && avpkt -> side_data [ 0 ] . type == AV_PKT_DATA_PALETTE ) {\n bytestream2_init ( & vid -> g , avpkt -> side_data [ 0 ] . data , avpkt -> side_data [ 0 ] . size ) ;\n if ( ( ret = set_palette ( vid ) ) < 0 ) return ret ;\n }\n bytestream2_init ( & vid -> g , avpkt -> data , avpkt -> size ) ;\n dst = vid -> frame . data [ 0 ] ;\n frame_end = vid -> frame . data [ 0 ] + vid -> frame . linesize [ 0 ] * avctx -> height ;\n switch ( block_type = bytestream2_get_byte ( & vid -> g ) ) {\n case PALETTE_BLOCK : {\n * got_frame = 0 ;\n if ( ( ret = set_palette ( vid ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"error reading palette\\n\" ) ;\n return ret ;\n }\n return bytestream2_tell ( & vid -> g ) ;\n }\n case VIDEO_YOFF_P_FRAME : yoffset = bytestream2_get_le16 ( & vid -> g ) ;\n if ( yoffset >= avctx -> height ) return AVERROR_INVALIDDATA ;\n dst += vid -> frame . linesize [ 0 ] * yoffset ;\n }\n while ( ( code = bytestream2_get_byte ( & vid -> g ) ) ) {\n int length = code & 0x7f ;\n while ( length > remaining ) {\n if ( code < 0x80 ) bytestream2_get_buffer ( & vid -> g , dst , remaining ) ;\n else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_peek_byte ( & vid -> g ) , remaining ) ;\n length -= remaining ;\n dst += remaining + wrap_to_next_line ;\n remaining = avctx -> width ;\n if ( dst == frame_end ) goto end ;\n }\n if ( code < 0x80 ) bytestream2_get_buffer ( & vid -> g , dst , length ) ;\n else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_get_byte ( & vid -> g ) , length ) ;\n remaining -= length ;\n dst += length ;\n }\n end : * got_frame = 1 ;\n * ( AVFrame * ) data = vid -> frame ;\n return avpkt -> size ;\n }",
        "hash": 3700518084842137861,
        "project": "debian",
        "size": 53,
        "slice": {
            "memset": [
                [
                    1,
                    "static int bethsoftvid_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    20,
                    " dst = vid -> frame . data [ 0 ] ;\n"
                ],
                [
                    33,
                    " dst += vid -> frame . linesize [ 0 ] * yoffset ;\n"
                ],
                [
                    37,
                    " while ( length > remaining ) {\n"
                ],
                [
                    39,
                    " else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_peek_byte ( & vid -> g ) , remaining ) ;\n"
                ],
                [
                    40,
                    " length -= remaining ;\n"
                ],
                [
                    41,
                    " dst += remaining + wrap_to_next_line ;\n"
                ],
                [
                    43,
                    " if ( dst == frame_end ) goto end ;\n"
                ],
                [
                    46,
                    " else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_get_byte ( & vid -> g ) , length ) ;\n"
                ],
                [
                    47,
                    " remaining -= length ;\n"
                ],
                [
                    48,
                    " dst += length ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int bethsoftvid_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    20,
                    " dst = vid -> frame . data [ 0 ] ;\n"
                ],
                [
                    33,
                    " dst += vid -> frame . linesize [ 0 ] * yoffset ;\n"
                ],
                [
                    37,
                    " while ( length > remaining ) {\n"
                ],
                [
                    39,
                    " else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_peek_byte ( & vid -> g ) , remaining ) ;\n"
                ],
                [
                    40,
                    " length -= remaining ;\n"
                ],
                [
                    41,
                    " dst += remaining + wrap_to_next_line ;\n"
                ],
                [
                    43,
                    " if ( dst == frame_end ) goto end ;\n"
                ],
                [
                    46,
                    " else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_get_byte ( & vid -> g ) , length ) ;\n"
                ],
                [
                    47,
                    " remaining -= length ;\n"
                ],
                [
                    48,
                    " dst += length ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n NuvContext * c = avctx -> priv_data ;\n AVFrame * picture = data ;\n int orig_size = buf_size ;\n int keyframe ;\n int result , init_frame = ! avctx -> frame_number ;\n enum {\n NUV_UNCOMPRESSED = '0' , NUV_RTJPEG = '1' , NUV_RTJPEG_IN_LZO = '2' , NUV_LZO = '3' , NUV_BLACK = 'N' , NUV_COPY_LAST = 'L' }\n comptype ;\n if ( buf_size < 12 ) {\n av_log ( avctx , AV_LOG_ERROR , \"coded frame too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( buf [ 0 ] == 'D' && buf [ 1 ] == 'R' ) {\n int ret ;\n buf = & buf [ 12 ] ;\n buf_size -= 12 ;\n ret = get_quant ( avctx , c , buf , buf_size ) ;\n if ( ret < 0 ) return ret ;\n ff_rtjpeg_decode_init ( & c -> rtj , & c -> dsp , c -> width , c -> height , c -> lq , c -> cq ) ;\n return orig_size ;\n }\n if ( buf [ 0 ] != 'V' || buf_size < 12 ) {\n av_log ( avctx , AV_LOG_ERROR , \"not a nuv video frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n comptype = buf [ 1 ] ;\n switch ( comptype ) {\n case NUV_RTJPEG_IN_LZO : case NUV_RTJPEG : keyframe = ! buf [ 2 ] ;\n break ;\n case NUV_COPY_LAST : keyframe = 0 ;\n break ;\n default : keyframe = 1 ;\n break ;\n }\n buf = & buf [ 12 ] ;\n buf_size -= 12 ;\n if ( comptype == NUV_RTJPEG_IN_LZO || comptype == NUV_LZO ) {\n int outlen = c -> decomp_size , inlen = buf_size ;\n if ( av_lzo1x_decode ( c -> decomp_buf , & outlen , buf , & inlen ) ) av_log ( avctx , AV_LOG_ERROR , \"error during lzo decompression\\n\" ) ;\n buf = c -> decomp_buf ;\n buf_size = c -> decomp_size ;\n }\n if ( c -> codec_frameheader ) {\n int w , h , q ;\n if ( buf_size < RTJPEG_HEADER_SIZE || buf [ 4 ] != RTJPEG_HEADER_SIZE || buf [ 5 ] != RTJPEG_FILE_VERSION ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid nuv video frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n w = AV_RL16 ( & buf [ 6 ] ) ;\n h = AV_RL16 ( & buf [ 8 ] ) ;\n q = buf [ 10 ] ;\n if ( ( result = codec_reinit ( avctx , w , h , q ) ) < 0 ) return result ;\n buf = & buf [ RTJPEG_HEADER_SIZE ] ;\n buf_size -= RTJPEG_HEADER_SIZE ;\n }\n if ( keyframe && c -> pic . data [ 0 ] ) {\n avctx -> release_buffer ( avctx , & c -> pic ) ;\n init_frame = 1 ;\n }\n c -> pic . reference = 3 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_READABLE | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n result = avctx -> reget_buffer ( avctx , & c -> pic ) ;\n if ( result < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return result ;\n }\n if ( init_frame ) {\n memset ( c -> pic . data [ 0 ] , 0 , avctx -> height * c -> pic . linesize [ 0 ] ) ;\n memset ( c -> pic . data [ 1 ] , 0x80 , avctx -> height * c -> pic . linesize [ 1 ] / 2 ) ;\n memset ( c -> pic . data [ 2 ] , 0x80 , avctx -> height * c -> pic . linesize [ 2 ] / 2 ) ;\n }\n c -> pic . pict_type = keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ;\n c -> pic . key_frame = keyframe ;\n switch ( comptype ) {\n case NUV_LZO : case NUV_UNCOMPRESSED : {\n int height = c -> height ;\n if ( buf_size < c -> width * height * 3 / 2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"uncompressed frame too short\\n\" ) ;\n height = buf_size / c -> width / 3 * 2 ;\n }\n copy_frame ( & c -> pic , buf , c -> width , height ) ;\n break ;\n }\n case NUV_RTJPEG_IN_LZO : case NUV_RTJPEG : ff_rtjpeg_decode_frame_yuv420 ( & c -> rtj , & c -> pic , buf , buf_size ) ;\n break ;\n case NUV_BLACK : memset ( c -> pic . data [ 0 ] , 0 , c -> width * c -> height ) ;\n memset ( c -> pic . data [ 1 ] , 128 , c -> width * c -> height / 4 ) ;\n memset ( c -> pic . data [ 2 ] , 128 , c -> width * c -> height / 4 ) ;\n break ;\n case NUV_COPY_LAST : break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"unknown compression\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n * picture = c -> pic ;\n * got_frame = 1 ;\n return orig_size ;\n }",
        "hash": -2689671302666609204,
        "project": "debian",
        "size": 100,
        "slice": {
            "memset": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    59,
                    " if ( keyframe && c -> pic . data [ 0 ] ) {\n"
                ],
                [
                    70,
                    " if ( init_frame ) {\n"
                ],
                [
                    71,
                    " memset ( c -> pic . data [ 0 ] , 0 , avctx -> height * c -> pic . linesize [ 0 ] ) ;\n"
                ],
                [
                    72,
                    " memset ( c -> pic . data [ 1 ] , 0x80 , avctx -> height * c -> pic . linesize [ 1 ] / 2 ) ;\n"
                ],
                [
                    73,
                    " memset ( c -> pic . data [ 2 ] , 0x80 , avctx -> height * c -> pic . linesize [ 2 ] / 2 ) ;\n"
                ],
                [
                    77,
                    " switch ( comptype ) {\n"
                ],
                [
                    89,
                    " case NUV_BLACK : memset ( c -> pic . data [ 0 ] , 0 , c -> width * c -> height ) ;\n"
                ],
                [
                    90,
                    " memset ( c -> pic . data [ 1 ] , 128 , c -> width * c -> height / 4 ) ;\n"
                ],
                [
                    91,
                    " memset ( c -> pic . data [ 2 ] , 128 , c -> width * c -> height / 4 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    59,
                    " if ( keyframe && c -> pic . data [ 0 ] ) {\n"
                ],
                [
                    70,
                    " if ( init_frame ) {\n"
                ],
                [
                    71,
                    " memset ( c -> pic . data [ 0 ] , 0 , avctx -> height * c -> pic . linesize [ 0 ] ) ;\n"
                ],
                [
                    72,
                    " memset ( c -> pic . data [ 1 ] , 0x80 , avctx -> height * c -> pic . linesize [ 1 ] / 2 ) ;\n"
                ],
                [
                    73,
                    " memset ( c -> pic . data [ 2 ] , 0x80 , avctx -> height * c -> pic . linesize [ 2 ] / 2 ) ;\n"
                ],
                [
                    77,
                    " switch ( comptype ) {\n"
                ],
                [
                    89,
                    " case NUV_BLACK : memset ( c -> pic . data [ 0 ] , 0 , c -> width * c -> height ) ;\n"
                ],
                [
                    90,
                    " memset ( c -> pic . data [ 1 ] , 128 , c -> width * c -> height / 4 ) ;\n"
                ],
                [
                    91,
                    " memset ( c -> pic . data [ 2 ] , 128 , c -> width * c -> height / 4 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mpc7_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size ;\n MPCContext * c = avctx -> priv_data ;\n GetBitContext gb ;\n int i , ch ;\n int mb = - 1 ;\n Band * bands = c -> bands ;\n int off , ret , last_frame , skip ;\n int bits_used , bits_avail ;\n memset ( bands , 0 , sizeof ( * bands ) * ( c -> maxbands + 1 ) ) ;\n buf_size = avpkt -> size & ~ 3 ;\n if ( buf_size <= 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"packet size is too small (%i bytes)\\n\" , avpkt -> size ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( buf_size != avpkt -> size ) {\n av_log ( avctx , AV_LOG_WARNING , \"packet size is not a multiple of 4. \" \"extra bytes at the end will be skipped.\\n\" ) ;\n }\n skip = buf [ 0 ] ;\n last_frame = buf [ 1 ] ;\n buf += 4 ;\n buf_size -= 4 ;\n frame -> nb_samples = last_frame ? c -> lastframelen : MPC_FRAME_SIZE ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n av_fast_padded_malloc ( & c -> bits , & c -> buf_size , buf_size ) ;\n if ( ! c -> bits ) return AVERROR ( ENOMEM ) ;\n c -> dsp . bswap_buf ( ( uint32_t * ) c -> bits , ( const uint32_t * ) buf , buf_size >> 2 ) ;\n init_get_bits ( & gb , c -> bits , buf_size * 8 ) ;\n skip_bits_long ( & gb , skip ) ;\n for ( i = 0 ;\n i <= c -> maxbands ;\n i ++ ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n int t = 4 ;\n if ( i ) t = get_vlc2 ( & gb , hdr_vlc . table , MPC7_HDR_BITS , 1 ) - 5 ;\n if ( t == 4 ) bands [ i ] . res [ ch ] = get_bits ( & gb , 4 ) ;\n else bands [ i ] . res [ ch ] = av_clip ( bands [ i - 1 ] . res [ ch ] + t , 0 , 17 ) ;\n }\n if ( bands [ i ] . res [ 0 ] || bands [ i ] . res [ 1 ] ) {\n mb = i ;\n if ( c -> MSS ) bands [ i ] . msf = get_bits1 ( & gb ) ;\n }\n }\n for ( i = 0 ;\n i <= mb ;\n i ++ ) for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) if ( bands [ i ] . res [ ch ] ) bands [ i ] . scfi [ ch ] = get_vlc2 ( & gb , scfi_vlc . table , MPC7_SCFI_BITS , 1 ) ;\n for ( i = 0 ;\n i <= mb ;\n i ++ ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n if ( bands [ i ] . res [ ch ] ) {\n bands [ i ] . scf_idx [ ch ] [ 2 ] = c -> oldDSCF [ ch ] [ i ] ;\n bands [ i ] . scf_idx [ ch ] [ 0 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 2 ] ) ;\n switch ( bands [ i ] . scfi [ ch ] ) {\n case 0 : bands [ i ] . scf_idx [ ch ] [ 1 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 0 ] ) ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 1 ] ) ;\n break ;\n case 1 : bands [ i ] . scf_idx [ ch ] [ 1 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 0 ] ) ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = bands [ i ] . scf_idx [ ch ] [ 1 ] ;\n break ;\n case 2 : bands [ i ] . scf_idx [ ch ] [ 1 ] = bands [ i ] . scf_idx [ ch ] [ 0 ] ;\n bands [ i ] . scf_idx [ ch ] [ 2 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 1 ] ) ;\n break ;\n case 3 : bands [ i ] . scf_idx [ ch ] [ 2 ] = bands [ i ] . scf_idx [ ch ] [ 1 ] = bands [ i ] . scf_idx [ ch ] [ 0 ] ;\n break ;\n }\n c -> oldDSCF [ ch ] [ i ] = bands [ i ] . scf_idx [ ch ] [ 2 ] ;\n }\n }\n }\n memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n off = 0 ;\n for ( i = 0 ;\n i < BANDS ;\n i ++ , off += SAMPLES_PER_BAND ) for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) idx_to_quant ( c , & gb , bands [ i ] . res [ ch ] , c -> Q [ ch ] + off ) ;\n ff_mpc_dequantize_and_synth ( c , mb , ( int16_t * * ) frame -> extended_data , 2 ) ;\n bits_used = get_bits_count ( & gb ) ;\n bits_avail = buf_size * 8 ;\n if ( ! last_frame && ( ( bits_avail < bits_used ) || ( bits_used + 32 <= bits_avail ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding frame: used %i of %i bits\\n\" , bits_used , bits_avail ) ;\n return - 1 ;\n }\n if ( c -> frames_to_skip ) {\n c -> frames_to_skip -- ;\n * got_frame_ptr = 0 ;\n return avpkt -> size ;\n }\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }",
        "hash": -482717283558482293,
        "project": "debian",
        "size": 103,
        "slice": {
            "memset": [
                [
                    1,
                    "static int mpc7_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " MPCContext * c = avctx -> priv_data ;\n"
                ],
                [
                    9,
                    " Band * bands = c -> bands ;\n"
                ],
                [
                    12,
                    " memset ( bands , 0 , sizeof ( * bands ) * ( c -> maxbands + 1 ) ) ;\n"
                ],
                [
                    31,
                    " if ( ! c -> bits ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    82,
                    " memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n"
                ],
                [
                    88,
                    " ch ++ ) idx_to_quant ( c , & gb , bands [ i ] . res [ ch ] , c -> Q [ ch ] + off ) ;\n"
                ],
                [
                    89,
                    " ff_mpc_dequantize_and_synth ( c , mb , ( int16_t * * ) frame -> extended_data , 2 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mpc7_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " MPCContext * c = avctx -> priv_data ;\n"
                ],
                [
                    9,
                    " Band * bands = c -> bands ;\n"
                ],
                [
                    12,
                    " memset ( bands , 0 , sizeof ( * bands ) * ( c -> maxbands + 1 ) ) ;\n"
                ],
                [
                    31,
                    " if ( ! c -> bits ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    82,
                    " memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n"
                ],
                [
                    88,
                    " ch ++ ) idx_to_quant ( c , & gb , bands [ i ] . res [ ch ] , c -> Q [ ch ] + off ) ;\n"
                ],
                [
                    89,
                    " ff_mpc_dequantize_and_synth ( c , mb , ( int16_t * * ) frame -> extended_data , 2 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MotionPixelsContext * mp = avctx -> priv_data ;\n GetBitContext gb ;\n int i , count1 , count2 , sz ;\n mp -> frame . reference = 1 ;\n mp -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( avctx -> reget_buffer ( avctx , & mp -> frame ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n av_fast_malloc ( & mp -> bswapbuf , & mp -> bswapbuf_size , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! mp -> bswapbuf ) return AVERROR ( ENOMEM ) ;\n mp -> dsp . bswap_buf ( ( uint32_t * ) mp -> bswapbuf , ( const uint32_t * ) buf , buf_size / 4 ) ;\n if ( buf_size & 3 ) memcpy ( mp -> bswapbuf + ( buf_size & ~ 3 ) , buf + ( buf_size & ~ 3 ) , buf_size & 3 ) ;\n memset ( mp -> bswapbuf + buf_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n init_get_bits ( & gb , mp -> bswapbuf , buf_size * 8 ) ;\n memset ( mp -> changes_map , 0 , avctx -> width * avctx -> height ) ;\n for ( i = ! ( avctx -> extradata [ 1 ] & 2 ) ;\n i < 2 ;\n ++ i ) {\n count1 = get_bits ( & gb , 12 ) ;\n count2 = get_bits ( & gb , 12 ) ;\n mp_read_changes_map ( mp , & gb , count1 , 8 , i ) ;\n mp_read_changes_map ( mp , & gb , count2 , 4 , i ) ;\n }\n mp -> codes_count = get_bits ( & gb , 4 ) ;\n if ( mp -> codes_count == 0 ) goto end ;\n if ( mp -> changes_map [ 0 ] == 0 ) {\n * ( uint16_t * ) mp -> frame . data [ 0 ] = get_bits ( & gb , 15 ) ;\n mp -> changes_map [ 0 ] = 1 ;\n }\n mp_read_codes_table ( mp , & gb ) ;\n sz = get_bits ( & gb , 18 ) ;\n if ( avctx -> extradata [ 0 ] != 5 ) sz += get_bits ( & gb , 18 ) ;\n if ( sz == 0 ) goto end ;\n if ( mp -> max_codes_bits <= 0 ) goto end ;\n if ( init_vlc ( & mp -> vlc , mp -> max_codes_bits , mp -> codes_count , & mp -> codes [ 0 ] . size , sizeof ( HuffCode ) , 1 , & mp -> codes [ 0 ] . code , sizeof ( HuffCode ) , 4 , 0 ) ) goto end ;\n mp_decode_frame_helper ( mp , & gb ) ;\n ff_free_vlc ( & mp -> vlc ) ;\n end : * got_frame = 1 ;\n * ( AVFrame * ) data = mp -> frame ;\n return buf_size ;\n }",
        "hash": -1409980668468066833,
        "project": "debian",
        "size": 45,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int mp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    4,
                    " MotionPixelsContext * mp = avctx -> priv_data ;\n"
                ],
                [
                    13,
                    " av_fast_malloc ( & mp -> bswapbuf , & mp -> bswapbuf_size , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    14,
                    " if ( ! mp -> bswapbuf ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    16,
                    " if ( buf_size & 3 ) memcpy ( mp -> bswapbuf + ( buf_size & ~ 3 ) , buf + ( buf_size & ~ 3 ) , buf_size & 3 ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int mp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " MotionPixelsContext * mp = avctx -> priv_data ;\n"
                ],
                [
                    13,
                    " av_fast_malloc ( & mp -> bswapbuf , & mp -> bswapbuf_size , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    14,
                    " if ( ! mp -> bswapbuf ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    16,
                    " if ( buf_size & 3 ) memcpy ( mp -> bswapbuf + ( buf_size & ~ 3 ) , buf + ( buf_size & ~ 3 ) , buf_size & 3 ) ;\n"
                ],
                [
                    17,
                    " memset ( mp -> bswapbuf + buf_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    19,
                    " memset ( mp -> changes_map , 0 , avctx -> width * avctx -> height ) ;\n"
                ],
                [
                    25,
                    " mp_read_changes_map ( mp , & gb , count1 , 8 , i ) ;\n"
                ],
                [
                    26,
                    " mp_read_changes_map ( mp , & gb , count2 , 4 , i ) ;\n"
                ],
                [
                    34,
                    " mp_read_codes_table ( mp , & gb ) ;\n"
                ],
                [
                    40,
                    " mp_decode_frame_helper ( mp , & gb ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    4,
                    " MotionPixelsContext * mp = avctx -> priv_data ;\n"
                ],
                [
                    13,
                    " av_fast_malloc ( & mp -> bswapbuf , & mp -> bswapbuf_size , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    14,
                    " if ( ! mp -> bswapbuf ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    16,
                    " if ( buf_size & 3 ) memcpy ( mp -> bswapbuf + ( buf_size & ~ 3 ) , buf + ( buf_size & ~ 3 ) , buf_size & 3 ) ;\n"
                ],
                [
                    17,
                    " memset ( mp -> bswapbuf + buf_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    19,
                    " memset ( mp -> changes_map , 0 , avctx -> width * avctx -> height ) ;\n"
                ],
                [
                    25,
                    " mp_read_changes_map ( mp , & gb , count1 , 8 , i ) ;\n"
                ],
                [
                    26,
                    " mp_read_changes_map ( mp , & gb , count2 , 4 , i ) ;\n"
                ],
                [
                    34,
                    " mp_read_codes_table ( mp , & gb ) ;\n"
                ],
                [
                    40,
                    " mp_decode_frame_helper ( mp , & gb ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n EightBpsContext * const c = avctx -> priv_data ;\n const unsigned char * encoded = buf ;\n unsigned char * pixptr , * pixptr_end ;\n unsigned int height = avctx -> height ;\n unsigned int dlen , p , row ;\n const unsigned char * lp , * dp ;\n unsigned char count ;\n unsigned int px_inc ;\n unsigned int planes = c -> planes ;\n unsigned char * planemap = c -> planemap ;\n int ret ;\n if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n c -> pic . reference = 0 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID ;\n if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n dp = encoded + planes * ( height << 1 ) ;\n if ( planes == 4 ) planes -- ;\n px_inc = planes + ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 ) ;\n for ( p = 0 ;\n p < planes ;\n p ++ ) {\n lp = encoded + p * ( height << 1 ) ;\n for ( row = 0 ;\n row < height ;\n row ++ ) {\n pixptr = c -> pic . data [ 0 ] + row * c -> pic . linesize [ 0 ] + planemap [ p ] ;\n pixptr_end = pixptr + c -> pic . linesize [ 0 ] ;\n dlen = av_be2ne16 ( * ( const unsigned short * ) ( lp + row * 2 ) ) ;\n while ( dlen > 0 ) {\n if ( dp + 1 >= buf + buf_size ) return AVERROR_INVALIDDATA ;\n if ( ( count = * dp ++ ) <= 127 ) {\n count ++ ;\n dlen -= count + 1 ;\n if ( pixptr + count * px_inc > pixptr_end ) break ;\n if ( dp + count > buf + buf_size ) return AVERROR_INVALIDDATA ;\n while ( count -- ) {\n * pixptr = * dp ++ ;\n pixptr += px_inc ;\n }\n }\n else {\n count = 257 - count ;\n if ( pixptr + count * px_inc > pixptr_end ) break ;\n while ( count -- ) {\n * pixptr = * dp ;\n pixptr += px_inc ;\n }\n dp ++ ;\n dlen -= 2 ;\n }\n }\n }\n }\n if ( avctx -> bits_per_coded_sample <= 8 ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n c -> pic . palette_has_changed = 1 ;\n memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }",
        "hash": 7929795578708937566,
        "project": "debian",
        "size": 71,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " EightBpsContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    60,
                    " if ( avctx -> bits_per_coded_sample <= 8 ) {\n"
                ],
                [
                    61,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    62,
                    " if ( pal ) {\n"
                ],
                [
                    64,
                    " memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    66,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " EightBpsContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    60,
                    " if ( avctx -> bits_per_coded_sample <= 8 ) {\n"
                ],
                [
                    61,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    62,
                    " if ( pal ) {\n"
                ],
                [
                    64,
                    " memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    66,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int binkb_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_key , int is_chroma ) {\n int blk , ret ;\n int i , j , bx , by ;\n uint8_t * dst , * ref , * ref_start , * ref_end ;\n int v , col [ 2 ] ;\n const uint8_t * scan ;\n int xoff , yoff ;\n LOCAL_ALIGNED_16 ( int16_t , block , [ 64 ] ) ;\n LOCAL_ALIGNED_16 ( int32_t , dctblock , [ 64 ] ) ;\n int coordmap [ 64 ] ;\n int ybias = is_key ? - 15 : 0 ;\n int qp ;\n const int stride = c -> pic -> linesize [ plane_idx ] ;\n int bw = is_chroma ? ( c -> avctx -> width + 15 ) >> 4 : ( c -> avctx -> width + 7 ) >> 3 ;\n int bh = is_chroma ? ( c -> avctx -> height + 15 ) >> 4 : ( c -> avctx -> height + 7 ) >> 3 ;\n binkb_init_bundles ( c ) ;\n ref_start = c -> pic -> data [ plane_idx ] ;\n ref_end = c -> pic -> data [ plane_idx ] + ( bh * c -> pic -> linesize [ plane_idx ] + bw ) * 8 ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) coordmap [ i ] = ( i & 7 ) + ( i >> 3 ) * stride ;\n for ( by = 0 ;\n by < bh ;\n by ++ ) {\n for ( i = 0 ;\n i < BINKB_NB_SRC ;\n i ++ ) {\n if ( ( ret = binkb_read_bundle ( c , gb , i ) ) < 0 ) return ret ;\n }\n dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n for ( bx = 0 ;\n bx < bw ;\n bx ++ , dst += 8 ) {\n blk = binkb_get_value ( c , BINKB_SRC_BLOCK_TYPES ) ;\n switch ( blk ) {\n case 0 : break ;\n case 1 : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n i = 0 ;\n do {\n int mode , run ;\n mode = get_bits1 ( gb ) ;\n run = get_bits ( gb , binkb_runbits [ i ] ) + 1 ;\n i += run ;\n if ( i > 64 ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Run went out of bounds\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( mode ) {\n v = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n for ( j = 0 ;\n j < run ;\n j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n }\n else {\n for ( j = 0 ;\n j < run ;\n j ++ ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n }\n }\n while ( i < 63 ) ;\n if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n break ;\n case 2 : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTRA_DC ) ;\n qp = binkb_get_value ( c , BINKB_SRC_INTRA_Q ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , binkb_intra_quant , qp ) ;\n c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n break ;\n case 3 : xoff = binkb_get_value ( c , BINKB_SRC_X_OFF ) ;\n yoff = binkb_get_value ( c , BINKB_SRC_Y_OFF ) + ybias ;\n ref = dst + xoff + yoff * stride ;\n if ( ref < ref_start || ref + 8 * stride > ref_end ) {\n av_log ( c -> avctx , AV_LOG_WARNING , \"Reference block is out of bounds\\n\" ) ;\n }\n else if ( ref + 8 * stride < dst || ref >= dst + 8 * stride ) {\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n }\n else {\n put_pixels8x8_overlapped ( dst , ref , stride ) ;\n }\n c -> dsp . clear_block ( block ) ;\n v = binkb_get_value ( c , BINKB_SRC_INTER_COEFS ) ;\n read_residue ( gb , block , v ) ;\n c -> dsp . add_pixels8 ( dst , block , stride ) ;\n break ;\n case 4 : xoff = binkb_get_value ( c , BINKB_SRC_X_OFF ) ;\n yoff = binkb_get_value ( c , BINKB_SRC_Y_OFF ) + ybias ;\n ref = dst + xoff + yoff * stride ;\n if ( ref < ref_start || ref + 8 * stride > ref_end ) {\n av_log ( c -> avctx , AV_LOG_WARNING , \"Reference block is out of bounds\\n\" ) ;\n }\n else if ( ref + 8 * stride < dst || ref >= dst + 8 * stride ) {\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n }\n else {\n put_pixels8x8_overlapped ( dst , ref , stride ) ;\n }\n memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTER_DC ) ;\n qp = binkb_get_value ( c , BINKB_SRC_INTER_Q ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , binkb_inter_quant , qp ) ;\n c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n break ;\n case 5 : v = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n c -> dsp . fill_block_tab [ 1 ] ( dst , v , stride , 8 ) ;\n break ;\n case 6 : for ( i = 0 ;\n i < 2 ;\n i ++ ) col [ i ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n v = binkb_get_value ( c , BINKB_SRC_PATTERN ) ;\n for ( j = 0 ;\n j < 8 ;\n j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n }\n break ;\n case 7 : xoff = binkb_get_value ( c , BINKB_SRC_X_OFF ) ;\n yoff = binkb_get_value ( c , BINKB_SRC_Y_OFF ) + ybias ;\n ref = dst + xoff + yoff * stride ;\n if ( ref < ref_start || ref + 8 * stride > ref_end ) {\n av_log ( c -> avctx , AV_LOG_WARNING , \"Reference block is out of bounds\\n\" ) ;\n }\n else if ( ref + 8 * stride < dst || ref >= dst + 8 * stride ) {\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n }\n else {\n put_pixels8x8_overlapped ( dst , ref , stride ) ;\n }\n break ;\n case 8 : for ( i = 0 ;\n i < 8 ;\n i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINKB_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n c -> bundle [ BINKB_SRC_COLORS ] . cur_ptr += 64 ;\n break ;\n default : av_log ( c -> avctx , AV_LOG_ERROR , \"Unknown block type %d\\n\" , blk ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n }\n if ( get_bits_count ( gb ) & 0x1F ) / ext plane data starts at 32 - bit boundary skip_bits_long ( gb , 32 - ( get_bits_count ( gb ) & 0x1F ) ) ;\n return 0 ;\n }",
        "hash": -7131177824150194183,
        "project": "debian",
        "size": 144,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int binkb_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_key , int is_chroma ) {\n"
                ],
                [
                    30,
                    " dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n"
                ],
                [
                    33,
                    " bx ++ , dst += 8 ) {\n"
                ],
                [
                    52,
                    " j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n"
                ],
                [
                    57,
                    " j ++ ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n"
                ],
                [
                    61,
                    " if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n"
                ],
                [
                    116,
                    " j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n"
                ],
                [
                    133,
                    " i < 8 ;\n"
                ],
                [
                    134,
                    " i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINKB_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int binkb_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_key , int is_chroma ) {\n"
                ],
                [
                    35,
                    " switch ( blk ) {\n"
                ],
                [
                    63,
                    " case 2 : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    64,
                    " dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTRA_DC ) ;\n"
                ],
                [
                    66,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , binkb_intra_quant , qp ) ;\n"
                ],
                [
                    67,
                    " c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n"
                ],
                [
                    98,
                    " memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    99,
                    " dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTER_DC ) ;\n"
                ],
                [
                    101,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , binkb_inter_quant , qp ) ;\n"
                ],
                [
                    102,
                    " c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int binkb_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_key , int is_chroma ) {\n"
                ],
                [
                    30,
                    " dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n"
                ],
                [
                    33,
                    " bx ++ , dst += 8 ) {\n"
                ],
                [
                    35,
                    " switch ( blk ) {\n"
                ],
                [
                    52,
                    " j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n"
                ],
                [
                    57,
                    " j ++ ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n"
                ],
                [
                    61,
                    " if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n"
                ],
                [
                    63,
                    " case 2 : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    64,
                    " dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTRA_DC ) ;\n"
                ],
                [
                    66,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , binkb_intra_quant , qp ) ;\n"
                ],
                [
                    67,
                    " c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n"
                ],
                [
                    98,
                    " memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    99,
                    " dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTER_DC ) ;\n"
                ],
                [
                    101,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , binkb_inter_quant , qp ) ;\n"
                ],
                [
                    102,
                    " c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n"
                ],
                [
                    116,
                    " j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n"
                ],
                [
                    133,
                    " i < 8 ;\n"
                ],
                [
                    134,
                    " i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINKB_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int bink_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_chroma ) {\n int blk , ret ;\n int i , j , bx , by ;\n uint8_t * dst , * prev , * ref , * ref_start , * ref_end ;\n int v , col [ 2 ] ;\n const uint8_t * scan ;\n int xoff , yoff ;\n LOCAL_ALIGNED_16 ( int16_t , block , [ 64 ] ) ;\n LOCAL_ALIGNED_16 ( uint8_t , ublock , [ 64 ] ) ;\n LOCAL_ALIGNED_16 ( int32_t , dctblock , [ 64 ] ) ;\n int coordmap [ 64 ] ;\n const int stride = c -> pic -> linesize [ plane_idx ] ;\n int bw = is_chroma ? ( c -> avctx -> width + 15 ) >> 4 : ( c -> avctx -> width + 7 ) >> 3 ;\n int bh = is_chroma ? ( c -> avctx -> height + 15 ) >> 4 : ( c -> avctx -> height + 7 ) >> 3 ;\n int width = c -> avctx -> width >> is_chroma ;\n init_lengths ( c , FFMAX ( width , 8 ) , bw ) ;\n for ( i = 0 ;\n i < BINK_NB_SRC ;\n i ++ ) read_bundle ( gb , c , i ) ;\n ref_start = c -> last -> data [ plane_idx ] ? c -> last -> data [ plane_idx ] : c -> pic -> data [ plane_idx ] ;\n ref_end = ref_start + ( bw - 1 + c -> last -> linesize [ plane_idx ] * ( bh - 1 ) ) * 8 ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) coordmap [ i ] = ( i & 7 ) + ( i >> 3 ) * stride ;\n for ( by = 0 ;\n by < bh ;\n by ++ ) {\n if ( ( ret = read_block_types ( c -> avctx , gb , & c -> bundle [ BINK_SRC_BLOCK_TYPES ] ) ) < 0 ) return ret ;\n if ( ( ret = read_block_types ( c -> avctx , gb , & c -> bundle [ BINK_SRC_SUB_BLOCK_TYPES ] ) ) < 0 ) return ret ;\n if ( ( ret = read_colors ( gb , & c -> bundle [ BINK_SRC_COLORS ] , c ) ) < 0 ) return ret ;\n if ( ( ret = read_patterns ( c -> avctx , gb , & c -> bundle [ BINK_SRC_PATTERN ] ) ) < 0 ) return ret ;\n if ( ( ret = read_motion_values ( c -> avctx , gb , & c -> bundle [ BINK_SRC_X_OFF ] ) ) < 0 ) return ret ;\n if ( ( ret = read_motion_values ( c -> avctx , gb , & c -> bundle [ BINK_SRC_Y_OFF ] ) ) < 0 ) return ret ;\n if ( ( ret = read_dcs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_INTRA_DC ] , DC_START_BITS , 0 ) ) < 0 ) return ret ;\n if ( ( ret = read_dcs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_INTER_DC ] , DC_START_BITS , 1 ) ) < 0 ) return ret ;\n if ( ( ret = read_runs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_RUN ] ) ) < 0 ) return ret ;\n if ( by == bh ) break ;\n dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n prev = ( c -> last -> data [ plane_idx ] ? c -> last -> data [ plane_idx ] : c -> pic -> data [ plane_idx ] ) + 8 * by * stride ;\n for ( bx = 0 ;\n bx < bw ;\n bx ++ , dst += 8 , prev += 8 ) {\n blk = get_value ( c , BINK_SRC_BLOCK_TYPES ) ;\n if ( ( by & 1 ) && blk == SCALED_BLOCK ) {\n bx ++ ;\n dst += 8 ;\n prev += 8 ;\n continue ;\n }\n switch ( blk ) {\n case SKIP_BLOCK : c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , prev , stride , 8 ) ;\n break ;\n case SCALED_BLOCK : blk = get_value ( c , BINK_SRC_SUB_BLOCK_TYPES ) ;\n switch ( blk ) {\n case RUN_BLOCK : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n i = 0 ;\n do {\n int run = get_value ( c , BINK_SRC_RUN ) + 1 ;\n i += run ;\n if ( i > 64 ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Run went out of bounds\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( get_bits1 ( gb ) ) {\n v = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < run ;\n j ++ ) ublock [ * scan ++ ] = v ;\n }\n else {\n for ( j = 0 ;\n j < run ;\n j ++ ) ublock [ * scan ++ ] = get_value ( c , BINK_SRC_COLORS ) ;\n }\n }\n while ( i < 63 ) ;\n if ( i == 63 ) ublock [ * scan ++ ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n c -> bdsp . idct_put ( ublock , 8 , dctblock ) ;\n break ;\n case FILL_BLOCK : v = get_value ( c , BINK_SRC_COLORS ) ;\n c -> dsp . fill_block_tab [ 0 ] ( dst , v , stride , 16 ) ;\n break ;\n case PATTERN_BLOCK : for ( i = 0 ;\n i < 2 ;\n i ++ ) col [ i ] = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < 8 ;\n j ++ ) {\n v = get_value ( c , BINK_SRC_PATTERN ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ , v >>= 1 ) ublock [ i + j * 8 ] = col [ v & 1 ] ;\n }\n break ;\n case RAW_BLOCK : for ( j = 0 ;\n j < 8 ;\n j ++ ) for ( i = 0 ;\n i < 8 ;\n i ++ ) ublock [ i + j * 8 ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n default : av_log ( c -> avctx , AV_LOG_ERROR , \"Incorrect 16x16 block type %d\\n\" , blk ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( blk != FILL_BLOCK ) c -> bdsp . scale_block ( ublock , dst , stride ) ;\n bx ++ ;\n dst += 8 ;\n prev += 8 ;\n break ;\n case MOTION_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n if ( ref < ref_start || ref > ref_end ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Copy out of bounds @%d, %d\\n\" , bx * 8 + xoff , by * 8 + yoff ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n break ;\n case RUN_BLOCK : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n i = 0 ;\n do {\n int run = get_value ( c , BINK_SRC_RUN ) + 1 ;\n i += run ;\n if ( i > 64 ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Run went out of bounds\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( get_bits1 ( gb ) ) {\n v = get_value ( c , BINK_SRC_COLORS ) ;\n for ( j = 0 ;\n j < run ;\n j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n }\n else {\n for ( j = 0 ;\n j < run ;\n j ++ ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n }\n }\n while ( i < 63 ) ;\n if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n break ;\n case RESIDUE_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n if ( ref < ref_start || ref > ref_end ) {\n av_log ( c -> avctx , AV_LOG_ERROR , \"Copy out of bounds @%d, %d\\n\" , bx * 8 + xoff , by * 8 + yoff ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n c -> dsp . clear_block ( block ) ;\n v = get_bits ( gb , 7 ) ;\n read_residue ( gb , block , v ) ;\n c -> dsp . add_pixels8 ( dst , block , stride ) ;\n break ;\n case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n break ;\n case FILL_BLOCK : v = get_value ( c , BINK_SRC_COLORS ) ;\n c -> dsp . fill_block_tab [ 1 ] ( dst , v , stride , 8 ) ;\n break ;\n case INTER_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n ref = prev + xoff + yoff * stride ;\n c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n dctblock [ 0 ] = get_value ( c , BINK_SRC_INTER_DC ) ;\n read_dct_coeffs ( gb , dctblock , bink_scan , bink_inter_quant , - 1 ) ;\n c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n break ;\n case PATTERN_BLOCK : for ( i = 0 ;\n i < 2 ;\n i ++ ) col [ i ] = get_value ( c , BINK_SRC_COLORS ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n v = get_value ( c , BINK_SRC_PATTERN ) ;\n for ( j = 0 ;\n j < 8 ;\n j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n }\n break ;\n case RAW_BLOCK : for ( i = 0 ;\n i < 8 ;\n i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINK_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n c -> bundle [ BINK_SRC_COLORS ] . cur_ptr += 64 ;\n break ;\n default : av_log ( c -> avctx , AV_LOG_ERROR , \"Unknown block type %d\\n\" , blk ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n }\n if ( get_bits_count ( gb ) & 0x1F ) / ext plane data starts at 32 - bit boundary skip_bits_long ( gb , 32 - ( get_bits_count ( gb ) & 0x1F ) ) ;\n return 0 ;\n }",
        "hash": -7131177824150194183,
        "project": "debian",
        "size": 200,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int bink_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_chroma ) {\n"
                ],
                [
                    38,
                    " dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n"
                ],
                [
                    42,
                    " bx ++ , dst += 8 , prev += 8 ) {\n"
                ],
                [
                    135,
                    " j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n"
                ],
                [
                    140,
                    " j ++ ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n"
                ],
                [
                    144,
                    " if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n"
                ],
                [
                    185,
                    " j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n"
                ],
                [
                    189,
                    " i < 8 ;\n"
                ],
                [
                    190,
                    " i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINK_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int bink_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_chroma ) {\n"
                ],
                [
                    50,
                    " switch ( blk ) {\n"
                ],
                [
                    54,
                    " switch ( blk ) {\n"
                ],
                [
                    79,
                    " case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    80,
                    " dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n"
                ],
                [
                    81,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n"
                ],
                [
                    82,
                    " c -> bdsp . idct_put ( ublock , 8 , dctblock ) ;\n"
                ],
                [
                    159,
                    " case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    160,
                    " dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n"
                ],
                [
                    161,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n"
                ],
                [
                    162,
                    " c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n"
                ],
                [
                    171,
                    " memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    172,
                    " dctblock [ 0 ] = get_value ( c , BINK_SRC_INTER_DC ) ;\n"
                ],
                [
                    173,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , bink_inter_quant , - 1 ) ;\n"
                ],
                [
                    174,
                    " c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int bink_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_chroma ) {\n"
                ],
                [
                    38,
                    " dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n"
                ],
                [
                    42,
                    " bx ++ , dst += 8 , prev += 8 ) {\n"
                ],
                [
                    50,
                    " switch ( blk ) {\n"
                ],
                [
                    54,
                    " switch ( blk ) {\n"
                ],
                [
                    79,
                    " case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    80,
                    " dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n"
                ],
                [
                    81,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n"
                ],
                [
                    82,
                    " c -> bdsp . idct_put ( ublock , 8 , dctblock ) ;\n"
                ],
                [
                    135,
                    " j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n"
                ],
                [
                    140,
                    " j ++ ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n"
                ],
                [
                    144,
                    " if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n"
                ],
                [
                    159,
                    " case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    160,
                    " dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n"
                ],
                [
                    161,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n"
                ],
                [
                    162,
                    " c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n"
                ],
                [
                    171,
                    " memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n"
                ],
                [
                    172,
                    " dctblock [ 0 ] = get_value ( c , BINK_SRC_INTER_DC ) ;\n"
                ],
                [
                    173,
                    " read_dct_coeffs ( gb , dctblock , bink_scan , bink_inter_quant , - 1 ) ;\n"
                ],
                [
                    174,
                    " c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n"
                ],
                [
                    185,
                    " j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n"
                ],
                [
                    189,
                    " i < 8 ;\n"
                ],
                [
                    190,
                    " i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINK_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int g722_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n G722Context * c = avctx -> priv_data ;\n AVFrame * frame = data ;\n int16_t * out_buf ;\n int j , ret ;\n const int skip = 8 - c -> bits_per_codeword ;\n const int16_t * quantizer_table = low_inv_quants [ skip ] ;\n GetBitContext gb ;\n frame -> nb_samples = avpkt -> size * 2 ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n out_buf = ( int16_t * ) frame -> data [ 0 ] ;\n init_get_bits ( & gb , avpkt -> data , avpkt -> size * 8 ) ;\n for ( j = 0 ;\n j < avpkt -> size ;\n j ++ ) {\n int ilow , ihigh , rlow , rhigh , dhigh ;\n int xout1 , xout2 ;\n ihigh = get_bits ( & gb , 2 ) ;\n ilow = get_bits ( & gb , 6 - skip ) ;\n skip_bits ( & gb , skip ) ;\n rlow = av_clip ( ( c -> band [ 0 ] . scale_factor * quantizer_table [ ilow ] >> 10 ) + c -> band [ 0 ] . s_predictor , - 16384 , 16383 ) ;\n ff_g722_update_low_predictor ( & c -> band [ 0 ] , ilow >> ( 2 - skip ) ) ;\n dhigh = c -> band [ 1 ] . scale_factor * ff_g722_high_inv_quant [ ihigh ] >> 10 ;\n rhigh = av_clip ( dhigh + c -> band [ 1 ] . s_predictor , - 16384 , 16383 ) ;\n ff_g722_update_high_predictor ( & c -> band [ 1 ] , dhigh , ihigh ) ;\n c -> prev_samples [ c -> prev_samples_pos ++ ] = rlow + rhigh ;\n c -> prev_samples [ c -> prev_samples_pos ++ ] = rlow - rhigh ;\n ff_g722_apply_qmf ( c -> prev_samples + c -> prev_samples_pos - 24 , & xout1 , & xout2 ) ;\n * out_buf ++ = av_clip_int16 ( xout1 >> 11 ) ;\n * out_buf ++ = av_clip_int16 ( xout2 >> 11 ) ;\n if ( c -> prev_samples_pos >= PREV_SAMPLES_BUF_SIZE ) {\n memmove ( c -> prev_samples , c -> prev_samples + c -> prev_samples_pos - 22 , 22 * sizeof ( c -> prev_samples [ 0 ] ) ) ;\n c -> prev_samples_pos = 22 ;\n }\n }\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }",
        "hash": -1388412050128601796,
        "project": "debian",
        "size": 41,
        "slice": {
            "memmove": [
                [
                    2,
                    " G722Context * c = avctx -> priv_data ;\n"
                ],
                [
                    30,
                    " c -> prev_samples [ c -> prev_samples_pos ++ ] = rlow - rhigh ;\n"
                ],
                [
                    31,
                    " ff_g722_apply_qmf ( c -> prev_samples + c -> prev_samples_pos - 24 , & xout1 , & xout2 ) ;\n"
                ],
                [
                    34,
                    " if ( c -> prev_samples_pos >= PREV_SAMPLES_BUF_SIZE ) {\n"
                ],
                [
                    35,
                    " memmove ( c -> prev_samples , c -> prev_samples + c -> prev_samples_pos - 22 , 22 * sizeof ( c -> prev_samples [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    2,
                    " G722Context * c = avctx -> priv_data ;\n"
                ],
                [
                    30,
                    " c -> prev_samples [ c -> prev_samples_pos ++ ] = rlow - rhigh ;\n"
                ],
                [
                    31,
                    " ff_g722_apply_qmf ( c -> prev_samples + c -> prev_samples_pos - 24 , & xout1 , & xout2 ) ;\n"
                ],
                [
                    34,
                    " if ( c -> prev_samples_pos >= PREV_SAMPLES_BUF_SIZE ) {\n"
                ],
                [
                    35,
                    " memmove ( c -> prev_samples , c -> prev_samples + c -> prev_samples_pos - 22 , 22 * sizeof ( c -> prev_samples [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_i_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n int x , y , ret ;\n const int width = f -> avctx -> width ;\n const int height = f -> avctx -> height ;\n const unsigned int bitstream_size = AV_RL32 ( buf ) ;\n int token_count av_unused ;\n unsigned int prestream_size ;\n const uint8_t * prestream ;\n if ( length < bitstream_size + 12 ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"packet size too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n token_count = AV_RL32 ( buf + bitstream_size + 8 ) ;\n prestream_size = 4 * AV_RL32 ( buf + bitstream_size + 4 ) ;\n prestream = buf + bitstream_size + 12 ;\n if ( prestream_size + bitstream_size + 12 != length || bitstream_size > ( 1 << 26 ) || prestream_size > ( 1 << 26 ) ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"size mismatch %d %d %d\\n\" , prestream_size , bitstream_size , length ) ;\n return AVERROR_INVALIDDATA ;\n }\n prestream = read_huffman_tables ( f , prestream ) ;\n if ( ! prestream ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"Error reading Huffman tables.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n init_get_bits ( & f -> gb , buf + 4 , 8 * bitstream_size ) ;\n prestream_size = length + buf - prestream ;\n av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , prestream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) prestream , prestream_size / 4 ) ;\n memset ( ( uint8_t * ) f -> bitstream_buffer + prestream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n init_get_bits ( & f -> pre_gb , f -> bitstream_buffer , 8 * prestream_size ) ;\n f -> last_dc = 0 * 128 * 8 * 8 ;\n for ( y = 0 ;\n y < height ;\n y += 16 ) {\n for ( x = 0 ;\n x < width ;\n x += 16 ) {\n if ( ( ret = decode_i_mb ( f ) ) < 0 ) return ret ;\n idct_put ( f , x , y ) ;\n }\n }\n if ( get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) != 256 ) av_log ( f -> avctx , AV_LOG_ERROR , \"end mismatch\\n\" ) ;\n return 0 ;\n }",
        "hash": -2661809302248698892,
        "project": "debian",
        "size": 45,
        "slice": {
            "memset": [
                [
                    1,
                    "static int decode_i_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n"
                ],
                [
                    20,
                    " prestream = read_huffman_tables ( f , prestream ) ;\n"
                ],
                [
                    27,
                    " av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , prestream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    28,
                    " if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    29,
                    " f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) prestream , prestream_size / 4 ) ;\n"
                ],
                [
                    30,
                    " memset ( ( uint8_t * ) f -> bitstream_buffer + prestream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_i_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n"
                ],
                [
                    20,
                    " prestream = read_huffman_tables ( f , prestream ) ;\n"
                ],
                [
                    27,
                    " av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , prestream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    28,
                    " if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    29,
                    " f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) prestream , prestream_size / 4 ) ;\n"
                ],
                [
                    30,
                    " memset ( ( uint8_t * ) f -> bitstream_buffer + prestream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_p_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n int x , y ;\n const int width = f -> avctx -> width ;\n const int height = f -> avctx -> height ;\n uint16_t * src = ( uint16_t * ) f -> last_picture -> data [ 0 ] ;\n uint16_t * dst = ( uint16_t * ) f -> current_picture -> data [ 0 ] ;\n const int stride = f -> current_picture -> linesize [ 0 ] >> 1 ;\n unsigned int bitstream_size , bytestream_size , wordstream_size , extra , bytestream_offset , wordstream_offset ;\n if ( f -> version > 1 ) {\n extra = 20 ;\n bitstream_size = AV_RL32 ( buf + 8 ) ;\n wordstream_size = AV_RL32 ( buf + 12 ) ;\n bytestream_size = AV_RL32 ( buf + 16 ) ;\n }\n else {\n extra = 0 ;\n bitstream_size = AV_RL16 ( buf - 4 ) ;\n wordstream_size = AV_RL16 ( buf - 2 ) ;\n bytestream_size = FFMAX ( length - bitstream_size - wordstream_size , 0 ) ;\n }\n if ( bitstream_size + bytestream_size + wordstream_size + extra != length || bitstream_size > ( 1 << 26 ) || bytestream_size > ( 1 << 26 ) || wordstream_size > ( 1 << 26 ) ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"lengths %d %d %d %d\\n\" , bitstream_size , bytestream_size , wordstream_size , bitstream_size + bytestream_size + wordstream_size - length ) ;\n return AVERROR_INVALIDDATA ;\n }\n av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) ( buf + extra ) , bitstream_size / 4 ) ;\n memset ( ( uint8_t * ) f -> bitstream_buffer + bitstream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n init_get_bits ( & f -> gb , f -> bitstream_buffer , 8 * bitstream_size ) ;\n wordstream_offset = extra + bitstream_size ;\n bytestream_offset = extra + bitstream_size + wordstream_size ;\n bytestream2_init ( & f -> g2 , buf + wordstream_offset , length - wordstream_offset ) ;\n bytestream2_init ( & f -> g , buf + bytestream_offset , length - bytestream_offset ) ;\n init_mv ( f ) ;\n for ( y = 0 ;\n y < height ;\n y += 8 ) {\n for ( x = 0 ;\n x < width ;\n x += 8 ) decode_p_block ( f , dst + x , src + x , 3 , 3 , stride ) ;\n src += 8 * stride ;\n dst += 8 * stride ;\n }\n return 0 ;\n }",
        "hash": -2661809302248698892,
        "project": "debian",
        "size": 45,
        "slice": {
            "memset": [
                [
                    1,
                    "static int decode_p_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n"
                ],
                [
                    25,
                    " av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    26,
                    " if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    27,
                    " f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) ( buf + extra ) , bitstream_size / 4 ) ;\n"
                ],
                [
                    28,
                    " memset ( ( uint8_t * ) f -> bitstream_buffer + bitstream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_p_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n"
                ],
                [
                    25,
                    " av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    26,
                    " if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    27,
                    " f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) ( buf + extra ) , bitstream_size / 4 ) ;\n"
                ],
                [
                    28,
                    " memset ( ( uint8_t * ) f -> bitstream_buffer + bitstream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n FourXContext * const f = avctx -> priv_data ;\n AVFrame * picture = data ;\n AVFrame * p ;\n int i , frame_4cc , frame_size , ret ;\n frame_4cc = AV_RL32 ( buf ) ;\n if ( buf_size != AV_RL32 ( buf + 4 ) + 8 || buf_size < 20 ) av_log ( f -> avctx , AV_LOG_ERROR , \"size mismatch %d %d\\n\" , buf_size , AV_RL32 ( buf + 4 ) ) ;\n if ( frame_4cc == AV_RL32 ( \"cfrm\" ) ) {\n int free_index = - 1 ;\n const int data_size = buf_size - 20 ;\n const int id = AV_RL32 ( buf + 12 ) ;\n const int whole_size = AV_RL32 ( buf + 16 ) ;\n CFrameBuffer * cfrm ;\n for ( i = 0 ;\n i < CFRAME_BUFFER_COUNT ;\n i ++ ) if ( f -> cfrm [ i ] . id && f -> cfrm [ i ] . id < avctx -> frame_number ) av_log ( f -> avctx , AV_LOG_ERROR , \"lost c frame %d\\n\" , f -> cfrm [ i ] . id ) ;\n for ( i = 0 ;\n i < CFRAME_BUFFER_COUNT ;\n i ++ ) {\n if ( f -> cfrm [ i ] . id == id ) break ;\n if ( f -> cfrm [ i ] . size == 0 ) free_index = i ;\n }\n if ( i >= CFRAME_BUFFER_COUNT ) {\n i = free_index ;\n f -> cfrm [ i ] . id = id ;\n }\n cfrm = & f -> cfrm [ i ] ;\n cfrm -> data = av_fast_realloc ( cfrm -> data , & cfrm -> allocated_size , cfrm -> size + data_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! cfrm -> data ) {\n av_log ( f -> avctx , AV_LOG_ERROR , \"realloc failure\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n memcpy ( cfrm -> data + cfrm -> size , buf + 20 , data_size ) ;\n cfrm -> size += data_size ;\n if ( cfrm -> size >= whole_size ) {\n buf = cfrm -> data ;\n frame_size = cfrm -> size ;\n if ( id != avctx -> frame_number ) av_log ( f -> avctx , AV_LOG_ERROR , \"cframe id mismatch %d %d\\n\" , id , avctx -> frame_number ) ;\n cfrm -> size = cfrm -> id = 0 ;\n frame_4cc = AV_RL32 ( \"pfrm\" ) ;\n }\n else return buf_size ;\n }\n else {\n buf = buf + 12 ;\n frame_size = buf_size - 12 ;\n }\n FFSWAP ( AVFrame * , f -> current_picture , f -> last_picture ) ;\n p = f -> current_picture ;\n avctx -> coded_frame = p ;\n avctx -> flags |= CODEC_FLAG_EMU_EDGE ;\n if ( p -> data [ 0 ] ) avctx -> release_buffer ( avctx , p ) ;\n p -> reference = 1 ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( frame_4cc == AV_RL32 ( \"ifr2\" ) ) {\n p -> pict_type = AV_PICTURE_TYPE_I ;\n if ( ( ret = decode_i2_frame ( f , buf - 4 , frame_size + 4 ) ) < 0 ) return ret ;\n }\n else if ( frame_4cc == AV_RL32 ( \"ifrm\" ) ) {\n p -> pict_type = AV_PICTURE_TYPE_I ;\n if ( ( ret = decode_i_frame ( f , buf , frame_size ) ) < 0 ) return ret ;\n }\n else if ( frame_4cc == AV_RL32 ( \"pfrm\" ) || frame_4cc == AV_RL32 ( \"pfr2\" ) ) {\n if ( ! f -> last_picture -> data [ 0 ] ) {\n f -> last_picture -> reference = 1 ;\n if ( ( ret = ff_get_buffer ( avctx , f -> last_picture ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n memset ( f -> last_picture -> data [ 0 ] , 0 , avctx -> height * FFABS ( f -> last_picture -> linesize [ 0 ] ) ) ;\n }\n p -> pict_type = AV_PICTURE_TYPE_P ;\n if ( ( ret = decode_p_frame ( f , buf , frame_size ) ) < 0 ) return ret ;\n }\n else if ( frame_4cc == AV_RL32 ( \"snd_\" ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring snd_ chunk length:%d\\n\" , buf_size ) ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"ignoring unknown chunk length:%d\\n\" , buf_size ) ;\n }\n p -> key_frame = p -> pict_type == AV_PICTURE_TYPE_I ;\n * picture = * p ;\n * got_frame = 1 ;\n emms_c ( ) ;\n return buf_size ;\n }",
        "hash": -2661809302248698892,
        "project": "debian",
        "size": 91,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    8,
                    " frame_4cc = AV_RL32 ( buf ) ;\n"
                ],
                [
                    12,
                    " const int data_size = buf_size - 20 ;\n"
                ],
                [
                    29,
                    " cfrm = & f -> cfrm [ i ] ;\n"
                ],
                [
                    31,
                    " if ( ! cfrm -> data ) {\n"
                ],
                [
                    35,
                    " memcpy ( cfrm -> data + cfrm -> size , buf + 20 , data_size ) ;\n"
                ],
                [
                    36,
                    " cfrm -> size += data_size ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    69,
                    " if ( ! f -> last_picture -> data [ 0 ] ) {\n"
                ],
                [
                    71,
                    " if ( ( ret = ff_get_buffer ( avctx , f -> last_picture ) ) < 0 ) {\n"
                ],
                [
                    75,
                    " memset ( f -> last_picture -> data [ 0 ] , 0 , avctx -> height * FFABS ( f -> last_picture -> linesize [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    8,
                    " frame_4cc = AV_RL32 ( buf ) ;\n"
                ],
                [
                    12,
                    " const int data_size = buf_size - 20 ;\n"
                ],
                [
                    29,
                    " cfrm = & f -> cfrm [ i ] ;\n"
                ],
                [
                    31,
                    " if ( ! cfrm -> data ) {\n"
                ],
                [
                    35,
                    " memcpy ( cfrm -> data + cfrm -> size , buf + 20 , data_size ) ;\n"
                ],
                [
                    36,
                    " cfrm -> size += data_size ;\n"
                ],
                [
                    69,
                    " if ( ! f -> last_picture -> data [ 0 ] ) {\n"
                ],
                [
                    71,
                    " if ( ( ret = ff_get_buffer ( avctx , f -> last_picture ) ) < 0 ) {\n"
                ],
                [
                    75,
                    " memset ( f -> last_picture -> data [ 0 ] , 0 , avctx -> height * FFABS ( f -> last_picture -> linesize [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int truespeech_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n TSContext * c = avctx -> priv_data ;\n int i , j ;\n int16_t * samples ;\n int iterations , ret ;\n iterations = buf_size / 32 ;\n if ( ! iterations ) {\n av_log ( avctx , AV_LOG_ERROR , \"Too small input buffer (%d bytes), need at least 32 bytes\\n\" , buf_size ) ;\n return - 1 ;\n }\n frame -> nb_samples = iterations * 240 ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( int16_t * ) frame -> data [ 0 ] ;\n memset ( samples , 0 , iterations * 240 * sizeof ( * samples ) ) ;\n for ( j = 0 ;\n j < iterations ;\n j ++ ) {\n truespeech_read_frame ( c , buf ) ;\n buf += 32 ;\n truespeech_correlate_filter ( c ) ;\n truespeech_filters_merge ( c ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n truespeech_apply_twopoint_filter ( c , i ) ;\n truespeech_place_pulses ( c , samples , i ) ;\n truespeech_update_filters ( c , samples , i ) ;\n truespeech_synth ( c , samples , i ) ;\n samples += 60 ;\n }\n truespeech_save_prevvec ( c ) ;\n }\n * got_frame_ptr = 1 ;\n return buf_size ;\n }",
        "hash": -2740750333757361388,
        "project": "debian",
        "size": 41,
        "slice": {
            "memset": [
                [
                    1,
                    "static int truespeech_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    15,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ],
                [
                    19,
                    " samples = ( int16_t * ) frame -> data [ 0 ] ;\n"
                ],
                [
                    20,
                    " memset ( samples , 0 , iterations * 240 * sizeof ( * samples ) ) ;\n"
                ],
                [
                    32,
                    " truespeech_place_pulses ( c , samples , i ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int truespeech_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    15,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ],
                [
                    19,
                    " samples = ( int16_t * ) frame -> data [ 0 ] ;\n"
                ],
                [
                    20,
                    " memset ( samples , 0 , iterations * 240 * sizeof ( * samples ) ) ;\n"
                ],
                [
                    32,
                    " truespeech_place_pulses ( c , samples , i ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n BinkAudioContext * s = avctx -> priv_data ;\n AVFrame * frame = data ;\n GetBitContext * gb = & s -> gb ;\n int ret , consumed = 0 ;\n if ( ! get_bits_left ( gb ) ) {\n uint8_t * buf ;\n if ( ! avpkt -> size ) {\n * got_frame_ptr = 0 ;\n return 0 ;\n }\n if ( avpkt -> size < 4 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n buf = av_realloc ( s -> packet_buffer , avpkt -> size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! buf ) return AVERROR ( ENOMEM ) ;\n s -> packet_buffer = buf ;\n memcpy ( s -> packet_buffer , avpkt -> data , avpkt -> size ) ;\n init_get_bits ( gb , s -> packet_buffer , avpkt -> size * 8 ) ;\n consumed = avpkt -> size ;\n skip_bits_long ( gb , 32 ) ;\n }\n frame -> nb_samples = s -> frame_len ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( decode_block ( s , ( float * * ) frame -> extended_data , avctx -> codec -> id == AV_CODEC_ID_BINKAUDIO_DCT ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Incomplete packet\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n get_bits_align32 ( gb ) ;\n frame -> nb_samples = s -> block_size / avctx -> channels ;\n * got_frame_ptr = 1 ;\n return consumed ;\n }",
        "hash": -7456613930747243098,
        "project": "debian",
        "size": 37,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " BinkAudioContext * s = avctx -> priv_data ;\n"
                ],
                [
                    12,
                    " if ( avpkt -> size < 4 ) {\n"
                ],
                [
                    17,
                    " if ( ! buf ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    18,
                    " s -> packet_buffer = buf ;\n"
                ],
                [
                    19,
                    " memcpy ( s -> packet_buffer , avpkt -> data , avpkt -> size ) ;\n"
                ],
                [
                    20,
                    " init_get_bits ( gb , s -> packet_buffer , avpkt -> size * 8 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " BinkAudioContext * s = avctx -> priv_data ;\n"
                ],
                [
                    12,
                    " if ( avpkt -> size < 4 ) {\n"
                ],
                [
                    17,
                    " if ( ! buf ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    18,
                    " s -> packet_buffer = buf ;\n"
                ],
                [
                    19,
                    " memcpy ( s -> packet_buffer , avpkt -> data , avpkt -> size ) ;\n"
                ],
                [
                    20,
                    " init_get_bits ( gb , s -> packet_buffer , avpkt -> size * 8 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ff_h264_decode_mb_cabac ( H264Context * h ) {\n int mb_xy ;\n int mb_type , partition_count , cbp = 0 ;\n int dct8x8_allowed = h -> pps . transform_8x8_mode ;\n int decode_chroma = h -> sps . chroma_format_idc == 1 || h -> sps . chroma_format_idc == 2 ;\n const int pixel_shift = h -> pixel_shift ;\n mb_xy = h -> mb_xy = h -> mb_x + h -> mb_y * h -> mb_stride ;\n tprintf ( h -> avctx , \"pic:%d mb:%d/%d\\n\" , h -> frame_num , h -> mb_x , h -> mb_y ) ;\n if ( h -> slice_type_nos != AV_PICTURE_TYPE_I ) {\n int skip ;\n if ( FRAME_MBAFF && ( h -> mb_y & 1 ) == 1 && h -> prev_mb_skipped ) skip = h -> next_mb_skipped ;\n else skip = decode_cabac_mb_skip ( h , h -> mb_x , h -> mb_y ) ;\n if ( skip ) {\n if ( FRAME_MBAFF && ( h -> mb_y & 1 ) == 0 ) {\n h -> cur_pic . f . mb_type [ mb_xy ] = MB_TYPE_SKIP ;\n h -> next_mb_skipped = decode_cabac_mb_skip ( h , h -> mb_x , h -> mb_y + 1 ) ;\n if ( ! h -> next_mb_skipped ) h -> mb_mbaff = h -> mb_field_decoding_flag = decode_cabac_field_decoding_flag ( h ) ;\n }\n decode_mb_skip ( h ) ;\n h -> cbp_table [ mb_xy ] = 0 ;\n h -> chroma_pred_mode_table [ mb_xy ] = 0 ;\n h -> last_qscale_diff = 0 ;\n return 0 ;\n }\n }\n if ( FRAME_MBAFF ) {\n if ( ( h -> mb_y & 1 ) == 0 ) h -> mb_mbaff = h -> mb_field_decoding_flag = decode_cabac_field_decoding_flag ( h ) ;\n }\n h -> prev_mb_skipped = 0 ;\n fill_decode_neighbors ( h , - ( MB_FIELD ) ) ;\n if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) {\n int ctx = 0 ;\n assert ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) ;\n if ( ! IS_DIRECT ( h -> left_type [ LTOP ] - 1 ) ) ctx ++ ;\n if ( ! IS_DIRECT ( h -> top_type - 1 ) ) ctx ++ ;\n if ( ! get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 27 + ctx ] ) ) {\n mb_type = 0 ;\n }\n else if ( ! get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 27 + 3 ] ) ) {\n mb_type = 1 + get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 27 + 5 ] ) ;\n }\n else {\n int bits ;\n bits = get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 27 + 4 ] ) << 3 ;\n bits += get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 27 + 5 ] ) << 2 ;\n bits += get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 27 + 5 ] ) << 1 ;\n bits += get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 27 + 5 ] ) ;\n if ( bits < 8 ) {\n mb_type = bits + 3 ;\n }\n else if ( bits == 13 ) {\n mb_type = decode_cabac_intra_mb_type ( h , 32 , 0 ) ;\n goto decode_intra_mb ;\n }\n else if ( bits == 14 ) {\n mb_type = 11 ;\n }\n else if ( bits == 15 ) {\n mb_type = 22 ;\n }\n else {\n bits = ( bits << 1 ) + get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 27 + 5 ] ) ;\n mb_type = bits - 4 ;\n }\n }\n partition_count = b_mb_type_info [ mb_type ] . partition_count ;\n mb_type = b_mb_type_info [ mb_type ] . type ;\n }\n else if ( h -> slice_type_nos == AV_PICTURE_TYPE_P ) {\n if ( get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 14 ] ) == 0 ) {\n if ( get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 15 ] ) == 0 ) {\n mb_type = 3 * get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 16 ] ) ;\n }\n else {\n mb_type = 2 - get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 17 ] ) ;\n }\n partition_count = p_mb_type_info [ mb_type ] . partition_count ;\n mb_type = p_mb_type_info [ mb_type ] . type ;\n }\n else {\n mb_type = decode_cabac_intra_mb_type ( h , 17 , 0 ) ;\n goto decode_intra_mb ;\n }\n }\n else {\n mb_type = decode_cabac_intra_mb_type ( h , 3 , 1 ) ;\n if ( h -> slice_type == AV_PICTURE_TYPE_SI && mb_type ) mb_type -- ;\n assert ( h -> slice_type_nos == AV_PICTURE_TYPE_I ) ;\n decode_intra_mb : partition_count = 0 ;\n cbp = i_mb_type_info [ mb_type ] . cbp ;\n h -> intra16x16_pred_mode = i_mb_type_info [ mb_type ] . pred_mode ;\n mb_type = i_mb_type_info [ mb_type ] . type ;\n }\n if ( MB_FIELD ) mb_type |= MB_TYPE_INTERLACED ;\n h -> slice_table [ mb_xy ] = h -> slice_num ;\n if ( IS_INTRA_PCM ( mb_type ) ) {\n const int mb_size = ff_h264_mb_sizes [ h -> sps . chroma_format_idc ] * h -> sps . bit_depth_luma >> 3 ;\n const uint8_t * ptr ;\n ptr = h -> cabac . bytestream ;\n if ( h -> cabac . low & 0x1 ) ptr -- ;\n if ( CABAC_BITS == 16 ) {\n if ( h -> cabac . low & 0x1FF ) ptr -- ;\n }\n if ( ( int ) ( h -> cabac . bytestream_end - ptr ) < mb_size ) return - 1 ;\n h -> intra_pcm_ptr = ptr ;\n ptr += mb_size ;\n ff_init_cabac_decoder ( & h -> cabac , ptr , h -> cabac . bytestream_end - ptr ) ;\n h -> cbp_table [ mb_xy ] = 0xf7ef ;\n h -> chroma_pred_mode_table [ mb_xy ] = 0 ;\n h -> cur_pic . f . qscale_table [ mb_xy ] = 0 ;\n memset ( h -> non_zero_count [ mb_xy ] , 16 , 48 ) ;\n h -> cur_pic . f . mb_type [ mb_xy ] = mb_type ;\n h -> last_qscale_diff = 0 ;\n return 0 ;\n }\n fill_decode_caches ( h , mb_type ) ;\n if ( IS_INTRA ( mb_type ) ) {\n int i , pred_mode ;\n if ( IS_INTRA4x4 ( mb_type ) ) {\n if ( dct8x8_allowed && get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 399 + h -> neighbor_transform_size ] ) ) {\n mb_type |= MB_TYPE_8x8DCT ;\n for ( i = 0 ;\n i < 16 ;\n i += 4 ) {\n int pred = pred_intra_mode ( h , i ) ;\n int mode = decode_cabac_mb_intra4x4_pred_mode ( h , pred ) ;\n fill_rectangle ( & h -> intra4x4_pred_mode_cache [ scan8 [ i ] ] , 2 , 2 , 8 , mode , 1 ) ;\n }\n }\n else {\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n int pred = pred_intra_mode ( h , i ) ;\n h -> intra4x4_pred_mode_cache [ scan8 [ i ] ] = decode_cabac_mb_intra4x4_pred_mode ( h , pred ) ;\n av_dlog ( h -> avctx , \"i4x4 pred=%d mode=%d\\n\" , pred , h -> intra4x4_pred_mode_cache [ scan8 [ i ] ] ) ;\n }\n }\n write_back_intra_pred_mode ( h ) ;\n if ( ff_h264_check_intra4x4_pred_mode ( h ) < 0 ) return - 1 ;\n }\n else {\n h -> intra16x16_pred_mode = ff_h264_check_intra_pred_mode ( h , h -> intra16x16_pred_mode , 0 ) ;\n if ( h -> intra16x16_pred_mode < 0 ) return - 1 ;\n }\n if ( decode_chroma ) {\n h -> chroma_pred_mode_table [ mb_xy ] = pred_mode = decode_cabac_mb_chroma_pre_mode ( h ) ;\n pred_mode = ff_h264_check_intra_pred_mode ( h , pred_mode , 1 ) ;\n if ( pred_mode < 0 ) return - 1 ;\n h -> chroma_pred_mode = pred_mode ;\n }\n else {\n h -> chroma_pred_mode = DC_128_PRED8x8 ;\n }\n }\n else if ( partition_count == 4 ) {\n int i , j , sub_partition_count [ 4 ] , list , ref [ 2 ] [ 4 ] ;\n if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n h -> sub_mb_type [ i ] = decode_cabac_b_mb_sub_type ( h ) ;\n sub_partition_count [ i ] = b_sub_mb_type_info [ h -> sub_mb_type [ i ] ] . partition_count ;\n h -> sub_mb_type [ i ] = b_sub_mb_type_info [ h -> sub_mb_type [ i ] ] . type ;\n }\n if ( IS_DIRECT ( h -> sub_mb_type [ 0 ] | h -> sub_mb_type [ 1 ] | h -> sub_mb_type [ 2 ] | h -> sub_mb_type [ 3 ] ) ) {\n ff_h264_pred_direct_motion ( h , & mb_type ) ;\n h -> ref_cache [ 0 ] [ scan8 [ 4 ] ] = h -> ref_cache [ 1 ] [ scan8 [ 4 ] ] = h -> ref_cache [ 0 ] [ scan8 [ 12 ] ] = h -> ref_cache [ 1 ] [ scan8 [ 12 ] ] = PART_NOT_AVAILABLE ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) fill_rectangle ( & h -> direct_cache [ scan8 [ 4 * i ] ] , 2 , 2 , 8 , ( h -> sub_mb_type [ i ] >> 1 ) & 0xFF , 1 ) ;\n }\n }\n else {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n h -> sub_mb_type [ i ] = decode_cabac_p_mb_sub_type ( h ) ;\n sub_partition_count [ i ] = p_sub_mb_type_info [ h -> sub_mb_type [ i ] ] . partition_count ;\n h -> sub_mb_type [ i ] = p_sub_mb_type_info [ h -> sub_mb_type [ i ] ] . type ;\n }\n }\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n if ( IS_DIRECT ( h -> sub_mb_type [ i ] ) ) continue ;\n if ( IS_DIR ( h -> sub_mb_type [ i ] , 0 , list ) ) {\n int rc = h -> ref_count [ list ] << MB_MBAFF ;\n if ( rc > 1 ) {\n ref [ list ] [ i ] = decode_cabac_mb_ref ( h , list , 4 * i ) ;\n if ( ref [ list ] [ i ] >= ( unsigned ) rc ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"Reference %d >= %d\\n\" , ref [ list ] [ i ] , rc ) ;\n return - 1 ;\n }\n }\n else ref [ list ] [ i ] = 0 ;\n }\n else {\n ref [ list ] [ i ] = - 1 ;\n }\n h -> ref_cache [ list ] [ scan8 [ 4 * i ] + 1 ] = h -> ref_cache [ list ] [ scan8 [ 4 * i ] + 8 ] = h -> ref_cache [ list ] [ scan8 [ 4 * i ] + 9 ] = ref [ list ] [ i ] ;\n }\n }\n if ( dct8x8_allowed ) dct8x8_allowed = get_dct8x8_allowed ( h ) ;\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n h -> ref_cache [ list ] [ scan8 [ 4 * i ] ] = h -> ref_cache [ list ] [ scan8 [ 4 * i ] + 1 ] ;\n if ( IS_DIRECT ( h -> sub_mb_type [ i ] ) ) {\n fill_rectangle ( h -> mvd_cache [ list ] [ scan8 [ 4 * i ] ] , 2 , 2 , 8 , 0 , 2 ) ;\n continue ;\n }\n if ( IS_DIR ( h -> sub_mb_type [ i ] , 0 , list ) && ! IS_DIRECT ( h -> sub_mb_type [ i ] ) ) {\n const int sub_mb_type = h -> sub_mb_type [ i ] ;\n const int block_width = ( sub_mb_type & ( MB_TYPE_16x16 | MB_TYPE_16x8 ) ) ? 2 : 1 ;\n for ( j = 0 ;\n j < sub_partition_count [ i ] ;\n j ++ ) {\n int mpx , mpy ;\n int mx , my ;\n const int index = 4 * i + block_width * j ;\n int16_t ( * mv_cache ) [ 2 ] = & h -> mv_cache [ list ] [ scan8 [ index ] ] ;\n uint8_t ( * mvd_cache ) [ 2 ] = & h -> mvd_cache [ list ] [ scan8 [ index ] ] ;\n pred_motion ( h , index , block_width , list , h -> ref_cache [ list ] [ scan8 [ index ] ] , & mx , & my ) ;\n DECODE_CABAC_MB_MVD ( h , list , index ) tprintf ( h -> avctx , \"final mv:%d %d\\n\" , mx , my ) ;\n if ( IS_SUB_8X8 ( sub_mb_type ) ) {\n mv_cache [ 1 ] [ 0 ] = mv_cache [ 8 ] [ 0 ] = mv_cache [ 9 ] [ 0 ] = mx ;\n mv_cache [ 1 ] [ 1 ] = mv_cache [ 8 ] [ 1 ] = mv_cache [ 9 ] [ 1 ] = my ;\n mvd_cache [ 1 ] [ 0 ] = mvd_cache [ 8 ] [ 0 ] = mvd_cache [ 9 ] [ 0 ] = mpx ;\n mvd_cache [ 1 ] [ 1 ] = mvd_cache [ 8 ] [ 1 ] = mvd_cache [ 9 ] [ 1 ] = mpy ;\n }\n else if ( IS_SUB_8X4 ( sub_mb_type ) ) {\n mv_cache [ 1 ] [ 0 ] = mx ;\n mv_cache [ 1 ] [ 1 ] = my ;\n mvd_cache [ 1 ] [ 0 ] = mpx ;\n mvd_cache [ 1 ] [ 1 ] = mpy ;\n }\n else if ( IS_SUB_4X8 ( sub_mb_type ) ) {\n mv_cache [ 8 ] [ 0 ] = mx ;\n mv_cache [ 8 ] [ 1 ] = my ;\n mvd_cache [ 8 ] [ 0 ] = mpx ;\n mvd_cache [ 8 ] [ 1 ] = mpy ;\n }\n mv_cache [ 0 ] [ 0 ] = mx ;\n mv_cache [ 0 ] [ 1 ] = my ;\n mvd_cache [ 0 ] [ 0 ] = mpx ;\n mvd_cache [ 0 ] [ 1 ] = mpy ;\n }\n }\n else {\n fill_rectangle ( h -> mv_cache [ list ] [ scan8 [ 4 * i ] ] , 2 , 2 , 8 , 0 , 4 ) ;\n fill_rectangle ( h -> mvd_cache [ list ] [ scan8 [ 4 * i ] ] , 2 , 2 , 8 , 0 , 2 ) ;\n }\n }\n }\n }\n else if ( IS_DIRECT ( mb_type ) ) {\n ff_h264_pred_direct_motion ( h , & mb_type ) ;\n fill_rectangle ( h -> mvd_cache [ 0 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , 0 , 2 ) ;\n fill_rectangle ( h -> mvd_cache [ 1 ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , 0 , 2 ) ;\n dct8x8_allowed &= h -> sps . direct_8x8_inference_flag ;\n }\n else {\n int list , i ;\n if ( IS_16X16 ( mb_type ) ) {\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n if ( IS_DIR ( mb_type , 0 , list ) ) {\n int ref , rc = h -> ref_count [ list ] << MB_MBAFF ;\n if ( rc > 1 ) {\n ref = decode_cabac_mb_ref ( h , list , 0 ) ;\n if ( ref >= ( unsigned ) rc ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"Reference %d >= %d\\n\" , ref , rc ) ;\n return - 1 ;\n }\n }\n else ref = 0 ;\n fill_rectangle ( & h -> ref_cache [ list ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , ref , 1 ) ;\n }\n }\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n if ( IS_DIR ( mb_type , 0 , list ) ) {\n int mx , my , mpx , mpy ;\n pred_motion ( h , 0 , 4 , list , h -> ref_cache [ list ] [ scan8 [ 0 ] ] , & mx , & my ) ;\n DECODE_CABAC_MB_MVD ( h , list , 0 ) tprintf ( h -> avctx , \"final mv:%d %d\\n\" , mx , my ) ;\n fill_rectangle ( h -> mvd_cache [ list ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , pack8to16 ( mpx , mpy ) , 2 ) ;\n fill_rectangle ( h -> mv_cache [ list ] [ scan8 [ 0 ] ] , 4 , 4 , 8 , pack16to32 ( mx , my ) , 4 ) ;\n }\n }\n }\n else if ( IS_16X8 ( mb_type ) ) {\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( IS_DIR ( mb_type , i , list ) ) {\n int ref , rc = h -> ref_count [ list ] << MB_MBAFF ;\n if ( rc > 1 ) {\n ref = decode_cabac_mb_ref ( h , list , 8 * i ) ;\n if ( ref >= ( unsigned ) rc ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"Reference %d >= %d\\n\" , ref , rc ) ;\n return - 1 ;\n }\n }\n else ref = 0 ;\n fill_rectangle ( & h -> ref_cache [ list ] [ scan8 [ 0 ] + 16 * i ] , 4 , 2 , 8 , ref , 1 ) ;\n }\n else fill_rectangle ( & h -> ref_cache [ list ] [ scan8 [ 0 ] + 16 * i ] , 4 , 2 , 8 , ( LIST_NOT_USED & 0xFF ) , 1 ) ;\n }\n }\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( IS_DIR ( mb_type , i , list ) ) {\n int mx , my , mpx , mpy ;\n pred_16x8_motion ( h , 8 * i , list , h -> ref_cache [ list ] [ scan8 [ 0 ] + 16 * i ] , & mx , & my ) ;\n DECODE_CABAC_MB_MVD ( h , list , 8 * i ) tprintf ( h -> avctx , \"final mv:%d %d\\n\" , mx , my ) ;\n fill_rectangle ( h -> mvd_cache [ list ] [ scan8 [ 0 ] + 16 * i ] , 4 , 2 , 8 , pack8to16 ( mpx , mpy ) , 2 ) ;\n fill_rectangle ( h -> mv_cache [ list ] [ scan8 [ 0 ] + 16 * i ] , 4 , 2 , 8 , pack16to32 ( mx , my ) , 4 ) ;\n }\n else {\n fill_rectangle ( h -> mvd_cache [ list ] [ scan8 [ 0 ] + 16 * i ] , 4 , 2 , 8 , 0 , 2 ) ;\n fill_rectangle ( h -> mv_cache [ list ] [ scan8 [ 0 ] + 16 * i ] , 4 , 2 , 8 , 0 , 4 ) ;\n }\n }\n }\n }\n else {\n assert ( IS_8X16 ( mb_type ) ) ;\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( IS_DIR ( mb_type , i , list ) ) {\n int ref , rc = h -> ref_count [ list ] << MB_MBAFF ;\n if ( rc > 1 ) {\n ref = decode_cabac_mb_ref ( h , list , 4 * i ) ;\n if ( ref >= ( unsigned ) rc ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"Reference %d >= %d\\n\" , ref , rc ) ;\n return - 1 ;\n }\n }\n else ref = 0 ;\n fill_rectangle ( & h -> ref_cache [ list ] [ scan8 [ 0 ] + 2 * i ] , 2 , 4 , 8 , ref , 1 ) ;\n }\n else fill_rectangle ( & h -> ref_cache [ list ] [ scan8 [ 0 ] + 2 * i ] , 2 , 4 , 8 , ( LIST_NOT_USED & 0xFF ) , 1 ) ;\n }\n }\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( IS_DIR ( mb_type , i , list ) ) {\n int mx , my , mpx , mpy ;\n pred_8x16_motion ( h , i * 4 , list , h -> ref_cache [ list ] [ scan8 [ 0 ] + 2 * i ] , & mx , & my ) ;\n DECODE_CABAC_MB_MVD ( h , list , 4 * i ) tprintf ( h -> avctx , \"final mv:%d %d\\n\" , mx , my ) ;\n fill_rectangle ( h -> mvd_cache [ list ] [ scan8 [ 0 ] + 2 * i ] , 2 , 4 , 8 , pack8to16 ( mpx , mpy ) , 2 ) ;\n fill_rectangle ( h -> mv_cache [ list ] [ scan8 [ 0 ] + 2 * i ] , 2 , 4 , 8 , pack16to32 ( mx , my ) , 4 ) ;\n }\n else {\n fill_rectangle ( h -> mvd_cache [ list ] [ scan8 [ 0 ] + 2 * i ] , 2 , 4 , 8 , 0 , 2 ) ;\n fill_rectangle ( h -> mv_cache [ list ] [ scan8 [ 0 ] + 2 * i ] , 2 , 4 , 8 , 0 , 4 ) ;\n }\n }\n }\n }\n }\n if ( IS_INTER ( mb_type ) ) {\n h -> chroma_pred_mode_table [ mb_xy ] = 0 ;\n write_back_motion ( h , mb_type ) ;\n }\n if ( ! IS_INTRA16x16 ( mb_type ) ) {\n cbp = decode_cabac_mb_cbp_luma ( h ) ;\n if ( decode_chroma ) cbp |= decode_cabac_mb_cbp_chroma ( h ) << 4 ;\n }\n h -> cbp_table [ mb_xy ] = h -> cbp = cbp ;\n if ( dct8x8_allowed && ( cbp & 15 ) && ! IS_INTRA ( mb_type ) ) {\n mb_type |= MB_TYPE_8x8DCT * get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 399 + h -> neighbor_transform_size ] ) ;\n }\n if ( CHROMA444 && IS_8x8DCT ( mb_type ) ) {\n int i ;\n uint8_t * nnz_cache = h -> non_zero_count_cache ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( h -> left_type [ LEFT ( i ) ] && ! IS_8x8DCT ( h -> left_type [ LEFT ( i ) ] ) ) {\n nnz_cache [ 3 + 8 * 1 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 2 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 6 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 7 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 11 + 2 * 8 * i ] = nnz_cache [ 3 + 8 * 12 + 2 * 8 * i ] = IS_INTRA ( mb_type ) ? 64 : 0 ;\n }\n }\n if ( h -> top_type && ! IS_8x8DCT ( h -> top_type ) ) {\n uint32_t top_empty = CABAC && ! IS_INTRA ( mb_type ) ? 0 : 0x40404040 ;\n AV_WN32A ( & nnz_cache [ 4 + 8 * 0 ] , top_empty ) ;\n AV_WN32A ( & nnz_cache [ 4 + 8 * 5 ] , top_empty ) ;\n AV_WN32A ( & nnz_cache [ 4 + 8 * 10 ] , top_empty ) ;\n }\n }\n h -> cur_pic . f . mb_type [ mb_xy ] = mb_type ;\n if ( cbp || IS_INTRA16x16 ( mb_type ) ) {\n const uint8_t * scan , * scan8x8 ;\n const uint32_t * qmul ;\n if ( IS_INTERLACED ( mb_type ) ) {\n scan8x8 = h -> qscale ? h -> field_scan8x8 : h -> field_scan8x8_q0 ;\n scan = h -> qscale ? h -> field_scan : h -> field_scan_q0 ;\n }\n else {\n scan8x8 = h -> qscale ? h -> zigzag_scan8x8 : h -> zigzag_scan8x8_q0 ;\n scan = h -> qscale ? h -> zigzag_scan : h -> zigzag_scan_q0 ;\n }\n if ( get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 60 + ( h -> last_qscale_diff != 0 ) ] ) ) {\n int val = 1 ;\n int ctx = 2 ;\n const int max_qp = 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) ;\n while ( get_cabac_noinline ( & h -> cabac , & h -> cabac_state [ 60 + ctx ] ) ) {\n ctx = 3 ;\n val ++ ;\n if ( val > 2 * max_qp ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"cabac decode of qscale diff failed at %d %d\\n\" , h -> mb_x , h -> mb_y ) ;\n return - 1 ;\n }\n }\n if ( val & 0x01 ) val = ( val + 1 ) >> 1 ;\n else val = - ( ( val + 1 ) >> 1 ) ;\n h -> last_qscale_diff = val ;\n h -> qscale += val ;\n if ( ( ( unsigned ) h -> qscale ) > max_qp ) {\n if ( h -> qscale < 0 ) h -> qscale += max_qp + 1 ;\n else h -> qscale -= max_qp + 1 ;\n }\n h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ;\n h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ;\n }\n else h -> last_qscale_diff = 0 ;\n decode_cabac_luma_residual ( h , scan , scan8x8 , pixel_shift , mb_type , cbp , 0 ) ;\n if ( CHROMA444 ) {\n decode_cabac_luma_residual ( h , scan , scan8x8 , pixel_shift , mb_type , cbp , 1 ) ;\n decode_cabac_luma_residual ( h , scan , scan8x8 , pixel_shift , mb_type , cbp , 2 ) ;\n }\n else if ( CHROMA422 ) {\n if ( cbp & 0x30 ) {\n int c ;\n for ( c = 0 ;\n c < 2 ;\n c ++ ) decode_cabac_residual_dc_422 ( h , h -> mb + ( ( 256 + 16 * 16 * c ) << pixel_shift ) , 3 , CHROMA_DC_BLOCK_INDEX + c , chroma422_dc_scan , 8 ) ;\n }\n if ( cbp & 0x20 ) {\n int c , i , i8x8 ;\n for ( c = 0 ;\n c < 2 ;\n c ++ ) {\n int16_t * mb = h -> mb + ( 16 * ( 16 + 16 * c ) << pixel_shift ) ;\n qmul = h -> dequant4_coeff [ c + 1 + ( IS_INTRA ( mb_type ) ? 0 : 3 ) ] [ h -> chroma_qp [ c ] ] ;\n for ( i8x8 = 0 ;\n i8x8 < 2 ;\n i8x8 ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n const int index = 16 + 16 * c + 8 * i8x8 + i ;\n decode_cabac_residual_nondc ( h , mb , 4 , index , scan + 1 , qmul , 15 ) ;\n mb += 16 << pixel_shift ;\n }\n }\n }\n }\n else {\n fill_rectangle ( & h -> non_zero_count_cache [ scan8 [ 16 ] ] , 4 , 4 , 8 , 0 , 1 ) ;\n fill_rectangle ( & h -> non_zero_count_cache [ scan8 [ 32 ] ] , 4 , 4 , 8 , 0 , 1 ) ;\n }\n }\n else {\n if ( cbp & 0x30 ) {\n int c ;\n for ( c = 0 ;\n c < 2 ;\n c ++ ) decode_cabac_residual_dc ( h , h -> mb + ( ( 256 + 16 * 16 * c ) << pixel_shift ) , 3 , CHROMA_DC_BLOCK_INDEX + c , chroma_dc_scan , 4 ) ;\n }\n if ( cbp & 0x20 ) {\n int c , i ;\n for ( c = 0 ;\n c < 2 ;\n c ++ ) {\n qmul = h -> dequant4_coeff [ c + 1 + ( IS_INTRA ( mb_type ) ? 0 : 3 ) ] [ h -> chroma_qp [ c ] ] ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n const int index = 16 + 16 * c + i ;\n decode_cabac_residual_nondc ( h , h -> mb + ( 16 * index << pixel_shift ) , 4 , index , scan + 1 , qmul , 15 ) ;\n }\n }\n }\n else {\n fill_rectangle ( & h -> non_zero_count_cache [ scan8 [ 16 ] ] , 4 , 4 , 8 , 0 , 1 ) ;\n fill_rectangle ( & h -> non_zero_count_cache [ scan8 [ 32 ] ] , 4 , 4 , 8 , 0 , 1 ) ;\n }\n }\n }\n else {\n fill_rectangle ( & h -> non_zero_count_cache [ scan8 [ 0 ] ] , 4 , 4 , 8 , 0 , 1 ) ;\n fill_rectangle ( & h -> non_zero_count_cache [ scan8 [ 16 ] ] , 4 , 4 , 8 , 0 , 1 ) ;\n fill_rectangle ( & h -> non_zero_count_cache [ scan8 [ 32 ] ] , 4 , 4 , 8 , 0 , 1 ) ;\n h -> last_qscale_diff = 0 ;\n }\n h -> cur_pic . f . qscale_table [ mb_xy ] = h -> qscale ;\n write_back_non_zero_count ( h ) ;\n return 0 ;\n }",
        "hash": -4456702502726364053,
        "project": "debian",
        "size": 524,
        "slice": {
            "memset": [
                [
                    1,
                    "int ff_h264_decode_mb_cabac ( H264Context * h ) {\n"
                ],
                [
                    104,
                    " if ( ( int ) ( h -> cabac . bytestream_end - ptr ) < mb_size ) return - 1 ;\n"
                ],
                [
                    111,
                    " memset ( h -> non_zero_count [ mb_xy ] , 16 , 48 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ff_h264_decode_mb_cabac ( H264Context * h ) {\n"
                ],
                [
                    104,
                    " if ( ( int ) ( h -> cabac . bytestream_end - ptr ) < mb_size ) return - 1 ;\n"
                ],
                [
                    111,
                    " memset ( h -> non_zero_count [ mb_xy ] , 16 , 48 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n MDECContext * const a = avctx -> priv_data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AVFrame * picture = data ;\n AVFrame * const p = & a -> picture ;\n int i , ret ;\n if ( p -> data [ 0 ] ) ff_thread_release_buffer ( avctx , p ) ;\n p -> reference = 0 ;\n if ( ( ret = ff_thread_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n av_fast_malloc ( & a -> bitstream_buffer , & a -> bitstream_buffer_size , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! a -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n for ( i = 0 ;\n i < buf_size ;\n i += 2 ) {\n a -> bitstream_buffer [ i ] = buf [ i + 1 ] ;\n a -> bitstream_buffer [ i + 1 ] = buf [ i ] ;\n }\n init_get_bits ( & a -> gb , a -> bitstream_buffer , buf_size * 8 ) ;\n skip_bits ( & a -> gb , 32 ) ;\n a -> qscale = get_bits ( & a -> gb , 16 ) ;\n a -> version = get_bits ( & a -> gb , 16 ) ;\n a -> last_dc [ 0 ] = a -> last_dc [ 1 ] = a -> last_dc [ 2 ] = 128 ;\n for ( a -> mb_x = 0 ;\n a -> mb_x < a -> mb_width ;\n a -> mb_x ++ ) {\n for ( a -> mb_y = 0 ;\n a -> mb_y < a -> mb_height ;\n a -> mb_y ++ ) {\n if ( ( ret = decode_mb ( a , a -> block ) ) < 0 ) return ret ;\n idct_put ( a , a -> mb_x , a -> mb_y ) ;\n }\n }\n p -> quality = a -> qscale * FF_QP2LAMBDA ;\n memset ( p -> qscale_table , a -> qscale , a -> mb_width ) ;\n * picture = a -> picture ;\n * got_frame = 1 ;\n return ( get_bits_count ( & a -> gb ) + 31 ) / 32 * 4 ;\n }",
        "hash": 7078129966845159750,
        "project": "debian",
        "size": 44,
        "slice": {
            "memset": [
                [
                    2,
                    " MDECContext * const a = avctx -> priv_data ;\n"
                ],
                [
                    10,
                    " if ( ( ret = ff_thread_get_buffer ( avctx , p ) ) < 0 ) {\n"
                ],
                [
                    30,
                    " a -> mb_x < a -> mb_width ;\n"
                ],
                [
                    36,
                    " idct_put ( a , a -> mb_x , a -> mb_y ) ;\n"
                ],
                [
                    39,
                    " p -> quality = a -> qscale * FF_QP2LAMBDA ;\n"
                ],
                [
                    40,
                    " memset ( p -> qscale_table , a -> qscale , a -> mb_width ) ;\n"
                ]
            ],
            "result": [
                [
                    2,
                    " MDECContext * const a = avctx -> priv_data ;\n"
                ],
                [
                    10,
                    " if ( ( ret = ff_thread_get_buffer ( avctx , p ) ) < 0 ) {\n"
                ],
                [
                    30,
                    " a -> mb_x < a -> mb_width ;\n"
                ],
                [
                    36,
                    " idct_put ( a , a -> mb_x , a -> mb_y ) ;\n"
                ],
                [
                    39,
                    " p -> quality = a -> qscale * FF_QP2LAMBDA ;\n"
                ],
                [
                    40,
                    " memset ( p -> qscale_table , a -> qscale , a -> mb_width ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int vc1_decode_p_mb_intfi ( VC1Context * v ) {\n MpegEncContext * s = & v -> s ;\n GetBitContext * gb = & s -> gb ;\n int i ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbp = 0 ;\n int mqdiff , mquant ;\n int ttmb = v -> ttfrm ;\n int mb_has_coeffs = 1 ;\n int dmv_x , dmv_y ;\n int val ;\n int first_block = 1 ;\n int dst_idx , off ;\n int pred_flag ;\n int block_cbp = 0 , pat , block_tt = 0 ;\n int idx_mbmode = 0 ;\n mquant = v -> pq ;\n idx_mbmode = get_vlc2 ( gb , v -> mbmode_vlc -> table , VC1_IF_MBMODE_VLC_BITS , 2 ) ;\n if ( idx_mbmode <= 1 ) {\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 1 ] = 0 ;\n s -> current_picture . f . mb_type [ mb_pos + v -> mb_off ] = MB_TYPE_INTRA ;\n GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n v -> s . ac_pred = v -> acpred_plane [ mb_pos ] = get_bits1 ( gb ) ;\n mb_has_coeffs = idx_mbmode & 1 ;\n if ( mb_has_coeffs ) cbp = 1 + get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_ICBPCY_VLC_BITS , 2 ) ;\n dst_idx = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 1 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n v -> a_avail = v -> c_avail = 0 ;\n if ( i == 2 || i == 3 || ! s -> first_slice_line ) v -> a_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - s -> block_wrap [ i ] ] ;\n if ( i == 1 || i == 3 || s -> mb_x ) v -> c_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - 1 ] ;\n vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n if ( ( i > 3 ) && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( s -> block [ i ] ) ;\n off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ) ;\n off += v -> cur_field_type ? ( ( i & 4 ) ? s -> current_picture_ptr -> f . linesize [ 1 ] : s -> current_picture_ptr -> f . linesize [ 0 ] ) : 0 ;\n s -> dsp . put_signed_pixels_clamped ( s -> block [ i ] , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize ) ;\n }\n }\n else {\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n s -> current_picture . f . mb_type [ mb_pos + v -> mb_off ] = MB_TYPE_16x16 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n if ( idx_mbmode <= 5 ) {\n dmv_x = dmv_y = pred_flag = 0 ;\n if ( idx_mbmode & 1 ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , & pred_flag ) ;\n }\n vc1_pred_mv ( v , 0 , dmv_x , dmv_y , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , pred_flag , 0 ) ;\n vc1_mc_1mv ( v , 0 ) ;\n mb_has_coeffs = ! ( idx_mbmode & 2 ) ;\n }\n else {\n v -> fourmvbp = get_vlc2 ( gb , v -> fourmvbp_vlc -> table , VC1_4MV_BLOCK_PATTERN_VLC_BITS , 1 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( i < 4 ) {\n dmv_x = dmv_y = pred_flag = 0 ;\n val = ( ( v -> fourmvbp >> ( 3 - i ) ) & 1 ) ;\n if ( val ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , & pred_flag ) ;\n }\n vc1_pred_mv ( v , i , dmv_x , dmv_y , 0 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] , pred_flag , 0 ) ;\n vc1_mc_4mv_luma ( v , i , 0 ) ;\n }\n else if ( i == 4 ) vc1_mc_4mv_chroma ( v , 0 ) ;\n }\n mb_has_coeffs = idx_mbmode & 1 ;\n }\n if ( mb_has_coeffs ) cbp = 1 + get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n if ( cbp ) {\n GET_MQUANT ( ) ;\n }\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n if ( ! v -> ttmbf && cbp ) {\n ttmb = get_vlc2 ( gb , ff_vc1_ttmb_vlc [ v -> tt_index ] . table , VC1_TTMB_VLC_BITS , 2 ) ;\n }\n dst_idx = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n off = ( i & 4 ) ? 0 : ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ;\n if ( v -> cur_field_type ) off += ( i & 4 ) ? s -> current_picture_ptr -> f . linesize [ 1 ] : s -> current_picture_ptr -> f . linesize [ 0 ] ;\n if ( val ) {\n pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n block_cbp |= pat << ( i << 2 ) ;\n if ( ! v -> ttmbf && ttmb < 8 ) ttmb = - 1 ;\n first_block = 0 ;\n }\n }\n }\n if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n return 0 ;\n }",
        "hash": 6080147530626246065,
        "project": "debian",
        "size": 110,
        "slice": {
            "memmove": [
                [
                    1,
                    "static int vc1_decode_p_mb_intfi ( VC1Context * v ) {\n"
                ],
                [
                    20,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n"
                ],
                [
                    42,
                    " vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n"
                ],
                [
                    51,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n"
                ],
                [
                    62,
                    " vc1_mc_1mv ( v , 0 ) ;\n"
                ],
                [
                    77,
                    " vc1_mc_4mv_luma ( v , i , 0 ) ;\n"
                ],
                [
                    79,
                    " else if ( i == 4 ) vc1_mc_4mv_chroma ( v , 0 ) ;\n"
                ],
                [
                    101,
                    " pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n"
                ],
                [
                    108,
                    " if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int vc1_decode_p_mb_intfi ( VC1Context * v ) {\n"
                ],
                [
                    20,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n"
                ],
                [
                    42,
                    " vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n"
                ],
                [
                    51,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n"
                ],
                [
                    62,
                    " vc1_mc_1mv ( v , 0 ) ;\n"
                ],
                [
                    77,
                    " vc1_mc_4mv_luma ( v , i , 0 ) ;\n"
                ],
                [
                    79,
                    " else if ( i == 4 ) vc1_mc_4mv_chroma ( v , 0 ) ;\n"
                ],
                [
                    101,
                    " pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n"
                ],
                [
                    108,
                    " if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int vc1_decode_i_block_adv ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int codingset , int mquant ) {\n GetBitContext * gb = & v -> s . gb ;\n MpegEncContext * s = & v -> s ;\n int dc_pred_dir = 0 ;\n int i ;\n int16_t * dc_val ;\n int16_t * ac_val , * ac_val2 ;\n int dcdiff ;\n int a_avail = v -> a_avail , c_avail = v -> c_avail ;\n int use_pred = s -> ac_pred ;\n int scale ;\n int q1 , q2 = 0 ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n if ( n < 4 ) {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_luma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n else {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_chroma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n if ( dcdiff < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Illegal DC VLC\\n\" ) ;\n return - 1 ;\n }\n if ( dcdiff ) {\n if ( dcdiff == 119 ) {\n if ( mquant == 1 ) dcdiff = get_bits ( gb , 10 ) ;\n else if ( mquant == 2 ) dcdiff = get_bits ( gb , 9 ) ;\n else dcdiff = get_bits ( gb , 8 ) ;\n }\n else {\n if ( mquant == 1 ) dcdiff = ( dcdiff << 2 ) + get_bits ( gb , 2 ) - 3 ;\n else if ( mquant == 2 ) dcdiff = ( dcdiff << 1 ) + get_bits1 ( gb ) - 1 ;\n }\n if ( get_bits1 ( gb ) ) dcdiff = - dcdiff ;\n }\n dcdiff += vc1_pred_dc ( & v -> s , v -> overlap , mquant , n , v -> a_avail , v -> c_avail , & dc_val , & dc_pred_dir ) ;\n * dc_val = dcdiff ;\n if ( n < 4 ) {\n block [ 0 ] = dcdiff * s -> y_dc_scale ;\n }\n else {\n block [ 0 ] = dcdiff * s -> c_dc_scale ;\n }\n i = 1 ;\n if ( ! a_avail && ! c_avail ) use_pred = 0 ;\n ac_val = s -> ac_val [ 0 ] [ 0 ] + s -> block_index [ n ] * 16 ;\n ac_val2 = ac_val ;\n scale = mquant * 2 + ( ( mquant == v -> pq ) ? v -> halfpq : 0 ) ;\n if ( dc_pred_dir ) ac_val -= 16 ;\n else ac_val -= 16 * s -> block_wrap [ n ] ;\n q1 = s -> current_picture . f . qscale_table [ mb_pos ] ;\n if ( dc_pred_dir && c_avail && mb_pos ) q2 = s -> current_picture . f . qscale_table [ mb_pos - 1 ] ;\n if ( ! dc_pred_dir && a_avail && mb_pos >= s -> mb_stride ) q2 = s -> current_picture . f . qscale_table [ mb_pos - s -> mb_stride ] ;\n if ( dc_pred_dir && n == 1 ) q2 = q1 ;\n if ( ! dc_pred_dir && n == 2 ) q2 = q1 ;\n if ( n == 3 ) q2 = q1 ;\n if ( coded ) {\n int last = 0 , skip , value ;\n const uint8_t * zz_table ;\n int k ;\n if ( v -> s . ac_pred ) {\n if ( ! use_pred && v -> fcm == ILACE_FRAME ) {\n zz_table = v -> zzi_8x8 ;\n }\n else {\n if ( ! dc_pred_dir ) zz_table = v -> zz_8x8 [ 2 ] ;\n else zz_table = v -> zz_8x8 [ 3 ] ;\n }\n }\n else {\n if ( v -> fcm != ILACE_FRAME ) zz_table = v -> zz_8x8 [ 1 ] ;\n else zz_table = v -> zzi_8x8 ;\n }\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , codingset ) ;\n i += skip ;\n if ( i > 63 ) break ;\n block [ zz_table [ i ++ ] ] = value ;\n }\n if ( use_pred ) {\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ( ac_val [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ( ac_val [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n else {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ac_val [ k ] ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ac_val [ k + 8 ] ;\n }\n }\n }\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n ac_val2 [ k ] = block [ k << v -> left_blk_sh ] ;\n ac_val2 [ k + 8 ] = block [ k << v -> top_blk_sh ] ;\n }\n for ( k = 1 ;\n k < 64 ;\n k ++ ) if ( block [ k ] ) {\n block [ k ] *= scale ;\n if ( ! v -> pquantizer ) block [ k ] += ( block [ k ] < 0 ) ? - mquant : mquant ;\n }\n if ( use_pred ) i = 63 ;\n }\n else {\n int k ;\n memset ( ac_val2 , 0 , 16 * 2 ) ;\n if ( dc_pred_dir ) {\n if ( use_pred ) {\n memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n else {\n if ( use_pred ) {\n memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n if ( use_pred ) {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> left_blk_sh ] ) block [ k << v -> left_blk_sh ] += ( block [ k << v -> left_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> top_blk_sh ] ) block [ k << v -> top_blk_sh ] += ( block [ k << v -> top_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n i = 63 ;\n }\n }\n s -> block_last_index [ n ] = i ;\n return 0 ;\n }",
        "hash": 6080147530626246065,
        "project": "debian",
        "size": 174,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int vc1_decode_i_block_adv ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int codingset , int mquant ) {\n"
                ],
                [
                    49,
                    " if ( dc_pred_dir ) ac_val -= 16 ;\n"
                ],
                [
                    50,
                    " else ac_val -= 16 * s -> block_wrap [ n ] ;\n"
                ],
                [
                    125,
                    " memset ( ac_val2 , 0 , 16 * 2 ) ;\n"
                ],
                [
                    127,
                    " if ( use_pred ) {\n"
                ],
                [
                    128,
                    " memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n"
                ],
                [
                    135,
                    " k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n"
                ],
                [
                    140,
                    " if ( use_pred ) {\n"
                ],
                [
                    141,
                    " memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n"
                ],
                [
                    157,
                    " block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n"
                ],
                [
                    165,
                    " block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int vc1_decode_i_block_adv ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int codingset , int mquant ) {\n"
                ],
                [
                    47,
                    " ac_val2 = ac_val ;\n"
                ],
                [
                    57,
                    " if ( coded ) {\n"
                ],
                [
                    125,
                    " memset ( ac_val2 , 0 , 16 * 2 ) ;\n"
                ],
                [
                    128,
                    " memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n"
                ],
                [
                    141,
                    " memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n"
                ],
                [
                    148,
                    " k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n"
                ],
                [
                    157,
                    " block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n"
                ],
                [
                    165,
                    " block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int vc1_decode_i_block_adv ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int codingset , int mquant ) {\n"
                ],
                [
                    47,
                    " ac_val2 = ac_val ;\n"
                ],
                [
                    49,
                    " if ( dc_pred_dir ) ac_val -= 16 ;\n"
                ],
                [
                    50,
                    " else ac_val -= 16 * s -> block_wrap [ n ] ;\n"
                ],
                [
                    57,
                    " if ( coded ) {\n"
                ],
                [
                    125,
                    " memset ( ac_val2 , 0 , 16 * 2 ) ;\n"
                ],
                [
                    127,
                    " if ( use_pred ) {\n"
                ],
                [
                    128,
                    " memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n"
                ],
                [
                    135,
                    " k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n"
                ],
                [
                    140,
                    " if ( use_pred ) {\n"
                ],
                [
                    141,
                    " memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n"
                ],
                [
                    148,
                    " k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n"
                ],
                [
                    157,
                    " block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n"
                ],
                [
                    165,
                    " block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int vc1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size , n_slices = 0 , i ;\n VC1Context * v = avctx -> priv_data ;\n MpegEncContext * s = & v -> s ;\n AVFrame * pict = data ;\n uint8_t * buf2 = NULL ;\n const uint8_t * buf_start = buf ;\n int mb_height , n_slices1 ;\n struct {\n uint8_t * buf ;\n GetBitContext gb ;\n int mby_start ;\n }\n * slices = NULL , * tmp ;\n if ( buf_size == 0 || ( buf_size == 4 && AV_RB32 ( buf ) == VC1_CODE_ENDOFSEQ ) ) {\n if ( s -> low_delay == 0 && s -> next_picture_ptr ) {\n * pict = s -> next_picture_ptr -> f ;\n s -> next_picture_ptr = NULL ;\n * got_frame = 1 ;\n }\n return 0 ;\n }\n if ( s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) {\n if ( v -> profile < PROFILE_ADVANCED ) avctx -> pix_fmt = AV_PIX_FMT_VDPAU_WMV3 ;\n else avctx -> pix_fmt = AV_PIX_FMT_VDPAU_VC1 ;\n }\n if ( avctx -> codec_id == AV_CODEC_ID_VC1 || avctx -> codec_id == AV_CODEC_ID_VC1IMAGE ) {\n int buf_size2 = 0 ;\n buf2 = av_mallocz ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( IS_MARKER ( AV_RB32 ( buf ) ) ) {\n const uint8_t * start , * end , * next ;\n int size ;\n next = buf ;\n for ( start = buf , end = buf + buf_size ;\n next < end ;\n start = next ) {\n next = find_next_marker ( start + 4 , end ) ;\n size = next - start - 4 ;\n if ( size <= 0 ) continue ;\n switch ( AV_RB32 ( start ) ) {\n case VC1_CODE_FRAME : if ( avctx -> hwaccel || s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) buf_start = start ;\n buf_size2 = vc1_unescape_buffer ( start + 4 , size , buf2 ) ;\n break ;\n case VC1_CODE_FIELD : {\n int buf_size3 ;\n tmp = av_realloc ( slices , sizeof ( * slices ) * ( n_slices + 1 ) ) ;\n if ( ! tmp ) goto err ;\n slices = tmp ;\n slices [ n_slices ] . buf = av_mallocz ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! slices [ n_slices ] . buf ) goto err ;\n buf_size3 = vc1_unescape_buffer ( start + 4 , size , slices [ n_slices ] . buf ) ;\n init_get_bits ( & slices [ n_slices ] . gb , slices [ n_slices ] . buf , buf_size3 << 3 ) ;\n slices [ n_slices ] . mby_start = s -> mb_height >> 1 ;\n n_slices1 = n_slices - 1 ;\n n_slices ++ ;\n break ;\n }\n case VC1_CODE_ENTRYPOINT : buf_size2 = vc1_unescape_buffer ( start + 4 , size , buf2 ) ;\n init_get_bits ( & s -> gb , buf2 , buf_size2 * 8 ) ;\n ff_vc1_decode_entry_point ( avctx , v , & s -> gb ) ;\n break ;\n case VC1_CODE_SLICE : {\n int buf_size3 ;\n tmp = av_realloc ( slices , sizeof ( * slices ) * ( n_slices + 1 ) ) ;\n if ( ! tmp ) goto err ;\n slices = tmp ;\n slices [ n_slices ] . buf = av_mallocz ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! slices [ n_slices ] . buf ) goto err ;\n buf_size3 = vc1_unescape_buffer ( start + 4 , size , slices [ n_slices ] . buf ) ;\n init_get_bits ( & slices [ n_slices ] . gb , slices [ n_slices ] . buf , buf_size3 << 3 ) ;\n slices [ n_slices ] . mby_start = get_bits ( & slices [ n_slices ] . gb , 9 ) ;\n n_slices ++ ;\n break ;\n }\n }\n }\n }\n else if ( v -> interlace && ( ( buf [ 0 ] & 0xC0 ) == 0xC0 ) ) {\n const uint8_t * divider ;\n int buf_size3 ;\n divider = find_next_marker ( buf , buf + buf_size ) ;\n if ( ( divider == ( buf + buf_size ) ) || AV_RB32 ( divider ) != VC1_CODE_FIELD ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error in WVC1 interlaced frame\\n\" ) ;\n goto err ;\n }\n else {\n tmp = av_realloc ( slices , sizeof ( * slices ) * ( n_slices + 1 ) ) ;\n if ( ! tmp ) goto err ;\n slices = tmp ;\n slices [ n_slices ] . buf = av_mallocz ( buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n if ( ! slices [ n_slices ] . buf ) goto err ;\n buf_size3 = vc1_unescape_buffer ( divider + 4 , buf + buf_size - divider - 4 , slices [ n_slices ] . buf ) ;\n init_get_bits ( & slices [ n_slices ] . gb , slices [ n_slices ] . buf , buf_size3 << 3 ) ;\n slices [ n_slices ] . mby_start = s -> mb_height >> 1 ;\n n_slices1 = n_slices - 1 ;\n n_slices ++ ;\n }\n buf_size2 = vc1_unescape_buffer ( buf , divider - buf , buf2 ) ;\n }\n else {\n buf_size2 = vc1_unescape_buffer ( buf , buf_size , buf2 ) ;\n }\n init_get_bits ( & s -> gb , buf2 , buf_size2 * 8 ) ;\n }\n else init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n if ( v -> res_sprite ) {\n v -> new_sprite = ! get_bits1 ( & s -> gb ) ;\n v -> two_sprites = get_bits1 ( & s -> gb ) ;\n if ( avctx -> codec_id == AV_CODEC_ID_WMV3IMAGE || avctx -> codec_id == AV_CODEC_ID_VC1IMAGE ) {\n if ( v -> new_sprite ) {\n avctx -> width = avctx -> coded_width = v -> sprite_width ;\n avctx -> height = avctx -> coded_height = v -> sprite_height ;\n }\n else {\n goto image ;\n }\n }\n }\n if ( s -> context_initialized && ( s -> width != avctx -> coded_width || s -> height != avctx -> coded_height ) ) {\n ff_vc1_decode_end ( avctx ) ;\n }\n if ( ! s -> context_initialized ) {\n if ( ff_msmpeg4_decode_init ( avctx ) < 0 || ff_vc1_decode_init_alloc_tables ( v ) < 0 ) goto err ;\n s -> low_delay = ! avctx -> has_b_frames || v -> res_sprite ;\n if ( v -> profile == PROFILE_ADVANCED ) {\n s -> h_edge_pos = avctx -> coded_width ;\n s -> v_edge_pos = avctx -> coded_height ;\n }\n }\n if ( s -> current_picture_ptr == NULL || s -> current_picture_ptr -> f . data [ 0 ] ) {\n int i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) goto err ;\n s -> current_picture_ptr = & s -> picture [ i ] ;\n }\n v -> pic_header_flag = 0 ;\n if ( v -> profile < PROFILE_ADVANCED ) {\n if ( ff_vc1_parse_frame_header ( v , & s -> gb ) == - 1 ) {\n goto err ;\n }\n }\n else {\n if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) == - 1 ) {\n goto err ;\n }\n }\n if ( ( avctx -> codec_id == AV_CODEC_ID_WMV3IMAGE || avctx -> codec_id == AV_CODEC_ID_VC1IMAGE ) && s -> pict_type != AV_PICTURE_TYPE_I ) {\n av_log ( v -> s . avctx , AV_LOG_ERROR , \"Sprite decoder: expected I-frame\\n\" ) ;\n goto err ;\n }\n s -> current_picture_ptr -> f . repeat_pict = 0 ;\n if ( v -> rff ) {\n s -> current_picture_ptr -> f . repeat_pict = 1 ;\n }\n else if ( v -> rptfrm ) {\n s -> current_picture_ptr -> f . repeat_pict = v -> rptfrm * 2 ;\n }\n s -> current_picture . f . pict_type = s -> pict_type ;\n s -> current_picture . f . key_frame = s -> pict_type == AV_PICTURE_TYPE_I ;\n if ( s -> last_picture_ptr == NULL && ( s -> pict_type == AV_PICTURE_TYPE_B || s -> droppable ) ) {\n goto err ;\n }\n if ( ( avctx -> skip_frame >= AVDISCARD_NONREF && s -> pict_type == AV_PICTURE_TYPE_B ) || ( avctx -> skip_frame >= AVDISCARD_NONKEY && s -> pict_type != AV_PICTURE_TYPE_I ) || avctx -> skip_frame >= AVDISCARD_ALL ) {\n goto end ;\n }\n if ( s -> next_p_frame_damaged ) {\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) goto end ;\n else s -> next_p_frame_damaged = 0 ;\n }\n if ( ff_MPV_frame_start ( s , avctx ) < 0 ) {\n goto err ;\n }\n s -> me . qpel_put = s -> dsp . put_qpel_pixels_tab ;\n s -> me . qpel_avg = s -> dsp . avg_qpel_pixels_tab ;\n if ( ( CONFIG_VC1_VDPAU_DECODER ) && s -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) ff_vdpau_vc1_decode_picture ( s , buf_start , ( buf + buf_size ) - buf_start ) ;\n else if ( avctx -> hwaccel ) {\n if ( avctx -> hwaccel -> start_frame ( avctx , buf , buf_size ) < 0 ) goto err ;\n if ( avctx -> hwaccel -> decode_slice ( avctx , buf_start , ( buf + buf_size ) - buf_start ) < 0 ) goto err ;\n if ( avctx -> hwaccel -> end_frame ( avctx ) < 0 ) goto err ;\n }\n else {\n ff_mpeg_er_frame_start ( s ) ;\n v -> bits = buf_size * 8 ;\n v -> end_mb_x = s -> mb_width ;\n if ( v -> field_mode ) {\n uint8_t * tmp [ 2 ] ;\n s -> current_picture . f . linesize [ 0 ] <<= 1 ;\n s -> current_picture . f . linesize [ 1 ] <<= 1 ;\n s -> current_picture . f . linesize [ 2 ] <<= 1 ;\n s -> linesize <<= 1 ;\n s -> uvlinesize <<= 1 ;\n tmp [ 0 ] = v -> mv_f_last [ 0 ] ;\n tmp [ 1 ] = v -> mv_f_last [ 1 ] ;\n v -> mv_f_last [ 0 ] = v -> mv_f_next [ 0 ] ;\n v -> mv_f_last [ 1 ] = v -> mv_f_next [ 1 ] ;\n v -> mv_f_next [ 0 ] = v -> mv_f [ 0 ] ;\n v -> mv_f_next [ 1 ] = v -> mv_f [ 1 ] ;\n v -> mv_f [ 0 ] = tmp [ 0 ] ;\n v -> mv_f [ 1 ] = tmp [ 1 ] ;\n }\n mb_height = s -> mb_height >> v -> field_mode ;\n for ( i = 0 ;\n i <= n_slices ;\n i ++ ) {\n if ( i > 0 && slices [ i - 1 ] . mby_start >= mb_height ) {\n if ( v -> field_mode <= 0 ) {\n av_log ( v -> s . avctx , AV_LOG_ERROR , \"Slice %d starts beyond \" \"picture boundary (%d >= %d)\\n\" , i , slices [ i - 1 ] . mby_start , mb_height ) ;\n continue ;\n }\n v -> second_field = 1 ;\n v -> blocks_off = s -> mb_width * s -> mb_height << 1 ;\n v -> mb_off = s -> mb_stride * s -> mb_height >> 1 ;\n }\n else {\n v -> second_field = 0 ;\n v -> blocks_off = 0 ;\n v -> mb_off = 0 ;\n }\n if ( i ) {\n v -> pic_header_flag = 0 ;\n if ( v -> field_mode && i == n_slices1 + 2 ) {\n if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n av_log ( v -> s . avctx , AV_LOG_ERROR , \"Field header damaged\\n\" ) ;\n continue ;\n }\n }\n else if ( get_bits1 ( & s -> gb ) ) {\n v -> pic_header_flag = 1 ;\n if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n av_log ( v -> s . avctx , AV_LOG_ERROR , \"Slice header damaged\\n\" ) ;\n continue ;\n }\n }\n }\n s -> start_mb_y = ( i == 0 ) ? 0 : FFMAX ( 0 , slices [ i - 1 ] . mby_start % mb_height ) ;\n if ( ! v -> field_mode || v -> second_field ) s -> end_mb_y = ( i == n_slices ) ? mb_height : FFMIN ( mb_height , slices [ i ] . mby_start % mb_height ) ;\n else s -> end_mb_y = ( i <= n_slices1 + 1 ) ? mb_height : FFMIN ( mb_height , slices [ i ] . mby_start % mb_height ) ;\n ff_vc1_decode_blocks ( v ) ;\n if ( i != n_slices ) s -> gb = slices [ i ] . gb ;\n }\n if ( v -> field_mode ) {\n v -> second_field = 0 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n memcpy ( v -> mv_f_base , v -> mv_f_next_base , 2 * ( s -> b8_stride * ( s -> mb_height * 2 + 1 ) + s -> mb_stride * ( s -> mb_height + 1 ) * 2 ) ) ;\n }\n s -> current_picture . f . linesize [ 0 ] >>= 1 ;\n s -> current_picture . f . linesize [ 1 ] >>= 1 ;\n s -> current_picture . f . linesize [ 2 ] >>= 1 ;\n s -> linesize >>= 1 ;\n s -> uvlinesize >>= 1 ;\n }\n av_dlog ( s -> avctx , \"Consumed %i/%i bits\\n\" , get_bits_count ( & s -> gb ) , s -> gb . size_in_bits ) ;\n ff_er_frame_end ( & s -> er ) ;\n }\n ff_MPV_frame_end ( s ) ;\n if ( avctx -> codec_id == AV_CODEC_ID_WMV3IMAGE || avctx -> codec_id == AV_CODEC_ID_VC1IMAGE ) {\n image : avctx -> width = avctx -> coded_width = v -> output_width ;\n avctx -> height = avctx -> coded_height = v -> output_height ;\n if ( avctx -> skip_frame >= AVDISCARD_NONREF ) goto end ;\n # if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER if ( vc1_decode_sprites ( v , & s -> gb ) ) goto err ;\n # endif * pict = v -> sprite_output_frame ;\n * got_frame = 1 ;\n }\n else {\n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {\n * pict = s -> current_picture_ptr -> f ;\n }\n else if ( s -> last_picture_ptr != NULL ) {\n * pict = s -> last_picture_ptr -> f ;\n }\n if ( s -> last_picture_ptr || s -> low_delay ) {\n * got_frame = 1 ;\n ff_print_debug_info ( s , pict ) ;\n }\n }\n end : av_free ( buf2 ) ;\n for ( i = 0 ;\n i < n_slices ;\n i ++ ) av_free ( slices [ i ] . buf ) ;\n av_free ( slices ) ;\n return buf_size ;\n err : av_free ( buf2 ) ;\n for ( i = 0 ;\n i < n_slices ;\n i ++ ) av_free ( slices [ i ] . buf ) ;\n av_free ( slices ) ;\n return - 1 ;\n }",
        "hash": 6080147530626246065,
        "project": "debian",
        "size": 288,
        "slice": {
            "memcpy": [
                [
                    138,
                    " if ( ff_vc1_parse_frame_header ( v , & s -> gb ) == - 1 ) {\n"
                ],
                [
                    143,
                    " if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) == - 1 ) {\n"
                ],
                [
                    222,
                    " if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n"
                ],
                [
                    229,
                    " if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n"
                ],
                [
                    238,
                    " ff_vc1_decode_blocks ( v ) ;\n"
                ],
                [
                    243,
                    " if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n"
                ],
                [
                    244,
                    " memcpy ( v -> mv_f_base , v -> mv_f_next_base , 2 * ( s -> b8_stride * ( s -> mb_height * 2 + 1 ) + s -> mb_stride * ( s -> mb_height + 1 ) * 2 ) ) ;\n"
                ]
            ],
            "result": [
                [
                    138,
                    " if ( ff_vc1_parse_frame_header ( v , & s -> gb ) == - 1 ) {\n"
                ],
                [
                    143,
                    " if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) == - 1 ) {\n"
                ],
                [
                    222,
                    " if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n"
                ],
                [
                    229,
                    " if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n"
                ],
                [
                    238,
                    " ff_vc1_decode_blocks ( v ) ;\n"
                ],
                [
                    243,
                    " if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n"
                ],
                [
                    244,
                    " memcpy ( v -> mv_f_base , v -> mv_f_next_base , 2 * ( s -> b8_stride * ( s -> mb_height * 2 + 1 ) + s -> mb_stride * ( s -> mb_height + 1 ) * 2 ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void vc1_decode_i_blocks_adv ( VC1Context * v ) {\n int k ;\n MpegEncContext * s = & v -> s ;\n int cbp , val ;\n uint8_t * coded_val ;\n int mb_pos ;\n int mquant = v -> pq ;\n int mqdiff ;\n GetBitContext * gb = & s -> gb ;\n switch ( v -> y_ac_table_index ) {\n case 0 : v -> codingset = ( v -> pqindex <= 8 ) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA ;\n break ;\n case 1 : v -> codingset = CS_HIGH_MOT_INTRA ;\n break ;\n case 2 : v -> codingset = CS_MID_RATE_INTRA ;\n break ;\n }\n switch ( v -> c_ac_table_index ) {\n case 0 : v -> codingset2 = ( v -> pqindex <= 8 ) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER ;\n break ;\n case 1 : v -> codingset2 = CS_HIGH_MOT_INTER ;\n break ;\n case 2 : v -> codingset2 = CS_MID_RATE_INTER ;\n break ;\n }\n s -> mb_x = s -> mb_y = 0 ;\n s -> mb_intra = 1 ;\n s -> first_slice_line = 1 ;\n s -> mb_y = s -> start_mb_y ;\n if ( s -> start_mb_y ) {\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n memset ( & s -> coded_block [ s -> block_index [ 0 ] - s -> b8_stride ] , 0 , ( 1 + s -> b8_stride ) * sizeof ( * s -> coded_block ) ) ;\n }\n for ( ;\n s -> mb_y < s -> end_mb_y ;\n s -> mb_y ++ ) {\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n for ( ;\n s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n int16_t ( * block ) [ 64 ] = v -> block [ v -> cur_blk_idx ] ;\n ff_update_block_index ( s ) ;\n s -> dsp . clear_blocks ( block [ 0 ] ) ;\n mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n s -> current_picture . f . mb_type [ mb_pos + v -> mb_off ] = MB_TYPE_INTRA ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] + v -> blocks_off ] [ 1 ] = 0 ;\n if ( v -> fieldtx_is_raw ) v -> fieldtx_plane [ mb_pos ] = get_bits1 ( & v -> s . gb ) ;\n cbp = get_vlc2 ( & v -> s . gb , ff_msmp4_mb_i_vlc . table , MB_INTRA_VLC_BITS , 2 ) ;\n if ( v -> acpred_is_raw ) v -> s . ac_pred = get_bits1 ( & v -> s . gb ) ;\n else v -> s . ac_pred = v -> acpred_plane [ mb_pos ] ;\n if ( v -> condover == CONDOVER_SELECT && v -> overflg_is_raw ) v -> over_flags_plane [ mb_pos ] = get_bits1 ( & v -> s . gb ) ;\n GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n for ( k = 0 ;\n k < 6 ;\n k ++ ) {\n val = ( ( cbp >> ( 5 - k ) ) & 1 ) ;\n if ( k < 4 ) {\n int pred = vc1_coded_block_pred ( & v -> s , k , & coded_val ) ;\n val = val ^ pred ;\n * coded_val = val ;\n }\n cbp |= val << ( 5 - k ) ;\n v -> a_avail = ! s -> first_slice_line || ( k == 2 || k == 3 ) ;\n v -> c_avail = ! ! s -> mb_x || ( k == 1 || k == 3 ) ;\n vc1_decode_i_block_adv ( v , block [ k ] , k , val , ( k < 4 ) ? v -> codingset : v -> codingset2 , mquant ) ;\n if ( k > 3 && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( block [ k ] ) ;\n }\n vc1_smooth_overlap_filter_iblk ( v ) ;\n vc1_put_signed_blocks_clamped ( v ) ;\n if ( v -> s . loop_filter ) vc1_loop_filter_iblk_delayed ( v , v -> pq ) ;\n if ( get_bits_count ( & s -> gb ) > v -> bits ) {\n ff_er_add_slice ( & s -> er , 0 , s -> start_mb_y , s -> mb_x , s -> mb_y , ER_MB_ERROR ) ;\n av_log ( s -> avctx , AV_LOG_ERROR , \"Bits overconsumption: %i > %i\\n\" , get_bits_count ( & s -> gb ) , v -> bits ) ;\n return ;\n }\n }\n if ( ! v -> s . loop_filter ) ff_mpeg_draw_horiz_band ( s , s -> mb_y * 16 , 16 ) ;\n else if ( s -> mb_y ) ff_mpeg_draw_horiz_band ( s , ( s -> mb_y - 1 ) * 16 , 16 ) ;\n s -> first_slice_line = 0 ;\n }\n s -> mb_x = 0 ;\n ff_init_block_index ( s ) ;\n for ( ;\n s -> mb_x < s -> mb_width ;\n s -> mb_x ++ ) {\n ff_update_block_index ( s ) ;\n vc1_put_signed_blocks_clamped ( v ) ;\n if ( v -> s . loop_filter ) vc1_loop_filter_iblk_delayed ( v , v -> pq ) ;\n }\n if ( v -> s . loop_filter ) ff_mpeg_draw_horiz_band ( s , ( s -> end_mb_y - 1 ) * 16 , 16 ) ;\n ff_er_add_slice ( & s -> er , 0 , s -> start_mb_y << v -> field_mode , s -> mb_width - 1 , ( s -> end_mb_y << v -> field_mode ) - 1 , ER_MB_END ) ;\n }",
        "hash": 6080147530626246065,
        "project": "debian",
        "size": 99,
        "slice": {
            "memset": [
                [
                    1,
                    "static void vc1_decode_i_blocks_adv ( VC1Context * v ) {\n"
                ],
                [
                    30,
                    " if ( s -> start_mb_y ) {\n"
                ],
                [
                    33,
                    " memset ( & s -> coded_block [ s -> block_index [ 0 ] - s -> b8_stride ] , 0 , ( 1 + s -> b8_stride ) * sizeof ( * s -> coded_block ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void vc1_decode_i_blocks_adv ( VC1Context * v ) {\n"
                ],
                [
                    30,
                    " if ( s -> start_mb_y ) {\n"
                ],
                [
                    33,
                    " memset ( & s -> coded_block [ s -> block_index [ 0 ] - s -> b8_stride ] , 0 , ( 1 + s -> b8_stride ) * sizeof ( * s -> coded_block ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n GetBitContext * gb = & v -> s . gb ;\n MpegEncContext * s = & v -> s ;\n int dc_pred_dir = 0 ;\n int i ;\n int16_t * dc_val ;\n int16_t * ac_val , * ac_val2 ;\n int dcdiff ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int a_avail = v -> a_avail , c_avail = v -> c_avail ;\n int use_pred = s -> ac_pred ;\n int scale ;\n int q1 , q2 = 0 ;\n s -> dsp . clear_block ( block ) ;\n mquant = ( mquant < 1 ) ? 0 : ( ( mquant > 31 ) ? 31 : mquant ) ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n if ( n < 4 ) {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_luma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n else {\n dcdiff = get_vlc2 ( & s -> gb , ff_msmp4_dc_chroma_vlc [ s -> dc_table_index ] . table , DC_VLC_BITS , 3 ) ;\n }\n if ( dcdiff < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Illegal DC VLC\\n\" ) ;\n return - 1 ;\n }\n if ( dcdiff ) {\n if ( dcdiff == 119 ) {\n if ( mquant == 1 ) dcdiff = get_bits ( gb , 10 ) ;\n else if ( mquant == 2 ) dcdiff = get_bits ( gb , 9 ) ;\n else dcdiff = get_bits ( gb , 8 ) ;\n }\n else {\n if ( mquant == 1 ) dcdiff = ( dcdiff << 2 ) + get_bits ( gb , 2 ) - 3 ;\n else if ( mquant == 2 ) dcdiff = ( dcdiff << 1 ) + get_bits1 ( gb ) - 1 ;\n }\n if ( get_bits1 ( gb ) ) dcdiff = - dcdiff ;\n }\n dcdiff += vc1_pred_dc ( & v -> s , v -> overlap , mquant , n , a_avail , c_avail , & dc_val , & dc_pred_dir ) ;\n * dc_val = dcdiff ;\n if ( n < 4 ) {\n block [ 0 ] = dcdiff * s -> y_dc_scale ;\n }\n else {\n block [ 0 ] = dcdiff * s -> c_dc_scale ;\n }\n i = 1 ;\n if ( ! a_avail ) dc_pred_dir = 1 ;\n if ( ! c_avail ) dc_pred_dir = 0 ;\n if ( ! a_avail && ! c_avail ) use_pred = 0 ;\n ac_val = s -> ac_val [ 0 ] [ 0 ] + s -> block_index [ n ] * 16 ;\n ac_val2 = ac_val ;\n scale = mquant * 2 + v -> halfpq ;\n if ( dc_pred_dir ) ac_val -= 16 ;\n else ac_val -= 16 * s -> block_wrap [ n ] ;\n q1 = s -> current_picture . f . qscale_table [ mb_pos ] ;\n if ( dc_pred_dir && c_avail && mb_pos ) q2 = s -> current_picture . f . qscale_table [ mb_pos - 1 ] ;\n if ( ! dc_pred_dir && a_avail && mb_pos >= s -> mb_stride ) q2 = s -> current_picture . f . qscale_table [ mb_pos - s -> mb_stride ] ;\n if ( dc_pred_dir && n == 1 ) q2 = q1 ;\n if ( ! dc_pred_dir && n == 2 ) q2 = q1 ;\n if ( n == 3 ) q2 = q1 ;\n if ( coded ) {\n int last = 0 , skip , value ;\n int k ;\n while ( ! last ) {\n vc1_decode_ac_coeff ( v , & last , & skip , & value , codingset ) ;\n i += skip ;\n if ( i > 63 ) break ;\n if ( v -> fcm == PROGRESSIVE ) block [ v -> zz_8x8 [ 0 ] [ i ++ ] ] = value ;\n else {\n if ( use_pred && ( v -> fcm == ILACE_FRAME ) ) {\n if ( ! dc_pred_dir ) block [ v -> zz_8x8 [ 2 ] [ i ++ ] ] = value ;\n else block [ v -> zz_8x8 [ 3 ] [ i ++ ] ] = value ;\n }\n else {\n block [ v -> zzi_8x8 [ i ++ ] ] = value ;\n }\n }\n }\n if ( use_pred ) {\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ( ac_val [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ( ac_val [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n else {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> left_blk_sh ] += ac_val [ k ] ;\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) block [ k << v -> top_blk_sh ] += ac_val [ k + 8 ] ;\n }\n }\n }\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n ac_val2 [ k ] = block [ k << v -> left_blk_sh ] ;\n ac_val2 [ k + 8 ] = block [ k << v -> top_blk_sh ] ;\n }\n for ( k = 1 ;\n k < 64 ;\n k ++ ) if ( block [ k ] ) {\n block [ k ] *= scale ;\n if ( ! v -> pquantizer ) block [ k ] += ( block [ k ] < 0 ) ? - mquant : mquant ;\n }\n if ( use_pred ) i = 63 ;\n }\n else {\n int k ;\n memset ( ac_val2 , 0 , 16 * 2 ) ;\n if ( dc_pred_dir ) {\n if ( use_pred ) {\n memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n else {\n if ( use_pred ) {\n memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n if ( q2 && q1 != q2 ) {\n q1 = q1 * 2 + ( ( q1 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n q2 = q2 * 2 + ( ( q2 == v -> pq ) ? v -> halfpq : 0 ) - 1 ;\n if ( q1 < 1 ) return AVERROR_INVALIDDATA ;\n for ( k = 1 ;\n k < 8 ;\n k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n }\n }\n }\n if ( use_pred ) {\n if ( dc_pred_dir ) {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> left_blk_sh ] ) block [ k << v -> left_blk_sh ] += ( block [ k << v -> left_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n else {\n for ( k = 1 ;\n k < 8 ;\n k ++ ) {\n block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n if ( ! v -> pquantizer && block [ k << v -> top_blk_sh ] ) block [ k << v -> top_blk_sh ] += ( block [ k << v -> top_blk_sh ] < 0 ) ? - mquant : mquant ;\n }\n }\n i = 63 ;\n }\n }\n s -> block_last_index [ n ] = i ;\n return 0 ;\n }",
        "hash": 6080147530626246065,
        "project": "debian",
        "size": 175,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n"
                ],
                [
                    55,
                    " if ( dc_pred_dir ) ac_val -= 16 ;\n"
                ],
                [
                    56,
                    " else ac_val -= 16 * s -> block_wrap [ n ] ;\n"
                ],
                [
                    126,
                    " memset ( ac_val2 , 0 , 16 * 2 ) ;\n"
                ],
                [
                    128,
                    " if ( use_pred ) {\n"
                ],
                [
                    129,
                    " memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n"
                ],
                [
                    136,
                    " k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n"
                ],
                [
                    141,
                    " if ( use_pred ) {\n"
                ],
                [
                    142,
                    " memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n"
                ],
                [
                    158,
                    " block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n"
                ],
                [
                    166,
                    " block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n"
                ],
                [
                    53,
                    " ac_val2 = ac_val ;\n"
                ],
                [
                    63,
                    " if ( coded ) {\n"
                ],
                [
                    126,
                    " memset ( ac_val2 , 0 , 16 * 2 ) ;\n"
                ],
                [
                    129,
                    " memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n"
                ],
                [
                    142,
                    " memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n"
                ],
                [
                    149,
                    " k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n"
                ],
                [
                    158,
                    " block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n"
                ],
                [
                    166,
                    " block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n"
                ],
                [
                    53,
                    " ac_val2 = ac_val ;\n"
                ],
                [
                    55,
                    " if ( dc_pred_dir ) ac_val -= 16 ;\n"
                ],
                [
                    56,
                    " else ac_val -= 16 * s -> block_wrap [ n ] ;\n"
                ],
                [
                    63,
                    " if ( coded ) {\n"
                ],
                [
                    126,
                    " memset ( ac_val2 , 0 , 16 * 2 ) ;\n"
                ],
                [
                    128,
                    " if ( use_pred ) {\n"
                ],
                [
                    129,
                    " memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n"
                ],
                [
                    136,
                    " k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n"
                ],
                [
                    141,
                    " if ( use_pred ) {\n"
                ],
                [
                    142,
                    " memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n"
                ],
                [
                    149,
                    " k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n"
                ],
                [
                    158,
                    " block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n"
                ],
                [
                    166,
                    " block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int vc1_decode_p_mb_intfr ( VC1Context * v ) {\n MpegEncContext * s = & v -> s ;\n GetBitContext * gb = & s -> gb ;\n int i ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbp = 0 ;\n int mqdiff , mquant ;\n int ttmb = v -> ttfrm ;\n int mb_has_coeffs = 1 ;\n int dmv_x , dmv_y ;\n int val ;\n int first_block = 1 ;\n int dst_idx , off ;\n int skipped , fourmv = 0 , twomv = 0 ;\n int block_cbp = 0 , pat , block_tt = 0 ;\n int idx_mbmode = 0 , mvbp ;\n int stride_y , fieldtx ;\n mquant = v -> pq ;\n if ( v -> skip_is_raw ) skipped = get_bits1 ( gb ) ;\n else skipped = v -> s . mbskip_table [ mb_pos ] ;\n if ( ! skipped ) {\n if ( v -> fourmvswitch ) idx_mbmode = get_vlc2 ( gb , v -> mbmode_vlc -> table , VC1_INTFR_4MV_MBMODE_VLC_BITS , 2 ) ;\n else idx_mbmode = get_vlc2 ( gb , v -> mbmode_vlc -> table , VC1_INTFR_NON4MV_MBMODE_VLC_BITS , 2 ) ;\n switch ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] ) {\n case MV_PMODE_INTFR_4MV : fourmv = 1 ;\n v -> blk_mv_type [ s -> block_index [ 0 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 0 ;\n break ;\n case MV_PMODE_INTFR_4MV_FIELD : fourmv = 1 ;\n v -> blk_mv_type [ s -> block_index [ 0 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 1 ;\n break ;\n case MV_PMODE_INTFR_2MV_FIELD : twomv = 1 ;\n v -> blk_mv_type [ s -> block_index [ 0 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 1 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 1 ;\n break ;\n case MV_PMODE_INTFR_1MV : v -> blk_mv_type [ s -> block_index [ 0 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 0 ;\n break ;\n }\n if ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] == MV_PMODE_INTFR_INTRA ) {\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] ] [ 0 ] = 0 ;\n s -> current_picture . f . motion_val [ 1 ] [ s -> block_index [ 0 ] ] [ 1 ] = 0 ;\n s -> current_picture . f . mb_type [ mb_pos ] = MB_TYPE_INTRA ;\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 1 ;\n fieldtx = v -> fieldtx_plane [ mb_pos ] = get_bits1 ( gb ) ;\n mb_has_coeffs = get_bits1 ( gb ) ;\n if ( mb_has_coeffs ) cbp = 1 + get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n v -> s . ac_pred = v -> acpred_plane [ mb_pos ] = get_bits1 ( gb ) ;\n GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n s -> y_dc_scale = s -> y_dc_scale_table [ mquant ] ;\n s -> c_dc_scale = s -> c_dc_scale_table [ mquant ] ;\n dst_idx = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = s -> mb_intra ;\n v -> a_avail = v -> c_avail = 0 ;\n if ( i == 2 || i == 3 || ! s -> first_slice_line ) v -> a_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - s -> block_wrap [ i ] ] ;\n if ( i == 1 || i == 3 || s -> mb_x ) v -> c_avail = v -> mb_type [ 0 ] [ s -> block_index [ i ] - 1 ] ;\n vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n if ( ( i > 3 ) && ( s -> flags & CODEC_FLAG_GRAY ) ) continue ;\n v -> vc1dsp . vc1_inv_trans_8x8 ( s -> block [ i ] ) ;\n if ( i < 4 ) {\n stride_y = s -> linesize << fieldtx ;\n off = ( fieldtx ) ? ( ( i & 1 ) * 8 ) + ( ( i & 2 ) >> 1 ) * s -> linesize : ( i & 1 ) * 8 + 4 * ( i & 2 ) * s -> linesize ;\n }\n else {\n stride_y = s -> uvlinesize ;\n off = 0 ;\n }\n s -> dsp . put_signed_pixels_clamped ( s -> block [ i ] , s -> dest [ dst_idx ] + off , stride_y ) ;\n }\n }\n else {\n mb_has_coeffs = ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 3 ] ;\n if ( mb_has_coeffs ) cbp = 1 + get_vlc2 ( & v -> s . gb , v -> cbpcy_vlc -> table , VC1_CBPCY_P_VLC_BITS , 2 ) ;\n if ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] == MV_PMODE_INTFR_2MV_FIELD ) {\n v -> twomvbp = get_vlc2 ( gb , v -> twomvbp_vlc -> table , VC1_2MV_BLOCK_PATTERN_VLC_BITS , 1 ) ;\n }\n else {\n if ( ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] == MV_PMODE_INTFR_4MV ) || ( ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 0 ] == MV_PMODE_INTFR_4MV_FIELD ) ) {\n v -> fourmvbp = get_vlc2 ( gb , v -> fourmvbp_vlc -> table , VC1_4MV_BLOCK_PATTERN_VLC_BITS , 1 ) ;\n }\n }\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n fieldtx = v -> fieldtx_plane [ mb_pos ] = ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 1 ] ;\n dst_idx = 0 ;\n if ( fourmv ) {\n mvbp = v -> fourmvbp ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( i < 4 ) {\n dmv_x = dmv_y = 0 ;\n val = ( ( mvbp >> ( 3 - i ) ) & 1 ) ;\n if ( val ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , 0 ) ;\n }\n vc1_pred_mv_intfr ( v , i , dmv_x , dmv_y , 0 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_4mv_luma ( v , i , 0 ) ;\n }\n else if ( i == 4 ) {\n vc1_mc_4mv_chroma4 ( v ) ;\n }\n }\n }\n else if ( twomv ) {\n mvbp = v -> twomvbp ;\n dmv_x = dmv_y = 0 ;\n if ( mvbp & 2 ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , 0 ) ;\n }\n vc1_pred_mv_intfr ( v , 0 , dmv_x , dmv_y , 2 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_4mv_luma ( v , 0 , 0 ) ;\n vc1_mc_4mv_luma ( v , 1 , 0 ) ;\n dmv_x = dmv_y = 0 ;\n if ( mvbp & 1 ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , 0 ) ;\n }\n vc1_pred_mv_intfr ( v , 2 , dmv_x , dmv_y , 2 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_4mv_luma ( v , 2 , 0 ) ;\n vc1_mc_4mv_luma ( v , 3 , 0 ) ;\n vc1_mc_4mv_chroma4 ( v ) ;\n }\n else {\n mvbp = ff_vc1_mbmode_intfrp [ v -> fourmvswitch ] [ idx_mbmode ] [ 2 ] ;\n dmv_x = dmv_y = 0 ;\n if ( mvbp ) {\n get_mvdata_interlaced ( v , & dmv_x , & dmv_y , 0 ) ;\n }\n vc1_pred_mv_intfr ( v , 0 , dmv_x , dmv_y , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_1mv ( v , 0 ) ;\n }\n if ( cbp ) GET_MQUANT ( ) ;\n s -> current_picture . f . qscale_table [ mb_pos ] = mquant ;\n if ( ! v -> ttmbf && cbp ) ttmb = get_vlc2 ( gb , ff_vc1_ttmb_vlc [ v -> tt_index ] . table , VC1_TTMB_VLC_BITS , 2 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n dst_idx += i >> 2 ;\n val = ( ( cbp >> ( 5 - i ) ) & 1 ) ;\n if ( ! fieldtx ) off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( i & 2 ) * 4 * s -> linesize ) ;\n else off = ( i & 4 ) ? 0 : ( ( i & 1 ) * 8 + ( ( i > 1 ) * s -> linesize ) ) ;\n if ( val ) {\n pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : ( s -> linesize << fieldtx ) , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n block_cbp |= pat << ( i << 2 ) ;\n if ( ! v -> ttmbf && ttmb < 8 ) ttmb = - 1 ;\n first_block = 0 ;\n }\n }\n }\n }\n else {\n s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n v -> mb_type [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = 0 ;\n }\n s -> current_picture . f . mb_type [ mb_pos ] = MB_TYPE_SKIP ;\n s -> current_picture . f . qscale_table [ mb_pos ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 0 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 1 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 2 ] ] = 0 ;\n v -> blk_mv_type [ s -> block_index [ 3 ] ] = 0 ;\n vc1_pred_mv_intfr ( v , 0 , 0 , 0 , 1 , v -> range_x , v -> range_y , v -> mb_type [ 0 ] ) ;\n vc1_mc_1mv ( v , 0 ) ;\n }\n if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n return 0 ;\n }",
        "hash": 6080147530626246065,
        "project": "debian",
        "size": 192,
        "slice": {
            "memmove": [
                [
                    1,
                    "static int vc1_decode_p_mb_intfr ( VC1Context * v ) {\n"
                ],
                [
                    53,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n"
                ],
                [
                    76,
                    " vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n"
                ],
                [
                    101,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n"
                ],
                [
                    119,
                    " vc1_mc_4mv_luma ( v , i , 0 ) ;\n"
                ],
                [
                    122,
                    " vc1_mc_4mv_chroma4 ( v ) ;\n"
                ],
                [
                    142,
                    " vc1_mc_4mv_chroma4 ( v ) ;\n"
                ],
                [
                    151,
                    " vc1_mc_1mv ( v , 0 ) ;\n"
                ],
                [
                    165,
                    " pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : ( s -> linesize << fieldtx ) , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n"
                ],
                [
                    174,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n"
                ],
                [
                    188,
                    " vc1_mc_1mv ( v , 0 ) ;\n"
                ],
                [
                    190,
                    " if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int vc1_decode_p_mb_intfr ( VC1Context * v ) {\n"
                ],
                [
                    53,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n"
                ],
                [
                    76,
                    " vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n"
                ],
                [
                    101,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n"
                ],
                [
                    119,
                    " vc1_mc_4mv_luma ( v , i , 0 ) ;\n"
                ],
                [
                    122,
                    " vc1_mc_4mv_chroma4 ( v ) ;\n"
                ],
                [
                    142,
                    " vc1_mc_4mv_chroma4 ( v ) ;\n"
                ],
                [
                    151,
                    " vc1_mc_1mv ( v , 0 ) ;\n"
                ],
                [
                    165,
                    " pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : ( s -> linesize << fieldtx ) , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n"
                ],
                [
                    174,
                    " s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n"
                ],
                [
                    188,
                    " vc1_mc_1mv ( v , 0 ) ;\n"
                ],
                [
                    190,
                    " if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int cng_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n CNGContext * p = avctx -> priv_data ;\n int buf_size = avpkt -> size ;\n int ret , i ;\n int16_t * buf_out ;\n float e = 1.0 ;\n float scaling ;\n if ( avpkt -> size ) {\n int dbov = - avpkt -> data [ 0 ] ;\n p -> target_energy = 1081109975 * pow ( 10 , dbov / 10.0 ) * 0.75 ;\n memset ( p -> target_refl_coef , 0 , p -> order * sizeof ( * p -> target_refl_coef ) ) ;\n for ( i = 0 ;\n i < FFMIN ( avpkt -> size - 1 , p -> order ) ;\n i ++ ) {\n p -> target_refl_coef [ i ] = ( avpkt -> data [ 1 + i ] - 127 ) / 128.0 ;\n }\n }\n if ( p -> inited ) {\n p -> energy = p -> energy / 2 + p -> target_energy / 2 ;\n for ( i = 0 ;\n i < p -> order ;\n i ++ ) p -> refl_coef [ i ] = 0.6 * p -> refl_coef [ i ] + 0.4 * p -> target_refl_coef [ i ] ;\n }\n else {\n p -> energy = p -> target_energy ;\n memcpy ( p -> refl_coef , p -> target_refl_coef , p -> order * sizeof ( * p -> refl_coef ) ) ;\n p -> inited = 1 ;\n }\n make_lpc_coefs ( p -> lpc_coef , p -> refl_coef , p -> order ) ;\n for ( i = 0 ;\n i < p -> order ;\n i ++ ) e *= 1.0 - p -> refl_coef [ i ] * p -> refl_coef [ i ] ;\n scaling = sqrt ( e * p -> energy / 1081109975 ) ;\n for ( i = 0 ;\n i < avctx -> frame_size ;\n i ++ ) {\n int r = ( av_lfg_get ( & p -> lfg ) & 0xffff ) - 0x8000 ;\n p -> excitation [ i ] = scaling * r ;\n }\n ff_celp_lp_synthesis_filterf ( p -> filter_out + p -> order , p -> lpc_coef , p -> excitation , avctx -> frame_size , p -> order ) ;\n frame -> nb_samples = avctx -> frame_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf_out = ( int16_t * ) frame -> data [ 0 ] ;\n for ( i = 0 ;\n i < avctx -> frame_size ;\n i ++ ) buf_out [ i ] = p -> filter_out [ i + p -> order ] ;\n memcpy ( p -> filter_out , p -> filter_out + avctx -> frame_size , p -> order * sizeof ( * p -> filter_out ) ) ;\n * got_frame_ptr = 1 ;\n return buf_size ;\n }",
        "hash": -4744270124459050462,
        "project": "debian",
        "size": 54,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int cng_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " CNGContext * p = avctx -> priv_data ;\n"
                ],
                [
                    12,
                    " memset ( p -> target_refl_coef , 0 , p -> order * sizeof ( * p -> target_refl_coef ) ) ;\n"
                ],
                [
                    16,
                    " p -> target_refl_coef [ i ] = ( avpkt -> data [ 1 + i ] - 127 ) / 128.0 ;\n"
                ],
                [
                    19,
                    " if ( p -> inited ) {\n"
                ],
                [
                    27,
                    " memcpy ( p -> refl_coef , p -> target_refl_coef , p -> order * sizeof ( * p -> refl_coef ) ) ;\n"
                ],
                [
                    30,
                    " make_lpc_coefs ( p -> lpc_coef , p -> refl_coef , p -> order ) ;\n"
                ],
                [
                    43,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ],
                [
                    49,
                    " i < avctx -> frame_size ;\n"
                ],
                [
                    51,
                    " memcpy ( p -> filter_out , p -> filter_out + avctx -> frame_size , p -> order * sizeof ( * p -> filter_out ) ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int cng_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " CNGContext * p = avctx -> priv_data ;\n"
                ],
                [
                    9,
                    " if ( avpkt -> size ) {\n"
                ],
                [
                    12,
                    " memset ( p -> target_refl_coef , 0 , p -> order * sizeof ( * p -> target_refl_coef ) ) ;\n"
                ],
                [
                    27,
                    " memcpy ( p -> refl_coef , p -> target_refl_coef , p -> order * sizeof ( * p -> refl_coef ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int cng_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " CNGContext * p = avctx -> priv_data ;\n"
                ],
                [
                    9,
                    " if ( avpkt -> size ) {\n"
                ],
                [
                    12,
                    " memset ( p -> target_refl_coef , 0 , p -> order * sizeof ( * p -> target_refl_coef ) ) ;\n"
                ],
                [
                    16,
                    " p -> target_refl_coef [ i ] = ( avpkt -> data [ 1 + i ] - 127 ) / 128.0 ;\n"
                ],
                [
                    19,
                    " if ( p -> inited ) {\n"
                ],
                [
                    27,
                    " memcpy ( p -> refl_coef , p -> target_refl_coef , p -> order * sizeof ( * p -> refl_coef ) ) ;\n"
                ],
                [
                    30,
                    " make_lpc_coefs ( p -> lpc_coef , p -> refl_coef , p -> order ) ;\n"
                ],
                [
                    43,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ],
                [
                    49,
                    " i < avctx -> frame_size ;\n"
                ],
                [
                    51,
                    " memcpy ( p -> filter_out , p -> filter_out + avctx -> frame_size , p -> order * sizeof ( * p -> filter_out ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int encode_thread ( AVCodecContext * c , void * arg ) {\n MpegEncContext * s = * ( void * * ) arg ;\n int mb_x , mb_y , pdif = 0 ;\n int chr_h = 16 >> s -> chroma_y_shift ;\n int i , j ;\n MpegEncContext best_s , backup_s ;\n uint8_t bit_buf [ 2 ] [ MAX_MB_BYTES ] ;\n uint8_t bit_buf2 [ 2 ] [ MAX_MB_BYTES ] ;\n uint8_t bit_buf_tex [ 2 ] [ MAX_MB_BYTES ] ;\n PutBitContext pb [ 2 ] , pb2 [ 2 ] , tex_pb [ 2 ] ;\n ff_check_alignment ( ) ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n init_put_bits ( & pb [ i ] , bit_buf [ i ] , MAX_MB_BYTES ) ;\n init_put_bits ( & pb2 [ i ] , bit_buf2 [ i ] , MAX_MB_BYTES ) ;\n init_put_bits ( & tex_pb [ i ] , bit_buf_tex [ i ] , MAX_MB_BYTES ) ;\n }\n s -> last_bits = put_bits_count ( & s -> pb ) ;\n s -> mv_bits = 0 ;\n s -> misc_bits = 0 ;\n s -> i_tex_bits = 0 ;\n s -> p_tex_bits = 0 ;\n s -> i_count = 0 ;\n s -> f_count = 0 ;\n s -> b_count = 0 ;\n s -> skip_count = 0 ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n s -> last_dc [ i ] = 128 << s -> intra_dc_precision ;\n s -> current_picture . f . error [ i ] = 0 ;\n }\n s -> mb_skip_run = 0 ;\n memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;\n s -> last_mv_dir = 0 ;\n switch ( s -> codec_id ) {\n case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : case AV_CODEC_ID_FLV1 : if ( CONFIG_H263_ENCODER ) s -> gob_index = ff_h263_get_gob_height ( s ) ;\n break ;\n case AV_CODEC_ID_MPEG4 : if ( CONFIG_MPEG4_ENCODER && s -> partitioned_frame ) ff_mpeg4_init_partitions ( s ) ;\n break ;\n }\n s -> resync_mb_x = 0 ;\n s -> resync_mb_y = 0 ;\n s -> first_slice_line = 1 ;\n s -> ptr_lastgob = s -> pb . buf ;\n for ( mb_y = s -> start_mb_y ;\n mb_y < s -> end_mb_y ;\n mb_y ++ ) {\n s -> mb_x = 0 ;\n s -> mb_y = mb_y ;\n ff_set_qscale ( s , s -> qscale ) ;\n ff_init_block_index ( s ) ;\n for ( mb_x = 0 ;\n mb_x < s -> mb_width ;\n mb_x ++ ) {\n int xy = mb_y * s -> mb_stride + mb_x ;\n int mb_type = s -> mb_type [ xy ] ;\n int dmin = INT_MAX ;\n int dir ;\n if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < MAX_MB_BYTES ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"encoded frame too large\\n\" ) ;\n return - 1 ;\n }\n if ( s -> data_partitioning ) {\n if ( s -> pb2 . buf_end - s -> pb2 . buf - ( put_bits_count ( & s -> pb2 ) >> 3 ) < MAX_MB_BYTES || s -> tex_pb . buf_end - s -> tex_pb . buf - ( put_bits_count ( & s -> tex_pb ) >> 3 ) < MAX_MB_BYTES ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"encoded frame too large\\n\" ) ;\n return - 1 ;\n }\n }\n s -> mb_x = mb_x ;\n s -> mb_y = mb_y ;\n ff_update_block_index ( s ) ;\n if ( CONFIG_H261_ENCODER && s -> codec_id == AV_CODEC_ID_H261 ) {\n ff_h261_reorder_mb_index ( s ) ;\n xy = s -> mb_y * s -> mb_stride + s -> mb_x ;\n mb_type = s -> mb_type [ xy ] ;\n }\n if ( s -> rtp_mode ) {\n int current_packet_size , is_gob_start ;\n current_packet_size = ( ( put_bits_count ( & s -> pb ) + 7 ) >> 3 ) - ( s -> ptr_lastgob - s -> pb . buf ) ;\n is_gob_start = s -> avctx -> rtp_payload_size && current_packet_size >= s -> avctx -> rtp_payload_size && mb_y + mb_x > 0 ;\n if ( s -> start_mb_y == mb_y && mb_y > 0 && mb_x == 0 ) is_gob_start = 1 ;\n switch ( s -> codec_id ) {\n case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : if ( ! s -> h263_slice_structured ) if ( s -> mb_x || s -> mb_y % s -> gob_index ) is_gob_start = 0 ;\n break ;\n case AV_CODEC_ID_MPEG2VIDEO : if ( s -> mb_x == 0 && s -> mb_y != 0 ) is_gob_start = 1 ;\n case AV_CODEC_ID_MPEG1VIDEO : if ( s -> mb_skip_run ) is_gob_start = 0 ;\n break ;\n }\n if ( is_gob_start ) {\n if ( s -> start_mb_y != mb_y || mb_x != 0 ) {\n write_slice_end ( s ) ;\n if ( CONFIG_MPEG4_ENCODER && s -> codec_id == AV_CODEC_ID_MPEG4 && s -> partitioned_frame ) {\n ff_mpeg4_init_partitions ( s ) ;\n }\n }\n assert ( ( put_bits_count ( & s -> pb ) & 7 ) == 0 ) ;\n current_packet_size = put_bits_ptr ( & s -> pb ) - s -> ptr_lastgob ;\n if ( s -> avctx -> error_rate && s -> resync_mb_x + s -> resync_mb_y > 0 ) {\n int r = put_bits_count ( & s -> pb ) / 8 + s -> picture_number + 16 + s -> mb_x + s -> mb_y ;\n int d = 100 / s -> avctx -> error_rate ;\n if ( r % d == 0 ) {\n current_packet_size = 0 ;\n s -> pb . buf_ptr = s -> ptr_lastgob ;\n assert ( put_bits_ptr ( & s -> pb ) == s -> ptr_lastgob ) ;\n }\n }\n if ( s -> avctx -> rtp_callback ) {\n int number_mb = ( mb_y - s -> resync_mb_y ) * s -> mb_width + mb_x - s -> resync_mb_x ;\n s -> avctx -> rtp_callback ( s -> avctx , s -> ptr_lastgob , current_packet_size , number_mb ) ;\n }\n update_mb_info ( s , 1 ) ;\n switch ( s -> codec_id ) {\n case AV_CODEC_ID_MPEG4 : if ( CONFIG_MPEG4_ENCODER ) {\n ff_mpeg4_encode_video_packet_header ( s ) ;\n ff_mpeg4_clean_buffers ( s ) ;\n }\n break ;\n case AV_CODEC_ID_MPEG1VIDEO : case AV_CODEC_ID_MPEG2VIDEO : if ( CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER ) {\n ff_mpeg1_encode_slice_header ( s ) ;\n ff_mpeg1_clean_buffers ( s ) ;\n }\n break ;\n case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : if ( CONFIG_H263_ENCODER ) ff_h263_encode_gob_header ( s , mb_y ) ;\n break ;\n }\n if ( s -> flags & CODEC_FLAG_PASS1 ) {\n int bits = put_bits_count ( & s -> pb ) ;\n s -> misc_bits += bits - s -> last_bits ;\n s -> last_bits = bits ;\n }\n s -> ptr_lastgob += current_packet_size ;\n s -> first_slice_line = 1 ;\n s -> resync_mb_x = mb_x ;\n s -> resync_mb_y = mb_y ;\n }\n }\n if ( ( s -> resync_mb_x == s -> mb_x ) && s -> resync_mb_y + 1 == s -> mb_y ) {\n s -> first_slice_line = 0 ;\n }\n s -> mb_skipped = 0 ;\n s -> dquant = 0 ;\n update_mb_info ( s , 0 ) ;\n if ( mb_type & ( mb_type - 1 ) || ( s -> mpv_flags & FF_MPV_FLAG_QP_RD ) ) {\n int next_block = 0 ;\n int pb_bits_count , pb2_bits_count , tex_pb_bits_count ;\n copy_context_before_encode ( & backup_s , s , - 1 ) ;\n backup_s . pb = s -> pb ;\n best_s . data_partitioning = s -> data_partitioning ;\n best_s . partitioned_frame = s -> partitioned_frame ;\n if ( s -> data_partitioning ) {\n backup_s . pb2 = s -> pb2 ;\n backup_s . tex_pb = s -> tex_pb ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_INTER ) {\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mb_intra = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = s -> p_mv_table [ xy ] [ 0 ] ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = s -> p_mv_table [ xy ] [ 1 ] ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_INTER_I ) {\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_FIELD ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n j = s -> field_select [ 0 ] [ i ] = s -> p_field_select_table [ i ] [ xy ] ;\n s -> mv [ 0 ] [ i ] [ 0 ] = s -> p_field_mv_table [ i ] [ j ] [ xy ] [ 0 ] ;\n s -> mv [ 0 ] [ i ] [ 1 ] = s -> p_field_mv_table [ i ] [ j ] [ xy ] [ 1 ] ;\n }\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_SKIPPED ) {\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mb_intra = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_SKIPPED , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_INTER4V ) {\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_8X8 ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n s -> mv [ 0 ] [ i ] [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ i ] ] [ 0 ] ;\n s -> mv [ 0 ] [ i ] [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ i ] ] [ 1 ] ;\n }\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER4V , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_FORWARD ) {\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mb_intra = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = s -> b_forw_mv_table [ xy ] [ 0 ] ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = s -> b_forw_mv_table [ xy ] [ 1 ] ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_BACKWARD ) {\n s -> mv_dir = MV_DIR_BACKWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mb_intra = 0 ;\n s -> mv [ 1 ] [ 0 ] [ 0 ] = s -> b_back_mv_table [ xy ] [ 0 ] ;\n s -> mv [ 1 ] [ 0 ] [ 1 ] = s -> b_back_mv_table [ xy ] [ 1 ] ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 1 ] [ 0 ] [ 0 ] , s -> mv [ 1 ] [ 0 ] [ 1 ] ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_BIDIR ) {\n s -> mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mb_intra = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = s -> b_bidir_forw_mv_table [ xy ] [ 0 ] ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = s -> b_bidir_forw_mv_table [ xy ] [ 1 ] ;\n s -> mv [ 1 ] [ 0 ] [ 0 ] = s -> b_bidir_back_mv_table [ xy ] [ 0 ] ;\n s -> mv [ 1 ] [ 0 ] [ 1 ] = s -> b_bidir_back_mv_table [ xy ] [ 1 ] ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_FORWARD_I ) {\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_FIELD ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n j = s -> field_select [ 0 ] [ i ] = s -> b_field_select_table [ 0 ] [ i ] [ xy ] ;\n s -> mv [ 0 ] [ i ] [ 0 ] = s -> b_field_mv_table [ 0 ] [ i ] [ j ] [ xy ] [ 0 ] ;\n s -> mv [ 0 ] [ i ] [ 1 ] = s -> b_field_mv_table [ 0 ] [ i ] [ j ] [ xy ] [ 1 ] ;\n }\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_BACKWARD_I ) {\n s -> mv_dir = MV_DIR_BACKWARD ;\n s -> mv_type = MV_TYPE_FIELD ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n j = s -> field_select [ 1 ] [ i ] = s -> b_field_select_table [ 1 ] [ i ] [ xy ] ;\n s -> mv [ 1 ] [ i ] [ 0 ] = s -> b_field_mv_table [ 1 ] [ i ] [ j ] [ xy ] [ 0 ] ;\n s -> mv [ 1 ] [ i ] [ 1 ] = s -> b_field_mv_table [ 1 ] [ i ] [ j ] [ xy ] [ 1 ] ;\n }\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_BIDIR_I ) {\n s -> mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD ;\n s -> mv_type = MV_TYPE_FIELD ;\n s -> mb_intra = 0 ;\n for ( dir = 0 ;\n dir < 2 ;\n dir ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n j = s -> field_select [ dir ] [ i ] = s -> b_field_select_table [ dir ] [ i ] [ xy ] ;\n s -> mv [ dir ] [ i ] [ 0 ] = s -> b_field_mv_table [ dir ] [ i ] [ j ] [ xy ] [ 0 ] ;\n s -> mv [ dir ] [ i ] [ 1 ] = s -> b_field_mv_table [ dir ] [ i ] [ j ] [ xy ] [ 1 ] ;\n }\n }\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n }\n if ( mb_type & CANDIDATE_MB_TYPE_INTRA ) {\n s -> mv_dir = 0 ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mb_intra = 1 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTRA , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n if ( s -> h263_pred || s -> h263_aic ) {\n if ( best_s . mb_intra ) s -> mbintra_table [ mb_x + mb_y * s -> mb_stride ] = 1 ;\n else ff_clean_intra_table_entries ( s ) ;\n }\n }\n if ( ( s -> mpv_flags & FF_MPV_FLAG_QP_RD ) && dmin < INT_MAX ) {\n if ( best_s . mv_type == MV_TYPE_16X16 ) {\n const int last_qp = backup_s . qscale ;\n int qpi , qp , dc [ 6 ] ;\n int16_t ac [ 6 ] [ 16 ] ;\n const int mvdir = ( best_s . mv_dir & MV_DIR_BACKWARD ) ? 1 : 0 ;\n static const int dquant_tab [ 4 ] = {\n - 1 , 1 , - 2 , 2 }\n ;\n assert ( backup_s . dquant == 0 ) ;\n s -> mv_dir = best_s . mv_dir ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> mb_intra = best_s . mb_intra ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = best_s . mv [ 0 ] [ 0 ] [ 0 ] ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = best_s . mv [ 0 ] [ 0 ] [ 1 ] ;\n s -> mv [ 1 ] [ 0 ] [ 0 ] = best_s . mv [ 1 ] [ 0 ] [ 0 ] ;\n s -> mv [ 1 ] [ 0 ] [ 1 ] = best_s . mv [ 1 ] [ 0 ] [ 1 ] ;\n qpi = s -> pict_type == AV_PICTURE_TYPE_B ? 2 : 0 ;\n for ( ;\n qpi < 4 ;\n qpi ++ ) {\n int dquant = dquant_tab [ qpi ] ;\n qp = last_qp + dquant ;\n if ( qp < s -> avctx -> qmin || qp > s -> avctx -> qmax ) continue ;\n backup_s . dquant = dquant ;\n if ( s -> mb_intra && s -> dc_val [ 0 ] ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n dc [ i ] = s -> dc_val [ 0 ] [ s -> block_index [ i ] ] ;\n memcpy ( ac [ i ] , s -> ac_val [ 0 ] [ s -> block_index [ i ] ] , sizeof ( int16_t ) * 16 ) ;\n }\n }\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ mvdir ] [ 0 ] [ 0 ] , s -> mv [ mvdir ] [ 0 ] [ 1 ] ) ;\n if ( best_s . qscale != qp ) {\n if ( s -> mb_intra && s -> dc_val [ 0 ] ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n s -> dc_val [ 0 ] [ s -> block_index [ i ] ] = dc [ i ] ;\n memcpy ( s -> ac_val [ 0 ] [ s -> block_index [ i ] ] , ac [ i ] , sizeof ( int16_t ) * 16 ) ;\n }\n }\n }\n }\n }\n }\n if ( CONFIG_MPEG4_ENCODER && mb_type & CANDIDATE_MB_TYPE_DIRECT ) {\n int mx = s -> b_direct_mv_table [ xy ] [ 0 ] ;\n int my = s -> b_direct_mv_table [ xy ] [ 1 ] ;\n backup_s . dquant = 0 ;\n s -> mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT ;\n s -> mb_intra = 0 ;\n ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n }\n if ( CONFIG_MPEG4_ENCODER && mb_type & CANDIDATE_MB_TYPE_DIRECT0 ) {\n backup_s . dquant = 0 ;\n s -> mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT ;\n s -> mb_intra = 0 ;\n ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n }\n if ( ! best_s . mb_intra && s -> mpv_flags & FF_MPV_FLAG_SKIP_RD ) {\n int coded = 0 ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) coded |= s -> block_last_index [ i ] ;\n if ( coded ) {\n int mx , my ;\n memcpy ( s -> mv , best_s . mv , sizeof ( s -> mv ) ) ;\n if ( CONFIG_MPEG4_ENCODER && best_s . mv_dir & MV_DIRECT ) {\n mx = my = 0 ;\n ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n }\n else if ( best_s . mv_dir & MV_DIR_BACKWARD ) {\n mx = s -> mv [ 1 ] [ 0 ] [ 0 ] ;\n my = s -> mv [ 1 ] [ 0 ] [ 1 ] ;\n }\n else {\n mx = s -> mv [ 0 ] [ 0 ] [ 0 ] ;\n my = s -> mv [ 0 ] [ 0 ] [ 1 ] ;\n }\n s -> mv_dir = best_s . mv_dir ;\n s -> mv_type = best_s . mv_type ;\n s -> mb_intra = 0 ;\n backup_s . dquant = 0 ;\n s -> skipdct = 1 ;\n encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n s -> skipdct = 0 ;\n }\n }\n s -> current_picture . f . qscale_table [ xy ] = best_s . qscale ;\n copy_context_after_encode ( s , & best_s , - 1 ) ;\n pb_bits_count = put_bits_count ( & s -> pb ) ;\n flush_put_bits ( & s -> pb ) ;\n avpriv_copy_bits ( & backup_s . pb , bit_buf [ next_block ^ 1 ] , pb_bits_count ) ;\n s -> pb = backup_s . pb ;\n if ( s -> data_partitioning ) {\n pb2_bits_count = put_bits_count ( & s -> pb2 ) ;\n flush_put_bits ( & s -> pb2 ) ;\n avpriv_copy_bits ( & backup_s . pb2 , bit_buf2 [ next_block ^ 1 ] , pb2_bits_count ) ;\n s -> pb2 = backup_s . pb2 ;\n tex_pb_bits_count = put_bits_count ( & s -> tex_pb ) ;\n flush_put_bits ( & s -> tex_pb ) ;\n avpriv_copy_bits ( & backup_s . tex_pb , bit_buf_tex [ next_block ^ 1 ] , tex_pb_bits_count ) ;\n s -> tex_pb = backup_s . tex_pb ;\n }\n s -> last_bits = put_bits_count ( & s -> pb ) ;\n if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n if ( next_block == 0 ) {\n s -> dsp . put_pixels_tab [ 0 ] [ 0 ] ( s -> dest [ 0 ] , s -> rd_scratchpad , s -> linesize , 16 ) ;\n s -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( s -> dest [ 1 ] , s -> rd_scratchpad + 16 * s -> linesize , s -> uvlinesize , 8 ) ;\n s -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( s -> dest [ 2 ] , s -> rd_scratchpad + 16 * s -> linesize + 8 , s -> uvlinesize , 8 ) ;\n }\n if ( s -> avctx -> mb_decision == FF_MB_DECISION_BITS ) ff_MPV_decode_mb ( s , s -> block ) ;\n }\n else {\n int motion_x = 0 , motion_y = 0 ;\n s -> mv_type = MV_TYPE_16X16 ;\n switch ( mb_type ) {\n case CANDIDATE_MB_TYPE_INTRA : s -> mv_dir = 0 ;\n s -> mb_intra = 1 ;\n motion_x = s -> mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\n motion_y = s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n break ;\n case CANDIDATE_MB_TYPE_INTER : s -> mv_dir = MV_DIR_FORWARD ;\n s -> mb_intra = 0 ;\n motion_x = s -> mv [ 0 ] [ 0 ] [ 0 ] = s -> p_mv_table [ xy ] [ 0 ] ;\n motion_y = s -> mv [ 0 ] [ 0 ] [ 1 ] = s -> p_mv_table [ xy ] [ 1 ] ;\n break ;\n case CANDIDATE_MB_TYPE_INTER_I : s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_FIELD ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n j = s -> field_select [ 0 ] [ i ] = s -> p_field_select_table [ i ] [ xy ] ;\n s -> mv [ 0 ] [ i ] [ 0 ] = s -> p_field_mv_table [ i ] [ j ] [ xy ] [ 0 ] ;\n s -> mv [ 0 ] [ i ] [ 1 ] = s -> p_field_mv_table [ i ] [ j ] [ xy ] [ 1 ] ;\n }\n break ;\n case CANDIDATE_MB_TYPE_INTER4V : s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_8X8 ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n s -> mv [ 0 ] [ i ] [ 0 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ i ] ] [ 0 ] ;\n s -> mv [ 0 ] [ i ] [ 1 ] = s -> current_picture . f . motion_val [ 0 ] [ s -> block_index [ i ] ] [ 1 ] ;\n }\n break ;\n case CANDIDATE_MB_TYPE_DIRECT : if ( CONFIG_MPEG4_ENCODER ) {\n s -> mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT ;\n s -> mb_intra = 0 ;\n motion_x = s -> b_direct_mv_table [ xy ] [ 0 ] ;\n motion_y = s -> b_direct_mv_table [ xy ] [ 1 ] ;\n ff_mpeg4_set_direct_mv ( s , motion_x , motion_y ) ;\n }\n break ;\n case CANDIDATE_MB_TYPE_DIRECT0 : if ( CONFIG_MPEG4_ENCODER ) {\n s -> mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT ;\n s -> mb_intra = 0 ;\n ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n }\n break ;\n case CANDIDATE_MB_TYPE_BIDIR : s -> mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD ;\n s -> mb_intra = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = s -> b_bidir_forw_mv_table [ xy ] [ 0 ] ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = s -> b_bidir_forw_mv_table [ xy ] [ 1 ] ;\n s -> mv [ 1 ] [ 0 ] [ 0 ] = s -> b_bidir_back_mv_table [ xy ] [ 0 ] ;\n s -> mv [ 1 ] [ 0 ] [ 1 ] = s -> b_bidir_back_mv_table [ xy ] [ 1 ] ;\n break ;\n case CANDIDATE_MB_TYPE_BACKWARD : s -> mv_dir = MV_DIR_BACKWARD ;\n s -> mb_intra = 0 ;\n motion_x = s -> mv [ 1 ] [ 0 ] [ 0 ] = s -> b_back_mv_table [ xy ] [ 0 ] ;\n motion_y = s -> mv [ 1 ] [ 0 ] [ 1 ] = s -> b_back_mv_table [ xy ] [ 1 ] ;\n break ;\n case CANDIDATE_MB_TYPE_FORWARD : s -> mv_dir = MV_DIR_FORWARD ;\n s -> mb_intra = 0 ;\n motion_x = s -> mv [ 0 ] [ 0 ] [ 0 ] = s -> b_forw_mv_table [ xy ] [ 0 ] ;\n motion_y = s -> mv [ 0 ] [ 0 ] [ 1 ] = s -> b_forw_mv_table [ xy ] [ 1 ] ;\n break ;\n case CANDIDATE_MB_TYPE_FORWARD_I : s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_FIELD ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n j = s -> field_select [ 0 ] [ i ] = s -> b_field_select_table [ 0 ] [ i ] [ xy ] ;\n s -> mv [ 0 ] [ i ] [ 0 ] = s -> b_field_mv_table [ 0 ] [ i ] [ j ] [ xy ] [ 0 ] ;\n s -> mv [ 0 ] [ i ] [ 1 ] = s -> b_field_mv_table [ 0 ] [ i ] [ j ] [ xy ] [ 1 ] ;\n }\n break ;\n case CANDIDATE_MB_TYPE_BACKWARD_I : s -> mv_dir = MV_DIR_BACKWARD ;\n s -> mv_type = MV_TYPE_FIELD ;\n s -> mb_intra = 0 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n j = s -> field_select [ 1 ] [ i ] = s -> b_field_select_table [ 1 ] [ i ] [ xy ] ;\n s -> mv [ 1 ] [ i ] [ 0 ] = s -> b_field_mv_table [ 1 ] [ i ] [ j ] [ xy ] [ 0 ] ;\n s -> mv [ 1 ] [ i ] [ 1 ] = s -> b_field_mv_table [ 1 ] [ i ] [ j ] [ xy ] [ 1 ] ;\n }\n break ;\n case CANDIDATE_MB_TYPE_BIDIR_I : s -> mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD ;\n s -> mv_type = MV_TYPE_FIELD ;\n s -> mb_intra = 0 ;\n for ( dir = 0 ;\n dir < 2 ;\n dir ++ ) {\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n j = s -> field_select [ dir ] [ i ] = s -> b_field_select_table [ dir ] [ i ] [ xy ] ;\n s -> mv [ dir ] [ i ] [ 0 ] = s -> b_field_mv_table [ dir ] [ i ] [ j ] [ xy ] [ 0 ] ;\n s -> mv [ dir ] [ i ] [ 1 ] = s -> b_field_mv_table [ dir ] [ i ] [ j ] [ xy ] [ 1 ] ;\n }\n }\n break ;\n default : av_log ( s -> avctx , AV_LOG_ERROR , \"illegal MB type\\n\" ) ;\n }\n encode_mb ( s , motion_x , motion_y ) ;\n s -> last_mv_dir = s -> mv_dir ;\n if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n ff_MPV_decode_mb ( s , s -> block ) ;\n }\n if ( s -> mb_intra ) {\n s -> p_mv_table [ xy ] [ 0 ] = 0 ;\n s -> p_mv_table [ xy ] [ 1 ] = 0 ;\n }\n if ( s -> flags & CODEC_FLAG_PSNR ) {\n int w = 16 ;\n int h = 16 ;\n if ( s -> mb_x * 16 + 16 > s -> width ) w = s -> width - s -> mb_x * 16 ;\n if ( s -> mb_y * 16 + 16 > s -> height ) h = s -> height - s -> mb_y * 16 ;\n s -> current_picture . f . error [ 0 ] += sse ( s , s -> new_picture . f . data [ 0 ] + s -> mb_x * 16 + s -> mb_y * s -> linesize * 16 , s -> dest [ 0 ] , w , h , s -> linesize ) ;\n s -> current_picture . f . error [ 1 ] += sse ( s , s -> new_picture . f . data [ 1 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 1 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n s -> current_picture . f . error [ 2 ] += sse ( s , s -> new_picture . f . data [ 2 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 2 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n }\n if ( s -> loop_filter ) {\n if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 ) ff_h263_loop_filter ( s ) ;\n }\n av_dlog ( s -> avctx , \"MB %d %d bits\\n\" , s -> mb_x + s -> mb_y * s -> mb_stride , put_bits_count ( & s -> pb ) ) ;\n }\n }\n / ot beautiful here but we must write it before flushing so it has to be here if ( CONFIG_MSMPEG4_ENCODER && s -> msmpeg4_version && s -> msmpeg4_version < 4 && s -> pict_type == AV_PICTURE_TYPE_I ) ff_msmpeg4_encode_ext_header ( s ) ;\n write_slice_end ( s ) ;\n if ( s -> avctx -> rtp_callback ) {\n int number_mb = ( mb_y - s -> resync_mb_y ) * s -> mb_width - s -> resync_mb_x ;\n pdif = put_bits_ptr ( & s -> pb ) - s -> ptr_lastgob ;\n emms_c ( ) ;\n s -> avctx -> rtp_callback ( s -> avctx , s -> ptr_lastgob , pdif , number_mb ) ;\n }\n return 0 ;\n }",
        "hash": -305162769887579921,
        "project": "debian",
        "size": 533,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int encode_thread ( AVCodecContext * c , void * arg ) {\n"
                ],
                [
                    52,
                    " ff_set_qscale ( s , s -> qscale ) ;\n"
                ],
                [
                    53,
                    " ff_init_block_index ( s ) ;\n"
                ],
                [
                    73,
                    " ff_update_block_index ( s ) ;\n"
                ],
                [
                    75,
                    " ff_h261_reorder_mb_index ( s ) ;\n"
                ],
                [
                    93,
                    " write_slice_end ( s ) ;\n"
                ],
                [
                    95,
                    " ff_mpeg4_init_partitions ( s ) ;\n"
                ],
                [
                    113,
                    " update_mb_info ( s , 1 ) ;\n"
                ],
                [
                    116,
                    " ff_mpeg4_encode_video_packet_header ( s ) ;\n"
                ],
                [
                    117,
                    " ff_mpeg4_clean_buffers ( s ) ;\n"
                ],
                [
                    121,
                    " ff_mpeg1_encode_slice_header ( s ) ;\n"
                ],
                [
                    122,
                    " ff_mpeg1_clean_buffers ( s ) ;\n"
                ],
                [
                    125,
                    " case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : if ( CONFIG_H263_ENCODER ) ff_h263_encode_gob_header ( s , mb_y ) ;\n"
                ],
                [
                    144,
                    " update_mb_info ( s , 0 ) ;\n"
                ],
                [
                    148,
                    " copy_context_before_encode ( & backup_s , s , - 1 ) ;\n"
                ],
                [
                    150,
                    " best_s . data_partitioning = s -> data_partitioning ;\n"
                ],
                [
                    151,
                    " best_s . partitioned_frame = s -> partitioned_frame ;\n"
                ],
                [
                    162,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    175,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    183,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_SKIPPED , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    195,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER4V , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    203,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    211,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 1 ] [ 0 ] [ 0 ] , s -> mv [ 1 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    221,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    234,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    247,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    264,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    272,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTRA , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    275,
                    " else ff_clean_intra_table_entries ( s ) ;\n"
                ],
                [
                    279,
                    " if ( best_s . mv_type == MV_TYPE_16X16 ) {\n"
                ],
                [
                    282,
                    " int16_t ac [ 6 ] [ 16 ] ;\n"
                ],
                [
                    283,
                    " const int mvdir = ( best_s . mv_dir & MV_DIR_BACKWARD ) ? 1 : 0 ;\n"
                ],
                [
                    288,
                    " s -> mv_dir = best_s . mv_dir ;\n"
                ],
                [
                    290,
                    " s -> mb_intra = best_s . mb_intra ;\n"
                ],
                [
                    305,
                    " i < 6 ;\n"
                ],
                [
                    308,
                    " memcpy ( ac [ i ] , s -> ac_val [ 0 ] [ s -> block_index [ i ] ] , sizeof ( int16_t ) * 16 ) ;\n"
                ],
                [
                    311,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ mvdir ] [ 0 ] [ 0 ] , s -> mv [ mvdir ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    312,
                    " if ( best_s . qscale != qp ) {\n"
                ],
                [
                    315,
                    " i < 6 ;\n"
                ],
                [
                    318,
                    " memcpy ( s -> ac_val [ 0 ] [ s -> block_index [ i ] ] , ac [ i ] , sizeof ( int16_t ) * 16 ) ;\n"
                ],
                [
                    331,
                    " ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n"
                ],
                [
                    332,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n"
                ],
                [
                    338,
                    " ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n"
                ],
                [
                    339,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    341,
                    " if ( ! best_s . mb_intra && s -> mpv_flags & FF_MPV_FLAG_SKIP_RD ) {\n"
                ],
                [
                    346,
                    " if ( coded ) {\n"
                ],
                [
                    348,
                    " memcpy ( s -> mv , best_s . mv , sizeof ( s -> mv ) ) ;\n"
                ],
                [
                    349,
                    " if ( CONFIG_MPEG4_ENCODER && best_s . mv_dir & MV_DIRECT ) {\n"
                ],
                [
                    351,
                    " ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n"
                ],
                [
                    353,
                    " else if ( best_s . mv_dir & MV_DIR_BACKWARD ) {\n"
                ],
                [
                    361,
                    " s -> mv_dir = best_s . mv_dir ;\n"
                ],
                [
                    362,
                    " s -> mv_type = best_s . mv_type ;\n"
                ],
                [
                    366,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n"
                ],
                [
                    370,
                    " s -> current_picture . f . qscale_table [ xy ] = best_s . qscale ;\n"
                ],
                [
                    371,
                    " copy_context_after_encode ( s , & best_s , - 1 ) ;\n"
                ],
                [
                    387,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n"
                ],
                [
                    393,
                    " if ( s -> avctx -> mb_decision == FF_MB_DECISION_BITS ) ff_MPV_decode_mb ( s , s -> block ) ;\n"
                ],
                [
                    435,
                    " ff_mpeg4_set_direct_mv ( s , motion_x , motion_y ) ;\n"
                ],
                [
                    441,
                    " ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n"
                ],
                [
                    500,
                    " encode_mb ( s , motion_x , motion_y ) ;\n"
                ],
                [
                    502,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n"
                ],
                [
                    503,
                    " ff_MPV_decode_mb ( s , s -> block ) ;\n"
                ],
                [
                    514,
                    " s -> current_picture . f . error [ 0 ] += sse ( s , s -> new_picture . f . data [ 0 ] + s -> mb_x * 16 + s -> mb_y * s -> linesize * 16 , s -> dest [ 0 ] , w , h , s -> linesize ) ;\n"
                ],
                [
                    515,
                    " s -> current_picture . f . error [ 1 ] += sse ( s , s -> new_picture . f . data [ 1 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 1 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n"
                ],
                [
                    516,
                    " s -> current_picture . f . error [ 2 ] += sse ( s , s -> new_picture . f . data [ 2 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 2 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n"
                ],
                [
                    519,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 ) ff_h263_loop_filter ( s ) ;\n"
                ],
                [
                    525,
                    " write_slice_end ( s ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int encode_thread ( AVCodecContext * c , void * arg ) {\n"
                ],
                [
                    2,
                    " MpegEncContext * s = * ( void * * ) arg ;\n"
                ],
                [
                    35,
                    " memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;\n"
                ],
                [
                    38,
                    " case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : case AV_CODEC_ID_FLV1 : if ( CONFIG_H263_ENCODER ) s -> gob_index = ff_h263_get_gob_height ( s ) ;\n"
                ],
                [
                    40,
                    " case AV_CODEC_ID_MPEG4 : if ( CONFIG_MPEG4_ENCODER && s -> partitioned_frame ) ff_mpeg4_init_partitions ( s ) ;\n"
                ],
                [
                    52,
                    " ff_set_qscale ( s , s -> qscale ) ;\n"
                ],
                [
                    53,
                    " ff_init_block_index ( s ) ;\n"
                ],
                [
                    73,
                    " ff_update_block_index ( s ) ;\n"
                ],
                [
                    75,
                    " ff_h261_reorder_mb_index ( s ) ;\n"
                ],
                [
                    93,
                    " write_slice_end ( s ) ;\n"
                ],
                [
                    95,
                    " ff_mpeg4_init_partitions ( s ) ;\n"
                ],
                [
                    113,
                    " update_mb_info ( s , 1 ) ;\n"
                ],
                [
                    116,
                    " ff_mpeg4_encode_video_packet_header ( s ) ;\n"
                ],
                [
                    117,
                    " ff_mpeg4_clean_buffers ( s ) ;\n"
                ],
                [
                    121,
                    " ff_mpeg1_encode_slice_header ( s ) ;\n"
                ],
                [
                    122,
                    " ff_mpeg1_clean_buffers ( s ) ;\n"
                ],
                [
                    125,
                    " case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : if ( CONFIG_H263_ENCODER ) ff_h263_encode_gob_header ( s , mb_y ) ;\n"
                ],
                [
                    144,
                    " update_mb_info ( s , 0 ) ;\n"
                ],
                [
                    148,
                    " copy_context_before_encode ( & backup_s , s , - 1 ) ;\n"
                ],
                [
                    162,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    175,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    183,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_SKIPPED , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    195,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER4V , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    203,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    211,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 1 ] [ 0 ] [ 0 ] , s -> mv [ 1 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    221,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    234,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    247,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    264,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    272,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTRA , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    275,
                    " else ff_clean_intra_table_entries ( s ) ;\n"
                ],
                [
                    311,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ mvdir ] [ 0 ] [ 0 ] , s -> mv [ mvdir ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    331,
                    " ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n"
                ],
                [
                    332,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n"
                ],
                [
                    338,
                    " ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n"
                ],
                [
                    339,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    351,
                    " ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n"
                ],
                [
                    366,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n"
                ],
                [
                    371,
                    " copy_context_after_encode ( s , & best_s , - 1 ) ;\n"
                ],
                [
                    387,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n"
                ],
                [
                    393,
                    " if ( s -> avctx -> mb_decision == FF_MB_DECISION_BITS ) ff_MPV_decode_mb ( s , s -> block ) ;\n"
                ],
                [
                    435,
                    " ff_mpeg4_set_direct_mv ( s , motion_x , motion_y ) ;\n"
                ],
                [
                    441,
                    " ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n"
                ],
                [
                    500,
                    " encode_mb ( s , motion_x , motion_y ) ;\n"
                ],
                [
                    502,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n"
                ],
                [
                    503,
                    " ff_MPV_decode_mb ( s , s -> block ) ;\n"
                ],
                [
                    514,
                    " s -> current_picture . f . error [ 0 ] += sse ( s , s -> new_picture . f . data [ 0 ] + s -> mb_x * 16 + s -> mb_y * s -> linesize * 16 , s -> dest [ 0 ] , w , h , s -> linesize ) ;\n"
                ],
                [
                    515,
                    " s -> current_picture . f . error [ 1 ] += sse ( s , s -> new_picture . f . data [ 1 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 1 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n"
                ],
                [
                    516,
                    " s -> current_picture . f . error [ 2 ] += sse ( s , s -> new_picture . f . data [ 2 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 2 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n"
                ],
                [
                    519,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 ) ff_h263_loop_filter ( s ) ;\n"
                ],
                [
                    525,
                    " write_slice_end ( s ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int encode_thread ( AVCodecContext * c , void * arg ) {\n"
                ],
                [
                    2,
                    " MpegEncContext * s = * ( void * * ) arg ;\n"
                ],
                [
                    35,
                    " memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;\n"
                ],
                [
                    38,
                    " case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : case AV_CODEC_ID_FLV1 : if ( CONFIG_H263_ENCODER ) s -> gob_index = ff_h263_get_gob_height ( s ) ;\n"
                ],
                [
                    40,
                    " case AV_CODEC_ID_MPEG4 : if ( CONFIG_MPEG4_ENCODER && s -> partitioned_frame ) ff_mpeg4_init_partitions ( s ) ;\n"
                ],
                [
                    52,
                    " ff_set_qscale ( s , s -> qscale ) ;\n"
                ],
                [
                    53,
                    " ff_init_block_index ( s ) ;\n"
                ],
                [
                    73,
                    " ff_update_block_index ( s ) ;\n"
                ],
                [
                    75,
                    " ff_h261_reorder_mb_index ( s ) ;\n"
                ],
                [
                    93,
                    " write_slice_end ( s ) ;\n"
                ],
                [
                    95,
                    " ff_mpeg4_init_partitions ( s ) ;\n"
                ],
                [
                    113,
                    " update_mb_info ( s , 1 ) ;\n"
                ],
                [
                    116,
                    " ff_mpeg4_encode_video_packet_header ( s ) ;\n"
                ],
                [
                    117,
                    " ff_mpeg4_clean_buffers ( s ) ;\n"
                ],
                [
                    121,
                    " ff_mpeg1_encode_slice_header ( s ) ;\n"
                ],
                [
                    122,
                    " ff_mpeg1_clean_buffers ( s ) ;\n"
                ],
                [
                    125,
                    " case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : if ( CONFIG_H263_ENCODER ) ff_h263_encode_gob_header ( s , mb_y ) ;\n"
                ],
                [
                    144,
                    " update_mb_info ( s , 0 ) ;\n"
                ],
                [
                    148,
                    " copy_context_before_encode ( & backup_s , s , - 1 ) ;\n"
                ],
                [
                    150,
                    " best_s . data_partitioning = s -> data_partitioning ;\n"
                ],
                [
                    151,
                    " best_s . partitioned_frame = s -> partitioned_frame ;\n"
                ],
                [
                    162,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    175,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    183,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_SKIPPED , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    195,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER4V , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    203,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    211,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 1 ] [ 0 ] [ 0 ] , s -> mv [ 1 ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    221,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    234,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    247,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    264,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    272,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTRA , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    275,
                    " else ff_clean_intra_table_entries ( s ) ;\n"
                ],
                [
                    279,
                    " if ( best_s . mv_type == MV_TYPE_16X16 ) {\n"
                ],
                [
                    282,
                    " int16_t ac [ 6 ] [ 16 ] ;\n"
                ],
                [
                    283,
                    " const int mvdir = ( best_s . mv_dir & MV_DIR_BACKWARD ) ? 1 : 0 ;\n"
                ],
                [
                    288,
                    " s -> mv_dir = best_s . mv_dir ;\n"
                ],
                [
                    290,
                    " s -> mb_intra = best_s . mb_intra ;\n"
                ],
                [
                    305,
                    " i < 6 ;\n"
                ],
                [
                    308,
                    " memcpy ( ac [ i ] , s -> ac_val [ 0 ] [ s -> block_index [ i ] ] , sizeof ( int16_t ) * 16 ) ;\n"
                ],
                [
                    311,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ mvdir ] [ 0 ] [ 0 ] , s -> mv [ mvdir ] [ 0 ] [ 1 ] ) ;\n"
                ],
                [
                    312,
                    " if ( best_s . qscale != qp ) {\n"
                ],
                [
                    315,
                    " i < 6 ;\n"
                ],
                [
                    318,
                    " memcpy ( s -> ac_val [ 0 ] [ s -> block_index [ i ] ] , ac [ i ] , sizeof ( int16_t ) * 16 ) ;\n"
                ],
                [
                    331,
                    " ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n"
                ],
                [
                    332,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n"
                ],
                [
                    338,
                    " ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n"
                ],
                [
                    339,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n"
                ],
                [
                    341,
                    " if ( ! best_s . mb_intra && s -> mpv_flags & FF_MPV_FLAG_SKIP_RD ) {\n"
                ],
                [
                    346,
                    " if ( coded ) {\n"
                ],
                [
                    348,
                    " memcpy ( s -> mv , best_s . mv , sizeof ( s -> mv ) ) ;\n"
                ],
                [
                    349,
                    " if ( CONFIG_MPEG4_ENCODER && best_s . mv_dir & MV_DIRECT ) {\n"
                ],
                [
                    351,
                    " ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n"
                ],
                [
                    353,
                    " else if ( best_s . mv_dir & MV_DIR_BACKWARD ) {\n"
                ],
                [
                    361,
                    " s -> mv_dir = best_s . mv_dir ;\n"
                ],
                [
                    362,
                    " s -> mv_type = best_s . mv_type ;\n"
                ],
                [
                    366,
                    " encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n"
                ],
                [
                    370,
                    " s -> current_picture . f . qscale_table [ xy ] = best_s . qscale ;\n"
                ],
                [
                    371,
                    " copy_context_after_encode ( s , & best_s , - 1 ) ;\n"
                ],
                [
                    387,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n"
                ],
                [
                    393,
                    " if ( s -> avctx -> mb_decision == FF_MB_DECISION_BITS ) ff_MPV_decode_mb ( s , s -> block ) ;\n"
                ],
                [
                    435,
                    " ff_mpeg4_set_direct_mv ( s , motion_x , motion_y ) ;\n"
                ],
                [
                    441,
                    " ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n"
                ],
                [
                    500,
                    " encode_mb ( s , motion_x , motion_y ) ;\n"
                ],
                [
                    502,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n"
                ],
                [
                    503,
                    " ff_MPV_decode_mb ( s , s -> block ) ;\n"
                ],
                [
                    514,
                    " s -> current_picture . f . error [ 0 ] += sse ( s , s -> new_picture . f . data [ 0 ] + s -> mb_x * 16 + s -> mb_y * s -> linesize * 16 , s -> dest [ 0 ] , w , h , s -> linesize ) ;\n"
                ],
                [
                    515,
                    " s -> current_picture . f . error [ 1 ] += sse ( s , s -> new_picture . f . data [ 1 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 1 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n"
                ],
                [
                    516,
                    " s -> current_picture . f . error [ 2 ] += sse ( s , s -> new_picture . f . data [ 2 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 2 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n"
                ],
                [
                    519,
                    " if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 ) ff_h263_loop_filter ( s ) ;\n"
                ],
                [
                    525,
                    " write_slice_end ( s ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int select_input_picture ( MpegEncContext * s ) {\n int i ;\n for ( i = 1 ;\n i < MAX_PICTURE_COUNT ;\n i ++ ) s -> reordered_input_picture [ i - 1 ] = s -> reordered_input_picture [ i ] ;\n s -> reordered_input_picture [ MAX_PICTURE_COUNT - 1 ] = NULL ;\n if ( s -> reordered_input_picture [ 0 ] == NULL && s -> input_picture [ 0 ] ) {\n if ( s -> next_picture_ptr == NULL || s -> intra_only ) {\n s -> reordered_input_picture [ 0 ] = s -> input_picture [ 0 ] ;\n s -> reordered_input_picture [ 0 ] -> f . pict_type = AV_PICTURE_TYPE_I ;\n s -> reordered_input_picture [ 0 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n }\n else {\n int b_frames ;\n if ( s -> avctx -> frame_skip_threshold || s -> avctx -> frame_skip_factor ) {\n if ( s -> picture_in_gop_number < s -> gop_size && skip_check ( s , s -> input_picture [ 0 ] , s -> next_picture_ptr ) ) {\n if ( s -> input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_SHARED ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) s -> input_picture [ 0 ] -> f . data [ i ] = NULL ;\n s -> input_picture [ 0 ] -> f . type = 0 ;\n }\n else {\n assert ( s -> input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_USER || s -> input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_INTERNAL ) ;\n s -> avctx -> release_buffer ( s -> avctx , & s -> input_picture [ 0 ] -> f ) ;\n }\n emms_c ( ) ;\n ff_vbv_update ( s , 0 ) ;\n goto no_output_pic ;\n }\n }\n if ( s -> flags & CODEC_FLAG_PASS2 ) {\n for ( i = 0 ;\n i < s -> max_b_frames + 1 ;\n i ++ ) {\n int pict_num = s -> input_picture [ 0 ] -> f . display_picture_number + i ;\n if ( pict_num >= s -> rc_context . num_entries ) break ;\n if ( ! s -> input_picture [ i ] ) {\n s -> rc_context . entry [ pict_num - 1 ] . new_pict_type = AV_PICTURE_TYPE_P ;\n break ;\n }\n s -> input_picture [ i ] -> f . pict_type = s -> rc_context . entry [ pict_num ] . new_pict_type ;\n }\n }\n if ( s -> avctx -> b_frame_strategy == 0 ) {\n b_frames = s -> max_b_frames ;\n while ( b_frames && ! s -> input_picture [ b_frames ] ) b_frames -- ;\n }\n else if ( s -> avctx -> b_frame_strategy == 1 ) {\n for ( i = 1 ;\n i < s -> max_b_frames + 1 ;\n i ++ ) {\n if ( s -> input_picture [ i ] && s -> input_picture [ i ] -> b_frame_score == 0 ) {\n s -> input_picture [ i ] -> b_frame_score = get_intra_count ( s , s -> input_picture [ i ] -> f . data [ 0 ] , s -> input_picture [ i - 1 ] -> f . data [ 0 ] , s -> linesize ) + 1 ;\n }\n }\n for ( i = 0 ;\n i < s -> max_b_frames + 1 ;\n i ++ ) {\n if ( s -> input_picture [ i ] == NULL || s -> input_picture [ i ] -> b_frame_score - 1 > s -> mb_num / s -> avctx -> b_sensitivity ) break ;\n }\n b_frames = FFMAX ( 0 , i - 1 ) ;\n for ( i = 0 ;\n i < b_frames + 1 ;\n i ++ ) {\n s -> input_picture [ i ] -> b_frame_score = 0 ;\n }\n }\n else if ( s -> avctx -> b_frame_strategy == 2 ) {\n b_frames = estimate_best_b_count ( s ) ;\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"illegal b frame strategy\\n\" ) ;\n b_frames = 0 ;\n }\n emms_c ( ) ;\n for ( i = b_frames - 1 ;\n i >= 0 ;\n i -- ) {\n int type = s -> input_picture [ i ] -> f . pict_type ;\n if ( type && type != AV_PICTURE_TYPE_B ) b_frames = i ;\n }\n if ( s -> input_picture [ b_frames ] -> f . pict_type == AV_PICTURE_TYPE_B && b_frames == s -> max_b_frames ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"warning, too many b frames in a row\\n\" ) ;\n }\n if ( s -> picture_in_gop_number + b_frames >= s -> gop_size ) {\n if ( ( s -> mpv_flags & FF_MPV_FLAG_STRICT_GOP ) && s -> gop_size > s -> picture_in_gop_number ) {\n b_frames = s -> gop_size - s -> picture_in_gop_number - 1 ;\n }\n else {\n if ( s -> flags & CODEC_FLAG_CLOSED_GOP ) b_frames = 0 ;\n s -> input_picture [ b_frames ] -> f . pict_type = AV_PICTURE_TYPE_I ;\n }\n }\n if ( ( s -> flags & CODEC_FLAG_CLOSED_GOP ) && b_frames && s -> input_picture [ b_frames ] -> f . pict_type == AV_PICTURE_TYPE_I ) b_frames -- ;\n s -> reordered_input_picture [ 0 ] = s -> input_picture [ b_frames ] ;\n if ( s -> reordered_input_picture [ 0 ] -> f . pict_type != AV_PICTURE_TYPE_I ) s -> reordered_input_picture [ 0 ] -> f . pict_type = AV_PICTURE_TYPE_P ;\n s -> reordered_input_picture [ 0 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n for ( i = 0 ;\n i < b_frames ;\n i ++ ) {\n s -> reordered_input_picture [ i + 1 ] = s -> input_picture [ i ] ;\n s -> reordered_input_picture [ i + 1 ] -> f . pict_type = AV_PICTURE_TYPE_B ;\n s -> reordered_input_picture [ i + 1 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n }\n }\n }\n no_output_pic : if ( s -> reordered_input_picture [ 0 ] ) {\n s -> reordered_input_picture [ 0 ] -> f . reference = s -> reordered_input_picture [ 0 ] -> f . pict_type != AV_PICTURE_TYPE_B ? 3 : 0 ;\n ff_copy_picture ( & s -> new_picture , s -> reordered_input_picture [ 0 ] ) ;\n if ( s -> reordered_input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_SHARED || s -> avctx -> rc_buffer_size ) {\n Picture * pic ;\n int i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) return i ;\n pic = & s -> picture [ i ] ;\n pic -> f . reference = s -> reordered_input_picture [ 0 ] -> f . reference ;\n if ( ff_alloc_picture ( s , pic , 0 ) < 0 ) {\n return - 1 ;\n }\n if ( s -> reordered_input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_INTERNAL ) s -> avctx -> release_buffer ( s -> avctx , & s -> reordered_input_picture [ 0 ] -> f ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) s -> reordered_input_picture [ 0 ] -> f . data [ i ] = NULL ;\n s -> reordered_input_picture [ 0 ] -> f . type = 0 ;\n copy_picture_attributes ( s , & pic -> f , & s -> reordered_input_picture [ 0 ] -> f ) ;\n s -> current_picture_ptr = pic ;\n }\n else {\n assert ( s -> reordered_input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_USER || s -> reordered_input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_INTERNAL ) ;\n s -> current_picture_ptr = s -> reordered_input_picture [ 0 ] ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n s -> new_picture . f . data [ i ] += INPLACE_OFFSET ;\n }\n }\n ff_copy_picture ( & s -> current_picture , s -> current_picture_ptr ) ;\n s -> picture_number = s -> new_picture . f . display_picture_number ;\n }\n else {\n memset ( & s -> new_picture , 0 , sizeof ( Picture ) ) ;\n }\n return 0 ;\n }",
        "hash": -305162769887579921,
        "project": "debian",
        "size": 144,
        "slice": {
            "memset": [
                [
                    1,
                    "static int select_input_picture ( MpegEncContext * s ) {\n"
                ],
                [
                    16,
                    " if ( s -> picture_in_gop_number < s -> gop_size && skip_check ( s , s -> input_picture [ 0 ] , s -> next_picture_ptr ) ) {\n"
                ],
                [
                    28,
                    " ff_vbv_update ( s , 0 ) ;\n"
                ],
                [
                    54,
                    " s -> input_picture [ i ] -> b_frame_score = get_intra_count ( s , s -> input_picture [ i ] -> f . data [ 0 ] , s -> input_picture [ i - 1 ] -> f . data [ 0 ] , s -> linesize ) + 1 ;\n"
                ],
                [
                    70,
                    " b_frames = estimate_best_b_count ( s ) ;\n"
                ],
                [
                    108,
                    " no_output_pic : if ( s -> reordered_input_picture [ 0 ] ) {\n"
                ],
                [
                    141,
                    " memset ( & s -> new_picture , 0 , sizeof ( Picture ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int select_input_picture ( MpegEncContext * s ) {\n"
                ],
                [
                    16,
                    " if ( s -> picture_in_gop_number < s -> gop_size && skip_check ( s , s -> input_picture [ 0 ] , s -> next_picture_ptr ) ) {\n"
                ],
                [
                    28,
                    " ff_vbv_update ( s , 0 ) ;\n"
                ],
                [
                    54,
                    " s -> input_picture [ i ] -> b_frame_score = get_intra_count ( s , s -> input_picture [ i ] -> f . data [ 0 ] , s -> input_picture [ i - 1 ] -> f . data [ 0 ] , s -> linesize ) + 1 ;\n"
                ],
                [
                    70,
                    " b_frames = estimate_best_b_count ( s ) ;\n"
                ],
                [
                    108,
                    " no_output_pic : if ( s -> reordered_input_picture [ 0 ] ) {\n"
                ],
                [
                    141,
                    " memset ( & s -> new_picture , 0 , sizeof ( Picture ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int load_input_picture ( MpegEncContext * s , const AVFrame * pic_arg ) {\n AVFrame * pic = NULL ;\n int64_t pts ;\n int i , display_picture_number = 0 ;\n const int encoding_delay = s -> max_b_frames ? s -> max_b_frames : ( s -> low_delay ? 0 : 1 ) ;\n int direct = 1 ;\n if ( pic_arg ) {\n pts = pic_arg -> pts ;\n display_picture_number = s -> input_picture_number ++ ;\n if ( pts != AV_NOPTS_VALUE ) {\n if ( s -> user_specified_pts != AV_NOPTS_VALUE ) {\n int64_t time = pts ;\n int64_t last = s -> user_specified_pts ;\n if ( time <= last ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Error, Invalid timestamp=%\" PRId64 \", \" \"last=%\" PRId64 \"\\n\" , pts , s -> user_specified_pts ) ;\n return - 1 ;\n }\n if ( ! s -> low_delay && display_picture_number == 1 ) s -> dts_delta = time - last ;\n }\n s -> user_specified_pts = pts ;\n }\n else {\n if ( s -> user_specified_pts != AV_NOPTS_VALUE ) {\n s -> user_specified_pts = pts = s -> user_specified_pts + 1 ;\n av_log ( s -> avctx , AV_LOG_INFO , \"Warning: AVFrame.pts=? trying to guess (%\" PRId64 \")\\n\" , pts ) ;\n }\n else {\n pts = display_picture_number ;\n }\n }\n }\n if ( pic_arg ) {\n if ( encoding_delay && ! ( s -> flags & CODEC_FLAG_INPUT_PRESERVED ) ) direct = 0 ;\n if ( pic_arg -> linesize [ 0 ] != s -> linesize ) direct = 0 ;\n if ( pic_arg -> linesize [ 1 ] != s -> uvlinesize ) direct = 0 ;\n if ( pic_arg -> linesize [ 2 ] != s -> uvlinesize ) direct = 0 ;\n av_dlog ( s -> avctx , \"%d %d %d %d\\n\" , pic_arg -> linesize [ 0 ] , pic_arg -> linesize [ 1 ] , s -> linesize , s -> uvlinesize ) ;\n if ( direct ) {\n i = ff_find_unused_picture ( s , 1 ) ;\n if ( i < 0 ) return i ;\n pic = & s -> picture [ i ] . f ;\n pic -> reference = 3 ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n pic -> data [ i ] = pic_arg -> data [ i ] ;\n pic -> linesize [ i ] = pic_arg -> linesize [ i ] ;\n }\n if ( ff_alloc_picture ( s , ( Picture * ) pic , 1 ) < 0 ) {\n return - 1 ;\n }\n }\n else {\n i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) return i ;\n pic = & s -> picture [ i ] . f ;\n pic -> reference = 3 ;\n if ( ff_alloc_picture ( s , ( Picture * ) pic , 0 ) < 0 ) {\n return - 1 ;\n }\n if ( pic -> data [ 0 ] + INPLACE_OFFSET == pic_arg -> data [ 0 ] && pic -> data [ 1 ] + INPLACE_OFFSET == pic_arg -> data [ 1 ] && pic -> data [ 2 ] + INPLACE_OFFSET == pic_arg -> data [ 2 ] ) {\n }\n else {\n int h_chroma_shift , v_chroma_shift ;\n av_pix_fmt_get_chroma_sub_sample ( s -> avctx -> pix_fmt , & h_chroma_shift , & v_chroma_shift ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n int src_stride = pic_arg -> linesize [ i ] ;\n int dst_stride = i ? s -> uvlinesize : s -> linesize ;\n int h_shift = i ? h_chroma_shift : 0 ;\n int v_shift = i ? v_chroma_shift : 0 ;\n int w = s -> width >> h_shift ;\n int h = s -> height >> v_shift ;\n uint8_t * src = pic_arg -> data [ i ] ;\n uint8_t * dst = pic -> data [ i ] ;\n if ( ! s -> avctx -> rc_buffer_size ) dst += INPLACE_OFFSET ;\n if ( src_stride == dst_stride ) memcpy ( dst , src , src_stride * h ) ;\n else {\n while ( h -- ) {\n memcpy ( dst , src , w ) ;\n dst += dst_stride ;\n src += src_stride ;\n }\n }\n }\n }\n }\n copy_picture_attributes ( s , pic , pic_arg ) ;\n pic -> display_picture_number = display_picture_number ;\n pic -> pts = pts ;\n }\n for ( i = 1 ;\n i < MAX_PICTURE_COUNT ;\n i ++ ) s -> input_picture [ i - 1 ] = s -> input_picture [ i ] ;\n s -> input_picture [ encoding_delay ] = ( Picture * ) pic ;\n return 0 ;\n }",
        "hash": -305162769887579921,
        "project": "debian",
        "size": 98,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int load_input_picture ( MpegEncContext * s , const AVFrame * pic_arg ) {\n"
                ],
                [
                    73,
                    " int w = s -> width >> h_shift ;\n"
                ],
                [
                    75,
                    " uint8_t * src = pic_arg -> data [ i ] ;\n"
                ],
                [
                    76,
                    " uint8_t * dst = pic -> data [ i ] ;\n"
                ],
                [
                    77,
                    " if ( ! s -> avctx -> rc_buffer_size ) dst += INPLACE_OFFSET ;\n"
                ],
                [
                    78,
                    " if ( src_stride == dst_stride ) memcpy ( dst , src , src_stride * h ) ;\n"
                ],
                [
                    80,
                    " while ( h -- ) {\n"
                ],
                [
                    81,
                    " memcpy ( dst , src , w ) ;\n"
                ],
                [
                    82,
                    " dst += dst_stride ;\n"
                ],
                [
                    83,
                    " src += src_stride ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int load_input_picture ( MpegEncContext * s , const AVFrame * pic_arg ) {\n"
                ],
                [
                    73,
                    " int w = s -> width >> h_shift ;\n"
                ],
                [
                    75,
                    " uint8_t * src = pic_arg -> data [ i ] ;\n"
                ],
                [
                    76,
                    " uint8_t * dst = pic -> data [ i ] ;\n"
                ],
                [
                    77,
                    " if ( ! s -> avctx -> rc_buffer_size ) dst += INPLACE_OFFSET ;\n"
                ],
                [
                    78,
                    " if ( src_stride == dst_stride ) memcpy ( dst , src , src_stride * h ) ;\n"
                ],
                [
                    80,
                    " while ( h -- ) {\n"
                ],
                [
                    81,
                    " memcpy ( dst , src , w ) ;\n"
                ],
                [
                    82,
                    " dst += dst_stride ;\n"
                ],
                [
                    83,
                    " src += src_stride ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int svq3_decode_mb ( SVQ3Context * s , unsigned int mb_type ) {\n H264Context * h = & s -> h ;\n int i , j , k , m , dir , mode ;\n int cbp = 0 ;\n uint32_t vlc ;\n int8_t * top , * left ;\n const int mb_xy = h -> mb_xy ;\n const int b_xy = 4 * h -> mb_x + 4 * h -> mb_y * h -> b_stride ;\n h -> top_samples_available = ( h -> mb_y == 0 ) ? 0x33FF : 0xFFFF ;\n h -> left_samples_available = ( h -> mb_x == 0 ) ? 0x5F5F : 0xFFFF ;\n h -> topright_samples_available = 0xFFFF ;\n if ( mb_type == 0 ) {\n if ( h -> pict_type == AV_PICTURE_TYPE_P || s -> next_pic -> f . mb_type [ mb_xy ] == - 1 ) {\n svq3_mc_dir_part ( s , 16 * h -> mb_x , 16 * h -> mb_y , 16 , 16 , 0 , 0 , 0 , 0 , 0 , 0 ) ;\n if ( h -> pict_type == AV_PICTURE_TYPE_B ) svq3_mc_dir_part ( s , 16 * h -> mb_x , 16 * h -> mb_y , 16 , 16 , 0 , 0 , 0 , 0 , 1 , 1 ) ;\n mb_type = MB_TYPE_SKIP ;\n }\n else {\n mb_type = FFMIN ( s -> next_pic -> f . mb_type [ mb_xy ] , 6 ) ;\n if ( svq3_mc_dir ( s , mb_type , PREDICT_MODE , 0 , 0 ) < 0 ) return - 1 ;\n if ( svq3_mc_dir ( s , mb_type , PREDICT_MODE , 1 , 1 ) < 0 ) return - 1 ;\n mb_type = MB_TYPE_16x16 ;\n }\n }\n else if ( mb_type < 8 ) {\n if ( s -> thirdpel_flag && s -> halfpel_flag == ! get_bits1 ( & h -> gb ) ) mode = THIRDPEL_MODE ;\n else if ( s -> halfpel_flag && s -> thirdpel_flag == ! get_bits1 ( & h -> gb ) ) mode = HALFPEL_MODE ;\n else mode = FULLPEL_MODE ;\n for ( m = 0 ;\n m < 2 ;\n m ++ ) {\n if ( h -> mb_x > 0 && h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - 1 ] + 6 ] != - 1 ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) AV_COPY32 ( h -> mv_cache [ m ] [ scan8 [ 0 ] - 1 + i * 8 ] , h -> cur_pic . f . motion_val [ m ] [ b_xy - 1 + i * h -> b_stride ] ) ;\n }\n else {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) AV_ZERO32 ( h -> mv_cache [ m ] [ scan8 [ 0 ] - 1 + i * 8 ] ) ;\n }\n if ( h -> mb_y > 0 ) {\n memcpy ( h -> mv_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , h -> cur_pic . f . motion_val [ m ] [ b_xy - h -> b_stride ] , 4 * 2 * sizeof ( int16_t ) ) ;\n memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 , 4 ) ;\n if ( h -> mb_x < h -> mb_width - 1 ) {\n AV_COPY32 ( h -> mv_cache [ m ] [ scan8 [ 0 ] + 4 - 1 * 8 ] , h -> cur_pic . f . motion_val [ m ] [ b_xy - h -> b_stride + 4 ] ) ;\n h -> ref_cache [ m ] [ scan8 [ 0 ] + 4 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride + 1 ] + 6 ] == - 1 || h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n }\n else h -> ref_cache [ m ] [ scan8 [ 0 ] + 4 - 1 * 8 ] = PART_NOT_AVAILABLE ;\n if ( h -> mb_x > 0 ) {\n AV_COPY32 ( h -> mv_cache [ m ] [ scan8 [ 0 ] - 1 - 1 * 8 ] , h -> cur_pic . f . motion_val [ m ] [ b_xy - h -> b_stride - 1 ] ) ;\n h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride - 1 ] + 3 ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n }\n else h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 - 1 * 8 ] = PART_NOT_AVAILABLE ;\n }\n else memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 - 1 ] , PART_NOT_AVAILABLE , 8 ) ;\n if ( h -> pict_type != AV_PICTURE_TYPE_B ) break ;\n }\n if ( h -> pict_type == AV_PICTURE_TYPE_P ) {\n if ( svq3_mc_dir ( s , mb_type - 1 , mode , 0 , 0 ) < 0 ) return - 1 ;\n }\n else {\n if ( mb_type != 2 ) {\n if ( svq3_mc_dir ( s , 0 , mode , 0 , 0 ) < 0 ) return - 1 ;\n }\n else {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) memset ( h -> cur_pic . f . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n }\n if ( mb_type != 1 ) {\n if ( svq3_mc_dir ( s , 0 , mode , 1 , mb_type == 3 ) < 0 ) return - 1 ;\n }\n else {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) memset ( h -> cur_pic . f . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n }\n }\n mb_type = MB_TYPE_16x16 ;\n }\n else if ( mb_type == 8 || mb_type == 33 ) {\n memset ( h -> intra4x4_pred_mode_cache , - 1 , 8 * 5 * sizeof ( int8_t ) ) ;\n if ( mb_type == 8 ) {\n if ( h -> mb_x > 0 ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] - 1 + i * 8 ] = h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - 1 ] + 6 - i ] ;\n if ( h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] - 1 ] == - 1 ) h -> left_samples_available = 0x5F5F ;\n }\n if ( h -> mb_y > 0 ) {\n h -> intra4x4_pred_mode_cache [ 4 + 8 * 0 ] = h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] + 0 ] ;\n h -> intra4x4_pred_mode_cache [ 5 + 8 * 0 ] = h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] + 1 ] ;\n h -> intra4x4_pred_mode_cache [ 6 + 8 * 0 ] = h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] + 2 ] ;\n h -> intra4x4_pred_mode_cache [ 7 + 8 * 0 ] = h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] + 3 ] ;\n if ( h -> intra4x4_pred_mode_cache [ 4 + 8 * 0 ] == - 1 ) h -> top_samples_available = 0x33FF ;\n }\n for ( i = 0 ;\n i < 16 ;\n i += 2 ) {\n vlc = svq3_get_ue_golomb ( & h -> gb ) ;\n if ( vlc >= 25 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"luma prediction:%d\\n\" , vlc ) ;\n return - 1 ;\n }\n left = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 1 ] ;\n top = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 8 ] ;\n left [ 1 ] = svq3_pred_1 [ top [ 0 ] + 1 ] [ left [ 0 ] + 1 ] [ svq3_pred_0 [ vlc ] [ 0 ] ] ;\n left [ 2 ] = svq3_pred_1 [ top [ 1 ] + 1 ] [ left [ 1 ] + 1 ] [ svq3_pred_0 [ vlc ] [ 1 ] ] ;\n if ( left [ 1 ] == - 1 || left [ 2 ] == - 1 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"weird prediction\\n\" ) ;\n return - 1 ;\n }\n }\n }\n else {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_PRED , 4 ) ;\n }\n write_back_intra_pred_mode ( h ) ;\n if ( mb_type == 8 ) {\n ff_h264_check_intra4x4_pred_mode ( h ) ;\n h -> top_samples_available = ( h -> mb_y == 0 ) ? 0x33FF : 0xFFFF ;\n h -> left_samples_available = ( h -> mb_x == 0 ) ? 0x5F5F : 0xFFFF ;\n }\n else {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_128_PRED , 4 ) ;\n h -> top_samples_available = 0x33FF ;\n h -> left_samples_available = 0x5F5F ;\n }\n mb_type = MB_TYPE_INTRA4x4 ;\n }\n else {\n dir = i_mb_type_info [ mb_type - 8 ] . pred_mode ;\n dir = ( dir >> 1 ) ^ 3 * ( dir & 1 ) ^ 1 ;\n if ( ( h -> intra16x16_pred_mode = ff_h264_check_intra_pred_mode ( h , dir , 0 ) ) == - 1 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"check_intra_pred_mode = -1\\n\" ) ;\n return - 1 ;\n }\n cbp = i_mb_type_info [ mb_type - 8 ] . cbp ;\n mb_type = MB_TYPE_INTRA16x16 ;\n }\n if ( ! IS_INTER ( mb_type ) && h -> pict_type != AV_PICTURE_TYPE_I ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) memset ( h -> cur_pic . f . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n if ( h -> pict_type == AV_PICTURE_TYPE_B ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) memset ( h -> cur_pic . f . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n }\n }\n if ( ! IS_INTRA4x4 ( mb_type ) ) {\n memset ( h -> intra4x4_pred_mode + h -> mb2br_xy [ mb_xy ] , DC_PRED , 8 ) ;\n }\n if ( ! IS_SKIP ( mb_type ) || h -> pict_type == AV_PICTURE_TYPE_B ) {\n memset ( h -> non_zero_count_cache + 8 , 0 , 14 * 8 * sizeof ( uint8_t ) ) ;\n h -> dsp . clear_blocks ( h -> mb + 0 ) ;\n h -> dsp . clear_blocks ( h -> mb + 384 ) ;\n }\n if ( ! IS_INTRA16x16 ( mb_type ) && ( ! IS_SKIP ( mb_type ) || h -> pict_type == AV_PICTURE_TYPE_B ) ) {\n if ( ( vlc = svq3_get_ue_golomb ( & h -> gb ) ) >= 48 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"cbp_vlc=%d\\n\" , vlc ) ;\n return - 1 ;\n }\n cbp = IS_INTRA ( mb_type ) ? golomb_to_intra4x4_cbp [ vlc ] : golomb_to_inter_cbp [ vlc ] ;\n }\n if ( IS_INTRA16x16 ( mb_type ) || ( h -> pict_type != AV_PICTURE_TYPE_I && s -> adaptive_quant && cbp ) ) {\n h -> qscale += svq3_get_se_golomb ( & h -> gb ) ;\n if ( h -> qscale > 31u ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"qscale:%d\\n\" , h -> qscale ) ;\n return - 1 ;\n }\n }\n if ( IS_INTRA16x16 ( mb_type ) ) {\n AV_ZERO128 ( h -> mb_luma_dc [ 0 ] + 0 ) ;\n AV_ZERO128 ( h -> mb_luma_dc [ 0 ] + 8 ) ;\n if ( svq3_decode_block ( & h -> gb , h -> mb_luma_dc [ 0 ] , 0 , 1 ) ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"error while decoding intra luma dc\\n\" ) ;\n return - 1 ;\n }\n }\n if ( cbp ) {\n const int index = IS_INTRA16x16 ( mb_type ) ? 1 : 0 ;\n const int type = ( ( h -> qscale < 24 && IS_INTRA4x4 ( mb_type ) ) ? 2 : 1 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) if ( ( cbp & ( 1 << i ) ) ) {\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n k = index ? ( 1 * ( j & 1 ) + 2 * ( i & 1 ) + 2 * ( j & 2 ) + 4 * ( i & 2 ) ) : ( 4 * i + j ) ;\n h -> non_zero_count_cache [ scan8 [ k ] ] = 1 ;\n if ( svq3_decode_block ( & h -> gb , & h -> mb [ 16 * k ] , index , type ) ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"error while decoding block\\n\" ) ;\n return - 1 ;\n }\n }\n }\n if ( ( cbp & 0x30 ) ) {\n for ( i = 1 ;\n i < 3 ;\n ++ i ) if ( svq3_decode_block ( & h -> gb , & h -> mb [ 16 * 16 * i ] , 0 , 3 ) ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"error while decoding chroma dc block\\n\" ) ;\n return - 1 ;\n }\n if ( ( cbp & 0x20 ) ) {\n for ( i = 1 ;\n i < 3 ;\n i ++ ) {\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n k = 16 * i + j ;\n h -> non_zero_count_cache [ scan8 [ k ] ] = 1 ;\n if ( svq3_decode_block ( & h -> gb , & h -> mb [ 16 * k ] , 1 , 1 ) ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"error while decoding chroma ac block\\n\" ) ;\n return - 1 ;\n }\n }\n }\n }\n }\n }\n h -> cbp = cbp ;\n h -> cur_pic . f . mb_type [ mb_xy ] = mb_type ;\n if ( IS_INTRA ( mb_type ) ) h -> chroma_pred_mode = ff_h264_check_intra_pred_mode ( h , DC_PRED8x8 , 1 ) ;\n return 0 ;\n }",
        "hash": -3569070884878445567,
        "project": "debian",
        "size": 232,
        "slice": {
            "memcpy": [
                [
                    42,
                    " if ( h -> mb_y > 0 ) {\n"
                ],
                [
                    43,
                    " memcpy ( h -> mv_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , h -> cur_pic . f . motion_val [ m ] [ b_xy - h -> b_stride ] , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int svq3_decode_mb ( SVQ3Context * s , unsigned int mb_type ) {\n"
                ],
                [
                    2,
                    " H264Context * h = & s -> h ;\n"
                ],
                [
                    32,
                    " if ( h -> mb_x > 0 && h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - 1 ] + 6 ] != - 1 ) {\n"
                ],
                [
                    42,
                    " if ( h -> mb_y > 0 ) {\n"
                ],
                [
                    44,
                    " memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 , 4 ) ;\n"
                ],
                [
                    47,
                    " h -> ref_cache [ m ] [ scan8 [ 0 ] + 4 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride + 1 ] + 6 ] == - 1 || h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n"
                ],
                [
                    52,
                    " h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride - 1 ] + 3 ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n"
                ],
                [
                    56,
                    " else memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 - 1 ] , PART_NOT_AVAILABLE , 8 ) ;\n"
                ],
                [
                    68,
                    " i < 4 ;\n"
                ],
                [
                    69,
                    " i ++ ) memset ( h -> cur_pic . f . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    76,
                    " i < 4 ;\n"
                ],
                [
                    77,
                    " i ++ ) memset ( h -> cur_pic . f . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    82,
                    " else if ( mb_type == 8 || mb_type == 33 ) {\n"
                ],
                [
                    83,
                    " memset ( h -> intra4x4_pred_mode_cache , - 1 , 8 * 5 * sizeof ( int8_t ) ) ;\n"
                ],
                [
                    106,
                    " left = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 1 ] ;\n"
                ],
                [
                    107,
                    " top = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 8 ] ;\n"
                ],
                [
                    118,
                    " i < 4 ;\n"
                ],
                [
                    119,
                    " i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_PRED , 4 ) ;\n"
                ],
                [
                    121,
                    " write_back_intra_pred_mode ( h ) ;\n"
                ],
                [
                    123,
                    " ff_h264_check_intra4x4_pred_mode ( h ) ;\n"
                ],
                [
                    129,
                    " i < 4 ;\n"
                ],
                [
                    130,
                    " i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_128_PRED , 4 ) ;\n"
                ],
                [
                    139,
                    " if ( ( h -> intra16x16_pred_mode = ff_h264_check_intra_pred_mode ( h , dir , 0 ) ) == - 1 ) {\n"
                ],
                [
                    148,
                    " i < 4 ;\n"
                ],
                [
                    149,
                    " i ++ ) memset ( h -> cur_pic . f . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    152,
                    " i < 4 ;\n"
                ],
                [
                    153,
                    " i ++ ) memset ( h -> cur_pic . f . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    156,
                    " if ( ! IS_INTRA4x4 ( mb_type ) ) {\n"
                ],
                [
                    157,
                    " memset ( h -> intra4x4_pred_mode + h -> mb2br_xy [ mb_xy ] , DC_PRED , 8 ) ;\n"
                ],
                [
                    159,
                    " if ( ! IS_SKIP ( mb_type ) || h -> pict_type == AV_PICTURE_TYPE_B ) {\n"
                ],
                [
                    160,
                    " memset ( h -> non_zero_count_cache + 8 , 0 , 14 * 8 * sizeof ( uint8_t ) ) ;\n"
                ],
                [
                    230,
                    " if ( IS_INTRA ( mb_type ) ) h -> chroma_pred_mode = ff_h264_check_intra_pred_mode ( h , DC_PRED8x8 , 1 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int svq3_decode_mb ( SVQ3Context * s , unsigned int mb_type ) {\n"
                ],
                [
                    2,
                    " H264Context * h = & s -> h ;\n"
                ],
                [
                    32,
                    " if ( h -> mb_x > 0 && h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - 1 ] + 6 ] != - 1 ) {\n"
                ],
                [
                    42,
                    " if ( h -> mb_y > 0 ) {\n"
                ],
                [
                    43,
                    " memcpy ( h -> mv_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , h -> cur_pic . f . motion_val [ m ] [ b_xy - h -> b_stride ] , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    44,
                    " memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 , 4 ) ;\n"
                ],
                [
                    47,
                    " h -> ref_cache [ m ] [ scan8 [ 0 ] + 4 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride + 1 ] + 6 ] == - 1 || h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n"
                ],
                [
                    52,
                    " h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride - 1 ] + 3 ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n"
                ],
                [
                    56,
                    " else memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 - 1 ] , PART_NOT_AVAILABLE , 8 ) ;\n"
                ],
                [
                    68,
                    " i < 4 ;\n"
                ],
                [
                    69,
                    " i ++ ) memset ( h -> cur_pic . f . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    76,
                    " i < 4 ;\n"
                ],
                [
                    77,
                    " i ++ ) memset ( h -> cur_pic . f . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    82,
                    " else if ( mb_type == 8 || mb_type == 33 ) {\n"
                ],
                [
                    83,
                    " memset ( h -> intra4x4_pred_mode_cache , - 1 , 8 * 5 * sizeof ( int8_t ) ) ;\n"
                ],
                [
                    106,
                    " left = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 1 ] ;\n"
                ],
                [
                    107,
                    " top = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 8 ] ;\n"
                ],
                [
                    118,
                    " i < 4 ;\n"
                ],
                [
                    119,
                    " i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_PRED , 4 ) ;\n"
                ],
                [
                    121,
                    " write_back_intra_pred_mode ( h ) ;\n"
                ],
                [
                    123,
                    " ff_h264_check_intra4x4_pred_mode ( h ) ;\n"
                ],
                [
                    129,
                    " i < 4 ;\n"
                ],
                [
                    130,
                    " i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_128_PRED , 4 ) ;\n"
                ],
                [
                    139,
                    " if ( ( h -> intra16x16_pred_mode = ff_h264_check_intra_pred_mode ( h , dir , 0 ) ) == - 1 ) {\n"
                ],
                [
                    148,
                    " i < 4 ;\n"
                ],
                [
                    149,
                    " i ++ ) memset ( h -> cur_pic . f . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    152,
                    " i < 4 ;\n"
                ],
                [
                    153,
                    " i ++ ) memset ( h -> cur_pic . f . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    156,
                    " if ( ! IS_INTRA4x4 ( mb_type ) ) {\n"
                ],
                [
                    157,
                    " memset ( h -> intra4x4_pred_mode + h -> mb2br_xy [ mb_xy ] , DC_PRED , 8 ) ;\n"
                ],
                [
                    159,
                    " if ( ! IS_SKIP ( mb_type ) || h -> pict_type == AV_PICTURE_TYPE_B ) {\n"
                ],
                [
                    160,
                    " memset ( h -> non_zero_count_cache + 8 , 0 , 14 * 8 * sizeof ( uint8_t ) ) ;\n"
                ],
                [
                    230,
                    " if ( IS_INTRA ( mb_type ) ) h -> chroma_pred_mode = ff_h264_check_intra_pred_mode ( h , DC_PRED8x8 , 1 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int svq3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n SVQ3Context * s = avctx -> priv_data ;\n H264Context * h = & s -> h ;\n int buf_size = avpkt -> size ;\n int ret , m , i ;\n if ( buf_size == 0 ) {\n if ( s -> next_pic -> f . data [ 0 ] && ! h -> low_delay && ! s -> last_frame_output ) {\n * ( AVFrame * ) data = s -> next_pic -> f ;\n s -> last_frame_output = 1 ;\n * got_frame = 1 ;\n }\n return 0 ;\n }\n init_get_bits ( & h -> gb , buf , 8 * buf_size ) ;\n h -> mb_x = h -> mb_y = h -> mb_xy = 0 ;\n if ( svq3_decode_slice_header ( avctx ) ) return - 1 ;\n h -> pict_type = h -> slice_type ;\n if ( h -> pict_type != AV_PICTURE_TYPE_B ) FFSWAP ( Picture * , s -> next_pic , s -> last_pic ) ;\n if ( s -> cur_pic -> f . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> cur_pic -> f ) ;\n s -> cur_pic -> f . pict_type = h -> pict_type ;\n s -> cur_pic -> f . key_frame = ( h -> pict_type == AV_PICTURE_TYPE_I ) ;\n ret = get_buffer ( avctx , s -> cur_pic ) ;\n if ( ret < 0 ) return ret ;\n h -> cur_pic_ptr = s -> cur_pic ;\n h -> cur_pic = * s -> cur_pic ;\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n h -> block_offset [ i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) ) + 4 * h -> linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ;\n h -> block_offset [ 48 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) ) + 8 * h -> linesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ;\n }\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n h -> block_offset [ 16 + i ] = h -> block_offset [ 32 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) ) + 4 * h -> uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ;\n h -> block_offset [ 48 + 16 + i ] = h -> block_offset [ 48 + 32 + i ] = ( 4 * ( ( scan8 [ i ] - scan8 [ 0 ] ) & 7 ) ) + 8 * h -> uvlinesize * ( ( scan8 [ i ] - scan8 [ 0 ] ) >> 3 ) ;\n }\n if ( h -> pict_type != AV_PICTURE_TYPE_I ) {\n if ( ! s -> last_pic -> f . data [ 0 ] ) {\n av_log ( avctx , AV_LOG_ERROR , \"Missing reference frame.\\n\" ) ;\n ret = get_buffer ( avctx , s -> last_pic ) ;\n if ( ret < 0 ) return ret ;\n memset ( s -> last_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> last_pic -> f . linesize [ 0 ] ) ;\n memset ( s -> last_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 1 ] ) ;\n memset ( s -> last_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 2 ] ) ;\n }\n if ( h -> pict_type == AV_PICTURE_TYPE_B && ! s -> next_pic -> f . data [ 0 ] ) {\n av_log ( avctx , AV_LOG_ERROR , \"Missing reference frame.\\n\" ) ;\n ret = get_buffer ( avctx , s -> next_pic ) ;\n if ( ret < 0 ) return ret ;\n memset ( s -> next_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> next_pic -> f . linesize [ 0 ] ) ;\n memset ( s -> next_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 1 ] ) ;\n memset ( s -> next_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 2 ] ) ;\n }\n }\n if ( avctx -> debug & FF_DEBUG_PICT_INFO ) av_log ( h -> avctx , AV_LOG_DEBUG , \"%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\\n\" , av_get_picture_type_char ( h -> pict_type ) , s -> halfpel_flag , s -> thirdpel_flag , s -> adaptive_quant , h -> qscale , h -> slice_num ) ;\n if ( avctx -> skip_frame >= AVDISCARD_NONREF && h -> pict_type == AV_PICTURE_TYPE_B || avctx -> skip_frame >= AVDISCARD_NONKEY && h -> pict_type != AV_PICTURE_TYPE_I || avctx -> skip_frame >= AVDISCARD_ALL ) return 0 ;\n if ( s -> next_p_frame_damaged ) {\n if ( h -> pict_type == AV_PICTURE_TYPE_B ) return 0 ;\n else s -> next_p_frame_damaged = 0 ;\n }\n if ( h -> pict_type == AV_PICTURE_TYPE_B ) {\n h -> frame_num_offset = h -> slice_num - h -> prev_frame_num ;\n if ( h -> frame_num_offset < 0 ) h -> frame_num_offset += 256 ;\n if ( h -> frame_num_offset == 0 || h -> frame_num_offset >= h -> prev_frame_num_offset ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"error in B-frame picture id\\n\" ) ;\n return - 1 ;\n }\n }\n else {\n h -> prev_frame_num = h -> frame_num ;\n h -> frame_num = h -> slice_num ;\n h -> prev_frame_num_offset = h -> frame_num - h -> prev_frame_num ;\n if ( h -> prev_frame_num_offset < 0 ) h -> prev_frame_num_offset += 256 ;\n }\n for ( m = 0 ;\n m < 2 ;\n m ++ ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n int j ;\n for ( j = - 1 ;\n j < 4 ;\n j ++ ) h -> ref_cache [ m ] [ scan8 [ 0 ] + 8 * i + j ] = 1 ;\n if ( i < 3 ) h -> ref_cache [ m ] [ scan8 [ 0 ] + 8 * i + j ] = PART_NOT_AVAILABLE ;\n }\n }\n for ( h -> mb_y = 0 ;\n h -> mb_y < h -> mb_height ;\n h -> mb_y ++ ) {\n for ( h -> mb_x = 0 ;\n h -> mb_x < h -> mb_width ;\n h -> mb_x ++ ) {\n unsigned mb_type ;\n h -> mb_xy = h -> mb_x + h -> mb_y * h -> mb_stride ;\n if ( ( get_bits_count ( & h -> gb ) + 7 ) >= h -> gb . size_in_bits && ( ( get_bits_count ( & h -> gb ) & 7 ) == 0 || show_bits ( & h -> gb , - get_bits_count ( & h -> gb ) & 7 ) == 0 ) ) {\n skip_bits ( & h -> gb , s -> next_slice_index - get_bits_count ( & h -> gb ) ) ;\n h -> gb . size_in_bits = 8 * buf_size ;\n if ( svq3_decode_slice_header ( avctx ) ) return - 1 ;\n }\n mb_type = svq3_get_ue_golomb ( & h -> gb ) ;\n if ( h -> pict_type == AV_PICTURE_TYPE_I ) mb_type += 8 ;\n else if ( h -> pict_type == AV_PICTURE_TYPE_B && mb_type >= 4 ) mb_type += 4 ;\n if ( mb_type > 33 || svq3_decode_mb ( s , mb_type ) ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"error while decoding MB %d %d\\n\" , h -> mb_x , h -> mb_y ) ;\n return - 1 ;\n }\n if ( mb_type != 0 ) ff_h264_hl_decode_mb ( h ) ;\n if ( h -> pict_type != AV_PICTURE_TYPE_B && ! h -> low_delay ) h -> cur_pic . f . mb_type [ h -> mb_x + h -> mb_y * h -> mb_stride ] = ( h -> pict_type == AV_PICTURE_TYPE_P && mb_type < 8 ) ? ( mb_type - 1 ) : - 1 ;\n }\n ff_draw_horiz_band ( avctx , NULL , s -> cur_pic , s -> last_pic -> f . data [ 0 ] ? s -> last_pic : NULL , 16 * h -> mb_y , 16 , h -> picture_structure , 0 , 0 , h -> low_delay , h -> mb_height * 16 , h -> mb_width * 16 ) ;\n }\n if ( h -> pict_type == AV_PICTURE_TYPE_B || h -> low_delay ) * ( AVFrame * ) data = s -> cur_pic -> f ;\n else * ( AVFrame * ) data = s -> last_pic -> f ;\n if ( s -> last_pic -> f . data [ 0 ] || h -> low_delay ) * got_frame = 1 ;\n if ( h -> pict_type != AV_PICTURE_TYPE_B ) {\n FFSWAP ( Picture * , s -> cur_pic , s -> next_pic ) ;\n }\n return buf_size ;\n }",
        "hash": -3569070884878445567,
        "project": "debian",
        "size": 123,
        "slice": {
            "memset": [
                [
                    1,
                    "static int svq3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    40,
                    " if ( ! s -> last_pic -> f . data [ 0 ] ) {\n"
                ],
                [
                    43,
                    " if ( ret < 0 ) return ret ;\n"
                ],
                [
                    44,
                    " memset ( s -> last_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> last_pic -> f . linesize [ 0 ] ) ;\n"
                ],
                [
                    45,
                    " memset ( s -> last_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 1 ] ) ;\n"
                ],
                [
                    46,
                    " memset ( s -> last_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 2 ] ) ;\n"
                ],
                [
                    48,
                    " if ( h -> pict_type == AV_PICTURE_TYPE_B && ! s -> next_pic -> f . data [ 0 ] ) {\n"
                ],
                [
                    51,
                    " if ( ret < 0 ) return ret ;\n"
                ],
                [
                    52,
                    " memset ( s -> next_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> next_pic -> f . linesize [ 0 ] ) ;\n"
                ],
                [
                    53,
                    " memset ( s -> next_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 1 ] ) ;\n"
                ],
                [
                    54,
                    " memset ( s -> next_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 2 ] ) ;\n"
                ],
                [
                    118,
                    " if ( s -> last_pic -> f . data [ 0 ] || h -> low_delay ) * got_frame = 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int svq3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    40,
                    " if ( ! s -> last_pic -> f . data [ 0 ] ) {\n"
                ],
                [
                    43,
                    " if ( ret < 0 ) return ret ;\n"
                ],
                [
                    44,
                    " memset ( s -> last_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> last_pic -> f . linesize [ 0 ] ) ;\n"
                ],
                [
                    45,
                    " memset ( s -> last_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 1 ] ) ;\n"
                ],
                [
                    46,
                    " memset ( s -> last_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 2 ] ) ;\n"
                ],
                [
                    48,
                    " if ( h -> pict_type == AV_PICTURE_TYPE_B && ! s -> next_pic -> f . data [ 0 ] ) {\n"
                ],
                [
                    51,
                    " if ( ret < 0 ) return ret ;\n"
                ],
                [
                    52,
                    " memset ( s -> next_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> next_pic -> f . linesize [ 0 ] ) ;\n"
                ],
                [
                    53,
                    " memset ( s -> next_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 1 ] ) ;\n"
                ],
                [
                    54,
                    " memset ( s -> next_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 2 ] ) ;\n"
                ],
                [
                    118,
                    " if ( s -> last_pic -> f . data [ 0 ] || h -> low_delay ) * got_frame = 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int g723_1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n G723_1_Context * p = avctx -> priv_data ;\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int dec_mode = buf [ 0 ] & 3 ;\n PPFParam ppf [ SUBFRAMES ] ;\n int16_t cur_lsp [ LPC_ORDER ] ;\n int16_t lpc [ SUBFRAMES * LPC_ORDER ] ;\n int16_t acb_vector [ SUBFRAME_LEN ] ;\n int16_t * out ;\n int bad_frame = 0 , i , j , ret ;\n int16_t * audio = p -> audio ;\n if ( buf_size < frame_size [ dec_mode ] ) {\n if ( buf_size ) av_log ( avctx , AV_LOG_WARNING , \"Expected %d bytes, got %d - skipping packet\\n\" , frame_size [ dec_mode ] , buf_size ) ;\n * got_frame_ptr = 0 ;\n return buf_size ;\n }\n if ( unpack_bitstream ( p , buf , buf_size ) < 0 ) {\n bad_frame = 1 ;\n if ( p -> past_frame_type == ACTIVE_FRAME ) p -> cur_frame_type = ACTIVE_FRAME ;\n else p -> cur_frame_type = UNTRANSMITTED_FRAME ;\n }\n frame -> nb_samples = FRAME_LEN ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n out = ( int16_t * ) frame -> data [ 0 ] ;\n if ( p -> cur_frame_type == ACTIVE_FRAME ) {\n if ( ! bad_frame ) p -> erased_frames = 0 ;\n else if ( p -> erased_frames != 3 ) p -> erased_frames ++ ;\n inverse_quant ( cur_lsp , p -> prev_lsp , p -> lsp_index , bad_frame ) ;\n lsp_interpolate ( lpc , cur_lsp , p -> prev_lsp ) ;\n memcpy ( p -> prev_lsp , cur_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n memcpy ( p -> excitation , p -> prev_excitation , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n if ( ! p -> erased_frames ) {\n int16_t * vector_ptr = p -> excitation + PITCH_MAX ;\n p -> interp_gain = fixed_cb_gain [ ( p -> subframe [ 2 ] . amp_index + p -> subframe [ 3 ] . amp_index ) >> 1 ] ;\n for ( i = 0 ;\n i < SUBFRAMES ;\n i ++ ) {\n gen_fcb_excitation ( vector_ptr , & p -> subframe [ i ] , p -> cur_rate , p -> pitch_lag [ i >> 1 ] , i ) ;\n gen_acb_excitation ( acb_vector , & p -> excitation [ SUBFRAME_LEN * i ] , p -> pitch_lag [ i >> 1 ] , & p -> subframe [ i ] , p -> cur_rate ) ;\n for ( j = 0 ;\n j < SUBFRAME_LEN ;\n j ++ ) {\n int v = av_clip_int16 ( vector_ptr [ j ] << 1 ) ;\n vector_ptr [ j ] = av_clip_int16 ( v + acb_vector [ j ] ) ;\n }\n vector_ptr += SUBFRAME_LEN ;\n }\n vector_ptr = p -> excitation + PITCH_MAX ;\n p -> interp_index = comp_interp_index ( p , p -> pitch_lag [ 1 ] , & p -> sid_gain , & p -> cur_gain ) ;\n if ( p -> postfilter ) {\n i = PITCH_MAX ;\n for ( j = 0 ;\n j < SUBFRAMES ;\n i += SUBFRAME_LEN , j ++ ) comp_ppf_coeff ( p , i , p -> pitch_lag [ j >> 1 ] , ppf + j , p -> cur_rate ) ;\n for ( i = 0 , j = 0 ;\n j < SUBFRAMES ;\n i += SUBFRAME_LEN , j ++ ) ff_acelp_weighted_vector_sum ( p -> audio + LPC_ORDER + i , vector_ptr + i , vector_ptr + i + ppf [ j ] . index , ppf [ j ] . sc_gain , ppf [ j ] . opt_gain , 1 << 14 , 15 , SUBFRAME_LEN ) ;\n }\n else {\n audio = vector_ptr - LPC_ORDER ;\n }\n memcpy ( p -> prev_excitation , p -> excitation + FRAME_LEN , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n }\n else {\n p -> interp_gain = ( p -> interp_gain * 3 + 2 ) >> 2 ;\n if ( p -> erased_frames == 3 ) {\n memset ( p -> excitation , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * p -> excitation ) ) ;\n memset ( p -> prev_excitation , 0 , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n memset ( frame -> data [ 0 ] , 0 , ( FRAME_LEN + LPC_ORDER ) * sizeof ( int16_t ) ) ;\n }\n else {\n int16_t * buf = p -> audio + LPC_ORDER ;\n residual_interp ( p -> excitation , buf , p -> interp_index , p -> interp_gain , & p -> random_seed ) ;\n memcpy ( p -> prev_excitation , buf + ( FRAME_LEN - PITCH_MAX ) , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n }\n }\n p -> cng_random_seed = CNG_RANDOM_SEED ;\n }\n else {\n if ( p -> cur_frame_type == SID_FRAME ) {\n p -> sid_gain = sid_gain_to_lsp_index ( p -> subframe [ 0 ] . amp_index ) ;\n inverse_quant ( p -> sid_lsp , p -> prev_lsp , p -> lsp_index , 0 ) ;\n }\n else if ( p -> past_frame_type == ACTIVE_FRAME ) {\n p -> sid_gain = estimate_sid_gain ( p ) ;\n }\n if ( p -> past_frame_type == ACTIVE_FRAME ) p -> cur_gain = p -> sid_gain ;\n else p -> cur_gain = ( p -> cur_gain * 7 + p -> sid_gain ) >> 3 ;\n generate_noise ( p ) ;\n lsp_interpolate ( lpc , p -> sid_lsp , p -> prev_lsp ) ;\n memcpy ( p -> prev_lsp , p -> sid_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n }\n p -> past_frame_type = p -> cur_frame_type ;\n memcpy ( p -> audio , p -> synth_mem , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n for ( i = LPC_ORDER , j = 0 ;\n j < SUBFRAMES ;\n i += SUBFRAME_LEN , j ++ ) ff_celp_lp_synthesis_filter ( p -> audio + i , & lpc [ j * LPC_ORDER ] , audio + i , SUBFRAME_LEN , LPC_ORDER , 0 , 1 , 1 << 12 ) ;\n memcpy ( p -> synth_mem , p -> audio + FRAME_LEN , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n if ( p -> postfilter ) {\n formant_postfilter ( p , lpc , p -> audio , out ) ;\n }\n else {\n for ( i = 0 ;\n i < FRAME_LEN ;\n i ++ ) out [ i ] = av_clip_int16 ( p -> audio [ LPC_ORDER + i ] << 1 ) ;\n }\n * got_frame_ptr = 1 ;\n return frame_size [ dec_mode ] ;\n }",
        "hash": -2591112946600337077,
        "project": "debian",
        "size": 114,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int g723_1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " G723_1_Context * p = avctx -> priv_data ;\n"
                ],
                [
                    6,
                    " int dec_mode = buf [ 0 ] & 3 ;\n"
                ],
                [
                    19,
                    " if ( unpack_bitstream ( p , buf , buf_size ) < 0 ) {\n"
                ],
                [
                    25,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ],
                [
                    30,
                    " if ( p -> cur_frame_type == ACTIVE_FRAME ) {\n"
                ],
                [
                    34,
                    " lsp_interpolate ( lpc , cur_lsp , p -> prev_lsp ) ;\n"
                ],
                [
                    35,
                    " memcpy ( p -> prev_lsp , cur_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n"
                ],
                [
                    36,
                    " memcpy ( p -> excitation , p -> prev_excitation , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    37,
                    " if ( ! p -> erased_frames ) {\n"
                ],
                [
                    38,
                    " int16_t * vector_ptr = p -> excitation + PITCH_MAX ;\n"
                ],
                [
                    44,
                    " gen_acb_excitation ( acb_vector , & p -> excitation [ SUBFRAME_LEN * i ] , p -> pitch_lag [ i >> 1 ] , & p -> subframe [ i ] , p -> cur_rate ) ;\n"
                ],
                [
                    53,
                    " vector_ptr = p -> excitation + PITCH_MAX ;\n"
                ],
                [
                    54,
                    " p -> interp_index = comp_interp_index ( p , p -> pitch_lag [ 1 ] , & p -> sid_gain , & p -> cur_gain ) ;\n"
                ],
                [
                    59,
                    " i += SUBFRAME_LEN , j ++ ) comp_ppf_coeff ( p , i , p -> pitch_lag [ j >> 1 ] , ppf + j , p -> cur_rate ) ;\n"
                ],
                [
                    67,
                    " memcpy ( p -> prev_excitation , p -> excitation + FRAME_LEN , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    71,
                    " if ( p -> erased_frames == 3 ) {\n"
                ],
                [
                    72,
                    " memset ( p -> excitation , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    73,
                    " memset ( p -> prev_excitation , 0 , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    78,
                    " residual_interp ( p -> excitation , buf , p -> interp_index , p -> interp_gain , & p -> random_seed ) ;\n"
                ],
                [
                    79,
                    " memcpy ( p -> prev_excitation , buf + ( FRAME_LEN - PITCH_MAX ) , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    94,
                    " generate_noise ( p ) ;\n"
                ],
                [
                    95,
                    " lsp_interpolate ( lpc , p -> sid_lsp , p -> prev_lsp ) ;\n"
                ],
                [
                    96,
                    " memcpy ( p -> prev_lsp , p -> sid_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n"
                ],
                [
                    99,
                    " memcpy ( p -> audio , p -> synth_mem , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n"
                ],
                [
                    102,
                    " i += SUBFRAME_LEN , j ++ ) ff_celp_lp_synthesis_filter ( p -> audio + i , & lpc [ j * LPC_ORDER ] , audio + i , SUBFRAME_LEN , LPC_ORDER , 0 , 1 , 1 << 12 ) ;\n"
                ],
                [
                    103,
                    " memcpy ( p -> synth_mem , p -> audio + FRAME_LEN , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n"
                ],
                [
                    105,
                    " formant_postfilter ( p , lpc , p -> audio , out ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int g723_1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    19,
                    " if ( unpack_bitstream ( p , buf , buf_size ) < 0 ) {\n"
                ],
                [
                    36,
                    " memcpy ( p -> excitation , p -> prev_excitation , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    71,
                    " if ( p -> erased_frames == 3 ) {\n"
                ],
                [
                    72,
                    " memset ( p -> excitation , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    73,
                    " memset ( p -> prev_excitation , 0 , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    74,
                    " memset ( frame -> data [ 0 ] , 0 , ( FRAME_LEN + LPC_ORDER ) * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    105,
                    " formant_postfilter ( p , lpc , p -> audio , out ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int g723_1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " G723_1_Context * p = avctx -> priv_data ;\n"
                ],
                [
                    6,
                    " int dec_mode = buf [ 0 ] & 3 ;\n"
                ],
                [
                    19,
                    " if ( unpack_bitstream ( p , buf , buf_size ) < 0 ) {\n"
                ],
                [
                    25,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ],
                [
                    30,
                    " if ( p -> cur_frame_type == ACTIVE_FRAME ) {\n"
                ],
                [
                    34,
                    " lsp_interpolate ( lpc , cur_lsp , p -> prev_lsp ) ;\n"
                ],
                [
                    35,
                    " memcpy ( p -> prev_lsp , cur_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n"
                ],
                [
                    36,
                    " memcpy ( p -> excitation , p -> prev_excitation , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    37,
                    " if ( ! p -> erased_frames ) {\n"
                ],
                [
                    38,
                    " int16_t * vector_ptr = p -> excitation + PITCH_MAX ;\n"
                ],
                [
                    44,
                    " gen_acb_excitation ( acb_vector , & p -> excitation [ SUBFRAME_LEN * i ] , p -> pitch_lag [ i >> 1 ] , & p -> subframe [ i ] , p -> cur_rate ) ;\n"
                ],
                [
                    53,
                    " vector_ptr = p -> excitation + PITCH_MAX ;\n"
                ],
                [
                    54,
                    " p -> interp_index = comp_interp_index ( p , p -> pitch_lag [ 1 ] , & p -> sid_gain , & p -> cur_gain ) ;\n"
                ],
                [
                    59,
                    " i += SUBFRAME_LEN , j ++ ) comp_ppf_coeff ( p , i , p -> pitch_lag [ j >> 1 ] , ppf + j , p -> cur_rate ) ;\n"
                ],
                [
                    67,
                    " memcpy ( p -> prev_excitation , p -> excitation + FRAME_LEN , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    71,
                    " if ( p -> erased_frames == 3 ) {\n"
                ],
                [
                    72,
                    " memset ( p -> excitation , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    73,
                    " memset ( p -> prev_excitation , 0 , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    74,
                    " memset ( frame -> data [ 0 ] , 0 , ( FRAME_LEN + LPC_ORDER ) * sizeof ( int16_t ) ) ;\n"
                ],
                [
                    78,
                    " residual_interp ( p -> excitation , buf , p -> interp_index , p -> interp_gain , & p -> random_seed ) ;\n"
                ],
                [
                    79,
                    " memcpy ( p -> prev_excitation , buf + ( FRAME_LEN - PITCH_MAX ) , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n"
                ],
                [
                    94,
                    " generate_noise ( p ) ;\n"
                ],
                [
                    95,
                    " lsp_interpolate ( lpc , p -> sid_lsp , p -> prev_lsp ) ;\n"
                ],
                [
                    96,
                    " memcpy ( p -> prev_lsp , p -> sid_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n"
                ],
                [
                    99,
                    " memcpy ( p -> audio , p -> synth_mem , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n"
                ],
                [
                    102,
                    " i += SUBFRAME_LEN , j ++ ) ff_celp_lp_synthesis_filter ( p -> audio + i , & lpc [ j * LPC_ORDER ] , audio + i , SUBFRAME_LEN , LPC_ORDER , 0 , 1 , 1 << 12 ) ;\n"
                ],
                [
                    103,
                    " memcpy ( p -> synth_mem , p -> audio + FRAME_LEN , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n"
                ],
                [
                    105,
                    " formant_postfilter ( p , lpc , p -> audio , out ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n uint8_t ctable [ 128 ] ;\n QpegContext * const a = avctx -> priv_data ;\n AVFrame * const p = & a -> pic ;\n uint8_t * outdata ;\n int delta , ret ;\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( avpkt -> size < 0x86 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_init ( & a -> buffer , avpkt -> data , avpkt -> size ) ;\n p -> reference = 3 ;\n if ( ( ret = avctx -> reget_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n outdata = a -> pic . data [ 0 ] ;\n bytestream2_skip ( & a -> buffer , 4 ) ;\n bytestream2_get_buffer ( & a -> buffer , ctable , 128 ) ;\n bytestream2_skip ( & a -> buffer , 1 ) ;\n delta = bytestream2_get_byte ( & a -> buffer ) ;\n if ( delta == 0x10 ) {\n qpeg_decode_intra ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height ) ;\n }\n else {\n qpeg_decode_inter ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height , delta , ctable , a -> refdata ) ;\n }\n if ( pal ) {\n a -> pic . palette_has_changed = 1 ;\n memcpy ( a -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( a -> pic . data [ 1 ] , a -> pal , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = a -> pic ;\n return avpkt -> size ;\n }",
        "hash": -6733199768332268221,
        "project": "debian",
        "size": 37,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    7,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    14,
                    " if ( ( ret = avctx -> reget_buffer ( avctx , p ) ) < 0 ) {\n"
                ],
                [
                    24,
                    " qpeg_decode_intra ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height ) ;\n"
                ],
                [
                    27,
                    " qpeg_decode_inter ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height , delta , ctable , a -> refdata ) ;\n"
                ],
                [
                    29,
                    " if ( pal ) {\n"
                ],
                [
                    31,
                    " memcpy ( a -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    33,
                    " memcpy ( a -> pic . data [ 1 ] , a -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    7,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    14,
                    " if ( ( ret = avctx -> reget_buffer ( avctx , p ) ) < 0 ) {\n"
                ],
                [
                    24,
                    " qpeg_decode_intra ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height ) ;\n"
                ],
                [
                    27,
                    " qpeg_decode_inter ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height , delta , ctable , a -> refdata ) ;\n"
                ],
                [
                    29,
                    " if ( pal ) {\n"
                ],
                [
                    31,
                    " memcpy ( a -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    33,
                    " memcpy ( a -> pic . data [ 1 ] , a -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int libschroedinger_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int64_t pts = avpkt -> pts ;\n SchroTag * tag ;\n SchroDecoderParams * p_schro_params = avctx -> priv_data ;\n SchroDecoder * decoder = p_schro_params -> decoder ;\n SchroBuffer * enc_buf ;\n SchroFrame * frame ;\n int state ;\n int go = 1 ;\n int outer = 1 ;\n SchroParseUnitContext parse_ctx ;\n LibSchroFrameContext * framewithpts = NULL ;\n * got_frame = 0 ;\n parse_context_init ( & parse_ctx , buf , buf_size ) ;\n if ( ! buf_size ) {\n if ( ! p_schro_params -> eos_signalled ) {\n state = schro_decoder_push_end_of_stream ( decoder ) ;\n p_schro_params -> eos_signalled = 1 ;\n }\n }\n do {\n if ( ( enc_buf = find_next_parse_unit ( & parse_ctx ) ) ) {\n enc_buf -> tag = schro_tag_new ( av_malloc ( sizeof ( int64_t ) ) , av_free ) ;\n if ( ! enc_buf -> tag -> value ) {\n av_log ( avctx , AV_LOG_ERROR , \"Unable to allocate SchroTag\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n AV_WN ( 64 , enc_buf -> tag -> value , pts ) ;\n if ( SCHRO_PARSE_CODE_IS_PICTURE ( enc_buf -> data [ 4 ] ) && SCHRO_PARSE_CODE_NUM_REFS ( enc_buf -> data [ 4 ] ) > 0 ) avctx -> has_b_frames = 1 ;\n state = schro_decoder_push ( decoder , enc_buf ) ;\n if ( state == SCHRO_DECODER_FIRST_ACCESS_UNIT ) libschroedinger_handle_first_access_unit ( avctx ) ;\n go = 1 ;\n }\n else outer = 0 ;\n while ( go ) {\n state = schro_decoder_wait ( decoder ) ;\n switch ( state ) {\n case SCHRO_DECODER_FIRST_ACCESS_UNIT : libschroedinger_handle_first_access_unit ( avctx ) ;\n break ;\n case SCHRO_DECODER_NEED_BITS : go = 0 ;\n break ;\n case SCHRO_DECODER_NEED_FRAME : frame = ff_create_schro_frame ( avctx , p_schro_params -> frame_format ) ;\n schro_decoder_add_output_picture ( decoder , frame ) ;\n break ;\n case SCHRO_DECODER_OK : tag = schro_decoder_get_picture_tag ( decoder ) ;\n frame = schro_decoder_pull ( decoder ) ;\n if ( frame ) {\n framewithpts = av_malloc ( sizeof ( LibSchroFrameContext ) ) ;\n if ( ! framewithpts ) {\n av_log ( avctx , AV_LOG_ERROR , \"Unable to allocate FrameWithPts\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n framewithpts -> frame = frame ;\n framewithpts -> pts = AV_RN64 ( tag -> value ) ;\n ff_schro_queue_push_back ( & p_schro_params -> dec_frame_queue , framewithpts ) ;\n }\n break ;\n case SCHRO_DECODER_EOS : go = 0 ;\n p_schro_params -> eos_pulled = 1 ;\n schro_decoder_reset ( decoder ) ;\n outer = 0 ;\n break ;\n case SCHRO_DECODER_ERROR : return - 1 ;\n break ;\n }\n }\n }\n while ( outer ) ;\n framewithpts = ff_schro_queue_pop ( & p_schro_params -> dec_frame_queue ) ;\n if ( framewithpts && framewithpts -> frame ) {\n if ( p_schro_params -> dec_frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & p_schro_params -> dec_frame ) ;\n if ( ff_get_buffer ( avctx , & p_schro_params -> dec_frame ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Unable to allocate buffer\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n memcpy ( p_schro_params -> dec_frame . data [ 0 ] , framewithpts -> frame -> components [ 0 ] . data , framewithpts -> frame -> components [ 0 ] . length ) ;\n memcpy ( p_schro_params -> dec_frame . data [ 1 ] , framewithpts -> frame -> components [ 1 ] . data , framewithpts -> frame -> components [ 1 ] . length ) ;\n memcpy ( p_schro_params -> dec_frame . data [ 2 ] , framewithpts -> frame -> components [ 2 ] . data , framewithpts -> frame -> components [ 2 ] . length ) ;\n p_schro_params -> dec_frame . format = - 1 ;\n p_schro_params -> dec_frame . width = framewithpts -> frame -> width ;\n p_schro_params -> dec_frame . height = framewithpts -> frame -> height ;\n p_schro_params -> dec_frame . pkt_pts = framewithpts -> pts ;\n p_schro_params -> dec_frame . linesize [ 0 ] = framewithpts -> frame -> components [ 0 ] . stride ;\n p_schro_params -> dec_frame . linesize [ 1 ] = framewithpts -> frame -> components [ 1 ] . stride ;\n p_schro_params -> dec_frame . linesize [ 2 ] = framewithpts -> frame -> components [ 2 ] . stride ;\n * ( AVFrame * ) data = p_schro_params -> dec_frame ;\n * got_frame = 1 ;\n libschroedinger_decode_frame_free ( framewithpts -> frame ) ;\n av_free ( framewithpts ) ;\n }\n else {\n data = NULL ;\n * got_frame = 0 ;\n }\n return buf_size ;\n }",
        "hash": -938099838013462850,
        "project": "debian",
        "size": 98,
        "slice": {
            "memcpy": [
                [
                    74,
                    " if ( ff_get_buffer ( avctx , & p_schro_params -> dec_frame ) < 0 ) {\n"
                ],
                [
                    78,
                    " memcpy ( p_schro_params -> dec_frame . data [ 0 ] , framewithpts -> frame -> components [ 0 ] . data , framewithpts -> frame -> components [ 0 ] . length ) ;\n"
                ],
                [
                    79,
                    " memcpy ( p_schro_params -> dec_frame . data [ 1 ] , framewithpts -> frame -> components [ 1 ] . data , framewithpts -> frame -> components [ 1 ] . length ) ;\n"
                ],
                [
                    80,
                    " memcpy ( p_schro_params -> dec_frame . data [ 2 ] , framewithpts -> frame -> components [ 2 ] . data , framewithpts -> frame -> components [ 2 ] . length ) ;\n"
                ]
            ],
            "result": [
                [
                    74,
                    " if ( ff_get_buffer ( avctx , & p_schro_params -> dec_frame ) < 0 ) {\n"
                ],
                [
                    78,
                    " memcpy ( p_schro_params -> dec_frame . data [ 0 ] , framewithpts -> frame -> components [ 0 ] . data , framewithpts -> frame -> components [ 0 ] . length ) ;\n"
                ],
                [
                    79,
                    " memcpy ( p_schro_params -> dec_frame . data [ 1 ] , framewithpts -> frame -> components [ 1 ] . data , framewithpts -> frame -> components [ 1 ] . length ) ;\n"
                ],
                [
                    80,
                    " memcpy ( p_schro_params -> dec_frame . data [ 2 ] , framewithpts -> frame -> components [ 2 ] . data , framewithpts -> frame -> components [ 2 ] . length ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int idcin_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n IdcinContext * s = avctx -> priv_data ;\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n s -> buf = buf ;\n s -> size = buf_size ;\n if ( s -> frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> frame ) ;\n if ( ff_get_buffer ( avctx , & s -> frame ) ) {\n av_log ( avctx , AV_LOG_ERROR , \" id CIN Video: get_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n idcin_decode_vlcs ( s ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": 730982944360815735,
        "project": "debian",
        "size": 22,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int idcin_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    9,
                    " if ( ff_get_buffer ( avctx , & s -> frame ) ) {\n"
                ],
                [
                    13,
                    " idcin_decode_vlcs ( s ) ;\n"
                ],
                [
                    14,
                    " if ( pal ) {\n"
                ],
                [
                    16,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    18,
                    " memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int idcin_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    9,
                    " if ( ff_get_buffer ( avctx , & s -> frame ) ) {\n"
                ],
                [
                    13,
                    " idcin_decode_vlcs ( s ) ;\n"
                ],
                [
                    14,
                    " if ( pal ) {\n"
                ],
                [
                    16,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    18,
                    " memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n CamtasiaContext * const c = avctx -> priv_data ;\n const unsigned char * encoded = buf ;\n int zret ;\n int ret , len = buf_size ;\n if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n c -> pic . reference = 1 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID ;\n if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n zret = inflateReset ( & c -> zstream ) ;\n if ( zret != Z_OK ) {\n av_log ( avctx , AV_LOG_ERROR , \"Inflate reset error: %d\\n\" , zret ) ;\n return AVERROR_UNKNOWN ;\n }\n c -> zstream . next_in = encoded ;\n c -> zstream . avail_in = len ;\n c -> zstream . next_out = c -> decomp_buf ;\n c -> zstream . avail_out = c -> decomp_size ;\n zret = inflate ( & c -> zstream , Z_FINISH ) ;\n if ( ( zret != Z_OK ) && ( zret != Z_STREAM_END ) && ( zret != Z_DATA_ERROR ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Inflate error: %d\\n\" , zret ) ;\n return AVERROR_UNKNOWN ;\n }\n if ( zret != Z_DATA_ERROR ) {\n bytestream2_init ( & c -> gb , c -> decomp_buf , c -> decomp_size - c -> zstream . avail_out ) ;\n ff_msrle_decode ( avctx , ( AVPicture * ) & c -> pic , c -> bpp , & c -> gb ) ;\n }\n if ( c -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n c -> pic . palette_has_changed = 1 ;\n memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }",
        "hash": 2066486429767443123,
        "project": "debian",
        "size": 44,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " CamtasiaContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    33,
                    " if ( c -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) {\n"
                ],
                [
                    34,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    35,
                    " if ( pal ) {\n"
                ],
                [
                    37,
                    " memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    39,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " CamtasiaContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    33,
                    " if ( c -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) {\n"
                ],
                [
                    34,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    35,
                    " if ( pal ) {\n"
                ],
                [
                    37,
                    " memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    39,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int pnm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n PNMContext * const s = avctx -> priv_data ;\n AVFrame * picture = data ;\n AVFrame * const p = & s -> picture ;\n int i , j , n , linesize , h , upgrade = 0 ;\n unsigned char * ptr ;\n int components , sample_len , ret ;\n s -> bytestream_start = s -> bytestream = buf ;\n s -> bytestream_end = buf + buf_size ;\n if ( ( ret = ff_pnm_decode_header ( avctx , s ) ) < 0 ) return ret ;\n if ( p -> data [ 0 ] ) avctx -> release_buffer ( avctx , p ) ;\n p -> reference = 0 ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n switch ( avctx -> pix_fmt ) {\n default : return AVERROR ( EINVAL ) ;\n case AV_PIX_FMT_RGB48BE : n = avctx -> width * 6 ;\n components = 3 ;\n sample_len = 16 ;\n goto do_read ;\n case AV_PIX_FMT_RGB24 : n = avctx -> width * 3 ;\n components = 3 ;\n sample_len = 8 ;\n goto do_read ;\n case AV_PIX_FMT_GRAY8 : n = avctx -> width ;\n components = 1 ;\n sample_len = 8 ;\n if ( s -> maxval < 255 ) upgrade = 1 ;\n goto do_read ;\n case AV_PIX_FMT_GRAY16BE : case AV_PIX_FMT_GRAY16LE : n = avctx -> width * 2 ;\n components = 1 ;\n sample_len = 16 ;\n if ( s -> maxval < 65535 ) upgrade = 2 ;\n goto do_read ;\n case AV_PIX_FMT_MONOWHITE : case AV_PIX_FMT_MONOBLACK : n = ( avctx -> width + 7 ) >> 3 ;\n components = 1 ;\n sample_len = 1 ;\n do_read : ptr = p -> data [ 0 ] ;\n linesize = p -> linesize [ 0 ] ;\n if ( s -> bytestream + n * avctx -> height > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n if ( s -> type < 4 ) {\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n PutBitContext pb ;\n init_put_bits ( & pb , ptr , linesize ) ;\n for ( j = 0 ;\n j < avctx -> width * components ;\n j ++ ) {\n unsigned int c = 0 ;\n int v = 0 ;\n while ( s -> bytestream < s -> bytestream_end && ( * s -> bytestream < '0' || * s -> bytestream > '9' ) ) s -> bytestream ++ ;\n if ( s -> bytestream >= s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n do {\n v = 10 * v + c ;\n c = ( * s -> bytestream ++ ) - '0' ;\n }\n while ( c <= 9 ) ;\n put_bits ( & pb , sample_len , ( ( ( 1 << sample_len ) - 1 ) * v + ( s -> maxval >> 1 ) ) / s -> maxval ) ;\n }\n flush_put_bits ( & pb ) ;\n ptr += linesize ;\n }\n }\n else {\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n if ( ! upgrade ) memcpy ( ptr , s -> bytestream , n ) ;\n else if ( upgrade == 1 ) {\n unsigned int j , f = ( 255 * 128 + s -> maxval / 2 ) / s -> maxval ;\n for ( j = 0 ;\n j < n ;\n j ++ ) ptr [ j ] = ( s -> bytestream [ j ] * f + 64 ) >> 7 ;\n }\n else if ( upgrade == 2 ) {\n unsigned int j , v , f = ( 65535 * 32768 + s -> maxval / 2 ) / s -> maxval ;\n for ( j = 0 ;\n j < n / 2 ;\n j ++ ) {\n v = av_be2ne16 ( ( ( uint16_t * ) s -> bytestream ) [ j ] ) ;\n ( ( uint16_t * ) ptr ) [ j ] = ( v * f + 16384 ) >> 15 ;\n }\n }\n s -> bytestream += n ;\n ptr += linesize ;\n }\n }\n break ;\n case AV_PIX_FMT_YUV420P : case AV_PIX_FMT_YUV420P9BE : case AV_PIX_FMT_YUV420P10BE : {\n unsigned char * ptr1 , * ptr2 ;\n n = avctx -> width ;\n ptr = p -> data [ 0 ] ;\n linesize = p -> linesize [ 0 ] ;\n if ( s -> maxval >= 256 ) n *= 2 ;\n if ( s -> bytestream + n * avctx -> height * 3 / 2 > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n memcpy ( ptr , s -> bytestream , n ) ;\n s -> bytestream += n ;\n ptr += linesize ;\n }\n ptr1 = p -> data [ 1 ] ;\n ptr2 = p -> data [ 2 ] ;\n n >>= 1 ;\n h = avctx -> height >> 1 ;\n for ( i = 0 ;\n i < h ;\n i ++ ) {\n memcpy ( ptr1 , s -> bytestream , n ) ;\n s -> bytestream += n ;\n memcpy ( ptr2 , s -> bytestream , n ) ;\n s -> bytestream += n ;\n ptr1 += p -> linesize [ 1 ] ;\n ptr2 += p -> linesize [ 2 ] ;\n }\n }\n break ;\n case AV_PIX_FMT_YUV420P16 : {\n uint16_t * ptr1 , * ptr2 ;\n const int f = ( 65535 * 32768 + s -> maxval / 2 ) / s -> maxval ;\n unsigned int j , v ;\n n = avctx -> width * 2 ;\n ptr = p -> data [ 0 ] ;\n linesize = p -> linesize [ 0 ] ;\n if ( s -> bytestream + n * avctx -> height * 3 / 2 > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n for ( j = 0 ;\n j < n / 2 ;\n j ++ ) {\n v = av_be2ne16 ( ( ( uint16_t * ) s -> bytestream ) [ j ] ) ;\n ( ( uint16_t * ) ptr ) [ j ] = ( v * f + 16384 ) >> 15 ;\n }\n s -> bytestream += n ;\n ptr += linesize ;\n }\n ptr1 = ( uint16_t * ) p -> data [ 1 ] ;\n ptr2 = ( uint16_t * ) p -> data [ 2 ] ;\n n >>= 1 ;\n h = avctx -> height >> 1 ;\n for ( i = 0 ;\n i < h ;\n i ++ ) {\n for ( j = 0 ;\n j < n / 2 ;\n j ++ ) {\n v = av_be2ne16 ( ( ( uint16_t * ) s -> bytestream ) [ j ] ) ;\n ptr1 [ j ] = ( v * f + 16384 ) >> 15 ;\n }\n s -> bytestream += n ;\n for ( j = 0 ;\n j < n / 2 ;\n j ++ ) {\n v = av_be2ne16 ( ( ( uint16_t * ) s -> bytestream ) [ j ] ) ;\n ptr2 [ j ] = ( v * f + 16384 ) >> 15 ;\n }\n s -> bytestream += n ;\n ptr1 += p -> linesize [ 1 ] / 2 ;\n ptr2 += p -> linesize [ 2 ] / 2 ;\n }\n }\n break ;\n case AV_PIX_FMT_RGB32 : ptr = p -> data [ 0 ] ;\n linesize = p -> linesize [ 0 ] ;\n if ( s -> bytestream + avctx -> width * avctx -> height * 4 > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n int j , r , g , b , a ;\n for ( j = 0 ;\n j < avctx -> width ;\n j ++ ) {\n r = * s -> bytestream ++ ;\n g = * s -> bytestream ++ ;\n b = * s -> bytestream ++ ;\n a = * s -> bytestream ++ ;\n ( ( uint32_t * ) ptr ) [ j ] = ( a << 24 ) | ( r << 16 ) | ( g << 8 ) | b ;\n }\n ptr += linesize ;\n }\n break ;\n }\n * picture = s -> picture ;\n * got_frame = 1 ;\n return s -> bytestream - s -> bytestream_start ;\n }",
        "hash": -4930126955259190757,
        "project": "debian",
        "size": 195,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int pnm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    10,
                    " s -> bytestream_start = s -> bytestream = buf ;\n"
                ],
                [
                    12,
                    " if ( ( ret = ff_pnm_decode_header ( avctx , s ) ) < 0 ) return ret ;\n"
                ],
                [
                    44,
                    " do_read : ptr = p -> data [ 0 ] ;\n"
                ],
                [
                    46,
                    " if ( s -> bytestream + n * avctx -> height > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    75,
                    " if ( ! upgrade ) memcpy ( ptr , s -> bytestream , n ) ;\n"
                ],
                [
                    79,
                    " j < n ;\n"
                ],
                [
                    80,
                    " j ++ ) ptr [ j ] = ( s -> bytestream [ j ] * f + 64 ) >> 7 ;\n"
                ],
                [
                    85,
                    " j < n / 2 ;\n"
                ],
                [
                    91,
                    " s -> bytestream += n ;\n"
                ],
                [
                    92,
                    " ptr += linesize ;\n"
                ],
                [
                    99,
                    " ptr = p -> data [ 0 ] ;\n"
                ],
                [
                    102,
                    " if ( s -> bytestream + n * avctx -> height * 3 / 2 > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    104,
                    " i < avctx -> height ;\n"
                ],
                [
                    106,
                    " memcpy ( ptr , s -> bytestream , n ) ;\n"
                ],
                [
                    107,
                    " s -> bytestream += n ;\n"
                ],
                [
                    108,
                    " ptr += linesize ;\n"
                ],
                [
                    110,
                    " ptr1 = p -> data [ 1 ] ;\n"
                ],
                [
                    111,
                    " ptr2 = p -> data [ 2 ] ;\n"
                ],
                [
                    112,
                    " n >>= 1 ;\n"
                ],
                [
                    115,
                    " i < h ;\n"
                ],
                [
                    117,
                    " memcpy ( ptr1 , s -> bytestream , n ) ;\n"
                ],
                [
                    118,
                    " s -> bytestream += n ;\n"
                ],
                [
                    119,
                    " memcpy ( ptr2 , s -> bytestream , n ) ;\n"
                ],
                [
                    120,
                    " s -> bytestream += n ;\n"
                ],
                [
                    121,
                    " ptr1 += p -> linesize [ 1 ] ;\n"
                ],
                [
                    122,
                    " ptr2 += p -> linesize [ 2 ] ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int pnm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    10,
                    " s -> bytestream_start = s -> bytestream = buf ;\n"
                ],
                [
                    12,
                    " if ( ( ret = ff_pnm_decode_header ( avctx , s ) ) < 0 ) return ret ;\n"
                ],
                [
                    44,
                    " do_read : ptr = p -> data [ 0 ] ;\n"
                ],
                [
                    46,
                    " if ( s -> bytestream + n * avctx -> height > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    75,
                    " if ( ! upgrade ) memcpy ( ptr , s -> bytestream , n ) ;\n"
                ],
                [
                    79,
                    " j < n ;\n"
                ],
                [
                    80,
                    " j ++ ) ptr [ j ] = ( s -> bytestream [ j ] * f + 64 ) >> 7 ;\n"
                ],
                [
                    85,
                    " j < n / 2 ;\n"
                ],
                [
                    91,
                    " s -> bytestream += n ;\n"
                ],
                [
                    92,
                    " ptr += linesize ;\n"
                ],
                [
                    99,
                    " ptr = p -> data [ 0 ] ;\n"
                ],
                [
                    102,
                    " if ( s -> bytestream + n * avctx -> height * 3 / 2 > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    104,
                    " i < avctx -> height ;\n"
                ],
                [
                    106,
                    " memcpy ( ptr , s -> bytestream , n ) ;\n"
                ],
                [
                    107,
                    " s -> bytestream += n ;\n"
                ],
                [
                    108,
                    " ptr += linesize ;\n"
                ],
                [
                    110,
                    " ptr1 = p -> data [ 1 ] ;\n"
                ],
                [
                    111,
                    " ptr2 = p -> data [ 2 ] ;\n"
                ],
                [
                    112,
                    " n >>= 1 ;\n"
                ],
                [
                    115,
                    " i < h ;\n"
                ],
                [
                    117,
                    " memcpy ( ptr1 , s -> bytestream , n ) ;\n"
                ],
                [
                    118,
                    " s -> bytestream += n ;\n"
                ],
                [
                    119,
                    " memcpy ( ptr2 , s -> bytestream , n ) ;\n"
                ],
                [
                    120,
                    " s -> bytestream += n ;\n"
                ],
                [
                    121,
                    " ptr1 += p -> linesize [ 1 ] ;\n"
                ],
                [
                    122,
                    " ptr2 += p -> linesize [ 2 ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mpeg_decode_mb ( MpegEncContext * s , int16_t block [ 12 ] [ 64 ] ) {\n int i , j , k , cbp , val , mb_type , motion_type ;\n const int mb_block_count = 4 + ( 1 << s -> chroma_format ) ;\n av_dlog ( s -> avctx , \"decode_mb: x=%d y=%d\\n\" , s -> mb_x , s -> mb_y ) ;\n assert ( s -> mb_skipped == 0 ) ;\n if ( s -> mb_skip_run -- != 0 ) {\n if ( s -> pict_type == AV_PICTURE_TYPE_P ) {\n s -> mb_skipped = 1 ;\n s -> current_picture . f . mb_type [ s -> mb_x + s -> mb_y * s -> mb_stride ] = MB_TYPE_SKIP | MB_TYPE_L0 | MB_TYPE_16x16 ;\n }\n else {\n int mb_type ;\n if ( s -> mb_x ) mb_type = s -> current_picture . f . mb_type [ s -> mb_x + s -> mb_y * s -> mb_stride - 1 ] ;\n else mb_type = s -> current_picture . f . mb_type [ s -> mb_width + ( s -> mb_y - 1 ) * s -> mb_stride - 1 ] ;\n if ( IS_INTRA ( mb_type ) ) return - 1 ;\n s -> current_picture . f . mb_type [ s -> mb_x + s -> mb_y * s -> mb_stride ] = mb_type | MB_TYPE_SKIP ;\n if ( ( s -> mv [ 0 ] [ 0 ] [ 0 ] | s -> mv [ 0 ] [ 0 ] [ 1 ] | s -> mv [ 1 ] [ 0 ] [ 0 ] | s -> mv [ 1 ] [ 0 ] [ 1 ] ) == 0 ) s -> mb_skipped = 1 ;\n }\n return 0 ;\n }\n switch ( s -> pict_type ) {\n default : case AV_PICTURE_TYPE_I : if ( get_bits1 ( & s -> gb ) == 0 ) {\n if ( get_bits1 ( & s -> gb ) == 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid mb type in I Frame at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n mb_type = MB_TYPE_QUANT | MB_TYPE_INTRA ;\n }\n else {\n mb_type = MB_TYPE_INTRA ;\n }\n break ;\n case AV_PICTURE_TYPE_P : mb_type = get_vlc2 ( & s -> gb , mb_ptype_vlc . table , MB_PTYPE_VLC_BITS , 1 ) ;\n if ( mb_type < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid mb type in P Frame at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n mb_type = ptype2mb_type [ mb_type ] ;\n break ;\n case AV_PICTURE_TYPE_B : mb_type = get_vlc2 ( & s -> gb , mb_btype_vlc . table , MB_BTYPE_VLC_BITS , 1 ) ;\n if ( mb_type < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid mb type in B Frame at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n mb_type = btype2mb_type [ mb_type ] ;\n break ;\n }\n av_dlog ( s -> avctx , \"mb_type=%x\\n\" , mb_type ) ;\n if ( IS_INTRA ( mb_type ) ) {\n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ;\n if ( ! s -> chroma_y_shift ) {\n s -> dsp . clear_blocks ( s -> block [ 6 ] ) ;\n }\n if ( s -> picture_structure == PICT_FRAME && ! s -> frame_pred_frame_dct ) {\n s -> interlaced_dct = get_bits1 ( & s -> gb ) ;\n }\n if ( IS_QUANT ( mb_type ) ) s -> qscale = get_qscale ( s ) ;\n if ( s -> concealment_motion_vectors ) {\n if ( s -> picture_structure != PICT_FRAME ) skip_bits1 ( & s -> gb ) ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = s -> last_mv [ 0 ] [ 0 ] [ 0 ] = s -> last_mv [ 0 ] [ 1 ] [ 0 ] = mpeg_decode_motion ( s , s -> mpeg_f_code [ 0 ] [ 0 ] , s -> last_mv [ 0 ] [ 0 ] [ 0 ] ) ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = s -> last_mv [ 0 ] [ 0 ] [ 1 ] = s -> last_mv [ 0 ] [ 1 ] [ 1 ] = mpeg_decode_motion ( s , s -> mpeg_f_code [ 0 ] [ 1 ] , s -> last_mv [ 0 ] [ 0 ] [ 1 ] ) ;\n skip_bits1 ( & s -> gb ) ;\n }\n else memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;\n s -> mb_intra = 1 ;\n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration > 1 ) {\n ff_xvmc_pack_pblocks ( s , - 1 ) ;\n if ( s -> swap_uv ) {\n exchange_uv ( s ) ;\n }\n }\n if ( s -> codec_id == AV_CODEC_ID_MPEG2VIDEO ) {\n if ( s -> flags2 & CODEC_FLAG2_FAST ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n mpeg2_fast_decode_block_intra ( s , * s -> pblocks [ i ] , i ) ;\n }\n }\n else {\n for ( i = 0 ;\n i < mb_block_count ;\n i ++ ) {\n if ( mpeg2_decode_block_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n }\n }\n }\n else {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( mpeg1_decode_block_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n }\n }\n }\n else {\n if ( mb_type & MB_TYPE_ZERO_MV ) {\n assert ( mb_type & MB_TYPE_CBP ) ;\n s -> mv_dir = MV_DIR_FORWARD ;\n if ( s -> picture_structure == PICT_FRAME ) {\n if ( ! s -> frame_pred_frame_dct ) s -> interlaced_dct = get_bits1 ( & s -> gb ) ;\n s -> mv_type = MV_TYPE_16X16 ;\n }\n else {\n s -> mv_type = MV_TYPE_FIELD ;\n mb_type |= MB_TYPE_INTERLACED ;\n s -> field_select [ 0 ] [ 0 ] = s -> picture_structure - 1 ;\n }\n if ( IS_QUANT ( mb_type ) ) s -> qscale = get_qscale ( s ) ;\n s -> last_mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\n s -> last_mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n s -> last_mv [ 0 ] [ 1 ] [ 0 ] = 0 ;\n s -> last_mv [ 0 ] [ 1 ] [ 1 ] = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n }\n else {\n assert ( mb_type & MB_TYPE_L0L1 ) ;\n if ( s -> frame_pred_frame_dct ) motion_type = MT_FRAME ;\n else {\n motion_type = get_bits ( & s -> gb , 2 ) ;\n if ( s -> picture_structure == PICT_FRAME && HAS_CBP ( mb_type ) ) s -> interlaced_dct = get_bits1 ( & s -> gb ) ;\n }\n if ( IS_QUANT ( mb_type ) ) s -> qscale = get_qscale ( s ) ;\n s -> mv_dir = ( mb_type >> 13 ) & 3 ;\n av_dlog ( s -> avctx , \"motion_type=%d\\n\" , motion_type ) ;\n switch ( motion_type ) {\n case MT_FRAME : if ( s -> picture_structure == PICT_FRAME ) {\n mb_type |= MB_TYPE_16x16 ;\n s -> mv_type = MV_TYPE_16X16 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( USES_LIST ( mb_type , i ) ) {\n s -> mv [ i ] [ 0 ] [ 0 ] = s -> last_mv [ i ] [ 0 ] [ 0 ] = s -> last_mv [ i ] [ 1 ] [ 0 ] = mpeg_decode_motion ( s , s -> mpeg_f_code [ i ] [ 0 ] , s -> last_mv [ i ] [ 0 ] [ 0 ] ) ;\n s -> mv [ i ] [ 0 ] [ 1 ] = s -> last_mv [ i ] [ 0 ] [ 1 ] = s -> last_mv [ i ] [ 1 ] [ 1 ] = mpeg_decode_motion ( s , s -> mpeg_f_code [ i ] [ 1 ] , s -> last_mv [ i ] [ 0 ] [ 1 ] ) ;\n if ( s -> full_pel [ i ] ) {\n s -> mv [ i ] [ 0 ] [ 0 ] <<= 1 ;\n s -> mv [ i ] [ 0 ] [ 1 ] <<= 1 ;\n }\n }\n }\n }\n else {\n mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED ;\n s -> mv_type = MV_TYPE_16X8 ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( USES_LIST ( mb_type , i ) ) {\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n s -> field_select [ i ] [ j ] = get_bits1 ( & s -> gb ) ;\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n val = mpeg_decode_motion ( s , s -> mpeg_f_code [ i ] [ k ] , s -> last_mv [ i ] [ j ] [ k ] ) ;\n s -> last_mv [ i ] [ j ] [ k ] = val ;\n s -> mv [ i ] [ j ] [ k ] = val ;\n }\n }\n }\n }\n }\n break ;\n case MT_FIELD : s -> mv_type = MV_TYPE_FIELD ;\n if ( s -> picture_structure == PICT_FRAME ) {\n mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( USES_LIST ( mb_type , i ) ) {\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n s -> field_select [ i ] [ j ] = get_bits1 ( & s -> gb ) ;\n val = mpeg_decode_motion ( s , s -> mpeg_f_code [ i ] [ 0 ] , s -> last_mv [ i ] [ j ] [ 0 ] ) ;\n s -> last_mv [ i ] [ j ] [ 0 ] = val ;\n s -> mv [ i ] [ j ] [ 0 ] = val ;\n av_dlog ( s -> avctx , \"fmx=%d\\n\" , val ) ;\n val = mpeg_decode_motion ( s , s -> mpeg_f_code [ i ] [ 1 ] , s -> last_mv [ i ] [ j ] [ 1 ] >> 1 ) ;\n s -> last_mv [ i ] [ j ] [ 1 ] = val << 1 ;\n s -> mv [ i ] [ j ] [ 1 ] = val ;\n av_dlog ( s -> avctx , \"fmy=%d\\n\" , val ) ;\n }\n }\n }\n }\n else {\n mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( USES_LIST ( mb_type , i ) ) {\n s -> field_select [ i ] [ 0 ] = get_bits1 ( & s -> gb ) ;\n for ( k = 0 ;\n k < 2 ;\n k ++ ) {\n val = mpeg_decode_motion ( s , s -> mpeg_f_code [ i ] [ k ] , s -> last_mv [ i ] [ 0 ] [ k ] ) ;\n s -> last_mv [ i ] [ 0 ] [ k ] = val ;\n s -> last_mv [ i ] [ 1 ] [ k ] = val ;\n s -> mv [ i ] [ 0 ] [ k ] = val ;\n }\n }\n }\n }\n break ;\n case MT_DMV : s -> mv_type = MV_TYPE_DMV ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n if ( USES_LIST ( mb_type , i ) ) {\n int dmx , dmy , mx , my , m ;\n const int my_shift = s -> picture_structure == PICT_FRAME ;\n mx = mpeg_decode_motion ( s , s -> mpeg_f_code [ i ] [ 0 ] , s -> last_mv [ i ] [ 0 ] [ 0 ] ) ;\n s -> last_mv [ i ] [ 0 ] [ 0 ] = mx ;\n s -> last_mv [ i ] [ 1 ] [ 0 ] = mx ;\n dmx = get_dmv ( s ) ;\n my = mpeg_decode_motion ( s , s -> mpeg_f_code [ i ] [ 1 ] , s -> last_mv [ i ] [ 0 ] [ 1 ] >> my_shift ) ;\n dmy = get_dmv ( s ) ;\n s -> last_mv [ i ] [ 0 ] [ 1 ] = my << my_shift ;\n s -> last_mv [ i ] [ 1 ] [ 1 ] = my << my_shift ;\n s -> mv [ i ] [ 0 ] [ 0 ] = mx ;\n s -> mv [ i ] [ 0 ] [ 1 ] = my ;\n s -> mv [ i ] [ 1 ] [ 0 ] = mx ;\n s -> mv [ i ] [ 1 ] [ 1 ] = my ;\n if ( s -> picture_structure == PICT_FRAME ) {\n mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED ;\n m = s -> top_field_first ? 1 : 3 ;\n s -> mv [ i ] [ 2 ] [ 0 ] = ( ( mx * m + ( mx > 0 ) ) >> 1 ) + dmx ;\n s -> mv [ i ] [ 2 ] [ 1 ] = ( ( my * m + ( my > 0 ) ) >> 1 ) + dmy - 1 ;\n m = 4 - m ;\n s -> mv [ i ] [ 3 ] [ 0 ] = ( ( mx * m + ( mx > 0 ) ) >> 1 ) + dmx ;\n s -> mv [ i ] [ 3 ] [ 1 ] = ( ( my * m + ( my > 0 ) ) >> 1 ) + dmy + 1 ;\n }\n else {\n mb_type |= MB_TYPE_16x16 ;\n s -> mv [ i ] [ 2 ] [ 0 ] = ( ( mx + ( mx > 0 ) ) >> 1 ) + dmx ;\n s -> mv [ i ] [ 2 ] [ 1 ] = ( ( my + ( my > 0 ) ) >> 1 ) + dmy ;\n if ( s -> picture_structure == PICT_TOP_FIELD ) s -> mv [ i ] [ 2 ] [ 1 ] -- ;\n else s -> mv [ i ] [ 2 ] [ 1 ] ++ ;\n }\n }\n }\n break ;\n default : av_log ( s -> avctx , AV_LOG_ERROR , \"00 motion_type at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n }\n s -> mb_intra = 0 ;\n if ( HAS_CBP ( mb_type ) ) {\n s -> dsp . clear_blocks ( s -> block [ 0 ] ) ;\n cbp = get_vlc2 ( & s -> gb , mb_pat_vlc . table , MB_PAT_VLC_BITS , 1 ) ;\n if ( mb_block_count > 6 ) {\n cbp <<= mb_block_count - 6 ;\n cbp |= get_bits ( & s -> gb , mb_block_count - 6 ) ;\n s -> dsp . clear_blocks ( s -> block [ 6 ] ) ;\n }\n if ( cbp <= 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid cbp at %d %d\\n\" , s -> mb_x , s -> mb_y ) ;\n return - 1 ;\n }\n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration > 1 ) {\n ff_xvmc_pack_pblocks ( s , cbp ) ;\n if ( s -> swap_uv ) {\n exchange_uv ( s ) ;\n }\n }\n if ( s -> codec_id == AV_CODEC_ID_MPEG2VIDEO ) {\n if ( s -> flags2 & CODEC_FLAG2_FAST ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( cbp & 32 ) {\n mpeg2_fast_decode_block_non_intra ( s , * s -> pblocks [ i ] , i ) ;\n }\n else {\n s -> block_last_index [ i ] = - 1 ;\n }\n cbp += cbp ;\n }\n }\n else {\n cbp <<= 12 - mb_block_count ;\n for ( i = 0 ;\n i < mb_block_count ;\n i ++ ) {\n if ( cbp & ( 1 << 11 ) ) {\n if ( mpeg2_decode_block_non_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n }\n else {\n s -> block_last_index [ i ] = - 1 ;\n }\n cbp += cbp ;\n }\n }\n }\n else {\n if ( s -> flags2 & CODEC_FLAG2_FAST ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( cbp & 32 ) {\n mpeg1_fast_decode_block_inter ( s , * s -> pblocks [ i ] , i ) ;\n }\n else {\n s -> block_last_index [ i ] = - 1 ;\n }\n cbp += cbp ;\n }\n }\n else {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n if ( cbp & 32 ) {\n if ( mpeg1_decode_block_inter ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n }\n else {\n s -> block_last_index [ i ] = - 1 ;\n }\n cbp += cbp ;\n }\n }\n }\n }\n else {\n for ( i = 0 ;\n i < 12 ;\n i ++ ) s -> block_last_index [ i ] = - 1 ;\n }\n }\n s -> current_picture . f . mb_type [ s -> mb_x + s -> mb_y * s -> mb_stride ] = mb_type ;\n return 0 ;\n }",
        "hash": -6435087038712482873,
        "project": "debian",
        "size": 336,
        "slice": {
            "memset": [
                [
                    1,
                    "static int mpeg_decode_mb ( MpegEncContext * s , int16_t block [ 12 ] [ 64 ] ) {\n"
                ],
                [
                    57,
                    " if ( IS_QUANT ( mb_type ) ) s -> qscale = get_qscale ( s ) ;\n"
                ],
                [
                    58,
                    " if ( s -> concealment_motion_vectors ) {\n"
                ],
                [
                    64,
                    " else memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;\n"
                ],
                [
                    67,
                    " ff_xvmc_pack_pblocks ( s , - 1 ) ;\n"
                ],
                [
                    69,
                    " exchange_uv ( s ) ;\n"
                ],
                [
                    77,
                    " mpeg2_fast_decode_block_intra ( s , * s -> pblocks [ i ] , i ) ;\n"
                ],
                [
                    84,
                    " if ( mpeg2_decode_block_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n"
                ],
                [
                    92,
                    " if ( mpeg1_decode_block_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mpeg_decode_mb ( MpegEncContext * s , int16_t block [ 12 ] [ 64 ] ) {\n"
                ],
                [
                    57,
                    " if ( IS_QUANT ( mb_type ) ) s -> qscale = get_qscale ( s ) ;\n"
                ],
                [
                    58,
                    " if ( s -> concealment_motion_vectors ) {\n"
                ],
                [
                    64,
                    " else memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;\n"
                ],
                [
                    67,
                    " ff_xvmc_pack_pblocks ( s , - 1 ) ;\n"
                ],
                [
                    69,
                    " exchange_uv ( s ) ;\n"
                ],
                [
                    77,
                    " mpeg2_fast_decode_block_intra ( s , * s -> pblocks [ i ] , i ) ;\n"
                ],
                [
                    84,
                    " if ( mpeg2_decode_block_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n"
                ],
                [
                    92,
                    " if ( mpeg1_decode_block_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n PNGDecContext * const s = avctx -> priv_data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AVFrame * picture = data ;\n uint8_t * crow_buf_base = NULL ;\n AVFrame * p ;\n uint32_t tag , length ;\n int ret ;\n FFSWAP ( AVFrame * , s -> current_picture , s -> last_picture ) ;\n avctx -> coded_frame = s -> current_picture ;\n p = s -> current_picture ;\n if ( buf_size < 8 || memcmp ( buf , ff_pngsig , 8 ) != 0 && memcmp ( buf , ff_mngsig , 8 ) != 0 ) return - 1 ;\n bytestream2_init ( & s -> gb , buf + 8 , buf_size - 8 ) ;\n s -> y = s -> state = 0 ;\n s -> zstream . zalloc = ff_png_zalloc ;\n s -> zstream . zfree = ff_png_zfree ;\n s -> zstream . opaque = NULL ;\n ret = inflateInit ( & s -> zstream ) ;\n if ( ret != Z_OK ) return - 1 ;\n for ( ;\n ;\n ) {\n if ( bytestream2_get_bytes_left ( & s -> gb ) <= 0 ) goto fail ;\n length = bytestream2_get_be32 ( & s -> gb ) ;\n if ( length > 0x7fffffff ) goto fail ;\n tag = bytestream2_get_le32 ( & s -> gb ) ;\n av_dlog ( avctx , \"png: tag=%c%c%c%c length=%u\\n\" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >> 24 ) & 0xff ) , length ) ;\n switch ( tag ) {\n case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : if ( length != 13 ) goto fail ;\n s -> width = bytestream2_get_be32 ( & s -> gb ) ;\n s -> height = bytestream2_get_be32 ( & s -> gb ) ;\n if ( av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) {\n s -> width = s -> height = 0 ;\n goto fail ;\n }\n s -> bit_depth = bytestream2_get_byte ( & s -> gb ) ;\n s -> color_type = bytestream2_get_byte ( & s -> gb ) ;\n s -> compression_type = bytestream2_get_byte ( & s -> gb ) ;\n s -> filter_type = bytestream2_get_byte ( & s -> gb ) ;\n s -> interlace_type = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 4 ) ;\n s -> state |= PNG_IHDR ;\n av_dlog ( avctx , \"width=%d height=%d depth=%d color_type=%d \" \"compression_type=%d filter_type=%d interlace_type=%d\\n\" , s -> width , s -> height , s -> bit_depth , s -> color_type , s -> compression_type , s -> filter_type , s -> interlace_type ) ;\n break ;\n case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : if ( ! ( s -> state & PNG_IHDR ) ) goto fail ;\n if ( ! ( s -> state & PNG_IDAT ) ) {\n avctx -> width = s -> width ;\n avctx -> height = s -> height ;\n s -> channels = ff_png_get_nb_channels ( s -> color_type ) ;\n s -> bits_per_pixel = s -> bit_depth * s -> channels ;\n s -> bpp = ( s -> bits_per_pixel + 7 ) >> 3 ;\n s -> row_size = ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3 ;\n if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_RGB ) {\n avctx -> pix_fmt = AV_PIX_FMT_RGB24 ;\n }\n else if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA ) {\n avctx -> pix_fmt = AV_PIX_FMT_RGB32 ;\n }\n else if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_GRAY ) {\n avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ;\n }\n else if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY ) {\n avctx -> pix_fmt = AV_PIX_FMT_GRAY16BE ;\n }\n else if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB ) {\n avctx -> pix_fmt = AV_PIX_FMT_RGB48BE ;\n }\n else if ( s -> bit_depth == 1 && s -> color_type == PNG_COLOR_TYPE_GRAY ) {\n avctx -> pix_fmt = AV_PIX_FMT_MONOBLACK ;\n }\n else if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_PALETTE ) {\n avctx -> pix_fmt = AV_PIX_FMT_PAL8 ;\n }\n else if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA ) {\n avctx -> pix_fmt = AV_PIX_FMT_Y400A ;\n }\n else {\n goto fail ;\n }\n if ( p -> data [ 0 ] ) avctx -> release_buffer ( avctx , p ) ;\n p -> reference = 0 ;\n if ( ff_get_buffer ( avctx , p ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n goto fail ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n p -> interlaced_frame = ! ! s -> interlace_type ;\n if ( ! s -> interlace_type ) {\n s -> crow_size = s -> row_size + 1 ;\n }\n else {\n s -> pass = 0 ;\n s -> pass_row_size = ff_png_pass_row_size ( s -> pass , s -> bits_per_pixel , s -> width ) ;\n s -> crow_size = s -> pass_row_size + 1 ;\n }\n av_dlog ( avctx , \"row_size=%d crow_size =%d\\n\" , s -> row_size , s -> crow_size ) ;\n s -> image_buf = p -> data [ 0 ] ;\n s -> image_linesize = p -> linesize [ 0 ] ;\n if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) memcpy ( p -> data [ 1 ] , s -> palette , 256 * sizeof ( uint32_t ) ) ;\n s -> last_row = av_mallocz ( s -> row_size ) ;\n if ( ! s -> last_row ) goto fail ;\n if ( s -> interlace_type || s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA ) {\n s -> tmp_row = av_malloc ( s -> row_size ) ;\n if ( ! s -> tmp_row ) goto fail ;\n }\n crow_buf_base = av_malloc ( s -> row_size + 16 ) ;\n if ( ! crow_buf_base ) goto fail ;\n s -> crow_buf = crow_buf_base + 15 ;\n s -> zstream . avail_out = s -> crow_size ;\n s -> zstream . next_out = s -> crow_buf ;\n }\n s -> state |= PNG_IDAT ;\n if ( png_decode_idat ( s , length ) < 0 ) goto fail ;\n bytestream2_skip ( & s -> gb , 4 ) ;\n break ;\n case MKTAG ( 'P' , 'L' , 'T' , 'E' ) : {\n int n , i , r , g , b ;\n if ( ( length % 3 ) != 0 || length > 256 * 3 ) goto skip_tag ;\n n = length / 3 ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n r = bytestream2_get_byte ( & s -> gb ) ;\n g = bytestream2_get_byte ( & s -> gb ) ;\n b = bytestream2_get_byte ( & s -> gb ) ;\n s -> palette [ i ] = ( 0xff << 24 ) | ( r << 16 ) | ( g << 8 ) | b ;\n }\n for ( ;\n i < 256 ;\n i ++ ) {\n s -> palette [ i ] = ( 0xff << 24 ) ;\n }\n s -> state |= PNG_PLTE ;\n bytestream2_skip ( & s -> gb , 4 ) ;\n }\n break ;\n case MKTAG ( 't' , 'R' , 'N' , 'S' ) : {\n int v , i ;\n if ( s -> color_type != PNG_COLOR_TYPE_PALETTE || length > 256 || ! ( s -> state & PNG_PLTE ) ) goto skip_tag ;\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n v = bytestream2_get_byte ( & s -> gb ) ;\n s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ;\n }\n bytestream2_skip ( & s -> gb , 4 ) ;\n }\n break ;\n case MKTAG ( 'I' , 'E' , 'N' , 'D' ) : if ( ! ( s -> state & PNG_ALLIMAGE ) ) goto fail ;\n bytestream2_skip ( & s -> gb , 4 ) ;\n goto exit_loop ;\n default : skip_tag : bytestream2_skip ( & s -> gb , length + 4 ) ;\n break ;\n }\n }\n exit_loop : if ( s -> last_picture -> data [ 0 ] != NULL ) {\n if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) ) {\n int i , j ;\n uint8_t * pd = s -> current_picture -> data [ 0 ] ;\n uint8_t * pd_last = s -> last_picture -> data [ 0 ] ;\n for ( j = 0 ;\n j < s -> height ;\n j ++ ) {\n for ( i = 0 ;\n i < s -> width * s -> bpp ;\n i ++ ) {\n pd [ i ] += pd_last [ i ] ;\n }\n pd += s -> image_linesize ;\n pd_last += s -> image_linesize ;\n }\n }\n }\n * picture = * s -> current_picture ;\n * got_frame = 1 ;\n ret = bytestream2_tell ( & s -> gb ) ;\n the_end : inflateEnd ( & s -> zstream ) ;\n av_free ( crow_buf_base ) ;\n s -> crow_buf = NULL ;\n av_freep ( & s -> last_row ) ;\n av_freep ( & s -> tmp_row ) ;\n return ret ;\n fail : ret = - 1 ;\n goto the_end ;\n }",
        "hash": -4433254577494420260,
        "project": "debian",
        "size": 187,
        "slice": {
            "memcpy": [
                [
                    2,
                    " PNGDecContext * const s = avctx -> priv_data ;\n"
                ],
                [
                    101,
                    " if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) memcpy ( p -> data [ 1 ] , s -> palette , 256 * sizeof ( uint32_t ) ) ;\n"
                ],
                [
                    115,
                    " if ( png_decode_idat ( s , length ) < 0 ) goto fail ;\n"
                ],
                [
                    128,
                    " s -> palette [ i ] = ( 0xff << 24 ) | ( r << 16 ) | ( g << 8 ) | b ;\n"
                ],
                [
                    133,
                    " s -> palette [ i ] = ( 0xff << 24 ) ;\n"
                ],
                [
                    146,
                    " s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    13,
                    " if ( buf_size < 8 || memcmp ( buf , ff_pngsig , 8 ) != 0 && memcmp ( buf , ff_mngsig , 8 ) != 0 ) return - 1 ;\n"
                ],
                [
                    14,
                    " bytestream2_init ( & s -> gb , buf + 8 , buf_size - 8 ) ;\n"
                ],
                [
                    15,
                    " s -> y = s -> state = 0 ;\n"
                ],
                [
                    16,
                    " s -> zstream . zalloc = ff_png_zalloc ;\n"
                ],
                [
                    17,
                    " s -> zstream . zfree = ff_png_zfree ;\n"
                ],
                [
                    18,
                    " s -> zstream . opaque = NULL ;\n"
                ],
                [
                    19,
                    " ret = inflateInit ( & s -> zstream ) ;\n"
                ],
                [
                    20,
                    " if ( ret != Z_OK ) return - 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " PNGDecContext * const s = avctx -> priv_data ;\n"
                ],
                [
                    3,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    13,
                    " if ( buf_size < 8 || memcmp ( buf , ff_pngsig , 8 ) != 0 && memcmp ( buf , ff_mngsig , 8 ) != 0 ) return - 1 ;\n"
                ],
                [
                    14,
                    " bytestream2_init ( & s -> gb , buf + 8 , buf_size - 8 ) ;\n"
                ],
                [
                    15,
                    " s -> y = s -> state = 0 ;\n"
                ],
                [
                    16,
                    " s -> zstream . zalloc = ff_png_zalloc ;\n"
                ],
                [
                    17,
                    " s -> zstream . zfree = ff_png_zfree ;\n"
                ],
                [
                    18,
                    " s -> zstream . opaque = NULL ;\n"
                ],
                [
                    19,
                    " ret = inflateInit ( & s -> zstream ) ;\n"
                ],
                [
                    20,
                    " if ( ret != Z_OK ) return - 1 ;\n"
                ],
                [
                    101,
                    " if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) memcpy ( p -> data [ 1 ] , s -> palette , 256 * sizeof ( uint32_t ) ) ;\n"
                ],
                [
                    115,
                    " if ( png_decode_idat ( s , length ) < 0 ) goto fail ;\n"
                ],
                [
                    128,
                    " s -> palette [ i ] = ( 0xff << 24 ) | ( r << 16 ) | ( g << 8 ) | b ;\n"
                ],
                [
                    133,
                    " s -> palette [ i ] = ( 0xff << 24 ) ;\n"
                ],
                [
                    146,
                    " s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mss1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MSS1Context * ctx = avctx -> priv_data ;\n MSS12Context * c = & ctx -> ctx ;\n GetBitContext gb ;\n ArithCoder acoder ;\n int pal_changed = 0 ;\n int ret ;\n init_get_bits ( & gb , buf , buf_size * 8 ) ;\n arith_init ( & acoder , & gb ) ;\n ctx -> pic . reference = 3 ;\n ctx -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_READABLE | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n c -> pal_pic = ctx -> pic . data [ 0 ] + ctx -> pic . linesize [ 0 ] * ( avctx -> height - 1 ) ;\n c -> pal_stride = - ctx -> pic . linesize [ 0 ] ;\n c -> keyframe = ! arith_get_bit ( & acoder ) ;\n if ( c -> keyframe ) {\n c -> corrupted = 0 ;\n ff_mss12_slicecontext_reset ( & ctx -> sc ) ;\n pal_changed = decode_pal ( c , & acoder ) ;\n ctx -> pic . key_frame = 1 ;\n ctx -> pic . pict_type = AV_PICTURE_TYPE_I ;\n }\n else {\n if ( c -> corrupted ) return AVERROR_INVALIDDATA ;\n ctx -> pic . key_frame = 0 ;\n ctx -> pic . pict_type = AV_PICTURE_TYPE_P ;\n }\n c -> corrupted = ff_mss12_decode_rect ( & ctx -> sc , & acoder , 0 , 0 , avctx -> width , avctx -> height ) ;\n if ( c -> corrupted ) return AVERROR_INVALIDDATA ;\n memcpy ( ctx -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n ctx -> pic . palette_has_changed = pal_changed ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = ctx -> pic ;\n return buf_size ;\n }",
        "hash": 4724375811251028572,
        "project": "debian",
        "size": 40,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int mss1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " MSS12Context * c = & ctx -> ctx ;\n"
                ],
                [
                    24,
                    " pal_changed = decode_pal ( c , & acoder ) ;\n"
                ],
                [
                    34,
                    " if ( c -> corrupted ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    35,
                    " memcpy ( ctx -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mss1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " MSS12Context * c = & ctx -> ctx ;\n"
                ],
                [
                    24,
                    " pal_changed = decode_pal ( c , & acoder ) ;\n"
                ],
                [
                    34,
                    " if ( c -> corrupted ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    35,
                    " memcpy ( ctx -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int flic_decode_frame_15_16BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n FlicDecodeContext * s = avctx -> priv_data ;\n GetByteContext g2 ;\n int pixel_ptr ;\n unsigned char palette_idx1 ;\n unsigned int frame_size ;\n int num_chunks ;\n unsigned int chunk_size ;\n int chunk_type ;\n int i , j , ret ;\n int lines ;\n int compressed_lines ;\n signed short line_packets ;\n int y_ptr ;\n int byte_run ;\n int pixel_skip ;\n int pixel_countdown ;\n unsigned char * pixels ;\n int pixel ;\n unsigned int pixel_limit ;\n bytestream2_init ( & g2 , buf , buf_size ) ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n pixels = s -> frame . data [ 0 ] ;\n pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;\n frame_size = bytestream2_get_le32 ( & g2 ) ;\n bytestream2_skip ( & g2 , 2 ) ;\n num_chunks = bytestream2_get_le16 ( & g2 ) ;\n bytestream2_skip ( & g2 , 8 ) ;\n frame_size -= 16 ;\n while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n chunk_size = bytestream2_get_le32 ( & g2 ) ;\n chunk_type = bytestream2_get_le16 ( & g2 ) ;\n switch ( chunk_type ) {\n case FLI_256_COLOR : case FLI_COLOR : av_dlog ( avctx , \"Unexpected Palette chunk %d in non-palettized FLC\\n\" , chunk_type ) ;\n bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n break ;\n case FLI_DELTA : case FLI_DTA_LC : y_ptr = 0 ;\n compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n while ( compressed_lines > 0 ) {\n line_packets = bytestream2_get_le16 ( & g2 ) ;\n if ( line_packets < 0 ) {\n line_packets = - line_packets ;\n y_ptr += line_packets * s -> frame . linesize [ 0 ] ;\n }\n else {\n compressed_lines -- ;\n pixel_ptr = y_ptr ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixel_countdown = s -> avctx -> width ;\n for ( i = 0 ;\n i < line_packets ;\n i ++ ) {\n pixel_skip = bytestream2_get_byte ( & g2 ) ;\n pixel_ptr += ( pixel_skip * 2 ) ;\n pixel_countdown -= pixel_skip ;\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run < 0 ) {\n byte_run = - byte_run ;\n pixel = bytestream2_get_le16 ( & g2 ) ;\n CHECK_PIXEL_PTR ( 2 * byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -= 2 ) {\n * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel ;\n pixel_ptr += 2 ;\n }\n }\n else {\n CHECK_PIXEL_PTR ( 2 * byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -- ) {\n * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = bytestream2_get_le16 ( & g2 ) ;\n pixel_ptr += 2 ;\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n }\n }\n break ;\n case FLI_LC : av_log ( avctx , AV_LOG_ERROR , \"Unexpected FLI_LC chunk in non-paletised FLC\\n\" ) ;\n bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n break ;\n case FLI_BLACK : memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n break ;\n case FLI_BRUN : y_ptr = 0 ;\n for ( lines = 0 ;\n lines < s -> avctx -> height ;\n lines ++ ) {\n pixel_ptr = y_ptr ;\n bytestream2_skip ( & g2 , 1 ) ;\n pixel_countdown = ( s -> avctx -> width * 2 ) ;\n while ( pixel_countdown > 0 ) {\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run > 0 ) {\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d) (linea%d)\\n\" , pixel_countdown , lines ) ;\n }\n }\n else {\n byte_run = - byte_run ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d) at line %d\\n\" , pixel_countdown , lines ) ;\n }\n }\n }\n # if HAVE_BIGENDIAN pixel_ptr = y_ptr ;\n pixel_countdown = s -> avctx -> width ;\n while ( pixel_countdown > 0 ) {\n * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = AV_RL16 ( & buf [ pixel_ptr ] ) ;\n pixel_ptr += 2 ;\n }\n # endif y_ptr += s -> frame . linesize [ 0 ] ;\n }\n break ;\n case FLI_DTA_BRUN : y_ptr = 0 ;\n for ( lines = 0 ;\n lines < s -> avctx -> height ;\n lines ++ ) {\n pixel_ptr = y_ptr ;\n bytestream2_skip ( & g2 , 1 ) ;\n pixel_countdown = s -> avctx -> width ;\n while ( pixel_countdown > 0 ) {\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run > 0 ) {\n pixel = bytestream2_get_le16 ( & g2 ) ;\n CHECK_PIXEL_PTR ( 2 * byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = pixel ;\n pixel_ptr += 2 ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d)\\n\" , pixel_countdown ) ;\n }\n }\n else {\n byte_run = - byte_run ;\n CHECK_PIXEL_PTR ( 2 * byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n * ( ( signed short * ) ( & pixels [ pixel_ptr ] ) ) = bytestream2_get_le16 ( & g2 ) ;\n pixel_ptr += 2 ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d)\\n\" , pixel_countdown ) ;\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n }\n break ;\n case FLI_COPY : case FLI_DTA_COPY : if ( chunk_size - 6 > ( unsigned int ) ( s -> avctx -> width * s -> avctx -> height ) * 2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"In chunk FLI_COPY : source data (%d bytes) \" \\ \"bigger than image, skipping chunk\\n\" , chunk_size - 6 ) ;\n bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n }\n else {\n for ( y_ptr = 0 ;\n y_ptr < s -> frame . linesize [ 0 ] * s -> avctx -> height ;\n y_ptr += s -> frame . linesize [ 0 ] ) {\n pixel_countdown = s -> avctx -> width ;\n pixel_ptr = 0 ;\n while ( pixel_countdown > 0 ) {\n * ( ( signed short * ) ( & pixels [ y_ptr + pixel_ptr ] ) ) = bytestream2_get_le16 ( & g2 ) ;\n pixel_ptr += 2 ;\n pixel_countdown -- ;\n }\n }\n }\n break ;\n case FLI_MINI : bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unrecognized chunk type: %d\\n\" , chunk_type ) ;\n break ;\n }\n frame_size -= chunk_size ;\n num_chunks -- ;\n }\n if ( ( bytestream2_get_bytes_left ( & g2 ) != 0 ) && ( bytestream2_get_bytes_left ( & g2 ) != 1 ) ) av_log ( avctx , AV_LOG_ERROR , \"Processed FLI chunk where chunk size = %d \" \\ \"and final chunk ptr = %d\\n\" , buf_size , bytestream2_tell ( & g2 ) ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": 6030508190585699741,
        "project": "debian",
        "size": 201,
        "slice": {
            "memset": [
                [
                    1,
                    "static int flic_decode_frame_15_16BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    28,
                    " pixels = s -> frame . data [ 0 ] ;\n"
                ],
                [
                    38,
                    " switch ( chunk_type ) {\n"
                ],
                [
                    90,
                    " case FLI_BLACK : memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n"
                ],
                [
                    107,
                    " pixels [ pixel_ptr ++ ] = palette_idx1 ;\n"
                ],
                [
                    119,
                    " pixels [ pixel_ptr ++ ] = palette_idx1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int flic_decode_frame_15_16BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    28,
                    " pixels = s -> frame . data [ 0 ] ;\n"
                ],
                [
                    38,
                    " switch ( chunk_type ) {\n"
                ],
                [
                    90,
                    " case FLI_BLACK : memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n"
                ],
                [
                    107,
                    " pixels [ pixel_ptr ++ ] = palette_idx1 ;\n"
                ],
                [
                    119,
                    " pixels [ pixel_ptr ++ ] = palette_idx1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n FlicDecodeContext * s = avctx -> priv_data ;\n GetByteContext g2 ;\n int stream_ptr_after_color_chunk ;\n int pixel_ptr ;\n int palette_ptr ;\n unsigned char palette_idx1 ;\n unsigned char palette_idx2 ;\n unsigned int frame_size ;\n int num_chunks ;\n unsigned int chunk_size ;\n int chunk_type ;\n int i , j , ret ;\n int color_packets ;\n int color_changes ;\n int color_shift ;\n unsigned char r , g , b ;\n int lines ;\n int compressed_lines ;\n int starting_line ;\n signed short line_packets ;\n int y_ptr ;\n int byte_run ;\n int pixel_skip ;\n int pixel_countdown ;\n unsigned char * pixels ;\n unsigned int pixel_limit ;\n bytestream2_init ( & g2 , buf , buf_size ) ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n pixels = s -> frame . data [ 0 ] ;\n pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;\n frame_size = bytestream2_get_le32 ( & g2 ) ;\n bytestream2_skip ( & g2 , 2 ) ;\n num_chunks = bytestream2_get_le16 ( & g2 ) ;\n bytestream2_skip ( & g2 , 8 ) ;\n frame_size -= 16 ;\n while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n chunk_size = bytestream2_get_le32 ( & g2 ) ;\n chunk_type = bytestream2_get_le16 ( & g2 ) ;\n switch ( chunk_type ) {\n case FLI_256_COLOR : case FLI_COLOR : stream_ptr_after_color_chunk = bytestream2_tell ( & g2 ) + chunk_size - 6 ;\n if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) ) color_shift = 0 ;\n else color_shift = 2 ;\n color_packets = bytestream2_get_le16 ( & g2 ) ;\n palette_ptr = 0 ;\n for ( i = 0 ;\n i < color_packets ;\n i ++ ) {\n palette_ptr += bytestream2_get_byte ( & g2 ) ;\n color_changes = bytestream2_get_byte ( & g2 ) ;\n if ( color_changes == 0 ) color_changes = 256 ;\n for ( j = 0 ;\n j < color_changes ;\n j ++ ) {\n unsigned int entry ;\n if ( ( unsigned ) palette_ptr >= 256 ) palette_ptr = 0 ;\n r = bytestream2_get_byte ( & g2 ) << color_shift ;\n g = bytestream2_get_byte ( & g2 ) << color_shift ;\n b = bytestream2_get_byte ( & g2 ) << color_shift ;\n entry = ( r << 16 ) | ( g << 8 ) | b ;\n if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ;\n s -> palette [ palette_ptr ++ ] = entry ;\n }\n }\n if ( stream_ptr_after_color_chunk - bytestream2_tell ( & g2 ) > 0 ) bytestream2_skip ( & g2 , stream_ptr_after_color_chunk - bytestream2_tell ( & g2 ) ) ;\n break ;\n case FLI_DELTA : y_ptr = 0 ;\n compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n while ( compressed_lines > 0 ) {\n line_packets = bytestream2_get_le16 ( & g2 ) ;\n if ( ( line_packets & 0xC000 ) == 0xC000 ) {\n line_packets = - line_packets ;\n y_ptr += line_packets * s -> frame . linesize [ 0 ] ;\n }\n else if ( ( line_packets & 0xC000 ) == 0x4000 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Undefined opcode (%x) in DELTA_FLI\\n\" , line_packets ) ;\n }\n else if ( ( line_packets & 0xC000 ) == 0x8000 ) {\n pixel_ptr = y_ptr + s -> frame . linesize [ 0 ] - 1 ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixels [ pixel_ptr ] = line_packets & 0xff ;\n }\n else {\n compressed_lines -- ;\n pixel_ptr = y_ptr ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixel_countdown = s -> avctx -> width ;\n for ( i = 0 ;\n i < line_packets ;\n i ++ ) {\n pixel_skip = bytestream2_get_byte ( & g2 ) ;\n pixel_ptr += pixel_skip ;\n pixel_countdown -= pixel_skip ;\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run < 0 ) {\n byte_run = - byte_run ;\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n palette_idx2 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run * 2 ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -= 2 ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n pixels [ pixel_ptr ++ ] = palette_idx2 ;\n }\n }\n else {\n CHECK_PIXEL_PTR ( byte_run * 2 ) ;\n for ( j = 0 ;\n j < byte_run * 2 ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n }\n }\n break ;\n case FLI_LC : starting_line = bytestream2_get_le16 ( & g2 ) ;\n y_ptr = 0 ;\n y_ptr += starting_line * s -> frame . linesize [ 0 ] ;\n compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n while ( compressed_lines > 0 ) {\n pixel_ptr = y_ptr ;\n CHECK_PIXEL_PTR ( 0 ) ;\n pixel_countdown = s -> avctx -> width ;\n line_packets = bytestream2_get_byte ( & g2 ) ;\n if ( line_packets > 0 ) {\n for ( i = 0 ;\n i < line_packets ;\n i ++ ) {\n pixel_skip = bytestream2_get_byte ( & g2 ) ;\n pixel_ptr += pixel_skip ;\n pixel_countdown -= pixel_skip ;\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( byte_run > 0 ) {\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n }\n }\n else if ( byte_run < 0 ) {\n byte_run = - byte_run ;\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ , pixel_countdown -- ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n }\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n compressed_lines -- ;\n }\n break ;\n case FLI_BLACK : memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n break ;\n case FLI_BRUN : y_ptr = 0 ;\n for ( lines = 0 ;\n lines < s -> avctx -> height ;\n lines ++ ) {\n pixel_ptr = y_ptr ;\n bytestream2_skip ( & g2 , 1 ) ;\n pixel_countdown = s -> avctx -> width ;\n while ( pixel_countdown > 0 ) {\n byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n if ( ! byte_run ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid byte run value.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( byte_run > 0 ) {\n palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n pixels [ pixel_ptr ++ ] = palette_idx1 ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d) at line %d\\n\" , pixel_countdown , lines ) ;\n }\n }\n else {\n byte_run = - byte_run ;\n CHECK_PIXEL_PTR ( byte_run ) ;\n for ( j = 0 ;\n j < byte_run ;\n j ++ ) {\n pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n pixel_countdown -- ;\n if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , \"pixel_countdown < 0 (%d) at line %d\\n\" , pixel_countdown , lines ) ;\n }\n }\n }\n y_ptr += s -> frame . linesize [ 0 ] ;\n }\n break ;\n case FLI_COPY : if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height ) {\n av_log ( avctx , AV_LOG_ERROR , \"In chunk FLI_COPY : source data (%d bytes) \" \\ \"bigger than image, skipping chunk\\n\" , chunk_size - 6 ) ;\n bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n }\n else {\n for ( y_ptr = 0 ;\n y_ptr < s -> frame . linesize [ 0 ] * s -> avctx -> height ;\n y_ptr += s -> frame . linesize [ 0 ] ) {\n bytestream2_get_buffer ( & g2 , & pixels [ y_ptr ] , s -> avctx -> width ) ;\n }\n }\n break ;\n case FLI_MINI : bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unrecognized chunk type: %d\\n\" , chunk_type ) ;\n break ;\n }\n frame_size -= chunk_size ;\n num_chunks -- ;\n }\n if ( ( bytestream2_get_bytes_left ( & g2 ) != 0 ) && ( bytestream2_get_bytes_left ( & g2 ) != 1 ) ) av_log ( avctx , AV_LOG_ERROR , \"Processed FLI chunk where chunk size = %d \" \\ \"and final chunk ptr = %d\\n\" , buf_size , buf_size - bytestream2_get_bytes_left ( & g2 ) ) ;\n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n if ( s -> new_palette ) {\n s -> frame . palette_has_changed = 1 ;\n s -> new_palette = 0 ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": 6030508190585699741,
        "project": "debian",
        "size": 236,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    2,
                    " FlicDecodeContext * s = avctx -> priv_data ;\n"
                ],
                [
                    42,
                    " while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n"
                ],
                [
                    66,
                    " if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ;\n"
                ],
                [
                    67,
                    " s -> palette [ palette_ptr ++ ] = entry ;\n"
                ],
                [
                    228,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    35,
                    " pixels = s -> frame . data [ 0 ] ;\n"
                ],
                [
                    45,
                    " switch ( chunk_type ) {\n"
                ],
                [
                    86,
                    " pixels [ pixel_ptr ] = line_packets & 0xff ;\n"
                ],
                [
                    109,
                    " pixels [ pixel_ptr ++ ] = palette_idx2 ;\n"
                ],
                [
                    117,
                    " pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n"
                ],
                [
                    147,
                    " pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n"
                ],
                [
                    157,
                    " pixels [ pixel_ptr ++ ] = palette_idx1 ;\n"
                ],
                [
                    166,
                    " case FLI_BLACK : memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n"
                ],
                [
                    187,
                    " pixels [ pixel_ptr ++ ] = palette_idx1 ;\n"
                ],
                [
                    198,
                    " pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n"
                ],
                [
                    215,
                    " bytestream2_get_buffer ( & g2 , & pixels [ y_ptr ] , s -> avctx -> width ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    2,
                    " FlicDecodeContext * s = avctx -> priv_data ;\n"
                ],
                [
                    35,
                    " pixels = s -> frame . data [ 0 ] ;\n"
                ],
                [
                    42,
                    " while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n"
                ],
                [
                    45,
                    " switch ( chunk_type ) {\n"
                ],
                [
                    66,
                    " if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ;\n"
                ],
                [
                    67,
                    " s -> palette [ palette_ptr ++ ] = entry ;\n"
                ],
                [
                    86,
                    " pixels [ pixel_ptr ] = line_packets & 0xff ;\n"
                ],
                [
                    109,
                    " pixels [ pixel_ptr ++ ] = palette_idx2 ;\n"
                ],
                [
                    117,
                    " pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n"
                ],
                [
                    147,
                    " pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n"
                ],
                [
                    157,
                    " pixels [ pixel_ptr ++ ] = palette_idx1 ;\n"
                ],
                [
                    166,
                    " case FLI_BLACK : memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n"
                ],
                [
                    187,
                    " pixels [ pixel_ptr ++ ] = palette_idx1 ;\n"
                ],
                [
                    198,
                    " pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n"
                ],
                [
                    215,
                    " bytestream2_get_buffer ( & g2 , & pixels [ y_ptr ] , s -> avctx -> width ) ;\n"
                ],
                [
                    228,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int yop_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n YopDecContext * s = avctx -> priv_data ;\n int tag , firstcolor , is_odd_frame ;\n int ret , i , x , y ;\n uint32_t * palette ;\n if ( avpkt -> size < 4 + 3 * s -> num_pal_colors ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet too small.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( s -> frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> frame ) ;\n ret = ff_get_buffer ( avctx , & s -> frame ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( ! avctx -> frame_number ) memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n s -> dstbuf = s -> frame . data [ 0 ] ;\n s -> dstptr = s -> frame . data [ 0 ] ;\n s -> srcptr = avpkt -> data + 4 ;\n s -> src_end = avpkt -> data + avpkt -> size ;\n s -> low_nibble = NULL ;\n is_odd_frame = avpkt -> data [ 0 ] ;\n firstcolor = s -> first_color [ is_odd_frame ] ;\n palette = ( uint32_t * ) s -> frame . data [ 1 ] ;\n for ( i = 0 ;\n i < s -> num_pal_colors ;\n i ++ , s -> srcptr += 3 ) palette [ i + firstcolor ] = ( s -> srcptr [ 0 ] << 18 ) | ( s -> srcptr [ 1 ] << 10 ) | ( s -> srcptr [ 2 ] << 2 ) ;\n s -> frame . palette_has_changed = 1 ;\n for ( y = 0 ;\n y < avctx -> height ;\n y += 2 ) {\n for ( x = 0 ;\n x < avctx -> width ;\n x += 2 ) {\n if ( s -> srcptr - avpkt -> data >= avpkt -> size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet too small.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n tag = yop_get_next_nibble ( s ) ;\n if ( tag != 0xf ) {\n ret = yop_paint_block ( s , tag ) ;\n if ( ret < 0 ) return ret ;\n }\n else {\n tag = yop_get_next_nibble ( s ) ;\n ret = yop_copy_previous_block ( s , tag ) ;\n if ( ret < 0 ) {\n avctx -> release_buffer ( avctx , & s -> frame ) ;\n return ret ;\n }\n }\n s -> dstptr += 2 ;\n }\n s -> dstptr += 2 * s -> frame . linesize [ 0 ] - x ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return avpkt -> size ;\n }",
        "hash": 4620577553943347649,
        "project": "debian",
        "size": 59,
        "slice": {
            "memset": [
                [
                    1,
                    "static int yop_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    16,
                    " if ( ! avctx -> frame_number ) memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    24,
                    " palette = ( uint32_t * ) s -> frame . data [ 1 ] ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int yop_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    16,
                    " if ( ! avctx -> frame_number ) memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    24,
                    " palette = ( uint32_t * ) s -> frame . data [ 1 ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int sunrast_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = avpkt -> data + avpkt -> size ;\n SUNRASTContext * const s = avctx -> priv_data ;\n AVFrame * picture = data ;\n AVFrame * const p = & s -> picture ;\n unsigned int w , h , depth , type , maptype , maplength , stride , x , y , len , alen ;\n uint8_t * ptr ;\n const uint8_t * bufstart = buf ;\n int ret ;\n if ( avpkt -> size < 32 ) return AVERROR_INVALIDDATA ;\n if ( AV_RB32 ( buf ) != RAS_MAGIC ) {\n av_log ( avctx , AV_LOG_ERROR , \"this is not sunras encoded data\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n w = AV_RB32 ( buf + 4 ) ;\n h = AV_RB32 ( buf + 8 ) ;\n depth = AV_RB32 ( buf + 12 ) ;\n type = AV_RB32 ( buf + 20 ) ;\n maptype = AV_RB32 ( buf + 24 ) ;\n maplength = AV_RB32 ( buf + 28 ) ;\n buf += 32 ;\n if ( type == RT_FORMAT_TIFF || type == RT_FORMAT_IFF || type == RT_EXPERIMENTAL ) {\n av_log_ask_for_sample ( avctx , \"unsupported (compression) type\\n\" ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( type > RT_FORMAT_IFF ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid (compression) type\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( av_image_check_size ( w , h , 0 , avctx ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid image size\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( maptype == RMT_RAW ) {\n av_log_ask_for_sample ( avctx , \"unsupported colormap type\\n\" ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( maptype > RMT_RAW ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid colormap type\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( depth ) {\n case 1 : avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ;\n break ;\n case 8 : avctx -> pix_fmt = maplength ? AV_PIX_FMT_PAL8 : AV_PIX_FMT_GRAY8 ;\n break ;\n case 24 : avctx -> pix_fmt = ( type == RT_FORMAT_RGB ) ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"invalid depth\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( p -> data [ 0 ] ) avctx -> release_buffer ( avctx , p ) ;\n if ( w != avctx -> width || h != avctx -> height ) avcodec_set_dimensions ( avctx , w , h ) ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n if ( buf_end - buf < maplength ) return AVERROR_INVALIDDATA ;\n if ( depth != 8 && maplength ) {\n av_log ( avctx , AV_LOG_WARNING , \"useless colormap found or file is corrupted, trying to recover\\n\" ) ;\n }\n else if ( maplength ) {\n unsigned int len = maplength / 3 ;\n if ( maplength % 3 || maplength > 768 ) {\n av_log ( avctx , AV_LOG_WARNING , \"invalid colormap length\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n ptr = p -> data [ 1 ] ;\n for ( x = 0 ;\n x < len ;\n x ++ , ptr += 4 ) * ( uint32_t * ) ptr = ( buf [ x ] << 16 ) + ( buf [ len + x ] << 8 ) + buf [ len + len + x ] ;\n }\n buf += maplength ;\n ptr = p -> data [ 0 ] ;\n stride = p -> linesize [ 0 ] ;\n len = ( depth * w + 7 ) >> 3 ;\n alen = len + ( len & 1 ) ;\n if ( type == RT_BYTE_ENCODED ) {\n int value , run ;\n uint8_t * end = ptr + h * stride ;\n x = 0 ;\n while ( ptr != end && buf < buf_end ) {\n run = 1 ;\n if ( buf_end - buf < 1 ) return AVERROR_INVALIDDATA ;\n if ( ( value = * buf ++ ) == RLE_TRIGGER ) {\n run = * buf ++ + 1 ;\n if ( run != 1 ) value = * buf ++ ;\n }\n while ( run -- ) {\n if ( x < len ) ptr [ x ] = value ;\n if ( ++ x >= alen ) {\n x = 0 ;\n ptr += stride ;\n if ( ptr == end ) break ;\n }\n }\n }\n }\n else {\n for ( y = 0 ;\n y < h ;\n y ++ ) {\n if ( buf_end - buf < len ) break ;\n memcpy ( ptr , buf , len ) ;\n ptr += stride ;\n buf += alen ;\n }\n }\n * picture = s -> picture ;\n * got_frame = 1 ;\n return buf - bufstart ;\n }",
        "hash": -7486651628261820829,
        "project": "debian",
        "size": 114,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int sunrast_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    60,
                    " if ( buf_end - buf < maplength ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    73,
                    " x ++ , ptr += 4 ) * ( uint32_t * ) ptr = ( buf [ x ] << 16 ) + ( buf [ len + x ] << 8 ) + buf [ len + len + x ] ;\n"
                ],
                [
                    76,
                    " ptr = p -> data [ 0 ] ;\n"
                ],
                [
                    105,
                    " if ( buf_end - buf < len ) break ;\n"
                ],
                [
                    106,
                    " memcpy ( ptr , buf , len ) ;\n"
                ],
                [
                    107,
                    " ptr += stride ;\n"
                ],
                [
                    108,
                    " buf += alen ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int sunrast_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    60,
                    " if ( buf_end - buf < maplength ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    73,
                    " x ++ , ptr += 4 ) * ( uint32_t * ) ptr = ( buf [ x ] << 16 ) + ( buf [ len + x ] << 8 ) + buf [ len + len + x ] ;\n"
                ],
                [
                    76,
                    " ptr = p -> data [ 0 ] ;\n"
                ],
                [
                    105,
                    " if ( buf_end - buf < len ) break ;\n"
                ],
                [
                    106,
                    " memcpy ( ptr , buf , len ) ;\n"
                ],
                [
                    107,
                    " ptr += stride ;\n"
                ],
                [
                    108,
                    " buf += alen ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = avpkt -> data + avpkt -> size ;\n int buf_size = avpkt -> size ;\n QdrawContext * const a = avctx -> priv_data ;\n AVFrame * const p = & a -> pic ;\n uint8_t * outdata ;\n int colors ;\n int i , ret ;\n uint32_t * pal ;\n int r , g , b ;\n if ( p -> data [ 0 ] ) avctx -> release_buffer ( avctx , p ) ;\n p -> reference = 0 ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n p -> pict_type = AV_PICTURE_TYPE_I ;\n p -> key_frame = 1 ;\n outdata = a -> pic . data [ 0 ] ;\n if ( buf_end - buf < 0x68 + 4 ) return AVERROR_INVALIDDATA ;\n buf += 0x68 ;\n colors = AV_RB32 ( buf ) ;\n buf += 4 ;\n if ( colors < 0 || colors > 256 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error color count - %i(0x%X)\\n\" , colors , colors ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( buf_end - buf < ( colors + 1 ) * 8 ) return AVERROR_INVALIDDATA ;\n pal = ( uint32_t * ) p -> data [ 1 ] ;\n for ( i = 0 ;\n i <= colors ;\n i ++ ) {\n unsigned int idx ;\n idx = AV_RB16 ( buf ) ;\n buf += 2 ;\n if ( idx > 255 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Palette index out of range: %u\\n\" , idx ) ;\n buf += 6 ;\n continue ;\n }\n r = * buf ++ ;\n buf ++ ;\n g = * buf ++ ;\n buf ++ ;\n b = * buf ++ ;\n buf ++ ;\n pal [ idx ] = ( r << 16 ) | ( g << 8 ) | b ;\n }\n p -> palette_has_changed = 1 ;\n if ( buf_end - buf < 18 ) return AVERROR_INVALIDDATA ;\n buf += 18 ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n int size , left , code , pix ;\n const uint8_t * next ;\n uint8_t * out ;\n int tsize = 0 ;\n out = outdata ;\n size = AV_RB16 ( buf ) ;\n buf += 2 ;\n if ( buf_end - buf < size ) return AVERROR_INVALIDDATA ;\n left = size ;\n next = buf + size ;\n while ( left > 0 ) {\n code = * buf ++ ;\n if ( code & 0x80 ) {\n pix = * buf ++ ;\n if ( ( out + ( 257 - code ) ) > ( outdata + a -> pic . linesize [ 0 ] ) ) break ;\n memset ( out , pix , 257 - code ) ;\n out += 257 - code ;\n tsize += 257 - code ;\n left -= 2 ;\n }\n else {\n if ( ( out + code ) > ( outdata + a -> pic . linesize [ 0 ] ) ) break ;\n if ( buf_end - buf < code + 1 ) return AVERROR_INVALIDDATA ;\n memcpy ( out , buf , code + 1 ) ;\n out += code + 1 ;\n buf += code + 1 ;\n left -= 2 + code ;\n tsize += code + 1 ;\n }\n }\n buf = next ;\n outdata += a -> pic . linesize [ 0 ] ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = a -> pic ;\n return buf_size ;\n }",
        "hash": -5332743636142828697,
        "project": "debian",
        "size": 92,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    60,
                    " out = outdata ;\n"
                ],
                [
                    68,
                    " if ( code & 0x80 ) {\n"
                ],
                [
                    72,
                    " out += 257 - code ;\n"
                ],
                [
                    78,
                    " if ( buf_end - buf < code + 1 ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    79,
                    " memcpy ( out , buf , code + 1 ) ;\n"
                ],
                [
                    80,
                    " out += code + 1 ;\n"
                ],
                [
                    81,
                    " buf += code + 1 ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    60,
                    " out = outdata ;\n"
                ],
                [
                    69,
                    " pix = * buf ++ ;\n"
                ],
                [
                    70,
                    " if ( ( out + ( 257 - code ) ) > ( outdata + a -> pic . linesize [ 0 ] ) ) break ;\n"
                ],
                [
                    71,
                    " memset ( out , pix , 257 - code ) ;\n"
                ],
                [
                    72,
                    " out += 257 - code ;\n"
                ],
                [
                    80,
                    " out += code + 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    60,
                    " out = outdata ;\n"
                ],
                [
                    68,
                    " if ( code & 0x80 ) {\n"
                ],
                [
                    69,
                    " pix = * buf ++ ;\n"
                ],
                [
                    70,
                    " if ( ( out + ( 257 - code ) ) > ( outdata + a -> pic . linesize [ 0 ] ) ) break ;\n"
                ],
                [
                    71,
                    " memset ( out , pix , 257 - code ) ;\n"
                ],
                [
                    72,
                    " out += 257 - code ;\n"
                ],
                [
                    78,
                    " if ( buf_end - buf < code + 1 ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    79,
                    " memcpy ( out , buf , code + 1 ) ;\n"
                ],
                [
                    80,
                    " out += code + 1 ;\n"
                ],
                [
                    81,
                    " buf += code + 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n VmncContext * const c = avctx -> priv_data ;\n uint8_t * outptr ;\n const uint8_t * src = buf ;\n int dx , dy , w , h , depth , enc , chunks , res , size_left ;\n c -> pic . reference = 1 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( avctx -> reget_buffer ( avctx , & c -> pic ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n c -> pic . key_frame = 0 ;\n c -> pic . pict_type = AV_PICTURE_TYPE_P ;\n if ( c -> screendta ) {\n int i ;\n w = c -> cur_w ;\n if ( c -> width < c -> cur_x + w ) w = c -> width - c -> cur_x ;\n h = c -> cur_h ;\n if ( c -> height < c -> cur_y + h ) h = c -> height - c -> cur_y ;\n dx = c -> cur_x ;\n if ( dx < 0 ) {\n w += dx ;\n dx = 0 ;\n }\n dy = c -> cur_y ;\n if ( dy < 0 ) {\n h += dy ;\n dy = 0 ;\n }\n if ( ( w > 0 ) && ( h > 0 ) ) {\n outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n for ( i = 0 ;\n i < h ;\n i ++ ) {\n memcpy ( outptr , c -> screendta + i * c -> cur_w * c -> bpp2 , w * c -> bpp2 ) ;\n outptr += c -> pic . linesize [ 0 ] ;\n }\n }\n }\n src += 2 ;\n chunks = AV_RB16 ( src ) ;\n src += 2 ;\n while ( chunks -- ) {\n dx = AV_RB16 ( src ) ;\n src += 2 ;\n dy = AV_RB16 ( src ) ;\n src += 2 ;\n w = AV_RB16 ( src ) ;\n src += 2 ;\n h = AV_RB16 ( src ) ;\n src += 2 ;\n enc = AV_RB32 ( src ) ;\n src += 4 ;\n outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n size_left = buf_size - ( src - buf ) ;\n switch ( enc ) {\n case MAGIC_WMVd : if ( size_left < 2 + w * h * c -> bpp2 * 2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Premature end of data! (need %i got %i)\\n\" , 2 + w * h * c -> bpp2 * 2 , size_left ) ;\n return - 1 ;\n }\n src += 2 ;\n c -> cur_w = w ;\n c -> cur_h = h ;\n c -> cur_hx = dx ;\n c -> cur_hy = dy ;\n if ( ( c -> cur_hx > c -> cur_w ) || ( c -> cur_hy > c -> cur_h ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Cursor hot spot is not in image: %ix%i of %ix%i cursor size\\n\" , c -> cur_hx , c -> cur_hy , c -> cur_w , c -> cur_h ) ;\n c -> cur_hx = c -> cur_hy = 0 ;\n }\n c -> curbits = av_realloc ( c -> curbits , c -> cur_w * c -> cur_h * c -> bpp2 ) ;\n c -> curmask = av_realloc ( c -> curmask , c -> cur_w * c -> cur_h * c -> bpp2 ) ;\n c -> screendta = av_realloc ( c -> screendta , c -> cur_w * c -> cur_h * c -> bpp2 ) ;\n load_cursor ( c , src ) ;\n src += w * h * c -> bpp2 * 2 ;\n break ;\n case MAGIC_WMVe : src += 2 ;\n break ;\n case MAGIC_WMVf : c -> cur_x = dx - c -> cur_hx ;\n c -> cur_y = dy - c -> cur_hy ;\n break ;\n case MAGIC_WMVg : src += 10 ;\n break ;\n case MAGIC_WMVh : src += 4 ;\n break ;\n case MAGIC_WMVi : c -> pic . key_frame = 1 ;\n c -> pic . pict_type = AV_PICTURE_TYPE_I ;\n depth = * src ++ ;\n if ( depth != c -> bpp ) {\n av_log ( avctx , AV_LOG_INFO , \"Depth mismatch. Container %i bpp, Frame data: %i bpp\\n\" , c -> bpp , depth ) ;\n }\n src ++ ;\n c -> bigendian = * src ++ ;\n if ( c -> bigendian & ( ~ 1 ) ) {\n av_log ( avctx , AV_LOG_INFO , \"Invalid header: bigendian flag = %i\\n\" , c -> bigendian ) ;\n return - 1 ;\n }\n src += 13 ;\n break ;\n case MAGIC_WMVj : src += 2 ;\n break ;\n case 0x00000000 : if ( ( dx + w > c -> width ) || ( dy + h > c -> height ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Incorrect frame size: %ix%i+%ix%i of %ix%i\\n\" , w , h , dx , dy , c -> width , c -> height ) ;\n return - 1 ;\n }\n if ( size_left < w * h * c -> bpp2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Premature end of data! (need %i got %i)\\n\" , w * h * c -> bpp2 , size_left ) ;\n return - 1 ;\n }\n paint_raw ( outptr , w , h , src , c -> bpp2 , c -> bigendian , c -> pic . linesize [ 0 ] ) ;\n src += w * h * c -> bpp2 ;\n break ;\n case 0x00000005 : if ( ( dx + w > c -> width ) || ( dy + h > c -> height ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Incorrect frame size: %ix%i+%ix%i of %ix%i\\n\" , w , h , dx , dy , c -> width , c -> height ) ;\n return - 1 ;\n }\n res = decode_hextile ( c , outptr , src , size_left , w , h , c -> pic . linesize [ 0 ] ) ;\n if ( res < 0 ) return - 1 ;\n src += res ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unsupported block type 0x%08X\\n\" , enc ) ;\n chunks = 0 ;\n }\n }\n if ( c -> screendta ) {\n int i ;\n w = c -> cur_w ;\n if ( c -> width < c -> cur_x + w ) w = c -> width - c -> cur_x ;\n h = c -> cur_h ;\n if ( c -> height < c -> cur_y + h ) h = c -> height - c -> cur_y ;\n dx = c -> cur_x ;\n if ( dx < 0 ) {\n w += dx ;\n dx = 0 ;\n }\n dy = c -> cur_y ;\n if ( dy < 0 ) {\n h += dy ;\n dy = 0 ;\n }\n if ( ( w > 0 ) && ( h > 0 ) ) {\n outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n for ( i = 0 ;\n i < h ;\n i ++ ) {\n memcpy ( c -> screendta + i * c -> cur_w * c -> bpp2 , outptr , w * c -> bpp2 ) ;\n outptr += c -> pic . linesize [ 0 ] ;\n }\n outptr = c -> pic . data [ 0 ] ;\n put_cursor ( outptr , c -> pic . linesize [ 0 ] , c , c -> cur_x , c -> cur_y ) ;\n }\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }",
        "hash": -3223310365196836448,
        "project": "debian",
        "size": 157,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " VmncContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    33,
                    " outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    35,
                    " i < h ;\n"
                ],
                [
                    37,
                    " memcpy ( outptr , c -> screendta + i * c -> cur_w * c -> bpp2 , w * c -> bpp2 ) ;\n"
                ],
                [
                    38,
                    " outptr += c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    74,
                    " c -> screendta = av_realloc ( c -> screendta , c -> cur_w * c -> cur_h * c -> bpp2 ) ;\n"
                ],
                [
                    75,
                    " load_cursor ( c , src ) ;\n"
                ],
                [
                    118,
                    " res = decode_hextile ( c , outptr , src , size_left , w , h , c -> pic . linesize [ 0 ] ) ;\n"
                ],
                [
                    143,
                    " outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    145,
                    " i < h ;\n"
                ],
                [
                    147,
                    " memcpy ( c -> screendta + i * c -> cur_w * c -> bpp2 , outptr , w * c -> bpp2 ) ;\n"
                ],
                [
                    148,
                    " outptr += c -> pic . linesize [ 0 ] ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " VmncContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    33,
                    " outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    35,
                    " i < h ;\n"
                ],
                [
                    37,
                    " memcpy ( outptr , c -> screendta + i * c -> cur_w * c -> bpp2 , w * c -> bpp2 ) ;\n"
                ],
                [
                    38,
                    " outptr += c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    74,
                    " c -> screendta = av_realloc ( c -> screendta , c -> cur_w * c -> cur_h * c -> bpp2 ) ;\n"
                ],
                [
                    75,
                    " load_cursor ( c , src ) ;\n"
                ],
                [
                    118,
                    " res = decode_hextile ( c , outptr , src , size_left , w , h , c -> pic . linesize [ 0 ] ) ;\n"
                ],
                [
                    143,
                    " outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    145,
                    " i < h ;\n"
                ],
                [
                    147,
                    " memcpy ( c -> screendta + i * c -> cur_w * c -> bpp2 , outptr , w * c -> bpp2 ) ;\n"
                ],
                [
                    148,
                    " outptr += c -> pic . linesize [ 0 ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void fill_slice_long ( AVCodecContext * avctx , DXVA_Slice_H264_Long * slice , unsigned position , unsigned size ) {\n const H264Context * h = avctx -> priv_data ;\n struct dxva_context * ctx = avctx -> hwaccel_context ;\n unsigned list ;\n memset ( slice , 0 , sizeof ( * slice ) ) ;\n slice -> BSNALunitDataLocation = position ;\n slice -> SliceBytesInBuffer = size ;\n slice -> wBadSliceChopping = 0 ;\n slice -> first_mb_in_slice = ( h -> mb_y >> FIELD_OR_MBAFF_PICTURE ) * h -> mb_width + h -> mb_x ;\n slice -> NumMbsForSlice = 0 ;\n slice -> BitOffsetToSliceData = get_bits_count ( & h -> gb ) ;\n slice -> slice_type = ff_h264_get_slice_type ( h ) ;\n if ( h -> slice_type_fixed ) slice -> slice_type += 5 ;\n slice -> luma_log2_weight_denom = h -> luma_log2_weight_denom ;\n slice -> chroma_log2_weight_denom = h -> chroma_log2_weight_denom ;\n if ( h -> list_count > 0 ) slice -> num_ref_idx_l0_active_minus1 = h -> ref_count [ 0 ] - 1 ;\n if ( h -> list_count > 1 ) slice -> num_ref_idx_l1_active_minus1 = h -> ref_count [ 1 ] - 1 ;\n slice -> slice_alpha_c0_offset_div2 = h -> slice_alpha_c0_offset / 2 - 26 ;\n slice -> slice_beta_offset_div2 = h -> slice_beta_offset / 2 - 26 ;\n slice -> Reserved8Bits = 0 ;\n for ( list = 0 ;\n list < 2 ;\n list ++ ) {\n unsigned i ;\n for ( i = 0 ;\n i < FF_ARRAY_ELEMS ( slice -> RefPicList [ list ] ) ;\n i ++ ) {\n if ( list < h -> list_count && i < h -> ref_count [ list ] ) {\n const Picture * r = & h -> ref_list [ list ] [ i ] ;\n unsigned plane ;\n fill_picture_entry ( & slice -> RefPicList [ list ] [ i ] , ff_dxva2_get_surface_index ( ctx , r ) , r -> f . reference == PICT_BOTTOM_FIELD ) ;\n for ( plane = 0 ;\n plane < 3 ;\n plane ++ ) {\n int w , o ;\n if ( plane == 0 && h -> luma_weight_flag [ list ] ) {\n w = h -> luma_weight [ i ] [ list ] [ 0 ] ;\n o = h -> luma_weight [ i ] [ list ] [ 1 ] ;\n }\n else if ( plane >= 1 && h -> chroma_weight_flag [ list ] ) {\n w = h -> chroma_weight [ i ] [ list ] [ plane - 1 ] [ 0 ] ;\n o = h -> chroma_weight [ i ] [ list ] [ plane - 1 ] [ 1 ] ;\n }\n else {\n w = 1 << ( plane == 0 ? h -> luma_log2_weight_denom : h -> chroma_log2_weight_denom ) ;\n o = 0 ;\n }\n slice -> Weights [ list ] [ i ] [ plane ] [ 0 ] = w ;\n slice -> Weights [ list ] [ i ] [ plane ] [ 1 ] = o ;\n }\n }\n else {\n unsigned plane ;\n slice -> RefPicList [ list ] [ i ] . bPicEntry = 0xff ;\n for ( plane = 0 ;\n plane < 3 ;\n plane ++ ) {\n slice -> Weights [ list ] [ i ] [ plane ] [ 0 ] = 0 ;\n slice -> Weights [ list ] [ i ] [ plane ] [ 1 ] = 0 ;\n }\n }\n }\n }\n slice -> slice_qs_delta = 0 ;\n slice -> slice_qp_delta = h -> qscale - h -> pps . init_qp ;\n slice -> redundant_pic_cnt = h -> redundant_pic_count ;\n if ( h -> slice_type == AV_PICTURE_TYPE_B ) slice -> direct_spatial_mv_pred_flag = h -> direct_spatial_mv_pred ;\n slice -> cabac_init_idc = h -> pps . cabac ? h -> cabac_init_idc : 0 ;\n if ( h -> deblocking_filter < 2 ) slice -> disable_deblocking_filter_idc = 1 - h -> deblocking_filter ;\n else slice -> disable_deblocking_filter_idc = h -> deblocking_filter ;\n slice -> slice_id = h -> current_slice - 1 ;\n }",
        "hash": 6871081691104220210,
        "project": "debian",
        "size": 72,
        "slice": {
            "memset": [
                [
                    1,
                    "static void fill_slice_long ( AVCodecContext * avctx , DXVA_Slice_H264_Long * slice , unsigned position , unsigned size ) {\n"
                ],
                [
                    5,
                    " memset ( slice , 0 , sizeof ( * slice ) ) ;\n"
                ],
                [
                    13,
                    " if ( h -> slice_type_fixed ) slice -> slice_type += 5 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void fill_slice_long ( AVCodecContext * avctx , DXVA_Slice_H264_Long * slice , unsigned position , unsigned size ) {\n"
                ],
                [
                    5,
                    " memset ( slice , 0 , sizeof ( * slice ) ) ;\n"
                ],
                [
                    13,
                    " if ( h -> slice_type_fixed ) slice -> slice_type += 5 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void fill_picture_parameters ( struct dxva_context * ctx , const H264Context * h , DXVA_PicParams_H264 * pp ) {\n const Picture * current_picture = h -> cur_pic_ptr ;\n int i , j ;\n memset ( pp , 0 , sizeof ( * pp ) ) ;\n fill_picture_entry ( & pp -> CurrPic , ff_dxva2_get_surface_index ( ctx , current_picture ) , h -> picture_structure == PICT_BOTTOM_FIELD ) ;\n pp -> UsedForReferenceFlags = 0 ;\n pp -> NonExistingFrameFlags = 0 ;\n for ( i = 0 , j = 0 ;\n i < FF_ARRAY_ELEMS ( pp -> RefFrameList ) ;\n i ++ ) {\n const Picture * r ;\n if ( j < h -> short_ref_count ) {\n r = h -> short_ref [ j ++ ] ;\n }\n else {\n r = NULL ;\n while ( ! r && j < h -> short_ref_count + 16 ) r = h -> long_ref [ j ++ - h -> short_ref_count ] ;\n }\n if ( r ) {\n fill_picture_entry ( & pp -> RefFrameList [ i ] , ff_dxva2_get_surface_index ( ctx , r ) , r -> long_ref != 0 ) ;\n if ( ( r -> f . reference & PICT_TOP_FIELD ) && r -> field_poc [ 0 ] != INT_MAX ) pp -> FieldOrderCntList [ i ] [ 0 ] = r -> field_poc [ 0 ] ;\n if ( ( r -> f . reference & PICT_BOTTOM_FIELD ) && r -> field_poc [ 1 ] != INT_MAX ) pp -> FieldOrderCntList [ i ] [ 1 ] = r -> field_poc [ 1 ] ;\n pp -> FrameNumList [ i ] = r -> long_ref ? r -> pic_id : r -> frame_num ;\n if ( r -> f . reference & PICT_TOP_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 0 ) ;\n if ( r -> f . reference & PICT_BOTTOM_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 1 ) ;\n }\n else {\n pp -> RefFrameList [ i ] . bPicEntry = 0xff ;\n pp -> FieldOrderCntList [ i ] [ 0 ] = 0 ;\n pp -> FieldOrderCntList [ i ] [ 1 ] = 0 ;\n pp -> FrameNumList [ i ] = 0 ;\n }\n }\n pp -> wFrameWidthInMbsMinus1 = h -> mb_width - 1 ;\n pp -> wFrameHeightInMbsMinus1 = h -> mb_height - 1 ;\n pp -> num_ref_frames = h -> sps . ref_frame_count ;\n pp -> wBitFields = ( ( h -> picture_structure != PICT_FRAME ) << 0 ) | ( ( h -> sps . mb_aff && ( h -> picture_structure == PICT_FRAME ) ) << 1 ) | ( h -> sps . residual_color_transform_flag << 2 ) | ( 0 << 3 ) | ( h -> sps . chroma_format_idc << 4 ) | ( ( h -> nal_ref_idc != 0 ) << 6 ) | ( h -> pps . constrained_intra_pred << 7 ) | ( h -> pps . weighted_pred << 8 ) | ( h -> pps . weighted_bipred_idc << 9 ) | ( 1 << 11 ) | ( h -> sps . frame_mbs_only_flag << 12 ) | ( h -> pps . transform_8x8_mode << 13 ) | ( ( h -> sps . level_idc >= 31 ) << 14 ) | ( 1 << 15 ) ;\n pp -> bit_depth_luma_minus8 = h -> sps . bit_depth_luma - 8 ;\n pp -> bit_depth_chroma_minus8 = h -> sps . bit_depth_chroma - 8 ;\n if ( ctx -> workaround & FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG ) pp -> Reserved16Bits = 0 ;\n else pp -> Reserved16Bits = 3 ;\n pp -> StatusReportFeedbackNumber = 1 + ctx -> report_id ++ ;\n pp -> CurrFieldOrderCnt [ 0 ] = 0 ;\n if ( ( h -> picture_structure & PICT_TOP_FIELD ) && current_picture -> field_poc [ 0 ] != INT_MAX ) pp -> CurrFieldOrderCnt [ 0 ] = current_picture -> field_poc [ 0 ] ;\n pp -> CurrFieldOrderCnt [ 1 ] = 0 ;\n if ( ( h -> picture_structure & PICT_BOTTOM_FIELD ) && current_picture -> field_poc [ 1 ] != INT_MAX ) pp -> CurrFieldOrderCnt [ 1 ] = current_picture -> field_poc [ 1 ] ;\n pp -> pic_init_qs_minus26 = h -> pps . init_qs - 26 ;\n pp -> chroma_qp_index_offset = h -> pps . chroma_qp_index_offset [ 0 ] ;\n pp -> second_chroma_qp_index_offset = h -> pps . chroma_qp_index_offset [ 1 ] ;\n pp -> ContinuationFlag = 1 ;\n pp -> pic_init_qp_minus26 = h -> pps . init_qp - 26 ;\n pp -> num_ref_idx_l0_active_minus1 = h -> pps . ref_count [ 0 ] - 1 ;\n pp -> num_ref_idx_l1_active_minus1 = h -> pps . ref_count [ 1 ] - 1 ;\n pp -> Reserved8BitsA = 0 ;\n pp -> frame_num = h -> frame_num ;\n pp -> log2_max_frame_num_minus4 = h -> sps . log2_max_frame_num - 4 ;\n pp -> pic_order_cnt_type = h -> sps . poc_type ;\n if ( h -> sps . poc_type == 0 ) pp -> log2_max_pic_order_cnt_lsb_minus4 = h -> sps . log2_max_poc_lsb - 4 ;\n else if ( h -> sps . poc_type == 1 ) pp -> delta_pic_order_always_zero_flag = h -> sps . delta_pic_order_always_zero_flag ;\n pp -> direct_8x8_inference_flag = h -> sps . direct_8x8_inference_flag ;\n pp -> entropy_coding_mode_flag = h -> pps . cabac ;\n pp -> pic_order_present_flag = h -> pps . pic_order_present ;\n pp -> num_slice_groups_minus1 = h -> pps . slice_group_count - 1 ;\n pp -> slice_group_map_type = h -> pps . mb_slice_group_map_type ;\n pp -> deblocking_filter_control_present_flag = h -> pps . deblocking_filter_parameters_present ;\n pp -> redundant_pic_cnt_present_flag = h -> pps . redundant_pic_cnt_present ;\n pp -> Reserved8BitsB = 0 ;\n pp -> slice_group_change_rate_minus1 = 0 ;\n }",
        "hash": 6871081691104220210,
        "project": "debian",
        "size": 69,
        "slice": {
            "memset": [
                [
                    1,
                    "static void fill_picture_parameters ( struct dxva_context * ctx , const H264Context * h , DXVA_PicParams_H264 * pp ) {\n"
                ],
                [
                    4,
                    " memset ( pp , 0 , sizeof ( * pp ) ) ;\n"
                ],
                [
                    5,
                    " fill_picture_entry ( & pp -> CurrPic , ff_dxva2_get_surface_index ( ctx , current_picture ) , h -> picture_structure == PICT_BOTTOM_FIELD ) ;\n"
                ],
                [
                    9,
                    " i < FF_ARRAY_ELEMS ( pp -> RefFrameList ) ;\n"
                ],
                [
                    24,
                    " if ( r -> f . reference & PICT_TOP_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 0 ) ;\n"
                ],
                [
                    25,
                    " if ( r -> f . reference & PICT_BOTTOM_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 1 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void fill_picture_parameters ( struct dxva_context * ctx , const H264Context * h , DXVA_PicParams_H264 * pp ) {\n"
                ],
                [
                    4,
                    " memset ( pp , 0 , sizeof ( * pp ) ) ;\n"
                ],
                [
                    5,
                    " fill_picture_entry ( & pp -> CurrPic , ff_dxva2_get_surface_index ( ctx , current_picture ) , h -> picture_structure == PICT_BOTTOM_FIELD ) ;\n"
                ],
                [
                    9,
                    " i < FF_ARRAY_ELEMS ( pp -> RefFrameList ) ;\n"
                ],
                [
                    24,
                    " if ( r -> f . reference & PICT_TOP_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 0 ) ;\n"
                ],
                [
                    25,
                    " if ( r -> f . reference & PICT_BOTTOM_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 1 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int bfi_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n GetByteContext g ;\n int buf_size = avpkt -> size ;\n BFIContext * bfi = avctx -> priv_data ;\n uint8_t * dst = bfi -> dst ;\n uint8_t * src , * dst_offset , colour1 , colour2 ;\n uint8_t * frame_end = bfi -> dst + avctx -> width * avctx -> height ;\n uint32_t * pal ;\n int i , j , ret , height = avctx -> height ;\n if ( bfi -> frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & bfi -> frame ) ;\n bfi -> frame . reference = 1 ;\n if ( ( ret = ff_get_buffer ( avctx , & bfi -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n bytestream2_init ( & g , avpkt -> data , buf_size ) ;\n if ( ! avctx -> frame_number ) {\n bfi -> frame . pict_type = AV_PICTURE_TYPE_I ;\n bfi -> frame . key_frame = 1 ;\n if ( avctx -> extradata_size > 768 ) {\n av_log ( NULL , AV_LOG_ERROR , \"Palette is too large.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n pal = ( uint32_t * ) bfi -> frame . data [ 1 ] ;\n for ( i = 0 ;\n i < avctx -> extradata_size / 3 ;\n i ++ ) {\n int shift = 16 ;\n * pal = 0 ;\n for ( j = 0 ;\n j < 3 ;\n j ++ , shift -= 8 ) * pal += ( ( avctx -> extradata [ i * 3 + j ] << 2 ) | ( avctx -> extradata [ i * 3 + j ] >> 4 ) ) << shift ;\n pal ++ ;\n }\n bfi -> frame . palette_has_changed = 1 ;\n }\n else {\n bfi -> frame . pict_type = AV_PICTURE_TYPE_P ;\n bfi -> frame . key_frame = 0 ;\n }\n bytestream2_skip ( & g , 4 ) ;\n while ( dst != frame_end ) {\n static const uint8_t lentab [ 4 ] = {\n 0 , 2 , 0 , 1 }\n ;\n unsigned int byte = bytestream2_get_byte ( & g ) , av_uninit ( offset ) ;\n unsigned int code = byte >> 6 ;\n unsigned int length = byte & ~ 0xC0 ;\n if ( ! bytestream2_get_bytes_left ( & g ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Input resolution larger than actual frame.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( length == 0 ) {\n if ( code == 1 ) {\n length = bytestream2_get_byte ( & g ) ;\n offset = bytestream2_get_le16 ( & g ) ;\n }\n else {\n length = bytestream2_get_le16 ( & g ) ;\n if ( code == 2 && length == 0 ) break ;\n }\n }\n else {\n if ( code == 1 ) offset = bytestream2_get_byte ( & g ) ;\n }\n if ( dst + ( length << lentab [ code ] ) > frame_end ) break ;\n switch ( code ) {\n case 0 : if ( length >= bytestream2_get_bytes_left ( & g ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame larger than buffer.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_get_buffer ( & g , dst , length ) ;\n dst += length ;\n break ;\n case 1 : dst_offset = dst - offset ;\n length *= 4 ;\n if ( dst_offset < bfi -> dst ) break ;\n while ( length -- ) * dst ++ = * dst_offset ++ ;\n break ;\n case 2 : dst += length ;\n break ;\n case 3 : colour1 = bytestream2_get_byte ( & g ) ;\n colour2 = bytestream2_get_byte ( & g ) ;\n while ( length -- ) {\n * dst ++ = colour1 ;\n * dst ++ = colour2 ;\n }\n break ;\n }\n }\n src = bfi -> dst ;\n dst = bfi -> frame . data [ 0 ] ;\n while ( height -- ) {\n memcpy ( dst , src , avctx -> width ) ;\n src += avctx -> width ;\n dst += bfi -> frame . linesize [ 0 ] ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = bfi -> frame ;\n return buf_size ;\n }",
        "hash": 2705024625298706915,
        "project": "debian",
        "size": 101,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int bfi_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    7,
                    " uint8_t * frame_end = bfi -> dst + avctx -> width * avctx -> height ;\n"
                ],
                [
                    12,
                    " if ( ( ret = ff_get_buffer ( avctx , & bfi -> frame ) ) < 0 ) {\n"
                ],
                [
                    91,
                    " src = bfi -> dst ;\n"
                ],
                [
                    92,
                    " dst = bfi -> frame . data [ 0 ] ;\n"
                ],
                [
                    93,
                    " while ( height -- ) {\n"
                ],
                [
                    94,
                    " memcpy ( dst , src , avctx -> width ) ;\n"
                ],
                [
                    95,
                    " src += avctx -> width ;\n"
                ],
                [
                    96,
                    " dst += bfi -> frame . linesize [ 0 ] ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int bfi_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    7,
                    " uint8_t * frame_end = bfi -> dst + avctx -> width * avctx -> height ;\n"
                ],
                [
                    12,
                    " if ( ( ret = ff_get_buffer ( avctx , & bfi -> frame ) ) < 0 ) {\n"
                ],
                [
                    91,
                    " src = bfi -> dst ;\n"
                ],
                [
                    92,
                    " dst = bfi -> frame . data [ 0 ] ;\n"
                ],
                [
                    93,
                    " while ( height -- ) {\n"
                ],
                [
                    94,
                    " memcpy ( dst , src , avctx -> width ) ;\n"
                ],
                [
                    95,
                    " src += avctx -> width ;\n"
                ],
                [
                    96,
                    " dst += bfi -> frame . linesize [ 0 ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n VBDecContext * const c = avctx -> priv_data ;\n uint8_t * outptr , * srcptr ;\n int i , j , ret ;\n int flags ;\n uint32_t size ;\n int offset = 0 ;\n bytestream2_init ( & c -> stream , avpkt -> data , avpkt -> size ) ;\n if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n c -> pic . reference = 1 ;\n if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n flags = bytestream2_get_le16 ( & c -> stream ) ;\n if ( flags & VB_HAS_GMC ) {\n i = ( int16_t ) bytestream2_get_le16 ( & c -> stream ) ;\n j = ( int16_t ) bytestream2_get_le16 ( & c -> stream ) ;\n offset = i + j * avctx -> width ;\n }\n if ( flags & VB_HAS_VIDEO ) {\n size = bytestream2_get_le32 ( & c -> stream ) ;\n vb_decode_framedata ( c , offset ) ;\n bytestream2_skip ( & c -> stream , size - 4 ) ;\n }\n if ( flags & VB_HAS_PALETTE ) {\n size = bytestream2_get_le32 ( & c -> stream ) ;\n vb_decode_palette ( c , size ) ;\n }\n memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n c -> pic . palette_has_changed = flags & VB_HAS_PALETTE ;\n outptr = c -> pic . data [ 0 ] ;\n srcptr = c -> frame ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n memcpy ( outptr , srcptr , avctx -> width ) ;\n srcptr += avctx -> width ;\n outptr += c -> pic . linesize [ 0 ] ;\n }\n FFSWAP ( uint8_t * , c -> frame , c -> prev_frame ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return avpkt -> size ;\n }",
        "hash": 2091417324431734585,
        "project": "debian",
        "size": 45,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " VBDecContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    11,
                    " if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n"
                ],
                [
                    19,
                    " offset = i + j * avctx -> width ;\n"
                ],
                [
                    23,
                    " vb_decode_framedata ( c , offset ) ;\n"
                ],
                [
                    28,
                    " vb_decode_palette ( c , size ) ;\n"
                ],
                [
                    30,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    32,
                    " outptr = c -> pic . data [ 0 ] ;\n"
                ],
                [
                    33,
                    " srcptr = c -> frame ;\n"
                ],
                [
                    35,
                    " i < avctx -> height ;\n"
                ],
                [
                    37,
                    " memcpy ( outptr , srcptr , avctx -> width ) ;\n"
                ],
                [
                    38,
                    " srcptr += avctx -> width ;\n"
                ],
                [
                    39,
                    " outptr += c -> pic . linesize [ 0 ] ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " VBDecContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    11,
                    " if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n"
                ],
                [
                    19,
                    " offset = i + j * avctx -> width ;\n"
                ],
                [
                    23,
                    " vb_decode_framedata ( c , offset ) ;\n"
                ],
                [
                    28,
                    " vb_decode_palette ( c , size ) ;\n"
                ],
                [
                    30,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    32,
                    " outptr = c -> pic . data [ 0 ] ;\n"
                ],
                [
                    33,
                    " srcptr = c -> frame ;\n"
                ],
                [
                    35,
                    " i < avctx -> height ;\n"
                ],
                [
                    37,
                    " memcpy ( outptr , srcptr , avctx -> width ) ;\n"
                ],
                [
                    38,
                    " srcptr += avctx -> width ;\n"
                ],
                [
                    39,
                    " outptr += c -> pic . linesize [ 0 ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int tmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n TMVContext * tmv = avctx -> priv_data ;\n const uint8_t * src = avpkt -> data ;\n uint8_t * dst ;\n unsigned char_cols = avctx -> width >> 3 ;\n unsigned char_rows = avctx -> height >> 3 ;\n unsigned x , y , fg , bg , c ;\n int ret ;\n if ( tmv -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & tmv -> pic ) ;\n if ( ( ret = ff_get_buffer ( avctx , & tmv -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( avpkt -> size < 2 * char_rows * char_cols ) {\n av_log ( avctx , AV_LOG_ERROR , \"Input buffer too small, truncated sample?\\n\" ) ;\n * got_frame = 0 ;\n return AVERROR_INVALIDDATA ;\n }\n tmv -> pic . pict_type = AV_PICTURE_TYPE_I ;\n tmv -> pic . key_frame = 1 ;\n dst = tmv -> pic . data [ 0 ] ;\n tmv -> pic . palette_has_changed = 1 ;\n memcpy ( tmv -> pic . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n for ( y = 0 ;\n y < char_rows ;\n y ++ ) {\n for ( x = 0 ;\n x < char_cols ;\n x ++ ) {\n c = * src ++ ;\n bg = * src >> 4 ;\n fg = * src ++ & 0xF ;\n ff_draw_pc_font ( dst + x * 8 , tmv -> pic . linesize [ 0 ] , ff_cga_font , 8 , c , fg , bg ) ;\n }\n dst += tmv -> pic . linesize [ 0 ] * 8 ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = tmv -> pic ;\n return avpkt -> size ;\n }",
        "hash": -6154134138260771502,
        "project": "debian",
        "size": 40,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int tmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    14,
                    " if ( avpkt -> size < 2 * char_rows * char_cols ) {\n"
                ],
                [
                    23,
                    " memcpy ( tmv -> pic . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int tmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    14,
                    " if ( avpkt -> size < 2 * char_rows * char_cols ) {\n"
                ],
                [
                    23,
                    " memcpy ( tmv -> pic . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n unsigned char * dst = s -> frame . data [ 0 ] ;\n int i ;\n for ( i = 0 ;\n i < s -> avctx -> height && buf_end - buf >= s -> avctx -> width ;\n i ++ ) {\n memcpy ( dst , buf , s -> avctx -> width ) ;\n dst += s -> frame . linesize [ 0 ] ;\n buf += s -> avctx -> width ;\n }\n }",
        "hash": 6020240946719726948,
        "project": "debian",
        "size": 11,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n"
                ],
                [
                    2,
                    " unsigned char * dst = s -> frame . data [ 0 ] ;\n"
                ],
                [
                    5,
                    " i < s -> avctx -> height && buf_end - buf >= s -> avctx -> width ;\n"
                ],
                [
                    7,
                    " memcpy ( dst , buf , s -> avctx -> width ) ;\n"
                ],
                [
                    8,
                    " dst += s -> frame . linesize [ 0 ] ;\n"
                ],
                [
                    9,
                    " buf += s -> avctx -> width ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n"
                ],
                [
                    2,
                    " unsigned char * dst = s -> frame . data [ 0 ] ;\n"
                ],
                [
                    5,
                    " i < s -> avctx -> height && buf_end - buf >= s -> avctx -> width ;\n"
                ],
                [
                    7,
                    " memcpy ( dst , buf , s -> avctx -> width ) ;\n"
                ],
                [
                    8,
                    " dst += s -> frame . linesize [ 0 ] ;\n"
                ],
                [
                    9,
                    " buf += s -> avctx -> width ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void cmv_decode_inter ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n const uint8_t * raw = buf + ( s -> avctx -> width * s -> avctx -> height / 16 ) ;\n int x , y , i ;\n i = 0 ;\n for ( y = 0 ;\n y < s -> avctx -> height / 4 ;\n y ++ ) for ( x = 0 ;\n x < s -> avctx -> width / 4 && buf_end - buf > i ;\n x ++ ) {\n if ( buf [ i ] == 0xFF ) {\n unsigned char * dst = s -> frame . data [ 0 ] + ( y * 4 ) * s -> frame . linesize [ 0 ] + x * 4 ;\n if ( raw + 16 < buf_end && * raw == 0xFF ) {\n raw ++ ;\n memcpy ( dst , raw , 4 ) ;\n memcpy ( dst + s -> frame . linesize [ 0 ] , raw + 4 , 4 ) ;\n memcpy ( dst + 2 * s -> frame . linesize [ 0 ] , raw + 8 , 4 ) ;\n memcpy ( dst + 3 * s -> frame . linesize [ 0 ] , raw + 12 , 4 ) ;\n raw += 16 ;\n }\n else if ( raw < buf_end ) {\n int xoffset = ( * raw & 0xF ) - 7 ;\n int yoffset = ( ( * raw >> 4 ) ) - 7 ;\n if ( s -> last2_frame . data [ 0 ] ) cmv_motcomp ( s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] , s -> last2_frame . data [ 0 ] , s -> last2_frame . linesize [ 0 ] , x * 4 , y * 4 , xoffset , yoffset , s -> avctx -> width , s -> avctx -> height ) ;\n raw ++ ;\n }\n }\n else {\n int xoffset = ( buf [ i ] & 0xF ) - 7 ;\n int yoffset = ( ( buf [ i ] >> 4 ) ) - 7 ;\n cmv_motcomp ( s -> frame . data [ 0 ] , s -> frame . linesize [ 0 ] , s -> last_frame . data [ 0 ] , s -> last_frame . linesize [ 0 ] , x * 4 , y * 4 , xoffset , yoffset , s -> avctx -> width , s -> avctx -> height ) ;\n }\n i ++ ;\n }\n }",
        "hash": 6020240946719726948,
        "project": "debian",
        "size": 34,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void cmv_decode_inter ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n"
                ],
                [
                    11,
                    " unsigned char * dst = s -> frame . data [ 0 ] + ( y * 4 ) * s -> frame . linesize [ 0 ] + x * 4 ;\n"
                ],
                [
                    12,
                    " if ( raw + 16 < buf_end && * raw == 0xFF ) {\n"
                ],
                [
                    13,
                    " raw ++ ;\n"
                ],
                [
                    14,
                    " memcpy ( dst , raw , 4 ) ;\n"
                ],
                [
                    15,
                    " memcpy ( dst + s -> frame . linesize [ 0 ] , raw + 4 , 4 ) ;\n"
                ],
                [
                    16,
                    " memcpy ( dst + 2 * s -> frame . linesize [ 0 ] , raw + 8 , 4 ) ;\n"
                ],
                [
                    17,
                    " memcpy ( dst + 3 * s -> frame . linesize [ 0 ] , raw + 12 , 4 ) ;\n"
                ],
                [
                    18,
                    " raw += 16 ;\n"
                ],
                [
                    22,
                    " int yoffset = ( ( * raw >> 4 ) ) - 7 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void cmv_decode_inter ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n"
                ],
                [
                    11,
                    " unsigned char * dst = s -> frame . data [ 0 ] + ( y * 4 ) * s -> frame . linesize [ 0 ] + x * 4 ;\n"
                ],
                [
                    12,
                    " if ( raw + 16 < buf_end && * raw == 0xFF ) {\n"
                ],
                [
                    13,
                    " raw ++ ;\n"
                ],
                [
                    14,
                    " memcpy ( dst , raw , 4 ) ;\n"
                ],
                [
                    15,
                    " memcpy ( dst + s -> frame . linesize [ 0 ] , raw + 4 , 4 ) ;\n"
                ],
                [
                    16,
                    " memcpy ( dst + 2 * s -> frame . linesize [ 0 ] , raw + 8 , 4 ) ;\n"
                ],
                [
                    17,
                    " memcpy ( dst + 3 * s -> frame . linesize [ 0 ] , raw + 12 , 4 ) ;\n"
                ],
                [
                    18,
                    " raw += 16 ;\n"
                ],
                [
                    22,
                    " int yoffset = ( ( * raw >> 4 ) ) - 7 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int cmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n CmvContext * s = avctx -> priv_data ;\n const uint8_t * buf_end = buf + buf_size ;\n if ( buf_end - buf < EA_PREAMBLE_SIZE ) return AVERROR_INVALIDDATA ;\n if ( AV_RL32 ( buf ) == MVIh_TAG || AV_RB32 ( buf ) == MVIh_TAG ) {\n cmv_process_header ( s , buf + EA_PREAMBLE_SIZE , buf_end ) ;\n return buf_size ;\n }\n if ( av_image_check_size ( s -> width , s -> height , 0 , s -> avctx ) ) return - 1 ;\n if ( s -> last2_frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> last2_frame ) ;\n FFSWAP ( AVFrame , s -> last_frame , s -> last2_frame ) ;\n FFSWAP ( AVFrame , s -> frame , s -> last_frame ) ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID ;\n if ( ff_get_buffer ( avctx , & s -> frame ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n buf += EA_PREAMBLE_SIZE ;\n if ( ( buf [ 0 ] & 1 ) ) {\n cmv_decode_inter ( s , buf + 2 , buf_end ) ;\n s -> frame . key_frame = 0 ;\n s -> frame . pict_type = AV_PICTURE_TYPE_P ;\n }\n else {\n s -> frame . key_frame = 1 ;\n s -> frame . pict_type = AV_PICTURE_TYPE_I ;\n cmv_decode_intra ( s , buf + 2 , buf_end ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": 6020240946719726948,
        "project": "debian",
        "size": 36,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int cmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " CmvContext * s = avctx -> priv_data ;\n"
                ],
                [
                    17,
                    " if ( ff_get_buffer ( avctx , & s -> frame ) < 0 ) {\n"
                ],
                [
                    21,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    24,
                    " cmv_decode_inter ( s , buf + 2 , buf_end ) ;\n"
                ],
                [
                    31,
                    " cmv_decode_intra ( s , buf + 2 , buf_end ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int cmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " CmvContext * s = avctx -> priv_data ;\n"
                ],
                [
                    17,
                    " if ( ff_get_buffer ( avctx , & s -> frame ) < 0 ) {\n"
                ],
                [
                    21,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    24,
                    " cmv_decode_inter ( s , buf + 2 , buf_end ) ;\n"
                ],
                [
                    31,
                    " cmv_decode_intra ( s , buf + 2 , buf_end ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int wma_decode_superframe ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n WMACodecContext * s = avctx -> priv_data ;\n int nb_frames , bit_offset , i , pos , len , ret ;\n uint8_t * q ;\n float * * samples ;\n int samples_offset ;\n tprintf ( avctx , \"***decode_superframe:\\n\" ) ;\n if ( buf_size == 0 ) {\n s -> last_superframe_len = 0 ;\n return 0 ;\n }\n if ( buf_size < avctx -> block_align ) {\n av_log ( avctx , AV_LOG_ERROR , \"Input packet size too small (%d < %d)\\n\" , buf_size , avctx -> block_align ) ;\n return AVERROR_INVALIDDATA ;\n }\n buf_size = avctx -> block_align ;\n init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n if ( s -> use_bit_reservoir ) {\n skip_bits ( & s -> gb , 4 ) ;\n nb_frames = get_bits ( & s -> gb , 4 ) - ( s -> last_superframe_len <= 0 ) ;\n }\n else {\n nb_frames = 1 ;\n }\n frame -> nb_samples = nb_frames * s -> frame_len ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( float * * ) frame -> extended_data ;\n samples_offset = 0 ;\n if ( s -> use_bit_reservoir ) {\n bit_offset = get_bits ( & s -> gb , s -> byte_offset_bits + 3 ) ;\n if ( bit_offset > get_bits_left ( & s -> gb ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid last frame bit offset %d > buf size %d (%d)\\n\" , bit_offset , get_bits_left ( & s -> gb ) , buf_size ) ;\n goto fail ;\n }\n if ( s -> last_superframe_len > 0 ) {\n if ( ( s -> last_superframe_len + ( ( bit_offset + 7 ) >> 3 ) ) > MAX_CODED_SUPERFRAME_SIZE ) goto fail ;\n q = s -> last_superframe + s -> last_superframe_len ;\n len = bit_offset ;\n while ( len > 7 ) {\n * q ++ = ( get_bits ) ( & s -> gb , 8 ) ;\n len -= 8 ;\n }\n if ( len > 0 ) {\n * q ++ = ( get_bits ) ( & s -> gb , len ) << ( 8 - len ) ;\n }\n memset ( q , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n init_get_bits ( & s -> gb , s -> last_superframe , s -> last_superframe_len * 8 + bit_offset ) ;\n if ( s -> last_bitoffset > 0 ) skip_bits ( & s -> gb , s -> last_bitoffset ) ;\n if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n samples_offset += s -> frame_len ;\n nb_frames -- ;\n }\n pos = bit_offset + 4 + 4 + s -> byte_offset_bits + 3 ;\n if ( pos >= MAX_CODED_SUPERFRAME_SIZE * 8 || pos > buf_size * 8 ) return AVERROR_INVALIDDATA ;\n init_get_bits ( & s -> gb , buf + ( pos >> 3 ) , ( buf_size - ( pos >> 3 ) ) * 8 ) ;\n len = pos & 7 ;\n if ( len > 0 ) skip_bits ( & s -> gb , len ) ;\n s -> reset_block_lengths = 1 ;\n for ( i = 0 ;\n i < nb_frames ;\n i ++ ) {\n if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n samples_offset += s -> frame_len ;\n }\n pos = get_bits_count ( & s -> gb ) + ( ( bit_offset + 4 + 4 + s -> byte_offset_bits + 3 ) & ~ 7 ) ;\n s -> last_bitoffset = pos & 7 ;\n pos >>= 3 ;\n len = buf_size - pos ;\n if ( len > MAX_CODED_SUPERFRAME_SIZE || len < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"len %d invalid\\n\" , len ) ;\n goto fail ;\n }\n s -> last_superframe_len = len ;\n memcpy ( s -> last_superframe , buf + pos , len ) ;\n }\n else {\n if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n samples_offset += s -> frame_len ;\n }\n av_dlog ( s -> avctx , \"%d %d %d %d outbytes:%td eaten:%d\\n\" , s -> frame_len_bits , s -> block_len_bits , s -> frame_len , s -> block_len , ( int8_t * ) samples - ( int8_t * ) data , avctx -> block_align ) ;\n * got_frame_ptr = 1 ;\n return avctx -> block_align ;\n fail : s -> last_superframe_len = 0 ;\n return - 1 ;\n }",
        "hash": -2922528420890432122,
        "project": "debian",
        "size": 91,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int wma_decode_superframe ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " WMACodecContext * s = avctx -> priv_data ;\n"
                ],
                [
                    20,
                    " init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n"
                ],
                [
                    53,
                    " init_get_bits ( & s -> gb , s -> last_superframe , s -> last_superframe_len * 8 + bit_offset ) ;\n"
                ],
                [
                    55,
                    " if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n"
                ],
                [
                    68,
                    " if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n"
                ],
                [
                    74,
                    " len = buf_size - pos ;\n"
                ],
                [
                    75,
                    " if ( len > MAX_CODED_SUPERFRAME_SIZE || len < 0 ) {\n"
                ],
                [
                    80,
                    " memcpy ( s -> last_superframe , buf + pos , len ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int wma_decode_superframe ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    42,
                    " if ( ( s -> last_superframe_len + ( ( bit_offset + 7 ) >> 3 ) ) > MAX_CODED_SUPERFRAME_SIZE ) goto fail ;\n"
                ],
                [
                    43,
                    " q = s -> last_superframe + s -> last_superframe_len ;\n"
                ],
                [
                    46,
                    " * q ++ = ( get_bits ) ( & s -> gb , 8 ) ;\n"
                ],
                [
                    50,
                    " * q ++ = ( get_bits ) ( & s -> gb , len ) << ( 8 - len ) ;\n"
                ],
                [
                    52,
                    " memset ( q , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int wma_decode_superframe ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " WMACodecContext * s = avctx -> priv_data ;\n"
                ],
                [
                    20,
                    " init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n"
                ],
                [
                    42,
                    " if ( ( s -> last_superframe_len + ( ( bit_offset + 7 ) >> 3 ) ) > MAX_CODED_SUPERFRAME_SIZE ) goto fail ;\n"
                ],
                [
                    43,
                    " q = s -> last_superframe + s -> last_superframe_len ;\n"
                ],
                [
                    46,
                    " * q ++ = ( get_bits ) ( & s -> gb , 8 ) ;\n"
                ],
                [
                    50,
                    " * q ++ = ( get_bits ) ( & s -> gb , len ) << ( 8 - len ) ;\n"
                ],
                [
                    52,
                    " memset ( q , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    53,
                    " init_get_bits ( & s -> gb , s -> last_superframe , s -> last_superframe_len * 8 + bit_offset ) ;\n"
                ],
                [
                    55,
                    " if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n"
                ],
                [
                    68,
                    " if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n"
                ],
                [
                    74,
                    " len = buf_size - pos ;\n"
                ],
                [
                    75,
                    " if ( len > MAX_CODED_SUPERFRAME_SIZE || len < 0 ) {\n"
                ],
                [
                    80,
                    " memcpy ( s -> last_superframe , buf + pos , len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int ac3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AC3DecodeContext * s = avctx -> priv_data ;\n int blk , ch , err , ret ;\n const uint8_t * channel_map ;\n const float * output [ AC3_MAX_CHANNELS ] ;\n if ( buf_size >= 2 && AV_RB16 ( buf ) == 0x770B ) {\n int cnt = FFMIN ( buf_size , AC3_FRAME_BUFFER_SIZE ) >> 1 ;\n s -> dsp . bswap16_buf ( ( uint16_t * ) s -> input_buffer , ( const uint16_t * ) buf , cnt ) ;\n }\n else memcpy ( s -> input_buffer , buf , FFMIN ( buf_size , AC3_FRAME_BUFFER_SIZE ) ) ;\n buf = s -> input_buffer ;\n init_get_bits ( & s -> gbc , buf , buf_size * 8 ) ;\n err = parse_frame_header ( s ) ;\n if ( err ) {\n switch ( err ) {\n case AAC_AC3_PARSE_ERROR_SYNC : av_log ( avctx , AV_LOG_ERROR , \"frame sync error\\n\" ) ;\n return - 1 ;\n case AAC_AC3_PARSE_ERROR_BSID : av_log ( avctx , AV_LOG_ERROR , \"invalid bitstream id\\n\" ) ;\n break ;\n case AAC_AC3_PARSE_ERROR_SAMPLE_RATE : av_log ( avctx , AV_LOG_ERROR , \"invalid sample rate\\n\" ) ;\n break ;\n case AAC_AC3_PARSE_ERROR_FRAME_SIZE : av_log ( avctx , AV_LOG_ERROR , \"invalid frame size\\n\" ) ;\n break ;\n case AAC_AC3_PARSE_ERROR_FRAME_TYPE : if ( s -> frame_type == EAC3_FRAME_TYPE_DEPENDENT || s -> substreamid ) {\n av_log ( avctx , AV_LOG_ERROR , \"unsupported frame type : \" \"skipping frame\\n\" ) ;\n * got_frame_ptr = 0 ;\n return s -> frame_size ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"invalid frame type\\n\" ) ;\n }\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"invalid header\\n\" ) ;\n break ;\n }\n }\n else {\n if ( s -> frame_size > buf_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"incomplete frame\\n\" ) ;\n err = AAC_AC3_PARSE_ERROR_FRAME_SIZE ;\n }\n else if ( avctx -> err_recognition & AV_EF_CRCCHECK ) {\n if ( av_crc ( av_crc_get_table ( AV_CRC_16_ANSI ) , 0 , & buf [ 2 ] , s -> frame_size - 2 ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"frame CRC mismatch\\n\" ) ;\n err = AAC_AC3_PARSE_ERROR_CRC ;\n }\n }\n }\n if ( ! err ) {\n avctx -> sample_rate = s -> sample_rate ;\n avctx -> bit_rate = s -> bit_rate ;\n }\n if ( ! err || ( s -> channels && s -> out_channels != s -> channels ) ) {\n s -> out_channels = s -> channels ;\n s -> output_mode = s -> channel_mode ;\n if ( s -> lfe_on ) s -> output_mode |= AC3_OUTPUT_LFEON ;\n if ( avctx -> request_channels > 0 && avctx -> request_channels <= 2 && avctx -> request_channels < s -> channels ) {\n s -> out_channels = avctx -> request_channels ;\n s -> output_mode = avctx -> request_channels == 1 ? AC3_CHMODE_MONO : AC3_CHMODE_STEREO ;\n s -> channel_layout = avpriv_ac3_channel_layout_tab [ s -> output_mode ] ;\n }\n avctx -> channels = s -> out_channels ;\n avctx -> channel_layout = s -> channel_layout ;\n if ( s -> channels != s -> out_channels && ! ( ( s -> output_mode & AC3_OUTPUT_LFEON ) && s -> fbw_channels == s -> out_channels ) ) {\n set_downmix_coeffs ( s ) ;\n }\n }\n else if ( ! s -> channels ) {\n av_log ( avctx , AV_LOG_ERROR , \"unable to determine channel mode\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n avctx -> channels = s -> out_channels ;\n avctx -> audio_service_type = s -> bitstream_mode ;\n if ( s -> bitstream_mode == 0x7 && s -> channels > 1 ) avctx -> audio_service_type = AV_AUDIO_SERVICE_TYPE_KARAOKE ;\n frame -> nb_samples = s -> num_blocks * 256 ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n channel_map = ff_ac3_dec_channel_map [ s -> output_mode & ~ AC3_OUTPUT_LFEON ] [ s -> lfe_on ] ;\n for ( ch = 0 ;\n ch < s -> channels ;\n ch ++ ) {\n if ( ch < s -> out_channels ) s -> outptr [ channel_map [ ch ] ] = ( float * ) frame -> data [ ch ] ;\n else s -> outptr [ ch ] = s -> output [ ch ] ;\n output [ ch ] = s -> output [ ch ] ;\n }\n for ( blk = 0 ;\n blk < s -> num_blocks ;\n blk ++ ) {\n if ( ! err && decode_audio_block ( s , blk ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"error decoding the audio block\\n\" ) ;\n err = 1 ;\n }\n if ( err ) for ( ch = 0 ;\n ch < s -> out_channels ;\n ch ++ ) memcpy ( s -> outptr [ channel_map [ ch ] ] , output [ ch ] , 1024 ) ;\n for ( ch = 0 ;\n ch < s -> out_channels ;\n ch ++ ) {\n output [ ch ] = s -> outptr [ channel_map [ ch ] ] ;\n s -> outptr [ channel_map [ ch ] ] += AC3_BLOCK_SIZE ;\n }\n }\n for ( ch = 0 ;\n ch < s -> out_channels ;\n ch ++ ) memcpy ( s -> output [ ch ] , output [ ch ] , 1024 ) ;\n * got_frame_ptr = 1 ;\n return FFMIN ( buf_size , s -> frame_size ) ;\n }",
        "hash": 3071315158823512715,
        "project": "debian",
        "size": 113,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int ac3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    5,
                    " AC3DecodeContext * s = avctx -> priv_data ;\n"
                ],
                [
                    8,
                    " const float * output [ AC3_MAX_CHANNELS ] ;\n"
                ],
                [
                    9,
                    " if ( buf_size >= 2 && AV_RB16 ( buf ) == 0x770B ) {\n"
                ],
                [
                    13,
                    " else memcpy ( s -> input_buffer , buf , FFMIN ( buf_size , AC3_FRAME_BUFFER_SIZE ) ) ;\n"
                ],
                [
                    14,
                    " buf = s -> input_buffer ;\n"
                ],
                [
                    16,
                    " err = parse_frame_header ( s ) ;\n"
                ],
                [
                    68,
                    " set_downmix_coeffs ( s ) ;\n"
                ],
                [
                    87,
                    " if ( ch < s -> out_channels ) s -> outptr [ channel_map [ ch ] ] = ( float * ) frame -> data [ ch ] ;\n"
                ],
                [
                    89,
                    " output [ ch ] = s -> output [ ch ] ;\n"
                ],
                [
                    94,
                    " if ( ! err && decode_audio_block ( s , blk ) ) {\n"
                ],
                [
                    99,
                    " ch < s -> out_channels ;\n"
                ],
                [
                    100,
                    " ch ++ ) memcpy ( s -> outptr [ channel_map [ ch ] ] , output [ ch ] , 1024 ) ;\n"
                ],
                [
                    104,
                    " output [ ch ] = s -> outptr [ channel_map [ ch ] ] ;\n"
                ],
                [
                    105,
                    " s -> outptr [ channel_map [ ch ] ] += AC3_BLOCK_SIZE ;\n"
                ],
                [
                    109,
                    " ch < s -> out_channels ;\n"
                ],
                [
                    110,
                    " ch ++ ) memcpy ( s -> output [ ch ] , output [ ch ] , 1024 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ac3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    5,
                    " AC3DecodeContext * s = avctx -> priv_data ;\n"
                ],
                [
                    8,
                    " const float * output [ AC3_MAX_CHANNELS ] ;\n"
                ],
                [
                    9,
                    " if ( buf_size >= 2 && AV_RB16 ( buf ) == 0x770B ) {\n"
                ],
                [
                    13,
                    " else memcpy ( s -> input_buffer , buf , FFMIN ( buf_size , AC3_FRAME_BUFFER_SIZE ) ) ;\n"
                ],
                [
                    14,
                    " buf = s -> input_buffer ;\n"
                ],
                [
                    16,
                    " err = parse_frame_header ( s ) ;\n"
                ],
                [
                    68,
                    " set_downmix_coeffs ( s ) ;\n"
                ],
                [
                    87,
                    " if ( ch < s -> out_channels ) s -> outptr [ channel_map [ ch ] ] = ( float * ) frame -> data [ ch ] ;\n"
                ],
                [
                    89,
                    " output [ ch ] = s -> output [ ch ] ;\n"
                ],
                [
                    94,
                    " if ( ! err && decode_audio_block ( s , blk ) ) {\n"
                ],
                [
                    99,
                    " ch < s -> out_channels ;\n"
                ],
                [
                    100,
                    " ch ++ ) memcpy ( s -> outptr [ channel_map [ ch ] ] , output [ ch ] , 1024 ) ;\n"
                ],
                [
                    104,
                    " output [ ch ] = s -> outptr [ channel_map [ ch ] ] ;\n"
                ],
                [
                    105,
                    " s -> outptr [ channel_map [ ch ] ] += AC3_BLOCK_SIZE ;\n"
                ],
                [
                    109,
                    " ch < s -> out_channels ;\n"
                ],
                [
                    110,
                    " ch ++ ) memcpy ( s -> output [ ch ] , output [ ch ] , 1024 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ff_h264_execute_ref_pic_marking ( H264Context * h , MMCO * mmco , int mmco_count ) {\n int i , av_uninit ( j ) ;\n int current_ref_assigned = 0 , err = 0 ;\n Picture * av_uninit ( pic ) ;\n if ( ( h -> avctx -> debug & FF_DEBUG_MMCO ) && mmco_count == 0 ) av_log ( h -> avctx , AV_LOG_DEBUG , \"no mmco here\\n\" ) ;\n for ( i = 0 ;\n i < mmco_count ;\n i ++ ) {\n int av_uninit ( structure ) , av_uninit ( frame_num ) ;\n if ( h -> avctx -> debug & FF_DEBUG_MMCO ) av_log ( h -> avctx , AV_LOG_DEBUG , \"mmco:%d %d %d\\n\" , h -> mmco [ i ] . opcode , h -> mmco [ i ] . short_pic_num , h -> mmco [ i ] . long_arg ) ;\n if ( mmco [ i ] . opcode == MMCO_SHORT2UNUSED || mmco [ i ] . opcode == MMCO_SHORT2LONG ) {\n frame_num = pic_num_extract ( h , mmco [ i ] . short_pic_num , & structure ) ;\n pic = find_short ( h , frame_num , & j ) ;\n if ( ! pic ) {\n if ( mmco [ i ] . opcode != MMCO_SHORT2LONG || ! h -> long_ref [ mmco [ i ] . long_arg ] || h -> long_ref [ mmco [ i ] . long_arg ] -> frame_num != frame_num ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"mmco: unref short failure\\n\" ) ;\n err = AVERROR_INVALIDDATA ;\n }\n continue ;\n }\n }\n switch ( mmco [ i ] . opcode ) {\n case MMCO_SHORT2UNUSED : if ( h -> avctx -> debug & FF_DEBUG_MMCO ) av_log ( h -> avctx , AV_LOG_DEBUG , \"mmco: unref short %d count %d\\n\" , h -> mmco [ i ] . short_pic_num , h -> short_ref_count ) ;\n remove_short ( h , frame_num , structure ^ PICT_FRAME ) ;\n break ;\n case MMCO_SHORT2LONG : if ( h -> long_ref [ mmco [ i ] . long_arg ] != pic ) remove_long ( h , mmco [ i ] . long_arg , 0 ) ;\n remove_short_at_index ( h , j ) ;\n h -> long_ref [ mmco [ i ] . long_arg ] = pic ;\n if ( h -> long_ref [ mmco [ i ] . long_arg ] ) {\n h -> long_ref [ mmco [ i ] . long_arg ] -> long_ref = 1 ;\n h -> long_ref_count ++ ;\n }\n break ;\n case MMCO_LONG2UNUSED : j = pic_num_extract ( h , mmco [ i ] . long_arg , & structure ) ;\n pic = h -> long_ref [ j ] ;\n if ( pic ) {\n remove_long ( h , j , structure ^ PICT_FRAME ) ;\n }\n else if ( h -> avctx -> debug & FF_DEBUG_MMCO ) av_log ( h -> avctx , AV_LOG_DEBUG , \"mmco: unref long failure\\n\" ) ;\n break ;\n case MMCO_LONG : if ( h -> long_ref [ mmco [ i ] . long_arg ] != h -> cur_pic_ptr ) {\n remove_long ( h , mmco [ i ] . long_arg , 0 ) ;\n h -> long_ref [ mmco [ i ] . long_arg ] = h -> cur_pic_ptr ;\n h -> long_ref [ mmco [ i ] . long_arg ] -> long_ref = 1 ;\n h -> long_ref_count ++ ;\n }\n h -> cur_pic_ptr -> f . reference |= h -> picture_structure ;\n current_ref_assigned = 1 ;\n break ;\n case MMCO_SET_MAX_LONG : assert ( mmco [ i ] . long_arg <= 16 ) ;\n for ( j = mmco [ i ] . long_arg ;\n j < 16 ;\n j ++ ) {\n remove_long ( h , j , 0 ) ;\n }\n break ;\n case MMCO_RESET : while ( h -> short_ref_count ) {\n remove_short ( h , h -> short_ref [ 0 ] -> frame_num , 0 ) ;\n }\n for ( j = 0 ;\n j < 16 ;\n j ++ ) {\n remove_long ( h , j , 0 ) ;\n }\n h -> frame_num = h -> cur_pic_ptr -> frame_num = 0 ;\n h -> mmco_reset = 1 ;\n h -> cur_pic_ptr -> mmco_reset = 1 ;\n break ;\n default : assert ( 0 ) ;\n }\n }\n if ( ! current_ref_assigned ) {\n if ( h -> short_ref_count && h -> short_ref [ 0 ] == h -> cur_pic_ptr ) {\n h -> cur_pic_ptr -> f . reference = PICT_FRAME ;\n }\n else if ( h -> cur_pic_ptr -> long_ref ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"illegal short term reference \" \"assignment for second field \" \"in complementary field pair \" \"(first field is long term)\\n\" ) ;\n err = AVERROR_INVALIDDATA ;\n }\n else {\n pic = remove_short ( h , h -> cur_pic_ptr -> frame_num , 0 ) ;\n if ( pic ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"illegal short term buffer state detected\\n\" ) ;\n err = AVERROR_INVALIDDATA ;\n }\n if ( h -> short_ref_count ) memmove ( & h -> short_ref [ 1 ] , & h -> short_ref [ 0 ] , h -> short_ref_count * sizeof ( Picture * ) ) ;\n h -> short_ref [ 0 ] = h -> cur_pic_ptr ;\n h -> short_ref_count ++ ;\n h -> cur_pic_ptr -> f . reference |= h -> picture_structure ;\n }\n }\n if ( h -> long_ref_count + h -> short_ref_count - ( h -> short_ref [ 0 ] == h -> cur_pic_ptr ) > h -> sps . ref_frame_count ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"number of reference frames (%d+%d) exceeds max (%d;\n probably \" \"corrupt input), discarding one\\n\" , h -> long_ref_count , h -> short_ref_count , h -> sps . ref_frame_count ) ;\n err = AVERROR_INVALIDDATA ;\n if ( h -> long_ref_count && ! h -> short_ref_count ) {\n for ( i = 0 ;\n i < 16 ;\n ++ i ) if ( h -> long_ref [ i ] ) break ;\n assert ( i < 16 ) ;\n remove_long ( h , i , 0 ) ;\n }\n else {\n pic = h -> short_ref [ h -> short_ref_count - 1 ] ;\n remove_short ( h , pic -> frame_num , 0 ) ;\n }\n }\n print_short_term ( h ) ;\n print_long_term ( h ) ;\n return ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ? err : 0 ;\n }",
        "hash": -1658505547857059267,
        "project": "debian",
        "size": 111,
        "slice": {
            "memmove": [
                [
                    1,
                    "int ff_h264_execute_ref_pic_marking ( H264Context * h , MMCO * mmco , int mmco_count ) {\n"
                ],
                [
                    58,
                    " remove_short ( h , h -> short_ref [ 0 ] -> frame_num , 0 ) ;\n"
                ],
                [
                    73,
                    " if ( h -> short_ref_count && h -> short_ref [ 0 ] == h -> cur_pic_ptr ) {\n"
                ],
                [
                    86,
                    " if ( h -> short_ref_count ) memmove ( & h -> short_ref [ 1 ] , & h -> short_ref [ 0 ] , h -> short_ref_count * sizeof ( Picture * ) ) ;\n"
                ],
                [
                    92,
                    " if ( h -> long_ref_count + h -> short_ref_count - ( h -> short_ref [ 0 ] == h -> cur_pic_ptr ) > h -> sps . ref_frame_count ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ff_h264_execute_ref_pic_marking ( H264Context * h , MMCO * mmco , int mmco_count ) {\n"
                ],
                [
                    58,
                    " remove_short ( h , h -> short_ref [ 0 ] -> frame_num , 0 ) ;\n"
                ],
                [
                    73,
                    " if ( h -> short_ref_count && h -> short_ref [ 0 ] == h -> cur_pic_ptr ) {\n"
                ],
                [
                    86,
                    " if ( h -> short_ref_count ) memmove ( & h -> short_ref [ 1 ] , & h -> short_ref [ 0 ] , h -> short_ref_count * sizeof ( Picture * ) ) ;\n"
                ],
                [
                    92,
                    " if ( h -> long_ref_count + h -> short_ref_count - ( h -> short_ref [ 0 ] == h -> cur_pic_ptr ) > h -> sps . ref_frame_count ) {\n"
                ]
            ]
        }
    },
    {
        "code": "int ff_h264_decode_ref_pic_list_reordering ( H264Context * h ) {\n int list , index , pic_structure ;\n print_short_term ( h ) ;\n print_long_term ( h ) ;\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n memcpy ( h -> ref_list [ list ] , h -> default_ref_list [ list ] , sizeof ( Picture ) * h -> ref_count [ list ] ) ;\n if ( get_bits1 ( & h -> gb ) ) {\n int pred = h -> curr_pic_num ;\n for ( index = 0 ;\n ;\n index ++ ) {\n unsigned int reordering_of_pic_nums_idc = get_ue_golomb_31 ( & h -> gb ) ;\n unsigned int pic_id ;\n int i ;\n Picture * ref = NULL ;\n if ( reordering_of_pic_nums_idc == 3 ) break ;\n if ( index >= h -> ref_count [ list ] ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"reference count overflow\\n\" ) ;\n return - 1 ;\n }\n if ( reordering_of_pic_nums_idc < 3 ) {\n if ( reordering_of_pic_nums_idc < 2 ) {\n const unsigned int abs_diff_pic_num = get_ue_golomb ( & h -> gb ) + 1 ;\n int frame_num ;\n if ( abs_diff_pic_num > h -> max_pic_num ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"abs_diff_pic_num overflow\\n\" ) ;\n return - 1 ;\n }\n if ( reordering_of_pic_nums_idc == 0 ) pred -= abs_diff_pic_num ;\n else pred += abs_diff_pic_num ;\n pred &= h -> max_pic_num - 1 ;\n frame_num = pic_num_extract ( h , pred , & pic_structure ) ;\n for ( i = h -> short_ref_count - 1 ;\n i >= 0 ;\n i -- ) {\n ref = h -> short_ref [ i ] ;\n assert ( ref -> f . reference ) ;\n assert ( ! ref -> long_ref ) ;\n if ( ref -> frame_num == frame_num && ( ref -> f . reference & pic_structure ) ) break ;\n }\n if ( i >= 0 ) ref -> pic_id = pred ;\n }\n else {\n int long_idx ;\n pic_id = get_ue_golomb ( & h -> gb ) ;\n long_idx = pic_num_extract ( h , pic_id , & pic_structure ) ;\n if ( long_idx > 31 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"long_term_pic_idx overflow\\n\" ) ;\n return - 1 ;\n }\n ref = h -> long_ref [ long_idx ] ;\n assert ( ! ( ref && ! ref -> f . reference ) ) ;\n if ( ref && ( ref -> f . reference & pic_structure ) ) {\n ref -> pic_id = pic_id ;\n assert ( ref -> long_ref ) ;\n i = 0 ;\n }\n else {\n i = - 1 ;\n }\n }\n if ( i < 0 ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"reference picture missing during reorder\\n\" ) ;\n memset ( & h -> ref_list [ list ] [ index ] , 0 , sizeof ( Picture ) ) ;\n }\n else {\n for ( i = index ;\n i + 1 < h -> ref_count [ list ] ;\n i ++ ) {\n if ( ref -> long_ref == h -> ref_list [ list ] [ i ] . long_ref && ref -> pic_id == h -> ref_list [ list ] [ i ] . pic_id ) break ;\n }\n for ( ;\n i > index ;\n i -- ) {\n h -> ref_list [ list ] [ i ] = h -> ref_list [ list ] [ i - 1 ] ;\n }\n h -> ref_list [ list ] [ index ] = * ref ;\n if ( FIELD_PICTURE ) {\n pic_as_field ( & h -> ref_list [ list ] [ index ] , pic_structure ) ;\n }\n }\n }\n else {\n av_log ( h -> avctx , AV_LOG_ERROR , \"illegal reordering_of_pic_nums_idc\\n\" ) ;\n return - 1 ;\n }\n }\n }\n }\n for ( list = 0 ;\n list < h -> list_count ;\n list ++ ) {\n for ( index = 0 ;\n index < h -> ref_count [ list ] ;\n index ++ ) {\n if ( ! h -> ref_list [ list ] [ index ] . f . data [ 0 ] ) {\n av_log ( h -> avctx , AV_LOG_ERROR , \"Missing reference picture\\n\" ) ;\n if ( h -> default_ref_list [ list ] [ 0 ] . f . data [ 0 ] ) h -> ref_list [ list ] [ index ] = h -> default_ref_list [ list ] [ 0 ] ;\n else return - 1 ;\n }\n }\n }\n return 0 ;\n }",
        "hash": -1658505547857059267,
        "project": "debian",
        "size": 106,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int ff_h264_decode_ref_pic_list_reordering ( H264Context * h ) {\n"
                ],
                [
                    6,
                    " list < h -> list_count ;\n"
                ],
                [
                    8,
                    " memcpy ( h -> ref_list [ list ] , h -> default_ref_list [ list ] , sizeof ( Picture ) * h -> ref_count [ list ] ) ;\n"
                ],
                [
                    66,
                    " memset ( & h -> ref_list [ list ] [ index ] , 0 , sizeof ( Picture ) ) ;\n"
                ],
                [
                    77,
                    " h -> ref_list [ list ] [ i ] = h -> ref_list [ list ] [ i - 1 ] ;\n"
                ],
                [
                    79,
                    " h -> ref_list [ list ] [ index ] = * ref ;\n"
                ],
                [
                    81,
                    " pic_as_field ( & h -> ref_list [ list ] [ index ] , pic_structure ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int ff_h264_decode_ref_pic_list_reordering ( H264Context * h ) {\n"
                ],
                [
                    8,
                    " memcpy ( h -> ref_list [ list ] , h -> default_ref_list [ list ] , sizeof ( Picture ) * h -> ref_count [ list ] ) ;\n"
                ],
                [
                    64,
                    " if ( i < 0 ) {\n"
                ],
                [
                    66,
                    " memset ( & h -> ref_list [ list ] [ index ] , 0 , sizeof ( Picture ) ) ;\n"
                ],
                [
                    79,
                    " h -> ref_list [ list ] [ index ] = * ref ;\n"
                ],
                [
                    81,
                    " pic_as_field ( & h -> ref_list [ list ] [ index ] , pic_structure ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ff_h264_decode_ref_pic_list_reordering ( H264Context * h ) {\n"
                ],
                [
                    6,
                    " list < h -> list_count ;\n"
                ],
                [
                    8,
                    " memcpy ( h -> ref_list [ list ] , h -> default_ref_list [ list ] , sizeof ( Picture ) * h -> ref_count [ list ] ) ;\n"
                ],
                [
                    64,
                    " if ( i < 0 ) {\n"
                ],
                [
                    66,
                    " memset ( & h -> ref_list [ list ] [ index ] , 0 , sizeof ( Picture ) ) ;\n"
                ],
                [
                    77,
                    " h -> ref_list [ list ] [ i ] = h -> ref_list [ list ] [ i - 1 ] ;\n"
                ],
                [
                    79,
                    " h -> ref_list [ list ] [ index ] = * ref ;\n"
                ],
                [
                    81,
                    " pic_as_field ( & h -> ref_list [ list ] [ index ] , pic_structure ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ff_h264_fill_default_ref_list ( H264Context * h ) {\n int i , len ;\n if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) {\n Picture * sorted [ 32 ] ;\n int cur_poc , list ;\n int lens [ 2 ] ;\n if ( FIELD_PICTURE ) cur_poc = h -> cur_pic_ptr -> field_poc [ h -> picture_structure == PICT_BOTTOM_FIELD ] ;\n else cur_poc = h -> cur_pic_ptr -> poc ;\n for ( list = 0 ;\n list < 2 ;\n list ++ ) {\n len = add_sorted ( sorted , h -> short_ref , h -> short_ref_count , cur_poc , 1 ^ list ) ;\n len += add_sorted ( sorted + len , h -> short_ref , h -> short_ref_count , cur_poc , 0 ^ list ) ;\n assert ( len <= 32 ) ;\n len = build_def_list ( h -> default_ref_list [ list ] , sorted , len , 0 , h -> picture_structure ) ;\n len += build_def_list ( h -> default_ref_list [ list ] + len , h -> long_ref , 16 , 1 , h -> picture_structure ) ;\n assert ( len <= 32 ) ;\n if ( len < h -> ref_count [ list ] ) memset ( & h -> default_ref_list [ list ] [ len ] , 0 , sizeof ( Picture ) * ( h -> ref_count [ list ] - len ) ) ;\n lens [ list ] = len ;\n }\n if ( lens [ 0 ] == lens [ 1 ] && lens [ 1 ] > 1 ) {\n for ( i = 0 ;\n h -> default_ref_list [ 0 ] [ i ] . f . data [ 0 ] == h -> default_ref_list [ 1 ] [ i ] . f . data [ 0 ] && i < lens [ 0 ] ;\n i ++ ) ;\n if ( i == lens [ 0 ] ) FFSWAP ( Picture , h -> default_ref_list [ 1 ] [ 0 ] , h -> default_ref_list [ 1 ] [ 1 ] ) ;\n }\n }\n else {\n len = build_def_list ( h -> default_ref_list [ 0 ] , h -> short_ref , h -> short_ref_count , 0 , h -> picture_structure ) ;\n len += build_def_list ( h -> default_ref_list [ 0 ] + len , h -> long_ref , 16 , 1 , h -> picture_structure ) ;\n assert ( len <= 32 ) ;\n if ( len < h -> ref_count [ 0 ] ) memset ( & h -> default_ref_list [ 0 ] [ len ] , 0 , sizeof ( Picture ) * ( h -> ref_count [ 0 ] - len ) ) ;\n }\n # ifdef TRACE for ( i = 0 ;\n i < h -> ref_count [ 0 ] ;\n i ++ ) {\n tprintf ( h -> avctx , \"List0: %s fn:%d 0x%p\\n\" , ( h -> default_ref_list [ 0 ] [ i ] . long_ref ? \"LT\" : \"ST\" ) , h -> default_ref_list [ 0 ] [ i ] . pic_id , h -> default_ref_list [ 0 ] [ i ] . f . data [ 0 ] ) ;\n }\n if ( h -> slice_type_nos == AV_PICTURE_TYPE_B ) {\n for ( i = 0 ;\n i < h -> ref_count [ 1 ] ;\n i ++ ) {\n tprintf ( h -> avctx , \"List1: %s fn:%d 0x%p\\n\" , ( h -> default_ref_list [ 1 ] [ i ] . long_ref ? \"LT\" : \"ST\" ) , h -> default_ref_list [ 1 ] [ i ] . pic_id , h -> default_ref_list [ 1 ] [ i ] . f . data [ 0 ] ) ;\n }\n }\n # endif return 0 ;\n }",
        "hash": -1658505547857059267,
        "project": "debian",
        "size": 47,
        "slice": {
            "memset": [
                [
                    1,
                    "int ff_h264_fill_default_ref_list ( H264Context * h ) {\n"
                ],
                [
                    15,
                    " len = build_def_list ( h -> default_ref_list [ list ] , sorted , len , 0 , h -> picture_structure ) ;\n"
                ],
                [
                    16,
                    " len += build_def_list ( h -> default_ref_list [ list ] + len , h -> long_ref , 16 , 1 , h -> picture_structure ) ;\n"
                ],
                [
                    18,
                    " if ( len < h -> ref_count [ list ] ) memset ( & h -> default_ref_list [ list ] [ len ] , 0 , sizeof ( Picture ) * ( h -> ref_count [ list ] - len ) ) ;\n"
                ],
                [
                    29,
                    " len = build_def_list ( h -> default_ref_list [ 0 ] , h -> short_ref , h -> short_ref_count , 0 , h -> picture_structure ) ;\n"
                ],
                [
                    32,
                    " if ( len < h -> ref_count [ 0 ] ) memset ( & h -> default_ref_list [ 0 ] [ len ] , 0 , sizeof ( Picture ) * ( h -> ref_count [ 0 ] - len ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ff_h264_fill_default_ref_list ( H264Context * h ) {\n"
                ],
                [
                    15,
                    " len = build_def_list ( h -> default_ref_list [ list ] , sorted , len , 0 , h -> picture_structure ) ;\n"
                ],
                [
                    16,
                    " len += build_def_list ( h -> default_ref_list [ list ] + len , h -> long_ref , 16 , 1 , h -> picture_structure ) ;\n"
                ],
                [
                    18,
                    " if ( len < h -> ref_count [ list ] ) memset ( & h -> default_ref_list [ list ] [ len ] , 0 , sizeof ( Picture ) * ( h -> ref_count [ list ] - len ) ) ;\n"
                ],
                [
                    29,
                    " len = build_def_list ( h -> default_ref_list [ 0 ] , h -> short_ref , h -> short_ref_count , 0 , h -> picture_structure ) ;\n"
                ],
                [
                    32,
                    " if ( len < h -> ref_count [ 0 ] ) memset ( & h -> default_ref_list [ 0 ] [ len ] , 0 , sizeof ( Picture ) * ( h -> ref_count [ 0 ] - len ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n KmvcContext * const ctx = avctx -> priv_data ;\n uint8_t * out , * src ;\n int i , ret ;\n int header ;\n int blocksize ;\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n bytestream2_init ( & ctx -> g , avpkt -> data , avpkt -> size ) ;\n if ( ctx -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & ctx -> pic ) ;\n ctx -> pic . reference = 1 ;\n ctx -> pic . buffer_hints = FF_BUFFER_HINTS_VALID ;\n if ( ( ret = ff_get_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n header = bytestream2_get_byte ( & ctx -> g ) ;\n if ( bytestream2_peek_byte ( & ctx -> g ) == 127 ) {\n bytestream2_skip ( & ctx -> g , 3 ) ;\n for ( i = 0 ;\n i < 127 ;\n i ++ ) {\n ctx -> pal [ i + ( header & 0x81 ) ] = bytestream2_get_be24 ( & ctx -> g ) ;\n bytestream2_skip ( & ctx -> g , 1 ) ;\n }\n bytestream2_seek ( & ctx -> g , - 127 * 4 - 3 , SEEK_CUR ) ;\n }\n if ( header & KMVC_KEYFRAME ) {\n ctx -> pic . key_frame = 1 ;\n ctx -> pic . pict_type = AV_PICTURE_TYPE_I ;\n }\n else {\n ctx -> pic . key_frame = 0 ;\n ctx -> pic . pict_type = AV_PICTURE_TYPE_P ;\n }\n if ( header & KMVC_PALETTE ) {\n ctx -> pic . palette_has_changed = 1 ;\n for ( i = 1 ;\n i <= ctx -> palsize ;\n i ++ ) {\n ctx -> pal [ i ] = bytestream2_get_be24 ( & ctx -> g ) ;\n }\n }\n if ( pal ) {\n ctx -> pic . palette_has_changed = 1 ;\n memcpy ( ctx -> pal , pal , AVPALETTE_SIZE ) ;\n }\n if ( ctx -> setpal ) {\n ctx -> setpal = 0 ;\n ctx -> pic . palette_has_changed = 1 ;\n }\n memcpy ( ctx -> pic . data [ 1 ] , ctx -> pal , 1024 ) ;\n blocksize = bytestream2_get_byte ( & ctx -> g ) ;\n if ( blocksize != 8 && blocksize != 127 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Block size = %i\\n\" , blocksize ) ;\n return AVERROR_INVALIDDATA ;\n }\n memset ( ctx -> cur , 0 , 320 * 200 ) ;\n switch ( header & KMVC_METHOD ) {\n case 0 : case 1 : memcpy ( ctx -> cur , ctx -> prev , 320 * 200 ) ;\n break ;\n case 3 : kmvc_decode_intra_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n break ;\n case 4 : kmvc_decode_inter_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unknown compression method %i\\n\" , header & KMVC_METHOD ) ;\n return AVERROR_INVALIDDATA ;\n }\n out = ctx -> pic . data [ 0 ] ;\n src = ctx -> cur ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n memcpy ( out , src , avctx -> width ) ;\n src += 320 ;\n out += ctx -> pic . linesize [ 0 ] ;\n }\n if ( ctx -> cur == ctx -> frm0 ) {\n ctx -> cur = ctx -> frm1 ;\n ctx -> prev = ctx -> frm0 ;\n }\n else {\n ctx -> cur = ctx -> frm0 ;\n ctx -> prev = ctx -> frm1 ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = ctx -> pic ;\n return avpkt -> size ;\n }",
        "hash": 2387725018197272228,
        "project": "debian",
        "size": 88,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " KmvcContext * const ctx = avctx -> priv_data ;\n"
                ],
                [
                    7,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    12,
                    " if ( ( ret = ff_get_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n"
                ],
                [
                    22,
                    " ctx -> pal [ i + ( header & 0x81 ) ] = bytestream2_get_be24 ( & ctx -> g ) ;\n"
                ],
                [
                    40,
                    " ctx -> pal [ i ] = bytestream2_get_be24 ( & ctx -> g ) ;\n"
                ],
                [
                    43,
                    " if ( pal ) {\n"
                ],
                [
                    45,
                    " memcpy ( ctx -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    51,
                    " memcpy ( ctx -> pic . data [ 1 ] , ctx -> pal , 1024 ) ;\n"
                ],
                [
                    57,
                    " memset ( ctx -> cur , 0 , 320 * 200 ) ;\n"
                ],
                [
                    58,
                    " switch ( header & KMVC_METHOD ) {\n"
                ],
                [
                    59,
                    " case 0 : case 1 : memcpy ( ctx -> cur , ctx -> prev , 320 * 200 ) ;\n"
                ],
                [
                    61,
                    " case 3 : kmvc_decode_intra_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n"
                ],
                [
                    63,
                    " case 4 : kmvc_decode_inter_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n"
                ],
                [
                    68,
                    " out = ctx -> pic . data [ 0 ] ;\n"
                ],
                [
                    69,
                    " src = ctx -> cur ;\n"
                ],
                [
                    71,
                    " i < avctx -> height ;\n"
                ],
                [
                    73,
                    " memcpy ( out , src , avctx -> width ) ;\n"
                ],
                [
                    74,
                    " src += 320 ;\n"
                ],
                [
                    75,
                    " out += ctx -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    77,
                    " if ( ctx -> cur == ctx -> frm0 ) {\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " KmvcContext * const ctx = avctx -> priv_data ;\n"
                ],
                [
                    53,
                    " if ( blocksize != 8 && blocksize != 127 ) {\n"
                ],
                [
                    57,
                    " memset ( ctx -> cur , 0 , 320 * 200 ) ;\n"
                ],
                [
                    59,
                    " case 0 : case 1 : memcpy ( ctx -> cur , ctx -> prev , 320 * 200 ) ;\n"
                ],
                [
                    61,
                    " case 3 : kmvc_decode_intra_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n"
                ],
                [
                    63,
                    " case 4 : kmvc_decode_inter_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n"
                ],
                [
                    69,
                    " src = ctx -> cur ;\n"
                ],
                [
                    77,
                    " if ( ctx -> cur == ctx -> frm0 ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " KmvcContext * const ctx = avctx -> priv_data ;\n"
                ],
                [
                    7,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    12,
                    " if ( ( ret = ff_get_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n"
                ],
                [
                    22,
                    " ctx -> pal [ i + ( header & 0x81 ) ] = bytestream2_get_be24 ( & ctx -> g ) ;\n"
                ],
                [
                    40,
                    " ctx -> pal [ i ] = bytestream2_get_be24 ( & ctx -> g ) ;\n"
                ],
                [
                    43,
                    " if ( pal ) {\n"
                ],
                [
                    45,
                    " memcpy ( ctx -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    51,
                    " memcpy ( ctx -> pic . data [ 1 ] , ctx -> pal , 1024 ) ;\n"
                ],
                [
                    53,
                    " if ( blocksize != 8 && blocksize != 127 ) {\n"
                ],
                [
                    57,
                    " memset ( ctx -> cur , 0 , 320 * 200 ) ;\n"
                ],
                [
                    58,
                    " switch ( header & KMVC_METHOD ) {\n"
                ],
                [
                    59,
                    " case 0 : case 1 : memcpy ( ctx -> cur , ctx -> prev , 320 * 200 ) ;\n"
                ],
                [
                    61,
                    " case 3 : kmvc_decode_intra_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n"
                ],
                [
                    63,
                    " case 4 : kmvc_decode_inter_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n"
                ],
                [
                    68,
                    " out = ctx -> pic . data [ 0 ] ;\n"
                ],
                [
                    69,
                    " src = ctx -> cur ;\n"
                ],
                [
                    71,
                    " i < avctx -> height ;\n"
                ],
                [
                    73,
                    " memcpy ( out , src , avctx -> width ) ;\n"
                ],
                [
                    74,
                    " src += 320 ;\n"
                ],
                [
                    75,
                    " out += ctx -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    77,
                    " if ( ctx -> cur == ctx -> frm0 ) {\n"
                ]
            ]
        }
    },
    {
        "code": "void ff_vdpau_h264_picture_complete ( H264Context * h ) {\n struct vdpau_render_state * render ;\n render = ( struct vdpau_render_state * ) h -> cur_pic_ptr -> f . data [ 0 ] ;\n assert ( render ) ;\n render -> info . h264 . slice_count = h -> slice_num ;\n if ( render -> info . h264 . slice_count < 1 ) return ;\n render -> info . h264 . is_reference = ( h -> cur_pic_ptr -> f . reference & 3 ) ? VDP_TRUE : VDP_FALSE ;\n render -> info . h264 . field_pic_flag = h -> picture_structure != PICT_FRAME ;\n render -> info . h264 . bottom_field_flag = h -> picture_structure == PICT_BOTTOM_FIELD ;\n render -> info . h264 . num_ref_frames = h -> sps . ref_frame_count ;\n render -> info . h264 . mb_adaptive_frame_field_flag = h -> sps . mb_aff && ! render -> info . h264 . field_pic_flag ;\n render -> info . h264 . constrained_intra_pred_flag = h -> pps . constrained_intra_pred ;\n render -> info . h264 . weighted_pred_flag = h -> pps . weighted_pred ;\n render -> info . h264 . weighted_bipred_idc = h -> pps . weighted_bipred_idc ;\n render -> info . h264 . frame_mbs_only_flag = h -> sps . frame_mbs_only_flag ;\n render -> info . h264 . transform_8x8_mode_flag = h -> pps . transform_8x8_mode ;\n render -> info . h264 . chroma_qp_index_offset = h -> pps . chroma_qp_index_offset [ 0 ] ;\n render -> info . h264 . second_chroma_qp_index_offset = h -> pps . chroma_qp_index_offset [ 1 ] ;\n render -> info . h264 . pic_init_qp_minus26 = h -> pps . init_qp - 26 ;\n render -> info . h264 . num_ref_idx_l0_active_minus1 = h -> pps . ref_count [ 0 ] - 1 ;\n render -> info . h264 . num_ref_idx_l1_active_minus1 = h -> pps . ref_count [ 1 ] - 1 ;\n render -> info . h264 . log2_max_frame_num_minus4 = h -> sps . log2_max_frame_num - 4 ;\n render -> info . h264 . pic_order_cnt_type = h -> sps . poc_type ;\n render -> info . h264 . log2_max_pic_order_cnt_lsb_minus4 = h -> sps . poc_type ? 0 : h -> sps . log2_max_poc_lsb - 4 ;\n render -> info . h264 . delta_pic_order_always_zero_flag = h -> sps . delta_pic_order_always_zero_flag ;\n render -> info . h264 . direct_8x8_inference_flag = h -> sps . direct_8x8_inference_flag ;\n render -> info . h264 . entropy_coding_mode_flag = h -> pps . cabac ;\n render -> info . h264 . pic_order_present_flag = h -> pps . pic_order_present ;\n render -> info . h264 . deblocking_filter_control_present_flag = h -> pps . deblocking_filter_parameters_present ;\n render -> info . h264 . redundant_pic_cnt_present_flag = h -> pps . redundant_pic_cnt_present ;\n memcpy ( render -> info . h264 . scaling_lists_4x4 , h -> pps . scaling_matrix4 , sizeof ( render -> info . h264 . scaling_lists_4x4 ) ) ;\n memcpy ( render -> info . h264 . scaling_lists_8x8 [ 0 ] , h -> pps . scaling_matrix8 [ 0 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;\n memcpy ( render -> info . h264 . scaling_lists_8x8 [ 1 ] , h -> pps . scaling_matrix8 [ 3 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;\n ff_h264_draw_horiz_band ( h , 0 , h -> avctx -> height ) ;\n render -> bitstream_buffers_used = 0 ;\n }",
        "hash": -7468702064548611268,
        "project": "debian",
        "size": 36,
        "slice": {
            "memcpy": [
                [
                    6,
                    " if ( render -> info . h264 . slice_count < 1 ) return ;\n"
                ],
                [
                    31,
                    " memcpy ( render -> info . h264 . scaling_lists_4x4 , h -> pps . scaling_matrix4 , sizeof ( render -> info . h264 . scaling_lists_4x4 ) ) ;\n"
                ],
                [
                    32,
                    " memcpy ( render -> info . h264 . scaling_lists_8x8 [ 0 ] , h -> pps . scaling_matrix8 [ 0 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;\n"
                ],
                [
                    33,
                    " memcpy ( render -> info . h264 . scaling_lists_8x8 [ 1 ] , h -> pps . scaling_matrix8 [ 3 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    6,
                    " if ( render -> info . h264 . slice_count < 1 ) return ;\n"
                ],
                [
                    31,
                    " memcpy ( render -> info . h264 . scaling_lists_4x4 , h -> pps . scaling_matrix4 , sizeof ( render -> info . h264 . scaling_lists_4x4 ) ) ;\n"
                ],
                [
                    32,
                    " memcpy ( render -> info . h264 . scaling_lists_8x8 [ 0 ] , h -> pps . scaling_matrix8 [ 0 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;\n"
                ],
                [
                    33,
                    " memcpy ( render -> info . h264 . scaling_lists_8x8 [ 1 ] , h -> pps . scaling_matrix8 [ 3 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void fill_colmap ( H264Context * h , int map [ 2 ] [ 16 + 32 ] , int list , int field , int colfield , int mbafi ) {\n Picture * const ref1 = & h -> ref_list [ 1 ] [ 0 ] ;\n int j , old_ref , rfield ;\n int start = mbafi ? 16 : 0 ;\n int end = mbafi ? 16 + 2 * h -> ref_count [ 0 ] : h -> ref_count [ 0 ] ;\n int interl = mbafi || h -> picture_structure != PICT_FRAME ;\n memset ( map [ list ] , 0 , sizeof ( map [ list ] ) ) ;\n for ( rfield = 0 ;\n rfield < 2 ;\n rfield ++ ) {\n for ( old_ref = 0 ;\n old_ref < ref1 -> ref_count [ colfield ] [ list ] ;\n old_ref ++ ) {\n int poc = ref1 -> ref_poc [ colfield ] [ list ] [ old_ref ] ;\n if ( ! interl ) poc |= 3 ;\n else if ( interl && ( poc & 3 ) == 3 ) poc = ( poc & ~ 3 ) + rfield + 1 ;\n for ( j = start ;\n j < end ;\n j ++ ) {\n if ( 4 * h -> ref_list [ 0 ] [ j ] . frame_num + ( h -> ref_list [ 0 ] [ j ] . f . reference & 3 ) == poc ) {\n int cur_ref = mbafi ? ( j - 16 ) ^ field : j ;\n if ( ref1 -> mbaff ) map [ list ] [ 2 * old_ref + ( rfield ^ field ) + 16 ] = cur_ref ;\n if ( rfield == field || ! interl ) map [ list ] [ old_ref ] = cur_ref ;\n break ;\n }\n }\n }\n }\n }",
        "hash": 1743019814289113128,
        "project": "debian",
        "size": 29,
        "slice": {
            "memset": [
                [
                    1,
                    "static void fill_colmap ( H264Context * h , int map [ 2 ] [ 16 + 32 ] , int list , int field , int colfield , int mbafi ) {\n"
                ],
                [
                    7,
                    " memset ( map [ list ] , 0 , sizeof ( map [ list ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void fill_colmap ( H264Context * h , int map [ 2 ] [ 16 + 32 ] , int list , int field , int colfield , int mbafi ) {\n"
                ],
                [
                    7,
                    " memset ( map [ list ] , 0 , sizeof ( map [ list ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void ff_h264_direct_ref_list_init ( H264Context * const h ) {\n Picture * const ref1 = & h -> ref_list [ 1 ] [ 0 ] ;\n Picture * const cur = h -> cur_pic_ptr ;\n int list , j , field ;\n int sidx = ( h -> picture_structure & 1 ) ^ 1 ;\n int ref1sidx = ( ref1 -> f . reference & 1 ) ^ 1 ;\n for ( list = 0 ;\n list < 2 ;\n list ++ ) {\n cur -> ref_count [ sidx ] [ list ] = h -> ref_count [ list ] ;\n for ( j = 0 ;\n j < h -> ref_count [ list ] ;\n j ++ ) cur -> ref_poc [ sidx ] [ list ] [ j ] = 4 * h -> ref_list [ list ] [ j ] . frame_num + ( h -> ref_list [ list ] [ j ] . f . reference & 3 ) ;\n }\n if ( h -> picture_structure == PICT_FRAME ) {\n memcpy ( cur -> ref_count [ 1 ] , cur -> ref_count [ 0 ] , sizeof ( cur -> ref_count [ 0 ] ) ) ;\n memcpy ( cur -> ref_poc [ 1 ] , cur -> ref_poc [ 0 ] , sizeof ( cur -> ref_poc [ 0 ] ) ) ;\n }\n cur -> mbaff = FRAME_MBAFF ;\n h -> col_fieldoff = 0 ;\n if ( h -> picture_structure == PICT_FRAME ) {\n int cur_poc = h -> cur_pic_ptr -> poc ;\n int * col_poc = h -> ref_list [ 1 ] -> field_poc ;\n h -> col_parity = ( FFABS ( col_poc [ 0 ] - cur_poc ) >= FFABS ( col_poc [ 1 ] - cur_poc ) ) ;\n ref1sidx = sidx = h -> col_parity ;\n }\n else if ( ! ( h -> picture_structure & h -> ref_list [ 1 ] [ 0 ] . f . reference ) && ! h -> ref_list [ 1 ] [ 0 ] . mbaff ) {\n h -> col_fieldoff = 2 * h -> ref_list [ 1 ] [ 0 ] . f . reference - 3 ;\n }\n if ( h -> slice_type_nos != AV_PICTURE_TYPE_B || h -> direct_spatial_mv_pred ) return ;\n for ( list = 0 ;\n list < 2 ;\n list ++ ) {\n fill_colmap ( h , h -> map_col_to_list0 , list , sidx , ref1sidx , 0 ) ;\n if ( FRAME_MBAFF ) for ( field = 0 ;\n field < 2 ;\n field ++ ) fill_colmap ( h , h -> map_col_to_list0_field [ field ] , list , field , field , 1 ) ;\n }\n }",
        "hash": 1743019814289113128,
        "project": "debian",
        "size": 39,
        "slice": {
            "memcpy": [
                [
                    1,
                    "void ff_h264_direct_ref_list_init ( H264Context * const h ) {\n"
                ],
                [
                    15,
                    " if ( h -> picture_structure == PICT_FRAME ) {\n"
                ],
                [
                    16,
                    " memcpy ( cur -> ref_count [ 1 ] , cur -> ref_count [ 0 ] , sizeof ( cur -> ref_count [ 0 ] ) ) ;\n"
                ],
                [
                    17,
                    " memcpy ( cur -> ref_poc [ 1 ] , cur -> ref_poc [ 0 ] , sizeof ( cur -> ref_poc [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void ff_h264_direct_ref_list_init ( H264Context * const h ) {\n"
                ],
                [
                    15,
                    " if ( h -> picture_structure == PICT_FRAME ) {\n"
                ],
                [
                    16,
                    " memcpy ( cur -> ref_count [ 1 ] , cur -> ref_count [ 0 ] , sizeof ( cur -> ref_count [ 0 ] ) ) ;\n"
                ],
                [
                    17,
                    " memcpy ( cur -> ref_poc [ 1 ] , cur -> ref_poc [ 0 ] , sizeof ( cur -> ref_poc [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static inline void xan_wc3_copy_pixel_run ( XanContext * s , int x , int y , int pixel_count , int motion_x , int motion_y ) {\n int stride ;\n int line_inc ;\n int curframe_index , prevframe_index ;\n int curframe_x , prevframe_x ;\n int width = s -> avctx -> width ;\n unsigned char * palette_plane , * prev_palette_plane ;\n if ( y + motion_y < 0 || y + motion_y >= s -> avctx -> height || x + motion_x < 0 || x + motion_x >= s -> avctx -> width ) return ;\n palette_plane = s -> current_frame . data [ 0 ] ;\n prev_palette_plane = s -> last_frame . data [ 0 ] ;\n if ( ! prev_palette_plane ) prev_palette_plane = palette_plane ;\n stride = s -> current_frame . linesize [ 0 ] ;\n line_inc = stride - width ;\n curframe_index = y * stride + x ;\n curframe_x = x ;\n prevframe_index = ( y + motion_y ) * stride + x + motion_x ;\n prevframe_x = x + motion_x ;\n while ( pixel_count && curframe_index < s -> frame_size && prevframe_index < s -> frame_size ) {\n int count = FFMIN3 ( pixel_count , width - curframe_x , width - prevframe_x ) ;\n memcpy ( palette_plane + curframe_index , prev_palette_plane + prevframe_index , count ) ;\n pixel_count -= count ;\n curframe_index += count ;\n prevframe_index += count ;\n curframe_x += count ;\n prevframe_x += count ;\n if ( curframe_x >= width ) {\n curframe_index += line_inc ;\n curframe_x = 0 ;\n }\n if ( prevframe_x >= width ) {\n prevframe_index += line_inc ;\n prevframe_x = 0 ;\n }\n }\n }",
        "hash": 8953904005695962093,
        "project": "debian",
        "size": 35,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static inline void xan_wc3_copy_pixel_run ( XanContext * s , int x , int y , int pixel_count , int motion_x , int motion_y ) {\n"
                ],
                [
                    9,
                    " palette_plane = s -> current_frame . data [ 0 ] ;\n"
                ],
                [
                    11,
                    " if ( ! prev_palette_plane ) prev_palette_plane = palette_plane ;\n"
                ],
                [
                    14,
                    " curframe_index = y * stride + x ;\n"
                ],
                [
                    16,
                    " prevframe_index = ( y + motion_y ) * stride + x + motion_x ;\n"
                ],
                [
                    18,
                    " while ( pixel_count && curframe_index < s -> frame_size && prevframe_index < s -> frame_size ) {\n"
                ],
                [
                    19,
                    " int count = FFMIN3 ( pixel_count , width - curframe_x , width - prevframe_x ) ;\n"
                ],
                [
                    20,
                    " memcpy ( palette_plane + curframe_index , prev_palette_plane + prevframe_index , count ) ;\n"
                ],
                [
                    21,
                    " pixel_count -= count ;\n"
                ],
                [
                    22,
                    " curframe_index += count ;\n"
                ],
                [
                    23,
                    " prevframe_index += count ;\n"
                ],
                [
                    24,
                    " curframe_x += count ;\n"
                ],
                [
                    25,
                    " prevframe_x += count ;\n"
                ],
                [
                    27,
                    " curframe_index += line_inc ;\n"
                ],
                [
                    31,
                    " prevframe_index += line_inc ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static inline void xan_wc3_copy_pixel_run ( XanContext * s , int x , int y , int pixel_count , int motion_x , int motion_y ) {\n"
                ],
                [
                    9,
                    " palette_plane = s -> current_frame . data [ 0 ] ;\n"
                ],
                [
                    11,
                    " if ( ! prev_palette_plane ) prev_palette_plane = palette_plane ;\n"
                ],
                [
                    14,
                    " curframe_index = y * stride + x ;\n"
                ],
                [
                    16,
                    " prevframe_index = ( y + motion_y ) * stride + x + motion_x ;\n"
                ],
                [
                    18,
                    " while ( pixel_count && curframe_index < s -> frame_size && prevframe_index < s -> frame_size ) {\n"
                ],
                [
                    19,
                    " int count = FFMIN3 ( pixel_count , width - curframe_x , width - prevframe_x ) ;\n"
                ],
                [
                    20,
                    " memcpy ( palette_plane + curframe_index , prev_palette_plane + prevframe_index , count ) ;\n"
                ],
                [
                    21,
                    " pixel_count -= count ;\n"
                ],
                [
                    22,
                    " curframe_index += count ;\n"
                ],
                [
                    23,
                    " prevframe_index += count ;\n"
                ],
                [
                    24,
                    " curframe_x += count ;\n"
                ],
                [
                    25,
                    " prevframe_x += count ;\n"
                ],
                [
                    27,
                    " curframe_index += line_inc ;\n"
                ],
                [
                    31,
                    " prevframe_index += line_inc ;\n"
                ]
            ]
        }
    },
    {
        "code": "static inline void xan_wc3_output_pixel_run ( XanContext * s , const unsigned char * pixel_buffer , int x , int y , int pixel_count ) {\n int stride ;\n int line_inc ;\n int index ;\n int current_x ;\n int width = s -> avctx -> width ;\n unsigned char * palette_plane ;\n palette_plane = s -> current_frame . data [ 0 ] ;\n stride = s -> current_frame . linesize [ 0 ] ;\n line_inc = stride - width ;\n index = y * stride + x ;\n current_x = x ;\n while ( pixel_count && index < s -> frame_size ) {\n int count = FFMIN ( pixel_count , width - current_x ) ;\n memcpy ( palette_plane + index , pixel_buffer , count ) ;\n pixel_count -= count ;\n index += count ;\n pixel_buffer += count ;\n current_x += count ;\n if ( current_x >= width ) {\n index += line_inc ;\n current_x = 0 ;\n }\n }\n }",
        "hash": 8953904005695962093,
        "project": "debian",
        "size": 25,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static inline void xan_wc3_output_pixel_run ( XanContext * s , const unsigned char * pixel_buffer , int x , int y , int pixel_count ) {\n"
                ],
                [
                    8,
                    " palette_plane = s -> current_frame . data [ 0 ] ;\n"
                ],
                [
                    11,
                    " index = y * stride + x ;\n"
                ],
                [
                    13,
                    " while ( pixel_count && index < s -> frame_size ) {\n"
                ],
                [
                    14,
                    " int count = FFMIN ( pixel_count , width - current_x ) ;\n"
                ],
                [
                    15,
                    " memcpy ( palette_plane + index , pixel_buffer , count ) ;\n"
                ],
                [
                    16,
                    " pixel_count -= count ;\n"
                ],
                [
                    17,
                    " index += count ;\n"
                ],
                [
                    18,
                    " pixel_buffer += count ;\n"
                ],
                [
                    19,
                    " current_x += count ;\n"
                ],
                [
                    21,
                    " index += line_inc ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static inline void xan_wc3_output_pixel_run ( XanContext * s , const unsigned char * pixel_buffer , int x , int y , int pixel_count ) {\n"
                ],
                [
                    8,
                    " palette_plane = s -> current_frame . data [ 0 ] ;\n"
                ],
                [
                    11,
                    " index = y * stride + x ;\n"
                ],
                [
                    13,
                    " while ( pixel_count && index < s -> frame_size ) {\n"
                ],
                [
                    14,
                    " int count = FFMIN ( pixel_count , width - current_x ) ;\n"
                ],
                [
                    15,
                    " memcpy ( palette_plane + index , pixel_buffer , count ) ;\n"
                ],
                [
                    16,
                    " pixel_count -= count ;\n"
                ],
                [
                    17,
                    " index += count ;\n"
                ],
                [
                    18,
                    " pixel_buffer += count ;\n"
                ],
                [
                    19,
                    " current_x += count ;\n"
                ],
                [
                    21,
                    " index += line_inc ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret , buf_size = avpkt -> size ;\n XanContext * s = avctx -> priv_data ;\n GetByteContext ctx ;\n int tag = 0 ;\n bytestream2_init ( & ctx , buf , buf_size ) ;\n while ( bytestream2_get_bytes_left ( & ctx ) > 8 && tag != VGA__TAG ) {\n unsigned * tmpptr ;\n uint32_t new_pal ;\n int size ;\n int i ;\n tag = bytestream2_get_le32 ( & ctx ) ;\n size = bytestream2_get_be32 ( & ctx ) ;\n size = FFMIN ( size , bytestream2_get_bytes_left ( & ctx ) ) ;\n switch ( tag ) {\n case PALT_TAG : if ( size < PALETTE_SIZE ) return AVERROR_INVALIDDATA ;\n if ( s -> palettes_count >= PALETTES_MAX ) return AVERROR_INVALIDDATA ;\n tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n if ( ! tmpptr ) return AVERROR ( ENOMEM ) ;\n s -> palettes = tmpptr ;\n tmpptr += s -> palettes_count * AVPALETTE_COUNT ;\n for ( i = 0 ;\n i < PALETTE_COUNT ;\n i ++ ) {\n # if RUNTIME_GAMMA int r = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n int g = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n int b = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n # else int r = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n int g = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n int b = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n # endif * tmpptr ++ = ( r << 16 ) | ( g << 8 ) | b ;\n }\n s -> palettes_count ++ ;\n break ;\n case SHOT_TAG : if ( size < 4 ) return AVERROR_INVALIDDATA ;\n new_pal = bytestream2_get_le32 ( & ctx ) ;\n if ( new_pal < s -> palettes_count ) {\n s -> cur_palette = new_pal ;\n }\n else av_log ( avctx , AV_LOG_ERROR , \"Invalid palette selected\\n\" ) ;\n break ;\n case VGA__TAG : break ;\n default : bytestream2_skip ( & ctx , size ) ;\n break ;\n }\n }\n buf_size = bytestream2_get_bytes_left ( & ctx ) ;\n if ( s -> palettes_count <= 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"No palette found\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n s -> current_frame . reference = 3 ;\n if ( ! s -> frame_size ) s -> frame_size = s -> current_frame . linesize [ 0 ] * s -> avctx -> height ;\n memcpy ( s -> current_frame . data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;\n s -> buf = ctx . buffer ;\n s -> size = buf_size ;\n if ( xan_wc3_decode_frame ( s ) < 0 ) return AVERROR_INVALIDDATA ;\n if ( s -> last_frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> last_frame ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> current_frame ;\n FFSWAP ( AVFrame , s -> current_frame , s -> last_frame ) ;\n return buf_size ;\n }",
        "hash": 8953904005695962093,
        "project": "debian",
        "size": 68,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " XanContext * s = avctx -> priv_data ;\n"
                ],
                [
                    19,
                    " tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n"
                ],
                [
                    21,
                    " s -> palettes = tmpptr ;\n"
                ],
                [
                    53,
                    " if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) ) {\n"
                ],
                [
                    59,
                    " memcpy ( s -> current_frame . data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " XanContext * s = avctx -> priv_data ;\n"
                ],
                [
                    19,
                    " tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n"
                ],
                [
                    21,
                    " s -> palettes = tmpptr ;\n"
                ],
                [
                    53,
                    " if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) ) {\n"
                ],
                [
                    59,
                    " memcpy ( s -> current_frame . data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int tgv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n TgvContext * s = avctx -> priv_data ;\n const uint8_t * buf_end = buf + buf_size ;\n int chunk_type , ret ;\n chunk_type = AV_RL32 ( & buf [ 0 ] ) ;\n buf += EA_PREAMBLE_SIZE ;\n if ( chunk_type == kVGT_TAG ) {\n int pal_count , i ;\n if ( buf + 12 > buf_end ) {\n av_log ( avctx , AV_LOG_WARNING , \"truncated header\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n s -> width = AV_RL16 ( & buf [ 0 ] ) ;\n s -> height = AV_RL16 ( & buf [ 2 ] ) ;\n if ( s -> avctx -> width != s -> width || s -> avctx -> height != s -> height ) {\n avcodec_set_dimensions ( s -> avctx , s -> width , s -> height ) ;\n cond_release_buffer ( & s -> frame ) ;\n cond_release_buffer ( & s -> last_frame ) ;\n }\n pal_count = AV_RL16 ( & buf [ 6 ] ) ;\n buf += 12 ;\n for ( i = 0 ;\n i < pal_count && i < AVPALETTE_COUNT && buf + 2 < buf_end ;\n i ++ ) {\n s -> palette [ i ] = AV_RB24 ( buf ) ;\n buf += 3 ;\n }\n }\n if ( ( ret = av_image_check_size ( s -> width , s -> height , 0 , avctx ) ) < 0 ) return ret ;\n FFSWAP ( AVFrame , s -> frame , s -> last_frame ) ;\n if ( ! s -> frame . data [ 0 ] ) {\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID ;\n s -> frame . linesize [ 0 ] = s -> width ;\n s -> frame . data [ 0 ] = av_malloc ( s -> width * s -> height ) ;\n if ( ! s -> frame . data [ 0 ] ) return AVERROR ( ENOMEM ) ;\n s -> frame . data [ 1 ] = av_malloc ( AVPALETTE_SIZE ) ;\n if ( ! s -> frame . data [ 1 ] ) {\n av_freep ( & s -> frame . data [ 0 ] ) ;\n return AVERROR ( ENOMEM ) ;\n }\n }\n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n if ( chunk_type == kVGT_TAG ) {\n s -> frame . key_frame = 1 ;\n s -> frame . pict_type = AV_PICTURE_TYPE_I ;\n if ( unpack ( buf , buf_end , s -> frame . data [ 0 ] , s -> avctx -> width , s -> avctx -> height ) < 0 ) {\n av_log ( avctx , AV_LOG_WARNING , \"truncated intra frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n else {\n if ( ! s -> last_frame . data [ 0 ] ) {\n av_log ( avctx , AV_LOG_WARNING , \"inter frame without corresponding intra frame\\n\" ) ;\n return buf_size ;\n }\n s -> frame . key_frame = 0 ;\n s -> frame . pict_type = AV_PICTURE_TYPE_P ;\n if ( tgv_decode_inter ( s , buf , buf_end ) < 0 ) {\n av_log ( avctx , AV_LOG_WARNING , \"truncated inter frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": -6734821889507212232,
        "project": "debian",
        "size": 69,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int tgv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " TgvContext * s = avctx -> priv_data ;\n"
                ],
                [
                    27,
                    " s -> palette [ i ] = AV_RB24 ( buf ) ;\n"
                ],
                [
                    33,
                    " if ( ! s -> frame . data [ 0 ] ) {\n"
                ],
                [
                    39,
                    " s -> frame . data [ 1 ] = av_malloc ( AVPALETTE_SIZE ) ;\n"
                ],
                [
                    40,
                    " if ( ! s -> frame . data [ 1 ] ) {\n"
                ],
                [
                    45,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    61,
                    " if ( tgv_decode_inter ( s , buf , buf_end ) < 0 ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int tgv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " TgvContext * s = avctx -> priv_data ;\n"
                ],
                [
                    27,
                    " s -> palette [ i ] = AV_RB24 ( buf ) ;\n"
                ],
                [
                    33,
                    " if ( ! s -> frame . data [ 0 ] ) {\n"
                ],
                [
                    39,
                    " s -> frame . data [ 1 ] = av_malloc ( AVPALETTE_SIZE ) ;\n"
                ],
                [
                    40,
                    " if ( ! s -> frame . data [ 1 ] ) {\n"
                ],
                [
                    45,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    61,
                    " if ( tgv_decode_inter ( s , buf , buf_end ) < 0 ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int raw_decode ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ;\n RawVideoContext * context = avctx -> priv_data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int res ;\n AVFrame * frame = data ;\n AVPicture * picture = data ;\n frame -> pict_type = avctx -> coded_frame -> pict_type ;\n frame -> interlaced_frame = avctx -> coded_frame -> interlaced_frame ;\n frame -> top_field_first = avctx -> coded_frame -> top_field_first ;\n frame -> reordered_opaque = avctx -> reordered_opaque ;\n frame -> pkt_pts = avctx -> pkt -> pts ;\n if ( buf_size < context -> length - ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ? AVPALETTE_SIZE : 0 ) ) return - 1 ;\n if ( context -> buffer ) {\n int i ;\n uint8_t * dst = context -> buffer ;\n buf_size = context -> length - AVPALETTE_SIZE ;\n if ( avctx -> bits_per_coded_sample == 4 ) {\n for ( i = 0 ;\n 2 * i + 1 < buf_size ;\n i ++ ) {\n dst [ 2 * i + 0 ] = buf [ i ] >> 4 ;\n dst [ 2 * i + 1 ] = buf [ i ] & 15 ;\n }\n }\n else {\n for ( i = 0 ;\n 4 * i + 3 < buf_size ;\n i ++ ) {\n dst [ 4 * i + 0 ] = buf [ i ] >> 6 ;\n dst [ 4 * i + 1 ] = buf [ i ] >> 4 & 3 ;\n dst [ 4 * i + 2 ] = buf [ i ] >> 2 & 3 ;\n dst [ 4 * i + 3 ] = buf [ i ] & 3 ;\n }\n }\n buf = dst ;\n }\n if ( avctx -> codec_tag == MKTAG ( 'A' , 'V' , '1' , 'x' ) || avctx -> codec_tag == MKTAG ( 'A' , 'V' , 'u' , 'p' ) ) buf += buf_size - context -> length ;\n if ( ( res = avpicture_fill ( picture , buf , avctx -> pix_fmt , avctx -> width , avctx -> height ) ) < 0 ) return res ;\n if ( ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 && buf_size < context -> length ) || ( desc -> flags & PIX_FMT_PSEUDOPAL ) ) {\n frame -> data [ 1 ] = context -> palette ;\n }\n if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n memcpy ( frame -> data [ 1 ] , pal , AVPALETTE_SIZE ) ;\n frame -> palette_has_changed = 1 ;\n }\n }\n if ( avctx -> pix_fmt == AV_PIX_FMT_BGR24 && ( ( frame -> linesize [ 0 ] + 3 ) & ~ 3 ) * avctx -> height <= buf_size ) frame -> linesize [ 0 ] = ( frame -> linesize [ 0 ] + 3 ) & ~ 3 ;\n if ( context -> flip ) flip ( avctx , picture ) ;\n if ( avctx -> codec_tag == MKTAG ( 'Y' , 'V' , '1' , '2' ) || avctx -> codec_tag == MKTAG ( 'Y' , 'V' , '1' , '6' ) || avctx -> codec_tag == MKTAG ( 'Y' , 'V' , '2' , '4' ) || avctx -> codec_tag == MKTAG ( 'Y' , 'V' , 'U' , '9' ) ) FFSWAP ( uint8_t * , picture -> data [ 1 ] , picture -> data [ 2 ] ) ;\n if ( avctx -> codec_tag == AV_RL32 ( \"yuv2\" ) && avctx -> pix_fmt == AV_PIX_FMT_YUYV422 ) {\n int x , y ;\n uint8_t * line = picture -> data [ 0 ] ;\n for ( y = 0 ;\n y < avctx -> height ;\n y ++ ) {\n for ( x = 0 ;\n x < avctx -> width ;\n x ++ ) line [ 2 * x + 1 ] ^= 0x80 ;\n line += picture -> linesize [ 0 ] ;\n }\n }\n * got_frame = 1 ;\n return buf_size ;\n }",
        "hash": -1604848228542845191,
        "project": "debian",
        "size": 68,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int raw_decode ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    18,
                    " buf_size = context -> length - AVPALETTE_SIZE ;\n"
                ],
                [
                    42,
                    " frame -> data [ 1 ] = context -> palette ;\n"
                ],
                [
                    45,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    46,
                    " if ( pal ) {\n"
                ],
                [
                    47,
                    " memcpy ( frame -> data [ 1 ] , pal , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int raw_decode ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    18,
                    " buf_size = context -> length - AVPALETTE_SIZE ;\n"
                ],
                [
                    42,
                    " frame -> data [ 1 ] = context -> palette ;\n"
                ],
                [
                    45,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    46,
                    " if ( pal ) {\n"
                ],
                [
                    47,
                    " memcpy ( frame -> data [ 1 ] , pal , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int amrwb_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AMRWBContext * ctx = avctx -> priv_data ;\n AVFrame * frame = data ;\n AMRWBFrame * cf = & ctx -> frame ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int expected_fr_size , header_size ;\n float * buf_out ;\n float spare_vector [ AMRWB_SFR_SIZE ] ;\n float fixed_gain_factor ;\n float * synth_fixed_vector ;\n float synth_fixed_gain ;\n float voice_fac , stab_fac ;\n float synth_exc [ AMRWB_SFR_SIZE ] ;\n float hb_exc [ AMRWB_SFR_SIZE_16k ] ;\n float hb_samples [ AMRWB_SFR_SIZE_16k ] ;\n float hb_gain ;\n int sub , i , ret ;\n frame -> nb_samples = 4 * AMRWB_SFR_SIZE_16k ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf_out = ( float * ) frame -> data [ 0 ] ;\n header_size = decode_mime_header ( ctx , buf ) ;\n if ( ctx -> fr_cur_mode > MODE_SID ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid mode %d\\n\" , ctx -> fr_cur_mode ) ;\n return AVERROR_INVALIDDATA ;\n }\n expected_fr_size = ( ( cf_sizes_wb [ ctx -> fr_cur_mode ] + 7 ) >> 3 ) + 1 ;\n if ( buf_size < expected_fr_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame too small (%d bytes). Truncated file?\\n\" , buf_size ) ;\n * got_frame_ptr = 0 ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ! ctx -> fr_quality || ctx -> fr_cur_mode > MODE_SID ) av_log ( avctx , AV_LOG_ERROR , \"Encountered a bad or corrupted frame\\n\" ) ;\n if ( ctx -> fr_cur_mode == MODE_SID ) {\n av_log_missing_feature ( avctx , \"SID mode\" , 1 ) ;\n return AVERROR_PATCHWELCOME ;\n }\n ff_amr_bit_reorder ( ( uint16_t * ) & ctx -> frame , sizeof ( AMRWBFrame ) , buf + header_size , amr_bit_orderings_by_mode [ ctx -> fr_cur_mode ] ) ;\n if ( ctx -> fr_cur_mode == MODE_6k60 ) {\n decode_isf_indices_36b ( cf -> isp_id , ctx -> isf_cur ) ;\n }\n else {\n decode_isf_indices_46b ( cf -> isp_id , ctx -> isf_cur ) ;\n }\n isf_add_mean_and_past ( ctx -> isf_cur , ctx -> isf_q_past ) ;\n ff_set_min_dist_lsf ( ctx -> isf_cur , MIN_ISF_SPACING , LP_ORDER - 1 ) ;\n stab_fac = stability_factor ( ctx -> isf_cur , ctx -> isf_past_final ) ;\n ctx -> isf_cur [ LP_ORDER - 1 ] *= 2.0 ;\n ff_acelp_lsf2lspd ( ctx -> isp [ 3 ] , ctx -> isf_cur , LP_ORDER ) ;\n if ( ctx -> first_frame ) {\n ctx -> first_frame = 0 ;\n memcpy ( ctx -> isp_sub4_past , ctx -> isp [ 3 ] , LP_ORDER * sizeof ( double ) ) ;\n }\n interpolate_isp ( ctx -> isp , ctx -> isp_sub4_past ) ;\n for ( sub = 0 ;\n sub < 4 ;\n sub ++ ) ff_amrwb_lsp2lpc ( ctx -> isp [ sub ] , ctx -> lp_coef [ sub ] , LP_ORDER ) ;\n for ( sub = 0 ;\n sub < 4 ;\n sub ++ ) {\n const AMRWBSubFrame * cur_subframe = & cf -> subframe [ sub ] ;\n float * sub_buf = buf_out + sub * AMRWB_SFR_SIZE_16k ;\n decode_pitch_vector ( ctx , cur_subframe , sub ) ;\n decode_fixed_vector ( ctx -> fixed_vector , cur_subframe -> pul_ih , cur_subframe -> pul_il , ctx -> fr_cur_mode ) ;\n pitch_sharpening ( ctx , ctx -> fixed_vector ) ;\n decode_gains ( cur_subframe -> vq_gain , ctx -> fr_cur_mode , & fixed_gain_factor , & ctx -> pitch_gain [ 0 ] ) ;\n ctx -> fixed_gain [ 0 ] = ff_amr_set_fixed_gain ( fixed_gain_factor , avpriv_scalarproduct_float_c ( ctx -> fixed_vector , ctx -> fixed_vector , AMRWB_SFR_SIZE ) / AMRWB_SFR_SIZE , ctx -> prediction_error , ENERGY_MEAN , energy_pred_fac ) ;\n voice_fac = voice_factor ( ctx -> pitch_vector , ctx -> pitch_gain [ 0 ] , ctx -> fixed_vector , ctx -> fixed_gain [ 0 ] ) ;\n ctx -> tilt_coef = voice_fac * 0.25 + 0.25 ;\n for ( i = 0 ;\n i < AMRWB_SFR_SIZE ;\n i ++ ) {\n ctx -> excitation [ i ] *= ctx -> pitch_gain [ 0 ] ;\n ctx -> excitation [ i ] += ctx -> fixed_gain [ 0 ] * ctx -> fixed_vector [ i ] ;\n ctx -> excitation [ i ] = truncf ( ctx -> excitation [ i ] ) ;\n }\n synth_fixed_gain = noise_enhancer ( ctx -> fixed_gain [ 0 ] , & ctx -> prev_tr_gain , voice_fac , stab_fac ) ;\n synth_fixed_vector = anti_sparseness ( ctx , ctx -> fixed_vector , spare_vector ) ;\n pitch_enhancer ( synth_fixed_vector , voice_fac ) ;\n synthesis ( ctx , ctx -> lp_coef [ sub ] , synth_exc , synth_fixed_gain , synth_fixed_vector , & ctx -> samples_az [ LP_ORDER ] ) ;\n de_emphasis ( & ctx -> samples_up [ UPS_MEM_SIZE ] , & ctx -> samples_az [ LP_ORDER ] , PREEMPH_FAC , ctx -> demph_mem ) ;\n ff_acelp_apply_order_2_transfer_function ( & ctx -> samples_up [ UPS_MEM_SIZE ] , & ctx -> samples_up [ UPS_MEM_SIZE ] , hpf_zeros , hpf_31_poles , hpf_31_gain , ctx -> hpf_31_mem , AMRWB_SFR_SIZE ) ;\n upsample_5_4 ( sub_buf , & ctx -> samples_up [ UPS_FIR_SIZE ] , AMRWB_SFR_SIZE_16k ) ;\n ff_acelp_apply_order_2_transfer_function ( hb_samples , & ctx -> samples_up [ UPS_MEM_SIZE ] , hpf_zeros , hpf_400_poles , hpf_400_gain , ctx -> hpf_400_mem , AMRWB_SFR_SIZE ) ;\n hb_gain = find_hb_gain ( ctx , hb_samples , cur_subframe -> hb_gain , cf -> vad ) ;\n scaled_hb_excitation ( ctx , hb_exc , synth_exc , hb_gain ) ;\n hb_synthesis ( ctx , sub , & ctx -> samples_hb [ LP_ORDER_16k ] , hb_exc , ctx -> isf_cur , ctx -> isf_past_final ) ;\n hb_fir_filter ( hb_samples , bpf_6_7_coef , ctx -> bpf_6_7_mem , & ctx -> samples_hb [ LP_ORDER_16k ] ) ;\n if ( ctx -> fr_cur_mode == MODE_23k85 ) hb_fir_filter ( hb_samples , lpf_7_coef , ctx -> lpf_7_mem , hb_samples ) ;\n for ( i = 0 ;\n i < AMRWB_SFR_SIZE_16k ;\n i ++ ) sub_buf [ i ] = ( sub_buf [ i ] + hb_samples [ i ] ) * ( 1.0f / ( 1 << 15 ) ) ;\n update_sub_state ( ctx ) ;\n }\n memcpy ( ctx -> isp_sub4_past , ctx -> isp [ 3 ] , LP_ORDER * sizeof ( ctx -> isp [ 3 ] [ 0 ] ) ) ;\n memcpy ( ctx -> isf_past_final , ctx -> isf_cur , LP_ORDER * sizeof ( float ) ) ;\n * got_frame_ptr = 1 ;\n return expected_fr_size ;\n }",
        "hash": -7019074708255236794,
        "project": "debian",
        "size": 102,
        "slice": {
            "memcpy": [
                [
                    25,
                    " header_size = decode_mime_header ( ctx , buf ) ;\n"
                ],
                [
                    37,
                    " if ( ctx -> fr_cur_mode == MODE_SID ) {\n"
                ],
                [
                    50,
                    " stab_fac = stability_factor ( ctx -> isf_cur , ctx -> isf_past_final ) ;\n"
                ],
                [
                    51,
                    " ctx -> isf_cur [ LP_ORDER - 1 ] *= 2.0 ;\n"
                ],
                [
                    52,
                    " ff_acelp_lsf2lspd ( ctx -> isp [ 3 ] , ctx -> isf_cur , LP_ORDER ) ;\n"
                ],
                [
                    53,
                    " if ( ctx -> first_frame ) {\n"
                ],
                [
                    55,
                    " memcpy ( ctx -> isp_sub4_past , ctx -> isp [ 3 ] , LP_ORDER * sizeof ( double ) ) ;\n"
                ],
                [
                    57,
                    " interpolate_isp ( ctx -> isp , ctx -> isp_sub4_past ) ;\n"
                ],
                [
                    90,
                    " hb_synthesis ( ctx , sub , & ctx -> samples_hb [ LP_ORDER_16k ] , hb_exc , ctx -> isf_cur , ctx -> isf_past_final ) ;\n"
                ],
                [
                    96,
                    " update_sub_state ( ctx ) ;\n"
                ],
                [
                    98,
                    " memcpy ( ctx -> isp_sub4_past , ctx -> isp [ 3 ] , LP_ORDER * sizeof ( ctx -> isp [ 3 ] [ 0 ] ) ) ;\n"
                ],
                [
                    99,
                    " memcpy ( ctx -> isf_past_final , ctx -> isf_cur , LP_ORDER * sizeof ( float ) ) ;\n"
                ]
            ],
            "result": [
                [
                    25,
                    " header_size = decode_mime_header ( ctx , buf ) ;\n"
                ],
                [
                    37,
                    " if ( ctx -> fr_cur_mode == MODE_SID ) {\n"
                ],
                [
                    50,
                    " stab_fac = stability_factor ( ctx -> isf_cur , ctx -> isf_past_final ) ;\n"
                ],
                [
                    51,
                    " ctx -> isf_cur [ LP_ORDER - 1 ] *= 2.0 ;\n"
                ],
                [
                    52,
                    " ff_acelp_lsf2lspd ( ctx -> isp [ 3 ] , ctx -> isf_cur , LP_ORDER ) ;\n"
                ],
                [
                    53,
                    " if ( ctx -> first_frame ) {\n"
                ],
                [
                    55,
                    " memcpy ( ctx -> isp_sub4_past , ctx -> isp [ 3 ] , LP_ORDER * sizeof ( double ) ) ;\n"
                ],
                [
                    57,
                    " interpolate_isp ( ctx -> isp , ctx -> isp_sub4_past ) ;\n"
                ],
                [
                    90,
                    " hb_synthesis ( ctx , sub , & ctx -> samples_hb [ LP_ORDER_16k ] , hb_exc , ctx -> isf_cur , ctx -> isf_past_final ) ;\n"
                ],
                [
                    96,
                    " update_sub_state ( ctx ) ;\n"
                ],
                [
                    98,
                    " memcpy ( ctx -> isp_sub4_past , ctx -> isp [ 3 ] , LP_ORDER * sizeof ( ctx -> isp [ 3 ] [ 0 ] ) ) ;\n"
                ],
                [
                    99,
                    " memcpy ( ctx -> isf_past_final , ctx -> isf_cur , LP_ORDER * sizeof ( float ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int tscc2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n TSCC2Context * c = avctx -> priv_data ;\n GetByteContext gb ;\n uint32_t frame_type , size ;\n int i , val , len , pos = 0 ;\n int num_mb = c -> mb_width * c -> mb_height ;\n int ret ;\n bytestream2_init ( & gb , buf , buf_size ) ;\n frame_type = bytestream2_get_byte ( & gb ) ;\n if ( frame_type > 1 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Incorrect frame type %d\\n\" , frame_type ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> pic . reference = 3 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( frame_type == 0 ) {\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }\n if ( bytestream2_get_bytes_left ( & gb ) < 4 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame is too short\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> quant [ 0 ] = bytestream2_get_byte ( & gb ) ;\n c -> quant [ 1 ] = bytestream2_get_byte ( & gb ) ;\n if ( c -> quant [ 0 ] < 2 || c -> quant [ 0 ] > NUM_VLC_SETS + 1 || c -> quant [ 1 ] < 2 || c -> quant [ 1 ] > NUM_VLC_SETS + 1 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid quantisers %d / %d\\n\" , c -> quant [ 0 ] , c -> quant [ 1 ] ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n c -> q [ 0 ] [ i ] = tscc2_quants [ c -> quant [ 0 ] - 2 ] [ i ] ;\n c -> q [ 1 ] [ i ] = tscc2_quants [ c -> quant [ 1 ] - 2 ] [ i ] ;\n }\n bytestream2_skip ( & gb , 1 ) ;\n size = bytestream2_get_le32 ( & gb ) ;\n if ( size > bytestream2_get_bytes_left ( & gb ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Slice properties chunk is too large\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < size ;\n i ++ ) {\n val = bytestream2_get_byte ( & gb ) ;\n len = val & 0x3F ;\n val >>= 6 ;\n if ( pos + len > num_mb ) {\n av_log ( avctx , AV_LOG_ERROR , \"Too many slice properties\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n memset ( c -> slice_quants + pos , val , len ) ;\n pos += len ;\n }\n if ( pos < num_mb ) {\n av_log ( avctx , AV_LOG_ERROR , \"Too few slice properties (%d / %d)\\n\" , pos , num_mb ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < c -> mb_height ;\n i ++ ) {\n size = bytestream2_peek_byte ( & gb ) ;\n if ( size & 1 ) {\n size = bytestream2_get_byte ( & gb ) - 1 ;\n }\n else {\n size = bytestream2_get_le32 ( & gb ) >> 1 ;\n }\n if ( ! size ) {\n int skip_row = 1 , j , off = i * c -> mb_width ;\n for ( j = 0 ;\n j < c -> mb_width ;\n j ++ ) {\n if ( c -> slice_quants [ off + j ] == 1 || c -> slice_quants [ off + j ] == 2 ) {\n skip_row = 0 ;\n break ;\n }\n }\n if ( ! skip_row ) {\n av_log ( avctx , AV_LOG_ERROR , \"Non-skip row with zero size\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n if ( bytestream2_get_bytes_left ( & gb ) < size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid slice size (%d/%d)\\n\" , size , bytestream2_get_bytes_left ( & gb ) ) ;\n return AVERROR_INVALIDDATA ;\n }\n ret = tscc2_decode_slice ( c , i , buf + bytestream2_tell ( & gb ) , size ) ;\n if ( ret ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding slice %d\\n\" , i ) ;\n return ret ;\n }\n bytestream2_skip ( & gb , size ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }",
        "hash": 6216601921913354724,
        "project": "debian",
        "size": 105,
        "slice": {
            "memset": [
                [
                    1,
                    "static int tscc2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " TSCC2Context * c = avctx -> priv_data ;\n"
                ],
                [
                    7,
                    " int i , val , len , pos = 0 ;\n"
                ],
                [
                    53,
                    " len = val & 0x3F ;\n"
                ],
                [
                    54,
                    " val >>= 6 ;\n"
                ],
                [
                    55,
                    " if ( pos + len > num_mb ) {\n"
                ],
                [
                    59,
                    " memset ( c -> slice_quants + pos , val , len ) ;\n"
                ],
                [
                    60,
                    " pos += len ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int tscc2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " TSCC2Context * c = avctx -> priv_data ;\n"
                ],
                [
                    7,
                    " int i , val , len , pos = 0 ;\n"
                ],
                [
                    53,
                    " len = val & 0x3F ;\n"
                ],
                [
                    54,
                    " val >>= 6 ;\n"
                ],
                [
                    55,
                    " if ( pos + len > num_mb ) {\n"
                ],
                [
                    59,
                    " memset ( c -> slice_quants + pos , val , len ) ;\n"
                ],
                [
                    60,
                    " pos += len ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int msrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MsrleContext * s = avctx -> priv_data ;\n int istride = FFALIGN ( avctx -> width * avctx -> bits_per_coded_sample , 32 ) / 8 ;\n int ret ;\n s -> buf = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( avctx -> bits_per_coded_sample <= 8 ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n }\n if ( avctx -> height * istride == avpkt -> size ) {\n int linesize = avctx -> width * avctx -> bits_per_coded_sample / 8 ;\n uint8_t * ptr = s -> frame . data [ 0 ] ;\n uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ;\n int i , j ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n if ( avctx -> bits_per_coded_sample == 4 ) {\n for ( j = 0 ;\n j < avctx -> width - 1 ;\n j += 2 ) {\n ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF ;\n }\n if ( avctx -> width & 1 ) ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n }\n else {\n memcpy ( ptr , buf , linesize ) ;\n }\n buf -= istride ;\n ptr += s -> frame . linesize [ 0 ] ;\n }\n }\n else {\n bytestream2_init ( & s -> gb , buf , buf_size ) ;\n ff_msrle_decode ( avctx , ( AVPicture * ) & s -> frame , avctx -> bits_per_coded_sample , & s -> gb ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": -2905271518485324905,
        "project": "debian",
        "size": 54,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int msrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " MsrleContext * s = avctx -> priv_data ;\n"
                ],
                [
                    15,
                    " if ( avctx -> bits_per_coded_sample <= 8 ) {\n"
                ],
                [
                    16,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    17,
                    " if ( pal ) {\n"
                ],
                [
                    19,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    21,
                    " memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    24,
                    " int linesize = avctx -> width * avctx -> bits_per_coded_sample / 8 ;\n"
                ],
                [
                    25,
                    " uint8_t * ptr = s -> frame . data [ 0 ] ;\n"
                ],
                [
                    26,
                    " uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ;\n"
                ],
                [
                    31,
                    " if ( avctx -> bits_per_coded_sample == 4 ) {\n"
                ],
                [
                    35,
                    " ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n"
                ],
                [
                    36,
                    " ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF ;\n"
                ],
                [
                    38,
                    " if ( avctx -> width & 1 ) ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n"
                ],
                [
                    41,
                    " memcpy ( ptr , buf , linesize ) ;\n"
                ],
                [
                    43,
                    " buf -= istride ;\n"
                ],
                [
                    44,
                    " ptr += s -> frame . linesize [ 0 ] ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int msrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " MsrleContext * s = avctx -> priv_data ;\n"
                ],
                [
                    15,
                    " if ( avctx -> bits_per_coded_sample <= 8 ) {\n"
                ],
                [
                    16,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    17,
                    " if ( pal ) {\n"
                ],
                [
                    19,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    21,
                    " memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    24,
                    " int linesize = avctx -> width * avctx -> bits_per_coded_sample / 8 ;\n"
                ],
                [
                    25,
                    " uint8_t * ptr = s -> frame . data [ 0 ] ;\n"
                ],
                [
                    26,
                    " uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ;\n"
                ],
                [
                    31,
                    " if ( avctx -> bits_per_coded_sample == 4 ) {\n"
                ],
                [
                    35,
                    " ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n"
                ],
                [
                    36,
                    " ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF ;\n"
                ],
                [
                    38,
                    " if ( avctx -> width & 1 ) ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n"
                ],
                [
                    41,
                    " memcpy ( ptr , buf , linesize ) ;\n"
                ],
                [
                    43,
                    " buf -= istride ;\n"
                ],
                [
                    44,
                    " ptr += s -> frame . linesize [ 0 ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) {\n MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ;\n if ( avctx == avctx_from ) return 0 ;\n dst -> cur_index = src -> next_cur_index ;\n dst -> prev_index = src -> next_prev_index ;\n memcpy ( dst -> buf_ptrs , src -> buf_ptrs , sizeof ( src -> buf_ptrs ) ) ;\n memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ;\n memset ( & dst -> buf_ptrs [ dst -> cur_index ] , 0 , sizeof ( AVFrame ) ) ;\n return 0 ;\n }",
        "hash": -2504372172279754762,
        "project": "debian",
        "size": 10,
        "slice": {
            "memcpy": [
                [
                    2,
                    " MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ;\n"
                ],
                [
                    3,
                    " if ( avctx == avctx_from ) return 0 ;\n"
                ],
                [
                    6,
                    " memcpy ( dst -> buf_ptrs , src -> buf_ptrs , sizeof ( src -> buf_ptrs ) ) ;\n"
                ],
                [
                    7,
                    " memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ;\n"
                ],
                [
                    8,
                    " memset ( & dst -> buf_ptrs [ dst -> cur_index ] , 0 , sizeof ( AVFrame ) ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) {\n"
                ],
                [
                    3,
                    " if ( avctx == avctx_from ) return 0 ;\n"
                ],
                [
                    6,
                    " memcpy ( dst -> buf_ptrs , src -> buf_ptrs , sizeof ( src -> buf_ptrs ) ) ;\n"
                ],
                [
                    8,
                    " memset ( & dst -> buf_ptrs [ dst -> cur_index ] , 0 , sizeof ( AVFrame ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) {\n"
                ],
                [
                    2,
                    " MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ;\n"
                ],
                [
                    3,
                    " if ( avctx == avctx_from ) return 0 ;\n"
                ],
                [
                    6,
                    " memcpy ( dst -> buf_ptrs , src -> buf_ptrs , sizeof ( src -> buf_ptrs ) ) ;\n"
                ],
                [
                    7,
                    " memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ;\n"
                ],
                [
                    8,
                    " memset ( & dst -> buf_ptrs [ dst -> cur_index ] , 0 , sizeof ( AVFrame ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n FrapsContext * const s = avctx -> priv_data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n AVFrame * frame = data ;\n AVFrame * const f = & s -> frame ;\n uint32_t header ;\n unsigned int version , header_size ;\n unsigned int x , y ;\n const uint32_t * buf32 ;\n uint32_t * luma1 , * luma2 , * cb , * cr ;\n uint32_t offs [ 4 ] ;\n int i , j , ret , is_chroma , planes ;\n enum AVPixelFormat pix_fmt ;\n header = AV_RL32 ( buf ) ;\n version = header & 0xff ;\n header_size = ( header & ( 1 << 30 ) ) ? 8 : 4 ;\n if ( version > 5 ) {\n av_log ( avctx , AV_LOG_ERROR , \"This file is encoded with Fraps version %d. \" \\ \"This codec can only decode versions <= 5.\\n\" , version ) ;\n return AVERROR_PATCHWELCOME ;\n }\n buf += 4 ;\n if ( header_size == 8 ) buf += 4 ;\n pix_fmt = version & 1 ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_YUVJ420P ;\n if ( avctx -> pix_fmt != pix_fmt && f -> data [ 0 ] ) {\n avctx -> release_buffer ( avctx , f ) ;\n }\n avctx -> pix_fmt = pix_fmt ;\n switch ( version ) {\n case 0 : default : if ( ( buf_size != avctx -> width * avctx -> height * 3 / 2 + header_size ) && ( buf_size != header_size ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame length %d (should be %d)\\n\" , buf_size , avctx -> width * avctx -> height * 3 / 2 + header_size ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( ( avctx -> width % 8 ) != 0 ) || ( ( avctx -> height % 2 ) != 0 ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame size %dx%d\\n\" , avctx -> width , avctx -> height ) ;\n return AVERROR_INVALIDDATA ;\n }\n f -> reference = 1 ;\n f -> buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , f ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n f -> pict_type = ( header & ( 1U << 31 ) ) ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I ;\n f -> key_frame = f -> pict_type == AV_PICTURE_TYPE_I ;\n if ( f -> pict_type == AV_PICTURE_TYPE_I ) {\n buf32 = ( const uint32_t * ) buf ;\n for ( y = 0 ;\n y < avctx -> height / 2 ;\n y ++ ) {\n luma1 = ( uint32_t * ) & f -> data [ 0 ] [ y * 2 * f -> linesize [ 0 ] ] ;\n luma2 = ( uint32_t * ) & f -> data [ 0 ] [ ( y * 2 + 1 ) * f -> linesize [ 0 ] ] ;\n cr = ( uint32_t * ) & f -> data [ 1 ] [ y * f -> linesize [ 1 ] ] ;\n cb = ( uint32_t * ) & f -> data [ 2 ] [ y * f -> linesize [ 2 ] ] ;\n for ( x = 0 ;\n x < avctx -> width ;\n x += 8 ) {\n * ( luma1 ++ ) = * ( buf32 ++ ) ;\n * ( luma1 ++ ) = * ( buf32 ++ ) ;\n * ( luma2 ++ ) = * ( buf32 ++ ) ;\n * ( luma2 ++ ) = * ( buf32 ++ ) ;\n * ( cr ++ ) = * ( buf32 ++ ) ;\n * ( cb ++ ) = * ( buf32 ++ ) ;\n }\n }\n }\n break ;\n case 1 : if ( ( buf_size != avctx -> width * avctx -> height * 3 + header_size ) && ( buf_size != header_size ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame length %d (should be %d)\\n\" , buf_size , avctx -> width * avctx -> height * 3 + header_size ) ;\n return AVERROR_INVALIDDATA ;\n }\n f -> reference = 1 ;\n f -> buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , f ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n f -> pict_type = ( header & ( 1U << 31 ) ) ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I ;\n f -> key_frame = f -> pict_type == AV_PICTURE_TYPE_I ;\n if ( f -> pict_type == AV_PICTURE_TYPE_I ) {\n for ( y = 0 ;\n y < avctx -> height ;\n y ++ ) memcpy ( & f -> data [ 0 ] [ ( avctx -> height - y - 1 ) * f -> linesize [ 0 ] ] , & buf [ y * avctx -> width * 3 ] , 3 * avctx -> width ) ;\n }\n break ;\n case 2 : case 4 : planes = 3 ;\n f -> reference = 1 ;\n f -> buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , f ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( buf_size == 8 ) {\n f -> pict_type = AV_PICTURE_TYPE_P ;\n f -> key_frame = 0 ;\n break ;\n }\n f -> pict_type = AV_PICTURE_TYPE_I ;\n f -> key_frame = 1 ;\n if ( ( AV_RL32 ( buf ) != FPS_TAG ) || ( buf_size < ( planes * 1024 + 24 ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Fraps: error in data stream\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < planes ;\n i ++ ) {\n offs [ i ] = AV_RL32 ( buf + 4 + i * 4 ) ;\n if ( offs [ i ] >= buf_size || ( i && offs [ i ] <= offs [ i - 1 ] + 1024 ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Fraps: plane %i offset is out of bounds\\n\" , i ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n offs [ planes ] = buf_size ;\n for ( i = 0 ;\n i < planes ;\n i ++ ) {\n is_chroma = ! ! i ;\n av_fast_padded_malloc ( & s -> tmpbuf , & s -> tmpbuf_size , offs [ i + 1 ] - offs [ i ] - 1024 ) ;\n if ( ! s -> tmpbuf ) return AVERROR ( ENOMEM ) ;\n if ( ( ret = fraps2_decode_plane ( s , f -> data [ i ] , f -> linesize [ i ] , avctx -> width >> is_chroma , avctx -> height >> is_chroma , buf + offs [ i ] , offs [ i + 1 ] - offs [ i ] , is_chroma , 1 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding plane %i\\n\" , i ) ;\n return ret ;\n }\n }\n break ;\n case 3 : case 5 : planes = 3 ;\n f -> reference = 1 ;\n f -> buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , f ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( buf_size == 8 ) {\n f -> pict_type = AV_PICTURE_TYPE_P ;\n f -> key_frame = 0 ;\n break ;\n }\n f -> pict_type = AV_PICTURE_TYPE_I ;\n f -> key_frame = 1 ;\n if ( ( AV_RL32 ( buf ) != FPS_TAG ) || ( buf_size < ( planes * 1024 + 24 ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Fraps: error in data stream\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < planes ;\n i ++ ) {\n offs [ i ] = AV_RL32 ( buf + 4 + i * 4 ) ;\n if ( offs [ i ] >= buf_size || ( i && offs [ i ] <= offs [ i - 1 ] + 1024 ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Fraps: plane %i offset is out of bounds\\n\" , i ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n offs [ planes ] = buf_size ;\n for ( i = 0 ;\n i < planes ;\n i ++ ) {\n av_fast_padded_malloc ( & s -> tmpbuf , & s -> tmpbuf_size , offs [ i + 1 ] - offs [ i ] - 1024 ) ;\n if ( ! s -> tmpbuf ) return AVERROR ( ENOMEM ) ;\n if ( ( ret = fraps2_decode_plane ( s , f -> data [ 0 ] + i + ( f -> linesize [ 0 ] * ( avctx -> height - 1 ) ) , - f -> linesize [ 0 ] , avctx -> width , avctx -> height , buf + offs [ i ] , offs [ i + 1 ] - offs [ i ] , 0 , 3 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding plane %i\\n\" , i ) ;\n return ret ;\n }\n }\n for ( j = 0 ;\n j < avctx -> height ;\n j ++ ) {\n for ( i = 0 ;\n i < avctx -> width ;\n i ++ ) {\n f -> data [ 0 ] [ 0 + i * 3 + j * f -> linesize [ 0 ] ] += f -> data [ 0 ] [ 1 + i * 3 + j * f -> linesize [ 0 ] ] ;\n f -> data [ 0 ] [ 2 + i * 3 + j * f -> linesize [ 0 ] ] += f -> data [ 0 ] [ 1 + i * 3 + j * f -> linesize [ 0 ] ] ;\n }\n }\n break ;\n }\n * frame = * f ;\n * got_frame = 1 ;\n return buf_size ;\n }",
        "hash": 7698410135314428663,
        "project": "debian",
        "size": 179,
        "slice": {
            "memcpy": [
                [
                    22,
                    " buf += 4 ;\n"
                ],
                [
                    23,
                    " if ( header_size == 8 ) buf += 4 ;\n"
                ],
                [
                    25,
                    " if ( avctx -> pix_fmt != pix_fmt && f -> data [ 0 ] ) {\n"
                ],
                [
                    82,
                    " y < avctx -> height ;\n"
                ],
                [
                    83,
                    " y ++ ) memcpy ( & f -> data [ 0 ] [ ( avctx -> height - y - 1 ) * f -> linesize [ 0 ] ] , & buf [ y * avctx -> width * 3 ] , 3 * avctx -> width ) ;\n"
                ]
            ],
            "result": [
                [
                    22,
                    " buf += 4 ;\n"
                ],
                [
                    23,
                    " if ( header_size == 8 ) buf += 4 ;\n"
                ],
                [
                    25,
                    " if ( avctx -> pix_fmt != pix_fmt && f -> data [ 0 ] ) {\n"
                ],
                [
                    82,
                    " y < avctx -> height ;\n"
                ],
                [
                    83,
                    " y ++ ) memcpy ( & f -> data [ 0 ] [ ( avctx -> height - y - 1 ) * f -> linesize [ 0 ] ] , & buf [ y * avctx -> width * 3 ] , 3 * avctx -> width ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( WMAProDecodeCtx * s , AVFrame * frame , int * got_frame_ptr ) {\n AVCodecContext * avctx = s -> avctx ;\n GetBitContext * gb = & s -> gb ;\n int more_frames = 0 ;\n int len = 0 ;\n int i , ret ;\n if ( s -> len_prefix ) len = get_bits ( gb , s -> log2_frame_size ) ;\n av_dlog ( s -> avctx , \"decoding frame with length %x\\n\" , len ) ;\n if ( decode_tilehdr ( s ) ) {\n s -> packet_loss = 1 ;\n return 0 ;\n }\n if ( s -> avctx -> channels > 1 && get_bits1 ( gb ) ) {\n if ( get_bits1 ( gb ) ) {\n for ( i = 0 ;\n i < avctx -> channels * avctx -> channels ;\n i ++ ) skip_bits ( gb , 4 ) ;\n }\n }\n if ( s -> dynamic_range_compression ) {\n s -> drc_gain = get_bits ( gb , 8 ) ;\n av_dlog ( s -> avctx , \"drc_gain %i\\n\" , s -> drc_gain ) ;\n }\n if ( get_bits1 ( gb ) ) {\n int av_unused skip ;\n if ( get_bits1 ( gb ) ) {\n skip = get_bits ( gb , av_log2 ( s -> samples_per_frame * 2 ) ) ;\n av_dlog ( s -> avctx , \"start skip: %i\\n\" , skip ) ;\n }\n if ( get_bits1 ( gb ) ) {\n skip = get_bits ( gb , av_log2 ( s -> samples_per_frame * 2 ) ) ;\n av_dlog ( s -> avctx , \"end skip: %i\\n\" , skip ) ;\n }\n }\n av_dlog ( s -> avctx , \"BITSTREAM: frame header length was %i\\n\" , get_bits_count ( gb ) - s -> frame_offset ) ;\n s -> parsed_all_subframes = 0 ;\n for ( i = 0 ;\n i < avctx -> channels ;\n i ++ ) {\n s -> channel [ i ] . decoded_samples = 0 ;\n s -> channel [ i ] . cur_subframe = 0 ;\n s -> channel [ i ] . reuse_sf = 0 ;\n }\n while ( ! s -> parsed_all_subframes ) {\n if ( decode_subframe ( s ) < 0 ) {\n s -> packet_loss = 1 ;\n return 0 ;\n }\n }\n frame -> nb_samples = s -> samples_per_frame ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n s -> packet_loss = 1 ;\n return 0 ;\n }\n for ( i = 0 ;\n i < avctx -> channels ;\n i ++ ) memcpy ( frame -> extended_data [ i ] , s -> channel [ i ] . out , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) ) ;\n for ( i = 0 ;\n i < avctx -> channels ;\n i ++ ) {\n memcpy ( & s -> channel [ i ] . out [ 0 ] , & s -> channel [ i ] . out [ s -> samples_per_frame ] , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) >> 1 ) ;\n }\n if ( s -> skip_frame ) {\n s -> skip_frame = 0 ;\n * got_frame_ptr = 0 ;\n }\n else {\n * got_frame_ptr = 1 ;\n }\n if ( s -> len_prefix ) {\n if ( len != ( get_bits_count ( gb ) - s -> frame_offset ) + 2 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"frame[%i] would have to skip %i bits\\n\" , s -> frame_num , len - ( get_bits_count ( gb ) - s -> frame_offset ) - 1 ) ;\n s -> packet_loss = 1 ;\n return 0 ;\n }\n skip_bits_long ( gb , len - ( get_bits_count ( gb ) - s -> frame_offset ) - 1 ) ;\n }\n else {\n while ( get_bits_count ( gb ) < s -> num_saved_bits && get_bits1 ( gb ) == 0 ) {\n }\n }\n more_frames = get_bits1 ( gb ) ;\n ++ s -> frame_num ;\n return more_frames ;\n }",
        "hash": 6664609110189077049,
        "project": "debian",
        "size": 86,
        "slice": {
            "memcpy": [
                [
                    57,
                    " i < avctx -> channels ;\n"
                ],
                [
                    58,
                    " i ++ ) memcpy ( frame -> extended_data [ i ] , s -> channel [ i ] . out , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) ) ;\n"
                ],
                [
                    60,
                    " i < avctx -> channels ;\n"
                ],
                [
                    62,
                    " memcpy ( & s -> channel [ i ] . out [ 0 ] , & s -> channel [ i ] . out [ s -> samples_per_frame ] , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) >> 1 ) ;\n"
                ]
            ],
            "result": [
                [
                    57,
                    " i < avctx -> channels ;\n"
                ],
                [
                    58,
                    " i ++ ) memcpy ( frame -> extended_data [ i ] , s -> channel [ i ] . out , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) ) ;\n"
                ],
                [
                    60,
                    " i < avctx -> channels ;\n"
                ],
                [
                    62,
                    " memcpy ( & s -> channel [ i ] . out [ 0 ] , & s -> channel [ i ] . out [ s -> samples_per_frame ] , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) >> 1 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int ws_snd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int in_size , out_size , ret ;\n int sample = 128 ;\n uint8_t * samples ;\n uint8_t * samples_end ;\n if ( ! buf_size ) return 0 ;\n if ( buf_size < 4 ) {\n av_log ( avctx , AV_LOG_ERROR , \"packet is too small\\n\" ) ;\n return AVERROR ( EINVAL ) ;\n }\n out_size = AV_RL16 ( & buf [ 0 ] ) ;\n in_size = AV_RL16 ( & buf [ 2 ] ) ;\n buf += 4 ;\n if ( in_size > buf_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame data is larger than input buffer\\n\" ) ;\n return - 1 ;\n }\n frame -> nb_samples = out_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = frame -> data [ 0 ] ;\n samples_end = samples + out_size ;\n if ( in_size == out_size ) {\n memcpy ( samples , buf , out_size ) ;\n * got_frame_ptr = 1 ;\n return buf_size ;\n }\n while ( samples < samples_end && buf - avpkt -> data < buf_size ) {\n int code , smp , size ;\n uint8_t count ;\n code = * buf >> 6 ;\n count = * buf & 0x3F ;\n buf ++ ;\n switch ( code ) {\n case 0 : smp = 4 * ( count + 1 ) ;\n break ;\n case 1 : smp = 2 * ( count + 1 ) ;\n break ;\n case 2 : smp = ( count & 0x20 ) ? 1 : count + 1 ;\n break ;\n default : smp = count + 1 ;\n break ;\n }\n if ( samples_end - samples < smp ) break ;\n size = ( ( code == 2 && ( count & 0x20 ) ) || code == 3 ) ? 0 : count + 1 ;\n if ( ( buf - avpkt -> data ) + size > buf_size ) break ;\n switch ( code ) {\n case 0 : for ( count ++ ;\n count > 0 ;\n count -- ) {\n code = * buf ++ ;\n sample += ( code & 0x3 ) - 2 ;\n sample = av_clip_uint8 ( sample ) ;\n * samples ++ = sample ;\n sample += ( ( code >> 2 ) & 0x3 ) - 2 ;\n sample = av_clip_uint8 ( sample ) ;\n * samples ++ = sample ;\n sample += ( ( code >> 4 ) & 0x3 ) - 2 ;\n sample = av_clip_uint8 ( sample ) ;\n * samples ++ = sample ;\n sample += ( code >> 6 ) - 2 ;\n sample = av_clip_uint8 ( sample ) ;\n * samples ++ = sample ;\n }\n break ;\n case 1 : for ( count ++ ;\n count > 0 ;\n count -- ) {\n code = * buf ++ ;\n sample += ws_adpcm_4bit [ code & 0xF ] ;\n sample = av_clip_uint8 ( sample ) ;\n * samples ++ = sample ;\n sample += ws_adpcm_4bit [ code >> 4 ] ;\n sample = av_clip_uint8 ( sample ) ;\n * samples ++ = sample ;\n }\n break ;\n case 2 : if ( count & 0x20 ) {\n int8_t t ;\n t = count ;\n t <<= 3 ;\n sample += t >> 3 ;\n sample = av_clip_uint8 ( sample ) ;\n * samples ++ = sample ;\n }\n else {\n memcpy ( samples , buf , smp ) ;\n samples += smp ;\n buf += smp ;\n sample = buf [ - 1 ] ;\n }\n break ;\n default : memset ( samples , sample , smp ) ;\n samples += smp ;\n }\n }\n frame -> nb_samples = samples - frame -> data [ 0 ] ;\n * got_frame_ptr = 1 ;\n return buf_size ;\n }",
        "hash": 2669106500597708495,
        "project": "debian",
        "size": 105,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int ws_snd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    16,
                    " buf += 4 ;\n"
                ],
                [
                    26,
                    " samples = frame -> data [ 0 ] ;\n"
                ],
                [
                    28,
                    " if ( in_size == out_size ) {\n"
                ],
                [
                    29,
                    " memcpy ( samples , buf , out_size ) ;\n"
                ],
                [
                    37,
                    " count = * buf & 0x3F ;\n"
                ],
                [
                    49,
                    " if ( samples_end - samples < smp ) break ;\n"
                ],
                [
                    51,
                    " if ( ( buf - avpkt -> data ) + size > buf_size ) break ;\n"
                ],
                [
                    83,
                    " case 2 : if ( count & 0x20 ) {\n"
                ],
                [
                    92,
                    " memcpy ( samples , buf , smp ) ;\n"
                ],
                [
                    93,
                    " samples += smp ;\n"
                ],
                [
                    94,
                    " buf += smp ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int ws_snd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    6,
                    " int sample = 128 ;\n"
                ],
                [
                    49,
                    " if ( samples_end - samples < smp ) break ;\n"
                ],
                [
                    52,
                    " switch ( code ) {\n"
                ],
                [
                    57,
                    " sample += ( code & 0x3 ) - 2 ;\n"
                ],
                [
                    67,
                    " sample = av_clip_uint8 ( sample ) ;\n"
                ],
                [
                    75,
                    " sample += ws_adpcm_4bit [ code & 0xF ] ;\n"
                ],
                [
                    79,
                    " sample = av_clip_uint8 ( sample ) ;\n"
                ],
                [
                    87,
                    " sample += t >> 3 ;\n"
                ],
                [
                    88,
                    " sample = av_clip_uint8 ( sample ) ;\n"
                ],
                [
                    95,
                    " sample = buf [ - 1 ] ;\n"
                ],
                [
                    98,
                    " default : memset ( samples , sample , smp ) ;\n"
                ],
                [
                    99,
                    " samples += smp ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ws_snd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    6,
                    " int sample = 128 ;\n"
                ],
                [
                    16,
                    " buf += 4 ;\n"
                ],
                [
                    26,
                    " samples = frame -> data [ 0 ] ;\n"
                ],
                [
                    28,
                    " if ( in_size == out_size ) {\n"
                ],
                [
                    29,
                    " memcpy ( samples , buf , out_size ) ;\n"
                ],
                [
                    37,
                    " count = * buf & 0x3F ;\n"
                ],
                [
                    49,
                    " if ( samples_end - samples < smp ) break ;\n"
                ],
                [
                    51,
                    " if ( ( buf - avpkt -> data ) + size > buf_size ) break ;\n"
                ],
                [
                    52,
                    " switch ( code ) {\n"
                ],
                [
                    57,
                    " sample += ( code & 0x3 ) - 2 ;\n"
                ],
                [
                    67,
                    " sample = av_clip_uint8 ( sample ) ;\n"
                ],
                [
                    75,
                    " sample += ws_adpcm_4bit [ code & 0xF ] ;\n"
                ],
                [
                    79,
                    " sample = av_clip_uint8 ( sample ) ;\n"
                ],
                [
                    83,
                    " case 2 : if ( count & 0x20 ) {\n"
                ],
                [
                    87,
                    " sample += t >> 3 ;\n"
                ],
                [
                    88,
                    " sample = av_clip_uint8 ( sample ) ;\n"
                ],
                [
                    92,
                    " memcpy ( samples , buf , smp ) ;\n"
                ],
                [
                    93,
                    " samples += smp ;\n"
                ],
                [
                    94,
                    " buf += smp ;\n"
                ],
                [
                    95,
                    " sample = buf [ - 1 ] ;\n"
                ],
                [
                    98,
                    " default : memset ( samples , sample , smp ) ;\n"
                ],
                [
                    99,
                    " samples += smp ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int eightsvx_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n EightSvxContext * esc = avctx -> priv_data ;\n AVFrame * frame = data ;\n int buf_size ;\n int ch , ret ;\n int is_compr = ( avctx -> codec_id != AV_CODEC_ID_PCM_S8_PLANAR ) ;\n if ( avpkt -> data ) {\n int hdr_size = is_compr ? 2 : 0 ;\n int chan_size = ( avpkt -> size - hdr_size * avctx -> channels ) / avctx -> channels ;\n if ( avpkt -> size < hdr_size * avctx -> channels ) {\n av_log ( avctx , AV_LOG_ERROR , \"packet size is too small\\n\" ) ;\n return AVERROR ( EINVAL ) ;\n }\n if ( esc -> data [ 0 ] ) {\n av_log ( avctx , AV_LOG_ERROR , \"unexpected data after first packet\\n\" ) ;\n return AVERROR ( EINVAL ) ;\n }\n if ( is_compr ) {\n esc -> fib_acc [ 0 ] = avpkt -> data [ 1 ] + 128 ;\n if ( avctx -> channels == 2 ) esc -> fib_acc [ 1 ] = avpkt -> data [ 2 + chan_size + 1 ] + 128 ;\n }\n esc -> data_idx = 0 ;\n esc -> data_size = chan_size ;\n if ( ! ( esc -> data [ 0 ] = av_malloc ( chan_size ) ) ) return AVERROR ( ENOMEM ) ;\n if ( avctx -> channels == 2 ) {\n if ( ! ( esc -> data [ 1 ] = av_malloc ( chan_size ) ) ) {\n av_freep ( & esc -> data [ 0 ] ) ;\n return AVERROR ( ENOMEM ) ;\n }\n }\n memcpy ( esc -> data [ 0 ] , & avpkt -> data [ hdr_size ] , chan_size ) ;\n if ( avctx -> channels == 2 ) memcpy ( esc -> data [ 1 ] , & avpkt -> data [ 2 * hdr_size + chan_size ] , chan_size ) ;\n }\n if ( ! esc -> data [ 0 ] ) {\n av_log ( avctx , AV_LOG_ERROR , \"unexpected empty packet\\n\" ) ;\n return AVERROR ( EINVAL ) ;\n }\n buf_size = FFMIN ( MAX_FRAME_SIZE , esc -> data_size - esc -> data_idx ) ;\n if ( buf_size <= 0 ) {\n * got_frame_ptr = 0 ;\n return avpkt -> size ;\n }\n frame -> nb_samples = buf_size * ( is_compr + 1 ) ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n for ( ch = 0 ;\n ch < avctx -> channels ;\n ch ++ ) {\n if ( is_compr ) {\n delta_decode ( frame -> data [ ch ] , & esc -> data [ ch ] [ esc -> data_idx ] , buf_size , & esc -> fib_acc [ ch ] , esc -> table ) ;\n }\n else {\n raw_decode ( frame -> data [ ch ] , & esc -> data [ ch ] [ esc -> data_idx ] , buf_size ) ;\n }\n }\n esc -> data_idx += buf_size ;\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }",
        "hash": 7442680289895575823,
        "project": "debian",
        "size": 61,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int eightsvx_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    24,
                    " if ( ! ( esc -> data [ 0 ] = av_malloc ( chan_size ) ) ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    25,
                    " if ( avctx -> channels == 2 ) {\n"
                ],
                [
                    26,
                    " if ( ! ( esc -> data [ 1 ] = av_malloc ( chan_size ) ) ) {\n"
                ],
                [
                    31,
                    " memcpy ( esc -> data [ 0 ] , & avpkt -> data [ hdr_size ] , chan_size ) ;\n"
                ],
                [
                    32,
                    " if ( avctx -> channels == 2 ) memcpy ( esc -> data [ 1 ] , & avpkt -> data [ 2 * hdr_size + chan_size ] , chan_size ) ;\n"
                ],
                [
                    34,
                    " if ( ! esc -> data [ 0 ] ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int eightsvx_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    24,
                    " if ( ! ( esc -> data [ 0 ] = av_malloc ( chan_size ) ) ) return AVERROR ( ENOMEM ) ;\n"
                ],
                [
                    25,
                    " if ( avctx -> channels == 2 ) {\n"
                ],
                [
                    26,
                    " if ( ! ( esc -> data [ 1 ] = av_malloc ( chan_size ) ) ) {\n"
                ],
                [
                    31,
                    " memcpy ( esc -> data [ 0 ] , & avpkt -> data [ hdr_size ] , chan_size ) ;\n"
                ],
                [
                    32,
                    " if ( avctx -> channels == 2 ) memcpy ( esc -> data [ 1 ] , & avpkt -> data [ 2 * hdr_size + chan_size ] , chan_size ) ;\n"
                ],
                [
                    34,
                    " if ( ! esc -> data [ 0 ] ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s ) {\n int y ;\n unsigned char P [ 2 ] ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ;\n memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ;\n s -> pixel_ptr += s -> stride ;\n }\n return 0 ;\n }",
        "hash": -1983921383858884161,
        "project": "debian",
        "size": 16,
        "slice": {
            "memset": [
                [
                    1,
                    "static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s ) {\n"
                ],
                [
                    3,
                    " unsigned char P [ 2 ] ;\n"
                ],
                [
                    5,
                    " y < 8 ;\n"
                ],
                [
                    8,
                    " P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n"
                ],
                [
                    9,
                    " P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n"
                ],
                [
                    11,
                    " memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ;\n"
                ],
                [
                    12,
                    " memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ;\n"
                ],
                [
                    13,
                    " s -> pixel_ptr += s -> stride ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s ) {\n"
                ],
                [
                    3,
                    " unsigned char P [ 2 ] ;\n"
                ],
                [
                    5,
                    " y < 8 ;\n"
                ],
                [
                    8,
                    " P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n"
                ],
                [
                    9,
                    " P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n"
                ],
                [
                    11,
                    " memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ;\n"
                ],
                [
                    12,
                    " memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ;\n"
                ],
                [
                    13,
                    " s -> pixel_ptr += s -> stride ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) {\n int y ;\n unsigned char pix ;\n pix = bytestream2_get_byte ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n memset ( s -> pixel_ptr , pix , 8 ) ;\n s -> pixel_ptr += s -> stride ;\n }\n return 0 ;\n }",
        "hash": -1983921383858884161,
        "project": "debian",
        "size": 12,
        "slice": {
            "memset": [
                [
                    1,
                    "static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) {\n"
                ],
                [
                    4,
                    " pix = bytestream2_get_byte ( & s -> stream_ptr ) ;\n"
                ],
                [
                    6,
                    " y < 8 ;\n"
                ],
                [
                    8,
                    " memset ( s -> pixel_ptr , pix , 8 ) ;\n"
                ],
                [
                    9,
                    " s -> pixel_ptr += s -> stride ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) {\n"
                ],
                [
                    4,
                    " pix = bytestream2_get_byte ( & s -> stream_ptr ) ;\n"
                ],
                [
                    6,
                    " y < 8 ;\n"
                ],
                [
                    8,
                    " memset ( s -> pixel_ptr , pix , 8 ) ;\n"
                ],
                [
                    9,
                    " s -> pixel_ptr += s -> stride ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int ipvideo_decode_block_opcode_0xA_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t P [ 8 ] ;\n int flags = 0 ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( x = 0 ;\n x < 4 ;\n x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 0 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n if ( y ) for ( x = 0 ;\n x < 4 ;\n x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n }\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) pixel_ptr -= 8 * s -> stride - 4 ;\n }\n }\n else {\n int vert ;\n uint64_t flags = bytestream2_get_le64 ( & s -> stream_ptr ) ;\n for ( x = 4 ;\n x < 8 ;\n x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n vert = ! ( P [ 4 ] & 0x8000 ) ;\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n if ( vert ) {\n pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) pixel_ptr -= 8 * s -> stride - 4 ;\n }\n else if ( y & 1 ) pixel_ptr += s -> line_inc ;\n if ( y == 7 ) {\n memcpy ( P , P + 4 , 8 ) ;\n flags = bytestream2_get_le64 ( & s -> stream_ptr ) ;\n }\n }\n }\n return 0 ;\n }",
        "hash": -1983921383858884161,
        "project": "debian",
        "size": 51,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int ipvideo_decode_block_opcode_0xA_16 ( IpvideoContext * s ) {\n"
                ],
                [
                    3,
                    " uint16_t P [ 8 ] ;\n"
                ],
                [
                    8,
                    " x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n"
                ],
                [
                    9,
                    " if ( ! ( P [ 0 ] & 0x8000 ) ) {\n"
                ],
                [
                    31,
                    " x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n"
                ],
                [
                    32,
                    " vert = ! ( P [ 4 ] & 0x8000 ) ;\n"
                ],
                [
                    38,
                    " x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n"
                ],
                [
                    44,
                    " if ( y == 7 ) {\n"
                ],
                [
                    45,
                    " memcpy ( P , P + 4 , 8 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ipvideo_decode_block_opcode_0xA_16 ( IpvideoContext * s ) {\n"
                ],
                [
                    3,
                    " uint16_t P [ 8 ] ;\n"
                ],
                [
                    8,
                    " x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n"
                ],
                [
                    9,
                    " if ( ! ( P [ 0 ] & 0x8000 ) ) {\n"
                ],
                [
                    31,
                    " x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n"
                ],
                [
                    32,
                    " vert = ! ( P [ 4 ] & 0x8000 ) ;\n"
                ],
                [
                    38,
                    " x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n"
                ],
                [
                    44,
                    " if ( y == 7 ) {\n"
                ],
                [
                    45,
                    " memcpy ( P , P + 4 , 8 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void ipvideo_decode_opcodes ( IpvideoContext * s ) {\n int x , y ;\n unsigned char opcode ;\n int ret ;\n GetBitContext gb ;\n bytestream2_skip ( & s -> stream_ptr , 14 ) ;\n if ( ! s -> is_16bpp ) {\n memcpy ( s -> current_frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n s -> stride = s -> current_frame . linesize [ 0 ] ;\n }\n else {\n s -> stride = s -> current_frame . linesize [ 0 ] >> 1 ;\n s -> mv_ptr = s -> stream_ptr ;\n bytestream2_skip ( & s -> mv_ptr , bytestream2_get_le16 ( & s -> stream_ptr ) ) ;\n }\n s -> line_inc = s -> stride - 8 ;\n s -> upper_motion_limit_offset = ( s -> avctx -> height - 8 ) * s -> current_frame . linesize [ 0 ] + ( s -> avctx -> width - 8 ) * ( 1 + s -> is_16bpp ) ;\n init_get_bits ( & gb , s -> decoding_map , s -> decoding_map_size * 8 ) ;\n for ( y = 0 ;\n y < s -> avctx -> height ;\n y += 8 ) {\n for ( x = 0 ;\n x < s -> avctx -> width ;\n x += 8 ) {\n opcode = get_bits ( & gb , 4 ) ;\n av_dlog ( s -> avctx , \" block @ (%3d, %3d): encoding 0x%X, data ptr offset %d\\n\" , x , y , opcode , bytestream2_tell ( & s -> stream_ptr ) ) ;\n if ( ! s -> is_16bpp ) {\n s -> pixel_ptr = s -> current_frame . data [ 0 ] + x + y * s -> current_frame . linesize [ 0 ] ;\n ret = ipvideo_decode_block [ opcode ] ( s ) ;\n }\n else {\n s -> pixel_ptr = s -> current_frame . data [ 0 ] + x * 2 + y * s -> current_frame . linesize [ 0 ] ;\n ret = ipvideo_decode_block16 [ opcode ] ( s ) ;\n }\n if ( ret != 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \" Interplay video: decode problem on frame %d, @ block (%d, %d)\\n\" , s -> avctx -> frame_number , x , y ) ;\n return ;\n }\n }\n }\n if ( bytestream2_get_bytes_left ( & s -> stream_ptr ) > 1 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Interplay video: decode finished with %d bytes left over\\n\" , bytestream2_get_bytes_left ( & s -> stream_ptr ) ) ;\n }\n }",
        "hash": -1983921383858884161,
        "project": "debian",
        "size": 44,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void ipvideo_decode_opcodes ( IpvideoContext * s ) {\n"
                ],
                [
                    7,
                    " if ( ! s -> is_16bpp ) {\n"
                ],
                [
                    8,
                    " memcpy ( s -> current_frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    29,
                    " ret = ipvideo_decode_block [ opcode ] ( s ) ;\n"
                ],
                [
                    33,
                    " ret = ipvideo_decode_block16 [ opcode ] ( s ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void ipvideo_decode_opcodes ( IpvideoContext * s ) {\n"
                ],
                [
                    7,
                    " if ( ! s -> is_16bpp ) {\n"
                ],
                [
                    8,
                    " memcpy ( s -> current_frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    29,
                    " ret = ipvideo_decode_block [ opcode ] ( s ) ;\n"
                ],
                [
                    33,
                    " ret = ipvideo_decode_block16 [ opcode ] ( s ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int ipvideo_decode_block_opcode_0xA ( IpvideoContext * s ) {\n int x , y ;\n unsigned char P [ 8 ] ;\n int flags = 0 ;\n bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ;\n if ( P [ 0 ] <= P [ 1 ] ) {\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n if ( y ) bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ;\n flags = bytestream2_get_le32 ( & s -> stream_ptr ) ;\n }\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 2 ) * s -> pixel_ptr ++ = P [ flags & 0x03 ] ;\n s -> pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ;\n }\n }\n else {\n int vert ;\n uint64_t flags = bytestream2_get_le64 ( & s -> stream_ptr ) ;\n bytestream2_get_buffer ( & s -> stream_ptr , P + 4 , 4 ) ;\n vert = P [ 4 ] <= P [ 5 ] ;\n for ( y = 0 ;\n y < 16 ;\n y ++ ) {\n for ( x = 0 ;\n x < 4 ;\n x ++ , flags >>= 2 ) * s -> pixel_ptr ++ = P [ flags & 0x03 ] ;\n if ( vert ) {\n s -> pixel_ptr += s -> stride - 4 ;\n if ( y == 7 ) s -> pixel_ptr -= 8 * s -> stride - 4 ;\n }\n else if ( y & 1 ) s -> pixel_ptr += s -> line_inc ;\n if ( y == 7 ) {\n memcpy ( P , P + 4 , 4 ) ;\n flags = bytestream2_get_le64 ( & s -> stream_ptr ) ;\n }\n }\n }\n return 0 ;\n }",
        "hash": -1983921383858884161,
        "project": "debian",
        "size": 44,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int ipvideo_decode_block_opcode_0xA ( IpvideoContext * s ) {\n"
                ],
                [
                    5,
                    " bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ;\n"
                ],
                [
                    6,
                    " if ( P [ 0 ] <= P [ 1 ] ) {\n"
                ],
                [
                    25,
                    " vert = P [ 4 ] <= P [ 5 ] ;\n"
                ],
                [
                    31,
                    " x ++ , flags >>= 2 ) * s -> pixel_ptr ++ = P [ flags & 0x03 ] ;\n"
                ],
                [
                    37,
                    " if ( y == 7 ) {\n"
                ],
                [
                    38,
                    " memcpy ( P , P + 4 , 4 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ipvideo_decode_block_opcode_0xA ( IpvideoContext * s ) {\n"
                ],
                [
                    5,
                    " bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ;\n"
                ],
                [
                    6,
                    " if ( P [ 0 ] <= P [ 1 ] ) {\n"
                ],
                [
                    25,
                    " vert = P [ 4 ] <= P [ 5 ] ;\n"
                ],
                [
                    31,
                    " x ++ , flags >>= 2 ) * s -> pixel_ptr ++ = P [ flags & 0x03 ] ;\n"
                ],
                [
                    37,
                    " if ( y == 7 ) {\n"
                ],
                [
                    38,
                    " memcpy ( P , P + 4 , 4 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int ipvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n IpvideoContext * s = avctx -> priv_data ;\n int ret ;\n s -> decoding_map_size = avctx -> width * avctx -> height / ( 8 * 8 * 2 ) ;\n if ( buf_size < s -> decoding_map_size ) return buf_size ;\n s -> decoding_map = buf ;\n bytestream2_init ( & s -> stream_ptr , buf + s -> decoding_map_size , buf_size - s -> decoding_map_size ) ;\n s -> current_frame . reference = 3 ;\n if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \" Interplay Video: get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( ! s -> is_16bpp ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> current_frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n }\n ipvideo_decode_opcodes ( s ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> current_frame ;\n if ( s -> second_last_frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> second_last_frame ) ;\n s -> second_last_frame = s -> last_frame ;\n s -> last_frame = s -> current_frame ;\n s -> current_frame . data [ 0 ] = NULL ;\n return buf_size ;\n }",
        "hash": -1983921383858884161,
        "project": "debian",
        "size": 30,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int ipvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " IpvideoContext * s = avctx -> priv_data ;\n"
                ],
                [
                    16,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    17,
                    " if ( pal ) {\n"
                ],
                [
                    19,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    22,
                    " ipvideo_decode_opcodes ( s ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ipvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " IpvideoContext * s = avctx -> priv_data ;\n"
                ],
                [
                    16,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    17,
                    " if ( pal ) {\n"
                ],
                [
                    19,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    22,
                    " ipvideo_decode_opcodes ( s ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mss2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MSS2Context * ctx = avctx -> priv_data ;\n MSS12Context * c = & ctx -> c ;\n GetBitContext gb ;\n GetByteContext gB ;\n ArithCoder acoder ;\n int keyframe , has_wmv9 , has_mv , is_rle , is_555 , ret ;\n Rectangle wmv9rects [ MAX_WMV9_RECTANGLES ] , * r ;\n int used_rects = 0 , i , implicit_rect = 0 , av_uninit ( wmv9_mask ) ;\n av_assert0 ( FF_INPUT_BUFFER_PADDING_SIZE >= ARITH2_PADDING + ( MIN_CACHE_BITS + 7 ) / 8 ) ;\n init_get_bits ( & gb , buf , buf_size * 8 ) ;\n if ( keyframe = get_bits1 ( & gb ) ) skip_bits ( & gb , 7 ) ;\n has_wmv9 = get_bits1 ( & gb ) ;\n has_mv = keyframe ? 0 : get_bits1 ( & gb ) ;\n is_rle = get_bits1 ( & gb ) ;\n is_555 = is_rle && get_bits1 ( & gb ) ;\n if ( c -> slice_split > 0 ) ctx -> split_position = c -> slice_split ;\n else if ( c -> slice_split < 0 ) {\n if ( get_bits1 ( & gb ) ) {\n if ( get_bits1 ( & gb ) ) {\n if ( get_bits1 ( & gb ) ) ctx -> split_position = get_bits ( & gb , 16 ) ;\n else ctx -> split_position = get_bits ( & gb , 12 ) ;\n }\n else ctx -> split_position = get_bits ( & gb , 8 ) << 4 ;\n }\n else {\n if ( keyframe ) ctx -> split_position = avctx -> height / 2 ;\n }\n }\n else ctx -> split_position = avctx -> height ;\n if ( c -> slice_split && ( ctx -> split_position < 1 - is_555 || ctx -> split_position > avctx -> height - 1 ) ) return AVERROR_INVALIDDATA ;\n align_get_bits ( & gb ) ;\n buf += get_bits_count ( & gb ) >> 3 ;\n buf_size -= get_bits_count ( & gb ) >> 3 ;\n if ( buf_size < 1 ) return AVERROR_INVALIDDATA ;\n if ( is_555 && ( has_wmv9 || has_mv || c -> slice_split && ctx -> split_position ) ) return AVERROR_INVALIDDATA ;\n avctx -> pix_fmt = is_555 ? AV_PIX_FMT_RGB555 : AV_PIX_FMT_RGB24 ;\n if ( ctx -> pic . data [ 0 ] && ctx -> pic . format != avctx -> pix_fmt ) avctx -> release_buffer ( avctx , & ctx -> pic ) ;\n if ( has_wmv9 ) {\n bytestream2_init ( & gB , buf , buf_size + ARITH2_PADDING ) ;\n arith2_init ( & acoder , & gB ) ;\n implicit_rect = ! arith2_get_bit ( & acoder ) ;\n while ( arith2_get_bit ( & acoder ) ) {\n if ( used_rects == MAX_WMV9_RECTANGLES ) return AVERROR_INVALIDDATA ;\n r = & wmv9rects [ used_rects ] ;\n if ( ! used_rects ) r -> x = arith2_get_number ( & acoder , avctx -> width ) ;\n else r -> x = arith2_get_number ( & acoder , avctx -> width - wmv9rects [ used_rects - 1 ] . x ) + wmv9rects [ used_rects - 1 ] . x ;\n r -> y = arith2_get_number ( & acoder , avctx -> height ) ;\n r -> w = arith2_get_number ( & acoder , avctx -> width - r -> x ) + 1 ;\n r -> h = arith2_get_number ( & acoder , avctx -> height - r -> y ) + 1 ;\n used_rects ++ ;\n }\n if ( implicit_rect && used_rects ) {\n av_log ( avctx , AV_LOG_ERROR , \"implicit_rect && used_rects > 0\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( implicit_rect ) {\n wmv9rects [ 0 ] . x = 0 ;\n wmv9rects [ 0 ] . y = 0 ;\n wmv9rects [ 0 ] . w = avctx -> width ;\n wmv9rects [ 0 ] . h = avctx -> height ;\n used_rects = 1 ;\n }\n for ( i = 0 ;\n i < used_rects ;\n i ++ ) {\n if ( ! implicit_rect && arith2_get_bit ( & acoder ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Unexpected grandchildren\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ! i ) {\n wmv9_mask = arith2_get_bit ( & acoder ) - 1 ;\n if ( ! wmv9_mask ) wmv9_mask = arith2_get_number ( & acoder , 256 ) ;\n }\n wmv9rects [ i ] . coded = arith2_get_number ( & acoder , 2 ) ;\n }\n buf += arith2_get_consumed_bytes ( & acoder ) ;\n buf_size -= arith2_get_consumed_bytes ( & acoder ) ;\n if ( buf_size < 1 ) return AVERROR_INVALIDDATA ;\n }\n c -> mvX = c -> mvY = 0 ;\n if ( keyframe && ! is_555 ) {\n if ( ( i = decode_pal_v2 ( c , buf , buf_size ) ) < 0 ) return AVERROR_INVALIDDATA ;\n buf += i ;\n buf_size -= i ;\n }\n else if ( has_mv ) {\n buf += 4 ;\n buf_size -= 4 ;\n if ( buf_size < 1 ) return AVERROR_INVALIDDATA ;\n c -> mvX = AV_RB16 ( buf - 4 ) - avctx -> width ;\n c -> mvY = AV_RB16 ( buf - 2 ) - avctx -> height ;\n }\n if ( c -> mvX < 0 || c -> mvY < 0 ) {\n FFSWAP ( AVFrame , ctx -> pic , ctx -> last_pic ) ;\n FFSWAP ( uint8_t * , c -> pal_pic , c -> last_pal_pic ) ;\n if ( ctx -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & ctx -> pic ) ;\n ctx -> pic . reference = 3 ;\n ctx -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_READABLE | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = ff_get_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( ctx -> last_pic . data [ 0 ] ) {\n av_assert0 ( ctx -> pic . linesize [ 0 ] == ctx -> last_pic . linesize [ 0 ] ) ;\n c -> last_rgb_pic = ctx -> last_pic . data [ 0 ] + ctx -> last_pic . linesize [ 0 ] * ( avctx -> height - 1 ) ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"Missing keyframe\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n else {\n if ( ctx -> last_pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & ctx -> last_pic ) ;\n ctx -> pic . reference = 3 ;\n ctx -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_READABLE | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n c -> last_rgb_pic = NULL ;\n }\n c -> rgb_pic = ctx -> pic . data [ 0 ] + ctx -> pic . linesize [ 0 ] * ( avctx -> height - 1 ) ;\n c -> rgb_stride = - ctx -> pic . linesize [ 0 ] ;\n ctx -> pic . key_frame = keyframe ;\n ctx -> pic . pict_type = keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ;\n if ( is_555 ) {\n bytestream2_init ( & gB , buf , buf_size ) ;\n if ( decode_555 ( & gB , ( uint16_t * ) c -> rgb_pic , c -> rgb_stride >> 1 , keyframe , avctx -> width , avctx -> height ) ) return AVERROR_INVALIDDATA ;\n buf_size -= bytestream2_tell ( & gB ) ;\n }\n else {\n if ( keyframe ) {\n c -> corrupted = 0 ;\n ff_mss12_slicecontext_reset ( & ctx -> sc [ 0 ] ) ;\n if ( c -> slice_split ) ff_mss12_slicecontext_reset ( & ctx -> sc [ 1 ] ) ;\n }\n if ( is_rle ) {\n init_get_bits ( & gb , buf , buf_size * 8 ) ;\n if ( ret = decode_rle ( & gb , c -> pal_pic , c -> pal_stride , c -> rgb_pic , c -> rgb_stride , c -> pal , keyframe , ctx -> split_position , 0 , avctx -> width , avctx -> height ) ) return ret ;\n align_get_bits ( & gb ) ;\n if ( c -> slice_split ) if ( ret = decode_rle ( & gb , c -> pal_pic , c -> pal_stride , c -> rgb_pic , c -> rgb_stride , c -> pal , keyframe , ctx -> split_position , 1 , avctx -> width , avctx -> height ) ) return ret ;\n align_get_bits ( & gb ) ;\n buf += get_bits_count ( & gb ) >> 3 ;\n buf_size -= get_bits_count ( & gb ) >> 3 ;\n }\n else if ( ! implicit_rect || wmv9_mask != - 1 ) {\n if ( c -> corrupted ) return AVERROR_INVALIDDATA ;\n bytestream2_init ( & gB , buf , buf_size + ARITH2_PADDING ) ;\n arith2_init ( & acoder , & gB ) ;\n c -> keyframe = keyframe ;\n if ( c -> corrupted = ff_mss12_decode_rect ( & ctx -> sc [ 0 ] , & acoder , 0 , 0 , avctx -> width , ctx -> split_position ) ) return AVERROR_INVALIDDATA ;\n buf += arith2_get_consumed_bytes ( & acoder ) ;\n buf_size -= arith2_get_consumed_bytes ( & acoder ) ;\n if ( c -> slice_split ) {\n if ( buf_size < 1 ) return AVERROR_INVALIDDATA ;\n bytestream2_init ( & gB , buf , buf_size + ARITH2_PADDING ) ;\n arith2_init ( & acoder , & gB ) ;\n if ( c -> corrupted = ff_mss12_decode_rect ( & ctx -> sc [ 1 ] , & acoder , 0 , ctx -> split_position , avctx -> width , avctx -> height - ctx -> split_position ) ) return AVERROR_INVALIDDATA ;\n buf += arith2_get_consumed_bytes ( & acoder ) ;\n buf_size -= arith2_get_consumed_bytes ( & acoder ) ;\n }\n }\n else memset ( c -> pal_pic , 0 , c -> pal_stride * avctx -> height ) ;\n }\n if ( has_wmv9 ) {\n for ( i = 0 ;\n i < used_rects ;\n i ++ ) {\n int x = wmv9rects [ i ] . x ;\n int y = wmv9rects [ i ] . y ;\n int w = wmv9rects [ i ] . w ;\n int h = wmv9rects [ i ] . h ;\n if ( wmv9rects [ i ] . coded ) {\n int WMV9codedFrameSize ;\n if ( buf_size < 4 || ! ( WMV9codedFrameSize = AV_RL24 ( buf ) ) ) return AVERROR_INVALIDDATA ;\n if ( ret = decode_wmv9 ( avctx , buf + 3 , buf_size - 3 , x , y , w , h , wmv9_mask ) ) return ret ;\n buf += WMV9codedFrameSize + 3 ;\n buf_size -= WMV9codedFrameSize + 3 ;\n }\n else {\n uint8_t * dst = c -> rgb_pic + y * c -> rgb_stride + x * 3 ;\n if ( wmv9_mask != - 1 ) {\n ctx -> dsp . mss2_gray_fill_masked ( dst , c -> rgb_stride , wmv9_mask , c -> pal_pic + y * c -> pal_stride + x , c -> pal_stride , w , h ) ;\n }\n else {\n do {\n memset ( dst , 0x80 , w * 3 ) ;\n dst += c -> rgb_stride ;\n }\n while ( -- h ) ;\n }\n }\n }\n }\n if ( buf_size ) av_log ( avctx , AV_LOG_WARNING , \"buffer not fully consumed\\n\" ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = ctx -> pic ;\n return avpkt -> size ;\n }",
        "hash": -6442559759273439153,
        "project": "debian",
        "size": 202,
        "slice": {
            "memset": [
                [
                    1,
                    "static int mss2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " MSS12Context * c = & ctx -> c ;\n"
                ],
                [
                    85,
                    " if ( ( i = decode_pal_v2 ( c , buf , buf_size ) ) < 0 ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    149,
                    " else if ( ! implicit_rect || wmv9_mask != - 1 ) {\n"
                ],
                [
                    166,
                    " else memset ( c -> pal_pic , 0 , c -> pal_stride * avctx -> height ) ;\n"
                ],
                [
                    184,
                    " uint8_t * dst = c -> rgb_pic + y * c -> rgb_stride + x * 3 ;\n"
                ],
                [
                    185,
                    " if ( wmv9_mask != - 1 ) {\n"
                ],
                [
                    186,
                    " ctx -> dsp . mss2_gray_fill_masked ( dst , c -> rgb_stride , wmv9_mask , c -> pal_pic + y * c -> pal_stride + x , c -> pal_stride , w , h ) ;\n"
                ],
                [
                    190,
                    " memset ( dst , 0x80 , w * 3 ) ;\n"
                ],
                [
                    191,
                    " dst += c -> rgb_stride ;\n"
                ],
                [
                    193,
                    " while ( -- h ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mss2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " MSS12Context * c = & ctx -> c ;\n"
                ],
                [
                    85,
                    " if ( ( i = decode_pal_v2 ( c , buf , buf_size ) ) < 0 ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    149,
                    " else if ( ! implicit_rect || wmv9_mask != - 1 ) {\n"
                ],
                [
                    166,
                    " else memset ( c -> pal_pic , 0 , c -> pal_stride * avctx -> height ) ;\n"
                ],
                [
                    184,
                    " uint8_t * dst = c -> rgb_pic + y * c -> rgb_stride + x * 3 ;\n"
                ],
                [
                    185,
                    " if ( wmv9_mask != - 1 ) {\n"
                ],
                [
                    186,
                    " ctx -> dsp . mss2_gray_fill_masked ( dst , c -> rgb_stride , wmv9_mask , c -> pal_pic + y * c -> pal_stride + x , c -> pal_stride , w , h ) ;\n"
                ],
                [
                    190,
                    " memset ( dst , 0x80 , w * 3 ) ;\n"
                ],
                [
                    191,
                    " dst += c -> rgb_stride ;\n"
                ],
                [
                    193,
                    " while ( -- h ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mjpegb_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MJpegDecodeContext * s = avctx -> priv_data ;\n const uint8_t * buf_end , * buf_ptr ;\n AVFrame * picture = data ;\n GetBitContext hgb ;\n uint32_t dqt_offs , dht_offs , sof_offs , sos_offs , second_field_offs ;\n uint32_t field_size , sod_offs ;\n buf_ptr = buf ;\n buf_end = buf + buf_size ;\n read_header : s -> restart_interval = 0 ;\n s -> restart_count = 0 ;\n s -> mjpb_skiptosod = 0 ;\n if ( buf_end - buf_ptr >= 1 << 28 ) return AVERROR_INVALIDDATA ;\n init_get_bits ( & hgb , buf_ptr , ( buf_end - buf_ptr ) * 8 ) ;\n skip_bits ( & hgb , 32 ) ;\n if ( get_bits_long ( & hgb , 32 ) != MKBETAG ( 'm' , 'j' , 'p' , 'g' ) ) {\n av_log ( avctx , AV_LOG_WARNING , \"not mjpeg-b (bad fourcc)\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n field_size = get_bits_long ( & hgb , 32 ) ;\n av_log ( avctx , AV_LOG_DEBUG , \"field size: 0x%x\\n\" , field_size ) ;\n skip_bits ( & hgb , 32 ) ;\n second_field_offs = read_offs ( avctx , & hgb , buf_end - buf_ptr , \"second_field_offs is %d and size is %d\\n\" ) ;\n av_log ( avctx , AV_LOG_DEBUG , \"second field offs: 0x%x\\n\" , second_field_offs ) ;\n dqt_offs = read_offs ( avctx , & hgb , buf_end - buf_ptr , \"dqt is %d and size is %d\\n\" ) ;\n av_log ( avctx , AV_LOG_DEBUG , \"dqt offs: 0x%x\\n\" , dqt_offs ) ;\n if ( dqt_offs ) {\n init_get_bits ( & s -> gb , buf_ptr + dqt_offs , ( buf_end - ( buf_ptr + dqt_offs ) ) * 8 ) ;\n s -> start_code = DQT ;\n if ( ff_mjpeg_decode_dqt ( s ) < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return AVERROR_INVALIDDATA ;\n }\n dht_offs = read_offs ( avctx , & hgb , buf_end - buf_ptr , \"dht is %d and size is %d\\n\" ) ;\n av_log ( avctx , AV_LOG_DEBUG , \"dht offs: 0x%x\\n\" , dht_offs ) ;\n if ( dht_offs ) {\n init_get_bits ( & s -> gb , buf_ptr + dht_offs , ( buf_end - ( buf_ptr + dht_offs ) ) * 8 ) ;\n s -> start_code = DHT ;\n ff_mjpeg_decode_dht ( s ) ;\n }\n sof_offs = read_offs ( avctx , & hgb , buf_end - buf_ptr , \"sof is %d and size is %d\\n\" ) ;\n av_log ( avctx , AV_LOG_DEBUG , \"sof offs: 0x%x\\n\" , sof_offs ) ;\n if ( sof_offs ) {\n init_get_bits ( & s -> gb , buf_ptr + sof_offs , ( buf_end - ( buf_ptr + sof_offs ) ) * 8 ) ;\n s -> start_code = SOF0 ;\n if ( ff_mjpeg_decode_sof ( s ) < 0 ) return - 1 ;\n }\n sos_offs = read_offs ( avctx , & hgb , buf_end - buf_ptr , \"sos is %d and size is %d\\n\" ) ;\n av_log ( avctx , AV_LOG_DEBUG , \"sos offs: 0x%x\\n\" , sos_offs ) ;\n sod_offs = read_offs ( avctx , & hgb , buf_end - buf_ptr , \"sof is %d and size is %d\\n\" ) ;\n av_log ( avctx , AV_LOG_DEBUG , \"sod offs: 0x%x\\n\" , sod_offs ) ;\n if ( sos_offs ) {\n init_get_bits ( & s -> gb , buf_ptr + sos_offs , 8 * FFMIN ( field_size , buf_end - buf_ptr - sos_offs ) ) ;\n s -> mjpb_skiptosod = ( sod_offs - sos_offs - show_bits ( & s -> gb , 16 ) ) ;\n s -> start_code = SOS ;\n if ( ff_mjpeg_decode_sos ( s , NULL , NULL ) < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) return AVERROR_INVALIDDATA ;\n }\n if ( s -> interlaced ) {\n s -> bottom_field ^= 1 ;\n if ( s -> bottom_field != s -> interlace_polarity && second_field_offs ) {\n buf_ptr = buf + second_field_offs ;\n second_field_offs = 0 ;\n goto read_header ;\n }\n }\n * picture = * s -> picture_ptr ;\n * got_frame = 1 ;\n if ( ! s -> lossless ) {\n picture -> quality = FFMAX3 ( s -> qscale [ 0 ] , s -> qscale [ 1 ] , s -> qscale [ 2 ] ) ;\n picture -> qstride = 0 ;\n picture -> qscale_table = s -> qscale_table ;\n memset ( picture -> qscale_table , picture -> quality , ( s -> width + 15 ) / 16 ) ;\n if ( avctx -> debug & FF_DEBUG_QP ) av_log ( avctx , AV_LOG_DEBUG , \"QP: %d\\n\" , picture -> quality ) ;\n picture -> quality *= FF_QP2LAMBDA ;\n }\n return buf_size ;\n }",
        "hash": 3634807423530492970,
        "project": "debian",
        "size": 77,
        "slice": {
            "memset": [
                [
                    6,
                    " AVFrame * picture = data ;\n"
                ],
                [
                    68,
                    " if ( ! s -> lossless ) {\n"
                ],
                [
                    69,
                    " picture -> quality = FFMAX3 ( s -> qscale [ 0 ] , s -> qscale [ 1 ] , s -> qscale [ 2 ] ) ;\n"
                ],
                [
                    71,
                    " picture -> qscale_table = s -> qscale_table ;\n"
                ],
                [
                    72,
                    " memset ( picture -> qscale_table , picture -> quality , ( s -> width + 15 ) / 16 ) ;\n"
                ],
                [
                    73,
                    " if ( avctx -> debug & FF_DEBUG_QP ) av_log ( avctx , AV_LOG_DEBUG , \"QP: %d\\n\" , picture -> quality ) ;\n"
                ],
                [
                    74,
                    " picture -> quality *= FF_QP2LAMBDA ;\n"
                ]
            ],
            "result": [
                [
                    6,
                    " AVFrame * picture = data ;\n"
                ],
                [
                    68,
                    " if ( ! s -> lossless ) {\n"
                ],
                [
                    69,
                    " picture -> quality = FFMAX3 ( s -> qscale [ 0 ] , s -> qscale [ 1 ] , s -> qscale [ 2 ] ) ;\n"
                ],
                [
                    71,
                    " picture -> qscale_table = s -> qscale_table ;\n"
                ],
                [
                    72,
                    " memset ( picture -> qscale_table , picture -> quality , ( s -> width + 15 ) / 16 ) ;\n"
                ],
                [
                    73,
                    " if ( avctx -> debug & FF_DEBUG_QP ) av_log ( avctx , AV_LOG_DEBUG , \"QP: %d\\n\" , picture -> quality ) ;\n"
                ],
                [
                    74,
                    " picture -> quality *= FF_QP2LAMBDA ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void vp3_decode_flush ( AVCodecContext * avctx ) {\n Vp3DecodeContext * s = avctx -> priv_data ;\n if ( s -> golden_frame . data [ 0 ] ) {\n if ( s -> golden_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> last_frame , 0 , sizeof ( AVFrame ) ) ;\n if ( s -> current_frame . data [ 0 ] == s -> golden_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n ff_thread_release_buffer ( avctx , & s -> golden_frame ) ;\n }\n if ( s -> last_frame . data [ 0 ] ) {\n if ( s -> current_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n ff_thread_release_buffer ( avctx , & s -> last_frame ) ;\n }\n if ( s -> current_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> current_frame ) ;\n }",
        "hash": -7990991774694156606,
        "project": "debian",
        "size": 13,
        "slice": {
            "memset": [
                [
                    1,
                    "static void vp3_decode_flush ( AVCodecContext * avctx ) {\n"
                ],
                [
                    2,
                    " Vp3DecodeContext * s = avctx -> priv_data ;\n"
                ],
                [
                    4,
                    " if ( s -> golden_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> last_frame , 0 , sizeof ( AVFrame ) ) ;\n"
                ],
                [
                    5,
                    " if ( s -> current_frame . data [ 0 ] == s -> golden_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n"
                ],
                [
                    9,
                    " if ( s -> current_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n"
                ],
                [
                    10,
                    " ff_thread_release_buffer ( avctx , & s -> last_frame ) ;\n"
                ],
                [
                    12,
                    " if ( s -> current_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> current_frame ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void vp3_decode_flush ( AVCodecContext * avctx ) {\n"
                ],
                [
                    2,
                    " Vp3DecodeContext * s = avctx -> priv_data ;\n"
                ],
                [
                    4,
                    " if ( s -> golden_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> last_frame , 0 , sizeof ( AVFrame ) ) ;\n"
                ],
                [
                    5,
                    " if ( s -> current_frame . data [ 0 ] == s -> golden_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n"
                ],
                [
                    9,
                    " if ( s -> current_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n"
                ],
                [
                    10,
                    " ff_thread_release_buffer ( avctx , & s -> last_frame ) ;\n"
                ],
                [
                    12,
                    " if ( s -> current_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> current_frame ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int vp3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n Vp3DecodeContext * s = avctx -> priv_data ;\n GetBitContext gb ;\n int i ;\n init_get_bits ( & gb , buf , buf_size * 8 ) ;\n if ( s -> theora && get_bits1 ( & gb ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Header packet passed to frame decoder, skipping\\n\" ) ;\n return - 1 ;\n }\n s -> keyframe = ! get_bits1 ( & gb ) ;\n if ( ! s -> theora ) skip_bits ( & gb , 1 ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) s -> last_qps [ i ] = s -> qps [ i ] ;\n s -> nqps = 0 ;\n do {\n s -> qps [ s -> nqps ++ ] = get_bits ( & gb , 6 ) ;\n }\n while ( s -> theora >= 0x030200 && s -> nqps < 3 && get_bits1 ( & gb ) ) ;\n for ( i = s -> nqps ;\n i < 3 ;\n i ++ ) s -> qps [ i ] = - 1 ;\n if ( s -> avctx -> debug & FF_DEBUG_PICT_INFO ) av_log ( s -> avctx , AV_LOG_INFO , \" VP3 %sframe #%d: Q index = %d\\n\" , s -> keyframe ? \"key\" : \"\" , avctx -> frame_number + 1 , s -> qps [ 0 ] ) ;\n s -> skip_loop_filter = ! s -> filter_limit_values [ s -> qps [ 0 ] ] || avctx -> skip_loop_filter >= ( s -> keyframe ? AVDISCARD_ALL : AVDISCARD_NONKEY ) ;\n if ( s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_loop_filter ( s ) ;\n for ( i = 0 ;\n i < s -> nqps ;\n i ++ ) if ( s -> qps [ i ] != s -> last_qps [ i ] || s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_dequantizer ( s , i ) ;\n if ( avctx -> skip_frame >= AVDISCARD_NONKEY && ! s -> keyframe ) return buf_size ;\n s -> current_frame . reference = 3 ;\n s -> current_frame . pict_type = s -> keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ;\n if ( ff_thread_get_buffer ( avctx , & s -> current_frame ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n goto error ;\n }\n if ( ! s -> edge_emu_buffer ) s -> edge_emu_buffer = av_malloc ( 9 * FFABS ( s -> current_frame . linesize [ 0 ] ) ) ;\n if ( s -> keyframe ) {\n if ( ! s -> theora ) {\n skip_bits ( & gb , 4 ) ;\n skip_bits ( & gb , 4 ) ;\n if ( s -> version ) {\n s -> version = get_bits ( & gb , 5 ) ;\n if ( avctx -> frame_number == 0 ) av_log ( s -> avctx , AV_LOG_DEBUG , \"VP version: %d\\n\" , s -> version ) ;\n }\n }\n if ( s -> version || s -> theora ) {\n if ( get_bits1 ( & gb ) ) av_log ( s -> avctx , AV_LOG_ERROR , \"Warning, unsupported keyframe coding type?!\\n\" ) ;\n skip_bits ( & gb , 2 ) ;\n }\n }\n else {\n if ( ! s -> golden_frame . data [ 0 ] ) {\n av_log ( s -> avctx , AV_LOG_WARNING , \"vp3: first frame not a keyframe\\n\" ) ;\n s -> golden_frame . reference = 3 ;\n s -> golden_frame . pict_type = AV_PICTURE_TYPE_I ;\n if ( ff_thread_get_buffer ( avctx , & s -> golden_frame ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n goto error ;\n }\n s -> last_frame = s -> golden_frame ;\n s -> last_frame . type = FF_BUFFER_TYPE_COPY ;\n ff_thread_report_progress ( & s -> last_frame , INT_MAX , 0 ) ;\n }\n }\n memset ( s -> all_fragments , 0 , s -> fragment_count * sizeof ( Vp3Fragment ) ) ;\n ff_thread_finish_setup ( avctx ) ;\n if ( unpack_superblocks ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_superblocks\\n\" ) ;\n goto error ;\n }\n if ( unpack_modes ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_modes\\n\" ) ;\n goto error ;\n }\n if ( unpack_vectors ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_vectors\\n\" ) ;\n goto error ;\n }\n if ( unpack_block_qpis ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_block_qpis\\n\" ) ;\n goto error ;\n }\n if ( unpack_dct_coeffs ( s , & gb ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"error in unpack_dct_coeffs\\n\" ) ;\n goto error ;\n }\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n int height = s -> height >> ( i && s -> chroma_y_shift ) ;\n if ( s -> flipped_image ) s -> data_offset [ i ] = 0 ;\n else s -> data_offset [ i ] = ( height - 1 ) * s -> current_frame . linesize [ i ] ;\n }\n s -> last_slice_end = 0 ;\n for ( i = 0 ;\n i < s -> c_superblock_height ;\n i ++ ) render_slice ( s , i ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n int row = ( s -> height >> ( 3 + ( i && s -> chroma_y_shift ) ) ) - 1 ;\n apply_loop_filter ( s , i , row , row + 1 ) ;\n }\n vp3_draw_horiz_band ( s , s -> avctx -> height ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> current_frame ;\n if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) update_frames ( avctx ) ;\n return buf_size ;\n error : ff_thread_report_progress ( & s -> current_frame , INT_MAX , 0 ) ;\n if ( ! HAVE_THREADS || ! ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) avctx -> release_buffer ( avctx , & s -> current_frame ) ;\n return - 1 ;\n }",
        "hash": -7990991774694156606,
        "project": "debian",
        "size": 114,
        "slice": {
            "memset": [
                [
                    1,
                    "static int vp3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " Vp3DecodeContext * s = avctx -> priv_data ;\n"
                ],
                [
                    27,
                    " if ( s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_loop_filter ( s ) ;\n"
                ],
                [
                    30,
                    " i ++ ) if ( s -> qps [ i ] != s -> last_qps [ i ] || s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_dequantizer ( s , i ) ;\n"
                ],
                [
                    39,
                    " if ( s -> keyframe ) {\n"
                ],
                [
                    54,
                    " if ( ! s -> golden_frame . data [ 0 ] ) {\n"
                ],
                [
                    58,
                    " if ( ff_thread_get_buffer ( avctx , & s -> golden_frame ) < 0 ) {\n"
                ],
                [
                    67,
                    " memset ( s -> all_fragments , 0 , s -> fragment_count * sizeof ( Vp3Fragment ) ) ;\n"
                ],
                [
                    69,
                    " if ( unpack_superblocks ( s , & gb ) ) {\n"
                ],
                [
                    73,
                    " if ( unpack_modes ( s , & gb ) ) {\n"
                ],
                [
                    77,
                    " if ( unpack_vectors ( s , & gb ) ) {\n"
                ],
                [
                    81,
                    " if ( unpack_block_qpis ( s , & gb ) ) {\n"
                ],
                [
                    85,
                    " if ( unpack_dct_coeffs ( s , & gb ) ) {\n"
                ],
                [
                    99,
                    " i ++ ) render_slice ( s , i ) ;\n"
                ],
                [
                    104,
                    " apply_loop_filter ( s , i , row , row + 1 ) ;\n"
                ],
                [
                    106,
                    " vp3_draw_horiz_band ( s , s -> avctx -> height ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int vp3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " Vp3DecodeContext * s = avctx -> priv_data ;\n"
                ],
                [
                    27,
                    " if ( s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_loop_filter ( s ) ;\n"
                ],
                [
                    30,
                    " i ++ ) if ( s -> qps [ i ] != s -> last_qps [ i ] || s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_dequantizer ( s , i ) ;\n"
                ],
                [
                    39,
                    " if ( s -> keyframe ) {\n"
                ],
                [
                    54,
                    " if ( ! s -> golden_frame . data [ 0 ] ) {\n"
                ],
                [
                    58,
                    " if ( ff_thread_get_buffer ( avctx , & s -> golden_frame ) < 0 ) {\n"
                ],
                [
                    67,
                    " memset ( s -> all_fragments , 0 , s -> fragment_count * sizeof ( Vp3Fragment ) ) ;\n"
                ],
                [
                    69,
                    " if ( unpack_superblocks ( s , & gb ) ) {\n"
                ],
                [
                    73,
                    " if ( unpack_modes ( s , & gb ) ) {\n"
                ],
                [
                    77,
                    " if ( unpack_vectors ( s , & gb ) ) {\n"
                ],
                [
                    81,
                    " if ( unpack_block_qpis ( s , & gb ) ) {\n"
                ],
                [
                    85,
                    " if ( unpack_dct_coeffs ( s , & gb ) ) {\n"
                ],
                [
                    99,
                    " i ++ ) render_slice ( s , i ) ;\n"
                ],
                [
                    104,
                    " apply_loop_filter ( s , i , row , row + 1 ) ;\n"
                ],
                [
                    106,
                    " vp3_draw_horiz_band ( s , s -> avctx -> height ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int vp3_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ;\n int qps_changed = 0 , i , err ;\n # define copy_fields ( to , from , start_field , end_field ) memcpy ( & to -> start_field , & from -> start_field , ( char * ) & to -> end_field - ( char * ) & to -> start_field ) if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height ) {\n if ( s != s1 ) copy_fields ( s , s1 , golden_frame , current_frame ) ;\n return - 1 ;\n }\n if ( s != s1 ) {\n if ( ! s -> current_frame . data [ 0 ] ) {\n int y_fragment_count , c_fragment_count ;\n s -> avctx = dst ;\n err = allocate_tables ( dst ) ;\n if ( err ) return err ;\n y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ] ;\n c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ] ;\n memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ) ;\n memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ) ;\n }\n copy_fields ( s , s1 , golden_frame , dsp ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n if ( s -> qps [ i ] != s1 -> qps [ 1 ] ) {\n qps_changed = 1 ;\n memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ) ;\n }\n }\n if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] ) memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ) ;\n if ( qps_changed ) copy_fields ( s , s1 , qps , superblock_count ) ;\n # undef copy_fields }\n update_frames ( dst ) ;\n return 0 ;\n }",
        "hash": -7990991774694156606,
        "project": "debian",
        "size": 33,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int vp3_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n"
                ],
                [
                    5,
                    " if ( s != s1 ) copy_fields ( s , s1 , golden_frame , current_frame ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int vp3_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n"
                ],
                [
                    5,
                    " if ( s != s1 ) copy_fields ( s , s1 , golden_frame , current_frame ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = avpkt -> data + avpkt -> size ;\n int buf_size = avpkt -> size ;\n DPXContext * const s = avctx -> priv_data ;\n AVFrame * picture = data ;\n AVFrame * const p = & s -> picture ;\n uint8_t * ptr ;\n unsigned int offset ;\n int magic_num , endian ;\n int x , y , ret ;\n int w , h , stride , bits_per_color , descriptor , elements , target_packet_size , source_packet_size ;\n unsigned int rgbBuffer ;\n if ( avpkt -> size <= 1634 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet too small for DPX header\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n magic_num = AV_RB32 ( buf ) ;\n buf += 4 ;\n if ( magic_num == AV_RL32 ( \"SDPX\" ) ) {\n endian = 0 ;\n }\n else if ( magic_num == AV_RB32 ( \"SDPX\" ) ) {\n endian = 1 ;\n }\n else {\n av_log ( avctx , AV_LOG_ERROR , \"DPX marker not found\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n offset = read32 ( & buf , endian ) ;\n if ( avpkt -> size <= offset ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid data start offset\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n buf = avpkt -> data + 0x304 ;\n w = read32 ( & buf , endian ) ;\n h = read32 ( & buf , endian ) ;\n buf += 20 ;\n descriptor = buf [ 0 ] ;\n buf += 3 ;\n avctx -> bits_per_raw_sample = bits_per_color = buf [ 0 ] ;\n buf += 825 ;\n avctx -> sample_aspect_ratio . num = read32 ( & buf , endian ) ;\n avctx -> sample_aspect_ratio . den = read32 ( & buf , endian ) ;\n switch ( descriptor ) {\n case 51 : elements = 4 ;\n break ;\n case 50 : elements = 3 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unsupported descriptor %d\\n\" , descriptor ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( bits_per_color ) {\n case 8 : if ( elements == 4 ) {\n avctx -> pix_fmt = AV_PIX_FMT_RGBA ;\n }\n else {\n avctx -> pix_fmt = AV_PIX_FMT_RGB24 ;\n }\n source_packet_size = elements ;\n target_packet_size = elements ;\n break ;\n case 10 : avctx -> pix_fmt = AV_PIX_FMT_RGB48 ;\n target_packet_size = 6 ;\n source_packet_size = 4 ;\n break ;\n case 12 : case 16 : if ( endian ) {\n avctx -> pix_fmt = AV_PIX_FMT_RGB48BE ;\n }\n else {\n avctx -> pix_fmt = AV_PIX_FMT_RGB48LE ;\n }\n target_packet_size = 6 ;\n source_packet_size = elements * 2 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unsupported color depth : %d\\n\" , bits_per_color ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( s -> picture . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> picture ) ;\n if ( ( ret = av_image_check_size ( w , h , 0 , avctx ) ) < 0 ) return ret ;\n if ( w != avctx -> width || h != avctx -> height ) avcodec_set_dimensions ( avctx , w , h ) ;\n if ( ( ret = ff_get_buffer ( avctx , p ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n buf = avpkt -> data + offset ;\n ptr = p -> data [ 0 ] ;\n stride = p -> linesize [ 0 ] ;\n if ( source_packet_size * avctx -> width * avctx -> height > buf_end - buf ) {\n av_log ( avctx , AV_LOG_ERROR , \"Overread buffer. Invalid header?\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n switch ( bits_per_color ) {\n case 10 : for ( x = 0 ;\n x < avctx -> height ;\n x ++ ) {\n uint16_t * dst = ( uint16_t * ) ptr ;\n for ( y = 0 ;\n y < avctx -> width ;\n y ++ ) {\n rgbBuffer = read32 ( & buf , endian ) ;\n * dst ++ = make_16bit ( rgbBuffer >> 16 ) ;\n * dst ++ = make_16bit ( rgbBuffer >> 6 ) ;\n * dst ++ = make_16bit ( rgbBuffer << 4 ) ;\n }\n ptr += stride ;\n }\n break ;\n case 8 : case 12 : case 16 : if ( source_packet_size == target_packet_size ) {\n for ( x = 0 ;\n x < avctx -> height ;\n x ++ ) {\n memcpy ( ptr , buf , target_packet_size * avctx -> width ) ;\n ptr += stride ;\n buf += source_packet_size * avctx -> width ;\n }\n }\n else {\n for ( x = 0 ;\n x < avctx -> height ;\n x ++ ) {\n uint8_t * dst = ptr ;\n for ( y = 0 ;\n y < avctx -> width ;\n y ++ ) {\n memcpy ( dst , buf , target_packet_size ) ;\n dst += target_packet_size ;\n buf += source_packet_size ;\n }\n ptr += stride ;\n }\n }\n break ;\n }\n * picture = s -> picture ;\n * got_frame = 1 ;\n return buf_size ;\n }",
        "hash": 3950861381020172342,
        "project": "debian",
        "size": 138,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    38,
                    " buf += 20 ;\n"
                ],
                [
                    40,
                    " buf += 3 ;\n"
                ],
                [
                    44,
                    " avctx -> sample_aspect_ratio . den = read32 ( & buf , endian ) ;\n"
                ],
                [
                    87,
                    " ptr = p -> data [ 0 ] ;\n"
                ],
                [
                    89,
                    " if ( source_packet_size * avctx -> width * avctx -> height > buf_end - buf ) {\n"
                ],
                [
                    109,
                    " case 8 : case 12 : case 16 : if ( source_packet_size == target_packet_size ) {\n"
                ],
                [
                    111,
                    " x < avctx -> height ;\n"
                ],
                [
                    113,
                    " memcpy ( ptr , buf , target_packet_size * avctx -> width ) ;\n"
                ],
                [
                    114,
                    " ptr += stride ;\n"
                ],
                [
                    115,
                    " buf += source_packet_size * avctx -> width ;\n"
                ],
                [
                    122,
                    " uint8_t * dst = ptr ;\n"
                ],
                [
                    124,
                    " y < avctx -> width ;\n"
                ],
                [
                    126,
                    " memcpy ( dst , buf , target_packet_size ) ;\n"
                ],
                [
                    127,
                    " dst += target_packet_size ;\n"
                ],
                [
                    128,
                    " buf += source_packet_size ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    38,
                    " buf += 20 ;\n"
                ],
                [
                    40,
                    " buf += 3 ;\n"
                ],
                [
                    44,
                    " avctx -> sample_aspect_ratio . den = read32 ( & buf , endian ) ;\n"
                ],
                [
                    87,
                    " ptr = p -> data [ 0 ] ;\n"
                ],
                [
                    89,
                    " if ( source_packet_size * avctx -> width * avctx -> height > buf_end - buf ) {\n"
                ],
                [
                    109,
                    " case 8 : case 12 : case 16 : if ( source_packet_size == target_packet_size ) {\n"
                ],
                [
                    111,
                    " x < avctx -> height ;\n"
                ],
                [
                    113,
                    " memcpy ( ptr , buf , target_packet_size * avctx -> width ) ;\n"
                ],
                [
                    114,
                    " ptr += stride ;\n"
                ],
                [
                    115,
                    " buf += source_packet_size * avctx -> width ;\n"
                ],
                [
                    122,
                    " uint8_t * dst = ptr ;\n"
                ],
                [
                    124,
                    " y < avctx -> width ;\n"
                ],
                [
                    126,
                    " memcpy ( dst , buf , target_packet_size ) ;\n"
                ],
                [
                    127,
                    " dst += target_packet_size ;\n"
                ],
                [
                    128,
                    " buf += source_packet_size ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int ra288_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n float * out ;\n int i , ret ;\n RA288Context * ractx = avctx -> priv_data ;\n GetBitContext gb ;\n if ( buf_size < avctx -> block_align ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error! Input buffer is too small [%d<%d]\\n\" , buf_size , avctx -> block_align ) ;\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = RA288_BLOCK_SIZE * RA288_BLOCKS_PER_FRAME ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n out = ( float * ) frame -> data [ 0 ] ;\n init_get_bits ( & gb , buf , avctx -> block_align * 8 ) ;\n for ( i = 0 ;\n i < RA288_BLOCKS_PER_FRAME ;\n i ++ ) {\n float gain = amptable [ get_bits ( & gb , 3 ) ] ;\n int cb_coef = get_bits ( & gb , 6 + ( i & 1 ) ) ;\n decode ( ractx , gain , cb_coef ) ;\n memcpy ( out , & ractx -> sp_hist [ 70 + 36 ] , RA288_BLOCK_SIZE * sizeof ( * out ) ) ;\n out += RA288_BLOCK_SIZE ;\n if ( ( i & 7 ) == 3 ) {\n backward_filter ( ractx , ractx -> sp_hist , ractx -> sp_rec , syn_window , ractx -> sp_lpc , syn_bw_tab , 36 , 40 , 35 , 70 ) ;\n backward_filter ( ractx , ractx -> gain_hist , ractx -> gain_rec , gain_window , ractx -> gain_lpc , gain_bw_tab , 10 , 8 , 20 , 28 ) ;\n }\n }\n * got_frame_ptr = 1 ;\n return avctx -> block_align ;\n }",
        "hash": 3090981948963373743,
        "project": "debian",
        "size": 35,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int ra288_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    18,
                    " out = ( float * ) frame -> data [ 0 ] ;\n"
                ],
                [
                    21,
                    " i < RA288_BLOCKS_PER_FRAME ;\n"
                ],
                [
                    26,
                    " memcpy ( out , & ractx -> sp_hist [ 70 + 36 ] , RA288_BLOCK_SIZE * sizeof ( * out ) ) ;\n"
                ],
                [
                    27,
                    " out += RA288_BLOCK_SIZE ;\n"
                ],
                [
                    29,
                    " backward_filter ( ractx , ractx -> sp_hist , ractx -> sp_rec , syn_window , ractx -> sp_lpc , syn_bw_tab , 36 , 40 , 35 , 70 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ra288_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    18,
                    " out = ( float * ) frame -> data [ 0 ] ;\n"
                ],
                [
                    21,
                    " i < RA288_BLOCKS_PER_FRAME ;\n"
                ],
                [
                    26,
                    " memcpy ( out , & ractx -> sp_hist [ 70 + 36 ] , RA288_BLOCK_SIZE * sizeof ( * out ) ) ;\n"
                ],
                [
                    27,
                    " out += RA288_BLOCK_SIZE ;\n"
                ],
                [
                    29,
                    " backward_filter ( ractx , ractx -> sp_hist , ractx -> sp_rec , syn_window , ractx -> sp_lpc , syn_bw_tab , 36 , 40 , 35 , 70 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int synth_superframe ( AVCodecContext * ctx , AVFrame * frame , int * got_frame_ptr ) {\n WMAVoiceContext * s = ctx -> priv_data ;\n GetBitContext * gb = & s -> gb , s_gb ;\n int n , res , n_samples = 480 ;\n double lsps [ MAX_FRAMES ] [ MAX_LSPS ] ;\n const double * mean_lsf = s -> lsps == 16 ? wmavoice_mean_lsf16 [ s -> lsp_def_mode ] : wmavoice_mean_lsf10 [ s -> lsp_def_mode ] ;\n float excitation [ MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12 ] ;\n float synth [ MAX_LSPS + MAX_SFRAMESIZE ] ;\n float * samples ;\n memcpy ( synth , s -> synth_history , s -> lsps * sizeof ( * synth ) ) ;\n memcpy ( excitation , s -> excitation_history , s -> history_nsamples * sizeof ( * excitation ) ) ;\n if ( s -> sframe_cache_size > 0 ) {\n gb = & s_gb ;\n init_get_bits ( gb , s -> sframe_cache , s -> sframe_cache_size ) ;\n s -> sframe_cache_size = 0 ;\n }\n if ( ( res = check_bits_for_superframe ( gb , s ) ) == 1 ) {\n * got_frame_ptr = 0 ;\n return 1 ;\n }\n if ( ! get_bits1 ( gb ) ) {\n av_log_missing_feature ( ctx , \"WMAPro-in-WMAVoice\" , 1 ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( get_bits1 ( gb ) ) {\n if ( ( n_samples = get_bits ( gb , 12 ) ) > 480 ) {\n av_log ( ctx , AV_LOG_ERROR , \"Superframe encodes >480 samples (%d), not allowed\\n\" , n_samples ) ;\n return - 1 ;\n }\n }\n if ( s -> has_residual_lsps ) {\n double prev_lsps [ MAX_LSPS ] , a1 [ MAX_LSPS * 2 ] , a2 [ MAX_LSPS * 2 ] ;\n for ( n = 0 ;\n n < s -> lsps ;\n n ++ ) prev_lsps [ n ] = s -> prev_lsps [ n ] - mean_lsf [ n ] ;\n if ( s -> lsps == 10 ) {\n dequant_lsp10r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n }\n else dequant_lsp16r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n for ( n = 0 ;\n n < s -> lsps ;\n n ++ ) {\n lsps [ 0 ] [ n ] = mean_lsf [ n ] + ( a1 [ n ] - a2 [ n * 2 ] ) ;\n lsps [ 1 ] [ n ] = mean_lsf [ n ] + ( a1 [ s -> lsps + n ] - a2 [ n * 2 + 1 ] ) ;\n lsps [ 2 ] [ n ] += mean_lsf [ n ] ;\n }\n for ( n = 0 ;\n n < 3 ;\n n ++ ) stabilize_lsps ( lsps [ n ] , s -> lsps ) ;\n }\n frame -> nb_samples = 480 ;\n if ( ( res = ff_get_buffer ( ctx , frame ) ) < 0 ) {\n av_log ( ctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return res ;\n }\n frame -> nb_samples = n_samples ;\n samples = ( float * ) frame -> data [ 0 ] ;\n for ( n = 0 ;\n n < 3 ;\n n ++ ) {\n if ( ! s -> has_residual_lsps ) {\n int m ;\n if ( s -> lsps == 10 ) {\n dequant_lsp10i ( gb , lsps [ n ] ) ;\n }\n else dequant_lsp16i ( gb , lsps [ n ] ) ;\n for ( m = 0 ;\n m < s -> lsps ;\n m ++ ) lsps [ n ] [ m ] += mean_lsf [ m ] ;\n stabilize_lsps ( lsps [ n ] , s -> lsps ) ;\n }\n if ( ( res = synth_frame ( ctx , gb , n , & samples [ n * MAX_FRAMESIZE ] , lsps [ n ] , n == 0 ? s -> prev_lsps : lsps [ n - 1 ] , & excitation [ s -> history_nsamples + n * MAX_FRAMESIZE ] , & synth [ s -> lsps + n * MAX_FRAMESIZE ] ) ) ) {\n * got_frame_ptr = 0 ;\n return res ;\n }\n }\n if ( get_bits1 ( gb ) ) {\n res = get_bits ( gb , 4 ) ;\n skip_bits ( gb , 10 * ( res + 1 ) ) ;\n }\n * got_frame_ptr = 1 ;\n memcpy ( s -> prev_lsps , lsps [ 2 ] , s -> lsps * sizeof ( * s -> prev_lsps ) ) ;\n memcpy ( s -> synth_history , & synth [ MAX_SFRAMESIZE ] , s -> lsps * sizeof ( * synth ) ) ;\n memcpy ( s -> excitation_history , & excitation [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * excitation ) ) ;\n if ( s -> do_apf ) memmove ( s -> zero_exc_pf , & s -> zero_exc_pf [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * s -> zero_exc_pf ) ) ;\n return 0 ;\n }",
        "hash": 643387607984457432,
        "project": "debian",
        "size": 87,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int synth_superframe ( AVCodecContext * ctx , AVFrame * frame , int * got_frame_ptr ) {\n"
                ],
                [
                    2,
                    " WMAVoiceContext * s = ctx -> priv_data ;\n"
                ],
                [
                    5,
                    " double lsps [ MAX_FRAMES ] [ MAX_LSPS ] ;\n"
                ],
                [
                    7,
                    " float excitation [ MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12 ] ;\n"
                ],
                [
                    8,
                    " float synth [ MAX_LSPS + MAX_SFRAMESIZE ] ;\n"
                ],
                [
                    10,
                    " memcpy ( synth , s -> synth_history , s -> lsps * sizeof ( * synth ) ) ;\n"
                ],
                [
                    11,
                    " memcpy ( excitation , s -> excitation_history , s -> history_nsamples * sizeof ( * excitation ) ) ;\n"
                ],
                [
                    17,
                    " if ( ( res = check_bits_for_superframe ( gb , s ) ) == 1 ) {\n"
                ],
                [
                    35,
                    " n ++ ) prev_lsps [ n ] = s -> prev_lsps [ n ] - mean_lsf [ n ] ;\n"
                ],
                [
                    37,
                    " dequant_lsp10r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n"
                ],
                [
                    39,
                    " else dequant_lsp16r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n"
                ],
                [
                    45,
                    " lsps [ 2 ] [ n ] += mean_lsf [ n ] ;\n"
                ],
                [
                    59,
                    " n < 3 ;\n"
                ],
                [
                    72,
                    " if ( ( res = synth_frame ( ctx , gb , n , & samples [ n * MAX_FRAMESIZE ] , lsps [ n ] , n == 0 ? s -> prev_lsps : lsps [ n - 1 ] , & excitation [ s -> history_nsamples + n * MAX_FRAMESIZE ] , & synth [ s -> lsps + n * MAX_FRAMESIZE ] ) ) ) {\n"
                ],
                [
                    82,
                    " memcpy ( s -> prev_lsps , lsps [ 2 ] , s -> lsps * sizeof ( * s -> prev_lsps ) ) ;\n"
                ],
                [
                    83,
                    " memcpy ( s -> synth_history , & synth [ MAX_SFRAMESIZE ] , s -> lsps * sizeof ( * synth ) ) ;\n"
                ],
                [
                    84,
                    " memcpy ( s -> excitation_history , & excitation [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * excitation ) ) ;\n"
                ]
            ],
            "memmove": [
                [
                    17,
                    " if ( ( res = check_bits_for_superframe ( gb , s ) ) == 1 ) {\n"
                ],
                [
                    85,
                    " if ( s -> do_apf ) memmove ( s -> zero_exc_pf , & s -> zero_exc_pf [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * s -> zero_exc_pf ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int synth_superframe ( AVCodecContext * ctx , AVFrame * frame , int * got_frame_ptr ) {\n"
                ],
                [
                    2,
                    " WMAVoiceContext * s = ctx -> priv_data ;\n"
                ],
                [
                    5,
                    " double lsps [ MAX_FRAMES ] [ MAX_LSPS ] ;\n"
                ],
                [
                    7,
                    " float excitation [ MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12 ] ;\n"
                ],
                [
                    8,
                    " float synth [ MAX_LSPS + MAX_SFRAMESIZE ] ;\n"
                ],
                [
                    10,
                    " memcpy ( synth , s -> synth_history , s -> lsps * sizeof ( * synth ) ) ;\n"
                ],
                [
                    11,
                    " memcpy ( excitation , s -> excitation_history , s -> history_nsamples * sizeof ( * excitation ) ) ;\n"
                ],
                [
                    17,
                    " if ( ( res = check_bits_for_superframe ( gb , s ) ) == 1 ) {\n"
                ],
                [
                    35,
                    " n ++ ) prev_lsps [ n ] = s -> prev_lsps [ n ] - mean_lsf [ n ] ;\n"
                ],
                [
                    37,
                    " dequant_lsp10r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n"
                ],
                [
                    39,
                    " else dequant_lsp16r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n"
                ],
                [
                    45,
                    " lsps [ 2 ] [ n ] += mean_lsf [ n ] ;\n"
                ],
                [
                    59,
                    " n < 3 ;\n"
                ],
                [
                    72,
                    " if ( ( res = synth_frame ( ctx , gb , n , & samples [ n * MAX_FRAMESIZE ] , lsps [ n ] , n == 0 ? s -> prev_lsps : lsps [ n - 1 ] , & excitation [ s -> history_nsamples + n * MAX_FRAMESIZE ] , & synth [ s -> lsps + n * MAX_FRAMESIZE ] ) ) ) {\n"
                ],
                [
                    82,
                    " memcpy ( s -> prev_lsps , lsps [ 2 ] , s -> lsps * sizeof ( * s -> prev_lsps ) ) ;\n"
                ],
                [
                    83,
                    " memcpy ( s -> synth_history , & synth [ MAX_SFRAMESIZE ] , s -> lsps * sizeof ( * synth ) ) ;\n"
                ],
                [
                    84,
                    " memcpy ( s -> excitation_history , & excitation [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * excitation ) ) ;\n"
                ],
                [
                    85,
                    " if ( s -> do_apf ) memmove ( s -> zero_exc_pf , & s -> zero_exc_pf [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * s -> zero_exc_pf ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void erase_screen ( AVCodecContext * avctx ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n s -> x = s -> y = 0 ;\n }",
        "hash": 2776415072272421122,
        "project": "debian",
        "size": 8,
        "slice": {
            "memset": [
                [
                    1,
                    "static void erase_screen ( AVCodecContext * avctx ) {\n"
                ],
                [
                    5,
                    " i < avctx -> height ;\n"
                ],
                [
                    6,
                    " i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void erase_screen ( AVCodecContext * avctx ) {\n"
                ],
                [
                    5,
                    " i < avctx -> height ;\n"
                ],
                [
                    6,
                    " i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n AnsiContext * s = avctx -> priv_data ;\n uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n const uint8_t * buf_end = buf + buf_size ;\n int ret , i , count ;\n ret = avctx -> reget_buffer ( avctx , & s -> frame ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( ! avctx -> frame_number ) {\n memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * FFABS ( s -> frame . linesize [ 0 ] ) ) ;\n memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n }\n s -> frame . pict_type = AV_PICTURE_TYPE_I ;\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n while ( buf < buf_end ) {\n switch ( s -> state ) {\n case STATE_NORMAL : switch ( buf [ 0 ] ) {\n case 0x00 : case 0x07 : case 0x1A : break ;\n case 0x08 : s -> x = FFMAX ( s -> x - 1 , 0 ) ;\n break ;\n case 0x09 : i = s -> x / FONT_WIDTH ;\n count = ( ( i + 8 ) & ~ 7 ) - i ;\n for ( i = 0 ;\n i < count ;\n i ++ ) draw_char ( avctx , ' ' ) ;\n break ;\n case 0x0A : hscroll ( avctx ) ;\n case 0x0D : s -> x = 0 ;\n break ;\n case 0x0C : erase_screen ( avctx ) ;\n break ;\n case 0x1B : s -> state = STATE_ESCAPE ;\n break ;\n default : draw_char ( avctx , buf [ 0 ] ) ;\n }\n break ;\n case STATE_ESCAPE : if ( buf [ 0 ] == '[' ) {\n s -> state = STATE_CODE ;\n s -> nb_args = 0 ;\n s -> args [ 0 ] = 0 ;\n }\n else {\n s -> state = STATE_NORMAL ;\n draw_char ( avctx , 0x1B ) ;\n continue ;\n }\n break ;\n case STATE_CODE : switch ( buf [ 0 ] ) {\n case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : if ( s -> nb_args < MAX_NB_ARGS ) s -> args [ s -> nb_args ] = s -> args [ s -> nb_args ] * 10 + buf [ 0 ] - '0' ;\n break ;\n case ';\n' : s -> nb_args ++ ;\n if ( s -> nb_args < MAX_NB_ARGS ) s -> args [ s -> nb_args ] = 0 ;\n break ;\n case 'M' : s -> state = STATE_MUSIC_PREAMBLE ;\n break ;\n case '=' : case '?' : break ;\n default : if ( s -> nb_args > MAX_NB_ARGS ) av_log ( avctx , AV_LOG_WARNING , \"args overflow (%i)\\n\" , s -> nb_args ) ;\n if ( s -> nb_args < MAX_NB_ARGS && s -> args [ s -> nb_args ] ) s -> nb_args ++ ;\n if ( ( ret = execute_code ( avctx , buf [ 0 ] ) ) < 0 ) return ret ;\n s -> state = STATE_NORMAL ;\n }\n break ;\n case STATE_MUSIC_PREAMBLE : if ( buf [ 0 ] == 0x0E || buf [ 0 ] == 0x1B ) s -> state = STATE_NORMAL ;\n break ;\n }\n buf ++ ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": 2776415072272421122,
        "project": "debian",
        "size": 76,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    8,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    14,
                    " memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    18,
                    " memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    12,
                    " if ( ! avctx -> frame_number ) {\n"
                ],
                [
                    13,
                    " memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * FFABS ( s -> frame . linesize [ 0 ] ) ) ;\n"
                ],
                [
                    14,
                    " memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    18,
                    " memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    8,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    12,
                    " if ( ! avctx -> frame_number ) {\n"
                ],
                [
                    13,
                    " memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * FFABS ( s -> frame . linesize [ 0 ] ) ) ;\n"
                ],
                [
                    14,
                    " memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    18,
                    " memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void hscroll ( AVCodecContext * avctx ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n if ( s -> y < avctx -> height - s -> font_height ) {\n s -> y += s -> font_height ;\n return ;\n }\n i = 0 ;\n for ( ;\n i < avctx -> height - s -> font_height ;\n i ++ ) memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , s -> frame . data [ 0 ] + ( i + s -> font_height ) * s -> frame . linesize [ 0 ] , avctx -> width ) ;\n for ( ;\n i < avctx -> height ;\n i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n }",
        "hash": 2776415072272421122,
        "project": "debian",
        "size": 15,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void hscroll ( AVCodecContext * avctx ) {\n"
                ],
                [
                    10,
                    " i < avctx -> height - s -> font_height ;\n"
                ],
                [
                    11,
                    " i ++ ) memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , s -> frame . data [ 0 ] + ( i + s -> font_height ) * s -> frame . linesize [ 0 ] , avctx -> width ) ;\n"
                ],
                [
                    14,
                    " i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static void hscroll ( AVCodecContext * avctx ) {\n"
                ],
                [
                    11,
                    " i ++ ) memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , s -> frame . data [ 0 ] + ( i + s -> font_height ) * s -> frame . linesize [ 0 ] , avctx -> width ) ;\n"
                ],
                [
                    13,
                    " i < avctx -> height ;\n"
                ],
                [
                    14,
                    " i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void hscroll ( AVCodecContext * avctx ) {\n"
                ],
                [
                    10,
                    " i < avctx -> height - s -> font_height ;\n"
                ],
                [
                    11,
                    " i ++ ) memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , s -> frame . data [ 0 ] + ( i + s -> font_height ) * s -> frame . linesize [ 0 ] , avctx -> width ) ;\n"
                ],
                [
                    13,
                    " i < avctx -> height ;\n"
                ],
                [
                    14,
                    " i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void erase_line ( AVCodecContext * avctx , int xoffset , int xlength ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n for ( i = 0 ;\n i < s -> font_height ;\n i ++ ) memset ( s -> frame . data [ 0 ] + ( s -> y + i ) * s -> frame . linesize [ 0 ] + xoffset , DEFAULT_BG_COLOR , xlength ) ;\n }",
        "hash": 2776415072272421122,
        "project": "debian",
        "size": 7,
        "slice": {
            "memset": [
                [
                    1,
                    "static void erase_line ( AVCodecContext * avctx , int xoffset , int xlength ) {\n"
                ],
                [
                    5,
                    " i < s -> font_height ;\n"
                ],
                [
                    6,
                    " i ++ ) memset ( s -> frame . data [ 0 ] + ( s -> y + i ) * s -> frame . linesize [ 0 ] + xoffset , DEFAULT_BG_COLOR , xlength ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void erase_line ( AVCodecContext * avctx , int xoffset , int xlength ) {\n"
                ],
                [
                    5,
                    " i < s -> font_height ;\n"
                ],
                [
                    6,
                    " i ++ ) memset ( s -> frame . data [ 0 ] + ( s -> y + i ) * s -> frame . linesize [ 0 ] + xoffset , DEFAULT_BG_COLOR , xlength ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int execute_code ( AVCodecContext * avctx , int c ) {\n AnsiContext * s = avctx -> priv_data ;\n int ret , i , width , height ;\n switch ( c ) {\n case 'A' : s -> y = FFMAX ( s -> y - ( s -> nb_args > 0 ? s -> args [ 0 ] * s -> font_height : s -> font_height ) , 0 ) ;\n break ;\n case 'B' : s -> y = FFMIN ( s -> y + ( s -> nb_args > 0 ? s -> args [ 0 ] * s -> font_height : s -> font_height ) , avctx -> height - s -> font_height ) ;\n break ;\n case 'C' : s -> x = FFMIN ( s -> x + ( s -> nb_args > 0 ? s -> args [ 0 ] * FONT_WIDTH : FONT_WIDTH ) , avctx -> width - FONT_WIDTH ) ;\n break ;\n case 'D' : s -> x = FFMAX ( s -> x - ( s -> nb_args > 0 ? s -> args [ 0 ] * FONT_WIDTH : FONT_WIDTH ) , 0 ) ;\n break ;\n case 'H' : case 'f' : s -> y = s -> nb_args > 0 ? av_clip ( ( s -> args [ 0 ] - 1 ) * s -> font_height , 0 , avctx -> height - s -> font_height ) : 0 ;\n s -> x = s -> nb_args > 1 ? av_clip ( ( s -> args [ 1 ] - 1 ) * FONT_WIDTH , 0 , avctx -> width - FONT_WIDTH ) : 0 ;\n break ;\n case 'h' : case 'l' : if ( s -> nb_args < 2 ) s -> args [ 0 ] = DEFAULT_SCREEN_MODE ;\n switch ( s -> args [ 0 ] ) {\n case 0 : case 1 : case 4 : case 5 : case 13 : case 19 : s -> font = ff_cga_font ;\n s -> font_height = 8 ;\n width = 40 << 3 ;\n height = 25 << 3 ;\n break ;\n case 2 : case 3 : s -> font = ff_vga16_font ;\n s -> font_height = 16 ;\n width = 80 << 3 ;\n height = 25 << 4 ;\n break ;\n case 6 : case 14 : s -> font = ff_cga_font ;\n s -> font_height = 8 ;\n width = 80 << 3 ;\n height = 25 << 3 ;\n break ;\n case 7 : break ;\n case 15 : case 16 : s -> font = ff_cga_font ;\n s -> font_height = 8 ;\n width = 80 << 3 ;\n height = 43 << 3 ;\n break ;\n case 17 : case 18 : s -> font = ff_cga_font ;\n s -> font_height = 8 ;\n width = 80 << 3 ;\n height = 60 << 4 ;\n break ;\n default : av_log_ask_for_sample ( avctx , \"unsupported screen mode\\n\" ) ;\n }\n if ( width != avctx -> width || height != avctx -> height ) {\n if ( s -> frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> frame ) ;\n avcodec_set_dimensions ( avctx , width , height ) ;\n ret = ff_get_buffer ( avctx , & s -> frame ) ;\n if ( ret < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n s -> frame . pict_type = AV_PICTURE_TYPE_I ;\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n erase_screen ( avctx ) ;\n }\n else if ( c == 'l' ) {\n erase_screen ( avctx ) ;\n }\n break ;\n case 'J' : switch ( s -> args [ 0 ] ) {\n case 0 : erase_line ( avctx , s -> x , avctx -> width - s -> x ) ;\n if ( s -> y < avctx -> height - s -> font_height ) memset ( s -> frame . data [ 0 ] + ( s -> y + s -> font_height ) * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , ( avctx -> height - s -> y - s -> font_height ) * s -> frame . linesize [ 0 ] ) ;\n break ;\n case 1 : erase_line ( avctx , 0 , s -> x ) ;\n if ( s -> y > 0 ) memset ( s -> frame . data [ 0 ] , DEFAULT_BG_COLOR , s -> y * s -> frame . linesize [ 0 ] ) ;\n break ;\n case 2 : erase_screen ( avctx ) ;\n }\n break ;\n case 'K' : switch ( s -> args [ 0 ] ) {\n case 0 : erase_line ( avctx , s -> x , avctx -> width - s -> x ) ;\n break ;\n case 1 : erase_line ( avctx , 0 , s -> x ) ;\n break ;\n case 2 : erase_line ( avctx , 0 , avctx -> width ) ;\n }\n break ;\n case 'm' : if ( s -> nb_args == 0 ) {\n s -> nb_args = 1 ;\n s -> args [ 0 ] = 0 ;\n }\n for ( i = 0 ;\n i < FFMIN ( s -> nb_args , MAX_NB_ARGS ) ;\n i ++ ) {\n int m = s -> args [ i ] ;\n if ( m == 0 ) {\n s -> attributes = 0 ;\n s -> fg = DEFAULT_FG_COLOR ;\n s -> bg = DEFAULT_BG_COLOR ;\n }\n else if ( m == 1 || m == 2 || m == 4 || m == 5 || m == 7 || m == 8 ) {\n s -> attributes |= 1 << ( m - 1 ) ;\n }\n else if ( m >= 30 && m <= 38 ) {\n s -> fg = ansi_to_cga [ m - 30 ] ;\n }\n else if ( m == 39 ) {\n s -> fg = ansi_to_cga [ DEFAULT_FG_COLOR ] ;\n }\n else if ( m >= 40 && m <= 47 ) {\n s -> bg = ansi_to_cga [ m - 40 ] ;\n }\n else if ( m == 49 ) {\n s -> fg = ansi_to_cga [ DEFAULT_BG_COLOR ] ;\n }\n else {\n av_log_ask_for_sample ( avctx , \"unsupported rendition parameter\\n\" ) ;\n }\n }\n break ;\n case 'n' : case 'R' : break ;\n case 's' : s -> sx = s -> x ;\n s -> sy = s -> y ;\n break ;\n case 'u' : s -> x = av_clip ( s -> sx , 0 , avctx -> width - FONT_WIDTH ) ;\n s -> y = av_clip ( s -> sy , 0 , avctx -> height - s -> font_height ) ;\n break ;\n default : av_log_ask_for_sample ( avctx , \"unsupported escape code\\n\" ) ;\n break ;\n }\n return 0 ;\n }",
        "hash": 2776415072272421122,
        "project": "debian",
        "size": 125,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int execute_code ( AVCodecContext * avctx , int c ) {\n"
                ],
                [
                    50,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    56,
                    " memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int execute_code ( AVCodecContext * avctx , int c ) {\n"
                ],
                [
                    65,
                    " if ( s -> y < avctx -> height - s -> font_height ) memset ( s -> frame . data [ 0 ] + ( s -> y + s -> font_height ) * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , ( avctx -> height - s -> y - s -> font_height ) * s -> frame . linesize [ 0 ] ) ;\n"
                ],
                [
                    68,
                    " if ( s -> y > 0 ) memset ( s -> frame . data [ 0 ] , DEFAULT_BG_COLOR , s -> y * s -> frame . linesize [ 0 ] ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int execute_code ( AVCodecContext * avctx , int c ) {\n"
                ],
                [
                    50,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    56,
                    " memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n"
                ],
                [
                    65,
                    " if ( s -> y < avctx -> height - s -> font_height ) memset ( s -> frame . data [ 0 ] + ( s -> y + s -> font_height ) * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , ( avctx -> height - s -> y - s -> font_height ) * s -> frame . linesize [ 0 ] ) ;\n"
                ],
                [
                    68,
                    " if ( s -> y > 0 ) memset ( s -> frame . data [ 0 ] , DEFAULT_BG_COLOR , s -> y * s -> frame . linesize [ 0 ] ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame_header ( ProresContext * ctx , const uint8_t * buf , const int data_size , AVCodecContext * avctx ) {\n int hdr_size , version , width , height , flags ;\n const uint8_t * ptr ;\n hdr_size = AV_RB16 ( buf ) ;\n if ( hdr_size > data_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"frame data too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n version = AV_RB16 ( buf + 2 ) ;\n if ( version >= 2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"unsupported header version: %d\\n\" , version ) ;\n return AVERROR_INVALIDDATA ;\n }\n width = AV_RB16 ( buf + 8 ) ;\n height = AV_RB16 ( buf + 10 ) ;\n if ( width != avctx -> width || height != avctx -> height ) {\n av_log ( avctx , AV_LOG_ERROR , \"picture dimension changed: old: %d x %d, new: %d x %d\\n\" , avctx -> width , avctx -> height , width , height ) ;\n return AVERROR_INVALIDDATA ;\n }\n ctx -> frame_type = ( buf [ 12 ] >> 2 ) & 3 ;\n if ( ctx -> frame_type > 2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"unsupported frame type: %d\\n\" , ctx -> frame_type ) ;\n return AVERROR_INVALIDDATA ;\n }\n ctx -> chroma_factor = ( buf [ 12 ] >> 6 ) & 3 ;\n ctx -> mb_chroma_factor = ctx -> chroma_factor + 2 ;\n ctx -> num_chroma_blocks = ( 1 << ctx -> chroma_factor ) >> 1 ;\n switch ( ctx -> chroma_factor ) {\n case 2 : avctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ;\n break ;\n case 3 : avctx -> pix_fmt = AV_PIX_FMT_YUV444P10 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"unsupported picture format: %d\\n\" , ctx -> pic_format ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ctx -> scantable_type != ctx -> frame_type ) {\n if ( ! ctx -> frame_type ) ff_init_scantable ( ctx -> dsp . idct_permutation , & ctx -> scantable , ff_prores_progressive_scan ) ;\n else ff_init_scantable ( ctx -> dsp . idct_permutation , & ctx -> scantable , ff_prores_interlaced_scan ) ;\n ctx -> scantable_type = ctx -> frame_type ;\n }\n if ( ctx -> frame_type ) {\n ctx -> picture . interlaced_frame = 1 ;\n ctx -> picture . top_field_first = ctx -> frame_type & 1 ;\n }\n else {\n ctx -> picture . interlaced_frame = 0 ;\n }\n avctx -> color_primaries = buf [ 14 ] ;\n avctx -> color_trc = buf [ 15 ] ;\n avctx -> colorspace = buf [ 16 ] ;\n ctx -> alpha_info = buf [ 17 ] & 0xf ;\n if ( ctx -> alpha_info ) av_log_missing_feature ( avctx , \"Alpha channel\" , 0 ) ;\n ctx -> qmat_changed = 0 ;\n ptr = buf + 20 ;\n flags = buf [ 19 ] ;\n if ( flags & 2 ) {\n if ( ptr - buf > hdr_size - 64 ) {\n av_log ( avctx , AV_LOG_ERROR , \"header data too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( memcmp ( ctx -> qmat_luma , ptr , 64 ) ) {\n memcpy ( ctx -> qmat_luma , ptr , 64 ) ;\n ctx -> qmat_changed = 1 ;\n }\n ptr += 64 ;\n }\n else {\n memset ( ctx -> qmat_luma , 4 , 64 ) ;\n ctx -> qmat_changed = 1 ;\n }\n if ( flags & 1 ) {\n if ( ptr - buf > hdr_size - 64 ) {\n av_log ( avctx , AV_LOG_ERROR , \"header data too small\\n\" ) ;\n return - 1 ;\n }\n if ( memcmp ( ctx -> qmat_chroma , ptr , 64 ) ) {\n memcpy ( ctx -> qmat_chroma , ptr , 64 ) ;\n ctx -> qmat_changed = 1 ;\n }\n }\n else {\n memset ( ctx -> qmat_chroma , 4 , 64 ) ;\n ctx -> qmat_changed = 1 ;\n }\n return hdr_size ;\n }",
        "hash": -1594970847928262768,
        "project": "debian",
        "size": 86,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame_header ( ProresContext * ctx , const uint8_t * buf , const int data_size , AVCodecContext * avctx ) {\n"
                ],
                [
                    61,
                    " if ( memcmp ( ctx -> qmat_luma , ptr , 64 ) ) {\n"
                ],
                [
                    62,
                    " memcpy ( ctx -> qmat_luma , ptr , 64 ) ;\n"
                ],
                [
                    65,
                    " ptr += 64 ;\n"
                ],
                [
                    76,
                    " if ( memcmp ( ctx -> qmat_chroma , ptr , 64 ) ) {\n"
                ],
                [
                    77,
                    " memcpy ( ctx -> qmat_chroma , ptr , 64 ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int decode_frame_header ( ProresContext * ctx , const uint8_t * buf , const int data_size , AVCodecContext * avctx ) {\n"
                ],
                [
                    56,
                    " if ( flags & 2 ) {\n"
                ],
                [
                    68,
                    " memset ( ctx -> qmat_luma , 4 , 64 ) ;\n"
                ],
                [
                    71,
                    " if ( flags & 1 ) {\n"
                ],
                [
                    82,
                    " memset ( ctx -> qmat_chroma , 4 , 64 ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "static int decode_frame_header ( ProresContext * ctx , const uint8_t * buf , const int data_size , AVCodecContext * avctx ) {\n"
                ],
                [
                    57,
                    " if ( ptr - buf > hdr_size - 64 ) {\n"
                ],
                [
                    61,
                    " if ( memcmp ( ctx -> qmat_luma , ptr , 64 ) ) {\n"
                ],
                [
                    62,
                    " memcpy ( ctx -> qmat_luma , ptr , 64 ) ;\n"
                ],
                [
                    63,
                    " ctx -> qmat_changed = 1 ;\n"
                ],
                [
                    65,
                    " ptr += 64 ;\n"
                ],
                [
                    72,
                    " if ( ptr - buf > hdr_size - 64 ) {\n"
                ],
                [
                    76,
                    " if ( memcmp ( ctx -> qmat_chroma , ptr , 64 ) ) {\n"
                ],
                [
                    77,
                    " memcpy ( ctx -> qmat_chroma , ptr , 64 ) ;\n"
                ],
                [
                    78,
                    " ctx -> qmat_changed = 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame_header ( ProresContext * ctx , const uint8_t * buf , const int data_size , AVCodecContext * avctx ) {\n"
                ],
                [
                    56,
                    " if ( flags & 2 ) {\n"
                ],
                [
                    57,
                    " if ( ptr - buf > hdr_size - 64 ) {\n"
                ],
                [
                    61,
                    " if ( memcmp ( ctx -> qmat_luma , ptr , 64 ) ) {\n"
                ],
                [
                    62,
                    " memcpy ( ctx -> qmat_luma , ptr , 64 ) ;\n"
                ],
                [
                    63,
                    " ctx -> qmat_changed = 1 ;\n"
                ],
                [
                    65,
                    " ptr += 64 ;\n"
                ],
                [
                    68,
                    " memset ( ctx -> qmat_luma , 4 , 64 ) ;\n"
                ],
                [
                    71,
                    " if ( flags & 1 ) {\n"
                ],
                [
                    72,
                    " if ( ptr - buf > hdr_size - 64 ) {\n"
                ],
                [
                    76,
                    " if ( memcmp ( ctx -> qmat_chroma , ptr , 64 ) ) {\n"
                ],
                [
                    77,
                    " memcpy ( ctx -> qmat_chroma , ptr , 64 ) ;\n"
                ],
                [
                    78,
                    " ctx -> qmat_changed = 1 ;\n"
                ],
                [
                    82,
                    " memset ( ctx -> qmat_chroma , 4 , 64 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int qcelp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n QCELPContext * q = avctx -> priv_data ;\n AVFrame * frame = data ;\n float * outbuffer ;\n int i , ret ;\n float quantized_lspf [ 10 ] , lpc [ 10 ] ;\n float gain [ 16 ] ;\n float * formant_mem ;\n frame -> nb_samples = 160 ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n outbuffer = ( float * ) frame -> data [ 0 ] ;\n if ( ( q -> bitrate = determine_bitrate ( avctx , buf_size , & buf ) ) == I_F_Q ) {\n warn_insufficient_frame_quality ( avctx , \"bitrate cannot be determined.\" ) ;\n goto erasure ;\n }\n if ( q -> bitrate == RATE_OCTAVE && ( q -> first16bits = AV_RB16 ( buf ) ) == 0xFFFF ) {\n warn_insufficient_frame_quality ( avctx , \"Bitrate is 1/8 and first 16 bits are on.\" ) ;\n goto erasure ;\n }\n if ( q -> bitrate > SILENCE ) {\n const QCELPBitmap * bitmaps = qcelp_unpacking_bitmaps_per_rate [ q -> bitrate ] ;\n const QCELPBitmap * bitmaps_end = qcelp_unpacking_bitmaps_per_rate [ q -> bitrate ] + qcelp_unpacking_bitmaps_lengths [ q -> bitrate ] ;\n uint8_t * unpacked_data = ( uint8_t * ) & q -> frame ;\n init_get_bits ( & q -> gb , buf , 8 * buf_size ) ;\n memset ( & q -> frame , 0 , sizeof ( QCELPFrame ) ) ;\n for ( ;\n bitmaps < bitmaps_end ;\n bitmaps ++ ) unpacked_data [ bitmaps -> index ] |= get_bits ( & q -> gb , bitmaps -> bitlen ) << bitmaps -> bitpos ;\n if ( q -> frame . reserved ) {\n warn_insufficient_frame_quality ( avctx , \"Wrong data in reserved frame area.\" ) ;\n goto erasure ;\n }\n if ( q -> bitrate == RATE_QUARTER && codebook_sanity_check_for_rate_quarter ( q -> frame . cbgain ) ) {\n warn_insufficient_frame_quality ( avctx , \"Codebook gain sanity check failed.\" ) ;\n goto erasure ;\n }\n if ( q -> bitrate >= RATE_HALF ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n if ( q -> frame . pfrac [ i ] && q -> frame . plag [ i ] >= 124 ) {\n warn_insufficient_frame_quality ( avctx , \"Cannot initialize pitch filter.\" ) ;\n goto erasure ;\n }\n }\n }\n }\n decode_gain_and_index ( q , gain ) ;\n compute_svector ( q , gain , outbuffer ) ;\n if ( decode_lspf ( q , quantized_lspf ) < 0 ) {\n warn_insufficient_frame_quality ( avctx , \"Badly received packets in frame.\" ) ;\n goto erasure ;\n }\n apply_pitch_filters ( q , outbuffer ) ;\n if ( q -> bitrate == I_F_Q ) {\n erasure : q -> bitrate = I_F_Q ;\n q -> erasure_count ++ ;\n decode_gain_and_index ( q , gain ) ;\n compute_svector ( q , gain , outbuffer ) ;\n decode_lspf ( q , quantized_lspf ) ;\n apply_pitch_filters ( q , outbuffer ) ;\n }\n else q -> erasure_count = 0 ;\n formant_mem = q -> formant_mem + 10 ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n interpolate_lpc ( q , quantized_lspf , lpc , i ) ;\n ff_celp_lp_synthesis_filterf ( formant_mem , lpc , outbuffer + i * 40 , 40 , 10 ) ;\n formant_mem += 40 ;\n }\n postfilter ( q , outbuffer , lpc ) ;\n memcpy ( q -> formant_mem , q -> formant_mem + 160 , 10 * sizeof ( float ) ) ;\n memcpy ( q -> prev_lspf , quantized_lspf , sizeof ( q -> prev_lspf ) ) ;\n q -> prev_bitrate = q -> bitrate ;\n * got_frame_ptr = 1 ;\n return buf_size ;\n }",
        "hash": -7500496935464390622,
        "project": "debian",
        "size": 83,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int qcelp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    12,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ],
                [
                    55,
                    " if ( decode_lspf ( q , quantized_lspf ) < 0 ) {\n"
                ],
                [
                    59,
                    " apply_pitch_filters ( q , outbuffer ) ;\n"
                ],
                [
                    65,
                    " decode_lspf ( q , quantized_lspf ) ;\n"
                ],
                [
                    66,
                    " apply_pitch_filters ( q , outbuffer ) ;\n"
                ],
                [
                    73,
                    " interpolate_lpc ( q , quantized_lspf , lpc , i ) ;\n"
                ],
                [
                    77,
                    " postfilter ( q , outbuffer , lpc ) ;\n"
                ],
                [
                    78,
                    " memcpy ( q -> formant_mem , q -> formant_mem + 160 , 10 * sizeof ( float ) ) ;\n"
                ],
                [
                    79,
                    " memcpy ( q -> prev_lspf , quantized_lspf , sizeof ( q -> prev_lspf ) ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int qcelp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " QCELPContext * q = avctx -> priv_data ;\n"
                ],
                [
                    25,
                    " if ( q -> bitrate > SILENCE ) {\n"
                ],
                [
                    30,
                    " memset ( & q -> frame , 0 , sizeof ( QCELPFrame ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int qcelp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " QCELPContext * q = avctx -> priv_data ;\n"
                ],
                [
                    12,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ],
                [
                    25,
                    " if ( q -> bitrate > SILENCE ) {\n"
                ],
                [
                    30,
                    " memset ( & q -> frame , 0 , sizeof ( QCELPFrame ) ) ;\n"
                ],
                [
                    55,
                    " if ( decode_lspf ( q , quantized_lspf ) < 0 ) {\n"
                ],
                [
                    59,
                    " apply_pitch_filters ( q , outbuffer ) ;\n"
                ],
                [
                    65,
                    " decode_lspf ( q , quantized_lspf ) ;\n"
                ],
                [
                    66,
                    " apply_pitch_filters ( q , outbuffer ) ;\n"
                ],
                [
                    73,
                    " interpolate_lpc ( q , quantized_lspf , lpc , i ) ;\n"
                ],
                [
                    77,
                    " postfilter ( q , outbuffer , lpc ) ;\n"
                ],
                [
                    78,
                    " memcpy ( q -> formant_mem , q -> formant_mem + 160 , 10 * sizeof ( float ) ) ;\n"
                ],
                [
                    79,
                    " memcpy ( q -> prev_lspf , quantized_lspf , sizeof ( q -> prev_lspf ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void ff_print_debug_info ( MpegEncContext * s , AVFrame * pict ) {\n if ( s -> avctx -> hwaccel || ! pict || ! pict -> mb_type ) return ;\n if ( s -> avctx -> debug & ( FF_DEBUG_SKIP | FF_DEBUG_QP | FF_DEBUG_MB_TYPE ) ) {\n int x , y ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"New frame, type: \" ) ;\n switch ( pict -> pict_type ) {\n case AV_PICTURE_TYPE_I : av_log ( s -> avctx , AV_LOG_DEBUG , \"I\\n\" ) ;\n break ;\n case AV_PICTURE_TYPE_P : av_log ( s -> avctx , AV_LOG_DEBUG , \"P\\n\" ) ;\n break ;\n case AV_PICTURE_TYPE_B : av_log ( s -> avctx , AV_LOG_DEBUG , \"B\\n\" ) ;\n break ;\n case AV_PICTURE_TYPE_S : av_log ( s -> avctx , AV_LOG_DEBUG , \"S\\n\" ) ;\n break ;\n case AV_PICTURE_TYPE_SI : av_log ( s -> avctx , AV_LOG_DEBUG , \"SI\\n\" ) ;\n break ;\n case AV_PICTURE_TYPE_SP : av_log ( s -> avctx , AV_LOG_DEBUG , \"SP\\n\" ) ;\n break ;\n }\n for ( y = 0 ;\n y < s -> mb_height ;\n y ++ ) {\n for ( x = 0 ;\n x < s -> mb_width ;\n x ++ ) {\n if ( s -> avctx -> debug & FF_DEBUG_SKIP ) {\n int count = s -> mbskip_table [ x + y * s -> mb_stride ] ;\n if ( count > 9 ) count = 9 ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"%1d\" , count ) ;\n }\n if ( s -> avctx -> debug & FF_DEBUG_QP ) {\n av_log ( s -> avctx , AV_LOG_DEBUG , \"%2d\" , pict -> qscale_table [ x + y * s -> mb_stride ] ) ;\n }\n if ( s -> avctx -> debug & FF_DEBUG_MB_TYPE ) {\n int mb_type = pict -> mb_type [ x + y * s -> mb_stride ] ;\n if ( IS_PCM ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"P\" ) ;\n else if ( IS_INTRA ( mb_type ) && IS_ACPRED ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"A\" ) ;\n else if ( IS_INTRA4x4 ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"i\" ) ;\n else if ( IS_INTRA16x16 ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"I\" ) ;\n else if ( IS_DIRECT ( mb_type ) && IS_SKIP ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"d\" ) ;\n else if ( IS_DIRECT ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"D\" ) ;\n else if ( IS_GMC ( mb_type ) && IS_SKIP ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"g\" ) ;\n else if ( IS_GMC ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"G\" ) ;\n else if ( IS_SKIP ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"S\" ) ;\n else if ( ! USES_LIST ( mb_type , 1 ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \">\" ) ;\n else if ( ! USES_LIST ( mb_type , 0 ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"<\" ) ;\n else {\n assert ( USES_LIST ( mb_type , 0 ) && USES_LIST ( mb_type , 1 ) ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"X\" ) ;\n }\n if ( IS_8X8 ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"+\" ) ;\n else if ( IS_16X8 ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"-\" ) ;\n else if ( IS_8X16 ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"|\" ) ;\n else if ( IS_INTRA ( mb_type ) || IS_16X16 ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \" \" ) ;\n else av_log ( s -> avctx , AV_LOG_DEBUG , \"?\" ) ;\n if ( IS_INTERLACED ( mb_type ) ) av_log ( s -> avctx , AV_LOG_DEBUG , \"=\" ) ;\n else av_log ( s -> avctx , AV_LOG_DEBUG , \" \" ) ;\n }\n }\n av_log ( s -> avctx , AV_LOG_DEBUG , \"\\n\" ) ;\n }\n }\n if ( ( s -> avctx -> debug & ( FF_DEBUG_VIS_QP | FF_DEBUG_VIS_MB_TYPE ) ) || ( s -> avctx -> debug_mv ) ) {\n const int shift = 1 + s -> quarter_sample ;\n int mb_y ;\n uint8_t * ptr ;\n int i ;\n int h_chroma_shift , v_chroma_shift , block_height ;\n const int width = s -> avctx -> width ;\n const int height = s -> avctx -> height ;\n const int mv_sample_log2 = 4 - pict -> motion_subsample_log2 ;\n const int mv_stride = ( s -> mb_width << mv_sample_log2 ) + ( s -> codec_id == AV_CODEC_ID_H264 ? 0 : 1 ) ;\n s -> low_delay = 0 ;\n av_pix_fmt_get_chroma_sub_sample ( s -> avctx -> pix_fmt , & h_chroma_shift , & v_chroma_shift ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n memcpy ( s -> visualization_buffer [ i ] , pict -> data [ i ] , ( i == 0 ) ? pict -> linesize [ i ] * height : pict -> linesize [ i ] * height >> v_chroma_shift ) ;\n pict -> data [ i ] = s -> visualization_buffer [ i ] ;\n }\n pict -> type = FF_BUFFER_TYPE_COPY ;\n ptr = pict -> data [ 0 ] ;\n block_height = 16 >> v_chroma_shift ;\n for ( mb_y = 0 ;\n mb_y < s -> mb_height ;\n mb_y ++ ) {\n int mb_x ;\n for ( mb_x = 0 ;\n mb_x < s -> mb_width ;\n mb_x ++ ) {\n const int mb_index = mb_x + mb_y * s -> mb_stride ;\n if ( ( s -> avctx -> debug_mv ) && pict -> motion_val ) {\n int type ;\n for ( type = 0 ;\n type < 3 ;\n type ++ ) {\n int direction = 0 ;\n switch ( type ) {\n case 0 : if ( ( ! ( s -> avctx -> debug_mv & FF_DEBUG_VIS_MV_P_FOR ) ) || ( pict -> pict_type != AV_PICTURE_TYPE_P ) ) continue ;\n direction = 0 ;\n break ;\n case 1 : if ( ( ! ( s -> avctx -> debug_mv & FF_DEBUG_VIS_MV_B_FOR ) ) || ( pict -> pict_type != AV_PICTURE_TYPE_B ) ) continue ;\n direction = 0 ;\n break ;\n case 2 : if ( ( ! ( s -> avctx -> debug_mv & FF_DEBUG_VIS_MV_B_BACK ) ) || ( pict -> pict_type != AV_PICTURE_TYPE_B ) ) continue ;\n direction = 1 ;\n break ;\n }\n if ( ! USES_LIST ( pict -> mb_type [ mb_index ] , direction ) ) continue ;\n if ( IS_8X8 ( pict -> mb_type [ mb_index ] ) ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n int sx = mb_x * 16 + 4 + 8 * ( i & 1 ) ;\n int sy = mb_y * 16 + 4 + 8 * ( i >> 1 ) ;\n int xy = ( mb_x * 2 + ( i & 1 ) + ( mb_y * 2 + ( i >> 1 ) ) * mv_stride ) << ( mv_sample_log2 - 1 ) ;\n int mx = ( pict -> motion_val [ direction ] [ xy ] [ 0 ] >> shift ) + sx ;\n int my = ( pict -> motion_val [ direction ] [ xy ] [ 1 ] >> shift ) + sy ;\n draw_arrow ( ptr , sx , sy , mx , my , width , height , s -> linesize , 100 ) ;\n }\n }\n else if ( IS_16X8 ( pict -> mb_type [ mb_index ] ) ) {\n int i ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n int sx = mb_x * 16 + 8 ;\n int sy = mb_y * 16 + 4 + 8 * i ;\n int xy = ( mb_x * 2 + ( mb_y * 2 + i ) * mv_stride ) << ( mv_sample_log2 - 1 ) ;\n int mx = ( pict -> motion_val [ direction ] [ xy ] [ 0 ] >> shift ) ;\n int my = ( pict -> motion_val [ direction ] [ xy ] [ 1 ] >> shift ) ;\n if ( IS_INTERLACED ( pict -> mb_type [ mb_index ] ) ) my *= 2 ;\n draw_arrow ( ptr , sx , sy , mx + sx , my + sy , width , height , s -> linesize , 100 ) ;\n }\n }\n else if ( IS_8X16 ( pict -> mb_type [ mb_index ] ) ) {\n int i ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n int sx = mb_x * 16 + 4 + 8 * i ;\n int sy = mb_y * 16 + 8 ;\n int xy = ( mb_x * 2 + i + mb_y * 2 * mv_stride ) << ( mv_sample_log2 - 1 ) ;\n int mx = pict -> motion_val [ direction ] [ xy ] [ 0 ] >> shift ;\n int my = pict -> motion_val [ direction ] [ xy ] [ 1 ] >> shift ;\n if ( IS_INTERLACED ( pict -> mb_type [ mb_index ] ) ) my *= 2 ;\n draw_arrow ( ptr , sx , sy , mx + sx , my + sy , width , height , s -> linesize , 100 ) ;\n }\n }\n else {\n int sx = mb_x * 16 + 8 ;\n int sy = mb_y * 16 + 8 ;\n int xy = ( mb_x + mb_y * mv_stride ) << mv_sample_log2 ;\n int mx = pict -> motion_val [ direction ] [ xy ] [ 0 ] >> shift + sx ;\n int my = pict -> motion_val [ direction ] [ xy ] [ 1 ] >> shift + sy ;\n draw_arrow ( ptr , sx , sy , mx , my , width , height , s -> linesize , 100 ) ;\n }\n }\n }\n if ( ( s -> avctx -> debug & FF_DEBUG_VIS_QP ) && pict -> motion_val ) {\n uint64_t c = ( pict -> qscale_table [ mb_index ] * 128 / 31 ) * 0x0101010101010101ULL ;\n int y ;\n for ( y = 0 ;\n y < block_height ;\n y ++ ) {\n * ( uint64_t * ) ( pict -> data [ 1 ] + 8 * mb_x + ( block_height * mb_y + y ) * pict -> linesize [ 1 ] ) = c ;\n * ( uint64_t * ) ( pict -> data [ 2 ] + 8 * mb_x + ( block_height * mb_y + y ) * pict -> linesize [ 2 ] ) = c ;\n }\n }\n if ( ( s -> avctx -> debug & FF_DEBUG_VIS_MB_TYPE ) && pict -> motion_val ) {\n int mb_type = pict -> mb_type [ mb_index ] ;\n uint64_t u , v ;\n int y ;\n # define COLOR ( theta , r ) u = ( int ) ( 128 + r * cos ( theta * 3.141592 / 180 ) ) ;\n v = ( int ) ( 128 + r * sin ( theta * 3.141592 / 180 ) ) ;\n u = v = 128 ;\n if ( IS_PCM ( mb_type ) ) {\n COLOR ( 120 , 48 ) }\n else if ( ( IS_INTRA ( mb_type ) && IS_ACPRED ( mb_type ) ) || IS_INTRA16x16 ( mb_type ) ) {\n COLOR ( 30 , 48 ) }\n else if ( IS_INTRA4x4 ( mb_type ) ) {\n COLOR ( 90 , 48 ) }\n else if ( IS_DIRECT ( mb_type ) && IS_SKIP ( mb_type ) ) {\n }\n else if ( IS_DIRECT ( mb_type ) ) {\n COLOR ( 150 , 48 ) }\n else if ( IS_GMC ( mb_type ) && IS_SKIP ( mb_type ) ) {\n COLOR ( 170 , 48 ) }\n else if ( IS_GMC ( mb_type ) ) {\n COLOR ( 190 , 48 ) }\n else if ( IS_SKIP ( mb_type ) ) {\n }\n else if ( ! USES_LIST ( mb_type , 1 ) ) {\n COLOR ( 240 , 48 ) }\n else if ( ! USES_LIST ( mb_type , 0 ) ) {\n COLOR ( 0 , 48 ) }\n else {\n assert ( USES_LIST ( mb_type , 0 ) && USES_LIST ( mb_type , 1 ) ) ;\n COLOR ( 300 , 48 ) }\n u *= 0x0101010101010101ULL ;\n v *= 0x0101010101010101ULL ;\n for ( y = 0 ;\n y < block_height ;\n y ++ ) {\n * ( uint64_t * ) ( pict -> data [ 1 ] + 8 * mb_x + ( block_height * mb_y + y ) * pict -> linesize [ 1 ] ) = u ;\n * ( uint64_t * ) ( pict -> data [ 2 ] + 8 * mb_x + ( block_height * mb_y + y ) * pict -> linesize [ 2 ] ) = v ;\n }\n if ( IS_8X8 ( mb_type ) || IS_16X8 ( mb_type ) ) {\n * ( uint64_t * ) ( pict -> data [ 0 ] + 16 * mb_x + 0 + ( 16 * mb_y + 8 ) * pict -> linesize [ 0 ] ) ^= 0x8080808080808080ULL ;\n * ( uint64_t * ) ( pict -> data [ 0 ] + 16 * mb_x + 8 + ( 16 * mb_y + 8 ) * pict -> linesize [ 0 ] ) ^= 0x8080808080808080ULL ;\n }\n if ( IS_8X8 ( mb_type ) || IS_8X16 ( mb_type ) ) {\n for ( y = 0 ;\n y < 16 ;\n y ++ ) pict -> data [ 0 ] [ 16 * mb_x + 8 + ( 16 * mb_y + y ) * pict -> linesize [ 0 ] ] ^= 0x80 ;\n }\n if ( IS_8X8 ( mb_type ) && mv_sample_log2 >= 2 ) {\n int dm = 1 << ( mv_sample_log2 - 2 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n int sx = mb_x * 16 + 8 * ( i & 1 ) ;\n int sy = mb_y * 16 + 8 * ( i >> 1 ) ;\n int xy = ( mb_x * 2 + ( i & 1 ) + ( mb_y * 2 + ( i >> 1 ) ) * mv_stride ) << ( mv_sample_log2 - 1 ) ;\n int32_t * mv = ( int32_t * ) & pict -> motion_val [ 0 ] [ xy ] ;\n if ( mv [ 0 ] != mv [ dm ] || mv [ dm * mv_stride ] != mv [ dm * ( mv_stride + 1 ) ] ) for ( y = 0 ;\n y < 8 ;\n y ++ ) pict -> data [ 0 ] [ sx + 4 + ( sy + y ) * pict -> linesize [ 0 ] ] ^= 0x80 ;\n if ( mv [ 0 ] != mv [ dm * mv_stride ] || mv [ dm ] != mv [ dm * ( mv_stride + 1 ) ] ) * ( uint64_t * ) ( pict -> data [ 0 ] + sx + ( sy + 4 ) * pict -> linesize [ 0 ] ) ^= 0x8080808080808080ULL ;\n }\n }\n if ( IS_INTERLACED ( mb_type ) && s -> codec_id == AV_CODEC_ID_H264 ) {\n }\n }\n s -> mbskip_table [ mb_index ] = 0 ;\n }\n }\n }\n }",
        "hash": 2713698759296604855,
        "project": "debian",
        "size": 240,
        "slice": {
            "memcpy": [
                [
                    76,
                    " i < 3 ;\n"
                ],
                [
                    78,
                    " memcpy ( s -> visualization_buffer [ i ] , pict -> data [ i ] , ( i == 0 ) ? pict -> linesize [ i ] * height : pict -> linesize [ i ] * height >> v_chroma_shift ) ;\n"
                ],
                [
                    79,
                    " pict -> data [ i ] = s -> visualization_buffer [ i ] ;\n"
                ]
            ],
            "result": [
                [
                    76,
                    " i < 3 ;\n"
                ],
                [
                    78,
                    " memcpy ( s -> visualization_buffer [ i ] , pict -> data [ i ] , ( i == 0 ) ? pict -> linesize [ i ] * height : pict -> linesize [ i ] * height >> v_chroma_shift ) ;\n"
                ],
                [
                    79,
                    " pict -> data [ i ] = s -> visualization_buffer [ i ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ff_MPV_frame_start ( MpegEncContext * s , AVCodecContext * avctx ) {\n int i ;\n Picture * pic ;\n s -> mb_skipped = 0 ;\n if ( s -> out_format != FMT_H264 || s -> codec_id == AV_CODEC_ID_SVQ3 ) {\n if ( s -> pict_type != AV_PICTURE_TYPE_B && s -> last_picture_ptr && s -> last_picture_ptr != s -> next_picture_ptr && s -> last_picture_ptr -> f . data [ 0 ] ) {\n if ( s -> last_picture_ptr -> owner2 == s ) free_frame_buffer ( s , s -> last_picture_ptr ) ;\n }\n if ( ! s -> encoding ) {\n for ( i = 0 ;\n i < s -> picture_count ;\n i ++ ) {\n if ( s -> picture [ i ] . owner2 == s && s -> picture [ i ] . f . data [ 0 ] && & s -> picture [ i ] != s -> last_picture_ptr && & s -> picture [ i ] != s -> next_picture_ptr && s -> picture [ i ] . f . reference && ! s -> picture [ i ] . needs_realloc ) {\n if ( ! ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) av_log ( avctx , AV_LOG_ERROR , \"releasing zombie picture\\n\" ) ;\n free_frame_buffer ( s , & s -> picture [ i ] ) ;\n }\n }\n }\n }\n if ( ! s -> encoding ) {\n ff_release_unused_pictures ( s , 1 ) ;\n if ( s -> current_picture_ptr && s -> current_picture_ptr -> f . data [ 0 ] == NULL ) {\n pic = s -> current_picture_ptr ;\n }\n else {\n i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"no frame buffer available\\n\" ) ;\n return i ;\n }\n pic = & s -> picture [ i ] ;\n }\n pic -> f . reference = 0 ;\n if ( ! s -> droppable ) {\n if ( s -> codec_id == AV_CODEC_ID_H264 ) pic -> f . reference = s -> picture_structure ;\n else if ( s -> pict_type != AV_PICTURE_TYPE_B ) pic -> f . reference = 3 ;\n }\n pic -> f . coded_picture_number = s -> coded_picture_number ++ ;\n if ( ff_alloc_picture ( s , pic , 0 ) < 0 ) return - 1 ;\n s -> current_picture_ptr = pic ;\n s -> current_picture_ptr -> f . top_field_first = s -> top_field_first ;\n if ( s -> codec_id == AV_CODEC_ID_MPEG1VIDEO || s -> codec_id == AV_CODEC_ID_MPEG2VIDEO ) {\n if ( s -> picture_structure != PICT_FRAME ) s -> current_picture_ptr -> f . top_field_first = ( s -> picture_structure == PICT_TOP_FIELD ) == s -> first_field ;\n }\n s -> current_picture_ptr -> f . interlaced_frame = ! s -> progressive_frame && ! s -> progressive_sequence ;\n s -> current_picture_ptr -> field_picture = s -> picture_structure != PICT_FRAME ;\n }\n s -> current_picture_ptr -> f . pict_type = s -> pict_type ;\n s -> current_picture_ptr -> f . key_frame = s -> pict_type == AV_PICTURE_TYPE_I ;\n ff_copy_picture ( & s -> current_picture , s -> current_picture_ptr ) ;\n if ( s -> pict_type != AV_PICTURE_TYPE_B ) {\n s -> last_picture_ptr = s -> next_picture_ptr ;\n if ( ! s -> droppable ) s -> next_picture_ptr = s -> current_picture_ptr ;\n }\n av_dlog ( s -> avctx , \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\" , s -> last_picture_ptr , s -> next_picture_ptr , s -> current_picture_ptr , s -> last_picture_ptr ? s -> last_picture_ptr -> f . data [ 0 ] : NULL , s -> next_picture_ptr ? s -> next_picture_ptr -> f . data [ 0 ] : NULL , s -> current_picture_ptr ? s -> current_picture_ptr -> f . data [ 0 ] : NULL , s -> pict_type , s -> droppable ) ;\n if ( s -> codec_id != AV_CODEC_ID_H264 ) {\n if ( ( s -> last_picture_ptr == NULL || s -> last_picture_ptr -> f . data [ 0 ] == NULL ) && ( s -> pict_type != AV_PICTURE_TYPE_I || s -> picture_structure != PICT_FRAME ) ) {\n int h_chroma_shift , v_chroma_shift ;\n av_pix_fmt_get_chroma_sub_sample ( s -> avctx -> pix_fmt , & h_chroma_shift , & v_chroma_shift ) ;\n if ( s -> pict_type != AV_PICTURE_TYPE_I ) av_log ( avctx , AV_LOG_ERROR , \"warning: first frame is no keyframe\\n\" ) ;\n else if ( s -> picture_structure != PICT_FRAME ) av_log ( avctx , AV_LOG_INFO , \"allocate dummy last picture for field based first keyframe\\n\" ) ;\n i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"no frame buffer available\\n\" ) ;\n return i ;\n }\n s -> last_picture_ptr = & s -> picture [ i ] ;\n if ( ff_alloc_picture ( s , s -> last_picture_ptr , 0 ) < 0 ) {\n s -> last_picture_ptr = NULL ;\n return - 1 ;\n }\n memset ( s -> last_picture_ptr -> f . data [ 0 ] , 0 , avctx -> height * s -> last_picture_ptr -> f . linesize [ 0 ] ) ;\n memset ( s -> last_picture_ptr -> f . data [ 1 ] , 0x80 , ( avctx -> height >> v_chroma_shift ) * s -> last_picture_ptr -> f . linesize [ 1 ] ) ;\n memset ( s -> last_picture_ptr -> f . data [ 2 ] , 0x80 , ( avctx -> height >> v_chroma_shift ) * s -> last_picture_ptr -> f . linesize [ 2 ] ) ;\n ff_thread_report_progress ( & s -> last_picture_ptr -> f , INT_MAX , 0 ) ;\n ff_thread_report_progress ( & s -> last_picture_ptr -> f , INT_MAX , 1 ) ;\n s -> last_picture_ptr -> f . reference = 3 ;\n }\n if ( ( s -> next_picture_ptr == NULL || s -> next_picture_ptr -> f . data [ 0 ] == NULL ) && s -> pict_type == AV_PICTURE_TYPE_B ) {\n i = ff_find_unused_picture ( s , 0 ) ;\n if ( i < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"no frame buffer available\\n\" ) ;\n return i ;\n }\n s -> next_picture_ptr = & s -> picture [ i ] ;\n if ( ff_alloc_picture ( s , s -> next_picture_ptr , 0 ) < 0 ) {\n s -> next_picture_ptr = NULL ;\n return - 1 ;\n }\n ff_thread_report_progress ( & s -> next_picture_ptr -> f , INT_MAX , 0 ) ;\n ff_thread_report_progress ( & s -> next_picture_ptr -> f , INT_MAX , 1 ) ;\n s -> next_picture_ptr -> f . reference = 3 ;\n }\n }\n if ( s -> last_picture_ptr ) ff_copy_picture ( & s -> last_picture , s -> last_picture_ptr ) ;\n if ( s -> next_picture_ptr ) ff_copy_picture ( & s -> next_picture , s -> next_picture_ptr ) ;\n if ( HAVE_THREADS && ( avctx -> active_thread_type & FF_THREAD_FRAME ) ) {\n if ( s -> next_picture_ptr ) s -> next_picture_ptr -> owner2 = s ;\n if ( s -> last_picture_ptr ) s -> last_picture_ptr -> owner2 = s ;\n }\n assert ( s -> pict_type == AV_PICTURE_TYPE_I || ( s -> last_picture_ptr && s -> last_picture_ptr -> f . data [ 0 ] ) ) ;\n if ( s -> picture_structure != PICT_FRAME && s -> out_format != FMT_H264 ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n if ( s -> picture_structure == PICT_BOTTOM_FIELD ) {\n s -> current_picture . f . data [ i ] += s -> current_picture . f . linesize [ i ] ;\n }\n s -> current_picture . f . linesize [ i ] *= 2 ;\n s -> last_picture . f . linesize [ i ] *= 2 ;\n s -> next_picture . f . linesize [ i ] *= 2 ;\n }\n }\n s -> err_recognition = avctx -> err_recognition ;\n if ( s -> mpeg_quant || s -> codec_id == AV_CODEC_ID_MPEG2VIDEO ) {\n s -> dct_unquantize_intra = s -> dct_unquantize_mpeg2_intra ;\n s -> dct_unquantize_inter = s -> dct_unquantize_mpeg2_inter ;\n }\n else if ( s -> out_format == FMT_H263 || s -> out_format == FMT_H261 ) {\n s -> dct_unquantize_intra = s -> dct_unquantize_h263_intra ;\n s -> dct_unquantize_inter = s -> dct_unquantize_h263_inter ;\n }\n else {\n s -> dct_unquantize_intra = s -> dct_unquantize_mpeg1_intra ;\n s -> dct_unquantize_inter = s -> dct_unquantize_mpeg1_inter ;\n }\n if ( s -> dct_error_sum ) {\n assert ( s -> avctx -> noise_reduction && s -> encoding ) ;\n update_noise_reduction ( s ) ;\n }\n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration ) return ff_xvmc_field_start ( s , avctx ) ;\n return 0 ;\n }",
        "hash": 2713698759296604855,
        "project": "debian",
        "size": 134,
        "slice": {
            "memset": [
                [
                    1,
                    "int ff_MPV_frame_start ( MpegEncContext * s , AVCodecContext * avctx ) {\n"
                ],
                [
                    6,
                    " if ( s -> pict_type != AV_PICTURE_TYPE_B && s -> last_picture_ptr && s -> last_picture_ptr != s -> next_picture_ptr && s -> last_picture_ptr -> f . data [ 0 ] ) {\n"
                ],
                [
                    57,
                    " if ( ( s -> last_picture_ptr == NULL || s -> last_picture_ptr -> f . data [ 0 ] == NULL ) && ( s -> pict_type != AV_PICTURE_TYPE_I || s -> picture_structure != PICT_FRAME ) ) {\n"
                ],
                [
                    68,
                    " if ( ff_alloc_picture ( s , s -> last_picture_ptr , 0 ) < 0 ) {\n"
                ],
                [
                    72,
                    " memset ( s -> last_picture_ptr -> f . data [ 0 ] , 0 , avctx -> height * s -> last_picture_ptr -> f . linesize [ 0 ] ) ;\n"
                ],
                [
                    73,
                    " memset ( s -> last_picture_ptr -> f . data [ 1 ] , 0x80 , ( avctx -> height >> v_chroma_shift ) * s -> last_picture_ptr -> f . linesize [ 1 ] ) ;\n"
                ],
                [
                    74,
                    " memset ( s -> last_picture_ptr -> f . data [ 2 ] , 0x80 , ( avctx -> height >> v_chroma_shift ) * s -> last_picture_ptr -> f . linesize [ 2 ] ) ;\n"
                ],
                [
                    101,
                    " assert ( s -> pict_type == AV_PICTURE_TYPE_I || ( s -> last_picture_ptr && s -> last_picture_ptr -> f . data [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ff_MPV_frame_start ( MpegEncContext * s , AVCodecContext * avctx ) {\n"
                ],
                [
                    6,
                    " if ( s -> pict_type != AV_PICTURE_TYPE_B && s -> last_picture_ptr && s -> last_picture_ptr != s -> next_picture_ptr && s -> last_picture_ptr -> f . data [ 0 ] ) {\n"
                ],
                [
                    57,
                    " if ( ( s -> last_picture_ptr == NULL || s -> last_picture_ptr -> f . data [ 0 ] == NULL ) && ( s -> pict_type != AV_PICTURE_TYPE_I || s -> picture_structure != PICT_FRAME ) ) {\n"
                ],
                [
                    68,
                    " if ( ff_alloc_picture ( s , s -> last_picture_ptr , 0 ) < 0 ) {\n"
                ],
                [
                    72,
                    " memset ( s -> last_picture_ptr -> f . data [ 0 ] , 0 , avctx -> height * s -> last_picture_ptr -> f . linesize [ 0 ] ) ;\n"
                ],
                [
                    73,
                    " memset ( s -> last_picture_ptr -> f . data [ 1 ] , 0x80 , ( avctx -> height >> v_chroma_shift ) * s -> last_picture_ptr -> f . linesize [ 1 ] ) ;\n"
                ],
                [
                    74,
                    " memset ( s -> last_picture_ptr -> f . data [ 2 ] , 0x80 , ( avctx -> height >> v_chroma_shift ) * s -> last_picture_ptr -> f . linesize [ 2 ] ) ;\n"
                ],
                [
                    101,
                    " assert ( s -> pict_type == AV_PICTURE_TYPE_I || ( s -> last_picture_ptr && s -> last_picture_ptr -> f . data [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ff_MPV_common_frame_size_change ( MpegEncContext * s ) {\n int i , err = 0 ;\n if ( s -> slice_context_count > 1 ) {\n for ( i = 0 ;\n i < s -> slice_context_count ;\n i ++ ) {\n free_duplicate_context ( s -> thread_context [ i ] ) ;\n }\n for ( i = 1 ;\n i < s -> slice_context_count ;\n i ++ ) {\n av_freep ( & s -> thread_context [ i ] ) ;\n }\n }\n else free_duplicate_context ( s ) ;\n free_context_frame ( s ) ;\n if ( s -> picture ) for ( i = 0 ;\n i < s -> picture_count ;\n i ++ ) {\n s -> picture [ i ] . needs_realloc = 1 ;\n }\n s -> last_picture_ptr = s -> next_picture_ptr = s -> current_picture_ptr = NULL ;\n if ( s -> codec_id == AV_CODEC_ID_MPEG2VIDEO && ! s -> progressive_sequence ) s -> mb_height = ( s -> height + 31 ) / 32 * 2 ;\n else if ( s -> codec_id != AV_CODEC_ID_H264 ) s -> mb_height = ( s -> height + 15 ) / 16 ;\n if ( ( s -> width || s -> height ) && av_image_check_size ( s -> width , s -> height , 0 , s -> avctx ) ) return AVERROR_INVALIDDATA ;\n if ( ( err = init_context_frame ( s ) ) ) goto fail ;\n s -> thread_context [ 0 ] = s ;\n if ( s -> width && s -> height ) {\n int nb_slices = s -> slice_context_count ;\n if ( nb_slices > 1 ) {\n for ( i = 1 ;\n i < nb_slices ;\n i ++ ) {\n s -> thread_context [ i ] = av_malloc ( sizeof ( MpegEncContext ) ) ;\n memcpy ( s -> thread_context [ i ] , s , sizeof ( MpegEncContext ) ) ;\n }\n for ( i = 0 ;\n i < nb_slices ;\n i ++ ) {\n if ( init_duplicate_context ( s -> thread_context [ i ] ) < 0 ) goto fail ;\n s -> thread_context [ i ] -> start_mb_y = ( s -> mb_height * ( i ) + nb_slices / 2 ) / nb_slices ;\n s -> thread_context [ i ] -> end_mb_y = ( s -> mb_height * ( i + 1 ) + nb_slices / 2 ) / nb_slices ;\n }\n }\n else {\n if ( init_duplicate_context ( s ) < 0 ) goto fail ;\n s -> start_mb_y = 0 ;\n s -> end_mb_y = s -> mb_height ;\n }\n s -> slice_context_count = nb_slices ;\n }\n return 0 ;\n fail : ff_MPV_common_end ( s ) ;\n return err ;\n }",
        "hash": 2713698759296604855,
        "project": "debian",
        "size": 55,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int ff_MPV_common_frame_size_change ( MpegEncContext * s ) {\n"
                ],
                [
                    3,
                    " if ( s -> slice_context_count > 1 ) {\n"
                ],
                [
                    10,
                    " i < s -> slice_context_count ;\n"
                ],
                [
                    12,
                    " av_freep ( & s -> thread_context [ i ] ) ;\n"
                ],
                [
                    18,
                    " i < s -> picture_count ;\n"
                ],
                [
                    22,
                    " s -> last_picture_ptr = s -> next_picture_ptr = s -> current_picture_ptr = NULL ;\n"
                ],
                [
                    23,
                    " if ( s -> codec_id == AV_CODEC_ID_MPEG2VIDEO && ! s -> progressive_sequence ) s -> mb_height = ( s -> height + 31 ) / 32 * 2 ;\n"
                ],
                [
                    24,
                    " else if ( s -> codec_id != AV_CODEC_ID_H264 ) s -> mb_height = ( s -> height + 15 ) / 16 ;\n"
                ],
                [
                    25,
                    " if ( ( s -> width || s -> height ) && av_image_check_size ( s -> width , s -> height , 0 , s -> avctx ) ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    26,
                    " if ( ( err = init_context_frame ( s ) ) ) goto fail ;\n"
                ],
                [
                    28,
                    " if ( s -> width && s -> height ) {\n"
                ],
                [
                    32,
                    " i < nb_slices ;\n"
                ],
                [
                    34,
                    " s -> thread_context [ i ] = av_malloc ( sizeof ( MpegEncContext ) ) ;\n"
                ],
                [
                    35,
                    " memcpy ( s -> thread_context [ i ] , s , sizeof ( MpegEncContext ) ) ;\n"
                ],
                [
                    40,
                    " if ( init_duplicate_context ( s -> thread_context [ i ] ) < 0 ) goto fail ;\n"
                ],
                [
                    41,
                    " s -> thread_context [ i ] -> start_mb_y = ( s -> mb_height * ( i ) + nb_slices / 2 ) / nb_slices ;\n"
                ],
                [
                    42,
                    " s -> thread_context [ i ] -> end_mb_y = ( s -> mb_height * ( i + 1 ) + nb_slices / 2 ) / nb_slices ;\n"
                ],
                [
                    53,
                    " fail : ff_MPV_common_end ( s ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ff_MPV_common_frame_size_change ( MpegEncContext * s ) {\n"
                ],
                [
                    3,
                    " if ( s -> slice_context_count > 1 ) {\n"
                ],
                [
                    10,
                    " i < s -> slice_context_count ;\n"
                ],
                [
                    12,
                    " av_freep ( & s -> thread_context [ i ] ) ;\n"
                ],
                [
                    18,
                    " i < s -> picture_count ;\n"
                ],
                [
                    22,
                    " s -> last_picture_ptr = s -> next_picture_ptr = s -> current_picture_ptr = NULL ;\n"
                ],
                [
                    23,
                    " if ( s -> codec_id == AV_CODEC_ID_MPEG2VIDEO && ! s -> progressive_sequence ) s -> mb_height = ( s -> height + 31 ) / 32 * 2 ;\n"
                ],
                [
                    24,
                    " else if ( s -> codec_id != AV_CODEC_ID_H264 ) s -> mb_height = ( s -> height + 15 ) / 16 ;\n"
                ],
                [
                    25,
                    " if ( ( s -> width || s -> height ) && av_image_check_size ( s -> width , s -> height , 0 , s -> avctx ) ) return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    26,
                    " if ( ( err = init_context_frame ( s ) ) ) goto fail ;\n"
                ],
                [
                    28,
                    " if ( s -> width && s -> height ) {\n"
                ],
                [
                    32,
                    " i < nb_slices ;\n"
                ],
                [
                    34,
                    " s -> thread_context [ i ] = av_malloc ( sizeof ( MpegEncContext ) ) ;\n"
                ],
                [
                    35,
                    " memcpy ( s -> thread_context [ i ] , s , sizeof ( MpegEncContext ) ) ;\n"
                ],
                [
                    40,
                    " if ( init_duplicate_context ( s -> thread_context [ i ] ) < 0 ) goto fail ;\n"
                ],
                [
                    41,
                    " s -> thread_context [ i ] -> start_mb_y = ( s -> mb_height * ( i ) + nb_slices / 2 ) / nb_slices ;\n"
                ],
                [
                    42,
                    " s -> thread_context [ i ] -> end_mb_y = ( s -> mb_height * ( i + 1 ) + nb_slices / 2 ) / nb_slices ;\n"
                ],
                [
                    53,
                    " fail : ff_MPV_common_end ( s ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ff_mpeg_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n int i ;\n MpegEncContext * s = dst -> priv_data , * s1 = src -> priv_data ;\n if ( dst == src || ! s1 -> context_initialized ) return 0 ;\n if ( ! s -> context_initialized ) {\n memcpy ( s , s1 , sizeof ( MpegEncContext ) ) ;\n s -> avctx = dst ;\n s -> picture_range_start += MAX_PICTURE_COUNT ;\n s -> picture_range_end += MAX_PICTURE_COUNT ;\n s -> bitstream_buffer = NULL ;\n s -> bitstream_buffer_size = s -> allocated_bitstream_buffer_size = 0 ;\n ff_MPV_common_init ( s ) ;\n }\n if ( s -> height != s1 -> height || s -> width != s1 -> width || s -> context_reinit ) {\n int err ;\n s -> context_reinit = 0 ;\n s -> height = s1 -> height ;\n s -> width = s1 -> width ;\n if ( ( err = ff_MPV_common_frame_size_change ( s ) ) < 0 ) return err ;\n }\n s -> avctx -> coded_height = s1 -> avctx -> coded_height ;\n s -> avctx -> coded_width = s1 -> avctx -> coded_width ;\n s -> avctx -> width = s1 -> avctx -> width ;\n s -> avctx -> height = s1 -> avctx -> height ;\n s -> coded_picture_number = s1 -> coded_picture_number ;\n s -> picture_number = s1 -> picture_number ;\n s -> input_picture_number = s1 -> input_picture_number ;\n memcpy ( s -> picture , s1 -> picture , s1 -> picture_count * sizeof ( Picture ) ) ;\n memcpy ( & s -> last_picture , & s1 -> last_picture , ( char * ) & s1 -> last_picture_ptr - ( char * ) & s1 -> last_picture ) ;\n for ( i = 0 ;\n i < s -> picture_count ;\n i ++ ) s -> picture [ i ] . f . extended_data = s -> picture [ i ] . f . data ;\n s -> last_picture_ptr = REBASE_PICTURE ( s1 -> last_picture_ptr , s , s1 ) ;\n s -> current_picture_ptr = REBASE_PICTURE ( s1 -> current_picture_ptr , s , s1 ) ;\n s -> next_picture_ptr = REBASE_PICTURE ( s1 -> next_picture_ptr , s , s1 ) ;\n s -> next_p_frame_damaged = s1 -> next_p_frame_damaged ;\n s -> workaround_bugs = s1 -> workaround_bugs ;\n memcpy ( & s -> time_increment_bits , & s1 -> time_increment_bits , ( char * ) & s1 -> shape - ( char * ) & s1 -> time_increment_bits ) ;\n s -> max_b_frames = s1 -> max_b_frames ;\n s -> low_delay = s1 -> low_delay ;\n s -> droppable = s1 -> droppable ;\n s -> divx_packed = s1 -> divx_packed ;\n if ( s1 -> bitstream_buffer ) {\n if ( s1 -> bitstream_buffer_size + FF_INPUT_BUFFER_PADDING_SIZE > s -> allocated_bitstream_buffer_size ) av_fast_malloc ( & s -> bitstream_buffer , & s -> allocated_bitstream_buffer_size , s1 -> allocated_bitstream_buffer_size ) ;\n s -> bitstream_buffer_size = s1 -> bitstream_buffer_size ;\n memcpy ( s -> bitstream_buffer , s1 -> bitstream_buffer , s1 -> bitstream_buffer_size ) ;\n memset ( s -> bitstream_buffer + s -> bitstream_buffer_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n }\n if ( ! s -> edge_emu_buffer ) if ( s1 -> linesize ) {\n if ( ff_mpv_frame_size_alloc ( s , s1 -> linesize ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Failed to allocate context \" \"scratch buffers.\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Context scratch buffers could not \" \"be allocated due to unknown size.\\n\" ) ;\n return AVERROR_BUG ;\n }\n memcpy ( & s -> progressive_sequence , & s1 -> progressive_sequence , ( char * ) & s1 -> rtp_mode - ( char * ) & s1 -> progressive_sequence ) ;\n if ( ! s1 -> first_field ) {\n s -> last_pict_type = s1 -> pict_type ;\n if ( s1 -> current_picture_ptr ) s -> last_lambda_for [ s1 -> pict_type ] = s1 -> current_picture_ptr -> f . quality ;\n if ( s1 -> pict_type != AV_PICTURE_TYPE_B ) {\n s -> last_non_b_pict_type = s1 -> pict_type ;\n }\n }\n return 0 ;\n }",
        "hash": 2713698759296604855,
        "project": "debian",
        "size": 68,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int ff_mpeg_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n"
                ],
                [
                    3,
                    " MpegEncContext * s = dst -> priv_data , * s1 = src -> priv_data ;\n"
                ],
                [
                    4,
                    " if ( dst == src || ! s1 -> context_initialized ) return 0 ;\n"
                ],
                [
                    5,
                    " if ( ! s -> context_initialized ) {\n"
                ],
                [
                    6,
                    " memcpy ( s , s1 , sizeof ( MpegEncContext ) ) ;\n"
                ],
                [
                    8,
                    " s -> picture_range_start += MAX_PICTURE_COUNT ;\n"
                ],
                [
                    9,
                    " s -> picture_range_end += MAX_PICTURE_COUNT ;\n"
                ],
                [
                    10,
                    " s -> bitstream_buffer = NULL ;\n"
                ],
                [
                    12,
                    " ff_MPV_common_init ( s ) ;\n"
                ],
                [
                    14,
                    " if ( s -> height != s1 -> height || s -> width != s1 -> width || s -> context_reinit ) {\n"
                ],
                [
                    17,
                    " s -> height = s1 -> height ;\n"
                ],
                [
                    18,
                    " s -> width = s1 -> width ;\n"
                ],
                [
                    19,
                    " if ( ( err = ff_MPV_common_frame_size_change ( s ) ) < 0 ) return err ;\n"
                ],
                [
                    25,
                    " s -> coded_picture_number = s1 -> coded_picture_number ;\n"
                ],
                [
                    26,
                    " s -> picture_number = s1 -> picture_number ;\n"
                ],
                [
                    27,
                    " s -> input_picture_number = s1 -> input_picture_number ;\n"
                ],
                [
                    28,
                    " memcpy ( s -> picture , s1 -> picture , s1 -> picture_count * sizeof ( Picture ) ) ;\n"
                ],
                [
                    29,
                    " memcpy ( & s -> last_picture , & s1 -> last_picture , ( char * ) & s1 -> last_picture_ptr - ( char * ) & s1 -> last_picture ) ;\n"
                ],
                [
                    33,
                    " s -> last_picture_ptr = REBASE_PICTURE ( s1 -> last_picture_ptr , s , s1 ) ;\n"
                ],
                [
                    34,
                    " s -> current_picture_ptr = REBASE_PICTURE ( s1 -> current_picture_ptr , s , s1 ) ;\n"
                ],
                [
                    35,
                    " s -> next_picture_ptr = REBASE_PICTURE ( s1 -> next_picture_ptr , s , s1 ) ;\n"
                ],
                [
                    38,
                    " memcpy ( & s -> time_increment_bits , & s1 -> time_increment_bits , ( char * ) & s1 -> shape - ( char * ) & s1 -> time_increment_bits ) ;\n"
                ],
                [
                    43,
                    " if ( s1 -> bitstream_buffer ) {\n"
                ],
                [
                    44,
                    " if ( s1 -> bitstream_buffer_size + FF_INPUT_BUFFER_PADDING_SIZE > s -> allocated_bitstream_buffer_size ) av_fast_malloc ( & s -> bitstream_buffer , & s -> allocated_bitstream_buffer_size , s1 -> allocated_bitstream_buffer_size ) ;\n"
                ],
                [
                    46,
                    " memcpy ( s -> bitstream_buffer , s1 -> bitstream_buffer , s1 -> bitstream_buffer_size ) ;\n"
                ],
                [
                    47,
                    " memset ( s -> bitstream_buffer + s -> bitstream_buffer_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    49,
                    " if ( ! s -> edge_emu_buffer ) if ( s1 -> linesize ) {\n"
                ],
                [
                    50,
                    " if ( ff_mpv_frame_size_alloc ( s , s1 -> linesize ) < 0 ) {\n"
                ],
                [
                    59,
                    " memcpy ( & s -> progressive_sequence , & s1 -> progressive_sequence , ( char * ) & s1 -> rtp_mode - ( char * ) & s1 -> progressive_sequence ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int ff_mpeg_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n"
                ],
                [
                    35,
                    " s -> next_picture_ptr = REBASE_PICTURE ( s1 -> next_picture_ptr , s , s1 ) ;\n"
                ],
                [
                    43,
                    " if ( s1 -> bitstream_buffer ) {\n"
                ],
                [
                    44,
                    " if ( s1 -> bitstream_buffer_size + FF_INPUT_BUFFER_PADDING_SIZE > s -> allocated_bitstream_buffer_size ) av_fast_malloc ( & s -> bitstream_buffer , & s -> allocated_bitstream_buffer_size , s1 -> allocated_bitstream_buffer_size ) ;\n"
                ],
                [
                    45,
                    " s -> bitstream_buffer_size = s1 -> bitstream_buffer_size ;\n"
                ],
                [
                    46,
                    " memcpy ( s -> bitstream_buffer , s1 -> bitstream_buffer , s1 -> bitstream_buffer_size ) ;\n"
                ],
                [
                    47,
                    " memset ( s -> bitstream_buffer + s -> bitstream_buffer_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ff_mpeg_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n"
                ],
                [
                    3,
                    " MpegEncContext * s = dst -> priv_data , * s1 = src -> priv_data ;\n"
                ],
                [
                    4,
                    " if ( dst == src || ! s1 -> context_initialized ) return 0 ;\n"
                ],
                [
                    5,
                    " if ( ! s -> context_initialized ) {\n"
                ],
                [
                    6,
                    " memcpy ( s , s1 , sizeof ( MpegEncContext ) ) ;\n"
                ],
                [
                    8,
                    " s -> picture_range_start += MAX_PICTURE_COUNT ;\n"
                ],
                [
                    9,
                    " s -> picture_range_end += MAX_PICTURE_COUNT ;\n"
                ],
                [
                    10,
                    " s -> bitstream_buffer = NULL ;\n"
                ],
                [
                    12,
                    " ff_MPV_common_init ( s ) ;\n"
                ],
                [
                    14,
                    " if ( s -> height != s1 -> height || s -> width != s1 -> width || s -> context_reinit ) {\n"
                ],
                [
                    17,
                    " s -> height = s1 -> height ;\n"
                ],
                [
                    18,
                    " s -> width = s1 -> width ;\n"
                ],
                [
                    19,
                    " if ( ( err = ff_MPV_common_frame_size_change ( s ) ) < 0 ) return err ;\n"
                ],
                [
                    25,
                    " s -> coded_picture_number = s1 -> coded_picture_number ;\n"
                ],
                [
                    26,
                    " s -> picture_number = s1 -> picture_number ;\n"
                ],
                [
                    27,
                    " s -> input_picture_number = s1 -> input_picture_number ;\n"
                ],
                [
                    28,
                    " memcpy ( s -> picture , s1 -> picture , s1 -> picture_count * sizeof ( Picture ) ) ;\n"
                ],
                [
                    29,
                    " memcpy ( & s -> last_picture , & s1 -> last_picture , ( char * ) & s1 -> last_picture_ptr - ( char * ) & s1 -> last_picture ) ;\n"
                ],
                [
                    33,
                    " s -> last_picture_ptr = REBASE_PICTURE ( s1 -> last_picture_ptr , s , s1 ) ;\n"
                ],
                [
                    34,
                    " s -> current_picture_ptr = REBASE_PICTURE ( s1 -> current_picture_ptr , s , s1 ) ;\n"
                ],
                [
                    35,
                    " s -> next_picture_ptr = REBASE_PICTURE ( s1 -> next_picture_ptr , s , s1 ) ;\n"
                ],
                [
                    38,
                    " memcpy ( & s -> time_increment_bits , & s1 -> time_increment_bits , ( char * ) & s1 -> shape - ( char * ) & s1 -> time_increment_bits ) ;\n"
                ],
                [
                    43,
                    " if ( s1 -> bitstream_buffer ) {\n"
                ],
                [
                    44,
                    " if ( s1 -> bitstream_buffer_size + FF_INPUT_BUFFER_PADDING_SIZE > s -> allocated_bitstream_buffer_size ) av_fast_malloc ( & s -> bitstream_buffer , & s -> allocated_bitstream_buffer_size , s1 -> allocated_bitstream_buffer_size ) ;\n"
                ],
                [
                    45,
                    " s -> bitstream_buffer_size = s1 -> bitstream_buffer_size ;\n"
                ],
                [
                    46,
                    " memcpy ( s -> bitstream_buffer , s1 -> bitstream_buffer , s1 -> bitstream_buffer_size ) ;\n"
                ],
                [
                    47,
                    " memset ( s -> bitstream_buffer + s -> bitstream_buffer_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n"
                ],
                [
                    49,
                    " if ( ! s -> edge_emu_buffer ) if ( s1 -> linesize ) {\n"
                ],
                [
                    50,
                    " if ( ff_mpv_frame_size_alloc ( s , s1 -> linesize ) < 0 ) {\n"
                ],
                [
                    59,
                    " memcpy ( & s -> progressive_sequence , & s1 -> progressive_sequence , ( char * ) & s1 -> rtp_mode - ( char * ) & s1 -> progressive_sequence ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n LclDecContext * const c = avctx -> priv_data ;\n unsigned char * encoded = ( unsigned char * ) buf ;\n unsigned int pixel_ptr ;\n int row , col ;\n unsigned char * outptr ;\n uint8_t * y_out , * u_out , * v_out ;\n unsigned int width = avctx -> width ;\n unsigned int height = avctx -> height ;\n unsigned int mszh_dlen ;\n unsigned char yq , y1q , uq , vq ;\n int uqvq , ret ;\n unsigned int mthread_inlen , mthread_outlen ;\n unsigned int len = buf_size ;\n if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n c -> pic . reference = 0 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID ;\n if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n outptr = c -> pic . data [ 0 ] ;\n switch ( avctx -> codec_id ) {\n case AV_CODEC_ID_MSZH : switch ( c -> compression ) {\n case COMP_MSZH : if ( c -> flags & FLAG_MULTITHREAD ) {\n mthread_inlen = AV_RL32 ( encoded ) ;\n mthread_inlen = FFMIN ( mthread_inlen , len - 8 ) ;\n mthread_outlen = AV_RL32 ( encoded + 4 ) ;\n mthread_outlen = FFMIN ( mthread_outlen , c -> decomp_size ) ;\n mszh_dlen = mszh_decomp ( encoded + 8 , mthread_inlen , c -> decomp_buf , c -> decomp_size ) ;\n if ( mthread_outlen != mszh_dlen ) {\n av_log ( avctx , AV_LOG_ERROR , \"Mthread1 decoded size differs (%d != %d)\\n\" , mthread_outlen , mszh_dlen ) ;\n return AVERROR_INVALIDDATA ;\n }\n mszh_dlen = mszh_decomp ( encoded + 8 + mthread_inlen , len - 8 - mthread_inlen , c -> decomp_buf + mthread_outlen , c -> decomp_size - mthread_outlen ) ;\n if ( mthread_outlen != mszh_dlen ) {\n av_log ( avctx , AV_LOG_ERROR , \"Mthread2 decoded size differs (%d != %d)\\n\" , mthread_outlen , mszh_dlen ) ;\n return AVERROR_INVALIDDATA ;\n }\n encoded = c -> decomp_buf ;\n len = c -> decomp_size ;\n }\n else {\n mszh_dlen = mszh_decomp ( encoded , len , c -> decomp_buf , c -> decomp_size ) ;\n if ( c -> decomp_size != mszh_dlen ) {\n av_log ( avctx , AV_LOG_ERROR , \"Decoded size differs (%d != %d)\\n\" , c -> decomp_size , mszh_dlen ) ;\n return AVERROR_INVALIDDATA ;\n }\n encoded = c -> decomp_buf ;\n len = mszh_dlen ;\n }\n break ;\n case COMP_MSZH_NOCOMP : {\n int bppx2 ;\n switch ( c -> imgtype ) {\n case IMGTYPE_YUV111 : case IMGTYPE_RGB24 : bppx2 = 6 ;\n break ;\n case IMGTYPE_YUV422 : case IMGTYPE_YUV211 : bppx2 = 4 ;\n break ;\n case IMGTYPE_YUV411 : case IMGTYPE_YUV420 : bppx2 = 3 ;\n break ;\n default : bppx2 = 0 ;\n break ;\n }\n if ( len < ( ( width * height * bppx2 ) >> 1 ) ) return AVERROR_INVALIDDATA ;\n break ;\n }\n default : av_log ( avctx , AV_LOG_ERROR , \"BUG! Unknown MSZH compression in frame decoder.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n break ;\n # if CONFIG_ZLIB_DECODER case AV_CODEC_ID_ZLIB : if ( c -> compression == COMP_ZLIB_NORMAL && c -> imgtype == IMGTYPE_RGB24 && len == width * height * 3 ) {\n if ( c -> flags & FLAG_PNGFILTER ) {\n memcpy ( c -> decomp_buf , encoded , len ) ;\n encoded = c -> decomp_buf ;\n }\n else {\n break ;\n }\n }\n else if ( c -> flags & FLAG_MULTITHREAD ) {\n mthread_inlen = AV_RL32 ( encoded ) ;\n mthread_inlen = FFMIN ( mthread_inlen , len - 8 ) ;\n mthread_outlen = AV_RL32 ( encoded + 4 ) ;\n mthread_outlen = FFMIN ( mthread_outlen , c -> decomp_size ) ;\n ret = zlib_decomp ( avctx , encoded + 8 , mthread_inlen , 0 , mthread_outlen ) ;\n if ( ret < 0 ) return ret ;\n ret = zlib_decomp ( avctx , encoded + 8 + mthread_inlen , len - 8 - mthread_inlen , mthread_outlen , mthread_outlen ) ;\n if ( ret < 0 ) return ret ;\n }\n else {\n int ret = zlib_decomp ( avctx , encoded , len , 0 , c -> decomp_size ) ;\n if ( ret < 0 ) return ret ;\n }\n encoded = c -> decomp_buf ;\n len = c -> decomp_size ;\n break ;\n # endif default : av_log ( avctx , AV_LOG_ERROR , \"BUG! Unknown codec in frame decoder compression switch.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( avctx -> codec_id == AV_CODEC_ID_ZLIB && ( c -> flags & FLAG_PNGFILTER ) ) {\n switch ( c -> imgtype ) {\n case IMGTYPE_YUV111 : case IMGTYPE_RGB24 : for ( row = 0 ;\n row < height ;\n row ++ ) {\n pixel_ptr = row * width * 3 ;\n yq = encoded [ pixel_ptr ++ ] ;\n uqvq = AV_RL16 ( encoded + pixel_ptr ) ;\n pixel_ptr += 2 ;\n for ( col = 1 ;\n col < width ;\n col ++ ) {\n encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n uqvq -= AV_RL16 ( encoded + pixel_ptr + 1 ) ;\n AV_WL16 ( encoded + pixel_ptr + 1 , uqvq ) ;\n pixel_ptr += 3 ;\n }\n }\n break ;\n case IMGTYPE_YUV422 : for ( row = 0 ;\n row < height ;\n row ++ ) {\n pixel_ptr = row * width * 2 ;\n yq = uq = vq = 0 ;\n for ( col = 0 ;\n col < width / 4 ;\n col ++ ) {\n encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n encoded [ pixel_ptr + 5 ] = uq -= encoded [ pixel_ptr + 5 ] ;\n encoded [ pixel_ptr + 6 ] = vq -= encoded [ pixel_ptr + 6 ] ;\n encoded [ pixel_ptr + 7 ] = vq -= encoded [ pixel_ptr + 7 ] ;\n pixel_ptr += 8 ;\n }\n }\n break ;\n case IMGTYPE_YUV411 : for ( row = 0 ;\n row < height ;\n row ++ ) {\n pixel_ptr = row * width / 2 * 3 ;\n yq = uq = vq = 0 ;\n for ( col = 0 ;\n col < width / 4 ;\n col ++ ) {\n encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n pixel_ptr += 6 ;\n }\n }\n break ;\n case IMGTYPE_YUV211 : for ( row = 0 ;\n row < height ;\n row ++ ) {\n pixel_ptr = row * width * 2 ;\n yq = uq = vq = 0 ;\n for ( col = 0 ;\n col < width / 2 ;\n col ++ ) {\n encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n encoded [ pixel_ptr + 2 ] = uq -= encoded [ pixel_ptr + 2 ] ;\n encoded [ pixel_ptr + 3 ] = vq -= encoded [ pixel_ptr + 3 ] ;\n pixel_ptr += 4 ;\n }\n }\n break ;\n case IMGTYPE_YUV420 : for ( row = 0 ;\n row < height / 2 ;\n row ++ ) {\n pixel_ptr = row * width * 3 ;\n yq = y1q = uq = vq = 0 ;\n for ( col = 0 ;\n col < width / 2 ;\n col ++ ) {\n encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n encoded [ pixel_ptr + 2 ] = y1q -= encoded [ pixel_ptr + 2 ] ;\n encoded [ pixel_ptr + 3 ] = y1q -= encoded [ pixel_ptr + 3 ] ;\n encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n pixel_ptr += 6 ;\n }\n }\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"BUG! Unknown imagetype in pngfilter switch.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n y_out = c -> pic . data [ 0 ] + ( height - 1 ) * c -> pic . linesize [ 0 ] ;\n u_out = c -> pic . data [ 1 ] + ( height - 1 ) * c -> pic . linesize [ 1 ] ;\n v_out = c -> pic . data [ 2 ] + ( height - 1 ) * c -> pic . linesize [ 2 ] ;\n switch ( c -> imgtype ) {\n case IMGTYPE_YUV111 : for ( row = 0 ;\n row < height ;\n row ++ ) {\n for ( col = 0 ;\n col < width ;\n col ++ ) {\n y_out [ col ] = * encoded ++ ;\n u_out [ col ] = * encoded ++ + 128 ;\n v_out [ col ] = * encoded ++ + 128 ;\n }\n y_out -= c -> pic . linesize [ 0 ] ;\n u_out -= c -> pic . linesize [ 1 ] ;\n v_out -= c -> pic . linesize [ 2 ] ;\n }\n break ;\n case IMGTYPE_YUV422 : for ( row = 0 ;\n row < height ;\n row ++ ) {\n for ( col = 0 ;\n col < width - 3 ;\n col += 4 ) {\n memcpy ( y_out + col , encoded , 4 ) ;\n encoded += 4 ;\n u_out [ col >> 1 ] = * encoded ++ + 128 ;\n u_out [ ( col >> 1 ) + 1 ] = * encoded ++ + 128 ;\n v_out [ col >> 1 ] = * encoded ++ + 128 ;\n v_out [ ( col >> 1 ) + 1 ] = * encoded ++ + 128 ;\n }\n y_out -= c -> pic . linesize [ 0 ] ;\n u_out -= c -> pic . linesize [ 1 ] ;\n v_out -= c -> pic . linesize [ 2 ] ;\n }\n break ;\n case IMGTYPE_RGB24 : for ( row = height - 1 ;\n row >= 0 ;\n row -- ) {\n pixel_ptr = row * c -> pic . linesize [ 0 ] ;\n memcpy ( outptr + pixel_ptr , encoded , 3 * width ) ;\n encoded += 3 * width ;\n }\n break ;\n case IMGTYPE_YUV411 : for ( row = 0 ;\n row < height ;\n row ++ ) {\n for ( col = 0 ;\n col < width - 3 ;\n col += 4 ) {\n memcpy ( y_out + col , encoded , 4 ) ;\n encoded += 4 ;\n u_out [ col >> 2 ] = * encoded ++ + 128 ;\n v_out [ col >> 2 ] = * encoded ++ + 128 ;\n }\n y_out -= c -> pic . linesize [ 0 ] ;\n u_out -= c -> pic . linesize [ 1 ] ;\n v_out -= c -> pic . linesize [ 2 ] ;\n }\n break ;\n case IMGTYPE_YUV211 : for ( row = 0 ;\n row < height ;\n row ++ ) {\n for ( col = 0 ;\n col < width - 1 ;\n col += 2 ) {\n memcpy ( y_out + col , encoded , 2 ) ;\n encoded += 2 ;\n u_out [ col >> 1 ] = * encoded ++ + 128 ;\n v_out [ col >> 1 ] = * encoded ++ + 128 ;\n }\n y_out -= c -> pic . linesize [ 0 ] ;\n u_out -= c -> pic . linesize [ 1 ] ;\n v_out -= c -> pic . linesize [ 2 ] ;\n }\n break ;\n case IMGTYPE_YUV420 : u_out = c -> pic . data [ 1 ] + ( ( height >> 1 ) - 1 ) * c -> pic . linesize [ 1 ] ;\n v_out = c -> pic . data [ 2 ] + ( ( height >> 1 ) - 1 ) * c -> pic . linesize [ 2 ] ;\n for ( row = 0 ;\n row < height - 1 ;\n row += 2 ) {\n for ( col = 0 ;\n col < width - 1 ;\n col += 2 ) {\n memcpy ( y_out + col , encoded , 2 ) ;\n encoded += 2 ;\n memcpy ( y_out + col - c -> pic . linesize [ 0 ] , encoded , 2 ) ;\n encoded += 2 ;\n u_out [ col >> 1 ] = * encoded ++ + 128 ;\n v_out [ col >> 1 ] = * encoded ++ + 128 ;\n }\n y_out -= c -> pic . linesize [ 0 ] << 1 ;\n u_out -= c -> pic . linesize [ 1 ] ;\n v_out -= c -> pic . linesize [ 2 ] ;\n }\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"BUG! Unknown imagetype in image decoder.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }",
        "hash": 4837267551952413506,
        "project": "debian",
        "size": 301,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " unsigned char * encoded = ( unsigned char * ) buf ;\n"
                ],
                [
                    24,
                    " outptr = c -> pic . data [ 0 ] ;\n"
                ],
                [
                    42,
                    " encoded = c -> decomp_buf ;\n"
                ],
                [
                    51,
                    " encoded = c -> decomp_buf ;\n"
                ],
                [
                    115,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    130,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    131,
                    " encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n"
                ],
                [
                    132,
                    " encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n"
                ],
                [
                    133,
                    " encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n"
                ],
                [
                    134,
                    " encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n"
                ],
                [
                    135,
                    " encoded [ pixel_ptr + 5 ] = uq -= encoded [ pixel_ptr + 5 ] ;\n"
                ],
                [
                    136,
                    " encoded [ pixel_ptr + 6 ] = vq -= encoded [ pixel_ptr + 6 ] ;\n"
                ],
                [
                    137,
                    " encoded [ pixel_ptr + 7 ] = vq -= encoded [ pixel_ptr + 7 ] ;\n"
                ],
                [
                    150,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    151,
                    " encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n"
                ],
                [
                    152,
                    " encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n"
                ],
                [
                    153,
                    " encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n"
                ],
                [
                    154,
                    " encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n"
                ],
                [
                    155,
                    " encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n"
                ],
                [
                    168,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    169,
                    " encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n"
                ],
                [
                    170,
                    " encoded [ pixel_ptr + 2 ] = uq -= encoded [ pixel_ptr + 2 ] ;\n"
                ],
                [
                    171,
                    " encoded [ pixel_ptr + 3 ] = vq -= encoded [ pixel_ptr + 3 ] ;\n"
                ],
                [
                    184,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    185,
                    " encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n"
                ],
                [
                    186,
                    " encoded [ pixel_ptr + 2 ] = y1q -= encoded [ pixel_ptr + 2 ] ;\n"
                ],
                [
                    187,
                    " encoded [ pixel_ptr + 3 ] = y1q -= encoded [ pixel_ptr + 3 ] ;\n"
                ],
                [
                    188,
                    " encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n"
                ],
                [
                    189,
                    " encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n"
                ],
                [
                    198,
                    " y_out = c -> pic . data [ 0 ] + ( height - 1 ) * c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    221,
                    " col < width - 3 ;\n"
                ],
                [
                    223,
                    " memcpy ( y_out + col , encoded , 4 ) ;\n"
                ],
                [
                    224,
                    " encoded += 4 ;\n"
                ],
                [
                    228,
                    " v_out [ ( col >> 1 ) + 1 ] = * encoded ++ + 128 ;\n"
                ],
                [
                    230,
                    " y_out -= c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    236,
                    " row >= 0 ;\n"
                ],
                [
                    238,
                    " pixel_ptr = row * c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    239,
                    " memcpy ( outptr + pixel_ptr , encoded , 3 * width ) ;\n"
                ],
                [
                    240,
                    " encoded += 3 * width ;\n"
                ],
                [
                    247,
                    " col < width - 3 ;\n"
                ],
                [
                    249,
                    " memcpy ( y_out + col , encoded , 4 ) ;\n"
                ],
                [
                    250,
                    " encoded += 4 ;\n"
                ],
                [
                    252,
                    " v_out [ col >> 2 ] = * encoded ++ + 128 ;\n"
                ],
                [
                    254,
                    " y_out -= c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    263,
                    " col < width - 1 ;\n"
                ],
                [
                    265,
                    " memcpy ( y_out + col , encoded , 2 ) ;\n"
                ],
                [
                    266,
                    " encoded += 2 ;\n"
                ],
                [
                    268,
                    " v_out [ col >> 1 ] = * encoded ++ + 128 ;\n"
                ],
                [
                    270,
                    " y_out -= c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    281,
                    " col < width - 1 ;\n"
                ],
                [
                    283,
                    " memcpy ( y_out + col , encoded , 2 ) ;\n"
                ],
                [
                    284,
                    " encoded += 2 ;\n"
                ],
                [
                    285,
                    " memcpy ( y_out + col - c -> pic . linesize [ 0 ] , encoded , 2 ) ;\n"
                ],
                [
                    286,
                    " encoded += 2 ;\n"
                ],
                [
                    288,
                    " v_out [ col >> 1 ] = * encoded ++ + 128 ;\n"
                ],
                [
                    290,
                    " y_out -= c -> pic . linesize [ 0 ] << 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " unsigned char * encoded = ( unsigned char * ) buf ;\n"
                ],
                [
                    24,
                    " outptr = c -> pic . data [ 0 ] ;\n"
                ],
                [
                    42,
                    " encoded = c -> decomp_buf ;\n"
                ],
                [
                    51,
                    " encoded = c -> decomp_buf ;\n"
                ],
                [
                    115,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    130,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    131,
                    " encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n"
                ],
                [
                    132,
                    " encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n"
                ],
                [
                    133,
                    " encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n"
                ],
                [
                    134,
                    " encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n"
                ],
                [
                    135,
                    " encoded [ pixel_ptr + 5 ] = uq -= encoded [ pixel_ptr + 5 ] ;\n"
                ],
                [
                    136,
                    " encoded [ pixel_ptr + 6 ] = vq -= encoded [ pixel_ptr + 6 ] ;\n"
                ],
                [
                    137,
                    " encoded [ pixel_ptr + 7 ] = vq -= encoded [ pixel_ptr + 7 ] ;\n"
                ],
                [
                    150,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    151,
                    " encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n"
                ],
                [
                    152,
                    " encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n"
                ],
                [
                    153,
                    " encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n"
                ],
                [
                    154,
                    " encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n"
                ],
                [
                    155,
                    " encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n"
                ],
                [
                    168,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    169,
                    " encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n"
                ],
                [
                    170,
                    " encoded [ pixel_ptr + 2 ] = uq -= encoded [ pixel_ptr + 2 ] ;\n"
                ],
                [
                    171,
                    " encoded [ pixel_ptr + 3 ] = vq -= encoded [ pixel_ptr + 3 ] ;\n"
                ],
                [
                    184,
                    " encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n"
                ],
                [
                    185,
                    " encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n"
                ],
                [
                    186,
                    " encoded [ pixel_ptr + 2 ] = y1q -= encoded [ pixel_ptr + 2 ] ;\n"
                ],
                [
                    187,
                    " encoded [ pixel_ptr + 3 ] = y1q -= encoded [ pixel_ptr + 3 ] ;\n"
                ],
                [
                    188,
                    " encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n"
                ],
                [
                    189,
                    " encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n"
                ],
                [
                    198,
                    " y_out = c -> pic . data [ 0 ] + ( height - 1 ) * c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    221,
                    " col < width - 3 ;\n"
                ],
                [
                    223,
                    " memcpy ( y_out + col , encoded , 4 ) ;\n"
                ],
                [
                    224,
                    " encoded += 4 ;\n"
                ],
                [
                    228,
                    " v_out [ ( col >> 1 ) + 1 ] = * encoded ++ + 128 ;\n"
                ],
                [
                    230,
                    " y_out -= c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    236,
                    " row >= 0 ;\n"
                ],
                [
                    238,
                    " pixel_ptr = row * c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    239,
                    " memcpy ( outptr + pixel_ptr , encoded , 3 * width ) ;\n"
                ],
                [
                    240,
                    " encoded += 3 * width ;\n"
                ],
                [
                    247,
                    " col < width - 3 ;\n"
                ],
                [
                    249,
                    " memcpy ( y_out + col , encoded , 4 ) ;\n"
                ],
                [
                    250,
                    " encoded += 4 ;\n"
                ],
                [
                    252,
                    " v_out [ col >> 2 ] = * encoded ++ + 128 ;\n"
                ],
                [
                    254,
                    " y_out -= c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    263,
                    " col < width - 1 ;\n"
                ],
                [
                    265,
                    " memcpy ( y_out + col , encoded , 2 ) ;\n"
                ],
                [
                    266,
                    " encoded += 2 ;\n"
                ],
                [
                    268,
                    " v_out [ col >> 1 ] = * encoded ++ + 128 ;\n"
                ],
                [
                    270,
                    " y_out -= c -> pic . linesize [ 0 ] ;\n"
                ],
                [
                    281,
                    " col < width - 1 ;\n"
                ],
                [
                    283,
                    " memcpy ( y_out + col , encoded , 2 ) ;\n"
                ],
                [
                    284,
                    " encoded += 2 ;\n"
                ],
                [
                    285,
                    " memcpy ( y_out + col - c -> pic . linesize [ 0 ] , encoded , 2 ) ;\n"
                ],
                [
                    286,
                    " encoded += 2 ;\n"
                ],
                [
                    288,
                    " v_out [ col >> 1 ] = * encoded ++ + 128 ;\n"
                ],
                [
                    290,
                    " y_out -= c -> pic . linesize [ 0 ] << 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void tgq_decode_mb ( TgqContext * s , int mb_y , int mb_x ) {\n int mode ;\n int i ;\n int8_t dc [ 6 ] ;\n mode = bytestream2_get_byte ( & s -> gb ) ;\n if ( mode > 12 ) {\n GetBitContext gb ;\n init_get_bits ( & gb , s -> gb . buffer , FFMIN ( s -> gb . buffer_end - s -> gb . buffer , mode ) * 8 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) tgq_decode_block ( s , s -> block [ i ] , & gb ) ;\n tgq_idct_put_mb ( s , s -> block , mb_x , mb_y ) ;\n bytestream2_skip ( & s -> gb , mode ) ;\n }\n else {\n if ( mode == 3 ) {\n memset ( dc , bytestream2_get_byte ( & s -> gb ) , 4 ) ;\n dc [ 4 ] = bytestream2_get_byte ( & s -> gb ) ;\n dc [ 5 ] = bytestream2_get_byte ( & s -> gb ) ;\n }\n else if ( mode == 6 ) {\n bytestream2_get_buffer ( & s -> gb , dc , 6 ) ;\n }\n else if ( mode == 12 ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n dc [ i ] = bytestream2_get_byte ( & s -> gb ) ;\n bytestream2_skip ( & s -> gb , 1 ) ;\n }\n }\n else {\n av_log ( s -> avctx , AV_LOG_ERROR , \"unsupported mb mode %i\\n\" , mode ) ;\n }\n tgq_idct_put_mb_dconly ( s , mb_x , mb_y , dc ) ;\n }\n }",
        "hash": 8588713512322173474,
        "project": "debian",
        "size": 37,
        "slice": {
            "memset": [
                [
                    1,
                    "static void tgq_decode_mb ( TgqContext * s , int mb_y , int mb_x ) {\n"
                ],
                [
                    4,
                    " int8_t dc [ 6 ] ;\n"
                ],
                [
                    16,
                    " if ( mode == 3 ) {\n"
                ],
                [
                    17,
                    " memset ( dc , bytestream2_get_byte ( & s -> gb ) , 4 ) ;\n"
                ],
                [
                    35,
                    " tgq_idct_put_mb_dconly ( s , mb_x , mb_y , dc ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void tgq_decode_mb ( TgqContext * s , int mb_y , int mb_x ) {\n"
                ],
                [
                    4,
                    " int8_t dc [ 6 ] ;\n"
                ],
                [
                    16,
                    " if ( mode == 3 ) {\n"
                ],
                [
                    17,
                    " memset ( dc , bytestream2_get_byte ( & s -> gb ) , 4 ) ;\n"
                ],
                [
                    35,
                    " tgq_idct_put_mb_dconly ( s , mb_x , mb_y , dc ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int shorten_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n ShortenContext * s = avctx -> priv_data ;\n int i , input_buf_size = 0 ;\n int ret ;\n if ( s -> max_framesize == 0 ) {\n void * tmp_ptr ;\n s -> max_framesize = 1024 ;\n tmp_ptr = av_fast_realloc ( s -> bitstream , & s -> allocated_bitstream_size , s -> max_framesize ) ;\n if ( ! tmp_ptr ) {\n av_log ( avctx , AV_LOG_ERROR , \"error allocating bitstream buffer\\n\" ) ;\n return AVERROR ( ENOMEM ) ;\n }\n s -> bitstream = tmp_ptr ;\n }\n if ( 1 && s -> max_framesize ) {\n buf_size = FFMIN ( buf_size , s -> max_framesize - s -> bitstream_size ) ;\n input_buf_size = buf_size ;\n if ( s -> bitstream_index + s -> bitstream_size + buf_size > s -> allocated_bitstream_size ) {\n memmove ( s -> bitstream , & s -> bitstream [ s -> bitstream_index ] , s -> bitstream_size ) ;\n s -> bitstream_index = 0 ;\n }\n if ( buf ) memcpy ( & s -> bitstream [ s -> bitstream_index + s -> bitstream_size ] , buf , buf_size ) ;\n buf = & s -> bitstream [ s -> bitstream_index ] ;\n buf_size += s -> bitstream_size ;\n s -> bitstream_size = buf_size ;\n if ( buf_size < s -> max_framesize && avpkt -> data ) {\n * got_frame_ptr = 0 ;\n return input_buf_size ;\n }\n }\n init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n skip_bits ( & s -> gb , s -> bitindex ) ;\n if ( ! s -> got_header ) {\n if ( ( ret = read_header ( s ) ) < 0 ) return ret ;\n * got_frame_ptr = 0 ;\n goto finish_frame ;\n }\n if ( s -> got_quit_command ) {\n * got_frame_ptr = 0 ;\n return avpkt -> size ;\n }\n s -> cur_chan = 0 ;\n while ( s -> cur_chan < s -> channels ) {\n unsigned cmd ;\n int len ;\n if ( get_bits_left ( & s -> gb ) < 3 + FNSIZE ) {\n * got_frame_ptr = 0 ;\n break ;\n }\n cmd = get_ur_golomb_shorten ( & s -> gb , FNSIZE ) ;\n if ( cmd > FN_VERBATIM ) {\n av_log ( avctx , AV_LOG_ERROR , \"unknown shorten function %d\\n\" , cmd ) ;\n * got_frame_ptr = 0 ;\n break ;\n }\n if ( ! is_audio_command [ cmd ] ) {\n switch ( cmd ) {\n case FN_VERBATIM : len = get_ur_golomb_shorten ( & s -> gb , VERBATIM_CKSIZE_SIZE ) ;\n while ( len -- ) get_ur_golomb_shorten ( & s -> gb , VERBATIM_BYTE_SIZE ) ;\n break ;\n case FN_BITSHIFT : s -> bitshift = get_ur_golomb_shorten ( & s -> gb , BITSHIFTSIZE ) ;\n break ;\n case FN_BLOCKSIZE : {\n unsigned blocksize = get_uint ( s , av_log2 ( s -> blocksize ) ) ;\n if ( blocksize > s -> blocksize ) {\n av_log ( avctx , AV_LOG_ERROR , \"Increasing block size is not supported\\n\" ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( ! blocksize || blocksize > MAX_BLOCKSIZE ) {\n av_log ( avctx , AV_LOG_ERROR , \"invalid or unsupported \" \"block size: %d\\n\" , blocksize ) ;\n return AVERROR ( EINVAL ) ;\n }\n s -> blocksize = blocksize ;\n break ;\n }\n case FN_QUIT : s -> got_quit_command = 1 ;\n break ;\n }\n if ( cmd == FN_BLOCKSIZE || cmd == FN_QUIT ) {\n * got_frame_ptr = 0 ;\n break ;\n }\n }\n else {\n int residual_size = 0 ;\n int channel = s -> cur_chan ;\n int32_t coffset ;\n if ( cmd != FN_ZERO ) {\n residual_size = get_ur_golomb_shorten ( & s -> gb , ENERGYSIZE ) ;\n if ( s -> version == 0 ) residual_size -- ;\n }\n if ( s -> nmean == 0 ) coffset = s -> offset [ channel ] [ 0 ] ;\n else {\n int32_t sum = ( s -> version < 2 ) ? 0 : s -> nmean / 2 ;\n for ( i = 0 ;\n i < s -> nmean ;\n i ++ ) sum += s -> offset [ channel ] [ i ] ;\n coffset = sum / s -> nmean ;\n if ( s -> version >= 2 ) coffset >>= FFMIN ( 1 , s -> bitshift ) ;\n }\n if ( cmd == FN_ZERO ) {\n for ( i = 0 ;\n i < s -> blocksize ;\n i ++ ) s -> decoded [ channel ] [ i ] = 0 ;\n }\n else {\n if ( ( ret = decode_subframe_lpc ( s , cmd , channel , residual_size , coffset ) ) < 0 ) return ret ;\n }\n if ( s -> nmean > 0 ) {\n int32_t sum = ( s -> version < 2 ) ? 0 : s -> blocksize / 2 ;\n for ( i = 0 ;\n i < s -> blocksize ;\n i ++ ) sum += s -> decoded [ channel ] [ i ] ;\n for ( i = 1 ;\n i < s -> nmean ;\n i ++ ) s -> offset [ channel ] [ i - 1 ] = s -> offset [ channel ] [ i ] ;\n if ( s -> version < 2 ) s -> offset [ channel ] [ s -> nmean - 1 ] = sum / s -> blocksize ;\n else s -> offset [ channel ] [ s -> nmean - 1 ] = ( sum / s -> blocksize ) << s -> bitshift ;\n }\n for ( i = - s -> nwrap ;\n i < 0 ;\n i ++ ) s -> decoded [ channel ] [ i ] = s -> decoded [ channel ] [ i + s -> blocksize ] ;\n fix_bitshift ( s , s -> decoded [ channel ] ) ;\n s -> cur_chan ++ ;\n if ( s -> cur_chan == s -> channels ) {\n frame -> nb_samples = s -> blocksize ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n output_buffer ( ( int16_t * * ) frame -> extended_data , s -> channels , s -> blocksize , s -> decoded ) ;\n * got_frame_ptr = 1 ;\n }\n }\n }\n if ( s -> cur_chan < s -> channels ) * got_frame_ptr = 0 ;\n finish_frame : s -> bitindex = get_bits_count ( & s -> gb ) - 8 * ( get_bits_count ( & s -> gb ) / 8 ) ;\n i = get_bits_count ( & s -> gb ) / 8 ;\n if ( i > buf_size ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"overread: %d\\n\" , i - buf_size ) ;\n s -> bitstream_size = 0 ;\n s -> bitstream_index = 0 ;\n return AVERROR_INVALIDDATA ;\n }\n if ( s -> bitstream_size ) {\n s -> bitstream_index += i ;\n s -> bitstream_size -= i ;\n return input_buf_size ;\n }\n else return i ;\n }",
        "hash": -8263083159286474465,
        "project": "debian",
        "size": 154,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int shorten_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    16,
                    " s -> bitstream = tmp_ptr ;\n"
                ],
                [
                    19,
                    " buf_size = FFMIN ( buf_size , s -> max_framesize - s -> bitstream_size ) ;\n"
                ],
                [
                    22,
                    " memmove ( s -> bitstream , & s -> bitstream [ s -> bitstream_index ] , s -> bitstream_size ) ;\n"
                ],
                [
                    25,
                    " if ( buf ) memcpy ( & s -> bitstream [ s -> bitstream_index + s -> bitstream_size ] , buf , buf_size ) ;\n"
                ],
                [
                    27,
                    " buf_size += s -> bitstream_size ;\n"
                ]
            ],
            "memmove": [
                [
                    5,
                    " ShortenContext * s = avctx -> priv_data ;\n"
                ],
                [
                    16,
                    " s -> bitstream = tmp_ptr ;\n"
                ],
                [
                    19,
                    " buf_size = FFMIN ( buf_size , s -> max_framesize - s -> bitstream_size ) ;\n"
                ],
                [
                    21,
                    " if ( s -> bitstream_index + s -> bitstream_size + buf_size > s -> allocated_bitstream_size ) {\n"
                ],
                [
                    22,
                    " memmove ( s -> bitstream , & s -> bitstream [ s -> bitstream_index ] , s -> bitstream_size ) ;\n"
                ],
                [
                    25,
                    " if ( buf ) memcpy ( & s -> bitstream [ s -> bitstream_index + s -> bitstream_size ] , buf , buf_size ) ;\n"
                ],
                [
                    26,
                    " buf = & s -> bitstream [ s -> bitstream_index ] ;\n"
                ],
                [
                    27,
                    " buf_size += s -> bitstream_size ;\n"
                ],
                [
                    37,
                    " if ( ( ret = read_header ( s ) ) < 0 ) return ret ;\n"
                ],
                [
                    67,
                    " unsigned blocksize = get_uint ( s , av_log2 ( s -> blocksize ) ) ;\n"
                ],
                [
                    110,
                    " if ( ( ret = decode_subframe_lpc ( s , cmd , channel , residual_size , coffset ) ) < 0 ) return ret ;\n"
                ],
                [
                    126,
                    " fix_bitshift ( s , s -> decoded [ channel ] ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int shorten_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    3,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    5,
                    " ShortenContext * s = avctx -> priv_data ;\n"
                ],
                [
                    16,
                    " s -> bitstream = tmp_ptr ;\n"
                ],
                [
                    19,
                    " buf_size = FFMIN ( buf_size , s -> max_framesize - s -> bitstream_size ) ;\n"
                ],
                [
                    21,
                    " if ( s -> bitstream_index + s -> bitstream_size + buf_size > s -> allocated_bitstream_size ) {\n"
                ],
                [
                    22,
                    " memmove ( s -> bitstream , & s -> bitstream [ s -> bitstream_index ] , s -> bitstream_size ) ;\n"
                ],
                [
                    25,
                    " if ( buf ) memcpy ( & s -> bitstream [ s -> bitstream_index + s -> bitstream_size ] , buf , buf_size ) ;\n"
                ],
                [
                    26,
                    " buf = & s -> bitstream [ s -> bitstream_index ] ;\n"
                ],
                [
                    27,
                    " buf_size += s -> bitstream_size ;\n"
                ],
                [
                    37,
                    " if ( ( ret = read_header ( s ) ) < 0 ) return ret ;\n"
                ],
                [
                    67,
                    " unsigned blocksize = get_uint ( s , av_log2 ( s -> blocksize ) ) ;\n"
                ],
                [
                    110,
                    " if ( ( ret = decode_subframe_lpc ( s , cmd , channel , residual_size , coffset ) ) < 0 ) return ret ;\n"
                ],
                [
                    126,
                    " fix_bitshift ( s , s -> decoded [ channel ] ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n C93DecoderContext * const c93 = avctx -> priv_data ;\n AVFrame * const newpic = & c93 -> pictures [ c93 -> currentpic ] ;\n AVFrame * const oldpic = & c93 -> pictures [ c93 -> currentpic ^ 1 ] ;\n AVFrame * picture = data ;\n GetByteContext gb ;\n uint8_t * out ;\n int stride , ret , i , x , y , b , bt = 0 ;\n c93 -> currentpic ^= 1 ;\n newpic -> reference = 1 ;\n newpic -> buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE | FF_BUFFER_HINTS_READABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , newpic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n stride = newpic -> linesize [ 0 ] ;\n bytestream2_init ( & gb , buf , buf_size ) ;\n b = bytestream2_get_byte ( & gb ) ;\n if ( b & C93_FIRST_FRAME ) {\n newpic -> pict_type = AV_PICTURE_TYPE_I ;\n newpic -> key_frame = 1 ;\n }\n else {\n newpic -> pict_type = AV_PICTURE_TYPE_P ;\n newpic -> key_frame = 0 ;\n }\n for ( y = 0 ;\n y < HEIGHT ;\n y += 8 ) {\n out = newpic -> data [ 0 ] + y * stride ;\n for ( x = 0 ;\n x < WIDTH ;\n x += 8 ) {\n uint8_t * copy_from = oldpic -> data [ 0 ] ;\n unsigned int offset , j ;\n uint8_t cols [ 4 ] , grps [ 4 ] ;\n C93BlockType block_type ;\n if ( ! bt ) bt = bytestream2_get_byte ( & gb ) ;\n block_type = bt & 0x0F ;\n switch ( block_type ) {\n case C93_8X8_FROM_PREV : offset = bytestream2_get_le16 ( & gb ) ;\n if ( ( ret = copy_block ( avctx , out , copy_from , offset , 8 , stride ) ) < 0 ) return ret ;\n break ;\n case C93_4X4_FROM_CURR : copy_from = newpic -> data [ 0 ] ;\n case C93_4X4_FROM_PREV : for ( j = 0 ;\n j < 8 ;\n j += 4 ) {\n for ( i = 0 ;\n i < 8 ;\n i += 4 ) {\n offset = bytestream2_get_le16 ( & gb ) ;\n if ( ( ret = copy_block ( avctx , & out [ j * stride + i ] , copy_from , offset , 4 , stride ) ) < 0 ) return ret ;\n }\n }\n break ;\n case C93_8X8_2COLOR : bytestream2_get_buffer ( & gb , cols , 2 ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n draw_n_color ( out + i * stride , stride , 8 , 1 , 1 , cols , NULL , bytestream2_get_byte ( & gb ) ) ;\n }\n break ;\n case C93_4X4_2COLOR : case C93_4X4_4COLOR : case C93_4X4_4COLOR_GRP : for ( j = 0 ;\n j < 8 ;\n j += 4 ) {\n for ( i = 0 ;\n i < 8 ;\n i += 4 ) {\n if ( block_type == C93_4X4_2COLOR ) {\n bytestream2_get_buffer ( & gb , cols , 2 ) ;\n draw_n_color ( out + i + j * stride , stride , 4 , 4 , 1 , cols , NULL , bytestream2_get_le16 ( & gb ) ) ;\n }\n else if ( block_type == C93_4X4_4COLOR ) {\n bytestream2_get_buffer ( & gb , cols , 4 ) ;\n draw_n_color ( out + i + j * stride , stride , 4 , 4 , 2 , cols , NULL , bytestream2_get_le32 ( & gb ) ) ;\n }\n else {\n bytestream2_get_buffer ( & gb , grps , 4 ) ;\n draw_n_color ( out + i + j * stride , stride , 4 , 4 , 1 , cols , grps , bytestream2_get_le16 ( & gb ) ) ;\n }\n }\n }\n break ;\n case C93_NOOP : break ;\n case C93_8X8_INTRA : for ( j = 0 ;\n j < 8 ;\n j ++ ) bytestream2_get_buffer ( & gb , out + j * stride , 8 ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"unexpected type %x at %dx%d\\n\" , block_type , x , y ) ;\n return AVERROR_INVALIDDATA ;\n }\n bt >>= 4 ;\n out += 8 ;\n }\n }\n if ( b & C93_HAS_PALETTE ) {\n uint32_t * palette = ( uint32_t * ) newpic -> data [ 1 ] ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n palette [ i ] = bytestream2_get_be24 ( & gb ) ;\n }\n newpic -> palette_has_changed = 1 ;\n }\n else {\n if ( oldpic -> data [ 1 ] ) memcpy ( newpic -> data [ 1 ] , oldpic -> data [ 1 ] , 256 * 4 ) ;\n }\n * picture = * newpic ;\n * got_frame = 1 ;\n return buf_size ;\n }",
        "hash": 423181909456162215,
        "project": "debian",
        "size": 113,
        "slice": {
            "memcpy": [
                [
                    108,
                    " if ( oldpic -> data [ 1 ] ) memcpy ( newpic -> data [ 1 ] , oldpic -> data [ 1 ] , 256 * 4 ) ;\n"
                ]
            ],
            "result": [
                [
                    108,
                    " if ( oldpic -> data [ 1 ] ) memcpy ( newpic -> data [ 1 ] , oldpic -> data [ 1 ] , 256 * 4 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n AnmContext * s = avctx -> priv_data ;\n const int buf_size = avpkt -> size ;\n uint8_t * dst , * dst_end ;\n int count , ret ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n dst = s -> frame . data [ 0 ] ;\n dst_end = s -> frame . data [ 0 ] + s -> frame . linesize [ 0 ] * avctx -> height ;\n bytestream2_init ( & s -> gb , avpkt -> data , buf_size ) ;\n if ( bytestream2_get_byte ( & s -> gb ) != 0x42 ) {\n av_log_ask_for_sample ( avctx , \"unknown record type\\n\" ) ;\n return buf_size ;\n }\n if ( bytestream2_get_byte ( & s -> gb ) ) {\n av_log_ask_for_sample ( avctx , \"padding bytes not supported\\n\" ) ;\n return buf_size ;\n }\n bytestream2_skip ( & s -> gb , 2 ) ;\n s -> x = 0 ;\n do {\n # define OP ( gb , pixel , count ) op ( & dst , dst_end , ( gb ) , ( pixel ) , ( count ) , & s -> x , avctx -> width , s -> frame . linesize [ 0 ] ) int type = bytestream2_get_byte ( & s -> gb ) ;\n count = type & 0x7F ;\n type >>= 7 ;\n if ( count ) {\n if ( OP ( type ? NULL : & s -> gb , - 1 , count ) ) break ;\n }\n else if ( ! type ) {\n int pixel ;\n count = bytestream2_get_byte ( & s -> gb ) ;\n pixel = bytestream2_get_byte ( & s -> gb ) ;\n if ( OP ( NULL , pixel , count ) ) break ;\n }\n else {\n int pixel ;\n type = bytestream2_get_le16 ( & s -> gb ) ;\n count = type & 0x3FFF ;\n type >>= 14 ;\n if ( ! count ) {\n if ( type == 0 ) break ;\n if ( type == 2 ) {\n av_log_ask_for_sample ( avctx , \"unknown opcode\" ) ;\n return AVERROR_PATCHWELCOME ;\n }\n continue ;\n }\n pixel = type == 3 ? bytestream2_get_byte ( & s -> gb ) : - 1 ;\n if ( type == 1 ) count += 0x4000 ;\n if ( OP ( type == 2 ? & s -> gb : NULL , pixel , count ) ) break ;\n }\n }\n while ( bytestream2_get_bytes_left ( & s -> gb ) > 0 ) ;\n memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": -2343429046993510367,
        "project": "debian",
        "size": 59,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " AnmContext * s = avctx -> priv_data ;\n"
                ],
                [
                    42,
                    " if ( type == 0 ) break ;\n"
                ],
                [
                    54,
                    " while ( bytestream2_get_bytes_left ( & s -> gb ) > 0 ) ;\n"
                ],
                [
                    55,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " AnmContext * s = avctx -> priv_data ;\n"
                ],
                [
                    42,
                    " if ( type == 0 ) break ;\n"
                ],
                [
                    54,
                    " while ( bytestream2_get_bytes_left ( & s -> gb ) > 0 ) ;\n"
                ],
                [
                    55,
                    " memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mss4_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MSS4Context * c = avctx -> priv_data ;\n GetBitContext gb ;\n GetByteContext bc ;\n uint8_t * dst [ 3 ] ;\n int width , height , quality , frame_type ;\n int x , y , i , mb_width , mb_height , blk_type ;\n int ret ;\n if ( buf_size < HEADER_SIZE ) {\n av_log ( avctx , AV_LOG_ERROR , \"Frame should have at least %d bytes, got %d instead\\n\" , HEADER_SIZE , buf_size ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_init ( & bc , buf , buf_size ) ;\n width = bytestream2_get_be16 ( & bc ) ;\n height = bytestream2_get_be16 ( & bc ) ;\n bytestream2_skip ( & bc , 2 ) ;\n quality = bytestream2_get_byte ( & bc ) ;\n frame_type = bytestream2_get_byte ( & bc ) ;\n if ( width > avctx -> width || height != avctx -> height ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame dimensions %dx%d\\n\" , width , height ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( quality < 1 || quality > 100 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid quality setting %d\\n\" , quality ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ( frame_type & ~ 3 ) || frame_type == 3 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid frame type %d\\n\" , frame_type ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( frame_type != SKIP_FRAME && ! bytestream2_get_bytes_left ( & bc ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Empty frame found but it is not a skip frame.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> pic . reference = 3 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n c -> pic . key_frame = ( frame_type == INTRA_FRAME ) ;\n c -> pic . pict_type = ( frame_type == INTRA_FRAME ) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P ;\n if ( frame_type == SKIP_FRAME ) {\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }\n if ( c -> quality != quality ) {\n c -> quality = quality ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) ff_mss34_gen_quant_mat ( c -> quant_mat [ i ] , quality , ! i ) ;\n }\n init_get_bits ( & gb , buf + HEADER_SIZE , ( buf_size - HEADER_SIZE ) * 8 ) ;\n mb_width = FFALIGN ( width , 16 ) >> 4 ;\n mb_height = FFALIGN ( height , 16 ) >> 4 ;\n dst [ 0 ] = c -> pic . data [ 0 ] ;\n dst [ 1 ] = c -> pic . data [ 1 ] ;\n dst [ 2 ] = c -> pic . data [ 2 ] ;\n memset ( c -> prev_vec , 0 , sizeof ( c -> prev_vec ) ) ;\n for ( y = 0 ;\n y < mb_height ;\n y ++ ) {\n memset ( c -> dc_cache , 0 , sizeof ( c -> dc_cache ) ) ;\n for ( x = 0 ;\n x < mb_width ;\n x ++ ) {\n blk_type = decode012 ( & gb ) ;\n switch ( blk_type ) {\n case DCT_BLOCK : if ( mss4_decode_dct_block ( c , & gb , dst , x , y ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding DCT block %d,%d\\n\" , x , y ) ;\n return AVERROR_INVALIDDATA ;\n }\n break ;\n case IMAGE_BLOCK : if ( mss4_decode_image_block ( c , & gb , dst , x , y ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding VQ block %d,%d\\n\" , x , y ) ;\n return AVERROR_INVALIDDATA ;\n }\n break ;\n case SKIP_BLOCK : if ( frame_type == INTRA_FRAME ) {\n av_log ( avctx , AV_LOG_ERROR , \"Skip block in intra frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n break ;\n }\n if ( blk_type != DCT_BLOCK ) mss4_update_dc_cache ( c , x ) ;\n }\n dst [ 0 ] += c -> pic . linesize [ 0 ] * 16 ;\n dst [ 1 ] += c -> pic . linesize [ 1 ] * 16 ;\n dst [ 2 ] += c -> pic . linesize [ 2 ] * 16 ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }",
        "hash": -5717349108307169967,
        "project": "debian",
        "size": 97,
        "slice": {
            "memset": [
                [
                    1,
                    "static int mss4_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " MSS4Context * c = avctx -> priv_data ;\n"
                ],
                [
                    45,
                    " if ( frame_type == SKIP_FRAME ) {\n"
                ],
                [
                    62,
                    " memset ( c -> prev_vec , 0 , sizeof ( c -> prev_vec ) ) ;\n"
                ],
                [
                    64,
                    " y < mb_height ;\n"
                ],
                [
                    66,
                    " memset ( c -> dc_cache , 0 , sizeof ( c -> dc_cache ) ) ;\n"
                ],
                [
                    72,
                    " case DCT_BLOCK : if ( mss4_decode_dct_block ( c , & gb , dst , x , y ) < 0 ) {\n"
                ],
                [
                    77,
                    " case IMAGE_BLOCK : if ( mss4_decode_image_block ( c , & gb , dst , x , y ) < 0 ) {\n"
                ],
                [
                    88,
                    " if ( blk_type != DCT_BLOCK ) mss4_update_dc_cache ( c , x ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mss4_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " MSS4Context * c = avctx -> priv_data ;\n"
                ],
                [
                    45,
                    " if ( frame_type == SKIP_FRAME ) {\n"
                ],
                [
                    62,
                    " memset ( c -> prev_vec , 0 , sizeof ( c -> prev_vec ) ) ;\n"
                ],
                [
                    64,
                    " y < mb_height ;\n"
                ],
                [
                    66,
                    " memset ( c -> dc_cache , 0 , sizeof ( c -> dc_cache ) ) ;\n"
                ],
                [
                    72,
                    " case DCT_BLOCK : if ( mss4_decode_dct_block ( c , & gb , dst , x , y ) < 0 ) {\n"
                ],
                [
                    77,
                    " case IMAGE_BLOCK : if ( mss4_decode_image_block ( c , & gb , dst , x , y ) < 0 ) {\n"
                ],
                [
                    88,
                    " if ( blk_type != DCT_BLOCK ) mss4_update_dc_cache ( c , x ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void ff_xvmc_decode_mb ( MpegEncContext * s ) {\n XvMCMacroBlock * mv_block ;\n struct xvmc_pix_fmt * render ;\n int i , cbp , blocks_per_mb ;\n const int mb_xy = s -> mb_y * s -> mb_stride + s -> mb_x ;\n if ( s -> encoding ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"XVMC doesn't support encoding!!!\\n\" ) ;\n return ;\n }\n if ( ! s -> mb_intra ) {\n s -> last_dc [ 0 ] = s -> last_dc [ 1 ] = s -> last_dc [ 2 ] = 128 << s -> intra_dc_precision ;\n }\n s -> mb_skipped = 0 ;\n s -> current_picture . f . qscale_table [ mb_xy ] = s -> qscale ;\n render = ( struct xvmc_pix_fmt * ) s -> current_picture . f . data [ 2 ] ;\n assert ( render ) ;\n assert ( render -> xvmc_id == AV_XVMC_ID ) ;\n assert ( render -> mv_blocks ) ;\n mv_block = & render -> mv_blocks [ render -> start_mv_blocks_num + render -> filled_mv_blocks_num ] ;\n mv_block -> x = s -> mb_x ;\n mv_block -> y = s -> mb_y ;\n mv_block -> dct_type = s -> interlaced_dct ;\n if ( s -> mb_intra ) {\n mv_block -> macroblock_type = XVMC_MB_TYPE_INTRA ;\n }\n else {\n mv_block -> macroblock_type = XVMC_MB_TYPE_PATTERN ;\n if ( s -> mv_dir & MV_DIR_FORWARD ) {\n mv_block -> macroblock_type |= XVMC_MB_TYPE_MOTION_FORWARD ;\n mv_block -> PMV [ 0 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 0 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 0 ] [ 1 ] = s -> mv [ 0 ] [ 0 ] [ 1 ] ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 1 ] [ 0 ] ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 1 ] = s -> mv [ 0 ] [ 1 ] [ 1 ] ;\n }\n if ( s -> mv_dir & MV_DIR_BACKWARD ) {\n mv_block -> macroblock_type |= XVMC_MB_TYPE_MOTION_BACKWARD ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 0 ] = s -> mv [ 1 ] [ 0 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 1 ] = s -> mv [ 1 ] [ 0 ] [ 1 ] ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 0 ] = s -> mv [ 1 ] [ 1 ] [ 0 ] ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 1 ] = s -> mv [ 1 ] [ 1 ] [ 1 ] ;\n }\n switch ( s -> mv_type ) {\n case MV_TYPE_16X16 : mv_block -> motion_type = XVMC_PREDICTION_FRAME ;\n break ;\n case MV_TYPE_16X8 : mv_block -> motion_type = XVMC_PREDICTION_16x8 ;\n break ;\n case MV_TYPE_FIELD : mv_block -> motion_type = XVMC_PREDICTION_FIELD ;\n if ( s -> picture_structure == PICT_FRAME ) {\n mv_block -> PMV [ 0 ] [ 0 ] [ 1 ] <<= 1 ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 1 ] <<= 1 ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 1 ] <<= 1 ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 1 ] <<= 1 ;\n }\n break ;\n case MV_TYPE_DMV : mv_block -> motion_type = XVMC_PREDICTION_DUAL_PRIME ;\n if ( s -> picture_structure == PICT_FRAME ) {\n mv_block -> PMV [ 0 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 0 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 0 ] [ 1 ] = s -> mv [ 0 ] [ 0 ] [ 1 ] << 1 ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 0 ] = s -> mv [ 0 ] [ 0 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 1 ] = s -> mv [ 0 ] [ 0 ] [ 1 ] << 1 ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 0 ] = s -> mv [ 0 ] [ 2 ] [ 0 ] ;\n mv_block -> PMV [ 1 ] [ 0 ] [ 1 ] = s -> mv [ 0 ] [ 2 ] [ 1 ] << 1 ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 0 ] = s -> mv [ 0 ] [ 3 ] [ 0 ] ;\n mv_block -> PMV [ 1 ] [ 1 ] [ 1 ] = s -> mv [ 0 ] [ 3 ] [ 1 ] << 1 ;\n }\n else {\n mv_block -> PMV [ 0 ] [ 1 ] [ 0 ] = s -> mv [ 0 ] [ 2 ] [ 0 ] ;\n mv_block -> PMV [ 0 ] [ 1 ] [ 1 ] = s -> mv [ 0 ] [ 2 ] [ 1 ] ;\n }\n break ;\n default : assert ( 0 ) ;\n }\n mv_block -> motion_vertical_field_select = 0 ;\n if ( s -> mv_type == MV_TYPE_FIELD || s -> mv_type == MV_TYPE_16X8 ) {\n mv_block -> motion_vertical_field_select |= s -> field_select [ 0 ] [ 0 ] ;\n mv_block -> motion_vertical_field_select |= s -> field_select [ 1 ] [ 0 ] << 1 ;\n mv_block -> motion_vertical_field_select |= s -> field_select [ 0 ] [ 1 ] << 2 ;\n mv_block -> motion_vertical_field_select |= s -> field_select [ 1 ] [ 1 ] << 3 ;\n }\n }\n mv_block -> index = render -> next_free_data_block_num ;\n blocks_per_mb = 6 ;\n if ( s -> chroma_format >= 2 ) {\n blocks_per_mb = 4 + ( 1 << s -> chroma_format ) ;\n }\n cbp = 0 ;\n for ( i = 0 ;\n i < blocks_per_mb ;\n i ++ ) {\n cbp += cbp ;\n if ( s -> block_last_index [ i ] >= 0 ) cbp ++ ;\n }\n if ( s -> flags & CODEC_FLAG_GRAY ) {\n if ( s -> mb_intra ) {\n for ( i = 4 ;\n i < blocks_per_mb ;\n i ++ ) {\n memset ( s -> pblocks [ i ] , 0 , sizeof ( * s -> pblocks [ i ] ) ) ;\n if ( ! render -> unsigned_intra ) * s -> pblocks [ i ] [ 0 ] = 1 << 10 ;\n }\n }\n else {\n cbp &= 0xf << ( blocks_per_mb - 4 ) ;\n blocks_per_mb = 4 ;\n }\n }\n mv_block -> coded_block_pattern = cbp ;\n if ( cbp == 0 ) mv_block -> macroblock_type &= ~ XVMC_MB_TYPE_PATTERN ;\n for ( i = 0 ;\n i < blocks_per_mb ;\n i ++ ) {\n if ( s -> block_last_index [ i ] >= 0 ) {\n if ( s -> mb_intra && ( render -> idct || ! render -> unsigned_intra ) ) * s -> pblocks [ i ] [ 0 ] -= 1 << 10 ;\n if ( ! render -> idct ) {\n s -> dsp . idct ( * s -> pblocks [ i ] ) ;\n }\n if ( s -> avctx -> xvmc_acceleration == 1 ) {\n memcpy ( & render -> data_blocks [ render -> next_free_data_block_num * 64 ] , s -> pblocks [ i ] , sizeof ( * s -> pblocks [ i ] ) ) ;\n }\n render -> next_free_data_block_num ++ ;\n }\n }\n render -> filled_mv_blocks_num ++ ;\n assert ( render -> filled_mv_blocks_num <= render -> allocated_mv_blocks ) ;\n assert ( render -> next_free_data_block_num <= render -> allocated_data_blocks ) ;\n if ( render -> filled_mv_blocks_num == render -> allocated_mv_blocks ) ff_mpeg_draw_horiz_band ( s , 0 , 0 ) ;\n }",
        "hash": 2218137424821696593,
        "project": "debian",
        "size": 127,
        "slice": {
            "memcpy": [
                [
                    98,
                    " memset ( s -> pblocks [ i ] , 0 , sizeof ( * s -> pblocks [ i ] ) ) ;\n"
                ],
                [
                    117,
                    " if ( s -> avctx -> xvmc_acceleration == 1 ) {\n"
                ],
                [
                    118,
                    " memcpy ( & render -> data_blocks [ render -> next_free_data_block_num * 64 ] , s -> pblocks [ i ] , sizeof ( * s -> pblocks [ i ] ) ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "void ff_xvmc_decode_mb ( MpegEncContext * s ) {\n"
                ],
                [
                    96,
                    " i < blocks_per_mb ;\n"
                ],
                [
                    98,
                    " memset ( s -> pblocks [ i ] , 0 , sizeof ( * s -> pblocks [ i ] ) ) ;\n"
                ],
                [
                    118,
                    " memcpy ( & render -> data_blocks [ render -> next_free_data_block_num * 64 ] , s -> pblocks [ i ] , sizeof ( * s -> pblocks [ i ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void ff_xvmc_decode_mb ( MpegEncContext * s ) {\n"
                ],
                [
                    96,
                    " i < blocks_per_mb ;\n"
                ],
                [
                    98,
                    " memset ( s -> pblocks [ i ] , 0 , sizeof ( * s -> pblocks [ i ] ) ) ;\n"
                ],
                [
                    117,
                    " if ( s -> avctx -> xvmc_acceleration == 1 ) {\n"
                ],
                [
                    118,
                    " memcpy ( & render -> data_blocks [ render -> next_free_data_block_num * 64 ] , s -> pblocks [ i ] , sizeof ( * s -> pblocks [ i ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mp_decode_frame ( MPADecodeContext * s , OUT_INT * * samples , const uint8_t * buf , int buf_size ) {\n int i , nb_frames , ch , ret ;\n OUT_INT * samples_ptr ;\n init_get_bits ( & s -> gb , buf + HEADER_SIZE , ( buf_size - HEADER_SIZE ) * 8 ) ;\n if ( s -> error_protection ) skip_bits ( & s -> gb , 16 ) ;\n switch ( s -> layer ) {\n case 1 : s -> avctx -> frame_size = 384 ;\n nb_frames = mp_decode_layer1 ( s ) ;\n break ;\n case 2 : s -> avctx -> frame_size = 1152 ;\n nb_frames = mp_decode_layer2 ( s ) ;\n break ;\n case 3 : s -> avctx -> frame_size = s -> lsf ? 576 : 1152 ;\n default : nb_frames = mp_decode_layer3 ( s ) ;\n if ( nb_frames < 0 ) return nb_frames ;\n s -> last_buf_size = 0 ;\n if ( s -> in_gb . buffer ) {\n align_get_bits ( & s -> gb ) ;\n i = get_bits_left ( & s -> gb ) >> 3 ;\n if ( i >= 0 && i <= BACKSTEP_SIZE ) {\n memmove ( s -> last_buf , s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) , i ) ;\n s -> last_buf_size = i ;\n }\n else av_log ( s -> avctx , AV_LOG_ERROR , \"invalid old backstep %d\\n\" , i ) ;\n s -> gb = s -> in_gb ;\n s -> in_gb . buffer = NULL ;\n }\n align_get_bits ( & s -> gb ) ;\n assert ( ( get_bits_count ( & s -> gb ) & 7 ) == 0 ) ;\n i = get_bits_left ( & s -> gb ) >> 3 ;\n if ( i < 0 || i > BACKSTEP_SIZE || nb_frames < 0 ) {\n if ( i < 0 ) av_log ( s -> avctx , AV_LOG_ERROR , \"invalid new backstep %d\\n\" , i ) ;\n i = FFMIN ( BACKSTEP_SIZE , buf_size - HEADER_SIZE ) ;\n }\n assert ( i <= buf_size - HEADER_SIZE && i >= 0 ) ;\n memcpy ( s -> last_buf + s -> last_buf_size , s -> gb . buffer + buf_size - HEADER_SIZE - i , i ) ;\n s -> last_buf_size += i ;\n }\n if ( ! samples ) {\n av_assert0 ( s -> frame != NULL ) ;\n s -> frame -> nb_samples = s -> avctx -> frame_size ;\n if ( ( ret = ff_get_buffer ( s -> avctx , s -> frame ) ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( OUT_INT * * ) s -> frame -> extended_data ;\n }\n for ( ch = 0 ;\n ch < s -> nb_channels ;\n ch ++ ) {\n int sample_stride ;\n if ( s -> avctx -> sample_fmt == OUT_FMT_P ) {\n samples_ptr = samples [ ch ] ;\n sample_stride = 1 ;\n }\n else {\n samples_ptr = samples [ 0 ] + ch ;\n sample_stride = s -> nb_channels ;\n }\n for ( i = 0 ;\n i < nb_frames ;\n i ++ ) {\n RENAME ( ff_mpa_synth_filter ) ( & s -> mpadsp , s -> synth_buf [ ch ] , & ( s -> synth_buf_offset [ ch ] ) , RENAME ( ff_mpa_synth_window ) , & s -> dither_state , samples_ptr , sample_stride , s -> sb_samples [ ch ] [ i ] ) ;\n samples_ptr += 32 * sample_stride ;\n }\n }\n return nb_frames * 32 * sizeof ( OUT_INT ) * s -> nb_channels ;\n }",
        "hash": -3591633859713840564,
        "project": "debian",
        "size": 68,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int mp_decode_frame ( MPADecodeContext * s , OUT_INT * * samples , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    14,
                    " default : nb_frames = mp_decode_layer3 ( s ) ;\n"
                ],
                [
                    15,
                    " if ( nb_frames < 0 ) return nb_frames ;\n"
                ],
                [
                    16,
                    " s -> last_buf_size = 0 ;\n"
                ],
                [
                    21,
                    " memmove ( s -> last_buf , s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) , i ) ;\n"
                ],
                [
                    22,
                    " s -> last_buf_size = i ;\n"
                ],
                [
                    36,
                    " memcpy ( s -> last_buf + s -> last_buf_size , s -> gb . buffer + buf_size - HEADER_SIZE - i , i ) ;\n"
                ],
                [
                    37,
                    " s -> last_buf_size += i ;\n"
                ]
            ],
            "memmove": [
                [
                    1,
                    "static int mp_decode_frame ( MPADecodeContext * s , OUT_INT * * samples , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    14,
                    " default : nb_frames = mp_decode_layer3 ( s ) ;\n"
                ],
                [
                    20,
                    " if ( i >= 0 && i <= BACKSTEP_SIZE ) {\n"
                ],
                [
                    21,
                    " memmove ( s -> last_buf , s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) , i ) ;\n"
                ],
                [
                    22,
                    " s -> last_buf_size = i ;\n"
                ],
                [
                    36,
                    " memcpy ( s -> last_buf + s -> last_buf_size , s -> gb . buffer + buf_size - HEADER_SIZE - i , i ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mp_decode_frame ( MPADecodeContext * s , OUT_INT * * samples , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    14,
                    " default : nb_frames = mp_decode_layer3 ( s ) ;\n"
                ],
                [
                    15,
                    " if ( nb_frames < 0 ) return nb_frames ;\n"
                ],
                [
                    16,
                    " s -> last_buf_size = 0 ;\n"
                ],
                [
                    20,
                    " if ( i >= 0 && i <= BACKSTEP_SIZE ) {\n"
                ],
                [
                    21,
                    " memmove ( s -> last_buf , s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) , i ) ;\n"
                ],
                [
                    22,
                    " s -> last_buf_size = i ;\n"
                ],
                [
                    36,
                    " memcpy ( s -> last_buf + s -> last_buf_size , s -> gb . buffer + buf_size - HEADER_SIZE - i , i ) ;\n"
                ],
                [
                    37,
                    " s -> last_buf_size += i ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int qtrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n QtrleContext * s = avctx -> priv_data ;\n int header , start_line ;\n int height , row_ptr ;\n int has_palette = 0 ;\n int ret ;\n bytestream2_init ( & s -> g , avpkt -> data , avpkt -> size ) ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE | FF_BUFFER_HINTS_READABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( avpkt -> size < 8 ) goto done ;\n bytestream2_seek ( & s -> g , 4 , SEEK_SET ) ;\n header = bytestream2_get_be16 ( & s -> g ) ;\n if ( header & 0x0008 ) {\n if ( avpkt -> size < 14 ) goto done ;\n start_line = bytestream2_get_be16 ( & s -> g ) ;\n bytestream2_skip ( & s -> g , 2 ) ;\n height = bytestream2_get_be16 ( & s -> g ) ;\n bytestream2_skip ( & s -> g , 2 ) ;\n }\n else {\n start_line = 0 ;\n height = s -> avctx -> height ;\n }\n row_ptr = s -> frame . linesize [ 0 ] * start_line ;\n switch ( avctx -> bits_per_coded_sample ) {\n case 1 : case 33 : qtrle_decode_1bpp ( s , row_ptr , height ) ;\n break ;\n case 2 : case 34 : qtrle_decode_2n4bpp ( s , row_ptr , height , 2 ) ;\n has_palette = 1 ;\n break ;\n case 4 : case 36 : qtrle_decode_2n4bpp ( s , row_ptr , height , 4 ) ;\n has_palette = 1 ;\n break ;\n case 8 : case 40 : qtrle_decode_8bpp ( s , row_ptr , height ) ;\n has_palette = 1 ;\n break ;\n case 16 : qtrle_decode_16bpp ( s , row_ptr , height ) ;\n break ;\n case 24 : qtrle_decode_24bpp ( s , row_ptr , height ) ;\n break ;\n case 32 : qtrle_decode_32bpp ( s , row_ptr , height ) ;\n break ;\n default : av_log ( s -> avctx , AV_LOG_ERROR , \"Unsupported colorspace: %d bits/sample?\\n\" , avctx -> bits_per_coded_sample ) ;\n break ;\n }\n if ( has_palette ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n }\n done : * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return avpkt -> size ;\n }",
        "hash": 5772289003363923137,
        "project": "debian",
        "size": 61,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int qtrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " QtrleContext * s = avctx -> priv_data ;\n"
                ],
                [
                    30,
                    " case 1 : case 33 : qtrle_decode_1bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    32,
                    " case 2 : case 34 : qtrle_decode_2n4bpp ( s , row_ptr , height , 2 ) ;\n"
                ],
                [
                    35,
                    " case 4 : case 36 : qtrle_decode_2n4bpp ( s , row_ptr , height , 4 ) ;\n"
                ],
                [
                    38,
                    " case 8 : case 40 : qtrle_decode_8bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    41,
                    " case 16 : qtrle_decode_16bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    43,
                    " case 24 : qtrle_decode_24bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    45,
                    " case 32 : qtrle_decode_32bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    50,
                    " if ( has_palette ) {\n"
                ],
                [
                    51,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    52,
                    " if ( pal ) {\n"
                ],
                [
                    54,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    56,
                    " memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int qtrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " QtrleContext * s = avctx -> priv_data ;\n"
                ],
                [
                    30,
                    " case 1 : case 33 : qtrle_decode_1bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    32,
                    " case 2 : case 34 : qtrle_decode_2n4bpp ( s , row_ptr , height , 2 ) ;\n"
                ],
                [
                    35,
                    " case 4 : case 36 : qtrle_decode_2n4bpp ( s , row_ptr , height , 4 ) ;\n"
                ],
                [
                    38,
                    " case 8 : case 40 : qtrle_decode_8bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    41,
                    " case 16 : qtrle_decode_16bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    43,
                    " case 24 : qtrle_decode_24bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    45,
                    " case 32 : qtrle_decode_32bpp ( s , row_ptr , height ) ;\n"
                ],
                [
                    50,
                    " if ( has_palette ) {\n"
                ],
                [
                    51,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    52,
                    " if ( pal ) {\n"
                ],
                [
                    54,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    56,
                    " memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int mpc8_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n MPCContext * c = avctx -> priv_data ;\n GetBitContext gb2 , * gb = & gb2 ;\n int i , j , k , ch , cnt , res , t ;\n Band * bands = c -> bands ;\n int off ;\n int maxband , keyframe ;\n int last [ 2 ] ;\n frame -> nb_samples = MPC_FRAME_SIZE ;\n if ( ( res = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return res ;\n }\n keyframe = c -> cur_frame == 0 ;\n if ( keyframe ) {\n memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n c -> last_bits_used = 0 ;\n }\n init_get_bits ( gb , buf , buf_size * 8 ) ;\n skip_bits ( gb , c -> last_bits_used & 7 ) ;\n if ( keyframe ) maxband = mpc8_get_mod_golomb ( gb , c -> maxbands + 1 ) ;\n else {\n maxband = c -> last_max_band + get_vlc2 ( gb , band_vlc . table , MPC8_BANDS_BITS , 2 ) ;\n if ( maxband > 32 ) maxband -= 33 ;\n }\n if ( maxband > c -> maxbands + 1 ) return AVERROR_INVALIDDATA ;\n c -> last_max_band = maxband ;\n if ( maxband ) {\n last [ 0 ] = last [ 1 ] = 0 ;\n for ( i = maxband - 1 ;\n i >= 0 ;\n i -- ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n last [ ch ] = get_vlc2 ( gb , res_vlc [ last [ ch ] > 2 ] . table , MPC8_RES_BITS , 2 ) + last [ ch ] ;\n if ( last [ ch ] > 15 ) last [ ch ] -= 17 ;\n bands [ i ] . res [ ch ] = last [ ch ] ;\n }\n }\n if ( c -> MSS ) {\n int mask ;\n cnt = 0 ;\n for ( i = 0 ;\n i < maxband ;\n i ++ ) if ( bands [ i ] . res [ 0 ] || bands [ i ] . res [ 1 ] ) cnt ++ ;\n t = mpc8_get_mod_golomb ( gb , cnt ) ;\n mask = mpc8_get_mask ( gb , cnt , t ) ;\n for ( i = maxband - 1 ;\n i >= 0 ;\n i -- ) if ( bands [ i ] . res [ 0 ] || bands [ i ] . res [ 1 ] ) {\n bands [ i ] . msf = mask & 1 ;\n mask >>= 1 ;\n }\n }\n }\n for ( i = maxband ;\n i < c -> maxbands ;\n i ++ ) bands [ i ] . res [ 0 ] = bands [ i ] . res [ 1 ] = 0 ;\n if ( keyframe ) {\n for ( i = 0 ;\n i < 32 ;\n i ++ ) c -> oldDSCF [ 0 ] [ i ] = c -> oldDSCF [ 1 ] [ i ] = 1 ;\n }\n for ( i = 0 ;\n i < maxband ;\n i ++ ) {\n if ( bands [ i ] . res [ 0 ] || bands [ i ] . res [ 1 ] ) {\n cnt = ! ! bands [ i ] . res [ 0 ] + ! ! bands [ i ] . res [ 1 ] - 1 ;\n if ( cnt >= 0 ) {\n t = get_vlc2 ( gb , scfi_vlc [ cnt ] . table , scfi_vlc [ cnt ] . bits , 1 ) ;\n if ( bands [ i ] . res [ 0 ] ) bands [ i ] . scfi [ 0 ] = t >> ( 2 * cnt ) ;\n if ( bands [ i ] . res [ 1 ] ) bands [ i ] . scfi [ 1 ] = t & 3 ;\n }\n }\n }\n for ( i = 0 ;\n i < maxband ;\n i ++ ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n if ( ! bands [ i ] . res [ ch ] ) continue ;\n if ( c -> oldDSCF [ ch ] [ i ] ) {\n bands [ i ] . scf_idx [ ch ] [ 0 ] = get_bits ( gb , 7 ) - 6 ;\n c -> oldDSCF [ ch ] [ i ] = 0 ;\n }\n else {\n t = get_vlc2 ( gb , dscf_vlc [ 1 ] . table , MPC8_DSCF1_BITS , 2 ) ;\n if ( t == 64 ) t += get_bits ( gb , 6 ) ;\n bands [ i ] . scf_idx [ ch ] [ 0 ] = ( ( bands [ i ] . scf_idx [ ch ] [ 2 ] + t - 25 ) & 0x7F ) - 6 ;\n }\n for ( j = 0 ;\n j < 2 ;\n j ++ ) {\n if ( ( bands [ i ] . scfi [ ch ] << j ) & 2 ) bands [ i ] . scf_idx [ ch ] [ j + 1 ] = bands [ i ] . scf_idx [ ch ] [ j ] ;\n else {\n t = get_vlc2 ( gb , dscf_vlc [ 0 ] . table , MPC8_DSCF0_BITS , 2 ) ;\n if ( t == 31 ) t = 64 + get_bits ( gb , 6 ) ;\n bands [ i ] . scf_idx [ ch ] [ j + 1 ] = ( ( bands [ i ] . scf_idx [ ch ] [ j ] + t - 25 ) & 0x7F ) - 6 ;\n }\n }\n }\n }\n for ( i = 0 , off = 0 ;\n i < maxband ;\n i ++ , off += SAMPLES_PER_BAND ) {\n for ( ch = 0 ;\n ch < 2 ;\n ch ++ ) {\n res = bands [ i ] . res [ ch ] ;\n switch ( res ) {\n case - 1 : for ( j = 0 ;\n j < SAMPLES_PER_BAND ;\n j ++ ) c -> Q [ ch ] [ off + j ] = ( av_lfg_get ( & c -> rnd ) & 0x3FC ) - 510 ;\n break ;\n case 0 : break ;\n case 1 : for ( j = 0 ;\n j < SAMPLES_PER_BAND ;\n j += SAMPLES_PER_BAND / 2 ) {\n cnt = get_vlc2 ( gb , q1_vlc . table , MPC8_Q1_BITS , 2 ) ;\n t = mpc8_get_mask ( gb , 18 , cnt ) ;\n for ( k = 0 ;\n k < SAMPLES_PER_BAND / 2 ;\n k ++ , t <<= 1 ) c -> Q [ ch ] [ off + j + k ] = ( t & 0x20000 ) ? ( get_bits1 ( gb ) << 1 ) - 1 : 0 ;\n }\n break ;\n case 2 : cnt = 6 ;\n for ( j = 0 ;\n j < SAMPLES_PER_BAND ;\n j += 3 ) {\n t = get_vlc2 ( gb , q2_vlc [ cnt > 3 ] . table , MPC8_Q2_BITS , 2 ) ;\n c -> Q [ ch ] [ off + j + 0 ] = mpc8_idx50 [ t ] ;\n c -> Q [ ch ] [ off + j + 1 ] = mpc8_idx51 [ t ] ;\n c -> Q [ ch ] [ off + j + 2 ] = mpc8_idx52 [ t ] ;\n cnt = ( cnt >> 1 ) + mpc8_huffq2 [ t ] ;\n }\n break ;\n case 3 : case 4 : for ( j = 0 ;\n j < SAMPLES_PER_BAND ;\n j += 2 ) {\n t = get_vlc2 ( gb , q3_vlc [ res - 3 ] . table , MPC8_Q3_BITS , 2 ) + q3_offsets [ res - 3 ] ;\n c -> Q [ ch ] [ off + j + 1 ] = t >> 4 ;\n c -> Q [ ch ] [ off + j + 0 ] = ( t & 8 ) ? ( t & 0xF ) - 16 : ( t & 0xF ) ;\n }\n break ;\n case 5 : case 6 : case 7 : case 8 : cnt = 2 * mpc8_thres [ res ] ;\n for ( j = 0 ;\n j < SAMPLES_PER_BAND ;\n j ++ ) {\n t = get_vlc2 ( gb , quant_vlc [ res - 5 ] [ cnt > mpc8_thres [ res ] ] . table , quant_vlc [ res - 5 ] [ cnt > mpc8_thres [ res ] ] . bits , 2 ) + quant_offsets [ res - 5 ] ;\n c -> Q [ ch ] [ off + j ] = t ;\n cnt = ( cnt >> 1 ) + FFABS ( c -> Q [ ch ] [ off + j ] ) ;\n }\n break ;\n default : for ( j = 0 ;\n j < SAMPLES_PER_BAND ;\n j ++ ) {\n c -> Q [ ch ] [ off + j ] = get_vlc2 ( gb , q9up_vlc . table , MPC8_Q9UP_BITS , 2 ) ;\n if ( res != 9 ) {\n c -> Q [ ch ] [ off + j ] <<= res - 9 ;\n c -> Q [ ch ] [ off + j ] |= get_bits ( gb , res - 9 ) ;\n }\n c -> Q [ ch ] [ off + j ] -= ( 1 << ( res - 2 ) ) - 1 ;\n }\n }\n }\n }\n ff_mpc_dequantize_and_synth ( c , maxband - 1 , ( int16_t * * ) frame -> extended_data , avctx -> channels ) ;\n c -> cur_frame ++ ;\n c -> last_bits_used = get_bits_count ( gb ) ;\n if ( get_bits_left ( gb ) < 8 ) c -> last_bits_used = buf_size << 3 ;\n if ( c -> cur_frame >= c -> frames ) c -> cur_frame = 0 ;\n * got_frame_ptr = 1 ;\n return c -> cur_frame ? c -> last_bits_used >> 3 : buf_size ;\n }",
        "hash": 7319734001219685758,
        "project": "debian",
        "size": 179,
        "slice": {
            "memset": [
                [
                    1,
                    "static int mpc8_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " MPCContext * c = avctx -> priv_data ;\n"
                ],
                [
                    18,
                    " if ( keyframe ) {\n"
                ],
                [
                    19,
                    " memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n"
                ],
                [
                    172,
                    " ff_mpc_dequantize_and_synth ( c , maxband - 1 , ( int16_t * * ) frame -> extended_data , avctx -> channels ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int mpc8_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    5,
                    " MPCContext * c = avctx -> priv_data ;\n"
                ],
                [
                    18,
                    " if ( keyframe ) {\n"
                ],
                [
                    19,
                    " memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n"
                ],
                [
                    172,
                    " ff_mpc_dequantize_and_synth ( c , maxband - 1 , ( int16_t * * ) frame -> extended_data , avctx -> channels ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int svq1_encode_plane ( SVQ1Context * s , int plane , unsigned char * src_plane , unsigned char * ref_plane , unsigned char * decoded_plane , int width , int height , int src_stride , int stride ) {\n int x , y ;\n int i ;\n int block_width , block_height ;\n int level ;\n int threshold [ 6 ] ;\n uint8_t * src = s -> scratchbuf + stride * 16 ;\n const int lambda = ( s -> picture . quality * s -> picture . quality ) >> ( 2 * FF_LAMBDA_SHIFT ) ;\n threshold [ 5 ] = QUALITY_THRESHOLD ;\n for ( level = 4 ;\n level >= 0 ;\n level -- ) threshold [ level ] = threshold [ level + 1 ] * THRESHOLD_MULTIPLIER ;\n block_width = ( width + 15 ) / 16 ;\n block_height = ( height + 15 ) / 16 ;\n if ( s -> picture . pict_type == AV_PICTURE_TYPE_P ) {\n s -> m . avctx = s -> avctx ;\n s -> m . current_picture_ptr = & s -> m . current_picture ;\n s -> m . last_picture_ptr = & s -> m . last_picture ;\n s -> m . last_picture . f . data [ 0 ] = ref_plane ;\n s -> m . linesize = s -> m . last_picture . f . linesize [ 0 ] = s -> m . new_picture . f . linesize [ 0 ] = s -> m . current_picture . f . linesize [ 0 ] = stride ;\n s -> m . width = width ;\n s -> m . height = height ;\n s -> m . mb_width = block_width ;\n s -> m . mb_height = block_height ;\n s -> m . mb_stride = s -> m . mb_width + 1 ;\n s -> m . b8_stride = 2 * s -> m . mb_width + 1 ;\n s -> m . f_code = 1 ;\n s -> m . pict_type = s -> picture . pict_type ;\n s -> m . me_method = s -> avctx -> me_method ;\n s -> m . me . scene_change_score = 0 ;\n s -> m . flags = s -> avctx -> flags ;\n s -> m . lambda = s -> picture . quality ;\n s -> m . qscale = s -> m . lambda * 139 + FF_LAMBDA_SCALE * 64 >> FF_LAMBDA_SHIFT + 7 ;\n s -> m . lambda2 = s -> m . lambda * s -> m . lambda + FF_LAMBDA_SCALE / 2 >> FF_LAMBDA_SHIFT ;\n if ( ! s -> motion_val8 [ plane ] ) {\n s -> motion_val8 [ plane ] = av_mallocz ( ( s -> m . b8_stride * block_height * 2 + 2 ) * 2 * sizeof ( int16_t ) ) ;\n s -> motion_val16 [ plane ] = av_mallocz ( ( s -> m . mb_stride * ( block_height + 2 ) + 1 ) * 2 * sizeof ( int16_t ) ) ;\n }\n s -> m . mb_type = s -> mb_type ;\n s -> m . current_picture . mb_mean = ( uint8_t * ) s -> dummy ;\n s -> m . current_picture . mb_var = ( uint16_t * ) s -> dummy ;\n s -> m . current_picture . mc_mb_var = ( uint16_t * ) s -> dummy ;\n s -> m . current_picture . f . mb_type = s -> dummy ;\n s -> m . current_picture . f . motion_val [ 0 ] = s -> motion_val8 [ plane ] + 2 ;\n s -> m . p_mv_table = s -> motion_val16 [ plane ] + s -> m . mb_stride + 1 ;\n s -> m . dsp = s -> dsp ;\n ff_init_me ( & s -> m ) ;\n s -> m . me . dia_size = s -> avctx -> dia_size ;\n s -> m . first_slice_line = 1 ;\n for ( y = 0 ;\n y < block_height ;\n y ++ ) {\n s -> m . new_picture . f . data [ 0 ] = src - y * 16 * stride ;\n s -> m . mb_y = y ;\n for ( i = 0 ;\n i < 16 && i + 16 * y < height ;\n i ++ ) {\n memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n for ( x = width ;\n x < 16 * block_width ;\n x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n }\n for ( ;\n i < 16 && i + 16 * y < 16 * block_height ;\n i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n for ( x = 0 ;\n x < block_width ;\n x ++ ) {\n s -> m . mb_x = x ;\n ff_init_block_index ( & s -> m ) ;\n ff_update_block_index ( & s -> m ) ;\n ff_estimate_p_frame_motion ( & s -> m , x , y ) ;\n }\n s -> m . first_slice_line = 0 ;\n }\n ff_fix_long_p_mvs ( & s -> m ) ;\n ff_fix_long_mvs ( & s -> m , NULL , 0 , s -> m . p_mv_table , s -> m . f_code , CANDIDATE_MB_TYPE_INTER , 0 ) ;\n }\n s -> m . first_slice_line = 1 ;\n for ( y = 0 ;\n y < block_height ;\n y ++ ) {\n for ( i = 0 ;\n i < 16 && i + 16 * y < height ;\n i ++ ) {\n memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n for ( x = width ;\n x < 16 * block_width ;\n x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n }\n for ( ;\n i < 16 && i + 16 * y < 16 * block_height ;\n i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n s -> m . mb_y = y ;\n for ( x = 0 ;\n x < block_width ;\n x ++ ) {\n uint8_t reorder_buffer [ 3 ] [ 6 ] [ 7 * 32 ] ;\n int count [ 3 ] [ 6 ] ;\n int offset = y * 16 * stride + x * 16 ;\n uint8_t * decoded = decoded_plane + offset ;\n uint8_t * ref = ref_plane + offset ;\n int score [ 4 ] = {\n 0 , 0 , 0 , 0 }\n , best ;\n uint8_t * temp = s -> scratchbuf ;\n if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < 3000 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"encoded frame too large\\n\" ) ;\n return - 1 ;\n }\n s -> m . mb_x = x ;\n ff_init_block_index ( & s -> m ) ;\n ff_update_block_index ( & s -> m ) ;\n if ( s -> picture . pict_type == AV_PICTURE_TYPE_I || ( s -> m . mb_type [ x + y * s -> m . mb_stride ] & CANDIDATE_MB_TYPE_INTRA ) ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) init_put_bits ( & s -> reorder_pb [ i ] , reorder_buffer [ 0 ] [ i ] , 7 * 32 ) ;\n if ( s -> picture . pict_type == AV_PICTURE_TYPE_P ) {\n const uint8_t * vlc = ff_svq1_block_type_vlc [ SVQ1_BLOCK_INTRA ] ;\n put_bits ( & s -> reorder_pb [ 5 ] , vlc [ 1 ] , vlc [ 0 ] ) ;\n score [ 0 ] = vlc [ 1 ] * lambda ;\n }\n score [ 0 ] += encode_block ( s , src + 16 * x , NULL , temp , stride , 5 , 64 , lambda , 1 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n count [ 0 ] [ i ] = put_bits_count ( & s -> reorder_pb [ i ] ) ;\n flush_put_bits ( & s -> reorder_pb [ i ] ) ;\n }\n }\n else score [ 0 ] = INT_MAX ;\n best = 0 ;\n if ( s -> picture . pict_type == AV_PICTURE_TYPE_P ) {\n const uint8_t * vlc = ff_svq1_block_type_vlc [ SVQ1_BLOCK_INTER ] ;\n int mx , my , pred_x , pred_y , dxy ;\n int16_t * motion_ptr ;\n motion_ptr = ff_h263_pred_motion ( & s -> m , 0 , 0 , & pred_x , & pred_y ) ;\n if ( s -> m . mb_type [ x + y * s -> m . mb_stride ] & CANDIDATE_MB_TYPE_INTER ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) init_put_bits ( & s -> reorder_pb [ i ] , reorder_buffer [ 1 ] [ i ] , 7 * 32 ) ;\n put_bits ( & s -> reorder_pb [ 5 ] , vlc [ 1 ] , vlc [ 0 ] ) ;\n s -> m . pb = s -> reorder_pb [ 5 ] ;\n mx = motion_ptr [ 0 ] ;\n my = motion_ptr [ 1 ] ;\n assert ( mx >= - 32 && mx <= 31 ) ;\n assert ( my >= - 32 && my <= 31 ) ;\n assert ( pred_x >= - 32 && pred_x <= 31 ) ;\n assert ( pred_y >= - 32 && pred_y <= 31 ) ;\n ff_h263_encode_motion ( & s -> m , mx - pred_x , 1 ) ;\n ff_h263_encode_motion ( & s -> m , my - pred_y , 1 ) ;\n s -> reorder_pb [ 5 ] = s -> m . pb ;\n score [ 1 ] += lambda * put_bits_count ( & s -> reorder_pb [ 5 ] ) ;\n dxy = ( mx & 1 ) + 2 * ( my & 1 ) ;\n s -> dsp . put_pixels_tab [ 0 ] [ dxy ] ( temp + 16 , ref + ( mx >> 1 ) + stride * ( my >> 1 ) , stride , 16 ) ;\n score [ 1 ] += encode_block ( s , src + 16 * x , temp + 16 , decoded , stride , 5 , 64 , lambda , 0 ) ;\n best = score [ 1 ] <= score [ 0 ] ;\n vlc = ff_svq1_block_type_vlc [ SVQ1_BLOCK_SKIP ] ;\n score [ 2 ] = s -> dsp . sse [ 0 ] ( NULL , src + 16 * x , ref , stride , 16 ) ;\n score [ 2 ] += vlc [ 1 ] * lambda ;\n if ( score [ 2 ] < score [ best ] && mx == 0 && my == 0 ) {\n best = 2 ;\n s -> dsp . put_pixels_tab [ 0 ] [ 0 ] ( decoded , ref , stride , 16 ) ;\n for ( i = 0 ;\n i < 6 ;\n i ++ ) count [ 2 ] [ i ] = 0 ;\n put_bits ( & s -> pb , vlc [ 1 ] , vlc [ 0 ] ) ;\n }\n }\n if ( best == 1 ) {\n for ( i = 0 ;\n i < 6 ;\n i ++ ) {\n count [ 1 ] [ i ] = put_bits_count ( & s -> reorder_pb [ i ] ) ;\n flush_put_bits ( & s -> reorder_pb [ i ] ) ;\n }\n }\n else {\n motion_ptr [ 0 ] = motion_ptr [ 1 ] = motion_ptr [ 2 ] = motion_ptr [ 3 ] = motion_ptr [ 0 + 2 * s -> m . b8_stride ] = motion_ptr [ 1 + 2 * s -> m . b8_stride ] = motion_ptr [ 2 + 2 * s -> m . b8_stride ] = motion_ptr [ 3 + 2 * s -> m . b8_stride ] = 0 ;\n }\n }\n s -> rd_total += score [ best ] ;\n for ( i = 5 ;\n i >= 0 ;\n i -- ) avpriv_copy_bits ( & s -> pb , reorder_buffer [ best ] [ i ] , count [ best ] [ i ] ) ;\n if ( best == 0 ) s -> dsp . put_pixels_tab [ 0 ] [ 0 ] ( decoded , temp , stride , 16 ) ;\n }\n s -> m . first_slice_line = 0 ;\n }\n return 0 ;\n }",
        "hash": -2899237383573912022,
        "project": "debian",
        "size": 191,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int svq1_encode_plane ( SVQ1Context * s , int plane , unsigned char * src_plane , unsigned char * ref_plane , unsigned char * decoded_plane , int width , int height , int src_stride , int stride ) {\n"
                ],
                [
                    7,
                    " uint8_t * src = s -> scratchbuf + stride * 16 ;\n"
                ],
                [
                    53,
                    " s -> m . new_picture . f . data [ 0 ] = src - y * 16 * stride ;\n"
                ],
                [
                    56,
                    " i < 16 && i + 16 * y < height ;\n"
                ],
                [
                    58,
                    " memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n"
                ],
                [
                    59,
                    " for ( x = width ;\n"
                ],
                [
                    61,
                    " x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n"
                ],
                [
                    64,
                    " i < 16 && i + 16 * y < 16 * block_height ;\n"
                ],
                [
                    65,
                    " i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n"
                ],
                [
                    84,
                    " i < 16 && i + 16 * y < height ;\n"
                ],
                [
                    86,
                    " memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n"
                ],
                [
                    87,
                    " for ( x = width ;\n"
                ],
                [
                    89,
                    " x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n"
                ],
                [
                    92,
                    " i < 16 && i + 16 * y < 16 * block_height ;\n"
                ],
                [
                    93,
                    " i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n"
                ],
                [
                    123,
                    " score [ 0 ] += encode_block ( s , src + 16 * x , NULL , temp , stride , 5 , 64 , lambda , 1 ) ;\n"
                ],
                [
                    156,
                    " score [ 1 ] += encode_block ( s , src + 16 * x , temp + 16 , decoded , stride , 5 , 64 , lambda , 0 ) ;\n"
                ],
                [
                    159,
                    " score [ 2 ] = s -> dsp . sse [ 0 ] ( NULL , src + 16 * x , ref , stride , 16 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int svq1_encode_plane ( SVQ1Context * s , int plane , unsigned char * src_plane , unsigned char * ref_plane , unsigned char * decoded_plane , int width , int height , int src_stride , int stride ) {\n"
                ],
                [
                    7,
                    " uint8_t * src = s -> scratchbuf + stride * 16 ;\n"
                ],
                [
                    53,
                    " s -> m . new_picture . f . data [ 0 ] = src - y * 16 * stride ;\n"
                ],
                [
                    56,
                    " i < 16 && i + 16 * y < height ;\n"
                ],
                [
                    58,
                    " memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n"
                ],
                [
                    59,
                    " for ( x = width ;\n"
                ],
                [
                    61,
                    " x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n"
                ],
                [
                    64,
                    " i < 16 && i + 16 * y < 16 * block_height ;\n"
                ],
                [
                    65,
                    " i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n"
                ],
                [
                    84,
                    " i < 16 && i + 16 * y < height ;\n"
                ],
                [
                    86,
                    " memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n"
                ],
                [
                    87,
                    " for ( x = width ;\n"
                ],
                [
                    89,
                    " x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n"
                ],
                [
                    92,
                    " i < 16 && i + 16 * y < 16 * block_height ;\n"
                ],
                [
                    93,
                    " i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n"
                ],
                [
                    123,
                    " score [ 0 ] += encode_block ( s , src + 16 * x , NULL , temp , stride , 5 , 64 , lambda , 1 ) ;\n"
                ],
                [
                    156,
                    " score [ 1 ] += encode_block ( s , src + 16 * x , temp + 16 , decoded , stride , 5 , 64 , lambda , 0 ) ;\n"
                ],
                [
                    159,
                    " score [ 2 ] = s -> dsp . sse [ 0 ] ( NULL , src + 16 * x , ref , stride , 16 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n Msvideo1Context * s = avctx -> priv_data ;\n s -> buf = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( avctx -> reget_buffer ( avctx , & s -> frame ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n if ( s -> mode_8bit ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n s -> frame . palette_has_changed = 1 ;\n }\n }\n if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;\n else msvideo1_decode_16bit ( s ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "hash": 2716625165137468453,
        "project": "debian",
        "size": 25,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " Msvideo1Context * s = avctx -> priv_data ;\n"
                ],
                [
                    14,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    15,
                    " if ( pal ) {\n"
                ],
                [
                    16,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    20,
                    " if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;\n"
                ],
                [
                    21,
                    " else msvideo1_decode_16bit ( s ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " Msvideo1Context * s = avctx -> priv_data ;\n"
                ],
                [
                    14,
                    " const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n"
                ],
                [
                    15,
                    " if ( pal ) {\n"
                ],
                [
                    16,
                    " memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    20,
                    " if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;\n"
                ],
                [
                    21,
                    " else msvideo1_decode_16bit ( s ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n int field , ret ;\n AVFrame * pic = avctx -> coded_frame ;\n const uint8_t * buf = avpkt -> data ;\n const uint8_t * buf_end = buf + avpkt -> size ;\n if ( pic -> data [ 0 ] ) avctx -> release_buffer ( avctx , pic ) ;\n if ( avpkt -> size < avctx -> width * 2 * avctx -> height + 4 + 2 * 8 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( bytestream_get_le32 ( & buf ) != MKTAG ( 'F' , 'R' , 'W' , '1' ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"incorrect marker\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n pic -> reference = 0 ;\n if ( ( ret = ff_get_buffer ( avctx , pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n pic -> pict_type = AV_PICTURE_TYPE_I ;\n pic -> key_frame = 1 ;\n pic -> interlaced_frame = 1 ;\n pic -> top_field_first = 1 ;\n for ( field = 0 ;\n field < 2 ;\n field ++ ) {\n int i ;\n int field_h = ( avctx -> height + ! field ) >> 1 ;\n int field_size , min_field_size = avctx -> width * 2 * field_h ;\n uint8_t * dst = pic -> data [ 0 ] ;\n if ( buf_end - buf < 8 ) return AVERROR_INVALIDDATA ;\n buf += 4 ;\n field_size = bytestream_get_le32 ( & buf ) ;\n if ( field_size < min_field_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Field size %i is too small (required %i)\\n\" , field_size , min_field_size ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( buf_end - buf < field_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small, need %i, have %i\\n\" , field_size , ( int ) ( buf_end - buf ) ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( field ) dst += pic -> linesize [ 0 ] ;\n for ( i = 0 ;\n i < field_h ;\n i ++ ) {\n memcpy ( dst , buf , avctx -> width * 2 ) ;\n buf += avctx -> width * 2 ;\n dst += pic -> linesize [ 0 ] << 1 ;\n }\n buf += field_size - min_field_size ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = * pic ;\n return avpkt -> size ;\n }",
        "hash": -3703054730362685242,
        "project": "debian",
        "size": 55,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    30,
                    " uint8_t * dst = pic -> data [ 0 ] ;\n"
                ],
                [
                    33,
                    " field_size = bytestream_get_le32 ( & buf ) ;\n"
                ],
                [
                    38,
                    " if ( buf_end - buf < field_size ) {\n"
                ],
                [
                    42,
                    " if ( field ) dst += pic -> linesize [ 0 ] ;\n"
                ],
                [
                    44,
                    " i < field_h ;\n"
                ],
                [
                    46,
                    " memcpy ( dst , buf , avctx -> width * 2 ) ;\n"
                ],
                [
                    47,
                    " buf += avctx -> width * 2 ;\n"
                ],
                [
                    48,
                    " dst += pic -> linesize [ 0 ] << 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    30,
                    " uint8_t * dst = pic -> data [ 0 ] ;\n"
                ],
                [
                    33,
                    " field_size = bytestream_get_le32 ( & buf ) ;\n"
                ],
                [
                    38,
                    " if ( buf_end - buf < field_size ) {\n"
                ],
                [
                    42,
                    " if ( field ) dst += pic -> linesize [ 0 ] ;\n"
                ],
                [
                    44,
                    " i < field_h ;\n"
                ],
                [
                    46,
                    " memcpy ( dst , buf , avctx -> width * 2 ) ;\n"
                ],
                [
                    47,
                    " buf += avctx -> width * 2 ;\n"
                ],
                [
                    48,
                    " dst += pic -> linesize [ 0 ] << 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_13 ( AVCodecContext * avctx , DxaDecContext * c , uint8_t * dst , uint8_t * src , uint8_t * ref ) {\n uint8_t * code , * data , * mv , * msk , * tmp , * tmp2 ;\n int i , j , k ;\n int type , x , y , d , d2 ;\n int stride = c -> pic . linesize [ 0 ] ;\n uint32_t mask ;\n code = src + 12 ;\n data = code + ( ( avctx -> width * avctx -> height ) >> 4 ) ;\n mv = data + AV_RB32 ( src + 0 ) ;\n msk = mv + AV_RB32 ( src + 4 ) ;\n for ( j = 0 ;\n j < avctx -> height ;\n j += 4 ) {\n for ( i = 0 ;\n i < avctx -> width ;\n i += 4 ) {\n tmp = dst + i ;\n tmp2 = ref + i ;\n type = * code ++ ;\n switch ( type ) {\n case 4 : x = ( * mv ) >> 4 ;\n if ( x & 8 ) x = 8 - x ;\n y = ( * mv ++ ) & 0xF ;\n if ( y & 8 ) y = 8 - y ;\n tmp2 += x + y * stride ;\n case 0 : case 5 : for ( y = 0 ;\n y < 4 ;\n y ++ ) {\n memcpy ( tmp , tmp2 , 4 ) ;\n tmp += stride ;\n tmp2 += stride ;\n }\n break ;\n case 1 : case 10 : case 11 : case 12 : case 13 : case 14 : case 15 : if ( type == 1 ) {\n mask = AV_RB16 ( msk ) ;\n msk += 2 ;\n }\n else {\n type -= 10 ;\n mask = ( ( msk [ 0 ] & 0xF0 ) << shift1 [ type ] ) | ( ( msk [ 0 ] & 0xF ) << shift2 [ type ] ) ;\n msk ++ ;\n }\n for ( y = 0 ;\n y < 4 ;\n y ++ ) {\n for ( x = 0 ;\n x < 4 ;\n x ++ ) {\n tmp [ x ] = ( mask & 0x8000 ) ? * data ++ : tmp2 [ x ] ;\n mask <<= 1 ;\n }\n tmp += stride ;\n tmp2 += stride ;\n }\n break ;\n case 2 : for ( y = 0 ;\n y < 4 ;\n y ++ ) {\n memset ( tmp , data [ 0 ] , 4 ) ;\n tmp += stride ;\n }\n data ++ ;\n break ;\n case 3 : for ( y = 0 ;\n y < 4 ;\n y ++ ) {\n memcpy ( tmp , data , 4 ) ;\n data += 4 ;\n tmp += stride ;\n }\n break ;\n case 8 : mask = * msk ++ ;\n for ( k = 0 ;\n k < 4 ;\n k ++ ) {\n d = ( ( k & 1 ) << 1 ) + ( ( k & 2 ) * stride ) ;\n d2 = ( ( k & 1 ) << 1 ) + ( ( k & 2 ) * stride ) ;\n tmp2 = ref + i + d2 ;\n switch ( mask & 0xC0 ) {\n case 0x80 : x = ( * mv ) >> 4 ;\n if ( x & 8 ) x = 8 - x ;\n y = ( * mv ++ ) & 0xF ;\n if ( y & 8 ) y = 8 - y ;\n tmp2 += x + y * stride ;\n case 0x00 : tmp [ d + 0 ] = tmp2 [ 0 ] ;\n tmp [ d + 1 ] = tmp2 [ 1 ] ;\n tmp [ d + 0 + stride ] = tmp2 [ 0 + stride ] ;\n tmp [ d + 1 + stride ] = tmp2 [ 1 + stride ] ;\n break ;\n case 0x40 : tmp [ d + 0 ] = data [ 0 ] ;\n tmp [ d + 1 ] = data [ 0 ] ;\n tmp [ d + 0 + stride ] = data [ 0 ] ;\n tmp [ d + 1 + stride ] = data [ 0 ] ;\n data ++ ;\n break ;\n case 0xC0 : tmp [ d + 0 ] = * data ++ ;\n tmp [ d + 1 ] = * data ++ ;\n tmp [ d + 0 + stride ] = * data ++ ;\n tmp [ d + 1 + stride ] = * data ++ ;\n break ;\n }\n mask <<= 2 ;\n }\n break ;\n case 32 : mask = AV_RB16 ( msk ) ;\n msk += 2 ;\n for ( y = 0 ;\n y < 4 ;\n y ++ ) {\n for ( x = 0 ;\n x < 4 ;\n x ++ ) {\n tmp [ x ] = data [ mask & 1 ] ;\n mask >>= 1 ;\n }\n tmp += stride ;\n tmp2 += stride ;\n }\n data += 2 ;\n break ;\n case 33 : case 34 : mask = AV_RB32 ( msk ) ;\n msk += 4 ;\n for ( y = 0 ;\n y < 4 ;\n y ++ ) {\n for ( x = 0 ;\n x < 4 ;\n x ++ ) {\n tmp [ x ] = data [ mask & 3 ] ;\n mask >>= 2 ;\n }\n tmp += stride ;\n tmp2 += stride ;\n }\n data += type - 30 ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unknown opcode %d\\n\" , type ) ;\n return AVERROR_INVALIDDATA ;\n }\n }\n dst += stride * 4 ;\n ref += stride * 4 ;\n }\n return 0 ;\n }",
        "hash": 1864017524114662826,
        "project": "debian",
        "size": 145,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_13 ( AVCodecContext * avctx , DxaDecContext * c , uint8_t * dst , uint8_t * src , uint8_t * ref ) {\n"
                ],
                [
                    8,
                    " data = code + ( ( avctx -> width * avctx -> height ) >> 4 ) ;\n"
                ],
                [
                    17,
                    " tmp = dst + i ;\n"
                ],
                [
                    18,
                    " tmp2 = ref + i ;\n"
                ],
                [
                    25,
                    " tmp2 += x + y * stride ;\n"
                ],
                [
                    27,
                    " y < 4 ;\n"
                ],
                [
                    29,
                    " memcpy ( tmp , tmp2 , 4 ) ;\n"
                ],
                [
                    30,
                    " tmp += stride ;\n"
                ],
                [
                    31,
                    " tmp2 += stride ;\n"
                ],
                [
                    49,
                    " tmp [ x ] = ( mask & 0x8000 ) ? * data ++ : tmp2 [ x ] ;\n"
                ],
                [
                    53,
                    " tmp2 += stride ;\n"
                ],
                [
                    59,
                    " memset ( tmp , data [ 0 ] , 4 ) ;\n"
                ],
                [
                    62,
                    " data ++ ;\n"
                ],
                [
                    65,
                    " y < 4 ;\n"
                ],
                [
                    67,
                    " memcpy ( tmp , data , 4 ) ;\n"
                ],
                [
                    68,
                    " data += 4 ;\n"
                ],
                [
                    69,
                    " tmp += stride ;\n"
                ],
                [
                    78,
                    " tmp2 = ref + i + d2 ;\n"
                ],
                [
                    84,
                    " tmp2 += x + y * stride ;\n"
                ],
                [
                    85,
                    " case 0x00 : tmp [ d + 0 ] = tmp2 [ 0 ] ;\n"
                ],
                [
                    86,
                    " tmp [ d + 1 ] = tmp2 [ 1 ] ;\n"
                ],
                [
                    87,
                    " tmp [ d + 0 + stride ] = tmp2 [ 0 + stride ] ;\n"
                ],
                [
                    88,
                    " tmp [ d + 1 + stride ] = tmp2 [ 1 + stride ] ;\n"
                ],
                [
                    90,
                    " case 0x40 : tmp [ d + 0 ] = data [ 0 ] ;\n"
                ],
                [
                    91,
                    " tmp [ d + 1 ] = data [ 0 ] ;\n"
                ],
                [
                    92,
                    " tmp [ d + 0 + stride ] = data [ 0 ] ;\n"
                ],
                [
                    93,
                    " tmp [ d + 1 + stride ] = data [ 0 ] ;\n"
                ],
                [
                    94,
                    " data ++ ;\n"
                ],
                [
                    96,
                    " case 0xC0 : tmp [ d + 0 ] = * data ++ ;\n"
                ],
                [
                    97,
                    " tmp [ d + 1 ] = * data ++ ;\n"
                ],
                [
                    98,
                    " tmp [ d + 0 + stride ] = * data ++ ;\n"
                ],
                [
                    99,
                    " tmp [ d + 1 + stride ] = * data ++ ;\n"
                ],
                [
                    113,
                    " tmp [ x ] = data [ mask & 1 ] ;\n"
                ],
                [
                    119,
                    " data += 2 ;\n"
                ],
                [
                    129,
                    " tmp [ x ] = data [ mask & 3 ] ;\n"
                ],
                [
                    135,
                    " data += type - 30 ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int decode_13 ( AVCodecContext * avctx , DxaDecContext * c , uint8_t * dst , uint8_t * src , uint8_t * ref ) {\n"
                ],
                [
                    8,
                    " data = code + ( ( avctx -> width * avctx -> height ) >> 4 ) ;\n"
                ],
                [
                    17,
                    " tmp = dst + i ;\n"
                ],
                [
                    49,
                    " tmp [ x ] = ( mask & 0x8000 ) ? * data ++ : tmp2 [ x ] ;\n"
                ],
                [
                    57,
                    " y < 4 ;\n"
                ],
                [
                    59,
                    " memset ( tmp , data [ 0 ] , 4 ) ;\n"
                ],
                [
                    60,
                    " tmp += stride ;\n"
                ],
                [
                    62,
                    " data ++ ;\n"
                ],
                [
                    67,
                    " memcpy ( tmp , data , 4 ) ;\n"
                ],
                [
                    68,
                    " data += 4 ;\n"
                ],
                [
                    85,
                    " case 0x00 : tmp [ d + 0 ] = tmp2 [ 0 ] ;\n"
                ],
                [
                    86,
                    " tmp [ d + 1 ] = tmp2 [ 1 ] ;\n"
                ],
                [
                    87,
                    " tmp [ d + 0 + stride ] = tmp2 [ 0 + stride ] ;\n"
                ],
                [
                    88,
                    " tmp [ d + 1 + stride ] = tmp2 [ 1 + stride ] ;\n"
                ],
                [
                    90,
                    " case 0x40 : tmp [ d + 0 ] = data [ 0 ] ;\n"
                ],
                [
                    91,
                    " tmp [ d + 1 ] = data [ 0 ] ;\n"
                ],
                [
                    92,
                    " tmp [ d + 0 + stride ] = data [ 0 ] ;\n"
                ],
                [
                    93,
                    " tmp [ d + 1 + stride ] = data [ 0 ] ;\n"
                ],
                [
                    94,
                    " data ++ ;\n"
                ],
                [
                    96,
                    " case 0xC0 : tmp [ d + 0 ] = * data ++ ;\n"
                ],
                [
                    97,
                    " tmp [ d + 1 ] = * data ++ ;\n"
                ],
                [
                    98,
                    " tmp [ d + 0 + stride ] = * data ++ ;\n"
                ],
                [
                    99,
                    " tmp [ d + 1 + stride ] = * data ++ ;\n"
                ],
                [
                    113,
                    " tmp [ x ] = data [ mask & 1 ] ;\n"
                ],
                [
                    119,
                    " data += 2 ;\n"
                ],
                [
                    129,
                    " tmp [ x ] = data [ mask & 3 ] ;\n"
                ],
                [
                    135,
                    " data += type - 30 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_13 ( AVCodecContext * avctx , DxaDecContext * c , uint8_t * dst , uint8_t * src , uint8_t * ref ) {\n"
                ],
                [
                    8,
                    " data = code + ( ( avctx -> width * avctx -> height ) >> 4 ) ;\n"
                ],
                [
                    17,
                    " tmp = dst + i ;\n"
                ],
                [
                    18,
                    " tmp2 = ref + i ;\n"
                ],
                [
                    25,
                    " tmp2 += x + y * stride ;\n"
                ],
                [
                    27,
                    " y < 4 ;\n"
                ],
                [
                    29,
                    " memcpy ( tmp , tmp2 , 4 ) ;\n"
                ],
                [
                    30,
                    " tmp += stride ;\n"
                ],
                [
                    31,
                    " tmp2 += stride ;\n"
                ],
                [
                    49,
                    " tmp [ x ] = ( mask & 0x8000 ) ? * data ++ : tmp2 [ x ] ;\n"
                ],
                [
                    53,
                    " tmp2 += stride ;\n"
                ],
                [
                    57,
                    " y < 4 ;\n"
                ],
                [
                    59,
                    " memset ( tmp , data [ 0 ] , 4 ) ;\n"
                ],
                [
                    60,
                    " tmp += stride ;\n"
                ],
                [
                    62,
                    " data ++ ;\n"
                ],
                [
                    65,
                    " y < 4 ;\n"
                ],
                [
                    67,
                    " memcpy ( tmp , data , 4 ) ;\n"
                ],
                [
                    68,
                    " data += 4 ;\n"
                ],
                [
                    69,
                    " tmp += stride ;\n"
                ],
                [
                    78,
                    " tmp2 = ref + i + d2 ;\n"
                ],
                [
                    84,
                    " tmp2 += x + y * stride ;\n"
                ],
                [
                    85,
                    " case 0x00 : tmp [ d + 0 ] = tmp2 [ 0 ] ;\n"
                ],
                [
                    86,
                    " tmp [ d + 1 ] = tmp2 [ 1 ] ;\n"
                ],
                [
                    87,
                    " tmp [ d + 0 + stride ] = tmp2 [ 0 + stride ] ;\n"
                ],
                [
                    88,
                    " tmp [ d + 1 + stride ] = tmp2 [ 1 + stride ] ;\n"
                ],
                [
                    90,
                    " case 0x40 : tmp [ d + 0 ] = data [ 0 ] ;\n"
                ],
                [
                    91,
                    " tmp [ d + 1 ] = data [ 0 ] ;\n"
                ],
                [
                    92,
                    " tmp [ d + 0 + stride ] = data [ 0 ] ;\n"
                ],
                [
                    93,
                    " tmp [ d + 1 + stride ] = data [ 0 ] ;\n"
                ],
                [
                    94,
                    " data ++ ;\n"
                ],
                [
                    96,
                    " case 0xC0 : tmp [ d + 0 ] = * data ++ ;\n"
                ],
                [
                    97,
                    " tmp [ d + 1 ] = * data ++ ;\n"
                ],
                [
                    98,
                    " tmp [ d + 0 + stride ] = * data ++ ;\n"
                ],
                [
                    99,
                    " tmp [ d + 1 + stride ] = * data ++ ;\n"
                ],
                [
                    113,
                    " tmp [ x ] = data [ mask & 1 ] ;\n"
                ],
                [
                    119,
                    " data += 2 ;\n"
                ],
                [
                    129,
                    " tmp [ x ] = data [ mask & 3 ] ;\n"
                ],
                [
                    135,
                    " data += type - 30 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n DxaDecContext * const c = avctx -> priv_data ;\n uint8_t * outptr , * srcptr , * tmpptr ;\n unsigned long dsize ;\n int i , j , compr , ret ;\n int stride ;\n int orig_buf_size = buf_size ;\n int pc = 0 ;\n if ( buf [ 0 ] == 'C' && buf [ 1 ] == 'M' && buf [ 2 ] == 'A' && buf [ 3 ] == 'P' ) {\n int r , g , b ;\n buf += 4 ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n r = * buf ++ ;\n g = * buf ++ ;\n b = * buf ++ ;\n c -> pal [ i ] = ( r << 16 ) | ( g << 8 ) | b ;\n }\n pc = 1 ;\n buf_size -= 768 + 4 ;\n }\n if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n c -> pic . palette_has_changed = pc ;\n outptr = c -> pic . data [ 0 ] ;\n srcptr = c -> decomp_buf ;\n tmpptr = c -> prev . data [ 0 ] ;\n stride = c -> pic . linesize [ 0 ] ;\n if ( buf [ 0 ] == 'N' && buf [ 1 ] == 'U' && buf [ 2 ] == 'L' && buf [ 3 ] == 'L' ) compr = - 1 ;\n else compr = buf [ 4 ] ;\n dsize = c -> dsize ;\n if ( ( compr != 4 && compr != - 1 ) && uncompress ( c -> decomp_buf , & dsize , buf + 9 , buf_size - 9 ) != Z_OK ) {\n av_log ( avctx , AV_LOG_ERROR , \"Uncompress failed!\\n\" ) ;\n return AVERROR_UNKNOWN ;\n }\n switch ( compr ) {\n case - 1 : c -> pic . key_frame = 0 ;\n c -> pic . pict_type = AV_PICTURE_TYPE_P ;\n if ( c -> prev . data [ 0 ] ) memcpy ( c -> pic . data [ 0 ] , c -> prev . data [ 0 ] , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n else {\n memset ( c -> pic . data [ 0 ] , 0 , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n c -> pic . key_frame = 1 ;\n c -> pic . pict_type = AV_PICTURE_TYPE_I ;\n }\n break ;\n case 2 : case 3 : case 4 : case 5 : c -> pic . key_frame = ! ( compr & 1 ) ;\n c -> pic . pict_type = ( compr & 1 ) ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I ;\n for ( j = 0 ;\n j < avctx -> height ;\n j ++ ) {\n if ( compr & 1 ) {\n for ( i = 0 ;\n i < avctx -> width ;\n i ++ ) outptr [ i ] = srcptr [ i ] ^ tmpptr [ i ] ;\n tmpptr += stride ;\n }\n else memcpy ( outptr , srcptr , avctx -> width ) ;\n outptr += stride ;\n srcptr += avctx -> width ;\n }\n break ;\n case 12 : case 13 : c -> pic . key_frame = 0 ;\n c -> pic . pict_type = AV_PICTURE_TYPE_P ;\n decode_13 ( avctx , c , c -> pic . data [ 0 ] , srcptr , c -> prev . data [ 0 ] ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unknown/unsupported compression type %d\\n\" , buf [ 4 ] ) ;\n return AVERROR_INVALIDDATA ;\n }\n FFSWAP ( AVFrame , c -> pic , c -> prev ) ;\n if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> prev ;\n return orig_buf_size ;\n }",
        "hash": 1864017524114662826,
        "project": "debian",
        "size": 80,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " DxaDecContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    20,
                    " c -> pal [ i ] = ( r << 16 ) | ( g << 8 ) | b ;\n"
                ],
                [
                    25,
                    " if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n"
                ],
                [
                    29,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    31,
                    " outptr = c -> pic . data [ 0 ] ;\n"
                ],
                [
                    32,
                    " srcptr = c -> decomp_buf ;\n"
                ],
                [
                    45,
                    " if ( c -> prev . data [ 0 ] ) memcpy ( c -> pic . data [ 0 ] , c -> prev . data [ 0 ] , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n"
                ],
                [
                    57,
                    " if ( compr & 1 ) {\n"
                ],
                [
                    59,
                    " i < avctx -> width ;\n"
                ],
                [
                    60,
                    " i ++ ) outptr [ i ] = srcptr [ i ] ^ tmpptr [ i ] ;\n"
                ],
                [
                    63,
                    " else memcpy ( outptr , srcptr , avctx -> width ) ;\n"
                ],
                [
                    64,
                    " outptr += stride ;\n"
                ],
                [
                    65,
                    " srcptr += avctx -> width ;\n"
                ],
                [
                    70,
                    " decode_13 ( avctx , c , c -> pic . data [ 0 ] , srcptr , c -> prev . data [ 0 ] ) ;\n"
                ],
                [
                    76,
                    " if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    45,
                    " if ( c -> prev . data [ 0 ] ) memcpy ( c -> pic . data [ 0 ] , c -> prev . data [ 0 ] , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n"
                ],
                [
                    47,
                    " memset ( c -> pic . data [ 0 ] , 0 , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    4,
                    " DxaDecContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    20,
                    " c -> pal [ i ] = ( r << 16 ) | ( g << 8 ) | b ;\n"
                ],
                [
                    25,
                    " if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n"
                ],
                [
                    29,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    31,
                    " outptr = c -> pic . data [ 0 ] ;\n"
                ],
                [
                    32,
                    " srcptr = c -> decomp_buf ;\n"
                ],
                [
                    45,
                    " if ( c -> prev . data [ 0 ] ) memcpy ( c -> pic . data [ 0 ] , c -> prev . data [ 0 ] , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n"
                ],
                [
                    47,
                    " memset ( c -> pic . data [ 0 ] , 0 , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n"
                ],
                [
                    57,
                    " if ( compr & 1 ) {\n"
                ],
                [
                    59,
                    " i < avctx -> width ;\n"
                ],
                [
                    60,
                    " i ++ ) outptr [ i ] = srcptr [ i ] ^ tmpptr [ i ] ;\n"
                ],
                [
                    63,
                    " else memcpy ( outptr , srcptr , avctx -> width ) ;\n"
                ],
                [
                    64,
                    " outptr += stride ;\n"
                ],
                [
                    65,
                    " srcptr += avctx -> width ;\n"
                ],
                [
                    70,
                    " decode_13 ( avctx , c , c -> pic . data [ 0 ] , srcptr , c -> prev . data [ 0 ] ) ;\n"
                ],
                [
                    76,
                    " if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n RALFContext * ctx = avctx -> priv_data ;\n AVFrame * frame = data ;\n int16_t * samples0 ;\n int16_t * samples1 ;\n int ret ;\n GetBitContext gb ;\n int table_size , table_bytes , i ;\n const uint8_t * src , * block_pointer ;\n int src_size ;\n int bytes_left ;\n if ( ctx -> has_pkt ) {\n ctx -> has_pkt = 0 ;\n table_bytes = ( AV_RB16 ( avpkt -> data ) + 7 ) >> 3 ;\n if ( table_bytes + 3 > avpkt -> size || avpkt -> size > RALF_MAX_PKT_SIZE ) {\n av_log ( avctx , AV_LOG_ERROR , \"Wrong packet's breath smells of wrong data!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( memcmp ( ctx -> pkt , avpkt -> data , 2 + table_bytes ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Wrong packet tails are wrong!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n src = ctx -> pkt ;\n src_size = RALF_MAX_PKT_SIZE + avpkt -> size ;\n memcpy ( ctx -> pkt + RALF_MAX_PKT_SIZE , avpkt -> data + 2 + table_bytes , avpkt -> size - 2 - table_bytes ) ;\n }\n else {\n if ( avpkt -> size == RALF_MAX_PKT_SIZE ) {\n memcpy ( ctx -> pkt , avpkt -> data , avpkt -> size ) ;\n ctx -> has_pkt = 1 ;\n * got_frame_ptr = 0 ;\n return avpkt -> size ;\n }\n src = avpkt -> data ;\n src_size = avpkt -> size ;\n }\n frame -> nb_samples = ctx -> max_frame_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Me fail get_buffer()? That's unpossible!\\n\" ) ;\n return ret ;\n }\n samples0 = ( int16_t * ) frame -> data [ 0 ] ;\n samples1 = ( int16_t * ) frame -> data [ 1 ] ;\n if ( src_size < 5 ) {\n av_log ( avctx , AV_LOG_ERROR , \"too short packets are too short!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n table_size = AV_RB16 ( src ) ;\n table_bytes = ( table_size + 7 ) >> 3 ;\n if ( src_size < table_bytes + 3 ) {\n av_log ( avctx , AV_LOG_ERROR , \"short packets are short!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n init_get_bits ( & gb , src + 2 , table_size ) ;\n ctx -> num_blocks = 0 ;\n while ( get_bits_left ( & gb ) > 0 ) {\n ctx -> block_size [ ctx -> num_blocks ] = get_bits ( & gb , 15 ) ;\n if ( get_bits1 ( & gb ) ) {\n ctx -> block_pts [ ctx -> num_blocks ] = get_bits ( & gb , 9 ) ;\n }\n else {\n ctx -> block_pts [ ctx -> num_blocks ] = 0 ;\n }\n ctx -> num_blocks ++ ;\n }\n block_pointer = src + table_bytes + 2 ;\n bytes_left = src_size - table_bytes - 2 ;\n ctx -> sample_offset = 0 ;\n for ( i = 0 ;\n i < ctx -> num_blocks ;\n i ++ ) {\n if ( bytes_left < ctx -> block_size [ i ] ) {\n av_log ( avctx , AV_LOG_ERROR , \"I'm pedaling backwards\\n\" ) ;\n break ;\n }\n init_get_bits ( & gb , block_pointer , ctx -> block_size [ i ] * 8 ) ;\n if ( decode_block ( avctx , & gb , samples0 + ctx -> sample_offset , samples1 + ctx -> sample_offset ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Sir, I got carsick in your office. Not decoding the rest of packet.\\n\" ) ;\n break ;\n }\n block_pointer += ctx -> block_size [ i ] ;\n bytes_left -= ctx -> block_size [ i ] ;\n }\n frame -> nb_samples = ctx -> sample_offset ;\n * got_frame_ptr = ctx -> sample_offset > 0 ;\n return avpkt -> size ;\n }",
        "hash": -2385618084223928445,
        "project": "debian",
        "size": 87,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " RALFContext * ctx = avctx -> priv_data ;\n"
                ],
                [
                    14,
                    " table_bytes = ( AV_RB16 ( avpkt -> data ) + 7 ) >> 3 ;\n"
                ],
                [
                    15,
                    " if ( table_bytes + 3 > avpkt -> size || avpkt -> size > RALF_MAX_PKT_SIZE ) {\n"
                ],
                [
                    19,
                    " if ( memcmp ( ctx -> pkt , avpkt -> data , 2 + table_bytes ) ) {\n"
                ],
                [
                    25,
                    " memcpy ( ctx -> pkt + RALF_MAX_PKT_SIZE , avpkt -> data + 2 + table_bytes , avpkt -> size - 2 - table_bytes ) ;\n"
                ],
                [
                    28,
                    " if ( avpkt -> size == RALF_MAX_PKT_SIZE ) {\n"
                ],
                [
                    29,
                    " memcpy ( ctx -> pkt , avpkt -> data , avpkt -> size ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " RALFContext * ctx = avctx -> priv_data ;\n"
                ],
                [
                    14,
                    " table_bytes = ( AV_RB16 ( avpkt -> data ) + 7 ) >> 3 ;\n"
                ],
                [
                    15,
                    " if ( table_bytes + 3 > avpkt -> size || avpkt -> size > RALF_MAX_PKT_SIZE ) {\n"
                ],
                [
                    19,
                    " if ( memcmp ( ctx -> pkt , avpkt -> data , 2 + table_bytes ) ) {\n"
                ],
                [
                    20,
                    " av_log ( avctx , AV_LOG_ERROR , \"Wrong packet tails are wrong!\\n\" ) ;\n"
                ],
                [
                    21,
                    " return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    23,
                    " src = ctx -> pkt ;\n"
                ],
                [
                    24,
                    " src_size = RALF_MAX_PKT_SIZE + avpkt -> size ;\n"
                ],
                [
                    25,
                    " memcpy ( ctx -> pkt + RALF_MAX_PKT_SIZE , avpkt -> data + 2 + table_bytes , avpkt -> size - 2 - table_bytes ) ;\n"
                ],
                [
                    37,
                    " frame -> nb_samples = ctx -> max_frame_size ;\n"
                ],
                [
                    38,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " RALFContext * ctx = avctx -> priv_data ;\n"
                ],
                [
                    14,
                    " table_bytes = ( AV_RB16 ( avpkt -> data ) + 7 ) >> 3 ;\n"
                ],
                [
                    15,
                    " if ( table_bytes + 3 > avpkt -> size || avpkt -> size > RALF_MAX_PKT_SIZE ) {\n"
                ],
                [
                    19,
                    " if ( memcmp ( ctx -> pkt , avpkt -> data , 2 + table_bytes ) ) {\n"
                ],
                [
                    20,
                    " av_log ( avctx , AV_LOG_ERROR , \"Wrong packet tails are wrong!\\n\" ) ;\n"
                ],
                [
                    21,
                    " return AVERROR_INVALIDDATA ;\n"
                ],
                [
                    23,
                    " src = ctx -> pkt ;\n"
                ],
                [
                    24,
                    " src_size = RALF_MAX_PKT_SIZE + avpkt -> size ;\n"
                ],
                [
                    25,
                    " memcpy ( ctx -> pkt + RALF_MAX_PKT_SIZE , avpkt -> data + 2 + table_bytes , avpkt -> size - 2 - table_bytes ) ;\n"
                ],
                [
                    28,
                    " if ( avpkt -> size == RALF_MAX_PKT_SIZE ) {\n"
                ],
                [
                    29,
                    " memcpy ( ctx -> pkt , avpkt -> data , avpkt -> size ) ;\n"
                ],
                [
                    37,
                    " frame -> nb_samples = ctx -> max_frame_size ;\n"
                ],
                [
                    38,
                    " if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n ZmbvContext * const c = avctx -> priv_data ;\n int zret = Z_OK ;\n int len = buf_size ;\n int hi_ver , lo_ver , ret ;\n uint8_t * tmp ;\n if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n c -> pic . reference = 1 ;\n c -> pic . buffer_hints = FF_BUFFER_HINTS_VALID ;\n if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n c -> flags = buf [ 0 ] ;\n buf ++ ;\n len -- ;\n if ( c -> flags & ZMBV_KEYFRAME ) {\n hi_ver = buf [ 0 ] ;\n lo_ver = buf [ 1 ] ;\n c -> comp = buf [ 2 ] ;\n c -> fmt = buf [ 3 ] ;\n c -> bw = buf [ 4 ] ;\n c -> bh = buf [ 5 ] ;\n c -> decode_intra = NULL ;\n c -> decode_xor = NULL ;\n buf += 6 ;\n len -= 6 ;\n av_log ( avctx , AV_LOG_DEBUG , \"Flags=%X ver=%i.%i comp=%i fmt=%i blk=%ix%i\\n\" , c -> flags , hi_ver , lo_ver , c -> comp , c -> fmt , c -> bw , c -> bh ) ;\n if ( hi_ver != 0 || lo_ver != 1 ) {\n av_log_ask_for_sample ( avctx , \"Unsupported version %i.%i\\n\" , hi_ver , lo_ver ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( c -> bw == 0 || c -> bh == 0 ) {\n av_log_ask_for_sample ( avctx , \"Unsupported block size %ix%i\\n\" , c -> bw , c -> bh ) ;\n return AVERROR_PATCHWELCOME ;\n }\n if ( c -> comp != 0 && c -> comp != 1 ) {\n av_log_ask_for_sample ( avctx , \"Unsupported compression type %i\\n\" , c -> comp ) ;\n return AVERROR_PATCHWELCOME ;\n }\n switch ( c -> fmt ) {\n case ZMBV_FMT_8BPP : c -> bpp = 8 ;\n c -> decode_intra = zmbv_decode_intra ;\n c -> decode_xor = zmbv_decode_xor_8 ;\n break ;\n case ZMBV_FMT_15BPP : case ZMBV_FMT_16BPP : c -> bpp = 16 ;\n c -> decode_intra = zmbv_decode_intra ;\n c -> decode_xor = zmbv_decode_xor_16 ;\n break ;\n # ifdef ZMBV_ENABLE_24BPP case ZMBV_FMT_24BPP : c -> bpp = 24 ;\n c -> decode_intra = zmbv_decode_intra ;\n c -> decode_xor = zmbv_decode_xor_24 ;\n break ;\n # endif case ZMBV_FMT_32BPP : c -> bpp = 32 ;\n c -> decode_intra = zmbv_decode_intra ;\n c -> decode_xor = zmbv_decode_xor_32 ;\n break ;\n default : c -> decode_intra = NULL ;\n c -> decode_xor = NULL ;\n av_log_ask_for_sample ( avctx , \"Unsupported (for now) format %i\\n\" , c -> fmt ) ;\n return AVERROR_PATCHWELCOME ;\n }\n zret = inflateReset ( & c -> zstream ) ;\n if ( zret != Z_OK ) {\n av_log ( avctx , AV_LOG_ERROR , \"Inflate reset error: %d\\n\" , zret ) ;\n return AVERROR_UNKNOWN ;\n }\n tmp = av_realloc ( c -> cur , avctx -> width * avctx -> height * ( c -> bpp / 8 ) ) ;\n if ( ! tmp ) return AVERROR ( ENOMEM ) ;\n c -> cur = tmp ;\n tmp = av_realloc ( c -> prev , avctx -> width * avctx -> height * ( c -> bpp / 8 ) ) ;\n if ( ! tmp ) return AVERROR ( ENOMEM ) ;\n c -> prev = tmp ;\n c -> bx = ( c -> width + c -> bw - 1 ) / c -> bw ;\n c -> by = ( c -> height + c -> bh - 1 ) / c -> bh ;\n }\n if ( c -> decode_intra == NULL ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error! Got no format or no keyframe!\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( c -> comp == 0 ) {\n memcpy ( c -> decomp_buf , buf , len ) ;\n c -> decomp_size = 1 ;\n }\n else {\n c -> zstream . total_in = c -> zstream . total_out = 0 ;\n c -> zstream . next_in = buf ;\n c -> zstream . avail_in = len ;\n c -> zstream . next_out = c -> decomp_buf ;\n c -> zstream . avail_out = c -> decomp_size ;\n zret = inflate ( & c -> zstream , Z_SYNC_FLUSH ) ;\n if ( zret != Z_OK && zret != Z_STREAM_END ) {\n av_log ( avctx , AV_LOG_ERROR , \"inflate error %d\\n\" , zret ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> decomp_len = c -> zstream . total_out ;\n }\n if ( c -> flags & ZMBV_KEYFRAME ) {\n c -> pic . key_frame = 1 ;\n c -> pic . pict_type = AV_PICTURE_TYPE_I ;\n c -> decode_intra ( c ) ;\n }\n else {\n c -> pic . key_frame = 0 ;\n c -> pic . pict_type = AV_PICTURE_TYPE_P ;\n if ( c -> decomp_len ) c -> decode_xor ( c ) ;\n }\n {\n uint8_t * out , * src ;\n int i , j ;\n out = c -> pic . data [ 0 ] ;\n src = c -> cur ;\n switch ( c -> fmt ) {\n case ZMBV_FMT_8BPP : for ( j = 0 ;\n j < c -> height ;\n j ++ ) {\n for ( i = 0 ;\n i < c -> width ;\n i ++ ) {\n out [ i * 3 + 0 ] = c -> pal [ ( * src ) * 3 + 0 ] ;\n out [ i * 3 + 1 ] = c -> pal [ ( * src ) * 3 + 1 ] ;\n out [ i * 3 + 2 ] = c -> pal [ ( * src ) * 3 + 2 ] ;\n src ++ ;\n }\n out += c -> pic . linesize [ 0 ] ;\n }\n break ;\n case ZMBV_FMT_15BPP : for ( j = 0 ;\n j < c -> height ;\n j ++ ) {\n for ( i = 0 ;\n i < c -> width ;\n i ++ ) {\n uint16_t tmp = AV_RL16 ( src ) ;\n src += 2 ;\n out [ i * 3 + 0 ] = ( tmp & 0x7C00 ) >> 7 ;\n out [ i * 3 + 1 ] = ( tmp & 0x03E0 ) >> 2 ;\n out [ i * 3 + 2 ] = ( tmp & 0x001F ) << 3 ;\n }\n out += c -> pic . linesize [ 0 ] ;\n }\n break ;\n case ZMBV_FMT_16BPP : for ( j = 0 ;\n j < c -> height ;\n j ++ ) {\n for ( i = 0 ;\n i < c -> width ;\n i ++ ) {\n uint16_t tmp = AV_RL16 ( src ) ;\n src += 2 ;\n out [ i * 3 + 0 ] = ( tmp & 0xF800 ) >> 8 ;\n out [ i * 3 + 1 ] = ( tmp & 0x07E0 ) >> 3 ;\n out [ i * 3 + 2 ] = ( tmp & 0x001F ) << 3 ;\n }\n out += c -> pic . linesize [ 0 ] ;\n }\n break ;\n # ifdef ZMBV_ENABLE_24BPP case ZMBV_FMT_24BPP : for ( j = 0 ;\n j < c -> height ;\n j ++ ) {\n memcpy ( out , src , c -> width * 3 ) ;\n src += c -> width * 3 ;\n out += c -> pic . linesize [ 0 ] ;\n }\n break ;\n # endif case ZMBV_FMT_32BPP : for ( j = 0 ;\n j < c -> height ;\n j ++ ) {\n for ( i = 0 ;\n i < c -> width ;\n i ++ ) {\n uint32_t tmp = AV_RL32 ( src ) ;\n src += 4 ;\n AV_WB24 ( out + ( i * 3 ) , tmp ) ;\n }\n out += c -> pic . linesize [ 0 ] ;\n }\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Cannot handle format %i\\n\" , c -> fmt ) ;\n }\n FFSWAP ( uint8_t * , c -> cur , c -> prev ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return buf_size ;\n }",
        "hash": -4178541639582894026,
        "project": "debian",
        "size": 188,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    4,
                    " ZmbvContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    17,
                    " buf ++ ;\n"
                ],
                [
                    18,
                    " len -- ;\n"
                ],
                [
                    28,
                    " buf += 6 ;\n"
                ],
                [
                    29,
                    " len -= 6 ;\n"
                ],
                [
                    83,
                    " if ( c -> comp == 0 ) {\n"
                ],
                [
                    84,
                    " memcpy ( c -> decomp_buf , buf , len ) ;\n"
                ],
                [
                    103,
                    " c -> decode_intra ( c ) ;\n"
                ],
                [
                    108,
                    " if ( c -> decomp_len ) c -> decode_xor ( c ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n"
                ],
                [
                    2,
                    " const uint8_t * buf = avpkt -> data ;\n"
                ],
                [
                    4,
                    " ZmbvContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    17,
                    " buf ++ ;\n"
                ],
                [
                    18,
                    " len -- ;\n"
                ],
                [
                    28,
                    " buf += 6 ;\n"
                ],
                [
                    29,
                    " len -= 6 ;\n"
                ],
                [
                    83,
                    " if ( c -> comp == 0 ) {\n"
                ],
                [
                    84,
                    " memcpy ( c -> decomp_buf , buf , len ) ;\n"
                ],
                [
                    103,
                    " c -> decode_intra ( c ) ;\n"
                ],
                [
                    108,
                    " if ( c -> decomp_len ) c -> decode_xor ( c ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int rv34_decode_intra_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n MpegEncContext * s = & r -> s ;\n int cbp , dist ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n dist = ( s -> mb_x - s -> resync_mb_x ) + ( s -> mb_y - s -> resync_mb_y ) * s -> mb_width ;\n if ( s -> mb_x && dist ) r -> avail_cache [ 5 ] = r -> avail_cache [ 9 ] = s -> current_picture_ptr -> f . mb_type [ mb_pos - 1 ] ;\n if ( dist >= s -> mb_width ) r -> avail_cache [ 2 ] = r -> avail_cache [ 3 ] = s -> current_picture_ptr -> f . mb_type [ mb_pos - s -> mb_stride ] ;\n if ( ( ( s -> mb_x + 1 ) < s -> mb_width ) && dist >= s -> mb_width - 1 ) r -> avail_cache [ 4 ] = s -> current_picture_ptr -> f . mb_type [ mb_pos - s -> mb_stride + 1 ] ;\n if ( s -> mb_x && dist > s -> mb_width ) r -> avail_cache [ 1 ] = s -> current_picture_ptr -> f . mb_type [ mb_pos - s -> mb_stride - 1 ] ;\n s -> qscale = r -> si . quant ;\n cbp = rv34_decode_intra_mb_header ( r , intra_types ) ;\n r -> cbp_luma [ mb_pos ] = cbp ;\n r -> cbp_chroma [ mb_pos ] = cbp >> 16 ;\n r -> deblock_coefs [ mb_pos ] = 0xFFFF ;\n s -> current_picture_ptr -> f . qscale_table [ mb_pos ] = s -> qscale ;\n if ( cbp == - 1 ) return - 1 ;\n if ( r -> is16 ) {\n rv34_output_i16x16 ( r , intra_types , cbp ) ;\n return 0 ;\n }\n rv34_output_intra ( r , intra_types , cbp ) ;\n return 0 ;\n }",
        "hash": 2335222688263906532,
        "project": "debian",
        "size": 25,
        "slice": {
            "memset": [
                [
                    1,
                    "static int rv34_decode_intra_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n"
                ],
                [
                    5,
                    " memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n"
                ],
                [
                    6,
                    " fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n"
                ],
                [
                    13,
                    " cbp = rv34_decode_intra_mb_header ( r , intra_types ) ;\n"
                ],
                [
                    20,
                    " rv34_output_i16x16 ( r , intra_types , cbp ) ;\n"
                ],
                [
                    23,
                    " rv34_output_intra ( r , intra_types , cbp ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int rv34_decode_intra_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n"
                ],
                [
                    5,
                    " memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n"
                ],
                [
                    6,
                    " fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n"
                ],
                [
                    13,
                    " cbp = rv34_decode_intra_mb_header ( r , intra_types ) ;\n"
                ],
                [
                    20,
                    " rv34_output_i16x16 ( r , intra_types , cbp ) ;\n"
                ],
                [
                    23,
                    " rv34_output_intra ( r , intra_types , cbp ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int rv34_decode_mv ( RV34DecContext * r , int block_type ) {\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n int i , j , k , l ;\n int mv_pos = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n int next_bt ;\n memset ( r -> dmv , 0 , sizeof ( r -> dmv ) ) ;\n for ( i = 0 ;\n i < num_mvs [ block_type ] ;\n i ++ ) {\n r -> dmv [ i ] [ 0 ] = svq3_get_se_golomb ( gb ) ;\n r -> dmv [ i ] [ 1 ] = svq3_get_se_golomb ( gb ) ;\n }\n switch ( block_type ) {\n case RV34_MB_TYPE_INTRA : case RV34_MB_TYPE_INTRA16x16 : ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n return 0 ;\n case RV34_MB_SKIP : if ( s -> pict_type == AV_PICTURE_TYPE_P ) {\n ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n break ;\n }\n case RV34_MB_B_DIRECT : if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) ff_thread_await_progress ( & s -> next_picture_ptr -> f , FFMAX ( 0 , s -> mb_y - 1 ) , 0 ) ;\n next_bt = s -> next_picture_ptr -> f . mb_type [ s -> mb_x + s -> mb_y * s -> mb_stride ] ;\n if ( IS_INTRA ( next_bt ) || IS_SKIP ( next_bt ) ) {\n ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 1 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n }\n else for ( j = 0 ;\n j < 2 ;\n j ++ ) for ( i = 0 ;\n i < 2 ;\n i ++ ) for ( k = 0 ;\n k < 2 ;\n k ++ ) for ( l = 0 ;\n l < 2 ;\n l ++ ) s -> current_picture_ptr -> f . motion_val [ l ] [ mv_pos + i + j * s -> b8_stride ] [ k ] = calc_add_mv ( r , l , s -> next_picture_ptr -> f . motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ k ] ) ;\n if ( ! ( IS_16X8 ( next_bt ) || IS_8X16 ( next_bt ) || IS_8X8 ( next_bt ) ) ) rv34_mc_2mv ( r , block_type ) ;\n else rv34_mc_2mv_skip ( r ) ;\n ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n break ;\n case RV34_MB_P_16x16 : case RV34_MB_P_MIX16x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n break ;\n case RV34_MB_B_FORWARD : case RV34_MB_B_BACKWARD : r -> dmv [ 1 ] [ 0 ] = r -> dmv [ 0 ] [ 0 ] ;\n r -> dmv [ 1 ] [ 1 ] = r -> dmv [ 0 ] [ 1 ] ;\n if ( r -> rv30 ) rv34_pred_mv_rv3 ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n else rv34_pred_mv_b ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , block_type == RV34_MB_B_BACKWARD ) ;\n break ;\n case RV34_MB_P_16x8 : case RV34_MB_P_8x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n rv34_pred_mv ( r , block_type , 1 + ( block_type == RV34_MB_P_16x8 ) , 1 ) ;\n if ( block_type == RV34_MB_P_16x8 ) {\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 1 , 0 ) ;\n rv34_mc_1mv ( r , block_type , 0 , 8 , s -> b8_stride , 2 , 1 , 0 ) ;\n }\n if ( block_type == RV34_MB_P_8x16 ) {\n rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 1 , 2 , 0 ) ;\n rv34_mc_1mv ( r , block_type , 8 , 0 , 1 , 1 , 2 , 0 ) ;\n }\n break ;\n case RV34_MB_B_BIDIR : rv34_pred_mv_b ( r , block_type , 0 ) ;\n rv34_pred_mv_b ( r , block_type , 1 ) ;\n rv34_mc_2mv ( r , block_type ) ;\n break ;\n case RV34_MB_P_8x8 : for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n rv34_pred_mv ( r , block_type , i , i ) ;\n rv34_mc_1mv ( r , block_type , ( i & 1 ) << 3 , ( i & 2 ) << 2 , ( i & 1 ) + ( i >> 1 ) * s -> b8_stride , 1 , 1 , 0 ) ;\n }\n break ;\n }\n return 0 ;\n }",
        "hash": 2335222688263906532,
        "project": "debian",
        "size": 74,
        "slice": {
            "memset": [
                [
                    1,
                    "static int rv34_decode_mv ( RV34DecContext * r , int block_type ) {\n"
                ],
                [
                    7,
                    " memset ( r -> dmv , 0 , sizeof ( r -> dmv ) ) ;\n"
                ],
                [
                    19,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n"
                ],
                [
                    36,
                    " l ++ ) s -> current_picture_ptr -> f . motion_val [ l ] [ mv_pos + i + j * s -> b8_stride ] [ k ] = calc_add_mv ( r , l , s -> next_picture_ptr -> f . motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ k ] ) ;\n"
                ],
                [
                    37,
                    " if ( ! ( IS_16X8 ( next_bt ) || IS_8X16 ( next_bt ) || IS_8X8 ( next_bt ) ) ) rv34_mc_2mv ( r , block_type ) ;\n"
                ],
                [
                    38,
                    " else rv34_mc_2mv_skip ( r ) ;\n"
                ],
                [
                    41,
                    " case RV34_MB_P_16x16 : case RV34_MB_P_MIX16x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n"
                ],
                [
                    42,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n"
                ],
                [
                    46,
                    " if ( r -> rv30 ) rv34_pred_mv_rv3 ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n"
                ],
                [
                    47,
                    " else rv34_pred_mv_b ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n"
                ],
                [
                    48,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , block_type == RV34_MB_B_BACKWARD ) ;\n"
                ],
                [
                    50,
                    " case RV34_MB_P_16x8 : case RV34_MB_P_8x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n"
                ],
                [
                    51,
                    " rv34_pred_mv ( r , block_type , 1 + ( block_type == RV34_MB_P_16x8 ) , 1 ) ;\n"
                ],
                [
                    53,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 1 , 0 ) ;\n"
                ],
                [
                    54,
                    " rv34_mc_1mv ( r , block_type , 0 , 8 , s -> b8_stride , 2 , 1 , 0 ) ;\n"
                ],
                [
                    57,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 1 , 2 , 0 ) ;\n"
                ],
                [
                    58,
                    " rv34_mc_1mv ( r , block_type , 8 , 0 , 1 , 1 , 2 , 0 ) ;\n"
                ],
                [
                    61,
                    " case RV34_MB_B_BIDIR : rv34_pred_mv_b ( r , block_type , 0 ) ;\n"
                ],
                [
                    62,
                    " rv34_pred_mv_b ( r , block_type , 1 ) ;\n"
                ],
                [
                    63,
                    " rv34_mc_2mv ( r , block_type ) ;\n"
                ],
                [
                    68,
                    " rv34_pred_mv ( r , block_type , i , i ) ;\n"
                ],
                [
                    69,
                    " rv34_mc_1mv ( r , block_type , ( i & 1 ) << 3 , ( i & 2 ) << 2 , ( i & 1 ) + ( i >> 1 ) * s -> b8_stride , 1 , 1 , 0 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int rv34_decode_mv ( RV34DecContext * r , int block_type ) {\n"
                ],
                [
                    7,
                    " memset ( r -> dmv , 0 , sizeof ( r -> dmv ) ) ;\n"
                ],
                [
                    19,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n"
                ],
                [
                    36,
                    " l ++ ) s -> current_picture_ptr -> f . motion_val [ l ] [ mv_pos + i + j * s -> b8_stride ] [ k ] = calc_add_mv ( r , l , s -> next_picture_ptr -> f . motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ k ] ) ;\n"
                ],
                [
                    37,
                    " if ( ! ( IS_16X8 ( next_bt ) || IS_8X16 ( next_bt ) || IS_8X8 ( next_bt ) ) ) rv34_mc_2mv ( r , block_type ) ;\n"
                ],
                [
                    38,
                    " else rv34_mc_2mv_skip ( r ) ;\n"
                ],
                [
                    41,
                    " case RV34_MB_P_16x16 : case RV34_MB_P_MIX16x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n"
                ],
                [
                    42,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n"
                ],
                [
                    46,
                    " if ( r -> rv30 ) rv34_pred_mv_rv3 ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n"
                ],
                [
                    47,
                    " else rv34_pred_mv_b ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n"
                ],
                [
                    48,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , block_type == RV34_MB_B_BACKWARD ) ;\n"
                ],
                [
                    50,
                    " case RV34_MB_P_16x8 : case RV34_MB_P_8x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n"
                ],
                [
                    51,
                    " rv34_pred_mv ( r , block_type , 1 + ( block_type == RV34_MB_P_16x8 ) , 1 ) ;\n"
                ],
                [
                    53,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 1 , 0 ) ;\n"
                ],
                [
                    54,
                    " rv34_mc_1mv ( r , block_type , 0 , 8 , s -> b8_stride , 2 , 1 , 0 ) ;\n"
                ],
                [
                    57,
                    " rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 1 , 2 , 0 ) ;\n"
                ],
                [
                    58,
                    " rv34_mc_1mv ( r , block_type , 8 , 0 , 1 , 1 , 2 , 0 ) ;\n"
                ],
                [
                    61,
                    " case RV34_MB_B_BIDIR : rv34_pred_mv_b ( r , block_type , 0 ) ;\n"
                ],
                [
                    62,
                    " rv34_pred_mv_b ( r , block_type , 1 ) ;\n"
                ],
                [
                    63,
                    " rv34_mc_2mv ( r , block_type ) ;\n"
                ],
                [
                    68,
                    " rv34_pred_mv ( r , block_type , i , i ) ;\n"
                ],
                [
                    69,
                    " rv34_mc_1mv ( r , block_type , ( i & 1 ) << 3 , ( i & 2 ) << 2 , ( i & 1 ) + ( i >> 1 ) * s -> b8_stride , 1 , 1 , 0 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int rv34_decode_inter_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n uint8_t * dst = s -> dest [ 0 ] ;\n int16_t * ptr = s -> block [ 0 ] ;\n int mb_pos = s -> mb_x + s -> mb_y * s -> mb_stride ;\n int cbp , cbp2 ;\n int q_dc , q_ac , has_ac ;\n int i , j ;\n int dist ;\n memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n dist = ( s -> mb_x - s -> resync_mb_x ) + ( s -> mb_y - s -> resync_mb_y ) * s -> mb_width ;\n if ( s -> mb_x && dist ) r -> avail_cache [ 5 ] = r -> avail_cache [ 9 ] = s -> current_picture_ptr -> f . mb_type [ mb_pos - 1 ] ;\n if ( dist >= s -> mb_width ) r -> avail_cache [ 2 ] = r -> avail_cache [ 3 ] = s -> current_picture_ptr -> f . mb_type [ mb_pos - s -> mb_stride ] ;\n if ( ( ( s -> mb_x + 1 ) < s -> mb_width ) && dist >= s -> mb_width - 1 ) r -> avail_cache [ 4 ] = s -> current_picture_ptr -> f . mb_type [ mb_pos - s -> mb_stride + 1 ] ;\n if ( s -> mb_x && dist > s -> mb_width ) r -> avail_cache [ 1 ] = s -> current_picture_ptr -> f . mb_type [ mb_pos - s -> mb_stride - 1 ] ;\n s -> qscale = r -> si . quant ;\n cbp = cbp2 = rv34_decode_inter_mb_header ( r , intra_types ) ;\n r -> cbp_luma [ mb_pos ] = cbp ;\n r -> cbp_chroma [ mb_pos ] = cbp >> 16 ;\n r -> deblock_coefs [ mb_pos ] = rv34_set_deblock_coef ( r ) | r -> cbp_luma [ mb_pos ] ;\n s -> current_picture_ptr -> f . qscale_table [ mb_pos ] = s -> qscale ;\n if ( cbp == - 1 ) return - 1 ;\n if ( IS_INTRA ( s -> current_picture_ptr -> f . mb_type [ mb_pos ] ) ) {\n if ( r -> is16 ) rv34_output_i16x16 ( r , intra_types , cbp ) ;\n else rv34_output_intra ( r , intra_types , cbp ) ;\n return 0 ;\n }\n if ( r -> is16 ) {\n LOCAL_ALIGNED_16 ( int16_t , block16 , [ 16 ] ) ;\n memset ( block16 , 0 , 16 * sizeof ( * block16 ) ) ;\n q_dc = rv34_qscale_tab [ r -> luma_dc_quant_p [ s -> qscale ] ] ;\n q_ac = rv34_qscale_tab [ s -> qscale ] ;\n if ( rv34_decode_block ( block16 , gb , r -> cur_vlcs , 3 , 0 , q_dc , q_dc , q_ac ) ) r -> rdsp . rv34_inv_transform ( block16 ) ;\n else r -> rdsp . rv34_inv_transform_dc ( block16 ) ;\n q_ac = rv34_qscale_tab [ s -> qscale ] ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ , cbp >>= 1 ) {\n int dc = block16 [ i + j * 4 ] ;\n if ( cbp & 1 ) {\n has_ac = rv34_decode_block ( ptr , gb , r -> cur_vlcs , r -> luma_vlc , 0 , q_ac , q_ac , q_ac ) ;\n }\n else has_ac = 0 ;\n if ( has_ac ) {\n ptr [ 0 ] = dc ;\n r -> rdsp . rv34_idct_add ( dst + 4 * i , s -> linesize , ptr ) ;\n }\n else r -> rdsp . rv34_idct_dc_add ( dst + 4 * i , s -> linesize , dc ) ;\n }\n dst += 4 * s -> linesize ;\n }\n r -> cur_vlcs = choose_vlc_set ( r -> si . quant , r -> si . vlc_set , 1 ) ;\n }\n else {\n q_ac = rv34_qscale_tab [ s -> qscale ] ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ , cbp >>= 1 ) {\n if ( ! ( cbp & 1 ) ) continue ;\n rv34_process_block ( r , dst + 4 * i , s -> linesize , r -> luma_vlc , 0 , q_ac , q_ac ) ;\n }\n dst += 4 * s -> linesize ;\n }\n }\n q_dc = rv34_qscale_tab [ rv34_chroma_quant [ 1 ] [ s -> qscale ] ] ;\n q_ac = rv34_qscale_tab [ rv34_chroma_quant [ 0 ] [ s -> qscale ] ] ;\n for ( j = 1 ;\n j < 3 ;\n j ++ ) {\n dst = s -> dest [ j ] ;\n for ( i = 0 ;\n i < 4 ;\n i ++ , cbp >>= 1 ) {\n uint8_t * pdst ;\n if ( ! ( cbp & 1 ) ) continue ;\n pdst = dst + ( i & 1 ) * 4 + ( i & 2 ) * 2 * s -> uvlinesize ;\n rv34_process_block ( r , pdst , s -> uvlinesize , r -> chroma_vlc , 1 , q_dc , q_ac ) ;\n }\n }\n return 0 ;\n }",
        "hash": 2335222688263906532,
        "project": "debian",
        "size": 89,
        "slice": {
            "memset": [
                [
                    1,
                    "static int rv34_decode_inter_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n"
                ],
                [
                    11,
                    " memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n"
                ],
                [
                    12,
                    " fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n"
                ],
                [
                    19,
                    " cbp = cbp2 = rv34_decode_inter_mb_header ( r , intra_types ) ;\n"
                ],
                [
                    22,
                    " r -> deblock_coefs [ mb_pos ] = rv34_set_deblock_coef ( r ) | r -> cbp_luma [ mb_pos ] ;\n"
                ],
                [
                    26,
                    " if ( r -> is16 ) rv34_output_i16x16 ( r , intra_types , cbp ) ;\n"
                ],
                [
                    27,
                    " else rv34_output_intra ( r , intra_types , cbp ) ;\n"
                ],
                [
                    30,
                    " if ( r -> is16 ) {\n"
                ],
                [
                    32,
                    " memset ( block16 , 0 , 16 * sizeof ( * block16 ) ) ;\n"
                ],
                [
                    35,
                    " if ( rv34_decode_block ( block16 , gb , r -> cur_vlcs , 3 , 0 , q_dc , q_dc , q_ac ) ) r -> rdsp . rv34_inv_transform ( block16 ) ;\n"
                ],
                [
                    68,
                    " rv34_process_block ( r , dst + 4 * i , s -> linesize , r -> luma_vlc , 0 , q_ac , q_ac ) ;\n"
                ],
                [
                    85,
                    " rv34_process_block ( r , pdst , s -> uvlinesize , r -> chroma_vlc , 1 , q_dc , q_ac ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int rv34_decode_inter_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n"
                ],
                [
                    11,
                    " memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n"
                ],
                [
                    12,
                    " fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n"
                ],
                [
                    19,
                    " cbp = cbp2 = rv34_decode_inter_mb_header ( r , intra_types ) ;\n"
                ],
                [
                    22,
                    " r -> deblock_coefs [ mb_pos ] = rv34_set_deblock_coef ( r ) | r -> cbp_luma [ mb_pos ] ;\n"
                ],
                [
                    26,
                    " if ( r -> is16 ) rv34_output_i16x16 ( r , intra_types , cbp ) ;\n"
                ],
                [
                    27,
                    " else rv34_output_intra ( r , intra_types , cbp ) ;\n"
                ],
                [
                    30,
                    " if ( r -> is16 ) {\n"
                ],
                [
                    32,
                    " memset ( block16 , 0 , 16 * sizeof ( * block16 ) ) ;\n"
                ],
                [
                    35,
                    " if ( rv34_decode_block ( block16 , gb , r -> cur_vlcs , 3 , 0 , q_dc , q_dc , q_ac ) ) r -> rdsp . rv34_inv_transform ( block16 ) ;\n"
                ],
                [
                    68,
                    " rv34_process_block ( r , dst + 4 * i , s -> linesize , r -> luma_vlc , 0 , q_ac , q_ac ) ;\n"
                ],
                [
                    85,
                    " rv34_process_block ( r , pdst , s -> uvlinesize , r -> chroma_vlc , 1 , q_dc , q_ac ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int rv34_decode_slice ( RV34DecContext * r , int end , const uint8_t * buf , int buf_size ) {\n MpegEncContext * s = & r -> s ;\n GetBitContext * gb = & s -> gb ;\n int mb_pos , slice_type ;\n int res ;\n init_get_bits ( & r -> s . gb , buf , buf_size * 8 ) ;\n res = r -> parse_slice_header ( r , gb , & r -> si ) ;\n if ( res < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Incorrect or unknown slice header\\n\" ) ;\n return - 1 ;\n }\n slice_type = r -> si . type ? r -> si . type : AV_PICTURE_TYPE_I ;\n if ( slice_type != s -> pict_type ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Slice type mismatch\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n r -> si . end = end ;\n s -> qscale = r -> si . quant ;\n s -> mb_num_left = r -> si . end - r -> si . start ;\n r -> s . mb_skip_run = 0 ;\n mb_pos = s -> mb_x + s -> mb_y * s -> mb_width ;\n if ( r -> si . start != mb_pos ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Slice indicates MB offset %d, got %d\\n\" , r -> si . start , mb_pos ) ;\n s -> mb_x = r -> si . start % s -> mb_width ;\n s -> mb_y = r -> si . start / s -> mb_width ;\n }\n memset ( r -> intra_types_hist , - 1 , r -> intra_types_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ;\n s -> first_slice_line = 1 ;\n s -> resync_mb_x = s -> mb_x ;\n s -> resync_mb_y = s -> mb_y ;\n ff_init_block_index ( s ) ;\n while ( ! check_slice_end ( r , s ) ) {\n ff_update_block_index ( s ) ;\n if ( r -> si . type ) res = rv34_decode_inter_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n else res = rv34_decode_intra_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n if ( res < 0 ) {\n ff_er_add_slice ( & s -> er , s -> resync_mb_x , s -> resync_mb_y , s -> mb_x - 1 , s -> mb_y , ER_MB_ERROR ) ;\n return - 1 ;\n }\n if ( ++ s -> mb_x == s -> mb_width ) {\n s -> mb_x = 0 ;\n s -> mb_y ++ ;\n ff_init_block_index ( s ) ;\n memmove ( r -> intra_types_hist , r -> intra_types , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n memset ( r -> intra_types , - 1 , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n if ( r -> loop_filter && s -> mb_y >= 2 ) r -> loop_filter ( r , s -> mb_y - 2 ) ;\n if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) ff_thread_report_progress ( & s -> current_picture_ptr -> f , s -> mb_y - 2 , 0 ) ;\n }\n if ( s -> mb_x == s -> resync_mb_x ) s -> first_slice_line = 0 ;\n s -> mb_num_left -- ;\n }\n ff_er_add_slice ( & s -> er , s -> resync_mb_x , s -> resync_mb_y , s -> mb_x - 1 , s -> mb_y , ER_MB_END ) ;\n return s -> mb_y == s -> mb_height ;\n }",
        "hash": 2335222688263906532,
        "project": "debian",
        "size": 54,
        "slice": {
            "memmove": [
                [
                    27,
                    " memset ( r -> intra_types_hist , - 1 , r -> intra_types_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    32,
                    " while ( ! check_slice_end ( r , s ) ) {\n"
                ],
                [
                    34,
                    " if ( r -> si . type ) res = rv34_decode_inter_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n"
                ],
                [
                    35,
                    " else res = rv34_decode_intra_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n"
                ],
                [
                    40,
                    " if ( ++ s -> mb_x == s -> mb_width ) {\n"
                ],
                [
                    44,
                    " memmove ( r -> intra_types_hist , r -> intra_types , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    45,
                    " memset ( r -> intra_types , - 1 , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    46,
                    " if ( r -> loop_filter && s -> mb_y >= 2 ) r -> loop_filter ( r , s -> mb_y - 2 ) ;\n"
                ]
            ],
            "memset": [
                [
                    7,
                    " res = r -> parse_slice_header ( r , gb , & r -> si ) ;\n"
                ],
                [
                    13,
                    " if ( slice_type != s -> pict_type ) {\n"
                ],
                [
                    27,
                    " memset ( r -> intra_types_hist , - 1 , r -> intra_types_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    32,
                    " while ( ! check_slice_end ( r , s ) ) {\n"
                ],
                [
                    34,
                    " if ( r -> si . type ) res = rv34_decode_inter_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n"
                ],
                [
                    35,
                    " else res = rv34_decode_intra_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n"
                ],
                [
                    40,
                    " if ( ++ s -> mb_x == s -> mb_width ) {\n"
                ],
                [
                    44,
                    " memmove ( r -> intra_types_hist , r -> intra_types , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    45,
                    " memset ( r -> intra_types , - 1 , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    46,
                    " if ( r -> loop_filter && s -> mb_y >= 2 ) r -> loop_filter ( r , s -> mb_y - 2 ) ;\n"
                ]
            ],
            "result": [
                [
                    7,
                    " res = r -> parse_slice_header ( r , gb , & r -> si ) ;\n"
                ],
                [
                    13,
                    " if ( slice_type != s -> pict_type ) {\n"
                ],
                [
                    27,
                    " memset ( r -> intra_types_hist , - 1 , r -> intra_types_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    32,
                    " while ( ! check_slice_end ( r , s ) ) {\n"
                ],
                [
                    34,
                    " if ( r -> si . type ) res = rv34_decode_inter_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n"
                ],
                [
                    35,
                    " else res = rv34_decode_intra_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n"
                ],
                [
                    40,
                    " if ( ++ s -> mb_x == s -> mb_width ) {\n"
                ],
                [
                    44,
                    " memmove ( r -> intra_types_hist , r -> intra_types , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    45,
                    " memset ( r -> intra_types , - 1 , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n"
                ],
                [
                    46,
                    " if ( r -> loop_filter && s -> mb_y >= 2 ) r -> loop_filter ( r , s -> mb_y - 2 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n BMVDecContext * const c = avctx -> priv_data ;\n int type , scr_off ;\n int i , ret ;\n uint8_t * srcptr , * outptr ;\n c -> stream = pkt -> data ;\n type = bytestream_get_byte ( & c -> stream ) ;\n if ( type & BMV_AUDIO ) {\n int blobs = bytestream_get_byte ( & c -> stream ) ;\n if ( pkt -> size < blobs * 65 + 2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Audio data doesn't fit in frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> stream += blobs * 65 ;\n }\n if ( type & BMV_COMMAND ) {\n int command_size = ( type & BMV_PRINT ) ? 8 : 10 ;\n if ( c -> stream - pkt -> data + command_size > pkt -> size ) {\n av_log ( avctx , AV_LOG_ERROR , \"Command data doesn't fit in frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n c -> stream += command_size ;\n }\n if ( type & BMV_PALETTE ) {\n if ( c -> stream - pkt -> data > pkt -> size - 768 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Palette data doesn't fit in frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < 256 ;\n i ++ ) c -> pal [ i ] = bytestream_get_be24 ( & c -> stream ) ;\n }\n if ( type & BMV_SCROLL ) {\n if ( c -> stream - pkt -> data > pkt -> size - 2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Screen offset data doesn't fit in frame\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n scr_off = ( int16_t ) bytestream_get_le16 ( & c -> stream ) ;\n }\n else if ( ( type & BMV_INTRA ) == BMV_INTRA ) {\n scr_off = - 640 ;\n }\n else {\n scr_off = 0 ;\n }\n if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n c -> pic . reference = 3 ;\n if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( decode_bmv_frame ( c -> stream , pkt -> size - ( c -> stream - pkt -> data ) , c -> frame , scr_off ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding frame data\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n c -> pic . palette_has_changed = type & BMV_PALETTE ;\n outptr = c -> pic . data [ 0 ] ;\n srcptr = c -> frame ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n memcpy ( outptr , srcptr , avctx -> width ) ;\n srcptr += avctx -> width ;\n outptr += c -> pic . linesize [ 0 ] ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = c -> pic ;\n return pkt -> size ;\n }",
        "hash": 7017429767411016590,
        "project": "debian",
        "size": 70,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n"
                ],
                [
                    2,
                    " BMVDecContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    31,
                    " i ++ ) c -> pal [ i ] = bytestream_get_be24 ( & c -> stream ) ;\n"
                ],
                [
                    48,
                    " if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n"
                ],
                [
                    52,
                    " if ( decode_bmv_frame ( c -> stream , pkt -> size - ( c -> stream - pkt -> data ) , c -> frame , scr_off ) ) {\n"
                ],
                [
                    56,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    58,
                    " outptr = c -> pic . data [ 0 ] ;\n"
                ],
                [
                    59,
                    " srcptr = c -> frame ;\n"
                ],
                [
                    61,
                    " i < avctx -> height ;\n"
                ],
                [
                    63,
                    " memcpy ( outptr , srcptr , avctx -> width ) ;\n"
                ],
                [
                    64,
                    " srcptr += avctx -> width ;\n"
                ],
                [
                    65,
                    " outptr += c -> pic . linesize [ 0 ] ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n"
                ],
                [
                    2,
                    " BMVDecContext * const c = avctx -> priv_data ;\n"
                ],
                [
                    31,
                    " i ++ ) c -> pal [ i ] = bytestream_get_be24 ( & c -> stream ) ;\n"
                ],
                [
                    48,
                    " if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n"
                ],
                [
                    52,
                    " if ( decode_bmv_frame ( c -> stream , pkt -> size - ( c -> stream - pkt -> data ) , c -> frame , scr_off ) ) {\n"
                ],
                [
                    56,
                    " memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n"
                ],
                [
                    58,
                    " outptr = c -> pic . data [ 0 ] ;\n"
                ],
                [
                    59,
                    " srcptr = c -> frame ;\n"
                ],
                [
                    61,
                    " i < avctx -> height ;\n"
                ],
                [
                    63,
                    " memcpy ( outptr , srcptr , avctx -> width ) ;\n"
                ],
                [
                    64,
                    " srcptr += avctx -> width ;\n"
                ],
                [
                    65,
                    " outptr += c -> pic . linesize [ 0 ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int cinvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n CinVideoContext * cin = avctx -> priv_data ;\n int i , y , palette_type , palette_colors_count , bitmap_frame_type , bitmap_frame_size , res = 0 ;\n palette_type = buf [ 0 ] ;\n palette_colors_count = AV_RL16 ( buf + 1 ) ;\n bitmap_frame_type = buf [ 3 ] ;\n buf += 4 ;\n bitmap_frame_size = buf_size - 4 ;\n if ( bitmap_frame_size < palette_colors_count * ( 3 + ( palette_type != 0 ) ) ) return AVERROR_INVALIDDATA ;\n if ( palette_type == 0 ) {\n if ( palette_colors_count > 256 ) return AVERROR_INVALIDDATA ;\n for ( i = 0 ;\n i < palette_colors_count ;\n ++ i ) {\n cin -> palette [ i ] = bytestream_get_le24 ( & buf ) ;\n bitmap_frame_size -= 3 ;\n }\n }\n else {\n for ( i = 0 ;\n i < palette_colors_count ;\n ++ i ) {\n cin -> palette [ buf [ 0 ] ] = AV_RL24 ( buf + 1 ) ;\n buf += 4 ;\n bitmap_frame_size -= 4 ;\n }\n }\n switch ( bitmap_frame_type ) {\n case 9 : cin_decode_rle ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 34 : cin_decode_rle ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 35 : cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_INT_BMP ] , cin -> bitmap_size ) ;\n cin_decode_rle ( cin -> bitmap_table [ CIN_INT_BMP ] , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 36 : bitmap_frame_size = cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_INT_BMP ] , cin -> bitmap_size ) ;\n cin_decode_rle ( cin -> bitmap_table [ CIN_INT_BMP ] , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 37 : cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n case 38 : res = cin_decode_lzss ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n if ( res < 0 ) return res ;\n break ;\n case 39 : res = cin_decode_lzss ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n if ( res < 0 ) return res ;\n cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n break ;\n }\n cin -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( avctx -> reget_buffer ( avctx , & cin -> frame ) ) {\n av_log ( cin -> avctx , AV_LOG_ERROR , \"delphinecinvideo: reget_buffer() failed to allocate a frame\\n\" ) ;\n return - 1 ;\n }\n memcpy ( cin -> frame . data [ 1 ] , cin -> palette , sizeof ( cin -> palette ) ) ;\n cin -> frame . palette_has_changed = 1 ;\n for ( y = 0 ;\n y < cin -> avctx -> height ;\n ++ y ) memcpy ( cin -> frame . data [ 0 ] + ( cin -> avctx -> height - 1 - y ) * cin -> frame . linesize [ 0 ] , cin -> bitmap_table [ CIN_CUR_BMP ] + y * cin -> avctx -> width , cin -> avctx -> width ) ;\n FFSWAP ( uint8_t * , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_table [ CIN_PRE_BMP ] ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = cin -> frame ;\n return buf_size ;\n }",
        "hash": 5750382823403258531,
        "project": "debian",
        "size": 67,
        "slice": {
            "memcpy": [
                [
                    4,
                    " CinVideoContext * cin = avctx -> priv_data ;\n"
                ],
                [
                    17,
                    " cin -> palette [ i ] = bytestream_get_le24 ( & buf ) ;\n"
                ],
                [
                    25,
                    " cin -> palette [ buf [ 0 ] ] = AV_RL24 ( buf + 1 ) ;\n"
                ],
                [
                    31,
                    " case 9 : cin_decode_rle ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    34,
                    " cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    37,
                    " cin_decode_rle ( cin -> bitmap_table [ CIN_INT_BMP ] , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    41,
                    " cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    43,
                    " case 37 : cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    45,
                    " case 38 : res = cin_decode_lzss ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    50,
                    " cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    54,
                    " if ( avctx -> reget_buffer ( avctx , & cin -> frame ) ) {\n"
                ],
                [
                    58,
                    " memcpy ( cin -> frame . data [ 1 ] , cin -> palette , sizeof ( cin -> palette ) ) ;\n"
                ],
                [
                    61,
                    " y < cin -> avctx -> height ;\n"
                ],
                [
                    62,
                    " ++ y ) memcpy ( cin -> frame . data [ 0 ] + ( cin -> avctx -> height - 1 - y ) * cin -> frame . linesize [ 0 ] , cin -> bitmap_table [ CIN_CUR_BMP ] + y * cin -> avctx -> width , cin -> avctx -> width ) ;\n"
                ]
            ],
            "result": [
                [
                    4,
                    " CinVideoContext * cin = avctx -> priv_data ;\n"
                ],
                [
                    17,
                    " cin -> palette [ i ] = bytestream_get_le24 ( & buf ) ;\n"
                ],
                [
                    25,
                    " cin -> palette [ buf [ 0 ] ] = AV_RL24 ( buf + 1 ) ;\n"
                ],
                [
                    31,
                    " case 9 : cin_decode_rle ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    34,
                    " cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    37,
                    " cin_decode_rle ( cin -> bitmap_table [ CIN_INT_BMP ] , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    41,
                    " cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    43,
                    " case 37 : cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    45,
                    " case 38 : res = cin_decode_lzss ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    50,
                    " cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n"
                ],
                [
                    54,
                    " if ( avctx -> reget_buffer ( avctx , & cin -> frame ) ) {\n"
                ],
                [
                    58,
                    " memcpy ( cin -> frame . data [ 1 ] , cin -> palette , sizeof ( cin -> palette ) ) ;\n"
                ],
                [
                    61,
                    " y < cin -> avctx -> height ;\n"
                ],
                [
                    62,
                    " ++ y ) memcpy ( cin -> frame . data [ 0 ] + ( cin -> avctx -> height - 1 - y ) * cin -> frame . linesize [ 0 ] , cin -> bitmap_table [ CIN_CUR_BMP ] + y * cin -> avctx -> width , cin -> avctx -> width ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void h245_setup_channels ( packet_info * pinfo , channel_info_t * upcoming_channel_lcl ) {\n gint * key ;\n GHashTable * rtp_dyn_payload = NULL ;\n struct srtp_info * dummy_srtp_info = NULL ;\n if ( ! upcoming_channel_lcl ) return ;\n if ( ! strcmp ( upcoming_channel_lcl -> data_type_str , \"t38fax\" ) ) {\n if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n t38_add_address ( pinfo , & upcoming_channel_lcl -> media_addr . addr , upcoming_channel_lcl -> media_addr . port , 0 , \"H245\" , pinfo -> fd -> num ) ;\n }\n return ;\n }\n if ( upcoming_channel_lcl -> rfc2198 > 0 ) {\n encoding_name_and_rate_t * encoding_name_and_rate = wmem_new ( wmem_file_scope ( ) , encoding_name_and_rate_t ) ;\n rtp_dyn_payload = g_hash_table_new ( g_int_hash , g_int_equal ) ;\n encoding_name_and_rate -> encoding_name = wmem_strdup ( wmem_file_scope ( ) , \"red\" ) ;\n encoding_name_and_rate -> sample_rate = 8000 ;\n key = wmem_new ( wmem_file_scope ( ) , gint ) ;\n * key = upcoming_channel_lcl -> rfc2198 ;\n g_hash_table_insert ( rtp_dyn_payload , key , encoding_name_and_rate ) ;\n }\n if ( upcoming_channel_lcl -> srtp_flag ) {\n dummy_srtp_info = wmem_new0 ( wmem_file_scope ( ) , struct srtp_info ) ;\n }\n if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n srtp_add_address ( pinfo , & upcoming_channel_lcl -> media_addr . addr , upcoming_channel_lcl -> media_addr . port , 0 , \"H245\" , pinfo -> fd -> num , upcoming_channel_lcl -> is_video , rtp_dyn_payload , dummy_srtp_info ) ;\n }\n if ( upcoming_channel_lcl -> media_control_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_control_addr . port != 0 && rtcp_handle ) {\n srtcp_add_address ( pinfo , & upcoming_channel_lcl -> media_control_addr . addr , upcoming_channel_lcl -> media_control_addr . port , 0 , \"H245\" , pinfo -> fd -> num , dummy_srtp_info ) ;\n }\n }",
        "hash": -4719501675862910941,
        "project": "debian",
        "size": 30,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static void h245_setup_channels ( packet_info * pinfo , channel_info_t * upcoming_channel_lcl ) {\n"
                ],
                [
                    5,
                    " if ( ! upcoming_channel_lcl ) return ;\n"
                ],
                [
                    6,
                    " if ( ! strcmp ( upcoming_channel_lcl -> data_type_str , \"t38fax\" ) ) {\n"
                ],
                [
                    7,
                    " if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n"
                ],
                [
                    10,
                    " return ;\n"
                ],
                [
                    12,
                    " if ( upcoming_channel_lcl -> rfc2198 > 0 ) {\n"
                ],
                [
                    21,
                    " if ( upcoming_channel_lcl -> srtp_flag ) {\n"
                ],
                [
                    24,
                    " if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n"
                ],
                [
                    27,
                    " if ( upcoming_channel_lcl -> media_control_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_control_addr . port != 0 && rtcp_handle ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void h245_setup_channels ( packet_info * pinfo , channel_info_t * upcoming_channel_lcl ) {\n"
                ],
                [
                    5,
                    " if ( ! upcoming_channel_lcl ) return ;\n"
                ],
                [
                    6,
                    " if ( ! strcmp ( upcoming_channel_lcl -> data_type_str , \"t38fax\" ) ) {\n"
                ],
                [
                    7,
                    " if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n"
                ],
                [
                    10,
                    " return ;\n"
                ],
                [
                    12,
                    " if ( upcoming_channel_lcl -> rfc2198 > 0 ) {\n"
                ],
                [
                    21,
                    " if ( upcoming_channel_lcl -> srtp_flag ) {\n"
                ],
                [
                    24,
                    " if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n"
                ],
                [
                    27,
                    " if ( upcoming_channel_lcl -> media_control_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_control_addr . port != 0 && rtcp_handle ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static void _slurm_rpc_submit_batch_pack_job ( slurm_msg_t * msg ) {\n static int select_serial = - 1 ;\n static int active_rpc_cnt = 0 ;\n ListIterator iter ;\n int error_code = SLURM_SUCCESS , alloc_only = 0 ;\n DEF_TIMERS ;\n uint32_t pack_job_id = 0 , pack_job_offset = 0 ;\n struct job_record * job_ptr = NULL , * first_job_ptr = NULL ;\n slurm_msg_t response_msg ;\n submit_response_msg_t submit_msg ;\n job_desc_msg_t * job_desc_msg ;\n char * script = NULL ;\n slurmctld_lock_t job_read_lock = {\n READ_LOCK , READ_LOCK , READ_LOCK , READ_LOCK , NO_LOCK }\n ;\n slurmctld_lock_t job_write_lock = {\n READ_LOCK , WRITE_LOCK , WRITE_LOCK , READ_LOCK , NO_LOCK }\n ;\n List job_req_list = ( List ) msg -> data ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n uint32_t job_uid = NO_VAL ;\n char * err_msg = NULL , * job_submit_user_msg = NULL ;\n bool reject_job = false ;\n bool is_super_user ;\n List submit_job_list = NULL ;\n hostset_t jobid_hostset = NULL ;\n char tmp_str [ 32 ] ;\n START_TIMER ;\n debug2 ( \"Processing RPC: REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d\" , uid ) ;\n if ( ! job_req_list || ( list_count ( job_req_list ) == 0 ) ) {\n info ( \"REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d with empty job list\" , uid ) ;\n error_code = SLURM_ERROR ;\n reject_job = true ;\n goto send_msg ;\n }\n if ( ! _sched_backfill ( ) ) {\n error_code = ESLURM_NOT_SUPPORTED ;\n reject_job = true ;\n goto send_msg ;\n }\n if ( select_serial == - 1 ) {\n if ( xstrcmp ( slurmctld_conf . select_type , \"select/serial\" ) ) select_serial = 0 ;\n else select_serial = 1 ;\n }\n if ( slurmctld_config . submissions_disabled || ( select_serial == 1 ) ) {\n info ( \"Submissions disabled on system\" ) ;\n error_code = ESLURM_SUBMISSIONS_DISABLED ;\n reject_job = true ;\n goto send_msg ;\n }\n if ( ! job_req_list || ( list_count ( job_req_list ) == 0 ) ) {\n info ( \"REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d with empty job list\" , uid ) ;\n error_code = SLURM_ERROR ;\n reject_job = true ;\n goto send_msg ;\n }\n is_super_user = validate_super_user ( uid ) ;\n lock_slurmctld ( job_read_lock ) ;\n iter = list_iterator_create ( job_req_list ) ;\n while ( ( job_desc_msg = ( job_desc_msg_t * ) list_next ( iter ) ) ) {\n if ( job_uid == NO_VAL ) job_uid = job_desc_msg -> user_id ;\n if ( ( uid != job_desc_msg -> user_id ) && ! is_super_user ) {\n error ( \"Security violation, REQUEST_SUBMIT_BATCH_PACK_JOB from uid=%d\" , uid ) ;\n error_code = ESLURM_USER_ID_MISSING ;\n break ;\n }\n if ( ( job_desc_msg -> alloc_node == NULL ) || ( job_desc_msg -> alloc_node [ 0 ] == '\\0' ) ) {\n error ( \"REQUEST_SUBMIT_BATCH_PACK_JOB lacks alloc_node from uid=%d\" , uid ) ;\n error_code = ESLURM_INVALID_NODE_NAME ;\n break ;\n }\n dump_job_desc ( job_desc_msg ) ;\n job_desc_msg -> pack_job_offset = pack_job_offset ;\n error_code = validate_job_create_req ( job_desc_msg , uid , & err_msg ) ;\n if ( error_code != SLURM_SUCCESS ) {\n reject_job = true ;\n break ;\n }\n if ( err_msg ) {\n char * save_ptr = NULL , * tok ;\n tok = strtok_r ( err_msg , \"\\n\" , & save_ptr ) ;\n while ( tok ) {\n char * sep = \"\" ;\n if ( job_submit_user_msg ) sep = \"\\n\" ;\n xstrfmtcat ( job_submit_user_msg , \"%s%d: %s\" , sep , pack_job_offset , tok ) ;\n tok = strtok_r ( NULL , \"\\n\" , & save_ptr ) ;\n }\n xfree ( err_msg ) ;\n }\n pack_job_offset ++ ;\n }\n list_iterator_destroy ( iter ) ;\n unlock_slurmctld ( job_read_lock ) ;\n if ( error_code != SLURM_SUCCESS ) goto send_msg ;\n if ( err_msg ) job_submit_user_msg = xstrdup ( err_msg ) ;\n submit_job_list = list_create ( NULL ) ;\n pack_job_offset = 0 ;\n _throttle_start ( & active_rpc_cnt ) ;\n lock_slurmctld ( job_write_lock ) ;\n START_TIMER ;\n iter = list_iterator_create ( job_req_list ) ;\n while ( ( job_desc_msg = ( job_desc_msg_t * ) list_next ( iter ) ) ) {\n if ( ! script ) script = xstrdup ( job_desc_msg -> script ) ;\n if ( pack_job_offset && job_desc_msg -> script ) {\n info ( \"%s: Pack job %u offset %u has script, being ignored\" , __func__ , pack_job_id , pack_job_offset ) ;\n xfree ( job_desc_msg -> script ) ;\n }\n if ( pack_job_offset ) {\n job_desc_msg -> mail_type = 0 ;\n xfree ( job_desc_msg -> mail_user ) ;\n }\n if ( ! job_desc_msg -> burst_buffer ) {\n xfree ( job_desc_msg -> script ) ;\n job_desc_msg -> script = bb_g_build_pack_script ( script , pack_job_offset ) ;\n }\n job_desc_msg -> pack_job_offset = pack_job_offset ;\n error_code = job_allocate ( job_desc_msg , job_desc_msg -> immediate , false , NULL , alloc_only , uid , & job_ptr , & err_msg , msg -> protocol_version ) ;\n if ( ! job_ptr || ( error_code && job_ptr -> job_state == JOB_FAILED ) ) {\n reject_job = true ;\n }\n else {\n if ( pack_job_id == 0 ) {\n pack_job_id = job_ptr -> job_id ;\n first_job_ptr = job_ptr ;\n alloc_only = 1 ;\n }\n snprintf ( tmp_str , sizeof ( tmp_str ) , \"%u\" , job_ptr -> job_id ) ;\n if ( jobid_hostset ) hostset_insert ( jobid_hostset , tmp_str ) ;\n else jobid_hostset = hostset_create ( tmp_str ) ;\n job_ptr -> pack_job_id = pack_job_id ;\n job_ptr -> pack_job_offset = pack_job_offset ++ ;\n job_ptr -> batch_flag = 1 ;\n list_append ( submit_job_list , job_ptr ) ;\n }\n if ( job_desc_msg -> immediate && ( error_code != SLURM_SUCCESS ) ) {\n error_code = ESLURM_CAN_NOT_START_IMMEDIATELY ;\n reject_job = true ;\n }\n if ( reject_job ) break ;\n }\n list_iterator_destroy ( iter ) ;\n xfree ( script ) ;\n if ( ( pack_job_id == 0 ) && ! reject_job ) {\n info ( \"%s: No error, but no pack_job_id\" , __func__ ) ;\n error_code = SLURM_ERROR ;\n reject_job = true ;\n }\n if ( ! reject_job && ( accounting_enforce & ACCOUNTING_ENFORCE_LIMITS ) && ! acct_policy_validate_pack ( submit_job_list ) ) {\n info ( \"Pack job %u exceeded association/QOS limit for user %u\" , pack_job_id , job_uid ) ;\n error_code = ESLURM_ACCOUNTING_POLICY ;\n reject_job = true ;\n }\n if ( ! reject_job ) {\n int buf_size = pack_job_offset * 16 ;\n char * tmp_str = xmalloc ( buf_size ) ;\n char * tmp_offset = tmp_str ;\n first_job_ptr -> pack_job_list = submit_job_list ;\n hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n if ( tmp_str [ 0 ] == '[' ) {\n tmp_offset = strchr ( tmp_str , ']' ) ;\n if ( tmp_offset ) tmp_offset [ 0 ] = '\\0' ;\n tmp_offset = tmp_str + 1 ;\n }\n iter = list_iterator_create ( submit_job_list ) ;\n while ( ( job_ptr = ( struct job_record * ) list_next ( iter ) ) ) {\n job_ptr -> pack_job_id_set = xstrdup ( tmp_offset ) ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_HETERO_JOBS ) {\n char buf [ JBUFSIZ ] ;\n info ( \"Submit %s\" , jobid2fmt ( job_ptr , buf , sizeof ( buf ) ) ) ;\n }\n }\n list_iterator_destroy ( iter ) ;\n xfree ( tmp_str ) ;\n }\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n send_msg : END_TIMER2 ( \"_slurm_rpc_submit_batch_pack_job\" ) ;\n if ( reject_job ) {\n info ( \"%s: %s\" , __func__ , slurm_strerror ( error_code ) ) ;\n if ( err_msg ) slurm_send_rc_err_msg ( msg , error_code , err_msg ) ;\n else slurm_send_rc_msg ( msg , error_code ) ;\n if ( submit_job_list ) {\n ( void ) list_for_each ( submit_job_list , _pack_job_cancel , NULL ) ;\n if ( first_job_ptr ) first_job_ptr -> pack_job_list = submit_job_list ;\n else FREE_NULL_LIST ( submit_job_list ) ;\n }\n }\n else {\n info ( \"%s: JobId=%u %s\" , __func__ , pack_job_id , TIME_STR ) ;\n submit_msg . job_id = pack_job_id ;\n submit_msg . step_id = SLURM_BATCH_SCRIPT ;\n submit_msg . error_code = error_code ;\n submit_msg . job_submit_user_msg = job_submit_user_msg ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . conn = msg -> conn ;\n response_msg . msg_type = RESPONSE_SUBMIT_BATCH_JOB ;\n response_msg . data = & submit_msg ;\n slurm_send_node_msg ( msg -> conn_fd , & response_msg ) ;\n schedule_job_save ( ) ;\n }\n if ( jobid_hostset ) hostset_destroy ( jobid_hostset ) ;\n xfree ( err_msg ) ;\n xfree ( job_submit_user_msg ) ;\n }",
        "hash": -1672864273235910388,
        "project": "debian",
        "size": 206,
        "slice": {
            "strchr": [
                [
                    1,
                    "static void _slurm_rpc_submit_batch_pack_job ( slurm_msg_t * msg ) {\n"
                ],
                [
                    158,
                    " hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n"
                ],
                [
                    159,
                    " if ( tmp_str [ 0 ] == '[' ) {\n"
                ],
                [
                    160,
                    " tmp_offset = strchr ( tmp_str , ']' ) ;\n"
                ],
                [
                    162,
                    " tmp_offset = tmp_str + 1 ;\n"
                ],
                [
                    173,
                    " xfree ( tmp_str ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void _slurm_rpc_submit_batch_pack_job ( slurm_msg_t * msg ) {\n"
                ],
                [
                    158,
                    " hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n"
                ],
                [
                    159,
                    " if ( tmp_str [ 0 ] == '[' ) {\n"
                ],
                [
                    160,
                    " tmp_offset = strchr ( tmp_str , ']' ) ;\n"
                ],
                [
                    162,
                    " tmp_offset = tmp_str + 1 ;\n"
                ],
                [
                    173,
                    " xfree ( tmp_str ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void _slurm_rpc_allocate_pack ( slurm_msg_t * msg ) {\n static int select_serial = - 1 ;\n static int active_rpc_cnt = 0 ;\n int error_code = SLURM_SUCCESS , inx , pack_cnt = - 1 ;\n DEF_TIMERS ;\n job_desc_msg_t * job_desc_msg ;\n List job_req_list = ( List ) msg -> data ;\n slurmctld_lock_t job_write_lock = {\n READ_LOCK , WRITE_LOCK , WRITE_LOCK , READ_LOCK , READ_LOCK }\n ;\n uid_t uid = g_slurm_auth_get_uid ( msg -> auth_cred , slurmctld_config . auth_info ) ;\n uint32_t job_uid = NO_VAL ;\n struct job_record * job_ptr , * first_job_ptr = NULL ;\n char * err_msg = NULL , * * job_submit_user_msg = NULL ;\n ListIterator iter ;\n bool priv_user ;\n List submit_job_list = NULL ;\n uint32_t pack_job_id = 0 , pack_job_offset = 0 ;\n hostset_t jobid_hostset = NULL ;\n char tmp_str [ 32 ] ;\n List resp = NULL ;\n slurm_addr_t resp_addr ;\n char resp_host [ 16 ] ;\n uint16_t port ;\n START_TIMER ;\n if ( select_serial == - 1 ) {\n if ( xstrcmp ( slurmctld_conf . select_type , \"select/serial\" ) ) select_serial = 0 ;\n else select_serial = 1 ;\n }\n if ( slurmctld_config . submissions_disabled || ( select_serial == 1 ) ) {\n info ( \"Submissions disabled on system\" ) ;\n error_code = ESLURM_SUBMISSIONS_DISABLED ;\n goto send_msg ;\n }\n if ( ! _sched_backfill ( ) ) {\n error_code = ESLURM_NOT_SUPPORTED ;\n goto send_msg ;\n }\n if ( ! job_req_list || ( list_count ( job_req_list ) == 0 ) ) {\n info ( \"REQUEST_JOB_PACK_ALLOCATION from uid=%d with empty job list\" , uid ) ;\n error_code = SLURM_ERROR ;\n goto send_msg ;\n }\n if ( slurm_get_peer_addr ( msg -> conn_fd , & resp_addr ) == 0 ) {\n slurm_get_ip_str ( & resp_addr , & port , resp_host , sizeof ( resp_host ) ) ;\n }\n else {\n info ( \"REQUEST_JOB_PACK_ALLOCATION from uid=%d , can't get peer addr\" , uid ) ;\n error_code = SLURM_ERROR ;\n goto send_msg ;\n }\n debug2 ( \"sched: Processing RPC: REQUEST_JOB_PACK_ALLOCATION from uid=%d\" , uid ) ;\n pack_cnt = list_count ( job_req_list ) ;\n job_submit_user_msg = xmalloc ( sizeof ( char * ) * pack_cnt ) ;\n priv_user = validate_slurm_user ( uid ) ;\n submit_job_list = list_create ( NULL ) ;\n _throttle_start ( & active_rpc_cnt ) ;\n lock_slurmctld ( job_write_lock ) ;\n inx = 0 ;\n iter = list_iterator_create ( job_req_list ) ;\n while ( ( job_desc_msg = ( job_desc_msg_t * ) list_next ( iter ) ) ) {\n if ( job_uid == NO_VAL ) job_uid = job_desc_msg -> user_id ;\n if ( ( uid != job_desc_msg -> user_id ) && ! priv_user ) {\n error_code = ESLURM_USER_ID_MISSING ;\n error ( \"Security violation, REQUEST_JOB_PACK_ALLOCATION from uid=%d\" , uid ) ;\n break ;\n }\n if ( ( job_desc_msg -> alloc_node == NULL ) || ( job_desc_msg -> alloc_node [ 0 ] == '\\0' ) ) {\n error_code = ESLURM_INVALID_NODE_NAME ;\n error ( \"REQUEST_JOB_PACK_ALLOCATION lacks alloc_node from uid=%d\" , uid ) ;\n break ;\n }\n if ( job_desc_msg -> array_inx ) {\n error_code = ESLURM_INVALID_ARRAY ;\n break ;\n }\n if ( job_desc_msg -> immediate ) {\n error_code = ESLURM_CAN_NOT_START_IMMEDIATELY ;\n break ;\n }\n job_desc_msg -> pack_job_offset = pack_job_offset ;\n error_code = validate_job_create_req ( job_desc_msg , uid , & job_submit_user_msg [ inx ++ ] ) ;\n if ( error_code ) break ;\n # if HAVE_ALPS_CRAY if ( allocated_session_in_use ( job_desc_msg ) ) {\n error_code = ESLURM_RESERVATION_BUSY ;\n error ( \"attempt to nest ALPS allocation on %s:%d by uid=%d\" , job_desc_msg -> alloc_node , job_desc_msg -> alloc_sid , uid ) ;\n break ;\n }\n # endif dump_job_desc ( job_desc_msg ) ;\n job_ptr = NULL ;\n if ( ! job_desc_msg -> resp_host ) job_desc_msg -> resp_host = xstrdup ( resp_host ) ;\n if ( pack_job_offset ) {\n job_desc_msg -> mail_type = 0 ;\n xfree ( job_desc_msg -> mail_user ) ;\n }\n job_desc_msg -> pack_job_offset = pack_job_offset ;\n error_code = job_allocate ( job_desc_msg , false , false , NULL , true , uid , & job_ptr , & err_msg , msg -> protocol_version ) ;\n if ( ! job_ptr ) {\n if ( error_code == SLURM_SUCCESS ) error_code = SLURM_ERROR ;\n break ;\n }\n if ( error_code && ( job_ptr -> job_state == JOB_FAILED ) ) break ;\n error_code = SLURM_SUCCESS ;\n if ( pack_job_id == 0 ) {\n pack_job_id = job_ptr -> job_id ;\n first_job_ptr = job_ptr ;\n }\n snprintf ( tmp_str , sizeof ( tmp_str ) , \"%u\" , job_ptr -> job_id ) ;\n if ( jobid_hostset ) hostset_insert ( jobid_hostset , tmp_str ) ;\n else jobid_hostset = hostset_create ( tmp_str ) ;\n job_ptr -> pack_job_id = pack_job_id ;\n job_ptr -> pack_job_offset = pack_job_offset ++ ;\n list_append ( submit_job_list , job_ptr ) ;\n }\n list_iterator_destroy ( iter ) ;\n if ( ( error_code == 0 ) && ( ! first_job_ptr ) ) {\n error ( \"%s: No error, but no pack_job_id\" , __func__ ) ;\n error_code = SLURM_ERROR ;\n }\n if ( ( error_code == SLURM_SUCCESS ) && ( accounting_enforce & ACCOUNTING_ENFORCE_LIMITS ) && ! acct_policy_validate_pack ( submit_job_list ) ) {\n info ( \"Pack job %u exceeded association/QOS limit for user %u\" , pack_job_id , job_uid ) ;\n error_code = ESLURM_ACCOUNTING_POLICY ;\n }\n if ( error_code ) {\n ( void ) list_for_each ( submit_job_list , _pack_job_cancel , NULL ) ;\n if ( first_job_ptr ) first_job_ptr -> pack_job_list = submit_job_list ;\n else FREE_NULL_LIST ( submit_job_list ) ;\n }\n else {\n resource_allocation_response_msg_t * alloc_msg ;\n ListIterator iter ;\n int buf_size = pack_job_offset * 16 ;\n char * tmp_str = xmalloc ( buf_size ) ;\n char * tmp_offset = tmp_str ;\n first_job_ptr -> pack_job_list = submit_job_list ;\n hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n if ( tmp_str [ 0 ] == '[' ) {\n tmp_offset = strchr ( tmp_str , ']' ) ;\n if ( tmp_offset ) tmp_offset [ 0 ] = '\\0' ;\n tmp_offset = tmp_str + 1 ;\n }\n inx = 0 ;\n iter = list_iterator_create ( submit_job_list ) ;\n while ( ( job_ptr = ( struct job_record * ) list_next ( iter ) ) ) {\n job_ptr -> pack_job_id_set = xstrdup ( tmp_offset ) ;\n if ( ! resp ) resp = list_create ( _del_alloc_pack_msg ) ;\n alloc_msg = xmalloc_nz ( sizeof ( resource_allocation_response_msg_t ) ) ;\n _build_alloc_msg ( job_ptr , alloc_msg , error_code , job_submit_user_msg [ inx ++ ] ) ;\n list_append ( resp , alloc_msg ) ;\n if ( slurmctld_conf . debug_flags & DEBUG_FLAG_HETERO_JOBS ) {\n char buf [ BUFSIZ ] ;\n info ( \"Submit %s\" , jobid2fmt ( job_ptr , buf , sizeof ( buf ) ) ) ;\n }\n }\n list_iterator_destroy ( iter ) ;\n xfree ( tmp_str ) ;\n }\n unlock_slurmctld ( job_write_lock ) ;\n _throttle_fini ( & active_rpc_cnt ) ;\n END_TIMER2 ( \"_slurm_rpc_allocate_pack\" ) ;\n if ( resp ) {\n slurm_msg_t response_msg ;\n slurm_msg_t_init ( & response_msg ) ;\n response_msg . conn = msg -> conn ;\n response_msg . flags = msg -> flags ;\n response_msg . protocol_version = msg -> protocol_version ;\n response_msg . msg_type = RESPONSE_JOB_PACK_ALLOCATION ;\n response_msg . data = resp ;\n if ( slurm_send_node_msg ( msg -> conn_fd , & response_msg ) < 0 ) _kill_job_on_msg_fail ( pack_job_id ) ;\n list_destroy ( resp ) ;\n }\n else {\n send_msg : info ( \"%s: %s \" , __func__ , slurm_strerror ( error_code ) ) ;\n if ( err_msg ) slurm_send_rc_err_msg ( msg , error_code , err_msg ) ;\n else slurm_send_rc_msg ( msg , error_code ) ;\n }\n xfree ( err_msg ) ;\n for ( inx = 0 ;\n inx < pack_cnt ;\n inx ++ ) xfree ( job_submit_user_msg [ inx ] ) ;\n xfree ( job_submit_user_msg ) ;\n if ( jobid_hostset ) hostset_destroy ( jobid_hostset ) ;\n schedule_job_save ( ) ;\n }",
        "hash": -1672864273235910388,
        "project": "debian",
        "size": 184,
        "slice": {
            "strchr": [
                [
                    1,
                    "static void _slurm_rpc_allocate_pack ( slurm_msg_t * msg ) {\n"
                ],
                [
                    136,
                    " hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n"
                ],
                [
                    137,
                    " if ( tmp_str [ 0 ] == '[' ) {\n"
                ],
                [
                    138,
                    " tmp_offset = strchr ( tmp_str , ']' ) ;\n"
                ],
                [
                    140,
                    " tmp_offset = tmp_str + 1 ;\n"
                ],
                [
                    156,
                    " xfree ( tmp_str ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void _slurm_rpc_allocate_pack ( slurm_msg_t * msg ) {\n"
                ],
                [
                    136,
                    " hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n"
                ],
                [
                    137,
                    " if ( tmp_str [ 0 ] == '[' ) {\n"
                ],
                [
                    138,
                    " tmp_offset = strchr ( tmp_str , ']' ) ;\n"
                ],
                [
                    140,
                    " tmp_offset = tmp_str + 1 ;\n"
                ],
                [
                    156,
                    " xfree ( tmp_str ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n uint8_t * apphead ;\n usize_t appheadsz ;\n int ret ;\n if ( ! option_use_appheader ) {\n return ;\n }\n ret = xd3_get_appheader ( stream , & apphead , & appheadsz ) ;\n if ( ret != 0 ) {\n return ;\n }\n if ( appheadsz > 0 ) {\n char * start = ( char * ) apphead ;\n char * slash ;\n int place = 0 ;\n char * parsed [ 4 ] ;\n memset ( parsed , 0 , sizeof ( parsed ) ) ;\n while ( ( slash = strchr ( start , '/' ) ) != NULL ) {\n * slash = 0 ;\n parsed [ place ++ ] = start ;\n start = slash + 1 ;\n }\n parsed [ place ++ ] = start ;\n if ( place == 2 || place == 4 ) {\n main_get_appheader_params ( output , parsed , 1 , \"output\" , ifile ) ;\n }\n if ( place == 4 ) {\n main_get_appheader_params ( sfile , parsed + 2 , 0 , \"source\" , ifile ) ;\n }\n }\n option_use_appheader = 0 ;\n return ;\n }",
        "hash": 914926989019402478,
        "project": "debian",
        "size": 33,
        "slice": {
            "memset": [
                [
                    1,
                    "static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n"
                ],
                [
                    12,
                    " if ( appheadsz > 0 ) {\n"
                ],
                [
                    17,
                    " memset ( parsed , 0 , sizeof ( parsed ) ) ;\n"
                ],
                [
                    25,
                    " main_get_appheader_params ( output , parsed , 1 , \"output\" , ifile ) ;\n"
                ],
                [
                    28,
                    " main_get_appheader_params ( sfile , parsed + 2 , 0 , \"source\" , ifile ) ;\n"
                ]
            ],
            "strchr": [
                [
                    1,
                    "static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n"
                ],
                [
                    12,
                    " if ( appheadsz > 0 ) {\n"
                ],
                [
                    13,
                    " char * start = ( char * ) apphead ;\n"
                ],
                [
                    18,
                    " while ( ( slash = strchr ( start , '/' ) ) != NULL ) {\n"
                ],
                [
                    19,
                    " * slash = 0 ;\n"
                ],
                [
                    20,
                    " parsed [ place ++ ] = start ;\n"
                ],
                [
                    21,
                    " start = slash + 1 ;\n"
                ],
                [
                    23,
                    " parsed [ place ++ ] = start ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n"
                ],
                [
                    12,
                    " if ( appheadsz > 0 ) {\n"
                ],
                [
                    13,
                    " char * start = ( char * ) apphead ;\n"
                ],
                [
                    17,
                    " memset ( parsed , 0 , sizeof ( parsed ) ) ;\n"
                ],
                [
                    18,
                    " while ( ( slash = strchr ( start , '/' ) ) != NULL ) {\n"
                ],
                [
                    19,
                    " * slash = 0 ;\n"
                ],
                [
                    20,
                    " parsed [ place ++ ] = start ;\n"
                ],
                [
                    21,
                    " start = slash + 1 ;\n"
                ],
                [
                    23,
                    " parsed [ place ++ ] = start ;\n"
                ],
                [
                    25,
                    " main_get_appheader_params ( output , parsed , 1 , \"output\" , ifile ) ;\n"
                ],
                [
                    28,
                    " main_get_appheader_params ( sfile , parsed + 2 , 0 , \"source\" , ifile ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int test_make_inputs ( xd3_stream * stream , xoff_t * ss_out , xoff_t * ts_out ) {\n usize_t ts = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n usize_t ss = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n uint8_t * buf = ( uint8_t * ) malloc ( ts + ss ) , * sbuf = buf , * tbuf = buf + ss ;\n usize_t sadd = 0 , sadd_max = ( usize_t ) ( ss * TEST_ADD_RATIO ) ;\n FILE * tf = NULL , * sf = NULL ;\n usize_t i , j ;\n int ret ;\n if ( buf == NULL ) {\n return ENOMEM ;\n }\n if ( ( tf = fopen ( TEST_TARGET_FILE , \"w\" ) ) == NULL || ( ss_out != NULL && ( sf = fopen ( TEST_SOURCE_FILE , \"w\" ) ) == NULL ) ) {\n stream -> msg = \"write failed\" ;\n ret = get_errno ( ) ;\n goto failure ;\n }\n if ( ss_out != NULL ) {\n for ( i = 0 ;\n i < ss ;\n ) {\n sbuf [ i ++ ] = ( uint8_t ) mt_random ( & static_mtrand ) ;\n }\n }\n for ( i = 0 ;\n i < ts ;\n ) {\n usize_t left = ts - i ;\n usize_t next = mt_exp_rand ( ( uint32_t ) TEST_ADD_MEAN , ( uint32_t ) TEST_ADD_MAX ) ;\n usize_t add_left = sadd_max - sadd ;\n double add_prob = ( left == 0 ) ? 0 : ( add_left / ( double ) left ) ;\n int do_copy ;\n next = min ( left , next ) ;\n do_copy = ( next > add_left || ( mt_random ( & static_mtrand ) / ( double ) USIZE_T_MAX ) >= add_prob ) ;\n if ( ss_out == NULL ) {\n do_copy &= ( i > 0 ) ;\n }\n else {\n do_copy &= ( ss - next ) > 0 ;\n }\n if ( do_copy ) {\n size_t offset = mt_random ( & static_mtrand ) % ( ( ss_out == NULL ) ? i : ( ss - next ) ) ;\n for ( j = 0 ;\n j < next ;\n j += 1 ) {\n char c = ( ( ss_out == NULL ) ? tbuf : sbuf ) [ offset + j ] ;\n tbuf [ i ++ ] = c ;\n }\n }\n else {\n for ( j = 0 ;\n j < next ;\n j += 1 ) {\n char c = ( char ) mt_random ( & static_mtrand ) ;\n tbuf [ i ++ ] = c ;\n }\n sadd += next ;\n }\n }\n if ( ( fwrite ( tbuf , 1 , ts , tf ) != ts ) || ( ss_out != NULL && ( fwrite ( sbuf , 1 , ss , sf ) != ss ) ) ) {\n stream -> msg = \"write failed\" ;\n ret = get_errno ( ) ;\n goto failure ;\n }\n if ( ( ret = fclose ( tf ) ) || ( ss_out != NULL && ( ret = fclose ( sf ) ) ) ) {\n stream -> msg = \"close failed\" ;\n ret = get_errno ( ) ;\n goto failure ;\n }\n if ( ts_out ) {\n ( * ts_out ) = ts ;\n }\n if ( ss_out ) {\n ( * ss_out ) = ss ;\n }\n failure : free ( buf ) ;\n return ret ;\n }",
        "hash": 7749168290238234888,
        "project": "debian",
        "size": 77,
        "slice": {
            "malloc": [
                [
                    1,
                    "static int test_make_inputs ( xd3_stream * stream , xoff_t * ss_out , xoff_t * ts_out ) {\n"
                ],
                [
                    2,
                    " usize_t ts = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n"
                ],
                [
                    3,
                    " usize_t ss = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n"
                ],
                [
                    4,
                    " uint8_t * buf = ( uint8_t * ) malloc ( ts + ss ) , * sbuf = buf , * tbuf = buf + ss ;\n"
                ],
                [
                    9,
                    " if ( buf == NULL ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static int test_make_inputs ( xd3_stream * stream , xoff_t * ss_out , xoff_t * ts_out ) {\n"
                ],
                [
                    9,
                    " if ( buf == NULL ) {\n"
                ],
                [
                    75,
                    " failure : free ( buf ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int test_make_inputs ( xd3_stream * stream , xoff_t * ss_out , xoff_t * ts_out ) {\n"
                ],
                [
                    2,
                    " usize_t ts = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n"
                ],
                [
                    3,
                    " usize_t ss = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n"
                ],
                [
                    4,
                    " uint8_t * buf = ( uint8_t * ) malloc ( ts + ss ) , * sbuf = buf , * tbuf = buf + ss ;\n"
                ],
                [
                    9,
                    " if ( buf == NULL ) {\n"
                ],
                [
                    75,
                    " failure : free ( buf ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n int ret ;\n int i ;\n uint8_t * buf ;\n if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n return ENOMEM ;\n }\n memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n for ( i = 0 ;\n i < ( 2 << 20 ) ;\n i += 256 ) {\n int j ;\n int off = mt_random ( & static_mtrand ) % 10 ;\n for ( j = 0 ;\n j < 256 ;\n j ++ ) {\n buf [ i + j ] = j + off ;\n }\n }\n if ( SIZEOF_XOFF_T == 4 ) {\n ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;\n if ( ret == XD3_INVALID_INPUT && MSG_IS ( \"decoder file offset overflow\" ) ) {\n ret = 0 ;\n }\n else {\n XPR ( NT XD3_LIB_ERRMSG ( stream , ret ) ) ;\n stream -> msg = \"expected overflow condition\" ;\n ret = XD3_INTERNAL ;\n goto fail ;\n }\n }\n if ( ( ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , << 12 ) ) ) {\n goto fail ;\n }\n fail : free ( buf ) ;\n return ret ;\n }",
        "hash": 7749168290238234888,
        "project": "debian",
        "size": 37,
        "slice": {
            "memset": [
                [
                    1,
                    "static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n"
                ],
                [
                    5,
                    " if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n"
                ],
                [
                    8,
                    " memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n"
                ],
                [
                    21,
                    " ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;\n"
                ],
                [
                    35,
                    " fail : free ( buf ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n"
                ],
                [
                    5,
                    " if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n"
                ],
                [
                    6,
                    " return ENOMEM ;\n"
                ],
                [
                    8,
                    " memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n"
                ],
                [
                    9,
                    " for ( i = 0 ;\n"
                ],
                [
                    10,
                    " i < ( 2 << 20 ) ;\n"
                ],
                [
                    20,
                    " if ( SIZEOF_XOFF_T == 4 ) {\n"
                ],
                [
                    35,
                    " fail : free ( buf ) ;\n"
                ],
                [
                    36,
                    " return ret ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n"
                ],
                [
                    5,
                    " if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n"
                ],
                [
                    8,
                    " memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n"
                ],
                [
                    17,
                    " buf [ i + j ] = j + off ;\n"
                ],
                [
                    21,
                    " ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;\n"
                ],
                [
                    35,
                    " fail : free ( buf ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n"
                ],
                [
                    5,
                    " if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n"
                ],
                [
                    6,
                    " return ENOMEM ;\n"
                ],
                [
                    8,
                    " memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n"
                ],
                [
                    9,
                    " for ( i = 0 ;\n"
                ],
                [
                    10,
                    " i < ( 2 << 20 ) ;\n"
                ],
                [
                    17,
                    " buf [ i + j ] = j + off ;\n"
                ],
                [
                    20,
                    " if ( SIZEOF_XOFF_T == 4 ) {\n"
                ],
                [
                    21,
                    " ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;\n"
                ],
                [
                    35,
                    " fail : free ( buf ) ;\n"
                ],
                [
                    36,
                    " return ret ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int test_string_matching ( xd3_stream * stream , int ignore ) {\n usize_t i ;\n int ret ;\n xd3_config config ;\n char rbuf [ TESTBUFSIZE ] ;\n for ( i = 0 ;\n i < SIZEOF_ARRAY ( match_tests ) ;\n i += 1 ) {\n const string_match_test * test = & match_tests [ i ] ;\n char * rptr = rbuf ;\n usize_t len = ( usize_t ) strlen ( test -> input ) ;\n xd3_free_stream ( stream ) ;\n xd3_init_config ( & config , 0 ) ;\n config . smatch_cfg = XD3_SMATCH_SOFT ;\n config . smatcher_soft . large_look = 4 ;\n config . smatcher_soft . large_step = 4 ;\n config . smatcher_soft . small_look = 4 ;\n config . smatcher_soft . small_chain = 10 ;\n config . smatcher_soft . small_lchain = 10 ;\n config . smatcher_soft . max_lazy = ( test -> flags & SM_LAZY ) ? 10 : 0 ;\n config . smatcher_soft . long_enough = 10 ;\n if ( ( ret = xd3_config_stream ( stream , & config ) ) ) {\n return ret ;\n }\n if ( ( ret = xd3_encode_init_full ( stream ) ) ) {\n return ret ;\n }\n xd3_avail_input ( stream , ( uint8_t * ) test -> input , len ) ;\n if ( ( ret = stream -> smatcher . string_match ( stream ) ) ) {\n return ret ;\n }\n * rptr = 0 ;\n while ( ! xd3_rlist_empty ( & stream -> iopt_used ) ) {\n xd3_rinst * inst = xd3_rlist_pop_front ( & stream -> iopt_used ) ;\n switch ( inst -> type ) {\n case XD3_RUN : * rptr ++ = 'R' ;\n break ;\n case XD3_CPY : * rptr ++ = 'C' ;\n break ;\n default : CHECK ( 0 ) ;\n }\n snprintf_func ( rptr , rbuf + TESTBUFSIZE - rptr , \"%d/%d\" , inst -> pos , inst -> size ) ;\n rptr += strlen ( rptr ) ;\n if ( inst -> type == XD3_CPY ) {\n * rptr ++ = '@' ;\n snprintf_func ( rptr , rbuf + TESTBUFSIZE - rptr , \"%\" Q \"d\" , inst -> addr ) ;\n rptr += strlen ( rptr ) ;\n }\n * rptr ++ = ' ' ;\n xd3_rlist_push_back ( & stream -> iopt_free , inst ) ;\n }\n if ( rptr != rbuf ) {\n rptr -= 1 ;\n * rptr = 0 ;\n }\n if ( strcmp ( rbuf , test -> result ) != 0 ) {\n XPR ( NT \"test %u: expected %s: got %s\" , i , test -> result , rbuf ) ;\n stream -> msg = \"wrong result\" ;\n return XD3_INTERNAL ;\n }\n }\n return 0 ;\n }",
        "hash": 7749168290238234888,
        "project": "debian",
        "size": 63,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int test_string_matching ( xd3_stream * stream , int ignore ) {\n"
                ],
                [
                    7,
                    " i < SIZEOF_ARRAY ( match_tests ) ;\n"
                ],
                [
                    8,
                    " i += 1 ) {\n"
                ],
                [
                    9,
                    " const string_match_test * test = & match_tests [ i ] ;\n"
                ],
                [
                    10,
                    " char * rptr = rbuf ;\n"
                ],
                [
                    29,
                    " if ( ( ret = stream -> smatcher . string_match ( stream ) ) ) {\n"
                ],
                [
                    42,
                    " snprintf_func ( rptr , rbuf + TESTBUFSIZE - rptr , \"%d/%d\" , inst -> pos , inst -> size ) ;\n"
                ],
                [
                    52,
                    " if ( rptr != rbuf ) {\n"
                ],
                [
                    56,
                    " if ( strcmp ( rbuf , test -> result ) != 0 ) {\n"
                ],
                [
                    58,
                    " stream -> msg = \"wrong result\" ;\n"
                ],
                [
                    59,
                    " return XD3_INTERNAL ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static int test_string_matching ( xd3_stream * stream , int ignore ) {\n"
                ],
                [
                    7,
                    " i < SIZEOF_ARRAY ( match_tests ) ;\n"
                ],
                [
                    9,
                    " const string_match_test * test = & match_tests [ i ] ;\n"
                ],
                [
                    11,
                    " usize_t len = ( usize_t ) strlen ( test -> input ) ;\n"
                ],
                [
                    28,
                    " xd3_avail_input ( stream , ( uint8_t * ) test -> input , len ) ;\n"
                ],
                [
                    32,
                    " * rptr = 0 ;\n"
                ],
                [
                    33,
                    " while ( ! xd3_rlist_empty ( & stream -> iopt_used ) ) {\n"
                ],
                [
                    42,
                    " snprintf_func ( rptr , rbuf + TESTBUFSIZE - rptr , \"%d/%d\" , inst -> pos , inst -> size ) ;\n"
                ],
                [
                    43,
                    " rptr += strlen ( rptr ) ;\n"
                ],
                [
                    44,
                    " if ( inst -> type == XD3_CPY ) {\n"
                ],
                [
                    45,
                    " * rptr ++ = '@' ;\n"
                ],
                [
                    47,
                    " rptr += strlen ( rptr ) ;\n"
                ],
                [
                    49,
                    " * rptr ++ = ' ' ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int test_string_matching ( xd3_stream * stream , int ignore ) {\n"
                ],
                [
                    7,
                    " i < SIZEOF_ARRAY ( match_tests ) ;\n"
                ],
                [
                    8,
                    " i += 1 ) {\n"
                ],
                [
                    9,
                    " const string_match_test * test = & match_tests [ i ] ;\n"
                ],
                [
                    10,
                    " char * rptr = rbuf ;\n"
                ],
                [
                    11,
                    " usize_t len = ( usize_t ) strlen ( test -> input ) ;\n"
                ],
                [
                    28,
                    " xd3_avail_input ( stream , ( uint8_t * ) test -> input , len ) ;\n"
                ],
                [
                    29,
                    " if ( ( ret = stream -> smatcher . string_match ( stream ) ) ) {\n"
                ],
                [
                    32,
                    " * rptr = 0 ;\n"
                ],
                [
                    33,
                    " while ( ! xd3_rlist_empty ( & stream -> iopt_used ) ) {\n"
                ],
                [
                    42,
                    " snprintf_func ( rptr , rbuf + TESTBUFSIZE - rptr , \"%d/%d\" , inst -> pos , inst -> size ) ;\n"
                ],
                [
                    43,
                    " rptr += strlen ( rptr ) ;\n"
                ],
                [
                    44,
                    " if ( inst -> type == XD3_CPY ) {\n"
                ],
                [
                    45,
                    " * rptr ++ = '@' ;\n"
                ],
                [
                    47,
                    " rptr += strlen ( rptr ) ;\n"
                ],
                [
                    49,
                    " * rptr ++ = ' ' ;\n"
                ],
                [
                    52,
                    " if ( rptr != rbuf ) {\n"
                ],
                [
                    56,
                    " if ( strcmp ( rbuf , test -> result ) != 0 ) {\n"
                ],
                [
                    58,
                    " stream -> msg = \"wrong result\" ;\n"
                ],
                [
                    59,
                    " return XD3_INTERNAL ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * argv [ ] ) {\n static char buff [ 16384 ] ;\n struct cpio _cpio ;\n struct cpio * cpio ;\n const char * errmsg ;\n int uid , gid ;\n int opt ;\n cpio = & _cpio ;\n memset ( cpio , 0 , sizeof ( * cpio ) ) ;\n cpio -> buff = buff ;\n cpio -> buff_size = sizeof ( buff ) ;\n # if defined ( HAVE_SIGACTION ) && defined ( SIGPIPE ) {\n struct sigaction sa ;\n sigemptyset ( & sa . sa_mask ) ;\n sa . sa_flags = 0 ;\n sa . sa_handler = SIG_IGN ;\n sigaction ( SIGPIPE , & sa , NULL ) ;\n }\n # endif lafe_setprogname ( * argv , \"bsdcpio\" ) ;\n # if HAVE_SETLOCALE if ( setlocale ( LC_ALL , \"\" ) == NULL ) lafe_warnc ( 0 , \"Failed to set default locale\" ) ;\n # endif cpio -> uid_override = - 1 ;\n cpio -> gid_override = - 1 ;\n cpio -> argv = argv ;\n cpio -> argc = argc ;\n cpio -> mode = '\\0' ;\n cpio -> verbose = 0 ;\n cpio -> compress = '\\0' ;\n cpio -> extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;\n cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ;\n # if ! defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( geteuid ( ) == 0 ) cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ;\n # endif cpio -> bytes_per_block = 512 ;\n cpio -> filename = NULL ;\n cpio -> matching = archive_match_new ( ) ;\n if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , \"Out of memory\" ) ;\n while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) {\n switch ( opt ) {\n case '0' : cpio -> option_null = 1 ;\n break ;\n case 'A' : cpio -> option_append = 1 ;\n break ;\n case 'a' : cpio -> option_atime_restore = 1 ;\n break ;\n case 'B' : cpio -> bytes_per_block = 5120 ;\n break ;\n case OPTION_B64ENCODE : cpio -> add_filter = opt ;\n break ;\n case 'C' : cpio -> bytes_per_block = atoi ( cpio -> argument ) ;\n if ( cpio -> bytes_per_block <= 0 ) lafe_errc ( 1 , 0 , \"Invalid blocksize %s\" , cpio -> argument ) ;\n break ;\n case 'c' : cpio -> format = \"odc\" ;\n break ;\n case 'd' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_AUTODIR ;\n break ;\n case 'E' : if ( archive_match_include_pattern_from_file ( cpio -> matching , cpio -> argument , cpio -> option_null ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , \"Error : %s\" , archive_error_string ( cpio -> matching ) ) ;\n break ;\n case 'F' : cpio -> filename = cpio -> argument ;\n break ;\n case 'f' : if ( archive_match_exclude_pattern ( cpio -> matching , cpio -> argument ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , \"Error : %s\" , archive_error_string ( cpio -> matching ) ) ;\n break ;\n case OPTION_GRZIP : cpio -> compress = opt ;\n break ;\n case 'H' : cpio -> format = cpio -> argument ;\n break ;\n case 'h' : long_help ( ) ;\n break ;\n case 'I' : cpio -> filename = cpio -> argument ;\n break ;\n case 'i' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , \"Cannot use both -i and -%c\" , cpio -> mode ) ;\n cpio -> mode = opt ;\n break ;\n case 'J' : cpio -> compress = opt ;\n break ;\n case 'j' : cpio -> compress = opt ;\n break ;\n case OPTION_INSECURE : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_SYMLINKS ;\n cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n break ;\n case 'L' : cpio -> option_follow_links = 1 ;\n break ;\n case 'l' : cpio -> option_link = 1 ;\n break ;\n case OPTION_LRZIP : case OPTION_LZ4 : case OPTION_LZMA : case OPTION_LZOP : cpio -> compress = opt ;\n break ;\n case 'm' : cpio -> extract_flags |= ARCHIVE_EXTRACT_TIME ;\n break ;\n case 'n' : cpio -> option_numeric_uid_gid = 1 ;\n break ;\n case OPTION_NO_PRESERVE_OWNER : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_OWNER ;\n break ;\n case 'O' : cpio -> filename = cpio -> argument ;\n break ;\n case 'o' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , \"Cannot use both -o and -%c\" , cpio -> mode ) ;\n cpio -> mode = opt ;\n break ;\n case 'p' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , \"Cannot use both -p and -%c\" , cpio -> mode ) ;\n cpio -> mode = opt ;\n cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n break ;\n case OPTION_PASSPHRASE : cpio -> passphrase = cpio -> argument ;\n break ;\n case OPTION_PRESERVE_OWNER : cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ;\n break ;\n case OPTION_QUIET : cpio -> quiet = 1 ;\n break ;\n case 'R' : errmsg = owner_parse ( cpio -> argument , & uid , & gid ) ;\n if ( errmsg ) {\n lafe_warnc ( - 1 , \"%s\" , errmsg ) ;\n usage ( ) ;\n }\n if ( uid != - 1 ) {\n cpio -> uid_override = uid ;\n cpio -> uname_override = NULL ;\n }\n if ( gid != - 1 ) {\n cpio -> gid_override = gid ;\n cpio -> gname_override = NULL ;\n }\n break ;\n case 'r' : cpio -> option_rename = 1 ;\n break ;\n case 't' : cpio -> option_list = 1 ;\n break ;\n case 'u' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ;\n break ;\n case OPTION_UUENCODE : cpio -> add_filter = opt ;\n break ;\n case 'v' : cpio -> verbose ++ ;\n break ;\n case 'V' : cpio -> dot ++ ;\n break ;\n case OPTION_VERSION : version ( ) ;\n break ;\n # if 0 case 'W' : break ;\n # endif case 'y' : cpio -> compress = opt ;\n break ;\n case 'Z' : cpio -> compress = opt ;\n break ;\n case 'z' : cpio -> compress = opt ;\n break ;\n default : usage ( ) ;\n }\n }\n if ( cpio -> option_list && cpio -> mode == '\\0' ) cpio -> mode = 'i' ;\n if ( cpio -> option_list && cpio -> mode != 'i' ) lafe_errc ( 1 , 0 , \"Option -t requires -i\" ) ;\n if ( cpio -> option_numeric_uid_gid && ! cpio -> option_list ) lafe_errc ( 1 , 0 , \"Option -n requires -it\" ) ;\n if ( cpio -> format != NULL && cpio -> mode != 'o' ) lafe_errc ( 1 , 0 , \"Option --format requires -o\" ) ;\n if ( cpio -> option_link && cpio -> mode != 'p' ) lafe_errc ( 1 , 0 , \"Option -l requires -p\" ) ;\n if ( cpio -> dot && cpio -> verbose ) cpio -> dot = 0 ;\n switch ( cpio -> mode ) {\n case 'o' : if ( cpio -> format == NULL ) cpio -> format = \"odc\" ;\n mode_out ( cpio ) ;\n break ;\n case 'i' : while ( * cpio -> argv != NULL ) {\n if ( archive_match_include_pattern ( cpio -> matching , * cpio -> argv ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , \"Error : %s\" , archive_error_string ( cpio -> matching ) ) ;\n -- cpio -> argc ;\n ++ cpio -> argv ;\n }\n if ( cpio -> option_list ) mode_list ( cpio ) ;\n else mode_in ( cpio ) ;\n break ;\n case 'p' : if ( * cpio -> argv == NULL || * * cpio -> argv == '\\0' ) lafe_errc ( 1 , 0 , \"-p mode requires a target directory\" ) ;\n mode_pass ( cpio , * cpio -> argv ) ;\n break ;\n default : lafe_errc ( 1 , 0 , \"Must specify at least one of -i, -o, or -p\" ) ;\n }\n archive_match_free ( cpio -> matching ) ;\n free_cache ( cpio -> gname_cache ) ;\n free_cache ( cpio -> uname_cache ) ;\n free ( cpio -> destdir ) ;\n passphrase_free ( cpio -> ppbuff ) ;\n return ( cpio -> return_value ) ;\n }",
        "hash": -6704066512670389306,
        "project": "debian",
        "size": 177,
        "slice": {
            "memset": [
                [
                    1,
                    "int main ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    8,
                    " cpio = & _cpio ;\n"
                ],
                [
                    9,
                    " memset ( cpio , 0 , sizeof ( * cpio ) ) ;\n"
                ],
                [
                    29,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ;\n"
                ],
                [
                    30,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ;\n"
                ],
                [
                    31,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n"
                ],
                [
                    32,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;\n"
                ],
                [
                    33,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;\n"
                ],
                [
                    34,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ;\n"
                ],
                [
                    39,
                    " if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , \"Out of memory\" ) ;\n"
                ],
                [
                    40,
                    " while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "int main ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    40,
                    " while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) {\n"
                ],
                [
                    156,
                    " mode_out ( cpio ) ;\n"
                ],
                [
                    163,
                    " if ( cpio -> option_list ) mode_list ( cpio ) ;\n"
                ],
                [
                    164,
                    " else mode_in ( cpio ) ;\n"
                ],
                [
                    167,
                    " mode_pass ( cpio , * cpio -> argv ) ;\n"
                ],
                [
                    174,
                    " free ( cpio -> destdir ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    8,
                    " cpio = & _cpio ;\n"
                ],
                [
                    9,
                    " memset ( cpio , 0 , sizeof ( * cpio ) ) ;\n"
                ],
                [
                    29,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ;\n"
                ],
                [
                    30,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ;\n"
                ],
                [
                    31,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n"
                ],
                [
                    32,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;\n"
                ],
                [
                    33,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;\n"
                ],
                [
                    34,
                    " cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ;\n"
                ],
                [
                    39,
                    " if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , \"Out of memory\" ) ;\n"
                ],
                [
                    40,
                    " while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) {\n"
                ],
                [
                    156,
                    " mode_out ( cpio ) ;\n"
                ],
                [
                    163,
                    " if ( cpio -> option_list ) mode_list ( cpio ) ;\n"
                ],
                [
                    164,
                    " else mode_in ( cpio ) ;\n"
                ],
                [
                    167,
                    " mode_pass ( cpio , * cpio -> argv ) ;\n"
                ],
                [
                    174,
                    " free ( cpio -> destdir ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "mbfl_string * mbfl_strcut ( mbfl_string * string , mbfl_string * result , int from , int length ) {\n const mbfl_encoding * encoding ;\n mbfl_memory_device device ;\n if ( string == NULL || string -> val == NULL || result == NULL ) {\n return NULL ;\n }\n if ( from < 0 || length < 0 ) {\n return NULL ;\n }\n if ( from >= string -> len ) {\n from = string -> len ;\n }\n encoding = mbfl_no2encoding ( string -> no_encoding ) ;\n if ( encoding == NULL ) {\n return NULL ;\n }\n mbfl_string_init ( result ) ;\n result -> no_language = string -> no_language ;\n result -> no_encoding = string -> no_encoding ;\n if ( ( encoding -> flag & ( MBFL_ENCTYPE_SBCS | MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE | MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE ) ) || encoding -> mblen_table != NULL ) {\n const unsigned char * start = NULL ;\n const unsigned char * end = NULL ;\n unsigned char * w ;\n unsigned int sz ;\n if ( encoding -> flag & ( MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE ) ) {\n from &= - 2 ;\n if ( from + length >= string -> len ) {\n length = string -> len - from ;\n }\n start = string -> val + from ;\n end = start + ( length & - 2 ) ;\n }\n else if ( encoding -> flag & ( MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE ) ) {\n from &= - 4 ;\n if ( from + length >= string -> len ) {\n length = string -> len - from ;\n }\n start = string -> val + from ;\n end = start + ( length & - 4 ) ;\n }\n else if ( ( encoding -> flag & MBFL_ENCTYPE_SBCS ) ) {\n if ( from + length >= string -> len ) {\n length = string -> len - from ;\n }\n start = string -> val + from ;\n end = start + length ;\n }\n else if ( encoding -> mblen_table != NULL ) {\n const unsigned char * mbtab = encoding -> mblen_table ;\n const unsigned char * p , * q ;\n int m ;\n for ( m = 0 , p = string -> val , q = p + from ;\n p < q ;\n p += ( m = mbtab [ * p ] ) ) ;\n if ( p > q ) {\n p -= m ;\n }\n start = p ;\n if ( ( start - string -> val ) + length >= ( int ) string -> len ) {\n end = string -> val + string -> len ;\n }\n else {\n for ( q = p + length ;\n p < q ;\n p += ( m = mbtab [ * p ] ) ) ;\n if ( p > q ) {\n p -= m ;\n }\n end = p ;\n }\n }\n else {\n return NULL ;\n }\n sz = end - start ;\n if ( ( w = ( unsigned char * ) mbfl_calloc ( sz + 8 , sizeof ( unsigned char ) ) ) == NULL ) {\n return NULL ;\n }\n memcpy ( w , start , sz ) ;\n w [ sz ] = '\\0' ;\n w [ sz + 1 ] = '\\0' ;\n w [ sz + 2 ] = '\\0' ;\n w [ sz + 3 ] = '\\0' ;\n result -> val = w ;\n result -> len = sz ;\n }\n else {\n mbfl_convert_filter * encoder = NULL ;\n mbfl_convert_filter * decoder = NULL ;\n const unsigned char * p , * q , * r ;\n struct {\n mbfl_convert_filter encoder ;\n mbfl_convert_filter decoder ;\n const unsigned char * p ;\n int pos ;\n }\n bk , _bk ;\n if ( ! ( decoder = mbfl_convert_filter_new ( mbfl_no_encoding_wchar , string -> no_encoding , mbfl_memory_device_output , 0 , & device ) ) ) {\n return NULL ;\n }\n if ( ! ( encoder = mbfl_convert_filter_new ( string -> no_encoding , mbfl_no_encoding_wchar , mbfl_filter_output_null , NULL , NULL ) ) ) {\n mbfl_convert_filter_delete ( decoder ) ;\n return NULL ;\n }\n mbfl_memory_device_init ( & device , length + 8 , 0 ) ;\n p = string -> val ;\n for ( q = string -> val + from ;\n p < q ;\n p ++ ) {\n ( * encoder -> filter_function ) ( * p , encoder ) ;\n }\n encoder -> output_function = ( int ( * ) ( int , void * ) ) decoder -> filter_function ;\n encoder -> flush_function = ( int ( * ) ( void * ) ) decoder -> filter_flush ;\n encoder -> data = decoder ;\n q = string -> val + string -> len ;\n mbfl_convert_filter_copy ( decoder , & _bk . decoder ) ;\n mbfl_convert_filter_copy ( encoder , & _bk . encoder ) ;\n _bk . p = p ;\n _bk . pos = device . pos ;\n if ( length > q - p ) {\n length = q - p ;\n }\n if ( length >= 20 ) {\n for ( r = p + length - 20 ;\n p < r ;\n p ++ ) {\n ( * encoder -> filter_function ) ( * p , encoder ) ;\n }\n if ( device . pos > length ) {\n p = _bk . p ;\n device . pos = _bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & _bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & _bk . encoder , encoder ) ;\n bk = _bk ;\n }\n else {\n mbfl_convert_filter_copy ( decoder , & bk . decoder ) ;\n mbfl_convert_filter_copy ( encoder , & bk . encoder ) ;\n bk . p = p ;\n bk . pos = device . pos ;\n ( * encoder -> filter_flush ) ( encoder ) ;\n if ( device . pos > length ) {\n bk . decoder . filter_dtor ( & bk . decoder ) ;\n bk . encoder . filter_dtor ( & bk . encoder ) ;\n p = _bk . p ;\n device . pos = _bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & _bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & _bk . encoder , encoder ) ;\n bk = _bk ;\n }\n else {\n _bk . decoder . filter_dtor ( & _bk . decoder ) ;\n _bk . encoder . filter_dtor ( & _bk . encoder ) ;\n p = bk . p ;\n device . pos = bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & bk . encoder , encoder ) ;\n }\n }\n }\n else {\n bk = _bk ;\n }\n while ( p < q ) {\n ( * encoder -> filter_function ) ( * p , encoder ) ;\n if ( device . pos > length ) {\n p = bk . p ;\n device . pos = bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & bk . encoder , encoder ) ;\n break ;\n }\n p ++ ;\n mbfl_convert_filter_copy ( decoder , & _bk . decoder ) ;\n mbfl_convert_filter_copy ( encoder , & _bk . encoder ) ;\n _bk . pos = device . pos ;\n _bk . p = p ;\n ( * encoder -> filter_flush ) ( encoder ) ;\n if ( device . pos > length ) {\n _bk . decoder . filter_dtor ( & _bk . decoder ) ;\n _bk . encoder . filter_dtor ( & _bk . encoder ) ;\n p = bk . p ;\n device . pos = bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & bk . encoder , encoder ) ;\n break ;\n }\n bk . decoder . filter_dtor ( & bk . decoder ) ;\n bk . encoder . filter_dtor ( & bk . encoder ) ;\n p = _bk . p ;\n device . pos = _bk . pos ;\n decoder -> filter_dtor ( decoder ) ;\n encoder -> filter_dtor ( encoder ) ;\n mbfl_convert_filter_copy ( & _bk . decoder , decoder ) ;\n mbfl_convert_filter_copy ( & _bk . encoder , encoder ) ;\n bk = _bk ;\n }\n ( * encoder -> filter_flush ) ( encoder ) ;\n bk . decoder . filter_dtor ( & bk . decoder ) ;\n bk . encoder . filter_dtor ( & bk . encoder ) ;\n result = mbfl_memory_device_result ( & device , result ) ;\n mbfl_convert_filter_delete ( encoder ) ;\n mbfl_convert_filter_delete ( decoder ) ;\n }\n return result ;\n }",
        "hash": 5991533509192663951,
        "project": "debian",
        "size": 216,
        "slice": {
            "memcpy": [
                [
                    1,
                    "mbfl_string * mbfl_strcut ( mbfl_string * string , mbfl_string * result , int from , int length ) {\n"
                ],
                [
                    75,
                    " sz = end - start ;\n"
                ],
                [
                    76,
                    " if ( ( w = ( unsigned char * ) mbfl_calloc ( sz + 8 , sizeof ( unsigned char ) ) ) == NULL ) {\n"
                ],
                [
                    79,
                    " memcpy ( w , start , sz ) ;\n"
                ],
                [
                    81,
                    " w [ sz + 1 ] = '\\0' ;\n"
                ],
                [
                    82,
                    " w [ sz + 2 ] = '\\0' ;\n"
                ],
                [
                    83,
                    " w [ sz + 3 ] = '\\0' ;\n"
                ],
                [
                    84,
                    " result -> val = w ;\n"
                ],
                [
                    85,
                    " result -> len = sz ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "mbfl_string * mbfl_strcut ( mbfl_string * string , mbfl_string * result , int from , int length ) {\n"
                ],
                [
                    75,
                    " sz = end - start ;\n"
                ],
                [
                    76,
                    " if ( ( w = ( unsigned char * ) mbfl_calloc ( sz + 8 , sizeof ( unsigned char ) ) ) == NULL ) {\n"
                ],
                [
                    79,
                    " memcpy ( w , start , sz ) ;\n"
                ],
                [
                    81,
                    " w [ sz + 1 ] = '\\0' ;\n"
                ],
                [
                    82,
                    " w [ sz + 2 ] = '\\0' ;\n"
                ],
                [
                    83,
                    " w [ sz + 3 ] = '\\0' ;\n"
                ],
                [
                    84,
                    " result -> val = w ;\n"
                ],
                [
                    85,
                    " result -> len = sz ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) {\n struct Client * agent_p = NULL ;\n struct Client * saslserv_p = NULL ;\n if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ;\n if ( strlen ( client_p -> id ) == 3 ) {\n exit_client ( client_p , client_p , client_p , \"Mixing client and server protocol\" ) ;\n return 0 ;\n }\n saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ;\n if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) {\n sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ;\n return 0 ;\n }\n if ( source_p -> localClient -> sasl_complete ) {\n * source_p -> localClient -> sasl_agent = '\\0' ;\n source_p -> localClient -> sasl_complete = 0 ;\n }\n if ( strlen ( parv [ 1 ] ) > 400 ) {\n sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ;\n return 0 ;\n }\n if ( ! * source_p -> id ) {\n strcpy ( source_p -> id , generate_uid ( ) ) ;\n add_to_id_hash ( source_p -> id , source_p ) ;\n }\n if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ;\n if ( agent_p == NULL ) {\n sendto_one ( saslserv_p , \":%s ENCAP %s SASL %s %s H %s %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , source_p -> host , source_p -> sockhost ) ;\n if ( ! strcmp ( parv [ 1 ] , \"EXTERNAL\" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , \":%s ENCAP %s SASL %s %s S %s %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ;\n else sendto_one ( saslserv_p , \":%s ENCAP %s SASL %s %s S %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ;\n rb_strlcpy ( source_p -> localClient -> sasl_agent , saslserv_p -> id , IDLEN ) ;\n }\n else sendto_one ( agent_p , \":%s ENCAP %s SASL %s %s C %s\" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ;\n source_p -> localClient -> sasl_out ++ ;\n return 0 ;\n }",
        "hash": 367231654042118631,
        "project": "debian",
        "size": 36,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) {\n"
                ],
                [
                    18,
                    " if ( strlen ( parv [ 1 ] ) > 400 ) {\n"
                ],
                [
                    27,
                    " if ( agent_p == NULL ) {\n"
                ],
                [
                    29,
                    " if ( ! strcmp ( parv [ 1 ] , \"EXTERNAL\" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , \":%s ENCAP %s SASL %s %s S %s %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ;\n"
                ],
                [
                    30,
                    " else sendto_one ( saslserv_p , \":%s ENCAP %s SASL %s %s S %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) {\n"
                ],
                [
                    4,
                    " if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ;\n"
                ],
                [
                    5,
                    " if ( strlen ( client_p -> id ) == 3 ) {\n"
                ],
                [
                    6,
                    " exit_client ( client_p , client_p , client_p , \"Mixing client and server protocol\" ) ;\n"
                ],
                [
                    7,
                    " return 0 ;\n"
                ],
                [
                    9,
                    " saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ;\n"
                ],
                [
                    10,
                    " if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) {\n"
                ],
                [
                    18,
                    " if ( strlen ( parv [ 1 ] ) > 400 ) {\n"
                ],
                [
                    19,
                    " sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ;\n"
                ],
                [
                    20,
                    " return 0 ;\n"
                ],
                [
                    22,
                    " if ( ! * source_p -> id ) {\n"
                ],
                [
                    26,
                    " if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ;\n"
                ],
                [
                    27,
                    " if ( agent_p == NULL ) {\n"
                ],
                [
                    29,
                    " if ( ! strcmp ( parv [ 1 ] , \"EXTERNAL\" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , \":%s ENCAP %s SASL %s %s S %s %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ;\n"
                ],
                [
                    33,
                    " else sendto_one ( agent_p , \":%s ENCAP %s SASL %s %s C %s\" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ;\n"
                ],
                [
                    34,
                    " source_p -> localClient -> sasl_out ++ ;\n"
                ],
                [
                    35,
                    " return 0 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) {\n"
                ],
                [
                    4,
                    " if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ;\n"
                ],
                [
                    5,
                    " if ( strlen ( client_p -> id ) == 3 ) {\n"
                ],
                [
                    6,
                    " exit_client ( client_p , client_p , client_p , \"Mixing client and server protocol\" ) ;\n"
                ],
                [
                    7,
                    " return 0 ;\n"
                ],
                [
                    9,
                    " saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ;\n"
                ],
                [
                    10,
                    " if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) {\n"
                ],
                [
                    18,
                    " if ( strlen ( parv [ 1 ] ) > 400 ) {\n"
                ],
                [
                    19,
                    " sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? \"*\" : source_p -> name ) ;\n"
                ],
                [
                    20,
                    " return 0 ;\n"
                ],
                [
                    22,
                    " if ( ! * source_p -> id ) {\n"
                ],
                [
                    26,
                    " if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ;\n"
                ],
                [
                    27,
                    " if ( agent_p == NULL ) {\n"
                ],
                [
                    29,
                    " if ( ! strcmp ( parv [ 1 ] , \"EXTERNAL\" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , \":%s ENCAP %s SASL %s %s S %s %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ;\n"
                ],
                [
                    30,
                    " else sendto_one ( saslserv_p , \":%s ENCAP %s SASL %s %s S %s\" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ;\n"
                ],
                [
                    33,
                    " else sendto_one ( agent_p , \":%s ENCAP %s SASL %s %s C %s\" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ;\n"
                ],
                [
                    34,
                    " source_p -> localClient -> sasl_out ++ ;\n"
                ],
                [
                    35,
                    " return 0 ;\n"
                ]
            ]
        }
    },
    {
        "code": "void simplestring_addn ( simplestring * target , const char * source , int add_len ) {\n if ( target && source ) {\n if ( ! target -> str ) {\n simplestring_init_str ( target ) ;\n }\n if ( target -> len + add_len + 1 > target -> size ) {\n int newsize = target -> len + add_len + 1 ;\n int incr = target -> size * 2 ;\n newsize = newsize - ( newsize % incr ) + incr ;\n target -> str = ( char * ) realloc ( target -> str , newsize ) ;\n target -> size = target -> str ? newsize : 0 ;\n }\n if ( target -> str ) {\n if ( add_len ) {\n memcpy ( target -> str + target -> len , source , add_len ) ;\n }\n target -> len += add_len ;\n target -> str [ target -> len ] = 0 ;\n }\n }\n }",
        "hash": -3765873911425338769,
        "project": "debian",
        "size": 21,
        "slice": {
            "memcpy": [
                [
                    1,
                    "void simplestring_addn ( simplestring * target , const char * source , int add_len ) {\n"
                ],
                [
                    2,
                    " if ( target && source ) {\n"
                ],
                [
                    3,
                    " if ( ! target -> str ) {\n"
                ],
                [
                    4,
                    " simplestring_init_str ( target ) ;\n"
                ],
                [
                    14,
                    " if ( add_len ) {\n"
                ],
                [
                    15,
                    " memcpy ( target -> str + target -> len , source , add_len ) ;\n"
                ],
                [
                    17,
                    " target -> len += add_len ;\n"
                ]
            ],
            "realloc": [
                [
                    1,
                    "void simplestring_addn ( simplestring * target , const char * source , int add_len ) {\n"
                ],
                [
                    2,
                    " if ( target && source ) {\n"
                ],
                [
                    3,
                    " if ( ! target -> str ) {\n"
                ],
                [
                    4,
                    " simplestring_init_str ( target ) ;\n"
                ],
                [
                    6,
                    " if ( target -> len + add_len + 1 > target -> size ) {\n"
                ],
                [
                    9,
                    " newsize = newsize - ( newsize % incr ) + incr ;\n"
                ],
                [
                    10,
                    " target -> str = ( char * ) realloc ( target -> str , newsize ) ;\n"
                ],
                [
                    11,
                    " target -> size = target -> str ? newsize : 0 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void simplestring_addn ( simplestring * target , const char * source , int add_len ) {\n"
                ],
                [
                    2,
                    " if ( target && source ) {\n"
                ],
                [
                    3,
                    " if ( ! target -> str ) {\n"
                ],
                [
                    4,
                    " simplestring_init_str ( target ) ;\n"
                ],
                [
                    6,
                    " if ( target -> len + add_len + 1 > target -> size ) {\n"
                ],
                [
                    9,
                    " newsize = newsize - ( newsize % incr ) + incr ;\n"
                ],
                [
                    10,
                    " target -> str = ( char * ) realloc ( target -> str , newsize ) ;\n"
                ],
                [
                    11,
                    " target -> size = target -> str ? newsize : 0 ;\n"
                ],
                [
                    14,
                    " if ( add_len ) {\n"
                ],
                [
                    15,
                    " memcpy ( target -> str + target -> len , source , add_len ) ;\n"
                ],
                [
                    17,
                    " target -> len += add_len ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ssl3_read_bytes ( SSL * s , int type , int * recvd_type , unsigned char * buf , int len , int peek ) {\n int al , i , j , ret ;\n unsigned int n , curr_rec , num_recs , read_bytes ;\n SSL3_RECORD * rr ;\n SSL3_BUFFER * rbuf ;\n void ( * cb ) ( const SSL * ssl , int type2 , int val ) = NULL ;\n rbuf = & s -> rlayer . rbuf ;\n if ( ! SSL3_BUFFER_is_initialised ( rbuf ) ) {\n if ( ! ssl3_setup_read_buffer ( s ) ) return ( - 1 ) ;\n }\n if ( ( type && ( type != SSL3_RT_APPLICATION_DATA ) && ( type != SSL3_RT_HANDSHAKE ) ) || ( peek && ( type != SSL3_RT_APPLICATION_DATA ) ) ) {\n SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;\n return - 1 ;\n }\n if ( ( type == SSL3_RT_HANDSHAKE ) && ( s -> rlayer . handshake_fragment_len > 0 ) ) {\n unsigned char * src = s -> rlayer . handshake_fragment ;\n unsigned char * dst = buf ;\n unsigned int k ;\n n = 0 ;\n while ( ( len > 0 ) && ( s -> rlayer . handshake_fragment_len > 0 ) ) {\n * dst ++ = * src ++ ;\n len -- ;\n s -> rlayer . handshake_fragment_len -- ;\n n ++ ;\n }\n for ( k = 0 ;\n k < s -> rlayer . handshake_fragment_len ;\n k ++ ) s -> rlayer . handshake_fragment [ k ] = * src ++ ;\n if ( recvd_type != NULL ) * recvd_type = SSL3_RT_HANDSHAKE ;\n return n ;\n }\n if ( ! ossl_statem_get_in_handshake ( s ) && SSL_in_init ( s ) ) {\n i = s -> handshake_func ( s ) ;\n if ( i < 0 ) return ( i ) ;\n if ( i == 0 ) {\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ;\n return ( - 1 ) ;\n }\n }\n start : s -> rwstate = SSL_NOTHING ;\n rr = s -> rlayer . rrec ;\n num_recs = RECORD_LAYER_get_numrpipes ( & s -> rlayer ) ;\n do {\n if ( num_recs == 0 ) {\n ret = ssl3_get_record ( s ) ;\n if ( ret <= 0 ) return ( ret ) ;\n num_recs = RECORD_LAYER_get_numrpipes ( & s -> rlayer ) ;\n if ( num_recs == 0 ) {\n al = SSL_AD_INTERNAL_ERROR ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;\n goto f_err ;\n }\n }\n for ( curr_rec = 0 ;\n curr_rec < num_recs && SSL3_RECORD_is_read ( & rr [ curr_rec ] ) ;\n curr_rec ++ ) ;\n if ( curr_rec == num_recs ) {\n RECORD_LAYER_set_numrpipes ( & s -> rlayer , 0 ) ;\n num_recs = 0 ;\n curr_rec = 0 ;\n }\n }\n while ( num_recs == 0 ) ;\n rr = & rr [ curr_rec ] ;\n if ( s -> s3 -> change_cipher_spec && ( SSL3_RECORD_get_type ( rr ) != SSL3_RT_HANDSHAKE ) ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_DATA_BETWEEN_CCS_AND_FINISHED ) ;\n goto f_err ;\n }\n if ( s -> shutdown & SSL_RECEIVED_SHUTDOWN ) {\n SSL3_RECORD_set_length ( rr , 0 ) ;\n s -> rwstate = SSL_NOTHING ;\n return ( 0 ) ;\n }\n if ( type == SSL3_RECORD_get_type ( rr ) || ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC && type == SSL3_RT_HANDSHAKE && recvd_type != NULL ) ) {\n if ( SSL_in_init ( s ) && ( type == SSL3_RT_APPLICATION_DATA ) && ( s -> enc_read_ctx == NULL ) ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_APP_DATA_IN_HANDSHAKE ) ;\n goto f_err ;\n }\n if ( type == SSL3_RT_HANDSHAKE && SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC && s -> rlayer . handshake_fragment_len > 0 ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ;\n goto f_err ;\n }\n if ( recvd_type != NULL ) * recvd_type = SSL3_RECORD_get_type ( rr ) ;\n if ( len <= 0 ) return ( len ) ;\n read_bytes = 0 ;\n do {\n if ( ( unsigned int ) len - read_bytes > SSL3_RECORD_get_length ( rr ) ) n = SSL3_RECORD_get_length ( rr ) ;\n else n = ( unsigned int ) len - read_bytes ;\n memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ;\n buf += n ;\n if ( ! peek ) {\n SSL3_RECORD_sub_length ( rr , n ) ;\n SSL3_RECORD_add_off ( rr , n ) ;\n if ( SSL3_RECORD_get_length ( rr ) == 0 ) {\n s -> rlayer . rstate = SSL_ST_READ_HEADER ;\n SSL3_RECORD_set_off ( rr , 0 ) ;\n SSL3_RECORD_set_read ( rr ) ;\n }\n }\n if ( SSL3_RECORD_get_length ( rr ) == 0 || ( peek && n == SSL3_RECORD_get_length ( rr ) ) ) {\n curr_rec ++ ;\n rr ++ ;\n }\n read_bytes += n ;\n }\n while ( type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs && read_bytes < ( unsigned int ) len ) ;\n if ( read_bytes == 0 ) {\n goto start ;\n }\n if ( ! peek && curr_rec == num_recs && ( s -> mode & SSL_MODE_RELEASE_BUFFERS ) && SSL3_BUFFER_get_left ( rbuf ) == 0 ) ssl3_release_read_buffer ( s ) ;\n return read_bytes ;\n }\n if ( rr -> rec_version == SSL2_VERSION ) {\n al = SSL_AD_INTERNAL_ERROR ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;\n goto f_err ;\n }\n if ( s -> method -> version == TLS_ANY_VERSION && ( s -> server || rr -> type != SSL3_RT_ALERT ) ) {\n s -> version = rr -> rec_version ;\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_MESSAGE ) ;\n goto f_err ;\n }\n {\n unsigned int dest_maxlen = 0 ;\n unsigned char * dest = NULL ;\n unsigned int * dest_len = NULL ;\n if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_HANDSHAKE ) {\n dest_maxlen = sizeof s -> rlayer . handshake_fragment ;\n dest = s -> rlayer . handshake_fragment ;\n dest_len = & s -> rlayer . handshake_fragment_len ;\n }\n else if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_ALERT ) {\n dest_maxlen = sizeof s -> rlayer . alert_fragment ;\n dest = s -> rlayer . alert_fragment ;\n dest_len = & s -> rlayer . alert_fragment_len ;\n }\n if ( dest_maxlen > 0 ) {\n n = dest_maxlen - * dest_len ;\n if ( SSL3_RECORD_get_length ( rr ) < n ) n = SSL3_RECORD_get_length ( rr ) ;\n while ( n -- > 0 ) {\n dest [ ( * dest_len ) ++ ] = SSL3_RECORD_get_data ( rr ) [ SSL3_RECORD_get_off ( rr ) ] ;\n SSL3_RECORD_add_off ( rr , 1 ) ;\n SSL3_RECORD_add_length ( rr , - 1 ) ;\n }\n if ( * dest_len < dest_maxlen ) {\n SSL3_RECORD_set_read ( rr ) ;\n goto start ;\n }\n }\n }\n if ( ( ! s -> server ) && ( s -> rlayer . handshake_fragment_len >= 4 ) && ( s -> rlayer . handshake_fragment [ 0 ] == SSL3_MT_HELLO_REQUEST ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) ) {\n s -> rlayer . handshake_fragment_len = 0 ;\n if ( ( s -> rlayer . handshake_fragment [ 1 ] != 0 ) || ( s -> rlayer . handshake_fragment [ 2 ] != 0 ) || ( s -> rlayer . handshake_fragment [ 3 ] != 0 ) ) {\n al = SSL_AD_DECODE_ERROR ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_BAD_HELLO_REQUEST ) ;\n goto f_err ;\n }\n if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_HANDSHAKE , s -> rlayer . handshake_fragment , 4 , s , s -> msg_callback_arg ) ;\n if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) && ! s -> s3 -> renegotiate ) {\n ssl3_renegotiate ( s ) ;\n if ( ssl3_renegotiate_check ( s ) ) {\n i = s -> handshake_func ( s ) ;\n if ( i < 0 ) return ( i ) ;\n if ( i == 0 ) {\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ;\n return ( - 1 ) ;\n }\n if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) {\n if ( SSL3_BUFFER_get_left ( rbuf ) == 0 ) {\n BIO * bio ;\n s -> rwstate = SSL_READING ;\n bio = SSL_get_rbio ( s ) ;\n BIO_clear_retry_flags ( bio ) ;\n BIO_set_retry_read ( bio ) ;\n return ( - 1 ) ;\n }\n }\n }\n }\n goto start ;\n }\n if ( s -> server && SSL_is_init_finished ( s ) && ! s -> s3 -> send_connection_binding && ( s -> version > SSL3_VERSION ) && ( s -> rlayer . handshake_fragment_len >= 4 ) && ( s -> rlayer . handshake_fragment [ 0 ] == SSL3_MT_CLIENT_HELLO ) && ( s -> session != NULL ) && ( s -> session -> cipher != NULL ) && ! ( s -> ctx -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) {\n SSL3_RECORD_set_length ( rr , 0 ) ;\n SSL3_RECORD_set_read ( rr ) ;\n ssl3_send_alert ( s , SSL3_AL_WARNING , SSL_AD_NO_RENEGOTIATION ) ;\n goto start ;\n }\n if ( s -> rlayer . alert_fragment_len >= 2 ) {\n int alert_level = s -> rlayer . alert_fragment [ 0 ] ;\n int alert_descr = s -> rlayer . alert_fragment [ 1 ] ;\n s -> rlayer . alert_fragment_len = 0 ;\n if ( s -> msg_callback ) s -> msg_callback ( 0 , s -> version , SSL3_RT_ALERT , s -> rlayer . alert_fragment , 2 , s , s -> msg_callback_arg ) ;\n if ( s -> info_callback != NULL ) cb = s -> info_callback ;\n else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ;\n if ( cb != NULL ) {\n j = ( alert_level << 8 ) | alert_descr ;\n cb ( s , SSL_CB_READ_ALERT , j ) ;\n }\n if ( alert_level == SSL3_AL_WARNING ) {\n s -> s3 -> warn_alert = alert_descr ;\n SSL3_RECORD_set_read ( rr ) ;\n if ( alert_descr == SSL_AD_CLOSE_NOTIFY ) {\n s -> shutdown |= SSL_RECEIVED_SHUTDOWN ;\n return ( 0 ) ;\n }\n else if ( alert_descr == SSL_AD_NO_RENEGOTIATION ) {\n al = SSL_AD_HANDSHAKE_FAILURE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_NO_RENEGOTIATION ) ;\n goto f_err ;\n }\n # ifdef SSL_AD_MISSING_SRP_USERNAME else if ( alert_descr == SSL_AD_MISSING_SRP_USERNAME ) return ( 0 ) ;\n # endif }\n else if ( alert_level == SSL3_AL_FATAL ) {\n char tmp [ 16 ] ;\n s -> rwstate = SSL_NOTHING ;\n s -> s3 -> fatal_alert = alert_descr ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_AD_REASON_OFFSET + alert_descr ) ;\n BIO_snprintf ( tmp , sizeof tmp , \"%d\" , alert_descr ) ;\n ERR_add_error_data ( 2 , \"SSL alert number \" , tmp ) ;\n s -> shutdown |= SSL_RECEIVED_SHUTDOWN ;\n SSL3_RECORD_set_read ( rr ) ;\n SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ;\n return ( 0 ) ;\n }\n else {\n al = SSL_AD_ILLEGAL_PARAMETER ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNKNOWN_ALERT_TYPE ) ;\n goto f_err ;\n }\n goto start ;\n }\n if ( s -> shutdown & SSL_SENT_SHUTDOWN ) {\n s -> rwstate = SSL_NOTHING ;\n SSL3_RECORD_set_length ( rr , 0 ) ;\n SSL3_RECORD_set_read ( rr ) ;\n return ( 0 ) ;\n }\n if ( SSL3_RECORD_get_type ( rr ) == SSL3_RT_CHANGE_CIPHER_SPEC ) {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_CCS_RECEIVED_EARLY ) ;\n goto f_err ;\n }\n if ( ( s -> rlayer . handshake_fragment_len >= 4 ) && ! ossl_statem_get_in_handshake ( s ) ) {\n if ( SSL_is_init_finished ( s ) && ! ( s -> s3 -> flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS ) ) {\n ossl_statem_set_in_init ( s , 1 ) ;\n s -> renegotiate = 1 ;\n s -> new_session = 1 ;\n }\n i = s -> handshake_func ( s ) ;\n if ( i < 0 ) return ( i ) ;\n if ( i == 0 ) {\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ;\n return ( - 1 ) ;\n }\n if ( ! ( s -> mode & SSL_MODE_AUTO_RETRY ) ) {\n if ( SSL3_BUFFER_get_left ( rbuf ) == 0 ) {\n BIO * bio ;\n s -> rwstate = SSL_READING ;\n bio = SSL_get_rbio ( s ) ;\n BIO_clear_retry_flags ( bio ) ;\n BIO_set_retry_read ( bio ) ;\n return ( - 1 ) ;\n }\n }\n goto start ;\n }\n switch ( SSL3_RECORD_get_type ( rr ) ) {\n default : if ( s -> version >= TLS1_VERSION && s -> version <= TLS1_1_VERSION ) {\n SSL3_RECORD_set_length ( rr , 0 ) ;\n SSL3_RECORD_set_read ( rr ) ;\n goto start ;\n }\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ;\n goto f_err ;\n case SSL3_RT_CHANGE_CIPHER_SPEC : case SSL3_RT_ALERT : case SSL3_RT_HANDSHAKE : al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , ERR_R_INTERNAL_ERROR ) ;\n goto f_err ;\n case SSL3_RT_APPLICATION_DATA : if ( ossl_statem_app_data_allowed ( s ) ) {\n s -> s3 -> in_read_app_data = 2 ;\n return ( - 1 ) ;\n }\n else {\n al = SSL_AD_UNEXPECTED_MESSAGE ;\n SSLerr ( SSL_F_SSL3_READ_BYTES , SSL_R_UNEXPECTED_RECORD ) ;\n goto f_err ;\n }\n }\n f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n return ( - 1 ) ;\n }",
        "hash": 561876472800374387,
        "project": "debian",
        "size": 295,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int ssl3_read_bytes ( SSL * s , int type , int * recvd_type , unsigned char * buf , int len , int peek ) {\n"
                ],
                [
                    87,
                    " if ( len <= 0 ) return ( len ) ;\n"
                ],
                [
                    90,
                    " if ( ( unsigned int ) len - read_bytes > SSL3_RECORD_get_length ( rr ) ) n = SSL3_RECORD_get_length ( rr ) ;\n"
                ],
                [
                    91,
                    " else n = ( unsigned int ) len - read_bytes ;\n"
                ],
                [
                    92,
                    " memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ;\n"
                ],
                [
                    93,
                    " buf += n ;\n"
                ],
                [
                    95,
                    " SSL3_RECORD_sub_length ( rr , n ) ;\n"
                ],
                [
                    103,
                    " if ( SSL3_RECORD_get_length ( rr ) == 0 || ( peek && n == SSL3_RECORD_get_length ( rr ) ) ) {\n"
                ],
                [
                    107,
                    " read_bytes += n ;\n"
                ],
                [
                    109,
                    " while ( type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs && read_bytes < ( unsigned int ) len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ssl3_read_bytes ( SSL * s , int type , int * recvd_type , unsigned char * buf , int len , int peek ) {\n"
                ],
                [
                    87,
                    " if ( len <= 0 ) return ( len ) ;\n"
                ],
                [
                    90,
                    " if ( ( unsigned int ) len - read_bytes > SSL3_RECORD_get_length ( rr ) ) n = SSL3_RECORD_get_length ( rr ) ;\n"
                ],
                [
                    91,
                    " else n = ( unsigned int ) len - read_bytes ;\n"
                ],
                [
                    92,
                    " memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ;\n"
                ],
                [
                    93,
                    " buf += n ;\n"
                ],
                [
                    95,
                    " SSL3_RECORD_sub_length ( rr , n ) ;\n"
                ],
                [
                    103,
                    " if ( SSL3_RECORD_get_length ( rr ) == 0 || ( peek && n == SSL3_RECORD_get_length ( rr ) ) ) {\n"
                ],
                [
                    107,
                    " read_bytes += n ;\n"
                ],
                [
                    109,
                    " while ( type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs && read_bytes < ( unsigned int ) len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) {\n struct cpio * cpio ;\n const void * h ;\n struct archive_string_conv * sconv ;\n size_t namelength ;\n size_t name_pad ;\n int r ;\n cpio = ( struct cpio * ) ( a -> format -> data ) ;\n sconv = cpio -> opt_sconv ;\n if ( sconv == NULL ) {\n if ( ! cpio -> init_default_conversion ) {\n cpio -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ;\n cpio -> init_default_conversion = 1 ;\n }\n sconv = cpio -> sconv_default ;\n }\n r = ( cpio -> read_header ( a , cpio , entry , & namelength , & name_pad ) ) ;\n if ( r < ARCHIVE_WARN ) return ( r ) ;\n h = __archive_read_ahead ( a , namelength + name_pad , NULL ) ;\n if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n if ( archive_entry_copy_pathname_l ( entry , ( const char * ) h , namelength , sconv ) != 0 ) {\n if ( errno == ENOMEM ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory for Pathname\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Pathname can't be converted from %s to current locale.\" , archive_string_conversion_charset_name ( sconv ) ) ;\n r = ARCHIVE_WARN ;\n }\n cpio -> entry_offset = 0 ;\n __archive_read_consume ( a , namelength + name_pad ) ;\n if ( archive_entry_filetype ( entry ) == AE_IFLNK ) {\n h = __archive_read_ahead ( a , ( size_t ) cpio -> entry_bytes_remaining , NULL ) ;\n if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) {\n if ( errno == ENOMEM ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate memory for Linkname\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , \"Linkname can't be converted from %s to \" \"current locale.\" , archive_string_conversion_charset_name ( sconv ) ) ;\n r = ARCHIVE_WARN ;\n }\n __archive_read_consume ( a , cpio -> entry_bytes_remaining ) ;\n cpio -> entry_bytes_remaining = 0 ;\n }\n if ( namelength == 11 && strcmp ( ( const char * ) h , \"TRAILER!!!\" ) == 0 ) {\n archive_clear_error ( & a -> archive ) ;\n return ( ARCHIVE_EOF ) ;\n }\n if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) {\n return ( ARCHIVE_FATAL ) ;\n }\n return ( r ) ;\n }",
        "hash": 1504508151056681409,
        "project": "debian",
        "size": 53,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) {\n"
                ],
                [
                    20,
                    " if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n"
                ],
                [
                    31,
                    " if ( archive_entry_filetype ( entry ) == AE_IFLNK ) {\n"
                ],
                [
                    33,
                    " if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n"
                ],
                [
                    34,
                    " if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) {\n"
                ],
                [
                    35,
                    " if ( errno == ENOMEM ) {\n"
                ],
                [
                    45,
                    " if ( namelength == 11 && strcmp ( ( const char * ) h , \"TRAILER!!!\" ) == 0 ) {\n"
                ],
                [
                    46,
                    " archive_clear_error ( & a -> archive ) ;\n"
                ],
                [
                    47,
                    " return ( ARCHIVE_EOF ) ;\n"
                ],
                [
                    49,
                    " if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) {\n"
                ],
                [
                    20,
                    " if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n"
                ],
                [
                    31,
                    " if ( archive_entry_filetype ( entry ) == AE_IFLNK ) {\n"
                ],
                [
                    33,
                    " if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n"
                ],
                [
                    34,
                    " if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) {\n"
                ],
                [
                    35,
                    " if ( errno == ENOMEM ) {\n"
                ],
                [
                    45,
                    " if ( namelength == 11 && strcmp ( ( const char * ) h , \"TRAILER!!!\" ) == 0 ) {\n"
                ],
                [
                    46,
                    " archive_clear_error ( & a -> archive ) ;\n"
                ],
                [
                    47,
                    " return ( ARCHIVE_EOF ) ;\n"
                ],
                [
                    49,
                    " if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) {\n"
                ]
            ]
        }
    },
    {
        "code": "kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) {\n int ret , ret2 , i ;\n kadm5_policy_ent_rec pol ;\n krb5_boolean have_pol = FALSE ;\n krb5_db_entry * kdb ;\n krb5_tl_data * tl_data_orig ;\n osa_princ_ent_rec adb ;\n kadm5_server_handle_t handle = server_handle ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ;\n if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;\n if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;\n if ( entry == ( kadm5_principal_ent_t ) NULL ) return EINVAL ;\n if ( mask & KADM5_TL_DATA ) {\n tl_data_orig = entry -> tl_data ;\n while ( tl_data_orig ) {\n if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ;\n tl_data_orig = tl_data_orig -> tl_data_next ;\n }\n }\n ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;\n if ( ret ) return ( ret ) ;\n if ( ( mask & KADM5_POLICY ) ) {\n ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ;\n if ( ret ) goto done ;\n adb . aux_attributes |= KADM5_POLICY ;\n if ( adb . policy ) free ( adb . policy ) ;\n adb . policy = strdup ( entry -> policy ) ;\n }\n if ( have_pol ) {\n if ( pol . pw_max_life ) {\n ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & ( kdb -> pw_expiration ) ) ;\n if ( ret ) goto done ;\n kdb -> pw_expiration += pol . pw_max_life ;\n }\n else {\n kdb -> pw_expiration = 0 ;\n }\n }\n if ( ( mask & KADM5_POLICY_CLR ) && ( adb . aux_attributes & KADM5_POLICY ) ) {\n free ( adb . policy ) ;\n adb . policy = NULL ;\n adb . aux_attributes &= ~ KADM5_POLICY ;\n kdb -> pw_expiration = 0 ;\n }\n if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ;\n if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ;\n if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ;\n if ( mask & KADM5_PW_EXPIRATION ) kdb -> pw_expiration = entry -> pw_expiration ;\n if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ;\n if ( ( mask & KADM5_KVNO ) ) {\n for ( i = 0 ;\n i < kdb -> n_key_data ;\n i ++ ) kdb -> key_data [ i ] . key_data_kvno = entry -> kvno ;\n }\n if ( mask & KADM5_TL_DATA ) {\n krb5_tl_data * tl ;\n for ( tl = entry -> tl_data ;\n tl ;\n tl = tl -> tl_data_next ) {\n ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl ) ;\n if ( ret ) {\n goto done ;\n }\n }\n }\n if ( mask & KADM5_FAIL_AUTH_COUNT ) {\n if ( entry -> fail_auth_count != 0 ) {\n ret = KADM5_BAD_SERVER_PARAMS ;\n goto done ;\n }\n kdb -> fail_auth_count = 0 ;\n }\n kdb -> mask = mask ;\n ret = k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask ) ;\n if ( ret ) goto done ;\n ret = kdb_put_entry ( handle , kdb , & adb ) ;\n if ( ret ) goto done ;\n ( void ) k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask ) ;\n ret = KADM5_OK ;\n done : if ( have_pol ) {\n ret2 = kadm5_free_policy_ent ( handle -> lhandle , & pol ) ;\n ret = ret ? ret : ret2 ;\n }\n kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }",
        "hash": 4704178797381506498,
        "project": "debian",
        "size": 88,
        "slice": {
            "free": [
                [
                    1,
                    "kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) {\n"
                ],
                [
                    28,
                    " if ( adb . policy ) free ( adb . policy ) ;\n"
                ],
                [
                    29,
                    " adb . policy = strdup ( entry -> policy ) ;\n"
                ],
                [
                    41,
                    " if ( ( mask & KADM5_POLICY_CLR ) && ( adb . aux_attributes & KADM5_POLICY ) ) {\n"
                ],
                [
                    42,
                    " free ( adb . policy ) ;\n"
                ]
            ],
            "strdup": [
                [
                    14,
                    " if ( entry == ( kadm5_principal_ent_t ) NULL ) return EINVAL ;\n"
                ],
                [
                    25,
                    " ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ;\n"
                ],
                [
                    26,
                    " if ( ret ) goto done ;\n"
                ],
                [
                    29,
                    " adb . policy = strdup ( entry -> policy ) ;\n"
                ],
                [
                    42,
                    " free ( adb . policy ) ;\n"
                ],
                [
                    76,
                    " ret = k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask ) ;\n"
                ],
                [
                    78,
                    " ret = kdb_put_entry ( handle , kdb , & adb ) ;\n"
                ],
                [
                    80,
                    " ( void ) k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask ) ;\n"
                ],
                [
                    86,
                    " kdb_free_entry ( handle , kdb , & adb ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) {\n"
                ],
                [
                    14,
                    " if ( entry == ( kadm5_principal_ent_t ) NULL ) return EINVAL ;\n"
                ],
                [
                    25,
                    " ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ;\n"
                ],
                [
                    26,
                    " if ( ret ) goto done ;\n"
                ],
                [
                    28,
                    " if ( adb . policy ) free ( adb . policy ) ;\n"
                ],
                [
                    29,
                    " adb . policy = strdup ( entry -> policy ) ;\n"
                ],
                [
                    41,
                    " if ( ( mask & KADM5_POLICY_CLR ) && ( adb . aux_attributes & KADM5_POLICY ) ) {\n"
                ],
                [
                    42,
                    " free ( adb . policy ) ;\n"
                ],
                [
                    76,
                    " ret = k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask ) ;\n"
                ],
                [
                    78,
                    " ret = kdb_put_entry ( handle , kdb , & adb ) ;\n"
                ],
                [
                    80,
                    " ( void ) k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask ) ;\n"
                ],
                [
                    86,
                    " kdb_free_entry ( handle , kdb , & adb ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) {\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n kadm5_policy_ent_rec polent ;\n krb5_boolean have_polent = FALSE ;\n krb5_int32 now ;\n krb5_tl_data * tl_data_tail ;\n unsigned int ret ;\n kadm5_server_handle_t handle = server_handle ;\n krb5_keyblock * act_mkey ;\n krb5_kvno act_kvno ;\n int new_n_ks_tuple = 0 ;\n krb5_key_salt_tuple * new_ks_tuple = NULL ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ;\n if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ;\n if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ;\n if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ;\n if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ;\n if ( entry == NULL ) return EINVAL ;\n ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;\n switch ( ret ) {\n case KADM5_UNK_PRINC : break ;\n case 0 : kdb_free_entry ( handle , kdb , & adb ) ;\n return KADM5_DUP ;\n default : return ret ;\n }\n kdb = krb5_db_alloc ( handle -> context , NULL , sizeof ( * kdb ) ) ;\n if ( kdb == NULL ) return ENOMEM ;\n memset ( kdb , 0 , sizeof ( * kdb ) ) ;\n memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ;\n if ( ( mask & KADM5_POLICY ) ) {\n ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ;\n if ( ret ) goto cleanup ;\n }\n if ( password ) {\n ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ;\n if ( ret ) goto cleanup ;\n }\n if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ;\n kdb -> magic = KRB5_KDB_MAGIC_NUMBER ;\n kdb -> len = KRB5_KDB_V1_BASE_LENGTH ;\n if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ;\n else kdb -> attributes = handle -> params . flags ;\n if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ;\n else kdb -> max_life = handle -> params . max_life ;\n if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ;\n else kdb -> max_renewable_life = handle -> params . max_rlife ;\n if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ;\n else kdb -> expiration = handle -> params . expiration ;\n kdb -> pw_expiration = 0 ;\n if ( have_polent ) {\n if ( polent . pw_max_life ) kdb -> pw_expiration = now + polent . pw_max_life ;\n else kdb -> pw_expiration = 0 ;\n }\n if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ;\n kdb -> last_success = 0 ;\n kdb -> last_failed = 0 ;\n kdb -> fail_auth_count = 0 ;\n if ( ( ret = kadm5_copy_principal ( handle -> context , entry -> principal , & ( kdb -> princ ) ) ) ) goto cleanup ;\n if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ;\n if ( mask & KADM5_TL_DATA ) {\n for ( tl_data_tail = entry -> tl_data ;\n tl_data_tail ;\n tl_data_tail = tl_data_tail -> tl_data_next ) {\n ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ;\n if ( ret ) goto cleanup ;\n }\n }\n ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ;\n if ( ret ) goto cleanup ;\n ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ;\n if ( ret ) goto cleanup ;\n if ( mask & KADM5_KEY_DATA ) {\n assert ( entry -> n_key_data == 0 ) ;\n }\n else if ( password ) {\n ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ;\n }\n else {\n ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ;\n }\n if ( ret ) goto cleanup ;\n ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;\n if ( ret ) goto cleanup ;\n ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n if ( ret ) goto cleanup ;\n adb . admin_history_kvno = INITIAL_HIST_KVNO ;\n if ( mask & KADM5_POLICY ) {\n adb . aux_attributes = KADM5_POLICY ;\n adb . policy = entry -> policy ;\n }\n kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n ret = kdb_put_entry ( handle , kdb , & adb ) ;\n ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n cleanup : free ( new_ks_tuple ) ;\n krb5_db_free_principal ( handle -> context , kdb ) ;\n if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ;\n return ret ;\n }",
        "hash": 4704178797381506498,
        "project": "debian",
        "size": 101,
        "slice": {
            "memset": [
                [
                    1,
                    "kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) {\n"
                ],
                [
                    22,
                    " ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;\n"
                ],
                [
                    30,
                    " if ( kdb == NULL ) return ENOMEM ;\n"
                ],
                [
                    31,
                    " memset ( kdb , 0 , sizeof ( * kdb ) ) ;\n"
                ],
                [
                    32,
                    " memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ;\n"
                ],
                [
                    61,
                    " if ( ( ret = kadm5_copy_principal ( handle -> context , entry -> principal , & ( kdb -> princ ) ) ) ) goto cleanup ;\n"
                ],
                [
                    62,
                    " if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ;\n"
                ],
                [
                    67,
                    " ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ;\n"
                ],
                [
                    79,
                    " ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ;\n"
                ],
                [
                    82,
                    " ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ;\n"
                ],
                [
                    85,
                    " ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;\n"
                ],
                [
                    95,
                    " ret = kdb_put_entry ( handle , kdb , & adb ) ;\n"
                ],
                [
                    98,
                    " krb5_db_free_principal ( handle -> context , kdb ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) {\n"
                ],
                [
                    13,
                    " krb5_key_salt_tuple * new_ks_tuple = NULL ;\n"
                ],
                [
                    30,
                    " if ( kdb == NULL ) return ENOMEM ;\n"
                ],
                [
                    71,
                    " ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ;\n"
                ],
                [
                    79,
                    " ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ;\n"
                ],
                [
                    82,
                    " ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ;\n"
                ],
                [
                    87,
                    " ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n"
                ],
                [
                    96,
                    " ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n"
                ],
                [
                    97,
                    " cleanup : free ( new_ks_tuple ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) {\n"
                ],
                [
                    13,
                    " krb5_key_salt_tuple * new_ks_tuple = NULL ;\n"
                ],
                [
                    22,
                    " ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;\n"
                ],
                [
                    30,
                    " if ( kdb == NULL ) return ENOMEM ;\n"
                ],
                [
                    31,
                    " memset ( kdb , 0 , sizeof ( * kdb ) ) ;\n"
                ],
                [
                    32,
                    " memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ;\n"
                ],
                [
                    61,
                    " if ( ( ret = kadm5_copy_principal ( handle -> context , entry -> principal , & ( kdb -> princ ) ) ) ) goto cleanup ;\n"
                ],
                [
                    62,
                    " if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ;\n"
                ],
                [
                    67,
                    " ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ;\n"
                ],
                [
                    71,
                    " ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ;\n"
                ],
                [
                    79,
                    " ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ;\n"
                ],
                [
                    82,
                    " ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ;\n"
                ],
                [
                    85,
                    " ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;\n"
                ],
                [
                    87,
                    " ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n"
                ],
                [
                    95,
                    " ret = kdb_put_entry ( handle , kdb , & adb ) ;\n"
                ],
                [
                    96,
                    " ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n"
                ],
                [
                    97,
                    " cleanup : free ( new_ks_tuple ) ;\n"
                ],
                [
                    98,
                    " krb5_db_free_principal ( handle -> context , kdb ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int pefromupx ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 , uint32_t * magic , uint32_t dend ) {\n char * imports , * sections = NULL , * pehdr = NULL , * newbuf ;\n unsigned int sectcnt = 0 , upd = 1 ;\n uint32_t realstuffsz = 0 , valign = 0 ;\n uint32_t foffset = 0xd0 + 0xf8 ;\n if ( ( dst == NULL ) || ( src == NULL ) ) return 0 ;\n while ( ( valign = magic [ sectcnt ++ ] ) ) {\n if ( ep - upx1 + valign <= ssize - 5 && src [ ep - upx1 + valign - 2 ] == '\\x8d' && src [ ep - upx1 + valign - 1 ] == '\\xbe' ) break ;\n }\n if ( ! valign && ep - upx1 + 0x80 < ssize - 8 ) {\n const char * pt = & src [ ep - upx1 + 0x80 ] ;\n cli_dbgmsg ( \"UPX: bad magic - scanning for imports\\n\" ) ;\n while ( ( pt = cli_memstr ( pt , ssize - ( pt - src ) - 8 , \"\\x8d\\xbe\" , 2 ) ) ) {\n if ( pt [ 6 ] == '\\x8b' && pt [ 7 ] == '\\x07' ) {\n valign = pt - src + 2 - ep + upx1 ;\n break ;\n }\n pt ++ ;\n }\n }\n if ( valign && CLI_ISCONTAINED ( src , ssize , src + ep - upx1 + valign , 4 ) ) {\n imports = dst + cli_readint32 ( src + ep - upx1 + valign ) ;\n realstuffsz = imports - dst ;\n if ( realstuffsz >= * dsize ) {\n cli_dbgmsg ( \"UPX: wrong realstuff size\\n\" ) ;\n }\n else {\n pehdr = imports ;\n while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 8 ) && cli_readint32 ( pehdr ) ) {\n pehdr += 8 ;\n while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) {\n pehdr ++ ;\n while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) pehdr ++ ;\n pehdr ++ ;\n }\n pehdr ++ ;\n }\n pehdr += 4 ;\n if ( ! ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) pehdr = NULL ;\n }\n }\n if ( ! pehdr && dend > 0xf8 + 0x28 ) {\n cli_dbgmsg ( \"UPX: no luck - scanning for PE\\n\" ) ;\n pehdr = & dst [ dend - 0xf8 - 0x28 ] ;\n while ( pehdr > dst ) {\n if ( ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) break ;\n pehdr -- ;\n }\n if ( ! ( realstuffsz = pehdr - dst ) ) pehdr = NULL ;\n }\n if ( ! pehdr ) {\n uint32_t rebsz = PESALIGN ( dend , 0x1000 ) ;\n cli_dbgmsg ( \"UPX: no luck - brutally crafing a reasonable PE\\n\" ) ;\n if ( ! ( newbuf = ( char * ) cli_calloc ( rebsz + 0x200 , sizeof ( char ) ) ) ) {\n cli_dbgmsg ( \"UPX: malloc failed - giving up rebuild\\n\" ) ;\n return 0 ;\n }\n memcpy ( newbuf , HEADERS , 0xd0 ) ;\n memcpy ( newbuf + 0xd0 , FAKEPE , 0x120 ) ;\n memcpy ( newbuf + 0x200 , dst , dend ) ;\n memcpy ( dst , newbuf , dend + 0x200 ) ;\n free ( newbuf ) ;\n cli_writeint32 ( dst + 0xd0 + 0x50 , rebsz + 0x1000 ) ;\n cli_writeint32 ( dst + 0xd0 + 0x100 , rebsz ) ;\n cli_writeint32 ( dst + 0xd0 + 0x108 , rebsz ) ;\n * dsize = rebsz + 0x200 ;\n cli_dbgmsg ( \"UPX: PE structure added to uncompressed data\\n\" ) ;\n return 1 ;\n }\n if ( ! sections ) sectcnt = 0 ;\n foffset = PESALIGN ( foffset + 0x28 * sectcnt , valign ) ;\n for ( upd = 0 ;\n upd < sectcnt ;\n upd ++ ) {\n uint32_t vsize = PESALIGN ( ( uint32_t ) cli_readint32 ( sections + 8 ) , valign ) ;\n uint32_t urva = PEALIGN ( ( uint32_t ) cli_readint32 ( sections + 12 ) , valign ) ;\n if ( ! CLI_ISCONTAINED ( upx0 , realstuffsz , urva , vsize ) ) {\n cli_dbgmsg ( \"UPX: Sect %d out of bounds - giving up rebuild\\n\" , upd ) ;\n return 0 ;\n }\n cli_writeint32 ( sections + 8 , vsize ) ;\n cli_writeint32 ( sections + 12 , urva ) ;\n cli_writeint32 ( sections + 16 , vsize ) ;\n cli_writeint32 ( sections + 20 , foffset ) ;\n if ( foffset + vsize < foffset ) {\n return 0 ;\n }\n foffset += vsize ;\n sections += 0x28 ;\n }\n cli_writeint32 ( pehdr + 8 , 0x4d414c43 ) ;\n cli_writeint32 ( pehdr + 0x3c , valign ) ;\n if ( ! ( newbuf = ( char * ) cli_calloc ( foffset , sizeof ( char ) ) ) ) {\n cli_dbgmsg ( \"UPX: malloc failed - giving up rebuild\\n\" ) ;\n return 0 ;\n }\n memcpy ( newbuf , HEADERS , 0xd0 ) ;\n memcpy ( newbuf + 0xd0 , pehdr , 0xf8 + 0x28 * sectcnt ) ;\n sections = pehdr + 0xf8 ;\n for ( upd = 0 ;\n upd < sectcnt ;\n upd ++ ) {\n uint32_t offset1 , offset2 , offset3 ;\n offset1 = ( uint32_t ) cli_readint32 ( sections + 20 ) ;\n offset2 = ( uint32_t ) cli_readint32 ( sections + 16 ) ;\n if ( offset1 > foffset || offset2 > foffset || offset1 + offset2 > foffset ) {\n free ( newbuf ) ;\n return 1 ;\n }\n offset3 = ( uint32_t ) cli_readint32 ( sections + 12 ) ;\n if ( offset3 - upx0 > * dsize ) {\n free ( newbuf ) ;\n return 1 ;\n }\n memcpy ( newbuf + offset1 , dst + offset3 - upx0 , offset2 ) ;\n sections += 0x28 ;\n }\n if ( foffset > * dsize + 8192 ) {\n cli_dbgmsg ( \"UPX: wrong raw size - giving up rebuild\\n\" ) ;\n free ( newbuf ) ;\n return 0 ;\n }\n memcpy ( dst , newbuf , foffset ) ;\n * dsize = foffset ;\n free ( newbuf ) ;\n cli_dbgmsg ( \"UPX: PE structure rebuilt from compressed file\\n\" ) ;\n return 1 ;\n }",
        "hash": -8745685032143262400,
        "project": "debian",
        "size": 128,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int pefromupx ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 , uint32_t * magic , uint32_t dend ) {\n"
                ],
                [
                    6,
                    " if ( ( dst == NULL ) || ( src == NULL ) ) return 0 ;\n"
                ],
                [
                    23,
                    " realstuffsz = imports - dst ;\n"
                ],
                [
                    31,
                    " while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) {\n"
                ],
                [
                    39,
                    " if ( ! ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) pehdr = NULL ;\n"
                ],
                [
                    49,
                    " if ( ! ( realstuffsz = pehdr - dst ) ) pehdr = NULL ;\n"
                ],
                [
                    51,
                    " if ( ! pehdr ) {\n"
                ],
                [
                    52,
                    " uint32_t rebsz = PESALIGN ( dend , 0x1000 ) ;\n"
                ],
                [
                    54,
                    " if ( ! ( newbuf = ( char * ) cli_calloc ( rebsz + 0x200 , sizeof ( char ) ) ) ) {\n"
                ],
                [
                    58,
                    " memcpy ( newbuf , HEADERS , 0xd0 ) ;\n"
                ],
                [
                    59,
                    " memcpy ( newbuf + 0xd0 , FAKEPE , 0x120 ) ;\n"
                ],
                [
                    60,
                    " memcpy ( newbuf + 0x200 , dst , dend ) ;\n"
                ],
                [
                    61,
                    " memcpy ( dst , newbuf , dend + 0x200 ) ;\n"
                ],
                [
                    62,
                    " free ( newbuf ) ;\n"
                ],
                [
                    63,
                    " cli_writeint32 ( dst + 0xd0 + 0x50 , rebsz + 0x1000 ) ;\n"
                ],
                [
                    64,
                    " cli_writeint32 ( dst + 0xd0 + 0x100 , rebsz ) ;\n"
                ],
                [
                    65,
                    " cli_writeint32 ( dst + 0xd0 + 0x108 , rebsz ) ;\n"
                ],
                [
                    93,
                    " if ( ! ( newbuf = ( char * ) cli_calloc ( foffset , sizeof ( char ) ) ) ) {\n"
                ],
                [
                    97,
                    " memcpy ( newbuf , HEADERS , 0xd0 ) ;\n"
                ],
                [
                    98,
                    " memcpy ( newbuf + 0xd0 , pehdr , 0xf8 + 0x28 * sectcnt ) ;\n"
                ],
                [
                    99,
                    " sections = pehdr + 0xf8 ;\n"
                ],
                [
                    105,
                    " offset2 = ( uint32_t ) cli_readint32 ( sections + 16 ) ;\n"
                ],
                [
                    106,
                    " if ( offset1 > foffset || offset2 > foffset || offset1 + offset2 > foffset ) {\n"
                ],
                [
                    107,
                    " free ( newbuf ) ;\n"
                ],
                [
                    111,
                    " if ( offset3 - upx0 > * dsize ) {\n"
                ],
                [
                    112,
                    " free ( newbuf ) ;\n"
                ],
                [
                    115,
                    " memcpy ( newbuf + offset1 , dst + offset3 - upx0 , offset2 ) ;\n"
                ],
                [
                    118,
                    " if ( foffset > * dsize + 8192 ) {\n"
                ],
                [
                    120,
                    " free ( newbuf ) ;\n"
                ],
                [
                    123,
                    " memcpy ( dst , newbuf , foffset ) ;\n"
                ],
                [
                    124,
                    " * dsize = foffset ;\n"
                ],
                [
                    125,
                    " free ( newbuf ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static int pefromupx ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 , uint32_t * magic , uint32_t dend ) {\n"
                ],
                [
                    54,
                    " if ( ! ( newbuf = ( char * ) cli_calloc ( rebsz + 0x200 , sizeof ( char ) ) ) ) {\n"
                ],
                [
                    61,
                    " memcpy ( dst , newbuf , dend + 0x200 ) ;\n"
                ],
                [
                    62,
                    " free ( newbuf ) ;\n"
                ],
                [
                    97,
                    " memcpy ( newbuf , HEADERS , 0xd0 ) ;\n"
                ],
                [
                    106,
                    " if ( offset1 > foffset || offset2 > foffset || offset1 + offset2 > foffset ) {\n"
                ],
                [
                    107,
                    " free ( newbuf ) ;\n"
                ],
                [
                    111,
                    " if ( offset3 - upx0 > * dsize ) {\n"
                ],
                [
                    112,
                    " free ( newbuf ) ;\n"
                ],
                [
                    118,
                    " if ( foffset > * dsize + 8192 ) {\n"
                ],
                [
                    120,
                    " free ( newbuf ) ;\n"
                ],
                [
                    123,
                    " memcpy ( dst , newbuf , foffset ) ;\n"
                ],
                [
                    125,
                    " free ( newbuf ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int pefromupx ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 , uint32_t * magic , uint32_t dend ) {\n"
                ],
                [
                    6,
                    " if ( ( dst == NULL ) || ( src == NULL ) ) return 0 ;\n"
                ],
                [
                    23,
                    " realstuffsz = imports - dst ;\n"
                ],
                [
                    31,
                    " while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) {\n"
                ],
                [
                    39,
                    " if ( ! ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) pehdr = NULL ;\n"
                ],
                [
                    49,
                    " if ( ! ( realstuffsz = pehdr - dst ) ) pehdr = NULL ;\n"
                ],
                [
                    51,
                    " if ( ! pehdr ) {\n"
                ],
                [
                    52,
                    " uint32_t rebsz = PESALIGN ( dend , 0x1000 ) ;\n"
                ],
                [
                    54,
                    " if ( ! ( newbuf = ( char * ) cli_calloc ( rebsz + 0x200 , sizeof ( char ) ) ) ) {\n"
                ],
                [
                    58,
                    " memcpy ( newbuf , HEADERS , 0xd0 ) ;\n"
                ],
                [
                    59,
                    " memcpy ( newbuf + 0xd0 , FAKEPE , 0x120 ) ;\n"
                ],
                [
                    60,
                    " memcpy ( newbuf + 0x200 , dst , dend ) ;\n"
                ],
                [
                    61,
                    " memcpy ( dst , newbuf , dend + 0x200 ) ;\n"
                ],
                [
                    62,
                    " free ( newbuf ) ;\n"
                ],
                [
                    63,
                    " cli_writeint32 ( dst + 0xd0 + 0x50 , rebsz + 0x1000 ) ;\n"
                ],
                [
                    64,
                    " cli_writeint32 ( dst + 0xd0 + 0x100 , rebsz ) ;\n"
                ],
                [
                    65,
                    " cli_writeint32 ( dst + 0xd0 + 0x108 , rebsz ) ;\n"
                ],
                [
                    93,
                    " if ( ! ( newbuf = ( char * ) cli_calloc ( foffset , sizeof ( char ) ) ) ) {\n"
                ],
                [
                    97,
                    " memcpy ( newbuf , HEADERS , 0xd0 ) ;\n"
                ],
                [
                    98,
                    " memcpy ( newbuf + 0xd0 , pehdr , 0xf8 + 0x28 * sectcnt ) ;\n"
                ],
                [
                    99,
                    " sections = pehdr + 0xf8 ;\n"
                ],
                [
                    105,
                    " offset2 = ( uint32_t ) cli_readint32 ( sections + 16 ) ;\n"
                ],
                [
                    106,
                    " if ( offset1 > foffset || offset2 > foffset || offset1 + offset2 > foffset ) {\n"
                ],
                [
                    107,
                    " free ( newbuf ) ;\n"
                ],
                [
                    111,
                    " if ( offset3 - upx0 > * dsize ) {\n"
                ],
                [
                    112,
                    " free ( newbuf ) ;\n"
                ],
                [
                    115,
                    " memcpy ( newbuf + offset1 , dst + offset3 - upx0 , offset2 ) ;\n"
                ],
                [
                    118,
                    " if ( foffset > * dsize + 8192 ) {\n"
                ],
                [
                    120,
                    " free ( newbuf ) ;\n"
                ],
                [
                    123,
                    " memcpy ( dst , newbuf , foffset ) ;\n"
                ],
                [
                    124,
                    " * dsize = foffset ;\n"
                ],
                [
                    125,
                    " free ( newbuf ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "gpg_err_code_t _gcry_ecc_fill_in_curve ( unsigned int nbits , const char * name , elliptic_curve_t * curve , unsigned int * r_nbits ) {\n int idx , aliasno ;\n const char * resname = NULL ;\n if ( name ) {\n for ( idx = 0 ;\n domain_parms [ idx ] . desc ;\n idx ++ ) if ( ! strcmp ( name , domain_parms [ idx ] . desc ) ) {\n resname = domain_parms [ idx ] . desc ;\n break ;\n }\n if ( ! domain_parms [ idx ] . desc ) {\n for ( aliasno = 0 ;\n curve_aliases [ aliasno ] . name ;\n aliasno ++ ) if ( ! strcmp ( name , curve_aliases [ aliasno ] . other ) ) break ;\n if ( curve_aliases [ aliasno ] . name ) {\n for ( idx = 0 ;\n domain_parms [ idx ] . desc ;\n idx ++ ) if ( ! strcmp ( curve_aliases [ aliasno ] . name , domain_parms [ idx ] . desc ) ) {\n resname = domain_parms [ idx ] . desc ;\n break ;\n }\n }\n }\n }\n else {\n for ( idx = 0 ;\n domain_parms [ idx ] . desc ;\n idx ++ ) if ( nbits == domain_parms [ idx ] . nbits ) break ;\n }\n if ( ! domain_parms [ idx ] . desc ) return GPG_ERR_UNKNOWN_CURVE ;\n if ( fips_mode ( ) && ! domain_parms [ idx ] . fips ) return GPG_ERR_NOT_SUPPORTED ;\n switch ( domain_parms [ idx ] . model ) {\n case MPI_EC_WEIERSTRASS : case MPI_EC_TWISTEDEDWARDS : break ;\n case MPI_EC_MONTGOMERY : return GPG_ERR_NOT_SUPPORTED ;\n default : return GPG_ERR_BUG ;\n }\n if ( r_nbits ) * r_nbits = domain_parms [ idx ] . nbits ;\n curve -> model = domain_parms [ idx ] . model ;\n curve -> p = scanval ( domain_parms [ idx ] . p ) ;\n curve -> a = scanval ( domain_parms [ idx ] . a ) ;\n curve -> b = scanval ( domain_parms [ idx ] . b ) ;\n curve -> n = scanval ( domain_parms [ idx ] . n ) ;\n curve -> G . x = scanval ( domain_parms [ idx ] . g_x ) ;\n curve -> G . y = scanval ( domain_parms [ idx ] . g_y ) ;\n curve -> G . z = mpi_alloc_set_ui ( 1 ) ;\n curve -> name = resname ;\n return 0 ;\n }",
        "hash": -8863722328038948117,
        "project": "debian",
        "size": 48,
        "slice": {
            "strcmp": [
                [
                    1,
                    "gpg_err_code_t _gcry_ecc_fill_in_curve ( unsigned int nbits , const char * name , elliptic_curve_t * curve , unsigned int * r_nbits ) {\n"
                ],
                [
                    6,
                    " domain_parms [ idx ] . desc ;\n"
                ],
                [
                    7,
                    " idx ++ ) if ( ! strcmp ( name , domain_parms [ idx ] . desc ) ) {\n"
                ],
                [
                    8,
                    " resname = domain_parms [ idx ] . desc ;\n"
                ],
                [
                    11,
                    " if ( ! domain_parms [ idx ] . desc ) {\n"
                ],
                [
                    13,
                    " curve_aliases [ aliasno ] . name ;\n"
                ],
                [
                    14,
                    " aliasno ++ ) if ( ! strcmp ( name , curve_aliases [ aliasno ] . other ) ) break ;\n"
                ],
                [
                    17,
                    " domain_parms [ idx ] . desc ;\n"
                ],
                [
                    18,
                    " idx ++ ) if ( ! strcmp ( curve_aliases [ aliasno ] . name , domain_parms [ idx ] . desc ) ) {\n"
                ],
                [
                    19,
                    " resname = domain_parms [ idx ] . desc ;\n"
                ],
                [
                    30,
                    " if ( ! domain_parms [ idx ] . desc ) return GPG_ERR_UNKNOWN_CURVE ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "gpg_err_code_t _gcry_ecc_fill_in_curve ( unsigned int nbits , const char * name , elliptic_curve_t * curve , unsigned int * r_nbits ) {\n"
                ],
                [
                    6,
                    " domain_parms [ idx ] . desc ;\n"
                ],
                [
                    7,
                    " idx ++ ) if ( ! strcmp ( name , domain_parms [ idx ] . desc ) ) {\n"
                ],
                [
                    8,
                    " resname = domain_parms [ idx ] . desc ;\n"
                ],
                [
                    11,
                    " if ( ! domain_parms [ idx ] . desc ) {\n"
                ],
                [
                    13,
                    " curve_aliases [ aliasno ] . name ;\n"
                ],
                [
                    14,
                    " aliasno ++ ) if ( ! strcmp ( name , curve_aliases [ aliasno ] . other ) ) break ;\n"
                ],
                [
                    17,
                    " domain_parms [ idx ] . desc ;\n"
                ],
                [
                    18,
                    " idx ++ ) if ( ! strcmp ( curve_aliases [ aliasno ] . name , domain_parms [ idx ] . desc ) ) {\n"
                ],
                [
                    19,
                    " resname = domain_parms [ idx ] . desc ;\n"
                ],
                [
                    30,
                    " if ( ! domain_parms [ idx ] . desc ) return GPG_ERR_UNKNOWN_CURVE ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * * argv ) {\n if ( argc > 1 && ! strcmp ( argv [ 1 ] , \"--verbose\" ) ) verbose = 1 ;\n else if ( argc > 1 && ! strcmp ( argv [ 1 ] , \"--debug\" ) ) verbose = debug = 1 ;\n if ( ! gcry_check_version ( GCRYPT_VERSION ) ) die ( \"version mismatch\\n\" ) ;\n gcry_control ( GCRYCTL_DISABLE_SECMEM , 0 ) ;\n gcry_control ( GCRYCTL_ENABLE_QUICK_RANDOM , 0 ) ;\n if ( debug ) gcry_control ( GCRYCTL_SET_DEBUG_FLAGS , 1u , 0 ) ;\n gcry_control ( GCRYCTL_INITIALIZATION_FINISHED , 0 ) ;\n set_get_point ( ) ;\n context_alloc ( ) ;\n context_param ( ) ;\n basic_ec_math ( ) ;\n basic_ec_math_simplified ( ) ;\n show ( \"All tests completed. Errors: %d\\n\" , error_count ) ;\n return error_count ? 1 : 0 ;\n }",
        "hash": -6474315190511670247,
        "project": "debian",
        "size": 16,
        "slice": {
            "strcmp": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    2,
                    " if ( argc > 1 && ! strcmp ( argv [ 1 ] , \"--verbose\" ) ) verbose = 1 ;\n"
                ],
                [
                    3,
                    " else if ( argc > 1 && ! strcmp ( argv [ 1 ] , \"--debug\" ) ) verbose = debug = 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    2,
                    " if ( argc > 1 && ! strcmp ( argv [ 1 ] , \"--verbose\" ) ) verbose = 1 ;\n"
                ],
                [
                    3,
                    " else if ( argc > 1 && ! strcmp ( argv [ 1 ] , \"--debug\" ) ) verbose = debug = 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "gcry_error_t gcry_mpi_print ( enum gcry_mpi_format format , unsigned char * buffer , size_t buflen , size_t * nwritten , struct gcry_mpi * a ) {\n unsigned int nbits = mpi_get_nbits ( a ) ;\n size_t len ;\n size_t dummy_nwritten ;\n int negative ;\n if ( ! nwritten ) nwritten = & dummy_nwritten ;\n if ( a -> sign && _gcry_mpi_cmp_ui ( a , 0 ) ) negative = 1 ;\n else negative = 0 ;\n len = buflen ;\n * nwritten = 0 ;\n if ( format == GCRYMPI_FMT_STD ) {\n unsigned char * tmp ;\n int extra = 0 ;\n unsigned int n ;\n if ( negative ) return gcry_error ( GPG_ERR_INTERNAL ) ;\n tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n if ( n && ( * tmp & 0x80 ) ) {\n n ++ ;\n extra = 1 ;\n }\n if ( buffer && n > len ) {\n gcry_free ( tmp ) ;\n return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n }\n if ( buffer ) {\n unsigned char * s = buffer ;\n if ( extra ) * s ++ = 0 ;\n memcpy ( s , tmp , n - extra ) ;\n }\n gcry_free ( tmp ) ;\n * nwritten = n ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_USG ) {\n unsigned int n = ( nbits + 7 ) / 8 ;\n if ( buffer && n > len ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n if ( buffer ) {\n unsigned char * tmp ;\n tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n memcpy ( buffer , tmp , n ) ;\n gcry_free ( tmp ) ;\n }\n * nwritten = n ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_PGP ) {\n unsigned int n = ( nbits + 7 ) / 8 ;\n if ( negative ) return gcry_error ( GPG_ERR_INV_ARG ) ;\n if ( buffer && n + 2 > len ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n if ( buffer ) {\n unsigned char * tmp ;\n unsigned char * s = buffer ;\n s [ 0 ] = nbits >> 8 ;\n s [ 1 ] = nbits ;\n tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n memcpy ( s + 2 , tmp , n ) ;\n gcry_free ( tmp ) ;\n }\n * nwritten = n + 2 ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_SSH ) {\n unsigned char * tmp ;\n int extra = 0 ;\n unsigned int n ;\n if ( negative ) return gcry_error ( GPG_ERR_INTERNAL ) ;\n tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n if ( n && ( * tmp & 0x80 ) ) {\n n ++ ;\n extra = 1 ;\n }\n if ( buffer && n + 4 > len ) {\n gcry_free ( tmp ) ;\n return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n }\n if ( buffer ) {\n unsigned char * s = buffer ;\n * s ++ = n >> 24 ;\n * s ++ = n >> 16 ;\n * s ++ = n >> 8 ;\n * s ++ = n ;\n if ( extra ) * s ++ = 0 ;\n memcpy ( s , tmp , n - extra ) ;\n }\n gcry_free ( tmp ) ;\n * nwritten = 4 + n ;\n return 0 ;\n }\n else if ( format == GCRYMPI_FMT_HEX ) {\n unsigned char * tmp ;\n int i ;\n int extra = 0 ;\n unsigned int n = 0 ;\n tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n if ( ! n || ( * tmp & 0x80 ) ) extra = 2 ;\n if ( buffer && 2 * n + extra + negative + 1 > len ) {\n gcry_free ( tmp ) ;\n return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n }\n if ( buffer ) {\n unsigned char * s = buffer ;\n if ( negative ) * s ++ = '-' ;\n if ( extra ) {\n * s ++ = '0' ;\n * s ++ = '0' ;\n }\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n unsigned int c = tmp [ i ] ;\n * s ++ = ( c >> 4 ) < 10 ? '0' + ( c >> 4 ) : 'A' + ( c >> 4 ) - 10 ;\n c &= 15 ;\n * s ++ = c < 10 ? '0' + c : 'A' + c - 10 ;\n }\n * s ++ = 0 ;\n * nwritten = s - buffer ;\n }\n else {\n * nwritten = 2 * n + extra + negative + 1 ;\n }\n gcry_free ( tmp ) ;\n return 0 ;\n }\n else return gcry_error ( GPG_ERR_INV_ARG ) ;\n }",
        "hash": 1460203986417252430,
        "project": "debian",
        "size": 130,
        "slice": {
            "memcpy": [
                [
                    1,
                    "gcry_error_t gcry_mpi_print ( enum gcry_mpi_format format , unsigned char * buffer , size_t buflen , size_t * nwritten , struct gcry_mpi * a ) {\n"
                ],
                [
                    17,
                    " if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    18,
                    " if ( n && ( * tmp & 0x80 ) ) {\n"
                ],
                [
                    26,
                    " if ( buffer ) {\n"
                ],
                [
                    27,
                    " unsigned char * s = buffer ;\n"
                ],
                [
                    28,
                    " if ( extra ) * s ++ = 0 ;\n"
                ],
                [
                    29,
                    " memcpy ( s , tmp , n - extra ) ;\n"
                ],
                [
                    31,
                    " gcry_free ( tmp ) ;\n"
                ],
                [
                    36,
                    " unsigned int n = ( nbits + 7 ) / 8 ;\n"
                ],
                [
                    37,
                    " if ( buffer && n > len ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n"
                ],
                [
                    40,
                    " tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n"
                ],
                [
                    41,
                    " if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    42,
                    " memcpy ( buffer , tmp , n ) ;\n"
                ],
                [
                    43,
                    " gcry_free ( tmp ) ;\n"
                ],
                [
                    45,
                    " * nwritten = n ;\n"
                ],
                [
                    49,
                    " unsigned int n = ( nbits + 7 ) / 8 ;\n"
                ],
                [
                    54,
                    " unsigned char * s = buffer ;\n"
                ],
                [
                    55,
                    " s [ 0 ] = nbits >> 8 ;\n"
                ],
                [
                    56,
                    " s [ 1 ] = nbits ;\n"
                ],
                [
                    57,
                    " tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n"
                ],
                [
                    58,
                    " if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    59,
                    " memcpy ( s + 2 , tmp , n ) ;\n"
                ],
                [
                    60,
                    " gcry_free ( tmp ) ;\n"
                ],
                [
                    62,
                    " * nwritten = n + 2 ;\n"
                ],
                [
                    71,
                    " if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    72,
                    " if ( n && ( * tmp & 0x80 ) ) {\n"
                ],
                [
                    80,
                    " if ( buffer ) {\n"
                ],
                [
                    85,
                    " * s ++ = n ;\n"
                ],
                [
                    86,
                    " if ( extra ) * s ++ = 0 ;\n"
                ],
                [
                    87,
                    " memcpy ( s , tmp , n - extra ) ;\n"
                ],
                [
                    89,
                    " gcry_free ( tmp ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "gcry_error_t gcry_mpi_print ( enum gcry_mpi_format format , unsigned char * buffer , size_t buflen , size_t * nwritten , struct gcry_mpi * a ) {\n"
                ],
                [
                    17,
                    " if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    18,
                    " if ( n && ( * tmp & 0x80 ) ) {\n"
                ],
                [
                    26,
                    " if ( buffer ) {\n"
                ],
                [
                    27,
                    " unsigned char * s = buffer ;\n"
                ],
                [
                    28,
                    " if ( extra ) * s ++ = 0 ;\n"
                ],
                [
                    29,
                    " memcpy ( s , tmp , n - extra ) ;\n"
                ],
                [
                    31,
                    " gcry_free ( tmp ) ;\n"
                ],
                [
                    36,
                    " unsigned int n = ( nbits + 7 ) / 8 ;\n"
                ],
                [
                    37,
                    " if ( buffer && n > len ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n"
                ],
                [
                    40,
                    " tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n"
                ],
                [
                    41,
                    " if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    42,
                    " memcpy ( buffer , tmp , n ) ;\n"
                ],
                [
                    43,
                    " gcry_free ( tmp ) ;\n"
                ],
                [
                    45,
                    " * nwritten = n ;\n"
                ],
                [
                    49,
                    " unsigned int n = ( nbits + 7 ) / 8 ;\n"
                ],
                [
                    54,
                    " unsigned char * s = buffer ;\n"
                ],
                [
                    55,
                    " s [ 0 ] = nbits >> 8 ;\n"
                ],
                [
                    56,
                    " s [ 1 ] = nbits ;\n"
                ],
                [
                    57,
                    " tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n"
                ],
                [
                    58,
                    " if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    59,
                    " memcpy ( s + 2 , tmp , n ) ;\n"
                ],
                [
                    60,
                    " gcry_free ( tmp ) ;\n"
                ],
                [
                    62,
                    " * nwritten = n + 2 ;\n"
                ],
                [
                    71,
                    " if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    72,
                    " if ( n && ( * tmp & 0x80 ) ) {\n"
                ],
                [
                    80,
                    " if ( buffer ) {\n"
                ],
                [
                    85,
                    " * s ++ = n ;\n"
                ],
                [
                    86,
                    " if ( extra ) * s ++ = 0 ;\n"
                ],
                [
                    87,
                    " memcpy ( s , tmp , n - extra ) ;\n"
                ],
                [
                    89,
                    " gcry_free ( tmp ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static gcry_err_code_t sexp_to_sig ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo ) {\n gcry_err_code_t err = 0 ;\n gcry_sexp_t list , l2 ;\n char * name ;\n const char * elems ;\n gcry_mpi_t * array ;\n gcry_module_t module ;\n gcry_pk_spec_t * pubkey ;\n list = gcry_sexp_find_token ( sexp , \"sig-val\" , 0 ) ;\n if ( ! list ) return GPG_ERR_INV_OBJ ;\n l2 = gcry_sexp_nth ( list , 1 ) ;\n if ( ! l2 ) {\n gcry_sexp_release ( list ) ;\n return GPG_ERR_NO_OBJ ;\n }\n name = _gcry_sexp_nth_string ( l2 , 0 ) ;\n if ( ! name ) {\n gcry_sexp_release ( list ) ;\n gcry_sexp_release ( l2 ) ;\n return GPG_ERR_INV_OBJ ;\n }\n else if ( ! strcmp ( name , \"flags\" ) ) {\n gcry_free ( name ) ;\n gcry_sexp_release ( l2 ) ;\n l2 = gcry_sexp_nth ( list , 2 ) ;\n if ( ! l2 ) {\n gcry_sexp_release ( list ) ;\n return GPG_ERR_INV_OBJ ;\n }\n name = _gcry_sexp_nth_string ( l2 , 0 ) ;\n }\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n module = gcry_pk_lookup_name ( name ) ;\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n gcry_free ( name ) ;\n name = NULL ;\n if ( ! module ) {\n gcry_sexp_release ( l2 ) ;\n gcry_sexp_release ( list ) ;\n return GPG_ERR_PUBKEY_ALGO ;\n }\n else pubkey = ( gcry_pk_spec_t * ) module -> spec ;\n elems = pubkey -> elements_sig ;\n array = gcry_calloc ( strlen ( elems ) + 1 , sizeof * array ) ;\n if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n if ( ! err ) err = sexp_elements_extract ( list , elems , array , NULL ) ;\n gcry_sexp_release ( l2 ) ;\n gcry_sexp_release ( list ) ;\n if ( err ) {\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n _gcry_module_release ( module ) ;\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n gcry_free ( array ) ;\n }\n else {\n * retarray = array ;\n * retalgo = module ;\n }\n return err ;\n }",
        "hash": -7795592811940874822,
        "project": "debian",
        "size": 60,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_sig ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo ) {\n"
                ],
                [
                    17,
                    " if ( ! name ) {\n"
                ],
                [
                    22,
                    " else if ( ! strcmp ( name , \"flags\" ) ) {\n"
                ],
                [
                    23,
                    " gcry_free ( name ) ;\n"
                ],
                [
                    24,
                    " gcry_sexp_release ( l2 ) ;\n"
                ],
                [
                    25,
                    " l2 = gcry_sexp_nth ( list , 2 ) ;\n"
                ],
                [
                    26,
                    " if ( ! l2 ) {\n"
                ],
                [
                    32,
                    " ath_mutex_lock ( & pubkeys_registered_lock ) ;\n"
                ],
                [
                    33,
                    " module = gcry_pk_lookup_name ( name ) ;\n"
                ],
                [
                    34,
                    " ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n"
                ],
                [
                    35,
                    " gcry_free ( name ) ;\n"
                ],
                [
                    36,
                    " name = NULL ;\n"
                ],
                [
                    37,
                    " if ( ! module ) {\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_sig ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo ) {\n"
                ],
                [
                    37,
                    " if ( ! module ) {\n"
                ],
                [
                    43,
                    " elems = pubkey -> elements_sig ;\n"
                ],
                [
                    44,
                    " array = gcry_calloc ( strlen ( elems ) + 1 , sizeof * array ) ;\n"
                ],
                [
                    45,
                    " if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    46,
                    " if ( ! err ) err = sexp_elements_extract ( list , elems , array , NULL ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_sig ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo ) {\n"
                ],
                [
                    17,
                    " if ( ! name ) {\n"
                ],
                [
                    22,
                    " else if ( ! strcmp ( name , \"flags\" ) ) {\n"
                ],
                [
                    23,
                    " gcry_free ( name ) ;\n"
                ],
                [
                    24,
                    " gcry_sexp_release ( l2 ) ;\n"
                ],
                [
                    25,
                    " l2 = gcry_sexp_nth ( list , 2 ) ;\n"
                ],
                [
                    26,
                    " if ( ! l2 ) {\n"
                ],
                [
                    32,
                    " ath_mutex_lock ( & pubkeys_registered_lock ) ;\n"
                ],
                [
                    33,
                    " module = gcry_pk_lookup_name ( name ) ;\n"
                ],
                [
                    34,
                    " ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n"
                ],
                [
                    35,
                    " gcry_free ( name ) ;\n"
                ],
                [
                    36,
                    " name = NULL ;\n"
                ],
                [
                    37,
                    " if ( ! module ) {\n"
                ],
                [
                    43,
                    " elems = pubkey -> elements_sig ;\n"
                ],
                [
                    44,
                    " array = gcry_calloc ( strlen ( elems ) + 1 , sizeof * array ) ;\n"
                ],
                [
                    45,
                    " if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    46,
                    " if ( ! err ) err = sexp_elements_extract ( list , elems , array , NULL ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static gcry_err_code_t sexp_elements_extract ( gcry_sexp_t key_sexp , const char * element_names , gcry_mpi_t * elements , const char * algo_name ) {\n gcry_err_code_t err = 0 ;\n int i , idx ;\n const char * name ;\n gcry_sexp_t list ;\n for ( name = element_names , idx = 0 ;\n * name && ! err ;\n name ++ , idx ++ ) {\n list = gcry_sexp_find_token ( key_sexp , name , 1 ) ;\n if ( ! list ) elements [ idx ] = NULL ;\n else {\n elements [ idx ] = gcry_sexp_nth_mpi ( list , 1 , GCRYMPI_FMT_USG ) ;\n gcry_sexp_release ( list ) ;\n if ( ! elements [ idx ] ) err = GPG_ERR_INV_OBJ ;\n }\n }\n if ( ! err ) {\n for ( name = element_names , i = 0 ;\n * name ;\n name ++ , i ++ ) if ( ! elements [ i ] ) break ;\n if ( * name ) {\n err = GPG_ERR_NO_OBJ ;\n if ( algo_name && ! strcmp ( algo_name , \"RSA\" ) && ! strcmp ( element_names , \"nedpqu\" ) ) {\n if ( elements [ 0 ] && elements [ 1 ] && elements [ 2 ] && ! elements [ 3 ] && ! elements [ 4 ] && ! elements [ 5 ] ) err = 0 ;\n }\n }\n }\n if ( err ) {\n for ( i = 0 ;\n i < idx ;\n i ++ ) if ( elements [ i ] ) mpi_free ( elements [ i ] ) ;\n }\n return err ;\n }",
        "hash": -7795592811940874822,
        "project": "debian",
        "size": 34,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static gcry_err_code_t sexp_elements_extract ( gcry_sexp_t key_sexp , const char * element_names , gcry_mpi_t * elements , const char * algo_name ) {\n"
                ],
                [
                    21,
                    " if ( * name ) {\n"
                ],
                [
                    23,
                    " if ( algo_name && ! strcmp ( algo_name , \"RSA\" ) && ! strcmp ( element_names , \"nedpqu\" ) ) {\n"
                ],
                [
                    24,
                    " if ( elements [ 0 ] && elements [ 1 ] && elements [ 2 ] && ! elements [ 3 ] && ! elements [ 4 ] && ! elements [ 5 ] ) err = 0 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gcry_err_code_t sexp_elements_extract ( gcry_sexp_t key_sexp , const char * element_names , gcry_mpi_t * elements , const char * algo_name ) {\n"
                ],
                [
                    21,
                    " if ( * name ) {\n"
                ],
                [
                    23,
                    " if ( algo_name && ! strcmp ( algo_name , \"RSA\" ) && ! strcmp ( element_names , \"nedpqu\" ) ) {\n"
                ],
                [
                    24,
                    " if ( elements [ 0 ] && elements [ 1 ] && elements [ 2 ] && ! elements [ 3 ] && ! elements [ 4 ] && ! elements [ 5 ] ) err = 0 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static gcry_err_code_t sexp_to_key ( gcry_sexp_t sexp , int want_private , int use , const char * override_elems , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * r_is_ecc ) {\n gcry_err_code_t err = 0 ;\n gcry_sexp_t list , l2 ;\n char * name ;\n const char * elems ;\n gcry_mpi_t * array ;\n gcry_module_t module ;\n gcry_pk_spec_t * pubkey ;\n pk_extra_spec_t * extraspec ;\n int is_ecc ;\n list = gcry_sexp_find_token ( sexp , want_private ? \"private-key\" : \"public-key\" , 0 ) ;\n if ( ! list && ! want_private ) list = gcry_sexp_find_token ( sexp , \"private-key\" , 0 ) ;\n if ( ! list ) return GPG_ERR_INV_OBJ ;\n l2 = gcry_sexp_cadr ( list ) ;\n gcry_sexp_release ( list ) ;\n list = l2 ;\n name = _gcry_sexp_nth_string ( list , 0 ) ;\n if ( ! name ) {\n gcry_sexp_release ( list ) ;\n return GPG_ERR_INV_OBJ ;\n }\n if ( ! strcmp ( name , \"ecc\" ) ) is_ecc = 2 ;\n else if ( ! strcmp ( name , \"ecdsa\" ) || ! strcmp ( name , \"ecdh\" ) ) is_ecc = 1 ;\n else is_ecc = 0 ;\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n if ( is_ecc == 2 && ( use & GCRY_PK_USAGE_SIGN ) ) module = gcry_pk_lookup_name ( \"ecdsa\" ) ;\n else if ( is_ecc == 2 && ( use & GCRY_PK_USAGE_ENCR ) ) module = gcry_pk_lookup_name ( \"ecdh\" ) ;\n else module = gcry_pk_lookup_name ( name ) ;\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n gcry_free ( name ) ;\n if ( ! module ) {\n gcry_sexp_release ( list ) ;\n return GPG_ERR_PUBKEY_ALGO ;\n }\n else {\n pubkey = ( gcry_pk_spec_t * ) module -> spec ;\n extraspec = module -> extraspec ;\n }\n if ( override_elems ) elems = override_elems ;\n else if ( want_private ) elems = pubkey -> elements_skey ;\n else elems = pubkey -> elements_pkey ;\n array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n if ( ! err ) {\n if ( is_ecc ) err = sexp_elements_extract_ecc ( list , elems , array , extraspec , want_private ) ;\n else err = sexp_elements_extract ( list , elems , array , pubkey -> name ) ;\n }\n gcry_sexp_release ( list ) ;\n if ( err ) {\n gcry_free ( array ) ;\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n _gcry_module_release ( module ) ;\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n }\n else {\n * retarray = array ;\n * retalgo = module ;\n if ( r_is_ecc ) * r_is_ecc = is_ecc ;\n }\n return err ;\n }",
        "hash": -7795592811940874822,
        "project": "debian",
        "size": 61,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_key ( gcry_sexp_t sexp , int want_private , int use , const char * override_elems , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * r_is_ecc ) {\n"
                ],
                [
                    18,
                    " if ( ! name ) {\n"
                ],
                [
                    22,
                    " if ( ! strcmp ( name , \"ecc\" ) ) is_ecc = 2 ;\n"
                ],
                [
                    23,
                    " else if ( ! strcmp ( name , \"ecdsa\" ) || ! strcmp ( name , \"ecdh\" ) ) is_ecc = 1 ;\n"
                ],
                [
                    24,
                    " else is_ecc = 0 ;\n"
                ],
                [
                    28,
                    " else module = gcry_pk_lookup_name ( name ) ;\n"
                ],
                [
                    30,
                    " gcry_free ( name ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_key ( gcry_sexp_t sexp , int want_private , int use , const char * override_elems , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * r_is_ecc ) {\n"
                ],
                [
                    31,
                    " if ( ! module ) {\n"
                ],
                [
                    39,
                    " if ( override_elems ) elems = override_elems ;\n"
                ],
                [
                    40,
                    " else if ( want_private ) elems = pubkey -> elements_skey ;\n"
                ],
                [
                    41,
                    " else elems = pubkey -> elements_pkey ;\n"
                ],
                [
                    42,
                    " array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n"
                ],
                [
                    43,
                    " if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    45,
                    " if ( is_ecc ) err = sexp_elements_extract_ecc ( list , elems , array , extraspec , want_private ) ;\n"
                ],
                [
                    46,
                    " else err = sexp_elements_extract ( list , elems , array , pubkey -> name ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_key ( gcry_sexp_t sexp , int want_private , int use , const char * override_elems , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * r_is_ecc ) {\n"
                ],
                [
                    18,
                    " if ( ! name ) {\n"
                ],
                [
                    22,
                    " if ( ! strcmp ( name , \"ecc\" ) ) is_ecc = 2 ;\n"
                ],
                [
                    23,
                    " else if ( ! strcmp ( name , \"ecdsa\" ) || ! strcmp ( name , \"ecdh\" ) ) is_ecc = 1 ;\n"
                ],
                [
                    24,
                    " else is_ecc = 0 ;\n"
                ],
                [
                    28,
                    " else module = gcry_pk_lookup_name ( name ) ;\n"
                ],
                [
                    30,
                    " gcry_free ( name ) ;\n"
                ],
                [
                    31,
                    " if ( ! module ) {\n"
                ],
                [
                    39,
                    " if ( override_elems ) elems = override_elems ;\n"
                ],
                [
                    40,
                    " else if ( want_private ) elems = pubkey -> elements_skey ;\n"
                ],
                [
                    41,
                    " else elems = pubkey -> elements_pkey ;\n"
                ],
                [
                    42,
                    " array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n"
                ],
                [
                    43,
                    " if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    45,
                    " if ( is_ecc ) err = sexp_elements_extract_ecc ( list , elems , array , extraspec , want_private ) ;\n"
                ],
                [
                    46,
                    " else err = sexp_elements_extract ( list , elems , array , pubkey -> name ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n gcry_err_code_t err = 0 ;\n gcry_sexp_t list = NULL , l2 = NULL ;\n gcry_pk_spec_t * pubkey = NULL ;\n gcry_module_t module = NULL ;\n char * name = NULL ;\n size_t n ;\n int parsed_flags = 0 ;\n const char * elems ;\n gcry_mpi_t * array = NULL ;\n * ret_modern = 0 ;\n list = gcry_sexp_find_token ( sexp , \"enc-val\" , 0 ) ;\n if ( ! list ) {\n err = GPG_ERR_INV_OBJ ;\n goto leave ;\n }\n l2 = gcry_sexp_nth ( list , 1 ) ;\n if ( ! l2 ) {\n err = GPG_ERR_NO_OBJ ;\n goto leave ;\n }\n name = _gcry_sexp_nth_string ( l2 , 0 ) ;\n if ( ! name ) {\n err = GPG_ERR_INV_OBJ ;\n goto leave ;\n }\n if ( ! strcmp ( name , \"flags\" ) ) {\n const char * s ;\n int i ;\n * ret_modern = 1 ;\n for ( i = gcry_sexp_length ( l2 ) - 1 ;\n i > 0 ;\n i -- ) {\n s = gcry_sexp_nth_data ( l2 , i , & n ) ;\n if ( ! s ) ;\n else if ( n == 3 && ! memcmp ( s , \"raw\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_RAW ;\n else if ( n == 5 && ! memcmp ( s , \"pkcs1\" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n else if ( n == 4 && ! memcmp ( s , \"oaep\" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n else if ( n == 3 && ! memcmp ( s , \"pss\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n err = GPG_ERR_CONFLICT ;\n goto leave ;\n }\n else if ( n == 11 && ! memcmp ( s , \"no-blinding\" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n else {\n err = GPG_ERR_INV_FLAG ;\n goto leave ;\n }\n }\n gcry_sexp_release ( l2 ) ;\n if ( ctx -> encoding == PUBKEY_ENC_OAEP ) {\n l2 = gcry_sexp_find_token ( list , \"hash-algo\" , 0 ) ;\n if ( l2 ) {\n s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n if ( ! s ) err = GPG_ERR_NO_OBJ ;\n else {\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) err = GPG_ERR_DIGEST_ALGO ;\n }\n gcry_sexp_release ( l2 ) ;\n if ( err ) goto leave ;\n }\n l2 = gcry_sexp_find_token ( list , \"label\" , 0 ) ;\n if ( l2 ) {\n s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n if ( ! s ) err = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n ctx -> label = gcry_malloc ( n ) ;\n if ( ! ctx -> label ) err = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( ctx -> label , s , n ) ;\n ctx -> labellen = n ;\n }\n }\n gcry_sexp_release ( l2 ) ;\n if ( err ) goto leave ;\n }\n }\n for ( i = 2 ;\n ( l2 = gcry_sexp_nth ( list , i ) ) != NULL ;\n i ++ ) {\n s = gcry_sexp_nth_data ( l2 , 0 , & n ) ;\n if ( ! ( n == 9 && ! memcmp ( s , \"hash-algo\" , 9 ) ) && ! ( n == 5 && ! memcmp ( s , \"label\" , 5 ) ) && ! ( n == 15 && ! memcmp ( s , \"random-override\" , 15 ) ) ) break ;\n gcry_sexp_release ( l2 ) ;\n }\n if ( ! l2 ) {\n err = GPG_ERR_NO_OBJ ;\n goto leave ;\n }\n gcry_free ( name ) ;\n name = _gcry_sexp_nth_string ( l2 , 0 ) ;\n if ( ! name ) {\n err = GPG_ERR_INV_OBJ ;\n goto leave ;\n }\n gcry_sexp_release ( list ) ;\n list = l2 ;\n l2 = NULL ;\n }\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n module = gcry_pk_lookup_name ( name ) ;\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n if ( ! module ) {\n err = GPG_ERR_PUBKEY_ALGO ;\n goto leave ;\n }\n pubkey = ( gcry_pk_spec_t * ) module -> spec ;\n elems = pubkey -> elements_enc ;\n array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n if ( ! array ) {\n err = gpg_err_code_from_syserror ( ) ;\n goto leave ;\n }\n err = sexp_elements_extract ( list , elems , array , NULL ) ;\n leave : gcry_sexp_release ( list ) ;\n gcry_sexp_release ( l2 ) ;\n gcry_free ( name ) ;\n if ( err ) {\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n _gcry_module_release ( module ) ;\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n gcry_free ( array ) ;\n gcry_free ( ctx -> label ) ;\n ctx -> label = NULL ;\n }\n else {\n * retarray = array ;\n * retalgo = module ;\n * flags = parsed_flags ;\n }\n return err ;\n }",
        "hash": -7795592811940874822,
        "project": "debian",
        "size": 131,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n"
                ],
                [
                    64,
                    " s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n"
                ],
                [
                    65,
                    " if ( ! s ) err = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    67,
                    " ctx -> label = gcry_malloc ( n ) ;\n"
                ],
                [
                    68,
                    " if ( ! ctx -> label ) err = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    70,
                    " memcpy ( ctx -> label , s , n ) ;\n"
                ],
                [
                    71,
                    " ctx -> labellen = n ;\n"
                ],
                [
                    81,
                    " s = gcry_sexp_nth_data ( l2 , 0 , & n ) ;\n"
                ],
                [
                    82,
                    " if ( ! ( n == 9 && ! memcmp ( s , \"hash-algo\" , 9 ) ) && ! ( n == 5 && ! memcmp ( s , \"label\" , 5 ) ) && ! ( n == 15 && ! memcmp ( s , \"random-override\" , 15 ) ) ) break ;\n"
                ],
                [
                    122,
                    " gcry_free ( ctx -> label ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n"
                ],
                [
                    32,
                    " i > 0 ;\n"
                ],
                [
                    33,
                    " i -- ) {\n"
                ],
                [
                    35,
                    " if ( ! s ) ;\n"
                ],
                [
                    36,
                    " else if ( n == 3 && ! memcmp ( s , \"raw\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_RAW ;\n"
                ],
                [
                    37,
                    " else if ( n == 5 && ! memcmp ( s , \"pkcs1\" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n"
                ],
                [
                    38,
                    " else if ( n == 4 && ! memcmp ( s , \"oaep\" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n"
                ],
                [
                    39,
                    " else if ( n == 3 && ! memcmp ( s , \"pss\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n"
                ],
                [
                    40,
                    " err = GPG_ERR_CONFLICT ;\n"
                ],
                [
                    43,
                    " else if ( n == 11 && ! memcmp ( s , \"no-blinding\" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n"
                ],
                [
                    45,
                    " err = GPG_ERR_INV_FLAG ;\n"
                ],
                [
                    79,
                    " ( l2 = gcry_sexp_nth ( list , i ) ) != NULL ;\n"
                ],
                [
                    80,
                    " i ++ ) {\n"
                ],
                [
                    81,
                    " s = gcry_sexp_nth_data ( l2 , 0 , & n ) ;\n"
                ],
                [
                    82,
                    " if ( ! ( n == 9 && ! memcmp ( s , \"hash-algo\" , 9 ) ) && ! ( n == 5 && ! memcmp ( s , \"label\" , 5 ) ) && ! ( n == 15 && ! memcmp ( s , \"random-override\" , 15 ) ) ) break ;\n"
                ],
                [
                    83,
                    " gcry_sexp_release ( l2 ) ;\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n"
                ],
                [
                    23,
                    " if ( ! name ) {\n"
                ],
                [
                    27,
                    " if ( ! strcmp ( name , \"flags\" ) ) {\n"
                ],
                [
                    30,
                    " * ret_modern = 1 ;\n"
                ],
                [
                    31,
                    " for ( i = gcry_sexp_length ( l2 ) - 1 ;\n"
                ],
                [
                    32,
                    " i > 0 ;\n"
                ],
                [
                    89,
                    " gcry_free ( name ) ;\n"
                ],
                [
                    99,
                    " ath_mutex_lock ( & pubkeys_registered_lock ) ;\n"
                ],
                [
                    100,
                    " module = gcry_pk_lookup_name ( name ) ;\n"
                ],
                [
                    101,
                    " ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n"
                ],
                [
                    102,
                    " if ( ! module ) {\n"
                ],
                [
                    116,
                    " gcry_free ( name ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n"
                ],
                [
                    102,
                    " if ( ! module ) {\n"
                ],
                [
                    107,
                    " elems = pubkey -> elements_enc ;\n"
                ],
                [
                    108,
                    " array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n"
                ],
                [
                    109,
                    " if ( ! array ) {\n"
                ],
                [
                    113,
                    " err = sexp_elements_extract ( list , elems , array , NULL ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n"
                ],
                [
                    23,
                    " if ( ! name ) {\n"
                ],
                [
                    27,
                    " if ( ! strcmp ( name , \"flags\" ) ) {\n"
                ],
                [
                    30,
                    " * ret_modern = 1 ;\n"
                ],
                [
                    31,
                    " for ( i = gcry_sexp_length ( l2 ) - 1 ;\n"
                ],
                [
                    32,
                    " i > 0 ;\n"
                ],
                [
                    33,
                    " i -- ) {\n"
                ],
                [
                    35,
                    " if ( ! s ) ;\n"
                ],
                [
                    36,
                    " else if ( n == 3 && ! memcmp ( s , \"raw\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_RAW ;\n"
                ],
                [
                    37,
                    " else if ( n == 5 && ! memcmp ( s , \"pkcs1\" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n"
                ],
                [
                    38,
                    " else if ( n == 4 && ! memcmp ( s , \"oaep\" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n"
                ],
                [
                    39,
                    " else if ( n == 3 && ! memcmp ( s , \"pss\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n"
                ],
                [
                    40,
                    " err = GPG_ERR_CONFLICT ;\n"
                ],
                [
                    43,
                    " else if ( n == 11 && ! memcmp ( s , \"no-blinding\" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n"
                ],
                [
                    45,
                    " err = GPG_ERR_INV_FLAG ;\n"
                ],
                [
                    64,
                    " s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n"
                ],
                [
                    65,
                    " if ( ! s ) err = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    67,
                    " ctx -> label = gcry_malloc ( n ) ;\n"
                ],
                [
                    68,
                    " if ( ! ctx -> label ) err = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    70,
                    " memcpy ( ctx -> label , s , n ) ;\n"
                ],
                [
                    71,
                    " ctx -> labellen = n ;\n"
                ],
                [
                    79,
                    " ( l2 = gcry_sexp_nth ( list , i ) ) != NULL ;\n"
                ],
                [
                    80,
                    " i ++ ) {\n"
                ],
                [
                    81,
                    " s = gcry_sexp_nth_data ( l2 , 0 , & n ) ;\n"
                ],
                [
                    82,
                    " if ( ! ( n == 9 && ! memcmp ( s , \"hash-algo\" , 9 ) ) && ! ( n == 5 && ! memcmp ( s , \"label\" , 5 ) ) && ! ( n == 15 && ! memcmp ( s , \"random-override\" , 15 ) ) ) break ;\n"
                ],
                [
                    83,
                    " gcry_sexp_release ( l2 ) ;\n"
                ],
                [
                    89,
                    " gcry_free ( name ) ;\n"
                ],
                [
                    99,
                    " ath_mutex_lock ( & pubkeys_registered_lock ) ;\n"
                ],
                [
                    100,
                    " module = gcry_pk_lookup_name ( name ) ;\n"
                ],
                [
                    101,
                    " ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n"
                ],
                [
                    102,
                    " if ( ! module ) {\n"
                ],
                [
                    107,
                    " elems = pubkey -> elements_enc ;\n"
                ],
                [
                    108,
                    " array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n"
                ],
                [
                    109,
                    " if ( ! array ) {\n"
                ],
                [
                    113,
                    " err = sexp_elements_extract ( list , elems , array , NULL ) ;\n"
                ],
                [
                    116,
                    " gcry_free ( name ) ;\n"
                ],
                [
                    122,
                    " gcry_free ( ctx -> label ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static gcry_err_code_t sexp_data_to_mpi ( gcry_sexp_t input , gcry_mpi_t * ret_mpi , struct pk_encoding_ctx * ctx ) {\n gcry_err_code_t rc = 0 ;\n gcry_sexp_t ldata , lhash , lvalue ;\n int i ;\n size_t n ;\n const char * s ;\n int unknown_flag = 0 ;\n int parsed_flags = 0 ;\n int explicit_raw = 0 ;\n * ret_mpi = NULL ;\n ldata = gcry_sexp_find_token ( input , \"data\" , 0 ) ;\n if ( ! ldata ) {\n * ret_mpi = gcry_sexp_nth_mpi ( input , 0 , 0 ) ;\n return * ret_mpi ? GPG_ERR_NO_ERROR : GPG_ERR_INV_OBJ ;\n }\n {\n gcry_sexp_t lflags = gcry_sexp_find_token ( ldata , \"flags\" , 0 ) ;\n if ( lflags ) {\n for ( i = gcry_sexp_length ( lflags ) - 1 ;\n i > 0 ;\n i -- ) {\n s = gcry_sexp_nth_data ( lflags , i , & n ) ;\n if ( ! s ) ;\n else if ( n == 7 && ! memcmp ( s , \"rfc6979\" , 7 ) ) parsed_flags |= PUBKEY_FLAG_RFC6979 ;\n else if ( n == 5 && ! memcmp ( s , \"eddsa\" , 5 ) ) {\n ctx -> encoding = PUBKEY_ENC_RAW ;\n parsed_flags |= PUBKEY_FLAG_EDDSA ;\n }\n else if ( n == 3 && ! memcmp ( s , \"raw\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n ctx -> encoding = PUBKEY_ENC_RAW ;\n explicit_raw = 1 ;\n }\n else if ( n == 5 && ! memcmp ( s , \"pkcs1\" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n else if ( n == 4 && ! memcmp ( s , \"oaep\" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n else if ( n == 3 && ! memcmp ( s , \"pss\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PSS ;\n else if ( n == 11 && ! memcmp ( s , \"no-blinding\" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n else unknown_flag = 1 ;\n }\n gcry_sexp_release ( lflags ) ;\n }\n }\n if ( ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_RAW ;\n lhash = gcry_sexp_find_token ( ldata , \"hash\" , 0 ) ;\n lvalue = lhash ? NULL : gcry_sexp_find_token ( ldata , \"value\" , 0 ) ;\n if ( ! ( ! lhash ^ ! lvalue ) ) rc = GPG_ERR_INV_OBJ ;\n else if ( unknown_flag ) rc = GPG_ERR_INV_FLAG ;\n else if ( ctx -> encoding == PUBKEY_ENC_RAW && ( parsed_flags & PUBKEY_FLAG_EDDSA ) ) {\n gcry_sexp_t list ;\n void * value ;\n size_t valuelen ;\n if ( ! lvalue ) {\n rc = GPG_ERR_INV_OBJ ;\n goto leave ;\n }\n list = gcry_sexp_find_token ( ldata , \"hash-algo\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else {\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n }\n gcry_sexp_release ( list ) ;\n }\n else rc = GPG_ERR_INV_OBJ ;\n if ( rc ) goto leave ;\n value = gcry_sexp_nth_buffer ( lvalue , 1 , & valuelen ) ;\n if ( ! value ) rc = GPG_ERR_INV_OBJ ;\n else if ( ( valuelen * 8 ) < valuelen ) {\n gcry_free ( value ) ;\n rc = GPG_ERR_TOO_LARGE ;\n }\n if ( rc ) goto leave ;\n * ret_mpi = gcry_mpi_set_opaque ( NULL , value , valuelen * 8 ) ;\n }\n else if ( ctx -> encoding == PUBKEY_ENC_RAW && lhash && ( explicit_raw || ( parsed_flags & PUBKEY_FLAG_RFC6979 ) ) ) {\n if ( gcry_sexp_length ( lhash ) != 3 ) rc = GPG_ERR_INV_OBJ ;\n else if ( ! ( s = gcry_sexp_nth_data ( lhash , 1 , & n ) ) || ! n ) rc = GPG_ERR_INV_OBJ ;\n else {\n void * value ;\n size_t valuelen ;\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n else if ( ! ( value = gcry_sexp_nth_buffer ( lhash , 2 , & valuelen ) ) ) rc = GPG_ERR_INV_OBJ ;\n else if ( ( valuelen * 8 ) < valuelen ) {\n gcry_free ( value ) ;\n rc = GPG_ERR_TOO_LARGE ;\n }\n else * ret_mpi = gcry_mpi_set_opaque ( NULL , value , valuelen * 8 ) ;\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_RAW && lvalue ) {\n if ( parsed_flags & PUBKEY_FLAG_RFC6979 ) {\n rc = GPG_ERR_CONFLICT ;\n goto leave ;\n }\n * ret_mpi = gcry_sexp_nth_mpi ( lvalue , 1 , GCRYMPI_FMT_USG ) ;\n if ( ! * ret_mpi ) rc = GPG_ERR_INV_OBJ ;\n }\n else if ( ctx -> encoding == PUBKEY_ENC_PKCS1 && lvalue && ctx -> op == PUBKEY_OP_ENCRYPT ) {\n const void * value ;\n size_t valuelen ;\n gcry_sexp_t list ;\n void * random_override = NULL ;\n size_t random_override_len = 0 ;\n if ( ! ( value = gcry_sexp_nth_data ( lvalue , 1 , & valuelen ) ) || ! valuelen ) rc = GPG_ERR_INV_OBJ ;\n else {\n list = gcry_sexp_find_token ( ldata , \"random-override\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n random_override = gcry_malloc ( n ) ;\n if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( random_override , s , n ) ;\n random_override_len = n ;\n }\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n rc = pkcs1_encode_for_encryption ( ret_mpi , ctx -> nbits , value , valuelen , random_override , random_override_len ) ;\n gcry_free ( random_override ) ;\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_PKCS1 && lhash && ( ctx -> op == PUBKEY_OP_SIGN || ctx -> op == PUBKEY_OP_VERIFY ) ) {\n if ( gcry_sexp_length ( lhash ) != 3 ) rc = GPG_ERR_INV_OBJ ;\n else if ( ! ( s = gcry_sexp_nth_data ( lhash , 1 , & n ) ) || ! n ) rc = GPG_ERR_INV_OBJ ;\n else {\n const void * value ;\n size_t valuelen ;\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n else if ( ! ( value = gcry_sexp_nth_data ( lhash , 2 , & valuelen ) ) || ! valuelen ) rc = GPG_ERR_INV_OBJ ;\n else rc = pkcs1_encode_for_signature ( ret_mpi , ctx -> nbits , value , valuelen , ctx -> hash_algo ) ;\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_OAEP && lvalue && ctx -> op == PUBKEY_OP_ENCRYPT ) {\n const void * value ;\n size_t valuelen ;\n if ( ! ( value = gcry_sexp_nth_data ( lvalue , 1 , & valuelen ) ) || ! valuelen ) rc = GPG_ERR_INV_OBJ ;\n else {\n gcry_sexp_t list ;\n void * random_override = NULL ;\n size_t random_override_len = 0 ;\n list = gcry_sexp_find_token ( ldata , \"hash-algo\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else {\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n list = gcry_sexp_find_token ( ldata , \"label\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n ctx -> label = gcry_malloc ( n ) ;\n if ( ! ctx -> label ) rc = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( ctx -> label , s , n ) ;\n ctx -> labellen = n ;\n }\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n list = gcry_sexp_find_token ( ldata , \"random-override\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n random_override = gcry_malloc ( n ) ;\n if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( random_override , s , n ) ;\n random_override_len = n ;\n }\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n rc = oaep_encode ( ret_mpi , ctx -> nbits , ctx -> hash_algo , value , valuelen , ctx -> label , ctx -> labellen , random_override , random_override_len ) ;\n gcry_free ( random_override ) ;\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_PSS && lhash && ctx -> op == PUBKEY_OP_SIGN ) {\n if ( gcry_sexp_length ( lhash ) != 3 ) rc = GPG_ERR_INV_OBJ ;\n else if ( ! ( s = gcry_sexp_nth_data ( lhash , 1 , & n ) ) || ! n ) rc = GPG_ERR_INV_OBJ ;\n else {\n const void * value ;\n size_t valuelen ;\n void * random_override = NULL ;\n size_t random_override_len = 0 ;\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n else if ( ! ( value = gcry_sexp_nth_data ( lhash , 2 , & valuelen ) ) || ! valuelen ) rc = GPG_ERR_INV_OBJ ;\n else {\n gcry_sexp_t list ;\n list = gcry_sexp_find_token ( ldata , \"salt-length\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) {\n rc = GPG_ERR_NO_OBJ ;\n goto leave ;\n }\n ctx -> saltlen = ( unsigned int ) strtoul ( s , NULL , 10 ) ;\n gcry_sexp_release ( list ) ;\n }\n list = gcry_sexp_find_token ( ldata , \"random-override\" , 0 ) ;\n if ( list ) {\n s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n else if ( n > 0 ) {\n random_override = gcry_malloc ( n ) ;\n if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n else {\n memcpy ( random_override , s , n ) ;\n random_override_len = n ;\n }\n }\n gcry_sexp_release ( list ) ;\n if ( rc ) goto leave ;\n }\n rc = pss_encode ( ret_mpi , ctx -> nbits - 1 , ctx -> hash_algo , value , valuelen , ctx -> saltlen , random_override , random_override_len ) ;\n gcry_free ( random_override ) ;\n }\n }\n }\n else if ( ctx -> encoding == PUBKEY_ENC_PSS && lhash && ctx -> op == PUBKEY_OP_VERIFY ) {\n if ( gcry_sexp_length ( lhash ) != 3 ) rc = GPG_ERR_INV_OBJ ;\n else if ( ! ( s = gcry_sexp_nth_data ( lhash , 1 , & n ) ) || ! n ) rc = GPG_ERR_INV_OBJ ;\n else {\n ctx -> hash_algo = get_hash_algo ( s , n ) ;\n if ( ! ctx -> hash_algo ) rc = GPG_ERR_DIGEST_ALGO ;\n else {\n * ret_mpi = gcry_sexp_nth_mpi ( lhash , 2 , GCRYMPI_FMT_USG ) ;\n if ( ! * ret_mpi ) rc = GPG_ERR_INV_OBJ ;\n ctx -> verify_cmp = pss_verify_cmp ;\n ctx -> verify_arg = * ret_mpi ;\n }\n }\n }\n else rc = GPG_ERR_CONFLICT ;\n leave : gcry_sexp_release ( ldata ) ;\n gcry_sexp_release ( lhash ) ;\n gcry_sexp_release ( lvalue ) ;\n if ( ! rc ) ctx -> flags = parsed_flags ;\n else {\n gcry_free ( ctx -> label ) ;\n ctx -> label = NULL ;\n }\n return rc ;\n }",
        "hash": -7795592811940874822,
        "project": "debian",
        "size": 259,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static gcry_err_code_t sexp_data_to_mpi ( gcry_sexp_t input , gcry_mpi_t * ret_mpi , struct pk_encoding_ctx * ctx ) {\n"
                ],
                [
                    110,
                    " s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n"
                ],
                [
                    111,
                    " if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    113,
                    " random_override = gcry_malloc ( n ) ;\n"
                ],
                [
                    114,
                    " if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    116,
                    " memcpy ( random_override , s , n ) ;\n"
                ],
                [
                    117,
                    " random_override_len = n ;\n"
                ],
                [
                    123,
                    " rc = pkcs1_encode_for_encryption ( ret_mpi , ctx -> nbits , value , valuelen , random_override , random_override_len ) ;\n"
                ],
                [
                    160,
                    " s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n"
                ],
                [
                    161,
                    " if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    163,
                    " ctx -> label = gcry_malloc ( n ) ;\n"
                ],
                [
                    164,
                    " if ( ! ctx -> label ) rc = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    166,
                    " memcpy ( ctx -> label , s , n ) ;\n"
                ],
                [
                    167,
                    " ctx -> labellen = n ;\n"
                ],
                [
                    175,
                    " s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n"
                ],
                [
                    176,
                    " if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    177,
                    " else if ( n > 0 ) {\n"
                ],
                [
                    178,
                    " random_override = gcry_malloc ( n ) ;\n"
                ],
                [
                    179,
                    " if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    181,
                    " memcpy ( random_override , s , n ) ;\n"
                ],
                [
                    182,
                    " random_override_len = n ;\n"
                ],
                [
                    188,
                    " rc = oaep_encode ( ret_mpi , ctx -> nbits , ctx -> hash_algo , value , valuelen , ctx -> label , ctx -> labellen , random_override , random_override_len ) ;\n"
                ],
                [
                    217,
                    " s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n"
                ],
                [
                    218,
                    " if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    220,
                    " random_override = gcry_malloc ( n ) ;\n"
                ],
                [
                    221,
                    " if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    223,
                    " memcpy ( random_override , s , n ) ;\n"
                ],
                [
                    224,
                    " random_override_len = n ;\n"
                ],
                [
                    230,
                    " rc = pss_encode ( ret_mpi , ctx -> nbits - 1 , ctx -> hash_algo , value , valuelen , ctx -> saltlen , random_override , random_override_len ) ;\n"
                ],
                [
                    255,
                    " gcry_free ( ctx -> label ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "static gcry_err_code_t sexp_data_to_mpi ( gcry_sexp_t input , gcry_mpi_t * ret_mpi , struct pk_encoding_ctx * ctx ) {\n"
                ],
                [
                    23,
                    " if ( ! s ) ;\n"
                ],
                [
                    24,
                    " else if ( n == 7 && ! memcmp ( s , \"rfc6979\" , 7 ) ) parsed_flags |= PUBKEY_FLAG_RFC6979 ;\n"
                ],
                [
                    25,
                    " else if ( n == 5 && ! memcmp ( s , \"eddsa\" , 5 ) ) {\n"
                ],
                [
                    26,
                    " ctx -> encoding = PUBKEY_ENC_RAW ;\n"
                ],
                [
                    27,
                    " parsed_flags |= PUBKEY_FLAG_EDDSA ;\n"
                ],
                [
                    29,
                    " else if ( n == 3 && ! memcmp ( s , \"raw\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n"
                ],
                [
                    30,
                    " ctx -> encoding = PUBKEY_ENC_RAW ;\n"
                ],
                [
                    31,
                    " explicit_raw = 1 ;\n"
                ],
                [
                    33,
                    " else if ( n == 5 && ! memcmp ( s , \"pkcs1\" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n"
                ],
                [
                    34,
                    " else if ( n == 4 && ! memcmp ( s , \"oaep\" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n"
                ],
                [
                    35,
                    " else if ( n == 3 && ! memcmp ( s , \"pss\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PSS ;\n"
                ],
                [
                    36,
                    " else if ( n == 11 && ! memcmp ( s , \"no-blinding\" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n"
                ],
                [
                    37,
                    " else unknown_flag = 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gcry_err_code_t sexp_data_to_mpi ( gcry_sexp_t input , gcry_mpi_t * ret_mpi , struct pk_encoding_ctx * ctx ) {\n"
                ],
                [
                    23,
                    " if ( ! s ) ;\n"
                ],
                [
                    24,
                    " else if ( n == 7 && ! memcmp ( s , \"rfc6979\" , 7 ) ) parsed_flags |= PUBKEY_FLAG_RFC6979 ;\n"
                ],
                [
                    25,
                    " else if ( n == 5 && ! memcmp ( s , \"eddsa\" , 5 ) ) {\n"
                ],
                [
                    26,
                    " ctx -> encoding = PUBKEY_ENC_RAW ;\n"
                ],
                [
                    27,
                    " parsed_flags |= PUBKEY_FLAG_EDDSA ;\n"
                ],
                [
                    29,
                    " else if ( n == 3 && ! memcmp ( s , \"raw\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n"
                ],
                [
                    30,
                    " ctx -> encoding = PUBKEY_ENC_RAW ;\n"
                ],
                [
                    31,
                    " explicit_raw = 1 ;\n"
                ],
                [
                    33,
                    " else if ( n == 5 && ! memcmp ( s , \"pkcs1\" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n"
                ],
                [
                    34,
                    " else if ( n == 4 && ! memcmp ( s , \"oaep\" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n"
                ],
                [
                    35,
                    " else if ( n == 3 && ! memcmp ( s , \"pss\" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PSS ;\n"
                ],
                [
                    36,
                    " else if ( n == 11 && ! memcmp ( s , \"no-blinding\" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n"
                ],
                [
                    37,
                    " else unknown_flag = 1 ;\n"
                ],
                [
                    110,
                    " s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n"
                ],
                [
                    111,
                    " if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    113,
                    " random_override = gcry_malloc ( n ) ;\n"
                ],
                [
                    114,
                    " if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    116,
                    " memcpy ( random_override , s , n ) ;\n"
                ],
                [
                    117,
                    " random_override_len = n ;\n"
                ],
                [
                    123,
                    " rc = pkcs1_encode_for_encryption ( ret_mpi , ctx -> nbits , value , valuelen , random_override , random_override_len ) ;\n"
                ],
                [
                    160,
                    " s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n"
                ],
                [
                    161,
                    " if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    163,
                    " ctx -> label = gcry_malloc ( n ) ;\n"
                ],
                [
                    164,
                    " if ( ! ctx -> label ) rc = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    166,
                    " memcpy ( ctx -> label , s , n ) ;\n"
                ],
                [
                    167,
                    " ctx -> labellen = n ;\n"
                ],
                [
                    175,
                    " s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n"
                ],
                [
                    176,
                    " if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    177,
                    " else if ( n > 0 ) {\n"
                ],
                [
                    178,
                    " random_override = gcry_malloc ( n ) ;\n"
                ],
                [
                    179,
                    " if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    181,
                    " memcpy ( random_override , s , n ) ;\n"
                ],
                [
                    182,
                    " random_override_len = n ;\n"
                ],
                [
                    188,
                    " rc = oaep_encode ( ret_mpi , ctx -> nbits , ctx -> hash_algo , value , valuelen , ctx -> label , ctx -> labellen , random_override , random_override_len ) ;\n"
                ],
                [
                    217,
                    " s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n"
                ],
                [
                    218,
                    " if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n"
                ],
                [
                    220,
                    " random_override = gcry_malloc ( n ) ;\n"
                ],
                [
                    221,
                    " if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n"
                ],
                [
                    223,
                    " memcpy ( random_override , s , n ) ;\n"
                ],
                [
                    224,
                    " random_override_len = n ;\n"
                ],
                [
                    230,
                    " rc = pss_encode ( ret_mpi , ctx -> nbits - 1 , ctx -> hash_algo , value , valuelen , ctx -> saltlen , random_override , random_override_len ) ;\n"
                ],
                [
                    255,
                    " gcry_free ( ctx -> label ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void config_connection_input ( struct config_connection * conn ) {\n const char * const * args , * line ;\n switch ( i_stream_read ( conn -> input ) ) {\n case - 2 : i_error ( \"BUG: Config client connection sent too much data\" ) ;\n config_connection_destroy ( conn ) ;\n return ;\n case - 1 : config_connection_destroy ( conn ) ;\n return ;\n }\n if ( ! conn -> version_received ) {\n line = i_stream_next_line ( conn -> input ) ;\n if ( line == NULL ) return ;\n if ( ! version_string_verify ( line , \"config\" , CONFIG_CLIENT_PROTOCOL_MAJOR_VERSION ) ) {\n i_error ( \"Config client not compatible with this server \" \"(mixed old and new binaries?)\" ) ;\n config_connection_destroy ( conn ) ;\n return ;\n }\n conn -> version_received = TRUE ;\n }\n while ( ( args = config_connection_next_line ( conn ) ) != NULL ) {\n if ( args [ 0 ] == NULL ) continue ;\n if ( strcmp ( args [ 0 ] , \"REQ\" ) == 0 ) {\n if ( config_connection_request ( conn , args + 1 ) < 0 ) break ;\n }\n }\n }",
        "hash": 6099731296275586910,
        "project": "debian",
        "size": 26,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static void config_connection_input ( struct config_connection * conn ) {\n"
                ],
                [
                    20,
                    " while ( ( args = config_connection_next_line ( conn ) ) != NULL ) {\n"
                ],
                [
                    21,
                    " if ( args [ 0 ] == NULL ) continue ;\n"
                ],
                [
                    22,
                    " if ( strcmp ( args [ 0 ] , \"REQ\" ) == 0 ) {\n"
                ],
                [
                    23,
                    " if ( config_connection_request ( conn , args + 1 ) < 0 ) break ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void config_connection_input ( struct config_connection * conn ) {\n"
                ],
                [
                    20,
                    " while ( ( args = config_connection_next_line ( conn ) ) != NULL ) {\n"
                ],
                [
                    21,
                    " if ( args [ 0 ] == NULL ) continue ;\n"
                ],
                [
                    22,
                    " if ( strcmp ( args [ 0 ] , \"REQ\" ) == 0 ) {\n"
                ],
                [
                    23,
                    " if ( config_connection_request ( conn , args + 1 ) < 0 ) break ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int zrsdparams ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n ref * pFilter ;\n ref * pDecodeParms ;\n int Intent = 0 ;\n bool AsyncRead ;\n ref empty_array , filter1_array , parms1_array ;\n uint i ;\n int code ;\n make_empty_array ( & empty_array , a_readonly ) ;\n if ( dict_find_string ( op , \"Filter\" , & pFilter ) > 0 ) {\n if ( ! r_is_array ( pFilter ) ) {\n if ( ! r_has_type ( pFilter , t_name ) ) return_error ( gs_error_typecheck ) ;\n make_array ( & filter1_array , a_readonly , 1 , pFilter ) ;\n pFilter = & filter1_array ;\n }\n }\n else pFilter = & empty_array ;\n if ( pFilter != & empty_array && dict_find_string ( op , \"DecodeParms\" , & pDecodeParms ) > 0 ) {\n if ( pFilter == & filter1_array ) {\n make_array ( & parms1_array , a_readonly , 1 , pDecodeParms ) ;\n pDecodeParms = & parms1_array ;\n }\n else if ( ! r_is_array ( pDecodeParms ) ) return_error ( gs_error_typecheck ) ;\n else if ( r_size ( pFilter ) != r_size ( pDecodeParms ) ) return_error ( gs_error_rangecheck ) ;\n }\n else pDecodeParms = 0 ;\n for ( i = 0 ;\n i < r_size ( pFilter ) ;\n ++ i ) {\n ref f , fname , dp ;\n array_get ( imemory , pFilter , ( long ) i , & f ) ;\n if ( ! r_has_type ( & f , t_name ) ) return_error ( gs_error_typecheck ) ;\n name_string_ref ( imemory , & f , & fname ) ;\n if ( r_size ( & fname ) < 6 || memcmp ( fname . value . bytes + r_size ( & fname ) - 6 , \"Decode\" , 6 ) ) return_error ( gs_error_rangecheck ) ;\n if ( pDecodeParms ) {\n array_get ( imemory , pDecodeParms , ( long ) i , & dp ) ;\n if ( ! ( r_has_type ( & dp , t_dictionary ) || r_has_type ( & dp , t_null ) ) ) return_error ( gs_error_typecheck ) ;\n }\n }\n code = dict_int_param ( op , \"Intent\" , 0 , 3 , 0 , & Intent ) ;\n if ( code < 0 && code != gs_error_rangecheck ) return code ;\n if ( ( code = dict_bool_param ( op , \"AsyncRead\" , false , & AsyncRead ) ) < 0 ) return code ;\n push ( 1 ) ;\n op [ - 1 ] = * pFilter ;\n if ( pDecodeParms ) * op = * pDecodeParms ;\n else make_null ( op ) ;\n return 0 ;\n }",
        "hash": 6451388340908334697,
        "project": "debian",
        "size": 49,
        "slice": {
            "memcmp": [
                [
                    1,
                    "static int zrsdparams ( i_ctx_t * i_ctx_p ) {\n"
                ],
                [
                    29,
                    " i < r_size ( pFilter ) ;\n"
                ],
                [
                    35,
                    " if ( r_size ( & fname ) < 6 || memcmp ( fname . value . bytes + r_size ( & fname ) - 6 , \"Decode\" , 6 ) ) return_error ( gs_error_rangecheck ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int zrsdparams ( i_ctx_t * i_ctx_p ) {\n"
                ],
                [
                    29,
                    " i < r_size ( pFilter ) ;\n"
                ],
                [
                    35,
                    " if ( r_size ( & fname ) < 6 || memcmp ( fname . value . bytes + r_size ( & fname ) - 6 , \"Decode\" , 6 ) ) return_error ( gs_error_rangecheck ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int MDC2_Update ( MDC2_CTX * c , const unsigned char * in , size_t len ) {\n size_t i , j ;\n i = c -> num ;\n if ( i != 0 ) {\n if ( i + len < MDC2_BLOCK ) {\n memcpy ( & ( c -> data [ i ] ) , in , len ) ;\n c -> num += ( int ) len ;\n return 1 ;\n }\n else {\n j = MDC2_BLOCK - i ;\n memcpy ( & ( c -> data [ i ] ) , in , j ) ;\n len -= j ;\n in += j ;\n c -> num = 0 ;\n mdc2_body ( c , & ( c -> data [ 0 ] ) , MDC2_BLOCK ) ;\n }\n }\n i = len & ~ ( ( size_t ) MDC2_BLOCK - 1 ) ;\n if ( i > 0 ) mdc2_body ( c , in , i ) ;\n j = len - i ;\n if ( j > 0 ) {\n memcpy ( & ( c -> data [ 0 ] ) , & ( in [ i ] ) , j ) ;\n c -> num = ( int ) j ;\n }\n return 1 ;\n }",
        "hash": -1361752047994420669,
        "project": "debian",
        "size": 27,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int MDC2_Update ( MDC2_CTX * c , const unsigned char * in , size_t len ) {\n"
                ],
                [
                    5,
                    " if ( i + len < MDC2_BLOCK ) {\n"
                ],
                [
                    6,
                    " memcpy ( & ( c -> data [ i ] ) , in , len ) ;\n"
                ],
                [
                    7,
                    " c -> num += ( int ) len ;\n"
                ],
                [
                    11,
                    " j = MDC2_BLOCK - i ;\n"
                ],
                [
                    12,
                    " memcpy ( & ( c -> data [ i ] ) , in , j ) ;\n"
                ],
                [
                    13,
                    " len -= j ;\n"
                ],
                [
                    14,
                    " in += j ;\n"
                ],
                [
                    16,
                    " mdc2_body ( c , & ( c -> data [ 0 ] ) , MDC2_BLOCK ) ;\n"
                ],
                [
                    20,
                    " if ( i > 0 ) mdc2_body ( c , in , i ) ;\n"
                ],
                [
                    22,
                    " if ( j > 0 ) {\n"
                ],
                [
                    23,
                    " memcpy ( & ( c -> data [ 0 ] ) , & ( in [ i ] ) , j ) ;\n"
                ],
                [
                    24,
                    " c -> num = ( int ) j ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int MDC2_Update ( MDC2_CTX * c , const unsigned char * in , size_t len ) {\n"
                ],
                [
                    5,
                    " if ( i + len < MDC2_BLOCK ) {\n"
                ],
                [
                    6,
                    " memcpy ( & ( c -> data [ i ] ) , in , len ) ;\n"
                ],
                [
                    7,
                    " c -> num += ( int ) len ;\n"
                ],
                [
                    11,
                    " j = MDC2_BLOCK - i ;\n"
                ],
                [
                    12,
                    " memcpy ( & ( c -> data [ i ] ) , in , j ) ;\n"
                ],
                [
                    13,
                    " len -= j ;\n"
                ],
                [
                    14,
                    " in += j ;\n"
                ],
                [
                    16,
                    " mdc2_body ( c , & ( c -> data [ 0 ] ) , MDC2_BLOCK ) ;\n"
                ],
                [
                    20,
                    " if ( i > 0 ) mdc2_body ( c , in , i ) ;\n"
                ],
                [
                    22,
                    " if ( j > 0 ) {\n"
                ],
                [
                    23,
                    " memcpy ( & ( c -> data [ 0 ] ) , & ( in [ i ] ) , j ) ;\n"
                ],
                [
                    24,
                    " c -> num = ( int ) j ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void pk_transaction_authorize_actions_finished_cb ( GObject * source_object , GAsyncResult * res , struct AuthorizeActionsData * data ) {\n const gchar * action_id = NULL ;\n PkTransactionPrivate * priv = data -> transaction -> priv ;\n g_autoptr ( GError ) error = NULL ;\n g_autoptr ( PolkitAuthorizationResult ) result = NULL ;\n g_assert ( data -> actions && data -> actions -> len > 0 ) ;\n action_id = g_ptr_array_index ( data -> actions , 0 ) ;\n result = polkit_authority_check_authorization_finish ( priv -> authority , res , & error ) ;\n if ( g_cancellable_is_cancelled ( priv -> cancellable ) ) {\n priv -> waiting_for_auth = FALSE ;\n pk_transaction_status_changed_emit ( data -> transaction , PK_STATUS_ENUM_FINISHED ) ;\n pk_transaction_error_code_emit ( data -> transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , \"The authentication was cancelled due to a timeout.\" ) ;\n pk_transaction_finished_emit ( data -> transaction , PK_EXIT_ENUM_FAILED , 0 ) ;\n goto out ;\n }\n if ( result == NULL ) {\n g_autofree gchar * message = NULL ;\n priv -> waiting_for_auth = FALSE ;\n g_warning ( \"failed to check for auth: %s\" , error -> message ) ;\n pk_transaction_status_changed_emit ( data -> transaction , PK_STATUS_ENUM_FINISHED ) ;\n message = g_strdup_printf ( \"Failed to check for authentication: %s\" , error -> message ) ;\n pk_transaction_error_code_emit ( data -> transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , message ) ;\n pk_transaction_finished_emit ( data -> transaction , PK_EXIT_ENUM_FAILED , 0 ) ;\n goto out ;\n }\n if ( ! polkit_authorization_result_get_is_authorized ( result ) ) {\n if ( g_strcmp0 ( action_id , \"org.freedesktop.packagekit.package-install\" ) == 0 && pk_bitfield_contain ( priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL ) ) {\n g_debug ( \"allowing just reinstallation\" ) ;\n pk_bitfield_add ( priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_JUST_REINSTALL ) ;\n }\n else {\n priv -> waiting_for_auth = FALSE ;\n pk_transaction_status_changed_emit ( data -> transaction , PK_STATUS_ENUM_FINISHED ) ;\n pk_transaction_error_code_emit ( data -> transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , \"Failed to obtain authentication.\" ) ;\n pk_transaction_finished_emit ( data -> transaction , PK_EXIT_ENUM_FAILED , 0 ) ;\n syslog ( LOG_AUTH | LOG_NOTICE , \"uid %i failed to obtain auth\" , priv -> uid ) ;\n goto out ;\n }\n }\n if ( data -> actions -> len <= 1 ) {\n priv -> waiting_for_auth = FALSE ;\n pk_transaction_set_state ( data -> transaction , PK_TRANSACTION_STATE_READY ) ;\n syslog ( LOG_AUTH | LOG_INFO , \"uid %i obtained auth for %s\" , priv -> uid , action_id ) ;\n }\n else {\n g_ptr_array_remove_index ( data -> actions , 0 ) ;\n pk_transaction_authorize_actions ( data -> transaction , data -> role , data -> actions ) ;\n }\n out : g_ptr_array_unref ( data -> actions ) ;\n g_free ( data ) ;\n }",
        "hash": 6755873269946787742,
        "project": "debian",
        "size": 51,
        "slice": {
            "syslog": [
                [
                    1,
                    "static void pk_transaction_authorize_actions_finished_cb ( GObject * source_object , GAsyncResult * res , struct AuthorizeActionsData * data ) {\n"
                ],
                [
                    3,
                    " PkTransactionPrivate * priv = data -> transaction -> priv ;\n"
                ],
                [
                    7,
                    " action_id = g_ptr_array_index ( data -> actions , 0 ) ;\n"
                ],
                [
                    27,
                    " if ( g_strcmp0 ( action_id , \"org.freedesktop.packagekit.package-install\" ) == 0 && pk_bitfield_contain ( priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL ) ) {\n"
                ],
                [
                    36,
                    " syslog ( LOG_AUTH | LOG_NOTICE , \"uid %i failed to obtain auth\" , priv -> uid ) ;\n"
                ],
                [
                    40,
                    " if ( data -> actions -> len <= 1 ) {\n"
                ],
                [
                    43,
                    " syslog ( LOG_AUTH | LOG_INFO , \"uid %i obtained auth for %s\" , priv -> uid , action_id ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void pk_transaction_authorize_actions_finished_cb ( GObject * source_object , GAsyncResult * res , struct AuthorizeActionsData * data ) {\n"
                ],
                [
                    3,
                    " PkTransactionPrivate * priv = data -> transaction -> priv ;\n"
                ],
                [
                    7,
                    " action_id = g_ptr_array_index ( data -> actions , 0 ) ;\n"
                ],
                [
                    27,
                    " if ( g_strcmp0 ( action_id , \"org.freedesktop.packagekit.package-install\" ) == 0 && pk_bitfield_contain ( priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL ) ) {\n"
                ],
                [
                    36,
                    " syslog ( LOG_AUTH | LOG_NOTICE , \"uid %i failed to obtain auth\" , priv -> uid ) ;\n"
                ],
                [
                    40,
                    " if ( data -> actions -> len <= 1 ) {\n"
                ],
                [
                    43,
                    " syslog ( LOG_AUTH | LOG_INFO , \"uid %i obtained auth for %s\" , priv -> uid , action_id ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static enum nss_status getanswer_r ( const querybuf * answer , int anslen , const char * qname , int qtype , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop , int map , int32_t * ttlp , char * * canonp ) {\n struct host_data {\n char * aliases [ MAX_NR_ALIASES ] ;\n unsigned char host_addr [ 16 ] ;\n char * h_addr_ptrs [ 0 ] ;\n }\n * host_data ;\n int linebuflen ;\n const HEADER * hp ;\n const u_char * end_of_message , * cp ;\n int n , ancount , qdcount ;\n int haveanswer , had_error ;\n char * bp , * * ap , * * hap ;\n char tbuf [ MAXDNAME ] ;\n const char * tname ;\n int ( * name_ok ) ( const char * ) ;\n u_char packtmp [ NS_MAXCDNAME ] ;\n int have_to_map = 0 ;\n uintptr_t pad = - ( uintptr_t ) buffer % __alignof__ ( struct host_data ) ;\n buffer += pad ;\n if ( __glibc_unlikely ( buflen < sizeof ( struct host_data ) + pad ) ) {\n too_small : * errnop = ERANGE ;\n * h_errnop = NETDB_INTERNAL ;\n return NSS_STATUS_TRYAGAIN ;\n }\n host_data = ( struct host_data * ) buffer ;\n linebuflen = buflen - sizeof ( struct host_data ) ;\n if ( buflen - sizeof ( struct host_data ) != linebuflen ) linebuflen = INT_MAX ;\n tname = qname ;\n result -> h_name = NULL ;\n end_of_message = answer -> buf + anslen ;\n switch ( qtype ) {\n case T_A : case T_AAAA : name_ok = res_hnok ;\n break ;\n case T_PTR : name_ok = res_dnok ;\n break ;\n default : * errnop = ENOENT ;\n return NSS_STATUS_UNAVAIL ;\n }\n hp = & answer -> hdr ;\n ancount = ntohs ( hp -> ancount ) ;\n qdcount = ntohs ( hp -> qdcount ) ;\n cp = answer -> buf + HFIXEDSZ ;\n if ( __builtin_expect ( qdcount , 1 ) != 1 ) {\n * h_errnop = NO_RECOVERY ;\n return NSS_STATUS_UNAVAIL ;\n }\n if ( sizeof ( struct host_data ) + ( ancount + 1 ) * sizeof ( char * ) >= buflen ) goto too_small ;\n bp = ( char * ) & host_data -> h_addr_ptrs [ ancount + 1 ] ;\n linebuflen -= ( ancount + 1 ) * sizeof ( char * ) ;\n n = __ns_name_unpack ( answer -> buf , end_of_message , cp , packtmp , sizeof packtmp ) ;\n if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n if ( __builtin_expect ( errno , 0 ) == EMSGSIZE ) goto too_small ;\n n = - 1 ;\n }\n if ( n > 0 && bp [ 0 ] == '.' ) bp [ 0 ] = '\\0' ;\n if ( __builtin_expect ( n < 0 || ( ( * name_ok ) ( bp ) == 0 && ( errno = EBADMSG ) ) , 0 ) ) {\n * errnop = errno ;\n * h_errnop = NO_RECOVERY ;\n return NSS_STATUS_UNAVAIL ;\n }\n cp += n + QFIXEDSZ ;\n if ( qtype == T_A || qtype == T_AAAA ) {\n n = strlen ( bp ) + 1 ;\n if ( n >= MAXHOSTNAMELEN ) {\n * h_errnop = NO_RECOVERY ;\n * errnop = ENOENT ;\n return NSS_STATUS_TRYAGAIN ;\n }\n result -> h_name = bp ;\n bp += n ;\n linebuflen -= n ;\n if ( linebuflen < 0 ) goto too_small ;\n qname = result -> h_name ;\n }\n ap = host_data -> aliases ;\n * ap = NULL ;\n result -> h_aliases = host_data -> aliases ;\n hap = host_data -> h_addr_ptrs ;\n * hap = NULL ;\n result -> h_addr_list = host_data -> h_addr_ptrs ;\n haveanswer = 0 ;\n had_error = 0 ;\n while ( ancount -- > 0 && cp < end_of_message && had_error == 0 ) {\n int type , class ;\n n = __ns_name_unpack ( answer -> buf , end_of_message , cp , packtmp , sizeof packtmp ) ;\n if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n if ( __builtin_expect ( errno , 0 ) == EMSGSIZE ) goto too_small ;\n n = - 1 ;\n }\n if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( bp ) == 0 ) ) {\n ++ had_error ;\n continue ;\n }\n cp += n ;\n if ( __glibc_unlikely ( cp + 10 > end_of_message ) ) {\n ++ had_error ;\n continue ;\n }\n type = __ns_get16 ( cp ) ;\n cp += INT16SZ ;\n class = __ns_get16 ( cp ) ;\n cp += INT16SZ ;\n int32_t ttl = __ns_get32 ( cp ) ;\n cp += INT32SZ ;\n n = __ns_get16 ( cp ) ;\n cp += INT16SZ ;\n if ( __glibc_unlikely ( class != C_IN ) ) {\n cp += n ;\n continue ;\n }\n if ( ( qtype == T_A || qtype == T_AAAA ) && type == T_CNAME ) {\n if ( ttlp != NULL && ttl < * ttlp ) * ttlp = ttl ;\n if ( ap >= & host_data -> aliases [ MAX_NR_ALIASES - 1 ] ) continue ;\n n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( tbuf ) == 0 ) ) {\n ++ had_error ;\n continue ;\n }\n cp += n ;\n * ap ++ = bp ;\n n = strlen ( bp ) + 1 ;\n if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n ++ had_error ;\n continue ;\n }\n bp += n ;\n linebuflen -= n ;\n n = strlen ( tbuf ) + 1 ;\n if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n ++ had_error ;\n continue ;\n }\n result -> h_name = bp ;\n bp = __mempcpy ( bp , tbuf , n ) ;\n linebuflen -= n ;\n continue ;\n }\n if ( qtype == T_PTR && type == T_CNAME ) {\n n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n if ( __glibc_unlikely ( n < 0 || res_dnok ( tbuf ) == 0 ) ) {\n ++ had_error ;\n continue ;\n }\n cp += n ;\n n = strlen ( tbuf ) + 1 ;\n if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n ++ had_error ;\n continue ;\n }\n tname = bp ;\n bp = __mempcpy ( bp , tbuf , n ) ;\n linebuflen -= n ;\n continue ;\n }\n if ( type == T_A && qtype == T_AAAA && map ) have_to_map = 1 ;\n else if ( __glibc_unlikely ( type != qtype ) ) {\n if ( ( _res . options & RES_USE_DNSSEC ) == 0 ) syslog ( LOG_NOTICE | LOG_AUTH , \"gethostby*.getanswer: asked for \\\"%s %s %s\\\", \" \"got type \\\"%s\\\"\" , qname , p_class ( C_IN ) , p_type ( qtype ) , p_type ( type ) ) ;\n cp += n ;\n continue ;\n }\n switch ( type ) {\n case T_PTR : if ( __glibc_unlikely ( strcasecmp ( tname , bp ) != 0 ) ) {\n syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , qname , bp ) ;\n cp += n ;\n continue ;\n }\n n = __ns_name_unpack ( answer -> buf , end_of_message , cp , packtmp , sizeof packtmp ) ;\n if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n if ( __builtin_expect ( errno , 0 ) == EMSGSIZE ) goto too_small ;\n n = - 1 ;\n }\n if ( __glibc_unlikely ( n < 0 || res_hnok ( bp ) == 0 ) ) {\n ++ had_error ;\n break ;\n }\n result -> h_name = bp ;\n if ( have_to_map ) {\n n = strlen ( bp ) + 1 ;\n if ( __glibc_unlikely ( n >= MAXHOSTNAMELEN ) ) {\n ++ had_error ;\n break ;\n }\n bp += n ;\n linebuflen -= n ;\n if ( map_v4v6_hostent ( result , & bp , & linebuflen ) ) goto too_small ;\n }\n * h_errnop = NETDB_SUCCESS ;\n return NSS_STATUS_SUCCESS ;\n case T_A : case T_AAAA : if ( __builtin_expect ( strcasecmp ( result -> h_name , bp ) , 0 ) != 0 ) {\n syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , result -> h_name , bp ) ;\n cp += n ;\n continue ;\n }\n if ( n != result -> h_length ) {\n cp += n ;\n continue ;\n }\n if ( ! haveanswer ) {\n int nn ;\n if ( ttlp != NULL && ttl < * ttlp ) * ttlp = ttl ;\n if ( canonp != NULL ) * canonp = bp ;\n result -> h_name = bp ;\n nn = strlen ( bp ) + 1 ;\n bp += nn ;\n linebuflen -= nn ;\n }\n linebuflen -= sizeof ( align ) - ( ( u_long ) bp % sizeof ( align ) ) ;\n bp += sizeof ( align ) - ( ( u_long ) bp % sizeof ( align ) ) ;\n if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n bp = __mempcpy ( * hap ++ = bp , cp , n ) ;\n cp += n ;\n linebuflen -= n ;\n break ;\n default : abort ( ) ;\n }\n if ( had_error == 0 ) ++ haveanswer ;\n }\n if ( haveanswer > 0 ) {\n * ap = NULL ;\n * hap = NULL ;\n # if defined RESOLVSORT if ( _res . nsort && haveanswer > 1 && qtype == T_A ) addrsort ( host_data -> h_addr_ptrs , haveanswer ) ;\n # endif if ( result -> h_name == NULL ) {\n n = strlen ( qname ) + 1 ;\n if ( n > linebuflen ) goto too_small ;\n if ( n >= MAXHOSTNAMELEN ) goto no_recovery ;\n result -> h_name = bp ;\n bp = __mempcpy ( bp , qname , n ) ;\n linebuflen -= n ;\n }\n if ( have_to_map ) if ( map_v4v6_hostent ( result , & bp , & linebuflen ) ) goto too_small ;\n * h_errnop = NETDB_SUCCESS ;\n return NSS_STATUS_SUCCESS ;\n }\n no_recovery : * h_errnop = NO_RECOVERY ;\n * errnop = ENOENT ;\n return ( ( qtype == T_A || qtype == T_AAAA ) && ap != host_data -> aliases ? NSS_STATUS_NOTFOUND : NSS_STATUS_TRYAGAIN ) ;\n }",
        "hash": 155037296040076635,
        "project": "debian",
        "size": 240,
        "slice": {
            "strlen": [
                [
                    1,
                    "static enum nss_status getanswer_r ( const querybuf * answer , int anslen , const char * qname , int qtype , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop , int map , int32_t * ttlp , char * * canonp ) {\n"
                ],
                [
                    49,
                    " bp = ( char * ) & host_data -> h_addr_ptrs [ ancount + 1 ] ;\n"
                ],
                [
                    52,
                    " if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n"
                ],
                [
                    56,
                    " if ( n > 0 && bp [ 0 ] == '.' ) bp [ 0 ] = '\\0' ;\n"
                ],
                [
                    57,
                    " if ( __builtin_expect ( n < 0 || ( ( * name_ok ) ( bp ) == 0 && ( errno = EBADMSG ) ) , 0 ) ) {\n"
                ],
                [
                    63,
                    " if ( qtype == T_A || qtype == T_AAAA ) {\n"
                ],
                [
                    64,
                    " n = strlen ( bp ) + 1 ;\n"
                ],
                [
                    65,
                    " if ( n >= MAXHOSTNAMELEN ) {\n"
                ],
                [
                    70,
                    " result -> h_name = bp ;\n"
                ],
                [
                    71,
                    " bp += n ;\n"
                ],
                [
                    74,
                    " qname = result -> h_name ;\n"
                ],
                [
                    87,
                    " if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n"
                ],
                [
                    91,
                    " if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( bp ) == 0 ) ) {\n"
                ],
                [
                    115,
                    " n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n"
                ],
                [
                    116,
                    " if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( tbuf ) == 0 ) ) {\n"
                ],
                [
                    121,
                    " * ap ++ = bp ;\n"
                ],
                [
                    122,
                    " n = strlen ( bp ) + 1 ;\n"
                ],
                [
                    123,
                    " if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n"
                ],
                [
                    127,
                    " bp += n ;\n"
                ],
                [
                    129,
                    " n = strlen ( tbuf ) + 1 ;\n"
                ],
                [
                    130,
                    " if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n"
                ],
                [
                    136,
                    " bp = __mempcpy ( bp , tbuf , n ) ;\n"
                ],
                [
                    141,
                    " n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n"
                ],
                [
                    142,
                    " if ( __glibc_unlikely ( n < 0 || res_dnok ( tbuf ) == 0 ) ) {\n"
                ],
                [
                    147,
                    " n = strlen ( tbuf ) + 1 ;\n"
                ],
                [
                    148,
                    " if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n"
                ],
                [
                    153,
                    " tname = bp ;\n"
                ],
                [
                    154,
                    " bp = __mempcpy ( bp , tbuf , n ) ;\n"
                ],
                [
                    160,
                    " if ( ( _res . options & RES_USE_DNSSEC ) == 0 ) syslog ( LOG_NOTICE | LOG_AUTH , \"gethostby*.getanswer: asked for \\\"%s %s %s\\\", \" \"got type \\\"%s\\\"\" , qname , p_class ( C_IN ) , p_type ( qtype ) , p_type ( type ) ) ;\n"
                ],
                [
                    165,
                    " case T_PTR : if ( __glibc_unlikely ( strcasecmp ( tname , bp ) != 0 ) ) {\n"
                ],
                [
                    166,
                    " syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , qname , bp ) ;\n"
                ],
                [
                    171,
                    " if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n"
                ],
                [
                    175,
                    " if ( __glibc_unlikely ( n < 0 || res_hnok ( bp ) == 0 ) ) {\n"
                ],
                [
                    180,
                    " if ( have_to_map ) {\n"
                ],
                [
                    181,
                    " n = strlen ( bp ) + 1 ;\n"
                ],
                [
                    182,
                    " if ( __glibc_unlikely ( n >= MAXHOSTNAMELEN ) ) {\n"
                ],
                [
                    186,
                    " bp += n ;\n"
                ],
                [
                    192,
                    " case T_A : case T_AAAA : if ( __builtin_expect ( strcasecmp ( result -> h_name , bp ) , 0 ) != 0 ) {\n"
                ],
                [
                    193,
                    " syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , result -> h_name , bp ) ;\n"
                ],
                [
                    201,
                    " if ( ! haveanswer ) {\n"
                ],
                [
                    206,
                    " nn = strlen ( bp ) + 1 ;\n"
                ],
                [
                    207,
                    " bp += nn ;\n"
                ],
                [
                    208,
                    " linebuflen -= nn ;\n"
                ],
                [
                    213,
                    " bp = __mempcpy ( * hap ++ = bp , cp , n ) ;\n"
                ],
                [
                    221,
                    " if ( haveanswer > 0 ) {\n"
                ],
                [
                    226,
                    " n = strlen ( qname ) + 1 ;\n"
                ],
                [
                    227,
                    " if ( n > linebuflen ) goto too_small ;\n"
                ],
                [
                    229,
                    " result -> h_name = bp ;\n"
                ],
                [
                    230,
                    " bp = __mempcpy ( bp , qname , n ) ;\n"
                ],
                [
                    233,
                    " if ( have_to_map ) if ( map_v4v6_hostent ( result , & bp , & linebuflen ) ) goto too_small ;\n"
                ]
            ],
            "syslog": [
                [
                    1,
                    "static enum nss_status getanswer_r ( const querybuf * answer , int anslen , const char * qname , int qtype , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop , int map , int32_t * ttlp , char * * canonp ) {\n"
                ],
                [
                    56,
                    " if ( n > 0 && bp [ 0 ] == '.' ) bp [ 0 ] = '\\0' ;\n"
                ],
                [
                    74,
                    " qname = result -> h_name ;\n"
                ],
                [
                    87,
                    " if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n"
                ],
                [
                    91,
                    " if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( bp ) == 0 ) ) {\n"
                ],
                [
                    121,
                    " * ap ++ = bp ;\n"
                ],
                [
                    122,
                    " n = strlen ( bp ) + 1 ;\n"
                ],
                [
                    153,
                    " tname = bp ;\n"
                ],
                [
                    154,
                    " bp = __mempcpy ( bp , tbuf , n ) ;\n"
                ],
                [
                    160,
                    " if ( ( _res . options & RES_USE_DNSSEC ) == 0 ) syslog ( LOG_NOTICE | LOG_AUTH , \"gethostby*.getanswer: asked for \\\"%s %s %s\\\", \" \"got type \\\"%s\\\"\" , qname , p_class ( C_IN ) , p_type ( qtype ) , p_type ( type ) ) ;\n"
                ],
                [
                    165,
                    " case T_PTR : if ( __glibc_unlikely ( strcasecmp ( tname , bp ) != 0 ) ) {\n"
                ],
                [
                    166,
                    " syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , qname , bp ) ;\n"
                ],
                [
                    192,
                    " case T_A : case T_AAAA : if ( __builtin_expect ( strcasecmp ( result -> h_name , bp ) , 0 ) != 0 ) {\n"
                ],
                [
                    193,
                    " syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , result -> h_name , bp ) ;\n"
                ],
                [
                    226,
                    " n = strlen ( qname ) + 1 ;\n"
                ],
                [
                    229,
                    " result -> h_name = bp ;\n"
                ],
                [
                    230,
                    " bp = __mempcpy ( bp , qname , n ) ;\n"
                ],
                [
                    233,
                    " if ( have_to_map ) if ( map_v4v6_hostent ( result , & bp , & linebuflen ) ) goto too_small ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static enum nss_status getanswer_r ( const querybuf * answer , int anslen , const char * qname , int qtype , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop , int map , int32_t * ttlp , char * * canonp ) {\n"
                ],
                [
                    49,
                    " bp = ( char * ) & host_data -> h_addr_ptrs [ ancount + 1 ] ;\n"
                ],
                [
                    52,
                    " if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n"
                ],
                [
                    56,
                    " if ( n > 0 && bp [ 0 ] == '.' ) bp [ 0 ] = '\\0' ;\n"
                ],
                [
                    57,
                    " if ( __builtin_expect ( n < 0 || ( ( * name_ok ) ( bp ) == 0 && ( errno = EBADMSG ) ) , 0 ) ) {\n"
                ],
                [
                    63,
                    " if ( qtype == T_A || qtype == T_AAAA ) {\n"
                ],
                [
                    64,
                    " n = strlen ( bp ) + 1 ;\n"
                ],
                [
                    65,
                    " if ( n >= MAXHOSTNAMELEN ) {\n"
                ],
                [
                    70,
                    " result -> h_name = bp ;\n"
                ],
                [
                    71,
                    " bp += n ;\n"
                ],
                [
                    74,
                    " qname = result -> h_name ;\n"
                ],
                [
                    87,
                    " if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n"
                ],
                [
                    91,
                    " if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( bp ) == 0 ) ) {\n"
                ],
                [
                    115,
                    " n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n"
                ],
                [
                    116,
                    " if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( tbuf ) == 0 ) ) {\n"
                ],
                [
                    121,
                    " * ap ++ = bp ;\n"
                ],
                [
                    122,
                    " n = strlen ( bp ) + 1 ;\n"
                ],
                [
                    123,
                    " if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n"
                ],
                [
                    127,
                    " bp += n ;\n"
                ],
                [
                    129,
                    " n = strlen ( tbuf ) + 1 ;\n"
                ],
                [
                    130,
                    " if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n"
                ],
                [
                    136,
                    " bp = __mempcpy ( bp , tbuf , n ) ;\n"
                ],
                [
                    141,
                    " n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n"
                ],
                [
                    142,
                    " if ( __glibc_unlikely ( n < 0 || res_dnok ( tbuf ) == 0 ) ) {\n"
                ],
                [
                    147,
                    " n = strlen ( tbuf ) + 1 ;\n"
                ],
                [
                    148,
                    " if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n"
                ],
                [
                    153,
                    " tname = bp ;\n"
                ],
                [
                    154,
                    " bp = __mempcpy ( bp , tbuf , n ) ;\n"
                ],
                [
                    160,
                    " if ( ( _res . options & RES_USE_DNSSEC ) == 0 ) syslog ( LOG_NOTICE | LOG_AUTH , \"gethostby*.getanswer: asked for \\\"%s %s %s\\\", \" \"got type \\\"%s\\\"\" , qname , p_class ( C_IN ) , p_type ( qtype ) , p_type ( type ) ) ;\n"
                ],
                [
                    165,
                    " case T_PTR : if ( __glibc_unlikely ( strcasecmp ( tname , bp ) != 0 ) ) {\n"
                ],
                [
                    166,
                    " syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , qname , bp ) ;\n"
                ],
                [
                    171,
                    " if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n"
                ],
                [
                    175,
                    " if ( __glibc_unlikely ( n < 0 || res_hnok ( bp ) == 0 ) ) {\n"
                ],
                [
                    180,
                    " if ( have_to_map ) {\n"
                ],
                [
                    181,
                    " n = strlen ( bp ) + 1 ;\n"
                ],
                [
                    182,
                    " if ( __glibc_unlikely ( n >= MAXHOSTNAMELEN ) ) {\n"
                ],
                [
                    186,
                    " bp += n ;\n"
                ],
                [
                    192,
                    " case T_A : case T_AAAA : if ( __builtin_expect ( strcasecmp ( result -> h_name , bp ) , 0 ) != 0 ) {\n"
                ],
                [
                    193,
                    " syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , result -> h_name , bp ) ;\n"
                ],
                [
                    201,
                    " if ( ! haveanswer ) {\n"
                ],
                [
                    206,
                    " nn = strlen ( bp ) + 1 ;\n"
                ],
                [
                    207,
                    " bp += nn ;\n"
                ],
                [
                    208,
                    " linebuflen -= nn ;\n"
                ],
                [
                    213,
                    " bp = __mempcpy ( * hap ++ = bp , cp , n ) ;\n"
                ],
                [
                    221,
                    " if ( haveanswer > 0 ) {\n"
                ],
                [
                    226,
                    " n = strlen ( qname ) + 1 ;\n"
                ],
                [
                    227,
                    " if ( n > linebuflen ) goto too_small ;\n"
                ],
                [
                    229,
                    " result -> h_name = bp ;\n"
                ],
                [
                    230,
                    " bp = __mempcpy ( bp , qname , n ) ;\n"
                ],
                [
                    233,
                    " if ( have_to_map ) if ( map_v4v6_hostent ( result , & bp , & linebuflen ) ) goto too_small ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void dissect_q931_pdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean is_over_ip ) {\n int offset = 0 ;\n proto_tree * q931_tree = NULL ;\n proto_tree * ie_tree = NULL ;\n proto_item * ti ;\n guint8 prot_discr ;\n guint8 call_ref_len ;\n guint8 call_ref [ 16 ] ;\n guint32 call_ref_val ;\n guint8 message_type , segmented_message_type ;\n guint8 info_element ;\n guint16 info_element_len ;\n gboolean first_frag , more_frags ;\n guint32 frag_len ;\n fragment_head * fd_head ;\n tvbuff_t * next_tvb = NULL ;\n q931_pi = wmem_new ( wmem_packet_scope ( ) , q931_packet_info ) ;\n reset_q931_packet_info ( q931_pi ) ;\n have_valid_q931_pi = TRUE ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"Q.931\" ) ;\n prot_discr = tvb_get_guint8 ( tvb , offset ) ;\n ti = proto_tree_add_item ( tree , proto_q931 , tvb , offset , - 1 , ENC_NA ) ;\n if ( tree ) {\n q931_tree = proto_item_add_subtree ( ti , ett_q931 ) ;\n dissect_q931_protocol_discriminator ( tvb , offset , q931_tree ) ;\n }\n offset += 1 ;\n call_ref_len = tvb_get_guint8 ( tvb , offset ) & 0xF ;\n if ( q931_tree != NULL ) proto_tree_add_uint ( q931_tree , hf_q931_call_ref_len , tvb , offset , 1 , call_ref_len ) ;\n offset += 1 ;\n switch ( call_ref_len ) {\n case 0 : call_ref_val = 0 ;\n break ;\n case 1 : call_ref_val = tvb_get_guint8 ( tvb , offset ) ;\n break ;\n case 2 : call_ref_val = tvb_get_ntohs ( tvb , offset ) ;\n break ;\n case 3 : call_ref_val = tvb_get_ntoh24 ( tvb , offset ) ;\n break ;\n default : call_ref_val = tvb_get_ntohl ( tvb , offset ) ;\n }\n if ( call_ref_len != 0 ) {\n tvb_memcpy ( tvb , call_ref , offset , call_ref_len ) ;\n if ( q931_tree != NULL ) {\n proto_tree_add_boolean ( q931_tree , hf_q931_call_ref_flag , tvb , offset , 1 , ( call_ref [ 0 ] & 0x80 ) != 0 ) ;\n call_ref [ 0 ] &= 0x7F ;\n proto_tree_add_bytes ( q931_tree , hf_q931_call_ref , tvb , offset , call_ref_len , call_ref ) ;\n }\n else {\n call_ref [ 0 ] &= 0x7F ;\n }\n memcpy ( & ( q931_pi -> crv ) , call_ref , call_ref_len > sizeof ( q931_pi -> crv ) ? sizeof ( q931_pi -> crv ) : call_ref_len ) ;\n offset += call_ref_len ;\n }\n message_type = tvb_get_guint8 ( tvb , offset ) ;\n if ( have_valid_q931_pi && q931_pi ) {\n q931_pi -> message_type = message_type ;\n }\n col_add_str ( pinfo -> cinfo , COL_INFO , get_message_name ( prot_discr , message_type ) ) ;\n if ( prot_discr == NLPID_DMS ) proto_tree_add_item ( q931_tree , hf_q931_maintenance_message_type , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n else proto_tree_add_item ( q931_tree , hf_q931_message_type , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset += 1 ;\n if ( ( message_type != Q931_SEGMENT ) || ! q931_reassembly || ( tvb_reported_length_remaining ( tvb , offset ) <= 4 ) ) {\n dissect_q931_IEs ( tvb , pinfo , tree , q931_tree , is_over_ip , offset , 0 ) ;\n return ;\n }\n info_element = tvb_get_guint8 ( tvb , offset ) ;\n info_element_len = tvb_get_guint8 ( tvb , offset + 1 ) ;\n if ( ( info_element != Q931_IE_SEGMENTED_MESSAGE ) || ( info_element_len < 2 ) ) {\n dissect_q931_IEs ( tvb , pinfo , tree , q931_tree , is_over_ip , offset , 0 ) ;\n return ;\n }\n ie_tree = proto_tree_add_subtree ( q931_tree , tvb , offset , 1 + 1 + info_element_len , ett_q931_ie [ info_element ] , NULL , val_to_str ( info_element , q931_info_element_vals [ 0 ] , \"Unknown information element (0x%02X)\" ) ) ;\n proto_tree_add_uint_format_value ( ie_tree , hf_q931_information_element , tvb , offset , 1 , info_element , \"%s\" , val_to_str ( info_element , q931_info_element_vals [ 0 ] , \"Unknown (0x%02X)\" ) ) ;\n proto_tree_add_item ( ie_tree , hf_q931_information_element_len , tvb , offset + 1 , 1 , ENC_NA ) ;\n dissect_q931_segmented_message_ie ( tvb , pinfo , offset + 2 , info_element_len , ie_tree , ti ) ;\n first_frag = ( tvb_get_guint8 ( tvb , offset + 2 ) & 0x80 ) != 0 ;\n more_frags = ( tvb_get_guint8 ( tvb , offset + 2 ) & 0x7F ) != 0 ;\n segmented_message_type = tvb_get_guint8 ( tvb , offset + 3 ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" of %s\" , val_to_str_ext ( segmented_message_type , & q931_message_type_vals_ext , \"Unknown message type (0x%02X)\" ) ) ;\n offset += 1 + 1 + info_element_len ;\n frag_len = tvb_reported_length_remaining ( tvb , offset ) ;\n if ( first_frag && fragment_get ( & q931_reassembly_table , pinfo , call_ref_val , NULL ) ) {\n fragment_end_seq_next ( & q931_reassembly_table , pinfo , call_ref_val , NULL ) ;\n }\n fd_head = fragment_add_seq_next ( & q931_reassembly_table , tvb , offset , pinfo , call_ref_val , NULL , frag_len , more_frags ) ;\n if ( fd_head ) {\n if ( pinfo -> num == fd_head -> reassembled_in ) {\n if ( fd_head -> next != NULL ) {\n next_tvb = tvb_new_chain ( tvb , fd_head -> tvb_data ) ;\n add_new_data_source ( pinfo , next_tvb , \"Reassembled Q.931 IEs\" ) ;\n if ( tree ) {\n proto_item * frag_tree_item ;\n show_fragment_seq_tree ( fd_head , & q931_frag_items , q931_tree , pinfo , next_tvb , & frag_tree_item ) ;\n }\n }\n else {\n next_tvb = tvb_new_subset_remaining ( tvb , offset ) ;\n }\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s [reassembled]\" , val_to_str_ext ( segmented_message_type , & q931_message_type_vals_ext , \"Unknown message type (0x%02X)\" ) ) ;\n }\n else {\n if ( tree ) proto_tree_add_uint ( q931_tree , hf_q931_reassembled_in , tvb , offset , frag_len , fd_head -> reassembled_in ) ;\n }\n }\n if ( next_tvb ) dissect_q931_IEs ( next_tvb , pinfo , tree , q931_tree , is_over_ip , 0 , 0 ) ;\n }",
        "hash": -1338403456839869183,
        "project": "debian",
        "size": 107,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void dissect_q931_pdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean is_over_ip ) {\n"
                ],
                [
                    18,
                    " reset_q931_packet_info ( q931_pi ) ;\n"
                ],
                [
                    42,
                    " if ( call_ref_len != 0 ) {\n"
                ],
                [
                    43,
                    " tvb_memcpy ( tvb , call_ref , offset , call_ref_len ) ;\n"
                ],
                [
                    46,
                    " call_ref [ 0 ] &= 0x7F ;\n"
                ],
                [
                    47,
                    " proto_tree_add_bytes ( q931_tree , hf_q931_call_ref , tvb , offset , call_ref_len , call_ref ) ;\n"
                ],
                [
                    50,
                    " call_ref [ 0 ] &= 0x7F ;\n"
                ],
                [
                    52,
                    " memcpy ( & ( q931_pi -> crv ) , call_ref , call_ref_len > sizeof ( q931_pi -> crv ) ? sizeof ( q931_pi -> crv ) : call_ref_len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void dissect_q931_pdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean is_over_ip ) {\n"
                ],
                [
                    18,
                    " reset_q931_packet_info ( q931_pi ) ;\n"
                ],
                [
                    42,
                    " if ( call_ref_len != 0 ) {\n"
                ],
                [
                    43,
                    " tvb_memcpy ( tvb , call_ref , offset , call_ref_len ) ;\n"
                ],
                [
                    46,
                    " call_ref [ 0 ] &= 0x7F ;\n"
                ],
                [
                    47,
                    " proto_tree_add_bytes ( q931_tree , hf_q931_call_ref , tvb , offset , call_ref_len , call_ref ) ;\n"
                ],
                [
                    50,
                    " call_ref [ 0 ] &= 0x7F ;\n"
                ],
                [
                    52,
                    " memcpy ( & ( q931_pi -> crv ) , call_ref , call_ref_len > sizeof ( q931_pi -> crv ) ? sizeof ( q931_pi -> crv ) : call_ref_len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void dissect_rtmpt_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , rtmpt_conv_t * rconv , int cdir , guint32 seq , guint32 lastackseq ) {\n int offset = 0 ;\n int remain ;\n int want ;\n guint8 header_type ;\n int basic_hlen ;\n int message_hlen ;\n guint32 id ;\n guint32 ts = 0 ;\n guint32 tsd = 0 ;\n int body_len ;\n guint8 cmd ;\n guint32 src ;\n int chunk_size ;\n rtmpt_frag_t * tf ;\n rtmpt_id_t * ti ;\n rtmpt_packet_t * tp ;\n tvbuff_t * pktbuf ;\n remain = tvb_reported_length ( tvb ) ;\n if ( ! remain ) return ;\n RTMPT_DEBUG ( \"Segment: cdir=%d seq=%d-%d\\n\" , cdir , seq , seq + remain - 1 ) ;\n if ( pinfo -> fd -> flags . visited ) {\n wmem_stack_t * packets ;\n packets = wmem_stack_new ( wmem_packet_scope ( ) ) ;\n wmem_stack_push ( packets , 0 ) ;\n tp = ( rtmpt_packet_t * ) wmem_tree_lookup32_le ( rconv -> packets [ cdir ] , seq + remain - 1 ) ;\n while ( tp && tp -> lastseq >= seq ) {\n wmem_stack_push ( packets , tp ) ;\n tp = ( rtmpt_packet_t * ) wmem_tree_lookup32_le ( rconv -> packets [ cdir ] , tp -> lastseq - 1 ) ;\n }\n while ( ( tp = ( rtmpt_packet_t * ) wmem_stack_pop ( packets ) ) != NULL ) {\n if ( tp -> resident ) {\n pktbuf = tvb_new_child_real_data ( tvb , tp -> data . p , tp -> have , tp -> have ) ;\n add_new_data_source ( pinfo , pktbuf , \"Unchunked RTMP\" ) ;\n }\n else {\n pktbuf = tvb_new_subset_length ( tvb , tp -> data . offset , tp -> have ) ;\n }\n dissect_rtmpt ( pktbuf , pinfo , tree , rconv , cdir , tp ) ;\n }\n return ;\n }\n while ( remain > 0 ) {\n tf = NULL ;\n ti = NULL ;\n tp = NULL ;\n if ( offset == 0 ) {\n tf = ( rtmpt_frag_t * ) wmem_tree_lookup32_le ( rconv -> frags [ cdir ] , seq + offset - 1 ) ;\n if ( tf ) {\n RTMPT_DEBUG ( \" tf seq=%d lseq=%d h=%d l=%d\\n\" , tf -> seq , tf -> lastseq , tf -> have , tf -> len ) ;\n if ( tf -> have >= tf -> len || seq + offset < tf -> seq || seq + offset > tf -> lastseq + tf -> len - tf -> have ) {\n tf = NULL ;\n }\n else if ( ! tf -> ishdr ) {\n ti = ( rtmpt_id_t * ) wmem_tree_lookup32 ( rconv -> ids [ cdir ] , tf -> saved . id ) ;\n if ( ti ) {\n tp = ( rtmpt_packet_t * ) wmem_tree_lookup32_le ( ti -> packets , seq + offset - 1 ) ;\n }\n if ( tp && tp -> chunkwant ) {\n goto unchunk ;\n }\n tf = NULL ;\n ti = NULL ;\n tp = NULL ;\n }\n if ( tf ) {\n want = tf -> len - tf -> have ;\n if ( remain < want ) want = remain ;\n tvb_memcpy ( tvb , tf -> saved . d + tf -> have , offset , want ) ;\n id = tf -> saved . d [ 0 ] ;\n header_type = ( id >> 6 ) & 3 ;\n basic_hlen = rtmpt_basic_header_length ( id ) ;\n if ( ( header_type < 3 ) && ( tf -> have < ( basic_hlen + 3 ) ) && ( tf -> have + want >= ( basic_hlen + 3 ) ) ) {\n if ( pntoh24 ( tf -> saved . d + basic_hlen ) == 0xffffff ) {\n tf -> len += 4 ;\n }\n }\n tf -> have += want ;\n tf -> lastseq = seq + want - 1 ;\n remain -= want ;\n offset += want ;\n if ( tf -> have < tf -> len ) {\n return ;\n }\n }\n }\n }\n if ( ! tf ) {\n id = tvb_get_guint8 ( tvb , offset ) ;\n if ( id == RTMPT_MAGIC && seq + offset == RTMPT_HANDSHAKE_OFFSET_1 ) {\n header_type = 4 ;\n basic_hlen = 1 ;\n message_hlen = 0 ;\n id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2 ;\n }\n else if ( seq + offset == RTMPT_HANDSHAKE_OFFSET_2 ) {\n header_type = 4 ;\n basic_hlen = 0 ;\n message_hlen = 0 ;\n id = RTMPT_TYPE_HANDSHAKE_3 ;\n }\n else {\n header_type = ( id >> 6 ) & 3 ;\n basic_hlen = rtmpt_basic_header_length ( id ) ;\n message_hlen = rtmpt_message_header_length ( id ) ;\n if ( ( header_type < 3 ) && ( remain >= ( basic_hlen + 3 ) ) ) {\n if ( tvb_get_ntoh24 ( tvb , offset + basic_hlen ) == 0xffffff ) {\n message_hlen += 4 ;\n }\n }\n if ( remain < ( basic_hlen + message_hlen ) ) {\n tf = wmem_new ( wmem_file_scope ( ) , rtmpt_frag_t ) ;\n tf -> ishdr = 1 ;\n tf -> seq = seq + offset ;\n tf -> lastseq = tf -> seq + remain - 1 ;\n tf -> len = basic_hlen + message_hlen ;\n tvb_memcpy ( tvb , tf -> saved . d , offset , remain ) ;\n tf -> have = remain ;\n wmem_tree_insert32 ( rconv -> frags [ cdir ] , seq + offset , tf ) ;\n return ;\n }\n id = id & 0x3f ;\n if ( id == 0 ) id = tvb_get_guint8 ( tvb , offset + 1 ) + 64 ;\n else if ( id == 1 ) id = tvb_get_letohs ( tvb , offset + 1 ) + 64 ;\n }\n }\n else {\n id = tf -> saved . d [ 0 ] ;\n header_type = ( id >> 6 ) & 3 ;\n basic_hlen = rtmpt_basic_header_length ( id ) ;\n message_hlen = tf -> len - basic_hlen ;\n id = id & 0x3f ;\n if ( id == 0 ) id = tf -> saved . d [ 1 ] + 64 ;\n else if ( id == 1 ) id = pletoh16 ( tf -> saved . d + 1 ) + 64 ;\n }\n if ( id <= RTMPT_ID_MAX ) ti = ( rtmpt_id_t * ) wmem_tree_lookup32 ( rconv -> ids [ cdir ] , id ) ;\n if ( ti ) tp = ( rtmpt_packet_t * ) wmem_tree_lookup32_le ( ti -> packets , seq + offset - 1 ) ;\n if ( header_type == 0 ) src = tf ? pntoh32 ( tf -> saved . d + basic_hlen + 7 ) : tvb_get_ntohl ( tvb , offset + basic_hlen + 7 ) ;\n else if ( ti ) src = ti -> src ;\n else src = 0 ;\n if ( header_type < 2 ) cmd = tf ? tf -> saved . d [ basic_hlen + 6 ] : tvb_get_guint8 ( tvb , offset + basic_hlen + 6 ) ;\n else if ( ti ) cmd = ti -> cmd ;\n else cmd = 0 ;\n if ( id > RTMPT_ID_MAX ) {\n if ( id == RTMPT_TYPE_HANDSHAKE_1 ) chunk_size = body_len = 1536 ;\n else if ( id == RTMPT_TYPE_HANDSHAKE_2 ) chunk_size = body_len = 3072 ;\n else chunk_size = body_len = 1536 ;\n }\n else {\n chunk_size = GPOINTER_TO_INT ( wmem_tree_lookup32_le ( rconv -> chunksize [ cdir ] , seq + offset - 1 ) ) ;\n if ( ! chunk_size ) chunk_size = RTMPT_DEFAULT_CHUNK_SIZE ;\n if ( header_type < 2 ) body_len = tf ? pntoh24 ( tf -> saved . d + basic_hlen + 3 ) : tvb_get_ntoh24 ( tvb , offset + basic_hlen + 3 ) ;\n else if ( ti ) body_len = ti -> len ;\n else body_len = chunk_size ;\n if ( body_len > ( gint ) rtmpt_max_packet_size ) {\n return ;\n }\n }\n if ( ! ti || ! tp || header_type < 3 || tp -> have == tp -> want || tp -> chunkhave != tp -> chunkwant ) {\n RTMPT_DEBUG ( \"New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\" , cdir , seq + offset , ti , tp , header_type , basic_hlen + message_hlen , id , tp ? tp -> have : 0 , tp ? tp -> want : 0 , body_len , chunk_size ) ;\n if ( ! ti ) {\n ti = wmem_new ( wmem_file_scope ( ) , rtmpt_id_t ) ;\n ti -> packets = wmem_tree_new ( wmem_file_scope ( ) ) ;\n ti -> ts = 0 ;\n ti -> tsd = 0 ;\n wmem_tree_insert32 ( rconv -> ids [ cdir ] , id , ti ) ;\n }\n if ( header_type == 0 ) {\n ts = tf ? pntoh24 ( tf -> saved . d + basic_hlen ) : tvb_get_ntoh24 ( tvb , offset + basic_hlen ) ;\n if ( ts == 0xffffff ) {\n ts = tf ? pntoh32 ( tf -> saved . d + basic_hlen + 11 ) : tvb_get_ntohl ( tvb , offset + basic_hlen + 11 ) ;\n }\n tsd = ts - ti -> ts ;\n }\n else if ( header_type < 3 ) {\n tsd = tf ? pntoh24 ( tf -> saved . d + basic_hlen ) : tvb_get_ntoh24 ( tvb , offset + basic_hlen ) ;\n if ( tsd == 0xffffff ) {\n ts = tf ? pntoh32 ( tf -> saved . d + basic_hlen + message_hlen - 4 ) : tvb_get_ntohl ( tvb , offset + basic_hlen + message_hlen - 4 ) ;\n tsd = ti -> tsd ;\n }\n else {\n ts = ti -> ts + tsd ;\n }\n }\n else {\n ts = ti -> ts + ti -> tsd ;\n tsd = ti -> tsd ;\n }\n tp = wmem_new ( wmem_file_scope ( ) , rtmpt_packet_t ) ;\n tp -> seq = tp -> lastseq = tf ? tf -> seq : seq + offset ;\n tp -> have = 0 ;\n tp -> want = basic_hlen + message_hlen + body_len ;\n tp -> chunkwant = 0 ;\n tp -> chunkhave = 0 ;\n tp -> bhlen = basic_hlen ;\n tp -> mhlen = message_hlen ;\n tp -> fmt = header_type ;\n tp -> id = id ;\n tp -> ts = ts ;\n tp -> len = body_len ;\n if ( id > RTMPT_ID_MAX ) tp -> cmd = id ;\n else tp -> cmd = cmd & 0x7f ;\n tp -> src = src ;\n tp -> txid = 0 ;\n tp -> isresponse = FALSE ;\n tp -> otherframe = 0 ;\n ti -> ts = ts ;\n ti -> tsd = tsd ;\n ti -> len = body_len ;\n ti -> cmd = cmd ;\n ti -> src = src ;\n wmem_tree_insert32 ( ti -> packets , tp -> seq , tp ) ;\n if ( ! tf && body_len <= chunk_size && tp -> want <= remain ) {\n tp -> resident = FALSE ;\n tp -> data . offset = offset ;\n tp -> lastseq = seq + offset + tp -> want - 1 ;\n tp -> have = tp -> want ;\n wmem_tree_insert32 ( rconv -> packets [ cdir ] , tp -> lastseq , tp ) ;\n pktbuf = tvb_new_subset_length ( tvb , tp -> data . offset , tp -> have ) ;\n dissect_rtmpt ( pktbuf , pinfo , tree , rconv , cdir , tp ) ;\n offset += tp -> want ;\n remain -= tp -> want ;\n continue ;\n }\n else {\n tp -> resident = TRUE ;\n tp -> data . p = ( guint8 * ) wmem_alloc ( wmem_file_scope ( ) , tp -> bhlen + tp -> mhlen + tp -> len ) ;\n if ( tf && tf -> ishdr ) {\n memcpy ( tp -> data . p , tf -> saved . d , tf -> len ) ;\n }\n else {\n tvb_memcpy ( tvb , tp -> data . p , offset , basic_hlen + message_hlen ) ;\n offset += basic_hlen + message_hlen ;\n remain -= basic_hlen + message_hlen ;\n }\n tp -> lastseq = seq + offset - 1 ;\n tp -> have = basic_hlen + message_hlen ;\n if ( tp -> have == tp -> want ) {\n wmem_tree_insert32 ( rconv -> packets [ cdir ] , tp -> lastseq , tp ) ;\n pktbuf = tvb_new_child_real_data ( tvb , tp -> data . p , tp -> have , tp -> have ) ;\n add_new_data_source ( pinfo , pktbuf , \"Unchunked RTMP\" ) ;\n dissect_rtmpt ( pktbuf , pinfo , tree , rconv , cdir , tp ) ;\n continue ;\n }\n tp -> chunkwant = chunk_size ;\n if ( tp -> chunkwant > tp -> want - tp -> have ) tp -> chunkwant = tp -> want - tp -> have ;\n }\n }\n else {\n RTMPT_DEBUG ( \"Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\" , cdir , seq + offset , ti , tp , basic_hlen + message_hlen , id , tp ? tp -> have : 0 , tp ? tp -> want : 0 , body_len , chunk_size ) ;\n tp -> chunkwant = chunk_size ;\n if ( tp -> chunkwant > tp -> want - tp -> have ) tp -> chunkwant = tp -> want - tp -> have ;\n offset += basic_hlen + message_hlen ;\n remain -= basic_hlen + message_hlen ;\n }\n tf = NULL ;\n unchunk : want = tp -> chunkwant - tp -> chunkhave ;\n if ( want > remain ) want = remain ;\n RTMPT_DEBUG ( \" cw=%d ch=%d r=%d w=%d\\n\" , tp -> chunkwant , tp -> chunkhave , remain , want ) ;\n tvb_memcpy ( tvb , tp -> data . p + tp -> have , offset , want ) ;\n if ( tf ) {\n tf -> have += want ;\n tf -> lastseq = seq + offset + want - 1 ;\n }\n tp -> lastseq = seq + offset + want - 1 ;\n tp -> have += want ;\n tp -> chunkhave += want ;\n offset += want ;\n remain -= want ;\n if ( tp -> chunkhave == tp -> chunkwant ) {\n tp -> chunkhave = 0 ;\n tp -> chunkwant = 0 ;\n }\n if ( tp -> have == tp -> want ) {\n wmem_tree_insert32 ( rconv -> packets [ cdir ] , tp -> lastseq , tp ) ;\n pktbuf = tvb_new_child_real_data ( tvb , tp -> data . p , tp -> have , tp -> have ) ;\n add_new_data_source ( pinfo , pktbuf , \"Unchunked RTMP\" ) ;\n dissect_rtmpt ( pktbuf , pinfo , tree , rconv , cdir , tp ) ;\n }\n else if ( tp -> chunkhave < tp -> chunkwant ) {\n rtmpt_frag_t * tf2 = wmem_new ( wmem_file_scope ( ) , rtmpt_frag_t ) ;\n tf2 -> ishdr = 0 ;\n tf2 -> seq = seq + offset - want ;\n tf2 -> lastseq = tf2 -> seq + remain - 1 + want ;\n tf2 -> have = tp -> chunkhave ;\n tf2 -> len = tp -> chunkwant ;\n tf2 -> saved . id = tp -> id ;\n RTMPT_DEBUG ( \" inserting tf @ %d\\n\" , seq + offset - want - 1 ) ;\n wmem_tree_insert32 ( rconv -> frags [ cdir ] , seq + offset - want - 1 , tf2 ) ;\n }\n }\n }",
        "hash": -8199454075838226273,
        "project": "debian",
        "size": 292,
        "slice": {
            "memcpy": [
                [
                    48,
                    " tf = ( rtmpt_frag_t * ) wmem_tree_lookup32_le ( rconv -> frags [ cdir ] , seq + offset - 1 ) ;\n"
                ],
                [
                    50,
                    " RTMPT_DEBUG ( \" tf seq=%d lseq=%d h=%d l=%d\\n\" , tf -> seq , tf -> lastseq , tf -> have , tf -> len ) ;\n"
                ],
                [
                    51,
                    " if ( tf -> have >= tf -> len || seq + offset < tf -> seq || seq + offset > tf -> lastseq + tf -> len - tf -> have ) {\n"
                ],
                [
                    82,
                    " if ( tf -> have < tf -> len ) {\n"
                ],
                [
                    88,
                    " if ( ! tf ) {\n"
                ],
                [
                    131,
                    " message_hlen = tf -> len - basic_hlen ;\n"
                ],
                [
                    213,
                    " if ( ! tf && body_len <= chunk_size && tp -> want <= remain ) {\n"
                ],
                [
                    227,
                    " tp -> data . p = ( guint8 * ) wmem_alloc ( wmem_file_scope ( ) , tp -> bhlen + tp -> mhlen + tp -> len ) ;\n"
                ],
                [
                    228,
                    " if ( tf && tf -> ishdr ) {\n"
                ],
                [
                    229,
                    " memcpy ( tp -> data . p , tf -> saved . d , tf -> len ) ;\n"
                ],
                [
                    260,
                    " tvb_memcpy ( tvb , tp -> data . p + tp -> have , offset , want ) ;\n"
                ]
            ],
            "result": [
                [
                    48,
                    " tf = ( rtmpt_frag_t * ) wmem_tree_lookup32_le ( rconv -> frags [ cdir ] , seq + offset - 1 ) ;\n"
                ],
                [
                    50,
                    " RTMPT_DEBUG ( \" tf seq=%d lseq=%d h=%d l=%d\\n\" , tf -> seq , tf -> lastseq , tf -> have , tf -> len ) ;\n"
                ],
                [
                    51,
                    " if ( tf -> have >= tf -> len || seq + offset < tf -> seq || seq + offset > tf -> lastseq + tf -> len - tf -> have ) {\n"
                ],
                [
                    82,
                    " if ( tf -> have < tf -> len ) {\n"
                ],
                [
                    88,
                    " if ( ! tf ) {\n"
                ],
                [
                    131,
                    " message_hlen = tf -> len - basic_hlen ;\n"
                ],
                [
                    213,
                    " if ( ! tf && body_len <= chunk_size && tp -> want <= remain ) {\n"
                ],
                [
                    227,
                    " tp -> data . p = ( guint8 * ) wmem_alloc ( wmem_file_scope ( ) , tp -> bhlen + tp -> mhlen + tp -> len ) ;\n"
                ],
                [
                    228,
                    " if ( tf && tf -> ishdr ) {\n"
                ],
                [
                    229,
                    " memcpy ( tp -> data . p , tf -> saved . d , tf -> len ) ;\n"
                ],
                [
                    260,
                    " tvb_memcpy ( tvb , tp -> data . p + tp -> have , offset , want ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) {\n char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ;\n unsigned char hmac_response [ MD5_DIGEST_LEN ] ;\n int len ;\n int rc ;\n if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ;\n mutt_message ( _ ( \"Authenticating (CRAM-MD5)...\" ) ) ;\n if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n imap_cmd_start ( idata , \"AUTHENTICATE CRAM-MD5\" ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_RESPOND ) {\n mutt_debug ( 1 , \"Invalid response from server: %s\\n\" , ibuf ) ;\n goto bail ;\n }\n len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ;\n if ( len == - 1 ) {\n mutt_debug ( 1 , \"Error decoding base64 response.\\n\" ) ;\n goto bail ;\n }\n obuf [ len ] = '\\0' ;\n mutt_debug ( 2 , \"CRAM challenge: %s\\n\" , obuf ) ;\n hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ;\n int off = snprintf ( obuf , sizeof ( obuf ) , \"%s \" , idata -> conn -> account . user ) ;\n mutt_md5_toascii ( hmac_response , obuf + off ) ;\n mutt_debug ( 2 , \"CRAM response: %s\\n\" , obuf ) ;\n mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ;\n mutt_str_strcat ( ibuf , sizeof ( ibuf ) , \"\\r\\n\" ) ;\n mutt_socket_send ( idata -> conn , ibuf ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_OK ) {\n mutt_debug ( 1 , \"Error receiving server response.\\n\" ) ;\n goto bail ;\n }\n if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ;\n bail : mutt_error ( _ ( \"CRAM-MD5 authentication failed.\" ) ) ;\n return IMAP_AUTH_FAILURE ;\n }",
        "hash": 8326517429469576957,
        "project": "debian",
        "size": 40,
        "slice": {
            "strlen": [
                [
                    1,
                    "enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) {\n"
                ],
                [
                    18,
                    " if ( len == - 1 ) {\n"
                ],
                [
                    22,
                    " obuf [ len ] = '\\0' ;\n"
                ],
                [
                    27,
                    " mutt_debug ( 2 , \"CRAM response: %s\\n\" , obuf ) ;\n"
                ],
                [
                    28,
                    " mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) {\n"
                ],
                [
                    18,
                    " if ( len == - 1 ) {\n"
                ],
                [
                    22,
                    " obuf [ len ] = '\\0' ;\n"
                ],
                [
                    27,
                    " mutt_debug ( 2 , \"CRAM response: %s\\n\" , obuf ) ;\n"
                ],
                [
                    28,
                    " mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) {\n gss_buffer_desc request_buf , send_token ;\n gss_buffer_t sec_token ;\n gss_name_t target_name ;\n gss_ctx_id_t context ;\n gss_OID mech_name ;\n char server_conf_flags ;\n gss_qop_t quality ;\n int cflags ;\n OM_uint32 maj_stat , min_stat ;\n char buf1 [ GSS_BUFSIZE ] , buf2 [ GSS_BUFSIZE ] ;\n unsigned long buf_size ;\n int rc ;\n if ( ! mutt_bit_isset ( idata -> capabilities , AGSSAPI ) ) return IMAP_AUTH_UNAVAIL ;\n if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n snprintf ( buf1 , sizeof ( buf1 ) , \"imap@%s\" , idata -> conn -> account . host ) ;\n request_buf . value = buf1 ;\n request_buf . length = strlen ( buf1 ) ;\n maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ;\n if ( maj_stat != GSS_S_COMPLETE ) {\n mutt_debug ( 2 , \"Couldn't get service name for [%s]\\n\" , buf1 ) ;\n return IMAP_AUTH_UNAVAIL ;\n }\n else if ( DebugLevel >= 2 ) {\n gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ;\n mutt_debug ( 2 , \"Using service name [%s]\\n\" , ( char * ) request_buf . value ) ;\n gss_release_buffer ( & min_stat , & request_buf ) ;\n }\n sec_token = GSS_C_NO_BUFFER ;\n context = GSS_C_NO_CONTEXT ;\n maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ;\n if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) {\n print_gss_error ( maj_stat , min_stat ) ;\n mutt_debug ( 1 , \"Error acquiring credentials - no TGT?\\n\" ) ;\n gss_release_name ( & min_stat , & target_name ) ;\n return IMAP_AUTH_UNAVAIL ;\n }\n mutt_message ( _ ( \"Authenticating (GSSAPI)...\" ) ) ;\n imap_cmd_start ( idata , \"AUTHENTICATE GSSAPI\" ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_RESPOND ) {\n mutt_debug ( 2 , \"Invalid response from server: %s\\n\" , buf1 ) ;\n gss_release_name ( & min_stat , & target_name ) ;\n goto bail ;\n }\n mutt_debug ( 2 , \"Sending credentials\\n\" ) ;\n mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ;\n gss_release_buffer ( & min_stat , & send_token ) ;\n mutt_str_strcat ( buf1 , sizeof ( buf1 ) , \"\\r\\n\" ) ;\n mutt_socket_send ( idata -> conn , buf1 ) ;\n while ( maj_stat == GSS_S_CONTINUE_NEEDED ) {\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_RESPOND ) {\n mutt_debug ( 1 , \"#1 Error receiving server response.\\n\" ) ;\n gss_release_name ( & min_stat , & target_name ) ;\n goto bail ;\n }\n request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;\n request_buf . value = buf2 ;\n sec_token = & request_buf ;\n maj_stat = gss_init_sec_context ( & min_stat , GSS_C_NO_CREDENTIAL , & context , target_name , GSS_C_NO_OID , GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG , 0 , GSS_C_NO_CHANNEL_BINDINGS , sec_token , NULL , & send_token , ( unsigned int * ) & cflags , NULL ) ;\n if ( maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED ) {\n print_gss_error ( maj_stat , min_stat ) ;\n mutt_debug ( 1 , \"Error exchanging credentials\\n\" ) ;\n gss_release_name ( & min_stat , & target_name ) ;\n goto err_abort_cmd ;\n }\n mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ;\n gss_release_buffer ( & min_stat , & send_token ) ;\n mutt_str_strcat ( buf1 , sizeof ( buf1 ) , \"\\r\\n\" ) ;\n mutt_socket_send ( idata -> conn , buf1 ) ;\n }\n gss_release_name ( & min_stat , & target_name ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc != IMAP_CMD_RESPOND ) {\n mutt_debug ( 1 , \"#2 Error receiving server response.\\n\" ) ;\n goto bail ;\n }\n request_buf . length = mutt_b64_decode ( buf2 , idata -> buf + 2 ) ;\n request_buf . value = buf2 ;\n maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ;\n if ( maj_stat != GSS_S_COMPLETE ) {\n print_gss_error ( maj_stat , min_stat ) ;\n mutt_debug ( 2 , \"Couldn't unwrap security level data\\n\" ) ;\n gss_release_buffer ( & min_stat , & send_token ) ;\n goto err_abort_cmd ;\n }\n mutt_debug ( 2 , \"Credential exchange complete\\n\" ) ;\n server_conf_flags = ( ( char * ) send_token . value ) [ 0 ] ;\n if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) {\n mutt_debug ( 2 , \"Server requires integrity or privacy\\n\" ) ;\n gss_release_buffer ( & min_stat , & send_token ) ;\n goto err_abort_cmd ;\n }\n ( ( char * ) send_token . value ) [ 0 ] = '\\0' ;\n buf_size = ntohl ( * ( ( long * ) send_token . value ) ) ;\n gss_release_buffer ( & min_stat , & send_token ) ;\n mutt_debug ( 2 , \"Unwrapped security level flags: %c%c%c\\n\" , ( server_conf_flags & GSS_AUTH_P_NONE ) ? 'N' : '-' , ( server_conf_flags & GSS_AUTH_P_INTEGRITY ) ? 'I' : '-' , ( server_conf_flags & GSS_AUTH_P_PRIVACY ) ? 'P' : '-' ) ;\n mutt_debug ( 2 , \"Maximum GSS token size is %ld\\n\" , buf_size ) ;\n buf_size = htonl ( buf_size ) ;\n memcpy ( buf1 , & buf_size , 4 ) ;\n buf1 [ 0 ] = GSS_AUTH_P_NONE ;\n strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ;\n request_buf . value = buf1 ;\n request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ;\n maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ;\n if ( maj_stat != GSS_S_COMPLETE ) {\n mutt_debug ( 2 , \"Error creating login request\\n\" ) ;\n goto err_abort_cmd ;\n }\n mutt_b64_encode ( buf1 , send_token . value , send_token . length , sizeof ( buf1 ) - 2 ) ;\n mutt_debug ( 2 , \"Requesting authorisation as %s\\n\" , idata -> conn -> account . user ) ;\n mutt_str_strcat ( buf1 , sizeof ( buf1 ) , \"\\r\\n\" ) ;\n mutt_socket_send ( idata -> conn , buf1 ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n if ( rc == IMAP_CMD_RESPOND ) {\n mutt_debug ( 1 , \"Unexpected server continuation request.\\n\" ) ;\n goto err_abort_cmd ;\n }\n if ( imap_code ( idata -> buf ) ) {\n mutt_debug ( 2 , \"Releasing GSS credentials\\n\" ) ;\n maj_stat = gss_delete_sec_context ( & min_stat , & context , & send_token ) ;\n if ( maj_stat != GSS_S_COMPLETE ) mutt_debug ( 1 , \"Error releasing credentials\\n\" ) ;\n gss_release_buffer ( & min_stat , & send_token ) ;\n return IMAP_AUTH_SUCCESS ;\n }\n else goto bail ;\n err_abort_cmd : mutt_socket_send ( idata -> conn , \"*\\r\\n\" ) ;\n do rc = imap_cmd_step ( idata ) ;\n while ( rc == IMAP_CMD_CONTINUE ) ;\n bail : mutt_error ( _ ( \"GSSAPI authentication failed.\" ) ) ;\n return IMAP_AUTH_FAILURE ;\n }",
        "hash": 8280658844309151365,
        "project": "debian",
        "size": 137,
        "slice": {
            "memcpy": [
                [
                    1,
                    "enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) {\n"
                ],
                [
                    51,
                    " mutt_socket_send ( idata -> conn , buf1 ) ;\n"
                ],
                [
                    73,
                    " mutt_socket_send ( idata -> conn , buf1 ) ;\n"
                ],
                [
                    93,
                    " if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) {\n"
                ],
                [
                    103,
                    " buf_size = htonl ( buf_size ) ;\n"
                ],
                [
                    104,
                    " memcpy ( buf1 , & buf_size , 4 ) ;\n"
                ],
                [
                    106,
                    " strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ;\n"
                ]
            ],
            "strncpy": [
                [
                    1,
                    "enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) {\n"
                ],
                [
                    93,
                    " if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) {\n"
                ],
                [
                    104,
                    " memcpy ( buf1 , & buf_size , 4 ) ;\n"
                ],
                [
                    105,
                    " buf1 [ 0 ] = GSS_AUTH_P_NONE ;\n"
                ],
                [
                    106,
                    " strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ;\n"
                ],
                [
                    108,
                    " request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) {\n"
                ],
                [
                    15,
                    " if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n"
                ],
                [
                    16,
                    " snprintf ( buf1 , sizeof ( buf1 ) , \"imap@%s\" , idata -> conn -> account . host ) ;\n"
                ],
                [
                    18,
                    " request_buf . length = strlen ( buf1 ) ;\n"
                ],
                [
                    19,
                    " maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ;\n"
                ],
                [
                    21,
                    " mutt_debug ( 2 , \"Couldn't get service name for [%s]\\n\" , buf1 ) ;\n"
                ],
                [
                    25,
                    " gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ;\n"
                ],
                [
                    26,
                    " mutt_debug ( 2 , \"Using service name [%s]\\n\" , ( char * ) request_buf . value ) ;\n"
                ],
                [
                    27,
                    " gss_release_buffer ( & min_stat , & request_buf ) ;\n"
                ],
                [
                    43,
                    " mutt_debug ( 2 , \"Invalid response from server: %s\\n\" , buf1 ) ;\n"
                ],
                [
                    62,
                    " sec_token = & request_buf ;\n"
                ],
                [
                    84,
                    " maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ;\n"
                ],
                [
                    93,
                    " if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) {\n"
                ],
                [
                    106,
                    " strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ;\n"
                ],
                [
                    108,
                    " request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ;\n"
                ],
                [
                    109,
                    " maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ;\n"
                ],
                [
                    115,
                    " mutt_debug ( 2 , \"Requesting authorisation as %s\\n\" , idata -> conn -> account . user ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) {\n"
                ],
                [
                    15,
                    " if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n"
                ],
                [
                    16,
                    " snprintf ( buf1 , sizeof ( buf1 ) , \"imap@%s\" , idata -> conn -> account . host ) ;\n"
                ],
                [
                    18,
                    " request_buf . length = strlen ( buf1 ) ;\n"
                ],
                [
                    19,
                    " maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ;\n"
                ],
                [
                    21,
                    " mutt_debug ( 2 , \"Couldn't get service name for [%s]\\n\" , buf1 ) ;\n"
                ],
                [
                    25,
                    " gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ;\n"
                ],
                [
                    26,
                    " mutt_debug ( 2 , \"Using service name [%s]\\n\" , ( char * ) request_buf . value ) ;\n"
                ],
                [
                    27,
                    " gss_release_buffer ( & min_stat , & request_buf ) ;\n"
                ],
                [
                    43,
                    " mutt_debug ( 2 , \"Invalid response from server: %s\\n\" , buf1 ) ;\n"
                ],
                [
                    51,
                    " mutt_socket_send ( idata -> conn , buf1 ) ;\n"
                ],
                [
                    62,
                    " sec_token = & request_buf ;\n"
                ],
                [
                    73,
                    " mutt_socket_send ( idata -> conn , buf1 ) ;\n"
                ],
                [
                    84,
                    " maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ;\n"
                ],
                [
                    93,
                    " if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) {\n"
                ],
                [
                    103,
                    " buf_size = htonl ( buf_size ) ;\n"
                ],
                [
                    104,
                    " memcpy ( buf1 , & buf_size , 4 ) ;\n"
                ],
                [
                    105,
                    " buf1 [ 0 ] = GSS_AUTH_P_NONE ;\n"
                ],
                [
                    106,
                    " strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ;\n"
                ],
                [
                    108,
                    " request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ;\n"
                ],
                [
                    109,
                    " maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ;\n"
                ],
                [
                    115,
                    " mutt_debug ( 2 , \"Requesting authorisation as %s\\n\" , idata -> conn -> account . user ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) {\n ssize_t l , ll , o ;\n double now ;\n uint8_t * ptr ;\n struct vsb * synth_body ;\n CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ;\n CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ;\n CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ;\n AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ;\n assert ( bo -> director_state == DIR_S_NULL ) ;\n wrk -> stats -> fetch_failed ++ ;\n now = W_TIM_real ( wrk ) ;\n VSLb_ts_busyobj ( bo , \"Error\" , now ) ;\n if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ;\n HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ;\n http_PutResponse ( bo -> beresp , \"HTTP/1.1\" , 503 , \"Backend fetch failed\" ) ;\n http_TimeHeader ( bo -> beresp , \"Date: \" , now ) ;\n http_SetHeader ( bo -> beresp , \"Server: Varnish\" ) ;\n bo -> fetch_objcore -> t_origin = now ;\n if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) {\n bo -> fetch_objcore -> ttl = 1 ;\n bo -> fetch_objcore -> grace = 5 ;\n bo -> fetch_objcore -> keep = 5 ;\n }\n else {\n bo -> fetch_objcore -> ttl = 0 ;\n bo -> fetch_objcore -> grace = 0 ;\n bo -> fetch_objcore -> keep = 0 ;\n }\n synth_body = VSB_new_auto ( ) ;\n AN ( synth_body ) ;\n VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ;\n AZ ( VSB_finish ( synth_body ) ) ;\n if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) {\n VSB_destroy ( & synth_body ) ;\n return ( F_STP_FAIL ) ;\n }\n if ( wrk -> handling == VCL_RET_RETRY ) {\n VSB_destroy ( & synth_body ) ;\n if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ;\n VSLb ( bo -> vsl , SLT_VCL_Error , \"Too many retries, failing\" ) ;\n return ( F_STP_FAIL ) ;\n }\n assert ( wrk -> handling == VCL_RET_DELIVER ) ;\n bo -> vfc -> bo = bo ;\n bo -> vfc -> wrk = bo -> wrk ;\n bo -> vfc -> oc = bo -> fetch_objcore ;\n bo -> vfc -> http = bo -> beresp ;\n bo -> vfc -> esi_req = bo -> bereq ;\n if ( vbf_beresp2obj ( bo ) ) {\n ( void ) VFP_Error ( bo -> vfc , \"Could not get storage\" ) ;\n VSB_destroy ( & synth_body ) ;\n return ( F_STP_FAIL ) ;\n }\n ll = VSB_len ( synth_body ) ;\n o = 0 ;\n while ( ll > 0 ) {\n l = ll ;\n if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ;\n memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;\n VFP_Extend ( bo -> vfc , l ) ;\n ll -= l ;\n o += l ;\n }\n AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ;\n VSB_destroy ( & synth_body ) ;\n HSH_Unbusy ( wrk , bo -> fetch_objcore ) ;\n ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ;\n return ( F_STP_DONE ) ;\n }",
        "hash": -4810636875286199147,
        "project": "debian",
        "size": 70,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) {\n"
                ],
                [
                    56,
                    " o = 0 ;\n"
                ],
                [
                    58,
                    " l = ll ;\n"
                ],
                [
                    59,
                    " if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ;\n"
                ],
                [
                    60,
                    " memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;\n"
                ],
                [
                    61,
                    " VFP_Extend ( bo -> vfc , l ) ;\n"
                ],
                [
                    63,
                    " o += l ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) {\n"
                ],
                [
                    56,
                    " o = 0 ;\n"
                ],
                [
                    58,
                    " l = ll ;\n"
                ],
                [
                    59,
                    " if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ;\n"
                ],
                [
                    60,
                    " memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;\n"
                ],
                [
                    61,
                    " VFP_Extend ( bo -> vfc , l ) ;\n"
                ],
                [
                    63,
                    " o += l ;\n"
                ]
            ]
        }
    },
    {
        "code": "void DefaultTTFEnglishNames ( struct ttflangname * dummy , SplineFont * sf ) {\n time_t now ;\n struct tm * tm ;\n char buffer [ 200 ] ;\n if ( dummy -> names [ ttf_copyright ] == NULL || * dummy -> names [ ttf_copyright ] == '\\0' ) dummy -> names [ ttf_copyright ] = utf8_verify_copy ( sf -> copyright ) ;\n if ( dummy -> names [ ttf_family ] == NULL || * dummy -> names [ ttf_family ] == '\\0' ) dummy -> names [ ttf_family ] = utf8_verify_copy ( sf -> familyname ) ;\n if ( dummy -> names [ ttf_subfamily ] == NULL || * dummy -> names [ ttf_subfamily ] == '\\0' ) dummy -> names [ ttf_subfamily ] = utf8_verify_copy ( SFGetModifiers ( sf ) ) ;\n if ( dummy -> names [ ttf_uniqueid ] == NULL || * dummy -> names [ ttf_uniqueid ] == '\\0' ) {\n time ( & now ) ;\n tm = localtime ( & now ) ;\n sprintf ( buffer , \"%s : %s : %d-%d-%d\" , BDFFoundry ? BDFFoundry : TTFFoundry ? TTFFoundry : \"FontForge 2.0\" , sf -> fullname != NULL ? sf -> fullname : sf -> fontname , tm -> tm_mday , tm -> tm_mon + 1 , tm -> tm_year + 1900 ) ;\n dummy -> names [ ttf_uniqueid ] = copy ( buffer ) ;\n }\n if ( dummy -> names [ ttf_fullname ] == NULL || * dummy -> names [ ttf_fullname ] == '\\0' ) dummy -> names [ ttf_fullname ] = utf8_verify_copy ( sf -> fullname ) ;\n if ( dummy -> names [ ttf_version ] == NULL || * dummy -> names [ ttf_version ] == '\\0' ) {\n if ( sf -> subfontcnt != 0 ) sprintf ( buffer , \"Version %f \" , ( double ) sf -> cidversion ) ;\n else if ( sf -> version != NULL ) sprintf ( buffer , \"Version %.20s \" , sf -> version ) ;\n else strcpy ( buffer , \"Version 1.0\" ) ;\n dummy -> names [ ttf_version ] = copy ( buffer ) ;\n }\n if ( dummy -> names [ ttf_postscriptname ] == NULL || * dummy -> names [ ttf_postscriptname ] == '\\0' ) dummy -> names [ ttf_postscriptname ] = utf8_verify_copy ( sf -> fontname ) ;\n }",
        "hash": -3740862514502467070,
        "project": "debian",
        "size": 22,
        "slice": {
            "sprintf": [
                [
                    1,
                    "void DefaultTTFEnglishNames ( struct ttflangname * dummy , SplineFont * sf ) {\n"
                ],
                [
                    4,
                    " char buffer [ 200 ] ;\n"
                ],
                [
                    7,
                    " if ( dummy -> names [ ttf_subfamily ] == NULL || * dummy -> names [ ttf_subfamily ] == '\\0' ) dummy -> names [ ttf_subfamily ] = utf8_verify_copy ( SFGetModifiers ( sf ) ) ;\n"
                ],
                [
                    8,
                    " if ( dummy -> names [ ttf_uniqueid ] == NULL || * dummy -> names [ ttf_uniqueid ] == '\\0' ) {\n"
                ],
                [
                    10,
                    " tm = localtime ( & now ) ;\n"
                ],
                [
                    11,
                    " sprintf ( buffer , \"%s : %s : %d-%d-%d\" , BDFFoundry ? BDFFoundry : TTFFoundry ? TTFFoundry : \"FontForge 2.0\" , sf -> fullname != NULL ? sf -> fullname : sf -> fontname , tm -> tm_mday , tm -> tm_mon + 1 , tm -> tm_year + 1900 ) ;\n"
                ],
                [
                    12,
                    " dummy -> names [ ttf_uniqueid ] = copy ( buffer ) ;\n"
                ],
                [
                    16,
                    " if ( sf -> subfontcnt != 0 ) sprintf ( buffer , \"Version %f \" , ( double ) sf -> cidversion ) ;\n"
                ],
                [
                    17,
                    " else if ( sf -> version != NULL ) sprintf ( buffer , \"Version %.20s \" , sf -> version ) ;\n"
                ],
                [
                    19,
                    " dummy -> names [ ttf_version ] = copy ( buffer ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void DefaultTTFEnglishNames ( struct ttflangname * dummy , SplineFont * sf ) {\n"
                ],
                [
                    4,
                    " char buffer [ 200 ] ;\n"
                ],
                [
                    7,
                    " if ( dummy -> names [ ttf_subfamily ] == NULL || * dummy -> names [ ttf_subfamily ] == '\\0' ) dummy -> names [ ttf_subfamily ] = utf8_verify_copy ( SFGetModifiers ( sf ) ) ;\n"
                ],
                [
                    8,
                    " if ( dummy -> names [ ttf_uniqueid ] == NULL || * dummy -> names [ ttf_uniqueid ] == '\\0' ) {\n"
                ],
                [
                    10,
                    " tm = localtime ( & now ) ;\n"
                ],
                [
                    11,
                    " sprintf ( buffer , \"%s : %s : %d-%d-%d\" , BDFFoundry ? BDFFoundry : TTFFoundry ? TTFFoundry : \"FontForge 2.0\" , sf -> fullname != NULL ? sf -> fullname : sf -> fontname , tm -> tm_mday , tm -> tm_mon + 1 , tm -> tm_year + 1900 ) ;\n"
                ],
                [
                    12,
                    " dummy -> names [ ttf_uniqueid ] = copy ( buffer ) ;\n"
                ],
                [
                    16,
                    " if ( sf -> subfontcnt != 0 ) sprintf ( buffer , \"Version %f \" , ( double ) sf -> cidversion ) ;\n"
                ],
                [
                    17,
                    " else if ( sf -> version != NULL ) sprintf ( buffer , \"Version %.20s \" , sf -> version ) ;\n"
                ],
                [
                    19,
                    " dummy -> names [ ttf_version ] = copy ( buffer ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "SplineChar * PSCharStringToSplines ( uint8 * type1 , int len , struct pscontext * context , struct pschars * subrs , struct pschars * gsubrs , const char * name ) {\n int is_type2 = context -> is_type2 ;\n real stack [ 50 ] ;\n int sp = 0 , v ;\n real transient [ 32 ] ;\n SplineChar * ret = SplineCharCreate ( 2 ) ;\n SplinePointList * cur = NULL , * oldcur = NULL ;\n RefChar * r1 , * r2 , * rlast = NULL ;\n DBasePoint current ;\n real dx , dy , dx2 , dy2 , dx3 , dy3 , dx4 , dy4 , dx5 , dy5 , dx6 , dy6 ;\n SplinePoint * pt ;\n struct substate {\n unsigned char * type1 ;\n int len ;\n int subnum ;\n }\n pcstack [ 11 ] ;\n int pcsp = 0 ;\n StemInfo * hint , * hp ;\n real pops [ 30 ] ;\n int popsp = 0 ;\n int base , polarity ;\n real coord ;\n struct pschars * s ;\n int hint_cnt = 0 ;\n StemInfo * activeh = NULL , * activev = NULL , * sameh ;\n HintMask * pending_hm = NULL ;\n HintMask * counters [ 96 ] ;\n int cp = 0 ;\n real unblended [ 2 ] [ MmMax ] ;\n int last_was_b1 = false , old_last_was_b1 ;\n if ( ! is_type2 && context -> instance_count > 1 ) memset ( unblended , 0 , sizeof ( unblended ) ) ;\n ret -> name = copy ( name ) ;\n ret -> unicodeenc = - 1 ;\n ret -> width = ( int16 ) 0x8000 ;\n if ( name == NULL ) name = \"unnamed\" ;\n ret -> manualhints = true ;\n current . x = current . y = 0 ;\n while ( len > 0 ) {\n if ( sp > 48 ) {\n LogError ( _ ( \"Stack got too big in %s\\n\" ) , name ) ;\n sp = 48 ;\n }\n base = 0 ;\n -- len ;\n if ( ( v = * type1 ++ ) >= 32 ) {\n if ( v <= 246 ) {\n stack [ sp ++ ] = v - 139 ;\n }\n else if ( v <= 250 ) {\n stack [ sp ++ ] = ( v - 247 ) * 256 + * type1 ++ + 108 ;\n -- len ;\n }\n else if ( v <= 254 ) {\n stack [ sp ++ ] = - ( v - 251 ) * 256 - * type1 ++ - 108 ;\n -- len ;\n }\n else {\n int val = ( * type1 << 24 ) | ( type1 [ 1 ] << 16 ) | ( type1 [ 2 ] << 8 ) | type1 [ 3 ] ;\n stack [ sp ++ ] = val ;\n type1 += 4 ;\n len -= 4 ;\n if ( is_type2 ) {\n # ifndef PSFixed_Is_TTF stack [ sp - 1 ] /= 65536. ;\n # else int mant = val & 0xffff ;\n stack [ sp - 1 ] = ( val >> 16 ) + mant / 65536. ;\n # endif }\n }\n }\n else if ( v == 28 ) {\n stack [ sp ++ ] = ( short ) ( ( type1 [ 0 ] << 8 ) | type1 [ 1 ] ) ;\n type1 += 2 ;\n len -= 2 ;\n }\n else if ( v == 12 ) {\n old_last_was_b1 = last_was_b1 ;\n last_was_b1 = false ;\n v = * type1 ++ ;\n -- len ;\n switch ( v ) {\n case 0 : if ( is_type2 ) LogError ( _ ( \"%s\\'s dotsection operator is deprecated for Type2\\n\" ) , name ) ;\n sp = 0 ;\n break ;\n case 1 : if ( sp < 6 ) LogError ( _ ( \"Stack underflow on vstem3 in %s\\n\" ) , name ) ;\n if ( is_type2 ) LogError ( _ ( \"%s\\'s vstem3 operator is not supported for Type2\\n\" ) , name ) ;\n sameh = NULL ;\n if ( ! is_type2 ) sameh = SameH ( ret -> vstem , stack [ 0 ] + ret -> lsidebearing , stack [ 1 ] , unblended , 0 ) ;\n hint = HintNew ( stack [ 0 ] + ret -> lsidebearing , stack [ 1 ] ) ;\n hint -> hintnumber = sameh != NULL ? sameh -> hintnumber : hint_cnt ++ ;\n if ( activev == NULL ) activev = hp = hint ;\n else {\n for ( hp = activev ;\n hp -> next != NULL ;\n hp = hp -> next ) ;\n hp -> next = hint ;\n hp = hint ;\n }\n sameh = NULL ;\n if ( ! is_type2 ) sameh = SameH ( ret -> vstem , stack [ 2 ] + ret -> lsidebearing , stack [ 3 ] , unblended , 0 ) ;\n hp -> next = HintNew ( stack [ 2 ] + ret -> lsidebearing , stack [ 3 ] ) ;\n hp -> next -> hintnumber = sameh != NULL ? sameh -> hintnumber : hint_cnt ++ ;\n if ( ! is_type2 ) sameh = SameH ( ret -> vstem , stack [ 4 ] + ret -> lsidebearing , stack [ 5 ] , unblended , 0 ) ;\n hp -> next -> next = HintNew ( stack [ 4 ] + ret -> lsidebearing , stack [ 5 ] ) ;\n hp -> next -> next -> hintnumber = sameh != NULL ? sameh -> hintnumber : hint_cnt ++ ;\n if ( ! is_type2 && hp -> next -> next -> hintnumber < 96 ) {\n if ( pending_hm == NULL ) pending_hm = chunkalloc ( sizeof ( HintMask ) ) ;\n ( * pending_hm ) [ hint -> hintnumber >> 3 ] |= 0x80 >> ( hint -> hintnumber & 0x7 ) ;\n ( * pending_hm ) [ hint -> next -> hintnumber >> 3 ] |= 0x80 >> ( hint -> next -> hintnumber & 0x7 ) ;\n ( * pending_hm ) [ hint -> next -> next -> hintnumber >> 3 ] |= 0x80 >> ( hint -> next -> next -> hintnumber & 0x7 ) ;\n }\n hp = hp -> next -> next ;\n sp = 0 ;\n break ;\n case 2 : if ( sp < 6 ) LogError ( _ ( \"Stack underflow on hstem3 in %s\\n\" ) , name ) ;\n if ( is_type2 ) LogError ( _ ( \"%s\\'s vstem3 operator is not supported for Type2\\n\" ) , name ) ;\n sameh = NULL ;\n if ( ! is_type2 ) sameh = SameH ( ret -> hstem , stack [ 0 ] , stack [ 1 ] , unblended , 0 ) ;\n hint = HintNew ( stack [ 0 ] , stack [ 1 ] ) ;\n hint -> hintnumber = sameh != NULL ? sameh -> hintnumber : hint_cnt ++ ;\n if ( activeh == NULL ) activeh = hp = hint ;\n else {\n for ( hp = activeh ;\n hp -> next != NULL ;\n hp = hp -> next ) ;\n hp -> next = hint ;\n hp = hint ;\n }\n sameh = NULL ;\n if ( ! is_type2 ) sameh = SameH ( ret -> hstem , stack [ 2 ] , stack [ 3 ] , unblended , 0 ) ;\n hp -> next = HintNew ( stack [ 2 ] , stack [ 3 ] ) ;\n hp -> next -> hintnumber = sameh != NULL ? sameh -> hintnumber : hint_cnt ++ ;\n sameh = NULL ;\n if ( ! is_type2 ) sameh = SameH ( ret -> hstem , stack [ 4 ] , stack [ 5 ] , unblended , 0 ) ;\n hp -> next -> next = HintNew ( stack [ 4 ] , stack [ 5 ] ) ;\n hp -> next -> next -> hintnumber = sameh != NULL ? sameh -> hintnumber : hint_cnt ++ ;\n if ( ! is_type2 && hp -> next -> next -> hintnumber < 96 ) {\n if ( pending_hm == NULL ) pending_hm = chunkalloc ( sizeof ( HintMask ) ) ;\n ( * pending_hm ) [ hint -> hintnumber >> 3 ] |= 0x80 >> ( hint -> hintnumber & 0x7 ) ;\n ( * pending_hm ) [ hint -> next -> hintnumber >> 3 ] |= 0x80 >> ( hint -> next -> hintnumber & 0x7 ) ;\n ( * pending_hm ) [ hint -> next -> next -> hintnumber >> 3 ] |= 0x80 >> ( hint -> next -> next -> hintnumber & 0x7 ) ;\n }\n hp = hp -> next -> next ;\n sp = 0 ;\n break ;\n case 6 : seac : if ( sp < 5 ) LogError ( _ ( \"Stack underflow on seac in %s\\n\" ) , name ) ;\n if ( is_type2 ) {\n if ( v == 6 ) LogError ( _ ( \"%s\\'s SEAC operator is invalid for Type2\\n\" ) , name ) ;\n else LogError ( _ ( \"%s\\'s SEAC-like endchar operator is deprecated for Type2\\n\" ) , name ) ;\n }\n r1 = RefCharCreate ( ) ;\n r2 = RefCharCreate ( ) ;\n r2 -> transform [ 0 ] = 1 ;\n r2 -> transform [ 3 ] = 1 ;\n r2 -> transform [ 4 ] = stack [ 1 ] - ( stack [ 0 ] - ret -> lsidebearing ) ;\n r2 -> transform [ 5 ] = stack [ 2 ] ;\n r1 -> transform [ 0 ] = 1 ;\n r1 -> transform [ 3 ] = 1 ;\n r1 -> adobe_enc = stack [ 3 ] ;\n r2 -> adobe_enc = stack [ 4 ] ;\n if ( stack [ 3 ] < 0 || stack [ 3 ] >= 256 || stack [ 4 ] < 0 || stack [ 4 ] >= 256 ) {\n LogError ( _ ( \"Reference encoding out of bounds in %s\\n\" ) , name ) ;\n r1 -> adobe_enc = 0 ;\n r2 -> adobe_enc = 0 ;\n }\n r1 -> next = r2 ;\n if ( rlast != NULL ) rlast -> next = r1 ;\n else ret -> layers [ ly_fore ] . refs = r1 ;\n ret -> changedsincelasthinted = true ;\n rlast = r2 ;\n sp = 0 ;\n break ;\n case 7 : if ( sp < 4 ) LogError ( _ ( \"Stack underflow on sbw in %s\\n\" ) , name ) ;\n if ( is_type2 ) LogError ( _ ( \"%s\\'s sbw operator is not supported for Type2\\n\" ) , name ) ;\n ret -> lsidebearing = stack [ 0 ] ;\n ret -> width = stack [ 2 ] ;\n sp = 0 ;\n break ;\n case 5 : case 9 : case 14 : case 26 : if ( sp < 1 ) LogError ( _ ( \"Stack underflow on unary operator in %s\\n\" ) , name ) ;\n switch ( v ) {\n case 5 : stack [ sp - 1 ] = ( stack [ sp - 1 ] == 0 ) ;\n break ;\n case 9 : if ( stack [ sp - 1 ] < 0 ) stack [ sp - 1 ] = - stack [ sp - 1 ] ;\n break ;\n case 14 : stack [ sp - 1 ] = - stack [ sp - 1 ] ;\n break ;\n case 26 : stack [ sp - 1 ] = sqrt ( stack [ sp - 1 ] ) ;\n break ;\n default : break ;\n }\n break ;\n case 3 : case 4 : case 10 : case 11 : case 12 : case 15 : case 24 : if ( sp < 2 ) LogError ( _ ( \"Stack underflow on binary operator in %s\\n\" ) , name ) ;\n else switch ( v ) {\n case 3 : stack [ sp - 2 ] = ( stack [ sp - 1 ] != 0 && stack [ sp - 2 ] != 0 ) ;\n break ;\n case 4 : stack [ sp - 2 ] = ( stack [ sp - 1 ] != 0 || stack [ sp - 2 ] != 0 ) ;\n break ;\n case 10 : stack [ sp - 2 ] += stack [ sp - 1 ] ;\n break ;\n case 11 : stack [ sp - 2 ] -= stack [ sp - 1 ] ;\n break ;\n case 12 : stack [ sp - 2 ] /= stack [ sp - 1 ] ;\n break ;\n case 24 : stack [ sp - 2 ] *= stack [ sp - 1 ] ;\n break ;\n case 15 : stack [ sp - 2 ] = ( stack [ sp - 1 ] == stack [ sp - 2 ] ) ;\n break ;\n default : break ;\n }\n -- sp ;\n break ;\n case 22 : if ( sp < 4 ) LogError ( _ ( \"Stack underflow on ifelse in %s\\n\" ) , name ) ;\n else {\n if ( stack [ sp - 2 ] > stack [ sp - 1 ] ) stack [ sp - 4 ] = stack [ sp - 3 ] ;\n sp -= 3 ;\n }\n break ;\n case 23 : do {\n stack [ sp ] = ( rand ( ) / ( RAND_MAX - 1 ) ) ;\n }\n while ( stack [ sp ] == 0 || stack [ sp ] > 1 ) ;\n ++ sp ;\n break ;\n case 16 : if ( is_type2 ) LogError ( _ ( \"Type2 fonts do not support the Type1 callothersubrs operator\" ) ) ;\n if ( sp < 2 || sp < 2 + stack [ sp - 2 ] ) {\n LogError ( _ ( \"Stack underflow on callothersubr in %s\\n\" ) , name ) ;\n sp = 0 ;\n }\n else {\n int tot = stack [ sp - 2 ] , i , k , j ;\n popsp = 0 ;\n for ( k = sp - 3 ;\n k >= sp - 2 - tot ;\n -- k ) pops [ popsp ++ ] = stack [ k ] ;\n switch ( ( int ) stack [ sp - 1 ] ) {\n case 3 : {\n ret -> manualhints = false ;\n ret -> hstem = HintsAppend ( ret -> hstem , activeh ) ;\n activeh = NULL ;\n ret -> vstem = HintsAppend ( ret -> vstem , activev ) ;\n activev = NULL ;\n }\n break ;\n case 1 : {\n is_type2 = false ;\n if ( cur != NULL ) {\n oldcur = cur ;\n cur -> next = NULL ;\n }\n else LogError ( _ ( \"Bad flex subroutine in %s\\n\" ) , name ) ;\n }\n break ;\n case 2 : {\n ;\n }\n break ;\n case 0 : if ( oldcur != NULL ) {\n SplinePointList * spl = oldcur -> next ;\n if ( spl != NULL && spl -> next != NULL && spl -> next -> next != NULL && spl -> next -> next -> next != NULL && spl -> next -> next -> next -> next != NULL && spl -> next -> next -> next -> next -> next != NULL && spl -> next -> next -> next -> next -> next -> next != NULL ) {\n BasePoint old_nextcp , mid_prevcp , mid , mid_nextcp , end_prevcp , end ;\n old_nextcp = spl -> next -> first -> me ;\n mid_prevcp = spl -> next -> next -> first -> me ;\n mid = spl -> next -> next -> next -> first -> me ;\n mid_nextcp = spl -> next -> next -> next -> next -> first -> me ;\n end_prevcp = spl -> next -> next -> next -> next -> next -> first -> me ;\n end = spl -> next -> next -> next -> next -> next -> next -> first -> me ;\n cur = oldcur ;\n if ( cur != NULL && cur -> first != NULL && ( cur -> first != cur -> last || cur -> first -> next == NULL ) ) {\n cur -> last -> nextcp = old_nextcp ;\n cur -> last -> nonextcp = false ;\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> hintmask = pending_hm ;\n pending_hm = NULL ;\n pt -> prevcp = mid_prevcp ;\n pt -> me = mid ;\n pt -> nextcp = mid_nextcp ;\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> prevcp = end_prevcp ;\n pt -> me = end ;\n pt -> nonextcp = true ;\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n }\n else LogError ( _ ( \"No previous point on path in curveto from flex 0 in %s\\n\" ) , name ) ;\n }\n else {\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> me . x = pops [ 1 ] ;\n pt -> me . y = pops [ 0 ] ;\n pt -> noprevcp = true ;\n pt -> nonextcp = true ;\n SplinePointListFree ( oldcur -> next ) ;\n oldcur -> next = NULL ;\n spl = NULL ;\n cur = oldcur ;\n if ( cur != NULL && cur -> first != NULL && ( cur -> first != cur -> last || cur -> first -> next == NULL ) ) {\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n }\n else LogError ( _ ( \"No previous point on path in lineto from flex 0 in %s\\n\" ) , name ) ;\n }\n -- popsp ;\n cur -> next = NULL ;\n SplinePointListsFree ( spl ) ;\n oldcur = NULL ;\n }\n else LogError ( _ ( \"Bad flex subroutine in %s\\n\" ) , name ) ;\n is_type2 = context -> is_type2 ;\n break ;\n case 14 : case 15 : case 16 : case 17 : case 18 : {\n int cnt = stack [ sp - 1 ] - 13 ;\n if ( cnt == 5 ) cnt = 6 ;\n if ( context -> instance_count == 0 ) LogError ( _ ( \"Attempt to use a multiple master subroutine in a non-mm font in %s.\\n\" ) , name ) ;\n else if ( tot != cnt * context -> instance_count ) LogError ( _ ( \"Multiple master subroutine called with the wrong number of arguments in %s.\\n\" ) , name ) ;\n else {\n if ( cnt == 1 && ! is_type2 ) {\n if ( sp - 2 - tot >= 1 && ( ! old_last_was_b1 || stack [ 0 ] != Blend ( unblended [ 1 ] , context ) ) ) {\n unblended [ 0 ] [ 0 ] = stack [ 0 ] ;\n for ( i = 1 ;\n i < context -> instance_count ;\n ++ i ) unblended [ 0 ] [ i ] = 0 ;\n }\n else memcpy ( unblended , unblended + 1 , context -> instance_count * sizeof ( real ) ) ;\n for ( j = 0 ;\n j < context -> instance_count ;\n ++ j ) unblended [ 1 ] [ j ] = stack [ sp - 2 - tot + j ] ;\n }\n else if ( cnt == 2 && ! is_type2 ) {\n unblended [ 0 ] [ 0 ] = stack [ sp - 2 - tot ] ;\n unblended [ 1 ] [ 0 ] = stack [ sp - 2 - tot + 1 ] ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) for ( j = 1 ;\n j < context -> instance_count ;\n ++ j ) unblended [ i ] [ j ] = stack [ sp - 2 - tot + 2 + i * ( context -> instance_count - 1 ) + ( j - 1 ) ] ;\n }\n popsp = 0 ;\n for ( i = 0 ;\n i < cnt ;\n ++ i ) {\n double sum = stack [ sp - 2 - tot + i ] ;\n for ( j = 1 ;\n j < context -> instance_count ;\n ++ j ) sum += context -> blend_values [ j ] * stack [ sp - 2 - tot + cnt + i * ( context -> instance_count - 1 ) + j - 1 ] ;\n pops [ cnt - 1 - popsp ++ ] = sum ;\n }\n }\n }\n break ;\n }\n sp = k + 1 ;\n }\n break ;\n case 20 : if ( sp < 2 ) LogError ( _ ( \"Too few items on stack for put in %s\\n\" ) , name ) ;\n else if ( stack [ sp - 1 ] < 0 || stack [ sp - 1 ] >= 32 ) LogError ( _ ( \"Reference to transient memory out of bounds in put in %s\\n\" ) , name ) ;\n else {\n transient [ ( int ) stack [ sp - 1 ] ] = stack [ sp - 2 ] ;\n sp -= 2 ;\n }\n break ;\n case 21 : if ( sp < 1 ) LogError ( _ ( \"Too few items on stack for get in %s\\n\" ) , name ) ;\n else if ( stack [ sp - 1 ] < 0 || stack [ sp - 1 ] >= 32 ) LogError ( _ ( \"Reference to transient memory out of bounds in put in %s\\n\" ) , name ) ;\n else stack [ sp - 1 ] = transient [ ( int ) stack [ sp - 1 ] ] ;\n break ;\n case 17 : if ( popsp <= 0 ) LogError ( _ ( \"Pop stack underflow on pop in %s\\n\" ) , name ) ;\n else stack [ sp ++ ] = pops [ -- popsp ] ;\n break ;\n case 18 : if ( sp > 0 ) -- sp ;\n break ;\n case 27 : if ( sp >= 1 ) {\n stack [ sp ] = stack [ sp - 1 ] ;\n ++ sp ;\n }\n break ;\n case 28 : if ( sp >= 2 ) {\n real temp = stack [ sp - 1 ] ;\n stack [ sp - 1 ] = stack [ sp - 2 ] ;\n stack [ sp - 2 ] = temp ;\n }\n break ;\n case 29 : if ( sp >= 1 ) {\n int index = stack [ -- sp ] ;\n if ( index < 0 || sp < index + 1 ) LogError ( _ ( \"Index out of range in %s\\n\" ) , name ) ;\n else {\n stack [ sp ] = stack [ sp - index - 1 ] ;\n ++ sp ;\n }\n }\n break ;\n case 30 : if ( sp >= 2 ) {\n int j = stack [ sp - 1 ] , N = stack [ sp - 2 ] ;\n if ( N > sp || j >= N || j < 0 || N < 0 ) LogError ( _ ( \"roll out of range in %s\\n\" ) , name ) ;\n else if ( j == 0 || N == 0 ) ;\n else {\n real * temp = malloc ( N * sizeof ( real ) ) ;\n int i ;\n for ( i = 0 ;\n i < N ;\n ++ i ) temp [ i ] = stack [ sp - N + i ] ;\n for ( i = 0 ;\n i < N ;\n ++ i ) stack [ sp - N + i ] = temp [ ( i + j ) % N ] ;\n free ( temp ) ;\n }\n }\n break ;\n case 33 : if ( is_type2 ) LogError ( _ ( \"Type2 fonts do not support the Type1 setcurrentpoint operator\" ) ) ;\n if ( sp < 2 ) LogError ( _ ( \"Stack underflow on setcurrentpoint in %s\\n\" ) , name ) ;\n else {\n current . x = stack [ 0 ] ;\n current . y = stack [ 1 ] ;\n }\n sp = 0 ;\n break ;\n case 34 : case 35 : case 36 : case 37 : dy = dy3 = dy4 = dy5 = dy6 = 0 ;\n dx = stack [ base ++ ] ;\n if ( v != 34 ) dy = stack [ base ++ ] ;\n dx2 = stack [ base ++ ] ;\n dy2 = stack [ base ++ ] ;\n dx3 = stack [ base ++ ] ;\n if ( v != 34 && v != 36 ) dy3 = stack [ base ++ ] ;\n dx4 = stack [ base ++ ] ;\n if ( v != 34 && v != 36 ) dy4 = stack [ base ++ ] ;\n dx5 = stack [ base ++ ] ;\n if ( v == 34 ) dy5 = - dy2 ;\n else dy5 = stack [ base ++ ] ;\n switch ( v ) {\n real xt , yt ;\n case 35 : dx6 = stack [ base ++ ] ;\n dy6 = stack [ base ++ ] ;\n break ;\n case 34 : dx6 = stack [ base ++ ] ;\n break ;\n case 36 : dx6 = stack [ base ++ ] ;\n dy6 = - dy - dy2 - dy5 ;\n break ;\n case 37 : xt = dx + dx2 + dx3 + dx4 + dx5 ;\n yt = dy + dy2 + dy3 + dy4 + dy5 ;\n if ( xt < 0 ) xt = - xt ;\n if ( yt < 0 ) yt = - yt ;\n if ( xt > yt ) {\n dx6 = stack [ base ++ ] ;\n dy6 = - dy - dy2 - dy3 - dy4 - dy5 ;\n }\n else {\n dy6 = stack [ base ++ ] ;\n dx6 = - dx - dx2 - dx3 - dx4 - dx5 ;\n }\n break ;\n }\n if ( cur != NULL && cur -> first != NULL && ( cur -> first != cur -> last || cur -> first -> next == NULL ) ) {\n current . x = rint ( ( current . x + dx ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy ) * 1024 ) / 1024 ;\n cur -> last -> nextcp . x = current . x ;\n cur -> last -> nextcp . y = current . y ;\n cur -> last -> nonextcp = false ;\n current . x = rint ( ( current . x + dx2 ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy2 ) * 1024 ) / 1024 ;\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> hintmask = pending_hm ;\n pending_hm = NULL ;\n pt -> prevcp . x = current . x ;\n pt -> prevcp . y = current . y ;\n current . x = rint ( ( current . x + dx3 ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy3 ) * 1024 ) / 1024 ;\n pt -> me . x = current . x ;\n pt -> me . y = current . y ;\n pt -> nonextcp = true ;\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n current . x = rint ( ( current . x + dx4 ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy4 ) * 1024 ) / 1024 ;\n cur -> last -> nextcp . x = current . x ;\n cur -> last -> nextcp . y = current . y ;\n cur -> last -> nonextcp = false ;\n current . x = rint ( ( current . x + dx5 ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy5 ) * 1024 ) / 1024 ;\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> prevcp . x = current . x ;\n pt -> prevcp . y = current . y ;\n current . x = rint ( ( current . x + dx6 ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy6 ) * 1024 ) / 1024 ;\n pt -> me . x = current . x ;\n pt -> me . y = current . y ;\n pt -> nonextcp = true ;\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n }\n else LogError ( _ ( \"No previous point on path in flex operator in %s\\n\" ) , name ) ;\n sp = 0 ;\n break ;\n default : LogError ( _ ( \"Uninterpreted opcode 12,%d in %s\\n\" ) , v , name ) ;\n break ;\n }\n }\n else {\n last_was_b1 = false ;\n switch ( v ) {\n case 1 : case 18 : base = 0 ;\n if ( ( sp & 1 ) && ret -> width == ( int16 ) 0x8000 ) ret -> width = stack [ 0 ] ;\n if ( sp & 1 ) base = 1 ;\n if ( sp - base < 2 ) LogError ( _ ( \"Stack underflow on hstem in %s\\n\" ) , name ) ;\n coord = 0 ;\n hp = NULL ;\n if ( activeh != NULL ) for ( hp = activeh ;\n hp -> next != NULL ;\n hp = hp -> next ) ;\n while ( sp - base >= 2 ) {\n sameh = NULL ;\n if ( ! is_type2 ) sameh = SameH ( ret -> hstem , stack [ base ] + coord , stack [ base + 1 ] , unblended , context -> instance_count ) ;\n hint = HintNew ( stack [ base ] + coord , stack [ base + 1 ] ) ;\n hint -> hintnumber = sameh != NULL ? sameh -> hintnumber : hint_cnt ++ ;\n if ( ! is_type2 && context -> instance_count != 0 ) {\n hint -> u . unblended = chunkalloc ( sizeof ( real [ 2 ] [ MmMax ] ) ) ;\n memcpy ( hint -> u . unblended , unblended , sizeof ( real [ 2 ] [ MmMax ] ) ) ;\n }\n if ( activeh == NULL ) activeh = hint ;\n else hp -> next = hint ;\n hp = hint ;\n if ( ! is_type2 && hint -> hintnumber < 96 ) {\n if ( pending_hm == NULL ) pending_hm = chunkalloc ( sizeof ( HintMask ) ) ;\n ( * pending_hm ) [ hint -> hintnumber >> 3 ] |= 0x80 >> ( hint -> hintnumber & 0x7 ) ;\n }\n base += 2 ;\n coord = hint -> start + hint -> width ;\n }\n sp = 0 ;\n break ;\n case 19 : case 20 : case 3 : case 23 : base = 0 ;\n if ( cur == NULL || v == 3 || v == 23 ) {\n if ( ( sp & 1 ) && is_type2 && ret -> width == ( int16 ) 0x8000 ) {\n ret -> width = stack [ 0 ] ;\n }\n if ( sp & 1 ) base = 1 ;\n if ( sp - base < 2 && v != 19 && v != 20 ) LogError ( _ ( \"Stack underflow on vstem in %s\\n\" ) , name ) ;\n coord = ret -> lsidebearing ;\n hp = NULL ;\n if ( activev != NULL ) for ( hp = activev ;\n hp -> next != NULL ;\n hp = hp -> next ) ;\n while ( sp - base >= 2 ) {\n sameh = NULL ;\n if ( ! is_type2 ) sameh = SameH ( ret -> vstem , stack [ base ] + coord , stack [ base + 1 ] , unblended , context -> instance_count ) ;\n hint = HintNew ( stack [ base ] + coord , stack [ base + 1 ] ) ;\n hint -> hintnumber = sameh != NULL ? sameh -> hintnumber : hint_cnt ++ ;\n if ( ! is_type2 && context -> instance_count != 0 ) {\n hint -> u . unblended = chunkalloc ( sizeof ( real [ 2 ] [ MmMax ] ) ) ;\n memcpy ( hint -> u . unblended , unblended , sizeof ( real [ 2 ] [ MmMax ] ) ) ;\n }\n if ( ! is_type2 && hint -> hintnumber < 96 ) {\n if ( pending_hm == NULL ) pending_hm = chunkalloc ( sizeof ( HintMask ) ) ;\n ( * pending_hm ) [ hint -> hintnumber >> 3 ] |= 0x80 >> ( hint -> hintnumber & 0x7 ) ;\n }\n if ( activev == NULL ) activev = hint ;\n else hp -> next = hint ;\n hp = hint ;\n base += 2 ;\n coord = hint -> start + hint -> width ;\n }\n sp = 0 ;\n }\n if ( v == 19 || v == 20 ) {\n int bytes = ( hint_cnt + 7 ) / 8 ;\n if ( bytes > sizeof ( HintMask ) ) bytes = sizeof ( HintMask ) ;\n if ( v == 19 ) {\n ret -> hstem = HintsAppend ( ret -> hstem , activeh ) ;\n activeh = NULL ;\n ret -> vstem = HintsAppend ( ret -> vstem , activev ) ;\n activev = NULL ;\n if ( pending_hm == NULL ) pending_hm = chunkalloc ( sizeof ( HintMask ) ) ;\n memcpy ( pending_hm , type1 , bytes ) ;\n }\n else if ( cp < sizeof ( counters ) / sizeof ( counters [ 0 ] ) ) {\n counters [ cp ] = chunkalloc ( sizeof ( HintMask ) ) ;\n memcpy ( counters [ cp ] , type1 , bytes ) ;\n ++ cp ;\n }\n if ( bytes != hint_cnt / 8 ) {\n int mask = 0xff >> ( hint_cnt & 7 ) ;\n if ( type1 [ bytes - 1 ] & mask ) LogError ( _ ( \"Hint mask (or counter mask) with too many hints in %s\\n\" ) , name ) ;\n }\n type1 += bytes ;\n len -= bytes ;\n }\n break ;\n case 14 : if ( ( sp & 1 ) && is_type2 && ret -> width == ( int16 ) 0x8000 ) ret -> width = stack [ 0 ] ;\n if ( context -> painttype != 2 ) closepath ( cur , is_type2 ) ;\n pcsp = 0 ;\n if ( sp == 4 ) {\n stack [ 4 ] = stack [ 3 ] ;\n stack [ 3 ] = stack [ 2 ] ;\n stack [ 2 ] = stack [ 1 ] ;\n stack [ 1 ] = stack [ 0 ] ;\n stack [ 0 ] = 0 ;\n sp = 5 ;\n goto seac ;\n }\n else if ( sp == 5 ) {\n stack [ 0 ] = 0 ;\n goto seac ;\n }\n goto done ;\n break ;\n case 13 : if ( sp < 2 ) LogError ( _ ( \"Stack underflow on hsbw in %s\\n\" ) , name ) ;\n ret -> lsidebearing = stack [ 0 ] ;\n current . x = stack [ 0 ] ;\n ret -> width = stack [ 1 ] ;\n sp = 0 ;\n break ;\n case 9 : sp = 0 ;\n closepath ( cur , is_type2 ) ;\n break ;\n case 21 : case 22 : case 4 : if ( is_type2 ) {\n if ( ( ( v == 21 && sp == 3 ) || ( v != 21 && sp == 2 ) ) && ret -> width == ( int16 ) 0x8000 ) ret -> width = stack [ 0 ] ;\n if ( v == 21 && sp > 2 ) {\n stack [ 0 ] = stack [ sp - 2 ] ;\n stack [ 1 ] = stack [ sp - 1 ] ;\n sp = 2 ;\n }\n else if ( v != 21 && sp > 1 ) {\n stack [ 0 ] = stack [ sp - 1 ] ;\n sp = 1 ;\n }\n if ( context -> painttype != 2 ) closepath ( cur , true ) ;\n }\n case 5 : case 6 : case 7 : polarity = 0 ;\n base = 0 ;\n while ( base < sp ) {\n dx = dy = 0 ;\n if ( v == 5 || v == 21 ) {\n if ( sp < base + 2 ) {\n LogError ( _ ( \"Stack underflow on rlineto/rmoveto in %s\\n\" ) , name ) ;\n break ;\n }\n dx = stack [ base ++ ] ;\n dy = stack [ base ++ ] ;\n }\n else if ( ( v == 6 && ! ( polarity & 1 ) ) || ( v == 7 && ( polarity & 1 ) ) || v == 22 ) {\n if ( sp <= base ) {\n LogError ( _ ( \"Stack underflow on hlineto/hmoveto in %s\\n\" ) , name ) ;\n break ;\n }\n dx = stack [ base ++ ] ;\n }\n else {\n if ( sp <= base ) {\n LogError ( _ ( \"Stack underflow on vlineto/vmoveto in %s\\n\" ) , name ) ;\n break ;\n }\n dy = stack [ base ++ ] ;\n }\n ++ polarity ;\n current . x = rint ( ( current . x + dx ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy ) * 1024 ) / 1024 ;\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> hintmask = pending_hm ;\n pending_hm = NULL ;\n pt -> me . x = current . x ;\n pt -> me . y = current . y ;\n pt -> noprevcp = true ;\n pt -> nonextcp = true ;\n if ( v == 4 || v == 21 || v == 22 ) {\n if ( cur != NULL && cur -> first == cur -> last && cur -> first -> prev == NULL && is_type2 ) {\n cur -> first -> me . x = current . x ;\n cur -> first -> me . y = current . y ;\n SplinePointFree ( pt ) ;\n }\n else {\n SplinePointList * spl = chunkalloc ( sizeof ( SplinePointList ) ) ;\n spl -> first = spl -> last = pt ;\n if ( cur != NULL ) cur -> next = spl ;\n else ret -> layers [ ly_fore ] . splines = spl ;\n cur = spl ;\n }\n break ;\n }\n else {\n if ( cur != NULL && cur -> first != NULL && ( cur -> first != cur -> last || cur -> first -> next == NULL ) ) {\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n }\n else LogError ( _ ( \"No previous point on path in lineto in %s\\n\" ) , name ) ;\n if ( ! is_type2 ) break ;\n }\n }\n sp = 0 ;\n break ;\n case 25 : base = 0 ;\n while ( sp > base + 6 ) {\n current . x = rint ( ( current . x + stack [ base ++ ] ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + stack [ base ++ ] ) * 1024 ) / 1024 ;\n if ( cur != NULL ) {\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> hintmask = pending_hm ;\n pending_hm = NULL ;\n pt -> me . x = current . x ;\n pt -> me . y = current . y ;\n pt -> noprevcp = true ;\n pt -> nonextcp = true ;\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n }\n }\n case 24 : case 8 : case 31 : case 30 : case 27 : case 26 : polarity = 0 ;\n while ( sp > base + 2 ) {\n dx = dy = dx2 = dy2 = dx3 = dy3 = 0 ;\n if ( v == 8 || v == 25 || v == 24 ) {\n if ( sp < 6 + base ) {\n LogError ( _ ( \"Stack underflow on rrcurveto in %s\\n\" ) , name ) ;\n base = sp ;\n }\n else {\n dx = stack [ base ++ ] ;\n dy = stack [ base ++ ] ;\n dx2 = stack [ base ++ ] ;\n dy2 = stack [ base ++ ] ;\n dx3 = stack [ base ++ ] ;\n dy3 = stack [ base ++ ] ;\n }\n }\n else if ( v == 27 ) {\n if ( sp < 4 + base ) {\n LogError ( _ ( \"Stack underflow on hhcurveto in %s\\n\" ) , name ) ;\n base = sp ;\n }\n else {\n if ( ( sp - base ) & 1 ) dy = stack [ base ++ ] ;\n dx = stack [ base ++ ] ;\n dx2 = stack [ base ++ ] ;\n dy2 = stack [ base ++ ] ;\n dx3 = stack [ base ++ ] ;\n }\n }\n else if ( v == 26 ) {\n if ( sp < 4 + base ) {\n LogError ( _ ( \"Stack underflow on hhcurveto in %s\\n\" ) , name ) ;\n base = sp ;\n }\n else {\n if ( ( sp - base ) & 1 ) dx = stack [ base ++ ] ;\n dy = stack [ base ++ ] ;\n dx2 = stack [ base ++ ] ;\n dy2 = stack [ base ++ ] ;\n dy3 = stack [ base ++ ] ;\n }\n }\n else if ( ( v == 31 && ! ( polarity & 1 ) ) || ( v == 30 && ( polarity & 1 ) ) ) {\n if ( sp < 4 + base ) {\n LogError ( _ ( \"Stack underflow on hvcurveto in %s\\n\" ) , name ) ;\n base = sp ;\n }\n else {\n dx = stack [ base ++ ] ;\n dx2 = stack [ base ++ ] ;\n dy2 = stack [ base ++ ] ;\n dy3 = stack [ base ++ ] ;\n if ( sp == base + 1 ) dx3 = stack [ base ++ ] ;\n }\n }\n else {\n if ( sp < 4 + base ) {\n LogError ( _ ( \"Stack underflow on vhcurveto in %s\\n\" ) , name ) ;\n base = sp ;\n }\n else {\n dy = stack [ base ++ ] ;\n dx2 = stack [ base ++ ] ;\n dy2 = stack [ base ++ ] ;\n dx3 = stack [ base ++ ] ;\n if ( sp == base + 1 ) dy3 = stack [ base ++ ] ;\n }\n }\n ++ polarity ;\n if ( cur != NULL && cur -> first != NULL && ( cur -> first != cur -> last || cur -> first -> next == NULL ) ) {\n current . x = rint ( ( current . x + dx ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy ) * 1024 ) / 1024 ;\n cur -> last -> nextcp . x = current . x ;\n cur -> last -> nextcp . y = current . y ;\n cur -> last -> nonextcp = false ;\n current . x = rint ( ( current . x + dx2 ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy2 ) * 1024 ) / 1024 ;\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> hintmask = pending_hm ;\n pending_hm = NULL ;\n pt -> prevcp . x = current . x ;\n pt -> prevcp . y = current . y ;\n current . x = rint ( ( current . x + dx3 ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + dy3 ) * 1024 ) / 1024 ;\n pt -> me . x = current . x ;\n pt -> me . y = current . y ;\n pt -> nonextcp = true ;\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n }\n else LogError ( _ ( \"No previous point on path in curveto in %s\\n\" ) , name ) ;\n }\n if ( v == 24 ) {\n current . x = rint ( ( current . x + stack [ base ++ ] ) * 1024 ) / 1024 ;\n current . y = rint ( ( current . y + stack [ base ++ ] ) * 1024 ) / 1024 ;\n if ( cur != NULL ) {\n pt = chunkalloc ( sizeof ( SplinePoint ) ) ;\n pt -> hintmask = pending_hm ;\n pending_hm = NULL ;\n pt -> me . x = current . x ;\n pt -> me . y = current . y ;\n pt -> noprevcp = true ;\n pt -> nonextcp = true ;\n CheckMake ( cur -> last , pt ) ;\n SplineMake3 ( cur -> last , pt ) ;\n cur -> last = pt ;\n }\n }\n sp = 0 ;\n break ;\n case 29 : case 10 : if ( sp < 1 ) {\n LogError ( _ ( \"Stack underflow on callsubr in %s\\n\" ) , name ) ;\n break ;\n }\n else if ( pcsp > 10 ) {\n LogError ( _ ( \"Too many subroutine calls in %s\\n\" ) , name ) ;\n break ;\n }\n s = subrs ;\n if ( v == 29 ) s = gsubrs ;\n if ( s != NULL ) stack [ sp - 1 ] += s -> bias ;\n if ( s == NULL || stack [ sp - 1 ] >= s -> cnt || stack [ sp - 1 ] < 0 || s -> values [ ( int ) stack [ sp - 1 ] ] == NULL ) LogError ( _ ( \"Subroutine number out of bounds in %s\\n\" ) , name ) ;\n else {\n pcstack [ pcsp ] . type1 = type1 ;\n pcstack [ pcsp ] . len = len ;\n pcstack [ pcsp ] . subnum = stack [ sp - 1 ] ;\n ++ pcsp ;\n type1 = s -> values [ ( int ) stack [ sp - 1 ] ] ;\n len = s -> lens [ ( int ) stack [ sp - 1 ] ] ;\n }\n if ( -- sp < 0 ) sp = 0 ;\n break ;\n case 11 : if ( pcsp < 1 ) LogError ( _ ( \"return when not in subroutine in %s\\n\" ) , name ) ;\n else {\n -- pcsp ;\n type1 = pcstack [ pcsp ] . type1 ;\n len = pcstack [ pcsp ] . len ;\n }\n break ;\n case 16 : {\n int cnt , i , j ;\n if ( context -> instance_count == 0 ) LogError ( _ ( \"Attempt to use a multiple master subroutine in a non-mm font.\\n\" ) ) ;\n else if ( sp < 1 || sp < context -> instance_count * stack [ sp - 1 ] + 1 ) LogError ( _ ( \"Too few items on stack for blend in %s\\n\" ) , name ) ;\n else {\n if ( ! context -> blend_warn ) {\n LogError ( _ ( \"Use of obsolete blend operator.\\n\" ) ) ;\n context -> blend_warn = true ;\n }\n cnt = stack [ sp - 1 ] ;\n sp -= context -> instance_count * stack [ sp - 1 ] + 1 ;\n for ( i = 0 ;\n i < cnt ;\n ++ i ) {\n for ( j = 1 ;\n j < context -> instance_count ;\n ++ j ) stack [ sp + i ] += context -> blend_values [ j ] * stack [ sp + cnt + i * ( context -> instance_count - 1 ) + j - 1 ] ;\n }\n sp += cnt ;\n }\n }\n break ;\n default : LogError ( _ ( \"Uninterpreted opcode %d in %s\\n\" ) , v , name ) ;\n break ;\n }\n }\n }\n done : if ( pcsp != 0 ) LogError ( _ ( \"end of subroutine reached with no return in %s\\n\" ) , name ) ;\n SCCategorizePoints ( ret ) ;\n ret -> hstem = HintsAppend ( ret -> hstem , activeh ) ;\n activeh = NULL ;\n ret -> vstem = HintsAppend ( ret -> vstem , activev ) ;\n activev = NULL ;\n if ( cp != 0 ) {\n int i ;\n ret -> countermasks = malloc ( cp * sizeof ( HintMask ) ) ;\n ret -> countermask_cnt = cp ;\n for ( i = 0 ;\n i < cp ;\n ++ i ) {\n memcpy ( & ret -> countermasks [ i ] , counters [ i ] , sizeof ( HintMask ) ) ;\n chunkfree ( counters [ i ] , sizeof ( HintMask ) ) ;\n }\n }\n if ( ! is_type2 && ! context -> painttype ) for ( cur = ret -> layers [ ly_fore ] . splines ;\n cur != NULL ;\n cur = cur -> next ) if ( cur -> first -> prev == NULL ) {\n CheckMake ( cur -> last , cur -> first ) ;\n SplineMake3 ( cur -> last , cur -> first ) ;\n cur -> last = cur -> first ;\n }\n for ( cur = ret -> layers [ ly_fore ] . splines ;\n cur != NULL ;\n cur = cur -> next ) SplineSetReverse ( cur ) ;\n if ( ret -> hstem == NULL && ret -> vstem == NULL ) ret -> manualhints = false ;\n if ( ! is_type2 && context -> instance_count != 0 ) {\n UnblendFree ( ret -> hstem ) ;\n UnblendFree ( ret -> vstem ) ;\n }\n ret -> hstem = HintCleanup ( ret -> hstem , true , context -> instance_count ) ;\n ret -> vstem = HintCleanup ( ret -> vstem , true , context -> instance_count ) ;\n SCGuessHHintInstancesList ( ret , ly_fore ) ;\n SCGuessVHintInstancesList ( ret , ly_fore ) ;\n ret -> hconflicts = StemListAnyConflicts ( ret -> hstem ) ;\n ret -> vconflicts = StemListAnyConflicts ( ret -> vstem ) ;\n if ( context -> instance_count == 1 && ! ret -> hconflicts && ! ret -> vconflicts ) SCClearHintMasks ( ret , ly_fore , false ) ;\n HintsRenumber ( ret ) ;\n if ( name != NULL && strcmp ( name , \".notdef\" ) != 0 ) ret -> widthset = true ;\n return ( ret ) ;\n }",
        "hash": 8947170728280515149,
        "project": "debian",
        "size": 922,
        "slice": {
            "memcpy": [
                [
                    1,
                    "SplineChar * PSCharStringToSplines ( uint8 * type1 , int len , struct pscontext * context , struct pschars * subrs , struct pschars * gsubrs , const char * name ) {\n"
                ],
                [
                    28,
                    " HintMask * counters [ 96 ] ;\n"
                ],
                [
                    888,
                    " ret -> countermasks = malloc ( cp * sizeof ( HintMask ) ) ;\n"
                ],
                [
                    891,
                    " i < cp ;\n"
                ],
                [
                    893,
                    " memcpy ( & ret -> countermasks [ i ] , counters [ i ] , sizeof ( HintMask ) ) ;\n"
                ],
                [
                    894,
                    " chunkfree ( counters [ i ] , sizeof ( HintMask ) ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "SplineChar * PSCharStringToSplines ( uint8 * type1 , int len , struct pscontext * context , struct pschars * subrs , struct pschars * gsubrs , const char * name ) {\n"
                ],
                [
                    32,
                    " if ( ! is_type2 && context -> instance_count > 1 ) memset ( unblended , 0 , sizeof ( unblended ) ) ;\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "SplineChar * PSCharStringToSplines ( uint8 * type1 , int len , struct pscontext * context , struct pschars * subrs , struct pschars * gsubrs , const char * name ) {\n"
                ],
                [
                    39,
                    " while ( len > 0 ) {\n"
                ],
                [
                    920,
                    " if ( name != NULL && strcmp ( name , \".notdef\" ) != 0 ) ret -> widthset = true ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "SplineChar * PSCharStringToSplines ( uint8 * type1 , int len , struct pscontext * context , struct pschars * subrs , struct pschars * gsubrs , const char * name ) {\n"
                ],
                [
                    886,
                    " if ( cp != 0 ) {\n"
                ],
                [
                    888,
                    " ret -> countermasks = malloc ( cp * sizeof ( HintMask ) ) ;\n"
                ],
                [
                    893,
                    " memcpy ( & ret -> countermasks [ i ] , counters [ i ] , sizeof ( HintMask ) ) ;\n"
                ],
                [
                    914,
                    " SCGuessHHintInstancesList ( ret , ly_fore ) ;\n"
                ],
                [
                    915,
                    " SCGuessVHintInstancesList ( ret , ly_fore ) ;\n"
                ],
                [
                    918,
                    " if ( context -> instance_count == 1 && ! ret -> hconflicts && ! ret -> vconflicts ) SCClearHintMasks ( ret , ly_fore , false ) ;\n"
                ],
                [
                    919,
                    " HintsRenumber ( ret ) ;\n"
                ],
                [
                    921,
                    " return ( ret ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "SplineChar * PSCharStringToSplines ( uint8 * type1 , int len , struct pscontext * context , struct pschars * subrs , struct pschars * gsubrs , const char * name ) {\n"
                ],
                [
                    28,
                    " HintMask * counters [ 96 ] ;\n"
                ],
                [
                    32,
                    " if ( ! is_type2 && context -> instance_count > 1 ) memset ( unblended , 0 , sizeof ( unblended ) ) ;\n"
                ],
                [
                    39,
                    " while ( len > 0 ) {\n"
                ],
                [
                    886,
                    " if ( cp != 0 ) {\n"
                ],
                [
                    888,
                    " ret -> countermasks = malloc ( cp * sizeof ( HintMask ) ) ;\n"
                ],
                [
                    891,
                    " i < cp ;\n"
                ],
                [
                    893,
                    " memcpy ( & ret -> countermasks [ i ] , counters [ i ] , sizeof ( HintMask ) ) ;\n"
                ],
                [
                    894,
                    " chunkfree ( counters [ i ] , sizeof ( HintMask ) ) ;\n"
                ],
                [
                    914,
                    " SCGuessHHintInstancesList ( ret , ly_fore ) ;\n"
                ],
                [
                    915,
                    " SCGuessVHintInstancesList ( ret , ly_fore ) ;\n"
                ],
                [
                    918,
                    " if ( context -> instance_count == 1 && ! ret -> hconflicts && ! ret -> vconflicts ) SCClearHintMasks ( ret , ly_fore , false ) ;\n"
                ],
                [
                    919,
                    " HintsRenumber ( ret ) ;\n"
                ],
                [
                    920,
                    " if ( name != NULL && strcmp ( name , \".notdef\" ) != 0 ) ret -> widthset = true ;\n"
                ],
                [
                    921,
                    " return ( ret ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n char geometry [ MaxTextExtent ] , * property ;\n const char * label ;\n DrawInfo * draw_info ;\n Image * image ;\n MagickBooleanType status ;\n TypeMetric metrics ;\n size_t height , width ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n ( void ) ResetImagePage ( image , \"0x0+0+0\" ) ;\n property = InterpretImageProperties ( image_info , image , image_info -> filename ) ;\n ( void ) SetImageProperty ( image , \"label\" , property ) ;\n property = DestroyString ( property ) ;\n label = GetImageProperty ( image , \"label\" ) ;\n draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ;\n draw_info -> text = ConstantString ( label ) ;\n metrics . width = 0 ;\n metrics . ascent = 0.0 ;\n status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {\n image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;\n }\n else if ( ( strlen ( label ) > 0 ) && ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) ) {\n double high , low ;\n for ( ;\n ;\n draw_info -> pointsize *= 2.0 ) {\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;\n if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) {\n if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ;\n }\n else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ;\n }\n high = draw_info -> pointsize ;\n for ( low = 1.0 ;\n ( high - low ) > 0.5 ;\n ) {\n draw_info -> pointsize = ( low + high ) / 2.0 ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;\n if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) {\n if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ;\n else high = draw_info -> pointsize - 0.5 ;\n }\n else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ;\n else high = draw_info -> pointsize - 0.5 ;\n }\n draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ;\n }\n status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n if ( status == MagickFalse ) {\n draw_info = DestroyDrawInfo ( draw_info ) ;\n InheritException ( exception , & image -> exception ) ;\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n if ( image -> columns == 0 ) image -> columns = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n if ( image -> columns == 0 ) image -> columns = ( size_t ) floor ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;\n if ( image -> rows == 0 ) image -> rows = ( size_t ) floor ( metrics . ascent - metrics . descent + draw_info -> stroke_width + 0.5 ) ;\n if ( image -> rows == 0 ) image -> rows = ( size_t ) floor ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ;\n status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n draw_info = DestroyDrawInfo ( draw_info ) ;\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n if ( SetImageBackgroundColor ( image ) == MagickFalse ) {\n draw_info = DestroyDrawInfo ( draw_info ) ;\n InheritException ( exception , & image -> exception ) ;\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ;\n draw_info -> geometry = AcquireString ( geometry ) ;\n status = AnnotateImage ( image , draw_info ) ;\n if ( image_info -> pointsize == 0.0 ) {\n char pointsize [ MaxTextExtent ] ;\n ( void ) FormatLocaleString ( pointsize , MaxTextExtent , \"%.20g\" , draw_info -> pointsize ) ;\n ( void ) SetImageProperty ( image , \"label:pointsize\" , pointsize ) ;\n }\n draw_info = DestroyDrawInfo ( draw_info ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n return ( GetFirstImageInList ( image ) ) ;\n }",
        "hash": 7839247307514698030,
        "project": "debian",
        "size": 100,
        "slice": {
            "strlen": [
                [
                    1,
                    "static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n"
                ],
                [
                    21,
                    " draw_info -> text = ConstantString ( label ) ;\n"
                ],
                [
                    25,
                    " if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {\n"
                ],
                [
                    29,
                    " else if ( ( strlen ( label ) > 0 ) && ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) ) {\n"
                ],
                [
                    33,
                    " draw_info -> pointsize *= 2.0 ) {\n"
                ],
                [
                    44,
                    " high = draw_info -> pointsize ;\n"
                ],
                [
                    45,
                    " for ( low = 1.0 ;\n"
                ],
                [
                    46,
                    " ( high - low ) > 0.5 ;\n"
                ],
                [
                    61,
                    " draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n"
                ],
                [
                    21,
                    " draw_info -> text = ConstantString ( label ) ;\n"
                ],
                [
                    25,
                    " if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {\n"
                ],
                [
                    29,
                    " else if ( ( strlen ( label ) > 0 ) && ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) ) {\n"
                ],
                [
                    33,
                    " draw_info -> pointsize *= 2.0 ) {\n"
                ],
                [
                    44,
                    " high = draw_info -> pointsize ;\n"
                ],
                [
                    45,
                    " for ( low = 1.0 ;\n"
                ],
                [
                    46,
                    " ( high - low ) > 0.5 ;\n"
                ],
                [
                    61,
                    " draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n char * caption , geometry [ MaxTextExtent ] , * property , * text ;\n const char * gravity , * option ;\n DrawInfo * draw_info ;\n Image * image ;\n MagickBooleanType split , status ;\n register ssize_t i ;\n size_t height , width ;\n TypeMetric metrics ;\n assert ( image_info != ( const ImageInfo * ) NULL ) ;\n assert ( image_info -> signature == MagickSignature ) ;\n if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , \"%s\" , image_info -> filename ) ;\n assert ( exception != ( ExceptionInfo * ) NULL ) ;\n assert ( exception -> signature == MagickSignature ) ;\n image = AcquireImage ( image_info ) ;\n ( void ) ResetImagePage ( image , \"0x0+0+0\" ) ;\n option = GetImageOption ( image_info , \"filename\" ) ;\n if ( option == ( const char * ) NULL ) property = InterpretImageProperties ( image_info , image , image_info -> filename ) ;\n else if ( LocaleNCompare ( option , \"caption:\" , 8 ) == 0 ) property = InterpretImageProperties ( image_info , image , option + 8 ) ;\n else property = InterpretImageProperties ( image_info , image , option ) ;\n ( void ) SetImageProperty ( image , \"caption\" , property ) ;\n property = DestroyString ( property ) ;\n caption = ConstantString ( GetImageProperty ( image , \"caption\" ) ) ;\n draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ;\n ( void ) CloneString ( & draw_info -> text , caption ) ;\n gravity = GetImageOption ( image_info , \"gravity\" ) ;\n if ( gravity != ( char * ) NULL ) draw_info -> gravity = ( GravityType ) ParseCommandOption ( MagickGravityOptions , MagickFalse , gravity ) ;\n split = MagickFalse ;\n status = MagickTrue ;\n if ( image -> columns == 0 ) {\n text = AcquireString ( caption ) ;\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ;\n ( void ) CloneString ( & draw_info -> text , text ) ;\n text = DestroyString ( text ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n image -> columns = width ;\n }\n if ( image -> rows == 0 ) {\n split = MagickTrue ;\n text = AcquireString ( caption ) ;\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ;\n ( void ) CloneString ( & draw_info -> text , text ) ;\n text = DestroyString ( text ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n image -> rows = ( size_t ) ( ( i + 1 ) * ( metrics . ascent - metrics . descent + draw_info -> interline_spacing + draw_info -> stroke_width ) + 0.5 ) ;\n }\n if ( status != MagickFalse ) status = SetImageExtent ( image , image -> columns , image -> rows ) ;\n if ( status == MagickFalse ) {\n draw_info = DestroyDrawInfo ( draw_info ) ;\n InheritException ( exception , & image -> exception ) ;\n return ( DestroyImageList ( image ) ) ;\n }\n if ( SetImageBackgroundColor ( image ) == MagickFalse ) {\n draw_info = DestroyDrawInfo ( draw_info ) ;\n InheritException ( exception , & image -> exception ) ;\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) {\n double high , low ;\n for ( ;\n ;\n draw_info -> pointsize *= 2.0 ) {\n text = AcquireString ( caption ) ;\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ;\n ( void ) CloneString ( & draw_info -> text , text ) ;\n text = DestroyString ( text ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n ( void ) status ;\n width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;\n if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) {\n if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ;\n }\n else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ;\n }\n high = draw_info -> pointsize ;\n for ( low = 1.0 ;\n ( high - low ) > 0.5 ;\n ) {\n draw_info -> pointsize = ( low + high ) / 2.0 ;\n text = AcquireString ( caption ) ;\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ;\n ( void ) CloneString ( & draw_info -> text , text ) ;\n text = DestroyString ( text ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , - metrics . bounds . x1 , metrics . ascent ) ;\n if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ;\n ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ;\n width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ;\n height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ;\n if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) {\n if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ;\n else high = draw_info -> pointsize - 0.5 ;\n }\n else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ;\n else high = draw_info -> pointsize - 0.5 ;\n }\n draw_info -> pointsize = floor ( ( low + high ) / 2.0 - 0.5 ) ;\n }\n i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ;\n ( void ) CloneString ( & draw_info -> text , caption ) ;\n ( void ) FormatLocaleString ( geometry , MaxTextExtent , \"%+g%+g\" , MagickMax ( draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : - metrics . bounds . x1 , 0.0 ) , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ;\n draw_info -> geometry = AcquireString ( geometry ) ;\n status = AnnotateImage ( image , draw_info ) ;\n if ( image_info -> pointsize == 0.0 ) {\n char pointsize [ MaxTextExtent ] ;\n ( void ) FormatLocaleString ( pointsize , MaxTextExtent , \"%.20g\" , draw_info -> pointsize ) ;\n ( void ) SetImageProperty ( image , \"caption:pointsize\" , pointsize ) ;\n }\n draw_info = DestroyDrawInfo ( draw_info ) ;\n caption = DestroyString ( caption ) ;\n if ( status == MagickFalse ) {\n image = DestroyImageList ( image ) ;\n return ( ( Image * ) NULL ) ;\n }\n return ( GetFirstImageInList ( image ) ) ;\n }",
        "hash": -735007692503855355,
        "project": "debian",
        "size": 124,
        "slice": {
            "strlen": [
                [
                    1,
                    "static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n"
                ],
                [
                    25,
                    " ( void ) CloneString ( & draw_info -> text , caption ) ;\n"
                ],
                [
                    31,
                    " text = AcquireString ( caption ) ;\n"
                ],
                [
                    43,
                    " text = AcquireString ( caption ) ;\n"
                ],
                [
                    64,
                    " if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) {\n"
                ],
                [
                    69,
                    " text = AcquireString ( caption ) ;\n"
                ],
                [
                    89,
                    " text = AcquireString ( caption ) ;\n"
                ],
                [
                    107,
                    " i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ;\n"
                ],
                [
                    108,
                    " ( void ) CloneString ( & draw_info -> text , caption ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n"
                ],
                [
                    25,
                    " ( void ) CloneString ( & draw_info -> text , caption ) ;\n"
                ],
                [
                    31,
                    " text = AcquireString ( caption ) ;\n"
                ],
                [
                    43,
                    " text = AcquireString ( caption ) ;\n"
                ],
                [
                    64,
                    " if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) {\n"
                ],
                [
                    69,
                    " text = AcquireString ( caption ) ;\n"
                ],
                [
                    89,
                    " text = AcquireString ( caption ) ;\n"
                ],
                [
                    107,
                    " i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ;\n"
                ],
                [
                    108,
                    " ( void ) CloneString ( & draw_info -> text , caption ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void build_config ( char * prefix , struct server * server ) {\n char * path = NULL ;\n int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;\n path = ss_malloc ( path_size ) ;\n snprintf ( path , path_size , \"%s/.shadowsocks_%s.conf\" , prefix , server -> port ) ;\n FILE * f = fopen ( path , \"w+\" ) ;\n if ( f == NULL ) {\n if ( verbose ) {\n LOGE ( \"unable to open config file\" ) ;\n }\n ss_free ( path ) ;\n return ;\n }\n fprintf ( f , \"{\n\\n\" ) ;\n fprintf ( f , \"\\\"server_port\\\":%d,\\n\" , atoi ( server -> port ) ) ;\n fprintf ( f , \"\\\"password\\\":\\\"%s\\\"\" , server -> password ) ;\n if ( server -> fast_open [ 0 ] ) fprintf ( f , \",\\n\\\"fast_open\\\": %s\" , server -> fast_open ) ;\n if ( server -> mode ) fprintf ( f , \",\\n\\\"mode\\\":\\\"%s\\\"\" , server -> mode ) ;\n if ( server -> method ) fprintf ( f , \",\\n\\\"method\\\":\\\"%s\\\"\" , server -> method ) ;\n if ( server -> plugin ) fprintf ( f , \",\\n\\\"plugin\\\":\\\"%s\\\"\" , server -> plugin ) ;\n if ( server -> plugin_opts ) fprintf ( f , \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\" , server -> plugin_opts ) ;\n fprintf ( f , \"\\n}\n\\n\" ) ;\n fclose ( f ) ;\n ss_free ( path ) ;\n }",
        "hash": -7248963932691286231,
        "project": "debian",
        "size": 27,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void build_config ( char * prefix , struct server * server ) {\n"
                ],
                [
                    3,
                    " int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;\n"
                ],
                [
                    4,
                    " path = ss_malloc ( path_size ) ;\n"
                ],
                [
                    5,
                    " snprintf ( path , path_size , \"%s/.shadowsocks_%s.conf\" , prefix , server -> port ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void build_config ( char * prefix , struct server * server ) {\n"
                ],
                [
                    7,
                    " if ( f == NULL ) {\n"
                ],
                [
                    17,
                    " fprintf ( f , \"\\\"password\\\":\\\"%s\\\"\" , server -> password ) ;\n"
                ],
                [
                    18,
                    " if ( server -> fast_open [ 0 ] ) fprintf ( f , \",\\n\\\"fast_open\\\": %s\" , server -> fast_open ) ;\n"
                ],
                [
                    19,
                    " if ( server -> mode ) fprintf ( f , \",\\n\\\"mode\\\":\\\"%s\\\"\" , server -> mode ) ;\n"
                ],
                [
                    20,
                    " if ( server -> method ) fprintf ( f , \",\\n\\\"method\\\":\\\"%s\\\"\" , server -> method ) ;\n"
                ],
                [
                    21,
                    " if ( server -> plugin ) fprintf ( f , \",\\n\\\"plugin\\\":\\\"%s\\\"\" , server -> plugin ) ;\n"
                ],
                [
                    22,
                    " if ( server -> plugin_opts ) fprintf ( f , \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\" , server -> plugin_opts ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void build_config ( char * prefix , struct server * server ) {\n"
                ],
                [
                    3,
                    " int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;\n"
                ],
                [
                    4,
                    " path = ss_malloc ( path_size ) ;\n"
                ],
                [
                    5,
                    " snprintf ( path , path_size , \"%s/.shadowsocks_%s.conf\" , prefix , server -> port ) ;\n"
                ],
                [
                    7,
                    " if ( f == NULL ) {\n"
                ],
                [
                    17,
                    " fprintf ( f , \"\\\"password\\\":\\\"%s\\\"\" , server -> password ) ;\n"
                ],
                [
                    18,
                    " if ( server -> fast_open [ 0 ] ) fprintf ( f , \",\\n\\\"fast_open\\\": %s\" , server -> fast_open ) ;\n"
                ],
                [
                    19,
                    " if ( server -> mode ) fprintf ( f , \",\\n\\\"mode\\\":\\\"%s\\\"\" , server -> mode ) ;\n"
                ],
                [
                    20,
                    " if ( server -> method ) fprintf ( f , \",\\n\\\"method\\\":\\\"%s\\\"\" , server -> method ) ;\n"
                ],
                [
                    21,
                    " if ( server -> plugin ) fprintf ( f , \",\\n\\\"plugin\\\":\\\"%s\\\"\" , server -> plugin ) ;\n"
                ],
                [
                    22,
                    " if ( server -> plugin_opts ) fprintf ( f , \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\" , server -> plugin_opts ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) {\n static char cmd [ BUF_SIZE ] ;\n char * method = manager -> method ;\n int i ;\n build_config ( working_dir , server ) ;\n if ( server -> method ) method = server -> method ;\n memset ( cmd , 0 , BUF_SIZE ) ;\n snprintf ( cmd , BUF_SIZE , \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\" , executable , method , manager -> manager_address , working_dir , server -> port , working_dir , server -> port ) ;\n if ( manager -> acl != NULL ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" --acl %s\" , manager -> acl ) ;\n }\n if ( manager -> timeout != NULL ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -t %s\" , manager -> timeout ) ;\n }\n # ifdef HAVE_SETRLIMIT if ( manager -> nofile ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -n %d\" , manager -> nofile ) ;\n }\n # endif if ( manager -> user != NULL ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -a %s\" , manager -> user ) ;\n }\n if ( manager -> verbose ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -v\" ) ;\n }\n if ( server -> mode == NULL && manager -> mode == UDP_ONLY ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -U\" ) ;\n }\n if ( server -> mode == NULL && manager -> mode == TCP_AND_UDP ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -u\" ) ;\n }\n if ( server -> fast_open [ 0 ] == 0 && manager -> fast_open ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" --fast-open\" ) ;\n }\n if ( manager -> ipv6first ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -6\" ) ;\n }\n if ( manager -> mtu ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" --mtu %d\" , manager -> mtu ) ;\n }\n if ( server -> plugin == NULL && manager -> plugin ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" --plugin \\\"%s\\\"\" , manager -> plugin ) ;\n }\n if ( server -> plugin_opts == NULL && manager -> plugin_opts ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" --plugin-opts \\\"%s\\\"\" , manager -> plugin_opts ) ;\n }\n for ( i = 0 ;\n i < manager -> nameserver_num ;\n i ++ ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -d %s\" , manager -> nameservers [ i ] ) ;\n }\n for ( i = 0 ;\n i < manager -> host_num ;\n i ++ ) {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" -s %s\" , manager -> hosts [ i ] ) ;\n }\n {\n int len = strlen ( cmd ) ;\n snprintf ( cmd + len , BUF_SIZE - len , \" --reuse-port\" ) ;\n }\n if ( verbose ) {\n LOGI ( \"cmd: %s\" , cmd ) ;\n }\n return cmd ;\n }",
        "hash": -7248963932691286231,
        "project": "debian",
        "size": 77,
        "slice": {
            "memset": [
                [
                    1,
                    "static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) {\n"
                ],
                [
                    2,
                    " static char cmd [ BUF_SIZE ] ;\n"
                ],
                [
                    7,
                    " memset ( cmd , 0 , BUF_SIZE ) ;\n"
                ],
                [
                    8,
                    " snprintf ( cmd , BUF_SIZE , \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\" , executable , method , manager -> manager_address , working_dir , server -> port , working_dir , server -> port ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) {\n"
                ],
                [
                    8,
                    " snprintf ( cmd , BUF_SIZE , \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\" , executable , method , manager -> manager_address , working_dir , server -> port , working_dir , server -> port ) ;\n"
                ],
                [
                    9,
                    " if ( manager -> acl != NULL ) {\n"
                ],
                [
                    10,
                    " int len = strlen ( cmd ) ;\n"
                ],
                [
                    11,
                    " snprintf ( cmd + len , BUF_SIZE - len , \" --acl %s\" , manager -> acl ) ;\n"
                ],
                [
                    13,
                    " if ( manager -> timeout != NULL ) {\n"
                ],
                [
                    14,
                    " int len = strlen ( cmd ) ;\n"
                ],
                [
                    15,
                    " snprintf ( cmd + len , BUF_SIZE - len , \" -t %s\" , manager -> timeout ) ;\n"
                ],
                [
                    22,
                    " int len = strlen ( cmd ) ;\n"
                ],
                [
                    23,
                    " snprintf ( cmd + len , BUF_SIZE - len , \" -a %s\" , manager -> user ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) {\n"
                ],
                [
                    2,
                    " static char cmd [ BUF_SIZE ] ;\n"
                ],
                [
                    7,
                    " memset ( cmd , 0 , BUF_SIZE ) ;\n"
                ],
                [
                    8,
                    " snprintf ( cmd , BUF_SIZE , \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\" , executable , method , manager -> manager_address , working_dir , server -> port , working_dir , server -> port ) ;\n"
                ],
                [
                    9,
                    " if ( manager -> acl != NULL ) {\n"
                ],
                [
                    10,
                    " int len = strlen ( cmd ) ;\n"
                ],
                [
                    11,
                    " snprintf ( cmd + len , BUF_SIZE - len , \" --acl %s\" , manager -> acl ) ;\n"
                ],
                [
                    13,
                    " if ( manager -> timeout != NULL ) {\n"
                ],
                [
                    14,
                    " int len = strlen ( cmd ) ;\n"
                ],
                [
                    15,
                    " snprintf ( cmd + len , BUF_SIZE - len , \" -t %s\" , manager -> timeout ) ;\n"
                ],
                [
                    22,
                    " int len = strlen ( cmd ) ;\n"
                ],
                [
                    23,
                    " snprintf ( cmd + len , BUF_SIZE - len , \" -a %s\" , manager -> user ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) {\n size_t bufsz = strlen ( root ) + sizeof ( \"/sys/fs/cgroup\" ) ;\n char * path = NULL ;\n char * * parts = NULL ;\n char * dirname = NULL ;\n char * abs_path = NULL ;\n char * abs_path2 = NULL ;\n struct cgfs_data * cgfs_d ;\n struct cgroup_process_info * info , * base_info ;\n int r , saved_errno = 0 ;\n cgfs_d = hdata ;\n if ( ! cgfs_d ) return false ;\n base_info = cgfs_d -> info ;\n if ( type == LXC_AUTO_CGROUP_FULL_NOSPEC ) type = LXC_AUTO_CGROUP_FULL_MIXED ;\n else if ( type == LXC_AUTO_CGROUP_NOSPEC ) type = LXC_AUTO_CGROUP_MIXED ;\n if ( type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED ) {\n ERROR ( \"could not mount cgroups into container: invalid type specified internally\" ) ;\n errno = EINVAL ;\n return false ;\n }\n path = calloc ( 1 , bufsz ) ;\n if ( ! path ) return false ;\n snprintf ( path , bufsz , \"%s/sys/fs/cgroup\" , root ) ;\n r = mount ( \"cgroup_root\" , path , \"tmpfs\" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , \"size=10240k,mode=755\" ) ;\n if ( r < 0 ) {\n SYSERROR ( \"could not mount tmpfs to /sys/fs/cgroup in the container\" ) ;\n return false ;\n }\n for ( info = base_info ;\n info ;\n info = info -> next ) {\n size_t subsystem_count , i ;\n struct cgroup_mount_point * mp = info -> designated_mount_point ;\n if ( ! mp ) mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ;\n if ( ! mp ) {\n SYSERROR ( \"could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem\" ) ;\n goto out_error ;\n }\n subsystem_count = lxc_array_len ( ( void * * ) info -> hierarchy -> subsystems ) ;\n parts = calloc ( subsystem_count + 1 , sizeof ( char * ) ) ;\n if ( ! parts ) goto out_error ;\n for ( i = 0 ;\n i < subsystem_count ;\n i ++ ) {\n if ( ! strncmp ( info -> hierarchy -> subsystems [ i ] , \"name=\" , 5 ) ) parts [ i ] = info -> hierarchy -> subsystems [ i ] + 5 ;\n else parts [ i ] = info -> hierarchy -> subsystems [ i ] ;\n }\n dirname = lxc_string_join ( \",\" , ( const char * * ) parts , false ) ;\n if ( ! dirname ) goto out_error ;\n abs_path = lxc_append_paths ( path , dirname ) ;\n if ( ! abs_path ) goto out_error ;\n r = mkdir_p ( abs_path , 0755 ) ;\n if ( r < 0 && errno != EEXIST ) {\n SYSERROR ( \"could not create cgroup subsystem directory /sys/fs/cgroup/%s\" , dirname ) ;\n goto out_error ;\n }\n abs_path2 = lxc_append_paths ( abs_path , info -> cgroup_path ) ;\n if ( ! abs_path2 ) goto out_error ;\n if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n if ( strcmp ( mp -> mount_prefix , \"/\" ) != 0 ) {\n ERROR ( \"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\" , dirname ) ;\n goto out_error ;\n }\n r = mount ( mp -> mount_point , abs_path , \"none\" , MS_BIND , 0 ) ;\n if ( r < 0 ) {\n SYSERROR ( \"error bind-mounting %s to %s\" , mp -> mount_point , abs_path ) ;\n goto out_error ;\n }\n if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n if ( r < 0 ) {\n SYSERROR ( \"error re-mounting %s readonly\" , abs_path ) ;\n goto out_error ;\n }\n }\n if ( type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n r = mount ( abs_path2 , abs_path2 , NULL , MS_BIND , NULL ) ;\n if ( r < 0 ) {\n SYSERROR ( \"error bind-mounting %s onto itself\" , abs_path2 ) ;\n goto out_error ;\n }\n r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND , NULL ) ;\n if ( r < 0 ) {\n SYSERROR ( \"error re-mounting %s readwrite\" , abs_path2 ) ;\n goto out_error ;\n }\n }\n }\n else {\n r = mkdir_p ( abs_path2 , 0755 ) ;\n if ( r < 0 && errno != EEXIST ) {\n SYSERROR ( \"could not create cgroup directory /sys/fs/cgroup/%s%s\" , dirname , info -> cgroup_path ) ;\n goto out_error ;\n }\n if ( type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO ) {\n r = mount ( abs_path , abs_path , NULL , MS_BIND , NULL ) ;\n if ( r < 0 ) {\n SYSERROR ( \"error bind-mounting %s onto itself\" , abs_path ) ;\n goto out_error ;\n }\n r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n if ( r < 0 ) {\n SYSERROR ( \"error re-mounting %s readonly\" , abs_path ) ;\n goto out_error ;\n }\n }\n free ( abs_path ) ;\n abs_path = NULL ;\n abs_path = cgroup_to_absolute_path ( mp , info -> cgroup_path , NULL ) ;\n if ( ! abs_path ) goto out_error ;\n r = mount ( abs_path , abs_path2 , \"none\" , MS_BIND , 0 ) ;\n if ( r < 0 ) {\n SYSERROR ( \"error bind-mounting %s to %s\" , abs_path , abs_path2 ) ;\n goto out_error ;\n }\n if ( type == LXC_AUTO_CGROUP_RO ) {\n r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n if ( r < 0 ) {\n SYSERROR ( \"error re-mounting %s readonly\" , abs_path2 ) ;\n goto out_error ;\n }\n }\n }\n free ( abs_path ) ;\n free ( abs_path2 ) ;\n abs_path = NULL ;\n abs_path2 = NULL ;\n if ( subsystem_count > 1 ) {\n for ( i = 0 ;\n i < subsystem_count ;\n i ++ ) {\n abs_path = lxc_append_paths ( path , parts [ i ] ) ;\n if ( ! abs_path ) goto out_error ;\n r = symlink ( dirname , abs_path ) ;\n if ( r < 0 ) WARN ( \"could not create symlink %s -> %s in /sys/fs/cgroup of container\" , parts [ i ] , dirname ) ;\n free ( abs_path ) ;\n abs_path = NULL ;\n }\n }\n free ( dirname ) ;\n free ( parts ) ;\n dirname = NULL ;\n parts = NULL ;\n }\n free ( path ) ;\n return true ;\n out_error : saved_errno = errno ;\n free ( path ) ;\n free ( dirname ) ;\n free ( parts ) ;\n free ( abs_path ) ;\n free ( abs_path2 ) ;\n errno = saved_errno ;\n return false ;\n }",
        "hash": -5992472514718425579,
        "project": "debian",
        "size": 155,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) {\n"
                ],
                [
                    34,
                    " if ( ! mp ) mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ;\n"
                ],
                [
                    35,
                    " if ( ! mp ) {\n"
                ],
                [
                    59,
                    " if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n"
                ],
                [
                    60,
                    " if ( strcmp ( mp -> mount_prefix , \"/\" ) != 0 ) {\n"
                ],
                [
                    61,
                    " ERROR ( \"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\" , dirname ) ;\n"
                ],
                [
                    64,
                    " r = mount ( mp -> mount_point , abs_path , \"none\" , MS_BIND , 0 ) ;\n"
                ],
                [
                    65,
                    " if ( r < 0 ) {\n"
                ],
                [
                    109,
                    " abs_path = cgroup_to_absolute_path ( mp , info -> cgroup_path , NULL ) ;\n"
                ],
                [
                    147,
                    " out_error : saved_errno = errno ;\n"
                ],
                [
                    148,
                    " free ( path ) ;\n"
                ],
                [
                    149,
                    " free ( dirname ) ;\n"
                ],
                [
                    150,
                    " free ( parts ) ;\n"
                ],
                [
                    151,
                    " free ( abs_path ) ;\n"
                ],
                [
                    152,
                    " free ( abs_path2 ) ;\n"
                ],
                [
                    153,
                    " errno = saved_errno ;\n"
                ],
                [
                    154,
                    " return false ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) {\n"
                ],
                [
                    2,
                    " size_t bufsz = strlen ( root ) + sizeof ( \"/sys/fs/cgroup\" ) ;\n"
                ],
                [
                    21,
                    " path = calloc ( 1 , bufsz ) ;\n"
                ],
                [
                    23,
                    " snprintf ( path , bufsz , \"%s/sys/fs/cgroup\" , root ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) {\n"
                ],
                [
                    4,
                    " char * * parts = NULL ;\n"
                ],
                [
                    5,
                    " char * dirname = NULL ;\n"
                ],
                [
                    6,
                    " char * abs_path = NULL ;\n"
                ],
                [
                    7,
                    " char * abs_path2 = NULL ;\n"
                ],
                [
                    24,
                    " r = mount ( \"cgroup_root\" , path , \"tmpfs\" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , \"size=10240k,mode=755\" ) ;\n"
                ],
                [
                    30,
                    " info ;\n"
                ],
                [
                    35,
                    " if ( ! mp ) {\n"
                ],
                [
                    41,
                    " if ( ! parts ) goto out_error ;\n"
                ],
                [
                    45,
                    " if ( ! strncmp ( info -> hierarchy -> subsystems [ i ] , \"name=\" , 5 ) ) parts [ i ] = info -> hierarchy -> subsystems [ i ] + 5 ;\n"
                ],
                [
                    46,
                    " else parts [ i ] = info -> hierarchy -> subsystems [ i ] ;\n"
                ],
                [
                    49,
                    " if ( ! dirname ) goto out_error ;\n"
                ],
                [
                    50,
                    " abs_path = lxc_append_paths ( path , dirname ) ;\n"
                ],
                [
                    51,
                    " if ( ! abs_path ) goto out_error ;\n"
                ],
                [
                    52,
                    " r = mkdir_p ( abs_path , 0755 ) ;\n"
                ],
                [
                    53,
                    " if ( r < 0 && errno != EEXIST ) {\n"
                ],
                [
                    54,
                    " SYSERROR ( \"could not create cgroup subsystem directory /sys/fs/cgroup/%s\" , dirname ) ;\n"
                ],
                [
                    57,
                    " abs_path2 = lxc_append_paths ( abs_path , info -> cgroup_path ) ;\n"
                ],
                [
                    58,
                    " if ( ! abs_path2 ) goto out_error ;\n"
                ],
                [
                    60,
                    " if ( strcmp ( mp -> mount_prefix , \"/\" ) != 0 ) {\n"
                ],
                [
                    61,
                    " ERROR ( \"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\" , dirname ) ;\n"
                ],
                [
                    64,
                    " r = mount ( mp -> mount_point , abs_path , \"none\" , MS_BIND , 0 ) ;\n"
                ],
                [
                    65,
                    " if ( r < 0 ) {\n"
                ],
                [
                    66,
                    " SYSERROR ( \"error bind-mounting %s to %s\" , mp -> mount_point , abs_path ) ;\n"
                ],
                [
                    70,
                    " r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n"
                ],
                [
                    71,
                    " if ( r < 0 ) {\n"
                ],
                [
                    72,
                    " SYSERROR ( \"error re-mounting %s readonly\" , abs_path ) ;\n"
                ],
                [
                    76,
                    " if ( type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n"
                ],
                [
                    78,
                    " if ( r < 0 ) {\n"
                ],
                [
                    79,
                    " SYSERROR ( \"error bind-mounting %s onto itself\" , abs_path2 ) ;\n"
                ],
                [
                    82,
                    " r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND , NULL ) ;\n"
                ],
                [
                    83,
                    " if ( r < 0 ) {\n"
                ],
                [
                    84,
                    " SYSERROR ( \"error re-mounting %s readwrite\" , abs_path2 ) ;\n"
                ],
                [
                    90,
                    " r = mkdir_p ( abs_path2 , 0755 ) ;\n"
                ],
                [
                    91,
                    " if ( r < 0 && errno != EEXIST ) {\n"
                ],
                [
                    92,
                    " SYSERROR ( \"could not create cgroup directory /sys/fs/cgroup/%s%s\" , dirname , info -> cgroup_path ) ;\n"
                ],
                [
                    95,
                    " if ( type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO ) {\n"
                ],
                [
                    97,
                    " if ( r < 0 ) {\n"
                ],
                [
                    98,
                    " SYSERROR ( \"error bind-mounting %s onto itself\" , abs_path ) ;\n"
                ],
                [
                    101,
                    " r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n"
                ],
                [
                    102,
                    " if ( r < 0 ) {\n"
                ],
                [
                    103,
                    " SYSERROR ( \"error re-mounting %s readonly\" , abs_path ) ;\n"
                ],
                [
                    107,
                    " free ( abs_path ) ;\n"
                ],
                [
                    110,
                    " if ( ! abs_path ) goto out_error ;\n"
                ],
                [
                    111,
                    " r = mount ( abs_path , abs_path2 , \"none\" , MS_BIND , 0 ) ;\n"
                ],
                [
                    112,
                    " if ( r < 0 ) {\n"
                ],
                [
                    113,
                    " SYSERROR ( \"error bind-mounting %s to %s\" , abs_path , abs_path2 ) ;\n"
                ],
                [
                    116,
                    " if ( type == LXC_AUTO_CGROUP_RO ) {\n"
                ],
                [
                    117,
                    " r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n"
                ],
                [
                    118,
                    " if ( r < 0 ) {\n"
                ],
                [
                    119,
                    " SYSERROR ( \"error re-mounting %s readonly\" , abs_path2 ) ;\n"
                ],
                [
                    124,
                    " free ( abs_path ) ;\n"
                ],
                [
                    125,
                    " free ( abs_path2 ) ;\n"
                ],
                [
                    126,
                    " abs_path = NULL ;\n"
                ],
                [
                    127,
                    " abs_path2 = NULL ;\n"
                ],
                [
                    128,
                    " if ( subsystem_count > 1 ) {\n"
                ],
                [
                    130,
                    " i < subsystem_count ;\n"
                ],
                [
                    132,
                    " abs_path = lxc_append_paths ( path , parts [ i ] ) ;\n"
                ],
                [
                    133,
                    " if ( ! abs_path ) goto out_error ;\n"
                ],
                [
                    134,
                    " r = symlink ( dirname , abs_path ) ;\n"
                ],
                [
                    135,
                    " if ( r < 0 ) WARN ( \"could not create symlink %s -> %s in /sys/fs/cgroup of container\" , parts [ i ] , dirname ) ;\n"
                ],
                [
                    136,
                    " free ( abs_path ) ;\n"
                ],
                [
                    137,
                    " abs_path = NULL ;\n"
                ],
                [
                    140,
                    " free ( dirname ) ;\n"
                ],
                [
                    141,
                    " free ( parts ) ;\n"
                ],
                [
                    142,
                    " dirname = NULL ;\n"
                ],
                [
                    143,
                    " parts = NULL ;\n"
                ],
                [
                    145,
                    " free ( path ) ;\n"
                ],
                [
                    148,
                    " free ( path ) ;\n"
                ],
                [
                    149,
                    " free ( dirname ) ;\n"
                ],
                [
                    150,
                    " free ( parts ) ;\n"
                ],
                [
                    151,
                    " free ( abs_path ) ;\n"
                ],
                [
                    152,
                    " free ( abs_path2 ) ;\n"
                ]
            ],
            "calloc": [
                [
                    1,
                    "static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) {\n"
                ],
                [
                    2,
                    " size_t bufsz = strlen ( root ) + sizeof ( \"/sys/fs/cgroup\" ) ;\n"
                ],
                [
                    16,
                    " if ( type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED ) {\n"
                ],
                [
                    21,
                    " path = calloc ( 1 , bufsz ) ;\n"
                ],
                [
                    22,
                    " if ( ! path ) return false ;\n"
                ],
                [
                    35,
                    " if ( ! mp ) {\n"
                ],
                [
                    39,
                    " subsystem_count = lxc_array_len ( ( void * * ) info -> hierarchy -> subsystems ) ;\n"
                ],
                [
                    40,
                    " parts = calloc ( subsystem_count + 1 , sizeof ( char * ) ) ;\n"
                ],
                [
                    41,
                    " if ( ! parts ) goto out_error ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) {\n"
                ],
                [
                    2,
                    " size_t bufsz = strlen ( root ) + sizeof ( \"/sys/fs/cgroup\" ) ;\n"
                ],
                [
                    4,
                    " char * * parts = NULL ;\n"
                ],
                [
                    5,
                    " char * dirname = NULL ;\n"
                ],
                [
                    6,
                    " char * abs_path = NULL ;\n"
                ],
                [
                    7,
                    " char * abs_path2 = NULL ;\n"
                ],
                [
                    16,
                    " if ( type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED ) {\n"
                ],
                [
                    21,
                    " path = calloc ( 1 , bufsz ) ;\n"
                ],
                [
                    22,
                    " if ( ! path ) return false ;\n"
                ],
                [
                    23,
                    " snprintf ( path , bufsz , \"%s/sys/fs/cgroup\" , root ) ;\n"
                ],
                [
                    24,
                    " r = mount ( \"cgroup_root\" , path , \"tmpfs\" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , \"size=10240k,mode=755\" ) ;\n"
                ],
                [
                    30,
                    " info ;\n"
                ],
                [
                    34,
                    " if ( ! mp ) mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ;\n"
                ],
                [
                    35,
                    " if ( ! mp ) {\n"
                ],
                [
                    39,
                    " subsystem_count = lxc_array_len ( ( void * * ) info -> hierarchy -> subsystems ) ;\n"
                ],
                [
                    40,
                    " parts = calloc ( subsystem_count + 1 , sizeof ( char * ) ) ;\n"
                ],
                [
                    41,
                    " if ( ! parts ) goto out_error ;\n"
                ],
                [
                    45,
                    " if ( ! strncmp ( info -> hierarchy -> subsystems [ i ] , \"name=\" , 5 ) ) parts [ i ] = info -> hierarchy -> subsystems [ i ] + 5 ;\n"
                ],
                [
                    46,
                    " else parts [ i ] = info -> hierarchy -> subsystems [ i ] ;\n"
                ],
                [
                    49,
                    " if ( ! dirname ) goto out_error ;\n"
                ],
                [
                    50,
                    " abs_path = lxc_append_paths ( path , dirname ) ;\n"
                ],
                [
                    51,
                    " if ( ! abs_path ) goto out_error ;\n"
                ],
                [
                    52,
                    " r = mkdir_p ( abs_path , 0755 ) ;\n"
                ],
                [
                    53,
                    " if ( r < 0 && errno != EEXIST ) {\n"
                ],
                [
                    54,
                    " SYSERROR ( \"could not create cgroup subsystem directory /sys/fs/cgroup/%s\" , dirname ) ;\n"
                ],
                [
                    57,
                    " abs_path2 = lxc_append_paths ( abs_path , info -> cgroup_path ) ;\n"
                ],
                [
                    58,
                    " if ( ! abs_path2 ) goto out_error ;\n"
                ],
                [
                    59,
                    " if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n"
                ],
                [
                    60,
                    " if ( strcmp ( mp -> mount_prefix , \"/\" ) != 0 ) {\n"
                ],
                [
                    61,
                    " ERROR ( \"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\" , dirname ) ;\n"
                ],
                [
                    64,
                    " r = mount ( mp -> mount_point , abs_path , \"none\" , MS_BIND , 0 ) ;\n"
                ],
                [
                    65,
                    " if ( r < 0 ) {\n"
                ],
                [
                    66,
                    " SYSERROR ( \"error bind-mounting %s to %s\" , mp -> mount_point , abs_path ) ;\n"
                ],
                [
                    70,
                    " r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n"
                ],
                [
                    71,
                    " if ( r < 0 ) {\n"
                ],
                [
                    72,
                    " SYSERROR ( \"error re-mounting %s readonly\" , abs_path ) ;\n"
                ],
                [
                    76,
                    " if ( type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n"
                ],
                [
                    78,
                    " if ( r < 0 ) {\n"
                ],
                [
                    79,
                    " SYSERROR ( \"error bind-mounting %s onto itself\" , abs_path2 ) ;\n"
                ],
                [
                    82,
                    " r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND , NULL ) ;\n"
                ],
                [
                    83,
                    " if ( r < 0 ) {\n"
                ],
                [
                    84,
                    " SYSERROR ( \"error re-mounting %s readwrite\" , abs_path2 ) ;\n"
                ],
                [
                    90,
                    " r = mkdir_p ( abs_path2 , 0755 ) ;\n"
                ],
                [
                    91,
                    " if ( r < 0 && errno != EEXIST ) {\n"
                ],
                [
                    92,
                    " SYSERROR ( \"could not create cgroup directory /sys/fs/cgroup/%s%s\" , dirname , info -> cgroup_path ) ;\n"
                ],
                [
                    95,
                    " if ( type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO ) {\n"
                ],
                [
                    97,
                    " if ( r < 0 ) {\n"
                ],
                [
                    98,
                    " SYSERROR ( \"error bind-mounting %s onto itself\" , abs_path ) ;\n"
                ],
                [
                    101,
                    " r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n"
                ],
                [
                    102,
                    " if ( r < 0 ) {\n"
                ],
                [
                    103,
                    " SYSERROR ( \"error re-mounting %s readonly\" , abs_path ) ;\n"
                ],
                [
                    107,
                    " free ( abs_path ) ;\n"
                ],
                [
                    109,
                    " abs_path = cgroup_to_absolute_path ( mp , info -> cgroup_path , NULL ) ;\n"
                ],
                [
                    110,
                    " if ( ! abs_path ) goto out_error ;\n"
                ],
                [
                    111,
                    " r = mount ( abs_path , abs_path2 , \"none\" , MS_BIND , 0 ) ;\n"
                ],
                [
                    112,
                    " if ( r < 0 ) {\n"
                ],
                [
                    113,
                    " SYSERROR ( \"error bind-mounting %s to %s\" , abs_path , abs_path2 ) ;\n"
                ],
                [
                    116,
                    " if ( type == LXC_AUTO_CGROUP_RO ) {\n"
                ],
                [
                    117,
                    " r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n"
                ],
                [
                    118,
                    " if ( r < 0 ) {\n"
                ],
                [
                    119,
                    " SYSERROR ( \"error re-mounting %s readonly\" , abs_path2 ) ;\n"
                ],
                [
                    124,
                    " free ( abs_path ) ;\n"
                ],
                [
                    125,
                    " free ( abs_path2 ) ;\n"
                ],
                [
                    126,
                    " abs_path = NULL ;\n"
                ],
                [
                    127,
                    " abs_path2 = NULL ;\n"
                ],
                [
                    128,
                    " if ( subsystem_count > 1 ) {\n"
                ],
                [
                    130,
                    " i < subsystem_count ;\n"
                ],
                [
                    132,
                    " abs_path = lxc_append_paths ( path , parts [ i ] ) ;\n"
                ],
                [
                    133,
                    " if ( ! abs_path ) goto out_error ;\n"
                ],
                [
                    134,
                    " r = symlink ( dirname , abs_path ) ;\n"
                ],
                [
                    135,
                    " if ( r < 0 ) WARN ( \"could not create symlink %s -> %s in /sys/fs/cgroup of container\" , parts [ i ] , dirname ) ;\n"
                ],
                [
                    136,
                    " free ( abs_path ) ;\n"
                ],
                [
                    137,
                    " abs_path = NULL ;\n"
                ],
                [
                    140,
                    " free ( dirname ) ;\n"
                ],
                [
                    141,
                    " free ( parts ) ;\n"
                ],
                [
                    142,
                    " dirname = NULL ;\n"
                ],
                [
                    143,
                    " parts = NULL ;\n"
                ],
                [
                    145,
                    " free ( path ) ;\n"
                ],
                [
                    147,
                    " out_error : saved_errno = errno ;\n"
                ],
                [
                    148,
                    " free ( path ) ;\n"
                ],
                [
                    149,
                    " free ( dirname ) ;\n"
                ],
                [
                    150,
                    " free ( parts ) ;\n"
                ],
                [
                    151,
                    " free ( abs_path ) ;\n"
                ],
                [
                    152,
                    " free ( abs_path2 ) ;\n"
                ],
                [
                    153,
                    " errno = saved_errno ;\n"
                ],
                [
                    154,
                    " return false ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void show_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {\n char * name = path_name ( path , last ) ;\n add_preferred_base_object ( name ) ;\n add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ;\n obj -> flags |= OBJECT_ADDED ;\n free ( ( char * ) name ) ;\n }",
        "hash": 3919646340804521652,
        "project": "debian",
        "size": 7,
        "slice": {
            "free": [
                [
                    1,
                    "static void show_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {\n"
                ],
                [
                    4,
                    " add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ;\n"
                ],
                [
                    6,
                    " free ( ( char * ) name ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void show_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {\n"
                ],
                [
                    4,
                    " add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ;\n"
                ],
                [
                    6,
                    " free ( ( char * ) name ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static struct object_list * * process_tree ( struct tree * tree , struct object_list * * p , struct name_path * path , const char * name ) {\n struct object * obj = & tree -> object ;\n struct tree_desc desc ;\n struct name_entry entry ;\n struct name_path me ;\n obj -> flags |= LOCAL ;\n if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return p ;\n if ( parse_tree ( tree ) < 0 ) die ( \"bad tree object %s\" , oid_to_hex ( & obj -> oid ) ) ;\n obj -> flags |= SEEN ;\n name = xstrdup ( name ) ;\n p = add_one_object ( obj , p ) ;\n me . up = path ;\n me . elem = name ;\n me . elem_len = strlen ( name ) ;\n init_tree_desc ( & desc , tree -> buffer , tree -> size ) ;\n while ( tree_entry ( & desc , & entry ) ) switch ( object_type ( entry . mode ) ) {\n case OBJ_TREE : p = process_tree ( lookup_tree ( entry . sha1 ) , p , & me , name ) ;\n break ;\n case OBJ_BLOB : p = process_blob ( lookup_blob ( entry . sha1 ) , p , & me , name ) ;\n break ;\n default : break ;\n }\n free_tree_buffer ( tree ) ;\n return p ;\n }",
        "hash": 229962612204196999,
        "project": "debian",
        "size": 25,
        "slice": {
            "strlen": [
                [
                    1,
                    "static struct object_list * * process_tree ( struct tree * tree , struct object_list * * p , struct name_path * path , const char * name ) {\n"
                ],
                [
                    7,
                    " if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return p ;\n"
                ],
                [
                    10,
                    " name = xstrdup ( name ) ;\n"
                ],
                [
                    14,
                    " me . elem_len = strlen ( name ) ;\n"
                ],
                [
                    17,
                    " case OBJ_TREE : p = process_tree ( lookup_tree ( entry . sha1 ) , p , & me , name ) ;\n"
                ],
                [
                    19,
                    " case OBJ_BLOB : p = process_blob ( lookup_blob ( entry . sha1 ) , p , & me , name ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static struct object_list * * process_tree ( struct tree * tree , struct object_list * * p , struct name_path * path , const char * name ) {\n"
                ],
                [
                    7,
                    " if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return p ;\n"
                ],
                [
                    10,
                    " name = xstrdup ( name ) ;\n"
                ],
                [
                    14,
                    " me . elem_len = strlen ( name ) ;\n"
                ],
                [
                    17,
                    " case OBJ_TREE : p = process_tree ( lookup_tree ( entry . sha1 ) , p , & me , name ) ;\n"
                ],
                [
                    19,
                    " case OBJ_BLOB : p = process_blob ( lookup_blob ( entry . sha1 ) , p , & me , name ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {\n struct bitmap * base = data ;\n int bitmap_pos ;\n bitmap_pos = bitmap_position ( object -> oid . hash ) ;\n if ( bitmap_pos < 0 ) {\n char * name = path_name ( path , last ) ;\n bitmap_pos = ext_index_add_object ( object , name ) ;\n free ( name ) ;\n }\n bitmap_set ( base , bitmap_pos ) ;\n }",
        "hash": 1414661670117003749,
        "project": "debian",
        "size": 11,
        "slice": {
            "free": [
                [
                    1,
                    "static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {\n"
                ],
                [
                    5,
                    " if ( bitmap_pos < 0 ) {\n"
                ],
                [
                    7,
                    " bitmap_pos = ext_index_add_object ( object , name ) ;\n"
                ],
                [
                    8,
                    " free ( name ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {\n"
                ],
                [
                    5,
                    " if ( bitmap_pos < 0 ) {\n"
                ],
                [
                    7,
                    " bitmap_pos = ext_index_add_object ( object , name ) ;\n"
                ],
                [
                    8,
                    " free ( name ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct name_path * path , struct strbuf * base , const char * name , void * cb_data ) {\n struct object * obj = & tree -> object ;\n struct tree_desc desc ;\n struct name_entry entry ;\n struct name_path me ;\n enum interesting match = revs -> diffopt . pathspec . nr == 0 ? all_entries_interesting : entry_not_interesting ;\n int baselen = base -> len ;\n if ( ! revs -> tree_objects ) return ;\n if ( ! obj ) die ( \"bad tree object\" ) ;\n if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ;\n if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) {\n if ( revs -> ignore_missing_links ) return ;\n die ( \"bad tree object %s\" , oid_to_hex ( & obj -> oid ) ) ;\n }\n obj -> flags |= SEEN ;\n show ( obj , path , name , cb_data ) ;\n me . up = path ;\n me . elem = name ;\n me . elem_len = strlen ( name ) ;\n if ( ! match ) {\n strbuf_addstr ( base , name ) ;\n if ( base -> len ) strbuf_addch ( base , '/' ) ;\n }\n init_tree_desc ( & desc , tree -> buffer , tree -> size ) ;\n while ( tree_entry ( & desc , & entry ) ) {\n if ( match != all_entries_interesting ) {\n match = tree_entry_interesting ( & entry , base , 0 , & revs -> diffopt . pathspec ) ;\n if ( match == all_entries_not_interesting ) break ;\n if ( match == entry_not_interesting ) continue ;\n }\n if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , & me , base , entry . path , cb_data ) ;\n else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , & me , entry . path , cb_data ) ;\n else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , & me , entry . path , cb_data ) ;\n }\n strbuf_setlen ( base , baselen ) ;\n free_tree_buffer ( tree ) ;\n }",
        "hash": -2654475221056024278,
        "project": "debian",
        "size": 37,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct name_path * path , struct strbuf * base , const char * name , void * cb_data ) {\n"
                ],
                [
                    11,
                    " if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) {\n"
                ],
                [
                    12,
                    " if ( revs -> ignore_missing_links ) return ;\n"
                ],
                [
                    16,
                    " show ( obj , path , name , cb_data ) ;\n"
                ],
                [
                    19,
                    " me . elem_len = strlen ( name ) ;\n"
                ],
                [
                    21,
                    " strbuf_addstr ( base , name ) ;\n"
                ],
                [
                    31,
                    " if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , & me , base , entry . path , cb_data ) ;\n"
                ],
                [
                    32,
                    " else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , & me , entry . path , cb_data ) ;\n"
                ],
                [
                    33,
                    " else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , & me , entry . path , cb_data ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct name_path * path , struct strbuf * base , const char * name , void * cb_data ) {\n"
                ],
                [
                    11,
                    " if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) {\n"
                ],
                [
                    12,
                    " if ( revs -> ignore_missing_links ) return ;\n"
                ],
                [
                    16,
                    " show ( obj , path , name , cb_data ) ;\n"
                ],
                [
                    19,
                    " me . elem_len = strlen ( name ) ;\n"
                ],
                [
                    21,
                    " strbuf_addstr ( base , name ) ;\n"
                ],
                [
                    31,
                    " if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , & me , base , entry . path , cb_data ) ;\n"
                ],
                [
                    32,
                    " else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , & me , entry . path , cb_data ) ;\n"
                ],
                [
                    33,
                    " else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , & me , entry . path , cb_data ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void cookedprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) {\n char * name ;\n char * value ;\n char output_raw ;\n int fmt ;\n l_fp lfp ;\n sockaddr_u hval ;\n u_long uval ;\n int narr ;\n size_t len ;\n l_fp lfparr [ 8 ] ;\n char b [ 12 ] ;\n char bn [ 2 * MAXVARLEN ] ;\n char bv [ 2 * MAXVALLEN ] ;\n UNUSED_ARG ( datatype ) ;\n if ( ! quiet ) fprintf ( fp , \"status=%04x %s,\\n\" , status , statustoa ( datatype , status ) ) ;\n startoutput ( ) ;\n while ( nextvar ( & length , & data , & name , & value ) ) {\n fmt = varfmt ( name ) ;\n output_raw = 0 ;\n switch ( fmt ) {\n case PADDING : output_raw = '*' ;\n break ;\n case TS : if ( ! decodets ( value , & lfp ) ) output_raw = '?' ;\n else output ( fp , name , prettydate ( & lfp ) ) ;\n break ;\n case HA : case NA : if ( ! decodenetnum ( value , & hval ) ) {\n output_raw = '?' ;\n }\n else if ( fmt == HA ) {\n output ( fp , name , nntohost ( & hval ) ) ;\n }\n else {\n output ( fp , name , stoa ( & hval ) ) ;\n }\n break ;\n case RF : if ( decodenetnum ( value , & hval ) ) {\n if ( ISREFCLOCKADR ( & hval ) ) output ( fp , name , refnumtoa ( & hval ) ) ;\n else output ( fp , name , stoa ( & hval ) ) ;\n }\n else if ( strlen ( value ) <= 4 ) {\n output ( fp , name , value ) ;\n }\n else {\n output_raw = '?' ;\n }\n break ;\n case LP : if ( ! decodeuint ( value , & uval ) || uval > 3 ) {\n output_raw = '?' ;\n }\n else {\n b [ 0 ] = ( 0x2 & uval ) ? '1' : '0' ;\n b [ 1 ] = ( 0x1 & uval ) ? '1' : '0' ;\n b [ 2 ] = '\\0' ;\n output ( fp , name , b ) ;\n }\n break ;\n case OC : if ( ! decodeuint ( value , & uval ) ) {\n output_raw = '?' ;\n }\n else {\n snprintf ( b , sizeof ( b ) , \"%03lo\" , uval ) ;\n output ( fp , name , b ) ;\n }\n break ;\n case AR : if ( ! decodearr ( value , & narr , lfparr ) ) output_raw = '?' ;\n else outputarr ( fp , name , narr , lfparr ) ;\n break ;\n case FX : if ( ! decodeuint ( value , & uval ) ) output_raw = '?' ;\n else output ( fp , name , tstflags ( uval ) ) ;\n break ;\n default : fprintf ( stderr , \"Internal error in cookedprint, %s=%s, fmt %d\\n\" , name , value , fmt ) ;\n output_raw = '?' ;\n break ;\n }\n if ( output_raw != 0 ) {\n atoascii ( name , MAXVARLEN , bn , sizeof ( bn ) ) ;\n atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ;\n if ( output_raw != '*' ) {\n len = strlen ( bv ) ;\n bv [ len ] = output_raw ;\n bv [ len + 1 ] = '\\0' ;\n }\n output ( fp , bn , bv ) ;\n }\n }\n endoutput ( fp ) ;\n }",
        "hash": -341028540041678099,
        "project": "debian",
        "size": 88,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void cookedprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) {\n"
                ],
                [
                    18,
                    " while ( nextvar ( & length , & data , & name , & value ) ) {\n"
                ],
                [
                    24,
                    " case TS : if ( ! decodets ( value , & lfp ) ) output_raw = '?' ;\n"
                ],
                [
                    27,
                    " case HA : case NA : if ( ! decodenetnum ( value , & hval ) ) {\n"
                ],
                [
                    37,
                    " case RF : if ( decodenetnum ( value , & hval ) ) {\n"
                ],
                [
                    41,
                    " else if ( strlen ( value ) <= 4 ) {\n"
                ],
                [
                    42,
                    " output ( fp , name , value ) ;\n"
                ],
                [
                    45,
                    " output_raw = '?' ;\n"
                ],
                [
                    48,
                    " case LP : if ( ! decodeuint ( value , & uval ) || uval > 3 ) {\n"
                ],
                [
                    58,
                    " case OC : if ( ! decodeuint ( value , & uval ) ) {\n"
                ],
                [
                    66,
                    " case AR : if ( ! decodearr ( value , & narr , lfparr ) ) output_raw = '?' ;\n"
                ],
                [
                    69,
                    " case FX : if ( ! decodeuint ( value , & uval ) ) output_raw = '?' ;\n"
                ],
                [
                    72,
                    " default : fprintf ( stderr , \"Internal error in cookedprint, %s=%s, fmt %d\\n\" , name , value , fmt ) ;\n"
                ],
                [
                    78,
                    " atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ;\n"
                ],
                [
                    79,
                    " if ( output_raw != '*' ) {\n"
                ],
                [
                    80,
                    " len = strlen ( bv ) ;\n"
                ],
                [
                    81,
                    " bv [ len ] = output_raw ;\n"
                ],
                [
                    82,
                    " bv [ len + 1 ] = '\\0' ;\n"
                ],
                [
                    84,
                    " output ( fp , bn , bv ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void cookedprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) {\n"
                ],
                [
                    16,
                    " if ( ! quiet ) fprintf ( fp , \"status=%04x %s,\\n\" , status , statustoa ( datatype , status ) ) ;\n"
                ],
                [
                    18,
                    " while ( nextvar ( & length , & data , & name , & value ) ) {\n"
                ],
                [
                    19,
                    " fmt = varfmt ( name ) ;\n"
                ],
                [
                    21,
                    " switch ( fmt ) {\n"
                ],
                [
                    24,
                    " case TS : if ( ! decodets ( value , & lfp ) ) output_raw = '?' ;\n"
                ],
                [
                    25,
                    " else output ( fp , name , prettydate ( & lfp ) ) ;\n"
                ],
                [
                    27,
                    " case HA : case NA : if ( ! decodenetnum ( value , & hval ) ) {\n"
                ],
                [
                    31,
                    " output ( fp , name , nntohost ( & hval ) ) ;\n"
                ],
                [
                    34,
                    " output ( fp , name , stoa ( & hval ) ) ;\n"
                ],
                [
                    37,
                    " case RF : if ( decodenetnum ( value , & hval ) ) {\n"
                ],
                [
                    38,
                    " if ( ISREFCLOCKADR ( & hval ) ) output ( fp , name , refnumtoa ( & hval ) ) ;\n"
                ],
                [
                    39,
                    " else output ( fp , name , stoa ( & hval ) ) ;\n"
                ],
                [
                    41,
                    " else if ( strlen ( value ) <= 4 ) {\n"
                ],
                [
                    42,
                    " output ( fp , name , value ) ;\n"
                ],
                [
                    48,
                    " case LP : if ( ! decodeuint ( value , & uval ) || uval > 3 ) {\n"
                ],
                [
                    55,
                    " output ( fp , name , b ) ;\n"
                ],
                [
                    58,
                    " case OC : if ( ! decodeuint ( value , & uval ) ) {\n"
                ],
                [
                    63,
                    " output ( fp , name , b ) ;\n"
                ],
                [
                    66,
                    " case AR : if ( ! decodearr ( value , & narr , lfparr ) ) output_raw = '?' ;\n"
                ],
                [
                    67,
                    " else outputarr ( fp , name , narr , lfparr ) ;\n"
                ],
                [
                    69,
                    " case FX : if ( ! decodeuint ( value , & uval ) ) output_raw = '?' ;\n"
                ],
                [
                    70,
                    " else output ( fp , name , tstflags ( uval ) ) ;\n"
                ],
                [
                    72,
                    " default : fprintf ( stderr , \"Internal error in cookedprint, %s=%s, fmt %d\\n\" , name , value , fmt ) ;\n"
                ],
                [
                    77,
                    " atoascii ( name , MAXVARLEN , bn , sizeof ( bn ) ) ;\n"
                ],
                [
                    78,
                    " atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ;\n"
                ],
                [
                    84,
                    " output ( fp , bn , bv ) ;\n"
                ],
                [
                    87,
                    " endoutput ( fp ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void cookedprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) {\n"
                ],
                [
                    16,
                    " if ( ! quiet ) fprintf ( fp , \"status=%04x %s,\\n\" , status , statustoa ( datatype , status ) ) ;\n"
                ],
                [
                    18,
                    " while ( nextvar ( & length , & data , & name , & value ) ) {\n"
                ],
                [
                    19,
                    " fmt = varfmt ( name ) ;\n"
                ],
                [
                    21,
                    " switch ( fmt ) {\n"
                ],
                [
                    24,
                    " case TS : if ( ! decodets ( value , & lfp ) ) output_raw = '?' ;\n"
                ],
                [
                    25,
                    " else output ( fp , name , prettydate ( & lfp ) ) ;\n"
                ],
                [
                    27,
                    " case HA : case NA : if ( ! decodenetnum ( value , & hval ) ) {\n"
                ],
                [
                    31,
                    " output ( fp , name , nntohost ( & hval ) ) ;\n"
                ],
                [
                    34,
                    " output ( fp , name , stoa ( & hval ) ) ;\n"
                ],
                [
                    37,
                    " case RF : if ( decodenetnum ( value , & hval ) ) {\n"
                ],
                [
                    38,
                    " if ( ISREFCLOCKADR ( & hval ) ) output ( fp , name , refnumtoa ( & hval ) ) ;\n"
                ],
                [
                    39,
                    " else output ( fp , name , stoa ( & hval ) ) ;\n"
                ],
                [
                    41,
                    " else if ( strlen ( value ) <= 4 ) {\n"
                ],
                [
                    42,
                    " output ( fp , name , value ) ;\n"
                ],
                [
                    45,
                    " output_raw = '?' ;\n"
                ],
                [
                    48,
                    " case LP : if ( ! decodeuint ( value , & uval ) || uval > 3 ) {\n"
                ],
                [
                    55,
                    " output ( fp , name , b ) ;\n"
                ],
                [
                    58,
                    " case OC : if ( ! decodeuint ( value , & uval ) ) {\n"
                ],
                [
                    63,
                    " output ( fp , name , b ) ;\n"
                ],
                [
                    66,
                    " case AR : if ( ! decodearr ( value , & narr , lfparr ) ) output_raw = '?' ;\n"
                ],
                [
                    67,
                    " else outputarr ( fp , name , narr , lfparr ) ;\n"
                ],
                [
                    69,
                    " case FX : if ( ! decodeuint ( value , & uval ) ) output_raw = '?' ;\n"
                ],
                [
                    70,
                    " else output ( fp , name , tstflags ( uval ) ) ;\n"
                ],
                [
                    72,
                    " default : fprintf ( stderr , \"Internal error in cookedprint, %s=%s, fmt %d\\n\" , name , value , fmt ) ;\n"
                ],
                [
                    77,
                    " atoascii ( name , MAXVARLEN , bn , sizeof ( bn ) ) ;\n"
                ],
                [
                    78,
                    " atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ;\n"
                ],
                [
                    79,
                    " if ( output_raw != '*' ) {\n"
                ],
                [
                    80,
                    " len = strlen ( bv ) ;\n"
                ],
                [
                    81,
                    " bv [ len ] = output_raw ;\n"
                ],
                [
                    82,
                    " bv [ len + 1 ] = '\\0' ;\n"
                ],
                [
                    84,
                    " output ( fp , bn , bv ) ;\n"
                ],
                [
                    87,
                    " endoutput ( fp ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void pdo_stmt_init ( TSRMLS_D ) {\n zend_class_entry ce ;\n INIT_CLASS_ENTRY ( ce , \"PDOStatement\" , pdo_dbstmt_functions ) ;\n pdo_dbstmt_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ;\n pdo_dbstmt_ce -> get_iterator = pdo_stmt_iter_get ;\n pdo_dbstmt_ce -> create_object = pdo_dbstmt_new ;\n zend_class_implements ( pdo_dbstmt_ce TSRMLS_CC , 1 , zend_ce_traversable ) ;\n zend_declare_property_null ( pdo_dbstmt_ce , \"queryString\" , sizeof ( \"queryString\" ) - 1 , ZEND_ACC_PUBLIC TSRMLS_CC ) ;\n memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ;\n pdo_dbstmt_object_handlers . write_property = dbstmt_prop_write ;\n pdo_dbstmt_object_handlers . unset_property = dbstmt_prop_delete ;\n pdo_dbstmt_object_handlers . get_method = dbstmt_method_get ;\n pdo_dbstmt_object_handlers . compare_objects = dbstmt_compare ;\n pdo_dbstmt_object_handlers . clone_obj = dbstmt_clone_obj ;\n INIT_CLASS_ENTRY ( ce , \"PDORow\" , pdo_row_functions ) ;\n pdo_row_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ;\n pdo_row_ce -> ce_flags |= ZEND_ACC_FINAL_CLASS ;\n pdo_row_ce -> create_object = pdo_row_new ;\n pdo_row_ce -> serialize = pdo_row_serialize ;\n }",
        "hash": 7399683071036018868,
        "project": "debian",
        "size": 20,
        "slice": {
            "memcpy": [
                [
                    1,
                    "void pdo_stmt_init ( TSRMLS_D ) {\n"
                ],
                [
                    9,
                    " memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void pdo_stmt_init ( TSRMLS_D ) {\n"
                ],
                [
                    9,
                    " memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static bfd_boolean srec_scan ( bfd * abfd ) {\n int c ;\n unsigned int lineno = 1 ;\n bfd_boolean error = FALSE ;\n bfd_byte * buf = NULL ;\n size_t bufsize = 0 ;\n asection * sec = NULL ;\n char * symbuf = NULL ;\n if ( bfd_seek ( abfd , ( file_ptr ) 0 , SEEK_SET ) != 0 ) goto error_return ;\n while ( ( c = srec_get_byte ( abfd , & error ) ) != EOF ) {\n if ( c != 'S' && c != '\\r' && c != '\\n' ) sec = NULL ;\n switch ( c ) {\n default : srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n case '\\n' : ++ lineno ;\n break ;\n case '\\r' : break ;\n case '$' : while ( ( c = srec_get_byte ( abfd , & error ) ) != '\\n' && c != EOF ) ;\n if ( c == EOF ) {\n srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n }\n ++ lineno ;\n break ;\n case ' ' : do {\n bfd_size_type alc ;\n char * p , * symname ;\n bfd_vma symval ;\n while ( ( c = srec_get_byte ( abfd , & error ) ) != EOF && ( c == ' ' || c == '\\t' ) ) ;\n if ( c == '\\n' || c == '\\r' ) break ;\n if ( c == EOF ) {\n srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n }\n alc = 10 ;\n symbuf = ( char * ) bfd_malloc ( alc + 1 ) ;\n if ( symbuf == NULL ) goto error_return ;\n p = symbuf ;\n * p ++ = c ;\n while ( ( c = srec_get_byte ( abfd , & error ) ) != EOF && ! ISSPACE ( c ) ) {\n if ( ( bfd_size_type ) ( p - symbuf ) >= alc ) {\n char * n ;\n alc *= 2 ;\n n = ( char * ) bfd_realloc ( symbuf , alc + 1 ) ;\n if ( n == NULL ) goto error_return ;\n p = n + ( p - symbuf ) ;\n symbuf = n ;\n }\n * p ++ = c ;\n }\n if ( c == EOF ) {\n srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n }\n * p ++ = '\\0' ;\n symname = ( char * ) bfd_alloc ( abfd , ( bfd_size_type ) ( p - symbuf ) ) ;\n if ( symname == NULL ) goto error_return ;\n strcpy ( symname , symbuf ) ;\n free ( symbuf ) ;\n symbuf = NULL ;\n while ( ( c = srec_get_byte ( abfd , & error ) ) != EOF && ( c == ' ' || c == '\\t' ) ) ;\n if ( c == EOF ) {\n srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n }\n if ( c == '$' ) {\n c = srec_get_byte ( abfd , & error ) ;\n if ( c == EOF ) {\n srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n }\n }\n symval = 0 ;\n while ( ISHEX ( c ) ) {\n symval <<= 4 ;\n symval += NIBBLE ( c ) ;\n c = srec_get_byte ( abfd , & error ) ;\n if ( c == EOF ) {\n srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n }\n }\n if ( ! srec_new_symbol ( abfd , symname , symval ) ) goto error_return ;\n }\n while ( c == ' ' || c == '\\t' ) ;\n if ( c == '\\n' ) ++ lineno ;\n else if ( c != '\\r' ) {\n srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n }\n break ;\n case 'S' : {\n file_ptr pos ;\n char hdr [ 3 ] ;\n unsigned int bytes ;\n bfd_vma address ;\n bfd_byte * data ;\n unsigned char check_sum ;\n pos = bfd_tell ( abfd ) - 1 ;\n if ( bfd_bread ( hdr , ( bfd_size_type ) 3 , abfd ) != 3 ) goto error_return ;\n if ( ! ISHEX ( hdr [ 1 ] ) || ! ISHEX ( hdr [ 2 ] ) ) {\n if ( ! ISHEX ( hdr [ 1 ] ) ) c = hdr [ 1 ] ;\n else c = hdr [ 2 ] ;\n srec_bad_byte ( abfd , lineno , c , error ) ;\n goto error_return ;\n }\n check_sum = bytes = HEX ( hdr + 1 ) ;\n if ( bytes * 2 > bufsize ) {\n if ( buf != NULL ) free ( buf ) ;\n buf = ( bfd_byte * ) bfd_malloc ( ( bfd_size_type ) bytes * 2 ) ;\n if ( buf == NULL ) goto error_return ;\n bufsize = bytes * 2 ;\n }\n if ( bytes == 0 || bfd_bread ( buf , ( bfd_size_type ) bytes * 2 , abfd ) != bytes * 2 ) goto error_return ;\n -- bytes ;\n address = 0 ;\n data = buf ;\n switch ( hdr [ 0 ] ) {\n case '0' : case '5' : sec = NULL ;\n break ;\n case '3' : check_sum += HEX ( data ) ;\n address = HEX ( data ) ;\n data += 2 ;\n -- bytes ;\n case '2' : check_sum += HEX ( data ) ;\n address = ( address << 8 ) | HEX ( data ) ;\n data += 2 ;\n -- bytes ;\n case '1' : check_sum += HEX ( data ) ;\n address = ( address << 8 ) | HEX ( data ) ;\n data += 2 ;\n check_sum += HEX ( data ) ;\n address = ( address << 8 ) | HEX ( data ) ;\n data += 2 ;\n bytes -= 2 ;\n if ( sec != NULL && sec -> vma + sec -> size == address ) {\n sec -> size += bytes ;\n }\n else {\n char secbuf [ 20 ] ;\n char * secname ;\n bfd_size_type amt ;\n flagword flags ;\n sprintf ( secbuf , \".sec%d\" , bfd_count_sections ( abfd ) + 1 ) ;\n amt = strlen ( secbuf ) + 1 ;\n secname = ( char * ) bfd_alloc ( abfd , amt ) ;\n strcpy ( secname , secbuf ) ;\n flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC ;\n sec = bfd_make_section_with_flags ( abfd , secname , flags ) ;\n if ( sec == NULL ) goto error_return ;\n sec -> vma = address ;\n sec -> lma = address ;\n sec -> size = bytes ;\n sec -> filepos = pos ;\n }\n while ( bytes > 0 ) {\n check_sum += HEX ( data ) ;\n data += 2 ;\n bytes -- ;\n }\n check_sum = 255 - ( check_sum & 0xff ) ;\n if ( check_sum != HEX ( data ) ) {\n ( * _bfd_error_handler ) ( _ ( \"%B:%d: Bad checksum in S-record file\\n\" ) , abfd , lineno ) ;\n bfd_set_error ( bfd_error_bad_value ) ;\n goto error_return ;\n }\n break ;\n case '7' : check_sum += HEX ( data ) ;\n address = HEX ( data ) ;\n data += 2 ;\n case '8' : check_sum += HEX ( data ) ;\n address = ( address << 8 ) | HEX ( data ) ;\n data += 2 ;\n case '9' : check_sum += HEX ( data ) ;\n address = ( address << 8 ) | HEX ( data ) ;\n data += 2 ;\n check_sum += HEX ( data ) ;\n address = ( address << 8 ) | HEX ( data ) ;\n data += 2 ;\n abfd -> start_address = address ;\n check_sum = 255 - ( check_sum & 0xff ) ;\n if ( check_sum != HEX ( data ) ) {\n ( * _bfd_error_handler ) ( _ ( \"%B:%d: Bad checksum in S-record file\\n\" ) , abfd , lineno ) ;\n bfd_set_error ( bfd_error_bad_value ) ;\n goto error_return ;\n }\n if ( buf != NULL ) free ( buf ) ;\n return TRUE ;\n }\n }\n break ;\n }\n }\n if ( error ) goto error_return ;\n if ( buf != NULL ) free ( buf ) ;\n return TRUE ;\n error_return : if ( symbuf != NULL ) free ( symbuf ) ;\n if ( buf != NULL ) free ( buf ) ;\n return FALSE ;\n }",
        "hash": -8638406710431929037,
        "project": "debian",
        "size": 200,
        "slice": {
            "strlen": [
                [
                    1,
                    "static bfd_boolean srec_scan ( bfd * abfd ) {\n"
                ],
                [
                    136,
                    " if ( sec != NULL && sec -> vma + sec -> size == address ) {\n"
                ],
                [
                    144,
                    " sprintf ( secbuf , \".sec%d\" , bfd_count_sections ( abfd ) + 1 ) ;\n"
                ],
                [
                    145,
                    " amt = strlen ( secbuf ) + 1 ;\n"
                ],
                [
                    146,
                    " secname = ( char * ) bfd_alloc ( abfd , amt ) ;\n"
                ],
                [
                    147,
                    " strcpy ( secname , secbuf ) ;\n"
                ]
            ],
            "sprintf": [
                [
                    1,
                    "static bfd_boolean srec_scan ( bfd * abfd ) {\n"
                ],
                [
                    136,
                    " if ( sec != NULL && sec -> vma + sec -> size == address ) {\n"
                ],
                [
                    140,
                    " char secbuf [ 20 ] ;\n"
                ],
                [
                    144,
                    " sprintf ( secbuf , \".sec%d\" , bfd_count_sections ( abfd ) + 1 ) ;\n"
                ],
                [
                    145,
                    " amt = strlen ( secbuf ) + 1 ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static bfd_boolean srec_scan ( bfd * abfd ) {\n"
                ],
                [
                    57,
                    " if ( symname == NULL ) goto error_return ;\n"
                ],
                [
                    58,
                    " strcpy ( symname , symbuf ) ;\n"
                ],
                [
                    59,
                    " free ( symbuf ) ;\n"
                ],
                [
                    109,
                    " if ( buf != NULL ) free ( buf ) ;\n"
                ],
                [
                    187,
                    " if ( buf != NULL ) free ( buf ) ;\n"
                ],
                [
                    195,
                    " if ( buf != NULL ) free ( buf ) ;\n"
                ],
                [
                    197,
                    " error_return : if ( symbuf != NULL ) free ( symbuf ) ;\n"
                ],
                [
                    198,
                    " if ( buf != NULL ) free ( buf ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static bfd_boolean srec_scan ( bfd * abfd ) {\n"
                ],
                [
                    57,
                    " if ( symname == NULL ) goto error_return ;\n"
                ],
                [
                    58,
                    " strcpy ( symname , symbuf ) ;\n"
                ],
                [
                    59,
                    " free ( symbuf ) ;\n"
                ],
                [
                    109,
                    " if ( buf != NULL ) free ( buf ) ;\n"
                ],
                [
                    136,
                    " if ( sec != NULL && sec -> vma + sec -> size == address ) {\n"
                ],
                [
                    140,
                    " char secbuf [ 20 ] ;\n"
                ],
                [
                    144,
                    " sprintf ( secbuf , \".sec%d\" , bfd_count_sections ( abfd ) + 1 ) ;\n"
                ],
                [
                    145,
                    " amt = strlen ( secbuf ) + 1 ;\n"
                ],
                [
                    146,
                    " secname = ( char * ) bfd_alloc ( abfd , amt ) ;\n"
                ],
                [
                    147,
                    " strcpy ( secname , secbuf ) ;\n"
                ],
                [
                    187,
                    " if ( buf != NULL ) free ( buf ) ;\n"
                ],
                [
                    195,
                    " if ( buf != NULL ) free ( buf ) ;\n"
                ],
                [
                    197,
                    " error_return : if ( symbuf != NULL ) free ( symbuf ) ;\n"
                ],
                [
                    198,
                    " if ( buf != NULL ) free ( buf ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "PyObject * PyString_DecodeEscape ( const char * s , Py_ssize_t len , const char * errors , Py_ssize_t unicode , const char * recode_encoding ) {\n int c ;\n char * p , * buf ;\n const char * end ;\n PyObject * v ;\n Py_ssize_t newlen = recode_encoding ? 4 * len : len ;\n v = PyString_FromStringAndSize ( ( char * ) NULL , newlen ) ;\n if ( v == NULL ) return NULL ;\n p = buf = PyString_AsString ( v ) ;\n end = s + len ;\n while ( s < end ) {\n if ( * s != '\\\\' ) {\n non_esc : # ifdef Py_USING_UNICODE if ( recode_encoding && ( * s & 0x80 ) ) {\n PyObject * u , * w ;\n char * r ;\n const char * t ;\n Py_ssize_t rn ;\n t = s ;\n while ( t < end && ( * t & 0x80 ) ) t ++ ;\n u = PyUnicode_DecodeUTF8 ( s , t - s , errors ) ;\n if ( ! u ) goto failed ;\n w = PyUnicode_AsEncodedString ( u , recode_encoding , errors ) ;\n Py_DECREF ( u ) ;\n if ( ! w ) goto failed ;\n assert ( PyString_Check ( w ) ) ;\n r = PyString_AS_STRING ( w ) ;\n rn = PyString_GET_SIZE ( w ) ;\n Py_MEMCPY ( p , r , rn ) ;\n p += rn ;\n Py_DECREF ( w ) ;\n s = t ;\n }\n else {\n * p ++ = * s ++ ;\n }\n # else * p ++ = * s ++ ;\n # endif continue ;\n }\n s ++ ;\n if ( s == end ) {\n PyErr_SetString ( PyExc_ValueError , \"Trailing \\\\ in string\" ) ;\n goto failed ;\n }\n switch ( * s ++ ) {\n case '\\n' : break ;\n case '\\\\' : * p ++ = '\\\\' ;\n break ;\n case '\\'' : * p ++ = '\\'' ;\n break ;\n case '\\\"' : * p ++ = '\\\"' ;\n break ;\n case 'b' : * p ++ = '\\b' ;\n break ;\n case 'f' : * p ++ = '\\014' ;\n break ;\n case 't' : * p ++ = '\\t' ;\n break ;\n case 'n' : * p ++ = '\\n' ;\n break ;\n case 'r' : * p ++ = '\\r' ;\n break ;\n case 'v' : * p ++ = '\\013' ;\n break ;\n case 'a' : * p ++ = '\\007' ;\n break ;\n case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : c = s [ - 1 ] - '0' ;\n if ( s < end && '0' <= * s && * s <= '7' ) {\n c = ( c << 3 ) + * s ++ - '0' ;\n if ( s < end && '0' <= * s && * s <= '7' ) c = ( c << 3 ) + * s ++ - '0' ;\n }\n * p ++ = c ;\n break ;\n case 'x' : if ( s + 1 < end && isxdigit ( Py_CHARMASK ( s [ 0 ] ) ) && isxdigit ( Py_CHARMASK ( s [ 1 ] ) ) ) {\n unsigned int x = 0 ;\n c = Py_CHARMASK ( * s ) ;\n s ++ ;\n if ( isdigit ( c ) ) x = c - '0' ;\n else if ( islower ( c ) ) x = 10 + c - 'a' ;\n else x = 10 + c - 'A' ;\n x = x << 4 ;\n c = Py_CHARMASK ( * s ) ;\n s ++ ;\n if ( isdigit ( c ) ) x += c - '0' ;\n else if ( islower ( c ) ) x += 10 + c - 'a' ;\n else x += 10 + c - 'A' ;\n * p ++ = x ;\n break ;\n }\n if ( ! errors || strcmp ( errors , \"strict\" ) == 0 ) {\n PyErr_SetString ( PyExc_ValueError , \"invalid \\\\x escape\" ) ;\n goto failed ;\n }\n if ( strcmp ( errors , \"replace\" ) == 0 ) {\n * p ++ = '?' ;\n }\n else if ( strcmp ( errors , \"ignore\" ) == 0 ) ;\n else {\n PyErr_Format ( PyExc_ValueError , \"decoding error;\n \" \"unknown error handling code: %.400s\" , errors ) ;\n goto failed ;\n }\n if ( s < end && isxdigit ( Py_CHARMASK ( s [ 0 ] ) ) ) s ++ ;\n break ;\n # ifndef Py_USING_UNICODE case 'u' : case 'U' : case 'N' : if ( unicode ) {\n PyErr_SetString ( PyExc_ValueError , \"Unicode escapes not legal \" \"when Unicode disabled\" ) ;\n goto failed ;\n }\n # endif default : * p ++ = '\\\\' ;\n s -- ;\n goto non_esc ;\n }\n }\n if ( p - buf < newlen ) _PyString_Resize ( & v , p - buf ) ;\n return v ;\n failed : Py_DECREF ( v ) ;\n return NULL ;\n }",
        "hash": -4555950263653671147,
        "project": "debian",
        "size": 117,
        "slice": {
            "strcmp": [
                [
                    1,
                    "PyObject * PyString_DecodeEscape ( const char * s , Py_ssize_t len , const char * errors , Py_ssize_t unicode , const char * recode_encoding ) {\n"
                ],
                [
                    89,
                    " if ( ! errors || strcmp ( errors , \"strict\" ) == 0 ) {\n"
                ],
                [
                    93,
                    " if ( strcmp ( errors , \"replace\" ) == 0 ) {\n"
                ],
                [
                    96,
                    " else if ( strcmp ( errors , \"ignore\" ) == 0 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "PyObject * PyString_DecodeEscape ( const char * s , Py_ssize_t len , const char * errors , Py_ssize_t unicode , const char * recode_encoding ) {\n"
                ],
                [
                    89,
                    " if ( ! errors || strcmp ( errors , \"strict\" ) == 0 ) {\n"
                ],
                [
                    93,
                    " if ( strcmp ( errors , \"replace\" ) == 0 ) {\n"
                ],
                [
                    96,
                    " else if ( strcmp ( errors , \"ignore\" ) == 0 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void IGDstartelt ( void * d , const char * name , int l ) {\n struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n memcpy ( datas -> cureltname , name , l ) ;\n datas -> cureltname [ l ] = '\\0' ;\n datas -> level ++ ;\n if ( ( l == 7 ) && ! memcmp ( name , \"service\" , l ) ) {\n datas -> tmp . controlurl [ 0 ] = '\\0' ;\n datas -> tmp . eventsuburl [ 0 ] = '\\0' ;\n datas -> tmp . scpdurl [ 0 ] = '\\0' ;\n datas -> tmp . servicetype [ 0 ] = '\\0' ;\n }\n }",
        "hash": 4198675434481816937,
        "project": "debian",
        "size": 12,
        "slice": {
            "memcpy": [
                [
                    1,
                    "void IGDstartelt ( void * d , const char * name , int l ) {\n"
                ],
                [
                    2,
                    " struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n"
                ],
                [
                    3,
                    " memcpy ( datas -> cureltname , name , l ) ;\n"
                ],
                [
                    6,
                    " if ( ( l == 7 ) && ! memcmp ( name , \"service\" , l ) ) {\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "void IGDstartelt ( void * d , const char * name , int l ) {\n"
                ],
                [
                    3,
                    " memcpy ( datas -> cureltname , name , l ) ;\n"
                ],
                [
                    6,
                    " if ( ( l == 7 ) && ! memcmp ( name , \"service\" , l ) ) {\n"
                ],
                [
                    7,
                    " datas -> tmp . controlurl [ 0 ] = '\\0' ;\n"
                ],
                [
                    8,
                    " datas -> tmp . eventsuburl [ 0 ] = '\\0' ;\n"
                ],
                [
                    9,
                    " datas -> tmp . scpdurl [ 0 ] = '\\0' ;\n"
                ],
                [
                    10,
                    " datas -> tmp . servicetype [ 0 ] = '\\0' ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void IGDstartelt ( void * d , const char * name , int l ) {\n"
                ],
                [
                    2,
                    " struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n"
                ],
                [
                    3,
                    " memcpy ( datas -> cureltname , name , l ) ;\n"
                ],
                [
                    6,
                    " if ( ( l == 7 ) && ! memcmp ( name , \"service\" , l ) ) {\n"
                ],
                [
                    7,
                    " datas -> tmp . controlurl [ 0 ] = '\\0' ;\n"
                ],
                [
                    8,
                    " datas -> tmp . eventsuburl [ 0 ] = '\\0' ;\n"
                ],
                [
                    9,
                    " datas -> tmp . scpdurl [ 0 ] = '\\0' ;\n"
                ],
                [
                    10,
                    " datas -> tmp . servicetype [ 0 ] = '\\0' ;\n"
                ]
            ]
        }
    },
    {
        "code": "kadm5_ret_t kadm5_create_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n kadm5_server_handle_t handle = server_handle ;\n osa_policy_ent_rec pent ;\n int ret ;\n char * p ;\n CHECK_HANDLE ( server_handle ) ;\n if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n if ( ! ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n if ( ( mask & KADM5_POLICY_ALLOWED_KEYSALTS ) && entry -> allowed_keysalts != NULL ) {\n ret = validate_allowed_keysalts ( entry -> allowed_keysalts ) ;\n if ( ret ) return ret ;\n }\n memset ( & pent , 0 , sizeof ( pent ) ) ;\n pent . name = entry -> policy ;\n p = entry -> policy ;\n while ( * p != '\\0' ) {\n if ( * p < ' ' || * p > '~' ) return KADM5_BAD_POLICY ;\n else p ++ ;\n }\n if ( ! ( mask & KADM5_PW_MAX_LIFE ) ) pent . pw_max_life = 0 ;\n else pent . pw_max_life = entry -> pw_max_life ;\n if ( ! ( mask & KADM5_PW_MIN_LIFE ) ) pent . pw_min_life = 0 ;\n else {\n if ( ( mask & KADM5_PW_MAX_LIFE ) ) {\n if ( entry -> pw_min_life > entry -> pw_max_life && entry -> pw_max_life != 0 ) return KADM5_BAD_MIN_PASS_LIFE ;\n }\n pent . pw_min_life = entry -> pw_min_life ;\n }\n if ( ! ( mask & KADM5_PW_MIN_LENGTH ) ) pent . pw_min_length = MIN_PW_LENGTH ;\n else {\n if ( entry -> pw_min_length < MIN_PW_LENGTH ) return KADM5_BAD_LENGTH ;\n pent . pw_min_length = entry -> pw_min_length ;\n }\n if ( ! ( mask & KADM5_PW_MIN_CLASSES ) ) pent . pw_min_classes = MIN_PW_CLASSES ;\n else {\n if ( entry -> pw_min_classes > MAX_PW_CLASSES || entry -> pw_min_classes < MIN_PW_CLASSES ) return KADM5_BAD_CLASS ;\n pent . pw_min_classes = entry -> pw_min_classes ;\n }\n if ( ! ( mask & KADM5_PW_HISTORY_NUM ) ) pent . pw_history_num = MIN_PW_HISTORY ;\n else {\n if ( entry -> pw_history_num < MIN_PW_HISTORY ) return KADM5_BAD_HISTORY ;\n else pent . pw_history_num = entry -> pw_history_num ;\n }\n if ( ! ( mask & KADM5_REF_COUNT ) ) pent . policy_refcnt = 0 ;\n else pent . policy_refcnt = entry -> policy_refcnt ;\n if ( handle -> api_version >= KADM5_API_VERSION_4 ) {\n if ( ! ( mask & KADM5_POLICY_ATTRIBUTES ) ) pent . attributes = 0 ;\n else pent . attributes = entry -> attributes ;\n if ( ! ( mask & KADM5_POLICY_MAX_LIFE ) ) pent . max_life = 0 ;\n else pent . max_life = entry -> max_life ;\n if ( ! ( mask & KADM5_POLICY_MAX_RLIFE ) ) pent . max_renewable_life = 0 ;\n else pent . max_renewable_life = entry -> max_renewable_life ;\n if ( ! ( mask & KADM5_POLICY_ALLOWED_KEYSALTS ) ) pent . allowed_keysalts = 0 ;\n else pent . allowed_keysalts = entry -> allowed_keysalts ;\n if ( ! ( mask & KADM5_POLICY_TL_DATA ) ) {\n pent . n_tl_data = 0 ;\n pent . tl_data = NULL ;\n }\n else {\n pent . n_tl_data = entry -> n_tl_data ;\n pent . tl_data = entry -> tl_data ;\n }\n }\n if ( handle -> api_version >= KADM5_API_VERSION_3 ) {\n if ( ! ( mask & KADM5_PW_MAX_FAILURE ) ) pent . pw_max_fail = 0 ;\n else pent . pw_max_fail = entry -> pw_max_fail ;\n if ( ! ( mask & KADM5_PW_FAILURE_COUNT_INTERVAL ) ) pent . pw_failcnt_interval = 0 ;\n else pent . pw_failcnt_interval = entry -> pw_failcnt_interval ;\n if ( ! ( mask & KADM5_PW_LOCKOUT_DURATION ) ) pent . pw_lockout_duration = 0 ;\n else pent . pw_lockout_duration = entry -> pw_lockout_duration ;\n }\n if ( ( ret = krb5_db_create_policy ( handle -> context , & pent ) ) ) return ret ;\n else return KADM5_OK ;\n }",
        "hash": -6986708248145981986,
        "project": "debian",
        "size": 75,
        "slice": {
            "memset": [
                [
                    1,
                    "kadm5_ret_t kadm5_create_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n"
                ],
                [
                    10,
                    " if ( ( mask & KADM5_POLICY_ALLOWED_KEYSALTS ) && entry -> allowed_keysalts != NULL ) {\n"
                ],
                [
                    12,
                    " if ( ret ) return ret ;\n"
                ],
                [
                    14,
                    " memset ( & pent , 0 , sizeof ( pent ) ) ;\n"
                ],
                [
                    73,
                    " if ( ( ret = krb5_db_create_policy ( handle -> context , & pent ) ) ) return ret ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "kadm5_ret_t kadm5_create_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n"
                ],
                [
                    7,
                    " if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n"
                ],
                [
                    8,
                    " if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n"
                ],
                [
                    9,
                    " if ( ! ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n"
                ],
                [
                    15,
                    " pent . name = entry -> policy ;\n"
                ],
                [
                    16,
                    " p = entry -> policy ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "kadm5_ret_t kadm5_create_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n"
                ],
                [
                    7,
                    " if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n"
                ],
                [
                    8,
                    " if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n"
                ],
                [
                    9,
                    " if ( ! ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n"
                ],
                [
                    10,
                    " if ( ( mask & KADM5_POLICY_ALLOWED_KEYSALTS ) && entry -> allowed_keysalts != NULL ) {\n"
                ],
                [
                    12,
                    " if ( ret ) return ret ;\n"
                ],
                [
                    14,
                    " memset ( & pent , 0 , sizeof ( pent ) ) ;\n"
                ],
                [
                    15,
                    " pent . name = entry -> policy ;\n"
                ],
                [
                    16,
                    " p = entry -> policy ;\n"
                ],
                [
                    73,
                    " if ( ( ret = krb5_db_create_policy ( handle -> context , & pent ) ) ) return ret ;\n"
                ]
            ]
        }
    },
    {
        "code": "kadm5_ret_t kadm5_get_policy ( void * server_handle , kadm5_policy_t name , kadm5_policy_ent_t entry ) {\n osa_policy_ent_t t ;\n kadm5_ret_t ret ;\n kadm5_server_handle_t handle = server_handle ;\n memset ( entry , 0 , sizeof ( * entry ) ) ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n ret = krb5_db_get_policy ( handle -> context , name , & t ) ;\n if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n else if ( ret ) return ret ;\n if ( ( entry -> policy = strdup ( t -> name ) ) == NULL ) {\n ret = ENOMEM ;\n goto cleanup ;\n }\n entry -> pw_min_life = t -> pw_min_life ;\n entry -> pw_max_life = t -> pw_max_life ;\n entry -> pw_min_length = t -> pw_min_length ;\n entry -> pw_min_classes = t -> pw_min_classes ;\n entry -> pw_history_num = t -> pw_history_num ;\n entry -> policy_refcnt = t -> policy_refcnt ;\n if ( handle -> api_version >= KADM5_API_VERSION_3 ) {\n entry -> pw_max_fail = t -> pw_max_fail ;\n entry -> pw_failcnt_interval = t -> pw_failcnt_interval ;\n entry -> pw_lockout_duration = t -> pw_lockout_duration ;\n }\n if ( handle -> api_version >= KADM5_API_VERSION_4 ) {\n entry -> attributes = t -> attributes ;\n entry -> max_life = t -> max_life ;\n entry -> max_renewable_life = t -> max_renewable_life ;\n if ( t -> allowed_keysalts ) {\n entry -> allowed_keysalts = strdup ( t -> allowed_keysalts ) ;\n if ( ! entry -> allowed_keysalts ) {\n ret = ENOMEM ;\n goto cleanup ;\n }\n }\n ret = copy_tl_data ( t -> n_tl_data , t -> tl_data , & entry -> tl_data ) ;\n if ( ret ) goto cleanup ;\n entry -> n_tl_data = t -> n_tl_data ;\n }\n ret = 0 ;\n cleanup : if ( ret ) kadm5_free_policy_ent ( handle , entry ) ;\n krb5_db_free_policy ( handle -> context , t ) ;\n return ret ;\n }",
        "hash": -6986708248145981986,
        "project": "debian",
        "size": 47,
        "slice": {
            "memset": [
                [
                    1,
                    "kadm5_ret_t kadm5_get_policy ( void * server_handle , kadm5_policy_t name , kadm5_policy_ent_t entry ) {\n"
                ],
                [
                    5,
                    " memset ( entry , 0 , sizeof ( * entry ) ) ;\n"
                ],
                [
                    34,
                    " if ( ! entry -> allowed_keysalts ) {\n"
                ],
                [
                    39,
                    " ret = copy_tl_data ( t -> n_tl_data , t -> tl_data , & entry -> tl_data ) ;\n"
                ],
                [
                    44,
                    " cleanup : if ( ret ) kadm5_free_policy_ent ( handle , entry ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "kadm5_ret_t kadm5_get_policy ( void * server_handle , kadm5_policy_t name , kadm5_policy_ent_t entry ) {\n"
                ],
                [
                    8,
                    " if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n"
                ],
                [
                    9,
                    " if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n"
                ],
                [
                    10,
                    " ret = krb5_db_get_policy ( handle -> context , name , & t ) ;\n"
                ],
                [
                    11,
                    " if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "kadm5_ret_t kadm5_get_policy ( void * server_handle , kadm5_policy_t name , kadm5_policy_ent_t entry ) {\n"
                ],
                [
                    12,
                    " else if ( ret ) return ret ;\n"
                ],
                [
                    13,
                    " if ( ( entry -> policy = strdup ( t -> name ) ) == NULL ) {\n"
                ],
                [
                    14,
                    " ret = ENOMEM ;\n"
                ],
                [
                    17,
                    " entry -> pw_min_life = t -> pw_min_life ;\n"
                ],
                [
                    18,
                    " entry -> pw_max_life = t -> pw_max_life ;\n"
                ],
                [
                    19,
                    " entry -> pw_min_length = t -> pw_min_length ;\n"
                ],
                [
                    20,
                    " entry -> pw_min_classes = t -> pw_min_classes ;\n"
                ],
                [
                    21,
                    " entry -> pw_history_num = t -> pw_history_num ;\n"
                ],
                [
                    22,
                    " entry -> policy_refcnt = t -> policy_refcnt ;\n"
                ],
                [
                    23,
                    " if ( handle -> api_version >= KADM5_API_VERSION_3 ) {\n"
                ],
                [
                    28,
                    " if ( handle -> api_version >= KADM5_API_VERSION_4 ) {\n"
                ],
                [
                    32,
                    " if ( t -> allowed_keysalts ) {\n"
                ],
                [
                    33,
                    " entry -> allowed_keysalts = strdup ( t -> allowed_keysalts ) ;\n"
                ],
                [
                    34,
                    " if ( ! entry -> allowed_keysalts ) {\n"
                ],
                [
                    44,
                    " cleanup : if ( ret ) kadm5_free_policy_ent ( handle , entry ) ;\n"
                ],
                [
                    45,
                    " krb5_db_free_policy ( handle -> context , t ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "kadm5_ret_t kadm5_get_policy ( void * server_handle , kadm5_policy_t name , kadm5_policy_ent_t entry ) {\n"
                ],
                [
                    5,
                    " memset ( entry , 0 , sizeof ( * entry ) ) ;\n"
                ],
                [
                    8,
                    " if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n"
                ],
                [
                    9,
                    " if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n"
                ],
                [
                    10,
                    " ret = krb5_db_get_policy ( handle -> context , name , & t ) ;\n"
                ],
                [
                    11,
                    " if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n"
                ],
                [
                    12,
                    " else if ( ret ) return ret ;\n"
                ],
                [
                    13,
                    " if ( ( entry -> policy = strdup ( t -> name ) ) == NULL ) {\n"
                ],
                [
                    14,
                    " ret = ENOMEM ;\n"
                ],
                [
                    17,
                    " entry -> pw_min_life = t -> pw_min_life ;\n"
                ],
                [
                    18,
                    " entry -> pw_max_life = t -> pw_max_life ;\n"
                ],
                [
                    19,
                    " entry -> pw_min_length = t -> pw_min_length ;\n"
                ],
                [
                    20,
                    " entry -> pw_min_classes = t -> pw_min_classes ;\n"
                ],
                [
                    21,
                    " entry -> pw_history_num = t -> pw_history_num ;\n"
                ],
                [
                    22,
                    " entry -> policy_refcnt = t -> policy_refcnt ;\n"
                ],
                [
                    23,
                    " if ( handle -> api_version >= KADM5_API_VERSION_3 ) {\n"
                ],
                [
                    28,
                    " if ( handle -> api_version >= KADM5_API_VERSION_4 ) {\n"
                ],
                [
                    32,
                    " if ( t -> allowed_keysalts ) {\n"
                ],
                [
                    33,
                    " entry -> allowed_keysalts = strdup ( t -> allowed_keysalts ) ;\n"
                ],
                [
                    34,
                    " if ( ! entry -> allowed_keysalts ) {\n"
                ],
                [
                    39,
                    " ret = copy_tl_data ( t -> n_tl_data , t -> tl_data , & entry -> tl_data ) ;\n"
                ],
                [
                    44,
                    " cleanup : if ( ret ) kadm5_free_policy_ent ( handle , entry ) ;\n"
                ],
                [
                    45,
                    " krb5_db_free_policy ( handle -> context , t ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "kadm5_ret_t kadm5_delete_policy ( void * server_handle , kadm5_policy_t name ) {\n kadm5_server_handle_t handle = server_handle ;\n osa_policy_ent_t entry ;\n int ret ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n ret = krb5_db_get_policy ( handle -> context , name , & entry ) ;\n if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n else if ( ret ) return ret ;\n if ( entry -> policy_refcnt != 0 ) {\n krb5_db_free_policy ( handle -> context , entry ) ;\n return KADM5_POLICY_REF ;\n }\n krb5_db_free_policy ( handle -> context , entry ) ;\n ret = krb5_db_delete_policy ( handle -> context , name ) ;\n if ( ret == KRB5_KDB_POLICY_REF ) ret = KADM5_POLICY_REF ;\n return ( ret == 0 ) ? KADM5_OK : ret ;\n }",
        "hash": -6986708248145981986,
        "project": "debian",
        "size": 20,
        "slice": {
            "strlen": [
                [
                    1,
                    "kadm5_ret_t kadm5_delete_policy ( void * server_handle , kadm5_policy_t name ) {\n"
                ],
                [
                    7,
                    " if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n"
                ],
                [
                    8,
                    " if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n"
                ],
                [
                    9,
                    " ret = krb5_db_get_policy ( handle -> context , name , & entry ) ;\n"
                ],
                [
                    10,
                    " if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "kadm5_ret_t kadm5_delete_policy ( void * server_handle , kadm5_policy_t name ) {\n"
                ],
                [
                    7,
                    " if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n"
                ],
                [
                    8,
                    " if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n"
                ],
                [
                    9,
                    " ret = krb5_db_get_policy ( handle -> context , name , & entry ) ;\n"
                ],
                [
                    10,
                    " if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n"
                ]
            ]
        }
    },
    {
        "code": "kadm5_ret_t kadm5_modify_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n kadm5_server_handle_t handle = server_handle ;\n krb5_tl_data * tl ;\n osa_policy_ent_t p ;\n int ret ;\n size_t len ;\n CHECK_HANDLE ( server_handle ) ;\n if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n if ( ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n if ( ( mask & KADM5_POLICY_ALLOWED_KEYSALTS ) && entry -> allowed_keysalts != NULL ) {\n ret = validate_allowed_keysalts ( entry -> allowed_keysalts ) ;\n if ( ret ) return ret ;\n }\n if ( ( mask & KADM5_POLICY_TL_DATA ) ) {\n tl = entry -> tl_data ;\n while ( tl != NULL ) {\n if ( tl -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ;\n tl = tl -> tl_data_next ;\n }\n }\n ret = krb5_db_get_policy ( handle -> context , entry -> policy , & p ) ;\n if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n else if ( ret ) return ret ;\n if ( ( mask & KADM5_PW_MAX_LIFE ) ) p -> pw_max_life = entry -> pw_max_life ;\n if ( ( mask & KADM5_PW_MIN_LIFE ) ) {\n if ( entry -> pw_min_life > p -> pw_max_life && p -> pw_max_life != 0 ) {\n krb5_db_free_policy ( handle -> context , p ) ;\n return KADM5_BAD_MIN_PASS_LIFE ;\n }\n p -> pw_min_life = entry -> pw_min_life ;\n }\n if ( ( mask & KADM5_PW_MIN_LENGTH ) ) {\n if ( entry -> pw_min_length < MIN_PW_LENGTH ) {\n krb5_db_free_policy ( handle -> context , p ) ;\n return KADM5_BAD_LENGTH ;\n }\n p -> pw_min_length = entry -> pw_min_length ;\n }\n if ( ( mask & KADM5_PW_MIN_CLASSES ) ) {\n if ( entry -> pw_min_classes > MAX_PW_CLASSES || entry -> pw_min_classes < MIN_PW_CLASSES ) {\n krb5_db_free_policy ( handle -> context , p ) ;\n return KADM5_BAD_CLASS ;\n }\n p -> pw_min_classes = entry -> pw_min_classes ;\n }\n if ( ( mask & KADM5_PW_HISTORY_NUM ) ) {\n if ( entry -> pw_history_num < MIN_PW_HISTORY ) {\n krb5_db_free_policy ( handle -> context , p ) ;\n return KADM5_BAD_HISTORY ;\n }\n p -> pw_history_num = entry -> pw_history_num ;\n }\n if ( ( mask & KADM5_REF_COUNT ) ) p -> policy_refcnt = entry -> policy_refcnt ;\n if ( handle -> api_version >= KADM5_API_VERSION_3 ) {\n if ( ( mask & KADM5_PW_MAX_FAILURE ) ) p -> pw_max_fail = entry -> pw_max_fail ;\n if ( ( mask & KADM5_PW_FAILURE_COUNT_INTERVAL ) ) p -> pw_failcnt_interval = entry -> pw_failcnt_interval ;\n if ( ( mask & KADM5_PW_LOCKOUT_DURATION ) ) p -> pw_lockout_duration = entry -> pw_lockout_duration ;\n }\n if ( handle -> api_version >= KADM5_API_VERSION_4 ) {\n if ( ( mask & KADM5_POLICY_ATTRIBUTES ) ) p -> attributes = entry -> attributes ;\n if ( ( mask & KADM5_POLICY_MAX_LIFE ) ) p -> max_life = entry -> max_life ;\n if ( ( mask & KADM5_POLICY_MAX_RLIFE ) ) p -> max_renewable_life = entry -> max_renewable_life ;\n if ( ( mask & KADM5_POLICY_ALLOWED_KEYSALTS ) ) {\n krb5_db_free ( handle -> context , p -> allowed_keysalts ) ;\n p -> allowed_keysalts = NULL ;\n if ( entry -> allowed_keysalts != NULL ) {\n len = strlen ( entry -> allowed_keysalts ) + 1 ;\n p -> allowed_keysalts = krb5_db_alloc ( handle -> context , NULL , len ) ;\n if ( p -> allowed_keysalts == NULL ) {\n ret = ENOMEM ;\n goto cleanup ;\n }\n memcpy ( p -> allowed_keysalts , entry -> allowed_keysalts , len ) ;\n }\n }\n if ( ( mask & KADM5_POLICY_TL_DATA ) ) {\n for ( tl = entry -> tl_data ;\n tl != NULL ;\n tl = tl -> tl_data_next ) {\n ret = krb5_db_update_tl_data ( handle -> context , & p -> n_tl_data , & p -> tl_data , tl ) ;\n if ( ret ) goto cleanup ;\n }\n }\n }\n ret = krb5_db_put_policy ( handle -> context , p ) ;\n cleanup : krb5_db_free_policy ( handle -> context , p ) ;\n return ret ;\n }",
        "hash": -6986708248145981986,
        "project": "debian",
        "size": 89,
        "slice": {
            "memcpy": [
                [
                    1,
                    "kadm5_ret_t kadm5_modify_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n"
                ],
                [
                    8,
                    " if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n"
                ],
                [
                    68,
                    " len = strlen ( entry -> allowed_keysalts ) + 1 ;\n"
                ],
                [
                    69,
                    " p -> allowed_keysalts = krb5_db_alloc ( handle -> context , NULL , len ) ;\n"
                ],
                [
                    70,
                    " if ( p -> allowed_keysalts == NULL ) {\n"
                ],
                [
                    74,
                    " memcpy ( p -> allowed_keysalts , entry -> allowed_keysalts , len ) ;\n"
                ],
                [
                    86,
                    " ret = krb5_db_put_policy ( handle -> context , p ) ;\n"
                ],
                [
                    87,
                    " cleanup : krb5_db_free_policy ( handle -> context , p ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "kadm5_ret_t kadm5_modify_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n"
                ],
                [
                    8,
                    " if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n"
                ],
                [
                    9,
                    " if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n"
                ],
                [
                    10,
                    " if ( ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n"
                ],
                [
                    22,
                    " ret = krb5_db_get_policy ( handle -> context , entry -> policy , & p ) ;\n"
                ],
                [
                    67,
                    " if ( entry -> allowed_keysalts != NULL ) {\n"
                ],
                [
                    68,
                    " len = strlen ( entry -> allowed_keysalts ) + 1 ;\n"
                ],
                [
                    69,
                    " p -> allowed_keysalts = krb5_db_alloc ( handle -> context , NULL , len ) ;\n"
                ],
                [
                    74,
                    " memcpy ( p -> allowed_keysalts , entry -> allowed_keysalts , len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "kadm5_ret_t kadm5_modify_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n"
                ],
                [
                    8,
                    " if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n"
                ],
                [
                    9,
                    " if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n"
                ],
                [
                    10,
                    " if ( ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n"
                ],
                [
                    22,
                    " ret = krb5_db_get_policy ( handle -> context , entry -> policy , & p ) ;\n"
                ],
                [
                    67,
                    " if ( entry -> allowed_keysalts != NULL ) {\n"
                ],
                [
                    68,
                    " len = strlen ( entry -> allowed_keysalts ) + 1 ;\n"
                ],
                [
                    69,
                    " p -> allowed_keysalts = krb5_db_alloc ( handle -> context , NULL , len ) ;\n"
                ],
                [
                    70,
                    " if ( p -> allowed_keysalts == NULL ) {\n"
                ],
                [
                    74,
                    " memcpy ( p -> allowed_keysalts , entry -> allowed_keysalts , len ) ;\n"
                ],
                [
                    86,
                    " ret = krb5_db_put_policy ( handle -> context , p ) ;\n"
                ],
                [
                    87,
                    " cleanup : krb5_db_free_policy ( handle -> context , p ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void kadmin_getpol ( int argc , char * argv [ ] ) {\n krb5_error_code retval ;\n kadm5_policy_ent_rec policy ;\n if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n fprintf ( stderr , _ ( \"usage: get_policy [-terse] policy\\n\" ) ) ;\n return ;\n }\n retval = kadm5_get_policy ( handle , argv [ argc - 1 ] , & policy ) ;\n if ( retval ) {\n com_err ( \"get_policy\" , retval , _ ( \"while retrieving policy \\\"%s\\\".\" ) , argv [ argc - 1 ] ) ;\n return ;\n }\n if ( argc == 2 ) {\n printf ( _ ( \"Policy: %s\\n\" ) , policy . policy ) ;\n printf ( _ ( \"Maximum password life: %ld\\n\" ) , policy . pw_max_life ) ;\n printf ( _ ( \"Minimum password life: %ld\\n\" ) , policy . pw_min_life ) ;\n printf ( _ ( \"Minimum password length: %ld\\n\" ) , policy . pw_min_length ) ;\n printf ( _ ( \"Minimum number of password character classes: %ld\\n\" ) , policy . pw_min_classes ) ;\n printf ( _ ( \"Number of old keys kept: %ld\\n\" ) , policy . pw_history_num ) ;\n printf ( _ ( \"Reference count: %ld\\n\" ) , policy . policy_refcnt ) ;\n printf ( _ ( \"Maximum password failures before lockout: %lu\\n\" ) , ( unsigned long ) policy . pw_max_fail ) ;\n printf ( _ ( \"Password failure count reset interval: %s\\n\" ) , strdur ( policy . pw_failcnt_interval ) ) ;\n printf ( _ ( \"Password lockout duration: %s\\n\" ) , strdur ( policy . pw_lockout_duration ) ) ;\n if ( policy . allowed_keysalts != NULL ) printf ( _ ( \"Allowed key/salt types: %s\\n\" ) , policy . allowed_keysalts ) ;\n }\n else {\n printf ( \"\\\"%s\\\"\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%lu\\t%ld\\t%ld\\t%s\\n\" , policy . policy , policy . pw_max_life , policy . pw_min_life , policy . pw_min_length , policy . pw_min_classes , policy . pw_history_num , policy . policy_refcnt , ( unsigned long ) policy . pw_max_fail , ( long ) policy . pw_failcnt_interval , ( long ) policy . pw_lockout_duration , ( policy . allowed_keysalts == NULL ) ? \"-\" : policy . allowed_keysalts ) ;\n }\n kadm5_free_policy_ent ( handle , & policy ) ;\n }",
        "hash": 1676654288894940649,
        "project": "debian",
        "size": 30,
        "slice": {
            "strcmp": [
                [
                    1,
                    "void kadmin_getpol ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    4,
                    " if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n"
                ],
                [
                    5,
                    " fprintf ( stderr , _ ( \"usage: get_policy [-terse] policy\\n\" ) ) ;\n"
                ],
                [
                    6,
                    " return ;\n"
                ],
                [
                    8,
                    " retval = kadm5_get_policy ( handle , argv [ argc - 1 ] , & policy ) ;\n"
                ],
                [
                    9,
                    " if ( retval ) {\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "void kadmin_getpol ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    13,
                    " if ( argc == 2 ) {\n"
                ],
                [
                    14,
                    " printf ( _ ( \"Policy: %s\\n\" ) , policy . policy ) ;\n"
                ],
                [
                    15,
                    " printf ( _ ( \"Maximum password life: %ld\\n\" ) , policy . pw_max_life ) ;\n"
                ],
                [
                    16,
                    " printf ( _ ( \"Minimum password life: %ld\\n\" ) , policy . pw_min_life ) ;\n"
                ],
                [
                    17,
                    " printf ( _ ( \"Minimum password length: %ld\\n\" ) , policy . pw_min_length ) ;\n"
                ],
                [
                    18,
                    " printf ( _ ( \"Minimum number of password character classes: %ld\\n\" ) , policy . pw_min_classes ) ;\n"
                ],
                [
                    19,
                    " printf ( _ ( \"Number of old keys kept: %ld\\n\" ) , policy . pw_history_num ) ;\n"
                ],
                [
                    20,
                    " printf ( _ ( \"Reference count: %ld\\n\" ) , policy . policy_refcnt ) ;\n"
                ],
                [
                    21,
                    " printf ( _ ( \"Maximum password failures before lockout: %lu\\n\" ) , ( unsigned long ) policy . pw_max_fail ) ;\n"
                ],
                [
                    22,
                    " printf ( _ ( \"Password failure count reset interval: %s\\n\" ) , strdur ( policy . pw_failcnt_interval ) ) ;\n"
                ],
                [
                    23,
                    " printf ( _ ( \"Password lockout duration: %s\\n\" ) , strdur ( policy . pw_lockout_duration ) ) ;\n"
                ],
                [
                    24,
                    " if ( policy . allowed_keysalts != NULL ) printf ( _ ( \"Allowed key/salt types: %s\\n\" ) , policy . allowed_keysalts ) ;\n"
                ],
                [
                    27,
                    " printf ( \"\\\"%s\\\"\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%lu\\t%ld\\t%ld\\t%s\\n\" , policy . policy , policy . pw_max_life , policy . pw_min_life , policy . pw_min_length , policy . pw_min_classes , policy . pw_history_num , policy . policy_refcnt , ( unsigned long ) policy . pw_max_fail , ( long ) policy . pw_failcnt_interval , ( long ) policy . pw_lockout_duration , ( policy . allowed_keysalts == NULL ) ? \"-\" : policy . allowed_keysalts ) ;\n"
                ],
                [
                    29,
                    " kadm5_free_policy_ent ( handle , & policy ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "void kadmin_getpol ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    4,
                    " if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n"
                ],
                [
                    5,
                    " fprintf ( stderr , _ ( \"usage: get_policy [-terse] policy\\n\" ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void kadmin_getpol ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    4,
                    " if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n"
                ],
                [
                    5,
                    " fprintf ( stderr , _ ( \"usage: get_policy [-terse] policy\\n\" ) ) ;\n"
                ],
                [
                    6,
                    " return ;\n"
                ],
                [
                    8,
                    " retval = kadm5_get_policy ( handle , argv [ argc - 1 ] , & policy ) ;\n"
                ],
                [
                    9,
                    " if ( retval ) {\n"
                ],
                [
                    13,
                    " if ( argc == 2 ) {\n"
                ],
                [
                    14,
                    " printf ( _ ( \"Policy: %s\\n\" ) , policy . policy ) ;\n"
                ],
                [
                    15,
                    " printf ( _ ( \"Maximum password life: %ld\\n\" ) , policy . pw_max_life ) ;\n"
                ],
                [
                    16,
                    " printf ( _ ( \"Minimum password life: %ld\\n\" ) , policy . pw_min_life ) ;\n"
                ],
                [
                    17,
                    " printf ( _ ( \"Minimum password length: %ld\\n\" ) , policy . pw_min_length ) ;\n"
                ],
                [
                    18,
                    " printf ( _ ( \"Minimum number of password character classes: %ld\\n\" ) , policy . pw_min_classes ) ;\n"
                ],
                [
                    19,
                    " printf ( _ ( \"Number of old keys kept: %ld\\n\" ) , policy . pw_history_num ) ;\n"
                ],
                [
                    20,
                    " printf ( _ ( \"Reference count: %ld\\n\" ) , policy . policy_refcnt ) ;\n"
                ],
                [
                    21,
                    " printf ( _ ( \"Maximum password failures before lockout: %lu\\n\" ) , ( unsigned long ) policy . pw_max_fail ) ;\n"
                ],
                [
                    22,
                    " printf ( _ ( \"Password failure count reset interval: %s\\n\" ) , strdur ( policy . pw_failcnt_interval ) ) ;\n"
                ],
                [
                    23,
                    " printf ( _ ( \"Password lockout duration: %s\\n\" ) , strdur ( policy . pw_lockout_duration ) ) ;\n"
                ],
                [
                    24,
                    " if ( policy . allowed_keysalts != NULL ) printf ( _ ( \"Allowed key/salt types: %s\\n\" ) , policy . allowed_keysalts ) ;\n"
                ],
                [
                    27,
                    " printf ( \"\\\"%s\\\"\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%ld\\t%lu\\t%ld\\t%ld\\t%s\\n\" , policy . policy , policy . pw_max_life , policy . pw_min_life , policy . pw_min_length , policy . pw_min_classes , policy . pw_history_num , policy . policy_refcnt , ( unsigned long ) policy . pw_max_fail , ( long ) policy . pw_failcnt_interval , ( long ) policy . pw_lockout_duration , ( policy . allowed_keysalts == NULL ) ? \"-\" : policy . allowed_keysalts ) ;\n"
                ],
                [
                    29,
                    " kadm5_free_policy_ent ( handle , & policy ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void kadmin_getprinc ( int argc , char * argv [ ] ) {\n kadm5_principal_ent_rec dprinc ;\n krb5_principal princ = NULL ;\n krb5_error_code retval ;\n char * canon = NULL , * princstr = NULL , * modprincstr = NULL ;\n int i ;\n size_t j ;\n if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n fprintf ( stderr , _ ( \"usage: get_principal [-terse] principal\\n\" ) ) ;\n return ;\n }\n memset ( & dprinc , 0 , sizeof ( dprinc ) ) ;\n retval = kadmin_parse_name ( argv [ argc - 1 ] , & princ ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while parsing principal\" ) ) ;\n return ;\n }\n retval = krb5_unparse_name ( context , princ , & canon ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while canonicalizing principal\" ) ) ;\n goto cleanup ;\n }\n retval = kadm5_get_principal ( handle , princ , & dprinc , KADM5_PRINCIPAL_NORMAL_MASK | KADM5_KEY_DATA ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while retrieving \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n retval = krb5_unparse_name ( context , dprinc . principal , & princstr ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while unparsing principal\" ) ) ;\n goto cleanup ;\n }\n retval = krb5_unparse_name ( context , dprinc . mod_name , & modprincstr ) ;\n if ( retval ) {\n com_err ( \"get_principal\" , retval , _ ( \"while unparsing principal\" ) ) ;\n goto cleanup ;\n }\n if ( argc == 2 ) {\n printf ( _ ( \"Principal: %s\\n\" ) , princstr ) ;\n printf ( _ ( \"Expiration date: %s\\n\" ) , dprinc . princ_expire_time ? strdate ( dprinc . princ_expire_time ) : _ ( \"[never]\" ) ) ;\n printf ( _ ( \"Last password change: %s\\n\" ) , dprinc . last_pwd_change ? strdate ( dprinc . last_pwd_change ) : _ ( \"[never]\" ) ) ;\n printf ( _ ( \"Password expiration date: %s\\n\" ) , dprinc . pw_expiration ? strdate ( dprinc . pw_expiration ) : _ ( \"[none]\" ) ) ;\n printf ( _ ( \"Maximum ticket life: %s\\n\" ) , strdur ( dprinc . max_life ) ) ;\n printf ( _ ( \"Maximum renewable life: %s\\n\" ) , strdur ( dprinc . max_renewable_life ) ) ;\n printf ( _ ( \"Last modified: %s (%s)\\n\" ) , strdate ( dprinc . mod_date ) , modprincstr ) ;\n printf ( _ ( \"Last successful authentication: %s\\n\" ) , dprinc . last_success ? strdate ( dprinc . last_success ) : _ ( \"[never]\" ) ) ;\n printf ( \"Last failed authentication: %s\\n\" , dprinc . last_failed ? strdate ( dprinc . last_failed ) : \"[never]\" ) ;\n printf ( _ ( \"Failed password attempts: %d\\n\" ) , dprinc . fail_auth_count ) ;\n printf ( _ ( \"Number of keys: %d\\n\" ) , dprinc . n_key_data ) ;\n for ( i = 0 ;\n i < dprinc . n_key_data ;\n i ++ ) {\n krb5_key_data * key_data = & dprinc . key_data [ i ] ;\n char enctype [ BUFSIZ ] , salttype [ BUFSIZ ] ;\n if ( krb5_enctype_to_name ( key_data -> key_data_type [ 0 ] , FALSE , enctype , sizeof ( enctype ) ) ) snprintf ( enctype , sizeof ( enctype ) , _ ( \"<Encryption type 0x%x>\" ) , key_data -> key_data_type [ 0 ] ) ;\n printf ( \"Key: vno %d, %s, \" , key_data -> key_data_kvno , enctype ) ;\n if ( key_data -> key_data_ver > 1 ) {\n if ( krb5_salttype_to_string ( key_data -> key_data_type [ 1 ] , salttype , sizeof ( salttype ) ) ) snprintf ( salttype , sizeof ( salttype ) , _ ( \"<Salt type 0x%x>\" ) , key_data -> key_data_type [ 1 ] ) ;\n printf ( \"%s\\n\" , salttype ) ;\n }\n else printf ( _ ( \"no salt\\n\" ) ) ;\n }\n printf ( _ ( \"MKey: vno %d\\n\" ) , dprinc . mkvno ) ;\n printf ( _ ( \"Attributes:\" ) ) ;\n for ( j = 0 ;\n j < sizeof ( prflags ) / sizeof ( char * ) ;\n j ++ ) {\n if ( dprinc . attributes & ( krb5_flags ) 1 << j ) printf ( \" %s\" , prflags [ j ] ) ;\n }\n printf ( \"\\n\" ) ;\n printf ( _ ( \"Policy: %s\\n\" ) , dprinc . policy ? dprinc . policy : _ ( \"[none]\" ) ) ;\n }\n else {\n printf ( \"\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\" \"\\t%d\\t%d\\t%d\\t%d\\t%d\" , princstr , dprinc . princ_expire_time , dprinc . last_pwd_change , dprinc . pw_expiration , dprinc . max_life , modprincstr , dprinc . mod_date , dprinc . attributes , dprinc . kvno , dprinc . mkvno , dprinc . policy ? dprinc . policy : \"[none]\" , dprinc . max_renewable_life , dprinc . last_success , dprinc . last_failed , dprinc . fail_auth_count , dprinc . n_key_data ) ;\n for ( i = 0 ;\n i < dprinc . n_key_data ;\n i ++ ) printf ( \"\\t%d\\t%d\\t%d\\t%d\" , dprinc . key_data [ i ] . key_data_ver , dprinc . key_data [ i ] . key_data_kvno , dprinc . key_data [ i ] . key_data_type [ 0 ] , dprinc . key_data [ i ] . key_data_type [ 1 ] ) ;\n printf ( \"\\n\" ) ;\n }\n cleanup : krb5_free_principal ( context , princ ) ;\n kadm5_free_principal_ent ( handle , & dprinc ) ;\n free ( canon ) ;\n free ( princstr ) ;\n free ( modprincstr ) ;\n }",
        "hash": 1676654288894940649,
        "project": "debian",
        "size": 85,
        "slice": {
            "memset": [
                [
                    1,
                    "void kadmin_getprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    8,
                    " if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n"
                ],
                [
                    12,
                    " memset ( & dprinc , 0 , sizeof ( dprinc ) ) ;\n"
                ],
                [
                    23,
                    " retval = kadm5_get_principal ( handle , princ , & dprinc , KADM5_PRINCIPAL_NORMAL_MASK | KADM5_KEY_DATA ) ;\n"
                ],
                [
                    28,
                    " retval = krb5_unparse_name ( context , dprinc . principal , & princstr ) ;\n"
                ],
                [
                    33,
                    " retval = krb5_unparse_name ( context , dprinc . mod_name , & modprincstr ) ;\n"
                ],
                [
                    40,
                    " printf ( _ ( \"Expiration date: %s\\n\" ) , dprinc . princ_expire_time ? strdate ( dprinc . princ_expire_time ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    41,
                    " printf ( _ ( \"Last password change: %s\\n\" ) , dprinc . last_pwd_change ? strdate ( dprinc . last_pwd_change ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    42,
                    " printf ( _ ( \"Password expiration date: %s\\n\" ) , dprinc . pw_expiration ? strdate ( dprinc . pw_expiration ) : _ ( \"[none]\" ) ) ;\n"
                ],
                [
                    43,
                    " printf ( _ ( \"Maximum ticket life: %s\\n\" ) , strdur ( dprinc . max_life ) ) ;\n"
                ],
                [
                    44,
                    " printf ( _ ( \"Maximum renewable life: %s\\n\" ) , strdur ( dprinc . max_renewable_life ) ) ;\n"
                ],
                [
                    45,
                    " printf ( _ ( \"Last modified: %s (%s)\\n\" ) , strdate ( dprinc . mod_date ) , modprincstr ) ;\n"
                ],
                [
                    46,
                    " printf ( _ ( \"Last successful authentication: %s\\n\" ) , dprinc . last_success ? strdate ( dprinc . last_success ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    47,
                    " printf ( \"Last failed authentication: %s\\n\" , dprinc . last_failed ? strdate ( dprinc . last_failed ) : \"[never]\" ) ;\n"
                ],
                [
                    48,
                    " printf ( _ ( \"Failed password attempts: %d\\n\" ) , dprinc . fail_auth_count ) ;\n"
                ],
                [
                    49,
                    " printf ( _ ( \"Number of keys: %d\\n\" ) , dprinc . n_key_data ) ;\n"
                ],
                [
                    51,
                    " i < dprinc . n_key_data ;\n"
                ],
                [
                    63,
                    " printf ( _ ( \"MKey: vno %d\\n\" ) , dprinc . mkvno ) ;\n"
                ],
                [
                    68,
                    " if ( dprinc . attributes & ( krb5_flags ) 1 << j ) printf ( \" %s\" , prflags [ j ] ) ;\n"
                ],
                [
                    71,
                    " printf ( _ ( \"Policy: %s\\n\" ) , dprinc . policy ? dprinc . policy : _ ( \"[none]\" ) ) ;\n"
                ],
                [
                    74,
                    " printf ( \"\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\" \"\\t%d\\t%d\\t%d\\t%d\\t%d\" , princstr , dprinc . princ_expire_time , dprinc . last_pwd_change , dprinc . pw_expiration , dprinc . max_life , modprincstr , dprinc . mod_date , dprinc . attributes , dprinc . kvno , dprinc . mkvno , dprinc . policy ? dprinc . policy : \"[none]\" , dprinc . max_renewable_life , dprinc . last_success , dprinc . last_failed , dprinc . fail_auth_count , dprinc . n_key_data ) ;\n"
                ],
                [
                    76,
                    " i < dprinc . n_key_data ;\n"
                ],
                [
                    81,
                    " kadm5_free_principal_ent ( handle , & dprinc ) ;\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "void kadmin_getprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    8,
                    " if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n"
                ],
                [
                    9,
                    " fprintf ( stderr , _ ( \"usage: get_principal [-terse] principal\\n\" ) ) ;\n"
                ],
                [
                    10,
                    " return ;\n"
                ],
                [
                    12,
                    " memset ( & dprinc , 0 , sizeof ( dprinc ) ) ;\n"
                ],
                [
                    13,
                    " retval = kadmin_parse_name ( argv [ argc - 1 ] , & princ ) ;\n"
                ],
                [
                    14,
                    " if ( retval ) {\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "void kadmin_getprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    5,
                    " char * canon = NULL , * princstr = NULL , * modprincstr = NULL ;\n"
                ],
                [
                    12,
                    " memset ( & dprinc , 0 , sizeof ( dprinc ) ) ;\n"
                ],
                [
                    28,
                    " retval = krb5_unparse_name ( context , dprinc . principal , & princstr ) ;\n"
                ],
                [
                    33,
                    " retval = krb5_unparse_name ( context , dprinc . mod_name , & modprincstr ) ;\n"
                ],
                [
                    38,
                    " if ( argc == 2 ) {\n"
                ],
                [
                    39,
                    " printf ( _ ( \"Principal: %s\\n\" ) , princstr ) ;\n"
                ],
                [
                    40,
                    " printf ( _ ( \"Expiration date: %s\\n\" ) , dprinc . princ_expire_time ? strdate ( dprinc . princ_expire_time ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    41,
                    " printf ( _ ( \"Last password change: %s\\n\" ) , dprinc . last_pwd_change ? strdate ( dprinc . last_pwd_change ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    42,
                    " printf ( _ ( \"Password expiration date: %s\\n\" ) , dprinc . pw_expiration ? strdate ( dprinc . pw_expiration ) : _ ( \"[none]\" ) ) ;\n"
                ],
                [
                    43,
                    " printf ( _ ( \"Maximum ticket life: %s\\n\" ) , strdur ( dprinc . max_life ) ) ;\n"
                ],
                [
                    44,
                    " printf ( _ ( \"Maximum renewable life: %s\\n\" ) , strdur ( dprinc . max_renewable_life ) ) ;\n"
                ],
                [
                    45,
                    " printf ( _ ( \"Last modified: %s (%s)\\n\" ) , strdate ( dprinc . mod_date ) , modprincstr ) ;\n"
                ],
                [
                    46,
                    " printf ( _ ( \"Last successful authentication: %s\\n\" ) , dprinc . last_success ? strdate ( dprinc . last_success ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    47,
                    " printf ( \"Last failed authentication: %s\\n\" , dprinc . last_failed ? strdate ( dprinc . last_failed ) : \"[never]\" ) ;\n"
                ],
                [
                    48,
                    " printf ( _ ( \"Failed password attempts: %d\\n\" ) , dprinc . fail_auth_count ) ;\n"
                ],
                [
                    49,
                    " printf ( _ ( \"Number of keys: %d\\n\" ) , dprinc . n_key_data ) ;\n"
                ],
                [
                    51,
                    " i < dprinc . n_key_data ;\n"
                ],
                [
                    53,
                    " krb5_key_data * key_data = & dprinc . key_data [ i ] ;\n"
                ],
                [
                    55,
                    " if ( krb5_enctype_to_name ( key_data -> key_data_type [ 0 ] , FALSE , enctype , sizeof ( enctype ) ) ) snprintf ( enctype , sizeof ( enctype ) , _ ( \"<Encryption type 0x%x>\" ) , key_data -> key_data_type [ 0 ] ) ;\n"
                ],
                [
                    56,
                    " printf ( \"Key: vno %d, %s, \" , key_data -> key_data_kvno , enctype ) ;\n"
                ],
                [
                    57,
                    " if ( key_data -> key_data_ver > 1 ) {\n"
                ],
                [
                    58,
                    " if ( krb5_salttype_to_string ( key_data -> key_data_type [ 1 ] , salttype , sizeof ( salttype ) ) ) snprintf ( salttype , sizeof ( salttype ) , _ ( \"<Salt type 0x%x>\" ) , key_data -> key_data_type [ 1 ] ) ;\n"
                ],
                [
                    59,
                    " printf ( \"%s\\n\" , salttype ) ;\n"
                ],
                [
                    61,
                    " else printf ( _ ( \"no salt\\n\" ) ) ;\n"
                ],
                [
                    63,
                    " printf ( _ ( \"MKey: vno %d\\n\" ) , dprinc . mkvno ) ;\n"
                ],
                [
                    64,
                    " printf ( _ ( \"Attributes:\" ) ) ;\n"
                ],
                [
                    68,
                    " if ( dprinc . attributes & ( krb5_flags ) 1 << j ) printf ( \" %s\" , prflags [ j ] ) ;\n"
                ],
                [
                    70,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    71,
                    " printf ( _ ( \"Policy: %s\\n\" ) , dprinc . policy ? dprinc . policy : _ ( \"[none]\" ) ) ;\n"
                ],
                [
                    74,
                    " printf ( \"\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\" \"\\t%d\\t%d\\t%d\\t%d\\t%d\" , princstr , dprinc . princ_expire_time , dprinc . last_pwd_change , dprinc . pw_expiration , dprinc . max_life , modprincstr , dprinc . mod_date , dprinc . attributes , dprinc . kvno , dprinc . mkvno , dprinc . policy ? dprinc . policy : \"[none]\" , dprinc . max_renewable_life , dprinc . last_success , dprinc . last_failed , dprinc . fail_auth_count , dprinc . n_key_data ) ;\n"
                ],
                [
                    76,
                    " i < dprinc . n_key_data ;\n"
                ],
                [
                    77,
                    " i ++ ) printf ( \"\\t%d\\t%d\\t%d\\t%d\" , dprinc . key_data [ i ] . key_data_ver , dprinc . key_data [ i ] . key_data_kvno , dprinc . key_data [ i ] . key_data_type [ 0 ] , dprinc . key_data [ i ] . key_data_type [ 1 ] ) ;\n"
                ],
                [
                    78,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    81,
                    " kadm5_free_principal_ent ( handle , & dprinc ) ;\n"
                ],
                [
                    83,
                    " free ( princstr ) ;\n"
                ],
                [
                    84,
                    " free ( modprincstr ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "void kadmin_getprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    8,
                    " if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n"
                ],
                [
                    9,
                    " fprintf ( stderr , _ ( \"usage: get_principal [-terse] principal\\n\" ) ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "void kadmin_getprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    5,
                    " char * canon = NULL , * princstr = NULL , * modprincstr = NULL ;\n"
                ],
                [
                    14,
                    " if ( retval ) {\n"
                ],
                [
                    18,
                    " retval = krb5_unparse_name ( context , princ , & canon ) ;\n"
                ],
                [
                    25,
                    " com_err ( \"get_principal\" , retval , _ ( \"while retrieving \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    28,
                    " retval = krb5_unparse_name ( context , dprinc . principal , & princstr ) ;\n"
                ],
                [
                    33,
                    " retval = krb5_unparse_name ( context , dprinc . mod_name , & modprincstr ) ;\n"
                ],
                [
                    39,
                    " printf ( _ ( \"Principal: %s\\n\" ) , princstr ) ;\n"
                ],
                [
                    45,
                    " printf ( _ ( \"Last modified: %s (%s)\\n\" ) , strdate ( dprinc . mod_date ) , modprincstr ) ;\n"
                ],
                [
                    74,
                    " printf ( \"\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\" \"\\t%d\\t%d\\t%d\\t%d\\t%d\" , princstr , dprinc . princ_expire_time , dprinc . last_pwd_change , dprinc . pw_expiration , dprinc . max_life , modprincstr , dprinc . mod_date , dprinc . attributes , dprinc . kvno , dprinc . mkvno , dprinc . policy ? dprinc . policy : \"[none]\" , dprinc . max_renewable_life , dprinc . last_success , dprinc . last_failed , dprinc . fail_auth_count , dprinc . n_key_data ) ;\n"
                ],
                [
                    82,
                    " free ( canon ) ;\n"
                ],
                [
                    83,
                    " free ( princstr ) ;\n"
                ],
                [
                    84,
                    " free ( modprincstr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void kadmin_getprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    5,
                    " char * canon = NULL , * princstr = NULL , * modprincstr = NULL ;\n"
                ],
                [
                    8,
                    " if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( \"-terse\" , argv [ 1 ] ) ) ) ) {\n"
                ],
                [
                    9,
                    " fprintf ( stderr , _ ( \"usage: get_principal [-terse] principal\\n\" ) ) ;\n"
                ],
                [
                    10,
                    " return ;\n"
                ],
                [
                    12,
                    " memset ( & dprinc , 0 , sizeof ( dprinc ) ) ;\n"
                ],
                [
                    13,
                    " retval = kadmin_parse_name ( argv [ argc - 1 ] , & princ ) ;\n"
                ],
                [
                    14,
                    " if ( retval ) {\n"
                ],
                [
                    18,
                    " retval = krb5_unparse_name ( context , princ , & canon ) ;\n"
                ],
                [
                    23,
                    " retval = kadm5_get_principal ( handle , princ , & dprinc , KADM5_PRINCIPAL_NORMAL_MASK | KADM5_KEY_DATA ) ;\n"
                ],
                [
                    25,
                    " com_err ( \"get_principal\" , retval , _ ( \"while retrieving \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    28,
                    " retval = krb5_unparse_name ( context , dprinc . principal , & princstr ) ;\n"
                ],
                [
                    33,
                    " retval = krb5_unparse_name ( context , dprinc . mod_name , & modprincstr ) ;\n"
                ],
                [
                    38,
                    " if ( argc == 2 ) {\n"
                ],
                [
                    39,
                    " printf ( _ ( \"Principal: %s\\n\" ) , princstr ) ;\n"
                ],
                [
                    40,
                    " printf ( _ ( \"Expiration date: %s\\n\" ) , dprinc . princ_expire_time ? strdate ( dprinc . princ_expire_time ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    41,
                    " printf ( _ ( \"Last password change: %s\\n\" ) , dprinc . last_pwd_change ? strdate ( dprinc . last_pwd_change ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    42,
                    " printf ( _ ( \"Password expiration date: %s\\n\" ) , dprinc . pw_expiration ? strdate ( dprinc . pw_expiration ) : _ ( \"[none]\" ) ) ;\n"
                ],
                [
                    43,
                    " printf ( _ ( \"Maximum ticket life: %s\\n\" ) , strdur ( dprinc . max_life ) ) ;\n"
                ],
                [
                    44,
                    " printf ( _ ( \"Maximum renewable life: %s\\n\" ) , strdur ( dprinc . max_renewable_life ) ) ;\n"
                ],
                [
                    45,
                    " printf ( _ ( \"Last modified: %s (%s)\\n\" ) , strdate ( dprinc . mod_date ) , modprincstr ) ;\n"
                ],
                [
                    46,
                    " printf ( _ ( \"Last successful authentication: %s\\n\" ) , dprinc . last_success ? strdate ( dprinc . last_success ) : _ ( \"[never]\" ) ) ;\n"
                ],
                [
                    47,
                    " printf ( \"Last failed authentication: %s\\n\" , dprinc . last_failed ? strdate ( dprinc . last_failed ) : \"[never]\" ) ;\n"
                ],
                [
                    48,
                    " printf ( _ ( \"Failed password attempts: %d\\n\" ) , dprinc . fail_auth_count ) ;\n"
                ],
                [
                    49,
                    " printf ( _ ( \"Number of keys: %d\\n\" ) , dprinc . n_key_data ) ;\n"
                ],
                [
                    51,
                    " i < dprinc . n_key_data ;\n"
                ],
                [
                    53,
                    " krb5_key_data * key_data = & dprinc . key_data [ i ] ;\n"
                ],
                [
                    55,
                    " if ( krb5_enctype_to_name ( key_data -> key_data_type [ 0 ] , FALSE , enctype , sizeof ( enctype ) ) ) snprintf ( enctype , sizeof ( enctype ) , _ ( \"<Encryption type 0x%x>\" ) , key_data -> key_data_type [ 0 ] ) ;\n"
                ],
                [
                    56,
                    " printf ( \"Key: vno %d, %s, \" , key_data -> key_data_kvno , enctype ) ;\n"
                ],
                [
                    57,
                    " if ( key_data -> key_data_ver > 1 ) {\n"
                ],
                [
                    58,
                    " if ( krb5_salttype_to_string ( key_data -> key_data_type [ 1 ] , salttype , sizeof ( salttype ) ) ) snprintf ( salttype , sizeof ( salttype ) , _ ( \"<Salt type 0x%x>\" ) , key_data -> key_data_type [ 1 ] ) ;\n"
                ],
                [
                    59,
                    " printf ( \"%s\\n\" , salttype ) ;\n"
                ],
                [
                    61,
                    " else printf ( _ ( \"no salt\\n\" ) ) ;\n"
                ],
                [
                    63,
                    " printf ( _ ( \"MKey: vno %d\\n\" ) , dprinc . mkvno ) ;\n"
                ],
                [
                    64,
                    " printf ( _ ( \"Attributes:\" ) ) ;\n"
                ],
                [
                    68,
                    " if ( dprinc . attributes & ( krb5_flags ) 1 << j ) printf ( \" %s\" , prflags [ j ] ) ;\n"
                ],
                [
                    70,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    71,
                    " printf ( _ ( \"Policy: %s\\n\" ) , dprinc . policy ? dprinc . policy : _ ( \"[none]\" ) ) ;\n"
                ],
                [
                    74,
                    " printf ( \"\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\\t%d\\t%d\\t%d\\t%d\\t\\\"%s\\\"\" \"\\t%d\\t%d\\t%d\\t%d\\t%d\" , princstr , dprinc . princ_expire_time , dprinc . last_pwd_change , dprinc . pw_expiration , dprinc . max_life , modprincstr , dprinc . mod_date , dprinc . attributes , dprinc . kvno , dprinc . mkvno , dprinc . policy ? dprinc . policy : \"[none]\" , dprinc . max_renewable_life , dprinc . last_success , dprinc . last_failed , dprinc . fail_auth_count , dprinc . n_key_data ) ;\n"
                ],
                [
                    76,
                    " i < dprinc . n_key_data ;\n"
                ],
                [
                    77,
                    " i ++ ) printf ( \"\\t%d\\t%d\\t%d\\t%d\" , dprinc . key_data [ i ] . key_data_ver , dprinc . key_data [ i ] . key_data_kvno , dprinc . key_data [ i ] . key_data_type [ 0 ] , dprinc . key_data [ i ] . key_data_type [ 1 ] ) ;\n"
                ],
                [
                    78,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    81,
                    " kadm5_free_principal_ent ( handle , & dprinc ) ;\n"
                ],
                [
                    82,
                    " free ( canon ) ;\n"
                ],
                [
                    83,
                    " free ( princstr ) ;\n"
                ],
                [
                    84,
                    " free ( modprincstr ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void kadmin_modprinc ( int argc , char * argv [ ] ) {\n kadm5_principal_ent_rec princ , oldprinc ;\n krb5_principal kprinc = NULL ;\n long mask ;\n krb5_error_code retval ;\n char * pass , * canon = NULL ;\n krb5_boolean randkey = FALSE ;\n int n_ks_tuple = 0 ;\n krb5_key_salt_tuple * ks_tuple = NULL ;\n if ( argc < 2 ) {\n kadmin_modprinc_usage ( ) ;\n return ;\n }\n memset ( & oldprinc , 0 , sizeof ( oldprinc ) ) ;\n memset ( & princ , 0 , sizeof ( princ ) ) ;\n retval = kadmin_parse_name ( argv [ argc - 1 ] , & kprinc ) ;\n if ( retval ) {\n com_err ( \"modify_principal\" , retval , _ ( \"while parsing principal\" ) ) ;\n return ;\n }\n retval = krb5_unparse_name ( context , kprinc , & canon ) ;\n if ( retval ) {\n com_err ( \"modify_principal\" , retval , _ ( \"while canonicalizing principal\" ) ) ;\n goto cleanup ;\n }\n retval = kadm5_get_principal ( handle , kprinc , & oldprinc , KADM5_PRINCIPAL_NORMAL_MASK ) ;\n if ( retval ) {\n com_err ( \"modify_principal\" , retval , _ ( \"while getting \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n princ . attributes = oldprinc . attributes ;\n kadm5_free_principal_ent ( handle , & oldprinc ) ;\n retval = kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , \"modify_principal\" ) ;\n if ( retval || ks_tuple != NULL || randkey || pass ) {\n kadmin_modprinc_usage ( ) ;\n goto cleanup ;\n }\n if ( mask ) {\n retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n }\n if ( retval ) {\n com_err ( \"modify_principal\" , retval , _ ( \"while modifying \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n printf ( _ ( \"Principal \\\"%s\\\" modified.\\n\" ) , canon ) ;\n cleanup : krb5_free_principal ( context , kprinc ) ;\n krb5_free_principal ( context , princ . principal ) ;\n kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;\n free ( canon ) ;\n free ( ks_tuple ) ;\n }",
        "hash": 1676654288894940649,
        "project": "debian",
        "size": 51,
        "slice": {
            "memset": [
                [
                    1,
                    "void kadmin_modprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    10,
                    " if ( argc < 2 ) {\n"
                ],
                [
                    14,
                    " memset ( & oldprinc , 0 , sizeof ( oldprinc ) ) ;\n"
                ],
                [
                    15,
                    " memset ( & princ , 0 , sizeof ( princ ) ) ;\n"
                ],
                [
                    26,
                    " retval = kadm5_get_principal ( handle , kprinc , & oldprinc , KADM5_PRINCIPAL_NORMAL_MASK ) ;\n"
                ],
                [
                    31,
                    " princ . attributes = oldprinc . attributes ;\n"
                ],
                [
                    32,
                    " kadm5_free_principal_ent ( handle , & oldprinc ) ;\n"
                ],
                [
                    33,
                    " retval = kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , \"modify_principal\" ) ;\n"
                ],
                [
                    39,
                    " retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n"
                ],
                [
                    47,
                    " krb5_free_principal ( context , princ . principal ) ;\n"
                ],
                [
                    48,
                    " kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "void kadmin_modprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    6,
                    " char * pass , * canon = NULL ;\n"
                ],
                [
                    21,
                    " retval = krb5_unparse_name ( context , kprinc , & canon ) ;\n"
                ],
                [
                    41,
                    " if ( retval ) {\n"
                ],
                [
                    45,
                    " printf ( _ ( \"Principal \\\"%s\\\" modified.\\n\" ) , canon ) ;\n"
                ],
                [
                    49,
                    " free ( canon ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "void kadmin_modprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    6,
                    " char * pass , * canon = NULL ;\n"
                ],
                [
                    9,
                    " krb5_key_salt_tuple * ks_tuple = NULL ;\n"
                ],
                [
                    17,
                    " if ( retval ) {\n"
                ],
                [
                    21,
                    " retval = krb5_unparse_name ( context , kprinc , & canon ) ;\n"
                ],
                [
                    28,
                    " com_err ( \"modify_principal\" , retval , _ ( \"while getting \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    33,
                    " retval = kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , \"modify_principal\" ) ;\n"
                ],
                [
                    34,
                    " if ( retval || ks_tuple != NULL || randkey || pass ) {\n"
                ],
                [
                    42,
                    " com_err ( \"modify_principal\" , retval , _ ( \"while modifying \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    45,
                    " printf ( _ ( \"Principal \\\"%s\\\" modified.\\n\" ) , canon ) ;\n"
                ],
                [
                    49,
                    " free ( canon ) ;\n"
                ],
                [
                    50,
                    " free ( ks_tuple ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void kadmin_modprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    6,
                    " char * pass , * canon = NULL ;\n"
                ],
                [
                    9,
                    " krb5_key_salt_tuple * ks_tuple = NULL ;\n"
                ],
                [
                    10,
                    " if ( argc < 2 ) {\n"
                ],
                [
                    14,
                    " memset ( & oldprinc , 0 , sizeof ( oldprinc ) ) ;\n"
                ],
                [
                    15,
                    " memset ( & princ , 0 , sizeof ( princ ) ) ;\n"
                ],
                [
                    17,
                    " if ( retval ) {\n"
                ],
                [
                    21,
                    " retval = krb5_unparse_name ( context , kprinc , & canon ) ;\n"
                ],
                [
                    26,
                    " retval = kadm5_get_principal ( handle , kprinc , & oldprinc , KADM5_PRINCIPAL_NORMAL_MASK ) ;\n"
                ],
                [
                    28,
                    " com_err ( \"modify_principal\" , retval , _ ( \"while getting \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    31,
                    " princ . attributes = oldprinc . attributes ;\n"
                ],
                [
                    32,
                    " kadm5_free_principal_ent ( handle , & oldprinc ) ;\n"
                ],
                [
                    33,
                    " retval = kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , \"modify_principal\" ) ;\n"
                ],
                [
                    34,
                    " if ( retval || ks_tuple != NULL || randkey || pass ) {\n"
                ],
                [
                    39,
                    " retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n"
                ],
                [
                    41,
                    " if ( retval ) {\n"
                ],
                [
                    42,
                    " com_err ( \"modify_principal\" , retval , _ ( \"while modifying \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    45,
                    " printf ( _ ( \"Principal \\\"%s\\\" modified.\\n\" ) , canon ) ;\n"
                ],
                [
                    47,
                    " krb5_free_principal ( context , princ . principal ) ;\n"
                ],
                [
                    48,
                    " kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;\n"
                ],
                [
                    49,
                    " free ( canon ) ;\n"
                ],
                [
                    50,
                    " free ( ks_tuple ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void kadmin_addprinc ( int argc , char * argv [ ] ) {\n kadm5_principal_ent_rec princ ;\n kadm5_policy_ent_rec defpol ;\n long mask ;\n krb5_boolean randkey = FALSE , old_style_randkey = FALSE ;\n int n_ks_tuple ;\n krb5_key_salt_tuple * ks_tuple = NULL ;\n char * pass , * canon = NULL ;\n krb5_error_code retval ;\n char newpw [ 1024 ] , dummybuf [ 256 ] ;\n static char prompt1 [ 1024 ] , prompt2 [ 1024 ] ;\n memset ( & princ , 0 , sizeof ( princ ) ) ;\n princ . attributes = 0 ;\n if ( kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , \"add_principal\" ) ) {\n kadmin_addprinc_usage ( ) ;\n goto cleanup ;\n }\n retval = krb5_unparse_name ( context , princ . principal , & canon ) ;\n if ( retval ) {\n com_err ( \"add_principal\" , retval , _ ( \"while canonicalizing principal\" ) ) ;\n goto cleanup ;\n }\n if ( ! ( mask & KADM5_POLICY ) && ! ( mask & KADM5_POLICY_CLR ) ) {\n if ( ! kadm5_get_policy ( handle , \"default\" , & defpol ) ) {\n fprintf ( stderr , _ ( \"NOTICE: no policy specified for %s;\n \" \"assigning \\\"default\\\"\\n\" ) , canon ) ;\n princ . policy = \"default\" ;\n mask |= KADM5_POLICY ;\n kadm5_free_policy_ent ( handle , & defpol ) ;\n }\n else fprintf ( stderr , _ ( \"WARNING: no policy specified for %s;\n \" \"defaulting to no policy\\n\" ) , canon ) ;\n }\n mask &= ~ KADM5_POLICY_CLR ;\n if ( randkey ) {\n pass = NULL ;\n }\n else if ( pass == NULL ) {\n unsigned int sz = sizeof ( newpw ) - 1 ;\n snprintf ( prompt1 , sizeof ( prompt1 ) , _ ( \"Enter password for principal \\\"%s\\\"\" ) , canon ) ;\n snprintf ( prompt2 , sizeof ( prompt2 ) , _ ( \"Re-enter password for principal \\\"%s\\\"\" ) , canon ) ;\n retval = krb5_read_password ( context , prompt1 , prompt2 , newpw , & sz ) ;\n if ( retval ) {\n com_err ( \"add_principal\" , retval , _ ( \"while reading password for \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n pass = newpw ;\n }\n mask |= KADM5_PRINCIPAL ;\n retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n if ( retval == EINVAL && randkey ) {\n prepare_dummy_password ( dummybuf , sizeof ( dummybuf ) ) ;\n princ . attributes |= KRB5_KDB_DISALLOW_ALL_TIX ;\n mask |= KADM5_ATTRIBUTES ;\n pass = dummybuf ;\n retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n old_style_randkey = 1 ;\n }\n if ( retval ) {\n com_err ( \"add_principal\" , retval , \"while creating \\\"%s\\\".\" , canon ) ;\n goto cleanup ;\n }\n if ( old_style_randkey ) {\n retval = randkey_princ ( princ . principal , FALSE , n_ks_tuple , ks_tuple ) ;\n if ( retval ) {\n com_err ( \"add_principal\" , retval , _ ( \"while randomizing key for \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n princ . attributes &= ~ KRB5_KDB_DISALLOW_ALL_TIX ;\n mask = KADM5_ATTRIBUTES ;\n retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n if ( retval ) {\n com_err ( \"add_principal\" , retval , _ ( \"while clearing DISALLOW_ALL_TIX for \\\"%s\\\".\" ) , canon ) ;\n goto cleanup ;\n }\n }\n printf ( \"Principal \\\"%s\\\" created.\\n\" , canon ) ;\n cleanup : krb5_free_principal ( context , princ . principal ) ;\n free ( ks_tuple ) ;\n free ( canon ) ;\n kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;\n }",
        "hash": 1676654288894940649,
        "project": "debian",
        "size": 82,
        "slice": {
            "memset": [
                [
                    1,
                    "void kadmin_addprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    12,
                    " memset ( & princ , 0 , sizeof ( princ ) ) ;\n"
                ],
                [
                    14,
                    " if ( kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , \"add_principal\" ) ) {\n"
                ],
                [
                    18,
                    " retval = krb5_unparse_name ( context , princ . principal , & canon ) ;\n"
                ],
                [
                    50,
                    " retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n"
                ],
                [
                    53,
                    " princ . attributes |= KRB5_KDB_DISALLOW_ALL_TIX ;\n"
                ],
                [
                    56,
                    " retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n"
                ],
                [
                    64,
                    " retval = randkey_princ ( princ . principal , FALSE , n_ks_tuple , ks_tuple ) ;\n"
                ],
                [
                    69,
                    " princ . attributes &= ~ KRB5_KDB_DISALLOW_ALL_TIX ;\n"
                ],
                [
                    71,
                    " retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n"
                ],
                [
                    78,
                    " cleanup : krb5_free_principal ( context , princ . principal ) ;\n"
                ],
                [
                    81,
                    " kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "void kadmin_addprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    8,
                    " char * pass , * canon = NULL ;\n"
                ],
                [
                    18,
                    " retval = krb5_unparse_name ( context , princ . principal , & canon ) ;\n"
                ],
                [
                    41,
                    " snprintf ( prompt2 , sizeof ( prompt2 ) , _ ( \"Re-enter password for principal \\\"%s\\\"\" ) , canon ) ;\n"
                ],
                [
                    63,
                    " if ( old_style_randkey ) {\n"
                ],
                [
                    72,
                    " if ( retval ) {\n"
                ],
                [
                    77,
                    " printf ( \"Principal \\\"%s\\\" created.\\n\" , canon ) ;\n"
                ],
                [
                    80,
                    " free ( canon ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "void kadmin_addprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    7,
                    " krb5_key_salt_tuple * ks_tuple = NULL ;\n"
                ],
                [
                    8,
                    " char * pass , * canon = NULL ;\n"
                ],
                [
                    14,
                    " if ( kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , \"add_principal\" ) ) {\n"
                ],
                [
                    18,
                    " retval = krb5_unparse_name ( context , princ . principal , & canon ) ;\n"
                ],
                [
                    44,
                    " com_err ( \"add_principal\" , retval , _ ( \"while reading password for \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    50,
                    " retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n"
                ],
                [
                    56,
                    " retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n"
                ],
                [
                    60,
                    " com_err ( \"add_principal\" , retval , \"while creating \\\"%s\\\".\" , canon ) ;\n"
                ],
                [
                    64,
                    " retval = randkey_princ ( princ . principal , FALSE , n_ks_tuple , ks_tuple ) ;\n"
                ],
                [
                    66,
                    " com_err ( \"add_principal\" , retval , _ ( \"while randomizing key for \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    73,
                    " com_err ( \"add_principal\" , retval , _ ( \"while clearing DISALLOW_ALL_TIX for \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    77,
                    " printf ( \"Principal \\\"%s\\\" created.\\n\" , canon ) ;\n"
                ],
                [
                    79,
                    " free ( ks_tuple ) ;\n"
                ],
                [
                    80,
                    " free ( canon ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void kadmin_addprinc ( int argc , char * argv [ ] ) {\n"
                ],
                [
                    7,
                    " krb5_key_salt_tuple * ks_tuple = NULL ;\n"
                ],
                [
                    8,
                    " char * pass , * canon = NULL ;\n"
                ],
                [
                    12,
                    " memset ( & princ , 0 , sizeof ( princ ) ) ;\n"
                ],
                [
                    14,
                    " if ( kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , \"add_principal\" ) ) {\n"
                ],
                [
                    18,
                    " retval = krb5_unparse_name ( context , princ . principal , & canon ) ;\n"
                ],
                [
                    41,
                    " snprintf ( prompt2 , sizeof ( prompt2 ) , _ ( \"Re-enter password for principal \\\"%s\\\"\" ) , canon ) ;\n"
                ],
                [
                    44,
                    " com_err ( \"add_principal\" , retval , _ ( \"while reading password for \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    50,
                    " retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n"
                ],
                [
                    53,
                    " princ . attributes |= KRB5_KDB_DISALLOW_ALL_TIX ;\n"
                ],
                [
                    56,
                    " retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n"
                ],
                [
                    60,
                    " com_err ( \"add_principal\" , retval , \"while creating \\\"%s\\\".\" , canon ) ;\n"
                ],
                [
                    63,
                    " if ( old_style_randkey ) {\n"
                ],
                [
                    64,
                    " retval = randkey_princ ( princ . principal , FALSE , n_ks_tuple , ks_tuple ) ;\n"
                ],
                [
                    66,
                    " com_err ( \"add_principal\" , retval , _ ( \"while randomizing key for \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    69,
                    " princ . attributes &= ~ KRB5_KDB_DISALLOW_ALL_TIX ;\n"
                ],
                [
                    71,
                    " retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n"
                ],
                [
                    72,
                    " if ( retval ) {\n"
                ],
                [
                    73,
                    " com_err ( \"add_principal\" , retval , _ ( \"while clearing DISALLOW_ALL_TIX for \\\"%s\\\".\" ) , canon ) ;\n"
                ],
                [
                    77,
                    " printf ( \"Principal \\\"%s\\\" created.\\n\" , canon ) ;\n"
                ],
                [
                    78,
                    " cleanup : krb5_free_principal ( context , princ . principal ) ;\n"
                ],
                [
                    79,
                    " free ( ks_tuple ) ;\n"
                ],
                [
                    80,
                    " free ( canon ) ;\n"
                ],
                [
                    81,
                    " kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : gctx -> key_set = 0 ;\n gctx -> iv_set = 0 ;\n gctx -> ivlen = EVP_CIPHER_CTX_iv_length ( c ) ;\n gctx -> iv = EVP_CIPHER_CTX_iv_noconst ( c ) ;\n gctx -> taglen = - 1 ;\n gctx -> iv_gen = 0 ;\n gctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 ) return 0 ;\n if ( ( arg > EVP_MAX_IV_LENGTH ) && ( arg > gctx -> ivlen ) ) {\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n gctx -> iv = OPENSSL_malloc ( arg ) ;\n if ( gctx -> iv == NULL ) return 0 ;\n }\n gctx -> ivlen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> taglen = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n }\n if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n gctx -> iv_gen = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n if ( arg <= 0 || arg > gctx -> ivlen ) arg = gctx -> ivlen ;\n memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n CRYPTO_gcm128_setiv ( & gctx -> gcm , gctx -> iv , gctx -> ivlen ) ;\n gctx -> iv_set = 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n gctx -> tls_aad_len = arg ;\n {\n unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n len -= EVP_GCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= EVP_GCM_TLS_TAG_LEN ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return EVP_GCM_TLS_TAG_LEN ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n if ( gctx -> gcm . key ) {\n if ( gctx -> gcm . key != & gctx -> ks ) return 0 ;\n gctx_out -> gcm . key = & gctx_out -> ks ;\n }\n if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n else {\n gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n if ( gctx_out -> iv == NULL ) return 0 ;\n memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }",
        "hash": 8801969307247112896,
        "project": "debian",
        "size": 77,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n"
                ],
                [
                    2,
                    " EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n"
                ],
                [
                    20,
                    " case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n"
                ],
                [
                    21,
                    " memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    22,
                    " gctx -> taglen = arg ;\n"
                ],
                [
                    24,
                    " case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n"
                ],
                [
                    25,
                    " memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n"
                ],
                [
                    27,
                    " case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n"
                ],
                [
                    28,
                    " memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n"
                ],
                [
                    32,
                    " if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n"
                ],
                [
                    33,
                    " if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n"
                ],
                [
                    34,
                    " if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n"
                ],
                [
                    37,
                    " case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n"
                ],
                [
                    40,
                    " memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n"
                ],
                [
                    44,
                    " case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n"
                ],
                [
                    45,
                    " memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n"
                ],
                [
                    49,
                    " case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n"
                ],
                [
                    50,
                    " memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    51,
                    " gctx -> tls_aad_len = arg ;\n"
                ],
                [
                    53,
                    " unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n"
                ],
                [
                    62,
                    " EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n"
                ],
                [
                    67,
                    " if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n"
                ],
                [
                    69,
                    " gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n"
                ],
                [
                    70,
                    " if ( gctx_out -> iv == NULL ) return 0 ;\n"
                ],
                [
                    71,
                    " memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n"
                ],
                [
                    2,
                    " EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n"
                ],
                [
                    20,
                    " case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n"
                ],
                [
                    21,
                    " memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    22,
                    " gctx -> taglen = arg ;\n"
                ],
                [
                    24,
                    " case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n"
                ],
                [
                    25,
                    " memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n"
                ],
                [
                    27,
                    " case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n"
                ],
                [
                    28,
                    " memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n"
                ],
                [
                    32,
                    " if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n"
                ],
                [
                    33,
                    " if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n"
                ],
                [
                    34,
                    " if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n"
                ],
                [
                    37,
                    " case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n"
                ],
                [
                    40,
                    " memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n"
                ],
                [
                    44,
                    " case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n"
                ],
                [
                    45,
                    " memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n"
                ],
                [
                    49,
                    " case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n"
                ],
                [
                    50,
                    " memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    51,
                    " gctx -> tls_aad_len = arg ;\n"
                ],
                [
                    53,
                    " unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n"
                ],
                [
                    62,
                    " EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n"
                ],
                [
                    67,
                    " if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n"
                ],
                [
                    69,
                    " gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n"
                ],
                [
                    70,
                    " if ( gctx_out -> iv == NULL ) return 0 ;\n"
                ],
                [
                    71,
                    " memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : cctx -> key_set = 0 ;\n cctx -> iv_set = 0 ;\n cctx -> L = 8 ;\n cctx -> M = 12 ;\n cctx -> tag_set = 0 ;\n cctx -> len_set = 0 ;\n cctx -> tls_aad_len = - 1 ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n cctx -> tls_aad_len = arg ;\n {\n uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ;\n if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= cctx -> M ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n }\n return cctx -> M ;\n case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ;\n memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ;\n case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ;\n cctx -> L = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ;\n if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ;\n if ( ptr ) {\n cctx -> tag_set = 1 ;\n memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n }\n cctx -> M = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ;\n if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ;\n cctx -> tag_set = 0 ;\n cctx -> iv_set = 0 ;\n cctx -> len_set = 0 ;\n return 1 ;\n case EVP_CTRL_COPY : {\n EVP_CIPHER_CTX * out = ptr ;\n EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ;\n if ( cctx -> ccm . key ) {\n if ( cctx -> ccm . key != & cctx -> ks ) return 0 ;\n cctx_out -> ccm . key = & cctx_out -> ks ;\n }\n return 1 ;\n }\n default : return - 1 ;\n }\n }",
        "hash": 8801969307247112896,
        "project": "debian",
        "size": 55,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n"
                ],
                [
                    12,
                    " case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n"
                ],
                [
                    13,
                    " memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    14,
                    " cctx -> tls_aad_len = arg ;\n"
                ],
                [
                    16,
                    " uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n"
                ],
                [
                    23,
                    " case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ;\n"
                ],
                [
                    24,
                    " memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    30,
                    " case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ;\n"
                ],
                [
                    31,
                    " if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ;\n"
                ],
                [
                    32,
                    " if ( ptr ) {\n"
                ],
                [
                    34,
                    " memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    36,
                    " cctx -> M = arg ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n"
                ],
                [
                    12,
                    " case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n"
                ],
                [
                    13,
                    " memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    14,
                    " cctx -> tls_aad_len = arg ;\n"
                ],
                [
                    16,
                    " uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n"
                ],
                [
                    23,
                    " case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ;\n"
                ],
                [
                    24,
                    " memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    30,
                    " case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ;\n"
                ],
                [
                    31,
                    " if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ;\n"
                ],
                [
                    32,
                    " if ( ptr ) {\n"
                ],
                [
                    34,
                    " memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n"
                ],
                [
                    36,
                    " cctx -> M = arg ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) {\n EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n switch ( type ) {\n case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ;\n if ( actx == NULL ) {\n EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ;\n return 0 ;\n }\n actx -> len . aad = 0 ;\n actx -> len . text = 0 ;\n actx -> aad = 0 ;\n actx -> mac_inited = 0 ;\n actx -> tag_len = 0 ;\n actx -> nonce_len = 12 ;\n actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ;\n return 1 ;\n case EVP_CTRL_COPY : if ( actx ) {\n EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ;\n dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ;\n if ( dst -> cipher_data == NULL ) {\n EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ;\n return 0 ;\n }\n }\n return 1 ;\n case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ;\n actx -> nonce_len = arg ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ;\n actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ;\n actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ;\n actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ;\n return 1 ;\n case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ;\n if ( ptr != NULL ) {\n memcpy ( actx -> tag , ptr , arg ) ;\n actx -> tag_len = arg ;\n }\n return 1 ;\n case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ;\n memcpy ( ptr , actx -> tag , arg ) ;\n return 1 ;\n case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n {\n unsigned int len ;\n unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ;\n len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ;\n if ( ! ctx -> encrypt ) {\n len -= POLY1305_BLOCK_SIZE ;\n memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;\n aad = temp ;\n temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ;\n temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ;\n }\n actx -> tls_payload_length = len ;\n actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ;\n actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ;\n actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ;\n actx -> mac_inited = 0 ;\n chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ;\n return POLY1305_BLOCK_SIZE ;\n }\n case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ;\n default : return - 1 ;\n }\n }",
        "hash": -1763326842639388875,
        "project": "debian",
        "size": 66,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) {\n"
                ],
                [
                    2,
                    " EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n"
                ],
                [
                    34,
                    " case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ;\n"
                ],
                [
                    35,
                    " if ( ptr != NULL ) {\n"
                ],
                [
                    36,
                    " memcpy ( actx -> tag , ptr , arg ) ;\n"
                ],
                [
                    37,
                    " actx -> tag_len = arg ;\n"
                ],
                [
                    40,
                    " case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ;\n"
                ],
                [
                    41,
                    " memcpy ( ptr , actx -> tag , arg ) ;\n"
                ],
                [
                    46,
                    " unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ;\n"
                ],
                [
                    47,
                    " len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ;\n"
                ],
                [
                    48,
                    " if ( ! ctx -> encrypt ) {\n"
                ],
                [
                    50,
                    " memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;\n"
                ],
                [
                    51,
                    " aad = temp ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) {\n"
                ],
                [
                    2,
                    " EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n"
                ],
                [
                    34,
                    " case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ;\n"
                ],
                [
                    35,
                    " if ( ptr != NULL ) {\n"
                ],
                [
                    36,
                    " memcpy ( actx -> tag , ptr , arg ) ;\n"
                ],
                [
                    37,
                    " actx -> tag_len = arg ;\n"
                ],
                [
                    40,
                    " case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ;\n"
                ],
                [
                    41,
                    " memcpy ( ptr , actx -> tag , arg ) ;\n"
                ],
                [
                    46,
                    " unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ;\n"
                ],
                [
                    47,
                    " len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ;\n"
                ],
                [
                    48,
                    " if ( ! ctx -> encrypt ) {\n"
                ],
                [
                    50,
                    " memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;\n"
                ],
                [
                    51,
                    " aad = temp ;\n"
                ]
            ]
        }
    },
    {
        "code": "static PGconn * _connectDB ( ArchiveHandle * AH , const char * reqdb , const char * requser ) {\n PGconn * newConn ;\n const char * newdb ;\n const char * newuser ;\n char * password ;\n bool new_pass ;\n if ( ! reqdb ) newdb = PQdb ( AH -> connection ) ;\n else newdb = reqdb ;\n if ( ! requser || strlen ( requser ) == 0 ) newuser = PQuser ( AH -> connection ) ;\n else newuser = requser ;\n ahlog ( AH , 1 , \"connecting to database \\\"%s\\\" as user \\\"%s\\\"\\n\" , newdb , newuser ) ;\n password = AH -> savedPassword ? pg_strdup ( AH -> savedPassword ) : NULL ;\n if ( AH -> promptPassword == TRI_YES && password == NULL ) {\n password = simple_prompt ( \"Password: \" , 100 , false ) ;\n if ( password == NULL ) exit_horribly ( modulename , \"out of memory\\n\" ) ;\n }\n do {\n const char * keywords [ 7 ] ;\n const char * values [ 7 ] ;\n keywords [ 0 ] = \"host\" ;\n values [ 0 ] = PQhost ( AH -> connection ) ;\n keywords [ 1 ] = \"port\" ;\n values [ 1 ] = PQport ( AH -> connection ) ;\n keywords [ 2 ] = \"user\" ;\n values [ 2 ] = newuser ;\n keywords [ 3 ] = \"password\" ;\n values [ 3 ] = password ;\n keywords [ 4 ] = \"dbname\" ;\n values [ 4 ] = newdb ;\n keywords [ 5 ] = \"fallback_application_name\" ;\n values [ 5 ] = progname ;\n keywords [ 6 ] = NULL ;\n values [ 6 ] = NULL ;\n new_pass = false ;\n newConn = PQconnectdbParams ( keywords , values , true ) ;\n if ( ! newConn ) exit_horribly ( modulename , \"failed to reconnect to database\\n\" ) ;\n if ( PQstatus ( newConn ) == CONNECTION_BAD ) {\n if ( ! PQconnectionNeedsPassword ( newConn ) ) exit_horribly ( modulename , \"could not reconnect to database: %s\" , PQerrorMessage ( newConn ) ) ;\n PQfinish ( newConn ) ;\n if ( password ) fprintf ( stderr , \"Password incorrect\\n\" ) ;\n fprintf ( stderr , \"Connecting to %s as %s\\n\" , newdb , newuser ) ;\n if ( password ) free ( password ) ;\n if ( AH -> promptPassword != TRI_NO ) password = simple_prompt ( \"Password: \" , 100 , false ) ;\n else exit_horribly ( modulename , \"connection needs password\\n\" ) ;\n if ( password == NULL ) exit_horribly ( modulename , \"out of memory\\n\" ) ;\n new_pass = true ;\n }\n }\n while ( new_pass ) ;\n if ( PQconnectionUsedPassword ( newConn ) ) {\n if ( AH -> savedPassword ) free ( AH -> savedPassword ) ;\n AH -> savedPassword = pg_strdup ( PQpass ( newConn ) ) ;\n }\n if ( password ) free ( password ) ;\n _check_database_version ( AH ) ;\n PQsetNoticeProcessor ( newConn , notice_processor , NULL ) ;\n return newConn ;\n }",
        "hash": -5550748970150309774,
        "project": "debian",
        "size": 58,
        "slice": {
            "strlen": [
                [
                    1,
                    "static PGconn * _connectDB ( ArchiveHandle * AH , const char * reqdb , const char * requser ) {\n"
                ],
                [
                    9,
                    " if ( ! requser || strlen ( requser ) == 0 ) newuser = PQuser ( AH -> connection ) ;\n"
                ],
                [
                    10,
                    " else newuser = requser ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static PGconn * _connectDB ( ArchiveHandle * AH , const char * reqdb , const char * requser ) {\n"
                ],
                [
                    11,
                    " ahlog ( AH , 1 , \"connecting to database \\\"%s\\\" as user \\\"%s\\\"\\n\" , newdb , newuser ) ;\n"
                ],
                [
                    25,
                    " values [ 2 ] = newuser ;\n"
                ],
                [
                    29,
                    " values [ 4 ] = newdb ;\n"
                ],
                [
                    37,
                    " if ( PQstatus ( newConn ) == CONNECTION_BAD ) {\n"
                ],
                [
                    40,
                    " if ( password ) fprintf ( stderr , \"Password incorrect\\n\" ) ;\n"
                ],
                [
                    41,
                    " fprintf ( stderr , \"Connecting to %s as %s\\n\" , newdb , newuser ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static PGconn * _connectDB ( ArchiveHandle * AH , const char * reqdb , const char * requser ) {\n"
                ],
                [
                    11,
                    " ahlog ( AH , 1 , \"connecting to database \\\"%s\\\" as user \\\"%s\\\"\\n\" , newdb , newuser ) ;\n"
                ],
                [
                    12,
                    " password = AH -> savedPassword ? pg_strdup ( AH -> savedPassword ) : NULL ;\n"
                ],
                [
                    13,
                    " if ( AH -> promptPassword == TRI_YES && password == NULL ) {\n"
                ],
                [
                    15,
                    " if ( password == NULL ) exit_horribly ( modulename , \"out of memory\\n\" ) ;\n"
                ],
                [
                    42,
                    " if ( password ) free ( password ) ;\n"
                ],
                [
                    45,
                    " if ( password == NULL ) exit_horribly ( modulename , \"out of memory\\n\" ) ;\n"
                ],
                [
                    51,
                    " if ( AH -> savedPassword ) free ( AH -> savedPassword ) ;\n"
                ],
                [
                    54,
                    " if ( password ) free ( password ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static PGconn * _connectDB ( ArchiveHandle * AH , const char * reqdb , const char * requser ) {\n"
                ],
                [
                    9,
                    " if ( ! requser || strlen ( requser ) == 0 ) newuser = PQuser ( AH -> connection ) ;\n"
                ],
                [
                    10,
                    " else newuser = requser ;\n"
                ],
                [
                    11,
                    " ahlog ( AH , 1 , \"connecting to database \\\"%s\\\" as user \\\"%s\\\"\\n\" , newdb , newuser ) ;\n"
                ],
                [
                    12,
                    " password = AH -> savedPassword ? pg_strdup ( AH -> savedPassword ) : NULL ;\n"
                ],
                [
                    13,
                    " if ( AH -> promptPassword == TRI_YES && password == NULL ) {\n"
                ],
                [
                    15,
                    " if ( password == NULL ) exit_horribly ( modulename , \"out of memory\\n\" ) ;\n"
                ],
                [
                    25,
                    " values [ 2 ] = newuser ;\n"
                ],
                [
                    29,
                    " values [ 4 ] = newdb ;\n"
                ],
                [
                    37,
                    " if ( PQstatus ( newConn ) == CONNECTION_BAD ) {\n"
                ],
                [
                    40,
                    " if ( password ) fprintf ( stderr , \"Password incorrect\\n\" ) ;\n"
                ],
                [
                    41,
                    " fprintf ( stderr , \"Connecting to %s as %s\\n\" , newdb , newuser ) ;\n"
                ],
                [
                    42,
                    " if ( password ) free ( password ) ;\n"
                ],
                [
                    45,
                    " if ( password == NULL ) exit_horribly ( modulename , \"out of memory\\n\" ) ;\n"
                ],
                [
                    51,
                    " if ( AH -> savedPassword ) free ( AH -> savedPassword ) ;\n"
                ],
                [
                    54,
                    " if ( password ) free ( password ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {\n PGconn * conn ;\n PGresult * result ;\n int i ;\n conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n result = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\n\" , progname , echo ) ;\n PQfinish ( conn ) ;\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n char * dbname = PQgetvalue ( result , i , 0 ) ;\n if ( ! quiet ) {\n printf ( _ ( \"%s: reindexing database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n fflush ( stdout ) ;\n }\n reindex_one_database ( dbname , dbname , \"DATABASE\" , host , port , username , prompt_password , progname , echo , verbose ) ;\n }\n PQclear ( result ) ;\n }",
        "hash": -4872400287267974771,
        "project": "debian",
        "size": 20,
        "slice": {
            "printf": [
                [
                    1,
                    "static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {\n"
                ],
                [
                    5,
                    " conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n"
                ],
                [
                    12,
                    " char * dbname = PQgetvalue ( result , i , 0 ) ;\n"
                ],
                [
                    13,
                    " if ( ! quiet ) {\n"
                ],
                [
                    14,
                    " printf ( _ ( \"%s: reindexing database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    17,
                    " reindex_one_database ( dbname , dbname , \"DATABASE\" , host , port , username , prompt_password , progname , echo , verbose ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {\n"
                ],
                [
                    5,
                    " conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n"
                ],
                [
                    12,
                    " char * dbname = PQgetvalue ( result , i , 0 ) ;\n"
                ],
                [
                    13,
                    " if ( ! quiet ) {\n"
                ],
                [
                    14,
                    " printf ( _ ( \"%s: reindexing database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    17,
                    " reindex_one_database ( dbname , dbname , \"DATABASE\" , host , port , username , prompt_password , progname , echo , verbose ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void cluster_all_databases ( bool verbose , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet ) {\n PGconn * conn ;\n PGresult * result ;\n int i ;\n conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n result = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\n\" , progname , echo ) ;\n PQfinish ( conn ) ;\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n char * dbname = PQgetvalue ( result , i , 0 ) ;\n if ( ! quiet ) {\n printf ( _ ( \"%s: clustering database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n fflush ( stdout ) ;\n }\n cluster_one_database ( dbname , verbose , NULL , host , port , username , prompt_password , progname , echo ) ;\n }\n PQclear ( result ) ;\n }",
        "hash": -8041308796088637266,
        "project": "debian",
        "size": 20,
        "slice": {
            "printf": [
                [
                    1,
                    "static void cluster_all_databases ( bool verbose , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet ) {\n"
                ],
                [
                    5,
                    " conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n"
                ],
                [
                    12,
                    " char * dbname = PQgetvalue ( result , i , 0 ) ;\n"
                ],
                [
                    13,
                    " if ( ! quiet ) {\n"
                ],
                [
                    14,
                    " printf ( _ ( \"%s: clustering database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    17,
                    " cluster_one_database ( dbname , verbose , NULL , host , port , username , prompt_password , progname , echo ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void cluster_all_databases ( bool verbose , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet ) {\n"
                ],
                [
                    5,
                    " conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n"
                ],
                [
                    12,
                    " char * dbname = PQgetvalue ( result , i , 0 ) ;\n"
                ],
                [
                    13,
                    " if ( ! quiet ) {\n"
                ],
                [
                    14,
                    " printf ( _ ( \"%s: clustering database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    17,
                    " cluster_one_database ( dbname , verbose , NULL , host , port , username , prompt_password , progname , echo ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "PGconn * GetConnection ( void ) {\n PGconn * tmpconn ;\n int argcount = 7 ;\n int i ;\n const char * * keywords ;\n const char * * values ;\n const char * tmpparam ;\n bool need_password ;\n PQconninfoOption * conn_opts = NULL ;\n PQconninfoOption * conn_opt ;\n char * err_msg = NULL ;\n i = 0 ;\n if ( connection_string ) {\n conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n if ( conn_opts == NULL ) {\n fprintf ( stderr , \"%s: %s\" , progname , err_msg ) ;\n exit ( 1 ) ;\n }\n for ( conn_opt = conn_opts ;\n conn_opt -> keyword != NULL ;\n conn_opt ++ ) {\n if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\\0' ) argcount ++ ;\n }\n keywords = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * keywords ) ) ;\n values = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * values ) ) ;\n for ( conn_opt = conn_opts ;\n conn_opt -> keyword != NULL ;\n conn_opt ++ ) {\n if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\\0' ) {\n keywords [ i ] = conn_opt -> keyword ;\n values [ i ] = conn_opt -> val ;\n i ++ ;\n }\n }\n }\n else {\n keywords = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * keywords ) ) ;\n values = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * values ) ) ;\n }\n keywords [ i ] = \"dbname\" ;\n values [ i ] = dbname == NULL ? \"replication\" : dbname ;\n i ++ ;\n keywords [ i ] = \"replication\" ;\n values [ i ] = dbname == NULL ? \"true\" : \"database\" ;\n i ++ ;\n keywords [ i ] = \"fallback_application_name\" ;\n values [ i ] = progname ;\n i ++ ;\n if ( dbhost ) {\n keywords [ i ] = \"host\" ;\n values [ i ] = dbhost ;\n i ++ ;\n }\n if ( dbuser ) {\n keywords [ i ] = \"user\" ;\n values [ i ] = dbuser ;\n i ++ ;\n }\n if ( dbport ) {\n keywords [ i ] = \"port\" ;\n values [ i ] = dbport ;\n i ++ ;\n }\n need_password = ( dbgetpassword == 1 && dbpassword == NULL ) ;\n do {\n if ( need_password ) {\n if ( dbpassword ) free ( dbpassword ) ;\n dbpassword = simple_prompt ( _ ( \"Password: \" ) , 100 , false ) ;\n need_password = false ;\n }\n if ( dbpassword ) {\n keywords [ i ] = \"password\" ;\n values [ i ] = dbpassword ;\n }\n else {\n keywords [ i ] = NULL ;\n values [ i ] = NULL ;\n }\n tmpconn = PQconnectdbParams ( keywords , values , true ) ;\n if ( ! tmpconn ) {\n fprintf ( stderr , _ ( \"%s: could not connect to server\\n\" ) , progname ) ;\n exit ( 1 ) ;\n }\n if ( PQstatus ( tmpconn ) == CONNECTION_BAD && PQconnectionNeedsPassword ( tmpconn ) && dbgetpassword != - 1 ) {\n PQfinish ( tmpconn ) ;\n need_password = true ;\n }\n }\n while ( need_password ) ;\n if ( PQstatus ( tmpconn ) != CONNECTION_OK ) {\n fprintf ( stderr , _ ( \"%s: could not connect to server: %s\" ) , progname , PQerrorMessage ( tmpconn ) ) ;\n PQfinish ( tmpconn ) ;\n free ( values ) ;\n free ( keywords ) ;\n if ( conn_opts ) PQconninfoFree ( conn_opts ) ;\n return NULL ;\n }\n free ( values ) ;\n free ( keywords ) ;\n if ( conn_opts ) PQconninfoFree ( conn_opts ) ;\n tmpparam = PQparameterStatus ( tmpconn , \"integer_datetimes\" ) ;\n if ( ! tmpparam ) {\n fprintf ( stderr , _ ( \"%s: could not determine server setting for integer_datetimes\\n\" ) , progname ) ;\n PQfinish ( tmpconn ) ;\n exit ( 1 ) ;\n }\n # ifdef HAVE_INT64_TIMESTAMP if ( strcmp ( tmpparam , \"on\" ) != 0 ) # else if ( strcmp ( tmpparam , \"off\" ) != 0 ) # endif {\n fprintf ( stderr , _ ( \"%s: integer_datetimes compile flag does not match server\\n\" ) , progname ) ;\n PQfinish ( tmpconn ) ;\n exit ( 1 ) ;\n }\n return tmpconn ;\n }",
        "hash": 7545838748510052337,
        "project": "debian",
        "size": 113,
        "slice": {
            "fprintf": [
                [
                    1,
                    "PGconn * GetConnection ( void ) {\n"
                ],
                [
                    11,
                    " char * err_msg = NULL ;\n"
                ],
                [
                    14,
                    " conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n"
                ],
                [
                    15,
                    " if ( conn_opts == NULL ) {\n"
                ],
                [
                    16,
                    " fprintf ( stderr , \"%s: %s\" , progname , err_msg ) ;\n"
                ],
                [
                    47,
                    " values [ i ] = progname ;\n"
                ],
                [
                    80,
                    " if ( ! tmpconn ) {\n"
                ],
                [
                    81,
                    " fprintf ( stderr , _ ( \"%s: could not connect to server\\n\" ) , progname ) ;\n"
                ],
                [
                    90,
                    " if ( PQstatus ( tmpconn ) != CONNECTION_OK ) {\n"
                ],
                [
                    91,
                    " fprintf ( stderr , _ ( \"%s: could not connect to server: %s\" ) , progname , PQerrorMessage ( tmpconn ) ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "PGconn * GetConnection ( void ) {\n"
                ],
                [
                    64,
                    " need_password = ( dbgetpassword == 1 && dbpassword == NULL ) ;\n"
                ],
                [
                    67,
                    " if ( dbpassword ) free ( dbpassword ) ;\n"
                ],
                [
                    68,
                    " dbpassword = simple_prompt ( _ ( \"Password: \" ) , 100 , false ) ;\n"
                ],
                [
                    72,
                    " keywords [ i ] = \"password\" ;\n"
                ],
                [
                    73,
                    " values [ i ] = dbpassword ;\n"
                ],
                [
                    76,
                    " keywords [ i ] = NULL ;\n"
                ],
                [
                    77,
                    " values [ i ] = NULL ;\n"
                ],
                [
                    79,
                    " tmpconn = PQconnectdbParams ( keywords , values , true ) ;\n"
                ],
                [
                    90,
                    " if ( PQstatus ( tmpconn ) != CONNECTION_OK ) {\n"
                ],
                [
                    93,
                    " free ( values ) ;\n"
                ],
                [
                    94,
                    " free ( keywords ) ;\n"
                ],
                [
                    98,
                    " free ( values ) ;\n"
                ],
                [
                    99,
                    " free ( keywords ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "PGconn * GetConnection ( void ) {\n"
                ],
                [
                    11,
                    " char * err_msg = NULL ;\n"
                ],
                [
                    14,
                    " conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n"
                ],
                [
                    15,
                    " if ( conn_opts == NULL ) {\n"
                ],
                [
                    16,
                    " fprintf ( stderr , \"%s: %s\" , progname , err_msg ) ;\n"
                ],
                [
                    47,
                    " values [ i ] = progname ;\n"
                ],
                [
                    64,
                    " need_password = ( dbgetpassword == 1 && dbpassword == NULL ) ;\n"
                ],
                [
                    67,
                    " if ( dbpassword ) free ( dbpassword ) ;\n"
                ],
                [
                    68,
                    " dbpassword = simple_prompt ( _ ( \"Password: \" ) , 100 , false ) ;\n"
                ],
                [
                    72,
                    " keywords [ i ] = \"password\" ;\n"
                ],
                [
                    73,
                    " values [ i ] = dbpassword ;\n"
                ],
                [
                    76,
                    " keywords [ i ] = NULL ;\n"
                ],
                [
                    77,
                    " values [ i ] = NULL ;\n"
                ],
                [
                    79,
                    " tmpconn = PQconnectdbParams ( keywords , values , true ) ;\n"
                ],
                [
                    80,
                    " if ( ! tmpconn ) {\n"
                ],
                [
                    81,
                    " fprintf ( stderr , _ ( \"%s: could not connect to server\\n\" ) , progname ) ;\n"
                ],
                [
                    90,
                    " if ( PQstatus ( tmpconn ) != CONNECTION_OK ) {\n"
                ],
                [
                    91,
                    " fprintf ( stderr , _ ( \"%s: could not connect to server: %s\" ) , progname , PQerrorMessage ( tmpconn ) ) ;\n"
                ],
                [
                    93,
                    " free ( values ) ;\n"
                ],
                [
                    94,
                    " free ( keywords ) ;\n"
                ],
                [
                    98,
                    " free ( values ) ;\n"
                ],
                [
                    99,
                    " free ( keywords ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void _reconnectToDB ( ArchiveHandle * AH , const char * dbname ) {\n if ( RestoringToDB ( AH ) ) ReconnectToServer ( AH , dbname , NULL ) ;\n else {\n PQExpBuffer qry = createPQExpBuffer ( ) ;\n appendPQExpBuffer ( qry , \"\\\\connect %s\\n\\n\" , dbname ? fmtId ( dbname ) : \"-\" ) ;\n ahprintf ( AH , \"%s\" , qry -> data ) ;\n destroyPQExpBuffer ( qry ) ;\n }\n if ( AH -> currUser ) free ( AH -> currUser ) ;\n AH -> currUser = NULL ;\n if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n AH -> currSchema = NULL ;\n if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;\n AH -> currTablespace = NULL ;\n AH -> currWithOids = - 1 ;\n _doSetFixedOutputState ( AH ) ;\n }",
        "hash": -8028756826159773630,
        "project": "debian",
        "size": 17,
        "slice": {
            "free": [
                [
                    2,
                    " if ( RestoringToDB ( AH ) ) ReconnectToServer ( AH , dbname , NULL ) ;\n"
                ],
                [
                    6,
                    " ahprintf ( AH , \"%s\" , qry -> data ) ;\n"
                ],
                [
                    9,
                    " if ( AH -> currUser ) free ( AH -> currUser ) ;\n"
                ],
                [
                    11,
                    " if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n"
                ],
                [
                    13,
                    " if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;\n"
                ]
            ],
            "result": [
                [
                    2,
                    " if ( RestoringToDB ( AH ) ) ReconnectToServer ( AH , dbname , NULL ) ;\n"
                ],
                [
                    6,
                    " ahprintf ( AH , \"%s\" , qry -> data ) ;\n"
                ],
                [
                    9,
                    " if ( AH -> currUser ) free ( AH -> currUser ) ;\n"
                ],
                [
                    11,
                    " if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n"
                ],
                [
                    13,
                    " if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int restore_toc_entry ( ArchiveHandle * AH , TocEntry * te , bool is_parallel ) {\n RestoreOptions * ropt = AH -> public . ropt ;\n int status = WORKER_OK ;\n teReqs reqs ;\n bool defnDumped ;\n AH -> currentTE = te ;\n if ( _tocEntryIsACL ( te ) ) reqs = 0 ;\n else reqs = te -> reqs ;\n if ( ! ropt -> createDB && strcmp ( te -> desc , \"DATABASE\" ) == 0 ) reqs = 0 ;\n if ( ! ropt -> suppressDumpWarnings && strcmp ( te -> desc , \"WARNING\" ) == 0 ) {\n if ( ! ropt -> dataOnly && te -> defn != NULL && strlen ( te -> defn ) != 0 ) write_msg ( modulename , \"warning from original dump file: %s\\n\" , te -> defn ) ;\n else if ( te -> copyStmt != NULL && strlen ( te -> copyStmt ) != 0 ) write_msg ( modulename , \"warning from original dump file: %s\\n\" , te -> copyStmt ) ;\n }\n defnDumped = false ;\n if ( ( reqs & REQ_SCHEMA ) != 0 ) {\n if ( te -> namespace ) ahlog ( AH , 1 , \"creating %s \\\"%s.%s\\\"\\n\" , te -> desc , te -> namespace , te -> tag ) ;\n else ahlog ( AH , 1 , \"creating %s \\\"%s\\\"\\n\" , te -> desc , te -> tag ) ;\n _printTocEntry ( AH , te , false , false ) ;\n defnDumped = true ;\n if ( strcmp ( te -> desc , \"TABLE\" ) == 0 ) {\n if ( AH -> lastErrorTE == te ) {\n if ( ropt -> noDataForFailedTables ) {\n if ( is_parallel ) status = WORKER_INHIBIT_DATA ;\n else inhibit_data_for_failed_table ( AH , te ) ;\n }\n }\n else {\n if ( is_parallel ) status = WORKER_CREATE_DONE ;\n else mark_create_done ( AH , te ) ;\n }\n }\n if ( strcmp ( te -> desc , \"DATABASE\" ) == 0 ) {\n ahlog ( AH , 1 , \"connecting to new database \\\"%s\\\"\\n\" , te -> tag ) ;\n _reconnectToDB ( AH , te -> tag ) ;\n ropt -> dbname = pg_strdup ( te -> tag ) ;\n }\n }\n if ( ( reqs & REQ_DATA ) != 0 ) {\n if ( te -> hadDumper ) {\n if ( AH -> PrintTocDataPtr != NULL ) {\n _printTocEntry ( AH , te , true , false ) ;\n if ( strcmp ( te -> desc , \"BLOBS\" ) == 0 || strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 ) {\n ahlog ( AH , 1 , \"processing %s\\n\" , te -> desc ) ;\n _selectOutputSchema ( AH , \"pg_catalog\" ) ;\n if ( strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 ) AH -> outputKind = OUTPUT_OTHERDATA ;\n ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n AH -> outputKind = OUTPUT_SQLCMDS ;\n }\n else {\n _disableTriggersIfNecessary ( AH , te ) ;\n _becomeOwner ( AH , te ) ;\n _selectOutputSchema ( AH , te -> namespace ) ;\n ahlog ( AH , 1 , \"processing data for table \\\"%s.%s\\\"\\n\" , te -> namespace , te -> tag ) ;\n if ( is_parallel && te -> created ) {\n StartTransaction ( & AH -> public ) ;\n ahprintf ( AH , \"TRUNCATE TABLE %s%s;\n\\n\\n\" , ( PQserverVersion ( AH -> connection ) >= 80400 ? \"ONLY \" : \"\" ) , fmtId ( te -> tag ) ) ;\n }\n if ( te -> copyStmt && strlen ( te -> copyStmt ) > 0 ) {\n ahprintf ( AH , \"%s\" , te -> copyStmt ) ;\n AH -> outputKind = OUTPUT_COPYDATA ;\n }\n else AH -> outputKind = OUTPUT_OTHERDATA ;\n ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n if ( AH -> outputKind == OUTPUT_COPYDATA && RestoringToDB ( AH ) ) EndDBCopyMode ( & AH -> public , te -> tag ) ;\n AH -> outputKind = OUTPUT_SQLCMDS ;\n if ( is_parallel && te -> created ) CommitTransaction ( & AH -> public ) ;\n _enableTriggersIfNecessary ( AH , te ) ;\n }\n }\n }\n else if ( ! defnDumped ) {\n ahlog ( AH , 1 , \"executing %s %s\\n\" , te -> desc , te -> tag ) ;\n _printTocEntry ( AH , te , false , false ) ;\n }\n }\n if ( AH -> public . n_errors > 0 && status == WORKER_OK ) status = WORKER_IGNORED_ERRORS ;\n return status ;\n }",
        "hash": -8028756826159773630,
        "project": "debian",
        "size": 79,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int restore_toc_entry ( ArchiveHandle * AH , TocEntry * te , bool is_parallel ) {\n"
                ],
                [
                    7,
                    " if ( _tocEntryIsACL ( te ) ) reqs = 0 ;\n"
                ],
                [
                    9,
                    " if ( ! ropt -> createDB && strcmp ( te -> desc , \"DATABASE\" ) == 0 ) reqs = 0 ;\n"
                ],
                [
                    10,
                    " if ( ! ropt -> suppressDumpWarnings && strcmp ( te -> desc , \"WARNING\" ) == 0 ) {\n"
                ],
                [
                    11,
                    " if ( ! ropt -> dataOnly && te -> defn != NULL && strlen ( te -> defn ) != 0 ) write_msg ( modulename , \"warning from original dump file: %s\\n\" , te -> defn ) ;\n"
                ],
                [
                    15,
                    " if ( ( reqs & REQ_SCHEMA ) != 0 ) {\n"
                ],
                [
                    16,
                    " if ( te -> namespace ) ahlog ( AH , 1 , \"creating %s \\\"%s.%s\\\"\\n\" , te -> desc , te -> namespace , te -> tag ) ;\n"
                ],
                [
                    17,
                    " else ahlog ( AH , 1 , \"creating %s \\\"%s\\\"\\n\" , te -> desc , te -> tag ) ;\n"
                ],
                [
                    18,
                    " _printTocEntry ( AH , te , false , false ) ;\n"
                ],
                [
                    20,
                    " if ( strcmp ( te -> desc , \"TABLE\" ) == 0 ) {\n"
                ],
                [
                    21,
                    " if ( AH -> lastErrorTE == te ) {\n"
                ],
                [
                    24,
                    " else inhibit_data_for_failed_table ( AH , te ) ;\n"
                ],
                [
                    29,
                    " else mark_create_done ( AH , te ) ;\n"
                ],
                [
                    32,
                    " if ( strcmp ( te -> desc , \"DATABASE\" ) == 0 ) {\n"
                ],
                [
                    33,
                    " ahlog ( AH , 1 , \"connecting to new database \\\"%s\\\"\\n\" , te -> tag ) ;\n"
                ],
                [
                    34,
                    " _reconnectToDB ( AH , te -> tag ) ;\n"
                ],
                [
                    35,
                    " ropt -> dbname = pg_strdup ( te -> tag ) ;\n"
                ],
                [
                    40,
                    " if ( AH -> PrintTocDataPtr != NULL ) {\n"
                ],
                [
                    41,
                    " _printTocEntry ( AH , te , true , false ) ;\n"
                ],
                [
                    42,
                    " if ( strcmp ( te -> desc , \"BLOBS\" ) == 0 || strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 ) {\n"
                ],
                [
                    43,
                    " ahlog ( AH , 1 , \"processing %s\\n\" , te -> desc ) ;\n"
                ],
                [
                    44,
                    " _selectOutputSchema ( AH , \"pg_catalog\" ) ;\n"
                ],
                [
                    45,
                    " if ( strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 ) AH -> outputKind = OUTPUT_OTHERDATA ;\n"
                ],
                [
                    46,
                    " ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n"
                ],
                [
                    47,
                    " AH -> outputKind = OUTPUT_SQLCMDS ;\n"
                ],
                [
                    50,
                    " _disableTriggersIfNecessary ( AH , te ) ;\n"
                ],
                [
                    51,
                    " _becomeOwner ( AH , te ) ;\n"
                ],
                [
                    52,
                    " _selectOutputSchema ( AH , te -> namespace ) ;\n"
                ],
                [
                    53,
                    " ahlog ( AH , 1 , \"processing data for table \\\"%s.%s\\\"\\n\" , te -> namespace , te -> tag ) ;\n"
                ],
                [
                    54,
                    " if ( is_parallel && te -> created ) {\n"
                ],
                [
                    59,
                    " if ( te -> copyStmt && strlen ( te -> copyStmt ) > 0 ) {\n"
                ],
                [
                    64,
                    " ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n"
                ],
                [
                    65,
                    " if ( AH -> outputKind == OUTPUT_COPYDATA && RestoringToDB ( AH ) ) EndDBCopyMode ( & AH -> public , te -> tag ) ;\n"
                ],
                [
                    66,
                    " AH -> outputKind = OUTPUT_SQLCMDS ;\n"
                ],
                [
                    67,
                    " if ( is_parallel && te -> created ) CommitTransaction ( & AH -> public ) ;\n"
                ],
                [
                    68,
                    " _enableTriggersIfNecessary ( AH , te ) ;\n"
                ],
                [
                    73,
                    " ahlog ( AH , 1 , \"executing %s %s\\n\" , te -> desc , te -> tag ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static int restore_toc_entry ( ArchiveHandle * AH , TocEntry * te , bool is_parallel ) {\n"
                ],
                [
                    7,
                    " if ( _tocEntryIsACL ( te ) ) reqs = 0 ;\n"
                ],
                [
                    11,
                    " if ( ! ropt -> dataOnly && te -> defn != NULL && strlen ( te -> defn ) != 0 ) write_msg ( modulename , \"warning from original dump file: %s\\n\" , te -> defn ) ;\n"
                ],
                [
                    12,
                    " else if ( te -> copyStmt != NULL && strlen ( te -> copyStmt ) != 0 ) write_msg ( modulename , \"warning from original dump file: %s\\n\" , te -> copyStmt ) ;\n"
                ],
                [
                    18,
                    " _printTocEntry ( AH , te , false , false ) ;\n"
                ],
                [
                    21,
                    " if ( AH -> lastErrorTE == te ) {\n"
                ],
                [
                    24,
                    " else inhibit_data_for_failed_table ( AH , te ) ;\n"
                ],
                [
                    29,
                    " else mark_create_done ( AH , te ) ;\n"
                ],
                [
                    41,
                    " _printTocEntry ( AH , te , true , false ) ;\n"
                ],
                [
                    42,
                    " if ( strcmp ( te -> desc , \"BLOBS\" ) == 0 || strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 ) {\n"
                ],
                [
                    46,
                    " ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n"
                ],
                [
                    50,
                    " _disableTriggersIfNecessary ( AH , te ) ;\n"
                ],
                [
                    51,
                    " _becomeOwner ( AH , te ) ;\n"
                ],
                [
                    59,
                    " if ( te -> copyStmt && strlen ( te -> copyStmt ) > 0 ) {\n"
                ],
                [
                    60,
                    " ahprintf ( AH , \"%s\" , te -> copyStmt ) ;\n"
                ],
                [
                    61,
                    " AH -> outputKind = OUTPUT_COPYDATA ;\n"
                ],
                [
                    63,
                    " else AH -> outputKind = OUTPUT_OTHERDATA ;\n"
                ],
                [
                    64,
                    " ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n"
                ],
                [
                    68,
                    " _enableTriggersIfNecessary ( AH , te ) ;\n"
                ],
                [
                    74,
                    " _printTocEntry ( AH , te , false , false ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int restore_toc_entry ( ArchiveHandle * AH , TocEntry * te , bool is_parallel ) {\n"
                ],
                [
                    7,
                    " if ( _tocEntryIsACL ( te ) ) reqs = 0 ;\n"
                ],
                [
                    9,
                    " if ( ! ropt -> createDB && strcmp ( te -> desc , \"DATABASE\" ) == 0 ) reqs = 0 ;\n"
                ],
                [
                    10,
                    " if ( ! ropt -> suppressDumpWarnings && strcmp ( te -> desc , \"WARNING\" ) == 0 ) {\n"
                ],
                [
                    11,
                    " if ( ! ropt -> dataOnly && te -> defn != NULL && strlen ( te -> defn ) != 0 ) write_msg ( modulename , \"warning from original dump file: %s\\n\" , te -> defn ) ;\n"
                ],
                [
                    12,
                    " else if ( te -> copyStmt != NULL && strlen ( te -> copyStmt ) != 0 ) write_msg ( modulename , \"warning from original dump file: %s\\n\" , te -> copyStmt ) ;\n"
                ],
                [
                    15,
                    " if ( ( reqs & REQ_SCHEMA ) != 0 ) {\n"
                ],
                [
                    16,
                    " if ( te -> namespace ) ahlog ( AH , 1 , \"creating %s \\\"%s.%s\\\"\\n\" , te -> desc , te -> namespace , te -> tag ) ;\n"
                ],
                [
                    17,
                    " else ahlog ( AH , 1 , \"creating %s \\\"%s\\\"\\n\" , te -> desc , te -> tag ) ;\n"
                ],
                [
                    18,
                    " _printTocEntry ( AH , te , false , false ) ;\n"
                ],
                [
                    20,
                    " if ( strcmp ( te -> desc , \"TABLE\" ) == 0 ) {\n"
                ],
                [
                    21,
                    " if ( AH -> lastErrorTE == te ) {\n"
                ],
                [
                    24,
                    " else inhibit_data_for_failed_table ( AH , te ) ;\n"
                ],
                [
                    29,
                    " else mark_create_done ( AH , te ) ;\n"
                ],
                [
                    32,
                    " if ( strcmp ( te -> desc , \"DATABASE\" ) == 0 ) {\n"
                ],
                [
                    33,
                    " ahlog ( AH , 1 , \"connecting to new database \\\"%s\\\"\\n\" , te -> tag ) ;\n"
                ],
                [
                    34,
                    " _reconnectToDB ( AH , te -> tag ) ;\n"
                ],
                [
                    35,
                    " ropt -> dbname = pg_strdup ( te -> tag ) ;\n"
                ],
                [
                    40,
                    " if ( AH -> PrintTocDataPtr != NULL ) {\n"
                ],
                [
                    41,
                    " _printTocEntry ( AH , te , true , false ) ;\n"
                ],
                [
                    42,
                    " if ( strcmp ( te -> desc , \"BLOBS\" ) == 0 || strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 ) {\n"
                ],
                [
                    43,
                    " ahlog ( AH , 1 , \"processing %s\\n\" , te -> desc ) ;\n"
                ],
                [
                    44,
                    " _selectOutputSchema ( AH , \"pg_catalog\" ) ;\n"
                ],
                [
                    45,
                    " if ( strcmp ( te -> desc , \"BLOB COMMENTS\" ) == 0 ) AH -> outputKind = OUTPUT_OTHERDATA ;\n"
                ],
                [
                    46,
                    " ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n"
                ],
                [
                    47,
                    " AH -> outputKind = OUTPUT_SQLCMDS ;\n"
                ],
                [
                    50,
                    " _disableTriggersIfNecessary ( AH , te ) ;\n"
                ],
                [
                    51,
                    " _becomeOwner ( AH , te ) ;\n"
                ],
                [
                    52,
                    " _selectOutputSchema ( AH , te -> namespace ) ;\n"
                ],
                [
                    53,
                    " ahlog ( AH , 1 , \"processing data for table \\\"%s.%s\\\"\\n\" , te -> namespace , te -> tag ) ;\n"
                ],
                [
                    54,
                    " if ( is_parallel && te -> created ) {\n"
                ],
                [
                    59,
                    " if ( te -> copyStmt && strlen ( te -> copyStmt ) > 0 ) {\n"
                ],
                [
                    60,
                    " ahprintf ( AH , \"%s\" , te -> copyStmt ) ;\n"
                ],
                [
                    61,
                    " AH -> outputKind = OUTPUT_COPYDATA ;\n"
                ],
                [
                    63,
                    " else AH -> outputKind = OUTPUT_OTHERDATA ;\n"
                ],
                [
                    64,
                    " ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n"
                ],
                [
                    65,
                    " if ( AH -> outputKind == OUTPUT_COPYDATA && RestoringToDB ( AH ) ) EndDBCopyMode ( & AH -> public , te -> tag ) ;\n"
                ],
                [
                    66,
                    " AH -> outputKind = OUTPUT_SQLCMDS ;\n"
                ],
                [
                    67,
                    " if ( is_parallel && te -> created ) CommitTransaction ( & AH -> public ) ;\n"
                ],
                [
                    68,
                    " _enableTriggersIfNecessary ( AH , te ) ;\n"
                ],
                [
                    73,
                    " ahlog ( AH , 1 , \"executing %s %s\\n\" , te -> desc , te -> tag ) ;\n"
                ],
                [
                    74,
                    " _printTocEntry ( AH , te , false , false ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {\n ArchiveHandle * clone ;\n clone = ( ArchiveHandle * ) pg_malloc ( sizeof ( ArchiveHandle ) ) ;\n memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;\n memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;\n clone -> connection = NULL ;\n clone -> connCancel = NULL ;\n clone -> currUser = NULL ;\n clone -> currSchema = NULL ;\n clone -> currTablespace = NULL ;\n clone -> currWithOids = - 1 ;\n if ( clone -> savedPassword ) clone -> savedPassword = pg_strdup ( clone -> savedPassword ) ;\n clone -> public . n_errors = 0 ;\n if ( AH -> mode == archModeRead ) {\n RestoreOptions * ropt = AH -> public . ropt ;\n Assert ( AH -> connection == NULL ) ;\n ConnectDatabase ( ( Archive * ) clone , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;\n _doSetFixedOutputState ( clone ) ;\n }\n else {\n char * dbname ;\n char * pghost ;\n char * pgport ;\n char * username ;\n Assert ( AH -> connection != NULL ) ;\n dbname = PQdb ( AH -> connection ) ;\n pghost = PQhost ( AH -> connection ) ;\n pgport = PQport ( AH -> connection ) ;\n username = PQuser ( AH -> connection ) ;\n ConnectDatabase ( ( Archive * ) clone , dbname , pghost , pgport , username , TRI_NO ) ;\n }\n ( clone -> ClonePtr ) ( clone ) ;\n Assert ( clone -> connection != NULL ) ;\n return clone ;\n }",
        "hash": -8028756826159773630,
        "project": "debian",
        "size": 35,
        "slice": {
            "memcpy": [
                [
                    1,
                    "ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {\n"
                ],
                [
                    3,
                    " clone = ( ArchiveHandle * ) pg_malloc ( sizeof ( ArchiveHandle ) ) ;\n"
                ],
                [
                    4,
                    " memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;\n"
                ],
                [
                    5,
                    " memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;\n"
                ],
                [
                    12,
                    " if ( clone -> savedPassword ) clone -> savedPassword = pg_strdup ( clone -> savedPassword ) ;\n"
                ],
                [
                    14,
                    " if ( AH -> mode == archModeRead ) {\n"
                ],
                [
                    16,
                    " Assert ( AH -> connection == NULL ) ;\n"
                ],
                [
                    17,
                    " ConnectDatabase ( ( Archive * ) clone , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;\n"
                ],
                [
                    18,
                    " _doSetFixedOutputState ( clone ) ;\n"
                ],
                [
                    25,
                    " Assert ( AH -> connection != NULL ) ;\n"
                ],
                [
                    26,
                    " dbname = PQdb ( AH -> connection ) ;\n"
                ],
                [
                    27,
                    " pghost = PQhost ( AH -> connection ) ;\n"
                ],
                [
                    28,
                    " pgport = PQport ( AH -> connection ) ;\n"
                ],
                [
                    29,
                    " username = PQuser ( AH -> connection ) ;\n"
                ],
                [
                    30,
                    " ConnectDatabase ( ( Archive * ) clone , dbname , pghost , pgport , username , TRI_NO ) ;\n"
                ],
                [
                    32,
                    " ( clone -> ClonePtr ) ( clone ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {\n"
                ],
                [
                    4,
                    " memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;\n"
                ],
                [
                    5,
                    " memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {\n"
                ],
                [
                    3,
                    " clone = ( ArchiveHandle * ) pg_malloc ( sizeof ( ArchiveHandle ) ) ;\n"
                ],
                [
                    4,
                    " memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;\n"
                ],
                [
                    5,
                    " memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;\n"
                ],
                [
                    12,
                    " if ( clone -> savedPassword ) clone -> savedPassword = pg_strdup ( clone -> savedPassword ) ;\n"
                ],
                [
                    14,
                    " if ( AH -> mode == archModeRead ) {\n"
                ],
                [
                    16,
                    " Assert ( AH -> connection == NULL ) ;\n"
                ],
                [
                    17,
                    " ConnectDatabase ( ( Archive * ) clone , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;\n"
                ],
                [
                    18,
                    " _doSetFixedOutputState ( clone ) ;\n"
                ],
                [
                    25,
                    " Assert ( AH -> connection != NULL ) ;\n"
                ],
                [
                    26,
                    " dbname = PQdb ( AH -> connection ) ;\n"
                ],
                [
                    27,
                    " pghost = PQhost ( AH -> connection ) ;\n"
                ],
                [
                    28,
                    " pgport = PQport ( AH -> connection ) ;\n"
                ],
                [
                    29,
                    " username = PQuser ( AH -> connection ) ;\n"
                ],
                [
                    30,
                    " ConnectDatabase ( ( Archive * ) clone , dbname , pghost , pgport , username , TRI_NO ) ;\n"
                ],
                [
                    32,
                    " ( clone -> ClonePtr ) ( clone ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void dumpCreateDB ( PGconn * conn ) {\n PQExpBuffer buf = createPQExpBuffer ( ) ;\n char * default_encoding = NULL ;\n char * default_collate = NULL ;\n char * default_ctype = NULL ;\n PGresult * res ;\n int i ;\n fprintf ( OPF , \"--\\n-- Database creation\\n--\\n\\n\" ) ;\n if ( server_version >= 80400 ) res = executeQuery ( conn , \"SELECT pg_encoding_to_char(encoding), \" \"datcollate, datctype \" \"FROM pg_database \" \"WHERE datname = 'template0'\" ) ;\n else if ( server_version >= 70100 ) res = executeQuery ( conn , \"SELECT pg_encoding_to_char(encoding), \" \"null::text AS datcollate, null::text AS datctype \" \"FROM pg_database \" \"WHERE datname = 'template0'\" ) ;\n else res = executeQuery ( conn , \"SELECT pg_encoding_to_char(encoding), \" \"null::text AS datcollate, null::text AS datctype \" \"FROM pg_database \" \"WHERE datname = 'template1'\" ) ;\n if ( PQntuples ( res ) > 0 ) {\n if ( ! PQgetisnull ( res , 0 , 0 ) ) default_encoding = pg_strdup ( PQgetvalue ( res , 0 , 0 ) ) ;\n if ( ! PQgetisnull ( res , 0 , 1 ) ) default_collate = pg_strdup ( PQgetvalue ( res , 0 , 1 ) ) ;\n if ( ! PQgetisnull ( res , 0 , 2 ) ) default_ctype = pg_strdup ( PQgetvalue ( res , 0 , 2 ) ) ;\n }\n PQclear ( res ) ;\n if ( server_version >= 90600 ) res = executeQuery ( conn , \"SELECT datname, \" \"coalesce(rolname, (select rolname from pg_authid where oid=(select datdba from pg_database where datname='template0'))), \" \"pg_encoding_to_char(d.encoding), \" \"datcollate, datctype, datfrozenxid, datminmxid, \" \"datistemplate, \" \"(SELECT pg_catalog.array_agg(acl) FROM (SELECT pg_catalog.unnest(coalesce(datacl,pg_catalog.acldefault('d',datdba))) AS acl \" \"EXCEPT SELECT pg_catalog.unnest(pg_catalog.acldefault('d',datdba))) as foo)\" \"AS datacl,\" \"(SELECT pg_catalog.array_agg(acl) FROM (SELECT pg_catalog.unnest(pg_catalog.acldefault('d',datdba)) AS acl \" \"EXCEPT SELECT pg_catalog.unnest(coalesce(datacl,pg_catalog.acldefault('d',datdba)))) as foo)\" \"AS rdatacl,\" \"datconnlimit, \" \"(SELECT spcname FROM pg_tablespace t WHERE t.oid = d.dattablespace) AS dattablespace \" \"FROM pg_database d LEFT JOIN pg_authid u ON (datdba = u.oid) \" \"WHERE datallowconn ORDER BY 1\" ) ;\n else if ( server_version >= 90300 ) res = executeQuery ( conn , \"SELECT datname, \" \"coalesce(rolname, (select rolname from pg_authid where oid=(select datdba from pg_database where datname='template0'))), \" \"pg_encoding_to_char(d.encoding), \" \"datcollate, datctype, datfrozenxid, datminmxid, \" \"datistemplate, datacl, '' as rdatacl, datconnlimit, \" \"(SELECT spcname FROM pg_tablespace t WHERE t.oid = d.dattablespace) AS dattablespace \" \"FROM pg_database d LEFT JOIN pg_authid u ON (datdba = u.oid) \" \"WHERE datallowconn ORDER BY 1\" ) ;\n else if ( server_version >= 80400 ) res = executeQuery ( conn , \"SELECT datname, \" \"coalesce(rolname, (select rolname from pg_authid where oid=(select datdba from pg_database where datname='template0'))), \" \"pg_encoding_to_char(d.encoding), \" \"datcollate, datctype, datfrozenxid, 0 AS datminmxid, \" \"datistemplate, datacl, '' as rdatacl, datconnlimit, \" \"(SELECT spcname FROM pg_tablespace t WHERE t.oid = d.dattablespace) AS dattablespace \" \"FROM pg_database d LEFT JOIN pg_authid u ON (datdba = u.oid) \" \"WHERE datallowconn ORDER BY 1\" ) ;\n else if ( server_version >= 80100 ) res = executeQuery ( conn , \"SELECT datname, \" \"coalesce(rolname, (select rolname from pg_authid where oid=(select datdba from pg_database where datname='template0'))), \" \"pg_encoding_to_char(d.encoding), \" \"null::text AS datcollate, null::text AS datctype, datfrozenxid, 0 AS datminmxid, \" \"datistemplate, datacl, '' as rdatacl, datconnlimit, \" \"(SELECT spcname FROM pg_tablespace t WHERE t.oid = d.dattablespace) AS dattablespace \" \"FROM pg_database d LEFT JOIN pg_authid u ON (datdba = u.oid) \" \"WHERE datallowconn ORDER BY 1\" ) ;\n else if ( server_version >= 80000 ) res = executeQuery ( conn , \"SELECT datname, \" \"coalesce(usename, (select usename from pg_shadow where usesysid=(select datdba from pg_database where datname='template0'))), \" \"pg_encoding_to_char(d.encoding), \" \"null::text AS datcollate, null::text AS datctype, datfrozenxid, 0 AS datminmxid, \" \"datistemplate, datacl, '' as rdatacl, -1 as datconnlimit, \" \"(SELECT spcname FROM pg_tablespace t WHERE t.oid = d.dattablespace) AS dattablespace \" \"FROM pg_database d LEFT JOIN pg_shadow u ON (datdba = usesysid) \" \"WHERE datallowconn ORDER BY 1\" ) ;\n else if ( server_version >= 70300 ) res = executeQuery ( conn , \"SELECT datname, \" \"coalesce(usename, (select usename from pg_shadow where usesysid=(select datdba from pg_database where datname='template0'))), \" \"pg_encoding_to_char(d.encoding), \" \"null::text AS datcollate, null::text AS datctype, datfrozenxid, 0 AS datminmxid, \" \"datistemplate, datacl, '' as rdatacl, -1 as datconnlimit, \" \"'pg_default' AS dattablespace \" \"FROM pg_database d LEFT JOIN pg_shadow u ON (datdba = usesysid) \" \"WHERE datallowconn ORDER BY 1\" ) ;\n else if ( server_version >= 70100 ) res = executeQuery ( conn , \"SELECT datname, \" \"coalesce(\" \"(select usename from pg_shadow where usesysid=datdba), \" \"(select usename from pg_shadow where usesysid=(select datdba from pg_database where datname='template0'))), \" \"pg_encoding_to_char(d.encoding), \" \"null::text AS datcollate, null::text AS datctype, 0 AS datfrozenxid, 0 AS datminmxid, \" \"datistemplate, '' as datacl, '' as rdatacl, -1 as datconnlimit, \" \"'pg_default' AS dattablespace \" \"FROM pg_database d \" \"WHERE datallowconn ORDER BY 1\" ) ;\n else {\n res = executeQuery ( conn , \"SELECT datname, \" \"(select usename from pg_shadow where usesysid=datdba), \" \"pg_encoding_to_char(d.encoding), \" \"null::text AS datcollate, null::text AS datctype, 0 AS datfrozenxid, 0 AS datminmxid, \" \"'f' as datistemplate, \" \"'' as datacl, '' as rdatacl, -1 as datconnlimit, \" \"'pg_default' AS dattablespace \" \"FROM pg_database d \" \"ORDER BY 1\" ) ;\n }\n for ( i = 0 ;\n i < PQntuples ( res ) ;\n i ++ ) {\n char * dbname = PQgetvalue ( res , i , 0 ) ;\n char * dbowner = PQgetvalue ( res , i , 1 ) ;\n char * dbencoding = PQgetvalue ( res , i , 2 ) ;\n char * dbcollate = PQgetvalue ( res , i , 3 ) ;\n char * dbctype = PQgetvalue ( res , i , 4 ) ;\n uint32 dbfrozenxid = atooid ( PQgetvalue ( res , i , 5 ) ) ;\n uint32 dbminmxid = atooid ( PQgetvalue ( res , i , 6 ) ) ;\n char * dbistemplate = PQgetvalue ( res , i , 7 ) ;\n char * dbacl = PQgetvalue ( res , i , 8 ) ;\n char * rdbacl = PQgetvalue ( res , i , 9 ) ;\n char * dbconnlimit = PQgetvalue ( res , i , 10 ) ;\n char * dbtablespace = PQgetvalue ( res , i , 11 ) ;\n char * fdbname ;\n fdbname = pg_strdup ( fmtId ( dbname ) ) ;\n resetPQExpBuffer ( buf ) ;\n if ( strcmp ( dbname , \"template1\" ) != 0 && strcmp ( dbname , \"postgres\" ) != 0 ) {\n appendPQExpBuffer ( buf , \"CREATE DATABASE %s\" , fdbname ) ;\n appendPQExpBufferStr ( buf , \" WITH TEMPLATE = template0\" ) ;\n if ( strlen ( dbowner ) != 0 ) appendPQExpBuffer ( buf , \" OWNER = %s\" , fmtId ( dbowner ) ) ;\n if ( default_encoding && strcmp ( dbencoding , default_encoding ) != 0 ) {\n appendPQExpBufferStr ( buf , \" ENCODING = \" ) ;\n appendStringLiteralConn ( buf , dbencoding , conn ) ;\n }\n if ( default_collate && strcmp ( dbcollate , default_collate ) != 0 ) {\n appendPQExpBufferStr ( buf , \" LC_COLLATE = \" ) ;\n appendStringLiteralConn ( buf , dbcollate , conn ) ;\n }\n if ( default_ctype && strcmp ( dbctype , default_ctype ) != 0 ) {\n appendPQExpBufferStr ( buf , \" LC_CTYPE = \" ) ;\n appendStringLiteralConn ( buf , dbctype , conn ) ;\n }\n if ( strcmp ( dbtablespace , \"pg_default\" ) != 0 && ! no_tablespaces ) appendPQExpBuffer ( buf , \" TABLESPACE = %s\" , fmtId ( dbtablespace ) ) ;\n if ( strcmp ( dbistemplate , \"t\" ) == 0 ) appendPQExpBuffer ( buf , \" IS_TEMPLATE = true\" ) ;\n if ( strcmp ( dbconnlimit , \"-1\" ) != 0 ) appendPQExpBuffer ( buf , \" CONNECTION LIMIT = %s\" , dbconnlimit ) ;\n appendPQExpBufferStr ( buf , \";\n\\n\" ) ;\n }\n else if ( strcmp ( dbtablespace , \"pg_default\" ) != 0 && ! no_tablespaces ) {\n if ( strcmp ( dbname , \"postgres\" ) == 0 ) appendPQExpBuffer ( buf , \"\\\\connect template1\\n\" ) ;\n else appendPQExpBuffer ( buf , \"\\\\connect postgres\\n\" ) ;\n appendPQExpBuffer ( buf , \"ALTER DATABASE %s SET TABLESPACE %s;\n\\n\" , fdbname , fmtId ( dbtablespace ) ) ;\n appendPQExpBuffer ( buf , \"\\\\connect %s\\n\" , fdbname ) ;\n }\n if ( binary_upgrade ) {\n appendPQExpBufferStr ( buf , \"-- For binary upgrade, set datfrozenxid and datminmxid.\\n\" ) ;\n appendPQExpBuffer ( buf , \"UPDATE pg_catalog.pg_database \" \"SET datfrozenxid = '%u', datminmxid = '%u' \" \"WHERE datname = \" , dbfrozenxid , dbminmxid ) ;\n appendStringLiteralConn ( buf , dbname , conn ) ;\n appendPQExpBufferStr ( buf , \";\n\\n\" ) ;\n }\n if ( ! skip_acls && ! buildACLCommands ( fdbname , NULL , \"DATABASE\" , dbacl , rdbacl , dbowner , \"\" , server_version , buf ) ) {\n fprintf ( stderr , _ ( \"%s: could not parse ACL list (%s) for database \\\"%s\\\"\\n\" ) , progname , dbacl , fdbname ) ;\n PQfinish ( conn ) ;\n exit_nicely ( 1 ) ;\n }\n fprintf ( OPF , \"%s\" , buf -> data ) ;\n if ( server_version >= 70300 ) dumpDatabaseConfig ( conn , dbname ) ;\n free ( fdbname ) ;\n }\n if ( default_encoding ) free ( default_encoding ) ;\n if ( default_collate ) free ( default_collate ) ;\n if ( default_ctype ) free ( default_ctype ) ;\n PQclear ( res ) ;\n destroyPQExpBuffer ( buf ) ;\n fprintf ( OPF , \"\\n\\n\" ) ;\n }",
        "hash": -6215323349888018447,
        "project": "debian",
        "size": 97,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static void dumpCreateDB ( PGconn * conn ) {\n"
                ],
                [
                    3,
                    " char * default_encoding = NULL ;\n"
                ],
                [
                    4,
                    " char * default_collate = NULL ;\n"
                ],
                [
                    5,
                    " char * default_ctype = NULL ;\n"
                ],
                [
                    13,
                    " if ( ! PQgetisnull ( res , 0 , 0 ) ) default_encoding = pg_strdup ( PQgetvalue ( res , 0 , 0 ) ) ;\n"
                ],
                [
                    14,
                    " if ( ! PQgetisnull ( res , 0 , 1 ) ) default_collate = pg_strdup ( PQgetvalue ( res , 0 , 1 ) ) ;\n"
                ],
                [
                    15,
                    " if ( ! PQgetisnull ( res , 0 , 2 ) ) default_ctype = pg_strdup ( PQgetvalue ( res , 0 , 2 ) ) ;\n"
                ],
                [
                    29,
                    " i < PQntuples ( res ) ;\n"
                ],
                [
                    33,
                    " char * dbencoding = PQgetvalue ( res , i , 2 ) ;\n"
                ],
                [
                    34,
                    " char * dbcollate = PQgetvalue ( res , i , 3 ) ;\n"
                ],
                [
                    35,
                    " char * dbctype = PQgetvalue ( res , i , 4 ) ;\n"
                ],
                [
                    38,
                    " char * dbistemplate = PQgetvalue ( res , i , 7 ) ;\n"
                ],
                [
                    41,
                    " char * dbconnlimit = PQgetvalue ( res , i , 10 ) ;\n"
                ],
                [
                    42,
                    " char * dbtablespace = PQgetvalue ( res , i , 11 ) ;\n"
                ],
                [
                    44,
                    " fdbname = pg_strdup ( fmtId ( dbname ) ) ;\n"
                ],
                [
                    46,
                    " if ( strcmp ( dbname , \"template1\" ) != 0 && strcmp ( dbname , \"postgres\" ) != 0 ) {\n"
                ],
                [
                    47,
                    " appendPQExpBuffer ( buf , \"CREATE DATABASE %s\" , fdbname ) ;\n"
                ],
                [
                    48,
                    " appendPQExpBufferStr ( buf , \" WITH TEMPLATE = template0\" ) ;\n"
                ],
                [
                    49,
                    " if ( strlen ( dbowner ) != 0 ) appendPQExpBuffer ( buf , \" OWNER = %s\" , fmtId ( dbowner ) ) ;\n"
                ],
                [
                    50,
                    " if ( default_encoding && strcmp ( dbencoding , default_encoding ) != 0 ) {\n"
                ],
                [
                    51,
                    " appendPQExpBufferStr ( buf , \" ENCODING = \" ) ;\n"
                ],
                [
                    52,
                    " appendStringLiteralConn ( buf , dbencoding , conn ) ;\n"
                ],
                [
                    54,
                    " if ( default_collate && strcmp ( dbcollate , default_collate ) != 0 ) {\n"
                ],
                [
                    55,
                    " appendPQExpBufferStr ( buf , \" LC_COLLATE = \" ) ;\n"
                ],
                [
                    56,
                    " appendStringLiteralConn ( buf , dbcollate , conn ) ;\n"
                ],
                [
                    58,
                    " if ( default_ctype && strcmp ( dbctype , default_ctype ) != 0 ) {\n"
                ],
                [
                    59,
                    " appendPQExpBufferStr ( buf , \" LC_CTYPE = \" ) ;\n"
                ],
                [
                    60,
                    " appendStringLiteralConn ( buf , dbctype , conn ) ;\n"
                ],
                [
                    62,
                    " if ( strcmp ( dbtablespace , \"pg_default\" ) != 0 && ! no_tablespaces ) appendPQExpBuffer ( buf , \" TABLESPACE = %s\" , fmtId ( dbtablespace ) ) ;\n"
                ],
                [
                    63,
                    " if ( strcmp ( dbistemplate , \"t\" ) == 0 ) appendPQExpBuffer ( buf , \" IS_TEMPLATE = true\" ) ;\n"
                ],
                [
                    64,
                    " if ( strcmp ( dbconnlimit , \"-1\" ) != 0 ) appendPQExpBuffer ( buf , \" CONNECTION LIMIT = %s\" , dbconnlimit ) ;\n"
                ],
                [
                    68,
                    " else if ( strcmp ( dbtablespace , \"pg_default\" ) != 0 && ! no_tablespaces ) {\n"
                ],
                [
                    69,
                    " if ( strcmp ( dbname , \"postgres\" ) == 0 ) appendPQExpBuffer ( buf , \"\\\\connect template1\\n\" ) ;\n"
                ],
                [
                    70,
                    " else appendPQExpBuffer ( buf , \"\\\\connect postgres\\n\" ) ;\n"
                ],
                [
                    78,
                    " appendStringLiteralConn ( buf , dbname , conn ) ;\n"
                ],
                [
                    88,
                    " if ( server_version >= 70300 ) dumpDatabaseConfig ( conn , dbname ) ;\n"
                ],
                [
                    91,
                    " if ( default_encoding ) free ( default_encoding ) ;\n"
                ],
                [
                    92,
                    " if ( default_collate ) free ( default_collate ) ;\n"
                ],
                [
                    93,
                    " if ( default_ctype ) free ( default_ctype ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static void dumpCreateDB ( PGconn * conn ) {\n"
                ],
                [
                    32,
                    " char * dbowner = PQgetvalue ( res , i , 1 ) ;\n"
                ],
                [
                    46,
                    " if ( strcmp ( dbname , \"template1\" ) != 0 && strcmp ( dbname , \"postgres\" ) != 0 ) {\n"
                ],
                [
                    49,
                    " if ( strlen ( dbowner ) != 0 ) appendPQExpBuffer ( buf , \" OWNER = %s\" , fmtId ( dbowner ) ) ;\n"
                ],
                [
                    82,
                    " if ( ! skip_acls && ! buildACLCommands ( fdbname , NULL , \"DATABASE\" , dbacl , rdbacl , dbowner , \"\" , server_version , buf ) ) {\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void dumpCreateDB ( PGconn * conn ) {\n"
                ],
                [
                    8,
                    " fprintf ( OPF , \"--\\n-- Database creation\\n--\\n\\n\" ) ;\n"
                ],
                [
                    29,
                    " i < PQntuples ( res ) ;\n"
                ],
                [
                    39,
                    " char * dbacl = PQgetvalue ( res , i , 8 ) ;\n"
                ],
                [
                    44,
                    " fdbname = pg_strdup ( fmtId ( dbname ) ) ;\n"
                ],
                [
                    45,
                    " resetPQExpBuffer ( buf ) ;\n"
                ],
                [
                    47,
                    " appendPQExpBuffer ( buf , \"CREATE DATABASE %s\" , fdbname ) ;\n"
                ],
                [
                    48,
                    " appendPQExpBufferStr ( buf , \" WITH TEMPLATE = template0\" ) ;\n"
                ],
                [
                    49,
                    " if ( strlen ( dbowner ) != 0 ) appendPQExpBuffer ( buf , \" OWNER = %s\" , fmtId ( dbowner ) ) ;\n"
                ],
                [
                    51,
                    " appendPQExpBufferStr ( buf , \" ENCODING = \" ) ;\n"
                ],
                [
                    52,
                    " appendStringLiteralConn ( buf , dbencoding , conn ) ;\n"
                ],
                [
                    55,
                    " appendPQExpBufferStr ( buf , \" LC_COLLATE = \" ) ;\n"
                ],
                [
                    56,
                    " appendStringLiteralConn ( buf , dbcollate , conn ) ;\n"
                ],
                [
                    59,
                    " appendPQExpBufferStr ( buf , \" LC_CTYPE = \" ) ;\n"
                ],
                [
                    60,
                    " appendStringLiteralConn ( buf , dbctype , conn ) ;\n"
                ],
                [
                    62,
                    " if ( strcmp ( dbtablespace , \"pg_default\" ) != 0 && ! no_tablespaces ) appendPQExpBuffer ( buf , \" TABLESPACE = %s\" , fmtId ( dbtablespace ) ) ;\n"
                ],
                [
                    63,
                    " if ( strcmp ( dbistemplate , \"t\" ) == 0 ) appendPQExpBuffer ( buf , \" IS_TEMPLATE = true\" ) ;\n"
                ],
                [
                    64,
                    " if ( strcmp ( dbconnlimit , \"-1\" ) != 0 ) appendPQExpBuffer ( buf , \" CONNECTION LIMIT = %s\" , dbconnlimit ) ;\n"
                ],
                [
                    69,
                    " if ( strcmp ( dbname , \"postgres\" ) == 0 ) appendPQExpBuffer ( buf , \"\\\\connect template1\\n\" ) ;\n"
                ],
                [
                    70,
                    " else appendPQExpBuffer ( buf , \"\\\\connect postgres\\n\" ) ;\n"
                ],
                [
                    76,
                    " appendPQExpBufferStr ( buf , \"-- For binary upgrade, set datfrozenxid and datminmxid.\\n\" ) ;\n"
                ],
                [
                    77,
                    " appendPQExpBuffer ( buf , \"UPDATE pg_catalog.pg_database \" \"SET datfrozenxid = '%u', datminmxid = '%u' \" \"WHERE datname = \" , dbfrozenxid , dbminmxid ) ;\n"
                ],
                [
                    78,
                    " appendStringLiteralConn ( buf , dbname , conn ) ;\n"
                ],
                [
                    82,
                    " if ( ! skip_acls && ! buildACLCommands ( fdbname , NULL , \"DATABASE\" , dbacl , rdbacl , dbowner , \"\" , server_version , buf ) ) {\n"
                ],
                [
                    83,
                    " fprintf ( stderr , _ ( \"%s: could not parse ACL list (%s) for database \\\"%s\\\"\\n\" ) , progname , dbacl , fdbname ) ;\n"
                ],
                [
                    87,
                    " fprintf ( OPF , \"%s\" , buf -> data ) ;\n"
                ],
                [
                    89,
                    " free ( fdbname ) ;\n"
                ],
                [
                    95,
                    " destroyPQExpBuffer ( buf ) ;\n"
                ],
                [
                    96,
                    " fprintf ( OPF , \"\\n\\n\" ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static void dumpCreateDB ( PGconn * conn ) {\n"
                ],
                [
                    3,
                    " char * default_encoding = NULL ;\n"
                ],
                [
                    4,
                    " char * default_collate = NULL ;\n"
                ],
                [
                    5,
                    " char * default_ctype = NULL ;\n"
                ],
                [
                    13,
                    " if ( ! PQgetisnull ( res , 0 , 0 ) ) default_encoding = pg_strdup ( PQgetvalue ( res , 0 , 0 ) ) ;\n"
                ],
                [
                    14,
                    " if ( ! PQgetisnull ( res , 0 , 1 ) ) default_collate = pg_strdup ( PQgetvalue ( res , 0 , 1 ) ) ;\n"
                ],
                [
                    15,
                    " if ( ! PQgetisnull ( res , 0 , 2 ) ) default_ctype = pg_strdup ( PQgetvalue ( res , 0 , 2 ) ) ;\n"
                ],
                [
                    29,
                    " i < PQntuples ( res ) ;\n"
                ],
                [
                    44,
                    " fdbname = pg_strdup ( fmtId ( dbname ) ) ;\n"
                ],
                [
                    47,
                    " appendPQExpBuffer ( buf , \"CREATE DATABASE %s\" , fdbname ) ;\n"
                ],
                [
                    50,
                    " if ( default_encoding && strcmp ( dbencoding , default_encoding ) != 0 ) {\n"
                ],
                [
                    54,
                    " if ( default_collate && strcmp ( dbcollate , default_collate ) != 0 ) {\n"
                ],
                [
                    58,
                    " if ( default_ctype && strcmp ( dbctype , default_ctype ) != 0 ) {\n"
                ],
                [
                    82,
                    " if ( ! skip_acls && ! buildACLCommands ( fdbname , NULL , \"DATABASE\" , dbacl , rdbacl , dbowner , \"\" , server_version , buf ) ) {\n"
                ],
                [
                    83,
                    " fprintf ( stderr , _ ( \"%s: could not parse ACL list (%s) for database \\\"%s\\\"\\n\" ) , progname , dbacl , fdbname ) ;\n"
                ],
                [
                    89,
                    " free ( fdbname ) ;\n"
                ],
                [
                    91,
                    " if ( default_encoding ) free ( default_encoding ) ;\n"
                ],
                [
                    92,
                    " if ( default_collate ) free ( default_collate ) ;\n"
                ],
                [
                    93,
                    " if ( default_ctype ) free ( default_ctype ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void dumpCreateDB ( PGconn * conn ) {\n"
                ],
                [
                    3,
                    " char * default_encoding = NULL ;\n"
                ],
                [
                    4,
                    " char * default_collate = NULL ;\n"
                ],
                [
                    5,
                    " char * default_ctype = NULL ;\n"
                ],
                [
                    8,
                    " fprintf ( OPF , \"--\\n-- Database creation\\n--\\n\\n\" ) ;\n"
                ],
                [
                    13,
                    " if ( ! PQgetisnull ( res , 0 , 0 ) ) default_encoding = pg_strdup ( PQgetvalue ( res , 0 , 0 ) ) ;\n"
                ],
                [
                    14,
                    " if ( ! PQgetisnull ( res , 0 , 1 ) ) default_collate = pg_strdup ( PQgetvalue ( res , 0 , 1 ) ) ;\n"
                ],
                [
                    15,
                    " if ( ! PQgetisnull ( res , 0 , 2 ) ) default_ctype = pg_strdup ( PQgetvalue ( res , 0 , 2 ) ) ;\n"
                ],
                [
                    29,
                    " i < PQntuples ( res ) ;\n"
                ],
                [
                    32,
                    " char * dbowner = PQgetvalue ( res , i , 1 ) ;\n"
                ],
                [
                    33,
                    " char * dbencoding = PQgetvalue ( res , i , 2 ) ;\n"
                ],
                [
                    34,
                    " char * dbcollate = PQgetvalue ( res , i , 3 ) ;\n"
                ],
                [
                    35,
                    " char * dbctype = PQgetvalue ( res , i , 4 ) ;\n"
                ],
                [
                    38,
                    " char * dbistemplate = PQgetvalue ( res , i , 7 ) ;\n"
                ],
                [
                    39,
                    " char * dbacl = PQgetvalue ( res , i , 8 ) ;\n"
                ],
                [
                    41,
                    " char * dbconnlimit = PQgetvalue ( res , i , 10 ) ;\n"
                ],
                [
                    42,
                    " char * dbtablespace = PQgetvalue ( res , i , 11 ) ;\n"
                ],
                [
                    44,
                    " fdbname = pg_strdup ( fmtId ( dbname ) ) ;\n"
                ],
                [
                    45,
                    " resetPQExpBuffer ( buf ) ;\n"
                ],
                [
                    46,
                    " if ( strcmp ( dbname , \"template1\" ) != 0 && strcmp ( dbname , \"postgres\" ) != 0 ) {\n"
                ],
                [
                    47,
                    " appendPQExpBuffer ( buf , \"CREATE DATABASE %s\" , fdbname ) ;\n"
                ],
                [
                    48,
                    " appendPQExpBufferStr ( buf , \" WITH TEMPLATE = template0\" ) ;\n"
                ],
                [
                    49,
                    " if ( strlen ( dbowner ) != 0 ) appendPQExpBuffer ( buf , \" OWNER = %s\" , fmtId ( dbowner ) ) ;\n"
                ],
                [
                    50,
                    " if ( default_encoding && strcmp ( dbencoding , default_encoding ) != 0 ) {\n"
                ],
                [
                    51,
                    " appendPQExpBufferStr ( buf , \" ENCODING = \" ) ;\n"
                ],
                [
                    52,
                    " appendStringLiteralConn ( buf , dbencoding , conn ) ;\n"
                ],
                [
                    54,
                    " if ( default_collate && strcmp ( dbcollate , default_collate ) != 0 ) {\n"
                ],
                [
                    55,
                    " appendPQExpBufferStr ( buf , \" LC_COLLATE = \" ) ;\n"
                ],
                [
                    56,
                    " appendStringLiteralConn ( buf , dbcollate , conn ) ;\n"
                ],
                [
                    58,
                    " if ( default_ctype && strcmp ( dbctype , default_ctype ) != 0 ) {\n"
                ],
                [
                    59,
                    " appendPQExpBufferStr ( buf , \" LC_CTYPE = \" ) ;\n"
                ],
                [
                    60,
                    " appendStringLiteralConn ( buf , dbctype , conn ) ;\n"
                ],
                [
                    62,
                    " if ( strcmp ( dbtablespace , \"pg_default\" ) != 0 && ! no_tablespaces ) appendPQExpBuffer ( buf , \" TABLESPACE = %s\" , fmtId ( dbtablespace ) ) ;\n"
                ],
                [
                    63,
                    " if ( strcmp ( dbistemplate , \"t\" ) == 0 ) appendPQExpBuffer ( buf , \" IS_TEMPLATE = true\" ) ;\n"
                ],
                [
                    64,
                    " if ( strcmp ( dbconnlimit , \"-1\" ) != 0 ) appendPQExpBuffer ( buf , \" CONNECTION LIMIT = %s\" , dbconnlimit ) ;\n"
                ],
                [
                    68,
                    " else if ( strcmp ( dbtablespace , \"pg_default\" ) != 0 && ! no_tablespaces ) {\n"
                ],
                [
                    69,
                    " if ( strcmp ( dbname , \"postgres\" ) == 0 ) appendPQExpBuffer ( buf , \"\\\\connect template1\\n\" ) ;\n"
                ],
                [
                    70,
                    " else appendPQExpBuffer ( buf , \"\\\\connect postgres\\n\" ) ;\n"
                ],
                [
                    76,
                    " appendPQExpBufferStr ( buf , \"-- For binary upgrade, set datfrozenxid and datminmxid.\\n\" ) ;\n"
                ],
                [
                    77,
                    " appendPQExpBuffer ( buf , \"UPDATE pg_catalog.pg_database \" \"SET datfrozenxid = '%u', datminmxid = '%u' \" \"WHERE datname = \" , dbfrozenxid , dbminmxid ) ;\n"
                ],
                [
                    78,
                    " appendStringLiteralConn ( buf , dbname , conn ) ;\n"
                ],
                [
                    82,
                    " if ( ! skip_acls && ! buildACLCommands ( fdbname , NULL , \"DATABASE\" , dbacl , rdbacl , dbowner , \"\" , server_version , buf ) ) {\n"
                ],
                [
                    83,
                    " fprintf ( stderr , _ ( \"%s: could not parse ACL list (%s) for database \\\"%s\\\"\\n\" ) , progname , dbacl , fdbname ) ;\n"
                ],
                [
                    87,
                    " fprintf ( OPF , \"%s\" , buf -> data ) ;\n"
                ],
                [
                    88,
                    " if ( server_version >= 70300 ) dumpDatabaseConfig ( conn , dbname ) ;\n"
                ],
                [
                    89,
                    " free ( fdbname ) ;\n"
                ],
                [
                    91,
                    " if ( default_encoding ) free ( default_encoding ) ;\n"
                ],
                [
                    92,
                    " if ( default_collate ) free ( default_collate ) ;\n"
                ],
                [
                    93,
                    " if ( default_ctype ) free ( default_ctype ) ;\n"
                ],
                [
                    95,
                    " destroyPQExpBuffer ( buf ) ;\n"
                ],
                [
                    96,
                    " fprintf ( OPF , \"\\n\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void dumpDatabases ( PGconn * conn ) {\n PGresult * res ;\n int i ;\n if ( server_version >= 70100 ) res = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1\" ) ;\n else res = executeQuery ( conn , \"SELECT datname FROM pg_database ORDER BY 1\" ) ;\n for ( i = 0 ;\n i < PQntuples ( res ) ;\n i ++ ) {\n int ret ;\n char * dbname = PQgetvalue ( res , i , 0 ) ;\n if ( verbose ) fprintf ( stderr , _ ( \"%s: dumping database \\\"%s\\\"...\\n\" ) , progname , dbname ) ;\n fprintf ( OPF , \"\\\\connect %s\\n\\n\" , fmtId ( dbname ) ) ;\n fprintf ( OPF , \"SET default_transaction_read_only = off;\n\\n\\n\" ) ;\n if ( filename ) fclose ( OPF ) ;\n ret = runPgDump ( dbname ) ;\n if ( ret != 0 ) {\n fprintf ( stderr , _ ( \"%s: pg_dump failed on database \\\"%s\\\", exiting\\n\" ) , progname , dbname ) ;\n exit_nicely ( 1 ) ;\n }\n if ( filename ) {\n OPF = fopen ( filename , PG_BINARY_A ) ;\n if ( ! OPF ) {\n fprintf ( stderr , _ ( \"%s: could not re-open the output file \\\"%s\\\": %s\\n\" ) , progname , filename , strerror ( errno ) ) ;\n exit_nicely ( 1 ) ;\n }\n }\n }\n PQclear ( res ) ;\n }",
        "hash": -6215323349888018447,
        "project": "debian",
        "size": 30,
        "slice": {
            "strerror": [
                [
                    1,
                    "static void dumpDatabases ( PGconn * conn ) {\n"
                ],
                [
                    23,
                    " if ( ! OPF ) {\n"
                ],
                [
                    24,
                    " fprintf ( stderr , _ ( \"%s: could not re-open the output file \\\"%s\\\": %s\\n\" ) , progname , filename , strerror ( errno ) ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void dumpDatabases ( PGconn * conn ) {\n"
                ],
                [
                    7,
                    " i < PQntuples ( res ) ;\n"
                ],
                [
                    10,
                    " char * dbname = PQgetvalue ( res , i , 0 ) ;\n"
                ],
                [
                    11,
                    " if ( verbose ) fprintf ( stderr , _ ( \"%s: dumping database \\\"%s\\\"...\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    12,
                    " fprintf ( OPF , \"\\\\connect %s\\n\\n\" , fmtId ( dbname ) ) ;\n"
                ],
                [
                    16,
                    " ret = runPgDump ( dbname ) ;\n"
                ],
                [
                    17,
                    " if ( ret != 0 ) {\n"
                ],
                [
                    18,
                    " fprintf ( stderr , _ ( \"%s: pg_dump failed on database \\\"%s\\\", exiting\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    22,
                    " OPF = fopen ( filename , PG_BINARY_A ) ;\n"
                ],
                [
                    23,
                    " if ( ! OPF ) {\n"
                ],
                [
                    24,
                    " fprintf ( stderr , _ ( \"%s: could not re-open the output file \\\"%s\\\": %s\\n\" ) , progname , filename , strerror ( errno ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void dumpDatabases ( PGconn * conn ) {\n"
                ],
                [
                    7,
                    " i < PQntuples ( res ) ;\n"
                ],
                [
                    10,
                    " char * dbname = PQgetvalue ( res , i , 0 ) ;\n"
                ],
                [
                    11,
                    " if ( verbose ) fprintf ( stderr , _ ( \"%s: dumping database \\\"%s\\\"...\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    12,
                    " fprintf ( OPF , \"\\\\connect %s\\n\\n\" , fmtId ( dbname ) ) ;\n"
                ],
                [
                    16,
                    " ret = runPgDump ( dbname ) ;\n"
                ],
                [
                    17,
                    " if ( ret != 0 ) {\n"
                ],
                [
                    18,
                    " fprintf ( stderr , _ ( \"%s: pg_dump failed on database \\\"%s\\\", exiting\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    22,
                    " OPF = fopen ( filename , PG_BINARY_A ) ;\n"
                ],
                [
                    23,
                    " if ( ! OPF ) {\n"
                ],
                [
                    24,
                    " fprintf ( stderr , _ ( \"%s: could not re-open the output file \\\"%s\\\": %s\\n\" ) , progname , filename , strerror ( errno ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static PGconn * connectDatabase ( const char * dbname , const char * connection_string , const char * pghost , const char * pgport , const char * pguser , trivalue prompt_password , bool fail_on_error ) {\n PGconn * conn ;\n bool new_pass ;\n const char * remoteversion_str ;\n int my_version ;\n static char * password = NULL ;\n const char * * keywords = NULL ;\n const char * * values = NULL ;\n PQconninfoOption * conn_opts = NULL ;\n if ( prompt_password == TRI_YES && ! password ) password = simple_prompt ( \"Password: \" , 100 , false ) ;\n do {\n int argcount = 6 ;\n PQconninfoOption * conn_opt ;\n char * err_msg = NULL ;\n int i = 0 ;\n if ( keywords ) free ( keywords ) ;\n if ( values ) free ( values ) ;\n if ( conn_opts ) PQconninfoFree ( conn_opts ) ;\n if ( connection_string ) {\n conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n if ( conn_opts == NULL ) {\n fprintf ( stderr , \"%s: %s\" , progname , err_msg ) ;\n exit_nicely ( 1 ) ;\n }\n for ( conn_opt = conn_opts ;\n conn_opt -> keyword != NULL ;\n conn_opt ++ ) {\n if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\\0' ) argcount ++ ;\n }\n keywords = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * keywords ) ) ;\n values = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * values ) ) ;\n for ( conn_opt = conn_opts ;\n conn_opt -> keyword != NULL ;\n conn_opt ++ ) {\n if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\\0' ) {\n keywords [ i ] = conn_opt -> keyword ;\n values [ i ] = conn_opt -> val ;\n i ++ ;\n }\n }\n }\n else {\n keywords = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * keywords ) ) ;\n values = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * values ) ) ;\n }\n if ( pghost ) {\n keywords [ i ] = \"host\" ;\n values [ i ] = pghost ;\n i ++ ;\n }\n if ( pgport ) {\n keywords [ i ] = \"port\" ;\n values [ i ] = pgport ;\n i ++ ;\n }\n if ( pguser ) {\n keywords [ i ] = \"user\" ;\n values [ i ] = pguser ;\n i ++ ;\n }\n if ( password ) {\n keywords [ i ] = \"password\" ;\n values [ i ] = password ;\n i ++ ;\n }\n if ( dbname ) {\n keywords [ i ] = \"dbname\" ;\n values [ i ] = dbname ;\n i ++ ;\n }\n keywords [ i ] = \"fallback_application_name\" ;\n values [ i ] = progname ;\n i ++ ;\n new_pass = false ;\n conn = PQconnectdbParams ( keywords , values , true ) ;\n if ( ! conn ) {\n fprintf ( stderr , _ ( \"%s: could not connect to database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n exit_nicely ( 1 ) ;\n }\n if ( PQstatus ( conn ) == CONNECTION_BAD && PQconnectionNeedsPassword ( conn ) && password == NULL && prompt_password != TRI_NO ) {\n PQfinish ( conn ) ;\n password = simple_prompt ( \"Password: \" , 100 , false ) ;\n new_pass = true ;\n }\n }\n while ( new_pass ) ;\n if ( PQstatus ( conn ) == CONNECTION_BAD ) {\n if ( fail_on_error ) {\n fprintf ( stderr , _ ( \"%s: could not connect to database \\\"%s\\\": %s\\n\" ) , progname , dbname , PQerrorMessage ( conn ) ) ;\n exit_nicely ( 1 ) ;\n }\n else {\n PQfinish ( conn ) ;\n free ( keywords ) ;\n free ( values ) ;\n PQconninfoFree ( conn_opts ) ;\n return NULL ;\n }\n }\n connstr = constructConnStr ( keywords , values ) ;\n free ( keywords ) ;\n free ( values ) ;\n PQconninfoFree ( conn_opts ) ;\n remoteversion_str = PQparameterStatus ( conn , \"server_version\" ) ;\n if ( ! remoteversion_str ) {\n fprintf ( stderr , _ ( \"%s: could not get server version\\n\" ) , progname ) ;\n exit_nicely ( 1 ) ;\n }\n server_version = PQserverVersion ( conn ) ;\n if ( server_version == 0 ) {\n fprintf ( stderr , _ ( \"%s: could not parse server version \\\"%s\\\"\\n\" ) , progname , remoteversion_str ) ;\n exit_nicely ( 1 ) ;\n }\n my_version = PG_VERSION_NUM ;\n if ( my_version != server_version && ( server_version < 70000 || ( server_version / 100 ) > ( my_version / 100 ) ) ) {\n fprintf ( stderr , _ ( \"server version: %s;\n %s version: %s\\n\" ) , remoteversion_str , progname , PG_VERSION ) ;\n fprintf ( stderr , _ ( \"aborting because of server version mismatch\\n\" ) ) ;\n exit_nicely ( 1 ) ;\n }\n if ( server_version >= 70300 ) executeCommand ( conn , \"SET search_path = pg_catalog\" ) ;\n return conn ;\n }",
        "hash": -6215323349888018447,
        "project": "debian",
        "size": 123,
        "slice": {
            "fprintf": [
                [
                    1,
                    "static PGconn * connectDatabase ( const char * dbname , const char * connection_string , const char * pghost , const char * pgport , const char * pguser , trivalue prompt_password , bool fail_on_error ) {\n"
                ],
                [
                    14,
                    " char * err_msg = NULL ;\n"
                ],
                [
                    20,
                    " conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n"
                ],
                [
                    21,
                    " if ( conn_opts == NULL ) {\n"
                ],
                [
                    22,
                    " fprintf ( stderr , \"%s: %s\" , progname , err_msg ) ;\n"
                ],
                [
                    68,
                    " values [ i ] = dbname ;\n"
                ],
                [
                    72,
                    " values [ i ] = progname ;\n"
                ],
                [
                    76,
                    " if ( ! conn ) {\n"
                ],
                [
                    77,
                    " fprintf ( stderr , _ ( \"%s: could not connect to database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    88,
                    " if ( fail_on_error ) {\n"
                ],
                [
                    89,
                    " fprintf ( stderr , _ ( \"%s: could not connect to database \\\"%s\\\": %s\\n\" ) , progname , dbname , PQerrorMessage ( conn ) ) ;\n"
                ],
                [
                    105,
                    " if ( ! remoteversion_str ) {\n"
                ],
                [
                    106,
                    " fprintf ( stderr , _ ( \"%s: could not get server version\\n\" ) , progname ) ;\n"
                ],
                [
                    110,
                    " if ( server_version == 0 ) {\n"
                ],
                [
                    111,
                    " fprintf ( stderr , _ ( \"%s: could not parse server version \\\"%s\\\"\\n\" ) , progname , remoteversion_str ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static PGconn * connectDatabase ( const char * dbname , const char * connection_string , const char * pghost , const char * pgport , const char * pguser , trivalue prompt_password , bool fail_on_error ) {\n"
                ],
                [
                    7,
                    " const char * * keywords = NULL ;\n"
                ],
                [
                    8,
                    " const char * * values = NULL ;\n"
                ],
                [
                    16,
                    " if ( keywords ) free ( keywords ) ;\n"
                ],
                [
                    17,
                    " if ( values ) free ( values ) ;\n"
                ],
                [
                    71,
                    " keywords [ i ] = \"fallback_application_name\" ;\n"
                ],
                [
                    72,
                    " values [ i ] = progname ;\n"
                ],
                [
                    75,
                    " conn = PQconnectdbParams ( keywords , values , true ) ;\n"
                ],
                [
                    87,
                    " if ( PQstatus ( conn ) == CONNECTION_BAD ) {\n"
                ],
                [
                    88,
                    " if ( fail_on_error ) {\n"
                ],
                [
                    94,
                    " free ( keywords ) ;\n"
                ],
                [
                    95,
                    " free ( values ) ;\n"
                ],
                [
                    100,
                    " connstr = constructConnStr ( keywords , values ) ;\n"
                ],
                [
                    101,
                    " free ( keywords ) ;\n"
                ],
                [
                    102,
                    " free ( values ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static PGconn * connectDatabase ( const char * dbname , const char * connection_string , const char * pghost , const char * pgport , const char * pguser , trivalue prompt_password , bool fail_on_error ) {\n"
                ],
                [
                    7,
                    " const char * * keywords = NULL ;\n"
                ],
                [
                    8,
                    " const char * * values = NULL ;\n"
                ],
                [
                    14,
                    " char * err_msg = NULL ;\n"
                ],
                [
                    16,
                    " if ( keywords ) free ( keywords ) ;\n"
                ],
                [
                    17,
                    " if ( values ) free ( values ) ;\n"
                ],
                [
                    20,
                    " conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n"
                ],
                [
                    21,
                    " if ( conn_opts == NULL ) {\n"
                ],
                [
                    22,
                    " fprintf ( stderr , \"%s: %s\" , progname , err_msg ) ;\n"
                ],
                [
                    68,
                    " values [ i ] = dbname ;\n"
                ],
                [
                    71,
                    " keywords [ i ] = \"fallback_application_name\" ;\n"
                ],
                [
                    72,
                    " values [ i ] = progname ;\n"
                ],
                [
                    75,
                    " conn = PQconnectdbParams ( keywords , values , true ) ;\n"
                ],
                [
                    76,
                    " if ( ! conn ) {\n"
                ],
                [
                    77,
                    " fprintf ( stderr , _ ( \"%s: could not connect to database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n"
                ],
                [
                    87,
                    " if ( PQstatus ( conn ) == CONNECTION_BAD ) {\n"
                ],
                [
                    88,
                    " if ( fail_on_error ) {\n"
                ],
                [
                    89,
                    " fprintf ( stderr , _ ( \"%s: could not connect to database \\\"%s\\\": %s\\n\" ) , progname , dbname , PQerrorMessage ( conn ) ) ;\n"
                ],
                [
                    94,
                    " free ( keywords ) ;\n"
                ],
                [
                    95,
                    " free ( values ) ;\n"
                ],
                [
                    100,
                    " connstr = constructConnStr ( keywords , values ) ;\n"
                ],
                [
                    101,
                    " free ( keywords ) ;\n"
                ],
                [
                    102,
                    " free ( values ) ;\n"
                ],
                [
                    105,
                    " if ( ! remoteversion_str ) {\n"
                ],
                [
                    106,
                    " fprintf ( stderr , _ ( \"%s: could not get server version\\n\" ) , progname ) ;\n"
                ],
                [
                    110,
                    " if ( server_version == 0 ) {\n"
                ],
                [
                    111,
                    " fprintf ( stderr , _ ( \"%s: could not parse server version \\\"%s\\\"\\n\" ) , progname , remoteversion_str ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void create_script_for_cluster_analyze ( char * * analyze_script_file_name ) {\n FILE * script = NULL ;\n char * user_specification = \"\" ;\n prep_status ( \"Creating script to analyze new cluster\" ) ;\n if ( os_info . user_specified ) user_specification = psprintf ( \"-U \\\"%s\\\" \" , os_info . user ) ;\n * analyze_script_file_name = psprintf ( \"%sanalyze_new_cluster.%s\" , SCRIPT_PREFIX , SCRIPT_EXT ) ;\n if ( ( script = fopen_priv ( * analyze_script_file_name , \"w\" ) ) == NULL ) pg_fatal ( \"Could not open file \\\"%s\\\": %s\\n\" , * analyze_script_file_name , getErrorText ( ) ) ;\n # ifndef WIN32 fprintf ( script , \"#!/bin/sh\\n\\n\" ) ;\n # else fprintf ( script , \"@echo off\\n\" ) ;\n # endif fprintf ( script , \"echo %sThis script will generate minimal optimizer statistics rapidly%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo %sso your system is usable, and then gather statistics twice more%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo %swith increasing accuracy. When it is done, your system will%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo %shave the default level of optimizer statistics.%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n fprintf ( script , \"echo %sIf you have used ALTER TABLE to modify the statistics target for%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo %sany tables, you might want to remove them and restore them after%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo %srunning this script because they will delay fast statistics generation.%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n fprintf ( script , \"echo %sIf you would like default statistics as quickly as possible, cancel%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo %sthis script and run:%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fprintf ( script , \"echo %s \\\"%s/vacuumdb\\\" %s--all %s%s\\n\" , ECHO_QUOTE , new_cluster . bindir , user_specification , ( GET_MAJOR_VERSION ( old_cluster . major_version ) >= 804 ) ? \"--analyze-only\" : \"--analyze\" , ECHO_QUOTE ) ;\n fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n fprintf ( script , \"\\\"%s/vacuumdb\\\" %s--all --analyze-in-stages\\n\" , new_cluster . bindir , user_specification ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) < 804 ) fprintf ( script , \"\\\"%s/vacuumdb\\\" %s--all\\n\" , new_cluster . bindir , user_specification ) ;\n fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n fprintf ( script , \"echo %sDone%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n fclose ( script ) ;\n # ifndef WIN32 if ( chmod ( * analyze_script_file_name , S_IRWXU ) != 0 ) pg_fatal ( \"Could not add execute permission to file \\\"%s\\\": %s\\n\" , * analyze_script_file_name , getErrorText ( ) ) ;\n # endif if ( os_info . user_specified ) pg_free ( user_specification ) ;\n check_ok ( ) ;\n }",
        "hash": 2830888773500127914,
        "project": "debian",
        "size": 31,
        "slice": {
            "fprintf": [
                [
                    1,
                    "void create_script_for_cluster_analyze ( char * * analyze_script_file_name ) {\n"
                ],
                [
                    3,
                    " char * user_specification = \"\" ;\n"
                ],
                [
                    5,
                    " if ( os_info . user_specified ) user_specification = psprintf ( \"-U \\\"%s\\\" \" , os_info . user ) ;\n"
                ],
                [
                    7,
                    " if ( ( script = fopen_priv ( * analyze_script_file_name , \"w\" ) ) == NULL ) pg_fatal ( \"Could not open file \\\"%s\\\": %s\\n\" , * analyze_script_file_name , getErrorText ( ) ) ;\n"
                ],
                [
                    11,
                    " fprintf ( script , \"echo %sso your system is usable, and then gather statistics twice more%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    12,
                    " fprintf ( script , \"echo %swith increasing accuracy. When it is done, your system will%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    13,
                    " fprintf ( script , \"echo %shave the default level of optimizer statistics.%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    14,
                    " fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n"
                ],
                [
                    15,
                    " fprintf ( script , \"echo %sIf you have used ALTER TABLE to modify the statistics target for%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    16,
                    " fprintf ( script , \"echo %sany tables, you might want to remove them and restore them after%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    17,
                    " fprintf ( script , \"echo %srunning this script because they will delay fast statistics generation.%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    18,
                    " fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n"
                ],
                [
                    19,
                    " fprintf ( script , \"echo %sIf you would like default statistics as quickly as possible, cancel%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    20,
                    " fprintf ( script , \"echo %sthis script and run:%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    21,
                    " fprintf ( script , \"echo %s \\\"%s/vacuumdb\\\" %s--all %s%s\\n\" , ECHO_QUOTE , new_cluster . bindir , user_specification , ( GET_MAJOR_VERSION ( old_cluster . major_version ) >= 804 ) ? \"--analyze-only\" : \"--analyze\" , ECHO_QUOTE ) ;\n"
                ],
                [
                    22,
                    " fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n"
                ],
                [
                    23,
                    " fprintf ( script , \"\\\"%s/vacuumdb\\\" %s--all --analyze-in-stages\\n\" , new_cluster . bindir , user_specification ) ;\n"
                ],
                [
                    24,
                    " if ( GET_MAJOR_VERSION ( old_cluster . major_version ) < 804 ) fprintf ( script , \"\\\"%s/vacuumdb\\\" %s--all\\n\" , new_cluster . bindir , user_specification ) ;\n"
                ],
                [
                    25,
                    " fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n"
                ],
                [
                    26,
                    " fprintf ( script , \"echo %sDone%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    27,
                    " fclose ( script ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void create_script_for_cluster_analyze ( char * * analyze_script_file_name ) {\n"
                ],
                [
                    3,
                    " char * user_specification = \"\" ;\n"
                ],
                [
                    5,
                    " if ( os_info . user_specified ) user_specification = psprintf ( \"-U \\\"%s\\\" \" , os_info . user ) ;\n"
                ],
                [
                    7,
                    " if ( ( script = fopen_priv ( * analyze_script_file_name , \"w\" ) ) == NULL ) pg_fatal ( \"Could not open file \\\"%s\\\": %s\\n\" , * analyze_script_file_name , getErrorText ( ) ) ;\n"
                ],
                [
                    11,
                    " fprintf ( script , \"echo %sso your system is usable, and then gather statistics twice more%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    12,
                    " fprintf ( script , \"echo %swith increasing accuracy. When it is done, your system will%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    13,
                    " fprintf ( script , \"echo %shave the default level of optimizer statistics.%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    14,
                    " fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n"
                ],
                [
                    15,
                    " fprintf ( script , \"echo %sIf you have used ALTER TABLE to modify the statistics target for%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    16,
                    " fprintf ( script , \"echo %sany tables, you might want to remove them and restore them after%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    17,
                    " fprintf ( script , \"echo %srunning this script because they will delay fast statistics generation.%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    18,
                    " fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n"
                ],
                [
                    19,
                    " fprintf ( script , \"echo %sIf you would like default statistics as quickly as possible, cancel%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    20,
                    " fprintf ( script , \"echo %sthis script and run:%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    21,
                    " fprintf ( script , \"echo %s \\\"%s/vacuumdb\\\" %s--all %s%s\\n\" , ECHO_QUOTE , new_cluster . bindir , user_specification , ( GET_MAJOR_VERSION ( old_cluster . major_version ) >= 804 ) ? \"--analyze-only\" : \"--analyze\" , ECHO_QUOTE ) ;\n"
                ],
                [
                    22,
                    " fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n"
                ],
                [
                    23,
                    " fprintf ( script , \"\\\"%s/vacuumdb\\\" %s--all --analyze-in-stages\\n\" , new_cluster . bindir , user_specification ) ;\n"
                ],
                [
                    24,
                    " if ( GET_MAJOR_VERSION ( old_cluster . major_version ) < 804 ) fprintf ( script , \"\\\"%s/vacuumdb\\\" %s--all\\n\" , new_cluster . bindir , user_specification ) ;\n"
                ],
                [
                    25,
                    " fprintf ( script , \"echo%s\\n\\n\" , ECHO_BLANK ) ;\n"
                ],
                [
                    26,
                    " fprintf ( script , \"echo %sDone%s\\n\" , ECHO_QUOTE , ECHO_QUOTE ) ;\n"
                ],
                [
                    27,
                    " fclose ( script ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * * argv ) {\n BlockBackend * blk ;\n BlockDriverState * bs ;\n off_t dev_offset = 0 ;\n uint16_t nbdflags = 0 ;\n bool disconnect = false ;\n const char * bindto = NULL ;\n const char * port = NULL ;\n char * sockpath = NULL ;\n char * device = NULL ;\n off_t fd_size ;\n QemuOpts * sn_opts = NULL ;\n const char * sn_id_or_name = NULL ;\n const char * sopt = \"hVb:o:p:rsnP:c:dvk:e:f:tl:x:T:D:\" ;\n struct option lopt [ ] = {\n {\n \"help\" , no_argument , NULL , 'h' }\n , {\n \"version\" , no_argument , NULL , 'V' }\n , {\n \"bind\" , required_argument , NULL , 'b' }\n , {\n \"port\" , required_argument , NULL , 'p' }\n , {\n \"socket\" , required_argument , NULL , 'k' }\n , {\n \"offset\" , required_argument , NULL , 'o' }\n , {\n \"read-only\" , no_argument , NULL , 'r' }\n , {\n \"partition\" , required_argument , NULL , 'P' }\n , {\n \"connect\" , required_argument , NULL , 'c' }\n , {\n \"disconnect\" , no_argument , NULL , 'd' }\n , {\n \"snapshot\" , no_argument , NULL , 's' }\n , {\n \"load-snapshot\" , required_argument , NULL , 'l' }\n , {\n \"nocache\" , no_argument , NULL , 'n' }\n , {\n \"cache\" , required_argument , NULL , QEMU_NBD_OPT_CACHE }\n , {\n \"aio\" , required_argument , NULL , QEMU_NBD_OPT_AIO }\n , {\n \"discard\" , required_argument , NULL , QEMU_NBD_OPT_DISCARD }\n , {\n \"detect-zeroes\" , required_argument , NULL , QEMU_NBD_OPT_DETECT_ZEROES }\n , {\n \"shared\" , required_argument , NULL , 'e' }\n , {\n \"format\" , required_argument , NULL , 'f' }\n , {\n \"persistent\" , no_argument , NULL , 't' }\n , {\n \"verbose\" , no_argument , NULL , 'v' }\n , {\n \"object\" , required_argument , NULL , QEMU_NBD_OPT_OBJECT }\n , {\n \"export-name\" , required_argument , NULL , 'x' }\n , {\n \"description\" , required_argument , NULL , 'D' }\n , {\n \"tls-creds\" , required_argument , NULL , QEMU_NBD_OPT_TLSCREDS }\n , {\n \"image-opts\" , no_argument , NULL , QEMU_NBD_OPT_IMAGE_OPTS }\n , {\n \"trace\" , required_argument , NULL , 'T' }\n , {\n \"fork\" , no_argument , NULL , QEMU_NBD_OPT_FORK }\n , {\n NULL , 0 , NULL , 0 }\n }\n ;\n int ch ;\n int opt_ind = 0 ;\n char * end ;\n int flags = BDRV_O_RDWR ;\n int partition = - 1 ;\n int ret = 0 ;\n bool seen_cache = false ;\n bool seen_discard = false ;\n bool seen_aio = false ;\n pthread_t client_thread ;\n const char * fmt = NULL ;\n Error * local_err = NULL ;\n BlockdevDetectZeroesOptions detect_zeroes = BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF ;\n QDict * options = NULL ;\n const char * export_name = NULL ;\n const char * export_description = NULL ;\n const char * tlscredsid = NULL ;\n bool imageOpts = false ;\n bool writethrough = true ;\n char * trace_file = NULL ;\n bool fork_process = false ;\n int old_stderr = - 1 ;\n unsigned socket_activation ;\n struct sigaction sa_sigterm ;\n memset ( & sa_sigterm , 0 , sizeof ( sa_sigterm ) ) ;\n sa_sigterm . sa_handler = termsig_handler ;\n sigaction ( SIGTERM , & sa_sigterm , NULL ) ;\n module_call_init ( MODULE_INIT_TRACE ) ;\n qcrypto_init ( & error_fatal ) ;\n module_call_init ( MODULE_INIT_QOM ) ;\n qemu_add_opts ( & qemu_object_opts ) ;\n qemu_add_opts ( & qemu_trace_opts ) ;\n qemu_init_exec_dir ( argv [ 0 ] ) ;\n while ( ( ch = getopt_long ( argc , argv , sopt , lopt , & opt_ind ) ) != - 1 ) {\n switch ( ch ) {\n case 's' : flags |= BDRV_O_SNAPSHOT ;\n break ;\n case 'n' : optarg = ( char * ) \"none\" ;\n case QEMU_NBD_OPT_CACHE : if ( seen_cache ) {\n error_report ( \"-n and --cache can only be specified once\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n seen_cache = true ;\n if ( bdrv_parse_cache_mode ( optarg , & flags , & writethrough ) == - 1 ) {\n error_report ( \"Invalid cache mode `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case QEMU_NBD_OPT_AIO : if ( seen_aio ) {\n error_report ( \"--aio can only be specified once\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n seen_aio = true ;\n if ( ! strcmp ( optarg , \"native\" ) ) {\n flags |= BDRV_O_NATIVE_AIO ;\n }\n else if ( ! strcmp ( optarg , \"threads\" ) ) {\n }\n else {\n error_report ( \"invalid aio mode `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case QEMU_NBD_OPT_DISCARD : if ( seen_discard ) {\n error_report ( \"--discard can only be specified once\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n seen_discard = true ;\n if ( bdrv_parse_discard_flags ( optarg , & flags ) == - 1 ) {\n error_report ( \"Invalid discard mode `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case QEMU_NBD_OPT_DETECT_ZEROES : detect_zeroes = qapi_enum_parse ( BlockdevDetectZeroesOptions_lookup , optarg , BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX , BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF , & local_err ) ;\n if ( local_err ) {\n error_reportf_err ( local_err , \"Failed to parse detect_zeroes mode: \" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP && ! ( flags & BDRV_O_UNMAP ) ) {\n error_report ( \"setting detect-zeroes to unmap is not allowed \" \"without setting discard operation to unmap\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'b' : bindto = optarg ;\n break ;\n case 'p' : port = optarg ;\n break ;\n case 'o' : dev_offset = strtoll ( optarg , & end , 0 ) ;\n if ( * end ) {\n error_report ( \"Invalid offset `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( dev_offset < 0 ) {\n error_report ( \"Offset must be positive `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'l' : if ( strstart ( optarg , SNAPSHOT_OPT_BASE , NULL ) ) {\n sn_opts = qemu_opts_parse_noisily ( & internal_snapshot_opts , optarg , false ) ;\n if ( ! sn_opts ) {\n error_report ( \"Failed in parsing snapshot param `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n else {\n sn_id_or_name = optarg ;\n }\n case 'r' : nbdflags |= NBD_FLAG_READ_ONLY ;\n flags &= ~ BDRV_O_RDWR ;\n break ;\n case 'P' : partition = strtol ( optarg , & end , 0 ) ;\n if ( * end ) {\n error_report ( \"Invalid partition `%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( partition < 1 || partition > 8 ) {\n error_report ( \"Invalid partition %d\" , partition ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'k' : sockpath = optarg ;\n if ( sockpath [ 0 ] != '/' ) {\n error_report ( \"socket path must be absolute\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'd' : disconnect = true ;\n break ;\n case 'c' : device = optarg ;\n break ;\n case 'e' : shared = strtol ( optarg , & end , 0 ) ;\n if ( * end ) {\n error_report ( \"Invalid shared device number '%s'\" , optarg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( shared < 1 ) {\n error_report ( \"Shared device number must be greater than 0\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n break ;\n case 'f' : fmt = optarg ;\n break ;\n case 't' : persistent = 1 ;\n break ;\n case 'x' : export_name = optarg ;\n break ;\n case 'D' : export_description = optarg ;\n break ;\n case 'v' : verbose = 1 ;\n break ;\n case 'V' : version ( argv [ 0 ] ) ;\n exit ( 0 ) ;\n break ;\n case 'h' : usage ( argv [ 0 ] ) ;\n exit ( 0 ) ;\n break ;\n case '?' : error_report ( \"Try `%s --help' for more information.\" , argv [ 0 ] ) ;\n exit ( EXIT_FAILURE ) ;\n case QEMU_NBD_OPT_OBJECT : {\n QemuOpts * opts ;\n opts = qemu_opts_parse_noisily ( & qemu_object_opts , optarg , true ) ;\n if ( ! opts ) {\n exit ( EXIT_FAILURE ) ;\n }\n }\n break ;\n case QEMU_NBD_OPT_TLSCREDS : tlscredsid = optarg ;\n break ;\n case QEMU_NBD_OPT_IMAGE_OPTS : imageOpts = true ;\n break ;\n case 'T' : g_free ( trace_file ) ;\n trace_file = trace_opt_parse ( optarg ) ;\n break ;\n case QEMU_NBD_OPT_FORK : fork_process = true ;\n break ;\n }\n }\n if ( ( argc - optind ) != 1 ) {\n error_report ( \"Invalid number of arguments\" ) ;\n error_printf ( \"Try `%s --help' for more information.\\n\" , argv [ 0 ] ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( qemu_opts_foreach ( & qemu_object_opts , user_creatable_add_opts_foreach , NULL , NULL ) ) {\n exit ( EXIT_FAILURE ) ;\n }\n if ( ! trace_init_backends ( ) ) {\n exit ( 1 ) ;\n }\n trace_init_file ( trace_file ) ;\n qemu_set_log ( LOG_TRACE ) ;\n socket_activation = check_socket_activation ( ) ;\n if ( socket_activation == 0 ) {\n setup_address_and_port ( & bindto , & port ) ;\n }\n else {\n const char * err_msg = socket_activation_validate_opts ( device , sockpath , bindto , port ) ;\n if ( err_msg != NULL ) {\n error_report ( \"%s\" , err_msg ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( socket_activation > 1 ) {\n error_report ( \"qemu-nbd does not support socket activation with %s > 1\" , \"LISTEN_FDS\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n if ( tlscredsid ) {\n if ( sockpath ) {\n error_report ( \"TLS is only supported with IPv4/IPv6\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( device ) {\n error_report ( \"TLS is not supported with a host device\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( ! export_name ) {\n export_name = \"\" ;\n }\n tlscreds = nbd_get_tls_creds ( tlscredsid , & local_err ) ;\n if ( local_err ) {\n error_report ( \"Failed to get TLS creds %s\" , error_get_pretty ( local_err ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n if ( disconnect ) {\n int nbdfd = open ( argv [ optind ] , O_RDWR ) ;\n if ( nbdfd < 0 ) {\n error_report ( \"Cannot open %s: %s\" , argv [ optind ] , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n nbd_disconnect ( nbdfd ) ;\n close ( nbdfd ) ;\n printf ( \"%s disconnected\\n\" , argv [ optind ] ) ;\n return 0 ;\n }\n if ( ( device && ! verbose ) || fork_process ) {\n int stderr_fd [ 2 ] ;\n pid_t pid ;\n int ret ;\n if ( qemu_pipe ( stderr_fd ) < 0 ) {\n error_report ( \"Error setting up communication pipe: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n pid = fork ( ) ;\n if ( pid < 0 ) {\n error_report ( \"Failed to fork: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n else if ( pid == 0 ) {\n close ( stderr_fd [ 0 ] ) ;\n ret = qemu_daemon ( 1 , 0 ) ;\n old_stderr = dup ( STDERR_FILENO ) ;\n dup2 ( stderr_fd [ 1 ] , STDERR_FILENO ) ;\n if ( ret < 0 ) {\n error_report ( \"Failed to daemonize: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n close ( stderr_fd [ 1 ] ) ;\n }\n else {\n bool errors = false ;\n char * buf ;\n close ( stderr_fd [ 1 ] ) ;\n buf = g_malloc ( 1024 ) ;\n while ( ( ret = read ( stderr_fd [ 0 ] , buf , 1024 ) ) > 0 ) {\n errors = true ;\n ret = qemu_write_full ( STDERR_FILENO , buf , ret ) ;\n if ( ret < 0 ) {\n exit ( EXIT_FAILURE ) ;\n }\n }\n if ( ret < 0 ) {\n error_report ( \"Cannot read from daemon: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n exit ( errors ) ;\n }\n }\n if ( device != NULL && sockpath == NULL ) {\n sockpath = g_malloc ( 128 ) ;\n snprintf ( sockpath , 128 , SOCKET_PATH , basename ( device ) ) ;\n }\n if ( socket_activation == 0 ) {\n server_ioc = qio_channel_socket_new ( ) ;\n saddr = nbd_build_socket_address ( sockpath , bindto , port ) ;\n if ( qio_channel_socket_listen_sync ( server_ioc , saddr , & local_err ) < 0 ) {\n object_unref ( OBJECT ( server_ioc ) ) ;\n error_report_err ( local_err ) ;\n return 1 ;\n }\n }\n else {\n assert ( socket_activation == 1 ) ;\n server_ioc = qio_channel_socket_new_fd ( FIRST_SOCKET_ACTIVATION_FD , & local_err ) ;\n if ( server_ioc == NULL ) {\n error_report ( \"Failed to use socket activation: %s\" , error_get_pretty ( local_err ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n if ( qemu_init_main_loop ( & local_err ) ) {\n error_report_err ( local_err ) ;\n exit ( EXIT_FAILURE ) ;\n }\n bdrv_init ( ) ;\n atexit ( bdrv_close_all ) ;\n srcpath = argv [ optind ] ;\n if ( imageOpts ) {\n QemuOpts * opts ;\n if ( fmt ) {\n error_report ( \"--image-opts and -f are mutually exclusive\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n opts = qemu_opts_parse_noisily ( & file_opts , srcpath , true ) ;\n if ( ! opts ) {\n qemu_opts_reset ( & file_opts ) ;\n exit ( EXIT_FAILURE ) ;\n }\n options = qemu_opts_to_qdict ( opts , NULL ) ;\n qemu_opts_reset ( & file_opts ) ;\n blk = blk_new_open ( NULL , NULL , options , flags , & local_err ) ;\n }\n else {\n if ( fmt ) {\n options = qdict_new ( ) ;\n qdict_put_str ( options , \"driver\" , fmt ) ;\n }\n blk = blk_new_open ( srcpath , NULL , options , flags , & local_err ) ;\n }\n if ( ! blk ) {\n error_reportf_err ( local_err , \"Failed to blk_new_open '%s': \" , argv [ optind ] ) ;\n exit ( EXIT_FAILURE ) ;\n }\n bs = blk_bs ( blk ) ;\n blk_set_enable_write_cache ( blk , ! writethrough ) ;\n if ( sn_opts ) {\n ret = bdrv_snapshot_load_tmp ( bs , qemu_opt_get ( sn_opts , SNAPSHOT_OPT_ID ) , qemu_opt_get ( sn_opts , SNAPSHOT_OPT_NAME ) , & local_err ) ;\n }\n else if ( sn_id_or_name ) {\n ret = bdrv_snapshot_load_tmp_by_id_or_name ( bs , sn_id_or_name , & local_err ) ;\n }\n if ( ret < 0 ) {\n error_reportf_err ( local_err , \"Failed to load snapshot: \" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n bs -> detect_zeroes = detect_zeroes ;\n fd_size = blk_getlength ( blk ) ;\n if ( fd_size < 0 ) {\n error_report ( \"Failed to determine the image length: %s\" , strerror ( - fd_size ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( dev_offset >= fd_size ) {\n error_report ( \"Offset (%lld) has to be smaller than the image size \" \"(%lld)\" , ( long long int ) dev_offset , ( long long int ) fd_size ) ;\n exit ( EXIT_FAILURE ) ;\n }\n fd_size -= dev_offset ;\n if ( partition != - 1 ) {\n ret = find_partition ( blk , partition , & dev_offset , & fd_size ) ;\n if ( ret < 0 ) {\n error_report ( \"Could not find partition %d: %s\" , partition , strerror ( - ret ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n exp = nbd_export_new ( bs , dev_offset , fd_size , nbdflags , nbd_export_closed , writethrough , NULL , & local_err ) ;\n if ( ! exp ) {\n error_report_err ( local_err ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( export_name ) {\n nbd_export_set_name ( exp , export_name ) ;\n nbd_export_set_description ( exp , export_description ) ;\n newproto = true ;\n }\n else if ( export_description ) {\n error_report ( \"Export description requires an export name\" ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( device ) {\n int ret ;\n ret = pthread_create ( & client_thread , NULL , nbd_client_thread , device ) ;\n if ( ret != 0 ) {\n error_report ( \"Failed to create client thread: %s\" , strerror ( ret ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n }\n else {\n memset ( & client_thread , 0 , sizeof ( client_thread ) ) ;\n }\n nbd_update_server_watch ( ) ;\n if ( chdir ( \"/\" ) < 0 ) {\n error_report ( \"Could not chdir to root directory: %s\" , strerror ( errno ) ) ;\n exit ( EXIT_FAILURE ) ;\n }\n if ( fork_process ) {\n dup2 ( old_stderr , STDERR_FILENO ) ;\n close ( old_stderr ) ;\n }\n state = RUNNING ;\n do {\n main_loop_wait ( false ) ;\n if ( state == TERMINATE ) {\n state = TERMINATING ;\n nbd_export_close ( exp ) ;\n nbd_export_put ( exp ) ;\n exp = NULL ;\n }\n }\n while ( state != TERMINATED ) ;\n blk_unref ( blk ) ;\n if ( sockpath ) {\n unlink ( sockpath ) ;\n }\n qemu_opts_del ( sn_opts ) ;\n if ( device ) {\n void * ret ;\n pthread_join ( client_thread , & ret ) ;\n exit ( ret != NULL ) ;\n }\n else {\n exit ( EXIT_SUCCESS ) ;\n }\n }",
        "hash": 4206838170759624883,
        "project": "debian",
        "size": 495,
        "slice": {
            "memset": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    100,
                    " memset ( & sa_sigterm , 0 , sizeof ( sa_sigterm ) ) ;\n"
                ],
                [
                    102,
                    " sigaction ( SIGTERM , & sa_sigterm , NULL ) ;\n"
                ],
                [
                    451,
                    " if ( device ) {\n"
                ],
                [
                    460,
                    " memset ( & client_thread , 0 , sizeof ( client_thread ) ) ;\n"
                ],
                [
                    489,
                    " pthread_join ( client_thread , & ret ) ;\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    110,
                    " switch ( ch ) {\n"
                ],
                [
                    119,
                    " if ( bdrv_parse_cache_mode ( optarg , & flags , & writethrough ) == - 1 ) {\n"
                ],
                [
                    120,
                    " error_report ( \"Invalid cache mode `%s'\" , optarg ) ;\n"
                ],
                [
                    129,
                    " if ( ! strcmp ( optarg , \"native\" ) ) {\n"
                ],
                [
                    130,
                    " flags |= BDRV_O_NATIVE_AIO ;\n"
                ],
                [
                    132,
                    " else if ( ! strcmp ( optarg , \"threads\" ) ) {\n"
                ],
                [
                    135,
                    " error_report ( \"invalid aio mode `%s'\" , optarg ) ;\n"
                ],
                [
                    136,
                    " exit ( EXIT_FAILURE ) ;\n"
                ],
                [
                    144,
                    " if ( bdrv_parse_discard_flags ( optarg , & flags ) == - 1 ) {\n"
                ],
                [
                    145,
                    " error_report ( \"Invalid discard mode `%s'\" , optarg ) ;\n"
                ],
                [
                    149,
                    " case QEMU_NBD_OPT_DETECT_ZEROES : detect_zeroes = qapi_enum_parse ( BlockdevDetectZeroesOptions_lookup , optarg , BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX , BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF , & local_err ) ;\n"
                ],
                [
                    159,
                    " case 'b' : bindto = optarg ;\n"
                ],
                [
                    161,
                    " case 'p' : port = optarg ;\n"
                ],
                [
                    163,
                    " case 'o' : dev_offset = strtoll ( optarg , & end , 0 ) ;\n"
                ],
                [
                    165,
                    " error_report ( \"Invalid offset `%s'\" , optarg ) ;\n"
                ],
                [
                    169,
                    " error_report ( \"Offset must be positive `%s'\" , optarg ) ;\n"
                ],
                [
                    173,
                    " case 'l' : if ( strstart ( optarg , SNAPSHOT_OPT_BASE , NULL ) ) {\n"
                ],
                [
                    174,
                    " sn_opts = qemu_opts_parse_noisily ( & internal_snapshot_opts , optarg , false ) ;\n"
                ],
                [
                    176,
                    " error_report ( \"Failed in parsing snapshot param `%s'\" , optarg ) ;\n"
                ],
                [
                    186,
                    " case 'P' : partition = strtol ( optarg , & end , 0 ) ;\n"
                ],
                [
                    188,
                    " error_report ( \"Invalid partition `%s'\" , optarg ) ;\n"
                ],
                [
                    196,
                    " case 'k' : sockpath = optarg ;\n"
                ],
                [
                    204,
                    " case 'c' : device = optarg ;\n"
                ],
                [
                    206,
                    " case 'e' : shared = strtol ( optarg , & end , 0 ) ;\n"
                ],
                [
                    208,
                    " error_report ( \"Invalid shared device number '%s'\" , optarg ) ;\n"
                ],
                [
                    216,
                    " case 'f' : fmt = optarg ;\n"
                ],
                [
                    220,
                    " case 'x' : export_name = optarg ;\n"
                ],
                [
                    222,
                    " case 'D' : export_description = optarg ;\n"
                ],
                [
                    236,
                    " opts = qemu_opts_parse_noisily ( & qemu_object_opts , optarg , true ) ;\n"
                ],
                [
                    242,
                    " case QEMU_NBD_OPT_TLSCREDS : tlscredsid = optarg ;\n"
                ],
                [
                    247,
                    " trace_file = trace_opt_parse ( optarg ) ;\n"
                ]
            ],
            "strerror": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    301,
                    " if ( nbdfd < 0 ) {\n"
                ],
                [
                    302,
                    " error_report ( \"Cannot open %s: %s\" , argv [ optind ] , strerror ( errno ) ) ;\n"
                ],
                [
                    314,
                    " if ( qemu_pipe ( stderr_fd ) < 0 ) {\n"
                ],
                [
                    315,
                    " error_report ( \"Error setting up communication pipe: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    319,
                    " if ( pid < 0 ) {\n"
                ],
                [
                    320,
                    " error_report ( \"Failed to fork: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    328,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    329,
                    " error_report ( \"Failed to daemonize: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    346,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    347,
                    " error_report ( \"Cannot read from daemon: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    421,
                    " if ( fd_size < 0 ) {\n"
                ],
                [
                    422,
                    " error_report ( \"Failed to determine the image length: %s\" , strerror ( - fd_size ) ) ;\n"
                ],
                [
                    432,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    433,
                    " error_report ( \"Could not find partition %d: %s\" , partition , strerror ( - ret ) ) ;\n"
                ],
                [
                    454,
                    " if ( ret != 0 ) {\n"
                ],
                [
                    455,
                    " error_report ( \"Failed to create client thread: %s\" , strerror ( ret ) ) ;\n"
                ],
                [
                    463,
                    " if ( chdir ( \"/\" ) < 0 ) {\n"
                ],
                [
                    464,
                    " error_report ( \"Could not chdir to root directory: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    489,
                    " pthread_join ( client_thread , & ret ) ;\n"
                ],
                [
                    490,
                    " exit ( ret != NULL ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    109,
                    " while ( ( ch = getopt_long ( argc , argv , sopt , lopt , & opt_ind ) ) != - 1 ) {\n"
                ],
                [
                    299,
                    " if ( disconnect ) {\n"
                ],
                [
                    300,
                    " int nbdfd = open ( argv [ optind ] , O_RDWR ) ;\n"
                ],
                [
                    302,
                    " error_report ( \"Cannot open %s: %s\" , argv [ optind ] , strerror ( errno ) ) ;\n"
                ],
                [
                    307,
                    " printf ( \"%s disconnected\\n\" , argv [ optind ] ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    100,
                    " memset ( & sa_sigterm , 0 , sizeof ( sa_sigterm ) ) ;\n"
                ],
                [
                    102,
                    " sigaction ( SIGTERM , & sa_sigterm , NULL ) ;\n"
                ],
                [
                    109,
                    " while ( ( ch = getopt_long ( argc , argv , sopt , lopt , & opt_ind ) ) != - 1 ) {\n"
                ],
                [
                    110,
                    " switch ( ch ) {\n"
                ],
                [
                    119,
                    " if ( bdrv_parse_cache_mode ( optarg , & flags , & writethrough ) == - 1 ) {\n"
                ],
                [
                    120,
                    " error_report ( \"Invalid cache mode `%s'\" , optarg ) ;\n"
                ],
                [
                    129,
                    " if ( ! strcmp ( optarg , \"native\" ) ) {\n"
                ],
                [
                    130,
                    " flags |= BDRV_O_NATIVE_AIO ;\n"
                ],
                [
                    132,
                    " else if ( ! strcmp ( optarg , \"threads\" ) ) {\n"
                ],
                [
                    135,
                    " error_report ( \"invalid aio mode `%s'\" , optarg ) ;\n"
                ],
                [
                    136,
                    " exit ( EXIT_FAILURE ) ;\n"
                ],
                [
                    144,
                    " if ( bdrv_parse_discard_flags ( optarg , & flags ) == - 1 ) {\n"
                ],
                [
                    145,
                    " error_report ( \"Invalid discard mode `%s'\" , optarg ) ;\n"
                ],
                [
                    149,
                    " case QEMU_NBD_OPT_DETECT_ZEROES : detect_zeroes = qapi_enum_parse ( BlockdevDetectZeroesOptions_lookup , optarg , BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX , BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF , & local_err ) ;\n"
                ],
                [
                    159,
                    " case 'b' : bindto = optarg ;\n"
                ],
                [
                    161,
                    " case 'p' : port = optarg ;\n"
                ],
                [
                    163,
                    " case 'o' : dev_offset = strtoll ( optarg , & end , 0 ) ;\n"
                ],
                [
                    165,
                    " error_report ( \"Invalid offset `%s'\" , optarg ) ;\n"
                ],
                [
                    169,
                    " error_report ( \"Offset must be positive `%s'\" , optarg ) ;\n"
                ],
                [
                    173,
                    " case 'l' : if ( strstart ( optarg , SNAPSHOT_OPT_BASE , NULL ) ) {\n"
                ],
                [
                    174,
                    " sn_opts = qemu_opts_parse_noisily ( & internal_snapshot_opts , optarg , false ) ;\n"
                ],
                [
                    176,
                    " error_report ( \"Failed in parsing snapshot param `%s'\" , optarg ) ;\n"
                ],
                [
                    186,
                    " case 'P' : partition = strtol ( optarg , & end , 0 ) ;\n"
                ],
                [
                    188,
                    " error_report ( \"Invalid partition `%s'\" , optarg ) ;\n"
                ],
                [
                    196,
                    " case 'k' : sockpath = optarg ;\n"
                ],
                [
                    204,
                    " case 'c' : device = optarg ;\n"
                ],
                [
                    206,
                    " case 'e' : shared = strtol ( optarg , & end , 0 ) ;\n"
                ],
                [
                    208,
                    " error_report ( \"Invalid shared device number '%s'\" , optarg ) ;\n"
                ],
                [
                    216,
                    " case 'f' : fmt = optarg ;\n"
                ],
                [
                    220,
                    " case 'x' : export_name = optarg ;\n"
                ],
                [
                    222,
                    " case 'D' : export_description = optarg ;\n"
                ],
                [
                    236,
                    " opts = qemu_opts_parse_noisily ( & qemu_object_opts , optarg , true ) ;\n"
                ],
                [
                    242,
                    " case QEMU_NBD_OPT_TLSCREDS : tlscredsid = optarg ;\n"
                ],
                [
                    247,
                    " trace_file = trace_opt_parse ( optarg ) ;\n"
                ],
                [
                    299,
                    " if ( disconnect ) {\n"
                ],
                [
                    300,
                    " int nbdfd = open ( argv [ optind ] , O_RDWR ) ;\n"
                ],
                [
                    301,
                    " if ( nbdfd < 0 ) {\n"
                ],
                [
                    302,
                    " error_report ( \"Cannot open %s: %s\" , argv [ optind ] , strerror ( errno ) ) ;\n"
                ],
                [
                    307,
                    " printf ( \"%s disconnected\\n\" , argv [ optind ] ) ;\n"
                ],
                [
                    314,
                    " if ( qemu_pipe ( stderr_fd ) < 0 ) {\n"
                ],
                [
                    315,
                    " error_report ( \"Error setting up communication pipe: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    319,
                    " if ( pid < 0 ) {\n"
                ],
                [
                    320,
                    " error_report ( \"Failed to fork: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    328,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    329,
                    " error_report ( \"Failed to daemonize: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    346,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    347,
                    " error_report ( \"Cannot read from daemon: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    421,
                    " if ( fd_size < 0 ) {\n"
                ],
                [
                    422,
                    " error_report ( \"Failed to determine the image length: %s\" , strerror ( - fd_size ) ) ;\n"
                ],
                [
                    432,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    433,
                    " error_report ( \"Could not find partition %d: %s\" , partition , strerror ( - ret ) ) ;\n"
                ],
                [
                    451,
                    " if ( device ) {\n"
                ],
                [
                    454,
                    " if ( ret != 0 ) {\n"
                ],
                [
                    455,
                    " error_report ( \"Failed to create client thread: %s\" , strerror ( ret ) ) ;\n"
                ],
                [
                    460,
                    " memset ( & client_thread , 0 , sizeof ( client_thread ) ) ;\n"
                ],
                [
                    463,
                    " if ( chdir ( \"/\" ) < 0 ) {\n"
                ],
                [
                    464,
                    " error_report ( \"Could not chdir to root directory: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    489,
                    " pthread_join ( client_thread , & ret ) ;\n"
                ],
                [
                    490,
                    " exit ( ret != NULL ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static inline void vmsvga_fill_rect ( struct vmsvga_state_s * s , uint32_t c , int x , int y , int w , int h ) {\n DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;\n int bypl = surface_stride ( surface ) ;\n int width = surface_bytes_per_pixel ( surface ) * w ;\n int line = h ;\n int column ;\n uint8_t * fst ;\n uint8_t * dst ;\n uint8_t * src ;\n uint8_t col [ 4 ] ;\n col [ 0 ] = c ;\n col [ 1 ] = c >> 8 ;\n col [ 2 ] = c >> 16 ;\n col [ 3 ] = c >> 24 ;\n fst = s -> vga . vram_ptr + surface_bytes_per_pixel ( surface ) * x + bypl * y ;\n if ( line -- ) {\n dst = fst ;\n src = col ;\n for ( column = width ;\n column > 0 ;\n column -- ) {\n * ( dst ++ ) = * ( src ++ ) ;\n if ( src - col == surface_bytes_per_pixel ( surface ) ) {\n src = col ;\n }\n }\n dst = fst ;\n for ( ;\n line > 0 ;\n line -- ) {\n dst += bypl ;\n memcpy ( dst , fst , width ) ;\n }\n }\n vmsvga_update_rect_delayed ( s , x , y , w , h ) ;\n }",
        "hash": 3649198920984613385,
        "project": "debian",
        "size": 36,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static inline void vmsvga_fill_rect ( struct vmsvga_state_s * s , uint32_t c , int x , int y , int w , int h ) {\n"
                ],
                [
                    4,
                    " int width = surface_bytes_per_pixel ( surface ) * w ;\n"
                ],
                [
                    15,
                    " fst = s -> vga . vram_ptr + surface_bytes_per_pixel ( surface ) * x + bypl * y ;\n"
                ],
                [
                    29,
                    " line > 0 ;\n"
                ],
                [
                    31,
                    " dst += bypl ;\n"
                ],
                [
                    32,
                    " memcpy ( dst , fst , width ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static inline void vmsvga_fill_rect ( struct vmsvga_state_s * s , uint32_t c , int x , int y , int w , int h ) {\n"
                ],
                [
                    4,
                    " int width = surface_bytes_per_pixel ( surface ) * w ;\n"
                ],
                [
                    15,
                    " fst = s -> vga . vram_ptr + surface_bytes_per_pixel ( surface ) * x + bypl * y ;\n"
                ],
                [
                    29,
                    " line > 0 ;\n"
                ],
                [
                    31,
                    " dst += bypl ;\n"
                ],
                [
                    32,
                    " memcpy ( dst , fst , width ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static inline void vmsvga_copy_rect ( struct vmsvga_state_s * s , int x0 , int y0 , int x1 , int y1 , int w , int h ) {\n DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;\n uint8_t * vram = s -> vga . vram_ptr ;\n int bypl = surface_stride ( surface ) ;\n int bypp = surface_bytes_per_pixel ( surface ) ;\n int width = bypp * w ;\n int line = h ;\n uint8_t * ptr [ 2 ] ;\n if ( y1 > y0 ) {\n ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 ) ;\n ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 ) ;\n for ( ;\n line > 0 ;\n line -- , ptr [ 0 ] -= bypl , ptr [ 1 ] -= bypl ) {\n memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n }\n }\n else {\n ptr [ 0 ] = vram + bypp * x0 + bypl * y0 ;\n ptr [ 1 ] = vram + bypp * x1 + bypl * y1 ;\n for ( ;\n line > 0 ;\n line -- , ptr [ 0 ] += bypl , ptr [ 1 ] += bypl ) {\n memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n }\n }\n vmsvga_update_rect_delayed ( s , x1 , y1 , w , h ) ;\n }",
        "hash": 3649198920984613385,
        "project": "debian",
        "size": 28,
        "slice": {
            "memmove": [
                [
                    1,
                    "static inline void vmsvga_copy_rect ( struct vmsvga_state_s * s , int x0 , int y0 , int x1 , int y1 , int w , int h ) {\n"
                ],
                [
                    6,
                    " int width = bypp * w ;\n"
                ],
                [
                    8,
                    " uint8_t * ptr [ 2 ] ;\n"
                ],
                [
                    10,
                    " ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 ) ;\n"
                ],
                [
                    11,
                    " ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 ) ;\n"
                ],
                [
                    13,
                    " line > 0 ;\n"
                ],
                [
                    14,
                    " line -- , ptr [ 0 ] -= bypl , ptr [ 1 ] -= bypl ) {\n"
                ],
                [
                    15,
                    " memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n"
                ],
                [
                    19,
                    " ptr [ 0 ] = vram + bypp * x0 + bypl * y0 ;\n"
                ],
                [
                    20,
                    " ptr [ 1 ] = vram + bypp * x1 + bypl * y1 ;\n"
                ],
                [
                    22,
                    " line > 0 ;\n"
                ],
                [
                    23,
                    " line -- , ptr [ 0 ] += bypl , ptr [ 1 ] += bypl ) {\n"
                ],
                [
                    24,
                    " memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static inline void vmsvga_copy_rect ( struct vmsvga_state_s * s , int x0 , int y0 , int x1 , int y1 , int w , int h ) {\n"
                ],
                [
                    6,
                    " int width = bypp * w ;\n"
                ],
                [
                    8,
                    " uint8_t * ptr [ 2 ] ;\n"
                ],
                [
                    10,
                    " ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 ) ;\n"
                ],
                [
                    11,
                    " ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 ) ;\n"
                ],
                [
                    13,
                    " line > 0 ;\n"
                ],
                [
                    14,
                    " line -- , ptr [ 0 ] -= bypl , ptr [ 1 ] -= bypl ) {\n"
                ],
                [
                    15,
                    " memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n"
                ],
                [
                    19,
                    " ptr [ 0 ] = vram + bypp * x0 + bypl * y0 ;\n"
                ],
                [
                    20,
                    " ptr [ 1 ] = vram + bypp * x1 + bypl * y1 ;\n"
                ],
                [
                    22,
                    " line > 0 ;\n"
                ],
                [
                    23,
                    " line -- , ptr [ 0 ] += bypl , ptr [ 1 ] += bypl ) {\n"
                ],
                [
                    24,
                    " memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void do_exec ( struct st_command * command ) {\n int error ;\n char buf [ 512 ] ;\n FILE * res_file ;\n char * cmd = command -> first_argument ;\n DYNAMIC_STRING ds_cmd ;\n DYNAMIC_STRING ds_sorted , * ds_result ;\n DBUG_ENTER ( \"do_exec\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"cmd: '%s'\" , cmd ) ) ;\n while ( * cmd && my_isspace ( charset_info , * cmd ) ) cmd ++ ;\n if ( ! * cmd ) {\n report_or_die ( \"Missing argument in exec\" ) ;\n return ;\n }\n command -> last_argument = command -> end ;\n init_dynamic_string ( & ds_cmd , 0 , command -> query_len + 256 , 256 ) ;\n do_eval ( & ds_cmd , cmd , command -> end , ! is_windows ) ;\n if ( builtin_echo [ 0 ] && strncmp ( cmd , \"echo\" , 4 ) == 0 ) {\n replace ( & ds_cmd , \"echo\" , 4 , builtin_echo , strlen ( builtin_echo ) ) ;\n }\n # ifdef __WIN__ # ifndef USE_CYGWIN while ( replace ( & ds_cmd , \"/devull\" , 9 , \"NUL\" , 3 ) == 0 ) ;\n while ( replace ( & ds_cmd , \">&-\" , 3 , \">&4\" , 3 ) == 0 ) ;\n # endif # endif while ( replace ( & ds_cmd , \"\\n\" , 1 , \" \" , 1 ) == 0 ) ;\n DBUG_PRINT ( \"info\" , ( \"Executing '%s' as '%s'\" , command -> first_argument , ds_cmd . str ) ) ;\n if ( ! ( res_file = my_popen ( & ds_cmd , \"r\" ) ) ) {\n dynstr_free ( & ds_cmd ) ;\n if ( command -> abort_on_error ) report_or_die ( \"popen(\\\"%s\\\", \\\"r\\\") failed\" , command -> first_argument ) ;\n return ;\n }\n ds_result = & ds_res ;\n if ( display_result_sorted ) {\n init_dynamic_string ( & ds_sorted , \"\" , 1024 , 1024 ) ;\n ds_result = & ds_sorted ;\n }\n while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n if ( disable_result_log ) {\n buf [ strlen ( buf ) - 1 ] = 0 ;\n DBUG_PRINT ( \"exec_result\" , ( \"%s\" , buf ) ) ;\n }\n else {\n replace_dynstr_append ( ds_result , buf ) ;\n }\n }\n error = pclose ( res_file ) ;\n if ( display_result_sorted ) {\n dynstr_append_sorted ( & ds_res , & ds_sorted , 0 ) ;\n dynstr_free ( & ds_sorted ) ;\n }\n if ( error > 0 ) {\n uint status = WEXITSTATUS ( error ) ;\n int i ;\n if ( command -> abort_on_error ) {\n report_or_die ( \"exec of '%s' failed, error: %d, status: %d, errno: %d\\n\" \"Output from before failure:\\n%s\\n\" , ds_cmd . str , error , status , errno , ds_res . str ) ;\n dynstr_free ( & ds_cmd ) ;\n return ;\n }\n DBUG_PRINT ( \"info\" , ( \"error: %d, status: %d\" , error , status ) ) ;\n i = match_expected_error ( command , status , NULL ) ;\n if ( i >= 0 ) DBUG_PRINT ( \"info\" , ( \"command \\\"%s\\\" failed with expected error: %d\" , command -> first_argument , status ) ) ;\n else {\n dynstr_free ( & ds_cmd ) ;\n if ( command -> expected_errors . count > 0 ) report_or_die ( \"command \\\"%s\\\" failed with wrong error: %d\" , command -> first_argument , status ) ;\n }\n }\n else if ( command -> expected_errors . err [ 0 ] . type == ERR_ERRNO && command -> expected_errors . err [ 0 ] . code . errnum != 0 ) {\n log_msg ( \"exec of '%s failed, error: %d, errno: %d\" , ds_cmd . str , error , errno ) ;\n dynstr_free ( & ds_cmd ) ;\n report_or_die ( \"command \\\"%s\\\" succeeded - should have failed with \" \"errno %d...\" , command -> first_argument , command -> expected_errors . err [ 0 ] . code . errnum ) ;\n }\n dynstr_free ( & ds_cmd ) ;\n DBUG_VOID_RETURN ;\n }",
        "hash": 1182028467273264883,
        "project": "debian",
        "size": 72,
        "slice": {
            "strlen": [
                [
                    1,
                    "void do_exec ( struct st_command * command ) {\n"
                ],
                [
                    18,
                    " if ( builtin_echo [ 0 ] && strncmp ( cmd , \"echo\" , 4 ) == 0 ) {\n"
                ],
                [
                    19,
                    " replace ( & ds_cmd , \"echo\" , 4 , builtin_echo , strlen ( builtin_echo ) ) ;\n"
                ],
                [
                    35,
                    " while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n"
                ],
                [
                    36,
                    " if ( disable_result_log ) {\n"
                ],
                [
                    37,
                    " buf [ strlen ( buf ) - 1 ] = 0 ;\n"
                ],
                [
                    38,
                    " DBUG_PRINT ( \"exec_result\" , ( \"%s\" , buf ) ) ;\n"
                ],
                [
                    41,
                    " replace_dynstr_append ( ds_result , buf ) ;\n"
                ]
            ],
            "fgets": [
                [
                    1,
                    "void do_exec ( struct st_command * command ) {\n"
                ],
                [
                    25,
                    " if ( ! ( res_file = my_popen ( & ds_cmd , \"r\" ) ) ) {\n"
                ],
                [
                    35,
                    " while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n"
                ],
                [
                    36,
                    " if ( disable_result_log ) {\n"
                ],
                [
                    37,
                    " buf [ strlen ( buf ) - 1 ] = 0 ;\n"
                ],
                [
                    41,
                    " replace_dynstr_append ( ds_result , buf ) ;\n"
                ],
                [
                    44,
                    " error = pclose ( res_file ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void do_exec ( struct st_command * command ) {\n"
                ],
                [
                    18,
                    " if ( builtin_echo [ 0 ] && strncmp ( cmd , \"echo\" , 4 ) == 0 ) {\n"
                ],
                [
                    19,
                    " replace ( & ds_cmd , \"echo\" , 4 , builtin_echo , strlen ( builtin_echo ) ) ;\n"
                ],
                [
                    25,
                    " if ( ! ( res_file = my_popen ( & ds_cmd , \"r\" ) ) ) {\n"
                ],
                [
                    35,
                    " while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n"
                ],
                [
                    36,
                    " if ( disable_result_log ) {\n"
                ],
                [
                    37,
                    " buf [ strlen ( buf ) - 1 ] = 0 ;\n"
                ],
                [
                    38,
                    " DBUG_PRINT ( \"exec_result\" , ( \"%s\" , buf ) ) ;\n"
                ],
                [
                    41,
                    " replace_dynstr_append ( ds_result , buf ) ;\n"
                ],
                [
                    44,
                    " error = pclose ( res_file ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int EVP_EncryptUpdate ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n int i , j , bl ;\n if ( ctx -> cipher -> flags & EVP_CIPH_FLAG_CUSTOM_CIPHER ) {\n i = ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ;\n if ( i < 0 ) return 0 ;\n else * outl = i ;\n return 1 ;\n }\n if ( inl <= 0 ) {\n * outl = 0 ;\n return inl == 0 ;\n }\n if ( ctx -> buf_len == 0 && ( inl & ( ctx -> block_mask ) ) == 0 ) {\n if ( ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ) {\n * outl = inl ;\n return 1 ;\n }\n else {\n * outl = 0 ;\n return 0 ;\n }\n }\n i = ctx -> buf_len ;\n bl = ctx -> cipher -> block_size ;\n OPENSSL_assert ( bl <= ( int ) sizeof ( ctx -> buf ) ) ;\n if ( i != 0 ) {\n if ( i + inl < bl ) {\n memcpy ( & ( ctx -> buf [ i ] ) , in , inl ) ;\n ctx -> buf_len += inl ;\n * outl = 0 ;\n return 1 ;\n }\n else {\n j = bl - i ;\n memcpy ( & ( ctx -> buf [ i ] ) , in , j ) ;\n if ( ! ctx -> cipher -> do_cipher ( ctx , out , ctx -> buf , bl ) ) return 0 ;\n inl -= j ;\n in += j ;\n out += bl ;\n * outl = bl ;\n }\n }\n else * outl = 0 ;\n i = inl & ( bl - 1 ) ;\n inl -= i ;\n if ( inl > 0 ) {\n if ( ! ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ) return 0 ;\n * outl += inl ;\n }\n if ( i != 0 ) memcpy ( ctx -> buf , & ( in [ inl ] ) , i ) ;\n ctx -> buf_len = i ;\n return 1 ;\n }",
        "hash": 1700977331036764538,
        "project": "debian",
        "size": 53,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int EVP_EncryptUpdate ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n"
                ],
                [
                    9,
                    " if ( inl <= 0 ) {\n"
                ],
                [
                    13,
                    " if ( ctx -> buf_len == 0 && ( inl & ( ctx -> block_mask ) ) == 0 ) {\n"
                ],
                [
                    27,
                    " if ( i + inl < bl ) {\n"
                ],
                [
                    28,
                    " memcpy ( & ( ctx -> buf [ i ] ) , in , inl ) ;\n"
                ],
                [
                    29,
                    " ctx -> buf_len += inl ;\n"
                ],
                [
                    34,
                    " j = bl - i ;\n"
                ],
                [
                    35,
                    " memcpy ( & ( ctx -> buf [ i ] ) , in , j ) ;\n"
                ],
                [
                    36,
                    " if ( ! ctx -> cipher -> do_cipher ( ctx , out , ctx -> buf , bl ) ) return 0 ;\n"
                ],
                [
                    37,
                    " inl -= j ;\n"
                ],
                [
                    38,
                    " in += j ;\n"
                ],
                [
                    47,
                    " if ( ! ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ) return 0 ;\n"
                ],
                [
                    50,
                    " if ( i != 0 ) memcpy ( ctx -> buf , & ( in [ inl ] ) , i ) ;\n"
                ],
                [
                    51,
                    " ctx -> buf_len = i ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int EVP_EncryptUpdate ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n"
                ],
                [
                    9,
                    " if ( inl <= 0 ) {\n"
                ],
                [
                    13,
                    " if ( ctx -> buf_len == 0 && ( inl & ( ctx -> block_mask ) ) == 0 ) {\n"
                ],
                [
                    27,
                    " if ( i + inl < bl ) {\n"
                ],
                [
                    28,
                    " memcpy ( & ( ctx -> buf [ i ] ) , in , inl ) ;\n"
                ],
                [
                    29,
                    " ctx -> buf_len += inl ;\n"
                ],
                [
                    34,
                    " j = bl - i ;\n"
                ],
                [
                    35,
                    " memcpy ( & ( ctx -> buf [ i ] ) , in , j ) ;\n"
                ],
                [
                    36,
                    " if ( ! ctx -> cipher -> do_cipher ( ctx , out , ctx -> buf , bl ) ) return 0 ;\n"
                ],
                [
                    37,
                    " inl -= j ;\n"
                ],
                [
                    38,
                    " in += j ;\n"
                ],
                [
                    47,
                    " if ( ! ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ) return 0 ;\n"
                ],
                [
                    50,
                    " if ( i != 0 ) memcpy ( ctx -> buf , & ( in [ inl ] ) , i ) ;\n"
                ],
                [
                    51,
                    " ctx -> buf_len = i ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int userauth_pubkey ( struct ssh * ssh ) {\n Authctxt * authctxt = ssh -> authctxt ;\n struct passwd * pw = authctxt -> pw ;\n struct sshbuf * b ;\n struct sshkey * key = NULL ;\n char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;\n u_char * pkblob , * sig , have_sig ;\n size_t blen , slen ;\n int r , pktype ;\n int authenticated = 0 ;\n struct sshauthopt * authopts = NULL ;\n if ( ! authctxt -> valid ) {\n debug2 ( \"%s: disabled because of invalid user\" , __func__ ) ;\n return 0 ;\n }\n if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( \"%s: parse request failed: %s\" , __func__ , ssh_err ( r ) ) ;\n pktype = sshkey_type_from_name ( pkalg ) ;\n if ( pktype == KEY_UNSPEC ) {\n verbose ( \"%s: unsupported public key algorithm: %s\" , __func__ , pkalg ) ;\n goto done ;\n }\n if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n error ( \"%s: could not parse key: %s\" , __func__ , ssh_err ( r ) ) ;\n goto done ;\n }\n if ( key == NULL ) {\n error ( \"%s: cannot decode key: %s\" , __func__ , pkalg ) ;\n goto done ;\n }\n if ( key -> type != pktype ) {\n error ( \"%s: type mismatch for decoded key \" \"(received %d, expected %d)\" , __func__ , key -> type , pktype ) ;\n goto done ;\n }\n if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) {\n logit ( \"Refusing RSA key because client uses unsafe \" \"signature scheme\" ) ;\n goto done ;\n }\n if ( auth2_key_already_used ( authctxt , key ) ) {\n logit ( \"refusing previously-used %s key\" , sshkey_type ( key ) ) ;\n goto done ;\n }\n if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) {\n logit ( \"%s: key type %s not in PubkeyAcceptedKeyTypes\" , __func__ , sshkey_ssh_name ( key ) ) ;\n goto done ;\n }\n key_s = format_key ( key ) ;\n if ( sshkey_is_cert ( key ) ) ca_s = format_key ( key -> cert -> signature_key ) ;\n if ( have_sig ) {\n debug3 ( \"%s: have %s signature for %s%s%s\" , __func__ , pkalg , key_s , ca_s == NULL ? \"\" : \" CA \" , ca_s == NULL ? \"\" : ca_s ) ;\n if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( \"%s: %s\" , __func__ , ssh_err ( r ) ) ;\n if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( \"%s: sshbuf_new failed\" , __func__ ) ;\n if ( ssh -> compat & SSH_OLD_SESSIONID ) {\n if ( ( r = sshbuf_put ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( \"%s: sshbuf_put session id: %s\" , __func__ , ssh_err ( r ) ) ;\n }\n else {\n if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( \"%s: sshbuf_put_string session id: %s\" , __func__ , ssh_err ( r ) ) ;\n }\n xasprintf ( & userstyle , \"%s%s%s\" , authctxt -> user , authctxt -> style ? \":\" : \"\" , authctxt -> style ? authctxt -> style : \"\" ) ;\n if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , \"publickey\" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( \"%s: build packet failed: %s\" , __func__ , ssh_err ( r ) ) ;\n # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ;\n # endif authenticated = 0 ;\n if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) {\n authenticated = 1 ;\n }\n sshbuf_free ( b ) ;\n free ( sig ) ;\n auth2_record_key ( authctxt , authenticated , key ) ;\n }\n else {\n debug ( \"%s: test pkalg %s pkblob %s%s%s\" , __func__ , pkalg , key_s , ca_s == NULL ? \"\" : \" CA \" , ca_s == NULL ? \"\" : ca_s ) ;\n if ( ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( \"%s: %s\" , __func__ , ssh_err ( r ) ) ;\n if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) {\n if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( \"%s: %s\" , __func__ , ssh_err ( r ) ) ;\n authctxt -> postponed = 1 ;\n }\n }\n done : if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) {\n debug ( \"%s: key options inconsistent with existing\" , __func__ ) ;\n authenticated = 0 ;\n }\n debug2 ( \"%s: authenticated %d pkalg %s\" , __func__ , authenticated , pkalg ) ;\n sshauthopt_free ( authopts ) ;\n sshkey_free ( key ) ;\n free ( userstyle ) ;\n free ( pkalg ) ;\n free ( pkblob ) ;\n free ( key_s ) ;\n free ( ca_s ) ;\n return authenticated ;\n }",
        "hash": 7847057953677889923,
        "project": "debian",
        "size": 90,
        "slice": {
            "free": [
                [
                    1,
                    "static int userauth_pubkey ( struct ssh * ssh ) {\n"
                ],
                [
                    6,
                    " char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;\n"
                ],
                [
                    12,
                    " if ( ! authctxt -> valid ) {\n"
                ],
                [
                    16,
                    " if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( \"%s: parse request failed: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    22,
                    " if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n"
                ],
                [
                    48,
                    " if ( have_sig ) {\n"
                ],
                [
                    49,
                    " debug3 ( \"%s: have %s signature for %s%s%s\" , __func__ , pkalg , key_s , ca_s == NULL ? \"\" : \" CA \" , ca_s == NULL ? \"\" : ca_s ) ;\n"
                ],
                [
                    50,
                    " if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( \"%s: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    58,
                    " xasprintf ( & userstyle , \"%s%s%s\" , authctxt -> user , authctxt -> style ? \":\" : \"\" , authctxt -> style ? authctxt -> style : \"\" ) ;\n"
                ],
                [
                    59,
                    " if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , \"publickey\" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( \"%s: build packet failed: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    62,
                    " if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) {\n"
                ],
                [
                    66,
                    " free ( sig ) ;\n"
                ],
                [
                    70,
                    " debug ( \"%s: test pkalg %s pkblob %s%s%s\" , __func__ , pkalg , key_s , ca_s == NULL ? \"\" : \" CA \" , ca_s == NULL ? \"\" : ca_s ) ;\n"
                ],
                [
                    73,
                    " if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( \"%s: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    81,
                    " debug2 ( \"%s: authenticated %d pkalg %s\" , __func__ , authenticated , pkalg ) ;\n"
                ],
                [
                    84,
                    " free ( userstyle ) ;\n"
                ],
                [
                    85,
                    " free ( pkalg ) ;\n"
                ],
                [
                    86,
                    " free ( pkblob ) ;\n"
                ],
                [
                    87,
                    " free ( key_s ) ;\n"
                ],
                [
                    88,
                    " free ( ca_s ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int userauth_pubkey ( struct ssh * ssh ) {\n"
                ],
                [
                    6,
                    " char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;\n"
                ],
                [
                    12,
                    " if ( ! authctxt -> valid ) {\n"
                ],
                [
                    16,
                    " if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( \"%s: parse request failed: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    22,
                    " if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n"
                ],
                [
                    48,
                    " if ( have_sig ) {\n"
                ],
                [
                    49,
                    " debug3 ( \"%s: have %s signature for %s%s%s\" , __func__ , pkalg , key_s , ca_s == NULL ? \"\" : \" CA \" , ca_s == NULL ? \"\" : ca_s ) ;\n"
                ],
                [
                    50,
                    " if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( \"%s: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    58,
                    " xasprintf ( & userstyle , \"%s%s%s\" , authctxt -> user , authctxt -> style ? \":\" : \"\" , authctxt -> style ? authctxt -> style : \"\" ) ;\n"
                ],
                [
                    59,
                    " if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , \"publickey\" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( \"%s: build packet failed: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    62,
                    " if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) {\n"
                ],
                [
                    66,
                    " free ( sig ) ;\n"
                ],
                [
                    70,
                    " debug ( \"%s: test pkalg %s pkblob %s%s%s\" , __func__ , pkalg , key_s , ca_s == NULL ? \"\" : \" CA \" , ca_s == NULL ? \"\" : ca_s ) ;\n"
                ],
                [
                    73,
                    " if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( \"%s: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    81,
                    " debug2 ( \"%s: authenticated %d pkalg %s\" , __func__ , authenticated , pkalg ) ;\n"
                ],
                [
                    84,
                    " free ( userstyle ) ;\n"
                ],
                [
                    85,
                    " free ( pkalg ) ;\n"
                ],
                [
                    86,
                    " free ( pkblob ) ;\n"
                ],
                [
                    87,
                    " free ( key_s ) ;\n"
                ],
                [
                    88,
                    " free ( ca_s ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int userauth_hostbased ( struct ssh * ssh ) {\n Authctxt * authctxt = ssh -> authctxt ;\n struct sshbuf * b ;\n struct sshkey * key = NULL ;\n char * pkalg , * cuser , * chost ;\n u_char * pkblob , * sig ;\n size_t alen , blen , slen ;\n int r , pktype , authenticated = 0 ;\n if ( ! authctxt -> valid ) {\n debug2 ( \"%s: disabled because of invalid user\" , __func__ ) ;\n return 0 ;\n }\n if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( \"%s: packet parsing: %s\" , __func__ , ssh_err ( r ) ) ;\n debug ( \"%s: cuser %s chost %s pkalg %s slen %zu\" , __func__ , cuser , chost , pkalg , slen ) ;\n # ifdef DEBUG_PK debug ( \"signature:\" ) ;\n sshbuf_dump_data ( sig , siglen , stderr ) ;\n # endif pktype = sshkey_type_from_name ( pkalg ) ;\n if ( pktype == KEY_UNSPEC ) {\n logit ( \"%s: unsupported public key algorithm: %s\" , __func__ , pkalg ) ;\n goto done ;\n }\n if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n error ( \"%s: key_from_blob: %s\" , __func__ , ssh_err ( r ) ) ;\n goto done ;\n }\n if ( key == NULL ) {\n error ( \"%s: cannot decode key: %s\" , __func__ , pkalg ) ;\n goto done ;\n }\n if ( key -> type != pktype ) {\n error ( \"%s: type mismatch for decoded key \" \"(received %d, expected %d)\" , __func__ , key -> type , pktype ) ;\n goto done ;\n }\n if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) {\n error ( \"Refusing RSA key because peer uses unsafe \" \"signature format\" ) ;\n goto done ;\n }\n if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) {\n logit ( \"%s: key type %s not in HostbasedAcceptedKeyTypes\" , __func__ , sshkey_type ( key ) ) ;\n goto done ;\n }\n if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( \"%s: sshbuf_new failed\" , __func__ ) ;\n if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , \"hostbased\" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( \"%s: buffer error: %s\" , __func__ , ssh_err ( r ) ) ;\n # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ;\n # endif auth2_record_info ( authctxt , \"client user \\\"%.100s\\\", client host \\\"%.100s\\\"\" , cuser , chost ) ;\n authenticated = 0 ;\n if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ;\n auth2_record_key ( authctxt , authenticated , key ) ;\n sshbuf_free ( b ) ;\n done : debug2 ( \"%s: authenticated %d\" , __func__ , authenticated ) ;\n sshkey_free ( key ) ;\n free ( pkalg ) ;\n free ( pkblob ) ;\n free ( cuser ) ;\n free ( chost ) ;\n free ( sig ) ;\n return authenticated ;\n }",
        "hash": 3126874532712459970,
        "project": "debian",
        "size": 58,
        "slice": {
            "free": [
                [
                    1,
                    "static int userauth_hostbased ( struct ssh * ssh ) {\n"
                ],
                [
                    9,
                    " if ( ! authctxt -> valid ) {\n"
                ],
                [
                    13,
                    " if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( \"%s: packet parsing: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    14,
                    " debug ( \"%s: cuser %s chost %s pkalg %s slen %zu\" , __func__ , cuser , chost , pkalg , slen ) ;\n"
                ],
                [
                    19,
                    " logit ( \"%s: unsupported public key algorithm: %s\" , __func__ , pkalg ) ;\n"
                ],
                [
                    22,
                    " if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n"
                ],
                [
                    27,
                    " error ( \"%s: cannot decode key: %s\" , __func__ , pkalg ) ;\n"
                ],
                [
                    38,
                    " if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) {\n"
                ],
                [
                    43,
                    " if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , \"hostbased\" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( \"%s: buffer error: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    47,
                    " if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ;\n"
                ],
                [
                    52,
                    " free ( pkalg ) ;\n"
                ],
                [
                    53,
                    " free ( pkblob ) ;\n"
                ],
                [
                    54,
                    " free ( cuser ) ;\n"
                ],
                [
                    55,
                    " free ( chost ) ;\n"
                ],
                [
                    56,
                    " free ( sig ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int userauth_hostbased ( struct ssh * ssh ) {\n"
                ],
                [
                    9,
                    " if ( ! authctxt -> valid ) {\n"
                ],
                [
                    13,
                    " if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( \"%s: packet parsing: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    14,
                    " debug ( \"%s: cuser %s chost %s pkalg %s slen %zu\" , __func__ , cuser , chost , pkalg , slen ) ;\n"
                ],
                [
                    19,
                    " logit ( \"%s: unsupported public key algorithm: %s\" , __func__ , pkalg ) ;\n"
                ],
                [
                    22,
                    " if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n"
                ],
                [
                    27,
                    " error ( \"%s: cannot decode key: %s\" , __func__ , pkalg ) ;\n"
                ],
                [
                    38,
                    " if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) {\n"
                ],
                [
                    43,
                    " if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , \"hostbased\" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( \"%s: buffer error: %s\" , __func__ , ssh_err ( r ) ) ;\n"
                ],
                [
                    47,
                    " if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ;\n"
                ],
                [
                    52,
                    " free ( pkalg ) ;\n"
                ],
                [
                    53,
                    " free ( pkblob ) ;\n"
                ],
                [
                    54,
                    " free ( cuser ) ;\n"
                ],
                [
                    55,
                    " free ( chost ) ;\n"
                ],
                [
                    56,
                    " free ( sig ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int rtp_packetize_xiph_config ( sout_stream_id_sys_t * id , const char * fmtp , int64_t i_pts ) {\n if ( fmtp == NULL ) return VLC_EGENERIC ;\n char * start = strstr ( fmtp , \"configuration=\" ) ;\n assert ( start != NULL ) ;\n start += sizeof ( \"configuration=\" ) - 1 ;\n char * end = strchr ( start , ';\n' ) ;\n assert ( end != NULL ) ;\n size_t len = end - start ;\n char b64 [ len + 1 ] ;\n memcpy ( b64 , start , len ) ;\n b64 [ len ] = '\\0' ;\n int i_max = rtp_mtu ( id ) - 6 ;\n uint8_t * p_orig , * p_data ;\n int i_data ;\n i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ;\n if ( i_data <= 9 ) {\n free ( p_orig ) ;\n return VLC_EGENERIC ;\n }\n p_data = p_orig + 9 ;\n i_data -= 9 ;\n int i_count = ( i_data + i_max - 1 ) / i_max ;\n for ( int i = 0 ;\n i < i_count ;\n i ++ ) {\n int i_payload = __MIN ( i_max , i_data ) ;\n block_t * out = block_Alloc ( 18 + i_payload ) ;\n unsigned fragtype , numpkts ;\n if ( i_count == 1 ) {\n fragtype = 0 ;\n numpkts = 1 ;\n }\n else {\n numpkts = 0 ;\n if ( i == 0 ) fragtype = 1 ;\n else if ( i == i_count - 1 ) fragtype = 3 ;\n else fragtype = 2 ;\n }\n uint32_t header = ( ( XIPH_IDENT & 0xffffff ) << 8 ) | ( fragtype << 6 ) | ( 1 << 4 ) | numpkts ;\n rtp_packetize_common ( id , out , 0 , i_pts ) ;\n SetDWBE ( out -> p_buffer + 12 , header ) ;\n SetWBE ( out -> p_buffer + 16 , i_payload ) ;\n memcpy ( & out -> p_buffer [ 18 ] , p_data , i_payload ) ;\n out -> i_dts = i_pts ;\n rtp_packetize_send ( id , out ) ;\n p_data += i_payload ;\n i_data -= i_payload ;\n }\n free ( p_orig ) ;\n return VLC_SUCCESS ;\n }",
        "hash": 3935234056444097745,
        "project": "debian",
        "size": 52,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int rtp_packetize_xiph_config ( sout_stream_id_sys_t * id , const char * fmtp , int64_t i_pts ) {\n"
                ],
                [
                    2,
                    " if ( fmtp == NULL ) return VLC_EGENERIC ;\n"
                ],
                [
                    9,
                    " size_t len = end - start ;\n"
                ],
                [
                    10,
                    " char b64 [ len + 1 ] ;\n"
                ],
                [
                    11,
                    " memcpy ( b64 , start , len ) ;\n"
                ],
                [
                    16,
                    " i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ;\n"
                ],
                [
                    21,
                    " p_data = p_orig + 9 ;\n"
                ],
                [
                    25,
                    " i < i_count ;\n"
                ],
                [
                    41,
                    " rtp_packetize_common ( id , out , 0 , i_pts ) ;\n"
                ],
                [
                    42,
                    " SetDWBE ( out -> p_buffer + 12 , header ) ;\n"
                ],
                [
                    43,
                    " SetWBE ( out -> p_buffer + 16 , i_payload ) ;\n"
                ],
                [
                    44,
                    " memcpy ( & out -> p_buffer [ 18 ] , p_data , i_payload ) ;\n"
                ],
                [
                    46,
                    " rtp_packetize_send ( id , out ) ;\n"
                ],
                [
                    47,
                    " p_data += i_payload ;\n"
                ],
                [
                    48,
                    " i_data -= i_payload ;\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "int rtp_packetize_xiph_config ( sout_stream_id_sys_t * id , const char * fmtp , int64_t i_pts ) {\n"
                ],
                [
                    2,
                    " if ( fmtp == NULL ) return VLC_EGENERIC ;\n"
                ],
                [
                    3,
                    " char * start = strstr ( fmtp , \"configuration=\" ) ;\n"
                ],
                [
                    4,
                    " assert ( start != NULL ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "int rtp_packetize_xiph_config ( sout_stream_id_sys_t * id , const char * fmtp , int64_t i_pts ) {\n"
                ],
                [
                    16,
                    " i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ;\n"
                ],
                [
                    17,
                    " if ( i_data <= 9 ) {\n"
                ],
                [
                    18,
                    " free ( p_orig ) ;\n"
                ],
                [
                    50,
                    " free ( p_orig ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int rtp_packetize_xiph_config ( sout_stream_id_sys_t * id , const char * fmtp , int64_t i_pts ) {\n"
                ],
                [
                    2,
                    " if ( fmtp == NULL ) return VLC_EGENERIC ;\n"
                ],
                [
                    3,
                    " char * start = strstr ( fmtp , \"configuration=\" ) ;\n"
                ],
                [
                    4,
                    " assert ( start != NULL ) ;\n"
                ],
                [
                    9,
                    " size_t len = end - start ;\n"
                ],
                [
                    10,
                    " char b64 [ len + 1 ] ;\n"
                ],
                [
                    11,
                    " memcpy ( b64 , start , len ) ;\n"
                ],
                [
                    16,
                    " i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ;\n"
                ],
                [
                    17,
                    " if ( i_data <= 9 ) {\n"
                ],
                [
                    18,
                    " free ( p_orig ) ;\n"
                ],
                [
                    21,
                    " p_data = p_orig + 9 ;\n"
                ],
                [
                    25,
                    " i < i_count ;\n"
                ],
                [
                    41,
                    " rtp_packetize_common ( id , out , 0 , i_pts ) ;\n"
                ],
                [
                    42,
                    " SetDWBE ( out -> p_buffer + 12 , header ) ;\n"
                ],
                [
                    43,
                    " SetWBE ( out -> p_buffer + 16 , i_payload ) ;\n"
                ],
                [
                    44,
                    " memcpy ( & out -> p_buffer [ 18 ] , p_data , i_payload ) ;\n"
                ],
                [
                    46,
                    " rtp_packetize_send ( id , out ) ;\n"
                ],
                [
                    47,
                    " p_data += i_payload ;\n"
                ],
                [
                    48,
                    " i_data -= i_payload ;\n"
                ],
                [
                    50,
                    " free ( p_orig ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name ) {\n reg2 uint key ;\n reg1 MI_KEYDEF * keyinfo ;\n File new_file ;\n my_off_t index_pos [ HA_MAX_POSSIBLE_KEY ] ;\n uint r_locks , w_locks ;\n int old_lock ;\n MYISAM_SHARE * share = info -> s ;\n MI_STATE_INFO old_state ;\n DBUG_ENTER ( \"mi_sort_index\" ) ;\n for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ;\n key < share -> base . keys ;\n key ++ , keyinfo ++ ) if ( keyinfo -> key_alg == HA_KEY_ALG_RTREE ) DBUG_RETURN ( 0 ) ;\n if ( ! ( param -> testflag & T_SILENT ) ) printf ( \"- Sorting index for MyISAM-table '%s'\\n\" , name ) ;\n fn_format ( param -> temp_filename , name , \"\" , MI_NAME_IEXT , 2 + 4 + 32 ) ;\n if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , \"\" , INDEX_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) {\n mi_check_print_error ( param , \"Can't create new tempfile: '%s'\" , param -> temp_filename ) ;\n DBUG_RETURN ( - 1 ) ;\n }\n if ( filecopy ( param , new_file , share -> kfile , 0L , ( ulong ) share -> base . keystart , \"headerblock\" ) ) goto err ;\n param -> new_file_pos = share -> base . keystart ;\n for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ;\n key < share -> base . keys ;\n key ++ , keyinfo ++ ) {\n if ( ! mi_is_key_active ( info -> s -> state . key_map , key ) ) continue ;\n if ( share -> state . key_root [ key ] != HA_OFFSET_ERROR ) {\n index_pos [ key ] = param -> new_file_pos ;\n if ( sort_one_index ( param , info , keyinfo , share -> state . key_root [ key ] , new_file ) ) goto err ;\n }\n else index_pos [ key ] = HA_OFFSET_ERROR ;\n }\n flush_key_blocks ( share -> key_cache , share -> kfile , FLUSH_IGNORE_CHANGED ) ;\n share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;\n old_state = share -> state ;\n r_locks = share -> r_locks ;\n w_locks = share -> w_locks ;\n old_lock = info -> lock_type ;\n share -> r_locks = share -> w_locks = share -> tot_locks = 0 ;\n ( void ) _mi_writeinfo ( info , WRITEINFO_UPDATE_KEYFILE ) ;\n ( void ) mysql_file_close ( share -> kfile , MYF ( MY_WME ) ) ;\n share -> kfile = - 1 ;\n ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ;\n if ( change_to_newfile ( share -> index_file_name , MI_NAME_IEXT , INDEX_TMP_EXT , MYF ( 0 ) ) || mi_open_keyfile ( share ) ) goto err2 ;\n info -> lock_type = F_UNLCK ;\n _mi_readinfo ( info , F_WRLCK , 0 ) ;\n info -> lock_type = old_lock ;\n share -> r_locks = r_locks ;\n share -> w_locks = w_locks ;\n share -> tot_locks = r_locks + w_locks ;\n share -> state = old_state ;\n info -> state -> key_file_length = param -> new_file_pos ;\n info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n for ( key = 0 ;\n key < info -> s -> base . keys ;\n key ++ ) info -> s -> state . key_root [ key ] = index_pos [ key ] ;\n for ( key = 0 ;\n key < info -> s -> state . header . max_block_size_index ;\n key ++ ) info -> s -> state . key_del [ key ] = HA_OFFSET_ERROR ;\n info -> s -> state . changed &= ~ STATE_NOT_SORTED_PAGES ;\n DBUG_RETURN ( 0 ) ;\n err : ( void ) mysql_file_close ( new_file , MYF ( MY_WME ) ) ;\n err2 : ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ;\n DBUG_RETURN ( - 1 ) ;\n }",
        "hash": -4885528830177756816,
        "project": "debian",
        "size": 64,
        "slice": {
            "printf": [
                [
                    1,
                    "int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name ) {\n"
                ],
                [
                    14,
                    " if ( ! ( param -> testflag & T_SILENT ) ) printf ( \"- Sorting index for MyISAM-table '%s'\\n\" , name ) ;\n"
                ],
                [
                    15,
                    " fn_format ( param -> temp_filename , name , \"\" , MI_NAME_IEXT , 2 + 4 + 32 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name ) {\n"
                ],
                [
                    14,
                    " if ( ! ( param -> testflag & T_SILENT ) ) printf ( \"- Sorting index for MyISAM-table '%s'\\n\" , name ) ;\n"
                ],
                [
                    15,
                    " fn_format ( param -> temp_filename , name , \"\" , MI_NAME_IEXT , 2 + 4 + 32 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick ) {\n int error , got_error ;\n ha_rows start_records , new_header_length ;\n my_off_t del ;\n File new_file ;\n MYISAM_SHARE * share = info -> s ;\n char llbuff [ 22 ] , llbuff2 [ 22 ] ;\n SORT_INFO sort_info ;\n MI_SORT_PARAM sort_param ;\n DBUG_ENTER ( \"mi_repair\" ) ;\n bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ;\n bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ;\n start_records = info -> state -> records ;\n new_header_length = ( param -> testflag & T_UNPACK ) ? 0L : share -> pack . header_length ;\n got_error = 1 ;\n new_file = - 1 ;\n sort_param . sort_info = & sort_info ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n printf ( \"- recovering (with keycache) MyISAM-table '%s'\\n\" , name ) ;\n printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n }\n param -> testflag |= T_REP ;\n if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ;\n DBUG_ASSERT ( param -> use_buffers < SIZE_T_MAX ) ;\n if ( ! param -> using_global_keycache ) ( void ) init_key_cache ( dflt_key_cache , param -> key_cache_block_size , param -> use_buffers , 0 , 0 ) ;\n if ( init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) ) {\n bzero ( & info -> rec_cache , sizeof ( info -> rec_cache ) ) ;\n goto err ;\n }\n if ( ! rep_quick ) if ( init_io_cache ( & info -> rec_cache , - 1 , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) ) ) goto err ;\n info -> opt_flag |= WRITE_CACHE_USED ;\n if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) {\n mi_check_print_error ( param , \"Not enough memory for extra record\" ) ;\n goto err ;\n }\n if ( ! rep_quick ) {\n if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , \"\" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {\n mi_check_print_error ( param , \"Can't create new tempfile: '%s'\" , param -> temp_filename ) ;\n goto err ;\n }\n if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , \"datafile-header\" ) ) goto err ;\n info -> s -> state . dellink = HA_OFFSET_ERROR ;\n info -> rec_cache . file = new_file ;\n if ( param -> testflag & T_UNPACK ) {\n share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;\n mi_int2store ( share -> state . header . options , share -> options ) ;\n }\n }\n sort_info . info = info ;\n sort_info . param = param ;\n sort_param . read_cache = param -> read_cache ;\n sort_param . pos = sort_param . max_pos = share -> pack . header_length ;\n sort_param . filepos = new_header_length ;\n param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( info -> dfile , 0L , MY_SEEK_END , MYF ( 0 ) ) ;\n sort_info . dupp = 0 ;\n sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ;\n sort_param . master = 1 ;\n sort_info . max_records = ~ ( ha_rows ) 0 ;\n set_data_file_type ( & sort_info , share ) ;\n del = info -> state -> del ;\n info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n info -> state -> empty = 0 ;\n param -> glob_crc = 0 ;\n if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ;\n info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n if ( param -> testflag & T_CREATE_MISSING_KEYS ) mi_set_all_keys_active ( share -> state . key_map , share -> base . keys ) ;\n mi_drop_all_indexes ( param , info , TRUE ) ;\n lock_memory ( param ) ;\n while ( ! ( error = sort_get_next_record ( & sort_param ) ) ) {\n if ( writekeys ( & sort_param ) ) {\n if ( my_errno != HA_ERR_FOUND_DUPP_KEY ) goto err ;\n DBUG_DUMP ( \"record\" , ( uchar * ) sort_param . record , share -> base . pack_reclength ) ;\n mi_check_print_info ( param , \"Duplicate key %2d for record at %10s against new record at %10s\" , info -> errkey + 1 , llstr ( sort_param . start_recpos , llbuff ) , llstr ( info -> dupp_key_pos , llbuff2 ) ) ;\n if ( param -> testflag & T_VERBOSE ) {\n ( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ;\n _mi_print_key ( stdout , share -> keyinfo [ info -> errkey ] . seg , info -> lastkey , USE_WHOLE_KEY ) ;\n }\n sort_info . dupp ++ ;\n if ( ( param -> testflag & ( T_FORCE_UNIQUENESS | T_QUICK ) ) == T_QUICK ) {\n param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n param -> error_printed = 1 ;\n goto err ;\n }\n continue ;\n }\n if ( sort_write_record ( & sort_param ) ) goto err ;\n }\n if ( error > 0 || write_data_suffix ( & sort_info , ( my_bool ) ! rep_quick ) || flush_io_cache ( & info -> rec_cache ) || param -> read_cache . error < 0 ) goto err ;\n if ( param -> testflag & T_WRITE_LOOP ) {\n ( void ) fputs ( \" \\r\" , stdout ) ;\n ( void ) fflush ( stdout ) ;\n }\n if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) {\n mi_check_print_warning ( param , \"Can't change size of indexfile, error: %d\" , my_errno ) ;\n goto err ;\n }\n if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n mi_check_print_error ( param , \"Couldn't fix table with quick recovery: Found wrong number of deleted records\" ) ;\n mi_check_print_error ( param , \"Run recovery again without -q\" ) ;\n got_error = 1 ;\n param -> retry_repair = 1 ;\n param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n goto err ;\n }\n if ( param -> testflag & T_SAFE_REPAIR ) {\n if ( info -> state -> records + 1 < start_records ) {\n info -> state -> records = start_records ;\n got_error = 1 ;\n goto err ;\n }\n }\n if ( ! rep_quick ) {\n mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;\n info -> dfile = new_file ;\n info -> state -> data_file_length = sort_param . filepos ;\n share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;\n }\n else {\n info -> state -> data_file_length = sort_param . max_pos ;\n }\n if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n if ( sort_info . dupp ) mi_check_print_warning ( param , \"%s records have been removed\" , llstr ( sort_info . dupp , llbuff ) ) ;\n }\n got_error = 0 ;\n if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n err : if ( ! got_error ) {\n if ( new_file >= 0 ) {\n mysql_file_close ( new_file , MYF ( 0 ) ) ;\n info -> dfile = new_file = - 1 ;\n if ( info -> s -> file_map ) {\n ( void ) my_munmap ( ( char * ) info -> s -> file_map , ( size_t ) info -> s -> mmaped_length ) ;\n info -> s -> file_map = NULL ;\n }\n if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n param -> retry_repair = 0 ;\n }\n }\n if ( got_error ) {\n if ( ! param -> error_printed ) mi_check_print_error ( param , \"%d for record at pos %s\" , my_errno , llstr ( sort_param . start_recpos , llbuff ) ) ;\n if ( new_file >= 0 ) {\n ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ;\n ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ;\n info -> rec_cache . file = - 1 ;\n }\n mi_mark_crashed_on_repair ( info ) ;\n }\n my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n my_free ( sort_info . buff ) ;\n ( void ) end_io_cache ( & param -> read_cache ) ;\n info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ;\n ( void ) end_io_cache ( & info -> rec_cache ) ;\n got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;\n if ( ! got_error && param -> testflag & T_UNPACK ) {\n share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ;\n share -> pack . header_length = 0 ;\n share -> data_file_type = sort_info . new_data_file_type ;\n }\n share -> state . changed |= ( STATE_NOT_OPTIMIZED_KEYS | STATE_NOT_SORTED_PAGES | STATE_NOT_ANALYZED ) ;\n DBUG_RETURN ( got_error ) ;\n }",
        "hash": -4885528830177756816,
        "project": "debian",
        "size": 163,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick ) {\n"
                ],
                [
                    61,
                    " info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n"
                ],
                [
                    62,
                    " info -> state -> empty = 0 ;\n"
                ],
                [
                    67,
                    " mi_drop_all_indexes ( param , info , TRUE ) ;\n"
                ],
                [
                    75,
                    " ( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ;\n"
                ],
                [
                    93,
                    " if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) {\n"
                ],
                [
                    97,
                    " if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n"
                ],
                [
                    115,
                    " info -> state -> data_file_length = sort_param . filepos ;\n"
                ],
                [
                    119,
                    " info -> state -> data_file_length = sort_param . max_pos ;\n"
                ],
                [
                    121,
                    " if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n"
                ],
                [
                    123,
                    " if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n"
                ],
                [
                    127,
                    " if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n"
                ],
                [
                    136,
                    " if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n"
                ],
                [
                    147,
                    " mi_mark_crashed_on_repair ( info ) ;\n"
                ],
                [
                    149,
                    " my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n"
                ],
                [
                    150,
                    " my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick ) {\n"
                ],
                [
                    18,
                    " if ( ! ( param -> testflag & T_SILENT ) ) {\n"
                ],
                [
                    19,
                    " printf ( \"- recovering (with keycache) MyISAM-table '%s'\\n\" , name ) ;\n"
                ],
                [
                    20,
                    " printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n"
                ],
                [
                    123,
                    " if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n"
                ],
                [
                    136,
                    " if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick ) {\n"
                ],
                [
                    18,
                    " if ( ! ( param -> testflag & T_SILENT ) ) {\n"
                ],
                [
                    19,
                    " printf ( \"- recovering (with keycache) MyISAM-table '%s'\\n\" , name ) ;\n"
                ],
                [
                    20,
                    " printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n"
                ],
                [
                    61,
                    " info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n"
                ],
                [
                    62,
                    " info -> state -> empty = 0 ;\n"
                ],
                [
                    67,
                    " mi_drop_all_indexes ( param , info , TRUE ) ;\n"
                ],
                [
                    75,
                    " ( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ;\n"
                ],
                [
                    93,
                    " if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) {\n"
                ],
                [
                    97,
                    " if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n"
                ],
                [
                    115,
                    " info -> state -> data_file_length = sort_param . filepos ;\n"
                ],
                [
                    119,
                    " info -> state -> data_file_length = sort_param . max_pos ;\n"
                ],
                [
                    121,
                    " if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n"
                ],
                [
                    123,
                    " if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n"
                ],
                [
                    127,
                    " if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n"
                ],
                [
                    136,
                    " if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n"
                ],
                [
                    147,
                    " mi_mark_crashed_on_repair ( info ) ;\n"
                ],
                [
                    149,
                    " my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n"
                ],
                [
                    150,
                    " my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n int got_error ;\n uint i , key , total_key_length , istep ;\n ulong rec_length ;\n ha_rows start_records ;\n my_off_t new_header_length , del ;\n File new_file ;\n MI_SORT_PARAM * sort_param = 0 ;\n MYISAM_SHARE * share = info -> s ;\n ulong * rec_per_key_part ;\n HA_KEYSEG * keyseg ;\n char llbuff [ 22 ] ;\n IO_CACHE new_data_cache ;\n IO_CACHE_SHARE io_share ;\n SORT_INFO sort_info ;\n ulonglong UNINIT_VAR ( key_map ) ;\n pthread_attr_t thr_attr ;\n ulong max_pack_reclength ;\n int error ;\n DBUG_ENTER ( \"mi_repair_parallel\" ) ;\n start_records = info -> state -> records ;\n got_error = 1 ;\n new_file = - 1 ;\n new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n printf ( \"- parallel recovering (with sort) MyISAM-table '%s'\\n\" , name ) ;\n printf ( \"Data records: %s\\n\" , llstr ( start_records , llbuff ) ) ;\n }\n param -> testflag |= T_REP ;\n if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ;\n DBUG_PRINT ( \"info\" , ( \"is quick repair: %d\" , rep_quick ) ) ;\n bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ;\n mysql_mutex_init ( mi_key_mutex_MI_SORT_INFO_mutex , & sort_info . mutex , MY_MUTEX_INIT_FAST ) ;\n mysql_cond_init ( mi_key_cond_MI_SORT_INFO_cond , & sort_info . cond , 0 ) ;\n mysql_mutex_init ( mi_key_mutex_MI_CHECK_print_msg , & param -> print_msg_mutex , MY_MUTEX_INIT_FAST ) ;\n param -> need_print_msg_lock = 1 ;\n if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && ( init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) || init_io_cache ( & new_data_cache , - 1 , ( uint ) param -> write_buffer_length , READ_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_DONT_CHECK_FILESIZE ) ) ) ) ) goto err ;\n sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ;\n info -> opt_flag |= WRITE_CACHE_USED ;\n info -> rec_cache . file = info -> dfile ;\n if ( ! rep_quick ) {\n if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , \"\" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {\n mi_check_print_error ( param , \"Can't create new tempfile: '%s'\" , param -> temp_filename ) ;\n goto err ;\n }\n if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , \"datafile-header\" ) ) goto err ;\n if ( param -> testflag & T_UNPACK ) {\n share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;\n mi_int2store ( share -> state . header . options , share -> options ) ;\n }\n share -> state . dellink = HA_OFFSET_ERROR ;\n info -> rec_cache . file = new_file ;\n }\n info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n mi_drop_all_indexes ( param , info , FALSE ) ;\n key_map = share -> state . key_map ;\n if ( param -> testflag & T_CREATE_MISSING_KEYS ) {\n key_map = ~ key_map ;\n }\n sort_info . info = info ;\n sort_info . param = param ;\n set_data_file_type ( & sort_info , share ) ;\n sort_info . dupp = 0 ;\n sort_info . buff = 0 ;\n param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ;\n if ( share -> data_file_type == DYNAMIC_RECORD ) rec_length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ;\n else if ( share -> data_file_type == COMPRESSED_RECORD ) rec_length = share -> base . min_block_length ;\n else rec_length = share -> base . pack_reclength ;\n sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records + 1 : ( ha_rows ) ( sort_info . filelength / rec_length + 1 ) ) ;\n del = info -> state -> del ;\n param -> glob_crc = 0 ;\n max_pack_reclength = share -> base . pack_reclength ;\n if ( share -> options & HA_OPTION_COMPRESS_RECORD ) set_if_bigger ( max_pack_reclength , share -> max_pack_length ) ;\n if ( ! ( sort_param = ( MI_SORT_PARAM * ) my_malloc ( ( uint ) share -> base . keys * ( sizeof ( MI_SORT_PARAM ) + max_pack_reclength ) , MYF ( MY_ZEROFILL ) ) ) ) {\n mi_check_print_error ( param , \"Not enough memory for key!\" ) ;\n goto err ;\n }\n total_key_length = 0 ;\n rec_per_key_part = param -> rec_per_key_part ;\n info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n info -> state -> empty = 0 ;\n for ( i = key = 0 , istep = 1 ;\n key < share -> base . keys ;\n rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) {\n sort_param [ i ] . key = key ;\n sort_param [ i ] . keyinfo = share -> keyinfo + key ;\n sort_param [ i ] . seg = sort_param [ i ] . keyinfo -> seg ;\n if ( ! mi_is_key_active ( key_map , key ) ) {\n memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n istep = 0 ;\n continue ;\n }\n istep = 1 ;\n if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( \"- Fixing index %d\\n\" , key + 1 ) ;\n if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) {\n sort_param [ i ] . key_read = sort_ft_key_read ;\n sort_param [ i ] . key_write = sort_ft_key_write ;\n }\n else {\n sort_param [ i ] . key_read = sort_key_read ;\n sort_param [ i ] . key_write = sort_key_write ;\n }\n sort_param [ i ] . key_cmp = sort_key_cmp ;\n sort_param [ i ] . lock_in_memory = lock_memory ;\n sort_param [ i ] . tmpdir = param -> tmpdir ;\n sort_param [ i ] . sort_info = & sort_info ;\n sort_param [ i ] . master = 0 ;\n sort_param [ i ] . fix_datafile = 0 ;\n sort_param [ i ] . calc_checksum = 0 ;\n sort_param [ i ] . filepos = new_header_length ;\n sort_param [ i ] . max_pos = sort_param [ i ] . pos = share -> pack . header_length ;\n sort_param [ i ] . record = ( ( ( uchar * ) ( sort_param + share -> base . keys ) ) + ( max_pack_reclength * i ) ) ;\n if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param [ i ] . rec_buff ) ) {\n mi_check_print_error ( param , \"Not enough memory!\" ) ;\n goto err ;\n }\n sort_param [ i ] . key_length = share -> rec_reflength ;\n for ( keyseg = sort_param [ i ] . seg ;\n keyseg -> type != HA_KEYTYPE_END ;\n keyseg ++ ) {\n sort_param [ i ] . key_length += keyseg -> length ;\n if ( keyseg -> flag & HA_SPACE_PACK ) sort_param [ i ] . key_length += get_pack_length ( keyseg -> length ) ;\n if ( keyseg -> flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param [ i ] . key_length += 2 + test ( keyseg -> length >= 127 ) ;\n if ( keyseg -> flag & HA_NULL_PART ) sort_param [ i ] . key_length ++ ;\n }\n total_key_length += sort_param [ i ] . key_length ;\n if ( sort_param [ i ] . keyinfo -> flag & HA_FULLTEXT ) {\n uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param [ i ] . keyinfo -> seg -> charset -> mbmaxlen ;\n sort_param [ i ] . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ;\n init_alloc_root ( & sort_param [ i ] . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ;\n }\n }\n sort_info . total_keys = i ;\n sort_param [ 0 ] . master = 1 ;\n sort_param [ 0 ] . fix_datafile = ( my_bool ) ( ! rep_quick ) ;\n sort_param [ 0 ] . calc_checksum = test ( param -> testflag & T_CALC_CHECKSUM ) ;\n if ( ! ftparser_alloc_param ( info ) ) goto err ;\n sort_info . got_error = 0 ;\n mysql_mutex_lock ( & sort_info . mutex ) ;\n if ( i > 1 ) {\n if ( rep_quick ) init_io_cache_share ( & param -> read_cache , & io_share , NULL , i ) ;\n else init_io_cache_share ( & new_data_cache , & io_share , & info -> rec_cache , i ) ;\n }\n else io_share . total_threads = 0 ;\n ( void ) pthread_attr_init ( & thr_attr ) ;\n ( void ) pthread_attr_setdetachstate ( & thr_attr , PTHREAD_CREATE_DETACHED ) ;\n for ( i = 0 ;\n i < sort_info . total_keys ;\n i ++ ) {\n sort_param [ i ] . read_cache = ( ( rep_quick || ! i ) ? param -> read_cache : new_data_cache ) ;\n DBUG_PRINT ( \"io_cache_share\" , ( \"thread: %u read_cache: 0x%lx\" , i , ( long ) & sort_param [ i ] . read_cache ) ) ;\n sort_param [ i ] . sortbuff_size = # ifndef USING_SECOND_APPROACH param -> sort_buffer_length / sort_info . total_keys ;\n # else param -> sort_buffer_length * sort_param [ i ] . key_length / total_key_length ;\n # endif if ( ( error = mysql_thread_create ( mi_key_thread_find_all_keys , & sort_param [ i ] . thr , & thr_attr , thr_find_all_keys , ( void * ) ( sort_param + i ) ) ) ) {\n mi_check_print_error ( param , \"Cannot start a repair thread (errno= %d)\" , error ) ;\n if ( io_share . total_threads ) remove_io_thread ( & sort_param [ i ] . read_cache ) ;\n DBUG_PRINT ( \"error\" , ( \"Cannot start a repair thread\" ) ) ;\n sort_info . got_error = 1 ;\n }\n else sort_info . threads_running ++ ;\n }\n ( void ) pthread_attr_destroy ( & thr_attr ) ;\n while ( sort_info . threads_running ) mysql_cond_wait ( & sort_info . cond , & sort_info . mutex ) ;\n mysql_mutex_unlock ( & sort_info . mutex ) ;\n if ( ( got_error = thr_write_keys ( sort_param ) ) ) {\n param -> retry_repair = 1 ;\n goto err ;\n }\n got_error = 1 ;\n if ( sort_param [ 0 ] . fix_datafile ) {\n if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ;\n if ( param -> testflag & T_SAFE_REPAIR ) {\n if ( info -> state -> records + 1 < start_records ) {\n info -> state -> records = start_records ;\n goto err ;\n }\n }\n share -> state . state . data_file_length = info -> state -> data_file_length = sort_param -> filepos ;\n share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;\n mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;\n info -> dfile = new_file ;\n share -> data_file_type = sort_info . new_data_file_type ;\n share -> pack . header_length = ( ulong ) new_header_length ;\n }\n else info -> state -> data_file_length = sort_param -> max_pos ;\n if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n mi_check_print_error ( param , \"Couldn't fix table with quick recovery: Found wrong number of deleted records\" ) ;\n mi_check_print_error ( param , \"Run recovery again without -q\" ) ;\n param -> retry_repair = 1 ;\n param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n goto err ;\n }\n if ( rep_quick & T_FORCE_UNIQUENESS ) {\n my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ;\n # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ;\n # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , \"Can't change size of datafile, error: %d\" , my_errno ) ;\n }\n if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , \"Can't change size of indexfile, error: %d\" , my_errno ) ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n if ( sort_info . dupp ) mi_check_print_warning ( param , \"%s records have been removed\" , llstr ( sort_info . dupp , llbuff ) ) ;\n }\n got_error = 0 ;\n if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;\n ( void ) end_io_cache ( & info -> rec_cache ) ;\n if ( ! rep_quick ) ( void ) end_io_cache ( & new_data_cache ) ;\n if ( ! got_error ) {\n if ( new_file >= 0 ) {\n mysql_file_close ( new_file , MYF ( 0 ) ) ;\n info -> dfile = new_file = - 1 ;\n if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n }\n }\n if ( got_error ) {\n if ( ! param -> error_printed ) mi_check_print_error ( param , \"%d when fixing table\" , my_errno ) ;\n if ( new_file >= 0 ) {\n ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ;\n ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ;\n if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ;\n }\n mi_mark_crashed_on_repair ( info ) ;\n }\n else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ;\n share -> state . changed |= STATE_NOT_SORTED_PAGES ;\n mysql_cond_destroy ( & sort_info . cond ) ;\n mysql_mutex_destroy ( & sort_info . mutex ) ;\n mysql_mutex_destroy ( & param -> print_msg_mutex ) ;\n param -> need_print_msg_lock = 0 ;\n my_free ( sort_info . ft_buf ) ;\n my_free ( sort_info . key_block ) ;\n my_free ( sort_param ) ;\n my_free ( sort_info . buff ) ;\n ( void ) end_io_cache ( & param -> read_cache ) ;\n info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ;\n if ( ! got_error && ( param -> testflag & T_UNPACK ) ) {\n share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ;\n share -> pack . header_length = 0 ;\n }\n DBUG_RETURN ( got_error ) ;\n }",
        "hash": -4885528830177756816,
        "project": "debian",
        "size": 242,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n"
                ],
                [
                    79,
                    " rec_per_key_part = param -> rec_per_key_part ;\n"
                ],
                [
                    84,
                    " rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) {\n"
                ],
                [
                    88,
                    " if ( ! mi_is_key_active ( key_map , key ) ) {\n"
                ],
                [
                    89,
                    " memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n"
                ],
                [
                    25,
                    " if ( ! ( param -> testflag & T_SILENT ) ) {\n"
                ],
                [
                    26,
                    " printf ( \"- parallel recovering (with sort) MyISAM-table '%s'\\n\" , name ) ;\n"
                ],
                [
                    27,
                    " printf ( \"Data records: %s\\n\" , llstr ( start_records , llbuff ) ) ;\n"
                ],
                [
                    88,
                    " if ( ! mi_is_key_active ( key_map , key ) ) {\n"
                ],
                [
                    94,
                    " if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( \"- Fixing index %d\\n\" , key + 1 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n"
                ],
                [
                    25,
                    " if ( ! ( param -> testflag & T_SILENT ) ) {\n"
                ],
                [
                    26,
                    " printf ( \"- parallel recovering (with sort) MyISAM-table '%s'\\n\" , name ) ;\n"
                ],
                [
                    27,
                    " printf ( \"Data records: %s\\n\" , llstr ( start_records , llbuff ) ) ;\n"
                ],
                [
                    79,
                    " rec_per_key_part = param -> rec_per_key_part ;\n"
                ],
                [
                    84,
                    " rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) {\n"
                ],
                [
                    88,
                    " if ( ! mi_is_key_active ( key_map , key ) ) {\n"
                ],
                [
                    89,
                    " memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n"
                ],
                [
                    94,
                    " if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( \"- Fixing index %d\\n\" , key + 1 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n int got_error ;\n uint i ;\n ulong length ;\n ha_rows start_records ;\n my_off_t new_header_length , del ;\n File new_file ;\n MI_SORT_PARAM sort_param ;\n MYISAM_SHARE * share = info -> s ;\n HA_KEYSEG * keyseg ;\n ulong * rec_per_key_part ;\n char llbuff [ 22 ] ;\n SORT_INFO sort_info ;\n ulonglong UNINIT_VAR ( key_map ) ;\n DBUG_ENTER ( \"mi_repair_by_sort\" ) ;\n start_records = info -> state -> records ;\n got_error = 1 ;\n new_file = - 1 ;\n new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n printf ( \"- recovering (with sort) MyISAM-table '%s'\\n\" , name ) ;\n printf ( \"Data records: %s\\n\" , llstr ( start_records , llbuff ) ) ;\n }\n param -> testflag |= T_REP ;\n if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ;\n bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ;\n bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ;\n if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ;\n sort_info . key_block_end = sort_info . key_block + param -> sort_key_blocks ;\n info -> opt_flag |= WRITE_CACHE_USED ;\n info -> rec_cache . file = info -> dfile ;\n if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) {\n mi_check_print_error ( param , \"Not enough memory for extra record\" ) ;\n goto err ;\n }\n if ( ! rep_quick ) {\n if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , \"\" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {\n mi_check_print_error ( param , \"Can't create new tempfile: '%s'\" , param -> temp_filename ) ;\n goto err ;\n }\n if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , \"datafile-header\" ) ) goto err ;\n if ( param -> testflag & T_UNPACK ) {\n share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;\n mi_int2store ( share -> state . header . options , share -> options ) ;\n }\n share -> state . dellink = HA_OFFSET_ERROR ;\n info -> rec_cache . file = new_file ;\n }\n info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n mi_drop_all_indexes ( param , info , FALSE ) ;\n key_map = share -> state . key_map ;\n if ( param -> testflag & T_CREATE_MISSING_KEYS ) {\n key_map = ~ key_map ;\n }\n sort_info . info = info ;\n sort_info . param = param ;\n set_data_file_type ( & sort_info , share ) ;\n sort_param . filepos = new_header_length ;\n sort_info . dupp = 0 ;\n sort_info . buff = 0 ;\n param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( param -> read_cache . file , 0L , MY_SEEK_END , MYF ( 0 ) ) ;\n sort_param . wordlist = NULL ;\n init_alloc_root ( & sort_param . wordroot , FTPARSER_MEMROOT_ALLOC_SIZE , 0 ) ;\n if ( share -> data_file_type == DYNAMIC_RECORD ) length = max ( share -> base . min_pack_length + 1 , share -> base . min_block_length ) ;\n else if ( share -> data_file_type == COMPRESSED_RECORD ) length = share -> base . min_block_length ;\n else length = share -> base . pack_reclength ;\n sort_info . max_records = ( ( param -> testflag & T_CREATE_MISSING_KEYS ) ? info -> state -> records : ( ha_rows ) ( sort_info . filelength / length + 1 ) ) ;\n sort_param . key_cmp = sort_key_cmp ;\n sort_param . lock_in_memory = lock_memory ;\n sort_param . tmpdir = param -> tmpdir ;\n sort_param . sort_info = & sort_info ;\n sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ;\n sort_param . master = 1 ;\n del = info -> state -> del ;\n param -> glob_crc = 0 ;\n if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ;\n rec_per_key_part = param -> rec_per_key_part ;\n for ( sort_param . key = 0 ;\n sort_param . key < share -> base . keys ;\n rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) {\n sort_param . read_cache = param -> read_cache ;\n sort_param . keyinfo = share -> keyinfo + sort_param . key ;\n sort_param . seg = sort_param . keyinfo -> seg ;\n if ( ! mi_is_key_active ( key_map , sort_param . key ) ) {\n memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n DBUG_PRINT ( \"repair\" , ( \"skipping seemingly disabled index #: %u\" , sort_param . key ) ) ;\n continue ;\n }\n if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( \"- Fixing index %d\\n\" , sort_param . key + 1 ) ;\n sort_param . max_pos = sort_param . pos = share -> pack . header_length ;\n keyseg = sort_param . seg ;\n bzero ( ( char * ) sort_param . unique , sizeof ( sort_param . unique ) ) ;\n sort_param . key_length = share -> rec_reflength ;\n for ( i = 0 ;\n keyseg [ i ] . type != HA_KEYTYPE_END ;\n i ++ ) {\n sort_param . key_length += keyseg [ i ] . length ;\n if ( keyseg [ i ] . flag & HA_SPACE_PACK ) sort_param . key_length += get_pack_length ( keyseg [ i ] . length ) ;\n if ( keyseg [ i ] . flag & ( HA_BLOB_PART | HA_VAR_LENGTH_PART ) ) sort_param . key_length += 2 + test ( keyseg [ i ] . length >= 127 ) ;\n if ( keyseg [ i ] . flag & HA_NULL_PART ) sort_param . key_length ++ ;\n }\n info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n info -> state -> empty = 0 ;\n if ( sort_param . keyinfo -> flag & HA_FULLTEXT ) {\n uint ft_max_word_len_for_sort = FT_MAX_WORD_LEN_FOR_SORT * sort_param . keyinfo -> seg -> charset -> mbmaxlen ;\n sort_param . key_length += ft_max_word_len_for_sort - HA_FT_MAXBYTELEN ;\n if ( sort_param . keyinfo -> parser == & ft_default_parser ) {\n sort_info . max_records = ( ha_rows ) ( sort_info . filelength / ft_min_word_len + 1 ) ;\n }\n else {\n sort_info . max_records = 10 * max ( param -> sort_buffer_length , MIN_SORT_BUFFER ) / sort_param . key_length ;\n }\n sort_param . key_read = sort_ft_key_read ;\n sort_param . key_write = sort_ft_key_write ;\n }\n else {\n sort_param . key_read = sort_key_read ;\n sort_param . key_write = sort_key_write ;\n }\n if ( _create_index_by_sort ( & sort_param , ( my_bool ) ( ! ( param -> testflag & T_VERBOSE ) ) , param -> sort_buffer_length ) ) {\n param -> retry_repair = 1 ;\n goto err ;\n }\n sort_param . calc_checksum = 0 ;\n free_root ( & sort_param . wordroot , MYF ( 0 ) ) ;\n sort_info . max_records = ( ha_rows ) info -> state -> records ;\n if ( param -> testflag & T_STATISTICS ) update_key_parts ( sort_param . keyinfo , rec_per_key_part , sort_param . unique , param -> stats_method == MI_STATS_METHOD_IGNORE_NULLS ? sort_param . notnull : NULL , ( ulonglong ) info -> state -> records ) ;\n mi_set_key_active ( share -> state . key_map , sort_param . key ) ;\n DBUG_PRINT ( \"repair\" , ( \"set enabled index #: %u\" , sort_param . key ) ) ;\n if ( sort_param . fix_datafile ) {\n param -> read_cache . end_of_file = sort_param . filepos ;\n if ( write_data_suffix ( & sort_info , 1 ) || end_io_cache ( & info -> rec_cache ) ) goto err ;\n if ( param -> testflag & T_SAFE_REPAIR ) {\n if ( info -> state -> records + 1 < start_records ) {\n info -> state -> records = start_records ;\n goto err ;\n }\n }\n share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ;\n share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;\n mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;\n info -> dfile = new_file ;\n share -> data_file_type = sort_info . new_data_file_type ;\n share -> pack . header_length = ( ulong ) new_header_length ;\n sort_param . fix_datafile = 0 ;\n }\n else info -> state -> data_file_length = sort_param . max_pos ;\n param -> read_cache . file = info -> dfile ;\n reinit_io_cache ( & param -> read_cache , READ_CACHE , share -> pack . header_length , 1 , 1 ) ;\n }\n if ( param -> testflag & T_WRITE_LOOP ) {\n ( void ) fputs ( \" \\r\" , stdout ) ;\n ( void ) fflush ( stdout ) ;\n }\n if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n mi_check_print_error ( param , \"Couldn't fix table with quick recovery: Found wrong number of deleted records\" ) ;\n mi_check_print_error ( param , \"Run recovery again without -q\" ) ;\n got_error = 1 ;\n param -> retry_repair = 1 ;\n param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n goto err ;\n }\n if ( rep_quick & T_FORCE_UNIQUENESS ) {\n my_off_t skr = info -> state -> data_file_length + ( share -> options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0 ) ;\n # ifdef USE_RELOC if ( share -> data_file_type == STATIC_RECORD && skr < share -> base . reloc * share -> base . min_pack_length ) skr = share -> base . reloc * share -> base . min_pack_length ;\n # endif if ( skr != sort_info . filelength ) if ( mysql_file_chsize ( info -> dfile , skr , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , \"Can't change size of datafile, error: %d\" , my_errno ) ;\n }\n if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , \"Can't change size of indexfile, error: %d\" , my_errno ) ;\n if ( ! ( param -> testflag & T_SILENT ) ) {\n if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n if ( sort_info . dupp ) mi_check_print_warning ( param , \"%s records have been removed\" , llstr ( sort_info . dupp , llbuff ) ) ;\n }\n got_error = 0 ;\n if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n err : got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;\n ( void ) end_io_cache ( & info -> rec_cache ) ;\n if ( ! got_error ) {\n if ( new_file >= 0 ) {\n mysql_file_close ( new_file , MYF ( 0 ) ) ;\n info -> dfile = new_file = - 1 ;\n if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n }\n }\n if ( got_error ) {\n if ( ! param -> error_printed ) mi_check_print_error ( param , \"%d when fixing table\" , my_errno ) ;\n if ( new_file >= 0 ) {\n ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ;\n ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ;\n if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ;\n }\n mi_mark_crashed_on_repair ( info ) ;\n }\n else if ( key_map == share -> state . key_map ) share -> state . changed &= ~ STATE_NOT_OPTIMIZED_KEYS ;\n share -> state . changed |= STATE_NOT_SORTED_PAGES ;\n my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n my_free ( sort_info . key_block ) ;\n my_free ( sort_info . ft_buf ) ;\n my_free ( sort_info . buff ) ;\n ( void ) end_io_cache ( & param -> read_cache ) ;\n info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ;\n if ( ! got_error && ( param -> testflag & T_UNPACK ) ) {\n share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ;\n share -> pack . header_length = 0 ;\n }\n DBUG_RETURN ( got_error ) ;\n }",
        "hash": -4885528830177756816,
        "project": "debian",
        "size": 208,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n"
                ],
                [
                    28,
                    " if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ;\n"
                ],
                [
                    30,
                    " info -> opt_flag |= WRITE_CACHE_USED ;\n"
                ],
                [
                    41,
                    " if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , \"datafile-header\" ) ) goto err ;\n"
                ],
                [
                    49,
                    " info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n"
                ],
                [
                    50,
                    " mi_drop_all_indexes ( param , info , FALSE ) ;\n"
                ],
                [
                    77,
                    " rec_per_key_part = param -> rec_per_key_part ;\n"
                ],
                [
                    80,
                    " rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) {\n"
                ],
                [
                    84,
                    " if ( ! mi_is_key_active ( key_map , sort_param . key ) ) {\n"
                ],
                [
                    85,
                    " memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n"
                ],
                [
                    102,
                    " info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n"
                ],
                [
                    103,
                    " info -> state -> empty = 0 ;\n"
                ],
                [
                    139,
                    " share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ;\n"
                ],
                [
                    147,
                    " else info -> state -> data_file_length = sort_param . max_pos ;\n"
                ],
                [
                    155,
                    " if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n"
                ],
                [
                    168,
                    " if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n"
                ],
                [
                    169,
                    " if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , \"Can't change size of indexfile, error: %d\" , my_errno ) ;\n"
                ],
                [
                    171,
                    " if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n"
                ],
                [
                    175,
                    " if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n"
                ],
                [
                    182,
                    " if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n"
                ],
                [
                    190,
                    " if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ;\n"
                ],
                [
                    192,
                    " mi_mark_crashed_on_repair ( info ) ;\n"
                ],
                [
                    196,
                    " my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n"
                ],
                [
                    197,
                    " my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n"
                ],
                [
                    20,
                    " if ( ! ( param -> testflag & T_SILENT ) ) {\n"
                ],
                [
                    21,
                    " printf ( \"- recovering (with sort) MyISAM-table '%s'\\n\" , name ) ;\n"
                ],
                [
                    22,
                    " printf ( \"Data records: %s\\n\" , llstr ( start_records , llbuff ) ) ;\n"
                ],
                [
                    84,
                    " if ( ! mi_is_key_active ( key_map , sort_param . key ) ) {\n"
                ],
                [
                    89,
                    " if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( \"- Fixing index %d\\n\" , sort_param . key + 1 ) ;\n"
                ],
                [
                    171,
                    " if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n"
                ],
                [
                    182,
                    " if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n"
                ],
                [
                    190,
                    " if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n"
                ],
                [
                    20,
                    " if ( ! ( param -> testflag & T_SILENT ) ) {\n"
                ],
                [
                    21,
                    " printf ( \"- recovering (with sort) MyISAM-table '%s'\\n\" , name ) ;\n"
                ],
                [
                    22,
                    " printf ( \"Data records: %s\\n\" , llstr ( start_records , llbuff ) ) ;\n"
                ],
                [
                    28,
                    " if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ;\n"
                ],
                [
                    30,
                    " info -> opt_flag |= WRITE_CACHE_USED ;\n"
                ],
                [
                    41,
                    " if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , \"datafile-header\" ) ) goto err ;\n"
                ],
                [
                    49,
                    " info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n"
                ],
                [
                    50,
                    " mi_drop_all_indexes ( param , info , FALSE ) ;\n"
                ],
                [
                    77,
                    " rec_per_key_part = param -> rec_per_key_part ;\n"
                ],
                [
                    80,
                    " rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) {\n"
                ],
                [
                    84,
                    " if ( ! mi_is_key_active ( key_map , sort_param . key ) ) {\n"
                ],
                [
                    85,
                    " memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n"
                ],
                [
                    89,
                    " if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( \"- Fixing index %d\\n\" , sort_param . key + 1 ) ;\n"
                ],
                [
                    102,
                    " info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n"
                ],
                [
                    103,
                    " info -> state -> empty = 0 ;\n"
                ],
                [
                    139,
                    " share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ;\n"
                ],
                [
                    147,
                    " else info -> state -> data_file_length = sort_param . max_pos ;\n"
                ],
                [
                    155,
                    " if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n"
                ],
                [
                    168,
                    " if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n"
                ],
                [
                    169,
                    " if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , \"Can't change size of indexfile, error: %d\" , my_errno ) ;\n"
                ],
                [
                    171,
                    " if ( start_records != info -> state -> records ) printf ( \"Data records: %s\\n\" , llstr ( info -> state -> records , llbuff ) ) ;\n"
                ],
                [
                    175,
                    " if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n"
                ],
                [
                    182,
                    " if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n"
                ],
                [
                    190,
                    " if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ;\n"
                ],
                [
                    192,
                    " mi_mark_crashed_on_repair ( info ) ;\n"
                ],
                [
                    196,
                    " my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n"
                ],
                [
                    197,
                    " my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int myisamchk ( MI_CHECK * param , char * filename ) {\n int error , lock_type , recreate ;\n int rep_quick = param -> testflag & ( T_QUICK | T_FORCE_UNIQUENESS ) ;\n MI_INFO * info ;\n File datafile ;\n char llbuff [ 22 ] , llbuff2 [ 22 ] ;\n my_bool state_updated = 0 ;\n MYISAM_SHARE * share ;\n DBUG_ENTER ( \"myisamchk\" ) ;\n param -> out_flag = error = param -> warning_printed = param -> error_printed = recreate = 0 ;\n datafile = 0 ;\n param -> isam_file_name = filename ;\n if ( ! ( info = mi_open ( filename , ( param -> testflag & ( T_DESCRIPT | T_READONLY ) ) ? O_RDONLY : O_RDWR , HA_OPEN_FOR_REPAIR | ( ( param -> testflag & T_WAIT_FOREVER ) ? HA_OPEN_WAIT_IF_LOCKED : ( param -> testflag & T_DESCRIPT ) ? HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED ) ) ) ) {\n param -> error_printed = 1 ;\n switch ( my_errno ) {\n case HA_ERR_CRASHED : mi_check_print_error ( param , \"'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair\" , filename ) ;\n break ;\n case HA_ERR_NOT_A_TABLE : mi_check_print_error ( param , \"'%s' is not a MyISAM-table\" , filename ) ;\n break ;\n case HA_ERR_CRASHED_ON_USAGE : mi_check_print_error ( param , \"'%s' is marked as crashed\" , filename ) ;\n break ;\n case HA_ERR_CRASHED_ON_REPAIR : mi_check_print_error ( param , \"'%s' is marked as crashed after last repair\" , filename ) ;\n break ;\n case HA_ERR_OLD_FILE : mi_check_print_error ( param , \"'%s' is an old type of MyISAM-table\" , filename ) ;\n break ;\n case HA_ERR_END_OF_FILE : mi_check_print_error ( param , \"Couldn't read complete header from '%s'\" , filename ) ;\n break ;\n case EAGAIN : mi_check_print_error ( param , \"'%s' is locked. Use -w to wait until unlocked\" , filename ) ;\n break ;\n case ENOENT : mi_check_print_error ( param , \"File '%s' doesn't exist\" , filename ) ;\n break ;\n case EACCES : mi_check_print_error ( param , \"You don't have permission to use '%s'\" , filename ) ;\n break ;\n default : mi_check_print_error ( param , \"%d when opening MyISAM-table '%s'\" , my_errno , filename ) ;\n break ;\n }\n DBUG_RETURN ( 1 ) ;\n }\n share = info -> s ;\n share -> options &= ~ HA_OPTION_READ_ONLY_DATA ;\n share -> tot_locks -= share -> r_locks ;\n share -> r_locks = 0 ;\n if ( param -> testflag & ( T_FAST | T_CHECK_ONLY_CHANGED ) ) {\n my_bool need_to_check = mi_is_crashed ( info ) || share -> state . open_count != 0 ;\n if ( ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS ) ) && ( ( share -> state . changed & ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) || ! ( param -> testflag & T_CHECK_ONLY_CHANGED ) ) ) ) need_to_check = 1 ;\n if ( info -> s -> base . keys && info -> state -> records ) {\n if ( ( param -> testflag & T_STATISTICS ) && ( share -> state . changed & STATE_NOT_ANALYZED ) ) need_to_check = 1 ;\n if ( ( param -> testflag & T_SORT_INDEX ) && ( share -> state . changed & STATE_NOT_SORTED_PAGES ) ) need_to_check = 1 ;\n if ( ( param -> testflag & T_REP_BY_SORT ) && ( share -> state . changed & STATE_NOT_OPTIMIZED_KEYS ) ) need_to_check = 1 ;\n }\n if ( ( param -> testflag & T_CHECK_ONLY_CHANGED ) && ( share -> state . changed & ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ) ) need_to_check = 1 ;\n if ( ! need_to_check ) {\n if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( \"MyISAM file: %s is already checked\\n\" , filename ) ;\n if ( mi_close ( info ) ) {\n mi_check_print_error ( param , \"%d when closing MyISAM-table '%s'\" , my_errno , filename ) ;\n DBUG_RETURN ( 1 ) ;\n }\n DBUG_RETURN ( 0 ) ;\n }\n }\n if ( ( param -> testflag & ( T_REP_ANY | T_STATISTICS | T_SORT_RECORDS | T_SORT_INDEX ) ) && ( ( ( param -> testflag & T_UNPACK ) && share -> data_file_type == COMPRESSED_RECORD ) || mi_uint2korr ( share -> state . header . state_info_length ) != MI_STATE_INFO_SIZE || mi_uint2korr ( share -> state . header . base_info_length ) != MI_BASE_INFO_SIZE || mi_is_any_intersect_keys_active ( param -> keys_in_use , share -> base . keys , ~ share -> state . key_map ) || test_if_almost_full ( info ) || info -> s -> state . header . file_version [ 3 ] != myisam_file_magic [ 3 ] || ( set_collation && set_collation -> number != share -> state . header . language ) || myisam_block_size != MI_KEY_BLOCK_LENGTH ) ) {\n if ( set_collation ) param -> language = set_collation -> number ;\n if ( recreate_table ( param , & info , filename ) ) {\n ( void ) fprintf ( stderr , \"MyISAM-table '%s' is not fixed because of errors\\n\" , filename ) ;\n return ( - 1 ) ;\n }\n recreate = 1 ;\n if ( ! ( param -> testflag & T_REP_ANY ) ) {\n param -> testflag |= T_REP_BY_SORT ;\n if ( ! ( param -> testflag & T_SILENT ) ) printf ( \"- '%s' has old table-format. Recreating index\\n\" , filename ) ;\n rep_quick |= T_QUICK ;\n }\n share = info -> s ;\n share -> tot_locks -= share -> r_locks ;\n share -> r_locks = 0 ;\n }\n if ( param -> testflag & T_DESCRIPT ) {\n param -> total_files ++ ;\n param -> total_records += info -> state -> records ;\n param -> total_deleted += info -> state -> del ;\n descript ( param , info , filename ) ;\n }\n else {\n if ( ! stopwords_inited ++ ) ft_init_stopwords ( ) ;\n if ( ! ( param -> testflag & T_READONLY ) ) lock_type = F_WRLCK ;\n else lock_type = F_RDLCK ;\n if ( info -> lock_type == F_RDLCK ) info -> lock_type = F_UNLCK ;\n if ( _mi_readinfo ( info , lock_type , 0 ) ) {\n mi_check_print_error ( param , \"Can't lock indexfile of '%s', error: %d\" , filename , my_errno ) ;\n param -> error_printed = 0 ;\n goto end2 ;\n }\n mi_lock_database ( info , F_EXTRA_LCK ) ;\n datafile = info -> dfile ;\n if ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX ) ) {\n if ( param -> testflag & T_REP_ANY ) {\n ulonglong tmp = share -> state . key_map ;\n mi_copy_keys_active ( share -> state . key_map , share -> base . keys , param -> keys_in_use ) ;\n if ( tmp != share -> state . key_map ) info -> update |= HA_STATE_CHANGED ;\n }\n if ( rep_quick && chk_del ( param , info , param -> testflag & ~ T_VERBOSE ) ) {\n if ( param -> testflag & T_FORCE_CREATE ) {\n rep_quick = 0 ;\n mi_check_print_info ( param , \"Creating new data file\\n\" ) ;\n }\n else {\n error = 1 ;\n mi_check_print_error ( param , \"Quick-recover aborted;\n Run recovery without switch 'q'\" ) ;\n }\n }\n if ( ! error ) {\n if ( ( param -> testflag & ( T_REP_BY_SORT | T_REP_PARALLEL ) ) && ( mi_is_any_key_active ( share -> state . key_map ) || ( rep_quick && ! param -> keys_in_use && ! recreate ) ) && mi_test_if_sort_rep ( info , info -> state -> records , info -> s -> state . key_map , param -> force_sort ) ) {\n if ( param -> testflag & T_REP_BY_SORT ) error = mi_repair_by_sort ( param , info , filename , rep_quick ) ;\n else error = mi_repair_parallel ( param , info , filename , rep_quick ) ;\n state_updated = 1 ;\n }\n else if ( param -> testflag & T_REP_ANY ) error = mi_repair ( param , info , filename , rep_quick ) ;\n }\n if ( ! error && param -> testflag & T_SORT_RECORDS ) {\n # ifndef TO_BE_REMOVED if ( param -> out_flag & O_NEW_DATA ) {\n ( void ) my_close ( info -> dfile , MYF ( MY_WME ) ) ;\n error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , MYF ( 0 ) ) ;\n if ( mi_open_datafile ( info , info -> s , NULL , - 1 ) ) error = 1 ;\n param -> out_flag &= ~ O_NEW_DATA ;\n param -> read_cache . file = info -> dfile ;\n }\n # endif if ( ! error ) {\n uint key ;\n my_bool update_index = 1 ;\n for ( key = 0 ;\n key < share -> base . keys ;\n key ++ ) if ( share -> keyinfo [ key ] . flag & ( HA_BINARY_PACK_KEY | HA_FULLTEXT ) ) update_index = 0 ;\n error = mi_sort_records ( param , info , filename , param -> opt_sort_key , ( my_bool ) ! ( param -> testflag & T_REP ) , update_index ) ;\n datafile = info -> dfile ;\n if ( ! error && ! update_index ) {\n if ( param -> verbose ) puts ( \"Table had a compressed index;\n We must now recreate the index\" ) ;\n error = mi_repair_by_sort ( param , info , filename , 1 ) ;\n }\n }\n }\n if ( ! error && param -> testflag & T_SORT_INDEX ) error = mi_sort_index ( param , info , filename ) ;\n if ( ! error ) share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ;\n else mi_mark_crashed ( info ) ;\n }\n else if ( ( param -> testflag & T_CHECK ) || ! ( param -> testflag & T_AUTO_INC ) ) {\n if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( \"Checking MyISAM file: %s\\n\" , filename ) ;\n if ( ! ( param -> testflag & T_SILENT ) ) printf ( \"Data records: %7s Deleted blocks: %7s\\n\" , llstr ( info -> state -> records , llbuff ) , llstr ( info -> state -> del , llbuff2 ) ) ;\n error = chk_status ( param , info ) ;\n mi_intersect_keys_active ( share -> state . key_map , param -> keys_in_use ) ;\n error = chk_size ( param , info ) ;\n if ( ! error || ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) ) error |= chk_del ( param , info , param -> testflag ) ;\n if ( ( ! error || ( ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) && ! param -> start_check_pos ) ) ) {\n error |= chk_key ( param , info ) ;\n if ( ! error && ( param -> testflag & ( T_STATISTICS | T_AUTO_INC ) ) ) error = update_state_info ( param , info , ( ( param -> testflag & T_STATISTICS ) ? UPDATE_STAT : 0 ) | ( ( param -> testflag & T_AUTO_INC ) ? UPDATE_AUTO_INC : 0 ) ) ;\n }\n if ( ( ! rep_quick && ! error ) || ! ( param -> testflag & ( T_FAST | T_FORCE_CREATE ) ) ) {\n if ( param -> testflag & ( T_EXTEND | T_MEDIUM ) ) ( void ) init_key_cache ( dflt_key_cache , opt_key_cache_block_size , param -> use_buffers , 0 , 0 ) ;\n ( void ) init_io_cache ( & param -> read_cache , datafile , ( uint ) param -> read_buffer_length , READ_CACHE , ( param -> start_check_pos ? param -> start_check_pos : share -> pack . header_length ) , 1 , MYF ( MY_WME ) ) ;\n lock_memory ( param ) ;\n if ( ( info -> s -> options & ( HA_OPTION_PACK_RECORD | HA_OPTION_COMPRESS_RECORD ) ) || ( param -> testflag & ( T_EXTEND | T_MEDIUM ) ) ) error |= chk_data_link ( param , info , param -> testflag & T_EXTEND ) ;\n error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;\n ( void ) end_io_cache ( & param -> read_cache ) ;\n }\n if ( ! error ) {\n if ( ( share -> state . changed & STATE_CHANGED ) && ( param -> testflag & T_UPDATE_STATE ) ) info -> update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ;\n share -> state . changed &= ~ ( STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR ) ;\n }\n else if ( ! mi_is_crashed ( info ) && ( param -> testflag & T_UPDATE_STATE ) ) {\n mi_mark_crashed ( info ) ;\n info -> update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ;\n }\n }\n }\n if ( ( param -> testflag & T_AUTO_INC ) || ( ( param -> testflag & T_REP_ANY ) && info -> s -> base . auto_key ) ) update_auto_increment_key ( param , info , ( my_bool ) ! test ( param -> testflag & T_AUTO_INC ) ) ;\n if ( ! ( param -> testflag & T_DESCRIPT ) ) {\n if ( info -> update & HA_STATE_CHANGED && ! ( param -> testflag & T_READONLY ) ) error |= update_state_info ( param , info , UPDATE_OPEN_COUNT | ( ( ( param -> testflag & T_REP_ANY ) ? UPDATE_TIME : 0 ) | ( state_updated ? UPDATE_STAT : 0 ) | ( ( param -> testflag & T_SORT_RECORDS ) ? UPDATE_SORT : 0 ) ) ) ;\n ( void ) lock_file ( param , share -> kfile , 0L , F_UNLCK , \"indexfile\" , filename ) ;\n info -> update &= ~ HA_STATE_CHANGED ;\n }\n mi_lock_database ( info , F_UNLCK ) ;\n end2 : if ( mi_close ( info ) ) {\n mi_check_print_error ( param , \"%d when closing MyISAM-table '%s'\" , my_errno , filename ) ;\n DBUG_RETURN ( 1 ) ;\n }\n if ( error == 0 ) {\n if ( param -> out_flag & O_NEW_DATA ) error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , ( ( param -> testflag & T_BACKUP_DATA ) ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) ;\n if ( param -> out_flag & O_NEW_INDEX ) error |= change_to_newfile ( filename , MI_NAME_IEXT , INDEX_TMP_EXT , MYF ( 0 ) ) ;\n }\n ( void ) fflush ( stdout ) ;\n ( void ) fflush ( stderr ) ;\n if ( param -> error_printed ) {\n if ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX ) ) {\n ( void ) fprintf ( stderr , \"MyISAM-table '%s' is not fixed because of errors\\n\" , filename ) ;\n if ( param -> testflag & T_REP_ANY ) ( void ) fprintf ( stderr , \"Try fixing it by using the --safe-recover (-o), the --force (-f) option or by not using the --quick (-q) flag\\n\" ) ;\n }\n else if ( ! ( param -> error_printed & 2 ) && ! ( param -> testflag & T_FORCE_CREATE ) ) ( void ) fprintf ( stderr , \"MyISAM-table '%s' is corrupted\\nFix it using switch \\\"-r\\\" or \\\"-o\\\"\\n\" , filename ) ;\n }\n else if ( param -> warning_printed && ! ( param -> testflag & ( T_REP_ANY | T_SORT_RECORDS | T_SORT_INDEX | T_FORCE_CREATE ) ) ) ( void ) fprintf ( stderr , \"MyISAM-table '%s' is usable but should be fixed\\n\" , filename ) ;\n ( void ) fflush ( stderr ) ;\n DBUG_RETURN ( error ) ;\n }",
        "hash": -4978896576290502518,
        "project": "debian",
        "size": 203,
        "slice": {
            "printf": [
                [
                    1,
                    "static int myisamchk ( MI_CHECK * param , char * filename ) {\n"
                ],
                [
                    13,
                    " if ( ! ( info = mi_open ( filename , ( param -> testflag & ( T_DESCRIPT | T_READONLY ) ) ? O_RDONLY : O_RDWR , HA_OPEN_FOR_REPAIR | ( ( param -> testflag & T_WAIT_FOREVER ) ? HA_OPEN_WAIT_IF_LOCKED : ( param -> testflag & T_DESCRIPT ) ? HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED ) ) ) ) {\n"
                ],
                [
                    16,
                    " case HA_ERR_CRASHED : mi_check_print_error ( param , \"'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair\" , filename ) ;\n"
                ],
                [
                    18,
                    " case HA_ERR_NOT_A_TABLE : mi_check_print_error ( param , \"'%s' is not a MyISAM-table\" , filename ) ;\n"
                ],
                [
                    20,
                    " case HA_ERR_CRASHED_ON_USAGE : mi_check_print_error ( param , \"'%s' is marked as crashed\" , filename ) ;\n"
                ],
                [
                    22,
                    " case HA_ERR_CRASHED_ON_REPAIR : mi_check_print_error ( param , \"'%s' is marked as crashed after last repair\" , filename ) ;\n"
                ],
                [
                    24,
                    " case HA_ERR_OLD_FILE : mi_check_print_error ( param , \"'%s' is an old type of MyISAM-table\" , filename ) ;\n"
                ],
                [
                    26,
                    " case HA_ERR_END_OF_FILE : mi_check_print_error ( param , \"Couldn't read complete header from '%s'\" , filename ) ;\n"
                ],
                [
                    28,
                    " case EAGAIN : mi_check_print_error ( param , \"'%s' is locked. Use -w to wait until unlocked\" , filename ) ;\n"
                ],
                [
                    30,
                    " case ENOENT : mi_check_print_error ( param , \"File '%s' doesn't exist\" , filename ) ;\n"
                ],
                [
                    32,
                    " case EACCES : mi_check_print_error ( param , \"You don't have permission to use '%s'\" , filename ) ;\n"
                ],
                [
                    34,
                    " default : mi_check_print_error ( param , \"%d when opening MyISAM-table '%s'\" , my_errno , filename ) ;\n"
                ],
                [
                    53,
                    " if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( \"MyISAM file: %s is already checked\\n\" , filename ) ;\n"
                ],
                [
                    55,
                    " mi_check_print_error ( param , \"%d when closing MyISAM-table '%s'\" , my_errno , filename ) ;\n"
                ],
                [
                    63,
                    " if ( recreate_table ( param , & info , filename ) ) {\n"
                ],
                [
                    70,
                    " if ( ! ( param -> testflag & T_SILENT ) ) printf ( \"- '%s' has old table-format. Recreating index\\n\" , filename ) ;\n"
                ],
                [
                    81,
                    " descript ( param , info , filename ) ;\n"
                ],
                [
                    89,
                    " mi_check_print_error ( param , \"Can't lock indexfile of '%s', error: %d\" , filename , my_errno ) ;\n"
                ],
                [
                    114,
                    " if ( param -> testflag & T_REP_BY_SORT ) error = mi_repair_by_sort ( param , info , filename , rep_quick ) ;\n"
                ],
                [
                    115,
                    " else error = mi_repair_parallel ( param , info , filename , rep_quick ) ;\n"
                ],
                [
                    118,
                    " else if ( param -> testflag & T_REP_ANY ) error = mi_repair ( param , info , filename , rep_quick ) ;\n"
                ],
                [
                    123,
                    " error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , MYF ( 0 ) ) ;\n"
                ],
                [
                    134,
                    " error = mi_sort_records ( param , info , filename , param -> opt_sort_key , ( my_bool ) ! ( param -> testflag & T_REP ) , update_index ) ;\n"
                ],
                [
                    143,
                    " if ( ! error && param -> testflag & T_SORT_INDEX ) error = mi_sort_index ( param , info , filename ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static int myisamchk ( MI_CHECK * param , char * filename ) {\n"
                ],
                [
                    63,
                    " if ( recreate_table ( param , & info , filename ) ) {\n"
                ],
                [
                    64,
                    " ( void ) fprintf ( stderr , \"MyISAM-table '%s' is not fixed because of errors\\n\" , filename ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int myisamchk ( MI_CHECK * param , char * filename ) {\n"
                ],
                [
                    13,
                    " if ( ! ( info = mi_open ( filename , ( param -> testflag & ( T_DESCRIPT | T_READONLY ) ) ? O_RDONLY : O_RDWR , HA_OPEN_FOR_REPAIR | ( ( param -> testflag & T_WAIT_FOREVER ) ? HA_OPEN_WAIT_IF_LOCKED : ( param -> testflag & T_DESCRIPT ) ? HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED ) ) ) ) {\n"
                ],
                [
                    16,
                    " case HA_ERR_CRASHED : mi_check_print_error ( param , \"'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair\" , filename ) ;\n"
                ],
                [
                    18,
                    " case HA_ERR_NOT_A_TABLE : mi_check_print_error ( param , \"'%s' is not a MyISAM-table\" , filename ) ;\n"
                ],
                [
                    20,
                    " case HA_ERR_CRASHED_ON_USAGE : mi_check_print_error ( param , \"'%s' is marked as crashed\" , filename ) ;\n"
                ],
                [
                    22,
                    " case HA_ERR_CRASHED_ON_REPAIR : mi_check_print_error ( param , \"'%s' is marked as crashed after last repair\" , filename ) ;\n"
                ],
                [
                    24,
                    " case HA_ERR_OLD_FILE : mi_check_print_error ( param , \"'%s' is an old type of MyISAM-table\" , filename ) ;\n"
                ],
                [
                    26,
                    " case HA_ERR_END_OF_FILE : mi_check_print_error ( param , \"Couldn't read complete header from '%s'\" , filename ) ;\n"
                ],
                [
                    28,
                    " case EAGAIN : mi_check_print_error ( param , \"'%s' is locked. Use -w to wait until unlocked\" , filename ) ;\n"
                ],
                [
                    30,
                    " case ENOENT : mi_check_print_error ( param , \"File '%s' doesn't exist\" , filename ) ;\n"
                ],
                [
                    32,
                    " case EACCES : mi_check_print_error ( param , \"You don't have permission to use '%s'\" , filename ) ;\n"
                ],
                [
                    34,
                    " default : mi_check_print_error ( param , \"%d when opening MyISAM-table '%s'\" , my_errno , filename ) ;\n"
                ],
                [
                    53,
                    " if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( \"MyISAM file: %s is already checked\\n\" , filename ) ;\n"
                ],
                [
                    55,
                    " mi_check_print_error ( param , \"%d when closing MyISAM-table '%s'\" , my_errno , filename ) ;\n"
                ],
                [
                    63,
                    " if ( recreate_table ( param , & info , filename ) ) {\n"
                ],
                [
                    64,
                    " ( void ) fprintf ( stderr , \"MyISAM-table '%s' is not fixed because of errors\\n\" , filename ) ;\n"
                ],
                [
                    70,
                    " if ( ! ( param -> testflag & T_SILENT ) ) printf ( \"- '%s' has old table-format. Recreating index\\n\" , filename ) ;\n"
                ],
                [
                    81,
                    " descript ( param , info , filename ) ;\n"
                ],
                [
                    89,
                    " mi_check_print_error ( param , \"Can't lock indexfile of '%s', error: %d\" , filename , my_errno ) ;\n"
                ],
                [
                    114,
                    " if ( param -> testflag & T_REP_BY_SORT ) error = mi_repair_by_sort ( param , info , filename , rep_quick ) ;\n"
                ],
                [
                    115,
                    " else error = mi_repair_parallel ( param , info , filename , rep_quick ) ;\n"
                ],
                [
                    118,
                    " else if ( param -> testflag & T_REP_ANY ) error = mi_repair ( param , info , filename , rep_quick ) ;\n"
                ],
                [
                    123,
                    " error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , MYF ( 0 ) ) ;\n"
                ],
                [
                    134,
                    " error = mi_sort_records ( param , info , filename , param -> opt_sort_key , ( my_bool ) ! ( param -> testflag & T_REP ) , update_index ) ;\n"
                ],
                [
                    143,
                    " if ( ! error && param -> testflag & T_SORT_INDEX ) error = mi_sort_index ( param , info , filename ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int dtls1_get_record ( SSL * s ) {\n int ssl_major , ssl_minor ;\n int i , n ;\n SSL3_RECORD * rr ;\n unsigned char * p = NULL ;\n unsigned short version ;\n DTLS1_BITMAP * bitmap ;\n unsigned int is_next_epoch ;\n rr = RECORD_LAYER_get_rrec ( & s -> rlayer ) ;\n again : if ( dtls1_process_buffered_records ( s ) < 0 ) return - 1 ;\n if ( dtls1_get_processed_record ( s ) ) return 1 ;\n if ( ( RECORD_LAYER_get_rstate ( & s -> rlayer ) != SSL_ST_READ_BODY ) || ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) < DTLS1_RT_HEADER_LENGTH ) ) {\n n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , SSL3_BUFFER_get_len ( & s -> rlayer . rbuf ) , 0 , 1 ) ;\n if ( n <= 0 ) return ( n ) ;\n if ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) != DTLS1_RT_HEADER_LENGTH ) {\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_BODY ) ;\n p = RECORD_LAYER_get_packet ( & s -> rlayer ) ;\n if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ;\n rr -> type = * ( p ++ ) ;\n ssl_major = * ( p ++ ) ;\n ssl_minor = * ( p ++ ) ;\n version = ( ssl_major << 8 ) | ssl_minor ;\n n2s ( p , rr -> epoch ) ;\n memcpy ( & ( RECORD_LAYER_get_read_sequence ( & s -> rlayer ) [ 2 ] ) , p , 6 ) ;\n p += 6 ;\n n2s ( p , rr -> length ) ;\n if ( ! s -> first_packet ) {\n if ( version != s -> version ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n }\n if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n }\n if ( rr -> length > RECORD_LAYER_get_packet_length ( & s -> rlayer ) - DTLS1_RT_HEADER_LENGTH ) {\n i = rr -> length ;\n n = ssl3_read_n ( s , i , i , 1 , 1 ) ;\n if ( n != i ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n }\n RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_HEADER ) ;\n bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ;\n if ( bitmap == NULL ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) {\n # endif if ( ! dtls1_record_replay_check ( s , bitmap ) ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n # ifndef OPENSSL_NO_SCTP }\n # endif if ( rr -> length == 0 ) goto again ;\n if ( is_next_epoch ) {\n if ( ( SSL_in_init ( s ) || ossl_statem_get_in_handshake ( s ) ) ) {\n if ( dtls1_buffer_record ( s , & ( DTLS_RECORD_LAYER_get_unprocessed_rcds ( & s -> rlayer ) ) , rr -> seq_num ) < 0 ) return - 1 ;\n dtls1_record_bitmap_update ( s , bitmap ) ;\n }\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n if ( ! dtls1_process_record ( s ) ) {\n rr -> length = 0 ;\n RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ;\n goto again ;\n }\n dtls1_record_bitmap_update ( s , bitmap ) ;\n return ( 1 ) ;\n }",
        "hash": 1825251920369138543,
        "project": "debian",
        "size": 88,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int dtls1_get_record ( SSL * s ) {\n"
                ],
                [
                    15,
                    " if ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) != DTLS1_RT_HEADER_LENGTH ) {\n"
                ],
                [
                    26,
                    " n2s ( p , rr -> epoch ) ;\n"
                ],
                [
                    27,
                    " memcpy ( & ( RECORD_LAYER_get_read_sequence ( & s -> rlayer ) [ 2 ] ) , p , 6 ) ;\n"
                ],
                [
                    28,
                    " p += 6 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int dtls1_get_record ( SSL * s ) {\n"
                ],
                [
                    15,
                    " if ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) != DTLS1_RT_HEADER_LENGTH ) {\n"
                ],
                [
                    26,
                    " n2s ( p , rr -> epoch ) ;\n"
                ],
                [
                    27,
                    " memcpy ( & ( RECORD_LAYER_get_read_sequence ( & s -> rlayer ) [ 2 ] ) , p , 6 ) ;\n"
                ],
                [
                    28,
                    " p += 6 ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ;\n unsigned char * channel_identities = NULL ;\n unsigned char * channel_reorder = NULL ;\n int64_t total_samples = 0 , infilesize ;\n CAFFileHeader caf_file_header ;\n CAFChunkHeader caf_chunk_header ;\n CAFAudioFormat caf_audio_format ;\n int i ;\n infilesize = DoGetFileSize ( infile ) ;\n memcpy ( & caf_file_header , fourcc , 4 ) ;\n if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ;\n if ( caf_file_header . mFileVersion != 1 ) {\n error_line ( \"%s: can't handle version %d .CAF files!\" , infilename , caf_file_header . mFileVersion ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n while ( 1 ) {\n if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ;\n if ( ! strncmp ( caf_chunk_header . mChunkType , \"desc\" , 4 ) ) {\n int supported = TRUE ;\n if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;\n if ( debug_logging_mode ) {\n char formatstr [ 5 ] ;\n memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ;\n formatstr [ 4 ] = 0 ;\n error_line ( \"format = %s, flags = %x, sampling rate = %g\" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ;\n error_line ( \"packet = %d bytes and %d frames\" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ;\n error_line ( \"channels per frame = %d, bits per channel = %d\" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ;\n }\n if ( strncmp ( caf_audio_format . mFormatID , \"lpcm\" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ;\n else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ;\n else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ;\n else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ;\n else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ;\n if ( ! supported ) {\n error_line ( \"%s is an unsupported .CAF format!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ;\n config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ;\n config -> bits_per_sample = caf_audio_format . mBitsPerChannel ;\n config -> num_channels = caf_audio_format . mChannelsPerFrame ;\n config -> sample_rate = ( int ) caf_audio_format . mSampleRate ;\n if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ;\n if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ;\n if ( debug_logging_mode ) {\n if ( config -> float_norm_exp == 127 ) error_line ( \"data format: 32-bit %s-endian floating point\" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? \"big\" : \"little\" ) ;\n else error_line ( \"data format: %d-bit %s-endian integers stored in %d byte(s)\" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? \"big\" : \"little\" , config -> bytes_per_sample ) ;\n }\n }\n else if ( ! strncmp ( caf_chunk_header . mChunkType , \"chan\" , 4 ) ) {\n CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;\n if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n free ( caf_channel_layout ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n free ( caf_channel_layout ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ;\n chan_chunk = 1 ;\n if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) {\n error_line ( \"this CAF file already has channel order information!\" ) ;\n free ( caf_channel_layout ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n switch ( caf_channel_layout -> mChannelLayoutTag ) {\n case kCAFChannelLayoutTag_UseChannelDescriptions : {\n CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ;\n int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ;\n int label , cindex = 0 , idents = 0 ;\n if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) {\n error_line ( \"channel descriptions in 'chan' chunk are the wrong size!\" ) ;\n free ( caf_channel_layout ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( num_descriptions >= 256 ) {\n error_line ( \"%d channel descriptions is more than we can handle...ignoring!\" ) ;\n break ;\n }\n channel_reorder = malloc ( num_descriptions ) ;\n memset ( channel_reorder , - 1 , num_descriptions ) ;\n channel_identities = malloc ( num_descriptions + 1 ) ;\n for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) {\n WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ;\n if ( debug_logging_mode ) error_line ( \"chan %d --> %d\" , i + 1 , descriptions [ i ] . mChannelLabel ) ;\n }\n for ( label = 1 ;\n label <= 18 ;\n ++ label ) for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) {\n config -> channel_mask |= 1 << ( label - 1 ) ;\n channel_reorder [ i ] = cindex ++ ;\n break ;\n }\n for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) {\n uint32_t clabel = descriptions [ i ] . mChannelLabel ;\n if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ;\n else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ;\n else {\n error_line ( \"warning: unknown channel descriptions label: %d\" , clabel ) ;\n channel_identities [ idents ++ ] = 0xff ;\n }\n channel_reorder [ i ] = cindex ++ ;\n }\n for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) if ( channel_reorder [ i ] != i ) break ;\n if ( i == num_descriptions ) {\n free ( channel_reorder ) ;\n channel_reorder = NULL ;\n }\n else {\n config -> qmode |= QMODE_REORDERED_CHANS ;\n channel_layout = num_descriptions ;\n }\n if ( ! idents ) {\n free ( channel_identities ) ;\n channel_identities = NULL ;\n }\n else channel_identities [ idents ] = 0 ;\n if ( debug_logging_mode ) {\n error_line ( \"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;\n if ( channel_reorder && num_descriptions <= 8 ) {\n char reorder_string [ ] = \"12345678\" ;\n for ( i = 0 ;\n i < num_descriptions ;\n ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ;\n reorder_string [ i ] = 0 ;\n error_line ( \"reordering string = \\\"%s\\\"\\n\" , reorder_string ) ;\n }\n }\n }\n break ;\n case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ;\n if ( debug_logging_mode ) error_line ( \"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;\n break ;\n default : for ( i = 0 ;\n i < NUM_LAYOUTS ;\n ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {\n config -> channel_mask = layouts [ i ] . mChannelBitmap ;\n channel_layout = layouts [ i ] . mChannelLayoutTag ;\n if ( layouts [ i ] . mChannelReorder ) {\n channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;\n config -> qmode |= QMODE_REORDERED_CHANS ;\n }\n if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;\n if ( debug_logging_mode ) error_line ( \"layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s\" , channel_layout , config -> channel_mask , channel_reorder ? \"yes\" : \"no\" , channel_identities ? \"yes\" : \"no\" ) ;\n break ;\n }\n if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( \"layout_tag 0x%08x not found in table...all channels unassigned\" , caf_channel_layout -> mChannelLayoutTag ) ;\n break ;\n }\n free ( caf_channel_layout ) ;\n }\n else if ( ! strncmp ( caf_chunk_header . mChunkType , \"data\" , 4 ) ) {\n uint32_t mEditCount ;\n if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) {\n error_line ( \"%s is not a valid .CAF file!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) {\n config -> qmode |= QMODE_IGNORE_LENGTH ;\n if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ;\n else total_samples = - 1 ;\n }\n else {\n if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) {\n error_line ( \".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) {\n error_line ( \".CAF file %s has an invalid data chunk size, probably is corrupt!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ;\n if ( ! total_samples ) {\n error_line ( \"this .CAF file has no audio samples, probably is corrupt!\" ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( total_samples > MAX_WAVPACK_SAMPLES ) {\n error_line ( \"%s has too many samples for WavPack!\" , infilename ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n }\n break ;\n }\n else {\n int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;\n char * buff = malloc ( bytes_to_copy ) ;\n if ( debug_logging_mode ) error_line ( \"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;\n if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n free ( buff ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n free ( buff ) ;\n }\n }\n if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ;\n if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) {\n error_line ( \"%s\" , WavpackGetErrorMessage ( wpc ) ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( channel_identities ) free ( channel_identities ) ;\n if ( channel_layout || channel_reorder ) {\n if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) {\n error_line ( \"problem with setting channel layout (should not happen)\" ) ;\n return WAVPACK_SOFT_ERROR ;\n }\n if ( channel_reorder ) free ( channel_reorder ) ;\n }\n return WAVPACK_NO_ERROR ;\n }",
        "hash": 2447070537606626244,
        "project": "debian",
        "size": 250,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n"
                ],
                [
                    11,
                    " memcpy ( & caf_file_header , fourcc , 4 ) ;\n"
                ],
                [
                    12,
                    " if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) {\n"
                ],
                [
                    16,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) {\n"
                ],
                [
                    20,
                    " WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ;\n"
                ],
                [
                    21,
                    " if ( caf_file_header . mFileVersion != 1 ) {\n"
                ],
                [
                    22,
                    " error_line ( \"%s: can't handle version %d .CAF files!\" , infilename , caf_file_header . mFileVersion ) ;\n"
                ],
                [
                    37,
                    " if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n"
                ],
                [
                    41,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n"
                ],
                [
                    45,
                    " WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;\n"
                ],
                [
                    46,
                    " if ( debug_logging_mode ) {\n"
                ],
                [
                    47,
                    " char formatstr [ 5 ] ;\n"
                ],
                [
                    48,
                    " memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ;\n"
                ],
                [
                    49,
                    " formatstr [ 4 ] = 0 ;\n"
                ],
                [
                    50,
                    " error_line ( \"format = %s, flags = %x, sampling rate = %g\" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ;\n"
                ],
                [
                    51,
                    " error_line ( \"packet = %d bytes and %d frames\" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ;\n"
                ],
                [
                    54,
                    " if ( strncmp ( caf_audio_format . mFormatID , \"lpcm\" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ;\n"
                ],
                [
                    55,
                    " else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ;\n"
                ],
                [
                    58,
                    " else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ;\n"
                ],
                [
                    63,
                    " config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ;\n"
                ],
                [
                    68,
                    " if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n"
                ],
                [
                    104,
                    " if ( num_descriptions >= 256 ) {\n"
                ],
                [
                    108,
                    " channel_reorder = malloc ( num_descriptions ) ;\n"
                ],
                [
                    109,
                    " memset ( channel_reorder , - 1 , num_descriptions ) ;\n"
                ],
                [
                    110,
                    " channel_identities = malloc ( num_descriptions + 1 ) ;\n"
                ],
                [
                    112,
                    " i < num_descriptions ;\n"
                ],
                [
                    123,
                    " channel_reorder [ i ] = cindex ++ ;\n"
                ],
                [
                    128,
                    " ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) {\n"
                ],
                [
                    136,
                    " channel_reorder [ i ] = cindex ++ ;\n"
                ],
                [
                    140,
                    " ++ i ) if ( channel_reorder [ i ] != i ) break ;\n"
                ],
                [
                    142,
                    " free ( channel_reorder ) ;\n"
                ],
                [
                    156,
                    " if ( channel_reorder && num_descriptions <= 8 ) {\n"
                ],
                [
                    242,
                    " if ( channel_layout || channel_reorder ) {\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n"
                ],
                [
                    26,
                    " if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) {\n"
                ],
                [
                    30,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) {\n"
                ],
                [
                    34,
                    " WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ;\n"
                ],
                [
                    35,
                    " if ( ! strncmp ( caf_chunk_header . mChunkType , \"desc\" , 4 ) ) {\n"
                ],
                [
                    37,
                    " if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n"
                ],
                [
                    75,
                    " else if ( ! strncmp ( caf_chunk_header . mChunkType , \"chan\" , 4 ) ) {\n"
                ],
                [
                    76,
                    " CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;\n"
                ],
                [
                    77,
                    " if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n"
                ],
                [
                    79,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    82,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n"
                ],
                [
                    84,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    87,
                    " WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ;\n"
                ],
                [
                    99,
                    " if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) {\n"
                ],
                [
                    104,
                    " if ( num_descriptions >= 256 ) {\n"
                ],
                [
                    108,
                    " channel_reorder = malloc ( num_descriptions ) ;\n"
                ],
                [
                    109,
                    " memset ( channel_reorder , - 1 , num_descriptions ) ;\n"
                ],
                [
                    110,
                    " channel_identities = malloc ( num_descriptions + 1 ) ;\n"
                ],
                [
                    150,
                    " free ( channel_identities ) ;\n"
                ],
                [
                    188,
                    " else if ( ! strncmp ( caf_chunk_header . mChunkType , \"data\" , 4 ) ) {\n"
                ],
                [
                    225,
                    " int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;\n"
                ],
                [
                    226,
                    " char * buff = malloc ( bytes_to_copy ) ;\n"
                ],
                [
                    227,
                    " if ( debug_logging_mode ) error_line ( \"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;\n"
                ],
                [
                    228,
                    " if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) {\n"
                ],
                [
                    237,
                    " if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n"
                ],
                [
                    76,
                    " CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;\n"
                ],
                [
                    77,
                    " if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n"
                ],
                [
                    79,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    82,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n"
                ],
                [
                    84,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    87,
                    " WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ;\n"
                ],
                [
                    89,
                    " if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) {\n"
                ],
                [
                    91,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    94,
                    " switch ( caf_channel_layout -> mChannelLayoutTag ) {\n"
                ],
                [
                    99,
                    " if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) {\n"
                ],
                [
                    101,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    109,
                    " memset ( channel_reorder , - 1 , num_descriptions ) ;\n"
                ],
                [
                    110,
                    " channel_identities = malloc ( num_descriptions + 1 ) ;\n"
                ],
                [
                    123,
                    " channel_reorder [ i ] = cindex ++ ;\n"
                ],
                [
                    128,
                    " ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) {\n"
                ],
                [
                    130,
                    " if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ;\n"
                ],
                [
                    131,
                    " else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ;\n"
                ],
                [
                    134,
                    " channel_identities [ idents ++ ] = 0xff ;\n"
                ],
                [
                    136,
                    " channel_reorder [ i ] = cindex ++ ;\n"
                ],
                [
                    140,
                    " ++ i ) if ( channel_reorder [ i ] != i ) break ;\n"
                ],
                [
                    141,
                    " if ( i == num_descriptions ) {\n"
                ],
                [
                    142,
                    " free ( channel_reorder ) ;\n"
                ],
                [
                    149,
                    " if ( ! idents ) {\n"
                ],
                [
                    150,
                    " free ( channel_identities ) ;\n"
                ],
                [
                    153,
                    " else channel_identities [ idents ] = 0 ;\n"
                ],
                [
                    155,
                    " error_line ( \"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;\n"
                ],
                [
                    156,
                    " if ( channel_reorder && num_descriptions <= 8 ) {\n"
                ],
                [
                    168,
                    " if ( debug_logging_mode ) error_line ( \"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;\n"
                ],
                [
                    172,
                    " ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {\n"
                ],
                [
                    183,
                    " if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( \"layout_tag 0x%08x not found in table...all channels unassigned\" , caf_channel_layout -> mChannelLayoutTag ) ;\n"
                ],
                [
                    186,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    228,
                    " if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) {\n"
                ],
                [
                    230,
                    " free ( buff ) ;\n"
                ],
                [
                    233,
                    " free ( buff ) ;\n"
                ],
                [
                    237,
                    " if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) {\n"
                ],
                [
                    241,
                    " if ( channel_identities ) free ( channel_identities ) ;\n"
                ],
                [
                    243,
                    " if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) {\n"
                ],
                [
                    247,
                    " if ( channel_reorder ) free ( channel_reorder ) ;\n"
                ]
            ],
            "strdup": [
                [
                    175,
                    " if ( layouts [ i ] . mChannelReorder ) {\n"
                ],
                [
                    176,
                    " channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;\n"
                ],
                [
                    179,
                    " if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;\n"
                ],
                [
                    237,
                    " if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) {\n"
                ],
                [
                    242,
                    " if ( channel_layout || channel_reorder ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n"
                ],
                [
                    11,
                    " memcpy ( & caf_file_header , fourcc , 4 ) ;\n"
                ],
                [
                    12,
                    " if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) {\n"
                ],
                [
                    16,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) {\n"
                ],
                [
                    20,
                    " WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ;\n"
                ],
                [
                    21,
                    " if ( caf_file_header . mFileVersion != 1 ) {\n"
                ],
                [
                    22,
                    " error_line ( \"%s: can't handle version %d .CAF files!\" , infilename , caf_file_header . mFileVersion ) ;\n"
                ],
                [
                    26,
                    " if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) {\n"
                ],
                [
                    30,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) {\n"
                ],
                [
                    34,
                    " WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ;\n"
                ],
                [
                    35,
                    " if ( ! strncmp ( caf_chunk_header . mChunkType , \"desc\" , 4 ) ) {\n"
                ],
                [
                    37,
                    " if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n"
                ],
                [
                    41,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n"
                ],
                [
                    45,
                    " WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;\n"
                ],
                [
                    46,
                    " if ( debug_logging_mode ) {\n"
                ],
                [
                    47,
                    " char formatstr [ 5 ] ;\n"
                ],
                [
                    48,
                    " memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ;\n"
                ],
                [
                    49,
                    " formatstr [ 4 ] = 0 ;\n"
                ],
                [
                    50,
                    " error_line ( \"format = %s, flags = %x, sampling rate = %g\" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ;\n"
                ],
                [
                    51,
                    " error_line ( \"packet = %d bytes and %d frames\" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ;\n"
                ],
                [
                    54,
                    " if ( strncmp ( caf_audio_format . mFormatID , \"lpcm\" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ;\n"
                ],
                [
                    55,
                    " else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ;\n"
                ],
                [
                    58,
                    " else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ;\n"
                ],
                [
                    63,
                    " config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ;\n"
                ],
                [
                    68,
                    " if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ;\n"
                ],
                [
                    75,
                    " else if ( ! strncmp ( caf_chunk_header . mChunkType , \"chan\" , 4 ) ) {\n"
                ],
                [
                    76,
                    " CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;\n"
                ],
                [
                    77,
                    " if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n"
                ],
                [
                    79,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    82,
                    " else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n"
                ],
                [
                    84,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    87,
                    " WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ;\n"
                ],
                [
                    89,
                    " if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) {\n"
                ],
                [
                    91,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    94,
                    " switch ( caf_channel_layout -> mChannelLayoutTag ) {\n"
                ],
                [
                    99,
                    " if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) {\n"
                ],
                [
                    101,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    104,
                    " if ( num_descriptions >= 256 ) {\n"
                ],
                [
                    108,
                    " channel_reorder = malloc ( num_descriptions ) ;\n"
                ],
                [
                    109,
                    " memset ( channel_reorder , - 1 , num_descriptions ) ;\n"
                ],
                [
                    110,
                    " channel_identities = malloc ( num_descriptions + 1 ) ;\n"
                ],
                [
                    112,
                    " i < num_descriptions ;\n"
                ],
                [
                    123,
                    " channel_reorder [ i ] = cindex ++ ;\n"
                ],
                [
                    128,
                    " ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) {\n"
                ],
                [
                    130,
                    " if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ;\n"
                ],
                [
                    131,
                    " else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ;\n"
                ],
                [
                    134,
                    " channel_identities [ idents ++ ] = 0xff ;\n"
                ],
                [
                    136,
                    " channel_reorder [ i ] = cindex ++ ;\n"
                ],
                [
                    140,
                    " ++ i ) if ( channel_reorder [ i ] != i ) break ;\n"
                ],
                [
                    141,
                    " if ( i == num_descriptions ) {\n"
                ],
                [
                    142,
                    " free ( channel_reorder ) ;\n"
                ],
                [
                    149,
                    " if ( ! idents ) {\n"
                ],
                [
                    150,
                    " free ( channel_identities ) ;\n"
                ],
                [
                    153,
                    " else channel_identities [ idents ] = 0 ;\n"
                ],
                [
                    155,
                    " error_line ( \"layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS\" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;\n"
                ],
                [
                    156,
                    " if ( channel_reorder && num_descriptions <= 8 ) {\n"
                ],
                [
                    168,
                    " if ( debug_logging_mode ) error_line ( \"layout_tag = 0x%08x, so using supplied bitmap of 0x%08x\" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;\n"
                ],
                [
                    172,
                    " ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {\n"
                ],
                [
                    175,
                    " if ( layouts [ i ] . mChannelReorder ) {\n"
                ],
                [
                    176,
                    " channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;\n"
                ],
                [
                    179,
                    " if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;\n"
                ],
                [
                    183,
                    " if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( \"layout_tag 0x%08x not found in table...all channels unassigned\" , caf_channel_layout -> mChannelLayoutTag ) ;\n"
                ],
                [
                    186,
                    " free ( caf_channel_layout ) ;\n"
                ],
                [
                    188,
                    " else if ( ! strncmp ( caf_chunk_header . mChunkType , \"data\" , 4 ) ) {\n"
                ],
                [
                    225,
                    " int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;\n"
                ],
                [
                    226,
                    " char * buff = malloc ( bytes_to_copy ) ;\n"
                ],
                [
                    227,
                    " if ( debug_logging_mode ) error_line ( \"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;\n"
                ],
                [
                    228,
                    " if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) {\n"
                ],
                [
                    230,
                    " free ( buff ) ;\n"
                ],
                [
                    233,
                    " free ( buff ) ;\n"
                ],
                [
                    237,
                    " if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) {\n"
                ],
                [
                    241,
                    " if ( channel_identities ) free ( channel_identities ) ;\n"
                ],
                [
                    242,
                    " if ( channel_layout || channel_reorder ) {\n"
                ],
                [
                    243,
                    " if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) {\n"
                ],
                [
                    247,
                    " if ( channel_reorder ) free ( channel_reorder ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int tmx_check_pretran ( sip_msg_t * msg ) {\n unsigned int chid ;\n unsigned int slotid ;\n int dsize ;\n struct via_param * vbr ;\n str scallid ;\n str scseqmet ;\n str scseqnum ;\n str sftag ;\n str svbranch = {\n NULL , 0 }\n ;\n pretran_t * it ;\n if ( _tmx_ptran_table == NULL ) {\n LM_ERR ( \"pretran hash table not initialized yet\\n\" ) ;\n return - 1 ;\n }\n if ( get_route_type ( ) != REQUEST_ROUTE ) {\n LM_ERR ( \"invalid usage - not in request route\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> first_line . type != SIP_REQUEST ) {\n LM_ERR ( \"invalid usage - not a sip request\\n\" ) ;\n return - 1 ;\n }\n if ( parse_headers ( msg , HDR_FROM_F | HDR_VIA1_F | HDR_CALLID_F | HDR_CSEQ_F , 0 ) < 0 ) {\n LM_ERR ( \"failed to parse required headers\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> cseq == NULL || msg -> cseq -> parsed == NULL ) {\n LM_ERR ( \"failed to parse cseq headers\\n\" ) ;\n return - 1 ;\n }\n if ( get_cseq ( msg ) -> method_id == METHOD_ACK || get_cseq ( msg ) -> method_id == METHOD_CANCEL ) {\n LM_DBG ( \"no pre-transaction management for ACK or CANCEL\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> via1 == 0 ) {\n LM_ERR ( \"failed to get Via header\\n\" ) ;\n return - 1 ;\n }\n if ( parse_from_header ( msg ) < 0 || get_from ( msg ) -> tag_value . len == 0 ) {\n LM_ERR ( \"failed to get From header\\n\" ) ;\n return - 1 ;\n }\n if ( msg -> callid == NULL || msg -> callid -> body . s == NULL ) {\n LM_ERR ( \"failed to parse callid headers\\n\" ) ;\n return - 1 ;\n }\n vbr = msg -> via1 -> branch ;\n scallid = msg -> callid -> body ;\n trim ( & scallid ) ;\n scseqmet = get_cseq ( msg ) -> method ;\n trim ( & scseqmet ) ;\n scseqnum = get_cseq ( msg ) -> number ;\n trim ( & scseqnum ) ;\n sftag = get_from ( msg ) -> tag_value ;\n trim ( & sftag ) ;\n chid = get_hash1_raw ( msg -> callid -> body . s , msg -> callid -> body . len ) ;\n slotid = chid & ( _tmx_ptran_size - 1 ) ;\n if ( unlikely ( _tmx_proc_ptran == NULL ) ) {\n _tmx_proc_ptran = ( pretran_t * ) shm_malloc ( sizeof ( pretran_t ) ) ;\n if ( _tmx_proc_ptran == NULL ) {\n LM_ERR ( \"not enough memory for pretran structure\\n\" ) ;\n return - 1 ;\n }\n memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ;\n _tmx_proc_ptran -> pid = my_pid ( ) ;\n }\n dsize = scallid . len + scseqnum . len + scseqmet . len + sftag . len + 4 ;\n if ( likely ( vbr != NULL ) ) {\n svbranch = vbr -> value ;\n trim ( & svbranch ) ;\n dsize += svbranch . len ;\n }\n if ( dsize < 256 ) dsize = 256 ;\n tmx_pretran_unlink ( ) ;\n if ( dsize > _tmx_proc_ptran -> dbuf . len ) {\n if ( _tmx_proc_ptran -> dbuf . s ) shm_free ( _tmx_proc_ptran -> dbuf . s ) ;\n _tmx_proc_ptran -> dbuf . s = ( char * ) shm_malloc ( dsize ) ;\n if ( _tmx_proc_ptran -> dbuf . s == NULL ) {\n LM_ERR ( \"not enough memory for pretran data\\n\" ) ;\n return - 1 ;\n }\n _tmx_proc_ptran -> dbuf . len = dsize ;\n }\n _tmx_proc_ptran -> hid = chid ;\n _tmx_proc_ptran -> cseqmetid = ( get_cseq ( msg ) ) -> method_id ;\n _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ;\n memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ;\n _tmx_proc_ptran -> callid . len = scallid . len ;\n _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\\0' ;\n _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ;\n memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ;\n _tmx_proc_ptran -> ftag . len = sftag . len ;\n _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\\0' ;\n _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ;\n memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ;\n _tmx_proc_ptran -> cseqnum . len = scseqnum . len ;\n _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\\0' ;\n _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ;\n memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ;\n _tmx_proc_ptran -> cseqmet . len = scseqmet . len ;\n _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\\0' ;\n if ( likely ( vbr != NULL ) ) {\n _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ;\n memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ;\n _tmx_proc_ptran -> vbranch . len = svbranch . len ;\n _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\\0' ;\n }\n else {\n _tmx_proc_ptran -> vbranch . s = NULL ;\n _tmx_proc_ptran -> vbranch . len = 0 ;\n }\n lock_get ( & _tmx_ptran_table [ slotid ] . lock ) ;\n it = _tmx_ptran_table [ slotid ] . plist ;\n tmx_pretran_link_safe ( slotid ) ;\n for ( ;\n it != NULL ;\n it = it -> next ) {\n if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ;\n if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) {\n if ( _tmx_proc_ptran -> vbranch . len != it -> vbranch . len ) continue ;\n if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ;\n if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ;\n }\n if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ;\n if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ;\n LM_DBG ( \"matched another pre-transaction by pid %d for [%.*s]\\n\" , it -> pid , it -> callid . len , it -> callid . s ) ;\n lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ;\n return 1 ;\n }\n lock_release ( & _tmx_ptran_table [ slotid ] . lock ) ;\n return 0 ;\n }",
        "hash": -8503439282031333562,
        "project": "debian",
        "size": 135,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int tmx_check_pretran ( sip_msg_t * msg ) {\n"
                ],
                [
                    51,
                    " scallid = msg -> callid -> body ;\n"
                ],
                [
                    53,
                    " scseqmet = get_cseq ( msg ) -> method ;\n"
                ],
                [
                    55,
                    " scseqnum = get_cseq ( msg ) -> number ;\n"
                ],
                [
                    57,
                    " sftag = get_from ( msg ) -> tag_value ;\n"
                ],
                [
                    72,
                    " svbranch = vbr -> value ;\n"
                ],
                [
                    78,
                    " if ( dsize > _tmx_proc_ptran -> dbuf . len ) {\n"
                ],
                [
                    81,
                    " if ( _tmx_proc_ptran -> dbuf . s == NULL ) {\n"
                ],
                [
                    89,
                    " _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ;\n"
                ],
                [
                    90,
                    " memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ;\n"
                ],
                [
                    91,
                    " _tmx_proc_ptran -> callid . len = scallid . len ;\n"
                ],
                [
                    93,
                    " _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ;\n"
                ],
                [
                    94,
                    " memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ;\n"
                ],
                [
                    95,
                    " _tmx_proc_ptran -> ftag . len = sftag . len ;\n"
                ],
                [
                    97,
                    " _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ;\n"
                ],
                [
                    98,
                    " memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ;\n"
                ],
                [
                    99,
                    " _tmx_proc_ptran -> cseqnum . len = scseqnum . len ;\n"
                ],
                [
                    101,
                    " _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ;\n"
                ],
                [
                    102,
                    " memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ;\n"
                ],
                [
                    103,
                    " _tmx_proc_ptran -> cseqmet . len = scseqmet . len ;\n"
                ],
                [
                    105,
                    " if ( likely ( vbr != NULL ) ) {\n"
                ],
                [
                    106,
                    " _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ;\n"
                ],
                [
                    107,
                    " memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ;\n"
                ],
                [
                    108,
                    " _tmx_proc_ptran -> vbranch . len = svbranch . len ;\n"
                ],
                [
                    122,
                    " if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) {\n"
                ],
                [
                    127,
                    " if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ;\n"
                ],
                [
                    128,
                    " if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int tmx_check_pretran ( sip_msg_t * msg ) {\n"
                ],
                [
                    63,
                    " if ( _tmx_proc_ptran == NULL ) {\n"
                ],
                [
                    67,
                    " memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ;\n"
                ],
                [
                    121,
                    " if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "int tmx_check_pretran ( sip_msg_t * msg ) {\n"
                ],
                [
                    90,
                    " memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ;\n"
                ],
                [
                    92,
                    " _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\\0' ;\n"
                ],
                [
                    94,
                    " memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ;\n"
                ],
                [
                    96,
                    " _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\\0' ;\n"
                ],
                [
                    98,
                    " memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ;\n"
                ],
                [
                    100,
                    " _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\\0' ;\n"
                ],
                [
                    102,
                    " memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ;\n"
                ],
                [
                    104,
                    " _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\\0' ;\n"
                ],
                [
                    109,
                    " _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\\0' ;\n"
                ],
                [
                    119,
                    " it != NULL ;\n"
                ],
                [
                    120,
                    " it = it -> next ) {\n"
                ],
                [
                    121,
                    " if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ;\n"
                ],
                [
                    122,
                    " if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) {\n"
                ],
                [
                    124,
                    " if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ;\n"
                ],
                [
                    125,
                    " if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ;\n"
                ],
                [
                    127,
                    " if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ;\n"
                ],
                [
                    128,
                    " if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ;\n"
                ],
                [
                    129,
                    " LM_DBG ( \"matched another pre-transaction by pid %d for [%.*s]\\n\" , it -> pid , it -> callid . len , it -> callid . s ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int tmx_check_pretran ( sip_msg_t * msg ) {\n"
                ],
                [
                    51,
                    " scallid = msg -> callid -> body ;\n"
                ],
                [
                    53,
                    " scseqmet = get_cseq ( msg ) -> method ;\n"
                ],
                [
                    55,
                    " scseqnum = get_cseq ( msg ) -> number ;\n"
                ],
                [
                    57,
                    " sftag = get_from ( msg ) -> tag_value ;\n"
                ],
                [
                    63,
                    " if ( _tmx_proc_ptran == NULL ) {\n"
                ],
                [
                    67,
                    " memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ;\n"
                ],
                [
                    72,
                    " svbranch = vbr -> value ;\n"
                ],
                [
                    78,
                    " if ( dsize > _tmx_proc_ptran -> dbuf . len ) {\n"
                ],
                [
                    81,
                    " if ( _tmx_proc_ptran -> dbuf . s == NULL ) {\n"
                ],
                [
                    89,
                    " _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ;\n"
                ],
                [
                    90,
                    " memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ;\n"
                ],
                [
                    91,
                    " _tmx_proc_ptran -> callid . len = scallid . len ;\n"
                ],
                [
                    92,
                    " _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\\0' ;\n"
                ],
                [
                    93,
                    " _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ;\n"
                ],
                [
                    94,
                    " memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ;\n"
                ],
                [
                    95,
                    " _tmx_proc_ptran -> ftag . len = sftag . len ;\n"
                ],
                [
                    96,
                    " _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\\0' ;\n"
                ],
                [
                    97,
                    " _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ;\n"
                ],
                [
                    98,
                    " memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ;\n"
                ],
                [
                    99,
                    " _tmx_proc_ptran -> cseqnum . len = scseqnum . len ;\n"
                ],
                [
                    100,
                    " _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\\0' ;\n"
                ],
                [
                    101,
                    " _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ;\n"
                ],
                [
                    102,
                    " memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ;\n"
                ],
                [
                    103,
                    " _tmx_proc_ptran -> cseqmet . len = scseqmet . len ;\n"
                ],
                [
                    104,
                    " _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\\0' ;\n"
                ],
                [
                    105,
                    " if ( likely ( vbr != NULL ) ) {\n"
                ],
                [
                    106,
                    " _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ;\n"
                ],
                [
                    107,
                    " memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ;\n"
                ],
                [
                    108,
                    " _tmx_proc_ptran -> vbranch . len = svbranch . len ;\n"
                ],
                [
                    109,
                    " _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\\0' ;\n"
                ],
                [
                    119,
                    " it != NULL ;\n"
                ],
                [
                    120,
                    " it = it -> next ) {\n"
                ],
                [
                    121,
                    " if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ;\n"
                ],
                [
                    122,
                    " if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) {\n"
                ],
                [
                    124,
                    " if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ;\n"
                ],
                [
                    125,
                    " if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ;\n"
                ],
                [
                    127,
                    " if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ;\n"
                ],
                [
                    128,
                    " if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ;\n"
                ],
                [
                    129,
                    " LM_DBG ( \"matched another pre-transaction by pid %d for [%.*s]\\n\" , it -> pid , it -> callid . len , it -> callid . s ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int encode_msg ( struct sip_msg * msg , char * payload , int len ) {\n int i , j , k , u , request ;\n unsigned short int h ;\n struct hdr_field * hf ;\n struct msg_start * ms ;\n struct sip_uri miuri ;\n char * myerror = NULL ;\n ptrdiff_t diff ;\n if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ;\n if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) {\n myerror = \"in parse_headers\" ;\n goto error ;\n }\n memset ( payload , 0 , len ) ;\n ms = & msg -> first_line ;\n if ( ms -> type == SIP_REQUEST ) request = 1 ;\n else if ( ms -> type == SIP_REPLY ) request = 0 ;\n else {\n myerror = \"message is neither request nor response\" ;\n goto error ;\n }\n if ( request ) {\n for ( h = 0 ;\n h < 32 ;\n j = ( 0x01 << h ) , h ++ ) if ( j & ms -> u . request . method_value ) break ;\n }\n else {\n h = ( unsigned short ) ( ms -> u . reply . statuscode ) ;\n }\n if ( h == 32 ) {\n myerror = \"unknown message type\\n\" ;\n goto error ;\n }\n h = htons ( h ) ;\n memcpy ( payload , & h , 2 ) ;\n h = htons ( ( unsigned short int ) msg -> len ) ;\n memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ;\n if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) {\n myerror = \"body starts before the message (uh ?)\" ;\n goto error ;\n }\n else h = htons ( ( unsigned short int ) diff ) ;\n memcpy ( payload + CONTENT_IDX , & h , 2 ) ;\n payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ;\n payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ;\n payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ;\n payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ;\n payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ;\n if ( request ) {\n if ( parse_uri ( ms -> u . request . uri . s , ms -> u . request . uri . len , & miuri ) < 0 ) {\n LM_ERR ( \"<%.*s>\\n\" , ms -> u . request . uri . len , ms -> u . request . uri . s ) ;\n myerror = \"while parsing the R-URI\" ;\n goto error ;\n }\n if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) {\n myerror = \"ENCODE_MSG: ERROR while encoding the R-URI\" ;\n goto error ;\n }\n payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ;\n k = REQUEST_URI_IDX + 1 + j ;\n }\n else k = REQUEST_URI_IDX ;\n u = k ;\n k ++ ;\n for ( i = 0 , hf = msg -> headers ;\n hf ;\n hf = hf -> next , i ++ ) ;\n i ++ ;\n j = k + 3 * i ;\n for ( i = 0 , hf = msg -> headers ;\n hf ;\n hf = hf -> next , k += 3 ) {\n payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ;\n h = htons ( j ) ;\n memcpy ( & payload [ k + 1 ] , & h , 2 ) ;\n if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) {\n LM_ERR ( \"encoding header %.*s\\n\" , hf -> name . len , hf -> name . s ) ;\n goto error ;\n k -= 3 ;\n continue ;\n }\n j += ( unsigned short int ) i ;\n }\n payload [ u ] = ( unsigned char ) ( ( k - u - 1 ) / 3 ) ;\n j = htons ( j ) ;\n memcpy ( & payload [ k + 1 ] , & j , 2 ) ;\n k += 3 ;\n j = ntohs ( j ) ;\n memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;\n LM_DBG ( \"msglen = %d,msg starts at %d\\n\" , msg -> len , j ) ;\n j = htons ( j ) ;\n memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ;\n return GET_PAY_SIZE ( payload ) ;\n error : LM_ERR ( \"%s\\n\" , myerror ) ;\n return - 1 ;\n }",
        "hash": 3731043152202786975,
        "project": "debian",
        "size": 96,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int encode_msg ( struct sip_msg * msg , char * payload , int len ) {\n"
                ],
                [
                    10,
                    " if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) {\n"
                ],
                [
                    14,
                    " memset ( payload , 0 , len ) ;\n"
                ],
                [
                    30,
                    " if ( h == 32 ) {\n"
                ],
                [
                    34,
                    " h = htons ( h ) ;\n"
                ],
                [
                    35,
                    " memcpy ( payload , & h , 2 ) ;\n"
                ],
                [
                    36,
                    " h = htons ( ( unsigned short int ) msg -> len ) ;\n"
                ],
                [
                    37,
                    " memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ;\n"
                ],
                [
                    38,
                    " if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) {\n"
                ],
                [
                    42,
                    " else h = htons ( ( unsigned short int ) diff ) ;\n"
                ],
                [
                    43,
                    " memcpy ( payload + CONTENT_IDX , & h , 2 ) ;\n"
                ],
                [
                    44,
                    " payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ;\n"
                ],
                [
                    45,
                    " payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ;\n"
                ],
                [
                    46,
                    " payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ;\n"
                ],
                [
                    47,
                    " payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ;\n"
                ],
                [
                    48,
                    " payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ;\n"
                ],
                [
                    55,
                    " if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) {\n"
                ],
                [
                    59,
                    " payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ;\n"
                ],
                [
                    71,
                    " hf ;\n"
                ],
                [
                    73,
                    " payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ;\n"
                ],
                [
                    74,
                    " h = htons ( j ) ;\n"
                ],
                [
                    75,
                    " memcpy ( & payload [ k + 1 ] , & h , 2 ) ;\n"
                ],
                [
                    76,
                    " if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) {\n"
                ],
                [
                    85,
                    " j = htons ( j ) ;\n"
                ],
                [
                    86,
                    " memcpy ( & payload [ k + 1 ] , & j , 2 ) ;\n"
                ],
                [
                    88,
                    " j = ntohs ( j ) ;\n"
                ],
                [
                    89,
                    " memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;\n"
                ],
                [
                    90,
                    " LM_DBG ( \"msglen = %d,msg starts at %d\\n\" , msg -> len , j ) ;\n"
                ],
                [
                    91,
                    " j = htons ( j ) ;\n"
                ],
                [
                    92,
                    " memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ;\n"
                ],
                [
                    93,
                    " return GET_PAY_SIZE ( payload ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int encode_msg ( struct sip_msg * msg , char * payload , int len ) {\n"
                ],
                [
                    9,
                    " if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ;\n"
                ],
                [
                    10,
                    " if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) {\n"
                ],
                [
                    14,
                    " memset ( payload , 0 , len ) ;\n"
                ],
                [
                    35,
                    " memcpy ( payload , & h , 2 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int encode_msg ( struct sip_msg * msg , char * payload , int len ) {\n"
                ],
                [
                    9,
                    " if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ;\n"
                ],
                [
                    10,
                    " if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) {\n"
                ],
                [
                    14,
                    " memset ( payload , 0 , len ) ;\n"
                ],
                [
                    30,
                    " if ( h == 32 ) {\n"
                ],
                [
                    34,
                    " h = htons ( h ) ;\n"
                ],
                [
                    35,
                    " memcpy ( payload , & h , 2 ) ;\n"
                ],
                [
                    36,
                    " h = htons ( ( unsigned short int ) msg -> len ) ;\n"
                ],
                [
                    37,
                    " memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ;\n"
                ],
                [
                    38,
                    " if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) {\n"
                ],
                [
                    42,
                    " else h = htons ( ( unsigned short int ) diff ) ;\n"
                ],
                [
                    43,
                    " memcpy ( payload + CONTENT_IDX , & h , 2 ) ;\n"
                ],
                [
                    44,
                    " payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ;\n"
                ],
                [
                    45,
                    " payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ;\n"
                ],
                [
                    46,
                    " payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ;\n"
                ],
                [
                    47,
                    " payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ;\n"
                ],
                [
                    48,
                    " payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ;\n"
                ],
                [
                    55,
                    " if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) {\n"
                ],
                [
                    59,
                    " payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ;\n"
                ],
                [
                    71,
                    " hf ;\n"
                ],
                [
                    73,
                    " payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ;\n"
                ],
                [
                    74,
                    " h = htons ( j ) ;\n"
                ],
                [
                    75,
                    " memcpy ( & payload [ k + 1 ] , & h , 2 ) ;\n"
                ],
                [
                    76,
                    " if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) {\n"
                ],
                [
                    85,
                    " j = htons ( j ) ;\n"
                ],
                [
                    86,
                    " memcpy ( & payload [ k + 1 ] , & j , 2 ) ;\n"
                ],
                [
                    88,
                    " j = ntohs ( j ) ;\n"
                ],
                [
                    89,
                    " memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;\n"
                ],
                [
                    90,
                    " LM_DBG ( \"msglen = %d,msg starts at %d\\n\" , msg -> len , j ) ;\n"
                ],
                [
                    91,
                    " j = htons ( j ) ;\n"
                ],
                [
                    92,
                    " memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ;\n"
                ],
                [
                    93,
                    " return GET_PAY_SIZE ( payload ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n struct module_state * state = GETSTATE ( self ) ;\n PyObject * value ;\n PyObject * error ;\n switch ( type ) {\n case 1 : {\n double d ;\n if ( max < 8 ) {\n goto invalid ;\n }\n memcpy ( & d , buffer + * position , 8 ) ;\n value = PyFloat_FromDouble ( d ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += 8 ;\n break ;\n }\n case 2 : case 14 : {\n int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ;\n if ( max < value_length ) {\n goto invalid ;\n }\n * position += 4 ;\n value = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , \"strict\" ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += value_length + 1 ;\n break ;\n }\n case 3 : {\n int size ;\n memcpy ( & size , buffer + * position , 4 ) ;\n if ( max < size ) {\n goto invalid ;\n }\n value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ;\n if ( ! value ) {\n return NULL ;\n }\n if ( strcmp ( buffer + * position + 5 , \"$ref\" ) == 0 ) {\n PyObject * dbref ;\n PyObject * collection = PyDict_GetItemString ( value , \"$ref\" ) ;\n PyObject * id = PyDict_GetItemString ( value , \"$id\" ) ;\n PyObject * database = PyDict_GetItemString ( value , \"$db\" ) ;\n Py_INCREF ( collection ) ;\n PyDict_DelItemString ( value , \"$ref\" ) ;\n Py_INCREF ( id ) ;\n PyDict_DelItemString ( value , \"$id\" ) ;\n if ( database == NULL ) {\n database = Py_None ;\n Py_INCREF ( database ) ;\n }\n else {\n Py_INCREF ( database ) ;\n PyDict_DelItemString ( value , \"$db\" ) ;\n }\n dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ;\n Py_DECREF ( value ) ;\n value = dbref ;\n Py_DECREF ( id ) ;\n Py_DECREF ( collection ) ;\n Py_DECREF ( database ) ;\n if ( ! value ) {\n return NULL ;\n }\n }\n * position += size ;\n break ;\n }\n case 4 : {\n int size , end ;\n memcpy ( & size , buffer + * position , 4 ) ;\n if ( max < size ) {\n goto invalid ;\n }\n end = * position + size - 1 ;\n * position += 4 ;\n value = PyList_New ( 0 ) ;\n if ( ! value ) {\n return NULL ;\n }\n while ( * position < end ) {\n PyObject * to_append ;\n int type = ( int ) buffer [ ( * position ) ++ ] ;\n int key_size = strlen ( buffer + * position ) ;\n * position += key_size + 1 ;\n to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ;\n if ( ! to_append ) {\n Py_DECREF ( value ) ;\n return NULL ;\n }\n PyList_Append ( value , to_append ) ;\n Py_DECREF ( to_append ) ;\n }\n ( * position ) ++ ;\n break ;\n }\n case 5 : {\n PyObject * data ;\n PyObject * st ;\n int length , subtype ;\n memcpy ( & length , buffer + * position , 4 ) ;\n if ( max < length ) {\n goto invalid ;\n }\n subtype = ( unsigned char ) buffer [ * position + 4 ] ;\n # if PY_MAJOR_VERSION >= 3 if ( subtype == 0 ) {\n value = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ;\n * position += length + 5 ;\n break ;\n }\n if ( subtype == 2 ) {\n data = PyBytes_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ;\n }\n else {\n data = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ;\n }\n # else if ( subtype == 2 ) {\n data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ;\n }\n else {\n data = PyString_FromStringAndSize ( buffer + * position + 5 , length ) ;\n }\n # endif if ( ! data ) {\n return NULL ;\n }\n if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) {\n PyObject * kwargs ;\n PyObject * args = PyTuple_New ( 0 ) ;\n if ( ! args ) {\n Py_DECREF ( data ) ;\n return NULL ;\n }\n kwargs = PyDict_New ( ) ;\n if ( ! kwargs ) {\n Py_DECREF ( data ) ;\n Py_DECREF ( args ) ;\n return NULL ;\n }\n assert ( length == 16 ) ;\n if ( uuid_subtype == CSHARP_LEGACY ) {\n PyDict_SetItemString ( kwargs , \"bytes_le\" , data ) ;\n }\n else {\n if ( uuid_subtype == JAVA_LEGACY ) {\n char big_endian [ 16 ] ;\n _fix_java ( buffer + * position + 5 , big_endian ) ;\n Py_DECREF ( data ) ;\n # if PY_MAJOR_VERSION >= 3 data = PyBytes_FromStringAndSize ( big_endian , length ) ;\n # else data = PyString_FromStringAndSize ( big_endian , length ) ;\n # endif }\n PyDict_SetItemString ( kwargs , \"bytes\" , data ) ;\n }\n value = PyObject_Call ( state -> UUID , args , kwargs ) ;\n Py_DECREF ( args ) ;\n Py_DECREF ( kwargs ) ;\n Py_DECREF ( data ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += length + 5 ;\n break ;\n }\n # if PY_MAJOR_VERSION >= 3 st = PyLong_FromLong ( subtype ) ;\n # else st = PyInt_FromLong ( subtype ) ;\n # endif if ( ! st ) {\n Py_DECREF ( data ) ;\n return NULL ;\n }\n value = PyObject_CallFunctionObjArgs ( state -> Binary , data , st , NULL ) ;\n Py_DECREF ( st ) ;\n Py_DECREF ( data ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += length + 5 ;\n break ;\n }\n case 6 : case 10 : {\n value = Py_None ;\n Py_INCREF ( value ) ;\n break ;\n }\n case 7 : {\n if ( max < 12 ) {\n goto invalid ;\n }\n # if PY_MAJOR_VERSION >= 3 value = PyObject_CallFunction ( state -> ObjectId , \"y#\" , buffer + * position , 12 ) ;\n # else value = PyObject_CallFunction ( state -> ObjectId , \"s#\" , buffer + * position , 12 ) ;\n # endif if ( ! value ) {\n return NULL ;\n }\n * position += 12 ;\n break ;\n }\n case 8 : {\n value = buffer [ ( * position ) ++ ] ? Py_True : Py_False ;\n Py_INCREF ( value ) ;\n break ;\n }\n case 9 : {\n PyObject * naive ;\n PyObject * replace ;\n PyObject * args ;\n PyObject * kwargs ;\n if ( max < 8 ) {\n goto invalid ;\n }\n naive = datetime_from_millis ( * ( long long * ) ( buffer + * position ) ) ;\n * position += 8 ;\n if ( ! tz_aware ) {\n value = naive ;\n break ;\n }\n if ( ! naive ) {\n return NULL ;\n }\n replace = PyObject_GetAttrString ( naive , \"replace\" ) ;\n Py_DECREF ( naive ) ;\n if ( ! replace ) {\n return NULL ;\n }\n args = PyTuple_New ( 0 ) ;\n if ( ! args ) {\n Py_DECREF ( replace ) ;\n return NULL ;\n }\n kwargs = PyDict_New ( ) ;\n if ( ! kwargs ) {\n Py_DECREF ( replace ) ;\n Py_DECREF ( args ) ;\n return NULL ;\n }\n if ( PyDict_SetItemString ( kwargs , \"tzinfo\" , state -> UTC ) == - 1 ) {\n Py_DECREF ( replace ) ;\n Py_DECREF ( args ) ;\n Py_DECREF ( kwargs ) ;\n return NULL ;\n }\n value = PyObject_Call ( replace , args , kwargs ) ;\n Py_DECREF ( replace ) ;\n Py_DECREF ( args ) ;\n Py_DECREF ( kwargs ) ;\n break ;\n }\n case 11 : {\n PyObject * pattern ;\n int flags_length , flags , i ;\n int pattern_length = strlen ( buffer + * position ) ;\n if ( max < pattern_length ) {\n goto invalid ;\n }\n pattern = PyUnicode_DecodeUTF8 ( buffer + * position , pattern_length , \"strict\" ) ;\n if ( ! pattern ) {\n return NULL ;\n }\n * position += pattern_length + 1 ;\n flags_length = strlen ( buffer + * position ) ;\n if ( max < pattern_length + flags_length ) {\n Py_DECREF ( pattern ) ;\n goto invalid ;\n }\n flags = 0 ;\n for ( i = 0 ;\n i < flags_length ;\n i ++ ) {\n if ( buffer [ * position + i ] == 'i' ) {\n flags |= 2 ;\n }\n else if ( buffer [ * position + i ] == 'l' ) {\n flags |= 4 ;\n }\n else if ( buffer [ * position + i ] == 'm' ) {\n flags |= 8 ;\n }\n else if ( buffer [ * position + i ] == 's' ) {\n flags |= 16 ;\n }\n else if ( buffer [ * position + i ] == 'u' ) {\n flags |= 32 ;\n }\n else if ( buffer [ * position + i ] == 'x' ) {\n flags |= 64 ;\n }\n }\n * position += flags_length + 1 ;\n value = PyObject_CallFunction ( state -> RECompile , \"Oi\" , pattern , flags ) ;\n Py_DECREF ( pattern ) ;\n break ;\n }\n case 12 : {\n int collection_length ;\n PyObject * collection ;\n PyObject * id ;\n * position += 4 ;\n collection_length = strlen ( buffer + * position ) ;\n if ( max < collection_length ) {\n goto invalid ;\n }\n collection = PyUnicode_DecodeUTF8 ( buffer + * position , collection_length , \"strict\" ) ;\n if ( ! collection ) {\n return NULL ;\n }\n * position += collection_length + 1 ;\n if ( max < collection_length + 12 ) {\n Py_DECREF ( collection ) ;\n goto invalid ;\n }\n id = PyObject_CallFunction ( state -> ObjectId , \"s#\" , buffer + * position , 12 ) ;\n if ( ! id ) {\n Py_DECREF ( collection ) ;\n return NULL ;\n }\n * position += 12 ;\n value = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , NULL ) ;\n Py_DECREF ( collection ) ;\n Py_DECREF ( id ) ;\n break ;\n }\n case 13 : {\n PyObject * code ;\n int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ;\n if ( max < value_length ) {\n goto invalid ;\n }\n * position += 4 ;\n code = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , \"strict\" ) ;\n if ( ! code ) {\n return NULL ;\n }\n * position += value_length + 1 ;\n value = PyObject_CallFunctionObjArgs ( state -> Code , code , NULL , NULL ) ;\n Py_DECREF ( code ) ;\n break ;\n }\n case 15 : {\n int code_length , scope_size ;\n PyObject * code ;\n PyObject * scope ;\n * position += 8 ;\n code_length = strlen ( buffer + * position ) ;\n if ( max < 8 + code_length ) {\n goto invalid ;\n }\n code = PyUnicode_DecodeUTF8 ( buffer + * position , code_length , \"strict\" ) ;\n if ( ! code ) {\n return NULL ;\n }\n * position += code_length + 1 ;\n memcpy ( & scope_size , buffer + * position , 4 ) ;\n scope = elements_to_dict ( self , buffer + * position + 4 , scope_size - 5 , ( PyObject * ) & PyDict_Type , tz_aware , uuid_subtype ) ;\n if ( ! scope ) {\n Py_DECREF ( code ) ;\n return NULL ;\n }\n * position += scope_size ;\n value = PyObject_CallFunctionObjArgs ( state -> Code , code , scope , NULL ) ;\n Py_DECREF ( code ) ;\n Py_DECREF ( scope ) ;\n break ;\n }\n case 16 : {\n int i ;\n if ( max < 4 ) {\n goto invalid ;\n }\n memcpy ( & i , buffer + * position , 4 ) ;\n # if PY_MAJOR_VERSION >= 3 value = PyLong_FromLong ( i ) ;\n # else value = PyInt_FromLong ( i ) ;\n # endif if ( ! value ) {\n return NULL ;\n }\n * position += 4 ;\n break ;\n }\n case 17 : {\n unsigned int time , inc ;\n if ( max < 8 ) {\n goto invalid ;\n }\n memcpy ( & inc , buffer + * position , 4 ) ;\n memcpy ( & time , buffer + * position + 4 , 4 ) ;\n value = PyObject_CallFunction ( state -> Timestamp , \"II\" , time , inc ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += 8 ;\n break ;\n }\n case 18 : {\n long long ll ;\n if ( max < 8 ) {\n goto invalid ;\n }\n memcpy ( & ll , buffer + * position , 8 ) ;\n value = PyLong_FromLongLong ( ll ) ;\n if ( ! value ) {\n return NULL ;\n }\n * position += 8 ;\n break ;\n }\n case - 1 : {\n value = PyObject_CallFunctionObjArgs ( state -> MinKey , NULL ) ;\n break ;\n }\n case 127 : {\n value = PyObject_CallFunctionObjArgs ( state -> MaxKey , NULL ) ;\n break ;\n }\n default : {\n PyObject * InvalidDocument = _error ( \"InvalidDocument\" ) ;\n PyErr_SetString ( InvalidDocument , \"no c decoder for this type yet\" ) ;\n Py_DECREF ( InvalidDocument ) ;\n return NULL ;\n }\n }\n return value ;\n invalid : error = _error ( \"InvalidBSON\" ) ;\n PyErr_SetNone ( error ) ;\n Py_DECREF ( error ) ;\n return NULL ;\n }",
        "hash": -5689214734378699681,
        "project": "debian",
        "size": 425,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n"
                ],
                [
                    5,
                    " switch ( type ) {\n"
                ],
                [
                    11,
                    " memcpy ( & d , buffer + * position , 8 ) ;\n"
                ],
                [
                    12,
                    " value = PyFloat_FromDouble ( d ) ;\n"
                ],
                [
                    34,
                    " memcpy ( & size , buffer + * position , 4 ) ;\n"
                ],
                [
                    35,
                    " if ( max < size ) {\n"
                ],
                [
                    38,
                    " value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ;\n"
                ],
                [
                    69,
                    " * position += size ;\n"
                ],
                [
                    74,
                    " memcpy ( & size , buffer + * position , 4 ) ;\n"
                ],
                [
                    75,
                    " if ( max < size ) {\n"
                ],
                [
                    78,
                    " end = * position + size - 1 ;\n"
                ],
                [
                    104,
                    " memcpy ( & length , buffer + * position , 4 ) ;\n"
                ],
                [
                    105,
                    " if ( max < length ) {\n"
                ],
                [
                    121,
                    " data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ;\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n"
                ],
                [
                    39,
                    " if ( ! value ) {\n"
                ],
                [
                    42,
                    " if ( strcmp ( buffer + * position + 5 , \"$ref\" ) == 0 ) {\n"
                ],
                [
                    44,
                    " PyObject * collection = PyDict_GetItemString ( value , \"$ref\" ) ;\n"
                ],
                [
                    45,
                    " PyObject * id = PyDict_GetItemString ( value , \"$id\" ) ;\n"
                ],
                [
                    46,
                    " PyObject * database = PyDict_GetItemString ( value , \"$db\" ) ;\n"
                ],
                [
                    47,
                    " Py_INCREF ( collection ) ;\n"
                ],
                [
                    48,
                    " PyDict_DelItemString ( value , \"$ref\" ) ;\n"
                ],
                [
                    49,
                    " Py_INCREF ( id ) ;\n"
                ],
                [
                    50,
                    " PyDict_DelItemString ( value , \"$id\" ) ;\n"
                ],
                [
                    51,
                    " if ( database == NULL ) {\n"
                ],
                [
                    59,
                    " dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ;\n"
                ],
                [
                    60,
                    " Py_DECREF ( value ) ;\n"
                ],
                [
                    61,
                    " value = dbref ;\n"
                ],
                [
                    62,
                    " Py_DECREF ( id ) ;\n"
                ],
                [
                    63,
                    " Py_DECREF ( collection ) ;\n"
                ],
                [
                    64,
                    " Py_DECREF ( database ) ;\n"
                ],
                [
                    65,
                    " if ( ! value ) {\n"
                ],
                [
                    69,
                    " * position += size ;\n"
                ],
                [
                    129,
                    " if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) {\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n"
                ],
                [
                    84,
                    " while ( * position < end ) {\n"
                ],
                [
                    86,
                    " int type = ( int ) buffer [ ( * position ) ++ ] ;\n"
                ],
                [
                    87,
                    " int key_size = strlen ( buffer + * position ) ;\n"
                ],
                [
                    88,
                    " * position += key_size + 1 ;\n"
                ],
                [
                    89,
                    " to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n"
                ],
                [
                    5,
                    " switch ( type ) {\n"
                ],
                [
                    11,
                    " memcpy ( & d , buffer + * position , 8 ) ;\n"
                ],
                [
                    12,
                    " value = PyFloat_FromDouble ( d ) ;\n"
                ],
                [
                    34,
                    " memcpy ( & size , buffer + * position , 4 ) ;\n"
                ],
                [
                    35,
                    " if ( max < size ) {\n"
                ],
                [
                    38,
                    " value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ;\n"
                ],
                [
                    39,
                    " if ( ! value ) {\n"
                ],
                [
                    42,
                    " if ( strcmp ( buffer + * position + 5 , \"$ref\" ) == 0 ) {\n"
                ],
                [
                    44,
                    " PyObject * collection = PyDict_GetItemString ( value , \"$ref\" ) ;\n"
                ],
                [
                    45,
                    " PyObject * id = PyDict_GetItemString ( value , \"$id\" ) ;\n"
                ],
                [
                    46,
                    " PyObject * database = PyDict_GetItemString ( value , \"$db\" ) ;\n"
                ],
                [
                    47,
                    " Py_INCREF ( collection ) ;\n"
                ],
                [
                    48,
                    " PyDict_DelItemString ( value , \"$ref\" ) ;\n"
                ],
                [
                    49,
                    " Py_INCREF ( id ) ;\n"
                ],
                [
                    50,
                    " PyDict_DelItemString ( value , \"$id\" ) ;\n"
                ],
                [
                    51,
                    " if ( database == NULL ) {\n"
                ],
                [
                    59,
                    " dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ;\n"
                ],
                [
                    60,
                    " Py_DECREF ( value ) ;\n"
                ],
                [
                    61,
                    " value = dbref ;\n"
                ],
                [
                    62,
                    " Py_DECREF ( id ) ;\n"
                ],
                [
                    63,
                    " Py_DECREF ( collection ) ;\n"
                ],
                [
                    64,
                    " Py_DECREF ( database ) ;\n"
                ],
                [
                    65,
                    " if ( ! value ) {\n"
                ],
                [
                    69,
                    " * position += size ;\n"
                ],
                [
                    74,
                    " memcpy ( & size , buffer + * position , 4 ) ;\n"
                ],
                [
                    75,
                    " if ( max < size ) {\n"
                ],
                [
                    78,
                    " end = * position + size - 1 ;\n"
                ],
                [
                    84,
                    " while ( * position < end ) {\n"
                ],
                [
                    86,
                    " int type = ( int ) buffer [ ( * position ) ++ ] ;\n"
                ],
                [
                    87,
                    " int key_size = strlen ( buffer + * position ) ;\n"
                ],
                [
                    88,
                    " * position += key_size + 1 ;\n"
                ],
                [
                    89,
                    " to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ;\n"
                ],
                [
                    104,
                    " memcpy ( & length , buffer + * position , 4 ) ;\n"
                ],
                [
                    105,
                    " if ( max < length ) {\n"
                ],
                [
                    121,
                    " data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ;\n"
                ],
                [
                    129,
                    " if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) {\n AVCodecParameters * par = stream -> codecpar ;\n if ( ! strcmp ( attr , \"packetization-mode\" ) ) {\n av_log ( s , AV_LOG_DEBUG , \"RTP Packetization Mode: %d\\n\" , atoi ( value ) ) ;\n h264_data -> packetization_mode = atoi ( value ) ;\n if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , \"Interleaved RTP mode is not supported yet.\\n\" ) ;\n }\n else if ( ! strcmp ( attr , \"profile-level-id\" ) ) {\n if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ;\n }\n else if ( ! strcmp ( attr , \"sprop-parameter-sets\" ) ) {\n int ret ;\n if ( value [ strlen ( value ) - 1 ] == ',' ) {\n av_log ( s , AV_LOG_WARNING , \"Missing PPS in sprop-parameter-sets, ignoring\\n\" ) ;\n return 0 ;\n }\n par -> extradata_size = 0 ;\n av_freep ( & par -> extradata ) ;\n ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ;\n av_log ( s , AV_LOG_DEBUG , \"Extradata set to %p (size: %d)\\n\" , par -> extradata , par -> extradata_size ) ;\n return ret ;\n }\n return 0 ;\n }",
        "hash": 3968979668594799806,
        "project": "debian",
        "size": 24,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) {\n"
                ],
                [
                    3,
                    " if ( ! strcmp ( attr , \"packetization-mode\" ) ) {\n"
                ],
                [
                    4,
                    " av_log ( s , AV_LOG_DEBUG , \"RTP Packetization Mode: %d\\n\" , atoi ( value ) ) ;\n"
                ],
                [
                    5,
                    " h264_data -> packetization_mode = atoi ( value ) ;\n"
                ],
                [
                    6,
                    " if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , \"Interleaved RTP mode is not supported yet.\\n\" ) ;\n"
                ],
                [
                    8,
                    " else if ( ! strcmp ( attr , \"profile-level-id\" ) ) {\n"
                ],
                [
                    9,
                    " if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ;\n"
                ],
                [
                    11,
                    " else if ( ! strcmp ( attr , \"sprop-parameter-sets\" ) ) {\n"
                ],
                [
                    13,
                    " if ( value [ strlen ( value ) - 1 ] == ',' ) {\n"
                ],
                [
                    23,
                    " return 0 ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) {\n"
                ],
                [
                    8,
                    " else if ( ! strcmp ( attr , \"profile-level-id\" ) ) {\n"
                ],
                [
                    9,
                    " if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ;\n"
                ],
                [
                    11,
                    " else if ( ! strcmp ( attr , \"sprop-parameter-sets\" ) ) {\n"
                ],
                [
                    13,
                    " if ( value [ strlen ( value ) - 1 ] == ',' ) {\n"
                ],
                [
                    14,
                    " av_log ( s , AV_LOG_WARNING , \"Missing PPS in sprop-parameter-sets, ignoring\\n\" ) ;\n"
                ],
                [
                    15,
                    " return 0 ;\n"
                ],
                [
                    17,
                    " par -> extradata_size = 0 ;\n"
                ],
                [
                    18,
                    " av_freep ( & par -> extradata ) ;\n"
                ],
                [
                    19,
                    " ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ;\n"
                ],
                [
                    20,
                    " av_log ( s , AV_LOG_DEBUG , \"Extradata set to %p (size: %d)\\n\" , par -> extradata , par -> extradata_size ) ;\n"
                ],
                [
                    21,
                    " return ret ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) {\n"
                ],
                [
                    3,
                    " if ( ! strcmp ( attr , \"packetization-mode\" ) ) {\n"
                ],
                [
                    4,
                    " av_log ( s , AV_LOG_DEBUG , \"RTP Packetization Mode: %d\\n\" , atoi ( value ) ) ;\n"
                ],
                [
                    5,
                    " h264_data -> packetization_mode = atoi ( value ) ;\n"
                ],
                [
                    6,
                    " if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , \"Interleaved RTP mode is not supported yet.\\n\" ) ;\n"
                ],
                [
                    8,
                    " else if ( ! strcmp ( attr , \"profile-level-id\" ) ) {\n"
                ],
                [
                    9,
                    " if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ;\n"
                ],
                [
                    11,
                    " else if ( ! strcmp ( attr , \"sprop-parameter-sets\" ) ) {\n"
                ],
                [
                    13,
                    " if ( value [ strlen ( value ) - 1 ] == ',' ) {\n"
                ],
                [
                    14,
                    " av_log ( s , AV_LOG_WARNING , \"Missing PPS in sprop-parameter-sets, ignoring\\n\" ) ;\n"
                ],
                [
                    15,
                    " return 0 ;\n"
                ],
                [
                    17,
                    " par -> extradata_size = 0 ;\n"
                ],
                [
                    18,
                    " av_freep ( & par -> extradata ) ;\n"
                ],
                [
                    19,
                    " ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ;\n"
                ],
                [
                    20,
                    " av_log ( s , AV_LOG_DEBUG , \"Extradata set to %p (size: %d)\\n\" , par -> extradata , par -> extradata_size ) ;\n"
                ],
                [
                    21,
                    " return ret ;\n"
                ],
                [
                    23,
                    " return 0 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static bool on_accept ( private_stroke_socket_t * this , stream_t * stream ) {\n stroke_msg_t * msg ;\n uint16_t len ;\n FILE * out ;\n if ( ! stream -> read_all ( stream , & len , sizeof ( len ) ) ) {\n if ( errno != EWOULDBLOCK ) {\n DBG1 ( DBG_CFG , \"reading length of stroke message failed: %s\" , strerror ( errno ) ) ;\n }\n return FALSE ;\n }\n msg = malloc ( len + 1 ) ;\n msg -> length = len ;\n if ( ! stream -> read_all ( stream , ( char * ) msg + sizeof ( len ) , len - sizeof ( len ) ) ) {\n if ( errno != EWOULDBLOCK ) {\n DBG1 ( DBG_CFG , \"reading stroke message failed: %s\" , strerror ( errno ) ) ;\n }\n free ( msg ) ;\n return FALSE ;\n }\n ( ( char * ) msg ) [ len ] = '\\0' ;\n DBG3 ( DBG_CFG , \"stroke message %b\" , ( void * ) msg , len ) ;\n out = stream -> get_file ( stream ) ;\n if ( ! out ) {\n DBG1 ( DBG_CFG , \"creating stroke output stream failed\" ) ;\n free ( msg ) ;\n return FALSE ;\n }\n switch ( msg -> type ) {\n case STR_INITIATE : stroke_initiate ( this , msg , out ) ;\n break ;\n case STR_ROUTE : stroke_route ( this , msg , out ) ;\n break ;\n case STR_UNROUTE : stroke_unroute ( this , msg , out ) ;\n break ;\n case STR_TERMINATE : stroke_terminate ( this , msg , out ) ;\n break ;\n case STR_TERMINATE_SRCIP : stroke_terminate_srcip ( this , msg , out ) ;\n break ;\n case STR_REKEY : stroke_rekey ( this , msg , out ) ;\n break ;\n case STR_STATUS : stroke_status ( this , msg , out , FALSE , TRUE ) ;\n break ;\n case STR_STATUS_ALL : stroke_status ( this , msg , out , TRUE , TRUE ) ;\n break ;\n case STR_STATUS_ALL_NOBLK : stroke_status ( this , msg , out , TRUE , FALSE ) ;\n break ;\n case STR_ADD_CONN : stroke_add_conn ( this , msg ) ;\n break ;\n case STR_DEL_CONN : stroke_del_conn ( this , msg ) ;\n break ;\n case STR_ADD_CA : stroke_add_ca ( this , msg , out ) ;\n break ;\n case STR_DEL_CA : stroke_del_ca ( this , msg , out ) ;\n break ;\n case STR_LOGLEVEL : stroke_loglevel ( this , msg , out ) ;\n break ;\n case STR_CONFIG : stroke_config ( this , msg , out ) ;\n break ;\n case STR_LIST : stroke_list ( this , msg , out ) ;\n break ;\n case STR_REREAD : stroke_reread ( this , msg , out ) ;\n break ;\n case STR_PURGE : stroke_purge ( this , msg , out ) ;\n break ;\n case STR_EXPORT : stroke_export ( this , msg , out ) ;\n break ;\n case STR_LEASES : stroke_leases ( this , msg , out ) ;\n break ;\n case STR_MEMUSAGE : stroke_memusage ( this , msg , out ) ;\n break ;\n case STR_USER_CREDS : stroke_user_creds ( this , msg , out ) ;\n break ;\n case STR_COUNTERS : stroke_counters ( this , msg , out ) ;\n break ;\n default : DBG1 ( DBG_CFG , \"received unknown stroke\" ) ;\n break ;\n }\n free ( msg ) ;\n fclose ( out ) ;\n return FALSE ;\n }",
        "hash": -5260094338219889901,
        "project": "debian",
        "size": 81,
        "slice": {
            "strerror": [
                [
                    1,
                    "static bool on_accept ( private_stroke_socket_t * this , stream_t * stream ) {\n"
                ],
                [
                    6,
                    " if ( errno != EWOULDBLOCK ) {\n"
                ],
                [
                    7,
                    " DBG1 ( DBG_CFG , \"reading length of stroke message failed: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    14,
                    " if ( errno != EWOULDBLOCK ) {\n"
                ],
                [
                    15,
                    " DBG1 ( DBG_CFG , \"reading stroke message failed: %s\" , strerror ( errno ) ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static bool on_accept ( private_stroke_socket_t * this , stream_t * stream ) {\n"
                ],
                [
                    5,
                    " if ( ! stream -> read_all ( stream , & len , sizeof ( len ) ) ) {\n"
                ],
                [
                    11,
                    " msg = malloc ( len + 1 ) ;\n"
                ],
                [
                    13,
                    " if ( ! stream -> read_all ( stream , ( char * ) msg + sizeof ( len ) , len - sizeof ( len ) ) ) {\n"
                ],
                [
                    17,
                    " free ( msg ) ;\n"
                ],
                [
                    20,
                    " ( ( char * ) msg ) [ len ] = '\\0' ;\n"
                ],
                [
                    21,
                    " DBG3 ( DBG_CFG , \"stroke message %b\" , ( void * ) msg , len ) ;\n"
                ],
                [
                    25,
                    " free ( msg ) ;\n"
                ],
                [
                    29,
                    " case STR_INITIATE : stroke_initiate ( this , msg , out ) ;\n"
                ],
                [
                    31,
                    " case STR_ROUTE : stroke_route ( this , msg , out ) ;\n"
                ],
                [
                    33,
                    " case STR_UNROUTE : stroke_unroute ( this , msg , out ) ;\n"
                ],
                [
                    35,
                    " case STR_TERMINATE : stroke_terminate ( this , msg , out ) ;\n"
                ],
                [
                    37,
                    " case STR_TERMINATE_SRCIP : stroke_terminate_srcip ( this , msg , out ) ;\n"
                ],
                [
                    39,
                    " case STR_REKEY : stroke_rekey ( this , msg , out ) ;\n"
                ],
                [
                    41,
                    " case STR_STATUS : stroke_status ( this , msg , out , FALSE , TRUE ) ;\n"
                ],
                [
                    43,
                    " case STR_STATUS_ALL : stroke_status ( this , msg , out , TRUE , TRUE ) ;\n"
                ],
                [
                    45,
                    " case STR_STATUS_ALL_NOBLK : stroke_status ( this , msg , out , TRUE , FALSE ) ;\n"
                ],
                [
                    47,
                    " case STR_ADD_CONN : stroke_add_conn ( this , msg ) ;\n"
                ],
                [
                    49,
                    " case STR_DEL_CONN : stroke_del_conn ( this , msg ) ;\n"
                ],
                [
                    51,
                    " case STR_ADD_CA : stroke_add_ca ( this , msg , out ) ;\n"
                ],
                [
                    53,
                    " case STR_DEL_CA : stroke_del_ca ( this , msg , out ) ;\n"
                ],
                [
                    55,
                    " case STR_LOGLEVEL : stroke_loglevel ( this , msg , out ) ;\n"
                ],
                [
                    57,
                    " case STR_CONFIG : stroke_config ( this , msg , out ) ;\n"
                ],
                [
                    59,
                    " case STR_LIST : stroke_list ( this , msg , out ) ;\n"
                ],
                [
                    61,
                    " case STR_REREAD : stroke_reread ( this , msg , out ) ;\n"
                ],
                [
                    63,
                    " case STR_PURGE : stroke_purge ( this , msg , out ) ;\n"
                ],
                [
                    65,
                    " case STR_EXPORT : stroke_export ( this , msg , out ) ;\n"
                ],
                [
                    67,
                    " case STR_LEASES : stroke_leases ( this , msg , out ) ;\n"
                ],
                [
                    69,
                    " case STR_MEMUSAGE : stroke_memusage ( this , msg , out ) ;\n"
                ],
                [
                    71,
                    " case STR_USER_CREDS : stroke_user_creds ( this , msg , out ) ;\n"
                ],
                [
                    73,
                    " case STR_COUNTERS : stroke_counters ( this , msg , out ) ;\n"
                ],
                [
                    78,
                    " free ( msg ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static bool on_accept ( private_stroke_socket_t * this , stream_t * stream ) {\n"
                ],
                [
                    11,
                    " msg = malloc ( len + 1 ) ;\n"
                ],
                [
                    12,
                    " msg -> length = len ;\n"
                ],
                [
                    13,
                    " if ( ! stream -> read_all ( stream , ( char * ) msg + sizeof ( len ) , len - sizeof ( len ) ) ) {\n"
                ],
                [
                    17,
                    " free ( msg ) ;\n"
                ],
                [
                    23,
                    " if ( ! out ) {\n"
                ],
                [
                    25,
                    " free ( msg ) ;\n"
                ],
                [
                    29,
                    " case STR_INITIATE : stroke_initiate ( this , msg , out ) ;\n"
                ],
                [
                    31,
                    " case STR_ROUTE : stroke_route ( this , msg , out ) ;\n"
                ],
                [
                    33,
                    " case STR_UNROUTE : stroke_unroute ( this , msg , out ) ;\n"
                ],
                [
                    35,
                    " case STR_TERMINATE : stroke_terminate ( this , msg , out ) ;\n"
                ],
                [
                    37,
                    " case STR_TERMINATE_SRCIP : stroke_terminate_srcip ( this , msg , out ) ;\n"
                ],
                [
                    39,
                    " case STR_REKEY : stroke_rekey ( this , msg , out ) ;\n"
                ],
                [
                    41,
                    " case STR_STATUS : stroke_status ( this , msg , out , FALSE , TRUE ) ;\n"
                ],
                [
                    43,
                    " case STR_STATUS_ALL : stroke_status ( this , msg , out , TRUE , TRUE ) ;\n"
                ],
                [
                    45,
                    " case STR_STATUS_ALL_NOBLK : stroke_status ( this , msg , out , TRUE , FALSE ) ;\n"
                ],
                [
                    47,
                    " case STR_ADD_CONN : stroke_add_conn ( this , msg ) ;\n"
                ],
                [
                    49,
                    " case STR_DEL_CONN : stroke_del_conn ( this , msg ) ;\n"
                ],
                [
                    51,
                    " case STR_ADD_CA : stroke_add_ca ( this , msg , out ) ;\n"
                ],
                [
                    53,
                    " case STR_DEL_CA : stroke_del_ca ( this , msg , out ) ;\n"
                ],
                [
                    55,
                    " case STR_LOGLEVEL : stroke_loglevel ( this , msg , out ) ;\n"
                ],
                [
                    57,
                    " case STR_CONFIG : stroke_config ( this , msg , out ) ;\n"
                ],
                [
                    59,
                    " case STR_LIST : stroke_list ( this , msg , out ) ;\n"
                ],
                [
                    61,
                    " case STR_REREAD : stroke_reread ( this , msg , out ) ;\n"
                ],
                [
                    63,
                    " case STR_PURGE : stroke_purge ( this , msg , out ) ;\n"
                ],
                [
                    65,
                    " case STR_EXPORT : stroke_export ( this , msg , out ) ;\n"
                ],
                [
                    67,
                    " case STR_LEASES : stroke_leases ( this , msg , out ) ;\n"
                ],
                [
                    69,
                    " case STR_MEMUSAGE : stroke_memusage ( this , msg , out ) ;\n"
                ],
                [
                    71,
                    " case STR_USER_CREDS : stroke_user_creds ( this , msg , out ) ;\n"
                ],
                [
                    73,
                    " case STR_COUNTERS : stroke_counters ( this , msg , out ) ;\n"
                ],
                [
                    78,
                    " free ( msg ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static bool on_accept ( private_stroke_socket_t * this , stream_t * stream ) {\n"
                ],
                [
                    5,
                    " if ( ! stream -> read_all ( stream , & len , sizeof ( len ) ) ) {\n"
                ],
                [
                    6,
                    " if ( errno != EWOULDBLOCK ) {\n"
                ],
                [
                    7,
                    " DBG1 ( DBG_CFG , \"reading length of stroke message failed: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    11,
                    " msg = malloc ( len + 1 ) ;\n"
                ],
                [
                    12,
                    " msg -> length = len ;\n"
                ],
                [
                    13,
                    " if ( ! stream -> read_all ( stream , ( char * ) msg + sizeof ( len ) , len - sizeof ( len ) ) ) {\n"
                ],
                [
                    14,
                    " if ( errno != EWOULDBLOCK ) {\n"
                ],
                [
                    15,
                    " DBG1 ( DBG_CFG , \"reading stroke message failed: %s\" , strerror ( errno ) ) ;\n"
                ],
                [
                    17,
                    " free ( msg ) ;\n"
                ],
                [
                    20,
                    " ( ( char * ) msg ) [ len ] = '\\0' ;\n"
                ],
                [
                    21,
                    " DBG3 ( DBG_CFG , \"stroke message %b\" , ( void * ) msg , len ) ;\n"
                ],
                [
                    23,
                    " if ( ! out ) {\n"
                ],
                [
                    25,
                    " free ( msg ) ;\n"
                ],
                [
                    29,
                    " case STR_INITIATE : stroke_initiate ( this , msg , out ) ;\n"
                ],
                [
                    31,
                    " case STR_ROUTE : stroke_route ( this , msg , out ) ;\n"
                ],
                [
                    33,
                    " case STR_UNROUTE : stroke_unroute ( this , msg , out ) ;\n"
                ],
                [
                    35,
                    " case STR_TERMINATE : stroke_terminate ( this , msg , out ) ;\n"
                ],
                [
                    37,
                    " case STR_TERMINATE_SRCIP : stroke_terminate_srcip ( this , msg , out ) ;\n"
                ],
                [
                    39,
                    " case STR_REKEY : stroke_rekey ( this , msg , out ) ;\n"
                ],
                [
                    41,
                    " case STR_STATUS : stroke_status ( this , msg , out , FALSE , TRUE ) ;\n"
                ],
                [
                    43,
                    " case STR_STATUS_ALL : stroke_status ( this , msg , out , TRUE , TRUE ) ;\n"
                ],
                [
                    45,
                    " case STR_STATUS_ALL_NOBLK : stroke_status ( this , msg , out , TRUE , FALSE ) ;\n"
                ],
                [
                    47,
                    " case STR_ADD_CONN : stroke_add_conn ( this , msg ) ;\n"
                ],
                [
                    49,
                    " case STR_DEL_CONN : stroke_del_conn ( this , msg ) ;\n"
                ],
                [
                    51,
                    " case STR_ADD_CA : stroke_add_ca ( this , msg , out ) ;\n"
                ],
                [
                    53,
                    " case STR_DEL_CA : stroke_del_ca ( this , msg , out ) ;\n"
                ],
                [
                    55,
                    " case STR_LOGLEVEL : stroke_loglevel ( this , msg , out ) ;\n"
                ],
                [
                    57,
                    " case STR_CONFIG : stroke_config ( this , msg , out ) ;\n"
                ],
                [
                    59,
                    " case STR_LIST : stroke_list ( this , msg , out ) ;\n"
                ],
                [
                    61,
                    " case STR_REREAD : stroke_reread ( this , msg , out ) ;\n"
                ],
                [
                    63,
                    " case STR_PURGE : stroke_purge ( this , msg , out ) ;\n"
                ],
                [
                    65,
                    " case STR_EXPORT : stroke_export ( this , msg , out ) ;\n"
                ],
                [
                    67,
                    " case STR_LEASES : stroke_leases ( this , msg , out ) ;\n"
                ],
                [
                    69,
                    " case STR_MEMUSAGE : stroke_memusage ( this , msg , out ) ;\n"
                ],
                [
                    71,
                    " case STR_USER_CREDS : stroke_user_creds ( this , msg , out ) ;\n"
                ],
                [
                    73,
                    " case STR_COUNTERS : stroke_counters ( this , msg , out ) ;\n"
                ],
                [
                    78,
                    " free ( msg ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void short_usage ( FILE * f ) {\n short_usage_sub ( f ) ;\n fprintf ( f , \"For more options, use %s --help\\n\" , my_progname_short ) ;\n }",
        "hash": 6667142528452941476,
        "project": "debian",
        "size": 4,
        "slice": {
            "fprintf": [
                [
                    1,
                    "static void short_usage ( FILE * f ) {\n"
                ],
                [
                    2,
                    " short_usage_sub ( f ) ;\n"
                ],
                [
                    3,
                    " fprintf ( f , \"For more options, use %s --help\\n\" , my_progname_short ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void short_usage ( FILE * f ) {\n"
                ],
                [
                    2,
                    " short_usage_sub ( f ) ;\n"
                ],
                [
                    3,
                    " fprintf ( f , \"For more options, use %s --help\\n\" , my_progname_short ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static my_bool get_view_structure ( char * table , char * db ) {\n MYSQL_RES * table_res ;\n MYSQL_ROW row ;\n MYSQL_FIELD * field ;\n char * result_table , * opt_quoted_table ;\n char table_buff [ NAME_LEN * 2 + 3 ] ;\n char table_buff2 [ NAME_LEN * 2 + 3 ] ;\n char query [ QUERY_LENGTH ] ;\n FILE * sql_file = md_result_file ;\n DBUG_ENTER ( \"get_view_structure\" ) ;\n if ( opt_no_create_info ) DBUG_RETURN ( 0 ) ;\n verbose_msg ( \"-- Retrieving view structure for table %s...\\n\" , table ) ;\n # ifdef NOT_REALLY_USED_YET dynstr_append_checked ( & insert_pat , \"SET SQL_QUOTE_SHOW_CREATE=\" ) ;\n dynstr_append_checked ( & insert_pat , ( opt_quoted || opt_keywords ) ? \"1\" : \"0\" ) ;\n # endif result_table = quote_name ( table , table_buff , 1 ) ;\n opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n if ( switch_character_set_results ( mysql , \"binary\" ) ) DBUG_RETURN ( 1 ) ;\n my_snprintf ( query , sizeof ( query ) , \"SHOW CREATE TABLE %s\" , result_table ) ;\n if ( mysql_query_with_error_report ( mysql , & table_res , query ) ) {\n switch_character_set_results ( mysql , default_charset ) ;\n DBUG_RETURN ( 0 ) ;\n }\n field = mysql_fetch_field_direct ( table_res , 0 ) ;\n if ( strcmp ( field -> name , \"View\" ) != 0 ) {\n mysql_free_result ( table_res ) ;\n switch_character_set_results ( mysql , default_charset ) ;\n verbose_msg ( \"-- It's base table, skipped\\n\" ) ;\n DBUG_RETURN ( 0 ) ;\n }\n if ( path ) {\n if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) {\n mysql_free_result ( table_res ) ;\n DBUG_RETURN ( 1 ) ;\n }\n write_header ( sql_file , db ) ;\n }\n print_comment ( sql_file , 0 , \"\\n--\\n-- Final view structure for view %s\\n--\\n\\n\" , result_table ) ;\n fprintf ( sql_file , \"/*!50001 DROP TABLE IF EXISTS %s*/;\n\\n\" , opt_quoted_table ) ;\n if ( opt_drop ) {\n fprintf ( sql_file , \"/*!50001 DROP VIEW IF EXISTS %s*/;\n\\n\" , opt_quoted_table ) ;\n check_io ( sql_file ) ;\n }\n my_snprintf ( query , sizeof ( query ) , \"SELECT CHECK_OPTION, DEFINER, SECURITY_TYPE, \" \" CHARACTER_SET_CLIENT, COLLATION_CONNECTION \" \"FROM information_schema.views \" \"WHERE table_name=\\\"%s\\\" AND table_schema=\\\"%s\\\"\" , table , db ) ;\n if ( mysql_query ( mysql , query ) ) {\n row = mysql_fetch_row ( table_res ) ;\n fprintf ( sql_file , \"/*!50001 %s */;\n\\n\" , row [ 1 ] ) ;\n check_io ( sql_file ) ;\n mysql_free_result ( table_res ) ;\n }\n else {\n char * ptr ;\n ulong * lengths ;\n char search_buf [ 256 ] , replace_buf [ 256 ] ;\n ulong search_len , replace_len ;\n DYNAMIC_STRING ds_view ;\n row = mysql_fetch_row ( table_res ) ;\n lengths = mysql_fetch_lengths ( table_res ) ;\n init_dynamic_string_checked ( & ds_view , row [ 1 ] , lengths [ 1 ] + 1 , 1024 ) ;\n mysql_free_result ( table_res ) ;\n if ( ! ( table_res = mysql_store_result ( mysql ) ) || ! ( row = mysql_fetch_row ( table_res ) ) ) {\n if ( table_res ) mysql_free_result ( table_res ) ;\n dynstr_free ( & ds_view ) ;\n DB_error ( mysql , \"when trying to save the result of SHOW CREATE TABLE in ds_view.\" ) ;\n DBUG_RETURN ( 1 ) ;\n }\n lengths = mysql_fetch_lengths ( table_res ) ;\n if ( strcmp ( row [ 0 ] , \"NONE\" ) ) {\n ptr = search_buf ;\n search_len = ( ulong ) ( strxmov ( ptr , \"WITH \" , row [ 0 ] , \" CHECK OPTION\" , NullS ) - ptr ) ;\n ptr = replace_buf ;\n replace_len = ( ulong ) ( strxmov ( ptr , \"*/\\n/*!50002 WITH \" , row [ 0 ] , \" CHECK OPTION\" , NullS ) - ptr ) ;\n replace ( & ds_view , search_buf , search_len , replace_buf , replace_len ) ;\n }\n {\n size_t user_name_len ;\n char user_name_str [ USERNAME_LENGTH + 1 ] ;\n char quoted_user_name_str [ USERNAME_LENGTH * 2 + 3 ] ;\n size_t host_name_len ;\n char host_name_str [ HOSTNAME_LENGTH + 1 ] ;\n char quoted_host_name_str [ HOSTNAME_LENGTH * 2 + 3 ] ;\n parse_user ( row [ 1 ] , lengths [ 1 ] , user_name_str , & user_name_len , host_name_str , & host_name_len ) ;\n ptr = search_buf ;\n search_len = ( ulong ) ( strxmov ( ptr , \"DEFINER=\" , quote_name ( user_name_str , quoted_user_name_str , FALSE ) , \"@\" , quote_name ( host_name_str , quoted_host_name_str , FALSE ) , \" SQL SECURITY \" , row [ 2 ] , NullS ) - ptr ) ;\n ptr = replace_buf ;\n replace_len = ( ulong ) ( strxmov ( ptr , \"*/\\n/*!50013 DEFINER=\" , quote_name ( user_name_str , quoted_user_name_str , FALSE ) , \"@\" , quote_name ( host_name_str , quoted_host_name_str , FALSE ) , \" SQL SECURITY \" , row [ 2 ] , \" */\\n/*!50001\" , NullS ) - ptr ) ;\n replace ( & ds_view , search_buf , search_len , replace_buf , replace_len ) ;\n }\n fprintf ( sql_file , \"/*!50001 SET @saved_cs_client = @@character_set_client */;\n\\n\" \"/*!50001 SET @saved_cs_results = @@character_set_results */;\n\\n\" \"/*!50001 SET @saved_col_connection = @@collation_connection */;\n\\n\" \"/*!50001 SET character_set_client = %s */;\n\\n\" \"/*!50001 SET character_set_results = %s */;\n\\n\" \"/*!50001 SET collation_connection = %s */;\n\\n\" \"/*!50001 %s */;\n\\n\" \"/*!50001 SET character_set_client = @saved_cs_client */;\n\\n\" \"/*!50001 SET character_set_results = @saved_cs_results */;\n\\n\" \"/*!50001 SET collation_connection = @saved_col_connection */;\n\\n\" , ( const char * ) row [ 3 ] , ( const char * ) row [ 3 ] , ( const char * ) row [ 4 ] , ( const char * ) ds_view . str ) ;\n check_io ( sql_file ) ;\n mysql_free_result ( table_res ) ;\n dynstr_free ( & ds_view ) ;\n }\n if ( switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 1 ) ;\n if ( sql_file != md_result_file ) {\n fputs ( \"\\n\" , sql_file ) ;\n write_footer ( sql_file ) ;\n my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n }\n DBUG_RETURN ( 0 ) ;\n }",
        "hash": 6667142528452941476,
        "project": "debian",
        "size": 113,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static my_bool get_view_structure ( char * table , char * db ) {\n"
                ],
                [
                    23,
                    " field = mysql_fetch_field_direct ( table_res , 0 ) ;\n"
                ],
                [
                    24,
                    " if ( strcmp ( field -> name , \"View\" ) != 0 ) {\n"
                ],
                [
                    25,
                    " mysql_free_result ( table_res ) ;\n"
                ],
                [
                    26,
                    " switch_character_set_results ( mysql , default_charset ) ;\n"
                ],
                [
                    27,
                    " verbose_msg ( \"-- It's base table, skipped\\n\" ) ;\n"
                ],
                [
                    28,
                    " DBUG_RETURN ( 0 ) ;\n"
                ],
                [
                    46,
                    " if ( mysql_query ( mysql , query ) ) {\n"
                ],
                [
                    59,
                    " row = mysql_fetch_row ( table_res ) ;\n"
                ],
                [
                    63,
                    " if ( ! ( table_res = mysql_store_result ( mysql ) ) || ! ( row = mysql_fetch_row ( table_res ) ) ) {\n"
                ],
                [
                    70,
                    " if ( strcmp ( row [ 0 ] , \"NONE\" ) ) {\n"
                ],
                [
                    71,
                    " ptr = search_buf ;\n"
                ],
                [
                    72,
                    " search_len = ( ulong ) ( strxmov ( ptr , \"WITH \" , row [ 0 ] , \" CHECK OPTION\" , NullS ) - ptr ) ;\n"
                ],
                [
                    73,
                    " ptr = replace_buf ;\n"
                ],
                [
                    74,
                    " replace_len = ( ulong ) ( strxmov ( ptr , \"*/\\n/*!50002 WITH \" , row [ 0 ] , \" CHECK OPTION\" , NullS ) - ptr ) ;\n"
                ],
                [
                    75,
                    " replace ( & ds_view , search_buf , search_len , replace_buf , replace_len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static my_bool get_view_structure ( char * table , char * db ) {\n"
                ],
                [
                    23,
                    " field = mysql_fetch_field_direct ( table_res , 0 ) ;\n"
                ],
                [
                    24,
                    " if ( strcmp ( field -> name , \"View\" ) != 0 ) {\n"
                ],
                [
                    25,
                    " mysql_free_result ( table_res ) ;\n"
                ],
                [
                    26,
                    " switch_character_set_results ( mysql , default_charset ) ;\n"
                ],
                [
                    27,
                    " verbose_msg ( \"-- It's base table, skipped\\n\" ) ;\n"
                ],
                [
                    28,
                    " DBUG_RETURN ( 0 ) ;\n"
                ],
                [
                    46,
                    " if ( mysql_query ( mysql , query ) ) {\n"
                ],
                [
                    59,
                    " row = mysql_fetch_row ( table_res ) ;\n"
                ],
                [
                    63,
                    " if ( ! ( table_res = mysql_store_result ( mysql ) ) || ! ( row = mysql_fetch_row ( table_res ) ) ) {\n"
                ],
                [
                    70,
                    " if ( strcmp ( row [ 0 ] , \"NONE\" ) ) {\n"
                ],
                [
                    71,
                    " ptr = search_buf ;\n"
                ],
                [
                    72,
                    " search_len = ( ulong ) ( strxmov ( ptr , \"WITH \" , row [ 0 ] , \" CHECK OPTION\" , NullS ) - ptr ) ;\n"
                ],
                [
                    73,
                    " ptr = replace_buf ;\n"
                ],
                [
                    74,
                    " replace_len = ( ulong ) ( strxmov ( ptr , \"*/\\n/*!50002 WITH \" , row [ 0 ] , \" CHECK OPTION\" , NullS ) - ptr ) ;\n"
                ],
                [
                    75,
                    " replace ( & ds_view , search_buf , search_len , replace_buf , replace_len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static uint dump_routines_for_db ( char * db ) {\n char query_buff [ QUERY_LENGTH ] ;\n const char * routine_type [ ] = {\n \"FUNCTION\" , \"PROCEDURE\" }\n ;\n char db_name_buff [ NAME_LEN * 2 + 3 ] , name_buff [ NAME_LEN * 2 + 3 ] ;\n char * routine_name ;\n int i ;\n FILE * sql_file = md_result_file ;\n MYSQL_RES * routine_res , * routine_list_res ;\n MYSQL_ROW row , routine_list_row ;\n char db_cl_name [ MY_CS_NAME_SIZE ] ;\n int db_cl_altered = FALSE ;\n DBUG_ENTER ( \"dump_routines_for_db\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"db: '%s'\" , db ) ) ;\n mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n print_comment ( sql_file , 0 , \"\\n--\\n-- Dumping routines for database '%s'\\n--\\n\" , db ) ;\n if ( lock_tables ) mysql_query ( mysql , \"LOCK TABLES mysql.proc READ\" ) ;\n if ( fetch_db_collation ( db , db_cl_name , sizeof ( db_cl_name ) ) ) DBUG_RETURN ( 1 ) ;\n if ( switch_character_set_results ( mysql , \"binary\" ) ) DBUG_RETURN ( 1 ) ;\n if ( opt_xml ) fputs ( \"\\t<routines>\\n\" , sql_file ) ;\n for ( i = 0 ;\n i <= 1 ;\n i ++ ) {\n my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW %s STATUS WHERE Db = '%s'\" , routine_type [ i ] , db_name_buff ) ;\n if ( mysql_query_with_error_report ( mysql , & routine_list_res , query_buff ) ) DBUG_RETURN ( 1 ) ;\n if ( mysql_num_rows ( routine_list_res ) ) {\n while ( ( routine_list_row = mysql_fetch_row ( routine_list_res ) ) ) {\n routine_name = quote_name ( routine_list_row [ 1 ] , name_buff , 0 ) ;\n DBUG_PRINT ( \"info\" , ( \"retrieving CREATE %s for %s\" , routine_type [ i ] , name_buff ) ) ;\n my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW CREATE %s %s\" , routine_type [ i ] , routine_name ) ;\n if ( mysql_query_with_error_report ( mysql , & routine_res , query_buff ) ) DBUG_RETURN ( 1 ) ;\n while ( ( row = mysql_fetch_row ( routine_res ) ) ) {\n DBUG_PRINT ( \"info\" , ( \"length of body for %s row[2] '%s' is %zu\" , routine_name , row [ 2 ] ? row [ 2 ] : \"(null)\" , row [ 2 ] ? strlen ( row [ 2 ] ) : 0 ) ) ;\n if ( row [ 2 ] == NULL ) {\n print_comment ( sql_file , 1 , \"\\n-- insufficient privileges to %s\\n\" , query_buff ) ;\n print_comment ( sql_file , 1 , \"-- does %s have permissions on mysql.proc?\\n\\n\" , current_user ) ;\n maybe_die ( EX_MYSQLERR , \"%s has insufficent privileges to %s!\" , current_user , query_buff ) ;\n }\n else if ( strlen ( row [ 2 ] ) ) {\n if ( opt_xml ) {\n if ( i ) print_xml_row ( sql_file , \"routine\" , routine_res , & row , \"Create Procedure\" ) ;\n else print_xml_row ( sql_file , \"routine\" , routine_res , & row , \"Create Function\" ) ;\n continue ;\n }\n if ( opt_drop ) fprintf ( sql_file , \"/*!50003 DROP %s IF EXISTS %s */;\n\\n\" , routine_type [ i ] , routine_name ) ;\n if ( mysql_num_fields ( routine_res ) >= 6 ) {\n if ( switch_db_collation ( sql_file , db , \";\n\" , db_cl_name , row [ 5 ] , & db_cl_altered ) ) {\n DBUG_RETURN ( 1 ) ;\n }\n switch_cs_variables ( sql_file , \";\n\" , row [ 3 ] , row [ 3 ] , row [ 4 ] ) ;\n }\n else {\n fprintf ( sql_file , \"--\\n\" \"-- WARNING: old server version. \" \"The following dump may be incomplete.\\n\" \"--\\n\" ) ;\n }\n switch_sql_mode ( sql_file , \";\n\" , row [ 1 ] ) ;\n fprintf ( sql_file , \"DELIMITER ;\n;\n\\n\" \"%s ;\n;\n\\n\" \"DELIMITER ;\n\\n\" , ( const char * ) row [ 2 ] ) ;\n restore_sql_mode ( sql_file , \";\n\" ) ;\n if ( mysql_num_fields ( routine_res ) >= 6 ) {\n restore_cs_variables ( sql_file , \";\n\" ) ;\n if ( db_cl_altered ) {\n if ( restore_db_collation ( sql_file , db , \";\n\" , db_cl_name ) ) DBUG_RETURN ( 1 ) ;\n }\n }\n }\n }\n mysql_free_result ( routine_res ) ;\n }\n }\n mysql_free_result ( routine_list_res ) ;\n }\n if ( opt_xml ) {\n fputs ( \"\\t</routines>\\n\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n if ( switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 1 ) ;\n if ( lock_tables ) ( void ) mysql_query_with_error_report ( mysql , 0 , \"UNLOCK TABLES\" ) ;\n DBUG_RETURN ( 0 ) ;\n }",
        "hash": 6667142528452941476,
        "project": "debian",
        "size": 91,
        "slice": {
            "strlen": [
                [
                    1,
                    "static uint dump_routines_for_db ( char * db ) {\n"
                ],
                [
                    15,
                    " DBUG_PRINT ( \"enter\" , ( \"db: '%s'\" , db ) ) ;\n"
                ],
                [
                    16,
                    " mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n"
                ],
                [
                    33,
                    " while ( ( row = mysql_fetch_row ( routine_res ) ) ) {\n"
                ],
                [
                    34,
                    " DBUG_PRINT ( \"info\" , ( \"length of body for %s row[2] '%s' is %zu\" , routine_name , row [ 2 ] ? row [ 2 ] : \"(null)\" , row [ 2 ] ? strlen ( row [ 2 ] ) : 0 ) ) ;\n"
                ],
                [
                    35,
                    " if ( row [ 2 ] == NULL ) {\n"
                ],
                [
                    40,
                    " else if ( strlen ( row [ 2 ] ) ) {\n"
                ],
                [
                    41,
                    " if ( opt_xml ) {\n"
                ],
                [
                    42,
                    " if ( i ) print_xml_row ( sql_file , \"routine\" , routine_res , & row , \"Create Procedure\" ) ;\n"
                ],
                [
                    43,
                    " else print_xml_row ( sql_file , \"routine\" , routine_res , & row , \"Create Function\" ) ;\n"
                ],
                [
                    57,
                    " fprintf ( sql_file , \"--\\n\" \"-- WARNING: old server version. \" \"The following dump may be incomplete.\\n\" \"--\\n\" ) ;\n"
                ],
                [
                    63,
                    "\\n\" \"%s ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static uint dump_routines_for_db ( char * db ) {\n"
                ],
                [
                    17,
                    " print_comment ( sql_file , 0 , \"\\n--\\n-- Dumping routines for database '%s'\\n--\\n\" , db ) ;\n"
                ],
                [
                    21,
                    " if ( opt_xml ) fputs ( \"\\t<routines>\\n\" , sql_file ) ;\n"
                ],
                [
                    36,
                    " print_comment ( sql_file , 1 , \"\\n-- insufficient privileges to %s\\n\" , query_buff ) ;\n"
                ],
                [
                    37,
                    " print_comment ( sql_file , 1 , \"-- does %s have permissions on mysql.proc?\\n\\n\" , current_user ) ;\n"
                ],
                [
                    40,
                    " else if ( strlen ( row [ 2 ] ) ) {\n"
                ],
                [
                    42,
                    " if ( i ) print_xml_row ( sql_file , \"routine\" , routine_res , & row , \"Create Procedure\" ) ;\n"
                ],
                [
                    43,
                    " else print_xml_row ( sql_file , \"routine\" , routine_res , & row , \"Create Function\" ) ;\n"
                ],
                [
                    57,
                    " fprintf ( sql_file , \"--\\n\" \"-- WARNING: old server version. \" \"The following dump may be incomplete.\\n\" \"--\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static uint dump_routines_for_db ( char * db ) {\n"
                ],
                [
                    15,
                    " DBUG_PRINT ( \"enter\" , ( \"db: '%s'\" , db ) ) ;\n"
                ],
                [
                    16,
                    " mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n"
                ],
                [
                    17,
                    " print_comment ( sql_file , 0 , \"\\n--\\n-- Dumping routines for database '%s'\\n--\\n\" , db ) ;\n"
                ],
                [
                    21,
                    " if ( opt_xml ) fputs ( \"\\t<routines>\\n\" , sql_file ) ;\n"
                ],
                [
                    33,
                    " while ( ( row = mysql_fetch_row ( routine_res ) ) ) {\n"
                ],
                [
                    34,
                    " DBUG_PRINT ( \"info\" , ( \"length of body for %s row[2] '%s' is %zu\" , routine_name , row [ 2 ] ? row [ 2 ] : \"(null)\" , row [ 2 ] ? strlen ( row [ 2 ] ) : 0 ) ) ;\n"
                ],
                [
                    35,
                    " if ( row [ 2 ] == NULL ) {\n"
                ],
                [
                    36,
                    " print_comment ( sql_file , 1 , \"\\n-- insufficient privileges to %s\\n\" , query_buff ) ;\n"
                ],
                [
                    37,
                    " print_comment ( sql_file , 1 , \"-- does %s have permissions on mysql.proc?\\n\\n\" , current_user ) ;\n"
                ],
                [
                    40,
                    " else if ( strlen ( row [ 2 ] ) ) {\n"
                ],
                [
                    41,
                    " if ( opt_xml ) {\n"
                ],
                [
                    42,
                    " if ( i ) print_xml_row ( sql_file , \"routine\" , routine_res , & row , \"Create Procedure\" ) ;\n"
                ],
                [
                    43,
                    " else print_xml_row ( sql_file , \"routine\" , routine_res , & row , \"Create Function\" ) ;\n"
                ],
                [
                    57,
                    " fprintf ( sql_file , \"--\\n\" \"-- WARNING: old server version. \" \"The following dump may be incomplete.\\n\" \"--\\n\" ) ;\n"
                ],
                [
                    63,
                    "\\n\" \"%s ;\n"
                ]
            ]
        }
    },
    {
        "code": "static uint get_table_structure ( char * table , char * db , char * table_type , char * ignore_flag ) {\n my_bool init = 0 , delayed , write_data , complete_insert ;\n my_ulonglong num_fields ;\n char * result_table , * opt_quoted_table ;\n const char * insert_option ;\n char name_buff [ NAME_LEN + 3 ] , table_buff [ NAME_LEN * 2 + 3 ] ;\n char table_buff2 [ NAME_LEN * 2 + 3 ] , query_buff [ QUERY_LENGTH ] ;\n const char * show_fields_stmt = \"SELECT `COLUMN_NAME` AS `Field`, \" \"`COLUMN_TYPE` AS `Type`, \" \"`IS_NULLABLE` AS `Null`, \" \"`COLUMN_KEY` AS `Key`, \" \"`COLUMN_DEFAULT` AS `Default`, \" \"`EXTRA` AS `Extra`, \" \"`COLUMN_COMMENT` AS `Comment` \" \"FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE \" \"TABLE_SCHEMA = '%s' AND TABLE_NAME = '%s'\" ;\n FILE * sql_file = md_result_file ;\n int len ;\n my_bool is_log_table ;\n MYSQL_RES * result ;\n MYSQL_ROW row ;\n DBUG_ENTER ( \"get_table_structure\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"db: %s table: %s\" , db , table ) ) ;\n * ignore_flag = check_if_ignore_table ( table , table_type ) ;\n delayed = opt_delayed ;\n if ( delayed && ( * ignore_flag & IGNORE_INSERT_DELAYED ) ) {\n delayed = 0 ;\n verbose_msg ( \"-- Warning: Unable to use delayed inserts for table '%s' \" \"because it's of type %s\\n\" , table , table_type ) ;\n }\n complete_insert = 0 ;\n if ( ( write_data = ! ( * ignore_flag & IGNORE_DATA ) ) ) {\n complete_insert = opt_complete_insert ;\n if ( ! insert_pat_inited ) {\n insert_pat_inited = 1 ;\n init_dynamic_string_checked ( & insert_pat , \"\" , 1024 , 1024 ) ;\n }\n else dynstr_set_checked ( & insert_pat , \"\" ) ;\n }\n insert_option = ( ( delayed && opt_ignore ) ? \" DELAYED IGNORE \" : delayed ? \" DELAYED \" : opt_ignore ? \" IGNORE \" : \"\" ) ;\n verbose_msg ( \"-- Retrieving table structure for table %s...\\n\" , table ) ;\n len = my_snprintf ( query_buff , sizeof ( query_buff ) , \"SET SQL_QUOTE_SHOW_CREATE=%d\" , ( opt_quoted || opt_keywords ) ) ;\n if ( ! create_options ) strmov ( query_buff + len , \"/*!40102 ,SQL_MODE=concat(@@sql_mode, _utf8 ',NO_KEY_OPTIONS,NO_TABLE_OPTIONS,NO_FIELD_OPTIONS') */\" ) ;\n result_table = quote_name ( table , table_buff , 1 ) ;\n opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n if ( opt_order_by_primary ) order_by = primary_key_fields ( result_table ) ;\n if ( ! opt_xml && ! mysql_query_with_error_report ( mysql , 0 , query_buff ) ) {\n if ( ! opt_no_create_info ) {\n char buff [ 20 + FN_REFLEN ] ;\n MYSQL_FIELD * field ;\n my_snprintf ( buff , sizeof ( buff ) , \"show create table %s\" , result_table ) ;\n if ( switch_character_set_results ( mysql , \"binary\" ) || mysql_query_with_error_report ( mysql , & result , buff ) || switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 0 ) ;\n if ( path ) {\n if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) DBUG_RETURN ( 0 ) ;\n write_header ( sql_file , db ) ;\n }\n if ( strcmp ( table_type , \"VIEW\" ) == 0 ) print_comment ( sql_file , 0 , \"\\n--\\n-- Temporary table structure for view %s\\n--\\n\\n\" , result_table ) ;\n else print_comment ( sql_file , 0 , \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\" , result_table ) ;\n if ( opt_drop ) {\n if ( ! general_log_or_slow_log_tables ( db , table ) ) fprintf ( sql_file , \"DROP TABLE IF EXISTS %s;\n\\n\" , opt_quoted_table ) ;\n check_io ( sql_file ) ;\n }\n field = mysql_fetch_field_direct ( result , 0 ) ;\n if ( strcmp ( field -> name , \"View\" ) == 0 ) {\n char * scv_buff = NULL ;\n my_ulonglong n_cols ;\n verbose_msg ( \"-- It's a view, create dummy table for view\\n\" ) ;\n if ( ( row = mysql_fetch_row ( result ) ) && ( scv_buff = row [ 1 ] ) ) scv_buff = my_strdup ( scv_buff , MYF ( 0 ) ) ;\n mysql_free_result ( result ) ;\n my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW FIELDS FROM %s\" , result_table ) ;\n if ( switch_character_set_results ( mysql , \"binary\" ) || mysql_query_with_error_report ( mysql , & result , query_buff ) || switch_character_set_results ( mysql , default_charset ) ) {\n if ( mysql_errno ( mysql ) == ER_VIEW_INVALID ) fprintf ( sql_file , \"\\n-- failed on view %s: %s\\n\\n\" , result_table , scv_buff ? scv_buff : \"\" ) ;\n my_free ( scv_buff ) ;\n DBUG_RETURN ( 0 ) ;\n }\n else my_free ( scv_buff ) ;\n n_cols = mysql_num_rows ( result ) ;\n if ( 0 != n_cols ) {\n if ( n_cols >= 1000 ) fprintf ( stderr , \"-- Warning: Creating a stand-in table for view %s may\" \" fail when replaying the dump file produced because \" \"of the number of columns exceeding 1000. Exercise \" \"caution when replaying the produced dump file.\\n\" , table ) ;\n if ( opt_drop ) {\n fprintf ( sql_file , \"/*!50001 DROP VIEW IF EXISTS %s*/;\n\\n\" , opt_quoted_table ) ;\n check_io ( sql_file ) ;\n }\n fprintf ( sql_file , \"SET @saved_cs_client = @@character_set_client;\n\\n\" \"SET character_set_client = utf8;\n\\n\" \"/*!50001 CREATE TABLE %s (\\n\" , result_table ) ;\n row = mysql_fetch_row ( result ) ;\n fprintf ( sql_file , \" %s tinyint NOT NULL\" , quote_name ( row [ 0 ] , name_buff , 0 ) ) ;\n while ( ( row = mysql_fetch_row ( result ) ) ) {\n fprintf ( sql_file , \",\\n %s tinyint NOT NULL\" , quote_name ( row [ 0 ] , name_buff , 0 ) ) ;\n }\n fprintf ( sql_file , \"\\n) ENGINE=MyISAM */;\n\\n\" \"SET character_set_client = @saved_cs_client;\n\\n\" ) ;\n check_io ( sql_file ) ;\n }\n mysql_free_result ( result ) ;\n if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n seen_views = 1 ;\n DBUG_RETURN ( 0 ) ;\n }\n row = mysql_fetch_row ( result ) ;\n is_log_table = general_log_or_slow_log_tables ( db , table ) ;\n if ( is_log_table ) row [ 1 ] += 13 ;\n if ( opt_compatible_mode & 3 ) {\n fprintf ( sql_file , is_log_table ? \"CREATE TABLE IF NOT EXISTS %s;\n\\n\" : \"%s;\n\\n\" , row [ 1 ] ) ;\n }\n else {\n fprintf ( sql_file , \"/*!40101 SET @saved_cs_client = @@character_set_client */;\n\\n\" \"/*!40101 SET character_set_client = utf8 */;\n\\n\" \"%s%s;\n\\n\" \"/*!40101 SET character_set_client = @saved_cs_client */;\n\\n\" , is_log_table ? \"CREATE TABLE IF NOT EXISTS \" : \"\" , row [ 1 ] ) ;\n }\n check_io ( sql_file ) ;\n mysql_free_result ( result ) ;\n }\n my_snprintf ( query_buff , sizeof ( query_buff ) , \"show fields from %s\" , result_table ) ;\n if ( mysql_query_with_error_report ( mysql , & result , query_buff ) ) {\n if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n DBUG_RETURN ( 0 ) ;\n }\n if ( write_data ) {\n if ( opt_replace_into ) dynstr_append_checked ( & insert_pat , \"REPLACE \" ) ;\n else dynstr_append_checked ( & insert_pat , \"INSERT \" ) ;\n dynstr_append_checked ( & insert_pat , insert_option ) ;\n dynstr_append_checked ( & insert_pat , \"INTO \" ) ;\n dynstr_append_checked ( & insert_pat , opt_quoted_table ) ;\n if ( complete_insert ) {\n dynstr_append_checked ( & insert_pat , \" (\" ) ;\n }\n else {\n dynstr_append_checked ( & insert_pat , \" VALUES \" ) ;\n if ( ! extended_insert ) dynstr_append_checked ( & insert_pat , \"(\" ) ;\n }\n }\n while ( ( row = mysql_fetch_row ( result ) ) ) {\n if ( complete_insert ) {\n if ( init ) {\n dynstr_append_checked ( & insert_pat , \", \" ) ;\n }\n init = 1 ;\n dynstr_append_checked ( & insert_pat , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) ) ;\n }\n }\n num_fields = mysql_num_rows ( result ) ;\n mysql_free_result ( result ) ;\n }\n else {\n verbose_msg ( \"%s: Warning: Can't set SQL_QUOTE_SHOW_CREATE option (%s)\\n\" , my_progname_short , mysql_error ( mysql ) ) ;\n my_snprintf ( query_buff , sizeof ( query_buff ) , show_fields_stmt , db , table ) ;\n if ( mysql_query_with_error_report ( mysql , & result , query_buff ) ) DBUG_RETURN ( 0 ) ;\n if ( ! opt_no_create_info ) {\n if ( path ) {\n if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) DBUG_RETURN ( 0 ) ;\n write_header ( sql_file , db ) ;\n }\n print_comment ( sql_file , 0 , \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\" , result_table ) ;\n if ( opt_drop ) fprintf ( sql_file , \"DROP TABLE IF EXISTS %s;\n\\n\" , result_table ) ;\n if ( ! opt_xml ) fprintf ( sql_file , \"CREATE TABLE %s (\\n\" , result_table ) ;\n else print_xml_tag ( sql_file , \"\\t\" , \"\\n\" , \"table_structure\" , \"name=\" , table , NullS ) ;\n check_io ( sql_file ) ;\n }\n if ( write_data ) {\n if ( opt_replace_into ) dynstr_append_checked ( & insert_pat , \"REPLACE \" ) ;\n else dynstr_append_checked ( & insert_pat , \"INSERT \" ) ;\n dynstr_append_checked ( & insert_pat , insert_option ) ;\n dynstr_append_checked ( & insert_pat , \"INTO \" ) ;\n dynstr_append_checked ( & insert_pat , result_table ) ;\n if ( complete_insert ) dynstr_append_checked ( & insert_pat , \" (\" ) ;\n else {\n dynstr_append_checked ( & insert_pat , \" VALUES \" ) ;\n if ( ! extended_insert ) dynstr_append_checked ( & insert_pat , \"(\" ) ;\n }\n }\n while ( ( row = mysql_fetch_row ( result ) ) ) {\n ulong * lengths = mysql_fetch_lengths ( result ) ;\n if ( init ) {\n if ( ! opt_xml && ! opt_no_create_info ) {\n fputs ( \",\\n\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n if ( complete_insert ) dynstr_append_checked ( & insert_pat , \", \" ) ;\n }\n init = 1 ;\n if ( complete_insert ) dynstr_append_checked ( & insert_pat , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) ) ;\n if ( ! opt_no_create_info ) {\n if ( opt_xml ) {\n print_xml_row ( sql_file , \"field\" , result , & row , NullS ) ;\n continue ;\n }\n if ( opt_keywords ) fprintf ( sql_file , \" %s.%s %s\" , result_table , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n else fprintf ( sql_file , \" %s %s\" , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n if ( row [ SHOW_DEFAULT ] ) {\n fputs ( \" DEFAULT \" , sql_file ) ;\n unescape ( sql_file , row [ SHOW_DEFAULT ] , lengths [ SHOW_DEFAULT ] ) ;\n }\n if ( ! row [ SHOW_NULL ] [ 0 ] ) fputs ( \" NOT NULL\" , sql_file ) ;\n if ( row [ SHOW_EXTRA ] [ 0 ] ) fprintf ( sql_file , \" %s\" , row [ SHOW_EXTRA ] ) ;\n check_io ( sql_file ) ;\n }\n }\n num_fields = mysql_num_rows ( result ) ;\n mysql_free_result ( result ) ;\n if ( ! opt_no_create_info ) {\n char buff [ 20 + FN_REFLEN ] ;\n uint keynr , primary_key ;\n my_snprintf ( buff , sizeof ( buff ) , \"show keys from %s\" , result_table ) ;\n if ( mysql_query_with_error_report ( mysql , & result , buff ) ) {\n if ( mysql_errno ( mysql ) == ER_WRONG_OBJECT ) {\n fputs ( \"\\t\\t<options Comment=\\\"view\\\" />\\n\" , sql_file ) ;\n goto continue_xml ;\n }\n fprintf ( stderr , \"%s: Can't get keys for table %s (%s)\\n\" , my_progname_short , result_table , mysql_error ( mysql ) ) ;\n if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n DBUG_RETURN ( 0 ) ;\n }\n keynr = 0 ;\n primary_key = INT_MAX ;\n while ( ( row = mysql_fetch_row ( result ) ) ) {\n if ( atoi ( row [ 3 ] ) == 1 ) {\n keynr ++ ;\n # ifdef FORCE_PRIMARY_KEY if ( atoi ( row [ 1 ] ) == 0 && primary_key == INT_MAX ) primary_key = keynr ;\n # endif if ( ! strcmp ( row [ 2 ] , \"PRIMARY\" ) ) {\n primary_key = keynr ;\n break ;\n }\n }\n }\n mysql_data_seek ( result , 0 ) ;\n keynr = 0 ;\n while ( ( row = mysql_fetch_row ( result ) ) ) {\n if ( opt_xml ) {\n print_xml_row ( sql_file , \"key\" , result , & row , NullS ) ;\n continue ;\n }\n if ( atoi ( row [ 3 ] ) == 1 ) {\n if ( keynr ++ ) putc ( ')' , sql_file ) ;\n if ( atoi ( row [ 1 ] ) ) fprintf ( sql_file , \",\\n KEY %s (\" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n else if ( keynr == primary_key ) fputs ( \",\\n PRIMARY KEY (\" , sql_file ) ;\n else fprintf ( sql_file , \",\\n UNIQUE %s (\" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n }\n else putc ( ',' , sql_file ) ;\n fputs ( quote_name ( row [ 4 ] , name_buff , 0 ) , sql_file ) ;\n if ( row [ 7 ] ) fprintf ( sql_file , \" (%s)\" , row [ 7 ] ) ;\n check_io ( sql_file ) ;\n }\n mysql_free_result ( result ) ;\n if ( ! opt_xml ) {\n if ( keynr ) putc ( ')' , sql_file ) ;\n fputs ( \"\\n)\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n if ( create_options ) {\n char show_name_buff [ NAME_LEN * 2 + 2 + 24 ] ;\n my_snprintf ( buff , sizeof ( buff ) , \"show table status like %s\" , quote_for_like ( table , show_name_buff ) ) ;\n if ( mysql_query_with_error_report ( mysql , & result , buff ) ) {\n if ( mysql_errno ( mysql ) != ER_PARSE_ERROR ) {\n verbose_msg ( \"-- Warning: Couldn't get status information for \" \"table %s (%s)\\n\" , result_table , mysql_error ( mysql ) ) ;\n }\n }\n else if ( ! ( row = mysql_fetch_row ( result ) ) ) {\n fprintf ( stderr , \"Error: Couldn't read status information for table %s (%s)\\n\" , result_table , mysql_error ( mysql ) ) ;\n }\n else {\n if ( opt_xml ) print_xml_row ( sql_file , \"options\" , result , & row , NullS ) ;\n else {\n fputs ( \"/*!\" , sql_file ) ;\n print_value ( sql_file , result , row , \"engine=\" , \"Engine\" , 0 ) ;\n print_value ( sql_file , result , row , \"\" , \"Create_options\" , 0 ) ;\n print_value ( sql_file , result , row , \"comment=\" , \"Comment\" , 1 ) ;\n fputs ( \" */\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n }\n mysql_free_result ( result ) ;\n }\n continue_xml : if ( ! opt_xml ) fputs ( \";\n\\n\" , sql_file ) ;\n else fputs ( \"\\t</table_structure>\\n\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n }\n if ( complete_insert ) {\n dynstr_append_checked ( & insert_pat , \") VALUES \" ) ;\n if ( ! extended_insert ) dynstr_append_checked ( & insert_pat , \"(\" ) ;\n }\n if ( sql_file != md_result_file ) {\n fputs ( \"\\n\" , sql_file ) ;\n write_footer ( sql_file ) ;\n my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n }\n DBUG_RETURN ( ( uint ) num_fields ) ;\n }",
        "hash": 6667142528452941476,
        "project": "debian",
        "size": 290,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static uint get_table_structure ( char * table , char * db , char * table_type , char * ignore_flag ) {\n"
                ],
                [
                    16,
                    " * ignore_flag = check_if_ignore_table ( table , table_type ) ;\n"
                ],
                [
                    20,
                    " verbose_msg ( \"-- Warning: Unable to use delayed inserts for table '%s' \" \"because it's of type %s\\n\" , table , table_type ) ;\n"
                ],
                [
                    39,
                    " if ( ! opt_no_create_info ) {\n"
                ],
                [
                    48,
                    " if ( strcmp ( table_type , \"VIEW\" ) == 0 ) print_comment ( sql_file , 0 , \"\\n--\\n-- Temporary table structure for view %s\\n--\\n\\n\" , result_table ) ;\n"
                ],
                [
                    49,
                    " else print_comment ( sql_file , 0 , \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\" , result_table ) ;\n"
                ],
                [
                    55,
                    " field = mysql_fetch_field_direct ( result , 0 ) ;\n"
                ],
                [
                    56,
                    " if ( strcmp ( field -> name , \"View\" ) == 0 ) {\n"
                ],
                [
                    57,
                    " char * scv_buff = NULL ;\n"
                ],
                [
                    59,
                    " verbose_msg ( \"-- It's a view, create dummy table for view\\n\" ) ;\n"
                ],
                [
                    60,
                    " if ( ( row = mysql_fetch_row ( result ) ) && ( scv_buff = row [ 1 ] ) ) scv_buff = my_strdup ( scv_buff , MYF ( 0 ) ) ;\n"
                ],
                [
                    61,
                    " mysql_free_result ( result ) ;\n"
                ],
                [
                    62,
                    " my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW FIELDS FROM %s\" , result_table ) ;\n"
                ],
                [
                    63,
                    " if ( switch_character_set_results ( mysql , \"binary\" ) || mysql_query_with_error_report ( mysql , & result , query_buff ) || switch_character_set_results ( mysql , default_charset ) ) {\n"
                ],
                [
                    69,
                    " n_cols = mysql_num_rows ( result ) ;\n"
                ],
                [
                    70,
                    " if ( 0 != n_cols ) {\n"
                ],
                [
                    90,
                    " mysql_free_result ( result ) ;\n"
                ],
                [
                    91,
                    " if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n"
                ],
                [
                    92,
                    " seen_views = 1 ;\n"
                ],
                [
                    93,
                    " DBUG_RETURN ( 0 ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static uint get_table_structure ( char * table , char * db , char * table_type , char * ignore_flag ) {\n"
                ],
                [
                    9,
                    " FILE * sql_file = md_result_file ;\n"
                ],
                [
                    35,
                    " result_table = quote_name ( table , table_buff , 1 ) ;\n"
                ],
                [
                    36,
                    " opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n"
                ],
                [
                    37,
                    " if ( opt_order_by_primary ) order_by = primary_key_fields ( result_table ) ;\n"
                ],
                [
                    45,
                    " if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) DBUG_RETURN ( 0 ) ;\n"
                ],
                [
                    48,
                    " if ( strcmp ( table_type , \"VIEW\" ) == 0 ) print_comment ( sql_file , 0 , \"\\n--\\n-- Temporary table structure for view %s\\n--\\n\\n\" , result_table ) ;\n"
                ],
                [
                    49,
                    " else print_comment ( sql_file , 0 , \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\" , result_table ) ;\n"
                ],
                [
                    57,
                    " char * scv_buff = NULL ;\n"
                ],
                [
                    60,
                    " if ( ( row = mysql_fetch_row ( result ) ) && ( scv_buff = row [ 1 ] ) ) scv_buff = my_strdup ( scv_buff , MYF ( 0 ) ) ;\n"
                ],
                [
                    62,
                    " my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW FIELDS FROM %s\" , result_table ) ;\n"
                ],
                [
                    64,
                    " if ( mysql_errno ( mysql ) == ER_VIEW_INVALID ) fprintf ( sql_file , \"\\n-- failed on view %s: %s\\n\\n\" , result_table , scv_buff ? scv_buff : \"\" ) ;\n"
                ],
                [
                    71,
                    " if ( n_cols >= 1000 ) fprintf ( stderr , \"-- Warning: Creating a stand-in table for view %s may\" \" fail when replaying the dump file produced because \" \"of the number of columns exceeding 1000. Exercise \" \"caution when replaying the produced dump file.\\n\" , table ) ;\n"
                ],
                [
                    88,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    91,
                    " if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n"
                ],
                [
                    96,
                    " is_log_table = general_log_or_slow_log_tables ( db , table ) ;\n"
                ],
                [
                    110,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    113,
                    " my_snprintf ( query_buff , sizeof ( query_buff ) , \"show fields from %s\" , result_table ) ;\n"
                ],
                [
                    145,
                    " verbose_msg ( \"%s: Warning: Can't set SQL_QUOTE_SHOW_CREATE option (%s)\\n\" , my_progname_short , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    153,
                    " print_comment ( sql_file , 0 , \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\" , result_table ) ;\n"
                ],
                [
                    158,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    165,
                    " dynstr_append_checked ( & insert_pat , result_table ) ;\n"
                ],
                [
                    172,
                    " while ( ( row = mysql_fetch_row ( result ) ) ) {\n"
                ],
                [
                    177,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    185,
                    " print_xml_row ( sql_file , \"field\" , result , & row , NullS ) ;\n"
                ],
                [
                    188,
                    " if ( opt_keywords ) fprintf ( sql_file , \" %s.%s %s\" , result_table , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n"
                ],
                [
                    189,
                    " else fprintf ( sql_file , \" %s %s\" , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n"
                ],
                [
                    191,
                    " fputs ( \" DEFAULT \" , sql_file ) ;\n"
                ],
                [
                    192,
                    " unescape ( sql_file , row [ SHOW_DEFAULT ] , lengths [ SHOW_DEFAULT ] ) ;\n"
                ],
                [
                    194,
                    " if ( ! row [ SHOW_NULL ] [ 0 ] ) fputs ( \" NOT NULL\" , sql_file ) ;\n"
                ],
                [
                    195,
                    " if ( row [ SHOW_EXTRA ] [ 0 ] ) fprintf ( sql_file , \" %s\" , row [ SHOW_EXTRA ] ) ;\n"
                ],
                [
                    196,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    204,
                    " my_snprintf ( buff , sizeof ( buff ) , \"show keys from %s\" , result_table ) ;\n"
                ],
                [
                    205,
                    " if ( mysql_query_with_error_report ( mysql , & result , buff ) ) {\n"
                ],
                [
                    210,
                    " fprintf ( stderr , \"%s: Can't get keys for table %s (%s)\\n\" , my_progname_short , result_table , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    211,
                    " if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n"
                ],
                [
                    228,
                    " while ( ( row = mysql_fetch_row ( result ) ) ) {\n"
                ],
                [
                    230,
                    " print_xml_row ( sql_file , \"key\" , result , & row , NullS ) ;\n"
                ],
                [
                    234,
                    " if ( keynr ++ ) putc ( ')' , sql_file ) ;\n"
                ],
                [
                    235,
                    " if ( atoi ( row [ 1 ] ) ) fprintf ( sql_file , \",\\n KEY %s (\" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n"
                ],
                [
                    236,
                    " else if ( keynr == primary_key ) fputs ( \",\\n PRIMARY KEY (\" , sql_file ) ;\n"
                ],
                [
                    237,
                    " else fprintf ( sql_file , \",\\n UNIQUE %s (\" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n"
                ],
                [
                    240,
                    " fputs ( quote_name ( row [ 4 ] , name_buff , 0 ) , sql_file ) ;\n"
                ],
                [
                    241,
                    " if ( row [ 7 ] ) fprintf ( sql_file , \" (%s)\" , row [ 7 ] ) ;\n"
                ],
                [
                    242,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    255,
                    " verbose_msg ( \"-- Warning: Couldn't get status information for \" \"table %s (%s)\\n\" , result_table , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    258,
                    " else if ( ! ( row = mysql_fetch_row ( result ) ) ) {\n"
                ],
                [
                    259,
                    " fprintf ( stderr , \"Error: Couldn't read status information for table %s (%s)\\n\" , result_table , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    262,
                    " if ( opt_xml ) print_xml_row ( sql_file , \"options\" , result , & row , NullS ) ;\n"
                ],
                [
                    265,
                    " print_value ( sql_file , result , row , \"engine=\" , \"Engine\" , 0 ) ;\n"
                ],
                [
                    266,
                    " print_value ( sql_file , result , row , \"\" , \"Create_options\" , 0 ) ;\n"
                ],
                [
                    267,
                    " print_value ( sql_file , result , row , \"comment=\" , \"Comment\" , 1 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static uint get_table_structure ( char * table , char * db , char * table_type , char * ignore_flag ) {\n"
                ],
                [
                    9,
                    " FILE * sql_file = md_result_file ;\n"
                ],
                [
                    16,
                    " * ignore_flag = check_if_ignore_table ( table , table_type ) ;\n"
                ],
                [
                    20,
                    " verbose_msg ( \"-- Warning: Unable to use delayed inserts for table '%s' \" \"because it's of type %s\\n\" , table , table_type ) ;\n"
                ],
                [
                    35,
                    " result_table = quote_name ( table , table_buff , 1 ) ;\n"
                ],
                [
                    36,
                    " opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n"
                ],
                [
                    37,
                    " if ( opt_order_by_primary ) order_by = primary_key_fields ( result_table ) ;\n"
                ],
                [
                    39,
                    " if ( ! opt_no_create_info ) {\n"
                ],
                [
                    45,
                    " if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) DBUG_RETURN ( 0 ) ;\n"
                ],
                [
                    48,
                    " if ( strcmp ( table_type , \"VIEW\" ) == 0 ) print_comment ( sql_file , 0 , \"\\n--\\n-- Temporary table structure for view %s\\n--\\n\\n\" , result_table ) ;\n"
                ],
                [
                    49,
                    " else print_comment ( sql_file , 0 , \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\" , result_table ) ;\n"
                ],
                [
                    55,
                    " field = mysql_fetch_field_direct ( result , 0 ) ;\n"
                ],
                [
                    56,
                    " if ( strcmp ( field -> name , \"View\" ) == 0 ) {\n"
                ],
                [
                    57,
                    " char * scv_buff = NULL ;\n"
                ],
                [
                    59,
                    " verbose_msg ( \"-- It's a view, create dummy table for view\\n\" ) ;\n"
                ],
                [
                    60,
                    " if ( ( row = mysql_fetch_row ( result ) ) && ( scv_buff = row [ 1 ] ) ) scv_buff = my_strdup ( scv_buff , MYF ( 0 ) ) ;\n"
                ],
                [
                    61,
                    " mysql_free_result ( result ) ;\n"
                ],
                [
                    62,
                    " my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW FIELDS FROM %s\" , result_table ) ;\n"
                ],
                [
                    63,
                    " if ( switch_character_set_results ( mysql , \"binary\" ) || mysql_query_with_error_report ( mysql , & result , query_buff ) || switch_character_set_results ( mysql , default_charset ) ) {\n"
                ],
                [
                    64,
                    " if ( mysql_errno ( mysql ) == ER_VIEW_INVALID ) fprintf ( sql_file , \"\\n-- failed on view %s: %s\\n\\n\" , result_table , scv_buff ? scv_buff : \"\" ) ;\n"
                ],
                [
                    69,
                    " n_cols = mysql_num_rows ( result ) ;\n"
                ],
                [
                    70,
                    " if ( 0 != n_cols ) {\n"
                ],
                [
                    71,
                    " if ( n_cols >= 1000 ) fprintf ( stderr , \"-- Warning: Creating a stand-in table for view %s may\" \" fail when replaying the dump file produced because \" \"of the number of columns exceeding 1000. Exercise \" \"caution when replaying the produced dump file.\\n\" , table ) ;\n"
                ],
                [
                    88,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    90,
                    " mysql_free_result ( result ) ;\n"
                ],
                [
                    91,
                    " if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n"
                ],
                [
                    92,
                    " seen_views = 1 ;\n"
                ],
                [
                    93,
                    " DBUG_RETURN ( 0 ) ;\n"
                ],
                [
                    96,
                    " is_log_table = general_log_or_slow_log_tables ( db , table ) ;\n"
                ],
                [
                    110,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    113,
                    " my_snprintf ( query_buff , sizeof ( query_buff ) , \"show fields from %s\" , result_table ) ;\n"
                ],
                [
                    145,
                    " verbose_msg ( \"%s: Warning: Can't set SQL_QUOTE_SHOW_CREATE option (%s)\\n\" , my_progname_short , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    153,
                    " print_comment ( sql_file , 0 , \"\\n--\\n-- Table structure for table %s\\n--\\n\\n\" , result_table ) ;\n"
                ],
                [
                    158,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    165,
                    " dynstr_append_checked ( & insert_pat , result_table ) ;\n"
                ],
                [
                    172,
                    " while ( ( row = mysql_fetch_row ( result ) ) ) {\n"
                ],
                [
                    177,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    185,
                    " print_xml_row ( sql_file , \"field\" , result , & row , NullS ) ;\n"
                ],
                [
                    188,
                    " if ( opt_keywords ) fprintf ( sql_file , \" %s.%s %s\" , result_table , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n"
                ],
                [
                    189,
                    " else fprintf ( sql_file , \" %s %s\" , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n"
                ],
                [
                    191,
                    " fputs ( \" DEFAULT \" , sql_file ) ;\n"
                ],
                [
                    192,
                    " unescape ( sql_file , row [ SHOW_DEFAULT ] , lengths [ SHOW_DEFAULT ] ) ;\n"
                ],
                [
                    194,
                    " if ( ! row [ SHOW_NULL ] [ 0 ] ) fputs ( \" NOT NULL\" , sql_file ) ;\n"
                ],
                [
                    195,
                    " if ( row [ SHOW_EXTRA ] [ 0 ] ) fprintf ( sql_file , \" %s\" , row [ SHOW_EXTRA ] ) ;\n"
                ],
                [
                    196,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    204,
                    " my_snprintf ( buff , sizeof ( buff ) , \"show keys from %s\" , result_table ) ;\n"
                ],
                [
                    205,
                    " if ( mysql_query_with_error_report ( mysql , & result , buff ) ) {\n"
                ],
                [
                    210,
                    " fprintf ( stderr , \"%s: Can't get keys for table %s (%s)\\n\" , my_progname_short , result_table , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    211,
                    " if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n"
                ],
                [
                    228,
                    " while ( ( row = mysql_fetch_row ( result ) ) ) {\n"
                ],
                [
                    230,
                    " print_xml_row ( sql_file , \"key\" , result , & row , NullS ) ;\n"
                ],
                [
                    234,
                    " if ( keynr ++ ) putc ( ')' , sql_file ) ;\n"
                ],
                [
                    235,
                    " if ( atoi ( row [ 1 ] ) ) fprintf ( sql_file , \",\\n KEY %s (\" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n"
                ],
                [
                    236,
                    " else if ( keynr == primary_key ) fputs ( \",\\n PRIMARY KEY (\" , sql_file ) ;\n"
                ],
                [
                    237,
                    " else fprintf ( sql_file , \",\\n UNIQUE %s (\" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n"
                ],
                [
                    240,
                    " fputs ( quote_name ( row [ 4 ] , name_buff , 0 ) , sql_file ) ;\n"
                ],
                [
                    241,
                    " if ( row [ 7 ] ) fprintf ( sql_file , \" (%s)\" , row [ 7 ] ) ;\n"
                ],
                [
                    242,
                    " check_io ( sql_file ) ;\n"
                ],
                [
                    255,
                    " verbose_msg ( \"-- Warning: Couldn't get status information for \" \"table %s (%s)\\n\" , result_table , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    258,
                    " else if ( ! ( row = mysql_fetch_row ( result ) ) ) {\n"
                ],
                [
                    259,
                    " fprintf ( stderr , \"Error: Couldn't read status information for table %s (%s)\\n\" , result_table , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    262,
                    " if ( opt_xml ) print_xml_row ( sql_file , \"options\" , result , & row , NullS ) ;\n"
                ],
                [
                    265,
                    " print_value ( sql_file , result , row , \"engine=\" , \"Engine\" , 0 ) ;\n"
                ],
                [
                    266,
                    " print_value ( sql_file , result , row , \"\" , \"Create_options\" , 0 ) ;\n"
                ],
                [
                    267,
                    " print_value ( sql_file , result , row , \"comment=\" , \"Comment\" , 1 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void dump_table ( char * table , char * db ) {\n char ignore_flag ;\n char buf [ 200 ] , table_buff [ NAME_LEN + 3 ] ;\n DYNAMIC_STRING query_string ;\n char table_type [ NAME_LEN ] ;\n char * result_table , table_buff2 [ NAME_LEN * 2 + 3 ] , * opt_quoted_table ;\n int error = 0 ;\n ulong rownr , row_break , total_length , init_length ;\n uint num_fields ;\n MYSQL_RES * res ;\n MYSQL_FIELD * field ;\n MYSQL_ROW row ;\n DBUG_ENTER ( \"dump_table\" ) ;\n num_fields = get_table_structure ( table , db , table_type , & ignore_flag ) ;\n if ( strcmp ( table_type , \"VIEW\" ) == 0 ) DBUG_VOID_RETURN ;\n if ( opt_no_data ) {\n verbose_msg ( \"-- Skipping dump data for table '%s', --no-data was used\\n\" , table ) ;\n DBUG_VOID_RETURN ;\n }\n DBUG_PRINT ( \"info\" , ( \"ignore_flag: %x num_fields: %d\" , ( int ) ignore_flag , num_fields ) ) ;\n if ( ignore_flag & IGNORE_DATA ) {\n verbose_msg ( \"-- Warning: Skipping data for table '%s' because \" \"it's of type %s\\n\" , table , table_type ) ;\n DBUG_VOID_RETURN ;\n }\n if ( num_fields == 0 ) {\n verbose_msg ( \"-- Skipping dump data for table '%s', it has no fields\\n\" , table ) ;\n DBUG_VOID_RETURN ;\n }\n if ( ! opt_events && ! my_strcasecmp ( & my_charset_latin1 , db , \"mysql\" ) && ! my_strcasecmp ( & my_charset_latin1 , table , \"event\" ) ) {\n verbose_msg ( \"-- Skipping data table mysql.event, --skip-events was used\\n\" ) ;\n DBUG_VOID_RETURN ;\n }\n result_table = quote_name ( table , table_buff , 1 ) ;\n opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n verbose_msg ( \"-- Sending SELECT query...\\n\" ) ;\n init_dynamic_string_checked ( & query_string , \"\" , 1024 , 1024 ) ;\n if ( path ) {\n char filename [ FN_REFLEN ] , tmp_path [ FN_REFLEN ] ;\n convert_dirname ( tmp_path , path , NullS ) ;\n my_load_path ( tmp_path , tmp_path , NULL ) ;\n fn_format ( filename , table , tmp_path , \".txt\" , MYF ( MY_UNPACK_FILENAME ) ) ;\n my_delete ( filename , MYF ( 0 ) ) ;\n to_unix_path ( filename ) ;\n dynstr_append_checked ( & query_string , \"SELECT /*!40001 SQL_NO_CACHE */ * INTO OUTFILE '\" ) ;\n dynstr_append_checked ( & query_string , filename ) ;\n dynstr_append_checked ( & query_string , \"'\" ) ;\n dynstr_append_checked ( & query_string , \" /*!50138 CHARACTER SET \" ) ;\n dynstr_append_checked ( & query_string , default_charset == mysql_universal_client_charset ? my_charset_bin . name : default_charset ) ;\n dynstr_append_checked ( & query_string , \" */\" ) ;\n if ( fields_terminated || enclosed || opt_enclosed || escaped ) dynstr_append_checked ( & query_string , \" FIELDS\" ) ;\n add_load_option ( & query_string , \" TERMINATED BY \" , fields_terminated ) ;\n add_load_option ( & query_string , \" ENCLOSED BY \" , enclosed ) ;\n add_load_option ( & query_string , \" OPTIONALLY ENCLOSED BY \" , opt_enclosed ) ;\n add_load_option ( & query_string , \" ESCAPED BY \" , escaped ) ;\n add_load_option ( & query_string , \" LINES TERMINATED BY \" , lines_terminated ) ;\n dynstr_append_checked ( & query_string , \" FROM \" ) ;\n dynstr_append_checked ( & query_string , result_table ) ;\n if ( where ) {\n dynstr_append_checked ( & query_string , \" WHERE \" ) ;\n dynstr_append_checked ( & query_string , where ) ;\n }\n if ( order_by ) {\n dynstr_append_checked ( & query_string , \" ORDER BY \" ) ;\n dynstr_append_checked ( & query_string , order_by ) ;\n }\n if ( mysql_real_query ( mysql , query_string . str , query_string . length ) ) {\n DB_error ( mysql , \"when executing 'SELECT INTO OUTFILE'\" ) ;\n dynstr_free ( & query_string ) ;\n DBUG_VOID_RETURN ;\n }\n }\n else {\n print_comment ( md_result_file , 0 , \"\\n--\\n-- Dumping data for table %s\\n--\\n\" , result_table ) ;\n dynstr_append_checked ( & query_string , \"SELECT /*!40001 SQL_NO_CACHE */ * FROM \" ) ;\n dynstr_append_checked ( & query_string , result_table ) ;\n if ( where ) {\n print_comment ( md_result_file , 0 , \"-- WHERE: %s\\n\" , where ) ;\n dynstr_append_checked ( & query_string , \" WHERE \" ) ;\n dynstr_append_checked ( & query_string , where ) ;\n }\n if ( order_by ) {\n print_comment ( md_result_file , 0 , \"-- ORDER BY: %s\\n\" , order_by ) ;\n dynstr_append_checked ( & query_string , \" ORDER BY \" ) ;\n dynstr_append_checked ( & query_string , order_by ) ;\n }\n if ( ! opt_xml && ! opt_compact ) {\n fputs ( \"\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n if ( mysql_query_with_error_report ( mysql , 0 , query_string . str ) ) {\n DB_error ( mysql , \"when retrieving data from server\" ) ;\n goto err ;\n }\n if ( quick ) res = mysql_use_result ( mysql ) ;\n else res = mysql_store_result ( mysql ) ;\n if ( ! res ) {\n DB_error ( mysql , \"when retrieving data from server\" ) ;\n goto err ;\n }\n verbose_msg ( \"-- Retrieving rows...\\n\" ) ;\n if ( mysql_num_fields ( res ) != num_fields ) {\n fprintf ( stderr , \"%s: Error in field count for table: %s ! Aborting.\\n\" , my_progname_short , result_table ) ;\n error = EX_CONSCHECK ;\n goto err ;\n }\n if ( opt_lock ) {\n fprintf ( md_result_file , \"LOCK TABLES %s WRITE;\n\\n\" , opt_quoted_table ) ;\n check_io ( md_result_file ) ;\n }\n if ( opt_disable_keys ) {\n fprintf ( md_result_file , \"/*!40000 ALTER TABLE %s DISABLE KEYS */;\n\\n\" , opt_quoted_table ) ;\n check_io ( md_result_file ) ;\n }\n total_length = opt_net_buffer_length ;\n row_break = 0 ;\n rownr = 0 ;\n init_length = ( uint ) insert_pat . length + 4 ;\n if ( opt_xml ) print_xml_tag ( md_result_file , \"\\t\" , \"\\n\" , \"table_data\" , \"name=\" , table , NullS ) ;\n if ( opt_autocommit ) {\n fprintf ( md_result_file , \"set autocommit=0;\n\\n\" ) ;\n check_io ( md_result_file ) ;\n }\n while ( ( row = mysql_fetch_row ( res ) ) ) {\n uint i ;\n ulong * lengths = mysql_fetch_lengths ( res ) ;\n rownr ++ ;\n if ( ! extended_insert && ! opt_xml ) {\n fputs ( insert_pat . str , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n mysql_field_seek ( res , 0 ) ;\n if ( opt_xml ) {\n fputs ( \"\\t<row>\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n for ( i = 0 ;\n i < mysql_num_fields ( res ) ;\n i ++ ) {\n int is_blob ;\n ulong length = lengths [ i ] ;\n if ( ! ( field = mysql_fetch_field ( res ) ) ) die ( EX_CONSCHECK , \"Not enough fields from table %s! Aborting.\\n\" , result_table ) ;\n is_blob = ( opt_hex_blob && field -> charsetnr == 63 && ( field -> type == MYSQL_TYPE_BIT || field -> type == MYSQL_TYPE_STRING || field -> type == MYSQL_TYPE_VAR_STRING || field -> type == MYSQL_TYPE_VARCHAR || field -> type == MYSQL_TYPE_BLOB || field -> type == MYSQL_TYPE_LONG_BLOB || field -> type == MYSQL_TYPE_MEDIUM_BLOB || field -> type == MYSQL_TYPE_TINY_BLOB || field -> type == MYSQL_TYPE_GEOMETRY ) ) ? 1 : 0 ;\n if ( extended_insert && ! opt_xml ) {\n if ( i == 0 ) dynstr_set_checked ( & extended_row , \"(\" ) ;\n else dynstr_append_checked ( & extended_row , \",\" ) ;\n if ( row [ i ] ) {\n if ( length ) {\n if ( ! ( field -> flags & NUM_FLAG ) ) {\n dynstr_realloc_checked ( & extended_row , length * 2 + 2 + 1 ) ;\n if ( opt_hex_blob && is_blob ) {\n dynstr_append_checked ( & extended_row , \"0x\" ) ;\n extended_row . length += mysql_hex_string ( extended_row . str + extended_row . length , row [ i ] , length ) ;\n DBUG_ASSERT ( extended_row . length + 1 <= extended_row . max_length ) ;\n DBUG_ASSERT ( extended_row . str [ extended_row . length ] == '\\0' ) ;\n }\n else {\n dynstr_append_checked ( & extended_row , \"'\" ) ;\n extended_row . length += mysql_real_escape_string ( & mysql_connection , & extended_row . str [ extended_row . length ] , row [ i ] , length ) ;\n extended_row . str [ extended_row . length ] = '\\0' ;\n dynstr_append_checked ( & extended_row , \"'\" ) ;\n }\n }\n else {\n char * ptr = row [ i ] ;\n if ( my_isalpha ( charset_info , * ptr ) || ( * ptr == '-' && my_isalpha ( charset_info , ptr [ 1 ] ) ) ) dynstr_append_checked ( & extended_row , \"NULL\" ) ;\n else {\n if ( field -> type == MYSQL_TYPE_DECIMAL ) {\n dynstr_append_checked ( & extended_row , \"'\" ) ;\n dynstr_append_checked ( & extended_row , ptr ) ;\n dynstr_append_checked ( & extended_row , \"'\" ) ;\n }\n else dynstr_append_checked ( & extended_row , ptr ) ;\n }\n }\n }\n else dynstr_append_checked ( & extended_row , \"''\" ) ;\n }\n else dynstr_append_checked ( & extended_row , \"NULL\" ) ;\n }\n else {\n if ( i && ! opt_xml ) {\n fputc ( ',' , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n if ( row [ i ] ) {\n if ( ! ( field -> flags & NUM_FLAG ) ) {\n if ( opt_xml ) {\n if ( opt_hex_blob && is_blob && length ) {\n print_xml_tag ( md_result_file , \"\\t\\t\" , \"\" , \"field\" , \"name=\" , field -> name , \"xsi:type=\" , \"xs:hexBinary\" , NullS ) ;\n print_blob_as_hex ( md_result_file , row [ i ] , length ) ;\n }\n else {\n print_xml_tag ( md_result_file , \"\\t\\t\" , \"\" , \"field\" , \"name=\" , field -> name , NullS ) ;\n print_quoted_xml ( md_result_file , row [ i ] , length , 0 ) ;\n }\n fputs ( \"</field>\\n\" , md_result_file ) ;\n }\n else if ( opt_hex_blob && is_blob && length ) {\n fputs ( \"0x\" , md_result_file ) ;\n print_blob_as_hex ( md_result_file , row [ i ] , length ) ;\n }\n else unescape ( md_result_file , row [ i ] , length ) ;\n }\n else {\n char * ptr = row [ i ] ;\n if ( opt_xml ) {\n print_xml_tag ( md_result_file , \"\\t\\t\" , \"\" , \"field\" , \"name=\" , field -> name , NullS ) ;\n fputs ( ! my_isalpha ( charset_info , * ptr ) ? ptr : \"NULL\" , md_result_file ) ;\n fputs ( \"</field>\\n\" , md_result_file ) ;\n }\n else if ( my_isalpha ( charset_info , * ptr ) || ( * ptr == '-' && my_isalpha ( charset_info , ptr [ 1 ] ) ) ) fputs ( \"NULL\" , md_result_file ) ;\n else if ( field -> type == MYSQL_TYPE_DECIMAL ) {\n fputc ( '\\'' , md_result_file ) ;\n fputs ( ptr , md_result_file ) ;\n fputc ( '\\'' , md_result_file ) ;\n }\n else fputs ( ptr , md_result_file ) ;\n }\n }\n else {\n if ( ! opt_xml ) fputs ( \"NULL\" , md_result_file ) ;\n else print_xml_null_tag ( md_result_file , \"\\t\\t\" , \"field name=\" , field -> name , \"\\n\" ) ;\n }\n check_io ( md_result_file ) ;\n }\n }\n if ( opt_xml ) {\n fputs ( \"\\t</row>\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n if ( extended_insert ) {\n ulong row_length ;\n dynstr_append_checked ( & extended_row , \")\" ) ;\n row_length = 2 + extended_row . length ;\n if ( total_length + row_length < opt_net_buffer_length ) {\n total_length += row_length ;\n fputc ( ',' , md_result_file ) ;\n fputs ( extended_row . str , md_result_file ) ;\n }\n else {\n if ( row_break ) fputs ( \";\n\\n\" , md_result_file ) ;\n row_break = 1 ;\n fputs ( insert_pat . str , md_result_file ) ;\n fputs ( extended_row . str , md_result_file ) ;\n total_length = row_length + init_length ;\n }\n check_io ( md_result_file ) ;\n }\n else if ( ! opt_xml ) {\n fputs ( \");\n\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n }\n if ( opt_xml ) fputs ( \"\\t</table_data>\\n\" , md_result_file ) ;\n else if ( extended_insert && row_break ) fputs ( \";\n\\n\" , md_result_file ) ;\n fflush ( md_result_file ) ;\n check_io ( md_result_file ) ;\n if ( mysql_errno ( mysql ) ) {\n my_snprintf ( buf , sizeof ( buf ) , \"%s: Error %d: %s when dumping table %s at row: %ld\\n\" , my_progname_short , mysql_errno ( mysql ) , mysql_error ( mysql ) , result_table , rownr ) ;\n fputs ( buf , stderr ) ;\n error = EX_CONSCHECK ;\n goto err ;\n }\n if ( opt_disable_keys ) {\n fprintf ( md_result_file , \"/*!40000 ALTER TABLE %s ENABLE KEYS */;\n\\n\" , opt_quoted_table ) ;\n check_io ( md_result_file ) ;\n }\n if ( opt_lock ) {\n fputs ( \"UNLOCK TABLES;\n\\n\" , md_result_file ) ;\n check_io ( md_result_file ) ;\n }\n if ( opt_autocommit ) {\n fprintf ( md_result_file , \"commit;\n\\n\" ) ;\n check_io ( md_result_file ) ;\n }\n mysql_free_result ( res ) ;\n }\n dynstr_free ( & query_string ) ;\n DBUG_VOID_RETURN ;\n err : dynstr_free ( & query_string ) ;\n maybe_exit ( error ) ;\n DBUG_VOID_RETURN ;\n }",
        "hash": 6667142528452941476,
        "project": "debian",
        "size": 292,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static void dump_table ( char * table , char * db ) {\n"
                ],
                [
                    14,
                    " num_fields = get_table_structure ( table , db , table_type , & ignore_flag ) ;\n"
                ],
                [
                    15,
                    " if ( strcmp ( table_type , \"VIEW\" ) == 0 ) DBUG_VOID_RETURN ;\n"
                ],
                [
                    22,
                    " verbose_msg ( \"-- Warning: Skipping data for table '%s' because \" \"it's of type %s\\n\" , table , table_type ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void dump_table ( char * table , char * db ) {\n"
                ],
                [
                    75,
                    " dynstr_append_checked ( & query_string , result_table ) ;\n"
                ],
                [
                    101,
                    " if ( mysql_num_fields ( res ) != num_fields ) {\n"
                ],
                [
                    102,
                    " fprintf ( stderr , \"%s: Error in field count for table: %s ! Aborting.\\n\" , my_progname_short , result_table ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void dump_table ( char * table , char * db ) {\n"
                ],
                [
                    14,
                    " num_fields = get_table_structure ( table , db , table_type , & ignore_flag ) ;\n"
                ],
                [
                    15,
                    " if ( strcmp ( table_type , \"VIEW\" ) == 0 ) DBUG_VOID_RETURN ;\n"
                ],
                [
                    22,
                    " verbose_msg ( \"-- Warning: Skipping data for table '%s' because \" \"it's of type %s\\n\" , table , table_type ) ;\n"
                ],
                [
                    75,
                    " dynstr_append_checked ( & query_string , result_table ) ;\n"
                ],
                [
                    101,
                    " if ( mysql_num_fields ( res ) != num_fields ) {\n"
                ],
                [
                    102,
                    " fprintf ( stderr , \"%s: Error in field count for table: %s ! Aborting.\\n\" , my_progname_short , result_table ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int dump_tablespaces ( char * ts_where ) {\n MYSQL_ROW row ;\n MYSQL_RES * tableres ;\n char buf [ FN_REFLEN ] ;\n DYNAMIC_STRING sqlbuf ;\n int first = 0 ;\n char extra_format [ ] = \"UNDO_BUFFER_SIZE=\" ;\n char * ubs ;\n char * endsemi ;\n DBUG_ENTER ( \"dump_tablespaces\" ) ;\n mysql_query ( mysql , \"set optimizer_switch='semijoin=off'\" ) ;\n init_dynamic_string_checked ( & sqlbuf , \"SELECT LOGFILE_GROUP_NAME,\" \" FILE_NAME,\" \" TOTAL_EXTENTS,\" \" INITIAL_SIZE,\" \" ENGINE,\" \" EXTRA\" \" FROM INFORMATION_SCHEMA.FILES\" \" WHERE FILE_TYPE = 'UNDO LOG'\" \" AND FILE_NAME IS NOT NULL\" , 256 , 1024 ) ;\n if ( ts_where ) {\n dynstr_append_checked ( & sqlbuf , \" AND LOGFILE_GROUP_NAME IN (\" \"SELECT DISTINCT LOGFILE_GROUP_NAME\" \" FROM INFORMATION_SCHEMA.FILES\" \" WHERE FILE_TYPE = 'DATAFILE'\" ) ;\n dynstr_append_checked ( & sqlbuf , ts_where ) ;\n dynstr_append_checked ( & sqlbuf , \")\" ) ;\n }\n dynstr_append_checked ( & sqlbuf , \" GROUP BY LOGFILE_GROUP_NAME, FILE_NAME\" \", ENGINE\" \" ORDER BY LOGFILE_GROUP_NAME\" ) ;\n if ( mysql_query ( mysql , sqlbuf . str ) || ! ( tableres = mysql_store_result ( mysql ) ) ) {\n dynstr_free ( & sqlbuf ) ;\n if ( mysql_errno ( mysql ) == ER_BAD_TABLE_ERROR || mysql_errno ( mysql ) == ER_BAD_DB_ERROR || mysql_errno ( mysql ) == ER_UNKNOWN_TABLE ) {\n fprintf ( md_result_file , \"\\n--\\n-- Not dumping tablespaces as no INFORMATION_SCHEMA.FILES\" \" table on this server\\n--\\n\" ) ;\n check_io ( md_result_file ) ;\n DBUG_RETURN ( 0 ) ;\n }\n fprintf ( stderr , \"%s: Error: '%s' when trying to dump tablespaces\\n\" , my_progname_short , mysql_error ( mysql ) ) ;\n DBUG_RETURN ( 1 ) ;\n }\n buf [ 0 ] = 0 ;\n while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n if ( first ) {\n print_comment ( md_result_file , 0 , \"\\n--\\n-- Logfile group: %s\\n--\\n\" , row [ 0 ] ) ;\n fprintf ( md_result_file , \"\\nCREATE\" ) ;\n }\n else {\n fprintf ( md_result_file , \"\\nALTER\" ) ;\n }\n fprintf ( md_result_file , \" LOGFILE GROUP %s\\n\" \" ADD UNDOFILE '%s'\\n\" , row [ 0 ] , row [ 1 ] ) ;\n if ( first ) {\n ubs = strstr ( row [ 5 ] , extra_format ) ;\n if ( ! ubs ) break ;\n ubs += strlen ( extra_format ) ;\n endsemi = strstr ( ubs , \";\n\" ) ;\n if ( endsemi ) endsemi [ 0 ] = '\\0' ;\n fprintf ( md_result_file , \" UNDO_BUFFER_SIZE %s\\n\" , ubs ) ;\n }\n fprintf ( md_result_file , \" INITIAL_SIZE %s\\n\" \" ENGINE=%s;\n\\n\" , row [ 3 ] , row [ 4 ] ) ;\n check_io ( md_result_file ) ;\n if ( first ) {\n first = 0 ;\n strxmov ( buf , row [ 0 ] , NullS ) ;\n }\n }\n dynstr_free ( & sqlbuf ) ;\n mysql_free_result ( tableres ) ;\n init_dynamic_string_checked ( & sqlbuf , \"SELECT DISTINCT TABLESPACE_NAME,\" \" FILE_NAME,\" \" LOGFILE_GROUP_NAME,\" \" EXTENT_SIZE,\" \" INITIAL_SIZE,\" \" ENGINE\" \" FROM INFORMATION_SCHEMA.FILES\" \" WHERE FILE_TYPE = 'DATAFILE'\" , 256 , 1024 ) ;\n if ( ts_where ) dynstr_append_checked ( & sqlbuf , ts_where ) ;\n dynstr_append_checked ( & sqlbuf , \" ORDER BY TABLESPACE_NAME, LOGFILE_GROUP_NAME\" ) ;\n if ( mysql_query_with_error_report ( mysql , & tableres , sqlbuf . str ) ) {\n dynstr_free ( & sqlbuf ) ;\n DBUG_RETURN ( 1 ) ;\n }\n buf [ 0 ] = 0 ;\n while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n if ( first ) {\n print_comment ( md_result_file , 0 , \"\\n--\\n-- Tablespace: %s\\n--\\n\" , row [ 0 ] ) ;\n fprintf ( md_result_file , \"\\nCREATE\" ) ;\n }\n else {\n fprintf ( md_result_file , \"\\nALTER\" ) ;\n }\n fprintf ( md_result_file , \" TABLESPACE %s\\n\" \" ADD DATAFILE '%s'\\n\" , row [ 0 ] , row [ 1 ] ) ;\n if ( first ) {\n fprintf ( md_result_file , \" USE LOGFILE GROUP %s\\n\" \" EXTENT_SIZE %s\\n\" , row [ 2 ] , row [ 3 ] ) ;\n }\n fprintf ( md_result_file , \" INITIAL_SIZE %s\\n\" \" ENGINE=%s;\n\\n\" , row [ 4 ] , row [ 5 ] ) ;\n check_io ( md_result_file ) ;\n if ( first ) {\n first = 0 ;\n strxmov ( buf , row [ 0 ] , NullS ) ;\n }\n }\n mysql_free_result ( tableres ) ;\n dynstr_free ( & sqlbuf ) ;\n mysql_query ( mysql , \"set optimizer_switch=default\" ) ;\n DBUG_RETURN ( 0 ) ;\n }",
        "hash": 6667142528452941476,
        "project": "debian",
        "size": 92,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int dump_tablespaces ( char * ts_where ) {\n"
                ],
                [
                    4,
                    " char buf [ FN_REFLEN ] ;\n"
                ],
                [
                    29,
                    " buf [ 0 ] = 0 ;\n"
                ],
                [
                    30,
                    " while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n"
                ],
                [
                    31,
                    " if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n"
                ],
                [
                    33,
                    " print_comment ( md_result_file , 0 , \"\\n--\\n-- Logfile group: %s\\n--\\n\" , row [ 0 ] ) ;\n"
                ],
                [
                    39,
                    " fprintf ( md_result_file , \" LOGFILE GROUP %s\\n\" \" ADD UNDOFILE '%s'\\n\" , row [ 0 ] , row [ 1 ] ) ;\n"
                ],
                [
                    54,
                    " strxmov ( buf , row [ 0 ] , NullS ) ;\n"
                ],
                [
                    66,
                    " buf [ 0 ] = 0 ;\n"
                ],
                [
                    67,
                    " while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n"
                ],
                [
                    68,
                    " if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n"
                ],
                [
                    70,
                    " print_comment ( md_result_file , 0 , \"\\n--\\n-- Tablespace: %s\\n--\\n\" , row [ 0 ] ) ;\n"
                ],
                [
                    76,
                    " fprintf ( md_result_file , \" TABLESPACE %s\\n\" \" ADD DATAFILE '%s'\\n\" , row [ 0 ] , row [ 1 ] ) ;\n"
                ],
                [
                    85,
                    " strxmov ( buf , row [ 0 ] , NullS ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static int dump_tablespaces ( char * ts_where ) {\n"
                ],
                [
                    41,
                    " ubs = strstr ( row [ 5 ] , extra_format ) ;\n"
                ],
                [
                    42,
                    " if ( ! ubs ) break ;\n"
                ],
                [
                    43,
                    " ubs += strlen ( extra_format ) ;\n"
                ],
                [
                    47,
                    " fprintf ( md_result_file , \" UNDO_BUFFER_SIZE %s\\n\" , ubs ) ;\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "static int dump_tablespaces ( char * ts_where ) {\n"
                ],
                [
                    7,
                    " char extra_format [ ] = \"UNDO_BUFFER_SIZE=\" ;\n"
                ],
                [
                    30,
                    " while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n"
                ],
                [
                    40,
                    " if ( first ) {\n"
                ],
                [
                    41,
                    " ubs = strstr ( row [ 5 ] , extra_format ) ;\n"
                ],
                [
                    42,
                    " if ( ! ubs ) break ;\n"
                ],
                [
                    43,
                    " ubs += strlen ( extra_format ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static int dump_tablespaces ( char * ts_where ) {\n"
                ],
                [
                    19,
                    " if ( mysql_query ( mysql , sqlbuf . str ) || ! ( tableres = mysql_store_result ( mysql ) ) ) {\n"
                ],
                [
                    21,
                    " if ( mysql_errno ( mysql ) == ER_BAD_TABLE_ERROR || mysql_errno ( mysql ) == ER_BAD_DB_ERROR || mysql_errno ( mysql ) == ER_UNKNOWN_TABLE ) {\n"
                ],
                [
                    22,
                    " fprintf ( md_result_file , \"\\n--\\n-- Not dumping tablespaces as no INFORMATION_SCHEMA.FILES\" \" table on this server\\n--\\n\" ) ;\n"
                ],
                [
                    23,
                    " check_io ( md_result_file ) ;\n"
                ],
                [
                    26,
                    " fprintf ( stderr , \"%s: Error: '%s' when trying to dump tablespaces\\n\" , my_progname_short , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    30,
                    " while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n"
                ],
                [
                    31,
                    " if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n"
                ],
                [
                    32,
                    " if ( first ) {\n"
                ],
                [
                    33,
                    " print_comment ( md_result_file , 0 , \"\\n--\\n-- Logfile group: %s\\n--\\n\" , row [ 0 ] ) ;\n"
                ],
                [
                    34,
                    " fprintf ( md_result_file , \"\\nCREATE\" ) ;\n"
                ],
                [
                    37,
                    " fprintf ( md_result_file , \"\\nALTER\" ) ;\n"
                ],
                [
                    39,
                    " fprintf ( md_result_file , \" LOGFILE GROUP %s\\n\" \" ADD UNDOFILE '%s'\\n\" , row [ 0 ] , row [ 1 ] ) ;\n"
                ],
                [
                    42,
                    " if ( ! ubs ) break ;\n"
                ],
                [
                    43,
                    " ubs += strlen ( extra_format ) ;\n"
                ],
                [
                    47,
                    " fprintf ( md_result_file , \" UNDO_BUFFER_SIZE %s\\n\" , ubs ) ;\n"
                ],
                [
                    54,
                    " strxmov ( buf , row [ 0 ] , NullS ) ;\n"
                ],
                [
                    67,
                    " while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n"
                ],
                [
                    68,
                    " if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n"
                ],
                [
                    69,
                    " if ( first ) {\n"
                ],
                [
                    70,
                    " print_comment ( md_result_file , 0 , \"\\n--\\n-- Tablespace: %s\\n--\\n\" , row [ 0 ] ) ;\n"
                ],
                [
                    71,
                    " fprintf ( md_result_file , \"\\nCREATE\" ) ;\n"
                ],
                [
                    74,
                    " fprintf ( md_result_file , \"\\nALTER\" ) ;\n"
                ],
                [
                    76,
                    " fprintf ( md_result_file , \" TABLESPACE %s\\n\" \" ADD DATAFILE '%s'\\n\" , row [ 0 ] , row [ 1 ] ) ;\n"
                ],
                [
                    77,
                    " if ( first ) {\n"
                ],
                [
                    78,
                    " fprintf ( md_result_file , \" USE LOGFILE GROUP %s\\n\" \" EXTENT_SIZE %s\\n\" , row [ 2 ] , row [ 3 ] ) ;\n"
                ],
                [
                    85,
                    " strxmov ( buf , row [ 0 ] , NullS ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int dump_tablespaces ( char * ts_where ) {\n"
                ],
                [
                    4,
                    " char buf [ FN_REFLEN ] ;\n"
                ],
                [
                    7,
                    " char extra_format [ ] = \"UNDO_BUFFER_SIZE=\" ;\n"
                ],
                [
                    19,
                    " if ( mysql_query ( mysql , sqlbuf . str ) || ! ( tableres = mysql_store_result ( mysql ) ) ) {\n"
                ],
                [
                    21,
                    " if ( mysql_errno ( mysql ) == ER_BAD_TABLE_ERROR || mysql_errno ( mysql ) == ER_BAD_DB_ERROR || mysql_errno ( mysql ) == ER_UNKNOWN_TABLE ) {\n"
                ],
                [
                    22,
                    " fprintf ( md_result_file , \"\\n--\\n-- Not dumping tablespaces as no INFORMATION_SCHEMA.FILES\" \" table on this server\\n--\\n\" ) ;\n"
                ],
                [
                    23,
                    " check_io ( md_result_file ) ;\n"
                ],
                [
                    26,
                    " fprintf ( stderr , \"%s: Error: '%s' when trying to dump tablespaces\\n\" , my_progname_short , mysql_error ( mysql ) ) ;\n"
                ],
                [
                    29,
                    " buf [ 0 ] = 0 ;\n"
                ],
                [
                    30,
                    " while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n"
                ],
                [
                    31,
                    " if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n"
                ],
                [
                    32,
                    " if ( first ) {\n"
                ],
                [
                    33,
                    " print_comment ( md_result_file , 0 , \"\\n--\\n-- Logfile group: %s\\n--\\n\" , row [ 0 ] ) ;\n"
                ],
                [
                    34,
                    " fprintf ( md_result_file , \"\\nCREATE\" ) ;\n"
                ],
                [
                    37,
                    " fprintf ( md_result_file , \"\\nALTER\" ) ;\n"
                ],
                [
                    39,
                    " fprintf ( md_result_file , \" LOGFILE GROUP %s\\n\" \" ADD UNDOFILE '%s'\\n\" , row [ 0 ] , row [ 1 ] ) ;\n"
                ],
                [
                    40,
                    " if ( first ) {\n"
                ],
                [
                    41,
                    " ubs = strstr ( row [ 5 ] , extra_format ) ;\n"
                ],
                [
                    42,
                    " if ( ! ubs ) break ;\n"
                ],
                [
                    43,
                    " ubs += strlen ( extra_format ) ;\n"
                ],
                [
                    47,
                    " fprintf ( md_result_file , \" UNDO_BUFFER_SIZE %s\\n\" , ubs ) ;\n"
                ],
                [
                    54,
                    " strxmov ( buf , row [ 0 ] , NullS ) ;\n"
                ],
                [
                    66,
                    " buf [ 0 ] = 0 ;\n"
                ],
                [
                    67,
                    " while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n"
                ],
                [
                    68,
                    " if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n"
                ],
                [
                    69,
                    " if ( first ) {\n"
                ],
                [
                    70,
                    " print_comment ( md_result_file , 0 , \"\\n--\\n-- Tablespace: %s\\n--\\n\" , row [ 0 ] ) ;\n"
                ],
                [
                    71,
                    " fprintf ( md_result_file , \"\\nCREATE\" ) ;\n"
                ],
                [
                    74,
                    " fprintf ( md_result_file , \"\\nALTER\" ) ;\n"
                ],
                [
                    76,
                    " fprintf ( md_result_file , \" TABLESPACE %s\\n\" \" ADD DATAFILE '%s'\\n\" , row [ 0 ] , row [ 1 ] ) ;\n"
                ],
                [
                    77,
                    " if ( first ) {\n"
                ],
                [
                    78,
                    " fprintf ( md_result_file , \" USE LOGFILE GROUP %s\\n\" \" EXTENT_SIZE %s\\n\" , row [ 2 ] , row [ 3 ] ) ;\n"
                ],
                [
                    85,
                    " strxmov ( buf , row [ 0 ] , NullS ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static uint dump_events_for_db ( char * db ) {\n char query_buff [ QUERY_LENGTH ] ;\n char db_name_buff [ NAME_LEN * 2 + 3 ] , name_buff [ NAME_LEN * 2 + 3 ] ;\n char * event_name ;\n char delimiter [ QUERY_LENGTH ] ;\n FILE * sql_file = md_result_file ;\n MYSQL_RES * event_res , * event_list_res ;\n MYSQL_ROW row , event_list_row ;\n char db_cl_name [ MY_CS_NAME_SIZE ] ;\n int db_cl_altered = FALSE ;\n DBUG_ENTER ( \"dump_events_for_db\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"db: '%s'\" , db ) ) ;\n mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n print_comment ( sql_file , 0 , \"\\n--\\n-- Dumping events for database '%s'\\n--\\n\" , db ) ;\n if ( lock_tables ) mysql_query ( mysql , \"LOCK TABLES mysql.event READ\" ) ;\n if ( mysql_query_with_error_report ( mysql , & event_list_res , \"show events\" ) ) DBUG_RETURN ( 0 ) ;\n strcpy ( delimiter , \";\n\" ) ;\n if ( mysql_num_rows ( event_list_res ) > 0 ) {\n if ( opt_xml ) fputs ( \"\\t<events>\\n\" , sql_file ) ;\n else {\n fprintf ( sql_file , \"/*!50106 SET @save_time_zone= @@TIME_ZONE */ ;\n\\n\" ) ;\n if ( fetch_db_collation ( db_name_buff , db_cl_name , sizeof ( db_cl_name ) ) ) DBUG_RETURN ( 1 ) ;\n }\n if ( switch_character_set_results ( mysql , \"binary\" ) ) DBUG_RETURN ( 1 ) ;\n while ( ( event_list_row = mysql_fetch_row ( event_list_res ) ) != NULL ) {\n event_name = quote_name ( event_list_row [ 1 ] , name_buff , 0 ) ;\n DBUG_PRINT ( \"info\" , ( \"retrieving CREATE EVENT for %s\" , name_buff ) ) ;\n my_snprintf ( query_buff , sizeof ( query_buff ) , \"SHOW CREATE EVENT %s\" , event_name ) ;\n if ( mysql_query_with_error_report ( mysql , & event_res , query_buff ) ) DBUG_RETURN ( 1 ) ;\n while ( ( row = mysql_fetch_row ( event_res ) ) != NULL ) {\n if ( opt_xml ) {\n print_xml_row ( sql_file , \"event\" , event_res , & row , \"Create Event\" ) ;\n continue ;\n }\n if ( strlen ( row [ 3 ] ) != 0 ) {\n char * query_str ;\n if ( opt_drop ) fprintf ( sql_file , \"/*!50106 DROP EVENT IF EXISTS %s */%s\\n\" , event_name , delimiter ) ;\n if ( create_delimiter ( row [ 3 ] , delimiter , sizeof ( delimiter ) ) == NULL ) {\n fprintf ( stderr , \"%s: Warning: Can't create delimiter for event '%s'\\n\" , my_progname_short , event_name ) ;\n DBUG_RETURN ( 1 ) ;\n }\n fprintf ( sql_file , \"DELIMITER %s\\n\" , delimiter ) ;\n if ( mysql_num_fields ( event_res ) >= 7 ) {\n if ( switch_db_collation ( sql_file , db_name_buff , delimiter , db_cl_name , row [ 6 ] , & db_cl_altered ) ) {\n DBUG_RETURN ( 1 ) ;\n }\n switch_cs_variables ( sql_file , delimiter , row [ 4 ] , row [ 4 ] , row [ 5 ] ) ;\n }\n else {\n fprintf ( sql_file , \"--\\n\" \"-- WARNING: old server version. \" \"The following dump may be incomplete.\\n\" \"--\\n\" ) ;\n }\n switch_sql_mode ( sql_file , delimiter , row [ 1 ] ) ;\n switch_time_zone ( sql_file , delimiter , row [ 2 ] ) ;\n query_str = cover_definer_clause ( row [ 3 ] , strlen ( row [ 3 ] ) , C_STRING_WITH_LEN ( \"50117\" ) , C_STRING_WITH_LEN ( \"50106\" ) , C_STRING_WITH_LEN ( \" EVENT\" ) ) ;\n fprintf ( sql_file , \"/*!50106 %s */ %s\\n\" , ( const char * ) ( query_str != NULL ? query_str : row [ 3 ] ) , ( const char * ) delimiter ) ;\n my_free ( query_str ) ;\n restore_time_zone ( sql_file , delimiter ) ;\n restore_sql_mode ( sql_file , delimiter ) ;\n if ( mysql_num_fields ( event_res ) >= 7 ) {\n restore_cs_variables ( sql_file , delimiter ) ;\n if ( db_cl_altered ) {\n if ( restore_db_collation ( sql_file , db_name_buff , delimiter , db_cl_name ) ) DBUG_RETURN ( 1 ) ;\n }\n }\n }\n }\n mysql_free_result ( event_res ) ;\n }\n if ( opt_xml ) {\n fputs ( \"\\t</events>\\n\" , sql_file ) ;\n check_io ( sql_file ) ;\n }\n else {\n fprintf ( sql_file , \"DELIMITER ;\n\\n\" ) ;\n fprintf ( sql_file , \"/*!50106 SET TIME_ZONE= @save_time_zone */ ;\n\\n\" ) ;\n }\n if ( switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 1 ) ;\n }\n mysql_free_result ( event_list_res ) ;\n if ( lock_tables ) ( void ) mysql_query_with_error_report ( mysql , 0 , \"UNLOCK TABLES\" ) ;\n DBUG_RETURN ( 0 ) ;\n }",
        "hash": 6667142528452941476,
        "project": "debian",
        "size": 86,
        "slice": {
            "strlen": [
                [
                    1,
                    "static uint dump_events_for_db ( char * db ) {\n"
                ],
                [
                    12,
                    " DBUG_PRINT ( \"enter\" , ( \"db: '%s'\" , db ) ) ;\n"
                ],
                [
                    13,
                    " mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static uint dump_events_for_db ( char * db ) {\n"
                ],
                [
                    12,
                    " DBUG_PRINT ( \"enter\" , ( \"db: '%s'\" , db ) ) ;\n"
                ],
                [
                    13,
                    " mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * * argv ) {\n gpg_error_t err ;\n if ( argc ) {\n argc -- ;\n argv ++ ;\n }\n if ( argc ) {\n unsigned char * buffer ;\n size_t n , buflen ;\n for ( ;\n argc ;\n argc -- , argv ++ ) {\n err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n if ( err ) {\n fprintf ( stderr , \"can't convert `%s': %s\\n\" , * argv , gpg_strerror ( err ) ) ;\n return 1 ;\n }\n printf ( \"%s ->\" , * argv ) ;\n for ( n = 0 ;\n n < buflen ;\n n ++ ) printf ( \" %02X\" , buffer [ n ] ) ;\n putchar ( '\\n' ) ;\n free ( buffer ) ;\n }\n }\n else {\n char * buffer ;\n size_t buflen ;\n char * result ;\n buffer = read_into_buffer ( stdin , & buflen ) ;\n result = ksba_oid_to_str ( buffer , buflen ) ;\n free ( buffer ) ;\n printf ( \"%s\\n\" , result ? result : \"[malloc failed]\" ) ;\n free ( result ) ;\n }\n return 0 ;\n }",
        "hash": -571446645408709055,
        "project": "debian",
        "size": 37,
        "slice": {
            "printf": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    7,
                    " if ( argc ) {\n"
                ],
                [
                    12,
                    " argc -- , argv ++ ) {\n"
                ],
                [
                    13,
                    " err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n"
                ],
                [
                    14,
                    " if ( err ) {\n"
                ],
                [
                    18,
                    " printf ( \"%s ->\" , * argv ) ;\n"
                ],
                [
                    20,
                    " n < buflen ;\n"
                ],
                [
                    21,
                    " n ++ ) printf ( \" %02X\" , buffer [ n ] ) ;\n"
                ],
                [
                    23,
                    " free ( buffer ) ;\n"
                ],
                [
                    31,
                    " result = ksba_oid_to_str ( buffer , buflen ) ;\n"
                ],
                [
                    33,
                    " printf ( \"%s\\n\" , result ? result : \"[malloc failed]\" ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    13,
                    " err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n"
                ],
                [
                    14,
                    " if ( err ) {\n"
                ],
                [
                    15,
                    " fprintf ( stderr , \"can't convert `%s': %s\\n\" , * argv , gpg_strerror ( err ) ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    7,
                    " if ( argc ) {\n"
                ],
                [
                    13,
                    " err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n"
                ],
                [
                    14,
                    " if ( err ) {\n"
                ],
                [
                    21,
                    " n ++ ) printf ( \" %02X\" , buffer [ n ] ) ;\n"
                ],
                [
                    23,
                    " free ( buffer ) ;\n"
                ],
                [
                    31,
                    " result = ksba_oid_to_str ( buffer , buflen ) ;\n"
                ],
                [
                    32,
                    " free ( buffer ) ;\n"
                ],
                [
                    34,
                    " free ( result ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    7,
                    " if ( argc ) {\n"
                ],
                [
                    12,
                    " argc -- , argv ++ ) {\n"
                ],
                [
                    13,
                    " err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n"
                ],
                [
                    14,
                    " if ( err ) {\n"
                ],
                [
                    15,
                    " fprintf ( stderr , \"can't convert `%s': %s\\n\" , * argv , gpg_strerror ( err ) ) ;\n"
                ],
                [
                    18,
                    " printf ( \"%s ->\" , * argv ) ;\n"
                ],
                [
                    20,
                    " n < buflen ;\n"
                ],
                [
                    21,
                    " n ++ ) printf ( \" %02X\" , buffer [ n ] ) ;\n"
                ],
                [
                    23,
                    " free ( buffer ) ;\n"
                ],
                [
                    31,
                    " result = ksba_oid_to_str ( buffer , buflen ) ;\n"
                ],
                [
                    32,
                    " free ( buffer ) ;\n"
                ],
                [
                    33,
                    " printf ( \"%s\\n\" , result ? result : \"[malloc failed]\" ) ;\n"
                ],
                [
                    34,
                    " free ( result ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "char * ksba_oid_to_str ( const char * buffer , size_t length ) {\n const unsigned char * buf = buffer ;\n char * string , * p ;\n int n = 0 ;\n unsigned long val , valmask ;\n valmask = ( unsigned long ) 0xfe << ( 8 * ( sizeof ( valmask ) - 1 ) ) ;\n string = p = xtrymalloc ( length * ( 1 + 3 ) + 2 + 1 ) ;\n if ( ! string ) return NULL ;\n if ( ! length ) {\n * p = 0 ;\n return string ;\n }\n if ( buf [ 0 ] < 40 ) p += sprintf ( p , \"0.%d\" , buf [ n ] ) ;\n else if ( buf [ 0 ] < 80 ) p += sprintf ( p , \"1.%d\" , buf [ n ] - 40 ) ;\n else {\n val = buf [ n ] & 0x7f ;\n while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n if ( ( val & valmask ) ) goto badoid ;\n val <<= 7 ;\n val |= buf [ n ] & 0x7f ;\n }\n val -= 80 ;\n sprintf ( p , \"2.%lu\" , val ) ;\n p += strlen ( p ) ;\n }\n for ( n ++ ;\n n < length ;\n n ++ ) {\n val = buf [ n ] & 0x7f ;\n while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n if ( ( val & valmask ) ) goto badoid ;\n val <<= 7 ;\n val |= buf [ n ] & 0x7f ;\n }\n sprintf ( p , \".%lu\" , val ) ;\n p += strlen ( p ) ;\n }\n * p = 0 ;\n return string ;\n badoid : xfree ( string ) ;\n return xtrystrdup ( \"1.3.6.1.4.1.11591.2.12242973\" ) ;\n }",
        "hash": -1676420406744178546,
        "project": "debian",
        "size": 42,
        "slice": {
            "strlen": [
                [
                    1,
                    "char * ksba_oid_to_str ( const char * buffer , size_t length ) {\n"
                ],
                [
                    17,
                    " while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n"
                ],
                [
                    23,
                    " sprintf ( p , \"2.%lu\" , val ) ;\n"
                ],
                [
                    24,
                    " p += strlen ( p ) ;\n"
                ],
                [
                    30,
                    " while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n"
                ],
                [
                    35,
                    " sprintf ( p , \".%lu\" , val ) ;\n"
                ],
                [
                    36,
                    " p += strlen ( p ) ;\n"
                ]
            ],
            "sprintf": [
                [
                    1,
                    "char * ksba_oid_to_str ( const char * buffer , size_t length ) {\n"
                ],
                [
                    2,
                    " const unsigned char * buf = buffer ;\n"
                ],
                [
                    7,
                    " string = p = xtrymalloc ( length * ( 1 + 3 ) + 2 + 1 ) ;\n"
                ],
                [
                    13,
                    " if ( buf [ 0 ] < 40 ) p += sprintf ( p , \"0.%d\" , buf [ n ] ) ;\n"
                ],
                [
                    14,
                    " else if ( buf [ 0 ] < 80 ) p += sprintf ( p , \"1.%d\" , buf [ n ] - 40 ) ;\n"
                ],
                [
                    17,
                    " while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n"
                ],
                [
                    22,
                    " val -= 80 ;\n"
                ],
                [
                    23,
                    " sprintf ( p , \"2.%lu\" , val ) ;\n"
                ],
                [
                    24,
                    " p += strlen ( p ) ;\n"
                ],
                [
                    29,
                    " val = buf [ n ] & 0x7f ;\n"
                ],
                [
                    30,
                    " while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n"
                ],
                [
                    33,
                    " val |= buf [ n ] & 0x7f ;\n"
                ],
                [
                    35,
                    " sprintf ( p , \".%lu\" , val ) ;\n"
                ],
                [
                    36,
                    " p += strlen ( p ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "char * ksba_oid_to_str ( const char * buffer , size_t length ) {\n"
                ],
                [
                    2,
                    " const unsigned char * buf = buffer ;\n"
                ],
                [
                    7,
                    " string = p = xtrymalloc ( length * ( 1 + 3 ) + 2 + 1 ) ;\n"
                ],
                [
                    13,
                    " if ( buf [ 0 ] < 40 ) p += sprintf ( p , \"0.%d\" , buf [ n ] ) ;\n"
                ],
                [
                    14,
                    " else if ( buf [ 0 ] < 80 ) p += sprintf ( p , \"1.%d\" , buf [ n ] - 40 ) ;\n"
                ],
                [
                    17,
                    " while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n"
                ],
                [
                    22,
                    " val -= 80 ;\n"
                ],
                [
                    23,
                    " sprintf ( p , \"2.%lu\" , val ) ;\n"
                ],
                [
                    24,
                    " p += strlen ( p ) ;\n"
                ],
                [
                    29,
                    " val = buf [ n ] & 0x7f ;\n"
                ],
                [
                    30,
                    " while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n"
                ],
                [
                    33,
                    " val |= buf [ n ] & 0x7f ;\n"
                ],
                [
                    35,
                    " sprintf ( p , \".%lu\" , val ) ;\n"
                ],
                [
                    36,
                    " p += strlen ( p ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * * argv ) {\n char inputbuf [ 4096 ] ;\n unsigned char * buf ;\n size_t len ;\n gpg_error_t err ;\n if ( argc == 2 && ! strcmp ( argv [ 1 ] , \"--to-str\" ) ) {\n fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n if ( ! feof ( stdin ) ) fail ( \"read error or input too large\" ) ;\n fail ( \"no yet implemented\" ) ;\n }\n else if ( argc == 2 && ! strcmp ( argv [ 1 ] , \"--to-der\" ) ) {\n fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n if ( ! feof ( stdin ) ) fail ( \"read error or input too large\" ) ;\n err = ksba_dn_str2der ( inputbuf , & buf , & len ) ;\n fail_if_err ( err ) ;\n fwrite ( buf , len , 1 , stdout ) ;\n }\n else if ( argc == 1 ) {\n test_0 ( ) ;\n test_1 ( ) ;\n test_2 ( ) ;\n }\n else {\n fprintf ( stderr , \"usage: t-dnparser [--to-str|--to-der]\\n\" ) ;\n return 1 ;\n }\n return 0 ;\n }",
        "hash": 3401745371761513837,
        "project": "debian",
        "size": 28,
        "slice": {
            "strcmp": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    6,
                    " if ( argc == 2 && ! strcmp ( argv [ 1 ] , \"--to-str\" ) ) {\n"
                ],
                [
                    7,
                    " fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n"
                ],
                [
                    8,
                    " if ( ! feof ( stdin ) ) fail ( \"read error or input too large\" ) ;\n"
                ],
                [
                    9,
                    " fail ( \"no yet implemented\" ) ;\n"
                ],
                [
                    11,
                    " else if ( argc == 2 && ! strcmp ( argv [ 1 ] , \"--to-der\" ) ) {\n"
                ],
                [
                    12,
                    " fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n"
                ],
                [
                    13,
                    " if ( ! feof ( stdin ) ) fail ( \"read error or input too large\" ) ;\n"
                ],
                [
                    14,
                    " err = ksba_dn_str2der ( inputbuf , & buf , & len ) ;\n"
                ],
                [
                    15,
                    " fail_if_err ( err ) ;\n"
                ],
                [
                    16,
                    " fwrite ( buf , len , 1 , stdout ) ;\n"
                ],
                [
                    18,
                    " else if ( argc == 1 ) {\n"
                ],
                [
                    27,
                    " return 0 ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    18,
                    " else if ( argc == 1 ) {\n"
                ],
                [
                    24,
                    " fprintf ( stderr , \"usage: t-dnparser [--to-str|--to-der]\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    6,
                    " if ( argc == 2 && ! strcmp ( argv [ 1 ] , \"--to-str\" ) ) {\n"
                ],
                [
                    7,
                    " fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n"
                ],
                [
                    8,
                    " if ( ! feof ( stdin ) ) fail ( \"read error or input too large\" ) ;\n"
                ],
                [
                    9,
                    " fail ( \"no yet implemented\" ) ;\n"
                ],
                [
                    11,
                    " else if ( argc == 2 && ! strcmp ( argv [ 1 ] , \"--to-der\" ) ) {\n"
                ],
                [
                    12,
                    " fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n"
                ],
                [
                    13,
                    " if ( ! feof ( stdin ) ) fail ( \"read error or input too large\" ) ;\n"
                ],
                [
                    14,
                    " err = ksba_dn_str2der ( inputbuf , & buf , & len ) ;\n"
                ],
                [
                    15,
                    " fail_if_err ( err ) ;\n"
                ],
                [
                    16,
                    " fwrite ( buf , len , 1 , stdout ) ;\n"
                ],
                [
                    18,
                    " else if ( argc == 1 ) {\n"
                ],
                [
                    24,
                    " fprintf ( stderr , \"usage: t-dnparser [--to-str|--to-der]\\n\" ) ;\n"
                ],
                [
                    27,
                    " return 0 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int _setup_resv_limits ( slurmdb_reservation_rec_t * resv , char * * cols , char * * vals , char * * extra ) {\n if ( resv -> assocs ) {\n int start = 0 ;\n int len = strlen ( resv -> assocs ) - 1 ;\n if ( strchr ( resv -> assocs , '-' ) ) {\n int i = 0 , i2 = 0 ;\n char * assocs = xmalloc ( sizeof ( char ) * len ) ;\n while ( i < len ) {\n if ( resv -> assocs [ i ] == ',' && resv -> assocs [ i + 1 ] == '-' ) {\n i += 2 ;\n while ( i < len ) {\n i ++ ;\n if ( resv -> assocs [ i ] == ',' ) break ;\n }\n continue ;\n }\n assocs [ i2 ++ ] = resv -> assocs [ i ++ ] ;\n }\n xfree ( resv -> assocs ) ;\n len = i2 - 1 ;\n resv -> assocs = assocs ;\n assocs = NULL ;\n }\n if ( resv -> assocs [ 0 ] == ',' ) start = 1 ;\n if ( resv -> assocs [ len ] == ',' ) resv -> assocs [ len ] = '\\0' ;\n xstrcat ( * cols , \", assoclist\" ) ;\n xstrfmtcat ( * vals , \", '%s'\" , resv -> assocs + start ) ;\n xstrfmtcat ( * extra , \", assoclist='%s'\" , resv -> assocs + start ) ;\n }\n if ( resv -> flags != NO_VAL ) {\n xstrcat ( * cols , \", flags\" ) ;\n xstrfmtcat ( * vals , \", %u\" , resv -> flags ) ;\n xstrfmtcat ( * extra , \", flags=%u\" , resv -> flags ) ;\n }\n if ( resv -> name ) {\n char * tmp_char = slurm_add_slash_to_quotes ( resv -> name ) ;\n xstrcat ( * cols , \", resv_name\" ) ;\n xstrfmtcat ( * vals , \", '%s'\" , tmp_char ) ;\n xstrfmtcat ( * extra , \", resv_name='%s'\" , tmp_char ) ;\n xfree ( tmp_char ) ;\n }\n if ( resv -> nodes ) {\n xstrcat ( * cols , \", nodelist\" ) ;\n xstrfmtcat ( * vals , \", '%s'\" , resv -> nodes ) ;\n xstrfmtcat ( * extra , \", nodelist='%s'\" , resv -> nodes ) ;\n }\n if ( resv -> node_inx ) {\n xstrcat ( * cols , \", node_inx\" ) ;\n xstrfmtcat ( * vals , \", '%s'\" , resv -> node_inx ) ;\n xstrfmtcat ( * extra , \", node_inx='%s'\" , resv -> node_inx ) ;\n }\n if ( resv -> time_end ) {\n xstrcat ( * cols , \", time_end\" ) ;\n xstrfmtcat ( * vals , \", %ld\" , resv -> time_end ) ;\n xstrfmtcat ( * extra , \", time_end=%ld\" , resv -> time_end ) ;\n }\n if ( resv -> time_start ) {\n xstrcat ( * cols , \", time_start\" ) ;\n xstrfmtcat ( * vals , \", %ld\" , resv -> time_start ) ;\n xstrfmtcat ( * extra , \", time_start=%ld\" , resv -> time_start ) ;\n }\n if ( resv -> tres_str ) {\n xstrcat ( * cols , \", tres\" ) ;\n xstrfmtcat ( * vals , \", '%s'\" , resv -> tres_str ) ;\n xstrfmtcat ( * extra , \", tres='%s'\" , resv -> tres_str ) ;\n }\n return SLURM_SUCCESS ;\n }",
        "hash": -2724676033474964439,
        "project": "debian",
        "size": 68,
        "slice": {
            "strchr": [
                [
                    1,
                    "static int _setup_resv_limits ( slurmdb_reservation_rec_t * resv , char * * cols , char * * vals , char * * extra ) {\n"
                ],
                [
                    2,
                    " if ( resv -> assocs ) {\n"
                ],
                [
                    4,
                    " int len = strlen ( resv -> assocs ) - 1 ;\n"
                ],
                [
                    5,
                    " if ( strchr ( resv -> assocs , '-' ) ) {\n"
                ],
                [
                    6,
                    " int i = 0 , i2 = 0 ;\n"
                ],
                [
                    7,
                    " char * assocs = xmalloc ( sizeof ( char ) * len ) ;\n"
                ],
                [
                    8,
                    " while ( i < len ) {\n"
                ],
                [
                    19,
                    " xfree ( resv -> assocs ) ;\n"
                ],
                [
                    20,
                    " len = i2 - 1 ;\n"
                ],
                [
                    21,
                    " resv -> assocs = assocs ;\n"
                ],
                [
                    22,
                    " assocs = NULL ;\n"
                ],
                [
                    27,
                    " xstrfmtcat ( * vals , \", '%s'\" , resv -> assocs + start ) ;\n"
                ],
                [
                    28,
                    " xstrfmtcat ( * extra , \", assoclist='%s'\" , resv -> assocs + start ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static int _setup_resv_limits ( slurmdb_reservation_rec_t * resv , char * * cols , char * * vals , char * * extra ) {\n"
                ],
                [
                    2,
                    " if ( resv -> assocs ) {\n"
                ],
                [
                    4,
                    " int len = strlen ( resv -> assocs ) - 1 ;\n"
                ],
                [
                    5,
                    " if ( strchr ( resv -> assocs , '-' ) ) {\n"
                ],
                [
                    7,
                    " char * assocs = xmalloc ( sizeof ( char ) * len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int _setup_resv_limits ( slurmdb_reservation_rec_t * resv , char * * cols , char * * vals , char * * extra ) {\n"
                ],
                [
                    2,
                    " if ( resv -> assocs ) {\n"
                ],
                [
                    4,
                    " int len = strlen ( resv -> assocs ) - 1 ;\n"
                ],
                [
                    5,
                    " if ( strchr ( resv -> assocs , '-' ) ) {\n"
                ],
                [
                    6,
                    " int i = 0 , i2 = 0 ;\n"
                ],
                [
                    7,
                    " char * assocs = xmalloc ( sizeof ( char ) * len ) ;\n"
                ],
                [
                    8,
                    " while ( i < len ) {\n"
                ],
                [
                    19,
                    " xfree ( resv -> assocs ) ;\n"
                ],
                [
                    20,
                    " len = i2 - 1 ;\n"
                ],
                [
                    21,
                    " resv -> assocs = assocs ;\n"
                ],
                [
                    22,
                    " assocs = NULL ;\n"
                ],
                [
                    27,
                    " xstrfmtcat ( * vals , \", '%s'\" , resv -> assocs + start ) ;\n"
                ],
                [
                    28,
                    " xstrfmtcat ( * extra , \", assoclist='%s'\" , resv -> assocs + start ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static gint detect_version ( wtap * wth , int * err , gchar * * err_info ) {\n gint bytes_read ;\n guint16 payload_length ;\n guint16 try_header_size ;\n guint8 * buffer ;\n gint64 file_offset ;\n guint32 log_length ;\n guint32 tag_length ;\n guint16 tmp ;\n file_offset = file_tell ( wth -> fh ) ;\n bytes_read = file_read ( & tmp , 2 , wth -> fh ) ;\n if ( bytes_read != 2 ) {\n * err = file_error ( wth -> fh , err_info ) ;\n if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ;\n return - 1 ;\n }\n payload_length = pletoh16 ( & tmp ) ;\n bytes_read = file_read ( & tmp , 2 , wth -> fh ) ;\n if ( bytes_read != 2 ) {\n * err = file_error ( wth -> fh , err_info ) ;\n if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ;\n return - 1 ;\n }\n try_header_size = pletoh16 ( & tmp ) ;\n buffer = ( guint8 * ) g_malloc ( 5 * 4 + payload_length ) ;\n bytes_read = file_read ( buffer , 5 * 4 + payload_length , wth -> fh ) ;\n if ( bytes_read != 5 * 4 + payload_length ) {\n if ( bytes_read != 4 * 4 + payload_length ) {\n * err = file_error ( wth -> fh , err_info ) ;\n if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ;\n g_free ( buffer ) ;\n return - 1 ;\n }\n }\n if ( try_header_size == 24 ) {\n tag_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 ) + 1 ;\n log_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 + tag_length ) + 1 ;\n if ( payload_length == 1 + tag_length + log_length ) {\n g_free ( buffer ) ;\n return 2 ;\n }\n }\n tag_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 ) + 1 ;\n log_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 + tag_length ) + 1 ;\n if ( payload_length == 1 + tag_length + log_length ) {\n if ( file_seek ( wth -> fh , file_offset + 4 * 4 + 1 + tag_length + log_length , SEEK_SET , err ) == - 1 ) {\n g_free ( buffer ) ;\n return - 1 ;\n }\n g_free ( buffer ) ;\n return 1 ;\n }\n g_free ( buffer ) ;\n return 0 ;\n }",
        "hash": 3616225660295849566,
        "project": "debian",
        "size": 55,
        "slice": {
            "strlen": [
                [
                    1,
                    "static gint detect_version ( wtap * wth , int * err , gchar * * err_info ) {\n"
                ],
                [
                    26,
                    " bytes_read = file_read ( buffer , 5 * 4 + payload_length , wth -> fh ) ;\n"
                ],
                [
                    35,
                    " if ( try_header_size == 24 ) {\n"
                ],
                [
                    36,
                    " tag_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 ) + 1 ;\n"
                ],
                [
                    37,
                    " log_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 + tag_length ) + 1 ;\n"
                ],
                [
                    38,
                    " if ( payload_length == 1 + tag_length + log_length ) {\n"
                ],
                [
                    43,
                    " tag_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 ) + 1 ;\n"
                ],
                [
                    44,
                    " log_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 + tag_length ) + 1 ;\n"
                ],
                [
                    45,
                    " if ( payload_length == 1 + tag_length + log_length ) {\n"
                ],
                [
                    46,
                    " if ( file_seek ( wth -> fh , file_offset + 4 * 4 + 1 + tag_length + log_length , SEEK_SET , err ) == - 1 ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gint detect_version ( wtap * wth , int * err , gchar * * err_info ) {\n"
                ],
                [
                    26,
                    " bytes_read = file_read ( buffer , 5 * 4 + payload_length , wth -> fh ) ;\n"
                ],
                [
                    35,
                    " if ( try_header_size == 24 ) {\n"
                ],
                [
                    36,
                    " tag_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 ) + 1 ;\n"
                ],
                [
                    37,
                    " log_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 + tag_length ) + 1 ;\n"
                ],
                [
                    38,
                    " if ( payload_length == 1 + tag_length + log_length ) {\n"
                ],
                [
                    43,
                    " tag_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 ) + 1 ;\n"
                ],
                [
                    44,
                    " log_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 + tag_length ) + 1 ;\n"
                ],
                [
                    45,
                    " if ( payload_length == 1 + tag_length + log_length ) {\n"
                ],
                [
                    46,
                    " if ( file_seek ( wth -> fh , file_offset + 4 * 4 + 1 + tag_length + log_length , SEEK_SET , err ) == - 1 ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static gboolean logcat_dump_text ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err ) {\n gchar * buf ;\n gint length ;\n gchar priority ;\n const gchar * tag ;\n const gint * pid ;\n const gint * tid ;\n const gchar * log ;\n gchar * log_part ;\n const gchar * str_begin ;\n const gchar * str_end ;\n const guint32 * datetime ;\n const guint32 * nanoseconds ;\n const union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ;\n const struct dumper_t * dumper = ( const struct dumper_t * ) wdh -> priv ;\n if ( phdr -> rec_type != REC_TYPE_PACKET ) {\n * err = WTAP_ERR_REC_TYPE_UNSUPPORTED ;\n return FALSE ;\n }\n if ( pseudo_header -> logcat . version == 1 ) {\n pid = ( const gint * ) ( pd + 4 ) ;\n tid = ( const gint * ) ( pd + 2 * 4 ) ;\n datetime = ( const guint32 * ) ( pd + 3 * 4 ) ;\n nanoseconds = ( const guint32 * ) ( pd + 4 * 4 ) ;\n priority = get_priority ( ( const guint8 * ) ( pd + 5 * 4 ) ) ;\n tag = ( const gchar * ) ( pd + 5 * 4 + 1 ) ;\n log = tag + strlen ( tag ) + 1 ;\n }\n else if ( pseudo_header -> logcat . version == 2 ) {\n pid = ( const gint * ) ( pd + 4 ) ;\n tid = ( const gint * ) ( pd + 2 * 4 ) ;\n datetime = ( const guint32 * ) ( pd + 3 * 4 ) ;\n nanoseconds = ( const guint32 * ) ( pd + 4 * 4 ) ;\n priority = get_priority ( ( const guint8 * ) ( pd + 6 * 4 ) ) ;\n tag = ( const char * ) ( pd + 6 * 4 + 1 ) ;\n log = tag + strlen ( tag ) + 1 ;\n }\n else {\n * err = WTAP_ERR_UNSUPPORTED ;\n return FALSE ;\n }\n str_begin = str_end = log ;\n while ( dumper -> type != DUMP_LONG && ( str_end = strchr ( str_begin , '\\n' ) ) ) {\n log_part = ( gchar * ) g_malloc ( str_end - str_begin + 1 ) ;\n g_strlcpy ( log_part , str_begin , str_end - str_begin + 1 ) ;\n str_begin = str_end + 1 ;\n buf = logcat_log ( dumper , * datetime , * nanoseconds / 1000000 , * pid , * tid , priority , tag , log_part ) ;\n if ( ! buf ) {\n g_free ( log_part ) ;\n return FALSE ;\n }\n g_free ( log_part ) ;\n length = ( guint32 ) strlen ( buf ) ;\n if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {\n g_free ( buf ) ;\n return FALSE ;\n }\n wdh -> bytes_dumped += length ;\n g_free ( buf ) ;\n }\n if ( * str_begin != '\\0' ) {\n log_part = ( gchar * ) g_malloc ( strlen ( str_begin ) + 1 ) ;\n g_strlcpy ( log_part , str_begin , strlen ( str_begin ) + 1 ) ;\n buf = logcat_log ( dumper , * datetime , * nanoseconds / 1000000 , * pid , * tid , priority , tag , log_part ) ;\n if ( ! buf ) {\n g_free ( log_part ) ;\n return FALSE ;\n }\n g_free ( log_part ) ;\n length = ( guint32 ) strlen ( buf ) ;\n if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {\n g_free ( buf ) ;\n return FALSE ;\n }\n wdh -> bytes_dumped += length ;\n g_free ( buf ) ;\n }\n return TRUE ;\n }",
        "hash": 3616225660295849566,
        "project": "debian",
        "size": 79,
        "slice": {
            "strchr": [
                [
                    1,
                    "static gboolean logcat_dump_text ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err ) {\n"
                ],
                [
                    42,
                    " str_begin = str_end = log ;\n"
                ],
                [
                    43,
                    " while ( dumper -> type != DUMP_LONG && ( str_end = strchr ( str_begin , '\\n' ) ) ) {\n"
                ],
                [
                    44,
                    " log_part = ( gchar * ) g_malloc ( str_end - str_begin + 1 ) ;\n"
                ],
                [
                    46,
                    " str_begin = str_end + 1 ;\n"
                ],
                [
                    62,
                    " log_part = ( gchar * ) g_malloc ( strlen ( str_begin ) + 1 ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static gboolean logcat_dump_text ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err ) {\n"
                ],
                [
                    20,
                    " if ( pseudo_header -> logcat . version == 1 ) {\n"
                ],
                [
                    26,
                    " tag = ( const gchar * ) ( pd + 5 * 4 + 1 ) ;\n"
                ],
                [
                    27,
                    " log = tag + strlen ( tag ) + 1 ;\n"
                ],
                [
                    29,
                    " else if ( pseudo_header -> logcat . version == 2 ) {\n"
                ],
                [
                    35,
                    " tag = ( const char * ) ( pd + 6 * 4 + 1 ) ;\n"
                ],
                [
                    36,
                    " log = tag + strlen ( tag ) + 1 ;\n"
                ],
                [
                    42,
                    " str_begin = str_end = log ;\n"
                ],
                [
                    43,
                    " while ( dumper -> type != DUMP_LONG && ( str_end = strchr ( str_begin , '\\n' ) ) ) {\n"
                ],
                [
                    46,
                    " str_begin = str_end + 1 ;\n"
                ],
                [
                    47,
                    " buf = logcat_log ( dumper , * datetime , * nanoseconds / 1000000 , * pid , * tid , priority , tag , log_part ) ;\n"
                ],
                [
                    48,
                    " if ( ! buf ) {\n"
                ],
                [
                    53,
                    " length = ( guint32 ) strlen ( buf ) ;\n"
                ],
                [
                    54,
                    " if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {\n"
                ],
                [
                    61,
                    " if ( * str_begin != '\\0' ) {\n"
                ],
                [
                    62,
                    " log_part = ( gchar * ) g_malloc ( strlen ( str_begin ) + 1 ) ;\n"
                ],
                [
                    63,
                    " g_strlcpy ( log_part , str_begin , strlen ( str_begin ) + 1 ) ;\n"
                ],
                [
                    64,
                    " buf = logcat_log ( dumper , * datetime , * nanoseconds / 1000000 , * pid , * tid , priority , tag , log_part ) ;\n"
                ],
                [
                    65,
                    " if ( ! buf ) {\n"
                ],
                [
                    70,
                    " length = ( guint32 ) strlen ( buf ) ;\n"
                ],
                [
                    71,
                    " if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gboolean logcat_dump_text ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err ) {\n"
                ],
                [
                    20,
                    " if ( pseudo_header -> logcat . version == 1 ) {\n"
                ],
                [
                    26,
                    " tag = ( const gchar * ) ( pd + 5 * 4 + 1 ) ;\n"
                ],
                [
                    27,
                    " log = tag + strlen ( tag ) + 1 ;\n"
                ],
                [
                    29,
                    " else if ( pseudo_header -> logcat . version == 2 ) {\n"
                ],
                [
                    35,
                    " tag = ( const char * ) ( pd + 6 * 4 + 1 ) ;\n"
                ],
                [
                    36,
                    " log = tag + strlen ( tag ) + 1 ;\n"
                ],
                [
                    42,
                    " str_begin = str_end = log ;\n"
                ],
                [
                    43,
                    " while ( dumper -> type != DUMP_LONG && ( str_end = strchr ( str_begin , '\\n' ) ) ) {\n"
                ],
                [
                    44,
                    " log_part = ( gchar * ) g_malloc ( str_end - str_begin + 1 ) ;\n"
                ],
                [
                    46,
                    " str_begin = str_end + 1 ;\n"
                ],
                [
                    47,
                    " buf = logcat_log ( dumper , * datetime , * nanoseconds / 1000000 , * pid , * tid , priority , tag , log_part ) ;\n"
                ],
                [
                    48,
                    " if ( ! buf ) {\n"
                ],
                [
                    53,
                    " length = ( guint32 ) strlen ( buf ) ;\n"
                ],
                [
                    54,
                    " if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {\n"
                ],
                [
                    61,
                    " if ( * str_begin != '\\0' ) {\n"
                ],
                [
                    62,
                    " log_part = ( gchar * ) g_malloc ( strlen ( str_begin ) + 1 ) ;\n"
                ],
                [
                    63,
                    " g_strlcpy ( log_part , str_begin , strlen ( str_begin ) + 1 ) ;\n"
                ],
                [
                    64,
                    " buf = logcat_log ( dumper , * datetime , * nanoseconds / 1000000 , * pid , * tid , priority , tag , log_part ) ;\n"
                ],
                [
                    65,
                    " if ( ! buf ) {\n"
                ],
                [
                    70,
                    " length = ( guint32 ) strlen ( buf ) ;\n"
                ],
                [
                    71,
                    " if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static gboolean logcat_read_packet ( struct logcat_phdr * logcat , FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n gint bytes_read ;\n gint packet_size ;\n guint16 payload_length ;\n guint tmp [ 2 ] ;\n guint8 * pd ;\n bytes_read = file_read ( & tmp , 2 , fh ) ;\n if ( bytes_read != 2 ) {\n * err = file_error ( fh , err_info ) ;\n if ( * err == 0 && bytes_read != 0 ) * err = WTAP_ERR_SHORT_READ ;\n return FALSE ;\n }\n payload_length = pletoh16 ( tmp ) ;\n if ( logcat -> version == 1 ) {\n packet_size = 5 * 4 + payload_length ;\n }\n else if ( logcat -> version == 2 ) {\n packet_size = 6 * 4 + payload_length ;\n }\n else {\n return FALSE ;\n }\n buffer_assure_space ( buf , packet_size ) ;\n pd = buffer_start_ptr ( buf ) ;\n memcpy ( pd , tmp , 2 ) ;\n bytes_read = file_read ( pd + 2 , packet_size - 2 , fh ) ;\n if ( bytes_read != packet_size - 2 ) {\n * err = file_error ( fh , err_info ) ;\n if ( * err == 0 ) * err = WTAP_ERR_SHORT_READ ;\n return FALSE ;\n }\n phdr -> rec_type = REC_TYPE_PACKET ;\n phdr -> presence_flags = WTAP_HAS_TS ;\n phdr -> ts . secs = ( time_t ) pletoh32 ( pd + 12 ) ;\n phdr -> ts . nsecs = ( int ) pletoh32 ( pd + 16 ) ;\n phdr -> caplen = packet_size ;\n phdr -> len = packet_size ;\n phdr -> pseudo_header . logcat . version = logcat -> version ;\n return TRUE ;\n }",
        "hash": 3616225660295849566,
        "project": "debian",
        "size": 40,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static gboolean logcat_read_packet ( struct logcat_phdr * logcat , FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n"
                ],
                [
                    7,
                    " bytes_read = file_read ( & tmp , 2 , fh ) ;\n"
                ],
                [
                    13,
                    " payload_length = pletoh16 ( tmp ) ;\n"
                ],
                [
                    14,
                    " if ( logcat -> version == 1 ) {\n"
                ],
                [
                    17,
                    " else if ( logcat -> version == 2 ) {\n"
                ],
                [
                    24,
                    " pd = buffer_start_ptr ( buf ) ;\n"
                ],
                [
                    25,
                    " memcpy ( pd , tmp , 2 ) ;\n"
                ],
                [
                    26,
                    " bytes_read = file_read ( pd + 2 , packet_size - 2 , fh ) ;\n"
                ],
                [
                    34,
                    " phdr -> ts . secs = ( time_t ) pletoh32 ( pd + 12 ) ;\n"
                ],
                [
                    35,
                    " phdr -> ts . nsecs = ( int ) pletoh32 ( pd + 16 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gboolean logcat_read_packet ( struct logcat_phdr * logcat , FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n"
                ],
                [
                    7,
                    " bytes_read = file_read ( & tmp , 2 , fh ) ;\n"
                ],
                [
                    13,
                    " payload_length = pletoh16 ( tmp ) ;\n"
                ],
                [
                    14,
                    " if ( logcat -> version == 1 ) {\n"
                ],
                [
                    17,
                    " else if ( logcat -> version == 2 ) {\n"
                ],
                [
                    24,
                    " pd = buffer_start_ptr ( buf ) ;\n"
                ],
                [
                    25,
                    " memcpy ( pd , tmp , 2 ) ;\n"
                ],
                [
                    26,
                    " bytes_read = file_read ( pd + 2 , packet_size - 2 , fh ) ;\n"
                ],
                [
                    34,
                    " phdr -> ts . secs = ( time_t ) pletoh32 ( pd + 12 ) ;\n"
                ],
                [
                    35,
                    " phdr -> ts . nsecs = ( int ) pletoh32 ( pd + 16 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int do_execstack ( i_ctx_t * i_ctx_p , bool include_marks , os_ptr op1 ) {\n os_ptr op = osp ;\n ref * arefs = op1 -> value . refs ;\n uint asize = r_size ( op1 ) ;\n uint i ;\n ref * rq ;\n for ( i = 0 , rq = arefs + asize ;\n rq != arefs ;\n ++ i ) {\n const ref * rp = ref_stack_index ( & e_stack , ( long ) i ) ;\n if ( r_has_type_attrs ( rp , t_null , a_executable ) && ! include_marks ) continue ;\n -- rq ;\n ref_assign_old ( op1 , rq , rp , \"execstack\" ) ;\n switch ( r_type ( rq ) ) {\n case t_operator : {\n uint opidx = op_index ( rq ) ;\n if ( opidx == 0 || op_def_is_internal ( op_index_def ( opidx ) ) ) r_clear_attrs ( rq , a_executable ) ;\n break ;\n }\n case t_struct : case t_astruct : {\n const char * tname = rq -> value . pstruct ? gs_struct_type_name_string ( gs_object_type ( imemory , rq -> value . pstruct ) ) : \"NULL\" ;\n make_const_string ( rq , a_readonly | avm_foreign , strlen ( tname ) , ( const byte * ) tname ) ;\n break ;\n }\n default : ;\n }\n }\n pop ( op - op1 ) ;\n return 0 ;\n }",
        "hash": -6119142299306266167,
        "project": "debian",
        "size": 30,
        "slice": {
            "strlen": [
                [
                    1,
                    "static int do_execstack ( i_ctx_t * i_ctx_p , bool include_marks , os_ptr op1 ) {\n"
                ],
                [
                    14,
                    " switch ( r_type ( rq ) ) {\n"
                ],
                [
                    21,
                    " const char * tname = rq -> value . pstruct ? gs_struct_type_name_string ( gs_object_type ( imemory , rq -> value . pstruct ) ) : \"NULL\" ;\n"
                ],
                [
                    22,
                    " make_const_string ( rq , a_readonly | avm_foreign , strlen ( tname ) , ( const byte * ) tname ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int do_execstack ( i_ctx_t * i_ctx_p , bool include_marks , os_ptr op1 ) {\n"
                ],
                [
                    14,
                    " switch ( r_type ( rq ) ) {\n"
                ],
                [
                    21,
                    " const char * tname = rq -> value . pstruct ? gs_struct_type_name_string ( gs_object_type ( imemory , rq -> value . pstruct ) ) : \"NULL\" ;\n"
                ],
                [
                    22,
                    " make_const_string ( rq , a_readonly | avm_foreign , strlen ( tname ) , ( const byte * ) tname ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void proto_register_iax2 ( void ) {\n static hf_register_info hf [ ] = {\n {\n & hf_iax2_packet_type , {\n \"Packet type\" , \"iax2.packet_type\" , FT_UINT8 , BASE_DEC , VALS ( iax_packet_types ) , 0 , \"Full/minivoice/minivideo/trunk packet\" , HFILL }\n }\n , {\n & hf_iax2_callno , {\n \"Call identifier\" , \"iax2.call\" , FT_UINT32 , BASE_DEC , NULL , 0 , \"This is the identifier Wireshark assigns to identify this call.\" \" It does not correspond to any real field in the protocol\" , HFILL }\n }\n , {\n & hf_iax2_scallno , {\n \"Source call\" , \"iax2.src_call\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"src_call holds the number of this call at the packet source pbx\" , HFILL }\n }\n , {\n & hf_iax2_dcallno , {\n \"Destination call\" , \"iax2.dst_call\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"dst_call holds the number of this call at the packet destination\" , HFILL }\n }\n , {\n & hf_iax2_retransmission , {\n \"Retransmission\" , \"iax2.retransmission\" , FT_BOOLEAN , 16 , NULL , 0x8000 , \"retransmission is set if this packet is a retransmission of an earlier failed packet\" , HFILL }\n }\n , {\n & hf_iax2_ts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_minits , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_minividts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_absts , {\n \"Absolute Time\" , \"iax2.abstime\" , FT_ABSOLUTE_TIME , ABSOLUTE_TIME_LOCAL , NULL , 0x0 , \"The absolute time of this packet (calculated by adding the IAX timestamp to the start time of this call)\" , HFILL }\n }\n , {\n & hf_iax2_lateness , {\n \"Lateness\" , \"iax2.lateness\" , FT_RELATIVE_TIME , BASE_NONE , NULL , 0x0 , \"The lateness of this packet compared to its timestamp\" , HFILL }\n }\n , {\n & hf_iax2_minividmarker , {\n \"Marker\" , \"iax2.video.marker\" , FT_UINT16 , BASE_DEC , NULL , 0x8000 , \"RTP end-of-frame marker\" , HFILL }\n }\n , {\n & hf_iax2_oseqno , {\n \"Outbound seq.no.\" , \"iax2.oseqno\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"oseqno is the sequence no of this packet. The first packet has oseqno==0,\" \" and subsequent packets increment the oseqno by 1\" , HFILL }\n }\n , {\n & hf_iax2_iseqno , {\n \"Inbound seq.no.\" , \"iax2.iseqno\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"iseqno is the sequence no of the last successfully received packet\" , HFILL }\n }\n , {\n & hf_iax2_type , {\n \"Type\" , \"iax2.type\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_frame_types_ext , 0x0 , \"For full IAX2 frames, type is the type of frame\" , HFILL }\n }\n , {\n & hf_iax2_csub , {\n \"Unknown subclass\" , \"iax2.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , \"Subclass of unknown type of full IAX2 frame\" , HFILL }\n }\n , {\n & hf_iax2_dtmf_csub , {\n \"DTMF subclass (digit)\" , \"iax2.dtmf.subclass\" , FT_STRINGZ , BASE_NONE , NULL , 0x0 , \"DTMF subclass gives the DTMF digit\" , HFILL }\n }\n , {\n & hf_iax2_cmd_csub , {\n \"Control subclass\" , \"iax2.control.subclass\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_cmd_subclasses_ext , 0x0 , \"This gives the command number for a Control packet.\" , HFILL }\n }\n , {\n & hf_iax2_iax_csub , {\n \"IAX subclass\" , \"iax2.iax.subclass\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_iax_subclasses_ext , 0x0 , \"IAX subclass gives the command number for IAX signaling packets\" , HFILL }\n }\n , {\n & hf_iax2_voice_csub , {\n \"Voice Subclass (compressed codec no)\" , \"iax2.voice.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_voice_codec , {\n \"CODEC\" , \"iax2.voice.codec\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0x0 , \"CODEC gives the codec used to encode audio data\" , HFILL }\n }\n , {\n & hf_iax2_video_csub , {\n \"Video Subclass (compressed codec no)\" , \"iax2.video.subclass\" , FT_UINT8 , BASE_DEC , NULL , 0xBF , NULL , HFILL }\n }\n , {\n & hf_iax2_marker , {\n \"Marker\" , \"iax2.video.marker\" , FT_BOOLEAN , 8 , NULL , 0x40 , \"RTP end-of-frame marker\" , HFILL }\n }\n , {\n & hf_iax2_video_codec , {\n \"CODEC\" , \"iax2.video.codec\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0 , \"The codec used to encode video data\" , HFILL }\n }\n , {\n & hf_iax2_modem_csub , {\n \"Modem subclass\" , \"iax2.modem.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_modem_subclasses ) , 0x0 , \"Modem subclass gives the type of modem\" , HFILL }\n }\n , {\n & hf_iax2_text_csub , {\n \"Text subclass\" , \"iax2.text.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_text_subclasses ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_text_text , {\n \"Text\" , \"iax2.text.text\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_html_csub , {\n \"HTML subclass\" , \"iax2.html.subclass\" , FT_UINT8 , BASE_DEC , VALS ( iax_html_subclasses ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_html_url , {\n \"HTML URL\" , \"iax2.html.url\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_trunk_ts , {\n \"Timestamp\" , \"iax2.timestamp\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of Command data this call,\" \" at which this trunk packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_trunk_metacmd , {\n \"Meta command\" , \"iax2.trunk.metacmd\" , FT_UINT8 , BASE_DEC , NULL , 0x7F , \"Meta command indicates whether or not the Meta Frame is a trunk.\" , HFILL }\n }\n , {\n & hf_iax2_trunk_cmddata , {\n \"Command data\" , \"iax2.trunk.cmddata\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"Flags for options that apply to a trunked call\" , HFILL }\n }\n , {\n & hf_iax2_trunk_cmddata_ts , {\n \"Trunk timestamps\" , \"iax2.trunk.cmddata.ts\" , FT_BOOLEAN , 8 , NULL , IAX2_TRUNK_TS , \"True: calls do each include their own timestamp\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_len , {\n \"Data length\" , \"iax2.trunk.call.len\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Trunk call data length in octets\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_scallno , {\n \"Source call number\" , \"iax2.trunk.call.scallno\" , FT_UINT16 , BASE_DEC , NULL , 0x7FFF , \"Trunk call source call number\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_ts , {\n \"Timestamp\" , \"iax2.trunk.call.ts\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\" , HFILL }\n }\n , {\n & hf_iax2_trunk_call_data , {\n \"Data\" , \"iax2.trunk.call.payload\" , FT_BYTES , BASE_NONE , NULL , 0x0 , \"Payload carried by this trunked packet.\" , HFILL }\n }\n , {\n & hf_iax2_trunk_ncalls , {\n \"Number of calls\" , \"iax2.trunk.ncalls\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , \"Number of calls in this trunk packet\" , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINFAMILY , {\n \"Family\" , \"iax2.iax.app_addr.sinfamily\" , FT_UINT16 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINPORT , {\n \"Port\" , \"iax2.iax.app_addr.sinport\" , FT_UINT16 , BASE_DEC , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_APPARENTADDR_SINADDR , {\n \"Address\" , \"iax2.iax.app_addr.sinaddr\" , FT_IPv4 , BASE_NONE , NULL , 0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLED_NUMBER ] , {\n \"Number/extension being called\" , \"iax2.iax.called_number\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_NUMBER ] , {\n \"Calling number\" , \"iax2.iax.calling_number\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_ANI ] , {\n \"Calling number ANI for billing\" , \"iax2.iax.calling_ani\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLING_NAME ] , {\n \"Name of caller\" , \"iax2.iax.calling_name\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLED_CONTEXT ] , {\n \"Context for number\" , \"iax2.iax.called_context\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_USERNAME ] , {\n \"Username (peer or user) for authentication\" , \"iax2.iax.username\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PASSWORD ] , {\n \"Password for authentication\" , \"iax2.iax.password\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAPABILITY ] , {\n \"Actual codec capability\" , \"iax2.iax.capability\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FORMAT ] , {\n \"Desired codec format\" , \"iax2.iax.format\" , FT_UINT32 , BASE_HEX | BASE_EXT_STRING , & codec_types_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_LANGUAGE ] , {\n \"Desired language\" , \"iax2.iax.language\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_VERSION ] , {\n \"Protocol version\" , \"iax2.iax.version\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ADSICPE ] , {\n \"CPE ADSI capability\" , \"iax2.iax.cpe_adsi\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DNID ] , {\n \"Originally dialed DNID\" , \"iax2.iax.dnid\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AUTHMETHODS ] , {\n \"Authentication method(s)\" , \"iax2.iax.auth.methods\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CHALLENGE ] , {\n \"Challenge data for MD5/RSA\" , \"iax2.iax.auth.challenge\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MD5_RESULT ] , {\n \"MD5 challenge result\" , \"iax2.iax.auth.md5\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RSA_RESULT ] , {\n \"RSA challenge result\" , \"iax2.iax.auth.rsa\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_REFRESH ] , {\n \"When to refresh registration\" , \"iax2.iax.refresh\" , FT_INT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DPSTATUS ] , {\n \"Dialplan status\" , \"iax2.iax.dialplan_status\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLNO ] , {\n \"Call number of peer\" , \"iax2.iax.call_no\" , FT_UINT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAUSE ] , {\n \"Cause\" , \"iax2.iax.cause\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_IAX_UNKNOWN ] , {\n \"Unknown IAX command\" , \"iax2.iax.iax_unknown\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MSGCOUNT ] , {\n \"How many messages waiting\" , \"iax2.iax.msg_count\" , FT_INT16 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AUTOANSWER ] , {\n \"Request auto-answering\" , \"iax2.iax.autoanswer\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_MUSICONHOLD ] , {\n \"Request musiconhold with QUELCH\" , \"iax2.iax.moh\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_TRANSFERID ] , {\n \"Transfer Request Identifier\" , \"iax2.iax.transferid\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RDNIS ] , {\n \"Referring DNIS\" , \"iax2.iax.rdnis\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PROVISIONING ] , {\n \"Provisioning info\" , \"iax2.iax.provisioning\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_AESPROVISIONING ] , {\n \"AES Provisioning info\" , \"iax2.iax.aesprovisioning\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DATETIME ] , {\n \"Date/Time\" , \"iax2.iax.datetime.raw\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ie_datetime , {\n \"Date/Time\" , \"iax2.iax.datetime\" , FT_ABSOLUTE_TIME , ABSOLUTE_TIME_LOCAL , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DEVICETYPE ] , {\n \"Device type\" , \"iax2.iax.devicetype\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_SERVICEIDENT ] , {\n \"Service identifier\" , \"iax2.iax.serviceident\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FIRMWAREVER ] , {\n \"Firmware version\" , \"iax2.iax.firmwarever\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FWBLOCKDESC ] , {\n \"Firmware block description\" , \"iax2.iax.fwblockdesc\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_FWBLOCKDATA ] , {\n \"Firmware block of data\" , \"iax2.iax.fwblockdata\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_PROVVER ] , {\n \"Provisioning version\" , \"iax2.iax.provver\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGPRES ] , {\n \"Calling presentation\" , \"iax2.iax.callingpres\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGTON ] , {\n \"Calling type of number\" , \"iax2.iax.callington\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CALLINGTNS ] , {\n \"Calling transit network select\" , \"iax2.iax.callingtns\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_SAMPLINGRATE ] , {\n \"Supported sampling rates\" , \"iax2.iax.samplingrate\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CAUSECODE ] , {\n \"Hangup cause\" , \"iax2.iax.causecode\" , FT_UINT8 , BASE_HEX | BASE_EXT_STRING , & iax_causecodes_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ENCRYPTION ] , {\n \"Encryption format\" , \"iax2.iax.encryption\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_ENCKEY ] , {\n \"Encryption key\" , \"iax2.iax.enckey\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_CODEC_PREFS ] , {\n \"Codec negotiation\" , \"iax2.iax.codecprefs\" , FT_STRING , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_JITTER ] , {\n \"Received jitter (as in RFC1889)\" , \"iax2.iax.rrjitter\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_LOSS ] , {\n \"Received loss (high byte loss pct, low 24 bits loss count, as in rfc1889)\" , \"iax2.iax.rrloss\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_PKTS ] , {\n \"Total frames received\" , \"iax2.iax.rrpkts\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_DELAY ] , {\n \"Max playout delay in ms for received frames\" , \"iax2.iax.rrdelay\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_DROPPED ] , {\n \"Dropped frames (presumably by jitterbuffer)\" , \"iax2.iax.rrdropped\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_RR_OOO ] , {\n \"Frame received out of order\" , \"iax2.iax.rrooo\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_ies [ IAX_IE_DATAFORMAT ] , {\n \"Data call format\" , \"iax2.iax.dataformat\" , FT_UINT32 , BASE_HEX , VALS ( iax_dataformats ) , 0x0 , NULL , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_BYTE , {\n \"Unknown\" , \"iax2.iax.unknownbyte\" , FT_UINT8 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_I16 , {\n \"Unknown\" , \"iax2.iax.unknownshort\" , FT_UINT16 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_I32 , {\n \"Unknown\" , \"iax2.iax.unknownlong\" , FT_UINT32 , BASE_HEX , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_IAX_IE_UNKNOWN_BYTES , {\n \"Unknown\" , \"iax2.iax.unknownstring\" , FT_STRING , BASE_NONE , NULL , 0x0 , \"Raw data for unknown IEs\" , HFILL }\n }\n , {\n & hf_iax2_ie_id , {\n \"IE id\" , \"iax2.ie_id\" , FT_UINT8 , BASE_DEC | BASE_EXT_STRING , & iax_ies_type_ext , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_length , {\n \"Length\" , \"iax2.length\" , FT_UINT8 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g723_1 , {\n \"G.723.1 compression\" , \"iax2.cap.g723_1\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G723_1 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_gsm , {\n \"GSM compression\" , \"iax2.cap.gsm\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_GSM , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_ulaw , {\n \"Raw mu-law data (G.711)\" , \"iax2.cap.ulaw\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ULAW , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_alaw , {\n \"Raw A-law data (G.711)\" , \"iax2.cap.alaw\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ALAW , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g726_aal2 , {\n \"G.726 compression (AAL2 packing)\" , \"iax2.cap.g726_aal2\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G726_AAL2 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_adpcm , {\n \"ADPCM\" , \"iax2.cap.adpcm\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ADPCM , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_slinear , {\n \"Raw 16-bit Signed Linear (8000 Hz) PCM\" , \"iax2.cap.slinear\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SLINEAR , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_lpc10 , {\n \"LPC10, 180 samples/frame\" , \"iax2.cap.lpc10\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_LPC10 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g729a , {\n \"G.729a Audio\" , \"iax2.cap.g729a\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G729A , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_speex , {\n \"SPEEX Audio\" , \"iax2.cap.speex\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SPEEX , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_ilbc , {\n \"iLBC Free compressed Audio\" , \"iax2.cap.ilbc\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_ILBC , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g726 , {\n \"ADPCM (G.726, 32kbps, RFC3551 codeword packing)\" , \"iax2.cap.g726\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G726 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_g722 , {\n \"G.722 wideband audio\" , \"iax2.cap.g722\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_G722 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_siren7 , {\n \"G.722.1 (also known as Siren7, 32kbps assumed)\" , \"iax2.cap.siren7\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SIREN7 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_siren14 , {\n \"G.722.1 Annex C (also known as Siren14, 48kbps assumed)\" , \"iax2.cap.siren14\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SIREN14 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_slinear16 , {\n \"Raw 16-bit Signed Linear (16000 Hz) PCM\" , \"iax2.cap.slinear16\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_SLINEAR16 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_jpeg , {\n \"JPEG images\" , \"iax2.cap.jpeg\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_JPEG , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_png , {\n \"PNG images\" , \"iax2.cap.png\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_PNG , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h261 , {\n \"H.261 video\" , \"iax2.cap.h261\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H261 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h263 , {\n \"H.263 video\" , \"iax2.cap.h263\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H263 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h263_plus , {\n \"H.263+ video\" , \"iax2.cap.h263_plus\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H263_PLUS , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_h264 , {\n \"H.264 video\" , \"iax2.cap.h264\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_H264 , NULL , HFILL }\n }\n , {\n & hf_iax2_cap_mpeg4 , {\n \"MPEG4 video\" , \"iax2.cap.mpeg4\" , FT_BOOLEAN , 32 , TFS ( & tfs_supported_not_supported ) , AST_FORMAT_MP4_VIDEO , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment_unfinished , {\n \"IAX2 fragment, unfinished\" , \"iax2.fragment_unfinished\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_payload_data , {\n \"IAX2 payload\" , \"iax2.payload_data\" , FT_BYTES , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragments , {\n \"IAX2 Fragments\" , \"iax2.fragments\" , FT_NONE , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment , {\n \"IAX2 Fragment data\" , \"iax2.fragment\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_fragment_overlap , {\n \"Fragment overlap\" , \"iax2.fragment.overlap\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Fragment overlaps with other fragments\" , HFILL }\n }\n , {\n & hf_iax2_fragment_overlap_conflict , {\n \"Conflicting data in fragment overlap\" , \"iax2.fragment.overlap.conflict\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Overlapping fragments contained conflicting data\" , HFILL }\n }\n , {\n & hf_iax2_fragment_multiple_tails , {\n \"Multiple tail fragments found\" , \"iax2.fragment.multipletails\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Several tails were found when defragmenting the packet\" , HFILL }\n }\n , {\n & hf_iax2_fragment_too_long_fragment , {\n \"Fragment too long\" , \"iax2.fragment.toolongfragment\" , FT_BOOLEAN , BASE_NONE , NULL , 0x0 , \"Fragment contained data past end of packet\" , HFILL }\n }\n , {\n & hf_iax2_fragment_error , {\n \"Defragmentation error\" , \"iax2.fragment.error\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"Defragmentation error due to illegal fragments\" , HFILL }\n }\n , {\n & hf_iax2_fragment_count , {\n \"Fragment count\" , \"iax2.fragment.count\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , NULL , HFILL }\n }\n , {\n & hf_iax2_reassembled_in , {\n \"IAX2 fragment, reassembled in frame\" , \"iax2.reassembled_in\" , FT_FRAMENUM , BASE_NONE , NULL , 0x0 , \"This IAX2 packet is reassembled in this frame\" , HFILL }\n }\n , {\n & hf_iax2_reassembled_length , {\n \"Reassembled IAX2 length\" , \"iax2.reassembled.length\" , FT_UINT32 , BASE_DEC , NULL , 0x0 , \"The total length of the reassembled payload\" , HFILL }\n }\n }\n ;\n static gint * ett [ ] = {\n & ett_iax2 , & ett_iax2_full_mini_subtree , & ett_iax2_type , & ett_iax2_ie , & ett_iax2_codecs , & ett_iax2_ies_apparent_addr , & ett_iax2_fragment , & ett_iax2_fragments , & ett_iax2_trunk_cmddata , & ett_iax2_trunk_call }\n ;\n static ei_register_info ei [ ] = {\n {\n & ei_iax_too_many_transfers , {\n \"iax2.too_many_transfers\" , PI_PROTOCOL , PI_WARN , \"Too many transfers for iax_call\" , EXPFILL }\n }\n , {\n & ei_iax_circuit_id_conflict , {\n \"iax2.circuit_id_conflict\" , PI_PROTOCOL , PI_WARN , \"Circuit ID conflict\" , EXPFILL }\n }\n , {\n & ei_iax_peer_address_unsupported , {\n \"iax2.peer_address_unsupported\" , PI_PROTOCOL , PI_WARN , \"Peer address unsupported\" , EXPFILL }\n }\n , {\n & ei_iax_invalid_len , {\n \"iax2.invalid_len\" , PI_PROTOCOL , PI_WARN , \"Invalid length\" , EXPFILL }\n }\n }\n ;\n expert_module_t * expert_iax ;\n memset ( hf_iax2_ies , 0xff , sizeof ( hf_iax2_ies ) ) ;\n proto_iax2 = proto_register_protocol ( \"Inter-Asterisk eXchange v2\" , \"IAX2\" , \"iax2\" ) ;\n proto_register_field_array ( proto_iax2 , hf , array_length ( hf ) ) ;\n proto_register_subtree_array ( ett , array_length ( ett ) ) ;\n expert_iax = expert_register_protocol ( proto_iax2 ) ;\n expert_register_field_array ( expert_iax , ei , array_length ( ei ) ) ;\n register_dissector ( \"iax2\" , dissect_iax2 , proto_iax2 ) ;\n iax2_codec_dissector_table = register_dissector_table ( \"iax2.codec\" , \"IAX codec number\" , FT_UINT32 , BASE_HEX ) ;\n iax2_dataformat_dissector_table = register_dissector_table ( \"iax2.dataformat\" , \"IAX dataformat number\" , FT_UINT32 , BASE_HEX ) ;\n register_init_routine ( & iax_init_protocol ) ;\n register_cleanup_routine ( & iax_cleanup_protocol ) ;\n iax2_tap = register_tap ( \"IAX2\" ) ;\n }",
        "hash": -4055702019813176658,
        "project": "debian",
        "size": 572,
        "slice": {
            "memset": [
                [
                    1,
                    "void proto_register_iax2 ( void ) {\n"
                ],
                [
                    560,
                    " memset ( hf_iax2_ies , 0xff , sizeof ( hf_iax2_ies ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void proto_register_iax2 ( void ) {\n"
                ],
                [
                    560,
                    " memset ( hf_iax2_ies , 0xff , sizeof ( hf_iax2_ies ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void ps2_common_post_load ( PS2State * s ) {\n PS2Queue * q = & s -> queue ;\n int size ;\n int i ;\n int tmp_data [ PS2_QUEUE_SIZE ] ;\n size = q -> count > PS2_QUEUE_SIZE ? 0 : q -> count ;\n if ( size > 0 ) {\n for ( i = 0 ;\n i < size ;\n i ++ ) {\n tmp_data [ i ] = q -> data [ q -> rptr ] ;\n if ( ++ q -> rptr == 256 ) {\n q -> rptr = 0 ;\n }\n }\n memcpy ( q -> data , tmp_data , size ) ;\n }\n q -> rptr = 0 ;\n q -> wptr = size ;\n q -> count = size ;\n s -> update_irq ( s -> update_arg , q -> count != 0 ) ;\n }",
        "hash": 3426991998365732450,
        "project": "debian",
        "size": 22,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void ps2_common_post_load ( PS2State * s ) {\n"
                ],
                [
                    2,
                    " PS2Queue * q = & s -> queue ;\n"
                ],
                [
                    5,
                    " int tmp_data [ PS2_QUEUE_SIZE ] ;\n"
                ],
                [
                    7,
                    " if ( size > 0 ) {\n"
                ],
                [
                    9,
                    " i < size ;\n"
                ],
                [
                    11,
                    " tmp_data [ i ] = q -> data [ q -> rptr ] ;\n"
                ],
                [
                    16,
                    " memcpy ( q -> data , tmp_data , size ) ;\n"
                ],
                [
                    19,
                    " q -> wptr = size ;\n"
                ],
                [
                    20,
                    " q -> count = size ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void ps2_common_post_load ( PS2State * s ) {\n"
                ],
                [
                    2,
                    " PS2Queue * q = & s -> queue ;\n"
                ],
                [
                    5,
                    " int tmp_data [ PS2_QUEUE_SIZE ] ;\n"
                ],
                [
                    7,
                    " if ( size > 0 ) {\n"
                ],
                [
                    9,
                    " i < size ;\n"
                ],
                [
                    11,
                    " tmp_data [ i ] = q -> data [ q -> rptr ] ;\n"
                ],
                [
                    16,
                    " memcpy ( q -> data , tmp_data , size ) ;\n"
                ],
                [
                    19,
                    " q -> wptr = size ;\n"
                ],
                [
                    20,
                    " q -> count = size ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void mspack_fmap_free ( void * mem ) {\n free ( mem ) ;\n }",
        "hash": 6028689830752105670,
        "project": "debian",
        "size": 3,
        "slice": {
            "free": [
                [
                    1,
                    "static void mspack_fmap_free ( void * mem ) {\n"
                ],
                [
                    2,
                    " free ( mem ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void mspack_fmap_free ( void * mem ) {\n"
                ],
                [
                    2,
                    " free ( mem ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int uwsgi_php_request ( struct wsgi_request * wsgi_req ) {\n char real_filename [ PATH_MAX + 1 ] ;\n char * path_info = NULL ;\n size_t real_filename_len = 0 ;\n struct stat php_stat ;\n char * filename = NULL ;\n int force_empty_script_name = 0 ;\n zend_file_handle file_handle ;\n # ifdef ZTS TSRMLS_FETCH ( ) ;\n # endif SG ( server_context ) = ( void * ) wsgi_req ;\n if ( uwsgi_parse_vars ( wsgi_req ) ) {\n return - 1 ;\n }\n char * orig_path_info = wsgi_req -> path_info ;\n uint16_t orig_path_info_len = wsgi_req -> path_info_len ;\n if ( uphp . docroot ) {\n wsgi_req -> document_root = uphp . docroot ;\n }\n else if ( ! wsgi_req -> document_root_len ) {\n wsgi_req -> document_root = uwsgi . cwd ;\n }\n else {\n char * sanitized_docroot = ecalloc ( 1 , PATH_MAX + 1 ) ;\n if ( ! uwsgi_expand_path ( wsgi_req -> document_root , wsgi_req -> document_root_len , sanitized_docroot ) ) {\n efree ( sanitized_docroot ) ;\n return - 1 ;\n }\n wsgi_req -> document_root = sanitized_docroot ;\n }\n wsgi_req -> document_root_len = strlen ( wsgi_req -> document_root ) ;\n if ( uphp . app ) {\n # ifdef UWSGI_PCRE struct uwsgi_regexp_list * bypass = uphp . app_bypass ;\n while ( bypass ) {\n if ( uwsgi_regexp_match ( bypass -> pattern , bypass -> pattern_extra , wsgi_req -> uri , wsgi_req -> uri_len ) >= 0 ) {\n goto oldstyle ;\n }\n bypass = bypass -> next ;\n }\n # endif strcpy ( real_filename , uphp . app ) ;\n if ( wsgi_req -> path_info_len == 1 && wsgi_req -> path_info [ 0 ] == '/' ) {\n goto appready ;\n }\n if ( uphp . app_qs ) {\n size_t app_qs_len = strlen ( uphp . app_qs ) ;\n size_t qs_len = wsgi_req -> path_info_len + app_qs_len ;\n if ( wsgi_req -> query_string_len > 0 ) {\n qs_len += 1 + wsgi_req -> query_string_len ;\n }\n char * qs = ecalloc ( 1 , qs_len + 1 ) ;\n memcpy ( qs , uphp . app_qs , app_qs_len ) ;\n memcpy ( qs + app_qs_len , wsgi_req -> path_info , wsgi_req -> path_info_len ) ;\n if ( wsgi_req -> query_string_len > 0 ) {\n char * ptr = qs + app_qs_len + wsgi_req -> path_info_len ;\n * ptr = '&' ;\n memcpy ( ptr + 1 , wsgi_req -> query_string , wsgi_req -> query_string_len ) ;\n }\n wsgi_req -> query_string = qs ;\n wsgi_req -> query_string_len = qs_len ;\n }\n appready : wsgi_req -> path_info = \"\" ;\n wsgi_req -> path_info_len = 0 ;\n force_empty_script_name = 1 ;\n goto secure2 ;\n }\n # ifdef UWSGI_PCRE oldstyle : # endif filename = uwsgi_concat4n ( wsgi_req -> document_root , wsgi_req -> document_root_len , \"/\" , 1 , wsgi_req -> path_info , wsgi_req -> path_info_len , \"\" , 0 ) ;\n if ( uwsgi_php_walk ( wsgi_req , filename , wsgi_req -> document_root , wsgi_req -> document_root_len , & path_info ) ) {\n free ( filename ) ;\n if ( uphp . fallback || uphp . fallback2 ) {\n if ( uphp . fallback ) {\n filename = uwsgi_str ( uphp . fallback ) ;\n }\n else {\n filename = uwsgi_concat2n ( wsgi_req -> document_root , strlen ( wsgi_req -> document_root ) , uphp . fallback2 , strlen ( uphp . fallback2 ) ) ;\n wsgi_req -> script_name = uphp . fallback2 ;\n wsgi_req -> script_name_len = strlen ( uphp . fallback2 ) ;\n }\n if ( uphp . fallback_qs ) {\n size_t fqs_len = strlen ( uphp . fallback_qs ) ;\n size_t new_qs_len = orig_path_info_len + fqs_len + 1 + wsgi_req -> query_string_len ;\n char * new_qs = ecalloc ( 1 , new_qs_len + 1 ) ;\n memcpy ( new_qs , uphp . fallback_qs , fqs_len ) ;\n new_qs [ fqs_len ] = '=' ;\n memcpy ( new_qs + fqs_len + 1 , orig_path_info , orig_path_info_len ) ;\n if ( wsgi_req -> query_string_len ) {\n new_qs [ fqs_len + 1 + orig_path_info_len ] = '&' ;\n memcpy ( new_qs + fqs_len + 2 + orig_path_info_len , wsgi_req -> query_string , wsgi_req -> query_string_len ) ;\n }\n wsgi_req -> query_string = new_qs ;\n wsgi_req -> query_string_len = new_qs_len ;\n }\n }\n else {\n uwsgi_404 ( wsgi_req ) ;\n return - 1 ;\n }\n }\n if ( path_info ) {\n wsgi_req -> path_info = path_info ;\n wsgi_req -> path_info_len = orig_path_info_len - ( path_info - orig_path_info ) ;\n }\n else {\n wsgi_req -> path_info = \"\" ;\n wsgi_req -> path_info_len = 0 ;\n }\n if ( ! realpath ( filename , real_filename ) ) {\n free ( filename ) ;\n uwsgi_404 ( wsgi_req ) ;\n return - 1 ;\n }\n free ( filename ) ;\n real_filename_len = strlen ( real_filename ) ;\n if ( uphp . allowed_docroot ) {\n struct uwsgi_string_list * usl = uphp . allowed_docroot ;\n while ( usl ) {\n if ( ! uwsgi_starts_with ( real_filename , real_filename_len , usl -> value , usl -> len ) ) {\n goto secure ;\n }\n usl = usl -> next ;\n }\n uwsgi_403 ( wsgi_req ) ;\n uwsgi_log ( \"PHP security error: %s is not under an allowed docroot\\n\" , real_filename ) ;\n return - 1 ;\n }\n secure : if ( stat ( real_filename , & php_stat ) ) {\n uwsgi_404 ( wsgi_req ) ;\n return UWSGI_OK ;\n }\n if ( S_ISDIR ( php_stat . st_mode ) ) {\n if ( orig_path_info_len == 0 || ( orig_path_info_len > 0 && orig_path_info [ orig_path_info_len - 1 ] != '/' ) ) {\n wsgi_req -> path_info = orig_path_info ;\n wsgi_req -> path_info_len = orig_path_info_len ;\n uwsgi_redirect_to_slash ( wsgi_req ) ;\n return UWSGI_OK ;\n }\n struct uwsgi_string_list * upi = uphp . index ;\n real_filename [ real_filename_len ] = '/' ;\n real_filename_len ++ ;\n int found = 0 ;\n while ( upi ) {\n if ( real_filename_len + upi -> len + 1 < PATH_MAX ) {\n memcpy ( real_filename + real_filename_len , upi -> value , upi -> len + 1 ) ;\n if ( ! access ( real_filename , R_OK ) ) {\n found = 1 ;\n break ;\n }\n }\n upi = upi -> next ;\n }\n if ( ! found ) {\n uwsgi_404 ( wsgi_req ) ;\n return UWSGI_OK ;\n }\n real_filename_len = strlen ( real_filename ) ;\n }\n if ( uphp . allowed_ext ) {\n struct uwsgi_string_list * usl = uphp . allowed_ext ;\n while ( usl ) {\n if ( real_filename_len >= usl -> len ) {\n if ( ! uwsgi_strncmp ( real_filename + ( real_filename_len - usl -> len ) , usl -> len , usl -> value , usl -> len ) ) {\n goto secure2 ;\n }\n }\n usl = usl -> next ;\n }\n uwsgi_403 ( wsgi_req ) ;\n uwsgi_log ( \"PHP security error: %s does not end with an allowed extension\\n\" , real_filename ) ;\n return - 1 ;\n }\n secure2 : wsgi_req -> file = real_filename ;\n wsgi_req -> file_len = strlen ( wsgi_req -> file ) ;\n if ( uphp . allowed_scripts ) {\n struct uwsgi_string_list * usl = uphp . allowed_scripts ;\n while ( usl ) {\n if ( ! uwsgi_strncmp ( wsgi_req -> file , wsgi_req -> file_len , usl -> value , usl -> len ) ) {\n goto secure3 ;\n }\n usl = usl -> next ;\n }\n uwsgi_403 ( wsgi_req ) ;\n uwsgi_log ( \"PHP security error: %s is not an allowed script\\n\" , real_filename ) ;\n return - 1 ;\n }\n secure3 : if ( force_empty_script_name ) {\n wsgi_req -> script_name = \"\" ;\n wsgi_req -> script_name_len = 0 ;\n }\n else if ( ! uphp . fallback2 ) {\n wsgi_req -> script_name = orig_path_info ;\n if ( path_info ) {\n wsgi_req -> script_name_len = path_info - orig_path_info ;\n }\n else {\n wsgi_req -> script_name_len = orig_path_info_len ;\n }\n }\n # ifdef UWSGI_DEBUG uwsgi_log ( \"php filename = %s script_name = %.*s (%d) document_root = %.*s (%d)\\n\" , real_filename , wsgi_req -> script_name_len , wsgi_req -> script_name , wsgi_req -> script_name_len , wsgi_req -> document_root_len , wsgi_req -> document_root , wsgi_req -> document_root_len ) ;\n # endif SG ( request_info ) . request_uri = estrndup ( wsgi_req -> uri , wsgi_req -> uri_len ) ;\n SG ( request_info ) . request_method = estrndup ( wsgi_req -> method , wsgi_req -> method_len ) ;\n SG ( request_info ) . proto_num = 1001 ;\n SG ( request_info ) . query_string = estrndup ( wsgi_req -> query_string , wsgi_req -> query_string_len ) ;\n SG ( request_info ) . content_length = wsgi_req -> post_cl ;\n SG ( request_info ) . content_type = estrndup ( wsgi_req -> content_type , wsgi_req -> content_type_len ) ;\n SG ( sapi_headers ) . http_response_code = 200 ;\n SG ( request_info ) . path_translated = wsgi_req -> file ;\n file_handle . type = ZEND_HANDLE_FILENAME ;\n file_handle . filename = real_filename ;\n file_handle . free_filename = 0 ;\n file_handle . opened_path = NULL ;\n if ( php_request_startup ( TSRMLS_C ) == FAILURE ) {\n uwsgi_500 ( wsgi_req ) ;\n return - 1 ;\n }\n struct uwsgi_string_list * usl = NULL ;\n uwsgi_foreach ( usl , uphp . exec_before ) {\n if ( zend_eval_string_ex ( usl -> value , NULL , \"uWSGI php exec before\" , 1 TSRMLS_CC ) == FAILURE ) goto end ;\n }\n php_execute_script ( & file_handle TSRMLS_CC ) ;\n uwsgi_foreach ( usl , uphp . exec_after ) {\n if ( zend_eval_string_ex ( usl -> value , NULL , \"uWSGI php exec after\" , 1 TSRMLS_CC ) == FAILURE ) goto end ;\n }\n end : php_request_shutdown ( NULL ) ;\n return 0 ;\n }",
        "hash": 4511225370772574632,
        "project": "debian",
        "size": 223,
        "slice": {
            "strlen": [
                [
                    11,
                    " if ( uwsgi_parse_vars ( wsgi_req ) ) {\n"
                ],
                [
                    16,
                    " if ( uphp . docroot ) {\n"
                ],
                [
                    17,
                    " wsgi_req -> document_root = uphp . docroot ;\n"
                ],
                [
                    19,
                    " else if ( ! wsgi_req -> document_root_len ) {\n"
                ],
                [
                    20,
                    " wsgi_req -> document_root = uwsgi . cwd ;\n"
                ],
                [
                    24,
                    " if ( ! uwsgi_expand_path ( wsgi_req -> document_root , wsgi_req -> document_root_len , sanitized_docroot ) ) {\n"
                ],
                [
                    28,
                    " wsgi_req -> document_root = sanitized_docroot ;\n"
                ],
                [
                    30,
                    " wsgi_req -> document_root_len = strlen ( wsgi_req -> document_root ) ;\n"
                ]
            ],
            "result": [
                [
                    11,
                    " if ( uwsgi_parse_vars ( wsgi_req ) ) {\n"
                ],
                [
                    16,
                    " if ( uphp . docroot ) {\n"
                ],
                [
                    17,
                    " wsgi_req -> document_root = uphp . docroot ;\n"
                ],
                [
                    19,
                    " else if ( ! wsgi_req -> document_root_len ) {\n"
                ],
                [
                    20,
                    " wsgi_req -> document_root = uwsgi . cwd ;\n"
                ],
                [
                    24,
                    " if ( ! uwsgi_expand_path ( wsgi_req -> document_root , wsgi_req -> document_root_len , sanitized_docroot ) ) {\n"
                ],
                [
                    28,
                    " wsgi_req -> document_root = sanitized_docroot ;\n"
                ],
                [
                    30,
                    " wsgi_req -> document_root_len = strlen ( wsgi_req -> document_root ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int uwsgi_php_init ( void ) {\n struct uwsgi_string_list * pset = uphp . set ;\n struct uwsgi_string_list * append_config = uphp . append_config ;\n # ifdef ZTS tsrm_startup ( 1 , 1 , 0 , NULL ) ;\n # endif sapi_startup ( & uwsgi_sapi_module ) ;\n while ( append_config ) {\n uwsgi_php_append_config ( append_config -> value ) ;\n append_config = append_config -> next ;\n }\n while ( pset ) {\n uwsgi_php_set ( pset -> value ) ;\n pset = pset -> next ;\n }\n if ( uphp . dump_config ) {\n uwsgi_log ( \"--- PHP custom config ---\\n\\n\" ) ;\n uwsgi_log ( \"%s\\n\" , uwsgi_sapi_module . ini_entries ) ;\n uwsgi_log ( \"--- end of PHP custom config ---\\n\" ) ;\n }\n if ( uphp . docroot ) {\n char * orig_docroot = uphp . docroot ;\n uphp . docroot = uwsgi_expand_path ( uphp . docroot , strlen ( uphp . docroot ) , NULL ) ;\n if ( ! uphp . docroot ) {\n uwsgi_log ( \"unable to set php docroot to %s\\n\" , orig_docroot ) ;\n exit ( 1 ) ;\n }\n }\n if ( uphp . sapi_name ) {\n uwsgi_sapi_module . name = uphp . sapi_name ;\n }\n uwsgi_sapi_module . startup ( & uwsgi_sapi_module ) ;\n uwsgi_log ( \"PHP %s initialized\\n\" , PHP_VERSION ) ;\n return 0 ;\n }",
        "hash": 4511225370772574632,
        "project": "debian",
        "size": 33,
        "slice": {
            "strlen": [
                [
                    1,
                    "int uwsgi_php_init ( void ) {\n"
                ],
                [
                    19,
                    " if ( uphp . docroot ) {\n"
                ],
                [
                    21,
                    " uphp . docroot = uwsgi_expand_path ( uphp . docroot , strlen ( uphp . docroot ) , NULL ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int uwsgi_php_init ( void ) {\n"
                ],
                [
                    19,
                    " if ( uphp . docroot ) {\n"
                ],
                [
                    21,
                    " uphp . docroot = uwsgi_expand_path ( uphp . docroot , strlen ( uphp . docroot ) , NULL ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int test_sqr ( BIO * bp , BN_CTX * ctx ) {\n BIGNUM a , c , d , e ;\n int i ;\n BN_init ( & a ) ;\n BN_init ( & c ) ;\n BN_init ( & d ) ;\n BN_init ( & e ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ;\n a . neg = rand_neg ( ) ;\n BN_sqr ( & c , & a , ctx ) ;\n if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , & a ) ;\n BIO_puts ( bp , \" * \" ) ;\n BN_print ( bp , & a ) ;\n BIO_puts ( bp , \" - \" ) ;\n }\n BN_print ( bp , & c ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n BN_div ( & d , & e , & c , & a , ctx ) ;\n BN_sub ( & d , & d , & a ) ;\n if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) {\n fprintf ( stderr , \"Square test failed!\\n\" ) ;\n return 0 ;\n }\n }\n BN_free ( & a ) ;\n BN_free ( & c ) ;\n BN_free ( & d ) ;\n BN_free ( & e ) ;\n return ( 1 ) ;\n }",
        "hash": -7553540414561818627,
        "project": "debian",
        "size": 36,
        "slice": {
            "fprintf": [
                [
                    1,
                    "int test_sqr ( BIO * bp , BN_CTX * ctx ) {\n"
                ],
                [
                    26,
                    " if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) {\n"
                ],
                [
                    27,
                    " fprintf ( stderr , \"Square test failed!\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int test_sqr ( BIO * bp , BN_CTX * ctx ) {\n"
                ],
                [
                    26,
                    " if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) {\n"
                ],
                [
                    27,
                    " fprintf ( stderr , \"Square test failed!\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) {\n unsigned int h , w , s , xcs , ycs , bps ;\n int align ;\n if ( ! buf_align ) buf_align = 1 ;\n if ( buf_align & ( buf_align - 1 ) ) goto fail ;\n if ( ! stride_align ) stride_align = 1 ;\n if ( stride_align & ( stride_align - 1 ) ) goto fail ;\n switch ( fmt ) {\n case VPX_IMG_FMT_RGB32 : case VPX_IMG_FMT_RGB32_LE : case VPX_IMG_FMT_ARGB : case VPX_IMG_FMT_ARGB_LE : bps = 32 ;\n break ;\n case VPX_IMG_FMT_RGB24 : case VPX_IMG_FMT_BGR24 : bps = 24 ;\n break ;\n case VPX_IMG_FMT_RGB565 : case VPX_IMG_FMT_RGB565_LE : case VPX_IMG_FMT_RGB555 : case VPX_IMG_FMT_RGB555_LE : case VPX_IMG_FMT_UYVY : case VPX_IMG_FMT_YUY2 : case VPX_IMG_FMT_YVYU : bps = 16 ;\n break ;\n case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : bps = 12 ;\n break ;\n case VPX_IMG_FMT_I422 : bps = 16 ;\n break ;\n case VPX_IMG_FMT_I444 : bps = 24 ;\n break ;\n case VPX_IMG_FMT_I42016 : bps = 24 ;\n break ;\n case VPX_IMG_FMT_I42216 : bps = 32 ;\n break ;\n case VPX_IMG_FMT_I44416 : bps = 48 ;\n break ;\n default : bps = 16 ;\n break ;\n }\n switch ( fmt ) {\n case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : xcs = 1 ;\n break ;\n default : xcs = 0 ;\n break ;\n }\n switch ( fmt ) {\n case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : ycs = 1 ;\n break ;\n default : ycs = 0 ;\n break ;\n }\n align = ( 1 << xcs ) - 1 ;\n w = ( d_w + align ) & ~ align ;\n align = ( 1 << ycs ) - 1 ;\n h = ( d_h + align ) & ~ align ;\n s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ;\n s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ;\n if ( ! img ) {\n img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;\n if ( ! img ) goto fail ;\n img -> self_allocd = 1 ;\n }\n else {\n memset ( img , 0 , sizeof ( vpx_image_t ) ) ;\n }\n img -> img_data = img_data ;\n if ( ! img_data ) {\n img -> img_data = img_buf_memalign ( buf_align , ( ( fmt & VPX_IMG_FMT_PLANAR ) ? h * s * bps / 8 : h * s ) ) ;\n img -> img_data_owner = 1 ;\n }\n if ( ! img -> img_data ) goto fail ;\n img -> fmt = fmt ;\n img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGH ) ? 16 : 8 ;\n img -> w = w ;\n img -> h = h ;\n img -> x_chroma_shift = xcs ;\n img -> y_chroma_shift = ycs ;\n img -> bps = bps ;\n img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = s ;\n img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = s >> xcs ;\n if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ;\n fail : vpx_img_free ( img ) ;\n return NULL ;\n }",
        "hash": -5537985723411439312,
        "project": "debian",
        "size": 74,
        "slice": {
            "memset": [
                [
                    1,
                    "static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) {\n"
                ],
                [
                    48,
                    " if ( ! img ) {\n"
                ],
                [
                    54,
                    " memset ( img , 0 , sizeof ( vpx_image_t ) ) ;\n"
                ],
                [
                    61,
                    " if ( ! img -> img_data ) goto fail ;\n"
                ],
                [
                    71,
                    " if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ;\n"
                ],
                [
                    72,
                    " fail : vpx_img_free ( img ) ;\n"
                ]
            ],
            "calloc": [
                [
                    1,
                    "static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) {\n"
                ],
                [
                    48,
                    " if ( ! img ) {\n"
                ],
                [
                    49,
                    " img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;\n"
                ],
                [
                    50,
                    " if ( ! img ) goto fail ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) {\n"
                ],
                [
                    48,
                    " if ( ! img ) {\n"
                ],
                [
                    49,
                    " img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;\n"
                ],
                [
                    50,
                    " if ( ! img ) goto fail ;\n"
                ],
                [
                    54,
                    " memset ( img , 0 , sizeof ( vpx_image_t ) ) ;\n"
                ],
                [
                    61,
                    " if ( ! img -> img_data ) goto fail ;\n"
                ],
                [
                    71,
                    " if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ;\n"
                ],
                [
                    72,
                    " fail : vpx_img_free ( img ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) {\n u_char * b , * s , * t , c ;\n int i , proto ;\n const void * se ;\n if ( length <= 0 ) return ;\n b = ( uint8_t * ) malloc ( length ) ;\n if ( b == NULL ) return ;\n for ( s = ( u_char * ) p , t = b , i = length ;\n i > 0 ;\n i -- ) {\n c = * s ++ ;\n if ( c == 0x7d ) {\n if ( i > 1 ) {\n i -- ;\n c = * s ++ ^ 0x20 ;\n }\n else continue ;\n }\n * t ++ = c ;\n }\n se = ndo -> ndo_snapend ;\n ndo -> ndo_snapend = t ;\n length = t - b ;\n if ( length < 1 ) goto trunc ;\n proto = * b ;\n switch ( proto ) {\n case PPP_IP : ip_print ( ndo , b + 1 , length - 1 ) ;\n goto cleanup ;\n case PPP_IPV6 : ip6_print ( ndo , b + 1 , length - 1 ) ;\n goto cleanup ;\n default : break ;\n }\n if ( length < 2 ) goto trunc ;\n proto = EXTRACT_16BITS ( b ) ;\n switch ( proto ) {\n case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ;\n proto = EXTRACT_16BITS ( b + 2 ) ;\n handle_ppp ( ndo , proto , b + 4 , length - 4 ) ;\n break ;\n default : handle_ppp ( ndo , proto , b + 2 , length - 2 ) ;\n break ;\n }\n cleanup : ndo -> ndo_snapend = se ;\n free ( b ) ;\n return ;\n trunc : ndo -> ndo_snapend = se ;\n free ( b ) ;\n ND_PRINT ( ( ndo , \"[|ppp]\" ) ) ;\n }",
        "hash": -5612058238993493687,
        "project": "debian",
        "size": 49,
        "slice": {
            "malloc": [
                [
                    1,
                    "static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) {\n"
                ],
                [
                    5,
                    " if ( length <= 0 ) return ;\n"
                ],
                [
                    6,
                    " b = ( uint8_t * ) malloc ( length ) ;\n"
                ],
                [
                    7,
                    " if ( b == NULL ) return ;\n"
                ],
                [
                    8,
                    " for ( s = ( u_char * ) p , t = b , i = length ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) {\n"
                ],
                [
                    23,
                    " length = t - b ;\n"
                ],
                [
                    24,
                    " if ( length < 1 ) goto trunc ;\n"
                ],
                [
                    26,
                    " switch ( proto ) {\n"
                ],
                [
                    33,
                    " if ( length < 2 ) goto trunc ;\n"
                ],
                [
                    34,
                    " proto = EXTRACT_16BITS ( b ) ;\n"
                ],
                [
                    35,
                    " switch ( proto ) {\n"
                ],
                [
                    36,
                    " case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ;\n"
                ],
                [
                    44,
                    " free ( b ) ;\n"
                ],
                [
                    47,
                    " free ( b ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) {\n"
                ],
                [
                    5,
                    " if ( length <= 0 ) return ;\n"
                ],
                [
                    6,
                    " b = ( uint8_t * ) malloc ( length ) ;\n"
                ],
                [
                    7,
                    " if ( b == NULL ) return ;\n"
                ],
                [
                    8,
                    " for ( s = ( u_char * ) p , t = b , i = length ;\n"
                ],
                [
                    23,
                    " length = t - b ;\n"
                ],
                [
                    24,
                    " if ( length < 1 ) goto trunc ;\n"
                ],
                [
                    26,
                    " switch ( proto ) {\n"
                ],
                [
                    33,
                    " if ( length < 2 ) goto trunc ;\n"
                ],
                [
                    34,
                    " proto = EXTRACT_16BITS ( b ) ;\n"
                ],
                [
                    35,
                    " switch ( proto ) {\n"
                ],
                [
                    36,
                    " case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ;\n"
                ],
                [
                    44,
                    " free ( b ) ;\n"
                ],
                [
                    47,
                    " free ( b ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static Asn1Generic * DecodeAsn1DerOctetString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t length , numbytes ;\n Asn1Generic * a ;\n unsigned char c ;\n d_ptr ++ ;\n c = d_ptr [ 0 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {\n length = c ;\n d_ptr ++ ;\n }\n else {\n numbytes = c & 0x7f ;\n d_ptr ++ ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {\n return NULL ;\n }\n }\n if ( length > max_size ) return NULL ;\n a = Asn1GenericNew ( ) ;\n if ( a == NULL ) return NULL ;\n a -> type = ASN1_OCTETSTRING ;\n a -> strlen = length ;\n a -> str = SCMalloc ( length + 1 ) ;\n if ( a -> str == NULL ) {\n SCFree ( a ) ;\n return NULL ;\n }\n memcpy ( a -> str , ( const char * ) d_ptr , length ) ;\n a -> str [ length ] = 0 ;\n d_ptr += length ;\n a -> length = ( d_ptr - buffer ) ;\n return a ;\n }",
        "hash": 2917602761308156638,
        "project": "debian",
        "size": 34,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static Asn1Generic * DecodeAsn1DerOctetString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n"
                ],
                [
                    6,
                    " d_ptr ++ ;\n"
                ],
                [
                    10,
                    " d_ptr ++ ;\n"
                ],
                [
                    14,
                    " d_ptr ++ ;\n"
                ],
                [
                    15,
                    " if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {\n"
                ],
                [
                    19,
                    " if ( length > max_size ) return NULL ;\n"
                ],
                [
                    21,
                    " if ( a == NULL ) return NULL ;\n"
                ],
                [
                    25,
                    " if ( a -> str == NULL ) {\n"
                ],
                [
                    29,
                    " memcpy ( a -> str , ( const char * ) d_ptr , length ) ;\n"
                ],
                [
                    31,
                    " d_ptr += length ;\n"
                ],
                [
                    33,
                    " return a ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static Asn1Generic * DecodeAsn1DerOctetString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n"
                ],
                [
                    6,
                    " d_ptr ++ ;\n"
                ],
                [
                    10,
                    " d_ptr ++ ;\n"
                ],
                [
                    14,
                    " d_ptr ++ ;\n"
                ],
                [
                    15,
                    " if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {\n"
                ],
                [
                    19,
                    " if ( length > max_size ) return NULL ;\n"
                ],
                [
                    21,
                    " if ( a == NULL ) return NULL ;\n"
                ],
                [
                    25,
                    " if ( a -> str == NULL ) {\n"
                ],
                [
                    29,
                    " memcpy ( a -> str , ( const char * ) d_ptr , length ) ;\n"
                ],
                [
                    31,
                    " d_ptr += length ;\n"
                ],
                [
                    33,
                    " return a ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n char myhash [ 16 ] ;\n if ( len < 16 ) return ;\n if ( userid < 0 || userid >= created_users ) return ;\n if ( ! users [ userid ] . active || users [ userid ] . disabled ) return ;\n if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN login raw, len %d, from user %d\\n\" , len , userid ) ;\n }\n login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;\n if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n struct sockaddr_in * tempin ;\n users [ userid ] . last_pkt = time ( NULL ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;\n send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;\n }\n }",
        "hash": 3246343243711264189,
        "project": "debian",
        "size": 21,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n"
                ],
                [
                    11,
                    " if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n"
                ],
                [
                    14,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    15,
                    " tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n"
                ],
                [
                    16,
                    " memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n"
                ],
                [
                    19,
                    " send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n"
                ],
                [
                    6,
                    " if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;\n"
                ],
                [
                    10,
                    " login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;\n"
                ],
                [
                    11,
                    " if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n"
                ],
                [
                    13,
                    " users [ userid ] . last_pkt = time ( NULL ) ;\n"
                ],
                [
                    14,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    15,
                    " tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n"
                ],
                [
                    16,
                    " memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n"
                ],
                [
                    17,
                    " user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n"
                ],
                [
                    18,
                    " login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;\n"
                ],
                [
                    19,
                    " send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n"
                ],
                [
                    3,
                    " if ( len < 16 ) return ;\n"
                ],
                [
                    4,
                    " if ( userid < 0 || userid >= created_users ) return ;\n"
                ],
                [
                    7,
                    " if ( debug >= 1 ) {\n"
                ],
                [
                    8,
                    " fprintf ( stderr , \"IN login raw, len %d, from user %d\\n\" , len , userid ) ;\n"
                ],
                [
                    17,
                    " user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n"
                ],
                [
                    3,
                    " if ( len < 16 ) return ;\n"
                ],
                [
                    4,
                    " if ( userid < 0 || userid >= created_users ) return ;\n"
                ],
                [
                    6,
                    " if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;\n"
                ],
                [
                    7,
                    " if ( debug >= 1 ) {\n"
                ],
                [
                    8,
                    " fprintf ( stderr , \"IN login raw, len %d, from user %d\\n\" , len , userid ) ;\n"
                ],
                [
                    10,
                    " login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;\n"
                ],
                [
                    11,
                    " if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n"
                ],
                [
                    13,
                    " users [ userid ] . last_pkt = time ( NULL ) ;\n"
                ],
                [
                    14,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    15,
                    " tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n"
                ],
                [
                    16,
                    " memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n"
                ],
                [
                    17,
                    " user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n"
                ],
                [
                    18,
                    " login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;\n"
                ],
                [
                    19,
                    " send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void handle_null_request ( int tun_fd , int dns_fd , struct query * q , int domain_len ) {\n struct in_addr tempip ;\n char in [ 512 ] ;\n char logindata [ 16 ] ;\n char out [ 64 * 1024 ] ;\n char unpacked [ 64 * 1024 ] ;\n char * tmp [ 2 ] ;\n int userid ;\n int read ;\n userid = - 1 ;\n if ( domain_len < 2 ) return ;\n memcpy ( in , q -> name , MIN ( domain_len , sizeof ( in ) ) ) ;\n if ( in [ 0 ] == 'V' || in [ 0 ] == 'v' ) {\n int version = 0 ;\n read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n if ( read > 4 ) {\n version = ( ( ( unpacked [ 0 ] & 0xff ) << 24 ) | ( ( unpacked [ 1 ] & 0xff ) << 16 ) | ( ( unpacked [ 2 ] & 0xff ) << 8 ) | ( ( unpacked [ 3 ] & 0xff ) ) ) ;\n }\n if ( version == VERSION ) {\n userid = find_available_user ( ) ;\n if ( userid >= 0 ) {\n int i ;\n struct sockaddr_in * tempin ;\n users [ userid ] . seed = rand ( ) ;\n tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n users [ userid ] . encoder = get_base32_encoder ( ) ;\n users [ userid ] . downenc = 'T' ;\n send_version_response ( dns_fd , VERSION_ACK , users [ userid ] . seed , userid , q ) ;\n syslog ( LOG_INFO , \"accepted version for user #%d from %s\" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n users [ userid ] . q . id = 0 ;\n users [ userid ] . q . id2 = 0 ;\n users [ userid ] . q_sendrealsoon . id = 0 ;\n users [ userid ] . q_sendrealsoon . id2 = 0 ;\n users [ userid ] . q_sendrealsoon_new = 0 ;\n users [ userid ] . outpacket . len = 0 ;\n users [ userid ] . outpacket . offset = 0 ;\n users [ userid ] . outpacket . sentlen = 0 ;\n users [ userid ] . outpacket . seqno = 0 ;\n users [ userid ] . outpacket . fragment = 0 ;\n users [ userid ] . outfragresent = 0 ;\n users [ userid ] . inpacket . len = 0 ;\n users [ userid ] . inpacket . offset = 0 ;\n users [ userid ] . inpacket . seqno = 0 ;\n users [ userid ] . inpacket . fragment = 0 ;\n users [ userid ] . fragsize = 100 ;\n users [ userid ] . conn = CONN_DNS_NULL ;\n users [ userid ] . lazy = 0 ;\n # ifdef OUTPACKETQ_LEN users [ userid ] . outpacketq_nexttouse = 0 ;\n users [ userid ] . outpacketq_filled = 0 ;\n # endif # ifdef DNSCACHE_LEN {\n for ( i = 0 ;\n i < DNSCACHE_LEN ;\n i ++ ) {\n users [ userid ] . dnscache_q [ i ] . id = 0 ;\n users [ userid ] . dnscache_answerlen [ i ] = 0 ;\n }\n }\n users [ userid ] . dnscache_lastfilled = 0 ;\n # endif for ( i = 0 ;\n i < QMEMPING_LEN ;\n i ++ ) users [ userid ] . qmemping_type [ i ] = T_UNSET ;\n users [ userid ] . qmemping_lastfilled = 0 ;\n for ( i = 0 ;\n i < QMEMDATA_LEN ;\n i ++ ) users [ userid ] . qmemdata_type [ i ] = T_UNSET ;\n users [ userid ] . qmemdata_lastfilled = 0 ;\n }\n else {\n send_version_response ( dns_fd , VERSION_FULL , created_users , 0 , q ) ;\n syslog ( LOG_INFO , \"dropped user from %s, server full\" , format_addr ( & q -> from , q -> fromlen ) ) ;\n }\n }\n else {\n send_version_response ( dns_fd , VERSION_NACK , VERSION , 0 , q ) ;\n syslog ( LOG_INFO , \"dropped user from %s, sent bad version %08X\" , format_addr ( & q -> from , q -> fromlen ) , version ) ;\n }\n return ;\n }\n else if ( in [ 0 ] == 'L' || in [ 0 ] == 'l' ) {\n read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n if ( read < 17 ) {\n write_dns ( dns_fd , q , \"BADLEN\" , 6 , 'T' ) ;\n return ;\n }\n userid = unpacked [ 0 ] ;\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n write_dns ( dns_fd , q , \"BADIP\" , 5 , 'T' ) ;\n syslog ( LOG_WARNING , \"dropped login request from user #%d from unexpected source %s\" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n return ;\n }\n else {\n users [ userid ] . last_pkt = time ( NULL ) ;\n login_calculate ( logindata , 16 , password , users [ userid ] . seed ) ;\n if ( read >= 18 && ( memcmp ( logindata , unpacked + 1 , 16 ) == 0 ) ) {\n tempip . s_addr = my_ip ;\n tmp [ 0 ] = strdup ( inet_ntoa ( tempip ) ) ;\n tempip . s_addr = users [ userid ] . tun_ip ;\n tmp [ 1 ] = strdup ( inet_ntoa ( tempip ) ) ;\n read = snprintf ( out , sizeof ( out ) , \"%s-%s-%d-%d\" , tmp [ 0 ] , tmp [ 1 ] , my_mtu , netmask ) ;\n write_dns ( dns_fd , q , out , read , users [ userid ] . downenc ) ;\n q -> id = 0 ;\n syslog ( LOG_NOTICE , \"accepted password from user #%d, given IP %s\" , userid , tmp [ 1 ] ) ;\n free ( tmp [ 1 ] ) ;\n free ( tmp [ 0 ] ) ;\n }\n else {\n write_dns ( dns_fd , q , \"LNAK\" , 4 , 'T' ) ;\n syslog ( LOG_WARNING , \"rejected login request from user #%d from %s, bad password\" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n }\n }\n return ;\n }\n else if ( in [ 0 ] == 'I' || in [ 0 ] == 'i' ) {\n in_addr_t replyaddr ;\n unsigned addr ;\n char reply [ 5 ] ;\n userid = b32_8to5 ( in [ 1 ] ) ;\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n write_dns ( dns_fd , q , \"BADIP\" , 5 , 'T' ) ;\n return ;\n }\n if ( ns_ip != INADDR_ANY ) {\n replyaddr = ns_ip ;\n }\n else {\n memcpy ( & replyaddr , & q -> destination . s_addr , sizeof ( in_addr_t ) ) ;\n }\n addr = htonl ( replyaddr ) ;\n reply [ 0 ] = 'I' ;\n reply [ 1 ] = ( addr >> 24 ) & 0xFF ;\n reply [ 2 ] = ( addr >> 16 ) & 0xFF ;\n reply [ 3 ] = ( addr >> 8 ) & 0xFF ;\n reply [ 4 ] = ( addr >> 0 ) & 0xFF ;\n write_dns ( dns_fd , q , reply , sizeof ( reply ) , 'T' ) ;\n }\n else if ( in [ 0 ] == 'Z' || in [ 0 ] == 'z' ) {\n write_dns ( dns_fd , q , in , domain_len , 'T' ) ;\n return ;\n }\n else if ( in [ 0 ] == 'S' || in [ 0 ] == 's' ) {\n int codec ;\n struct encoder * enc ;\n if ( domain_len < 3 ) {\n write_dns ( dns_fd , q , \"BADLEN\" , 6 , 'T' ) ;\n return ;\n }\n userid = b32_8to5 ( in [ 1 ] ) ;\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n write_dns ( dns_fd , q , \"BADIP\" , 5 , 'T' ) ;\n return ;\n }\n codec = b32_8to5 ( in [ 2 ] ) ;\n switch ( codec ) {\n case 5 : enc = get_base32_encoder ( ) ;\n user_switch_codec ( userid , enc ) ;\n write_dns ( dns_fd , q , enc -> name , strlen ( enc -> name ) , users [ userid ] . downenc ) ;\n break ;\n case 6 : enc = get_base64_encoder ( ) ;\n user_switch_codec ( userid , enc ) ;\n write_dns ( dns_fd , q , enc -> name , strlen ( enc -> name ) , users [ userid ] . downenc ) ;\n break ;\n case 26 : enc = get_base64u_encoder ( ) ;\n user_switch_codec ( userid , enc ) ;\n write_dns ( dns_fd , q , enc -> name , strlen ( enc -> name ) , users [ userid ] . downenc ) ;\n break ;\n case 7 : enc = get_base128_encoder ( ) ;\n user_switch_codec ( userid , enc ) ;\n write_dns ( dns_fd , q , enc -> name , strlen ( enc -> name ) , users [ userid ] . downenc ) ;\n break ;\n default : write_dns ( dns_fd , q , \"BADCODEC\" , 8 , users [ userid ] . downenc ) ;\n break ;\n }\n return ;\n }\n else if ( in [ 0 ] == 'O' || in [ 0 ] == 'o' ) {\n if ( domain_len < 3 ) {\n write_dns ( dns_fd , q , \"BADLEN\" , 6 , 'T' ) ;\n return ;\n }\n userid = b32_8to5 ( in [ 1 ] ) ;\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n write_dns ( dns_fd , q , \"BADIP\" , 5 , 'T' ) ;\n return ;\n }\n switch ( in [ 2 ] ) {\n case 'T' : case 't' : users [ userid ] . downenc = 'T' ;\n write_dns ( dns_fd , q , \"Base32\" , 6 , users [ userid ] . downenc ) ;\n break ;\n case 'S' : case 's' : users [ userid ] . downenc = 'S' ;\n write_dns ( dns_fd , q , \"Base64\" , 6 , users [ userid ] . downenc ) ;\n break ;\n case 'U' : case 'u' : users [ userid ] . downenc = 'U' ;\n write_dns ( dns_fd , q , \"Base64u\" , 7 , users [ userid ] . downenc ) ;\n break ;\n case 'V' : case 'v' : users [ userid ] . downenc = 'V' ;\n write_dns ( dns_fd , q , \"Base128\" , 7 , users [ userid ] . downenc ) ;\n break ;\n case 'R' : case 'r' : users [ userid ] . downenc = 'R' ;\n write_dns ( dns_fd , q , \"Raw\" , 3 , users [ userid ] . downenc ) ;\n break ;\n case 'L' : case 'l' : users [ userid ] . lazy = 1 ;\n write_dns ( dns_fd , q , \"Lazy\" , 4 , users [ userid ] . downenc ) ;\n break ;\n case 'I' : case 'i' : users [ userid ] . lazy = 0 ;\n write_dns ( dns_fd , q , \"Immediate\" , 9 , users [ userid ] . downenc ) ;\n break ;\n default : write_dns ( dns_fd , q , \"BADCODEC\" , 8 , users [ userid ] . downenc ) ;\n break ;\n }\n return ;\n }\n else if ( in [ 0 ] == 'Y' || in [ 0 ] == 'y' ) {\n int i ;\n char * datap ;\n int datalen ;\n if ( domain_len < 6 ) {\n write_dns ( dns_fd , q , \"BADLEN\" , 6 , 'T' ) ;\n return ;\n }\n i = b32_8to5 ( in [ 2 ] ) ;\n switch ( i ) {\n case 1 : datap = DOWNCODECCHECK1 ;\n datalen = DOWNCODECCHECK1_LEN ;\n break ;\n default : write_dns ( dns_fd , q , \"BADLEN\" , 6 , 'T' ) ;\n return ;\n }\n switch ( in [ 1 ] ) {\n case 'T' : case 't' : if ( q -> type == T_TXT || q -> type == T_SRV || q -> type == T_MX || q -> type == T_CNAME || q -> type == T_A ) {\n write_dns ( dns_fd , q , datap , datalen , 'T' ) ;\n return ;\n }\n break ;\n case 'S' : case 's' : if ( q -> type == T_TXT || q -> type == T_SRV || q -> type == T_MX || q -> type == T_CNAME || q -> type == T_A ) {\n write_dns ( dns_fd , q , datap , datalen , 'S' ) ;\n return ;\n }\n break ;\n case 'U' : case 'u' : if ( q -> type == T_TXT || q -> type == T_SRV || q -> type == T_MX || q -> type == T_CNAME || q -> type == T_A ) {\n write_dns ( dns_fd , q , datap , datalen , 'U' ) ;\n return ;\n }\n break ;\n case 'V' : case 'v' : if ( q -> type == T_TXT || q -> type == T_SRV || q -> type == T_MX || q -> type == T_CNAME || q -> type == T_A ) {\n write_dns ( dns_fd , q , datap , datalen , 'V' ) ;\n return ;\n }\n break ;\n case 'R' : case 'r' : if ( q -> type == T_NULL || q -> type == T_TXT ) {\n write_dns ( dns_fd , q , datap , datalen , 'R' ) ;\n return ;\n }\n break ;\n }\n write_dns ( dns_fd , q , \"BADCODEC\" , 8 , 'T' ) ;\n return ;\n }\n else if ( in [ 0 ] == 'R' || in [ 0 ] == 'r' ) {\n int req_frag_size ;\n if ( domain_len < 16 ) {\n write_dns ( dns_fd , q , \"BADLEN\" , 6 , 'T' ) ;\n return ;\n }\n userid = ( b32_8to5 ( in [ 1 ] ) >> 1 ) & 15 ;\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n write_dns ( dns_fd , q , \"BADIP\" , 5 , 'T' ) ;\n return ;\n }\n req_frag_size = ( ( b32_8to5 ( in [ 1 ] ) & 1 ) << 10 ) | ( ( b32_8to5 ( in [ 2 ] ) & 31 ) << 5 ) | ( b32_8to5 ( in [ 3 ] ) & 31 ) ;\n if ( req_frag_size < 2 || req_frag_size > 2047 ) {\n write_dns ( dns_fd , q , \"BADFRAG\" , 7 , users [ userid ] . downenc ) ;\n }\n else {\n char buf [ 2048 ] ;\n int i ;\n unsigned int v = ( ( unsigned int ) rand ( ) ) & 0xff ;\n memset ( buf , 0 , sizeof ( buf ) ) ;\n buf [ 0 ] = ( req_frag_size >> 8 ) & 0xff ;\n buf [ 1 ] = req_frag_size & 0xff ;\n buf [ 2 ] = 107 ;\n for ( i = 3 ;\n i < 2048 ;\n i ++ , v = ( v + 107 ) & 0xff ) buf [ i ] = v ;\n write_dns ( dns_fd , q , buf , req_frag_size , users [ userid ] . downenc ) ;\n }\n return ;\n }\n else if ( in [ 0 ] == 'N' || in [ 0 ] == 'n' ) {\n int max_frag_size ;\n read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n if ( read < 3 ) {\n write_dns ( dns_fd , q , \"BADLEN\" , 6 , 'T' ) ;\n return ;\n }\n userid = unpacked [ 0 ] ;\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n write_dns ( dns_fd , q , \"BADIP\" , 5 , 'T' ) ;\n return ;\n }\n max_frag_size = ( ( unpacked [ 1 ] & 0xff ) << 8 ) | ( unpacked [ 2 ] & 0xff ) ;\n if ( max_frag_size < 2 ) {\n write_dns ( dns_fd , q , \"BADFRAG\" , 7 , users [ userid ] . downenc ) ;\n }\n else {\n users [ userid ] . fragsize = max_frag_size ;\n write_dns ( dns_fd , q , & unpacked [ 1 ] , 2 , users [ userid ] . downenc ) ;\n }\n return ;\n }\n else if ( in [ 0 ] == 'P' || in [ 0 ] == 'p' ) {\n int dn_seq ;\n int dn_frag ;\n int didsend = 0 ;\n if ( q -> id == 0 ) return ;\n read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n if ( read < 4 ) return ;\n userid = unpacked [ 0 ] ;\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n write_dns ( dns_fd , q , \"BADIP\" , 5 , 'T' ) ;\n return ;\n }\n # ifdef DNSCACHE_LEN if ( answer_from_dnscache ( dns_fd , userid , q ) ) return ;\n # endif if ( answer_from_qmem ( dns_fd , q , users [ userid ] . qmemping_cmc , users [ userid ] . qmemping_type , QMEMPING_LEN , ( void * ) unpacked ) ) return ;\n if ( users [ userid ] . q . id != 0 && q -> type == users [ userid ] . q . type && ! strcmp ( q -> name , users [ userid ] . q . name ) && users [ userid ] . lazy ) {\n if ( debug >= 2 ) {\n fprintf ( stderr , \"PING pkt from user %d = dupe from impatient DNS server, remembering\\n\" , userid ) ;\n }\n users [ userid ] . q . id2 = q -> id ;\n users [ userid ] . q . fromlen2 = q -> fromlen ;\n memcpy ( & ( users [ userid ] . q . from2 ) , & ( q -> from ) , q -> fromlen ) ;\n return ;\n }\n if ( users [ userid ] . q_sendrealsoon . id != 0 && q -> type == users [ userid ] . q_sendrealsoon . type && ! strcmp ( q -> name , users [ userid ] . q_sendrealsoon . name ) ) {\n if ( debug >= 2 ) {\n fprintf ( stderr , \"PING pkt from user %d = dupe from impatient DNS server, remembering\\n\" , userid ) ;\n }\n users [ userid ] . q_sendrealsoon . id2 = q -> id ;\n users [ userid ] . q_sendrealsoon . fromlen2 = q -> fromlen ;\n memcpy ( & ( users [ userid ] . q_sendrealsoon . from2 ) , & ( q -> from ) , q -> fromlen ) ;\n return ;\n }\n dn_seq = unpacked [ 1 ] >> 4 ;\n dn_frag = unpacked [ 1 ] & 15 ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"PING pkt from user %d, ack for downstream %d/%d\\n\" , userid , dn_seq , dn_frag ) ;\n }\n process_downstream_ack ( userid , dn_seq , dn_frag ) ;\n if ( debug >= 3 ) {\n fprintf ( stderr , \"PINGret (if any) will ack upstream %d/%d\\n\" , users [ userid ] . inpacket . seqno , users [ userid ] . inpacket . fragment ) ;\n }\n if ( users [ userid ] . q_sendrealsoon . id != 0 ) {\n send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q_sendrealsoon ) ;\n }\n if ( users [ userid ] . q . id != 0 ) {\n didsend = 1 ;\n if ( send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) == 1 ) didsend = 0 ;\n }\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n users [ userid ] . last_pkt = time ( NULL ) ;\n if ( ( ! didsend && users [ userid ] . outpacket . len > 0 ) || ! users [ userid ] . lazy ) send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) ;\n }\n else if ( ( in [ 0 ] >= '0' && in [ 0 ] <= '9' ) || ( in [ 0 ] >= 'a' && in [ 0 ] <= 'f' ) || ( in [ 0 ] >= 'A' && in [ 0 ] <= 'F' ) ) {\n int up_seq , up_frag , dn_seq , dn_frag , lastfrag ;\n int upstream_ok = 1 ;\n int didsend = 0 ;\n int code = - 1 ;\n if ( domain_len < 6 ) return ;\n if ( q -> id == 0 ) return ;\n if ( ( in [ 0 ] >= '0' && in [ 0 ] <= '9' ) ) code = in [ 0 ] - '0' ;\n if ( ( in [ 0 ] >= 'a' && in [ 0 ] <= 'f' ) ) code = in [ 0 ] - 'a' + 10 ;\n if ( ( in [ 0 ] >= 'A' && in [ 0 ] <= 'F' ) ) code = in [ 0 ] - 'A' + 10 ;\n userid = code ;\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n write_dns ( dns_fd , q , \"BADIP\" , 5 , 'T' ) ;\n return ;\n }\n # ifdef DNSCACHE_LEN if ( answer_from_dnscache ( dns_fd , userid , q ) ) return ;\n # endif if ( answer_from_qmem_data ( dns_fd , userid , q ) ) return ;\n if ( users [ userid ] . q . id != 0 && q -> type == users [ userid ] . q . type && ! strcmp ( q -> name , users [ userid ] . q . name ) && users [ userid ] . lazy ) {\n if ( debug >= 2 ) {\n fprintf ( stderr , \"IN pkt from user %d = dupe from impatient DNS server, remembering\\n\" , userid ) ;\n }\n users [ userid ] . q . id2 = q -> id ;\n users [ userid ] . q . fromlen2 = q -> fromlen ;\n memcpy ( & ( users [ userid ] . q . from2 ) , & ( q -> from ) , q -> fromlen ) ;\n return ;\n }\n if ( users [ userid ] . q_sendrealsoon . id != 0 && q -> type == users [ userid ] . q_sendrealsoon . type && ! strcmp ( q -> name , users [ userid ] . q_sendrealsoon . name ) ) {\n if ( debug >= 2 ) {\n fprintf ( stderr , \"IN pkt from user %d = dupe from impatient DNS server, remembering\\n\" , userid ) ;\n }\n users [ userid ] . q_sendrealsoon . id2 = q -> id ;\n users [ userid ] . q_sendrealsoon . fromlen2 = q -> fromlen ;\n memcpy ( & ( users [ userid ] . q_sendrealsoon . from2 ) , & ( q -> from ) , q -> fromlen ) ;\n return ;\n }\n up_seq = ( b32_8to5 ( in [ 1 ] ) >> 2 ) & 7 ;\n up_frag = ( ( b32_8to5 ( in [ 1 ] ) & 3 ) << 2 ) | ( ( b32_8to5 ( in [ 2 ] ) >> 3 ) & 3 ) ;\n dn_seq = ( b32_8to5 ( in [ 2 ] ) & 7 ) ;\n dn_frag = b32_8to5 ( in [ 3 ] ) >> 1 ;\n lastfrag = b32_8to5 ( in [ 3 ] ) & 1 ;\n process_downstream_ack ( userid , dn_seq , dn_frag ) ;\n if ( up_seq == users [ userid ] . inpacket . seqno && up_frag <= users [ userid ] . inpacket . fragment ) {\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN pkt seq# %d, frag %d, dropped duplicate frag\\n\" , up_seq , up_frag ) ;\n }\n upstream_ok = 0 ;\n }\n else if ( up_seq != users [ userid ] . inpacket . seqno && recent_seqno ( users [ userid ] . inpacket . seqno , up_seq ) ) {\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN pkt seq# %d, frag %d, dropped duplicate recent seqno\\n\" , up_seq , up_frag ) ;\n }\n upstream_ok = 0 ;\n }\n else if ( up_seq != users [ userid ] . inpacket . seqno ) {\n users [ userid ] . inpacket . seqno = up_seq ;\n users [ userid ] . inpacket . fragment = up_frag ;\n users [ userid ] . inpacket . len = 0 ;\n users [ userid ] . inpacket . offset = 0 ;\n }\n else {\n users [ userid ] . inpacket . fragment = up_frag ;\n }\n if ( debug >= 3 ) {\n fprintf ( stderr , \"INpack with upstream %d/%d, we are going to ack upstream %d/%d\\n\" , up_seq , up_frag , users [ userid ] . inpacket . seqno , users [ userid ] . inpacket . fragment ) ;\n }\n if ( upstream_ok ) {\n read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 5 ] ) , domain_len - 5 , users [ userid ] . encoder ) ;\n read = MIN ( read , sizeof ( users [ userid ] . inpacket . data ) - users [ userid ] . inpacket . offset ) ;\n memcpy ( users [ userid ] . inpacket . data + users [ userid ] . inpacket . offset , unpacked , read ) ;\n users [ userid ] . inpacket . len += read ;\n users [ userid ] . inpacket . offset += read ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN pkt seq# %d, frag %d (last=%d), fragsize %d, total %d, from user %d\\n\" , up_seq , up_frag , lastfrag , read , users [ userid ] . inpacket . len , userid ) ;\n }\n }\n if ( upstream_ok && lastfrag ) {\n handle_full_packet ( tun_fd , dns_fd , userid ) ;\n }\n if ( users [ userid ] . q_sendrealsoon . id != 0 ) {\n didsend = 1 ;\n if ( send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q_sendrealsoon ) == 1 ) didsend = 0 ;\n }\n if ( users [ userid ] . q . id != 0 ) {\n if ( ( users [ userid ] . outpacket . len > 0 && ! didsend ) || ( upstream_ok && ! lastfrag && ! didsend ) || ( ! upstream_ok && ! didsend ) || ! users [ userid ] . lazy ) {\n didsend = 1 ;\n if ( send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) == 1 ) didsend = 0 ;\n }\n else {\n memcpy ( & ( users [ userid ] . q_sendrealsoon ) , & ( users [ userid ] . q ) , sizeof ( struct query ) ) ;\n users [ userid ] . q_sendrealsoon_new = 1 ;\n users [ userid ] . q . id = 0 ;\n didsend = 1 ;\n }\n }\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n users [ userid ] . last_pkt = time ( NULL ) ;\n if ( users [ userid ] . outpacket . len > 0 && ! didsend ) send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) ;\n else if ( ! didsend || ! users [ userid ] . lazy ) {\n if ( upstream_ok && lastfrag ) {\n memcpy ( & ( users [ userid ] . q_sendrealsoon ) , & ( users [ userid ] . q ) , sizeof ( struct query ) ) ;\n users [ userid ] . q_sendrealsoon_new = 1 ;\n users [ userid ] . q . id = 0 ;\n }\n else {\n send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) ;\n }\n }\n }\n }",
        "hash": 3246343243711264189,
        "project": "debian",
        "size": 472,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void handle_null_request ( int tun_fd , int dns_fd , struct query * q , int domain_len ) {\n"
                ],
                [
                    11,
                    " if ( domain_len < 2 ) return ;\n"
                ],
                [
                    12,
                    " memcpy ( in , q -> name , MIN ( domain_len , sizeof ( in ) ) ) ;\n"
                ],
                [
                    13,
                    " if ( in [ 0 ] == 'V' || in [ 0 ] == 'v' ) {\n"
                ],
                [
                    15,
                    " read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n"
                ],
                [
                    21,
                    " if ( userid >= 0 ) {\n"
                ],
                [
                    25,
                    " tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n"
                ],
                [
                    26,
                    " memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n"
                ],
                [
                    27,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    30,
                    " send_version_response ( dns_fd , VERSION_ACK , users [ userid ] . seed , userid , q ) ;\n"
                ],
                [
                    71,
                    " send_version_response ( dns_fd , VERSION_FULL , created_users , 0 , q ) ;\n"
                ],
                [
                    76,
                    " send_version_response ( dns_fd , VERSION_NACK , VERSION , 0 , q ) ;\n"
                ]
            ],
            "syslog": [
                [
                    1,
                    "static void handle_null_request ( int tun_fd , int dns_fd , struct query * q , int domain_len ) {\n"
                ],
                [
                    13,
                    " if ( in [ 0 ] == 'V' || in [ 0 ] == 'v' ) {\n"
                ],
                [
                    19,
                    " if ( version == VERSION ) {\n"
                ],
                [
                    21,
                    " if ( userid >= 0 ) {\n"
                ],
                [
                    30,
                    " send_version_response ( dns_fd , VERSION_ACK , users [ userid ] . seed , userid , q ) ;\n"
                ],
                [
                    31,
                    " syslog ( LOG_INFO , \"accepted version for user #%d from %s\" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n"
                ],
                [
                    72,
                    " syslog ( LOG_INFO , \"dropped user from %s, server full\" , format_addr ( & q -> from , q -> fromlen ) ) ;\n"
                ],
                [
                    77,
                    " syslog ( LOG_INFO , \"dropped user from %s, sent bad version %08X\" , format_addr ( & q -> from , q -> fromlen ) , version ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void handle_null_request ( int tun_fd , int dns_fd , struct query * q , int domain_len ) {\n"
                ],
                [
                    11,
                    " if ( domain_len < 2 ) return ;\n"
                ],
                [
                    12,
                    " memcpy ( in , q -> name , MIN ( domain_len , sizeof ( in ) ) ) ;\n"
                ],
                [
                    13,
                    " if ( in [ 0 ] == 'V' || in [ 0 ] == 'v' ) {\n"
                ],
                [
                    15,
                    " read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n"
                ],
                [
                    19,
                    " if ( version == VERSION ) {\n"
                ],
                [
                    21,
                    " if ( userid >= 0 ) {\n"
                ],
                [
                    25,
                    " tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n"
                ],
                [
                    26,
                    " memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n"
                ],
                [
                    27,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    30,
                    " send_version_response ( dns_fd , VERSION_ACK , users [ userid ] . seed , userid , q ) ;\n"
                ],
                [
                    31,
                    " syslog ( LOG_INFO , \"accepted version for user #%d from %s\" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n"
                ],
                [
                    71,
                    " send_version_response ( dns_fd , VERSION_FULL , created_users , 0 , q ) ;\n"
                ],
                [
                    72,
                    " syslog ( LOG_INFO , \"dropped user from %s, server full\" , format_addr ( & q -> from , q -> fromlen ) ) ;\n"
                ],
                [
                    76,
                    " send_version_response ( dns_fd , VERSION_NACK , VERSION , 0 , q ) ;\n"
                ],
                [
                    77,
                    " syslog ( LOG_INFO , \"dropped user from %s, sent bad version %08X\" , format_addr ( & q -> from , q -> fromlen ) , version ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void handle_raw_ping ( struct query * q , int dns_fd , int userid ) {\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n return ;\n }\n users [ userid ] . last_pkt = time ( NULL ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN ping raw, from user %d\\n\" , userid ) ;\n }\n send_raw ( dns_fd , NULL , 0 , userid , RAW_HDR_CMD_PING , q ) ;\n }",
        "hash": 3246343243711264189,
        "project": "debian",
        "size": 11,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void handle_raw_ping ( struct query * q , int dns_fd , int userid ) {\n"
                ],
                [
                    2,
                    " if ( check_user_and_ip ( userid , q ) != 0 ) {\n"
                ],
                [
                    6,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    10,
                    " send_raw ( dns_fd , NULL , 0 , userid , RAW_HDR_CMD_PING , q ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void handle_raw_ping ( struct query * q , int dns_fd , int userid ) {\n"
                ],
                [
                    2,
                    " if ( check_user_and_ip ( userid , q ) != 0 ) {\n"
                ],
                [
                    7,
                    " if ( debug >= 1 ) {\n"
                ],
                [
                    8,
                    " fprintf ( stderr , \"IN ping raw, from user %d\\n\" , userid ) ;\n"
                ],
                [
                    10,
                    " send_raw ( dns_fd , NULL , 0 , userid , RAW_HDR_CMD_PING , q ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void handle_raw_ping ( struct query * q , int dns_fd , int userid ) {\n"
                ],
                [
                    2,
                    " if ( check_user_and_ip ( userid , q ) != 0 ) {\n"
                ],
                [
                    6,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    7,
                    " if ( debug >= 1 ) {\n"
                ],
                [
                    8,
                    " fprintf ( stderr , \"IN ping raw, from user %d\\n\" , userid ) ;\n"
                ],
                [
                    10,
                    " send_raw ( dns_fd , NULL , 0 , userid , RAW_HDR_CMD_PING , q ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int check_user_and_ip ( int userid , struct query * q ) {\n struct sockaddr_in * tempin ;\n if ( userid < 0 || userid >= created_users ) {\n return 1 ;\n }\n if ( ! users [ userid ] . active || users [ userid ] . disabled ) {\n return 1 ;\n }\n if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) {\n return 1 ;\n }\n if ( ! check_ip ) {\n return 0 ;\n }\n tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n return memcmp ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n }",
        "hash": 3246343243711264189,
        "project": "debian",
        "size": 17,
        "slice": {
            "memcmp": [
                [
                    1,
                    "static int check_user_and_ip ( int userid , struct query * q ) {\n"
                ],
                [
                    12,
                    " if ( ! check_ip ) {\n"
                ],
                [
                    15,
                    " tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n"
                ],
                [
                    16,
                    " return memcmp ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int check_user_and_ip ( int userid , struct query * q ) {\n"
                ],
                [
                    12,
                    " if ( ! check_ip ) {\n"
                ],
                [
                    15,
                    " tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n"
                ],
                [
                    16,
                    " return memcmp ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void handle_raw_data ( char * packet , int len , struct query * q , int dns_fd , int tun_fd , int userid ) {\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n return ;\n }\n users [ userid ] . last_pkt = time ( NULL ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n users [ userid ] . inpacket . offset = 0 ;\n memcpy ( users [ userid ] . inpacket . data , packet , len ) ;\n users [ userid ] . inpacket . len = len ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN pkt raw, total %d, from user %d\\n\" , users [ userid ] . inpacket . len , userid ) ;\n }\n handle_full_packet ( tun_fd , dns_fd , userid ) ;\n }",
        "hash": 3246343243711264189,
        "project": "debian",
        "size": 14,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void handle_raw_data ( char * packet , int len , struct query * q , int dns_fd , int tun_fd , int userid ) {\n"
                ],
                [
                    2,
                    " if ( check_user_and_ip ( userid , q ) != 0 ) {\n"
                ],
                [
                    6,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    8,
                    " memcpy ( users [ userid ] . inpacket . data , packet , len ) ;\n"
                ],
                [
                    9,
                    " users [ userid ] . inpacket . len = len ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void handle_raw_data ( char * packet , int len , struct query * q , int dns_fd , int tun_fd , int userid ) {\n"
                ],
                [
                    2,
                    " if ( check_user_and_ip ( userid , q ) != 0 ) {\n"
                ],
                [
                    9,
                    " users [ userid ] . inpacket . len = len ;\n"
                ],
                [
                    10,
                    " if ( debug >= 1 ) {\n"
                ],
                [
                    11,
                    " fprintf ( stderr , \"IN pkt raw, total %d, from user %d\\n\" , users [ userid ] . inpacket . len , userid ) ;\n"
                ],
                [
                    13,
                    " handle_full_packet ( tun_fd , dns_fd , userid ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void handle_raw_data ( char * packet , int len , struct query * q , int dns_fd , int tun_fd , int userid ) {\n"
                ],
                [
                    2,
                    " if ( check_user_and_ip ( userid , q ) != 0 ) {\n"
                ],
                [
                    6,
                    " memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n"
                ],
                [
                    8,
                    " memcpy ( users [ userid ] . inpacket . data , packet , len ) ;\n"
                ],
                [
                    9,
                    " users [ userid ] . inpacket . len = len ;\n"
                ],
                [
                    10,
                    " if ( debug >= 1 ) {\n"
                ],
                [
                    11,
                    " fprintf ( stderr , \"IN pkt raw, total %d, from user %d\\n\" , users [ userid ] . inpacket . len , userid ) ;\n"
                ],
                [
                    13,
                    " handle_full_packet ( tun_fd , dns_fd , userid ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int mdb_search ( Operation * op , SlapReply * rs ) {\n struct mdb_info * mdb = ( struct mdb_info * ) op -> o_bd -> be_private ;\n ID id , cursor , nsubs , ncand , cscope ;\n ID lastid = NOID ;\n ID candidates [ MDB_IDL_UM_SIZE ] ;\n ID iscopes [ MDB_IDL_DB_SIZE ] ;\n ID2 * scopes ;\n void * stack ;\n Entry * e = NULL , * base = NULL ;\n Entry * matched = NULL ;\n AttributeName * attrs ;\n slap_mask_t mask ;\n time_t stoptime ;\n int manageDSAit ;\n int tentries = 0 ;\n IdScopes isc ;\n MDB_cursor * mci , * mcd ;\n ww_ctx wwctx ;\n slap_callback cb = {\n 0 }\n ;\n mdb_op_info opinfo = {\n {\n {\n 0 }\n }\n }\n , * moi = & opinfo ;\n MDB_txn * ltid = NULL ;\n Debug ( LDAP_DEBUG_TRACE , \"=> \" LDAP_XSTRING ( mdb_search ) \"\\n\" , 0 , 0 , 0 ) ;\n attrs = op -> oq_search . rs_attrs ;\n manageDSAit = get_manageDSAit ( op ) ;\n rs -> sr_err = mdb_opinfo_get ( op , mdb , 1 , & moi ) ;\n switch ( rs -> sr_err ) {\n case 0 : break ;\n default : send_ldap_error ( op , rs , LDAP_OTHER , \"internal error\" ) ;\n return rs -> sr_err ;\n }\n ltid = moi -> moi_txn ;\n rs -> sr_err = mdb_cursor_open ( ltid , mdb -> mi_id2entry , & mci ) ;\n if ( rs -> sr_err ) {\n send_ldap_error ( op , rs , LDAP_OTHER , \"internal error\" ) ;\n return rs -> sr_err ;\n }\n rs -> sr_err = mdb_cursor_open ( ltid , mdb -> mi_dn2id , & mcd ) ;\n if ( rs -> sr_err ) {\n mdb_cursor_close ( mci ) ;\n send_ldap_error ( op , rs , LDAP_OTHER , \"internal error\" ) ;\n return rs -> sr_err ;\n }\n scopes = scope_chunk_get ( op ) ;\n stack = search_stack ( op ) ;\n isc . mt = ltid ;\n isc . mc = mcd ;\n isc . scopes = scopes ;\n isc . oscope = op -> ors_scope ;\n isc . sctmp = stack ;\n if ( op -> ors_deref & LDAP_DEREF_FINDING ) {\n MDB_IDL_ZERO ( candidates ) ;\n }\n dn2entry_retry : rs -> sr_err = mdb_dn2entry ( op , ltid , mcd , & op -> o_req_ndn , & e , & nsubs , 1 ) ;\n switch ( rs -> sr_err ) {\n case MDB_NOTFOUND : matched = e ;\n e = NULL ;\n break ;\n case 0 : break ;\n case LDAP_BUSY : send_ldap_error ( op , rs , LDAP_BUSY , \"ldap server busy\" ) ;\n goto done ;\n default : send_ldap_error ( op , rs , LDAP_OTHER , \"internal error\" ) ;\n goto done ;\n }\n if ( op -> ors_deref & LDAP_DEREF_FINDING ) {\n if ( matched && is_entry_alias ( matched ) ) {\n struct berval stub ;\n stub . bv_val = op -> o_req_ndn . bv_val ;\n stub . bv_len = op -> o_req_ndn . bv_len - matched -> e_nname . bv_len - 1 ;\n e = deref_base ( op , rs , matched , & matched , ltid , candidates , NULL ) ;\n if ( e ) {\n build_new_dn ( & op -> o_req_ndn , & e -> e_nname , & stub , op -> o_tmpmemctx ) ;\n mdb_entry_return ( op , e ) ;\n matched = NULL ;\n goto dn2entry_retry ;\n }\n }\n else if ( e && is_entry_alias ( e ) ) {\n e = deref_base ( op , rs , e , & matched , ltid , candidates , NULL ) ;\n }\n }\n if ( e == NULL ) {\n struct berval matched_dn = BER_BVNULL ;\n if ( matched != NULL ) {\n BerVarray erefs = NULL ;\n if ( ! access_allowed ( op , matched , slap_schema . si_ad_entry , NULL , ACL_DISCLOSE , NULL ) ) {\n rs -> sr_err = LDAP_NO_SUCH_OBJECT ;\n }\n else {\n ber_dupbv ( & matched_dn , & matched -> e_name ) ;\n erefs = is_entry_referral ( matched ) ? get_entry_referrals ( op , matched ) : NULL ;\n if ( rs -> sr_err == MDB_NOTFOUND ) rs -> sr_err = LDAP_REFERRAL ;\n rs -> sr_matched = matched_dn . bv_val ;\n }\n mdb_entry_return ( op , matched ) ;\n matched = NULL ;\n if ( erefs ) {\n rs -> sr_ref = referral_rewrite ( erefs , & matched_dn , & op -> o_req_dn , op -> oq_search . rs_scope ) ;\n ber_bvarray_free ( erefs ) ;\n }\n }\n else {\n rs -> sr_ref = referral_rewrite ( default_referral , NULL , & op -> o_req_dn , op -> oq_search . rs_scope ) ;\n rs -> sr_err = rs -> sr_ref != NULL ? LDAP_REFERRAL : LDAP_NO_SUCH_OBJECT ;\n }\n send_ldap_result ( op , rs ) ;\n if ( rs -> sr_ref ) {\n ber_bvarray_free ( rs -> sr_ref ) ;\n rs -> sr_ref = NULL ;\n }\n if ( ! BER_BVISNULL ( & matched_dn ) ) {\n ber_memfree ( matched_dn . bv_val ) ;\n rs -> sr_matched = NULL ;\n }\n goto done ;\n }\n if ( ! access_allowed_mask ( op , e , slap_schema . si_ad_entry , NULL , ACL_SEARCH , NULL , & mask ) ) {\n if ( ! ACL_GRANT ( mask , ACL_DISCLOSE ) ) {\n rs -> sr_err = LDAP_NO_SUCH_OBJECT ;\n }\n else {\n rs -> sr_err = LDAP_INSUFFICIENT_ACCESS ;\n }\n mdb_entry_return ( op , e ) ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n if ( ! manageDSAit && is_entry_referral ( e ) ) {\n struct berval matched_dn = BER_BVNULL ;\n BerVarray erefs = NULL ;\n ber_dupbv ( & matched_dn , & e -> e_name ) ;\n erefs = get_entry_referrals ( op , e ) ;\n rs -> sr_err = LDAP_REFERRAL ;\n mdb_entry_return ( op , e ) ;\n e = NULL ;\n if ( erefs ) {\n rs -> sr_ref = referral_rewrite ( erefs , & matched_dn , & op -> o_req_dn , op -> oq_search . rs_scope ) ;\n ber_bvarray_free ( erefs ) ;\n if ( ! rs -> sr_ref ) {\n rs -> sr_text = \"bad_referral object\" ;\n }\n }\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": entry is referral\\n\" , 0 , 0 , 0 ) ;\n rs -> sr_matched = matched_dn . bv_val ;\n send_ldap_result ( op , rs ) ;\n ber_bvarray_free ( rs -> sr_ref ) ;\n rs -> sr_ref = NULL ;\n ber_memfree ( matched_dn . bv_val ) ;\n rs -> sr_matched = NULL ;\n goto done ;\n }\n if ( get_assert ( op ) && ( test_filter ( op , e , get_assertion ( op ) ) != LDAP_COMPARE_TRUE ) ) {\n rs -> sr_err = LDAP_ASSERTION_FAILED ;\n mdb_entry_return ( op , e ) ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n stoptime = op -> o_time + op -> ors_tlimit ;\n base = e ;\n e = NULL ;\n if ( op -> oq_search . rs_scope == LDAP_SCOPE_BASE ) {\n rs -> sr_err = base_candidate ( op -> o_bd , base , candidates ) ;\n scopes [ 0 ] . mid = 0 ;\n ncand = 1 ;\n }\n else {\n if ( op -> ors_scope == LDAP_SCOPE_ONELEVEL ) {\n size_t nkids ;\n MDB_val key , data ;\n key . mv_data = & base -> e_id ;\n key . mv_size = sizeof ( ID ) ;\n mdb_cursor_get ( mcd , & key , & data , MDB_SET ) ;\n mdb_cursor_count ( mcd , & nkids ) ;\n nsubs = nkids - 1 ;\n }\n else if ( ! base -> e_id ) {\n MDB_stat ms ;\n mdb_stat ( ltid , mdb -> mi_id2entry , & ms ) ;\n nsubs = ms . ms_entries ;\n }\n MDB_IDL_ZERO ( candidates ) ;\n scopes [ 0 ] . mid = 1 ;\n scopes [ 1 ] . mid = base -> e_id ;\n scopes [ 1 ] . mval . mv_data = NULL ;\n rs -> sr_err = search_candidates ( op , rs , base , & isc , mci , candidates , stack ) ;\n ncand = MDB_IDL_N ( candidates ) ;\n if ( ! base -> e_id || ncand == NOID ) {\n MDB_stat ms ;\n mdb_stat ( ltid , mdb -> mi_id2entry , & ms ) ;\n if ( ! base -> e_id ) nsubs = ms . ms_entries ;\n if ( ncand == NOID ) ncand = ms . ms_entries ;\n }\n }\n cursor = 0 ;\n if ( candidates [ 0 ] == 0 ) {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": no candidates\\n\" , 0 , 0 , 0 ) ;\n goto nochange ;\n }\n if ( op -> ors_limit && op -> ors_limit -> lms_s_unchecked != - 1 && ncand > ( unsigned ) op -> ors_limit -> lms_s_unchecked ) {\n rs -> sr_err = LDAP_ADMINLIMIT_EXCEEDED ;\n send_ldap_result ( op , rs ) ;\n rs -> sr_err = LDAP_SUCCESS ;\n goto done ;\n }\n if ( op -> ors_limit == NULL || ! op -> ors_limit -> lms_s_pr_hide ) {\n tentries = ncand ;\n }\n wwctx . flag = 0 ;\n if ( moi == & opinfo ) {\n cb . sc_writewait = mdb_writewait ;\n cb . sc_private = & wwctx ;\n wwctx . txn = ltid ;\n wwctx . mcd = NULL ;\n cb . sc_next = op -> o_callback ;\n op -> o_callback = & cb ;\n }\n if ( get_pagedresults ( op ) > SLAP_CONTROL_IGNORED ) {\n PagedResultsState * ps = op -> o_pagedresults_state ;\n rs -> sr_err = parse_paged_cookie ( op , rs ) ;\n if ( rs -> sr_err != LDAP_SUCCESS ) {\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n cursor = ( ID ) ps -> ps_cookie ;\n if ( cursor && ps -> ps_size == 0 ) {\n rs -> sr_err = LDAP_SUCCESS ;\n rs -> sr_text = \"search abandoned by pagedResult size=0\" ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n id = mdb_idl_first ( candidates , & cursor ) ;\n if ( id == NOID ) {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": no paged results candidates\\n\" , 0 , 0 , 0 ) ;\n send_paged_response ( op , rs , & lastid , 0 ) ;\n rs -> sr_err = LDAP_OTHER ;\n goto done ;\n }\n if ( id == ( ID ) ps -> ps_cookie ) id = mdb_idl_next ( candidates , & cursor ) ;\n nsubs = ncand ;\n goto loop_begin ;\n }\n if ( nsubs < ncand ) {\n int rc ;\n if ( scopes [ 0 ] . mid > 1 ) {\n cursor = 1 ;\n for ( cscope = 1 ;\n cscope <= scopes [ 0 ] . mid ;\n cscope ++ ) {\n if ( scopes [ cscope ] . mid == base -> e_id ) continue ;\n iscopes [ cursor ++ ] = scopes [ cscope ] . mid ;\n }\n iscopes [ 0 ] = scopes [ 0 ] . mid - 1 ;\n }\n else {\n iscopes [ 0 ] = 0 ;\n }\n wwctx . mcd = mcd ;\n isc . id = base -> e_id ;\n isc . numrdns = 0 ;\n rc = mdb_dn2id_walk ( op , & isc ) ;\n if ( rc ) id = NOID ;\n else id = isc . id ;\n cscope = 0 ;\n }\n else {\n id = mdb_idl_first ( candidates , & cursor ) ;\n }\n while ( id != NOID ) {\n int scopeok ;\n MDB_val edata ;\n loop_begin : if ( op -> o_abandon ) {\n rs -> sr_err = SLAPD_ABANDON ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n if ( slapd_shutdown ) {\n rs -> sr_err = LDAP_UNAVAILABLE ;\n send_ldap_disconnect ( op , rs ) ;\n goto done ;\n }\n if ( op -> ors_tlimit != SLAP_NO_LIMIT && slap_get_time ( ) > stoptime ) {\n rs -> sr_err = LDAP_TIMELIMIT_EXCEEDED ;\n rs -> sr_ref = rs -> sr_v2ref ;\n send_ldap_result ( op , rs ) ;\n rs -> sr_err = LDAP_SUCCESS ;\n goto done ;\n }\n if ( nsubs < ncand ) {\n unsigned i ;\n scopeok = 0 ;\n if ( MDB_IDL_IS_RANGE ( candidates ) ) {\n if ( id >= MDB_IDL_RANGE_FIRST ( candidates ) && id <= MDB_IDL_RANGE_LAST ( candidates ) ) scopeok = 1 ;\n }\n else {\n i = mdb_idl_search ( candidates , id ) ;\n if ( i <= candidates [ 0 ] && candidates [ i ] == id ) scopeok = 1 ;\n }\n if ( scopeok ) goto scopeok ;\n goto loop_continue ;\n }\n scopeok = 0 ;\n isc . numrdns = 0 ;\n switch ( op -> ors_scope ) {\n case LDAP_SCOPE_BASE : if ( id == base -> e_id ) scopeok = 1 ;\n break ;\n # ifdef LDAP_SCOPE_CHILDREN case LDAP_SCOPE_CHILDREN : if ( id == base -> e_id ) break ;\n # endif case LDAP_SCOPE_SUBTREE : if ( id == base -> e_id ) {\n scopeok = 1 ;\n break ;\n }\n case LDAP_SCOPE_ONELEVEL : if ( id == base -> e_id ) break ;\n isc . id = id ;\n isc . nscope = 0 ;\n rs -> sr_err = mdb_idscopes ( op , & isc ) ;\n if ( rs -> sr_err == MDB_SUCCESS ) {\n if ( isc . nscope ) scopeok = 1 ;\n }\n else {\n if ( rs -> sr_err == MDB_NOTFOUND ) goto notfound ;\n }\n break ;\n }\n if ( ! scopeok ) {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": %ld scope not okay\\n\" , ( long ) id , 0 , 0 ) ;\n goto loop_continue ;\n }\n scopeok : if ( id == base -> e_id ) {\n e = base ;\n }\n else {\n rs -> sr_err = mdb_id2edata ( op , mci , id , & edata ) ;\n if ( rs -> sr_err == MDB_NOTFOUND ) {\n notfound : if ( nsubs < ncand ) goto loop_continue ;\n if ( ! MDB_IDL_IS_RANGE ( candidates ) ) {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": candidate %ld not found\\n\" , ( long ) id , 0 , 0 ) ;\n }\n else {\n rs -> sr_err = mdb_get_nextid ( mci , & cursor ) ;\n if ( rs -> sr_err == MDB_NOTFOUND ) {\n break ;\n }\n if ( rs -> sr_err ) {\n rs -> sr_err = LDAP_OTHER ;\n rs -> sr_text = \"internal error in get_nextid\" ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n cursor -- ;\n }\n goto loop_continue ;\n }\n else if ( rs -> sr_err ) {\n rs -> sr_err = LDAP_OTHER ;\n rs -> sr_text = \"internal error in mdb_id2edata\" ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n rs -> sr_err = mdb_entry_decode ( op , ltid , & edata , id , & e ) ;\n if ( rs -> sr_err ) {\n rs -> sr_err = LDAP_OTHER ;\n rs -> sr_text = \"internal error in mdb_entry_decode\" ;\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n e -> e_id = id ;\n e -> e_name . bv_val = NULL ;\n e -> e_nname . bv_val = NULL ;\n }\n if ( is_entry_subentry ( e ) ) {\n if ( op -> oq_search . rs_scope != LDAP_SCOPE_BASE ) {\n if ( ! get_subentries_visibility ( op ) ) {\n goto loop_continue ;\n }\n }\n else if ( get_subentries ( op ) && ! get_subentries_visibility ( op ) ) {\n goto loop_continue ;\n }\n }\n else if ( get_subentries_visibility ( op ) ) {\n goto loop_continue ;\n }\n if ( op -> ors_deref & LDAP_DEREF_SEARCHING ) {\n if ( is_entry_alias ( e ) && ( ( op -> ors_deref & LDAP_DEREF_FINDING ) || e != base ) ) {\n goto loop_continue ;\n }\n }\n if ( ! manageDSAit && is_entry_glue ( e ) ) {\n goto loop_continue ;\n }\n if ( e != base ) {\n struct berval pdn , pndn ;\n char * d , * n ;\n int i ;\n if ( nsubs < ncand || isc . scopes [ isc . nscope ] . mid == base -> e_id ) {\n pdn = base -> e_name ;\n pndn = base -> e_nname ;\n }\n else {\n mdb_id2name ( op , ltid , & isc . mc , scopes [ isc . nscope ] . mid , & pdn , & pndn ) ;\n }\n e -> e_name . bv_len = pdn . bv_len ;\n e -> e_nname . bv_len = pndn . bv_len ;\n for ( i = 0 ;\n i < isc . numrdns ;\n i ++ ) {\n e -> e_name . bv_len += isc . rdns [ i ] . bv_len + 1 ;\n e -> e_nname . bv_len += isc . nrdns [ i ] . bv_len + 1 ;\n }\n e -> e_name . bv_val = op -> o_tmpalloc ( e -> e_name . bv_len + 1 , op -> o_tmpmemctx ) ;\n e -> e_nname . bv_val = op -> o_tmpalloc ( e -> e_nname . bv_len + 1 , op -> o_tmpmemctx ) ;\n d = e -> e_name . bv_val ;\n n = e -> e_nname . bv_val ;\n if ( nsubs < ncand ) {\n for ( i = isc . numrdns - 1 ;\n i >= 0 ;\n i -- ) {\n memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n d += isc . rdns [ i ] . bv_len ;\n * d ++ = ',' ;\n memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n n += isc . nrdns [ i ] . bv_len ;\n * n ++ = ',' ;\n }\n }\n else {\n for ( i = 0 ;\n i < isc . numrdns ;\n i ++ ) {\n memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n d += isc . rdns [ i ] . bv_len ;\n * d ++ = ',' ;\n memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n n += isc . nrdns [ i ] . bv_len ;\n * n ++ = ',' ;\n }\n }\n if ( pdn . bv_len ) {\n memcpy ( d , pdn . bv_val , pdn . bv_len + 1 ) ;\n memcpy ( n , pndn . bv_val , pndn . bv_len + 1 ) ;\n }\n else {\n * -- d = '\\0' ;\n * -- n = '\\0' ;\n e -> e_name . bv_len -- ;\n e -> e_nname . bv_len -- ;\n }\n if ( pndn . bv_val != base -> e_nname . bv_val ) {\n op -> o_tmpfree ( pndn . bv_val , op -> o_tmpmemctx ) ;\n op -> o_tmpfree ( pdn . bv_val , op -> o_tmpmemctx ) ;\n }\n }\n if ( ! manageDSAit && op -> oq_search . rs_scope != LDAP_SCOPE_BASE && is_entry_referral ( e ) ) {\n BerVarray erefs = get_entry_referrals ( op , e ) ;\n rs -> sr_ref = referral_rewrite ( erefs , & e -> e_name , NULL , op -> oq_search . rs_scope == LDAP_SCOPE_ONELEVEL ? LDAP_SCOPE_BASE : LDAP_SCOPE_SUBTREE ) ;\n rs -> sr_entry = e ;\n rs -> sr_flags = 0 ;\n send_search_reference ( op , rs ) ;\n if ( e != base ) mdb_entry_return ( op , e ) ;\n rs -> sr_entry = NULL ;\n e = NULL ;\n ber_bvarray_free ( rs -> sr_ref ) ;\n ber_bvarray_free ( erefs ) ;\n rs -> sr_ref = NULL ;\n goto loop_continue ;\n }\n rs -> sr_err = test_filter ( op , e , op -> oq_search . rs_filter ) ;\n if ( rs -> sr_err == LDAP_COMPARE_TRUE ) {\n if ( get_pagedresults ( op ) > SLAP_CONTROL_IGNORED ) {\n if ( rs -> sr_nentries >= ( ( PagedResultsState * ) op -> o_pagedresults_state ) -> ps_size ) {\n mdb_entry_return ( op , e ) ;\n e = NULL ;\n send_paged_response ( op , rs , & lastid , tentries ) ;\n goto done ;\n }\n lastid = id ;\n }\n if ( e ) {\n rs -> sr_attrs = op -> oq_search . rs_attrs ;\n rs -> sr_operational_attrs = NULL ;\n rs -> sr_ctrls = NULL ;\n rs -> sr_entry = e ;\n RS_ASSERT ( e -> e_private != NULL ) ;\n rs -> sr_flags = 0 ;\n rs -> sr_err = LDAP_SUCCESS ;\n rs -> sr_err = send_search_entry ( op , rs ) ;\n rs -> sr_attrs = NULL ;\n rs -> sr_entry = NULL ;\n if ( e != base ) mdb_entry_return ( op , e ) ;\n e = NULL ;\n switch ( rs -> sr_err ) {\n case LDAP_SUCCESS : break ;\n default : break ;\n case LDAP_BUSY : send_ldap_result ( op , rs ) ;\n goto done ;\n case LDAP_UNAVAILABLE : case LDAP_SIZELIMIT_EXCEEDED : if ( rs -> sr_err == LDAP_SIZELIMIT_EXCEEDED ) {\n rs -> sr_ref = rs -> sr_v2ref ;\n send_ldap_result ( op , rs ) ;\n rs -> sr_err = LDAP_SUCCESS ;\n }\n else {\n rs -> sr_err = LDAP_OTHER ;\n }\n goto done ;\n }\n }\n }\n else {\n Debug ( LDAP_DEBUG_TRACE , LDAP_XSTRING ( mdb_search ) \": %ld does not match filter\\n\" , ( long ) id , 0 , 0 ) ;\n }\n loop_continue : if ( moi == & opinfo && ! wwctx . flag && mdb -> mi_rtxn_size ) {\n wwctx . nentries ++ ;\n if ( wwctx . nentries >= mdb -> mi_rtxn_size ) {\n wwctx . nentries = 0 ;\n mdb_rtxn_snap ( op , & wwctx ) ;\n }\n }\n if ( wwctx . flag ) {\n rs -> sr_err = mdb_waitfixup ( op , & wwctx , mci , mcd , & isc ) ;\n if ( rs -> sr_err ) {\n send_ldap_result ( op , rs ) ;\n goto done ;\n }\n }\n if ( e != NULL ) {\n if ( e != base ) mdb_entry_return ( op , e ) ;\n RS_ASSERT ( rs -> sr_entry == NULL ) ;\n e = NULL ;\n rs -> sr_entry = NULL ;\n }\n if ( nsubs < ncand ) {\n int rc = mdb_dn2id_walk ( op , & isc ) ;\n if ( rc ) {\n id = NOID ;\n while ( iscopes [ 0 ] && cscope < iscopes [ 0 ] ) {\n cscope ++ ;\n isc . id = iscopes [ cscope ] ;\n if ( base ) mdb_entry_return ( op , base ) ;\n rs -> sr_err = mdb_id2entry ( op , mci , isc . id , & base ) ;\n if ( ! rs -> sr_err ) {\n mdb_id2name ( op , ltid , & isc . mc , isc . id , & base -> e_name , & base -> e_nname ) ;\n isc . numrdns = 0 ;\n if ( isc . oscope == LDAP_SCOPE_ONELEVEL ) isc . oscope = LDAP_SCOPE_BASE ;\n rc = mdb_dn2id_walk ( op , & isc ) ;\n if ( ! rc ) {\n id = isc . id ;\n break ;\n }\n }\n }\n }\n else id = isc . id ;\n }\n else {\n id = mdb_idl_next ( candidates , & cursor ) ;\n }\n }\n nochange : rs -> sr_ctrls = NULL ;\n rs -> sr_ref = rs -> sr_v2ref ;\n rs -> sr_err = ( rs -> sr_v2ref == NULL ) ? LDAP_SUCCESS : LDAP_REFERRAL ;\n rs -> sr_rspoid = NULL ;\n if ( get_pagedresults ( op ) > SLAP_CONTROL_IGNORED ) {\n send_paged_response ( op , rs , NULL , 0 ) ;\n }\n else {\n send_ldap_result ( op , rs ) ;\n }\n rs -> sr_err = LDAP_SUCCESS ;\n done : if ( cb . sc_private ) {\n slap_callback * * scp = & op -> o_callback ;\n while ( * scp ) {\n if ( * scp == & cb ) {\n * scp = cb . sc_next ;\n cb . sc_private = NULL ;\n break ;\n }\n }\n }\n mdb_cursor_close ( mcd ) ;\n mdb_cursor_close ( mci ) ;\n if ( moi == & opinfo ) {\n mdb_txn_reset ( moi -> moi_txn ) ;\n LDAP_SLIST_REMOVE ( & op -> o_extra , & moi -> moi_oe , OpExtra , oe_next ) ;\n }\n else {\n moi -> moi_ref -- ;\n }\n if ( rs -> sr_v2ref ) {\n ber_bvarray_free ( rs -> sr_v2ref ) ;\n rs -> sr_v2ref = NULL ;\n }\n if ( base ) mdb_entry_return ( op , base ) ;\n scope_chunk_ret ( op , scopes ) ;\n return rs -> sr_err ;\n }",
        "hash": 7295169435648525618,
        "project": "debian",
        "size": 601,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int mdb_search ( Operation * op , SlapReply * rs ) {\n"
                ],
                [
                    402,
                    " pdn = base -> e_name ;\n"
                ],
                [
                    403,
                    " pndn = base -> e_nname ;\n"
                ],
                [
                    418,
                    " d = e -> e_name . bv_val ;\n"
                ],
                [
                    419,
                    " n = e -> e_nname . bv_val ;\n"
                ],
                [
                    422,
                    " i >= 0 ;\n"
                ],
                [
                    424,
                    " memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n"
                ],
                [
                    425,
                    " d += isc . rdns [ i ] . bv_len ;\n"
                ],
                [
                    426,
                    " * d ++ = ',' ;\n"
                ],
                [
                    427,
                    " memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n"
                ],
                [
                    428,
                    " n += isc . nrdns [ i ] . bv_len ;\n"
                ],
                [
                    429,
                    " * n ++ = ',' ;\n"
                ],
                [
                    434,
                    " i < isc . numrdns ;\n"
                ],
                [
                    436,
                    " memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n"
                ],
                [
                    437,
                    " d += isc . rdns [ i ] . bv_len ;\n"
                ],
                [
                    438,
                    " * d ++ = ',' ;\n"
                ],
                [
                    439,
                    " memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n"
                ],
                [
                    440,
                    " n += isc . nrdns [ i ] . bv_len ;\n"
                ],
                [
                    441,
                    " * n ++ = ',' ;\n"
                ],
                [
                    444,
                    " if ( pdn . bv_len ) {\n"
                ],
                [
                    445,
                    " memcpy ( d , pdn . bv_val , pdn . bv_len + 1 ) ;\n"
                ],
                [
                    446,
                    " memcpy ( n , pndn . bv_val , pndn . bv_len + 1 ) ;\n"
                ],
                [
                    454,
                    " if ( pndn . bv_val != base -> e_nname . bv_val ) {\n"
                ],
                [
                    456,
                    " op -> o_tmpfree ( pdn . bv_val , op -> o_tmpmemctx ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int mdb_search ( Operation * op , SlapReply * rs ) {\n"
                ],
                [
                    402,
                    " pdn = base -> e_name ;\n"
                ],
                [
                    403,
                    " pndn = base -> e_nname ;\n"
                ],
                [
                    418,
                    " d = e -> e_name . bv_val ;\n"
                ],
                [
                    419,
                    " n = e -> e_nname . bv_val ;\n"
                ],
                [
                    422,
                    " i >= 0 ;\n"
                ],
                [
                    424,
                    " memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n"
                ],
                [
                    425,
                    " d += isc . rdns [ i ] . bv_len ;\n"
                ],
                [
                    426,
                    " * d ++ = ',' ;\n"
                ],
                [
                    427,
                    " memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n"
                ],
                [
                    428,
                    " n += isc . nrdns [ i ] . bv_len ;\n"
                ],
                [
                    429,
                    " * n ++ = ',' ;\n"
                ],
                [
                    434,
                    " i < isc . numrdns ;\n"
                ],
                [
                    436,
                    " memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n"
                ],
                [
                    437,
                    " d += isc . rdns [ i ] . bv_len ;\n"
                ],
                [
                    438,
                    " * d ++ = ',' ;\n"
                ],
                [
                    439,
                    " memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n"
                ],
                [
                    440,
                    " n += isc . nrdns [ i ] . bv_len ;\n"
                ],
                [
                    441,
                    " * n ++ = ',' ;\n"
                ],
                [
                    444,
                    " if ( pdn . bv_len ) {\n"
                ],
                [
                    445,
                    " memcpy ( d , pdn . bv_val , pdn . bv_len + 1 ) ;\n"
                ],
                [
                    446,
                    " memcpy ( n , pndn . bv_val , pndn . bv_len + 1 ) ;\n"
                ],
                [
                    454,
                    " if ( pndn . bv_val != base -> e_nname . bv_val ) {\n"
                ],
                [
                    456,
                    " op -> o_tmpfree ( pdn . bv_val , op -> o_tmpmemctx ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int selinux_setprocattr ( struct task_struct * p , char * name , void * value , size_t size ) {\n struct task_security_struct * tsec ;\n struct cred * new ;\n u32 sid = 0 , ptsid ;\n int error ;\n char * str = value ;\n if ( current != p ) {\n return - EACCES ;\n }\n if ( ! strcmp ( name , \"exec\" ) ) error = current_has_perm ( p , PROCESS__SETEXEC ) ;\n else if ( ! strcmp ( name , \"fscreate\" ) ) error = current_has_perm ( p , PROCESS__SETFSCREATE ) ;\n else if ( ! strcmp ( name , \"keycreate\" ) ) error = current_has_perm ( p , PROCESS__SETKEYCREATE ) ;\n else if ( ! strcmp ( name , \"sockcreate\" ) ) error = current_has_perm ( p , PROCESS__SETSOCKCREATE ) ;\n else if ( ! strcmp ( name , \"current\" ) ) error = current_has_perm ( p , PROCESS__SETCURRENT ) ;\n else error = - EINVAL ;\n if ( error ) return error ;\n if ( size && str [ 1 ] && str [ 1 ] != '\\n' ) {\n if ( str [ size - 1 ] == '\\n' ) {\n str [ size - 1 ] = 0 ;\n size -- ;\n }\n error = security_context_to_sid ( value , size , & sid , GFP_KERNEL ) ;\n if ( error == - EINVAL && ! strcmp ( name , \"fscreate\" ) ) {\n if ( ! capable ( CAP_MAC_ADMIN ) ) {\n struct audit_buffer * ab ;\n size_t audit_size ;\n if ( str [ size - 1 ] == '\\0' ) audit_size = size - 1 ;\n else audit_size = size ;\n ab = audit_log_start ( current -> audit_context , GFP_ATOMIC , AUDIT_SELINUX_ERR ) ;\n audit_log_format ( ab , \"op=fscreate invalid_context=\" ) ;\n audit_log_n_untrustedstring ( ab , value , audit_size ) ;\n audit_log_end ( ab ) ;\n return error ;\n }\n error = security_context_to_sid_force ( value , size , & sid ) ;\n }\n if ( error ) return error ;\n }\n new = prepare_creds ( ) ;\n if ( ! new ) return - ENOMEM ;\n tsec = new -> security ;\n if ( ! strcmp ( name , \"exec\" ) ) {\n tsec -> exec_sid = sid ;\n }\n else if ( ! strcmp ( name , \"fscreate\" ) ) {\n tsec -> create_sid = sid ;\n }\n else if ( ! strcmp ( name , \"keycreate\" ) ) {\n error = may_create_key ( sid , p ) ;\n if ( error ) goto abort_change ;\n tsec -> keycreate_sid = sid ;\n }\n else if ( ! strcmp ( name , \"sockcreate\" ) ) {\n tsec -> sockcreate_sid = sid ;\n }\n else if ( ! strcmp ( name , \"current\" ) ) {\n error = - EINVAL ;\n if ( sid == 0 ) goto abort_change ;\n error = - EPERM ;\n if ( ! current_is_single_threaded ( ) ) {\n error = security_bounded_transition ( tsec -> sid , sid ) ;\n if ( error ) goto abort_change ;\n }\n error = avc_has_perm ( tsec -> sid , sid , SECCLASS_PROCESS , PROCESS__DYNTRANSITION , NULL ) ;\n if ( error ) goto abort_change ;\n ptsid = ptrace_parent_sid ( p ) ;\n if ( ptsid != 0 ) {\n error = avc_has_perm ( ptsid , sid , SECCLASS_PROCESS , PROCESS__PTRACE , NULL ) ;\n if ( error ) goto abort_change ;\n }\n tsec -> sid = sid ;\n }\n else {\n error = - EINVAL ;\n goto abort_change ;\n }\n commit_creds ( new ) ;\n return size ;\n abort_change : abort_creds ( new ) ;\n return error ;\n }",
        "hash": 4180964683905830761,
        "project": "debian",
        "size": 81,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int selinux_setprocattr ( struct task_struct * p , char * name , void * value , size_t size ) {\n"
                ],
                [
                    7,
                    " if ( current != p ) {\n"
                ],
                [
                    10,
                    " if ( ! strcmp ( name , \"exec\" ) ) error = current_has_perm ( p , PROCESS__SETEXEC ) ;\n"
                ],
                [
                    11,
                    " else if ( ! strcmp ( name , \"fscreate\" ) ) error = current_has_perm ( p , PROCESS__SETFSCREATE ) ;\n"
                ],
                [
                    12,
                    " else if ( ! strcmp ( name , \"keycreate\" ) ) error = current_has_perm ( p , PROCESS__SETKEYCREATE ) ;\n"
                ],
                [
                    13,
                    " else if ( ! strcmp ( name , \"sockcreate\" ) ) error = current_has_perm ( p , PROCESS__SETSOCKCREATE ) ;\n"
                ],
                [
                    14,
                    " else if ( ! strcmp ( name , \"current\" ) ) error = current_has_perm ( p , PROCESS__SETCURRENT ) ;\n"
                ],
                [
                    15,
                    " else error = - EINVAL ;\n"
                ],
                [
                    17,
                    " if ( size && str [ 1 ] && str [ 1 ] != '\\n' ) {\n"
                ],
                [
                    23,
                    " if ( error == - EINVAL && ! strcmp ( name , \"fscreate\" ) ) {\n"
                ],
                [
                    24,
                    " if ( ! capable ( CAP_MAC_ADMIN ) ) {\n"
                ],
                [
                    37,
                    " if ( error ) return error ;\n"
                ],
                [
                    40,
                    " if ( ! new ) return - ENOMEM ;\n"
                ],
                [
                    42,
                    " if ( ! strcmp ( name , \"exec\" ) ) {\n"
                ],
                [
                    43,
                    " tsec -> exec_sid = sid ;\n"
                ],
                [
                    45,
                    " else if ( ! strcmp ( name , \"fscreate\" ) ) {\n"
                ],
                [
                    46,
                    " tsec -> create_sid = sid ;\n"
                ],
                [
                    48,
                    " else if ( ! strcmp ( name , \"keycreate\" ) ) {\n"
                ],
                [
                    49,
                    " error = may_create_key ( sid , p ) ;\n"
                ],
                [
                    50,
                    " if ( error ) goto abort_change ;\n"
                ],
                [
                    53,
                    " else if ( ! strcmp ( name , \"sockcreate\" ) ) {\n"
                ],
                [
                    54,
                    " tsec -> sockcreate_sid = sid ;\n"
                ],
                [
                    56,
                    " else if ( ! strcmp ( name , \"current\" ) ) {\n"
                ],
                [
                    57,
                    " error = - EINVAL ;\n"
                ],
                [
                    58,
                    " if ( sid == 0 ) goto abort_change ;\n"
                ],
                [
                    74,
                    " error = - EINVAL ;\n"
                ],
                [
                    77,
                    " commit_creds ( new ) ;\n"
                ],
                [
                    78,
                    " return size ;\n"
                ],
                [
                    79,
                    " abort_change : abort_creds ( new ) ;\n"
                ],
                [
                    80,
                    " return error ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int selinux_setprocattr ( struct task_struct * p , char * name , void * value , size_t size ) {\n"
                ],
                [
                    7,
                    " if ( current != p ) {\n"
                ],
                [
                    10,
                    " if ( ! strcmp ( name , \"exec\" ) ) error = current_has_perm ( p , PROCESS__SETEXEC ) ;\n"
                ],
                [
                    11,
                    " else if ( ! strcmp ( name , \"fscreate\" ) ) error = current_has_perm ( p , PROCESS__SETFSCREATE ) ;\n"
                ],
                [
                    12,
                    " else if ( ! strcmp ( name , \"keycreate\" ) ) error = current_has_perm ( p , PROCESS__SETKEYCREATE ) ;\n"
                ],
                [
                    13,
                    " else if ( ! strcmp ( name , \"sockcreate\" ) ) error = current_has_perm ( p , PROCESS__SETSOCKCREATE ) ;\n"
                ],
                [
                    14,
                    " else if ( ! strcmp ( name , \"current\" ) ) error = current_has_perm ( p , PROCESS__SETCURRENT ) ;\n"
                ],
                [
                    15,
                    " else error = - EINVAL ;\n"
                ],
                [
                    17,
                    " if ( size && str [ 1 ] && str [ 1 ] != '\\n' ) {\n"
                ],
                [
                    23,
                    " if ( error == - EINVAL && ! strcmp ( name , \"fscreate\" ) ) {\n"
                ],
                [
                    24,
                    " if ( ! capable ( CAP_MAC_ADMIN ) ) {\n"
                ],
                [
                    37,
                    " if ( error ) return error ;\n"
                ],
                [
                    40,
                    " if ( ! new ) return - ENOMEM ;\n"
                ],
                [
                    42,
                    " if ( ! strcmp ( name , \"exec\" ) ) {\n"
                ],
                [
                    43,
                    " tsec -> exec_sid = sid ;\n"
                ],
                [
                    45,
                    " else if ( ! strcmp ( name , \"fscreate\" ) ) {\n"
                ],
                [
                    46,
                    " tsec -> create_sid = sid ;\n"
                ],
                [
                    48,
                    " else if ( ! strcmp ( name , \"keycreate\" ) ) {\n"
                ],
                [
                    49,
                    " error = may_create_key ( sid , p ) ;\n"
                ],
                [
                    50,
                    " if ( error ) goto abort_change ;\n"
                ],
                [
                    53,
                    " else if ( ! strcmp ( name , \"sockcreate\" ) ) {\n"
                ],
                [
                    54,
                    " tsec -> sockcreate_sid = sid ;\n"
                ],
                [
                    56,
                    " else if ( ! strcmp ( name , \"current\" ) ) {\n"
                ],
                [
                    57,
                    " error = - EINVAL ;\n"
                ],
                [
                    58,
                    " if ( sid == 0 ) goto abort_change ;\n"
                ],
                [
                    74,
                    " error = - EINVAL ;\n"
                ],
                [
                    77,
                    " commit_creds ( new ) ;\n"
                ],
                [
                    78,
                    " return size ;\n"
                ],
                [
                    79,
                    " abort_change : abort_creds ( new ) ;\n"
                ],
                [
                    80,
                    " return error ;\n"
                ]
            ]
        }
    },
    {
        "code": "char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n int length ;\n length = strlen ( filename ) ;\n if ( length > 0 ) {\n if ( ( filename [ 0 ] == '\\\"' ) && ( filename [ length - 1 ] == '\\\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n }\n return strdup ( filename ) ;\n }",
        "hash": 2518148041181868265,
        "project": "debian",
        "size": 8,
        "slice": {
            "strlen": [
                [
                    1,
                    "char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n"
                ],
                [
                    3,
                    " length = strlen ( filename ) ;\n"
                ],
                [
                    4,
                    " if ( length > 0 ) {\n"
                ],
                [
                    5,
                    " if ( ( filename [ 0 ] == '\\\"' ) && ( filename [ length - 1 ] == '\\\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n"
                ],
                [
                    7,
                    " return strdup ( filename ) ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n"
                ],
                [
                    3,
                    " length = strlen ( filename ) ;\n"
                ],
                [
                    4,
                    " if ( length > 0 ) {\n"
                ],
                [
                    5,
                    " if ( ( filename [ 0 ] == '\\\"' ) && ( filename [ length - 1 ] == '\\\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n"
                ],
                [
                    7,
                    " return strdup ( filename ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n"
                ],
                [
                    3,
                    " length = strlen ( filename ) ;\n"
                ],
                [
                    4,
                    " if ( length > 0 ) {\n"
                ],
                [
                    5,
                    " if ( ( filename [ 0 ] == '\\\"' ) && ( filename [ length - 1 ] == '\\\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n"
                ],
                [
                    7,
                    " return strdup ( filename ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void init_directory_config ( directory_config * dcfg ) {\n if ( dcfg == NULL ) return ;\n if ( dcfg -> is_enabled == NOT_SET ) dcfg -> is_enabled = 0 ;\n if ( dcfg -> reqbody_access == NOT_SET ) dcfg -> reqbody_access = 0 ;\n if ( dcfg -> reqintercept_oe == NOT_SET ) dcfg -> reqintercept_oe = 0 ;\n if ( dcfg -> reqbody_buffering == NOT_SET ) dcfg -> reqbody_buffering = REQUEST_BODY_FORCEBUF_OFF ;\n if ( dcfg -> reqbody_inmemory_limit == NOT_SET ) dcfg -> reqbody_inmemory_limit = REQUEST_BODY_DEFAULT_INMEMORY_LIMIT ;\n if ( dcfg -> reqbody_limit == NOT_SET ) dcfg -> reqbody_limit = REQUEST_BODY_DEFAULT_LIMIT ;\n if ( dcfg -> reqbody_no_files_limit == NOT_SET ) dcfg -> reqbody_no_files_limit = REQUEST_BODY_NO_FILES_DEFAULT_LIMIT ;\n if ( dcfg -> resbody_access == NOT_SET ) dcfg -> resbody_access = 0 ;\n if ( dcfg -> of_limit == NOT_SET ) dcfg -> of_limit = RESPONSE_BODY_DEFAULT_LIMIT ;\n if ( dcfg -> if_limit_action == NOT_SET ) dcfg -> if_limit_action = REQUEST_BODY_LIMIT_ACTION_REJECT ;\n if ( dcfg -> of_limit_action == NOT_SET ) dcfg -> of_limit_action = RESPONSE_BODY_LIMIT_ACTION_REJECT ;\n if ( dcfg -> of_mime_types == NOT_SET_P ) {\n dcfg -> of_mime_types = apr_table_make ( dcfg -> mp , 3 ) ;\n if ( dcfg -> of_mime_types_cleared != 1 ) {\n apr_table_setn ( dcfg -> of_mime_types , \"text/plain\" , \"1\" ) ;\n apr_table_setn ( dcfg -> of_mime_types , \"text/html\" , \"1\" ) ;\n }\n }\n if ( dcfg -> debuglog_fd == NOT_SET_P ) dcfg -> debuglog_fd = NULL ;\n if ( dcfg -> debuglog_name == NOT_SET_P ) dcfg -> debuglog_name = NULL ;\n if ( dcfg -> debuglog_level == NOT_SET ) dcfg -> debuglog_level = 0 ;\n if ( dcfg -> cookie_format == NOT_SET ) dcfg -> cookie_format = 0 ;\n if ( dcfg -> argument_separator == NOT_SET ) dcfg -> argument_separator = '&' ;\n if ( dcfg -> cookiev0_separator == NOT_SET_P ) dcfg -> cookiev0_separator = NULL ;\n if ( dcfg -> rule_inheritance == NOT_SET ) dcfg -> rule_inheritance = 1 ;\n if ( dcfg -> auditlog_flag == NOT_SET ) dcfg -> auditlog_flag = 0 ;\n if ( dcfg -> auditlog_type == NOT_SET ) dcfg -> auditlog_type = AUDITLOG_SERIAL ;\n if ( dcfg -> max_rule_time == NOT_SET ) dcfg -> max_rule_time = 0 ;\n if ( dcfg -> auditlog_dirperms == NOT_SET ) dcfg -> auditlog_dirperms = CREATEMODE_DIR ;\n if ( dcfg -> auditlog_fileperms == NOT_SET ) dcfg -> auditlog_fileperms = CREATEMODE ;\n if ( dcfg -> auditlog_fd == NOT_SET_P ) dcfg -> auditlog_fd = NULL ;\n if ( dcfg -> auditlog2_fd == NOT_SET_P ) dcfg -> auditlog2_fd = NULL ;\n if ( dcfg -> auditlog_name == NOT_SET_P ) dcfg -> auditlog_name = NULL ;\n if ( dcfg -> auditlog2_name == NOT_SET_P ) dcfg -> auditlog2_name = NULL ;\n if ( dcfg -> auditlog_storage_dir == NOT_SET_P ) dcfg -> auditlog_storage_dir = NULL ;\n if ( dcfg -> auditlog_parts == NOT_SET_P ) dcfg -> auditlog_parts = \"ABCFHZ\" ;\n if ( dcfg -> auditlog_relevant_regex == NOT_SET_P ) dcfg -> auditlog_relevant_regex = NULL ;\n if ( dcfg -> tmp_dir == NOT_SET_P ) dcfg -> tmp_dir = guess_tmp_dir ( dcfg -> mp ) ;\n if ( dcfg -> upload_dir == NOT_SET_P ) dcfg -> upload_dir = NULL ;\n if ( dcfg -> upload_keep_files == NOT_SET ) dcfg -> upload_keep_files = KEEP_FILES_OFF ;\n if ( dcfg -> upload_validates_files == NOT_SET ) dcfg -> upload_validates_files = 0 ;\n if ( dcfg -> upload_filemode == NOT_SET ) dcfg -> upload_filemode = 0600 ;\n if ( dcfg -> upload_file_limit == NOT_SET ) dcfg -> upload_file_limit = 100 ;\n if ( dcfg -> data_dir == NOT_SET_P ) dcfg -> data_dir = NULL ;\n if ( dcfg -> webappid == NOT_SET_P ) dcfg -> webappid = \"default\" ;\n if ( dcfg -> sensor_id == NOT_SET_P ) dcfg -> sensor_id = \"default\" ;\n if ( dcfg -> httpBlkey == NOT_SET_P ) dcfg -> httpBlkey = NULL ;\n if ( dcfg -> content_injection_enabled == NOT_SET ) dcfg -> content_injection_enabled = 0 ;\n if ( dcfg -> stream_inbody_inspection == NOT_SET ) dcfg -> stream_inbody_inspection = 0 ;\n if ( dcfg -> stream_outbody_inspection == NOT_SET ) dcfg -> stream_outbody_inspection = 0 ;\n if ( dcfg -> geo == NOT_SET_P ) dcfg -> geo = NULL ;\n if ( dcfg -> gsb == NOT_SET_P ) dcfg -> gsb = NULL ;\n if ( dcfg -> u_map == NOT_SET_P ) dcfg -> u_map = NULL ;\n if ( dcfg -> cache_trans == NOT_SET ) dcfg -> cache_trans = MODSEC_CACHE_DISABLED ;\n if ( dcfg -> cache_trans_incremental == NOT_SET ) dcfg -> cache_trans_incremental = 0 ;\n if ( dcfg -> cache_trans_min == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_min = 32 ;\n if ( dcfg -> cache_trans_max == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_max = 1024 ;\n if ( dcfg -> cache_trans_maxitems == ( apr_size_t ) NOT_SET ) dcfg -> cache_trans_maxitems = 512 ;\n if ( dcfg -> request_encoding == NOT_SET_P ) dcfg -> request_encoding = NULL ;\n if ( dcfg -> disable_backend_compression == NOT_SET ) dcfg -> disable_backend_compression = 0 ;\n if ( dcfg -> col_timeout == NOT_SET ) dcfg -> col_timeout = 3600 ;\n if ( dcfg -> crypto_key == NOT_SET_P ) dcfg -> crypto_key = getkey ( dcfg -> mp ) ;\n if ( dcfg -> crypto_key_len == NOT_SET ) dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ;\n if ( dcfg -> crypto_key_add == NOT_SET ) dcfg -> crypto_key_add = HASH_KEYONLY ;\n if ( dcfg -> crypto_param_name == NOT_SET_P ) dcfg -> crypto_param_name = \"crypt\" ;\n if ( dcfg -> hash_is_enabled == NOT_SET ) dcfg -> hash_is_enabled = HASH_DISABLED ;\n if ( dcfg -> hash_enforcement == NOT_SET ) dcfg -> hash_enforcement = HASH_DISABLED ;\n if ( dcfg -> crypto_hash_href_rx == NOT_SET ) dcfg -> crypto_hash_href_rx = 0 ;\n if ( dcfg -> crypto_hash_faction_rx == NOT_SET ) dcfg -> crypto_hash_faction_rx = 0 ;\n if ( dcfg -> crypto_hash_location_rx == NOT_SET ) dcfg -> crypto_hash_location_rx = 0 ;\n if ( dcfg -> crypto_hash_iframesrc_rx == NOT_SET ) dcfg -> crypto_hash_iframesrc_rx = 0 ;\n if ( dcfg -> crypto_hash_framesrc_rx == NOT_SET ) dcfg -> crypto_hash_framesrc_rx = 0 ;\n if ( dcfg -> crypto_hash_href_pm == NOT_SET ) dcfg -> crypto_hash_href_pm = 0 ;\n if ( dcfg -> crypto_hash_faction_pm == NOT_SET ) dcfg -> crypto_hash_faction_pm = 0 ;\n if ( dcfg -> crypto_hash_location_pm == NOT_SET ) dcfg -> crypto_hash_location_pm = 0 ;\n if ( dcfg -> crypto_hash_iframesrc_pm == NOT_SET ) dcfg -> crypto_hash_iframesrc_pm = 0 ;\n if ( dcfg -> crypto_hash_framesrc_pm == NOT_SET ) dcfg -> crypto_hash_framesrc_pm = 0 ;\n }",
        "hash": -5493081488206619677,
        "project": "debian",
        "size": 80,
        "slice": {
            "strlen": [
                [
                    2,
                    " if ( dcfg == NULL ) return ;\n"
                ],
                [
                    64,
                    " if ( dcfg -> crypto_key == NOT_SET_P ) dcfg -> crypto_key = getkey ( dcfg -> mp ) ;\n"
                ],
                [
                    65,
                    " if ( dcfg -> crypto_key_len == NOT_SET ) dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ;\n"
                ]
            ],
            "result": [
                [
                    2,
                    " if ( dcfg == NULL ) return ;\n"
                ],
                [
                    64,
                    " if ( dcfg -> crypto_key == NOT_SET_P ) dcfg -> crypto_key = getkey ( dcfg -> mp ) ;\n"
                ],
                [
                    65,
                    " if ( dcfg -> crypto_key_len == NOT_SET ) dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n CURLcode result ;\n char * plainauth ;\n size_t ulen ;\n size_t plen ;\n size_t plainlen ;\n * outlen = 0 ;\n * outptr = NULL ;\n ulen = strlen ( userp ) ;\n plen = strlen ( passwdp ) ;\n if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;\n plainlen = 2 * ulen + plen + 2 ;\n plainauth = malloc ( plainlen ) ;\n if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;\n memcpy ( plainauth , userp , ulen ) ;\n plainauth [ ulen ] = '\\0' ;\n memcpy ( plainauth + ulen + 1 , userp , ulen ) ;\n plainauth [ 2 * ulen + 1 ] = '\\0' ;\n memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ;\n result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;\n free ( plainauth ) ;\n return result ;\n }",
        "hash": -8908662106146784322,
        "project": "debian",
        "size": 23,
        "slice": {
            "memcpy": [
                [
                    1,
                    "CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n"
                ],
                [
                    9,
                    " ulen = strlen ( userp ) ;\n"
                ],
                [
                    10,
                    " plen = strlen ( passwdp ) ;\n"
                ],
                [
                    11,
                    " if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    12,
                    " plainlen = 2 * ulen + plen + 2 ;\n"
                ],
                [
                    14,
                    " if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    15,
                    " memcpy ( plainauth , userp , ulen ) ;\n"
                ],
                [
                    16,
                    " plainauth [ ulen ] = '\\0' ;\n"
                ],
                [
                    17,
                    " memcpy ( plainauth + ulen + 1 , userp , ulen ) ;\n"
                ],
                [
                    18,
                    " plainauth [ 2 * ulen + 1 ] = '\\0' ;\n"
                ],
                [
                    19,
                    " memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ;\n"
                ],
                [
                    20,
                    " result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n"
                ],
                [
                    9,
                    " ulen = strlen ( userp ) ;\n"
                ],
                [
                    10,
                    " plen = strlen ( passwdp ) ;\n"
                ],
                [
                    11,
                    " if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    12,
                    " plainlen = 2 * ulen + plen + 2 ;\n"
                ],
                [
                    15,
                    " memcpy ( plainauth , userp , ulen ) ;\n"
                ],
                [
                    19,
                    " memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n"
                ],
                [
                    11,
                    " if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    12,
                    " plainlen = 2 * ulen + plen + 2 ;\n"
                ],
                [
                    13,
                    " plainauth = malloc ( plainlen ) ;\n"
                ],
                [
                    14,
                    " if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    20,
                    " result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n"
                ],
                [
                    14,
                    " if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    16,
                    " plainauth [ ulen ] = '\\0' ;\n"
                ],
                [
                    18,
                    " plainauth [ 2 * ulen + 1 ] = '\\0' ;\n"
                ],
                [
                    20,
                    " result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;\n"
                ],
                [
                    21,
                    " free ( plainauth ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n"
                ],
                [
                    9,
                    " ulen = strlen ( userp ) ;\n"
                ],
                [
                    10,
                    " plen = strlen ( passwdp ) ;\n"
                ],
                [
                    11,
                    " if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    12,
                    " plainlen = 2 * ulen + plen + 2 ;\n"
                ],
                [
                    13,
                    " plainauth = malloc ( plainlen ) ;\n"
                ],
                [
                    14,
                    " if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    15,
                    " memcpy ( plainauth , userp , ulen ) ;\n"
                ],
                [
                    16,
                    " plainauth [ ulen ] = '\\0' ;\n"
                ],
                [
                    17,
                    " memcpy ( plainauth + ulen + 1 , userp , ulen ) ;\n"
                ],
                [
                    18,
                    " plainauth [ 2 * ulen + 1 ] = '\\0' ;\n"
                ],
                [
                    19,
                    " memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ;\n"
                ],
                [
                    20,
                    " result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;\n"
                ],
                [
                    21,
                    " free ( plainauth ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int get_file_params_count_resume ( char * * params , int paramcount ) {\n int pos , best ;\n if ( * params [ 0 ] == '\"' ) {\n for ( pos = 0 ;\n pos < paramcount - 2 ;\n pos ++ ) {\n if ( params [ pos ] [ strlen ( params [ pos ] ) - 1 ] == '\"' && get_params_match_resume ( params , pos + 1 ) ) return pos + 1 ;\n }\n }\n best = paramcount - 2 ;\n for ( pos = paramcount - 2 ;\n pos > 0 ;\n pos -- ) {\n if ( get_params_match_resume ( params , pos ) ) best = pos ;\n }\n return best ;\n }",
        "hash": -7440595807730782314,
        "project": "debian",
        "size": 17,
        "slice": {
            "strlen": [
                [
                    1,
                    "int get_file_params_count_resume ( char * * params , int paramcount ) {\n"
                ],
                [
                    5,
                    " pos < paramcount - 2 ;\n"
                ],
                [
                    6,
                    " pos ++ ) {\n"
                ],
                [
                    7,
                    " if ( params [ pos ] [ strlen ( params [ pos ] ) - 1 ] == '\"' && get_params_match_resume ( params , pos + 1 ) ) return pos + 1 ;\n"
                ],
                [
                    14,
                    " if ( get_params_match_resume ( params , pos ) ) best = pos ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int get_file_params_count_resume ( char * * params , int paramcount ) {\n"
                ],
                [
                    5,
                    " pos < paramcount - 2 ;\n"
                ],
                [
                    6,
                    " pos ++ ) {\n"
                ],
                [
                    7,
                    " if ( params [ pos ] [ strlen ( params [ pos ] ) - 1 ] == '\"' && get_params_match_resume ( params , pos + 1 ) ) return pos + 1 ;\n"
                ],
                [
                    14,
                    " if ( get_params_match_resume ( params , pos ) ) best = pos ;\n"
                ]
            ]
        }
    },
    {
        "code": "SRP_user_pwd * SRP_VBASE_get_by_user ( SRP_VBASE * vb , char * username ) {\n int i ;\n SRP_user_pwd * user ;\n unsigned char digv [ SHA_DIGEST_LENGTH ] ;\n unsigned char digs [ SHA_DIGEST_LENGTH ] ;\n EVP_MD_CTX ctxt ;\n if ( vb == NULL ) return NULL ;\n for ( i = 0 ;\n i < sk_SRP_user_pwd_num ( vb -> users_pwd ) ;\n i ++ ) {\n user = sk_SRP_user_pwd_value ( vb -> users_pwd , i ) ;\n if ( strcmp ( user -> id , username ) == 0 ) return user ;\n }\n if ( ( vb -> seed_key == NULL ) || ( vb -> default_g == NULL ) || ( vb -> default_N == NULL ) ) return NULL ;\n if ( ( user = SRP_user_pwd_new ( ) ) == NULL ) return NULL ;\n SRP_user_pwd_set_gN ( user , vb -> default_g , vb -> default_N ) ;\n if ( ! SRP_user_pwd_set_ids ( user , username , NULL ) ) goto err ;\n if ( RAND_pseudo_bytes ( digv , SHA_DIGEST_LENGTH ) < 0 ) goto err ;\n EVP_MD_CTX_init ( & ctxt ) ;\n EVP_DigestInit_ex ( & ctxt , EVP_sha1 ( ) , NULL ) ;\n EVP_DigestUpdate ( & ctxt , vb -> seed_key , strlen ( vb -> seed_key ) ) ;\n EVP_DigestUpdate ( & ctxt , username , strlen ( username ) ) ;\n EVP_DigestFinal_ex ( & ctxt , digs , NULL ) ;\n EVP_MD_CTX_cleanup ( & ctxt ) ;\n if ( SRP_user_pwd_set_sv_BN ( user , BN_bin2bn ( digs , SHA_DIGEST_LENGTH , NULL ) , BN_bin2bn ( digv , SHA_DIGEST_LENGTH , NULL ) ) ) return user ;\n err : SRP_user_pwd_free ( user ) ;\n return NULL ;\n }",
        "hash": -331579171381918893,
        "project": "debian",
        "size": 28,
        "slice": {
            "strcmp": [
                [
                    1,
                    "SRP_user_pwd * SRP_VBASE_get_by_user ( SRP_VBASE * vb , char * username ) {\n"
                ],
                [
                    9,
                    " i < sk_SRP_user_pwd_num ( vb -> users_pwd ) ;\n"
                ],
                [
                    10,
                    " i ++ ) {\n"
                ],
                [
                    11,
                    " user = sk_SRP_user_pwd_value ( vb -> users_pwd , i ) ;\n"
                ],
                [
                    12,
                    " if ( strcmp ( user -> id , username ) == 0 ) return user ;\n"
                ],
                [
                    16,
                    " SRP_user_pwd_set_gN ( user , vb -> default_g , vb -> default_N ) ;\n"
                ],
                [
                    17,
                    " if ( ! SRP_user_pwd_set_ids ( user , username , NULL ) ) goto err ;\n"
                ],
                [
                    25,
                    " if ( SRP_user_pwd_set_sv_BN ( user , BN_bin2bn ( digs , SHA_DIGEST_LENGTH , NULL ) , BN_bin2bn ( digv , SHA_DIGEST_LENGTH , NULL ) ) ) return user ;\n"
                ],
                [
                    26,
                    " err : SRP_user_pwd_free ( user ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "SRP_user_pwd * SRP_VBASE_get_by_user ( SRP_VBASE * vb , char * username ) {\n"
                ],
                [
                    7,
                    " if ( vb == NULL ) return NULL ;\n"
                ],
                [
                    14,
                    " if ( ( vb -> seed_key == NULL ) || ( vb -> default_g == NULL ) || ( vb -> default_N == NULL ) ) return NULL ;\n"
                ],
                [
                    17,
                    " if ( ! SRP_user_pwd_set_ids ( user , username , NULL ) ) goto err ;\n"
                ],
                [
                    18,
                    " if ( RAND_pseudo_bytes ( digv , SHA_DIGEST_LENGTH ) < 0 ) goto err ;\n"
                ],
                [
                    19,
                    " EVP_MD_CTX_init ( & ctxt ) ;\n"
                ],
                [
                    20,
                    " EVP_DigestInit_ex ( & ctxt , EVP_sha1 ( ) , NULL ) ;\n"
                ],
                [
                    21,
                    " EVP_DigestUpdate ( & ctxt , vb -> seed_key , strlen ( vb -> seed_key ) ) ;\n"
                ],
                [
                    22,
                    " EVP_DigestUpdate ( & ctxt , username , strlen ( username ) ) ;\n"
                ],
                [
                    23,
                    " EVP_DigestFinal_ex ( & ctxt , digs , NULL ) ;\n"
                ],
                [
                    24,
                    " EVP_MD_CTX_cleanup ( & ctxt ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "SRP_user_pwd * SRP_VBASE_get_by_user ( SRP_VBASE * vb , char * username ) {\n"
                ],
                [
                    7,
                    " if ( vb == NULL ) return NULL ;\n"
                ],
                [
                    9,
                    " i < sk_SRP_user_pwd_num ( vb -> users_pwd ) ;\n"
                ],
                [
                    10,
                    " i ++ ) {\n"
                ],
                [
                    11,
                    " user = sk_SRP_user_pwd_value ( vb -> users_pwd , i ) ;\n"
                ],
                [
                    12,
                    " if ( strcmp ( user -> id , username ) == 0 ) return user ;\n"
                ],
                [
                    14,
                    " if ( ( vb -> seed_key == NULL ) || ( vb -> default_g == NULL ) || ( vb -> default_N == NULL ) ) return NULL ;\n"
                ],
                [
                    16,
                    " SRP_user_pwd_set_gN ( user , vb -> default_g , vb -> default_N ) ;\n"
                ],
                [
                    17,
                    " if ( ! SRP_user_pwd_set_ids ( user , username , NULL ) ) goto err ;\n"
                ],
                [
                    18,
                    " if ( RAND_pseudo_bytes ( digv , SHA_DIGEST_LENGTH ) < 0 ) goto err ;\n"
                ],
                [
                    19,
                    " EVP_MD_CTX_init ( & ctxt ) ;\n"
                ],
                [
                    20,
                    " EVP_DigestInit_ex ( & ctxt , EVP_sha1 ( ) , NULL ) ;\n"
                ],
                [
                    21,
                    " EVP_DigestUpdate ( & ctxt , vb -> seed_key , strlen ( vb -> seed_key ) ) ;\n"
                ],
                [
                    22,
                    " EVP_DigestUpdate ( & ctxt , username , strlen ( username ) ) ;\n"
                ],
                [
                    23,
                    " EVP_DigestFinal_ex ( & ctxt , digs , NULL ) ;\n"
                ],
                [
                    24,
                    " EVP_MD_CTX_cleanup ( & ctxt ) ;\n"
                ],
                [
                    25,
                    " if ( SRP_user_pwd_set_sv_BN ( user , BN_bin2bn ( digs , SHA_DIGEST_LENGTH , NULL ) , BN_bin2bn ( digv , SHA_DIGEST_LENGTH , NULL ) ) ) return user ;\n"
                ],
                [
                    26,
                    " err : SRP_user_pwd_free ( user ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "ssize_t pcnet_receive ( NetClientState * nc , const uint8_t * buf , size_t size_ ) {\n PCNetState * s = qemu_get_nic_opaque ( nc ) ;\n int is_padr = 0 , is_bcast = 0 , is_ladr = 0 ;\n uint8_t buf1 [ 60 ] ;\n int remaining ;\n int crc_err = 0 ;\n int size = size_ ;\n if ( CSR_DRX ( s ) || CSR_STOP ( s ) || CSR_SPND ( s ) || ! size || ( CSR_LOOP ( s ) && ! s -> looptest ) ) {\n return - 1 ;\n }\n # ifdef PCNET_DEBUG printf ( \"pcnet_receive size=%d\\n\" , size ) ;\n # endif if ( size < MIN_BUF_SIZE ) {\n memcpy ( buf1 , buf , size ) ;\n memset ( buf1 + size , 0 , MIN_BUF_SIZE - size ) ;\n buf = buf1 ;\n size = MIN_BUF_SIZE ;\n }\n if ( CSR_PROM ( s ) || ( is_padr = padr_match ( s , buf , size ) ) || ( is_bcast = padr_bcast ( s , buf , size ) ) || ( is_ladr = ladr_match ( s , buf , size ) ) ) {\n pcnet_rdte_poll ( s ) ;\n if ( ! ( CSR_CRST ( s ) & 0x8000 ) && s -> rdra ) {\n struct pcnet_RMD rmd ;\n int rcvrc = CSR_RCVRC ( s ) - 1 , i ;\n hwaddr nrda ;\n for ( i = CSR_RCVRL ( s ) - 1 ;\n i > 0 ;\n i -- , rcvrc -- ) {\n if ( rcvrc <= 1 ) rcvrc = CSR_RCVRL ( s ) ;\n nrda = s -> rdra + ( CSR_RCVRL ( s ) - rcvrc ) * ( BCR_SWSTYLE ( s ) ? 16 : 8 ) ;\n RMDLOAD ( & rmd , nrda ) ;\n if ( GET_FIELD ( rmd . status , RMDS , OWN ) ) {\n # ifdef PCNET_DEBUG_RMD printf ( \"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\" , rcvrc , CSR_RCVRC ( s ) ) ;\n # endif CSR_RCVRC ( s ) = rcvrc ;\n pcnet_rdte_poll ( s ) ;\n break ;\n }\n }\n }\n if ( ! ( CSR_CRST ( s ) & 0x8000 ) ) {\n # ifdef PCNET_DEBUG_RMD printf ( \"pcnet - no buffer: RCVRC=%d\\n\" , CSR_RCVRC ( s ) ) ;\n # endif s -> csr [ 0 ] |= 0x1000 ;\n CSR_MISSC ( s ) ++ ;\n }\n else {\n uint8_t * src = s -> buffer ;\n hwaddr crda = CSR_CRDA ( s ) ;\n struct pcnet_RMD rmd ;\n int pktcount = 0 ;\n if ( ! s -> looptest ) {\n if ( size > 4092 ) {\n # ifdef PCNET_DEBUG_RMD fprintf ( stderr , \"pcnet: truncates rx packet.\\n\" ) ;\n # endif size = 4092 ;\n }\n memcpy ( src , buf , size ) ;\n src [ size ] = 0 ;\n src [ size + 1 ] = 0 ;\n src [ size + 2 ] = 0 ;\n src [ size + 3 ] = 0 ;\n size += 4 ;\n }\n else if ( s -> looptest == PCNET_LOOPTEST_CRC || ! CSR_DXMTFCS ( s ) || size < MIN_BUF_SIZE + 4 ) {\n uint32_t fcs = ~ 0 ;\n uint8_t * p = src ;\n while ( p != & src [ size ] ) CRC ( fcs , * p ++ ) ;\n * ( uint32_t * ) p = htonl ( fcs ) ;\n size += 4 ;\n }\n else {\n uint32_t fcs = ~ 0 ;\n uint8_t * p = src ;\n while ( p != & src [ size ] ) CRC ( fcs , * p ++ ) ;\n crc_err = ( * ( uint32_t * ) p != htonl ( fcs ) ) ;\n }\n # ifdef PCNET_DEBUG_MATCH PRINT_PKTHDR ( buf ) ;\n # endif RMDLOAD ( & rmd , PHYSADDR ( s , crda ) ) ;\n SET_FIELD ( & rmd . status , RMDS , STP , 1 ) ;\n # define PCNET_RECV_STORE ( ) do {\n int count = MIN ( 4096 - GET_FIELD ( rmd . buf_length , RMDL , BCNT ) , remaining ) ;\n hwaddr rbadr = PHYSADDR ( s , rmd . rbadr ) ;\n s -> phys_mem_write ( s -> dma_opaque , rbadr , src , count , CSR_BSWP ( s ) ) ;\n src += count ;\n remaining -= count ;\n SET_FIELD ( & rmd . status , RMDS , OWN , 0 ) ;\n RMDSTORE ( & rmd , PHYSADDR ( s , crda ) ) ;\n pktcount ++ ;\n \\ }\n while ( 0 ) remaining = size ;\n PCNET_RECV_STORE ( ) ;\n if ( ( remaining > 0 ) && CSR_NRDA ( s ) ) {\n hwaddr nrda = CSR_NRDA ( s ) ;\n # ifdef PCNET_DEBUG_RMD PRINT_RMD ( & rmd ) ;\n # endif RMDLOAD ( & rmd , PHYSADDR ( s , nrda ) ) ;\n if ( GET_FIELD ( rmd . status , RMDS , OWN ) ) {\n crda = nrda ;\n PCNET_RECV_STORE ( ) ;\n # ifdef PCNET_DEBUG_RMD PRINT_RMD ( & rmd ) ;\n # endif if ( ( remaining > 0 ) && ( nrda = CSR_NNRD ( s ) ) ) {\n RMDLOAD ( & rmd , PHYSADDR ( s , nrda ) ) ;\n if ( GET_FIELD ( rmd . status , RMDS , OWN ) ) {\n crda = nrda ;\n PCNET_RECV_STORE ( ) ;\n }\n }\n }\n }\n # undef PCNET_RECV_STORE RMDLOAD ( & rmd , PHYSADDR ( s , crda ) ) ;\n if ( remaining == 0 ) {\n SET_FIELD ( & rmd . msg_length , RMDM , MCNT , size ) ;\n SET_FIELD ( & rmd . status , RMDS , ENP , 1 ) ;\n SET_FIELD ( & rmd . status , RMDS , PAM , ! CSR_PROM ( s ) && is_padr ) ;\n SET_FIELD ( & rmd . status , RMDS , LFAM , ! CSR_PROM ( s ) && is_ladr ) ;\n SET_FIELD ( & rmd . status , RMDS , BAM , ! CSR_PROM ( s ) && is_bcast ) ;\n if ( crc_err ) {\n SET_FIELD ( & rmd . status , RMDS , CRC , 1 ) ;\n SET_FIELD ( & rmd . status , RMDS , ERR , 1 ) ;\n }\n }\n else {\n SET_FIELD ( & rmd . status , RMDS , OFLO , 1 ) ;\n SET_FIELD ( & rmd . status , RMDS , BUFF , 1 ) ;\n SET_FIELD ( & rmd . status , RMDS , ERR , 1 ) ;\n }\n RMDSTORE ( & rmd , PHYSADDR ( s , crda ) ) ;\n s -> csr [ 0 ] |= 0x0400 ;\n # ifdef PCNET_DEBUG printf ( \"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\" , CSR_RCVRC ( s ) , PHYSADDR ( s , CSR_CRDA ( s ) ) , pktcount ) ;\n # endif # ifdef PCNET_DEBUG_RMD PRINT_RMD ( & rmd ) ;\n # endif while ( pktcount -- ) {\n if ( CSR_RCVRC ( s ) <= 1 ) {\n CSR_RCVRC ( s ) = CSR_RCVRL ( s ) ;\n }\n else {\n CSR_RCVRC ( s ) -- ;\n }\n }\n pcnet_rdte_poll ( s ) ;\n }\n }\n pcnet_poll ( s ) ;\n pcnet_update_irq ( s ) ;\n return size_ ;\n }",
        "hash": 8193534372312945122,
        "project": "debian",
        "size": 140,
        "slice": {
            "memcpy": [
                [
                    1,
                    "ssize_t pcnet_receive ( NetClientState * nc , const uint8_t * buf , size_t size_ ) {\n"
                ],
                [
                    4,
                    " uint8_t buf1 [ 60 ] ;\n"
                ],
                [
                    7,
                    " int size = size_ ;\n"
                ],
                [
                    8,
                    " if ( CSR_DRX ( s ) || CSR_STOP ( s ) || CSR_SPND ( s ) || ! size || ( CSR_LOOP ( s ) && ! s -> looptest ) ) {\n"
                ],
                [
                    13,
                    " memcpy ( buf1 , buf , size ) ;\n"
                ],
                [
                    14,
                    " memset ( buf1 + size , 0 , MIN_BUF_SIZE - size ) ;\n"
                ],
                [
                    15,
                    " buf = buf1 ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "ssize_t pcnet_receive ( NetClientState * nc , const uint8_t * buf , size_t size_ ) {\n"
                ],
                [
                    8,
                    " if ( CSR_DRX ( s ) || CSR_STOP ( s ) || CSR_SPND ( s ) || ! size || ( CSR_LOOP ( s ) && ! s -> looptest ) ) {\n"
                ],
                [
                    13,
                    " memcpy ( buf1 , buf , size ) ;\n"
                ],
                [
                    14,
                    " memset ( buf1 + size , 0 , MIN_BUF_SIZE - size ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "ssize_t pcnet_receive ( NetClientState * nc , const uint8_t * buf , size_t size_ ) {\n"
                ],
                [
                    4,
                    " uint8_t buf1 [ 60 ] ;\n"
                ],
                [
                    7,
                    " int size = size_ ;\n"
                ],
                [
                    8,
                    " if ( CSR_DRX ( s ) || CSR_STOP ( s ) || CSR_SPND ( s ) || ! size || ( CSR_LOOP ( s ) && ! s -> looptest ) ) {\n"
                ],
                [
                    13,
                    " memcpy ( buf1 , buf , size ) ;\n"
                ],
                [
                    14,
                    " memset ( buf1 + size , 0 , MIN_BUF_SIZE - size ) ;\n"
                ],
                [
                    15,
                    " buf = buf1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "tdata_t _TIFFmalloc ( tsize_t s ) {\n if ( s == 0 ) return ( ( void * ) NULL ) ;\n return ( malloc ( ( size_t ) s ) ) ;\n }",
        "hash": -6468986929796051453,
        "project": "debian",
        "size": 4,
        "slice": {
            "malloc": [
                [
                    1,
                    "tdata_t _TIFFmalloc ( tsize_t s ) {\n"
                ],
                [
                    2,
                    " if ( s == 0 ) return ( ( void * ) NULL ) ;\n"
                ],
                [
                    3,
                    " return ( malloc ( ( size_t ) s ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "tdata_t _TIFFmalloc ( tsize_t s ) {\n"
                ],
                [
                    2,
                    " if ( s == 0 ) return ( ( void * ) NULL ) ;\n"
                ],
                [
                    3,
                    " return ( malloc ( ( size_t ) s ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static VALUE cState_array_nl_set ( VALUE self , VALUE array_nl ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( array_nl , T_STRING ) ;\n len = RSTRING_LEN ( array_nl ) ;\n if ( len == 0 ) {\n if ( state -> array_nl ) {\n ruby_xfree ( state -> array_nl ) ;\n state -> array_nl = NULL ;\n }\n }\n else {\n if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ;\n state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ;\n state -> array_nl_len = len ;\n }\n return Qnil ;\n }",
        "hash": 3668456668028959955,
        "project": "debian",
        "size": 18,
        "slice": {
            "strdup": [
                [
                    1,
                    "static VALUE cState_array_nl_set ( VALUE self , VALUE array_nl ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    14,
                    " state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static VALUE cState_array_nl_set ( VALUE self , VALUE array_nl ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    14,
                    " state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static VALUE cState_indent_set ( VALUE self , VALUE indent ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( indent , T_STRING ) ;\n len = RSTRING_LEN ( indent ) ;\n if ( len == 0 ) {\n if ( state -> indent ) {\n ruby_xfree ( state -> indent ) ;\n state -> indent = NULL ;\n state -> indent_len = 0 ;\n }\n }\n else {\n if ( state -> indent ) ruby_xfree ( state -> indent ) ;\n state -> indent = strdup ( RSTRING_PTR ( indent ) ) ;\n state -> indent_len = len ;\n }\n return Qnil ;\n }",
        "hash": 3668456668028959955,
        "project": "debian",
        "size": 19,
        "slice": {
            "strdup": [
                [
                    1,
                    "static VALUE cState_indent_set ( VALUE self , VALUE indent ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    15,
                    " state -> indent = strdup ( RSTRING_PTR ( indent ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static VALUE cState_indent_set ( VALUE self , VALUE indent ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    15,
                    " state -> indent = strdup ( RSTRING_PTR ( indent ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( object_nl , T_STRING ) ;\n len = RSTRING_LEN ( object_nl ) ;\n if ( len == 0 ) {\n if ( state -> object_nl ) {\n ruby_xfree ( state -> object_nl ) ;\n state -> object_nl = NULL ;\n }\n }\n else {\n if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ;\n state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ;\n state -> object_nl_len = len ;\n }\n return Qnil ;\n }",
        "hash": 3668456668028959955,
        "project": "debian",
        "size": 18,
        "slice": {
            "strdup": [
                [
                    1,
                    "static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    14,
                    " state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    14,
                    " state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static VALUE cState_space_before_set ( VALUE self , VALUE space_before ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( space_before , T_STRING ) ;\n len = RSTRING_LEN ( space_before ) ;\n if ( len == 0 ) {\n if ( state -> space_before ) {\n ruby_xfree ( state -> space_before ) ;\n state -> space_before = NULL ;\n state -> space_before_len = 0 ;\n }\n }\n else {\n if ( state -> space_before ) ruby_xfree ( state -> space_before ) ;\n state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ;\n state -> space_before_len = len ;\n }\n return Qnil ;\n }",
        "hash": 3668456668028959955,
        "project": "debian",
        "size": 19,
        "slice": {
            "strdup": [
                [
                    1,
                    "static VALUE cState_space_before_set ( VALUE self , VALUE space_before ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    15,
                    " state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static VALUE cState_space_before_set ( VALUE self , VALUE space_before ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    15,
                    " state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static VALUE cState_space_set ( VALUE self , VALUE space ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( space , T_STRING ) ;\n len = RSTRING_LEN ( space ) ;\n if ( len == 0 ) {\n if ( state -> space ) {\n ruby_xfree ( state -> space ) ;\n state -> space = NULL ;\n state -> space_len = 0 ;\n }\n }\n else {\n if ( state -> space ) ruby_xfree ( state -> space ) ;\n state -> space = strdup ( RSTRING_PTR ( space ) ) ;\n state -> space_len = len ;\n }\n return Qnil ;\n }",
        "hash": 3668456668028959955,
        "project": "debian",
        "size": 19,
        "slice": {
            "strdup": [
                [
                    1,
                    "static VALUE cState_space_set ( VALUE self , VALUE space ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    15,
                    " state -> space = strdup ( RSTRING_PTR ( space ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static VALUE cState_space_set ( VALUE self , VALUE space ) {\n"
                ],
                [
                    6,
                    " if ( len == 0 ) {\n"
                ],
                [
                    15,
                    " state -> space = strdup ( RSTRING_PTR ( space ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void ppc_prep_init ( int ram_size , int vga_ram_size , int boot_device , DisplayState * ds , const char * * fd_filename , int snapshot , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename ) {\n char buf [ 1024 ] ;\n int PPC_io_memory ;\n int ret , linux_boot , initrd_size , i , nb_nics1 , fd ;\n linux_boot = ( kernel_filename != NULL ) ;\n cpu_register_physical_memory ( 0 , ram_size , 0 ) ;\n isa_mem_base = 0xc0000000 ;\n if ( linux_boot ) {\n ret = load_image ( kernel_filename , phys_ram_base + KERNEL_LOAD_ADDR ) ;\n if ( ret < 0 ) {\n fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n exit ( 1 ) ;\n }\n initrd_size = 0 ;\n # if 0 if ( initrd_filename ) {\n initrd_size = load_image ( initrd_filename , phys_ram_base + INITRD_LOAD_ADDR ) ;\n if ( initrd_size < 0 ) {\n fprintf ( stderr , \"qemu: could not load initial ram disk '%s'\\n\" , initrd_filename ) ;\n exit ( 1 ) ;\n }\n }\n # endif PPC_init_hw ( ram_size , KERNEL_LOAD_ADDR , ret , KERNEL_STACK_ADDR , boot_device , initrd_filename ) ;\n }\n else {\n snprintf ( buf , sizeof ( buf ) , \"%s\" , BIOS_FILENAME ) ;\n printf ( \"load BIOS at %p\\n\" , phys_ram_base + 0x000f0000 ) ;\n ret = load_image ( buf , phys_ram_base + 0x000f0000 ) ;\n if ( ret != 0x10000 ) {\n fprintf ( stderr , \"qemu: could not load PPC bios '%s' (%d)\\n%m\\n\" , buf , ret ) ;\n exit ( 1 ) ;\n }\n }\n vga_initialize ( ds , phys_ram_base + ram_size , ram_size , vga_ram_size ) ;\n rtc_init ( 0x70 , 8 ) ;\n pic_init ( ) ;\n fd = serial_open_device ( ) ;\n serial_init ( 0x3f8 , 4 , fd ) ;\n # if 1 nb_nics1 = nb_nics ;\n if ( nb_nics1 > NE2000_NB_MAX ) nb_nics1 = NE2000_NB_MAX ;\n for ( i = 0 ;\n i < nb_nics1 ;\n i ++ ) {\n ne2000_init ( ne2000_io [ i ] , ne2000_irq [ i ] , & nd_table [ i ] ) ;\n }\n # endif for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n ide_init ( ide_iobase [ i ] , ide_iobase2 [ i ] , ide_irq [ i ] , bs_table [ 2 * i ] , bs_table [ 2 * i + 1 ] ) ;\n }\n kbd_init ( ) ;\n AUD_init ( ) ;\n DMA_init ( ) ;\n fdctrl_init ( 6 , 2 , 0 , 0x3f0 , fd_table ) ;\n PPC_io_memory = cpu_register_io_memory ( 0 , PPC_io_read , PPC_io_write ) ;\n cpu_register_physical_memory ( 0x80000000 , 0x10000 , PPC_io_memory ) ;\n register_ioport_read ( 0x398 , 2 , 1 , & PREP_io_read , NULL ) ;\n register_ioport_write ( 0x398 , 2 , 1 , & PREP_io_write , NULL ) ;\n register_ioport_write ( 0x0092 , 0x1 , 1 , & PREP_io_800_writeb , NULL ) ;\n register_ioport_read ( 0x0800 , 0x52 , 1 , & PREP_io_800_readb , NULL ) ;\n register_ioport_write ( 0x0800 , 0x52 , 1 , & PREP_io_800_writeb , NULL ) ;\n PPC_io_memory = cpu_register_io_memory ( 0 , PPC_ioB_read , PPC_ioB_write ) ;\n cpu_register_physical_memory ( 0xBFFFFFF0 , 0x4 , PPC_io_memory ) ;\n prep_NVRAM_init ( ) ;\n PPC_end_init ( ) ;\n }",
        "hash": 8460430819945784394,
        "project": "debian",
        "size": 65,
        "slice": {
            "printf": [
                [
                    1,
                    "void ppc_prep_init ( int ram_size , int vga_ram_size , int boot_device , DisplayState * ds , const char * * fd_filename , int snapshot , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename ) {\n"
                ],
                [
                    8,
                    " if ( linux_boot ) {\n"
                ],
                [
                    26,
                    " printf ( \"load BIOS at %p\\n\" , phys_ram_base + 0x000f0000 ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "void ppc_prep_init ( int ram_size , int vga_ram_size , int boot_device , DisplayState * ds , const char * * fd_filename , int snapshot , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename ) {\n"
                ],
                [
                    9,
                    " ret = load_image ( kernel_filename , phys_ram_base + KERNEL_LOAD_ADDR ) ;\n"
                ],
                [
                    10,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    11,
                    " fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n"
                ],
                [
                    27,
                    " ret = load_image ( buf , phys_ram_base + 0x000f0000 ) ;\n"
                ],
                [
                    28,
                    " if ( ret != 0x10000 ) {\n"
                ],
                [
                    29,
                    " fprintf ( stderr , \"qemu: could not load PPC bios '%s' (%d)\\n%m\\n\" , buf , ret ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void ppc_prep_init ( int ram_size , int vga_ram_size , int boot_device , DisplayState * ds , const char * * fd_filename , int snapshot , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename ) {\n"
                ],
                [
                    8,
                    " if ( linux_boot ) {\n"
                ],
                [
                    9,
                    " ret = load_image ( kernel_filename , phys_ram_base + KERNEL_LOAD_ADDR ) ;\n"
                ],
                [
                    10,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    11,
                    " fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n"
                ],
                [
                    26,
                    " printf ( \"load BIOS at %p\\n\" , phys_ram_base + 0x000f0000 ) ;\n"
                ],
                [
                    27,
                    " ret = load_image ( buf , phys_ram_base + 0x000f0000 ) ;\n"
                ],
                [
                    28,
                    " if ( ret != 0x10000 ) {\n"
                ],
                [
                    29,
                    " fprintf ( stderr , \"qemu: could not load PPC bios '%s' (%d)\\n%m\\n\" , buf , ret ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static ssize_t virtio_net_receive ( VLANClientState * nc , const uint8_t * buf , size_t size ) {\n VirtIONet * n = DO_UPCAST ( NICState , nc , nc ) -> opaque ;\n struct virtio_net_hdr_mrg_rxbuf * mhdr = NULL ;\n size_t guest_hdr_len , offset , i , host_hdr_len ;\n if ( ! virtio_net_can_receive ( & n -> nic -> nc ) ) return - 1 ;\n guest_hdr_len = n -> mergeable_rx_bufs ? sizeof ( struct virtio_net_hdr_mrg_rxbuf ) : sizeof ( struct virtio_net_hdr ) ;\n host_hdr_len = n -> has_vnet_hdr ? sizeof ( struct virtio_net_hdr ) : 0 ;\n if ( ! virtio_net_has_buffers ( n , size + guest_hdr_len - host_hdr_len ) ) return 0 ;\n if ( ! receive_filter ( n , buf , size ) ) return size ;\n offset = i = 0 ;\n while ( offset < size ) {\n VirtQueueElement elem ;\n int len , total ;\n struct iovec sg [ VIRTQUEUE_MAX_SIZE ] ;\n total = 0 ;\n if ( virtqueue_pop ( n -> rx_vq , & elem ) == 0 ) {\n if ( i == 0 ) return - 1 ;\n error_report ( \"virtio-net unexpected empty queue: \" \"i %zd mergeable %d offset %zd, size %zd, \" \"guest hdr len %zd, host hdr len %zd guest features 0x%x\" , i , n -> mergeable_rx_bufs , offset , size , guest_hdr_len , host_hdr_len , n -> vdev . guest_features ) ;\n exit ( 1 ) ;\n }\n if ( elem . in_num < 1 ) {\n error_report ( \"virtio-net receive queue contains no in buffers\" ) ;\n exit ( 1 ) ;\n }\n if ( ! n -> mergeable_rx_bufs && elem . in_sg [ 0 ] . iov_len != guest_hdr_len ) {\n error_report ( \"virtio-net header not in first element\" ) ;\n exit ( 1 ) ;\n }\n memcpy ( & sg , & elem . in_sg [ 0 ] , sizeof ( sg [ 0 ] ) * elem . in_num ) ;\n if ( i == 0 ) {\n if ( n -> mergeable_rx_bufs ) mhdr = ( struct virtio_net_hdr_mrg_rxbuf * ) sg [ 0 ] . iov_base ;\n offset += receive_header ( n , sg , elem . in_num , buf + offset , size - offset , guest_hdr_len ) ;\n total += guest_hdr_len ;\n }\n len = iov_from_buf ( sg , elem . in_num , buf + offset , 0 , size - offset ) ;\n total += len ;\n offset += len ;\n if ( ! n -> mergeable_rx_bufs && offset < size ) {\n # if 0 error_report ( \"virtio-net truncated non-mergeable packet: \" \"i %zd mergeable %d offset %zd, size %zd, \" \"guest hdr len %zd, host hdr len %zd\" , i , n -> mergeable_rx_bufs , offset , size , guest_hdr_len , host_hdr_len ) ;\n # endif return size ;\n }\n virtqueue_fill ( n -> rx_vq , & elem , total , i ++ ) ;\n }\n if ( mhdr ) {\n stw_p ( & mhdr -> num_buffers , i ) ;\n }\n virtqueue_flush ( n -> rx_vq , i ) ;\n virtio_notify ( & n -> vdev , n -> rx_vq ) ;\n return size ;\n }",
        "hash": -8365810778652022218,
        "project": "debian",
        "size": 50,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static ssize_t virtio_net_receive ( VLANClientState * nc , const uint8_t * buf , size_t size ) {\n"
                ],
                [
                    14,
                    " struct iovec sg [ VIRTQUEUE_MAX_SIZE ] ;\n"
                ],
                [
                    16,
                    " if ( virtqueue_pop ( n -> rx_vq , & elem ) == 0 ) {\n"
                ],
                [
                    17,
                    " if ( i == 0 ) return - 1 ;\n"
                ],
                [
                    25,
                    " if ( ! n -> mergeable_rx_bufs && elem . in_sg [ 0 ] . iov_len != guest_hdr_len ) {\n"
                ],
                [
                    29,
                    " memcpy ( & sg , & elem . in_sg [ 0 ] , sizeof ( sg [ 0 ] ) * elem . in_num ) ;\n"
                ],
                [
                    32,
                    " offset += receive_header ( n , sg , elem . in_num , buf + offset , size - offset , guest_hdr_len ) ;\n"
                ],
                [
                    35,
                    " len = iov_from_buf ( sg , elem . in_num , buf + offset , 0 , size - offset ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static ssize_t virtio_net_receive ( VLANClientState * nc , const uint8_t * buf , size_t size ) {\n"
                ],
                [
                    14,
                    " struct iovec sg [ VIRTQUEUE_MAX_SIZE ] ;\n"
                ],
                [
                    16,
                    " if ( virtqueue_pop ( n -> rx_vq , & elem ) == 0 ) {\n"
                ],
                [
                    17,
                    " if ( i == 0 ) return - 1 ;\n"
                ],
                [
                    25,
                    " if ( ! n -> mergeable_rx_bufs && elem . in_sg [ 0 ] . iov_len != guest_hdr_len ) {\n"
                ],
                [
                    29,
                    " memcpy ( & sg , & elem . in_sg [ 0 ] , sizeof ( sg [ 0 ] ) * elem . in_num ) ;\n"
                ],
                [
                    32,
                    " offset += receive_header ( n , sg , elem . in_num , buf + offset , size - offset , guest_hdr_len ) ;\n"
                ],
                [
                    35,
                    " len = iov_from_buf ( sg , elem . in_num , buf + offset , 0 , size - offset ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ssl23_get_client_hello ( SSL * s ) {\n char buf_space [ 11 ] ;\n char * buf = & ( buf_space [ 0 ] ) ;\n unsigned char * p , * d , * d_len , * dd ;\n unsigned int i ;\n unsigned int csl , sil , cl ;\n int n = 0 , j ;\n int type = 0 ;\n int v [ 2 ] ;\n if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A ) {\n v [ 0 ] = v [ 1 ] = 0 ;\n if ( ! ssl3_setup_buffers ( s ) ) goto err ;\n n = ssl23_read_bytes ( s , sizeof buf_space ) ;\n if ( n != sizeof buf_space ) return ( n ) ;\n p = s -> packet ;\n memcpy ( buf , p , n ) ;\n if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {\n if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) ) {\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) type = 1 ;\n }\n else if ( p [ 3 ] == SSL3_VERSION_MAJOR ) {\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n if ( p [ 4 ] >= TLS1_VERSION_MINOR ) {\n if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n s -> version = TLS1_2_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n s -> version = TLS1_1_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) {\n type = 1 ;\n }\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) type = 1 ;\n }\n }\n else if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) ) {\n v [ 0 ] = p [ 1 ] ;\n if ( p [ 3 ] == 0 && p [ 4 ] < 6 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_SMALL ) ;\n goto err ;\n }\n if ( p [ 9 ] > SSL3_VERSION_MAJOR ) v [ 1 ] = 0xff ;\n else v [ 1 ] = p [ 10 ] ;\n if ( v [ 1 ] >= TLS1_VERSION_MINOR ) {\n if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n s -> version = TLS1_2_VERSION ;\n type = 3 ;\n }\n else if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n s -> version = TLS1_1_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n type = 3 ;\n }\n }\n else {\n if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n s -> version = SSL3_VERSION ;\n type = 3 ;\n }\n else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n s -> version = TLS1_VERSION ;\n type = 3 ;\n }\n }\n }\n else if ( ( strncmp ( \"GET \" , ( char * ) p , 4 ) == 0 ) || ( strncmp ( \"POST \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"HEAD \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"PUT \" , ( char * ) p , 4 ) == 0 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_HTTP_REQUEST ) ;\n goto err ;\n }\n else if ( strncmp ( \"CONNECT\" , ( char * ) p , 7 ) == 0 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_HTTPS_PROXY_REQUEST ) ;\n goto err ;\n }\n }\n OPENSSL_assert ( s -> version <= TLS_MAX_VERSION ) ;\n # ifdef OPENSSL_FIPS if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE ) ;\n goto err ;\n }\n # endif if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B ) {\n type = 2 ;\n p = s -> packet ;\n v [ 0 ] = p [ 3 ] ;\n v [ 1 ] = p [ 4 ] ;\n n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;\n if ( n > ( 1024 * 4 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ;\n goto err ;\n }\n if ( n < 9 ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n goto err ;\n }\n j = ssl23_read_bytes ( s , n + 2 ) ;\n if ( j <= 0 ) return ( j ) ;\n ssl3_finish_mac ( s , s -> packet + 2 , s -> packet_length - 2 ) ;\n if ( s -> msg_callback ) s -> msg_callback ( 0 , SSL2_VERSION , 0 , s -> packet + 2 , s -> packet_length - 2 , s , s -> msg_callback_arg ) ;\n p = s -> packet ;\n p += 5 ;\n n2s ( p , csl ) ;\n n2s ( p , sil ) ;\n n2s ( p , cl ) ;\n d = ( unsigned char * ) s -> init_buf -> data ;\n if ( ( csl + sil + cl + 11 ) != s -> packet_length ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n goto err ;\n }\n * ( d ++ ) = SSL3_MT_CLIENT_HELLO ;\n d_len = d ;\n d += 3 ;\n * ( d ++ ) = SSL3_VERSION_MAJOR ;\n * ( d ++ ) = v [ 1 ] ;\n i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl ;\n memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n d += SSL3_RANDOM_SIZE ;\n * ( d ++ ) = 0 ;\n j = 0 ;\n dd = d ;\n d += 2 ;\n for ( i = 0 ;\n i < csl ;\n i += 3 ) {\n if ( p [ i ] != 0 ) continue ;\n * ( d ++ ) = p [ i + 1 ] ;\n * ( d ++ ) = p [ i + 2 ] ;\n j += 2 ;\n }\n s2n ( j , dd ) ;\n * ( d ++ ) = 1 ;\n * ( d ++ ) = 0 ;\n # if 0 p = p + csl + sil + cl ;\n while ( p < s -> packet + s -> packet_length ) {\n * ( d ++ ) = * ( p ++ ) ;\n }\n # endif i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4 ;\n l2n3 ( ( long ) i , d_len ) ;\n s -> s3 -> tmp . reuse_message = 1 ;\n s -> s3 -> tmp . message_type = SSL3_MT_CLIENT_HELLO ;\n s -> s3 -> tmp . message_size = i ;\n }\n if ( type == 1 ) {\n # ifdef OPENSSL_NO_SSL2 SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ;\n goto err ;\n # else if ( s -> s2 == NULL ) {\n if ( ! ssl2_new ( s ) ) goto err ;\n }\n else ssl2_clear ( s ) ;\n if ( s -> s3 != NULL ) ssl3_free ( s ) ;\n if ( ! BUF_MEM_grow_clean ( s -> init_buf , SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER ) ) {\n goto err ;\n }\n s -> state = SSL2_ST_GET_CLIENT_HELLO_A ;\n if ( s -> options & SSL_OP_NO_TLSv1 && s -> options & SSL_OP_NO_SSLv3 ) s -> s2 -> ssl2_rollback = 0 ;\n else s -> s2 -> ssl2_rollback = 1 ;\n s -> rstate = SSL_ST_READ_HEADER ;\n s -> packet_length = n ;\n s -> packet = & ( s -> s2 -> rbuf [ 0 ] ) ;\n memcpy ( s -> packet , buf , n ) ;\n s -> s2 -> rbuf_left = n ;\n s -> s2 -> rbuf_offs = 0 ;\n s -> method = SSLv2_server_method ( ) ;\n s -> handshake_func = s -> method -> ssl_accept ;\n # endif }\n if ( ( type == 2 ) || ( type == 3 ) ) {\n s -> method = ssl23_get_server_method ( s -> version ) ;\n if ( s -> method == NULL ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ;\n goto err ;\n }\n if ( ! ssl_init_wbio_buffer ( s , 1 ) ) goto err ;\n s -> state = SSL3_ST_SR_CLNT_HELLO_A ;\n if ( type == 3 ) {\n s -> rstate = SSL_ST_READ_HEADER ;\n s -> packet_length = n ;\n if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) goto err ;\n s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ) ;\n memcpy ( s -> packet , buf , n ) ;\n s -> s3 -> rbuf . left = n ;\n s -> s3 -> rbuf . offset = 0 ;\n }\n else {\n s -> packet_length = 0 ;\n s -> s3 -> rbuf . left = 0 ;\n s -> s3 -> rbuf . offset = 0 ;\n }\n # if 0 s -> client_version = ( v [ 0 ] << 8 ) | v [ 1 ] ;\n # endif s -> handshake_func = s -> method -> ssl_accept ;\n }\n if ( ( type < 1 ) || ( type > 3 ) ) {\n SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNKNOWN_PROTOCOL ) ;\n goto err ;\n }\n s -> init_num = 0 ;\n if ( buf != buf_space ) OPENSSL_free ( buf ) ;\n return ( SSL_accept ( s ) ) ;\n err : if ( buf != buf_space ) OPENSSL_free ( buf ) ;\n return ( - 1 ) ;\n }",
        "hash": 6709099320123900016,
        "project": "debian",
        "size": 224,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int ssl23_get_client_hello ( SSL * s ) {\n"
                ],
                [
                    3,
                    " char * buf = & ( buf_space [ 0 ] ) ;\n"
                ],
                [
                    14,
                    " if ( n != sizeof buf_space ) return ( n ) ;\n"
                ],
                [
                    15,
                    " p = s -> packet ;\n"
                ],
                [
                    16,
                    " memcpy ( buf , p , n ) ;\n"
                ],
                [
                    17,
                    " if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {\n"
                ],
                [
                    18,
                    " if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) ) {\n"
                ],
                [
                    19,
                    " v [ 0 ] = p [ 3 ] ;\n"
                ],
                [
                    20,
                    " v [ 1 ] = p [ 4 ] ;\n"
                ],
                [
                    23,
                    " else if ( p [ 3 ] == SSL3_VERSION_MAJOR ) {\n"
                ],
                [
                    24,
                    " v [ 0 ] = p [ 3 ] ;\n"
                ],
                [
                    25,
                    " v [ 1 ] = p [ 4 ] ;\n"
                ],
                [
                    26,
                    " if ( p [ 4 ] >= TLS1_VERSION_MINOR ) {\n"
                ],
                [
                    27,
                    " if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n"
                ],
                [
                    31,
                    " else if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n"
                ],
                [
                    54,
                    " else if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) ) {\n"
                ],
                [
                    55,
                    " v [ 0 ] = p [ 1 ] ;\n"
                ],
                [
                    56,
                    " if ( p [ 3 ] == 0 && p [ 4 ] < 6 ) {\n"
                ],
                [
                    60,
                    " if ( p [ 9 ] > SSL3_VERSION_MAJOR ) v [ 1 ] = 0xff ;\n"
                ],
                [
                    61,
                    " else v [ 1 ] = p [ 10 ] ;\n"
                ],
                [
                    91,
                    " else if ( ( strncmp ( \"GET \" , ( char * ) p , 4 ) == 0 ) || ( strncmp ( \"POST \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"HEAD \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"PUT \" , ( char * ) p , 4 ) == 0 ) ) {\n"
                ],
                [
                    95,
                    " else if ( strncmp ( \"CONNECT\" , ( char * ) p , 7 ) == 0 ) {\n"
                ],
                [
                    108,
                    " v [ 0 ] = p [ 3 ] ;\n"
                ],
                [
                    109,
                    " v [ 1 ] = p [ 4 ] ;\n"
                ],
                [
                    110,
                    " n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;\n"
                ],
                [
                    120,
                    " if ( j <= 0 ) return ( j ) ;\n"
                ],
                [
                    124,
                    " p += 5 ;\n"
                ],
                [
                    125,
                    " n2s ( p , csl ) ;\n"
                ],
                [
                    126,
                    " n2s ( p , sil ) ;\n"
                ],
                [
                    127,
                    " n2s ( p , cl ) ;\n"
                ],
                [
                    139,
                    " memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n"
                ],
                [
                    140,
                    " memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "int ssl23_get_client_hello ( SSL * s ) {\n"
                ],
                [
                    120,
                    " if ( j <= 0 ) return ( j ) ;\n"
                ],
                [
                    137,
                    " * ( d ++ ) = v [ 1 ] ;\n"
                ],
                [
                    138,
                    " i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl ;\n"
                ],
                [
                    139,
                    " memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n"
                ],
                [
                    140,
                    " memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n"
                ],
                [
                    141,
                    " d += SSL3_RANDOM_SIZE ;\n"
                ],
                [
                    142,
                    " * ( d ++ ) = 0 ;\n"
                ],
                [
                    144,
                    " dd = d ;\n"
                ],
                [
                    145,
                    " d += 2 ;\n"
                ],
                [
                    150,
                    " * ( d ++ ) = p [ i + 1 ] ;\n"
                ],
                [
                    151,
                    " * ( d ++ ) = p [ i + 2 ] ;\n"
                ],
                [
                    155,
                    " * ( d ++ ) = 1 ;\n"
                ],
                [
                    156,
                    " * ( d ++ ) = 0 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ssl23_get_client_hello ( SSL * s ) {\n"
                ],
                [
                    3,
                    " char * buf = & ( buf_space [ 0 ] ) ;\n"
                ],
                [
                    14,
                    " if ( n != sizeof buf_space ) return ( n ) ;\n"
                ],
                [
                    15,
                    " p = s -> packet ;\n"
                ],
                [
                    16,
                    " memcpy ( buf , p , n ) ;\n"
                ],
                [
                    17,
                    " if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {\n"
                ],
                [
                    18,
                    " if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) ) {\n"
                ],
                [
                    19,
                    " v [ 0 ] = p [ 3 ] ;\n"
                ],
                [
                    20,
                    " v [ 1 ] = p [ 4 ] ;\n"
                ],
                [
                    23,
                    " else if ( p [ 3 ] == SSL3_VERSION_MAJOR ) {\n"
                ],
                [
                    24,
                    " v [ 0 ] = p [ 3 ] ;\n"
                ],
                [
                    25,
                    " v [ 1 ] = p [ 4 ] ;\n"
                ],
                [
                    26,
                    " if ( p [ 4 ] >= TLS1_VERSION_MINOR ) {\n"
                ],
                [
                    27,
                    " if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n"
                ],
                [
                    31,
                    " else if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n"
                ],
                [
                    54,
                    " else if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) ) {\n"
                ],
                [
                    55,
                    " v [ 0 ] = p [ 1 ] ;\n"
                ],
                [
                    56,
                    " if ( p [ 3 ] == 0 && p [ 4 ] < 6 ) {\n"
                ],
                [
                    60,
                    " if ( p [ 9 ] > SSL3_VERSION_MAJOR ) v [ 1 ] = 0xff ;\n"
                ],
                [
                    61,
                    " else v [ 1 ] = p [ 10 ] ;\n"
                ],
                [
                    91,
                    " else if ( ( strncmp ( \"GET \" , ( char * ) p , 4 ) == 0 ) || ( strncmp ( \"POST \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"HEAD \" , ( char * ) p , 5 ) == 0 ) || ( strncmp ( \"PUT \" , ( char * ) p , 4 ) == 0 ) ) {\n"
                ],
                [
                    95,
                    " else if ( strncmp ( \"CONNECT\" , ( char * ) p , 7 ) == 0 ) {\n"
                ],
                [
                    108,
                    " v [ 0 ] = p [ 3 ] ;\n"
                ],
                [
                    109,
                    " v [ 1 ] = p [ 4 ] ;\n"
                ],
                [
                    110,
                    " n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;\n"
                ],
                [
                    120,
                    " if ( j <= 0 ) return ( j ) ;\n"
                ],
                [
                    124,
                    " p += 5 ;\n"
                ],
                [
                    125,
                    " n2s ( p , csl ) ;\n"
                ],
                [
                    126,
                    " n2s ( p , sil ) ;\n"
                ],
                [
                    127,
                    " n2s ( p , cl ) ;\n"
                ],
                [
                    137,
                    " * ( d ++ ) = v [ 1 ] ;\n"
                ],
                [
                    138,
                    " i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl ;\n"
                ],
                [
                    139,
                    " memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n"
                ],
                [
                    140,
                    " memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n"
                ],
                [
                    141,
                    " d += SSL3_RANDOM_SIZE ;\n"
                ],
                [
                    142,
                    " * ( d ++ ) = 0 ;\n"
                ],
                [
                    144,
                    " dd = d ;\n"
                ],
                [
                    145,
                    " d += 2 ;\n"
                ],
                [
                    150,
                    " * ( d ++ ) = p [ i + 1 ] ;\n"
                ],
                [
                    151,
                    " * ( d ++ ) = p [ i + 2 ] ;\n"
                ],
                [
                    155,
                    " * ( d ++ ) = 1 ;\n"
                ],
                [
                    156,
                    " * ( d ++ ) = 0 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static char * get_pid_environ_val ( pid_t pid , char * val ) {\n char temp [ 500 ] ;\n int i = 0 ;\n int foundit = 0 ;\n FILE * fp ;\n sprintf ( temp , \"/proc/%d/environ\" , pid ) ;\n fp = fopen ( temp , \"r\" ) ;\n if ( fp == NULL ) return NULL ;\n for ( ;\n ;\n ) {\n temp [ i ] = fgetc ( fp ) ;\n if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) {\n char * ret ;\n temp [ i ] = 0 ;\n ret = malloc ( strlen ( temp ) + 10 ) ;\n sprintf ( ret , \"%s\" , temp ) ;\n fclose ( fp ) ;\n return ret ;\n }\n switch ( temp [ i ] ) {\n case EOF : fclose ( fp ) ;\n return NULL ;\n case '=' : temp [ i ] = 0 ;\n if ( ! strcmp ( temp , val ) ) {\n foundit = 1 ;\n }\n i = 0 ;\n break ;\n case '\\0' : i = 0 ;\n break ;\n default : i ++ ;\n }\n }\n }",
        "hash": -2424348134098907053,
        "project": "debian",
        "size": 35,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static char * get_pid_environ_val ( pid_t pid , char * val ) {\n"
                ],
                [
                    7,
                    " fp = fopen ( temp , \"r\" ) ;\n"
                ],
                [
                    13,
                    " if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) {\n"
                ],
                [
                    16,
                    " ret = malloc ( strlen ( temp ) + 10 ) ;\n"
                ],
                [
                    21,
                    " switch ( temp [ i ] ) {\n"
                ],
                [
                    24,
                    " case '=' : temp [ i ] = 0 ;\n"
                ],
                [
                    25,
                    " if ( ! strcmp ( temp , val ) ) {\n"
                ],
                [
                    26,
                    " foundit = 1 ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static char * get_pid_environ_val ( pid_t pid , char * val ) {\n"
                ],
                [
                    7,
                    " fp = fopen ( temp , \"r\" ) ;\n"
                ],
                [
                    13,
                    " if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) {\n"
                ],
                [
                    15,
                    " temp [ i ] = 0 ;\n"
                ],
                [
                    16,
                    " ret = malloc ( strlen ( temp ) + 10 ) ;\n"
                ],
                [
                    17,
                    " sprintf ( ret , \"%s\" , temp ) ;\n"
                ],
                [
                    25,
                    " if ( ! strcmp ( temp , val ) ) {\n"
                ]
            ],
            "sprintf": [
                [
                    1,
                    "static char * get_pid_environ_val ( pid_t pid , char * val ) {\n"
                ],
                [
                    2,
                    " char temp [ 500 ] ;\n"
                ],
                [
                    6,
                    " sprintf ( temp , \"/proc/%d/environ\" , pid ) ;\n"
                ],
                [
                    7,
                    " fp = fopen ( temp , \"r\" ) ;\n"
                ],
                [
                    13,
                    " if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) {\n"
                ],
                [
                    15,
                    " temp [ i ] = 0 ;\n"
                ],
                [
                    16,
                    " ret = malloc ( strlen ( temp ) + 10 ) ;\n"
                ],
                [
                    17,
                    " sprintf ( ret , \"%s\" , temp ) ;\n"
                ],
                [
                    19,
                    " return ret ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static char * get_pid_environ_val ( pid_t pid , char * val ) {\n"
                ],
                [
                    13,
                    " if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) {\n"
                ],
                [
                    16,
                    " ret = malloc ( strlen ( temp ) + 10 ) ;\n"
                ],
                [
                    17,
                    " sprintf ( ret , \"%s\" , temp ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static char * get_pid_environ_val ( pid_t pid , char * val ) {\n"
                ],
                [
                    2,
                    " char temp [ 500 ] ;\n"
                ],
                [
                    6,
                    " sprintf ( temp , \"/proc/%d/environ\" , pid ) ;\n"
                ],
                [
                    7,
                    " fp = fopen ( temp , \"r\" ) ;\n"
                ],
                [
                    13,
                    " if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) {\n"
                ],
                [
                    15,
                    " temp [ i ] = 0 ;\n"
                ],
                [
                    16,
                    " ret = malloc ( strlen ( temp ) + 10 ) ;\n"
                ],
                [
                    17,
                    " sprintf ( ret , \"%s\" , temp ) ;\n"
                ],
                [
                    19,
                    " return ret ;\n"
                ],
                [
                    21,
                    " switch ( temp [ i ] ) {\n"
                ],
                [
                    24,
                    " case '=' : temp [ i ] = 0 ;\n"
                ],
                [
                    25,
                    " if ( ! strcmp ( temp , val ) ) {\n"
                ],
                [
                    26,
                    " foundit = 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void process_envvars ( enum mode * modep ) {\n char * * runp = _environ ;\n char * envline ;\n enum mode mode = normal ;\n char * debug_output = NULL ;\n GLRO ( dl_profile_output ) = & \"/var/tmp\\0/var/profile\" [ __libc_enable_secure ? 9 : 0 ] ;\n while ( ( envline = _dl_next_ld_env_entry ( & runp ) ) != NULL ) {\n size_t len = 0 ;\n while ( envline [ len ] != '\\0' && envline [ len ] != '=' ) ++ len ;\n if ( envline [ len ] != '=' ) continue ;\n switch ( len ) {\n case 4 : if ( memcmp ( envline , \"WARN\" , 4 ) == 0 ) GLRO ( dl_verbose ) = envline [ 5 ] != '\\0' ;\n break ;\n case 5 : if ( memcmp ( envline , \"DEBUG\" , 5 ) == 0 ) {\n process_dl_debug ( & envline [ 6 ] ) ;\n break ;\n }\n if ( memcmp ( envline , \"AUDIT\" , 5 ) == 0 ) process_dl_audit ( & envline [ 6 ] ) ;\n break ;\n case 7 : if ( memcmp ( envline , \"VERBOSE\" , 7 ) == 0 ) {\n version_info = envline [ 8 ] != '\\0' ;\n break ;\n }\n if ( memcmp ( envline , \"PRELOAD\" , 7 ) == 0 ) {\n preloadlist = & envline [ 8 ] ;\n break ;\n }\n if ( memcmp ( envline , \"PROFILE\" , 7 ) == 0 && envline [ 8 ] != '\\0' ) GLRO ( dl_profile ) = & envline [ 8 ] ;\n break ;\n case 8 : if ( memcmp ( envline , \"BIND_NOW\" , 8 ) == 0 ) {\n GLRO ( dl_lazy ) = envline [ 9 ] == '\\0' ;\n break ;\n }\n if ( memcmp ( envline , \"BIND_NOT\" , 8 ) == 0 ) GLRO ( dl_bind_not ) = envline [ 9 ] != '\\0' ;\n break ;\n case 9 : if ( ! __libc_enable_secure && memcmp ( envline , \"SHOW_AUXV\" , 9 ) == 0 ) _dl_show_auxv ( ) ;\n break ;\n case 10 : if ( memcmp ( envline , \"HWCAP_MASK\" , 10 ) == 0 ) GLRO ( dl_hwcap_mask ) = __strtoul_internal ( & envline [ 11 ] , NULL , 0 , 0 ) ;\n break ;\n case 11 : if ( ! __libc_enable_secure && memcmp ( envline , \"ORIGIN_PATH\" , 11 ) == 0 ) GLRO ( dl_origin_path ) = & envline [ 12 ] ;\n break ;\n case 12 : if ( memcmp ( envline , \"LIBRARY_PATH\" , 12 ) == 0 ) {\n library_path = & envline [ 13 ] ;\n break ;\n }\n if ( memcmp ( envline , \"DEBUG_OUTPUT\" , 12 ) == 0 ) {\n debug_output = & envline [ 13 ] ;\n break ;\n }\n if ( ! __libc_enable_secure && memcmp ( envline , \"DYNAMIC_WEAK\" , 12 ) == 0 ) GLRO ( dl_dynamic_weak ) = 1 ;\n break ;\n case 13 : # ifdef EXTRA_LD_ENVVARS_13 EXTRA_LD_ENVVARS_13 # endif if ( ! __libc_enable_secure && memcmp ( envline , \"USE_LOAD_BIAS\" , 13 ) == 0 ) {\n GLRO ( dl_use_load_bias ) = envline [ 14 ] == '1' ? - 1 : 0 ;\n break ;\n }\n if ( memcmp ( envline , \"POINTER_GUARD\" , 13 ) == 0 ) GLRO ( dl_pointer_guard ) = envline [ 14 ] != '0' ;\n break ;\n case 14 : if ( ! __libc_enable_secure && memcmp ( envline , \"PROFILE_OUTPUT\" , 14 ) == 0 && envline [ 15 ] != '\\0' ) GLRO ( dl_profile_output ) = & envline [ 15 ] ;\n break ;\n case 16 : if ( memcmp ( envline , \"TRACE_PRELINKING\" , 16 ) == 0 ) {\n mode = trace ;\n GLRO ( dl_verbose ) = 1 ;\n GLRO ( dl_debug_mask ) |= DL_DEBUG_PRELINK ;\n GLRO ( dl_trace_prelink ) = & envline [ 17 ] ;\n }\n break ;\n case 20 : if ( memcmp ( envline , \"TRACE_LOADED_OBJECTS\" , 20 ) == 0 ) mode = trace ;\n break ;\n # ifdef EXTRA_LD_ENVVARS EXTRA_LD_ENVVARS # endif }\n }\n * modep = mode ;\n if ( __builtin_expect ( __libc_enable_secure , 0 ) ) {\n static const char unsecure_envvars [ ] = # ifdef EXTRA_UNSECURE_ENVVARS EXTRA_UNSECURE_ENVVARS # endif UNSECURE_ENVVARS ;\n const char * nextp ;\n nextp = unsecure_envvars ;\n do {\n unsetenv ( nextp ) ;\n nextp = ( char * ) ( strchr ) ( nextp , '\\0' ) + 1 ;\n }\n while ( * nextp != '\\0' ) ;\n if ( __access ( \"/etc/suid-debug\" , F_OK ) != 0 ) {\n unsetenv ( \"MALLOC_CHECK_\" ) ;\n GLRO ( dl_debug_mask ) = 0 ;\n }\n if ( mode != normal ) _exit ( 5 ) ;\n }\n else if ( any_debug && debug_output != NULL ) {\n # ifdef O_NOFOLLOW const int flags = O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW ;\n # else const int flags = O_WRONLY | O_APPEND | O_CREAT ;\n # endif size_t name_len = strlen ( debug_output ) ;\n char buf [ name_len + 12 ] ;\n char * startp ;\n buf [ name_len + 11 ] = '\\0' ;\n startp = _itoa ( __getpid ( ) , & buf [ name_len + 11 ] , 10 , 0 ) ;\n * -- startp = '.' ;\n startp = memcpy ( startp - name_len , debug_output , name_len ) ;\n GLRO ( dl_debug_fd ) = __open ( startp , flags , DEFFILEMODE ) ;\n if ( GLRO ( dl_debug_fd ) == - 1 ) GLRO ( dl_debug_fd ) = STDOUT_FILENO ;\n }\n }",
        "hash": -5025430721469043309,
        "project": "debian",
        "size": 100,
        "slice": {
            "memcmp": [
                [
                    1,
                    "static void process_envvars ( enum mode * modep ) {\n"
                ],
                [
                    10,
                    " if ( envline [ len ] != '=' ) continue ;\n"
                ],
                [
                    12,
                    " case 4 : if ( memcmp ( envline , \"WARN\" , 4 ) == 0 ) GLRO ( dl_verbose ) = envline [ 5 ] != '\\0' ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void process_envvars ( enum mode * modep ) {\n"
                ],
                [
                    10,
                    " if ( envline [ len ] != '=' ) continue ;\n"
                ],
                [
                    12,
                    " case 4 : if ( memcmp ( envline , \"WARN\" , 4 ) == 0 ) GLRO ( dl_verbose ) = envline [ 5 ] != '\\0' ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void dissect_rsvp_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean e2ei ) {\n guint8 message_type ;\n int session_off , tempfilt_off ;\n rsvp_conversation_info * rsvph ;\n conversation_t * conversation ;\n struct rsvp_request_key request_key , * new_request_key ;\n struct rsvp_request_val * request_val ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n message_type = tvb_get_guint8 ( tvb , 1 ) ;\n rsvph = wmem_new0 ( wmem_packet_scope ( ) , rsvp_conversation_info ) ;\n set_address ( & rsvph -> source , pinfo -> src . type , pinfo -> src . len , pinfo -> src . data ) ;\n set_address ( & rsvph -> destination , pinfo -> dst . type , pinfo -> dst . len , pinfo -> dst . data ) ;\n col_add_str ( pinfo -> cinfo , COL_INFO , val_to_str_ext ( message_type , & message_type_vals_ext , \"Unknown (%u). \" ) ) ;\n if ( message_type == RSVP_MSG_BUNDLE ) {\n col_set_str ( pinfo -> cinfo , COL_INFO , rsvp_bundle_dissect ? \"Component Messages Dissected\" : \"Component Messages Not Dissected\" ) ;\n }\n else {\n find_rsvp_session_tempfilt ( tvb , 0 , & session_off , & tempfilt_off ) ;\n if ( session_off ) col_append_str ( pinfo -> cinfo , COL_INFO , summary_session ( tvb , session_off ) ) ;\n if ( tempfilt_off ) col_append_str ( pinfo -> cinfo , COL_INFO , summary_template ( tvb , tempfilt_off ) ) ;\n }\n dissect_rsvp_msg_tree ( tvb , pinfo , tree , TREE ( TT_RSVP ) , rsvph , e2ei ) ;\n if ( ( message_type == RSVP_MSG_ACK ) || ( message_type == RSVP_MSG_SREFRESH ) || ( message_type == RSVP_MSG_HELLO ) ) return ;\n conversation = find_or_create_conversation ( pinfo ) ;\n memset ( & request_key , 0 , sizeof ( request_key ) ) ;\n request_key . conversation = conversation -> index ;\n request_key . session_type = rsvph -> session_type ;\n switch ( request_key . session_type ) {\n case RSVP_SESSION_TYPE_IPV4 : set_address ( & request_key . u . session_ipv4 . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_ipv4 . protocol = rsvph -> protocol ;\n request_key . u . session_ipv4 . udp_dest_port = rsvph -> udp_dest_port ;\n break ;\n case RSVP_SESSION_TYPE_IPV6 : break ;\n case RSVP_SESSION_TYPE_IPV4_LSP : set_address ( & request_key . u . session_ipv4_lsp . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_ipv4_lsp . udp_dest_port = rsvph -> udp_dest_port ;\n request_key . u . session_ipv4_lsp . ext_tunnel_id = rsvph -> ext_tunnel_id ;\n break ;\n case RSVP_SESSION_TYPE_AGGREGATE_IPV4 : set_address ( & request_key . u . session_agg_ipv4 . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_agg_ipv4 . dscp = rsvph -> dscp ;\n break ;\n case RSVP_SESSION_TYPE_IPV4_UNI : set_address ( & request_key . u . session_ipv4_uni . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_ipv4_uni . udp_dest_port = rsvph -> udp_dest_port ;\n request_key . u . session_ipv4_uni . ext_tunnel_id = rsvph -> ext_tunnel_id ;\n break ;\n case RSVP_SESSION_TYPE_IPV4_E_NNI : set_address ( & request_key . u . session_ipv4_enni . destination , rsvph -> destination . type , rsvph -> destination . len , rsvph -> destination . data ) ;\n request_key . u . session_ipv4_enni . udp_dest_port = rsvph -> udp_dest_port ;\n request_key . u . session_ipv4_enni . ext_tunnel_id = rsvph -> ext_tunnel_id ;\n break ;\n default : proto_tree_add_expert ( tree , pinfo , & ei_rsvp_session_type , tvb , 0 , 0 ) ;\n break ;\n }\n copy_address_wmem ( wmem_file_scope ( ) , & request_key . source_info . source , & rsvph -> source ) ;\n request_key . source_info . udp_source_port = rsvph -> udp_source_port ;\n request_val = ( struct rsvp_request_val * ) g_hash_table_lookup ( rsvp_request_hash , & request_key ) ;\n if ( ! request_val ) {\n new_request_key = ( struct rsvp_request_key * ) wmem_memdup ( wmem_file_scope ( ) , & request_key , sizeof ( struct rsvp_request_key ) ) ;\n request_val = wmem_new ( wmem_file_scope ( ) , struct rsvp_request_val ) ;\n request_val -> value = conversation -> index ;\n g_hash_table_insert ( rsvp_request_hash , new_request_key , request_val ) ;\n }\n tap_queue_packet ( rsvp_tap , pinfo , rsvph ) ;\n }",
        "hash": 2388171415474875762,
        "project": "debian",
        "size": 62,
        "slice": {
            "memset": [
                [
                    1,
                    "static void dissect_rsvp_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean e2ei ) {\n"
                ],
                [
                    23,
                    " if ( ( message_type == RSVP_MSG_ACK ) || ( message_type == RSVP_MSG_SREFRESH ) || ( message_type == RSVP_MSG_HELLO ) ) return ;\n"
                ],
                [
                    25,
                    " memset ( & request_key , 0 , sizeof ( request_key ) ) ;\n"
                ],
                [
                    54,
                    " request_val = ( struct rsvp_request_val * ) g_hash_table_lookup ( rsvp_request_hash , & request_key ) ;\n"
                ],
                [
                    56,
                    " new_request_key = ( struct rsvp_request_key * ) wmem_memdup ( wmem_file_scope ( ) , & request_key , sizeof ( struct rsvp_request_key ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void dissect_rsvp_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean e2ei ) {\n"
                ],
                [
                    23,
                    " if ( ( message_type == RSVP_MSG_ACK ) || ( message_type == RSVP_MSG_SREFRESH ) || ( message_type == RSVP_MSG_HELLO ) ) return ;\n"
                ],
                [
                    25,
                    " memset ( & request_key , 0 , sizeof ( request_key ) ) ;\n"
                ],
                [
                    54,
                    " request_val = ( struct rsvp_request_val * ) g_hash_table_lookup ( rsvp_request_hash , & request_key ) ;\n"
                ],
                [
                    56,
                    " new_request_key = ( struct rsvp_request_key * ) wmem_memdup ( wmem_file_scope ( ) , & request_key , sizeof ( struct rsvp_request_key ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) {\n encoder_sys_t * p_sys = p_enc -> p_sys ;\n block_t * p_block , * p_output_chain = NULL ;\n SchroFrame * p_frame ;\n bool b_go = true ;\n if ( ! p_pic ) {\n if ( ! p_sys -> started || p_sys -> b_eos_pulled ) return NULL ;\n if ( ! p_sys -> b_eos_signalled ) {\n p_sys -> b_eos_signalled = 1 ;\n schro_encoder_end_of_stream ( p_sys -> p_schro ) ;\n }\n }\n else {\n p_sys -> p_format -> interlaced = ! p_pic -> b_progressive ;\n p_sys -> p_format -> top_field_first = p_pic -> b_top_field_first ;\n if ( p_sys -> b_auto_field_coding ) schro_encoder_setting_set_double ( p_sys -> p_schro , \"interlaced_coding\" , ! p_pic -> b_progressive ) ;\n }\n if ( ! p_sys -> started ) {\n date_t date ;\n if ( p_pic -> format . i_chroma != p_enc -> fmt_in . i_codec ) {\n char chroma_in [ 5 ] , chroma_out [ 5 ] ;\n vlc_fourcc_to_char ( p_pic -> format . i_chroma , chroma_in ) ;\n chroma_in [ 4 ] = '\\0' ;\n chroma_out [ 4 ] = '\\0' ;\n vlc_fourcc_to_char ( p_enc -> fmt_in . i_codec , chroma_out ) ;\n msg_Warn ( p_enc , \"Resetting chroma from %s to %s\" , chroma_out , chroma_in ) ;\n if ( ! SetEncChromaFormat ( p_enc , p_pic -> format . i_chroma ) ) {\n msg_Err ( p_enc , \"Could not reset chroma format to %s\" , chroma_in ) ;\n return NULL ;\n }\n }\n date_Init ( & date , p_enc -> fmt_in . video . i_frame_rate , p_enc -> fmt_in . video . i_frame_rate_base ) ;\n date_Increment ( & date , 1 ) ;\n p_sys -> i_pts_offset = date_Get ( & date ) ;\n if ( schro_encoder_setting_get_double ( p_sys -> p_schro , \"interlaced_coding\" ) > 0.0 ) {\n date_Set ( & date , 0 ) ;\n date_Increment ( & date , 1 ) ;\n p_sys -> i_field_time = date_Get ( & date ) / 2 ;\n }\n schro_video_format_set_std_signal_range ( p_sys -> p_format , SCHRO_SIGNAL_RANGE_8BIT_VIDEO ) ;\n schro_encoder_set_video_format ( p_sys -> p_schro , p_sys -> p_format ) ;\n schro_encoder_start ( p_sys -> p_schro ) ;\n p_sys -> started = 1 ;\n }\n if ( ! p_sys -> b_eos_signalled ) {\n picture_Hold ( p_pic ) ;\n p_frame = CreateSchroFrameFromInputPic ( p_enc , p_pic ) ;\n if ( ! p_frame ) return NULL ;\n schro_encoder_push_frame ( p_sys -> p_schro , p_frame ) ;\n StorePicturePTS ( p_enc , p_sys -> i_input_picnum , p_pic -> date ) ;\n p_sys -> i_input_picnum ++ ;\n p_block = block_Alloc ( 1 ) ;\n if ( ! p_block ) return NULL ;\n p_block -> i_dts = p_pic -> date - p_sys -> i_pts_offset ;\n block_FifoPut ( p_sys -> p_dts_fifo , p_block ) ;\n p_block = NULL ;\n if ( schro_encoder_setting_get_double ( p_sys -> p_schro , \"interlaced_coding\" ) > 0.0 ) {\n StorePicturePTS ( p_enc , p_sys -> i_input_picnum , p_pic -> date + p_sys -> i_field_time ) ;\n p_sys -> i_input_picnum ++ ;\n p_block = block_Alloc ( 1 ) ;\n if ( ! p_block ) return NULL ;\n p_block -> i_dts = p_pic -> date - p_sys -> i_pts_offset + p_sys -> i_field_time ;\n block_FifoPut ( p_sys -> p_dts_fifo , p_block ) ;\n p_block = NULL ;\n }\n }\n do {\n SchroStateEnum state ;\n state = schro_encoder_wait ( p_sys -> p_schro ) ;\n switch ( state ) {\n case SCHRO_STATE_NEED_FRAME : b_go = false ;\n break ;\n case SCHRO_STATE_AGAIN : break ;\n case SCHRO_STATE_END_OF_STREAM : p_sys -> b_eos_pulled = 1 ;\n b_go = false ;\n break ;\n case SCHRO_STATE_HAVE_BUFFER : {\n SchroBuffer * p_enc_buf ;\n uint32_t u_pic_num ;\n int i_presentation_frame ;\n p_enc_buf = schro_encoder_pull ( p_sys -> p_schro , & i_presentation_frame ) ;\n p_block = block_Alloc ( p_enc_buf -> length ) ;\n if ( ! p_block ) return NULL ;\n memcpy ( p_block -> p_buffer , p_enc_buf -> data , p_enc_buf -> length ) ;\n schro_buffer_unref ( p_enc_buf ) ;\n if ( 0 == p_block -> p_buffer [ 4 ] ) {\n p_block -> i_flags |= BLOCK_FLAG_TYPE_I ;\n if ( ! p_enc -> fmt_out . p_extra ) {\n const uint8_t eos [ ] = {\n 'B' , 'B' , 'C' , 'D' , 0x10 , 0 , 0 , 0 , 13 , 0 , 0 , 0 , 0 }\n ;\n uint32_t len = GetDWBE ( p_block -> p_buffer + 5 ) ;\n p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ;\n if ( ! p_enc -> fmt_out . p_extra ) return NULL ;\n memcpy ( p_enc -> fmt_out . p_extra , p_block -> p_buffer , len ) ;\n memcpy ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len , eos , sizeof ( eos ) ) ;\n SetDWBE ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len + sizeof ( eos ) - 4 , len ) ;\n p_enc -> fmt_out . i_extra = len + sizeof ( eos ) ;\n }\n }\n if ( ReadDiracPictureNumber ( & u_pic_num , p_block ) ) {\n block_t * p_dts_block = block_FifoGet ( p_sys -> p_dts_fifo ) ;\n p_block -> i_dts = p_dts_block -> i_dts ;\n p_block -> i_pts = GetPicturePTS ( p_enc , u_pic_num ) ;\n block_Release ( p_dts_block ) ;\n block_ChainAppend ( & p_output_chain , p_block ) ;\n }\n else {\n block_ChainAppend ( & p_output_chain , p_block ) ;\n }\n break ;\n }\n default : break ;\n }\n }\n while ( b_go ) ;\n return p_output_chain ;\n }",
        "hash": 2125998987781803371,
        "project": "debian",
        "size": 118,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) {\n"
                ],
                [
                    81,
                    " p_enc_buf = schro_encoder_pull ( p_sys -> p_schro , & i_presentation_frame ) ;\n"
                ],
                [
                    82,
                    " p_block = block_Alloc ( p_enc_buf -> length ) ;\n"
                ],
                [
                    83,
                    " if ( ! p_block ) return NULL ;\n"
                ],
                [
                    84,
                    " memcpy ( p_block -> p_buffer , p_enc_buf -> data , p_enc_buf -> length ) ;\n"
                ],
                [
                    85,
                    " schro_buffer_unref ( p_enc_buf ) ;\n"
                ],
                [
                    86,
                    " if ( 0 == p_block -> p_buffer [ 4 ] ) {\n"
                ],
                [
                    88,
                    " if ( ! p_enc -> fmt_out . p_extra ) {\n"
                ],
                [
                    92,
                    " uint32_t len = GetDWBE ( p_block -> p_buffer + 5 ) ;\n"
                ],
                [
                    94,
                    " if ( ! p_enc -> fmt_out . p_extra ) return NULL ;\n"
                ],
                [
                    95,
                    " memcpy ( p_enc -> fmt_out . p_extra , p_block -> p_buffer , len ) ;\n"
                ],
                [
                    96,
                    " memcpy ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len , eos , sizeof ( eos ) ) ;\n"
                ],
                [
                    97,
                    " SetDWBE ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len + sizeof ( eos ) - 4 , len ) ;\n"
                ],
                [
                    101,
                    " if ( ReadDiracPictureNumber ( & u_pic_num , p_block ) ) {\n"
                ],
                [
                    106,
                    " block_ChainAppend ( & p_output_chain , p_block ) ;\n"
                ],
                [
                    109,
                    " block_ChainAppend ( & p_output_chain , p_block ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) {\n"
                ],
                [
                    88,
                    " if ( ! p_enc -> fmt_out . p_extra ) {\n"
                ],
                [
                    92,
                    " uint32_t len = GetDWBE ( p_block -> p_buffer + 5 ) ;\n"
                ],
                [
                    93,
                    " p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ;\n"
                ],
                [
                    94,
                    " if ( ! p_enc -> fmt_out . p_extra ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) {\n"
                ],
                [
                    81,
                    " p_enc_buf = schro_encoder_pull ( p_sys -> p_schro , & i_presentation_frame ) ;\n"
                ],
                [
                    82,
                    " p_block = block_Alloc ( p_enc_buf -> length ) ;\n"
                ],
                [
                    83,
                    " if ( ! p_block ) return NULL ;\n"
                ],
                [
                    84,
                    " memcpy ( p_block -> p_buffer , p_enc_buf -> data , p_enc_buf -> length ) ;\n"
                ],
                [
                    85,
                    " schro_buffer_unref ( p_enc_buf ) ;\n"
                ],
                [
                    86,
                    " if ( 0 == p_block -> p_buffer [ 4 ] ) {\n"
                ],
                [
                    88,
                    " if ( ! p_enc -> fmt_out . p_extra ) {\n"
                ],
                [
                    92,
                    " uint32_t len = GetDWBE ( p_block -> p_buffer + 5 ) ;\n"
                ],
                [
                    93,
                    " p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ;\n"
                ],
                [
                    94,
                    " if ( ! p_enc -> fmt_out . p_extra ) return NULL ;\n"
                ],
                [
                    95,
                    " memcpy ( p_enc -> fmt_out . p_extra , p_block -> p_buffer , len ) ;\n"
                ],
                [
                    96,
                    " memcpy ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len , eos , sizeof ( eos ) ) ;\n"
                ],
                [
                    97,
                    " SetDWBE ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len + sizeof ( eos ) - 4 , len ) ;\n"
                ],
                [
                    101,
                    " if ( ReadDiracPictureNumber ( & u_pic_num , p_block ) ) {\n"
                ],
                [
                    106,
                    " block_ChainAppend ( & p_output_chain , p_block ) ;\n"
                ],
                [
                    109,
                    " block_ChainAppend ( & p_output_chain , p_block ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int qemuMonitorTextGetBlockInfo ( qemuMonitorPtr mon , const char * devname , struct qemuDomainDiskInfo * info ) {\n char * reply = NULL ;\n int ret = - 1 ;\n char * dummy ;\n const char * p , * eol ;\n int devnamelen = strlen ( devname ) ;\n int tmp ;\n if ( qemuMonitorHMPCommand ( mon , \"info block\" , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , \"%s\" , _ ( \"info block command failed\" ) ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"\\ninfo \" ) ) {\n qemuReportError ( VIR_ERR_OPERATION_INVALID , \"%s\" , _ ( \"info block not supported by this qemu\" ) ) ;\n goto cleanup ;\n }\n p = reply ;\n while ( * p ) {\n if ( STRPREFIX ( p , QEMU_DRIVE_HOST_PREFIX ) ) p += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n if ( STREQLEN ( p , devname , devnamelen ) && p [ devnamelen ] == ':' && p [ devnamelen + 1 ] == ' ' ) {\n eol = strchr ( p , '\\n' ) ;\n if ( ! eol ) eol = p + strlen ( p ) ;\n p += devnamelen + 2 ;\n while ( * p ) {\n if ( STRPREFIX ( p , \"removable=\" ) ) {\n p += strlen ( \"removable=\" ) ;\n if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading removable: %s\" , p ) ;\n else info -> removable = ( tmp != 0 ) ;\n }\n else if ( STRPREFIX ( p , \"locked=\" ) ) {\n p += strlen ( \"locked=\" ) ;\n if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading locked: %s\" , p ) ;\n else info -> locked = ( tmp != 0 ) ;\n }\n else if ( STRPREFIX ( p , \"tray_open=\" ) ) {\n p += strlen ( \"tray_open=\" ) ;\n if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading tray_open: %s\" , p ) ;\n else info -> tray_open = ( tmp != 0 ) ;\n }\n else {\n }\n p = strchr ( p , ' ' ) ;\n if ( ! p || p >= eol ) break ;\n p ++ ;\n }\n ret = 0 ;\n goto cleanup ;\n }\n p = strchr ( p , '\\n' ) ;\n if ( ! p ) break ;\n p ++ ;\n }\n qemuReportError ( VIR_ERR_INVALID_ARG , _ ( \"no info for device '%s'\" ) , devname ) ;\n cleanup : VIR_FREE ( reply ) ;\n return ret ;\n }",
        "hash": 378220832151730865,
        "project": "debian",
        "size": 55,
        "slice": {
            "strchr": [
                [
                    1,
                    "int qemuMonitorTextGetBlockInfo ( qemuMonitorPtr mon , const char * devname , struct qemuDomainDiskInfo * info ) {\n"
                ],
                [
                    19,
                    " if ( STREQLEN ( p , devname , devnamelen ) && p [ devnamelen ] == ':' && p [ devnamelen + 1 ] == ' ' ) {\n"
                ],
                [
                    20,
                    " eol = strchr ( p , '\\n' ) ;\n"
                ],
                [
                    21,
                    " if ( ! eol ) eol = p + strlen ( p ) ;\n"
                ],
                [
                    22,
                    " p += devnamelen + 2 ;\n"
                ],
                [
                    23,
                    " while ( * p ) {\n"
                ],
                [
                    26,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading removable: %s\" , p ) ;\n"
                ],
                [
                    31,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading locked: %s\" , p ) ;\n"
                ],
                [
                    34,
                    " else if ( STRPREFIX ( p , \"tray_open=\" ) ) {\n"
                ],
                [
                    36,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading tray_open: %s\" , p ) ;\n"
                ],
                [
                    41,
                    " p = strchr ( p , ' ' ) ;\n"
                ],
                [
                    42,
                    " if ( ! p || p >= eol ) break ;\n"
                ],
                [
                    48,
                    " p = strchr ( p , '\\n' ) ;\n"
                ],
                [
                    49,
                    " if ( ! p ) break ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "int qemuMonitorTextGetBlockInfo ( qemuMonitorPtr mon , const char * devname , struct qemuDomainDiskInfo * info ) {\n"
                ],
                [
                    6,
                    " int devnamelen = strlen ( devname ) ;\n"
                ],
                [
                    18,
                    " if ( STRPREFIX ( p , QEMU_DRIVE_HOST_PREFIX ) ) p += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n"
                ],
                [
                    19,
                    " if ( STREQLEN ( p , devname , devnamelen ) && p [ devnamelen ] == ':' && p [ devnamelen + 1 ] == ' ' ) {\n"
                ],
                [
                    20,
                    " eol = strchr ( p , '\\n' ) ;\n"
                ],
                [
                    21,
                    " if ( ! eol ) eol = p + strlen ( p ) ;\n"
                ],
                [
                    22,
                    " p += devnamelen + 2 ;\n"
                ],
                [
                    24,
                    " if ( STRPREFIX ( p , \"removable=\" ) ) {\n"
                ],
                [
                    25,
                    " p += strlen ( \"removable=\" ) ;\n"
                ],
                [
                    26,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading removable: %s\" , p ) ;\n"
                ],
                [
                    29,
                    " else if ( STRPREFIX ( p , \"locked=\" ) ) {\n"
                ],
                [
                    30,
                    " p += strlen ( \"locked=\" ) ;\n"
                ],
                [
                    31,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading locked: %s\" , p ) ;\n"
                ],
                [
                    34,
                    " else if ( STRPREFIX ( p , \"tray_open=\" ) ) {\n"
                ],
                [
                    35,
                    " p += strlen ( \"tray_open=\" ) ;\n"
                ],
                [
                    36,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading tray_open: %s\" , p ) ;\n"
                ],
                [
                    42,
                    " if ( ! p || p >= eol ) break ;\n"
                ],
                [
                    52,
                    " qemuReportError ( VIR_ERR_INVALID_ARG , _ ( \"no info for device '%s'\" ) , devname ) ;\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "int qemuMonitorTextGetBlockInfo ( qemuMonitorPtr mon , const char * devname , struct qemuDomainDiskInfo * info ) {\n"
                ],
                [
                    2,
                    " char * reply = NULL ;\n"
                ],
                [
                    8,
                    " if ( qemuMonitorHMPCommand ( mon , \"info block\" , & reply ) < 0 ) {\n"
                ],
                [
                    12,
                    " if ( strstr ( reply , \"\\ninfo \" ) ) {\n"
                ],
                [
                    13,
                    " qemuReportError ( VIR_ERR_OPERATION_INVALID , \"%s\" , _ ( \"info block not supported by this qemu\" ) ) ;\n"
                ],
                [
                    16,
                    " p = reply ;\n"
                ],
                [
                    17,
                    " while ( * p ) {\n"
                ],
                [
                    53,
                    " cleanup : VIR_FREE ( reply ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int qemuMonitorTextGetBlockInfo ( qemuMonitorPtr mon , const char * devname , struct qemuDomainDiskInfo * info ) {\n"
                ],
                [
                    2,
                    " char * reply = NULL ;\n"
                ],
                [
                    6,
                    " int devnamelen = strlen ( devname ) ;\n"
                ],
                [
                    8,
                    " if ( qemuMonitorHMPCommand ( mon , \"info block\" , & reply ) < 0 ) {\n"
                ],
                [
                    12,
                    " if ( strstr ( reply , \"\\ninfo \" ) ) {\n"
                ],
                [
                    13,
                    " qemuReportError ( VIR_ERR_OPERATION_INVALID , \"%s\" , _ ( \"info block not supported by this qemu\" ) ) ;\n"
                ],
                [
                    16,
                    " p = reply ;\n"
                ],
                [
                    17,
                    " while ( * p ) {\n"
                ],
                [
                    18,
                    " if ( STRPREFIX ( p , QEMU_DRIVE_HOST_PREFIX ) ) p += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n"
                ],
                [
                    19,
                    " if ( STREQLEN ( p , devname , devnamelen ) && p [ devnamelen ] == ':' && p [ devnamelen + 1 ] == ' ' ) {\n"
                ],
                [
                    20,
                    " eol = strchr ( p , '\\n' ) ;\n"
                ],
                [
                    21,
                    " if ( ! eol ) eol = p + strlen ( p ) ;\n"
                ],
                [
                    22,
                    " p += devnamelen + 2 ;\n"
                ],
                [
                    23,
                    " while ( * p ) {\n"
                ],
                [
                    24,
                    " if ( STRPREFIX ( p , \"removable=\" ) ) {\n"
                ],
                [
                    25,
                    " p += strlen ( \"removable=\" ) ;\n"
                ],
                [
                    26,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading removable: %s\" , p ) ;\n"
                ],
                [
                    29,
                    " else if ( STRPREFIX ( p , \"locked=\" ) ) {\n"
                ],
                [
                    30,
                    " p += strlen ( \"locked=\" ) ;\n"
                ],
                [
                    31,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading locked: %s\" , p ) ;\n"
                ],
                [
                    34,
                    " else if ( STRPREFIX ( p , \"tray_open=\" ) ) {\n"
                ],
                [
                    35,
                    " p += strlen ( \"tray_open=\" ) ;\n"
                ],
                [
                    36,
                    " if ( virStrToLong_i ( p , & dummy , 10 , & tmp ) == - 1 ) VIR_DEBUG ( \"error reading tray_open: %s\" , p ) ;\n"
                ],
                [
                    41,
                    " p = strchr ( p , ' ' ) ;\n"
                ],
                [
                    42,
                    " if ( ! p || p >= eol ) break ;\n"
                ],
                [
                    48,
                    " p = strchr ( p , '\\n' ) ;\n"
                ],
                [
                    49,
                    " if ( ! p ) break ;\n"
                ],
                [
                    52,
                    " qemuReportError ( VIR_ERR_INVALID_ARG , _ ( \"no info for device '%s'\" ) , devname ) ;\n"
                ],
                [
                    53,
                    " cleanup : VIR_FREE ( reply ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) {\n struct berval * * ret = NULL ;\n int currkvno ;\n int num_versions = 1 ;\n int i , j , last ;\n krb5_error_code err = 0 ;\n krb5_key_data * key_data ;\n if ( n_key_data <= 0 ) return NULL ;\n key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ;\n if ( key_data_in == NULL ) goto cleanup ;\n memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ;\n for ( i = 0 ;\n i < n_key_data ;\n i ++ ) {\n if ( key_data [ i ] . key_data_ver == 1 ) {\n key_data [ i ] . key_data_ver = 2 ;\n key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ;\n key_data [ i ] . key_data_length [ 1 ] = 0 ;\n key_data [ i ] . key_data_contents [ 1 ] = NULL ;\n }\n }\n for ( i = 0 ;\n i < n_key_data - 1 ;\n i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;\n ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;\n if ( ret == NULL ) {\n err = ENOMEM ;\n goto cleanup ;\n }\n for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ;\n i < n_key_data ;\n i ++ ) {\n krb5_data * code ;\n if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) {\n ret [ j ] = k5alloc ( sizeof ( struct berval ) , & err ) ;\n if ( ret [ j ] == NULL ) goto cleanup ;\n err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;\n if ( err ) goto cleanup ;\n ret [ j ] -> bv_len = code -> length ;\n ret [ j ] -> bv_val = code -> data ;\n free ( code ) ;\n j ++ ;\n last = i + 1 ;\n currkvno = key_data [ i ] . key_data_kvno ;\n }\n }\n ret [ num_versions ] = NULL ;\n cleanup : free ( key_data ) ;\n if ( err != 0 ) {\n if ( ret != NULL ) {\n for ( i = 0 ;\n i <= num_versions ;\n i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ;\n free ( ret ) ;\n ret = NULL ;\n }\n }\n return ret ;\n }",
        "hash": -4432585791636767127,
        "project": "debian",
        "size": 59,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) {\n"
                ],
                [
                    9,
                    " key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ;\n"
                ],
                [
                    10,
                    " if ( key_data_in == NULL ) goto cleanup ;\n"
                ],
                [
                    11,
                    " memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ;\n"
                ],
                [
                    37,
                    " err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;\n"
                ],
                [
                    48,
                    " cleanup : free ( key_data ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) {\n"
                ],
                [
                    8,
                    " if ( n_key_data <= 0 ) return NULL ;\n"
                ],
                [
                    9,
                    " key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ;\n"
                ],
                [
                    11,
                    " memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ;\n"
                ],
                [
                    36,
                    " if ( ret [ j ] == NULL ) goto cleanup ;\n"
                ],
                [
                    37,
                    " err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;\n"
                ],
                [
                    38,
                    " if ( err ) goto cleanup ;\n"
                ],
                [
                    39,
                    " ret [ j ] -> bv_len = code -> length ;\n"
                ],
                [
                    40,
                    " ret [ j ] -> bv_val = code -> data ;\n"
                ],
                [
                    41,
                    " free ( code ) ;\n"
                ],
                [
                    47,
                    " ret [ num_versions ] = NULL ;\n"
                ],
                [
                    48,
                    " cleanup : free ( key_data ) ;\n"
                ],
                [
                    50,
                    " if ( ret != NULL ) {\n"
                ],
                [
                    53,
                    " i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ;\n"
                ],
                [
                    54,
                    " free ( ret ) ;\n"
                ],
                [
                    58,
                    " return ret ;\n"
                ]
            ],
            "calloc": [
                [
                    1,
                    "static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) {\n"
                ],
                [
                    4,
                    " int num_versions = 1 ;\n"
                ],
                [
                    10,
                    " if ( key_data_in == NULL ) goto cleanup ;\n"
                ],
                [
                    24,
                    " i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;\n"
                ],
                [
                    25,
                    " ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;\n"
                ],
                [
                    26,
                    " if ( ret == NULL ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) {\n"
                ],
                [
                    4,
                    " int num_versions = 1 ;\n"
                ],
                [
                    8,
                    " if ( n_key_data <= 0 ) return NULL ;\n"
                ],
                [
                    9,
                    " key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ;\n"
                ],
                [
                    10,
                    " if ( key_data_in == NULL ) goto cleanup ;\n"
                ],
                [
                    11,
                    " memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ;\n"
                ],
                [
                    24,
                    " i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;\n"
                ],
                [
                    25,
                    " ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;\n"
                ],
                [
                    26,
                    " if ( ret == NULL ) {\n"
                ],
                [
                    36,
                    " if ( ret [ j ] == NULL ) goto cleanup ;\n"
                ],
                [
                    37,
                    " err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;\n"
                ],
                [
                    38,
                    " if ( err ) goto cleanup ;\n"
                ],
                [
                    39,
                    " ret [ j ] -> bv_len = code -> length ;\n"
                ],
                [
                    40,
                    " ret [ j ] -> bv_val = code -> data ;\n"
                ],
                [
                    41,
                    " free ( code ) ;\n"
                ],
                [
                    47,
                    " ret [ num_versions ] = NULL ;\n"
                ],
                [
                    48,
                    " cleanup : free ( key_data ) ;\n"
                ],
                [
                    50,
                    " if ( ret != NULL ) {\n"
                ],
                [
                    53,
                    " i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ;\n"
                ],
                [
                    54,
                    " free ( ret ) ;\n"
                ],
                [
                    58,
                    " return ret ;\n"
                ]
            ]
        }
    },
    {
        "code": "__attribute__ ( ( format ( printf , 2 , 3 ) ) ) static int cmd_submitf ( int id , const char * fmt , ... ) {\n char cmd [ MAX_EXTERNAL_COMMAND_LENGTH ] ;\n const char * command ;\n int len , len2 ;\n va_list ap ;\n command = extcmd_get_name ( id ) ;\n len = snprintf ( cmd , sizeof ( cmd ) - 1 , \"[%lu] %s;\n\" , time ( NULL ) , command ) ;\n if ( len < 0 ) return ERROR ;\n if ( fmt ) {\n va_start ( ap , fmt ) ;\n len2 = vsnprintf ( & cmd [ len ] , sizeof ( cmd ) - len - 1 , fmt , ap ) ;\n va_end ( ap ) ;\n if ( len2 < 0 ) return ERROR ;\n }\n return write_command_to_file ( cmd ) ;\n }",
        "hash": 9173144338563772419,
        "project": "debian",
        "size": 17,
        "slice": {
            "vsnprintf": [
                [
                    1,
                    "__attribute__ ( ( format ( printf , 2 , 3 ) ) ) static int cmd_submitf ( int id , const char * fmt , ... ) {\n"
                ],
                [
                    2,
                    " char cmd [ MAX_EXTERNAL_COMMAND_LENGTH ] ;\n"
                ],
                [
                    10,
                    " if ( fmt ) {\n"
                ],
                [
                    11,
                    " va_start ( ap , fmt ) ;\n"
                ],
                [
                    12,
                    " len2 = vsnprintf ( & cmd [ len ] , sizeof ( cmd ) - len - 1 , fmt , ap ) ;\n"
                ],
                [
                    13,
                    " va_end ( ap ) ;\n"
                ],
                [
                    14,
                    " if ( len2 < 0 ) return ERROR ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "__attribute__ ( ( format ( printf , 2 , 3 ) ) ) static int cmd_submitf ( int id , const char * fmt , ... ) {\n"
                ],
                [
                    2,
                    " char cmd [ MAX_EXTERNAL_COMMAND_LENGTH ] ;\n"
                ],
                [
                    10,
                    " if ( fmt ) {\n"
                ],
                [
                    11,
                    " va_start ( ap , fmt ) ;\n"
                ],
                [
                    12,
                    " len2 = vsnprintf ( & cmd [ len ] , sizeof ( cmd ) - len - 1 , fmt , ap ) ;\n"
                ],
                [
                    13,
                    " va_end ( ap ) ;\n"
                ],
                [
                    14,
                    " if ( len2 < 0 ) return ERROR ;\n"
                ]
            ]
        }
    },
    {
        "code": "static ngx_int_t create_request ( ngx_http_request_t * r ) {\n u_char ch ;\n const char * helper_agent_request_socket_password_data ;\n unsigned int helper_agent_request_socket_password_len ;\n u_char buf [ sizeof ( \"4294967296\" ) + 1 ] ;\n size_t len , size , key_len , val_len ;\n const u_char * app_type_string ;\n size_t app_type_string_len ;\n int server_name_len ;\n ngx_str_t escaped_uri ;\n ngx_str_t * union_station_filters = NULL ;\n void * tmp ;\n ngx_uint_t i , n ;\n ngx_buf_t * b ;\n ngx_chain_t * cl , * body ;\n ngx_list_part_t * part ;\n ngx_table_elt_t * header ;\n ngx_http_script_code_pt code ;\n ngx_http_script_engine_t e , le ;\n ngx_http_core_srv_conf_t * cscf ;\n passenger_loc_conf_t * slcf ;\n passenger_context_t * context ;\n ngx_http_script_len_code_pt lcode ;\n cscf = ngx_http_get_module_srv_conf ( r , ngx_http_core_module ) ;\n slcf = ngx_http_get_module_loc_conf ( r , ngx_http_passenger_module ) ;\n context = ngx_http_get_module_ctx ( r , ngx_http_passenger_module ) ;\n if ( context == NULL ) {\n return NGX_HTTP_INTERNAL_SERVER_ERROR ;\n }\n app_type_string = ( const u_char * ) pp_get_app_type_name ( context -> app_type ) ;\n app_type_string_len = strlen ( ( const char * ) app_type_string ) + 1 ;\n escaped_uri . len = * ngx_escape_uri ( NULL , r -> uri . data , r -> uri . len , NGX_ESCAPE_URI ) + r -> uri . len ;\n escaped_uri . data = ngx_pnalloc ( r -> pool , escaped_uri . len + 1 ) ;\n escaped_uri . data [ escaped_uri . len ] = '\\0' ;\n ngx_escape_uri ( escaped_uri . data , r -> uri . data , r -> uri . len , NGX_ESCAPE_URI ) ;\n len = 0 ;\n if ( r -> headers_in . content_length_n >= 0 ) {\n len += sizeof ( \"CONTENT_LENGTH\" ) + uint_to_str ( r -> headers_in . content_length_n , buf , sizeof ( buf ) ) + 1 ;\n }\n len += sizeof ( \"DOCUMENT_ROOT\" ) + context -> public_dir . len + 1 ;\n if ( context -> base_uri . len > 0 ) {\n len += sizeof ( \"SCRIPT_NAME\" ) + context -> base_uri . len + 1 ;\n len += sizeof ( \"RAILS_RELATIVE_URL_ROOT\" ) + context -> base_uri . len + 1 ;\n len += sizeof ( \"PATH_INFO\" ) + escaped_uri . len - context -> base_uri . len + 1 ;\n }\n else {\n len += sizeof ( \"SCRIPT_NAME\" ) + sizeof ( \"\" ) ;\n len += sizeof ( \"PATH_INFO\" ) + escaped_uri . len + 1 ;\n }\n len += sizeof ( \"REQUEST_URI\" ) + escaped_uri . len + 1 ;\n if ( r -> args . len > 0 ) {\n len += 1 + r -> args . len ;\n }\n if ( r -> headers_in . host != NULL ) {\n tmp = memchr ( r -> headers_in . host -> value . data , ':' , r -> headers_in . host -> value . len ) ;\n if ( tmp == NULL ) {\n server_name_len = r -> headers_in . host -> value . len ;\n }\n else {\n server_name_len = ( int ) ( ( const u_char * ) tmp - r -> headers_in . host -> value . data ) ;\n }\n }\n else {\n server_name_len = cscf -> server_name . len ;\n }\n len += sizeof ( \"SERVER_NAME\" ) + server_name_len + 1 ;\n if ( r -> headers_in . content_type != NULL && r -> headers_in . content_type -> value . len > 0 ) {\n len += sizeof ( \"CONTENT_TYPE\" ) + r -> headers_in . content_type -> value . len + 1 ;\n }\n # if ( NGX_HTTP_SSL ) if ( r -> http_connection -> ssl ) {\n len += sizeof ( \"HTTPS\" ) + sizeof ( \"on\" ) ;\n }\n # endif len += slcf -> options_cache . len ;\n len += sizeof ( \"PASSENGER_APP_TYPE\" ) + app_type_string_len ;\n if ( slcf -> union_station_filters != NGX_CONF_UNSET_PTR && slcf -> union_station_filters -> nelts > 0 ) {\n len += sizeof ( \"UNION_STATION_FILTERS\" ) ;\n union_station_filters = ( ngx_str_t * ) slcf -> union_station_filters -> elts ;\n for ( i = 0 ;\n i < slcf -> union_station_filters -> nelts ;\n i ++ ) {\n if ( i != 0 ) {\n len ++ ;\n }\n len += union_station_filters [ i ] . len ;\n }\n len ++ ;\n }\n if ( slcf -> vars_len ) {\n ngx_memzero ( & le , sizeof ( ngx_http_script_engine_t ) ) ;\n ngx_http_script_flush_no_cacheable_variables ( r , slcf -> flushes ) ;\n le . flushed = 1 ;\n le . ip = slcf -> vars_len -> elts ;\n le . request = r ;\n while ( * ( uintptr_t * ) le . ip ) {\n lcode = * ( ngx_http_script_len_code_pt * ) le . ip ;\n key_len = lcode ( & le ) ;\n for ( val_len = 0 ;\n * ( uintptr_t * ) le . ip ;\n val_len += lcode ( & le ) ) {\n lcode = * ( ngx_http_script_len_code_pt * ) le . ip ;\n }\n le . ip += sizeof ( uintptr_t ) ;\n len += key_len + val_len ;\n }\n }\n if ( slcf -> upstream_config . pass_request_headers ) {\n part = & r -> headers_in . headers . part ;\n header = part -> elts ;\n for ( i = 0 ;\n ;\n i ++ ) {\n if ( i >= part -> nelts ) {\n if ( part -> next == NULL ) {\n break ;\n }\n part = part -> next ;\n header = part -> elts ;\n i = 0 ;\n }\n if ( ! header_is_transfer_encoding ( & header [ i ] . key ) ) {\n len += sizeof ( \"HTTP_\" ) - 1 + header [ i ] . key . len + 1 + header [ i ] . value . len + 1 ;\n }\n }\n }\n helper_agent_request_socket_password_data = pp_agents_starter_get_request_socket_password ( pp_agents_starter , & helper_agent_request_socket_password_len ) ;\n size = helper_agent_request_socket_password_len + len + 10 + 1 + 1 ;\n b = ngx_create_temp_buf ( r -> pool , size ) ;\n if ( b == NULL ) {\n return NGX_ERROR ;\n }\n cl = ngx_alloc_chain_link ( r -> pool ) ;\n if ( cl == NULL ) {\n return NGX_ERROR ;\n }\n cl -> buf = b ;\n b -> last = ngx_copy ( b -> last , helper_agent_request_socket_password_data , helper_agent_request_socket_password_len ) ;\n b -> last = ngx_snprintf ( b -> last , 10 , \"%ui\" , len ) ;\n * b -> last ++ = ( u_char ) ':' ;\n if ( r -> headers_in . content_length_n >= 0 ) {\n b -> last = ngx_copy ( b -> last , \"CONTENT_LENGTH\" , sizeof ( \"CONTENT_LENGTH\" ) ) ;\n b -> last = ngx_snprintf ( b -> last , 10 , \"%O\" , r -> headers_in . content_length_n ) ;\n * b -> last ++ = ( u_char ) 0 ;\n }\n b -> last = ngx_copy ( b -> last , \"DOCUMENT_ROOT\" , sizeof ( \"DOCUMENT_ROOT\" ) ) ;\n b -> last = ngx_copy ( b -> last , context -> public_dir . data , context -> public_dir . len + 1 ) ;\n if ( context -> base_uri . len > 0 ) {\n b -> last = ngx_copy ( b -> last , \"SCRIPT_NAME\" , sizeof ( \"SCRIPT_NAME\" ) ) ;\n b -> last = ngx_copy ( b -> last , context -> base_uri . data , context -> base_uri . len + 1 ) ;\n b -> last = ngx_copy ( b -> last , \"RAILS_RELATIVE_URL_ROOT\" , sizeof ( \"RAILS_RELATIVE_URL_ROOT\" ) ) ;\n b -> last = ngx_copy ( b -> last , context -> base_uri . data , context -> base_uri . len + 1 ) ;\n b -> last = ngx_copy ( b -> last , \"PATH_INFO\" , sizeof ( \"PATH_INFO\" ) ) ;\n b -> last = ngx_copy ( b -> last , escaped_uri . data + context -> base_uri . len , escaped_uri . len - context -> base_uri . len ) ;\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n }\n else {\n b -> last = ngx_copy ( b -> last , \"SCRIPT_NAME\" , sizeof ( \"SCRIPT_NAME\" ) ) ;\n b -> last = ngx_copy ( b -> last , \"\" , sizeof ( \"\" ) ) ;\n b -> last = ngx_copy ( b -> last , \"PATH_INFO\" , sizeof ( \"PATH_INFO\" ) ) ;\n b -> last = ngx_copy ( b -> last , escaped_uri . data , escaped_uri . len ) ;\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n }\n b -> last = ngx_copy ( b -> last , \"REQUEST_URI\" , sizeof ( \"REQUEST_URI\" ) ) ;\n b -> last = ngx_copy ( b -> last , escaped_uri . data , escaped_uri . len ) ;\n if ( r -> args . len > 0 ) {\n b -> last = ngx_copy ( b -> last , \"?\" , 1 ) ;\n b -> last = ngx_copy ( b -> last , r -> args . data , r -> args . len ) ;\n }\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n b -> last = ngx_copy ( b -> last , \"SERVER_NAME\" , sizeof ( \"SERVER_NAME\" ) ) ;\n if ( r -> headers_in . host != NULL ) {\n b -> last = ngx_copy ( b -> last , r -> headers_in . host -> value . data , server_name_len ) ;\n }\n else {\n b -> last = ngx_copy ( b -> last , cscf -> server_name . data , server_name_len ) ;\n }\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n if ( r -> headers_in . content_type != NULL && r -> headers_in . content_type -> value . len > 0 ) {\n b -> last = ngx_copy ( b -> last , \"CONTENT_TYPE\" , sizeof ( \"CONTENT_TYPE\" ) ) ;\n b -> last = ngx_copy ( b -> last , r -> headers_in . content_type -> value . data , r -> headers_in . content_type -> value . len ) ;\n b -> last = ngx_copy ( b -> last , \"\" , 1 ) ;\n }\n # if ( NGX_HTTP_SSL ) if ( r -> http_connection -> ssl ) {\n b -> last = ngx_copy ( b -> last , \"HTTPS\" , sizeof ( \"HTTPS\" ) ) ;\n b -> last = ngx_copy ( b -> last , \"on\" , sizeof ( \"on\" ) ) ;\n }\n # endif b -> last = ngx_copy ( b -> last , slcf -> options_cache . data , slcf -> options_cache . len ) ;\n b -> last = ngx_copy ( b -> last , \"PASSENGER_APP_TYPE\" , sizeof ( \"PASSENGER_APP_TYPE\" ) ) ;\n b -> last = ngx_copy ( b -> last , app_type_string , app_type_string_len ) ;\n if ( slcf -> union_station_filters != NGX_CONF_UNSET_PTR && slcf -> union_station_filters -> nelts > 0 ) {\n b -> last = ngx_copy ( b -> last , \"UNION_STATION_FILTERS\" , sizeof ( \"UNION_STATION_FILTERS\" ) ) ;\n for ( i = 0 ;\n i < slcf -> union_station_filters -> nelts ;\n i ++ ) {\n if ( i != 0 ) {\n b -> last = ngx_copy ( b -> last , \"\\1\" , 1 ) ;\n }\n b -> last = ngx_copy ( b -> last , union_station_filters [ i ] . data , union_station_filters [ i ] . len ) ;\n }\n b -> last = ngx_copy ( b -> last , \"\\0\" , 1 ) ;\n }\n if ( slcf -> vars_len ) {\n ngx_memzero ( & e , sizeof ( ngx_http_script_engine_t ) ) ;\n e . ip = slcf -> vars -> elts ;\n e . pos = b -> last ;\n e . request = r ;\n e . flushed = 1 ;\n le . ip = slcf -> vars_len -> elts ;\n while ( * ( uintptr_t * ) le . ip ) {\n lcode = * ( ngx_http_script_len_code_pt * ) le . ip ;\n ( void ) lcode ( & le ) ;\n for ( val_len = 0 ;\n * ( uintptr_t * ) le . ip ;\n val_len += lcode ( & le ) ) {\n lcode = * ( ngx_http_script_len_code_pt * ) le . ip ;\n }\n le . ip += sizeof ( uintptr_t ) ;\n while ( * ( uintptr_t * ) e . ip ) {\n code = * ( ngx_http_script_code_pt * ) e . ip ;\n code ( ( ngx_http_script_engine_t * ) & e ) ;\n }\n e . ip += sizeof ( uintptr_t ) ;\n }\n b -> last = e . pos ;\n }\n if ( slcf -> upstream_config . pass_request_headers ) {\n part = & r -> headers_in . headers . part ;\n header = part -> elts ;\n for ( i = 0 ;\n ;\n i ++ ) {\n if ( i >= part -> nelts ) {\n if ( part -> next == NULL ) {\n break ;\n }\n part = part -> next ;\n header = part -> elts ;\n i = 0 ;\n }\n if ( header_is_transfer_encoding ( & header [ i ] . key ) ) {\n continue ;\n }\n b -> last = ngx_cpymem ( b -> last , \"HTTP_\" , sizeof ( \"HTTP_\" ) - 1 ) ;\n for ( n = 0 ;\n n < header [ i ] . key . len ;\n n ++ ) {\n ch = header [ i ] . key . data [ n ] ;\n if ( ch >= 'a' && ch <= 'z' ) {\n ch &= ~ 0x20 ;\n }\n else if ( ch == '-' ) {\n ch = '_' ;\n }\n * b -> last ++ = ch ;\n }\n * b -> last ++ = ( u_char ) 0 ;\n b -> last = ngx_copy ( b -> last , header [ i ] . value . data , header [ i ] . value . len ) ;\n * b -> last ++ = ( u_char ) 0 ;\n }\n }\n * b -> last ++ = ( u_char ) ',' ;\n if ( slcf -> upstream_config . pass_request_body ) {\n body = r -> upstream -> request_bufs ;\n r -> upstream -> request_bufs = cl ;\n while ( body ) {\n b = ngx_alloc_buf ( r -> pool ) ;\n if ( b == NULL ) {\n return NGX_ERROR ;\n }\n ngx_memcpy ( b , body -> buf , sizeof ( ngx_buf_t ) ) ;\n cl -> next = ngx_alloc_chain_link ( r -> pool ) ;\n if ( cl -> next == NULL ) {\n return NGX_ERROR ;\n }\n cl = cl -> next ;\n cl -> buf = b ;\n body = body -> next ;\n }\n b -> flush = 1 ;\n }\n else {\n r -> upstream -> request_bufs = cl ;\n }\n cl -> next = NULL ;\n return NGX_OK ;\n }",
        "hash": 3766491362463647945,
        "project": "debian",
        "size": 285,
        "slice": {
            "memchr": [
                [
                    1,
                    "static ngx_int_t create_request ( ngx_http_request_t * r ) {\n"
                ],
                [
                    54,
                    " if ( r -> headers_in . host != NULL ) {\n"
                ],
                [
                    55,
                    " tmp = memchr ( r -> headers_in . host -> value . data , ':' , r -> headers_in . host -> value . len ) ;\n"
                ],
                [
                    56,
                    " if ( tmp == NULL ) {\n"
                ],
                [
                    57,
                    " server_name_len = r -> headers_in . host -> value . len ;\n"
                ],
                [
                    60,
                    " server_name_len = ( int ) ( ( const u_char * ) tmp - r -> headers_in . host -> value . data ) ;\n"
                ],
                [
                    171,
                    " b -> last = ngx_copy ( b -> last , r -> headers_in . host -> value . data , server_name_len ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static ngx_int_t create_request ( ngx_http_request_t * r ) {\n"
                ],
                [
                    27,
                    " if ( context == NULL ) {\n"
                ],
                [
                    30,
                    " app_type_string = ( const u_char * ) pp_get_app_type_name ( context -> app_type ) ;\n"
                ],
                [
                    31,
                    " app_type_string_len = strlen ( ( const char * ) app_type_string ) + 1 ;\n"
                ],
                [
                    74,
                    " len += sizeof ( \"PASSENGER_APP_TYPE\" ) + app_type_string_len ;\n"
                ],
                [
                    188,
                    " b -> last = ngx_copy ( b -> last , app_type_string , app_type_string_len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static ngx_int_t create_request ( ngx_http_request_t * r ) {\n"
                ],
                [
                    27,
                    " if ( context == NULL ) {\n"
                ],
                [
                    30,
                    " app_type_string = ( const u_char * ) pp_get_app_type_name ( context -> app_type ) ;\n"
                ],
                [
                    31,
                    " app_type_string_len = strlen ( ( const char * ) app_type_string ) + 1 ;\n"
                ],
                [
                    54,
                    " if ( r -> headers_in . host != NULL ) {\n"
                ],
                [
                    55,
                    " tmp = memchr ( r -> headers_in . host -> value . data , ':' , r -> headers_in . host -> value . len ) ;\n"
                ],
                [
                    56,
                    " if ( tmp == NULL ) {\n"
                ],
                [
                    57,
                    " server_name_len = r -> headers_in . host -> value . len ;\n"
                ],
                [
                    60,
                    " server_name_len = ( int ) ( ( const u_char * ) tmp - r -> headers_in . host -> value . data ) ;\n"
                ],
                [
                    74,
                    " len += sizeof ( \"PASSENGER_APP_TYPE\" ) + app_type_string_len ;\n"
                ],
                [
                    171,
                    " b -> last = ngx_copy ( b -> last , r -> headers_in . host -> value . data , server_name_len ) ;\n"
                ],
                [
                    188,
                    " b -> last = ngx_copy ( b -> last , app_type_string , app_type_string_len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int rfc2231_parse ( struct rfc822_parser_context * ctx , const char * const * * result_r ) {\n ARRAY_TYPE ( const_string ) result ;\n ARRAY ( struct rfc2231_parameter ) rfc2231_params_arr ;\n struct rfc2231_parameter rfc2231_param ;\n const struct rfc2231_parameter * rfc2231_params ;\n const char * key , * value , * p , * p2 ;\n string_t * str ;\n unsigned int i , j , count , next , next_idx ;\n bool ok , have_extended , broken = FALSE ;\n int ret ;\n i_zero ( & rfc2231_param ) ;\n t_array_init ( & result , 8 ) ;\n t_array_init ( & rfc2231_params_arr , 8 ) ;\n while ( ( ret = rfc822_parse_content_param ( ctx , & key , & value ) ) != 0 ) {\n if ( ret < 0 ) {\n broken = TRUE ;\n if ( ctx -> data == ctx -> end ) break ;\n ctx -> data ++ ;\n continue ;\n }\n p = strchr ( key , '*' ) ;\n if ( p != NULL ) {\n p2 = p ;\n if ( p [ 1 ] != '\\0' ) {\n p ++ ;\n rfc2231_param . idx = 0 ;\n for ( ;\n * p >= '0' && * p <= '9' ;\n p ++ ) {\n rfc2231_param . idx = rfc2231_param . idx * 10 + * p - '0' ;\n }\n }\n if ( * p != '*' ) rfc2231_param . extended = FALSE ;\n else {\n rfc2231_param . extended = TRUE ;\n p ++ ;\n }\n if ( * p != '\\0' ) p = NULL ;\n else {\n rfc2231_param . key = t_strdup_until ( key , p2 ) ;\n rfc2231_param . value = value ;\n array_append ( & rfc2231_params_arr , & rfc2231_param , 1 ) ;\n }\n }\n if ( p == NULL ) {\n array_append ( & result , & key , 1 ) ;\n array_append ( & result , & value , 1 ) ;\n }\n }\n if ( array_count ( & rfc2231_params_arr ) == 0 ) {\n array_append_zero ( & result ) ;\n * result_r = array_idx ( & result , 0 ) ;\n return broken ? - 1 : 0 ;\n }\n array_sort ( & rfc2231_params_arr , rfc2231_parameter_cmp ) ;\n rfc2231_params = array_get ( & rfc2231_params_arr , & count ) ;\n str = t_str_new ( 64 ) ;\n for ( i = 0 ;\n i < count ;\n i = next ) {\n ok = TRUE ;\n have_extended = FALSE ;\n next_idx = 0 ;\n for ( j = i ;\n j < count ;\n j ++ ) {\n if ( strcasecmp ( rfc2231_params [ i ] . key , rfc2231_params [ j ] . key ) != 0 ) break ;\n if ( rfc2231_params [ j ] . idx != next_idx ) {\n ok = FALSE ;\n }\n if ( rfc2231_params [ j ] . extended ) have_extended = TRUE ;\n next_idx ++ ;\n }\n next = j ;\n if ( ! ok ) {\n for ( j = i ;\n j < next ;\n j ++ ) {\n key = t_strdup_printf ( rfc2231_params [ j ] . extended ? \"%s*%u*\" : \"%s*%u\" , rfc2231_params [ j ] . key , rfc2231_params [ j ] . idx ) ;\n array_append ( & result , & key , 1 ) ;\n array_append ( & result , & rfc2231_params [ j ] . value , 1 ) ;\n }\n }\n else {\n str_truncate ( str , 0 ) ;\n if ( ! rfc2231_params [ i ] . extended && have_extended ) str_append ( str , \"''\" ) ;\n for ( j = i ;\n j < next ;\n j ++ ) {\n if ( ! rfc2231_params [ j ] . extended && have_extended ) {\n rfc2231_escape ( str , rfc2231_params [ j ] . value ) ;\n }\n else {\n str_append ( str , rfc2231_params [ j ] . value ) ;\n }\n }\n key = rfc2231_params [ i ] . key ;\n if ( have_extended ) key = t_strconcat ( key , \"*\" , NULL ) ;\n value = t_strdup ( str_c ( str ) ) ;\n array_append ( & result , & key , 1 ) ;\n array_append ( & result , & value , 1 ) ;\n }\n }\n array_append_zero ( & result ) ;\n * result_r = array_idx ( & result , 0 ) ;\n return broken ? - 1 : 0 ;\n }",
        "hash": 6562213886666176620,
        "project": "debian",
        "size": 107,
        "slice": {
            "strchr": [
                [
                    1,
                    "int rfc2231_parse ( struct rfc822_parser_context * ctx , const char * const * * result_r ) {\n"
                ],
                [
                    14,
                    " while ( ( ret = rfc822_parse_content_param ( ctx , & key , & value ) ) != 0 ) {\n"
                ],
                [
                    15,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    21,
                    " p = strchr ( key , '*' ) ;\n"
                ],
                [
                    22,
                    " if ( p != NULL ) {\n"
                ],
                [
                    40,
                    " rfc2231_param . key = t_strdup_until ( key , p2 ) ;\n"
                ],
                [
                    46,
                    " array_append ( & result , & key , 1 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int rfc2231_parse ( struct rfc822_parser_context * ctx , const char * const * * result_r ) {\n"
                ],
                [
                    14,
                    " while ( ( ret = rfc822_parse_content_param ( ctx , & key , & value ) ) != 0 ) {\n"
                ],
                [
                    15,
                    " if ( ret < 0 ) {\n"
                ],
                [
                    21,
                    " p = strchr ( key , '*' ) ;\n"
                ],
                [
                    22,
                    " if ( p != NULL ) {\n"
                ],
                [
                    40,
                    " rfc2231_param . key = t_strdup_until ( key , p2 ) ;\n"
                ],
                [
                    46,
                    " array_append ( & result , & key , 1 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int tm_adopt ( char * id , int adoptCmd , pid_t pid ) {\n int rc = TM_SUCCESS ;\n int status , ret ;\n pid_t sid ;\n char * env ;\n struct tcp_chan * chan = NULL ;\n sid = getsid ( pid ) ;\n if ( init_done ) return TM_BADINIT ;\n init_done = 1 ;\n if ( ( tm_jobid = getenv ( \"PBS_JOBID\" ) ) == NULL ) tm_jobid = ( char * ) \"ADOPT JOB\" ;\n tm_jobid_len = strlen ( tm_jobid ) ;\n if ( ( tm_jobcookie = getenv ( \"PBS_JOBCOOKIE\" ) ) == NULL ) tm_jobcookie = ( char * ) \"ADOPT COOKIE\" ;\n tm_jobcookie_len = strlen ( tm_jobcookie ) ;\n tm_jobndid = 0 ;\n tm_jobtid = 0 ;\n if ( ( env = getenv ( \"PBS_MOMPORT\" ) ) == NULL || ( tm_momport = atoi ( env ) ) == 0 ) tm_momport = PBS_MANAGER_SERVICE_PORT ;\n if ( adoptCmd != TM_ADOPT_ALTID && adoptCmd != TM_ADOPT_JOBID ) return TM_EUNKNOWNCMD ;\n if ( startcom ( adoptCmd , TM_NULL_EVENT , & chan ) != DIS_SUCCESS ) return TM_ESYSTEM ;\n if ( diswsi ( chan , sid ) != DIS_SUCCESS ) {\n rc = TM_ENOTCONNECTED ;\n goto tm_adopt_cleanup ;\n }\n if ( diswsi ( chan , pid ) != DIS_SUCCESS ) {\n rc = TM_ENOTCONNECTED ;\n goto tm_adopt_cleanup ;\n }\n if ( diswcs ( chan , id , strlen ( id ) ) != DIS_SUCCESS ) {\n rc = TM_ENOTCONNECTED ;\n goto tm_adopt_cleanup ;\n }\n DIS_tcp_wflush ( chan ) ;\n status = disrsi ( chan , & ret ) ;\n if ( ret != DIS_SUCCESS ) {\n rc = TM_ENOTCONNECTED ;\n goto tm_adopt_cleanup ;\n }\n tm_finalize ( ) ;\n if ( local_conn > - 1 ) {\n close ( local_conn ) ;\n local_conn = - 1 ;\n }\n DIS_tcp_cleanup ( chan ) ;\n return ( status == TM_OKAY ? TM_SUCCESS : TM_ENOTFOUND ) ;\n tm_adopt_cleanup : if ( chan != NULL ) DIS_tcp_cleanup ( chan ) ;\n return rc ;\n }",
        "hash": -2325305888478261876,
        "project": "debian",
        "size": 46,
        "slice": {
            "getenv": [
                [
                    1,
                    "int tm_adopt ( char * id , int adoptCmd , pid_t pid ) {\n"
                ],
                [
                    8,
                    " if ( init_done ) return TM_BADINIT ;\n"
                ],
                [
                    10,
                    " if ( ( tm_jobid = getenv ( \"PBS_JOBID\" ) ) == NULL ) tm_jobid = ( char * ) \"ADOPT JOB\" ;\n"
                ],
                [
                    11,
                    " tm_jobid_len = strlen ( tm_jobid ) ;\n"
                ],
                [
                    12,
                    " if ( ( tm_jobcookie = getenv ( \"PBS_JOBCOOKIE\" ) ) == NULL ) tm_jobcookie = ( char * ) \"ADOPT COOKIE\" ;\n"
                ],
                [
                    13,
                    " tm_jobcookie_len = strlen ( tm_jobcookie ) ;\n"
                ],
                [
                    16,
                    " if ( ( env = getenv ( \"PBS_MOMPORT\" ) ) == NULL || ( tm_momport = atoi ( env ) ) == 0 ) tm_momport = PBS_MANAGER_SERVICE_PORT ;\n"
                ],
                [
                    44,
                    " tm_adopt_cleanup : if ( chan != NULL ) DIS_tcp_cleanup ( chan ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "int tm_adopt ( char * id , int adoptCmd , pid_t pid ) {\n"
                ],
                [
                    8,
                    " if ( init_done ) return TM_BADINIT ;\n"
                ],
                [
                    10,
                    " if ( ( tm_jobid = getenv ( \"PBS_JOBID\" ) ) == NULL ) tm_jobid = ( char * ) \"ADOPT JOB\" ;\n"
                ],
                [
                    11,
                    " tm_jobid_len = strlen ( tm_jobid ) ;\n"
                ],
                [
                    12,
                    " if ( ( tm_jobcookie = getenv ( \"PBS_JOBCOOKIE\" ) ) == NULL ) tm_jobcookie = ( char * ) \"ADOPT COOKIE\" ;\n"
                ],
                [
                    13,
                    " tm_jobcookie_len = strlen ( tm_jobcookie ) ;\n"
                ],
                [
                    18,
                    " if ( startcom ( adoptCmd , TM_NULL_EVENT , & chan ) != DIS_SUCCESS ) return TM_ESYSTEM ;\n"
                ],
                [
                    23,
                    " if ( diswsi ( chan , pid ) != DIS_SUCCESS ) {\n"
                ],
                [
                    27,
                    " if ( diswcs ( chan , id , strlen ( id ) ) != DIS_SUCCESS ) {\n"
                ],
                [
                    28,
                    " rc = TM_ENOTCONNECTED ;\n"
                ],
                [
                    31,
                    " DIS_tcp_wflush ( chan ) ;\n"
                ],
                [
                    32,
                    " status = disrsi ( chan , & ret ) ;\n"
                ],
                [
                    33,
                    " if ( ret != DIS_SUCCESS ) {\n"
                ],
                [
                    44,
                    " tm_adopt_cleanup : if ( chan != NULL ) DIS_tcp_cleanup ( chan ) ;\n"
                ],
                [
                    45,
                    " return rc ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int tm_adopt ( char * id , int adoptCmd , pid_t pid ) {\n"
                ],
                [
                    8,
                    " if ( init_done ) return TM_BADINIT ;\n"
                ],
                [
                    10,
                    " if ( ( tm_jobid = getenv ( \"PBS_JOBID\" ) ) == NULL ) tm_jobid = ( char * ) \"ADOPT JOB\" ;\n"
                ],
                [
                    11,
                    " tm_jobid_len = strlen ( tm_jobid ) ;\n"
                ],
                [
                    12,
                    " if ( ( tm_jobcookie = getenv ( \"PBS_JOBCOOKIE\" ) ) == NULL ) tm_jobcookie = ( char * ) \"ADOPT COOKIE\" ;\n"
                ],
                [
                    13,
                    " tm_jobcookie_len = strlen ( tm_jobcookie ) ;\n"
                ],
                [
                    16,
                    " if ( ( env = getenv ( \"PBS_MOMPORT\" ) ) == NULL || ( tm_momport = atoi ( env ) ) == 0 ) tm_momport = PBS_MANAGER_SERVICE_PORT ;\n"
                ],
                [
                    18,
                    " if ( startcom ( adoptCmd , TM_NULL_EVENT , & chan ) != DIS_SUCCESS ) return TM_ESYSTEM ;\n"
                ],
                [
                    23,
                    " if ( diswsi ( chan , pid ) != DIS_SUCCESS ) {\n"
                ],
                [
                    27,
                    " if ( diswcs ( chan , id , strlen ( id ) ) != DIS_SUCCESS ) {\n"
                ],
                [
                    28,
                    " rc = TM_ENOTCONNECTED ;\n"
                ],
                [
                    31,
                    " DIS_tcp_wflush ( chan ) ;\n"
                ],
                [
                    32,
                    " status = disrsi ( chan , & ret ) ;\n"
                ],
                [
                    33,
                    " if ( ret != DIS_SUCCESS ) {\n"
                ],
                [
                    44,
                    " tm_adopt_cleanup : if ( chan != NULL ) DIS_tcp_cleanup ( chan ) ;\n"
                ],
                [
                    45,
                    " return rc ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * * argv ) {\n int ArgIndex ;\n int NumErrs = 0 ;\n char * Args [ MAXARGS ] ;\n int aindex = 0 ;\n int rc ;\n int pid ;\n char tmpJobID [ PBS_MAXCLTJOBID ] ;\n char JobID [ PBS_MAXCLTJOBID ] ;\n char ServerName [ MAXSERVERNAME ] ;\n int DoBackground = 0 ;\n tmpJobID [ 0 ] = '\\0' ;\n # define GETOPT_ARGS \"bj:\" while ( ( ArgIndex = getopt ( argc , argv , GETOPT_ARGS ) ) != EOF ) {\n switch ( ArgIndex ) {\n case 'b' : DoBackground = 1 ;\n break ;\n case 'j' : strncpy ( tmpJobID , optarg , sizeof ( tmpJobID ) ) ;\n if ( tmpJobID [ PBS_MAXCLTJOBID - 1 ] != '\\0' ) {\n fprintf ( stderr , \"pbs_track: given job ID too large (> %d)\\n\" , PBS_MAXCLTJOBID ) ;\n exit ( - 1 ) ;\n }\n break ;\n default : NumErrs ++ ;\n break ;\n }\n }\n if ( ( NumErrs > 0 ) || ( optind >= argc ) || ( tmpJobID [ 0 ] == '\\0' ) ) {\n static char Usage [ ] = \"USAGE: pbs_track [-j <JOBID>] [-b] -- a.out arg1 arg2 ... argN\\n\" ;\n fprintf ( stderr , \"%s\" , Usage ) ;\n exit ( 2 ) ;\n }\n if ( getenv ( NO_SERVER_SUFFIX ) != NULL ) {\n snprintf ( JobID , sizeof ( JobID ) , \"%s\" , tmpJobID ) ;\n }\n else {\n if ( get_server ( tmpJobID , JobID , sizeof ( JobID ) , ServerName , sizeof ( ServerName ) ) ) {\n fprintf ( stderr , \"pbs_track: illegally formed job identifier: '%s'\\n\" , JobID ) ;\n exit ( 1 ) ;\n }\n }\n aindex = 0 ;\n for ( ;\n optind < argc ;\n optind ++ ) {\n Args [ aindex ++ ] = strdup ( argv [ optind ] ) ;\n printf ( \"Got arg: %s\\n\" , Args [ aindex - 1 ] ) ;\n }\n Args [ aindex ] = NULL ;\n pid = 1 ;\n if ( DoBackground == 1 ) {\n printf ( \"FORKING!\\n\" ) ;\n pid = fork ( ) ;\n }\n if ( ( DoBackground == 0 ) || ( pid == 0 ) ) {\n rc = tm_adopt ( JobID , TM_ADOPT_JOBID , getpid ( ) ) ;\n switch ( rc ) {\n case TM_SUCCESS : break ;\n case TM_ENOTFOUND : fprintf ( stderr , \"pbs_track: MOM could not find job %s\\n\" , JobID ) ;\n break ;\n case TM_ESYSTEM : case TM_ENOTCONNECTED : fprintf ( stderr , \"pbs_track: error occurred while trying to communication with pbs_mom: %s (%d)\\n\" , pbse_to_txt ( rc ) , rc ) ;\n break ;\n default : fprintf ( stderr , \"pbs_track: unexpected error %s (%d) occurred\\n\" , pbse_to_txt ( rc ) , rc ) ;\n break ;\n }\n if ( rc != TM_SUCCESS ) {\n exit ( - 1 ) ;\n }\n if ( execvp ( Args [ 0 ] , Args ) == - 1 ) {\n fprintf ( stderr , \"execvp failed with error %d, message:\\n%s\\n\" , errno , strerror ( errno ) ) ;\n }\n }\n else if ( pid > 0 ) {\n fclose ( stdin ) ;\n fclose ( stdout ) ;\n fclose ( stderr ) ;\n }\n else if ( pid < 0 ) {\n fprintf ( stderr , \"pbs_track: could not fork (%d:%s)\\n\" , errno , strerror ( errno ) ) ;\n }\n exit ( 0 ) ;\n }",
        "hash": 3527528132581042157,
        "project": "debian",
        "size": 81,
        "slice": {
            "strncpy": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    12,
                    " tmpJobID [ 0 ] = '\\0' ;\n"
                ],
                [
                    14,
                    " switch ( ArgIndex ) {\n"
                ],
                [
                    17,
                    " case 'j' : strncpy ( tmpJobID , optarg , sizeof ( tmpJobID ) ) ;\n"
                ],
                [
                    18,
                    " if ( tmpJobID [ PBS_MAXCLTJOBID - 1 ] != '\\0' ) {\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    18,
                    " if ( tmpJobID [ PBS_MAXCLTJOBID - 1 ] != '\\0' ) {\n"
                ],
                [
                    19,
                    " fprintf ( stderr , \"pbs_track: given job ID too large (> %d)\\n\" , PBS_MAXCLTJOBID ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    12,
                    " tmpJobID [ 0 ] = '\\0' ;\n"
                ],
                [
                    14,
                    " switch ( ArgIndex ) {\n"
                ],
                [
                    17,
                    " case 'j' : strncpy ( tmpJobID , optarg , sizeof ( tmpJobID ) ) ;\n"
                ],
                [
                    18,
                    " if ( tmpJobID [ PBS_MAXCLTJOBID - 1 ] != '\\0' ) {\n"
                ],
                [
                    19,
                    " fprintf ( stderr , \"pbs_track: given job ID too large (> %d)\\n\" , PBS_MAXCLTJOBID ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int parse_picture_segment ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) {\n PGSSubContext * ctx = avctx -> priv_data ;\n uint8_t sequence_desc ;\n unsigned int rle_bitmap_len , width , height ;\n uint16_t picture_id ;\n if ( buf_size <= 4 ) return - 1 ;\n buf_size -= 4 ;\n picture_id = bytestream_get_be16 ( & buf ) ;\n buf ++ ;\n sequence_desc = bytestream_get_byte ( & buf ) ;\n if ( ! ( sequence_desc & 0x80 ) ) {\n if ( buf_size > ctx -> pictures [ picture_id ] . rle_remaining_len ) return - 1 ;\n memcpy ( ctx -> pictures [ picture_id ] . rle + ctx -> pictures [ picture_id ] . rle_data_len , buf , buf_size ) ;\n ctx -> pictures [ picture_id ] . rle_data_len += buf_size ;\n ctx -> pictures [ picture_id ] . rle_remaining_len -= buf_size ;\n return 0 ;\n }\n if ( buf_size <= 7 ) return - 1 ;\n buf_size -= 7 ;\n rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2 ;\n width = bytestream_get_be16 ( & buf ) ;\n height = bytestream_get_be16 ( & buf ) ;\n if ( avctx -> width < width || avctx -> height < height ) {\n av_log ( avctx , AV_LOG_ERROR , \"Bitmap dimensions larger than video.\\n\" ) ;\n return - 1 ;\n }\n ctx -> pictures [ picture_id ] . w = width ;\n ctx -> pictures [ picture_id ] . h = height ;\n av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ) ;\n if ( ! ctx -> pictures [ picture_id ] . rle ) return - 1 ;\n memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ) ;\n ctx -> pictures [ picture_id ] . rle_data_len = buf_size ;\n ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size ;\n return 0 ;\n }",
        "hash": 3322961578925988960,
        "project": "debian",
        "size": 35,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int parse_picture_segment ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    8,
                    " picture_id = bytestream_get_be16 ( & buf ) ;\n"
                ],
                [
                    9,
                    " buf ++ ;\n"
                ],
                [
                    10,
                    " sequence_desc = bytestream_get_byte ( & buf ) ;\n"
                ],
                [
                    12,
                    " if ( buf_size > ctx -> pictures [ picture_id ] . rle_remaining_len ) return - 1 ;\n"
                ],
                [
                    13,
                    " memcpy ( ctx -> pictures [ picture_id ] . rle + ctx -> pictures [ picture_id ] . rle_data_len , buf , buf_size ) ;\n"
                ],
                [
                    14,
                    " ctx -> pictures [ picture_id ] . rle_data_len += buf_size ;\n"
                ],
                [
                    15,
                    " ctx -> pictures [ picture_id ] . rle_remaining_len -= buf_size ;\n"
                ],
                [
                    19,
                    " buf_size -= 7 ;\n"
                ],
                [
                    20,
                    " rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2 ;\n"
                ],
                [
                    21,
                    " width = bytestream_get_be16 ( & buf ) ;\n"
                ],
                [
                    22,
                    " height = bytestream_get_be16 ( & buf ) ;\n"
                ],
                [
                    29,
                    " av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ) ;\n"
                ],
                [
                    30,
                    " if ( ! ctx -> pictures [ picture_id ] . rle ) return - 1 ;\n"
                ],
                [
                    31,
                    " memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ) ;\n"
                ],
                [
                    32,
                    " ctx -> pictures [ picture_id ] . rle_data_len = buf_size ;\n"
                ],
                [
                    33,
                    " ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int parse_picture_segment ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) {\n"
                ],
                [
                    8,
                    " picture_id = bytestream_get_be16 ( & buf ) ;\n"
                ],
                [
                    9,
                    " buf ++ ;\n"
                ],
                [
                    10,
                    " sequence_desc = bytestream_get_byte ( & buf ) ;\n"
                ],
                [
                    12,
                    " if ( buf_size > ctx -> pictures [ picture_id ] . rle_remaining_len ) return - 1 ;\n"
                ],
                [
                    13,
                    " memcpy ( ctx -> pictures [ picture_id ] . rle + ctx -> pictures [ picture_id ] . rle_data_len , buf , buf_size ) ;\n"
                ],
                [
                    14,
                    " ctx -> pictures [ picture_id ] . rle_data_len += buf_size ;\n"
                ],
                [
                    15,
                    " ctx -> pictures [ picture_id ] . rle_remaining_len -= buf_size ;\n"
                ],
                [
                    19,
                    " buf_size -= 7 ;\n"
                ],
                [
                    20,
                    " rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2 ;\n"
                ],
                [
                    21,
                    " width = bytestream_get_be16 ( & buf ) ;\n"
                ],
                [
                    22,
                    " height = bytestream_get_be16 ( & buf ) ;\n"
                ],
                [
                    29,
                    " av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ) ;\n"
                ],
                [
                    30,
                    " if ( ! ctx -> pictures [ picture_id ] . rle ) return - 1 ;\n"
                ],
                [
                    31,
                    " memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ) ;\n"
                ],
                [
                    32,
                    " ctx -> pictures [ picture_id ] . rle_data_len = buf_size ;\n"
                ],
                [
                    33,
                    " ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size ;\n"
                ]
            ]
        }
    },
    {
        "code": "static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) {\n Gif_Stream * gfs ;\n Gif_Image * gfi ;\n Gif_Context gfc ;\n int unknown_block_type = 0 ;\n if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ;\n ( void ) gifgetc ( grr ) ;\n ( void ) gifgetc ( grr ) ;\n ( void ) gifgetc ( grr ) ;\n gfs = Gif_NewStream ( ) ;\n gfi = Gif_NewImage ( ) ;\n gfc . stream = gfs ;\n gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ;\n gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ;\n gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ;\n gfc . handler = handler ;\n gfc . gfi = gfi ;\n gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ;\n if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ;\n gfs -> landmark = landmark ;\n GIF_DEBUG ( ( \"\\nGIF \" ) ) ;\n if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ;\n GIF_DEBUG ( ( \"logscrdesc \" ) ) ;\n while ( ! gifeof ( grr ) ) {\n uint8_t block = gifgetbyte ( grr ) ;\n switch ( block ) {\n case ',' : GIF_DEBUG ( ( \"imageread %d \" , gfs -> nimages ) ) ;\n gfi -> identifier = last_name ;\n last_name = 0 ;\n if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ;\n else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) {\n Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ;\n goto done ;\n }\n gfc . gfi = gfi = Gif_NewImage ( ) ;\n if ( ! gfi ) goto done ;\n break ;\n case ';\n' : GIF_DEBUG ( ( \"term\\n\" ) ) ;\n goto done ;\n case '!' : block = gifgetbyte ( grr ) ;\n GIF_DEBUG ( ( \"ext(0x%02X) \" , block ) ) ;\n switch ( block ) {\n case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ;\n break ;\n case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ;\n break ;\n case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ;\n break ;\n case 0xFF : read_application_extension ( & gfc , grr ) ;\n break ;\n default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ;\n break ;\n }\n break ;\n default : if ( ! unknown_block_type ) {\n char buf [ 256 ] ;\n sprintf ( buf , \"unknown block type %d at file offset %u\" , block , grr -> pos - 1 ) ;\n gif_read_error ( & gfc , 1 , buf ) ;\n unknown_block_type = 1 ;\n }\n break ;\n }\n }\n done : if ( gfs && gfi ) {\n Gif_Extension * gfex ;\n gfs -> end_comment = gfi -> comment ;\n gfi -> comment = 0 ;\n gfs -> end_extension_list = gfi -> extension_list ;\n gfi -> extension_list = 0 ;\n for ( gfex = gfs -> end_extension_list ;\n gfex ;\n gfex = gfex -> next ) gfex -> image = NULL ;\n }\n Gif_DeleteImage ( gfi ) ;\n Gif_DeleteArray ( last_name ) ;\n Gif_DeleteArray ( gfc . prefix ) ;\n Gif_DeleteArray ( gfc . suffix ) ;\n Gif_DeleteArray ( gfc . length ) ;\n gfc . gfi = 0 ;\n if ( gfs ) gfs -> errors = gfc . errors [ 1 ] ;\n if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , \"trailing garbage after GIF ignored\" ) ;\n gif_read_error ( & gfc , - 1 , 0 ) ;\n return gfs ;\n }",
        "hash": -9197960073880365676,
        "project": "debian",
        "size": 85,
        "slice": {
            "sprintf": [
                [
                    1,
                    "static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) {\n"
                ],
                [
                    25,
                    " uint8_t block = gifgetbyte ( grr ) ;\n"
                ],
                [
                    56,
                    " default : if ( ! unknown_block_type ) {\n"
                ],
                [
                    57,
                    " char buf [ 256 ] ;\n"
                ],
                [
                    58,
                    " sprintf ( buf , \"unknown block type %d at file offset %u\" , block , grr -> pos - 1 ) ;\n"
                ],
                [
                    59,
                    " gif_read_error ( & gfc , 1 , buf ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) {\n"
                ],
                [
                    25,
                    " uint8_t block = gifgetbyte ( grr ) ;\n"
                ],
                [
                    56,
                    " default : if ( ! unknown_block_type ) {\n"
                ],
                [
                    57,
                    " char buf [ 256 ] ;\n"
                ],
                [
                    58,
                    " sprintf ( buf , \"unknown block type %d at file offset %u\" , block , grr -> pos - 1 ) ;\n"
                ],
                [
                    59,
                    " gif_read_error ( & gfc , 1 , buf ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static char * memdup ( const char * src , size_t buffer_length ) {\n size_t length ;\n bool add = FALSE ;\n char * buffer ;\n if ( buffer_length ) length = buffer_length ;\n else if ( src ) {\n length = strlen ( src ) ;\n add = TRUE ;\n }\n else return strdup ( \"\" ) ;\n buffer = malloc ( length + add ) ;\n if ( ! buffer ) return NULL ;\n memcpy ( buffer , src , length ) ;\n if ( add ) buffer [ length ] = '\\0' ;\n return buffer ;\n }",
        "hash": -4635544075321012404,
        "project": "debian",
        "size": 16,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static char * memdup ( const char * src , size_t buffer_length ) {\n"
                ],
                [
                    5,
                    " if ( buffer_length ) length = buffer_length ;\n"
                ],
                [
                    7,
                    " length = strlen ( src ) ;\n"
                ],
                [
                    12,
                    " if ( ! buffer ) return NULL ;\n"
                ],
                [
                    13,
                    " memcpy ( buffer , src , length ) ;\n"
                ],
                [
                    15,
                    " return buffer ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static char * memdup ( const char * src , size_t buffer_length ) {\n"
                ],
                [
                    6,
                    " else if ( src ) {\n"
                ],
                [
                    7,
                    " length = strlen ( src ) ;\n"
                ],
                [
                    11,
                    " buffer = malloc ( length + add ) ;\n"
                ],
                [
                    13,
                    " memcpy ( buffer , src , length ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static char * memdup ( const char * src , size_t buffer_length ) {\n"
                ],
                [
                    3,
                    " bool add = FALSE ;\n"
                ],
                [
                    5,
                    " if ( buffer_length ) length = buffer_length ;\n"
                ],
                [
                    6,
                    " else if ( src ) {\n"
                ],
                [
                    7,
                    " length = strlen ( src ) ;\n"
                ],
                [
                    8,
                    " add = TRUE ;\n"
                ],
                [
                    11,
                    " buffer = malloc ( length + add ) ;\n"
                ],
                [
                    12,
                    " if ( ! buffer ) return NULL ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static char * memdup ( const char * src , size_t buffer_length ) {\n"
                ],
                [
                    6,
                    " else if ( src ) {\n"
                ],
                [
                    10,
                    " else return strdup ( \"\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static char * memdup ( const char * src , size_t buffer_length ) {\n"
                ],
                [
                    3,
                    " bool add = FALSE ;\n"
                ],
                [
                    5,
                    " if ( buffer_length ) length = buffer_length ;\n"
                ],
                [
                    6,
                    " else if ( src ) {\n"
                ],
                [
                    7,
                    " length = strlen ( src ) ;\n"
                ],
                [
                    8,
                    " add = TRUE ;\n"
                ],
                [
                    10,
                    " else return strdup ( \"\" ) ;\n"
                ],
                [
                    11,
                    " buffer = malloc ( length + add ) ;\n"
                ],
                [
                    12,
                    " if ( ! buffer ) return NULL ;\n"
                ],
                [
                    13,
                    " memcpy ( buffer , src , length ) ;\n"
                ],
                [
                    15,
                    " return buffer ;\n"
                ]
            ]
        }
    },
    {
        "code": "static CURLFORMcode FormAdd ( struct curl_httppost * * httppost , struct curl_httppost * * last_post , va_list params ) {\n FormInfo * first_form , * current_form , * form = NULL ;\n CURLFORMcode return_value = CURL_FORMADD_OK ;\n const char * prevtype = NULL ;\n struct curl_httppost * post = NULL ;\n CURLformoption option ;\n struct curl_forms * forms = NULL ;\n char * array_value = NULL ;\n bool array_state = FALSE ;\n first_form = calloc ( 1 , sizeof ( struct FormInfo ) ) ;\n if ( ! first_form ) return CURL_FORMADD_MEMORY ;\n current_form = first_form ;\n while ( return_value == CURL_FORMADD_OK ) {\n if ( array_state && forms ) {\n option = forms -> option ;\n array_value = ( char * ) forms -> value ;\n forms ++ ;\n if ( CURLFORM_END == option ) {\n array_state = FALSE ;\n continue ;\n }\n }\n else {\n option = va_arg ( params , CURLformoption ) ;\n if ( CURLFORM_END == option ) break ;\n }\n switch ( option ) {\n case CURLFORM_ARRAY : if ( array_state ) return_value = CURL_FORMADD_ILLEGAL_ARRAY ;\n else {\n forms = va_arg ( params , struct curl_forms * ) ;\n if ( forms ) array_state = TRUE ;\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_PTRNAME : # ifdef CURL_DOES_CONVERSIONS # else current_form -> flags |= HTTPPOST_PTRNAME ;\n # endif case CURLFORM_COPYNAME : if ( current_form -> name ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n char * name = array_state ? array_value : va_arg ( params , char * ) ;\n if ( name ) current_form -> name = name ;\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_NAMELENGTH : if ( current_form -> namelength ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else current_form -> namelength = array_state ? ( size_t ) array_value : ( size_t ) va_arg ( params , long ) ;\n break ;\n case CURLFORM_PTRCONTENTS : current_form -> flags |= HTTPPOST_PTRCONTENTS ;\n case CURLFORM_COPYCONTENTS : if ( current_form -> value ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n char * value = array_state ? array_value : va_arg ( params , char * ) ;\n if ( value ) current_form -> value = value ;\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_CONTENTSLENGTH : if ( current_form -> contentslength ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else current_form -> contentslength = array_state ? ( size_t ) array_value : ( size_t ) va_arg ( params , long ) ;\n break ;\n case CURLFORM_FILECONTENT : if ( current_form -> flags & ( HTTPPOST_PTRCONTENTS | HTTPPOST_READFILE ) ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n const char * filename = array_state ? array_value : va_arg ( params , char * ) ;\n if ( filename ) {\n current_form -> value = strdup ( filename ) ;\n if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n else {\n current_form -> flags |= HTTPPOST_READFILE ;\n current_form -> value_alloc = TRUE ;\n }\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_FILE : {\n const char * filename = array_state ? array_value : va_arg ( params , char * ) ;\n if ( current_form -> value ) {\n if ( current_form -> flags & HTTPPOST_FILENAME ) {\n if ( filename ) {\n char * fname = strdup ( filename ) ;\n if ( ! fname ) return_value = CURL_FORMADD_MEMORY ;\n else {\n form = AddFormInfo ( fname , NULL , current_form ) ;\n if ( ! form ) {\n Curl_safefree ( fname ) ;\n return_value = CURL_FORMADD_MEMORY ;\n }\n else {\n form -> value_alloc = TRUE ;\n current_form = form ;\n form = NULL ;\n }\n }\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n else return_value = CURL_FORMADD_OPTION_TWICE ;\n }\n else {\n if ( filename ) {\n current_form -> value = strdup ( filename ) ;\n if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n else {\n current_form -> flags |= HTTPPOST_FILENAME ;\n current_form -> value_alloc = TRUE ;\n }\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n }\n case CURLFORM_BUFFERPTR : current_form -> flags |= HTTPPOST_PTRBUFFER | HTTPPOST_BUFFER ;\n if ( current_form -> buffer ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n char * buffer = array_state ? array_value : va_arg ( params , char * ) ;\n if ( buffer ) {\n current_form -> buffer = buffer ;\n current_form -> value = buffer ;\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_BUFFERLENGTH : if ( current_form -> bufferlength ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else current_form -> bufferlength = array_state ? ( size_t ) array_value : ( size_t ) va_arg ( params , long ) ;\n break ;\n case CURLFORM_STREAM : current_form -> flags |= HTTPPOST_CALLBACK ;\n if ( current_form -> userp ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n char * userp = array_state ? array_value : va_arg ( params , char * ) ;\n if ( userp ) {\n current_form -> userp = userp ;\n current_form -> value = userp ;\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n case CURLFORM_CONTENTTYPE : {\n const char * contenttype = array_state ? array_value : va_arg ( params , char * ) ;\n if ( current_form -> contenttype ) {\n if ( current_form -> flags & HTTPPOST_FILENAME ) {\n if ( contenttype ) {\n char * type = strdup ( contenttype ) ;\n if ( ! type ) return_value = CURL_FORMADD_MEMORY ;\n else {\n form = AddFormInfo ( NULL , type , current_form ) ;\n if ( ! form ) {\n Curl_safefree ( type ) ;\n return_value = CURL_FORMADD_MEMORY ;\n }\n else {\n form -> contenttype_alloc = TRUE ;\n current_form = form ;\n form = NULL ;\n }\n }\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n else return_value = CURL_FORMADD_OPTION_TWICE ;\n }\n else {\n if ( contenttype ) {\n current_form -> contenttype = strdup ( contenttype ) ;\n if ( ! current_form -> contenttype ) return_value = CURL_FORMADD_MEMORY ;\n else current_form -> contenttype_alloc = TRUE ;\n }\n else return_value = CURL_FORMADD_NULL ;\n }\n break ;\n }\n case CURLFORM_CONTENTHEADER : {\n struct curl_slist * list = array_state ? ( struct curl_slist * ) array_value : va_arg ( params , struct curl_slist * ) ;\n if ( current_form -> contentheader ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else current_form -> contentheader = list ;\n break ;\n }\n case CURLFORM_FILENAME : case CURLFORM_BUFFER : {\n const char * filename = array_state ? array_value : va_arg ( params , char * ) ;\n if ( current_form -> showfilename ) return_value = CURL_FORMADD_OPTION_TWICE ;\n else {\n current_form -> showfilename = strdup ( filename ) ;\n if ( ! current_form -> showfilename ) return_value = CURL_FORMADD_MEMORY ;\n else current_form -> showfilename_alloc = TRUE ;\n }\n break ;\n }\n default : return_value = CURL_FORMADD_UNKNOWN_OPTION ;\n break ;\n }\n }\n if ( CURL_FORMADD_OK != return_value ) {\n FormInfo * ptr ;\n for ( ptr = first_form ;\n ptr != NULL ;\n ptr = ptr -> more ) {\n if ( ptr -> name_alloc ) {\n Curl_safefree ( ptr -> name ) ;\n ptr -> name_alloc = FALSE ;\n }\n if ( ptr -> value_alloc ) {\n Curl_safefree ( ptr -> value ) ;\n ptr -> value_alloc = FALSE ;\n }\n if ( ptr -> contenttype_alloc ) {\n Curl_safefree ( ptr -> contenttype ) ;\n ptr -> contenttype_alloc = FALSE ;\n }\n if ( ptr -> showfilename_alloc ) {\n Curl_safefree ( ptr -> showfilename ) ;\n ptr -> showfilename_alloc = FALSE ;\n }\n }\n }\n if ( CURL_FORMADD_OK == return_value ) {\n post = NULL ;\n for ( form = first_form ;\n form != NULL ;\n form = form -> more ) {\n if ( ( ( ! form -> name || ! form -> value ) && ! post ) || ( ( form -> contentslength ) && ( form -> flags & HTTPPOST_FILENAME ) ) || ( ( form -> flags & HTTPPOST_FILENAME ) && ( form -> flags & HTTPPOST_PTRCONTENTS ) ) || ( ( ! form -> buffer ) && ( form -> flags & HTTPPOST_BUFFER ) && ( form -> flags & HTTPPOST_PTRBUFFER ) ) || ( ( form -> flags & HTTPPOST_READFILE ) && ( form -> flags & HTTPPOST_PTRCONTENTS ) ) ) {\n return_value = CURL_FORMADD_INCOMPLETE ;\n break ;\n }\n else {\n if ( ( ( form -> flags & HTTPPOST_FILENAME ) || ( form -> flags & HTTPPOST_BUFFER ) ) && ! form -> contenttype ) {\n char * f = form -> flags & HTTPPOST_BUFFER ? form -> showfilename : form -> value ;\n form -> contenttype = strdup ( ContentTypeForFilename ( f , prevtype ) ) ;\n if ( ! form -> contenttype ) {\n return_value = CURL_FORMADD_MEMORY ;\n break ;\n }\n form -> contenttype_alloc = TRUE ;\n }\n if ( ! ( form -> flags & HTTPPOST_PTRNAME ) && ( form == first_form ) ) {\n if ( form -> name ) form -> name = memdup ( form -> name , form -> namelength ) ;\n if ( ! form -> name ) {\n return_value = CURL_FORMADD_MEMORY ;\n break ;\n }\n form -> name_alloc = TRUE ;\n }\n if ( ! ( form -> flags & ( HTTPPOST_FILENAME | HTTPPOST_READFILE | HTTPPOST_PTRCONTENTS | HTTPPOST_PTRBUFFER | HTTPPOST_CALLBACK ) ) && form -> value ) {\n form -> value = memdup ( form -> value , form -> contentslength ) ;\n if ( ! form -> value ) {\n return_value = CURL_FORMADD_MEMORY ;\n break ;\n }\n form -> value_alloc = TRUE ;\n }\n post = AddHttpPost ( form -> name , form -> namelength , form -> value , form -> contentslength , form -> buffer , form -> bufferlength , form -> contenttype , form -> flags , form -> contentheader , form -> showfilename , form -> userp , post , httppost , last_post ) ;\n if ( ! post ) {\n return_value = CURL_FORMADD_MEMORY ;\n break ;\n }\n if ( form -> contenttype ) prevtype = form -> contenttype ;\n }\n }\n if ( CURL_FORMADD_OK != return_value ) {\n FormInfo * ptr ;\n for ( ptr = form ;\n ptr != NULL ;\n ptr = ptr -> more ) {\n if ( ptr -> name_alloc ) {\n Curl_safefree ( ptr -> name ) ;\n ptr -> name_alloc = FALSE ;\n }\n if ( ptr -> value_alloc ) {\n Curl_safefree ( ptr -> value ) ;\n ptr -> value_alloc = FALSE ;\n }\n if ( ptr -> contenttype_alloc ) {\n Curl_safefree ( ptr -> contenttype ) ;\n ptr -> contenttype_alloc = FALSE ;\n }\n if ( ptr -> showfilename_alloc ) {\n Curl_safefree ( ptr -> showfilename ) ;\n ptr -> showfilename_alloc = FALSE ;\n }\n }\n }\n }\n while ( first_form ) {\n FormInfo * ptr = first_form -> more ;\n Curl_safefree ( first_form ) ;\n first_form = ptr ;\n }\n return return_value ;\n }",
        "hash": -4635544075321012404,
        "project": "debian",
        "size": 283,
        "slice": {
            "calloc": [
                [
                    1,
                    "static CURLFORMcode FormAdd ( struct curl_httppost * * httppost , struct curl_httppost * * last_post , va_list params ) {\n"
                ],
                [
                    10,
                    " first_form = calloc ( 1 , sizeof ( struct FormInfo ) ) ;\n"
                ],
                [
                    11,
                    " if ( ! first_form ) return CURL_FORMADD_MEMORY ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static CURLFORMcode FormAdd ( struct curl_httppost * * httppost , struct curl_httppost * * last_post , va_list params ) {\n"
                ],
                [
                    60,
                    " if ( filename ) {\n"
                ],
                [
                    61,
                    " current_form -> value = strdup ( filename ) ;\n"
                ],
                [
                    62,
                    " if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    75,
                    " if ( filename ) {\n"
                ],
                [
                    76,
                    " char * fname = strdup ( filename ) ;\n"
                ],
                [
                    77,
                    " if ( ! fname ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    96,
                    " if ( filename ) {\n"
                ],
                [
                    97,
                    " current_form -> value = strdup ( filename ) ;\n"
                ],
                [
                    98,
                    " if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    137,
                    " if ( contenttype ) {\n"
                ],
                [
                    138,
                    " char * type = strdup ( contenttype ) ;\n"
                ],
                [
                    139,
                    " if ( ! type ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    158,
                    " if ( contenttype ) {\n"
                ],
                [
                    159,
                    " current_form -> contenttype = strdup ( contenttype ) ;\n"
                ],
                [
                    160,
                    " if ( ! current_form -> contenttype ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    175,
                    " if ( current_form -> showfilename ) return_value = CURL_FORMADD_OPTION_TWICE ;\n"
                ],
                [
                    177,
                    " current_form -> showfilename = strdup ( filename ) ;\n"
                ],
                [
                    178,
                    " if ( ! current_form -> showfilename ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    220,
                    " if ( ( ( form -> flags & HTTPPOST_FILENAME ) || ( form -> flags & HTTPPOST_BUFFER ) ) && ! form -> contenttype ) {\n"
                ],
                [
                    222,
                    " form -> contenttype = strdup ( ContentTypeForFilename ( f , prevtype ) ) ;\n"
                ],
                [
                    223,
                    " if ( ! form -> contenttype ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static CURLFORMcode FormAdd ( struct curl_httppost * * httppost , struct curl_httppost * * last_post , va_list params ) {\n"
                ],
                [
                    10,
                    " first_form = calloc ( 1 , sizeof ( struct FormInfo ) ) ;\n"
                ],
                [
                    11,
                    " if ( ! first_form ) return CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    60,
                    " if ( filename ) {\n"
                ],
                [
                    61,
                    " current_form -> value = strdup ( filename ) ;\n"
                ],
                [
                    62,
                    " if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    75,
                    " if ( filename ) {\n"
                ],
                [
                    76,
                    " char * fname = strdup ( filename ) ;\n"
                ],
                [
                    77,
                    " if ( ! fname ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    96,
                    " if ( filename ) {\n"
                ],
                [
                    97,
                    " current_form -> value = strdup ( filename ) ;\n"
                ],
                [
                    98,
                    " if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    137,
                    " if ( contenttype ) {\n"
                ],
                [
                    138,
                    " char * type = strdup ( contenttype ) ;\n"
                ],
                [
                    139,
                    " if ( ! type ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    158,
                    " if ( contenttype ) {\n"
                ],
                [
                    159,
                    " current_form -> contenttype = strdup ( contenttype ) ;\n"
                ],
                [
                    160,
                    " if ( ! current_form -> contenttype ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    175,
                    " if ( current_form -> showfilename ) return_value = CURL_FORMADD_OPTION_TWICE ;\n"
                ],
                [
                    177,
                    " current_form -> showfilename = strdup ( filename ) ;\n"
                ],
                [
                    178,
                    " if ( ! current_form -> showfilename ) return_value = CURL_FORMADD_MEMORY ;\n"
                ],
                [
                    220,
                    " if ( ( ( form -> flags & HTTPPOST_FILENAME ) || ( form -> flags & HTTPPOST_BUFFER ) ) && ! form -> contenttype ) {\n"
                ],
                [
                    222,
                    " form -> contenttype = strdup ( ContentTypeForFilename ( f , prevtype ) ) ;\n"
                ],
                [
                    223,
                    " if ( ! form -> contenttype ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static char * CreateHtmlSubtitle ( int * pi_align , char * psz_subtitle ) {\n char * psz_tag = malloc ( 1 ) ;\n if ( psz_tag == NULL ) return NULL ;\n char * psz_html = malloc ( 1 ) ;\n if ( psz_html == NULL ) {\n free ( psz_tag ) ;\n return NULL ;\n }\n psz_tag [ 0 ] = '\\0' ;\n psz_html [ 0 ] = '\\0' ;\n bool b_has_align = false ;\n HtmlPut ( & psz_html , \"<text>\" ) ;\n while ( * psz_subtitle ) {\n if ( * psz_subtitle == '\\n' ) {\n HtmlPut ( & psz_html , \"<br/>\" ) ;\n psz_subtitle ++ ;\n }\n else if ( * psz_subtitle == '<' ) {\n if ( ! strncasecmp ( psz_subtitle , \"<br/>\" , 5 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<br/>\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<b>\" , 3 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<b>\" ) ;\n HtmlPut ( & psz_tag , \"b\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<i>\" , 3 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<i>\" ) ;\n HtmlPut ( & psz_tag , \"i\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<u>\" , 3 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<u>\" ) ;\n HtmlPut ( & psz_tag , \"u\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<s>\" , 3 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"<s>\" ) ;\n HtmlPut ( & psz_tag , \"s\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"<font \" , 6 ) ) {\n const char * psz_attribs [ ] = {\n \"face=\" , \"family=\" , \"size=\" , \"color=\" , \"outline-color=\" , \"shadow-color=\" , \"outline-level=\" , \"shadow-level=\" , \"back-color=\" , \"alpha=\" , NULL }\n ;\n HtmlCopy ( & psz_html , & psz_subtitle , \"<font \" ) ;\n HtmlPut ( & psz_tag , \"f\" ) ;\n while ( * psz_subtitle != '>' ) {\n int k ;\n while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n for ( k = 0 ;\n psz_attribs [ k ] ;\n k ++ ) {\n int i_len = strlen ( psz_attribs [ k ] ) ;\n if ( ! strncasecmp ( psz_subtitle , psz_attribs [ k ] , i_len ) ) {\n HtmlPut ( & psz_html , psz_attribs [ k ] ) ;\n psz_subtitle += i_len ;\n while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n if ( * psz_subtitle == '\"' ) {\n psz_subtitle ++ ;\n i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n }\n else if ( * psz_subtitle == '\\'' ) {\n psz_subtitle ++ ;\n i_len = strcspn ( psz_subtitle , \"'\" ) ;\n }\n else {\n i_len = strcspn ( psz_subtitle , \" \\t>\" ) ;\n }\n HtmlPut ( & psz_html , \"\\\"\" ) ;\n HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n HtmlPut ( & psz_html , \"\\\"\" ) ;\n psz_subtitle += i_len ;\n if ( * psz_subtitle == '\\\"' || * psz_subtitle == '\\'' ) psz_subtitle ++ ;\n break ;\n }\n }\n if ( psz_attribs [ k ] == NULL ) {\n int i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n if ( psz_subtitle [ i_len ] == '\\\"' ) {\n i_len += 1 + strcspn ( & psz_subtitle [ i_len + 1 ] , \"\\\"\" ) ;\n if ( psz_subtitle [ i_len ] == '\\\"' ) i_len ++ ;\n }\n if ( i_len == 0 ) psz_subtitle ++ ;\n psz_subtitle += i_len ;\n }\n HtmlNPut ( & psz_html , psz_subtitle , strspn ( psz_subtitle , \" \" ) ) ;\n }\n HtmlPut ( & psz_html , \">\" ) ;\n psz_subtitle ++ ;\n }\n else if ( ! strncmp ( psz_subtitle , \"</\" , 2 ) ) {\n bool b_match = false ;\n bool b_ignore = false ;\n int i_len = ( psz_tag ? strlen ( psz_tag ) : 0 ) - 1 ;\n char * psz_lastTag = NULL ;\n if ( i_len >= 0 ) {\n psz_lastTag = psz_tag + i_len ;\n i_len = 0 ;\n switch ( * psz_lastTag ) {\n case 'b' : b_match = ! strncasecmp ( psz_subtitle , \"</b>\" , 4 ) ;\n i_len = 4 ;\n break ;\n case 'i' : b_match = ! strncasecmp ( psz_subtitle , \"</i>\" , 4 ) ;\n i_len = 4 ;\n break ;\n case 'u' : b_match = ! strncasecmp ( psz_subtitle , \"</u>\" , 4 ) ;\n i_len = 4 ;\n break ;\n case 's' : b_match = ! strncasecmp ( psz_subtitle , \"</s>\" , 4 ) ;\n i_len = 4 ;\n break ;\n case 'f' : b_match = ! strncasecmp ( psz_subtitle , \"</font>\" , 7 ) ;\n i_len = 7 ;\n break ;\n case 'I' : i_len = strcspn ( psz_subtitle , \">\" ) ;\n b_match = psz_subtitle [ i_len ] == '>' ;\n b_ignore = true ;\n if ( b_match ) i_len ++ ;\n break ;\n }\n }\n if ( ! b_match ) {\n free ( psz_html ) ;\n psz_html = NULL ;\n break ;\n }\n * psz_lastTag = '\\0' ;\n if ( ! b_ignore ) HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n psz_subtitle += i_len ;\n }\n else if ( ( psz_subtitle [ 1 ] < 'a' || psz_subtitle [ 1 ] > 'z' ) && ( psz_subtitle [ 1 ] < 'A' || psz_subtitle [ 1 ] > 'Z' ) ) {\n HtmlPut ( & psz_html , \"&lt;\n\" ) ;\n psz_subtitle ++ ;\n }\n else {\n char * psz_stop = psz_subtitle + 1 + strcspn ( & psz_subtitle [ 1 ] , \"<>\" ) ;\n char * psz_closing = strstr ( psz_subtitle , \"/>\" ) ;\n if ( psz_closing && psz_closing < psz_stop ) {\n psz_subtitle = & psz_closing [ 2 ] ;\n }\n else if ( * psz_stop == '>' ) {\n char psz_match [ 256 ] ;\n snprintf ( psz_match , sizeof ( psz_match ) , \"</%s\" , & psz_subtitle [ 1 ] ) ;\n psz_match [ strcspn ( psz_match , \" \\t>\" ) ] = '\\0' ;\n if ( strstr ( psz_subtitle , psz_match ) ) {\n psz_subtitle = & psz_stop [ 1 ] ;\n HtmlPut ( & psz_tag , \"I\" ) ;\n }\n else {\n int i_len = psz_stop + 1 - psz_subtitle ;\n for ( ;\n i_len > 0 ;\n i_len -- , psz_subtitle ++ ) {\n if ( * psz_subtitle == '<' ) HtmlPut ( & psz_html , \"&lt;\n\" ) ;\n else if ( * psz_subtitle == '>' ) HtmlPut ( & psz_html , \"&gt;\n\" ) ;\n else HtmlNPut ( & psz_html , psz_subtitle , 1 ) ;\n }\n }\n }\n else {\n HtmlPut ( & psz_html , \"&lt;\n\" ) ;\n psz_subtitle ++ ;\n }\n }\n }\n else if ( * psz_subtitle == '&' ) {\n if ( ! strncasecmp ( psz_subtitle , \"&lt;\n\" , 4 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"&lt;\n\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"&gt;\n\" , 4 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"&gt;\n\" ) ;\n }\n else if ( ! strncasecmp ( psz_subtitle , \"&amp;\n\" , 5 ) ) {\n HtmlCopy ( & psz_html , & psz_subtitle , \"&amp;\n\" ) ;\n }\n else {\n HtmlPut ( & psz_html , \"&amp;\n\" ) ;\n psz_subtitle ++ ;\n }\n }\n else if ( * psz_subtitle == '>' ) {\n HtmlPut ( & psz_html , \"&gt;\n\" ) ;\n psz_subtitle ++ ;\n }\n else if ( psz_subtitle [ 0 ] == '{\n' && psz_subtitle [ 1 ] == '\\\\' && strchr ( psz_subtitle , '}\n' ) ) {\n if ( ! b_has_align && ! strncmp ( psz_subtitle , \"{\n\\\\an\" , 4 ) && psz_subtitle [ 4 ] >= '1' && psz_subtitle [ 4 ] <= '9' && psz_subtitle [ 5 ] == '}\n' ) {\n static const int pi_vertical [ 3 ] = {\n SUBPICTURE_ALIGN_BOTTOM , 0 , SUBPICTURE_ALIGN_TOP }\n ;\n static const int pi_horizontal [ 3 ] = {\n SUBPICTURE_ALIGN_LEFT , 0 , SUBPICTURE_ALIGN_RIGHT }\n ;\n const int i_id = psz_subtitle [ 4 ] - '1' ;\n b_has_align = true ;\n * pi_align = pi_vertical [ i_id / 3 ] | pi_horizontal [ i_id % 3 ] ;\n }\n psz_subtitle = strchr ( psz_subtitle , '}\n' ) + 1 ;\n }\n else if ( psz_subtitle [ 0 ] == '{\n' && ( psz_subtitle [ 1 ] == 'Y' || psz_subtitle [ 1 ] == 'y' ) && psz_subtitle [ 2 ] == ':' && strchr ( psz_subtitle , '}\n' ) ) {\n if ( psz_subtitle [ 3 ] == 'i' ) {\n HtmlPut ( & psz_html , \"<i>\" ) ;\n HtmlPut ( & psz_tag , \"i\" ) ;\n }\n if ( psz_subtitle [ 3 ] == 'b' ) {\n HtmlPut ( & psz_html , \"<b>\" ) ;\n HtmlPut ( & psz_tag , \"b\" ) ;\n }\n if ( psz_subtitle [ 3 ] == 'u' ) {\n HtmlPut ( & psz_html , \"<u>\" ) ;\n HtmlPut ( & psz_tag , \"u\" ) ;\n }\n psz_subtitle = strchr ( psz_subtitle , '}\n' ) + 1 ;\n }\n else if ( psz_subtitle [ 0 ] == '{\n' && psz_subtitle [ 2 ] == ':' && strchr ( psz_subtitle , '}\n' ) ) {\n psz_subtitle = strchr ( psz_subtitle , '}\n' ) + 1 ;\n }\n else if ( psz_subtitle [ 0 ] == '\\\\' && psz_subtitle [ 1 ] ) {\n if ( psz_subtitle [ 1 ] == 'N' || psz_subtitle [ 1 ] == 'n' ) {\n HtmlPut ( & psz_html , \"<br/>\" ) ;\n psz_subtitle += 2 ;\n }\n else if ( psz_subtitle [ 1 ] == 'h' ) {\n HtmlPut ( & psz_html , NO_BREAKING_SPACE ) ;\n psz_subtitle += 2 ;\n }\n else {\n HtmlPut ( & psz_html , \"\\\\\" ) ;\n psz_subtitle ++ ;\n }\n }\n else {\n HtmlNPut ( & psz_html , psz_subtitle , 1 ) ;\n # if 0 if ( * psz_html ) {\n # error This test does not make sense . if ( ( * psz_html == ' ' || * psz_html == '\\t' ) && ( * ( psz_html - 1 ) == ' ' || * ( psz_html - 1 ) == '\\t' ) ) {\n HtmlPut ( & psz_html , NO_BREAKING_SPACE ) ;\n psz_html -- ;\n }\n }\n # endif psz_subtitle ++ ;\n }\n }\n while ( psz_tag && * psz_tag ) {\n char * psz_last = & psz_tag [ strlen ( psz_tag ) - 1 ] ;\n switch ( * psz_last ) {\n case 'b' : HtmlPut ( & psz_html , \"</b>\" ) ;\n break ;\n case 'i' : HtmlPut ( & psz_html , \"</i>\" ) ;\n break ;\n case 'u' : HtmlPut ( & psz_html , \"</u>\" ) ;\n break ;\n case 's' : HtmlPut ( & psz_html , \"</s>\" ) ;\n break ;\n case 'f' : HtmlPut ( & psz_html , \"</font>\" ) ;\n break ;\n case 'I' : break ;\n }\n * psz_last = '\\0' ;\n }\n HtmlPut ( & psz_html , \"</text>\" ) ;\n free ( psz_tag ) ;\n return psz_html ;\n }",
        "hash": -275948070528829821,
        "project": "debian",
        "size": 282,
        "slice": {
            "strlen": [
                [
                    1,
                    "static char * CreateHtmlSubtitle ( int * pi_align , char * psz_subtitle ) {\n"
                ],
                [
                    3,
                    " if ( psz_tag == NULL ) return NULL ;\n"
                ],
                [
                    9,
                    " psz_tag [ 0 ] = '\\0' ;\n"
                ],
                [
                    24,
                    " HtmlPut ( & psz_tag , \"b\" ) ;\n"
                ],
                [
                    28,
                    " HtmlPut ( & psz_tag , \"i\" ) ;\n"
                ],
                [
                    32,
                    " HtmlPut ( & psz_tag , \"u\" ) ;\n"
                ],
                [
                    36,
                    " HtmlPut ( & psz_tag , \"s\" ) ;\n"
                ],
                [
                    43,
                    " HtmlPut ( & psz_tag , \"f\" ) ;\n"
                ],
                [
                    48,
                    " psz_attribs [ k ] ;\n"
                ],
                [
                    50,
                    " int i_len = strlen ( psz_attribs [ k ] ) ;\n"
                ],
                [
                    51,
                    " if ( ! strncasecmp ( psz_subtitle , psz_attribs [ k ] , i_len ) ) {\n"
                ],
                [
                    74,
                    " if ( psz_attribs [ k ] == NULL ) {\n"
                ],
                [
                    88,
                    " else if ( ! strncmp ( psz_subtitle , \"</\" , 2 ) ) {\n"
                ],
                [
                    91,
                    " int i_len = ( psz_tag ? strlen ( psz_tag ) : 0 ) - 1 ;\n"
                ],
                [
                    93,
                    " if ( i_len >= 0 ) {\n"
                ],
                [
                    145,
                    " HtmlPut ( & psz_tag , \"I\" ) ;\n"
                ]
            ],
            "strspn": [
                [
                    1,
                    "static char * CreateHtmlSubtitle ( int * pi_align , char * psz_subtitle ) {\n"
                ],
                [
                    5,
                    " if ( psz_html == NULL ) {\n"
                ],
                [
                    10,
                    " psz_html [ 0 ] = '\\0' ;\n"
                ],
                [
                    12,
                    " HtmlPut ( & psz_html , \"<text>\" ) ;\n"
                ],
                [
                    15,
                    " HtmlPut ( & psz_html , \"<br/>\" ) ;\n"
                ],
                [
                    18,
                    " else if ( * psz_subtitle == '<' ) {\n"
                ],
                [
                    20,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<br/>\" ) ;\n"
                ],
                [
                    23,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<b>\" ) ;\n"
                ],
                [
                    27,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<i>\" ) ;\n"
                ],
                [
                    31,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<u>\" ) ;\n"
                ],
                [
                    35,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<s>\" ) ;\n"
                ],
                [
                    38,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<font \" , 6 ) ) {\n"
                ],
                [
                    42,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<font \" ) ;\n"
                ],
                [
                    44,
                    " while ( * psz_subtitle != '>' ) {\n"
                ],
                [
                    46,
                    " while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n"
                ],
                [
                    51,
                    " if ( ! strncasecmp ( psz_subtitle , psz_attribs [ k ] , i_len ) ) {\n"
                ],
                [
                    52,
                    " HtmlPut ( & psz_html , psz_attribs [ k ] ) ;\n"
                ],
                [
                    66,
                    " HtmlPut ( & psz_html , \"\\\"\" ) ;\n"
                ],
                [
                    67,
                    " HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n"
                ],
                [
                    68,
                    " HtmlPut ( & psz_html , \"\\\"\" ) ;\n"
                ],
                [
                    69,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    70,
                    " if ( * psz_subtitle == '\\\"' || * psz_subtitle == '\\'' ) psz_subtitle ++ ;\n"
                ],
                [
                    75,
                    " int i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n"
                ],
                [
                    76,
                    " if ( psz_subtitle [ i_len ] == '\\\"' ) {\n"
                ],
                [
                    77,
                    " i_len += 1 + strcspn ( & psz_subtitle [ i_len + 1 ] , \"\\\"\" ) ;\n"
                ],
                [
                    78,
                    " if ( psz_subtitle [ i_len ] == '\\\"' ) i_len ++ ;\n"
                ],
                [
                    81,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    83,
                    " HtmlNPut ( & psz_html , psz_subtitle , strspn ( psz_subtitle , \" \" ) ) ;\n"
                ],
                [
                    85,
                    " HtmlPut ( & psz_html , \">\" ) ;\n"
                ],
                [
                    86,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    88,
                    " else if ( ! strncmp ( psz_subtitle , \"</\" , 2 ) ) {\n"
                ],
                [
                    113,
                    " b_match = psz_subtitle [ i_len ] == '>' ;\n"
                ],
                [
                    120,
                    " free ( psz_html ) ;\n"
                ],
                [
                    125,
                    " if ( ! b_ignore ) HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n"
                ],
                [
                    128,
                    " else if ( ( psz_subtitle [ 1 ] < 'a' || psz_subtitle [ 1 ] > 'z' ) && ( psz_subtitle [ 1 ] < 'A' || psz_subtitle [ 1 ] > 'Z' ) ) {\n"
                ],
                [
                    134,
                    " char * psz_stop = psz_subtitle + 1 + strcspn ( & psz_subtitle [ 1 ] , \"<>\" ) ;\n"
                ],
                [
                    135,
                    " char * psz_closing = strstr ( psz_subtitle , \"/>\" ) ;\n"
                ],
                [
                    141,
                    " snprintf ( psz_match , sizeof ( psz_match ) , \"</%s\" , & psz_subtitle [ 1 ] ) ;\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "static char * CreateHtmlSubtitle ( int * pi_align , char * psz_subtitle ) {\n"
                ],
                [
                    16,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    18,
                    " else if ( * psz_subtitle == '<' ) {\n"
                ],
                [
                    19,
                    " if ( ! strncasecmp ( psz_subtitle , \"<br/>\" , 5 ) ) {\n"
                ],
                [
                    20,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<br/>\" ) ;\n"
                ],
                [
                    22,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<b>\" , 3 ) ) {\n"
                ],
                [
                    23,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<b>\" ) ;\n"
                ],
                [
                    26,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<i>\" , 3 ) ) {\n"
                ],
                [
                    27,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<i>\" ) ;\n"
                ],
                [
                    30,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<u>\" , 3 ) ) {\n"
                ],
                [
                    31,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<u>\" ) ;\n"
                ],
                [
                    34,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<s>\" , 3 ) ) {\n"
                ],
                [
                    35,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<s>\" ) ;\n"
                ],
                [
                    38,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<font \" , 6 ) ) {\n"
                ],
                [
                    42,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<font \" ) ;\n"
                ],
                [
                    46,
                    " while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n"
                ],
                [
                    51,
                    " if ( ! strncasecmp ( psz_subtitle , psz_attribs [ k ] , i_len ) ) {\n"
                ],
                [
                    53,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    54,
                    " while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n"
                ],
                [
                    56,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    57,
                    " i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n"
                ],
                [
                    60,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    61,
                    " i_len = strcspn ( psz_subtitle , \"'\" ) ;\n"
                ],
                [
                    64,
                    " i_len = strcspn ( psz_subtitle , \" \\t>\" ) ;\n"
                ],
                [
                    67,
                    " HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n"
                ],
                [
                    69,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    70,
                    " if ( * psz_subtitle == '\\\"' || * psz_subtitle == '\\'' ) psz_subtitle ++ ;\n"
                ],
                [
                    75,
                    " int i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n"
                ],
                [
                    76,
                    " if ( psz_subtitle [ i_len ] == '\\\"' ) {\n"
                ],
                [
                    77,
                    " i_len += 1 + strcspn ( & psz_subtitle [ i_len + 1 ] , \"\\\"\" ) ;\n"
                ],
                [
                    78,
                    " if ( psz_subtitle [ i_len ] == '\\\"' ) i_len ++ ;\n"
                ],
                [
                    80,
                    " if ( i_len == 0 ) psz_subtitle ++ ;\n"
                ],
                [
                    81,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    83,
                    " HtmlNPut ( & psz_html , psz_subtitle , strspn ( psz_subtitle , \" \" ) ) ;\n"
                ],
                [
                    86,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    88,
                    " else if ( ! strncmp ( psz_subtitle , \"</\" , 2 ) ) {\n"
                ],
                [
                    97,
                    " case 'b' : b_match = ! strncasecmp ( psz_subtitle , \"</b>\" , 4 ) ;\n"
                ],
                [
                    100,
                    " case 'i' : b_match = ! strncasecmp ( psz_subtitle , \"</i>\" , 4 ) ;\n"
                ],
                [
                    103,
                    " case 'u' : b_match = ! strncasecmp ( psz_subtitle , \"</u>\" , 4 ) ;\n"
                ],
                [
                    106,
                    " case 's' : b_match = ! strncasecmp ( psz_subtitle , \"</s>\" , 4 ) ;\n"
                ],
                [
                    109,
                    " case 'f' : b_match = ! strncasecmp ( psz_subtitle , \"</font>\" , 7 ) ;\n"
                ],
                [
                    112,
                    " case 'I' : i_len = strcspn ( psz_subtitle , \">\" ) ;\n"
                ],
                [
                    113,
                    " b_match = psz_subtitle [ i_len ] == '>' ;\n"
                ],
                [
                    125,
                    " if ( ! b_ignore ) HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n"
                ],
                [
                    126,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    128,
                    " else if ( ( psz_subtitle [ 1 ] < 'a' || psz_subtitle [ 1 ] > 'z' ) && ( psz_subtitle [ 1 ] < 'A' || psz_subtitle [ 1 ] > 'Z' ) ) {\n"
                ],
                [
                    134,
                    " char * psz_stop = psz_subtitle + 1 + strcspn ( & psz_subtitle [ 1 ] , \"<>\" ) ;\n"
                ],
                [
                    135,
                    " char * psz_closing = strstr ( psz_subtitle , \"/>\" ) ;\n"
                ],
                [
                    136,
                    " if ( psz_closing && psz_closing < psz_stop ) {\n"
                ],
                [
                    139,
                    " else if ( * psz_stop == '>' ) {\n"
                ],
                [
                    141,
                    " snprintf ( psz_match , sizeof ( psz_match ) , \"</%s\" , & psz_subtitle [ 1 ] ) ;\n"
                ],
                [
                    142,
                    " psz_match [ strcspn ( psz_match , \" \\t>\" ) ] = '\\0' ;\n"
                ],
                [
                    143,
                    " if ( strstr ( psz_subtitle , psz_match ) ) {\n"
                ],
                [
                    144,
                    " psz_subtitle = & psz_stop [ 1 ] ;\n"
                ],
                [
                    145,
                    " HtmlPut ( & psz_tag , \"I\" ) ;\n"
                ],
                [
                    148,
                    " int i_len = psz_stop + 1 - psz_subtitle ;\n"
                ],
                [
                    150,
                    " i_len > 0 ;\n"
                ],
                [
                    151,
                    " i_len -- , psz_subtitle ++ ) {\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static char * CreateHtmlSubtitle ( int * pi_align , char * psz_subtitle ) {\n"
                ],
                [
                    2,
                    " char * psz_tag = malloc ( 1 ) ;\n"
                ],
                [
                    3,
                    " if ( psz_tag == NULL ) return NULL ;\n"
                ],
                [
                    4,
                    " char * psz_html = malloc ( 1 ) ;\n"
                ],
                [
                    5,
                    " if ( psz_html == NULL ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static char * CreateHtmlSubtitle ( int * pi_align , char * psz_subtitle ) {\n"
                ],
                [
                    3,
                    " if ( psz_tag == NULL ) return NULL ;\n"
                ],
                [
                    5,
                    " if ( psz_html == NULL ) {\n"
                ],
                [
                    6,
                    " free ( psz_tag ) ;\n"
                ],
                [
                    10,
                    " psz_html [ 0 ] = '\\0' ;\n"
                ],
                [
                    12,
                    " HtmlPut ( & psz_html , \"<text>\" ) ;\n"
                ],
                [
                    15,
                    " HtmlPut ( & psz_html , \"<br/>\" ) ;\n"
                ],
                [
                    20,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<br/>\" ) ;\n"
                ],
                [
                    23,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<b>\" ) ;\n"
                ],
                [
                    27,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<i>\" ) ;\n"
                ],
                [
                    31,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<u>\" ) ;\n"
                ],
                [
                    35,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<s>\" ) ;\n"
                ],
                [
                    42,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<font \" ) ;\n"
                ],
                [
                    52,
                    " HtmlPut ( & psz_html , psz_attribs [ k ] ) ;\n"
                ],
                [
                    66,
                    " HtmlPut ( & psz_html , \"\\\"\" ) ;\n"
                ],
                [
                    67,
                    " HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n"
                ],
                [
                    68,
                    " HtmlPut ( & psz_html , \"\\\"\" ) ;\n"
                ],
                [
                    83,
                    " HtmlNPut ( & psz_html , psz_subtitle , strspn ( psz_subtitle , \" \" ) ) ;\n"
                ],
                [
                    85,
                    " HtmlPut ( & psz_html , \">\" ) ;\n"
                ],
                [
                    119,
                    " if ( ! b_match ) {\n"
                ],
                [
                    120,
                    " free ( psz_html ) ;\n"
                ],
                [
                    125,
                    " if ( ! b_ignore ) HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static char * CreateHtmlSubtitle ( int * pi_align , char * psz_subtitle ) {\n"
                ],
                [
                    2,
                    " char * psz_tag = malloc ( 1 ) ;\n"
                ],
                [
                    3,
                    " if ( psz_tag == NULL ) return NULL ;\n"
                ],
                [
                    4,
                    " char * psz_html = malloc ( 1 ) ;\n"
                ],
                [
                    5,
                    " if ( psz_html == NULL ) {\n"
                ],
                [
                    6,
                    " free ( psz_tag ) ;\n"
                ],
                [
                    9,
                    " psz_tag [ 0 ] = '\\0' ;\n"
                ],
                [
                    10,
                    " psz_html [ 0 ] = '\\0' ;\n"
                ],
                [
                    12,
                    " HtmlPut ( & psz_html , \"<text>\" ) ;\n"
                ],
                [
                    15,
                    " HtmlPut ( & psz_html , \"<br/>\" ) ;\n"
                ],
                [
                    16,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    18,
                    " else if ( * psz_subtitle == '<' ) {\n"
                ],
                [
                    19,
                    " if ( ! strncasecmp ( psz_subtitle , \"<br/>\" , 5 ) ) {\n"
                ],
                [
                    20,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<br/>\" ) ;\n"
                ],
                [
                    22,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<b>\" , 3 ) ) {\n"
                ],
                [
                    23,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<b>\" ) ;\n"
                ],
                [
                    24,
                    " HtmlPut ( & psz_tag , \"b\" ) ;\n"
                ],
                [
                    26,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<i>\" , 3 ) ) {\n"
                ],
                [
                    27,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<i>\" ) ;\n"
                ],
                [
                    28,
                    " HtmlPut ( & psz_tag , \"i\" ) ;\n"
                ],
                [
                    30,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<u>\" , 3 ) ) {\n"
                ],
                [
                    31,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<u>\" ) ;\n"
                ],
                [
                    32,
                    " HtmlPut ( & psz_tag , \"u\" ) ;\n"
                ],
                [
                    34,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<s>\" , 3 ) ) {\n"
                ],
                [
                    35,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<s>\" ) ;\n"
                ],
                [
                    36,
                    " HtmlPut ( & psz_tag , \"s\" ) ;\n"
                ],
                [
                    38,
                    " else if ( ! strncasecmp ( psz_subtitle , \"<font \" , 6 ) ) {\n"
                ],
                [
                    42,
                    " HtmlCopy ( & psz_html , & psz_subtitle , \"<font \" ) ;\n"
                ],
                [
                    43,
                    " HtmlPut ( & psz_tag , \"f\" ) ;\n"
                ],
                [
                    44,
                    " while ( * psz_subtitle != '>' ) {\n"
                ],
                [
                    46,
                    " while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n"
                ],
                [
                    48,
                    " psz_attribs [ k ] ;\n"
                ],
                [
                    50,
                    " int i_len = strlen ( psz_attribs [ k ] ) ;\n"
                ],
                [
                    51,
                    " if ( ! strncasecmp ( psz_subtitle , psz_attribs [ k ] , i_len ) ) {\n"
                ],
                [
                    52,
                    " HtmlPut ( & psz_html , psz_attribs [ k ] ) ;\n"
                ],
                [
                    53,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    54,
                    " while ( * psz_subtitle == ' ' ) psz_subtitle ++ ;\n"
                ],
                [
                    56,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    57,
                    " i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n"
                ],
                [
                    60,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    61,
                    " i_len = strcspn ( psz_subtitle , \"'\" ) ;\n"
                ],
                [
                    64,
                    " i_len = strcspn ( psz_subtitle , \" \\t>\" ) ;\n"
                ],
                [
                    66,
                    " HtmlPut ( & psz_html , \"\\\"\" ) ;\n"
                ],
                [
                    67,
                    " HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n"
                ],
                [
                    68,
                    " HtmlPut ( & psz_html , \"\\\"\" ) ;\n"
                ],
                [
                    69,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    70,
                    " if ( * psz_subtitle == '\\\"' || * psz_subtitle == '\\'' ) psz_subtitle ++ ;\n"
                ],
                [
                    74,
                    " if ( psz_attribs [ k ] == NULL ) {\n"
                ],
                [
                    75,
                    " int i_len = strcspn ( psz_subtitle , \"\\\"\" ) ;\n"
                ],
                [
                    76,
                    " if ( psz_subtitle [ i_len ] == '\\\"' ) {\n"
                ],
                [
                    77,
                    " i_len += 1 + strcspn ( & psz_subtitle [ i_len + 1 ] , \"\\\"\" ) ;\n"
                ],
                [
                    78,
                    " if ( psz_subtitle [ i_len ] == '\\\"' ) i_len ++ ;\n"
                ],
                [
                    80,
                    " if ( i_len == 0 ) psz_subtitle ++ ;\n"
                ],
                [
                    81,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    83,
                    " HtmlNPut ( & psz_html , psz_subtitle , strspn ( psz_subtitle , \" \" ) ) ;\n"
                ],
                [
                    85,
                    " HtmlPut ( & psz_html , \">\" ) ;\n"
                ],
                [
                    86,
                    " psz_subtitle ++ ;\n"
                ],
                [
                    88,
                    " else if ( ! strncmp ( psz_subtitle , \"</\" , 2 ) ) {\n"
                ],
                [
                    91,
                    " int i_len = ( psz_tag ? strlen ( psz_tag ) : 0 ) - 1 ;\n"
                ],
                [
                    93,
                    " if ( i_len >= 0 ) {\n"
                ],
                [
                    97,
                    " case 'b' : b_match = ! strncasecmp ( psz_subtitle , \"</b>\" , 4 ) ;\n"
                ],
                [
                    100,
                    " case 'i' : b_match = ! strncasecmp ( psz_subtitle , \"</i>\" , 4 ) ;\n"
                ],
                [
                    103,
                    " case 'u' : b_match = ! strncasecmp ( psz_subtitle , \"</u>\" , 4 ) ;\n"
                ],
                [
                    106,
                    " case 's' : b_match = ! strncasecmp ( psz_subtitle , \"</s>\" , 4 ) ;\n"
                ],
                [
                    109,
                    " case 'f' : b_match = ! strncasecmp ( psz_subtitle , \"</font>\" , 7 ) ;\n"
                ],
                [
                    112,
                    " case 'I' : i_len = strcspn ( psz_subtitle , \">\" ) ;\n"
                ],
                [
                    113,
                    " b_match = psz_subtitle [ i_len ] == '>' ;\n"
                ],
                [
                    119,
                    " if ( ! b_match ) {\n"
                ],
                [
                    120,
                    " free ( psz_html ) ;\n"
                ],
                [
                    125,
                    " if ( ! b_ignore ) HtmlNPut ( & psz_html , psz_subtitle , i_len ) ;\n"
                ],
                [
                    126,
                    " psz_subtitle += i_len ;\n"
                ],
                [
                    128,
                    " else if ( ( psz_subtitle [ 1 ] < 'a' || psz_subtitle [ 1 ] > 'z' ) && ( psz_subtitle [ 1 ] < 'A' || psz_subtitle [ 1 ] > 'Z' ) ) {\n"
                ],
                [
                    134,
                    " char * psz_stop = psz_subtitle + 1 + strcspn ( & psz_subtitle [ 1 ] , \"<>\" ) ;\n"
                ],
                [
                    135,
                    " char * psz_closing = strstr ( psz_subtitle , \"/>\" ) ;\n"
                ],
                [
                    136,
                    " if ( psz_closing && psz_closing < psz_stop ) {\n"
                ],
                [
                    139,
                    " else if ( * psz_stop == '>' ) {\n"
                ],
                [
                    141,
                    " snprintf ( psz_match , sizeof ( psz_match ) , \"</%s\" , & psz_subtitle [ 1 ] ) ;\n"
                ],
                [
                    142,
                    " psz_match [ strcspn ( psz_match , \" \\t>\" ) ] = '\\0' ;\n"
                ],
                [
                    143,
                    " if ( strstr ( psz_subtitle , psz_match ) ) {\n"
                ],
                [
                    144,
                    " psz_subtitle = & psz_stop [ 1 ] ;\n"
                ],
                [
                    145,
                    " HtmlPut ( & psz_tag , \"I\" ) ;\n"
                ],
                [
                    148,
                    " int i_len = psz_stop + 1 - psz_subtitle ;\n"
                ],
                [
                    150,
                    " i_len > 0 ;\n"
                ],
                [
                    151,
                    " i_len -- , psz_subtitle ++ ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) {\n size_t Data_Buf_Size = 1024 ;\n char Buf [ 1024 ] ;\n int Timeout = - 1 ;\n FILE * Fp ;\n parse_status_t status = PARSE_OK ;\n int ok_on_close = FALSE ;\n size_t entity_offset = 0 ;\n int num_read = 0 ;\n int ret_code = HTTP_OK ;\n if ( Instr && Instr -> IsVirtualFile ) {\n Fp = ( virtualDirCallback . open ) ( filename , UPNP_WRITE ) ;\n if ( Fp == NULL ) return HTTP_INTERNAL_SERVER_ERROR ;\n }\n else {\n Fp = fopen ( filename , \"wb\" ) ;\n if ( Fp == NULL ) return HTTP_UNAUTHORIZED ;\n }\n parser -> position = POS_ENTITY ;\n do {\n if ( parser -> position != POS_COMPLETE ) status = parser_parse_entity ( parser ) ;\n if ( status == PARSE_INCOMPLETE_ENTITY ) {\n ok_on_close = TRUE ;\n }\n else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) {\n ret_code = HTTP_BAD_REQUEST ;\n goto ExitFunction ;\n }\n while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) {\n num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ;\n if ( num_read > 0 ) {\n if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) {\n parser -> http_error_code = HTTP_INTERNAL_SERVER_ERROR ;\n ret_code = HTTP_INTERNAL_SERVER_ERROR ;\n goto ExitFunction ;\n }\n status = parser_parse_entity ( parser ) ;\n if ( status == PARSE_INCOMPLETE_ENTITY ) {\n ok_on_close = TRUE ;\n }\n else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) {\n ret_code = HTTP_BAD_REQUEST ;\n goto ExitFunction ;\n }\n }\n else if ( num_read == 0 ) {\n if ( ok_on_close ) {\n UpnpPrintf ( UPNP_INFO , HTTP , __FILE__ , __LINE__ , \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\" , parser -> msg . msg . buf ) ;\n print_http_headers ( & parser -> msg ) ;\n parser -> position = POS_COMPLETE ;\n }\n else {\n parser -> http_error_code = HTTP_BAD_REQUEST ;\n ret_code = HTTP_BAD_REQUEST ;\n goto ExitFunction ;\n }\n }\n else {\n ret_code = HTTP_SERVICE_UNAVAILABLE ;\n goto ExitFunction ;\n }\n }\n if ( ( entity_offset + Data_Buf_Size ) > parser -> msg . entity . length ) {\n Data_Buf_Size = parser -> msg . entity . length - entity_offset ;\n }\n memcpy ( Buf , & parser -> msg . msg . buf [ parser -> entity_start_position + entity_offset ] , Data_Buf_Size ) ;\n entity_offset += Data_Buf_Size ;\n if ( Instr && Instr -> IsVirtualFile ) {\n int n = virtualDirCallback . write ( Fp , Buf , Data_Buf_Size ) ;\n if ( n < 0 ) {\n ret_code = HTTP_INTERNAL_SERVER_ERROR ;\n goto ExitFunction ;\n }\n }\n else {\n size_t n = fwrite ( Buf , 1 , Data_Buf_Size , Fp ) ;\n if ( n != Data_Buf_Size ) {\n ret_code = HTTP_INTERNAL_SERVER_ERROR ;\n goto ExitFunction ;\n }\n }\n }\n while ( parser -> position != POS_COMPLETE || entity_offset != parser -> msg . entity . length ) ;\n ExitFunction : if ( Instr && Instr -> IsVirtualFile ) {\n virtualDirCallback . close ( Fp ) ;\n }\n else {\n fclose ( Fp ) ;\n }\n return ret_code ;\n }",
        "hash": 9118387177353441960,
        "project": "debian",
        "size": 91,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) {\n"
                ],
                [
                    2,
                    " size_t Data_Buf_Size = 1024 ;\n"
                ],
                [
                    3,
                    " char Buf [ 1024 ] ;\n"
                ],
                [
                    29,
                    " while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) {\n"
                ],
                [
                    30,
                    " num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ;\n"
                ],
                [
                    32,
                    " if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) {\n"
                ],
                [
                    48,
                    " UpnpPrintf ( UPNP_INFO , HTTP , __FILE__ , __LINE__ , \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\" , parser -> msg . msg . buf ) ;\n"
                ],
                [
                    64,
                    " Data_Buf_Size = parser -> msg . entity . length - entity_offset ;\n"
                ],
                [
                    66,
                    " memcpy ( Buf , & parser -> msg . msg . buf [ parser -> entity_start_position + entity_offset ] , Data_Buf_Size ) ;\n"
                ],
                [
                    67,
                    " entity_offset += Data_Buf_Size ;\n"
                ],
                [
                    69,
                    " int n = virtualDirCallback . write ( Fp , Buf , Data_Buf_Size ) ;\n"
                ],
                [
                    76,
                    " size_t n = fwrite ( Buf , 1 , Data_Buf_Size , Fp ) ;\n"
                ],
                [
                    77,
                    " if ( n != Data_Buf_Size ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) {\n"
                ],
                [
                    2,
                    " size_t Data_Buf_Size = 1024 ;\n"
                ],
                [
                    3,
                    " char Buf [ 1024 ] ;\n"
                ],
                [
                    29,
                    " while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) {\n"
                ],
                [
                    30,
                    " num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ;\n"
                ],
                [
                    32,
                    " if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) {\n"
                ],
                [
                    48,
                    " UpnpPrintf ( UPNP_INFO , HTTP , __FILE__ , __LINE__ , \"<<< (RECVD) <<<\\n%s\\n-----------------\\n\" , parser -> msg . msg . buf ) ;\n"
                ],
                [
                    64,
                    " Data_Buf_Size = parser -> msg . entity . length - entity_offset ;\n"
                ],
                [
                    66,
                    " memcpy ( Buf , & parser -> msg . msg . buf [ parser -> entity_start_position + entity_offset ] , Data_Buf_Size ) ;\n"
                ],
                [
                    67,
                    " entity_offset += Data_Buf_Size ;\n"
                ],
                [
                    69,
                    " int n = virtualDirCallback . write ( Fp , Buf , Data_Buf_Size ) ;\n"
                ],
                [
                    76,
                    " size_t n = fwrite ( Buf , 1 , Data_Buf_Size , Fp ) ;\n"
                ],
                [
                    77,
                    " if ( n != Data_Buf_Size ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int parsedate ( const char * date , time_t * output ) {\n time_t t = 0 ;\n int wdaynum = - 1 ;\n int monnum = - 1 ;\n int mdaynum = - 1 ;\n int hournum = - 1 ;\n int minnum = - 1 ;\n int secnum = - 1 ;\n int yearnum = - 1 ;\n int tzoff = - 1 ;\n struct my_tm tm ;\n enum assume dignext = DATE_MDAY ;\n const char * indate = date ;\n int part = 0 ;\n while ( * date && ( part < 6 ) ) {\n bool found = FALSE ;\n skip ( & date ) ;\n if ( ISALPHA ( * date ) ) {\n char buf [ 32 ] = \"\" ;\n size_t len ;\n if ( sscanf ( date , \"%31[ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz]\" , buf ) ) len = strlen ( buf ) ;\n else len = 0 ;\n if ( wdaynum == - 1 ) {\n wdaynum = checkday ( buf , len ) ;\n if ( wdaynum != - 1 ) found = TRUE ;\n }\n if ( ! found && ( monnum == - 1 ) ) {\n monnum = checkmonth ( buf ) ;\n if ( monnum != - 1 ) found = TRUE ;\n }\n if ( ! found && ( tzoff == - 1 ) ) {\n tzoff = checktz ( buf ) ;\n if ( tzoff != - 1 ) found = TRUE ;\n }\n if ( ! found ) return PARSEDATE_FAIL ;\n date += len ;\n }\n else if ( ISDIGIT ( * date ) ) {\n int val ;\n char * end ;\n if ( ( secnum == - 1 ) && ( 3 == sscanf ( date , \"%02d:%02d:%02d\" , & hournum , & minnum , & secnum ) ) ) {\n date += 8 ;\n }\n else if ( ( secnum == - 1 ) && ( 2 == sscanf ( date , \"%02d:%02d\" , & hournum , & minnum ) ) ) {\n date += 5 ;\n secnum = 0 ;\n }\n else {\n long lval ;\n int error ;\n int old_errno ;\n old_errno = ERRNO ;\n SET_ERRNO ( 0 ) ;\n lval = strtol ( date , & end , 10 ) ;\n error = ERRNO ;\n if ( error != old_errno ) SET_ERRNO ( old_errno ) ;\n if ( error ) return PARSEDATE_FAIL ;\n # if LONG_MAX != INT_MAX if ( ( lval > ( long ) INT_MAX ) || ( lval < ( long ) INT_MIN ) ) return PARSEDATE_FAIL ;\n # endif val = curlx_sltosi ( lval ) ;\n if ( ( tzoff == - 1 ) && ( ( end - date ) == 4 ) && ( val <= 1400 ) && ( indate < date ) && ( ( date [ - 1 ] == '+' || date [ - 1 ] == '-' ) ) ) {\n found = TRUE ;\n tzoff = ( val / 100 * 60 + val % 100 ) * 60 ;\n tzoff = date [ - 1 ] == '+' ? - tzoff : tzoff ;\n }\n if ( ( ( end - date ) == 8 ) && ( yearnum == - 1 ) && ( monnum == - 1 ) && ( mdaynum == - 1 ) ) {\n found = TRUE ;\n yearnum = val / 10000 ;\n monnum = ( val % 10000 ) / 100 - 1 ;\n mdaynum = val % 100 ;\n }\n if ( ! found && ( dignext == DATE_MDAY ) && ( mdaynum == - 1 ) ) {\n if ( ( val > 0 ) && ( val < 32 ) ) {\n mdaynum = val ;\n found = TRUE ;\n }\n dignext = DATE_YEAR ;\n }\n if ( ! found && ( dignext == DATE_YEAR ) && ( yearnum == - 1 ) ) {\n yearnum = val ;\n found = TRUE ;\n if ( yearnum < 1900 ) {\n if ( yearnum > 70 ) yearnum += 1900 ;\n else yearnum += 2000 ;\n }\n if ( mdaynum == - 1 ) dignext = DATE_MDAY ;\n }\n if ( ! found ) return PARSEDATE_FAIL ;\n date = end ;\n }\n }\n part ++ ;\n }\n if ( - 1 == secnum ) secnum = minnum = hournum = 0 ;\n if ( ( - 1 == mdaynum ) || ( - 1 == monnum ) || ( - 1 == yearnum ) ) return PARSEDATE_FAIL ;\n # if SIZEOF_TIME_T < 5 if ( yearnum > 2037 ) {\n * output = 0x7fffffff ;\n return PARSEDATE_LATER ;\n }\n # endif if ( yearnum < 1970 ) {\n * output = 0 ;\n return PARSEDATE_SOONER ;\n }\n if ( ( mdaynum > 31 ) || ( monnum > 11 ) || ( hournum > 23 ) || ( minnum > 59 ) || ( secnum > 60 ) ) return PARSEDATE_FAIL ;\n tm . tm_sec = secnum ;\n tm . tm_min = minnum ;\n tm . tm_hour = hournum ;\n tm . tm_mday = mdaynum ;\n tm . tm_mon = monnum ;\n tm . tm_year = yearnum - 1900 ;\n t = my_timegm ( & tm ) ;\n if ( - 1 != ( int ) t ) {\n long delta = ( long ) ( tzoff != - 1 ? tzoff : 0 ) ;\n if ( ( delta > 0 ) && ( t > LONG_MAX - delta ) ) {\n * output = 0x7fffffff ;\n return PARSEDATE_LATER ;\n }\n t += delta ;\n }\n * output = t ;\n return PARSEDATE_OK ;\n }",
        "hash": -7256256713578558606,
        "project": "debian",
        "size": 121,
        "slice": {
            "strlen": [
                [
                    1,
                    "static int parsedate ( const char * date , time_t * output ) {\n"
                ],
                [
                    21,
                    " if ( sscanf ( date , \"%31[ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz]\" , buf ) ) len = strlen ( buf ) ;\n"
                ],
                [
                    24,
                    " wdaynum = checkday ( buf , len ) ;\n"
                ],
                [
                    28,
                    " monnum = checkmonth ( buf ) ;\n"
                ],
                [
                    32,
                    " tzoff = checktz ( buf ) ;\n"
                ],
                [
                    36,
                    " date += len ;\n"
                ]
            ],
            "sscanf": [
                [
                    1,
                    "static int parsedate ( const char * date , time_t * output ) {\n"
                ],
                [
                    6,
                    " int hournum = - 1 ;\n"
                ],
                [
                    7,
                    " int minnum = - 1 ;\n"
                ],
                [
                    15,
                    " while ( * date && ( part < 6 ) ) {\n"
                ],
                [
                    17,
                    " skip ( & date ) ;\n"
                ],
                [
                    18,
                    " if ( ISALPHA ( * date ) ) {\n"
                ],
                [
                    19,
                    " char buf [ 32 ] = \"\" ;\n"
                ],
                [
                    21,
                    " if ( sscanf ( date , \"%31[ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz]\" , buf ) ) len = strlen ( buf ) ;\n"
                ],
                [
                    22,
                    " else len = 0 ;\n"
                ],
                [
                    24,
                    " wdaynum = checkday ( buf , len ) ;\n"
                ],
                [
                    28,
                    " monnum = checkmonth ( buf ) ;\n"
                ],
                [
                    32,
                    " tzoff = checktz ( buf ) ;\n"
                ],
                [
                    36,
                    " date += len ;\n"
                ],
                [
                    38,
                    " else if ( ISDIGIT ( * date ) ) {\n"
                ],
                [
                    41,
                    " if ( ( secnum == - 1 ) && ( 3 == sscanf ( date , \"%02d:%02d:%02d\" , & hournum , & minnum , & secnum ) ) ) {\n"
                ],
                [
                    42,
                    " date += 8 ;\n"
                ],
                [
                    44,
                    " else if ( ( secnum == - 1 ) && ( 2 == sscanf ( date , \"%02d:%02d\" , & hournum , & minnum ) ) ) {\n"
                ],
                [
                    45,
                    " date += 5 ;\n"
                ],
                [
                    46,
                    " secnum = 0 ;\n"
                ],
                [
                    52,
                    " old_errno = ERRNO ;\n"
                ],
                [
                    53,
                    " SET_ERRNO ( 0 ) ;\n"
                ],
                [
                    54,
                    " lval = strtol ( date , & end , 10 ) ;\n"
                ],
                [
                    55,
                    " error = ERRNO ;\n"
                ],
                [
                    56,
                    " if ( error != old_errno ) SET_ERRNO ( old_errno ) ;\n"
                ],
                [
                    57,
                    " if ( error ) return PARSEDATE_FAIL ;\n"
                ],
                [
                    60,
                    " if ( ( tzoff == - 1 ) && ( ( end - date ) == 4 ) && ( val <= 1400 ) && ( indate < date ) && ( ( date [ - 1 ] == '+' || date [ - 1 ] == '-' ) ) ) {\n"
                ],
                [
                    63,
                    " tzoff = date [ - 1 ] == '+' ? - tzoff : tzoff ;\n"
                ],
                [
                    88,
                    " date = end ;\n"
                ],
                [
                    91,
                    " part ++ ;\n"
                ],
                [
                    93,
                    " if ( - 1 == secnum ) secnum = minnum = hournum = 0 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int parsedate ( const char * date , time_t * output ) {\n"
                ],
                [
                    6,
                    " int hournum = - 1 ;\n"
                ],
                [
                    7,
                    " int minnum = - 1 ;\n"
                ],
                [
                    15,
                    " while ( * date && ( part < 6 ) ) {\n"
                ],
                [
                    17,
                    " skip ( & date ) ;\n"
                ],
                [
                    18,
                    " if ( ISALPHA ( * date ) ) {\n"
                ],
                [
                    19,
                    " char buf [ 32 ] = \"\" ;\n"
                ],
                [
                    21,
                    " if ( sscanf ( date , \"%31[ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz]\" , buf ) ) len = strlen ( buf ) ;\n"
                ],
                [
                    22,
                    " else len = 0 ;\n"
                ],
                [
                    24,
                    " wdaynum = checkday ( buf , len ) ;\n"
                ],
                [
                    28,
                    " monnum = checkmonth ( buf ) ;\n"
                ],
                [
                    32,
                    " tzoff = checktz ( buf ) ;\n"
                ],
                [
                    36,
                    " date += len ;\n"
                ],
                [
                    38,
                    " else if ( ISDIGIT ( * date ) ) {\n"
                ],
                [
                    41,
                    " if ( ( secnum == - 1 ) && ( 3 == sscanf ( date , \"%02d:%02d:%02d\" , & hournum , & minnum , & secnum ) ) ) {\n"
                ],
                [
                    42,
                    " date += 8 ;\n"
                ],
                [
                    44,
                    " else if ( ( secnum == - 1 ) && ( 2 == sscanf ( date , \"%02d:%02d\" , & hournum , & minnum ) ) ) {\n"
                ],
                [
                    45,
                    " date += 5 ;\n"
                ],
                [
                    46,
                    " secnum = 0 ;\n"
                ],
                [
                    52,
                    " old_errno = ERRNO ;\n"
                ],
                [
                    53,
                    " SET_ERRNO ( 0 ) ;\n"
                ],
                [
                    54,
                    " lval = strtol ( date , & end , 10 ) ;\n"
                ],
                [
                    55,
                    " error = ERRNO ;\n"
                ],
                [
                    56,
                    " if ( error != old_errno ) SET_ERRNO ( old_errno ) ;\n"
                ],
                [
                    57,
                    " if ( error ) return PARSEDATE_FAIL ;\n"
                ],
                [
                    60,
                    " if ( ( tzoff == - 1 ) && ( ( end - date ) == 4 ) && ( val <= 1400 ) && ( indate < date ) && ( ( date [ - 1 ] == '+' || date [ - 1 ] == '-' ) ) ) {\n"
                ],
                [
                    63,
                    " tzoff = date [ - 1 ] == '+' ? - tzoff : tzoff ;\n"
                ],
                [
                    88,
                    " date = end ;\n"
                ],
                [
                    91,
                    " part ++ ;\n"
                ],
                [
                    93,
                    " if ( - 1 == secnum ) secnum = minnum = hournum = 0 ;\n"
                ]
            ]
        }
    },
    {
        "code": "TSReturnCode TSHttpTxnConfigFind ( const char * name , int length , TSOverridableConfigKey * conf , TSRecordDataType * type ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) name ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) conf ) == TS_SUCCESS ) ;\n TSOverridableConfigKey cnf = TS_CONFIG_NULL ;\n TSRecordDataType typ = TS_RECORDDATATYPE_INT ;\n if ( length == - 1 ) {\n length = strlen ( name ) ;\n }\n switch ( length ) {\n case 24 : if ( ! strncmp ( name , \"proxy.config.srv_enabled\" , length ) ) {\n cnf = TS_CONFIG_SRV_ENABLED ;\n }\n break ;\n case 28 : if ( ! strncmp ( name , \"proxy.config.http.cache.http\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_HTTP ;\n }\n break ;\n case 29 : if ( ! strncmp ( name , \"proxy.config.ssl.hsts_max_age\" , length ) ) {\n cnf = TS_CONFIG_SSL_HSTS_MAX_AGE ;\n }\n break ;\n case 31 : if ( ! strncmp ( name , \"proxy.config.http.chunking.size\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CHUNKING_SIZE ;\n }\n break ;\n case 33 : if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_FUZZ_TIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.ssl.client.cert.path\" , length ) ) {\n cnf = TS_CONFIG_SSL_CERT_FILEPATH ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n break ;\n case 34 : if ( ! strncmp ( name , \"proxy.config.http.chunking_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CHUNKING_ENABLED ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.generation\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_GENERATION ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.insert_client_ip\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_INSERT_CLIENT_IP ;\n }\n break ;\n case 35 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.range.write\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_RANGE_WRITE ;\n }\n break ;\n case 'p' : if ( ! strncmp ( name , \"proxy.config.http.normalize_ae_gzip\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NORMALIZE_AE_GZIP ;\n }\n break ;\n }\n break ;\n case 36 : switch ( name [ length - 1 ] ) {\n case 'p' : if ( ! strncmp ( name , \"proxy.config.http.cache.range.lookup\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_RANGE_LOOKUP ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.net.sock_packet_tos_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_PACKET_TOS_OUT ;\n }\n break ;\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.slow.log.threshold\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SLOW_LOG_THRESHOLD ;\n }\n break ;\n }\n break ;\n case 37 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.redirection_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ENABLE_REDIRECTION ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.max_stale_age\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_MAX_STALE_AGE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.min_time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_FUZZ_MIN_TIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.default_buffer_size\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_SIZE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.ssl.client.cert.filename\" , length ) ) {\n cnf = TS_CONFIG_SSL_CERT_FILENAME ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.response_server_str\" , length ) ) {\n cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_STR ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n else if ( ! strncmp ( name , \"proxy.config.ssl.client.verify.server\" , length ) ) {\n cnf = TS_CONFIG_SSL_CLIENT_VERIFY_SERVER ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_post_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_POST_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.net.sock_option_flag_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_OPTION_FLAG_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.net.sock_packet_mark_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_PACKET_MARK_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.websocket.active_timeout\" , length ) ) {\n cnf = TS_CONFIG_WEBSOCKET_ACTIVE_TIMEOUT ;\n }\n break ;\n }\n break ;\n case 38 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.server_tcp_init_cwnd\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SERVER_TCP_INIT_CWND ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.flow_control.enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED ;\n }\n break ;\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.send_http11_requests\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SEND_HTTP11_REQUESTS ;\n }\n break ;\n }\n break ;\n case 39 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.body_factory.template_base\" , length ) ) {\n cnf = TS_CONFIG_BODY_FACTORY_TEMPLATE_BASE ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n break ;\n case 'm' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_from\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_FROM ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_enabled_in\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_IN ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.doc_in_cache_skip_dns\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DOC_IN_CACHE_SKIP_DNS ;\n }\n break ;\n }\n break ;\n case 40 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.forward_connect_method\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FORWARD_CONNECT_METHOD ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.down_server.cache_time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DOWN_SERVER_CACHE_TIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.insert_age_in_response\" , length ) ) {\n cnf = TS_CONFIG_HTTP_INSERT_AGE_IN_RESPONSE ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.url_remap.pristine_host_hdr\" , length ) ) {\n cnf = TS_CONFIG_URL_REMAP_PRISTINE_HOST_HDR ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.insert_request_via_str\" , length ) ) {\n cnf = TS_CONFIG_HTTP_INSERT_REQUEST_VIA_STR ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.flow_control.low_water\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER_MARK ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.origin_max_connections\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.required_headers\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_REQUIRED_HEADERS ;\n }\n else if ( ! strncmp ( name , \"proxy.config.ssl.hsts_include_subdomains\" , length ) ) {\n cnf = TS_CONFIG_SSL_HSTS_INCLUDE_SUBDOMAINS ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.number_of_redirections\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NUMBER_OF_REDIRECTIONS ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_enabled_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_OUT ;\n }\n break ;\n case 'y' : if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.probability\" , length ) ) {\n typ = TS_RECORDDATATYPE_FLOAT ;\n cnf = TS_CONFIG_HTTP_CACHE_FUZZ_PROBABILITY ;\n }\n break ;\n }\n break ;\n case 41 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.response_server_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_ENABLED ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_cookie\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_COOKIE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.request_header_max_size\" , length ) ) {\n cnf = TS_CONFIG_HTTP_REQUEST_HEADER_MAX_SIZE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.safe_requests_retryable\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SAFE_REQUESTS_RETRYABLE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.retry_time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PARENT_PROXY_RETRY_TIME ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.insert_response_via_str\" , length ) ) {\n cnf = TS_CONFIG_HTTP_INSERT_RESPONSE_VIA_STR ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.flow_control.high_water\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER_MARK ;\n }\n break ;\n }\n break ;\n case 42 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.negative_caching_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_ENABLED ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.when_to_revalidate\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_WHEN_TO_REVALIDATE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.response_header_max_size\" , length ) ) {\n cnf = TS_CONFIG_HTTP_RESPONSE_HEADER_MAX_SIZE ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_referer\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_REFERER ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.global_user_agent_header\" , length ) ) {\n cnf = TS_CONFIG_HTTP_GLOBAL_USER_AGENT_HEADER ;\n typ = TS_RECORDDATATYPE_STRING ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.net.sock_recv_buffer_size_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_RECV_BUFFER_SIZE_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.net.sock_send_buffer_size_out\" , length ) ) {\n cnf = TS_CONFIG_NET_SOCK_SEND_BUFFER_SIZE_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_timeout\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_TIMEOUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.websocket.no_activity_timeout\" , length ) ) {\n cnf = TS_CONFIG_WEBSOCKET_NO_ACTIVITY_TIMEOUT ;\n }\n break ;\n }\n break ;\n case 43 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.negative_caching_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_LIFETIME ;\n }\n break ;\n case 'k' : if ( ! strncmp ( name , \"proxy.config.http.default_buffer_water_mark\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_WATER_MARK ;\n }\n break ;\n case 'l' : if ( ! strncmp ( name , \"proxy.config.http.cache.cluster_cache_local\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_CLUSTER_CACHE_LOCAL ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.cache.heuristic_lm_factor\" , length ) ) {\n typ = TS_RECORDDATATYPE_FLOAT ;\n cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_LM_FACTOR ;\n }\n break ;\n }\n break ;\n case 44 : switch ( name [ length - 1 ] ) {\n case 'p' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_client_ip\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_CLIENT_IP ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.open_read_retry_time\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_OPEN_READ_RETRY_TIME ;\n }\n break ;\n }\n break ;\n case 45 : switch ( name [ length - 1 ] ) {\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.down_server.abort_threshold\" , length ) ) {\n cnf = TS_CONFIG_HTTP_DOWN_SERVER_ABORT_THRESHOLD ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.fail_threshold\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PARENT_PROXY_FAIL_THRESHOLD ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_authentication\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IGNORE_AUTHENTICATION ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_user_agent\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_USER_AGENT ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_rr_retries\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_RR_RETRIES ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.max_open_read_retries\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_READ_RETRIES ;\n }\n break ;\n case 'e' : if ( 0 == strncmp ( name , \"proxy.config.http.auth_server_session_private\" , length ) ) {\n cnf = TS_CONFIG_HTTP_AUTH_SERVER_SESSION_PRIVATE ;\n }\n break ;\n case 'y' : if ( ! strncmp ( name , \"proxy.config.http.redirect_use_orig_cache_key\" , length ) ) {\n cnf = TS_CONFIG_HTTP_REDIRECT_USE_ORIG_CACHE_KEY ;\n }\n break ;\n }\n break ;\n case 46 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_client_no_cache\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_NO_CACHE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.ims_on_client_no_cache\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IMS_ON_CLIENT_NO_CACHE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_server_no_cache\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IGNORE_SERVER_NO_CACHE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.heuristic_min_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MIN_LIFETIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.heuristic_max_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MAX_LIFETIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.origin_max_connections_queue\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS_QUEUE ;\n }\n break ;\n case 'r' : if ( ! strncmp ( name , \"proxy.config.http.insert_squid_x_forwarded_for\" , length ) ) {\n cnf = TS_CONFIG_HTTP_INSERT_SQUID_X_FORWARDED_FOR ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_max_retries\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.max_open_write_retries\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_WRITE_RETRIES ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.forward.proxy_auth_to_parent\" , length ) ) {\n cnf = TS_CONFIG_HTTP_FORWARD_PROXY_AUTH_TO_PARENT ;\n }\n break ;\n case 'h' : if ( 0 == strncmp ( name , \"proxy.config.http.server_session_sharing.match\" , length ) ) {\n cnf = TS_CONFIG_HTTP_SERVER_SESSION_SHARING_MATCH ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.cache.open_write_fail_action\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_OPEN_WRITE_FAIL_ACTION ;\n }\n break ;\n }\n break ;\n case 47 : switch ( name [ length - 1 ] ) {\n case 'b' : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.mark_down_hostdb\" , length ) ) {\n cnf = TS_CONFIG_PARENT_FAILURES_UPDATE_HOSTDB ;\n }\n break ;\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.negative_revalidating_enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_ENABLED ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.guaranteed_min_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MIN_LIFETIME ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.cache.guaranteed_max_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MAX_LIFETIME ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.transaction_active_timeout_in\" , length ) ) {\n cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.post_connect_attempts_timeout\" , length ) ) {\n cnf = TS_CONFIG_HTTP_POST_CONNECT_ATTEMPTS_TIMEOUT ;\n }\n break ;\n }\n break ;\n case 48 : switch ( name [ length - 1 ] ) {\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_client_cc_max_age\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_CC_MAX_AGE ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.negative_revalidating_lifetime\" , length ) ) {\n cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_LIFETIME ;\n }\n break ;\n case 't' : switch ( name [ length - 4 ] ) {\n case '_' : if ( ! strncmp ( name , \"proxy.config.http.transaction_active_timeout_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_OUT ;\n }\n break ;\n case 'e' : if ( ! strncmp ( name , \"proxy.config.http.background_fill_active_timeout\" , length ) ) {\n cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_ACTIVE_TIMEOUT ;\n }\n break ;\n }\n break ;\n }\n break ;\n case 49 : if ( ! strncmp ( name , \"proxy.config.http.attach_server_session_to_client\" , length ) ) {\n cnf = TS_CONFIG_HTTP_ATTACH_SERVER_SESSION_TO_CLIENT ;\n }\n break ;\n case 50 : if ( ! strncmp ( name , \"proxy.config.http.cache.cache_responses_to_cookies\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_CACHE_RESPONSES_TO_COOKIES ;\n }\n break ;\n case 51 : switch ( name [ length - 1 ] ) {\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_no_activity_timeout_in\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_IN ;\n }\n break ;\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.post.check.content_length.enabled\" , length ) ) {\n cnf = TS_CONFIG_HTTP_POST_CHECK_CONTENT_LENGTH_ENABLED ;\n }\n break ;\n }\n break ;\n case 52 : switch ( name [ length - 1 ] ) {\n case 'c' : if ( ! strncmp ( name , \"proxy.config.http.cache.cache_urls_that_look_dynamic\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CACHE_CACHE_URLS_THAT_LOOK_DYNAMIC ;\n }\n break ;\n case 'n' : if ( ! strncmp ( name , \"proxy.config.http.transaction_no_activity_timeout_in\" , length ) ) {\n cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_IN ;\n }\n break ;\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_no_activity_timeout_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_OUT ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.uncacheable_requests_bypass_parent\" , length ) ) {\n cnf = TS_CONFIG_HTTP_UNCACHEABLE_REQUESTS_BYPASS_PARENT ;\n }\n break ;\n }\n break ;\n case 53 : switch ( name [ length - 1 ] ) {\n case 't' : if ( ! strncmp ( name , \"proxy.config.http.transaction_no_activity_timeout_out\" , length ) ) {\n cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_OUT ;\n }\n break ;\n case 'd' : if ( ! strncmp ( name , \"proxy.config.http.background_fill_completed_threshold\" , length ) ) {\n typ = TS_RECORDDATATYPE_FLOAT ;\n cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_COMPLETED_THRESHOLD ;\n }\n break ;\n case 's' : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.total_connect_attempts\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS ;\n }\n break ;\n }\n break ;\n case 55 : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.connect_attempts_timeout\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PARENT_CONNECT_ATTEMPT_TIMEOUT ;\n }\n break ;\n case 58 : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_max_retries_dead_server\" , length ) ) {\n cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES_DEAD_SERVER ;\n }\n else if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.per_parent_connect_attempts\" , length ) ) {\n cnf = TS_CONFIG_HTTP_PER_PARENT_CONNECT_ATTEMPTS ;\n }\n break ;\n }\n * conf = cnf ;\n if ( type ) {\n * type = typ ;\n }\n return ( ( cnf != TS_CONFIG_NULL ) ? TS_SUCCESS : TS_ERROR ) ;\n }",
        "hash": 1760449185745615462,
        "project": "debian",
        "size": 481,
        "slice": {
            "strlen": [
                [
                    1,
                    "TSReturnCode TSHttpTxnConfigFind ( const char * name , int length , TSOverridableConfigKey * conf , TSRecordDataType * type ) {\n"
                ],
                [
                    6,
                    " if ( length == - 1 ) {\n"
                ],
                [
                    7,
                    " length = strlen ( name ) ;\n"
                ],
                [
                    10,
                    " case 24 : if ( ! strncmp ( name , \"proxy.config.srv_enabled\" , length ) ) {\n"
                ],
                [
                    14,
                    " case 28 : if ( ! strncmp ( name , \"proxy.config.http.cache.http\" , length ) ) {\n"
                ],
                [
                    18,
                    " case 29 : if ( ! strncmp ( name , \"proxy.config.ssl.hsts_max_age\" , length ) ) {\n"
                ],
                [
                    22,
                    " case 31 : if ( ! strncmp ( name , \"proxy.config.http.chunking.size\" , length ) ) {\n"
                ],
                [
                    26,
                    " case 33 : if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.time\" , length ) ) {\n"
                ],
                [
                    34,
                    " case 34 : if ( ! strncmp ( name , \"proxy.config.http.chunking_enabled\" , length ) ) {\n"
                ],
                [
                    44,
                    " case 35 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    45,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.range.write\" , length ) ) {\n"
                ],
                [
                    49,
                    " case 'p' : if ( ! strncmp ( name , \"proxy.config.http.normalize_ae_gzip\" , length ) ) {\n"
                ],
                [
                    55,
                    " case 36 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    56,
                    " case 'p' : if ( ! strncmp ( name , \"proxy.config.http.cache.range.lookup\" , length ) ) {\n"
                ],
                [
                    60,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.net.sock_packet_tos_out\" , length ) ) {\n"
                ],
                [
                    64,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.slow.log.threshold\" , length ) ) {\n"
                ],
                [
                    70,
                    " case 37 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    71,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.redirection_enabled\" , length ) ) {\n"
                ],
                [
                    75,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.max_stale_age\" , length ) ) {\n"
                ],
                [
                    89,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.response_server_str\" , length ) ) {\n"
                ],
                [
                    97,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_post_out\" , length ) ) {\n"
                ],
                [
                    112,
                    " case 38 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    113,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.server_tcp_init_cwnd\" , length ) ) {\n"
                ],
                [
                    121,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.send_http11_requests\" , length ) ) {\n"
                ],
                [
                    127,
                    " case 39 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    128,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.body_factory.template_base\" , length ) ) {\n"
                ],
                [
                    133,
                    " case 'm' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_from\" , length ) ) {\n"
                ],
                [
                    137,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_enabled_in\" , length ) ) {\n"
                ],
                [
                    141,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.doc_in_cache_skip_dns\" , length ) ) {\n"
                ],
                [
                    147,
                    " case 40 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    148,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.forward_connect_method\" , length ) ) {\n"
                ],
                [
                    152,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.down_server.cache_time\" , length ) ) {\n"
                ],
                [
                    159,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.url_remap.pristine_host_hdr\" , length ) ) {\n"
                ],
                [
                    169,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.origin_max_connections\" , length ) ) {\n"
                ],
                [
                    182,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_enabled_out\" , length ) ) {\n"
                ],
                [
                    186,
                    " case 'y' : if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.probability\" , length ) ) {\n"
                ],
                [
                    193,
                    " case 41 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    194,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.response_server_enabled\" , length ) ) {\n"
                ],
                [
                    198,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_cookie\" , length ) ) {\n"
                ],
                [
                    211,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.insert_response_via_str\" , length ) ) {\n"
                ],
                [
                    220,
                    " case 42 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    221,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.negative_caching_enabled\" , length ) ) {\n"
                ],
                [
                    225,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.when_to_revalidate\" , length ) ) {\n"
                ],
                [
                    232,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_referer\" , length ) ) {\n"
                ],
                [
                    240,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.net.sock_recv_buffer_size_out\" , length ) ) {\n"
                ],
                [
                    255,
                    " case 43 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    256,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.negative_caching_lifetime\" , length ) ) {\n"
                ],
                [
                    260,
                    " case 'k' : if ( ! strncmp ( name , \"proxy.config.http.default_buffer_water_mark\" , length ) ) {\n"
                ],
                [
                    264,
                    " case 'l' : if ( ! strncmp ( name , \"proxy.config.http.cache.cluster_cache_local\" , length ) ) {\n"
                ],
                [
                    268,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.cache.heuristic_lm_factor\" , length ) ) {\n"
                ],
                [
                    275,
                    " case 44 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    276,
                    " case 'p' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_client_ip\" , length ) ) {\n"
                ],
                [
                    280,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.open_read_retry_time\" , length ) ) {\n"
                ],
                [
                    286,
                    " case 45 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    287,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.down_server.abort_threshold\" , length ) ) {\n"
                ],
                [
                    294,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_authentication\" , length ) ) {\n"
                ],
                [
                    298,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_user_agent\" , length ) ) {\n"
                ],
                [
                    302,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_rr_retries\" , length ) ) {\n"
                ],
                [
                    309,
                    " case 'e' : if ( 0 == strncmp ( name , \"proxy.config.http.auth_server_session_private\" , length ) ) {\n"
                ],
                [
                    313,
                    " case 'y' : if ( ! strncmp ( name , \"proxy.config.http.redirect_use_orig_cache_key\" , length ) ) {\n"
                ],
                [
                    319,
                    " case 46 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    320,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_client_no_cache\" , length ) ) {\n"
                ],
                [
                    339,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.insert_squid_x_forwarded_for\" , length ) ) {\n"
                ],
                [
                    343,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_max_retries\" , length ) ) {\n"
                ],
                [
                    350,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.forward.proxy_auth_to_parent\" , length ) ) {\n"
                ],
                [
                    354,
                    " case 'h' : if ( 0 == strncmp ( name , \"proxy.config.http.server_session_sharing.match\" , length ) ) {\n"
                ],
                [
                    358,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.cache.open_write_fail_action\" , length ) ) {\n"
                ],
                [
                    364,
                    " case 47 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    365,
                    " case 'b' : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.mark_down_hostdb\" , length ) ) {\n"
                ],
                [
                    369,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.negative_revalidating_enabled\" , length ) ) {\n"
                ],
                [
                    373,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.guaranteed_min_lifetime\" , length ) ) {\n"
                ],
                [
                    380,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.transaction_active_timeout_in\" , length ) ) {\n"
                ],
                [
                    384,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.post_connect_attempts_timeout\" , length ) ) {\n"
                ],
                [
                    390,
                    " case 48 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    391,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_client_cc_max_age\" , length ) ) {\n"
                ],
                [
                    399,
                    " case '_' : if ( ! strncmp ( name , \"proxy.config.http.transaction_active_timeout_out\" , length ) ) {\n"
                ],
                [
                    403,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.background_fill_active_timeout\" , length ) ) {\n"
                ],
                [
                    411,
                    " case 49 : if ( ! strncmp ( name , \"proxy.config.http.attach_server_session_to_client\" , length ) ) {\n"
                ],
                [
                    415,
                    " case 50 : if ( ! strncmp ( name , \"proxy.config.http.cache.cache_responses_to_cookies\" , length ) ) {\n"
                ],
                [
                    419,
                    " case 51 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    420,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_no_activity_timeout_in\" , length ) ) {\n"
                ],
                [
                    424,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.post.check.content_length.enabled\" , length ) ) {\n"
                ],
                [
                    430,
                    " case 52 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    431,
                    " case 'c' : if ( ! strncmp ( name , \"proxy.config.http.cache.cache_urls_that_look_dynamic\" , length ) ) {\n"
                ],
                [
                    435,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.transaction_no_activity_timeout_in\" , length ) ) {\n"
                ],
                [
                    439,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_no_activity_timeout_out\" , length ) ) {\n"
                ],
                [
                    448,
                    " case 53 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    449,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.transaction_no_activity_timeout_out\" , length ) ) {\n"
                ],
                [
                    453,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.background_fill_completed_threshold\" , length ) ) {\n"
                ],
                [
                    458,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.total_connect_attempts\" , length ) ) {\n"
                ],
                [
                    464,
                    " case 55 : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.connect_attempts_timeout\" , length ) ) {\n"
                ],
                [
                    468,
                    " case 58 : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_max_retries_dead_server\" , length ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "TSReturnCode TSHttpTxnConfigFind ( const char * name , int length , TSOverridableConfigKey * conf , TSRecordDataType * type ) {\n"
                ],
                [
                    6,
                    " if ( length == - 1 ) {\n"
                ],
                [
                    7,
                    " length = strlen ( name ) ;\n"
                ],
                [
                    10,
                    " case 24 : if ( ! strncmp ( name , \"proxy.config.srv_enabled\" , length ) ) {\n"
                ],
                [
                    14,
                    " case 28 : if ( ! strncmp ( name , \"proxy.config.http.cache.http\" , length ) ) {\n"
                ],
                [
                    18,
                    " case 29 : if ( ! strncmp ( name , \"proxy.config.ssl.hsts_max_age\" , length ) ) {\n"
                ],
                [
                    22,
                    " case 31 : if ( ! strncmp ( name , \"proxy.config.http.chunking.size\" , length ) ) {\n"
                ],
                [
                    26,
                    " case 33 : if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.time\" , length ) ) {\n"
                ],
                [
                    34,
                    " case 34 : if ( ! strncmp ( name , \"proxy.config.http.chunking_enabled\" , length ) ) {\n"
                ],
                [
                    44,
                    " case 35 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    45,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.range.write\" , length ) ) {\n"
                ],
                [
                    49,
                    " case 'p' : if ( ! strncmp ( name , \"proxy.config.http.normalize_ae_gzip\" , length ) ) {\n"
                ],
                [
                    55,
                    " case 36 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    56,
                    " case 'p' : if ( ! strncmp ( name , \"proxy.config.http.cache.range.lookup\" , length ) ) {\n"
                ],
                [
                    60,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.net.sock_packet_tos_out\" , length ) ) {\n"
                ],
                [
                    64,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.slow.log.threshold\" , length ) ) {\n"
                ],
                [
                    70,
                    " case 37 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    71,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.redirection_enabled\" , length ) ) {\n"
                ],
                [
                    75,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.max_stale_age\" , length ) ) {\n"
                ],
                [
                    89,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.response_server_str\" , length ) ) {\n"
                ],
                [
                    97,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_post_out\" , length ) ) {\n"
                ],
                [
                    112,
                    " case 38 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    113,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.server_tcp_init_cwnd\" , length ) ) {\n"
                ],
                [
                    121,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.send_http11_requests\" , length ) ) {\n"
                ],
                [
                    127,
                    " case 39 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    128,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.body_factory.template_base\" , length ) ) {\n"
                ],
                [
                    133,
                    " case 'm' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_from\" , length ) ) {\n"
                ],
                [
                    137,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_enabled_in\" , length ) ) {\n"
                ],
                [
                    141,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.doc_in_cache_skip_dns\" , length ) ) {\n"
                ],
                [
                    147,
                    " case 40 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    148,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.forward_connect_method\" , length ) ) {\n"
                ],
                [
                    152,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.down_server.cache_time\" , length ) ) {\n"
                ],
                [
                    159,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.url_remap.pristine_host_hdr\" , length ) ) {\n"
                ],
                [
                    169,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.origin_max_connections\" , length ) ) {\n"
                ],
                [
                    182,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_enabled_out\" , length ) ) {\n"
                ],
                [
                    186,
                    " case 'y' : if ( ! strncmp ( name , \"proxy.config.http.cache.fuzz.probability\" , length ) ) {\n"
                ],
                [
                    193,
                    " case 41 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    194,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.response_server_enabled\" , length ) ) {\n"
                ],
                [
                    198,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_cookie\" , length ) ) {\n"
                ],
                [
                    211,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.insert_response_via_str\" , length ) ) {\n"
                ],
                [
                    220,
                    " case 42 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    221,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.negative_caching_enabled\" , length ) ) {\n"
                ],
                [
                    225,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.when_to_revalidate\" , length ) ) {\n"
                ],
                [
                    232,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_referer\" , length ) ) {\n"
                ],
                [
                    240,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.net.sock_recv_buffer_size_out\" , length ) ) {\n"
                ],
                [
                    255,
                    " case 43 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    256,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.negative_caching_lifetime\" , length ) ) {\n"
                ],
                [
                    260,
                    " case 'k' : if ( ! strncmp ( name , \"proxy.config.http.default_buffer_water_mark\" , length ) ) {\n"
                ],
                [
                    264,
                    " case 'l' : if ( ! strncmp ( name , \"proxy.config.http.cache.cluster_cache_local\" , length ) ) {\n"
                ],
                [
                    268,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.cache.heuristic_lm_factor\" , length ) ) {\n"
                ],
                [
                    275,
                    " case 44 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    276,
                    " case 'p' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_client_ip\" , length ) ) {\n"
                ],
                [
                    280,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.open_read_retry_time\" , length ) ) {\n"
                ],
                [
                    286,
                    " case 45 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    287,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.down_server.abort_threshold\" , length ) ) {\n"
                ],
                [
                    294,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_authentication\" , length ) ) {\n"
                ],
                [
                    298,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.anonymize_remove_user_agent\" , length ) ) {\n"
                ],
                [
                    302,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_rr_retries\" , length ) ) {\n"
                ],
                [
                    309,
                    " case 'e' : if ( 0 == strncmp ( name , \"proxy.config.http.auth_server_session_private\" , length ) ) {\n"
                ],
                [
                    313,
                    " case 'y' : if ( ! strncmp ( name , \"proxy.config.http.redirect_use_orig_cache_key\" , length ) ) {\n"
                ],
                [
                    319,
                    " case 46 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    320,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_client_no_cache\" , length ) ) {\n"
                ],
                [
                    339,
                    " case 'r' : if ( ! strncmp ( name , \"proxy.config.http.insert_squid_x_forwarded_for\" , length ) ) {\n"
                ],
                [
                    343,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_max_retries\" , length ) ) {\n"
                ],
                [
                    350,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.forward.proxy_auth_to_parent\" , length ) ) {\n"
                ],
                [
                    354,
                    " case 'h' : if ( 0 == strncmp ( name , \"proxy.config.http.server_session_sharing.match\" , length ) ) {\n"
                ],
                [
                    358,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.cache.open_write_fail_action\" , length ) ) {\n"
                ],
                [
                    364,
                    " case 47 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    365,
                    " case 'b' : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.mark_down_hostdb\" , length ) ) {\n"
                ],
                [
                    369,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.negative_revalidating_enabled\" , length ) ) {\n"
                ],
                [
                    373,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.guaranteed_min_lifetime\" , length ) ) {\n"
                ],
                [
                    380,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.transaction_active_timeout_in\" , length ) ) {\n"
                ],
                [
                    384,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.post_connect_attempts_timeout\" , length ) ) {\n"
                ],
                [
                    390,
                    " case 48 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    391,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.cache.ignore_client_cc_max_age\" , length ) ) {\n"
                ],
                [
                    399,
                    " case '_' : if ( ! strncmp ( name , \"proxy.config.http.transaction_active_timeout_out\" , length ) ) {\n"
                ],
                [
                    403,
                    " case 'e' : if ( ! strncmp ( name , \"proxy.config.http.background_fill_active_timeout\" , length ) ) {\n"
                ],
                [
                    411,
                    " case 49 : if ( ! strncmp ( name , \"proxy.config.http.attach_server_session_to_client\" , length ) ) {\n"
                ],
                [
                    415,
                    " case 50 : if ( ! strncmp ( name , \"proxy.config.http.cache.cache_responses_to_cookies\" , length ) ) {\n"
                ],
                [
                    419,
                    " case 51 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    420,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_no_activity_timeout_in\" , length ) ) {\n"
                ],
                [
                    424,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.post.check.content_length.enabled\" , length ) ) {\n"
                ],
                [
                    430,
                    " case 52 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    431,
                    " case 'c' : if ( ! strncmp ( name , \"proxy.config.http.cache.cache_urls_that_look_dynamic\" , length ) ) {\n"
                ],
                [
                    435,
                    " case 'n' : if ( ! strncmp ( name , \"proxy.config.http.transaction_no_activity_timeout_in\" , length ) ) {\n"
                ],
                [
                    439,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.keep_alive_no_activity_timeout_out\" , length ) ) {\n"
                ],
                [
                    448,
                    " case 53 : switch ( name [ length - 1 ] ) {\n"
                ],
                [
                    449,
                    " case 't' : if ( ! strncmp ( name , \"proxy.config.http.transaction_no_activity_timeout_out\" , length ) ) {\n"
                ],
                [
                    453,
                    " case 'd' : if ( ! strncmp ( name , \"proxy.config.http.background_fill_completed_threshold\" , length ) ) {\n"
                ],
                [
                    458,
                    " case 's' : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.total_connect_attempts\" , length ) ) {\n"
                ],
                [
                    464,
                    " case 55 : if ( ! strncmp ( name , \"proxy.config.http.parent_proxy.connect_attempts_timeout\" , length ) ) {\n"
                ],
                [
                    468,
                    " case 58 : if ( ! strncmp ( name , \"proxy.config.http.connect_attempts_max_retries_dead_server\" , length ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int ztype ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n ref tnref ;\n int code = array_get ( imemory , op , ( long ) r_btype ( op - 1 ) , & tnref ) ;\n if ( code < 0 ) return code ;\n if ( ! r_has_type ( & tnref , t_name ) ) {\n check_op ( 2 ) ;\n {\n if ( op [ - 1 ] . value . pstruct != 0x00 ) {\n const char * sname = gs_struct_type_name_string ( gs_object_type ( imemory , op [ - 1 ] . value . pstruct ) ) ;\n int code = name_ref ( imemory , ( const byte * ) sname , strlen ( sname ) , ( ref * ) ( op - 1 ) , 0 ) ;\n if ( code < 0 ) return code ;\n }\n else return_error ( gs_error_stackunderflow ) ;\n }\n r_set_attrs ( op - 1 , a_executable ) ;\n }\n else {\n ref_assign ( op - 1 , & tnref ) ;\n }\n pop ( 1 ) ;\n return 0 ;\n }",
        "hash": 7607805321589710329,
        "project": "debian",
        "size": 23,
        "slice": {
            "strlen": [
                [
                    1,
                    "static int ztype ( i_ctx_t * i_ctx_p ) {\n"
                ],
                [
                    9,
                    " if ( op [ - 1 ] . value . pstruct != 0x00 ) {\n"
                ],
                [
                    10,
                    " const char * sname = gs_struct_type_name_string ( gs_object_type ( imemory , op [ - 1 ] . value . pstruct ) ) ;\n"
                ],
                [
                    11,
                    " int code = name_ref ( imemory , ( const byte * ) sname , strlen ( sname ) , ( ref * ) ( op - 1 ) , 0 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int ztype ( i_ctx_t * i_ctx_p ) {\n"
                ],
                [
                    9,
                    " if ( op [ - 1 ] . value . pstruct != 0x00 ) {\n"
                ],
                [
                    10,
                    " const char * sname = gs_struct_type_name_string ( gs_object_type ( imemory , op [ - 1 ] . value . pstruct ) ) ;\n"
                ],
                [
                    11,
                    " int code = name_ref ( imemory , ( const byte * ) sname , strlen ( sname ) , ( ref * ) ( op - 1 ) , 0 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int ssl3_send_finished ( SSL * s , int a , int b , const char * sender , int slen ) {\n unsigned char * p , * d ;\n int i ;\n unsigned long l ;\n if ( s -> state == a ) {\n d = ( unsigned char * ) s -> init_buf -> data ;\n p = & ( d [ 4 ] ) ;\n i = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . finish_md ) ;\n s -> s3 -> tmp . finish_md_len = i ;\n memcpy ( p , s -> s3 -> tmp . finish_md , i ) ;\n p += i ;\n l = i ;\n if ( s -> type == SSL_ST_CONNECT ) {\n OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . finish_md , i ) ;\n s -> s3 -> previous_client_finished_len = i ;\n }\n else {\n OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . finish_md , i ) ;\n s -> s3 -> previous_server_finished_len = i ;\n }\n # ifdef OPENSSL_SYS_WIN16 l &= 0xffff ;\n # endif * ( d ++ ) = SSL3_MT_FINISHED ;\n l2n3 ( l , d ) ;\n s -> init_num = ( int ) l + 4 ;\n s -> init_off = 0 ;\n s -> state = b ;\n }\n return ( ssl3_do_write ( s , SSL3_RT_HANDSHAKE ) ) ;\n }",
        "hash": 5524055408114021500,
        "project": "debian",
        "size": 31,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int ssl3_send_finished ( SSL * s , int a , int b , const char * sender , int slen ) {\n"
                ],
                [
                    5,
                    " if ( s -> state == a ) {\n"
                ],
                [
                    7,
                    " p = & ( d [ 4 ] ) ;\n"
                ],
                [
                    8,
                    " i = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . finish_md ) ;\n"
                ],
                [
                    10,
                    " memcpy ( p , s -> s3 -> tmp . finish_md , i ) ;\n"
                ],
                [
                    11,
                    " p += i ;\n"
                ],
                [
                    12,
                    " l = i ;\n"
                ],
                [
                    13,
                    " if ( s -> type == SSL_ST_CONNECT ) {\n"
                ],
                [
                    14,
                    " OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n"
                ],
                [
                    15,
                    " memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . finish_md , i ) ;\n"
                ],
                [
                    16,
                    " s -> s3 -> previous_client_finished_len = i ;\n"
                ],
                [
                    19,
                    " OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n"
                ],
                [
                    20,
                    " memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . finish_md , i ) ;\n"
                ],
                [
                    21,
                    " s -> s3 -> previous_server_finished_len = i ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int ssl3_send_finished ( SSL * s , int a , int b , const char * sender , int slen ) {\n"
                ],
                [
                    5,
                    " if ( s -> state == a ) {\n"
                ],
                [
                    7,
                    " p = & ( d [ 4 ] ) ;\n"
                ],
                [
                    8,
                    " i = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . finish_md ) ;\n"
                ],
                [
                    10,
                    " memcpy ( p , s -> s3 -> tmp . finish_md , i ) ;\n"
                ],
                [
                    11,
                    " p += i ;\n"
                ],
                [
                    12,
                    " l = i ;\n"
                ],
                [
                    13,
                    " if ( s -> type == SSL_ST_CONNECT ) {\n"
                ],
                [
                    14,
                    " OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n"
                ],
                [
                    15,
                    " memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . finish_md , i ) ;\n"
                ],
                [
                    16,
                    " s -> s3 -> previous_client_finished_len = i ;\n"
                ],
                [
                    19,
                    " OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n"
                ],
                [
                    20,
                    " memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . finish_md , i ) ;\n"
                ],
                [
                    21,
                    " s -> s3 -> previous_server_finished_len = i ;\n"
                ]
            ]
        }
    },
    {
        "code": "static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n krb5_error_code retval = 0 ;\n char * r = NULL ;\n krb5_data * data = NULL ;\n krb5_int32 count = 0 ;\n krb5_int32 size = 2 ;\n char * component = NULL ;\n data = malloc ( size * sizeof ( krb5_data ) ) ;\n if ( ! data ) {\n retval = ENOMEM ;\n }\n if ( ! retval ) {\n r = strdup ( realm ) ;\n if ( ! r ) {\n retval = ENOMEM ;\n }\n }\n while ( ! retval && ( component = va_arg ( ap , char * ) ) ) {\n if ( count == size ) {\n krb5_data * new_data = NULL ;\n size *= 2 ;\n new_data = realloc ( data , size * sizeof ( krb5_data ) ) ;\n if ( new_data ) {\n data = new_data ;\n }\n else {\n retval = ENOMEM ;\n }\n }\n if ( ! retval ) {\n data [ count ] . length = strlen ( component ) ;\n data [ count ] . data = strdup ( component ) ;\n if ( ! data [ count ] . data ) {\n retval = ENOMEM ;\n }\n count ++ ;\n }\n }\n if ( ! retval ) {\n princ -> type = KRB5_NT_UNKNOWN ;\n princ -> magic = KV5M_PRINCIPAL ;\n princ -> realm = make_data ( r , rlen ) ;\n princ -> data = data ;\n princ -> length = count ;\n r = NULL ;\n data = NULL ;\n }\n if ( data ) {\n while ( -- count >= 0 ) {\n free ( data [ count ] . data ) ;\n }\n free ( data ) ;\n }\n free ( r ) ;\n return retval ;\n }",
        "hash": 4383303759030234417,
        "project": "debian",
        "size": 56,
        "slice": {
            "strlen": [
                [
                    1,
                    "static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n"
                ],
                [
                    7,
                    " char * component = NULL ;\n"
                ],
                [
                    30,
                    " if ( ! retval ) {\n"
                ],
                [
                    31,
                    " data [ count ] . length = strlen ( component ) ;\n"
                ],
                [
                    32,
                    " data [ count ] . data = strdup ( component ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n"
                ],
                [
                    8,
                    " data = malloc ( size * sizeof ( krb5_data ) ) ;\n"
                ],
                [
                    9,
                    " if ( ! data ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n"
                ],
                [
                    3,
                    " char * r = NULL ;\n"
                ],
                [
                    9,
                    " if ( ! data ) {\n"
                ],
                [
                    14,
                    " if ( ! r ) {\n"
                ],
                [
                    22,
                    " new_data = realloc ( data , size * sizeof ( krb5_data ) ) ;\n"
                ],
                [
                    24,
                    " data = new_data ;\n"
                ],
                [
                    45,
                    " r = NULL ;\n"
                ],
                [
                    46,
                    " data = NULL ;\n"
                ],
                [
                    48,
                    " if ( data ) {\n"
                ],
                [
                    49,
                    " while ( -- count >= 0 ) {\n"
                ],
                [
                    50,
                    " free ( data [ count ] . data ) ;\n"
                ],
                [
                    52,
                    " free ( data ) ;\n"
                ],
                [
                    54,
                    " free ( r ) ;\n"
                ]
            ],
            "realloc": [
                [
                    1,
                    "static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n"
                ],
                [
                    9,
                    " if ( ! data ) {\n"
                ],
                [
                    19,
                    " if ( count == size ) {\n"
                ],
                [
                    22,
                    " new_data = realloc ( data , size * sizeof ( krb5_data ) ) ;\n"
                ],
                [
                    24,
                    " data = new_data ;\n"
                ],
                [
                    43,
                    " princ -> data = data ;\n"
                ],
                [
                    52,
                    " free ( data ) ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n"
                ],
                [
                    12,
                    " if ( ! retval ) {\n"
                ],
                [
                    13,
                    " r = strdup ( realm ) ;\n"
                ],
                [
                    14,
                    " if ( ! r ) {\n"
                ],
                [
                    30,
                    " if ( ! retval ) {\n"
                ],
                [
                    31,
                    " data [ count ] . length = strlen ( component ) ;\n"
                ],
                [
                    32,
                    " data [ count ] . data = strdup ( component ) ;\n"
                ],
                [
                    33,
                    " if ( ! data [ count ] . data ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n"
                ],
                [
                    3,
                    " char * r = NULL ;\n"
                ],
                [
                    7,
                    " char * component = NULL ;\n"
                ],
                [
                    8,
                    " data = malloc ( size * sizeof ( krb5_data ) ) ;\n"
                ],
                [
                    9,
                    " if ( ! data ) {\n"
                ],
                [
                    12,
                    " if ( ! retval ) {\n"
                ],
                [
                    13,
                    " r = strdup ( realm ) ;\n"
                ],
                [
                    14,
                    " if ( ! r ) {\n"
                ],
                [
                    19,
                    " if ( count == size ) {\n"
                ],
                [
                    22,
                    " new_data = realloc ( data , size * sizeof ( krb5_data ) ) ;\n"
                ],
                [
                    24,
                    " data = new_data ;\n"
                ],
                [
                    30,
                    " if ( ! retval ) {\n"
                ],
                [
                    31,
                    " data [ count ] . length = strlen ( component ) ;\n"
                ],
                [
                    32,
                    " data [ count ] . data = strdup ( component ) ;\n"
                ],
                [
                    33,
                    " if ( ! data [ count ] . data ) {\n"
                ],
                [
                    43,
                    " princ -> data = data ;\n"
                ],
                [
                    45,
                    " r = NULL ;\n"
                ],
                [
                    46,
                    " data = NULL ;\n"
                ],
                [
                    48,
                    " if ( data ) {\n"
                ],
                [
                    49,
                    " while ( -- count >= 0 ) {\n"
                ],
                [
                    50,
                    " free ( data [ count ] . data ) ;\n"
                ],
                [
                    52,
                    " free ( data ) ;\n"
                ],
                [
                    54,
                    " free ( r ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static char * unescape_word ( struct Curl_easy * data , const char * inputbuff ) {\n char * newp ;\n char * dictp ;\n char * ptr ;\n int len ;\n char ch ;\n int olen = 0 ;\n newp = curl_easy_unescape ( data , inputbuff , 0 , & len ) ;\n if ( ! newp ) return NULL ;\n dictp = malloc ( ( ( size_t ) len ) * 2 + 1 ) ;\n if ( dictp ) {\n for ( ptr = newp ;\n ( ch = * ptr ) != 0 ;\n ptr ++ ) {\n if ( ( ch <= 32 ) || ( ch == 127 ) || ( ch == '\\'' ) || ( ch == '\\\"' ) || ( ch == '\\\\' ) ) {\n dictp [ olen ++ ] = '\\\\' ;\n }\n dictp [ olen ++ ] = ch ;\n }\n dictp [ olen ] = 0 ;\n }\n free ( newp ) ;\n return dictp ;\n }",
        "hash": -6220838201187559331,
        "project": "debian",
        "size": 24,
        "slice": {
            "malloc": [
                [
                    1,
                    "static char * unescape_word ( struct Curl_easy * data , const char * inputbuff ) {\n"
                ],
                [
                    9,
                    " if ( ! newp ) return NULL ;\n"
                ],
                [
                    10,
                    " dictp = malloc ( ( ( size_t ) len ) * 2 + 1 ) ;\n"
                ],
                [
                    23,
                    " return dictp ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static char * unescape_word ( struct Curl_easy * data , const char * inputbuff ) {\n"
                ],
                [
                    9,
                    " if ( ! newp ) return NULL ;\n"
                ],
                [
                    22,
                    " free ( newp ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static char * unescape_word ( struct Curl_easy * data , const char * inputbuff ) {\n"
                ],
                [
                    9,
                    " if ( ! newp ) return NULL ;\n"
                ],
                [
                    10,
                    " dictp = malloc ( ( ( size_t ) len ) * 2 + 1 ) ;\n"
                ],
                [
                    22,
                    " free ( newp ) ;\n"
                ],
                [
                    23,
                    " return dictp ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void process_packet_data ( struct wtap_pkthdr * phdr , Buffer * target , guint8 * buffer , gint len , k12_t * k12 ) {\n guint32 type ;\n guint buffer_offset ;\n guint64 ts ;\n guint32 length ;\n guint32 extra_len ;\n guint32 src_id ;\n k12_src_desc_t * src_desc ;\n phdr -> rec_type = REC_TYPE_PACKET ;\n phdr -> presence_flags = WTAP_HAS_TS ;\n ts = pntoh64 ( buffer + K12_PACKET_TIMESTAMP ) ;\n phdr -> ts . secs = ( guint32 ) ( ( ts / 2000000 ) + 631152000 ) ;\n phdr -> ts . nsecs = ( guint32 ) ( ( ts % 2000000 ) * 500 ) ;\n length = pntoh32 ( buffer + K12_RECORD_FRAME_LEN ) & 0x00001FFF ;\n phdr -> len = phdr -> caplen = length ;\n type = pntoh32 ( buffer + K12_RECORD_TYPE ) ;\n buffer_offset = ( type == K12_REC_D0020 ) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME ;\n ws_buffer_assure_space ( target , length ) ;\n memcpy ( ws_buffer_start_ptr ( target ) , buffer + buffer_offset , length ) ;\n extra_len = len - buffer_offset - length ;\n ws_buffer_assure_space ( & ( k12 -> extra_info ) , extra_len ) ;\n memcpy ( ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) , buffer + buffer_offset + length , extra_len ) ;\n phdr -> pseudo_header . k12 . extra_info = ( guint8 * ) ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) ;\n phdr -> pseudo_header . k12 . extra_length = extra_len ;\n src_id = pntoh32 ( buffer + K12_RECORD_SRC_ID ) ;\n K12_DBG ( 5 , ( \"process_packet_data: src_id=%.8x\" , src_id ) ) ;\n phdr -> pseudo_header . k12 . input = src_id ;\n if ( ! ( src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id ) ) ) ) {\n src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id & K12_RECORD_SRC_ID_MASK ) ) ;\n }\n if ( src_desc ) {\n K12_DBG ( 5 , ( \"process_packet_data: input_name='%s' stack_file='%s' type=%x\" , src_desc -> input_name , src_desc -> stack_file , src_desc -> input_type ) ) ;\n phdr -> pseudo_header . k12 . input_name = src_desc -> input_name ;\n phdr -> pseudo_header . k12 . stack_file = src_desc -> stack_file ;\n phdr -> pseudo_header . k12 . input_type = src_desc -> input_type ;\n switch ( src_desc -> input_type ) {\n case K12_PORT_ATMPVC : if ( ( long ) ( buffer_offset + length + K12_PACKET_OFFSET_CID ) < len ) {\n phdr -> pseudo_header . k12 . input_info . atm . vp = pntoh16 ( buffer + buffer_offset + length + K12_PACKET_OFFSET_VP ) ;\n phdr -> pseudo_header . k12 . input_info . atm . vc = pntoh16 ( buffer + buffer_offset + length + K12_PACKET_OFFSET_VC ) ;\n phdr -> pseudo_header . k12 . input_info . atm . cid = * ( ( unsigned char * ) ( buffer + buffer_offset + length + K12_PACKET_OFFSET_CID ) ) ;\n break ;\n }\n default : memcpy ( & ( phdr -> pseudo_header . k12 . input_info ) , & ( src_desc -> input_info ) , sizeof ( src_desc -> input_info ) ) ;\n break ;\n }\n }\n else {\n K12_DBG ( 5 , ( \"process_packet_data: NO SRC_RECORD FOUND\" ) ) ;\n memset ( & ( phdr -> pseudo_header . k12 ) , 0 , sizeof ( phdr -> pseudo_header . k12 ) ) ;\n phdr -> pseudo_header . k12 . input_name = \"unknown port\" ;\n phdr -> pseudo_header . k12 . stack_file = \"unknown stack file\" ;\n }\n phdr -> pseudo_header . k12 . input = src_id ;\n phdr -> pseudo_header . k12 . stuff = k12 ;\n }",
        "hash": -5511323081862746166,
        "project": "debian",
        "size": 55,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void process_packet_data ( struct wtap_pkthdr * phdr , Buffer * target , guint8 * buffer , gint len , k12_t * k12 ) {\n"
                ],
                [
                    17,
                    " buffer_offset = ( type == K12_REC_D0020 ) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME ;\n"
                ],
                [
                    18,
                    " ws_buffer_assure_space ( target , length ) ;\n"
                ],
                [
                    19,
                    " memcpy ( ws_buffer_start_ptr ( target ) , buffer + buffer_offset , length ) ;\n"
                ],
                [
                    20,
                    " extra_len = len - buffer_offset - length ;\n"
                ],
                [
                    21,
                    " ws_buffer_assure_space ( & ( k12 -> extra_info ) , extra_len ) ;\n"
                ],
                [
                    22,
                    " memcpy ( ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) , buffer + buffer_offset + length , extra_len ) ;\n"
                ],
                [
                    24,
                    " phdr -> pseudo_header . k12 . extra_length = extra_len ;\n"
                ],
                [
                    28,
                    " if ( ! ( src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id ) ) ) ) {\n"
                ],
                [
                    29,
                    " src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id & K12_RECORD_SRC_ID_MASK ) ) ;\n"
                ],
                [
                    36,
                    " switch ( src_desc -> input_type ) {\n"
                ],
                [
                    37,
                    " case K12_PORT_ATMPVC : if ( ( long ) ( buffer_offset + length + K12_PACKET_OFFSET_CID ) < len ) {\n"
                ],
                [
                    43,
                    " default : memcpy ( & ( phdr -> pseudo_header . k12 . input_info ) , & ( src_desc -> input_info ) , sizeof ( src_desc -> input_info ) ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static void process_packet_data ( struct wtap_pkthdr * phdr , Buffer * target , guint8 * buffer , gint len , k12_t * k12 ) {\n"
                ],
                [
                    23,
                    " phdr -> pseudo_header . k12 . extra_info = ( guint8 * ) ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) ;\n"
                ],
                [
                    24,
                    " phdr -> pseudo_header . k12 . extra_length = extra_len ;\n"
                ],
                [
                    27,
                    " phdr -> pseudo_header . k12 . input = src_id ;\n"
                ],
                [
                    31,
                    " if ( src_desc ) {\n"
                ],
                [
                    49,
                    " memset ( & ( phdr -> pseudo_header . k12 ) , 0 , sizeof ( phdr -> pseudo_header . k12 ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void process_packet_data ( struct wtap_pkthdr * phdr , Buffer * target , guint8 * buffer , gint len , k12_t * k12 ) {\n"
                ],
                [
                    17,
                    " buffer_offset = ( type == K12_REC_D0020 ) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME ;\n"
                ],
                [
                    18,
                    " ws_buffer_assure_space ( target , length ) ;\n"
                ],
                [
                    19,
                    " memcpy ( ws_buffer_start_ptr ( target ) , buffer + buffer_offset , length ) ;\n"
                ],
                [
                    20,
                    " extra_len = len - buffer_offset - length ;\n"
                ],
                [
                    21,
                    " ws_buffer_assure_space ( & ( k12 -> extra_info ) , extra_len ) ;\n"
                ],
                [
                    22,
                    " memcpy ( ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) , buffer + buffer_offset + length , extra_len ) ;\n"
                ],
                [
                    23,
                    " phdr -> pseudo_header . k12 . extra_info = ( guint8 * ) ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) ;\n"
                ],
                [
                    24,
                    " phdr -> pseudo_header . k12 . extra_length = extra_len ;\n"
                ],
                [
                    27,
                    " phdr -> pseudo_header . k12 . input = src_id ;\n"
                ],
                [
                    28,
                    " if ( ! ( src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id ) ) ) ) {\n"
                ],
                [
                    29,
                    " src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id & K12_RECORD_SRC_ID_MASK ) ) ;\n"
                ],
                [
                    31,
                    " if ( src_desc ) {\n"
                ],
                [
                    36,
                    " switch ( src_desc -> input_type ) {\n"
                ],
                [
                    37,
                    " case K12_PORT_ATMPVC : if ( ( long ) ( buffer_offset + length + K12_PACKET_OFFSET_CID ) < len ) {\n"
                ],
                [
                    43,
                    " default : memcpy ( & ( phdr -> pseudo_header . k12 . input_info ) , & ( src_desc -> input_info ) , sizeof ( src_desc -> input_info ) ) ;\n"
                ],
                [
                    49,
                    " memset ( & ( phdr -> pseudo_header . k12 ) , 0 , sizeof ( phdr -> pseudo_header . k12 ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "struct zip_cdir * _zip_cdir_new ( int nentry , struct zip_error * error ) {\n struct zip_cdir * cd ;\n if ( ( cd = ( struct zip_cdir * ) malloc ( sizeof ( * cd ) ) ) == NULL ) {\n _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n return NULL ;\n }\n if ( ( cd -> entry = ( struct zip_dirent * ) malloc ( sizeof ( * ( cd -> entry ) ) * nentry ) ) == NULL ) {\n _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n free ( cd ) ;\n return NULL ;\n }\n cd -> nentry = nentry ;\n cd -> size = cd -> offset = 0 ;\n cd -> comment = NULL ;\n cd -> comment_len = 0 ;\n return cd ;\n }",
        "hash": -5861712607647761763,
        "project": "debian",
        "size": 17,
        "slice": {
            "malloc": [
                [
                    1,
                    "struct zip_cdir * _zip_cdir_new ( int nentry , struct zip_error * error ) {\n"
                ],
                [
                    3,
                    " if ( ( cd = ( struct zip_cdir * ) malloc ( sizeof ( * cd ) ) ) == NULL ) {\n"
                ],
                [
                    4,
                    " _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n"
                ],
                [
                    5,
                    " return NULL ;\n"
                ],
                [
                    7,
                    " if ( ( cd -> entry = ( struct zip_dirent * ) malloc ( sizeof ( * ( cd -> entry ) ) * nentry ) ) == NULL ) {\n"
                ],
                [
                    8,
                    " _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n"
                ],
                [
                    9,
                    " free ( cd ) ;\n"
                ],
                [
                    10,
                    " return NULL ;\n"
                ],
                [
                    12,
                    " cd -> nentry = nentry ;\n"
                ],
                [
                    13,
                    " cd -> size = cd -> offset = 0 ;\n"
                ],
                [
                    14,
                    " cd -> comment = NULL ;\n"
                ],
                [
                    15,
                    " cd -> comment_len = 0 ;\n"
                ],
                [
                    16,
                    " return cd ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "struct zip_cdir * _zip_cdir_new ( int nentry , struct zip_error * error ) {\n"
                ],
                [
                    3,
                    " if ( ( cd = ( struct zip_cdir * ) malloc ( sizeof ( * cd ) ) ) == NULL ) {\n"
                ],
                [
                    7,
                    " if ( ( cd -> entry = ( struct zip_dirent * ) malloc ( sizeof ( * ( cd -> entry ) ) * nentry ) ) == NULL ) {\n"
                ],
                [
                    9,
                    " free ( cd ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "struct zip_cdir * _zip_cdir_new ( int nentry , struct zip_error * error ) {\n"
                ],
                [
                    3,
                    " if ( ( cd = ( struct zip_cdir * ) malloc ( sizeof ( * cd ) ) ) == NULL ) {\n"
                ],
                [
                    4,
                    " _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n"
                ],
                [
                    5,
                    " return NULL ;\n"
                ],
                [
                    7,
                    " if ( ( cd -> entry = ( struct zip_dirent * ) malloc ( sizeof ( * ( cd -> entry ) ) * nentry ) ) == NULL ) {\n"
                ],
                [
                    8,
                    " _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n"
                ],
                [
                    9,
                    " free ( cd ) ;\n"
                ],
                [
                    10,
                    " return NULL ;\n"
                ],
                [
                    12,
                    " cd -> nentry = nentry ;\n"
                ],
                [
                    13,
                    " cd -> size = cd -> offset = 0 ;\n"
                ],
                [
                    14,
                    " cd -> comment = NULL ;\n"
                ],
                [
                    15,
                    " cd -> comment_len = 0 ;\n"
                ],
                [
                    16,
                    " return cd ;\n"
                ]
            ]
        }
    },
    {
        "code": "static char * pool_strdup ( const char * s ) {\n char * r = pool_alloc ( strlen ( s ) + 1 ) ;\n strcpy ( r , s ) ;\n return r ;\n }",
        "hash": -3889154245145551951,
        "project": "debian",
        "size": 5,
        "slice": {
            "strlen": [
                [
                    1,
                    "static char * pool_strdup ( const char * s ) {\n"
                ],
                [
                    2,
                    " char * r = pool_alloc ( strlen ( s ) + 1 ) ;\n"
                ],
                [
                    3,
                    " strcpy ( r , s ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static char * pool_strdup ( const char * s ) {\n"
                ],
                [
                    2,
                    " char * r = pool_alloc ( strlen ( s ) + 1 ) ;\n"
                ],
                [
                    3,
                    " strcpy ( r , s ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static afs_int32 newEntry ( struct rx_call * call , char aname [ ] , afs_int32 flag , afs_int32 oid , afs_int32 * aid , afs_int32 * cid ) {\n afs_int32 code ;\n struct ubik_trans * tt ;\n int admin ;\n char cname [ PR_MAXNAMELEN ] ;\n stolower ( aname ) ;\n code = Initdb ( ) ;\n if ( code ) return code ;\n code = ubik_BeginTrans ( dbase , UBIK_WRITETRANS , & tt ) ;\n if ( code ) return code ;\n code = ubik_SetLock ( tt , 1 , 1 , LOCKWRITE ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = read_DbHeader ( tt ) ;\n if ( code ) ABORT_WITH ( tt , code ) ;\n code = WhoIsThisWithName ( call , tt , cid , cname ) ;\n if ( code != 2 ) {\n if ( code ) ABORT_WITH ( tt , PRPERM ) ;\n admin = IsAMemberOf ( tt , * cid , SYSADMINID ) ;\n }\n else {\n admin = ( ( ! restricted && ! strcmp ( aname , cname ) ) ) || IsAMemberOf ( tt , * cid , SYSADMINID ) ;\n oid = * cid = SYSADMINID ;\n }\n if ( ! CreateOK ( tt , * cid , oid , flag , admin ) ) ABORT_WITH ( tt , PRPERM ) ;\n code = CreateEntry ( tt , aname , aid , 0 , flag , oid , * cid ) ;\n if ( code != PRSUCCESS ) ABORT_WITH ( tt , code ) ;\n code = ubik_EndTrans ( tt ) ;\n if ( code ) return code ;\n return PRSUCCESS ;\n }",
        "hash": 6343276067273564310,
        "project": "debian",
        "size": 30,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static afs_int32 newEntry ( struct rx_call * call , char aname [ ] , afs_int32 flag , afs_int32 oid , afs_int32 * aid , afs_int32 * cid ) {\n"
                ],
                [
                    6,
                    " stolower ( aname ) ;\n"
                ],
                [
                    15,
                    " code = WhoIsThisWithName ( call , tt , cid , cname ) ;\n"
                ],
                [
                    16,
                    " if ( code != 2 ) {\n"
                ],
                [
                    21,
                    " admin = ( ( ! restricted && ! strcmp ( aname , cname ) ) ) || IsAMemberOf ( tt , * cid , SYSADMINID ) ;\n"
                ],
                [
                    24,
                    " if ( ! CreateOK ( tt , * cid , oid , flag , admin ) ) ABORT_WITH ( tt , PRPERM ) ;\n"
                ],
                [
                    25,
                    " code = CreateEntry ( tt , aname , aid , 0 , flag , oid , * cid ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static afs_int32 newEntry ( struct rx_call * call , char aname [ ] , afs_int32 flag , afs_int32 oid , afs_int32 * aid , afs_int32 * cid ) {\n"
                ],
                [
                    6,
                    " stolower ( aname ) ;\n"
                ],
                [
                    15,
                    " code = WhoIsThisWithName ( call , tt , cid , cname ) ;\n"
                ],
                [
                    16,
                    " if ( code != 2 ) {\n"
                ],
                [
                    21,
                    " admin = ( ( ! restricted && ! strcmp ( aname , cname ) ) ) || IsAMemberOf ( tt , * cid , SYSADMINID ) ;\n"
                ],
                [
                    24,
                    " if ( ! CreateOK ( tt , * cid , oid , flag , admin ) ) ABORT_WITH ( tt , PRPERM ) ;\n"
                ],
                [
                    25,
                    " code = CreateEntry ( tt , aname , aid , 0 , flag , oid , * cid ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "apr_status_t modsecurity_tx_init ( modsec_rec * msr ) {\n const char * s = NULL ;\n const apr_array_header_t * arr ;\n char * semicolon = NULL ;\n char * comma = NULL ;\n apr_table_entry_t * te ;\n int i ;\n apr_pool_cleanup_register ( msr -> mp , msr , modsecurity_tx_cleanup , apr_pool_cleanup_null ) ;\n msr -> request_content_length = - 1 ;\n s = apr_table_get ( msr -> request_headers , \"Content-Length\" ) ;\n if ( s != NULL ) {\n msr -> request_content_length = strtol ( s , NULL , 10 ) ;\n }\n msr -> reqbody_chunked = 0 ;\n msr -> reqbody_should_exist = 0 ;\n if ( msr -> request_content_length == - 1 ) {\n char * transfer_encoding = ( char * ) apr_table_get ( msr -> request_headers , \"Transfer-Encoding\" ) ;\n if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , \"chunked\" ) != NULL ) ) {\n msr -> reqbody_should_exist = 1 ;\n msr -> reqbody_chunked = 1 ;\n }\n }\n else {\n msr -> reqbody_should_exist = 1 ;\n }\n msr -> request_content_type = NULL ;\n s = apr_table_get ( msr -> request_headers , \"Content-Type\" ) ;\n if ( s != NULL ) msr -> request_content_type = s ;\n if ( ( msr -> request_content_type != NULL ) && ( strncasecmp ( msr -> request_content_type , \"application/x-www-form-urlencoded\" , 33 ) == 0 ) ) {\n msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ;\n msr -> msc_reqbody_spilltodisk = 0 ;\n msr -> msc_reqbody_processor = \"URLENCODED\" ;\n }\n else {\n if ( ( msr -> request_content_length != - 1 ) && ( msr -> request_content_length > msr -> txcfg -> reqbody_inmemory_limit ) ) {\n msr -> msc_reqbody_storage = MSC_REQBODY_DISK ;\n }\n msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ;\n msr -> msc_reqbody_spilltodisk = 1 ;\n if ( msr -> request_content_type != NULL ) {\n if ( strncasecmp ( msr -> request_content_type , \"multipart/form-data\" , 19 ) == 0 ) {\n msr -> msc_reqbody_processor = \"MULTIPART\" ;\n }\n }\n }\n if ( msr -> txcfg -> reqbody_buffering != REQUEST_BODY_FORCEBUF_OFF ) {\n msr -> msc_reqbody_storage = MSC_REQBODY_MEMORY ;\n msr -> msc_reqbody_spilltodisk = 0 ;\n }\n msr -> arguments = apr_table_make ( msr -> mp , 32 ) ;\n if ( msr -> arguments == NULL ) return - 1 ;\n if ( msr -> query_string != NULL ) {\n int invalid_count = 0 ;\n if ( parse_arguments ( msr , msr -> query_string , strlen ( msr -> query_string ) , msr -> txcfg -> argument_separator , \"QUERY_STRING\" , msr -> arguments , & invalid_count ) < 0 ) {\n msr_log ( msr , 1 , \"Initialisation: Error occurred while parsing QUERY_STRING arguments.\" ) ;\n return - 1 ;\n }\n if ( invalid_count ) {\n msr -> urlencoded_error = 1 ;\n }\n }\n msr -> arguments_to_sanitize = apr_table_make ( msr -> mp , 16 ) ;\n if ( msr -> arguments_to_sanitize == NULL ) return - 1 ;\n msr -> request_headers_to_sanitize = apr_table_make ( msr -> mp , 16 ) ;\n if ( msr -> request_headers_to_sanitize == NULL ) return - 1 ;\n msr -> response_headers_to_sanitize = apr_table_make ( msr -> mp , 16 ) ;\n if ( msr -> response_headers_to_sanitize == NULL ) return - 1 ;\n msr -> pattern_to_sanitize = apr_table_make ( msr -> mp , 32 ) ;\n if ( msr -> pattern_to_sanitize == NULL ) return - 1 ;\n msr -> removed_targets = apr_table_make ( msr -> mp , 16 ) ;\n if ( msr -> removed_targets == NULL ) return - 1 ;\n msr -> request_cookies = apr_table_make ( msr -> mp , 16 ) ;\n if ( msr -> request_cookies == NULL ) return - 1 ;\n msr -> matched_vars = apr_table_make ( msr -> mp , 8 ) ;\n if ( msr -> matched_vars == NULL ) return - 1 ;\n apr_table_clear ( msr -> matched_vars ) ;\n msr -> perf_rules = apr_table_make ( msr -> mp , 8 ) ;\n if ( msr -> perf_rules == NULL ) return - 1 ;\n apr_table_clear ( msr -> perf_rules ) ;\n arr = apr_table_elts ( msr -> request_headers ) ;\n te = ( apr_table_entry_t * ) arr -> elts ;\n for ( i = 0 ;\n i < arr -> nelts ;\n i ++ ) {\n if ( strcasecmp ( te [ i ] . key , \"Cookie\" ) == 0 ) {\n if ( msr -> txcfg -> cookie_format == COOKIES_V0 ) {\n semicolon = apr_pstrdup ( msr -> mp , te [ i ] . val ) ;\n while ( ( * semicolon != 0 ) && ( * semicolon != ';\n' ) ) semicolon ++ ;\n if ( * semicolon == ';\n' ) {\n parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , \";\n\" ) ;\n }\n else {\n comma = apr_pstrdup ( msr -> mp , te [ i ] . val ) ;\n while ( ( * comma != 0 ) && ( * comma != ',' ) ) comma ++ ;\n if ( * comma == ',' ) {\n comma ++ ;\n if ( * comma == 0x20 ) {\n if ( msr -> txcfg -> debuglog_level >= 5 ) {\n msr_log ( msr , 5 , \"Cookie v0 parser: Using comma as a separator. Semi-colon was not identified!\" ) ;\n }\n parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , \",\" ) ;\n }\n else {\n parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , \";\n\" ) ;\n }\n }\n else {\n parse_cookies_v0 ( msr , te [ i ] . val , msr -> request_cookies , \";\n\" ) ;\n }\n }\n }\n else {\n parse_cookies_v1 ( msr , te [ i ] . val , msr -> request_cookies ) ;\n }\n }\n }\n msr -> tx_vars = apr_table_make ( msr -> mp , 32 ) ;\n if ( msr -> tx_vars == NULL ) return - 1 ;\n msr -> geo_vars = apr_table_make ( msr -> mp , 8 ) ;\n if ( msr -> geo_vars == NULL ) return - 1 ;\n msr -> collections_original = apr_table_make ( msr -> mp , 8 ) ;\n if ( msr -> collections_original == NULL ) return - 1 ;\n msr -> collections = apr_table_make ( msr -> mp , 8 ) ;\n if ( msr -> collections == NULL ) return - 1 ;\n msr -> collections_dirty = apr_table_make ( msr -> mp , 8 ) ;\n if ( msr -> collections_dirty == NULL ) return - 1 ;\n msr -> tcache = NULL ;\n msr -> tcache_items = 0 ;\n msr -> matched_rules = apr_array_make ( msr -> mp , 16 , sizeof ( void * ) ) ;\n if ( msr -> matched_rules == NULL ) return - 1 ;\n msr -> matched_var = ( msc_string * ) apr_pcalloc ( msr -> mp , sizeof ( msc_string ) ) ;\n if ( msr -> matched_var == NULL ) return - 1 ;\n msr -> highest_severity = 255 ;\n msr -> removed_rules = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ;\n if ( msr -> removed_rules == NULL ) return - 1 ;\n msr -> removed_rules_tag = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ;\n if ( msr -> removed_rules_tag == NULL ) return - 1 ;\n msr -> removed_rules_msg = apr_array_make ( msr -> mp , 16 , sizeof ( char * ) ) ;\n if ( msr -> removed_rules_msg == NULL ) return - 1 ;\n return 1 ;\n }",
        "hash": -7683902591435073306,
        "project": "debian",
        "size": 146,
        "slice": {
            "strlen": [
                [
                    8,
                    " apr_pool_cleanup_register ( msr -> mp , msr , modsecurity_tx_cleanup , apr_pool_cleanup_null ) ;\n"
                ],
                [
                    52,
                    " if ( msr -> query_string != NULL ) {\n"
                ],
                [
                    54,
                    " if ( parse_arguments ( msr , msr -> query_string , strlen ( msr -> query_string ) , msr -> txcfg -> argument_separator , \"QUERY_STRING\" , msr -> arguments , & invalid_count ) < 0 ) {\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "apr_status_t modsecurity_tx_init ( modsec_rec * msr ) {\n"
                ],
                [
                    16,
                    " if ( msr -> request_content_length == - 1 ) {\n"
                ],
                [
                    18,
                    " if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , \"chunked\" ) != NULL ) ) {\n"
                ],
                [
                    19,
                    " msr -> reqbody_should_exist = 1 ;\n"
                ],
                [
                    20,
                    " msr -> reqbody_chunked = 1 ;\n"
                ],
                [
                    26,
                    " msr -> request_content_type = NULL ;\n"
                ],
                [
                    28,
                    " if ( s != NULL ) msr -> request_content_type = s ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "apr_status_t modsecurity_tx_init ( modsec_rec * msr ) {\n"
                ],
                [
                    8,
                    " apr_pool_cleanup_register ( msr -> mp , msr , modsecurity_tx_cleanup , apr_pool_cleanup_null ) ;\n"
                ],
                [
                    16,
                    " if ( msr -> request_content_length == - 1 ) {\n"
                ],
                [
                    18,
                    " if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , \"chunked\" ) != NULL ) ) {\n"
                ],
                [
                    19,
                    " msr -> reqbody_should_exist = 1 ;\n"
                ],
                [
                    20,
                    " msr -> reqbody_chunked = 1 ;\n"
                ],
                [
                    26,
                    " msr -> request_content_type = NULL ;\n"
                ],
                [
                    28,
                    " if ( s != NULL ) msr -> request_content_type = s ;\n"
                ],
                [
                    52,
                    " if ( msr -> query_string != NULL ) {\n"
                ],
                [
                    54,
                    " if ( parse_arguments ( msr , msr -> query_string , strlen ( msr -> query_string ) , msr -> txcfg -> argument_separator , \"QUERY_STRING\" , msr -> arguments , & invalid_count ) < 0 ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static void create_watching_parent ( void ) {\n pid_t child ;\n sigset_t ourset ;\n struct sigaction oldact [ 3 ] ;\n int status = 0 ;\n int retval ;\n retval = pam_open_session ( pamh , 0 ) ;\n if ( is_pam_failure ( retval ) ) {\n cleanup_pam ( retval ) ;\n errx ( EXIT_FAILURE , _ ( \"cannot open session: %s\" ) , pam_strerror ( pamh , retval ) ) ;\n }\n else _pam_session_opened = 1 ;\n memset ( oldact , 0 , sizeof ( oldact ) ) ;\n child = fork ( ) ;\n if ( child == ( pid_t ) - 1 ) {\n cleanup_pam ( PAM_ABORT ) ;\n err ( EXIT_FAILURE , _ ( \"cannot create child process\" ) ) ;\n }\n if ( child == 0 ) return ;\n if ( chdir ( \"/\" ) != 0 ) warn ( _ ( \"cannot change directory to %s\" ) , \"/\" ) ;\n sigfillset ( & ourset ) ;\n if ( sigprocmask ( SIG_BLOCK , & ourset , NULL ) ) {\n warn ( _ ( \"cannot block signals\" ) ) ;\n caught_signal = true ;\n }\n if ( ! caught_signal ) {\n struct sigaction action ;\n action . sa_handler = su_catch_sig ;\n sigemptyset ( & action . sa_mask ) ;\n action . sa_flags = 0 ;\n sigemptyset ( & ourset ) ;\n if ( ! same_session ) {\n if ( sigaddset ( & ourset , SIGINT ) || sigaddset ( & ourset , SIGQUIT ) ) {\n warn ( _ ( \"cannot set signal handler\" ) ) ;\n caught_signal = true ;\n }\n }\n if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) {\n warn ( _ ( \"cannot set signal handler\" ) ) ;\n caught_signal = true ;\n }\n if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) {\n warn ( _ ( \"cannot set signal handler\" ) ) ;\n caught_signal = true ;\n }\n }\n if ( ! caught_signal ) {\n pid_t pid ;\n for ( ;\n ;\n ) {\n pid = waitpid ( child , & status , WUNTRACED ) ;\n if ( pid != ( pid_t ) - 1 && WIFSTOPPED ( status ) ) {\n kill ( getpid ( ) , SIGSTOP ) ;\n kill ( pid , SIGCONT ) ;\n }\n else break ;\n }\n if ( pid != ( pid_t ) - 1 ) {\n if ( WIFSIGNALED ( status ) ) {\n fprintf ( stderr , \"%s%s\\n\" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( \" (core dumped)\" ) : \"\" ) ;\n status = WTERMSIG ( status ) + 128 ;\n }\n else status = WEXITSTATUS ( status ) ;\n }\n else if ( caught_signal ) status = caught_signal + 128 ;\n else status = 1 ;\n }\n else status = 1 ;\n if ( caught_signal ) {\n fprintf ( stderr , _ ( \"\\nSession terminated, killing shell...\" ) ) ;\n kill ( child , SIGTERM ) ;\n }\n cleanup_pam ( PAM_SUCCESS ) ;\n if ( caught_signal ) {\n sleep ( 2 ) ;\n kill ( child , SIGKILL ) ;\n fprintf ( stderr , _ ( \" ...killed.\\n\" ) ) ;\n switch ( caught_signal ) {\n case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ;\n break ;\n case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ;\n break ;\n case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ;\n break ;\n default : caught_signal = SIGKILL ;\n break ;\n }\n kill ( getpid ( ) , caught_signal ) ;\n }\n exit ( status ) ;\n }",
        "hash": 9009378236683657160,
        "project": "debian",
        "size": 92,
        "slice": {
            "memset": [
                [
                    1,
                    "static void create_watching_parent ( void ) {\n"
                ],
                [
                    13,
                    " memset ( oldact , 0 , sizeof ( oldact ) ) ;\n"
                ],
                [
                    38,
                    " if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) {\n"
                ],
                [
                    42,
                    " if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) {\n"
                ],
                [
                    80,
                    " case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ;\n"
                ],
                [
                    82,
                    " case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ;\n"
                ],
                [
                    84,
                    " case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void create_watching_parent ( void ) {\n"
                ],
                [
                    60,
                    " if ( WIFSIGNALED ( status ) ) {\n"
                ],
                [
                    61,
                    " fprintf ( stderr , \"%s%s\\n\" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( \" (core dumped)\" ) : \"\" ) ;\n"
                ],
                [
                    70,
                    " if ( caught_signal ) {\n"
                ],
                [
                    71,
                    " fprintf ( stderr , _ ( \"\\nSession terminated, killing shell...\" ) ) ;\n"
                ],
                [
                    75,
                    " if ( caught_signal ) {\n"
                ],
                [
                    78,
                    " fprintf ( stderr , _ ( \" ...killed.\\n\" ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void create_watching_parent ( void ) {\n"
                ],
                [
                    13,
                    " memset ( oldact , 0 , sizeof ( oldact ) ) ;\n"
                ],
                [
                    38,
                    " if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) {\n"
                ],
                [
                    42,
                    " if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) {\n"
                ],
                [
                    60,
                    " if ( WIFSIGNALED ( status ) ) {\n"
                ],
                [
                    61,
                    " fprintf ( stderr , \"%s%s\\n\" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( \" (core dumped)\" ) : \"\" ) ;\n"
                ],
                [
                    70,
                    " if ( caught_signal ) {\n"
                ],
                [
                    71,
                    " fprintf ( stderr , _ ( \"\\nSession terminated, killing shell...\" ) ) ;\n"
                ],
                [
                    75,
                    " if ( caught_signal ) {\n"
                ],
                [
                    78,
                    " fprintf ( stderr , _ ( \" ...killed.\\n\" ) ) ;\n"
                ],
                [
                    80,
                    " case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ;\n"
                ],
                [
                    82,
                    " case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ;\n"
                ],
                [
                    84,
                    " case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void init_t38_info_conv ( packet_info * pinfo ) {\n t38_info_current ++ ;\n if ( t38_info_current == MAX_T38_MESSAGES_IN_PACKET ) {\n t38_info_current = 0 ;\n }\n t38_info = & t38_info_arr [ t38_info_current ] ;\n t38_info -> seq_num = 0 ;\n t38_info -> type_msg = 0 ;\n t38_info -> data_value = 0 ;\n t38_info -> t30ind_value = 0 ;\n t38_info -> setup_frame_number = 0 ;\n t38_info -> Data_Field_field_type_value = 0 ;\n t38_info -> desc [ 0 ] = '\\0' ;\n t38_info -> desc_comment [ 0 ] = '\\0' ;\n t38_info -> time_first_t4_data = 0 ;\n t38_info -> frame_num_first_t4_data = 0 ;\n p_t38_packet_conv = NULL ;\n p_t38_conv = NULL ;\n p_t38_packet_conv = ( t38_conv * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_t38 , 0 ) ;\n p_conv = find_conversation ( pinfo -> fd -> num , & pinfo -> net_dst , & pinfo -> net_src , pinfo -> ptype , pinfo -> destport , pinfo -> srcport , NO_ADDR_B | NO_PORT_B ) ;\n if ( ! p_conv ) {\n p_conv = conversation_new ( pinfo -> fd -> num , & pinfo -> net_src , & pinfo -> net_dst , pinfo -> ptype , pinfo -> srcport , pinfo -> destport , NO_ADDR_B | NO_PORT_B ) ;\n conversation_set_dissector ( p_conv , t38_udp_handle ) ;\n }\n if ( ! p_t38_packet_conv ) {\n p_t38_conv = ( t38_conv * ) conversation_get_proto_data ( p_conv , proto_t38 ) ;\n if ( ! p_t38_conv ) {\n p_t38_conv = wmem_new ( wmem_file_scope ( ) , t38_conv ) ;\n p_t38_conv -> setup_method [ 0 ] = '\\0' ;\n p_t38_conv -> setup_frame_number = 0 ;\n p_t38_conv -> src_t38_info . reass_ID = 0 ;\n p_t38_conv -> src_t38_info . reass_start_seqnum = - 1 ;\n p_t38_conv -> src_t38_info . reass_data_type = 0 ;\n p_t38_conv -> src_t38_info . last_seqnum = - 1 ;\n p_t38_conv -> src_t38_info . packet_lost = 0 ;\n p_t38_conv -> src_t38_info . burst_lost = 0 ;\n p_t38_conv -> src_t38_info . time_first_t4_data = 0 ;\n p_t38_conv -> src_t38_info . additional_hdlc_data_field_counter = 0 ;\n p_t38_conv -> src_t38_info . seqnum_prev_data_field = - 1 ;\n p_t38_conv -> dst_t38_info . reass_ID = 0 ;\n p_t38_conv -> dst_t38_info . reass_start_seqnum = - 1 ;\n p_t38_conv -> dst_t38_info . reass_data_type = 0 ;\n p_t38_conv -> dst_t38_info . last_seqnum = - 1 ;\n p_t38_conv -> dst_t38_info . packet_lost = 0 ;\n p_t38_conv -> dst_t38_info . burst_lost = 0 ;\n p_t38_conv -> dst_t38_info . time_first_t4_data = 0 ;\n p_t38_conv -> dst_t38_info . additional_hdlc_data_field_counter = 0 ;\n p_t38_conv -> dst_t38_info . seqnum_prev_data_field = - 1 ;\n conversation_add_proto_data ( p_conv , proto_t38 , p_t38_conv ) ;\n }\n p_t38_packet_conv = wmem_new ( wmem_file_scope ( ) , t38_conv ) ;\n g_strlcpy ( p_t38_packet_conv -> setup_method , p_t38_conv -> setup_method , MAX_T38_SETUP_METHOD_SIZE ) ;\n p_t38_packet_conv -> setup_frame_number = p_t38_conv -> setup_frame_number ;\n memcpy ( & ( p_t38_packet_conv -> src_t38_info ) , & ( p_t38_conv -> src_t38_info ) , sizeof ( t38_conv_info ) ) ;\n memcpy ( & ( p_t38_packet_conv -> dst_t38_info ) , & ( p_t38_conv -> dst_t38_info ) , sizeof ( t38_conv_info ) ) ;\n p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_t38 , 0 , p_t38_packet_conv ) ;\n }\n if ( ADDRESSES_EQUAL ( & p_conv -> key_ptr -> addr1 , & pinfo -> net_src ) ) {\n p_t38_conv_info = & ( p_t38_conv -> src_t38_info ) ;\n p_t38_packet_conv_info = & ( p_t38_packet_conv -> src_t38_info ) ;\n }\n else {\n p_t38_conv_info = & ( p_t38_conv -> dst_t38_info ) ;\n p_t38_packet_conv_info = & ( p_t38_packet_conv -> dst_t38_info ) ;\n }\n t38_info -> setup_frame_number = p_t38_packet_conv -> setup_frame_number ;\n }",
        "hash": -5640788001150418304,
        "project": "debian",
        "size": 67,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void init_t38_info_conv ( packet_info * pinfo ) {\n"
                ],
                [
                    25,
                    " if ( ! p_t38_packet_conv ) {\n"
                ],
                [
                    27,
                    " if ( ! p_t38_conv ) {\n"
                ],
                [
                    49,
                    " conversation_add_proto_data ( p_conv , proto_t38 , p_t38_conv ) ;\n"
                ],
                [
                    51,
                    " p_t38_packet_conv = wmem_new ( wmem_file_scope ( ) , t38_conv ) ;\n"
                ],
                [
                    54,
                    " memcpy ( & ( p_t38_packet_conv -> src_t38_info ) , & ( p_t38_conv -> src_t38_info ) , sizeof ( t38_conv_info ) ) ;\n"
                ],
                [
                    55,
                    " memcpy ( & ( p_t38_packet_conv -> dst_t38_info ) , & ( p_t38_conv -> dst_t38_info ) , sizeof ( t38_conv_info ) ) ;\n"
                ],
                [
                    59,
                    " p_t38_conv_info = & ( p_t38_conv -> src_t38_info ) ;\n"
                ],
                [
                    60,
                    " p_t38_packet_conv_info = & ( p_t38_packet_conv -> src_t38_info ) ;\n"
                ],
                [
                    63,
                    " p_t38_conv_info = & ( p_t38_conv -> dst_t38_info ) ;\n"
                ],
                [
                    64,
                    " p_t38_packet_conv_info = & ( p_t38_packet_conv -> dst_t38_info ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void init_t38_info_conv ( packet_info * pinfo ) {\n"
                ],
                [
                    25,
                    " if ( ! p_t38_packet_conv ) {\n"
                ],
                [
                    27,
                    " if ( ! p_t38_conv ) {\n"
                ],
                [
                    49,
                    " conversation_add_proto_data ( p_conv , proto_t38 , p_t38_conv ) ;\n"
                ],
                [
                    51,
                    " p_t38_packet_conv = wmem_new ( wmem_file_scope ( ) , t38_conv ) ;\n"
                ],
                [
                    54,
                    " memcpy ( & ( p_t38_packet_conv -> src_t38_info ) , & ( p_t38_conv -> src_t38_info ) , sizeof ( t38_conv_info ) ) ;\n"
                ],
                [
                    55,
                    " memcpy ( & ( p_t38_packet_conv -> dst_t38_info ) , & ( p_t38_conv -> dst_t38_info ) , sizeof ( t38_conv_info ) ) ;\n"
                ],
                [
                    59,
                    " p_t38_conv_info = & ( p_t38_conv -> src_t38_info ) ;\n"
                ],
                [
                    60,
                    " p_t38_packet_conv_info = & ( p_t38_packet_conv -> src_t38_info ) ;\n"
                ],
                [
                    63,
                    " p_t38_conv_info = & ( p_t38_conv -> dst_t38_info ) ;\n"
                ],
                [
                    64,
                    " p_t38_packet_conv_info = & ( p_t38_packet_conv -> dst_t38_info ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void mark_desktop_file_trusted ( CommonJob * common , GCancellable * cancellable , GFile * file , gboolean interactive ) {\n char * contents , * new_contents ;\n gsize length , new_length ;\n GError * error ;\n guint32 current_perms , new_perms ;\n int response ;\n GFileInfo * info ;\n retry : error = NULL ;\n if ( ! g_file_load_contents ( file , cancellable , & contents , & length , NULL , & error ) ) {\n if ( interactive ) {\n response = run_error ( common , g_strdup ( _ ( \"Unable to mark launcher trusted (executable)\" ) ) , error -> message , NULL , FALSE , CANCEL , RETRY , NULL ) ;\n }\n else {\n response = 0 ;\n }\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( common ) ;\n }\n else if ( response == 1 ) {\n goto retry ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n goto out ;\n }\n if ( ! g_str_has_prefix ( contents , \"#!\" ) ) {\n new_length = length + strlen ( TRUSTED_SHEBANG ) ;\n new_contents = g_malloc ( new_length ) ;\n strcpy ( new_contents , TRUSTED_SHEBANG ) ;\n memcpy ( new_contents + strlen ( TRUSTED_SHEBANG ) , contents , length ) ;\n if ( ! g_file_replace_contents ( file , new_contents , new_length , NULL , FALSE , 0 , NULL , cancellable , & error ) ) {\n g_free ( contents ) ;\n g_free ( new_contents ) ;\n if ( interactive ) {\n response = run_error ( common , g_strdup ( _ ( \"Unable to mark launcher trusted (executable)\" ) ) , error -> message , NULL , FALSE , CANCEL , RETRY , NULL ) ;\n }\n else {\n response = 0 ;\n }\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( common ) ;\n }\n else if ( response == 1 ) {\n goto retry ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n goto out ;\n }\n g_free ( new_contents ) ;\n }\n g_free ( contents ) ;\n info = g_file_query_info ( file , G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_UNIX_MODE , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , common -> cancellable , & error ) ;\n if ( info == NULL ) {\n if ( interactive ) {\n response = run_error ( common , g_strdup ( _ ( \"Unable to mark launcher trusted (executable)\" ) ) , error -> message , NULL , FALSE , CANCEL , RETRY , NULL ) ;\n }\n else {\n response = 0 ;\n }\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( common ) ;\n }\n else if ( response == 1 ) {\n goto retry ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n goto out ;\n }\n if ( g_file_info_has_attribute ( info , G_FILE_ATTRIBUTE_UNIX_MODE ) ) {\n current_perms = g_file_info_get_attribute_uint32 ( info , G_FILE_ATTRIBUTE_UNIX_MODE ) ;\n new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH ;\n if ( ( current_perms != new_perms ) && ! g_file_set_attribute_uint32 ( file , G_FILE_ATTRIBUTE_UNIX_MODE , new_perms , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , common -> cancellable , & error ) ) {\n g_object_unref ( info ) ;\n if ( interactive ) {\n response = run_error ( common , g_strdup ( _ ( \"Unable to mark launcher trusted (executable)\" ) ) , error -> message , NULL , FALSE , CANCEL , RETRY , NULL ) ;\n }\n else {\n response = 0 ;\n }\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( common ) ;\n }\n else if ( response == 1 ) {\n goto retry ;\n }\n else {\n g_assert_not_reached ( ) ;\n }\n goto out ;\n }\n }\n g_object_unref ( info ) ;\n out : ;\n }",
        "hash": 1245821301839614810,
        "project": "debian",
        "size": 99,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void mark_desktop_file_trusted ( CommonJob * common , GCancellable * cancellable , GFile * file , gboolean interactive ) {\n"
                ],
                [
                    9,
                    " if ( ! g_file_load_contents ( file , cancellable , & contents , & length , NULL , & error ) ) {\n"
                ],
                [
                    27,
                    " if ( ! g_str_has_prefix ( contents , \"#!\" ) ) {\n"
                ],
                [
                    30,
                    " strcpy ( new_contents , TRUSTED_SHEBANG ) ;\n"
                ],
                [
                    31,
                    " memcpy ( new_contents + strlen ( TRUSTED_SHEBANG ) , contents , length ) ;\n"
                ],
                [
                    33,
                    " g_free ( contents ) ;\n"
                ],
                [
                    54,
                    " g_free ( contents ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static void mark_desktop_file_trusted ( CommonJob * common , GCancellable * cancellable , GFile * file , gboolean interactive ) {\n"
                ],
                [
                    9,
                    " if ( ! g_file_load_contents ( file , cancellable , & contents , & length , NULL , & error ) ) {\n"
                ],
                [
                    27,
                    " if ( ! g_str_has_prefix ( contents , \"#!\" ) ) {\n"
                ],
                [
                    28,
                    " new_length = length + strlen ( TRUSTED_SHEBANG ) ;\n"
                ],
                [
                    29,
                    " new_contents = g_malloc ( new_length ) ;\n"
                ],
                [
                    30,
                    " strcpy ( new_contents , TRUSTED_SHEBANG ) ;\n"
                ],
                [
                    31,
                    " memcpy ( new_contents + strlen ( TRUSTED_SHEBANG ) , contents , length ) ;\n"
                ],
                [
                    33,
                    " g_free ( contents ) ;\n"
                ],
                [
                    54,
                    " g_free ( contents ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void mark_desktop_file_trusted ( CommonJob * common , GCancellable * cancellable , GFile * file , gboolean interactive ) {\n"
                ],
                [
                    9,
                    " if ( ! g_file_load_contents ( file , cancellable , & contents , & length , NULL , & error ) ) {\n"
                ],
                [
                    27,
                    " if ( ! g_str_has_prefix ( contents , \"#!\" ) ) {\n"
                ],
                [
                    28,
                    " new_length = length + strlen ( TRUSTED_SHEBANG ) ;\n"
                ],
                [
                    29,
                    " new_contents = g_malloc ( new_length ) ;\n"
                ],
                [
                    30,
                    " strcpy ( new_contents , TRUSTED_SHEBANG ) ;\n"
                ],
                [
                    31,
                    " memcpy ( new_contents + strlen ( TRUSTED_SHEBANG ) , contents , length ) ;\n"
                ],
                [
                    33,
                    " g_free ( contents ) ;\n"
                ],
                [
                    54,
                    " g_free ( contents ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void steamdiscover_dissect_body_status ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n gint64 value ;\n gint len ;\n gint len2 ;\n protobuf_desc_t pb = {\n tvb , offset , bytes_left }\n ;\n protobuf_desc_t pb2 = {\n tvb , 0 , 0 }\n ;\n protobuf_tag_t tag = {\n 0 , 0 , 0 }\n ;\n wmem_allocator_t * strpool ;\n guint8 * hostname ;\n strpool = wmem_allocator_new ( WMEM_ALLOCATOR_SIMPLE ) ;\n nstime_t timestamp ;\n proto_tree * user_tree ;\n proto_item * user_it ;\n while ( protobuf_iter_next ( & pb , & tag ) ) {\n switch ( tag . field_number ) {\n case STEAMDISCOVER_FN_STATUS_VERSION : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_int ( tree , hf_steam_ihs_discovery_body_status_version , pb . tvb , pb . offset , len , ( gint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_MINVERSION : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_int ( tree , hf_steam_ihs_discovery_body_status_minversion , pb . tvb , pb . offset , len , ( gint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_CONNECTPORT : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_uint ( tree , hf_steam_ihs_discovery_body_status_connectport , pb . tvb , pb . offset , len , ( guint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_HOSTNAME : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_LENGTHDELIMITED ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_item ( tree , hf_steam_ihs_discovery_body_status_hostname , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 | ENC_NA ) ;\n hostname = tvb_get_string_enc ( strpool , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n if ( hostname && strlen ( hostname ) ) {\n col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s from %s\" , hf_steam_ihs_discovery_header_msgtype_strings [ STEAMDISCOVER_MSGTYPE_CLIENTBROADCASTMSGSTATUS ] . strptr , hostname ) ;\n }\n len += ( gint ) value ;\n break ;\n case STEAMDISCOVER_FN_STATUS_ENABLEDSERVICES : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_uint ( tree , hf_steam_ihs_discovery_body_status_enabledservices , pb . tvb , pb . offset , len , ( guint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_OSTYPE : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_int ( tree , hf_steam_ihs_discovery_body_status_ostype , pb . tvb , pb . offset , len , ( gint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_IS64BIT : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_boolean ( tree , hf_steam_ihs_discovery_body_status_is64bit , pb . tvb , pb . offset , len , ( gint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_USERS : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_LENGTHDELIMITED ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n pb2 . offset = pb . offset + len ;\n pb2 . bytes_left = ( gint ) value ;\n len += ( gint ) value ;\n user_tree = proto_tree_add_subtree ( tree , pb . tvb , pb . offset , len , ett_steam_ihs_discovery_body_status_user , & user_it , \"User\" ) ;\n while ( protobuf_iter_next ( & pb2 , & tag ) ) {\n switch ( tag . field_number ) {\n case STEAMDISCOVER_FN_STATUS_USER_STEAMID : if ( ( len2 = protobuf_verify_wiretype ( & pb2 , & tag , pinfo , user_tree , PROTOBUF_WIRETYPE_64BIT ) ) ) break ;\n len2 = 8 ;\n value = tvb_get_letoh64 ( pb2 . tvb , pb2 . offset ) ;\n proto_tree_add_uint64 ( user_tree , hf_steam_ihs_discovery_body_status_user_steamid , pb2 . tvb , pb2 . offset , len2 , ( guint64 ) value ) ;\n proto_item_append_text ( user_it , \", Steam ID: %\" G_GUINT64_FORMAT , ( guint64 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_USER_AUTHKEYID : if ( ( len2 = protobuf_verify_wiretype ( & pb2 , & tag , pinfo , user_tree , PROTOBUF_WIRETYPE_VARINT ) ) ) break ;\n value = get_varint64 ( pb2 . tvb , pb2 . offset , pb2 . bytes_left , & len2 ) ;\n proto_tree_add_uint ( user_tree , hf_steam_ihs_discovery_body_status_user_authkeyid , pb2 . tvb , pb2 . offset , len2 , ( guint32 ) value ) ;\n proto_item_append_text ( user_it , \", Auth Key ID: %\" G_GUINT32_FORMAT , ( guint32 ) value ) ;\n break ;\n default : len2 = protobuf_dissect_unknown_field ( & pb2 , & tag , pinfo , tree , NULL ) ;\n break ;\n }\n protobuf_seek_forward ( & pb2 , len2 ) ;\n }\n break ;\n case STEAMDISCOVER_FN_STATUS_EUNIVERSE : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_int ( tree , hf_steam_ihs_discovery_body_status_euniverse , pb . tvb , pb . offset , len , ( gint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_TIMESTAMP : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n timestamp . secs = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n timestamp . nsecs = 0 ;\n proto_tree_add_time ( tree , hf_steam_ihs_discovery_body_status_timestamp , pb . tvb , pb . offset , len , & timestamp ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_SCREENLOCKED : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_boolean ( tree , hf_steam_ihs_discovery_body_status_screenlocked , pb . tvb , pb . offset , len , ( gint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_GAMESRUNNING : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_VARINT ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_boolean ( tree , hf_steam_ihs_discovery_body_status_gamesrunning , pb . tvb , pb . offset , len , ( gint32 ) value ) ;\n break ;\n case STEAMDISCOVER_FN_STATUS_MACADDRESSES : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_LENGTHDELIMITED ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_item ( tree , hf_steam_ihs_discovery_body_status_macaddresses , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 | ENC_NA ) ;\n len += ( gint ) value ;\n break ;\n default : len = protobuf_dissect_unknown_field ( & pb , & tag , pinfo , tree , NULL ) ;\n break ;\n }\n protobuf_seek_forward ( & pb , len ) ;\n }\n wmem_destroy_allocator ( strpool ) ;\n }",
        "hash": -192019917869801237,
        "project": "debian",
        "size": 108,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void steamdiscover_dissect_body_status ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n"
                ],
                [
                    21,
                    " switch ( tag . field_number ) {\n"
                ],
                [
                    37,
                    " hostname = tvb_get_string_enc ( strpool , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n"
                ],
                [
                    38,
                    " if ( hostname && strlen ( hostname ) ) {\n"
                ],
                [
                    39,
                    " col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s from %s\" , hf_steam_ihs_discovery_header_msgtype_strings [ STEAMDISCOVER_MSGTYPE_CLIENTBROADCASTMSGSTATUS ] . strptr , hostname ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void steamdiscover_dissect_body_status ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n"
                ],
                [
                    21,
                    " switch ( tag . field_number ) {\n"
                ],
                [
                    37,
                    " hostname = tvb_get_string_enc ( strpool , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n"
                ],
                [
                    38,
                    " if ( hostname && strlen ( hostname ) ) {\n"
                ],
                [
                    39,
                    " col_add_fstr ( pinfo -> cinfo , COL_INFO , \"%s from %s\" , hf_steam_ihs_discovery_header_msgtype_strings [ STEAMDISCOVER_MSGTYPE_CLIENTBROADCASTMSGSTATUS ] . strptr , hostname ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void steamdiscover_dissect_body_authrequest ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n guint len ;\n gint64 value ;\n protobuf_desc_t pb = {\n tvb , offset , bytes_left }\n ;\n protobuf_tag_t tag = {\n 0 , 0 , 0 }\n ;\n wmem_allocator_t * strpool ;\n strpool = wmem_allocator_new ( WMEM_ALLOCATOR_SIMPLE ) ;\n guint8 * devicename ;\n while ( protobuf_iter_next ( & pb , & tag ) ) {\n switch ( tag . field_number ) {\n case STEAMDISCOVER_FN_AUTHREQUEST_DEVICETOKEN : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_LENGTHDELIMITED ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_item ( tree , hf_steam_ihs_discovery_body_authrequest_devicetoken , pb . tvb , pb . offset + len , ( gint ) value , ENC_NA ) ;\n len += ( gint ) value ;\n break ;\n case STEAMDISCOVER_FN_AUTHREQUEST_DEVICENAME : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_LENGTHDELIMITED ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_item ( tree , hf_steam_ihs_discovery_body_authrequest_devicename , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 | ENC_NA ) ;\n devicename = tvb_get_string_enc ( strpool , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n if ( devicename && strlen ( devicename ) ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" from %s\" , devicename ) ;\n }\n len += ( gint ) value ;\n break ;\n case STEAMDISCOVER_FN_AUTHREQUEST_ENCRYPTEDREQUEST : STEAMDISCOVER_ENSURE_WIRETYPE ( PROTOBUF_WIRETYPE_LENGTHDELIMITED ) ;\n value = get_varint64 ( pb . tvb , pb . offset , pb . bytes_left , & len ) ;\n proto_tree_add_item ( tree , hf_steam_ihs_discovery_body_authrequest_encryptedrequest , pb . tvb , pb . offset + len , ( gint ) value , ENC_NA ) ;\n len += ( gint ) value ;\n break ;\n default : len = protobuf_dissect_unknown_field ( & pb , & tag , pinfo , tree , NULL ) ;\n break ;\n }\n protobuf_seek_forward ( & pb , len ) ;\n }\n wmem_destroy_allocator ( strpool ) ;\n }",
        "hash": -192019917869801237,
        "project": "debian",
        "size": 40,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void steamdiscover_dissect_body_authrequest ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n"
                ],
                [
                    14,
                    " switch ( tag . field_number ) {\n"
                ],
                [
                    23,
                    " devicename = tvb_get_string_enc ( strpool , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n"
                ],
                [
                    24,
                    " if ( devicename && strlen ( devicename ) ) {\n"
                ],
                [
                    25,
                    " col_append_fstr ( pinfo -> cinfo , COL_INFO , \" from %s\" , devicename ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void steamdiscover_dissect_body_authrequest ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n"
                ],
                [
                    14,
                    " switch ( tag . field_number ) {\n"
                ],
                [
                    23,
                    " devicename = tvb_get_string_enc ( strpool , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n"
                ],
                [
                    24,
                    " if ( devicename && strlen ( devicename ) ) {\n"
                ],
                [
                    25,
                    " col_append_fstr ( pinfo -> cinfo , COL_INFO , \" from %s\" , devicename ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static CURLcode glob_range ( URLGlob * glob , char * * patternp , size_t * posp , unsigned long * amount , int globindex ) {\n URLPattern * pat ;\n int rc ;\n char * pattern = * patternp ;\n char * c ;\n pat = & glob -> pattern [ glob -> size ] ;\n pat -> globindex = globindex ;\n if ( ISALPHA ( * pattern ) ) {\n char min_c ;\n char max_c ;\n int step = 1 ;\n pat -> type = UPTCharRange ;\n rc = sscanf ( pattern , \"%c-%c\" , & min_c , & max_c ) ;\n if ( ( rc == 2 ) && ( pattern [ 3 ] == ':' ) ) {\n char * endp ;\n unsigned long lstep ;\n errno = 0 ;\n lstep = strtoul ( & pattern [ 4 ] , & endp , 10 ) ;\n if ( errno || ( * endp != ']' ) ) step = - 1 ;\n else {\n pattern = endp + 1 ;\n step = ( int ) lstep ;\n if ( step > ( max_c - min_c ) ) step = - 1 ;\n }\n }\n else pattern += 4 ;\n * posp += ( pattern - * patternp ) ;\n if ( ( rc != 2 ) || ( min_c >= max_c ) || ( ( max_c - min_c ) > ( 'z' - 'a' ) ) || ( step <= 0 ) ) return GLOBERROR ( \"bad range\" , * posp , CURLE_URL_MALFORMAT ) ;\n pat -> content . CharRange . step = step ;\n pat -> content . CharRange . ptr_c = pat -> content . CharRange . min_c = min_c ;\n pat -> content . CharRange . max_c = max_c ;\n if ( multiply ( amount , ( pat -> content . CharRange . max_c - pat -> content . CharRange . min_c ) / pat -> content . CharRange . step + 1 ) ) return GLOBERROR ( \"range overflow\" , * posp , CURLE_URL_MALFORMAT ) ;\n }\n else if ( ISDIGIT ( * pattern ) ) {\n unsigned long min_n ;\n unsigned long max_n = 0 ;\n unsigned long step_n = 0 ;\n char * endp ;\n pat -> type = UPTNumRange ;\n pat -> content . NumRange . padlength = 0 ;\n if ( * pattern == '0' ) {\n c = pattern ;\n while ( ISDIGIT ( * c ) ) {\n c ++ ;\n ++ pat -> content . NumRange . padlength ;\n }\n }\n errno = 0 ;\n min_n = strtoul ( pattern , & endp , 10 ) ;\n if ( errno || ( endp == pattern ) ) endp = NULL ;\n else {\n if ( * endp != '-' ) endp = NULL ;\n else {\n pattern = endp + 1 ;\n errno = 0 ;\n max_n = strtoul ( pattern , & endp , 10 ) ;\n if ( errno || ( * endp == ':' ) ) {\n pattern = endp + 1 ;\n errno = 0 ;\n step_n = strtoul ( pattern , & endp , 10 ) ;\n if ( errno ) endp = NULL ;\n }\n else step_n = 1 ;\n if ( endp && ( * endp == ']' ) ) {\n pattern = endp + 1 ;\n }\n else endp = NULL ;\n }\n }\n * posp += ( pattern - * patternp ) ;\n if ( ! endp || ( min_n > max_n ) || ( step_n > ( max_n - min_n ) ) || ! step_n ) return GLOBERROR ( \"bad range\" , * posp , CURLE_URL_MALFORMAT ) ;\n pat -> content . NumRange . ptr_n = pat -> content . NumRange . min_n = min_n ;\n pat -> content . NumRange . max_n = max_n ;\n pat -> content . NumRange . step = step_n ;\n if ( multiply ( amount , ( pat -> content . NumRange . max_n - pat -> content . NumRange . min_n ) / pat -> content . NumRange . step + 1 ) ) return GLOBERROR ( \"range overflow\" , * posp , CURLE_URL_MALFORMAT ) ;\n }\n else return GLOBERROR ( \"bad range specification\" , * posp , CURLE_URL_MALFORMAT ) ;\n * patternp = pattern ;\n return CURLE_OK ;\n }",
        "hash": 1105505185808271410,
        "project": "debian",
        "size": 80,
        "slice": {
            "sscanf": [
                [
                    1,
                    "static CURLcode glob_range ( URLGlob * glob , char * * patternp , size_t * posp , unsigned long * amount , int globindex ) {\n"
                ],
                [
                    4,
                    " char * pattern = * patternp ;\n"
                ],
                [
                    8,
                    " if ( ISALPHA ( * pattern ) ) {\n"
                ],
                [
                    13,
                    " rc = sscanf ( pattern , \"%c-%c\" , & min_c , & max_c ) ;\n"
                ],
                [
                    14,
                    " if ( ( rc == 2 ) && ( pattern [ 3 ] == ':' ) ) {\n"
                ],
                [
                    18,
                    " lstep = strtoul ( & pattern [ 4 ] , & endp , 10 ) ;\n"
                ],
                [
                    23,
                    " if ( step > ( max_c - min_c ) ) step = - 1 ;\n"
                ],
                [
                    26,
                    " else pattern += 4 ;\n"
                ],
                [
                    27,
                    " * posp += ( pattern - * patternp ) ;\n"
                ],
                [
                    28,
                    " if ( ( rc != 2 ) || ( min_c >= max_c ) || ( ( max_c - min_c ) > ( 'z' - 'a' ) ) || ( step <= 0 ) ) return GLOBERROR ( \"bad range\" , * posp , CURLE_URL_MALFORMAT ) ;\n"
                ],
                [
                    30,
                    " pat -> content . CharRange . ptr_c = pat -> content . CharRange . min_c = min_c ;\n"
                ],
                [
                    31,
                    " pat -> content . CharRange . max_c = max_c ;\n"
                ],
                [
                    78,
                    " * patternp = pattern ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static CURLcode glob_range ( URLGlob * glob , char * * patternp , size_t * posp , unsigned long * amount , int globindex ) {\n"
                ],
                [
                    4,
                    " char * pattern = * patternp ;\n"
                ],
                [
                    8,
                    " if ( ISALPHA ( * pattern ) ) {\n"
                ],
                [
                    13,
                    " rc = sscanf ( pattern , \"%c-%c\" , & min_c , & max_c ) ;\n"
                ],
                [
                    14,
                    " if ( ( rc == 2 ) && ( pattern [ 3 ] == ':' ) ) {\n"
                ],
                [
                    18,
                    " lstep = strtoul ( & pattern [ 4 ] , & endp , 10 ) ;\n"
                ],
                [
                    23,
                    " if ( step > ( max_c - min_c ) ) step = - 1 ;\n"
                ],
                [
                    26,
                    " else pattern += 4 ;\n"
                ],
                [
                    27,
                    " * posp += ( pattern - * patternp ) ;\n"
                ],
                [
                    28,
                    " if ( ( rc != 2 ) || ( min_c >= max_c ) || ( ( max_c - min_c ) > ( 'z' - 'a' ) ) || ( step <= 0 ) ) return GLOBERROR ( \"bad range\" , * posp , CURLE_URL_MALFORMAT ) ;\n"
                ],
                [
                    30,
                    " pat -> content . CharRange . ptr_c = pat -> content . CharRange . min_c = min_c ;\n"
                ],
                [
                    31,
                    " pat -> content . CharRange . max_c = max_c ;\n"
                ],
                [
                    78,
                    " * patternp = pattern ;\n"
                ]
            ]
        }
    },
    {
        "code": "bool chal_reply_h ( connection_t * c ) {\n char hishash [ MAX_STRING_SIZE ] ;\n char myhash [ EVP_MAX_MD_SIZE ] ;\n EVP_MD_CTX * ctx ;\n if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING , hishash ) != 1 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"CHAL_REPLY\" , c -> name , c -> hostname ) ;\n return false ;\n }\n if ( strlen ( hishash ) != ( size_t ) EVP_MD_size ( c -> outdigest ) * 2 ) {\n logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge reply length\" ) ;\n return false ;\n }\n if ( ! hex2bin ( hishash , hishash , EVP_MD_size ( c -> outdigest ) ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s(%s): %s\" , \"CHAL_REPLY\" , c -> name , c -> hostname , \"invalid hash\" ) ;\n return false ;\n }\n ctx = EVP_MD_CTX_create ( ) ;\n if ( ! ctx ) {\n abort ( ) ;\n }\n if ( ! EVP_DigestInit ( ctx , c -> outdigest ) || ! EVP_DigestUpdate ( ctx , c -> hischallenge , RSA_size ( c -> rsa_key ) ) || ! EVP_DigestFinal ( ctx , ( unsigned char * ) myhash , NULL ) ) {\n EVP_MD_CTX_destroy ( ctx ) ;\n logger ( LOG_ERR , \"Error during calculation of response from %s (%s): %s\" , c -> name , c -> hostname , ERR_error_string ( ERR_get_error ( ) , NULL ) ) ;\n return false ;\n }\n EVP_MD_CTX_destroy ( ctx ) ;\n if ( memcmp ( hishash , myhash , EVP_MD_size ( c -> outdigest ) ) ) {\n logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge reply\" ) ;\n ifdebug ( SCARY_THINGS ) {\n bin2hex ( myhash , hishash , SHA_DIGEST_LENGTH ) ;\n hishash [ SHA_DIGEST_LENGTH * 2 ] = '\\0' ;\n logger ( LOG_DEBUG , \"Expected challenge reply: %s\" , hishash ) ;\n }\n return false ;\n }\n c -> allow_request = ACK ;\n return send_ack ( c ) ;\n }",
        "hash": 4372812923566076695,
        "project": "debian",
        "size": 38,
        "slice": {
            "memcmp": [
                [
                    1,
                    "bool chal_reply_h ( connection_t * c ) {\n"
                ],
                [
                    3,
                    " char myhash [ EVP_MAX_MD_SIZE ] ;\n"
                ],
                [
                    13,
                    " if ( ! hex2bin ( hishash , hishash , EVP_MD_size ( c -> outdigest ) ) ) {\n"
                ],
                [
                    21,
                    " if ( ! EVP_DigestInit ( ctx , c -> outdigest ) || ! EVP_DigestUpdate ( ctx , c -> hischallenge , RSA_size ( c -> rsa_key ) ) || ! EVP_DigestFinal ( ctx , ( unsigned char * ) myhash , NULL ) ) {\n"
                ],
                [
                    27,
                    " if ( memcmp ( hishash , myhash , EVP_MD_size ( c -> outdigest ) ) ) {\n"
                ],
                [
                    28,
                    " logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge reply\" ) ;\n"
                ],
                [
                    29,
                    " ifdebug ( SCARY_THINGS ) {\n"
                ],
                [
                    30,
                    " bin2hex ( myhash , hishash , SHA_DIGEST_LENGTH ) ;\n"
                ],
                [
                    31,
                    " hishash [ SHA_DIGEST_LENGTH * 2 ] = '\\0' ;\n"
                ],
                [
                    32,
                    " logger ( LOG_DEBUG , \"Expected challenge reply: %s\" , hishash ) ;\n"
                ],
                [
                    34,
                    " return false ;\n"
                ],
                [
                    36,
                    " c -> allow_request = ACK ;\n"
                ],
                [
                    37,
                    " return send_ack ( c ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "bool chal_reply_h ( connection_t * c ) {\n"
                ],
                [
                    2,
                    " char hishash [ MAX_STRING_SIZE ] ;\n"
                ],
                [
                    5,
                    " if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING , hishash ) != 1 ) {\n"
                ],
                [
                    9,
                    " if ( strlen ( hishash ) != ( size_t ) EVP_MD_size ( c -> outdigest ) * 2 ) {\n"
                ],
                [
                    10,
                    " logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge reply length\" ) ;\n"
                ],
                [
                    11,
                    " return false ;\n"
                ],
                [
                    13,
                    " if ( ! hex2bin ( hishash , hishash , EVP_MD_size ( c -> outdigest ) ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "bool chal_reply_h ( connection_t * c ) {\n"
                ],
                [
                    2,
                    " char hishash [ MAX_STRING_SIZE ] ;\n"
                ],
                [
                    3,
                    " char myhash [ EVP_MAX_MD_SIZE ] ;\n"
                ],
                [
                    5,
                    " if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING , hishash ) != 1 ) {\n"
                ],
                [
                    9,
                    " if ( strlen ( hishash ) != ( size_t ) EVP_MD_size ( c -> outdigest ) * 2 ) {\n"
                ],
                [
                    10,
                    " logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge reply length\" ) ;\n"
                ],
                [
                    11,
                    " return false ;\n"
                ],
                [
                    13,
                    " if ( ! hex2bin ( hishash , hishash , EVP_MD_size ( c -> outdigest ) ) ) {\n"
                ],
                [
                    21,
                    " if ( ! EVP_DigestInit ( ctx , c -> outdigest ) || ! EVP_DigestUpdate ( ctx , c -> hischallenge , RSA_size ( c -> rsa_key ) ) || ! EVP_DigestFinal ( ctx , ( unsigned char * ) myhash , NULL ) ) {\n"
                ],
                [
                    27,
                    " if ( memcmp ( hishash , myhash , EVP_MD_size ( c -> outdigest ) ) ) {\n"
                ],
                [
                    28,
                    " logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge reply\" ) ;\n"
                ],
                [
                    29,
                    " ifdebug ( SCARY_THINGS ) {\n"
                ],
                [
                    30,
                    " bin2hex ( myhash , hishash , SHA_DIGEST_LENGTH ) ;\n"
                ],
                [
                    31,
                    " hishash [ SHA_DIGEST_LENGTH * 2 ] = '\\0' ;\n"
                ],
                [
                    32,
                    " logger ( LOG_DEBUG , \"Expected challenge reply: %s\" , hishash ) ;\n"
                ],
                [
                    34,
                    " return false ;\n"
                ],
                [
                    36,
                    " c -> allow_request = ACK ;\n"
                ],
                [
                    37,
                    " return send_ack ( c ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "bool metakey_h ( connection_t * c ) {\n char buffer [ MAX_STRING_SIZE ] ;\n int cipher , digest , maclength , compression ;\n int len ;\n if ( sscanf ( c -> buffer , \"%*d %d %d %d %d \" MAX_STRING , & cipher , & digest , & maclength , & compression , buffer ) != 5 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"METAKEY\" , c -> name , c -> hostname ) ;\n return false ;\n }\n len = RSA_size ( myself -> connection -> rsa_key ) ;\n if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong keylength\" ) ;\n return false ;\n }\n c -> inkey = xrealloc ( c -> inkey , len ) ;\n if ( ! c -> inctx ) {\n c -> inctx = EVP_CIPHER_CTX_new ( ) ;\n if ( ! c -> inctx ) {\n abort ( ) ;\n }\n }\n if ( ! hex2bin ( buffer , buffer , len ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s(%s): %s\" , \"METAKEY\" , c -> name , c -> hostname , \"invalid key\" ) ;\n return false ;\n }\n if ( RSA_private_decrypt ( len , ( unsigned char * ) buffer , ( unsigned char * ) c -> inkey , myself -> connection -> rsa_key , RSA_NO_PADDING ) != len ) {\n logger ( LOG_ERR , \"Error during decryption of meta key for %s (%s): %s\" , c -> name , c -> hostname , ERR_error_string ( ERR_get_error ( ) , NULL ) ) ;\n return false ;\n }\n ifdebug ( SCARY_THINGS ) {\n bin2hex ( c -> inkey , buffer , len ) ;\n buffer [ len * 2 ] = '\\0' ;\n logger ( LOG_DEBUG , \"Received random meta key (unencrypted): %s\" , buffer ) ;\n }\n if ( cipher ) {\n c -> incipher = EVP_get_cipherbynid ( cipher ) ;\n if ( ! c -> incipher ) {\n logger ( LOG_ERR , \"%s (%s) uses unknown cipher!\" , c -> name , c -> hostname ) ;\n return false ;\n }\n if ( ! EVP_DecryptInit ( c -> inctx , c -> incipher , ( unsigned char * ) c -> inkey + len - EVP_CIPHER_key_length ( c -> incipher ) , ( unsigned char * ) c -> inkey + len - EVP_CIPHER_key_length ( c -> incipher ) - EVP_CIPHER_iv_length ( c -> incipher ) ) ) {\n logger ( LOG_ERR , \"Error during initialisation of cipher from %s (%s): %s\" , c -> name , c -> hostname , ERR_error_string ( ERR_get_error ( ) , NULL ) ) ;\n return false ;\n }\n c -> inbudget = byte_budget ( c -> incipher ) ;\n c -> status . decryptin = true ;\n }\n else {\n c -> incipher = NULL ;\n }\n c -> inmaclength = maclength ;\n if ( digest ) {\n c -> indigest = EVP_get_digestbynid ( digest ) ;\n if ( ! c -> indigest ) {\n logger ( LOG_ERR , \"Node %s (%s) uses unknown digest!\" , c -> name , c -> hostname ) ;\n return false ;\n }\n if ( c -> inmaclength > EVP_MD_size ( c -> indigest ) || c -> inmaclength < 0 ) {\n logger ( LOG_ERR , \"%s (%s) uses bogus MAC length!\" , c -> name , c -> hostname ) ;\n return false ;\n }\n }\n else {\n c -> indigest = NULL ;\n }\n c -> incompression = compression ;\n c -> allow_request = CHALLENGE ;\n return send_challenge ( c ) ;\n }",
        "hash": 4372812923566076695,
        "project": "debian",
        "size": 68,
        "slice": {
            "strlen": [
                [
                    1,
                    "bool metakey_h ( connection_t * c ) {\n"
                ],
                [
                    2,
                    " char buffer [ MAX_STRING_SIZE ] ;\n"
                ],
                [
                    5,
                    " if ( sscanf ( c -> buffer , \"%*d %d %d %d %d \" MAX_STRING , & cipher , & digest , & maclength , & compression , buffer ) != 5 ) {\n"
                ],
                [
                    10,
                    " if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n"
                ],
                [
                    11,
                    " logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong keylength\" ) ;\n"
                ],
                [
                    12,
                    " return false ;\n"
                ],
                [
                    14,
                    " c -> inkey = xrealloc ( c -> inkey , len ) ;\n"
                ],
                [
                    15,
                    " if ( ! c -> inctx ) {\n"
                ],
                [
                    21,
                    " if ( ! hex2bin ( buffer , buffer , len ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "bool metakey_h ( connection_t * c ) {\n"
                ],
                [
                    2,
                    " char buffer [ MAX_STRING_SIZE ] ;\n"
                ],
                [
                    5,
                    " if ( sscanf ( c -> buffer , \"%*d %d %d %d %d \" MAX_STRING , & cipher , & digest , & maclength , & compression , buffer ) != 5 ) {\n"
                ],
                [
                    10,
                    " if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n"
                ],
                [
                    11,
                    " logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong keylength\" ) ;\n"
                ],
                [
                    12,
                    " return false ;\n"
                ],
                [
                    14,
                    " c -> inkey = xrealloc ( c -> inkey , len ) ;\n"
                ],
                [
                    15,
                    " if ( ! c -> inctx ) {\n"
                ],
                [
                    21,
                    " if ( ! hex2bin ( buffer , buffer , len ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "bool challenge_h ( connection_t * c ) {\n char buffer [ MAX_STRING_SIZE ] ;\n int len ;\n if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING , buffer ) != 1 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"CHALLENGE\" , c -> name , c -> hostname ) ;\n return false ;\n }\n len = RSA_size ( myself -> connection -> rsa_key ) ;\n if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge length\" ) ;\n return false ;\n }\n c -> mychallenge = xrealloc ( c -> mychallenge , len ) ;\n if ( ! hex2bin ( buffer , c -> mychallenge , len ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s(%s): %s\" , \"CHALLENGE\" , c -> name , c -> hostname , \"invalid challenge\" ) ;\n return false ;\n }\n c -> allow_request = CHAL_REPLY ;\n return send_chal_reply ( c ) ;\n }",
        "hash": 4372812923566076695,
        "project": "debian",
        "size": 20,
        "slice": {
            "strlen": [
                [
                    1,
                    "bool challenge_h ( connection_t * c ) {\n"
                ],
                [
                    2,
                    " char buffer [ MAX_STRING_SIZE ] ;\n"
                ],
                [
                    4,
                    " if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING , buffer ) != 1 ) {\n"
                ],
                [
                    9,
                    " if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n"
                ],
                [
                    10,
                    " logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge length\" ) ;\n"
                ],
                [
                    11,
                    " return false ;\n"
                ],
                [
                    13,
                    " c -> mychallenge = xrealloc ( c -> mychallenge , len ) ;\n"
                ],
                [
                    14,
                    " if ( ! hex2bin ( buffer , c -> mychallenge , len ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "bool challenge_h ( connection_t * c ) {\n"
                ],
                [
                    2,
                    " char buffer [ MAX_STRING_SIZE ] ;\n"
                ],
                [
                    4,
                    " if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING , buffer ) != 1 ) {\n"
                ],
                [
                    9,
                    " if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n"
                ],
                [
                    10,
                    " logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge length\" ) ;\n"
                ],
                [
                    11,
                    " return false ;\n"
                ],
                [
                    13,
                    " c -> mychallenge = xrealloc ( c -> mychallenge , len ) ;\n"
                ],
                [
                    14,
                    " if ( ! hex2bin ( buffer , c -> mychallenge , len ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "bool id_h ( connection_t * c ) {\n char name [ MAX_STRING_SIZE ] ;\n if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING \" %d\" , name , & c -> protocol_version ) != 2 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"ID\" , c -> name , c -> hostname ) ;\n return false ;\n }\n if ( ! check_id ( name ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s): %s\" , \"ID\" , c -> name , c -> hostname , \"invalid name\" ) ;\n return false ;\n }\n if ( c -> outgoing ) {\n if ( strcmp ( c -> name , name ) ) {\n logger ( LOG_ERR , \"Peer %s is %s instead of %s\" , c -> hostname , name , c -> name ) ;\n return false ;\n }\n }\n else {\n if ( c -> name ) {\n free ( c -> name ) ;\n }\n c -> name = xstrdup ( name ) ;\n }\n if ( c -> protocol_version != myself -> connection -> protocol_version ) {\n logger ( LOG_ERR , \"Peer %s (%s) uses incompatible version %d\" , c -> name , c -> hostname , c -> protocol_version ) ;\n return false ;\n }\n if ( bypass_security ) {\n if ( ! c -> config_tree ) {\n init_configuration ( & c -> config_tree ) ;\n }\n c -> allow_request = ACK ;\n return send_ack ( c ) ;\n }\n if ( ! c -> config_tree ) {\n init_configuration ( & c -> config_tree ) ;\n if ( ! read_connection_config ( c ) ) {\n logger ( LOG_ERR , \"Peer %s had unknown identity (%s)\" , c -> hostname , c -> name ) ;\n return false ;\n }\n }\n if ( ! read_rsa_public_key ( c ) ) {\n return false ;\n }\n c -> allow_request = METAKEY ;\n return send_metakey ( c ) ;\n }",
        "hash": 4372812923566076695,
        "project": "debian",
        "size": 46,
        "slice": {
            "strcmp": [
                [
                    1,
                    "bool id_h ( connection_t * c ) {\n"
                ],
                [
                    7,
                    " if ( ! check_id ( name ) ) {\n"
                ],
                [
                    11,
                    " if ( c -> outgoing ) {\n"
                ],
                [
                    12,
                    " if ( strcmp ( c -> name , name ) ) {\n"
                ],
                [
                    13,
                    " logger ( LOG_ERR , \"Peer %s is %s instead of %s\" , c -> hostname , name , c -> name ) ;\n"
                ],
                [
                    14,
                    " return false ;\n"
                ],
                [
                    23,
                    " if ( c -> protocol_version != myself -> connection -> protocol_version ) {\n"
                ],
                [
                    24,
                    " logger ( LOG_ERR , \"Peer %s (%s) uses incompatible version %d\" , c -> name , c -> hostname , c -> protocol_version ) ;\n"
                ],
                [
                    32,
                    " return send_ack ( c ) ;\n"
                ],
                [
                    36,
                    " if ( ! read_connection_config ( c ) ) {\n"
                ],
                [
                    37,
                    " logger ( LOG_ERR , \"Peer %s had unknown identity (%s)\" , c -> hostname , c -> name ) ;\n"
                ],
                [
                    41,
                    " if ( ! read_rsa_public_key ( c ) ) {\n"
                ],
                [
                    45,
                    " return send_metakey ( c ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "bool id_h ( connection_t * c ) {\n"
                ],
                [
                    18,
                    " if ( c -> name ) {\n"
                ],
                [
                    19,
                    " free ( c -> name ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "bool id_h ( connection_t * c ) {\n"
                ],
                [
                    7,
                    " if ( ! check_id ( name ) ) {\n"
                ],
                [
                    11,
                    " if ( c -> outgoing ) {\n"
                ],
                [
                    12,
                    " if ( strcmp ( c -> name , name ) ) {\n"
                ],
                [
                    13,
                    " logger ( LOG_ERR , \"Peer %s is %s instead of %s\" , c -> hostname , name , c -> name ) ;\n"
                ],
                [
                    14,
                    " return false ;\n"
                ],
                [
                    18,
                    " if ( c -> name ) {\n"
                ],
                [
                    19,
                    " free ( c -> name ) ;\n"
                ],
                [
                    23,
                    " if ( c -> protocol_version != myself -> connection -> protocol_version ) {\n"
                ],
                [
                    24,
                    " logger ( LOG_ERR , \"Peer %s (%s) uses incompatible version %d\" , c -> name , c -> hostname , c -> protocol_version ) ;\n"
                ],
                [
                    32,
                    " return send_ack ( c ) ;\n"
                ],
                [
                    36,
                    " if ( ! read_connection_config ( c ) ) {\n"
                ],
                [
                    37,
                    " logger ( LOG_ERR , \"Peer %s had unknown identity (%s)\" , c -> hostname , c -> name ) ;\n"
                ],
                [
                    41,
                    " if ( ! read_rsa_public_key ( c ) ) {\n"
                ],
                [
                    45,
                    " return send_metakey ( c ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) {\n size_t width = ( 79 - strlen ( prefix ) ) ;\n if ( ! config -> mute ) {\n size_t len ;\n char * ptr ;\n char * print_buffer ;\n print_buffer = curlx_mvaprintf ( fmt , ap ) ;\n if ( ! print_buffer ) return ;\n len = strlen ( print_buffer ) ;\n ptr = print_buffer ;\n while ( len > 0 ) {\n fputs ( prefix , config -> errors ) ;\n if ( len > width ) {\n size_t cut = width - 1 ;\n while ( ! ISSPACE ( ptr [ cut ] ) && cut ) {\n cut -- ;\n }\n if ( 0 == cut ) cut = width - 1 ;\n ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ;\n fputs ( \"\\n\" , config -> errors ) ;\n ptr += cut + 1 ;\n len -= cut ;\n }\n else {\n fputs ( ptr , config -> errors ) ;\n len = 0 ;\n }\n }\n curl_free ( print_buffer ) ;\n }\n }",
        "hash": 794575292121248454,
        "project": "debian",
        "size": 31,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) {\n"
                ],
                [
                    2,
                    " size_t width = ( 79 - strlen ( prefix ) ) ;\n"
                ],
                [
                    8,
                    " if ( ! print_buffer ) return ;\n"
                ],
                [
                    9,
                    " len = strlen ( print_buffer ) ;\n"
                ],
                [
                    10,
                    " ptr = print_buffer ;\n"
                ],
                [
                    11,
                    " while ( len > 0 ) {\n"
                ],
                [
                    12,
                    " fputs ( prefix , config -> errors ) ;\n"
                ],
                [
                    13,
                    " if ( len > width ) {\n"
                ],
                [
                    29,
                    " curl_free ( print_buffer ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) {\n"
                ],
                [
                    2,
                    " size_t width = ( 79 - strlen ( prefix ) ) ;\n"
                ],
                [
                    8,
                    " if ( ! print_buffer ) return ;\n"
                ],
                [
                    9,
                    " len = strlen ( print_buffer ) ;\n"
                ],
                [
                    10,
                    " ptr = print_buffer ;\n"
                ],
                [
                    11,
                    " while ( len > 0 ) {\n"
                ],
                [
                    12,
                    " fputs ( prefix , config -> errors ) ;\n"
                ],
                [
                    13,
                    " if ( len > width ) {\n"
                ],
                [
                    29,
                    " curl_free ( print_buffer ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n gx_ttfReader * r = ( gx_ttfReader * ) self ;\n const byte * q ;\n if ( ! r -> error ) {\n if ( r -> extra_glyph_index != - 1 ) {\n q = r -> glyph_data . bits . data + r -> pos ;\n r -> error = ( r -> glyph_data . bits . size - r -> pos < n ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n }\n else {\n unsigned int cnt ;\n for ( cnt = 0 ;\n cnt < ( uint ) n ;\n cnt += r -> error ) {\n r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;\n if ( r -> error < 0 ) break ;\n else if ( r -> error == 0 ) {\n memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n break ;\n }\n else {\n memcpy ( ( char * ) p + cnt , q , r -> error ) ;\n }\n }\n }\n }\n if ( r -> error ) {\n memset ( p , 0 , n ) ;\n return ;\n }\n r -> pos += n ;\n }",
        "hash": -1950979830238945732,
        "project": "debian",
        "size": 32,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n"
                ],
                [
                    2,
                    " gx_ttfReader * r = ( gx_ttfReader * ) self ;\n"
                ],
                [
                    6,
                    " q = r -> glyph_data . bits . data + r -> pos ;\n"
                ],
                [
                    7,
                    " r -> error = ( r -> glyph_data . bits . size - r -> pos < n ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n"
                ],
                [
                    8,
                    " if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n"
                ],
                [
                    14,
                    " cnt += r -> error ) {\n"
                ],
                [
                    15,
                    " r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;\n"
                ],
                [
                    17,
                    " else if ( r -> error == 0 ) {\n"
                ],
                [
                    18,
                    " memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n"
                ],
                [
                    22,
                    " memcpy ( ( char * ) p + cnt , q , r -> error ) ;\n"
                ],
                [
                    28,
                    " memset ( p , 0 , n ) ;\n"
                ],
                [
                    31,
                    " r -> pos += n ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n"
                ],
                [
                    7,
                    " r -> error = ( r -> glyph_data . bits . size - r -> pos < n ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n"
                ],
                [
                    8,
                    " if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n"
                ],
                [
                    18,
                    " memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n"
                ],
                [
                    27,
                    " if ( r -> error ) {\n"
                ],
                [
                    28,
                    " memset ( p , 0 , n ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n"
                ],
                [
                    2,
                    " gx_ttfReader * r = ( gx_ttfReader * ) self ;\n"
                ],
                [
                    6,
                    " q = r -> glyph_data . bits . data + r -> pos ;\n"
                ],
                [
                    7,
                    " r -> error = ( r -> glyph_data . bits . size - r -> pos < n ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n"
                ],
                [
                    8,
                    " if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n"
                ],
                [
                    14,
                    " cnt += r -> error ) {\n"
                ],
                [
                    15,
                    " r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;\n"
                ],
                [
                    17,
                    " else if ( r -> error == 0 ) {\n"
                ],
                [
                    18,
                    " memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n"
                ],
                [
                    22,
                    " memcpy ( ( char * ) p + cnt , q , r -> error ) ;\n"
                ],
                [
                    27,
                    " if ( r -> error ) {\n"
                ],
                [
                    28,
                    " memset ( p , 0 , n ) ;\n"
                ],
                [
                    31,
                    " r -> pos += n ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int dissect_dns_answer ( tvbuff_t * tvb , int offsetx , int dns_data_offset , column_info * cinfo , proto_tree * dns_tree , packet_info * pinfo , gboolean is_mdns ) {\n int len ;\n const guchar * name ;\n gchar * name_out ;\n int name_len ;\n int dns_type ;\n int dns_class ;\n int flush ;\n const char * class_name ;\n const char * type_name ;\n int data_offset ;\n int cur_offset ;\n int data_start ;\n gushort data_len ;\n proto_tree * rr_tree = NULL ;\n proto_item * trr = NULL ;\n data_start = data_offset = offsetx ;\n cur_offset = offsetx ;\n len = get_dns_name_type_class ( tvb , offsetx , dns_data_offset , & name , & name_len , & dns_type , & dns_class ) ;\n data_offset += len ;\n cur_offset += len ;\n if ( is_mdns ) {\n flush = dns_class & C_FLUSH ;\n dns_class &= ~ C_FLUSH ;\n }\n else {\n flush = 0 ;\n }\n type_name = val_to_str_ext ( dns_type , & dns_types_vals_ext , \"Unknown (%d)\" ) ;\n class_name = val_to_str_const ( dns_class , dns_classes , \"Unknown\" ) ;\n data_offset += 4 ;\n cur_offset += 4 ;\n data_len = tvb_get_ntohs ( tvb , data_offset ) ;\n data_offset += 2 ;\n cur_offset += 2 ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \"%s\" , type_name ) ;\n if ( is_mdns && flush ) {\n col_append_str ( cinfo , COL_INFO , \", cache flush\" ) ;\n }\n }\n if ( dns_tree != NULL ) {\n name_out = format_text ( name , strlen ( name ) ) ;\n if ( dns_type != T_OPT ) {\n rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , \"%s: type %s, class %s\" , name_out , type_name , class_name ) ;\n add_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , dns_type , pinfo , is_mdns ) ;\n }\n else {\n rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , \"%s: type %s\" , name_out , type_name ) ;\n add_opt_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , is_mdns ) ;\n }\n if ( is_mdns && flush ) {\n proto_item_append_text ( trr , \", cache flush\" ) ;\n }\n }\n if ( data_len == 0 ) {\n return data_offset - data_start ;\n }\n switch ( dns_type ) {\n case T_A : {\n const char * addr ;\n addr = tvb_ip_to_str ( tvb , cur_offset ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , addr ) ;\n }\n proto_item_append_text ( trr , \", addr %s\" , addr ) ;\n proto_tree_add_item ( rr_tree , hf_dns_a , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n if ( dns_use_for_addr_resolution && ( dns_class & 0x7f ) == C_IN ) {\n guint32 addr_int ;\n tvb_memcpy ( tvb , & addr_int , cur_offset , sizeof ( addr_int ) ) ;\n add_ipv4_name ( addr_int , name ) ;\n }\n }\n break ;\n case T_NS : {\n const guchar * ns_name ;\n int ns_name_len ;\n ns_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & ns_name ) ;\n name_out = format_text ( ns_name , strlen ( ns_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", ns %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_ns , tvb , cur_offset , ns_name_len , name_out ) ;\n }\n break ;\n case T_MD : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_md , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_MF : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_mf , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_CNAME : {\n const guchar * cname ;\n int cname_len ;\n cname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & cname ) ;\n name_out = format_text ( cname , strlen ( cname ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", cname %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_cname , tvb , cur_offset , cname_len , name_out ) ;\n }\n break ;\n case T_SOA : {\n const guchar * mname ;\n int mname_len ;\n const guchar * rname ;\n int rname_len ;\n proto_item * ti_soa ;\n mname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mname ) ;\n name_out = format_text ( mname , strlen ( mname ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", mname %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_soa_mname , tvb , cur_offset , mname_len , name_out ) ;\n cur_offset += mname_len ;\n rname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rname ) ;\n name_out = format_text ( rname , strlen ( rname ) ) ;\n proto_tree_add_string ( rr_tree , hf_dns_soa_rname , tvb , cur_offset , rname_len , name_out ) ;\n cur_offset += rname_len ;\n proto_tree_add_item ( rr_tree , hf_dns_soa_serial_number , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_refresh_interval , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_soa , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n cur_offset += 4 ;\n ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_retry_interval , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_soa , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n cur_offset += 4 ;\n ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_expire_limit , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_soa , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n cur_offset += 4 ;\n ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_minimum_ttl , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_soa , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n }\n break ;\n case T_MB : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_mb , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_MG : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_mg , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_MR : {\n int hostname_len ;\n const guchar * hostname_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_mr , tvb , cur_offset , hostname_len , hostname_str ) ;\n }\n break ;\n case T_NULL : {\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_null , tvb , cur_offset , data_len , ENC_NA ) ;\n }\n break ;\n case T_WKS : {\n int rr_len = data_len ;\n const char * wks_addr ;\n guint8 protocol ;\n guint8 bits ;\n int mask ;\n int port_num ;\n int i ;\n proto_item * ti_wks ;\n wmem_strbuf_t * bitnames = wmem_strbuf_new_label ( wmem_packet_scope ( ) ) ;\n wks_addr = tvb_ip_to_str ( tvb , cur_offset ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , wks_addr ) ;\n }\n proto_item_append_text ( trr , \", addr %s\" , wks_addr ) ;\n proto_tree_add_item ( rr_tree , hf_dns_wks_address , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_wks_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n protocol = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n port_num = 0 ;\n while ( rr_len != 0 ) {\n bits = tvb_get_guint8 ( tvb , cur_offset ) ;\n if ( bits != 0 ) {\n mask = 1 << 7 ;\n wmem_strbuf_truncate ( bitnames , 0 ) ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n if ( bits & mask ) {\n if ( wmem_strbuf_get_len ( bitnames ) > 0 ) {\n wmem_strbuf_append ( bitnames , \", \" ) ;\n }\n switch ( protocol ) {\n case IP_PROTO_TCP : wmem_strbuf_append ( bitnames , tcp_port_to_display ( wmem_packet_scope ( ) , port_num ) ) ;\n break ;\n case IP_PROTO_UDP : wmem_strbuf_append ( bitnames , udp_port_to_display ( wmem_packet_scope ( ) , port_num ) ) ;\n break ;\n default : wmem_strbuf_append_printf ( bitnames , \"%u\" , port_num ) ;\n break ;\n }\n }\n mask >>= 1 ;\n port_num ++ ;\n }\n ti_wks = proto_tree_add_item ( rr_tree , hf_dns_wks_bits , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti_wks , \" (%s)\" , wmem_strbuf_get_str ( bitnames ) ) ;\n }\n else {\n port_num += 8 ;\n }\n cur_offset += 1 ;\n rr_len -= 1 ;\n }\n }\n break ;\n case T_PTR : {\n const guchar * pname ;\n int pname_len ;\n pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n name_out = format_text ( pname , strlen ( pname ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_ptr_domain_name , tvb , cur_offset , pname_len , name_out ) ;\n }\n break ;\n case T_HINFO : {\n int cpu_offset ;\n int cpu_len ;\n const char * cpu ;\n int os_offset ;\n int os_len ;\n const char * os ;\n cpu_offset = cur_offset ;\n cpu_len = tvb_get_guint8 ( tvb , cpu_offset ) ;\n cpu = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cpu_offset + 1 , cpu_len , ENC_ASCII | ENC_NA ) ;\n os_offset = cpu_offset + 1 + cpu_len ;\n os_len = tvb_get_guint8 ( tvb , os_offset ) ;\n os = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , os_offset + 1 , os_len , ENC_ASCII | ENC_NA ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %.*s %.*s\" , cpu_len , cpu , os_len , os ) ;\n }\n proto_item_append_text ( trr , \", CPU %.*s, OS %.*s\" , cpu_len , cpu , os_len , os ) ;\n proto_tree_add_item ( rr_tree , hf_dns_hinfo_cpu_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_hinfo_cpu , tvb , cur_offset , cpu_len , ENC_ASCII | ENC_NA ) ;\n cur_offset += cpu_len ;\n proto_tree_add_item ( rr_tree , hf_dns_hinfo_os_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_hinfo_os , tvb , cur_offset , os_len , ENC_ASCII | ENC_NA ) ;\n }\n break ;\n case T_MINFO : {\n int rmailbx_len , emailbx_len ;\n const guchar * rmailbx_str , * emailbx_str ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n rmailbx_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rmailbx_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_minfo_r_mailbox , tvb , cur_offset , rmailbx_len , rmailbx_str ) ;\n cur_offset += rmailbx_len ;\n emailbx_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & emailbx_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_minfo_e_mailbox , tvb , cur_offset , emailbx_len , emailbx_str ) ;\n }\n break ;\n case T_MX : {\n guint16 preference = 0 ;\n const guchar * mx_name ;\n int mx_name_len ;\n preference = tvb_get_ntohs ( tvb , cur_offset ) ;\n mx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & mx_name ) ;\n name_out = format_text ( mx_name , strlen ( mx_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %u %s\" , preference , name_out ) ;\n }\n proto_item_append_text ( trr , \", preference %u, mx %s\" , preference , name_out ) ;\n proto_tree_add_item ( rr_tree , hf_dns_mx_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_string ( rr_tree , hf_dns_mx_mail_exchange , tvb , cur_offset , mx_name_len , name_out ) ;\n }\n break ;\n case T_TXT : {\n int rr_len = data_len ;\n int txt_offset ;\n int txt_len ;\n txt_offset = cur_offset ;\n while ( rr_len != 0 ) {\n txt_len = tvb_get_guint8 ( tvb , txt_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_txt_length , tvb , txt_offset , 1 , ENC_BIG_ENDIAN ) ;\n txt_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_txt , tvb , txt_offset , txt_len , ENC_ASCII | ENC_NA ) ;\n txt_offset += txt_len ;\n rr_len -= txt_len ;\n }\n }\n break ;\n case T_RP : {\n int mbox_dname_len , txt_dname_len ;\n const guchar * mbox_dname , * txt_dname ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n mbox_dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mbox_dname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_rp_mailbox , tvb , cur_offset , mbox_dname_len , mbox_dname ) ;\n cur_offset += mbox_dname_len ;\n txt_dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & txt_dname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_rp_txt_rr , tvb , cur_offset , txt_dname_len , txt_dname ) ;\n }\n break ;\n case T_AFSDB : {\n const guchar * host_name ;\n int host_name_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n host_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & host_name ) ;\n proto_tree_add_item ( rr_tree , hf_dns_afsdb_subtype , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_string ( rr_tree , hf_dns_afsdb_hostname , tvb , cur_offset , host_name_len , host_name ) ;\n }\n break ;\n case T_X25 : {\n guint8 x25_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_x25_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n x25_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_x25_psdn_address , tvb , cur_offset , x25_len , ENC_ASCII | ENC_NA ) ;\n }\n break ;\n case T_ISDN : {\n guint8 isdn_address_len , isdn_sa_len ;\n int rr_len = data_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_isdn_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n isdn_address_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_isdn_address , tvb , cur_offset , isdn_address_len , ENC_ASCII | ENC_NA ) ;\n cur_offset += isdn_address_len ;\n rr_len -= isdn_address_len ;\n if ( rr_len > 1 ) {\n proto_tree_add_item ( rr_tree , hf_dns_isdn_sa_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n isdn_sa_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_isdn_sa , tvb , cur_offset , isdn_sa_len , ENC_ASCII | ENC_NA ) ;\n }\n }\n break ;\n case T_RT : {\n const guchar * host_name ;\n int host_name_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n host_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & host_name ) ;\n proto_tree_add_item ( rr_tree , hf_dns_rt_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_string ( rr_tree , hf_dns_rt_intermediate_host , tvb , cur_offset , host_name_len , host_name ) ;\n }\n break ;\n case T_NSAP : {\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_nsap_rdata , tvb , cur_offset , data_len , ENC_NA ) ;\n }\n break ;\n case T_NSAP_PTR : {\n int nsap_ptr_owner_len ;\n const guchar * nsap_ptr_owner ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n nsap_ptr_owner_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & nsap_ptr_owner ) ;\n proto_tree_add_string ( rr_tree , hf_dns_nsap_ptr_owner , tvb , cur_offset , nsap_ptr_owner_len , nsap_ptr_owner ) ;\n }\n break ;\n case T_KEY : {\n int rr_len = data_len ;\n guint16 flags ;\n proto_item * tf , * ti_gen ;\n proto_tree * flags_tree ;\n guint8 algo ;\n guint16 key_id ;\n tf = proto_tree_add_item ( rr_tree , hf_dns_key_flags , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n flags_tree = proto_item_add_subtree ( tf , ett_key_flags ) ;\n flags = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_authentication , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_confidentiality , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n if ( ( flags & 0xC000 ) != 0xC000 ) {\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_key_required , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_associated_user , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_associated_named_entity , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_ipsec , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_mime , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_key_flags_signatory , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n }\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_key_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_key_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n algo = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n key_id = compute_key_id ( tvb , cur_offset - 4 , rr_len + 4 , algo ) ;\n ti_gen = proto_tree_add_uint ( rr_tree , hf_dns_key_key_id , tvb , 0 , 0 , key_id ) ;\n PROTO_ITEM_SET_GENERATED ( ti_gen ) ;\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_key_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_PX : {\n int px_map822_len , px_mapx400_len ;\n const guchar * px_map822_dnsname , * px_mapx400_dnsname ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_px_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n px_map822_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & px_map822_dnsname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_px_map822 , tvb , cur_offset , px_map822_len , px_map822_dnsname ) ;\n cur_offset += px_map822_len ;\n px_mapx400_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & px_mapx400_dnsname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_px_mapx400 , tvb , cur_offset , px_mapx400_len , px_mapx400_dnsname ) ;\n }\n break ;\n case T_GPOS : {\n guint8 long_len , lat_len , alt_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_gpos_longitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n long_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_longitude , tvb , cur_offset , long_len , ENC_ASCII | ENC_NA ) ;\n cur_offset += long_len ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_latitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n lat_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_latitude , tvb , cur_offset , lat_len , ENC_ASCII | ENC_NA ) ;\n cur_offset += lat_len ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_altitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n alt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_gpos_altitude , tvb , cur_offset , alt_len , ENC_ASCII | ENC_NA ) ;\n }\n break ;\n case T_AAAA : {\n const char * addr6 ;\n addr6 = tvb_ip6_to_str ( tvb , cur_offset ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , addr6 ) ;\n }\n proto_item_append_text ( trr , \", addr %s\" , addr6 ) ;\n proto_tree_add_item ( rr_tree , hf_dns_aaaa , tvb , cur_offset , 16 , ENC_NA ) ;\n if ( dns_use_for_addr_resolution && ( dns_class & 0x7f ) == C_IN ) {\n struct e_in6_addr addr_in6 ;\n tvb_memcpy ( tvb , & addr_in6 , cur_offset , sizeof ( addr_in6 ) ) ;\n add_ipv6_name ( & addr_in6 , name ) ;\n }\n }\n break ;\n case T_LOC : {\n guint8 version ;\n proto_item * ti ;\n version = tvb_get_guint8 ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_loc_version , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n if ( version == 0 ) {\n cur_offset ++ ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_size , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%g m)\" , rfc1867_size ( tvb , cur_offset ) ) ;\n cur_offset ++ ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_horizontal_precision , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%g m)\" , rfc1867_size ( tvb , cur_offset ) ) ;\n cur_offset ++ ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_vertical_precision , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%g m)\" , rfc1867_size ( tvb , cur_offset ) ) ;\n cur_offset ++ ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_latitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%s)\" , rfc1867_angle ( tvb , cur_offset , \"NS\" ) ) ;\n cur_offset += 4 ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_longitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%s)\" , rfc1867_angle ( tvb , cur_offset , \"EW\" ) ) ;\n cur_offset += 4 ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_loc_altitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%g m)\" , ( ( gint32 ) tvb_get_ntohl ( tvb , cur_offset ) - 10000000 ) / 100.0 ) ;\n }\n else {\n proto_tree_add_item ( rr_tree , hf_dns_loc_unknown_data , tvb , cur_offset , data_len , ENC_NA ) ;\n }\n }\n break ;\n case T_NXT : {\n int rr_len = data_len ;\n const guchar * next_domain_name ;\n int next_domain_name_len ;\n next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", next domain name %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_nxt_next_domain_name , tvb , cur_offset , next_domain_name_len , name_out ) ;\n cur_offset += next_domain_name_len ;\n rr_len -= next_domain_name_len ;\n dissect_type_bitmap_nxt ( rr_tree , tvb , cur_offset , rr_len ) ;\n }\n break ;\n case T_SRV : {\n guint16 priority = 0 ;\n guint16 weight = 0 ;\n guint16 port = 0 ;\n const guchar * target ;\n int target_len ;\n proto_tree_add_item ( rr_tree , hf_dns_srv_priority , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n priority = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_srv_weight , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n weight = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_srv_port , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n port = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n target_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & target ) ;\n name_out = format_text ( target , strlen ( target ) ) ;\n proto_tree_add_string ( rr_tree , hf_dns_srv_target , tvb , cur_offset , target_len , name_out ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %u %u %u %s\" , priority , weight , port , name_out ) ;\n }\n proto_item_append_text ( trr , \", priority %u, weight %u, port %u, target %s\" , priority , weight , port , name_out ) ;\n }\n break ;\n case T_NAPTR : {\n proto_item * ti_len ;\n int offset = cur_offset ;\n guint16 order ;\n guint16 preference ;\n gchar * flags ;\n guint8 flags_len ;\n guint8 service_len ;\n guint8 regex_len ;\n const guchar * replacement ;\n int replacement_len ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_order , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n order = tvb_get_ntohs ( tvb , offset ) ;\n offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_preference , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n preference = tvb_get_ntohs ( tvb , offset ) ;\n offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_flags_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n flags_len = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_flags , tvb , offset , flags_len , ENC_ASCII | ENC_NA ) ;\n flags = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , flags_len , ENC_ASCII | ENC_NA ) ;\n offset += flags_len ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_service_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n service_len = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_service , tvb , offset , service_len , ENC_ASCII | ENC_NA ) ;\n offset += service_len ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_regex_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n regex_len = tvb_get_guint8 ( tvb , offset ) ;\n offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_naptr_regex , tvb , offset , regex_len , ENC_ASCII | ENC_NA ) ;\n offset += regex_len ;\n replacement_len = get_dns_name ( tvb , offset , 0 , dns_data_offset , & replacement ) ;\n name_out = format_text ( replacement , strlen ( replacement ) ) ;\n ti_len = proto_tree_add_uint ( rr_tree , hf_dns_naptr_replacement_length , tvb , offset , 0 , replacement_len ) ;\n PROTO_ITEM_SET_GENERATED ( ti_len ) ;\n proto_tree_add_string ( rr_tree , hf_dns_naptr_replacement , tvb , offset , replacement_len , name_out ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %u %u %s\" , order , preference , flags ) ;\n }\n proto_item_append_text ( trr , \", order %u, preference %u, flags %s\" , order , preference , flags ) ;\n }\n break ;\n case T_KX : {\n const guchar * kx_name ;\n int kx_name_len ;\n kx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & kx_name ) ;\n name_out = format_text ( kx_name , strlen ( kx_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %u %s\" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n }\n proto_item_append_text ( trr , \", preference %u, kx %s\" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n proto_tree_add_item ( rr_tree , hf_dns_kx_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_string ( rr_tree , hf_dns_kx_key_exchange , tvb , cur_offset + 2 , kx_name_len , name_out ) ;\n }\n break ;\n case T_CERT : {\n int rr_len = data_len ;\n proto_tree_add_item ( rr_tree , hf_dns_cert_type , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_cert_key_tag , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_cert_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_cert_certificate , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_A6 : {\n unsigned short pre_len ;\n unsigned short suf_len ;\n unsigned short suf_octet_count ;\n const guchar * pname ;\n int pname_len ;\n int a6_offset ;\n int suf_offset ;\n struct e_in6_addr suffix ;\n address suffix_addr ;\n a6_offset = cur_offset ;\n pre_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset ++ ;\n suf_len = 128 - pre_len ;\n suf_octet_count = suf_len ? ( suf_len - 1 ) / 8 + 1 : 0 ;\n for ( suf_offset = 0 ;\n suf_offset < 16 - suf_octet_count ;\n suf_offset ++ ) {\n suffix . bytes [ suf_offset ] = 0 ;\n }\n for ( ;\n suf_offset < 16 ;\n suf_offset ++ ) {\n suffix . bytes [ suf_offset ] = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset ++ ;\n }\n if ( pre_len > 0 ) {\n pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n }\n else {\n pname = \"\" ;\n pname_len = 0 ;\n }\n name_out = format_text ( pname , strlen ( pname ) ) ;\n SET_ADDRESS ( & suffix_addr , AT_IPv6 , 16 , suffix . bytes ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %d %s %s\" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_a6_prefix_len , tvb , a6_offset , 1 , ENC_BIG_ENDIAN ) ;\n a6_offset ++ ;\n if ( suf_len ) {\n proto_tree_add_ipv6 ( rr_tree , hf_dns_a6_address_suffix , tvb , a6_offset , suf_octet_count , suffix . bytes ) ;\n a6_offset += suf_octet_count ;\n }\n if ( pre_len > 0 ) {\n proto_tree_add_string ( rr_tree , hf_dns_a6_prefix_name , tvb , a6_offset , pname_len , name_out ) ;\n }\n proto_item_append_text ( trr , \", addr %d %s %s\" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n }\n break ;\n case T_DNAME : {\n const guchar * dname ;\n int dname_len ;\n dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n name_out = format_text ( dname , strlen ( dname ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", dname %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_dname , tvb , cur_offset , dname_len , name_out ) ;\n }\n break ;\n case T_OPT : {\n int rropt_len = data_len ;\n guint16 optcode , optlen ;\n proto_item * rropt , * rroptlen ;\n proto_tree * rropt_tree ;\n while ( rropt_len > 0 ) {\n optcode = tvb_get_ntohs ( tvb , cur_offset ) ;\n rropt_len -= 2 ;\n optlen = tvb_get_ntohs ( tvb , cur_offset + 2 ) ;\n rropt_len -= 2 ;\n rropt = proto_tree_add_item ( rr_tree , hf_dns_opt , tvb , cur_offset , 4 + optlen , ENC_NA ) ;\n proto_item_append_text ( rropt , \": %s\" , val_to_str ( optcode , edns0_opt_code_vals , \"Unknown (%d)\" ) ) ;\n rropt_tree = proto_item_add_subtree ( rropt , ett_dns_opts ) ;\n rropt = proto_tree_add_item ( rropt_tree , hf_dns_opt_code , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rroptlen = proto_tree_add_item ( rropt_tree , hf_dns_opt_len , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rropt_tree , hf_dns_opt_data , tvb , cur_offset , optlen , ENC_NA ) ;\n switch ( optcode ) {\n case O_DAU : while ( optlen != 0 ) {\n proto_tree_add_item ( rropt_tree , hf_dns_opt_dau , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rropt_len -= 1 ;\n optlen -= 1 ;\n }\n break ;\n case O_DHU : while ( optlen != 0 ) {\n proto_tree_add_item ( rropt_tree , hf_dns_opt_dhu , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rropt_len -= 1 ;\n optlen -= 1 ;\n }\n break ;\n case O_N3U : while ( optlen != 0 ) {\n proto_tree_add_item ( rropt_tree , hf_dns_opt_n3u , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rropt_len -= 1 ;\n optlen -= 1 ;\n }\n break ;\n case O_CLIENT_SUBNET_EXP : expert_add_info_format ( pinfo , rropt , & ei_dns_depr_opc , \"Deprecated opcode. Client subnet OPT assigned as %d.\" , O_CLIENT_SUBNET ) ;\n case O_CLIENT_SUBNET : {\n guint16 family ;\n union {\n guint32 addr ;\n guint8 bytes [ 16 ] ;\n }\n ip_addr = {\n 0 }\n ;\n family = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( rropt_tree , hf_dns_opt_client_family , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rropt_tree , hf_dns_opt_client_netmask , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rropt_tree , hf_dns_opt_client_scope , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n if ( optlen - 4 > 16 ) {\n expert_add_info ( pinfo , rroptlen , & ei_dns_opt_bad_length ) ;\n optlen = 20 ;\n }\n tvb_memcpy ( tvb , ip_addr . bytes , cur_offset , ( optlen - 4 ) ) ;\n switch ( family ) {\n case AFNUM_INET : proto_tree_add_ipv4 ( rropt_tree , hf_dns_opt_client_addr4 , tvb , cur_offset , ( optlen - 4 ) , ip_addr . addr ) ;\n break ;\n case AFNUM_INET6 : proto_tree_add_ipv6 ( rropt_tree , hf_dns_opt_client_addr6 , tvb , cur_offset , ( optlen - 4 ) , ip_addr . bytes ) ;\n break ;\n default : proto_tree_add_item ( rropt_tree , hf_dns_opt_client_addr , tvb , cur_offset , ( optlen - 4 ) , ENC_NA ) ;\n break ;\n }\n cur_offset += ( optlen - 4 ) ;\n rropt_len -= optlen ;\n }\n break ;\n default : cur_offset += optlen ;\n rropt_len -= optlen ;\n break ;\n }\n }\n }\n break ;\n case T_APL : {\n int rr_len = data_len ;\n guint16 afamily ;\n guint8 afdpart_len ;\n guint8 * addr_copy ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n while ( rr_len > 1 ) {\n afamily = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_apl_address_family , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_apl_coded_prefix , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n afdpart_len = tvb_get_guint8 ( tvb , cur_offset ) & DNS_APL_AFDLENGTH ;\n proto_tree_add_item ( rr_tree , hf_dns_apl_negation , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rr_tree , hf_dns_apl_afdlength , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n if ( afamily == 1 && afdpart_len <= 4 ) {\n addr_copy = ( guint8 * ) wmem_alloc0 ( wmem_file_scope ( ) , 4 ) ;\n tvb_memcpy ( tvb , ( guint8 * ) addr_copy , cur_offset , afdpart_len ) ;\n proto_tree_add_ipv4 ( rr_tree , hf_dns_apl_afdpart_ipv4 , tvb , cur_offset , afdpart_len , * addr_copy ) ;\n }\n else if ( afamily == 2 && afdpart_len <= 16 ) {\n addr_copy = ( guint8 * ) wmem_alloc0 ( wmem_file_scope ( ) , 16 ) ;\n tvb_memcpy ( tvb , ( guint8 * ) addr_copy , cur_offset , afdpart_len ) ;\n proto_tree_add_ipv6 ( rr_tree , hf_dns_apl_afdpart_ipv6 , tvb , cur_offset , afdpart_len , addr_copy ) ;\n }\n else {\n proto_tree_add_item ( rr_tree , hf_dns_apl_afdpart_data , tvb , cur_offset , afdpart_len , ENC_NA ) ;\n }\n cur_offset += afdpart_len ;\n rr_len -= afdpart_len ;\n }\n }\n break ;\n case T_DS : case T_CDS : case T_DLV : {\n int rr_len = data_len ;\n proto_tree_add_item ( rr_tree , hf_dns_ds_key_id , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_ds_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_ds_digest_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_ds_digest , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n break ;\n case T_SSHFP : {\n int rr_len = data_len ;\n proto_tree_add_item ( rr_tree , hf_dns_sshfp_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_sshfp_fingerprint_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_sshfp_fingerprint , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_IPSECKEY : {\n int rr_len = data_len ;\n guint8 gw_type ;\n const guchar * gw ;\n int gw_name_len ;\n proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_precedence , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n gw_type = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n switch ( gw_type ) {\n case 0 : break ;\n case 1 : proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_ipv4 , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n break ;\n case 2 : proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_ipv6 , tvb , cur_offset , 16 , ENC_NA ) ;\n cur_offset += 16 ;\n rr_len -= 16 ;\n break ;\n case 3 : gw_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & gw ) ;\n proto_tree_add_string ( rr_tree , hf_dns_ipseckey_gateway_dns , tvb , cur_offset , gw_name_len , gw ) ;\n cur_offset += gw_name_len ;\n rr_len -= gw_name_len ;\n break ;\n default : break ;\n }\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_ipseckey_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_RRSIG : case T_SIG : {\n int rr_len = data_len ;\n const guchar * signer_name ;\n int signer_name_len ;\n proto_item * ti ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_type_covered , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_labels , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_rrsig_original_ttl , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \" (%s)\" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature_expiration , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature_inception , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_key_tag , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n signer_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & signer_name ) ;\n proto_tree_add_string ( rr_tree , hf_dns_rrsig_signers_name , tvb , cur_offset , signer_name_len , signer_name ) ;\n cur_offset += signer_name_len ;\n rr_len -= signer_name_len ;\n if ( rr_len != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n }\n break ;\n case T_NSEC : {\n int rr_len = data_len ;\n const guchar * next_domain_name ;\n int next_domain_name_len ;\n next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", next domain name %s\" , name_out ) ;\n proto_tree_add_string ( rr_tree , hf_dns_nsec_next_domain_name , tvb , cur_offset , next_domain_name_len , name_out ) ;\n cur_offset += next_domain_name_len ;\n rr_len -= next_domain_name_len ;\n dissect_type_bitmap ( rr_tree , tvb , cur_offset , rr_len ) ;\n }\n break ;\n case T_DNSKEY : case T_CDNSKEY : {\n int rr_len = data_len ;\n proto_item * tf , * ti_gen ;\n proto_tree * flags_tree ;\n guint16 key_id ;\n guint8 algo ;\n tf = proto_tree_add_item ( rr_tree , hf_dns_dnskey_flags , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n flags_tree = proto_item_add_subtree ( tf , ett_key_flags ) ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_zone_key , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_key_revoked , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_secure_entry_point , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_reserved , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( flags_tree , hf_dns_dnskey_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n algo = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n key_id = compute_key_id ( tvb , cur_offset - 4 , rr_len + 4 , algo ) ;\n ti_gen = proto_tree_add_uint ( rr_tree , hf_dns_dnskey_key_id , tvb , 0 , 0 , key_id ) ;\n PROTO_ITEM_SET_GENERATED ( ti_gen ) ;\n proto_tree_add_item ( rr_tree , hf_dns_dnskey_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n break ;\n case T_DHCID : {\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_dhcid_rdata , tvb , cur_offset , data_len , ENC_NA ) ;\n }\n break ;\n case T_NSEC3 : {\n int rr_len , initial_offset = cur_offset ;\n guint8 salt_len , hash_len ;\n proto_item * flags_item ;\n proto_tree * flags_tree ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n flags_item = proto_tree_add_item ( rr_tree , hf_dns_nsec3_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n flags_tree = proto_item_add_subtree ( flags_item , ett_nsec3_flags ) ;\n proto_tree_add_item ( flags_tree , hf_dns_nsec3_flag_optout , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_iterations , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n salt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_value , tvb , cur_offset , salt_len , ENC_NA ) ;\n cur_offset += salt_len ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_hash_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n hash_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_hash_value , tvb , cur_offset , hash_len , ENC_NA ) ;\n cur_offset += hash_len ;\n rr_len = data_len - ( cur_offset - initial_offset ) ;\n dissect_type_bitmap ( rr_tree , tvb , cur_offset , rr_len ) ;\n }\n break ;\n case T_NSEC3PARAM : {\n int salt_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_iterations , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n salt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n cur_offset += 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_value , tvb , cur_offset , salt_len , ENC_NA ) ;\n }\n break ;\n case T_TLSA : {\n int rr_len = data_len ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_tlsa_certificate_usage , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset ++ ;\n rr_len -- ;\n proto_tree_add_item ( rr_tree , hf_dns_tlsa_selector , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset ++ ;\n rr_len -- ;\n proto_tree_add_item ( rr_tree , hf_dns_tlsa_matching_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset ++ ;\n rr_len -- ;\n proto_tree_add_item ( rr_tree , hf_dns_tlsa_certificate_association_data , tvb , cur_offset , rr_len , ENC_NA ) ;\n }\n break ;\n case T_HIP : {\n guint8 hit_len ;\n guint16 pk_len ;\n int rr_len = data_len ;\n int rendezvous_len ;\n const guchar * rend_server_dns_name ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name ) ;\n }\n hit_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_hit_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_pk_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset += 1 ;\n rr_len -= 1 ;\n pk_len = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_pk_length , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n rr_len -= 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_hit , tvb , cur_offset , hit_len , ENC_NA ) ;\n cur_offset += hit_len ;\n rr_len -= hit_len ;\n proto_tree_add_item ( rr_tree , hf_dns_hip_pk , tvb , cur_offset , pk_len , ENC_NA ) ;\n cur_offset += pk_len ;\n rr_len -= pk_len ;\n while ( rr_len > 1 ) {\n rendezvous_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rend_server_dns_name ) ;\n proto_tree_add_string ( rr_tree , hf_dns_hip_rendezvous_server , tvb , cur_offset , rendezvous_len , rend_server_dns_name ) ;\n cur_offset += rendezvous_len ;\n rr_len -= rendezvous_len ;\n }\n }\n break ;\n case T_OPENPGPKEY : {\n proto_tree_add_item ( rr_tree , hf_dns_openpgpkey , tvb , cur_offset , data_len , ENC_ASCII | ENC_NA ) ;\n }\n break ;\n case T_SPF : {\n int rr_len = data_len ;\n int spf_offset ;\n int spf_len ;\n spf_offset = cur_offset ;\n while ( rr_len != 0 ) {\n spf_len = tvb_get_guint8 ( tvb , spf_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_spf_length , tvb , spf_offset , 1 , ENC_BIG_ENDIAN ) ;\n spf_offset += 1 ;\n rr_len -= 1 ;\n proto_tree_add_item ( rr_tree , hf_dns_spf , tvb , spf_offset , spf_len , ENC_ASCII | ENC_NA ) ;\n spf_offset += spf_len ;\n rr_len -= spf_len ;\n }\n }\n break ;\n case T_NID : {\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_nodeid_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_nodeid , tvb , cur_offset , 8 , ENC_NA ) ;\n }\n break ;\n case T_L32 : {\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator32_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator32 , tvb , cur_offset , 4 , ENC_NA ) ;\n }\n break ;\n case T_L64 : {\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator64_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator64 , tvb , cur_offset , 8 , ENC_NA ) ;\n }\n break ;\n case T_LP : {\n int lp_len ;\n const guchar * lp_str ;\n proto_tree_add_item ( rr_tree , hf_dns_ilnp_locatorfqdn_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n lp_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & lp_str ) ;\n proto_tree_add_string ( rr_tree , hf_dns_ilnp_locatorfqdn , tvb , cur_offset , lp_len , lp_str ) ;\n }\n break ;\n case T_EUI48 : {\n proto_tree_add_item ( rr_tree , hf_dns_eui48 , tvb , cur_offset , 6 , ENC_NA ) ;\n }\n break ;\n case T_EUI64 : {\n proto_tree_add_item ( rr_tree , hf_dns_eui64 , tvb , cur_offset , 8 , ENC_NA ) ;\n }\n break ;\n case T_TKEY : {\n const guchar * tkey_algname ;\n int tkey_algname_len ;\n guint16 tkey_mode , tkey_keylen , tkey_otherlen ;\n proto_tree * key_tree ;\n proto_item * key_item ;\n tkey_algname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & tkey_algname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_tkey_algo_name , tvb , cur_offset , tkey_algname_len , tkey_algname ) ;\n cur_offset += tkey_algname_len ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_signature_inception , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_signature_expiration , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_mode , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n tkey_mode = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_error , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_tkey_key_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n tkey_keylen = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n if ( tkey_keylen != 0 ) {\n key_item = proto_tree_add_item ( rr_tree , hf_dns_tkey_key_data , tvb , cur_offset , tkey_keylen , ENC_NA ) ;\n key_tree = proto_item_add_subtree ( key_item , ett_t_key ) ;\n switch ( tkey_mode ) {\n case TKEYMODE_GSSAPI : {\n tvbuff_t * gssapi_tvb ;\n gssapi_tvb = tvb_new_subset_length ( tvb , cur_offset , tkey_keylen ) ;\n if ( tvb_strneql ( gssapi_tvb , 0 , \"NTLMSSP\" , 7 ) == 0 ) {\n call_dissector ( ntlmssp_handle , gssapi_tvb , pinfo , key_tree ) ;\n }\n else {\n call_dissector ( gssapi_handle , gssapi_tvb , pinfo , key_tree ) ;\n }\n break ;\n }\n default : break ;\n }\n cur_offset += tkey_keylen ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_tkey_other_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n tkey_otherlen = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n if ( tkey_otherlen != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_tkey_other_data , tvb , cur_offset , tkey_otherlen , ENC_NA ) ;\n }\n }\n break ;\n case T_TSIG : {\n guint16 tsig_siglen , tsig_otherlen ;\n const guchar * tsig_algname ;\n int tsig_algname_len ;\n proto_item * ti ;\n tsig_algname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & tsig_algname ) ;\n proto_tree_add_string ( rr_tree , hf_dns_tsig_algorithm_name , tvb , cur_offset , tsig_algname_len , tsig_algname ) ;\n cur_offset += tsig_algname_len ;\n ti = proto_tree_add_item ( rr_tree , hf_dns_tsig_time_signed , tvb , cur_offset , 6 , ENC_NA ) ;\n if ( tvb_get_ntohs ( tvb , cur_offset ) ) {\n proto_item_append_text ( ti , \" (high bits set)\" ) ;\n }\n cur_offset += 6 ;\n proto_tree_add_item ( rr_tree , hf_dns_tsig_fudge , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n tsig_siglen = tvb_get_ntohs ( tvb , cur_offset ) ;\n proto_tree_add_item ( rr_tree , hf_dns_tsig_mac_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n if ( tsig_siglen != 0 ) {\n proto_item * mac_item ;\n proto_tree * mac_tree ;\n tvbuff_t * sub_tvb ;\n mac_item = proto_tree_add_item ( rr_tree , hf_dns_tsig_mac , tvb , cur_offset , tsig_siglen , ENC_NA ) ;\n mac_tree = proto_item_add_subtree ( mac_item , ett_dns_mac ) ;\n sub_tvb = tvb_new_subset_length ( tvb , cur_offset , tsig_siglen ) ;\n if ( ! dissector_try_string ( dns_tsig_dissector_table , tsig_algname , sub_tvb , pinfo , mac_tree , NULL ) ) {\n expert_add_info_format ( pinfo , mac_item , & ei_dns_tsig_alg , \"No dissector for algorithm:%s\" , tsig_algname ) ;\n }\n cur_offset += tsig_siglen ;\n }\n proto_tree_add_item ( rr_tree , hf_dns_tsig_original_id , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_tsig_error , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n cur_offset += 2 ;\n proto_tree_add_item ( rr_tree , hf_dns_tsig_other_len , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n tsig_otherlen = tvb_get_ntohs ( tvb , cur_offset ) ;\n cur_offset += 2 ;\n if ( tsig_otherlen != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_tsig_other_data , tvb , cur_offset , tsig_otherlen , ENC_NA ) ;\n }\n }\n break ;\n case T_CAA : {\n proto_item * caa_item ;\n proto_tree * caa_tree ;\n guint8 tag_len ;\n const char * tag ;\n gushort value_len ;\n const guchar * value ;\n int cur_hf = - 1 ;\n caa_item = proto_tree_add_item ( rr_tree , hf_dns_caa_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n caa_tree = proto_item_add_subtree ( caa_item , ett_caa_flags ) ;\n proto_tree_add_item ( caa_tree , hf_dns_caa_flag_issuer_critical , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n cur_offset ++ ;\n tag_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n tag = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cur_offset + 1 , tag_len , ENC_ASCII | ENC_NA ) ;\n value_len = data_len - ( tag_len + 2 ) ;\n value = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cur_offset + 1 + tag_len , value_len , ENC_ASCII | ENC_NA ) ;\n value = format_text ( value , value_len ) ;\n if ( strncmp ( tag , \"issue\" , tag_len ) == 0 ) {\n cur_hf = hf_dns_caa_issue ;\n }\n else if ( strncmp ( tag , \"issuewild\" , tag_len ) == 0 ) {\n cur_hf = hf_dns_caa_issuewild ;\n }\n else if ( strncmp ( tag , \"iodef\" , tag_len ) == 0 ) {\n cur_hf = hf_dns_caa_iodef ;\n }\n else {\n cur_hf = hf_dns_caa_unknown ;\n }\n caa_item = proto_tree_add_string ( rr_tree , cur_hf , tvb , cur_offset , 1 + tag_len + value_len , value ) ;\n caa_tree = proto_item_add_subtree ( caa_item , ett_caa_data ) ;\n proto_tree_add_uint ( caa_tree , hf_dns_caa_tag_length , tvb , cur_offset , 1 , tag_len ) ;\n proto_tree_add_string ( caa_tree , hf_dns_caa_tag , tvb , cur_offset + 1 , tag_len , tag ) ;\n proto_tree_add_string ( caa_tree , hf_dns_caa_value , tvb , cur_offset + 1 + tag_len , value_len , value ) ;\n }\n break ;\n case T_WINS : {\n int rr_len = data_len ;\n guint32 nservers ;\n proto_tree_add_item ( rr_tree , hf_dns_wins_local_flag , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_wins_lookup_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_wins_cache_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_wins_nb_wins_servers , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n nservers = tvb_get_ntohl ( tvb , cur_offset ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n while ( rr_len != 0 && nservers != 0 ) {\n proto_tree_add_item ( rr_tree , hf_dns_wins_server , tvb , cur_offset , 4 , ENC_NA ) ;\n cur_offset += 4 ;\n rr_len -= 4 ;\n nservers -- ;\n }\n }\n break ;\n case T_WINS_R : {\n const guchar * dname ;\n int dname_len ;\n proto_tree_add_item ( rr_tree , hf_dns_winsr_local_flag , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_winsr_lookup_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n proto_tree_add_item ( rr_tree , hf_dns_winsr_cache_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n cur_offset += 4 ;\n dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n name_out = format_text ( dname , strlen ( dname ) ) ;\n proto_tree_add_string ( rr_tree , hf_dns_winsr_name_result_domain , tvb , cur_offset , dname_len , name_out ) ;\n if ( cinfo != NULL ) {\n col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n }\n proto_item_append_text ( trr , \", name result domain %s\" , name_out ) ;\n }\n break ;\n default : expert_add_info_format ( pinfo , trr , & ei_dns_undecoded_option , \"Dissector for DNS Type (%d)\" \" code not implemented, Contact Wireshark developers\" \" if you want this supported\" , dns_type ) ;\n proto_tree_add_item ( rr_tree , hf_dns_data , tvb , cur_offset , data_len , ENC_NA ) ;\n break ;\n }\n data_offset += data_len ;\n return data_offset - data_start ;\n }",
        "hash": 5506079590431503777,
        "project": "debian",
        "size": 1303,
        "slice": {
            "strlen": [
                [
                    1,
                    "static int dissect_dns_answer ( tvbuff_t * tvb , int offsetx , int dns_data_offset , column_info * cinfo , proto_tree * dns_tree , packet_info * pinfo , gboolean is_mdns ) {\n"
                ],
                [
                    19,
                    " len = get_dns_name_type_class ( tvb , offsetx , dns_data_offset , & name , & name_len , & dns_type , & dns_class ) ;\n"
                ],
                [
                    42,
                    " if ( dns_tree != NULL ) {\n"
                ],
                [
                    43,
                    " name_out = format_text ( name , strlen ( name ) ) ;\n"
                ],
                [
                    45,
                    " rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , \"%s: type %s, class %s\" , name_out , type_name , class_name ) ;\n"
                ],
                [
                    46,
                    " add_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , dns_type , pinfo , is_mdns ) ;\n"
                ],
                [
                    49,
                    " rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , \"%s: type %s\" , name_out , type_name ) ;\n"
                ],
                [
                    50,
                    " add_opt_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , is_mdns ) ;\n"
                ],
                [
                    59,
                    " switch ( dns_type ) {\n"
                ],
                [
                    78,
                    " ns_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & ns_name ) ;\n"
                ],
                [
                    79,
                    " name_out = format_text ( ns_name , strlen ( ns_name ) ) ;\n"
                ],
                [
                    81,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    83,
                    " proto_item_append_text ( trr , \", ns %s\" , name_out ) ;\n"
                ],
                [
                    110,
                    " cname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & cname ) ;\n"
                ],
                [
                    111,
                    " name_out = format_text ( cname , strlen ( cname ) ) ;\n"
                ],
                [
                    113,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    115,
                    " proto_item_append_text ( trr , \", cname %s\" , name_out ) ;\n"
                ],
                [
                    125,
                    " mname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mname ) ;\n"
                ],
                [
                    126,
                    " name_out = format_text ( mname , strlen ( mname ) ) ;\n"
                ],
                [
                    128,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    130,
                    " proto_item_append_text ( trr , \", mname %s\" , name_out ) ;\n"
                ],
                [
                    133,
                    " rname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rname ) ;\n"
                ],
                [
                    134,
                    " name_out = format_text ( rname , strlen ( rname ) ) ;\n"
                ],
                [
                    135,
                    " proto_tree_add_string ( rr_tree , hf_dns_soa_rname , tvb , cur_offset , rname_len , name_out ) ;\n"
                ],
                [
                    250,
                    " pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n"
                ],
                [
                    251,
                    " name_out = format_text ( pname , strlen ( pname ) ) ;\n"
                ],
                [
                    253,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    255,
                    " proto_item_append_text ( trr , \", %s\" , name_out ) ;\n"
                ],
                [
                    303,
                    " mx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & mx_name ) ;\n"
                ],
                [
                    304,
                    " name_out = format_text ( mx_name , strlen ( mx_name ) ) ;\n"
                ],
                [
                    306,
                    " col_append_fstr ( cinfo , COL_INFO , \" %u %s\" , preference , name_out ) ;\n"
                ],
                [
                    308,
                    " proto_item_append_text ( trr , \", preference %u, mx %s\" , preference , name_out ) ;\n"
                ],
                [
                    538,
                    " next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n"
                ],
                [
                    539,
                    " name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n"
                ],
                [
                    565,
                    " target_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & target ) ;\n"
                ],
                [
                    566,
                    " name_out = format_text ( target , strlen ( target ) ) ;\n"
                ],
                [
                    567,
                    " proto_tree_add_string ( rr_tree , hf_dns_srv_target , tvb , cur_offset , target_len , name_out ) ;\n"
                ],
                [
                    607,
                    " replacement_len = get_dns_name ( tvb , offset , 0 , dns_data_offset , & replacement ) ;\n"
                ],
                [
                    608,
                    " name_out = format_text ( replacement , strlen ( replacement ) ) ;\n"
                ],
                [
                    611,
                    " proto_tree_add_string ( rr_tree , hf_dns_naptr_replacement , tvb , offset , replacement_len , name_out ) ;\n"
                ],
                [
                    621,
                    " kx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & kx_name ) ;\n"
                ],
                [
                    622,
                    " name_out = format_text ( kx_name , strlen ( kx_name ) ) ;\n"
                ],
                [
                    624,
                    " col_append_fstr ( cinfo , COL_INFO , \" %u %s\" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n"
                ],
                [
                    626,
                    " proto_item_append_text ( trr , \", preference %u, kx %s\" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n"
                ],
                [
                    674,
                    " pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n"
                ],
                [
                    677,
                    " pname = \"\" ;\n"
                ],
                [
                    680,
                    " name_out = format_text ( pname , strlen ( pname ) ) ;\n"
                ],
                [
                    683,
                    " col_append_fstr ( cinfo , COL_INFO , \" %d %s %s\" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n"
                ],
                [
                    692,
                    " proto_tree_add_string ( rr_tree , hf_dns_a6_prefix_name , tvb , a6_offset , pname_len , name_out ) ;\n"
                ],
                [
                    694,
                    " proto_item_append_text ( trr , \", addr %d %s %s\" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n"
                ],
                [
                    700,
                    " dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n"
                ],
                [
                    701,
                    " name_out = format_text ( dname , strlen ( dname ) ) ;\n"
                ],
                [
                    703,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    705,
                    " proto_item_append_text ( trr , \", dname %s\" , name_out ) ;\n"
                ],
                [
                    933,
                    " next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n"
                ],
                [
                    934,
                    " name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n"
                ],
                [
                    1288,
                    " dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n"
                ],
                [
                    1289,
                    " name_out = format_text ( dname , strlen ( dname ) ) ;\n"
                ],
                [
                    1290,
                    " proto_tree_add_string ( rr_tree , hf_dns_winsr_name_result_domain , tvb , cur_offset , dname_len , name_out ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int dissect_dns_answer ( tvbuff_t * tvb , int offsetx , int dns_data_offset , column_info * cinfo , proto_tree * dns_tree , packet_info * pinfo , gboolean is_mdns ) {\n"
                ],
                [
                    19,
                    " len = get_dns_name_type_class ( tvb , offsetx , dns_data_offset , & name , & name_len , & dns_type , & dns_class ) ;\n"
                ],
                [
                    42,
                    " if ( dns_tree != NULL ) {\n"
                ],
                [
                    43,
                    " name_out = format_text ( name , strlen ( name ) ) ;\n"
                ],
                [
                    45,
                    " rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , \"%s: type %s, class %s\" , name_out , type_name , class_name ) ;\n"
                ],
                [
                    46,
                    " add_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , dns_type , pinfo , is_mdns ) ;\n"
                ],
                [
                    49,
                    " rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , \"%s: type %s\" , name_out , type_name ) ;\n"
                ],
                [
                    50,
                    " add_opt_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , is_mdns ) ;\n"
                ],
                [
                    59,
                    " switch ( dns_type ) {\n"
                ],
                [
                    78,
                    " ns_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & ns_name ) ;\n"
                ],
                [
                    79,
                    " name_out = format_text ( ns_name , strlen ( ns_name ) ) ;\n"
                ],
                [
                    81,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    83,
                    " proto_item_append_text ( trr , \", ns %s\" , name_out ) ;\n"
                ],
                [
                    110,
                    " cname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & cname ) ;\n"
                ],
                [
                    111,
                    " name_out = format_text ( cname , strlen ( cname ) ) ;\n"
                ],
                [
                    113,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    115,
                    " proto_item_append_text ( trr , \", cname %s\" , name_out ) ;\n"
                ],
                [
                    125,
                    " mname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mname ) ;\n"
                ],
                [
                    126,
                    " name_out = format_text ( mname , strlen ( mname ) ) ;\n"
                ],
                [
                    128,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    130,
                    " proto_item_append_text ( trr , \", mname %s\" , name_out ) ;\n"
                ],
                [
                    133,
                    " rname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rname ) ;\n"
                ],
                [
                    134,
                    " name_out = format_text ( rname , strlen ( rname ) ) ;\n"
                ],
                [
                    135,
                    " proto_tree_add_string ( rr_tree , hf_dns_soa_rname , tvb , cur_offset , rname_len , name_out ) ;\n"
                ],
                [
                    250,
                    " pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n"
                ],
                [
                    251,
                    " name_out = format_text ( pname , strlen ( pname ) ) ;\n"
                ],
                [
                    253,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    255,
                    " proto_item_append_text ( trr , \", %s\" , name_out ) ;\n"
                ],
                [
                    303,
                    " mx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & mx_name ) ;\n"
                ],
                [
                    304,
                    " name_out = format_text ( mx_name , strlen ( mx_name ) ) ;\n"
                ],
                [
                    306,
                    " col_append_fstr ( cinfo , COL_INFO , \" %u %s\" , preference , name_out ) ;\n"
                ],
                [
                    308,
                    " proto_item_append_text ( trr , \", preference %u, mx %s\" , preference , name_out ) ;\n"
                ],
                [
                    538,
                    " next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n"
                ],
                [
                    539,
                    " name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n"
                ],
                [
                    565,
                    " target_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & target ) ;\n"
                ],
                [
                    566,
                    " name_out = format_text ( target , strlen ( target ) ) ;\n"
                ],
                [
                    567,
                    " proto_tree_add_string ( rr_tree , hf_dns_srv_target , tvb , cur_offset , target_len , name_out ) ;\n"
                ],
                [
                    607,
                    " replacement_len = get_dns_name ( tvb , offset , 0 , dns_data_offset , & replacement ) ;\n"
                ],
                [
                    608,
                    " name_out = format_text ( replacement , strlen ( replacement ) ) ;\n"
                ],
                [
                    611,
                    " proto_tree_add_string ( rr_tree , hf_dns_naptr_replacement , tvb , offset , replacement_len , name_out ) ;\n"
                ],
                [
                    621,
                    " kx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & kx_name ) ;\n"
                ],
                [
                    622,
                    " name_out = format_text ( kx_name , strlen ( kx_name ) ) ;\n"
                ],
                [
                    624,
                    " col_append_fstr ( cinfo , COL_INFO , \" %u %s\" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n"
                ],
                [
                    626,
                    " proto_item_append_text ( trr , \", preference %u, kx %s\" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n"
                ],
                [
                    674,
                    " pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n"
                ],
                [
                    677,
                    " pname = \"\" ;\n"
                ],
                [
                    680,
                    " name_out = format_text ( pname , strlen ( pname ) ) ;\n"
                ],
                [
                    683,
                    " col_append_fstr ( cinfo , COL_INFO , \" %d %s %s\" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n"
                ],
                [
                    692,
                    " proto_tree_add_string ( rr_tree , hf_dns_a6_prefix_name , tvb , a6_offset , pname_len , name_out ) ;\n"
                ],
                [
                    694,
                    " proto_item_append_text ( trr , \", addr %d %s %s\" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n"
                ],
                [
                    700,
                    " dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n"
                ],
                [
                    701,
                    " name_out = format_text ( dname , strlen ( dname ) ) ;\n"
                ],
                [
                    703,
                    " col_append_fstr ( cinfo , COL_INFO , \" %s\" , name_out ) ;\n"
                ],
                [
                    705,
                    " proto_item_append_text ( trr , \", dname %s\" , name_out ) ;\n"
                ],
                [
                    933,
                    " next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n"
                ],
                [
                    934,
                    " name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n"
                ],
                [
                    1288,
                    " dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n"
                ],
                [
                    1289,
                    " name_out = format_text ( dname , strlen ( dname ) ) ;\n"
                ],
                [
                    1290,
                    " proto_tree_add_string ( rr_tree , hf_dns_winsr_name_result_domain , tvb , cur_offset , dname_len , name_out ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int av_image_fill_pointers ( uint8_t * data [ 4 ] , enum PixelFormat pix_fmt , int height , uint8_t * ptr , const int linesizes [ 4 ] ) {\n int i , total_size , size [ 4 ] , has_plane [ 4 ] ;\n const AVPixFmtDescriptor * desc = & av_pix_fmt_descriptors [ pix_fmt ] ;\n memset ( data , 0 , sizeof ( data [ 0 ] ) * 4 ) ;\n memset ( size , 0 , sizeof ( size ) ) ;\n memset ( has_plane , 0 , sizeof ( has_plane ) ) ;\n if ( ( unsigned ) pix_fmt >= PIX_FMT_NB || desc -> flags & PIX_FMT_HWACCEL ) return AVERROR ( EINVAL ) ;\n data [ 0 ] = ptr ;\n if ( linesizes [ 0 ] > ( INT_MAX - 1024 ) / height ) return AVERROR ( EINVAL ) ;\n size [ 0 ] = linesizes [ 0 ] * height ;\n if ( desc -> flags & PIX_FMT_PAL ) {\n size [ 0 ] = ( size [ 0 ] + 3 ) & ~ 3 ;\n data [ 1 ] = ptr + size [ 0 ] ;\n return size [ 0 ] + 256 * 4 ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) has_plane [ desc -> comp [ i ] . plane ] = 1 ;\n total_size = size [ 0 ] ;\n for ( i = 1 ;\n has_plane [ i ] && i < 4 ;\n i ++ ) {\n int h , s = ( i == 1 || i == 2 ) ? desc -> log2_chroma_h : 0 ;\n data [ i ] = data [ i - 1 ] + size [ i - 1 ] ;\n h = ( height + ( 1 << s ) - 1 ) >> s ;\n if ( linesizes [ i ] > INT_MAX / h ) return AVERROR ( EINVAL ) ;\n size [ i ] = h * linesizes [ i ] ;\n if ( total_size > INT_MAX - size [ i ] ) return AVERROR ( EINVAL ) ;\n total_size += size [ i ] ;\n }\n return total_size ;\n }",
        "hash": -1493847185972313035,
        "project": "debian",
        "size": 32,
        "slice": {
            "memset": [
                [
                    1,
                    "int av_image_fill_pointers ( uint8_t * data [ 4 ] , enum PixelFormat pix_fmt , int height , uint8_t * ptr , const int linesizes [ 4 ] ) {\n"
                ],
                [
                    4,
                    " memset ( data , 0 , sizeof ( data [ 0 ] ) * 4 ) ;\n"
                ],
                [
                    5,
                    " memset ( size , 0 , sizeof ( size ) ) ;\n"
                ],
                [
                    6,
                    " memset ( has_plane , 0 , sizeof ( has_plane ) ) ;\n"
                ],
                [
                    12,
                    " size [ 0 ] = ( size [ 0 ] + 3 ) & ~ 3 ;\n"
                ],
                [
                    13,
                    " data [ 1 ] = ptr + size [ 0 ] ;\n"
                ],
                [
                    14,
                    " return size [ 0 ] + 256 * 4 ;\n"
                ],
                [
                    19,
                    " total_size = size [ 0 ] ;\n"
                ],
                [
                    21,
                    " has_plane [ i ] && i < 4 ;\n"
                ],
                [
                    24,
                    " data [ i ] = data [ i - 1 ] + size [ i - 1 ] ;\n"
                ],
                [
                    28,
                    " if ( total_size > INT_MAX - size [ i ] ) return AVERROR ( EINVAL ) ;\n"
                ],
                [
                    29,
                    " total_size += size [ i ] ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int av_image_fill_pointers ( uint8_t * data [ 4 ] , enum PixelFormat pix_fmt , int height , uint8_t * ptr , const int linesizes [ 4 ] ) {\n"
                ],
                [
                    4,
                    " memset ( data , 0 , sizeof ( data [ 0 ] ) * 4 ) ;\n"
                ],
                [
                    5,
                    " memset ( size , 0 , sizeof ( size ) ) ;\n"
                ],
                [
                    6,
                    " memset ( has_plane , 0 , sizeof ( has_plane ) ) ;\n"
                ],
                [
                    12,
                    " size [ 0 ] = ( size [ 0 ] + 3 ) & ~ 3 ;\n"
                ],
                [
                    13,
                    " data [ 1 ] = ptr + size [ 0 ] ;\n"
                ],
                [
                    14,
                    " return size [ 0 ] + 256 * 4 ;\n"
                ],
                [
                    19,
                    " total_size = size [ 0 ] ;\n"
                ],
                [
                    21,
                    " has_plane [ i ] && i < 4 ;\n"
                ],
                [
                    24,
                    " data [ i ] = data [ i - 1 ] + size [ i - 1 ] ;\n"
                ],
                [
                    28,
                    " if ( total_size > INT_MAX - size [ i ] ) return AVERROR ( EINVAL ) ;\n"
                ],
                [
                    29,
                    " total_size += size [ i ] ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int com_connect ( String * buffer , char * line ) {\n char * tmp , buff [ 256 ] ;\n my_bool save_rehash = opt_rehash ;\n int error ;\n bzero ( buff , sizeof ( buff ) ) ;\n if ( buffer ) {\n tmp = strmake ( buff , line , sizeof ( buff ) - 2 ) ;\n # ifdef EXTRA_DEBUG tmp [ 1 ] = 0 ;\n # endif tmp = get_arg ( buff , 0 ) ;\n if ( tmp && * tmp ) {\n my_free ( current_db ) ;\n current_db = my_strdup ( tmp , MYF ( MY_WME ) ) ;\n tmp = get_arg ( buff , 1 ) ;\n if ( tmp ) {\n my_free ( current_host ) ;\n current_host = my_strdup ( tmp , MYF ( MY_WME ) ) ;\n }\n }\n else {\n opt_rehash = 0 ;\n }\n buffer -> length ( 0 ) ;\n }\n else opt_rehash = 0 ;\n error = sql_connect ( current_host , current_db , current_user , opt_password , 0 ) ;\n opt_rehash = save_rehash ;\n if ( connected ) {\n sprintf ( buff , \"Connection id: %lu\" , mysql_thread_id ( & mysql ) ) ;\n put_info ( buff , INFO_INFO ) ;\n sprintf ( buff , \"Current database: %.128s\\n\" , current_db ? current_db : \"*** NONE ***\" ) ;\n put_info ( buff , INFO_INFO ) ;\n }\n return error ;\n }",
        "hash": 7191899184788440065,
        "project": "debian",
        "size": 34,
        "slice": {
            "sprintf": [
                [
                    1,
                    "static int com_connect ( String * buffer , char * line ) {\n"
                ],
                [
                    5,
                    " bzero ( buff , sizeof ( buff ) ) ;\n"
                ],
                [
                    7,
                    " tmp = strmake ( buff , line , sizeof ( buff ) - 2 ) ;\n"
                ],
                [
                    13,
                    " tmp = get_arg ( buff , 1 ) ;\n"
                ],
                [
                    25,
                    " error = sql_connect ( current_host , current_db , current_user , opt_password , 0 ) ;\n"
                ],
                [
                    27,
                    " if ( connected ) {\n"
                ],
                [
                    28,
                    " sprintf ( buff , \"Connection id: %lu\" , mysql_thread_id ( & mysql ) ) ;\n"
                ],
                [
                    29,
                    " put_info ( buff , INFO_INFO ) ;\n"
                ],
                [
                    30,
                    " sprintf ( buff , \"Current database: %.128s\\n\" , current_db ? current_db : \"*** NONE ***\" ) ;\n"
                ],
                [
                    31,
                    " put_info ( buff , INFO_INFO ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int com_connect ( String * buffer , char * line ) {\n"
                ],
                [
                    5,
                    " bzero ( buff , sizeof ( buff ) ) ;\n"
                ],
                [
                    7,
                    " tmp = strmake ( buff , line , sizeof ( buff ) - 2 ) ;\n"
                ],
                [
                    13,
                    " tmp = get_arg ( buff , 1 ) ;\n"
                ],
                [
                    25,
                    " error = sql_connect ( current_host , current_db , current_user , opt_password , 0 ) ;\n"
                ],
                [
                    27,
                    " if ( connected ) {\n"
                ],
                [
                    28,
                    " sprintf ( buff , \"Connection id: %lu\" , mysql_thread_id ( & mysql ) ) ;\n"
                ],
                [
                    29,
                    " put_info ( buff , INFO_INFO ) ;\n"
                ],
                [
                    30,
                    " sprintf ( buff , \"Current database: %.128s\\n\" , current_db ? current_db : \"*** NONE ***\" ) ;\n"
                ],
                [
                    31,
                    " put_info ( buff , INFO_INFO ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n char buff [ 256 ] , * tmp ;\n strmake_buf ( buff , line ) ;\n tmp = get_arg ( buff , 0 ) ;\n if ( ! tmp || ! * tmp ) {\n put_info ( \"DELIMITER must be followed by a 'delimiter' character or string\" , INFO_ERROR ) ;\n return 0 ;\n }\n else {\n if ( strstr ( tmp , \"\\\\\" ) ) {\n put_info ( \"DELIMITER cannot contain a backslash character\" , INFO_ERROR ) ;\n return 0 ;\n }\n }\n strmake_buf ( delimiter , tmp ) ;\n delimiter_length = ( int ) strlen ( delimiter ) ;\n delimiter_str = delimiter ;\n return 0 ;\n }",
        "hash": 7191899184788440065,
        "project": "debian",
        "size": 19,
        "slice": {
            "strlen": [
                [
                    1,
                    "static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n"
                ],
                [
                    10,
                    " if ( strstr ( tmp , \"\\\\\" ) ) {\n"
                ],
                [
                    15,
                    " strmake_buf ( delimiter , tmp ) ;\n"
                ],
                [
                    16,
                    " delimiter_length = ( int ) strlen ( delimiter ) ;\n"
                ],
                [
                    17,
                    " delimiter_str = delimiter ;\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n"
                ],
                [
                    5,
                    " if ( ! tmp || ! * tmp ) {\n"
                ],
                [
                    10,
                    " if ( strstr ( tmp , \"\\\\\" ) ) {\n"
                ],
                [
                    11,
                    " put_info ( \"DELIMITER cannot contain a backslash character\" , INFO_ERROR ) ;\n"
                ],
                [
                    12,
                    " return 0 ;\n"
                ],
                [
                    15,
                    " strmake_buf ( delimiter , tmp ) ;\n"
                ],
                [
                    16,
                    " delimiter_length = ( int ) strlen ( delimiter ) ;\n"
                ],
                [
                    17,
                    " delimiter_str = delimiter ;\n"
                ],
                [
                    18,
                    " return 0 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n"
                ],
                [
                    5,
                    " if ( ! tmp || ! * tmp ) {\n"
                ],
                [
                    10,
                    " if ( strstr ( tmp , \"\\\\\" ) ) {\n"
                ],
                [
                    11,
                    " put_info ( \"DELIMITER cannot contain a backslash character\" , INFO_ERROR ) ;\n"
                ],
                [
                    12,
                    " return 0 ;\n"
                ],
                [
                    15,
                    " strmake_buf ( delimiter , tmp ) ;\n"
                ],
                [
                    16,
                    " delimiter_length = ( int ) strlen ( delimiter ) ;\n"
                ],
                [
                    17,
                    " delimiter_str = delimiter ;\n"
                ],
                [
                    18,
                    " return 0 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static COMMANDS * find_command ( char * name ) {\n uint len ;\n char * end ;\n DBUG_ENTER ( \"find_command\" ) ;\n DBUG_ASSERT ( name != NULL ) ;\n DBUG_PRINT ( \"enter\" , ( \"name: '%s'\" , name ) ) ;\n while ( my_isspace ( charset_info , * name ) ) name ++ ;\n if ( ( ! real_binary_mode && strstr ( name , \"\\\\g\" ) ) || ( strstr ( name , delimiter ) && ! is_delimiter_command ( name , DELIMITER_NAME_LEN ) ) ) DBUG_RETURN ( ( COMMANDS * ) 0 ) ;\n if ( ( end = strcont ( name , \" \\t\" ) ) ) {\n len = ( uint ) ( end - name ) ;\n while ( my_isspace ( charset_info , * end ) ) end ++ ;\n if ( ! * end ) end = 0 ;\n }\n else len = ( uint ) strlen ( name ) ;\n int index = - 1 ;\n if ( real_binary_mode ) {\n if ( is_delimiter_command ( name , len ) ) index = delimiter_index ;\n }\n else {\n for ( uint i = 0 ;\n commands [ i ] . func ;\n i ++ ) {\n if ( ! my_strnncoll ( & my_charset_latin1 , ( uchar * ) name , len , ( uchar * ) commands [ i ] . name , len ) && ( commands [ i ] . name [ len ] == '\\0' ) && ( ! end || commands [ i ] . takes_params ) ) {\n index = i ;\n break ;\n }\n }\n }\n if ( index >= 0 ) {\n DBUG_PRINT ( \"exit\" , ( \"found command: %s\" , commands [ index ] . name ) ) ;\n DBUG_RETURN ( & commands [ index ] ) ;\n }\n DBUG_RETURN ( ( COMMANDS * ) 0 ) ;\n }",
        "hash": 7191899184788440065,
        "project": "debian",
        "size": 34,
        "slice": {
            "strlen": [
                [
                    1,
                    "static COMMANDS * find_command ( char * name ) {\n"
                ],
                [
                    7,
                    " while ( my_isspace ( charset_info , * name ) ) name ++ ;\n"
                ],
                [
                    9,
                    " if ( ( end = strcont ( name , \" \\t\" ) ) ) {\n"
                ],
                [
                    14,
                    " else len = ( uint ) strlen ( name ) ;\n"
                ],
                [
                    17,
                    " if ( is_delimiter_command ( name , len ) ) index = delimiter_index ;\n"
                ],
                [
                    23,
                    " if ( ! my_strnncoll ( & my_charset_latin1 , ( uchar * ) name , len , ( uchar * ) commands [ i ] . name , len ) && ( commands [ i ] . name [ len ] == '\\0' ) && ( ! end || commands [ i ] . takes_params ) ) {\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "static COMMANDS * find_command ( char * name ) {\n"
                ],
                [
                    6,
                    " DBUG_PRINT ( \"enter\" , ( \"name: '%s'\" , name ) ) ;\n"
                ],
                [
                    7,
                    " while ( my_isspace ( charset_info , * name ) ) name ++ ;\n"
                ],
                [
                    8,
                    " if ( ( ! real_binary_mode && strstr ( name , \"\\\\g\" ) ) || ( strstr ( name , delimiter ) && ! is_delimiter_command ( name , DELIMITER_NAME_LEN ) ) ) DBUG_RETURN ( ( COMMANDS * ) 0 ) ;\n"
                ],
                [
                    9,
                    " if ( ( end = strcont ( name , \" \\t\" ) ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static COMMANDS * find_command ( char * name ) {\n"
                ],
                [
                    6,
                    " DBUG_PRINT ( \"enter\" , ( \"name: '%s'\" , name ) ) ;\n"
                ],
                [
                    7,
                    " while ( my_isspace ( charset_info , * name ) ) name ++ ;\n"
                ],
                [
                    8,
                    " if ( ( ! real_binary_mode && strstr ( name , \"\\\\g\" ) ) || ( strstr ( name , delimiter ) && ! is_delimiter_command ( name , DELIMITER_NAME_LEN ) ) ) DBUG_RETURN ( ( COMMANDS * ) 0 ) ;\n"
                ],
                [
                    9,
                    " if ( ( end = strcont ( name , \" \\t\" ) ) ) {\n"
                ],
                [
                    14,
                    " else len = ( uint ) strlen ( name ) ;\n"
                ],
                [
                    17,
                    " if ( is_delimiter_command ( name , len ) ) index = delimiter_index ;\n"
                ],
                [
                    23,
                    " if ( ! my_strnncoll ( & my_charset_latin1 , ( uchar * ) name , len , ( uchar * ) commands [ i ] . name , len ) && ( commands [ i ] . name [ len ] == '\\0' ) && ( ! end || commands [ i ] . takes_params ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static void fmtint ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , LLONG value , int base , int min , int max , int flags ) {\n int signvalue = 0 ;\n const char * prefix = \"\" ;\n unsigned LLONG uvalue ;\n char convert [ DECIMAL_SIZE ( value ) + 3 ] ;\n int place = 0 ;\n int spadlen = 0 ;\n int zpadlen = 0 ;\n int caps = 0 ;\n if ( max < 0 ) max = 0 ;\n uvalue = value ;\n if ( ! ( flags & DP_F_UNSIGNED ) ) {\n if ( value < 0 ) {\n signvalue = '-' ;\n uvalue = - value ;\n }\n else if ( flags & DP_F_PLUS ) signvalue = '+' ;\n else if ( flags & DP_F_SPACE ) signvalue = ' ' ;\n }\n if ( flags & DP_F_NUM ) {\n if ( base == 8 ) prefix = \"0\" ;\n if ( base == 16 ) prefix = \"0x\" ;\n }\n if ( flags & DP_F_UP ) caps = 1 ;\n do {\n convert [ place ++ ] = ( caps ? \"0123456789ABCDEF\" : \"0123456789abcdef\" ) [ uvalue % ( unsigned ) base ] ;\n uvalue = ( uvalue / ( unsigned ) base ) ;\n }\n while ( uvalue && ( place < ( int ) sizeof ( convert ) ) ) ;\n if ( place == sizeof ( convert ) ) place -- ;\n convert [ place ] = 0 ;\n zpadlen = max - place ;\n spadlen = min - OSSL_MAX ( max , place ) - ( signvalue ? 1 : 0 ) - strlen ( prefix ) ;\n if ( zpadlen < 0 ) zpadlen = 0 ;\n if ( spadlen < 0 ) spadlen = 0 ;\n if ( flags & DP_F_ZERO ) {\n zpadlen = OSSL_MAX ( zpadlen , spadlen ) ;\n spadlen = 0 ;\n }\n if ( flags & DP_F_MINUS ) spadlen = - spadlen ;\n while ( spadlen > 0 ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ;\n -- spadlen ;\n }\n if ( signvalue ) doapr_outch ( sbuffer , buffer , currlen , maxlen , signvalue ) ;\n while ( * prefix ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , * prefix ) ;\n prefix ++ ;\n }\n if ( zpadlen > 0 ) {\n while ( zpadlen > 0 ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , '0' ) ;\n -- zpadlen ;\n }\n }\n while ( place > 0 ) doapr_outch ( sbuffer , buffer , currlen , maxlen , convert [ -- place ] ) ;\n while ( spadlen < 0 ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ;\n ++ spadlen ;\n }\n return ;\n }",
        "hash": -789251383577298283,
        "project": "debian",
        "size": 62,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void fmtint ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , LLONG value , int base , int min , int max , int flags ) {\n"
                ],
                [
                    3,
                    " const char * prefix = \"\" ;\n"
                ],
                [
                    21,
                    " if ( base == 8 ) prefix = \"0\" ;\n"
                ],
                [
                    22,
                    " if ( base == 16 ) prefix = \"0x\" ;\n"
                ],
                [
                    33,
                    " spadlen = min - OSSL_MAX ( max , place ) - ( signvalue ? 1 : 0 ) - strlen ( prefix ) ;\n"
                ],
                [
                    48,
                    " prefix ++ ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void fmtint ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , LLONG value , int base , int min , int max , int flags ) {\n"
                ],
                [
                    3,
                    " const char * prefix = \"\" ;\n"
                ],
                [
                    21,
                    " if ( base == 8 ) prefix = \"0\" ;\n"
                ],
                [
                    22,
                    " if ( base == 16 ) prefix = \"0x\" ;\n"
                ],
                [
                    33,
                    " spadlen = min - OSSL_MAX ( max , place ) - ( signvalue ? 1 : 0 ) - strlen ( prefix ) ;\n"
                ],
                [
                    48,
                    " prefix ++ ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void doapr_outch ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , int c ) {\n assert ( * sbuffer != NULL || buffer != NULL ) ;\n assert ( * currlen <= * maxlen ) ;\n if ( buffer && * currlen == * maxlen ) {\n * maxlen += 1024 ;\n if ( * buffer == NULL ) {\n * buffer = OPENSSL_malloc ( * maxlen ) ;\n if ( ! * buffer ) {\n return ;\n }\n if ( * currlen > 0 ) {\n assert ( * sbuffer != NULL ) ;\n memcpy ( * buffer , * sbuffer , * currlen ) ;\n }\n * sbuffer = NULL ;\n }\n else {\n * buffer = OPENSSL_realloc ( * buffer , * maxlen ) ;\n if ( ! * buffer ) {\n return ;\n }\n }\n }\n if ( * currlen < * maxlen ) {\n if ( * sbuffer ) ( * sbuffer ) [ ( * currlen ) ++ ] = ( char ) c ;\n else ( * buffer ) [ ( * currlen ) ++ ] = ( char ) c ;\n }\n return ;\n }",
        "hash": -789251383577298283,
        "project": "debian",
        "size": 29,
        "slice": {
            "memcpy": [
                [
                    8,
                    " if ( ! * buffer ) {\n"
                ],
                [
                    11,
                    " if ( * currlen > 0 ) {\n"
                ],
                [
                    12,
                    " assert ( * sbuffer != NULL ) ;\n"
                ],
                [
                    13,
                    " memcpy ( * buffer , * sbuffer , * currlen ) ;\n"
                ],
                [
                    24,
                    " if ( * currlen < * maxlen ) {\n"
                ]
            ],
            "result": [
                [
                    8,
                    " if ( ! * buffer ) {\n"
                ],
                [
                    11,
                    " if ( * currlen > 0 ) {\n"
                ],
                [
                    12,
                    " assert ( * sbuffer != NULL ) ;\n"
                ],
                [
                    13,
                    " memcpy ( * buffer , * sbuffer , * currlen ) ;\n"
                ],
                [
                    24,
                    " if ( * currlen < * maxlen ) {\n"
                ]
            ]
        }
    },
    {
        "code": "int authreadkeys ( const char * file ) {\n FILE * fp ;\n char * line ;\n char * token ;\n keyid_t keyno ;\n int keytype ;\n char buf [ 512 ] ;\n u_char keystr [ 32 ] ;\n size_t len ;\n size_t j ;\n fp = fopen ( file , \"r\" ) ;\n if ( fp == NULL ) {\n msyslog ( LOG_ERR , \"authreadkeys: file %s: %m\" , file ) ;\n return ( 0 ) ;\n }\n INIT_SSL ( ) ;\n auth_delkeys ( ) ;\n while ( ( line = fgets ( buf , sizeof buf , fp ) ) != NULL ) {\n token = nexttok ( & line ) ;\n if ( token == NULL ) continue ;\n keyno = atoi ( token ) ;\n if ( keyno == 0 ) {\n msyslog ( LOG_ERR , \"authreadkeys: cannot change key %s\" , token ) ;\n continue ;\n }\n if ( keyno > NTP_MAXKEY ) {\n msyslog ( LOG_ERR , \"authreadkeys: key %s > %d reserved for Autokey\" , token , NTP_MAXKEY ) ;\n continue ;\n }\n token = nexttok ( & line ) ;\n if ( token == NULL ) {\n msyslog ( LOG_ERR , \"authreadkeys: no key type for key %d\" , keyno ) ;\n continue ;\n }\n # ifdef OPENSSL keytype = keytype_from_text ( token , NULL ) ;\n if ( keytype == 0 ) {\n msyslog ( LOG_ERR , \"authreadkeys: invalid type for key %d\" , keyno ) ;\n continue ;\n }\n if ( EVP_get_digestbynid ( keytype ) == NULL ) {\n msyslog ( LOG_ERR , \"authreadkeys: no algorithm for key %d\" , keyno ) ;\n continue ;\n }\n # else if ( ! ( * token == 'M' || * token == 'm' ) ) {\n msyslog ( LOG_ERR , \"authreadkeys: invalid type for key %d\" , keyno ) ;\n continue ;\n }\n keytype = KEY_TYPE_MD5 ;\n # endif token = nexttok ( & line ) ;\n if ( token == NULL ) {\n msyslog ( LOG_ERR , \"authreadkeys: no key for key %d\" , keyno ) ;\n continue ;\n }\n len = strlen ( token ) ;\n if ( len <= 20 ) {\n MD5auth_setkey ( keyno , keytype , ( u_char * ) token , len ) ;\n }\n else {\n char hex [ ] = \"0123456789abcdef\" ;\n u_char temp ;\n char * ptr ;\n size_t jlim ;\n jlim = min ( len , 2 * sizeof ( keystr ) ) ;\n for ( j = 0 ;\n j < jlim ;\n j ++ ) {\n ptr = strchr ( hex , tolower ( ( unsigned char ) token [ j ] ) ) ;\n if ( ptr == NULL ) break ;\n temp = ( u_char ) ( ptr - hex ) ;\n if ( j & 1 ) keystr [ j / 2 ] |= temp ;\n else keystr [ j / 2 ] = temp << 4 ;\n }\n if ( j < jlim ) {\n msyslog ( LOG_ERR , \"authreadkeys: invalid hex digit for key %d\" , keyno ) ;\n continue ;\n }\n MD5auth_setkey ( keyno , keytype , keystr , jlim / 2 ) ;\n }\n }\n fclose ( fp ) ;\n return ( 1 ) ;\n }",
        "hash": -4207871914787387485,
        "project": "debian",
        "size": 82,
        "slice": {
            "strchr": [
                [
                    1,
                    "int authreadkeys ( const char * file ) {\n"
                ],
                [
                    59,
                    " char hex [ ] = \"0123456789abcdef\" ;\n"
                ],
                [
                    65,
                    " j < jlim ;\n"
                ],
                [
                    67,
                    " ptr = strchr ( hex , tolower ( ( unsigned char ) token [ j ] ) ) ;\n"
                ],
                [
                    68,
                    " if ( ptr == NULL ) break ;\n"
                ],
                [
                    69,
                    " temp = ( u_char ) ( ptr - hex ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "int authreadkeys ( const char * file ) {\n"
                ],
                [
                    12,
                    " if ( fp == NULL ) {\n"
                ],
                [
                    50,
                    " if ( token == NULL ) {\n"
                ],
                [
                    54,
                    " len = strlen ( token ) ;\n"
                ],
                [
                    55,
                    " if ( len <= 20 ) {\n"
                ],
                [
                    56,
                    " MD5auth_setkey ( keyno , keytype , ( u_char * ) token , len ) ;\n"
                ],
                [
                    67,
                    " ptr = strchr ( hex , tolower ( ( unsigned char ) token [ j ] ) ) ;\n"
                ]
            ],
            "fgets": [
                [
                    1,
                    "int authreadkeys ( const char * file ) {\n"
                ],
                [
                    12,
                    " if ( fp == NULL ) {\n"
                ],
                [
                    18,
                    " while ( ( line = fgets ( buf , sizeof buf , fp ) ) != NULL ) {\n"
                ],
                [
                    19,
                    " token = nexttok ( & line ) ;\n"
                ],
                [
                    20,
                    " if ( token == NULL ) continue ;\n"
                ],
                [
                    30,
                    " token = nexttok ( & line ) ;\n"
                ],
                [
                    31,
                    " if ( token == NULL ) {\n"
                ],
                [
                    50,
                    " if ( token == NULL ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int authreadkeys ( const char * file ) {\n"
                ],
                [
                    12,
                    " if ( fp == NULL ) {\n"
                ],
                [
                    18,
                    " while ( ( line = fgets ( buf , sizeof buf , fp ) ) != NULL ) {\n"
                ],
                [
                    19,
                    " token = nexttok ( & line ) ;\n"
                ],
                [
                    20,
                    " if ( token == NULL ) continue ;\n"
                ],
                [
                    30,
                    " token = nexttok ( & line ) ;\n"
                ],
                [
                    31,
                    " if ( token == NULL ) {\n"
                ],
                [
                    50,
                    " if ( token == NULL ) {\n"
                ],
                [
                    54,
                    " len = strlen ( token ) ;\n"
                ],
                [
                    55,
                    " if ( len <= 20 ) {\n"
                ],
                [
                    56,
                    " MD5auth_setkey ( keyno , keytype , ( u_char * ) token , len ) ;\n"
                ],
                [
                    59,
                    " char hex [ ] = \"0123456789abcdef\" ;\n"
                ],
                [
                    65,
                    " j < jlim ;\n"
                ],
                [
                    67,
                    " ptr = strchr ( hex , tolower ( ( unsigned char ) token [ j ] ) ) ;\n"
                ],
                [
                    68,
                    " if ( ptr == NULL ) break ;\n"
                ],
                [
                    69,
                    " temp = ( u_char ) ( ptr - hex ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int compress_bidder_init ( struct archive_read_filter * self ) {\n struct private_data * state ;\n static const size_t out_block_size = 64 * 1024 ;\n void * out_block ;\n int code ;\n self -> code = ARCHIVE_FILTER_COMPRESS ;\n self -> name = \"compress (.Z)\" ;\n state = ( struct private_data * ) calloc ( sizeof ( * state ) , 1 ) ;\n out_block = malloc ( out_block_size ) ;\n if ( state == NULL || out_block == NULL ) {\n free ( out_block ) ;\n free ( state ) ;\n archive_set_error ( & self -> archive -> archive , ENOMEM , \"Can't allocate data for %s decompression\" , self -> name ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n self -> data = state ;\n state -> out_block_size = out_block_size ;\n state -> out_block = out_block ;\n self -> read = compress_filter_read ;\n self -> skip = NULL ;\n self -> close = compress_filter_close ;\n ( void ) getbits ( self , 8 ) ;\n ( void ) getbits ( self , 8 ) ;\n code = getbits ( self , 8 ) ;\n state -> maxcode_bits = code & 0x1f ;\n state -> maxcode = ( 1 << state -> maxcode_bits ) ;\n state -> use_reset_code = code & 0x80 ;\n state -> free_ent = 256 ;\n state -> stackp = state -> stack ;\n if ( state -> use_reset_code ) state -> free_ent ++ ;\n state -> bits = 9 ;\n state -> section_end_code = ( 1 << state -> bits ) - 1 ;\n state -> oldcode = - 1 ;\n for ( code = 255 ;\n code >= 0 ;\n code -- ) {\n state -> prefix [ code ] = 0 ;\n state -> suffix [ code ] = code ;\n }\n next_code ( self ) ;\n return ( ARCHIVE_OK ) ;\n }",
        "hash": 5498422609764865307,
        "project": "debian",
        "size": 42,
        "slice": {
            "malloc": [
                [
                    1,
                    "static int compress_bidder_init ( struct archive_read_filter * self ) {\n"
                ],
                [
                    3,
                    " static const size_t out_block_size = 64 * 1024 ;\n"
                ],
                [
                    9,
                    " out_block = malloc ( out_block_size ) ;\n"
                ],
                [
                    10,
                    " if ( state == NULL || out_block == NULL ) {\n"
                ],
                [
                    11,
                    " free ( out_block ) ;\n"
                ],
                [
                    17,
                    " state -> out_block_size = out_block_size ;\n"
                ],
                [
                    18,
                    " state -> out_block = out_block ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static int compress_bidder_init ( struct archive_read_filter * self ) {\n"
                ],
                [
                    9,
                    " out_block = malloc ( out_block_size ) ;\n"
                ],
                [
                    10,
                    " if ( state == NULL || out_block == NULL ) {\n"
                ],
                [
                    11,
                    " free ( out_block ) ;\n"
                ],
                [
                    12,
                    " free ( state ) ;\n"
                ]
            ],
            "calloc": [
                [
                    1,
                    "static int compress_bidder_init ( struct archive_read_filter * self ) {\n"
                ],
                [
                    8,
                    " state = ( struct private_data * ) calloc ( sizeof ( * state ) , 1 ) ;\n"
                ],
                [
                    10,
                    " if ( state == NULL || out_block == NULL ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int compress_bidder_init ( struct archive_read_filter * self ) {\n"
                ],
                [
                    3,
                    " static const size_t out_block_size = 64 * 1024 ;\n"
                ],
                [
                    8,
                    " state = ( struct private_data * ) calloc ( sizeof ( * state ) , 1 ) ;\n"
                ],
                [
                    9,
                    " out_block = malloc ( out_block_size ) ;\n"
                ],
                [
                    10,
                    " if ( state == NULL || out_block == NULL ) {\n"
                ],
                [
                    11,
                    " free ( out_block ) ;\n"
                ],
                [
                    12,
                    " free ( state ) ;\n"
                ],
                [
                    17,
                    " state -> out_block_size = out_block_size ;\n"
                ],
                [
                    18,
                    " state -> out_block = out_block ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int diffie_hellman_sha256 ( LIBSSH2_SESSION * session , _libssh2_bn * g , _libssh2_bn * p , int group_order , unsigned char packet_type_init , unsigned char packet_type_reply , unsigned char * midhash , unsigned long midhash_len , kmdhgGPshakex_state_t * exchange_state ) {\n int ret = 0 ;\n int rc ;\n libssh2_sha256_ctx exchange_hash_ctx ;\n if ( exchange_state -> state == libssh2_NB_state_idle ) {\n exchange_state -> e_packet = NULL ;\n exchange_state -> s_packet = NULL ;\n exchange_state -> k_value = NULL ;\n exchange_state -> ctx = _libssh2_bn_ctx_new ( ) ;\n exchange_state -> x = _libssh2_bn_init ( ) ;\n exchange_state -> e = _libssh2_bn_init ( ) ;\n exchange_state -> f = _libssh2_bn_init_from_bin ( ) ;\n exchange_state -> k = _libssh2_bn_init ( ) ;\n memset ( & exchange_state -> req_state , 0 , sizeof ( packet_require_state_t ) ) ;\n _libssh2_bn_rand ( exchange_state -> x , group_order , 0 , - 1 ) ;\n _libssh2_bn_mod_exp ( exchange_state -> e , g , exchange_state -> x , p , exchange_state -> ctx ) ;\n exchange_state -> e_packet_len = _libssh2_bn_bytes ( exchange_state -> e ) + 6 ;\n if ( _libssh2_bn_bits ( exchange_state -> e ) % 8 ) {\n exchange_state -> e_packet_len -- ;\n }\n exchange_state -> e_packet = LIBSSH2_ALLOC ( session , exchange_state -> e_packet_len ) ;\n if ( ! exchange_state -> e_packet ) {\n ret = _libssh2_error ( session , LIBSSH2_ERROR_ALLOC , \"Out of memory error\" ) ;\n goto clean_exit ;\n }\n exchange_state -> e_packet [ 0 ] = packet_type_init ;\n _libssh2_htonu32 ( exchange_state -> e_packet + 1 , exchange_state -> e_packet_len - 5 ) ;\n if ( _libssh2_bn_bits ( exchange_state -> e ) % 8 ) {\n _libssh2_bn_to_bin ( exchange_state -> e , exchange_state -> e_packet + 5 ) ;\n }\n else {\n exchange_state -> e_packet [ 5 ] = 0 ;\n _libssh2_bn_to_bin ( exchange_state -> e , exchange_state -> e_packet + 6 ) ;\n }\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Sending KEX packet %d\" , ( int ) packet_type_init ) ;\n exchange_state -> state = libssh2_NB_state_created ;\n }\n if ( exchange_state -> state == libssh2_NB_state_created ) {\n rc = _libssh2_transport_send ( session , exchange_state -> e_packet , exchange_state -> e_packet_len , NULL , 0 ) ;\n if ( rc == LIBSSH2_ERROR_EAGAIN ) {\n return rc ;\n }\n else if ( rc ) {\n ret = _libssh2_error ( session , rc , \"Unable to send KEX init message\" ) ;\n goto clean_exit ;\n }\n exchange_state -> state = libssh2_NB_state_sent ;\n }\n if ( exchange_state -> state == libssh2_NB_state_sent ) {\n if ( session -> burn_optimistic_kexinit ) {\n int burn_type ;\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Waiting for badly guessed KEX packet (to be ignored)\" ) ;\n burn_type = _libssh2_packet_burn ( session , & exchange_state -> burn_state ) ;\n if ( burn_type == LIBSSH2_ERROR_EAGAIN ) {\n return burn_type ;\n }\n else if ( burn_type <= 0 ) {\n ret = burn_type ;\n goto clean_exit ;\n }\n session -> burn_optimistic_kexinit = 0 ;\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Burnt packet of type: %02x\" , ( unsigned int ) burn_type ) ;\n }\n exchange_state -> state = libssh2_NB_state_sent1 ;\n }\n if ( exchange_state -> state == libssh2_NB_state_sent1 ) {\n rc = _libssh2_packet_require ( session , packet_type_reply , & exchange_state -> s_packet , & exchange_state -> s_packet_len , 0 , NULL , 0 , & exchange_state -> req_state ) ;\n if ( rc == LIBSSH2_ERROR_EAGAIN ) {\n return rc ;\n }\n if ( rc ) {\n ret = _libssh2_error ( session , LIBSSH2_ERROR_TIMEOUT , \"Timed out waiting for KEX reply\" ) ;\n goto clean_exit ;\n }\n exchange_state -> s = exchange_state -> s_packet + 1 ;\n session -> server_hostkey_len = _libssh2_ntohu32 ( exchange_state -> s ) ;\n exchange_state -> s += 4 ;\n if ( session -> server_hostkey ) LIBSSH2_FREE ( session , session -> server_hostkey ) ;\n session -> server_hostkey = LIBSSH2_ALLOC ( session , session -> server_hostkey_len ) ;\n if ( ! session -> server_hostkey ) {\n ret = _libssh2_error ( session , LIBSSH2_ERROR_ALLOC , \"Unable to allocate memory for a copy \" \"of the host key\" ) ;\n goto clean_exit ;\n }\n memcpy ( session -> server_hostkey , exchange_state -> s , session -> server_hostkey_len ) ;\n exchange_state -> s += session -> server_hostkey_len ;\n # if LIBSSH2_MD5 {\n libssh2_md5_ctx fingerprint_ctx ;\n if ( libssh2_md5_init ( & fingerprint_ctx ) ) {\n libssh2_md5_update ( fingerprint_ctx , session -> server_hostkey , session -> server_hostkey_len ) ;\n libssh2_md5_final ( fingerprint_ctx , session -> server_hostkey_md5 ) ;\n session -> server_hostkey_md5_valid = TRUE ;\n }\n else {\n session -> server_hostkey_md5_valid = FALSE ;\n }\n }\n # ifdef LIBSSH2DEBUG {\n char fingerprint [ 50 ] , * fprint = fingerprint ;\n int i ;\n for ( i = 0 ;\n i < 16 ;\n i ++ , fprint += 3 ) {\n snprintf ( fprint , 4 , \"%02x:\" , session -> server_hostkey_md5 [ i ] ) ;\n }\n * ( -- fprint ) = '\\0' ;\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Server's MD5 Fingerprint: %s\" , fingerprint ) ;\n }\n # endif # endif {\n libssh2_sha1_ctx fingerprint_ctx ;\n if ( libssh2_sha1_init ( & fingerprint_ctx ) ) {\n libssh2_sha1_update ( fingerprint_ctx , session -> server_hostkey , session -> server_hostkey_len ) ;\n libssh2_sha1_final ( fingerprint_ctx , session -> server_hostkey_sha1 ) ;\n session -> server_hostkey_sha1_valid = TRUE ;\n }\n else {\n session -> server_hostkey_sha1_valid = FALSE ;\n }\n }\n # ifdef LIBSSH2DEBUG {\n char fingerprint [ 64 ] , * fprint = fingerprint ;\n int i ;\n for ( i = 0 ;\n i < 20 ;\n i ++ , fprint += 3 ) {\n snprintf ( fprint , 4 , \"%02x:\" , session -> server_hostkey_sha1 [ i ] ) ;\n }\n * ( -- fprint ) = '\\0' ;\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Server's SHA1 Fingerprint: %s\" , fingerprint ) ;\n }\n # endif if ( session -> hostkey -> init ( session , session -> server_hostkey , session -> server_hostkey_len , & session -> server_hostkey_abstract ) ) {\n ret = _libssh2_error ( session , LIBSSH2_ERROR_HOSTKEY_INIT , \"Unable to initialize hostkey importer\" ) ;\n goto clean_exit ;\n }\n exchange_state -> f_value_len = _libssh2_ntohu32 ( exchange_state -> s ) ;\n exchange_state -> s += 4 ;\n exchange_state -> f_value = exchange_state -> s ;\n exchange_state -> s += exchange_state -> f_value_len ;\n _libssh2_bn_from_bin ( exchange_state -> f , exchange_state -> f_value_len , exchange_state -> f_value ) ;\n exchange_state -> h_sig_len = _libssh2_ntohu32 ( exchange_state -> s ) ;\n exchange_state -> s += 4 ;\n exchange_state -> h_sig = exchange_state -> s ;\n _libssh2_bn_mod_exp ( exchange_state -> k , exchange_state -> f , exchange_state -> x , p , exchange_state -> ctx ) ;\n exchange_state -> k_value_len = _libssh2_bn_bytes ( exchange_state -> k ) + 5 ;\n if ( _libssh2_bn_bits ( exchange_state -> k ) % 8 ) {\n exchange_state -> k_value_len -- ;\n }\n exchange_state -> k_value = LIBSSH2_ALLOC ( session , exchange_state -> k_value_len ) ;\n if ( ! exchange_state -> k_value ) {\n ret = _libssh2_error ( session , LIBSSH2_ERROR_ALLOC , \"Unable to allocate buffer for K\" ) ;\n goto clean_exit ;\n }\n _libssh2_htonu32 ( exchange_state -> k_value , exchange_state -> k_value_len - 4 ) ;\n if ( _libssh2_bn_bits ( exchange_state -> k ) % 8 ) {\n _libssh2_bn_to_bin ( exchange_state -> k , exchange_state -> k_value + 4 ) ;\n }\n else {\n exchange_state -> k_value [ 4 ] = 0 ;\n _libssh2_bn_to_bin ( exchange_state -> k , exchange_state -> k_value + 5 ) ;\n }\n exchange_state -> exchange_hash = ( void * ) & exchange_hash_ctx ;\n libssh2_sha256_init ( & exchange_hash_ctx ) ;\n if ( session -> local . banner ) {\n _libssh2_htonu32 ( exchange_state -> h_sig_comp , strlen ( ( char * ) session -> local . banner ) - 2 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 4 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , ( char * ) session -> local . banner , strlen ( ( char * ) session -> local . banner ) - 2 ) ;\n }\n else {\n _libssh2_htonu32 ( exchange_state -> h_sig_comp , sizeof ( LIBSSH2_SSH_DEFAULT_BANNER ) - 1 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 4 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , LIBSSH2_SSH_DEFAULT_BANNER , sizeof ( LIBSSH2_SSH_DEFAULT_BANNER ) - 1 ) ;\n }\n _libssh2_htonu32 ( exchange_state -> h_sig_comp , strlen ( ( char * ) session -> remote . banner ) ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 4 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , session -> remote . banner , strlen ( ( char * ) session -> remote . banner ) ) ;\n _libssh2_htonu32 ( exchange_state -> h_sig_comp , session -> local . kexinit_len ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 4 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , session -> local . kexinit , session -> local . kexinit_len ) ;\n _libssh2_htonu32 ( exchange_state -> h_sig_comp , session -> remote . kexinit_len ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 4 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , session -> remote . kexinit , session -> remote . kexinit_len ) ;\n _libssh2_htonu32 ( exchange_state -> h_sig_comp , session -> server_hostkey_len ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 4 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , session -> server_hostkey , session -> server_hostkey_len ) ;\n if ( packet_type_init == SSH_MSG_KEX_DH_GEX_INIT ) {\n # ifdef LIBSSH2_DH_GEX_NEW _libssh2_htonu32 ( exchange_state -> h_sig_comp , LIBSSH2_DH_GEX_MINGROUP ) ;\n _libssh2_htonu32 ( exchange_state -> h_sig_comp + 4 , LIBSSH2_DH_GEX_OPTGROUP ) ;\n _libssh2_htonu32 ( exchange_state -> h_sig_comp + 8 , LIBSSH2_DH_GEX_MAXGROUP ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 12 ) ;\n # else _libssh2_htonu32 ( exchange_state -> h_sig_comp , LIBSSH2_DH_GEX_OPTGROUP ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 4 ) ;\n # endif }\n if ( midhash ) {\n libssh2_sha256_update ( exchange_hash_ctx , midhash , midhash_len ) ;\n }\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> e_packet + 1 , exchange_state -> e_packet_len - 1 ) ;\n _libssh2_htonu32 ( exchange_state -> h_sig_comp , exchange_state -> f_value_len ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> h_sig_comp , 4 ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> f_value , exchange_state -> f_value_len ) ;\n libssh2_sha256_update ( exchange_hash_ctx , exchange_state -> k_value , exchange_state -> k_value_len ) ;\n libssh2_sha256_final ( exchange_hash_ctx , exchange_state -> h_sig_comp ) ;\n if ( session -> hostkey -> sig_verify ( session , exchange_state -> h_sig , exchange_state -> h_sig_len , exchange_state -> h_sig_comp , SHA256_DIGEST_LENGTH , & session -> server_hostkey_abstract ) ) {\n ret = _libssh2_error ( session , LIBSSH2_ERROR_HOSTKEY_SIGN , \"Unable to verify hostkey signature\" ) ;\n goto clean_exit ;\n }\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Sending NEWKEYS message\" ) ;\n exchange_state -> c = SSH_MSG_NEWKEYS ;\n exchange_state -> state = libssh2_NB_state_sent2 ;\n }\n if ( exchange_state -> state == libssh2_NB_state_sent2 ) {\n rc = _libssh2_transport_send ( session , & exchange_state -> c , 1 , NULL , 0 ) ;\n if ( rc == LIBSSH2_ERROR_EAGAIN ) {\n return rc ;\n }\n else if ( rc ) {\n ret = _libssh2_error ( session , rc , \"Unable to send NEWKEYS message\" ) ;\n goto clean_exit ;\n }\n exchange_state -> state = libssh2_NB_state_sent3 ;\n }\n if ( exchange_state -> state == libssh2_NB_state_sent3 ) {\n rc = _libssh2_packet_require ( session , SSH_MSG_NEWKEYS , & exchange_state -> tmp , & exchange_state -> tmp_len , 0 , NULL , 0 , & exchange_state -> req_state ) ;\n if ( rc == LIBSSH2_ERROR_EAGAIN ) {\n return rc ;\n }\n else if ( rc ) {\n ret = _libssh2_error ( session , rc , \"Timed out waiting for NEWKEYS\" ) ;\n goto clean_exit ;\n }\n session -> state |= LIBSSH2_STATE_NEWKEYS ;\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Received NEWKEYS message\" ) ;\n LIBSSH2_FREE ( session , exchange_state -> tmp ) ;\n if ( ! session -> session_id ) {\n session -> session_id = LIBSSH2_ALLOC ( session , SHA256_DIGEST_LENGTH ) ;\n if ( ! session -> session_id ) {\n ret = _libssh2_error ( session , LIBSSH2_ERROR_ALLOC , \"Unable to allocate buffer for SHA digest\" ) ;\n goto clean_exit ;\n }\n memcpy ( session -> session_id , exchange_state -> h_sig_comp , SHA256_DIGEST_LENGTH ) ;\n session -> session_id_len = SHA256_DIGEST_LENGTH ;\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"session_id calculated\" ) ;\n }\n if ( session -> local . crypt -> dtor ) {\n session -> local . crypt -> dtor ( session , & session -> local . crypt_abstract ) ;\n }\n if ( session -> local . crypt -> init ) {\n unsigned char * iv = NULL , * secret = NULL ;\n int free_iv = 0 , free_secret = 0 ;\n LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH ( iv , session -> local . crypt -> iv_len , \"A\" ) ;\n if ( ! iv ) {\n ret = - 1 ;\n goto clean_exit ;\n }\n LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH ( secret , session -> local . crypt -> secret_len , \"C\" ) ;\n if ( ! secret ) {\n LIBSSH2_FREE ( session , iv ) ;\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n if ( session -> local . crypt -> init ( session , session -> local . crypt , iv , & free_iv , secret , & free_secret , 1 , & session -> local . crypt_abstract ) ) {\n LIBSSH2_FREE ( session , iv ) ;\n LIBSSH2_FREE ( session , secret ) ;\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n if ( free_iv ) {\n memset ( iv , 0 , session -> local . crypt -> iv_len ) ;\n LIBSSH2_FREE ( session , iv ) ;\n }\n if ( free_secret ) {\n memset ( secret , 0 , session -> local . crypt -> secret_len ) ;\n LIBSSH2_FREE ( session , secret ) ;\n }\n }\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Client to Server IV and Key calculated\" ) ;\n if ( session -> remote . crypt -> dtor ) {\n session -> remote . crypt -> dtor ( session , & session -> remote . crypt_abstract ) ;\n }\n if ( session -> remote . crypt -> init ) {\n unsigned char * iv = NULL , * secret = NULL ;\n int free_iv = 0 , free_secret = 0 ;\n LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH ( iv , session -> remote . crypt -> iv_len , \"B\" ) ;\n if ( ! iv ) {\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH ( secret , session -> remote . crypt -> secret_len , \"D\" ) ;\n if ( ! secret ) {\n LIBSSH2_FREE ( session , iv ) ;\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n if ( session -> remote . crypt -> init ( session , session -> remote . crypt , iv , & free_iv , secret , & free_secret , 0 , & session -> remote . crypt_abstract ) ) {\n LIBSSH2_FREE ( session , iv ) ;\n LIBSSH2_FREE ( session , secret ) ;\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n if ( free_iv ) {\n memset ( iv , 0 , session -> remote . crypt -> iv_len ) ;\n LIBSSH2_FREE ( session , iv ) ;\n }\n if ( free_secret ) {\n memset ( secret , 0 , session -> remote . crypt -> secret_len ) ;\n LIBSSH2_FREE ( session , secret ) ;\n }\n }\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Server to Client IV and Key calculated\" ) ;\n if ( session -> local . mac -> dtor ) {\n session -> local . mac -> dtor ( session , & session -> local . mac_abstract ) ;\n }\n if ( session -> local . mac -> init ) {\n unsigned char * key = NULL ;\n int free_key = 0 ;\n LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH ( key , session -> local . mac -> key_len , \"E\" ) ;\n if ( ! key ) {\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n session -> local . mac -> init ( session , key , & free_key , & session -> local . mac_abstract ) ;\n if ( free_key ) {\n memset ( key , 0 , session -> local . mac -> key_len ) ;\n LIBSSH2_FREE ( session , key ) ;\n }\n }\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Client to Server HMAC Key calculated\" ) ;\n if ( session -> remote . mac -> dtor ) {\n session -> remote . mac -> dtor ( session , & session -> remote . mac_abstract ) ;\n }\n if ( session -> remote . mac -> init ) {\n unsigned char * key = NULL ;\n int free_key = 0 ;\n LIBSSH2_KEX_METHOD_DIFFIE_HELLMAN_SHA256_HASH ( key , session -> remote . mac -> key_len , \"F\" ) ;\n if ( ! key ) {\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n session -> remote . mac -> init ( session , key , & free_key , & session -> remote . mac_abstract ) ;\n if ( free_key ) {\n memset ( key , 0 , session -> remote . mac -> key_len ) ;\n LIBSSH2_FREE ( session , key ) ;\n }\n }\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Server to Client HMAC Key calculated\" ) ;\n if ( session -> local . comp && session -> local . comp -> dtor ) {\n session -> local . comp -> dtor ( session , 1 , & session -> local . comp_abstract ) ;\n }\n if ( session -> local . comp && session -> local . comp -> init ) {\n if ( session -> local . comp -> init ( session , 1 , & session -> local . comp_abstract ) ) {\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n }\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Client to Server compression initialized\" ) ;\n if ( session -> remote . comp && session -> remote . comp -> dtor ) {\n session -> remote . comp -> dtor ( session , 0 , & session -> remote . comp_abstract ) ;\n }\n if ( session -> remote . comp && session -> remote . comp -> init ) {\n if ( session -> remote . comp -> init ( session , 0 , & session -> remote . comp_abstract ) ) {\n ret = LIBSSH2_ERROR_KEX_FAILURE ;\n goto clean_exit ;\n }\n }\n _libssh2_debug ( session , LIBSSH2_TRACE_KEX , \"Server to Client compression initialized\" ) ;\n }\n clean_exit : _libssh2_bn_free ( exchange_state -> x ) ;\n exchange_state -> x = NULL ;\n _libssh2_bn_free ( exchange_state -> e ) ;\n exchange_state -> e = NULL ;\n _libssh2_bn_free ( exchange_state -> f ) ;\n exchange_state -> f = NULL ;\n _libssh2_bn_free ( exchange_state -> k ) ;\n exchange_state -> k = NULL ;\n _libssh2_bn_ctx_free ( exchange_state -> ctx ) ;\n exchange_state -> ctx = NULL ;\n if ( exchange_state -> e_packet ) {\n LIBSSH2_FREE ( session , exchange_state -> e_packet ) ;\n exchange_state -> e_packet = NULL ;\n }\n if ( exchange_state -> s_packet ) {\n LIBSSH2_FREE ( session , exchange_state -> s_packet ) ;\n exchange_state -> s_packet = NULL ;\n }\n if ( exchange_state -> k_value ) {\n LIBSSH2_FREE ( session , exchange_state -> k_value ) ;\n exchange_state -> k_value = NULL ;\n }\n exchange_state -> state = libssh2_NB_state_idle ;\n return ret ;\n }",
        "hash": 1202634027547122397,
        "project": "debian",
        "size": 389,
        "slice": {
            "memset": [
                [
                    1,
                    "static int diffie_hellman_sha256 ( LIBSSH2_SESSION * session , _libssh2_bn * g , _libssh2_bn * p , int group_order , unsigned char packet_type_init , unsigned char packet_type_reply , unsigned char * midhash , unsigned long midhash_len , kmdhgGPshakex_state_t * exchange_state ) {\n"
                ],
                [
                    5,
                    " if ( exchange_state -> state == libssh2_NB_state_idle ) {\n"
                ],
                [
                    14,
                    " memset ( & exchange_state -> req_state , 0 , sizeof ( packet_require_state_t ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int diffie_hellman_sha256 ( LIBSSH2_SESSION * session , _libssh2_bn * g , _libssh2_bn * p , int group_order , unsigned char packet_type_init , unsigned char packet_type_reply , unsigned char * midhash , unsigned long midhash_len , kmdhgGPshakex_state_t * exchange_state ) {\n"
                ],
                [
                    5,
                    " if ( exchange_state -> state == libssh2_NB_state_idle ) {\n"
                ],
                [
                    14,
                    " memset ( & exchange_state -> req_state , 0 , sizeof ( packet_require_state_t ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n GstTagList * taglist ;\n guint16 blockcount , i ;\n gboolean content3D = FALSE ;\n struct {\n const gchar * interleave_name ;\n GstASF3DMode interleaving_type ;\n }\n stereoscopic_layout_map [ ] = {\n {\n \"SideBySideRF\" , GST_ASF_3D_SIDE_BY_SIDE_HALF_RL }\n , {\n \"SideBySideLF\" , GST_ASF_3D_SIDE_BY_SIDE_HALF_LR }\n , {\n \"OverUnderRT\" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL }\n , {\n \"OverUnderLT\" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR }\n , {\n \"DualStream\" , GST_ASF_3D_DUAL_STREAM }\n }\n ;\n GST_INFO_OBJECT ( demux , \"object is an extended content description\" ) ;\n taglist = gst_tag_list_new_empty ( ) ;\n if ( size < 2 ) goto not_enough_data ;\n blockcount = gst_asf_demux_get_uint16 ( & data , & size ) ;\n for ( i = 1 ;\n i <= blockcount ;\n ++ i ) {\n const gchar * gst_tag_name ;\n guint16 datatype ;\n guint16 value_len ;\n guint16 name_len ;\n GValue tag_value = {\n 0 , }\n ;\n gsize in , out ;\n gchar * name ;\n gchar * name_utf8 = NULL ;\n gchar * value ;\n if ( ! gst_asf_demux_get_string ( & name , & name_len , & data , & size ) ) goto not_enough_data ;\n if ( size < 2 ) {\n g_free ( name ) ;\n goto not_enough_data ;\n }\n datatype = gst_asf_demux_get_uint16 ( & data , & size ) ;\n if ( ! gst_asf_demux_get_string ( & value , & value_len , & data , & size ) ) {\n g_free ( name ) ;\n goto not_enough_data ;\n }\n name_utf8 = g_convert ( name , name_len , \"UTF-8\" , \"UTF-16LE\" , & in , & out , NULL ) ;\n if ( name_utf8 != NULL ) {\n GST_DEBUG ( \"Found tag/metadata %s\" , name_utf8 ) ;\n gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ;\n GST_DEBUG ( \"gst_tag_name %s\" , GST_STR_NULL ( gst_tag_name ) ) ;\n switch ( datatype ) {\n case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING : {\n gchar * value_utf8 ;\n value_utf8 = g_convert ( value , value_len , \"UTF-8\" , \"UTF-16LE\" , & in , & out , NULL ) ;\n if ( value_utf8 != NULL && * value_utf8 != '\\0' ) {\n GST_DEBUG ( \"string value %s\" , value_utf8 ) ;\n value_utf8 [ out ] = '\\0' ;\n if ( gst_tag_name != NULL ) {\n if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) {\n guint year = atoi ( value_utf8 ) ;\n if ( year > 0 ) {\n g_value_init ( & tag_value , GST_TYPE_DATE_TIME ) ;\n g_value_take_boxed ( & tag_value , gst_date_time_new_y ( year ) ) ;\n }\n }\n else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) {\n guint id3v1_genre_id ;\n const gchar * genre_str ;\n if ( sscanf ( value_utf8 , \"(%u)\" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) {\n GST_DEBUG ( \"Genre: %s -> %s\" , value_utf8 , genre_str ) ;\n g_free ( value_utf8 ) ;\n value_utf8 = g_strdup ( genre_str ) ;\n }\n }\n else {\n GType tag_type ;\n tag_type = gst_tag_get_type ( gst_tag_name ) ;\n g_value_init ( & tag_value , tag_type ) ;\n if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) {\n GValue from_val = {\n 0 , }\n ;\n g_value_init ( & from_val , G_TYPE_STRING ) ;\n g_value_set_string ( & from_val , value_utf8 ) ;\n if ( ! g_value_transform ( & from_val , & tag_value ) ) {\n GST_WARNING_OBJECT ( demux , \"Could not transform string tag to \" \"%s tag type %s\" , gst_tag_name , g_type_name ( tag_type ) ) ;\n g_value_unset ( & tag_value ) ;\n }\n g_value_unset ( & from_val ) ;\n }\n }\n }\n else {\n GST_DEBUG ( \"Setting metadata\" ) ;\n g_value_init ( & tag_value , G_TYPE_STRING ) ;\n g_value_set_string ( & tag_value , value_utf8 ) ;\n if ( content3D ) {\n guint i ;\n if ( strncmp ( \"StereoscopicLayout\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n for ( i = 0 ;\n i < G_N_ELEMENTS ( stereoscopic_layout_map ) ;\n i ++ ) {\n if ( g_str_equal ( stereoscopic_layout_map [ i ] . interleave_name , value_utf8 ) ) {\n demux -> asf_3D_mode = stereoscopic_layout_map [ i ] . interleaving_type ;\n GST_INFO ( \"find interleave type %u\" , demux -> asf_3D_mode ) ;\n }\n }\n }\n GST_INFO_OBJECT ( demux , \"3d type is %u\" , demux -> asf_3D_mode ) ;\n }\n else {\n demux -> asf_3D_mode = GST_ASF_3D_NONE ;\n GST_INFO_OBJECT ( demux , \"None 3d type\" ) ;\n }\n }\n }\n else if ( value_utf8 == NULL ) {\n GST_WARNING ( \"Failed to convert string value to UTF8, skipping\" ) ;\n }\n else {\n GST_DEBUG ( \"Skipping empty string value for %s\" , GST_STR_NULL ( gst_tag_name ) ) ;\n }\n g_free ( value_utf8 ) ;\n break ;\n }\n case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY : {\n if ( gst_tag_name ) {\n if ( ! g_str_equal ( gst_tag_name , GST_TAG_IMAGE ) ) {\n GST_FIXME ( \"Unhandled byte array tag %s\" , GST_STR_NULL ( gst_tag_name ) ) ;\n break ;\n }\n else {\n asf_demux_parse_picture_tag ( taglist , ( guint8 * ) value , value_len ) ;\n }\n }\n break ;\n }\n case ASF_DEMUX_DATA_TYPE_DWORD : {\n guint uint_val = GST_READ_UINT32_LE ( value ) ;\n g_value_init ( & tag_value , G_TYPE_UINT ) ;\n if ( ! strcmp ( name_utf8 , \"WM/Track\" ) ) ++ uint_val ;\n g_value_set_uint ( & tag_value , uint_val ) ;\n break ;\n }\n case ASF_DEMUX_DATA_TYPE_BOOL : {\n gboolean bool_val = GST_READ_UINT32_LE ( value ) ;\n if ( strncmp ( \"Stereoscopic\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n if ( bool_val ) {\n GST_INFO_OBJECT ( demux , \"This is 3D contents\" ) ;\n content3D = TRUE ;\n }\n else {\n GST_INFO_OBJECT ( demux , \"This is not 3D contenst\" ) ;\n content3D = FALSE ;\n }\n }\n break ;\n }\n default : {\n GST_DEBUG ( \"Skipping tag %s of type %d\" , gst_tag_name , datatype ) ;\n break ;\n }\n }\n if ( G_IS_VALUE ( & tag_value ) ) {\n if ( gst_tag_name ) {\n GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND ;\n if ( strcmp ( name_utf8 , \"WM/TrackNumber\" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ;\n gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ;\n }\n else {\n GST_DEBUG ( \"Setting global metadata %s\" , name_utf8 ) ;\n gst_structure_set_value ( demux -> global_metadata , name_utf8 , & tag_value ) ;\n }\n g_value_unset ( & tag_value ) ;\n }\n }\n g_free ( name ) ;\n g_free ( value ) ;\n g_free ( name_utf8 ) ;\n }\n gst_asf_demux_add_global_tags ( demux , taglist ) ;\n return GST_FLOW_OK ;\n not_enough_data : {\n GST_WARNING ( \"Unexpected end of data parsing ext content desc object\" ) ;\n gst_tag_list_unref ( taglist ) ;\n return GST_FLOW_OK ;\n }\n }",
        "hash": -5280794106681745199,
        "project": "debian",
        "size": 192,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n"
                ],
                [
                    53,
                    " gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ;\n"
                ],
                [
                    55,
                    " switch ( datatype ) {\n"
                ],
                [
                    62,
                    " if ( gst_tag_name != NULL ) {\n"
                ],
                [
                    63,
                    " if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) {\n"
                ],
                [
                    64,
                    " guint year = atoi ( value_utf8 ) ;\n"
                ],
                [
                    65,
                    " if ( year > 0 ) {\n"
                ],
                [
                    70,
                    " else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) {\n"
                ],
                [
                    73,
                    " if ( sscanf ( value_utf8 , \"(%u)\" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) {\n"
                ],
                [
                    81,
                    " tag_type = gst_tag_get_type ( gst_tag_name ) ;\n"
                ],
                [
                    82,
                    " g_value_init ( & tag_value , tag_type ) ;\n"
                ],
                [
                    83,
                    " if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) {\n"
                ],
                [
                    103,
                    " if ( strncmp ( \"StereoscopicLayout\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n"
                ],
                [
                    145,
                    " if ( ! strcmp ( name_utf8 , \"WM/Track\" ) ) ++ uint_val ;\n"
                ],
                [
                    151,
                    " if ( strncmp ( \"Stereoscopic\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n"
                ],
                [
                    169,
                    " if ( gst_tag_name ) {\n"
                ],
                [
                    171,
                    " if ( strcmp ( name_utf8 , \"WM/TrackNumber\" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ;\n"
                ],
                [
                    172,
                    " gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ;\n"
                ],
                [
                    175,
                    " GST_DEBUG ( \"Setting global metadata %s\" , name_utf8 ) ;\n"
                ],
                [
                    183,
                    " g_free ( name_utf8 ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n"
                ],
                [
                    53,
                    " gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ;\n"
                ],
                [
                    55,
                    " switch ( datatype ) {\n"
                ],
                [
                    101,
                    " if ( content3D ) {\n"
                ],
                [
                    103,
                    " if ( strncmp ( \"StereoscopicLayout\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n"
                ],
                [
                    151,
                    " if ( strncmp ( \"Stereoscopic\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n"
                ],
                [
                    152,
                    " if ( bool_val ) {\n"
                ],
                [
                    171,
                    " if ( strcmp ( name_utf8 , \"WM/TrackNumber\" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ;\n"
                ],
                [
                    175,
                    " GST_DEBUG ( \"Setting global metadata %s\" , name_utf8 ) ;\n"
                ],
                [
                    183,
                    " g_free ( name_utf8 ) ;\n"
                ]
            ],
            "sscanf": [
                [
                    1,
                    "static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n"
                ],
                [
                    59,
                    " if ( value_utf8 != NULL && * value_utf8 != '\\0' ) {\n"
                ],
                [
                    60,
                    " GST_DEBUG ( \"string value %s\" , value_utf8 ) ;\n"
                ],
                [
                    61,
                    " value_utf8 [ out ] = '\\0' ;\n"
                ],
                [
                    70,
                    " else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) {\n"
                ],
                [
                    73,
                    " if ( sscanf ( value_utf8 , \"(%u)\" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) {\n"
                ],
                [
                    74,
                    " GST_DEBUG ( \"Genre: %s -> %s\" , value_utf8 , genre_str ) ;\n"
                ],
                [
                    75,
                    " g_free ( value_utf8 ) ;\n"
                ],
                [
                    76,
                    " value_utf8 = g_strdup ( genre_str ) ;\n"
                ],
                [
                    127,
                    " g_free ( value_utf8 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n"
                ],
                [
                    53,
                    " gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ;\n"
                ],
                [
                    55,
                    " switch ( datatype ) {\n"
                ],
                [
                    59,
                    " if ( value_utf8 != NULL && * value_utf8 != '\\0' ) {\n"
                ],
                [
                    60,
                    " GST_DEBUG ( \"string value %s\" , value_utf8 ) ;\n"
                ],
                [
                    61,
                    " value_utf8 [ out ] = '\\0' ;\n"
                ],
                [
                    62,
                    " if ( gst_tag_name != NULL ) {\n"
                ],
                [
                    63,
                    " if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) {\n"
                ],
                [
                    64,
                    " guint year = atoi ( value_utf8 ) ;\n"
                ],
                [
                    65,
                    " if ( year > 0 ) {\n"
                ],
                [
                    70,
                    " else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) {\n"
                ],
                [
                    73,
                    " if ( sscanf ( value_utf8 , \"(%u)\" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) {\n"
                ],
                [
                    74,
                    " GST_DEBUG ( \"Genre: %s -> %s\" , value_utf8 , genre_str ) ;\n"
                ],
                [
                    75,
                    " g_free ( value_utf8 ) ;\n"
                ],
                [
                    76,
                    " value_utf8 = g_strdup ( genre_str ) ;\n"
                ],
                [
                    81,
                    " tag_type = gst_tag_get_type ( gst_tag_name ) ;\n"
                ],
                [
                    82,
                    " g_value_init ( & tag_value , tag_type ) ;\n"
                ],
                [
                    83,
                    " if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) {\n"
                ],
                [
                    101,
                    " if ( content3D ) {\n"
                ],
                [
                    103,
                    " if ( strncmp ( \"StereoscopicLayout\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n"
                ],
                [
                    127,
                    " g_free ( value_utf8 ) ;\n"
                ],
                [
                    145,
                    " if ( ! strcmp ( name_utf8 , \"WM/Track\" ) ) ++ uint_val ;\n"
                ],
                [
                    151,
                    " if ( strncmp ( \"Stereoscopic\" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n"
                ],
                [
                    152,
                    " if ( bool_val ) {\n"
                ],
                [
                    169,
                    " if ( gst_tag_name ) {\n"
                ],
                [
                    171,
                    " if ( strcmp ( name_utf8 , \"WM/TrackNumber\" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ;\n"
                ],
                [
                    172,
                    " gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ;\n"
                ],
                [
                    175,
                    " GST_DEBUG ( \"Setting global metadata %s\" , name_utf8 ) ;\n"
                ],
                [
                    183,
                    " g_free ( name_utf8 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "CURLcode Curl_http ( struct connectdata * conn , bool * done ) {\n struct Curl_easy * data = conn -> data ;\n CURLcode result = CURLE_OK ;\n struct HTTP * http ;\n const char * ppath = data -> state . path ;\n bool paste_ftp_userpwd = FALSE ;\n char ftp_typecode [ sizeof ( \"/;\ntype=?\" ) ] = \"\" ;\n const char * host = conn -> host . name ;\n const char * te = \"\" ;\n const char * ptr ;\n const char * request ;\n Curl_HttpReq httpreq = data -> set . httpreq ;\n # if ! defined ( CURL_DISABLE_COOKIES ) char * addcookies = NULL ;\n # endif curl_off_t included_body = 0 ;\n const char * httpstring ;\n Curl_send_buffer * req_buffer ;\n curl_off_t postsize = 0 ;\n int seekerr = CURL_SEEKFUNC_OK ;\n * done = TRUE ;\n if ( conn -> httpversion < 20 ) {\n switch ( conn -> negnpn ) {\n case CURL_HTTP_VERSION_2 : conn -> httpversion = 20 ;\n result = Curl_http2_switched ( conn , NULL , 0 ) ;\n if ( result ) return result ;\n break ;\n case CURL_HTTP_VERSION_1_1 : break ;\n default : # ifdef USE_NGHTTP2 if ( conn -> data -> set . httpversion == CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE ) {\n DEBUGF ( infof ( data , \"HTTP/2 over clean TCP\\n\" ) ) ;\n conn -> httpversion = 20 ;\n result = Curl_http2_switched ( conn , NULL , 0 ) ;\n if ( result ) return result ;\n }\n # endif break ;\n }\n }\n else {\n result = Curl_http2_setup ( conn ) ;\n if ( result ) return result ;\n }\n http = data -> req . protop ;\n if ( ! data -> state . this_is_a_follow ) {\n free ( data -> state . first_host ) ;\n data -> state . first_host = strdup ( conn -> host . name ) ;\n if ( ! data -> state . first_host ) return CURLE_OUT_OF_MEMORY ;\n data -> state . first_remote_port = conn -> remote_port ;\n }\n http -> writebytecount = http -> readbytecount = 0 ;\n if ( ( conn -> handler -> protocol & ( PROTO_FAMILY_HTTP | CURLPROTO_FTP ) ) && data -> set . upload ) {\n httpreq = HTTPREQ_PUT ;\n }\n if ( data -> set . str [ STRING_CUSTOMREQUEST ] ) request = data -> set . str [ STRING_CUSTOMREQUEST ] ;\n else {\n if ( data -> set . opt_no_body ) request = \"HEAD\" ;\n else {\n DEBUGASSERT ( ( httpreq > HTTPREQ_NONE ) && ( httpreq < HTTPREQ_LAST ) ) ;\n switch ( httpreq ) {\n case HTTPREQ_POST : case HTTPREQ_POST_FORM : request = \"POST\" ;\n break ;\n case HTTPREQ_PUT : request = \"PUT\" ;\n break ;\n default : case HTTPREQ_GET : request = \"GET\" ;\n break ;\n case HTTPREQ_HEAD : request = \"HEAD\" ;\n break ;\n }\n }\n }\n if ( Curl_checkheaders ( conn , \"User-Agent:\" ) ) {\n free ( conn -> allocptr . uagent ) ;\n conn -> allocptr . uagent = NULL ;\n }\n result = Curl_http_output_auth ( conn , request , ppath , FALSE ) ;\n if ( result ) return result ;\n if ( ( data -> state . authhost . multi || data -> state . authproxy . multi ) && ( httpreq != HTTPREQ_GET ) && ( httpreq != HTTPREQ_HEAD ) ) {\n conn -> bits . authneg = TRUE ;\n }\n else conn -> bits . authneg = FALSE ;\n Curl_safefree ( conn -> allocptr . ref ) ;\n if ( data -> change . referer && ! Curl_checkheaders ( conn , \"Referer:\" ) ) {\n conn -> allocptr . ref = aprintf ( \"Referer: %s\\r\\n\" , data -> change . referer ) ;\n if ( ! conn -> allocptr . ref ) return CURLE_OUT_OF_MEMORY ;\n }\n else conn -> allocptr . ref = NULL ;\n # if ! defined ( CURL_DISABLE_COOKIES ) if ( data -> set . str [ STRING_COOKIE ] && ! Curl_checkheaders ( conn , \"Cookie:\" ) ) addcookies = data -> set . str [ STRING_COOKIE ] ;\n # endif if ( ! Curl_checkheaders ( conn , \"Accept-Encoding:\" ) && data -> set . str [ STRING_ENCODING ] ) {\n Curl_safefree ( conn -> allocptr . accept_encoding ) ;\n conn -> allocptr . accept_encoding = aprintf ( \"Accept-Encoding: %s\\r\\n\" , data -> set . str [ STRING_ENCODING ] ) ;\n if ( ! conn -> allocptr . accept_encoding ) return CURLE_OUT_OF_MEMORY ;\n }\n else {\n Curl_safefree ( conn -> allocptr . accept_encoding ) ;\n conn -> allocptr . accept_encoding = NULL ;\n }\n # ifdef HAVE_LIBZ if ( ! Curl_checkheaders ( conn , \"TE:\" ) && data -> set . http_transfer_encoding ) {\n char * cptr = Curl_checkheaders ( conn , \"Connection:\" ) ;\n # define TE_HEADER \"TE: gzip\\r\\n\" Curl_safefree ( conn -> allocptr . te ) ;\n conn -> allocptr . te = cptr ? aprintf ( \"%s, TE\\r\\n\" TE_HEADER , cptr ) : strdup ( \"Connection: TE\\r\\n\" TE_HEADER ) ;\n if ( ! conn -> allocptr . te ) return CURLE_OUT_OF_MEMORY ;\n }\n # endif ptr = Curl_checkheaders ( conn , \"Transfer-Encoding:\" ) ;\n if ( ptr ) {\n data -> req . upload_chunky = Curl_compareheader ( ptr , \"Transfer-Encoding:\" , \"chunked\" ) ;\n }\n else {\n if ( ( conn -> handler -> protocol & PROTO_FAMILY_HTTP ) && data -> set . upload && ( data -> state . infilesize == - 1 ) ) {\n if ( conn -> bits . authneg ) ;\n else if ( use_http_1_1plus ( data , conn ) ) {\n data -> req . upload_chunky = TRUE ;\n }\n else {\n failf ( data , \"Chunky upload is not supported by HTTP 1.0\" ) ;\n return CURLE_UPLOAD_FAILED ;\n }\n }\n else {\n data -> req . upload_chunky = FALSE ;\n }\n if ( data -> req . upload_chunky ) te = \"Transfer-Encoding: chunked\\r\\n\" ;\n }\n Curl_safefree ( conn -> allocptr . host ) ;\n ptr = Curl_checkheaders ( conn , \"Host:\" ) ;\n if ( ptr && ( ! data -> state . this_is_a_follow || Curl_raw_equal ( data -> state . first_host , conn -> host . name ) ) ) {\n # if ! defined ( CURL_DISABLE_COOKIES ) char * cookiehost = Curl_copy_header_value ( ptr ) ;\n if ( ! cookiehost ) return CURLE_OUT_OF_MEMORY ;\n if ( ! * cookiehost ) free ( cookiehost ) ;\n else {\n int startsearch = 0 ;\n if ( * cookiehost == '[' ) {\n char * closingbracket ;\n memmove ( cookiehost , cookiehost + 1 , strlen ( cookiehost ) - 1 ) ;\n closingbracket = strchr ( cookiehost , ']' ) ;\n if ( closingbracket ) * closingbracket = 0 ;\n }\n else {\n char * colon = strchr ( cookiehost + startsearch , ':' ) ;\n if ( colon ) * colon = 0 ;\n }\n Curl_safefree ( conn -> allocptr . cookiehost ) ;\n conn -> allocptr . cookiehost = cookiehost ;\n }\n # endif if ( strcmp ( \"Host:\" , ptr ) ) {\n conn -> allocptr . host = aprintf ( \"%s\\r\\n\" , ptr ) ;\n if ( ! conn -> allocptr . host ) return CURLE_OUT_OF_MEMORY ;\n }\n else conn -> allocptr . host = NULL ;\n }\n else {\n if ( ( ( conn -> given -> protocol & CURLPROTO_HTTPS ) && ( conn -> remote_port == PORT_HTTPS ) ) || ( ( conn -> given -> protocol & CURLPROTO_HTTP ) && ( conn -> remote_port == PORT_HTTP ) ) ) conn -> allocptr . host = aprintf ( \"Host: %s%s%s\\r\\n\" , conn -> bits . ipv6_ip ? \"[\" : \"\" , host , conn -> bits . ipv6_ip ? \"]\" : \"\" ) ;\n else conn -> allocptr . host = aprintf ( \"Host: %s%s%s:%hu\\r\\n\" , conn -> bits . ipv6_ip ? \"[\" : \"\" , host , conn -> bits . ipv6_ip ? \"]\" : \"\" , conn -> remote_port ) ;\n if ( ! conn -> allocptr . host ) return CURLE_OUT_OF_MEMORY ;\n }\n # ifndef CURL_DISABLE_PROXY if ( conn -> bits . httpproxy && ! conn -> bits . tunnel_proxy ) {\n if ( conn -> host . dispname != conn -> host . name ) {\n char * url = data -> change . url ;\n ptr = strstr ( url , conn -> host . dispname ) ;\n if ( ptr ) {\n size_t currlen = strlen ( conn -> host . dispname ) ;\n size_t newlen = strlen ( conn -> host . name ) ;\n size_t urllen = strlen ( url ) ;\n char * newurl ;\n newurl = malloc ( urllen + newlen - currlen + 1 ) ;\n if ( newurl ) {\n memcpy ( newurl , url , ptr - url ) ;\n memcpy ( newurl + ( ptr - url ) , conn -> host . name , newlen ) ;\n memcpy ( newurl + newlen + ( ptr - url ) , ptr + currlen , urllen - ( ptr - url ) - currlen + 1 ) ;\n if ( data -> change . url_alloc ) {\n Curl_safefree ( data -> change . url ) ;\n data -> change . url_alloc = FALSE ;\n }\n data -> change . url = newurl ;\n data -> change . url_alloc = TRUE ;\n }\n else return CURLE_OUT_OF_MEMORY ;\n }\n }\n ppath = data -> change . url ;\n if ( checkprefix ( \"ftp://\" , ppath ) ) {\n if ( data -> set . proxy_transfer_mode ) {\n char * type = strstr ( ppath , \";\ntype=\" ) ;\n if ( type && type [ 6 ] && type [ 7 ] == 0 ) {\n switch ( Curl_raw_toupper ( type [ 6 ] ) ) {\n case 'A' : case 'D' : case 'I' : break ;\n default : type = NULL ;\n }\n }\n if ( ! type ) {\n char * p = ftp_typecode ;\n if ( ! * data -> state . path && ppath [ strlen ( ppath ) - 1 ] != '/' ) {\n * p ++ = '/' ;\n }\n snprintf ( p , sizeof ( ftp_typecode ) - 1 , \";\ntype=%c\" , data -> set . prefer_ascii ? 'a' : 'i' ) ;\n }\n }\n if ( conn -> bits . user_passwd && ! conn -> bits . userpwd_in_url ) paste_ftp_userpwd = TRUE ;\n }\n }\n # endif if ( HTTPREQ_POST_FORM == httpreq ) {\n result = Curl_getformdata ( data , & http -> sendit , data -> set . httppost , Curl_checkheaders ( conn , \"Content-Type:\" ) , & http -> postsize ) ;\n if ( result ) return result ;\n }\n http -> p_accept = Curl_checkheaders ( conn , \"Accept:\" ) ? NULL : \"Accept: */*\\r\\n\" ;\n if ( ( ( HTTPREQ_POST == httpreq ) || ( HTTPREQ_POST_FORM == httpreq ) || ( HTTPREQ_PUT == httpreq ) ) && data -> state . resume_from ) {\n if ( data -> state . resume_from < 0 ) {\n data -> state . resume_from = 0 ;\n }\n if ( data -> state . resume_from && ! data -> state . this_is_a_follow ) {\n if ( conn -> seek_func ) {\n seekerr = conn -> seek_func ( conn -> seek_client , data -> state . resume_from , SEEK_SET ) ;\n }\n if ( seekerr != CURL_SEEKFUNC_OK ) {\n if ( seekerr != CURL_SEEKFUNC_CANTSEEK ) {\n failf ( data , \"Could not seek stream\" ) ;\n return CURLE_READ_ERROR ;\n }\n else {\n curl_off_t passed = 0 ;\n do {\n size_t readthisamountnow = ( data -> state . resume_from - passed > CURL_OFF_T_C ( BUFSIZE ) ) ? BUFSIZE : curlx_sotouz ( data -> state . resume_from - passed ) ;\n size_t actuallyread = data -> state . fread_func ( data -> state . buffer , 1 , readthisamountnow , data -> state . in ) ;\n passed += actuallyread ;\n if ( ( actuallyread == 0 ) || ( actuallyread > readthisamountnow ) ) {\n failf ( data , \"Could only read %\" CURL_FORMAT_CURL_OFF_T \" bytes from the input\" , passed ) ;\n return CURLE_READ_ERROR ;\n }\n }\n while ( passed < data -> state . resume_from ) ;\n }\n }\n if ( data -> state . infilesize > 0 ) {\n data -> state . infilesize -= data -> state . resume_from ;\n if ( data -> state . infilesize <= 0 ) {\n failf ( data , \"File already completely uploaded\" ) ;\n return CURLE_PARTIAL_FILE ;\n }\n }\n }\n }\n if ( data -> state . use_range ) {\n if ( ( ( httpreq == HTTPREQ_GET ) || ( httpreq == HTTPREQ_HEAD ) ) && ! Curl_checkheaders ( conn , \"Range:\" ) ) {\n free ( conn -> allocptr . rangeline ) ;\n conn -> allocptr . rangeline = aprintf ( \"Range: bytes=%s\\r\\n\" , data -> state . range ) ;\n }\n else if ( ( httpreq != HTTPREQ_GET ) && ! Curl_checkheaders ( conn , \"Content-Range:\" ) ) {\n free ( conn -> allocptr . rangeline ) ;\n if ( data -> set . set_resume_from < 0 ) {\n conn -> allocptr . rangeline = aprintf ( \"Content-Range: bytes 0-%\" CURL_FORMAT_CURL_OFF_T \"/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , data -> state . infilesize - 1 , data -> state . infilesize ) ;\n }\n else if ( data -> state . resume_from ) {\n curl_off_t total_expected_size = data -> state . resume_from + data -> state . infilesize ;\n conn -> allocptr . rangeline = aprintf ( \"Content-Range: bytes %s%\" CURL_FORMAT_CURL_OFF_T \"/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , data -> state . range , total_expected_size - 1 , total_expected_size ) ;\n }\n else {\n conn -> allocptr . rangeline = aprintf ( \"Content-Range: bytes %s/%\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , data -> state . range , data -> state . infilesize ) ;\n }\n if ( ! conn -> allocptr . rangeline ) return CURLE_OUT_OF_MEMORY ;\n }\n }\n httpstring = use_http_1_1plus ( data , conn ) ? \"1.1\" : \"1.0\" ;\n req_buffer = Curl_add_buffer_init ( ) ;\n if ( ! req_buffer ) return CURLE_OUT_OF_MEMORY ;\n result = Curl_add_bufferf ( req_buffer , \"%s \" , request ) ;\n if ( result ) return result ;\n if ( paste_ftp_userpwd ) result = Curl_add_bufferf ( req_buffer , \"ftp://%s:%s@%s\" , conn -> user , conn -> passwd , ppath + sizeof ( \"ftp://\" ) - 1 ) ;\n else result = Curl_add_buffer ( req_buffer , ppath , strlen ( ppath ) ) ;\n if ( result ) return result ;\n result = Curl_add_bufferf ( req_buffer , \"%s\" \" HTTP/%s\\r\\n\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" \"%s\" , ftp_typecode , httpstring , ( conn -> allocptr . host ? conn -> allocptr . host : \"\" ) , conn -> allocptr . proxyuserpwd ? conn -> allocptr . proxyuserpwd : \"\" , conn -> allocptr . userpwd ? conn -> allocptr . userpwd : \"\" , ( data -> state . use_range && conn -> allocptr . rangeline ) ? conn -> allocptr . rangeline : \"\" , ( data -> set . str [ STRING_USERAGENT ] && * data -> set . str [ STRING_USERAGENT ] && conn -> allocptr . uagent ) ? conn -> allocptr . uagent : \"\" , http -> p_accept ? http -> p_accept : \"\" , conn -> allocptr . te ? conn -> allocptr . te : \"\" , ( data -> set . str [ STRING_ENCODING ] && * data -> set . str [ STRING_ENCODING ] && conn -> allocptr . accept_encoding ) ? conn -> allocptr . accept_encoding : \"\" , ( data -> change . referer && conn -> allocptr . ref ) ? conn -> allocptr . ref : \"\" , ( conn -> bits . httpproxy && ! conn -> bits . tunnel_proxy && ! Curl_checkProxyheaders ( conn , \"Proxy-Connection:\" ) ) ? \"Proxy-Connection: Keep-Alive\\r\\n\" : \"\" , te ) ;\n Curl_safefree ( conn -> allocptr . userpwd ) ;\n switch ( data -> state . authproxy . picked ) {\n case CURLAUTH_NEGOTIATE : case CURLAUTH_NTLM : case CURLAUTH_NTLM_WB : Curl_safefree ( conn -> allocptr . proxyuserpwd ) ;\n break ;\n }\n if ( result ) return result ;\n if ( ! ( conn -> handler -> flags & PROTOPT_SSL ) && conn -> httpversion != 20 && ( data -> set . httpversion == CURL_HTTP_VERSION_2 ) ) {\n result = Curl_http2_request_upgrade ( req_buffer , conn ) ;\n if ( result ) return result ;\n }\n # if ! defined ( CURL_DISABLE_COOKIES ) if ( data -> cookies || addcookies ) {\n struct Cookie * co = NULL ;\n int count = 0 ;\n if ( data -> cookies ) {\n Curl_share_lock ( data , CURL_LOCK_DATA_COOKIE , CURL_LOCK_ACCESS_SINGLE ) ;\n co = Curl_cookie_getlist ( data -> cookies , conn -> allocptr . cookiehost ? conn -> allocptr . cookiehost : host , data -> state . path , ( conn -> handler -> protocol & CURLPROTO_HTTPS ) ? TRUE : FALSE ) ;\n Curl_share_unlock ( data , CURL_LOCK_DATA_COOKIE ) ;\n }\n if ( co ) {\n struct Cookie * store = co ;\n while ( co ) {\n if ( co -> value ) {\n if ( 0 == count ) {\n result = Curl_add_bufferf ( req_buffer , \"Cookie: \" ) ;\n if ( result ) break ;\n }\n result = Curl_add_bufferf ( req_buffer , \"%s%s=%s\" , count ? \";\n \" : \"\" , co -> name , co -> value ) ;\n if ( result ) break ;\n count ++ ;\n }\n co = co -> next ;\n }\n Curl_cookie_freelist ( store , FALSE ) ;\n }\n if ( addcookies && ! result ) {\n if ( ! count ) result = Curl_add_bufferf ( req_buffer , \"Cookie: \" ) ;\n if ( ! result ) {\n result = Curl_add_bufferf ( req_buffer , \"%s%s\" , count ? \";\n \" : \"\" , addcookies ) ;\n count ++ ;\n }\n }\n if ( count && ! result ) result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n }\n # endif result = Curl_add_timecondition ( data , req_buffer ) ;\n if ( result ) return result ;\n result = Curl_add_custom_headers ( conn , FALSE , req_buffer ) ;\n if ( result ) return result ;\n http -> postdata = NULL ;\n Curl_pgrsSetUploadSize ( data , - 1 ) ;\n switch ( httpreq ) {\n case HTTPREQ_POST_FORM : if ( ! http -> sendit || conn -> bits . authneg ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Length: 0\\r\\n\\r\\n\" ) ;\n if ( result ) return result ;\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , 0 , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending POST request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , - 1 , NULL ) ;\n break ;\n }\n if ( Curl_FormInit ( & http -> form , http -> sendit ) ) {\n failf ( data , \"Internal HTTP POST error!\" ) ;\n return CURLE_HTTP_POST_ERROR ;\n }\n http -> form . fread_func = data -> state . fread_func ;\n data -> state . fread_func = ( curl_read_callback ) Curl_FormReader ;\n data -> state . in = & http -> form ;\n http -> sending = HTTPSEND_BODY ;\n if ( ! data -> req . upload_chunky && ! Curl_checkheaders ( conn , \"Content-Length:\" ) ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , http -> postsize ) ;\n if ( result ) return result ;\n }\n result = expect100 ( data , conn , req_buffer ) ;\n if ( result ) return result ;\n {\n char * contentType ;\n size_t linelength = 0 ;\n contentType = Curl_formpostheader ( ( void * ) & http -> form , & linelength ) ;\n if ( ! contentType ) {\n failf ( data , \"Could not get Content-Type header line!\" ) ;\n return CURLE_HTTP_POST_ERROR ;\n }\n result = Curl_add_buffer ( req_buffer , contentType , linelength ) ;\n if ( result ) return result ;\n }\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n Curl_pgrsSetUploadSize ( data , http -> postsize ) ;\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , 0 , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending POST request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , FIRSTSOCKET , & http -> writebytecount ) ;\n if ( result ) {\n Curl_formclean ( & http -> sendit ) ;\n return result ;\n }\n result = Curl_convert_form ( data , http -> sendit ) ;\n if ( result ) {\n Curl_formclean ( & http -> sendit ) ;\n return result ;\n }\n break ;\n case HTTPREQ_PUT : if ( conn -> bits . authneg ) postsize = 0 ;\n else postsize = data -> state . infilesize ;\n if ( ( postsize != - 1 ) && ! data -> req . upload_chunky && ! Curl_checkheaders ( conn , \"Content-Length:\" ) ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , postsize ) ;\n if ( result ) return result ;\n }\n if ( postsize != 0 ) {\n result = expect100 ( data , conn , req_buffer ) ;\n if ( result ) return result ;\n }\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n Curl_pgrsSetUploadSize ( data , postsize ) ;\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , 0 , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending PUT request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , postsize ? FIRSTSOCKET : - 1 , postsize ? & http -> writebytecount : NULL ) ;\n if ( result ) return result ;\n break ;\n case HTTPREQ_POST : if ( conn -> bits . authneg ) postsize = 0 ;\n else {\n postsize = ( data -> state . infilesize != - 1 ) ? data -> state . infilesize : ( data -> set . postfields ? ( curl_off_t ) strlen ( data -> set . postfields ) : - 1 ) ;\n }\n if ( ( postsize != - 1 ) && ! data -> req . upload_chunky && ! Curl_checkheaders ( conn , \"Content-Length:\" ) ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Length: %\" CURL_FORMAT_CURL_OFF_T \"\\r\\n\" , postsize ) ;\n if ( result ) return result ;\n }\n if ( ! Curl_checkheaders ( conn , \"Content-Type:\" ) ) {\n result = Curl_add_bufferf ( req_buffer , \"Content-Type: application/\" \"x-www-form-urlencoded\\r\\n\" ) ;\n if ( result ) return result ;\n }\n ptr = Curl_checkheaders ( conn , \"Expect:\" ) ;\n if ( ptr ) {\n data -> state . expect100header = Curl_compareheader ( ptr , \"Expect:\" , \"100-continue\" ) ;\n }\n else if ( postsize > TINY_INITIAL_POST_SIZE || postsize < 0 ) {\n result = expect100 ( data , conn , req_buffer ) ;\n if ( result ) return result ;\n }\n else data -> state . expect100header = FALSE ;\n if ( data -> set . postfields ) {\n if ( conn -> httpversion != 20 && ! data -> state . expect100header && ( postsize < MAX_INITIAL_POST_SIZE ) ) {\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n if ( ! data -> req . upload_chunky ) {\n result = Curl_add_buffer ( req_buffer , data -> set . postfields , ( size_t ) postsize ) ;\n included_body = postsize ;\n }\n else {\n if ( postsize ) {\n result = Curl_add_bufferf ( req_buffer , \"%x\\r\\n\" , ( int ) postsize ) ;\n if ( ! result ) {\n result = Curl_add_buffer ( req_buffer , data -> set . postfields , ( size_t ) postsize ) ;\n if ( ! result ) result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n included_body = postsize + 2 ;\n }\n }\n if ( ! result ) result = Curl_add_buffer ( req_buffer , \"\\x30\\x0d\\x0a\\x0d\\x0a\" , 5 ) ;\n included_body += 5 ;\n }\n if ( result ) return result ;\n Curl_pgrsSetUploadSize ( data , postsize ) ;\n }\n else {\n http -> postsize = postsize ;\n http -> postdata = data -> set . postfields ;\n http -> sending = HTTPSEND_BODY ;\n data -> state . fread_func = ( curl_read_callback ) readmoredata ;\n data -> state . in = ( void * ) conn ;\n Curl_pgrsSetUploadSize ( data , http -> postsize ) ;\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n }\n }\n else {\n result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n if ( data -> req . upload_chunky && conn -> bits . authneg ) {\n result = Curl_add_buffer ( req_buffer , \"\\x30\\x0d\\x0a\\x0d\\x0a\" , 5 ) ;\n if ( result ) return result ;\n }\n else if ( data -> state . infilesize ) {\n Curl_pgrsSetUploadSize ( data , postsize ? postsize : - 1 ) ;\n if ( ! conn -> bits . authneg ) {\n http -> postdata = ( char * ) & http -> postdata ;\n http -> postsize = postsize ;\n }\n }\n }\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , ( size_t ) included_body , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending HTTP POST request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , http -> postdata ? FIRSTSOCKET : - 1 , http -> postdata ? & http -> writebytecount : NULL ) ;\n break ;\n default : result = Curl_add_buffer ( req_buffer , \"\\r\\n\" , 2 ) ;\n if ( result ) return result ;\n result = Curl_add_buffer_send ( req_buffer , conn , & data -> info . request_size , 0 , FIRSTSOCKET ) ;\n if ( result ) failf ( data , \"Failed sending HTTP request\" ) ;\n else Curl_setup_transfer ( conn , FIRSTSOCKET , - 1 , TRUE , & http -> readbytecount , http -> postdata ? FIRSTSOCKET : - 1 , http -> postdata ? & http -> writebytecount : NULL ) ;\n }\n if ( result ) return result ;\n if ( http -> writebytecount ) {\n Curl_pgrsSetUploadCounter ( data , http -> writebytecount ) ;\n if ( Curl_pgrsUpdate ( conn ) ) result = CURLE_ABORTED_BY_CALLBACK ;\n if ( http -> writebytecount >= postsize ) {\n infof ( data , \"upload completely sent off: %\" CURL_FORMAT_CURL_OFF_T \" out of %\" CURL_FORMAT_CURL_OFF_T \" bytes\\n\" , http -> writebytecount , postsize ) ;\n data -> req . upload_done = TRUE ;\n data -> req . keepon &= ~ KEEP_SEND ;\n data -> req . exp100 = EXP100_SEND_DATA ;\n }\n }\n if ( ( conn -> httpversion == 20 ) && data -> req . upload_chunky ) data -> req . upload_chunky = FALSE ;\n return result ;\n }",
        "hash": -7136186224744987223,
        "project": "debian",
        "size": 483,
        "slice": {
            "free": [
                [
                    42,
                    " if ( ! data -> state . this_is_a_follow ) {\n"
                ],
                [
                    43,
                    " free ( data -> state . first_host ) ;\n"
                ],
                [
                    69,
                    " if ( Curl_checkheaders ( conn , \"User-Agent:\" ) ) {\n"
                ],
                [
                    70,
                    " free ( conn -> allocptr . uagent ) ;\n"
                ]
            ],
            "strdup": [
                [
                    42,
                    " if ( ! data -> state . this_is_a_follow ) {\n"
                ],
                [
                    44,
                    " data -> state . first_host = strdup ( conn -> host . name ) ;\n"
                ],
                [
                    45,
                    " if ( ! data -> state . first_host ) return CURLE_OUT_OF_MEMORY ;\n"
                ]
            ],
            "result": [
                [
                    42,
                    " if ( ! data -> state . this_is_a_follow ) {\n"
                ],
                [
                    43,
                    " free ( data -> state . first_host ) ;\n"
                ],
                [
                    44,
                    " data -> state . first_host = strdup ( conn -> host . name ) ;\n"
                ],
                [
                    45,
                    " if ( ! data -> state . first_host ) return CURLE_OUT_OF_MEMORY ;\n"
                ],
                [
                    69,
                    " if ( Curl_checkheaders ( conn , \"User-Agent:\" ) ) {\n"
                ],
                [
                    70,
                    " free ( conn -> allocptr . uagent ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) {\n if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , \"GAB2\" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) {\n uint8_t desc [ 256 ] ;\n int score = AVPROBE_SCORE_EXTENSION , ret ;\n AVIStream * ast = st -> priv_data ;\n AVInputFormat * sub_demuxer ;\n AVRational time_base ;\n int size ;\n AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ;\n AVProbeData pd ;\n unsigned int desc_len = avio_rl32 ( pb ) ;\n if ( desc_len > pb -> buf_end - pb -> buf_ptr ) goto error ;\n ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ;\n avio_skip ( pb , desc_len - ret ) ;\n if ( * desc ) av_dict_set ( & st -> metadata , \"title\" , desc , 0 ) ;\n avio_rl16 ( pb ) ;\n avio_rl32 ( pb ) ;\n size = pb -> buf_end - pb -> buf_ptr ;\n pd = ( AVProbeData ) {\n . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , . buf_size = size }\n ;\n if ( ! pd . buf ) goto error ;\n memcpy ( pd . buf , pb -> buf_ptr , size ) ;\n sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ;\n av_freep ( & pd . buf ) ;\n if ( ! sub_demuxer ) goto error ;\n if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) goto error ;\n ast -> sub_ctx -> pb = pb ;\n if ( ff_copy_whiteblacklists ( ast -> sub_ctx , s ) < 0 ) goto error ;\n if ( ! avformat_open_input ( & ast -> sub_ctx , \"\" , sub_demuxer , NULL ) ) {\n if ( ast -> sub_ctx -> nb_streams != 1 ) goto error ;\n ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) ;\n avcodec_parameters_copy ( st -> codecpar , ast -> sub_ctx -> streams [ 0 ] -> codecpar ) ;\n time_base = ast -> sub_ctx -> streams [ 0 ] -> time_base ;\n avpriv_set_pts_info ( st , 64 , time_base . num , time_base . den ) ;\n }\n ast -> sub_buffer = pkt -> data ;\n memset ( pkt , 0 , sizeof ( * pkt ) ) ;\n return 1 ;\n error : av_freep ( & ast -> sub_ctx ) ;\n av_freep ( & pb ) ;\n }\n return 0 ;\n }",
        "hash": -4534372572324105488,
        "project": "debian",
        "size": 44,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) {\n"
                ],
                [
                    17,
                    " avio_rl32 ( pb ) ;\n"
                ],
                [
                    18,
                    " size = pb -> buf_end - pb -> buf_ptr ;\n"
                ],
                [
                    22,
                    " if ( ! pd . buf ) goto error ;\n"
                ],
                [
                    23,
                    " memcpy ( pd . buf , pb -> buf_ptr , size ) ;\n"
                ],
                [
                    24,
                    " sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ;\n"
                ],
                [
                    25,
                    " av_freep ( & pd . buf ) ;\n"
                ],
                [
                    28,
                    " ast -> sub_ctx -> pb = pb ;\n"
                ],
                [
                    41,
                    " av_freep ( & pb ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) {\n"
                ],
                [
                    2,
                    " if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , \"GAB2\" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) {\n"
                ],
                [
                    9,
                    " AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ;\n"
                ],
                [
                    30,
                    " if ( ! avformat_open_input ( & ast -> sub_ctx , \"\" , sub_demuxer , NULL ) ) {\n"
                ],
                [
                    31,
                    " if ( ast -> sub_ctx -> nb_streams != 1 ) goto error ;\n"
                ],
                [
                    38,
                    " memset ( pkt , 0 , sizeof ( * pkt ) ) ;\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) {\n"
                ],
                [
                    2,
                    " if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , \"GAB2\" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) {\n"
                ],
                [
                    9,
                    " AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ;\n"
                ],
                [
                    37,
                    " ast -> sub_buffer = pkt -> data ;\n"
                ],
                [
                    38,
                    " memset ( pkt , 0 , sizeof ( * pkt ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) {\n"
                ],
                [
                    2,
                    " if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , \"GAB2\" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) {\n"
                ],
                [
                    9,
                    " AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ;\n"
                ],
                [
                    17,
                    " avio_rl32 ( pb ) ;\n"
                ],
                [
                    18,
                    " size = pb -> buf_end - pb -> buf_ptr ;\n"
                ],
                [
                    22,
                    " if ( ! pd . buf ) goto error ;\n"
                ],
                [
                    23,
                    " memcpy ( pd . buf , pb -> buf_ptr , size ) ;\n"
                ],
                [
                    24,
                    " sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ;\n"
                ],
                [
                    25,
                    " av_freep ( & pd . buf ) ;\n"
                ],
                [
                    28,
                    " ast -> sub_ctx -> pb = pb ;\n"
                ],
                [
                    30,
                    " if ( ! avformat_open_input ( & ast -> sub_ctx , \"\" , sub_demuxer , NULL ) ) {\n"
                ],
                [
                    31,
                    " if ( ast -> sub_ctx -> nb_streams != 1 ) goto error ;\n"
                ],
                [
                    37,
                    " ast -> sub_buffer = pkt -> data ;\n"
                ],
                [
                    38,
                    " memset ( pkt , 0 , sizeof ( * pkt ) ) ;\n"
                ],
                [
                    41,
                    " av_freep ( & pb ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n OFCondition cond = EC_Normal ;\n unsigned char type ;\n unsigned long itemLength ;\n PRV_PRESENTATIONCONTEXTITEM * context ;\n ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n if ( ( assoc -> presentationContextList = LST_Create ( ) ) == NULL ) return EC_MemoryExhausted ;\n if ( ( assoc -> userInfo . SCUSCPRoleList = LST_Create ( ) ) == NULL ) return EC_MemoryExhausted ;\n if ( pduLength < 2 + 2 + 16 + 16 + 32 ) return makeLengthError ( \"associate PDU\" , pduLength , 2 + 2 + 16 + 16 + 32 ) ;\n assoc -> type = * buf ++ ;\n assoc -> rsv1 = * buf ++ ;\n EXTRACT_LONG_BIG ( buf , assoc -> length ) ;\n buf += 4 ;\n EXTRACT_SHORT_BIG ( buf , assoc -> protocol ) ;\n buf += 2 ;\n pduLength -= 2 ;\n if ( ( assoc -> protocol & DUL_PROTOCOL ) == 0 ) {\n char buffer [ 256 ] ;\n sprintf ( buffer , \"DUL Unsupported peer protocol %04x;\n expected %04x in %s\" , assoc -> protocol , DUL_PROTOCOL , \"parseAssociate\" ) ;\n return makeDcmnetCondition ( DULC_UNSUPPORTEDPEERPROTOCOL , OF_error , buffer ) ;\n }\n assoc -> rsv2 [ 0 ] = * buf ++ ;\n pduLength -- ;\n assoc -> rsv2 [ 1 ] = * buf ++ ;\n pduLength -- ;\n ( void ) strncpy ( assoc -> calledAPTitle , ( char * ) buf , 16 ) ;\n assoc -> calledAPTitle [ 16 ] = '\\0' ;\n trim_trailing_spaces ( assoc -> calledAPTitle ) ;\n buf += 16 ;\n pduLength -= 16 ;\n ( void ) strncpy ( assoc -> callingAPTitle , ( char * ) buf , 16 ) ;\n assoc -> callingAPTitle [ 16 ] = '\\0' ;\n trim_trailing_spaces ( assoc -> callingAPTitle ) ;\n buf += 16 ;\n pduLength -= 16 ;\n ( void ) memcpy ( assoc -> rsv3 , buf , 32 ) ;\n buf += 32 ;\n pduLength -= 32 ;\n if ( DCM_dcmnetLogger . isEnabledFor ( OFLogger : : DEBUG_LOG_LEVEL ) ) {\n const char * s ;\n DCMNET_DEBUG ( \"Parsing an A-ASSOCIATE PDU\" ) ;\n if ( assoc -> type == DUL_TYPEASSOCIATERQ ) s = \"A-ASSOCIATE RQ\" ;\n else if ( assoc -> type == DUL_TYPEASSOCIATEAC ) s = \"A-ASSOCIATE AC\" ;\n else s = \"Unknown: Programming bug in parseAssociate\" ;\n DCMNET_TRACE ( \"PDU type: \" << STD_NAMESPACE hex << ( ( unsigned int ) assoc -> type ) << STD_NAMESPACE dec << \" (\" << s << \"), PDU Length: \" << assoc -> length << OFendl << \"DICOM Protocol: \" << STD_NAMESPACE hex << assoc -> protocol << STD_NAMESPACE dec << OFendl << \"Called AP Title: \" << assoc -> calledAPTitle << OFendl << \"Calling AP Title: \" << assoc -> callingAPTitle ) ;\n }\n while ( ( cond . good ( ) ) && ( pduLength > 0 ) ) {\n type = * buf ;\n DCMNET_TRACE ( \"Parsing remaining \" << pduLength << \" bytes of A-ASSOCIATE PDU\" << OFendl << \"Next item type: \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( ( unsigned int ) type ) ) ;\n switch ( type ) {\n case DUL_TYPEAPPLICATIONCONTEXT : cond = parseSubItem ( & assoc -> applicationContext , buf , & itemLength , pduLength ) ;\n if ( cond . good ( ) ) {\n buf += itemLength ;\n pduLength -= itemLength ;\n DCMNET_TRACE ( \"Successfully parsed Application Context\" ) ;\n }\n break ;\n case DUL_TYPEPRESENTATIONCONTEXTRQ : case DUL_TYPEPRESENTATIONCONTEXTAC : context = ( PRV_PRESENTATIONCONTEXTITEM * ) malloc ( sizeof ( PRV_PRESENTATIONCONTEXTITEM ) ) ;\n if ( context == NULL ) return EC_MemoryExhausted ;\n ( void ) memset ( context , 0 , sizeof ( * context ) ) ;\n cond = parsePresentationContext ( type , context , buf , & itemLength , pduLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += itemLength ;\n pduLength -= itemLength ;\n LST_Enqueue ( & assoc -> presentationContextList , ( LST_NODE * ) context ) ;\n DCMNET_TRACE ( \"Successfully parsed Presentation Context\" ) ;\n break ;\n case DUL_TYPEUSERINFO : cond = parseUserInfo ( & assoc -> userInfo , buf , & itemLength , assoc -> type , pduLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += itemLength ;\n pduLength -= itemLength ;\n DCMNET_TRACE ( \"Successfully parsed User Information\" ) ;\n break ;\n default : cond = parseDummy ( buf , & itemLength , pduLength ) ;\n buf += itemLength ;\n pduLength -= itemLength ;\n break ;\n }\n }\n return cond ;\n }",
        "hash": -4525874104093394205,
        "project": "debian",
        "size": 82,
        "slice": {
            "memcpy": [
                [
                    1,
                    "OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n"
                ],
                [
                    6,
                    " ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n"
                ],
                [
                    9,
                    " if ( pduLength < 2 + 2 + 16 + 16 + 32 ) return makeLengthError ( \"associate PDU\" , pduLength , 2 + 2 + 16 + 16 + 32 ) ;\n"
                ],
                [
                    35,
                    " buf += 16 ;\n"
                ],
                [
                    37,
                    " ( void ) memcpy ( assoc -> rsv3 , buf , 32 ) ;\n"
                ],
                [
                    38,
                    " buf += 32 ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n"
                ],
                [
                    6,
                    " ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n"
                ],
                [
                    12,
                    " EXTRACT_LONG_BIG ( buf , assoc -> length ) ;\n"
                ],
                [
                    14,
                    " EXTRACT_SHORT_BIG ( buf , assoc -> protocol ) ;\n"
                ],
                [
                    17,
                    " if ( ( assoc -> protocol & DUL_PROTOCOL ) == 0 ) {\n"
                ],
                [
                    27,
                    " ( void ) strncpy ( assoc -> calledAPTitle , ( char * ) buf , 16 ) ;\n"
                ],
                [
                    29,
                    " trim_trailing_spaces ( assoc -> calledAPTitle ) ;\n"
                ],
                [
                    32,
                    " ( void ) strncpy ( assoc -> callingAPTitle , ( char * ) buf , 16 ) ;\n"
                ],
                [
                    34,
                    " trim_trailing_spaces ( assoc -> callingAPTitle ) ;\n"
                ],
                [
                    37,
                    " ( void ) memcpy ( assoc -> rsv3 , buf , 32 ) ;\n"
                ],
                [
                    43,
                    " if ( assoc -> type == DUL_TYPEASSOCIATERQ ) s = \"A-ASSOCIATE RQ\" ;\n"
                ],
                [
                    44,
                    " else if ( assoc -> type == DUL_TYPEASSOCIATEAC ) s = \"A-ASSOCIATE AC\" ;\n"
                ],
                [
                    52,
                    " case DUL_TYPEAPPLICATIONCONTEXT : cond = parseSubItem ( & assoc -> applicationContext , buf , & itemLength , pduLength ) ;\n"
                ],
                [
                    60,
                    " if ( context == NULL ) return EC_MemoryExhausted ;\n"
                ],
                [
                    61,
                    " ( void ) memset ( context , 0 , sizeof ( * context ) ) ;\n"
                ],
                [
                    62,
                    " cond = parsePresentationContext ( type , context , buf , & itemLength , pduLength ) ;\n"
                ],
                [
                    66,
                    " LST_Enqueue ( & assoc -> presentationContextList , ( LST_NODE * ) context ) ;\n"
                ],
                [
                    69,
                    " case DUL_TYPEUSERINFO : cond = parseUserInfo ( & assoc -> userInfo , buf , & itemLength , assoc -> type , pduLength ) ;\n"
                ]
            ],
            "strncpy": [
                [
                    1,
                    "OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n"
                ],
                [
                    6,
                    " ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n"
                ],
                [
                    9,
                    " if ( pduLength < 2 + 2 + 16 + 16 + 32 ) return makeLengthError ( \"associate PDU\" , pduLength , 2 + 2 + 16 + 16 + 32 ) ;\n"
                ],
                [
                    25,
                    " assoc -> rsv2 [ 1 ] = * buf ++ ;\n"
                ],
                [
                    27,
                    " ( void ) strncpy ( assoc -> calledAPTitle , ( char * ) buf , 16 ) ;\n"
                ],
                [
                    29,
                    " trim_trailing_spaces ( assoc -> calledAPTitle ) ;\n"
                ],
                [
                    30,
                    " buf += 16 ;\n"
                ],
                [
                    32,
                    " ( void ) strncpy ( assoc -> callingAPTitle , ( char * ) buf , 16 ) ;\n"
                ],
                [
                    34,
                    " trim_trailing_spaces ( assoc -> callingAPTitle ) ;\n"
                ]
            ],
            "malloc": [
                [
                    51,
                    " switch ( type ) {\n"
                ],
                [
                    59,
                    " case DUL_TYPEPRESENTATIONCONTEXTRQ : case DUL_TYPEPRESENTATIONCONTEXTAC : context = ( PRV_PRESENTATIONCONTEXTITEM * ) malloc ( sizeof ( PRV_PRESENTATIONCONTEXTITEM ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n"
                ],
                [
                    6,
                    " ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n"
                ],
                [
                    9,
                    " if ( pduLength < 2 + 2 + 16 + 16 + 32 ) return makeLengthError ( \"associate PDU\" , pduLength , 2 + 2 + 16 + 16 + 32 ) ;\n"
                ],
                [
                    12,
                    " EXTRACT_LONG_BIG ( buf , assoc -> length ) ;\n"
                ],
                [
                    14,
                    " EXTRACT_SHORT_BIG ( buf , assoc -> protocol ) ;\n"
                ],
                [
                    17,
                    " if ( ( assoc -> protocol & DUL_PROTOCOL ) == 0 ) {\n"
                ],
                [
                    25,
                    " assoc -> rsv2 [ 1 ] = * buf ++ ;\n"
                ],
                [
                    27,
                    " ( void ) strncpy ( assoc -> calledAPTitle , ( char * ) buf , 16 ) ;\n"
                ],
                [
                    29,
                    " trim_trailing_spaces ( assoc -> calledAPTitle ) ;\n"
                ],
                [
                    30,
                    " buf += 16 ;\n"
                ],
                [
                    32,
                    " ( void ) strncpy ( assoc -> callingAPTitle , ( char * ) buf , 16 ) ;\n"
                ],
                [
                    34,
                    " trim_trailing_spaces ( assoc -> callingAPTitle ) ;\n"
                ],
                [
                    35,
                    " buf += 16 ;\n"
                ],
                [
                    37,
                    " ( void ) memcpy ( assoc -> rsv3 , buf , 32 ) ;\n"
                ],
                [
                    38,
                    " buf += 32 ;\n"
                ],
                [
                    43,
                    " if ( assoc -> type == DUL_TYPEASSOCIATERQ ) s = \"A-ASSOCIATE RQ\" ;\n"
                ],
                [
                    44,
                    " else if ( assoc -> type == DUL_TYPEASSOCIATEAC ) s = \"A-ASSOCIATE AC\" ;\n"
                ],
                [
                    51,
                    " switch ( type ) {\n"
                ],
                [
                    52,
                    " case DUL_TYPEAPPLICATIONCONTEXT : cond = parseSubItem ( & assoc -> applicationContext , buf , & itemLength , pduLength ) ;\n"
                ],
                [
                    59,
                    " case DUL_TYPEPRESENTATIONCONTEXTRQ : case DUL_TYPEPRESENTATIONCONTEXTAC : context = ( PRV_PRESENTATIONCONTEXTITEM * ) malloc ( sizeof ( PRV_PRESENTATIONCONTEXTITEM ) ) ;\n"
                ],
                [
                    60,
                    " if ( context == NULL ) return EC_MemoryExhausted ;\n"
                ],
                [
                    61,
                    " ( void ) memset ( context , 0 , sizeof ( * context ) ) ;\n"
                ],
                [
                    62,
                    " cond = parsePresentationContext ( type , context , buf , & itemLength , pduLength ) ;\n"
                ],
                [
                    66,
                    " LST_Enqueue ( & assoc -> presentationContextList , ( LST_NODE * ) context ) ;\n"
                ],
                [
                    69,
                    " case DUL_TYPEUSERINFO : cond = parseUserInfo ( & assoc -> userInfo , buf , & itemLength , assoc -> type , pduLength ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static OFCondition parseSCUSCPRole ( PRV_SCUSCPROLE * role , unsigned char * buf , unsigned long * length , unsigned long availData ) {\n unsigned short UIDLength ;\n if ( availData < 8 ) return makeLengthError ( \"SCU-SCP role list\" , availData , 8 ) ;\n role -> type = * buf ++ ;\n role -> rsv1 = * buf ++ ;\n EXTRACT_SHORT_BIG ( buf , role -> length ) ;\n buf += 2 ;\n EXTRACT_SHORT_BIG ( buf , UIDLength ) ;\n buf += 2 ;\n if ( availData - 4 < role -> length ) return makeLengthError ( \"SCU-SCP role list\" , availData , 0 , role -> length ) ;\n if ( role -> length < 4 ) return makeLengthError ( \"SCU-SCP role list UID\" , role -> length , 4 ) ;\n if ( role -> length - 4 < UIDLength ) return makeLengthError ( \"SCU-SCP role list UID\" , role -> length , 0 , UIDLength ) ;\n ( void ) memcpy ( role -> SOPClassUID , buf , UIDLength ) ;\n role -> SOPClassUID [ UIDLength ] = '\\0' ;\n buf += UIDLength ;\n role -> SCURole = * buf ++ ;\n role -> SCPRole = * buf ++ ;\n * length = 2 + 2 + role -> length ;\n DCMNET_TRACE ( \"Subitem parse: Type \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) role -> type << STD_NAMESPACE dec << \", Length \" << STD_NAMESPACE setw ( 4 ) << ( int ) role -> length << \", Content: \" << role -> SOPClassUID << \" \" << ( int ) role -> SCURole << \" \" << ( int ) role -> SCPRole ) ;\n return EC_Normal ;\n }",
        "hash": -4525874104093394205,
        "project": "debian",
        "size": 21,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static OFCondition parseSCUSCPRole ( PRV_SCUSCPROLE * role , unsigned char * buf , unsigned long * length , unsigned long availData ) {\n"
                ],
                [
                    9,
                    " buf += 2 ;\n"
                ],
                [
                    12,
                    " if ( role -> length - 4 < UIDLength ) return makeLengthError ( \"SCU-SCP role list UID\" , role -> length , 0 , UIDLength ) ;\n"
                ],
                [
                    13,
                    " ( void ) memcpy ( role -> SOPClassUID , buf , UIDLength ) ;\n"
                ],
                [
                    15,
                    " buf += UIDLength ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static OFCondition parseSCUSCPRole ( PRV_SCUSCPROLE * role , unsigned char * buf , unsigned long * length , unsigned long availData ) {\n"
                ],
                [
                    9,
                    " buf += 2 ;\n"
                ],
                [
                    12,
                    " if ( role -> length - 4 < UIDLength ) return makeLengthError ( \"SCU-SCP role list UID\" , role -> length , 0 , UIDLength ) ;\n"
                ],
                [
                    13,
                    " ( void ) memcpy ( role -> SOPClassUID , buf , UIDLength ) ;\n"
                ],
                [
                    15,
                    " buf += UIDLength ;\n"
                ]
            ]
        }
    },
    {
        "code": "static OFCondition parseUserInfo ( DUL_USERINFO * userInfo , unsigned char * buf , unsigned long * itemLength , unsigned char typeRQorAC , unsigned long availData ) {\n unsigned short userLength ;\n unsigned long length ;\n OFCondition cond = EC_Normal ;\n PRV_SCUSCPROLE * role ;\n SOPClassExtendedNegotiationSubItem * extNeg = NULL ;\n UserIdentityNegotiationSubItem * usrIdent = NULL ;\n if ( availData < 4 ) return makeLengthError ( \"user info\" , availData , 4 ) ;\n userInfo -> type = * buf ++ ;\n userInfo -> rsv1 = * buf ++ ;\n EXTRACT_SHORT_BIG ( buf , userInfo -> length ) ;\n buf += 2 ;\n userLength = userInfo -> length ;\n * itemLength = userLength + 4 ;\n if ( availData - 4 < userLength ) return makeLengthError ( \"user info\" , availData , 0 , userLength ) ;\n DCMNET_TRACE ( \"Parsing user info field (\" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) userInfo -> type << STD_NAMESPACE dec << \"), Length: \" << ( unsigned long ) userInfo -> length ) ;\n while ( userLength > 0 ) {\n DCMNET_TRACE ( \"Parsing remaining \" << ( long ) userLength << \" bytes of User Information\" << OFendl << \"Next item type: \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) * buf ) ;\n switch ( * buf ) {\n case DUL_TYPEMAXLENGTH : cond = parseMaxPDU ( & userInfo -> maxLength , buf , & length , userLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += length ;\n userLength -= ( unsigned short ) length ;\n DCMNET_TRACE ( \"Successfully parsed Maximum PDU Length\" ) ;\n break ;\n case DUL_TYPEIMPLEMENTATIONCLASSUID : cond = parseSubItem ( & userInfo -> implementationClassUID , buf , & length , userLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += length ;\n userLength -= ( unsigned short ) length ;\n break ;\n case DUL_TYPEASYNCOPERATIONS : cond = parseDummy ( buf , & length , userLength ) ;\n buf += length ;\n userLength -= ( unsigned short ) length ;\n break ;\n case DUL_TYPESCUSCPROLE : role = ( PRV_SCUSCPROLE * ) malloc ( sizeof ( PRV_SCUSCPROLE ) ) ;\n if ( role == NULL ) return EC_MemoryExhausted ;\n cond = parseSCUSCPRole ( role , buf , & length , userLength ) ;\n if ( cond . bad ( ) ) return cond ;\n LST_Enqueue ( & userInfo -> SCUSCPRoleList , ( LST_NODE * ) role ) ;\n buf += length ;\n userLength -= ( unsigned short ) length ;\n break ;\n case DUL_TYPEIMPLEMENTATIONVERSIONNAME : cond = parseSubItem ( & userInfo -> implementationVersionName , buf , & length , userLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += length ;\n userLength -= ( unsigned short ) length ;\n break ;\n case DUL_TYPESOPCLASSEXTENDEDNEGOTIATION : extNeg = new SOPClassExtendedNegotiationSubItem ;\n if ( extNeg == NULL ) return EC_MemoryExhausted ;\n cond = parseExtNeg ( extNeg , buf , & length , userLength ) ;\n if ( cond . bad ( ) ) return cond ;\n if ( userInfo -> extNegList == NULL ) {\n userInfo -> extNegList = new SOPClassExtendedNegotiationSubItemList ;\n if ( userInfo -> extNegList == NULL ) return EC_MemoryExhausted ;\n }\n userInfo -> extNegList -> push_back ( extNeg ) ;\n buf += length ;\n userLength -= ( unsigned short ) length ;\n break ;\n case DUL_TYPENEGOTIATIONOFUSERIDENTITY : if ( typeRQorAC == DUL_TYPEASSOCIATERQ ) usrIdent = new UserIdentityNegotiationSubItemRQ ( ) ;\n else usrIdent = new UserIdentityNegotiationSubItemAC ( ) ;\n if ( usrIdent == NULL ) return EC_MemoryExhausted ;\n cond = usrIdent -> parseFromBuffer ( buf , length , userLength ) ;\n if ( cond . bad ( ) ) {\n delete usrIdent ;\n return cond ;\n }\n userInfo -> usrIdent = usrIdent ;\n buf += length ;\n userLength -= ( unsigned short ) length ;\n break ;\n default : cond = parseDummy ( buf , & length , userLength ) ;\n buf += length ;\n userLength -= ( unsigned short ) length ;\n break ;\n }\n }\n return EC_Normal ;\n }",
        "hash": -4525874104093394205,
        "project": "debian",
        "size": 79,
        "slice": {
            "malloc": [
                [
                    19,
                    " switch ( * buf ) {\n"
                ],
                [
                    35,
                    " case DUL_TYPESCUSCPROLE : role = ( PRV_SCUSCPROLE * ) malloc ( sizeof ( PRV_SCUSCPROLE ) ) ;\n"
                ],
                [
                    36,
                    " if ( role == NULL ) return EC_MemoryExhausted ;\n"
                ]
            ],
            "result": [
                [
                    19,
                    " switch ( * buf ) {\n"
                ],
                [
                    35,
                    " case DUL_TYPESCUSCPROLE : role = ( PRV_SCUSCPROLE * ) malloc ( sizeof ( PRV_SCUSCPROLE ) ) ;\n"
                ],
                [
                    36,
                    " if ( role == NULL ) return EC_MemoryExhausted ;\n"
                ]
            ]
        }
    },
    {
        "code": "static OFCondition parsePresentationContext ( unsigned char type , PRV_PRESENTATIONCONTEXTITEM * context , unsigned char * buf , unsigned long * itemLength , unsigned long availData ) {\n unsigned long length ;\n unsigned long presentationLength ;\n OFCondition cond = EC_Normal ;\n DUL_SUBITEM * subItem ;\n if ( availData < 8 ) return makeLengthError ( \"presentation context\" , availData , 8 ) ;\n if ( ( context -> transferSyntaxList = LST_Create ( ) ) == NULL ) return EC_MemoryExhausted ;\n * itemLength = 0 ;\n context -> type = * buf ++ ;\n context -> rsv1 = * buf ++ ;\n EXTRACT_SHORT_BIG ( buf , context -> length ) ;\n buf += 2 ;\n context -> contextID = * buf ++ ;\n context -> rsv2 = * buf ++ ;\n context -> result = * buf ++ ;\n context -> rsv3 = * buf ++ ;\n length = context -> length ;\n * itemLength = 2 + 2 + length ;\n if ( availData - 4 < length || length < 4 ) return makeLengthError ( \"presentation context\" , availData , 4 , length ) ;\n DCMNET_TRACE ( \"Parsing Presentation Context: (\" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) context -> type << STD_NAMESPACE dec << \"), Length: \" << ( unsigned long ) context -> length << OFendl << \"Presentation Context ID: \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) context -> contextID << STD_NAMESPACE dec ) ;\n presentationLength = length - 4 ;\n if ( ! ( ( type == DUL_TYPEPRESENTATIONCONTEXTAC ) && ( context -> result != DUL_PRESENTATION_ACCEPT ) ) ) {\n while ( presentationLength > 0 ) {\n DCMNET_TRACE ( \"Parsing remaining \" << presentationLength << \" bytes of Presentation Context\" << OFendl << \"Next item type: \" << STD_NAMESPACE hex << STD_NAMESPACE setfill ( '0' ) << STD_NAMESPACE setw ( 2 ) << ( unsigned int ) * buf ) ;\n switch ( * buf ) {\n case DUL_TYPEABSTRACTSYNTAX : cond = parseSubItem ( & context -> abstractSyntax , buf , & length , presentationLength ) ;\n if ( cond . bad ( ) ) return cond ;\n buf += length ;\n presentationLength -= length ;\n DCMNET_TRACE ( \"Successfully parsed Abstract Syntax\" ) ;\n break ;\n case DUL_TYPETRANSFERSYNTAX : subItem = ( DUL_SUBITEM * ) malloc ( sizeof ( DUL_SUBITEM ) ) ;\n if ( subItem == NULL ) return EC_MemoryExhausted ;\n cond = parseSubItem ( subItem , buf , & length , presentationLength ) ;\n if ( cond . bad ( ) ) return cond ;\n LST_Enqueue ( & context -> transferSyntaxList , ( LST_NODE * ) subItem ) ;\n buf += length ;\n presentationLength -= length ;\n DCMNET_TRACE ( \"Successfully parsed Transfer Syntax\" ) ;\n break ;\n default : cond = parseDummy ( buf , & length , presentationLength ) ;\n buf += length ;\n presentationLength -= length ;\n break ;\n }\n }\n }\n return EC_Normal ;\n }",
        "hash": -4525874104093394205,
        "project": "debian",
        "size": 49,
        "slice": {
            "malloc": [
                [
                    25,
                    " switch ( * buf ) {\n"
                ],
                [
                    32,
                    " case DUL_TYPETRANSFERSYNTAX : subItem = ( DUL_SUBITEM * ) malloc ( sizeof ( DUL_SUBITEM ) ) ;\n"
                ],
                [
                    33,
                    " if ( subItem == NULL ) return EC_MemoryExhausted ;\n"
                ]
            ],
            "result": [
                [
                    25,
                    " switch ( * buf ) {\n"
                ],
                [
                    32,
                    " case DUL_TYPETRANSFERSYNTAX : subItem = ( DUL_SUBITEM * ) malloc ( sizeof ( DUL_SUBITEM ) ) ;\n"
                ],
                [
                    33,
                    " if ( subItem == NULL ) return EC_MemoryExhausted ;\n"
                ]
            ]
        }
    },
    {
        "code": "enum nss_status _nss_nis_getaliasbyname_r ( const char * name , struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n if ( name == NULL ) {\n * errnop = EINVAL ;\n return NSS_STATUS_UNAVAIL ;\n }\n size_t namlen = strlen ( name ) ;\n char name2 [ namlen + 1 ] ;\n char * domain ;\n if ( __builtin_expect ( yp_get_default_domain ( & domain ) , 0 ) ) return NSS_STATUS_UNAVAIL ;\n size_t i ;\n for ( i = 0 ;\n i < namlen ;\n ++ i ) name2 [ i ] = _tolower ( name [ i ] ) ;\n name2 [ i ] = '\\0' ;\n char * result ;\n int len ;\n int yperr = yp_match ( domain , \"mail.aliases\" , name2 , namlen , & result , & len ) ;\n if ( __builtin_expect ( yperr != YPERR_SUCCESS , 0 ) ) {\n enum nss_status retval = yperr2nss ( yperr ) ;\n if ( retval == NSS_STATUS_TRYAGAIN ) * errnop = errno ;\n return retval ;\n }\n if ( __builtin_expect ( ( size_t ) ( len + 1 ) > buflen , 0 ) ) {\n free ( result ) ;\n * errnop = ERANGE ;\n return NSS_STATUS_TRYAGAIN ;\n }\n char * p = strncpy ( buffer , result , len ) ;\n buffer [ len ] = '\\0' ;\n while ( isspace ( * p ) ) ++ p ;\n free ( result ) ;\n alias -> alias_local = 0 ;\n int parse_res = _nss_nis_parse_aliasent ( name , p , alias , buffer , buflen , errnop ) ;\n if ( __builtin_expect ( parse_res < 1 , 0 ) ) {\n if ( parse_res == - 1 ) return NSS_STATUS_TRYAGAIN ;\n else return NSS_STATUS_NOTFOUND ;\n }\n return NSS_STATUS_SUCCESS ;\n }",
        "hash": 3944119518966250431,
        "project": "debian",
        "size": 39,
        "slice": {
            "strncpy": [
                [
                    1,
                    "enum nss_status _nss_nis_getaliasbyname_r ( const char * name , struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n"
                ],
                [
                    17,
                    " int yperr = yp_match ( domain , \"mail.aliases\" , name2 , namlen , & result , & len ) ;\n"
                ],
                [
                    23,
                    " if ( __builtin_expect ( ( size_t ) ( len + 1 ) > buflen , 0 ) ) {\n"
                ],
                [
                    28,
                    " char * p = strncpy ( buffer , result , len ) ;\n"
                ],
                [
                    30,
                    " while ( isspace ( * p ) ) ++ p ;\n"
                ],
                [
                    31,
                    " free ( result ) ;\n"
                ],
                [
                    33,
                    " int parse_res = _nss_nis_parse_aliasent ( name , p , alias , buffer , buflen , errnop ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "enum nss_status _nss_nis_getaliasbyname_r ( const char * name , struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n"
                ],
                [
                    2,
                    " if ( name == NULL ) {\n"
                ],
                [
                    6,
                    " size_t namlen = strlen ( name ) ;\n"
                ],
                [
                    7,
                    " char name2 [ namlen + 1 ] ;\n"
                ],
                [
                    12,
                    " i < namlen ;\n"
                ],
                [
                    13,
                    " ++ i ) name2 [ i ] = _tolower ( name [ i ] ) ;\n"
                ],
                [
                    33,
                    " int parse_res = _nss_nis_parse_aliasent ( name , p , alias , buffer , buflen , errnop ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "enum nss_status _nss_nis_getaliasbyname_r ( const char * name , struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n"
                ],
                [
                    17,
                    " int yperr = yp_match ( domain , \"mail.aliases\" , name2 , namlen , & result , & len ) ;\n"
                ],
                [
                    23,
                    " if ( __builtin_expect ( ( size_t ) ( len + 1 ) > buflen , 0 ) ) {\n"
                ],
                [
                    24,
                    " free ( result ) ;\n"
                ],
                [
                    28,
                    " char * p = strncpy ( buffer , result , len ) ;\n"
                ],
                [
                    31,
                    " free ( result ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "enum nss_status _nss_nis_getaliasbyname_r ( const char * name , struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n"
                ],
                [
                    2,
                    " if ( name == NULL ) {\n"
                ],
                [
                    6,
                    " size_t namlen = strlen ( name ) ;\n"
                ],
                [
                    7,
                    " char name2 [ namlen + 1 ] ;\n"
                ],
                [
                    12,
                    " i < namlen ;\n"
                ],
                [
                    13,
                    " ++ i ) name2 [ i ] = _tolower ( name [ i ] ) ;\n"
                ],
                [
                    17,
                    " int yperr = yp_match ( domain , \"mail.aliases\" , name2 , namlen , & result , & len ) ;\n"
                ],
                [
                    23,
                    " if ( __builtin_expect ( ( size_t ) ( len + 1 ) > buflen , 0 ) ) {\n"
                ],
                [
                    24,
                    " free ( result ) ;\n"
                ],
                [
                    28,
                    " char * p = strncpy ( buffer , result , len ) ;\n"
                ],
                [
                    30,
                    " while ( isspace ( * p ) ) ++ p ;\n"
                ],
                [
                    31,
                    " free ( result ) ;\n"
                ],
                [
                    33,
                    " int parse_res = _nss_nis_parse_aliasent ( name , p , alias , buffer , buflen , errnop ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob ) {\n size_t dirlen = strlen ( directory ) ;\n void * stream = NULL ;\n struct globnames {\n struct globnames * next ;\n size_t count ;\n char * name [ 64 ] ;\n }\n ;\n # define INITIAL_COUNT sizeof ( init_names . name ) / sizeof ( init_names . name [ 0 ] ) struct globnames init_names ;\n struct globnames * names = & init_names ;\n struct globnames * names_alloca = & init_names ;\n size_t nfound = 0 ;\n size_t allocasize = sizeof ( init_names ) ;\n size_t cur = 0 ;\n int meta ;\n int save ;\n init_names . next = NULL ;\n init_names . count = INITIAL_COUNT ;\n meta = __glob_pattern_type ( pattern , ! ( flags & GLOB_NOESCAPE ) ) ;\n if ( meta == 0 && ( flags & ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) ) {\n flags |= GLOB_NOCHECK ;\n }\n else if ( meta == 0 ) {\n struct stat st ;\n struct_stat64 st64 ;\n size_t patlen = strlen ( pattern ) ;\n char * fullname = ( char * ) __alloca ( dirlen + 1 + patlen + 1 ) ;\n mempcpy ( mempcpy ( mempcpy ( fullname , directory , dirlen ) , \"/\" , 1 ) , pattern , patlen + 1 ) ;\n if ( ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_stat ) ( fullname , & st ) : __stat64 ( fullname , & st64 ) ) == 0 ) flags |= GLOB_NOCHECK ;\n }\n else {\n stream = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_opendir ) ( directory ) : opendir ( directory ) ) ;\n if ( stream == NULL ) {\n if ( errno != ENOTDIR && ( ( errfunc != NULL && ( * errfunc ) ( directory , errno ) ) || ( flags & GLOB_ERR ) ) ) return GLOB_ABORTED ;\n }\n else {\n # ifdef _LIBC int dfd = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? - 1 : dirfd ( ( DIR * ) stream ) ) ;\n # endif int fnm_flags = ( ( ! ( flags & GLOB_PERIOD ) ? FNM_PERIOD : 0 ) | ( ( flags & GLOB_NOESCAPE ) ? FNM_NOESCAPE : 0 ) # if defined _AMIGA || defined VMS | FNM_CASEFOLD # endif ) ;\n flags |= GLOB_MAGCHAR ;\n while ( 1 ) {\n const char * name ;\n size_t len ;\n # if defined _LIBC && ! defined COMPILE_GLOB64 struct dirent64 * d ;\n union {\n struct dirent64 d64 ;\n char room [ offsetof ( struct dirent64 , d_name [ 0 ] ) + NAME_MAX + 1 ] ;\n }\n d64buf ;\n if ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ) {\n struct dirent * d32 = ( * pglob -> gl_readdir ) ( stream ) ;\n if ( d32 != NULL ) {\n CONVERT_DIRENT_DIRENT64 ( & d64buf . d64 , d32 ) ;\n d = & d64buf . d64 ;\n }\n else d = NULL ;\n }\n else d = __readdir64 ( stream ) ;\n # else struct dirent * d = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( ( struct dirent * ) ( * pglob -> gl_readdir ) ( stream ) ) : __readdir ( stream ) ) ;\n # endif if ( d == NULL ) break ;\n if ( ! REAL_DIR_ENTRY ( d ) ) continue ;\n if ( ( flags & GLOB_ONLYDIR ) && ! DIRENT_MIGHT_BE_DIR ( d ) ) continue ;\n name = d -> d_name ;\n if ( fnmatch ( pattern , name , fnm_flags ) == 0 ) {\n if ( ! DIRENT_MIGHT_BE_SYMLINK ( d ) || link_exists_p ( dfd , directory , dirlen , name , pglob , flags ) ) {\n if ( cur == names -> count ) {\n struct globnames * newnames ;\n size_t count = names -> count * 2 ;\n size_t size = ( sizeof ( struct globnames ) + ( ( count - INITIAL_COUNT ) * sizeof ( char * ) ) ) ;\n allocasize += size ;\n if ( __libc_use_alloca ( allocasize ) ) newnames = names_alloca = __alloca ( size ) ;\n else if ( ( newnames = malloc ( size ) ) == NULL ) goto memory_error ;\n newnames -> count = count ;\n newnames -> next = names ;\n names = newnames ;\n cur = 0 ;\n }\n len = NAMLEN ( d ) ;\n names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n if ( names -> name [ cur ] == NULL ) goto memory_error ;\n * ( ( char * ) mempcpy ( names -> name [ cur ++ ] , name , len ) ) = '\\0' ;\n ++ nfound ;\n }\n }\n }\n }\n }\n if ( nfound == 0 && ( flags & GLOB_NOCHECK ) ) {\n size_t len = strlen ( pattern ) ;\n nfound = 1 ;\n names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n if ( names -> name [ cur ] == NULL ) goto memory_error ;\n * ( ( char * ) mempcpy ( names -> name [ cur ++ ] , pattern , len ) ) = '\\0' ;\n }\n int result = GLOB_NOMATCH ;\n if ( nfound != 0 ) {\n result = 0 ;\n char * * new_gl_pathv ;\n new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( pglob -> gl_pathc + pglob -> gl_offs + nfound + 1 ) * sizeof ( char * ) ) ;\n if ( new_gl_pathv == NULL ) {\n memory_error : while ( 1 ) {\n struct globnames * old = names ;\n for ( size_t i = 0 ;\n i < cur ;\n ++ i ) free ( names -> name [ i ] ) ;\n names = names -> next ;\n if ( names == NULL ) {\n assert ( old == & init_names ) ;\n break ;\n }\n cur = names -> count ;\n if ( old == names_alloca ) names_alloca = names ;\n else free ( old ) ;\n }\n result = GLOB_NOSPACE ;\n }\n else {\n while ( 1 ) {\n struct globnames * old = names ;\n for ( size_t i = 0 ;\n i < cur ;\n ++ i ) new_gl_pathv [ pglob -> gl_offs + pglob -> gl_pathc ++ ] = names -> name [ i ] ;\n names = names -> next ;\n if ( names == NULL ) {\n assert ( old == & init_names ) ;\n break ;\n }\n cur = names -> count ;\n if ( old == names_alloca ) names_alloca = names ;\n else free ( old ) ;\n }\n pglob -> gl_pathv = new_gl_pathv ;\n pglob -> gl_pathv [ pglob -> gl_offs + pglob -> gl_pathc ] = NULL ;\n pglob -> gl_flags = flags ;\n }\n }\n if ( stream != NULL ) {\n save = errno ;\n if ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ) ( * pglob -> gl_closedir ) ( stream ) ;\n else closedir ( stream ) ;\n __set_errno ( save ) ;\n }\n return result ;\n }",
        "hash": 4187524518637656726,
        "project": "debian",
        "size": 144,
        "slice": {
            "strlen": [
                [
                    1,
                    "static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob ) {\n"
                ],
                [
                    2,
                    " size_t dirlen = strlen ( directory ) ;\n"
                ],
                [
                    20,
                    " meta = __glob_pattern_type ( pattern , ! ( flags & GLOB_NOESCAPE ) ) ;\n"
                ],
                [
                    24,
                    " else if ( meta == 0 ) {\n"
                ],
                [
                    27,
                    " size_t patlen = strlen ( pattern ) ;\n"
                ],
                [
                    28,
                    " char * fullname = ( char * ) __alloca ( dirlen + 1 + patlen + 1 ) ;\n"
                ],
                [
                    29,
                    " mempcpy ( mempcpy ( mempcpy ( fullname , directory , dirlen ) , \"/\" , 1 ) , pattern , patlen + 1 ) ;\n"
                ],
                [
                    33,
                    " stream = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_opendir ) ( directory ) : opendir ( directory ) ) ;\n"
                ],
                [
                    64,
                    " if ( fnmatch ( pattern , name , fnm_flags ) == 0 ) {\n"
                ],
                [
                    65,
                    " if ( ! DIRENT_MIGHT_BE_SYMLINK ( d ) || link_exists_p ( dfd , directory , dirlen , name , pglob , flags ) ) {\n"
                ],
                [
                    88,
                    " if ( nfound == 0 && ( flags & GLOB_NOCHECK ) ) {\n"
                ],
                [
                    89,
                    " size_t len = strlen ( pattern ) ;\n"
                ],
                [
                    91,
                    " names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n"
                ],
                [
                    93,
                    " * ( ( char * ) mempcpy ( names -> name [ cur ++ ] , pattern , len ) ) = '\\0' ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob ) {\n"
                ],
                [
                    34,
                    " if ( stream == NULL ) {\n"
                ],
                [
                    66,
                    " if ( cur == names -> count ) {\n"
                ],
                [
                    70,
                    " allocasize += size ;\n"
                ],
                [
                    71,
                    " if ( __libc_use_alloca ( allocasize ) ) newnames = names_alloca = __alloca ( size ) ;\n"
                ],
                [
                    72,
                    " else if ( ( newnames = malloc ( size ) ) == NULL ) goto memory_error ;\n"
                ],
                [
                    73,
                    " newnames -> count = count ;\n"
                ],
                [
                    74,
                    " newnames -> next = names ;\n"
                ],
                [
                    75,
                    " names = newnames ;\n"
                ],
                [
                    76,
                    " cur = 0 ;\n"
                ],
                [
                    78,
                    " len = NAMLEN ( d ) ;\n"
                ],
                [
                    79,
                    " names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n"
                ],
                [
                    80,
                    " if ( names -> name [ cur ] == NULL ) goto memory_error ;\n"
                ],
                [
                    88,
                    " if ( nfound == 0 && ( flags & GLOB_NOCHECK ) ) {\n"
                ],
                [
                    89,
                    " size_t len = strlen ( pattern ) ;\n"
                ],
                [
                    91,
                    " names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n"
                ],
                [
                    92,
                    " if ( names -> name [ cur ] == NULL ) goto memory_error ;\n"
                ],
                [
                    102,
                    " struct globnames * old = names ;\n"
                ],
                [
                    103,
                    " for ( size_t i = 0 ;\n"
                ],
                [
                    104,
                    " i < cur ;\n"
                ],
                [
                    106,
                    " names = names -> next ;\n"
                ],
                [
                    107,
                    " if ( names == NULL ) {\n"
                ],
                [
                    115,
                    " result = GLOB_NOSPACE ;\n"
                ],
                [
                    137,
                    " if ( stream != NULL ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob ) {\n"
                ],
                [
                    104,
                    " i < cur ;\n"
                ],
                [
                    105,
                    " ++ i ) free ( names -> name [ i ] ) ;\n"
                ],
                [
                    112,
                    " if ( old == names_alloca ) names_alloca = names ;\n"
                ],
                [
                    113,
                    " else free ( old ) ;\n"
                ],
                [
                    129,
                    " if ( old == names_alloca ) names_alloca = names ;\n"
                ],
                [
                    130,
                    " else free ( old ) ;\n"
                ]
            ],
            "realloc": [
                [
                    1,
                    "static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob ) {\n"
                ],
                [
                    65,
                    " if ( ! DIRENT_MIGHT_BE_SYMLINK ( d ) || link_exists_p ( dfd , directory , dirlen , name , pglob , flags ) ) {\n"
                ],
                [
                    96,
                    " if ( nfound != 0 ) {\n"
                ],
                [
                    99,
                    " new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( pglob -> gl_pathc + pglob -> gl_offs + nfound + 1 ) * sizeof ( char * ) ) ;\n"
                ],
                [
                    100,
                    " if ( new_gl_pathv == NULL ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob ) {\n"
                ],
                [
                    2,
                    " size_t dirlen = strlen ( directory ) ;\n"
                ],
                [
                    20,
                    " meta = __glob_pattern_type ( pattern , ! ( flags & GLOB_NOESCAPE ) ) ;\n"
                ],
                [
                    24,
                    " else if ( meta == 0 ) {\n"
                ],
                [
                    27,
                    " size_t patlen = strlen ( pattern ) ;\n"
                ],
                [
                    28,
                    " char * fullname = ( char * ) __alloca ( dirlen + 1 + patlen + 1 ) ;\n"
                ],
                [
                    29,
                    " mempcpy ( mempcpy ( mempcpy ( fullname , directory , dirlen ) , \"/\" , 1 ) , pattern , patlen + 1 ) ;\n"
                ],
                [
                    33,
                    " stream = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_opendir ) ( directory ) : opendir ( directory ) ) ;\n"
                ],
                [
                    34,
                    " if ( stream == NULL ) {\n"
                ],
                [
                    64,
                    " if ( fnmatch ( pattern , name , fnm_flags ) == 0 ) {\n"
                ],
                [
                    65,
                    " if ( ! DIRENT_MIGHT_BE_SYMLINK ( d ) || link_exists_p ( dfd , directory , dirlen , name , pglob , flags ) ) {\n"
                ],
                [
                    66,
                    " if ( cur == names -> count ) {\n"
                ],
                [
                    70,
                    " allocasize += size ;\n"
                ],
                [
                    71,
                    " if ( __libc_use_alloca ( allocasize ) ) newnames = names_alloca = __alloca ( size ) ;\n"
                ],
                [
                    72,
                    " else if ( ( newnames = malloc ( size ) ) == NULL ) goto memory_error ;\n"
                ],
                [
                    73,
                    " newnames -> count = count ;\n"
                ],
                [
                    74,
                    " newnames -> next = names ;\n"
                ],
                [
                    75,
                    " names = newnames ;\n"
                ],
                [
                    76,
                    " cur = 0 ;\n"
                ],
                [
                    78,
                    " len = NAMLEN ( d ) ;\n"
                ],
                [
                    79,
                    " names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n"
                ],
                [
                    80,
                    " if ( names -> name [ cur ] == NULL ) goto memory_error ;\n"
                ],
                [
                    88,
                    " if ( nfound == 0 && ( flags & GLOB_NOCHECK ) ) {\n"
                ],
                [
                    89,
                    " size_t len = strlen ( pattern ) ;\n"
                ],
                [
                    91,
                    " names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n"
                ],
                [
                    92,
                    " if ( names -> name [ cur ] == NULL ) goto memory_error ;\n"
                ],
                [
                    93,
                    " * ( ( char * ) mempcpy ( names -> name [ cur ++ ] , pattern , len ) ) = '\\0' ;\n"
                ],
                [
                    96,
                    " if ( nfound != 0 ) {\n"
                ],
                [
                    99,
                    " new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( pglob -> gl_pathc + pglob -> gl_offs + nfound + 1 ) * sizeof ( char * ) ) ;\n"
                ],
                [
                    100,
                    " if ( new_gl_pathv == NULL ) {\n"
                ],
                [
                    102,
                    " struct globnames * old = names ;\n"
                ],
                [
                    103,
                    " for ( size_t i = 0 ;\n"
                ],
                [
                    104,
                    " i < cur ;\n"
                ],
                [
                    105,
                    " ++ i ) free ( names -> name [ i ] ) ;\n"
                ],
                [
                    106,
                    " names = names -> next ;\n"
                ],
                [
                    107,
                    " if ( names == NULL ) {\n"
                ],
                [
                    112,
                    " if ( old == names_alloca ) names_alloca = names ;\n"
                ],
                [
                    113,
                    " else free ( old ) ;\n"
                ],
                [
                    115,
                    " result = GLOB_NOSPACE ;\n"
                ],
                [
                    129,
                    " if ( old == names_alloca ) names_alloca = names ;\n"
                ],
                [
                    130,
                    " else free ( old ) ;\n"
                ],
                [
                    137,
                    " if ( stream != NULL ) {\n"
                ]
            ]
        }
    },
    {
        "code": "int # ifdef GLOB_ATTRIBUTE GLOB_ATTRIBUTE # endif glob ( pattern , flags , errfunc , pglob ) const char * pattern ;\n int flags ;\n int ( * errfunc ) ( const char * , int ) ;\n glob_t * pglob ;\n {\n const char * filename ;\n const char * dirname ;\n size_t dirlen ;\n int status ;\n size_t oldcount ;\n int meta ;\n int dirname_modified ;\n glob_t dirs ;\n if ( pattern == NULL || pglob == NULL || ( flags & ~ __GLOB_FLAGS ) != 0 ) {\n __set_errno ( EINVAL ) ;\n return - 1 ;\n }\n if ( ! ( flags & GLOB_DOOFFS ) ) pglob -> gl_offs = 0 ;\n if ( flags & GLOB_BRACE ) {\n const char * begin ;\n if ( flags & GLOB_NOESCAPE ) begin = strchr ( pattern , '{\n' ) ;\n else {\n begin = pattern ;\n while ( 1 ) {\n if ( * begin == '\\0' ) {\n begin = NULL ;\n break ;\n }\n if ( * begin == '\\\\' && begin [ 1 ] != '\\0' ) ++ begin ;\n else if ( * begin == '{\n' ) break ;\n ++ begin ;\n }\n }\n if ( begin != NULL ) {\n size_t firstc ;\n char * alt_start ;\n const char * p ;\n const char * next ;\n const char * rest ;\n size_t rest_len ;\n # ifdef __GNUC__ char onealt [ strlen ( pattern ) - 1 ] ;\n # else char * onealt = ( char * ) malloc ( strlen ( pattern ) - 1 ) ;\n if ( onealt == NULL ) {\n if ( ! ( flags & GLOB_APPEND ) ) {\n pglob -> gl_pathc = 0 ;\n pglob -> gl_pathv = NULL ;\n }\n return GLOB_NOSPACE ;\n }\n # endif alt_start = mempcpy ( onealt , pattern , begin - pattern ) ;\n next = next_brace_sub ( begin + 1 , flags ) ;\n if ( next == NULL ) {\n # ifndef __GNUC__ free ( onealt ) ;\n # endif return glob ( pattern , flags & ~ GLOB_BRACE , errfunc , pglob ) ;\n }\n rest = next ;\n while ( * rest != '}\n' ) {\n rest = next_brace_sub ( rest + 1 , flags ) ;\n if ( rest == NULL ) {\n # ifndef __GNUC__ free ( onealt ) ;\n # endif return glob ( pattern , flags & ~ GLOB_BRACE , errfunc , pglob ) ;\n }\n }\n rest_len = strlen ( ++ rest ) + 1 ;\n if ( ! ( flags & GLOB_APPEND ) ) {\n pglob -> gl_pathc = 0 ;\n pglob -> gl_pathv = NULL ;\n }\n firstc = pglob -> gl_pathc ;\n p = begin + 1 ;\n while ( 1 ) {\n int result ;\n mempcpy ( mempcpy ( alt_start , p , next - p ) , rest , rest_len ) ;\n result = glob ( onealt , ( ( flags & ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) | GLOB_APPEND ) , errfunc , pglob ) ;\n if ( result && result != GLOB_NOMATCH ) {\n # ifndef __GNUC__ free ( onealt ) ;\n # endif if ( ! ( flags & GLOB_APPEND ) ) {\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n }\n return result ;\n }\n if ( * next == '}\n' ) break ;\n p = next + 1 ;\n next = next_brace_sub ( p , flags ) ;\n assert ( next != NULL ) ;\n }\n # ifndef __GNUC__ free ( onealt ) ;\n # endif if ( pglob -> gl_pathc != firstc ) return 0 ;\n else if ( ! ( flags & ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) ) return GLOB_NOMATCH ;\n }\n }\n if ( ! ( flags & GLOB_APPEND ) ) {\n pglob -> gl_pathc = 0 ;\n if ( ! ( flags & GLOB_DOOFFS ) ) pglob -> gl_pathv = NULL ;\n else {\n size_t i ;\n pglob -> gl_pathv = ( char * * ) malloc ( ( pglob -> gl_offs + 1 ) * sizeof ( char * ) ) ;\n if ( pglob -> gl_pathv == NULL ) return GLOB_NOSPACE ;\n for ( i = 0 ;\n i <= pglob -> gl_offs ;\n ++ i ) pglob -> gl_pathv [ i ] = NULL ;\n }\n }\n oldcount = pglob -> gl_pathc + pglob -> gl_offs ;\n filename = strrchr ( pattern , '/' ) ;\n # if defined __MSDOS__ || defined WINDOWS32 if ( filename == NULL ) filename = strchr ( pattern , ':' ) ;\n # endif dirname_modified = 0 ;\n if ( filename == NULL ) {\n if ( ( flags & ( GLOB_TILDE | GLOB_TILDE_CHECK ) ) && pattern [ 0 ] == '~' ) {\n dirname = pattern ;\n dirlen = strlen ( pattern ) ;\n filename = NULL ;\n }\n else {\n if ( __builtin_expect ( pattern [ 0 ] == '\\0' , 0 ) ) {\n dirs . gl_pathv = NULL ;\n goto no_matches ;\n }\n filename = pattern ;\n # ifdef _AMIGA dirname = \"\" ;\n # else dirname = \".\" ;\n # endif dirlen = 0 ;\n }\n }\n else if ( filename == pattern || ( filename == pattern + 1 && pattern [ 0 ] == '\\\\' && ( flags & GLOB_NOESCAPE ) == 0 ) ) {\n dirname = \"/\" ;\n dirlen = 1 ;\n ++ filename ;\n }\n else {\n char * newp ;\n dirlen = filename - pattern ;\n # if defined __MSDOS__ || defined WINDOWS32 if ( * filename == ':' || ( filename > pattern + 1 && filename [ - 1 ] == ':' ) ) {\n char * drive_spec ;\n ++ dirlen ;\n drive_spec = ( char * ) __alloca ( dirlen + 1 ) ;\n * ( ( char * ) mempcpy ( drive_spec , pattern , dirlen ) ) = '\\0' ;\n if ( __glob_pattern_p ( drive_spec , ! ( flags & GLOB_NOESCAPE ) ) ) return GLOB_NOMATCH ;\n }\n # endif newp = ( char * ) __alloca ( dirlen + 1 ) ;\n * ( ( char * ) mempcpy ( newp , pattern , dirlen ) ) = '\\0' ;\n dirname = newp ;\n ++ filename ;\n if ( filename [ 0 ] == '\\0' # if defined __MSDOS__ || defined WINDOWS32 && dirname [ dirlen - 1 ] != ':' && ( dirlen < 3 || dirname [ dirlen - 2 ] != ':' || dirname [ dirlen - 1 ] != '/' ) # endif && dirlen > 1 ) {\n int orig_flags = flags ;\n if ( ! ( flags & GLOB_NOESCAPE ) && dirname [ dirlen - 1 ] == '\\\\' ) {\n char * p = ( char * ) & dirname [ dirlen - 1 ] ;\n while ( p > dirname && p [ - 1 ] == '\\\\' ) -- p ;\n if ( ( & dirname [ dirlen ] - p ) & 1 ) {\n * ( char * ) & dirname [ -- dirlen ] = '\\0' ;\n flags &= ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ;\n }\n }\n int val = glob ( dirname , flags | GLOB_MARK , errfunc , pglob ) ;\n if ( val == 0 ) pglob -> gl_flags = ( ( pglob -> gl_flags & ~ GLOB_MARK ) | ( flags & GLOB_MARK ) ) ;\n else if ( val == GLOB_NOMATCH && flags != orig_flags ) {\n dirs . gl_pathv = NULL ;\n flags = orig_flags ;\n oldcount = pglob -> gl_pathc + pglob -> gl_offs ;\n goto no_matches ;\n }\n return val ;\n }\n }\n # ifndef VMS if ( ( flags & ( GLOB_TILDE | GLOB_TILDE_CHECK ) ) && dirname [ 0 ] == '~' ) {\n if ( dirname [ 1 ] == '\\0' || dirname [ 1 ] == '/' || ( ! ( flags & GLOB_NOESCAPE ) && dirname [ 1 ] == '\\\\' && ( dirname [ 2 ] == '\\0' || dirname [ 2 ] == '/' ) ) ) {\n const char * home_dir = getenv ( \"HOME\" ) ;\n # ifdef _AMIGA if ( home_dir == NULL || home_dir [ 0 ] == '\\0' ) home_dir = \"SYS:\" ;\n # else # ifdef WINDOWS32 if ( home_dir == NULL || home_dir [ 0 ] == '\\0' ) home_dir = \"c:/users/default\" ;\n # else if ( home_dir == NULL || home_dir [ 0 ] == '\\0' ) {\n int success ;\n char * name ;\n size_t buflen = GET_LOGIN_NAME_MAX ( ) + 1 ;\n if ( buflen == 0 ) buflen = 20 ;\n name = ( char * ) __alloca ( buflen ) ;\n success = getlogin_r ( name , buflen ) == 0 ;\n if ( success ) {\n struct passwd * p ;\n # if defined HAVE_GETPWNAM_R || defined _LIBC long int pwbuflen = GETPW_R_SIZE_MAX ( ) ;\n char * pwtmpbuf ;\n struct passwd pwbuf ;\n int save = errno ;\n # ifndef _LIBC if ( pwbuflen == - 1 ) pwbuflen = 1024 ;\n # endif pwtmpbuf = ( char * ) __alloca ( pwbuflen ) ;\n while ( getpwnam_r ( name , & pwbuf , pwtmpbuf , pwbuflen , & p ) != 0 ) {\n if ( errno != ERANGE ) {\n p = NULL ;\n break ;\n }\n # ifdef _LIBC pwtmpbuf = extend_alloca ( pwtmpbuf , pwbuflen , 2 * pwbuflen ) ;\n # else pwbuflen *= 2 ;\n pwtmpbuf = ( char * ) __alloca ( pwbuflen ) ;\n # endif __set_errno ( save ) ;\n }\n # else p = getpwnam ( name ) ;\n # endif if ( p != NULL ) home_dir = p -> pw_dir ;\n }\n }\n if ( home_dir == NULL || home_dir [ 0 ] == '\\0' ) {\n if ( flags & GLOB_TILDE_CHECK ) return GLOB_NOMATCH ;\n else home_dir = \"~\" ;\n }\n # endif # endif if ( dirname [ 1 ] == '\\0' ) {\n dirname = home_dir ;\n dirlen = strlen ( dirname ) ;\n }\n else {\n char * newp ;\n size_t home_len = strlen ( home_dir ) ;\n newp = ( char * ) __alloca ( home_len + dirlen ) ;\n mempcpy ( mempcpy ( newp , home_dir , home_len ) , & dirname [ 1 ] , dirlen ) ;\n dirname = newp ;\n dirlen += home_len - 1 ;\n }\n dirname_modified = 1 ;\n }\n # if ! defined _AMIGA && ! defined WINDOWS32 else {\n char * end_name = strchr ( dirname , '/' ) ;\n const char * user_name ;\n const char * home_dir ;\n char * unescape = NULL ;\n if ( ! ( flags & GLOB_NOESCAPE ) ) {\n if ( end_name == NULL ) {\n unescape = strchr ( dirname , '\\\\' ) ;\n if ( unescape ) end_name = strchr ( unescape , '\\0' ) ;\n }\n else unescape = memchr ( dirname , '\\\\' , end_name - dirname ) ;\n }\n if ( end_name == NULL ) user_name = dirname + 1 ;\n else {\n char * newp ;\n newp = ( char * ) __alloca ( end_name - dirname ) ;\n if ( unescape != NULL ) {\n char * p = mempcpy ( newp , dirname + 1 , unescape - dirname - 1 ) ;\n char * q = unescape ;\n while ( * q != '\\0' ) {\n if ( * q == '\\\\' ) {\n if ( q [ 1 ] == '\\0' ) {\n if ( filename == NULL ) * p ++ = '\\\\' ;\n break ;\n }\n ++ q ;\n }\n * p ++ = * q ++ ;\n }\n * p = '\\0' ;\n }\n else * ( ( char * ) mempcpy ( newp , dirname + 1 , end_name - dirname ) ) = '\\0' ;\n user_name = newp ;\n }\n {\n struct passwd * p ;\n # if defined HAVE_GETPWNAM_R || defined _LIBC long int buflen = GETPW_R_SIZE_MAX ( ) ;\n char * pwtmpbuf ;\n struct passwd pwbuf ;\n int save = errno ;\n # ifndef _LIBC if ( buflen == - 1 ) buflen = 1024 ;\n # endif pwtmpbuf = ( char * ) __alloca ( buflen ) ;\n while ( getpwnam_r ( user_name , & pwbuf , pwtmpbuf , buflen , & p ) != 0 ) {\n if ( errno != ERANGE ) {\n p = NULL ;\n break ;\n }\n # ifdef _LIBC pwtmpbuf = extend_alloca ( pwtmpbuf , buflen , 2 * buflen ) ;\n # else buflen *= 2 ;\n pwtmpbuf = __alloca ( buflen ) ;\n # endif __set_errno ( save ) ;\n }\n # else p = getpwnam ( user_name ) ;\n # endif if ( p != NULL ) home_dir = p -> pw_dir ;\n else home_dir = NULL ;\n }\n if ( home_dir != NULL ) {\n char * newp ;\n size_t home_len = strlen ( home_dir ) ;\n size_t rest_len = end_name == NULL ? 0 : strlen ( end_name ) ;\n newp = ( char * ) __alloca ( home_len + rest_len + 1 ) ;\n * ( ( char * ) mempcpy ( mempcpy ( newp , home_dir , home_len ) , end_name , rest_len ) ) = '\\0' ;\n dirname = newp ;\n dirlen = home_len + rest_len ;\n dirname_modified = 1 ;\n }\n else if ( flags & GLOB_TILDE_CHECK ) return GLOB_NOMATCH ;\n }\n # endif }\n # endif if ( filename == NULL ) {\n struct stat st ;\n struct_stat64 st64 ;\n if ( ( flags & GLOB_NOCHECK ) || ( ( ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ) ? ( ( * pglob -> gl_stat ) ( dirname , & st ) == 0 && S_ISDIR ( st . st_mode ) ) : ( __stat64 ( dirname , & st64 ) == 0 && S_ISDIR ( st64 . st_mode ) ) ) ) ) {\n int newcount = pglob -> gl_pathc + pglob -> gl_offs ;\n char * * new_gl_pathv ;\n new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( newcount + 1 + 1 ) * sizeof ( char * ) ) ;\n if ( new_gl_pathv == NULL ) {\n nospace : free ( pglob -> gl_pathv ) ;\n pglob -> gl_pathv = NULL ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n pglob -> gl_pathv = new_gl_pathv ;\n if ( flags & GLOB_MARK ) {\n char * p ;\n pglob -> gl_pathv [ newcount ] = malloc ( dirlen + 2 ) ;\n if ( pglob -> gl_pathv [ newcount ] == NULL ) goto nospace ;\n p = mempcpy ( pglob -> gl_pathv [ newcount ] , dirname , dirlen ) ;\n p [ 0 ] = '/' ;\n p [ 1 ] = '\\0' ;\n }\n else {\n pglob -> gl_pathv [ newcount ] = strdup ( dirname ) ;\n if ( pglob -> gl_pathv [ newcount ] == NULL ) goto nospace ;\n }\n pglob -> gl_pathv [ ++ newcount ] = NULL ;\n ++ pglob -> gl_pathc ;\n pglob -> gl_flags = flags ;\n return 0 ;\n }\n return GLOB_NOMATCH ;\n }\n meta = __glob_pattern_type ( dirname , ! ( flags & GLOB_NOESCAPE ) ) ;\n if ( meta & 5 ) {\n size_t i ;\n if ( ! ( flags & GLOB_NOESCAPE ) && dirlen > 0 && dirname [ dirlen - 1 ] == '\\\\' ) {\n char * p = ( char * ) & dirname [ dirlen - 1 ] ;\n while ( p > dirname && p [ - 1 ] == '\\\\' ) -- p ;\n if ( ( & dirname [ dirlen ] - p ) & 1 ) * ( char * ) & dirname [ -- dirlen ] = '\\0' ;\n }\n if ( __builtin_expect ( ( flags & GLOB_ALTDIRFUNC ) != 0 , 0 ) ) {\n dirs . gl_opendir = pglob -> gl_opendir ;\n dirs . gl_readdir = pglob -> gl_readdir ;\n dirs . gl_closedir = pglob -> gl_closedir ;\n dirs . gl_stat = pglob -> gl_stat ;\n dirs . gl_lstat = pglob -> gl_lstat ;\n }\n status = glob ( dirname , ( ( flags & ( GLOB_ERR | GLOB_NOESCAPE | GLOB_ALTDIRFUNC ) ) | GLOB_NOSORT | GLOB_ONLYDIR ) , errfunc , & dirs ) ;\n if ( status != 0 ) {\n if ( ( flags & GLOB_NOCHECK ) == 0 || status != GLOB_NOMATCH ) return status ;\n goto no_matches ;\n }\n for ( i = 0 ;\n i < dirs . gl_pathc ;\n ++ i ) {\n int old_pathc ;\n # ifdef SHELL {\n extern int interrupt_state ;\n if ( interrupt_state ) {\n globfree ( & dirs ) ;\n return GLOB_ABORTED ;\n }\n }\n # endif old_pathc = pglob -> gl_pathc ;\n status = glob_in_dir ( filename , dirs . gl_pathv [ i ] , ( ( flags | GLOB_APPEND ) & ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ) , errfunc , pglob ) ;\n if ( status == GLOB_NOMATCH ) continue ;\n if ( status != 0 ) {\n globfree ( & dirs ) ;\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return status ;\n }\n if ( prefix_array ( dirs . gl_pathv [ i ] , & pglob -> gl_pathv [ old_pathc + pglob -> gl_offs ] , pglob -> gl_pathc - old_pathc ) ) {\n globfree ( & dirs ) ;\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n }\n flags |= GLOB_MAGCHAR ;\n if ( pglob -> gl_pathc + pglob -> gl_offs == oldcount ) {\n no_matches : if ( flags & GLOB_NOCHECK ) {\n int newcount = pglob -> gl_pathc + pglob -> gl_offs ;\n char * * new_gl_pathv ;\n new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( newcount + 2 ) * sizeof ( char * ) ) ;\n if ( new_gl_pathv == NULL ) {\n globfree ( & dirs ) ;\n return GLOB_NOSPACE ;\n }\n pglob -> gl_pathv = new_gl_pathv ;\n pglob -> gl_pathv [ newcount ] = __strdup ( pattern ) ;\n if ( pglob -> gl_pathv [ newcount ] == NULL ) {\n globfree ( & dirs ) ;\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n ++ pglob -> gl_pathc ;\n ++ newcount ;\n pglob -> gl_pathv [ newcount ] = NULL ;\n pglob -> gl_flags = flags ;\n }\n else {\n globfree ( & dirs ) ;\n return GLOB_NOMATCH ;\n }\n }\n globfree ( & dirs ) ;\n }\n else {\n int old_pathc = pglob -> gl_pathc ;\n int orig_flags = flags ;\n if ( meta & 2 ) {\n char * p = strchr ( dirname , '\\\\' ) , * q ;\n q = p ;\n do {\n if ( * p == '\\\\' ) {\n * q = * ++ p ;\n -- dirlen ;\n }\n else * q = * p ;\n ++ q ;\n }\n while ( * p ++ != '\\0' ) ;\n dirname_modified = 1 ;\n }\n if ( dirname_modified ) flags &= ~ ( GLOB_NOCHECK | GLOB_NOMAGIC ) ;\n status = glob_in_dir ( filename , dirname , flags , errfunc , pglob ) ;\n if ( status != 0 ) {\n if ( status == GLOB_NOMATCH && flags != orig_flags && pglob -> gl_pathc + pglob -> gl_offs == oldcount ) {\n dirs . gl_pathv = NULL ;\n flags = orig_flags ;\n goto no_matches ;\n }\n return status ;\n }\n if ( dirlen > 0 ) {\n if ( prefix_array ( dirname , & pglob -> gl_pathv [ old_pathc + pglob -> gl_offs ] , pglob -> gl_pathc - old_pathc ) ) {\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n }\n }\n if ( flags & GLOB_MARK ) {\n size_t i ;\n struct stat st ;\n struct_stat64 st64 ;\n for ( i = oldcount ;\n i < pglob -> gl_pathc + pglob -> gl_offs ;\n ++ i ) if ( ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( ( * pglob -> gl_stat ) ( pglob -> gl_pathv [ i ] , & st ) == 0 && S_ISDIR ( st . st_mode ) ) : ( __stat64 ( pglob -> gl_pathv [ i ] , & st64 ) == 0 && S_ISDIR ( st64 . st_mode ) ) ) ) {\n size_t len = strlen ( pglob -> gl_pathv [ i ] ) + 2 ;\n char * new = realloc ( pglob -> gl_pathv [ i ] , len ) ;\n if ( new == NULL ) {\n globfree ( pglob ) ;\n pglob -> gl_pathc = 0 ;\n return GLOB_NOSPACE ;\n }\n strcpy ( & new [ len - 2 ] , \"/\" ) ;\n pglob -> gl_pathv [ i ] = new ;\n }\n }\n if ( ! ( flags & GLOB_NOSORT ) ) {\n qsort ( & pglob -> gl_pathv [ oldcount ] , pglob -> gl_pathc + pglob -> gl_offs - oldcount , sizeof ( char * ) , collated_compare ) ;\n }\n return 0 ;\n }",
        "hash": 4187524518637656726,
        "project": "debian",
        "size": 458,
        "slice": {
            "strchr": [
                [
                    1,
                    "int # ifdef GLOB_ATTRIBUTE GLOB_ATTRIBUTE # endif glob ( pattern , flags , errfunc , pglob ) const char * pattern ;\n"
                ],
                [
                    210,
                    " dirlen = strlen ( dirname ) ;\n"
                ],
                [
                    223,
                    " char * end_name = strchr ( dirname , '/' ) ;\n"
                ],
                [
                    324,
                    " meta = __glob_pattern_type ( dirname , ! ( flags & GLOB_NOESCAPE ) ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "int # ifdef GLOB_ATTRIBUTE GLOB_ATTRIBUTE # endif glob ( pattern , flags , errfunc , pglob ) const char * pattern ;\n"
                ],
                [
                    209,
                    " dirname = home_dir ;\n"
                ],
                [
                    210,
                    " dirlen = strlen ( dirname ) ;\n"
                ],
                [
                    223,
                    " char * end_name = strchr ( dirname , '/' ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int # ifdef GLOB_ATTRIBUTE GLOB_ATTRIBUTE # endif glob ( pattern , flags , errfunc , pglob ) const char * pattern ;\n"
                ],
                [
                    209,
                    " dirname = home_dir ;\n"
                ],
                [
                    210,
                    " dirlen = strlen ( dirname ) ;\n"
                ],
                [
                    223,
                    " char * end_name = strchr ( dirname , '/' ) ;\n"
                ],
                [
                    324,
                    " meta = __glob_pattern_type ( dirname , ! ( flags & GLOB_NOESCAPE ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void save_config ( struct recvbuf * rbufp , int restrict_mask ) {\n char reply [ 128 ] ;\n # ifdef SAVECONFIG char filespec [ 128 ] ;\n char filename [ 128 ] ;\n char fullpath [ 512 ] ;\n const char savedconfig_eq [ ] = \"savedconfig=\" ;\n char savedconfig [ sizeof ( savedconfig_eq ) + sizeof ( filename ) ] ;\n time_t now ;\n int fd ;\n FILE * fptr ;\n # endif if ( RES_NOMODIFY & restrict_mask ) {\n snprintf ( reply , sizeof ( reply ) , \"saveconfig prohibited by restrict ... nomodify\" ) ;\n ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n ctl_flushpkt ( 0 ) ;\n NLOG ( NLOG_SYSINFO ) msyslog ( LOG_NOTICE , \"saveconfig from %s rejected due to nomodify restriction\" , stoa ( & rbufp -> recv_srcadr ) ) ;\n sys_restricted ++ ;\n return ;\n }\n # ifdef SAVECONFIG if ( NULL == saveconfigdir ) {\n snprintf ( reply , sizeof ( reply ) , \"saveconfig prohibited, no saveconfigdir configured\" ) ;\n ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n ctl_flushpkt ( 0 ) ;\n NLOG ( NLOG_SYSINFO ) msyslog ( LOG_NOTICE , \"saveconfig from %s rejected, no saveconfigdir\" , stoa ( & rbufp -> recv_srcadr ) ) ;\n return ;\n }\n if ( 0 == reqend - reqpt ) return ;\n strlcpy ( filespec , reqpt , sizeof ( filespec ) ) ;\n time ( & now ) ;\n if ( 0 == strftime ( filename , sizeof ( filename ) , filespec , localtime ( & now ) ) ) strlcpy ( filename , filespec , sizeof ( filename ) ) ;\n if ( strchr ( filename , '\\\\' ) || strchr ( filename , '/' ) ) {\n snprintf ( reply , sizeof ( reply ) , \"saveconfig does not allow directory in filename\" ) ;\n ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n ctl_flushpkt ( 0 ) ;\n msyslog ( LOG_NOTICE , \"saveconfig with path from %s rejected\" , stoa ( & rbufp -> recv_srcadr ) ) ;\n return ;\n }\n snprintf ( fullpath , sizeof ( fullpath ) , \"%s%s\" , saveconfigdir , filename ) ;\n fd = open ( fullpath , O_CREAT | O_TRUNC | O_WRONLY , S_IRUSR | S_IWUSR ) ;\n if ( - 1 == fd ) fptr = NULL ;\n else fptr = fdopen ( fd , \"w\" ) ;\n if ( NULL == fptr || - 1 == dump_all_config_trees ( fptr , 1 ) ) {\n snprintf ( reply , sizeof ( reply ) , \"Unable to save configuration to file %s\" , filename ) ;\n msyslog ( LOG_ERR , \"saveconfig %s from %s failed\" , filename , stoa ( & rbufp -> recv_srcadr ) ) ;\n }\n else {\n snprintf ( reply , sizeof ( reply ) , \"Configuration saved to %s\" , filename ) ;\n msyslog ( LOG_NOTICE , \"Configuration saved to %s (requested by %s)\" , fullpath , stoa ( & rbufp -> recv_srcadr ) ) ;\n snprintf ( savedconfig , sizeof ( savedconfig ) , \"%s%s\" , savedconfig_eq , filename ) ;\n set_sys_var ( savedconfig , strlen ( savedconfig ) + 1 , RO ) ;\n }\n if ( NULL != fptr ) fclose ( fptr ) ;\n # else snprintf ( reply , sizeof ( reply ) , \"saveconfig unavailable, configured with --disable-saveconfig\" ) ;\n # endif ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n ctl_flushpkt ( 0 ) ;\n }",
        "hash": -6068976579504840746,
        "project": "debian",
        "size": 55,
        "slice": {
            "strlen": [
                [
                    1,
                    "void save_config ( struct recvbuf * rbufp , int restrict_mask ) {\n"
                ],
                [
                    12,
                    " snprintf ( reply , sizeof ( reply ) , \"saveconfig prohibited by restrict ... nomodify\" ) ;\n"
                ],
                [
                    13,
                    " ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void save_config ( struct recvbuf * rbufp , int restrict_mask ) {\n"
                ],
                [
                    12,
                    " snprintf ( reply , sizeof ( reply ) , \"saveconfig prohibited by restrict ... nomodify\" ) ;\n"
                ],
                [
                    13,
                    " ctl_putdata ( reply , strlen ( reply ) , 0 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void EVP_EncodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n int i , j ;\n unsigned int total = 0 ;\n * outl = 0 ;\n if ( inl <= 0 ) return ;\n OPENSSL_assert ( ctx -> length <= ( int ) sizeof ( ctx -> enc_data ) ) ;\n if ( ( ctx -> num + inl ) < ctx -> length ) {\n memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , inl ) ;\n ctx -> num += inl ;\n return ;\n }\n if ( ctx -> num != 0 ) {\n i = ctx -> length - ctx -> num ;\n memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , i ) ;\n in += i ;\n inl -= i ;\n j = EVP_EncodeBlock ( out , ctx -> enc_data , ctx -> length ) ;\n ctx -> num = 0 ;\n out += j ;\n * ( out ++ ) = '\\n' ;\n * out = '\\0' ;\n total = j + 1 ;\n }\n while ( inl >= ctx -> length ) {\n j = EVP_EncodeBlock ( out , in , ctx -> length ) ;\n in += ctx -> length ;\n inl -= ctx -> length ;\n out += j ;\n * ( out ++ ) = '\\n' ;\n * out = '\\0' ;\n total += j + 1 ;\n }\n if ( inl != 0 ) memcpy ( & ( ctx -> enc_data [ 0 ] ) , in , inl ) ;\n ctx -> num = inl ;\n * outl = total ;\n }",
        "hash": 5653549006541675258,
        "project": "debian",
        "size": 36,
        "slice": {
            "memcpy": [
                [
                    1,
                    "void EVP_EncodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n"
                ],
                [
                    5,
                    " if ( inl <= 0 ) return ;\n"
                ],
                [
                    7,
                    " if ( ( ctx -> num + inl ) < ctx -> length ) {\n"
                ],
                [
                    8,
                    " memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , inl ) ;\n"
                ],
                [
                    9,
                    " ctx -> num += inl ;\n"
                ],
                [
                    12,
                    " if ( ctx -> num != 0 ) {\n"
                ],
                [
                    13,
                    " i = ctx -> length - ctx -> num ;\n"
                ],
                [
                    14,
                    " memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , i ) ;\n"
                ],
                [
                    15,
                    " in += i ;\n"
                ],
                [
                    16,
                    " inl -= i ;\n"
                ],
                [
                    17,
                    " j = EVP_EncodeBlock ( out , ctx -> enc_data , ctx -> length ) ;\n"
                ],
                [
                    26,
                    " in += ctx -> length ;\n"
                ],
                [
                    33,
                    " if ( inl != 0 ) memcpy ( & ( ctx -> enc_data [ 0 ] ) , in , inl ) ;\n"
                ],
                [
                    34,
                    " ctx -> num = inl ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void EVP_EncodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n"
                ],
                [
                    5,
                    " if ( inl <= 0 ) return ;\n"
                ],
                [
                    7,
                    " if ( ( ctx -> num + inl ) < ctx -> length ) {\n"
                ],
                [
                    8,
                    " memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , inl ) ;\n"
                ],
                [
                    9,
                    " ctx -> num += inl ;\n"
                ],
                [
                    12,
                    " if ( ctx -> num != 0 ) {\n"
                ],
                [
                    13,
                    " i = ctx -> length - ctx -> num ;\n"
                ],
                [
                    14,
                    " memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , i ) ;\n"
                ],
                [
                    15,
                    " in += i ;\n"
                ],
                [
                    16,
                    " inl -= i ;\n"
                ],
                [
                    17,
                    " j = EVP_EncodeBlock ( out , ctx -> enc_data , ctx -> length ) ;\n"
                ],
                [
                    26,
                    " in += ctx -> length ;\n"
                ],
                [
                    33,
                    " if ( inl != 0 ) memcpy ( & ( ctx -> enc_data [ 0 ] ) , in , inl ) ;\n"
                ],
                [
                    34,
                    " ctx -> num = inl ;\n"
                ]
            ]
        }
    },
    {
        "code": "static uint64_t mpc8544_guts_read ( void * opaque , hwaddr addr , unsigned size ) {\n uint32_t value = 0 ;\n CPUPPCState * env = cpu_single_env ;\n addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;\n switch ( addr ) {\n case MPC8544_GUTS_ADDR_PVR : value = env -> spr [ SPR_PVR ] ;\n break ;\n case MPC8544_GUTS_ADDR_SVR : value = env -> spr [ SPR_E500_SVR ] ;\n break ;\n default : fprintf ( stderr , \"guts: Unknown register read: %x\\n\" , ( int ) addr ) ;\n break ;\n }\n return value ;\n }",
        "hash": -4978182697885785366,
        "project": "debian",
        "size": 14,
        "slice": {
            "fprintf": [
                [
                    1,
                    "static uint64_t mpc8544_guts_read ( void * opaque , hwaddr addr , unsigned size ) {\n"
                ],
                [
                    4,
                    " addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;\n"
                ],
                [
                    5,
                    " switch ( addr ) {\n"
                ],
                [
                    10,
                    " default : fprintf ( stderr , \"guts: Unknown register read: %x\\n\" , ( int ) addr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static uint64_t mpc8544_guts_read ( void * opaque , hwaddr addr , unsigned size ) {\n"
                ],
                [
                    4,
                    " addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;\n"
                ],
                [
                    5,
                    " switch ( addr ) {\n"
                ],
                [
                    10,
                    " default : fprintf ( stderr , \"guts: Unknown register read: %x\\n\" , ( int ) addr ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int pxa2xx_pwrmode_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n PXA2xxState * s = ( PXA2xxState * ) ri -> opaque ;\n static const char * pwrmode [ 8 ] = {\n \"Normal\" , \"Idle\" , \"Deep-idle\" , \"Standby\" , \"Sleep\" , \"reserved (!)\" , \"reserved (!)\" , \"Deep-sleep\" , }\n ;\n if ( value & 8 ) {\n printf ( \"%s: CPU voltage change attempt\\n\" , __func__ ) ;\n }\n switch ( value & 7 ) {\n case 0 : break ;\n case 1 : if ( ! ( s -> cm_regs [ CCCR >> 2 ] & ( 1 << 31 ) ) ) {\n cpu_interrupt ( CPU ( s -> cpu ) , CPU_INTERRUPT_HALT ) ;\n break ;\n }\n case 2 : cpu_interrupt ( CPU ( s -> cpu ) , CPU_INTERRUPT_HALT ) ;\n s -> pm_regs [ RCSR >> 2 ] |= 0x8 ;\n goto message ;\n case 3 : s -> cpu -> env . uncached_cpsr = ARM_CPU_MODE_SVC | CPSR_A | CPSR_F | CPSR_I ;\n s -> cpu -> env . cp15 . c1_sys = 0 ;\n s -> cpu -> env . cp15 . c1_coproc = 0 ;\n s -> cpu -> env . cp15 . c2_base0 = 0 ;\n s -> cpu -> env . cp15 . c3 = 0 ;\n s -> pm_regs [ PSSR >> 2 ] |= 0x8 ;\n s -> pm_regs [ RCSR >> 2 ] |= 0x8 ;\n memset ( s -> cpu -> env . regs , 0 , 4 * 15 ) ;\n s -> cpu -> env . regs [ 15 ] = s -> pm_regs [ PSPR >> 2 ] ;\n # if 0 buffer = 0xe59ff000 ;\n cpu_physical_memory_write ( 0 , & buffer , 4 ) ;\n buffer = s -> pm_regs [ PSPR >> 2 ] ;\n cpu_physical_memory_write ( 8 , & buffer , 4 ) ;\n # endif cpu_interrupt ( CPU ( arm_env_get_cpu ( cpu_single_env ) ) , CPU_INTERRUPT_HALT ) ;\n goto message ;\n default : message : printf ( \"%s: machine entered %s mode\\n\" , __func__ , pwrmode [ value & 7 ] ) ;\n }\n return 0 ;\n }",
        "hash": 6302861533225984845,
        "project": "debian",
        "size": 36,
        "slice": {
            "memset": [
                [
                    1,
                    "static int pxa2xx_pwrmode_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n"
                ],
                [
                    9,
                    " switch ( value & 7 ) {\n"
                ],
                [
                    25,
                    " memset ( s -> cpu -> env . regs , 0 , 4 * 15 ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "static int pxa2xx_pwrmode_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n"
                ],
                [
                    6,
                    " if ( value & 8 ) {\n"
                ],
                [
                    7,
                    " printf ( \"%s: CPU voltage change attempt\\n\" , __func__ ) ;\n"
                ],
                [
                    9,
                    " switch ( value & 7 ) {\n"
                ],
                [
                    11,
                    " case 1 : if ( ! ( s -> cm_regs [ CCCR >> 2 ] & ( 1 << 31 ) ) ) {\n"
                ],
                [
                    33,
                    " default : message : printf ( \"%s: machine entered %s mode\\n\" , __func__ , pwrmode [ value & 7 ] ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int pxa2xx_pwrmode_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n"
                ],
                [
                    6,
                    " if ( value & 8 ) {\n"
                ],
                [
                    7,
                    " printf ( \"%s: CPU voltage change attempt\\n\" , __func__ ) ;\n"
                ],
                [
                    9,
                    " switch ( value & 7 ) {\n"
                ],
                [
                    11,
                    " case 1 : if ( ! ( s -> cm_regs [ CCCR >> 2 ] & ( 1 << 31 ) ) ) {\n"
                ],
                [
                    25,
                    " memset ( s -> cpu -> env . regs , 0 , 4 * 15 ) ;\n"
                ],
                [
                    33,
                    " default : message : printf ( \"%s: machine entered %s mode\\n\" , __func__ , pwrmode [ value & 7 ] ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int64_t cpu_get_icount ( void ) {\n int64_t icount ;\n CPUArchState * env = cpu_single_env ;\n icount = qemu_icount ;\n if ( env ) {\n if ( ! can_do_io ( env ) ) {\n fprintf ( stderr , \"Bad clock read\\n\" ) ;\n }\n icount -= ( env -> icount_decr . u16 . low + env -> icount_extra ) ;\n }\n return qemu_icount_bias + ( icount << icount_time_shift ) ;\n }",
        "hash": -5420171864670538459,
        "project": "debian",
        "size": 12,
        "slice": {
            "fprintf": [
                [
                    1,
                    "int64_t cpu_get_icount ( void ) {\n"
                ],
                [
                    6,
                    " if ( ! can_do_io ( env ) ) {\n"
                ],
                [
                    7,
                    " fprintf ( stderr , \"Bad clock read\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int64_t cpu_get_icount ( void ) {\n"
                ],
                [
                    6,
                    " if ( ! can_do_io ( env ) ) {\n"
                ],
                [
                    7,
                    " fprintf ( stderr , \"Bad clock read\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void * qemu_kvm_cpu_thread_fn ( void * arg ) {\n CPUState * cpu = arg ;\n int r ;\n qemu_mutex_lock ( & qemu_global_mutex ) ;\n qemu_thread_get_self ( cpu -> thread ) ;\n cpu -> thread_id = qemu_get_thread_id ( ) ;\n cpu_single_env = cpu -> env_ptr ;\n r = kvm_init_vcpu ( cpu ) ;\n if ( r < 0 ) {\n fprintf ( stderr , \"kvm_init_vcpu failed: %s\\n\" , strerror ( - r ) ) ;\n exit ( 1 ) ;\n }\n qemu_kvm_init_cpu_signals ( cpu ) ;\n cpu -> created = true ;\n qemu_cond_signal ( & qemu_cpu_cond ) ;\n while ( 1 ) {\n if ( cpu_can_run ( cpu ) ) {\n r = kvm_cpu_exec ( cpu ) ;\n if ( r == EXCP_DEBUG ) {\n cpu_handle_guest_debug ( cpu ) ;\n }\n }\n qemu_kvm_wait_io_event ( cpu ) ;\n }\n return NULL ;\n }",
        "hash": -5420171864670538459,
        "project": "debian",
        "size": 26,
        "slice": {
            "strerror": [
                [
                    1,
                    "static void * qemu_kvm_cpu_thread_fn ( void * arg ) {\n"
                ],
                [
                    9,
                    " if ( r < 0 ) {\n"
                ],
                [
                    10,
                    " fprintf ( stderr , \"kvm_init_vcpu failed: %s\\n\" , strerror ( - r ) ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void * qemu_kvm_cpu_thread_fn ( void * arg ) {\n"
                ],
                [
                    9,
                    " if ( r < 0 ) {\n"
                ],
                [
                    10,
                    " fprintf ( stderr , \"kvm_init_vcpu failed: %s\\n\" , strerror ( - r ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void * qemu_kvm_cpu_thread_fn ( void * arg ) {\n"
                ],
                [
                    9,
                    " if ( r < 0 ) {\n"
                ],
                [
                    10,
                    " fprintf ( stderr , \"kvm_init_vcpu failed: %s\\n\" , strerror ( - r ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int s_aes_process ( stream_state * ss , stream_cursor_read * pr , stream_cursor_write * pw , bool last ) {\n stream_aes_state * const state = ( stream_aes_state * ) ss ;\n const unsigned char * limit ;\n const long in_size = pr -> limit - pr -> ptr ;\n const long out_size = pw -> limit - pw -> ptr ;\n unsigned char temp [ 16 ] ;\n int status = 0 ;\n if ( in_size > out_size ) {\n limit = pr -> ptr + out_size ;\n status = 1 ;\n }\n else {\n limit = pr -> limit ;\n status = last ? EOFC : 0 ;\n }\n if ( state -> ctx == NULL ) {\n state -> ctx = ( aes_context * ) gs_alloc_bytes_immovable ( state -> memory , sizeof ( aes_context ) , \"aes context structure\" ) ;\n if ( state -> ctx == NULL ) {\n gs_throw ( gs_error_VMerror , \"could not allocate aes context\" ) ;\n return ERRC ;\n }\n if ( state -> keylength < 1 || state -> keylength > SAES_MAX_KEYLENGTH ) {\n gs_throw1 ( gs_error_rangecheck , \"invalid aes key length (%d bytes)\" , state -> keylength ) ;\n return ERRC ;\n }\n aes_setkey_dec ( state -> ctx , state -> key , state -> keylength * 8 ) ;\n }\n if ( ! state -> initialized ) {\n if ( in_size < 16 ) return 0 ;\n memcpy ( state -> iv , pr -> ptr + 1 , 16 ) ;\n state -> initialized = 1 ;\n pr -> ptr += 16 ;\n }\n while ( pr -> ptr + 16 <= limit ) {\n aes_crypt_cbc ( state -> ctx , AES_DECRYPT , 16 , state -> iv , pr -> ptr + 1 , temp ) ;\n pr -> ptr += 16 ;\n if ( last && pr -> ptr == pr -> limit ) {\n int pad ;\n if ( state -> use_padding ) {\n pad = temp [ 15 ] ;\n if ( pad < 1 || pad > 16 ) {\n gs_warn1 ( \"invalid aes padding byte (0x%02x)\" , ( unsigned char ) pad ) ;\n pad = 0 ;\n }\n }\n else {\n pad = 0 ;\n }\n memcpy ( pw -> ptr + 1 , temp , 16 - pad ) ;\n pw -> ptr += 16 - pad ;\n return EOFC ;\n }\n memcpy ( pw -> ptr + 1 , temp , 16 ) ;\n pw -> ptr += 16 ;\n }\n if ( status == EOFC ) {\n gs_throw ( gs_error_rangecheck , \"aes stream isn't a multiple of 16 bytes\" ) ;\n return 0 ;\n }\n return status ;\n }",
        "hash": 2782335626401253771,
        "project": "debian",
        "size": 61,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int s_aes_process ( stream_state * ss , stream_cursor_read * pr , stream_cursor_write * pw , bool last ) {\n"
                ],
                [
                    2,
                    " stream_aes_state * const state = ( stream_aes_state * ) ss ;\n"
                ],
                [
                    4,
                    " const long in_size = pr -> limit - pr -> ptr ;\n"
                ],
                [
                    5,
                    " const long out_size = pw -> limit - pw -> ptr ;\n"
                ],
                [
                    29,
                    " if ( in_size < 16 ) return 0 ;\n"
                ],
                [
                    30,
                    " memcpy ( state -> iv , pr -> ptr + 1 , 16 ) ;\n"
                ],
                [
                    35,
                    " aes_crypt_cbc ( state -> ctx , AES_DECRYPT , 16 , state -> iv , pr -> ptr + 1 , temp ) ;\n"
                ],
                [
                    37,
                    " if ( last && pr -> ptr == pr -> limit ) {\n"
                ],
                [
                    49,
                    " memcpy ( pw -> ptr + 1 , temp , 16 - pad ) ;\n"
                ],
                [
                    53,
                    " memcpy ( pw -> ptr + 1 , temp , 16 ) ;\n"
                ],
                [
                    54,
                    " pw -> ptr += 16 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int s_aes_process ( stream_state * ss , stream_cursor_read * pr , stream_cursor_write * pw , bool last ) {\n"
                ],
                [
                    2,
                    " stream_aes_state * const state = ( stream_aes_state * ) ss ;\n"
                ],
                [
                    4,
                    " const long in_size = pr -> limit - pr -> ptr ;\n"
                ],
                [
                    5,
                    " const long out_size = pw -> limit - pw -> ptr ;\n"
                ],
                [
                    29,
                    " if ( in_size < 16 ) return 0 ;\n"
                ],
                [
                    30,
                    " memcpy ( state -> iv , pr -> ptr + 1 , 16 ) ;\n"
                ],
                [
                    35,
                    " aes_crypt_cbc ( state -> ctx , AES_DECRYPT , 16 , state -> iv , pr -> ptr + 1 , temp ) ;\n"
                ],
                [
                    37,
                    " if ( last && pr -> ptr == pr -> limit ) {\n"
                ],
                [
                    49,
                    " memcpy ( pw -> ptr + 1 , temp , 16 - pad ) ;\n"
                ],
                [
                    53,
                    " memcpy ( pw -> ptr + 1 , temp , 16 ) ;\n"
                ],
                [
                    54,
                    " pw -> ptr += 16 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) {\n EVP_CIPHER_CTX * ctx ;\n unsigned char key [ EVP_MAX_KEY_LENGTH ] , * p_key = NULL ;\n unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ;\n VALUE pass , init_v ;\n if ( rb_scan_args ( argc , argv , \"02\" , & pass , & init_v ) > 0 ) {\n VALUE cname = rb_class_path ( rb_obj_class ( self ) ) ;\n rb_warn ( \"arguments for %\" PRIsVALUE \"#encrypt and %\" PRIsVALUE \"#decrypt were deprecated;\n \" \"use %\" PRIsVALUE \"#pkcs5_keyivgen to derive key and IV\" , cname , cname , cname ) ;\n StringValue ( pass ) ;\n GetCipher ( self , ctx ) ;\n if ( NIL_P ( init_v ) ) memcpy ( iv , \"OpenSSL for Ruby rulez!\" , sizeof ( iv ) ) ;\n else {\n StringValue ( init_v ) ;\n if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) {\n memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ;\n memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ;\n }\n else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ;\n }\n EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ;\n p_key = key ;\n p_iv = iv ;\n }\n else {\n GetCipher ( self , ctx ) ;\n }\n if ( EVP_CipherInit_ex ( ctx , NULL , NULL , p_key , p_iv , mode ) != 1 ) {\n ossl_raise ( eCipherError , NULL ) ;\n }\n return self ;\n }",
        "hash": 1896723564367514490,
        "project": "debian",
        "size": 32,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) {\n"
                ],
                [
                    12,
                    " if ( NIL_P ( init_v ) ) memcpy ( iv , \"OpenSSL for Ruby rulez!\" , sizeof ( iv ) ) ;\n"
                ],
                [
                    15,
                    " if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) {\n"
                ],
                [
                    16,
                    " memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ;\n"
                ],
                [
                    17,
                    " memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ;\n"
                ],
                [
                    19,
                    " else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ;\n"
                ],
                [
                    21,
                    " EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) {\n"
                ],
                [
                    4,
                    " unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ;\n"
                ],
                [
                    15,
                    " if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) {\n"
                ],
                [
                    16,
                    " memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ;\n"
                ],
                [
                    17,
                    " memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) {\n"
                ],
                [
                    4,
                    " unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ;\n"
                ],
                [
                    12,
                    " if ( NIL_P ( init_v ) ) memcpy ( iv , \"OpenSSL for Ruby rulez!\" , sizeof ( iv ) ) ;\n"
                ],
                [
                    15,
                    " if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) {\n"
                ],
                [
                    16,
                    " memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ;\n"
                ],
                [
                    17,
                    " memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ;\n"
                ],
                [
                    19,
                    " else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ;\n"
                ],
                [
                    21,
                    " EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n char filename [ AR_name_size + 1 ] ;\n uint64_t number ;\n size_t bsd_name_length , entry_size ;\n char * p , * st ;\n const void * b ;\n int r ;\n if ( strncmp ( h + AR_fmag_offset , \"`\\n\" , 2 ) != 0 ) {\n archive_set_error ( & a -> archive , EINVAL , \"Incorrect file header signature\" ) ;\n return ( ARCHIVE_WARN ) ;\n }\n strncpy ( filename , h + AR_name_offset , AR_name_size ) ;\n filename [ AR_name_size ] = '\\0' ;\n if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR ) {\n if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n else if ( strchr ( filename , '/' ) != NULL ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_GNU ;\n else if ( strncmp ( filename , \"__.SYMDEF\" , 9 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n }\n if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR_GNU ) a -> archive . archive_format_name = \"ar (GNU/SVR4)\" ;\n else if ( a -> archive . archive_format == ARCHIVE_FORMAT_AR_BSD ) a -> archive . archive_format_name = \"ar (BSD)\" ;\n else a -> archive . archive_format_name = \"ar\" ;\n p = filename + AR_name_size - 1 ;\n while ( p >= filename && * p == ' ' ) {\n * p = '\\0' ;\n p -- ;\n }\n if ( filename [ 0 ] != '/' && * p == '/' ) * p = '\\0' ;\n if ( strcmp ( filename , \"//\" ) == 0 ) {\n ar_parse_common_header ( ar , entry , h ) ;\n archive_entry_copy_pathname ( entry , filename ) ;\n archive_entry_set_filetype ( entry , AE_IFREG ) ;\n number = ar_atol10 ( h + AR_size_offset , AR_size_size ) ;\n if ( number > SIZE_MAX ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Filename table too large\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n entry_size = ( size_t ) number ;\n if ( entry_size == 0 ) {\n archive_set_error ( & a -> archive , EINVAL , \"Invalid string table\" ) ;\n return ( ARCHIVE_WARN ) ;\n }\n if ( ar -> strtab != NULL ) {\n archive_set_error ( & a -> archive , EINVAL , \"More than one string tables exist\" ) ;\n return ( ARCHIVE_WARN ) ;\n }\n st = malloc ( entry_size ) ;\n if ( st == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate filename table buffer\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n ar -> strtab = st ;\n ar -> strtab_size = entry_size ;\n if ( * unconsumed ) {\n __archive_read_consume ( a , * unconsumed ) ;\n * unconsumed = 0 ;\n }\n if ( ( b = __archive_read_ahead ( a , entry_size , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ;\n memcpy ( st , b , entry_size ) ;\n __archive_read_consume ( a , entry_size ) ;\n ar -> entry_bytes_remaining = 0 ;\n archive_entry_set_size ( entry , ar -> entry_bytes_remaining ) ;\n return ( ar_parse_gnu_filename_table ( a ) ) ;\n }\n if ( filename [ 0 ] == '/' && filename [ 1 ] >= '0' && filename [ 1 ] <= '9' ) {\n number = ar_atol10 ( h + AR_name_offset + 1 , AR_name_size - 1 ) ;\n if ( ar -> strtab == NULL || number > ar -> strtab_size ) {\n archive_set_error ( & a -> archive , EINVAL , \"Can't find long filename for entry\" ) ;\n archive_entry_copy_pathname ( entry , filename ) ;\n ar_parse_common_header ( ar , entry , h ) ;\n return ( ARCHIVE_WARN ) ;\n }\n archive_entry_copy_pathname ( entry , & ar -> strtab [ ( size_t ) number ] ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }\n if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) {\n ar_parse_common_header ( ar , entry , h ) ;\n number = ar_atol10 ( h + AR_name_offset + 3 , AR_name_size - 3 ) ;\n bsd_name_length = ( size_t ) number ;\n if ( number > ( uint64_t ) ( bsd_name_length + 1 ) || ( int64_t ) bsd_name_length > ar -> entry_bytes_remaining ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Bad input file size\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n ar -> entry_bytes_remaining -= bsd_name_length ;\n archive_entry_set_size ( entry , ar -> entry_bytes_remaining ) ;\n if ( * unconsumed ) {\n __archive_read_consume ( a , * unconsumed ) ;\n * unconsumed = 0 ;\n }\n if ( ( b = __archive_read_ahead ( a , bsd_name_length , NULL ) ) == NULL ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Truncated input file\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n p = ( char * ) malloc ( bsd_name_length + 1 ) ;\n if ( p == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate fname buffer\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n strncpy ( p , b , bsd_name_length ) ;\n p [ bsd_name_length ] = '\\0' ;\n __archive_read_consume ( a , bsd_name_length ) ;\n archive_entry_copy_pathname ( entry , p ) ;\n free ( p ) ;\n return ( ARCHIVE_OK ) ;\n }\n if ( strcmp ( filename , \"/\" ) == 0 ) {\n archive_entry_copy_pathname ( entry , \"/\" ) ;\n r = ar_parse_common_header ( ar , entry , h ) ;\n archive_entry_set_filetype ( entry , AE_IFREG ) ;\n return ( r ) ;\n }\n if ( strcmp ( filename , \"__.SYMDEF\" ) == 0 ) {\n archive_entry_copy_pathname ( entry , filename ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }\n archive_entry_copy_pathname ( entry , filename ) ;\n return ( ar_parse_common_header ( ar , entry , h ) ) ;\n }",
        "hash": -8575765905118000367,
        "project": "debian",
        "size": 117,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n"
                ],
                [
                    47,
                    " if ( st == NULL ) {\n"
                ],
                [
                    57,
                    " if ( ( b = __archive_read_ahead ( a , entry_size , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ;\n"
                ],
                [
                    58,
                    " memcpy ( st , b , entry_size ) ;\n"
                ],
                [
                    59,
                    " __archive_read_consume ( a , entry_size ) ;\n"
                ]
            ],
            "strncpy": [
                [
                    1,
                    "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n"
                ],
                [
                    2,
                    " char filename [ AR_name_size + 1 ] ;\n"
                ],
                [
                    8,
                    " if ( strncmp ( h + AR_fmag_offset , \"`\\n\" , 2 ) != 0 ) {\n"
                ],
                [
                    12,
                    " strncpy ( filename , h + AR_name_offset , AR_name_size ) ;\n"
                ],
                [
                    15,
                    " if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n"
                ],
                [
                    22,
                    " p = filename + AR_name_size - 1 ;\n"
                ],
                [
                    23,
                    " while ( p >= filename && * p == ' ' ) {\n"
                ],
                [
                    24,
                    " * p = '\\0' ;\n"
                ],
                [
                    27,
                    " if ( filename [ 0 ] != '/' && * p == '/' ) * p = '\\0' ;\n"
                ],
                [
                    65,
                    " number = ar_atol10 ( h + AR_name_offset + 1 , AR_name_size - 1 ) ;\n"
                ],
                [
                    77,
                    " number = ar_atol10 ( h + AR_name_offset + 3 , AR_name_size - 3 ) ;\n"
                ],
                [
                    89,
                    " if ( ( b = __archive_read_ahead ( a , bsd_name_length , NULL ) ) == NULL ) {\n"
                ],
                [
                    94,
                    " if ( p == NULL ) {\n"
                ],
                [
                    98,
                    " strncpy ( p , b , bsd_name_length ) ;\n"
                ],
                [
                    100,
                    " __archive_read_consume ( a , bsd_name_length ) ;\n"
                ],
                [
                    101,
                    " archive_entry_copy_pathname ( entry , p ) ;\n"
                ]
            ],
            "strchr": [
                [
                    1,
                    "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n"
                ],
                [
                    13,
                    " filename [ AR_name_size ] = '\\0' ;\n"
                ],
                [
                    15,
                    " if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n"
                ],
                [
                    16,
                    " else if ( strchr ( filename , '/' ) != NULL ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_GNU ;\n"
                ],
                [
                    17,
                    " else if ( strncmp ( filename , \"__.SYMDEF\" , 9 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n"
                ],
                [
                    22,
                    " p = filename + AR_name_size - 1 ;\n"
                ],
                [
                    23,
                    " while ( p >= filename && * p == ' ' ) {\n"
                ],
                [
                    42,
                    " if ( ar -> strtab != NULL ) {\n"
                ],
                [
                    66,
                    " if ( ar -> strtab == NULL || number > ar -> strtab_size ) {\n"
                ],
                [
                    89,
                    " if ( ( b = __archive_read_ahead ( a , bsd_name_length , NULL ) ) == NULL ) {\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n"
                ],
                [
                    8,
                    " if ( strncmp ( h + AR_fmag_offset , \"`\\n\" , 2 ) != 0 ) {\n"
                ],
                [
                    13,
                    " filename [ AR_name_size ] = '\\0' ;\n"
                ],
                [
                    23,
                    " while ( p >= filename && * p == ' ' ) {\n"
                ],
                [
                    27,
                    " if ( filename [ 0 ] != '/' && * p == '/' ) * p = '\\0' ;\n"
                ],
                [
                    28,
                    " if ( strcmp ( filename , \"//\" ) == 0 ) {\n"
                ],
                [
                    29,
                    " ar_parse_common_header ( ar , entry , h ) ;\n"
                ],
                [
                    30,
                    " archive_entry_copy_pathname ( entry , filename ) ;\n"
                ],
                [
                    31,
                    " archive_entry_set_filetype ( entry , AE_IFREG ) ;\n"
                ],
                [
                    32,
                    " number = ar_atol10 ( h + AR_size_offset , AR_size_size ) ;\n"
                ],
                [
                    33,
                    " if ( number > SIZE_MAX ) {\n"
                ],
                [
                    64,
                    " if ( filename [ 0 ] == '/' && filename [ 1 ] >= '0' && filename [ 1 ] <= '9' ) {\n"
                ],
                [
                    68,
                    " archive_entry_copy_pathname ( entry , filename ) ;\n"
                ],
                [
                    75,
                    " if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) {\n"
                ],
                [
                    105,
                    " if ( strcmp ( filename , \"/\" ) == 0 ) {\n"
                ],
                [
                    106,
                    " archive_entry_copy_pathname ( entry , \"/\" ) ;\n"
                ],
                [
                    107,
                    " r = ar_parse_common_header ( ar , entry , h ) ;\n"
                ],
                [
                    108,
                    " archive_entry_set_filetype ( entry , AE_IFREG ) ;\n"
                ],
                [
                    109,
                    " return ( r ) ;\n"
                ],
                [
                    111,
                    " if ( strcmp ( filename , \"__.SYMDEF\" ) == 0 ) {\n"
                ],
                [
                    112,
                    " archive_entry_copy_pathname ( entry , filename ) ;\n"
                ],
                [
                    113,
                    " return ( ar_parse_common_header ( ar , entry , h ) ) ;\n"
                ],
                [
                    115,
                    " archive_entry_copy_pathname ( entry , filename ) ;\n"
                ],
                [
                    116,
                    " return ( ar_parse_common_header ( ar , entry , h ) ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n"
                ],
                [
                    38,
                    " if ( entry_size == 0 ) {\n"
                ],
                [
                    42,
                    " if ( ar -> strtab != NULL ) {\n"
                ],
                [
                    46,
                    " st = malloc ( entry_size ) ;\n"
                ],
                [
                    47,
                    " if ( st == NULL ) {\n"
                ],
                [
                    52,
                    " ar -> strtab_size = entry_size ;\n"
                ],
                [
                    57,
                    " if ( ( b = __archive_read_ahead ( a , entry_size , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ;\n"
                ],
                [
                    89,
                    " if ( ( b = __archive_read_ahead ( a , bsd_name_length , NULL ) ) == NULL ) {\n"
                ],
                [
                    93,
                    " p = ( char * ) malloc ( bsd_name_length + 1 ) ;\n"
                ],
                [
                    94,
                    " if ( p == NULL ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n"
                ],
                [
                    23,
                    " while ( p >= filename && * p == ' ' ) {\n"
                ],
                [
                    24,
                    " * p = '\\0' ;\n"
                ],
                [
                    27,
                    " if ( filename [ 0 ] != '/' && * p == '/' ) * p = '\\0' ;\n"
                ],
                [
                    94,
                    " if ( p == NULL ) {\n"
                ],
                [
                    99,
                    " p [ bsd_name_length ] = '\\0' ;\n"
                ],
                [
                    101,
                    " archive_entry_copy_pathname ( entry , p ) ;\n"
                ],
                [
                    102,
                    " free ( p ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n"
                ],
                [
                    2,
                    " char filename [ AR_name_size + 1 ] ;\n"
                ],
                [
                    8,
                    " if ( strncmp ( h + AR_fmag_offset , \"`\\n\" , 2 ) != 0 ) {\n"
                ],
                [
                    12,
                    " strncpy ( filename , h + AR_name_offset , AR_name_size ) ;\n"
                ],
                [
                    13,
                    " filename [ AR_name_size ] = '\\0' ;\n"
                ],
                [
                    15,
                    " if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n"
                ],
                [
                    16,
                    " else if ( strchr ( filename , '/' ) != NULL ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_GNU ;\n"
                ],
                [
                    17,
                    " else if ( strncmp ( filename , \"__.SYMDEF\" , 9 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n"
                ],
                [
                    22,
                    " p = filename + AR_name_size - 1 ;\n"
                ],
                [
                    23,
                    " while ( p >= filename && * p == ' ' ) {\n"
                ],
                [
                    24,
                    " * p = '\\0' ;\n"
                ],
                [
                    27,
                    " if ( filename [ 0 ] != '/' && * p == '/' ) * p = '\\0' ;\n"
                ],
                [
                    28,
                    " if ( strcmp ( filename , \"//\" ) == 0 ) {\n"
                ],
                [
                    29,
                    " ar_parse_common_header ( ar , entry , h ) ;\n"
                ],
                [
                    30,
                    " archive_entry_copy_pathname ( entry , filename ) ;\n"
                ],
                [
                    31,
                    " archive_entry_set_filetype ( entry , AE_IFREG ) ;\n"
                ],
                [
                    32,
                    " number = ar_atol10 ( h + AR_size_offset , AR_size_size ) ;\n"
                ],
                [
                    33,
                    " if ( number > SIZE_MAX ) {\n"
                ],
                [
                    38,
                    " if ( entry_size == 0 ) {\n"
                ],
                [
                    42,
                    " if ( ar -> strtab != NULL ) {\n"
                ],
                [
                    46,
                    " st = malloc ( entry_size ) ;\n"
                ],
                [
                    47,
                    " if ( st == NULL ) {\n"
                ],
                [
                    52,
                    " ar -> strtab_size = entry_size ;\n"
                ],
                [
                    57,
                    " if ( ( b = __archive_read_ahead ( a , entry_size , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ;\n"
                ],
                [
                    58,
                    " memcpy ( st , b , entry_size ) ;\n"
                ],
                [
                    59,
                    " __archive_read_consume ( a , entry_size ) ;\n"
                ],
                [
                    64,
                    " if ( filename [ 0 ] == '/' && filename [ 1 ] >= '0' && filename [ 1 ] <= '9' ) {\n"
                ],
                [
                    65,
                    " number = ar_atol10 ( h + AR_name_offset + 1 , AR_name_size - 1 ) ;\n"
                ],
                [
                    66,
                    " if ( ar -> strtab == NULL || number > ar -> strtab_size ) {\n"
                ],
                [
                    68,
                    " archive_entry_copy_pathname ( entry , filename ) ;\n"
                ],
                [
                    75,
                    " if ( strncmp ( filename , \"#1/\" , 3 ) == 0 ) {\n"
                ],
                [
                    77,
                    " number = ar_atol10 ( h + AR_name_offset + 3 , AR_name_size - 3 ) ;\n"
                ],
                [
                    89,
                    " if ( ( b = __archive_read_ahead ( a , bsd_name_length , NULL ) ) == NULL ) {\n"
                ],
                [
                    93,
                    " p = ( char * ) malloc ( bsd_name_length + 1 ) ;\n"
                ],
                [
                    94,
                    " if ( p == NULL ) {\n"
                ],
                [
                    98,
                    " strncpy ( p , b , bsd_name_length ) ;\n"
                ],
                [
                    99,
                    " p [ bsd_name_length ] = '\\0' ;\n"
                ],
                [
                    100,
                    " __archive_read_consume ( a , bsd_name_length ) ;\n"
                ],
                [
                    101,
                    " archive_entry_copy_pathname ( entry , p ) ;\n"
                ],
                [
                    102,
                    " free ( p ) ;\n"
                ],
                [
                    105,
                    " if ( strcmp ( filename , \"/\" ) == 0 ) {\n"
                ],
                [
                    106,
                    " archive_entry_copy_pathname ( entry , \"/\" ) ;\n"
                ],
                [
                    107,
                    " r = ar_parse_common_header ( ar , entry , h ) ;\n"
                ],
                [
                    108,
                    " archive_entry_set_filetype ( entry , AE_IFREG ) ;\n"
                ],
                [
                    109,
                    " return ( r ) ;\n"
                ],
                [
                    111,
                    " if ( strcmp ( filename , \"__.SYMDEF\" ) == 0 ) {\n"
                ],
                [
                    112,
                    " archive_entry_copy_pathname ( entry , filename ) ;\n"
                ],
                [
                    113,
                    " return ( ar_parse_common_header ( ar , entry , h ) ) ;\n"
                ],
                [
                    115,
                    " archive_entry_copy_pathname ( entry , filename ) ;\n"
                ],
                [
                    116,
                    " return ( ar_parse_common_header ( ar , entry , h ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int ar_parse_gnu_filename_table ( struct archive_read * a ) {\n struct ar * ar ;\n char * p ;\n size_t size ;\n ar = ( struct ar * ) ( a -> format -> data ) ;\n size = ar -> strtab_size ;\n for ( p = ar -> strtab ;\n p < ar -> strtab + size - 1 ;\n ++ p ) {\n if ( * p == '/' ) {\n * p ++ = '\\0' ;\n if ( * p != '\\n' ) goto bad_string_table ;\n * p = '\\0' ;\n }\n }\n if ( p != ar -> strtab + size && * p != '\\n' && * p != '`' ) goto bad_string_table ;\n ar -> strtab [ size - 1 ] = '\\0' ;\n return ( ARCHIVE_OK ) ;\n bad_string_table : archive_set_error ( & a -> archive , EINVAL , \"Invalid string table\" ) ;\n free ( ar -> strtab ) ;\n ar -> strtab = NULL ;\n return ( ARCHIVE_WARN ) ;\n }",
        "hash": -8575765905118000367,
        "project": "debian",
        "size": 23,
        "slice": {
            "free": [
                [
                    5,
                    " ar = ( struct ar * ) ( a -> format -> data ) ;\n"
                ],
                [
                    12,
                    " if ( * p != '\\n' ) goto bad_string_table ;\n"
                ],
                [
                    16,
                    " if ( p != ar -> strtab + size && * p != '\\n' && * p != '`' ) goto bad_string_table ;\n"
                ],
                [
                    20,
                    " free ( ar -> strtab ) ;\n"
                ]
            ],
            "result": [
                [
                    5,
                    " ar = ( struct ar * ) ( a -> format -> data ) ;\n"
                ],
                [
                    12,
                    " if ( * p != '\\n' ) goto bad_string_table ;\n"
                ],
                [
                    16,
                    " if ( p != ar -> strtab + size && * p != '\\n' && * p != '`' ) goto bad_string_table ;\n"
                ],
                [
                    20,
                    " free ( ar -> strtab ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int gdev_x_open ( gx_device_X * xdev ) {\n XSizeHints sizehints ;\n char * window_id ;\n XEvent event ;\n XVisualInfo xvinfo ;\n int nitems ;\n XtAppContext app_con ;\n Widget toplevel ;\n Display * dpy ;\n XColor xc ;\n int zero = 0 ;\n int xid_height = 0 , xid_width = 0 ;\n int code ;\n # ifdef DEBUG # ifdef have_Xdebug if ( gs_debug [ 'X' ] ) {\n extern int _Xdebug ;\n _Xdebug = 1 ;\n }\n # endif # endif if ( ! ( xdev -> dpy = XOpenDisplay ( ( char * ) NULL ) ) ) {\n char * dispname = getenv ( \"DISPLAY\" ) ;\n emprintf1 ( xdev -> memory , \"Cannot open X display `%s'.\\n\" , ( dispname == NULL ? \"(null)\" : dispname ) ) ;\n return_error ( gs_error_ioerror ) ;\n }\n xdev -> dest = 0 ;\n if ( ( window_id = getenv ( \"GHOSTVIEW\" ) ) ) {\n if ( ! ( xdev -> ghostview = sscanf ( window_id , \"%ld %ld\" , & ( xdev -> win ) , & ( xdev -> dest ) ) ) ) {\n emprintf ( xdev -> memory , \"Cannot get Window ID from ghostview.\\n\" ) ;\n return_error ( gs_error_ioerror ) ;\n }\n }\n if ( xdev -> pwin != ( Window ) None ) {\n XWindowAttributes attrib ;\n xdev -> win = xdev -> pwin ;\n if ( XGetWindowAttributes ( xdev -> dpy , xdev -> win , & attrib ) ) {\n xdev -> scr = attrib . screen ;\n xvinfo . visual = attrib . visual ;\n xdev -> cmap = attrib . colormap ;\n xid_width = attrib . width ;\n xid_height = attrib . height ;\n }\n else {\n xid_width = xid_height = 0 ;\n }\n }\n else if ( xdev -> ghostview ) {\n XWindowAttributes attrib ;\n Atom type ;\n int format ;\n unsigned long nitems , bytes_after ;\n char * buf ;\n Atom ghostview_atom = XInternAtom ( xdev -> dpy , \"GHOSTVIEW\" , False ) ;\n if ( XGetWindowAttributes ( xdev -> dpy , xdev -> win , & attrib ) ) {\n xdev -> scr = attrib . screen ;\n xvinfo . visual = attrib . visual ;\n xdev -> cmap = attrib . colormap ;\n xdev -> width = attrib . width ;\n xdev -> height = attrib . height ;\n }\n if ( XGetWindowProperty ( xdev -> dpy , xdev -> win , ghostview_atom , 0 , 256 , ( xdev -> dest != 0 ) , XA_STRING , & type , & format , & nitems , & bytes_after , ( unsigned char * * ) & buf ) == 0 && type == XA_STRING ) {\n int llx , lly , urx , ury ;\n int left_margin = 0 , bottom_margin = 0 ;\n int right_margin = 0 , top_margin = 0 ;\n int page_orientation ;\n float xppp , yppp ;\n nitems = sscanf ( buf , \"%ld %d %d %d %d %d %f %f %d %d %d %d\" , & ( xdev -> bpixmap ) , & page_orientation , & llx , & lly , & urx , & ury , & ( xdev -> x_pixels_per_inch ) , & ( xdev -> y_pixels_per_inch ) , & left_margin , & bottom_margin , & right_margin , & top_margin ) ;\n if ( ! ( nitems == 8 || nitems == 12 ) ) {\n emprintf ( xdev -> memory , \"Cannot get ghostview property.\\n\" ) ;\n return_error ( gs_error_ioerror ) ;\n }\n if ( xdev -> dest && xdev -> bpixmap ) {\n emprintf ( xdev -> memory , \"Both destination and backing pixmap specified.\\n\" ) ;\n return_error ( gs_error_rangecheck ) ;\n }\n if ( xdev -> dest ) {\n Window root ;\n int x , y ;\n unsigned int width , height ;\n unsigned int border_width , depth ;\n if ( XGetGeometry ( xdev -> dpy , xdev -> dest , & root , & x , & y , & width , & height , & border_width , & depth ) ) {\n xdev -> width = width ;\n xdev -> height = height ;\n }\n }\n xppp = xdev -> x_pixels_per_inch / 72.0 ;\n yppp = xdev -> y_pixels_per_inch / 72.0 ;\n switch ( page_orientation ) {\n case Portrait : xdev -> initial_matrix . xx = xppp ;\n xdev -> initial_matrix . xy = 0.0 ;\n xdev -> initial_matrix . yx = 0.0 ;\n xdev -> initial_matrix . yy = - yppp ;\n xdev -> initial_matrix . tx = - llx * xppp ;\n xdev -> initial_matrix . ty = ury * yppp ;\n break ;\n case Landscape : xdev -> initial_matrix . xx = 0.0 ;\n xdev -> initial_matrix . xy = yppp ;\n xdev -> initial_matrix . yx = xppp ;\n xdev -> initial_matrix . yy = 0.0 ;\n xdev -> initial_matrix . tx = - lly * xppp ;\n xdev -> initial_matrix . ty = - llx * yppp ;\n break ;\n case Upsidedown : xdev -> initial_matrix . xx = - xppp ;\n xdev -> initial_matrix . xy = 0.0 ;\n xdev -> initial_matrix . yx = 0.0 ;\n xdev -> initial_matrix . yy = yppp ;\n xdev -> initial_matrix . tx = urx * xppp ;\n xdev -> initial_matrix . ty = - lly * yppp ;\n break ;\n case Seascape : xdev -> initial_matrix . xx = 0.0 ;\n xdev -> initial_matrix . xy = - yppp ;\n xdev -> initial_matrix . yx = - xppp ;\n xdev -> initial_matrix . yy = 0.0 ;\n xdev -> initial_matrix . tx = ury * xppp ;\n xdev -> initial_matrix . ty = urx * yppp ;\n break ;\n }\n xdev -> ImagingBBox [ 0 ] = llx - left_margin ;\n xdev -> ImagingBBox [ 1 ] = lly - bottom_margin ;\n xdev -> ImagingBBox [ 2 ] = urx + right_margin ;\n xdev -> ImagingBBox [ 3 ] = ury + top_margin ;\n xdev -> ImagingBBox_set = true ;\n }\n else if ( xdev -> pwin == ( Window ) None ) {\n emprintf ( xdev -> memory , \"Cannot get ghostview property.\\n\" ) ;\n return_error ( gs_error_ioerror ) ;\n }\n }\n else {\n Screen * scr = DefaultScreenOfDisplay ( xdev -> dpy ) ;\n xdev -> scr = scr ;\n xvinfo . visual = DefaultVisualOfScreen ( scr ) ;\n xdev -> cmap = DefaultColormapOfScreen ( scr ) ;\n if ( xvinfo . visual -> class != TrueColor ) {\n int scrno = DefaultScreen ( xdev -> dpy ) ;\n if ( XMatchVisualInfo ( xdev -> dpy , scrno , 24 , TrueColor , & xvinfo ) || XMatchVisualInfo ( xdev -> dpy , scrno , 32 , TrueColor , & xvinfo ) || XMatchVisualInfo ( xdev -> dpy , scrno , 16 , TrueColor , & xvinfo ) || XMatchVisualInfo ( xdev -> dpy , scrno , 15 , TrueColor , & xvinfo ) ) {\n xdev -> cmap = XCreateColormap ( xdev -> dpy , DefaultRootWindow ( xdev -> dpy ) , xvinfo . visual , AllocNone ) ;\n }\n }\n }\n xvinfo . visualid = XVisualIDFromVisual ( xvinfo . visual ) ;\n xdev -> vinfo = XGetVisualInfo ( xdev -> dpy , VisualIDMask , & xvinfo , & nitems ) ;\n if ( xdev -> vinfo == NULL ) {\n emprintf ( xdev -> memory , \"Cannot get XVisualInfo.\\n\" ) ;\n return_error ( gs_error_ioerror ) ;\n }\n x_error_handler . orighandler = XSetErrorHandler ( x_catch_free_colors ) ;\n XtToolkitInitialize ( ) ;\n app_con = XtCreateApplicationContext ( ) ;\n XtAppSetFallbackResources ( app_con , gdev_x_fallback_resources ) ;\n dpy = XtOpenDisplay ( app_con , NULL , \"ghostscript\" , \"Ghostscript\" , NULL , 0 , & zero , NULL ) ;\n toplevel = XtAppCreateShell ( NULL , \"Ghostscript\" , applicationShellWidgetClass , dpy , NULL , 0 ) ;\n XtGetApplicationResources ( toplevel , ( XtPointer ) xdev , gdev_x_resources , gdev_x_resource_count , NULL , 0 ) ;\n xc . pixel = xdev -> foreground ;\n XQueryColor ( xdev -> dpy , DefaultColormap ( xdev -> dpy , DefaultScreen ( xdev -> dpy ) ) , & xc ) ;\n XAllocColor ( xdev -> dpy , xdev -> cmap , & xc ) ;\n xdev -> foreground = xc . pixel ;\n xc . pixel = xdev -> background ;\n XQueryColor ( xdev -> dpy , DefaultColormap ( xdev -> dpy , DefaultScreen ( xdev -> dpy ) ) , & xc ) ;\n XAllocColor ( xdev -> dpy , xdev -> cmap , & xc ) ;\n xdev -> background = xc . pixel ;\n code = gdev_x_setup_colors ( xdev ) ;\n if ( code < 0 ) {\n XCloseDisplay ( xdev -> dpy ) ;\n return code ;\n }\n check_device_separable ( ( gx_device * ) xdev ) ;\n if ( ! xdev -> ghostview ) {\n XWMHints wm_hints ;\n XClassHint class_hint ;\n XSetWindowAttributes xswa ;\n gx_device * dev = ( gx_device * ) xdev ;\n if ( xdev -> x_pixels_per_inch == FAKE_RES || xdev -> y_pixels_per_inch == FAKE_RES ) {\n float xsize = ( float ) xdev -> width / xdev -> x_pixels_per_inch ;\n float ysize = ( float ) xdev -> height / xdev -> y_pixels_per_inch ;\n int workarea_width = WidthOfScreen ( xdev -> scr ) , workarea_height = HeightOfScreen ( xdev -> scr ) ;\n x_get_work_area ( xdev , & workarea_width , & workarea_height ) ;\n if ( xdev -> xResolution == 0.0 && xdev -> yResolution == 0.0 ) {\n float dpi , xdpi , ydpi ;\n xdpi = 25.4 * WidthOfScreen ( xdev -> scr ) / WidthMMOfScreen ( xdev -> scr ) ;\n ydpi = 25.4 * HeightOfScreen ( xdev -> scr ) / HeightMMOfScreen ( xdev -> scr ) ;\n dpi = min ( xdpi , ydpi ) ;\n if ( dpi < 30 ) dpi = 75 ;\n else {\n while ( xsize * dpi > WidthOfScreen ( xdev -> scr ) - 32 || ysize * dpi > HeightOfScreen ( xdev -> scr ) - 32 ) dpi *= 0.95 ;\n }\n xdev -> x_pixels_per_inch = dpi ;\n xdev -> y_pixels_per_inch = dpi ;\n }\n else {\n xdev -> x_pixels_per_inch = xdev -> xResolution ;\n xdev -> y_pixels_per_inch = xdev -> yResolution ;\n }\n if ( xdev -> width > workarea_width ) {\n xdev -> width = min ( xsize * xdev -> x_pixels_per_inch , workarea_width ) ;\n }\n if ( xdev -> height > workarea_height ) {\n xdev -> height = min ( ysize * xdev -> y_pixels_per_inch , workarea_height ) ;\n }\n xdev -> MediaSize [ 0 ] = ( float ) xdev -> width / xdev -> x_pixels_per_inch * 72 ;\n xdev -> MediaSize [ 1 ] = ( float ) xdev -> height / xdev -> y_pixels_per_inch * 72 ;\n }\n sizehints . x = 0 ;\n sizehints . y = 0 ;\n sizehints . width = xdev -> width ;\n sizehints . height = xdev -> height ;\n sizehints . flags = 0 ;\n if ( xdev -> geometry != NULL ) {\n char gstr [ 40 ] ;\n int bitmask ;\n gs_sprintf ( gstr , \"%dx%d+%d+%d\" , sizehints . width , sizehints . height , sizehints . x , sizehints . y ) ;\n bitmask = XWMGeometry ( xdev -> dpy , DefaultScreen ( xdev -> dpy ) , xdev -> geometry , gstr , xdev -> borderWidth , & sizehints , & sizehints . x , & sizehints . y , & sizehints . width , & sizehints . height , & sizehints . win_gravity ) ;\n if ( bitmask & ( XValue | YValue ) ) sizehints . flags |= USPosition ;\n }\n gx_default_get_initial_matrix ( dev , & ( xdev -> initial_matrix ) ) ;\n if ( xdev -> pwin != ( Window ) None && xid_width != 0 && xid_height != 0 ) {\n # if 0 xdev -> initial_matrix . xx = xdev -> initial_matrix . xx * ( float ) xid_width / ( float ) xdev -> width ;\n xdev -> initial_matrix . yy = xdev -> initial_matrix . yy * ( float ) xid_height / ( float ) xdev -> height ;\n # endif xdev -> width = xid_width ;\n xdev -> height = xid_height ;\n xdev -> initial_matrix . ty = xdev -> height ;\n }\n else {\n xswa . event_mask = ExposureMask ;\n xswa . background_pixel = xdev -> background ;\n xswa . border_pixel = xdev -> borderColor ;\n xswa . colormap = xdev -> cmap ;\n xdev -> win = XCreateWindow ( xdev -> dpy , RootWindowOfScreen ( xdev -> scr ) , sizehints . x , sizehints . y , xdev -> width , xdev -> height , xdev -> borderWidth , xdev -> vinfo -> depth , InputOutput , xdev -> vinfo -> visual , CWEventMask | CWBackPixel | CWBorderPixel | CWColormap , & xswa ) ;\n XStoreName ( xdev -> dpy , xdev -> win , \"ghostscript\" ) ;\n XSetWMNormalHints ( xdev -> dpy , xdev -> win , & sizehints ) ;\n wm_hints . flags = InputHint ;\n wm_hints . input = False ;\n XSetWMHints ( xdev -> dpy , xdev -> win , & wm_hints ) ;\n class_hint . res_name = ( char * ) \"ghostscript\" ;\n class_hint . res_class = ( char * ) \"Ghostscript\" ;\n XSetClassHint ( xdev -> dpy , xdev -> win , & class_hint ) ;\n }\n }\n XtDestroyWidget ( toplevel ) ;\n XtCloseDisplay ( dpy ) ;\n XtDestroyApplicationContext ( app_con ) ;\n xdev -> ht . pixmap = ( Pixmap ) 0 ;\n xdev -> ht . id = gx_no_bitmap_id ;\n ;\n xdev -> fill_style = FillSolid ;\n xdev -> function = GXcopy ;\n xdev -> fid = ( Font ) 0 ;\n xdev -> gc = XCreateGC ( xdev -> dpy , xdev -> win , 0 , ( XGCValues * ) NULL ) ;\n XSetFunction ( xdev -> dpy , xdev -> gc , GXcopy ) ;\n XSetLineAttributes ( xdev -> dpy , xdev -> gc , 0 , LineSolid , CapButt , JoinMiter ) ;\n gdev_x_clear_window ( xdev ) ;\n if ( ! xdev -> ghostview ) {\n XMapWindow ( xdev -> dpy , xdev -> win ) ;\n XSync ( xdev -> dpy , False ) ;\n if ( xdev -> pwin == ( Window ) None ) {\n XNextEvent ( xdev -> dpy , & event ) ;\n }\n XSetGraphicsExposures ( xdev -> dpy , xdev -> gc , False ) ;\n XSelectInput ( xdev -> dpy , xdev -> win , NoEventMask ) ;\n }\n else {\n XSetWindowAttributes attributes ;\n attributes . override_redirect = True ;\n xdev -> mwin = XCreateWindow ( xdev -> dpy , RootWindowOfScreen ( xdev -> scr ) , 0 , 0 , 1 , 1 , 0 , CopyFromParent , CopyFromParent , CopyFromParent , CWOverrideRedirect , & attributes ) ;\n xdev -> NEXT = XInternAtom ( xdev -> dpy , \"NEXT\" , False ) ;\n xdev -> PAGE = XInternAtom ( xdev -> dpy , \"PAGE\" , False ) ;\n xdev -> DONE = XInternAtom ( xdev -> dpy , \"DONE\" , False ) ;\n }\n xdev -> ht . no_pixmap = XCreatePixmap ( xdev -> dpy , xdev -> win , 1 , 1 , xdev -> vinfo -> depth ) ;\n return 0 ;\n }",
        "hash": -6529313662352494663,
        "project": "debian",
        "size": 268,
        "slice": {
            "getenv": [
                [
                    1,
                    "int gdev_x_open ( gx_device_X * xdev ) {\n"
                ],
                [
                    19,
                    " char * dispname = getenv ( \"DISPLAY\" ) ;\n"
                ],
                [
                    20,
                    " emprintf1 ( xdev -> memory , \"Cannot open X display `%s'.\\n\" , ( dispname == NULL ? \"(null)\" : dispname ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int gdev_x_open ( gx_device_X * xdev ) {\n"
                ],
                [
                    19,
                    " char * dispname = getenv ( \"DISPLAY\" ) ;\n"
                ],
                [
                    20,
                    " emprintf1 ( xdev -> memory , \"Cannot open X display `%s'.\\n\" , ( dispname == NULL ? \"(null)\" : dispname ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int qcow2_open ( BlockDriverState * bs , QDict * options , int flags , Error * * errp ) {\n BDRVQcowState * s = bs -> opaque ;\n unsigned int len , i ;\n int ret = 0 ;\n QCowHeader header ;\n QemuOpts * opts ;\n Error * local_err = NULL ;\n uint64_t ext_end ;\n uint64_t l1_vm_state_index ;\n const char * opt_overlap_check ;\n int overlap_check_template = 0 ;\n ret = bdrv_pread ( bs -> file , 0 , & header , sizeof ( header ) ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read qcow2 header\" ) ;\n goto fail ;\n }\n be32_to_cpus ( & header . magic ) ;\n be32_to_cpus ( & header . version ) ;\n be64_to_cpus ( & header . backing_file_offset ) ;\n be32_to_cpus ( & header . backing_file_size ) ;\n be64_to_cpus ( & header . size ) ;\n be32_to_cpus ( & header . cluster_bits ) ;\n be32_to_cpus ( & header . crypt_method ) ;\n be64_to_cpus ( & header . l1_table_offset ) ;\n be32_to_cpus ( & header . l1_size ) ;\n be64_to_cpus ( & header . refcount_table_offset ) ;\n be32_to_cpus ( & header . refcount_table_clusters ) ;\n be64_to_cpus ( & header . snapshots_offset ) ;\n be32_to_cpus ( & header . nb_snapshots ) ;\n if ( header . magic != QCOW_MAGIC ) {\n error_setg ( errp , \"Image is not in qcow2 format\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n if ( header . version < 2 || header . version > 3 ) {\n report_unsupported ( bs , errp , \"QCOW version %d\" , header . version ) ;\n ret = - ENOTSUP ;\n goto fail ;\n }\n s -> qcow_version = header . version ;\n if ( header . cluster_bits < MIN_CLUSTER_BITS || header . cluster_bits > MAX_CLUSTER_BITS ) {\n error_setg ( errp , \"Unsupported cluster size: 2^%i\" , header . cluster_bits ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n s -> cluster_bits = header . cluster_bits ;\n s -> cluster_size = 1 << s -> cluster_bits ;\n s -> cluster_sectors = 1 << ( s -> cluster_bits - 9 ) ;\n if ( header . version == 2 ) {\n header . incompatible_features = 0 ;\n header . compatible_features = 0 ;\n header . autoclear_features = 0 ;\n header . refcount_order = 4 ;\n header . header_length = 72 ;\n }\n else {\n be64_to_cpus ( & header . incompatible_features ) ;\n be64_to_cpus ( & header . compatible_features ) ;\n be64_to_cpus ( & header . autoclear_features ) ;\n be32_to_cpus ( & header . refcount_order ) ;\n be32_to_cpus ( & header . header_length ) ;\n if ( header . header_length < 104 ) {\n error_setg ( errp , \"qcow2 header too short\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n }\n if ( header . header_length > s -> cluster_size ) {\n error_setg ( errp , \"qcow2 header exceeds cluster size\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n if ( header . header_length > sizeof ( header ) ) {\n s -> unknown_header_fields_size = header . header_length - sizeof ( header ) ;\n s -> unknown_header_fields = g_malloc ( s -> unknown_header_fields_size ) ;\n ret = bdrv_pread ( bs -> file , sizeof ( header ) , s -> unknown_header_fields , s -> unknown_header_fields_size ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read unknown qcow2 header \" \"fields\" ) ;\n goto fail ;\n }\n }\n if ( header . backing_file_offset > s -> cluster_size ) {\n error_setg ( errp , \"Invalid backing file offset\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n if ( header . backing_file_offset ) {\n ext_end = header . backing_file_offset ;\n }\n else {\n ext_end = 1 << header . cluster_bits ;\n }\n s -> incompatible_features = header . incompatible_features ;\n s -> compatible_features = header . compatible_features ;\n s -> autoclear_features = header . autoclear_features ;\n if ( s -> incompatible_features & ~ QCOW2_INCOMPAT_MASK ) {\n void * feature_table = NULL ;\n qcow2_read_extensions ( bs , header . header_length , ext_end , & feature_table , NULL ) ;\n report_unsupported_feature ( bs , errp , feature_table , s -> incompatible_features & ~ QCOW2_INCOMPAT_MASK ) ;\n ret = - ENOTSUP ;\n g_free ( feature_table ) ;\n goto fail ;\n }\n if ( s -> incompatible_features & QCOW2_INCOMPAT_CORRUPT ) {\n if ( ( flags & BDRV_O_RDWR ) && ! ( flags & BDRV_O_CHECK ) ) {\n error_setg ( errp , \"qcow2: Image is corrupt;\n cannot be opened \" \"read/write\" ) ;\n ret = - EACCES ;\n goto fail ;\n }\n }\n if ( header . refcount_order != 4 ) {\n report_unsupported ( bs , errp , \"%d bit reference counts\" , 1 << header . refcount_order ) ;\n ret = - ENOTSUP ;\n goto fail ;\n }\n s -> refcount_order = header . refcount_order ;\n if ( header . crypt_method > QCOW_CRYPT_AES ) {\n error_setg ( errp , \"Unsupported encryption method: %i\" , header . crypt_method ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n s -> crypt_method_header = header . crypt_method ;\n if ( s -> crypt_method_header ) {\n bs -> encrypted = 1 ;\n }\n s -> l2_bits = s -> cluster_bits - 3 ;\n s -> l2_size = 1 << s -> l2_bits ;\n bs -> total_sectors = header . size / 512 ;\n s -> csize_shift = ( 62 - ( s -> cluster_bits - 8 ) ) ;\n s -> csize_mask = ( 1 << ( s -> cluster_bits - 8 ) ) - 1 ;\n s -> cluster_offset_mask = ( 1LL << s -> csize_shift ) - 1 ;\n s -> refcount_table_offset = header . refcount_table_offset ;\n s -> refcount_table_size = header . refcount_table_clusters << ( s -> cluster_bits - 3 ) ;\n if ( header . refcount_table_clusters > qcow2_max_refcount_clusters ( s ) ) {\n error_setg ( errp , \"Reference count table too large\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n ret = validate_table_offset ( bs , s -> refcount_table_offset , s -> refcount_table_size , sizeof ( uint64_t ) ) ;\n if ( ret < 0 ) {\n error_setg ( errp , \"Invalid reference count table offset\" ) ;\n goto fail ;\n }\n if ( header . nb_snapshots > QCOW_MAX_SNAPSHOTS ) {\n error_setg ( errp , \"Too many snapshots\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n ret = validate_table_offset ( bs , header . snapshots_offset , header . nb_snapshots , sizeof ( QCowSnapshotHeader ) ) ;\n if ( ret < 0 ) {\n error_setg ( errp , \"Invalid snapshot table offset\" ) ;\n goto fail ;\n }\n s -> snapshots_offset = header . snapshots_offset ;\n s -> nb_snapshots = header . nb_snapshots ;\n if ( header . l1_size > 0x2000000 ) {\n error_setg ( errp , \"Active L1 table too large\" ) ;\n ret = - EFBIG ;\n goto fail ;\n }\n s -> l1_size = header . l1_size ;\n l1_vm_state_index = size_to_l1 ( s , header . size ) ;\n if ( l1_vm_state_index > INT_MAX ) {\n error_setg ( errp , \"Image is too big\" ) ;\n ret = - EFBIG ;\n goto fail ;\n }\n s -> l1_vm_state_index = l1_vm_state_index ;\n if ( s -> l1_size < s -> l1_vm_state_index ) {\n error_setg ( errp , \"L1 table is too small\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n ret = validate_table_offset ( bs , header . l1_table_offset , header . l1_size , sizeof ( uint64_t ) ) ;\n if ( ret < 0 ) {\n error_setg ( errp , \"Invalid L1 table offset\" ) ;\n goto fail ;\n }\n s -> l1_table_offset = header . l1_table_offset ;\n if ( s -> l1_size > 0 ) {\n s -> l1_table = g_malloc0 ( align_offset ( s -> l1_size * sizeof ( uint64_t ) , 512 ) ) ;\n ret = bdrv_pread ( bs -> file , s -> l1_table_offset , s -> l1_table , s -> l1_size * sizeof ( uint64_t ) ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read L1 table\" ) ;\n goto fail ;\n }\n for ( i = 0 ;\n i < s -> l1_size ;\n i ++ ) {\n be64_to_cpus ( & s -> l1_table [ i ] ) ;\n }\n }\n s -> l2_table_cache = qcow2_cache_create ( bs , L2_CACHE_SIZE ) ;\n s -> refcount_block_cache = qcow2_cache_create ( bs , REFCOUNT_CACHE_SIZE ) ;\n s -> cluster_cache = g_malloc ( s -> cluster_size ) ;\n s -> cluster_data = qemu_blockalign ( bs , QCOW_MAX_CRYPT_CLUSTERS * s -> cluster_size + 512 ) ;\n s -> cluster_cache_offset = - 1 ;\n s -> flags = flags ;\n ret = qcow2_refcount_init ( bs ) ;\n if ( ret != 0 ) {\n error_setg_errno ( errp , - ret , \"Could not initialize refcount handling\" ) ;\n goto fail ;\n }\n QLIST_INIT ( & s -> cluster_allocs ) ;\n QTAILQ_INIT ( & s -> discards ) ;\n if ( qcow2_read_extensions ( bs , header . header_length , ext_end , NULL , & local_err ) ) {\n error_propagate ( errp , local_err ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n if ( header . backing_file_offset != 0 ) {\n len = header . backing_file_size ;\n if ( len > MIN ( 1023 , s -> cluster_size - header . backing_file_offset ) ) {\n error_setg ( errp , \"Backing file name too long\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n ret = bdrv_pread ( bs -> file , header . backing_file_offset , bs -> backing_file , len ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read backing file name\" ) ;\n goto fail ;\n }\n bs -> backing_file [ len ] = '\\0' ;\n }\n ret = qcow2_read_snapshots ( bs ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not read snapshots\" ) ;\n goto fail ;\n }\n if ( ! bs -> read_only && ! ( flags & BDRV_O_INCOMING ) && s -> autoclear_features ) {\n s -> autoclear_features = 0 ;\n ret = qcow2_update_header ( bs ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not update qcow2 header\" ) ;\n goto fail ;\n }\n }\n qemu_co_mutex_init ( & s -> lock ) ;\n if ( ! ( flags & ( BDRV_O_CHECK | BDRV_O_INCOMING ) ) && ! bs -> read_only && ( s -> incompatible_features & QCOW2_INCOMPAT_DIRTY ) ) {\n BdrvCheckResult result = {\n 0 }\n ;\n ret = qcow2_check ( bs , & result , BDRV_FIX_ERRORS ) ;\n if ( ret < 0 ) {\n error_setg_errno ( errp , - ret , \"Could not repair dirty image\" ) ;\n goto fail ;\n }\n }\n opts = qemu_opts_create ( & qcow2_runtime_opts , NULL , 0 , & error_abort ) ;\n qemu_opts_absorb_qdict ( opts , options , & local_err ) ;\n if ( local_err ) {\n error_propagate ( errp , local_err ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n s -> use_lazy_refcounts = qemu_opt_get_bool ( opts , QCOW2_OPT_LAZY_REFCOUNTS , ( s -> compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS ) ) ;\n s -> discard_passthrough [ QCOW2_DISCARD_NEVER ] = false ;\n s -> discard_passthrough [ QCOW2_DISCARD_ALWAYS ] = true ;\n s -> discard_passthrough [ QCOW2_DISCARD_REQUEST ] = qemu_opt_get_bool ( opts , QCOW2_OPT_DISCARD_REQUEST , flags & BDRV_O_UNMAP ) ;\n s -> discard_passthrough [ QCOW2_DISCARD_SNAPSHOT ] = qemu_opt_get_bool ( opts , QCOW2_OPT_DISCARD_SNAPSHOT , true ) ;\n s -> discard_passthrough [ QCOW2_DISCARD_OTHER ] = qemu_opt_get_bool ( opts , QCOW2_OPT_DISCARD_OTHER , false ) ;\n opt_overlap_check = qemu_opt_get ( opts , \"overlap-check\" ) ? : \"cached\" ;\n if ( ! strcmp ( opt_overlap_check , \"none\" ) ) {\n overlap_check_template = 0 ;\n }\n else if ( ! strcmp ( opt_overlap_check , \"constant\" ) ) {\n overlap_check_template = QCOW2_OL_CONSTANT ;\n }\n else if ( ! strcmp ( opt_overlap_check , \"cached\" ) ) {\n overlap_check_template = QCOW2_OL_CACHED ;\n }\n else if ( ! strcmp ( opt_overlap_check , \"all\" ) ) {\n overlap_check_template = QCOW2_OL_ALL ;\n }\n else {\n error_setg ( errp , \"Unsupported value '%s' for qcow2 option \" \"'overlap-check'. Allowed are either of the following: \" \"none, constant, cached, all\" , opt_overlap_check ) ;\n qemu_opts_del ( opts ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n s -> overlap_check = 0 ;\n for ( i = 0 ;\n i < QCOW2_OL_MAX_BITNR ;\n i ++ ) {\n s -> overlap_check |= qemu_opt_get_bool ( opts , overlap_bool_option_names [ i ] , overlap_check_template & ( 1 << i ) ) << i ;\n }\n qemu_opts_del ( opts ) ;\n if ( s -> use_lazy_refcounts && s -> qcow_version < 3 ) {\n error_setg ( errp , \"Lazy refcounts require a qcow2 image with at least \" \"qemu 1.1 compatibility level\" ) ;\n ret = - EINVAL ;\n goto fail ;\n }\n # ifdef DEBUG_ALLOC {\n BdrvCheckResult result = {\n 0 }\n ;\n qcow2_check_refcounts ( bs , & result , 0 ) ;\n }\n # endif return ret ;\n fail : g_free ( s -> unknown_header_fields ) ;\n cleanup_unknown_header_ext ( bs ) ;\n qcow2_free_snapshots ( bs ) ;\n qcow2_refcount_close ( bs ) ;\n g_free ( s -> l1_table ) ;\n s -> l1_table = NULL ;\n if ( s -> l2_table_cache ) {\n qcow2_cache_destroy ( bs , s -> l2_table_cache ) ;\n }\n if ( s -> refcount_block_cache ) {\n qcow2_cache_destroy ( bs , s -> refcount_block_cache ) ;\n }\n g_free ( s -> cluster_cache ) ;\n qemu_vfree ( s -> cluster_data ) ;\n return ret ;\n }",
        "hash": 3298403829257765374,
        "project": "debian",
        "size": 316,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int qcow2_open ( BlockDriverState * bs , QDict * options , int flags , Error * * errp ) {\n"
                ],
                [
                    252,
                    " if ( local_err ) {\n"
                ],
                [
                    263,
                    " opt_overlap_check = qemu_opt_get ( opts , \"overlap-check\" ) ? : \"cached\" ;\n"
                ],
                [
                    264,
                    " if ( ! strcmp ( opt_overlap_check , \"none\" ) ) {\n"
                ],
                [
                    265,
                    " overlap_check_template = 0 ;\n"
                ],
                [
                    267,
                    " else if ( ! strcmp ( opt_overlap_check , \"constant\" ) ) {\n"
                ],
                [
                    268,
                    " overlap_check_template = QCOW2_OL_CONSTANT ;\n"
                ],
                [
                    270,
                    " else if ( ! strcmp ( opt_overlap_check , \"cached\" ) ) {\n"
                ],
                [
                    271,
                    " overlap_check_template = QCOW2_OL_CACHED ;\n"
                ],
                [
                    273,
                    " else if ( ! strcmp ( opt_overlap_check , \"all\" ) ) {\n"
                ],
                [
                    274,
                    " overlap_check_template = QCOW2_OL_ALL ;\n"
                ],
                [
                    277,
                    " error_setg ( errp , \"Unsupported value '%s' for qcow2 option \" \"'overlap-check'. Allowed are either of the following: \" \"none, constant, cached, all\" , opt_overlap_check ) ;\n"
                ],
                [
                    278,
                    " qemu_opts_del ( opts ) ;\n"
                ],
                [
                    279,
                    " ret = - EINVAL ;\n"
                ],
                [
                    282,
                    " s -> overlap_check = 0 ;\n"
                ],
                [
                    283,
                    " for ( i = 0 ;\n"
                ],
                [
                    284,
                    " i < QCOW2_OL_MAX_BITNR ;\n"
                ],
                [
                    288,
                    " qemu_opts_del ( opts ) ;\n"
                ],
                [
                    289,
                    " if ( s -> use_lazy_refcounts && s -> qcow_version < 3 ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int qcow2_open ( BlockDriverState * bs , QDict * options , int flags , Error * * errp ) {\n"
                ],
                [
                    252,
                    " if ( local_err ) {\n"
                ],
                [
                    263,
                    " opt_overlap_check = qemu_opt_get ( opts , \"overlap-check\" ) ? : \"cached\" ;\n"
                ],
                [
                    264,
                    " if ( ! strcmp ( opt_overlap_check , \"none\" ) ) {\n"
                ],
                [
                    265,
                    " overlap_check_template = 0 ;\n"
                ],
                [
                    267,
                    " else if ( ! strcmp ( opt_overlap_check , \"constant\" ) ) {\n"
                ],
                [
                    268,
                    " overlap_check_template = QCOW2_OL_CONSTANT ;\n"
                ],
                [
                    270,
                    " else if ( ! strcmp ( opt_overlap_check , \"cached\" ) ) {\n"
                ],
                [
                    271,
                    " overlap_check_template = QCOW2_OL_CACHED ;\n"
                ],
                [
                    273,
                    " else if ( ! strcmp ( opt_overlap_check , \"all\" ) ) {\n"
                ],
                [
                    274,
                    " overlap_check_template = QCOW2_OL_ALL ;\n"
                ],
                [
                    277,
                    " error_setg ( errp , \"Unsupported value '%s' for qcow2 option \" \"'overlap-check'. Allowed are either of the following: \" \"none, constant, cached, all\" , opt_overlap_check ) ;\n"
                ],
                [
                    278,
                    " qemu_opts_del ( opts ) ;\n"
                ],
                [
                    279,
                    " ret = - EINVAL ;\n"
                ],
                [
                    282,
                    " s -> overlap_check = 0 ;\n"
                ],
                [
                    283,
                    " for ( i = 0 ;\n"
                ],
                [
                    284,
                    " i < QCOW2_OL_MAX_BITNR ;\n"
                ],
                [
                    288,
                    " qemu_opts_del ( opts ) ;\n"
                ],
                [
                    289,
                    " if ( s -> use_lazy_refcounts && s -> qcow_version < 3 ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static int remoteStreamHandleFinish ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n remote_error rerr ;\n int ret ;\n VIR_DEBUG ( \"stream=%p proc=%d serial=%d\" , stream , msg -> hdr . proc , msg -> hdr . serial ) ;\n memset ( & rerr , 0 , sizeof rerr ) ;\n stream -> closed = 1 ;\n virStreamEventRemoveCallback ( stream -> st ) ;\n ret = virStreamFinish ( stream -> st ) ;\n if ( ret < 0 ) {\n remoteDispatchConnError ( & rerr , client -> conn ) ;\n return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n }\n else {\n if ( remoteSendStreamData ( client , stream , NULL , 0 ) < 0 ) return - 1 ;\n }\n return 0 ;\n }",
        "hash": 7320640583188908680,
        "project": "debian",
        "size": 17,
        "slice": {
            "memset": [
                [
                    1,
                    "static int remoteStreamHandleFinish ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n"
                ],
                [
                    5,
                    " memset ( & rerr , 0 , sizeof rerr ) ;\n"
                ],
                [
                    10,
                    " remoteDispatchConnError ( & rerr , client -> conn ) ;\n"
                ],
                [
                    11,
                    " return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int remoteStreamHandleFinish ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n"
                ],
                [
                    5,
                    " memset ( & rerr , 0 , sizeof rerr ) ;\n"
                ],
                [
                    10,
                    " remoteDispatchConnError ( & rerr , client -> conn ) ;\n"
                ],
                [
                    11,
                    " return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int remoteStreamHandleRead ( struct qemud_client * client , struct qemud_client_stream * stream ) {\n char * buffer ;\n size_t bufferLen = REMOTE_MESSAGE_PAYLOAD_MAX ;\n int ret ;\n VIR_DEBUG ( \"stream=%p\" , stream ) ;\n if ( ! stream -> tx ) return 0 ;\n if ( VIR_ALLOC_N ( buffer , bufferLen ) < 0 ) return - 1 ;\n ret = virStreamRecv ( stream -> st , buffer , bufferLen ) ;\n if ( ret == - 2 ) {\n ret = 0 ;\n }\n else if ( ret < 0 ) {\n remote_error rerr ;\n memset ( & rerr , 0 , sizeof rerr ) ;\n remoteDispatchConnError ( & rerr , NULL ) ;\n ret = remoteSerializeStreamError ( client , & rerr , stream -> procedure , stream -> serial ) ;\n }\n else {\n stream -> tx = 0 ;\n if ( ret == 0 ) stream -> recvEOF = 1 ;\n ret = remoteSendStreamData ( client , stream , buffer , ret ) ;\n }\n VIR_FREE ( buffer ) ;\n return ret ;\n }",
        "hash": 7320640583188908680,
        "project": "debian",
        "size": 25,
        "slice": {
            "memset": [
                [
                    1,
                    "static int remoteStreamHandleRead ( struct qemud_client * client , struct qemud_client_stream * stream ) {\n"
                ],
                [
                    12,
                    " else if ( ret < 0 ) {\n"
                ],
                [
                    14,
                    " memset ( & rerr , 0 , sizeof rerr ) ;\n"
                ],
                [
                    15,
                    " remoteDispatchConnError ( & rerr , NULL ) ;\n"
                ],
                [
                    16,
                    " ret = remoteSerializeStreamError ( client , & rerr , stream -> procedure , stream -> serial ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int remoteStreamHandleRead ( struct qemud_client * client , struct qemud_client_stream * stream ) {\n"
                ],
                [
                    12,
                    " else if ( ret < 0 ) {\n"
                ],
                [
                    14,
                    " memset ( & rerr , 0 , sizeof rerr ) ;\n"
                ],
                [
                    15,
                    " remoteDispatchConnError ( & rerr , NULL ) ;\n"
                ],
                [
                    16,
                    " ret = remoteSerializeStreamError ( client , & rerr , stream -> procedure , stream -> serial ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int remoteStreamHandleWriteData ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n remote_error rerr ;\n int ret ;\n VIR_DEBUG ( \"stream=%p proc=%d serial=%d len=%d offset=%d\" , stream , msg -> hdr . proc , msg -> hdr . serial , msg -> bufferLength , msg -> bufferOffset ) ;\n memset ( & rerr , 0 , sizeof rerr ) ;\n ret = virStreamSend ( stream -> st , msg -> buffer + msg -> bufferOffset , msg -> bufferLength - msg -> bufferOffset ) ;\n if ( ret > 0 ) {\n msg -> bufferOffset += ret ;\n if ( msg -> bufferOffset < msg -> bufferLength ) return 1 ;\n }\n else if ( ret == - 2 ) {\n return 1 ;\n }\n else {\n VIR_INFO0 ( \"Stream send failed\" ) ;\n stream -> closed = 1 ;\n remoteDispatchConnError ( & rerr , client -> conn ) ;\n return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n }\n return 0 ;\n }",
        "hash": 7320640583188908680,
        "project": "debian",
        "size": 21,
        "slice": {
            "memset": [
                [
                    1,
                    "static int remoteStreamHandleWriteData ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n"
                ],
                [
                    5,
                    " memset ( & rerr , 0 , sizeof rerr ) ;\n"
                ],
                [
                    17,
                    " remoteDispatchConnError ( & rerr , client -> conn ) ;\n"
                ],
                [
                    18,
                    " return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int remoteStreamHandleWriteData ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n"
                ],
                [
                    5,
                    " memset ( & rerr , 0 , sizeof rerr ) ;\n"
                ],
                [
                    17,
                    " remoteDispatchConnError ( & rerr , client -> conn ) ;\n"
                ],
                [
                    18,
                    " return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void bamboo_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n unsigned int pci_irq_nrs [ 4 ] = {\n 28 , 27 , 26 , 25 }\n ;\n PCIBus * pcibus ;\n CPUState * env ;\n uint64_t elf_entry ;\n uint64_t elf_lowaddr ;\n target_phys_addr_t entry = 0 ;\n target_phys_addr_t loadaddr = 0 ;\n target_long kernel_size = 0 ;\n target_ulong initrd_base = 0 ;\n target_long initrd_size = 0 ;\n target_ulong dt_base = 0 ;\n void * fdt ;\n int i ;\n env = ppc440ep_init ( & ram_size , & pcibus , pci_irq_nrs , 1 , cpu_model ) ;\n if ( pcibus ) {\n for ( i = 0 ;\n i < MAX_VIRTIO_CONSOLES ;\n i ++ ) {\n if ( virtcon_hds [ i ] ) {\n pci_create_simple ( pcibus , - 1 , \"virtio-console-pci\" ) ;\n }\n }\n for ( i = 0 ;\n i < nb_nics ;\n i ++ ) {\n pci_nic_init_nofail ( & nd_table [ i ] , \"e1000\" , NULL ) ;\n }\n }\n if ( kernel_filename ) {\n kernel_size = load_uimage ( kernel_filename , & entry , & loadaddr , NULL ) ;\n if ( kernel_size < 0 ) {\n kernel_size = load_elf ( kernel_filename , 0 , & elf_entry , & elf_lowaddr , NULL , 1 , ELF_MACHINE , 0 ) ;\n entry = elf_entry ;\n loadaddr = elf_lowaddr ;\n }\n if ( kernel_size < 0 ) {\n fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n exit ( 1 ) ;\n }\n }\n if ( initrd_filename ) {\n initrd_base = kernel_size + loadaddr ;\n initrd_size = load_image_targphys ( initrd_filename , initrd_base , ram_size - initrd_base ) ;\n if ( initrd_size < 0 ) {\n fprintf ( stderr , \"qemu: could not load initial ram disk '%s'\\n\" , initrd_filename ) ;\n exit ( 1 ) ;\n }\n }\n if ( kernel_filename ) {\n if ( initrd_base ) dt_base = initrd_base + initrd_size ;\n else dt_base = kernel_size + loadaddr ;\n fdt = bamboo_load_device_tree ( dt_base , ram_size , initrd_base , initrd_size , kernel_cmdline ) ;\n if ( fdt == NULL ) {\n fprintf ( stderr , \"couldn't load device tree\\n\" ) ;\n exit ( 1 ) ;\n }\n env -> gpr [ 1 ] = ( 16 << 20 ) - 8 ;\n env -> gpr [ 3 ] = dt_base ;\n env -> nip = entry ;\n }\n if ( kvm_enabled ( ) ) kvmppc_init ( ) ;\n }",
        "hash": 6910889735724933479,
        "project": "debian",
        "size": 65,
        "slice": {
            "fprintf": [
                [
                    1,
                    "static void bamboo_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n"
                ],
                [
                    33,
                    " kernel_size = load_uimage ( kernel_filename , & entry , & loadaddr , NULL ) ;\n"
                ],
                [
                    35,
                    " kernel_size = load_elf ( kernel_filename , 0 , & elf_entry , & elf_lowaddr , NULL , 1 , ELF_MACHINE , 0 ) ;\n"
                ],
                [
                    39,
                    " if ( kernel_size < 0 ) {\n"
                ],
                [
                    40,
                    " fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n"
                ],
                [
                    46,
                    " initrd_size = load_image_targphys ( initrd_filename , initrd_base , ram_size - initrd_base ) ;\n"
                ],
                [
                    47,
                    " if ( initrd_size < 0 ) {\n"
                ],
                [
                    48,
                    " fprintf ( stderr , \"qemu: could not load initial ram disk '%s'\\n\" , initrd_filename ) ;\n"
                ],
                [
                    56,
                    " if ( fdt == NULL ) {\n"
                ],
                [
                    57,
                    " fprintf ( stderr , \"couldn't load device tree\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void bamboo_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n"
                ],
                [
                    33,
                    " kernel_size = load_uimage ( kernel_filename , & entry , & loadaddr , NULL ) ;\n"
                ],
                [
                    35,
                    " kernel_size = load_elf ( kernel_filename , 0 , & elf_entry , & elf_lowaddr , NULL , 1 , ELF_MACHINE , 0 ) ;\n"
                ],
                [
                    39,
                    " if ( kernel_size < 0 ) {\n"
                ],
                [
                    40,
                    " fprintf ( stderr , \"qemu: could not load kernel '%s'\\n\" , kernel_filename ) ;\n"
                ],
                [
                    46,
                    " initrd_size = load_image_targphys ( initrd_filename , initrd_base , ram_size - initrd_base ) ;\n"
                ],
                [
                    47,
                    " if ( initrd_size < 0 ) {\n"
                ],
                [
                    48,
                    " fprintf ( stderr , \"qemu: could not load initial ram disk '%s'\\n\" , initrd_filename ) ;\n"
                ],
                [
                    56,
                    " if ( fdt == NULL ) {\n"
                ],
                [
                    57,
                    " fprintf ( stderr , \"couldn't load device tree\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n CPUState * env = NULL ;\n ram_addr_t ram_addr ;\n ram_addr_t kernel_size = 0 ;\n ram_addr_t initrd_offset ;\n ram_addr_t initrd_size = 0 ;\n int i ;\n if ( ! kvm_enabled ( ) ) {\n fprintf ( stderr , \"The S390 target only works with KVM enabled\\n\" ) ;\n exit ( 1 ) ;\n }\n s390_bus = s390_virtio_bus_init ( & ram_size ) ;\n ram_addr = qemu_ram_alloc ( ram_size ) ;\n cpu_register_physical_memory ( 0 , ram_size , ram_addr ) ;\n if ( cpu_model == NULL ) {\n cpu_model = \"host\" ;\n }\n ipi_states = qemu_malloc ( sizeof ( CPUState * ) * smp_cpus ) ;\n for ( i = 0 ;\n i < smp_cpus ;\n i ++ ) {\n CPUState * tmp_env ;\n tmp_env = cpu_init ( cpu_model ) ;\n if ( ! env ) {\n env = tmp_env ;\n }\n ipi_states [ i ] = tmp_env ;\n tmp_env -> halted = 1 ;\n tmp_env -> exception_index = EXCP_HLT ;\n }\n env -> halted = 0 ;\n env -> exception_index = 0 ;\n if ( kernel_filename ) {\n kernel_size = load_image ( kernel_filename , qemu_get_ram_ptr ( 0 ) ) ;\n if ( lduw_phys ( KERN_IMAGE_START ) != 0x0dd0 ) {\n fprintf ( stderr , \"Specified image is not an s390 boot image\\n\" ) ;\n exit ( 1 ) ;\n }\n cpu_synchronize_state ( env ) ;\n env -> psw . addr = KERN_IMAGE_START ;\n env -> psw . mask = 0x0000000180000000ULL ;\n }\n if ( initrd_filename ) {\n initrd_offset = INITRD_START ;\n while ( kernel_size + 0x100000 > initrd_offset ) {\n initrd_offset += 0x100000 ;\n }\n initrd_size = load_image ( initrd_filename , qemu_get_ram_ptr ( initrd_offset ) ) ;\n stq_phys ( INITRD_PARM_START , initrd_offset ) ;\n stq_phys ( INITRD_PARM_SIZE , initrd_size ) ;\n }\n if ( kernel_cmdline ) {\n cpu_physical_memory_rw ( KERN_PARM_AREA , ( uint8_t * ) kernel_cmdline , strlen ( kernel_cmdline ) , 1 ) ;\n }\n for ( i = 0 ;\n i < MAX_VIRTIO_CONSOLES ;\n i ++ ) {\n if ( virtcon_hds [ i ] ) {\n qdev_init_nofail ( qdev_create ( ( BusState * ) s390_bus , \"virtio-console-s390\" ) ) ;\n }\n }\n for ( i = 0 ;\n i < nb_nics ;\n i ++ ) {\n NICInfo * nd = & nd_table [ i ] ;\n DeviceState * dev ;\n if ( ! nd -> model ) {\n nd -> model = qemu_strdup ( \"virtio\" ) ;\n }\n if ( strcmp ( nd -> model , \"virtio\" ) ) {\n fprintf ( stderr , \"S390 only supports VirtIO nics\\n\" ) ;\n exit ( 1 ) ;\n }\n dev = qdev_create ( ( BusState * ) s390_bus , \"virtio-net-s390\" ) ;\n qdev_set_nic_properties ( dev , nd ) ;\n qdev_init_nofail ( dev ) ;\n }\n for ( i = 0 ;\n i < MAX_BLK_DEVS ;\n i ++ ) {\n DriveInfo * dinfo ;\n DeviceState * dev ;\n dinfo = drive_get ( IF_IDE , 0 , i ) ;\n if ( ! dinfo ) {\n continue ;\n }\n dev = qdev_create ( ( BusState * ) s390_bus , \"virtio-blk-s390\" ) ;\n qdev_prop_set_drive ( dev , \"drive\" , dinfo ) ;\n qdev_init_nofail ( dev ) ;\n }\n }",
        "hash": -5018047422955641881,
        "project": "debian",
        "size": 91,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n"
                ],
                [
                    63,
                    " i < nb_nics ;\n"
                ],
                [
                    65,
                    " NICInfo * nd = & nd_table [ i ] ;\n"
                ],
                [
                    67,
                    " if ( ! nd -> model ) {\n"
                ],
                [
                    68,
                    " nd -> model = qemu_strdup ( \"virtio\" ) ;\n"
                ],
                [
                    70,
                    " if ( strcmp ( nd -> model , \"virtio\" ) ) {\n"
                ],
                [
                    71,
                    " fprintf ( stderr , \"S390 only supports VirtIO nics\\n\" ) ;\n"
                ],
                [
                    72,
                    " exit ( 1 ) ;\n"
                ],
                [
                    75,
                    " qdev_set_nic_properties ( dev , nd ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n"
                ],
                [
                    52,
                    " if ( kernel_cmdline ) {\n"
                ],
                [
                    53,
                    " cpu_physical_memory_rw ( KERN_PARM_AREA , ( uint8_t * ) kernel_cmdline , strlen ( kernel_cmdline ) , 1 ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n"
                ],
                [
                    8,
                    " if ( ! kvm_enabled ( ) ) {\n"
                ],
                [
                    9,
                    " fprintf ( stderr , \"The S390 target only works with KVM enabled\\n\" ) ;\n"
                ],
                [
                    35,
                    " if ( lduw_phys ( KERN_IMAGE_START ) != 0x0dd0 ) {\n"
                ],
                [
                    36,
                    " fprintf ( stderr , \"Specified image is not an s390 boot image\\n\" ) ;\n"
                ],
                [
                    70,
                    " if ( strcmp ( nd -> model , \"virtio\" ) ) {\n"
                ],
                [
                    71,
                    " fprintf ( stderr , \"S390 only supports VirtIO nics\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n"
                ],
                [
                    8,
                    " if ( ! kvm_enabled ( ) ) {\n"
                ],
                [
                    9,
                    " fprintf ( stderr , \"The S390 target only works with KVM enabled\\n\" ) ;\n"
                ],
                [
                    35,
                    " if ( lduw_phys ( KERN_IMAGE_START ) != 0x0dd0 ) {\n"
                ],
                [
                    36,
                    " fprintf ( stderr , \"Specified image is not an s390 boot image\\n\" ) ;\n"
                ],
                [
                    52,
                    " if ( kernel_cmdline ) {\n"
                ],
                [
                    53,
                    " cpu_physical_memory_rw ( KERN_PARM_AREA , ( uint8_t * ) kernel_cmdline , strlen ( kernel_cmdline ) , 1 ) ;\n"
                ],
                [
                    63,
                    " i < nb_nics ;\n"
                ],
                [
                    65,
                    " NICInfo * nd = & nd_table [ i ] ;\n"
                ],
                [
                    67,
                    " if ( ! nd -> model ) {\n"
                ],
                [
                    68,
                    " nd -> model = qemu_strdup ( \"virtio\" ) ;\n"
                ],
                [
                    70,
                    " if ( strcmp ( nd -> model , \"virtio\" ) ) {\n"
                ],
                [
                    71,
                    " fprintf ( stderr , \"S390 only supports VirtIO nics\\n\" ) ;\n"
                ],
                [
                    72,
                    " exit ( 1 ) ;\n"
                ],
                [
                    75,
                    " qdev_set_nic_properties ( dev , nd ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "libc_hidden_proto ( __printf_fp ) extern unsigned int __guess_grouping ( unsigned int intdig_max , const char * grouping , wchar_t sepchar ) ;\n ssize_t __vstrfmon_l ( char * s , size_t maxsize , __locale_t loc , const char * format , va_list ap ) {\n struct locale_data * current = loc -> __locales [ LC_MONETARY ] ;\n _IO_strfile f ;\n # ifdef _IO_MTSAFE_IO _IO_lock_t lock ;\n # endif struct printf_info info ;\n char * dest ;\n const char * fmt ;\n dest = s ;\n fmt = format ;\n while ( * fmt != '\\0' ) {\n union {\n double dbl ;\n __long_double_t ldbl ;\n }\n fpnum ;\n int int_format ;\n int print_curr_symbol ;\n int left_prec ;\n int left_pad ;\n int right_prec ;\n int group ;\n char pad ;\n int is_long_double ;\n int p_sign_posn ;\n int n_sign_posn ;\n int sign_posn ;\n int other_sign_posn ;\n int left ;\n int is_negative ;\n int sep_by_space ;\n int other_sep_by_space ;\n int cs_precedes ;\n int other_cs_precedes ;\n const char * sign_string ;\n const char * other_sign_string ;\n int done ;\n const char * currency_symbol ;\n size_t currency_symbol_len ;\n int width ;\n char * startp ;\n const void * ptr ;\n char space_char ;\n if ( * fmt != '%' ) {\n out_char ( * fmt ++ ) ;\n continue ;\n }\n if ( fmt [ 1 ] == '%' ) {\n out_char ( * ++ fmt ) ;\n ++ fmt ;\n continue ;\n }\n int_format = 0 ;\n print_curr_symbol = 1 ;\n left_prec = - 1 ;\n right_prec = - 1 ;\n group = 1 ;\n pad = ' ' ;\n is_long_double = 0 ;\n p_sign_posn = - 1 ;\n n_sign_posn = - 1 ;\n width = - 1 ;\n left = 0 ;\n while ( 1 ) {\n switch ( * ++ fmt ) {\n case '=' : pad = * ++ fmt ;\n if ( pad == '\\0' ) {\n __set_errno ( EINVAL ) ;\n return - 1 ;\n }\n continue ;\n case '^' : group = 0 ;\n continue ;\n case '+' : if ( n_sign_posn != - 1 ) {\n __set_errno ( EINVAL ) ;\n return - 1 ;\n }\n p_sign_posn = * _NL_CURRENT ( LC_MONETARY , P_SIGN_POSN ) ;\n n_sign_posn = * _NL_CURRENT ( LC_MONETARY , N_SIGN_POSN ) ;\n continue ;\n case '(' : if ( n_sign_posn != - 1 ) {\n __set_errno ( EINVAL ) ;\n return - 1 ;\n }\n p_sign_posn = 0 ;\n n_sign_posn = 0 ;\n continue ;\n case '!' : print_curr_symbol = 0 ;\n continue ;\n case '-' : left = 1 ;\n continue ;\n default : ;\n }\n break ;\n }\n if ( isdigit ( * fmt ) ) {\n width = to_digit ( * fmt ) ;\n while ( isdigit ( * ++ fmt ) ) {\n width *= 10 ;\n width += to_digit ( * fmt ) ;\n }\n if ( dest + width >= s + maxsize ) {\n __set_errno ( E2BIG ) ;\n return - 1 ;\n }\n }\n if ( * fmt == '#' ) {\n if ( ! isdigit ( * ++ fmt ) ) {\n __set_errno ( EINVAL ) ;\n return - 1 ;\n }\n left_prec = to_digit ( * fmt ) ;\n while ( isdigit ( * ++ fmt ) ) {\n left_prec *= 10 ;\n left_prec += to_digit ( * fmt ) ;\n }\n }\n if ( * fmt == '.' ) {\n if ( ! isdigit ( * ++ fmt ) ) {\n __set_errno ( EINVAL ) ;\n return - 1 ;\n }\n right_prec = to_digit ( * fmt ) ;\n while ( isdigit ( * ++ fmt ) ) {\n right_prec *= 10 ;\n right_prec += to_digit ( * fmt ) ;\n }\n }\n if ( * fmt == 'L' ) {\n ++ fmt ;\n if ( ! __ldbl_is_dbl ) is_long_double = 1 ;\n }\n char int_symbol [ 4 ] ;\n switch ( * fmt ++ ) {\n case 'i' : {\n const char * int_curr_symbol ;\n int_curr_symbol = _NL_CURRENT ( LC_MONETARY , INT_CURR_SYMBOL ) ;\n strncpy ( int_symbol , int_curr_symbol , 3 ) ;\n int_symbol [ 3 ] = '\\0' ;\n currency_symbol_len = 3 ;\n currency_symbol = & int_symbol [ 0 ] ;\n space_char = int_curr_symbol [ 3 ] ;\n int_format = 1 ;\n break ;\n }\n case 'n' : currency_symbol = _NL_CURRENT ( LC_MONETARY , CURRENCY_SYMBOL ) ;\n currency_symbol_len = strlen ( currency_symbol ) ;\n space_char = ' ' ;\n int_format = 0 ;\n break ;\n default : __set_errno ( EINVAL ) ;\n return - 1 ;\n }\n if ( p_sign_posn == - 1 ) p_sign_posn = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_P_SIGN_POSN : P_SIGN_POSN ) ;\n if ( n_sign_posn == - 1 ) n_sign_posn = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_N_SIGN_POSN : N_SIGN_POSN ) ;\n if ( right_prec == - 1 ) {\n right_prec = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_FRAC_DIGITS : FRAC_DIGITS ) ;\n if ( right_prec == CHAR_MAX ) right_prec = 2 ;\n }\n if ( group && left_prec != - 1 ) left_prec += __guess_grouping ( left_prec , _NL_CURRENT ( LC_MONETARY , MON_GROUPING ) , * _NL_CURRENT ( LC_MONETARY , MON_THOUSANDS_SEP ) ) ;\n if ( is_long_double == 1 ) {\n fpnum . ldbl = va_arg ( ap , long double ) ;\n is_negative = fpnum . ldbl < 0 ;\n if ( is_negative ) fpnum . ldbl = - fpnum . ldbl ;\n }\n else {\n fpnum . dbl = va_arg ( ap , double ) ;\n is_negative = fpnum . dbl < 0 ;\n if ( is_negative ) fpnum . dbl = - fpnum . dbl ;\n }\n if ( is_negative ) {\n sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n if ( * sign_string == '\\0' ) sign_string = ( const char * ) \"-\" ;\n cs_precedes = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_N_CS_PRECEDES : N_CS_PRECEDES ) ;\n sep_by_space = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_N_SEP_BY_SPACE : N_SEP_BY_SPACE ) ;\n sign_posn = n_sign_posn ;\n other_sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n other_cs_precedes = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_P_CS_PRECEDES : P_CS_PRECEDES ) ;\n other_sep_by_space = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_P_SEP_BY_SPACE : P_SEP_BY_SPACE ) ;\n other_sign_posn = p_sign_posn ;\n }\n else {\n sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n cs_precedes = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_P_CS_PRECEDES : P_CS_PRECEDES ) ;\n sep_by_space = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_P_SEP_BY_SPACE : P_SEP_BY_SPACE ) ;\n sign_posn = p_sign_posn ;\n other_sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n if ( * other_sign_string == '\\0' ) other_sign_string = ( const char * ) \"-\" ;\n other_cs_precedes = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_N_CS_PRECEDES : N_CS_PRECEDES ) ;\n other_sep_by_space = * _NL_CURRENT ( LC_MONETARY , int_format ? INT_N_SEP_BY_SPACE : N_SEP_BY_SPACE ) ;\n other_sign_posn = n_sign_posn ;\n }\n if ( cs_precedes != 0 ) cs_precedes = 1 ;\n if ( other_cs_precedes != 0 ) other_cs_precedes = 1 ;\n if ( sep_by_space == CHAR_MAX ) sep_by_space = 0 ;\n if ( other_sep_by_space == CHAR_MAX ) other_sep_by_space = 0 ;\n if ( sign_posn == CHAR_MAX ) sign_posn = 1 ;\n if ( other_sign_posn == CHAR_MAX ) other_sign_posn = 1 ;\n if ( sep_by_space == 2 ) {\n if ( sign_posn == 0 || ( sign_posn == 1 && ! cs_precedes ) || ( sign_posn == 2 && cs_precedes ) ) sep_by_space = 0 ;\n }\n if ( other_sep_by_space == 2 ) {\n if ( other_sign_posn == 0 || ( other_sign_posn == 1 && ! other_cs_precedes ) || ( other_sign_posn == 2 && other_cs_precedes ) ) other_sep_by_space = 0 ;\n }\n if ( left_prec == - 1 ) {\n left_prec = 0 ;\n left_pad = 0 ;\n }\n else {\n int left_bytes = 0 ;\n int other_left_bytes = 0 ;\n if ( cs_precedes ) {\n left_bytes += currency_symbol_len ;\n if ( sep_by_space != 0 ) ++ left_bytes ;\n }\n if ( other_cs_precedes ) {\n other_left_bytes += currency_symbol_len ;\n if ( other_sep_by_space != 0 ) ++ other_left_bytes ;\n }\n if ( sign_posn == 0 && is_negative ) ++ left_bytes ;\n else if ( sign_posn == 1 ) left_bytes += strlen ( sign_string ) ;\n else if ( cs_precedes && ( sign_posn == 3 || sign_posn == 4 ) ) left_bytes += strlen ( sign_string ) ;\n if ( other_sign_posn == 0 && ! is_negative ) ++ other_left_bytes ;\n else if ( other_sign_posn == 1 ) other_left_bytes += strlen ( other_sign_string ) ;\n else if ( other_cs_precedes && ( other_sign_posn == 3 || other_sign_posn == 4 ) ) other_left_bytes += strlen ( other_sign_string ) ;\n if ( other_left_bytes > left_bytes ) left_pad = other_left_bytes - left_bytes ;\n else left_pad = 0 ;\n }\n # define left_paren '(' # define right_paren ')' startp = dest ;\n while ( left_pad -- > 0 ) out_char ( ' ' ) ;\n if ( sign_posn == 0 && is_negative ) out_char ( left_paren ) ;\n if ( cs_precedes ) {\n if ( sign_posn != 0 && sign_posn != 2 && sign_posn != 4 && sign_posn != 5 ) {\n out_string ( sign_string ) ;\n if ( sep_by_space == 2 ) out_char ( ' ' ) ;\n }\n if ( print_curr_symbol ) out_string ( currency_symbol ) ;\n if ( sign_posn == 4 ) {\n if ( print_curr_symbol && sep_by_space == 2 ) out_char ( space_char ) ;\n out_string ( sign_string ) ;\n if ( sep_by_space == 1 ) out_char ( ' ' ) ;\n }\n else if ( print_curr_symbol && sep_by_space == 1 ) out_char ( space_char ) ;\n }\n else if ( sign_posn != 0 && sign_posn != 2 && sign_posn != 3 && sign_posn != 4 && sign_posn != 5 ) out_string ( sign_string ) ;\n # ifdef _IO_MTSAFE_IO f . _sbf . _f . _lock = & lock ;\n # endif INTUSE ( _IO_init ) ( ( _IO_FILE * ) & f , 0 ) ;\n _IO_JUMPS ( ( struct _IO_FILE_plus * ) & f ) = & _IO_str_jumps ;\n INTUSE ( _IO_str_init_static ) ( ( _IO_strfile * ) & f , dest , ( s + maxsize ) - dest , dest ) ;\n s [ maxsize - 1 ] = '\\0' ;\n memset ( & info , '\\0' , sizeof ( info ) ) ;\n info . prec = right_prec ;\n info . width = left_prec + ( right_prec ? ( right_prec + 1 ) : 0 ) ;\n info . spec = 'f' ;\n info . is_long_double = is_long_double ;\n info . group = group ;\n info . pad = pad ;\n info . extra = 1 ;\n ptr = & fpnum ;\n done = __printf_fp ( ( FILE * ) & f , & info , & ptr ) ;\n if ( done < 0 ) return - 1 ;\n if ( s [ maxsize - 1 ] != '\\0' ) {\n __set_errno ( E2BIG ) ;\n return - 1 ;\n }\n dest += done ;\n if ( ! cs_precedes ) {\n if ( sign_posn == 3 ) {\n if ( sep_by_space == 1 ) out_char ( ' ' ) ;\n out_string ( sign_string ) ;\n }\n if ( print_curr_symbol ) {\n if ( ( sign_posn == 3 && sep_by_space == 2 ) || ( sign_posn == 4 && sep_by_space == 1 ) || ( sign_posn == 2 && sep_by_space == 1 ) || ( sign_posn == 1 && sep_by_space == 1 ) || ( sign_posn == 0 && sep_by_space == 1 ) ) out_char ( space_char ) ;\n out_nstring ( currency_symbol , currency_symbol_len ) ;\n }\n if ( sign_posn == 4 ) {\n if ( sep_by_space == 2 ) out_char ( ' ' ) ;\n out_string ( sign_string ) ;\n }\n }\n if ( sign_posn == 2 ) {\n if ( sep_by_space == 2 ) out_char ( ' ' ) ;\n out_string ( sign_string ) ;\n }\n if ( sign_posn == 0 && is_negative ) out_char ( right_paren ) ;\n if ( dest - startp < width ) {\n if ( left ) do out_char ( ' ' ) ;\n while ( dest - startp < width ) ;\n else {\n int dist = width - ( dest - startp ) ;\n char * cp ;\n for ( cp = dest - 1 ;\n cp >= startp ;\n -- cp ) cp [ dist ] = cp [ 0 ] ;\n dest += dist ;\n do startp [ -- dist ] = ' ' ;\n while ( dist > 0 ) ;\n }\n }\n }\n * dest = '\\0' ;\n return dest - s ;\n }",
        "hash": 4267090854870892355,
        "project": "debian",
        "size": 303,
        "slice": {
            "memset": [
                [
                    2,
                    " ssize_t __vstrfmon_l ( char * s , size_t maxsize , __locale_t loc , const char * format , va_list ap ) {\n"
                ],
                [
                    134,
                    " switch ( * fmt ++ ) {\n"
                ],
                [
                    251,
                    " memset ( & info , '\\0' , sizeof ( info ) ) ;\n"
                ],
                [
                    252,
                    " info . prec = right_prec ;\n"
                ],
                [
                    253,
                    " info . width = left_prec + ( right_prec ? ( right_prec + 1 ) : 0 ) ;\n"
                ],
                [
                    254,
                    " info . spec = 'f' ;\n"
                ],
                [
                    255,
                    " info . is_long_double = is_long_double ;\n"
                ],
                [
                    256,
                    " info . group = group ;\n"
                ],
                [
                    257,
                    " info . pad = pad ;\n"
                ],
                [
                    258,
                    " info . extra = 1 ;\n"
                ],
                [
                    260,
                    " done = __printf_fp ( ( FILE * ) & f , & info , & ptr ) ;\n"
                ]
            ],
            "strncpy": [
                [
                    2,
                    " ssize_t __vstrfmon_l ( char * s , size_t maxsize , __locale_t loc , const char * format , va_list ap ) {\n"
                ],
                [
                    133,
                    " char int_symbol [ 4 ] ;\n"
                ],
                [
                    134,
                    " switch ( * fmt ++ ) {\n"
                ],
                [
                    137,
                    " int_curr_symbol = _NL_CURRENT ( LC_MONETARY , INT_CURR_SYMBOL ) ;\n"
                ],
                [
                    138,
                    " strncpy ( int_symbol , int_curr_symbol , 3 ) ;\n"
                ],
                [
                    139,
                    " int_symbol [ 3 ] = '\\0' ;\n"
                ],
                [
                    141,
                    " currency_symbol = & int_symbol [ 0 ] ;\n"
                ],
                [
                    142,
                    " space_char = int_curr_symbol [ 3 ] ;\n"
                ]
            ],
            "strlen": [
                [
                    2,
                    " ssize_t __vstrfmon_l ( char * s , size_t maxsize , __locale_t loc , const char * format , va_list ap ) {\n"
                ],
                [
                    134,
                    " switch ( * fmt ++ ) {\n"
                ],
                [
                    146,
                    " case 'n' : currency_symbol = _NL_CURRENT ( LC_MONETARY , CURRENCY_SYMBOL ) ;\n"
                ],
                [
                    147,
                    " currency_symbol_len = strlen ( currency_symbol ) ;\n"
                ],
                [
                    172,
                    " sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n"
                ],
                [
                    173,
                    " if ( * sign_string == '\\0' ) sign_string = ( const char * ) \"-\" ;\n"
                ],
                [
                    177,
                    " other_sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n"
                ],
                [
                    183,
                    " sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n"
                ],
                [
                    187,
                    " other_sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n"
                ],
                [
                    188,
                    " if ( * other_sign_string == '\\0' ) other_sign_string = ( const char * ) \"-\" ;\n"
                ],
                [
                    210,
                    " int left_bytes = 0 ;\n"
                ],
                [
                    211,
                    " int other_left_bytes = 0 ;\n"
                ],
                [
                    213,
                    " left_bytes += currency_symbol_len ;\n"
                ],
                [
                    214,
                    " if ( sep_by_space != 0 ) ++ left_bytes ;\n"
                ],
                [
                    217,
                    " other_left_bytes += currency_symbol_len ;\n"
                ],
                [
                    218,
                    " if ( other_sep_by_space != 0 ) ++ other_left_bytes ;\n"
                ],
                [
                    221,
                    " else if ( sign_posn == 1 ) left_bytes += strlen ( sign_string ) ;\n"
                ],
                [
                    222,
                    " else if ( cs_precedes && ( sign_posn == 3 || sign_posn == 4 ) ) left_bytes += strlen ( sign_string ) ;\n"
                ],
                [
                    224,
                    " else if ( other_sign_posn == 1 ) other_left_bytes += strlen ( other_sign_string ) ;\n"
                ],
                [
                    225,
                    " else if ( other_cs_precedes && ( other_sign_posn == 3 || other_sign_posn == 4 ) ) other_left_bytes += strlen ( other_sign_string ) ;\n"
                ],
                [
                    226,
                    " if ( other_left_bytes > left_bytes ) left_pad = other_left_bytes - left_bytes ;\n"
                ],
                [
                    234,
                    " out_string ( sign_string ) ;\n"
                ],
                [
                    237,
                    " if ( print_curr_symbol ) out_string ( currency_symbol ) ;\n"
                ],
                [
                    240,
                    " out_string ( sign_string ) ;\n"
                ],
                [
                    245,
                    " else if ( sign_posn != 0 && sign_posn != 2 && sign_posn != 3 && sign_posn != 4 && sign_posn != 5 ) out_string ( sign_string ) ;\n"
                ],
                [
                    270,
                    " out_string ( sign_string ) ;\n"
                ],
                [
                    274,
                    " out_nstring ( currency_symbol , currency_symbol_len ) ;\n"
                ],
                [
                    278,
                    " out_string ( sign_string ) ;\n"
                ],
                [
                    283,
                    " out_string ( sign_string ) ;\n"
                ]
            ],
            "result": [
                [
                    2,
                    " ssize_t __vstrfmon_l ( char * s , size_t maxsize , __locale_t loc , const char * format , va_list ap ) {\n"
                ],
                [
                    133,
                    " char int_symbol [ 4 ] ;\n"
                ],
                [
                    134,
                    " switch ( * fmt ++ ) {\n"
                ],
                [
                    137,
                    " int_curr_symbol = _NL_CURRENT ( LC_MONETARY , INT_CURR_SYMBOL ) ;\n"
                ],
                [
                    138,
                    " strncpy ( int_symbol , int_curr_symbol , 3 ) ;\n"
                ],
                [
                    139,
                    " int_symbol [ 3 ] = '\\0' ;\n"
                ],
                [
                    141,
                    " currency_symbol = & int_symbol [ 0 ] ;\n"
                ],
                [
                    142,
                    " space_char = int_curr_symbol [ 3 ] ;\n"
                ],
                [
                    146,
                    " case 'n' : currency_symbol = _NL_CURRENT ( LC_MONETARY , CURRENCY_SYMBOL ) ;\n"
                ],
                [
                    147,
                    " currency_symbol_len = strlen ( currency_symbol ) ;\n"
                ],
                [
                    172,
                    " sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n"
                ],
                [
                    173,
                    " if ( * sign_string == '\\0' ) sign_string = ( const char * ) \"-\" ;\n"
                ],
                [
                    177,
                    " other_sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n"
                ],
                [
                    183,
                    " sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n"
                ],
                [
                    187,
                    " other_sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n"
                ],
                [
                    188,
                    " if ( * other_sign_string == '\\0' ) other_sign_string = ( const char * ) \"-\" ;\n"
                ],
                [
                    210,
                    " int left_bytes = 0 ;\n"
                ],
                [
                    211,
                    " int other_left_bytes = 0 ;\n"
                ],
                [
                    213,
                    " left_bytes += currency_symbol_len ;\n"
                ],
                [
                    214,
                    " if ( sep_by_space != 0 ) ++ left_bytes ;\n"
                ],
                [
                    217,
                    " other_left_bytes += currency_symbol_len ;\n"
                ],
                [
                    218,
                    " if ( other_sep_by_space != 0 ) ++ other_left_bytes ;\n"
                ],
                [
                    221,
                    " else if ( sign_posn == 1 ) left_bytes += strlen ( sign_string ) ;\n"
                ],
                [
                    222,
                    " else if ( cs_precedes && ( sign_posn == 3 || sign_posn == 4 ) ) left_bytes += strlen ( sign_string ) ;\n"
                ],
                [
                    224,
                    " else if ( other_sign_posn == 1 ) other_left_bytes += strlen ( other_sign_string ) ;\n"
                ],
                [
                    225,
                    " else if ( other_cs_precedes && ( other_sign_posn == 3 || other_sign_posn == 4 ) ) other_left_bytes += strlen ( other_sign_string ) ;\n"
                ],
                [
                    226,
                    " if ( other_left_bytes > left_bytes ) left_pad = other_left_bytes - left_bytes ;\n"
                ],
                [
                    234,
                    " out_string ( sign_string ) ;\n"
                ],
                [
                    237,
                    " if ( print_curr_symbol ) out_string ( currency_symbol ) ;\n"
                ],
                [
                    240,
                    " out_string ( sign_string ) ;\n"
                ],
                [
                    245,
                    " else if ( sign_posn != 0 && sign_posn != 2 && sign_posn != 3 && sign_posn != 4 && sign_posn != 5 ) out_string ( sign_string ) ;\n"
                ],
                [
                    251,
                    " memset ( & info , '\\0' , sizeof ( info ) ) ;\n"
                ],
                [
                    252,
                    " info . prec = right_prec ;\n"
                ],
                [
                    253,
                    " info . width = left_prec + ( right_prec ? ( right_prec + 1 ) : 0 ) ;\n"
                ],
                [
                    254,
                    " info . spec = 'f' ;\n"
                ],
                [
                    255,
                    " info . is_long_double = is_long_double ;\n"
                ],
                [
                    256,
                    " info . group = group ;\n"
                ],
                [
                    257,
                    " info . pad = pad ;\n"
                ],
                [
                    258,
                    " info . extra = 1 ;\n"
                ],
                [
                    260,
                    " done = __printf_fp ( ( FILE * ) & f , & info , & ptr ) ;\n"
                ],
                [
                    270,
                    " out_string ( sign_string ) ;\n"
                ],
                [
                    274,
                    " out_nstring ( currency_symbol , currency_symbol_len ) ;\n"
                ],
                [
                    278,
                    " out_string ( sign_string ) ;\n"
                ],
                [
                    283,
                    " out_string ( sign_string ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n struct io_cb_data * data = ( struct io_cb_data * ) opaque ;\n engine_uiserver_t uiserver = ( engine_uiserver_t ) data -> handler_value ;\n gpgme_error_t err = 0 ;\n char * line ;\n size_t linelen ;\n do {\n err = assuan_read_line ( uiserver -> assuan_ctx , & line , & linelen ) ;\n if ( err ) {\n TRACE3 ( DEBUG_CTX , \"gpgme:status_handler\" , uiserver , \"fd 0x%x: error from assuan (%d) getting status line : %s\" , fd , err , gpg_strerror ( err ) ) ;\n }\n else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n if ( ! err ) err = gpg_error ( GPG_ERR_GENERAL ) ;\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , uiserver , \"fd 0x%x: ERR line - mapped to: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n if ( uiserver -> status . fnc ) err = uiserver -> status . fnc ( uiserver -> status . fnc_value , GPGME_STATUS_EOF , \"\" ) ;\n if ( ! err && uiserver -> colon . fnc && uiserver -> colon . any ) {\n uiserver -> colon . any = 0 ;\n err = uiserver -> colon . fnc ( uiserver -> colon . fnc_value , NULL ) ;\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , uiserver , \"fd 0x%x: OK line - final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n _gpgme_io_close ( uiserver -> status_cb . fd ) ;\n return err ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> colon . fnc ) {\n char * src = line + 2 ;\n char * end = line + linelen ;\n char * dst ;\n char * * aline = & uiserver -> colon . attic . line ;\n int * alinelen = & uiserver -> colon . attic . linelen ;\n if ( uiserver -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n else {\n * aline = newline ;\n uiserver -> colon . attic . linesize += linelen + 1 ;\n }\n }\n if ( ! err ) {\n dst = * aline + * alinelen ;\n while ( ! err && src < end ) {\n if ( * src == '%' && src + 2 < end ) {\n ++ src ;\n * dst = _gpgme_hextobyte ( src ) ;\n ( * alinelen ) ++ ;\n src += 2 ;\n }\n else {\n * dst = * src ++ ;\n ( * alinelen ) ++ ;\n }\n if ( * dst == '\\n' ) {\n uiserver -> colon . any = 1 ;\n if ( * alinelen > 1 && * ( dst - 1 ) == '\\r' ) dst -- ;\n * dst = '\\0' ;\n err = uiserver -> colon . fnc ( uiserver -> colon . fnc_value , * aline ) ;\n if ( ! err ) {\n dst = * aline ;\n * alinelen = 0 ;\n }\n }\n else dst ++ ;\n }\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , uiserver , \"fd 0x%x: D line;\n final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> inline_data ) {\n char * src = line + 2 ;\n char * end = line + linelen ;\n char * dst = src ;\n gpgme_ssize_t nwritten ;\n linelen = 0 ;\n while ( src < end ) {\n if ( * src == '%' && src + 2 < end ) {\n ++ src ;\n * dst ++ = _gpgme_hextobyte ( src ) ;\n src += 2 ;\n }\n else * dst ++ = * src ++ ;\n linelen ++ ;\n }\n src = line + 2 ;\n while ( linelen > 0 ) {\n nwritten = gpgme_data_write ( uiserver -> inline_data , src , linelen ) ;\n if ( ! nwritten || ( nwritten < 0 && errno != EINTR ) || nwritten > linelen ) {\n err = gpg_error_from_syserror ( ) ;\n break ;\n }\n src += nwritten ;\n linelen -= nwritten ;\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , uiserver , \"fd 0x%x: D inlinedata;\n final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n char * rest ;\n gpgme_status_code_t r ;\n rest = strchr ( line + 2 , ' ' ) ;\n if ( ! rest ) rest = line + linelen ;\n else * ( rest ++ ) = 0 ;\n r = _gpgme_parse_status ( line + 2 ) ;\n if ( r >= 0 ) {\n if ( uiserver -> status . fnc ) err = uiserver -> status . fnc ( uiserver -> status . fnc_value , r , rest ) ;\n }\n else fprintf ( stderr , \"[UNKNOWN STATUS]%s %s\" , line + 2 , rest ) ;\n TRACE3 ( DEBUG_CTX , \"gpgme:status_handler\" , uiserver , \"fd 0x%x: S line (%s) - final status: %s\" , fd , line + 2 , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n char * keyword = line + 7 ;\n while ( * keyword == ' ' ) keyword ++ ;\n ;\n default_inq_cb ( uiserver , keyword ) ;\n assuan_write_line ( uiserver -> assuan_ctx , \"END\" ) ;\n }\n }\n while ( ! err && assuan_pending_line ( uiserver -> assuan_ctx ) ) ;\n return err ;\n }",
        "hash": -769658847024738738,
        "project": "debian",
        "size": 121,
        "slice": {
            "strchr": [
                [
                    1,
                    "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n"
                ],
                [
                    8,
                    " err = assuan_read_line ( uiserver -> assuan_ctx , & line , & linelen ) ;\n"
                ],
                [
                    12,
                    " else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n"
                ],
                [
                    13,
                    " if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n"
                ],
                [
                    17,
                    " else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n"
                ],
                [
                    27,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> colon . fnc ) {\n"
                ],
                [
                    70,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> inline_data ) {\n"
                ],
                [
                    98,
                    " else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n"
                ],
                [
                    101,
                    " rest = strchr ( line + 2 , ' ' ) ;\n"
                ],
                [
                    102,
                    " if ( ! rest ) rest = line + linelen ;\n"
                ],
                [
                    111,
                    " else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n"
                ],
                [
                    8,
                    " err = assuan_read_line ( uiserver -> assuan_ctx , & line , & linelen ) ;\n"
                ],
                [
                    12,
                    " else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n"
                ],
                [
                    13,
                    " if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n"
                ],
                [
                    17,
                    " else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n"
                ],
                [
                    27,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> colon . fnc ) {\n"
                ],
                [
                    70,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> inline_data ) {\n"
                ],
                [
                    98,
                    " else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n"
                ],
                [
                    102,
                    " if ( ! rest ) rest = line + linelen ;\n"
                ],
                [
                    103,
                    " else * ( rest ++ ) = 0 ;\n"
                ],
                [
                    105,
                    " if ( r >= 0 ) {\n"
                ],
                [
                    108,
                    " else fprintf ( stderr , \"[UNKNOWN STATUS]%s %s\" , line + 2 , rest ) ;\n"
                ],
                [
                    111,
                    " else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n"
                ]
            ],
            "realloc": [
                [
                    1,
                    "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n"
                ],
                [
                    8,
                    " err = assuan_read_line ( uiserver -> assuan_ctx , & line , & linelen ) ;\n"
                ],
                [
                    27,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> colon . fnc ) {\n"
                ],
                [
                    33,
                    " if ( uiserver -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n"
                ],
                [
                    34,
                    " char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n"
                ],
                [
                    35,
                    " if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    37,
                    " * aline = newline ;\n"
                ],
                [
                    42,
                    " dst = * aline + * alinelen ;\n"
                ],
                [
                    58,
                    " err = uiserver -> colon . fnc ( uiserver -> colon . fnc_value , * aline ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n"
                ],
                [
                    8,
                    " err = assuan_read_line ( uiserver -> assuan_ctx , & line , & linelen ) ;\n"
                ],
                [
                    12,
                    " else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n"
                ],
                [
                    13,
                    " if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n"
                ],
                [
                    17,
                    " else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n"
                ],
                [
                    27,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> colon . fnc ) {\n"
                ],
                [
                    33,
                    " if ( uiserver -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n"
                ],
                [
                    34,
                    " char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n"
                ],
                [
                    35,
                    " if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    37,
                    " * aline = newline ;\n"
                ],
                [
                    42,
                    " dst = * aline + * alinelen ;\n"
                ],
                [
                    58,
                    " err = uiserver -> colon . fnc ( uiserver -> colon . fnc_value , * aline ) ;\n"
                ],
                [
                    70,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> inline_data ) {\n"
                ],
                [
                    98,
                    " else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n"
                ],
                [
                    101,
                    " rest = strchr ( line + 2 , ' ' ) ;\n"
                ],
                [
                    102,
                    " if ( ! rest ) rest = line + linelen ;\n"
                ],
                [
                    103,
                    " else * ( rest ++ ) = 0 ;\n"
                ],
                [
                    105,
                    " if ( r >= 0 ) {\n"
                ],
                [
                    108,
                    " else fprintf ( stderr , \"[UNKNOWN STATUS]%s %s\" , line + 2 , rest ) ;\n"
                ],
                [
                    111,
                    " else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n struct io_cb_data * data = ( struct io_cb_data * ) opaque ;\n engine_gpgsm_t gpgsm = ( engine_gpgsm_t ) data -> handler_value ;\n gpgme_error_t err = 0 ;\n char * line ;\n size_t linelen ;\n do {\n err = assuan_read_line ( gpgsm -> assuan_ctx , & line , & linelen ) ;\n if ( err ) {\n TRACE3 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: error from assuan (%d) getting status line : %s\" , fd , err , gpg_strerror ( err ) ) ;\n }\n else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n if ( ! err ) err = gpg_error ( GPG_ERR_GENERAL ) ;\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: ERR line - mapped to: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n if ( gpgsm -> status . fnc ) err = gpgsm -> status . fnc ( gpgsm -> status . fnc_value , GPGME_STATUS_EOF , \"\" ) ;\n if ( ! err && gpgsm -> colon . fnc && gpgsm -> colon . any ) {\n gpgsm -> colon . any = 0 ;\n err = gpgsm -> colon . fnc ( gpgsm -> colon . fnc_value , NULL ) ;\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: OK line - final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n _gpgme_io_close ( gpgsm -> status_cb . fd ) ;\n return err ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> colon . fnc ) {\n char * src = line + 2 ;\n char * end = line + linelen ;\n char * dst ;\n char * * aline = & gpgsm -> colon . attic . line ;\n int * alinelen = & gpgsm -> colon . attic . linelen ;\n if ( gpgsm -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n else {\n * aline = newline ;\n gpgsm -> colon . attic . linesize += linelen + 1 ;\n }\n }\n if ( ! err ) {\n dst = * aline + * alinelen ;\n while ( ! err && src < end ) {\n if ( * src == '%' && src + 2 < end ) {\n ++ src ;\n * dst = _gpgme_hextobyte ( src ) ;\n ( * alinelen ) ++ ;\n src += 2 ;\n }\n else {\n * dst = * src ++ ;\n ( * alinelen ) ++ ;\n }\n if ( * dst == '\\n' ) {\n gpgsm -> colon . any = 1 ;\n if ( * alinelen > 1 && * ( dst - 1 ) == '\\r' ) dst -- ;\n * dst = '\\0' ;\n err = gpgsm -> colon . fnc ( gpgsm -> colon . fnc_value , * aline ) ;\n if ( ! err ) {\n dst = * aline ;\n * alinelen = 0 ;\n }\n }\n else dst ++ ;\n }\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: D line;\n final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> inline_data ) {\n char * src = line + 2 ;\n char * end = line + linelen ;\n char * dst = src ;\n gpgme_ssize_t nwritten ;\n linelen = 0 ;\n while ( src < end ) {\n if ( * src == '%' && src + 2 < end ) {\n ++ src ;\n * dst ++ = _gpgme_hextobyte ( src ) ;\n src += 2 ;\n }\n else * dst ++ = * src ++ ;\n linelen ++ ;\n }\n src = line + 2 ;\n while ( linelen > 0 ) {\n nwritten = gpgme_data_write ( gpgsm -> inline_data , src , linelen ) ;\n if ( ! nwritten || ( nwritten < 0 && errno != EINTR ) || nwritten > linelen ) {\n err = gpg_error_from_syserror ( ) ;\n break ;\n }\n src += nwritten ;\n linelen -= nwritten ;\n }\n TRACE2 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: D inlinedata;\n final status: %s\" , fd , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n char * rest ;\n gpgme_status_code_t r ;\n rest = strchr ( line + 2 , ' ' ) ;\n if ( ! rest ) rest = line + linelen ;\n else * ( rest ++ ) = 0 ;\n r = _gpgme_parse_status ( line + 2 ) ;\n if ( r >= 0 ) {\n if ( gpgsm -> status . fnc ) err = gpgsm -> status . fnc ( gpgsm -> status . fnc_value , r , rest ) ;\n }\n else fprintf ( stderr , \"[UNKNOWN STATUS]%s %s\" , line + 2 , rest ) ;\n TRACE3 ( DEBUG_CTX , \"gpgme:status_handler\" , gpgsm , \"fd 0x%x: S line (%s) - final status: %s\" , fd , line + 2 , err ? gpg_strerror ( err ) : \"ok\" ) ;\n }\n else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n char * keyword = line + 7 ;\n while ( * keyword == ' ' ) keyword ++ ;\n ;\n default_inq_cb ( gpgsm , keyword ) ;\n assuan_write_line ( gpgsm -> assuan_ctx , \"END\" ) ;\n }\n }\n while ( ! err && assuan_pending_line ( gpgsm -> assuan_ctx ) ) ;\n return err ;\n }",
        "hash": -2386031673786599357,
        "project": "debian",
        "size": 121,
        "slice": {
            "strchr": [
                [
                    1,
                    "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n"
                ],
                [
                    8,
                    " err = assuan_read_line ( gpgsm -> assuan_ctx , & line , & linelen ) ;\n"
                ],
                [
                    12,
                    " else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n"
                ],
                [
                    13,
                    " if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n"
                ],
                [
                    17,
                    " else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n"
                ],
                [
                    27,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> colon . fnc ) {\n"
                ],
                [
                    70,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> inline_data ) {\n"
                ],
                [
                    98,
                    " else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n"
                ],
                [
                    101,
                    " rest = strchr ( line + 2 , ' ' ) ;\n"
                ],
                [
                    102,
                    " if ( ! rest ) rest = line + linelen ;\n"
                ],
                [
                    111,
                    " else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n"
                ],
                [
                    8,
                    " err = assuan_read_line ( gpgsm -> assuan_ctx , & line , & linelen ) ;\n"
                ],
                [
                    12,
                    " else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n"
                ],
                [
                    13,
                    " if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n"
                ],
                [
                    17,
                    " else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n"
                ],
                [
                    27,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> colon . fnc ) {\n"
                ],
                [
                    70,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> inline_data ) {\n"
                ],
                [
                    98,
                    " else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n"
                ],
                [
                    102,
                    " if ( ! rest ) rest = line + linelen ;\n"
                ],
                [
                    103,
                    " else * ( rest ++ ) = 0 ;\n"
                ],
                [
                    105,
                    " if ( r >= 0 ) {\n"
                ],
                [
                    108,
                    " else fprintf ( stderr , \"[UNKNOWN STATUS]%s %s\" , line + 2 , rest ) ;\n"
                ],
                [
                    111,
                    " else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n"
                ]
            ],
            "realloc": [
                [
                    1,
                    "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n"
                ],
                [
                    8,
                    " err = assuan_read_line ( gpgsm -> assuan_ctx , & line , & linelen ) ;\n"
                ],
                [
                    27,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> colon . fnc ) {\n"
                ],
                [
                    33,
                    " if ( gpgsm -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n"
                ],
                [
                    34,
                    " char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n"
                ],
                [
                    35,
                    " if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    37,
                    " * aline = newline ;\n"
                ],
                [
                    42,
                    " dst = * aline + * alinelen ;\n"
                ],
                [
                    58,
                    " err = gpgsm -> colon . fnc ( gpgsm -> colon . fnc_value , * aline ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static gpgme_error_t status_handler ( void * opaque , int fd ) {\n"
                ],
                [
                    8,
                    " err = assuan_read_line ( gpgsm -> assuan_ctx , & line , & linelen ) ;\n"
                ],
                [
                    12,
                    " else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\\0' || line [ 3 ] == ' ' ) ) {\n"
                ],
                [
                    13,
                    " if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n"
                ],
                [
                    17,
                    " else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\\0' || line [ 2 ] == ' ' ) ) {\n"
                ],
                [
                    27,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> colon . fnc ) {\n"
                ],
                [
                    33,
                    " if ( gpgsm -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n"
                ],
                [
                    34,
                    " char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n"
                ],
                [
                    35,
                    " if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n"
                ],
                [
                    37,
                    " * aline = newline ;\n"
                ],
                [
                    42,
                    " dst = * aline + * alinelen ;\n"
                ],
                [
                    58,
                    " err = gpgsm -> colon . fnc ( gpgsm -> colon . fnc_value , * aline ) ;\n"
                ],
                [
                    70,
                    " else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> inline_data ) {\n"
                ],
                [
                    98,
                    " else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n"
                ],
                [
                    101,
                    " rest = strchr ( line + 2 , ' ' ) ;\n"
                ],
                [
                    102,
                    " if ( ! rest ) rest = line + linelen ;\n"
                ],
                [
                    103,
                    " else * ( rest ++ ) = 0 ;\n"
                ],
                [
                    105,
                    " if ( r >= 0 ) {\n"
                ],
                [
                    108,
                    " else fprintf ( stderr , \"[UNKNOWN STATUS]%s %s\" , line + 2 , rest ) ;\n"
                ],
                [
                    111,
                    " else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\\0' || line [ 7 ] == ' ' ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "int crypto_authenticate_and_decrypt ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n struct crypto_config_header * cch = ( struct crypto_config_header * ) buf ;\n const char * guessed_str ;\n if ( cch -> crypto_cipher_type != CRYPTO_CIPHER_TYPE_2_3 ) {\n guessed_str = NULL ;\n if ( ( cch -> crypto_cipher_type == 0xC0 && cch -> crypto_hash_type == 0x70 ) || ( cch -> crypto_cipher_type == 0x70 && cch -> crypto_hash_type == 0xC0 ) ) {\n guessed_str = \"Corosync 3.x\" ;\n }\n else if ( cch -> crypto_cipher_type == CRYPTO_CIPHER_TYPE_2_2 ) {\n guessed_str = \"Corosync 2.2\" ;\n }\n else if ( cch -> crypto_cipher_type == 0x01 ) {\n guessed_str = \"unencrypted Kronosnet\" ;\n }\n else if ( cch -> crypto_cipher_type >= 0 && cch -> crypto_cipher_type <= 5 ) {\n guessed_str = \"unencrypted Corosync 2.0/2.1/1.x/OpenAIS\" ;\n }\n else {\n guessed_str = \"encrypted Kronosnet/Corosync 2.0/2.1/1.x/OpenAIS or unknown\" ;\n }\n log_printf ( instance -> log_level_security , \"Unsupported incoming packet (probably sent by %s). Rejecting\" , guessed_str ) ;\n return - 1 ;\n }\n if ( cch -> crypto_hash_type != CRYPTO_HASH_TYPE_2_3 ) {\n log_printf ( instance -> log_level_security , \"Incoming packet has different hash type. Rejecting\" ) ;\n return - 1 ;\n }\n if ( authenticate_nss_2_3 ( instance , buf , buf_len ) != 0 ) {\n return - 1 ;\n }\n if ( ( cch -> __pad0 != 0 ) || ( cch -> __pad1 != 0 ) ) {\n log_printf ( instance -> log_level_security , \"Incoming packet appears to have features not supported by this version of corosync. Rejecting\" ) ;\n return - 1 ;\n }\n if ( decrypt_nss_2_3 ( instance , buf , buf_len ) != 0 ) {\n return - 1 ;\n }\n cch = NULL ;\n memmove ( buf , buf + sizeof ( struct crypto_config_header ) , * buf_len ) ;\n return 0 ;\n }",
        "hash": 3755875528583281641,
        "project": "debian",
        "size": 41,
        "slice": {
            "memmove": [
                [
                    1,
                    "int crypto_authenticate_and_decrypt ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n"
                ],
                [
                    35,
                    " if ( decrypt_nss_2_3 ( instance , buf , buf_len ) != 0 ) {\n"
                ],
                [
                    39,
                    " memmove ( buf , buf + sizeof ( struct crypto_config_header ) , * buf_len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int crypto_authenticate_and_decrypt ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n"
                ],
                [
                    35,
                    " if ( decrypt_nss_2_3 ( instance , buf , buf_len ) != 0 ) {\n"
                ],
                [
                    39,
                    " memmove ( buf , buf + sizeof ( struct crypto_config_header ) , * buf_len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int authenticate_nss_2_3 ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n if ( hash_to_nss [ instance -> crypto_hash_type ] ) {\n unsigned char tmp_hash [ hash_len [ instance -> crypto_hash_type ] ] ;\n int datalen = * buf_len - hash_len [ instance -> crypto_hash_type ] ;\n if ( calculate_nss_hash ( instance , buf , datalen , tmp_hash ) < 0 ) {\n return - 1 ;\n }\n if ( memcmp ( tmp_hash , buf + datalen , hash_len [ instance -> crypto_hash_type ] ) != 0 ) {\n log_printf ( instance -> log_level_error , \"Digest does not match\" ) ;\n return - 1 ;\n }\n * buf_len = datalen ;\n }\n return 0 ;\n }",
        "hash": 3755875528583281641,
        "project": "debian",
        "size": 15,
        "slice": {
            "memcmp": [
                [
                    1,
                    "static int authenticate_nss_2_3 ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n"
                ],
                [
                    4,
                    " int datalen = * buf_len - hash_len [ instance -> crypto_hash_type ] ;\n"
                ],
                [
                    5,
                    " if ( calculate_nss_hash ( instance , buf , datalen , tmp_hash ) < 0 ) {\n"
                ],
                [
                    8,
                    " if ( memcmp ( tmp_hash , buf + datalen , hash_len [ instance -> crypto_hash_type ] ) != 0 ) {\n"
                ],
                [
                    9,
                    " log_printf ( instance -> log_level_error , \"Digest does not match\" ) ;\n"
                ],
                [
                    10,
                    " return - 1 ;\n"
                ],
                [
                    12,
                    " * buf_len = datalen ;\n"
                ],
                [
                    14,
                    " return 0 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int authenticate_nss_2_3 ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n"
                ],
                [
                    4,
                    " int datalen = * buf_len - hash_len [ instance -> crypto_hash_type ] ;\n"
                ],
                [
                    5,
                    " if ( calculate_nss_hash ( instance , buf , datalen , tmp_hash ) < 0 ) {\n"
                ],
                [
                    8,
                    " if ( memcmp ( tmp_hash , buf + datalen , hash_len [ instance -> crypto_hash_type ] ) != 0 ) {\n"
                ],
                [
                    9,
                    " log_printf ( instance -> log_level_error , \"Digest does not match\" ) ;\n"
                ],
                [
                    10,
                    " return - 1 ;\n"
                ],
                [
                    12,
                    " * buf_len = datalen ;\n"
                ],
                [
                    14,
                    " return 0 ;\n"
                ]
            ]
        }
    },
    {
        "code": "ASN1_BIT_STRING * c2i_ASN1_BIT_STRING ( ASN1_BIT_STRING * * a , const unsigned char * * pp , long len ) {\n ASN1_BIT_STRING * ret = NULL ;\n const unsigned char * p ;\n unsigned char * s ;\n int i ;\n if ( len < 1 ) {\n i = ASN1_R_STRING_TOO_SHORT ;\n goto err ;\n }\n if ( ( a == NULL ) || ( ( * a ) == NULL ) ) {\n if ( ( ret = M_ASN1_BIT_STRING_new ( ) ) == NULL ) return ( NULL ) ;\n }\n else ret = ( * a ) ;\n p = * pp ;\n i = * ( p ++ ) ;\n ret -> flags &= ~ ( ASN1_STRING_FLAG_BITS_LEFT | 0x07 ) ;\n ret -> flags |= ( ASN1_STRING_FLAG_BITS_LEFT | ( i & 0x07 ) ) ;\n if ( len -- > 1 ) {\n s = ( unsigned char * ) OPENSSL_malloc ( ( int ) len ) ;\n if ( s == NULL ) {\n i = ERR_R_MALLOC_FAILURE ;\n goto err ;\n }\n memcpy ( s , p , ( int ) len ) ;\n s [ len - 1 ] &= ( 0xff << i ) ;\n p += len ;\n }\n else s = NULL ;\n ret -> length = ( int ) len ;\n if ( ret -> data != NULL ) OPENSSL_free ( ret -> data ) ;\n ret -> data = s ;\n ret -> type = V_ASN1_BIT_STRING ;\n if ( a != NULL ) ( * a ) = ret ;\n * pp = p ;\n return ( ret ) ;\n err : ASN1err ( ASN1_F_C2I_ASN1_BIT_STRING , i ) ;\n if ( ( ret != NULL ) && ( ( a == NULL ) || ( * a != ret ) ) ) M_ASN1_BIT_STRING_free ( ret ) ;\n return ( NULL ) ;\n }",
        "hash": -6231193035097909837,
        "project": "debian",
        "size": 39,
        "slice": {
            "memcpy": [
                [
                    1,
                    "ASN1_BIT_STRING * c2i_ASN1_BIT_STRING ( ASN1_BIT_STRING * * a , const unsigned char * * pp , long len ) {\n"
                ],
                [
                    15,
                    " i = * ( p ++ ) ;\n"
                ],
                [
                    18,
                    " if ( len -- > 1 ) {\n"
                ],
                [
                    20,
                    " if ( s == NULL ) {\n"
                ],
                [
                    24,
                    " memcpy ( s , p , ( int ) len ) ;\n"
                ],
                [
                    25,
                    " s [ len - 1 ] &= ( 0xff << i ) ;\n"
                ],
                [
                    26,
                    " p += len ;\n"
                ],
                [
                    31,
                    " ret -> data = s ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "ASN1_BIT_STRING * c2i_ASN1_BIT_STRING ( ASN1_BIT_STRING * * a , const unsigned char * * pp , long len ) {\n"
                ],
                [
                    15,
                    " i = * ( p ++ ) ;\n"
                ],
                [
                    18,
                    " if ( len -- > 1 ) {\n"
                ],
                [
                    20,
                    " if ( s == NULL ) {\n"
                ],
                [
                    24,
                    " memcpy ( s , p , ( int ) len ) ;\n"
                ],
                [
                    25,
                    " s [ len - 1 ] &= ( 0xff << i ) ;\n"
                ],
                [
                    26,
                    " p += len ;\n"
                ],
                [
                    31,
                    " ret -> data = s ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n static char packet [ PACKET_LENGTH ] ;\n static char helpful_packet [ PACKET_LENGTH ] ;\n char * response ;\n char * device_list ;\n gssize data_length ;\n gssize device_length ;\n socket_handle_t sock ;\n const char * adb_transport_serial_templace = \"%04x\" \"host:transport:%s\" ;\n const char * adb_check_port_templace = \"%04x\" \"shell:cat /proc/%set/tcp\" ;\n const char * adb_devices = \"000E\" \"host:devices-l\" ;\n const char * adb_api_level = \"0022\" \"shell:getprop ro.build.version.sdk\" ;\n const char * adb_hcidump_version = \"0017\" \"shell:hcidump --version\" ;\n const char * adb_ps_droid_bluetooth = \"0018\" \"shell:ps droid.bluetooth\" ;\n const char * adb_ps_bluetooth_app = \"001E\" \"shell:ps com.android.bluetooth\" ;\n const char * adb_tcpdump_help = \"0010\" \"shell:tcpdump -h\" ;\n char serial_number [ SERIAL_NUMBER_LENGTH_MAX ] ;\n size_t serial_number_length ;\n char model_name [ MODEL_NAME_LENGTH_MAX ] ;\n int result ;\n char * pos ;\n char * i_pos ;\n char * model_pos ;\n char * device_pos ;\n char * prev_pos ;\n int api_level ;\n int disable_interface ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_INTERFACES_LIST ;\n device_list = adb_send_and_receive ( sock , adb_devices , packet , sizeof ( packet ) , & device_length ) ;\n closesocket ( sock ) ;\n if ( ! device_list ) {\n errmsg_print ( \"ERROR: Cannot get list of interfaces from devices\" ) ;\n return EXIT_CODE_CANNOT_GET_INTERFACES_LIST ;\n }\n device_list [ device_length ] = '\\0' ;\n pos = ( char * ) device_list ;\n while ( pos < ( char * ) ( device_list + device_length ) ) {\n prev_pos = pos ;\n pos = strchr ( pos , ' ' ) ;\n i_pos = pos ;\n result = ( int ) ( pos - prev_pos ) ;\n pos = strchr ( pos , '\\n' ) + 1 ;\n if ( result >= ( int ) sizeof ( serial_number ) ) {\n verbose_print ( \"WARNING: Serial number too long, ignore device\\n\" ) ;\n continue ;\n }\n memcpy ( serial_number , prev_pos , result ) ;\n serial_number [ result ] = '\\0' ;\n serial_number_length = strlen ( serial_number ) ;\n model_name [ 0 ] = '\\0' ;\n model_pos = g_strstr_len ( i_pos , pos - i_pos , \"model:\" ) ;\n if ( model_pos ) {\n device_pos = g_strstr_len ( i_pos , pos - i_pos , \"device:\" ) ;\n if ( device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX ) {\n memcpy ( model_name , model_pos + 6 , device_pos - model_pos - 6 - 1 ) ;\n model_name [ device_pos - model_pos - 6 - 1 ] = '\\0' ;\n }\n }\n if ( model_name [ 0 ] == '\\0' ) strcpy ( model_name , \"unknown\" ) ;\n verbose_print ( \"VERBOSE: Processing device: \\\"%s\\\" <%s>\\n\" , serial_number , model_name ) ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet for transport\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_1 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n verbose_print ( \"WARNING: Error while setting adb transport for <%s>\\n\" , helpful_packet ) ;\n closesocket ( sock ) ;\n }\n else {\n response = adb_send_and_read ( sock , adb_tcpdump_help , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( response ) {\n response [ data_length ] = '\\0' ;\n if ( strstr ( response , \"tcpdump version\" ) ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_WIFI_TCPDUMP , model_name , serial_number , \"Android WiFi\" ) ;\n }\n }\n else {\n verbose_print ( \"WARNING: Error on socket: <%s>\\n\" , helpful_packet ) ;\n }\n }\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_2 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n verbose_print ( \"WARNING: Error while setting adb transport for <%s>\\n\" , helpful_packet ) ;\n closesocket ( sock ) ;\n continue ;\n }\n response = adb_send_and_read ( sock , adb_api_level , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response ) {\n verbose_print ( \"WARNING: Error on socket: <%s>\\n\" , helpful_packet ) ;\n continue ;\n }\n response [ data_length ] = '\\0' ;\n api_level = ( int ) g_ascii_strtoll ( response , NULL , 10 ) ;\n verbose_print ( \"VERBOSE: Android API Level for %s is %i\\n\" , serial_number , api_level ) ;\n if ( api_level < 21 ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_MAIN , model_name , serial_number , \"Android Logcat Main\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_SYSTEM , model_name , serial_number , \"Android Logcat System\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_RADIO , model_name , serial_number , \"Android Logcat Radio\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_EVENTS , model_name , serial_number , \"Android Logcat Events\" ) ;\n }\n else {\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_MAIN , model_name , serial_number , \"Android Logcat Main\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_SYSTEM , model_name , serial_number , \"Android Logcat System\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_RADIO , model_name , serial_number , \"Android Logcat Radio\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_EVENTS , model_name , serial_number , \"Android Logcat Events\" ) ;\n new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_CRASH , model_name , serial_number , \"Android Logcat Crash\" ) ;\n }\n if ( api_level >= 5 && api_level < 17 ) {\n disable_interface = 0 ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_3 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n response = adb_send_and_read ( sock , adb_hcidump_version , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response || data_length < 1 ) {\n verbose_print ( \"WARNING: Error while getting hcidump version by <%s> (%p len=%\" G_GSSIZE_FORMAT \")\\n\" , adb_hcidump_version , ( void * ) response , data_length ) ;\n verbose_print ( \"VERBOSE: Android hcidump version for %s is unknown\\n\" , serial_number ) ;\n disable_interface = 1 ;\n }\n else {\n response [ data_length ] = '\\0' ;\n if ( g_ascii_strtoull ( response , NULL , 10 ) == 0 ) {\n verbose_print ( \"VERBOSE: Android hcidump version for %s is unknown\\n\" , serial_number ) ;\n disable_interface = 1 ;\n }\n else {\n verbose_print ( \"VERBOSE: Android hcidump version for %s is %s\\n\" , serial_number , response ) ;\n }\n }\n if ( ! disable_interface ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_HCIDUMP , model_name , serial_number , \"Android Bluetooth Hcidump\" ) ;\n }\n }\n if ( api_level >= 17 && api_level < 21 ) {\n disable_interface = 0 ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_4 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n response = adb_send_and_read ( sock , adb_ps_droid_bluetooth , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response || data_length < 1 ) {\n verbose_print ( \"WARNING: Error while getting Bluetooth application process id by <%s> \" \"(%p len=%\" G_GSSIZE_FORMAT \")\\n\" , adb_hcidump_version , ( void * ) response , data_length ) ;\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n disable_interface = 1 ;\n }\n else {\n char * data_str ;\n char pid [ 16 ] ;\n memset ( pid , 0 , sizeof ( pid ) ) ;\n response [ data_length ] = '\\0' ;\n data_str = strchr ( response , '\\n' ) ;\n if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_1 ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_5 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_6 ;\n }\n response = adb_send_and_read ( sock , helpful_packet , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response ) {\n disable_interface = 1 ;\n }\n else {\n response [ data_length ] = '\\0' ;\n data_str = strchr ( response , '\\n' ) ;\n if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"10EA\" ) == 0 ) {\n verbose_print ( \"VERBOSE: Bluedroid External Parser Port for %s is %s\\n\" , serial_number , pid + 9 ) ;\n }\n else {\n disable_interface = 1 ;\n verbose_print ( \"VERBOSE: Bluedroid External Parser Port for %s is unknown\\n\" , serial_number ) ;\n }\n }\n }\n else {\n disable_interface = 1 ;\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n }\n }\n if ( ! disable_interface ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER , model_name , serial_number , \"Android Bluetooth External Parser\" ) ;\n }\n }\n if ( api_level >= 21 ) {\n disable_interface = 0 ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) continue ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_7 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n if ( api_level >= 23 ) {\n response = adb_send_and_read ( sock , adb_ps_bluetooth_app , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n }\n else response = adb_send_and_read ( sock , adb_ps_droid_bluetooth , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response || data_length < 1 ) {\n verbose_print ( \"WARNING: Error while getting Bluetooth application process id by <%s> \" \"(%p len=%\" G_GSSIZE_FORMAT \")\\n\" , adb_hcidump_version , ( void * ) response , data_length ) ;\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n disable_interface = 1 ;\n }\n else {\n char * data_str ;\n char pid [ 16 ] ;\n memset ( pid , 0 , sizeof ( pid ) ) ;\n response [ data_length ] = '\\0' ;\n data_str = strchr ( response , '\\n' ) ;\n if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_2 ;\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_8 ;\n }\n result = adb_send ( sock , helpful_packet ) ;\n if ( result ) {\n errmsg_print ( \"ERROR: Error while setting adb transport for <%s>\" , helpful_packet ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_GENERIC ;\n }\n result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n if ( result <= 0 || result > PACKET_LENGTH ) {\n errmsg_print ( \"ERROR: Error while completing adb packet\" ) ;\n closesocket ( sock ) ;\n return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_9 ;\n }\n response = adb_send_and_read ( sock , helpful_packet , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n closesocket ( sock ) ;\n if ( ! response ) {\n disable_interface = 1 ;\n }\n else {\n response [ data_length ] = '\\0' ;\n data_str = strchr ( response , '\\n' ) ;\n if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"22A8\" ) == 0 ) {\n verbose_print ( \"VERBOSE: Btsnoop Net Port for %s is %s\\n\" , serial_number , pid + 9 ) ;\n }\n else {\n disable_interface = 1 ;\n verbose_print ( \"VERBOSE: Btsnoop Net Port for %s is unknown\\n\" , serial_number ) ;\n }\n }\n }\n else {\n disable_interface = 1 ;\n verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n }\n }\n if ( ! disable_interface ) {\n new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET , model_name , serial_number , \"Android Bluetooth Btsnoop Net\" ) ;\n }\n }\n }\n return EXIT_CODE_SUCCESS ;\n }",
        "hash": -5912543978015782596,
        "project": "debian",
        "size": 320,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n"
                ],
                [
                    19,
                    " char model_name [ MODEL_NAME_LENGTH_MAX ] ;\n"
                ],
                [
                    42,
                    " result = ( int ) ( pos - prev_pos ) ;\n"
                ],
                [
                    44,
                    " if ( result >= ( int ) sizeof ( serial_number ) ) {\n"
                ],
                [
                    48,
                    " memcpy ( serial_number , prev_pos , result ) ;\n"
                ],
                [
                    49,
                    " serial_number [ result ] = '\\0' ;\n"
                ],
                [
                    50,
                    " serial_number_length = strlen ( serial_number ) ;\n"
                ],
                [
                    51,
                    " model_name [ 0 ] = '\\0' ;\n"
                ],
                [
                    52,
                    " model_pos = g_strstr_len ( i_pos , pos - i_pos , \"model:\" ) ;\n"
                ],
                [
                    55,
                    " if ( device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX ) {\n"
                ],
                [
                    56,
                    " memcpy ( model_name , model_pos + 6 , device_pos - model_pos - 6 - 1 ) ;\n"
                ],
                [
                    57,
                    " model_name [ device_pos - model_pos - 6 - 1 ] = '\\0' ;\n"
                ],
                [
                    60,
                    " if ( model_name [ 0 ] == '\\0' ) strcpy ( model_name , \"unknown\" ) ;\n"
                ],
                [
                    61,
                    " verbose_print ( \"VERBOSE: Processing device: \\\"%s\\\" <%s>\\n\" , serial_number , model_name ) ;\n"
                ],
                [
                    81,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_WIFI_TCPDUMP , model_name , serial_number , \"Android WiFi\" ) ;\n"
                ],
                [
                    115,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_EVENTS , model_name , serial_number , \"Android Logcat Events\" ) ;\n"
                ],
                [
                    122,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_CRASH , model_name , serial_number , \"Android Logcat Crash\" ) ;\n"
                ],
                [
                    158,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_HCIDUMP , model_name , serial_number , \"Android Bluetooth Hcidump\" ) ;\n"
                ],
                [
                    235,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER , model_name , serial_number , \"Android Bluetooth External Parser\" ) ;\n"
                ],
                [
                    315,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET , model_name , serial_number , \"Android Bluetooth Btsnoop Net\" ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n"
                ],
                [
                    179,
                    " if ( ! response || data_length < 1 ) {\n"
                ],
                [
                    187,
                    " memset ( pid , 0 , sizeof ( pid ) ) ;\n"
                ],
                [
                    190,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n"
                ],
                [
                    191,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n"
                ],
                [
                    259,
                    " if ( ! response || data_length < 1 ) {\n"
                ],
                [
                    267,
                    " memset ( pid , 0 , sizeof ( pid ) ) ;\n"
                ],
                [
                    270,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n"
                ],
                [
                    271,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n"
                ]
            ],
            "strchr": [
                [
                    1,
                    "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n"
                ],
                [
                    38,
                    " while ( pos < ( char * ) ( device_list + device_length ) ) {\n"
                ],
                [
                    40,
                    " pos = strchr ( pos , ' ' ) ;\n"
                ],
                [
                    41,
                    " i_pos = pos ;\n"
                ],
                [
                    42,
                    " result = ( int ) ( pos - prev_pos ) ;\n"
                ],
                [
                    43,
                    " pos = strchr ( pos , '\\n' ) + 1 ;\n"
                ],
                [
                    52,
                    " model_pos = g_strstr_len ( i_pos , pos - i_pos , \"model:\" ) ;\n"
                ],
                [
                    179,
                    " if ( ! response || data_length < 1 ) {\n"
                ],
                [
                    188,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    189,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    190,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n"
                ],
                [
                    214,
                    " if ( ! response ) {\n"
                ],
                [
                    218,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    219,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    220,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"10EA\" ) == 0 ) {\n"
                ],
                [
                    259,
                    " if ( ! response || data_length < 1 ) {\n"
                ],
                [
                    268,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    269,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    270,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n"
                ],
                [
                    294,
                    " if ( ! response ) {\n"
                ],
                [
                    298,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    299,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    300,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"22A8\" ) == 0 ) {\n"
                ]
            ],
            "strcmp": [
                [
                    1,
                    "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n"
                ],
                [
                    206,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n"
                ],
                [
                    220,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"10EA\" ) == 0 ) {\n"
                ],
                [
                    286,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n"
                ],
                [
                    300,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"22A8\" ) == 0 ) {\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n"
                ],
                [
                    10,
                    " const char * adb_check_port_templace = \"%04x\" \"shell:cat /proc/%set/tcp\" ;\n"
                ],
                [
                    44,
                    " if ( result >= ( int ) sizeof ( serial_number ) ) {\n"
                ],
                [
                    48,
                    " memcpy ( serial_number , prev_pos , result ) ;\n"
                ],
                [
                    49,
                    " serial_number [ result ] = '\\0' ;\n"
                ],
                [
                    50,
                    " serial_number_length = strlen ( serial_number ) ;\n"
                ],
                [
                    61,
                    " verbose_print ( \"VERBOSE: Processing device: \\\"%s\\\" <%s>\\n\" , serial_number , model_name ) ;\n"
                ],
                [
                    64,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    90,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    128,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    165,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    191,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n"
                ],
                [
                    194,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    201,
                    " if ( result ) {\n"
                ],
                [
                    206,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n"
                ],
                [
                    242,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    271,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n"
                ],
                [
                    274,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    281,
                    " if ( result ) {\n"
                ],
                [
                    286,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n"
                ]
            ],
            "strstr": [
                [
                    1,
                    "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n"
                ],
                [
                    76,
                    " response = adb_send_and_read ( sock , adb_tcpdump_help , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n"
                ],
                [
                    78,
                    " if ( response ) {\n"
                ],
                [
                    79,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    80,
                    " if ( strstr ( response , \"tcpdump version\" ) ) {\n"
                ],
                [
                    81,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_WIFI_TCPDUMP , model_name , serial_number , \"Android WiFi\" ) ;\n"
                ]
            ],
            "sscanf": [
                [
                    1,
                    "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n"
                ],
                [
                    38,
                    " while ( pos < ( char * ) ( device_list + device_length ) ) {\n"
                ],
                [
                    179,
                    " if ( ! response || data_length < 1 ) {\n"
                ],
                [
                    187,
                    " memset ( pid , 0 , sizeof ( pid ) ) ;\n"
                ],
                [
                    189,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    190,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n"
                ],
                [
                    191,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n"
                ],
                [
                    192,
                    " sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n"
                ],
                [
                    193,
                    " if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_1 ;\n"
                ],
                [
                    206,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n"
                ],
                [
                    214,
                    " if ( ! response ) {\n"
                ],
                [
                    219,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    220,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"10EA\" ) == 0 ) {\n"
                ],
                [
                    221,
                    " verbose_print ( \"VERBOSE: Bluedroid External Parser Port for %s is %s\\n\" , serial_number , pid + 9 ) ;\n"
                ],
                [
                    224,
                    " disable_interface = 1 ;\n"
                ],
                [
                    225,
                    " verbose_print ( \"VERBOSE: Bluedroid External Parser Port for %s is unknown\\n\" , serial_number ) ;\n"
                ],
                [
                    230,
                    " disable_interface = 1 ;\n"
                ],
                [
                    231,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n"
                ],
                [
                    234,
                    " if ( ! disable_interface ) {\n"
                ],
                [
                    238,
                    " if ( api_level >= 21 ) {\n"
                ],
                [
                    259,
                    " if ( ! response || data_length < 1 ) {\n"
                ],
                [
                    267,
                    " memset ( pid , 0 , sizeof ( pid ) ) ;\n"
                ],
                [
                    269,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    270,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n"
                ],
                [
                    271,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n"
                ],
                [
                    272,
                    " sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n"
                ],
                [
                    273,
                    " if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_2 ;\n"
                ],
                [
                    286,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n"
                ],
                [
                    294,
                    " if ( ! response ) {\n"
                ],
                [
                    299,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    300,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"22A8\" ) == 0 ) {\n"
                ],
                [
                    301,
                    " verbose_print ( \"VERBOSE: Btsnoop Net Port for %s is %s\\n\" , serial_number , pid + 9 ) ;\n"
                ],
                [
                    304,
                    " disable_interface = 1 ;\n"
                ],
                [
                    305,
                    " verbose_print ( \"VERBOSE: Btsnoop Net Port for %s is unknown\\n\" , serial_number ) ;\n"
                ],
                [
                    310,
                    " disable_interface = 1 ;\n"
                ],
                [
                    311,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n"
                ],
                [
                    314,
                    " if ( ! disable_interface ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n"
                ],
                [
                    10,
                    " const char * adb_check_port_templace = \"%04x\" \"shell:cat /proc/%set/tcp\" ;\n"
                ],
                [
                    19,
                    " char model_name [ MODEL_NAME_LENGTH_MAX ] ;\n"
                ],
                [
                    38,
                    " while ( pos < ( char * ) ( device_list + device_length ) ) {\n"
                ],
                [
                    40,
                    " pos = strchr ( pos , ' ' ) ;\n"
                ],
                [
                    41,
                    " i_pos = pos ;\n"
                ],
                [
                    42,
                    " result = ( int ) ( pos - prev_pos ) ;\n"
                ],
                [
                    43,
                    " pos = strchr ( pos , '\\n' ) + 1 ;\n"
                ],
                [
                    44,
                    " if ( result >= ( int ) sizeof ( serial_number ) ) {\n"
                ],
                [
                    48,
                    " memcpy ( serial_number , prev_pos , result ) ;\n"
                ],
                [
                    49,
                    " serial_number [ result ] = '\\0' ;\n"
                ],
                [
                    50,
                    " serial_number_length = strlen ( serial_number ) ;\n"
                ],
                [
                    51,
                    " model_name [ 0 ] = '\\0' ;\n"
                ],
                [
                    52,
                    " model_pos = g_strstr_len ( i_pos , pos - i_pos , \"model:\" ) ;\n"
                ],
                [
                    55,
                    " if ( device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX ) {\n"
                ],
                [
                    56,
                    " memcpy ( model_name , model_pos + 6 , device_pos - model_pos - 6 - 1 ) ;\n"
                ],
                [
                    57,
                    " model_name [ device_pos - model_pos - 6 - 1 ] = '\\0' ;\n"
                ],
                [
                    60,
                    " if ( model_name [ 0 ] == '\\0' ) strcpy ( model_name , \"unknown\" ) ;\n"
                ],
                [
                    61,
                    " verbose_print ( \"VERBOSE: Processing device: \\\"%s\\\" <%s>\\n\" , serial_number , model_name ) ;\n"
                ],
                [
                    64,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    76,
                    " response = adb_send_and_read ( sock , adb_tcpdump_help , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n"
                ],
                [
                    78,
                    " if ( response ) {\n"
                ],
                [
                    79,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    80,
                    " if ( strstr ( response , \"tcpdump version\" ) ) {\n"
                ],
                [
                    81,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_WIFI_TCPDUMP , model_name , serial_number , \"Android WiFi\" ) ;\n"
                ],
                [
                    90,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    115,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_EVENTS , model_name , serial_number , \"Android Logcat Events\" ) ;\n"
                ],
                [
                    122,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_CRASH , model_name , serial_number , \"Android Logcat Crash\" ) ;\n"
                ],
                [
                    128,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    158,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_HCIDUMP , model_name , serial_number , \"Android Bluetooth Hcidump\" ) ;\n"
                ],
                [
                    165,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    179,
                    " if ( ! response || data_length < 1 ) {\n"
                ],
                [
                    187,
                    " memset ( pid , 0 , sizeof ( pid ) ) ;\n"
                ],
                [
                    188,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    189,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    190,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n"
                ],
                [
                    191,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n"
                ],
                [
                    192,
                    " sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n"
                ],
                [
                    193,
                    " if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_1 ;\n"
                ],
                [
                    194,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    201,
                    " if ( result ) {\n"
                ],
                [
                    206,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n"
                ],
                [
                    214,
                    " if ( ! response ) {\n"
                ],
                [
                    218,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    219,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    220,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"10EA\" ) == 0 ) {\n"
                ],
                [
                    221,
                    " verbose_print ( \"VERBOSE: Bluedroid External Parser Port for %s is %s\\n\" , serial_number , pid + 9 ) ;\n"
                ],
                [
                    224,
                    " disable_interface = 1 ;\n"
                ],
                [
                    225,
                    " verbose_print ( \"VERBOSE: Bluedroid External Parser Port for %s is unknown\\n\" , serial_number ) ;\n"
                ],
                [
                    230,
                    " disable_interface = 1 ;\n"
                ],
                [
                    231,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n"
                ],
                [
                    234,
                    " if ( ! disable_interface ) {\n"
                ],
                [
                    235,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER , model_name , serial_number , \"Android Bluetooth External Parser\" ) ;\n"
                ],
                [
                    238,
                    " if ( api_level >= 21 ) {\n"
                ],
                [
                    242,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    259,
                    " if ( ! response || data_length < 1 ) {\n"
                ],
                [
                    267,
                    " memset ( pid , 0 , sizeof ( pid ) ) ;\n"
                ],
                [
                    268,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    269,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    270,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 ) {\n"
                ],
                [
                    271,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is %s\\n\" , serial_number , pid ) ;\n"
                ],
                [
                    272,
                    " sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n"
                ],
                [
                    273,
                    " if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_2 ;\n"
                ],
                [
                    274,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n"
                ],
                [
                    281,
                    " if ( result ) {\n"
                ],
                [
                    286,
                    " result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n"
                ],
                [
                    294,
                    " if ( ! response ) {\n"
                ],
                [
                    298,
                    " response [ data_length ] = '\\0' ;\n"
                ],
                [
                    299,
                    " data_str = strchr ( response , '\\n' ) ;\n"
                ],
                [
                    300,
                    " if ( data_str && sscanf ( data_str , \"%*s %s\" , pid ) == 1 && strcmp ( pid + 9 , \"22A8\" ) == 0 ) {\n"
                ],
                [
                    301,
                    " verbose_print ( \"VERBOSE: Btsnoop Net Port for %s is %s\\n\" , serial_number , pid + 9 ) ;\n"
                ],
                [
                    304,
                    " disable_interface = 1 ;\n"
                ],
                [
                    305,
                    " verbose_print ( \"VERBOSE: Btsnoop Net Port for %s is unknown\\n\" , serial_number ) ;\n"
                ],
                [
                    310,
                    " disable_interface = 1 ;\n"
                ],
                [
                    311,
                    " verbose_print ( \"VERBOSE: Android Bluetooth application PID for %s is unknown\\n\" , serial_number ) ;\n"
                ],
                [
                    314,
                    " if ( ! disable_interface ) {\n"
                ],
                [
                    315,
                    " new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET , model_name , serial_number , \"Android Bluetooth Btsnoop Net\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n krb5_error_code ret ;\n char * ptr ;\n unsigned int plen , vno ;\n krb5_data ap_req , ap_rep = empty_data ( ) ;\n krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ;\n krb5_auth_context auth_context = NULL ;\n krb5_principal changepw = NULL ;\n krb5_principal client , target = NULL ;\n krb5_ticket * ticket = NULL ;\n krb5_replay_data replay ;\n krb5_error krberror ;\n int numresult ;\n char strresult [ 1024 ] ;\n char * clientstr = NULL , * targetstr = NULL ;\n const char * errmsg = NULL ;\n size_t clen ;\n char * cdots ;\n struct sockaddr_storage ss ;\n socklen_t salen ;\n char addrbuf [ 100 ] ;\n krb5_address * addr = remote_faddr -> address ;\n * rep = empty_data ( ) ;\n if ( req -> length < 4 ) {\n ret = KRB5KRB_AP_ERR_MODIFIED ;\n numresult = KRB5_KPASSWD_MALFORMED ;\n strlcpy ( strresult , \"Request was truncated\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ptr = req -> data ;\n plen = ( * ptr ++ & 0xff ) ;\n plen = ( plen << 8 ) | ( * ptr ++ & 0xff ) ;\n if ( plen != req -> length ) {\n ret = KRB5KRB_AP_ERR_MODIFIED ;\n numresult = KRB5_KPASSWD_MALFORMED ;\n strlcpy ( strresult , \"Request length was inconsistent\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n vno = ( * ptr ++ & 0xff ) ;\n vno = ( vno << 8 ) | ( * ptr ++ & 0xff ) ;\n if ( vno != 1 && vno != RFC3244_VERSION ) {\n ret = KRB5KDC_ERR_BAD_PVNO ;\n numresult = KRB5_KPASSWD_BAD_VERSION ;\n snprintf ( strresult , sizeof ( strresult ) , \"Request contained unknown protocol version number %d\" , vno ) ;\n goto chpwfail ;\n }\n ap_req . length = ( * ptr ++ & 0xff ) ;\n ap_req . length = ( ap_req . length << 8 ) | ( * ptr ++ & 0xff ) ;\n if ( ptr + ap_req . length >= req -> data + req -> length ) {\n ret = KRB5KRB_AP_ERR_MODIFIED ;\n numresult = KRB5_KPASSWD_MALFORMED ;\n strlcpy ( strresult , \"Request was truncated in AP-REQ\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ap_req . data = ptr ;\n ptr += ap_req . length ;\n ret = krb5_auth_con_init ( context , & auth_context ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed initializing auth context\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ret = krb5_auth_con_setflags ( context , auth_context , KRB5_AUTH_CONTEXT_DO_SEQUENCE ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed initializing auth context\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , \"kadmin\" , \"changepw\" , NULL ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed building kadmin/changepw principal\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ret = krb5_rd_req ( context , & auth_context , & ap_req , changepw , keytab , NULL , & ticket ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_AUTHERROR ;\n strlcpy ( strresult , \"Failed reading application request\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ret = krb5_mk_rep ( context , auth_context , & ap_rep ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_AUTHERROR ;\n strlcpy ( strresult , \"Failed replying to application request\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n cipher . length = ( req -> data + req -> length ) - ptr ;\n cipher . data = ptr ;\n ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed decrypting request\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n client = ticket -> enc_part2 -> client ;\n if ( vno == RFC3244_VERSION ) {\n krb5_data * clear_data ;\n ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ;\n if ( ret != 0 ) {\n numresult = KRB5_KPASSWD_MALFORMED ;\n strlcpy ( strresult , \"Failed decoding ChangePasswdData\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n zapfree ( clear . data , clear . length ) ;\n clear = * clear_data ;\n free ( clear_data ) ;\n if ( target != NULL ) {\n ret = krb5_unparse_name ( context , target , & targetstr ) ;\n if ( ret != 0 ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed unparsing target name for log\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n }\n }\n ret = krb5_unparse_name ( context , client , & clientstr ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed unparsing client name for log\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n if ( vno == 1 && ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) {\n numresult = KRB5_KPASSWD_INITIAL_FLAG_NEEDED ;\n strlcpy ( strresult , \"Ticket must be derived from a password\" , sizeof ( strresult ) ) ;\n goto chpwfail ;\n }\n ptr = k5memdup0 ( clear . data , clear . length , & ret ) ;\n ret = schpw_util_wrapper ( server_handle , client , target , ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , ptr , NULL , strresult , sizeof ( strresult ) ) ;\n if ( ret ) errmsg = krb5_get_error_message ( context , ret ) ;\n zapfree ( clear . data , clear . length ) ;\n zapfree ( ptr , clear . length ) ;\n clear = empty_data ( ) ;\n clen = strlen ( clientstr ) ;\n trunc_name ( & clen , & cdots ) ;\n switch ( addr -> addrtype ) {\n case ADDRTYPE_INET : {\n struct sockaddr_in * sin = ss2sin ( & ss ) ;\n sin -> sin_family = AF_INET ;\n memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ;\n sin -> sin_port = htons ( remote_faddr -> port ) ;\n salen = sizeof ( * sin ) ;\n break ;\n }\n case ADDRTYPE_INET6 : {\n struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ;\n sin6 -> sin6_family = AF_INET6 ;\n memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ;\n sin6 -> sin6_port = htons ( remote_faddr -> port ) ;\n salen = sizeof ( * sin6 ) ;\n break ;\n }\n default : {\n struct sockaddr * sa = ss2sa ( & ss ) ;\n sa -> sa_family = AF_UNSPEC ;\n salen = sizeof ( * sa ) ;\n break ;\n }\n }\n if ( getnameinfo ( ss2sa ( & ss ) , salen , addrbuf , sizeof ( addrbuf ) , NULL , 0 , NI_NUMERICHOST | NI_NUMERICSERV ) != 0 ) strlcpy ( addrbuf , \"<unprintable>\" , sizeof ( addrbuf ) ) ;\n if ( vno == RFC3244_VERSION ) {\n size_t tlen ;\n char * tdots ;\n const char * targetp ;\n if ( target == NULL ) {\n tlen = clen ;\n tdots = cdots ;\n targetp = targetstr ;\n }\n else {\n tlen = strlen ( targetstr ) ;\n trunc_name ( & tlen , & tdots ) ;\n targetp = clientstr ;\n }\n krb5_klog_syslog ( LOG_NOTICE , _ ( \"setpw request from %s by %.*s%s for \" \"%.*s%s: %s\" ) , addrbuf , ( int ) clen , clientstr , cdots , ( int ) tlen , targetp , tdots , errmsg ? errmsg : \"success\" ) ;\n }\n else {\n krb5_klog_syslog ( LOG_NOTICE , _ ( \"chpw request from %s for %.*s%s: %s\" ) , addrbuf , ( int ) clen , clientstr , cdots , errmsg ? errmsg : \"success\" ) ;\n }\n switch ( ret ) {\n case KADM5_AUTH_CHANGEPW : numresult = KRB5_KPASSWD_ACCESSDENIED ;\n break ;\n case KADM5_PASS_Q_TOOSHORT : case KADM5_PASS_REUSE : case KADM5_PASS_Q_CLASS : case KADM5_PASS_Q_DICT : case KADM5_PASS_Q_GENERIC : case KADM5_PASS_TOOSOON : numresult = KRB5_KPASSWD_SOFTERROR ;\n break ;\n case 0 : numresult = KRB5_KPASSWD_SUCCESS ;\n strlcpy ( strresult , \"\" , sizeof ( strresult ) ) ;\n break ;\n default : numresult = KRB5_KPASSWD_HARDERROR ;\n break ;\n }\n chpwfail : clear . length = 2 + strlen ( strresult ) ;\n clear . data = ( char * ) malloc ( clear . length ) ;\n ptr = clear . data ;\n * ptr ++ = ( numresult >> 8 ) & 0xff ;\n * ptr ++ = numresult & 0xff ;\n memcpy ( ptr , strresult , strlen ( strresult ) ) ;\n cipher = empty_data ( ) ;\n if ( ap_rep . length ) {\n ret = krb5_auth_con_setaddrs ( context , auth_context , local_faddr -> address , NULL ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed storing client and server internet addresses\" , sizeof ( strresult ) ) ;\n }\n else {\n ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ;\n if ( ret ) {\n numresult = KRB5_KPASSWD_HARDERROR ;\n strlcpy ( strresult , \"Failed encrypting reply\" , sizeof ( strresult ) ) ;\n }\n }\n }\n if ( cipher . length == 0 ) {\n if ( ap_rep . length ) {\n free ( ap_rep . data ) ;\n ap_rep = empty_data ( ) ;\n }\n krberror . ctime = 0 ;\n krberror . cusec = 0 ;\n krberror . susec = 0 ;\n ret = krb5_timeofday ( context , & krberror . stime ) ;\n if ( ret ) goto bailout ;\n krberror . error = ret ;\n krberror . error -= ERROR_TABLE_BASE_krb5 ;\n if ( krberror . error < 0 || krberror . error > 128 ) krberror . error = KRB_ERR_GENERIC ;\n krberror . client = NULL ;\n ret = krb5_build_principal ( context , & krberror . server , strlen ( realm ) , realm , \"kadmin\" , \"changepw\" , NULL ) ;\n if ( ret ) goto bailout ;\n krberror . text . length = 0 ;\n krberror . e_data = clear ;\n ret = krb5_mk_error ( context , & krberror , & cipher ) ;\n krb5_free_principal ( context , krberror . server ) ;\n if ( ret ) goto bailout ;\n }\n ret = alloc_data ( rep , 6 + ap_rep . length + cipher . length ) ;\n if ( ret ) goto bailout ;\n ptr = rep -> data ;\n * ptr ++ = ( rep -> length >> 8 ) & 0xff ;\n * ptr ++ = rep -> length & 0xff ;\n * ptr ++ = 0 ;\n * ptr ++ = 1 ;\n * ptr ++ = ( ap_rep . length >> 8 ) & 0xff ;\n * ptr ++ = ap_rep . length & 0xff ;\n if ( ap_rep . length ) {\n memcpy ( ptr , ap_rep . data , ap_rep . length ) ;\n ptr += ap_rep . length ;\n }\n memcpy ( ptr , cipher . data , cipher . length ) ;\n bailout : krb5_auth_con_free ( context , auth_context ) ;\n krb5_free_principal ( context , changepw ) ;\n krb5_free_ticket ( context , ticket ) ;\n free ( ap_rep . data ) ;\n free ( clear . data ) ;\n free ( cipher . data ) ;\n krb5_free_principal ( context , target ) ;\n krb5_free_unparsed_name ( context , targetstr ) ;\n krb5_free_unparsed_name ( context , clientstr ) ;\n krb5_free_error_message ( context , errmsg ) ;\n return ret ;\n }",
        "hash": 217269231454293846,
        "project": "debian",
        "size": 258,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n"
                ],
                [
                    5,
                    " krb5_data ap_req , ap_rep = empty_data ( ) ;\n"
                ],
                [
                    22,
                    " krb5_address * addr = remote_faddr -> address ;\n"
                ],
                [
                    89,
                    " ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ;\n"
                ],
                [
                    135,
                    " switch ( addr -> addrtype ) {\n"
                ],
                [
                    137,
                    " struct sockaddr_in * sin = ss2sin ( & ss ) ;\n"
                ],
                [
                    139,
                    " memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ;\n"
                ],
                [
                    145,
                    " struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ;\n"
                ],
                [
                    147,
                    " memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ;\n"
                ],
                [
                    194,
                    " * ptr ++ = numresult & 0xff ;\n"
                ],
                [
                    195,
                    " memcpy ( ptr , strresult , strlen ( strresult ) ) ;\n"
                ],
                [
                    196,
                    " cipher = empty_data ( ) ;\n"
                ],
                [
                    204,
                    " ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ;\n"
                ],
                [
                    211,
                    " if ( cipher . length == 0 ) {\n"
                ],
                [
                    214,
                    " ap_rep = empty_data ( ) ;\n"
                ],
                [
                    234,
                    " if ( ret ) goto bailout ;\n"
                ],
                [
                    241,
                    " * ptr ++ = ap_rep . length & 0xff ;\n"
                ],
                [
                    242,
                    " if ( ap_rep . length ) {\n"
                ],
                [
                    243,
                    " memcpy ( ptr , ap_rep . data , ap_rep . length ) ;\n"
                ],
                [
                    244,
                    " ptr += ap_rep . length ;\n"
                ],
                [
                    246,
                    " memcpy ( ptr , cipher . data , cipher . length ) ;\n"
                ],
                [
                    250,
                    " free ( ap_rep . data ) ;\n"
                ],
                [
                    252,
                    " free ( cipher . data ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n"
                ],
                [
                    15,
                    " char * clientstr = NULL , * targetstr = NULL ;\n"
                ],
                [
                    27,
                    " strlcpy ( strresult , \"Request was truncated\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    36,
                    " strlcpy ( strresult , \"Request length was inconsistent\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    44,
                    " snprintf ( strresult , sizeof ( strresult ) , \"Request contained unknown protocol version number %d\" , vno ) ;\n"
                ],
                [
                    52,
                    " strlcpy ( strresult , \"Request was truncated in AP-REQ\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    60,
                    " strlcpy ( strresult , \"Failed initializing auth context\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    64,
                    " if ( ret ) {\n"
                ],
                [
                    66,
                    " strlcpy ( strresult , \"Failed initializing auth context\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    69,
                    " ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , \"kadmin\" , \"changepw\" , NULL ) ;\n"
                ],
                [
                    72,
                    " strlcpy ( strresult , \"Failed building kadmin/changepw principal\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    78,
                    " strlcpy ( strresult , \"Failed reading application request\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    84,
                    " strlcpy ( strresult , \"Failed replying to application request\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    92,
                    " strlcpy ( strresult , \"Failed decrypting request\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    101,
                    " strlcpy ( strresult , \"Failed decoding ChangePasswdData\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    108,
                    " ret = krb5_unparse_name ( context , target , & targetstr ) ;\n"
                ],
                [
                    111,
                    " strlcpy ( strresult , \"Failed unparsing target name for log\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    116,
                    " ret = krb5_unparse_name ( context , client , & clientstr ) ;\n"
                ],
                [
                    119,
                    " strlcpy ( strresult , \"Failed unparsing client name for log\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    122,
                    " if ( vno == 1 && ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) {\n"
                ],
                [
                    124,
                    " strlcpy ( strresult , \"Ticket must be derived from a password\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    128,
                    " ret = schpw_util_wrapper ( server_handle , client , target , ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , ptr , NULL , strresult , sizeof ( strresult ) ) ;\n"
                ],
                [
                    133,
                    " clen = strlen ( clientstr ) ;\n"
                ],
                [
                    134,
                    " trunc_name ( & clen , & cdots ) ;\n"
                ],
                [
                    164,
                    " if ( target == NULL ) {\n"
                ],
                [
                    165,
                    " tlen = clen ;\n"
                ],
                [
                    170,
                    " tlen = strlen ( targetstr ) ;\n"
                ],
                [
                    171,
                    " trunc_name ( & tlen , & tdots ) ;\n"
                ],
                [
                    172,
                    " targetp = clientstr ;\n"
                ],
                [
                    174,
                    " krb5_klog_syslog ( LOG_NOTICE , _ ( \"setpw request from %s by %.*s%s for \" \"%.*s%s: %s\" ) , addrbuf , ( int ) clen , clientstr , cdots , ( int ) tlen , targetp , tdots , errmsg ? errmsg : \"success\" ) ;\n"
                ],
                [
                    177,
                    " krb5_klog_syslog ( LOG_NOTICE , _ ( \"chpw request from %s for %.*s%s: %s\" ) , addrbuf , ( int ) clen , clientstr , cdots , errmsg ? errmsg : \"success\" ) ;\n"
                ],
                [
                    185,
                    " strlcpy ( strresult , \"\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    190,
                    " chpwfail : clear . length = 2 + strlen ( strresult ) ;\n"
                ],
                [
                    191,
                    " clear . data = ( char * ) malloc ( clear . length ) ;\n"
                ],
                [
                    194,
                    " * ptr ++ = numresult & 0xff ;\n"
                ],
                [
                    195,
                    " memcpy ( ptr , strresult , strlen ( strresult ) ) ;\n"
                ],
                [
                    220,
                    " if ( ret ) goto bailout ;\n"
                ],
                [
                    225,
                    " ret = krb5_build_principal ( context , & krberror . server , strlen ( realm ) , realm , \"kadmin\" , \"changepw\" , NULL ) ;\n"
                ],
                [
                    254,
                    " krb5_free_unparsed_name ( context , targetstr ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n"
                ],
                [
                    6,
                    " krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ;\n"
                ],
                [
                    89,
                    " ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ;\n"
                ],
                [
                    105,
                    " clear = * clear_data ;\n"
                ],
                [
                    132,
                    " clear = empty_data ( ) ;\n"
                ],
                [
                    190,
                    " chpwfail : clear . length = 2 + strlen ( strresult ) ;\n"
                ],
                [
                    191,
                    " clear . data = ( char * ) malloc ( clear . length ) ;\n"
                ],
                [
                    192,
                    " ptr = clear . data ;\n"
                ],
                [
                    204,
                    " ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ;\n"
                ],
                [
                    228,
                    " krberror . e_data = clear ;\n"
                ],
                [
                    251,
                    " free ( clear . data ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n"
                ],
                [
                    5,
                    " krb5_data ap_req , ap_rep = empty_data ( ) ;\n"
                ],
                [
                    6,
                    " krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ;\n"
                ],
                [
                    89,
                    " ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ;\n"
                ],
                [
                    98,
                    " ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ;\n"
                ],
                [
                    99,
                    " if ( ret != 0 ) {\n"
                ],
                [
                    105,
                    " clear = * clear_data ;\n"
                ],
                [
                    106,
                    " free ( clear_data ) ;\n"
                ],
                [
                    132,
                    " clear = empty_data ( ) ;\n"
                ],
                [
                    191,
                    " clear . data = ( char * ) malloc ( clear . length ) ;\n"
                ],
                [
                    196,
                    " cipher = empty_data ( ) ;\n"
                ],
                [
                    204,
                    " ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ;\n"
                ],
                [
                    211,
                    " if ( cipher . length == 0 ) {\n"
                ],
                [
                    212,
                    " if ( ap_rep . length ) {\n"
                ],
                [
                    213,
                    " free ( ap_rep . data ) ;\n"
                ],
                [
                    214,
                    " ap_rep = empty_data ( ) ;\n"
                ],
                [
                    243,
                    " memcpy ( ptr , ap_rep . data , ap_rep . length ) ;\n"
                ],
                [
                    246,
                    " memcpy ( ptr , cipher . data , cipher . length ) ;\n"
                ],
                [
                    250,
                    " free ( ap_rep . data ) ;\n"
                ],
                [
                    251,
                    " free ( clear . data ) ;\n"
                ],
                [
                    252,
                    " free ( cipher . data ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n"
                ],
                [
                    5,
                    " krb5_data ap_req , ap_rep = empty_data ( ) ;\n"
                ],
                [
                    6,
                    " krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ;\n"
                ],
                [
                    15,
                    " char * clientstr = NULL , * targetstr = NULL ;\n"
                ],
                [
                    22,
                    " krb5_address * addr = remote_faddr -> address ;\n"
                ],
                [
                    27,
                    " strlcpy ( strresult , \"Request was truncated\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    36,
                    " strlcpy ( strresult , \"Request length was inconsistent\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    44,
                    " snprintf ( strresult , sizeof ( strresult ) , \"Request contained unknown protocol version number %d\" , vno ) ;\n"
                ],
                [
                    52,
                    " strlcpy ( strresult , \"Request was truncated in AP-REQ\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    60,
                    " strlcpy ( strresult , \"Failed initializing auth context\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    64,
                    " if ( ret ) {\n"
                ],
                [
                    66,
                    " strlcpy ( strresult , \"Failed initializing auth context\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    69,
                    " ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , \"kadmin\" , \"changepw\" , NULL ) ;\n"
                ],
                [
                    72,
                    " strlcpy ( strresult , \"Failed building kadmin/changepw principal\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    78,
                    " strlcpy ( strresult , \"Failed reading application request\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    84,
                    " strlcpy ( strresult , \"Failed replying to application request\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    89,
                    " ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ;\n"
                ],
                [
                    92,
                    " strlcpy ( strresult , \"Failed decrypting request\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    98,
                    " ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ;\n"
                ],
                [
                    99,
                    " if ( ret != 0 ) {\n"
                ],
                [
                    101,
                    " strlcpy ( strresult , \"Failed decoding ChangePasswdData\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    105,
                    " clear = * clear_data ;\n"
                ],
                [
                    106,
                    " free ( clear_data ) ;\n"
                ],
                [
                    108,
                    " ret = krb5_unparse_name ( context , target , & targetstr ) ;\n"
                ],
                [
                    111,
                    " strlcpy ( strresult , \"Failed unparsing target name for log\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    116,
                    " ret = krb5_unparse_name ( context , client , & clientstr ) ;\n"
                ],
                [
                    119,
                    " strlcpy ( strresult , \"Failed unparsing client name for log\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    122,
                    " if ( vno == 1 && ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) {\n"
                ],
                [
                    124,
                    " strlcpy ( strresult , \"Ticket must be derived from a password\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    128,
                    " ret = schpw_util_wrapper ( server_handle , client , target , ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , ptr , NULL , strresult , sizeof ( strresult ) ) ;\n"
                ],
                [
                    132,
                    " clear = empty_data ( ) ;\n"
                ],
                [
                    133,
                    " clen = strlen ( clientstr ) ;\n"
                ],
                [
                    134,
                    " trunc_name ( & clen , & cdots ) ;\n"
                ],
                [
                    135,
                    " switch ( addr -> addrtype ) {\n"
                ],
                [
                    137,
                    " struct sockaddr_in * sin = ss2sin ( & ss ) ;\n"
                ],
                [
                    139,
                    " memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ;\n"
                ],
                [
                    145,
                    " struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ;\n"
                ],
                [
                    147,
                    " memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ;\n"
                ],
                [
                    164,
                    " if ( target == NULL ) {\n"
                ],
                [
                    165,
                    " tlen = clen ;\n"
                ],
                [
                    170,
                    " tlen = strlen ( targetstr ) ;\n"
                ],
                [
                    171,
                    " trunc_name ( & tlen , & tdots ) ;\n"
                ],
                [
                    172,
                    " targetp = clientstr ;\n"
                ],
                [
                    174,
                    " krb5_klog_syslog ( LOG_NOTICE , _ ( \"setpw request from %s by %.*s%s for \" \"%.*s%s: %s\" ) , addrbuf , ( int ) clen , clientstr , cdots , ( int ) tlen , targetp , tdots , errmsg ? errmsg : \"success\" ) ;\n"
                ],
                [
                    177,
                    " krb5_klog_syslog ( LOG_NOTICE , _ ( \"chpw request from %s for %.*s%s: %s\" ) , addrbuf , ( int ) clen , clientstr , cdots , errmsg ? errmsg : \"success\" ) ;\n"
                ],
                [
                    185,
                    " strlcpy ( strresult , \"\" , sizeof ( strresult ) ) ;\n"
                ],
                [
                    190,
                    " chpwfail : clear . length = 2 + strlen ( strresult ) ;\n"
                ],
                [
                    191,
                    " clear . data = ( char * ) malloc ( clear . length ) ;\n"
                ],
                [
                    192,
                    " ptr = clear . data ;\n"
                ],
                [
                    194,
                    " * ptr ++ = numresult & 0xff ;\n"
                ],
                [
                    195,
                    " memcpy ( ptr , strresult , strlen ( strresult ) ) ;\n"
                ],
                [
                    196,
                    " cipher = empty_data ( ) ;\n"
                ],
                [
                    204,
                    " ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ;\n"
                ],
                [
                    211,
                    " if ( cipher . length == 0 ) {\n"
                ],
                [
                    212,
                    " if ( ap_rep . length ) {\n"
                ],
                [
                    213,
                    " free ( ap_rep . data ) ;\n"
                ],
                [
                    214,
                    " ap_rep = empty_data ( ) ;\n"
                ],
                [
                    220,
                    " if ( ret ) goto bailout ;\n"
                ],
                [
                    225,
                    " ret = krb5_build_principal ( context , & krberror . server , strlen ( realm ) , realm , \"kadmin\" , \"changepw\" , NULL ) ;\n"
                ],
                [
                    228,
                    " krberror . e_data = clear ;\n"
                ],
                [
                    234,
                    " if ( ret ) goto bailout ;\n"
                ],
                [
                    241,
                    " * ptr ++ = ap_rep . length & 0xff ;\n"
                ],
                [
                    242,
                    " if ( ap_rep . length ) {\n"
                ],
                [
                    243,
                    " memcpy ( ptr , ap_rep . data , ap_rep . length ) ;\n"
                ],
                [
                    244,
                    " ptr += ap_rep . length ;\n"
                ],
                [
                    246,
                    " memcpy ( ptr , cipher . data , cipher . length ) ;\n"
                ],
                [
                    250,
                    " free ( ap_rep . data ) ;\n"
                ],
                [
                    251,
                    " free ( clear . data ) ;\n"
                ],
                [
                    252,
                    " free ( cipher . data ) ;\n"
                ],
                [
                    254,
                    " krb5_free_unparsed_name ( context , targetstr ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "rfbBool rfbSendTextChatMessage ( rfbClientPtr cl , uint32_t length , char * buffer ) {\n rfbTextChatMsg tc ;\n int bytesToSend = 0 ;\n memset ( ( char * ) & tc , 0 , sizeof ( tc ) ) ;\n tc . type = rfbTextChat ;\n tc . length = Swap32IfLE ( length ) ;\n switch ( length ) {\n case rfbTextChatOpen : case rfbTextChatClose : case rfbTextChatFinished : bytesToSend = 0 ;\n break ;\n default : bytesToSend = length ;\n if ( bytesToSend > rfbTextMaxSize ) bytesToSend = rfbTextMaxSize ;\n }\n if ( cl -> ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE ) {\n if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n }\n memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & tc , sz_rfbTextChatMsg ) ;\n cl -> ublen += sz_rfbTextChatMsg ;\n if ( bytesToSend > 0 ) {\n memcpy ( & cl -> updateBuf [ cl -> ublen ] , buffer , bytesToSend ) ;\n cl -> ublen += bytesToSend ;\n }\n rfbStatRecordMessageSent ( cl , rfbTextChat , sz_rfbTextChatMsg + bytesToSend , sz_rfbTextChatMsg + bytesToSend ) ;\n if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n return TRUE ;\n }",
        "hash": 6250095321513210169,
        "project": "debian",
        "size": 25,
        "slice": {
            "memcpy": [
                [
                    1,
                    "rfbBool rfbSendTextChatMessage ( rfbClientPtr cl , uint32_t length , char * buffer ) {\n"
                ],
                [
                    5,
                    " tc . type = rfbTextChat ;\n"
                ],
                [
                    6,
                    " tc . length = Swap32IfLE ( length ) ;\n"
                ],
                [
                    13,
                    " if ( cl -> ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE ) {\n"
                ],
                [
                    14,
                    " if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n"
                ],
                [
                    16,
                    " memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & tc , sz_rfbTextChatMsg ) ;\n"
                ],
                [
                    17,
                    " cl -> ublen += sz_rfbTextChatMsg ;\n"
                ],
                [
                    18,
                    " if ( bytesToSend > 0 ) {\n"
                ],
                [
                    19,
                    " memcpy ( & cl -> updateBuf [ cl -> ublen ] , buffer , bytesToSend ) ;\n"
                ],
                [
                    20,
                    " cl -> ublen += bytesToSend ;\n"
                ],
                [
                    22,
                    " rfbStatRecordMessageSent ( cl , rfbTextChat , sz_rfbTextChatMsg + bytesToSend , sz_rfbTextChatMsg + bytesToSend ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "rfbBool rfbSendTextChatMessage ( rfbClientPtr cl , uint32_t length , char * buffer ) {\n"
                ],
                [
                    4,
                    " memset ( ( char * ) & tc , 0 , sizeof ( tc ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "rfbBool rfbSendTextChatMessage ( rfbClientPtr cl , uint32_t length , char * buffer ) {\n"
                ],
                [
                    4,
                    " memset ( ( char * ) & tc , 0 , sizeof ( tc ) ) ;\n"
                ],
                [
                    5,
                    " tc . type = rfbTextChat ;\n"
                ],
                [
                    6,
                    " tc . length = Swap32IfLE ( length ) ;\n"
                ],
                [
                    13,
                    " if ( cl -> ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE ) {\n"
                ],
                [
                    14,
                    " if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n"
                ],
                [
                    16,
                    " memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & tc , sz_rfbTextChatMsg ) ;\n"
                ],
                [
                    17,
                    " cl -> ublen += sz_rfbTextChatMsg ;\n"
                ],
                [
                    18,
                    " if ( bytesToSend > 0 ) {\n"
                ],
                [
                    19,
                    " memcpy ( & cl -> updateBuf [ cl -> ublen ] , buffer , bytesToSend ) ;\n"
                ],
                [
                    20,
                    " cl -> ublen += bytesToSend ;\n"
                ],
                [
                    22,
                    " rfbStatRecordMessageSent ( cl , rfbTextChat , sz_rfbTextChatMsg + bytesToSend , sz_rfbTextChatMsg + bytesToSend ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) {\n char * buffer = NULL ;\n int n = 0 ;\n FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( \"\" , cl , NULL ) ;\n if ( length > 0 ) {\n buffer = malloc ( length + 1 ) ;\n if ( buffer != NULL ) {\n if ( ( n = rfbReadExact ( cl , ( char * ) buffer , length ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessFileTransferReadBuffer: read\" ) ;\n rfbCloseClient ( cl ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return NULL ;\n }\n buffer [ length ] = 0 ;\n }\n }\n return buffer ;\n }",
        "hash": 6250095321513210169,
        "project": "debian",
        "size": 18,
        "slice": {
            "malloc": [
                [
                    1,
                    "char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) {\n"
                ],
                [
                    5,
                    " if ( length > 0 ) {\n"
                ],
                [
                    6,
                    " buffer = malloc ( length + 1 ) ;\n"
                ],
                [
                    7,
                    " if ( buffer != NULL ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) {\n"
                ],
                [
                    11,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) {\n"
                ],
                [
                    5,
                    " if ( length > 0 ) {\n"
                ],
                [
                    6,
                    " buffer = malloc ( length + 1 ) ;\n"
                ],
                [
                    7,
                    " if ( buffer != NULL ) {\n"
                ],
                [
                    11,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n char * buffer = NULL , * p = NULL ;\n int retval = 0 ;\n char filename1 [ MAX_PATH ] ;\n char filename2 [ MAX_PATH ] ;\n char szFileTime [ MAX_PATH ] ;\n struct stat statbuf ;\n uint32_t sizeHtmp = 0 ;\n int n = 0 ;\n char timespec [ 64 ] ;\n # ifdef LIBVNCSERVER_HAVE_LIBZ unsigned char compBuff [ sz_rfbBlockSize ] ;\n unsigned long nRawBytes = sz_rfbBlockSize ;\n int nRet = 0 ;\n # endif FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( \"\" , cl , FALSE ) ;\n switch ( contentType ) {\n case rfbDirContentRequest : switch ( contentParam ) {\n case rfbRDrivesList : filename2 [ 0 ] = 'C' ;\n filename2 [ 1 ] = ':' ;\n filename2 [ 2 ] = 'l' ;\n filename2 [ 3 ] = 0 ;\n filename2 [ 4 ] = 0 ;\n retval = rfbSendFileTransferMessage ( cl , rfbDirPacket , rfbADrivesList , 0 , 5 , filename2 ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return retval ;\n break ;\n case rfbRDirContent : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n retval = rfbSendDirContent ( cl , length , buffer ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return retval ;\n }\n break ;\n case rfbDirPacket : rfbLog ( \"rfbProcessFileTransfer() rfbDirPacket\\n\" ) ;\n break ;\n case rfbFileAcceptHeader : rfbLog ( \"rfbProcessFileTransfer() rfbFileAcceptHeader\\n\" ) ;\n break ;\n case rfbCommandReturn : rfbLog ( \"rfbProcessFileTransfer() rfbCommandReturn\\n\" ) ;\n break ;\n case rfbFileChecksums : rfbLog ( \"rfbProcessFileTransfer() rfbFileChecksums\\n\" ) ;\n break ;\n case rfbFileTransferAccess : rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferAccess\\n\" ) ;\n break ;\n case rfbFileTransferRequest : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n cl -> fileTransfer . fd = open ( filename1 , O_RDONLY , 0744 ) ;\n if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\") Open: %s fd=%d\\n\" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? \"Failed\" : \"Success\" ) , cl -> fileTransfer . fd ) ;\n if ( cl -> fileTransfer . fd != - 1 ) {\n if ( fstat ( cl -> fileTransfer . fd , & statbuf ) != 0 ) {\n close ( cl -> fileTransfer . fd ) ;\n cl -> fileTransfer . fd = - 1 ;\n }\n else {\n strftime ( timespec , sizeof ( timespec ) , \"%m/%d/%Y %H:%M\" , gmtime ( & statbuf . st_ctime ) ) ;\n buffer = realloc ( buffer , length + strlen ( timespec ) + 2 ) ;\n if ( buffer == NULL ) {\n rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\\n\" , length + strlen ( timespec ) + 2 ) ;\n return FALSE ;\n }\n strcat ( buffer , \",\" ) ;\n strcat ( buffer , timespec ) ;\n length = strlen ( buffer ) ;\n if ( DB ) rfbLog ( \"rfbProcessFileTransfer() buffer is now: \\\"%s\\\"\\n\" , buffer ) ;\n }\n }\n cl -> fileTransfer . compressionEnabled = ( size == 1 ) ;\n retval = rfbSendFileTransferMessage ( cl , rfbFileHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : statbuf . st_size ) , length , buffer ) ;\n if ( cl -> fileTransfer . fd == - 1 ) {\n if ( buffer != NULL ) free ( buffer ) ;\n return retval ;\n }\n cl -> fileTransfer . fileSize = statbuf . st_size ;\n cl -> fileTransfer . numPackets = statbuf . st_size / sz_rfbBlockSize ;\n cl -> fileTransfer . receiving = 0 ;\n cl -> fileTransfer . sending = 0 ;\n sizeHtmp = 0 ;\n LOCK ( cl -> sendMutex ) ;\n if ( rfbWriteExact ( cl , ( char * ) & sizeHtmp , 4 ) < 0 ) {\n rfbLogPerror ( \"rfbProcessFileTransfer: write\" ) ;\n rfbCloseClient ( cl ) ;\n UNLOCK ( cl -> sendMutex ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return FALSE ;\n }\n UNLOCK ( cl -> sendMutex ) ;\n break ;\n case rfbFileHeader : if ( size == - 1 ) {\n rfbLog ( \"rfbProcessFileTransfer() rfbFileHeader (error, aborting)\\n\" ) ;\n close ( cl -> fileTransfer . fd ) ;\n cl -> fileTransfer . fd = - 1 ;\n return TRUE ;\n }\n cl -> fileTransfer . sending = 1 ;\n return rfbSendFileTransferChunk ( cl ) ;\n break ;\n case rfbFileTransferOffer : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n p = strrchr ( buffer , ',' ) ;\n if ( p != NULL ) {\n * p = '\\0' ;\n strncpy ( szFileTime , p + 1 , sizeof ( szFileTime ) ) ;\n szFileTime [ sizeof ( szFileTime ) - 1 ] = '\\x00' ;\n }\n else szFileTime [ 0 ] = 0 ;\n if ( ( n = rfbReadExact ( cl , ( char * ) & sizeHtmp , 4 ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessFileTransfer: read sizeHtmp\" ) ;\n rfbCloseClient ( cl ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return FALSE ;\n }\n sizeHtmp = Swap32IfLE ( sizeHtmp ) ;\n if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n cl -> fileTransfer . fd = open ( filename1 , O_CREAT | O_WRONLY | O_TRUNC , 0744 ) ;\n if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferOffer(\\\"%s\\\"->\\\"%s\\\") %s %s fd=%d\\n\" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? \"Failed\" : \"Success\" ) , ( cl -> fileTransfer . fd == - 1 ? strerror ( errno ) : \"\" ) , cl -> fileTransfer . fd ) ;\n retval = rfbSendFileTransferMessage ( cl , rfbFileAcceptHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : 0 ) , length , buffer ) ;\n if ( cl -> fileTransfer . fd == - 1 ) {\n free ( buffer ) ;\n return retval ;\n }\n cl -> fileTransfer . fileSize = size ;\n cl -> fileTransfer . numPackets = size / sz_rfbBlockSize ;\n cl -> fileTransfer . receiving = 1 ;\n cl -> fileTransfer . sending = 0 ;\n break ;\n case rfbFilePacket : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n if ( cl -> fileTransfer . fd != - 1 ) {\n if ( size == 0 ) retval = write ( cl -> fileTransfer . fd , buffer , length ) ;\n else {\n # ifdef LIBVNCSERVER_HAVE_LIBZ nRet = uncompress ( compBuff , & nRawBytes , ( const unsigned char * ) buffer , length ) ;\n if ( nRet == Z_OK ) retval = write ( cl -> fileTransfer . fd , ( char * ) compBuff , nRawBytes ) ;\n else retval = - 1 ;\n # else retval = write ( cl -> fileTransfer . fd , buffer , length ) ;\n # endif }\n if ( retval == - 1 ) {\n close ( cl -> fileTransfer . fd ) ;\n cl -> fileTransfer . fd = - 1 ;\n cl -> fileTransfer . sending = 0 ;\n cl -> fileTransfer . receiving = 0 ;\n }\n }\n break ;\n case rfbEndOfFile : if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbEndOfFile\\n\" ) ;\n if ( cl -> fileTransfer . fd != - 1 ) close ( cl -> fileTransfer . fd ) ;\n cl -> fileTransfer . fd = - 1 ;\n cl -> fileTransfer . sending = 0 ;\n cl -> fileTransfer . receiving = 0 ;\n break ;\n case rfbAbortFileTransfer : if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbAbortFileTransfer\\n\" ) ;\n if ( cl -> fileTransfer . fd != - 1 ) {\n close ( cl -> fileTransfer . fd ) ;\n cl -> fileTransfer . fd = - 1 ;\n cl -> fileTransfer . sending = 0 ;\n cl -> fileTransfer . receiving = 0 ;\n }\n else {\n if ( contentParam == 0 ) {\n rfbLog ( \"rfbProcessFileTransfer() File Transfer Permission DENIED! (Client Version <=RC18)\\n\" ) ;\n return rfbSendFileTransferMessage ( cl , rfbAbortFileTransfer , 0 , - 1 , 0 , \"\" ) ;\n }\n if ( cl -> screen -> getFileTransferPermission != NULL ) {\n if ( cl -> screen -> getFileTransferPermission ( cl ) == TRUE ) {\n rfbLog ( \"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\" ) ;\n return rfbSendFileTransferMessage ( cl , rfbFileTransferAccess , 0 , 1 , 0 , \"\" ) ;\n }\n else {\n rfbLog ( \"rfbProcessFileTransfer() File Transfer Permission DENIED!\\n\" ) ;\n return rfbSendFileTransferMessage ( cl , rfbFileTransferAccess , 0 , - 1 , 0 , \"\" ) ;\n }\n }\n else {\n if ( cl -> screen -> permitFileTransfer ) {\n rfbLog ( \"rfbProcessFileTransfer() File Transfer Permission Granted!\\n\" ) ;\n return rfbSendFileTransferMessage ( cl , rfbFileTransferAccess , 0 , 1 , 0 , \"\" ) ;\n }\n else {\n rfbLog ( \"rfbProcessFileTransfer() File Transfer Permission DENIED by default!\\n\" ) ;\n return rfbSendFileTransferMessage ( cl , rfbFileTransferAccess , 0 , - 1 , 0 , \"\" ) ;\n }\n }\n }\n break ;\n case rfbCommand : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n switch ( contentParam ) {\n case rfbCDirCreate : if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n retval = mkdir ( filename1 , 0755 ) ;\n if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbCommand: rfbCDirCreate(\\\"%s\\\"->\\\"%s\\\") %s\\n\" , buffer , filename1 , ( retval == - 1 ? \"Failed\" : \"Success\" ) ) ;\n retval = rfbSendFileTransferMessage ( cl , rfbCommandReturn , rfbADirCreate , retval , length , buffer ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return retval ;\n case rfbCFileDelete : if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n if ( stat ( filename1 , & statbuf ) == 0 ) {\n if ( S_ISDIR ( statbuf . st_mode ) ) retval = rmdir ( filename1 ) ;\n else retval = unlink ( filename1 ) ;\n }\n else retval = - 1 ;\n retval = rfbSendFileTransferMessage ( cl , rfbCommandReturn , rfbAFileDelete , retval , length , buffer ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return retval ;\n case rfbCFileRename : p = strrchr ( buffer , '*' ) ;\n if ( p != NULL ) {\n * p = '\\0' ;\n if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n if ( ! rfbFilenameTranslate2UNIX ( cl , p + 1 , filename2 , sizeof ( filename2 ) ) ) goto fail ;\n retval = rename ( filename1 , filename2 ) ;\n if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbCommand: rfbCFileRename(\\\"%s\\\"->\\\"%s\\\" -->> \\\"%s\\\"->\\\"%s\\\") %s\\n\" , buffer , filename1 , p + 1 , filename2 , ( retval == - 1 ? \"Failed\" : \"Success\" ) ) ;\n * p = '*' ;\n retval = rfbSendFileTransferMessage ( cl , rfbCommandReturn , rfbAFileRename , retval , length , buffer ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return retval ;\n }\n break ;\n }\n break ;\n }\n if ( buffer != NULL ) free ( buffer ) ;\n return TRUE ;\n fail : if ( buffer != NULL ) free ( buffer ) ;\n return FALSE ;\n }",
        "hash": 6250095321513210169,
        "project": "debian",
        "size": 216,
        "slice": {
            "strncpy": [
                [
                    1,
                    "rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n"
                ],
                [
                    96,
                    " if ( p != NULL ) {\n"
                ],
                [
                    97,
                    " * p = '\\0' ;\n"
                ],
                [
                    98,
                    " strncpy ( szFileTime , p + 1 , sizeof ( szFileTime ) ) ;\n"
                ]
            ],
            "strcat": [
                [
                    1,
                    "rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n"
                ],
                [
                    53,
                    " buffer = realloc ( buffer , length + strlen ( timespec ) + 2 ) ;\n"
                ],
                [
                    54,
                    " if ( buffer == NULL ) {\n"
                ],
                [
                    58,
                    " strcat ( buffer , \",\" ) ;\n"
                ],
                [
                    59,
                    " strcat ( buffer , timespec ) ;\n"
                ],
                [
                    60,
                    " length = strlen ( buffer ) ;\n"
                ]
            ],
            "strerror": [
                [
                    1,
                    "rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n"
                ],
                [
                    111,
                    " if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferOffer(\\\"%s\\\"->\\\"%s\\\") %s %s fd=%d\\n\" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? \"Failed\" : \"Success\" ) , ( cl -> fileTransfer . fd == - 1 ? strerror ( errno ) : \"\" ) , cl -> fileTransfer . fd ) ;\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n"
                ],
                [
                    42,
                    " case rfbFileTransferRequest : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n"
                ],
                [
                    43,
                    " if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n"
                ],
                [
                    45,
                    " if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\") Open: %s fd=%d\\n\" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? \"Failed\" : \"Success\" ) , cl -> fileTransfer . fd ) ;\n"
                ],
                [
                    47,
                    " if ( fstat ( cl -> fileTransfer . fd , & statbuf ) != 0 ) {\n"
                ],
                [
                    52,
                    " strftime ( timespec , sizeof ( timespec ) , \"%m/%d/%Y %H:%M\" , gmtime ( & statbuf . st_ctime ) ) ;\n"
                ],
                [
                    53,
                    " buffer = realloc ( buffer , length + strlen ( timespec ) + 2 ) ;\n"
                ],
                [
                    54,
                    " if ( buffer == NULL ) {\n"
                ],
                [
                    55,
                    " rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\\n\" , length + strlen ( timespec ) + 2 ) ;\n"
                ],
                [
                    59,
                    " strcat ( buffer , timespec ) ;\n"
                ],
                [
                    60,
                    " length = strlen ( buffer ) ;\n"
                ],
                [
                    61,
                    " if ( DB ) rfbLog ( \"rfbProcessFileTransfer() buffer is now: \\\"%s\\\"\\n\" , buffer ) ;\n"
                ],
                [
                    65,
                    " retval = rfbSendFileTransferMessage ( cl , rfbFileHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : statbuf . st_size ) , length , buffer ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n"
                ],
                [
                    23,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    28,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    67,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    80,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    105,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    112,
                    " retval = rfbSendFileTransferMessage ( cl , rfbFileAcceptHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : 0 ) , length , buffer ) ;\n"
                ],
                [
                    113,
                    " if ( cl -> fileTransfer . fd == - 1 ) {\n"
                ],
                [
                    114,
                    " free ( buffer ) ;\n"
                ],
                [
                    185,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    194,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    205,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    212,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    214,
                    " fail : if ( buffer != NULL ) free ( buffer ) ;\n"
                ]
            ],
            "realloc": [
                [
                    1,
                    "rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n"
                ],
                [
                    42,
                    " case rfbFileTransferRequest : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n"
                ],
                [
                    43,
                    " if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n"
                ],
                [
                    45,
                    " if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\") Open: %s fd=%d\\n\" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? \"Failed\" : \"Success\" ) , cl -> fileTransfer . fd ) ;\n"
                ],
                [
                    47,
                    " if ( fstat ( cl -> fileTransfer . fd , & statbuf ) != 0 ) {\n"
                ],
                [
                    53,
                    " buffer = realloc ( buffer , length + strlen ( timespec ) + 2 ) ;\n"
                ],
                [
                    54,
                    " if ( buffer == NULL ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n"
                ],
                [
                    23,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    28,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    42,
                    " case rfbFileTransferRequest : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n"
                ],
                [
                    43,
                    " if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n"
                ],
                [
                    45,
                    " if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferRequest(\\\"%s\\\"->\\\"%s\\\") Open: %s fd=%d\\n\" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? \"Failed\" : \"Success\" ) , cl -> fileTransfer . fd ) ;\n"
                ],
                [
                    47,
                    " if ( fstat ( cl -> fileTransfer . fd , & statbuf ) != 0 ) {\n"
                ],
                [
                    52,
                    " strftime ( timespec , sizeof ( timespec ) , \"%m/%d/%Y %H:%M\" , gmtime ( & statbuf . st_ctime ) ) ;\n"
                ],
                [
                    53,
                    " buffer = realloc ( buffer , length + strlen ( timespec ) + 2 ) ;\n"
                ],
                [
                    54,
                    " if ( buffer == NULL ) {\n"
                ],
                [
                    55,
                    " rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\\n\" , length + strlen ( timespec ) + 2 ) ;\n"
                ],
                [
                    58,
                    " strcat ( buffer , \",\" ) ;\n"
                ],
                [
                    59,
                    " strcat ( buffer , timespec ) ;\n"
                ],
                [
                    60,
                    " length = strlen ( buffer ) ;\n"
                ],
                [
                    61,
                    " if ( DB ) rfbLog ( \"rfbProcessFileTransfer() buffer is now: \\\"%s\\\"\\n\" , buffer ) ;\n"
                ],
                [
                    65,
                    " retval = rfbSendFileTransferMessage ( cl , rfbFileHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : statbuf . st_size ) , length , buffer ) ;\n"
                ],
                [
                    67,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    80,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    96,
                    " if ( p != NULL ) {\n"
                ],
                [
                    97,
                    " * p = '\\0' ;\n"
                ],
                [
                    98,
                    " strncpy ( szFileTime , p + 1 , sizeof ( szFileTime ) ) ;\n"
                ],
                [
                    105,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    111,
                    " if ( DB ) rfbLog ( \"rfbProcessFileTransfer() rfbFileTransferOffer(\\\"%s\\\"->\\\"%s\\\") %s %s fd=%d\\n\" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? \"Failed\" : \"Success\" ) , ( cl -> fileTransfer . fd == - 1 ? strerror ( errno ) : \"\" ) , cl -> fileTransfer . fd ) ;\n"
                ],
                [
                    112,
                    " retval = rfbSendFileTransferMessage ( cl , rfbFileAcceptHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : 0 ) , length , buffer ) ;\n"
                ],
                [
                    113,
                    " if ( cl -> fileTransfer . fd == - 1 ) {\n"
                ],
                [
                    114,
                    " free ( buffer ) ;\n"
                ],
                [
                    185,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    194,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    205,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    212,
                    " if ( buffer != NULL ) free ( buffer ) ;\n"
                ],
                [
                    214,
                    " fail : if ( buffer != NULL ) free ( buffer ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) {\n int mi_row , mi_col ;\n int mi_index = 0 ;\n MODE_INFO * * mi = cm -> mi_grid_visible ;\n int rows = cm -> mi_rows ;\n int cols = cm -> mi_cols ;\n char prefix = descriptor [ 0 ] ;\n log_frame_info ( cm , descriptor , file ) ;\n mi_index = 0 ;\n for ( mi_row = 0 ;\n mi_row < rows ;\n mi_row ++ ) {\n fprintf ( file , \"%c \" , prefix ) ;\n for ( mi_col = 0 ;\n mi_col < cols ;\n mi_col ++ ) {\n fprintf ( file , \"%2d \" , * ( ( int * ) ( ( char * ) ( & mi [ mi_index ] -> mbmi ) + member_offset ) ) ) ;\n mi_index ++ ;\n }\n fprintf ( file , \"\\n\" ) ;\n mi_index += 8 ;\n }\n fprintf ( file , \"\\n\" ) ;\n }",
        "hash": 7364333987762519984,
        "project": "chrome",
        "size": 24,
        "slice": {
            "fprintf": [
                [
                    1,
                    "static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) {\n"
                ],
                [
                    7,
                    " char prefix = descriptor [ 0 ] ;\n"
                ],
                [
                    8,
                    " log_frame_info ( cm , descriptor , file ) ;\n"
                ],
                [
                    11,
                    " mi_row < rows ;\n"
                ],
                [
                    13,
                    " fprintf ( file , \"%c \" , prefix ) ;\n"
                ],
                [
                    15,
                    " mi_col < cols ;\n"
                ],
                [
                    17,
                    " fprintf ( file , \"%2d \" , * ( ( int * ) ( ( char * ) ( & mi [ mi_index ] -> mbmi ) + member_offset ) ) ) ;\n"
                ],
                [
                    20,
                    " fprintf ( file , \"\\n\" ) ;\n"
                ],
                [
                    23,
                    " fprintf ( file , \"\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) {\n"
                ],
                [
                    7,
                    " char prefix = descriptor [ 0 ] ;\n"
                ],
                [
                    8,
                    " log_frame_info ( cm , descriptor , file ) ;\n"
                ],
                [
                    11,
                    " mi_row < rows ;\n"
                ],
                [
                    13,
                    " fprintf ( file , \"%c \" , prefix ) ;\n"
                ],
                [
                    15,
                    " mi_col < cols ;\n"
                ],
                [
                    17,
                    " fprintf ( file , \"%2d \" , * ( ( int * ) ( ( char * ) ( & mi [ mi_index ] -> mbmi ) + member_offset ) ) ) ;\n"
                ],
                [
                    20,
                    " fprintf ( file , \"\\n\" ) ;\n"
                ],
                [
                    23,
                    " fprintf ( file , \"\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void vp9_print_modes_and_motion_vectors ( VP9_COMMON * cm , const char * file ) {\n int mi_row ;\n int mi_col ;\n int mi_index = 0 ;\n FILE * mvs = fopen ( file , \"a\" ) ;\n MODE_INFO * * mi = cm -> mi_grid_visible ;\n int rows = cm -> mi_rows ;\n int cols = cm -> mi_cols ;\n print_mi_data ( cm , mvs , \"Partitions:\" , offsetof ( MB_MODE_INFO , sb_type ) ) ;\n print_mi_data ( cm , mvs , \"Modes:\" , offsetof ( MB_MODE_INFO , mode ) ) ;\n print_mi_data ( cm , mvs , \"Skips:\" , offsetof ( MB_MODE_INFO , skip ) ) ;\n print_mi_data ( cm , mvs , \"Ref frame:\" , offsetof ( MB_MODE_INFO , ref_frame [ 0 ] ) ) ;\n print_mi_data ( cm , mvs , \"Transform:\" , offsetof ( MB_MODE_INFO , tx_size ) ) ;\n print_mi_data ( cm , mvs , \"UV Modes:\" , offsetof ( MB_MODE_INFO , uv_mode ) ) ;\n log_frame_info ( cm , \"Vectors \" , mvs ) ;\n for ( mi_row = 0 ;\n mi_row < rows ;\n mi_row ++ ) {\n fprintf ( mvs , \"V \" ) ;\n for ( mi_col = 0 ;\n mi_col < cols ;\n mi_col ++ ) {\n fprintf ( mvs , \"%4d:%4d \" , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . col ) ;\n mi_index ++ ;\n }\n fprintf ( mvs , \"\\n\" ) ;\n mi_index += 8 ;\n }\n fprintf ( mvs , \"\\n\" ) ;\n fclose ( mvs ) ;\n }",
        "hash": 7364333987762519984,
        "project": "chrome",
        "size": 31,
        "slice": {
            "fprintf": [
                [
                    1,
                    "void vp9_print_modes_and_motion_vectors ( VP9_COMMON * cm , const char * file ) {\n"
                ],
                [
                    15,
                    " log_frame_info ( cm , \"Vectors \" , mvs ) ;\n"
                ],
                [
                    17,
                    " mi_row < rows ;\n"
                ],
                [
                    19,
                    " fprintf ( mvs , \"V \" ) ;\n"
                ],
                [
                    21,
                    " mi_col < cols ;\n"
                ],
                [
                    23,
                    " fprintf ( mvs , \"%4d:%4d \" , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . col ) ;\n"
                ],
                [
                    26,
                    " fprintf ( mvs , \"\\n\" ) ;\n"
                ],
                [
                    29,
                    " fprintf ( mvs , \"\\n\" ) ;\n"
                ],
                [
                    30,
                    " fclose ( mvs ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void vp9_print_modes_and_motion_vectors ( VP9_COMMON * cm , const char * file ) {\n"
                ],
                [
                    15,
                    " log_frame_info ( cm , \"Vectors \" , mvs ) ;\n"
                ],
                [
                    17,
                    " mi_row < rows ;\n"
                ],
                [
                    19,
                    " fprintf ( mvs , \"V \" ) ;\n"
                ],
                [
                    21,
                    " mi_col < cols ;\n"
                ],
                [
                    23,
                    " fprintf ( mvs , \"%4d:%4d \" , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . col ) ;\n"
                ],
                [
                    26,
                    " fprintf ( mvs , \"\\n\" ) ;\n"
                ],
                [
                    29,
                    " fprintf ( mvs , \"\\n\" ) ;\n"
                ],
                [
                    30,
                    " fclose ( mvs ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , const char * * argv ) {\n AppInput app_input = {\n 0 }\n ;\n VpxVideoWriter * writer = NULL ;\n VpxVideoInfo info = {\n 0 }\n ;\n vpx_codec_ctx_t codec ;\n vpx_codec_enc_cfg_t enc_cfg ;\n SvcContext svc_ctx ;\n uint32_t i ;\n uint32_t frame_cnt = 0 ;\n vpx_image_t raw ;\n vpx_codec_err_t res ;\n int pts = 0 ;\n int frame_duration = 1 ;\n FILE * infile = NULL ;\n int end_of_stream = 0 ;\n int frame_size ;\n memset ( & svc_ctx , 0 , sizeof ( svc_ctx ) ) ;\n svc_ctx . log_print = 1 ;\n exec_name = argv [ 0 ] ;\n parse_command_line ( argc , argv , & app_input , & svc_ctx , & enc_cfg ) ;\n if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , enc_cfg . g_w , enc_cfg . g_h , 32 ) ) die ( \"Failed to allocate image %dx%d\\n\" , enc_cfg . g_w , enc_cfg . g_h ) ;\n if ( ! ( infile = fopen ( app_input . input_filename , \"rb\" ) ) ) die ( \"Failed to open %s for reading\\n\" , app_input . input_filename ) ;\n if ( vpx_svc_init ( & svc_ctx , & codec , vpx_codec_vp9_cx ( ) , & enc_cfg ) != VPX_CODEC_OK ) die ( \"Failed to initialize encoder\\n\" ) ;\n info . codec_fourcc = VP9_FOURCC ;\n info . time_base . numerator = enc_cfg . g_timebase . num ;\n info . time_base . denominator = enc_cfg . g_timebase . den ;\n if ( vpx_svc_get_layer_resolution ( & svc_ctx , svc_ctx . spatial_layers - 1 , ( unsigned int * ) & info . frame_width , ( unsigned int * ) & info . frame_height ) != VPX_CODEC_OK ) {\n die ( \"Failed to get output resolution\" ) ;\n }\n if ( ! ( app_input . passes == 2 && app_input . pass == 1 ) ) {\n writer = vpx_video_writer_open ( app_input . output_filename , kContainerIVF , & info ) ;\n if ( ! writer ) die ( \"Failed to open %s for writing\\n\" , app_input . output_filename ) ;\n }\n for ( i = 0 ;\n i < app_input . frames_to_skip ;\n ++ i ) vpx_img_read ( & raw , infile ) ;\n while ( ! end_of_stream ) {\n if ( frame_cnt >= app_input . frames_to_code || ! vpx_img_read ( & raw , infile ) ) {\n end_of_stream = 1 ;\n }\n res = vpx_svc_encode ( & svc_ctx , & codec , ( end_of_stream ? NULL : & raw ) , pts , frame_duration , VPX_DL_GOOD_QUALITY ) ;\n printf ( \"%s\" , vpx_svc_get_message ( & svc_ctx ) ) ;\n if ( res != VPX_CODEC_OK ) {\n die_codec ( & codec , \"Failed to encode frame\" ) ;\n }\n if ( ! ( app_input . passes == 2 && app_input . pass == 1 ) ) {\n while ( ( frame_size = vpx_svc_get_frame_size ( & svc_ctx ) ) > 0 ) {\n vpx_video_writer_write_frame ( writer , vpx_svc_get_buffer ( & svc_ctx ) , frame_size , pts ) ;\n }\n }\n if ( vpx_svc_get_rc_stats_buffer_size ( & svc_ctx ) > 0 ) {\n stats_write ( & app_input . rc_stats , vpx_svc_get_rc_stats_buffer ( & svc_ctx ) , vpx_svc_get_rc_stats_buffer_size ( & svc_ctx ) ) ;\n }\n if ( ! end_of_stream ) {\n ++ frame_cnt ;\n pts += frame_duration ;\n }\n }\n printf ( \"Processed %d frames\\n\" , frame_cnt ) ;\n fclose ( infile ) ;\n if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed to destroy codec\" ) ;\n if ( app_input . passes == 2 ) stats_close ( & app_input . rc_stats , 1 ) ;\n if ( writer ) {\n vpx_video_writer_close ( writer ) ;\n }\n vpx_img_free ( & raw ) ;\n printf ( \"%s\" , vpx_svc_dump_statistics ( & svc_ctx ) ) ;\n vpx_svc_release ( & svc_ctx ) ;\n return EXIT_SUCCESS ;\n }",
        "hash": 6809509104003465181,
        "project": "chrome",
        "size": 74,
        "slice": {
            "memset": [
                [
                    1,
                    "int main ( int argc , const char * * argv ) {\n"
                ],
                [
                    21,
                    " memset ( & svc_ctx , 0 , sizeof ( svc_ctx ) ) ;\n"
                ],
                [
                    24,
                    " parse_command_line ( argc , argv , & app_input , & svc_ctx , & enc_cfg ) ;\n"
                ],
                [
                    27,
                    " if ( vpx_svc_init ( & svc_ctx , & codec , vpx_codec_vp9_cx ( ) , & enc_cfg ) != VPX_CODEC_OK ) die ( \"Failed to initialize encoder\\n\" ) ;\n"
                ],
                [
                    31,
                    " if ( vpx_svc_get_layer_resolution ( & svc_ctx , svc_ctx . spatial_layers - 1 , ( unsigned int * ) & info . frame_width , ( unsigned int * ) & info . frame_height ) != VPX_CODEC_OK ) {\n"
                ],
                [
                    45,
                    " res = vpx_svc_encode ( & svc_ctx , & codec , ( end_of_stream ? NULL : & raw ) , pts , frame_duration , VPX_DL_GOOD_QUALITY ) ;\n"
                ],
                [
                    46,
                    " printf ( \"%s\" , vpx_svc_get_message ( & svc_ctx ) ) ;\n"
                ],
                [
                    51,
                    " while ( ( frame_size = vpx_svc_get_frame_size ( & svc_ctx ) ) > 0 ) {\n"
                ],
                [
                    52,
                    " vpx_video_writer_write_frame ( writer , vpx_svc_get_buffer ( & svc_ctx ) , frame_size , pts ) ;\n"
                ],
                [
                    55,
                    " if ( vpx_svc_get_rc_stats_buffer_size ( & svc_ctx ) > 0 ) {\n"
                ],
                [
                    56,
                    " stats_write ( & app_input . rc_stats , vpx_svc_get_rc_stats_buffer ( & svc_ctx ) , vpx_svc_get_rc_stats_buffer_size ( & svc_ctx ) ) ;\n"
                ],
                [
                    71,
                    " printf ( \"%s\" , vpx_svc_dump_statistics ( & svc_ctx ) ) ;\n"
                ],
                [
                    72,
                    " vpx_svc_release ( & svc_ctx ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "int main ( int argc , const char * * argv ) {\n"
                ],
                [
                    13,
                    " uint32_t frame_cnt = 0 ;\n"
                ],
                [
                    41,
                    " while ( ! end_of_stream ) {\n"
                ],
                [
                    42,
                    " if ( frame_cnt >= app_input . frames_to_code || ! vpx_img_read ( & raw , infile ) ) {\n"
                ],
                [
                    46,
                    " printf ( \"%s\" , vpx_svc_get_message ( & svc_ctx ) ) ;\n"
                ],
                [
                    59,
                    " ++ frame_cnt ;\n"
                ],
                [
                    63,
                    " printf ( \"Processed %d frames\\n\" , frame_cnt ) ;\n"
                ],
                [
                    71,
                    " printf ( \"%s\" , vpx_svc_dump_statistics ( & svc_ctx ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , const char * * argv ) {\n"
                ],
                [
                    13,
                    " uint32_t frame_cnt = 0 ;\n"
                ],
                [
                    21,
                    " memset ( & svc_ctx , 0 , sizeof ( svc_ctx ) ) ;\n"
                ],
                [
                    24,
                    " parse_command_line ( argc , argv , & app_input , & svc_ctx , & enc_cfg ) ;\n"
                ],
                [
                    27,
                    " if ( vpx_svc_init ( & svc_ctx , & codec , vpx_codec_vp9_cx ( ) , & enc_cfg ) != VPX_CODEC_OK ) die ( \"Failed to initialize encoder\\n\" ) ;\n"
                ],
                [
                    31,
                    " if ( vpx_svc_get_layer_resolution ( & svc_ctx , svc_ctx . spatial_layers - 1 , ( unsigned int * ) & info . frame_width , ( unsigned int * ) & info . frame_height ) != VPX_CODEC_OK ) {\n"
                ],
                [
                    41,
                    " while ( ! end_of_stream ) {\n"
                ],
                [
                    42,
                    " if ( frame_cnt >= app_input . frames_to_code || ! vpx_img_read ( & raw , infile ) ) {\n"
                ],
                [
                    45,
                    " res = vpx_svc_encode ( & svc_ctx , & codec , ( end_of_stream ? NULL : & raw ) , pts , frame_duration , VPX_DL_GOOD_QUALITY ) ;\n"
                ],
                [
                    46,
                    " printf ( \"%s\" , vpx_svc_get_message ( & svc_ctx ) ) ;\n"
                ],
                [
                    51,
                    " while ( ( frame_size = vpx_svc_get_frame_size ( & svc_ctx ) ) > 0 ) {\n"
                ],
                [
                    52,
                    " vpx_video_writer_write_frame ( writer , vpx_svc_get_buffer ( & svc_ctx ) , frame_size , pts ) ;\n"
                ],
                [
                    55,
                    " if ( vpx_svc_get_rc_stats_buffer_size ( & svc_ctx ) > 0 ) {\n"
                ],
                [
                    56,
                    " stats_write ( & app_input . rc_stats , vpx_svc_get_rc_stats_buffer ( & svc_ctx ) , vpx_svc_get_rc_stats_buffer_size ( & svc_ctx ) ) ;\n"
                ],
                [
                    59,
                    " ++ frame_cnt ;\n"
                ],
                [
                    63,
                    " printf ( \"Processed %d frames\\n\" , frame_cnt ) ;\n"
                ],
                [
                    71,
                    " printf ( \"%s\" , vpx_svc_dump_statistics ( & svc_ctx ) ) ;\n"
                ],
                [
                    72,
                    " vpx_svc_release ( & svc_ctx ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n struct arg arg = {\n 0 }\n ;\n char * * argv = NULL ;\n char * * argi = NULL ;\n char * * argj = NULL ;\n vpx_codec_err_t res ;\n int passes = 0 ;\n int pass = 0 ;\n const char * fpf_file_name = NULL ;\n unsigned int min_bitrate = 0 ;\n unsigned int max_bitrate = 0 ;\n svc_ctx -> log_level = SVC_LOG_DEBUG ;\n svc_ctx -> spatial_layers = default_spatial_layers ;\n svc_ctx -> temporal_layers = default_temporal_layers ;\n res = vpx_codec_enc_config_default ( vpx_codec_vp9_cx ( ) , enc_cfg , 0 ) ;\n if ( res ) {\n die ( \"Failed to get config: %s\\n\" , vpx_codec_err_to_string ( res ) ) ;\n }\n enc_cfg -> g_w = default_width ;\n enc_cfg -> g_h = default_height ;\n enc_cfg -> g_timebase . num = default_timebase_num ;\n enc_cfg -> g_timebase . den = default_timebase_den ;\n enc_cfg -> rc_target_bitrate = default_bitrate ;\n enc_cfg -> kf_min_dist = default_kf_dist ;\n enc_cfg -> kf_max_dist = default_kf_dist ;\n enc_cfg -> rc_end_usage = VPX_CQ ;\n app_input -> frames_to_code = default_frames_to_code ;\n app_input -> frames_to_skip = default_frames_to_skip ;\n argv = argv_dup ( argc - 1 , argv_ + 1 ) ;\n for ( argi = argj = argv ;\n ( * argj = * argi ) ;\n argi += arg . argv_step ) {\n arg . argv_step = 1 ;\n if ( arg_match ( & arg , & frames_arg , argi ) ) {\n app_input -> frames_to_code = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & width_arg , argi ) ) {\n enc_cfg -> g_w = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & height_arg , argi ) ) {\n enc_cfg -> g_h = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & timebase_arg , argi ) ) {\n enc_cfg -> g_timebase = arg_parse_rational ( & arg ) ;\n }\n else if ( arg_match ( & arg , & bitrate_arg , argi ) ) {\n enc_cfg -> rc_target_bitrate = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & skip_frames_arg , argi ) ) {\n app_input -> frames_to_skip = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & spatial_layers_arg , argi ) ) {\n svc_ctx -> spatial_layers = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & temporal_layers_arg , argi ) ) {\n svc_ctx -> temporal_layers = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & kf_dist_arg , argi ) ) {\n enc_cfg -> kf_min_dist = arg_parse_uint ( & arg ) ;\n enc_cfg -> kf_max_dist = enc_cfg -> kf_min_dist ;\n }\n else if ( arg_match ( & arg , & scale_factors_arg , argi ) ) {\n vpx_svc_set_scale_factors ( svc_ctx , arg . val ) ;\n }\n else if ( arg_match ( & arg , & quantizers_arg , argi ) ) {\n vpx_svc_set_quantizers ( svc_ctx , arg . val ) ;\n }\n else if ( arg_match ( & arg , & passes_arg , argi ) ) {\n passes = arg_parse_uint ( & arg ) ;\n if ( passes < 1 || passes > 2 ) {\n die ( \"Error: Invalid number of passes (%d)\\n\" , passes ) ;\n }\n }\n else if ( arg_match ( & arg , & pass_arg , argi ) ) {\n pass = arg_parse_uint ( & arg ) ;\n if ( pass < 1 || pass > 2 ) {\n die ( \"Error: Invalid pass selected (%d)\\n\" , pass ) ;\n }\n }\n else if ( arg_match ( & arg , & fpf_name_arg , argi ) ) {\n fpf_file_name = arg . val ;\n }\n else if ( arg_match ( & arg , & min_q_arg , argi ) ) {\n enc_cfg -> rc_min_quantizer = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & max_q_arg , argi ) ) {\n enc_cfg -> rc_max_quantizer = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & min_bitrate_arg , argi ) ) {\n min_bitrate = arg_parse_uint ( & arg ) ;\n }\n else if ( arg_match ( & arg , & max_bitrate_arg , argi ) ) {\n max_bitrate = arg_parse_uint ( & arg ) ;\n }\n else {\n ++ argj ;\n }\n }\n if ( passes == 0 || passes == 1 ) {\n if ( pass ) {\n fprintf ( stderr , \"pass is ignored since there's only one pass\\n\" ) ;\n }\n enc_cfg -> g_pass = VPX_RC_ONE_PASS ;\n }\n else {\n if ( pass == 0 ) {\n die ( \"pass must be specified when passes is 2\\n\" ) ;\n }\n if ( fpf_file_name == NULL ) {\n die ( \"fpf must be specified when passes is 2\\n\" ) ;\n }\n if ( pass == 1 ) {\n enc_cfg -> g_pass = VPX_RC_FIRST_PASS ;\n if ( ! stats_open_file ( & app_input -> rc_stats , fpf_file_name , 0 ) ) {\n fatal ( \"Failed to open statistics store\" ) ;\n }\n }\n else {\n enc_cfg -> g_pass = VPX_RC_LAST_PASS ;\n if ( ! stats_open_file ( & app_input -> rc_stats , fpf_file_name , 1 ) ) {\n fatal ( \"Failed to open statistics store\" ) ;\n }\n enc_cfg -> rc_twopass_stats_in = stats_get ( & app_input -> rc_stats ) ;\n }\n app_input -> passes = passes ;\n app_input -> pass = pass ;\n }\n if ( enc_cfg -> rc_target_bitrate > 0 ) {\n if ( min_bitrate > 0 ) {\n enc_cfg -> rc_2pass_vbr_minsection_pct = min_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n }\n if ( max_bitrate > 0 ) {\n enc_cfg -> rc_2pass_vbr_maxsection_pct = max_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n }\n }\n for ( argi = argv ;\n * argi ;\n ++ argi ) if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) die ( \"Error: Unrecognized option %s\\n\" , * argi ) ;\n if ( argv [ 0 ] == NULL || argv [ 1 ] == 0 ) {\n usage_exit ( ) ;\n }\n app_input -> input_filename = argv [ 0 ] ;\n app_input -> output_filename = argv [ 1 ] ;\n free ( argv ) ;\n if ( enc_cfg -> g_w < 16 || enc_cfg -> g_w % 2 || enc_cfg -> g_h < 16 || enc_cfg -> g_h % 2 ) die ( \"Invalid resolution: %d x %d\\n\" , enc_cfg -> g_w , enc_cfg -> g_h ) ;\n printf ( \"Codec %s\\nframes: %d, skip: %d\\n\" \"layers: %d\\n\" \"width %d, height: %d,\\n\" \"num: %d, den: %d, bitrate: %d,\\n\" \"gop size: %d\\n\" , vpx_codec_iface_name ( vpx_codec_vp9_cx ( ) ) , app_input -> frames_to_code , app_input -> frames_to_skip , svc_ctx -> spatial_layers , enc_cfg -> g_w , enc_cfg -> g_h , enc_cfg -> g_timebase . num , enc_cfg -> g_timebase . den , enc_cfg -> rc_target_bitrate , enc_cfg -> kf_max_dist ) ;\n }",
        "hash": 6809509104003465181,
        "project": "chrome",
        "size": 149,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n"
                ],
                [
                    138,
                    " for ( argi = argv ;\n"
                ],
                [
                    139,
                    " * argi ;\n"
                ],
                [
                    140,
                    " ++ argi ) if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) die ( \"Error: Unrecognized option %s\\n\" , * argi ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n"
                ],
                [
                    15,
                    " svc_ctx -> spatial_layers = default_spatial_layers ;\n"
                ],
                [
                    17,
                    " res = vpx_codec_enc_config_default ( vpx_codec_vp9_cx ( ) , enc_cfg , 0 ) ;\n"
                ],
                [
                    22,
                    " enc_cfg -> g_h = default_height ;\n"
                ],
                [
                    23,
                    " enc_cfg -> g_timebase . num = default_timebase_num ;\n"
                ],
                [
                    24,
                    " enc_cfg -> g_timebase . den = default_timebase_den ;\n"
                ],
                [
                    27,
                    " enc_cfg -> kf_max_dist = default_kf_dist ;\n"
                ],
                [
                    29,
                    " app_input -> frames_to_code = default_frames_to_code ;\n"
                ],
                [
                    30,
                    " app_input -> frames_to_skip = default_frames_to_skip ;\n"
                ],
                [
                    37,
                    " app_input -> frames_to_code = arg_parse_uint ( & arg ) ;\n"
                ],
                [
                    43,
                    " enc_cfg -> g_h = arg_parse_uint ( & arg ) ;\n"
                ],
                [
                    52,
                    " app_input -> frames_to_skip = arg_parse_uint ( & arg ) ;\n"
                ],
                [
                    55,
                    " svc_ctx -> spatial_layers = arg_parse_uint ( & arg ) ;\n"
                ],
                [
                    62,
                    " enc_cfg -> kf_max_dist = enc_cfg -> kf_min_dist ;\n"
                ],
                [
                    65,
                    " vpx_svc_set_scale_factors ( svc_ctx , arg . val ) ;\n"
                ],
                [
                    68,
                    " vpx_svc_set_quantizers ( svc_ctx , arg . val ) ;\n"
                ],
                [
                    130,
                    " if ( enc_cfg -> rc_target_bitrate > 0 ) {\n"
                ],
                [
                    132,
                    " enc_cfg -> rc_2pass_vbr_minsection_pct = min_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n"
                ],
                [
                    135,
                    " enc_cfg -> rc_2pass_vbr_maxsection_pct = max_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n"
                ],
                [
                    147,
                    " if ( enc_cfg -> g_w < 16 || enc_cfg -> g_w % 2 || enc_cfg -> g_h < 16 || enc_cfg -> g_h % 2 ) die ( \"Invalid resolution: %d x %d\\n\" , enc_cfg -> g_w , enc_cfg -> g_h ) ;\n"
                ],
                [
                    148,
                    " printf ( \"Codec %s\\nframes: %d, skip: %d\\n\" \"layers: %d\\n\" \"width %d, height: %d,\\n\" \"num: %d, den: %d, bitrate: %d,\\n\" \"gop size: %d\\n\" , vpx_codec_iface_name ( vpx_codec_vp9_cx ( ) ) , app_input -> frames_to_code , app_input -> frames_to_skip , svc_ctx -> spatial_layers , enc_cfg -> g_w , enc_cfg -> g_h , enc_cfg -> g_timebase . num , enc_cfg -> g_timebase . den , enc_cfg -> rc_target_bitrate , enc_cfg -> kf_max_dist ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n"
                ],
                [
                    102,
                    " if ( pass ) {\n"
                ],
                [
                    103,
                    " fprintf ( stderr , \"pass is ignored since there's only one pass\\n\" ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n"
                ],
                [
                    31,
                    " argv = argv_dup ( argc - 1 , argv_ + 1 ) ;\n"
                ],
                [
                    141,
                    " if ( argv [ 0 ] == NULL || argv [ 1 ] == 0 ) {\n"
                ],
                [
                    146,
                    " free ( argv ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n"
                ],
                [
                    15,
                    " svc_ctx -> spatial_layers = default_spatial_layers ;\n"
                ],
                [
                    17,
                    " res = vpx_codec_enc_config_default ( vpx_codec_vp9_cx ( ) , enc_cfg , 0 ) ;\n"
                ],
                [
                    22,
                    " enc_cfg -> g_h = default_height ;\n"
                ],
                [
                    23,
                    " enc_cfg -> g_timebase . num = default_timebase_num ;\n"
                ],
                [
                    24,
                    " enc_cfg -> g_timebase . den = default_timebase_den ;\n"
                ],
                [
                    27,
                    " enc_cfg -> kf_max_dist = default_kf_dist ;\n"
                ],
                [
                    29,
                    " app_input -> frames_to_code = default_frames_to_code ;\n"
                ],
                [
                    30,
                    " app_input -> frames_to_skip = default_frames_to_skip ;\n"
                ],
                [
                    31,
                    " argv = argv_dup ( argc - 1 , argv_ + 1 ) ;\n"
                ],
                [
                    37,
                    " app_input -> frames_to_code = arg_parse_uint ( & arg ) ;\n"
                ],
                [
                    43,
                    " enc_cfg -> g_h = arg_parse_uint ( & arg ) ;\n"
                ],
                [
                    52,
                    " app_input -> frames_to_skip = arg_parse_uint ( & arg ) ;\n"
                ],
                [
                    55,
                    " svc_ctx -> spatial_layers = arg_parse_uint ( & arg ) ;\n"
                ],
                [
                    62,
                    " enc_cfg -> kf_max_dist = enc_cfg -> kf_min_dist ;\n"
                ],
                [
                    65,
                    " vpx_svc_set_scale_factors ( svc_ctx , arg . val ) ;\n"
                ],
                [
                    68,
                    " vpx_svc_set_quantizers ( svc_ctx , arg . val ) ;\n"
                ],
                [
                    102,
                    " if ( pass ) {\n"
                ],
                [
                    103,
                    " fprintf ( stderr , \"pass is ignored since there's only one pass\\n\" ) ;\n"
                ],
                [
                    130,
                    " if ( enc_cfg -> rc_target_bitrate > 0 ) {\n"
                ],
                [
                    132,
                    " enc_cfg -> rc_2pass_vbr_minsection_pct = min_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n"
                ],
                [
                    135,
                    " enc_cfg -> rc_2pass_vbr_maxsection_pct = max_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n"
                ],
                [
                    138,
                    " for ( argi = argv ;\n"
                ],
                [
                    139,
                    " * argi ;\n"
                ],
                [
                    140,
                    " ++ argi ) if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) die ( \"Error: Unrecognized option %s\\n\" , * argi ) ;\n"
                ],
                [
                    141,
                    " if ( argv [ 0 ] == NULL || argv [ 1 ] == 0 ) {\n"
                ],
                [
                    146,
                    " free ( argv ) ;\n"
                ],
                [
                    147,
                    " if ( enc_cfg -> g_w < 16 || enc_cfg -> g_w % 2 || enc_cfg -> g_h < 16 || enc_cfg -> g_h % 2 ) die ( \"Invalid resolution: %d x %d\\n\" , enc_cfg -> g_w , enc_cfg -> g_h ) ;\n"
                ],
                [
                    148,
                    " printf ( \"Codec %s\\nframes: %d, skip: %d\\n\" \"layers: %d\\n\" \"width %d, height: %d,\\n\" \"num: %d, den: %d, bitrate: %d,\\n\" \"gop size: %d\\n\" , vpx_codec_iface_name ( vpx_codec_vp9_cx ( ) ) , app_input -> frames_to_code , app_input -> frames_to_skip , svc_ctx -> spatial_layers , enc_cfg -> g_w , enc_cfg -> g_h , enc_cfg -> g_timebase . num , enc_cfg -> g_timebase . den , enc_cfg -> rc_target_bitrate , enc_cfg -> kf_max_dist ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static vpx_fixed_buf_t pass0 ( vpx_image_t * raw , FILE * infile , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n vpx_codec_ctx_t codec ;\n int frame_count = 0 ;\n vpx_fixed_buf_t stats = {\n NULL , 0 }\n ;\n if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , cfg , 0 ) ) die_codec ( & codec , \"Failed to initialize encoder\" ) ;\n while ( vpx_img_read ( raw , infile ) ) {\n ++ frame_count ;\n get_frame_stats ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;\n }\n while ( get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ) {\n }\n printf ( \"Pass 0 complete. Processed %d frames.\\n\" , frame_count ) ;\n if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed to destroy codec.\" ) ;\n return stats ;\n }",
        "hash": -6475363373423390854,
        "project": "chrome",
        "size": 17,
        "slice": {
            "printf": [
                [
                    1,
                    "static vpx_fixed_buf_t pass0 ( vpx_image_t * raw , FILE * infile , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n"
                ],
                [
                    12,
                    " while ( get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ) {\n"
                ],
                [
                    14,
                    " printf ( \"Pass 0 complete. Processed %d frames.\\n\" , frame_count ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static vpx_fixed_buf_t pass0 ( vpx_image_t * raw , FILE * infile , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n"
                ],
                [
                    12,
                    " while ( get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ) {\n"
                ],
                [
                    14,
                    " printf ( \"Pass 0 complete. Processed %d frames.\\n\" , frame_count ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void pass1 ( vpx_image_t * raw , FILE * infile , const char * outfile_name , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n VpxVideoInfo info = {\n encoder -> fourcc , cfg -> g_w , cfg -> g_h , {\n cfg -> g_timebase . num , cfg -> g_timebase . den }\n }\n ;\n VpxVideoWriter * writer = NULL ;\n vpx_codec_ctx_t codec ;\n int frame_count = 0 ;\n writer = vpx_video_writer_open ( outfile_name , kContainerIVF , & info ) ;\n if ( ! writer ) die ( \"Failed to open %s for writing\" , outfile_name ) ;\n if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , cfg , 0 ) ) die_codec ( & codec , \"Failed to initialize encoder\" ) ;\n while ( vpx_img_read ( raw , infile ) ) {\n ++ frame_count ;\n encode_frame ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;\n }\n while ( encode_frame ( & codec , NULL , - 1 , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ) {\n }\n printf ( \"\\n\" ) ;\n if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed to destroy codec.\" ) ;\n vpx_video_writer_close ( writer ) ;\n printf ( \"Pass 1 complete. Processed %d frames.\\n\" , frame_count ) ;\n }",
        "hash": -6475363373423390854,
        "project": "chrome",
        "size": 23,
        "slice": {
            "printf": [
                [
                    1,
                    "static void pass1 ( vpx_image_t * raw , FILE * infile , const char * outfile_name , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n"
                ],
                [
                    9,
                    " int frame_count = 0 ;\n"
                ],
                [
                    15,
                    " encode_frame ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;\n"
                ],
                [
                    19,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    22,
                    " printf ( \"Pass 1 complete. Processed %d frames.\\n\" , frame_count ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void pass1 ( vpx_image_t * raw , FILE * infile , const char * outfile_name , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n"
                ],
                [
                    9,
                    " int frame_count = 0 ;\n"
                ],
                [
                    15,
                    " encode_frame ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;\n"
                ],
                [
                    19,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    22,
                    " printf ( \"Pass 1 complete. Processed %d frames.\\n\" , frame_count ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) {\n char frame [ 6 ] ;\n int pic_sz ;\n int c_w ;\n int c_h ;\n int c_sz ;\n int bytes_per_sample = _y4m -> bit_depth > 8 ? 2 : 1 ;\n if ( ! file_read ( frame , 6 , _fin ) ) return 0 ;\n if ( memcmp ( frame , \"FRAME\" , 5 ) ) {\n fprintf ( stderr , \"Loss of framing in Y4M input data\\n\" ) ;\n return - 1 ;\n }\n if ( frame [ 5 ] != '\\n' ) {\n char c ;\n int j ;\n for ( j = 0 ;\n j < 79 && file_read ( & c , 1 , _fin ) && c != '\\n' ;\n j ++ ) {\n }\n if ( j == 79 ) {\n fprintf ( stderr , \"Error parsing Y4M frame header\\n\" ) ;\n return - 1 ;\n }\n }\n if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) {\n fprintf ( stderr , \"Error reading Y4M frame data.\\n\" ) ;\n return - 1 ;\n }\n if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {\n fprintf ( stderr , \"Error reading Y4M frame data.\\n\" ) ;\n return - 1 ;\n }\n ( * _y4m -> convert ) ( _y4m , _y4m -> dst_buf , _y4m -> aux_buf ) ;\n memset ( _img , 0 , sizeof ( * _img ) ) ;\n _img -> fmt = _y4m -> vpx_fmt ;\n _img -> w = _img -> d_w = _y4m -> pic_w ;\n _img -> h = _img -> d_h = _y4m -> pic_h ;\n _img -> x_chroma_shift = _y4m -> dst_c_dec_h >> 1 ;\n _img -> y_chroma_shift = _y4m -> dst_c_dec_v >> 1 ;\n _img -> bps = _y4m -> bps ;\n pic_sz = _y4m -> pic_w * _y4m -> pic_h * bytes_per_sample ;\n c_w = ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ;\n c_w *= bytes_per_sample ;\n c_h = ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ;\n c_sz = c_w * c_h ;\n _img -> stride [ PLANE_Y ] = _img -> stride [ PLANE_ALPHA ] = _y4m -> pic_w * bytes_per_sample ;\n _img -> stride [ PLANE_U ] = _img -> stride [ PLANE_V ] = c_w ;\n _img -> planes [ PLANE_Y ] = _y4m -> dst_buf ;\n _img -> planes [ PLANE_U ] = _y4m -> dst_buf + pic_sz ;\n _img -> planes [ PLANE_V ] = _y4m -> dst_buf + pic_sz + c_sz ;\n _img -> planes [ PLANE_ALPHA ] = _y4m -> dst_buf + pic_sz + 2 * c_sz ;\n return 1 ;\n }",
        "hash": -5018199117312371093,
        "project": "chrome",
        "size": 53,
        "slice": {
            "memset": [
                [
                    1,
                    "int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) {\n"
                ],
                [
                    29,
                    " if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {\n"
                ],
                [
                    34,
                    " memset ( _img , 0 , sizeof ( * _img ) ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) {\n"
                ],
                [
                    8,
                    " if ( ! file_read ( frame , 6 , _fin ) ) return 0 ;\n"
                ],
                [
                    9,
                    " if ( memcmp ( frame , \"FRAME\" , 5 ) ) {\n"
                ],
                [
                    10,
                    " fprintf ( stderr , \"Loss of framing in Y4M input data\\n\" ) ;\n"
                ],
                [
                    11,
                    " return - 1 ;\n"
                ],
                [
                    13,
                    " if ( frame [ 5 ] != '\\n' ) {\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) {\n"
                ],
                [
                    9,
                    " if ( memcmp ( frame , \"FRAME\" , 5 ) ) {\n"
                ],
                [
                    10,
                    " fprintf ( stderr , \"Loss of framing in Y4M input data\\n\" ) ;\n"
                ],
                [
                    20,
                    " if ( j == 79 ) {\n"
                ],
                [
                    21,
                    " fprintf ( stderr , \"Error parsing Y4M frame header\\n\" ) ;\n"
                ],
                [
                    25,
                    " if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) {\n"
                ],
                [
                    26,
                    " fprintf ( stderr , \"Error reading Y4M frame data.\\n\" ) ;\n"
                ],
                [
                    29,
                    " if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {\n"
                ],
                [
                    30,
                    " fprintf ( stderr , \"Error reading Y4M frame data.\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) {\n"
                ],
                [
                    8,
                    " if ( ! file_read ( frame , 6 , _fin ) ) return 0 ;\n"
                ],
                [
                    9,
                    " if ( memcmp ( frame , \"FRAME\" , 5 ) ) {\n"
                ],
                [
                    10,
                    " fprintf ( stderr , \"Loss of framing in Y4M input data\\n\" ) ;\n"
                ],
                [
                    11,
                    " return - 1 ;\n"
                ],
                [
                    13,
                    " if ( frame [ 5 ] != '\\n' ) {\n"
                ],
                [
                    20,
                    " if ( j == 79 ) {\n"
                ],
                [
                    21,
                    " fprintf ( stderr , \"Error parsing Y4M frame header\\n\" ) ;\n"
                ],
                [
                    25,
                    " if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) {\n"
                ],
                [
                    26,
                    " fprintf ( stderr , \"Error reading Y4M frame data.\\n\" ) ;\n"
                ],
                [
                    29,
                    " if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {\n"
                ],
                [
                    30,
                    " fprintf ( stderr , \"Error reading Y4M frame data.\\n\" ) ;\n"
                ],
                [
                    34,
                    " memset ( _img , 0 , sizeof ( * _img ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) {\n vpx_codec_err_t res = VPX_CODEC_OK ;\n VP9_COMP * const cpi = ctx -> cpi ;\n const vpx_rational_t * const timebase = & ctx -> cfg . g_timebase ;\n if ( img != NULL ) {\n res = validate_img ( ctx , img ) ;\n if ( res == VPX_CODEC_OK && cpi != NULL && ctx -> cx_data == NULL ) {\n ctx -> cx_data_sz = ctx -> cfg . g_w * ctx -> cfg . g_h * get_image_bps ( img ) / 8 * ( cpi -> multi_arf_allowed ? 8 : 2 ) ;\n if ( ctx -> cx_data_sz < 4096 ) ctx -> cx_data_sz = 4096 ;\n ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ;\n if ( ctx -> cx_data == NULL ) {\n return VPX_CODEC_MEM_ERROR ;\n }\n }\n }\n pick_quickcompress_mode ( ctx , duration , deadline ) ;\n vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ;\n if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) {\n ctx -> base . err_detail = \"Conflicting flags.\" ;\n return VPX_CODEC_INVALID_PARAM ;\n }\n vp9_apply_encoding_flags ( cpi , flags ) ;\n if ( ctx -> cfg . kf_mode == VPX_KF_AUTO && ctx -> cfg . kf_min_dist == ctx -> cfg . kf_max_dist ) {\n if ( ++ ctx -> fixed_kf_cntr > ctx -> cfg . kf_min_dist ) {\n flags |= VPX_EFLAG_FORCE_KF ;\n ctx -> fixed_kf_cntr = 1 ;\n }\n }\n if ( res == VPX_CODEC_OK && cpi != NULL ) {\n unsigned int lib_flags = 0 ;\n YV12_BUFFER_CONFIG sd ;\n int64_t dst_time_stamp = timebase_units_to_ticks ( timebase , pts ) ;\n int64_t dst_end_time_stamp = timebase_units_to_ticks ( timebase , pts + duration ) ;\n size_t size , cx_data_sz ;\n unsigned char * cx_data ;\n if ( ctx -> base . init_flags & VPX_CODEC_USE_PSNR ) cpi -> b_calculate_psnr = 1 ;\n if ( img != NULL ) {\n res = image2yuvconfig ( img , & sd ) ;\n if ( vp9_receive_raw_frame ( cpi , flags , & sd , dst_time_stamp , dst_end_time_stamp ) ) {\n res = update_error_state ( ctx , & cpi -> common . error ) ;\n }\n }\n cx_data = ctx -> cx_data ;\n cx_data_sz = ctx -> cx_data_sz ;\n if ( ctx -> pending_cx_data ) {\n memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ;\n ctx -> pending_cx_data = cx_data ;\n cx_data += ctx -> pending_cx_data_sz ;\n cx_data_sz -= ctx -> pending_cx_data_sz ;\n if ( cx_data_sz < ctx -> cx_data_sz / 2 ) {\n ctx -> base . err_detail = \"Compressed data buffer too small\" ;\n return VPX_CODEC_ERROR ;\n }\n }\n while ( cx_data_sz >= ctx -> cx_data_sz / 2 && - 1 != vp9_get_compressed_data ( cpi , & lib_flags , & size , cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {\n if ( size ) {\n vpx_codec_cx_pkt_t pkt ;\n # if CONFIG_SPATIAL_SVC if ( is_two_pass_svc ( cpi ) ) cpi -> svc . layer_context [ cpi -> svc . spatial_layer_id ] . layer_size += size ;\n # endif if ( ! cpi -> common . show_frame # if CONFIG_SPATIAL_SVC || ( is_two_pass_svc ( cpi ) && cpi -> svc . spatial_layer_id < cpi -> svc . number_spatial_layers - 1 ) # endif ) {\n if ( ctx -> pending_cx_data == 0 ) ctx -> pending_cx_data = cx_data ;\n ctx -> pending_cx_data_sz += size ;\n ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ;\n ctx -> pending_frame_magnitude |= size ;\n cx_data += size ;\n cx_data_sz -= size ;\n continue ;\n }\n pkt . kind = VPX_CODEC_CX_FRAME_PKT ;\n pkt . data . frame . pts = ticks_to_timebase_units ( timebase , dst_time_stamp ) ;\n pkt . data . frame . duration = ( unsigned long ) ticks_to_timebase_units ( timebase , dst_end_time_stamp - dst_time_stamp ) ;\n pkt . data . frame . flags = get_frame_pkt_flags ( cpi , lib_flags ) ;\n if ( ctx -> pending_cx_data ) {\n ctx -> pending_frame_sizes [ ctx -> pending_frame_count ++ ] = size ;\n ctx -> pending_frame_magnitude |= size ;\n ctx -> pending_cx_data_sz += size ;\n size += write_superframe_index ( ctx ) ;\n pkt . data . frame . buf = ctx -> pending_cx_data ;\n pkt . data . frame . sz = ctx -> pending_cx_data_sz ;\n ctx -> pending_cx_data = NULL ;\n ctx -> pending_cx_data_sz = 0 ;\n ctx -> pending_frame_count = 0 ;\n ctx -> pending_frame_magnitude = 0 ;\n }\n else {\n pkt . data . frame . buf = cx_data ;\n pkt . data . frame . sz = size ;\n }\n pkt . data . frame . partition_id = - 1 ;\n vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;\n cx_data += size ;\n cx_data_sz -= size ;\n # if CONFIG_SPATIAL_SVC if ( is_two_pass_svc ( cpi ) ) {\n vpx_codec_cx_pkt_t pkt ;\n int i ;\n vp9_zero ( pkt ) ;\n pkt . kind = VPX_CODEC_SPATIAL_SVC_LAYER_SIZES ;\n for ( i = 0 ;\n i < cpi -> svc . number_spatial_layers ;\n ++ i ) {\n pkt . data . layer_sizes [ i ] = cpi -> svc . layer_context [ i ] . layer_size ;\n cpi -> svc . layer_context [ i ] . layer_size = 0 ;\n }\n vpx_codec_pkt_list_add ( & ctx -> pkt_list . head , & pkt ) ;\n }\n # endif }\n }\n }\n return res ;\n }",
        "hash": -2723830976796502611,
        "project": "chrome",
        "size": 109,
        "slice": {
            "memmove": [
                [
                    1,
                    "static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) {\n"
                ],
                [
                    16,
                    " pick_quickcompress_mode ( ctx , duration , deadline ) ;\n"
                ],
                [
                    40,
                    " res = update_error_state ( ctx , & cpi -> common . error ) ;\n"
                ],
                [
                    43,
                    " cx_data = ctx -> cx_data ;\n"
                ],
                [
                    45,
                    " if ( ctx -> pending_cx_data ) {\n"
                ],
                [
                    46,
                    " memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ;\n"
                ],
                [
                    47,
                    " ctx -> pending_cx_data = cx_data ;\n"
                ],
                [
                    48,
                    " cx_data += ctx -> pending_cx_data_sz ;\n"
                ],
                [
                    49,
                    " cx_data_sz -= ctx -> pending_cx_data_sz ;\n"
                ],
                [
                    61,
                    " ctx -> pending_cx_data_sz += size ;\n"
                ],
                [
                    75,
                    " ctx -> pending_cx_data_sz += size ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) {\n"
                ],
                [
                    6,
                    " res = validate_img ( ctx , img ) ;\n"
                ],
                [
                    7,
                    " if ( res == VPX_CODEC_OK && cpi != NULL && ctx -> cx_data == NULL ) {\n"
                ],
                [
                    9,
                    " if ( ctx -> cx_data_sz < 4096 ) ctx -> cx_data_sz = 4096 ;\n"
                ],
                [
                    10,
                    " ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ;\n"
                ],
                [
                    11,
                    " if ( ctx -> cx_data == NULL ) {\n"
                ],
                [
                    16,
                    " pick_quickcompress_mode ( ctx , duration , deadline ) ;\n"
                ],
                [
                    40,
                    " res = update_error_state ( ctx , & cpi -> common . error ) ;\n"
                ],
                [
                    44,
                    " cx_data_sz = ctx -> cx_data_sz ;\n"
                ],
                [
                    50,
                    " if ( cx_data_sz < ctx -> cx_data_sz / 2 ) {\n"
                ],
                [
                    55,
                    " while ( cx_data_sz >= ctx -> cx_data_sz / 2 && - 1 != vp9_get_compressed_data ( cpi , & lib_flags , & size , cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) {\n"
                ],
                [
                    6,
                    " res = validate_img ( ctx , img ) ;\n"
                ],
                [
                    7,
                    " if ( res == VPX_CODEC_OK && cpi != NULL && ctx -> cx_data == NULL ) {\n"
                ],
                [
                    9,
                    " if ( ctx -> cx_data_sz < 4096 ) ctx -> cx_data_sz = 4096 ;\n"
                ],
                [
                    10,
                    " ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ;\n"
                ],
                [
                    11,
                    " if ( ctx -> cx_data == NULL ) {\n"
                ],
                [
                    16,
                    " pick_quickcompress_mode ( ctx , duration , deadline ) ;\n"
                ],
                [
                    40,
                    " res = update_error_state ( ctx , & cpi -> common . error ) ;\n"
                ],
                [
                    43,
                    " cx_data = ctx -> cx_data ;\n"
                ],
                [
                    44,
                    " cx_data_sz = ctx -> cx_data_sz ;\n"
                ],
                [
                    45,
                    " if ( ctx -> pending_cx_data ) {\n"
                ],
                [
                    46,
                    " memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ;\n"
                ],
                [
                    47,
                    " ctx -> pending_cx_data = cx_data ;\n"
                ],
                [
                    48,
                    " cx_data += ctx -> pending_cx_data_sz ;\n"
                ],
                [
                    49,
                    " cx_data_sz -= ctx -> pending_cx_data_sz ;\n"
                ],
                [
                    50,
                    " if ( cx_data_sz < ctx -> cx_data_sz / 2 ) {\n"
                ],
                [
                    55,
                    " while ( cx_data_sz >= ctx -> cx_data_sz / 2 && - 1 != vp9_get_compressed_data ( cpi , & lib_flags , & size , cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {\n"
                ],
                [
                    61,
                    " ctx -> pending_cx_data_sz += size ;\n"
                ],
                [
                    75,
                    " ctx -> pending_cx_data_sz += size ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * * argv ) {\n VpxVideoWriter * outfile [ VPX_TS_MAX_LAYERS ] = {\n NULL }\n ;\n vpx_codec_ctx_t codec ;\n vpx_codec_enc_cfg_t cfg ;\n int frame_cnt = 0 ;\n vpx_image_t raw ;\n vpx_codec_err_t res ;\n unsigned int width ;\n unsigned int height ;\n int speed ;\n int frame_avail ;\n int got_data ;\n int flags = 0 ;\n unsigned int i ;\n int pts = 0 ;\n int frame_duration = 1 ;\n int layering_mode = 0 ;\n int layer_flags [ VPX_TS_MAX_PERIODICITY ] = {\n 0 }\n ;\n int flag_periodicity = 1 ;\n vpx_svc_layer_id_t layer_id = {\n 0 , 0 }\n ;\n const VpxInterface * encoder = NULL ;\n FILE * infile = NULL ;\n struct RateControlMetrics rc ;\n int64_t cx_time = 0 ;\n exec_name = argv [ 0 ] ;\n if ( argc < 11 ) {\n die ( \"Usage: %s <infile> <outfile> <codec_type(vp8/vp9)> <width> <height> \" \"<rate_num> <rate_den> <speed> <frame_drop_threshold> <mode> \" \"<Rate_0> ... <Rate_nlayers-1> \\n\" , argv [ 0 ] ) ;\n }\n encoder = get_vpx_encoder_by_name ( argv [ 3 ] ) ;\n if ( ! encoder ) die ( \"Unsupported codec.\" ) ;\n printf ( \"Using %s\\n\" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n width = strtol ( argv [ 4 ] , NULL , 0 ) ;\n height = strtol ( argv [ 5 ] , NULL , 0 ) ;\n if ( width < 16 || width % 2 || height < 16 || height % 2 ) {\n die ( \"Invalid resolution: %d x %d\" , width , height ) ;\n }\n layering_mode = strtol ( argv [ 10 ] , NULL , 0 ) ;\n if ( layering_mode < 0 || layering_mode > 12 ) {\n die ( \"Invalid layering mode (0..12) %s\" , argv [ 10 ] ) ;\n }\n if ( argc != 11 + mode_to_num_layers [ layering_mode ] ) {\n die ( \"Invalid number of arguments\" ) ;\n }\n if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , width , height , 32 ) ) {\n die ( \"Failed to allocate image\" , width , height ) ;\n }\n res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ;\n if ( res ) {\n printf ( \"Failed to get config: %s\\n\" , vpx_codec_err_to_string ( res ) ) ;\n return EXIT_FAILURE ;\n }\n cfg . g_w = width ;\n cfg . g_h = height ;\n cfg . g_timebase . num = strtol ( argv [ 6 ] , NULL , 0 ) ;\n cfg . g_timebase . den = strtol ( argv [ 7 ] , NULL , 0 ) ;\n speed = strtol ( argv [ 8 ] , NULL , 0 ) ;\n if ( speed < 0 ) {\n die ( \"Invalid speed setting: must be positive\" ) ;\n }\n for ( i = 11 ;\n ( int ) i < 11 + mode_to_num_layers [ layering_mode ] ;\n ++ i ) {\n cfg . ts_target_bitrate [ i - 11 ] = strtol ( argv [ i ] , NULL , 0 ) ;\n }\n cfg . rc_dropframe_thresh = strtol ( argv [ 9 ] , NULL , 0 ) ;\n cfg . rc_end_usage = VPX_CBR ;\n cfg . rc_resize_allowed = 0 ;\n cfg . rc_min_quantizer = 2 ;\n cfg . rc_max_quantizer = 56 ;\n cfg . rc_undershoot_pct = 50 ;\n cfg . rc_overshoot_pct = 50 ;\n cfg . rc_buf_initial_sz = 500 ;\n cfg . rc_buf_optimal_sz = 600 ;\n cfg . rc_buf_sz = 1000 ;\n cfg . g_error_resilient = 1 ;\n cfg . g_lag_in_frames = 0 ;\n cfg . kf_mode = VPX_KF_AUTO ;\n cfg . kf_min_dist = cfg . kf_max_dist = 3000 ;\n set_temporal_layer_pattern ( layering_mode , & cfg , layer_flags , & flag_periodicity ) ;\n set_rate_control_metrics ( & rc , & cfg ) ;\n cfg . rc_target_bitrate = cfg . ts_target_bitrate [ cfg . ts_number_layers - 1 ] ;\n if ( ! ( infile = fopen ( argv [ 1 ] , \"rb\" ) ) ) {\n die ( \"Failed to open %s for reading\" , argv [ 1 ] ) ;\n }\n for ( i = 0 ;\n i < cfg . ts_number_layers ;\n ++ i ) {\n char file_name [ PATH_MAX ] ;\n VpxVideoInfo info ;\n info . codec_fourcc = encoder -> fourcc ;\n info . frame_width = cfg . g_w ;\n info . frame_height = cfg . g_h ;\n info . time_base . numerator = cfg . g_timebase . num ;\n info . time_base . denominator = cfg . g_timebase . den ;\n snprintf ( file_name , sizeof ( file_name ) , \"%s_%d.ivf\" , argv [ 2 ] , i ) ;\n outfile [ i ] = vpx_video_writer_open ( file_name , kContainerIVF , & info ) ;\n if ( ! outfile [ i ] ) die ( \"Failed to open %s for writing\" , file_name ) ;\n assert ( outfile [ i ] != NULL ) ;\n }\n cfg . ss_number_layers = 1 ;\n if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , & cfg , 0 ) ) die_codec ( & codec , \"Failed to initialize encoder\" ) ;\n if ( strncmp ( encoder -> name , \"vp8\" , 3 ) == 0 ) {\n vpx_codec_control ( & codec , VP8E_SET_CPUUSED , - speed ) ;\n vpx_codec_control ( & codec , VP8E_SET_NOISE_SENSITIVITY , kDenoiserOnYOnly ) ;\n }\n else if ( strncmp ( encoder -> name , \"vp9\" , 3 ) == 0 ) {\n vpx_codec_control ( & codec , VP8E_SET_CPUUSED , speed ) ;\n vpx_codec_control ( & codec , VP9E_SET_AQ_MODE , 3 ) ;\n vpx_codec_control ( & codec , VP9E_SET_FRAME_PERIODIC_BOOST , 0 ) ;\n vpx_codec_control ( & codec , VP8E_SET_NOISE_SENSITIVITY , 0 ) ;\n if ( vpx_codec_control ( & codec , VP9E_SET_SVC , 1 ) ) {\n die_codec ( & codec , \"Failed to set SVC\" ) ;\n }\n }\n vpx_codec_control ( & codec , VP8E_SET_STATIC_THRESHOLD , 1 ) ;\n vpx_codec_control ( & codec , VP8E_SET_TOKEN_PARTITIONS , 1 ) ;\n {\n const int max_intra_size_pct = 200 ;\n vpx_codec_control ( & codec , VP8E_SET_MAX_INTRA_BITRATE_PCT , max_intra_size_pct ) ;\n }\n frame_avail = 1 ;\n while ( frame_avail || got_data ) {\n struct vpx_usec_timer timer ;\n vpx_codec_iter_t iter = NULL ;\n const vpx_codec_cx_pkt_t * pkt ;\n layer_id . spatial_layer_id = 0 ;\n layer_id . temporal_layer_id = cfg . ts_layer_id [ frame_cnt % cfg . ts_periodicity ] ;\n if ( strncmp ( encoder -> name , \"vp9\" , 3 ) == 0 ) {\n vpx_codec_control ( & codec , VP9E_SET_SVC_LAYER_ID , & layer_id ) ;\n }\n flags = layer_flags [ frame_cnt % flag_periodicity ] ;\n frame_avail = vpx_img_read ( & raw , infile ) ;\n if ( frame_avail ) ++ rc . layer_input_frames [ layer_id . temporal_layer_id ] ;\n vpx_usec_timer_start ( & timer ) ;\n if ( vpx_codec_encode ( & codec , frame_avail ? & raw : NULL , pts , 1 , flags , VPX_DL_REALTIME ) ) {\n die_codec ( & codec , \"Failed to encode frame\" ) ;\n }\n vpx_usec_timer_mark ( & timer ) ;\n cx_time += vpx_usec_timer_elapsed ( & timer ) ;\n if ( layering_mode != 7 ) {\n layer_flags [ 0 ] &= ~ VPX_EFLAG_FORCE_KF ;\n }\n got_data = 0 ;\n while ( ( pkt = vpx_codec_get_cx_data ( & codec , & iter ) ) ) {\n got_data = 1 ;\n switch ( pkt -> kind ) {\n case VPX_CODEC_CX_FRAME_PKT : for ( i = cfg . ts_layer_id [ frame_cnt % cfg . ts_periodicity ] ;\n i < cfg . ts_number_layers ;\n ++ i ) {\n vpx_video_writer_write_frame ( outfile [ i ] , pkt -> data . frame . buf , pkt -> data . frame . sz , pts ) ;\n ++ rc . layer_tot_enc_frames [ i ] ;\n rc . layer_encoding_bitrate [ i ] += 8.0 * pkt -> data . frame . sz ;\n if ( i == cfg . ts_layer_id [ frame_cnt % cfg . ts_periodicity ] && ! ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) ) {\n rc . layer_avg_frame_size [ i ] += 8.0 * pkt -> data . frame . sz ;\n rc . layer_avg_rate_mismatch [ i ] += fabs ( 8.0 * pkt -> data . frame . sz - rc . layer_pfb [ i ] ) / rc . layer_pfb [ i ] ;\n ++ rc . layer_enc_frames [ i ] ;\n }\n }\n break ;\n default : break ;\n }\n }\n ++ frame_cnt ;\n pts += frame_duration ;\n }\n fclose ( infile ) ;\n printout_rate_control_summary ( & rc , & cfg , frame_cnt ) ;\n printf ( \"\\n\" ) ;\n printf ( \"Frame cnt and encoding time/FPS stats for encoding: %d %f %f \\n\" , frame_cnt , * ( float ) cx_time / ( double ) ( frame_cnt * 1000000 ) , * ( double ) frame_cnt / ( double ) cx_time ) ;\n if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed to destroy codec\" ) ;\n for ( i = 0 ;\n i < cfg . ts_number_layers ;\n ++ i ) vpx_video_writer_close ( outfile [ i ] ) ;\n vpx_img_free ( & raw ) ;\n return EXIT_SUCCESS ;\n }",
        "hash": -4974091237615489098,
        "project": "chrome",
        "size": 182,
        "slice": {
            "printf": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    37,
                    " printf ( \"Using %s\\n\" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n"
                ],
                [
                    54,
                    " if ( res ) {\n"
                ],
                [
                    55,
                    " printf ( \"Failed to get config: %s\\n\" , vpx_codec_err_to_string ( res ) ) ;\n"
                ],
                [
                    174,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    175,
                    " printf ( \"Frame cnt and encoding time/FPS stats for encoding: %d %f %f \\n\" , frame_cnt , * ( float ) cx_time / ( double ) ( frame_cnt * 1000000 ) , * ( double ) frame_cnt / ( double ) cx_time ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    37,
                    " printf ( \"Using %s\\n\" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n"
                ],
                [
                    54,
                    " if ( res ) {\n"
                ],
                [
                    55,
                    " printf ( \"Failed to get config: %s\\n\" , vpx_codec_err_to_string ( res ) ) ;\n"
                ],
                [
                    174,
                    " printf ( \"\\n\" ) ;\n"
                ],
                [
                    175,
                    " printf ( \"Frame cnt and encoding time/FPS stats for encoding: %d %f %f \\n\" , frame_cnt , * ( float ) cx_time / ( double ) ( frame_cnt * 1000000 ) , * ( double ) frame_cnt / ( double ) cx_time ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n int i ;\n struct ExternalFrameBufferList * const ext_fb_list = ( struct ExternalFrameBufferList * ) cb_priv ;\n if ( ext_fb_list == NULL ) return - 1 ;\n for ( i = 0 ;\n i < ext_fb_list -> num_external_frame_buffers ;\n ++ i ) {\n if ( ! ext_fb_list -> ext_fb [ i ] . in_use ) break ;\n }\n if ( i == ext_fb_list -> num_external_frame_buffers ) return - 1 ;\n if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {\n free ( ext_fb_list -> ext_fb [ i ] . data ) ;\n ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ;\n if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;\n ext_fb_list -> ext_fb [ i ] . size = min_size ;\n }\n fb -> data = ext_fb_list -> ext_fb [ i ] . data ;\n fb -> size = ext_fb_list -> ext_fb [ i ] . size ;\n ext_fb_list -> ext_fb [ i ] . in_use = 1 ;\n fb -> priv = & ext_fb_list -> ext_fb [ i ] ;\n return 0 ;\n }",
        "hash": -2338718868165006846,
        "project": "chrome",
        "size": 22,
        "slice": {
            "malloc": [
                [
                    1,
                    "int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n"
                ],
                [
                    11,
                    " if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {\n"
                ],
                [
                    13,
                    " ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ;\n"
                ],
                [
                    15,
                    " ext_fb_list -> ext_fb [ i ] . size = min_size ;\n"
                ]
            ],
            "free": [
                [
                    11,
                    " if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {\n"
                ],
                [
                    12,
                    " free ( ext_fb_list -> ext_fb [ i ] . data ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n"
                ],
                [
                    11,
                    " if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {\n"
                ],
                [
                    12,
                    " free ( ext_fb_list -> ext_fb [ i ] . data ) ;\n"
                ],
                [
                    13,
                    " ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ;\n"
                ],
                [
                    15,
                    " ext_fb_list -> ext_fb [ i ] . size = min_size ;\n"
                ]
            ]
        }
    },
    {
        "code": "static vpx_codec_err_t parse_quantizer_values ( SvcContext * svc_ctx , const char * quantizer_values ) {\n char * input_string ;\n char * token ;\n const char * delim = \",\" ;\n char * save_ptr ;\n int found = 0 ;\n int i , q ;\n vpx_codec_err_t res = VPX_CODEC_OK ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( quantizer_values == NULL || strlen ( quantizer_values ) == 0 ) {\n input_string = strdup ( DEFAULT_QUANTIZER_VALUES ) ;\n }\n else {\n input_string = strdup ( quantizer_values ) ;\n }\n token = strtok_r ( input_string , delim , & save_ptr ) ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n if ( token != NULL ) {\n q = atoi ( token ) ;\n if ( q <= 0 || q > 100 ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc-quantizer-values: invalid value %s\\n\" , token ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n token = strtok_r ( NULL , delim , & save_ptr ) ;\n found = i + 1 ;\n }\n else {\n q = 0 ;\n }\n si -> quantizer [ i + VPX_SS_MAX_LAYERS - svc_ctx -> spatial_layers ] = q ;\n }\n if ( res == VPX_CODEC_OK && found != svc_ctx -> spatial_layers ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: quantizers: %d values required, but only %d specified\\n\" , svc_ctx -> spatial_layers , found ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n }\n free ( input_string ) ;\n return res ;\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 41,
        "slice": {
            "strlen": [
                [
                    1,
                    "static vpx_codec_err_t parse_quantizer_values ( SvcContext * svc_ctx , const char * quantizer_values ) {\n"
                ],
                [
                    10,
                    " if ( quantizer_values == NULL || strlen ( quantizer_values ) == 0 ) {\n"
                ],
                [
                    11,
                    " input_string = strdup ( DEFAULT_QUANTIZER_VALUES ) ;\n"
                ],
                [
                    14,
                    " input_string = strdup ( quantizer_values ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static vpx_codec_err_t parse_quantizer_values ( SvcContext * svc_ctx , const char * quantizer_values ) {\n"
                ],
                [
                    16,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ],
                [
                    39,
                    " free ( input_string ) ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static vpx_codec_err_t parse_quantizer_values ( SvcContext * svc_ctx , const char * quantizer_values ) {\n"
                ],
                [
                    10,
                    " if ( quantizer_values == NULL || strlen ( quantizer_values ) == 0 ) {\n"
                ],
                [
                    11,
                    " input_string = strdup ( DEFAULT_QUANTIZER_VALUES ) ;\n"
                ],
                [
                    14,
                    " input_string = strdup ( quantizer_values ) ;\n"
                ],
                [
                    16,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static vpx_codec_err_t parse_quantizer_values ( SvcContext * svc_ctx , const char * quantizer_values ) {\n"
                ],
                [
                    10,
                    " if ( quantizer_values == NULL || strlen ( quantizer_values ) == 0 ) {\n"
                ],
                [
                    11,
                    " input_string = strdup ( DEFAULT_QUANTIZER_VALUES ) ;\n"
                ],
                [
                    14,
                    " input_string = strdup ( quantizer_values ) ;\n"
                ],
                [
                    16,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ],
                [
                    39,
                    " free ( input_string ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static vpx_codec_err_t parse_auto_alt_ref ( SvcContext * svc_ctx , const char * alt_ref_options ) {\n char * input_string ;\n char * token ;\n const char * delim = \",\" ;\n char * save_ptr ;\n int found = 0 , enabled = 0 ;\n int i , value ;\n vpx_codec_err_t res = VPX_CODEC_OK ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( alt_ref_options == NULL || strlen ( alt_ref_options ) == 0 ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n else {\n input_string = strdup ( alt_ref_options ) ;\n }\n token = strtok_r ( input_string , delim , & save_ptr ) ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n if ( token != NULL ) {\n value = atoi ( token ) ;\n if ( value < 0 || value > 1 ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"enable auto alt ref values: invalid value %s\\n\" , token ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n token = strtok_r ( NULL , delim , & save_ptr ) ;\n found = i + 1 ;\n }\n else {\n value = 0 ;\n }\n si -> enable_auto_alt_ref [ i ] = value ;\n if ( value > 0 ) ++ enabled ;\n }\n if ( res == VPX_CODEC_OK && found != svc_ctx -> spatial_layers ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: quantizers: %d values required, but only %d specified\\n\" , svc_ctx -> spatial_layers , found ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n }\n if ( enabled > REF_FRAMES - svc_ctx -> spatial_layers ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: auto alt ref: Maxinum %d(REF_FRAMES - layers) layers could\" \"enabled auto alt reference frame, but % layers are enabled\\n\" , REF_FRAMES - svc_ctx -> spatial_layers , enabled ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n }\n free ( input_string ) ;\n return res ;\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 46,
        "slice": {
            "strlen": [
                [
                    1,
                    "static vpx_codec_err_t parse_auto_alt_ref ( SvcContext * svc_ctx , const char * alt_ref_options ) {\n"
                ],
                [
                    10,
                    " if ( alt_ref_options == NULL || strlen ( alt_ref_options ) == 0 ) {\n"
                ],
                [
                    11,
                    " return VPX_CODEC_INVALID_PARAM ;\n"
                ],
                [
                    14,
                    " input_string = strdup ( alt_ref_options ) ;\n"
                ],
                [
                    16,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ],
                [
                    17,
                    " for ( i = 0 ;\n"
                ],
                [
                    18,
                    " i < svc_ctx -> spatial_layers ;\n"
                ],
                [
                    36,
                    " if ( res == VPX_CODEC_OK && found != svc_ctx -> spatial_layers ) {\n"
                ],
                [
                    40,
                    " if ( enabled > REF_FRAMES - svc_ctx -> spatial_layers ) {\n"
                ],
                [
                    44,
                    " free ( input_string ) ;\n"
                ],
                [
                    45,
                    " return res ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static vpx_codec_err_t parse_auto_alt_ref ( SvcContext * svc_ctx , const char * alt_ref_options ) {\n"
                ],
                [
                    10,
                    " if ( alt_ref_options == NULL || strlen ( alt_ref_options ) == 0 ) {\n"
                ],
                [
                    16,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ],
                [
                    44,
                    " free ( input_string ) ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static vpx_codec_err_t parse_auto_alt_ref ( SvcContext * svc_ctx , const char * alt_ref_options ) {\n"
                ],
                [
                    10,
                    " if ( alt_ref_options == NULL || strlen ( alt_ref_options ) == 0 ) {\n"
                ],
                [
                    14,
                    " input_string = strdup ( alt_ref_options ) ;\n"
                ],
                [
                    16,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static vpx_codec_err_t parse_auto_alt_ref ( SvcContext * svc_ctx , const char * alt_ref_options ) {\n"
                ],
                [
                    10,
                    " if ( alt_ref_options == NULL || strlen ( alt_ref_options ) == 0 ) {\n"
                ],
                [
                    11,
                    " return VPX_CODEC_INVALID_PARAM ;\n"
                ],
                [
                    14,
                    " input_string = strdup ( alt_ref_options ) ;\n"
                ],
                [
                    16,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ],
                [
                    17,
                    " for ( i = 0 ;\n"
                ],
                [
                    18,
                    " i < svc_ctx -> spatial_layers ;\n"
                ],
                [
                    36,
                    " if ( res == VPX_CODEC_OK && found != svc_ctx -> spatial_layers ) {\n"
                ],
                [
                    40,
                    " if ( enabled > REF_FRAMES - svc_ctx -> spatial_layers ) {\n"
                ],
                [
                    44,
                    " free ( input_string ) ;\n"
                ],
                [
                    45,
                    " return res ;\n"
                ]
            ]
        }
    },
    {
        "code": "vpx_codec_err_t vpx_svc_set_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || scale_factors == NULL || si == NULL ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n strncpy ( si -> scale_factors , scale_factors , sizeof ( si -> scale_factors ) ) ;\n si -> scale_factors [ sizeof ( si -> scale_factors ) - 1 ] = '\\0' ;\n return VPX_CODEC_OK ;\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 9,
        "slice": {
            "strncpy": [
                [
                    1,
                    "vpx_codec_err_t vpx_svc_set_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n"
                ],
                [
                    2,
                    " SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n"
                ],
                [
                    3,
                    " if ( svc_ctx == NULL || scale_factors == NULL || si == NULL ) {\n"
                ],
                [
                    6,
                    " strncpy ( si -> scale_factors , scale_factors , sizeof ( si -> scale_factors ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "vpx_codec_err_t vpx_svc_set_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n"
                ],
                [
                    2,
                    " SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n"
                ],
                [
                    3,
                    " if ( svc_ctx == NULL || scale_factors == NULL || si == NULL ) {\n"
                ],
                [
                    6,
                    " strncpy ( si -> scale_factors , scale_factors , sizeof ( si -> scale_factors ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "vpx_codec_err_t vpx_svc_set_quantizers ( SvcContext * svc_ctx , const char * quantizers ) {\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || quantizers == NULL || si == NULL ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n strncpy ( si -> quantizers , quantizers , sizeof ( si -> quantizers ) ) ;\n si -> quantizers [ sizeof ( si -> quantizers ) - 1 ] = '\\0' ;\n return VPX_CODEC_OK ;\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 9,
        "slice": {
            "strncpy": [
                [
                    1,
                    "vpx_codec_err_t vpx_svc_set_quantizers ( SvcContext * svc_ctx , const char * quantizers ) {\n"
                ],
                [
                    2,
                    " SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n"
                ],
                [
                    3,
                    " if ( svc_ctx == NULL || quantizers == NULL || si == NULL ) {\n"
                ],
                [
                    6,
                    " strncpy ( si -> quantizers , quantizers , sizeof ( si -> quantizers ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "vpx_codec_err_t vpx_svc_set_quantizers ( SvcContext * svc_ctx , const char * quantizers ) {\n"
                ],
                [
                    2,
                    " SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n"
                ],
                [
                    3,
                    " if ( svc_ctx == NULL || quantizers == NULL || si == NULL ) {\n"
                ],
                [
                    6,
                    " strncpy ( si -> quantizers , quantizers , sizeof ( si -> quantizers ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void set_svc_parameters ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx ) {\n int layer , layer_index ;\n vpx_svc_parameters_t svc_params ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n memset ( & svc_params , 0 , sizeof ( svc_params ) ) ;\n svc_params . temporal_layer = 0 ;\n svc_params . spatial_layer = si -> layer ;\n layer = si -> layer ;\n if ( VPX_CODEC_OK != vpx_svc_get_layer_resolution ( svc_ctx , layer , & svc_params . width , & svc_params . height ) ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"vpx_svc_get_layer_resolution failed\\n\" ) ;\n }\n layer_index = layer + VPX_SS_MAX_LAYERS - si -> layers ;\n if ( codec_ctx -> config . enc -> g_pass == VPX_RC_ONE_PASS ) {\n svc_params . min_quantizer = si -> quantizer [ layer_index ] ;\n svc_params . max_quantizer = si -> quantizer [ layer_index ] ;\n }\n else {\n svc_params . min_quantizer = codec_ctx -> config . enc -> rc_min_quantizer ;\n svc_params . max_quantizer = codec_ctx -> config . enc -> rc_max_quantizer ;\n }\n svc_params . distance_from_i_frame = si -> frame_within_gop ;\n vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & svc_params ) ;\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 23,
        "slice": {
            "memset": [
                [
                    1,
                    "static void set_svc_parameters ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx ) {\n"
                ],
                [
                    5,
                    " memset ( & svc_params , 0 , sizeof ( svc_params ) ) ;\n"
                ],
                [
                    22,
                    " vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & svc_params ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void set_svc_parameters ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx ) {\n"
                ],
                [
                    5,
                    " memset ( & svc_params , 0 , sizeof ( svc_params ) ) ;\n"
                ],
                [
                    22,
                    " vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & svc_params ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static vpx_codec_err_t parse_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n char * input_string ;\n char * token ;\n const char * delim = \",\" ;\n char * save_ptr ;\n int found = 0 ;\n int i ;\n int64_t num , den ;\n vpx_codec_err_t res = VPX_CODEC_OK ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( scale_factors == NULL || strlen ( scale_factors ) == 0 ) {\n input_string = strdup ( DEFAULT_SCALE_FACTORS ) ;\n }\n else {\n input_string = strdup ( scale_factors ) ;\n }\n token = strtok_r ( input_string , delim , & save_ptr ) ;\n for ( i = 0 ;\n i < svc_ctx -> spatial_layers ;\n ++ i ) {\n num = den = 0 ;\n if ( token != NULL ) {\n num = strtol ( token , & token , 10 ) ;\n if ( num <= 0 ) {\n log_invalid_scale_factor ( svc_ctx , token ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n if ( * token ++ != '/' ) {\n log_invalid_scale_factor ( svc_ctx , token ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n den = strtol ( token , & token , 10 ) ;\n if ( den <= 0 ) {\n log_invalid_scale_factor ( svc_ctx , token ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n token = strtok_r ( NULL , delim , & save_ptr ) ;\n found = i + 1 ;\n }\n si -> scaling_factor_num [ i + VPX_SS_MAX_LAYERS - svc_ctx -> spatial_layers ] = ( int ) num ;\n si -> scaling_factor_den [ i + VPX_SS_MAX_LAYERS - svc_ctx -> spatial_layers ] = ( int ) den ;\n }\n if ( res == VPX_CODEC_OK && found != svc_ctx -> spatial_layers ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc: scale-factors: %d values required, but only %d specified\\n\" , svc_ctx -> spatial_layers , found ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n }\n free ( input_string ) ;\n return res ;\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 52,
        "slice": {
            "strlen": [
                [
                    1,
                    "static vpx_codec_err_t parse_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n"
                ],
                [
                    11,
                    " if ( scale_factors == NULL || strlen ( scale_factors ) == 0 ) {\n"
                ],
                [
                    12,
                    " input_string = strdup ( DEFAULT_SCALE_FACTORS ) ;\n"
                ],
                [
                    15,
                    " input_string = strdup ( scale_factors ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static vpx_codec_err_t parse_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n"
                ],
                [
                    17,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ],
                [
                    50,
                    " free ( input_string ) ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static vpx_codec_err_t parse_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n"
                ],
                [
                    11,
                    " if ( scale_factors == NULL || strlen ( scale_factors ) == 0 ) {\n"
                ],
                [
                    12,
                    " input_string = strdup ( DEFAULT_SCALE_FACTORS ) ;\n"
                ],
                [
                    15,
                    " input_string = strdup ( scale_factors ) ;\n"
                ],
                [
                    17,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static vpx_codec_err_t parse_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n"
                ],
                [
                    11,
                    " if ( scale_factors == NULL || strlen ( scale_factors ) == 0 ) {\n"
                ],
                [
                    12,
                    " input_string = strdup ( DEFAULT_SCALE_FACTORS ) ;\n"
                ],
                [
                    15,
                    " input_string = strdup ( scale_factors ) ;\n"
                ],
                [
                    17,
                    " token = strtok_r ( input_string , delim , & save_ptr ) ;\n"
                ],
                [
                    50,
                    " free ( input_string ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void vpx_svc_release ( SvcContext * svc_ctx ) {\n SvcInternal * si ;\n if ( svc_ctx == NULL ) return ;\n si = ( SvcInternal * ) svc_ctx -> internal ;\n if ( si != NULL ) {\n fd_free ( si -> frame_temp ) ;\n fd_free_list ( si -> frame_list ) ;\n if ( si -> rc_stats_buf ) {\n free ( si -> rc_stats_buf ) ;\n }\n free ( si ) ;\n svc_ctx -> internal = NULL ;\n }\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 14,
        "slice": {
            "free": [
                [
                    1,
                    "void vpx_svc_release ( SvcContext * svc_ctx ) {\n"
                ],
                [
                    5,
                    " if ( si != NULL ) {\n"
                ],
                [
                    6,
                    " fd_free ( si -> frame_temp ) ;\n"
                ],
                [
                    7,
                    " fd_free_list ( si -> frame_list ) ;\n"
                ],
                [
                    8,
                    " if ( si -> rc_stats_buf ) {\n"
                ],
                [
                    9,
                    " free ( si -> rc_stats_buf ) ;\n"
                ],
                [
                    11,
                    " free ( si ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void vpx_svc_release ( SvcContext * svc_ctx ) {\n"
                ],
                [
                    5,
                    " if ( si != NULL ) {\n"
                ],
                [
                    6,
                    " fd_free ( si -> frame_temp ) ;\n"
                ],
                [
                    7,
                    " fd_free_list ( si -> frame_list ) ;\n"
                ],
                [
                    8,
                    " if ( si -> rc_stats_buf ) {\n"
                ],
                [
                    9,
                    " free ( si -> rc_stats_buf ) ;\n"
                ],
                [
                    11,
                    " free ( si ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "vpx_codec_err_t vpx_svc_encode ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , struct vpx_image * rawimg , vpx_codec_pts_t pts , int64_t duration , int deadline ) {\n vpx_codec_err_t res ;\n vpx_codec_iter_t iter ;\n const vpx_codec_cx_pkt_t * cx_pkt ;\n int layer_for_psnr = 0 ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || codec_ctx == NULL || si == NULL ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n svc_log_reset ( svc_ctx ) ;\n si -> rc_stats_buf_used = 0 ;\n si -> layers = svc_ctx -> spatial_layers ;\n if ( si -> encode_frame_count == 0 ) {\n si -> frame_within_gop = 0 ;\n }\n si -> is_keyframe = ( si -> frame_within_gop == 0 ) ;\n if ( rawimg != NULL ) {\n svc_log ( svc_ctx , SVC_LOG_DEBUG , \"vpx_svc_encode layers: %d, frame_count: %d, \" \"frame_within_gop: %d\\n\" , si -> layers , si -> encode_frame_count , si -> frame_within_gop ) ;\n }\n if ( rawimg != NULL ) {\n for ( si -> layer = 0 ;\n si -> layer < si -> layers ;\n ++ si -> layer ) {\n set_svc_parameters ( svc_ctx , codec_ctx ) ;\n }\n }\n res = vpx_codec_encode ( codec_ctx , rawimg , pts , ( uint32_t ) duration , 0 , deadline ) ;\n if ( res != VPX_CODEC_OK ) {\n return res ;\n }\n iter = NULL ;\n while ( ( cx_pkt = vpx_codec_get_cx_data ( codec_ctx , & iter ) ) ) {\n switch ( cx_pkt -> kind ) {\n case VPX_CODEC_CX_FRAME_PKT : {\n fd_list_add ( & si -> frame_list , fd_create ( cx_pkt -> data . frame . buf , cx_pkt -> data . frame . sz , cx_pkt -> data . frame . flags ) ) ;\n svc_log ( svc_ctx , SVC_LOG_DEBUG , \"SVC frame: %d, kf: %d, size: %d, \" \"pts: %d\\n\" , si -> frame_received , ( cx_pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) ? 1 : 0 , ( int ) cx_pkt -> data . frame . sz , ( int ) cx_pkt -> data . frame . pts ) ;\n ++ si -> frame_received ;\n layer_for_psnr = 0 ;\n break ;\n }\n case VPX_CODEC_PSNR_PKT : {\n int i ;\n svc_log ( svc_ctx , SVC_LOG_DEBUG , \"SVC frame: %d, layer: %d, PSNR(Total/Y/U/V): \" \"%2.3f %2.3f %2.3f %2.3f \\n\" , si -> frame_received , layer_for_psnr , cx_pkt -> data . psnr . psnr [ 0 ] , cx_pkt -> data . psnr . psnr [ 1 ] , cx_pkt -> data . psnr . psnr [ 2 ] , cx_pkt -> data . psnr . psnr [ 3 ] ) ;\n svc_log ( svc_ctx , SVC_LOG_DEBUG , \"SVC frame: %d, layer: %d, SSE(Total/Y/U/V): \" \"%2.3f %2.3f %2.3f %2.3f \\n\" , si -> frame_received , layer_for_psnr , cx_pkt -> data . psnr . sse [ 0 ] , cx_pkt -> data . psnr . sse [ 1 ] , cx_pkt -> data . psnr . sse [ 2 ] , cx_pkt -> data . psnr . sse [ 3 ] ) ;\n for ( i = 0 ;\n i < COMPONENTS ;\n i ++ ) {\n si -> psnr_sum [ layer_for_psnr ] [ i ] += cx_pkt -> data . psnr . psnr [ i ] ;\n si -> sse_sum [ layer_for_psnr ] [ i ] += cx_pkt -> data . psnr . sse [ i ] ;\n }\n ++ layer_for_psnr ;\n break ;\n }\n case VPX_CODEC_STATS_PKT : {\n size_t new_size = si -> rc_stats_buf_used + cx_pkt -> data . twopass_stats . sz ;\n if ( new_size > si -> rc_stats_buf_size ) {\n char * p = ( char * ) realloc ( si -> rc_stats_buf , new_size ) ;\n if ( p == NULL ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"Error allocating stats buf\\n\" ) ;\n return VPX_CODEC_MEM_ERROR ;\n }\n si -> rc_stats_buf = p ;\n si -> rc_stats_buf_size = new_size ;\n }\n memcpy ( si -> rc_stats_buf + si -> rc_stats_buf_used , cx_pkt -> data . twopass_stats . buf , cx_pkt -> data . twopass_stats . sz ) ;\n si -> rc_stats_buf_used += cx_pkt -> data . twopass_stats . sz ;\n break ;\n }\n # if CONFIG_SPATIAL_SVC case VPX_CODEC_SPATIAL_SVC_LAYER_SIZES : {\n int i ;\n for ( i = 0 ;\n i < si -> layers ;\n ++ i ) si -> bytes_sum [ i ] += cx_pkt -> data . layer_sizes [ i ] ;\n break ;\n }\n # endif default : {\n break ;\n }\n }\n }\n if ( rawimg != NULL ) {\n ++ si -> frame_within_gop ;\n ++ si -> encode_frame_count ;\n }\n return VPX_CODEC_OK ;\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 86,
        "slice": {
            "memcpy": [
                [
                    6,
                    " SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n"
                ],
                [
                    7,
                    " if ( svc_ctx == NULL || codec_ctx == NULL || si == NULL ) {\n"
                ],
                [
                    11,
                    " si -> rc_stats_buf_used = 0 ;\n"
                ],
                [
                    56,
                    " if ( new_size > si -> rc_stats_buf_size ) {\n"
                ],
                [
                    58,
                    " if ( p == NULL ) {\n"
                ],
                [
                    62,
                    " si -> rc_stats_buf = p ;\n"
                ],
                [
                    65,
                    " memcpy ( si -> rc_stats_buf + si -> rc_stats_buf_used , cx_pkt -> data . twopass_stats . buf , cx_pkt -> data . twopass_stats . sz ) ;\n"
                ],
                [
                    66,
                    " si -> rc_stats_buf_used += cx_pkt -> data . twopass_stats . sz ;\n"
                ]
            ],
            "realloc": [
                [
                    1,
                    "vpx_codec_err_t vpx_svc_encode ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , struct vpx_image * rawimg , vpx_codec_pts_t pts , int64_t duration , int deadline ) {\n"
                ],
                [
                    6,
                    " SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n"
                ],
                [
                    7,
                    " if ( svc_ctx == NULL || codec_ctx == NULL || si == NULL ) {\n"
                ],
                [
                    56,
                    " if ( new_size > si -> rc_stats_buf_size ) {\n"
                ],
                [
                    57,
                    " char * p = ( char * ) realloc ( si -> rc_stats_buf , new_size ) ;\n"
                ],
                [
                    58,
                    " if ( p == NULL ) {\n"
                ],
                [
                    62,
                    " si -> rc_stats_buf = p ;\n"
                ],
                [
                    63,
                    " si -> rc_stats_buf_size = new_size ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "vpx_codec_err_t vpx_svc_encode ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , struct vpx_image * rawimg , vpx_codec_pts_t pts , int64_t duration , int deadline ) {\n"
                ],
                [
                    6,
                    " SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n"
                ],
                [
                    7,
                    " if ( svc_ctx == NULL || codec_ctx == NULL || si == NULL ) {\n"
                ],
                [
                    11,
                    " si -> rc_stats_buf_used = 0 ;\n"
                ],
                [
                    56,
                    " if ( new_size > si -> rc_stats_buf_size ) {\n"
                ],
                [
                    57,
                    " char * p = ( char * ) realloc ( si -> rc_stats_buf , new_size ) ;\n"
                ],
                [
                    58,
                    " if ( p == NULL ) {\n"
                ],
                [
                    62,
                    " si -> rc_stats_buf = p ;\n"
                ],
                [
                    63,
                    " si -> rc_stats_buf_size = new_size ;\n"
                ],
                [
                    65,
                    " memcpy ( si -> rc_stats_buf + si -> rc_stats_buf_used , cx_pkt -> data . twopass_stats . buf , cx_pkt -> data . twopass_stats . sz ) ;\n"
                ],
                [
                    66,
                    " si -> rc_stats_buf_used += cx_pkt -> data . twopass_stats . sz ;\n"
                ]
            ]
        }
    },
    {
        "code": "static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) {\n char * input_string ;\n char * option_name ;\n char * option_value ;\n char * input_ptr ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n vpx_codec_err_t res = VPX_CODEC_OK ;\n if ( options == NULL ) return VPX_CODEC_OK ;\n input_string = strdup ( options ) ;\n option_name = strtok_r ( input_string , \"=\" , & input_ptr ) ;\n while ( option_name != NULL ) {\n option_value = strtok_r ( NULL , \" \" , & input_ptr ) ;\n if ( option_value == NULL ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"option missing value: %s\\n\" , option_name ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n if ( strcmp ( \"spatial-layers\" , option_name ) == 0 ) {\n svc_ctx -> spatial_layers = atoi ( option_value ) ;\n }\n else if ( strcmp ( \"temporal-layers\" , option_name ) == 0 ) {\n svc_ctx -> temporal_layers = atoi ( option_value ) ;\n }\n else if ( strcmp ( \"scale-factors\" , option_name ) == 0 ) {\n res = parse_scale_factors ( svc_ctx , option_value ) ;\n if ( res != VPX_CODEC_OK ) break ;\n }\n else if ( strcmp ( \"quantizers\" , option_name ) == 0 ) {\n res = parse_quantizer_values ( svc_ctx , option_value ) ;\n if ( res != VPX_CODEC_OK ) break ;\n }\n else if ( strcmp ( \"auto-alt-refs\" , option_name ) == 0 ) {\n res = parse_auto_alt_ref ( svc_ctx , option_value ) ;\n if ( res != VPX_CODEC_OK ) break ;\n }\n else if ( strcmp ( \"multi-frame-contexts\" , option_name ) == 0 ) {\n si -> use_multiple_frame_contexts = atoi ( option_value ) ;\n }\n else {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"invalid option: %s\\n\" , option_name ) ;\n res = VPX_CODEC_INVALID_PARAM ;\n break ;\n }\n option_name = strtok_r ( NULL , \"=\" , & input_ptr ) ;\n }\n free ( input_string ) ;\n if ( si -> use_multiple_frame_contexts && ( svc_ctx -> spatial_layers > 3 || svc_ctx -> spatial_layers * svc_ctx -> temporal_layers > 4 ) ) res = VPX_CODEC_INVALID_PARAM ;\n return res ;\n }",
        "hash": 5400542917484463750,
        "project": "chrome",
        "size": 49,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) {\n"
                ],
                [
                    11,
                    " while ( option_name != NULL ) {\n"
                ],
                [
                    13,
                    " if ( option_value == NULL ) {\n"
                ],
                [
                    18,
                    " if ( strcmp ( \"spatial-layers\" , option_name ) == 0 ) {\n"
                ],
                [
                    19,
                    " svc_ctx -> spatial_layers = atoi ( option_value ) ;\n"
                ],
                [
                    21,
                    " else if ( strcmp ( \"temporal-layers\" , option_name ) == 0 ) {\n"
                ],
                [
                    22,
                    " svc_ctx -> temporal_layers = atoi ( option_value ) ;\n"
                ],
                [
                    24,
                    " else if ( strcmp ( \"scale-factors\" , option_name ) == 0 ) {\n"
                ],
                [
                    25,
                    " res = parse_scale_factors ( svc_ctx , option_value ) ;\n"
                ],
                [
                    26,
                    " if ( res != VPX_CODEC_OK ) break ;\n"
                ],
                [
                    28,
                    " else if ( strcmp ( \"quantizers\" , option_name ) == 0 ) {\n"
                ],
                [
                    29,
                    " res = parse_quantizer_values ( svc_ctx , option_value ) ;\n"
                ],
                [
                    30,
                    " if ( res != VPX_CODEC_OK ) break ;\n"
                ],
                [
                    32,
                    " else if ( strcmp ( \"auto-alt-refs\" , option_name ) == 0 ) {\n"
                ],
                [
                    33,
                    " res = parse_auto_alt_ref ( svc_ctx , option_value ) ;\n"
                ],
                [
                    34,
                    " if ( res != VPX_CODEC_OK ) break ;\n"
                ],
                [
                    36,
                    " else if ( strcmp ( \"multi-frame-contexts\" , option_name ) == 0 ) {\n"
                ],
                [
                    37,
                    " si -> use_multiple_frame_contexts = atoi ( option_value ) ;\n"
                ],
                [
                    40,
                    " svc_log ( svc_ctx , SVC_LOG_ERROR , \"invalid option: %s\\n\" , option_name ) ;\n"
                ],
                [
                    41,
                    " res = VPX_CODEC_INVALID_PARAM ;\n"
                ],
                [
                    44,
                    " option_name = strtok_r ( NULL , \"=\" , & input_ptr ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) {\n"
                ],
                [
                    8,
                    " if ( options == NULL ) return VPX_CODEC_OK ;\n"
                ],
                [
                    10,
                    " option_name = strtok_r ( input_string , \"=\" , & input_ptr ) ;\n"
                ],
                [
                    46,
                    " free ( input_string ) ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) {\n"
                ],
                [
                    8,
                    " if ( options == NULL ) return VPX_CODEC_OK ;\n"
                ],
                [
                    9,
                    " input_string = strdup ( options ) ;\n"
                ],
                [
                    10,
                    " option_name = strtok_r ( input_string , \"=\" , & input_ptr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) {\n"
                ],
                [
                    8,
                    " if ( options == NULL ) return VPX_CODEC_OK ;\n"
                ],
                [
                    9,
                    " input_string = strdup ( options ) ;\n"
                ],
                [
                    10,
                    " option_name = strtok_r ( input_string , \"=\" , & input_ptr ) ;\n"
                ],
                [
                    11,
                    " while ( option_name != NULL ) {\n"
                ],
                [
                    13,
                    " if ( option_value == NULL ) {\n"
                ],
                [
                    18,
                    " if ( strcmp ( \"spatial-layers\" , option_name ) == 0 ) {\n"
                ],
                [
                    19,
                    " svc_ctx -> spatial_layers = atoi ( option_value ) ;\n"
                ],
                [
                    21,
                    " else if ( strcmp ( \"temporal-layers\" , option_name ) == 0 ) {\n"
                ],
                [
                    22,
                    " svc_ctx -> temporal_layers = atoi ( option_value ) ;\n"
                ],
                [
                    24,
                    " else if ( strcmp ( \"scale-factors\" , option_name ) == 0 ) {\n"
                ],
                [
                    25,
                    " res = parse_scale_factors ( svc_ctx , option_value ) ;\n"
                ],
                [
                    26,
                    " if ( res != VPX_CODEC_OK ) break ;\n"
                ],
                [
                    28,
                    " else if ( strcmp ( \"quantizers\" , option_name ) == 0 ) {\n"
                ],
                [
                    29,
                    " res = parse_quantizer_values ( svc_ctx , option_value ) ;\n"
                ],
                [
                    30,
                    " if ( res != VPX_CODEC_OK ) break ;\n"
                ],
                [
                    32,
                    " else if ( strcmp ( \"auto-alt-refs\" , option_name ) == 0 ) {\n"
                ],
                [
                    33,
                    " res = parse_auto_alt_ref ( svc_ctx , option_value ) ;\n"
                ],
                [
                    34,
                    " if ( res != VPX_CODEC_OK ) break ;\n"
                ],
                [
                    36,
                    " else if ( strcmp ( \"multi-frame-contexts\" , option_name ) == 0 ) {\n"
                ],
                [
                    37,
                    " si -> use_multiple_frame_contexts = atoi ( option_value ) ;\n"
                ],
                [
                    40,
                    " svc_log ( svc_ctx , SVC_LOG_ERROR , \"invalid option: %s\\n\" , option_name ) ;\n"
                ],
                [
                    41,
                    " res = VPX_CODEC_INVALID_PARAM ;\n"
                ],
                [
                    44,
                    " option_name = strtok_r ( NULL , \"=\" , & input_ptr ) ;\n"
                ],
                [
                    46,
                    " free ( input_string ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * * argv ) {\n using std : : string ;\n if ( argc != 2 ) {\n fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n return 1 ;\n }\n string filename ( argv [ 1 ] ) ;\n string outfilename = filename . substr ( 0 , filename . find_last_of ( \".\" ) ) + \".ttf\" ;\n fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n string input = woff2 : : GetFileContent ( filename ) ;\n size_t decompressed_size = woff2 : : ComputeWOFF2FinalSize ( reinterpret_cast < const uint8_t * > ( input . data ( ) ) , input . size ( ) ) ;\n string output ( decompressed_size , 0 ) ;\n const bool ok = woff2 : : ConvertWOFF2ToTTF ( reinterpret_cast < uint8_t * > ( & output [ 0 ] ) , decompressed_size , reinterpret_cast < const uint8_t * > ( input . data ( ) ) , input . size ( ) ) ;\n if ( ! ok ) {\n fprintf ( stderr , \"Decompression failed\\n\" ) ;\n return 1 ;\n }\n woff2 : : SetFileContents ( outfilename , output ) ;\n return 0 ;\n }",
        "hash": 2898965519451754076,
        "project": "chrome",
        "size": 20,
        "slice": {
            "fprintf": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    3,
                    " if ( argc != 2 ) {\n"
                ],
                [
                    4,
                    " fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n"
                ],
                [
                    9,
                    " fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n"
                ],
                [
                    14,
                    " if ( ! ok ) {\n"
                ],
                [
                    15,
                    " fprintf ( stderr , \"Decompression failed\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    3,
                    " if ( argc != 2 ) {\n"
                ],
                [
                    4,
                    " fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n"
                ],
                [
                    9,
                    " fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n"
                ],
                [
                    14,
                    " if ( ! ok ) {\n"
                ],
                [
                    15,
                    " fprintf ( stderr , \"Decompression failed\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int main ( int argc , char * * argv ) {\n using std : : string ;\n if ( argc != 2 ) {\n fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n return 1 ;\n }\n string filename ( argv [ 1 ] ) ;\n string outfilename = filename . substr ( 0 , filename . find_last_of ( \".\" ) ) + \".woff2\" ;\n fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n string input = woff2 : : GetFileContent ( filename ) ;\n const uint8_t * input_data = reinterpret_cast < const uint8_t * > ( input . data ( ) ) ;\n size_t output_size = woff2 : : MaxWOFF2CompressedSize ( input_data , input . size ( ) ) ;\n string output ( output_size , 0 ) ;\n uint8_t * output_data = reinterpret_cast < uint8_t * > ( & output [ 0 ] ) ;\n if ( ! woff2 : : ConvertTTFToWOFF2 ( input_data , input . size ( ) , output_data , & output_size ) ) {\n fprintf ( stderr , \"Compression failed.\\n\" ) ;\n return 1 ;\n }\n output . resize ( output_size ) ;\n woff2 : : SetFileContents ( outfilename , output ) ;\n return 0 ;\n }",
        "hash": -1967830727983583668,
        "project": "chrome",
        "size": 22,
        "slice": {
            "fprintf": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    3,
                    " if ( argc != 2 ) {\n"
                ],
                [
                    4,
                    " fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n"
                ],
                [
                    9,
                    " fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n"
                ],
                [
                    15,
                    " if ( ! woff2 : : ConvertTTFToWOFF2 ( input_data , input . size ( ) , output_data , & output_size ) ) {\n"
                ],
                [
                    16,
                    " fprintf ( stderr , \"Compression failed.\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int main ( int argc , char * * argv ) {\n"
                ],
                [
                    3,
                    " if ( argc != 2 ) {\n"
                ],
                [
                    4,
                    " fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n"
                ],
                [
                    9,
                    " fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n"
                ],
                [
                    15,
                    " if ( ! woff2 : : ConvertTTFToWOFF2 ( input_data , input . size ( ) , output_data , & output_size ) ) {\n"
                ],
                [
                    16,
                    " fprintf ( stderr , \"Compression failed.\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static uint8_t checkBaseExtUnicode ( UCMStates * baseStates , UCMTable * base , UCMTable * ext , UBool moveToExt , UBool intersectBase ) {\n UCMapping * mb , * me , * mbLimit , * meLimit ;\n int32_t cmp ;\n uint8_t result ;\n mb = base -> mappings ;\n mbLimit = mb + base -> mappingsLength ;\n me = ext -> mappings ;\n meLimit = me + ext -> mappingsLength ;\n result = 0 ;\n for ( ;\n ;\n ) {\n for ( ;\n ;\n ) {\n if ( mb == mbLimit ) {\n return result ;\n }\n if ( ( 0 <= mb -> f && mb -> f <= 2 ) || mb -> f == 4 ) {\n break ;\n }\n ++ mb ;\n }\n for ( ;\n ;\n ) {\n if ( me == meLimit ) {\n return result ;\n }\n if ( ( 0 <= me -> f && me -> f <= 2 ) || me -> f == 4 ) {\n break ;\n }\n ++ me ;\n }\n cmp = compareUnicode ( base , mb , ext , me ) ;\n if ( cmp < 0 ) {\n if ( intersectBase && ( intersectBase != 2 || mb -> bLen > 1 ) ) {\n mb -> moveFlag |= UCM_MOVE_TO_EXT ;\n result |= NEEDS_MOVE ;\n }\n else if ( mb -> uLen < me -> uLen && 0 == uprv_memcmp ( UCM_GET_CODE_POINTS ( base , mb ) , UCM_GET_CODE_POINTS ( ext , me ) , 4 * mb -> uLen ) ) {\n if ( moveToExt ) {\n mb -> moveFlag |= UCM_MOVE_TO_EXT ;\n result |= NEEDS_MOVE ;\n }\n else {\n fprintf ( stderr , \"ucm error: the base table contains a mapping whose input sequence\\n\" \" is a prefix of the input sequence of an extension mapping\\n\" ) ;\n ucm_printMapping ( base , mb , stderr ) ;\n ucm_printMapping ( ext , me , stderr ) ;\n result |= HAS_ERRORS ;\n }\n }\n ++ mb ;\n }\n else if ( cmp == 0 ) {\n if ( mb -> f == me -> f && mb -> bLen == me -> bLen && 0 == uprv_memcmp ( UCM_GET_BYTES ( base , mb ) , UCM_GET_BYTES ( ext , me ) , mb -> bLen ) ) {\n me -> moveFlag |= UCM_REMOVE_MAPPING ;\n result |= NEEDS_MOVE ;\n }\n else if ( intersectBase ) {\n mb -> moveFlag |= UCM_MOVE_TO_EXT ;\n result |= NEEDS_MOVE ;\n }\n else {\n fprintf ( stderr , \"ucm error: the base table contains a mapping whose input sequence\\n\" \" is the same as the input sequence of an extension mapping\\n\" \" but it maps differently\\n\" ) ;\n ucm_printMapping ( base , mb , stderr ) ;\n ucm_printMapping ( ext , me , stderr ) ;\n result |= HAS_ERRORS ;\n }\n ++ mb ;\n }\n else {\n ++ me ;\n }\n }\n }",
        "hash": 4600167735237264207,
        "project": "chrome",
        "size": 76,
        "slice": {
            "fprintf": [
                [
                    1,
                    "static uint8_t checkBaseExtUnicode ( UCMStates * baseStates , UCMTable * base , UCMTable * ext , UBool moveToExt , UBool intersectBase ) {\n"
                ],
                [
                    42,
                    " if ( moveToExt ) {\n"
                ],
                [
                    47,
                    " fprintf ( stderr , \"ucm error: the base table contains a mapping whose input sequence\\n\" \" is a prefix of the input sequence of an extension mapping\\n\" ) ;\n"
                ],
                [
                    48,
                    " ucm_printMapping ( base , mb , stderr ) ;\n"
                ],
                [
                    49,
                    " ucm_printMapping ( ext , me , stderr ) ;\n"
                ],
                [
                    60,
                    " else if ( intersectBase ) {\n"
                ],
                [
                    65,
                    " fprintf ( stderr , \"ucm error: the base table contains a mapping whose input sequence\\n\" \" is the same as the input sequence of an extension mapping\\n\" \" but it maps differently\\n\" ) ;\n"
                ],
                [
                    66,
                    " ucm_printMapping ( base , mb , stderr ) ;\n"
                ],
                [
                    67,
                    " ucm_printMapping ( ext , me , stderr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static uint8_t checkBaseExtUnicode ( UCMStates * baseStates , UCMTable * base , UCMTable * ext , UBool moveToExt , UBool intersectBase ) {\n"
                ],
                [
                    42,
                    " if ( moveToExt ) {\n"
                ],
                [
                    47,
                    " fprintf ( stderr , \"ucm error: the base table contains a mapping whose input sequence\\n\" \" is a prefix of the input sequence of an extension mapping\\n\" ) ;\n"
                ],
                [
                    48,
                    " ucm_printMapping ( base , mb , stderr ) ;\n"
                ],
                [
                    49,
                    " ucm_printMapping ( ext , me , stderr ) ;\n"
                ],
                [
                    60,
                    " else if ( intersectBase ) {\n"
                ],
                [
                    65,
                    " fprintf ( stderr , \"ucm error: the base table contains a mapping whose input sequence\\n\" \" is the same as the input sequence of an extension mapping\\n\" \" but it maps differently\\n\" ) ;\n"
                ],
                [
                    66,
                    " ucm_printMapping ( base , mb , stderr ) ;\n"
                ],
                [
                    67,
                    " ucm_printMapping ( ext , me , stderr ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void addFile ( const char * filename , const char * name , const char * source , UBool sourceTOC , UBool verbose ) {\n char * s ;\n uint32_t length ;\n char * fullPath = NULL ;\n if ( fileCount == fileMax ) {\n fileMax += CHUNK_FILE_COUNT ;\n files = uprv_realloc ( files , fileMax * sizeof ( files [ 0 ] ) ) ;\n if ( files == NULL ) {\n fprintf ( stderr , \"pkgdata/gencmn: Could not allocate %u bytes for %d files\\n\" , ( unsigned int ) ( fileMax * sizeof ( files [ 0 ] ) ) , fileCount ) ;\n exit ( U_MEMORY_ALLOCATION_ERROR ) ;\n }\n }\n if ( ! sourceTOC ) {\n FileStream * file ;\n if ( uprv_pathIsAbsolute ( filename ) ) {\n fprintf ( stderr , \"gencmn: Error: absolute path encountered. Old style paths are not supported. Use relative paths such as 'fur.res' or 'translit%cfur.res'.\\n\\tBad path: '%s'\\n\" , U_FILE_SEP_CHAR , filename ) ;\n exit ( U_ILLEGAL_ARGUMENT_ERROR ) ;\n }\n fullPath = pathToFullPath ( filename , source ) ;\n length = ( uint32_t ) ( uprv_strlen ( filename ) + 1 + uprv_strlen ( name ) + 1 ) ;\n s = allocString ( length ) ;\n uprv_strcpy ( s , name ) ;\n uprv_strcat ( s , U_TREE_ENTRY_SEP_STRING ) ;\n uprv_strcat ( s , filename ) ;\n fixDirToTreePath ( s ) ;\n files [ fileCount ] . basename = s ;\n files [ fileCount ] . basenameLength = length ;\n files [ fileCount ] . pathname = fullPath ;\n basenameTotal += length ;\n file = T_FileStream_open ( fullPath , \"rb\" ) ;\n if ( file == NULL ) {\n fprintf ( stderr , \"gencmn: unable to open listed file %s\\n\" , fullPath ) ;\n exit ( U_FILE_ACCESS_ERROR ) ;\n }\n length = T_FileStream_size ( file ) ;\n if ( T_FileStream_error ( file ) || length <= 20 ) {\n fprintf ( stderr , \"gencmn: unable to get length of listed file %s\\n\" , fullPath ) ;\n exit ( U_FILE_ACCESS_ERROR ) ;\n }\n T_FileStream_close ( file ) ;\n if ( maxSize && length > maxSize ) {\n if ( verbose ) {\n printf ( \"%s ignored (size %ld > %ld)\\n\" , fullPath , ( long ) length , ( long ) maxSize ) ;\n }\n return ;\n }\n files [ fileCount ] . fileSize = length ;\n }\n else {\n char * t ;\n length = ( uint32_t ) ( uprv_strlen ( filename ) + 1 + uprv_strlen ( name ) + 1 ) ;\n s = allocString ( length ) ;\n uprv_strcpy ( s , name ) ;\n uprv_strcat ( s , U_TREE_ENTRY_SEP_STRING ) ;\n uprv_strcat ( s , filename ) ;\n fixDirToTreePath ( s ) ;\n files [ fileCount ] . basename = s ;\n t = files [ fileCount ] . pathname = allocString ( length ) ;\n while ( -- length > 0 ) {\n if ( * s == '.' || * s == '-' || * s == '/' ) {\n * t = '_' ;\n }\n else {\n * t = * s ;\n }\n ++ s ;\n ++ t ;\n }\n * t = 0 ;\n }\n ++ fileCount ;\n }",
        "hash": 6805657479815417135,
        "project": "chrome",
        "size": 72,
        "slice": {
            "printf": [
                [
                    1,
                    "static void addFile ( const char * filename , const char * name , const char * source , UBool sourceTOC , UBool verbose ) {\n"
                ],
                [
                    30,
                    " file = T_FileStream_open ( fullPath , \"rb\" ) ;\n"
                ],
                [
                    32,
                    " fprintf ( stderr , \"gencmn: unable to open listed file %s\\n\" , fullPath ) ;\n"
                ],
                [
                    35,
                    " length = T_FileStream_size ( file ) ;\n"
                ],
                [
                    36,
                    " if ( T_FileStream_error ( file ) || length <= 20 ) {\n"
                ],
                [
                    37,
                    " fprintf ( stderr , \"gencmn: unable to get length of listed file %s\\n\" , fullPath ) ;\n"
                ],
                [
                    41,
                    " if ( maxSize && length > maxSize ) {\n"
                ],
                [
                    42,
                    " if ( verbose ) {\n"
                ],
                [
                    43,
                    " printf ( \"%s ignored (size %ld > %ld)\\n\" , fullPath , ( long ) length , ( long ) maxSize ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void addFile ( const char * filename , const char * name , const char * source , UBool sourceTOC , UBool verbose ) {\n"
                ],
                [
                    5,
                    " if ( fileCount == fileMax ) {\n"
                ],
                [
                    8,
                    " if ( files == NULL ) {\n"
                ],
                [
                    9,
                    " fprintf ( stderr , \"pkgdata/gencmn: Could not allocate %u bytes for %d files\\n\" , ( unsigned int ) ( fileMax * sizeof ( files [ 0 ] ) ) , fileCount ) ;\n"
                ],
                [
                    15,
                    " if ( uprv_pathIsAbsolute ( filename ) ) {\n"
                ],
                [
                    16,
                    " fprintf ( stderr , \"gencmn: Error: absolute path encountered. Old style paths are not supported. Use relative paths such as 'fur.res' or 'translit%cfur.res'.\\n\\tBad path: '%s'\\n\" , U_FILE_SEP_CHAR , filename ) ;\n"
                ],
                [
                    19,
                    " fullPath = pathToFullPath ( filename , source ) ;\n"
                ],
                [
                    30,
                    " file = T_FileStream_open ( fullPath , \"rb\" ) ;\n"
                ],
                [
                    31,
                    " if ( file == NULL ) {\n"
                ],
                [
                    32,
                    " fprintf ( stderr , \"gencmn: unable to open listed file %s\\n\" , fullPath ) ;\n"
                ],
                [
                    36,
                    " if ( T_FileStream_error ( file ) || length <= 20 ) {\n"
                ],
                [
                    37,
                    " fprintf ( stderr , \"gencmn: unable to get length of listed file %s\\n\" , fullPath ) ;\n"
                ],
                [
                    43,
                    " printf ( \"%s ignored (size %ld > %ld)\\n\" , fullPath , ( long ) length , ( long ) maxSize ) ;\n"
                ],
                [
                    71,
                    " ++ fileCount ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void addFile ( const char * filename , const char * name , const char * source , UBool sourceTOC , UBool verbose ) {\n"
                ],
                [
                    5,
                    " if ( fileCount == fileMax ) {\n"
                ],
                [
                    8,
                    " if ( files == NULL ) {\n"
                ],
                [
                    9,
                    " fprintf ( stderr , \"pkgdata/gencmn: Could not allocate %u bytes for %d files\\n\" , ( unsigned int ) ( fileMax * sizeof ( files [ 0 ] ) ) , fileCount ) ;\n"
                ],
                [
                    15,
                    " if ( uprv_pathIsAbsolute ( filename ) ) {\n"
                ],
                [
                    16,
                    " fprintf ( stderr , \"gencmn: Error: absolute path encountered. Old style paths are not supported. Use relative paths such as 'fur.res' or 'translit%cfur.res'.\\n\\tBad path: '%s'\\n\" , U_FILE_SEP_CHAR , filename ) ;\n"
                ],
                [
                    19,
                    " fullPath = pathToFullPath ( filename , source ) ;\n"
                ],
                [
                    30,
                    " file = T_FileStream_open ( fullPath , \"rb\" ) ;\n"
                ],
                [
                    31,
                    " if ( file == NULL ) {\n"
                ],
                [
                    32,
                    " fprintf ( stderr , \"gencmn: unable to open listed file %s\\n\" , fullPath ) ;\n"
                ],
                [
                    35,
                    " length = T_FileStream_size ( file ) ;\n"
                ],
                [
                    36,
                    " if ( T_FileStream_error ( file ) || length <= 20 ) {\n"
                ],
                [
                    37,
                    " fprintf ( stderr , \"gencmn: unable to get length of listed file %s\\n\" , fullPath ) ;\n"
                ],
                [
                    41,
                    " if ( maxSize && length > maxSize ) {\n"
                ],
                [
                    42,
                    " if ( verbose ) {\n"
                ],
                [
                    43,
                    " printf ( \"%s ignored (size %ld > %ld)\\n\" , fullPath , ( long ) length , ( long ) maxSize ) ;\n"
                ],
                [
                    71,
                    " ++ fileCount ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int32_t u_printf_octal_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int64_t num = args [ 0 ] . int64Value ;\n UChar result [ UPRINTF_BUFFER_SIZE ] ;\n int32_t len = UPRINTF_BUFFER_SIZE ;\n if ( info -> fIsShort ) num &= UINT16_MAX ;\n else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;\n ufmt_64tou ( result , & len , num , 8 , FALSE , info -> fPrecision == - 1 && info -> fZero ? info -> fWidth : info -> fPrecision ) ;\n if ( info -> fAlt && result [ 0 ] != 0x0030 && len < UPRINTF_BUFFER_SIZE - 1 ) {\n memmove ( result + 1 , result , len * sizeof ( UChar ) ) ;\n result [ 0 ] = 0x0030 ;\n len += 1 ;\n }\n return handler -> pad_and_justify ( context , info , result , len ) ;\n }",
        "hash": 1981604082870872490,
        "project": "chrome",
        "size": 14,
        "slice": {
            "memmove": [
                [
                    1,
                    "static int32_t u_printf_octal_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n"
                ],
                [
                    7,
                    " ufmt_64tou ( result , & len , num , 8 , FALSE , info -> fPrecision == - 1 && info -> fZero ? info -> fWidth : info -> fPrecision ) ;\n"
                ],
                [
                    8,
                    " if ( info -> fAlt && result [ 0 ] != 0x0030 && len < UPRINTF_BUFFER_SIZE - 1 ) {\n"
                ],
                [
                    9,
                    " memmove ( result + 1 , result , len * sizeof ( UChar ) ) ;\n"
                ],
                [
                    13,
                    " return handler -> pad_and_justify ( context , info , result , len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int32_t u_printf_octal_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n"
                ],
                [
                    7,
                    " ufmt_64tou ( result , & len , num , 8 , FALSE , info -> fPrecision == - 1 && info -> fZero ? info -> fWidth : info -> fPrecision ) ;\n"
                ],
                [
                    8,
                    " if ( info -> fAlt && result [ 0 ] != 0x0030 && len < UPRINTF_BUFFER_SIZE - 1 ) {\n"
                ],
                [
                    9,
                    " memmove ( result + 1 , result , len * sizeof ( UChar ) ) ;\n"
                ],
                [
                    13,
                    " return handler -> pad_and_justify ( context , info , result , len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int32_t u_printf_hex_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int64_t num = args [ 0 ] . int64Value ;\n UChar result [ UPRINTF_BUFFER_SIZE ] ;\n int32_t len = UPRINTF_BUFFER_SIZE ;\n if ( info -> fIsShort ) num &= UINT16_MAX ;\n else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;\n ufmt_64tou ( result , & len , num , 16 , ( UBool ) ( info -> fSpec == 0x0078 ) , ( info -> fPrecision == - 1 && info -> fZero ) ? info -> fWidth : info -> fPrecision ) ;\n if ( num != 0 && info -> fAlt && len < UPRINTF_BUFFER_SIZE - 2 ) {\n memmove ( result + 2 , result , len * sizeof ( UChar ) ) ;\n result [ 0 ] = 0x0030 ;\n result [ 1 ] = info -> fSpec ;\n len += 2 ;\n }\n return handler -> pad_and_justify ( context , info , result , len ) ;\n }",
        "hash": 1981604082870872490,
        "project": "chrome",
        "size": 15,
        "slice": {
            "memmove": [
                [
                    1,
                    "static int32_t u_printf_hex_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n"
                ],
                [
                    7,
                    " ufmt_64tou ( result , & len , num , 16 , ( UBool ) ( info -> fSpec == 0x0078 ) , ( info -> fPrecision == - 1 && info -> fZero ) ? info -> fWidth : info -> fPrecision ) ;\n"
                ],
                [
                    8,
                    " if ( num != 0 && info -> fAlt && len < UPRINTF_BUFFER_SIZE - 2 ) {\n"
                ],
                [
                    9,
                    " memmove ( result + 2 , result , len * sizeof ( UChar ) ) ;\n"
                ],
                [
                    14,
                    " return handler -> pad_and_justify ( context , info , result , len ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int32_t u_printf_hex_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n"
                ],
                [
                    7,
                    " ufmt_64tou ( result , & len , num , 16 , ( UBool ) ( info -> fSpec == 0x0078 ) , ( info -> fPrecision == - 1 && info -> fZero ) ? info -> fWidth : info -> fPrecision ) ;\n"
                ],
                [
                    8,
                    " if ( num != 0 && info -> fAlt && len < UPRINTF_BUFFER_SIZE - 2 ) {\n"
                ],
                [
                    9,
                    " memmove ( result + 2 , result , len * sizeof ( UChar ) ) ;\n"
                ],
                [
                    14,
                    " return handler -> pad_and_justify ( context , info , result , len ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int32_t u_printf_string_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n UChar * s ;\n UChar buffer [ UFMT_DEFAULT_BUFFER_SIZE ] ;\n int32_t len , written ;\n int32_t argSize ;\n const char * arg = ( const char * ) ( args [ 0 ] . ptrValue ) ;\n if ( arg ) {\n argSize = ( int32_t ) strlen ( arg ) + 1 ;\n if ( argSize >= MAX_UCHAR_BUFFER_SIZE ( buffer ) ) {\n s = ufmt_defaultCPToUnicode ( arg , argSize , ( UChar * ) uprv_malloc ( MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) , MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) ;\n if ( s == NULL ) {\n return 0 ;\n }\n }\n else {\n s = ufmt_defaultCPToUnicode ( arg , argSize , buffer , UPRV_LENGTHOF ( buffer ) ) ;\n }\n }\n else {\n s = ( UChar * ) gNullStr ;\n }\n len = u_strlen ( s ) ;\n if ( info -> fPrecision != - 1 && info -> fPrecision < len ) {\n len = info -> fPrecision ;\n }\n written = handler -> pad_and_justify ( context , info , s , len ) ;\n if ( gNullStr != s && buffer != s ) {\n uprv_free ( s ) ;\n }\n return written ;\n }",
        "hash": 1981604082870872490,
        "project": "chrome",
        "size": 31,
        "slice": {
            "strlen": [
                [
                    1,
                    "static int32_t u_printf_string_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n"
                ],
                [
                    6,
                    " const char * arg = ( const char * ) ( args [ 0 ] . ptrValue ) ;\n"
                ],
                [
                    7,
                    " if ( arg ) {\n"
                ],
                [
                    8,
                    " argSize = ( int32_t ) strlen ( arg ) + 1 ;\n"
                ],
                [
                    9,
                    " if ( argSize >= MAX_UCHAR_BUFFER_SIZE ( buffer ) ) {\n"
                ],
                [
                    10,
                    " s = ufmt_defaultCPToUnicode ( arg , argSize , ( UChar * ) uprv_malloc ( MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) , MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) ;\n"
                ],
                [
                    16,
                    " s = ufmt_defaultCPToUnicode ( arg , argSize , buffer , UPRV_LENGTHOF ( buffer ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int32_t u_printf_string_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n"
                ],
                [
                    6,
                    " const char * arg = ( const char * ) ( args [ 0 ] . ptrValue ) ;\n"
                ],
                [
                    7,
                    " if ( arg ) {\n"
                ],
                [
                    8,
                    " argSize = ( int32_t ) strlen ( arg ) + 1 ;\n"
                ],
                [
                    9,
                    " if ( argSize >= MAX_UCHAR_BUFFER_SIZE ( buffer ) ) {\n"
                ],
                [
                    10,
                    " s = ufmt_defaultCPToUnicode ( arg , argSize , ( UChar * ) uprv_malloc ( MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) , MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) ;\n"
                ],
                [
                    16,
                    " s = ufmt_defaultCPToUnicode ( arg , argSize , buffer , UPRV_LENGTHOF ( buffer ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "xmlHashTablePtr xmlHashCreate ( int size ) {\n xmlHashTablePtr table ;\n if ( size <= 0 ) size = 256 ;\n table = xmlMalloc ( sizeof ( xmlHashTable ) ) ;\n if ( table ) {\n table -> dict = NULL ;\n table -> size = size ;\n table -> nbElems = 0 ;\n table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n if ( table -> table ) {\n memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n return ( table ) ;\n }\n xmlFree ( table ) ;\n }\n return ( NULL ) ;\n }",
        "hash": -4239386405881995323,
        "project": "chrome",
        "size": 17,
        "slice": {
            "memset": [
                [
                    1,
                    "xmlHashTablePtr xmlHashCreate ( int size ) {\n"
                ],
                [
                    4,
                    " table = xmlMalloc ( sizeof ( xmlHashTable ) ) ;\n"
                ],
                [
                    9,
                    " table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    10,
                    " if ( table -> table ) {\n"
                ],
                [
                    11,
                    " memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    12,
                    " return ( table ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "xmlHashTablePtr xmlHashCreate ( int size ) {\n"
                ],
                [
                    4,
                    " table = xmlMalloc ( sizeof ( xmlHashTable ) ) ;\n"
                ],
                [
                    9,
                    " table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    10,
                    " if ( table -> table ) {\n"
                ],
                [
                    11,
                    " memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    12,
                    " return ( table ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int xmlHashGrow ( xmlHashTablePtr table , int size ) {\n unsigned long key ;\n int oldsize , i ;\n xmlHashEntryPtr iter , next ;\n struct _xmlHashEntry * oldtable ;\n # ifdef DEBUG_GROW unsigned long nbElem = 0 ;\n # endif if ( table == NULL ) return ( - 1 ) ;\n if ( size < 8 ) return ( - 1 ) ;\n if ( size > 8 * 2048 ) return ( - 1 ) ;\n oldsize = table -> size ;\n oldtable = table -> table ;\n if ( oldtable == NULL ) return ( - 1 ) ;\n table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n if ( table -> table == NULL ) {\n table -> table = oldtable ;\n return ( - 1 ) ;\n }\n memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n table -> size = size ;\n for ( i = 0 ;\n i < oldsize ;\n i ++ ) {\n if ( oldtable [ i ] . valid == 0 ) continue ;\n key = xmlHashComputeKey ( table , oldtable [ i ] . name , oldtable [ i ] . name2 , oldtable [ i ] . name3 ) ;\n memcpy ( & ( table -> table [ key ] ) , & ( oldtable [ i ] ) , sizeof ( xmlHashEntry ) ) ;\n table -> table [ key ] . next = NULL ;\n }\n for ( i = 0 ;\n i < oldsize ;\n i ++ ) {\n iter = oldtable [ i ] . next ;\n while ( iter ) {\n next = iter -> next ;\n key = xmlHashComputeKey ( table , iter -> name , iter -> name2 , iter -> name3 ) ;\n if ( table -> table [ key ] . valid == 0 ) {\n memcpy ( & ( table -> table [ key ] ) , iter , sizeof ( xmlHashEntry ) ) ;\n table -> table [ key ] . next = NULL ;\n xmlFree ( iter ) ;\n }\n else {\n iter -> next = table -> table [ key ] . next ;\n table -> table [ key ] . next = iter ;\n }\n # ifdef DEBUG_GROW nbElem ++ ;\n # endif iter = next ;\n }\n }\n xmlFree ( oldtable ) ;\n # ifdef DEBUG_GROW xmlGenericError ( xmlGenericErrorContext , \"xmlHashGrow : from %d to %d, %d elems\\n\" , oldsize , size , nbElem ) ;\n # endif return ( 0 ) ;\n }",
        "hash": -4239386405881995323,
        "project": "chrome",
        "size": 51,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int xmlHashGrow ( xmlHashTablePtr table , int size ) {\n"
                ],
                [
                    12,
                    " if ( oldtable == NULL ) return ( - 1 ) ;\n"
                ],
                [
                    18,
                    " memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    23,
                    " if ( oldtable [ i ] . valid == 0 ) continue ;\n"
                ],
                [
                    24,
                    " key = xmlHashComputeKey ( table , oldtable [ i ] . name , oldtable [ i ] . name2 , oldtable [ i ] . name3 ) ;\n"
                ],
                [
                    25,
                    " memcpy ( & ( table -> table [ key ] ) , & ( oldtable [ i ] ) , sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    31,
                    " iter = oldtable [ i ] . next ;\n"
                ],
                [
                    34,
                    " key = xmlHashComputeKey ( table , iter -> name , iter -> name2 , iter -> name3 ) ;\n"
                ],
                [
                    35,
                    " if ( table -> table [ key ] . valid == 0 ) {\n"
                ],
                [
                    36,
                    " memcpy ( & ( table -> table [ key ] ) , iter , sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    38,
                    " xmlFree ( iter ) ;\n"
                ],
                [
                    41,
                    " iter -> next = table -> table [ key ] . next ;\n"
                ],
                [
                    48,
                    " xmlFree ( oldtable ) ;\n"
                ]
            ],
            "memset": [
                [
                    1,
                    "static int xmlHashGrow ( xmlHashTablePtr table , int size ) {\n"
                ],
                [
                    14,
                    " if ( table -> table == NULL ) {\n"
                ],
                [
                    18,
                    " memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    24,
                    " key = xmlHashComputeKey ( table , oldtable [ i ] . name , oldtable [ i ] . name2 , oldtable [ i ] . name3 ) ;\n"
                ],
                [
                    25,
                    " memcpy ( & ( table -> table [ key ] ) , & ( oldtable [ i ] ) , sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    34,
                    " key = xmlHashComputeKey ( table , iter -> name , iter -> name2 , iter -> name3 ) ;\n"
                ],
                [
                    36,
                    " memcpy ( & ( table -> table [ key ] ) , iter , sizeof ( xmlHashEntry ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int xmlHashGrow ( xmlHashTablePtr table , int size ) {\n"
                ],
                [
                    12,
                    " if ( oldtable == NULL ) return ( - 1 ) ;\n"
                ],
                [
                    14,
                    " if ( table -> table == NULL ) {\n"
                ],
                [
                    18,
                    " memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    23,
                    " if ( oldtable [ i ] . valid == 0 ) continue ;\n"
                ],
                [
                    24,
                    " key = xmlHashComputeKey ( table , oldtable [ i ] . name , oldtable [ i ] . name2 , oldtable [ i ] . name3 ) ;\n"
                ],
                [
                    25,
                    " memcpy ( & ( table -> table [ key ] ) , & ( oldtable [ i ] ) , sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    31,
                    " iter = oldtable [ i ] . next ;\n"
                ],
                [
                    34,
                    " key = xmlHashComputeKey ( table , iter -> name , iter -> name2 , iter -> name3 ) ;\n"
                ],
                [
                    35,
                    " if ( table -> table [ key ] . valid == 0 ) {\n"
                ],
                [
                    36,
                    " memcpy ( & ( table -> table [ key ] ) , iter , sizeof ( xmlHashEntry ) ) ;\n"
                ],
                [
                    38,
                    " xmlFree ( iter ) ;\n"
                ],
                [
                    41,
                    " iter -> next = table -> table [ key ] . next ;\n"
                ],
                [
                    48,
                    " xmlFree ( oldtable ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static xsltAttrVTPtr xsltSetAttrVTsegment ( xsltAttrVTPtr avt , void * val ) {\n if ( avt -> nb_seg >= avt -> max_seg ) {\n avt = ( xsltAttrVTPtr ) xmlRealloc ( avt , sizeof ( xsltAttrVT ) + avt -> max_seg * sizeof ( void * ) ) ;\n if ( avt == NULL ) {\n return NULL ;\n }\n memset ( & avt -> segments [ avt -> nb_seg ] , 0 , MAX_AVT_SEG * sizeof ( void * ) ) ;\n avt -> max_seg += MAX_AVT_SEG ;\n }\n avt -> segments [ avt -> nb_seg ++ ] = val ;\n return avt ;\n }",
        "hash": -7262742957929857695,
        "project": "chrome",
        "size": 12,
        "slice": {
            "memset": [
                [
                    1,
                    "static xsltAttrVTPtr xsltSetAttrVTsegment ( xsltAttrVTPtr avt , void * val ) {\n"
                ],
                [
                    4,
                    " if ( avt == NULL ) {\n"
                ],
                [
                    7,
                    " memset ( & avt -> segments [ avt -> nb_seg ] , 0 , MAX_AVT_SEG * sizeof ( void * ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static xsltAttrVTPtr xsltSetAttrVTsegment ( xsltAttrVTPtr avt , void * val ) {\n"
                ],
                [
                    4,
                    " if ( avt == NULL ) {\n"
                ],
                [
                    7,
                    " memset ( & avt -> segments [ avt -> nb_seg ] , 0 , MAX_AVT_SEG * sizeof ( void * ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "xsltDocumentPtr xsltNewDocument ( xsltTransformContextPtr ctxt , xmlDocPtr doc ) {\n xsltDocumentPtr cur ;\n cur = ( xsltDocumentPtr ) xmlMalloc ( sizeof ( xsltDocument ) ) ;\n if ( cur == NULL ) {\n xsltTransformError ( ctxt , NULL , ( xmlNodePtr ) doc , \"xsltNewDocument : malloc failed\\n\" ) ;\n return ( NULL ) ;\n }\n memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n cur -> doc = doc ;\n if ( ctxt != NULL ) {\n if ( ! XSLT_IS_RES_TREE_FRAG ( doc ) ) {\n cur -> next = ctxt -> docList ;\n ctxt -> docList = cur ;\n }\n }\n return ( cur ) ;\n }",
        "hash": 2100112064176019294,
        "project": "chrome",
        "size": 17,
        "slice": {
            "memset": [
                [
                    1,
                    "xsltDocumentPtr xsltNewDocument ( xsltTransformContextPtr ctxt , xmlDocPtr doc ) {\n"
                ],
                [
                    4,
                    " if ( cur == NULL ) {\n"
                ],
                [
                    8,
                    " memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n"
                ],
                [
                    13,
                    " ctxt -> docList = cur ;\n"
                ],
                [
                    16,
                    " return ( cur ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "xsltDocumentPtr xsltNewDocument ( xsltTransformContextPtr ctxt , xmlDocPtr doc ) {\n"
                ],
                [
                    4,
                    " if ( cur == NULL ) {\n"
                ],
                [
                    8,
                    " memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n"
                ],
                [
                    13,
                    " ctxt -> docList = cur ;\n"
                ],
                [
                    16,
                    " return ( cur ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "xsltDocumentPtr xsltNewStyleDocument ( xsltStylesheetPtr style , xmlDocPtr doc ) {\n xsltDocumentPtr cur ;\n cur = ( xsltDocumentPtr ) xmlMalloc ( sizeof ( xsltDocument ) ) ;\n if ( cur == NULL ) {\n xsltTransformError ( NULL , style , ( xmlNodePtr ) doc , \"xsltNewStyleDocument : malloc failed\\n\" ) ;\n return ( NULL ) ;\n }\n memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n cur -> doc = doc ;\n if ( style != NULL ) {\n cur -> next = style -> docList ;\n style -> docList = cur ;\n }\n return ( cur ) ;\n }",
        "hash": 2100112064176019294,
        "project": "chrome",
        "size": 15,
        "slice": {
            "memset": [
                [
                    1,
                    "xsltDocumentPtr xsltNewStyleDocument ( xsltStylesheetPtr style , xmlDocPtr doc ) {\n"
                ],
                [
                    4,
                    " if ( cur == NULL ) {\n"
                ],
                [
                    8,
                    " memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n"
                ],
                [
                    12,
                    " style -> docList = cur ;\n"
                ],
                [
                    14,
                    " return ( cur ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "xsltDocumentPtr xsltNewStyleDocument ( xsltStylesheetPtr style , xmlDocPtr doc ) {\n"
                ],
                [
                    4,
                    " if ( cur == NULL ) {\n"
                ],
                [
                    8,
                    " memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n"
                ],
                [
                    12,
                    " style -> docList = cur ;\n"
                ],
                [
                    14,
                    " return ( cur ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void * size_checked_realloc ( void * ptr , size_t size ) {\n if ( size > MAX_LIBXML_MALLOC ) {\n * ( volatile char * ) 0 = '\\0' ;\n return NULL ;\n }\n return realloc ( ptr , size ) ;\n }",
        "hash": -5780611388839125875,
        "project": "chrome",
        "size": 7,
        "slice": {
            "realloc": [
                [
                    1,
                    "static void * size_checked_realloc ( void * ptr , size_t size ) {\n"
                ],
                [
                    2,
                    " if ( size > MAX_LIBXML_MALLOC ) {\n"
                ],
                [
                    6,
                    " return realloc ( ptr , size ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void * size_checked_realloc ( void * ptr , size_t size ) {\n"
                ],
                [
                    2,
                    " if ( size > MAX_LIBXML_MALLOC ) {\n"
                ],
                [
                    6,
                    " return realloc ( ptr , size ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void * size_checked_malloc ( size_t size ) {\n if ( size > MAX_LIBXML_MALLOC ) {\n * ( volatile char * ) 0 = '\\0' ;\n return NULL ;\n }\n return malloc ( size ) ;\n }",
        "hash": -5780611388839125875,
        "project": "chrome",
        "size": 7,
        "slice": {
            "malloc": [
                [
                    1,
                    "static void * size_checked_malloc ( size_t size ) {\n"
                ],
                [
                    2,
                    " if ( size > MAX_LIBXML_MALLOC ) {\n"
                ],
                [
                    6,
                    " return malloc ( size ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void * size_checked_malloc ( size_t size ) {\n"
                ],
                [
                    2,
                    " if ( size > MAX_LIBXML_MALLOC ) {\n"
                ],
                [
                    6,
                    " return malloc ( size ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void xmlInitializeGlobalState ( xmlGlobalStatePtr gs ) {\n # ifdef DEBUG_GLOBALS fprintf ( stderr , \"Initializing globals at %lu for thread %d\\n\" , ( unsigned long ) gs , xmlGetThreadId ( ) ) ;\n # endif if ( xmlThrDefMutex == NULL ) xmlInitGlobals ( ) ;\n xmlMutexLock ( xmlThrDefMutex ) ;\n # if defined ( LIBXML_DOCB_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) && defined ( LIBXML_SAX1_ENABLED ) initdocbDefaultSAXHandler ( & gs -> docbDefaultSAXHandler ) ;\n # endif # if defined ( LIBXML_HTML_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) inithtmlDefaultSAXHandler ( & gs -> htmlDefaultSAXHandler ) ;\n # endif gs -> oldXMLWDcompatibility = 0 ;\n gs -> xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef ;\n gs -> xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef ;\n # if defined ( LIBXML_SAX1_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) initxmlDefaultSAXHandler ( & gs -> xmlDefaultSAXHandler , 1 ) ;\n # endif gs -> xmlDefaultSAXLocator . getPublicId = xmlSAX2GetPublicId ;\n gs -> xmlDefaultSAXLocator . getSystemId = xmlSAX2GetSystemId ;\n gs -> xmlDefaultSAXLocator . getLineNumber = xmlSAX2GetLineNumber ;\n gs -> xmlDefaultSAXLocator . getColumnNumber = xmlSAX2GetColumnNumber ;\n gs -> xmlDoValidityCheckingDefaultValue = xmlDoValidityCheckingDefaultValueThrDef ;\n # if defined ( DEBUG_MEMORY_LOCATION ) | defined ( DEBUG_MEMORY ) gs -> xmlFree = ( xmlFreeFunc ) xmlMemFree ;\n gs -> xmlMalloc = ( xmlMallocFunc ) xmlMemMalloc ;\n gs -> xmlMallocAtomic = ( xmlMallocFunc ) xmlMemMalloc ;\n gs -> xmlRealloc = ( xmlReallocFunc ) xmlMemRealloc ;\n gs -> xmlMemStrdup = ( xmlStrdupFunc ) xmlMemoryStrdup ;\n # else gs -> xmlFree = ( xmlFreeFunc ) free ;\n gs -> xmlMalloc = ( xmlMallocFunc ) malloc ;\n gs -> xmlMallocAtomic = ( xmlMallocFunc ) malloc ;\n gs -> xmlRealloc = ( xmlReallocFunc ) realloc ;\n gs -> xmlMemStrdup = ( xmlStrdupFunc ) xmlStrdup ;\n # endif gs -> xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef ;\n gs -> xmlIndentTreeOutput = xmlIndentTreeOutputThrDef ;\n gs -> xmlTreeIndentString = xmlTreeIndentStringThrDef ;\n gs -> xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef ;\n gs -> xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef ;\n gs -> xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef ;\n gs -> xmlParserDebugEntities = xmlParserDebugEntitiesThrDef ;\n gs -> xmlParserVersion = LIBXML_VERSION_STRING ;\n gs -> xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef ;\n gs -> xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef ;\n gs -> xmlSubstituteEntitiesDefaultValue = xmlSubstituteEntitiesDefaultValueThrDef ;\n gs -> xmlGenericError = xmlGenericErrorThrDef ;\n gs -> xmlStructuredError = xmlStructuredErrorThrDef ;\n gs -> xmlGenericErrorContext = xmlGenericErrorContextThrDef ;\n gs -> xmlStructuredErrorContext = xmlStructuredErrorContextThrDef ;\n gs -> xmlRegisterNodeDefaultValue = xmlRegisterNodeDefaultValueThrDef ;\n gs -> xmlDeregisterNodeDefaultValue = xmlDeregisterNodeDefaultValueThrDef ;\n gs -> xmlParserInputBufferCreateFilenameValue = xmlParserInputBufferCreateFilenameValueThrDef ;\n gs -> xmlOutputBufferCreateFilenameValue = xmlOutputBufferCreateFilenameValueThrDef ;\n memset ( & gs -> xmlLastError , 0 , sizeof ( xmlError ) ) ;\n xmlMutexUnlock ( xmlThrDefMutex ) ;\n }",
        "hash": -5780611388839125875,
        "project": "chrome",
        "size": 47,
        "slice": {
            "memset": [
                [
                    1,
                    "void xmlInitializeGlobalState ( xmlGlobalStatePtr gs ) {\n"
                ],
                [
                    45,
                    " memset ( & gs -> xmlLastError , 0 , sizeof ( xmlError ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void xmlInitializeGlobalState ( xmlGlobalStatePtr gs ) {\n"
                ],
                [
                    45,
                    " memset ( & gs -> xmlLastError , 0 , sizeof ( xmlError ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {\n xmlListPtr l ;\n if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for list\" ) ;\n return ( NULL ) ;\n }\n memset ( l , 0 , sizeof ( xmlList ) ) ;\n if ( NULL == ( l -> sentinel = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ) ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for sentinel\" ) ;\n xmlFree ( l ) ;\n return ( NULL ) ;\n }\n l -> sentinel -> next = l -> sentinel ;\n l -> sentinel -> prev = l -> sentinel ;\n l -> sentinel -> data = NULL ;\n if ( deallocator != NULL ) l -> linkDeallocator = deallocator ;\n if ( compare != NULL ) l -> linkCompare = compare ;\n else l -> linkCompare = xmlLinkCompare ;\n return l ;\n }",
        "hash": -4558261210024070448,
        "project": "chrome",
        "size": 20,
        "slice": {
            "memset": [
                [
                    1,
                    "xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {\n"
                ],
                [
                    3,
                    " if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {\n"
                ],
                [
                    7,
                    " memset ( l , 0 , sizeof ( xmlList ) ) ;\n"
                ],
                [
                    10,
                    " xmlFree ( l ) ;\n"
                ],
                [
                    13,
                    " l -> sentinel -> next = l -> sentinel ;\n"
                ],
                [
                    14,
                    " l -> sentinel -> prev = l -> sentinel ;\n"
                ],
                [
                    19,
                    " return l ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {\n"
                ],
                [
                    3,
                    " if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {\n"
                ],
                [
                    7,
                    " memset ( l , 0 , sizeof ( xmlList ) ) ;\n"
                ],
                [
                    10,
                    " xmlFree ( l ) ;\n"
                ],
                [
                    13,
                    " l -> sentinel -> next = l -> sentinel ;\n"
                ],
                [
                    14,
                    " l -> sentinel -> prev = l -> sentinel ;\n"
                ],
                [
                    19,
                    " return l ;\n"
                ]
            ]
        }
    },
    {
        "code": "int MBS_ApplyPatch ( const MBSPatchHeader * header , int patchfd , unsigned char * fbuffer , int filefd ) {\n unsigned char * fbufend = fbuffer + header -> slen ;\n unsigned char * buf = ( unsigned char * ) malloc ( header -> cblen + header -> difflen + header -> extralen ) ;\n if ( ! buf ) return MEM_ERROR ;\n int rv = OK ;\n int r = header -> cblen + header -> difflen + header -> extralen ;\n unsigned char * wb = buf ;\n while ( r ) {\n int c = read ( patchfd , wb , ( r > SSIZE_MAX ) ? SSIZE_MAX : r ) ;\n if ( c < 0 ) {\n rv = READ_ERROR ;\n goto end ;\n }\n r -= c ;\n if ( c == 0 && r ) {\n rv = UNEXPECTED_ERROR ;\n goto end ;\n }\n }\n {\n MBSPatchTriple * ctrlsrc = ( MBSPatchTriple * ) buf ;\n unsigned char * diffsrc = buf + header -> cblen ;\n unsigned char * extrasrc = diffsrc + header -> difflen ;\n MBSPatchTriple * ctrlend = ( MBSPatchTriple * ) diffsrc ;\n unsigned char * diffend = extrasrc ;\n unsigned char * extraend = extrasrc + header -> extralen ;\n do {\n ctrlsrc -> x = ntohl ( ctrlsrc -> x ) ;\n ctrlsrc -> y = ntohl ( ctrlsrc -> y ) ;\n ctrlsrc -> z = ntohl ( ctrlsrc -> z ) ;\n # ifdef DEBUG_bsmedberg printf ( \"Applying block:\\n\" \" x: %u\\n\" \" y: %u\\n\" \" z: %i\\n\" , ctrlsrc -> x , ctrlsrc -> y , ctrlsrc -> z ) ;\n # endif if ( fbuffer + ctrlsrc -> x > fbufend || diffsrc + ctrlsrc -> x > diffend ) {\n rv = UNEXPECTED_ERROR ;\n goto end ;\n }\n for ( unsigned int i = 0 ;\n i < ctrlsrc -> x ;\n ++ i ) {\n diffsrc [ i ] += fbuffer [ i ] ;\n }\n if ( ( int ) write ( filefd , diffsrc , ctrlsrc -> x ) != ctrlsrc -> x ) {\n rv = WRITE_ERROR ;\n goto end ;\n }\n fbuffer += ctrlsrc -> x ;\n diffsrc += ctrlsrc -> x ;\n if ( extrasrc + ctrlsrc -> y > extraend ) {\n rv = UNEXPECTED_ERROR ;\n goto end ;\n }\n if ( ( int ) write ( filefd , extrasrc , ctrlsrc -> y ) != ctrlsrc -> y ) {\n rv = WRITE_ERROR ;\n goto end ;\n }\n extrasrc += ctrlsrc -> y ;\n if ( fbuffer + ctrlsrc -> z > fbufend ) {\n rv = UNEXPECTED_ERROR ;\n goto end ;\n }\n fbuffer += ctrlsrc -> z ;\n ++ ctrlsrc ;\n }\n while ( ctrlsrc < ctrlend ) ;\n }\n end : free ( buf ) ;\n return rv ;\n }",
        "hash": 9111838939241885685,
        "project": "chrome",
        "size": 67,
        "slice": {
            "malloc": [
                [
                    1,
                    "int MBS_ApplyPatch ( const MBSPatchHeader * header , int patchfd , unsigned char * fbuffer , int filefd ) {\n"
                ],
                [
                    3,
                    " unsigned char * buf = ( unsigned char * ) malloc ( header -> cblen + header -> difflen + header -> extralen ) ;\n"
                ],
                [
                    4,
                    " if ( ! buf ) return MEM_ERROR ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int MBS_ApplyPatch ( const MBSPatchHeader * header , int patchfd , unsigned char * fbuffer , int filefd ) {\n"
                ],
                [
                    3,
                    " unsigned char * buf = ( unsigned char * ) malloc ( header -> cblen + header -> difflen + header -> extralen ) ;\n"
                ],
                [
                    4,
                    " if ( ! buf ) return MEM_ERROR ;\n"
                ]
            ]
        }
    },
    {
        "code": "int MBS_ReadHeader ( int fd , MBSPatchHeader * header ) {\n int s = read ( fd , header , sizeof ( MBSPatchHeader ) ) ;\n if ( s != sizeof ( MBSPatchHeader ) ) return READ_ERROR ;\n header -> slen = ntohl ( header -> slen ) ;\n header -> scrc32 = ntohl ( header -> scrc32 ) ;\n header -> dlen = ntohl ( header -> dlen ) ;\n header -> cblen = ntohl ( header -> cblen ) ;\n header -> difflen = ntohl ( header -> difflen ) ;\n header -> extralen = ntohl ( header -> extralen ) ;\n struct stat hs ;\n s = fstat ( fd , & hs ) ;\n if ( s ) return READ_ERROR ;\n if ( memcmp ( header -> tag , \"MBDIFF10\" , 8 ) != 0 ) return UNEXPECTED_ERROR ;\n if ( sizeof ( MBSPatchHeader ) + header -> cblen + header -> difflen + header -> extralen != int ( hs . st_size ) ) return UNEXPECTED_ERROR ;\n return OK ;\n }",
        "hash": 9111838939241885685,
        "project": "chrome",
        "size": 16,
        "slice": {
            "memcmp": [
                [
                    1,
                    "int MBS_ReadHeader ( int fd , MBSPatchHeader * header ) {\n"
                ],
                [
                    2,
                    " int s = read ( fd , header , sizeof ( MBSPatchHeader ) ) ;\n"
                ],
                [
                    12,
                    " if ( s ) return READ_ERROR ;\n"
                ],
                [
                    13,
                    " if ( memcmp ( header -> tag , \"MBDIFF10\" , 8 ) != 0 ) return UNEXPECTED_ERROR ;\n"
                ],
                [
                    14,
                    " if ( sizeof ( MBSPatchHeader ) + header -> cblen + header -> difflen + header -> extralen != int ( hs . st_size ) ) return UNEXPECTED_ERROR ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int MBS_ReadHeader ( int fd , MBSPatchHeader * header ) {\n"
                ],
                [
                    2,
                    " int s = read ( fd , header , sizeof ( MBSPatchHeader ) ) ;\n"
                ],
                [
                    12,
                    " if ( s ) return READ_ERROR ;\n"
                ],
                [
                    13,
                    " if ( memcmp ( header -> tag , \"MBDIFF10\" , 8 ) != 0 ) return UNEXPECTED_ERROR ;\n"
                ],
                [
                    14,
                    " if ( sizeof ( MBSPatchHeader ) + header -> cblen + header -> difflen + header -> extralen != int ( hs . st_size ) ) return UNEXPECTED_ERROR ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void TestHeapFunctions ( ) {\n UErrorCode status = U_ZERO_ERROR ;\n UResourceBundle * rb = NULL ;\n char * icuDataDir ;\n UVersionInfo unicodeVersion = {\n 0 , 0 , 0 , 0 }\n ;\n icuDataDir = safeGetICUDataDirectory ( ) ;\n ctest_resetICU ( ) ;\n u_setMemoryFunctions ( & gContext , myMemAlloc , myMemRealloc , myMemFree , & status ) ;\n TEST_STATUS ( status , U_INVALID_STATE_ERROR ) ;\n u_cleanup ( ) ;\n status = U_ZERO_ERROR ;\n u_setMemoryFunctions ( & gContext , NULL , myMemRealloc , myMemFree , & status ) ;\n TEST_STATUS ( status , U_ILLEGAL_ARGUMENT_ERROR ) ;\n status = U_ZERO_ERROR ;\n u_setMemoryFunctions ( & gContext , myMemAlloc , NULL , myMemFree , & status ) ;\n TEST_STATUS ( status , U_ILLEGAL_ARGUMENT_ERROR ) ;\n status = U_ZERO_ERROR ;\n u_setMemoryFunctions ( & gContext , myMemAlloc , myMemRealloc , NULL , & status ) ;\n TEST_STATUS ( status , U_ILLEGAL_ARGUMENT_ERROR ) ;\n status = U_ZERO_ERROR ;\n u_setMemoryFunctions ( NULL , myMemAlloc , myMemRealloc , myMemFree , & status ) ;\n TEST_STATUS ( status , U_ZERO_ERROR ) ;\n u_setMemoryFunctions ( & gContext , myMemAlloc , myMemRealloc , myMemFree , & status ) ;\n TEST_STATUS ( status , U_ZERO_ERROR ) ;\n status = U_ZERO_ERROR ;\n u_setDataDirectory ( icuDataDir ) ;\n u_init ( & status ) ;\n TEST_STATUS ( status , U_ZERO_ERROR ) ;\n u_setMemoryFunctions ( NULL , myMemAlloc , myMemRealloc , myMemFree , & status ) ;\n TEST_STATUS ( status , U_INVALID_STATE_ERROR ) ;\n gBlockCount = 0 ;\n status = U_ZERO_ERROR ;\n rb = ures_open ( NULL , \"es\" , & status ) ;\n TEST_STATUS ( status , U_ZERO_ERROR ) ;\n if ( gBlockCount == 0 ) {\n log_err ( \"Heap functions are not being called from ICU.\\n\" ) ;\n }\n ures_close ( rb ) ;\n ctest_resetICU ( ) ;\n u_getUnicodeVersion ( unicodeVersion ) ;\n if ( unicodeVersion [ 0 ] <= 0 ) {\n log_err ( \"Properties doesn't reinitialize without u_init.\\n\" ) ;\n }\n status = U_ZERO_ERROR ;\n u_init ( & status ) ;\n TEST_STATUS ( status , U_ZERO_ERROR ) ;\n gBlockCount = 0 ;\n status = U_ZERO_ERROR ;\n rb = ures_open ( NULL , \"fr\" , & status ) ;\n TEST_STATUS ( status , U_ZERO_ERROR ) ;\n if ( gBlockCount != 0 ) {\n log_err ( \"Heap functions did not reset after u_cleanup.\\n\" ) ;\n }\n ures_close ( rb ) ;\n free ( icuDataDir ) ;\n ctest_resetICU ( ) ;\n }",
        "hash": 4491846291755990729,
        "project": "chrome",
        "size": 59,
        "slice": {
            "free": [
                [
                    1,
                    "static void TestHeapFunctions ( ) {\n"
                ],
                [
                    28,
                    " u_setDataDirectory ( icuDataDir ) ;\n"
                ],
                [
                    57,
                    " free ( icuDataDir ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void TestHeapFunctions ( ) {\n"
                ],
                [
                    28,
                    " u_setDataDirectory ( icuDataDir ) ;\n"
                ],
                [
                    57,
                    " free ( icuDataDir ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "TEST_F ( TransportSecurityPersisterTest , PublicKeyHashes ) {\n TransportSecurityState : : DomainState domain_state ;\n static const char kTestDomain [ ] = \"example.com\" ;\n EXPECT_FALSE ( state_ . GetDomainState ( kTestDomain , false , & domain_state ) ) ;\n net : : HashValueVector hashes ;\n std : : string failure_log ;\n EXPECT_FALSE ( domain_state . CheckPublicKeyPins ( hashes , & failure_log ) ) ;\n net : : HashValue sha1 ( net : : HASH_VALUE_SHA1 ) ;\n memset ( sha1 . data ( ) , '1' , sha1 . size ( ) ) ;\n domain_state . dynamic_spki_hashes . push_back ( sha1 ) ;\n EXPECT_FALSE ( domain_state . CheckPublicKeyPins ( hashes , & failure_log ) ) ;\n hashes . push_back ( sha1 ) ;\n EXPECT_TRUE ( domain_state . CheckPublicKeyPins ( hashes , & failure_log ) ) ;\n hashes [ 0 ] . data ( ) [ 0 ] = '2' ;\n EXPECT_FALSE ( domain_state . CheckPublicKeyPins ( hashes , & failure_log ) ) ;\n const base : : Time current_time ( base : : Time : : Now ( ) ) ;\n const base : : Time expiry = current_time + base : : TimeDelta : : FromSeconds ( 1000 ) ;\n bool include_subdomains = false ;\n state_ . AddHSTS ( kTestDomain , expiry , include_subdomains ) ;\n state_ . AddHPKP ( kTestDomain , expiry , include_subdomains , domain_state . dynamic_spki_hashes ) ;\n std : : string ser ;\n EXPECT_TRUE ( persister_ -> SerializeData ( & ser ) ) ;\n bool dirty ;\n EXPECT_TRUE ( persister_ -> LoadEntries ( ser , & dirty ) ) ;\n EXPECT_TRUE ( state_ . GetDomainState ( kTestDomain , false , & domain_state ) ) ;\n EXPECT_EQ ( 1u , domain_state . dynamic_spki_hashes . size ( ) ) ;\n EXPECT_EQ ( sha1 . tag , domain_state . dynamic_spki_hashes [ 0 ] . tag ) ;\n EXPECT_EQ ( 0 , memcmp ( domain_state . dynamic_spki_hashes [ 0 ] . data ( ) , sha1 . data ( ) , sha1 . size ( ) ) ) ;\n }",
        "hash": -6527276140940489090,
        "project": "chrome",
        "size": 29,
        "slice": {
            "memset": [
                [
                    1,
                    "TEST_F ( TransportSecurityPersisterTest , PublicKeyHashes ) {\n"
                ],
                [
                    9,
                    " memset ( sha1 . data ( ) , '1' , sha1 . size ( ) ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "TEST_F ( TransportSecurityPersisterTest , PublicKeyHashes ) {\n"
                ],
                [
                    28,
                    " EXPECT_EQ ( 0 , memcmp ( domain_state . dynamic_spki_hashes [ 0 ] . data ( ) , sha1 . data ( ) , sha1 . size ( ) ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "TEST_F ( TransportSecurityPersisterTest , PublicKeyHashes ) {\n"
                ],
                [
                    9,
                    " memset ( sha1 . data ( ) , '1' , sha1 . size ( ) ) ;\n"
                ],
                [
                    28,
                    " EXPECT_EQ ( 0 , memcmp ( domain_state . dynamic_spki_hashes [ 0 ] . data ( ) , sha1 . data ( ) , sha1 . size ( ) ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static inline void free_static_shapers ( void ) {\n if ( unlikely ( static_shapers != all_shapers ) ) free ( ( void * ) static_shapers ) ;\n }",
        "hash": -1711362334384181293,
        "project": "chrome",
        "size": 3,
        "slice": {
            "free": [
                [
                    1,
                    "static inline void free_static_shapers ( void ) {\n"
                ],
                [
                    2,
                    " if ( unlikely ( static_shapers != all_shapers ) ) free ( ( void * ) static_shapers ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static inline void free_static_shapers ( void ) {\n"
                ],
                [
                    2,
                    " if ( unlikely ( static_shapers != all_shapers ) ) free ( ( void * ) static_shapers ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void preprocess_text_hangul ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , hb_font_t * font ) {\n HB_BUFFER_ALLOCATE_VAR ( buffer , hangul_shaping_feature ) ;\n buffer -> clear_output ( ) ;\n unsigned int start = 0 , end = 0 ;\n unsigned int count = buffer -> len ;\n for ( buffer -> idx = 0 ;\n buffer -> idx < count ;\n ) {\n hb_codepoint_t u = buffer -> cur ( ) . codepoint ;\n if ( isHangulTone ( u ) ) {\n if ( start < end && end == buffer -> out_len ) {\n buffer -> next_glyph ( ) ;\n if ( ! is_zero_width_char ( font , u ) ) {\n hb_glyph_info_t * info = buffer -> out_info ;\n hb_glyph_info_t tone = info [ end ] ;\n memmove ( & info [ start + 1 ] , & info [ start ] , ( end - start ) * sizeof ( hb_glyph_info_t ) ) ;\n info [ start ] = tone ;\n }\n buffer -> merge_out_clusters ( start , end + 1 ) ;\n }\n else {\n if ( font -> has_glyph ( 0x25CCu ) ) {\n hb_codepoint_t chars [ 2 ] ;\n if ( ! is_zero_width_char ( font , u ) ) {\n chars [ 0 ] = u ;\n chars [ 1 ] = 0x25CCu ;\n }\n else {\n chars [ 0 ] = 0x25CCu ;\n chars [ 1 ] = u ;\n }\n buffer -> replace_glyphs ( 1 , 2 , chars ) ;\n }\n else {\n buffer -> next_glyph ( ) ;\n }\n }\n start = end = buffer -> out_len ;\n continue ;\n }\n start = buffer -> out_len ;\n if ( isL ( u ) && buffer -> idx + 1 < count ) {\n hb_codepoint_t l = u ;\n hb_codepoint_t v = buffer -> cur ( + 1 ) . codepoint ;\n if ( isV ( v ) ) {\n hb_codepoint_t t = 0 ;\n unsigned int tindex = 0 ;\n if ( buffer -> idx + 2 < count ) {\n t = buffer -> cur ( + 2 ) . codepoint ;\n if ( isT ( t ) ) tindex = t - TBase ;\n else t = 0 ;\n }\n if ( isCombiningL ( l ) && isCombiningV ( v ) && ( t == 0 || isCombiningT ( t ) ) ) {\n hb_codepoint_t s = SBase + ( l - LBase ) * NCount + ( v - VBase ) * TCount + tindex ;\n if ( font -> has_glyph ( s ) ) {\n buffer -> replace_glyphs ( t ? 3 : 2 , 1 , & s ) ;\n if ( unlikely ( buffer -> in_error ) ) return ;\n end = start + 1 ;\n continue ;\n }\n }\n buffer -> cur ( ) . hangul_shaping_feature ( ) = LJMO ;\n buffer -> next_glyph ( ) ;\n buffer -> cur ( ) . hangul_shaping_feature ( ) = VJMO ;\n buffer -> next_glyph ( ) ;\n if ( t ) {\n buffer -> cur ( ) . hangul_shaping_feature ( ) = TJMO ;\n buffer -> next_glyph ( ) ;\n end = start + 3 ;\n }\n else end = start + 2 ;\n buffer -> merge_out_clusters ( start , end ) ;\n continue ;\n }\n }\n else if ( isCombinedS ( u ) ) {\n hb_codepoint_t s = u ;\n bool has_glyph = font -> has_glyph ( s ) ;\n unsigned int lindex = ( s - SBase ) / NCount ;\n unsigned int nindex = ( s - SBase ) % NCount ;\n unsigned int vindex = nindex / TCount ;\n unsigned int tindex = nindex % TCount ;\n if ( ! tindex && buffer -> idx + 1 < count && isCombiningT ( buffer -> cur ( + 1 ) . codepoint ) ) {\n unsigned int new_tindex = buffer -> cur ( + 1 ) . codepoint - TBase ;\n hb_codepoint_t new_s = s + new_tindex ;\n if ( font -> has_glyph ( new_s ) ) {\n buffer -> replace_glyphs ( 2 , 1 , & new_s ) ;\n if ( unlikely ( buffer -> in_error ) ) return ;\n end = start + 1 ;\n continue ;\n }\n }\n if ( ! has_glyph || ( ! tindex && buffer -> idx + 1 < count && isT ( buffer -> cur ( + 1 ) . codepoint ) ) ) {\n hb_codepoint_t decomposed [ 3 ] = {\n LBase + lindex , VBase + vindex , TBase + tindex }\n ;\n if ( font -> has_glyph ( decomposed [ 0 ] ) && font -> has_glyph ( decomposed [ 1 ] ) && ( ! tindex || font -> has_glyph ( decomposed [ 2 ] ) ) ) {\n unsigned int s_len = tindex ? 3 : 2 ;\n buffer -> replace_glyphs ( 1 , s_len , decomposed ) ;\n if ( unlikely ( buffer -> in_error ) ) return ;\n hb_glyph_info_t * info = buffer -> out_info ;\n if ( has_glyph && ! tindex ) {\n buffer -> next_glyph ( ) ;\n s_len ++ ;\n }\n end = start + s_len ;\n unsigned int i = start ;\n info [ i ++ ] . hangul_shaping_feature ( ) = LJMO ;\n info [ i ++ ] . hangul_shaping_feature ( ) = VJMO ;\n if ( i < end ) info [ i ++ ] . hangul_shaping_feature ( ) = TJMO ;\n buffer -> merge_out_clusters ( start , end ) ;\n continue ;\n }\n }\n if ( has_glyph ) {\n end = start + 1 ;\n buffer -> next_glyph ( ) ;\n continue ;\n }\n }\n buffer -> next_glyph ( ) ;\n }\n buffer -> swap_buffers ( ) ;\n }",
        "hash": -3808839139375273429,
        "project": "chrome",
        "size": 124,
        "slice": {
            "memmove": [
                [
                    1,
                    "static void preprocess_text_hangul ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , hb_font_t * font ) {\n"
                ],
                [
                    13,
                    " if ( ! is_zero_width_char ( font , u ) ) {\n"
                ],
                [
                    14,
                    " hb_glyph_info_t * info = buffer -> out_info ;\n"
                ],
                [
                    16,
                    " memmove ( & info [ start + 1 ] , & info [ start ] , ( end - start ) * sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    17,
                    " info [ start ] = tone ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void preprocess_text_hangul ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , hb_font_t * font ) {\n"
                ],
                [
                    13,
                    " if ( ! is_zero_width_char ( font , u ) ) {\n"
                ],
                [
                    14,
                    " hb_glyph_info_t * info = buffer -> out_info ;\n"
                ],
                [
                    16,
                    " memmove ( & info [ start + 1 ] , & info [ start ] , ( end - start ) * sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    17,
                    " info [ start ] = tone ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void final_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n const indic_shape_plan_t * indic_plan = ( const indic_shape_plan_t * ) plan -> data ;\n hb_glyph_info_t * info = buffer -> info ;\n if ( indic_plan -> virama_glyph ) {\n unsigned int virama_glyph = indic_plan -> virama_glyph ;\n for ( unsigned int i = start ;\n i < end ;\n i ++ ) if ( info [ i ] . codepoint == virama_glyph && _hb_glyph_info_ligated ( & info [ i ] ) && _hb_glyph_info_multiplied ( & info [ i ] ) ) {\n info [ i ] . indic_category ( ) = OT_H ;\n _hb_glyph_info_clear_ligated_and_multiplied ( & info [ i ] ) ;\n }\n }\n bool try_pref = ! ! indic_plan -> mask_array [ PREF ] ;\n unsigned int base ;\n for ( base = start ;\n base < end ;\n base ++ ) if ( info [ base ] . indic_position ( ) >= POS_BASE_C ) {\n if ( try_pref && base + 1 < end && indic_plan -> config -> pref_len == 2 ) {\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( ( info [ i ] . mask & indic_plan -> mask_array [ PREF ] ) != 0 ) {\n if ( ! ( _hb_glyph_info_substituted ( & info [ i ] ) && _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n base = i ;\n while ( base < end && is_halant_or_coeng ( info [ base ] ) ) base ++ ;\n info [ base ] . indic_position ( ) = POS_BASE_C ;\n try_pref = false ;\n }\n break ;\n }\n }\n if ( start < base && info [ base ] . indic_position ( ) > POS_BASE_C ) base -- ;\n break ;\n }\n if ( base == end && start < base && is_one_of ( info [ base - 1 ] , FLAG ( OT_ZWJ ) ) ) base -- ;\n if ( base < end ) while ( start < base && is_one_of ( info [ base ] , ( FLAG ( OT_N ) | HALANT_OR_COENG_FLAGS ) ) ) base -- ;\n if ( start + 1 < end && start < base ) {\n unsigned int new_pos = base == end ? base - 2 : base - 1 ;\n if ( buffer -> props . script != HB_SCRIPT_MALAYALAM && buffer -> props . script != HB_SCRIPT_TAMIL ) {\n while ( new_pos > start && ! ( is_one_of ( info [ new_pos ] , ( FLAG ( OT_M ) | HALANT_OR_COENG_FLAGS ) ) ) ) new_pos -- ;\n if ( is_halant_or_coeng ( info [ new_pos ] ) && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n if ( new_pos + 1 < end && is_joiner ( info [ new_pos + 1 ] ) ) new_pos ++ ;\n }\n else new_pos = start ;\n }\n if ( start < new_pos && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n for ( unsigned int i = new_pos ;\n i > start ;\n i -- ) if ( info [ i - 1 ] . indic_position ( ) == POS_PRE_M ) {\n unsigned int old_pos = i - 1 ;\n hb_glyph_info_t tmp = info [ old_pos ] ;\n memmove ( & info [ old_pos ] , & info [ old_pos + 1 ] , ( new_pos - old_pos ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_pos ] = tmp ;\n if ( old_pos < base && base <= new_pos ) base -- ;\n buffer -> merge_clusters ( new_pos , MIN ( end , base + 1 ) ) ;\n new_pos -- ;\n }\n }\n else {\n for ( unsigned int i = start ;\n i < base ;\n i ++ ) if ( info [ i ] . indic_position ( ) == POS_PRE_M ) {\n buffer -> merge_clusters ( i , MIN ( end , base + 1 ) ) ;\n break ;\n }\n }\n }\n if ( start + 1 < end && info [ start ] . indic_position ( ) == POS_RA_TO_BECOME_REPH && ( ( info [ start ] . indic_category ( ) == OT_Repha ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ start ] ) ) ) {\n unsigned int new_reph_pos ;\n reph_position_t reph_pos = indic_plan -> config -> reph_pos ;\n assert ( reph_pos != REPH_POS_DONT_CARE ) ;\n if ( reph_pos == REPH_POS_AFTER_POST ) {\n goto reph_step_5 ;\n }\n {\n new_reph_pos = start + 1 ;\n while ( new_reph_pos < base && ! is_halant_or_coeng ( info [ new_reph_pos ] ) ) new_reph_pos ++ ;\n if ( new_reph_pos < base && is_halant_or_coeng ( info [ new_reph_pos ] ) ) {\n if ( new_reph_pos + 1 < base && is_joiner ( info [ new_reph_pos + 1 ] ) ) new_reph_pos ++ ;\n goto reph_move ;\n }\n }\n if ( reph_pos == REPH_POS_AFTER_MAIN ) {\n new_reph_pos = base ;\n while ( new_reph_pos + 1 < end && info [ new_reph_pos + 1 ] . indic_position ( ) <= POS_AFTER_MAIN ) new_reph_pos ++ ;\n if ( new_reph_pos < end ) goto reph_move ;\n }\n if ( reph_pos == REPH_POS_AFTER_SUB ) {\n new_reph_pos = base ;\n while ( new_reph_pos < end && ! ( FLAG ( info [ new_reph_pos + 1 ] . indic_position ( ) ) & ( FLAG ( POS_POST_C ) | FLAG ( POS_AFTER_POST ) | FLAG ( POS_SMVD ) ) ) ) new_reph_pos ++ ;\n if ( new_reph_pos < end ) goto reph_move ;\n }\n reph_step_5 : {\n new_reph_pos = start + 1 ;\n while ( new_reph_pos < base && ! is_halant_or_coeng ( info [ new_reph_pos ] ) ) new_reph_pos ++ ;\n if ( new_reph_pos < base && is_halant_or_coeng ( info [ new_reph_pos ] ) ) {\n if ( new_reph_pos + 1 < base && is_joiner ( info [ new_reph_pos + 1 ] ) ) new_reph_pos ++ ;\n goto reph_move ;\n }\n }\n {\n new_reph_pos = end - 1 ;\n while ( new_reph_pos > start && info [ new_reph_pos ] . indic_position ( ) == POS_SMVD ) new_reph_pos -- ;\n if ( ! hb_options ( ) . uniscribe_bug_compatible && unlikely ( is_halant_or_coeng ( info [ new_reph_pos ] ) ) ) {\n for ( unsigned int i = base + 1 ;\n i < new_reph_pos ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_M ) {\n new_reph_pos -- ;\n }\n }\n goto reph_move ;\n }\n reph_move : {\n buffer -> merge_clusters ( start , new_reph_pos + 1 ) ;\n hb_glyph_info_t reph = info [ start ] ;\n memmove ( & info [ start ] , & info [ start + 1 ] , ( new_reph_pos - start ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_reph_pos ] = reph ;\n if ( start < base && base <= new_reph_pos ) base -- ;\n }\n }\n if ( try_pref && base + 1 < end ) {\n unsigned int pref_len = indic_plan -> config -> pref_len ;\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( ( info [ i ] . mask & indic_plan -> mask_array [ PREF ] ) != 0 ) {\n if ( _hb_glyph_info_substituted ( & info [ i ] ) && ( ( pref_len == 1 ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n unsigned int new_pos = base ;\n if ( buffer -> props . script != HB_SCRIPT_MALAYALAM && buffer -> props . script != HB_SCRIPT_TAMIL ) {\n while ( new_pos > start && ! ( is_one_of ( info [ new_pos - 1 ] , FLAG ( OT_M ) | HALANT_OR_COENG_FLAGS ) ) ) new_pos -- ;\n if ( new_pos > start && info [ new_pos - 1 ] . indic_category ( ) == OT_M ) {\n unsigned int old_pos = i ;\n for ( unsigned int i = base + 1 ;\n i < old_pos ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_M ) {\n new_pos -- ;\n break ;\n }\n }\n }\n if ( new_pos > start && is_halant_or_coeng ( info [ new_pos - 1 ] ) ) {\n if ( new_pos < end && is_joiner ( info [ new_pos ] ) ) new_pos ++ ;\n }\n {\n unsigned int old_pos = i ;\n buffer -> merge_clusters ( new_pos , old_pos + 1 ) ;\n hb_glyph_info_t tmp = info [ old_pos ] ;\n memmove ( & info [ new_pos + 1 ] , & info [ new_pos ] , ( old_pos - new_pos ) * sizeof ( info [ 0 ] ) ) ;\n info [ new_pos ] = tmp ;\n if ( new_pos <= base && base < old_pos ) base ++ ;\n }\n }\n break ;\n }\n }\n if ( info [ start ] . indic_position ( ) == POS_PRE_M && ( ! start || ! ( FLAG ( _hb_glyph_info_get_general_category ( & info [ start - 1 ] ) ) & FLAG_RANGE ( HB_UNICODE_GENERAL_CATEGORY_FORMAT , HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ) ) ) ) info [ start ] . mask |= indic_plan -> mask_array [ INIT ] ;\n if ( hb_options ( ) . uniscribe_bug_compatible ) {\n switch ( ( hb_tag_t ) plan -> props . script ) {\n case HB_SCRIPT_TAMIL : case HB_SCRIPT_SINHALA : break ;\n default : buffer -> merge_clusters ( start , end ) ;\n break ;\n }\n }\n }",
        "hash": -3165961362620712443,
        "project": "chrome",
        "size": 162,
        "slice": {
            "memmove": [
                [
                    1,
                    "static void final_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n"
                ],
                [
                    3,
                    " hb_glyph_info_t * info = buffer -> info ;\n"
                ],
                [
                    40,
                    " if ( is_halant_or_coeng ( info [ new_pos ] ) && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n"
                ],
                [
                    41,
                    " if ( new_pos + 1 < end && is_joiner ( info [ new_pos + 1 ] ) ) new_pos ++ ;\n"
                ],
                [
                    48,
                    " i -- ) if ( info [ i - 1 ] . indic_position ( ) == POS_PRE_M ) {\n"
                ],
                [
                    50,
                    " hb_glyph_info_t tmp = info [ old_pos ] ;\n"
                ],
                [
                    51,
                    " memmove ( & info [ old_pos ] , & info [ old_pos + 1 ] , ( new_pos - old_pos ) * sizeof ( info [ 0 ] ) ) ;\n"
                ],
                [
                    52,
                    " info [ new_pos ] = tmp ;\n"
                ],
                [
                    67,
                    " if ( start + 1 < end && info [ start ] . indic_position ( ) == POS_RA_TO_BECOME_REPH && ( ( info [ start ] . indic_category ( ) == OT_Repha ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ start ] ) ) ) {\n"
                ],
                [
                    115,
                    " memmove ( & info [ start ] , & info [ start + 1 ] , ( new_reph_pos - start ) * sizeof ( info [ 0 ] ) ) ;\n"
                ],
                [
                    125,
                    " if ( _hb_glyph_info_substituted ( & info [ i ] ) && ( ( pref_len == 1 ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n"
                ],
                [
                    140,
                    " if ( new_pos < end && is_joiner ( info [ new_pos ] ) ) new_pos ++ ;\n"
                ],
                [
                    145,
                    " hb_glyph_info_t tmp = info [ old_pos ] ;\n"
                ],
                [
                    146,
                    " memmove ( & info [ new_pos + 1 ] , & info [ new_pos ] , ( old_pos - new_pos ) * sizeof ( info [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void final_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n"
                ],
                [
                    3,
                    " hb_glyph_info_t * info = buffer -> info ;\n"
                ],
                [
                    40,
                    " if ( is_halant_or_coeng ( info [ new_pos ] ) && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n"
                ],
                [
                    41,
                    " if ( new_pos + 1 < end && is_joiner ( info [ new_pos + 1 ] ) ) new_pos ++ ;\n"
                ],
                [
                    48,
                    " i -- ) if ( info [ i - 1 ] . indic_position ( ) == POS_PRE_M ) {\n"
                ],
                [
                    50,
                    " hb_glyph_info_t tmp = info [ old_pos ] ;\n"
                ],
                [
                    51,
                    " memmove ( & info [ old_pos ] , & info [ old_pos + 1 ] , ( new_pos - old_pos ) * sizeof ( info [ 0 ] ) ) ;\n"
                ],
                [
                    52,
                    " info [ new_pos ] = tmp ;\n"
                ],
                [
                    67,
                    " if ( start + 1 < end && info [ start ] . indic_position ( ) == POS_RA_TO_BECOME_REPH && ( ( info [ start ] . indic_category ( ) == OT_Repha ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ start ] ) ) ) {\n"
                ],
                [
                    115,
                    " memmove ( & info [ start ] , & info [ start + 1 ] , ( new_reph_pos - start ) * sizeof ( info [ 0 ] ) ) ;\n"
                ],
                [
                    125,
                    " if ( _hb_glyph_info_substituted ( & info [ i ] ) && ( ( pref_len == 1 ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n"
                ],
                [
                    140,
                    " if ( new_pos < end && is_joiner ( info [ new_pos ] ) ) new_pos ++ ;\n"
                ],
                [
                    145,
                    " hb_glyph_info_t tmp = info [ old_pos ] ;\n"
                ],
                [
                    146,
                    " memmove ( & info [ new_pos + 1 ] , & info [ new_pos ] , ( old_pos - new_pos ) * sizeof ( info [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void initial_reordering_consonant_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n const indic_shape_plan_t * indic_plan = ( const indic_shape_plan_t * ) plan -> data ;\n hb_glyph_info_t * info = buffer -> info ;\n unsigned int base = end ;\n bool has_reph = false ;\n {\n unsigned int limit = start ;\n if ( indic_plan -> config -> reph_pos != REPH_POS_DONT_CARE && indic_plan -> mask_array [ RPHF ] && start + 3 <= end && ( ( indic_plan -> config -> reph_mode == REPH_MODE_IMPLICIT && ! is_joiner ( info [ start + 2 ] ) ) || ( indic_plan -> config -> reph_mode == REPH_MODE_EXPLICIT && info [ start + 2 ] . indic_category ( ) == OT_ZWJ ) ) ) {\n hb_codepoint_t glyphs [ 3 ] = {\n info [ start ] . codepoint , info [ start + 1 ] . codepoint , indic_plan -> config -> reph_mode == REPH_MODE_EXPLICIT ? info [ start + 2 ] . codepoint : 0 }\n ;\n if ( indic_plan -> rphf . would_substitute ( glyphs , 2 , face ) || ( indic_plan -> config -> reph_mode == REPH_MODE_EXPLICIT && indic_plan -> rphf . would_substitute ( glyphs , 3 , face ) ) ) {\n limit += 2 ;\n while ( limit < end && is_joiner ( info [ limit ] ) ) limit ++ ;\n base = start ;\n has_reph = true ;\n }\n }\n else if ( indic_plan -> config -> reph_mode == REPH_MODE_LOG_REPHA && info [ start ] . indic_category ( ) == OT_Repha ) {\n limit += 1 ;\n while ( limit < end && is_joiner ( info [ limit ] ) ) limit ++ ;\n base = start ;\n has_reph = true ;\n }\n switch ( indic_plan -> config -> base_pos ) {\n default : assert ( false ) ;\n case BASE_POS_LAST : {\n unsigned int i = end ;\n bool seen_below = false ;\n do {\n i -- ;\n if ( is_consonant ( info [ i ] ) ) {\n if ( info [ i ] . indic_position ( ) != POS_BELOW_C && ( info [ i ] . indic_position ( ) != POS_POST_C || seen_below ) ) {\n base = i ;\n break ;\n }\n if ( info [ i ] . indic_position ( ) == POS_BELOW_C ) seen_below = true ;\n base = i ;\n }\n else {\n if ( start < i && info [ i ] . indic_category ( ) == OT_ZWJ && info [ i - 1 ] . indic_category ( ) == OT_H ) break ;\n }\n }\n while ( i > limit ) ;\n }\n break ;\n case BASE_POS_LAST_SINHALA : {\n if ( ! has_reph ) base = limit ;\n for ( unsigned int i = limit ;\n i < end ;\n i ++ ) if ( is_consonant ( info [ i ] ) ) {\n if ( limit < i && info [ i - 1 ] . indic_category ( ) == OT_ZWJ ) break ;\n else base = i ;\n }\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( is_consonant ( info [ i ] ) ) info [ i ] . indic_position ( ) = POS_BELOW_C ;\n }\n break ;\n case BASE_POS_FIRST : {\n assert ( indic_plan -> config -> reph_mode == REPH_MODE_VIS_REPHA ) ;\n assert ( ! has_reph ) ;\n base = start ;\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( is_consonant ( info [ i ] ) ) info [ i ] . indic_position ( ) = POS_BELOW_C ;\n }\n break ;\n }\n if ( has_reph && base == start && limit - base <= 2 ) {\n has_reph = false ;\n }\n }\n for ( unsigned int i = start ;\n i < base ;\n i ++ ) info [ i ] . indic_position ( ) = MIN ( POS_PRE_C , ( indic_position_t ) info [ i ] . indic_position ( ) ) ;\n if ( base < end ) info [ base ] . indic_position ( ) = POS_BASE_C ;\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_M ) {\n for ( unsigned int j = i + 1 ;\n j < end ;\n j ++ ) if ( is_consonant ( info [ j ] ) ) {\n info [ j ] . indic_position ( ) = POS_FINAL_C ;\n break ;\n }\n break ;\n }\n if ( has_reph ) info [ start ] . indic_position ( ) = POS_RA_TO_BECOME_REPH ;\n if ( indic_plan -> is_old_spec ) {\n bool disallow_double_halants = buffer -> props . script != HB_SCRIPT_MALAYALAM ;\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_H ) {\n unsigned int j ;\n for ( j = end - 1 ;\n j > i ;\n j -- ) if ( is_consonant ( info [ j ] ) || ( disallow_double_halants && info [ j ] . indic_category ( ) == OT_H ) ) break ;\n if ( info [ j ] . indic_category ( ) != OT_H && j > i ) {\n hb_glyph_info_t t = info [ i ] ;\n memmove ( & info [ i ] , & info [ i + 1 ] , ( j - i ) * sizeof ( info [ 0 ] ) ) ;\n info [ j ] = t ;\n }\n break ;\n }\n }\n {\n indic_position_t last_pos = POS_START ;\n for ( unsigned int i = start ;\n i < end ;\n i ++ ) {\n if ( ( FLAG ( info [ i ] . indic_category ( ) ) & ( JOINER_FLAGS | FLAG ( OT_N ) | FLAG ( OT_RS ) | MEDIAL_FLAGS | HALANT_OR_COENG_FLAGS ) ) ) {\n info [ i ] . indic_position ( ) = last_pos ;\n if ( unlikely ( info [ i ] . indic_category ( ) == OT_H && info [ i ] . indic_position ( ) == POS_PRE_M ) ) {\n for ( unsigned int j = i ;\n j > start ;\n j -- ) if ( info [ j - 1 ] . indic_position ( ) != POS_PRE_M ) {\n info [ i ] . indic_position ( ) = info [ j - 1 ] . indic_position ( ) ;\n break ;\n }\n }\n }\n else if ( info [ i ] . indic_position ( ) != POS_SMVD ) {\n last_pos = ( indic_position_t ) info [ i ] . indic_position ( ) ;\n }\n }\n }\n {\n unsigned int last = base ;\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) if ( is_consonant ( info [ i ] ) ) {\n for ( unsigned int j = last + 1 ;\n j < i ;\n j ++ ) if ( info [ j ] . indic_position ( ) < POS_SMVD ) info [ j ] . indic_position ( ) = info [ i ] . indic_position ( ) ;\n last = i ;\n }\n else if ( info [ i ] . indic_category ( ) == OT_M ) last = i ;\n }\n {\n unsigned int syllable = info [ start ] . syllable ( ) ;\n for ( unsigned int i = start ;\n i < end ;\n i ++ ) info [ i ] . syllable ( ) = i - start ;\n hb_bubble_sort ( info + start , end - start , compare_indic_order ) ;\n base = end ;\n for ( unsigned int i = start ;\n i < end ;\n i ++ ) if ( info [ i ] . indic_position ( ) == POS_BASE_C ) {\n base = i ;\n break ;\n }\n if ( indic_plan -> is_old_spec || end - base > 127 ) buffer -> merge_clusters ( base , end ) ;\n else {\n for ( unsigned int i = base ;\n i < end ;\n i ++ ) if ( info [ i ] . syllable ( ) != 255 ) {\n unsigned int max = i ;\n unsigned int j = start + info [ i ] . syllable ( ) ;\n while ( j != i ) {\n max = MAX ( max , j ) ;\n unsigned int next = start + info [ j ] . syllable ( ) ;\n info [ j ] . syllable ( ) = 255 ;\n j = next ;\n }\n if ( i != max ) buffer -> merge_clusters ( i , max + 1 ) ;\n }\n }\n for ( unsigned int i = start ;\n i < end ;\n i ++ ) info [ i ] . syllable ( ) = syllable ;\n }\n {\n hb_mask_t mask ;\n for ( unsigned int i = start ;\n i < end && info [ i ] . indic_position ( ) == POS_RA_TO_BECOME_REPH ;\n i ++ ) info [ i ] . mask |= indic_plan -> mask_array [ RPHF ] ;\n mask = indic_plan -> mask_array [ HALF ] ;\n if ( ! indic_plan -> is_old_spec && indic_plan -> config -> blwf_mode == BLWF_MODE_PRE_AND_POST ) mask |= indic_plan -> mask_array [ BLWF ] ;\n for ( unsigned int i = start ;\n i < base ;\n i ++ ) info [ i ] . mask |= mask ;\n mask = 0 ;\n if ( base < end ) info [ base ] . mask |= mask ;\n mask = indic_plan -> mask_array [ BLWF ] | indic_plan -> mask_array [ ABVF ] | indic_plan -> mask_array [ PSTF ] ;\n for ( unsigned int i = base + 1 ;\n i < end ;\n i ++ ) info [ i ] . mask |= mask ;\n }\n if ( indic_plan -> is_old_spec && buffer -> props . script == HB_SCRIPT_DEVANAGARI ) {\n for ( unsigned int i = start ;\n i + 1 < base ;\n i ++ ) if ( info [ i ] . indic_category ( ) == OT_Ra && info [ i + 1 ] . indic_category ( ) == OT_H && ( i + 2 == base || info [ i + 2 ] . indic_category ( ) != OT_ZWJ ) ) {\n info [ i ] . mask |= indic_plan -> mask_array [ BLWF ] ;\n info [ i + 1 ] . mask |= indic_plan -> mask_array [ BLWF ] ;\n }\n }\n unsigned int pref_len = indic_plan -> config -> pref_len ;\n if ( indic_plan -> mask_array [ PREF ] && base + pref_len < end ) {\n assert ( 1 <= pref_len && pref_len <= 2 ) ;\n for ( unsigned int i = base + 1 ;\n i + pref_len - 1 < end ;\n i ++ ) {\n hb_codepoint_t glyphs [ 2 ] ;\n for ( unsigned int j = 0 ;\n j < pref_len ;\n j ++ ) glyphs [ j ] = info [ i + j ] . codepoint ;\n if ( indic_plan -> pref . would_substitute ( glyphs , pref_len , face ) ) {\n for ( unsigned int j = 0 ;\n j < pref_len ;\n j ++ ) info [ i ++ ] . mask |= indic_plan -> mask_array [ PREF ] ;\n if ( indic_plan -> mask_array [ CFAR ] ) for ( ;\n i < end ;\n i ++ ) info [ i ] . mask |= indic_plan -> mask_array [ CFAR ] ;\n break ;\n }\n }\n }\n for ( unsigned int i = start + 1 ;\n i < end ;\n i ++ ) if ( is_joiner ( info [ i ] ) ) {\n bool non_joiner = info [ i ] . indic_category ( ) == OT_ZWNJ ;\n unsigned int j = i ;\n do {\n j -- ;\n if ( non_joiner ) info [ j ] . mask &= ~ indic_plan -> mask_array [ HALF ] ;\n }\n while ( j > start && ! is_consonant ( info [ j ] ) ) ;\n }\n }",
        "hash": -3165961362620712443,
        "project": "chrome",
        "size": 230,
        "slice": {
            "memmove": [
                [
                    1,
                    "static void initial_reordering_consonant_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n"
                ],
                [
                    3,
                    " hb_glyph_info_t * info = buffer -> info ;\n"
                ],
                [
                    32,
                    " if ( is_consonant ( info [ i ] ) ) {\n"
                ],
                [
                    51,
                    " i ++ ) if ( is_consonant ( info [ i ] ) ) {\n"
                ],
                [
                    57,
                    " i ++ ) if ( is_consonant ( info [ i ] ) ) info [ i ] . indic_position ( ) = POS_BELOW_C ;\n"
                ],
                [
                    66,
                    " i ++ ) if ( is_consonant ( info [ i ] ) ) info [ i ] . indic_position ( ) = POS_BELOW_C ;\n"
                ],
                [
                    99,
                    " if ( info [ j ] . indic_category ( ) != OT_H && j > i ) {\n"
                ],
                [
                    101,
                    " memmove ( & info [ i ] , & info [ i + 1 ] , ( j - i ) * sizeof ( info [ 0 ] ) ) ;\n"
                ],
                [
                    132,
                    " i ++ ) if ( is_consonant ( info [ i ] ) ) {\n"
                ],
                [
                    221,
                    " i ++ ) if ( is_joiner ( info [ i ] ) ) {\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void initial_reordering_consonant_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n"
                ],
                [
                    3,
                    " hb_glyph_info_t * info = buffer -> info ;\n"
                ],
                [
                    32,
                    " if ( is_consonant ( info [ i ] ) ) {\n"
                ],
                [
                    51,
                    " i ++ ) if ( is_consonant ( info [ i ] ) ) {\n"
                ],
                [
                    57,
                    " i ++ ) if ( is_consonant ( info [ i ] ) ) info [ i ] . indic_position ( ) = POS_BELOW_C ;\n"
                ],
                [
                    66,
                    " i ++ ) if ( is_consonant ( info [ i ] ) ) info [ i ] . indic_position ( ) = POS_BELOW_C ;\n"
                ],
                [
                    99,
                    " if ( info [ j ] . indic_category ( ) != OT_H && j > i ) {\n"
                ],
                [
                    101,
                    " memmove ( & info [ i ] , & info [ i + 1 ] , ( j - i ) * sizeof ( info [ 0 ] ) ) ;\n"
                ],
                [
                    132,
                    " i ++ ) if ( is_consonant ( info [ i ] ) ) {\n"
                ],
                [
                    221,
                    " i ++ ) if ( is_joiner ( info [ i ] ) ) {\n"
                ]
            ]
        }
    },
    {
        "code": "static hb_language_t * language_reference ( hb_language_t * l ) {\n hb_language_t * c = ( hb_language_t * ) calloc ( 1 , sizeof ( hb_language_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 6,
        "slice": {
            "calloc": [
                [
                    1,
                    "static hb_language_t * language_reference ( hb_language_t * l ) {\n"
                ],
                [
                    2,
                    " hb_language_t * c = ( hb_language_t * ) calloc ( 1 , sizeof ( hb_language_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static hb_language_t * language_reference ( hb_language_t * l ) {\n"
                ],
                [
                    2,
                    " hb_language_t * c = ( hb_language_t * ) calloc ( 1 , sizeof ( hb_language_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 6,
        "slice": {
            "calloc": [
                [
                    1,
                    "static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    2,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    2,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 3,
        "slice": {
            "free": [
                [
                    1,
                    "static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    2,
                    " free ( g ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    2,
                    " free ( g ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_info , glyph_info_reference , glyph_info_destroy ) static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_position , glyph_position_reference , glyph_position_destroy ) static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( segment_properties , segment_properties_reference , segment_properties_destroy ) static hb_user_data_key_t user_data_key_reference ( hb_user_data_key_t l ) {\n return l ;\n }\n static void user_data_key_destroy ( hb_user_data_key_t l ) {\n }\n HB_DEFINE_BOXED_TYPE ( user_data_key , user_data_key_reference , user_data_key_destroy ) static hb_language_t * language_reference ( hb_language_t * l ) {\n hb_language_t * c = ( hb_language_t * ) calloc ( 1 , sizeof ( hb_language_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }\n static void language_destroy ( hb_language_t * l ) {\n free ( l ) ;\n }\n HB_DEFINE_BOXED_TYPE ( language , language_reference , language_destroy )",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 60,
        "slice": {
            "free": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ]
            ],
            "calloc": [
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ],
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void language_destroy ( hb_language_t * l ) {\n free ( l ) ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 3,
        "slice": {
            "free": [
                [
                    1,
                    "static void language_destroy ( hb_language_t * l ) {\n"
                ],
                [
                    2,
                    " free ( l ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void language_destroy ( hb_language_t * l ) {\n"
                ],
                [
                    2,
                    " free ( l ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 6,
        "slice": {
            "calloc": [
                [
                    1,
                    "static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n"
                ],
                [
                    2,
                    " hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n"
                ],
                [
                    2,
                    " hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n free ( g ) ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 3,
        "slice": {
            "free": [
                [
                    1,
                    "static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n"
                ],
                [
                    2,
                    " free ( g ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n"
                ],
                [
                    2,
                    " free ( g ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 6,
        "slice": {
            "calloc": [
                [
                    1,
                    "static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n"
                ],
                [
                    2,
                    " hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n"
                ],
                [
                    2,
                    " hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n free ( g ) ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 3,
        "slice": {
            "free": [
                [
                    1,
                    "static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n"
                ],
                [
                    2,
                    " free ( g ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n"
                ],
                [
                    2,
                    " free ( g ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n free ( g ) ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 3,
        "slice": {
            "free": [
                [
                    1,
                    "static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    2,
                    " free ( g ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    2,
                    " free ( g ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 6,
        "slice": {
            "calloc": [
                [
                    1,
                    "static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n"
                ],
                [
                    2,
                    " hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n"
                ],
                [
                    2,
                    " hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n"
                ],
                [
                    3,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_info , glyph_info_reference , glyph_info_destroy )",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 28,
        "slice": {
            "free": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ]
            ],
            "calloc": [
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ],
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_info , glyph_info_reference , glyph_info_destroy ) static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_position , glyph_position_reference , glyph_position_destroy ) static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( segment_properties , segment_properties_reference , segment_properties_destroy )",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 46,
        "slice": {
            "free": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ]
            ],
            "calloc": [
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ],
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_info , glyph_info_reference , glyph_info_destroy ) static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_position , glyph_position_reference , glyph_position_destroy ) static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( segment_properties , segment_properties_reference , segment_properties_destroy ) static hb_user_data_key_t user_data_key_reference ( hb_user_data_key_t l ) {\n return l ;\n }\n static void user_data_key_destroy ( hb_user_data_key_t l ) {\n }\n HB_DEFINE_BOXED_TYPE ( user_data_key , user_data_key_reference , user_data_key_destroy )",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 51,
        "slice": {
            "free": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ]
            ],
            "calloc": [
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ],
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy )",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 19,
        "slice": {
            "free": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ]
            ],
            "result": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_info , glyph_info_reference , glyph_info_destroy ) static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( glyph_position , glyph_position_reference , glyph_position_destroy )",
        "hash": -4527380754569407959,
        "project": "chrome",
        "size": 37,
        "slice": {
            "free": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ]
            ],
            "calloc": [
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ],
            "result": [
                [
                    16,
                    " static void feature_destroy ( hb_feature_t * g ) {\n"
                ],
                [
                    17,
                    " free ( g ) ;\n"
                ],
                [
                    19,
                    " HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n"
                ],
                [
                    20,
                    " hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n"
                ],
                [
                    21,
                    " if ( unlikely ( ! c ) ) return NULL ;\n"
                ]
            ]
        }
    },
    {
        "code": "hb_bool_t _hb_graphite2_shape ( hb_shape_plan_t * shape_plan , hb_font_t * font , hb_buffer_t * buffer , const hb_feature_t * features , unsigned int num_features ) {\n hb_face_t * face = font -> face ;\n gr_face * grface = HB_SHAPER_DATA_GET ( face ) -> grface ;\n gr_font * grfont = HB_SHAPER_DATA_GET ( font ) ;\n const char * lang = hb_language_to_string ( hb_buffer_get_language ( buffer ) ) ;\n const char * lang_end = lang ? strchr ( lang , '-' ) : NULL ;\n int lang_len = lang_end ? lang_end - lang : - 1 ;\n gr_feature_val * feats = gr_face_featureval_for_lang ( grface , lang ? hb_tag_from_string ( lang , lang_len ) : 0 ) ;\n while ( num_features -- ) {\n const gr_feature_ref * fref = gr_face_find_fref ( grface , features -> tag ) ;\n if ( fref ) gr_fref_set_feature_value ( fref , features -> value , feats ) ;\n features ++ ;\n }\n gr_segment * seg = NULL ;\n const gr_slot * is ;\n unsigned int ci = 0 , ic = 0 ;\n float curradvx = 0. , curradvy = 0. ;\n unsigned int scratch_size ;\n hb_buffer_t : : scratch_buffer_t * scratch = buffer -> get_scratch_buffer ( & scratch_size ) ;\n uint32_t * chars = ( uint32_t * ) scratch ;\n for ( unsigned int i = 0 ;\n i < buffer -> len ;\n ++ i ) chars [ i ] = buffer -> info [ i ] . codepoint ;\n hb_tag_t script_tag [ 2 ] ;\n hb_ot_tags_from_script ( hb_buffer_get_script ( buffer ) , & script_tag [ 0 ] , & script_tag [ 1 ] ) ;\n seg = gr_make_seg ( grfont , grface , script_tag [ 1 ] == HB_TAG_NONE ? script_tag [ 0 ] : script_tag [ 1 ] , feats , gr_utf32 , chars , buffer -> len , | ( hb_buffer_get_direction ( buffer ) == HB_DIRECTION_RTL ? 1 : 0 ) ) ;\n if ( unlikely ( ! seg ) ) {\n if ( feats ) gr_featureval_destroy ( feats ) ;\n return false ;\n }\n unsigned int glyph_count = gr_seg_n_slots ( seg ) ;\n if ( unlikely ( ! glyph_count ) ) {\n if ( feats ) gr_featureval_destroy ( feats ) ;\n gr_seg_destroy ( seg ) ;\n return false ;\n }\n scratch = buffer -> get_scratch_buffer ( & scratch_size ) ;\n while ( ( DIV_CEIL ( sizeof ( hb_graphite2_cluster_t ) * buffer -> len , sizeof ( * scratch ) ) + DIV_CEIL ( sizeof ( hb_codepoint_t ) * glyph_count , sizeof ( * scratch ) ) ) > scratch_size ) {\n if ( unlikely ( ! buffer -> ensure ( buffer -> allocated * 2 ) ) ) {\n if ( feats ) gr_featureval_destroy ( feats ) ;\n gr_seg_destroy ( seg ) ;\n return false ;\n }\n scratch = buffer -> get_scratch_buffer ( & scratch_size ) ;\n }\n # define ALLOCATE_ARRAY ( Type , name , len ) Type * name = ( Type * ) scratch ;\n {\n unsigned int _consumed = DIV_CEIL ( ( len ) * sizeof ( Type ) , sizeof ( * scratch ) ) ;\n assert ( _consumed <= scratch_size ) ;\n scratch += _consumed ;\n scratch_size -= _consumed ;\n }\n ALLOCATE_ARRAY ( hb_graphite2_cluster_t , clusters , buffer -> len ) ;\n ALLOCATE_ARRAY ( hb_codepoint_t , gids , glyph_count ) ;\n # undef ALLOCATE_ARRAY memset ( clusters , 0 , sizeof ( clusters [ 0 ] ) * buffer -> len ) ;\n hb_codepoint_t * pg = gids ;\n clusters [ 0 ] . cluster = buffer -> info [ 0 ] . cluster ;\n for ( is = gr_seg_first_slot ( seg ) , ic = 0 ;\n is ;\n is = gr_slot_next_in_segment ( is ) , ic ++ ) {\n unsigned int before = gr_slot_before ( is ) ;\n unsigned int after = gr_slot_after ( is ) ;\n * pg = gr_slot_gid ( is ) ;\n pg ++ ;\n while ( clusters [ ci ] . base_char > before && ci ) {\n clusters [ ci - 1 ] . num_chars += clusters [ ci ] . num_chars ;\n clusters [ ci - 1 ] . num_glyphs += clusters [ ci ] . num_glyphs ;\n ci -- ;\n }\n if ( gr_slot_can_insert_before ( is ) && clusters [ ci ] . num_chars && before >= clusters [ ci ] . base_char + clusters [ ci ] . num_chars ) {\n hb_graphite2_cluster_t * c = clusters + ci + 1 ;\n c -> base_char = clusters [ ci ] . base_char + clusters [ ci ] . num_chars ;\n c -> cluster = buffer -> info [ c -> base_char ] . cluster ;\n c -> num_chars = before - c -> base_char ;\n c -> base_glyph = ic ;\n c -> num_glyphs = 0 ;\n ci ++ ;\n }\n clusters [ ci ] . num_glyphs ++ ;\n if ( clusters [ ci ] . base_char + clusters [ ci ] . num_chars < after + 1 ) clusters [ ci ] . num_chars = after + 1 - clusters [ ci ] . base_char ;\n }\n ci ++ ;\n for ( unsigned int i = 0 ;\n i < ci ;\n ++ i ) {\n for ( unsigned int j = 0 ;\n j < clusters [ i ] . num_glyphs ;\n ++ j ) {\n hb_glyph_info_t * info = & buffer -> info [ clusters [ i ] . base_glyph + j ] ;\n info -> codepoint = gids [ clusters [ i ] . base_glyph + j ] ;\n info -> cluster = clusters [ i ] . cluster ;\n }\n }\n buffer -> len = glyph_count ;\n if ( HB_DIRECTION_IS_BACKWARD ( buffer -> props . direction ) ) curradvx = gr_seg_advance_X ( seg ) ;\n hb_glyph_position_t * pPos ;\n for ( pPos = hb_buffer_get_glyph_positions ( buffer , NULL ) , is = gr_seg_first_slot ( seg ) ;\n is ;\n pPos ++ , is = gr_slot_next_in_segment ( is ) ) {\n pPos -> x_offset = gr_slot_origin_X ( is ) - curradvx ;\n pPos -> y_offset = gr_slot_origin_Y ( is ) - curradvy ;\n pPos -> x_advance = gr_slot_advance_X ( is , grface , grfont ) ;\n pPos -> y_advance = gr_slot_advance_Y ( is , grface , grfont ) ;\n if ( HB_DIRECTION_IS_BACKWARD ( buffer -> props . direction ) ) curradvx -= pPos -> x_advance ;\n pPos -> x_offset = gr_slot_origin_X ( is ) - curradvx ;\n if ( ! HB_DIRECTION_IS_BACKWARD ( buffer -> props . direction ) ) curradvx += pPos -> x_advance ;\n pPos -> y_offset = gr_slot_origin_Y ( is ) - curradvy ;\n curradvy += pPos -> y_advance ;\n }\n if ( ! HB_DIRECTION_IS_BACKWARD ( buffer -> props . direction ) ) pPos [ - 1 ] . x_advance += gr_seg_advance_X ( seg ) - curradvx ;\n if ( HB_DIRECTION_IS_BACKWARD ( buffer -> props . direction ) ) hb_buffer_reverse_clusters ( buffer ) ;\n if ( feats ) gr_featureval_destroy ( feats ) ;\n gr_seg_destroy ( seg ) ;\n return true ;\n }",
        "hash": 330507736709312787,
        "project": "chrome",
        "size": 115,
        "slice": {
            "strchr": [
                [
                    1,
                    "hb_bool_t _hb_graphite2_shape ( hb_shape_plan_t * shape_plan , hb_font_t * font , hb_buffer_t * buffer , const hb_feature_t * features , unsigned int num_features ) {\n"
                ],
                [
                    5,
                    " const char * lang = hb_language_to_string ( hb_buffer_get_language ( buffer ) ) ;\n"
                ],
                [
                    6,
                    " const char * lang_end = lang ? strchr ( lang , '-' ) : NULL ;\n"
                ],
                [
                    7,
                    " int lang_len = lang_end ? lang_end - lang : - 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "hb_bool_t _hb_graphite2_shape ( hb_shape_plan_t * shape_plan , hb_font_t * font , hb_buffer_t * buffer , const hb_feature_t * features , unsigned int num_features ) {\n"
                ],
                [
                    5,
                    " const char * lang = hb_language_to_string ( hb_buffer_get_language ( buffer ) ) ;\n"
                ],
                [
                    6,
                    " const char * lang_end = lang ? strchr ( lang , '-' ) : NULL ;\n"
                ],
                [
                    7,
                    " int lang_len = lang_end ? lang_end - lang : - 1 ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void data_destroy_arabic ( void * data ) {\n arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) data ;\n arabic_fallback_plan_destroy ( arabic_plan -> fallback_plan ) ;\n free ( data ) ;\n }",
        "hash": -6216181551924087864,
        "project": "chrome",
        "size": 5,
        "slice": {
            "free": [
                [
                    1,
                    "static void data_destroy_arabic ( void * data ) {\n"
                ],
                [
                    4,
                    " free ( data ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void data_destroy_arabic ( void * data ) {\n"
                ],
                [
                    4,
                    " free ( data ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void * data_create_arabic ( const hb_ot_shape_plan_t * plan ) {\n arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) calloc ( 1 , sizeof ( arabic_shape_plan_t ) ) ;\n if ( unlikely ( ! arabic_plan ) ) return NULL ;\n arabic_plan -> do_fallback = plan -> props . script == HB_SCRIPT_ARABIC ;\n for ( unsigned int i = 0 ;\n i < ARABIC_NUM_FEATURES ;\n i ++ ) {\n arabic_plan -> mask_array [ i ] = plan -> map . get_1_mask ( arabic_features [ i ] ) ;\n arabic_plan -> do_fallback = arabic_plan -> do_fallback && ( FEATURE_IS_SYRIAC ( arabic_features [ i ] ) || plan -> map . needs_fallback ( arabic_features [ i ] ) ) ;\n }\n return arabic_plan ;\n }",
        "hash": -6216181551924087864,
        "project": "chrome",
        "size": 12,
        "slice": {
            "calloc": [
                [
                    1,
                    "static void * data_create_arabic ( const hb_ot_shape_plan_t * plan ) {\n"
                ],
                [
                    2,
                    " arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) calloc ( 1 , sizeof ( arabic_shape_plan_t ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void * data_create_arabic ( const hb_ot_shape_plan_t * plan ) {\n"
                ],
                [
                    2,
                    " arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) calloc ( 1 , sizeof ( arabic_shape_plan_t ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "hb_shape_plan_t * hb_shape_plan_create ( hb_face_t * face , const hb_segment_properties_t * props , const hb_feature_t * user_features , unsigned int num_user_features , const char * const * shaper_list ) {\n DEBUG_MSG_FUNC ( SHAPE_PLAN , NULL , \"face=%p num_features=%d shaper_list=%p\" , face , num_user_features , shaper_list ) ;\n hb_shape_plan_t * shape_plan ;\n hb_feature_t * features = NULL ;\n if ( unlikely ( ! face ) ) face = hb_face_get_empty ( ) ;\n if ( unlikely ( ! props || hb_object_is_inert ( face ) ) ) return hb_shape_plan_get_empty ( ) ;\n if ( num_user_features && ! ( features = ( hb_feature_t * ) malloc ( num_user_features * sizeof ( hb_feature_t ) ) ) ) return hb_shape_plan_get_empty ( ) ;\n if ( ! ( shape_plan = hb_object_create < hb_shape_plan_t > ( ) ) ) {\n free ( features ) ;\n return hb_shape_plan_get_empty ( ) ;\n }\n assert ( props -> direction != HB_DIRECTION_INVALID ) ;\n hb_face_make_immutable ( face ) ;\n shape_plan -> default_shaper_list = shaper_list == NULL ;\n shape_plan -> face_unsafe = face ;\n shape_plan -> props = * props ;\n shape_plan -> num_user_features = num_user_features ;\n shape_plan -> user_features = features ;\n if ( num_user_features ) memcpy ( features , user_features , num_user_features * sizeof ( hb_feature_t ) ) ;\n hb_shape_plan_plan ( shape_plan , user_features , num_user_features , shaper_list ) ;\n return shape_plan ;\n }",
        "hash": 1667027354487746122,
        "project": "chrome",
        "size": 22,
        "slice": {
            "memcpy": [
                [
                    1,
                    "hb_shape_plan_t * hb_shape_plan_create ( hb_face_t * face , const hb_segment_properties_t * props , const hb_feature_t * user_features , unsigned int num_user_features , const char * const * shaper_list ) {\n"
                ],
                [
                    4,
                    " hb_feature_t * features = NULL ;\n"
                ],
                [
                    7,
                    " if ( num_user_features && ! ( features = ( hb_feature_t * ) malloc ( num_user_features * sizeof ( hb_feature_t ) ) ) ) return hb_shape_plan_get_empty ( ) ;\n"
                ],
                [
                    19,
                    " if ( num_user_features ) memcpy ( features , user_features , num_user_features * sizeof ( hb_feature_t ) ) ;\n"
                ],
                [
                    20,
                    " hb_shape_plan_plan ( shape_plan , user_features , num_user_features , shaper_list ) ;\n"
                ]
            ],
            "malloc": [
                [
                    6,
                    " if ( unlikely ( ! props || hb_object_is_inert ( face ) ) ) return hb_shape_plan_get_empty ( ) ;\n"
                ],
                [
                    7,
                    " if ( num_user_features && ! ( features = ( hb_feature_t * ) malloc ( num_user_features * sizeof ( hb_feature_t ) ) ) ) return hb_shape_plan_get_empty ( ) ;\n"
                ],
                [
                    9,
                    " free ( features ) ;\n"
                ],
                [
                    18,
                    " shape_plan -> user_features = features ;\n"
                ],
                [
                    19,
                    " if ( num_user_features ) memcpy ( features , user_features , num_user_features * sizeof ( hb_feature_t ) ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "hb_shape_plan_t * hb_shape_plan_create ( hb_face_t * face , const hb_segment_properties_t * props , const hb_feature_t * user_features , unsigned int num_user_features , const char * const * shaper_list ) {\n"
                ],
                [
                    4,
                    " hb_feature_t * features = NULL ;\n"
                ],
                [
                    7,
                    " if ( num_user_features && ! ( features = ( hb_feature_t * ) malloc ( num_user_features * sizeof ( hb_feature_t ) ) ) ) return hb_shape_plan_get_empty ( ) ;\n"
                ],
                [
                    8,
                    " if ( ! ( shape_plan = hb_object_create < hb_shape_plan_t > ( ) ) ) {\n"
                ],
                [
                    9,
                    " free ( features ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "hb_shape_plan_t * hb_shape_plan_create ( hb_face_t * face , const hb_segment_properties_t * props , const hb_feature_t * user_features , unsigned int num_user_features , const char * const * shaper_list ) {\n"
                ],
                [
                    4,
                    " hb_feature_t * features = NULL ;\n"
                ],
                [
                    6,
                    " if ( unlikely ( ! props || hb_object_is_inert ( face ) ) ) return hb_shape_plan_get_empty ( ) ;\n"
                ],
                [
                    7,
                    " if ( num_user_features && ! ( features = ( hb_feature_t * ) malloc ( num_user_features * sizeof ( hb_feature_t ) ) ) ) return hb_shape_plan_get_empty ( ) ;\n"
                ],
                [
                    8,
                    " if ( ! ( shape_plan = hb_object_create < hb_shape_plan_t > ( ) ) ) {\n"
                ],
                [
                    9,
                    " free ( features ) ;\n"
                ],
                [
                    18,
                    " shape_plan -> user_features = features ;\n"
                ],
                [
                    19,
                    " if ( num_user_features ) memcpy ( features , user_features , num_user_features * sizeof ( hb_feature_t ) ) ;\n"
                ],
                [
                    20,
                    " hb_shape_plan_plan ( shape_plan , user_features , num_user_features , shaper_list ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int sbr_mapping ( AACContext * ac , SpectralBandReplication * sbr , SBRData * ch_data , int e_a [ 2 ] ) {\n int e , i , m ;\n memset ( ch_data -> s_indexmapped [ 1 ] , 0 , 7 * sizeof ( ch_data -> s_indexmapped [ 1 ] ) ) ;\n for ( e = 0 ;\n e < ch_data -> bs_num_env ;\n e ++ ) {\n const unsigned int ilim = sbr -> n [ ch_data -> bs_freq_res [ e + 1 ] ] ;\n uint16_t * table = ch_data -> bs_freq_res [ e + 1 ] ? sbr -> f_tablehigh : sbr -> f_tablelow ;\n int k ;\n if ( sbr -> kx [ 1 ] != table [ 0 ] ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"kx != f_table{\nhigh,low}\n[0]. \" \"Derived frequency tables were not regenerated.\\n\" ) ;\n sbr_turnoff ( sbr ) ;\n return AVERROR_BUG ;\n }\n for ( i = 0 ;\n i < ilim ;\n i ++ ) for ( m = table [ i ] ;\n m < table [ i + 1 ] ;\n m ++ ) sbr -> e_origmapped [ e ] [ m - sbr -> kx [ 1 ] ] = ch_data -> env_facs [ e + 1 ] [ i ] ;\n k = ( ch_data -> bs_num_noise > 1 ) && ( ch_data -> t_env [ e ] >= ch_data -> t_q [ 1 ] ) ;\n for ( i = 0 ;\n i < sbr -> n_q ;\n i ++ ) for ( m = sbr -> f_tablenoise [ i ] ;\n m < sbr -> f_tablenoise [ i + 1 ] ;\n m ++ ) sbr -> q_mapped [ e ] [ m - sbr -> kx [ 1 ] ] = ch_data -> noise_facs [ k + 1 ] [ i ] ;\n for ( i = 0 ;\n i < sbr -> n [ 1 ] ;\n i ++ ) {\n if ( ch_data -> bs_add_harmonic_flag ) {\n const unsigned int m_midpoint = ( sbr -> f_tablehigh [ i ] + sbr -> f_tablehigh [ i + 1 ] ) >> 1 ;\n ch_data -> s_indexmapped [ e + 1 ] [ m_midpoint - sbr -> kx [ 1 ] ] = ch_data -> bs_add_harmonic [ i ] * ( e >= e_a [ 1 ] || ( ch_data -> s_indexmapped [ 0 ] [ m_midpoint - sbr -> kx [ 1 ] ] == 1 ) ) ;\n }\n }\n for ( i = 0 ;\n i < ilim ;\n i ++ ) {\n int additional_sinusoid_present = 0 ;\n for ( m = table [ i ] ;\n m < table [ i + 1 ] ;\n m ++ ) {\n if ( ch_data -> s_indexmapped [ e + 1 ] [ m - sbr -> kx [ 1 ] ] ) {\n additional_sinusoid_present = 1 ;\n break ;\n }\n }\n memset ( & sbr -> s_mapped [ e ] [ table [ i ] - sbr -> kx [ 1 ] ] , additional_sinusoid_present , ( table [ i + 1 ] - table [ i ] ) * sizeof ( sbr -> s_mapped [ e ] [ 0 ] ) ) ;\n }\n }\n memcpy ( ch_data -> s_indexmapped [ 0 ] , ch_data -> s_indexmapped [ ch_data -> bs_num_env ] , sizeof ( ch_data -> s_indexmapped [ 0 ] ) ) ;\n return 0 ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 53,
        "slice": {
            "memset": [
                [
                    1,
                    "static int sbr_mapping ( AACContext * ac , SpectralBandReplication * sbr , SBRData * ch_data , int e_a [ 2 ] ) {\n"
                ],
                [
                    3,
                    " memset ( ch_data -> s_indexmapped [ 1 ] , 0 , 7 * sizeof ( ch_data -> s_indexmapped [ 1 ] ) ) ;\n"
                ],
                [
                    37,
                    " i < ilim ;\n"
                ],
                [
                    39,
                    " int additional_sinusoid_present = 0 ;\n"
                ],
                [
                    44,
                    " additional_sinusoid_present = 1 ;\n"
                ],
                [
                    48,
                    " memset ( & sbr -> s_mapped [ e ] [ table [ i ] - sbr -> kx [ 1 ] ] , additional_sinusoid_present , ( table [ i + 1 ] - table [ i ] ) * sizeof ( sbr -> s_mapped [ e ] [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int sbr_mapping ( AACContext * ac , SpectralBandReplication * sbr , SBRData * ch_data , int e_a [ 2 ] ) {\n"
                ],
                [
                    3,
                    " memset ( ch_data -> s_indexmapped [ 1 ] , 0 , 7 * sizeof ( ch_data -> s_indexmapped [ 1 ] ) ) ;\n"
                ],
                [
                    37,
                    " i < ilim ;\n"
                ],
                [
                    39,
                    " int additional_sinusoid_present = 0 ;\n"
                ],
                [
                    44,
                    " additional_sinusoid_present = 1 ;\n"
                ],
                [
                    48,
                    " memset ( & sbr -> s_mapped [ e ] [ table [ i ] - sbr -> kx [ 1 ] ] , additional_sinusoid_present , ( table [ i + 1 ] - table [ i ] ) * sizeof ( sbr -> s_mapped [ e ] [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int read_sbr_channel_pair_element ( AACContext * ac , SpectralBandReplication * sbr , GetBitContext * gb ) {\n if ( get_bits1 ( gb ) ) skip_bits ( gb , 8 ) ;\n if ( ( sbr -> bs_coupling = get_bits1 ( gb ) ) ) {\n if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ) return - 1 ;\n copy_sbr_grid ( & sbr -> data [ 1 ] , & sbr -> data [ 0 ] ) ;\n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 0 ] ) ;\n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 1 ] ) ;\n read_sbr_invf ( sbr , gb , & sbr -> data [ 0 ] ) ;\n memcpy ( sbr -> data [ 1 ] . bs_invf_mode [ 1 ] , sbr -> data [ 1 ] . bs_invf_mode [ 0 ] , sizeof ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] ) ) ;\n memcpy ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] , sbr -> data [ 0 ] . bs_invf_mode [ 0 ] , sizeof ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] ) ) ;\n read_sbr_envelope ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;\n read_sbr_noise ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;\n read_sbr_envelope ( sbr , gb , & sbr -> data [ 1 ] , 1 ) ;\n read_sbr_noise ( sbr , gb , & sbr -> data [ 1 ] , 1 ) ;\n }\n else {\n if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) || read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 1 ] ) ) return - 1 ;\n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 0 ] ) ;\n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 1 ] ) ;\n read_sbr_invf ( sbr , gb , & sbr -> data [ 0 ] ) ;\n read_sbr_invf ( sbr , gb , & sbr -> data [ 1 ] ) ;\n read_sbr_envelope ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;\n read_sbr_envelope ( sbr , gb , & sbr -> data [ 1 ] , 1 ) ;\n read_sbr_noise ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;\n read_sbr_noise ( sbr , gb , & sbr -> data [ 1 ] , 1 ) ;\n }\n if ( ( sbr -> data [ 0 ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) get_bits1_vector ( gb , sbr -> data [ 0 ] . bs_add_harmonic , sbr -> n [ 1 ] ) ;\n if ( ( sbr -> data [ 1 ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) get_bits1_vector ( gb , sbr -> data [ 1 ] . bs_add_harmonic , sbr -> n [ 1 ] ) ;\n return 0 ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 30,
        "slice": {
            "memcpy": [
                [
                    4,
                    " if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ) return - 1 ;\n"
                ],
                [
                    9,
                    " memcpy ( sbr -> data [ 1 ] . bs_invf_mode [ 1 ] , sbr -> data [ 1 ] . bs_invf_mode [ 0 ] , sizeof ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] ) ) ;\n"
                ],
                [
                    10,
                    " memcpy ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] , sbr -> data [ 0 ] . bs_invf_mode [ 0 ] , sizeof ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    4,
                    " if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ) return - 1 ;\n"
                ],
                [
                    9,
                    " memcpy ( sbr -> data [ 1 ] . bs_invf_mode [ 1 ] , sbr -> data [ 1 ] . bs_invf_mode [ 0 ] , sizeof ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] ) ) ;\n"
                ],
                [
                    10,
                    " memcpy ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] , sbr -> data [ 0 ] . bs_invf_mode [ 0 ] , sizeof ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void read_sbr_envelope ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data , int ch ) {\n int bits ;\n int i , j , k ;\n VLC_TYPE ( * t_huff ) [ 2 ] , ( * f_huff ) [ 2 ] ;\n int t_lav , f_lav ;\n const int delta = ( ch == 1 && sbr -> bs_coupling == 1 ) + 1 ;\n const int odd = sbr -> n [ 1 ] & 1 ;\n if ( sbr -> bs_coupling && ch ) {\n if ( ch_data -> bs_amp_res ) {\n bits = 5 ;\n t_huff = vlc_sbr [ T_HUFFMAN_ENV_BAL_3_0DB ] . table ;\n t_lav = vlc_sbr_lav [ T_HUFFMAN_ENV_BAL_3_0DB ] ;\n f_huff = vlc_sbr [ F_HUFFMAN_ENV_BAL_3_0DB ] . table ;\n f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_BAL_3_0DB ] ;\n }\n else {\n bits = 6 ;\n t_huff = vlc_sbr [ T_HUFFMAN_ENV_BAL_1_5DB ] . table ;\n t_lav = vlc_sbr_lav [ T_HUFFMAN_ENV_BAL_1_5DB ] ;\n f_huff = vlc_sbr [ F_HUFFMAN_ENV_BAL_1_5DB ] . table ;\n f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_BAL_1_5DB ] ;\n }\n }\n else {\n if ( ch_data -> bs_amp_res ) {\n bits = 6 ;\n t_huff = vlc_sbr [ T_HUFFMAN_ENV_3_0DB ] . table ;\n t_lav = vlc_sbr_lav [ T_HUFFMAN_ENV_3_0DB ] ;\n f_huff = vlc_sbr [ F_HUFFMAN_ENV_3_0DB ] . table ;\n f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_3_0DB ] ;\n }\n else {\n bits = 7 ;\n t_huff = vlc_sbr [ T_HUFFMAN_ENV_1_5DB ] . table ;\n t_lav = vlc_sbr_lav [ T_HUFFMAN_ENV_1_5DB ] ;\n f_huff = vlc_sbr [ F_HUFFMAN_ENV_1_5DB ] . table ;\n f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_1_5DB ] ;\n }\n }\n for ( i = 0 ;\n i < ch_data -> bs_num_env ;\n i ++ ) {\n if ( ch_data -> bs_df_env [ i ] ) {\n if ( ch_data -> bs_freq_res [ i + 1 ] == ch_data -> bs_freq_res [ i ] ) {\n for ( j = 0 ;\n j < sbr -> n [ ch_data -> bs_freq_res [ i + 1 ] ] ;\n j ++ ) ch_data -> env_facs [ i + 1 ] [ j ] = ch_data -> env_facs [ i ] [ j ] + delta * ( get_vlc2 ( gb , t_huff , 9 , 3 ) - t_lav ) ;\n }\n else if ( ch_data -> bs_freq_res [ i + 1 ] ) {\n for ( j = 0 ;\n j < sbr -> n [ ch_data -> bs_freq_res [ i + 1 ] ] ;\n j ++ ) {\n k = ( j + odd ) >> 1 ;\n ch_data -> env_facs [ i + 1 ] [ j ] = ch_data -> env_facs [ i ] [ k ] + delta * ( get_vlc2 ( gb , t_huff , 9 , 3 ) - t_lav ) ;\n }\n }\n else {\n for ( j = 0 ;\n j < sbr -> n [ ch_data -> bs_freq_res [ i + 1 ] ] ;\n j ++ ) {\n k = j ? 2 * j - odd : 0 ;\n ch_data -> env_facs [ i + 1 ] [ j ] = ch_data -> env_facs [ i ] [ k ] + delta * ( get_vlc2 ( gb , t_huff , 9 , 3 ) - t_lav ) ;\n }\n }\n }\n else {\n ch_data -> env_facs [ i + 1 ] [ 0 ] = delta * get_bits ( gb , bits ) ;\n for ( j = 1 ;\n j < sbr -> n [ ch_data -> bs_freq_res [ i + 1 ] ] ;\n j ++ ) ch_data -> env_facs [ i + 1 ] [ j ] = ch_data -> env_facs [ i + 1 ] [ j - 1 ] + delta * ( get_vlc2 ( gb , f_huff , 9 , 3 ) - f_lav ) ;\n }\n }\n memcpy ( ch_data -> env_facs [ 0 ] , ch_data -> env_facs [ ch_data -> bs_num_env ] , sizeof ( ch_data -> env_facs [ 0 ] ) ) ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 74,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void read_sbr_envelope ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data , int ch ) {\n"
                ],
                [
                    73,
                    " memcpy ( ch_data -> env_facs [ 0 ] , ch_data -> env_facs [ ch_data -> bs_num_env ] , sizeof ( ch_data -> env_facs [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void read_sbr_envelope ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data , int ch ) {\n"
                ],
                [
                    73,
                    " memcpy ( ch_data -> env_facs [ 0 ] , ch_data -> env_facs [ ch_data -> bs_num_env ] , sizeof ( ch_data -> env_facs [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void ff_sbr_apply ( AACContext * ac , SpectralBandReplication * sbr , int id_aac , float * L , float * R ) {\n int downsampled = ac -> oc [ 1 ] . m4ac . ext_sample_rate < sbr -> sample_rate ;\n int ch ;\n int nch = ( id_aac == TYPE_CPE ) ? 2 : 1 ;\n int err ;\n if ( id_aac != sbr -> id_aac ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"element type mismatch %d != %d\\n\" , id_aac , sbr -> id_aac ) ;\n sbr_turnoff ( sbr ) ;\n }\n if ( ! sbr -> kx_and_m_pushed ) {\n sbr -> kx [ 0 ] = sbr -> kx [ 1 ] ;\n sbr -> m [ 0 ] = sbr -> m [ 1 ] ;\n }\n else {\n sbr -> kx_and_m_pushed = 0 ;\n }\n if ( sbr -> start ) {\n sbr_dequant ( sbr , id_aac ) ;\n }\n for ( ch = 0 ;\n ch < nch ;\n ch ++ ) {\n sbr_qmf_analysis ( ac -> fdsp , & sbr -> mdct_ana , & sbr -> dsp , ch ? R : L , sbr -> data [ ch ] . analysis_filterbank_samples , ( float * ) sbr -> qmf_filter_scratch , sbr -> data [ ch ] . W , sbr -> data [ ch ] . Ypos ) ;\n sbr -> c . sbr_lf_gen ( ac , sbr , sbr -> X_low , ( const float ( * ) [ 32 ] [ 32 ] [ 2 ] ) sbr -> data [ ch ] . W , sbr -> data [ ch ] . Ypos ) ;\n sbr -> data [ ch ] . Ypos ^= 1 ;\n if ( sbr -> start ) {\n sbr -> c . sbr_hf_inverse_filter ( & sbr -> dsp , sbr -> alpha0 , sbr -> alpha1 , ( const float ( * ) [ 40 ] [ 2 ] ) sbr -> X_low , sbr -> k [ 0 ] ) ;\n sbr_chirp ( sbr , & sbr -> data [ ch ] ) ;\n av_assert0 ( sbr -> data [ ch ] . bs_num_env > 0 ) ;\n sbr_hf_gen ( ac , sbr , sbr -> X_high , ( const float ( * ) [ 40 ] [ 2 ] ) sbr -> X_low , ( const float ( * ) [ 2 ] ) sbr -> alpha0 , ( const float ( * ) [ 2 ] ) sbr -> alpha1 , sbr -> data [ ch ] . bw_array , sbr -> data [ ch ] . t_env , sbr -> data [ ch ] . bs_num_env ) ;\n err = sbr_mapping ( ac , sbr , & sbr -> data [ ch ] , sbr -> data [ ch ] . e_a ) ;\n if ( ! err ) {\n sbr_env_estimate ( sbr -> e_curr , sbr -> X_high , sbr , & sbr -> data [ ch ] ) ;\n sbr_gain_calc ( ac , sbr , & sbr -> data [ ch ] , sbr -> data [ ch ] . e_a ) ;\n sbr -> c . sbr_hf_assemble ( sbr -> data [ ch ] . Y [ sbr -> data [ ch ] . Ypos ] , ( const float ( * ) [ 40 ] [ 2 ] ) sbr -> X_high , sbr , & sbr -> data [ ch ] , sbr -> data [ ch ] . e_a ) ;\n }\n }\n sbr -> c . sbr_x_gen ( sbr , sbr -> X [ ch ] , ( const float ( * ) [ 64 ] [ 2 ] ) sbr -> data [ ch ] . Y [ 1 - sbr -> data [ ch ] . Ypos ] , ( const float ( * ) [ 64 ] [ 2 ] ) sbr -> data [ ch ] . Y [ sbr -> data [ ch ] . Ypos ] , ( const float ( * ) [ 40 ] [ 2 ] ) sbr -> X_low , ch ) ;\n }\n if ( ac -> oc [ 1 ] . m4ac . ps == 1 ) {\n if ( sbr -> ps . start ) {\n ff_ps_apply ( ac -> avctx , & sbr -> ps , sbr -> X [ 0 ] , sbr -> X [ 1 ] , sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) ;\n }\n else {\n memcpy ( sbr -> X [ 1 ] , sbr -> X [ 0 ] , sizeof ( sbr -> X [ 0 ] ) ) ;\n }\n nch = 2 ;\n }\n sbr_qmf_synthesis ( & sbr -> mdct , & sbr -> dsp , ac -> fdsp , L , sbr -> X [ 0 ] , sbr -> qmf_filter_scratch , sbr -> data [ 0 ] . synthesis_filterbank_samples , & sbr -> data [ 0 ] . synthesis_filterbank_samples_offset , downsampled ) ;\n if ( nch == 2 ) sbr_qmf_synthesis ( & sbr -> mdct , & sbr -> dsp , ac -> fdsp , R , sbr -> X [ 1 ] , sbr -> qmf_filter_scratch , sbr -> data [ 1 ] . synthesis_filterbank_samples , & sbr -> data [ 1 ] . synthesis_filterbank_samples_offset , downsampled ) ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 51,
        "slice": {
            "memcpy": [
                [
                    1,
                    "void ff_sbr_apply ( AACContext * ac , SpectralBandReplication * sbr , int id_aac , float * L , float * R ) {\n"
                ],
                [
                    41,
                    " if ( sbr -> ps . start ) {\n"
                ],
                [
                    45,
                    " memcpy ( sbr -> X [ 1 ] , sbr -> X [ 0 ] , sizeof ( sbr -> X [ 0 ] ) ) ;\n"
                ],
                [
                    49,
                    " sbr_qmf_synthesis ( & sbr -> mdct , & sbr -> dsp , ac -> fdsp , L , sbr -> X [ 0 ] , sbr -> qmf_filter_scratch , sbr -> data [ 0 ] . synthesis_filterbank_samples , & sbr -> data [ 0 ] . synthesis_filterbank_samples_offset , downsampled ) ;\n"
                ],
                [
                    50,
                    " if ( nch == 2 ) sbr_qmf_synthesis ( & sbr -> mdct , & sbr -> dsp , ac -> fdsp , R , sbr -> X [ 1 ] , sbr -> qmf_filter_scratch , sbr -> data [ 1 ] . synthesis_filterbank_samples , & sbr -> data [ 1 ] . synthesis_filterbank_samples_offset , downsampled ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void ff_sbr_apply ( AACContext * ac , SpectralBandReplication * sbr , int id_aac , float * L , float * R ) {\n"
                ],
                [
                    41,
                    " if ( sbr -> ps . start ) {\n"
                ],
                [
                    45,
                    " memcpy ( sbr -> X [ 1 ] , sbr -> X [ 0 ] , sizeof ( sbr -> X [ 0 ] ) ) ;\n"
                ],
                [
                    49,
                    " sbr_qmf_synthesis ( & sbr -> mdct , & sbr -> dsp , ac -> fdsp , L , sbr -> X [ 0 ] , sbr -> qmf_filter_scratch , sbr -> data [ 0 ] . synthesis_filterbank_samples , & sbr -> data [ 0 ] . synthesis_filterbank_samples_offset , downsampled ) ;\n"
                ],
                [
                    50,
                    " if ( nch == 2 ) sbr_qmf_synthesis ( & sbr -> mdct , & sbr -> dsp , ac -> fdsp , R , sbr -> X [ 1 ] , sbr -> qmf_filter_scratch , sbr -> data [ 1 ] . synthesis_filterbank_samples , & sbr -> data [ 1 ] . synthesis_filterbank_samples_offset , downsampled ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int sbr_hf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_high [ 64 ] [ 40 ] [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , const float ( * alpha0 ) [ 2 ] , const float ( * alpha1 ) [ 2 ] , const float bw_array [ 5 ] , const uint8_t * t_env , int bs_num_env ) {\n int j , x ;\n int g = 0 ;\n int k = sbr -> kx [ 1 ] ;\n for ( j = 0 ;\n j < sbr -> num_patches ;\n j ++ ) {\n for ( x = 0 ;\n x < sbr -> patch_num_subbands [ j ] ;\n x ++ , k ++ ) {\n const int p = sbr -> patch_start_subband [ j ] + x ;\n while ( g <= sbr -> n_q && k >= sbr -> f_tablenoise [ g ] ) g ++ ;\n g -- ;\n if ( g < 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"ERROR : no subband found for frequency %d\\n\" , k ) ;\n return - 1 ;\n }\n sbr -> dsp . hf_gen ( X_high [ k ] + ENVELOPE_ADJUSTMENT_OFFSET , X_low [ p ] + ENVELOPE_ADJUSTMENT_OFFSET , alpha0 [ p ] , alpha1 [ p ] , bw_array [ g ] , * t_env [ 0 ] , 2 * t_env [ bs_num_env ] ) ;\n }\n }\n if ( k < sbr -> m [ 1 ] + sbr -> kx [ 1 ] ) memset ( X_high + k , 0 , ( sbr -> m [ 1 ] + sbr -> kx [ 1 ] - k ) * sizeof ( * X_high ) ) ;\n return 0 ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 23,
        "slice": {
            "memset": [
                [
                    1,
                    "static int sbr_hf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_high [ 64 ] [ 40 ] [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , const float ( * alpha0 ) [ 2 ] , const float ( * alpha1 ) [ 2 ] , const float bw_array [ 5 ] , const uint8_t * t_env , int bs_num_env ) {\n"
                ],
                [
                    21,
                    " if ( k < sbr -> m [ 1 ] + sbr -> kx [ 1 ] ) memset ( X_high + k , 0 , ( sbr -> m [ 1 ] + sbr -> kx [ 1 ] - k ) * sizeof ( * X_high ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int sbr_hf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_high [ 64 ] [ 40 ] [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , const float ( * alpha0 ) [ 2 ] , const float ( * alpha1 ) [ 2 ] , const float bw_array [ 5 ] , const uint8_t * t_env , int bs_num_env ) {\n"
                ],
                [
                    21,
                    " if ( k < sbr -> m [ 1 ] + sbr -> kx [ 1 ] ) memset ( X_high + k , 0 , ( sbr -> m [ 1 ] + sbr -> kx [ 1 ] - k ) * sizeof ( * X_high ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void sbr_turnoff ( SpectralBandReplication * sbr ) {\n sbr -> start = 0 ;\n sbr -> kx [ 1 ] = 32 ;\n sbr -> m [ 1 ] = 0 ;\n sbr -> data [ 0 ] . e_a [ 1 ] = sbr -> data [ 1 ] . e_a [ 1 ] = - 1 ;\n memset ( & sbr -> spectrum_params , - 1 , sizeof ( SpectrumParameters ) ) ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 7,
        "slice": {
            "memset": [
                [
                    1,
                    "static void sbr_turnoff ( SpectralBandReplication * sbr ) {\n"
                ],
                [
                    6,
                    " memset ( & sbr -> spectrum_params , - 1 , sizeof ( SpectrumParameters ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void sbr_turnoff ( SpectralBandReplication * sbr ) {\n"
                ],
                [
                    6,
                    " memset ( & sbr -> spectrum_params , - 1 , sizeof ( SpectrumParameters ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void read_sbr_noise ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data , int ch ) {\n int i , j ;\n VLC_TYPE ( * t_huff ) [ 2 ] , ( * f_huff ) [ 2 ] ;\n int t_lav , f_lav ;\n int delta = ( ch == 1 && sbr -> bs_coupling == 1 ) + 1 ;\n if ( sbr -> bs_coupling && ch ) {\n t_huff = vlc_sbr [ T_HUFFMAN_NOISE_BAL_3_0DB ] . table ;\n t_lav = vlc_sbr_lav [ T_HUFFMAN_NOISE_BAL_3_0DB ] ;\n f_huff = vlc_sbr [ F_HUFFMAN_ENV_BAL_3_0DB ] . table ;\n f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_BAL_3_0DB ] ;\n }\n else {\n t_huff = vlc_sbr [ T_HUFFMAN_NOISE_3_0DB ] . table ;\n t_lav = vlc_sbr_lav [ T_HUFFMAN_NOISE_3_0DB ] ;\n f_huff = vlc_sbr [ F_HUFFMAN_ENV_3_0DB ] . table ;\n f_lav = vlc_sbr_lav [ F_HUFFMAN_ENV_3_0DB ] ;\n }\n for ( i = 0 ;\n i < ch_data -> bs_num_noise ;\n i ++ ) {\n if ( ch_data -> bs_df_noise [ i ] ) {\n for ( j = 0 ;\n j < sbr -> n_q ;\n j ++ ) ch_data -> noise_facs [ i + 1 ] [ j ] = ch_data -> noise_facs [ i ] [ j ] + delta * ( get_vlc2 ( gb , t_huff , 9 , 2 ) - t_lav ) ;\n }\n else {\n ch_data -> noise_facs [ i + 1 ] [ 0 ] = delta * get_bits ( gb , 5 ) ;\n for ( j = 1 ;\n j < sbr -> n_q ;\n j ++ ) ch_data -> noise_facs [ i + 1 ] [ j ] = ch_data -> noise_facs [ i + 1 ] [ j - 1 ] + delta * ( get_vlc2 ( gb , f_huff , 9 , 3 ) - f_lav ) ;\n }\n }\n memcpy ( ch_data -> noise_facs [ 0 ] , ch_data -> noise_facs [ ch_data -> bs_num_noise ] , sizeof ( ch_data -> noise_facs [ 0 ] ) ) ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 34,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void read_sbr_noise ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data , int ch ) {\n"
                ],
                [
                    33,
                    " memcpy ( ch_data -> noise_facs [ 0 ] , ch_data -> noise_facs [ ch_data -> bs_num_noise ] , sizeof ( ch_data -> noise_facs [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void read_sbr_noise ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data , int ch ) {\n"
                ],
                [
                    33,
                    " memcpy ( ch_data -> noise_facs [ 0 ] , ch_data -> noise_facs [ ch_data -> bs_num_noise ] , sizeof ( ch_data -> noise_facs [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int sbr_make_f_master ( AACContext * ac , SpectralBandReplication * sbr , SpectrumParameters * spectrum ) {\n unsigned int temp , max_qmf_subbands = 0 ;\n unsigned int start_min , stop_min ;\n int k ;\n const int8_t * sbr_offset_ptr ;\n int16_t stop_dk [ 13 ] ;\n if ( sbr -> sample_rate < 32000 ) {\n temp = 3000 ;\n }\n else if ( sbr -> sample_rate < 64000 ) {\n temp = 4000 ;\n }\n else temp = 5000 ;\n switch ( sbr -> sample_rate ) {\n case 16000 : sbr_offset_ptr = sbr_offset [ 0 ] ;\n break ;\n case 22050 : sbr_offset_ptr = sbr_offset [ 1 ] ;\n break ;\n case 24000 : sbr_offset_ptr = sbr_offset [ 2 ] ;\n break ;\n case 32000 : sbr_offset_ptr = sbr_offset [ 3 ] ;\n break ;\n case 44100 : case 48000 : case 64000 : sbr_offset_ptr = sbr_offset [ 4 ] ;\n break ;\n case 88200 : case 96000 : case 128000 : case 176400 : case 192000 : sbr_offset_ptr = sbr_offset [ 5 ] ;\n break ;\n default : av_log ( ac -> avctx , AV_LOG_ERROR , \"Unsupported sample rate for SBR: %d\\n\" , sbr -> sample_rate ) ;\n return - 1 ;\n }\n start_min = ( ( temp << 7 ) + ( sbr -> sample_rate >> 1 ) ) / sbr -> sample_rate ;\n stop_min = ( ( temp << 8 ) + ( sbr -> sample_rate >> 1 ) ) / sbr -> sample_rate ;\n sbr -> k [ 0 ] = start_min + sbr_offset_ptr [ spectrum -> bs_start_freq ] ;\n if ( spectrum -> bs_stop_freq < 14 ) {\n sbr -> k [ 2 ] = stop_min ;\n make_bands ( stop_dk , stop_min , 64 , 13 ) ;\n qsort ( stop_dk , 13 , sizeof ( stop_dk [ 0 ] ) , qsort_comparison_function_int16 ) ;\n for ( k = 0 ;\n k < spectrum -> bs_stop_freq ;\n k ++ ) sbr -> k [ 2 ] += stop_dk [ k ] ;\n }\n else if ( spectrum -> bs_stop_freq == 14 ) {\n sbr -> k [ 2 ] = 2 * sbr -> k [ 0 ] ;\n }\n else if ( spectrum -> bs_stop_freq == 15 ) {\n sbr -> k [ 2 ] = 3 * sbr -> k [ 0 ] ;\n }\n else {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid bs_stop_freq: %d\\n\" , spectrum -> bs_stop_freq ) ;\n return - 1 ;\n }\n sbr -> k [ 2 ] = FFMIN ( 64 , sbr -> k [ 2 ] ) ;\n if ( sbr -> sample_rate <= 32000 ) {\n max_qmf_subbands = 48 ;\n }\n else if ( sbr -> sample_rate == 44100 ) {\n max_qmf_subbands = 35 ;\n }\n else if ( sbr -> sample_rate >= 48000 ) max_qmf_subbands = 32 ;\n else av_assert0 ( 0 ) ;\n if ( sbr -> k [ 2 ] - sbr -> k [ 0 ] > max_qmf_subbands ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid bitstream, too many QMF subbands: %d\\n\" , sbr -> k [ 2 ] - sbr -> k [ 0 ] ) ;\n return - 1 ;\n }\n if ( ! spectrum -> bs_freq_scale ) {\n int dk , k2diff ;\n dk = spectrum -> bs_alter_scale + 1 ;\n sbr -> n_master = ( ( sbr -> k [ 2 ] - sbr -> k [ 0 ] + ( dk & 2 ) ) >> dk ) << 1 ;\n if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n for ( k = 1 ;\n k <= sbr -> n_master ;\n k ++ ) sbr -> f_master [ k ] = dk ;\n k2diff = sbr -> k [ 2 ] - sbr -> k [ 0 ] - sbr -> n_master * dk ;\n if ( k2diff < 0 ) {\n sbr -> f_master [ 1 ] -- ;\n sbr -> f_master [ 2 ] -= ( k2diff < - 1 ) ;\n }\n else if ( k2diff ) {\n sbr -> f_master [ sbr -> n_master ] ++ ;\n }\n sbr -> f_master [ 0 ] = sbr -> k [ 0 ] ;\n for ( k = 1 ;\n k <= sbr -> n_master ;\n k ++ ) sbr -> f_master [ k ] += sbr -> f_master [ k - 1 ] ;\n }\n else {\n int half_bands = 7 - spectrum -> bs_freq_scale ;\n int two_regions , num_bands_0 ;\n int vdk0_max , vdk1_min ;\n int16_t vk0 [ 49 ] ;\n if ( 49 * sbr -> k [ 2 ] > 110 * sbr -> k [ 0 ] ) {\n two_regions = 1 ;\n sbr -> k [ 1 ] = 2 * sbr -> k [ 0 ] ;\n }\n else {\n two_regions = 0 ;\n sbr -> k [ 1 ] = sbr -> k [ 2 ] ;\n }\n num_bands_0 = lrintf ( half_bands * log2f ( sbr -> k [ 1 ] / ( float ) sbr -> k [ 0 ] ) ) * 2 ;\n if ( num_bands_0 <= 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid num_bands_0: %d\\n\" , num_bands_0 ) ;\n return - 1 ;\n }\n vk0 [ 0 ] = 0 ;\n make_bands ( vk0 + 1 , sbr -> k [ 0 ] , sbr -> k [ 1 ] , num_bands_0 ) ;\n qsort ( vk0 + 1 , num_bands_0 , sizeof ( vk0 [ 1 ] ) , qsort_comparison_function_int16 ) ;\n vdk0_max = vk0 [ num_bands_0 ] ;\n vk0 [ 0 ] = sbr -> k [ 0 ] ;\n for ( k = 1 ;\n k <= num_bands_0 ;\n k ++ ) {\n if ( vk0 [ k ] <= 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid vDk0[%d]: %d\\n\" , k , vk0 [ k ] ) ;\n return - 1 ;\n }\n vk0 [ k ] += vk0 [ k - 1 ] ;\n }\n if ( two_regions ) {\n int16_t vk1 [ 49 ] ;\n float invwarp = spectrum -> bs_alter_scale ? 0.76923076923076923077f : 1.0f ;\n int num_bands_1 = lrintf ( half_bands * invwarp * log2f ( sbr -> k [ 2 ] / ( float ) sbr -> k [ 1 ] ) ) * 2 ;\n make_bands ( vk1 + 1 , sbr -> k [ 1 ] , sbr -> k [ 2 ] , num_bands_1 ) ;\n vdk1_min = array_min_int16 ( vk1 + 1 , num_bands_1 ) ;\n if ( vdk1_min < vdk0_max ) {\n int change ;\n qsort ( vk1 + 1 , num_bands_1 , sizeof ( vk1 [ 1 ] ) , qsort_comparison_function_int16 ) ;\n change = FFMIN ( vdk0_max - vk1 [ 1 ] , ( vk1 [ num_bands_1 ] - vk1 [ 1 ] ) >> 1 ) ;\n vk1 [ 1 ] += change ;\n vk1 [ num_bands_1 ] -= change ;\n }\n qsort ( vk1 + 1 , num_bands_1 , sizeof ( vk1 [ 1 ] ) , qsort_comparison_function_int16 ) ;\n vk1 [ 0 ] = sbr -> k [ 1 ] ;\n for ( k = 1 ;\n k <= num_bands_1 ;\n k ++ ) {\n if ( vk1 [ k ] <= 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Invalid vDk1[%d]: %d\\n\" , k , vk1 [ k ] ) ;\n return - 1 ;\n }\n vk1 [ k ] += vk1 [ k - 1 ] ;\n }\n sbr -> n_master = num_bands_0 + num_bands_1 ;\n if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n memcpy ( & sbr -> f_master [ 0 ] , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n memcpy ( & sbr -> f_master [ num_bands_0 + 1 ] , vk1 + 1 , num_bands_1 * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n }\n else {\n sbr -> n_master = num_bands_0 ;\n if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n memcpy ( sbr -> f_master , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n }\n }\n return 0 ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 153,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int sbr_make_f_master ( AACContext * ac , SpectralBandReplication * sbr , SpectrumParameters * spectrum ) {\n"
                ],
                [
                    89,
                    " int16_t vk0 [ 49 ] ;\n"
                ],
                [
                    103,
                    " vk0 [ 0 ] = 0 ;\n"
                ],
                [
                    107,
                    " vk0 [ 0 ] = sbr -> k [ 0 ] ;\n"
                ],
                [
                    115,
                    " vk0 [ k ] += vk0 [ k - 1 ] ;\n"
                ],
                [
                    118,
                    " int16_t vk1 [ 49 ] ;\n"
                ],
                [
                    127,
                    " vk1 [ 1 ] += change ;\n"
                ],
                [
                    128,
                    " vk1 [ num_bands_1 ] -= change ;\n"
                ],
                [
                    131,
                    " vk1 [ 0 ] = sbr -> k [ 1 ] ;\n"
                ],
                [
                    139,
                    " vk1 [ k ] += vk1 [ k - 1 ] ;\n"
                ],
                [
                    142,
                    " if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n"
                ],
                [
                    143,
                    " memcpy ( & sbr -> f_master [ 0 ] , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n"
                ],
                [
                    144,
                    " memcpy ( & sbr -> f_master [ num_bands_0 + 1 ] , vk1 + 1 , num_bands_1 * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n"
                ],
                [
                    148,
                    " if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n"
                ],
                [
                    149,
                    " memcpy ( sbr -> f_master , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int sbr_make_f_master ( AACContext * ac , SpectralBandReplication * sbr , SpectrumParameters * spectrum ) {\n"
                ],
                [
                    89,
                    " int16_t vk0 [ 49 ] ;\n"
                ],
                [
                    103,
                    " vk0 [ 0 ] = 0 ;\n"
                ],
                [
                    107,
                    " vk0 [ 0 ] = sbr -> k [ 0 ] ;\n"
                ],
                [
                    115,
                    " vk0 [ k ] += vk0 [ k - 1 ] ;\n"
                ],
                [
                    118,
                    " int16_t vk1 [ 49 ] ;\n"
                ],
                [
                    127,
                    " vk1 [ 1 ] += change ;\n"
                ],
                [
                    128,
                    " vk1 [ num_bands_1 ] -= change ;\n"
                ],
                [
                    131,
                    " vk1 [ 0 ] = sbr -> k [ 1 ] ;\n"
                ],
                [
                    139,
                    " vk1 [ k ] += vk1 [ k - 1 ] ;\n"
                ],
                [
                    142,
                    " if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n"
                ],
                [
                    143,
                    " memcpy ( & sbr -> f_master [ 0 ] , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n"
                ],
                [
                    144,
                    " memcpy ( & sbr -> f_master [ num_bands_0 + 1 ] , vk1 + 1 , num_bands_1 * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n"
                ],
                [
                    148,
                    " if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n"
                ],
                [
                    149,
                    " memcpy ( sbr -> f_master , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static unsigned int read_sbr_header ( SpectralBandReplication * sbr , GetBitContext * gb ) {\n unsigned int cnt = get_bits_count ( gb ) ;\n uint8_t bs_header_extra_1 ;\n uint8_t bs_header_extra_2 ;\n int old_bs_limiter_bands = sbr -> bs_limiter_bands ;\n SpectrumParameters old_spectrum_params ;\n sbr -> start = 1 ;\n memcpy ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ;\n sbr -> bs_amp_res_header = get_bits1 ( gb ) ;\n sbr -> spectrum_params . bs_start_freq = get_bits ( gb , 4 ) ;\n sbr -> spectrum_params . bs_stop_freq = get_bits ( gb , 4 ) ;\n sbr -> spectrum_params . bs_xover_band = get_bits ( gb , 3 ) ;\n skip_bits ( gb , 2 ) ;\n bs_header_extra_1 = get_bits1 ( gb ) ;\n bs_header_extra_2 = get_bits1 ( gb ) ;\n if ( bs_header_extra_1 ) {\n sbr -> spectrum_params . bs_freq_scale = get_bits ( gb , 2 ) ;\n sbr -> spectrum_params . bs_alter_scale = get_bits1 ( gb ) ;\n sbr -> spectrum_params . bs_noise_bands = get_bits ( gb , 2 ) ;\n }\n else {\n sbr -> spectrum_params . bs_freq_scale = 2 ;\n sbr -> spectrum_params . bs_alter_scale = 1 ;\n sbr -> spectrum_params . bs_noise_bands = 2 ;\n }\n if ( memcmp ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ) sbr -> reset = 1 ;\n if ( bs_header_extra_2 ) {\n sbr -> bs_limiter_bands = get_bits ( gb , 2 ) ;\n sbr -> bs_limiter_gains = get_bits ( gb , 2 ) ;\n sbr -> bs_interpol_freq = get_bits1 ( gb ) ;\n sbr -> bs_smoothing_mode = get_bits1 ( gb ) ;\n }\n else {\n sbr -> bs_limiter_bands = 2 ;\n sbr -> bs_limiter_gains = 2 ;\n sbr -> bs_interpol_freq = 1 ;\n sbr -> bs_smoothing_mode = 1 ;\n }\n if ( sbr -> bs_limiter_bands != old_bs_limiter_bands && ! sbr -> reset ) sbr_make_f_tablelim ( sbr ) ;\n return get_bits_count ( gb ) - cnt ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 41,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static unsigned int read_sbr_header ( SpectralBandReplication * sbr , GetBitContext * gb ) {\n"
                ],
                [
                    8,
                    " memcpy ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ;\n"
                ],
                [
                    26,
                    " if ( memcmp ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ) sbr -> reset = 1 ;\n"
                ],
                [
                    39,
                    " if ( sbr -> bs_limiter_bands != old_bs_limiter_bands && ! sbr -> reset ) sbr_make_f_tablelim ( sbr ) ;\n"
                ]
            ],
            "memcmp": [
                [
                    1,
                    "static unsigned int read_sbr_header ( SpectralBandReplication * sbr , GetBitContext * gb ) {\n"
                ],
                [
                    8,
                    " memcpy ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ;\n"
                ],
                [
                    10,
                    " sbr -> spectrum_params . bs_start_freq = get_bits ( gb , 4 ) ;\n"
                ],
                [
                    11,
                    " sbr -> spectrum_params . bs_stop_freq = get_bits ( gb , 4 ) ;\n"
                ],
                [
                    12,
                    " sbr -> spectrum_params . bs_xover_band = get_bits ( gb , 3 ) ;\n"
                ],
                [
                    17,
                    " sbr -> spectrum_params . bs_freq_scale = get_bits ( gb , 2 ) ;\n"
                ],
                [
                    18,
                    " sbr -> spectrum_params . bs_alter_scale = get_bits1 ( gb ) ;\n"
                ],
                [
                    19,
                    " sbr -> spectrum_params . bs_noise_bands = get_bits ( gb , 2 ) ;\n"
                ],
                [
                    22,
                    " sbr -> spectrum_params . bs_freq_scale = 2 ;\n"
                ],
                [
                    23,
                    " sbr -> spectrum_params . bs_alter_scale = 1 ;\n"
                ],
                [
                    24,
                    " sbr -> spectrum_params . bs_noise_bands = 2 ;\n"
                ],
                [
                    26,
                    " if ( memcmp ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ) sbr -> reset = 1 ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static unsigned int read_sbr_header ( SpectralBandReplication * sbr , GetBitContext * gb ) {\n"
                ],
                [
                    8,
                    " memcpy ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ;\n"
                ],
                [
                    10,
                    " sbr -> spectrum_params . bs_start_freq = get_bits ( gb , 4 ) ;\n"
                ],
                [
                    11,
                    " sbr -> spectrum_params . bs_stop_freq = get_bits ( gb , 4 ) ;\n"
                ],
                [
                    12,
                    " sbr -> spectrum_params . bs_xover_band = get_bits ( gb , 3 ) ;\n"
                ],
                [
                    17,
                    " sbr -> spectrum_params . bs_freq_scale = get_bits ( gb , 2 ) ;\n"
                ],
                [
                    18,
                    " sbr -> spectrum_params . bs_alter_scale = get_bits1 ( gb ) ;\n"
                ],
                [
                    19,
                    " sbr -> spectrum_params . bs_noise_bands = get_bits ( gb , 2 ) ;\n"
                ],
                [
                    22,
                    " sbr -> spectrum_params . bs_freq_scale = 2 ;\n"
                ],
                [
                    23,
                    " sbr -> spectrum_params . bs_alter_scale = 1 ;\n"
                ],
                [
                    24,
                    " sbr -> spectrum_params . bs_noise_bands = 2 ;\n"
                ],
                [
                    26,
                    " if ( memcmp ( & old_spectrum_params , & sbr -> spectrum_params , sizeof ( SpectrumParameters ) ) ) sbr -> reset = 1 ;\n"
                ],
                [
                    39,
                    " if ( sbr -> bs_limiter_bands != old_bs_limiter_bands && ! sbr -> reset ) sbr_make_f_tablelim ( sbr ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int sbr_x_gen ( SpectralBandReplication * sbr , float X [ 2 ] [ 38 ] [ 64 ] , const float Y0 [ 38 ] [ 64 ] [ 2 ] , const float Y1 [ 38 ] [ 64 ] [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , int ch ) {\n int k , i ;\n const int i_f = 32 ;\n const int i_Temp = FFMAX ( 2 * sbr -> data [ ch ] . t_env_num_env_old - i_f , 0 ) ;\n memset ( X , 0 , 2 * sizeof ( * X ) ) ;\n for ( k = 0 ;\n k < sbr -> kx [ 0 ] ;\n k ++ ) {\n for ( i = 0 ;\n i < i_Temp ;\n i ++ ) {\n X [ 0 ] [ i ] [ k ] = X_low [ k ] [ i + ENVELOPE_ADJUSTMENT_OFFSET ] [ 0 ] ;\n X [ 1 ] [ i ] [ k ] = X_low [ k ] [ i + ENVELOPE_ADJUSTMENT_OFFSET ] [ 1 ] ;\n }\n }\n for ( ;\n k < sbr -> kx [ 0 ] + sbr -> m [ 0 ] ;\n k ++ ) {\n for ( i = 0 ;\n i < i_Temp ;\n i ++ ) {\n X [ 0 ] [ i ] [ k ] = Y0 [ i + i_f ] [ k ] [ 0 ] ;\n X [ 1 ] [ i ] [ k ] = Y0 [ i + i_f ] [ k ] [ 1 ] ;\n }\n }\n for ( k = 0 ;\n k < sbr -> kx [ 1 ] ;\n k ++ ) {\n for ( i = i_Temp ;\n i < 38 ;\n i ++ ) {\n X [ 0 ] [ i ] [ k ] = X_low [ k ] [ i + ENVELOPE_ADJUSTMENT_OFFSET ] [ 0 ] ;\n X [ 1 ] [ i ] [ k ] = X_low [ k ] [ i + ENVELOPE_ADJUSTMENT_OFFSET ] [ 1 ] ;\n }\n }\n for ( ;\n k < sbr -> kx [ 1 ] + sbr -> m [ 1 ] ;\n k ++ ) {\n for ( i = i_Temp ;\n i < i_f ;\n i ++ ) {\n X [ 0 ] [ i ] [ k ] = Y1 [ i ] [ k ] [ 0 ] ;\n X [ 1 ] [ i ] [ k ] = Y1 [ i ] [ k ] [ 1 ] ;\n }\n }\n return 0 ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 47,
        "slice": {
            "memset": [
                [
                    1,
                    "static int sbr_x_gen ( SpectralBandReplication * sbr , float X [ 2 ] [ 38 ] [ 64 ] , const float Y0 [ 38 ] [ 64 ] [ 2 ] , const float Y1 [ 38 ] [ 64 ] [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , int ch ) {\n"
                ],
                [
                    5,
                    " memset ( X , 0 , 2 * sizeof ( * X ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int sbr_x_gen ( SpectralBandReplication * sbr , float X [ 2 ] [ 38 ] [ 64 ] , const float Y0 [ 38 ] [ 64 ] [ 2 ] , const float Y1 [ 38 ] [ 64 ] [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , int ch ) {\n"
                ],
                [
                    5,
                    " memset ( X , 0 , 2 * sizeof ( * X ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void read_sbr_invf ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data ) {\n int i ;\n memcpy ( ch_data -> bs_invf_mode [ 1 ] , ch_data -> bs_invf_mode [ 0 ] , 5 * sizeof ( uint8_t ) ) ;\n for ( i = 0 ;\n i < sbr -> n_q ;\n i ++ ) ch_data -> bs_invf_mode [ 0 ] [ i ] = get_bits ( gb , 2 ) ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 7,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void read_sbr_invf ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data ) {\n"
                ],
                [
                    3,
                    " memcpy ( ch_data -> bs_invf_mode [ 1 ] , ch_data -> bs_invf_mode [ 0 ] , 5 * sizeof ( uint8_t ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void read_sbr_invf ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data ) {\n"
                ],
                [
                    3,
                    " memcpy ( ch_data -> bs_invf_mode [ 1 ] , ch_data -> bs_invf_mode [ 0 ] , 5 * sizeof ( uint8_t ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void sbr_qmf_synthesis ( FFTContext * mdct , SBRDSPContext * sbrdsp , AVFloatDSPContext * dsp , float * out , float X [ 2 ] [ 38 ] [ 64 ] , float mdct_buf [ 2 ] [ 64 ] , float * v0 , int * v_off , const unsigned int div ) {\n int i , n ;\n const float * sbr_qmf_window = div ? sbr_qmf_window_ds : sbr_qmf_window_us ;\n const int step = 128 >> div ;\n float * v ;\n for ( i = 0 ;\n i < 32 ;\n i ++ ) {\n if ( * v_off < step ) {\n int saved_samples = ( 1280 - 128 ) >> div ;\n memcpy ( & v0 [ SBR_SYNTHESIS_BUF_SIZE - saved_samples ] , v0 , saved_samples * sizeof ( float ) ) ;\n * v_off = SBR_SYNTHESIS_BUF_SIZE - saved_samples - step ;\n }\n else {\n * v_off -= step ;\n }\n v = v0 + * v_off ;\n if ( div ) {\n for ( n = 0 ;\n n < 32 ;\n n ++ ) {\n X [ 0 ] [ i ] [ n ] = - X [ 0 ] [ i ] [ n ] ;\n X [ 0 ] [ i ] [ 32 + n ] = X [ 1 ] [ i ] [ 31 - n ] ;\n }\n mdct -> imdct_half ( mdct , mdct_buf [ 0 ] , X [ 0 ] [ i ] ) ;\n sbrdsp -> qmf_deint_neg ( v , mdct_buf [ 0 ] ) ;\n }\n else {\n sbrdsp -> neg_odd_64 ( X [ 1 ] [ i ] ) ;\n mdct -> imdct_half ( mdct , mdct_buf [ 0 ] , X [ 0 ] [ i ] ) ;\n mdct -> imdct_half ( mdct , mdct_buf [ 1 ] , X [ 1 ] [ i ] ) ;\n sbrdsp -> qmf_deint_bfly ( v , mdct_buf [ 1 ] , mdct_buf [ 0 ] ) ;\n }\n dsp -> vector_fmul ( out , v , sbr_qmf_window , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 192 >> div ) , sbr_qmf_window + ( 64 >> div ) , out , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 256 >> div ) , sbr_qmf_window + ( 128 >> div ) , out , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 448 >> div ) , sbr_qmf_window + ( 192 >> div ) , out , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 512 >> div ) , sbr_qmf_window + ( 256 >> div ) , out , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 704 >> div ) , sbr_qmf_window + ( 320 >> div ) , out , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 768 >> div ) , sbr_qmf_window + ( 384 >> div ) , out , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 960 >> div ) , sbr_qmf_window + ( 448 >> div ) , out , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 1024 >> div ) , sbr_qmf_window + ( 512 >> div ) , out , 64 >> div ) ;\n dsp -> vector_fmul_add ( out , v + ( 1216 >> div ) , sbr_qmf_window + ( 576 >> div ) , out , 64 >> div ) ;\n out += 64 >> div ;\n }\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 46,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void sbr_qmf_synthesis ( FFTContext * mdct , SBRDSPContext * sbrdsp , AVFloatDSPContext * dsp , float * out , float X [ 2 ] [ 38 ] [ 64 ] , float mdct_buf [ 2 ] [ 64 ] , float * v0 , int * v_off , const unsigned int div ) {\n"
                ],
                [
                    9,
                    " if ( * v_off < step ) {\n"
                ],
                [
                    11,
                    " memcpy ( & v0 [ SBR_SYNTHESIS_BUF_SIZE - saved_samples ] , v0 , saved_samples * sizeof ( float ) ) ;\n"
                ],
                [
                    17,
                    " v = v0 + * v_off ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void sbr_qmf_synthesis ( FFTContext * mdct , SBRDSPContext * sbrdsp , AVFloatDSPContext * dsp , float * out , float X [ 2 ] [ 38 ] [ 64 ] , float mdct_buf [ 2 ] [ 64 ] , float * v0 , int * v_off , const unsigned int div ) {\n"
                ],
                [
                    9,
                    " if ( * v_off < step ) {\n"
                ],
                [
                    11,
                    " memcpy ( & v0 [ SBR_SYNTHESIS_BUF_SIZE - saved_samples ] , v0 , saved_samples * sizeof ( float ) ) ;\n"
                ],
                [
                    17,
                    " v = v0 + * v_off ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , SBRDSPContext * sbrdsp , const float * in , float * x , float z [ 320 ] , float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n int i ;\n memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ;\n memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ;\n for ( i = 0 ;\n i < 32 ;\n i ++ ) {\n dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ;\n sbrdsp -> sum64x5 ( z ) ;\n sbrdsp -> qmf_pre_shuffle ( z ) ;\n mdct -> imdct_half ( mdct , z , z + 64 ) ;\n sbrdsp -> qmf_post_shuffle ( W [ buf_idx ] [ i ] , z ) ;\n x += 32 ;\n }\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 15,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , SBRDSPContext * sbrdsp , const float * in , float * x , float z [ 320 ] , float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n"
                ],
                [
                    3,
                    " memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ;\n"
                ],
                [
                    4,
                    " memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ;\n"
                ],
                [
                    8,
                    " dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , SBRDSPContext * sbrdsp , const float * in , float * x , float z [ 320 ] , float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n"
                ],
                [
                    3,
                    " memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ;\n"
                ],
                [
                    4,
                    " memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ;\n"
                ],
                [
                    8,
                    " dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int sbr_lf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_low [ 32 ] [ 40 ] [ 2 ] , const float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n int i , k ;\n const int t_HFGen = 8 ;\n const int i_f = 32 ;\n memset ( X_low , 0 , 32 * sizeof ( * X_low ) ) ;\n for ( k = 0 ;\n k < sbr -> kx [ 1 ] ;\n k ++ ) {\n for ( i = t_HFGen ;\n i < i_f + t_HFGen ;\n i ++ ) {\n X_low [ k ] [ i ] [ 0 ] = W [ buf_idx ] [ i - t_HFGen ] [ k ] [ 0 ] ;\n X_low [ k ] [ i ] [ 1 ] = W [ buf_idx ] [ i - t_HFGen ] [ k ] [ 1 ] ;\n }\n }\n buf_idx = 1 - buf_idx ;\n for ( k = 0 ;\n k < sbr -> kx [ 0 ] ;\n k ++ ) {\n for ( i = 0 ;\n i < t_HFGen ;\n i ++ ) {\n X_low [ k ] [ i ] [ 0 ] = W [ buf_idx ] [ i + i_f - t_HFGen ] [ k ] [ 0 ] ;\n X_low [ k ] [ i ] [ 1 ] = W [ buf_idx ] [ i + i_f - t_HFGen ] [ k ] [ 1 ] ;\n }\n }\n return 0 ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 28,
        "slice": {
            "memset": [
                [
                    1,
                    "static int sbr_lf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_low [ 32 ] [ 40 ] [ 2 ] , const float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n"
                ],
                [
                    5,
                    " memset ( X_low , 0 , 32 * sizeof ( * X_low ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int sbr_lf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_low [ 32 ] [ 40 ] [ 2 ] , const float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n"
                ],
                [
                    5,
                    " memset ( X_low , 0 , 32 * sizeof ( * X_low ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int sbr_make_f_derived ( AACContext * ac , SpectralBandReplication * sbr ) {\n int k , temp ;\n sbr -> n [ 1 ] = sbr -> n_master - sbr -> spectrum_params . bs_xover_band ;\n sbr -> n [ 0 ] = ( sbr -> n [ 1 ] + 1 ) >> 1 ;\n memcpy ( sbr -> f_tablehigh , & sbr -> f_master [ sbr -> spectrum_params . bs_xover_band ] , ( sbr -> n [ 1 ] + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n sbr -> m [ 1 ] = sbr -> f_tablehigh [ sbr -> n [ 1 ] ] - sbr -> f_tablehigh [ 0 ] ;\n sbr -> kx [ 1 ] = sbr -> f_tablehigh [ 0 ] ;\n if ( sbr -> kx [ 1 ] + sbr -> m [ 1 ] > 64 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Stop frequency border too high: %d\\n\" , sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) ;\n return - 1 ;\n }\n if ( sbr -> kx [ 1 ] > 32 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Start frequency border too high: %d\\n\" , sbr -> kx [ 1 ] ) ;\n return - 1 ;\n }\n sbr -> f_tablelow [ 0 ] = sbr -> f_tablehigh [ 0 ] ;\n temp = sbr -> n [ 1 ] & 1 ;\n for ( k = 1 ;\n k <= sbr -> n [ 0 ] ;\n k ++ ) sbr -> f_tablelow [ k ] = sbr -> f_tablehigh [ 2 * k - temp ] ;\n sbr -> n_q = FFMAX ( 1 , lrintf ( sbr -> spectrum_params . bs_noise_bands * log2f ( sbr -> k [ 2 ] / ( float ) sbr -> kx [ 1 ] ) ) ) ;\n if ( sbr -> n_q > 5 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Too many noise floor scale factors: %d\\n\" , sbr -> n_q ) ;\n return - 1 ;\n }\n sbr -> f_tablenoise [ 0 ] = sbr -> f_tablelow [ 0 ] ;\n temp = 0 ;\n for ( k = 1 ;\n k <= sbr -> n_q ;\n k ++ ) {\n temp += ( sbr -> n [ 0 ] - temp ) / ( sbr -> n_q + 1 - k ) ;\n sbr -> f_tablenoise [ k ] = sbr -> f_tablelow [ temp ] ;\n }\n if ( sbr_hf_calc_npatches ( ac , sbr ) < 0 ) return - 1 ;\n sbr_make_f_tablelim ( sbr ) ;\n sbr -> data [ 0 ] . f_indexnoise = 0 ;\n sbr -> data [ 1 ] . f_indexnoise = 0 ;\n return 0 ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 39,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static int sbr_make_f_derived ( AACContext * ac , SpectralBandReplication * sbr ) {\n"
                ],
                [
                    5,
                    " memcpy ( sbr -> f_tablehigh , & sbr -> f_master [ sbr -> spectrum_params . bs_xover_band ] , ( sbr -> n [ 1 ] + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n"
                ],
                [
                    34,
                    " if ( sbr_hf_calc_npatches ( ac , sbr ) < 0 ) return - 1 ;\n"
                ],
                [
                    35,
                    " sbr_make_f_tablelim ( sbr ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int sbr_make_f_derived ( AACContext * ac , SpectralBandReplication * sbr ) {\n"
                ],
                [
                    5,
                    " memcpy ( sbr -> f_tablehigh , & sbr -> f_master [ sbr -> spectrum_params . bs_xover_band ] , ( sbr -> n [ 1 ] + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n"
                ],
                [
                    34,
                    " if ( sbr_hf_calc_npatches ( ac , sbr ) < 0 ) return - 1 ;\n"
                ],
                [
                    35,
                    " sbr_make_f_tablelim ( sbr ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void copy_sbr_grid ( SBRData * dst , const SBRData * src ) {\n dst -> bs_freq_res [ 0 ] = dst -> bs_freq_res [ dst -> bs_num_env ] ;\n dst -> t_env_num_env_old = dst -> t_env [ dst -> bs_num_env ] ;\n dst -> e_a [ 0 ] = - ( dst -> e_a [ 1 ] != dst -> bs_num_env ) ;\n memcpy ( dst -> bs_freq_res + 1 , src -> bs_freq_res + 1 , sizeof ( dst -> bs_freq_res ) - sizeof ( * dst -> bs_freq_res ) ) ;\n memcpy ( dst -> t_env , src -> t_env , sizeof ( dst -> t_env ) ) ;\n memcpy ( dst -> t_q , src -> t_q , sizeof ( dst -> t_q ) ) ;\n dst -> bs_num_env = src -> bs_num_env ;\n dst -> bs_amp_res = src -> bs_amp_res ;\n dst -> bs_num_noise = src -> bs_num_noise ;\n dst -> bs_frame_class = src -> bs_frame_class ;\n dst -> e_a [ 1 ] = src -> e_a [ 1 ] ;\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 13,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void copy_sbr_grid ( SBRData * dst , const SBRData * src ) {\n"
                ],
                [
                    2,
                    " dst -> bs_freq_res [ 0 ] = dst -> bs_freq_res [ dst -> bs_num_env ] ;\n"
                ],
                [
                    5,
                    " memcpy ( dst -> bs_freq_res + 1 , src -> bs_freq_res + 1 , sizeof ( dst -> bs_freq_res ) - sizeof ( * dst -> bs_freq_res ) ) ;\n"
                ],
                [
                    6,
                    " memcpy ( dst -> t_env , src -> t_env , sizeof ( dst -> t_env ) ) ;\n"
                ],
                [
                    7,
                    " memcpy ( dst -> t_q , src -> t_q , sizeof ( dst -> t_q ) ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void copy_sbr_grid ( SBRData * dst , const SBRData * src ) {\n"
                ],
                [
                    2,
                    " dst -> bs_freq_res [ 0 ] = dst -> bs_freq_res [ dst -> bs_num_env ] ;\n"
                ],
                [
                    5,
                    " memcpy ( dst -> bs_freq_res + 1 , src -> bs_freq_res + 1 , sizeof ( dst -> bs_freq_res ) - sizeof ( * dst -> bs_freq_res ) ) ;\n"
                ],
                [
                    6,
                    " memcpy ( dst -> t_env , src -> t_env , sizeof ( dst -> t_env ) ) ;\n"
                ],
                [
                    7,
                    " memcpy ( dst -> t_q , src -> t_q , sizeof ( dst -> t_q ) ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void sbr_make_f_tablelim ( SpectralBandReplication * sbr ) {\n int k ;\n if ( sbr -> bs_limiter_bands > 0 ) {\n static const float bands_warped [ 3 ] = {\n 1.32715174233856803909f , 1.18509277094158210129f , 1.11987160404675912501f }\n ;\n const float lim_bands_per_octave_warped = bands_warped [ sbr -> bs_limiter_bands - 1 ] ;\n int16_t patch_borders [ 7 ] ;\n uint16_t * in = sbr -> f_tablelim + 1 , * out = sbr -> f_tablelim ;\n patch_borders [ 0 ] = sbr -> kx [ 1 ] ;\n for ( k = 1 ;\n k <= sbr -> num_patches ;\n k ++ ) patch_borders [ k ] = patch_borders [ k - 1 ] + sbr -> patch_num_subbands [ k - 1 ] ;\n memcpy ( sbr -> f_tablelim , sbr -> f_tablelow , ( sbr -> n [ 0 ] + 1 ) * sizeof ( sbr -> f_tablelow [ 0 ] ) ) ;\n if ( sbr -> num_patches > 1 ) memcpy ( sbr -> f_tablelim + sbr -> n [ 0 ] + 1 , patch_borders + 1 , ( sbr -> num_patches - 1 ) * sizeof ( patch_borders [ 0 ] ) ) ;\n qsort ( sbr -> f_tablelim , sbr -> num_patches + sbr -> n [ 0 ] , sizeof ( sbr -> f_tablelim [ 0 ] ) , qsort_comparison_function_int16 ) ;\n sbr -> n_lim = sbr -> n [ 0 ] + sbr -> num_patches - 1 ;\n while ( out < sbr -> f_tablelim + sbr -> n_lim ) {\n if ( * in >= * out * lim_bands_per_octave_warped ) {\n * ++ out = * in ++ ;\n }\n else if ( * in == * out || ! in_table_int16 ( patch_borders , sbr -> num_patches , * in ) ) {\n in ++ ;\n sbr -> n_lim -- ;\n }\n else if ( ! in_table_int16 ( patch_borders , sbr -> num_patches , * out ) ) {\n * out = * in ++ ;\n sbr -> n_lim -- ;\n }\n else {\n * ++ out = * in ++ ;\n }\n }\n }\n else {\n sbr -> f_tablelim [ 0 ] = sbr -> f_tablelow [ 0 ] ;\n sbr -> f_tablelim [ 1 ] = sbr -> f_tablelow [ sbr -> n [ 0 ] ] ;\n sbr -> n_lim = 1 ;\n }\n }",
        "hash": -4106680724983638989,
        "project": "chrome",
        "size": 40,
        "slice": {
            "memcpy": [
                [
                    1,
                    "static void sbr_make_f_tablelim ( SpectralBandReplication * sbr ) {\n"
                ],
                [
                    3,
                    " if ( sbr -> bs_limiter_bands > 0 ) {\n"
                ],
                [
                    8,
                    " int16_t patch_borders [ 7 ] ;\n"
                ],
                [
                    10,
                    " patch_borders [ 0 ] = sbr -> kx [ 1 ] ;\n"
                ],
                [
                    13,
                    " k ++ ) patch_borders [ k ] = patch_borders [ k - 1 ] + sbr -> patch_num_subbands [ k - 1 ] ;\n"
                ],
                [
                    14,
                    " memcpy ( sbr -> f_tablelim , sbr -> f_tablelow , ( sbr -> n [ 0 ] + 1 ) * sizeof ( sbr -> f_tablelow [ 0 ] ) ) ;\n"
                ],
                [
                    15,
                    " if ( sbr -> num_patches > 1 ) memcpy ( sbr -> f_tablelim + sbr -> n [ 0 ] + 1 , patch_borders + 1 , ( sbr -> num_patches - 1 ) * sizeof ( patch_borders [ 0 ] ) ) ;\n"
                ],
                [
                    16,
                    " qsort ( sbr -> f_tablelim , sbr -> num_patches + sbr -> n [ 0 ] , sizeof ( sbr -> f_tablelim [ 0 ] ) , qsort_comparison_function_int16 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void sbr_make_f_tablelim ( SpectralBandReplication * sbr ) {\n"
                ],
                [
                    3,
                    " if ( sbr -> bs_limiter_bands > 0 ) {\n"
                ],
                [
                    8,
                    " int16_t patch_borders [ 7 ] ;\n"
                ],
                [
                    10,
                    " patch_borders [ 0 ] = sbr -> kx [ 1 ] ;\n"
                ],
                [
                    13,
                    " k ++ ) patch_borders [ k ] = patch_borders [ k - 1 ] + sbr -> patch_num_subbands [ k - 1 ] ;\n"
                ],
                [
                    14,
                    " memcpy ( sbr -> f_tablelim , sbr -> f_tablelow , ( sbr -> n [ 0 ] + 1 ) * sizeof ( sbr -> f_tablelow [ 0 ] ) ) ;\n"
                ],
                [
                    15,
                    " if ( sbr -> num_patches > 1 ) memcpy ( sbr -> f_tablelim + sbr -> n [ 0 ] + 1 , patch_borders + 1 , ( sbr -> num_patches - 1 ) * sizeof ( patch_borders [ 0 ] ) ) ;\n"
                ],
                [
                    16,
                    " qsort ( sbr -> f_tablelim , sbr -> num_patches + sbr -> n [ 0 ] , sizeof ( sbr -> f_tablelim [ 0 ] ) , qsort_comparison_function_int16 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void evsignal_dealloc ( struct event_base * base ) {\n int i = 0 ;\n if ( base -> sig . ev_signal_added ) {\n event_del ( & base -> sig . ev_signal ) ;\n base -> sig . ev_signal_added = 0 ;\n }\n for ( i = 0 ;\n i < NSIG ;\n ++ i ) {\n if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;\n }\n EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 0 ] ) ;\n base -> sig . ev_signal_pair [ 0 ] = - 1 ;\n EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 1 ] ) ;\n base -> sig . ev_signal_pair [ 1 ] = - 1 ;\n base -> sig . sh_old_max = 0 ;\n free ( base -> sig . sh_old ) ;\n }",
        "hash": 6980637897759012306,
        "project": "chrome",
        "size": 18,
        "slice": {
            "free": [
                [
                    1,
                    "void evsignal_dealloc ( struct event_base * base ) {\n"
                ],
                [
                    10,
                    " if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;\n"
                ],
                [
                    17,
                    " free ( base -> sig . sh_old ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void evsignal_dealloc ( struct event_base * base ) {\n"
                ],
                [
                    10,
                    " if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;\n"
                ],
                [
                    17,
                    " free ( base -> sig . sh_old ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int evsignal_init ( struct event_base * base ) {\n int i ;\n if ( evutil_socketpair ( AF_UNIX , SOCK_STREAM , 0 , base -> sig . ev_signal_pair ) == - 1 ) {\n # ifdef WIN32 event_warn ( \"%s: socketpair\" , __func__ ) ;\n # else event_err ( 1 , \"%s: socketpair\" , __func__ ) ;\n # endif return - 1 ;\n }\n FD_CLOSEONEXEC ( base -> sig . ev_signal_pair [ 0 ] ) ;\n FD_CLOSEONEXEC ( base -> sig . ev_signal_pair [ 1 ] ) ;\n base -> sig . sh_old = NULL ;\n base -> sig . sh_old_max = 0 ;\n base -> sig . evsignal_caught = 0 ;\n memset ( & base -> sig . evsigcaught , 0 , sizeof ( sig_atomic_t ) * NSIG ) ;\n for ( i = 0 ;\n i < NSIG ;\n ++ i ) TAILQ_INIT ( & base -> sig . evsigevents [ i ] ) ;\n evutil_make_socket_nonblocking ( base -> sig . ev_signal_pair [ 0 ] ) ;\n event_set ( & base -> sig . ev_signal , base -> sig . ev_signal_pair [ 1 ] , EV_READ | EV_PERSIST , evsignal_cb , & base -> sig . ev_signal ) ;\n base -> sig . ev_signal . ev_base = base ;\n base -> sig . ev_signal . ev_flags |= EVLIST_INTERNAL ;\n return 0 ;\n }",
        "hash": 6980637897759012306,
        "project": "chrome",
        "size": 22,
        "slice": {
            "memset": [
                [
                    1,
                    "int evsignal_init ( struct event_base * base ) {\n"
                ],
                [
                    13,
                    " memset ( & base -> sig . evsigcaught , 0 , sizeof ( sig_atomic_t ) * NSIG ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int evsignal_init ( struct event_base * base ) {\n"
                ],
                [
                    13,
                    " memset ( & base -> sig . evsigcaught , 0 , sizeof ( sig_atomic_t ) * NSIG ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int _evsignal_set_handler ( struct event_base * base , int evsignal , void ( * handler ) ( int ) ) {\n # ifdef HAVE_SIGACTION struct sigaction sa ;\n # else ev_sighandler_t sh ;\n # endif struct evsignal_info * sig = & base -> sig ;\n void * p ;\n if ( evsignal >= sig -> sh_old_max ) {\n int new_max = evsignal + 1 ;\n event_debug ( ( \"%s: evsignal (%d) >= sh_old_max (%d), resizing\" , __func__ , evsignal , sig -> sh_old_max ) ) ;\n p = realloc ( sig -> sh_old , new_max * sizeof ( * sig -> sh_old ) ) ;\n if ( p == NULL ) {\n event_warn ( \"realloc\" ) ;\n return ( - 1 ) ;\n }\n memset ( ( char * ) p + sig -> sh_old_max * sizeof ( * sig -> sh_old ) , 0 , ( new_max - sig -> sh_old_max ) * sizeof ( * sig -> sh_old ) ) ;\n sig -> sh_old_max = new_max ;\n sig -> sh_old = p ;\n }\n sig -> sh_old [ evsignal ] = malloc ( sizeof * sig -> sh_old [ evsignal ] ) ;\n if ( sig -> sh_old [ evsignal ] == NULL ) {\n event_warn ( \"malloc\" ) ;\n return ( - 1 ) ;\n }\n # ifdef HAVE_SIGACTION memset ( & sa , 0 , sizeof ( sa ) ) ;\n sa . sa_handler = handler ;\n sa . sa_flags |= SA_RESTART ;\n sigfillset ( & sa . sa_mask ) ;\n if ( sigaction ( evsignal , & sa , sig -> sh_old [ evsignal ] ) == - 1 ) {\n event_warn ( \"sigaction\" ) ;\n free ( sig -> sh_old [ evsignal ] ) ;\n return ( - 1 ) ;\n }\n # else if ( ( sh = signal ( evsignal , handler ) ) == SIG_ERR ) {\n event_warn ( \"signal\" ) ;\n free ( sig -> sh_old [ evsignal ] ) ;\n return ( - 1 ) ;\n }\n * sig -> sh_old [ evsignal ] = sh ;\n # endif return ( 0 ) ;\n }",
        "hash": 6980637897759012306,
        "project": "chrome",
        "size": 39,
        "slice": {
            "memset": [
                [
                    1,
                    "int _evsignal_set_handler ( struct event_base * base , int evsignal , void ( * handler ) ( int ) ) {\n"
                ],
                [
                    10,
                    " if ( p == NULL ) {\n"
                ],
                [
                    14,
                    " memset ( ( char * ) p + sig -> sh_old_max * sizeof ( * sig -> sh_old ) , 0 , ( new_max - sig -> sh_old_max ) * sizeof ( * sig -> sh_old ) ) ;\n"
                ]
            ],
            "malloc": [
                [
                    1,
                    "int _evsignal_set_handler ( struct event_base * base , int evsignal , void ( * handler ) ( int ) ) {\n"
                ],
                [
                    6,
                    " if ( evsignal >= sig -> sh_old_max ) {\n"
                ],
                [
                    10,
                    " if ( p == NULL ) {\n"
                ],
                [
                    18,
                    " sig -> sh_old [ evsignal ] = malloc ( sizeof * sig -> sh_old [ evsignal ] ) ;\n"
                ],
                [
                    19,
                    " if ( sig -> sh_old [ evsignal ] == NULL ) {\n"
                ],
                [
                    20,
                    " event_warn ( \"malloc\" ) ;\n"
                ]
            ],
            "free": [
                [
                    19,
                    " if ( sig -> sh_old [ evsignal ] == NULL ) {\n"
                ],
                [
                    34,
                    " free ( sig -> sh_old [ evsignal ] ) ;\n"
                ]
            ],
            "realloc": [
                [
                    1,
                    "int _evsignal_set_handler ( struct event_base * base , int evsignal , void ( * handler ) ( int ) ) {\n"
                ],
                [
                    6,
                    " if ( evsignal >= sig -> sh_old_max ) {\n"
                ],
                [
                    9,
                    " p = realloc ( sig -> sh_old , new_max * sizeof ( * sig -> sh_old ) ) ;\n"
                ],
                [
                    10,
                    " if ( p == NULL ) {\n"
                ],
                [
                    11,
                    " event_warn ( \"realloc\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int _evsignal_set_handler ( struct event_base * base , int evsignal , void ( * handler ) ( int ) ) {\n"
                ],
                [
                    6,
                    " if ( evsignal >= sig -> sh_old_max ) {\n"
                ],
                [
                    9,
                    " p = realloc ( sig -> sh_old , new_max * sizeof ( * sig -> sh_old ) ) ;\n"
                ],
                [
                    10,
                    " if ( p == NULL ) {\n"
                ],
                [
                    11,
                    " event_warn ( \"realloc\" ) ;\n"
                ],
                [
                    14,
                    " memset ( ( char * ) p + sig -> sh_old_max * sizeof ( * sig -> sh_old ) , 0 , ( new_max - sig -> sh_old_max ) * sizeof ( * sig -> sh_old ) ) ;\n"
                ],
                [
                    18,
                    " sig -> sh_old [ evsignal ] = malloc ( sizeof * sig -> sh_old [ evsignal ] ) ;\n"
                ],
                [
                    19,
                    " if ( sig -> sh_old [ evsignal ] == NULL ) {\n"
                ],
                [
                    20,
                    " event_warn ( \"malloc\" ) ;\n"
                ],
                [
                    34,
                    " free ( sig -> sh_old [ evsignal ] ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void min_heap_dtor ( min_heap_t * s ) {\n free ( s -> p ) ;\n }",
        "hash": -1514879141119470937,
        "project": "chrome",
        "size": 3,
        "slice": {
            "free": [
                [
                    1,
                    "void min_heap_dtor ( min_heap_t * s ) {\n"
                ],
                [
                    2,
                    " free ( s -> p ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void min_heap_dtor ( min_heap_t * s ) {\n"
                ],
                [
                    2,
                    " free ( s -> p ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int event_base_priority_init ( struct event_base * base , int npriorities ) {\n int i ;\n if ( base -> event_count_active ) return ( - 1 ) ;\n if ( base -> nactivequeues && npriorities != base -> nactivequeues ) {\n for ( i = 0 ;\n i < base -> nactivequeues ;\n ++ i ) {\n free ( base -> activequeues [ i ] ) ;\n }\n free ( base -> activequeues ) ;\n }\n base -> nactivequeues = npriorities ;\n base -> activequeues = ( struct event_list * * ) calloc ( base -> nactivequeues , sizeof ( struct event_list * ) ) ;\n if ( base -> activequeues == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n for ( i = 0 ;\n i < base -> nactivequeues ;\n ++ i ) {\n base -> activequeues [ i ] = malloc ( sizeof ( struct event_list ) ) ;\n if ( base -> activequeues [ i ] == NULL ) event_err ( 1 , \"%s: malloc\" , __func__ ) ;\n TAILQ_INIT ( base -> activequeues [ i ] ) ;\n }\n return ( 0 ) ;\n }",
        "hash": 8461266595329035000,
        "project": "chrome",
        "size": 23,
        "slice": {
            "malloc": [
                [
                    1,
                    "int event_base_priority_init ( struct event_base * base , int npriorities ) {\n"
                ],
                [
                    14,
                    " if ( base -> activequeues == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n"
                ],
                [
                    16,
                    " i < base -> nactivequeues ;\n"
                ],
                [
                    18,
                    " base -> activequeues [ i ] = malloc ( sizeof ( struct event_list ) ) ;\n"
                ],
                [
                    19,
                    " if ( base -> activequeues [ i ] == NULL ) event_err ( 1 , \"%s: malloc\" , __func__ ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "int event_base_priority_init ( struct event_base * base , int npriorities ) {\n"
                ],
                [
                    4,
                    " if ( base -> nactivequeues && npriorities != base -> nactivequeues ) {\n"
                ],
                [
                    6,
                    " i < base -> nactivequeues ;\n"
                ],
                [
                    8,
                    " free ( base -> activequeues [ i ] ) ;\n"
                ],
                [
                    10,
                    " free ( base -> activequeues ) ;\n"
                ],
                [
                    14,
                    " if ( base -> activequeues == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n"
                ]
            ],
            "calloc": [
                [
                    1,
                    "int event_base_priority_init ( struct event_base * base , int npriorities ) {\n"
                ],
                [
                    3,
                    " if ( base -> event_count_active ) return ( - 1 ) ;\n"
                ],
                [
                    12,
                    " base -> nactivequeues = npriorities ;\n"
                ],
                [
                    13,
                    " base -> activequeues = ( struct event_list * * ) calloc ( base -> nactivequeues , sizeof ( struct event_list * ) ) ;\n"
                ],
                [
                    14,
                    " if ( base -> activequeues == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n"
                ],
                [
                    19,
                    " if ( base -> activequeues [ i ] == NULL ) event_err ( 1 , \"%s: malloc\" , __func__ ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int event_base_priority_init ( struct event_base * base , int npriorities ) {\n"
                ],
                [
                    3,
                    " if ( base -> event_count_active ) return ( - 1 ) ;\n"
                ],
                [
                    4,
                    " if ( base -> nactivequeues && npriorities != base -> nactivequeues ) {\n"
                ],
                [
                    6,
                    " i < base -> nactivequeues ;\n"
                ],
                [
                    8,
                    " free ( base -> activequeues [ i ] ) ;\n"
                ],
                [
                    10,
                    " free ( base -> activequeues ) ;\n"
                ],
                [
                    12,
                    " base -> nactivequeues = npriorities ;\n"
                ],
                [
                    13,
                    " base -> activequeues = ( struct event_list * * ) calloc ( base -> nactivequeues , sizeof ( struct event_list * ) ) ;\n"
                ],
                [
                    14,
                    " if ( base -> activequeues == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n"
                ],
                [
                    16,
                    " i < base -> nactivequeues ;\n"
                ],
                [
                    18,
                    " base -> activequeues [ i ] = malloc ( sizeof ( struct event_list ) ) ;\n"
                ],
                [
                    19,
                    " if ( base -> activequeues [ i ] == NULL ) event_err ( 1 , \"%s: malloc\" , __func__ ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "struct event_base * event_base_new ( void ) {\n int i ;\n struct event_base * base ;\n if ( ( base = calloc ( 1 , sizeof ( struct event_base ) ) ) == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n gettime ( base , & base -> event_tv ) ;\n min_heap_ctor ( & base -> timeheap ) ;\n TAILQ_INIT ( & base -> eventqueue ) ;\n base -> sig . ev_signal_pair [ 0 ] = - 1 ;\n base -> sig . ev_signal_pair [ 1 ] = - 1 ;\n base -> evbase = NULL ;\n for ( i = 0 ;\n eventops [ i ] && ! base -> evbase ;\n i ++ ) {\n base -> evsel = eventops [ i ] ;\n base -> evbase = base -> evsel -> init ( base ) ;\n }\n if ( base -> evbase == NULL ) event_errx ( 1 , \"%s: no event mechanism available\" , __func__ ) ;\n if ( evutil_getenv ( \"EVENT_SHOW_METHOD\" ) ) event_msgx ( \"libevent using: %s\\n\" , base -> evsel -> name ) ;\n event_base_priority_init ( base , 1 ) ;\n return ( base ) ;\n }",
        "hash": 8461266595329035000,
        "project": "chrome",
        "size": 21,
        "slice": {
            "calloc": [
                [
                    1,
                    "struct event_base * event_base_new ( void ) {\n"
                ],
                [
                    4,
                    " if ( ( base = calloc ( 1 , sizeof ( struct event_base ) ) ) == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n"
                ],
                [
                    5,
                    " gettime ( base , & base -> event_tv ) ;\n"
                ],
                [
                    10,
                    " base -> evbase = NULL ;\n"
                ],
                [
                    15,
                    " base -> evbase = base -> evsel -> init ( base ) ;\n"
                ],
                [
                    17,
                    " if ( base -> evbase == NULL ) event_errx ( 1 , \"%s: no event mechanism available\" , __func__ ) ;\n"
                ],
                [
                    19,
                    " event_base_priority_init ( base , 1 ) ;\n"
                ],
                [
                    20,
                    " return ( base ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "struct event_base * event_base_new ( void ) {\n"
                ],
                [
                    4,
                    " if ( ( base = calloc ( 1 , sizeof ( struct event_base ) ) ) == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n"
                ],
                [
                    5,
                    " gettime ( base , & base -> event_tv ) ;\n"
                ],
                [
                    10,
                    " base -> evbase = NULL ;\n"
                ],
                [
                    15,
                    " base -> evbase = base -> evsel -> init ( base ) ;\n"
                ],
                [
                    17,
                    " if ( base -> evbase == NULL ) event_errx ( 1 , \"%s: no event mechanism available\" , __func__ ) ;\n"
                ],
                [
                    19,
                    " event_base_priority_init ( base , 1 ) ;\n"
                ],
                [
                    20,
                    " return ( base ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void test_evbuffer_find ( void ) {\n u_char * p ;\n const char * test1 = \"1234567890\\r\\n\" ;\n const char * test2 = \"1234567890\\r\" ;\n # define EVBUFFER_INITIAL_LENGTH 256 char test3 [ EVBUFFER_INITIAL_LENGTH ] ;\n unsigned int i ;\n struct evbuffer * buf = evbuffer_new ( ) ;\n fprintf ( stdout , \"Testing evbuffer_find 1: \" ) ;\n evbuffer_add ( buf , ( u_char * ) test1 , strlen ( test1 ) ) ;\n evbuffer_drain ( buf , strlen ( test1 ) ) ;\n evbuffer_add ( buf , ( u_char * ) test2 , strlen ( test2 ) ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"\\r\\n\" , 2 ) ;\n if ( p == NULL ) {\n fprintf ( stdout , \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"Testing evbuffer_find 2: \" ) ;\n evbuffer_drain ( buf , strlen ( test2 ) ) ;\n for ( i = 0 ;\n i < EVBUFFER_INITIAL_LENGTH ;\n ++ i ) test3 [ i ] = 'a' ;\n test3 [ EVBUFFER_INITIAL_LENGTH - 1 ] = 'x' ;\n evbuffer_add ( buf , ( u_char * ) test3 , EVBUFFER_INITIAL_LENGTH ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"xy\" , 2 ) ;\n if ( p == NULL ) {\n printf ( \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n fprintf ( stdout , \"Testing evbuffer_find 3: \" ) ;\n p = evbuffer_find ( buf , ( u_char * ) \"ax\" , 2 ) ;\n if ( p != NULL && strncmp ( ( char * ) p , \"ax\" , 2 ) == 0 ) {\n printf ( \"OK\\n\" ) ;\n }\n else {\n fprintf ( stdout , \"FAILED\\n\" ) ;\n exit ( 1 ) ;\n }\n evbuffer_free ( buf ) ;\n }",
        "hash": 5347874611477979643,
        "project": "chrome",
        "size": 45,
        "slice": {
            "strlen": [
                [
                    1,
                    "static void test_evbuffer_find ( void ) {\n"
                ],
                [
                    3,
                    " const char * test1 = \"1234567890\\r\\n\" ;\n"
                ],
                [
                    4,
                    " const char * test2 = \"1234567890\\r\" ;\n"
                ],
                [
                    9,
                    " evbuffer_add ( buf , ( u_char * ) test1 , strlen ( test1 ) ) ;\n"
                ],
                [
                    10,
                    " evbuffer_drain ( buf , strlen ( test1 ) ) ;\n"
                ],
                [
                    11,
                    " evbuffer_add ( buf , ( u_char * ) test2 , strlen ( test2 ) ) ;\n"
                ],
                [
                    12,
                    " p = evbuffer_find ( buf , ( u_char * ) \"\\r\\n\" , 2 ) ;\n"
                ],
                [
                    21,
                    " evbuffer_drain ( buf , strlen ( test2 ) ) ;\n"
                ],
                [
                    27,
                    " p = evbuffer_find ( buf , ( u_char * ) \"xy\" , 2 ) ;\n"
                ]
            ],
            "printf": [
                [
                    1,
                    "static void test_evbuffer_find ( void ) {\n"
                ],
                [
                    28,
                    " if ( p == NULL ) {\n"
                ],
                [
                    29,
                    " printf ( \"OK\\n\" ) ;\n"
                ],
                [
                    37,
                    " if ( p != NULL && strncmp ( ( char * ) p , \"ax\" , 2 ) == 0 ) {\n"
                ],
                [
                    38,
                    " printf ( \"OK\\n\" ) ;\n"
                ]
            ],
            "fprintf": [
                [
                    1,
                    "static void test_evbuffer_find ( void ) {\n"
                ],
                [
                    8,
                    " fprintf ( stdout , \"Testing evbuffer_find 1: \" ) ;\n"
                ],
                [
                    13,
                    " if ( p == NULL ) {\n"
                ],
                [
                    14,
                    " fprintf ( stdout , \"OK\\n\" ) ;\n"
                ],
                [
                    17,
                    " fprintf ( stdout , \"FAILED\\n\" ) ;\n"
                ],
                [
                    20,
                    " fprintf ( stdout , \"Testing evbuffer_find 2: \" ) ;\n"
                ],
                [
                    28,
                    " if ( p == NULL ) {\n"
                ],
                [
                    32,
                    " fprintf ( stdout , \"FAILED\\n\" ) ;\n"
                ],
                [
                    35,
                    " fprintf ( stdout , \"Testing evbuffer_find 3: \" ) ;\n"
                ],
                [
                    37,
                    " if ( p != NULL && strncmp ( ( char * ) p , \"ax\" , 2 ) == 0 ) {\n"
                ],
                [
                    41,
                    " fprintf ( stdout , \"FAILED\\n\" ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void test_evbuffer_find ( void ) {\n"
                ],
                [
                    3,
                    " const char * test1 = \"1234567890\\r\\n\" ;\n"
                ],
                [
                    4,
                    " const char * test2 = \"1234567890\\r\" ;\n"
                ],
                [
                    8,
                    " fprintf ( stdout , \"Testing evbuffer_find 1: \" ) ;\n"
                ],
                [
                    9,
                    " evbuffer_add ( buf , ( u_char * ) test1 , strlen ( test1 ) ) ;\n"
                ],
                [
                    10,
                    " evbuffer_drain ( buf , strlen ( test1 ) ) ;\n"
                ],
                [
                    11,
                    " evbuffer_add ( buf , ( u_char * ) test2 , strlen ( test2 ) ) ;\n"
                ],
                [
                    12,
                    " p = evbuffer_find ( buf , ( u_char * ) \"\\r\\n\" , 2 ) ;\n"
                ],
                [
                    13,
                    " if ( p == NULL ) {\n"
                ],
                [
                    14,
                    " fprintf ( stdout , \"OK\\n\" ) ;\n"
                ],
                [
                    17,
                    " fprintf ( stdout , \"FAILED\\n\" ) ;\n"
                ],
                [
                    20,
                    " fprintf ( stdout , \"Testing evbuffer_find 2: \" ) ;\n"
                ],
                [
                    21,
                    " evbuffer_drain ( buf , strlen ( test2 ) ) ;\n"
                ],
                [
                    27,
                    " p = evbuffer_find ( buf , ( u_char * ) \"xy\" , 2 ) ;\n"
                ],
                [
                    28,
                    " if ( p == NULL ) {\n"
                ],
                [
                    29,
                    " printf ( \"OK\\n\" ) ;\n"
                ],
                [
                    32,
                    " fprintf ( stdout , \"FAILED\\n\" ) ;\n"
                ],
                [
                    35,
                    " fprintf ( stdout , \"Testing evbuffer_find 3: \" ) ;\n"
                ],
                [
                    37,
                    " if ( p != NULL && strncmp ( ( char * ) p , \"ax\" , 2 ) == 0 ) {\n"
                ],
                [
                    38,
                    " printf ( \"OK\\n\" ) ;\n"
                ],
                [
                    41,
                    " fprintf ( stdout , \"FAILED\\n\" ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {\n size_t need = buf -> misalign + buf -> off + datlen ;\n if ( buf -> totallen >= need ) return ( 0 ) ;\n if ( buf -> misalign >= datlen ) {\n evbuffer_align ( buf ) ;\n }\n else {\n void * newbuf ;\n size_t length = buf -> totallen ;\n if ( length < 256 ) length = 256 ;\n while ( length < need ) length <<= 1 ;\n if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;\n if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;\n buf -> orig_buffer = buf -> buffer = newbuf ;\n buf -> totallen = length ;\n }\n return ( 0 ) ;\n }",
        "hash": 5704453449583823009,
        "project": "chrome",
        "size": 18,
        "slice": {
            "realloc": [
                [
                    1,
                    "int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {\n"
                ],
                [
                    4,
                    " if ( buf -> misalign >= datlen ) {\n"
                ],
                [
                    11,
                    " while ( length < need ) length <<= 1 ;\n"
                ],
                [
                    12,
                    " if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;\n"
                ],
                [
                    13,
                    " if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;\n"
                ],
                [
                    14,
                    " buf -> orig_buffer = buf -> buffer = newbuf ;\n"
                ],
                [
                    15,
                    " buf -> totallen = length ;\n"
                ],
                [
                    17,
                    " return ( 0 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {\n"
                ],
                [
                    4,
                    " if ( buf -> misalign >= datlen ) {\n"
                ],
                [
                    11,
                    " while ( length < need ) length <<= 1 ;\n"
                ],
                [
                    12,
                    " if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;\n"
                ],
                [
                    13,
                    " if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;\n"
                ],
                [
                    14,
                    " buf -> orig_buffer = buf -> buffer = newbuf ;\n"
                ],
                [
                    15,
                    " buf -> totallen = length ;\n"
                ],
                [
                    17,
                    " return ( 0 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "int evbuffer_add ( struct evbuffer * buf , const void * data , size_t datlen ) {\n size_t need = buf -> misalign + buf -> off + datlen ;\n size_t oldoff = buf -> off ;\n if ( buf -> totallen < need ) {\n if ( evbuffer_expand ( buf , datlen ) == - 1 ) return ( - 1 ) ;\n }\n memcpy ( buf -> buffer + buf -> off , data , datlen ) ;\n buf -> off += datlen ;\n if ( datlen && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;\n return ( 0 ) ;\n }",
        "hash": 5704453449583823009,
        "project": "chrome",
        "size": 11,
        "slice": {
            "memcpy": [
                [
                    1,
                    "int evbuffer_add ( struct evbuffer * buf , const void * data , size_t datlen ) {\n"
                ],
                [
                    4,
                    " if ( buf -> totallen < need ) {\n"
                ],
                [
                    5,
                    " if ( evbuffer_expand ( buf , datlen ) == - 1 ) return ( - 1 ) ;\n"
                ],
                [
                    7,
                    " memcpy ( buf -> buffer + buf -> off , data , datlen ) ;\n"
                ],
                [
                    8,
                    " buf -> off += datlen ;\n"
                ],
                [
                    9,
                    " if ( datlen && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "int evbuffer_add ( struct evbuffer * buf , const void * data , size_t datlen ) {\n"
                ],
                [
                    4,
                    " if ( buf -> totallen < need ) {\n"
                ],
                [
                    5,
                    " if ( evbuffer_expand ( buf , datlen ) == - 1 ) return ( - 1 ) ;\n"
                ],
                [
                    7,
                    " memcpy ( buf -> buffer + buf -> off , data , datlen ) ;\n"
                ],
                [
                    8,
                    " buf -> off += datlen ;\n"
                ],
                [
                    9,
                    " if ( datlen && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void kq_dealloc ( struct event_base * base , void * arg ) {\n struct kqop * kqop = arg ;\n if ( kqop -> changes ) free ( kqop -> changes ) ;\n if ( kqop -> events ) free ( kqop -> events ) ;\n if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;\n memset ( kqop , 0 , sizeof ( struct kqop ) ) ;\n free ( kqop ) ;\n }",
        "hash": -7470076990396875111,
        "project": "chrome",
        "size": 8,
        "slice": {
            "memset": [
                [
                    1,
                    "static void kq_dealloc ( struct event_base * base , void * arg ) {\n"
                ],
                [
                    2,
                    " struct kqop * kqop = arg ;\n"
                ],
                [
                    3,
                    " if ( kqop -> changes ) free ( kqop -> changes ) ;\n"
                ],
                [
                    4,
                    " if ( kqop -> events ) free ( kqop -> events ) ;\n"
                ],
                [
                    5,
                    " if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;\n"
                ],
                [
                    6,
                    " memset ( kqop , 0 , sizeof ( struct kqop ) ) ;\n"
                ],
                [
                    7,
                    " free ( kqop ) ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static void kq_dealloc ( struct event_base * base , void * arg ) {\n"
                ],
                [
                    2,
                    " struct kqop * kqop = arg ;\n"
                ],
                [
                    3,
                    " if ( kqop -> changes ) free ( kqop -> changes ) ;\n"
                ],
                [
                    4,
                    " if ( kqop -> events ) free ( kqop -> events ) ;\n"
                ],
                [
                    5,
                    " if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;\n"
                ],
                [
                    6,
                    " memset ( kqop , 0 , sizeof ( struct kqop ) ) ;\n"
                ],
                [
                    7,
                    " free ( kqop ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void kq_dealloc ( struct event_base * base , void * arg ) {\n"
                ],
                [
                    2,
                    " struct kqop * kqop = arg ;\n"
                ],
                [
                    3,
                    " if ( kqop -> changes ) free ( kqop -> changes ) ;\n"
                ],
                [
                    4,
                    " if ( kqop -> events ) free ( kqop -> events ) ;\n"
                ],
                [
                    5,
                    " if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;\n"
                ],
                [
                    6,
                    " memset ( kqop , 0 , sizeof ( struct kqop ) ) ;\n"
                ],
                [
                    7,
                    " free ( kqop ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void * kq_init ( struct event_base * base ) {\n int i , kq ;\n struct kqop * kqueueop ;\n if ( evutil_getenv ( \"EVENT_NOKQUEUE\" ) ) return ( NULL ) ;\n if ( ! ( kqueueop = calloc ( 1 , sizeof ( struct kqop ) ) ) ) return ( NULL ) ;\n if ( ( kq = kqueue ( ) ) == - 1 ) {\n event_warn ( \"kqueue\" ) ;\n free ( kqueueop ) ;\n return ( NULL ) ;\n }\n kqueueop -> kq = kq ;\n kqueueop -> pid = getpid ( ) ;\n kqueueop -> changes = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n if ( kqueueop -> changes == NULL ) {\n free ( kqueueop ) ;\n return ( NULL ) ;\n }\n kqueueop -> events = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n if ( kqueueop -> events == NULL ) {\n free ( kqueueop -> changes ) ;\n free ( kqueueop ) ;\n return ( NULL ) ;\n }\n kqueueop -> nevents = NEVENT ;\n for ( i = 0 ;\n i < NSIG ;\n ++ i ) {\n TAILQ_INIT ( & kqueueop -> evsigevents [ i ] ) ;\n }\n kqueueop -> changes [ 0 ] . ident = - 1 ;\n kqueueop -> changes [ 0 ] . filter = EVFILT_READ ;\n kqueueop -> changes [ 0 ] . flags = EV_ADD ;\n if ( kevent ( kq , kqueueop -> changes , 1 , kqueueop -> events , NEVENT , NULL ) != 1 || kqueueop -> events [ 0 ] . ident != - 1 || kqueueop -> events [ 0 ] . flags != EV_ERROR ) {\n event_warn ( \"%s: detected broken kqueue;\n not using.\" , __func__ ) ;\n free ( kqueueop -> changes ) ;\n free ( kqueueop -> events ) ;\n free ( kqueueop ) ;\n close ( kq ) ;\n return ( NULL ) ;\n }\n return ( kqueueop ) ;\n }",
        "hash": -7470076990396875111,
        "project": "chrome",
        "size": 43,
        "slice": {
            "malloc": [
                [
                    6,
                    " if ( ( kq = kqueue ( ) ) == - 1 ) {\n"
                ],
                [
                    13,
                    " kqueueop -> changes = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n"
                ],
                [
                    14,
                    " if ( kqueueop -> changes == NULL ) {\n"
                ],
                [
                    18,
                    " kqueueop -> events = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n"
                ],
                [
                    19,
                    " if ( kqueueop -> events == NULL ) {\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static void * kq_init ( struct event_base * base ) {\n"
                ],
                [
                    5,
                    " if ( ! ( kqueueop = calloc ( 1 , sizeof ( struct kqop ) ) ) ) return ( NULL ) ;\n"
                ],
                [
                    6,
                    " if ( ( kq = kqueue ( ) ) == - 1 ) {\n"
                ],
                [
                    8,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    11,
                    " kqueueop -> kq = kq ;\n"
                ],
                [
                    12,
                    " kqueueop -> pid = getpid ( ) ;\n"
                ],
                [
                    14,
                    " if ( kqueueop -> changes == NULL ) {\n"
                ],
                [
                    15,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    19,
                    " if ( kqueueop -> events == NULL ) {\n"
                ],
                [
                    20,
                    " free ( kqueueop -> changes ) ;\n"
                ],
                [
                    21,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    24,
                    " kqueueop -> nevents = NEVENT ;\n"
                ],
                [
                    33,
                    " if ( kevent ( kq , kqueueop -> changes , 1 , kqueueop -> events , NEVENT , NULL ) != 1 || kqueueop -> events [ 0 ] . ident != - 1 || kqueueop -> events [ 0 ] . flags != EV_ERROR ) {\n"
                ],
                [
                    37,
                    " free ( kqueueop -> events ) ;\n"
                ],
                [
                    38,
                    " free ( kqueueop ) ;\n"
                ]
            ],
            "calloc": [
                [
                    1,
                    "static void * kq_init ( struct event_base * base ) {\n"
                ],
                [
                    4,
                    " if ( evutil_getenv ( \"EVENT_NOKQUEUE\" ) ) return ( NULL ) ;\n"
                ],
                [
                    5,
                    " if ( ! ( kqueueop = calloc ( 1 , sizeof ( struct kqop ) ) ) ) return ( NULL ) ;\n"
                ],
                [
                    6,
                    " if ( ( kq = kqueue ( ) ) == - 1 ) {\n"
                ],
                [
                    8,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    14,
                    " if ( kqueueop -> changes == NULL ) {\n"
                ],
                [
                    15,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    19,
                    " if ( kqueueop -> events == NULL ) {\n"
                ],
                [
                    20,
                    " free ( kqueueop -> changes ) ;\n"
                ],
                [
                    21,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    33,
                    " if ( kevent ( kq , kqueueop -> changes , 1 , kqueueop -> events , NEVENT , NULL ) != 1 || kqueueop -> events [ 0 ] . ident != - 1 || kqueueop -> events [ 0 ] . flags != EV_ERROR ) {\n"
                ],
                [
                    37,
                    " free ( kqueueop -> events ) ;\n"
                ],
                [
                    38,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    42,
                    " return ( kqueueop ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void * kq_init ( struct event_base * base ) {\n"
                ],
                [
                    4,
                    " if ( evutil_getenv ( \"EVENT_NOKQUEUE\" ) ) return ( NULL ) ;\n"
                ],
                [
                    5,
                    " if ( ! ( kqueueop = calloc ( 1 , sizeof ( struct kqop ) ) ) ) return ( NULL ) ;\n"
                ],
                [
                    6,
                    " if ( ( kq = kqueue ( ) ) == - 1 ) {\n"
                ],
                [
                    8,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    11,
                    " kqueueop -> kq = kq ;\n"
                ],
                [
                    12,
                    " kqueueop -> pid = getpid ( ) ;\n"
                ],
                [
                    13,
                    " kqueueop -> changes = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n"
                ],
                [
                    14,
                    " if ( kqueueop -> changes == NULL ) {\n"
                ],
                [
                    15,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    18,
                    " kqueueop -> events = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n"
                ],
                [
                    19,
                    " if ( kqueueop -> events == NULL ) {\n"
                ],
                [
                    20,
                    " free ( kqueueop -> changes ) ;\n"
                ],
                [
                    21,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    24,
                    " kqueueop -> nevents = NEVENT ;\n"
                ],
                [
                    33,
                    " if ( kevent ( kq , kqueueop -> changes , 1 , kqueueop -> events , NEVENT , NULL ) != 1 || kqueueop -> events [ 0 ] . ident != - 1 || kqueueop -> events [ 0 ] . flags != EV_ERROR ) {\n"
                ],
                [
                    37,
                    " free ( kqueueop -> events ) ;\n"
                ],
                [
                    38,
                    " free ( kqueueop ) ;\n"
                ],
                [
                    42,
                    " return ( kqueueop ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int _evdns_nameserver_add_impl ( unsigned long int address , int port ) {\n const struct nameserver * server = server_head , * const started_at = server_head ;\n struct nameserver * ns ;\n int err = 0 ;\n if ( server ) {\n do {\n if ( server -> address == address ) return 3 ;\n server = server -> next ;\n }\n while ( server != started_at ) ;\n }\n ns = ( struct nameserver * ) malloc ( sizeof ( struct nameserver ) ) ;\n if ( ! ns ) return - 1 ;\n memset ( ns , 0 , sizeof ( struct nameserver ) ) ;\n evtimer_set ( & ns -> timeout_event , nameserver_prod_callback , ns ) ;\n ns -> socket = socket ( PF_INET , SOCK_DGRAM , 0 ) ;\n if ( ns -> socket < 0 ) {\n err = 1 ;\n goto out1 ;\n }\n evutil_make_socket_nonblocking ( ns -> socket ) ;\n ns -> address = address ;\n ns -> port = htons ( port ) ;\n ns -> state = 1 ;\n event_set ( & ns -> event , ns -> socket , EV_READ | EV_PERSIST , nameserver_ready_callback , ns ) ;\n if ( event_add ( & ns -> event , NULL ) < 0 ) {\n err = 2 ;\n goto out2 ;\n }\n log ( EVDNS_LOG_DEBUG , \"Added nameserver %s\" , debug_ntoa ( address ) ) ;\n if ( ! server_head ) {\n ns -> next = ns -> prev = ns ;\n server_head = ns ;\n }\n else {\n ns -> next = server_head -> next ;\n ns -> prev = server_head ;\n server_head -> next = ns ;\n if ( server_head -> prev == server_head ) {\n server_head -> prev = ns ;\n }\n }\n global_good_nameservers ++ ;\n return 0 ;\n out2 : CLOSE_SOCKET ( ns -> socket ) ;\n out1 : free ( ns ) ;\n log ( EVDNS_LOG_WARN , \"Unable to add nameserver %s: error %d\" , debug_ntoa ( address ) , err ) ;\n return err ;\n }",
        "hash": 2687336064028423153,
        "project": "chrome",
        "size": 49,
        "slice": {
            "memset": [
                [
                    1,
                    "static int _evdns_nameserver_add_impl ( unsigned long int address , int port ) {\n"
                ],
                [
                    13,
                    " if ( ! ns ) return - 1 ;\n"
                ],
                [
                    14,
                    " memset ( ns , 0 , sizeof ( struct nameserver ) ) ;\n"
                ],
                [
                    15,
                    " evtimer_set ( & ns -> timeout_event , nameserver_prod_callback , ns ) ;\n"
                ],
                [
                    25,
                    " event_set ( & ns -> event , ns -> socket , EV_READ | EV_PERSIST , nameserver_ready_callback , ns ) ;\n"
                ],
                [
                    32,
                    " ns -> next = ns -> prev = ns ;\n"
                ],
                [
                    33,
                    " server_head = ns ;\n"
                ],
                [
                    38,
                    " server_head -> next = ns ;\n"
                ],
                [
                    40,
                    " server_head -> prev = ns ;\n"
                ],
                [
                    46,
                    " out1 : free ( ns ) ;\n"
                ]
            ],
            "malloc": [
                [
                    5,
                    " if ( server ) {\n"
                ],
                [
                    10,
                    " while ( server != started_at ) ;\n"
                ],
                [
                    12,
                    " ns = ( struct nameserver * ) malloc ( sizeof ( struct nameserver ) ) ;\n"
                ],
                [
                    13,
                    " if ( ! ns ) return - 1 ;\n"
                ]
            ],
            "free": [
                [
                    1,
                    "static int _evdns_nameserver_add_impl ( unsigned long int address , int port ) {\n"
                ],
                [
                    14,
                    " memset ( ns , 0 , sizeof ( struct nameserver ) ) ;\n"
                ],
                [
                    15,
                    " evtimer_set ( & ns -> timeout_event , nameserver_prod_callback , ns ) ;\n"
                ],
                [
                    17,
                    " if ( ns -> socket < 0 ) {\n"
                ],
                [
                    22,
                    " ns -> address = address ;\n"
                ],
                [
                    23,
                    " ns -> port = htons ( port ) ;\n"
                ],
                [
                    24,
                    " ns -> state = 1 ;\n"
                ],
                [
                    25,
                    " event_set ( & ns -> event , ns -> socket , EV_READ | EV_PERSIST , nameserver_ready_callback , ns ) ;\n"
                ],
                [
                    26,
                    " if ( event_add ( & ns -> event , NULL ) < 0 ) {\n"
                ],
                [
                    45,
                    " out2 : CLOSE_SOCKET ( ns -> socket ) ;\n"
                ],
                [
                    46,
                    " out1 : free ( ns ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int _evdns_nameserver_add_impl ( unsigned long int address , int port ) {\n"
                ],
                [
                    5,
                    " if ( server ) {\n"
                ],
                [
                    10,
                    " while ( server != started_at ) ;\n"
                ],
                [
                    12,
                    " ns = ( struct nameserver * ) malloc ( sizeof ( struct nameserver ) ) ;\n"
                ],
                [
                    13,
                    " if ( ! ns ) return - 1 ;\n"
                ],
                [
                    14,
                    " memset ( ns , 0 , sizeof ( struct nameserver ) ) ;\n"
                ],
                [
                    15,
                    " evtimer_set ( & ns -> timeout_event , nameserver_prod_callback , ns ) ;\n"
                ],
                [
                    17,
                    " if ( ns -> socket < 0 ) {\n"
                ],
                [
                    22,
                    " ns -> address = address ;\n"
                ],
                [
                    23,
                    " ns -> port = htons ( port ) ;\n"
                ],
                [
                    24,
                    " ns -> state = 1 ;\n"
                ],
                [
                    25,
                    " event_set ( & ns -> event , ns -> socket , EV_READ | EV_PERSIST , nameserver_ready_callback , ns ) ;\n"
                ],
                [
                    26,
                    " if ( event_add ( & ns -> event , NULL ) < 0 ) {\n"
                ],
                [
                    32,
                    " ns -> next = ns -> prev = ns ;\n"
                ],
                [
                    33,
                    " server_head = ns ;\n"
                ],
                [
                    38,
                    " server_head -> next = ns ;\n"
                ],
                [
                    40,
                    " server_head -> prev = ns ;\n"
                ],
                [
                    45,
                    " out2 : CLOSE_SOCKET ( ns -> socket ) ;\n"
                ],
                [
                    46,
                    " out1 : free ( ns ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static void evhttp_handle_request ( struct evhttp_request * req , void * arg ) {\n struct evhttp * http = arg ;\n struct evhttp_cb * cb = NULL ;\n if ( req -> uri == NULL ) {\n evhttp_send_error ( req , HTTP_BADREQUEST , \"Bad Request\" ) ;\n return ;\n }\n if ( ( cb = evhttp_dispatch_callback ( & http -> callbacks , req ) ) != NULL ) {\n ( * cb -> cb ) ( req , cb -> cbarg ) ;\n return ;\n }\n if ( http -> gencb ) {\n ( * http -> gencb ) ( req , http -> gencbarg ) ;\n return ;\n }\n else {\n # define ERR_FORMAT \"<html><head>\" \"<title>404 Not Found</title>\" \"</head><body>\" \"<h1>Not Found</h1>\" \"<p>The requested URL %s was not found on this server.</p>\" \"</body></html>\\n\" char * escaped_html = evhttp_htmlescape ( req -> uri ) ;\n struct evbuffer * buf = evbuffer_new ( ) ;\n evhttp_response_code ( req , HTTP_NOTFOUND , \"Not Found\" ) ;\n evbuffer_add_printf ( buf , ERR_FORMAT , escaped_html ) ;\n free ( escaped_html ) ;\n evhttp_send_page ( req , buf ) ;\n evbuffer_free ( buf ) ;\n # undef ERR_FORMAT }\n }",
        "hash": -7076754245473579218,
        "project": "chrome",
        "size": 25,
        "slice": {
            "free": [
                [
                    1,
                    "static void evhttp_handle_request ( struct evhttp_request * req , void * arg ) {\n"
                ],
                [
                    12,
                    " if ( http -> gencb ) {\n"
                ],
                [
                    21,
                    " free ( escaped_html ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static void evhttp_handle_request ( struct evhttp_request * req , void * arg ) {\n"
                ],
                [
                    12,
                    " if ( http -> gencb ) {\n"
                ],
                [
                    21,
                    " free ( escaped_html ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {\n char * protocol ;\n char * number ;\n char * readable ;\n protocol = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n number = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n readable = line ;\n if ( strcmp ( protocol , \"HTTP/1.0\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 0 ;\n }\n else if ( strcmp ( protocol , \"HTTP/1.1\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 1 ;\n }\n else {\n event_debug ( ( \"%s: bad protocol \\\"%s\\\"\" , __func__ , protocol ) ) ;\n return ( - 1 ) ;\n }\n req -> response_code = atoi ( number ) ;\n if ( ! evhttp_valid_response_code ( req -> response_code ) ) {\n event_debug ( ( \"%s: bad response code \\\"%s\\\"\" , __func__ , number ) ) ;\n return ( - 1 ) ;\n }\n if ( ( req -> response_code_line = strdup ( readable ) ) == NULL ) event_err ( 1 , \"%s: strdup\" , __func__ ) ;\n return ( 0 ) ;\n }",
        "hash": -7076754245473579218,
        "project": "chrome",
        "size": 29,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {\n"
                ],
                [
                    5,
                    " protocol = strsep ( & line , \" \" ) ;\n"
                ],
                [
                    8,
                    " if ( line == NULL ) return ( - 1 ) ;\n"
                ],
                [
                    10,
                    " if ( strcmp ( protocol , \"HTTP/1.0\" ) == 0 ) {\n"
                ],
                [
                    11,
                    " req -> major = 1 ;\n"
                ],
                [
                    12,
                    " req -> minor = 0 ;\n"
                ],
                [
                    14,
                    " else if ( strcmp ( protocol , \"HTTP/1.1\" ) == 0 ) {\n"
                ],
                [
                    15,
                    " req -> major = 1 ;\n"
                ],
                [
                    16,
                    " req -> minor = 1 ;\n"
                ],
                [
                    19,
                    " event_debug ( ( \"%s: bad protocol \\\"%s\\\"\" , __func__ , protocol ) ) ;\n"
                ],
                [
                    20,
                    " return ( - 1 ) ;\n"
                ],
                [
                    22,
                    " req -> response_code = atoi ( number ) ;\n"
                ],
                [
                    23,
                    " if ( ! evhttp_valid_response_code ( req -> response_code ) ) {\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {\n"
                ],
                [
                    8,
                    " if ( line == NULL ) return ( - 1 ) ;\n"
                ],
                [
                    9,
                    " readable = line ;\n"
                ],
                [
                    23,
                    " if ( ! evhttp_valid_response_code ( req -> response_code ) ) {\n"
                ],
                [
                    27,
                    " if ( ( req -> response_code_line = strdup ( readable ) ) == NULL ) event_err ( 1 , \"%s: strdup\" , __func__ ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {\n"
                ],
                [
                    5,
                    " protocol = strsep ( & line , \" \" ) ;\n"
                ],
                [
                    8,
                    " if ( line == NULL ) return ( - 1 ) ;\n"
                ],
                [
                    9,
                    " readable = line ;\n"
                ],
                [
                    10,
                    " if ( strcmp ( protocol , \"HTTP/1.0\" ) == 0 ) {\n"
                ],
                [
                    11,
                    " req -> major = 1 ;\n"
                ],
                [
                    12,
                    " req -> minor = 0 ;\n"
                ],
                [
                    14,
                    " else if ( strcmp ( protocol , \"HTTP/1.1\" ) == 0 ) {\n"
                ],
                [
                    15,
                    " req -> major = 1 ;\n"
                ],
                [
                    16,
                    " req -> minor = 1 ;\n"
                ],
                [
                    19,
                    " event_debug ( ( \"%s: bad protocol \\\"%s\\\"\" , __func__ , protocol ) ) ;\n"
                ],
                [
                    20,
                    " return ( - 1 ) ;\n"
                ],
                [
                    22,
                    " req -> response_code = atoi ( number ) ;\n"
                ],
                [
                    23,
                    " if ( ! evhttp_valid_response_code ( req -> response_code ) ) {\n"
                ],
                [
                    27,
                    " if ( ( req -> response_code_line = strdup ( readable ) ) == NULL ) event_err ( 1 , \"%s: strdup\" , __func__ ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int evhttp_connection_incoming_fail ( struct evhttp_request * req , enum evhttp_connection_error error ) {\n switch ( error ) {\n case EVCON_HTTP_TIMEOUT : case EVCON_HTTP_EOF : return ( - 1 ) ;\n case EVCON_HTTP_INVALID_HEADER : default : if ( req -> uri ) {\n free ( req -> uri ) ;\n req -> uri = NULL ;\n }\n ( * req -> cb ) ( req , req -> cb_arg ) ;\n }\n return ( 0 ) ;\n }",
        "hash": -7076754245473579218,
        "project": "chrome",
        "size": 11,
        "slice": {
            "free": [
                [
                    1,
                    "static int evhttp_connection_incoming_fail ( struct evhttp_request * req , enum evhttp_connection_error error ) {\n"
                ],
                [
                    4,
                    " case EVCON_HTTP_INVALID_HEADER : default : if ( req -> uri ) {\n"
                ],
                [
                    5,
                    " free ( req -> uri ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int evhttp_connection_incoming_fail ( struct evhttp_request * req , enum evhttp_connection_error error ) {\n"
                ],
                [
                    4,
                    " case EVCON_HTTP_INVALID_HEADER : default : if ( req -> uri ) {\n"
                ],
                [
                    5,
                    " free ( req -> uri ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n char * method ;\n char * uri ;\n char * version ;\n method = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n uri = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n version = strsep ( & line , \" \" ) ;\n if ( line != NULL ) return ( - 1 ) ;\n if ( strcmp ( method , \"GET\" ) == 0 ) {\n req -> type = EVHTTP_REQ_GET ;\n }\n else if ( strcmp ( method , \"POST\" ) == 0 ) {\n req -> type = EVHTTP_REQ_POST ;\n }\n else if ( strcmp ( method , \"HEAD\" ) == 0 ) {\n req -> type = EVHTTP_REQ_HEAD ;\n }\n else {\n event_debug ( ( \"%s: bad method %s on request %p from %s\" , __func__ , method , req , req -> remote_host ) ) ;\n return ( - 1 ) ;\n }\n if ( strcmp ( version , \"HTTP/1.0\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 0 ;\n }\n else if ( strcmp ( version , \"HTTP/1.1\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 1 ;\n }\n else {\n event_debug ( ( \"%s: bad version %s on request %p from %s\" , __func__ , version , req , req -> remote_host ) ) ;\n return ( - 1 ) ;\n }\n if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n event_debug ( ( \"%s: evhttp_decode_uri\" , __func__ ) ) ;\n return ( - 1 ) ;\n }\n if ( strlen ( req -> uri ) > 0 && req -> uri [ 0 ] != '/' ) req -> flags |= EVHTTP_PROXY_REQUEST ;\n return ( 0 ) ;\n }",
        "hash": -7076754245473579218,
        "project": "chrome",
        "size": 42,
        "slice": {
            "strcmp": [
                [
                    1,
                    "static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n"
                ],
                [
                    5,
                    " method = strsep ( & line , \" \" ) ;\n"
                ],
                [
                    9,
                    " version = strsep ( & line , \" \" ) ;\n"
                ],
                [
                    10,
                    " if ( line != NULL ) return ( - 1 ) ;\n"
                ],
                [
                    11,
                    " if ( strcmp ( method , \"GET\" ) == 0 ) {\n"
                ],
                [
                    12,
                    " req -> type = EVHTTP_REQ_GET ;\n"
                ],
                [
                    14,
                    " else if ( strcmp ( method , \"POST\" ) == 0 ) {\n"
                ],
                [
                    15,
                    " req -> type = EVHTTP_REQ_POST ;\n"
                ],
                [
                    17,
                    " else if ( strcmp ( method , \"HEAD\" ) == 0 ) {\n"
                ],
                [
                    18,
                    " req -> type = EVHTTP_REQ_HEAD ;\n"
                ],
                [
                    21,
                    " event_debug ( ( \"%s: bad method %s on request %p from %s\" , __func__ , method , req , req -> remote_host ) ) ;\n"
                ],
                [
                    22,
                    " return ( - 1 ) ;\n"
                ],
                [
                    24,
                    " if ( strcmp ( version , \"HTTP/1.0\" ) == 0 ) {\n"
                ],
                [
                    25,
                    " req -> major = 1 ;\n"
                ],
                [
                    26,
                    " req -> minor = 0 ;\n"
                ],
                [
                    28,
                    " else if ( strcmp ( version , \"HTTP/1.1\" ) == 0 ) {\n"
                ],
                [
                    29,
                    " req -> major = 1 ;\n"
                ],
                [
                    30,
                    " req -> minor = 1 ;\n"
                ],
                [
                    33,
                    " event_debug ( ( \"%s: bad version %s on request %p from %s\" , __func__ , version , req , req -> remote_host ) ) ;\n"
                ],
                [
                    34,
                    " return ( - 1 ) ;\n"
                ],
                [
                    36,
                    " if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n"
                ]
            ],
            "strlen": [
                [
                    1,
                    "static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n"
                ],
                [
                    36,
                    " if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n"
                ],
                [
                    40,
                    " if ( strlen ( req -> uri ) > 0 && req -> uri [ 0 ] != '/' ) req -> flags |= EVHTTP_PROXY_REQUEST ;\n"
                ]
            ],
            "strdup": [
                [
                    1,
                    "static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n"
                ],
                [
                    7,
                    " uri = strsep ( & line , \" \" ) ;\n"
                ],
                [
                    10,
                    " if ( line != NULL ) return ( - 1 ) ;\n"
                ],
                [
                    24,
                    " if ( strcmp ( version , \"HTTP/1.0\" ) == 0 ) {\n"
                ],
                [
                    28,
                    " else if ( strcmp ( version , \"HTTP/1.1\" ) == 0 ) {\n"
                ],
                [
                    36,
                    " if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n"
                ],
                [
                    37,
                    " event_debug ( ( \"%s: evhttp_decode_uri\" , __func__ ) ) ;\n"
                ],
                [
                    38,
                    " return ( - 1 ) ;\n"
                ],
                [
                    40,
                    " if ( strlen ( req -> uri ) > 0 && req -> uri [ 0 ] != '/' ) req -> flags |= EVHTTP_PROXY_REQUEST ;\n"
                ],
                [
                    41,
                    " return ( 0 ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n"
                ],
                [
                    5,
                    " method = strsep ( & line , \" \" ) ;\n"
                ],
                [
                    7,
                    " uri = strsep ( & line , \" \" ) ;\n"
                ],
                [
                    9,
                    " version = strsep ( & line , \" \" ) ;\n"
                ],
                [
                    10,
                    " if ( line != NULL ) return ( - 1 ) ;\n"
                ],
                [
                    11,
                    " if ( strcmp ( method , \"GET\" ) == 0 ) {\n"
                ],
                [
                    12,
                    " req -> type = EVHTTP_REQ_GET ;\n"
                ],
                [
                    14,
                    " else if ( strcmp ( method , \"POST\" ) == 0 ) {\n"
                ],
                [
                    15,
                    " req -> type = EVHTTP_REQ_POST ;\n"
                ],
                [
                    17,
                    " else if ( strcmp ( method , \"HEAD\" ) == 0 ) {\n"
                ],
                [
                    18,
                    " req -> type = EVHTTP_REQ_HEAD ;\n"
                ],
                [
                    21,
                    " event_debug ( ( \"%s: bad method %s on request %p from %s\" , __func__ , method , req , req -> remote_host ) ) ;\n"
                ],
                [
                    22,
                    " return ( - 1 ) ;\n"
                ],
                [
                    24,
                    " if ( strcmp ( version , \"HTTP/1.0\" ) == 0 ) {\n"
                ],
                [
                    25,
                    " req -> major = 1 ;\n"
                ],
                [
                    26,
                    " req -> minor = 0 ;\n"
                ],
                [
                    28,
                    " else if ( strcmp ( version , \"HTTP/1.1\" ) == 0 ) {\n"
                ],
                [
                    29,
                    " req -> major = 1 ;\n"
                ],
                [
                    30,
                    " req -> minor = 1 ;\n"
                ],
                [
                    33,
                    " event_debug ( ( \"%s: bad version %s on request %p from %s\" , __func__ , version , req , req -> remote_host ) ) ;\n"
                ],
                [
                    34,
                    " return ( - 1 ) ;\n"
                ],
                [
                    36,
                    " if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n"
                ],
                [
                    37,
                    " event_debug ( ( \"%s: evhttp_decode_uri\" , __func__ ) ) ;\n"
                ],
                [
                    38,
                    " return ( - 1 ) ;\n"
                ],
                [
                    40,
                    " if ( strlen ( req -> uri ) > 0 && req -> uri [ 0 ] != '/' ) req -> flags |= EVHTTP_PROXY_REQUEST ;\n"
                ],
                [
                    41,
                    " return ( 0 ) ;\n"
                ]
            ]
        }
    },
    {
        "code": "void evhttp_connection_free ( struct evhttp_connection * evcon ) {\n struct evhttp_request * req ;\n if ( evcon -> fd != - 1 ) {\n if ( evhttp_connected ( evcon ) && evcon -> closecb != NULL ) ( * evcon -> closecb ) ( evcon , evcon -> closecb_arg ) ;\n }\n while ( ( req = TAILQ_FIRST ( & evcon -> requests ) ) != NULL ) {\n TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n evhttp_request_free ( req ) ;\n }\n if ( evcon -> http_server != NULL ) {\n struct evhttp * http = evcon -> http_server ;\n TAILQ_REMOVE ( & http -> connections , evcon , next ) ;\n }\n if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;\n if ( event_initialized ( & evcon -> ev ) ) event_del ( & evcon -> ev ) ;\n if ( evcon -> fd != - 1 ) EVUTIL_CLOSESOCKET ( evcon -> fd ) ;\n if ( evcon -> bind_address != NULL ) free ( evcon -> bind_address ) ;\n if ( evcon -> address != NULL ) free ( evcon -> address ) ;\n if ( evcon -> input_buffer != NULL ) evbuffer_free ( evcon -> input_buffer ) ;\n if ( evcon -> output_buffer != NULL ) evbuffer_free ( evcon -> output_buffer ) ;\n free ( evcon ) ;\n }",
        "hash": -7076754245473579218,
        "project": "chrome",
        "size": 22,
        "slice": {
            "free": [
                [
                    1,
                    "void evhttp_connection_free ( struct evhttp_connection * evcon ) {\n"
                ],
                [
                    4,
                    " if ( evhttp_connected ( evcon ) && evcon -> closecb != NULL ) ( * evcon -> closecb ) ( evcon , evcon -> closecb_arg ) ;\n"
                ],
                [
                    6,
                    " while ( ( req = TAILQ_FIRST ( & evcon -> requests ) ) != NULL ) {\n"
                ],
                [
                    7,
                    " TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n"
                ],
                [
                    10,
                    " if ( evcon -> http_server != NULL ) {\n"
                ],
                [
                    12,
                    " TAILQ_REMOVE ( & http -> connections , evcon , next ) ;\n"
                ],
                [
                    14,
                    " if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;\n"
                ],
                [
                    15,
                    " if ( event_initialized ( & evcon -> ev ) ) event_del ( & evcon -> ev ) ;\n"
                ],
                [
                    16,
                    " if ( evcon -> fd != - 1 ) EVUTIL_CLOSESOCKET ( evcon -> fd ) ;\n"
                ],
                [
                    17,
                    " if ( evcon -> bind_address != NULL ) free ( evcon -> bind_address ) ;\n"
                ],
                [
                    18,
                    " if ( evcon -> address != NULL ) free ( evcon -> address ) ;\n"
                ],
                [
                    19,
                    " if ( evcon -> input_buffer != NULL ) evbuffer_free ( evcon -> input_buffer ) ;\n"
                ],
                [
                    20,
                    " if ( evcon -> output_buffer != NULL ) evbuffer_free ( evcon -> output_buffer ) ;\n"
                ],
                [
                    21,
                    " free ( evcon ) ;\n"
                ]
            ],
            "result": [
                [
                    1,
                    "void evhttp_connection_free ( struct evhttp_connection * evcon ) {\n"
                ],
                [
                    4,
                    " if ( evhttp_connected ( evcon ) && evcon -> closecb != NULL ) ( * evcon -> closecb ) ( evcon , evcon -> closecb_arg ) ;\n"
                ],
                [
                    6,
                    " while ( ( req = TAILQ_FIRST ( & evcon -> requests ) ) != NULL ) {\n"
                ],
                [
                    7,
                    " TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n"
                ],
                [
                    10,
                    " if ( evcon -> http_server != NULL ) {\n"
                ],
                [
                    12,
                    " TAILQ_REMOVE ( & http -> connections , evcon , next ) ;\n"
                ],
                [
                    14,
                    " if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;\n"
                ],
                [
                    15,
                    " if ( event_initialized ( & evcon -> ev ) ) event_del ( & evcon -> ev ) ;\n"
                ],
                [
                    16,
                    " if ( evcon -> fd != - 1 ) EVUTIL_CLOSESOCKET ( evcon -> fd ) ;\n"
                ],
                [
                    17,
                    " if ( evcon -> bind_address != NULL ) free ( evcon -> bind_address ) ;\n"
                ],
                [
                    18,
                    " if ( evcon -> address != NULL ) free ( evcon -> address ) ;\n"
                ],
                [
                    19,
                    " if ( evcon -> input_buffer != NULL ) evbuffer_free ( evcon -> input_buffer ) ;\n"
                ],
                [
                    20,
                    " if ( evcon -> output_buffer != NULL ) evbuffer_free ( evcon -> output_buffer ) ;\n"
                ],
                [
                    21,
                    " free ( evcon ) ;\n"
                ]
            ]
        }
    }
]