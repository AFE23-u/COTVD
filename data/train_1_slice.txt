<1> int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<281> AVBufferRef *qp_table_buf = av_buffer_alloc(qpw);\n<283> if (qp_table_buf) {\n<285> memset(qp_table_buf->data, qp, qpw);\n<287> av_frame_set_qp_table(data, qp_table_buf, 0, FF_QSCALE_TYPE_MPEG1);\n<295> av_log(avctx, AV_LOG_DEBUG, "QP: %d\n", qp);\n<409> uint8_t *dst = &((uint8_t *)s->picture_ptr->data[s->upscale_v])[(s->height - 1) * s->linesize[s->upscale_v]];\n<415> w = s->width >> hshift;\n<431> if (src1 == src2) {\n<433> memcpy(dst, src1, w);\n<437> for (index = 0; index < w; index++)\n<439> dst[index] = (src1[index] + src2[index]) >> 1;\n<443> dst -= s->linesize[s->upscale_v];
<1> int ffurl_connect(URLContext *uc, AVDictionary **options)\n<17> if (err)\n<27> if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, "file"))\n<29> if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
<1> static void * data_create_arabic ( const hb_ot_shape_plan_t * plan ) {\n<2> arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) calloc ( 1 , sizeof ( arabic_shape_plan_t ) ) ;
<1> void mips_malta_init(MachineState *machine)\n<131> if (cpu == NULL) {\n<133> fprintf(stderr, "Unable to find CPU definition\n");\n<161> if (ram_size > (2048u << 20)) {\n<167> ((unsigned int)ram_size / (1 << 20)));\n<431> if (!rom_copy(memory_region_get_ram_ptr(bios_copy),\n<435> memcpy(memory_region_get_ram_ptr(bios_copy),\n<437> memory_region_get_ram_ptr(bios), BIOS_SIZE);
<1> static void gdb_accept(void *opaque)\n<27> } else if (fd >= 0) {\n<45> s = &gdbserver_state;\n<47> memset (s, 0, sizeof (GDBState));\n<57> gdb_syscall_state = s;
<1> static int commit_bitstream_and_slice_buffer(AVCodecContext *avctx,\n<89> if (size > end - current) {\n<97> slice->dwSliceDataLocation = current - dxva_data;\n<115> memcpy(current, &ctx_pic->bitstream[position], size);\n<117> current += size;
<1> static void palmte_init(ram_addr_t ram_size, int vga_ram_size,\n<13> int flash_size = 0x00800000;\n<15> int sdram_size = palmte_binfo.ram_size;\n<35> if (ram_size < flash_size + sdram_size + OMAP15XX_SRAM_SIZE) {\n<37> fprintf(stderr, "This architecture uses %i bytes of memory\n",\n<95> rom_size = get_image_size(option_rom[0]);\n<97> if (rom_size > flash_size) {\n<99> fprintf(stderr, "%s: ROM image too big (%x > %x)\n",\n<109> rom_size = load_image_targphys(option_rom[0], OMAP_CS0_BASE,\n<119> if (rom_size < 0) {\n<131> if (!rom_loaded && !kernel_filename) {\n<133> fprintf(stderr, "Kernel or ROM image must be specified\n");
<1> static void test_evbuffer_find ( void ) {\n<3> const char * test1 = "1234567890\r\n" ;\n<4> const char * test2 = "1234567890\r" ;\n<8> fprintf ( stdout , "Testing evbuffer_find 1: " ) ;\n<9> evbuffer_add ( buf , ( u_char * ) test1 , strlen ( test1 ) ) ;\n<10> evbuffer_drain ( buf , strlen ( test1 ) ) ;\n<11> evbuffer_add ( buf , ( u_char * ) test2 , strlen ( test2 ) ) ;\n<12> p = evbuffer_find ( buf , ( u_char * ) "\r\n" , 2 ) ;\n<13> if ( p == NULL ) {\n<14> fprintf ( stdout , "OK\n" ) ;\n<17> fprintf ( stdout , "FAILED\n" ) ;\n<20> fprintf ( stdout , "Testing evbuffer_find 2: " ) ;\n<21> evbuffer_drain ( buf , strlen ( test2 ) ) ;\n<27> p = evbuffer_find ( buf , ( u_char * ) "xy" , 2 ) ;\n<28> if ( p == NULL ) {\n<29> printf ( "OK\n" ) ;\n<32> fprintf ( stdout , "FAILED\n" ) ;\n<35> fprintf ( stdout , "Testing evbuffer_find 3: " ) ;\n<37> if ( p != NULL && strncmp ( ( char * ) p , "ax" , 2 ) == 0 ) {\n<38> printf ( "OK\n" ) ;\n<41> fprintf ( stdout , "FAILED\n" ) ;
<1> void *checkasm_check_func(void *func, const char *name, ...)\n<17> va_start(arg, name);\n<19> name_length = vsnprintf(name_buf, sizeof(name_buf), name, arg);\n<21> va_end(arg);\n<25> if (!func || name_length <= 0 || name_length >= sizeof(name_buf))\n<31> state.current_func = get_func(name_buf, name_length);
<1> static void kqemu_record_flush(void)\n<13> for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n<17> free(r);
<1> int ff_h263_decode_frame(AVCodecContext *avctx,\n<5> const uint8_t *buf, int buf_size)\n<73> next= ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);\n<77> next= ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n<109> init_get_bits(&s->gb, buf, buf_size*8);\n<621> decode_slice(s);\n<633> if(ff_h263_resync(s)<0)\n<647> decode_slice(s);\n<655> if(!CONFIG_MSMPEG4_DECODER || msmpeg4_decode_ext_header(s, buf_size) < 0){\n<679> if(buf[i]==0 && buf[i+1]==0 && buf[i+2]==1 && buf[i+3]==0xB6){\n<701> if(startcode_found){\n<709> buf_size - current_pos + FF_INPUT_BUFFER_PADDING_SIZE);\n<711> memcpy(s->bitstream_buffer, buf + current_pos, buf_size - current_pos);\n<723> ff_er_frame_end(s);\n<727> MPV_frame_end(s);\n<751> ff_print_debug_info(s, pict);\n<773> return get_consumed_bytes(s, buf_size);
<1> static int usb_host_claim_interfaces(USBHostDevice *dev, int configuration)\n<19> DPRINTF("husb: claiming interfaces. config %d\n", configuration);\n<47> if (dev->descr[i+1] != USB_DT_CONFIG) {\n<59> printf("husb: config #%d need %d\n", dev->descr[i + 5], configuration);\n<63> if (configuration < 0 || configuration == dev->descr[i + 5]) {\n<65> configuration = dev->descr[i + 5];\n<79> if (i >= dev->descr_len) {\n<129> for (interface = 0; interface < nb_interfaces; interface++) {\n<135> if (errno == EBUSY) {\n<137> printf("husb: update iface. device already grabbed\n");\n<155> printf("husb: %d interfaces claimed for configuration %d\n",\n<161> dev->ninterfaces   = nb_interfaces;\n<163> dev->configuration = configuration;
<1> int avformat_open_input(AVFormatContext **ps, const char *filename,\n<123> if (id3v2_extra_meta) {\n<125> if (!strcmp(s->iformat->name, "mp3") || !strcmp(s->iformat->name, "aac") ||\n<127> !strcmp(s->iformat->name, "tta")) {\n<129> if ((ret = ff_id3v2_parse_apic(s, &id3v2_extra_meta)) < 0)\n<135> av_log(s, AV_LOG_DEBUG, "demuxer does not support additional id3 data, skipping\n");\n<139> ff_id3v2_free_extra_meta(&id3v2_extra_meta);\n<143> if ((ret = avformat_queue_attached_pictures(s)) < 0)
<1> void ppm_save(const char *filename, struct DisplaySurface *ds, Error **errp)\n<5> int width = pixman_image_get_width(ds->image);\n<7> int height = pixman_image_get_height(ds->image);\n<23> if (!f) {\n<25> error_setg(errp, "failed to open file '%s': %s", filename,\n<27> strerror(errno));\n<33> ret = fprintf(f, "P6\n%d %d\n%d\n", width, height, 255);\n<35> if (ret < 0) {\n<43> linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, width);\n<45> for (y = 0; y < height; y++) {\n<49> clearerr(f);\n<57> if (ferror(f)) {\n<71> fclose(f);\n<79> error_setg(errp, "failed to write to file '%s': %s", filename,\n<81> strerror(errno));
<1> static void omap_clkm_write(void *opaque, target_phys_addr_t addr,\n<123> if ((s->clkm.clocking_scheme ^ (value >> 11)) & 7) {\n<127> printf("%s: clocking scheme set to %s\n", __FUNCTION__,
<1> iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,\n<35> trace_iscsi_aio_writev(iscsi, sector_num, nb_sectors, opaque, acb);\n<87> acb->task = malloc(sizeof(struct scsi_task));\n<89> if (acb->task == NULL) {\n<101> memset(acb->task, 0, sizeof(struct scsi_task));\n<137> ret = iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,
<1> matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n<75> block_time = (data[0] << 8) | data[1];\n<83> data += 1;\n<121> data += 1;\n<153> data += 1;\n<189> n = matroska_ebmlnum_uint(data, size, &num);\n<201> data += n;\n<213> r = matroska_ebmlnum_sint (data, size, &snum);\n<225> data += r;\n<263> slices = *data++ + 1;\n<287> slice_offset = rv_offset(data, slice, slices);\n<291> slice_size = lace_size[n] - slice_offset;\n<295> slice_size = rv_offset(data, slice+1, slices) - slice_offset;\n<299> if (ppkt)  *ppkt = pkt;\n<303> if (av_new_packet(pkt, slice_size) < 0) {\n<313> memcpy (pkt->data, data+slice_offset, slice_size);\n<331> matroska_queue_packet(matroska, pkt);\n<335> data += lace_size[n];
<1> int main ( int argc , char * argv [ ] ) {\n<8> cpio = & _cpio ;\n<9> memset ( cpio , 0 , sizeof ( * cpio ) ) ;\n<29> cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ;\n<30> cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ;\n<31> cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n<32> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;\n<33> cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;\n<34> cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ;\n<39> if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , "Out of memory" ) ;\n<40> while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) {\n<156> mode_out ( cpio ) ;\n<163> if ( cpio -> option_list ) mode_list ( cpio ) ;\n<164> else mode_in ( cpio ) ;\n<167> mode_pass ( cpio , * cpio -> argv ) ;\n<174> free ( cpio -> destdir ) ;
<1> static inline void gen_op_mfspr (DisasContext *ctx)\n<7> uint32_t sprn = SPR(ctx->opcode);\n<23> if (likely(read_cb != NULL)) {\n<25> if (likely(read_cb != SPR_NOACCESS)) {\n<35> if (loglevel != 0) {\n<37> fprintf(logfile, "Trying to read privileged spr %d %03x\n",\n<43> printf("Trying to read privileged spr %d %03x\n", sprn, sprn);\n<53> if (loglevel != 0) {\n<55> fprintf(logfile, "Trying to read invalid spr %d %03x\n",\n<61> printf("Trying to read invalid spr %d %03x\n", sprn, sprn);
<1> struct vhost_net *vhost_net_init(NetClientState *backend, int devfd,\n<11> if (!backend) {\n<13> fprintf(stderr, "vhost-net requires backend to be setup\n");
<1> QemuOpts *qemu_opts_create(QemuOptsList *list, const char *id, int fail_if_exists)\n<11> opts = qemu_opts_find(list, id);\n<15> if (fail_if_exists) {\n<17> fprintf(stderr, "tried to create id \"%s\" twice for \"%s\"\n",
<1> static void r2d_init(MachineState *machine)\n<9> const char *kernel_cmdline = machine->kernel_cmdline;\n<49> if (cpu == NULL) {\n<51> fprintf(stderr, "Unable to find CPU definition\n");\n<171> memset(&boot_params, 0, sizeof(boot_params));\n<187> if (kernel_size < 0) {\n<189> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);\n<223> if (initrd_size < 0) {\n<225> fprintf(stderr, "qemu: could not load initrd '%s'\n", initrd_filename);\n<245> if (kernel_cmdline) {\n<251> strncpy(boot_params.kernel_cmdline, kernel_cmdline,\n<259> rom_add_blob_fixed("boot_params", &boot_params, sizeof(boot_params),
<1> static void do_video_out(AVFormatContext *s,\n<3> OutputStream *ost,\n<97> if (format_video_sync == VSYNC_AUTO) {\n<99> if(!strcmp(s->oformat->name, "avi")) {\n<101> format_video_sync = VSYNC_VFR;\n<105> format_video_sync = (s->oformat->flags & AVFMT_VARIABLE_FPS) ? ((s->oformat->flags & AVFMT_NOTIMESTAMPS) ? VSYNC_PASSTHROUGH : VSYNC_VFR) : VSYNC_CFR;\n<237> sizeof(ost->last_nb0_frames[0]) * (FF_ARRAY_ELEMS(ost->last_nb0_frames) - 1));\n<313> if (!check_recording_time(ost))\n<353> write_frame(s, &pkt, ost);\n<491> ret = avcodec_encode_video2(enc, &pkt, in_picture, &got_packet);\n<547> write_frame(s, &pkt, ost);\n<553> if (ost->logfile && enc->stats_out) {\n<555> fprintf(ost->logfile, "%s", enc->stats_out);\n<581> do_video_stats(ost, frame_size);
<1> static void bootp_reply(struct bootp_t *bp)\n<43> memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n<47> if ((m = m_get()) == NULL)\n<53> rbp = (struct bootp_t *)m->m_data;\n<57> memset(rbp, 0, sizeof(struct bootp_t));\n<67> if (!bc) {\n<75> memcpy(bc->macaddr, client_ethaddr, 6);\n<79> bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n<81> if (!bc) {\n<97> snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), "%s",\n<107> saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n<125> memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n<139> q = rbp->bp_vend;\n<141> memcpy(q, rfc1533_cookie, 4);\n<143> q += 4;\n<173> *q++ = 4;\n<175> memcpy(q, &saddr.sin_addr, 4);\n<177> q += 4;\n<195> if (!slirp_restrict) {\n<199> *q++ = 4;\n<201> memcpy(q, &saddr.sin_addr, 4);\n<203> q += 4;\n<209> *q++ = 4;\n<211> dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n<213> memcpy(q, &dns_addr, 4);\n<215> q += 4;\n<223> *q++ = 4;\n<225> val = htonl(LEASE_TIME);\n<227> memcpy(q, &val, 4);\n<229> q += 4;\n<233> if (*slirp_hostname) {\n<235> val = strlen(slirp_hostname);\n<239> *q++ = val;\n<241> memcpy(q, slirp_hostname, val);\n<243> q += val;\n<257> udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);
<1> void do_savevm(Monitor *mon, const QDict *qdict)\n<9> QEMUSnapshotInfo sn1, *sn = &sn1, old_sn1, *old_sn = &old_sn1;\n<35> if (!bs) {\n<71> memset(sn, 0, sizeof(*sn));\n<75> pstrcpy(sn->name, sizeof(sn->name), old_sn->name);\n<77> pstrcpy(sn->id_str, sizeof(sn->id_str), old_sn->id_str);\n<83> pstrcpy(sn->name, sizeof(sn->name), name);\n<171> ret = bdrv_snapshot_create(bs1, sn);
<1> int mpeg4_decode_picture_header(MpegEncContext * s)\n<33> if( get_bits_count(&s->gb) > s->gb.size*8){\n<35> printf("no VOP startcode found\n");\n<81> if(get_bits1(&s->gb)){ /* vol control parameter */\n<83> printf("vol control parameter not supported\n");\n<91> if(s->shape != RECT_SHAPE) printf("only rectangular vol supported\n");\n<93> if(s->shape == GRAY_SHAPE && vo_ver_id != 1){\n<95> printf("Gray shape not supported\n");\n<155> if(get_bits1(&s->gb)) printf("interlaced not supported\n");   /* interlaced */\n<157> if(!get_bits1(&s->gb)) printf("OBMC not supported\n");   /* OBMC Disable */\n<169> if(s->vol_sprite_usage==STATIC_SPRITE) printf("Static Sprites not supported\n");\n<213> if(get_bits(&s->gb, 4)!=8) printf("N-bit not supported\n"); /* bits_per_pixel */\n<225> if(get_bits1(&s->gb)) printf("Quant-Type not supported\n");  /* vol_quant_type */ //FIXME\n<235> if(!get_bits1(&s->gb)) printf("Complexity estimation not supported\n");\n<249> if(s->data_partioning){\n<251> printf("data partitioning not supported\n");\n<263> if(s->new_pred){\n<265> printf("new pred not supported\n");\n<275> if(s->reduced_res_vop) printf("reduced resolution VOP not supported\n");\n<291> if (s->scalability) {\n<293> printf("bad scalability!!!\n");\n<305> } else if (startcode == 0x1b2) { //userdata\n<307> char buf[256];\n<319> buf[0]= show_bits(&s->gb, 8);\n<325> if(buf[i]==0) break;\n<331> buf[255]=0;\n<333> e=sscanf(buf, "DivX%dBuild%d", &ver, &build);\n<335> if(e==2){\n<337> s->divx_version= ver;\n<339> s->divx_build= build;\n<341> if(s->picture_number==0){\n<343> printf("This file was encoded with DivX%d Build%d\n", ver, build);\n<345> if(ver==500 && build==413){ //most likely all version are indeed totally buggy but i dunno for sure ...\n<347> printf("WARNING: this version of DivX is not MPEG4 compatible, trying to workaround these bugs...\n");\n<351> printf("hmm, i havnt seen that version of divx yet, lets assume they fixed these bugs ...\n"\n<407> if(check_marker(&s->gb, "before vop_coded")==0 && s->picture_number==0){\n<409> printf("hmm, seems the headers arnt complete, trying to guess time_increment_bits\n");\n<411> for(s->time_increment_bits++ ;s->time_increment_bits<16; s->time_increment_bits++){\n<417> printf("my guess is %d bits ;)\n",s->time_increment_bits);\n<503> mpeg4_decode_sprite_trajectory(s);\n<507> if(s->sprite_brightness_change) printf("sprite_brightness_change not supported\n");\n<509> if(s->vol_sprite_usage==STATIC_SPRITE) printf("static sprite not supported\n");\n<525> if(s->qscale==0){\n<527> printf("Error, header damaged or not MPEG4 header (qscale=0)\n");\n<539> if(s->f_code==0){\n<541> printf("Error, header damaged or not MPEG4 header (f_code=0)\n");
<1> static QObject *parse_keyword(JSONParserContext *ctxt)\n<15> val = token_get_value(token);\n<19> if (!strcmp(val, "true")) {\n<21> return QOBJECT(qbool_from_bool(true));\n<23> } else if (!strcmp(val, "false")) {\n<25> return QOBJECT(qbool_from_bool(false));\n<27> } else if (!strcmp(val, "null")) {\n<29> return qnull();\n<33> parse_error(ctxt, token, "invalid keyword '%s'", val);\n<35> return NULL;
<45> if (rc < 0) {\n<47> error_setg(errp, "cannot get SG_IO version number: %s.  "\n<51> strerror(-rc));
<1> static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n<2> unsigned char * dst = s -> frame . data [ 0 ] ;\n<5> i < s -> avctx -> height && buf_end - buf >= s -> avctx -> width ;\n<7> memcpy ( dst , buf , s -> avctx -> width ) ;\n<8> dst += s -> frame . linesize [ 0 ] ;\n<9> buf += s -> avctx -> width ;
<1> int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name ) {\n<14> if ( ! ( param -> testflag & T_SILENT ) ) printf ( "- Sorting index for MyISAM-table '%s'\n" , name ) ;\n<15> fn_format ( param -> temp_filename , name , "" , MI_NAME_IEXT , 2 + 4 + 32 ) ;
<1> void omap_uwire_attach(struct omap_uwire_s *s,\n<7> if (chipselect < 0 || chipselect > 3) {\n<9> fprintf(stderr, "%s: Bad chipselect %i\n", __FUNCTION__, chipselect);
<1> void *qemu_blockalign0(BlockDriverState *bs, size_t size)\n<5> return memset(qemu_blockalign(bs, size), 0, size);
<1> int kvm_arch_init(KVMState *s, int smp_cpus)\n<15> lm_capable_kernel = strcmp(utsname.machine, "x86_64") == 0;\n<33> if (ret <= 0) {\n<35> fprintf(stderr, "kvm does not support KVM_CAP_SET_TSS_ADDR\n");
<1> int ff_h264_alloc_tables(H264Context *h){\n<17> FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)\n<33> memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n<35> h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n<71> init_dequant_tables(h);
<1> int av_packet_split_side_data(AVPacket *pkt){\n<19> if (size>INT_MAX || p - pkt->data < size)\n<43> for (i=0; ; i++){\n<47> av_assert0(size<=INT_MAX && p - pkt->data >= size);\n<55> if (!pkt->side_data[i].data)\n<59> memcpy(pkt->side_data[i].data, p-size, size);\n<61> pkt->size -= size + 5;\n<63> if(p[4]&128)\n<67> p-= size+5;\n<71> pkt->size -= 8;\n<85> FFMIN(orig_pktsize - pkt->size, FF_INPUT_BUFFER_PADDING_SIZE));
<87> put_ebml_string(pb, MATROSKA_ID_TRACKLANGUAGE, tag && tag->value ? tag->value:"und");\n<89> } else if (tag && tag->value) {\n<91> put_ebml_string(pb, MATROSKA_ID_TRACKLANGUAGE, tag->value);\n<277> if ((tag = av_dict_get(st->metadata, "stereo_mode", NULL, 0)) ||\n<279> (tag = av_dict_get( s->metadata, "stereo_mode", NULL, 0))) {\n<285> for (j=0; j<MATROSKA_VIDEO_STEREO_MODE_COUNT; j++)\n<287> if (!strcmp(tag->value, ff_matroska_video_stereo_mode[j])){\n<289> st_mode = j;
<1> static void cpu_x86_register(X86CPU *cpu, const char *name, Error **errp)\n<7> x86_def_t def1, *def = &def1;\n<11> memset(def, 0, sizeof(*def));\n<15> if (cpu_x86_find_by_name(cpu, def, name) < 0) {
<1> static void virtio_9p_device_realize(DeviceState *dev, Error **errp)\n<13> if (v9fs_device_realize_common(s, errp)) {\n<21> v->config_size = sizeof(struct virtio_9p_config) + strlen(s->fsconf.tag);
<1> static int decode_update_thread_context(AVCodecContext *dst,\n<7> H264Context *h = dst->priv_data, *h1 = src->priv_data;\n<17> if (dst == src || !h1->context_initialized)\n<25> (h->width                 != h1->width                 ||\n<27> h->height                != h1->height                ||\n<29> h->mb_width              != h1->mb_width              ||\n<31> h->mb_height             != h1->mb_height             ||\n<55> h->width     = h1->width;\n<57> h->height    = h1->height;\n<59> h->mb_height = h1->mb_height;\n<61> h->mb_width  = h1->mb_width;\n<63> h->mb_num    = h1->mb_num;\n<65> h->mb_stride = h1->mb_stride;\n<67> h->b_stride  = h1->b_stride;\n<71> if ((err = h264_slice_header_init(h, 1)) < 0) {\n<87> h->linesize   = h1->linesize;\n<89> h->uvlinesize = h1->uvlinesize;\n<95> memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));\n<101> if (!inited) {\n<115> memcpy(h, h1, sizeof(*h1));\n<117> memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n<119> memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n<121> memset(&h->er, 0, sizeof(h->er));\n<123> memset(&h->me, 0, sizeof(h->me));\n<125> memset(&h->mb, 0, sizeof(h->mb));\n<127> memset(&h->mb_luma_dc, 0, sizeof(h->mb_luma_dc));\n<129> memset(&h->mb_padding, 0, sizeof(h->mb_padding));\n<135> memset(&h->cur_pic, 0, sizeof(h->cur_pic));\n<157> ret = ff_h264_alloc_tables(h);\n<167> ret = context_init(h);\n<193> h->thread_context[0] = h;\n<211> h->coded_picture_number = h1->coded_picture_number;\n<213> h->first_field          = h1->first_field;\n<215> h->picture_structure    = h1->picture_structure;\n<217> h->qscale               = h1->qscale;\n<219> h->droppable            = h1->droppable;\n<221> h->data_partitioning    = h1->data_partitioning;\n<223> h->low_delay            = h1->low_delay;\n<229> unref_picture(h, &h->DPB[i]);\n<233> (ret = ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0)\n<241> h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1);\n<243> unref_picture(h, &h->cur_pic);\n<245> if ((ret = ref_picture(h, &h->cur_pic, &h1->cur_pic)) < 0)\n<253> h->low_delay       = h1->low_delay;\n<255> h->droppable       = h1->droppable;\n<263> err = alloc_scratch_buffers(h, h1->linesize);\n<279> if ((ret = copy_parameter_set((void **)h->sps_buffers,\n<289> if ((ret = copy_parameter_set((void **)h->pps_buffers,\n<305> copy_fields(h, h1, dequant4_buffer, dequant4_coeff);\n<331> copy_fields(h, h1, poc_lsb, redundant_pic_count);\n<337> copy_fields(h, h1, short_ref, cabac_init_idc);\n<341> copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1);\n<343> copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1);\n<345> copy_picture_range(h->delayed_pic, h1->delayed_pic,\n<357> h264_set_parameter_from_sps(h);\n<369> err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
<1> static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) {\n<2> MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ;\n<3> if ( avctx == avctx_from ) return 0 ;\n<6> memcpy ( dst -> buf_ptrs , src -> buf_ptrs , sizeof ( src -> buf_ptrs ) ) ;\n<7> memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ;\n<8> memset ( & dst -> buf_ptrs [ dst -> cur_index ] , 0 , sizeof ( AVFrame ) ) ;
<1> static void opt_output_file(const char *filename)\n<11> AVFormatParameters params, *ap = &params;\n<17> if (!strcmp(filename, "-"))\n<19> filename = "pipe:";\n<27> print_error(filename, AVERROR(ENOMEM));\n<37> file_oformat = av_guess_format(last_asked_format, NULL, NULL);\n<39> if (!file_oformat) {\n<41> fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format);\n<51> file_oformat = av_guess_format(NULL, filename, NULL);\n<53> if (!file_oformat) {\n<55> fprintf(stderr, "Unable to find a suitable output format for '%s'\n",\n<69> av_strlcpy(oc->filename, filename, sizeof(oc->filename));\n<73> if (!strcmp(file_oformat->name, "ffm") &&\n<75> av_strstart(filename, "http:", NULL)) {\n<81> int err = read_ffserver_streams(oc, filename);\n<83> if (err < 0) {\n<85> print_error(filename, err);\n<93> use_video = file_oformat->video_codec != CODEC_ID_NONE || video_stream_copy || video_codec_name;\n<95> use_audio = file_oformat->audio_codec != CODEC_ID_NONE || audio_stream_copy || audio_codec_name;\n<97> use_subtitle = file_oformat->subtitle_codec != CODEC_ID_NONE || subtitle_stream_copy || subtitle_codec_name;\n<105> if (nb_input_files > 0) {\n<129> if (audio_disable)    use_audio    = 0;\n<131> if (video_disable)    use_video    = 0;\n<133> if (subtitle_disable) use_subtitle = 0;\n<137> if (use_video)    new_video_stream(oc, nb_output_files);\n<139> if (use_audio)    new_audio_stream(oc, nb_output_files);\n<141> if (use_subtitle) new_subtitle_stream(oc, nb_output_files);\n<145> oc->timestamp = recording_timestamp;\n<149> av_metadata_copy(&oc->metadata, metadata, 0);\n<151> av_metadata_free(&metadata);\n<165> if (!av_filename_number_test(oc->filename)) {\n<167> print_error(oc->filename, AVERROR_NUMEXPECTED);\n<181> if (!file_overwrite &&\n<183> (strchr(filename, ':') == NULL ||\n<185> filename[1] == ':' ||\n<187> av_strstart(filename, "file:", NULL))) {\n<189> if (url_exist(filename)) {\n<191> if (!using_stdin) {\n<193> fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", filename);\n<195> fflush(stderr);\n<197> if (!read_yesno()) {\n<199> fprintf(stderr, "Not overwriting - exiting\n");\n<209> fprintf(stderr,"File '%s' already exists. Exiting.\n", filename);\n<223> if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {\n<235> memset(ap, 0, sizeof(*ap));\n<237> if (av_set_parameters(oc, ap) < 0) {\n<239> fprintf(stderr, "%s: Invalid encoding parameters\n",\n<259> set_context_opts(oc, avformat_opts, AV_OPT_FLAG_ENCODING_PARAM, NULL);
<1> av_cold void dsputil_init(DSPContext* c, AVCodecContext *avctx)\n<519> memset(c->put_2tap_qpel_pixels_tab, 0, sizeof(c->put_2tap_qpel_pixels_tab));\n<521> memset(c->avg_2tap_qpel_pixels_tab, 0, sizeof(c->avg_2tap_qpel_pixels_tab));\n<709> if (HAVE_MMX)        dsputil_init_mmx   (c, avctx);\n<711> if (ARCH_ARM)        dsputil_init_arm   (c, avctx);\n<713> if (CONFIG_MLIB)     dsputil_init_mlib  (c, avctx);\n<715> if (HAVE_VIS)        dsputil_init_vis   (c, avctx);\n<717> if (ARCH_ALPHA)      dsputil_init_alpha (c, avctx);\n<719> if (ARCH_PPC)        dsputil_init_ppc   (c, avctx);\n<721> if (HAVE_MMI)        dsputil_init_mmi   (c, avctx);\n<723> if (ARCH_SH4)        dsputil_init_sh4   (c, avctx);\n<725> if (ARCH_BFIN)       dsputil_init_bfin  (c, avctx);
<1> static int tscc2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> TSCC2Context * c = avctx -> priv_data ;\n<7> int i , val , len , pos = 0 ;\n<53> len = val & 0x3F ;\n<54> val >>= 6 ;\n<55> if ( pos + len > num_mb ) {\n<59> memset ( c -> slice_quants + pos , val , len ) ;\n<60> pos += len ;
<1> static void kvm_fixup_page_sizes(PowerPCCPU *cpu)\n<9> CPUPPCState *env = &cpu->env;\n<19> if (!(env->mmu_model & POWERPC_MMU_64)) {\n<45> memset(&env->sps, 0, sizeof(env->sps));
<1> pp_context_t *pp_get_context(int width, int height, int cpuCaps){\n<3> PPContext *c= memalign(32, sizeof(PPContext));\n<11> memset(c, 0, sizeof(PPContext));\n<31> reallocBuffers(c, width, height, stride);
<1> void mips_cpu_do_interrupt(CPUState *cs)\n<9> CPUMIPSState *env = &cpu->env;\n<55> switch (cs->exception_index) {\n<149> memset(env->CP0_WatchLo, 0, sizeof(env->CP0_WatchLo));\n<159> env->CP0_ErrorEPC = exception_resume_pc(env);\n<189> set_hflags_for_handler(env);
<1> static gboolean logcat_dump_text ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err ) {\n<20> if ( pseudo_header -> logcat . version == 1 ) {\n<26> tag = ( const gchar * ) ( pd + 5 * 4 + 1 ) ;\n<27> log = tag + strlen ( tag ) + 1 ;\n<29> else if ( pseudo_header -> logcat . version == 2 ) {\n<35> tag = ( const char * ) ( pd + 6 * 4 + 1 ) ;\n<36> log = tag + strlen ( tag ) + 1 ;\n<42> str_begin = str_end = log ;\n<43> while ( dumper -> type != DUMP_LONG && ( str_end = strchr ( str_begin , '\n' ) ) ) {\n<44> log_part = ( gchar * ) g_malloc ( str_end - str_begin + 1 ) ;\n<46> str_begin = str_end + 1 ;\n<47> buf = logcat_log ( dumper , * datetime , * nanoseconds / 1000000 , * pid , * tid , priority , tag , log_part ) ;\n<48> if ( ! buf ) {\n<53> length = ( guint32 ) strlen ( buf ) ;\n<54> if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {\n<61> if ( * str_begin != '\0' ) {\n<62> log_part = ( gchar * ) g_malloc ( strlen ( str_begin ) + 1 ) ;\n<63> g_strlcpy ( log_part , str_begin , strlen ( str_begin ) + 1 ) ;\n<64> buf = logcat_log ( dumper , * datetime , * nanoseconds / 1000000 , * pid , * tid , priority , tag , log_part ) ;\n<65> if ( ! buf ) {\n<70> length = ( guint32 ) strlen ( buf ) ;\n<71> if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {
<1> int net_init_tap(QemuOpts *opts, Monitor *mon, const char *name, VLANState *vlan)\n<95> if (qemu_opt_get(opts, "fd")) {\n<113> snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n<121> if (strcmp(downscript, "no") != 0) {\n<123> snprintf(s->down_script, sizeof(s->down_script), "%s", downscript);\n<125> snprintf(s->down_script_arg, sizeof(s->down_script_arg), "%s", ifname);
<1> int ppc_hash32_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n<43> } else if (ret < 0) {\n<147> switch (access_type) {\n<207> printf("DSI: invalid exception (%d)\n", ret);
<1> static int ioreq_map(struct ioreq *ioreq)\n<23> if (ioreq->pages == NULL) {\n<29> ioreq->v.niov, strerror(errno), ioreq->blkdev->cnt_map);\n<53> if (ioreq->page[i] == NULL) {\n<59> ioreq->refs[i], strerror(errno), ioreq->blkdev->cnt_map);
<1> void ide_init_drive(IDEState *s, DriveInfo *dinfo, const char *version)\n<11> if (dinfo && dinfo->bdrv) {\n<43> bdrv_set_change_cb(s->bs, cdrom_change_cb, s);\n<47> strncpy(s->drive_serial_str, drive_get_serial(s->bs),\n<53> if (strlen(s->drive_serial_str) == 0)\n<55> snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n<57> "QM%05d", s->drive_serial);\n<69> ide_reset(s);
<1> static int v9fs_receivefd(int sockfd, int *status)\n<23> memset(&msg, 0, sizeof(msg));\n<37> retval = recvmsg(sockfd, &msg, 0);\n<75> for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
<1> void show_banner(void)\n<9> fprintf(stderr, "  built on %s %s with %s %s\n",\n<15> print_all_libs_info(stderr, INDENT|SHOW_CONFIG);
<1> static ngx_int_t create_request ( ngx_http_request_t * r ) {\n<27> if ( context == NULL ) {\n<30> app_type_string = ( const u_char * ) pp_get_app_type_name ( context -> app_type ) ;\n<31> app_type_string_len = strlen ( ( const char * ) app_type_string ) + 1 ;\n<54> if ( r -> headers_in . host != NULL ) {\n<55> tmp = memchr ( r -> headers_in . host -> value . data , ':' , r -> headers_in . host -> value . len ) ;\n<56> if ( tmp == NULL ) {\n<57> server_name_len = r -> headers_in . host -> value . len ;\n<60> server_name_len = ( int ) ( ( const u_char * ) tmp - r -> headers_in . host -> value . data ) ;\n<74> len += sizeof ( "PASSENGER_APP_TYPE" ) + app_type_string_len ;\n<171> b -> last = ngx_copy ( b -> last , r -> headers_in . host -> value . data , server_name_len ) ;\n<188> b -> last = ngx_copy ( b -> last , app_type_string , app_type_string_len ) ;
<1> static void qio_channel_websock_handshake_process(QIOChannelWebsock *ioc,\n<61> if (!key) {\n<125> if (!g_str_equal(version, QIO_CHANNEL_WEBSOCK_SUPPORTED_VERSION)) {\n<137> if (strlen(key) != QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN) {\n<139> error_setg(errp, "Key length '%zu' was not as expected '%d'",\n<141> strlen(key), QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN);\n<149> if (!g_strrstr(connection, QIO_CHANNEL_WEBSOCK_CONNECTION_UPGRADE)) {\n<169> qio_channel_websock_handshake_send_res_ok(ioc, key, errp);
<1> int ff_mpeg_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n<3> MpegEncContext * s = dst -> priv_data , * s1 = src -> priv_data ;\n<4> if ( dst == src || ! s1 -> context_initialized ) return 0 ;\n<5> if ( ! s -> context_initialized ) {\n<6> memcpy ( s , s1 , sizeof ( MpegEncContext ) ) ;\n<8> s -> picture_range_start += MAX_PICTURE_COUNT ;\n<9> s -> picture_range_end += MAX_PICTURE_COUNT ;\n<10> s -> bitstream_buffer = NULL ;\n<12> ff_MPV_common_init ( s ) ;\n<14> if ( s -> height != s1 -> height || s -> width != s1 -> width || s -> context_reinit ) {\n<17> s -> height = s1 -> height ;\n<18> s -> width = s1 -> width ;\n<19> if ( ( err = ff_MPV_common_frame_size_change ( s ) ) < 0 ) return err ;\n<25> s -> coded_picture_number = s1 -> coded_picture_number ;\n<26> s -> picture_number = s1 -> picture_number ;\n<27> s -> input_picture_number = s1 -> input_picture_number ;\n<28> memcpy ( s -> picture , s1 -> picture , s1 -> picture_count * sizeof ( Picture ) ) ;\n<29> memcpy ( & s -> last_picture , & s1 -> last_picture , ( char * ) & s1 -> last_picture_ptr - ( char * ) & s1 -> last_picture ) ;\n<33> s -> last_picture_ptr = REBASE_PICTURE ( s1 -> last_picture_ptr , s , s1 ) ;\n<34> s -> current_picture_ptr = REBASE_PICTURE ( s1 -> current_picture_ptr , s , s1 ) ;\n<35> s -> next_picture_ptr = REBASE_PICTURE ( s1 -> next_picture_ptr , s , s1 ) ;\n<38> memcpy ( & s -> time_increment_bits , & s1 -> time_increment_bits , ( char * ) & s1 -> shape - ( char * ) & s1 -> time_increment_bits ) ;\n<43> if ( s1 -> bitstream_buffer ) {\n<44> if ( s1 -> bitstream_buffer_size + FF_INPUT_BUFFER_PADDING_SIZE > s -> allocated_bitstream_buffer_size ) av_fast_malloc ( & s -> bitstream_buffer , & s -> allocated_bitstream_buffer_size , s1 -> allocated_bitstream_buffer_size ) ;\n<45> s -> bitstream_buffer_size = s1 -> bitstream_buffer_size ;\n<46> memcpy ( s -> bitstream_buffer , s1 -> bitstream_buffer , s1 -> bitstream_buffer_size ) ;\n<47> memset ( s -> bitstream_buffer + s -> bitstream_buffer_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<49> if ( ! s -> edge_emu_buffer ) if ( s1 -> linesize ) {\n<50> if ( ff_mpv_frame_size_alloc ( s , s1 -> linesize ) < 0 ) {\n<59> memcpy ( & s -> progressive_sequence , & s1 -> progressive_sequence , ( char * ) & s1 -> rtp_mode - ( char * ) & s1 -> progressive_sequence ) ;
<1> static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n<9> uint8_t *ptr = (uint8_t *)buf;\n<15> if (n->promisc)\n<21> if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n<23> int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n<25> if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n<33> if ((ptr[0] & 1) && n->allmulti)\n<39> if (!memcmp(ptr, bcast, sizeof(bcast)))\n<41> return 1;\n<45> if (!memcmp(ptr, n->mac, ETH_ALEN))\n<47> return 1;\n<51> for (i = 0; i < n->mac_table.in_use; i++) {\n<53> if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n<55> return 1;
<1> static int aac_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<217> if ((ret = ff_alloc_packet2(avctx, avpkt, 8192 * s->channels, 0)) < 0)\n<237> memset(chan_el_counter, 0, sizeof(chan_el_counter));\n<239> for (i = 0; i < s->chan_map[0]; i++) {\n<249> cpe      = &s->cpe[i];\n<253> memset(cpe->is_mask, 0, sizeof(cpe->is_mask));\n<255> memset(cpe->ms_mask, 0, sizeof(cpe->ms_mask));\n<259> put_bits(&s->pb, 4, chan_el_counter[tag]++);\n<261> for (ch = 0; ch < chans; ch++) {\n<263> sce = &cpe->ch[ch];\n<271> memset(sce->ics.ltp.used, 0, sizeof(sce->ics.ltp.used));\n<273> memset(sce->ics.prediction_used, 0, sizeof(sce->ics.prediction_used));\n<275> memset(&sce->tns, 0, sizeof(TemporalNoiseShaping));\n<349> s->coder->search_for_tns(s, sce);\n<353> s->coder->apply_tns_filt(s, sce);\n<361> s->coder->search_for_pns(s, avctx, sce);\n<371> s->coder->search_for_is(s, avctx, cpe);\n<375> apply_intensity_stereo(cpe);\n<389> s->coder->search_for_pred(s, sce);\n<397> s->coder->adjust_common_pred(s, cpe);\n<407> s->coder->apply_main_pred(s, sce);\n<419> s->coder->search_for_ms(s, cpe);\n<421> else if (cpe->common_window)\n<423> memset(cpe->ms_mask, 1, sizeof(cpe->ms_mask));\n<425> apply_mid_side_stereo(cpe);\n<429> adjust_frame_information(cpe, chans);\n<441> s->coder->search_for_ltp(s, sce, cpe->common_window);\n<451> s->coder->adjust_common_ltp(s, cpe);\n<471> encode_ms_info(&s->pb, cpe);\n<577> if (ratio > 0.9f && ratio < 1.1f) {\n<593> for (ch = 0; ch < chans; ch++)\n<595> memcpy(cpe->ch[ch].coeffs, cpe->ch[ch].pcoeffs, sizeof(cpe->ch[ch].coeffs));
<1> static int indeo3_decode_frame(AVCodecContext *avctx,\n<39> src = s->cur_frame->Ybuf;\n<41> dest = s->frame.data[0];\n<43> for (y = 0; y < s->height; y++) {\n<45> memcpy(dest, src, s->cur_frame->y_w);\n<47> src += s->cur_frame->y_w;\n<49> dest += s->frame.linesize[0];\n<59> src = s->cur_frame->Ubuf;\n<61> dest = s->frame.data[1];\n<63> for (y = 0; y < s->height / 4; y++) {\n<65> memcpy(dest, src, s->cur_frame->uv_w);\n<67> src += s->cur_frame->uv_w;\n<69> dest += s->frame.linesize[1];\n<75> src = s->cur_frame->Vbuf;\n<77> dest = s->frame.data[2];\n<79> for (y = 0; y < s->height / 4; y++) {\n<81> memcpy(dest, src, s->cur_frame->uv_w);\n<83> src += s->cur_frame->uv_w;\n<85> dest += s->frame.linesize[2];
<1> static void img_copy(uint8_t *dst, int dst_wrap,\n<3> uint8_t *src, int src_wrap,\n<5> int width, int height)\n<9> for(;height > 0; height--) {\n<11> memcpy(dst, src, width);\n<13> dst += dst_wrap;\n<15> src += src_wrap;
<1> static void ini_print_section_header(WriterContext *wctx)\n<19> av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n<21> if (wctx->level == 0) {\n<23> printf("# ffprobe output\n\n");\n<31> if (wctx->nb_item[wctx->level-1])\n<33> printf("\n");\n<43> av_bprintf(&buf, "%s%s", i>1 ? "." : "", wctx->section[i]->name);\n<61> if (!(section->flags & (SECTION_FLAG_IS_ARRAY|SECTION_FLAG_IS_WRAPPER)))\n<63> printf("[%s]\n", buf.str);\n<65> av_bprint_finalize(&buf, NULL);
<1> static void pic_write(void *opaque, target_phys_addr_t addr,\n<3> uint64_t value, unsigned int size)\n<9> D(printf("%s addr=%x val=%x\n", __func__, addr, value));\n<13> if (addr == R_RW_MASK) {\n<15> fs->regs[R_RW_MASK] = value;
<1> static int ffv1_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<7> FFV1Context *f      = avctx->priv_data;\n<53> write_header(f);\n<101> buf_p = pkt->data;\n<127> if (i > 0 || f->version > 2) {\n<129> av_assert0(bytes < pkt->size / f->slice_count);\n<131> memmove(buf_p, fs->c.bytestream_start, bytes);\n<133> av_assert0(bytes < (1 << 24));\n<135> AV_WB24(buf_p + bytes, bytes);\n<145> buf_p[bytes++] = 0;\n<147> v = av_crc(av_crc_get_table(AV_CRC_32_IEEE), 0, buf_p, bytes);\n<155> buf_p += bytes;\n<161> if ((avctx->flags & AV_CODEC_FLAG_PASS1) && (f->picture_number & 31) == 0) {\n<165> char *p   = avctx->stats_out;\n<171> memset(f->rc_stat, 0, sizeof(f->rc_stat));\n<173> for (i = 0; i < f->quant_table_count; i++)\n<175> memset(f->rc_stat2[i], 0, f->context_count[i] * sizeof(*f->rc_stat2[i]));\n<209> for (j = 0; j < 256; j++) {\n<215> p += strlen(p);\n<219> snprintf(p, end - p, "\n");\n<227> for (m = 0; m < 32; m++) {\n<233> p += strlen(p);\n<239> snprintf(p, end - p, "%d\n", f->gob_count);
<73> for (i = 0; i < size >> TARGET_PAGE_BITS; i++) {\n<137> if (!xs_write(state->xenstore, 0, path, value, strlen(value))) {\n<151> if (!xs_write(state->xenstore, 0, path, value, strlen(value))) {\n<157> if (mr_name) {\n<165> if (!xs_write(state->xenstore, 0, path, mr_name, strlen(mr_name))) {
<1> static void a9_scu_write(void *opaque, target_phys_addr_t offset,\n<3> uint64_t value, unsigned size)\n<13> switch (size) {\n<35> fprintf(stderr, "Invalid size %u in write to a9 scu register %x\n",
<1> static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)\n<89> r->buflen = MAX(4096, req->cmd.xfer);\n<99> outbuf = r->iov.iov_base;\n<101> switch (req->cmd.buf[0]) {\n<209> memset(outbuf, 0, 8);\n<339> if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n<343> memset(outbuf, 0, req->cmd.xfer);\n<413> buflen = req->cmd.xfer;\n<539> r->iov.iov_len = MIN(buflen, req->cmd.xfer);
<1> static int svq3_decode_mb (H264Context *h, unsigned int mb_type) {\n<51> svq3_mc_dir (h, mb_type, PREDICT_MODE, 1, 1);\n<117> if (s->mb_y > 0) {\n<119> memcpy (h->mv_cache[m][scan8[0] - 1*8], s->current_picture.motion_val[m][b_xy - h->b_stride], 4*2*sizeof(int16_t));\n<121> memset (&h->ref_cache[m][scan8[0] - 1*8], (h->intra4x4_pred_mode[mb_xy - s->mb_stride][4] == -1) ? PART_NOT_AVAILABLE : 1, 4);\n<151> memset (&h->ref_cache[m][scan8[0] - 1*8 - 1], PART_NOT_AVAILABLE, 8);\n<167> svq3_mc_dir (h, (mb_type - 1), mode, 0, 0);\n<173> svq3_mc_dir (h, 0, mode, 0, 0);\n<177> for (i=0; i < 4; i++) {\n<179> memset (s->current_picture.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<187> svq3_mc_dir (h, 0, mode, 1, (mb_type == 3));\n<191> for (i=0; i < 4; i++) {\n<193> memset (s->current_picture.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<205> } else if (mb_type == 8 || mb_type == 33) {	/* INTRA4x4 */\n<207> memset (h->intra4x4_pred_mode_cache, -1, 8*5*sizeof(int8_t));\n<265> left	= &h->intra4x4_pred_mode_cache[scan8[i] - 1];\n<267> top	= &h->intra4x4_pred_mode_cache[scan8[i] - 8];\n<285> for (i=0; i < 4; i++) {\n<287> memset (&h->intra4x4_pred_mode_cache[scan8[0] + 8*i], DC_PRED, 4);\n<295> write_back_intra_pred_mode (h);\n<301> check_intra4x4_pred_mode (h);\n<311> for (i=0; i < 4; i++) {\n<313> memset (&h->intra4x4_pred_mode_cache[scan8[0] + 8*i], DC_128_PRED, 4);\n<337> if ((h->intra16x16_pred_mode = check_intra_pred_mode (h, dir)) == -1)\n<353> for (i=0; i < 4; i++) {\n<355> memset (s->current_picture.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<361> for (i=0; i < 4; i++) {\n<363> memset (s->current_picture.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<371> if (!IS_INTRA4x4(mb_type)) {\n<373> memset (h->intra4x4_pred_mode[mb_xy], DC_PRED, 8);\n<377> if (!IS_SKIP(mb_type) || s->pict_type == B_TYPE) {\n<379> memset (h->non_zero_count_cache + 8, 0, 4*9*sizeof(uint8_t));\n<493> h->chroma_pred_mode = check_intra_pred_mode (h, DC_PRED8x8);
<1> static int pcm_decode_frame(AVCodecContext *avctx,\n<31> samples = data;\n<33> src = buf;\n<95> switch(avctx->codec->id) {\n<257> memcpy(samples, src, n*sample_size);\n<259> src += n*sample_size;
<1> static uint64_t pxa2xx_fir_read(void *opaque, hwaddr addr,\n<33> if (s->rx_len) {\n<47> printf("%s: Rx FIFO underrun.\n", __FUNCTION__);
<1> int ff_mjpeg_decode_sof(MJpegDecodeContext *s)\n<95> if (s->ls && !(s->bits <= 8 || nb_components == 1)) {\n<113> memset(s->h_count, 0, sizeof(s->h_count));\n<115> memset(s->v_count, 0, sizeof(s->v_count));\n<479> if (s->progressive) {\n<501> memset(s->coefs_finished, 0, sizeof(s->coefs_finished));
<1> static int mov_read_stsd(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n<169> get_buffer(pb, codec_name, 32); /* codec name, pascal string */\n<171> if (codec_name[0] <= 31) {\n<173> memcpy(st->codec->codec_name, &codec_name[1],codec_name[0]);\n<175> st->codec->codec_name[codec_name[0]] = 0;
<1> int kvm_cpu_exec(CPUState *cpu)\n<35> cpu->kvm_vcpu_dirty = false;\n<71> attrs = kvm_arch_post_run(cpu, run);\n<77> if (run_ret == -EINTR || run_ret == -EAGAIN) {\n<89> strerror(-run_ret));\n<115> trace_kvm_run_exit(cpu->cpu_index, run->exit_reason);\n<185> ret = kvm_handle_internal_error(cpu, run);\n<213> ret = kvm_arch_handle_exit(cpu, run);\n<225> ret = kvm_arch_handle_exit(cpu, run);\n<235> if (ret < 0) {\n<237> cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_CODE);
<1> static void virt_set_gic_version(Object *obj, const char *value, Error **errp)\n<9> if (!strcmp(value, "3")) {\n<11> vms->gic_version = 3;\n<13> } else if (!strcmp(value, "2")) {\n<15> vms->gic_version = 2;\n<17> } else if (!strcmp(value, "host")) {\n<19> vms->gic_version = 0; /* Will probe later */\n<23> error_report("Invalid gic-version option value");\n<25> error_printf("Allowed gic-version values are: 3, 2, host\n");\n<27> exit(1);
<1> int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)\n<7> uint8_t buf[256];\n<9> uint8_t type = value >> 8;\n<17> switch(type) {\n<21> ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));\n<31> ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));\n<41> ret = usb_desc_string(dev, index, buf, sizeof(buf));\n<49> fprintf(stderr, "%s: %d unknown type %d (len %zd)\n", __FUNCTION__,\n<59> if (ret > 0) {\n<61> if (ret > len) {\n<63> ret = len;\n<67> memcpy(dest, buf, ret);\n<71> return ret;
<1> static ssize_t qio_channel_socket_readv(QIOChannel *ioc,\n<21> char control[CMSG_SPACE(sizeof(int) * SOCKET_MAX_FDS)];\n<27> memset(control, 0, CMSG_SPACE(sizeof(int) * SOCKET_MAX_FDS));\n<45> msg.msg_control = control;
<1> static void test_acpi_piix4_tcg_memhp(void)\n<9> memset(&data, 0, sizeof(data));\n<15> test_acpi_one(" -m 128,slots=3,maxmem=1G -numa node", &data);\n<17> free_test_data(&data);
<1> static int evhttp_connection_incoming_fail ( struct evhttp_request * req , enum evhttp_connection_error error ) {\n<4> case EVCON_HTTP_INVALID_HEADER : default : if ( req -> uri ) {\n<5> free ( req -> uri ) ;
<1> static char *vio_format_dev_name(VIOsPAPRDevice *dev)\n<5> VIOsPAPRDeviceInfo *info = (VIOsPAPRDeviceInfo *)qdev_get_info(&dev->qdev);\n<13> if (asprintf(&name, "%s@%x", info->dt_name, dev->reg) < 0) {\n<15> return NULL;\n<21> return name;
<1> static int rtl8139_cplus_transmit_one(RTL8139State *s)\n<425> int hlen = 0;\n<433> uint8_t *eth_payload_data = NULL;\n<451> eth_payload_data = saved_buffer + ETH_HLEN;\n<477> ip_data_len = be16_to_cpu(ip->ip_len) - hlen;\n<497> if (hlen<sizeof(ip_header) || hlen>eth_payload_len) {/* min header length */\n<513> DPRINTF("+++ C+ mode IP header len=%d checksum=%04x\n",\n<523> if ((txdw0 & CP_TX_LGSEN) && ip_protocol == IP_PROTO_TCP)\n<549> uint8_t saved_ip_header[60];\n<555> memcpy(saved_ip_header, eth_payload_data, hlen);\n<561> uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;\n<569> tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);\n<573> int tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);\n<581> int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;\n<585> DPRINTF("+++ C+ mode TSO IP data len %d TCP hlen %d TCP "\n<603> for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)\n<607> uint16_t chunk_size = tcp_chunk_size;\n<619> chunk_size = tcp_data_len - tcp_send_offset;\n<627> be32_to_cpu(p_tcp_hdr->th_seq));\n<635> memcpy(data_to_checksum, saved_ip_header + 12, 8);\n<647> if (tcp_send_offset)\n<651> memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);\n<663> TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN);\n<671> ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;\n<677> p_tcpip_hdr->ip_payload = cpu_to_be16(tcp_hlen + chunk_size);\n<685> int tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + 12);\n<693> p_tcp_hdr->th_sum = tcp_checksum;\n<699> memcpy(eth_payload_data, saved_ip_header, hlen);\n<705> ip->ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);\n<717> ip->ip_sum = ip_checksum(eth_payload_data, hlen);\n<725> int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;\n<739> p_tcp_hdr->th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr->th_seq));\n<753> else if (txdw0 & (CP_TX_TCPCS|CP_TX_UDPCS))\n<763> uint8_t saved_ip_header[60];\n<765> memcpy(saved_ip_header, eth_payload_data, hlen);\n<769> uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;\n<779> memcpy(data_to_checksum, saved_ip_header + 12, 8);\n<793> ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;\n<803> tcp_header* p_tcp_hdr = (tcp_header *) (data_to_checksum+12);\n<811> int tcp_checksum = ip_checksum(data_to_checksum, ip_data_len + 12);\n<833> ip_pseudo_header *p_udpip_hdr = (ip_pseudo_header *)data_to_checksum;\n<843> udp_header *p_udp_hdr = (udp_header *) (data_to_checksum+12);\n<851> int udp_checksum = ip_checksum(data_to_checksum, ip_data_len + 12);\n<867> memcpy(eth_payload_data, saved_ip_header, hlen);
<1> static void vp6_parse_coeff_models(VP56Context *s)\n<19> memset(def_prob, 0x80, sizeof(def_prob));\n<31> model->coeff_dccv[pt][node] = def_prob[node];\n<35> model->coeff_dccv[pt][node] = def_prob[node];\n<49> vp6_coeff_order_table_init(s);\n<77> model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n<81> model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n<87> if (s->use_huffman) {\n<103> vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],\n<111> memset(s->nb_null, 0, sizeof(s->nb_null));
<1> int jbig2_decode_halftone_mmr ( Jbig2Ctx * ctx , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image , size_t * consumed_bytes ) {\n<3> const int rowstride = image -> stride ;\n<4> byte * dst = image -> data ;\n<11> y < image -> height ;\n<13> memset ( dst , 0 , rowstride ) ;\n<14> code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n<17> dst += rowstride ;
<1> static int cris_mmu_translate_page(struct cris_mmu_result_t *res,\n<3> CPUState *env, uint32_t vaddr,\n<5> int rw, int usermode)\n<15> uint32_t tlb_vpn, tlb_pfn = 0;\n<35> r_cause = env->sregs[SFR_R_MM_CAUSE];\n<61> vpage = vaddr >> 13;\n<97> idx = vpage & 15;\n<99> for (set = 0; set < 4; set++)\n<109> tlb_vpn = EXTRACT_FIELD(hi, 13, 31);\n<111> tlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n<115> D(printf("TLB[%d][%d] v=%x vpage=%x -> pfn=%x lo=%x hi=%x\n",\n<119> if (tlb_vpn == vpage) {\n<145> tlb_pid = EXTRACT_FIELD(hi, 0, 7);\n<147> tlb_pfn = EXTRACT_FIELD(lo, 13, 31);\n<157> tlb_x = EXTRACT_FIELD(lo, 0, 0);\n<183> && tlb_pid != (env->pregs[PR_PID] & 0xff)) {\n<193> } else if (rw == 1 && cfg_w && !tlb_w) {\n<203> } else if (cfg_v && !tlb_v) {\n<205> D(printf ("tlb: invalid %x\n", vaddr));\n<207> set_field(&r_cause, rwcause, 8, 9);\n<235> D(dump_tlb(env, mmu));\n<241> env->sregs[SFR_RW_MM_TLB_LO] = lo;\n<247> if (!match) {\n<259> env->sregs[SFR_RW_MM_TLB_SEL] = 0;\n<261> set_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);\n<263> set_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 5);\n<269> set_field(&r_cause, rwcause, 8, 2);\n<271> set_field(&r_cause, vpage, 13, 19);\n<273> set_field(&r_cause, env->pregs[PR_PID], 0, 8);\n<277> D(printf("refill vaddr=%x pc=%x\n", vaddr, env->pc));\n<285> D(printf ("%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x"\n<305> res->pfn = tlb_pfn;\n<307> return !match;
<2> if ( dcfg == NULL ) return ;\n<64> if ( dcfg -> crypto_key == NOT_SET_P ) dcfg -> crypto_key = getkey ( dcfg -> mp ) ;\n<65> if ( dcfg -> crypto_key_len == NOT_SET ) dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ;
<1> int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)\n<7> void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,\n<15> if (status != CL_SUCCESS) {\n<23> memcpy(dst_buf, mapped, buf_size);\n<27> status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);
<1> int MDC2_Update ( MDC2_CTX * c , const unsigned char * in , size_t len ) {\n<5> if ( i + len < MDC2_BLOCK ) {\n<6> memcpy ( & ( c -> data [ i ] ) , in , len ) ;\n<7> c -> num += ( int ) len ;\n<11> j = MDC2_BLOCK - i ;\n<12> memcpy ( & ( c -> data [ i ] ) , in , j ) ;\n<13> len -= j ;\n<14> in += j ;\n<16> mdc2_body ( c , & ( c -> data [ 0 ] ) , MDC2_BLOCK ) ;\n<20> if ( i > 0 ) mdc2_body ( c , in , i ) ;\n<22> if ( j > 0 ) {\n<23> memcpy ( & ( c -> data [ 0 ] ) , & ( in [ i ] ) , j ) ;\n<24> c -> num = ( int ) j ;
<1> static void test_qemu_strtoull_overflow(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoull(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n<19> if (!env->mcg_cap) {\n<21> fprintf(stderr, "MCE support is not enabled!\n");
<1> static void filter_channel(MLPDecodeContext *m, unsigned int substr,\n<9> int32_t firbuf[MAX_BLOCKSIZE + MAX_FIR_ORDER];\n<11> int32_t iirbuf[MAX_BLOCKSIZE + MAX_IIR_ORDER];\n<29> MAX_FIR_ORDER * sizeof(int32_t));\n<33> MAX_IIR_ORDER * sizeof(int32_t));\n<77> firbuf[index] = result;\n<79> iirbuf[index] = result - accum;\n<91> MAX_FIR_ORDER * sizeof(int32_t));\n<95> MAX_IIR_ORDER * sizeof(int32_t));
<1> static void sdl_resize(DisplayState *ds, int w, int h)\n<23> if (!screen) {\n<25> fprintf(stderr, "Could not open SDL display\n");
<1> static int execute_code ( AVCodecContext * avctx , int c ) {\n<50> if ( ret < 0 ) {\n<56> memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n<65> if ( s -> y < avctx -> height - s -> font_height ) memset ( s -> frame . data [ 0 ] + ( s -> y + s -> font_height ) * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , ( avctx -> height - s -> y - s -> font_height ) * s -> frame . linesize [ 0 ] ) ;\n<68> if ( s -> y > 0 ) memset ( s -> frame . data [ 0 ] , DEFAULT_BG_COLOR , s -> y * s -> frame . linesize [ 0 ] ) ;
<1> static abi_long do_recvfrom(int fd, abi_ulong msg, size_t len, int flags,\n<19> host_msg = lock_user(VERIFY_WRITE, msg, len, 0);\n<21> if (!host_msg)\n<25> if (target_addr) {\n<35> if (addrlen < 0 || addrlen > MAX_SOCK_ADDR) {\n<43> addr = alloca(addrlen);\n<45> ret = get_errno(recvfrom(fd, host_msg, len, flags, addr, &addrlen));\n<51> ret = get_errno(recv(fd, host_msg, len, flags));\n<55> if (!is_error(ret)) {\n<59> host_to_target_sockaddr(target_addr, addr, addrlen);\n<61> if (put_user_u32(addrlen, target_addrlen)) {\n<71> unlock_user(host_msg, msg, len);\n<77> unlock_user(host_msg, msg, 0);
<1> static inline void mix_2f_1r_to_stereo(AC3DecodeContext *ctx)\n<19> memset(output[3], 0, sizeof(output[3]));
<1> int # ifdef GLOB_ATTRIBUTE GLOB_ATTRIBUTE # endif glob ( pattern , flags , errfunc , pglob ) const char * pattern ;\n<209> dirname = home_dir ;\n<210> dirlen = strlen ( dirname ) ;\n<223> char * end_name = strchr ( dirname , '/' ) ;\n<324> meta = __glob_pattern_type ( dirname , ! ( flags & GLOB_NOESCAPE ) ) ;
<1> static int mono_decode(COOKContext *q, COOKSubpacket *p, float *mlt_buffer)\n<5> int category_index[128];\n<9> int category[128];\n<15> memset(&category,       0, sizeof(category));\n<17> memset(&category_index, 0, sizeof(category_index));\n<27> categorize(q, p, quant_index_table, category, category_index);\n<29> expand_category(q, category, category_index);\n<31> decode_vectors(q, p, category, quant_index_table, mlt_buffer);
<1> int MBS_ReadHeader ( int fd , MBSPatchHeader * header ) {\n<2> int s = read ( fd , header , sizeof ( MBSPatchHeader ) ) ;\n<12> if ( s ) return READ_ERROR ;\n<13> if ( memcmp ( header -> tag , "MBDIFF10" , 8 ) != 0 ) return UNEXPECTED_ERROR ;\n<14> if ( sizeof ( MBSPatchHeader ) + header -> cblen + header -> difflen + header -> extralen != int ( hs . st_size ) ) return UNEXPECTED_ERROR ;
<1> static int img_info(int argc, char **argv)\n<19> output = NULL;\n<65> output = optarg;\n<83> if (output && !strcmp(output, "json")) {\n<85> output_format = OFORMAT_JSON;\n<87> } else if (output && !strcmp(output, "human")) {\n<89> output_format = OFORMAT_HUMAN;\n<91> } else if (output) {\n<101> bs = bdrv_new_open(filename, fmt, BDRV_O_FLAGS | BDRV_O_NO_BACKING);\n<103> if (!bs) {
<1> main (void)\n<5> struct timeval t_m = {0, 0};\n<9> struct timeval t_m1 = {0, 0};\n<21> for (i = 1; i < 10000; i++)\n<23> if (gettimeofday (&t_m1, NULL) != 0)\n<29> if (t_m1.tv_sec * 1000000 + t_m1.tv_usec\n<31> != (t_m.tv_sec * 1000000 + t_m.tv_usec + i * 1000))\n<35> fprintf (stderr, "t0 (%ld, %ld), i %d, t1 (%ld, %ld)\n",\n<45> if (time (NULL) != t_m1.tv_sec)\n<49> fprintf (stderr, "time != gettod\n");\n<57> printf ("pass\n");
<1> static gboolean ga_channel_open(GAChannel *c, const gchar *path,\n<29> if (fd == -1) {\n<31> g_critical("error opening channel: %s", strerror(errno));\n<81> if (fd == -1) {\n<83> g_critical("error opening channel: %s", strerror(errno));\n<139> if (fd < 0) {\n<141> Error *local_err = NULL;\n<145> fd = unix_listen(path, NULL, strlen(path), &local_err);\n<147> if (local_err != NULL) {\n<149> g_critical("%s", error_get_pretty(local_err));\n<151> error_free(local_err);\n<159> ga_channel_listen_add(c, fd, true);
<1> static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) {\n<22> np != NULL ;\n<27> if ( ( int ) ( l = np -> file -> basename_utf16 . length ) > ffmax ) l = ffmax ;\n<28> p = malloc ( ( l + 1 ) * 2 ) ;\n<29> if ( p == NULL ) {\n<33> memcpy ( p , np -> file -> basename_utf16 . s , l ) ;\n<34> p [ l ] = 0 ;\n<35> p [ l + 1 ] = 0 ;\n<36> np -> identifier = ( char * ) p ;\n<37> lt = l ;\n<38> dot = p + l ;\n<41> if ( ! joliet_allowed_char ( p [ 0 ] , p [ 1 ] ) ) archive_be16enc ( p , 0x005F ) ;\n<42> else if ( p [ 0 ] == 0 && p [ 1 ] == 0x2E ) dot = p ;\n<43> p += 2 ;\n<48> np -> ext_len = ( int ) l - ext_off ;\n<49> np -> id_len = ( int ) l ;\n<51> if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) {\n<64> if ( ( int ) l == ffmax ) noff = ext_off - 6 ;\n<65> else if ( ( int ) l == ffmax - 2 ) noff = ext_off - 4 ;\n<66> else if ( ( int ) l == ffmax - 4 ) noff = ext_off - 2 ;
<1> int check_params(const char * const *params, const char *str)\n<17> for (i = 0; params[i] != NULL; i++) {\n<19> len = strlen(params[i]) + 1;\n<21> if (len > name_buf_size) {\n<37> p = get_opt_name(name_buf, name_buf_size, p, '=');\n<49> for(i = 0; params[i] != NULL; i++)\n<51> if (!strcmp(params[i], name_buf))\n<55> if (params[i] == NULL) {\n<75> qemu_free(name_buf);
<1> static unsigned int dec_movs_r(DisasContext *dc)\n<7> int size = memsize_z(dc);\n<11> memsize_char(size),\n<17> cris_cc_mask(dc, CC_MASK_NZ);
<1> static int decode_svq1_block (bit_buffer_t *bitbuf, uint8_t *pixels, int pitch, int intra) {\n<75> dst = (uint32_t *) list[i];\n<77> width = 1 << ((4 + level) /2);\n<111> for (y=0; y < height; y++) {\n<113> memset (&dst[y*(pitch / 4)], 0, width);\n<195> mean	    = vlc->value;\n<203> for (y=0; y < height; y++) {\n<205> memset (&dst[y*(pitch / 4)], mean, width);\n<311> dst += (pitch / 4);
<1> void check_file_fixed_eof_mmaps(void)\n<27> fprintf (stderr, "%s addr=%p", __func__, (void *)addr);\n<83> fprintf (stderr, " passed\n");
<1> static int gif_image_write_image(AVCodecContext *avctx,\n<7> const uint8_t *buf, const int linesize,\n<13> GIFContext *s = avctx->priv_data;\n<15> int len = 0, height = avctx->height, width = avctx->width, x, y;\n<29> const uint8_t *ref = s->last_frame->data[0];\n<41> while (y_start < y_end) {\n<43> if (memcmp(ref + y_start*ref_linesize, buf + y_start*linesize, width))\n<47> y_start++;\n<51> while (y_end > y_start) {\n<53> if (memcmp(ref + y_end*ref_linesize, buf + y_end*linesize, width))\n<57> y_end--;\n<179> pal_exdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n<181> if (!pal_exdata)\n<185> memcpy(pal_exdata, s->palette, AVPALETTE_SIZE);\n<203> ff_lzw_encode_init(s->lzw, s->buf, 2 * width * height,\n<209> ptr = buf + y_start*linesize + x_start;\n<219> for (y = 0; y < height; y++) {\n<221> memcpy(s->tmpl, ptr, width);\n<223> for (x = 0; x < width; x++)\n<225> if (ref[x] == ptr[x])\n<227> s->tmpl[x] = trans;\n<229> len += ff_lzw_encode(s->lzw, s->tmpl, width);\n<231> ptr += linesize;
<1> static void ide_init1(IDEBus *bus, int unit)\n<7> IDEState *s = &bus->ifs[unit];\n<21> s->io_buffer = qemu_memalign(2048, s->io_buffer_total_len);\n<23> memset(s->io_buffer, 0, s->io_buffer_total_len);\n<27> s->smart_selftest_data = qemu_blockalign(s->bs, 512);\n<29> memset(s->smart_selftest_data, 0, 512);
<1> static BusState *qbus_find(const char *path)\n<9> char elem[128], msg[256];\n<17> if (path[0] == '/') {\n<21> pos = 0;\n<25> if (sscanf(path, "%127[^/]%n", elem, &len) != 1) {\n<27> qemu_error("path parse error (\"%s\")\n", path);\n<29> return NULL;\n<33> bus = qbus_find_recursive(main_system_bus, elem, NULL);\n<35> if (!bus) {\n<43> pos = len;\n<51> if (path[pos] == '\0') {\n<63> if (sscanf(path+pos, "/%127[^/]%n", elem, &len) != 1) {\n<65> qemu_error("path parse error (\"%s\" pos %d)\n", path, pos);\n<67> return NULL;\n<71> pos += len;\n<73> dev = qbus_find_dev(bus, elem);\n<75> if (!dev) {\n<85> if (path[pos] == '\0') {\n<95> qemu_error("device has no child bus (%s)\n", path);\n<107> qemu_error("device has multiple child busses (%s)\n%s\n",\n<121> if (sscanf(path+pos, "/%127[^/]%n", elem, &len) != 1) {\n<123> qemu_error("path parse error (\"%s\" pos %d)\n", path, pos);\n<125> return NULL;\n<129> pos += len;\n<131> bus = qbus_find_bus(dev, elem);\n<133> if (!bus) {
<1> static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)\n<35> if (!strcmp(filename, "-"))\n<37> filename = "pipe:";\n<41> using_stdin |= !strncmp(filename, "pipe:", 5) ||\n<43> !strcmp(filename, "/dev/stdin");\n<53> print_error(filename, AVERROR(ENOMEM));\n<123> err = avformat_open_input(&ic, filename, file_iformat, &format_opts);
<1> static int shorten_decode_frame(AVCodecContext *avctx, void *data,\n<9> const uint8_t *buf = avpkt->data;\n<13> ShortenContext *s  = avctx->priv_data;\n<29> tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,\n<33> if (!tmp_ptr) {\n<41> memset(tmp_ptr, 0, s->allocated_bitstream_size);\n<43> s->bitstream = tmp_ptr;\n<53> buf_size       = FFMIN(buf_size, s->max_framesize - s->bitstream_size);\n<59> if (s->bitstream_index + s->bitstream_size + buf_size + FF_INPUT_BUFFER_PADDING_SIZE >\n<63> memmove(s->bitstream, &s->bitstream[s->bitstream_index],\n<71> if (buf)\n<73> memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,\n<77> buf               = &s->bitstream[s->bitstream_index];\n<79> buf_size         += s->bitstream_size;\n<111> if ((ret = read_header(s)) < 0)\n<195> unsigned blocksize = get_uint(s, av_log2(s->blocksize));\n<355> fix_bitshift(s, s->decoded[channel]);
<1> static int mpegts_write_section1(MpegTSSection *s, int tid, int id,\n<5> uint8_t *buf, int len)\n<23> if (tot_len > 1024)\n<35> put16(&q, id);\n<41> *q++ = last_sec_num;\n<43> memcpy(q, buf, len);
<1> void mkimg(const char *file, const char *fmt, unsigned size_mb)\n<11> GError *err = NULL;\n<21> qemu_img_path = getenv("QTEST_QEMU_IMG");\n<23> abs_path = realpath(qemu_img_path, NULL);\n<29> cli = g_strdup_printf("%s create -f %s %s %uM", abs_path,\n<33> ret = g_spawn_command_line_sync(cli, &out, &out2, &rc, &err);\n<35> if (err) {\n<37> fprintf(stderr, "%s\n", err->message);\n<39> g_error_free(err);\n<43> g_assert(ret && !err);\n<57> if (rc) {\n<59> fprintf(stderr, "qemu-img returned status code %d\n", rc);\n<63> g_assert(!rc);\n<73> free(abs_path);
<1> AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_size, int phase_shift, int linear, double cutoff){\n<3> AVResampleContext *c= av_mallocz(sizeof(AVResampleContext));\n<23> av_build_filter(c->filter_bank, factor, c->filter_length, phase_count, 1<<FILTER_SHIFT, 1);\n<25> memcpy(&c->filter_bank[c->filter_length*phase_count+1], c->filter_bank, (c->filter_length-1)*sizeof(FELEM));\n<39> return c;
<1> static int usb_parse(const char *cmdline)\n<7> r = usb_device_add(cmdline);\n<9> if (r < 0) {\n<11> fprintf(stderr, "qemu: could not add USB device '%s'\n", cmdline);
<27> if(pps == NULL)\n<127> if(pps->ref_count[0]-1 > 32-1 || pps->ref_count[1]-1 > 32-1){\n<159> memcpy(pps->scaling_matrix4, h->sps_buffers[pps->sps_id]->scaling_matrix4, sizeof(pps->scaling_matrix4));\n<161> memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8));\n<171> decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8);\n<183> build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], h->sps.bit_depth_luma);\n<185> build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], h->sps.bit_depth_luma);\n<225> h->pps_buffers[pps_id]= pps;
<1> static size_t handle_aiocb_rw(struct qemu_paiocb *aiocb)\n<83> char *p = buf;\n<89> for (i = 0; i < aiocb->aio_niov; ++i) {\n<91> memcpy(p, aiocb->aio_iov[i].iov_base, aiocb->aio_iov[i].iov_len);\n<93> p += aiocb->aio_iov[i].iov_len;\n<105> char *p = buf;\n<113> for (i = 0; i < aiocb->aio_niov && count; ++i) {\n<117> if (copy > aiocb->aio_iov[i].iov_len)\n<119> copy = aiocb->aio_iov[i].iov_len;\n<121> memcpy(aiocb->aio_iov[i].iov_base, p, copy);\n<123> p     += copy;\n<125> count -= copy;
<1> static void ppc_prep_init(QEMUMachineInitArgs *args)\n<87> if (cpu == NULL) {\n<89> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<143> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<167> if (bios_size > BIOS_SIZE) {\n<169> fprintf(stderr, "qemu: PReP bios '%s' is too large (0x%x)\n",\n<185> if (bios_size < 0 && !qtest_enabled()) {\n<187> fprintf(stderr, "qemu: could not load PPC PReP bios '%s'\n",\n<275> if (ppc_boot_device == '\0') {\n<277> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<305> if (pci_bus == NULL) {\n<307> fprintf(stderr, "Couldn't create PCI host controller.\n");\n<375> for(i = 0; i < nb_nics1; i++) {\n<377> if (nd_table[i].model == NULL) {\n<379> nd_table[i].model = g_strdup("ne2k_isa");\n<383> if (strcmp(nd_table[i].model, "ne2k_isa") == 0) {\n<385> isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],\n<387> &nd_table[i]);\n<391> pci_nic_init_nofail(&nd_table[i], pci_bus, "ne2k_pci", NULL);
<1> static int decode_frame(AVCodecContext *avctx,\n<9> JvContext *s           = avctx->priv_data;\n<37> if (avctx->reget_buffer(avctx, &s->frame) < 0) {\n<71> int v = *buf++;\n<73> for (j = 0; j < avctx->height; j++)\n<75> memset(s->frame.data[0] + j*s->frame.linesize[0], v, avctx->width);\n<97> s->palette[i] = 0xFF << 24 | pal << 2 | ((pal >> 4) & 0x30303);\n<109> if (video_size) {\n<119> memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);
<6> if ( render -> info . h264 . slice_count < 1 ) return ;\n<31> memcpy ( render -> info . h264 . scaling_lists_4x4 , h -> pps . scaling_matrix4 , sizeof ( render -> info . h264 . scaling_lists_4x4 ) ) ;\n<32> memcpy ( render -> info . h264 . scaling_lists_8x8 [ 0 ] , h -> pps . scaling_matrix8 [ 0 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;\n<33> memcpy ( render -> info . h264 . scaling_lists_8x8 [ 1 ] , h -> pps . scaling_matrix8 [ 3 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;
<1> void vnc_display_init(DisplayState *ds)\n<57> vs->timer = qemu_new_timer(rt_clock, vnc_update_client, vs);\n<71> memset(vs->dirty_row, 0xFF, sizeof(vs->dirty_row));
<1> static int bmp_decode_frame(AVCodecContext *avctx,\n<149> depth = bytestream_get_le16(&buf);\n<155> comp = bytestream_get_le32(&buf);\n<181> rgb[2] = bytestream_get_le32(&buf);\n<315> if(avctx->get_buffer(avctx, p) < 0){\n<329> buf = buf0 + hsize;\n<337> n = ((avctx->width * depth) / 8 + 3) & ~3;\n<341> if(n * avctx->height > dsize && comp != BMP_RLE4 && comp != BMP_RLE8){\n<355> if(comp == BMP_RLE4 || comp == BMP_RLE8)\n<357> memset(p->data[0], 0, avctx->height * p->linesize[0]);\n<361> if(depth == 4 || depth == 8)\n<363> memset(p->data[1], 0, 1024);\n<369> ptr = p->data[0] + (avctx->height - 1) * p->linesize[0];\n<375> ptr = p->data[0];\n<391> ((uint32_t*)p->data[1])[i] = bytestream_get_le24(&buf);\n<397> ((uint32_t*)p->data[1])[i] = bytestream_get_le32(&buf);\n<401> buf = buf0 + hsize;\n<415> for(i = 0; i < avctx->height; i++){\n<417> memcpy(ptr, buf, n);\n<419> buf += n;\n<421> ptr += linesize;\n<451> for(i = 0; i < avctx->height; i++){\n<453> memcpy(ptr, buf, avctx->width);\n<455> buf += n;\n<457> ptr += linesize;\n<465> for(i = 0; i < avctx->height; i++){\n<467> memcpy(ptr, buf, avctx->width*(depth>>3));\n<469> buf += n;\n<471> ptr += linesize;
<1> void kadmin_getpol ( int argc , char * argv [ ] ) {\n<4> if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( "-terse" , argv [ 1 ] ) ) ) ) {\n<5> fprintf ( stderr , _ ( "usage: get_policy [-terse] policy\n" ) ) ;\n<6> return ;\n<8> retval = kadm5_get_policy ( handle , argv [ argc - 1 ] , & policy ) ;\n<9> if ( retval ) {\n<13> if ( argc == 2 ) {\n<14> printf ( _ ( "Policy: %s\n" ) , policy . policy ) ;\n<15> printf ( _ ( "Maximum password life: %ld\n" ) , policy . pw_max_life ) ;\n<16> printf ( _ ( "Minimum password life: %ld\n" ) , policy . pw_min_life ) ;\n<17> printf ( _ ( "Minimum password length: %ld\n" ) , policy . pw_min_length ) ;\n<18> printf ( _ ( "Minimum number of password character classes: %ld\n" ) , policy . pw_min_classes ) ;\n<19> printf ( _ ( "Number of old keys kept: %ld\n" ) , policy . pw_history_num ) ;\n<20> printf ( _ ( "Reference count: %ld\n" ) , policy . policy_refcnt ) ;\n<21> printf ( _ ( "Maximum password failures before lockout: %lu\n" ) , ( unsigned long ) policy . pw_max_fail ) ;\n<22> printf ( _ ( "Password failure count reset interval: %s\n" ) , strdur ( policy . pw_failcnt_interval ) ) ;\n<23> printf ( _ ( "Password lockout duration: %s\n" ) , strdur ( policy . pw_lockout_duration ) ) ;\n<24> if ( policy . allowed_keysalts != NULL ) printf ( _ ( "Allowed key/salt types: %s\n" ) , policy . allowed_keysalts ) ;\n<27> printf ( "\"%s\"\t%ld\t%ld\t%ld\t%ld\t%ld\t%ld\t%lu\t%ld\t%ld\t%s\n" , policy . policy , policy . pw_max_life , policy . pw_min_life , policy . pw_min_length , policy . pw_min_classes , policy . pw_history_num , policy . policy_refcnt , ( unsigned long ) policy . pw_max_fail , ( long ) policy . pw_failcnt_interval , ( long ) policy . pw_lockout_duration , ( policy . allowed_keysalts == NULL ) ? "-" : policy . allowed_keysalts ) ;\n<29> kadm5_free_policy_ent ( handle , & policy ) ;
<1> int av_buffersrc_add_ref(AVFilterContext *buffer_filter,\n<43> if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {\n<63> if (!scale || strcmp(scale->filter->name, "scale")) {\n<65> AVFilter *f = avfilter_get_by_name("scale");\n<69> av_log(buffer_filter, AV_LOG_INFO, "Inserting scaler filter\n");\n<71> if ((ret = avfilter_open(&scale, f, "Input equalizer")) < 0)\n<103> } else if (!strcmp(scale->filter->name, "scale")) {\n<105> snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s",\n<107> scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n<109> scale->filter->init(scale, scale_param, NULL);\n<115> c->pix_fmt = scale->inputs[0]->format = picref->format;\n<117> c->w       = scale->inputs[0]->w      = picref->video->w;\n<119> c->h       = scale->inputs[0]->h      = picref->video->h;\n<123> link = scale->outputs[0];\n<125> if ((ret =  link->srcpad->config_props(link)) < 0)
<1> static inline void mix_2f_2r_to_dolby(AC3DecodeContext *ctx)\n<19> memset(output[3], 0, sizeof(output[3]));\n<21> memset(output[4], 0, sizeof(output[4]));
<1> static void mux_print_help(CharDriverState *chr)\n<7> char ebuf[15] = "Escape-Char";\n<15> snprintf(cbuf, sizeof(cbuf), "\n\r");\n<17> snprintf(ebuf, sizeof(ebuf), "C-%c", term_escape_char - 1 + 'a');\n<29> qemu_chr_fe_write(chr, (uint8_t *)cbuf, strlen(cbuf));\n<35> if (mux_help[i][j] == '%')\n<37> qemu_chr_fe_write(chr, (uint8_t *)ebuf, strlen(ebuf));\n<41> qemu_chr_fe_write(chr, (uint8_t *)&mux_help[i][j], 1);
<1> static int xmv_process_packet_header(AVFormatContext *s)\n<161> xmv_read_extradata(xmv->video.extradata, pb);\n<171> if (xmv->video.stream_index >= 0) {\n<183> av_freep(&vst->codec->extradata);\n<193> memcpy(vst->codec->extradata, xmv->video.extradata, 4);
<1> int cpu_ppc_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n<49> } else if (ret < 0) {\n<347> switch (access_type) {\n<377> printf("DSI: invalid exception (%d)\n", ret);
<1> static void net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n<37> } else if (tap->has_helper) {\n<45> snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n<53> if (strcmp(downscript, "no") != 0) {\n<55> snprintf(s->down_script, sizeof(s->down_script), "%s", downscript);\n<57> snprintf(s->down_script_arg, sizeof(s->down_script_arg),
<1> static int http_start_receive_data(HTTPContext *c)\n<27> if (fd < 0) {\n<29> http_log("Error opening feeder file: %s\n", strerror(errno));\n<51> if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {\n<53> http_log("Error reading write index from feed file: %s\n", strerror(errno));
<1> static void mainstone_common_init(int ram_size, int vga_ram_size,\n<11> uint32_t mainstone_ram = 0x04000000;\n<13> uint32_t mainstone_rom = 0x00800000;\n<31> if (ram_size < mainstone_ram + mainstone_rom + PXA2XX_INTERNAL_SIZE) {\n<33> fprintf(stderr, "This platform requires %i bytes of memory\n",\n<61> if (index == -1) {\n<63> fprintf(stderr, "Two flash images must be given with the "\n<71> if (!pflash_register(MST_FLASH_0, mainstone_ram + PXA2XX_INTERNAL_SIZE,\n<77> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<87> if (index == -1) {\n<89> fprintf(stderr, "Two flash images must be given with the "\n<97> if (!pflash_register(MST_FLASH_1, mainstone_ram + PXA2XX_INTERNAL_SIZE,\n<103> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> static int plot_cqt(AVFilterLink *inlink)\n<7> ShowCQTContext *s = ctx->priv;\n<33> memcpy(s->fft_result, s->fft_data, fft_len * sizeof(*s->fft_data));\n<35> av_fft_permute(s->fft_context, s->fft_result);\n<189> s->spectogram[s->spectogram_index*linesize + 3*x] = result[x][0] + 0.5f;\n<191> s->spectogram[s->spectogram_index*linesize + 3*x + 1] = result[x][1] + 0.5f;\n<193> s->spectogram[s->spectogram_index*linesize + 3*x + 2] = result[x][2] + 0.5f;\n<201> if (!s->spectogram_count) {\n<287> for (y = 0; y < font_height; y++) {\n<289> uint8_t *lineptr = data + (spectogram_height + y) * linesize;\n<291> memcpy(lineptr, s->spectogram + s->spectogram_index * linesize, video_width*3);\n<381> data += spectogram_start * linesize;\n<383> memcpy(data, s->spectogram + s->spectogram_index*linesize, total_length - back_length);\n<387> data += total_length - back_length;\n<389> if (back_length)\n<391> memcpy(data, s->spectogram, back_length);
<1> static void sdp_parse_line(AVFormatContext *s, SDPParseState *s1,\n<35> switch(letter) {\n<39> get_word(buf1, sizeof(buf1), &p);\n<41> if (strcmp(buf1, "IN") != 0)\n<43> return;\n<45> get_word(buf1, sizeof(buf1), &p);\n<47> if (strcmp(buf1, "IP4") != 0)\n<49> return;\n<51> get_word_sep(buf1, sizeof(buf1), "/", &p);\n<53> if (inet_aton(buf1, &sdp_ip) == 0)\n<111> get_word(st_type, sizeof(st_type), &p);\n<113> if (!strcmp(st_type, "audio")) {\n<115> codec_type = CODEC_TYPE_AUDIO;\n<117> } else if (!strcmp(st_type, "video")) {\n<119> codec_type = CODEC_TYPE_VIDEO;\n<123> return;\n<127> rtsp_st = av_mallocz(sizeof(RTSPStream));\n<129> if (!rtsp_st)
<1> void qemu_spice_display_switch(SimpleSpiceDisplay *ssd,\n<61> memset(&ssd->dirty, 0, sizeof(ssd->dirty));\n<87> qemu_spice_destroy_update(ssd, update);\n<95> qemu_spice_destroy_host_primary(ssd);\n<107> qemu_spice_create_host_primary(ssd);\n<113> memset(&ssd->dirty, 0, sizeof(ssd->dirty));
<1> read_f(int argc, char **argv)\n<23> int pattern = 0, pattern_offset = 0, pattern_count = 0;\n<27> while ((c = getopt(argc, argv, "bCl:pP:qs:v")) != EOF) {\n<47> pattern_count = cvtnum(optarg);\n<49> if (pattern_count < 0) {\n<51> printf("non-numeric length argument -- %s\n", optarg);\n<69> pattern = atoi(optarg);\n<83> pattern_offset = cvtnum(optarg);\n<85> if (pattern_offset < 0) {\n<87> printf("non-numeric length argument -- %s\n", optarg);\n<117> if (bflag && pflag) {\n<119> printf("-b and -p cannot be specified at the same time\n");\n<127> offset = cvtnum(argv[optind]);\n<129> if (offset < 0) {\n<131> printf("non-numeric length argument -- %s\n", argv[optind]);\n<141> count = cvtnum(argv[optind]);\n<143> if (count < 0) {\n<145> printf("non-numeric length argument -- %s\n", argv[optind]);\n<163> pattern_count = count - pattern_offset;\n<169> if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n<171> printf("pattern verfication range exceeds end of read data\n");\n<181> if (offset & 0x1ff) {\n<191> if (count & 0x1ff) {\n<213> cnt = do_pread(buf, offset, count, &total);\n<217> cnt = do_load_vmstate(buf, offset, count, &total);\n<221> cnt = do_read(buf, offset, count, &total);\n<227> if (cnt < 0) {\n<229> printf("read failed: %s\n", strerror(-cnt));\n<237> if (Pflag) {\n<239> void* cmp_buf = malloc(pattern_count);\n<241> memset(cmp_buf, pattern, pattern_count);\n<243> if (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n<245> printf("Pattern verification failed at offset %lld, "\n<249> (long long) offset + pattern_offset, pattern_count);\n<253> free(cmp_buf);
<1> static int img_amend(int argc, char **argv)\n<235> if (ret < 0) {\n<237> error_report("Error while amending options: %s", strerror(-ret));
<1> static int parsedate ( const char * date , time_t * output ) {\n<6> int hournum = - 1 ;\n<7> int minnum = - 1 ;\n<15> while ( * date && ( part < 6 ) ) {\n<17> skip ( & date ) ;\n<18> if ( ISALPHA ( * date ) ) {\n<19> char buf [ 32 ] = "" ;\n<21> if ( sscanf ( date , "%31[ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz]" , buf ) ) len = strlen ( buf ) ;\n<22> else len = 0 ;\n<24> wdaynum = checkday ( buf , len ) ;\n<28> monnum = checkmonth ( buf ) ;\n<32> tzoff = checktz ( buf ) ;\n<36> date += len ;\n<38> else if ( ISDIGIT ( * date ) ) {\n<41> if ( ( secnum == - 1 ) && ( 3 == sscanf ( date , "%02d:%02d:%02d" , & hournum , & minnum , & secnum ) ) ) {\n<42> date += 8 ;\n<44> else if ( ( secnum == - 1 ) && ( 2 == sscanf ( date , "%02d:%02d" , & hournum , & minnum ) ) ) {\n<45> date += 5 ;\n<46> secnum = 0 ;\n<52> old_errno = ERRNO ;\n<53> SET_ERRNO ( 0 ) ;\n<54> lval = strtol ( date , & end , 10 ) ;\n<55> error = ERRNO ;\n<56> if ( error != old_errno ) SET_ERRNO ( old_errno ) ;\n<57> if ( error ) return PARSEDATE_FAIL ;\n<60> if ( ( tzoff == - 1 ) && ( ( end - date ) == 4 ) && ( val <= 1400 ) && ( indate < date ) && ( ( date [ - 1 ] == '+' || date [ - 1 ] == '-' ) ) ) {\n<63> tzoff = date [ - 1 ] == '+' ? - tzoff : tzoff ;\n<88> date = end ;\n<91> part ++ ;\n<93> if ( - 1 == secnum ) secnum = minnum = hournum = 0 ;
<1> void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)\n<11> memset(&bs->bl, 0, sizeof(bs->bl));
<1> static int vnc_zlib_stop(VncState *vs)\n<49> if (err != Z_OK) {\n<51> fprintf(stderr, "VNC: error initializing zlib\n");\n<107> if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n<109> fprintf(stderr, "VNC: error during zlib compression\n");
<1> void do_store_dcr (void)\n<7> if (loglevel != 0) {\n<9> fprintf(logfile, "No DCR environment\n");\n<15> } else if (unlikely(ppc_dcr_write(env->dcr_env, T0, T1) != 0)) {\n<17> if (loglevel != 0) {\n<19> fprintf(logfile, "DCR write error %d %03x\n", (int)T0, (int)T0);
<1> static void monitor_parse(const char *optarg, const char *mode, bool pretty)\n<35> opts = qemu_chr_parse_compat(label, optarg);\n<37> if (!opts) {\n<39> fprintf(stderr, "parse error: %s\n", optarg);
<1> static int qio_dns_resolver_lookup_sync_inet(QIODNSResolver *resolver,\n<17> char port[33];\n<37> memset(&ai, 0, sizeof(ai));\n<39> ai.ai_flags = AI_PASSIVE;\n<43> ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n<47> ai.ai_family = inet_ai_family_from_address(iaddr, &err);\n<49> ai.ai_socktype = SOCK_STREAM;\n<63> if (iaddr->host == NULL) {\n<71> if (iaddr->port != NULL) {\n<73> pstrcpy(port, sizeof(port), iaddr->port);\n<77> port[0] = '\0';\n<83> rc = getaddrinfo(strlen(iaddr->host) ? iaddr->host : NULL,\n<85> strlen(port) ? port : NULL, &ai, &res);\n<87> if (rc != 0) {\n<89> error_setg(errp, "address resolution failed for %s:%s: %s",\n<99> for (e = res; e != NULL; e = e->ai_next) {\n<113> for (i = 0, e = res; e != NULL; i++, e = e->ai_next) {\n<159> freeaddrinfo(res);
<1> static void mcf5208evb_init(ram_addr_t ram_size, int vga_ram_size,\n<29> if (!env) {\n<31> fprintf(stderr, "Unable to find m68k CPU definition\n");\n<81> if (nb_nics > 1) {\n<83> fprintf(stderr, "Too many NICs\n");\n<91> if (nd_table[0].model == NULL\n<93> || strcmp(nd_table[0].model, "mcf_fec") == 0) {\n<95> mcf_fec_init(&nd_table[0], 0xfc030000, pic + 36);\n<97> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<99> fprintf(stderr, "qemu: Supported NICs: mcf_fec\n");\n<101> exit (1);\n<105> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<107> exit (1);\n<161> if (!kernel_filename) {\n<163> fprintf(stderr, "Kernel image must be specified\n");\n<171> kernel_size = load_elf(kernel_filename, 0, &elf_entry, NULL, NULL);\n<177> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n<183> kernel_size = load_image(kernel_filename, phys_ram_base);\n<189> if (kernel_size < 0) {\n<191> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> int main(int argc, char **argv){\n<47> if (argc > 1) {\n<49> if (!strcmp(argv[1], "-h") || !strcmp(argv[1], "--help")) {\n<51> av_log(NULL, AV_LOG_INFO, "Usage: swresample-test [<num_tests>[ <test>]]  \n"\n<55> return 0;\n<59> num_tests = strtol(argv[1], NULL, 0);\n<61> if(num_tests < 0) {\n<69> if(num_tests<= 0 || num_tests>max_tests)\n<73> if(argc > 2) {\n<83> for(i=0; i<max_tests; i++)\n<89> for(test=0; test<num_tests; test++){\n<101> qsort(remaining_tests + max_tests - num_tests, num_tests, sizeof(remaining_tests[0]), (void*)cmp);\n<103> in_sample_rate=16000;\n<105> for(test=0; test<num_tests; test++){\n<127> out_sample_rate = rates  [vector % FF_ARRAY_ELEMS(rates  )]; vector /= FF_ARRAY_ELEMS(rates);\n<133> if(specific_test == 0){\n<135> if(out_sample_rate != in_sample_rate || in_ch_layout != out_ch_layout)\n<147> av_get_channel_layout_string( in_layout_string, sizeof( in_layout_string),  in_ch_count,  in_ch_layout);\n<149> av_get_channel_layout_string(out_layout_string, sizeof(out_layout_string), out_ch_count, out_ch_layout);\n<151> fprintf(stderr, "TEST: %s->%s, rate:%5d->%5d, fmt:%s->%s\n",\n<157> av_get_sample_fmt_name(in_sample_fmt), av_get_sample_fmt_name(out_sample_fmt));\n<159> forw_ctx  = swr_alloc_set_opts(forw_ctx, out_ch_layout, out_sample_fmt,  out_sample_rate,\n<165> backw_ctx = swr_alloc_set_opts(backw_ctx, in_ch_layout,  in_sample_fmt,             in_sample_rate,\n<171> if(swr_init( forw_ctx) < 0)\n<173> fprintf(stderr, "swr_init(->) failed\n");\n<175> if(swr_init(backw_ctx) < 0)\n<177> fprintf(stderr, "swr_init(<-) failed\n");\n<179> if(!forw_ctx)\n<181> fprintf(stderr, "Failed to init forw_cts\n");\n<183> if(!backw_ctx)\n<185> fprintf(stderr, "Failed to init backw_ctx\n");\n<259> for(ch=0; ch<in_ch_count; ch++){\n<261> double sse, maxdiff=0;\n<273> for(i=0; i<out_count; i++){\n<289> maxdiff= FFMAX(maxdiff, FFABS(a-b));\n<299> fprintf(stderr, "[e:%f c:%f max:%f] len:%5d\n", sqrt(sse/out_count), sum_ab/(sqrt(sum_aa*sum_bb)), maxdiff, out_count);\n<305> flush_i++;\n<315> shift(aout, -flush_i, in_ch_count, in_sample_fmt);\n<319> for(ch=0; ch<in_ch_count; ch++){\n<321> double sse, maxdiff=0;\n<333> for(i=0; i<flush_count; i++){\n<335> double a= get(ain , ch, i+out_count, in_ch_count, in_sample_fmt);\n<349> maxdiff= FFMAX(maxdiff, FFABS(a-b));\n<359> fprintf(stderr, "[e:%f c:%f max:%f] len:%5d F:%3d\n", sqrt(sse/flush_count), sum_ab/(sqrt(sum_aa*sum_bb)), maxdiff, flush_count, flush_i);\n<369> fprintf(stderr, "\n");\n<375> return 0;
<1> static void pl110_update_display(void *opaque)\n<39> switch (surface_bits_per_pixel(surface)) {\n<87> fprintf(stderr, "pl110: Bad color depth\n");
<1> static int remoteStreamHandleWriteData ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n<5> memset ( & rerr , 0 , sizeof rerr ) ;\n<17> remoteDispatchConnError ( & rerr , client -> conn ) ;\n<18> return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
<1> static inline void dv_decode_video_segment(DVVideoDecodeContext *s,\n<37> memset(s->block, 0, sizeof(s->block));\n<117> dv_decode_ac(s, mb, block, last_index);\n<177> dv_decode_ac(s, mb, block, mb_bit_count);\n<263> dv_decode_ac(s, mb, block, vs_bit_count);
<1> static inline void pit_load_count(PITChannelState *s, int val)\n<15> if (s == &pit_channels[0] && val <= pit_min_timer_count) {\n<21> PIT_FREQ / pit_min_timer_count);
<1> int spapr_vio_send_crq(VIOsPAPRDevice *dev, uint8_t *crq)\n<11> if (!dev->crq.qsize) {\n<13> fprintf(stderr, "spapr_vio_send_creq on uninitialized queue\n");
<1> static void dhcp_decode(const struct bootp_t *bp, int *pmsg_type,\n<19> p = bp->bp_vend;\n<23> if (memcmp(p, rfc1533_cookie, 4) != 0)\n<25> return;\n<27> p += 4;\n<29> while (p < p_end) {\n<85> if (*pmsg_type == DHCPREQUEST && !*preq_addr && bp->bp_ciaddr.s_addr) {
<1> static int tiff_unpack_strip(TiffContext *s, uint8_t* dst, int stride, const uint8_t *src, int size, int lines){\n<57> if(ff_lzw_decode_init(s->lzw, 8, src, size, FF_LZW_TIFF) < 0){\n<75> if(!src2 || (unsigned)size + FF_INPUT_BUFFER_PADDING_SIZE < (unsigned)size){\n<83> if(s->fax_opts & 2){\n<93> if(!s->fill_order){\n<95> memcpy(src2, src, size);\n<99> for(i = 0; i < size; i++)\n<101> src2[i] = av_reverse[src[i]];\n<105> memset(src2+size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<115> ret = ff_ccitt_unpack(s->avctx, src2, size, dst, lines, stride, s->compr, s->fax_opts);\n<121> av_free(src2);\n<141> if (ssrc + size - src < width)\n<145> if (!s->fill_order) {\n<147> memcpy(dst, src, width);\n<155> dst[i] = av_reverse[src[i]];\n<159> src += width;\n<165> for(pixels = 0; pixels < width;){\n<167> code = (int8_t)*src++;\n<171> code++;\n<173> if(pixels + code > width){\n<181> memcpy(dst + pixels, src, code);\n<183> src += code;\n<185> pixels += code;\n<189> code = (-code) + 1;\n<191> if(pixels + code > width){\n<199> c = *src++;\n<201> memset(dst + pixels, c, code);\n<203> pixels += code;\n<213> pixels = ff_lzw_decode(s->lzw, dst, width);\n<227> dst += stride;
<1> static int ram_save_setup(QEMUFile *f, void *opaque)\n<15> if (migrate_use_xbzrle()) {\n<23> if (!XBZRLE.cache) {\n<57> qemu_put_be64(f, ram_bytes_total() | RAM_SAVE_FLAG_MEM_SIZE);\n<61> QLIST_FOREACH(block, &ram_list.blocks, next) {\n<63> qemu_put_byte(f, strlen(block->idstr));\n<65> qemu_put_buffer(f, (uint8_t *)block->idstr, strlen(block->idstr));
<1> static int l2_allocate(BlockDriverState *bs, int l1_index, uint64_t **table)\n<5> BDRVQcowState *s = bs->opaque;\n<65> l2_table = *table;\n<69> if ((old_l2_offset & L1E_OFFSET_MASK) == 0) {\n<73> memset(l2_table, 0, s->l2_size * sizeof(uint64_t));\n<91> if (ret < 0) {\n<99> memcpy(l2_table, old_table, s->cluster_size);\n<103> ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &old_table);\n<123> qcow2_cache_entry_mark_dirty(s->l2_table_cache, l2_table);
<1> static void rtl8139_do_receive(void *opaque, const uint8_t *buf, int size, int do_interrupt)\n<13> uint8_t buf1[60];\n<57> if (s->RxConfig & AcceptAllPhys) {\n<67> if (!memcmp(buf,  broadcast_macaddr, 6)) {\n<71> if (!(s->RxConfig & AcceptBroadcast))\n<105> } else if (buf[0] & 0x01) {\n<129> int mcast_idx = compute_mcast_idx(buf);\n<167> } else if (s->phys[0] == buf[0] &&\n<169> s->phys[1] == buf[1] &&\n<171> s->phys[2] == buf[2] &&\n<173> s->phys[3] == buf[3] &&\n<175> s->phys[4] == buf[4] &&\n<177> s->phys[5] == buf[5]) {\n<239> if (size < MIN_BUF_SIZE) {\n<241> memcpy(buf1, buf, size);\n<243> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<245> buf = buf1;\n<415> cpu_physical_memory_write( rx_addr, buf, size );\n<637> rtl8139_write_buffer(s, buf, size);
<1> dma_write(void *opaque, target_phys_addr_t addr,\n<25> c = fs_channel(addr);\n<31> switch (addr)\n<55> if (value & ~1)\n<61> ctrl->channels[c].regs[addr] = value;\n<63> channel_continue(ctrl, c);\n<101> if (value & ~1023)\n<109> ctrl->channels[c].regs[addr] = value;\n<111> D(printf("stream_cmd ch=%d\n", c));\n<113> channel_stream_cmd(ctrl, c, value);
<1> static void data_destroy_arabic ( void * data ) {\n<4> free ( data ) ;
<1> void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n<11> const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n<31> memset(&entry, 0, sizeof entry);\n<33> strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n<45> g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
<1> static void do_getfd(Monitor *mon, const QDict *qdict)\n<5> const char *fdname = qdict_get_str(qdict, "fdname");\n<25> if (qemu_isdigit(fdname[0])) {\n<37> if (fd == -1) {\n<39> monitor_printf(mon, "Failed to dup() file descriptor: %s\n",\n<41> strerror(errno));\n<49> LIST_FOREACH(monfd, &mon->fds, next) {\n<51> if (strcmp(monfd->name, fdname) != 0) {
<1> static int do_bit_allocation(AC3DecodeContext *ctx, int flags)\n<5> ac3_audio_block *ab = &ctx->audio_block;\n<33> if (!snroffst) {\n<35> memset(ab->cplbap, 0, sizeof (ab->cplbap));\n<37> for (i = 0; i < ctx->bsi.nfchans; i++)\n<39> memset(ab->bap[i], 0, sizeof (ab->bap[i]));\n<41> memset(ab->lfebap, 0, sizeof (ab->lfebap));
<1> static void check_pred8x8(H264PredContext *h, uint8_t *buf0, uint8_t *buf1,\n<11> if (check_pred_func(h->pred8x8[pred_mode], (chroma_format == 2) ? "8x16" : "8x8",\n<21> if (memcmp(buf0, buf1, BUF_SIZE))\n<23> fail();
<1> static int sdp_parse(AVFormatContext *s, const char *content)\n<25> SDPParseState sdp_parse_state, *s1 = &sdp_parse_state;\n<29> memset(s1, 0, sizeof(SDPParseState));\n<67> sdp_parse_line(s, s1, letter, buf);
<1> static void eeprom_generate(eeprom24c0x_t *eeprom, ram_addr_t ram_size)\n<23> while ((ram_size >= 4) && (nbanks <= 2)) {\n<67> if (ram_size) {\n<69> fprintf(stderr, "Warning: SPD cannot represent final %dMB"
<1> void qemu_put_byte(QEMUFile *f, int v)\n<5> if (!f->last_error && f->is_write == 0 && f->buf_index > 0) {
<1> int vnc_display_open(DisplayState *ds, const char *display)\n<5> VncState *vs = ds ? (VncState *)ds->opaque : vnc_state;\n<25> if (strcmp(display, "none") == 0)\n<27> return 0;\n<31> if (!(vs->display = strdup(display)))\n<33> return -1;\n<37> options = display;\n<39> while ((options = strchr(options, ','))) {\n<41> options++;\n<43> if (strncmp(options, "password", 8) == 0) {\n<47> } else if (strncmp(options, "reverse", 7) == 0) {\n<51> } else if (strncmp(options, "to=", 3) == 0) {\n<131> if (password) {\n<211> if (reverse) {\n<215> if (strncmp(display, "unix:", 5) == 0)\n<223> if (-1 == vs->lsock) {\n<225> free(vs->display);\n<237> vnc_connect(vs);\n<253> if (strncmp(display, "unix:", 5) == 0) {\n<255> strcpy(dpy, "unix:");\n<261> vs->lsock = inet_listen(display, dpy, 256, SOCK_STREAM, 5900);\n<265> if (-1 == vs->lsock) {\n<267> free(dpy);\n<271> free(vs->display);\n<281> return qemu_set_fd_handler2(vs->lsock, vnc_listen_poll, vnc_listen_read, NULL, vs);
<1> static void qemu_cpu_kick_thread(CPUState *env)\n<11> err = pthread_kill(env->thread->thread, SIG_IPI);\n<13> if (err) {\n<15> fprintf(stderr, "qemu:%s: %s", __func__, strerror(err));
<1> static int lag_decode_arith_plane(LagarithContext *l, uint8_t *dst,\n<3> int width, int height, int stride,\n<5> const uint8_t *src, int src_size)\n<93> src ++;\n<117> if (src_size < width * height)\n<123> for (i = 0; i < height; i++) {\n<125> memcpy(dst + (i * stride), src, width);\n<127> src += width;\n<137> for (i = 0; i < height; i++)\n<139> memset(dst + i * stride, src[1], width);\n<165> lag_pred_line(l, dst, width, stride, i);\n<177> width == l->avctx->width);
<1> static int decompress_p(AVCodecContext *avctx,\n<39> ret |= decode_value(s, s->range_model, 256, 1, &temp);\n<41> if (ret < 0)\n<49> memset(s->blocks, 0, sizeof(*s->blocks) * s->nbcount);\n<59> ret  = decode_value(s, s->fill_model,  5,   10, &fill);\n<61> ret |= decode_value(s, s->count_model, 256, 20, &count);\n<95> ret  = decode_value(s, s->sxy_model[0], 16, 100, &sx1);\n<97> ret |= decode_value(s, s->sxy_model[1], 16, 100, &sy1);\n<99> ret |= decode_value(s, s->sxy_model[2], 16, 100, &sx2);\n<101> ret |= decode_value(s, s->sxy_model[3], 16, 100, &sy2);\n<123> ret  = decode_value(s, s->mv_model[0], 512, 100, &mvx);\n<125> ret |= decode_value(s, s->mv_model[1], 512, 100, &mvy);\n<165> ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n<169> ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n<181> ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n<193> ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n<213> ret = decode_value(s, s->run_model[ptype], 256, 400, &run);
<1> static int huffman_decode(MPADecodeContext *s, GranuleDef *g,\n<45> if (!l) {\n<47> memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * 2 * j);\n<91> g->sb_hybrid[s_index+1] = 0;\n<117> READ_FLIP_SIGN(g->sb_hybrid + s_index, RENAME(expval_table)[exponent] + x)\n<129> g->sb_hybrid[s_index] = v;\n<135> READ_FLIP_SIGN(g->sb_hybrid + s_index + 1, RENAME(expval_table)[exponent] + y)\n<147> g->sb_hybrid[s_index+1] = v;\n<161> READ_FLIP_SIGN(g->sb_hybrid + s_index + !!y, RENAME(expval_table)[exponent] + x)\n<173> g->sb_hybrid[s_index+!!y] = v;\n<177> g->sb_hybrid[s_index + !y] = 0;\n<249> g->sb_hybrid[s_index+3] = 0;\n<261> READ_FLIP_SIGN(g->sb_hybrid + pos, RENAME(exp_table)+exponents[pos])\n<289> memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid) * (576 - s_index));
<1> static void smbios_encode_uuid(struct smbios_uuid *uuid, const uint8_t *buf)\n<5> memcpy(uuid, buf, 16);\n<9> uuid->time_low = bswap32(uuid->time_low);\n<11> uuid->time_mid = bswap16(uuid->time_mid);\n<13> uuid->time_hi_and_version = bswap16(uuid->time_hi_and_version);
<1> static void handle_raw_data ( char * packet , int len , struct query * q , int dns_fd , int tun_fd , int userid ) {\n<2> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<6> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<8> memcpy ( users [ userid ] . inpacket . data , packet , len ) ;\n<9> users [ userid ] . inpacket . len = len ;\n<10> if ( debug >= 1 ) {\n<11> fprintf ( stderr , "IN pkt raw, total %d, from user %d\n" , users [ userid ] . inpacket . len , userid ) ;\n<13> handle_full_packet ( tun_fd , dns_fd , userid ) ;
<1> static int multiwrite_merge(BlockDriverState *bs, BlockRequest *reqs,\n<91> if (reqs[i].sector > oldreq_last) {\n<95> uint8_t *buf = qemu_blockalign(bs, zero_bytes);\n<97> memset(buf, 0, zero_bytes);\n<99> qemu_iovec_add(qiov, buf, zero_bytes);
<1> static int nbd_send_negotiate(int csock, off_t size, uint32_t flags)\n<5> char buf[8 + 8 + 8 + 128];\n<27> memcpy(buf, "NBDMAGIC", 8);\n<29> cpu_to_be64w((uint64_t*)(buf + 8), 0x00420281861253LL);\n<31> cpu_to_be64w((uint64_t*)(buf + 16), size);\n<33> cpu_to_be32w((uint32_t*)(buf + 24),\n<39> memset(buf + 28, 0, 124);
<1> MemoryRegion *rom_add_blob(const char *name, const void *blob, size_t len,\n<17> rom           = g_malloc0(sizeof(*rom));\n<27> rom->data     = g_malloc0(rom->datasize);\n<29> memcpy(rom->data, blob, len);\n<31> rom_insert(rom);\n<47> data = rom_set_mr(rom, OBJECT(fw_cfg), devpath);\n<53> data = rom->data;
<1> static int vc1_decode_intra_block(VC1Context *v, DCTELEM block[64], int n, int coded, int mquant, int codingset)\n<179> ac_val -= 16;\n<183> ac_val -= 16 * s->block_wrap[n];\n<221> if(!c_avail) {\n<223> memset(ac_val, 0, 8 * sizeof(ac_val[0]));\n<229> if(!a_avail) {\n<231> memset(ac_val + 8, 0, 8 * sizeof(ac_val[0]));\n<249> block[k << 3] += (ac_val[k] * q2 * vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<255> block[k] += (ac_val[k + 8] * q2 * vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<265> block[k << 3] += ac_val[k];\n<271> block[k] += ac_val[k + 8];\n<283> ac_val2[k] = block[k << 3];\n<285> ac_val2[k + 8] = block[k];\n<315> if(!coded) {\n<319> ac_val = s->ac_val[0][0] + s->block_index[n] * 16;\n<321> ac_val2 = ac_val;\n<325> if(!c_avail) {\n<327> memset(ac_val, 0, 8 * sizeof(ac_val[0]));\n<333> if(!a_avail) {\n<335> memset(ac_val + 8, 0, 8 * sizeof(ac_val[0]));\n<345> memset(ac_val2, 0, 16 * 2);\n<349> ac_val -= 16;\n<351> if(s->ac_pred)\n<353> memcpy(ac_val2, ac_val, 8 * 2);\n<357> ac_val -= 16 * s->block_wrap[n];\n<359> if(s->ac_pred)\n<361> memcpy(ac_val2 + 8, ac_val + 8, 8 * 2);\n<375> block[k << 3] = ac_val[k] * scale;\n<387> block[k] = ac_val[k + 8] * scale;
<1> void vpx_svc_release ( SvcContext * svc_ctx ) {\n<5> if ( si != NULL ) {\n<6> fd_free ( si -> frame_temp ) ;\n<7> fd_free_list ( si -> frame_list ) ;\n<8> if ( si -> rc_stats_buf ) {\n<9> free ( si -> rc_stats_buf ) ;\n<11> free ( si ) ;
<1> static int test_make_inputs ( xd3_stream * stream , xoff_t * ss_out , xoff_t * ts_out ) {\n<2> usize_t ts = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n<3> usize_t ss = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n<4> uint8_t * buf = ( uint8_t * ) malloc ( ts + ss ) , * sbuf = buf , * tbuf = buf + ss ;\n<9> if ( buf == NULL ) {\n<75> failure : free ( buf ) ;
<1> static uint64_t omap_mcbsp_read(void *opaque, target_phys_addr_t addr,\n<35> if (s->rx_req < 2) {\n<37> printf("%s: Rx FIFO underrun\n", __FUNCTION__);
<1> static int transcode(OutputFile *output_files, int nb_output_files,\n<25> if (!(no_packet = av_mallocz(nb_input_files)))\n<31> ret = transcode_init(output_files, nb_output_files, input_files, nb_input_files);\n<187> if (key == 'd' || key == 'D'){\n<189> int debug=0;\n<191> if(key == 'D') {\n<195> if(!debug) debug = 1;\n<197> while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n<199> debug += debug;\n<203> if(scanf("%d", &debug)!=1)\n<205> fprintf(stderr,"error parsing debug value\n");\n<209> input_streams[i].st->codec->debug = debug;\n<217> ost->st->codec->debug = debug;\n<223> fprintf(stderr,"debug=%d\n", debug);\n<227> if (key == '?'){\n<277> if (ost->is_past_recording_time || no_packet[ist->file_index] ||\n<327> if (no_packet_count) {\n<331> memset(no_packet, 0, nb_input_files);\n<353> no_packet[file_index] = 1;\n<361> if (ret < 0) {\n<379> memset(no_packet, 0, nb_input_files);\n<597> av_freep(&no_packet);
<1> int qdev_prop_set_drive(DeviceState *dev, const char *name, BlockDriverState *value)\n<11> if (res < 0) {\n<13> error_report("Can't attach drive %s to %s.%s: %s",\n<19> name, strerror(-res));
<1> static char *shorts2str(int16_t *sp, int count, const char *sep)\n<9> if (!sep) sep = ", ";\n<11> ap = av_malloc((5 + strlen(sep)) * count);\n<13> if (!ap)\n<17> ap0   = ap;\n<19> ap[0] = '\0';\n<21> for (i = 0; i < count; i++) {\n<23> int l = snprintf(ap, 5 + strlen(sep), "%d%s", sp[i], sep);\n<25> ap += l;\n<29> ap0[strlen(ap0) - strlen(sep)] = '\0';\n<31> return ap0;
<1> static int tosa_dac_send(I2CSlave *i2c, uint8_t data)\n<25> if (s->len == 2) {\n<27> fprintf(stderr, "dac: channel %d value 0x%02x\n",
<1> static void process_envvars ( enum mode * modep ) {\n<10> if ( envline [ len ] != '=' ) continue ;\n<12> case 4 : if ( memcmp ( envline , "WARN" , 4 ) == 0 ) GLRO ( dl_verbose ) = envline [ 5 ] != '\0' ;
<1> static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx,\n<5> const uint8_t *buf, int len, uint16_t seq,\n<65> lid  = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f);\n<67> tid  =   buf[1] & 0x07;\n<117> buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n<127> buf += RTP_HEVC_DONL_FIELD_SIZE;\n<159> if (len < 1) {\n<175> if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0)\n<181> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<185> memcpy(pkt->data + sizeof(start_sequence), buf, len);\n<235> fu_type        = buf[0] & 0x3f;\n<241> buf += RTP_HEVC_FU_HEADER_SIZE;\n<251> buf += RTP_HEVC_DONL_FIELD_SIZE;\n<263> if (len > 0) {\n<265> new_nal_header[0] = (rtp_pl[0] & 0x81) | (fu_type << 1);\n<267> new_nal_header[1] = rtp_pl[1];\n<279> if ((res = av_new_packet(pkt, sizeof(start_sequence) + sizeof(new_nal_header) + len)) < 0)\n<285> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<289> memcpy(pkt->data + sizeof(start_sequence), new_nal_header, sizeof(new_nal_header));\n<293> memcpy(pkt->data + sizeof(start_sequence) + sizeof(new_nal_header), buf, len);\n<307> if ((res = av_new_packet(pkt, len)) < 0)\n<313> memcpy(pkt->data, buf, len);
<1> static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n<17> switch (req->cmd.buf[0]) {\n<125> memset(outbuf, 0, 8);\n<187> memset(outbuf, 0, 8);\n<203> if ((req->cmd.buf[1] & 31) == 0x10) {\n<207> memset(outbuf, 0, req->cmd.xfer);\n<267> buflen = req->cmd.xfer;\n<279> if (req->cmd.xfer < 16)\n<283> memset(outbuf, 0, 16);
<1> static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n<79> if (!region)\n<115> clut_table = clut->clut4;\n<121> clut_table = clut->clut256;\n<129> clut_table = clut->clut16;\n<139> if (!rect->pict.data[1]) {\n<147> memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n<151> rect->pict.data[0] = av_malloc(region->buf_size);\n<153> if (!rect->pict.data[0]) {\n<155> av_free(rect->pict.data[1]);\n<163> memcpy(rect->pict.data[0], region->pbuf, region->buf_size);
<1> static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time)\n<5> char buf[1024];\n<37> if (!is_last_report) {\n<47> if ((cur_time - last_time) < 500000)\n<71> buf[0] = '\0';\n<79> float q = -1;\n<87> q = enc->coded_frame->quality / (float)FF_QP2LAMBDA;\n<89> if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<91> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q);\n<93> av_bprintf(&buf_script, "stream_%d_%d_q=%.1f\n",\n<99> if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<105> frame_number = ost->frame_number;\n<107> fps = t > 1 ? frame_number / t : 0;\n<109> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3.*f q=%3.1f ",\n<111> frame_number, fps < 9.95, fps, q);\n<113> av_bprintf(&buf_script, "frame=%d\n", frame_number);\n<115> av_bprintf(&buf_script, "fps=%.1f\n", fps);\n<117> av_bprintf(&buf_script, "stream_%d_%d_q=%.1f\n",\n<121> if (is_last_report)\n<123> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L");\n<135> for (j = 0; j < 32; j++)\n<137> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log2(qp_histogram[j] + 1)));\n<141> if ((enc->flags&CODEC_FLAG_PSNR) && (enc->coded_frame || is_last_report)) {\n<151> char type[3] = { 'Y','U','V' };\n<153> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR=");\n<155> for (j = 0; j < 3; j++) {\n<179> p = psnr(error / scale);\n<181> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[j], p);\n<183> av_bprintf(&buf_script, "stream_%d_%d_psnr_%c=%2.2f\n",\n<185> ost->file_index, ost->index, type[j] | 32, p);\n<191> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum / scale_sum));\n<225> secs %= 60;\n<227> hours = mins / 60;\n<229> mins %= 60;\n<237> if (total_size < 0) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<241> else                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<243> "size=%8.0fkB time=", total_size / 1024.0);\n<245> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<249> (100 * us) / AV_TIME_BASE);\n<253> if (bitrate < 0) {\n<255> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),"bitrate=N/A");\n<261> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),"bitrate=%6.1fkbits/s", bitrate);\n<263> av_bprintf(&buf_script, "bitrate=%6.1fkbits/s\n", bitrate);\n<275> av_bprintf(&buf_script, "out_time=%02d:%02d:%02d.%06d\n",\n<281> if (nb_frames_dup || nb_frames_drop)\n<283> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d",\n<287> av_bprintf(&buf_script, "dup_frames=%d\n", nb_frames_dup);\n<289> av_bprintf(&buf_script, "drop_frames=%d\n", nb_frames_drop);\n<295> const char end = is_last_report ? '\n' : '\r';\n<297> if (print_stats==1 && AV_LOG_INFO > av_log_get_level()) {\n<299> fprintf(stderr, "%s    %c", buf, end);\n<303> av_log(NULL, AV_LOG_INFO, "%s    %c", buf, end);\n<307> fflush(stderr);
<1> static uint8_t *l2cap_bframe_out(struct bt_l2cap_conn_params_s *parm, int len)\n<5> struct l2cap_chan_s *chan = (struct l2cap_chan_s *) parm;\n<9> if (len > chan->params.remote_mtu) {\n<11> fprintf(stderr, "%s: B-Frame for CID %04x longer than %i octets.\n",\n<23> return l2cap_pdu_out(chan->l2cap, chan->remote_cid, len);
<1> static void pc_init1(MemoryRegion *system_memory,\n<65> if (xen_enabled() && xen_hvm_init() != 0) {\n<67> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> int usb_desc_msos(const USBDesc *desc,  USBPacket *p,\n<3> int index, uint8_t *dest, size_t len)\n<7> void *buf = g_malloc0(4096);\n<17> length = usb_desc_msos_compat(desc, buf);\n<23> length = usb_desc_msos_prop(desc, buf);\n<31> if (length > len) {\n<33> length = len;\n<37> memcpy(dest, buf, length);\n<39> free(buf);\n<43> p->actual_length = length;
<1> static int bethsoftvid_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<20> dst = vid -> frame . data [ 0 ] ;\n<33> dst += vid -> frame . linesize [ 0 ] * yoffset ;\n<37> while ( length > remaining ) {\n<39> else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_peek_byte ( & vid -> g ) , remaining ) ;\n<40> length -= remaining ;\n<41> dst += remaining + wrap_to_next_line ;\n<43> if ( dst == frame_end ) goto end ;\n<46> else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_get_byte ( & vid -> g ) , length ) ;\n<47> remaining -= length ;\n<48> dst += length ;
<1> static void opt_frame_pad_top(const char *arg)\n<7> if (frame_padtop < 0) {\n<9> fprintf(stderr, "Incorrect top pad size\n");
<1> static int kvm_get_fpu(CPUState *env)\n<11> ret = kvm_vcpu_ioctl(env, KVM_GET_FPU, &fpu);\n<13> if (ret < 0)\n<29> memcpy(env->fpregs, fpu.fpr, sizeof env->fpregs);\n<31> memcpy(env->xmm_regs, fpu.xmm, sizeof env->xmm_regs);
<1> DriveInfo *drive_init(QemuOpts *opts, int default_to_scsi, int *fatal_error)\n<101> serial = qemu_opt_get(opts, "serial");\n<105> if ((buf = qemu_opt_get(opts, "if")) != NULL) {\n<107> pstrcpy(devname, sizeof(devname), buf);\n<109> if (!strcmp(buf, "ide")) {\n<111> type = IF_IDE;\n<113> max_devs = MAX_IDE_DEVS;\n<115> } else if (!strcmp(buf, "scsi")) {\n<117> type = IF_SCSI;\n<119> max_devs = MAX_SCSI_DEVS;\n<121> } else if (!strcmp(buf, "floppy")) {\n<123> type = IF_FLOPPY;\n<125> max_devs = 0;\n<127> } else if (!strcmp(buf, "pflash")) {\n<129> type = IF_PFLASH;\n<131> max_devs = 0;\n<133> } else if (!strcmp(buf, "mtd")) {\n<135> type = IF_MTD;\n<137> max_devs = 0;\n<139> } else if (!strcmp(buf, "sd")) {\n<141> type = IF_SD;\n<143> max_devs = 0;\n<145> } else if (!strcmp(buf, "virtio")) {\n<147> type = IF_VIRTIO;\n<149> max_devs = 0;\n<151> } else if (!strcmp(buf, "xen")) {\n<153> type = IF_XEN;\n<155> max_devs = 0;\n<157> } else if (!strcmp(buf, "none")) {\n<159> type = IF_NONE;\n<161> max_devs = 0;\n<165> error_report("unsupported bus type '%s'", buf);\n<167> return NULL;\n<175> if (cyls || heads || secs) {\n<205> if ((buf = qemu_opt_get(opts, "trans")) != NULL) {\n<207> if (!cyls) {\n<217> if (!strcmp(buf, "none"))\n<219> translation = BIOS_ATA_TRANSLATION_NONE;\n<221> else if (!strcmp(buf, "lba"))\n<223> translation = BIOS_ATA_TRANSLATION_LBA;\n<225> else if (!strcmp(buf, "auto"))\n<227> translation = BIOS_ATA_TRANSLATION_AUTO;\n<231> error_report("'%s' invalid translation type", buf);\n<233> return NULL;\n<241> if ((buf = qemu_opt_get(opts, "media")) != NULL) {\n<243> if (!strcmp(buf, "disk")) {\n<245> media = MEDIA_DISK;\n<247> } else if (!strcmp(buf, "cdrom")) {\n<249> if (cyls || secs || heads) {\n<251> error_report("'%s' invalid physical CHS format", buf);\n<261> error_report("'%s' invalid media", buf);\n<263> return NULL;\n<271> if ((buf = qemu_opt_get(opts, "cache")) != NULL) {\n<273> if (!strcmp(buf, "off") || !strcmp(buf, "none")) {\n<275> bdrv_flags |= BDRV_O_NOCACHE;\n<277> } else if (!strcmp(buf, "writeback")) {\n<279> bdrv_flags |= BDRV_O_CACHE_WB;\n<281> } else if (!strcmp(buf, "unsafe")) {\n<283> bdrv_flags |= BDRV_O_CACHE_WB;\n<285> bdrv_flags |= BDRV_O_NO_FLUSH;\n<287> } else if (!strcmp(buf, "writethrough")) {\n<293> error_report("invalid cache option");\n<295> return NULL;\n<329> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<331> if (strcmp(buf, "?") == 0) {\n<333> error_printf("Supported formats:");\n<335> bdrv_iterate_format(bdrv_format_print, NULL);\n<337> error_printf("\n");\n<339> return NULL;\n<343> drv = bdrv_find_whitelisted_format(buf);\n<345> if (!drv) {\n<525> dinfo = qemu_mallocz(sizeof(*dinfo));\n<567> if (serial)\n<569> strncpy(dinfo->serial, serial, sizeof(dinfo->serial) - 1);\n<571> QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n<699> if (ret < 0) {\n<701> error_report("could not open disk image %s: %s",\n<703> file, strerror(-ret));\n<717> return dinfo;
<1> static int spapr_nvram_init(VIOsPAPRDevice *dev)\n<23> if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n<25> fprintf(stderr, "spapr-nvram must be between %d and %d bytes in size\n",
<1> static int parse_playlist(HLSContext *c, const char *url,\n<65> if (!in) {\n<99> if (ret < 0)\n<135> read_chomp_line(in, line, sizeof(line));\n<137> if (strcmp(line, "#EXTM3U")) {\n<139> ret = AVERROR_INVALIDDATA;\n<147> if (pls) {\n<157> while (!avio_feof(in)) {\n<161> if (av_strstart(line, "#EXT-X-STREAM-INF:", &ptr)) {\n<165> memset(&variant_info, 0, sizeof(variant_info));\n<167> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n<171> } else if (av_strstart(line, "#EXT-X-KEY:", &ptr)) {\n<173> struct key_info info = {{0}};\n<175> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n<183> if (!strcmp(info.method, "AES-128"))\n<185> key_type = KEY_AES_128;\n<187> if (!strcmp(info.method, "SAMPLE-AES"))\n<189> key_type = KEY_SAMPLE_AES;\n<193> ff_hex_to_data(iv, info.iv + 2);\n<201> } else if (av_strstart(line, "#EXT-X-MEDIA:", &ptr)) {\n<205> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_rendition_args,\n<209> new_rendition(c, &info, url);\n<211> } else if (av_strstart(line, "#EXT-X-TARGETDURATION:", &ptr)) {\n<219> pls->target_duration = strtoll(ptr, NULL, 10) * AV_TIME_BASE;\n<221> } else if (av_strstart(line, "#EXT-X-MEDIA-SEQUENCE:", &ptr)) {\n<229> pls->start_seq_no = atoi(ptr);\n<231> } else if (av_strstart(line, "#EXT-X-PLAYLIST-TYPE:", &ptr)) {\n<235> if (ret < 0)\n<239> if (!strcmp(ptr, "EVENT"))\n<241> pls->type = PLS_TYPE_EVENT;\n<243> else if (!strcmp(ptr, "VOD"))\n<245> pls->type = PLS_TYPE_VOD;\n<247> } else if (av_strstart(line, "#EXT-X-MAP:", &ptr)) {\n<257> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_init_section_args,\n<261> cur_init_section = new_init_section(pls, &info, url);\n<263> } else if (av_strstart(line, "#EXT-X-ENDLIST", &ptr)) {\n<269> } else if (av_strstart(line, "#EXTINF:", &ptr)) {\n<273> duration   = atof(ptr) * AV_TIME_BASE;\n<275> } else if (av_strstart(line, "#EXT-X-BYTERANGE:", &ptr)) {\n<277> seg_size = strtoll(ptr, NULL, 10);\n<279> ptr = strchr(ptr, '@');\n<283> seg_offset = strtoll(ptr+1, NULL, 10);\n<293> if (!new_variant(c, &variant_info, line, url)) {\n<325> if (!seg) {\n<337> if (has_iv) {\n<339> memcpy(seg->iv, iv, sizeof(iv));\n<345> memset(seg->iv, 0, sizeof(seg->iv));\n<347> AV_WB32(seg->iv + 12, seq);\n<361> av_free(seg);\n<385> av_free(seg);\n<395> dynarray_add(&pls->segments, &pls->n_segments, seg);
<1> CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n<9> ulen = strlen ( userp ) ;\n<10> plen = strlen ( passwdp ) ;\n<11> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;\n<12> plainlen = 2 * ulen + plen + 2 ;\n<13> plainauth = malloc ( plainlen ) ;\n<14> if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;\n<15> memcpy ( plainauth , userp , ulen ) ;\n<16> plainauth [ ulen ] = '\0' ;\n<17> memcpy ( plainauth + ulen + 1 , userp , ulen ) ;\n<18> plainauth [ 2 * ulen + 1 ] = '\0' ;\n<19> memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ;\n<20> result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;\n<21> free ( plainauth ) ;
<1> void cpu_loop(CPUCRISState *env)\n<17> trapnr = cpu_cris_exec(cs);\n<21> switch (trapnr) {\n<103> printf ("Unhandled trap: 0x%x\n", trapnr);
<1> static void configure_alarms(char const *opt)\n<17> if (!strcmp(opt, "help")) {\n<19> show_available_alarms();\n<21> exit(0);\n<27> arg = strdup(opt);\n<33> name = strtok(arg, ",");\n<35> while (name) {\n<41> for (i = 0; i < count; i++) {\n<43> if (!strcmp(alarm_timers[i].name, name))\n<51> if (i == count) {\n<53> fprintf(stderr, "Unknown clock %s\n", name);\n<83> name = strtok(NULL, ",");\n<89> free(arg);\n<99> alarm_timers[i].name = NULL;
<1> static void test_dst_table(AcpiSdtTable *sdt_table, uint32_t addr)\n<9> memset(sdt_table, 0, sizeof(*sdt_table));\n<11> ACPI_READ_TABLE_HEADER(&sdt_table->header, addr);\n<19> sdt_table->aml = g_malloc0(sdt_table->aml_len);\n<21> ACPI_READ_ARRAY_PTR(sdt_table->aml, sdt_table->aml_len, addr);\n<25> checksum = acpi_calc_checksum((uint8_t *)sdt_table,\n<29> acpi_calc_checksum((uint8_t *)sdt_table->aml,
<1> static void channel_run(DBDMA_channel *ch)\n<29> cmd = le16_to_cpu(current->command) & COMMAND_MASK;\n<61> if (key == KEY_STREAM4) {\n<63> printf("command %x, invalid key 4\n", cmd);\n<109> if (key < KEY_REGS) {\n<111> printf("command %x, invalid key %x\n", cmd, key);
<1> static int adpcm_decode_frame(AVCodecContext *avctx,\n<55> cs = &(c->status[channel]);\n<87> if (cs->step_index > 88) fprintf(stderr, "ERROR: step_index = %i\n", cs->step_index);\n<89> if (cs->step_index > 88) cs->step_index = 88;\n<175> if (*src++) fprintf(stderr, "unused byte should be null !!\n"); /* unused */
<1> static void print_report(OutputFile *output_files,\n<9> char buf[1024];\n<33> if (!is_last_report) {\n<49> if ((cur_time - last_time) < 500000)\n<73> buf[0] = '\0';\n<79> float q = -1;\n<87> q = enc->coded_frame->quality/(float)FF_QP2LAMBDA;\n<89> if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<91> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q);\n<95> if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<101> frame_number = ost->frame_number;\n<103> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ",\n<105> frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);\n<107> if(is_last_report)\n<109> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L");\n<115> int qp = lrintf(q);\n<121> for(j=0; j<32; j++)\n<123> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log(qp_histogram[j]+1)/log(2)));\n<127> if (enc->flags&CODEC_FLAG_PSNR){\n<135> char type[3]= {'Y','U','V'};\n<137> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR=");\n<139> for(j=0; j<3; j++){\n<145> scale= enc->width*enc->height*255.0*255.0*frame_number;\n<161> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[j], psnr(error/scale));\n<165> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum/scale_sum));\n<189> secs %= 60;\n<191> hours = mins / 60;\n<193> mins %= 60;\n<197> bitrate = pts ? total_size * 8 / (pts / 1000.0) : 0;\n<201> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<203> "size=%8.0fkB time=", total_size / 1024.0);\n<205> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<209> (100 * us) / AV_TIME_BASE);\n<211> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<217> if (nb_frames_dup || nb_frames_drop)\n<219> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d",\n<225> av_log(NULL, is_last_report ? AV_LOG_WARNING : AV_LOG_INFO, "%s    \r", buf);
<1> static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) {\n<2> size_t bufsz = strlen ( root ) + sizeof ( "/sys/fs/cgroup" ) ;\n<4> char * * parts = NULL ;\n<5> char * dirname = NULL ;\n<6> char * abs_path = NULL ;\n<7> char * abs_path2 = NULL ;\n<16> if ( type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED ) {\n<21> path = calloc ( 1 , bufsz ) ;\n<22> if ( ! path ) return false ;\n<23> snprintf ( path , bufsz , "%s/sys/fs/cgroup" , root ) ;\n<24> r = mount ( "cgroup_root" , path , "tmpfs" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , "size=10240k,mode=755" ) ;\n<30> info ;\n<34> if ( ! mp ) mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ;\n<35> if ( ! mp ) {\n<39> subsystem_count = lxc_array_len ( ( void * * ) info -> hierarchy -> subsystems ) ;\n<40> parts = calloc ( subsystem_count + 1 , sizeof ( char * ) ) ;\n<41> if ( ! parts ) goto out_error ;\n<45> if ( ! strncmp ( info -> hierarchy -> subsystems [ i ] , "name=" , 5 ) ) parts [ i ] = info -> hierarchy -> subsystems [ i ] + 5 ;\n<46> else parts [ i ] = info -> hierarchy -> subsystems [ i ] ;\n<49> if ( ! dirname ) goto out_error ;\n<50> abs_path = lxc_append_paths ( path , dirname ) ;\n<51> if ( ! abs_path ) goto out_error ;\n<52> r = mkdir_p ( abs_path , 0755 ) ;\n<53> if ( r < 0 && errno != EEXIST ) {\n<54> SYSERROR ( "could not create cgroup subsystem directory /sys/fs/cgroup/%s" , dirname ) ;\n<57> abs_path2 = lxc_append_paths ( abs_path , info -> cgroup_path ) ;\n<58> if ( ! abs_path2 ) goto out_error ;\n<59> if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n<60> if ( strcmp ( mp -> mount_prefix , "/" ) != 0 ) {\n<61> ERROR ( "could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup" , dirname ) ;\n<64> r = mount ( mp -> mount_point , abs_path , "none" , MS_BIND , 0 ) ;\n<65> if ( r < 0 ) {\n<66> SYSERROR ( "error bind-mounting %s to %s" , mp -> mount_point , abs_path ) ;\n<70> r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n<71> if ( r < 0 ) {\n<72> SYSERROR ( "error re-mounting %s readonly" , abs_path ) ;\n<76> if ( type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n<78> if ( r < 0 ) {\n<79> SYSERROR ( "error bind-mounting %s onto itself" , abs_path2 ) ;\n<82> r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND , NULL ) ;\n<83> if ( r < 0 ) {\n<84> SYSERROR ( "error re-mounting %s readwrite" , abs_path2 ) ;\n<90> r = mkdir_p ( abs_path2 , 0755 ) ;\n<91> if ( r < 0 && errno != EEXIST ) {\n<92> SYSERROR ( "could not create cgroup directory /sys/fs/cgroup/%s%s" , dirname , info -> cgroup_path ) ;\n<95> if ( type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO ) {\n<97> if ( r < 0 ) {\n<98> SYSERROR ( "error bind-mounting %s onto itself" , abs_path ) ;\n<101> r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n<102> if ( r < 0 ) {\n<103> SYSERROR ( "error re-mounting %s readonly" , abs_path ) ;\n<107> free ( abs_path ) ;\n<109> abs_path = cgroup_to_absolute_path ( mp , info -> cgroup_path , NULL ) ;\n<110> if ( ! abs_path ) goto out_error ;\n<111> r = mount ( abs_path , abs_path2 , "none" , MS_BIND , 0 ) ;\n<112> if ( r < 0 ) {\n<113> SYSERROR ( "error bind-mounting %s to %s" , abs_path , abs_path2 ) ;\n<116> if ( type == LXC_AUTO_CGROUP_RO ) {\n<117> r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n<118> if ( r < 0 ) {\n<119> SYSERROR ( "error re-mounting %s readonly" , abs_path2 ) ;\n<124> free ( abs_path ) ;\n<125> free ( abs_path2 ) ;\n<126> abs_path = NULL ;\n<127> abs_path2 = NULL ;\n<128> if ( subsystem_count > 1 ) {\n<130> i < subsystem_count ;\n<132> abs_path = lxc_append_paths ( path , parts [ i ] ) ;\n<133> if ( ! abs_path ) goto out_error ;\n<134> r = symlink ( dirname , abs_path ) ;\n<135> if ( r < 0 ) WARN ( "could not create symlink %s -> %s in /sys/fs/cgroup of container" , parts [ i ] , dirname ) ;\n<136> free ( abs_path ) ;\n<137> abs_path = NULL ;\n<140> free ( dirname ) ;\n<141> free ( parts ) ;\n<142> dirname = NULL ;\n<143> parts = NULL ;\n<145> free ( path ) ;\n<147> out_error : saved_errno = errno ;\n<148> free ( path ) ;\n<149> free ( dirname ) ;\n<150> free ( parts ) ;\n<151> free ( abs_path ) ;\n<152> free ( abs_path2 ) ;\n<153> errno = saved_errno ;\n<154> return false ;
<2> ssize_t __vstrfmon_l ( char * s , size_t maxsize , __locale_t loc , const char * format , va_list ap ) {\n<133> char int_symbol [ 4 ] ;\n<134> switch ( * fmt ++ ) {\n<137> int_curr_symbol = _NL_CURRENT ( LC_MONETARY , INT_CURR_SYMBOL ) ;\n<138> strncpy ( int_symbol , int_curr_symbol , 3 ) ;\n<139> int_symbol [ 3 ] = '\0' ;\n<141> currency_symbol = & int_symbol [ 0 ] ;\n<142> space_char = int_curr_symbol [ 3 ] ;\n<146> case 'n' : currency_symbol = _NL_CURRENT ( LC_MONETARY , CURRENCY_SYMBOL ) ;\n<147> currency_symbol_len = strlen ( currency_symbol ) ;\n<172> sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n<173> if ( * sign_string == '\0' ) sign_string = ( const char * ) "-" ;\n<177> other_sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n<183> sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n<187> other_sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n<188> if ( * other_sign_string == '\0' ) other_sign_string = ( const char * ) "-" ;\n<210> int left_bytes = 0 ;\n<211> int other_left_bytes = 0 ;\n<213> left_bytes += currency_symbol_len ;\n<214> if ( sep_by_space != 0 ) ++ left_bytes ;\n<217> other_left_bytes += currency_symbol_len ;\n<218> if ( other_sep_by_space != 0 ) ++ other_left_bytes ;\n<221> else if ( sign_posn == 1 ) left_bytes += strlen ( sign_string ) ;\n<222> else if ( cs_precedes && ( sign_posn == 3 || sign_posn == 4 ) ) left_bytes += strlen ( sign_string ) ;\n<224> else if ( other_sign_posn == 1 ) other_left_bytes += strlen ( other_sign_string ) ;\n<225> else if ( other_cs_precedes && ( other_sign_posn == 3 || other_sign_posn == 4 ) ) other_left_bytes += strlen ( other_sign_string ) ;\n<226> if ( other_left_bytes > left_bytes ) left_pad = other_left_bytes - left_bytes ;\n<234> out_string ( sign_string ) ;\n<237> if ( print_curr_symbol ) out_string ( currency_symbol ) ;\n<240> out_string ( sign_string ) ;\n<245> else if ( sign_posn != 0 && sign_posn != 2 && sign_posn != 3 && sign_posn != 4 && sign_posn != 5 ) out_string ( sign_string ) ;\n<251> memset ( & info , '\0' , sizeof ( info ) ) ;\n<252> info . prec = right_prec ;\n<253> info . width = left_prec + ( right_prec ? ( right_prec + 1 ) : 0 ) ;\n<254> info . spec = 'f' ;\n<255> info . is_long_double = is_long_double ;\n<256> info . group = group ;\n<257> info . pad = pad ;\n<258> info . extra = 1 ;\n<260> done = __printf_fp ( ( FILE * ) & f , & info , & ptr ) ;\n<270> out_string ( sign_string ) ;\n<274> out_nstring ( currency_symbol , currency_symbol_len ) ;\n<278> out_string ( sign_string ) ;\n<283> out_string ( sign_string ) ;
<1> static int mpegaudio_parse(AVCodecParserContext *s1,\n<11> MpegAudioParseContext *s = s1->priv_data;\n<25> buf_ptr = buf;\n<29> len = s->inbuf_ptr - s->inbuf;\n<55> if (len > 0) {\n<57> memcpy(s->inbuf_ptr, buf_ptr, len);\n<59> buf_ptr += len;\n<61> buf_size -= len;\n<63> s->inbuf_ptr += len;\n<71> header = AV_RB32(s->inbuf);\n<77> if (ret < 0) {\n<83> memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n<239> if (len < s->frame_size) {\n<245> len = FFMIN(s->frame_size - len, buf_size);\n<247> memcpy(s->inbuf_ptr, buf_ptr, len);\n<249> buf_ptr += len;\n<251> s->inbuf_ptr += len;\n<253> buf_size -= len;\n<259> if(s->frame_size > 0 && buf_ptr - buf == s->inbuf_ptr - s->inbuf\n<273> s->inbuf_ptr = s->inbuf;\n<287> (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n<291> *poutbuf = s->inbuf;\n<293> *poutbuf_size = s->inbuf_ptr - s->inbuf;\n<297> s->inbuf_ptr = s->inbuf;
<1> static int decode_mb_cavlc(H264Context *h){\n<149> if(IS_INTRA_PCM(mb_type)){\n<213> memset(h->non_zero_count[mb_xy], 16, 16);
<1> void avfilter_uninit(void)\n<5> memset(registered_avfilters, 0, sizeof(registered_avfilters));
<1> void net_slirp_redir(const char *redir_str)\n<29> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0)\n<33> if (!strcmp(buf, "tcp")) {\n<35> is_udp = 0;\n<37> } else if (!strcmp(buf, "udp")) {\n<39> is_udp = 1;\n<49> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0)\n<55> if (r == buf)\n<61> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0)\n<71> if (!inet_aton(buf, &guest_addr))\n<79> if (r == p)\n<85> if (slirp_redir(is_udp, host_port, guest_addr, guest_port) < 0) {\n<87> fprintf(stderr, "qemu: could not set up redirection\n");\n<97> fprintf(stderr, "qemu: syntax: -redir [tcp|udp]:host-port:[guest-host]:guest-port\n");\n<99> exit(1);
<1> static inline uint8_t *bt_hci_event_start(struct bt_hci_s *hci,\n<13> if (len > 255) {\n<15> fprintf(stderr, "%s: HCI event params too long (%ib)\n",\n<39> packet[1] = len;
<1> static void virtio_blk_handle_request(VirtIOBlockReq *req,\n<65> } else if (type & VIRTIO_BLK_T_GET_ID) {\n<83> MIN(req->elem->in_sg[0].iov_len, VIRTIO_BLK_ID_BYTES));
<1> int usb_claim_port(USBDevice *dev)\n<5> USBBus *bus = usb_bus_from_device(dev);\n<15> if (dev->port_path) {\n<17> QTAILQ_FOREACH(port, &bus->free, next) {\n<19> if (strcmp(port->path, dev->port_path) == 0) {\n<27> if (port == NULL) {\n<29> error_report("Error: usb port %s (bus %s) not found (in use?)",\n<39> if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), "usb-hub") != 0) {\n<43> usb_create_simple(bus, "usb-hub");\n<61> trace_usb_port_claim(bus->busnr, port->path);\n<73> port->dev = dev;
<1> static void test_qemu_strtoull_max(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoull(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));\n<27> g_free(str);
<1> static void create_cpu(const char *cpu_model,\n<33> if (cpu == NULL) {\n<35> fprintf(stderr, "Unable to find CPU definition\n");
<1> int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n<21> if (!sps_buf)\n<25> sps = (SPS*)sps_buf->data;\n<29> sps->data_size = gb->buffer_end - gb->buffer;\n<31> if (sps->data_size > sizeof(sps->data)) {\n<35> sps->data_size = sizeof(sps->data);\n<39> memcpy(sps->data, gb->buffer, sps->data_size);\n<43> profile_idc           = get_bits(gb, 8);\n<45> constraint_set_flags |= get_bits1(gb) << 0;   // constraint_set0_flag\n<47> constraint_set_flags |= get_bits1(gb) << 1;   // constraint_set1_flag\n<49> constraint_set_flags |= get_bits1(gb) << 2;   // constraint_set2_flag\n<51> constraint_set_flags |= get_bits1(gb) << 3;   // constraint_set3_flag\n<53> constraint_set_flags |= get_bits1(gb) << 4;   // constraint_set4_flag\n<55> constraint_set_flags |= get_bits1(gb) << 5;   // constraint_set5_flag\n<57> skip_bits(gb, 2);                             // reserved_zero_2bits\n<59> level_idc = get_bits(gb, 8);\n<61> sps_id    = get_ue_golomb_31(gb);\n<65> if (sps_id >= MAX_SPS_COUNT) {\n<89> memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n<91> memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n<121> sps->chroma_format_idc = get_ue_golomb_31(gb);\n<133> sps->residual_color_transform_flag = get_bits1(gb);\n<145> sps->bit_depth_luma   = get_ue_golomb(gb) + 8;\n<147> sps->bit_depth_chroma = get_ue_golomb(gb) + 8;\n<171> sps->transform_bypass = get_bits1(gb);\n<189> log2_max_frame_num_minus4 = get_ue_golomb(gb);\n<209> sps->poc_type = get_ue_golomb_31(gb);\n<215> unsigned t = get_ue_golomb(gb);\n<229> sps->delta_pic_order_always_zero_flag = get_bits1(gb);\n<231> sps->offset_for_non_ref_pic           = get_se_golomb(gb);\n<233> sps->offset_for_top_to_bottom_field   = get_se_golomb(gb);\n<235> sps->poc_cycle_length                 = get_ue_golomb(gb);\n<255> sps->offset_for_ref_frame[i] = get_se_golomb(gb);\n<267> sps->ref_frame_count = get_ue_golomb_31(gb);\n<285> sps->gaps_in_frame_num_allowed_flag = get_bits1(gb);\n<287> sps->mb_width                       = get_ue_golomb(gb) + 1;\n<289> sps->mb_height                      = get_ue_golomb(gb) + 1;\n<307> sps->frame_mbs_only_flag = get_bits1(gb);\n<311> sps->mb_aff = get_bits1(gb);\n<319> sps->direct_8x8_inference_flag = get_bits1(gb);\n<333> sps->crop = get_bits1(gb);\n<337> unsigned int crop_left   = get_ue_golomb(gb);\n<339> unsigned int crop_right  = get_ue_golomb(gb);\n<341> unsigned int crop_top    = get_ue_golomb(gb);\n<343> unsigned int crop_bottom = get_ue_golomb(gb);\n<449> sps->vui_parameters_present_flag = get_bits1(gb);\n<453> int ret = decode_vui_parameters(gb, avctx, sps);\n<463> if (get_bits_left(gb) < 0) {\n<467> "Overread %s by %d bits\n", sps->vui_parameters_present_flag ? "VUI" : "SPS", -get_bits_left(gb));\n<557> if (ps->sps_list[sps_id] &&\n<559> !memcmp(ps->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n<561> av_buffer_unref(&sps_buf);\n<567> ps->sps_list[sps_id] = sps_buf;
<1> static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)\n<5> const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n<17> descr     = "DataHandler";\n<27> descr     = "VideoHandler";\n<33> descr     = "SoundHandler";\n<41> descr = "SubtitleHandler";\n<47> descr     = "HintHandler";\n<69> avio_wb32(pb, 0); /* reserved */\n<71> if (!track || track->mode == MODE_MOV)\n<73> avio_w8(pb, strlen(descr)); /* pascal string */\n<75> avio_write(pb, descr, strlen(descr)); /* handler description */\n<79> avio_w8(pb, 0); /* c string */\n<81> return update_size(pb, pos);
<1> static void s390_cpu_initial_reset(CPUState *s)\n<7> CPUS390XState *env = &cpu->env;
<1> void check_file_unfixed_eof_mmaps(void)\n<15> fprintf (stderr, "%s", __func__);\n<61> fprintf (stderr, " passed\n");
<1> static int filter_frame(AVFilterLink *inlink, AVFrame *inpicref)\n<253> for (j = h; j < h + b; j++)\n<255> memset(oleft->data[i] + j * s->linesize[i], 0, s->linesize[i]);\n<283> av_image_copy_plane(oleft->data[i] + out_off_left[i],
<1> static void simple_number(void)\n<41> obj = qobject_from_json(test_cases[i].encoded);\n<53> if (test_cases[i].skip == 0) {\n<61> g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
<1> void sdl_display_init(DisplayState *ds, int full_screen, int no_frame)\n<41> if (SDL_Init (flags)) {\n<43> fprintf(stderr, "Could not initialize SDL - exiting\n");
<1> static int path_has_protocol(const char *path)\n<19> return strchr(path, ':') != NULL;
<1> void ff_sbr_apply(AACContext *ac, SpectralBandReplication *sbr, int id_aac,\n<73> if (sbr->ps.start) {\n<79> memcpy(sbr->X[1], sbr->X[0], sizeof(sbr->X[0]));\n<89> sbr_qmf_synthesis(&ac->dsp, &sbr->mdct, L, sbr->X[0], sbr->qmf_filter_scratch,\n<99> sbr_qmf_synthesis(&ac->dsp, &sbr->mdct, R, sbr->X[1], sbr->qmf_filter_scratch,
<1> callback(void *priv_data, int index, uint8_t *buf, int buf_size, int64_t time)\n<35> if(av_new_packet(&pktl_next->pkt, buf_size) < 0) {\n<49> memcpy(pktl_next->pkt.data, buf, buf_size);\n<59> ctx->curbufsize += buf_size;
<1> static int yuv4_read_header(AVFormatContext *s, AVFormatParameters *ap)\n<5> char header[MAX_YUV4_HEADER+10];  // Include headroom for the longest option\n<13> int width=-1, height=-1, raten=0, rated=0, aspectn=0, aspectd=0;\n<29> if (header[i] == '\n') {\n<31> header[i+1] = 0x20;  // Add a space after last option. Makes parsing "444" vs "444alpha" easier.\n<33> header[i+2] = 0;\n<41> if (i == MAX_YUV4_HEADER) return -1;\n<43> if (strncmp(header, Y4M_MAGIC, strlen(Y4M_MAGIC))) return -1;\n<47> s1->interlaced_frame = 0;\n<49> s1->top_field_first = 0;\n<51> header_end = &header[i+1]; // Include space\n<53> for(tokstart = &header[strlen(Y4M_MAGIC) + 1]; tokstart < header_end; tokstart++) {\n<55> if (*tokstart==0x20) continue;\n<57> switch (*tokstart++) {\n<177> sscanf(tokstart,"%d:%d",&raten,&rated); // 0:0 if unknown\n<179> while(tokstart<header_end&&*tokstart!=0x20) tokstart++;\n<185> sscanf(tokstart,"%d:%d",&aspectn,&aspectd); // 0:0 if unknown\n<187> while(tokstart<header_end&&*tokstart!=0x20) tokstart++;\n<259> if (raten == 0 && rated == 0) {\n<271> if (aspectn == 0 && aspectd == 0) {\n<291> av_reduce(&raten, &rated, raten, rated, (1UL<<31)-1);\n<301> st->sample_aspect_ratio= (AVRational){aspectn, aspectd};
<11> PAVoiceIn *pa = (PAVoiceIn *) hw;\n<65> if (!pa->pcm_buf) {\n<77> if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {\n<91> free (pa->pcm_buf);
<1> static void read_SCP_info(SCLPDevice *sclp, SCCB *sccb)\n<5> ReadInfo *read_info = (ReadInfo *) sccb;\n<165> if (ipib && ipib->flags & DIAG308_FLAGS_LP_VALID) {
<1> static int raw_pwrite(BlockDriverState *bs, int64_t offset,\n<3> const uint8_t *buf, int count)\n<7> BDRVRawState *s = bs->opaque;\n<17> if (s->aligned_buf != NULL) {\n<27> ret = raw_pread_aligned(bs, offset - shift, s->aligned_buf, 512);\n<29> if (ret < 0)\n<35> size = 512 - shift;\n<37> if (size > count)\n<39> size = count;\n<41> memcpy(s->aligned_buf + shift, buf, size);\n<45> ret = raw_pwrite_aligned(bs, offset - shift, s->aligned_buf, 512);\n<53> buf += size;\n<55> offset += size;\n<57> count -= size;\n<59> sum += size;\n<73> while ((size = (count & ~0x1ff)) != 0) {\n<77> if (size > ALIGNED_BUFFER_SIZE)\n<79> size = ALIGNED_BUFFER_SIZE;\n<83> memcpy(s->aligned_buf, buf, size);\n<87> ret = raw_pwrite_aligned(bs, offset, s->aligned_buf, size);\n<95> buf += ret;\n<109> ret = raw_pread_aligned(bs, offset, s->aligned_buf, 512);\n<111> if (ret < 0)\n<115> memcpy(s->aligned_buf, buf, count);\n<119> ret = raw_pwrite_aligned(bs, offset, s->aligned_buf, 512);\n<125> if (count < ret)
<1> static int mov_read_uuid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n<61> } else if (ret != sizeof(uuid)) {\n<67> if (!memcmp(uuid, uuid_isml_manifest, sizeof(uuid))) {\n<73> size_t len = atom.size - sizeof(uuid);\n<77> if (len < 4) {\n<155> } else if (!memcmp(uuid, uuid_xmp, sizeof(uuid))) {\n<159> size_t len = atom.size - sizeof(uuid);\n<161> if (c->export_xmp) {\n<205> } else if (!memcmp(uuid, uuid_spherical, sizeof(uuid))) {\n<207> size_t len = atom.size - sizeof(uuid);\n<209> ret = mov_parse_uuid_spherical(sc, pb, len);\n<211> if (ret < 0)\n<221> return 0;
<1> static void parse_error(JSONParserContext *ctxt, QObject *token, const char *msg, ...)\n<5> fprintf(stderr, "parse error: %s\n", msg);
<1> static void alloc_picture(void *opaque)\n<11> vp = &is->pictq[is->pictq_windex];\n<55> if (!vp->bmp || vp->bmp->pitches[0] < vp->width) {\n<61> fprintf(stderr, "Error: the video system does not support an image\n"
<1> void ff_h264_direct_ref_list_init(const H264Context *const h, H264SliceContext *sl)\n<31> if (h->picture_structure == PICT_FRAME) {\n<33> memcpy(cur->ref_count[1], cur->ref_count[0], sizeof(cur->ref_count[0]));\n<35> memcpy(cur->ref_poc[1],   cur->ref_poc[0],   sizeof(cur->ref_poc[0]));
<1> static unsigned int dec_move_sr(DisasContext *dc)\n<5> DIS(fprintf (logfile, "move $s%u, $r%u\n", dc->op2, dc->op1));\n<7> cris_cc_mask(dc, 0);\n<11> tcg_const_tl(dc->op1), tcg_const_tl(dc->op2));
<1> static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,\n<7> PNGEncContext *s = avctx->priv_data;\n<99> ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);\n<101> if (ret < 0)\n<107> memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);\n<109> pkt->size = s->last_frame_packet_size;\n<121> s->bytestream       = s->last_frame_packet;\n<161> uint8_t* last_fctl_chunk_start = pkt->data;\n<207> if (!s->prev_frame) {\n<223> if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)\n<233> memcpy(s->prev_frame->data[0], s->last_frame->data[0],\n<235> s->last_frame->linesize[0] * s->last_frame->height);\n<243> for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {\n<245> size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;\n<247> memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);
<1> BusState *qbus_create(BusInfo *info, DeviceState *parent, const char *name)\n<13> bus = qemu_mallocz(info->size);\n<27> } else if (parent && parent->id) {\n<31> len = strlen(parent->id) + 16;\n<33> buf = qemu_malloc(len);\n<35> snprintf(buf, len, "%s.%d", parent->id, parent->num_child_bus);\n<43> len = strlen(info->name) + 16;\n<45> buf = qemu_malloc(len);
<1> static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n<147> if (s != ide_if && !s->bs)\n<687> if (!s->is_cf)\n<695> memset(s->io_buffer, 0, 0x200);\n<705> s->io_buffer[0x04] = ide_get_sector(s) >> 16;	/* LBA MSB */\n<707> s->io_buffer[0x05] = ide_get_sector(s) >> 8;	/* LBA */\n<709> s->io_buffer[0x06] = ide_get_sector(s) >> 0;	/* LBA LSB */\n<719> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);
<1> static void blkdebug_refresh_filename(BlockDriverState *bs)\n<13> for (e = qdict_first(bs->options); e; e = qdict_next(bs->options, e)) {\n<15> if (strcmp(qdict_entry_key(e), "config") &&\n<17> strcmp(qdict_entry_key(e), "x-image") &&\n<19> strcmp(qdict_entry_key(e), "image") &&\n<21> strncmp(qdict_entry_key(e), "image.", strlen("image.")))\n<25> force_json = true;\n<73> for (e = qdict_first(bs->options); e; e = qdict_next(bs->options, e)) {\n<75> if (strcmp(qdict_entry_key(e), "x-image") &&\n<77> strcmp(qdict_entry_key(e), "image") &&\n<79> strncmp(qdict_entry_key(e), "image.", strlen("image.")))\n<83> qobject_incref(qdict_entry_value(e));\n<85> qdict_put_obj(opts, qdict_entry_key(e), qdict_entry_value(e));
<1> static int pci_e1000_init(PCIDevice *pci_dev)\n<41> d->mmio_index = cpu_register_io_memory(e1000_mmio_read,\n<99> vmstate_register(-1, &vmstate_e1000, d);\n<101> e1000_reset(d);
<1> static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) {\n<4> pix = bytestream2_get_byte ( & s -> stream_ptr ) ;\n<6> y < 8 ;\n<8> memset ( s -> pixel_ptr , pix , 8 ) ;\n<9> s -> pixel_ptr += s -> stride ;
<1> START_TEST(qstring_from_str_test)\n<11> qstring = qstring_from_str(str);\n<13> fail_unless(qstring != NULL);\n<17> fail_unless(strcmp(str, qstring->string) == 0);\n<19> fail_unless(qobject_type(QOBJECT(qstring)) == QTYPE_QSTRING);\n<25> g_free(qstring->string);
<1> static int msrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> MsrleContext * s = avctx -> priv_data ;\n<15> if ( avctx -> bits_per_coded_sample <= 8 ) {\n<16> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<17> if ( pal ) {\n<19> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<21> memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n<24> int linesize = avctx -> width * avctx -> bits_per_coded_sample / 8 ;\n<25> uint8_t * ptr = s -> frame . data [ 0 ] ;\n<26> uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ;\n<31> if ( avctx -> bits_per_coded_sample == 4 ) {\n<35> ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n<36> ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF ;\n<38> if ( avctx -> width & 1 ) ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n<41> memcpy ( ptr , buf , linesize ) ;\n<43> buf -= istride ;\n<44> ptr += s -> frame . linesize [ 0 ] ;
<1> static int load_flat_file(struct linux_binprm * bprm,\n<39> data_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n<41> bss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n<65> if (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n<67> fprintf(stderr, "BINFMT_FLAT: bad magic/rev (0x%x, need 0x%x)\n",\n<79> if (rev == OLD_FLAT_VERSION && id != 0) {\n<81> fprintf(stderr, "BINFMT_FLAT: shared libraries are not available\n");\n<105> if (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n<107> fprintf(stderr, "Support for ZFLAT executables is not enabled\n");\n<169> if (textpos == -1) {\n<171> fprintf(stderr, "Unable to mmap process text\n");\n<187> if (realdatastart == -1) {\n<189> fprintf(stderr, "Unable to allocate RAM for process data\n");\n<229> if (result < 0) {\n<231> fprintf(stderr, "Unable to read data+bss\n");\n<255> if (textpos == -1 ) {\n<257> fprintf(stderr, "Unable to allocate RAM for process text/data\n");\n<267> datapos = realdatastart + indx_len;\n<339> if (result < 0) {\n<341> fprintf(stderr, "Unable to read code+data+bss\n");\n<493> for (i = 0; i < relocs; i++) {\n<565> for (i = 0; i < relocs; i++) {\n<583> memset((void *)((unsigned long)datapos + data_len), 0, bss_len);
<1> static int curl_open(BlockDriverState *bs, const char *filename, int flags)\n<5> BDRVCURLState *s = bs->opaque;\n<29> file = strdup(filename);\n<37> ra = file + strlen(file) - 1;\n<39> while (ra >= file) {\n<53> if (*ra > '9' || *ra < '0') {\n<55> char *opt_start = ra - strlen(RA_OPTSTR) + 1;\n<57> if (opt_start > file &&\n<59> strncmp(opt_start, RA_OPTSTR, strlen(RA_OPTSTR)) == 0) {\n<61> ra_val = ra + 1;\n<63> ra -= strlen(RA_OPTSTR) - 1;\n<87> if ((s->readahead_size & 0x1ff) != 0) {\n<89> fprintf(stderr, "HTTP_READAHEAD_SIZE %Zd is not a multiple of 512\n",\n<115> if (!state)\n<129> if (curl_easy_perform(state->curl))\n<143> else if(!s->len)\n<181> fprintf(stderr, "CURL: Error opening file: %s\n", state->errmsg);
<1> static int process_line(URLContext *h, char *line, int line_count,\n<37> s->http_code = strtol(p, &end, 10);\n<49> if (s->http_code >= 400 && s->http_code < 600 && (s->http_code != 401\n<55> end += strspn(end, SPACE_CHARS);\n<57> av_log(h, AV_LOG_WARNING, "HTTP error %d %s\n",\n<81> p++;\n<83> while (isspace(*p))\n<85> p++;\n<103> if (!strncmp (p, "bytes ", 6)) {\n<107> s->off = strtoll(p, NULL, 10);\n<109> if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n<111> s->filesize = strtoll(slash+1, NULL, 10);\n<119> } else if (!av_strcasecmp(tag, "Accept-Ranges") && !strncmp(p, "bytes", 5) && s->seekable == -1) {\n<123> } else if (!av_strcasecmp (tag, "Transfer-Encoding") && !av_strncasecmp(p, "chunked", 7)) {\n<141> } else if (!av_strcasecmp (tag, "Connection")) {\n<143> if (!strcmp(p, "close"))\n<145> s->willclose = 1;
<1> static void scsi_disk_emulate_write_same(SCSIDiskReq *r, uint8_t *inbuf)\n<49> if (buffer_is_zero(inbuf, s->qdev.blocksize)) {\n<85> data->nb_sectors = nb_sectors * (s->qdev.blocksize / 512);\n<89> data->iov.iov_base = buf = qemu_blockalign(s->qdev.conf.bs, data->iov.iov_len);\n<95> for (i = 0; i < data->iov.iov_len; i += s->qdev.blocksize) {\n<97> memcpy(&buf[i], inbuf, s->qdev.blocksize);
<1> static void read_sbr_invf ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data ) {\n<3> memcpy ( ch_data -> bs_invf_mode [ 1 ] , ch_data -> bs_invf_mode [ 0 ] , 5 * sizeof ( uint8_t ) ) ;
<1> aio_write_f(int argc, char **argv)\n<13> struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n<19> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<57> ctx->offset = cvtnum(argv[optind]);\n<59> if (ctx->offset < 0) {\n<61> printf("non-numeric length argument -- %s\n", argv[optind]);\n<71> if (ctx->offset & 0x1ff) {\n<75> (long long)ctx->offset);\n<83> if (count & 0x1ff) {\n<103> if (len < 0) {\n<105> printf("non-numeric length argument -- %s\n", argv[i]);\n<119> qemu_iovec_init(&ctx->qiov, nr_iov);\n<129> len = cvtnum(argv[optind]);\n<131> if (len < 0) {\n<143> qemu_iovec_add(&ctx->qiov, p, len);\n<153> gettimeofday(&ctx->t1, NULL);\n<155> acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,
<1> static void ide_drive_pre_save(void *opaque)\n<27> if (s->end_transfer_fn_idx == -1) {\n<29> fprintf(stderr, "%s: invalid end_transfer_func for DRQ_STAT\n",
<1> int main ( int argc , char * * argv ) {\n<3> if ( argc != 2 ) {\n<4> fprintf ( stderr , "One argument, the input filename, must be provided.\n" ) ;\n<9> fprintf ( stdout , "Processing %s => %s\n" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n<15> if ( ! woff2 : : ConvertTTFToWOFF2 ( input_data , input . size ( ) , output_data , & output_size ) ) {\n<16> fprintf ( stderr , "Compression failed.\n" ) ;
<1> envlist_setenv(envlist_t *envlist, const char *env)\n<13> if ((envlist == NULL) || (env == NULL))\n<21> if ((eq_sign = strchr(env, '=')) == NULL)\n<23> return (EINVAL);\n<25> envname_len = eq_sign - env + 1;\n<39> for (entry = envlist->el_entries.lh_first; entry != NULL;\n<43> if (strncmp(entry->ev_var, env, envname_len) == 0)\n<51> if (entry != NULL) {\n<53> LIST_REMOVE(entry, ev_link);\n<55> free((char *)entry->ev_var);\n<57> free(entry);\n<67> if ((entry = malloc(sizeof (*entry))) == NULL)\n<69> return (errno);\n<71> if ((entry->ev_var = strdup(env)) == NULL) {\n<73> free(entry);\n<75> return (errno);\n<79> LIST_INSERT_HEAD(&envlist->el_entries, entry, ev_link);\n<83> return (0);
<1> static int wavpack_encode_block(WavPackEncodeContext *s,\n<3> int32_t *samples_l, int32_t *samples_r,\n<31> diff |= samples_l[i] - samples_r[i];\n<85> shift_mono(samples_l, nb_samples, shift);\n<89> shift_stereo(samples_l, samples_r, nb_samples, shift);\n<105> if ((s->flags & WV_FLOAT_DATA) || (s->flags & MAG_MASK) >> MAG_LSB >= 24) {\n<107> av_fast_padded_malloc(&s->orig_l, &s->orig_l_size, sizeof(int32_t) * nb_samples);\n<109> memcpy(s->orig_l, samples_l, sizeof(int32_t) * nb_samples);\n<111> if (!(s->flags & WV_MONO_DATA)) {\n<113> av_fast_padded_malloc(&s->orig_r, &s->orig_r_size, sizeof(int32_t) * nb_samples);\n<115> memcpy(s->orig_r, samples_r, sizeof(int32_t) * nb_samples);\n<123> got_extra = scan_float(s, samples_l, samples_r, nb_samples);\n<127> got_extra = scan_int32(s, samples_l, samples_r, nb_samples);\n<155> ret = wv_mono(s, samples_l, 1, 0);\n<159> ret = wv_stereo(s, samples_l, samples_r, 1, 0);\n<177> ret = wv_mono(s, samples_l, !s->num_terms, 1);\n<189> ret = wv_stereo(s, samples_l, samples_r, !s->num_terms, 1);
<1> static void sd_reset(SDState *sd, BlockBackend *blk)\n<43> sd_set_sdstatus(sd);\n<61> memset(sd->function_group, 0, sizeof(sd->function_group));
<1> static uint8_t virtio_scsi_do_command(QVirtIOSCSI *vs, const uint8_t *cdb,\n<13> QVirtIOSCSICmdReq req = { { 0 } };\n<33> memcpy(req.cdb, cdb, CDB_SIZE);
<1> static int vtd_interrupt_remap_msi(IntelIOMMUState *iommu,\n<19> assert(origin && translated);\n<23> if (!iommu || !iommu->intr_enabled) {\n<47> addr.data = origin->address & VTD_MSI_ADDR_LO_MASK;\n<63> if (addr.int_mode != VTD_IR_INT_FORMAT_REMAP) {\n<171> memcpy(translated, origin, sizeof(*origin));
<1> static int cloop_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<7> BDRVCloopState *s = bs->opaque;\n<21> if (cloop_read_block(bs, block_num) != 0) {\n<27> memcpy(buf + i * 512,\n<29> s->uncompressed_block + sector_offset_in_block * 512, 512);
<1> static int match_group_separator(const OptionGroupDef *groups, const char *opt)\n<5> const OptionGroupDef *p = groups;\n<9> while (p->name) {\n<11> if (p->sep && !strcmp(p->sep, opt))\n<13> return p - groups;\n<15> p++;
<1> static void dump_metadata(void *ctx, AVDictionary *m, const char *indent)\n<13> while((tag=av_dict_get(m, "", tag, AV_DICT_IGNORE_SUFFIX))) {\n<15> if(strcmp("language", tag->key)){\n<17> const char *p = tag->value;\n<19> av_log(ctx, AV_LOG_INFO, "%s  %-16s: ", indent, tag->key);\n<21> while(*p) {\n<41> av_log(ctx, AV_LOG_INFO, "\n");
<1> static void mainstone_common_init(MemoryRegion *address_space_mem,\n<69> if (qtest_enabled()) {\n<75> fprintf(stderr, "Two flash images must be given with the "\n<85> if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n<97> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> SCSIRequest *scsi_req_new(SCSIDevice *d, uint32_t tag, uint32_t lun,\n<3> uint8_t *buf, void *hba_private)\n<11> memcpy(req->cmd.buf, buf, 16);
<1> static int pxa2xx_pwrmode_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n<6> if ( value & 8 ) {\n<7> printf ( "%s: CPU voltage change attempt\n" , __func__ ) ;\n<9> switch ( value & 7 ) {\n<11> case 1 : if ( ! ( s -> cm_regs [ CCCR >> 2 ] & ( 1 << 31 ) ) ) {\n<25> memset ( s -> cpu -> env . regs , 0 , 4 * 15 ) ;\n<33> default : message : printf ( "%s: machine entered %s mode\n" , __func__ , pwrmode [ value & 7 ] ) ;
<1> void net_hub_check_clients(void)\n<13> QLIST_FOREACH(hub, &hubs, next) {\n<25> fprintf(stderr, "Warning: hub port %s has no peer\n",\n<67> warn_report("vlan %d with no nics", hub->id);\n<71> if (has_nic && !has_host_dev) {
<1> static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n<12> if ( appheadsz > 0 ) {\n<13> char * start = ( char * ) apphead ;\n<17> memset ( parsed , 0 , sizeof ( parsed ) ) ;\n<18> while ( ( slash = strchr ( start , '/' ) ) != NULL ) {\n<19> * slash = 0 ;\n<20> parsed [ place ++ ] = start ;\n<21> start = slash + 1 ;\n<23> parsed [ place ++ ] = start ;\n<25> main_get_appheader_params ( output , parsed , 1 , "output" , ifile ) ;\n<28> main_get_appheader_params ( sfile , parsed + 2 , 0 , "source" , ifile ) ;
<1> void net_slirp_hostfwd_remove(Monitor *mon, const QDict *qdict)\n<49> if (!src_str || !src_str[0])\n<57> get_str_sep(buf, sizeof(buf), &p, ':');\n<61> if (!strcmp(buf, "tcp") || buf[0] == '\0') {\n<63> is_udp = 0;\n<65> } else if (!strcmp(buf, "udp")) {\n<67> is_udp = 1;\n<77> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<111> monitor_printf(mon, "invalid format\n");
<1> static void s390_cpu_full_reset(CPUState *s)\n<9> CPUS390XState *env = &cpu->env;\n<23> memset(env, 0, offsetof(CPUS390XState, end_reset_fields));\n<45> for (i = 0; i < ARRAY_SIZE(env->io_index); i++) {\n<57> set_float_detect_tininess(float_tininess_before_rounding,
<1> static void opt_qmin(const char *arg)\n<11> fprintf(stderr, "qmin must be >= 1 and <= 31\n");
<1> static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n<15> memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n<49> words[bit / 64] |= 1ULL << (63 - bit % 64);
<1> static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) {\n<4> if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ;\n<5> if ( strlen ( client_p -> id ) == 3 ) {\n<6> exit_client ( client_p , client_p , client_p , "Mixing client and server protocol" ) ;\n<7> return 0 ;\n<9> saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ;\n<10> if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) {\n<18> if ( strlen ( parv [ 1 ] ) > 400 ) {\n<19> sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? "*" : source_p -> name ) ;\n<20> return 0 ;\n<22> if ( ! * source_p -> id ) {\n<26> if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ;\n<27> if ( agent_p == NULL ) {\n<29> if ( ! strcmp ( parv [ 1 ] , "EXTERNAL" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , ":%s ENCAP %s SASL %s %s S %s %s" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ;\n<30> else sendto_one ( saslserv_p , ":%s ENCAP %s SASL %s %s S %s" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ;\n<33> else sendto_one ( agent_p , ":%s ENCAP %s SASL %s %s C %s" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ;\n<34> source_p -> localClient -> sasl_out ++ ;\n<35> return 0 ;
<1> int qemu_acl_party_is_allowed(qemu_acl *acl,\n<3> const char *party)\n<11> TAILQ_FOREACH(entry, &acl->entries, next) {\n<25> if (strcmp(entry->match, party) == 0)\n<27> return entry->deny ? 0 : 1;\n<35> return acl->defaultDeny ? 0 : 1;
<1> static char * unescape_word ( struct Curl_easy * data , const char * inputbuff ) {\n<9> if ( ! newp ) return NULL ;\n<10> dictp = malloc ( ( ( size_t ) len ) * 2 + 1 ) ;\n<22> free ( newp ) ;\n<23> return dictp ;
<1> static int read_restart_header(MLPDecodeContext *m, BitstreamContext *bc,\n<7> SubStream *s = &m->substream[substr];\n<117> if (min_channel > max_channel) {\n<191> memset(s->ch_assign, 0, sizeof(s->ch_assign));\n<195> for (ch = 0; ch <= s->max_matrix_channel; ch++) {\n<251> memset(s->output_shift   , 0, sizeof(s->output_shift   ));\n<253> memset(s->quant_step_size, 0, sizeof(s->quant_step_size));
<1> static int read_gab2_sub(AVStream *st, AVPacket *pkt)\n<5> if (pkt->size >= 7 &&\n<7> !strcmp(pkt->data, "GAB2") && AV_RL16(pkt->data + 5) == 2) {\n<19> AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n<21> pkt->size - 7,\n<63> if (!(ast->sub_ctx = avformat_alloc_context()))\n<85> ast->sub_buffer = pkt->data;\n<87> memset(pkt, 0, sizeof(*pkt));
<1> static int32_t u_printf_octal_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n<7> ufmt_64tou ( result , & len , num , 8 , FALSE , info -> fPrecision == - 1 && info -> fZero ? info -> fWidth : info -> fPrecision ) ;\n<8> if ( info -> fAlt && result [ 0 ] != 0x0030 && len < UPRINTF_BUFFER_SIZE - 1 ) {\n<9> memmove ( result + 1 , result , len * sizeof ( UChar ) ) ;\n<13> return handler -> pad_and_justify ( context , info , result , len ) ;
<1> void *kvmppc_create_spapr_tce(uint32_t liobn, uint32_t window_size, int *pfd,\n<9> .liobn = liobn,\n<41> if (fd < 0) {\n<43> fprintf(stderr, "KVM: Failed to create TCE table for liobn 0x%x\n",\n<61> if (table == MAP_FAILED) {\n<63> fprintf(stderr, "KVM: Failed to map TCE table for liobn 0x%x\n",
<1> static void pci_init_mask_bridge(PCIDevice *d)\n<9> memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);\n<15> d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;\n<17> d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;\n<39> memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);
<1> static int writev_f(BlockBackend *blk, int argc, char **argv)\n<27> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<73> offset = cvtnum(argv[optind]);\n<75> if (offset < 0) {\n<77> printf("non-numeric length argument -- %s\n", argv[optind]);\n<119> if (cnt < 0) {\n<121> printf("writev failed: %s\n", strerror(-cnt));
<1> static void opt_frame_size(const char *arg)\n<5> if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {\n<7> fprintf(stderr, "Incorrect frame size\n");\n<13> if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {\n<15> fprintf(stderr, "Frame size must be a multiple of 2\n");
<1> static void bt_l2cap_sdp_sdu_in(void *opaque, const uint8_t *data, int len)\n<9> uint8_t rsp[MAX_PDU_OUT_SIZE - PDU_HEADER_SIZE], *sdu_out;\n<19> if (len < 5) {\n<21> fprintf(stderr, "%s: short SDP PDU (%iB).\n", __func__, len);\n<29> pdu_id = *data ++;\n<41> if (len != plen) {\n<43> fprintf(stderr, "%s: wrong SDP PDU length (%iB != %iB).\n",\n<55> switch (pdu_id) {\n<59> rsp_len = sdp_svc_search(sdp, rsp, data, len);\n<69> rsp_len = sdp_attr_get(sdp, rsp, data, len);\n<79> rsp_len = sdp_svc_search_attr_get(sdp, rsp, data, len);\n<97> fprintf(stderr, "%s: unexpected SDP PDU ID %02x.\n",\n<127> rsp[rsp_len ++] = err & 0xff;\n<133> sdu_out = sdp->channel->sdu_out(sdp->channel, rsp_len + PDU_HEADER_SIZE);\n<137> sdu_out[0] = pdu_id;\n<139> sdu_out[1] = transaction_id >> 8;\n<141> sdu_out[2] = transaction_id & 0xff;\n<143> sdu_out[3] = rsp_len >> 8;\n<145> sdu_out[4] = rsp_len & 0xff;\n<147> memcpy(sdu_out + PDU_HEADER_SIZE, rsp, rsp_len);
<1> static inline int parse_nal_units(AVCodecParserContext *s, AVCodecContext *avctx,\n<7> HEVCContext   *h  = &((HEVCParseContext *)s->priv_data)->h;\n<45> if (!tmp)\n<49> h->nals = tmp;\n<51> memset(h->nals, 0, sizeof(*tmp));\n<59> nal = &h->nals[0];\n<93> consumed = ff_hevc_extract_rbsp(h, buf, src_length, nal);\n<107> ff_hevc_decode_nal_vps(h);\n<113> ff_hevc_decode_nal_sps(h);\n<119> ff_hevc_decode_nal_pps(h);\n<127> ff_hevc_decode_nal_sei(h);\n<171> if (IS_IRAP(h)) {\n<297> if (!IS_IDR(h)) {\n<301> s->output_picture_number = h->poc = ff_hevc_compute_poc(h, sh->pic_order_cnt_lsb);
<1> int inet_listen_opts(QemuOpts *opts, int port_offset)\n<19> memset(&ai,0, sizeof(ai));\n<21> ai.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n<23> ai.ai_family = PF_UNSPEC;\n<25> ai.ai_socktype = SOCK_STREAM;\n<29> if ((qemu_opt_get(opts, "host") == NULL) ||\n<31> (qemu_opt_get(opts, "port") == NULL)) {\n<33> fprintf(stderr, "%s: host and/or port not specified\n", __FUNCTION__);\n<39> pstrcpy(port, sizeof(port), qemu_opt_get(opts, "port"));\n<41> addr = qemu_opt_get(opts, "host");\n<49> ai.ai_family = PF_INET;\n<53> ai.ai_family = PF_INET6;\n<61> snprintf(port, sizeof(port), "%d", atoi(port) + port_offset);\n<63> rc = getaddrinfo(strlen(addr) ? addr : NULL, port, &ai, &res);\n<65> if (rc != 0) {\n<67> fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port,\n<69> gai_strerror(rc));\n<79> for (e = res; e != NULL; e = e->ai_next) {\n<81> getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n<89> if (slisten < 0) {\n<91> fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__,\n<93> inet_strfamily(e->ai_family), strerror(errno));\n<129> if (!try_next)\n<131> fprintf(stderr,"%s: bind(%s,%s,%d): %s\n", __FUNCTION__,\n<133> inet_strfamily(e->ai_family), uaddr, inet_getport(e),\n<135> strerror(errno));\n<153> fprintf(stderr, "%s: FAILED\n", __FUNCTION__);\n<155> freeaddrinfo(res);\n<169> freeaddrinfo(res);\n<177> qemu_opt_set(opts, "host", uaddr);\n<185> freeaddrinfo(res);
<1> static int ftp_send_command(FTPContext *s, const char *command,\n<13> if ((err = ftp_flush_control_input(s)) < 0)\n<23> if ((err = ffurl_write(s->conn_control, command, strlen(command))) < 0)\n<37> return ftp_status(s, response, response_codes);
<1> void ff_init_elbg(int *points, int dim, int numpoints, int *codebook,\n<19> int *temp_points = av_malloc(dim*(numpoints/8)*sizeof(int));\n<21> for (i=0; i<numpoints/8; i++) {\n<25> memcpy(temp_points + i*dim, points + k*dim, dim*sizeof(int));\n<43> for (i=0; i < numCB; i++)\n<45> memcpy(codebook + i*dim, points + ((i*BIG_PRIME)%numpoints)*dim,\n<47> dim*sizeof(int));
<27> if (!sps_buf)\n<675> if (s->sps_list[sps_id] &&\n<677> !memcmp(s->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n<679> av_buffer_unref(&sps_buf);\n<691> av_buffer_unref(&s->sps_list[sps_id]);\n<693> s->sps_list[sps_id] = sps_buf;
<1> static void assigned_dev_msix_mmio_write(void *opaque, target_phys_addr_t addr,\n<3> uint64_t val, unsigned size)\n<7> AssignedDevice *adev = opaque;\n<19> if (i >= adev->msix_max) {\n<31> DEBUG("write to MSI-X table offset 0x%lx, val 0x%lx\n", addr, val);\n<43> memcpy((uint8_t *)adev->msix_table + addr, &val, size);
<1> static void ppc_core99_init (ram_addr_t ram_size,\n<77> if (!env) {\n<79> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<159> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n<173> if (vga_bios_size < 0) {\n<177> fprintf(stderr, "qemu: warning: could not load VGA bios '%s'\n",\n<323> if (ppc_boot_device == '\0') {\n<325> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<475> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<477> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static void *kvm_cpu_thread_fn(void *arg)\n<19> if (r < 0) {\n<21> fprintf(stderr, "kvm_init_vcpu failed: %s\n", strerror(-r));
<1> static gcry_err_code_t sexp_data_to_mpi ( gcry_sexp_t input , gcry_mpi_t * ret_mpi , struct pk_encoding_ctx * ctx ) {\n<23> if ( ! s ) ;\n<24> else if ( n == 7 && ! memcmp ( s , "rfc6979" , 7 ) ) parsed_flags |= PUBKEY_FLAG_RFC6979 ;\n<25> else if ( n == 5 && ! memcmp ( s , "eddsa" , 5 ) ) {\n<26> ctx -> encoding = PUBKEY_ENC_RAW ;\n<27> parsed_flags |= PUBKEY_FLAG_EDDSA ;\n<29> else if ( n == 3 && ! memcmp ( s , "raw" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n<30> ctx -> encoding = PUBKEY_ENC_RAW ;\n<31> explicit_raw = 1 ;\n<33> else if ( n == 5 && ! memcmp ( s , "pkcs1" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n<34> else if ( n == 4 && ! memcmp ( s , "oaep" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n<35> else if ( n == 3 && ! memcmp ( s , "pss" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PSS ;\n<36> else if ( n == 11 && ! memcmp ( s , "no-blinding" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n<37> else unknown_flag = 1 ;\n<110> s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n<111> if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n<113> random_override = gcry_malloc ( n ) ;\n<114> if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n<116> memcpy ( random_override , s , n ) ;\n<117> random_override_len = n ;\n<123> rc = pkcs1_encode_for_encryption ( ret_mpi , ctx -> nbits , value , valuelen , random_override , random_override_len ) ;\n<160> s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n<161> if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n<163> ctx -> label = gcry_malloc ( n ) ;\n<164> if ( ! ctx -> label ) rc = gpg_err_code_from_syserror ( ) ;\n<166> memcpy ( ctx -> label , s , n ) ;\n<167> ctx -> labellen = n ;\n<175> s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n<176> if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n<177> else if ( n > 0 ) {\n<178> random_override = gcry_malloc ( n ) ;\n<179> if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n<181> memcpy ( random_override , s , n ) ;\n<182> random_override_len = n ;\n<188> rc = oaep_encode ( ret_mpi , ctx -> nbits , ctx -> hash_algo , value , valuelen , ctx -> label , ctx -> labellen , random_override , random_override_len ) ;\n<217> s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n<218> if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n<220> random_override = gcry_malloc ( n ) ;\n<221> if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n<223> memcpy ( random_override , s , n ) ;\n<224> random_override_len = n ;\n<230> rc = pss_encode ( ret_mpi , ctx -> nbits - 1 , ctx -> hash_algo , value , valuelen , ctx -> saltlen , random_override , random_override_len ) ;\n<255> gcry_free ( ctx -> label ) ;
<1> static void handle_windowevent(SDL_Event *ev)\n<17> switch (ev->window.event) {\n<25> memset(&info, 0, sizeof(info));\n<31> dpy_set_ui_info(scon->dcl.con, &info);
<1> void uuid_generate(uuid_t out)\n<5> memset(out, 0, sizeof(uuid_t));
<1> void tcg_context_init(TCGContext *s)\n<15> memset(s, 0, sizeof(*s));\n<71> tcg_target_init(s);
<1> kadm5_ret_t kadm5_delete_policy ( void * server_handle , kadm5_policy_t name ) {\n<7> if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n<8> if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n<9> ret = krb5_db_get_policy ( handle -> context , name , & entry ) ;\n<10> if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;
<16> static void feature_destroy ( hb_feature_t * g ) {\n<17> free ( g ) ;\n<19> HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n<20> hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n<21> if ( unlikely ( ! c ) ) return NULL ;
<1> static int rm_assemble_video_frame(AVFormatContext *s, RMContext *rm, AVPacket *pkt, int len)\n<123> AV_WL32(rm->videobuf - 3 + 8*rm->cur_slice, rm->videobufpos - 8*rm->slices - 1);\n<139> if(type == 2 || (rm->videobufpos) == rm->videobufsize){\n<143> memmove(rm->videobuf + 1 + 8*rm->cur_slice, rm->videobuf + 1 + 8*rm->slices, rm->videobufsize - 1 - 8*rm->slices);\n<149> rm->videobuf[0] = rm->cur_slice-1;\n<151> if(av_new_packet(pkt, ssize) < 0)\n<155> memcpy(pkt->data, rm->videobuf, ssize);
<1> static inline void _t_gen_mov_TN_env(TCGv tn, int offset)\n<5> if (offset > sizeof(CPUCRISState)) {\n<7> fprintf(stderr, "wrong load from env from off=%d\n", offset);\n<11> tcg_gen_ld_tl(tn, cpu_env, offset);
<1> int sws_setColorspaceDetails(struct SwsContext *c, const int inv_table[4],\n<3> int srcRange, const int table[4], int dstRange,\n<13> memcpy(c->srcColorspaceTable, inv_table, sizeof(int) * 4);\n<15> memcpy(c->dstColorspaceTable, table, sizeof(int) * 4);\n<41> ff_yuv2rgb_c_init_tables(c, inv_table, srcRange, brightness,\n<51> ff_yuv2rgb_init_tables_altivec(c, inv_table, brightness,
<1> static inline int bidir_refine(MpegEncContext * s, int mb_x, int mb_y)\n<47> memset(map,0,sizeof(map));
<1> static void spitz_common_init(ram_addr_t ram_size, int vga_ram_size,\n<25> if (ram_size < SPITZ_RAM + SPITZ_ROM + PXA2XX_INTERNAL_SIZE) {\n<27> fprintf(stderr, "This platform requires %i bytes of memory\n",
<1> static int put_flac_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)\n<15> } else if (codec->extradata_size == FLAC_STREAMINFO_SIZE) {\n<25> } else if(memcmp("fLaC", codec->extradata, 4)) {\n<27> av_log(s, AV_LOG_ERROR, "Invalid FLAC extradata\n");\n<29> return -1;\n<33> put_buffer(pb, codec->extradata, codec->extradata_size);\n<35> return 0;
<1> static void gpio_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n<9> D(printf("%s %x=%x\n", __func__, addr, (unsigned)value));\n<13> addr >>= 2;
<1> static int slirp_guestfwd(SlirpState *s, const char *config_str,\n<33> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<39> if (strcmp(buf, "tcp") && buf[0] != '\0') {\n<45> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<123> error_report("invalid guest forwarding rule '%s'", config_str);\n<125> return -1;
<1> vpx_codec_err_t vpx_svc_encode ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx , struct vpx_image * rawimg , vpx_codec_pts_t pts , int64_t duration , int deadline ) {\n<6> SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n<7> if ( svc_ctx == NULL || codec_ctx == NULL || si == NULL ) {\n<11> si -> rc_stats_buf_used = 0 ;\n<56> if ( new_size > si -> rc_stats_buf_size ) {\n<57> char * p = ( char * ) realloc ( si -> rc_stats_buf , new_size ) ;\n<58> if ( p == NULL ) {\n<62> si -> rc_stats_buf = p ;\n<63> si -> rc_stats_buf_size = new_size ;\n<65> memcpy ( si -> rc_stats_buf + si -> rc_stats_buf_used , cx_pkt -> data . twopass_stats . buf , cx_pkt -> data . twopass_stats . sz ) ;\n<66> si -> rc_stats_buf_used += cx_pkt -> data . twopass_stats . sz ;
<1> static int sd_create(const char *filename, QEMUOptionParameter *options,\n<29> memset(tag, 0, sizeof(tag));\n<31> if (strstr(filename, "://")) {\n<33> ret = sd_parse_uri(s, filename, s->name, &snapid, tag);\n<37> ret = parse_vdiname(s, filename, s->name, &snapid, tag);\n<49> while (options && options->name) {\n<51> if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n<53> s->inode.vdi_size = options->value.n;\n<55> } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FILE)) {\n<57> backing_file = options->value.s;\n<59> } else if (!strcmp(options->name, BLOCK_OPT_PREALLOC)) {\n<61> if (!options->value.s || !strcmp(options->value.s, "off")) {\n<63> prealloc = false;\n<65> } else if (!strcmp(options->value.s, "full")) {\n<67> prealloc = true;\n<71> error_report("Invalid preallocation mode: '%s'",\n<73> options->value.s);\n<75> ret = -EINVAL;\n<81> } else if (!strcmp(options->name, BLOCK_OPT_REDUNDANCY)) {\n<83> ret = parse_redundancy(s, options->value.s);\n<85> if (ret < 0) {\n<93> options++;\n<111> if (backing_file) {\n<125> if (!drv || strcmp(drv->protocol_name, "sheepdog") != 0) {\n<127> error_report("backing_file must be a sheepdog image");\n<129> ret = -EINVAL;\n<137> ret = bdrv_file_open(&bs, backing_file, NULL, 0, &local_err);\n<139> if (ret < 0) {
<1> static int virtio_ccw_cb(SubchDev *sch, CCW1 ccw)\n<21> VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n<215> features.features = address_space_ldl_le(&address_space_memory,\n<231> } else if ((features.index == 1) && (dev->revision >= 1)) {\n<259> if (features.features) {\n<261> fprintf(stderr, "Guest bug: features[%i]=%x (expected 0)\n",\n<339> if (!config) {\n<345> len = hw_len;\n<347> memcpy(vdev->config, config, len);\n<349> cpu_physical_memory_unmap(config, hw_len, 0, hw_len);\n<351> virtio_bus_set_vdev_config(&dev->bus, vdev->config);\n<353> sch->curr_status.scsw.count = ccw.count - len;
<1> static void ppc_prep_init (int ram_size, int vga_ram_size,\n<61> if (!env) {\n<63> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<197> if (ppc_boot_device == '\0') {\n<199> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<259> if (nd_table[i].model == NULL\n<261> || strcmp(nd_table[i].model, "ne2k_isa") == 0) {\n<263> isa_ne2000_init(ne2000_io[i], i8259[ne2000_irq[i]], &nd_table[i]);\n<267> pci_nic_init(pci_bus, &nd_table[i], -1);
<1> static int ehci_state_fetchentry(EHCIState *ehci, int async)\n<25> if (async && (NLPTR_TYPE_GET(entry) != NLPTR_TYPE_QH)) {\n<27> fprintf(stderr, "non queue head request in async schedule\n");\n<35> switch (NLPTR_TYPE_GET(entry)) {\n<71> fprintf(stderr, "FETCHENTRY: entry at %X is of type %d "\n<73> "which is not supported yet\n", entry, NLPTR_TYPE_GET(entry));
<1> static int bethsoftvid_decode_frame(AVCodecContext *avctx,\n<39> dst = vid->frame.data[0];\n<73> dst += vid->frame.linesize[0] * yoffset;\n<89> while(length > remaining){\n<95> else if(block_type == VIDEO_I_FRAME)\n<97> memset(dst, bytestream2_peek_byte(&vid->g), remaining);\n<99> length -= remaining;      // decrement the number of bytes to be copied\n<101> dst += remaining + wrap_to_next_line;    // skip over extra bytes at end of frame\n<105> if(dst == frame_end)\n<119> else if(block_type == VIDEO_I_FRAME)\n<121> memset(dst, bytestream2_get_byte(&vid->g), length);\n<123> remaining -= length;\n<125> dst += length;
<1> void checkasm_report(const char *name, ...)\n<9> if (state.num_checked > prev_checked) {\n<15> if (*name) {\n<23> fprintf(stderr, " - ");\n<27> pad_length -= vfprintf(stderr, name, arg);\n<31> fprintf(stderr, "%*c", FFMAX(pad_length, 0) + 2, '[');\n<35> fprintf(stderr, " - %-*s [", max_length, state.current_func->name);\n<47> fprintf(stderr, "]\n");\n<63> if (*name) {\n<67> va_start(arg, name);\n<69> length = vsnprintf(NULL, 0, name, arg);\n<71> va_end(arg);\n<75> length = strlen(state.current_func->name);\n<79> if (length > max_length)
<1> write_f(int argc, char **argv)\n<25> while ((c = getopt(argc, argv, "bCpP:q")) != EOF) {\n<75> if (bflag && pflag) {\n<77> printf("-b and -p cannot be specified at the same time\n");\n<85> offset = cvtnum(argv[optind]);\n<87> if (offset < 0) {\n<89> printf("non-numeric length argument -- %s\n", argv[optind]);\n<99> count = cvtnum(argv[optind]);\n<101> if (count < 0) {\n<103> printf("non-numeric length argument -- %s\n", argv[optind]);\n<113> if (offset & 0x1ff) {\n<125> if (count & 0x1ff) {\n<161> if (cnt < 0) {\n<163> printf("write failed: %s\n", strerror(-cnt));
<1> static void qdev_prop_cpy(DeviceState *dev, Property *props, void *src)\n<5> if (props->info->type == PROP_TYPE_BIT) {\n<13> char *dst = qdev_get_prop_ptr(dev, props);\n<15> memcpy(dst, src, props->info->size);
<1> static void v9fs_req_recv(P9Req *req, uint8_t id)\n<53> if (hdr.id == P9_RLERROR) {\n<57> v9fs_uint32_read(req, &err);\n<59> g_printerr("Rlerror has errno %d (%s)\n", err, strerror(err));
<1> static int rv34_decode_mv(RV34DecContext *r, int block_type)\n<17> memset(r->dmv, 0, sizeof(r->dmv));\n<43> rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n<79> s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]);\n<83> rv34_mc_2mv(r, block_type);\n<87> rv34_mc_2mv_skip(r);\n<97> rv34_pred_mv(r, block_type, 0, 0);\n<99> rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);\n<113> rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD);\n<117> rv34_pred_mv_b  (r, block_type, block_type == RV34_MB_B_BACKWARD);\n<119> rv34_mc_1mv     (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD);\n<127> rv34_pred_mv(r, block_type, 0, 0);\n<129> rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1);\n<133> rv34_mc_1mv(r, block_type, 0, 0, 0,            2, 1, 0);\n<135> rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0);\n<141> rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0);\n<143> rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0);\n<151> rv34_pred_mv_b  (r, block_type, 0);\n<153> rv34_pred_mv_b  (r, block_type, 1);\n<155> rv34_mc_2mv     (r, block_type);\n<163> rv34_pred_mv(r, block_type, i, i);\n<165> rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0);
<1> static int kvm_put_xsave(X86CPU *cpu)\n<5> CPUX86State *env = &cpu->env;\n<7> struct kvm_xsave* xsave = env->kvm_xsave_buf;\n<15> if (!kvm_has_xsave()) {\n<23> memset(xsave, 0, sizeof(struct kvm_xsave));\n<43> memcpy(&xsave->region[XSAVE_CWD_RIP], &env->fpip, sizeof(env->fpip));\n<45> memcpy(&xsave->region[XSAVE_CWD_RDP], &env->fpdp, sizeof(env->fpdp));\n<47> memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,\n<51> memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,\n<59> memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,\n<63> memcpy(&xsave->region[XSAVE_BNDREGS], env->bnd_regs,\n<67> memcpy(&xsave->region[XSAVE_BNDCSR], &env->bndcs_regs,\n<71> memcpy(&xsave->region[XSAVE_OPMASK], env->opmask_regs,\n<75> memcpy(&xsave->region[XSAVE_ZMM_Hi256], env->zmmh_regs,\n<87> r = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_XSAVE, xsave);
<1> static int decode_frame(AVCodecContext *avctx,\n<21> uint8_t *ptr[AV_NUM_DATA_POINTERS];\n<111> buf += 20;\n<119> buf += 3;\n<135> avctx->sample_aspect_ratio.den = read32(&buf, endian);\n<275> buf =  avpkt->data + offset;\n<395> for (x = 0; x < avctx->height; x++) {\n<397> memcpy(ptr[0], buf, elements*avctx->width);\n<399> ptr[0] += p->linesize[0];\n<401> buf += elements*avctx->width;
<1> static void write_streaminfo(FlacEncodeContext *s, uint8_t *header)\n<9> memset(header, 0, FLAC_STREAMINFO_SIZE);\n<11> init_put_bits(&pb, header, FLAC_STREAMINFO_SIZE);
<1> static void xen_ram_init(ram_addr_t ram_size)\n<27> ram_list.phys_dirty = qemu_realloc(ram_list.phys_dirty,\n<31> memset(ram_list.phys_dirty + (new_block->offset >> TARGET_PAGE_BITS),\n<33> 0xff, new_block->length >> TARGET_PAGE_BITS);
<1> static unsigned int dec_addi_r(DisasContext *dc)\n<9> memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n<11> cris_cc_mask(dc, 0);
<1> static int avi_read_header(AVFormatContext *s)\n<19> AVIStream *ast      = NULL;\n<215> if (!ast)\n<219> st->priv_data = ast;\n<263> ast = s->streams[0]->priv_data;\n<287> s->streams[0]->priv_data = ast;\n<293> ast->rate  = avio_rl32(pb);\n<301> if (ast->scale > 0 && ast->rate > 0 && dv_dur > 0) {\n<305> s->duration = av_rescale(dv_dur, ast->scale, ast->rate);\n<343> if (!(ast->scale && ast->rate)) {\n<371> avpriv_set_pts_info(st, 64, ast->scale, ast->rate);\n<389> ast->cum_len    *= FFMAX(1, ast->sample_size);\n<435> if (ast->sample_size == 0)\n<439> ast->frame_offset = ast->cum_len;\n<511> if (!st->codec->extradata) {\n<569> memcpy(ast->pal, pal_src, pal_size);\n<573> ast->has_pal = 1;\n<603> !memcmp(&st->codec->extradata[28], "1:1", 3))\n<627> memcpy(st->codec->extradata + st->codec->extradata_size - 9,\n<643> ret = ff_get_wav_header(pb, st->codec, size);\n<649> ast->dshow_block_align = st->codec->block_align;\n<651> if (ast->sample_size && st->codec->block_align &&\n<653> ast->sample_size != st->codec->block_align) {\n<665> ast->sample_size = st->codec->block_align;\n<711> ast->dshow_block_align = 0;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> EightBpsContext * const c = avctx -> priv_data ;\n<60> if ( avctx -> bits_per_coded_sample <= 8 ) {\n<61> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<62> if ( pal ) {\n<64> memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n<66> memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;
<1> static void new_video_stream(AVFormatContext *oc, int file_idx)\n<151> p= video_rc_override_string;\n<153> for(i=0; p; i++){\n<157> int e=sscanf(p, "%d,%d,%d", &start, &end, &q);\n<159> if(e!=3){\n<161> fprintf(stderr, "error parsing rc_override\n");\n<173> video_enc->rc_override[i].start_frame= start;\n<175> video_enc->rc_override[i].end_frame  = end;\n<177> if(q>0){\n<179> video_enc->rc_override[i].qscale= q;\n<189> video_enc->rc_override[i].quality_factor= -q/100.0;\n<193> p= strchr(p, '/');\n<195> if(p) p++;
<1> static void qemu_event_increment(void)\n<23> } while (ret < 0 && errno == EINTR);\n<29> if (ret < 0 && errno != EAGAIN) {\n<31> fprintf(stderr, "qemu_event_increment: write() filed: %s\n",\n<33> strerror(errno));
<1> static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,\n<7> IscsiLun *iscsilun = bs->opaque;\n<67> if (iscsi_url == NULL) {\n<79> memset(iscsilun, 0, sizeof(IscsiLun));\n<197> iscsilun->aio_context = bdrv_get_aio_context(bs);\n<201> iscsilun->has_write_same = true;\n<205> task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 0, 0,\n<227> if (iscsilun->type == TYPE_DISK && (flags & BDRV_O_RDWR) &&\n<229> iscsi_is_write_protected(iscsilun)) {\n<241> iscsi_readcapacity_sync(iscsilun, &local_err);\n<253> bs->total_sectors = sector_lun2qemu(iscsilun->num_blocks, iscsilun);\n<267> if (iscsilun->type != TYPE_DISK && iscsilun->type != TYPE_ROM) {\n<275> task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n<301> inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n<307> if (inq_task == NULL) {\n<325> inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n<331> if (inq_task == NULL) {\n<361> iscsi_attach_aio_context(bs, iscsilun->aio_context);\n<371> if (iscsilun->bl.opt_unmap_gran * iscsilun->block_size >= 4 * 1024 &&\n<373> iscsilun->bl.opt_unmap_gran * iscsilun->block_size <= 16 * 1024 * 1024) {\n<375> iscsilun->cluster_sectors = (iscsilun->bl.opt_unmap_gran *\n<379> if (iscsilun->lbprz && !(bs->open_flags & BDRV_O_NOCACHE)) {\n<381> iscsilun->allocationmap = iscsi_allocationmap_init(iscsilun);\n<383> if (iscsilun->allocationmap == NULL) {\n<415> if (ret) {\n<423> memset(iscsilun, 0, sizeof(IscsiLun));
<1> writev_f(int argc, char **argv)\n<25> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<63> offset = cvtnum(argv[optind]);\n<65> if (offset < 0) {\n<67> printf("non-numeric length argument -- %s\n", argv[optind]);\n<77> if (offset & 0x1ff) {\n<103> if (cnt < 0) {\n<105> printf("writev failed: %s\n", strerror(-cnt));
<1> static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)\n<43> AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL,0);\n<115> put16(&q, 0xe000 | ts_st->pid);\n<125> switch(st->codec->codec_type) {\n<175> for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {\n<177> next = strchr(p, ',');\n<179> if (strlen(p) != 3 && (!next || next != p + 3))\n<185> *q++ = *p++;\n<187> *q++ = *p++;\n<189> *q++ = *p++;\n<193> if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)\n<211> *len_ptr += 4;\n<229> const char default_language[] = "und";\n<231> const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;\n<235> if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n<249> while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */\n<251> *q++ = *language++;\n<253> *q++ = *language++;\n<255> *q++ = *language++;\n<259> if (*language != '\0')\n<261> language++;\n<265> if (st->codec->extradata_size - extradata_copied >= 5) {\n<267> *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */\n<269> memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */\n<273> q += 4;\n<283> *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;\n<285> if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {\n<289> memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */\n<293> q += 4;\n<299> put16(&q, 1); /* ancillary_page_id */\n<311> } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {\n<327> while (strlen(language) >= 3) {\n<329> *q++ = *language++;\n<331> *q++ = *language++;\n<333> *q++ = *language++;\n<337> if (*language != '\0')\n<339> language++;\n<343> if (st->codec->extradata_size - 1 > extradata_copied) {\n<345> memcpy(q, st->codec->extradata + extradata_copied, 2);\n<349> q += 2;
<1> static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)\n<9> uint8_t buf1[60];\n<33> if (size < MIN_BUF_SIZE) {\n<35> memcpy(buf1, buf, size);\n<37> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<39> buf = buf1;
<1> static void bt_submit_acl(struct HCIInfo *info,\n<17> if (length < HCI_ACL_HDR_SIZE) {\n<19> fprintf(stderr, "%s: ACL packet too short (%iB)\n",\n<41> if (bt_hci_handle_bad(hci, handle)) {\n<43> fprintf(stderr, "%s: invalid ACL handle %03x\n",\n<57> if (datalen > length) {\n<59> fprintf(stderr, "%s: ACL packet too short (%iB < %iB)\n",\n<79> else if (handle != hci->asb_handle) {\n<81> fprintf(stderr, "%s: Bad handle %03x in Active Slave Broadcast\n",\n<105> else if (handle != hci->psb_handle) {\n<107> fprintf(stderr, "%s: Bad handle %03x in Parked Slave Broadcast\n",
<1> static int write_elf32_note(DumpState *s)\n<15> memset(&phdr, 0, sizeof(Elf32_Phdr));\n<31> ret = fd_write_vmcore(&phdr, sizeof(Elf32_Phdr), s);
<1> static int decode_mb(H264Context *h){\n<29> if (s->mb_skip_run--) {\n<41> memset(h->non_zero_count[mb_xy], 0, 16+4+4);\n<43> memset(h->non_zero_count_cache + 8, 0, 8*5); //FIXME ugly, remove pfui\n<177> if(IS_INTRA_PCM(mb_type)){\n<237> memset(h->non_zero_count[mb_xy], 16, 16+4+4);\n<671> if(cbp || IS_INTRA16x16(mb_type)){\n<847> memset(&h->non_zero_count_cache[8], 0, 8*5);
<1> static void object_set_link_property(Object *obj, Visitor *v, void *opaque,\n<17> type = object_property_get_type(obj, name, NULL);\n<21> visit_type_str(v, &path, name, errp);\n<33> if (strcmp(path, "") != 0) {\n<39> target = object_resolve_path(path, &ambiguous);\n<41> if (target) {\n<51> if (strcmp(target_type, type) == 0) {\n<53> *child = target;\n<55> object_ref(target);\n<59> error_set(errp, QERR_INVALID_PARAMETER_TYPE, name, type);\n<65> g_free(target_type);\n<75> *child = NULL;\n<81> g_free(path);
<1> static int map_f(BlockBackend *blk, int argc, char **argv)\n<23> if (total_sectors < 0) {\n<25> error_report("Failed to query image length: %s",\n<27> strerror(-total_sectors));\n<43> if (ret < 0) {\n<45> error_report("Failed to get allocation status: %s", strerror(-ret));
<1> static int decode_frame(AVCodecContext * avctx,\n<9> MPADecodeContext *s = avctx->priv_data;\n<21> buf_ptr = buf;\n<25> len = s->inbuf_ptr - s->inbuf;\n<35> s->inbuf[0] = s->free_format_next_header >> 24;\n<37> s->inbuf[1] = s->free_format_next_header >> 16;\n<39> s->inbuf[2] = s->free_format_next_header >> 8;\n<41> s->inbuf[3] = s->free_format_next_header;\n<61> if (len > 0) {\n<63> memcpy(s->inbuf_ptr, buf_ptr, len);\n<65> buf_ptr += len;\n<67> buf_size -= len;\n<69> s->inbuf_ptr += len;\n<73> if ((s->inbuf_ptr - s->inbuf) >= HEADER_SIZE) {\n<77> header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n<79> (s->inbuf[2] << 8) | s->inbuf[3];\n<83> if (ff_mpa_check_header(header) < 0) {\n<87> memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n<101> if (decode_header(s, header) == 1) {\n<161> if (len == 0) {\n<167> memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n<181> memcpy(s->inbuf_ptr, buf_ptr, len);\n<185> p = s->inbuf_ptr - 3;\n<187> pend = s->inbuf_ptr + len - 4;\n<195> header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n<197> (s->inbuf[2] << 8) | s->inbuf[3];\n<211> buf_ptr += len;\n<237> decode_header(s, header1);\n<249> buf_ptr += len;\n<251> s->inbuf_ptr += len;\n<253> buf_size -= len;\n<257> } else if (len < s->frame_size) {\n<265> if (len > buf_size)\n<267> len = buf_size;\n<269> memcpy(s->inbuf_ptr, buf_ptr, len);\n<271> buf_ptr += len;\n<273> s->inbuf_ptr += len;\n<275> buf_size -= len;\n<283> (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n<289> *(uint8_t **)data = s->inbuf;\n<291> out_size = s->inbuf_ptr - s->inbuf;\n<295> out_size = mp_decode_frame(s, out_samples);\n<299> s->inbuf_ptr = s->inbuf;
<1> int MPV_encode_init(AVCodecContext *avctx)\n<139> if (h263_get_picture_format(s->width, s->height) == 7) {\n<141> printf("Input picture size isn't suitable for h263 codec! try h263+\n");\n<261> if((s->flags&CODEC_FLAG_4MV) && !(s->flags&CODEC_FLAG_HQ)){\n<263> printf("4MV is currently only supported in HQ mode\n");\n<275> if(!done){\n<281> memset(default_mv_penalty, 0, sizeof(UINT16)*(MAX_FCODE+1)*(2*MAX_MV+1));\n<283> memset(default_fcode_tab , 0, sizeof(UINT8)*(2*MAX_MV+1));\n<297> s->mv_penalty= default_mv_penalty;\n<299> s->fcode_tab= default_fcode_tab;\n<315> if (s->me_method < ME_EPZS) s->mv_penalty = default_mv_penalty;
<1> vsprintf_len(string, format, args)\n<3> char *string;\n<5> const char *format;\n<7> va_list args;\n<11> vsprintf(string, format, args);\n<13> return strlen(string);
<1> static int svq3_decode_mb(SVQ3Context *svq3, unsigned int mb_type)\n<5> H264Context *h = &svq3->h;\n<57> if (svq3_mc_dir(h, mb_type, PREDICT_MODE, 1, 1) < 0)\n<105> if (s->mb_x > 0 && h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - 1]+6] != -1) {\n<123> if (s->mb_y > 0) {\n<125> memcpy(h->mv_cache[m][scan8[0] - 1*8], s->current_picture.f.motion_val[m][b_xy - h->b_stride], 4*2*sizeof(int16_t));\n<127> memset(&h->ref_cache[m][scan8[0] - 1*8], (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - s->mb_stride]] == -1) ? PART_NOT_AVAILABLE : 1, 4);\n<137> (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - s->mb_stride + 1]+6] == -1 ||\n<139> h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - s->mb_stride    ]  ] == -1) ? PART_NOT_AVAILABLE : 1;\n<149> h->ref_cache[m][scan8[0] - 1 - 1*8] = (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - s->mb_stride - 1]+3] == -1) ? PART_NOT_AVAILABLE : 1;\n<157> memset(&h->ref_cache[m][scan8[0] - 1*8 - 1], PART_NOT_AVAILABLE, 8);\n<173> if (svq3_mc_dir(h, (mb_type - 1), mode, 0, 0) < 0)\n<181> if (svq3_mc_dir(h, 0, mode, 0, 0) < 0)\n<187> for (i = 0; i < 4; i++) {\n<189> memset(s->current_picture.f.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<197> if (svq3_mc_dir(h, 0, mode, 1, (mb_type == 3)) < 0)\n<203> for (i = 0; i < 4; i++) {\n<205> memset(s->current_picture.f.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<217> } else if (mb_type == 8 || mb_type == 33) {   /* INTRA4x4 */\n<219> memset(h->intra4x4_pred_mode_cache, -1, 8*5*sizeof(int8_t));\n<281> left    = &h->intra4x4_pred_mode_cache[scan8[i] - 1];\n<283> top     = &h->intra4x4_pred_mode_cache[scan8[i] - 8];\n<305> for (i = 0; i < 4; i++) {\n<307> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8*i], DC_PRED, 4);\n<315> write_back_intra_pred_mode(h);\n<321> ff_h264_check_intra4x4_pred_mode(h);\n<331> for (i = 0; i < 4; i++) {\n<333> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8*i], DC_128_PRED, 4);\n<357> if ((h->intra16x16_pred_mode = ff_h264_check_intra_pred_mode(h, dir)) == -1){\n<377> for (i = 0; i < 4; i++) {\n<379> memset(s->current_picture.f.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<385> for (i = 0; i < 4; i++) {\n<387> memset(s->current_picture.f.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<395> if (!IS_INTRA4x4(mb_type)) {\n<397> memset(h->intra4x4_pred_mode+h->mb2br_xy[mb_xy], DC_PRED, 8);\n<401> if (!IS_SKIP(mb_type) || s->pict_type == AV_PICTURE_TYPE_B) {\n<403> memset(h->non_zero_count_cache + 8, 0, 14*8*sizeof(uint8_t));\n<555> h->chroma_pred_mode = ff_h264_check_intra_pred_mode(h, DC_PRED8x8);
<1> int avio_printf(AVIOContext *s, const char *fmt, ...)\n<13> va_start(ap, fmt);\n<15> ret = vsnprintf(buf, sizeof(buf), fmt, ap);\n<17> va_end(ap);\n<19> avio_write(s, buf, strlen(buf));\n<21> return ret;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<7> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<14> if ( ( ret = avctx -> reget_buffer ( avctx , p ) ) < 0 ) {\n<24> qpeg_decode_intra ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height ) ;\n<27> qpeg_decode_inter ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height , delta , ctable , a -> refdata ) ;\n<29> if ( pal ) {\n<31> memcpy ( a -> pal , pal , AVPALETTE_SIZE ) ;\n<33> memcpy ( a -> pic . data [ 1 ] , a -> pal , AVPALETTE_SIZE ) ;
<1> static void do_video_out(AVFormatContext *s,\n<49> vdelta = get_sync_ipts(ost) / av_q2d(enc->time_base) - ost->sync_opts;\n<59> ost->sync_opts= lrintf(get_sync_ipts(ost) / av_q2d(enc->time_base));\n<71> if (verbose>2)\n<73> fprintf(stderr, "*** drop!\n");\n<79> if (verbose>2)\n<81> fprintf(stderr, "*** %d dup!\n", nb_frames-1);\n<87> ost->sync_opts= lrintf(get_sync_ipts(ost) / av_q2d(enc->time_base));\n<277> if (ret == -1) {\n<279> fprintf(stderr, "Video encoding failed\n");\n<323> if (ost->logfile && enc->stats_out) {\n<325> fprintf(ost->logfile, "%s", enc->stats_out);
<1> int net_init_slirp(QemuOpts *opts,\n<55> if (qemu_opt_get(opts, "ip")) {\n<57> const char *ip = qemu_opt_get(opts, "ip");\n<59> int l = strlen(ip) + strlen("/24") + 1;\n<63> vnet = qemu_malloc(l);\n<69> pstrcpy(vnet, l, ip);
<1> static int cfhd_decode(AVCodecContext *avctx, void *data, int *got_frame,\n<467> coeff_data = s->plane[s->channel_num].subband[s->subband_num_actual];\n<521> coeff_data += lowpass_width;\n<535> if (lowpass_height & 1) {\n<537> memcpy(&coeff_data[lowpass_height * lowpass_width],\n<541> lowpass_width * sizeof(*coeff_data));\n<645> *coeff_data++ = coeff;\n<683> *coeff_data++ = coeff;\n<731> if (highpass_height & 1) {\n<733> memcpy(&coeff_data[highpass_height * highpass_stride],\n<737> highpass_stride * sizeof(*coeff_data));
<1> static int testit ( struct test_case_struct * tc ) {\n<15> we = sav_we ;\n<16> printf ( "Test %d (%s): " , ++ tests , tc -> words ) ;\n<18> if ( wordexp ( "pre1 pre2" , & we , tc -> flags & ~ WRDE_APPEND ) != 0 ) {\n<19> printf ( "FAILED setup\n" ) ;\n<23> retval = wordexp ( tc -> words , & we , tc -> flags ) ;\n<25> if ( retval != tc -> retval || ( retval == 0 && we . we_wordc != tc -> wordc ) ) bzzzt = 1 ;\n<26> else if ( retval == 0 ) {\n<34> i < we . we_wordc ;\n<35> ++ i ) if ( we . we_wordv [ i + start_offs ] == NULL || strcmp ( tc -> wordv [ i ] , we . we_wordv [ i + start_offs ] ) != 0 ) {\n<40> if ( bzzzt ) {\n<41> printf ( "FAILED\n" ) ;\n<42> printf ( "Test words: <%s>, need retval %d, wordc %Zd\n" , tc -> words , tc -> retval , tc -> wordc ) ;\n<43> if ( start_offs != 0 ) printf ( "(preceded by %d NULLs)\n" , start_offs ) ;\n<44> printf ( "Got retval %d, wordc %Zd: " , retval , we . we_wordc ) ;\n<45> if ( retval == 0 || retval == WRDE_NOSPACE ) {\n<47> i < we . we_wordc + start_offs ;\n<48> ++ i ) if ( we . we_wordv [ i ] == NULL ) printf ( "NULL " ) ;\n<49> else printf ( "<%s> " , we . we_wordv [ i ] ) ;\n<51> printf ( "\n" ) ;\n<53> else if ( retval != 0 && retval != WRDE_NOSPACE && ( we . we_wordc != sav_we . we_wordc || we . we_wordv != sav_we . we_wordv || we . we_offs != sav_we . we_offs ) ) {\n<55> printf ( "FAILED to restore wordexp_t members\n" ) ;\n<57> else printf ( "OK\n" ) ;\n<58> if ( retval == 0 || retval == WRDE_NOSPACE ) wordfree ( & we ) ;
<1> static void build_file_streams(void)\n<13> for(stream = config.first_stream; stream; stream = stream_next) {\n<29> if (stream->fmt && !strcmp(stream->fmt->name, "rtp")) {\n<35> av_dict_set(&stream->in_opts, "mpeg2ts_compute_pcr", "1", 0);\n<67> remove_stream(stream);\n<93> add_av_stream1(stream, infile->streams[i]->codec, 1);
<1> void test_fenv(void)\n<57> TEST_ENV(&float_env32, "fnstenv", "fldenv");\n<75> printf("fptag=%04x\n", float_env32.fptag);
<1> int kvmppc_remove_spapr_tce(void *table, int fd, uint32_t window_size)\n<23> fprintf(stderr, "KVM: Unexpected error removing TCE table: %s",\n<25> strerror(errno));
<1> void nonono(const char* file, int line, const char* msg) {\n<3> fprintf(stderr, "Nonono! %s:%d %s\n", file, line, msg);
<1> void bios_linker_loader_add_checksum(GArray *linker, const char *file,\n<15> memset(&entry, 0, sizeof entry);\n<17> strncpy(entry.cksum.file, file, sizeof entry.cksum.file - 1);\n<29> g_array_append_val(linker, entry);
<1> static void tftp_handle_rrq(struct tftp_t *tp, int pktlen)\n<25> spt = &tftp_sessions[s];\n<29> src = tp->x.tp_buf;\n<57> if (src[k] == '\0') {\n<81> if ((n - k) < 6) {\n<89> if (memcmp(&src[k], "octet\0", 6) != 0) {\n<91> tftp_send_error(spt, 4, "Unsupported transfer mode", tp);\n<93> return;\n<99> k += 6; /* skipping octet */\n<107> if ((spt->filename[0] != '/')\n<109> || (spt->filename[strlen((char *)spt->filename) - 1] == '/')\n<111> ||  strstr((char *)spt->filename, "/../")) {\n<113> tftp_send_error(spt, 2, "Access violation", tp);\n<127> tftp_send_error(spt, 2, "Access violation", tp);\n<139> if (tftp_read_data(spt, 0, spt->filename, 0) < 0) {\n<159> while (k < n) {\n<165> key = (char *)src + k;\n<167> k += strlen(key) + 1;\n<171> if (k >= n) {\n<181> value = (char *)src + k;\n<183> k += strlen(value) + 1;\n<187> if (strcmp(key, "tsize") == 0) {\n<189> int tsize = atoi(value);\n<195> if (tsize == 0 && tftp_prefix) {
<1> static int fileTest(uint8_t *ref[4], int refStride[4], int w, int h, FILE *fp,\n<13> while (fgets(buf, sizeof(buf), fp)) {\n<19> char srcStr[12];\n<25> char dstStr[12];\n<45> if (ret != 12) {\n<47> srcStr[0] = dstStr[0] = 0;\n<49> ret       = sscanf(buf, "%12s -> %12s\n", srcStr, dstStr);\n<55> srcFormat = av_get_pix_fmt(srcStr);\n<57> dstFormat = av_get_pix_fmt(dstStr);\n<61> if (srcFormat == AV_PIX_FMT_NONE || dstFormat == AV_PIX_FMT_NONE) {\n<63> fprintf(stderr, "malformed input file\n");\n<75> if (ret != 12) {\n<77> printf("%s", buf);\n<97> return 0;
<1> static void fill_picture_parameters(const AVCodecContext *avctx, AVDXVAContext *ctx, const H264Context *h,\n<3> DXVA_PicParams_H264 *pp)\n<17> memset(pp, 0, sizeof(*pp));\n<33> for (i = 0, j = 0; i < FF_ARRAY_ELEMS(pp->RefFrameList); i++) {\n<75> pp->UsedForReferenceFlags |= 1 << (2*i + 0);\n<79> pp->UsedForReferenceFlags |= 1 << (2*i + 1);
<1> void powerpc_display_perf_report(void)\n<9> fprintf(stderr, "PowerPC performance report\n Values are from the Time Base register, and represent 4 bus cycles.\n");\n<21> if (perfdata[i][powerpc_data_num] != (unsigned long long)0)\n<23> fprintf(stderr, " Function \"%s\" (pmc1):\n\tmin: %llu\n\tmax: %llu\n\tavg: %1.2lf (%llu)\n",
<1> static void tight_palette_rgb2buf(uint32_t rgb, int bpp, uint8_t buf[6])\n<5> memset(buf, 0, 6);\n<19> buf[4] = ((buf[0] & 1) == 0) << 3 | ((buf[1] & 1) == 0) << 2;\n<21> buf[4]|= ((buf[2] & 1) == 0) << 1 | ((buf[3] & 1) == 0) << 0;\n<23> buf[0] |= 1;\n<25> buf[1] |= 1;\n<27> buf[2] |= 1;\n<29> buf[3] |= 1;\n<39> buf[2] = ((buf[0] & 1) == 0) << 1 | ((buf[1] & 1) == 0) << 0;\n<41> buf[0] |= 1;\n<43> buf[1] |= 1;
<1> void xps_parse_color ( xps_document * doc , char * base_uri , char * string , fz_colorspace * * csp , float * samples ) {\n<7> samples [ 0 ] = 1 ;\n<8> samples [ 1 ] = 0 ;\n<9> samples [ 2 ] = 0 ;\n<10> samples [ 3 ] = 0 ;\n<11> if ( string [ 0 ] == '#' ) {\n<12> if ( strlen ( string ) == 9 ) {\n<13> samples [ 0 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n<14> samples [ 1 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n<15> samples [ 2 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n<16> samples [ 3 ] = unhex ( string [ 7 ] ) * 16 + unhex ( string [ 8 ] ) ;\n<19> samples [ 0 ] = 255 ;\n<20> samples [ 1 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n<21> samples [ 2 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n<22> samples [ 3 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n<29> else if ( string [ 0 ] == 's' && string [ 1 ] == 'c' && string [ 2 ] == '#' ) {\n<30> if ( count_commas ( string ) == 2 ) sscanf ( string , "sc#%g,%g,%g" , samples + 1 , samples + 2 , samples + 3 ) ;\n<31> if ( count_commas ( string ) == 3 ) sscanf ( string , "sc#%g,%g,%g,%g" , samples , samples + 1 , samples + 2 , samples + 3 ) ;\n<33> else if ( strstr ( string , "ContextColor " ) == string ) {\n<34> fz_strlcpy ( buf , string , sizeof buf ) ;\n<35> profile = strchr ( buf , ' ' ) ;\n<36> if ( ! profile ) {\n<40> * profile ++ = 0 ;\n<41> p = strchr ( profile , ' ' ) ;\n<42> if ( ! p ) {\n<43> fz_warn ( doc -> ctx , "cannot find component values in '%s'" , profile ) ;\n<49> while ( i < n ) {\n<50> samples [ i ++ ] = fz_atof ( p ) ;\n<51> p = strchr ( p , ',' ) ;\n<52> if ( ! p ) break ;\n<54> if ( * p == ' ' ) p ++ ;
<1> static void musicpal_init(ram_addr_t ram_size, int vga_ram_size,\n<31> if (!env) {\n<33> fprintf(stderr, "Unable to find CPU definition\n");\n<95> if (flash_size != 8*1024*1024 && flash_size != 16*1024*1024 &&\n<99> fprintf(stderr, "Invalid flash image size\n");
<1> static void cluster_all_databases ( bool verbose , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet ) {\n<5> conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n<12> char * dbname = PQgetvalue ( result , i , 0 ) ;\n<13> if ( ! quiet ) {\n<14> printf ( _ ( "%s: clustering database \"%s\"\n" ) , progname , dbname ) ;\n<17> cluster_one_database ( dbname , verbose , NULL , host , port , username , prompt_password , progname , echo ) ;
<1> static void rcu_qtest(const char *test, int duration, int nreaders)\n<39> atomic_add(&n_nodes_removed, n_removed_local);\n<43> while (n_nodes_removed > n_reclaims) {\n<51> if (g_test_in_charge) {\n<57> printf("%s: %d readers; 1 updater; nodes read: "  \\n<61> test, nthreadsrunning - 1, n_reads, n_nodes_removed, n_reclaims);
<1> static void rtas_ibm_change_msi(sPAPREnvironment *spapr,\n<15> unsigned int func = rtas_ld(args, 3);\n<31> switch (func) {\n<49> fprintf(stderr, "rtas_ibm_change_msi(%u) is not implemented\n", func);\n<115> if (ndev >= SPAPR_MSIX_MAX_DEVS || ndev < 0) {\n<117> fprintf(stderr, "No free entry for a new MSI device\n");\n<125> trace_spapr_pci_msi("Configuring MSI", ndev, config_addr);\n<131> if (phb->msi_table[ndev].nvec && (req_num != phb->msi_table[ndev].nvec)) {\n<135> fprintf(stderr, "Cannot reuse MSI config for device#%d", ndev);\n<151> if (irq < 0) {\n<153> fprintf(stderr, "Cannot allocate MSIs for device#%d", ndev);
<1> int scsi_build_sense(uint8_t *in_buf, int in_len,\n<3> uint8_t *buf, int len, bool fixed)\n<11> if (!fixed && len < 8) {\n<19> if (in_len == 0) {\n<29> fixed_in = (in_buf[0] & 2) == 0;\n<33> if (fixed == fixed_in) {\n<35> memcpy(buf, in_buf, MIN(len, in_len));\n<65> memset(buf, 0, len);\n<81> return MIN(len, 18);
<1> static int bink_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc,\n<105> dst  = frame->data[plane_idx]  + 8*by*stride;\n<111> for (bx = 0; bx < bw; bx++, dst += 8, prev += 8) {\n<129> switch (blk) {\n<141> switch (blk) {\n<191> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<193> dctblock[0] = get_value(c, BINK_SRC_INTRA_DC);\n<195> read_dct_coeffs(bc, dctblock, bink_scan, bink_intra_quant, -1);\n<197> c->binkdsp.idct_put(ublock, 8, dctblock);\n<297> dst[coordmap[*scan++]] = v;\n<303> dst[coordmap[*scan++]] = get_value(c, BINK_SRC_COLORS);\n<311> dst[coordmap[*scan++]] = get_value(c, BINK_SRC_COLORS);\n<337> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<339> dctblock[0] = get_value(c, BINK_SRC_INTRA_DC);\n<341> read_dct_coeffs(bc, dctblock, bink_scan, bink_intra_quant, -1);\n<343> c->binkdsp.idct_put(dst, stride, dctblock);\n<361> if (ret < 0)\n<365> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<367> dctblock[0] = get_value(c, BINK_SRC_INTER_DC);\n<369> read_dct_coeffs(bc, dctblock, bink_scan, bink_inter_quant, -1);\n<371> c->binkdsp.idct_add(dst, stride, dctblock);\n<387> dst[i*stride + j] = col[v & 1];\n<395> for (i = 0; i < 8; i++)\n<397> memcpy(dst + i*stride, c->bundle[BINK_SRC_COLORS].cur_ptr + i*8, 8);
<1> void xps_parse_glyphs ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n<22> fz_xml * fill_tag = NULL ;\n<43> is_sideways_att = fz_xml_att ( root , "IsSideways" ) ;\n<46> style_att = fz_xml_att ( root , "StyleSimulations" ) ;\n<53> node ;\n<55> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs.RenderTransform" ) ) transform_tag = fz_xml_down ( node ) ;\n<56> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs.OpacityMask" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n<57> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs.Clip" ) ) clip_tag = fz_xml_down ( node ) ;\n<58> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs.Fill" ) ) fill_tag = fz_xml_down ( node ) ;\n<64> xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n<71> if ( is_sideways_att ) is_sideways = ! strcmp ( is_sideways_att , "true" ) ;\n<80> if ( style_att ) {\n<81> if ( ! strcmp ( style_att , "BoldSimulation" ) ) fz_strlcat ( fakename , "#Bold" , sizeof fakename ) ;\n<82> else if ( ! strcmp ( style_att , "ItalicSimulation" ) ) fz_strlcat ( fakename , "#Italic" , sizeof fakename ) ;\n<83> else if ( ! strcmp ( style_att , "BoldItalicSimulation" ) ) fz_strlcat ( fakename , "#BoldItalic" , sizeof fakename ) ;\n<86> if ( ! font ) {\n<95> if ( strstr ( part -> name , ".odttf" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n<96> if ( strstr ( part -> name , ".ODTTF" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n<108> if ( style_att ) {\n<109> font -> ft_bold = ! ! strstr ( style_att , "Bold" ) ;\n<110> font -> ft_italic = ! ! strstr ( style_att , "Italic" ) ;\n<125> text = xps_parse_glyphs_imp ( doc , & local_ctm , font , font_size , fz_atof ( origin_x_att ) , fz_atof ( origin_y_att ) , is_sideways , bidi_level , indices_att , unicode_att ) ;\n<129> if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , "SolidColorBrush" ) ) {\n<130> fill_opacity_att = fz_xml_att ( fill_tag , "Opacity" ) ;\n<131> fill_att = fz_xml_att ( fill_tag , "Color" ) ;\n<132> fill_tag = NULL ;\n<144> xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;
<1> static void virtio_net_receive(void *opaque, const uint8_t *buf, size_t size)\n<43> struct iovec sg[VIRTQUEUE_MAX_SIZE];\n<55> if (i == 0)\n<59> fprintf(stderr, "virtio-net truncating packet\n");\n<67> if (elem.in_num < 1) {\n<69> fprintf(stderr, "virtio-net receive queue contains no in buffers\n");\n<77> if (!n->mergeable_rx_bufs && elem.in_sg[0].iov_len != hdr_len) {\n<79> fprintf(stderr, "virtio-net header not in first element\n");\n<87> memcpy(&sg, &elem.in_sg[0], sizeof(sg[0]) * elem.in_num);
<17> AVFrame *picture = data;\n<205> if(!s->lossless){\n<207> picture->quality= FFMAX3(s->qscale[0], s->qscale[1], s->qscale[2]);\n<211> picture->qscale_table= s->qscale_table;\n<213> memset(picture->qscale_table, picture->quality, (s->width+15)/16);\n<217> av_log(avctx, AV_LOG_DEBUG, "QP: %d\n", picture->quality);\n<219> picture->quality*= FF_QP2LAMBDA;
<1> static int pcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<31> samples     = (const short *)frame->data[0];\n<39> dst = avpkt->data;\n<43> switch (avctx->codec->id) {\n<211> memcpy(dst, samples, n * sample_size);
<1> static void bastardized_rice_decompress(ALACContext *alac,\n<3> int32_t *output_buffer,\n<97> if (block_size > 0) {\n<107> memset(&output_buffer[output_count+1], 0, block_size * 4);
<1> static void set_kernel_args_old(const struct arm_boot_info *info)\n<125> while (p < base + KERNEL_ARGS_ADDR + 256 + 1024) {\n<131> s = info->kernel_cmdline;\n<133> if (s) {\n<135> cpu_physical_memory_write(p, (void *)s, strlen(s) + 1);
<1> static int asf_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> ASFContext *asf = s->priv_data;\n<69> if (asf->stream_index < 0)\n<75> url_fskip(pb, asf->packet_frag_size);\n<79> printf("ff asf skip %d  %d\n", asf->packet_frag_size, num &0x7f);\n<91> DO_2BITS(asf->packet_property >> 4, asf->packet_seq, 0);\n<103> asf->packet_obj_size = get_le32(pb);\n<135> DO_2BITS(asf->packet_segsizetype >> 6, asf->packet_frag_size, 0); // 0 is illegal\n<141> asf->packet_frag_size = asf->packet_size_left - rsize;\n<173> asf_st = asf->asf_st;\n<177> if ((asf->packet_frag_offset != asf_st->frag_offset\n<181> && asf->packet_seq != asf_st->seq)) // seq should be ignored\n<189> printf("ff asf parser skips: %d - %d     o:%d - %d    %d %d   fl:%d\n",\n<201> av_free_packet(&asf_st->pkt);\n<205> if (asf->packet_frag_offset != 0) {\n<207> url_fskip(pb, asf->packet_frag_size);\n<209> printf("ff asf parser skiping %db\n", asf->packet_frag_size);\n<211> asf->packet_size_left -= asf->packet_frag_size;\n<227> asf->packet_obj_size = asf->packet_frag_size = get_byte(pb);\n<233> if (asf->packet_multi_size < asf->packet_obj_size)\n<259> av_new_packet(&asf_st->pkt, asf->packet_obj_size);\n<261> asf_st->seq = asf->packet_seq;\n<263> asf_st->pkt.pts = asf->packet_frag_timestamp - asf->hdr.preroll;\n<265> asf_st->pkt.stream_index = asf->stream_index;\n<269> asf_st->pkt.flags |= PKT_FLAG_KEY;\n<283> asf->packet_size_left -= asf->packet_frag_size;\n<289> get_buffer(pb, asf_st->pkt.data + asf->packet_frag_offset,\n<297> if (asf_st->frag_offset == asf_st->pkt.size) {\n<305> char* newdata = av_malloc(asf_st->pkt.size);\n<311> while (offset < asf_st->pkt.size) {\n<313> int off = offset / asf_st->ds_chunk_size;\n<325> asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n<329> offset += asf_st->ds_chunk_size;\n<335> asf_st->pkt.data = newdata;\n<345> memcpy(pkt, &asf_st->pkt, sizeof(AVPacket));
<1> static unsigned int dec_move_r(DisasContext *dc)\n<5> int size = memsize_zz(dc);\n<11> memsize_char(size), dc->op1, dc->op2));\n<15> cris_cc_mask(dc, CC_MASK_NZ);\n<19> dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, cpu_R[dc->op2]);\n<39> dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
<1> static void TestHeapFunctions ( ) {\n<28> u_setDataDirectory ( icuDataDir ) ;\n<57> free ( icuDataDir ) ;
<1> static inline void xan_wc3_copy_pixel_run ( XanContext * s , int x , int y , int pixel_count , int motion_x , int motion_y ) {\n<9> palette_plane = s -> current_frame . data [ 0 ] ;\n<11> if ( ! prev_palette_plane ) prev_palette_plane = palette_plane ;\n<14> curframe_index = y * stride + x ;\n<16> prevframe_index = ( y + motion_y ) * stride + x + motion_x ;\n<18> while ( pixel_count && curframe_index < s -> frame_size && prevframe_index < s -> frame_size ) {\n<19> int count = FFMIN3 ( pixel_count , width - curframe_x , width - prevframe_x ) ;\n<20> memcpy ( palette_plane + curframe_index , prev_palette_plane + prevframe_index , count ) ;\n<21> pixel_count -= count ;\n<22> curframe_index += count ;\n<23> prevframe_index += count ;\n<24> curframe_x += count ;\n<25> prevframe_x += count ;\n<27> curframe_index += line_inc ;\n<31> prevframe_index += line_inc ;
<13> if (!build_state || build_state->patched) {\n<37> qemu_ram_resize(build_state->table_ram, build_state->table_size,\n<43> memcpy(qemu_get_ram_ptr(build_state->table_ram), tables.table_data->data,\n<47> memcpy(build_state->rsdp, tables.rsdp->data, acpi_data_len(tables.rsdp));\n<49> memcpy(qemu_get_ram_ptr(build_state->linker_ram), tables.linker->data,\n<55> cpu_physical_memory_set_dirty_range_nocode(build_state->table_ram,
<1> void mips_r4k_init (ram_addr_t ram_size, int vga_ram_size,\n<49> if (!env) {\n<51> fprintf(stderr, "Unable to find CPU definition\n");\n<95> bios_size = load_image(buf, phys_ram_base + bios_offset);\n<103> } else if ((index = drive_get_index(IF_PFLASH, 0, 0)) > -1) {\n<111> if (!pflash_cfi01_register(0x1fc00000, qemu_ram_alloc(mips_rom),\n<117> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<127> fprintf(stderr, "qemu: Warning, could not load MIPS bios '%s'\n",\n<201> if (nd_table[0].vlan) {\n<209> if (strcmp(nd_table[0].model, "ne2k_isa") == 0) {\n<211> isa_ne2000_init(0x300, i8259[9], &nd_table[0]);\n<213> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<215> fprintf(stderr, "qemu: Supported NICs: ne2k_isa\n");\n<217> exit (1);\n<221> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<223> exit (1);\n<231> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<233> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static int joint_decode(COOKContext *q, COOKSubpacket *p, float *mlt_buffer1,\n<3> float *mlt_buffer2)\n<11> float *decode_buffer = q->decode_buffer_0;\n<21> memset(decouple_tab, 0, sizeof(decouple_tab));\n<23> memset(decode_buffer, 0, sizeof(q->decode_buffer_0));\n<29> memset(mlt_buffer1, 0, 1024 * sizeof(*mlt_buffer1));\n<31> memset(mlt_buffer2, 0, 1024 * sizeof(*mlt_buffer2));\n<33> decouple_info(q, p, decouple_tab);\n<35> if ((ret = mono_decode(q, p, decode_buffer)) < 0)\n<73> q->decouple(q, p, i, f1, f2, decode_buffer, mlt_buffer1, mlt_buffer2);
<1> static bool local_is_mapped_file_metadata(FsContext *fs_ctx, const char *name)\n<5> return !strcmp(name, VIRTFS_META_DIR);
<1> int load_elf_binary(struct linux_binprm * bprm, struct target_pt_regs * regs,\n<59> elf_ex = *((struct elfhdr *) bprm->buf);          /* exec-header */\n<67> if ((elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) ||\n<93> elf_phdata = (struct elf_phdr *)malloc(elf_ex.e_phentsize*elf_ex.e_phnum);\n<95> if (elf_phdata == NULL) {\n<103> i = elf_ex.e_phnum * sizeof(struct elf_phdr);\n<105> if (elf_ex.e_phoff + i <= BPRM_BUF_SIZE) {\n<107> memcpy(elf_phdata, bprm->buf + elf_ex.e_phoff, i);\n<123> bswap_phdr(elf_phdata, elf_ex.e_phnum);\n<131> elf_interpreter = NULL;\n<145> elf_ppnt = elf_phdata;\n<151> if ( elf_interpreter != NULL )\n<155> free (elf_phdata);\n<157> free(elf_interpreter);\n<177> elf_interpreter = (char *)malloc(elf_ppnt->p_filesz);\n<181> if (elf_interpreter == NULL) {\n<183> free (elf_phdata);\n<193> if (elf_ppnt->p_offset + elf_ppnt->p_filesz <= BPRM_BUF_SIZE) {\n<195> memcpy(elf_interpreter, bprm->buf + elf_ppnt->p_offset,\n<201> retval = pread(bprm->fd, elf_interpreter, elf_ppnt->p_filesz,\n<205> if (retval != elf_ppnt->p_filesz) {\n<229> if (strcmp(elf_interpreter,"/usr/lib/libc.so.1") == 0 ||\n<231> strcmp(elf_interpreter,"/usr/lib/ld.so.1") == 0) {\n<233> ibcs2_interpreter = 1;\n<239> retval = open(path(elf_interpreter), O_RDONLY);\n<243> perror(elf_interpreter);\n<253> retval = read(interpreter_fd, bprm->buf, BPRM_BUF_SIZE);\n<263> if (retval < BPRM_BUF_SIZE) {\n<265> memset(bprm->buf, 0, BPRM_BUF_SIZE - retval);\n<271> interp_ex = *((struct exec *) bprm->buf); /* aout exec-header */\n<273> interp_elf_ex = *((struct elfhdr *) bprm->buf); /* elf exec-header */\n<277> elf_ppnt++;\n<313> if (!interpreter_type) {\n<315> free(elf_interpreter);\n<317> free(elf_phdata);\n<359> if (!bprm->p) {\n<361> if (elf_interpreter) {\n<363> free(elf_interpreter);\n<367> free (elf_phdata);\n<567> bprm->p = setup_arg_pages(bprm->p, bprm, info);\n<585> for(i = 0, elf_ppnt = elf_phdata; i < elf_ex.e_phnum; i++, elf_ppnt++) {\n<645> error = target_mmap(TARGET_ELF_PAGESTART(load_bias + elf_ppnt->p_vaddr),\n<711> k = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n<733> if (elf_ppnt->p_filesz < elf_ppnt->p_memsz) {\n<761> if (elf_interpreter) {\n<769> elf_entry = load_elf_interp(&interp_elf_ex, interpreter_fd,\n<781> free(elf_interpreter);\n<785> if (elf_entry == ~((abi_ulong)0UL)) {\n<787> printf("Unable to load interpreter\n");\n<789> free(elf_phdata);\n<801> free(elf_phdata);
<1> matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n<89> flags = *data++;\n<141> data += 1;\n<173> data += 1;\n<209> n = matroska_ebmlnum_uint(data, size, &num);\n<221> data += n;\n<233> r = matroska_ebmlnum_sint (data, size, &snum);\n<245> data += r;\n<291> slices = *data++ + 1;\n<305> slice_offset = rv_offset(data, slice, slices);\n<309> slice_size = lace_size[n] - slice_offset;\n<313> slice_size = rv_offset(data, slice+1, slices) - slice_offset;\n<323> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n<345> for (x=0; x<h/2; x++)\n<347> memcpy(audiotrack->buf+x*2*w+y*cfs,\n<349> data+x*cfs, cfs);\n<353> for (x=0; x<w/sps; x++)\n<355> memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n<369> while (audiotrack->pkt_cnt) {\n<373> av_new_packet(pkt, a);\n<377> + a * (h*w / a - audiotrack->pkt_cnt--), a);\n<383> matroska_queue_packet(matroska, pkt);\n<399> for (i=0; i<8 && data[slice_offset+offset]; offset++)\n<413> if (av_new_packet(pkt, slice_size-offset) < 0) {\n<423> memcpy (pkt->data, data+slice_offset+offset, slice_size-offset);\n<443> matroska_queue_packet(matroska, pkt);\n<455> data += lace_size[n];
<1> void net_set_boot_mask(int net_boot_mask)\n<27> if (net_boot_mask) {\n<29> fprintf(stderr, "Cannot boot from non-existent NIC\n");
<1> static void omap_mcbsp_writeh(void *opaque, hwaddr addr,\n<35> if (s->tx_req > 1) {\n<53> printf("%s: Tx FIFO overrun\n", __FUNCTION__);\n<81> if (value & (1 << 15))				/* DLB */\n<83> printf("%s: Digital Loopback mode enable attempt\n", __FUNCTION__);\n<145> if (value & 3)					/* XMCM */\n<147> printf("%s: Tx channel selection mode enable attempt\n",\n<157> if (value & 1)					/* RMCM */\n<159> printf("%s: Rx channel selection mode enable attempt\n",
<1> static char *qemu_rbd_parse_clientname(const char *conf, char *clientname)\n<5> const char *p = conf;\n<9> while (*p) {\n<13> const char *end = strchr(p, ':');\n<17> if (end) {\n<19> len = end - p;\n<23> len = strlen(p);\n<29> if (strncmp(p, "id=", 3) == 0) {\n<31> len -= 3;\n<33> strncpy(clientname, p + 3, len);\n<37> return clientname;\n<41> if (end == NULL) {\n<47> p = end + 1;
<1> int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n<20> if ( ! ( param -> testflag & T_SILENT ) ) {\n<21> printf ( "- recovering (with sort) MyISAM-table '%s'\n" , name ) ;\n<22> printf ( "Data records: %s\n" , llstr ( start_records , llbuff ) ) ;\n<28> if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ;\n<30> info -> opt_flag |= WRITE_CACHE_USED ;\n<41> if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , "datafile-header" ) ) goto err ;\n<49> info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n<50> mi_drop_all_indexes ( param , info , FALSE ) ;\n<77> rec_per_key_part = param -> rec_per_key_part ;\n<80> rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) {\n<84> if ( ! mi_is_key_active ( key_map , sort_param . key ) ) {\n<85> memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n<89> if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( "- Fixing index %d\n" , sort_param . key + 1 ) ;\n<102> info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n<103> info -> state -> empty = 0 ;\n<139> share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ;\n<147> else info -> state -> data_file_length = sort_param . max_pos ;\n<155> if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n<168> if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n<169> if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , "Can't change size of indexfile, error: %d" , my_errno ) ;\n<171> if ( start_records != info -> state -> records ) printf ( "Data records: %s\n" , llstr ( info -> state -> records , llbuff ) ) ;\n<175> if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n<182> if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n<190> if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ;\n<192> mi_mark_crashed_on_repair ( info ) ;\n<196> my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n<197> my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;
<1> void ff_h264_remove_all_refs(H264Context *h)\n<19> ff_h264_unref_picture(h, &h->last_pic_for_ec);\n<23> ff_h264_ref_picture(h, &h->last_pic_for_ec, h->short_ref[0]);\n<29> unreference_pic(h, h->short_ref[i], 0);\n<39> memset(h->default_ref_list, 0, sizeof(h->default_ref_list));\n<41> memset(h->ref_list, 0, sizeof(h->ref_list));
<1> int if_encap(Slirp *slirp, struct mbuf *ifm)\n<7> struct ethhdr *eh = (struct ethhdr *)buf;\n<9> uint8_t ethaddr[ETH_ALEN];\n<25> switch (iph->ip_v) {\n<29> ret = if_encap4(slirp, ifm, eh, ethaddr);\n<31> if (ret < 2) {\n<53> memcpy(eh->h_dest, ethaddr, ETH_ALEN);\n<67> memcpy(buf + sizeof(struct ethhdr), ifm->m_data, ifm->m_len);\n<69> slirp_output(slirp->opaque, buf, ifm->m_len + ETH_HLEN);
<1> static void test_io_channel_unix_fd_pass(void)\n<65> memcpy(bufsend, "Hello World", G_N_ELEMENTS(bufsend));\n<69> iosend[0].iov_base = bufsend;\n<71> iosend[0].iov_len = G_N_ELEMENTS(bufsend);\n<77> iorecv[0].iov_len = G_N_ELEMENTS(bufrecv);\n<137> g_assert(memcmp(bufsend, bufrecv, G_N_ELEMENTS(bufsend)) == 0);\n<143> g_assert(write(fdrecv[0], bufsend, G_N_ELEMENTS(bufsend)) ==\n<151> memset(bufrecv, 0, G_N_ELEMENTS(bufrecv));\n<155> g_assert(read(testfd, bufrecv, G_N_ELEMENTS(bufrecv)) ==\n<157> G_N_ELEMENTS(bufrecv));\n<159> g_assert(memcmp(bufsend, bufrecv, G_N_ELEMENTS(bufsend)) == 0);
<1> static void numa_node_parse(NumaNodeOptions *node, QemuOpts *opts, Error **errp)\n<91> if (node->has_mem) {\n<95> const char *mem_str = qemu_opt_get(opts, "mem");\n<99> if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n<101> mem_size <<= 20;
<1> char *ff_AMediaCodecList_getCodecNameByType(const char *mime, int width, int height, void *log_ctx)\n<225> if (!name) {\n<233> if (strstr(name, "OMX.google")) {\n<235> av_freep(&name);\n<245> av_freep(&supported_type);\n<335> return name;
<1> bool has_help_option(const char *param)\n<5> size_t buflen = strlen(param) + 1;\n<7> char *buf = g_malloc(buflen);\n<9> const char *p = param;\n<27> if (is_help_option(buf)) {\n<41> free(buf);
<1> static void versatile_init(QEMUMachineInitArgs *args, int board_id)\n<45> if (!cpu) {\n<47> fprintf(stderr, "Unable to find CPU definition\n");\n<135> for(n = 0; n < nb_nics; n++) {\n<137> nd = &nd_table[n];\n<141> if (!done_smc && (!nd->model || strcmp(nd->model, "smc91c111") == 0)) {\n<143> smc91c111_init(nd, 0x10010000, sic[25]);\n<145> done_smc = 1;\n<149> pci_nic_init_nofail(nd, "rtl8139", NULL);\n<323> if (!pflash_cfi01_register(VERSATILE_FLASH_ADDR, NULL, "versatile.flash",\n<333> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> static void check_native_list(QObject *qobj,\n<101> for (i = 0; i < 32; i++) {\n<107> gchar str[8];\n<115> sprintf(str, "%d", i);
<1> void axisdev88_init(MachineState *machine)\n<207> } else if (!qtest_enabled()) {\n<209> fprintf(stderr, "Kernel image must be specified\n");
<1> void kadmin_modprinc ( int argc , char * argv [ ] ) {\n<6> char * pass , * canon = NULL ;\n<9> krb5_key_salt_tuple * ks_tuple = NULL ;\n<10> if ( argc < 2 ) {\n<14> memset ( & oldprinc , 0 , sizeof ( oldprinc ) ) ;\n<15> memset ( & princ , 0 , sizeof ( princ ) ) ;\n<17> if ( retval ) {\n<21> retval = krb5_unparse_name ( context , kprinc , & canon ) ;\n<26> retval = kadm5_get_principal ( handle , kprinc , & oldprinc , KADM5_PRINCIPAL_NORMAL_MASK ) ;\n<28> com_err ( "modify_principal" , retval , _ ( "while getting \"%s\"." ) , canon ) ;\n<31> princ . attributes = oldprinc . attributes ;\n<32> kadm5_free_principal_ent ( handle , & oldprinc ) ;\n<33> retval = kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , "modify_principal" ) ;\n<34> if ( retval || ks_tuple != NULL || randkey || pass ) {\n<39> retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n<41> if ( retval ) {\n<42> com_err ( "modify_principal" , retval , _ ( "while modifying \"%s\"." ) , canon ) ;\n<45> printf ( _ ( "Principal \"%s\" modified.\n" ) , canon ) ;\n<47> krb5_free_principal ( context , princ . principal ) ;\n<48> kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;\n<49> free ( canon ) ;\n<50> free ( ks_tuple ) ;
<1> static sd_rsp_type_t sd_normal_command(SDState *sd,\n<3> SDRequest req)\n<25> DPRINTF("CMD%d 0x%08x state %d\n", req.cmd, req.arg, sd->state);\n<27> switch (req.cmd) {\n<57> if (!sd->spi)\n<71> if (sd->spi)\n<75> switch (sd->state) {\n<97> if (sd->spi)\n<101> switch (sd->state) {\n<127> if (sd->spi)\n<157> if (sd->spi)\n<161> switch (sd->mode) {\n<189> if (sd->spi)\n<193> switch (sd->state) {\n<213> if (sd->rca == rca)\n<241> if (sd->rca == rca)\n<267> switch (sd->state) {\n<303> switch (sd->state) {\n<319> if (!sd->spi)\n<325> memcpy(sd->data, sd->csd, 16);\n<347> switch (sd->state) {\n<363> if (!sd->spi)\n<369> memcpy(sd->data, sd->cid, 16);\n<391> if (sd->spi)\n<395> switch (sd->state) {\n<427> switch (sd->state) {\n<461> switch (sd->mode) {\n<487> if (sd->spi)\n<491> switch (sd->mode) {\n<521> switch (sd->state) {\n<551> switch (sd->state) {\n<583> switch (sd->state) {\n<617> if (sd->spi)\n<621> switch (sd->state) {\n<627> if (sd->spi)\n<669> if (sd->spi)\n<673> switch (sd->state) {\n<679> if (sd->spi)\n<721> if (sd->spi)\n<725> switch (sd->state) {\n<751> if (sd->spi)\n<755> switch (sd->state) {\n<783> switch (sd->state) {\n<821> switch (sd->state) {\n<859> switch (sd->state) {\n<889> switch (sd->state) {\n<911> switch (sd->state) {\n<933> switch (sd->state) {\n<973> if (sd->spi)\n<977> switch (sd->state) {\n<1041> fprintf(stderr, "SD: GEN_CMD 0x%08x\n", req.arg);\n<1045> switch (sd->state) {\n<1051> if (req.arg & 1)\n<1077> fprintf(stderr, "SD: Unknown CMD%i\n", req.cmd);\n<1087> fprintf(stderr, "SD: CMD%i not implemented in SPI mode\n", req.cmd);\n<1095> fprintf(stderr, "SD: CMD%i in a wrong state\n", req.cmd);
<1> static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,\n<3> MegasasCmd *cmd)\n<25> if (!cmd->iov_buf) {\n<27> cmd->iov_buf = g_malloc(dcmd_size);\n<29> memset(cmd->iov_buf, 0, dcmd_size);\n<31> info = cmd->iov_buf;\n<39> req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);\n<47> g_free(cmd->iov_buf);
<1> const char *get_feature_xml(CPUState *env, const char *p, const char **newp)\n<13> static char target_xml[1024];\n<33> if (!target_xml[0]) {\n<53> for (r = env->gdb_regs; r; r = r->next) {\n<55> strcat(target_xml, "<xi:include href=\"");\n<57> strcat(target_xml, r->xml);\n<59> strcat(target_xml, "\"/>");\n<63> strcat(target_xml, "</target>");\n<67> return target_xml;\n<71> for (i = 0; ; i++) {\n<75> if (!name || (strncmp(name, p, len) == 0 && strlen(name) == len))
<1> SimpleSpiceUpdate *qemu_spice_create_update(SimpleSpiceDisplay *ssd)\n<19> if (qemu_spice_rect_is_empty(&ssd->dirty)) {\n<47> bw       = ssd->dirty.right - ssd->dirty.left;\n<49> bh       = ssd->dirty.bottom - ssd->dirty.top;\n<117> ssd->dirty.top * ds_get_linesize(ssd->ds) +\n<119> ssd->dirty.left * ds_get_bytes_per_pixel(ssd->ds);\n<141> memset(&ssd->dirty, 0, sizeof(ssd->dirty));
<1> void ff_ac3_bit_alloc_calc_bap(int16_t *mask, int16_t *psd, int start, int end,\n<5> const uint8_t *bap_tab, uint8_t *bap)\n<15> if (snr_offset == -960) {\n<17> memset(bap, 0, 256);
<1> static void generate_eeprom_spd(uint8_t *eeprom, ram_addr_t ram_size)\n<7> uint8_t *spd = spd_eeprom.contents;\n<23> while ((ram_size >= 4) && (nbanks <= 2)) {\n<67> if (ram_size) {\n<69> fprintf(stderr, "Warning: SPD cannot represent final %dMB"\n<79> spd[2] = type;\n<81> spd[5] = nbanks;\n<83> spd[31] = density;\n<89> spd[63] = 0;\n<93> spd[63] += spd[i];\n<101> memcpy(eeprom, spd, sizeof(spd_eeprom.contents));
<1> static int mpeg_decode_frame(AVCodecContext *avctx,\n<99> if (start_code < 0){\n<101> printf("missing end of picture\n");\n<191> }else if(ret < 0){\n<199> fprintf(stderr,"Error while decoding slice\n");
<1> static void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,\n<29> if (!req) {\n<67> evt = req->resp.event;\n<69> memset(evt, 0, sizeof(VirtIOSCSIEvent));
<1> static void new_video_stream(AVFormatContext *oc)\n<15> if (!st) {\n<17> fprintf(stderr, "Could not alloc stream\n");\n<165> p= video_rc_override_string;\n<167> for(i=0; p; i++){\n<171> int e=sscanf(p, "%d,%d,%d", &start, &end, &q);\n<173> if(e!=3){\n<175> fprintf(stderr, "error parsing rc_override\n");\n<187> video_enc->rc_override[i].start_frame= start;\n<189> video_enc->rc_override[i].end_frame  = end;\n<191> if(q>0){\n<193> video_enc->rc_override[i].qscale= q;\n<203> video_enc->rc_override[i].quality_factor= -q/100.0;\n<207> p= strchr(p, '/');\n<209> if(p) p++;
<1> static int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv)\n<5> static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b};\n<79> if (size < 32 || size - 32 < orig_size)\n<85> avio_read(pb, tmpbuf, 16);\n<89> av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1);\n<91> if (memcmp(tmpbuf, checkv, 16))\n<93> av_log(s, AV_LOG_ERROR, "probably incorrect decryption key\n");
<1> static void qtest_process_command(CharDriverState *chr, gchar **words)\n<9> g_assert(words);\n<17> if (qtest_log_fp) {\n<31> for (i = 0; words[i]; i++) {\n<33> fprintf(qtest_log_fp, " %s", words[i]);\n<37> fprintf(qtest_log_fp, "\n");\n<45> if (strcmp(words[0], "irq_intercept_out") == 0\n<47> || strcmp(words[0], "irq_intercept_in") == 0) {\n<55> g_assert(words[1]);\n<57> dev = DEVICE(object_resolve_path(words[1], NULL));\n<59> if (!dev) {\n<139> } else if (strcmp(words[0], "outb") == 0 ||\n<141> strcmp(words[0], "outw") == 0 ||\n<143> strcmp(words[0], "outl") == 0) {\n<151> g_assert(words[1] && words[2]);\n<153> addr = strtoul(words[1], NULL, 0);\n<155> value = strtoul(words[2], NULL, 0);\n<159> if (words[0][3] == 'b') {\n<173> qtest_send_prefix(chr);\n<175> qtest_send(chr, "OK\n");\n<177> } else if (strcmp(words[0], "inb") == 0 ||\n<179> strcmp(words[0], "inw") == 0 ||\n<181> strcmp(words[0], "inl") == 0) {\n<185> uint32_t value = -1U;\n<189> g_assert(words[1]);\n<191> addr = strtoul(words[1], NULL, 0);\n<195> if (words[0][2] == 'b') {\n<209> qtest_send_prefix(chr);\n<211> qtest_sendf(chr, "OK 0x%04x\n", value);\n<213> } else if (strcmp(words[0], "writeb") == 0 ||\n<215> strcmp(words[0], "writew") == 0 ||\n<217> strcmp(words[0], "writel") == 0 ||\n<219> strcmp(words[0], "writeq") == 0) {\n<227> g_assert(words[1] && words[2]);\n<229> addr = strtoull(words[1], NULL, 0);\n<231> value = strtoull(words[2], NULL, 0);\n<235> if (words[0][5] == 'b') {\n<267> qtest_send_prefix(chr);\n<269> qtest_send(chr, "OK\n");\n<271> } else if (strcmp(words[0], "readb") == 0 ||\n<273> strcmp(words[0], "readw") == 0 ||\n<275> strcmp(words[0], "readl") == 0 ||\n<277> strcmp(words[0], "readq") == 0) {\n<281> uint64_t value = UINT64_C(-1);\n<285> g_assert(words[1]);\n<287> addr = strtoull(words[1], NULL, 0);\n<291> if (words[0][4] == 'b') {\n<323> qtest_send_prefix(chr);\n<327> } else if (strcmp(words[0], "read") == 0) {\n<337> g_assert(words[1] && words[2]);\n<339> addr = strtoull(words[1], NULL, 0);\n<341> len = strtoull(words[2], NULL, 0);\n<345> data = g_malloc(len);\n<347> cpu_physical_memory_read(addr, data, len);\n<351> enc = g_malloc(2 * len + 1);\n<353> for (i = 0; i < len; i++) {\n<355> sprintf(&enc[i * 2], "%02x", data[i]);\n<361> qtest_send_prefix(chr);\n<363> qtest_sendf(chr, "OK 0x%s\n", enc);\n<367> g_free(data);\n<369> g_free(enc);\n<371> } else if (strcmp(words[0], "b64read") == 0) {\n<381> g_assert(words[1] && words[2]);\n<383> addr = strtoull(words[1], NULL, 0);\n<385> len = strtoull(words[2], NULL, 0);\n<389> data = g_malloc(len);\n<391> cpu_physical_memory_read(addr, data, len);\n<393> b64_data = g_base64_encode(data, len);\n<395> qtest_send_prefix(chr);\n<397> qtest_sendf(chr, "OK %s\n", b64_data);\n<401> g_free(data);\n<403> g_free(b64_data);\n<405> } else if (strcmp(words[0], "write") == 0) {\n<415> g_assert(words[1] && words[2] && words[3]);\n<417> addr = strtoull(words[1], NULL, 0);\n<419> len = strtoull(words[2], NULL, 0);\n<423> data_len = strlen(words[3]);\n<425> if (data_len < 3) {\n<463> } else if (strcmp(words[0], "memset") == 0) {\n<473> g_assert(words[1] && words[2] && words[3]);\n<475> addr = strtoull(words[1], NULL, 0);\n<477> len = strtoull(words[2], NULL, 0);\n<479> pattern = strtoull(words[3], NULL, 0);\n<483> if (len) {\n<485> data = g_malloc(len);\n<487> memset(data, pattern, len);\n<489> cpu_physical_memory_write(addr, data, len);\n<497> qtest_send_prefix(chr);\n<499> qtest_send(chr, "OK\n");\n<501> }  else if (strcmp(words[0], "b64write") == 0) {\n<513> g_assert(words[1] && words[2] && words[3]);\n<515> addr = strtoull(words[1], NULL, 0);\n<517> len = strtoull(words[2], NULL, 0);\n<521> data_len = strlen(words[3]);\n<523> if (data_len < 3) {\n<533> data = g_base64_decode_inplace(words[3], &out_len);\n<557> } else if (qtest_enabled() && strcmp(words[0], "clock_step") == 0) {\n<563> if (words[1]) {\n<573> qtest_clock_warp(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + ns);\n<575> qtest_send_prefix(chr);\n<581> } else if (qtest_enabled() && strcmp(words[0], "clock_set") == 0) {\n<587> g_assert(words[1]);\n<589> ns = strtoll(words[1], NULL, 0);\n<591> qtest_clock_warp(ns);\n<593> qtest_send_prefix(chr);\n<601> qtest_send_prefix(chr);\n<603> qtest_sendf(chr, "FAIL Unknown command '%s'\n", words[0]);
<1> static void flat_print_int(WriterContext *wctx, const char *key, long long int value)\n<7> printf("%s=%lld\n", key, value);
<1> static void restore_native_fp_frstor(CPUState *env)\n<37> for(i = 0;i < 8; i++) {\n<39> memcpy(&fp->fpregs1[i * 10], &env->fpregs[j].d, 10);
<1> static void ppc_heathrow_init(MachineState *machine)\n<77> if (cpu == NULL) {\n<79> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<101> if (ram_size > (2047 << 20)) {\n<107> ((unsigned int)ram_size / (1 << 20)));\n<299> if (ppc_boot_device == '\0') {\n<301> fprintf(stderr, "No valid boot device for G3 Beige machine\n");
<1> int img_convert(AVPicture *dst, int dst_pix_fmt,\n<117> w >>= dst_pix->x_chroma_shift;\n<123> d = dst->data[i];\n<125> for(y = 0; y< h; y++) {\n<127> memset(d, 128, w);\n<129> d += dst->linesize[i];
<1> void slirp_init(int restricted, const char *special_ip)\n<49> if (get_dns_addr(&dns_addr) < 0) {\n<53> fprintf (stderr, "Warning: No DNS servers found\n");
<1> DriveInfo *drive_init(QemuOpts *opts, int default_to_scsi)\n<93> serial = qemu_opt_get(opts, "serial");\n<97> if ((buf = qemu_opt_get(opts, "if")) != NULL) {\n<99> pstrcpy(devname, sizeof(devname), buf);\n<101> for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n<107> error_report("unsupported bus type '%s'", buf);\n<149> if ((buf = qemu_opt_get(opts, "trans")) != NULL) {\n<151> if (!cyls) {\n<161> if (!strcmp(buf, "none"))\n<163> translation = BIOS_ATA_TRANSLATION_NONE;\n<165> else if (!strcmp(buf, "lba"))\n<167> translation = BIOS_ATA_TRANSLATION_LBA;\n<169> else if (!strcmp(buf, "auto"))\n<171> translation = BIOS_ATA_TRANSLATION_AUTO;\n<175> error_report("'%s' invalid translation type", buf);\n<177> return NULL;\n<185> if ((buf = qemu_opt_get(opts, "media")) != NULL) {\n<187> if (!strcmp(buf, "disk")) {\n<189> media = MEDIA_DISK;\n<191> } else if (!strcmp(buf, "cdrom")) {\n<193> if (cyls || secs || heads) {\n<195> error_report("'%s' invalid physical CHS format", buf);\n<205> error_report("'%s' invalid media", buf);\n<207> return NULL;\n<215> if ((buf = qemu_opt_get(opts, "cache")) != NULL) {\n<217> if (!strcmp(buf, "off") || !strcmp(buf, "none")) {\n<219> bdrv_flags |= BDRV_O_NOCACHE;\n<221> } else if (!strcmp(buf, "writeback")) {\n<223> bdrv_flags |= BDRV_O_CACHE_WB;\n<225> } else if (!strcmp(buf, "unsafe")) {\n<227> bdrv_flags |= BDRV_O_CACHE_WB;\n<229> bdrv_flags |= BDRV_O_NO_FLUSH;\n<231> } else if (!strcmp(buf, "writethrough")) {\n<237> error_report("invalid cache option");\n<239> return NULL;\n<273> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<275> if (strcmp(buf, "?") == 0) {\n<277> error_printf("Supported formats:");\n<279> bdrv_iterate_format(bdrv_format_print, NULL);\n<281> error_printf("\n");\n<283> return NULL;\n<287> drv = bdrv_find_whitelisted_format(buf);\n<289> if (!drv) {\n<459> dinfo = qemu_mallocz(sizeof(*dinfo));\n<503> if (serial)\n<505> strncpy(dinfo->serial, serial, sizeof(dinfo->serial) - 1);\n<507> QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n<593> return dinfo;\n<635> if (ret < 0) {\n<637> error_report("could not open disk image %s: %s",\n<639> file, strerror(-ret));\n<651> return dinfo;\n<661> QTAILQ_REMOVE(&drives, dinfo, next);\n<663> qemu_free(dinfo);
<1> void configure_icount(const char *option)\n<7> if (!option)\n<13> if (strcmp(option, "auto") != 0) {\n<15> icount_time_shift = strtol(option, NULL, 0);\n<17> use_icount = 1;\n<19> return;\n<25> use_icount = 2;\n<33> icount_time_shift = 3;\n<47> icount_rt_timer = qemu_new_timer(rt_clock, icount_adjust_rt, NULL);\n<51> qemu_get_clock(rt_clock) + 1000);\n<53> icount_vm_timer = qemu_new_timer(vm_clock, icount_adjust_vm, NULL);\n<57> qemu_get_clock(vm_clock) + get_ticks_per_sec() / 10);
<1> static int nbd_receive_list(QIOChannel *ioc, const char *want, bool *match,\n<81> if (read_sync(ioc, &namelen, sizeof(namelen), errp) < 0) {\n<95> if (len < namelen) {\n<105> if (namelen != strlen(want)) {\n<107> if (drop_sync(ioc, len, errp) < 0) {\n<123> assert(namelen < sizeof(name));\n<125> if (read_sync(ioc, name, namelen, errp) < 0) {\n<135> name[namelen] = '\0';\n<139> if (drop_sync(ioc, len, errp) < 0) {\n<149> if (!strcmp(name, want)) {\n<151> *match = true;
<1> static void qxl_log_cmd_draw(PCIQXLDevice *qxl, QXLDrawable *draw, int group_id)\n<5> fprintf(stderr, ": surface_id %d type %s effect %s",\n<9> qxl_name(qxl_draw_type, draw->type),\n<11> qxl_name(qxl_draw_effect, draw->effect));
<1> int qemu_savevm_state_complete(Monitor *mon, QEMUFile *f)\n<35> QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n<57> len = strlen(se->idstr);\n<59> qemu_put_byte(f, len);\n<61> qemu_put_buffer(f, (uint8_t *)se->idstr, len);\n<71> vmstate_save(f, se);
<1> static bool bdrv_exceed_io_limits(BlockDriverState *bs, int nb_sectors,\n<31> memset(&bs->slice_submitted, 0, sizeof(bs->slice_submitted));
<1> static int amf_parse_object(AVFormatContext *s, AVStream *astream,\n<55> if ((vstream || astream) && key &&\n<57> !strcmp(KEYFRAMES_TAG, key) && depth == 1)\n<153> if (depth == 1 && key) {\n<155> acodec = astream ? astream->codec : NULL;\n<157> vcodec = vstream ? vstream->codec : NULL;\n<165> if (!strcmp(key, "duration"))\n<167> s->duration = num_val * AV_TIME_BASE;\n<169> else if (!strcmp(key, "videodatarate") && vcodec &&\n<171> 0 <= (int)(num_val * 1024.0))\n<173> vcodec->bit_rate = num_val * 1024.0;\n<175> else if (!strcmp(key, "audiodatarate") && acodec &&\n<177> 0 <= (int)(num_val * 1024.0))\n<179> acodec->bit_rate = num_val * 1024.0;\n<181> else if (!strcmp(key, "datastream")) {\n<183> AVStream *st = create_stream(s, AVMEDIA_TYPE_DATA);\n<185> if (!st)\n<191> } else if (flv->trust_metadata) {\n<193> if (!strcmp(key, "videocodecid") && vcodec) {\n<195> flv_set_video_codec(s, vstream, num_val, 0);\n<197> } else if (!strcmp(key, "audiocodecid") && acodec) {\n<199> int id = ((int)num_val) << FLV_AUDIO_CODECID_OFFSET;\n<201> flv_set_audio_codec(s, astream, acodec, id);\n<203> } else if (!strcmp(key, "audiosamplerate") && acodec) {\n<205> acodec->sample_rate = num_val;\n<207> } else if (!strcmp(key, "audiosamplesize") && acodec) {\n<209> acodec->bits_per_coded_sample = num_val;\n<211> } else if (!strcmp(key, "stereo") && acodec) {\n<213> acodec->channels       = num_val + 1;\n<215> acodec->channel_layout = acodec->channels == 2 ?\n<221> } else if (!strcmp(key, "width") && vcodec) {\n<223> vcodec->width = num_val;\n<225> } else if (!strcmp(key, "height") && vcodec) {\n<227> vcodec->height = num_val;\n<237> if (!strcmp(key, "duration")        ||\n<239> !strcmp(key, "filesize")        ||\n<241> !strcmp(key, "width")           ||\n<243> !strcmp(key, "height")          ||\n<245> !strcmp(key, "videodatarate")   ||\n<247> !strcmp(key, "framerate")       ||\n<249> !strcmp(key, "videocodecid")    ||\n<251> !strcmp(key, "audiodatarate")   ||\n<253> !strcmp(key, "audiosamplerate") ||\n<255> !strcmp(key, "audiosamplesize") ||\n<257> !strcmp(key, "stereo")          ||\n<259> !strcmp(key, "audiocodecid")    ||\n<261> !strcmp(key, "datastream"))\n<263> return 0;\n<267> if (amf_type == AMF_DATA_TYPE_BOOL) {\n<273> av_dict_set(&s->metadata, key, str_val, 0);\n<279> av_dict_set(&s->metadata, key, str_val, 0);\n<283> av_dict_set(&s->metadata, key, str_val, 0);\n<289> return 0;
<1> static int pnm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<10> s -> bytestream_start = s -> bytestream = buf ;\n<12> if ( ( ret = ff_pnm_decode_header ( avctx , s ) ) < 0 ) return ret ;\n<44> do_read : ptr = p -> data [ 0 ] ;\n<46> if ( s -> bytestream + n * avctx -> height > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n<75> if ( ! upgrade ) memcpy ( ptr , s -> bytestream , n ) ;\n<79> j < n ;\n<80> j ++ ) ptr [ j ] = ( s -> bytestream [ j ] * f + 64 ) >> 7 ;\n<85> j < n / 2 ;\n<91> s -> bytestream += n ;\n<92> ptr += linesize ;\n<99> ptr = p -> data [ 0 ] ;\n<102> if ( s -> bytestream + n * avctx -> height * 3 / 2 > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n<104> i < avctx -> height ;\n<106> memcpy ( ptr , s -> bytestream , n ) ;\n<107> s -> bytestream += n ;\n<108> ptr += linesize ;\n<110> ptr1 = p -> data [ 1 ] ;\n<111> ptr2 = p -> data [ 2 ] ;\n<112> n >>= 1 ;\n<115> i < h ;\n<117> memcpy ( ptr1 , s -> bytestream , n ) ;\n<118> s -> bytestream += n ;\n<119> memcpy ( ptr2 , s -> bytestream , n ) ;\n<120> s -> bytestream += n ;\n<121> ptr1 += p -> linesize [ 1 ] ;\n<122> ptr2 += p -> linesize [ 2 ] ;
<1> int nbd_receive_negotiate(QIOChannel *ioc, const char *name, uint32_t *flags,\n<45> if (read_sync(ioc, buf, 8) != 8) {\n<55> buf[8] = '\0';\n<57> if (strlen(buf) == 0) {\n<59> error_setg(errp, "Server connection closed unexpectedly");\n<69> qemu_isprint(buf[0]) ? buf[0] : '.',\n<71> qemu_isprint(buf[1]) ? buf[1] : '.',\n<73> qemu_isprint(buf[2]) ? buf[2] : '.',\n<75> qemu_isprint(buf[3]) ? buf[3] : '.',\n<77> qemu_isprint(buf[4]) ? buf[4] : '.',\n<79> qemu_isprint(buf[5]) ? buf[5] : '.',\n<81> qemu_isprint(buf[6]) ? buf[6] : '.',\n<83> qemu_isprint(buf[7]) ? buf[7] : '.');\n<87> if (memcmp(buf, "NBDMAGIC", 8) != 0) {\n<89> error_setg(errp, "Invalid magic received");\n<97> if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {\n<191> if (!name) {\n<195> name = "";\n<213> if (nbd_receive_query_exports(ioc, name, errp) < 0) {\n<235> if (write_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {\n<243> namesize = cpu_to_be32(strlen(name));\n<245> if (write_sync(ioc, &namesize, sizeof(namesize)) !=\n<255> if (write_sync(ioc, (char *)name, strlen(name)) != strlen(name)) {\n<257> error_setg(errp, "Failed to send export name");\n<265> if (read_sync(ioc, &s, sizeof(s)) != sizeof(s)) {\n<349> if (read_sync(ioc, &buf, 124) != 124) {
<1> SwsContext *sws_getContext(int srcW, int srcH, enum PixelFormat srcFormat,\n<581> c->chrPixBuf[i] = c->chrPixBuf[i+c->vChrBufSize];\n<599> for (i=0; i<c->vChrBufSize; i++) memset(c->chrPixBuf[i], 64, (VOF+1)*2);
<1> static void bt_dummy_lmp_connection_complete(struct bt_link_s *link)\n<5> if (link->slave->reject_reason)\n<7> fprintf(stderr, "%s: stray LMP_not_accepted received, fixme\n",\n<13> fprintf(stderr, "%s: stray LMP_accepted received, fixme\n",
<1> static CharDriverState *qemu_chr_open_stdio(const char *id,\n<29> if (stdio_in_use) {\n<51> memset(&act, 0, sizeof(act));\n<55> sigaction(SIGCONT, &act, NULL);
<1> PXA2xxState *pxa255_init(MemoryRegion *address_space, unsigned int sdram_size)\n<19> if (s->cpu == NULL) {\n<21> fprintf(stderr, "Unable to find CPU definition\n");\n<83> if (!dinfo) {\n<85> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> static void lm32_cpu_reset(CPUState *s)\n<27> tlb_flush(env, 1);\n<33> memset(env, 0, offsetof(CPULM32State, breakpoints));
<1> static void selfTest(uint8_t *ref[4], int refStride[4], int w, int h)\n<25> for (dstFormat = 0; dstFormat < PIX_FMT_NB; dstFormat++) {\n<35> sws_format_name(srcFormat),\n<37> sws_format_name(dstFormat));
<1> static void * qemu_kvm_cpu_thread_fn ( void * arg ) {\n<9> if ( r < 0 ) {\n<10> fprintf ( stderr , "kvm_init_vcpu failed: %s\n" , strerror ( - r ) ) ;
<1> static void g364fb_screen_dump(void *opaque, const char *filename, bool cswitch,\n<7> G364State *s = opaque;\n<35> if (!f) {\n<37> error_setg(errp, "failed to open file '%s': %s", filename,\n<39> strerror(errno));\n<47> if (s->ctla & CTLA_FORCE_BLANK) {\n<51> ret = fprintf(f, "P4\n%d %d\n", s->width, s->height);\n<53> if (ret < 0) {\n<59> for (y = 0; y < s->height; y++)\n<61> for (x = 0; x < s->width; x++) {\n<63> ret = fputc(0, f);\n<65> if (ret == EOF) {\n<77> ret = fprintf(f, "P6\n%d %d\n%d\n", s->width, s->height, 255);\n<79> if (ret < 0) {\n<85> for (y = 0; y < s->height; y++)\n<87> for (x = 0; x < s->width; x++, data_buffer++) {\n<91> ret = fputc(s->color_palette[index][0], f);\n<93> if (ret == EOF) {\n<101> if (ret == EOF) {\n<109> if (ret == EOF) {\n<123> fclose(f);\n<131> error_setg(errp, "failed to write to file '%s': %s", filename,\n<133> strerror(errno));
<1> static int usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n<45> if (sz > ret)\n<47> sz = ret;\n<49> memcpy(&s->out_buf[s->out_ptr], p->data, sz);\n<51> s->out_ptr += sz;\n<71> if (s->out_ptr < 8 || s->out_ptr < len)\n<87> s->out_ptr -= len;\n<89> memmove(s->out_buf, &s->out_buf[len], s->out_ptr);
<1> int qemu_opts_print(QemuOpts *opts, void *dummy)\n<13> TAILQ_FOREACH(opt, &opts->head, next) {\n<15> fprintf(stderr, " %s=\"%s\"", opt->name, opt->str);\n<19> fprintf(stderr, "\n");
<1> static void bootp_reply(Slirp *slirp, const struct bootp_t *bp)\n<19> uint8_t client_ethaddr[ETH_ALEN];\n<25> dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n<55> memcpy(client_ethaddr, bp->bp_hwaddr, ETH_ALEN);\n<61> if (!m) {\n<69> rbp = (struct bootp_t *)m->m_data;\n<73> memset(rbp, 0, sizeof(struct bootp_t));\n<81> bc = request_addr(slirp, &preq_addr, client_ethaddr);\n<91> if (!bc) {\n<95> bc = get_new_addr(slirp, &daddr.sin_addr, client_ethaddr);\n<97> if (!bc) {\n<107> memcpy(bc->macaddr, client_ethaddr, ETH_ALEN);\n<109> } else if (preq_addr.s_addr != htonl(0L)) {\n<111> bc = request_addr(slirp, &preq_addr, client_ethaddr);\n<113> if (bc) {\n<117> memcpy(bc->macaddr, client_ethaddr, ETH_ALEN);\n<129> bc = find_addr(slirp, &daddr.sin_addr, bp->bp_hwaddr);\n<131> if (!bc) {\n<147> arp_table_add(slirp, daddr.sin_addr.s_addr, client_ethaddr);\n<151> saddr.sin_addr = slirp->vhost_addr;\n<169> memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, ETH_ALEN);\n<179> q = rbp->bp_vend;\n<181> memcpy(q, rfc1533_cookie, 4);\n<183> q += 4;\n<187> if (bc) {\n<219> snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), "%s",\n<227> *q++ = 4;\n<229> memcpy(q, &saddr.sin_addr, 4);\n<231> q += 4;\n<237> *q++ = 4;\n<239> memcpy(q, &slirp->vnetwork_mask, 4);\n<241> q += 4;\n<245> if (!slirp->restricted) {\n<249> *q++ = 4;\n<251> memcpy(q, &saddr.sin_addr, 4);\n<253> q += 4;\n<259> *q++ = 4;\n<261> memcpy(q, &slirp->vnameserver_addr, 4);\n<263> q += 4;\n<271> *q++ = 4;\n<273> val = htonl(LEASE_TIME);\n<275> memcpy(q, &val, 4);\n<277> q += 4;\n<281> if (*slirp->client_hostname) {\n<283> val = strlen(slirp->client_hostname);\n<287> *q++ = val;\n<289> memcpy(q, slirp->client_hostname, val);\n<291> q += val;\n<299> size_t spaceleft = sizeof(rbp->bp_vend) - (q - rbp->bp_vend);\n<301> val = slirp->vdnssearch_len;\n<303> if (val + 1 > spaceleft) {\n<311> memcpy(q, slirp->vdnssearch, val);\n<313> q += val;\n<339> *q++ = sizeof(nak_msg) - 1;\n<341> memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n<343> q += sizeof(nak_msg) - 1;\n<359> udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);
<1> static int vf_open(vf_instance_t *vf, char *args){\n<15> vf->priv=malloc(sizeof(struct vf_priv_s));\n<17> memset(vf->priv, 0, sizeof(struct vf_priv_s));\n<21> if (args) sscanf(args, "%d:%d", &vf->priv->qp, &vf->priv->mode);\n<25> if(vf->priv->qp < 0)
<1> static ssize_t qio_channel_websock_readv(QIOChannel *ioc,\n<49> for (i = 0 ; i < niov ; i++) {\n<53> if (want > (wioc->rawinput.offset - got)) {\n<55> want = (wioc->rawinput.offset - got);\n<67> got += want;\n<71> if (want < iov[i].iov_len) {
<1> static void spapr_reset_htab(sPAPRMachineState *spapr)\n<17> } else if (shift > 0) {\n<37> memset(spapr->htab, 0, HTAB_SIZE(spapr));\n<41> for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n<43> DIRTY_HPTE(HPTE(spapr->htab, index));
<1> static int preallocate(BlockDriverState *bs)\n<89> if (host_offset != 0) {\n<91> uint8_t buf[512];\n<93> memset(buf, 0, 512);\n<95> ret = bdrv_write(bs->file, (host_offset >> 9) + num - 1, buf, 1);
<1> int av_opencl_buffer_write_image(cl_mem dst_cl_buf, size_t cl_buffer_size, int dst_cl_offset,\n<3> uint8_t **src_data, int *plane_size, int plane_num)\n<51> temp += dst_cl_offset;\n<53> for (i = 0; i < plane_num; i++) {\n<55> memcpy(temp, src_data[i], plane_size[i]);\n<57> temp += plane_size[i];
<1> static void pc_init1(ram_addr_t ram_size, int vga_ram_size,\n<83> if (!env) {\n<85> fprintf(stderr, "Unable to find x86 CPU definition\n");\n<179> bios_size = get_image_size(buf);\n<191> ret = load_image(buf, phys_ram_base + bios_offset);\n<193> if (ret != bios_size) {\n<197> fprintf(stderr, "qemu: could not load PC BIOS '%s'\n", buf);\n<217> vga_bios_size = get_image_size(buf);\n<219> if (vga_bios_size <= 0 || vga_bios_size > 65536)\n<227> ret = load_image(buf, phys_ram_base + vga_bios_offset);\n<229> if (ret != vga_bios_size) {\n<233> fprintf(stderr, "qemu: could not load VGA BIOS '%s'\n", buf);\n<277> size = get_image_size(option_rom[i]);\n<279> if (size < 0) {\n<281> fprintf(stderr, "Could not load option rom '%s'\n",\n<289> if (size > (0x10000 - offset))\n<295> ret = load_image(option_rom[i], phys_ram_base + option_rom_offset);\n<297> if (ret != size) {\n<301> fprintf(stderr, "Too many option ROMS\n");\n<391> if (pci_enabled)\n<399> fprintf(stderr, "%s: vmware_vga: no PCI bus\n", __FUNCTION__);\n<481> for(i = 0; i < nb_nics; i++) {\n<483> nd = &nd_table[i];\n<485> if (!nd->model) {\n<489> nd->model = "ne2k_pci";\n<493> nd->model = "ne2k_isa";\n<499> if (strcmp(nd->model, "ne2k_isa") == 0) {\n<501> pc_init_ne2k_isa(nd, i8259);\n<503> } else if (pci_enabled) {\n<505> if (strcmp(nd->model, "?") == 0)\n<507> fprintf(stderr, "qemu: Supported ISA NICs: ne2k_isa\n");\n<509> pci_nic_init(pci_bus, nd, -1);\n<511> } else if (strcmp(nd->model, "?") == 0) {\n<513> fprintf(stderr, "qemu: Supported ISA NICs: ne2k_isa\n");\n<515> exit(1);\n<519> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd->model);\n<521> exit(1);\n<529> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<531> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static int write_elf64_note(DumpState *s)\n<15> memset(&phdr, 0, sizeof(Elf64_Phdr));\n<31> ret = fd_write_vmcore(&phdr, sizeof(Elf64_Phdr), s);
<1> static int match_format(const char *name, const char *names)\n<11> if (!name || !names)\n<17> namelen = strlen(name);\n<19> while ((p = strchr(names, ','))) {\n<21> len = FFMAX(p - names, namelen);\n<23> if (!av_strncasecmp(name, names, len))\n<27> names = p + 1;\n<31> return !av_strcasecmp(name, names);
<1> int nbd_receive_negotiate(QIOChannel *ioc, const char *name, uint16_t *flags,\n<47> if (read_sync(ioc, buf, 8, errp) < 0) {\n<57> buf[8] = '\0';\n<59> if (strlen(buf) == 0) {\n<61> error_setg(errp, "Server connection closed unexpectedly");\n<71> qemu_isprint(buf[0]) ? buf[0] : '.',\n<73> qemu_isprint(buf[1]) ? buf[1] : '.',\n<75> qemu_isprint(buf[2]) ? buf[2] : '.',\n<77> qemu_isprint(buf[3]) ? buf[3] : '.',\n<79> qemu_isprint(buf[4]) ? buf[4] : '.',\n<81> qemu_isprint(buf[5]) ? buf[5] : '.',\n<83> qemu_isprint(buf[6]) ? buf[6] : '.',\n<85> qemu_isprint(buf[7]) ? buf[7] : '.');\n<89> if (memcmp(buf, "NBDMAGIC", 8) != 0) {\n<91> error_setg(errp, "Invalid magic received");\n<99> if (read_sync(ioc, &magic, sizeof(magic), errp) < 0) {
<1> int ff_h264_context_init(H264Context *h)\n<5> ERContext *er = &h->er;\n<43> if (CONFIG_ERROR_RESILIENCE) {\n<99> FF_ALLOC_OR_GOTO(h->avctx, er->mbintra_table, mb_array_size, fail);\n<101> memset(er->mbintra_table, 1, mb_array_size);\n<105> FF_ALLOCZ_OR_GOTO(h->avctx, er->mbskip_table, mb_array_size + 2, fail);
<1> int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)\n<41> len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n<45> len += build_def_list(h->default_ref_list[list] + len,\n<55> if (len < sl->ref_count[list])\n<57> memset(&h->default_ref_list[list][len], 0, sizeof(H264Ref) * (sl->ref_count[list] - len));\n<89> FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n<97> if (len < sl->ref_count[0])\n<99> memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));\n<153> memset(&h->default_ref_list[j][i], 0, sizeof(h->default_ref_list[j][i]));
<11> if (ret) {\n<13> error_report("Could not enable split irqchip mode: %s\n",\n<15> strerror(-ret));
<1> static int unix_connect_saddr(UnixSocketAddress *saddr,\n<29> if (sock < 0) {\n<51> memset(&un, 0, sizeof(un));\n<65> if (connect(sock, (struct sockaddr *) &un, sizeof(un)) < 0) {
<1> static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n<2> hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n<3> if ( unlikely ( ! c ) ) return NULL ;
<1> void runstate_set(RunState new_state)\n<9> fprintf(stderr, "invalid runstate transition\n");
<1> char *socket_address_to_string(struct SocketAddressLegacy *addr, Error **errp)\n<11> switch (addr->type) {\n<15> inet = addr->u.inet.data;\n<17> if (strchr(inet->host, ':') == NULL) {\n<19> buf = g_strdup_printf("%s:%s", inet->host, inet->port);\n<23> buf = g_strdup_printf("[%s]:%s", inet->host, inet->port);
<1> static int read_write_object(int fd, char *buf, uint64_t oid, int copies,\n<19> memset(&hdr, 0, sizeof(hdr));\n<71> ret = do_req(fd, (SheepdogReq *)&hdr, buf, &wlen, &rlen);
<1> void ff_ass_init(AVSubtitle *sub)\n<5> memset(sub, 0, sizeof(*sub));
<1> static SlirpState *slirp_lookup(Monitor *mon, const char *vlan,\n<15> if (!vc) {\n<21> if (strcmp(vc->model, "user")) {\n<23> monitor_printf(mon, "invalid device specified\n");\n<25> return NULL;\n<29> return vc->opaque;
<1> static int decode_init(AVCodecContext *avctx)\n<5> HYuvContext *s = avctx->priv_data;\n<19> memset(s->vlc, 0, 3*sizeof(VLC));\n<77> if(read_huffman_tables(s, ((uint8_t*)avctx->extradata)+4, avctx->extradata_size) < 0)\n<133> if(read_old_huffman_tables(s) < 0)
<16> static void feature_destroy ( hb_feature_t * g ) {\n<17> free ( g ) ;\n<19> HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n<20> hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n<21> if ( unlikely ( ! c ) ) return NULL ;
<1> int kvm_cpu_exec(CPUState *env)\n<95> if (ret < 0) {\n<97> DPRINTF("kvm run failed %s\n", strerror(-ret));
<1> static void process_command(GAState *s, QDict *req)\n<19> ret = send_response(s, rsp);\n<21> if (ret) {\n<23> g_warning("error sending response: %s", strerror(ret));
<1> static int slirp_smb(SlirpState* s, const char *exported_dir,\n<29> snprintf(smb_conf, sizeof(smb_conf), "%s/%s", s->smb_dir, "smb.conf");\n<35> if (!f) {\n<89> fclose(f);\n<101> slirp_smb_cleanup(s);
<1> static vpx_fixed_buf_t pass0 ( vpx_image_t * raw , FILE * infile , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n<12> while ( get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ) {\n<14> printf ( "Pass 0 complete. Processed %d frames.\n" , frame_count ) ;
<1> static void usb_msd_handle_data(USBDevice *dev, USBPacket *p)\n<29> if (p->iov.size != 31) {\n<31> fprintf(stderr, "usb-msd: Bad CBW size");\n<39> if (le32_to_cpu(cbw.sig) != 0x43425355) {\n<41> fprintf(stderr, "usb-msd: Bad signature %08x\n",\n<43> le32_to_cpu(cbw.sig));\n<51> if (cbw.lun != 0) {\n<53> fprintf(stderr, "usb-msd: Bad LUN %d\n", cbw.lun);
<1> START_TEST(escaped_string)\n<35> for (i = 0; test_cases[i].encoded; i++) {\n<55> fail_unless(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
<1> static int mjpeg_decode_frame(AVCodecContext *avctx,\n<139> if (start_code >= 0xd0 && start_code <= 0xd7) {\n<141> dprintf("restart marker: %d\n", start_code&0x0f);\n<147> if (start_code >= 0xe0 && start_code <= 0xef)\n<153> else if (start_code == COM)\n<161> switch(start_code) {\n<313> printf("mjpeg: unsupported coding type (%x)\n", start_code);
<1> static void final(Real144_internal *glob, short *i1, short *i2, void *out,\n<3> int *statbuf, int len)\n<17> memcpy(glob->work, statbuf,20);\n<19> memcpy(glob->work + 10, i2, len * 2);\n<45> ptr2 = (ptr = glob->work) + len;\n<49> while (ptr < ptr2) {\n<53> sum += buffer[x] * (ptr[x]);\n<63> if (x<-32768 || x>32767) {\n<65> memset(out, 0, len * 2);\n<67> memset(statbuf, 0, 20);\n<75> ptr[10] = x;\n<81> memcpy(out, ptr+10 - len, len * 2);\n<83> memcpy(statbuf, ptr, 20);
<1> static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)\n<5> if (buf_size < 13)\n<9> if (memcmp(buf, "FLV", 3))\n<11> return AVERROR_INVALIDDATA;\n<13> buf      += 13;\n<15> buf_size -= 13;\n<17> while (buf_size >= 11 + 4) {\n<21> int size = AV_RB24(&buf[1]) + 11 + 4;\n<29> if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))\n<35> os->extra_packets[os->nb_extra_packets] = av_malloc(size);\n<37> if (!os->extra_packets[os->nb_extra_packets])\n<41> memcpy(os->extra_packets[os->nb_extra_packets], buf, size);\n<53> os->metadata      = av_malloc(os->metadata_size);\n<55> if (!os->metadata)\n<59> memcpy(os->metadata, buf + 11, os->metadata_size);\n<63> buf      += size;\n<65> buf_size -= size;\n<69> if (!os->metadata)
<1> static void omap_prcm_dpll_update(struct omap_prcm_s *s)\n<29> switch (mode) {\n<33> fprintf(stderr, "%s: bad EN_DPLL\n", __FUNCTION__);\n<63> switch ((s->clksel[6] >> 0) & 3) {\n<87> fprintf(stderr, "%s: bad CORE_CLK_SRC\n", __FUNCTION__);
<1> static int ehci_init_transfer(EHCIPacket *p)\n<27> if (cpage > 4) {\n<29> fprintf(stderr, "cpage out of range (%d)\n", cpage);
<1> static int ivi_decode_coded_blocks(GetBitContext *gb, IVIBandDesc *band,\n<19> int32_t trvec[64];\n<47> if (!band->scan) {\n<59> memset(trvec, 0, num_coeffs * sizeof(trvec[0]));\n<63> memset(col_flags, 0, sizeof(col_flags));\n<137> col_flags[pos & col_mask] |= !!val;\n<153> *prev_dc     += trvec[0];\n<157> col_flags[0] |= !!*prev_dc;
<1> static void test_acpi_asl(test_data *data)\n<13> memset(&exp_data, 0, sizeof(exp_data));\n<53> free_test_data(&exp_data);
<1> void ppce500_init(MachineState *machine, PPCE500Params *params)\n<79> if (cpu == NULL) {\n<81> fprintf(stderr, "Unable to initialize CPU!\n");\n<259> if (!pci_bus)\n<261> printf("couldn't create PCI controller!\n");\n<313> if (kernel_size < 0) {\n<315> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<345> initrd_size = load_image_targphys(machine->initrd_filename, initrd_base,\n<351> if (initrd_size < 0) {\n<353> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<379> dt_size = ppce500_prep_device_tree(machine, params, dt_base,\n<383> if (dt_size < 0) {\n<385> fprintf(stderr, "couldn't load device tree\n");
<1> static void opt_qscale(const char *arg)\n<11> fprintf(stderr, "qscale must be > 0.0 and <= 255\n");
<1> int main (int argc, char **argv)\n<9> if (argc != 4 && argc != 5) {\n<11> fprintf(stderr, "usage: %s [-refcount=<old|new_norefcount|new_refcount>] "\n<37> if (argc == 5) {\n<39> const char *mode = argv[1] + strlen("-refcount=");\n<41> if      (!strcmp(mode, "old"))            api_mode = API_MODE_OLD;\n<43> else if (!strcmp(mode, "new_norefcount")) api_mode = API_MODE_NEW_API_NO_REF_COUNT;\n<45> else if (!strcmp(mode, "new_refcount"))   api_mode = API_MODE_NEW_API_REF_COUNT;\n<49> fprintf(stderr, "unknow mode '%s'\n", mode);\n<51> exit(1);\n<55> argv++;\n<61> video_dst_filename = argv[2];\n<63> audio_dst_filename = argv[3];\n<75> if (avformat_open_input(&fmt_ctx, src_filename, NULL, NULL) < 0) {\n<77> fprintf(stderr, "Could not open source file %s\n", src_filename);\n<87> if (avformat_find_stream_info(fmt_ctx, NULL) < 0) {\n<89> fprintf(stderr, "Could not find stream information\n");\n<101> video_dec_ctx = video_stream->codec;\n<105> video_dst_file = fopen(video_dst_filename, "wb");\n<107> if (!video_dst_file) {\n<109> fprintf(stderr, "Could not open destination file %s\n", video_dst_filename);\n<121> ret = av_image_alloc(video_dst_data, video_dst_linesize,\n<127> if (ret < 0) {\n<129> fprintf(stderr, "Could not allocate raw video buffer\n");\n<145> audio_dec_ctx = audio_stream->codec;\n<147> audio_dst_file = fopen(audio_dst_filename, "wb");\n<149> if (!audio_dst_file) {\n<151> fprintf(stderr, "Could not open destination file %s\n", video_dst_filename);\n<165> av_dump_format(fmt_ctx, 0, src_filename, 0);\n<169> if (!audio_stream && !video_stream) {\n<171> fprintf(stderr, "Could not find audio or video stream in the input, aborting\n");\n<193> if (!frame) {\n<195> fprintf(stderr, "Could not allocate frame\n");\n<215> if (video_stream)\n<217> printf("Demuxing video from file '%s' into '%s'\n", src_filename, video_dst_filename);\n<219> if (audio_stream)\n<221> printf("Demuxing audio from file '%s' into '%s'\n", src_filename, audio_dst_filename);\n<265> printf("Demuxing succeeded.\n");\n<269> if (video_stream) {\n<271> printf("Play the output video file with the command:\n"\n<275> av_get_pix_fmt_name(video_dec_ctx->pix_fmt), video_dec_ctx->width, video_dec_ctx->height,\n<287> int n_channels = audio_dec_ctx->channels;\n<293> if (av_sample_fmt_is_planar(sfmt)) {\n<295> const char *packed = av_get_sample_fmt_name(sfmt);\n<297> printf("Warning: the sample format the decoder produced is planar "\n<305> n_channels = 1;\n<311> if ((ret = get_format_from_sample_fmt(&fmt, sfmt)) < 0)\n<317> printf("Play the output audio file with the command:\n"\n<333> avcodec_close(video_dec_ctx);\n<337> avcodec_close(audio_dec_ctx);
<1> static inline void mix_3f_to_mono(AC3DecodeContext *ctx)\n<15> memset(output[2], 0, sizeof(output[2]));\n<17> memset(output[3], 0, sizeof(output[3]));
<1> static ssize_t local_llistxattr(FsContext *ctx, const char *path,\n<29> xattr_len = llistxattr(rpath(ctx, path), value, 0);\n<37> xattr_len = llistxattr(rpath(ctx, path), orig_value, xattr_len);\n<49> temp_value = qemu_mallocz(xattr_len);\n<51> temp_value_start = temp_value;\n<55> while (xattr_len > parsed_len) {\n<57> attr_len = strlen(orig_value) + 1;\n<59> if (strncmp(orig_value, "user.virtfs.", 12) != 0) {\n<63> strcat(temp_value, orig_value);\n<65> temp_value  += attr_len;\n<67> actual_len += attr_len;\n<71> parsed_len += attr_len;\n<73> orig_value += attr_len;\n<83> } else if (size >= actual_len) {\n<87> memset(value, 0, size);\n<89> memcpy(value, temp_value_start, actual_len);\n<91> retval = actual_len;\n<105> qemu_free(temp_value_start);
<1> static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n<13> if (data[0] > 3) {\n<25> switch (data[0]) {\n<69> for (i = 0; i < limit; i++) {\n<71> int32_t val = read_s32(data, 4 + (i * 4));\n<73> memcpy(data + 4 + (i * 4), &val, sizeof(val));\n<155> switch (read_u8(data, 1)) {\n<179> switch (read_u16 (data, 2)) {\n<199> switch (read_u8(data, 4)) {\n<215> printf("Invalid audio format %d\n", read_u8(data, 4));\n<225> if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n<229> read_u8(data, 5));\n<243> printf ("Invalid audio message %d\n", read_u8(data, 4));\n<257> printf("Msg: %d\n", read_u16(data, 0));\n<269> printf("Msg: %d\n", data[0]);
<1> static int atrac1_decode_frame(AVCodecContext *avctx, void *data,\n<17> float* samples = data;\n<75> if (q->channels == 1) {\n<79> memcpy(samples, q->out_samples[0], AT1_SU_SAMPLES * 4);
<1> void proto_register_iax2 ( void ) {\n<560> memset ( hf_iax2_ies , 0xff , sizeof ( hf_iax2_ies ) ) ;
<1> static int vtenc_cm_to_avpacket(\n<9> ExtraSEI          *sei)\n<155> if (sei_nalu_size > 0) {\n<157> uint8_t *sei_nalu = pkt->data + pkt->size - sei_nalu_size;\n<159> memcpy(sei_nalu, start_code, sizeof(start_code));\n<161> sei_nalu += sizeof(start_code);\n<163> sei_nalu[0] = H264_NAL_SEI;\n<165> sei_nalu[1] = SEI_TYPE_USER_DATA_REGISTERED;\n<167> sei_nalu[2] = sei->size;\n<169> sei_nalu += 3;\n<171> memcpy(sei_nalu, sei->data, sei->size);\n<173> sei_nalu += sei->size;
<1> static void assert_file_overwrite(const char *filename)\n<5> if (file_overwrite && file_skip) {\n<7> fprintf(stderr, "Error, both -y and -n supplied. Exiting.\n");\n<15> if (!file_overwrite &&\n<17> (strchr(filename, ':') == NULL || filename[1] == ':' ||\n<19> av_strstart(filename, "file:", NULL))) {\n<21> if (avio_check(filename, 0) == 0) {\n<23> if (!using_stdin && !file_skip) {\n<25> fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", filename);\n<27> fflush(stderr);\n<29> if (!read_yesno()) {\n<31> fprintf(stderr, "Not overwriting - exiting\n");\n<41> fprintf(stderr,"File '%s' already exists. Exiting.\n", filename);
<1> static int scsi_hot_add(Monitor *mon, DeviceState *adapter,\n<15> if (!scsibus || strcmp(scsibus->qbus.info->name, "SCSI") != 0) {\n<17> error_report("Device is not a SCSI adapter");\n<19> return -1;\n<41> dinfo->unit = qemu_opt_get_number(dinfo->opts, "unit", -1);\n<43> scsidev = scsi_bus_legacy_add_drive(scsibus, dinfo, dinfo->unit);\n<45> if (!scsidev) {
<1> static void predictor_decode_mono(APEContext *ctx, int count)\n<5> APEPredictor *p = &ctx->predictor;\n<25> p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n<33> p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n<35> p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n<43> p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n<45> p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n<51> p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n<53> p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n<55> p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n<57> p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n<67> if (p->buf == p->historybuffer + HISTORY_SIZE) {\n<71> PREDICTOR_SIZE * sizeof(*p->historybuffer));\n<73> p->buf = p->historybuffer;
<1> MemTxResult address_space_read_continue(AddressSpace *as, hwaddr addr,\n<3> MemTxAttrs attrs, uint8_t *buf,\n<5> int len, hwaddr addr1, hwaddr l,\n<23> if (!memory_access_is_direct(mr, false)) {\n<91> ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n<93> memcpy(buf, ptr, l);\n<109> len -= l;\n<111> buf += l;\n<113> addr += l;\n<125> l = len;\n<127> mr = address_space_translate(as, addr, &addr1, &l, false);
<1> static void rate_start (SpiceRateCtl *rate)\n<5> memset (rate, 0, sizeof (*rate));
<1> CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,\n<35> if (!env) {\n<37> fprintf(stderr, "Unable to initialize CPU!\n");\n<65> memset(ram_bases, 0, sizeof(ram_bases));\n<67> memset(ram_sizes, 0, sizeof(ram_sizes));\n<69> *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n<107> if (!*pcip)\n<109> printf("couldn't create PCI controller!\n");
<1> static int ff_sctp_send(int s, const void *msg, size_t len,\n<3> const struct sctp_sndrcvinfo *sinfo, int flags)\n<29> if (sinfo) {\n<57> memcpy(CMSG_DATA(cmsg), sinfo, sizeof(struct sctp_sndrcvinfo));
<1> static int read_header(FFV1Context *f){\n<11> memset(state, 128, sizeof(state));\n<17> f->version= get_symbol(c, state, 0);\n<191> context_count= read_quant_tables(c, f->quant_table);\n<203> f->slice_count= get_symbol(c, state, 0);\n<225> fs->slice_x     = get_symbol(c, state, 0)   *f->width ;\n<259> PlaneContext * const p= &fs->plane[i];\n<263> if(f->version >= 2){\n<265> int idx=get_symbol(c, state, 0);\n<267> if(idx > (unsigned)f->quant_table_count){\n<277> memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));\n<283> memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));
<1> static void print_report(AVFormatContext **output_files,\n<9> char buf[1024];\n<69> buf[0] = '\0';\n<77> float q= -1;\n<85> q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;\n<87> if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<89> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q);\n<93> if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<99> frame_number = ost->frame_number;\n<101> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ",\n<103> frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);\n<105> if(is_last_report)\n<107> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L");\n<113> int qp= lrintf(q);\n<119> for(j=0; j<32; j++)\n<121> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log(qp_histogram[j]+1)/log(2)));\n<125> if (enc->flags&CODEC_FLAG_PSNR){\n<133> char type[3]= {'Y','U','V'};\n<135> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR=");\n<137> for(j=0; j<3; j++){\n<143> scale= enc->width*enc->height*255.0*255.0*frame_number;\n<159> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[j], psnr(error/scale));\n<163> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum/scale_sum));\n<187> if (verbose || is_last_report) {\n<189> bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n<193> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<197> (double)total_size / 1024, ti1, bitrate);\n<201> if (nb_frames_dup || nb_frames_drop)\n<203> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d",\n<209> if (verbose >= 0)\n<211> fprintf(stderr, "%s    \r", buf);\n<215> fflush(stderr);\n<221> if (is_last_report && verbose >= 0){\n<225> fprintf(stderr, "\n");\n<227> fprintf(stderr, "video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n",\n<229> video_size/1024.0,\n<231> audio_size/1024.0,\n<233> extra_size/1024.0,\n<235> 100.0*(total_size - raw)/raw
<1> static int raw_pread(BlockDriverState *bs, int64_t offset,\n<3> uint8_t *buf, int count)\n<7> BDRVRawState *s = bs->opaque;\n<35> ret = raw_pread_aligned(bs, offset - shift, s->aligned_buf, size);\n<37> if (ret < 0)\n<43> size = 512 - shift;\n<45> if (size > count)\n<47> size = count;\n<49> memcpy(buf, s->aligned_buf + shift, size);\n<53> buf += size;\n<55> offset += size;\n<57> count -= size;\n<59> sum += size;\n<89> ret = raw_pread_aligned(bs, offset, s->aligned_buf, size);\n<91> if (ret < 0) {\n<95> } else if (ret == 0) {\n<97> fprintf(stderr, "raw_pread: read beyond end of file\n");\n<107> if (size > count)\n<109> size = count;\n<113> memcpy(buf, s->aligned_buf, size);\n<117> buf += size;\n<119> offset += size;\n<121> count -= size;\n<123> sum += size;
<1> static void m5206_mbar_update(m5206_mbar_state *s)\n<13> irq = m5206_find_pending_irq(s);\n<31> switch (irq) {\n<55> fprintf(stderr, "Unhandled vector for IRQ %d\n", irq);
<1> static int parse_playlist(HLSContext *c, const char *url,\n<29> if (!in) {\n<49> read_chomp_line(in, line, sizeof(line));\n<51> if (strcmp(line, "#EXTM3U")) {\n<53> ret = AVERROR_INVALIDDATA;\n<61> if (var) {\n<69> while (!in->eof_reached) {\n<79> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n<85> } else if (av_strstart(line, "#EXT-X-KEY:", &ptr)) {\n<87> struct key_info info = {{0}};\n<89> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n<97> if (!strcmp(info.method, "AES-128"))\n<99> key_type = KEY_AES_128;\n<103> ff_hex_to_data(iv, info.iv + 2);\n<201> if (!seg) {\n<213> if (has_iv) {\n<215> memcpy(seg->iv, iv, sizeof(iv));\n<221> memset(seg->iv, 0, sizeof(seg->iv));\n<223> AV_WB32(seg->iv + 12, seq);\n<231> dynarray_add(&var->segments, &var->n_segments, seg);
<1> static void vtd_init(IntelIOMMUState *s)\n<5> memset(s->csr, 0, DMAR_REG_SIZE);\n<7> memset(s->wmask, 0, DMAR_REG_SIZE);\n<9> memset(s->w1cmask, 0, DMAR_REG_SIZE);\n<11> memset(s->womask, 0, DMAR_REG_SIZE);\n<45> vtd_reset_context_cache(s);\n<47> vtd_reset_iotlb(s);\n<53> vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n<55> vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n<57> vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n<59> vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n<61> vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n<63> vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n<65> vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n<67> vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n<69> vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n<75> vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n<77> vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n<79> vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n<81> vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n<91> vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n<103> vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n<107> vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n<109> vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n<111> vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n<113> vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n<115> vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n<117> vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n<119> vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n<123> vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n<129> vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n<131> vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n<133> vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n<139> vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n<141> vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);
<1> int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res)\n<5> if (bs->drv->bdrv_check == NULL) {\n<13> memset(res, 0, sizeof(*res));\n<15> return bs->drv->bdrv_check(bs, res);
<1> void evsignal_dealloc ( struct event_base * base ) {\n<10> if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;\n<17> free ( base -> sig . sh_old ) ;
<1> static int decode_frame_header(ProresContext *ctx, const uint8_t *buf,\n<117> if (flags & 2) {\n<133> memset(ctx->qmat_luma, 4, 64);\n<139> if (flags & 1) {\n<153> memset(ctx->qmat_chroma, 4, 64);
<1> int sclp_service_call(CPUS390XState *env, uint32_t sccb, uint64_t code)\n<19> if (sccb & ~0x7ffffff8ul) {\n<21> fprintf(stderr, "KVM: invalid sccb address 0x%x\n", sccb);
<1> static ssize_t net_rx_packet(NetClientState *nc, const uint8_t *buf, size_t size)\n<39> if (size > XC_PAGE_SIZE - NET_IP_ALIGN) {\n<51> memcpy(&rxreq, RING_GET_REQUEST(&netdev->rx_ring, rc), sizeof(rxreq));\n<63> if (page == NULL) {\n<69> net_rx_response(netdev, &rxreq, NETIF_RSP_ERROR, 0, 0, 0);\n<75> memcpy(page + NET_IP_ALIGN, buf, size);\n<79> net_rx_response(netdev, &rxreq, NETIF_RSP_OKAY, NET_IP_ALIGN, size, 0);
<1> static void do_video_out(AVFormatContext *s,\n<105> do_video_resample(ost, ist, in_picture, &final_picture);\n<251> if (ost->logfile && enc->stats_out) {\n<253> fprintf(ost->logfile, "%s", enc->stats_out);
<1> static CharDriverState *qemu_chr_open_pty(const char *id,\n<19> if (master_fd < 0) {\n<37> ret->pty = g_strdup(pty_name);\n<43> fprintf(stderr, "char device redirected to %s (label %s)\n",
<11> G2MContext *c = avctx->priv_data;\n<169> if (g2m_init_buffers(c))\n<313> g2m_load_cursor(c, &tbc);\n<345> if (c->width && c->height && c->framebuf) {\n<363> for (i = 0; i < avctx->height; i++)\n<365> memcpy(pic->data[0] + i * pic->linesize[0],\n<367> c->framebuf  + i * c->framebuf_stride,\n<369> c->width * 3);
<1> static void do_hybrid_window(int order, int n, int non_rec, const float *in,\n<3> float *out, float *hist, float *out2,\n<21> memmove(hist, hist + n, (order + non_rec)*sizeof(*hist));\n<31> colmult(work, window, hist, order + n + non_rec);
<1> int configure_accelerator(MachineState *ms)\n<15> AccelClass *acc = NULL;\n<41> acc = accel_find(buf);\n<43> if (!acc) {\n<45> fprintf(stderr, "\"%s\" accelerator not found.\n", buf);\n<51> if (acc->available && !acc->available()) {\n<61> ret = accel_init_machine(acc, ms);\n<63> if (ret < 0) {\n<67> fprintf(stderr, "failed to initialize %s: %s\n",\n<71> strerror(-ret));\n<85> if (!init_failed) {\n<87> fprintf(stderr, "No accelerator found!\n");\n<97> if (init_failed) {\n<99> fprintf(stderr, "Back to %s accelerator.\n", acc->name);
<1> int ff_draw_slice(AVFilterLink *link, int y, int h, int slice_dir)\n<5> uint8_t *src[4], *dst[4];\n<39> src[i] = dst[i] = NULL;\n<53> if (!src[i]) continue;\n<57> for (j = 0; j < h >> (i==1 || i==2 ? vsub : 0); j++) {\n<59> memcpy(dst[i], src[i], planew);\n<61> src[i] += link->src_buf->linesize[i];\n<63> dst[i] += link->cur_buf->linesize[i];
<1> char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n<3> length = strlen ( filename ) ;\n<4> if ( length > 0 ) {\n<5> if ( ( filename [ 0 ] == '\"' ) && ( filename [ length - 1 ] == '\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n<7> return strdup ( filename ) ;
<1> static int ftp_passive_mode(FTPContext *s)\n<5> char *res = NULL, *start, *end;\n<15> if (!ftp_send_command(s, command, pasv_codes, &res))\n<23> for (i = 0; i < strlen(res); ++i) {\n<25> if (res[i] == '(') {\n<27> start = res + i + 1;\n<29> } else if (res[i] == ')') {\n<31> end = res + i;\n<77> av_free(res);\n<85> av_free(res);
<1> static void test_acpi_q35_tcg_cphp(void)\n<9> memset(&data, 0, sizeof(data));\n<15> test_acpi_one(" -smp 2,cores=3,sockets=2,maxcpus=6"\n<21> free_test_data(&data);
<1> static void replay_enable(const char *fname, int mode)\n<11> switch (mode) {\n<27> fprintf(stderr, "Replay: internal error: invalid replay mode\n");\n<43> replay_file = fopen(fname, fmode);\n<45> if (replay_file == NULL) {\n<47> fprintf(stderr, "Replay: open %s: %s\n", fname, strerror(errno));\n<55> replay_filename = g_strdup(fname);\n<79> if (version != REPLAY_VERSION) {\n<81> fprintf(stderr, "Replay: invalid input log file version\n");
<1> static int hyperv_handle_properties(CPUState *cs)\n<75> fprintf(stderr, "Hyper-V SynIC is not supported by kernel\n");\n<97> if (!has_msr_hv_stimer) {\n<99> fprintf(stderr, "Hyper-V timers aren't supported by kernel\n");
<1> void cpu_reset (CPUMIPSState *env)\n<5> memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n<9> tlb_flush(env, 1);
<1> av_cold int ff_h264_decode_init(AVCodecContext *avctx)\n<13> if (ret < 0)\n<19> memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));\n<21> memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));
<1> static void fill_note(struct memelfnote *note, const char *name, int type,\n<11> namesz = strlen(name) + 1;\n<13> note->name = name;\n<15> note->namesz = namesz;\n<17> note->namesz_rounded = roundup(namesz, sizeof (int32_t));
<1> static TCGArg do_constant_folding_2(int op, TCGArg x, TCGArg y)\n<5> switch (op) {
<1> UserDefTwo *qmp_user_def_cmd2(UserDefOne *ud1a,\n<3> bool has_udb1, UserDefOne *ud1b,\n<17> ud1c->string = strdup(ud1a->string);\n<23> ud1d->string = strdup(has_udb1 ? ud1b->string : "blah0");\n<33> ret->string0 = strdup("blah1");\n<37> ret->dict1->string1 = strdup("blah2");\n<41> ret->dict1->dict2->userdef = ud1c;\n<43> ret->dict1->dict2->string = strdup("blah3");\n<49> ret->dict1->dict3->userdef = ud1d;\n<51> ret->dict1->dict3->string = strdup("blah4");\n<55> return ret;
<1> static int mpc8544_load_device_tree(CPUPPCState *env,\n<105> if (ret < 0) {\n<107> fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");\n<117> if (ret < 0) {\n<119> fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");\n<131> if (ret < 0)\n<133> fprintf(stderr, "couldn't set /chosen/bootargs\n");
<1> static void do_change(const char *device, const char *target, const char *fmt)\n<5> if (strcmp(device, "vnc") == 0) {\n<7> do_change_vnc(target);\n<11> do_change_block(device, target, fmt);
<1> int EVP_EncryptUpdate ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n<9> if ( inl <= 0 ) {\n<13> if ( ctx -> buf_len == 0 && ( inl & ( ctx -> block_mask ) ) == 0 ) {\n<27> if ( i + inl < bl ) {\n<28> memcpy ( & ( ctx -> buf [ i ] ) , in , inl ) ;\n<29> ctx -> buf_len += inl ;\n<34> j = bl - i ;\n<35> memcpy ( & ( ctx -> buf [ i ] ) , in , j ) ;\n<36> if ( ! ctx -> cipher -> do_cipher ( ctx , out , ctx -> buf , bl ) ) return 0 ;\n<37> inl -= j ;\n<38> in += j ;\n<47> if ( ! ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ) return 0 ;\n<50> if ( i != 0 ) memcpy ( ctx -> buf , & ( in [ inl ] ) , i ) ;\n<51> ctx -> buf_len = i ;
<1> static void mm_decode_intra(MmContext * s, int half_horiz, int half_vert, const uint8_t *buf, int buf_size)\n<7> i=0; x=0; y=0;\n<19> run_length = 1;\n<21> color = buf[i];\n<27> run_length = (buf[i] & 0x7f) + 2;\n<29> color = buf[i+1];\n<39> run_length *=2;\n<43> if (color) {\n<45> memset(s->frame.data[0] + y*s->frame.linesize[0] + x, color, run_length);\n<47> if (half_vert)\n<49> memset(s->frame.data[0] + (y+1)*s->frame.linesize[0] + x, color, run_length);\n<53> x+= run_length;\n<57> if (x >= s->avctx->width) {\n<59> x=0;
<1> static int vnc_refresh_server_surface(VncDisplay *vd)\n<51> if (cmp_bytes > vnc_server_fb_stride(vd)) {\n<53> cmp_bytes = vnc_server_fb_stride(vd);\n<85> guest_ptr = (uint8_t *)pixman_image_get_data(tmpbuf);\n<89> guest_ptr = guest_row;\n<93> server_ptr = server_row;\n<99> x += 16, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n<101> if (!test_and_clear_bit((x / 16), vd->guest.dirty[y]))\n<105> if (memcmp(server_ptr, guest_ptr, cmp_bytes) == 0)\n<109> memcpy(server_ptr, guest_ptr, cmp_bytes);\n<111> if (!vd->non_adaptive)\n<115> QTAILQ_FOREACH(vs, &vd->clients, next) {\n<117> set_bit((x / 16), vs->dirty[y]);\n<121> has_dirty++;
<1> int gdev_x_open ( gx_device_X * xdev ) {\n<19> char * dispname = getenv ( "DISPLAY" ) ;\n<20> emprintf1 ( xdev -> memory , "Cannot open X display `%s'.\n" , ( dispname == NULL ? "(null)" : dispname ) ) ;
<1> static void simple_string(void)\n<27> for (i = 0; test_cases[i].encoded; i++) {\n<35> obj = qobject_from_json(test_cases[i].encoded);\n<47> g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n<53> g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
<1> void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,\n<57> int16_t *coeffs = lc->tu.coeffs[c_idx > 0];\n<85> memset(coeffs, 0, trafo_size * trafo_size * sizeof(int16_t));\n<923> s->hevcdsp.transform_rdpcm(coeffs, log2_trafo_size, mode);\n<941> FFSWAP(int16_t, coeffs[i], coeffs[16 - i - 1]);\n<947> s->hevcdsp.transform_skip(coeffs, log2_trafo_size);\n<967> s->hevcdsp.idct_4x4_luma(coeffs);\n<975> s->hevcdsp.idct_dc[log2_trafo_size-2](coeffs);\n<993> s->hevcdsp.idct[log2_trafo_size-2](coeffs, col_limit);\n<1009> coeffs[i] = coeffs[i] + ((lc->tu.res_scale_val * coeffs_y[i]) >> 3);\n<1015> s->hevcdsp.transform_add[log2_trafo_size-2](dst, coeffs, stride);
<1> static int http_receive_data(HTTPContext *c)\n<9> if (c->buffer_end > c->buffer_ptr) {\n<15> len = recv(c->fd, c->buffer_ptr, c->buffer_end - c->buffer_ptr, 0);\n<17> if (len < 0) {\n<35> c->buffer_ptr += len;\n<47> if (c->buffer_ptr - c->buffer >= 2 && c->data_count > FFM_PACKET_SIZE) {\n<81> if (write(c->feed_fd, c->buffer, FFM_PACKET_SIZE) < 0) {\n<83> http_log("Error writing to feed file: %s\n", strerror(errno));\n<175> for (i = 0; i < s->nb_streams; i++)
<1> static int dvvideo_init(AVCodecContext *avctx)\n<15> if (!done) {\n<109> if (!dv_rl_vlc) {\n<259> memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);
<1> static int vmdaudio_decode_frame(AVCodecContext *avctx, void *data,\n<7> const uint8_t *buf = avpkt->data;\n<13> VmdAudioContext *s = avctx->priv_data;\n<89> audio_chunks = buf_size / s->chunk_size;\n<105> output_samples_u8  = s->frame.data[0];\n<107> output_samples_s16 = (int16_t *)s->frame.data[0];\n<115> int silent_size = avctx->block_align * silent_chunks;\n<117> if (s->out_bps == 2) {\n<119> memset(output_samples_s16, 0x00, silent_size * 2);\n<121> output_samples_s16 += silent_size;\n<125> memset(output_samples_u8,  0x80, silent_size);\n<127> output_samples_u8 += silent_size;\n<141> while (buf < buf_end) {\n<143> if (s->out_bps == 2) {\n<145> decode_audio_s16(output_samples_s16, buf, s->chunk_size,\n<153> memcpy(output_samples_u8, buf, s->chunk_size);\n<155> output_samples_u8  += avctx->block_align;\n<159> buf += s->chunk_size;
<1> static int sbr_hf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_high [ 64 ] [ 40 ] [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , const float ( * alpha0 ) [ 2 ] , const float ( * alpha1 ) [ 2 ] , const float bw_array [ 5 ] , const uint8_t * t_env , int bs_num_env ) {\n<21> if ( k < sbr -> m [ 1 ] + sbr -> kx [ 1 ] ) memset ( X_high + k , 0 , ( sbr -> m [ 1 ] + sbr -> kx [ 1 ] - k ) * sizeof ( * X_high ) ) ;
<1> static void pxa2xx_gpio_set(void *opaque, int line, int level)\n<15> if (line >= s->lines) {\n<17> printf("%s: No GPIO pin %i\n", __FUNCTION__, line);
<1> static int scsi_disk_emulate_inquiry(SCSIRequest *req, uint8_t *outbuf)\n<5> SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n<53> outbuf[buflen++] = 0x00;\n<57> switch (page_code) {\n<87> int l = strlen(serial);\n<91> if (l > req->cmd.xfer)\n<95> if (l > 20)\n<97> l = 20;\n<105> outbuf[buflen++] = l;\n<107> memcpy(outbuf+buflen, serial, l);\n<109> buflen += l;\n<123> int id_len = strlen(bdrv_get_device_name(s->bs));\n<127> if (id_len > max_len)\n<129> id_len = max_len;\n<145> outbuf[buflen++] = id_len; // length of data following\n<149> memcpy(outbuf+buflen, bdrv_get_device_name(s->bs), id_len);\n<151> buflen += id_len;\n<169> outbuf[3] = buflen = 0x3c;\n<173> memset(outbuf + 4, 0, buflen - 4);\n<233> if (req->cmd.xfer < 5) {\n<247> if (buflen > SCSI_MAX_INQUIRY_LEN)\n<249> buflen = SCSI_MAX_INQUIRY_LEN;\n<253> memset(outbuf, 0, buflen);\n<257> if (req->lun || req->cmd.buf[1] >> 5) {\n<261> return buflen;\n<267> if (bdrv_get_type_hint(s->bs) == BDRV_TYPE_CDROM) {\n<273> memcpy(&outbuf[16], "QEMU CD-ROM     ", 16);\n<279> memcpy(&outbuf[16], "QEMU HARDDISK   ", 16);\n<283> memcpy(&outbuf[8], "QEMU    ", 8);\n<285> memcpy(&outbuf[32], s->version ? s->version : QEMU_VERSION, 4);\n<305> if (buflen > 36) {
<1> static void tftp_send_error(struct tftp_session *spt,\n<21> if (!m) {\n<29> memset(m->m_data, 0, m->m_size);\n<33> m->m_data += IF_MAXLINKHDR;\n<45> pstrcpy((char *)tp->x.tp_error.tp_msg, sizeof(tp->x.tp_error.tp_msg), msg);\n<61> m->m_len = sizeof(struct tftp_t) - 514 + 3 + strlen(msg) -\n<67> udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);
<1> static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , SBRDSPContext * sbrdsp , const float * in , float * x , float z [ 320 ] , float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n<3> memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ;\n<4> memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ;\n<8> dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ;
<1> static void check_pred4x4(H264PredContext *h, uint8_t *buf0, uint8_t *buf1,\n<15> if (check_pred_func(h->pred4x4[pred_mode], "4x4", pred4x4_modes[codec][pred_mode])) {\n<23> if (memcmp(buf0, buf1, BUF_SIZE))\n<25> fail();
<1> static int vpc_create(const char *filename, QemuOpts *opts, Error **errp)\n<5> uint8_t buf[1024];\n<7> VHDFooter *footer = (VHDFooter *) buf;\n<35> disk_type_param = qemu_opt_get_del(opts, BLOCK_OPT_SUBFMT);\n<37> if (disk_type_param) {\n<39> if (!strcmp(disk_type_param, "dynamic")) {\n<41> disk_type = VHD_DYNAMIC;\n<43> } else if (!strcmp(disk_type_param, "fixed")) {\n<45> disk_type = VHD_FIXED;\n<49> ret = -EINVAL;\n<61> nocow = qemu_opt_get_bool_del(opts, BLOCK_OPT_NOCOW, false);\n<67> fd = qemu_open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);\n<69> if (fd < 0) {\n<121> for (i = 0; total_sectors > (int64_t)cyls * heads * secs_per_cyl; i++) {\n<145> memset(buf, 0, 1024);\n<149> memcpy(footer->creator, "conectix", 8);\n<153> memcpy(footer->creator_app, "qemu", 4);\n<155> memcpy(footer->creator_os, "Wi2k", 4);\n<217> footer->checksum = be32_to_cpu(vpc_checksum(buf, HEADER_SIZE));\n<239> g_free(disk_type_param);
<1> static void final_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n<3> hb_glyph_info_t * info = buffer -> info ;\n<40> if ( is_halant_or_coeng ( info [ new_pos ] ) && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n<41> if ( new_pos + 1 < end && is_joiner ( info [ new_pos + 1 ] ) ) new_pos ++ ;\n<48> i -- ) if ( info [ i - 1 ] . indic_position ( ) == POS_PRE_M ) {\n<50> hb_glyph_info_t tmp = info [ old_pos ] ;\n<51> memmove ( & info [ old_pos ] , & info [ old_pos + 1 ] , ( new_pos - old_pos ) * sizeof ( info [ 0 ] ) ) ;\n<52> info [ new_pos ] = tmp ;\n<67> if ( start + 1 < end && info [ start ] . indic_position ( ) == POS_RA_TO_BECOME_REPH && ( ( info [ start ] . indic_category ( ) == OT_Repha ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ start ] ) ) ) {\n<115> memmove ( & info [ start ] , & info [ start + 1 ] , ( new_reph_pos - start ) * sizeof ( info [ 0 ] ) ) ;\n<125> if ( _hb_glyph_info_substituted ( & info [ i ] ) && ( ( pref_len == 1 ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n<140> if ( new_pos < end && is_joiner ( info [ new_pos ] ) ) new_pos ++ ;\n<145> hb_glyph_info_t tmp = info [ old_pos ] ;\n<146> memmove ( & info [ new_pos + 1 ] , & info [ new_pos ] , ( old_pos - new_pos ) * sizeof ( info [ 0 ] ) ) ;
<1> int ff_mpv_common_frame_size_change(MpegEncContext *s)\n<9> if (!s->context_initialized)\n<15> if (s->slice_context_count > 1) {\n<23> for (i = 1; i < s->slice_context_count; i++) {\n<25> av_freep(&s->thread_context[i]);\n<53> s->current_picture_ptr      = NULL;\n<59> if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n<61> s->mb_height = (s->height + 31) / 32 * 2;\n<65> s->mb_height = (s->height + 15) / 16;\n<69> if ((s->width || s->height) &&\n<71> (err = av_image_check_size(s->width, s->height, 0, s->avctx)) < 0)\n<77> if ((err = init_context_frame(s)))\n<87> if (s->width && s->height) {\n<93> for (i = 1; i < nb_slices; i++) {\n<95> s->thread_context[i] = av_malloc(sizeof(MpegEncContext));\n<97> memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n<105> if ((err = init_duplicate_context(s->thread_context[i])) < 0)\n<111> (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n<115> (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n<143> ff_mpv_common_end(s);
<1> static void smbios_build_type_0_fields(const char *t)\n<31> if (get_param_value(buf, sizeof(buf), "release", t)) {\n<33> sscanf(buf, "%hhu.%hhu", &major, &minor);
<1> static int aac_decode_frame(AVCodecContext *avctx, void *data,\n<23> const uint8_t *new_extradata = av_packet_get_side_data(avpkt,\n<39> if (!avctx->extradata)\n<45> memcpy(avctx->extradata, new_extradata, new_extradata_size);\n<49> if (decode_audio_specific_config(ac, ac->avctx, &ac->oc[1].m4ac,
<1> void mips_r4k_init(MachineState *machine)\n<69> if (cpu == NULL) {\n<71> fprintf(stderr, "Unable to find CPU definition\n");\n<93> if (ram_size > (256 << 20)) {\n<99> ((unsigned int)ram_size / (1 << 20)));\n<131> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<173> if (!pflash_cfi01_register(0x1fc00000, NULL, "mips_r4k.bios", mips_rom,\n<181> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<185> } else if (!qtest_enabled()) {\n<189> fprintf(stderr, "qemu: Warning, could not load MIPS bios '%s'\n",
<1> static int gif_read_header1(GifState *s)\n<13> if (bytestream2_get_bytes_left(&s->gb) < 13)\n<21> bytestream2_get_bufferu(&s->gb, sig, 6);\n<23> if (memcmp(sig, gif87a_sig, 6) != 0 &&\n<25> memcmp(sig, gif89a_sig, 6) != 0)\n<27> return AVERROR_INVALIDDATA;\n<33> s->transparent_color_index = -1;\n<35> s->screen_width = bytestream2_get_le16u(&s->gb);\n<37> s->screen_height = bytestream2_get_le16u(&s->gb);\n<39> if(   (unsigned)s->screen_width  > 32767
<1> static abi_ulong setup_arg_pages(abi_ulong p, struct linux_binprm *bprm,\n<59> if (bprm->page[i]) {\n<65> memcpy_to_target(stack_base, bprm->page[i], TARGET_PAGE_SIZE);\n<67> free(bprm->page[i]);
<1> build_rsdt(GArray *table_data, GArray *linker, GArray *table_offsets,\n<13> const int table_data_len = (sizeof(uint32_t) * table_offsets->len);\n<19> rsdt = acpi_data_push(table_data, rsdt_len);\n<21> memcpy(rsdt->table_offset_entry, table_offsets->data, table_data_len);\n<41> (void *)rsdt, "RSDT", rsdt_len, 1, oem_id, oem_table_id);
<1> milkymist_init(MachineState *machine)\n<9> const char *kernel_cmdline = machine->kernel_cmdline;\n<67> cpu = cpu_lm32_init(cpu_model);\n<69> if (cpu == NULL) {\n<71> fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model);\n<131> bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<149> if (!kernel_filename && !dinfo && !bios_filename && !qtest_enabled()) {\n<151> fprintf(stderr, "qemu: could not load Milkymist One bios '%s'\n",\n<203> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<213> kernel_size = load_image_targphys(kernel_filename, sdram_base,\n<223> if (kernel_size < 0) {\n<225> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<237> if (kernel_cmdline && strlen(kernel_cmdline)) {\n<239> pstrcpy_targphys("cmdline", cmdline_base, TARGET_PAGE_SIZE,\n<243> reset_info->cmdline_base = (uint32_t)cmdline_base;
<1> int monitor_get_fd(Monitor *mon, const char *fdname)\n<9> LIST_FOREACH(monfd, &mon->fds, next) {\n<15> if (strcmp(monfd->name, fdname) != 0) {\n<29> LIST_REMOVE(monfd, next);\n<31> qemu_free(monfd->name);
<1> void apic_init_reset(DeviceState *dev)\n<13> if (!s) {\n<27> memset(s->isr, 0, sizeof(s->isr));\n<29> memset(s->tmr, 0, sizeof(s->tmr));\n<31> memset(s->irr, 0, sizeof(s->irr));\n<41> memset(s->icr, 0, sizeof(s->icr));\n<69> info->reset(s);
<1> CPUState *ppc4xx_init (const char *cpu_model,\n<15> env = cpu_init(cpu_model);\n<17> if (!env) {\n<19> fprintf(stderr, "Unable to find PowerPC %s CPU definition\n",
<1> static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config)\n<61> if (strchr(opt, ':')) {\n<65> snprintf(buff, sizeof(buff), "%s", opt);\n<67> codec_name = buff;\n<69> option = strchr(buff, ':');\n<71> buff[option - buff] = '\0';\n<73> option++;\n<75> if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0)\n<79> if (!ctx->codec || !ctx->priv_data)\n<85> option = opt;\n<91> o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN);\n<93> if (!o && (!strcmp(option, "time_base")  || !strcmp(option, "pixel_format") ||\n<95> !strcmp(option, "video_size") || !strcmp(option, "codec_tag")))\n<97> o = av_opt_find(ctx, option, NULL, 0, 0);\n<99> if (!o) {\n<101> report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n<119> } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) {\n<121> report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n<133> report_config_error(config->filename, config->line_num, AV_LOG_ERROR,
<1> static int restore_toc_entry ( ArchiveHandle * AH , TocEntry * te , bool is_parallel ) {\n<7> if ( _tocEntryIsACL ( te ) ) reqs = 0 ;\n<9> if ( ! ropt -> createDB && strcmp ( te -> desc , "DATABASE" ) == 0 ) reqs = 0 ;\n<10> if ( ! ropt -> suppressDumpWarnings && strcmp ( te -> desc , "WARNING" ) == 0 ) {\n<11> if ( ! ropt -> dataOnly && te -> defn != NULL && strlen ( te -> defn ) != 0 ) write_msg ( modulename , "warning from original dump file: %s\n" , te -> defn ) ;\n<12> else if ( te -> copyStmt != NULL && strlen ( te -> copyStmt ) != 0 ) write_msg ( modulename , "warning from original dump file: %s\n" , te -> copyStmt ) ;\n<15> if ( ( reqs & REQ_SCHEMA ) != 0 ) {\n<16> if ( te -> namespace ) ahlog ( AH , 1 , "creating %s \"%s.%s\"\n" , te -> desc , te -> namespace , te -> tag ) ;\n<17> else ahlog ( AH , 1 , "creating %s \"%s\"\n" , te -> desc , te -> tag ) ;\n<18> _printTocEntry ( AH , te , false , false ) ;\n<20> if ( strcmp ( te -> desc , "TABLE" ) == 0 ) {\n<21> if ( AH -> lastErrorTE == te ) {\n<24> else inhibit_data_for_failed_table ( AH , te ) ;\n<29> else mark_create_done ( AH , te ) ;\n<32> if ( strcmp ( te -> desc , "DATABASE" ) == 0 ) {\n<33> ahlog ( AH , 1 , "connecting to new database \"%s\"\n" , te -> tag ) ;\n<34> _reconnectToDB ( AH , te -> tag ) ;\n<35> ropt -> dbname = pg_strdup ( te -> tag ) ;\n<40> if ( AH -> PrintTocDataPtr != NULL ) {\n<41> _printTocEntry ( AH , te , true , false ) ;\n<42> if ( strcmp ( te -> desc , "BLOBS" ) == 0 || strcmp ( te -> desc , "BLOB COMMENTS" ) == 0 ) {\n<43> ahlog ( AH , 1 , "processing %s\n" , te -> desc ) ;\n<44> _selectOutputSchema ( AH , "pg_catalog" ) ;\n<45> if ( strcmp ( te -> desc , "BLOB COMMENTS" ) == 0 ) AH -> outputKind = OUTPUT_OTHERDATA ;\n<46> ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n<47> AH -> outputKind = OUTPUT_SQLCMDS ;\n<50> _disableTriggersIfNecessary ( AH , te ) ;\n<51> _becomeOwner ( AH , te ) ;\n<52> _selectOutputSchema ( AH , te -> namespace ) ;\n<53> ahlog ( AH , 1 , "processing data for table \"%s.%s\"\n" , te -> namespace , te -> tag ) ;\n<54> if ( is_parallel && te -> created ) {\n<59> if ( te -> copyStmt && strlen ( te -> copyStmt ) > 0 ) {\n<60> ahprintf ( AH , "%s" , te -> copyStmt ) ;\n<61> AH -> outputKind = OUTPUT_COPYDATA ;\n<63> else AH -> outputKind = OUTPUT_OTHERDATA ;\n<64> ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n<65> if ( AH -> outputKind == OUTPUT_COPYDATA && RestoringToDB ( AH ) ) EndDBCopyMode ( & AH -> public , te -> tag ) ;\n<66> AH -> outputKind = OUTPUT_SQLCMDS ;\n<67> if ( is_parallel && te -> created ) CommitTransaction ( & AH -> public ) ;\n<68> _enableTriggersIfNecessary ( AH , te ) ;\n<73> ahlog ( AH , 1 , "executing %s %s\n" , te -> desc , te -> tag ) ;\n<74> _printTocEntry ( AH , te , false , false ) ;
<1> static void check_pred8x8l(H264PredContext *h, uint8_t *buf0, uint8_t *buf1,\n<25> if ((pred_mode == DIAG_DOWN_RIGHT_PRED || pred_mode == VERT_RIGHT_PRED) && !has_topleft)\n<37> if (memcmp(buf0, buf1, BUF_SIZE))\n<39> fail();
<1> static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n<11> const char *proto_name = avio_find_protocol_name(url);\n<31> if (!av_strstart(proto_name, "http", NULL) && !av_strstart(proto_name, "file", NULL))\n<35> if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n<39> else if (strcmp(proto_name, "file") || !strncmp(url, "file,", 5))\n<41> return AVERROR_INVALIDDATA;\n<45> ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n<47> if (ret >= 0) {\n<61> av_dict_free(&tmp);\n<65> return ret;
<1> static CharDriverState *qemu_chr_open_tcp(const char *host_str,\n<45> if (parse_unix_path(&uaddr, host_str) < 0)\n<59> if (parse_host_port(&saddr, host_str) < 0)\n<67> ptr = host_str;\n<69> while((ptr = strchr(ptr,','))) {\n<71> ptr++;\n<73> if (!strncmp(ptr,"server",6)) {\n<77> } else if (!strncmp(ptr,"nowait",6)) {\n<81> } else if (!strncmp(ptr,"nodelay",6)) {\n<87> printf("Unknown option: %s\n", ptr);\n<95> if (!is_listen)\n<101> chr = qemu_mallocz(sizeof(CharDriverState));\n<103> if (!chr)\n<269> if (is_listen && is_waitconnect) {\n<271> printf("QEMU waiting for connection on: %s\n", host_str);
<1> BlockDriverAIOCB *laio_submit(BlockDriverState *bs, void *aio_ctx, int fd,\n<5> BlockDriverCompletionFunc *cb, void *opaque, int type)\n<39> switch (type) {\n<55> fprintf(stderr, "%s: invalid AIO request type 0x%x.\n",
<1> static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) {\n<6> res = validate_img ( ctx , img ) ;\n<7> if ( res == VPX_CODEC_OK && cpi != NULL && ctx -> cx_data == NULL ) {\n<9> if ( ctx -> cx_data_sz < 4096 ) ctx -> cx_data_sz = 4096 ;\n<10> ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ;\n<11> if ( ctx -> cx_data == NULL ) {\n<16> pick_quickcompress_mode ( ctx , duration , deadline ) ;\n<40> res = update_error_state ( ctx , & cpi -> common . error ) ;\n<43> cx_data = ctx -> cx_data ;\n<44> cx_data_sz = ctx -> cx_data_sz ;\n<45> if ( ctx -> pending_cx_data ) {\n<46> memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ;\n<47> ctx -> pending_cx_data = cx_data ;\n<48> cx_data += ctx -> pending_cx_data_sz ;\n<49> cx_data_sz -= ctx -> pending_cx_data_sz ;\n<50> if ( cx_data_sz < ctx -> cx_data_sz / 2 ) {\n<55> while ( cx_data_sz >= ctx -> cx_data_sz / 2 && - 1 != vp9_get_compressed_data ( cpi , & lib_flags , & size , cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {\n<61> ctx -> pending_cx_data_sz += size ;\n<75> ctx -> pending_cx_data_sz += size ;
<1> int encode_const ( char * string , struct filter_op * fop ) {\n<3> memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n<4> if ( ! strncmp ( string , "0x" , 2 ) && isxdigit ( ( int ) string [ 2 ] ) ) {\n<8> else if ( isdigit ( ( int ) string [ 0 ] ) ) {\n<12> else if ( string [ 0 ] == '\'' && string [ strlen ( string ) - 1 ] == '\'' ) {\n<14> p = strchr ( string + 1 , '\'' ) ;\n<15> * p = '\0' ;\n<16> if ( ip_addr_pton ( string + 1 , & ipaddr ) == E_SUCCESS ) {\n<30> else if ( string [ 0 ] == '\"' && string [ strlen ( string ) - 1 ] == '\"' ) {\n<31> p = strchr ( string + 1 , '\"' ) ;\n<32> * p = '\0' ;\n<33> fop -> op . test . string = ( u_char * ) strdup ( string + 1 ) ;\n<34> fop -> op . test . slen = strescape ( ( char * ) fop -> op . test . string , ( char * ) fop -> op . test . string ) ;\n<35> return E_SUCCESS ;\n<37> else if ( isalpha ( ( int ) string [ 0 ] ) ) {\n<38> return get_constant ( string , & fop -> op . test . value ) ;
<1> static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)\n<13> if (!ost->st->codec->extradata_size && ost->enc_ctx->extradata_size) {\n<15> ost->st->codec->extradata = av_mallocz(ost->enc_ctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n<17> if (ost->st->codec->extradata) {\n<19> memcpy(ost->st->codec->extradata, ost->enc_ctx->extradata, ost->enc_ctx->extradata_size);\n<21> ost->st->codec->extradata_size = ost->enc_ctx->extradata_size;\n<103> AVPacket new_pkt = *pkt;\n<121> if(a == 0 && new_pkt.data != pkt->data && new_pkt.destruct) {\n<123> uint8_t *t = av_malloc(new_pkt.size + AV_INPUT_BUFFER_PADDING_SIZE); //the new should be a subset of the old so cannot overflow\n<125> if(t) {\n<127> memcpy(t, new_pkt.data, new_pkt.size);\n<129> memset(t + new_pkt.size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n<131> new_pkt.data = t;\n<177> *pkt = new_pkt;
<1> static inline int onenand_load_main(OneNANDState *s, int sec, int secn,\n<3> void *dest)\n<11> else if (sec + secn > s->secs_cur)\n<17> memcpy(dest, s->current + (sec << 9), secn << 9);
<1> static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n<5> IscsiLun *iscsilun = bs->opaque;\n<35> if (iscsi_url == NULL) {\n<49> memset(iscsilun, 0, sizeof(IscsiLun));\n<139> task.iscsilun = iscsilun;\n<149> iscsilun->iscsi = iscsi;\n<151> iscsilun->lun   = iscsi_url->lun;\n<173> iscsi_set_events(iscsilun);\n<201> if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n<203> iscsilun->type == TYPE_TAPE) {\n<231> if (ret) {\n<239> memset(iscsilun, 0, sizeof(IscsiLun));
<1> int av_tempfile(char *prefix, char **filename) {\n<11> size_t len = strlen(prefix) + 12; /* room for "/tmp/" and "XXXXXX\0" */\n<13> *filename = av_malloc(len);\n<33> snprintf(*filename, len, "/tmp/%sXXXXXX", prefix);
<1> START_TEST(float_number)\n<39> obj = qobject_from_json(test_cases[i].encoded);\n<53> if (test_cases[i].skip == 0) {\n<61> fail_unless(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
<1> static void opt_input_file(const char *filename)\n<7> AVFormatParameters params, *ap = &params;\n<19> if (!(file_iformat = av_find_input_format(last_asked_format))) {\n<21> fprintf(stderr, "Unknown input format: '%s'\n", last_asked_format);\n<33> if (!strcmp(filename, "-"))\n<35> filename = "pipe:";\n<39> using_stdin |= !strncmp(filename, "pipe:", 5) ||\n<41> !strcmp(filename, "/dev/stdin");\n<51> print_error(filename, AVERROR(ENOMEM));\n<59> memset(ap, 0, sizeof(*ap));\n<119> err = av_open_input_file(&ic, filename, file_iformat, 0, ap);\n<123> print_error(filename, err);\n<163> if(!found){\n<165> fprintf(stderr, "Specified program id not found\n");\n<187> if (ret < 0 && verbose >= 0) {\n<189> fprintf(stderr, "%s: could not find codec parameters\n", filename);\n<215> if (ret < 0) {\n<217> fprintf(stderr, "%s: could not seek to position %0.3f\n",\n<219> filename, (double)timestamp / AV_TIME_BASE);\n<233> for(i=0;i<ic->nb_streams;i++) {\n<319> if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n<323> if (verbose >= 0)\n<325> fprintf(stderr,"\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n",\n<327> i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n<331> (float)rfps / rfps_base, rfps, rfps_base);\n<337> frame_rate.num = rfps;\n<339> frame_rate.den = rfps_base;\n<391> dump_format(ic, nb_input_files, filename, 0);
<1> void memory_region_init(MemoryRegion *mr,\n<47> memset(&mr->subregions_link, 0, sizeof mr->subregions_link);
<1> BlockDriverState *bdrv_find_backing_image(BlockDriverState *bs,\n<37> is_protocol = path_has_protocol(backing_file);\n<41> for (curr_bs = bs; curr_bs->backing_hd; curr_bs = curr_bs->backing_hd) {\n<49> if (is_protocol || path_has_protocol(curr_bs->backing_file)) {\n<51> if (strcmp(backing_file, curr_bs->backing_file) == 0) {\n<53> retval = curr_bs->backing_hd;\n<65> path_combine(filename_tmp, PATH_MAX, curr_bs->filename,\n<73> if (!realpath(filename_tmp, filename_full)) {\n<85> path_combine(filename_tmp, PATH_MAX, curr_bs->filename,\n<91> if (!realpath(filename_tmp, backing_file_full)) {\n<99> if (strcmp(backing_file_full, filename_full) == 0) {\n<101> retval = curr_bs->backing_hd;\n<113> g_free(filename_full);\n<115> g_free(backing_file_full);
<1> static void netfilter_print_info(Monitor *mon, NetFilterState *nf)\n<19> while ((prop = object_property_iter_next(&iter))) {\n<21> if (!strcmp(prop->name, "type")) {\n<27> ov = string_output_visitor_new(false);\n<29> object_property_get(OBJECT(nf), string_output_get_visitor(ov),\n<31> prop->name, NULL);\n<33> str = string_output_get_string(ov);\n<35> visit_free(string_output_get_visitor(ov));\n<37> monitor_printf(mon, ",%s=%s", prop->name, str);\n<39> g_free(str);
<1> static void read_sbr_envelope ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data , int ch ) {\n<73> memcpy ( ch_data -> env_facs [ 0 ] , ch_data -> env_facs [ ch_data -> bs_num_env ] , sizeof ( ch_data -> env_facs [ 0 ] ) ) ;
<1> static void add_flagname_to_bitmaps(const char *flagname, uint32_t *features,\n<15> if (!lookup_feature(features, flagname, NULL, feature_name) &&\n<17> !lookup_feature(ext_features, flagname, NULL, ext_feature_name) &&\n<19> !lookup_feature(ext2_features, flagname, NULL, ext2_feature_name) &&\n<21> !lookup_feature(ext3_features, flagname, NULL, ext3_feature_name) &&\n<23> !lookup_feature(kvm_features, flagname, NULL, kvm_feature_name) &&\n<25> !lookup_feature(svm_features, flagname, NULL, svm_feature_name))\n<27> fprintf(stderr, "CPU feature %s not found\n", flagname);
<1> static int xen_domain_watcher(void)\n<13> if (pipe(fd) != 0) {\n<15> qemu_log("%s: Huh? pipe error: %s\n", __FUNCTION__, strerror(errno));\n<67> if (errno == EINTR)\n<71> qemu_log("%s: Huh? read error: %s\n", __FUNCTION__, strerror(errno));
<1> rdt_parse_packet (PayloadContext *rdt, AVStream *st,\n<21> init_put_byte(&pb, buf, len, 0, NULL, NULL, NULL, NULL);\n<29> pos = url_ftell(&pb);\n<41> memcpy (rdt->buffer, buf + pos, len - pos);
<1> static bool on_accept ( private_stroke_socket_t * this , stream_t * stream ) {\n<5> if ( ! stream -> read_all ( stream , & len , sizeof ( len ) ) ) {\n<6> if ( errno != EWOULDBLOCK ) {\n<7> DBG1 ( DBG_CFG , "reading length of stroke message failed: %s" , strerror ( errno ) ) ;\n<11> msg = malloc ( len + 1 ) ;\n<12> msg -> length = len ;\n<13> if ( ! stream -> read_all ( stream , ( char * ) msg + sizeof ( len ) , len - sizeof ( len ) ) ) {\n<14> if ( errno != EWOULDBLOCK ) {\n<15> DBG1 ( DBG_CFG , "reading stroke message failed: %s" , strerror ( errno ) ) ;\n<17> free ( msg ) ;\n<20> ( ( char * ) msg ) [ len ] = '\0' ;\n<21> DBG3 ( DBG_CFG , "stroke message %b" , ( void * ) msg , len ) ;\n<23> if ( ! out ) {\n<25> free ( msg ) ;\n<29> case STR_INITIATE : stroke_initiate ( this , msg , out ) ;\n<31> case STR_ROUTE : stroke_route ( this , msg , out ) ;\n<33> case STR_UNROUTE : stroke_unroute ( this , msg , out ) ;\n<35> case STR_TERMINATE : stroke_terminate ( this , msg , out ) ;\n<37> case STR_TERMINATE_SRCIP : stroke_terminate_srcip ( this , msg , out ) ;\n<39> case STR_REKEY : stroke_rekey ( this , msg , out ) ;\n<41> case STR_STATUS : stroke_status ( this , msg , out , FALSE , TRUE ) ;\n<43> case STR_STATUS_ALL : stroke_status ( this , msg , out , TRUE , TRUE ) ;\n<45> case STR_STATUS_ALL_NOBLK : stroke_status ( this , msg , out , TRUE , FALSE ) ;\n<47> case STR_ADD_CONN : stroke_add_conn ( this , msg ) ;\n<49> case STR_DEL_CONN : stroke_del_conn ( this , msg ) ;\n<51> case STR_ADD_CA : stroke_add_ca ( this , msg , out ) ;\n<53> case STR_DEL_CA : stroke_del_ca ( this , msg , out ) ;\n<55> case STR_LOGLEVEL : stroke_loglevel ( this , msg , out ) ;\n<57> case STR_CONFIG : stroke_config ( this , msg , out ) ;\n<59> case STR_LIST : stroke_list ( this , msg , out ) ;\n<61> case STR_REREAD : stroke_reread ( this , msg , out ) ;\n<63> case STR_PURGE : stroke_purge ( this , msg , out ) ;\n<65> case STR_EXPORT : stroke_export ( this , msg , out ) ;\n<67> case STR_LEASES : stroke_leases ( this , msg , out ) ;\n<69> case STR_MEMUSAGE : stroke_memusage ( this , msg , out ) ;\n<71> case STR_USER_CREDS : stroke_user_creds ( this , msg , out ) ;\n<73> case STR_COUNTERS : stroke_counters ( this , msg , out ) ;\n<78> free ( msg ) ;
<1> static int nbd_parse_uri(const char *filename, QDict *options)\n<19> if (!uri) {\n<29> if (!strcmp(uri->scheme, "nbd")) {\n<31> is_unix = false;\n<33> } else if (!strcmp(uri->scheme, "nbd+tcp")) {\n<35> is_unix = false;\n<37> } else if (!strcmp(uri->scheme, "nbd+unix")) {\n<39> is_unix = true;\n<43> ret = -EINVAL;\n<51> p = uri->path ? uri->path : "/";\n<53> p += strspn(p, "/");\n<55> if (p[0]) {\n<57> qdict_put(options, "export", qstring_from_str(p));\n<63> qp = query_params_parse(uri->query);\n<65> if (qp->n > 1 || (is_unix && !qp->n) || (!is_unix && qp->n)) {\n<75> if (is_unix) {\n<79> if (uri->server || uri->port || strcmp(qp->p[0].name, "socket")) {\n<81> ret = -EINVAL;\n<87> qdict_put(options, "server.type", qstring_from_str("unix"));\n<91> qstring_from_str(qp->p[0].value));\n<103> if (!uri->server) {\n<115> if (uri->server[0] == '[') {\n<119> strlen(uri->server) - 2);\n<153> uri_free(uri);
<1> static int coreaudio_init_out (HWVoiceOut *hw, audsettings_t *as)\n<21> err = pthread_mutex_init(&core->mutex, NULL);\n<23> if (err) {\n<25> dolog("Could not create mutex\nReason: %s\n", strerror (err));
<17> if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))\n<29> memcpy(sbr->data[1].bs_invf_mode[1], sbr->data[1].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));\n<31> memcpy(sbr->data[1].bs_invf_mode[0], sbr->data[0].bs_invf_mode[0], sizeof(sbr->data[1].bs_invf_mode[0]));
<1> static int init_context_frame(MpegEncContext *s)\n<219> FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n<221> memset(s->mbintra_table, 1, mb_array_size);\n<227> FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size + 2, fail);\n<233> return init_er(s);
<1> static int do_execstack ( i_ctx_t * i_ctx_p , bool include_marks , os_ptr op1 ) {\n<14> switch ( r_type ( rq ) ) {\n<21> const char * tname = rq -> value . pstruct ? gs_struct_type_name_string ( gs_object_type ( imemory , rq -> value . pstruct ) ) : "NULL" ;\n<22> make_const_string ( rq , a_readonly | avm_foreign , strlen ( tname ) , ( const byte * ) tname ) ;
<1> int ff_h2645_extract_rbsp(const uint8_t *src, int length,\n<17> if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {     \\n<93> if (i > 0 && src[i - 1] == 0)\n<105> if (i >= length - 1) { // no escaped 0\n<125> if (!nal->rbsp_buffer)\n<131> dst = nal->rbsp_buffer;\n<135> memcpy(dst, src, i);\n<137> si = di = i;\n<139> while (si + 2 < length) {\n<143> if (src[si + 2] > 3) {\n<145> dst[di++] = src[si++];\n<147> dst[di++] = src[si++];\n<149> } else if (src[si] == 0 && src[si + 1] == 0 && src[si + 2] != 0) {\n<151> if (src[si + 2] == 3) { // escape\n<155> dst[di++] = 0;\n<189> nal->skipped_bytes_pos[nal->skipped_bytes-1] = di - 1;\n<203> dst[di++] = src[si++];\n<209> dst[di++] = src[si++];\n<215> memset(dst + di, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n<219> nal->data = dst;\n<223> nal->raw_data = src;
<1> build_srat(GArray *table_data, GArray *linker)\n<43> for (i = 0; i < pcms->apic_id_limit; ++i) {\n<45> core = acpi_data_push(table_data, sizeof *core);\n<57> memset(core->proximity_hi, 0, 3);
<1> static void vmxnet3_net_init(VMXNET3State *s)\n<19> memcpy(&s->perm_mac.a, &s->conf.macaddr.a, sizeof(s->perm_mac.a));\n<75> qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);
<1> static unsigned int dec_movem_mr(DisasContext *dc)\n<15> DIS(fprintf (logfile, "movem [$r%u%s, $r%u\n", dc->op1,\n<25> cris_flush_cc_state(dc);\n<33> gen_load(dc, tmp[i], addr, 8, 0);\n<43> gen_load(dc, tmp[i], addr, 4, 0);\n<83> cris_cc_mask(dc, 0);
<1> static int blk_init(struct XenDevice *xendev)\n<15> if (blkdev->params == NULL) {\n<17> blkdev->params = xenstore_read_be_str(&blkdev->xendev, "params");\n<19> h = strchr(blkdev->params, ':');\n<21> if (h != NULL) {\n<23> blkdev->fileproto = blkdev->params;\n<33> blkdev->filename  = blkdev->params;\n<39> if (blkdev->mode == NULL)\n<41> blkdev->mode = xenstore_read_be_str(&blkdev->xendev, "mode");\n<51> if (blkdev->devtype == NULL)\n<53> blkdev->devtype = xenstore_read_be_str(&blkdev->xendev, "device-type");\n<59> if (blkdev->params == NULL ||\n<61> blkdev->mode == NULL   ||\n<73> if (strcmp(blkdev->mode, "w") == 0) {\n<75> qflags = BDRV_O_RDWR;\n<79> qflags = 0;\n<81> info  |= VDISK_READONLY;\n<89> if (blkdev->devtype && !strcmp(blkdev->devtype, "cdrom"))\n<91> info  |= VDISK_CDROM;\n<143> if (blkdev->file_size < 0) {\n<145> xen_be_printf(&blkdev->xendev, 1, "bdrv_getlength: %d (%s) | drv %s\n",\n<147> (int)blkdev->file_size, strerror(-blkdev->file_size),
<1> static void process_incoming_migration_co(void *opaque)\n<29> if (ret < 0) {\n<33> error_report("load of migration failed: %s", strerror(-ret));
<1> static uint32_t vmdk_read_cid(BlockDriverState *bs, int parent)\n<17> if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n<27> cid_str = "parentCID";\n<33> cid_str = "CID";\n<41> if ((p_name = strstr(desc,cid_str)) != NULL) {\n<43> p_name += cid_str_size;\n<45> sscanf(p_name,"%x",&cid);\n<51> return cid;
<1> static int write_option(void *optctx, const OptionDef *po, const char *opt,\n<19> if (po->flags & OPT_SPEC) {\n<23> char *p = strchr(opt, ':');\n<31> (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : "");\n<51> *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n<55> *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n<59> *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n<63> *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n<67> *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n<71> int ret = po->u.func_arg(optctx, opt, arg);
<1> static void kq_dealloc ( struct event_base * base , void * arg ) {\n<2> struct kqop * kqop = arg ;\n<3> if ( kqop -> changes ) free ( kqop -> changes ) ;\n<4> if ( kqop -> events ) free ( kqop -> events ) ;\n<5> if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;\n<6> memset ( kqop , 0 , sizeof ( struct kqop ) ) ;\n<7> free ( kqop ) ;
<1> static int flic_decode_frame_8BPP(AVCodecContext *avctx,\n<9> FlicDecodeContext *s = avctx->priv_data;\n<83> pixels = s->frame.data[0];\n<111> while ((frame_size >= 6) && (num_chunks > 0)) {\n<135> switch (chunk_type) {\n<217> if (s->palette[palette_ptr] != entry)\n<221> s->palette[palette_ptr++] = entry;\n<265> pixels[pixel_ptr] = line_packets & 0xff;\n<307> pixels[pixel_ptr++] = palette_idx2;\n<321> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<397> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<411> pixels[pixel_ptr++] = palette_idx1;\n<439> s->frame.linesize[0] * s->avctx->height);\n<491> pixels[pixel_ptr++] = palette_idx1;\n<515> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<619> memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);
<1> static int mp3_header_decompress(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,\n<5> const uint8_t *buf, int buf_size, int keyframe){\n<17> header = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];\n<73> if(bitrate_index == 30){\n<93> *poutbuf= av_malloc(buf_size + 4 + FF_INPUT_BUFFER_PADDING_SIZE);\n<95> memcpy(*poutbuf + 4, buf, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> DxaDecContext * const c = avctx -> priv_data ;\n<20> c -> pal [ i ] = ( r << 16 ) | ( g << 8 ) | b ;\n<25> if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n<29> memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n<31> outptr = c -> pic . data [ 0 ] ;\n<32> srcptr = c -> decomp_buf ;\n<45> if ( c -> prev . data [ 0 ] ) memcpy ( c -> pic . data [ 0 ] , c -> prev . data [ 0 ] , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n<47> memset ( c -> pic . data [ 0 ] , 0 , c -> pic . linesize [ 0 ] * avctx -> height ) ;\n<57> if ( compr & 1 ) {\n<59> i < avctx -> width ;\n<60> i ++ ) outptr [ i ] = srcptr [ i ] ^ tmpptr [ i ] ;\n<63> else memcpy ( outptr , srcptr , avctx -> width ) ;\n<64> outptr += stride ;\n<65> srcptr += avctx -> width ;\n<70> decode_13 ( avctx , c , c -> pic . data [ 0 ] , srcptr , c -> prev . data [ 0 ] ) ;\n<76> if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;
<1> mbfl_string * mbfl_strcut ( mbfl_string * string , mbfl_string * result , int from , int length ) {\n<75> sz = end - start ;\n<76> if ( ( w = ( unsigned char * ) mbfl_calloc ( sz + 8 , sizeof ( unsigned char ) ) ) == NULL ) {\n<79> memcpy ( w , start , sz ) ;\n<81> w [ sz + 1 ] = '\0' ;\n<82> w [ sz + 2 ] = '\0' ;\n<83> w [ sz + 3 ] = '\0' ;\n<84> result -> val = w ;\n<85> result -> len = sz ;
<1> static void xen_init_pv(MachineState *machine)\n<13> if (xen_be_init() != 0) {\n<15> fprintf(stderr, "%s: xen backend core setup failed\n", __FUNCTION__);\n<23> switch (xen_mode) {\n<59> fprintf(stderr, "xen emulation not implemented (yet)\n");\n<67> fprintf(stderr, "unhandled xen_mode %d\n", xen_mode);\n<115> for (i = 0; i < nb_nics; i++) {\n<117> if (!nd_table[i].model || 0 != strcmp(nd_table[i].model, "xen"))\n<121> xen_config_dev_nic(nd_table + i);
<1> static int flac_parse(AVCodecParserContext *s, AVCodecContext *avctx,\n<185> if (buf) {\n<193> memset(pad, 0, sizeof(pad));\n<195> av_fifo_generic_write(fpc->fifo_buf, (void*) pad, sizeof(pad), NULL);
<1> int encode_function ( char * string , struct filter_op * fop ) {\n<2> char * str = strdup ( string ) ;\n<8> memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n<9> name = ec_strtok ( string , "(" , & tok ) ;\n<10> args = name + strlen ( name ) + 1 ;\n<11> dec_args = decode_args ( args , & nargs ) ;
<1> static int swf_write_video(AVFormatContext *s,\n<3> AVCodecContext *enc, const uint8_t *buf, int size)\n<31> if ( enc->codec_type == CODEC_TYPE_VIDEO ) {\n<33> SWFFrame *new_frame = av_malloc(sizeof(SWFFrame));\n<39> new_frame->data = av_malloc(size);\n<43> memcpy(new_frame->data,buf,size);\n<45> swf->frame_head = new_frame;\n<49> swf->frame_tail = new_frame;
<1> static int ac3_decode_frame(AVCodecContext * avctx, void *data,\n<7> const uint8_t *buf = avpkt->data;\n<11> AC3DecodeContext *s = avctx->priv_data;\n<17> const float *output[AC3_MAX_CHANNELS];\n<25> if (buf_size >= 2 && AV_RB16(buf) == 0x770B) {\n<35> memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));\n<37> buf = s->input_buffer;\n<47> err = parse_frame_header(s);\n<193> set_downmix_coeffs(s);\n<247> output[ch] = s->output[ch];\n<263> if (!err && decode_audio_block(s, blk)) {\n<273> for (ch = 0; ch < s->out_channels; ch++)\n<275> memcpy(((float*)s->frame.data[ch]) + AC3_BLOCK_SIZE*blk, output[ch], 1024);\n<279> output[ch] = s->outptr[channel_map[ch]];\n<297> for (ch = 0; ch < s->out_channels; ch++)\n<299> memcpy(s->output[ch], output[ch], 1024);
<1> static int omx_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<7> OMXCodecContext *s = avctx->priv_data;\n<31> buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);\n<75> buffer->pBuffer = local->data[0];\n<109> buffer->nFilledLen = av_image_fill_arrays(dst, linesize, buffer->pBuffer, avctx->pix_fmt, s->stride, s->plane_size, 1);\n<127> buffer->nOffset = 0;\n<163> if (!buffer)\n<171> if ((ret = av_reallocp(&avctx->extradata, avctx->extradata_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE)) < 0) {\n<173> avctx->extradata_size = 0;\n<179> memcpy(avctx->extradata + avctx->extradata_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);\n<181> avctx->extradata_size += buffer->nFilledLen;\n<183> memset(avctx->extradata + avctx->extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n<191> if (!(buffer->nFlags & OMX_BUFFERFLAG_ENDOFFRAME) || !pkt->data) {\n<197> int newsize = s->output_buf_size + buffer->nFilledLen + AV_INPUT_BUFFER_PADDING_SIZE;\n<199> if ((ret = av_reallocp(&s->output_buf, newsize)) < 0) {\n<201> s->output_buf_size = 0;\n<207> memcpy(s->output_buf + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);\n<209> s->output_buf_size += buffer->nFilledLen;\n<213> if ((ret = av_packet_from_data(pkt, s->output_buf, s->output_buf_size)) < 0) {\n<215> av_freep(&s->output_buf);\n<217> s->output_buf_size = 0;\n<223> s->output_buf = NULL;\n<225> s->output_buf_size = 0;\n<233> if ((ret = ff_alloc_packet2(avctx, pkt, s->output_buf_size + buffer->nFilledLen, 0)) < 0) {\n<235> av_log(avctx, AV_LOG_ERROR, "Error getting output packet of size %d.\n",\n<237> (int)(s->output_buf_size + buffer->nFilledLen));\n<243> memcpy(pkt->data, s->output_buf, s->output_buf_size);\n<245> memcpy(pkt->data + s->output_buf_size, buffer->pBuffer + buffer->nOffset, buffer->nFilledLen);\n<247> av_freep(&s->output_buf);\n<249> s->output_buf_size = 0;\n<277> err = OMX_FillThisBuffer(s->handle, buffer);\n<281> append_buffer(&s->output_mutex, &s->output_cond, &s->num_done_out_buffers, s->done_out_buffers, buffer);\n<283> av_log(avctx, AV_LOG_ERROR, "OMX_FillThisBuffer failed: %x\n", err);
<1> static void qemu_spice_create_update(SimpleSpiceDisplay *ssd)\n<19> if (qemu_spice_rect_is_empty(&ssd->dirty)) {\n<35> guest = surface_data(ssd->ds);\n<37> mirror = (void *)pixman_image_get_data(ssd->mirror);\n<39> for (y = ssd->dirty.top; y < ssd->dirty.bottom; y++) {\n<41> yoff = y * surface_stride(ssd->ds);\n<43> for (x = ssd->dirty.left; x < ssd->dirty.right; x += blksize) {\n<45> xoff = x * bpp;\n<55> bw * bpp) == 0) {\n<57> if (dirty_top[blk] != -1) {\n<71> qemu_spice_create_one_update(ssd, &update);\n<79> if (dirty_top[blk] == -1) {\n<93> for (x = ssd->dirty.left; x < ssd->dirty.right; x += blksize) {\n<113> qemu_spice_create_one_update(ssd, &update);\n<123> memset(&ssd->dirty, 0, sizeof(ssd->dirty));
<1> static int v9fs_xattr_write(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n<25> write_count = xattr_len - off;\n<59> for (i = 0; i < cnt; i++) {\n<63> to_copy = sg[i].iov_len;\n<67> to_copy = write_count;\n<71> memcpy((char *)fidp->fs.xattr.value + off, sg[i].iov_base, to_copy);\n<75> off += to_copy;\n<77> write_count -= to_copy;
<1> static int transcode(AVFormatContext **output_files,\n<25> char error[1024];\n<57> if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n<59> av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n<61> fprintf(stderr, "Output file #%d does not contain any stream\n", i);\n<73> if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n<75> fprintf(stderr, "Number of stream maps must match number of output streams\n");\n<91> int si = stream_maps[i].stream_index;\n<95> if (fi < 0 || fi > nb_input_files - 1 ||\n<97> si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n<99> fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si);\n<109> si = stream_maps[i].sync_stream_index;\n<111> if (fi < 0 || fi > nb_input_files - 1 ||\n<113> si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n<115> fprintf(stderr,"Could not find sync stream #%d.%d\n", fi, si);\n<217> ost = ost_table[n] = output_streams_for_file[k][i];\n<229> if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {\n<231> int i= ost->file_index;\n<235> fprintf(stderr, "Codec type mismatch for mapping #%d.%d -> #%d.%d\n",\n<327> if (!found) {\n<329> int i= ost->file_index;\n<333> fprintf(stderr, "Could not find input stream matching output stream #%d.%d\n",\n<373> codec = ost->st->codec;\n<375> icodec = ist->st->codec;\n<397> uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n<437> if (!codec->extradata)\n<441> memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n<443> codec->extradata_size= icodec->extradata_size;\n<463> if(audio_volume != 256) {\n<465> fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");\n<613> if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n<615> fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");\n<729> f = fopen(logfilename, "wb");\n<731> if (!f) {\n<733> fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));\n<747> if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n<749> fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);\n<769> bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n<779> bit_buffer = av_malloc(bit_buffer_size);\n<781> if (!bit_buffer) {\n<783> fprintf(stderr, "Cannot allocate %d bytes output buffer\n",\n<805> AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n<807> if (!codec) {\n<809> snprintf(error, sizeof(error), "Encoder (codec id %d) not found for output stream #%d.%d",\n<821> ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n<823> if (!ost->st->codec->subtitle_header) {\n<831> memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<833> ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n<837> if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n<839> snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",\n<849> assert_codec_experimental(ost->st->codec, 1);\n<877> if (!codec)\n<881> if (!codec) {\n<883> snprintf(error, sizeof(error), "Decoder (codec id %d) not found for input stream #%d.%d",\n<893> if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {\n<895> snprintf(error, sizeof(error), "Error while opening decoder for input stream #%d.%d",\n<955> snprintf(error, sizeof(error), "Invalid %s index %d while processing metadata maps\n",\\n<1069> snprintf(error, sizeof(error), "Invalid input file index %d in chapter mapping.\n", infile);\n<1079> snprintf(error, sizeof(error), "Invalid output file index %d in chapter mapping.\n",outfile);\n<1123> if (avformat_write_header(os, &output_opts[i]) < 0) {\n<1125> snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);\n<1135> if (strcmp(output_files[i]->oformat->name, "rtp")) {\n<1137> want_sdp = 0;\n<1161> if (verbose >= 0) {\n<1163> fprintf(stderr, "Stream mapping:\n");\n<1165> for(i=0;i<nb_ostreams;i++) {\n<1167> ost = ost_table[i];\n<1179> if (ost->sync_ist != &input_streams[ost->source_index])\n<1187> fprintf(stderr, "\n");\n<1195> if (ret) {\n<1197> fprintf(stderr, "%s\n", error);\n<1215> if(verbose >= 0)\n<1217> fprintf(stderr, "Press [q] to stop, [?] for help\n");\n<1289> if (key == 'd' || key == 'D'){\n<1291> int debug=0;\n<1293> if(key == 'D') {\n<1297> if(!debug) debug = 1;\n<1299> while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n<1301> debug += debug;\n<1305> scanf("%d", &debug);\n<1309> input_streams[i].st->codec->debug = debug;\n<1317> ost->st->codec->debug = debug;\n<1323> fprintf(stderr,"debug=%d\n", debug);\n<1327> if (key == '?'){\n<1367> ist = &input_streams[ost->source_index];\n<1369> if(ist->is_past_recording_time || no_packet[ist->file_index])\n<1383> if(input_sync ) file_index = ist->file_index;\n<1391> if(!input_sync) file_index = ist->file_index;\n<1411> if(no_packet_count){\n<1415> memset(no_packet, 0, sizeof(no_packet));\n<1445> no_packet[file_index]=1;\n<1453> if (ret < 0) {\n<1471> memset(no_packet, 0, sizeof(no_packet));\n<1581> if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n<1585> if (verbose >= 0)\n<1587> fprintf(stderr, "Error while decoding stream #%d.%d\n",\n<1625> output_packet(ist, i, ost_table, nb_ostreams, NULL);\n<1665> avcodec_close(ost->st->codec);\n<1731> av_freep(&ost->st->codec->subtitle_header);\n<1751> av_free(ost);
<1> static int proxy_init(FsContext *ctx)\n<19> if (sock_id < 0) {\n<21> fprintf(stderr, "socket descriptor not initialized\n");
<1> void kvm_setup_guest_memory(void *start, size_t size)\n<17> if (ret) {
<1> uint8_t sd_read_data(SDState *sd)\n<19> if (sd->state != sd_sendingdata_state) {\n<21> fprintf(stderr, "sd_read_data: not in Sending-Data state\n");\n<39> switch (sd->current_cmd) {\n<225> fprintf(stderr, "sd_read_data: unknown command\n");
<1> void ff_h264_direct_ref_list_init ( H264Context * const h ) {\n<15> if ( h -> picture_structure == PICT_FRAME ) {\n<16> memcpy ( cur -> ref_count [ 1 ] , cur -> ref_count [ 0 ] , sizeof ( cur -> ref_count [ 0 ] ) ) ;\n<17> memcpy ( cur -> ref_poc [ 1 ] , cur -> ref_poc [ 0 ] , sizeof ( cur -> ref_poc [ 0 ] ) ) ;
<1> static void do_video_out(AVFormatContext *s,\n<141> fprintf(stderr, "pixel format conversion not handled\n");
<1> static int ra288_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<18> out = ( float * ) frame -> data [ 0 ] ;\n<21> i < RA288_BLOCKS_PER_FRAME ;\n<26> memcpy ( out , & ractx -> sp_hist [ 70 + 36 ] , RA288_BLOCK_SIZE * sizeof ( * out ) ) ;\n<27> out += RA288_BLOCK_SIZE ;\n<29> backward_filter ( ractx , ractx -> sp_hist , ractx -> sp_rec , syn_window , ractx -> sp_lpc , syn_bw_tab , 36 , 40 , 35 , 70 ) ;
<1> static int avi_read_header(AVFormatContext *s, AVFormatParameters *ap)\n<63> switch(tag) {\n<129> st = av_new_stream(s, i);\n<203> avi->dv_demux = dv_init_demux(s);\n<341> av_log(s, AV_LOG_ERROR, "unknown stream type %X\n", tag1);\n<399> get_buffer(pb, st->codec->extradata, st->codec->extradata_size);\n<417> if (st->codec->extradata_size && (st->codec->bits_per_sample <= 8)) {\n<429> memcpy(st->codec->palctrl->palette, st->codec->extradata,\n<431> FFMIN(st->codec->extradata_size, AVPALETTE_SIZE));\n<465> get_wav_header(pb, st->codec, size);\n<469> av_log(s, AV_LOG_DEBUG, "invalid sample size or block align detected\n");\n<521> read_braindead_odml_indx(s, 0);\n<567> avi_read_tag(pb, str_track, sizeof(str_track), size);\n<569> sscanf(str_track, "%d", &s->track);\n<611> avi_load_index(s);\n<615> avi->non_interleaved |= guess_ni_flag(s);\n<619> clean_index(s);
<11> av_cold void swri_rematrix_init_x86(struct SwrContext *s){\n<79> } else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){\n<97> s->native_simd_matrix = av_mallocz(num * sizeof(float));\n<99> memcpy(s->native_simd_matrix, s->native_matrix, num * sizeof(float));\n<101> s->native_simd_one = av_mallocz(sizeof(float));\n<103> memcpy(s->native_simd_one, s->native_one, sizeof(float));
<1> static int fbdev_write_packet(AVFormatContext *h, AVPacket *pkt)\n<63> bytes_to_copy = FFMIN(fbdev->varinfo.xres, video_width) * bytes_per_pixel;\n<67> pin  = pkt->data;\n<85> bytes_to_copy += fbdev->xoffset * bytes_per_pixel;\n<87> pin -= fbdev->xoffset * bytes_per_pixel;\n<99> bytes_to_copy -= diff * bytes_per_pixel;\n<103> pout += bytes_per_pixel * fbdev->xoffset;\n<121> pin -= fbdev->yoffset * src_line_size;\n<137> pout += fbdev->yoffset * fbdev->fixinfo.line_length;\n<145> for (i = 0; i < disp_height; i++) {\n<147> memcpy(pout, pin, bytes_to_copy);\n<149> pout += fbdev->fixinfo.line_length;\n<151> pin  += src_line_size;
<1> static void nic_selective_reset(EEPRO100State * s)\n<7> uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);\n<11> memcpy(eeprom_contents, s->conf.macaddr.a, 6);\n<23> sum += eeprom_contents[i];\n<29> TRACE(EEPROM, logout("checksum=0x%04x\n", eeprom_contents[EEPROM_SIZE - 1]));\n<33> memset(s->mem, 0, sizeof(s->mem));\n<35> uint32_t val = BIT(21);\n<37> memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));\n<43> memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));
<1> av_cold int ff_mdct_init(FFTContext *s, int nbits, int inverse, double scale)\n<13> memset(s, 0, sizeof(*s));\n<27> if (ff_fft_init(s, s->mdct_bits - 2, inverse) < 0)
<1> unsigned long setup_arg_pages(void * mh, char ** argv, char ** env)\n<159> for(i = envc-1; i >= 0; i--)\n<163> DPRINTF("pushing env %s (0x%x)\n", (char*)env[i], (int)env[i]);\n<165> stl(stack, (int)env[i]);\n<173> page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID);\n<181> if(interp_prefix[0])\n<187> asprintf(&dyld_root, "DYLD_ROOT_PATH=%s", interp_prefix);\n<189> page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID);\n<193> stl(stack, (int)dyld_root);\n<271> for(i = argc-1; i >= 0; i--)\n<275> DPRINTF("pushing arg %s (0x%x)\n", (char*)argv[i], (int)argv[i]);\n<277> stl(stack, (int) argv[i]);\n<285> page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID);
<1> bool desc_ring_set_size(DescRing *ring, uint32_t size)\n<41> if (!ring->info) {\n<49> memset(ring->info, 0, size * sizeof(DescInfo));\n<55> ring->info[i].ring = ring;
<1> static void draw_mandelbrot(AVFilterContext *ctx, uint32_t *color, int linesize, int64_t pts)\n<15> for(y=0; y<mb->h; y++){\n<19> memset(color+linesize*y, 0, sizeof(*color)*mb->w);\n<45> if(color[x + y*linesize] & 0xFF000000)\n<51> use_zyklus= (x==0 || mb->inner!=BLACK ||color[x-1 + y*linesize] == 0xFF000000);\n<203> color[x + y*linesize]= c;
<1> static int usb_bt_handle_control(USBDevice *dev, int request, int value,\n<13> ret = usb_desc_handle_control(dev, request, value, index, length, data);\n<97> if (value != 1 && value != 0) {\n<99> printf("%s: Wrong SET_CONFIGURATION request (%i)\n",\n<137> if ((index & ~1) || length != 0 ||\n<139> (index == 1 && (value < 0 || value > 4)) ||\n<141> (index == 0 && value != 0)) {\n<143> printf("%s: Wrong SET_INTERFACE request (%i, %i)\n",
<1> static int tpm_passthrough_handle_device_opts(QemuOpts *opts, TPMBackend *tb)\n<37> if (tpm_pt->tpm_fd < 0) {\n<39> error_report("Cannot access TPM device using '%s': %s",\n<41> tpm_pt->tpm_dev, strerror(errno));
<1> static void generate_bootsect(target_phys_addr_t option_rom,\n<15> memset(rom, 0, sizeof(rom));\n<19> p = rom;\n<75> *reloc = (p - rom);
<1> static void internal_snapshot_prepare(BlkActionState *common,\n<45> name = internal->name;\n<117> if (!bdrv_can_snapshot(bs)) {\n<131> if (!strlen(name)) {\n<133> error_setg(errp, "Name is empty");\n<135> return;\n<143> ret = bdrv_snapshot_find_by_id_and_name(bs, NULL, name, &old_sn,\n<145> &local_err);\n<147> if (local_err) {
<1> static int v9fs_receive_response(V9fsProxy *proxy, int type,\n<3> int *status, void *response)\n<99> switch (type) {\n<177> v9fs_string_init(&xattr);\n<181> memcpy(response, xattr.data, xattr.size);\n<183> v9fs_string_free(&xattr);
<1> static int decode_frame(AVCodecContext * avctx,\n<9> MPADecodeContext *s = avctx->priv_data;\n<23> buf_ptr = buf;\n<27> len = s->inbuf_ptr - s->inbuf;\n<37> s->inbuf[0] = s->free_format_next_header >> 24;\n<39> s->inbuf[1] = s->free_format_next_header >> 16;\n<41> s->inbuf[2] = s->free_format_next_header >> 8;\n<43> s->inbuf[3] = s->free_format_next_header;\n<63> if (len > 0) {\n<65> memcpy(s->inbuf_ptr, buf_ptr, len);\n<67> buf_ptr += len;\n<69> buf_size -= len;\n<71> s->inbuf_ptr += len;\n<75> if ((s->inbuf_ptr - s->inbuf) >= HEADER_SIZE) {\n<79> header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n<81> (s->inbuf[2] << 8) | s->inbuf[3];\n<85> if (check_header(header) < 0) {\n<89> memcpy(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n<103> if (decode_header(s, header) == 1) {\n<109> memcpy(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n<141> if (len == 0) {\n<157> memcpy(s->inbuf_ptr, buf_ptr, len);\n<161> p = s->inbuf_ptr - 3;\n<163> pend = s->inbuf_ptr + len - 4;\n<187> buf_ptr += len;\n<225> buf_ptr += len;\n<227> s->inbuf_ptr += len;\n<229> buf_size -= len;\n<233> } else if (len < s->frame_size) {\n<243> len = buf_size;\n<245> else if (len < 4)\n<247> len = buf_size > 4 ? 4 : buf_size;\n<249> memcpy(s->inbuf_ptr, buf_ptr, len);\n<251> buf_ptr += len;\n<253> s->inbuf_ptr += len;\n<255> buf_size -= len;
<1> static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)\n<5> struct vmsvga_state_s *s = opaque;\n<73> if (value != s->depth) {\n<75> printf("%s: Bad colour depth: %i bits\n", __FUNCTION__, value);\n<207> if (s->index >= SVGA_SCRATCH_BASE &&\n<209> s->index < SVGA_SCRATCH_BASE + s->scratch_size) {\n<217> printf("%s: Bad register %02x\n", __FUNCTION__, s->index);
<1> static void init_ppc_proc(PowerPCCPU *cpu)\n<101> switch (env->flags & (POWERPC_FLAG_SPE | POWERPC_FLAG_VRE)) {\n<111> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<119> } else if (env->flags & (POWERPC_FLAG_SPE | POWERPC_FLAG_VRE)) {\n<121> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<131> switch (env->flags & (POWERPC_FLAG_TGPR | POWERPC_FLAG_CE)) {\n<141> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<149> } else if (env->flags & (POWERPC_FLAG_TGPR | POWERPC_FLAG_CE)) {\n<151> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<161> switch (env->flags & (POWERPC_FLAG_SE | POWERPC_FLAG_DWE |\n<175> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<185> } else if (env->flags & (POWERPC_FLAG_SE | POWERPC_FLAG_DWE |\n<189> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<201> switch (env->flags & (POWERPC_FLAG_BE | POWERPC_FLAG_DE)) {\n<211> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<219> } else if (env->flags & (POWERPC_FLAG_BE | POWERPC_FLAG_DE)) {\n<221> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<231> switch (env->flags & (POWERPC_FLAG_PX | POWERPC_FLAG_PMM)) {\n<241> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<249> } else if (env->flags & (POWERPC_FLAG_PX | POWERPC_FLAG_PMM)) {\n<251> fprintf(stderr, "PowerPC MSR definition inconsistency\n"\n<259> if ((env->flags & (POWERPC_FLAG_RTC_CLK | POWERPC_FLAG_BUS_CLK)) == 0) {\n<261> fprintf(stderr, "PowerPC flags inconsistency\n"\n<309> if (env->irq_inputs == NULL) {\n<311> fprintf(stderr, "WARNING: no internal IRQ controller registered.\n"\n<319> if (env->check_pow == NULL) {\n<321> fprintf(stderr, "WARNING: no power management check handler "
<1> static int init_directories(BDRVVVFATState* s,\n<19> memset(&(s->first_sectors[0]),0,0x40*0x200);\n<59> direntry_t* entry=array_get_next(&(s->directory));\n<63> memcpy(entry->name, "QEMU VVFAT ", sizeof(entry->name));\n<81> mapping = array_get_next(&(s->mapping));\n<91> mapping->path = g_strdup(dirname);\n<93> i = strlen(mapping->path);\n<95> if (i > 0 && mapping->path[i - 1] == '/')\n<103> s->path = mapping->path;\n<107> for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n<127> error_setg(errp, "Could not read directory %s",\n<231> bootsector=(bootsector_t*)(s->first_sectors+(s->first_sectors_number-1)*0x200);\n<239> memcpy(bootsector->name,"QEMU    ",8);\n<281> memcpy(bootsector->u.fat16.volume_label,"QEMU VVFAT ",11);\n<283> memcpy(bootsector->fat_type,(s->fat_type==12?"FAT12   ":s->fat_type==16?"FAT16   ":"FAT32   "),8);
<1> static int kvm_s390_store_adtl_status(S390CPU *cpu, hwaddr addr)\n<13> if (!mem) {\n<19> if (len != ADTL_SAVE_AREA_SIZE) {\n<29> memcpy(mem, &cpu->env.vregs, 512);\n<33> cpu_physical_memory_unmap(mem, len, 1, len);
<3> AVPacket *pkt, const AVFrame *frame, int *got_packet)\n<91> if (pkt->size < new_pkt.size) {\n<105> memcpy(pkt->data, new_pkt.data, new_pkt.size);\n<107> pkt->size = new_pkt.size;\n<111> ret = av_packet_copy_props(pkt, &new_pkt);\n<113> av_packet_unref(&new_pkt);
<1> int qemu_read_password(char *buf, int buf_size)\n<11> printf("password: ");\n<65> printf("\n");
<1> static void ioport_write(void *opaque, target_phys_addr_t addr,\n<9> uint32_t io_port = addr;\n<161> switch (io_port) {\n<395> fprintf(stderr, "%s: ioport=0x%x, abort()\n", __FUNCTION__, io_port);
<1> static void flush_encoders(OutputStream *ost_table, int nb_ostreams)\n<11> OutputStream   *ost = &ost_table[i];\n<85> ret = avcodec_encode_audio(enc, bit_buffer, bit_buffer_size, (short *)audio_buf);\n<97> ret = avcodec_encode_audio(enc, bit_buffer, bit_buffer_size, NULL);\n<117> ret = avcodec_encode_video(enc, bit_buffer, bit_buffer_size, NULL);\n<133> if (ost->logfile && enc->stats_out) {\n<135> fprintf(ost->logfile, "%s", enc->stats_out);
<1> __org_qemu_x_Union1 *qmp___org_qemu_x_command(__org_qemu_x_EnumList *a,\n<19> ret->__org_qemu_x_branch = strdup("blah1");\n<23> return ret;
<1> enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) {\n<15> if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n<16> snprintf ( buf1 , sizeof ( buf1 ) , "imap@%s" , idata -> conn -> account . host ) ;\n<18> request_buf . length = strlen ( buf1 ) ;\n<19> maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ;\n<21> mutt_debug ( 2 , "Couldn't get service name for [%s]\n" , buf1 ) ;\n<25> gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ;\n<26> mutt_debug ( 2 , "Using service name [%s]\n" , ( char * ) request_buf . value ) ;\n<27> gss_release_buffer ( & min_stat , & request_buf ) ;\n<43> mutt_debug ( 2 , "Invalid response from server: %s\n" , buf1 ) ;\n<51> mutt_socket_send ( idata -> conn , buf1 ) ;\n<62> sec_token = & request_buf ;\n<73> mutt_socket_send ( idata -> conn , buf1 ) ;\n<84> maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ;\n<93> if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) {\n<103> buf_size = htonl ( buf_size ) ;\n<104> memcpy ( buf1 , & buf_size , 4 ) ;\n<105> buf1 [ 0 ] = GSS_AUTH_P_NONE ;\n<106> strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ;\n<108> request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ;\n<109> maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ;\n<115> mutt_debug ( 2 , "Requesting authorisation as %s\n" , idata -> conn -> account . user ) ;
<1> static int iscsi_create(const char *filename, QEMUOptionParameter *options,\n<25> while (options && options->name) {\n<27> if (!strcmp(options->name, "size")) {\n<29> total_size = options->value.n / BDRV_SECTOR_SIZE;\n<33> options++;
<1> create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern)\n<5> size_t *sizes = calloc(nr_iov, sizeof(size_t));\n<25> len = cvtnum(arg);\n<27> if (len < 0) {\n<29> printf("non-numeric length argument -- %s\n", arg);\n<39> if (len > INT_MAX) {\n<41> printf("too large length argument -- %s\n", arg);\n<61> sizes[i] = len;\n<79> qemu_iovec_add(qiov, p, sizes[i]);\n<81> p += sizes[i];\n<89> free(sizes);
<1> static void sdp_parse_fmtp_config(AVCodecContext * codec, void *ctx,\n<3> char *attr, char *value)\n<7> switch (codec->codec_id) {\n<13> if (!strcmp(attr, "config")) {\n<17> int len = hex_to_data(NULL, value);\n<19> if (codec->extradata)\n<23> codec->extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);\n<25> if (!codec->extradata)\n<49> return;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> VBDecContext * const c = avctx -> priv_data ;\n<11> if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n<19> offset = i + j * avctx -> width ;\n<23> vb_decode_framedata ( c , offset ) ;\n<28> vb_decode_palette ( c , size ) ;\n<30> memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n<32> outptr = c -> pic . data [ 0 ] ;\n<33> srcptr = c -> frame ;\n<35> i < avctx -> height ;\n<37> memcpy ( outptr , srcptr , avctx -> width ) ;\n<38> srcptr += avctx -> width ;\n<39> outptr += c -> pic . linesize [ 0 ] ;
<1> static void gen_compute_branch(DisasContext *ctx, uint32_t opc, int r1,\n<13> switch (opc) {\n<467> printf("Branch Error at %x\n", ctx->pc);
<1> static void kvm_set_phys_mem(target_phys_addr_t start_addr,\n<73> if (err) {\n<75> fprintf(stderr, "%s: error unregistering overlapping slot: %s\n",\n<77> __func__, strerror(-err));\n<121> if (err) {\n<123> fprintf(stderr, "%s: error updating slot: %s\n", __func__,\n<125> strerror(-err));\n<163> if (err) {\n<165> fprintf(stderr, "%s: error registering prefix slot: %s\n",\n<167> __func__, strerror(-err));\n<201> if (err) {\n<203> fprintf(stderr, "%s: error registering suffix slot: %s\n",\n<205> __func__, strerror(-err));\n<247> if (err) {\n<249> fprintf(stderr, "%s: error registering slot: %s\n", __func__,\n<251> strerror(-err));
<1> static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) {\n<25> uint8_t block = gifgetbyte ( grr ) ;\n<56> default : if ( ! unknown_block_type ) {\n<57> char buf [ 256 ] ;\n<58> sprintf ( buf , "unknown block type %d at file offset %u" , block , grr -> pos - 1 ) ;\n<59> gif_read_error ( & gfc , 1 , buf ) ;
<1> static void do_commit(Monitor *mon, const QDict *qdict)\n<9> const char *device = qdict_get_str(qdict, "device");\n<13> all_devices = !strcmp(device, "all");\n<17> if (!all_devices)\n<19> if (strcmp(bdrv_get_device_name(dinfo->bdrv), device))
<1> static int decode_slice_header(FFV1Context *f, FFV1Context *fs)\n<11> memset(state, 128, sizeof(state));\n<29> fs->slice_x      = get_symbol(c, state, 0) * f->width;\n<63> PlaneContext *const p = &fs->plane[i];\n<67> if (idx > (unsigned)f->quant_table_count) {\n<77> memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));
<1> static xsltAttrVTPtr xsltSetAttrVTsegment ( xsltAttrVTPtr avt , void * val ) {\n<4> if ( avt == NULL ) {\n<7> memset ( & avt -> segments [ avt -> nb_seg ] , 0 , MAX_AVT_SEG * sizeof ( void * ) ) ;
<1> bool error_is_type(Error *err, const char *fmt)\n<13> if (!err) {\n<21> ptr = strstr(fmt, "'class': '");\n<23> assert(ptr != NULL);\n<25> ptr += strlen("'class': '");\n<29> end = strchr(ptr, '\'');\n<31> assert(end != NULL);\n<35> error_class = error_get_field(err, "class");\n<37> if (strlen(error_class) != end - ptr) {\n<39> return false;\n<45> return strncmp(ptr, error_class, end - ptr) == 0;
<1> QEMUFile *qemu_fopen(const char *filename, const char *mode)\n<11> if (!f)\n<15> if (!strcmp(mode, "wb")) {\n<17> f->is_writable = 1;\n<19> } else if (!strcmp(mode, "rb")) {\n<21> f->is_writable = 0;\n<29> f->outfile = fopen(filename, mode);\n<31> if (!f->outfile)\n<41> if (f->outfile)\n<45> qemu_free(f);\n<47> return NULL;
<1> static void lm32_evr_init(QEMUMachineInitArgs *args)\n<137> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<157> if (kernel_size < 0) {\n<159> fprintf(stderr, "qemu: could not load kernel '%s'\n",
<1> static void m68k_cpu_reset(CPUState *s)\n<9> CPUM68KState *env = &cpu->env;\n<17> memset(env, 0, offsetof(CPUM68KState, end_reset_fields));\n<25> m68k_switch_sp(env);
<1> static int proxy_lsetxattr(FsContext *ctx, V9fsPath *fs_path, const char *name,\n<3> void *value, size_t size, int flags)\n<23> xvalue.data = g_malloc(size);\n<25> memcpy(xvalue.data, value, size);\n<29> retval = v9fs_request(ctx->private, T_LSETXATTR, value, "sssdd",\n<35> v9fs_string_free(&xvalue);
<1> int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<17> if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n<19> memcpy(buf, bs->boot_sector_data, 512);\n<25> buf += 512;\n<39> ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n<61> return drv->bdrv_read(bs, sector_num, buf, nb_sectors);
<1> create_iovec(BlockBackend *blk, QEMUIOVector *qiov, char **argv, int nr_iov,\n<27> len = cvtnum(arg);\n<41> if (len > INT_MAX) {\n<43> printf("Argument '%s' exceeds maximum size %d\n", arg, INT_MAX);
<45> a->ch[i]= a->data + i*(a->planar ? countb : a->bps);\n<47> if(a->planar) memcpy(a->ch[i], old.ch[i], a->count*a->bps);\n<51> if(!a->planar) memcpy(a->ch[0], old.ch[0], a->count*a->ch_count*a->bps);
<1> static int yuv4_read_header(AVFormatContext *s)\n<5> char header[MAX_YUV4_HEADER + 10];  // Include headroom for\n<15> int width = -1, height  = -1, raten   = 0,\n<17> rated =  0, aspectn =  0, aspectd = 0;\n<33> if (header[i] == '\n') {\n<35> header[i + 1] = 0x20;  // Add a space after last option.\n<39> header[i + 2] = 0;\n<47> if (i == MAX_YUV4_HEADER)\n<51> if (strncmp(header, Y4M_MAGIC, strlen(Y4M_MAGIC)))\n<53> return -1;\n<57> header_end = &header[i + 1]; // Include space\n<59> for (tokstart = &header[strlen(Y4M_MAGIC) + 1];\n<61> tokstart < header_end; tokstart++) {\n<63> if (*tokstart == 0x20)\n<67> switch (*tokstart++) {\n<199> sscanf(tokstart, "%d:%d", &raten, &rated); // 0:0 if unknown\n<201> while (tokstart < header_end && *tokstart != 0x20)\n<209> sscanf(tokstart, "%d:%d", &aspectn, &aspectd); // 0:0 if unknown\n<211> while (tokstart < header_end && *tokstart != 0x20)\n<287> if (raten <= 0 || rated <= 0) {\n<299> if (aspectn == 0 && aspectd == 0) {\n<319> av_reduce(&raten, &rated, raten, rated, (1UL << 31) - 1);\n<331> st->sample_aspect_ratio           = (AVRational){ aspectn, aspectd };
<1> static int vmdk_parent_open(BlockDriverState *bs)\n<13> desc[DESC_SIZE] = '\0';\n<15> if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n<23> if ((p_name = strstr(desc,"parentFileNameHint")) != NULL) {\n<29> p_name += sizeof("parentFileNameHint") + 1;\n<31> if ((end_name = strchr(p_name,'\"')) == NULL)\n<33> return -1;\n<35> if ((end_name - p_name) > sizeof (bs->backing_file) - 1)\n<47> return 0;
<1> int av_opencl_create_kernel(AVOpenCLKernelEnv *env, const char *kernel_name)\n<11> if (strlen(kernel_name) + 1 > AV_OPENCL_MAX_KERNEL_NAME_SIZE) {\n<13> av_log(&openclutils, AV_LOG_ERROR, "Created kernel name %s is too long\n", kernel_name);\n<15> ret = AVERROR(EINVAL);\n<21> if (!env->kernel) {\n<39> env->kernel = clCreateKernel(gpu_env.programs[i], kernel_name, &status);\n<61> av_strlcpy(env->kernel_name, kernel_name, sizeof(env->kernel_name));
<1> static UserDefNested *nested_struct_create(void)\n<7> udnp->string0 = strdup("test_string0");\n<9> udnp->dict1.string1 = strdup("test_string1");\n<17> udnp->dict1.dict2.userdef1->string = strdup("test_string");\n<19> udnp->dict1.dict2.string2 = strdup("test_string2");\n<29> udnp->dict1.dict3.userdef2->string = strdup("test_string");\n<31> udnp->dict1.dict3.string3 = strdup("test_string3");\n<33> return udnp;
<1> static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n<17> if (!s || !s->orig_buf)\n<23> if (s->buf_off >= s->buf_len) {\n<31> realsize = MIN(realsize, s->buf_len - s->buf_off);\n<33> memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n<35> s->buf_off += realsize;\n<71> return realsize;
<1> static int load_input_picture(MpegEncContext *s, const AVFrame *pic_arg)\n<191> int w = s->width  >> h_shift;\n<195> uint8_t *src = pic_arg->data[i];\n<197> uint8_t *dst = pic->f.data[i];\n<211> dst += INPLACE_OFFSET;\n<215> if (src_stride == dst_stride)\n<217> memcpy(dst, src, src_stride * h);\n<223> uint8_t *dst2 = dst;\n<225> while (h2--) {\n<227> memcpy(dst2, src, w);\n<229> dst2 += dst_stride;\n<231> src += src_stride;
<1> size_t iov_memset(const struct iovec *iov, const unsigned int iov_cnt,\n<3> size_t iov_off, int fillc, size_t size)\n<19> if (iov_off < (iovec_off + iov[i].iov_len)) {\n<21> size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off , size);\n<25> memset(iov[i].iov_base + (iov_off - iovec_off), fillc, len);\n<29> buf_off += len;\n<31> iov_off += len;\n<33> size -= len;
<1> static int dirac_decode_data_unit(AVCodecContext *avctx, const uint8_t *buf, int size)\n<61> if (buf[13] == 1) {     /* encoder implementation/version */\n<63> int ver[3];\n<69> if (sscanf(buf+14, "Schroedinger %d.%d.%d", ver, ver+1, ver+2) == 3)\n<71> if (ver[0] == 1 && ver[1] == 0 && ver[2] <= 7)
<1> static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n<15> memset(output[2], 0, sizeof(output[2]));\n<17> memset(output[3], 0, sizeof(output[3]));\n<19> memset(output[4], 0, sizeof(output[4]));
<1> static int usb_linux_update_endp_table(USBHostDevice *s)\n<25> if (s->configuration == 0) {\n<49> descriptors[i + 5] != s->configuration) {\n<51> fprintf(stderr, "invalid descriptor data - configuration %d\n",\n<133> if (ep == 0) {\n<135> fprintf(stderr, "usb-linux: invalid ep descriptor, ep == 0\n");
<1> int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)\n<15> if (s->read_packet && s->write_flag) {\n<29> len = s->buf_end - s->buf_ptr;\n<47> fill_buffer(s);\n<49> len = s->buf_end - s->buf_ptr;\n<53> if (len > size)\n<55> len = size;\n<57> memcpy(buf, s->buf_ptr, len);\n<59> s->buf_ptr += len;\n<61> if (!len) {
<1> static int video_open(VideoState *is){\n<53> if (!screen) {\n<55> fprintf(stderr, "SDL: could not set video mode - exiting\n");
<1> static void omap_mcbsp_writew(void *opaque, hwaddr addr,\n<19> if (s->tx_req > 3) {\n<49> printf("%s: Tx FIFO overrun\n", __FUNCTION__);
<1> tight_detect_smooth_image24(VncState *vs, int w, int h)\n<35> memset(stats, 0, sizeof (stats));\n<57> stats[abs(pix - left[c])]++;\n<89> if (stats[0] * 33 / pixels >= 95) {\n<101> errors += stats[c] * (c * c);\n<103> if (stats[c] == 0 || stats[c] > stats[c-1] * 2) {\n<113> errors += stats[c] * (c * c);\n<117> errors /= (pixels * 3 - stats[0]);
<1> static void colored_fputs(int level, int tint, const char *str)\n<5> if (!*str)\n<31> if (use_color == 1 && level != AV_LOG_INFO/8) {\n<37> (color[level] >> 4) & 15,\n<39> color[level] & 15,\n<43> } else if (tint && use_color == 256) {\n<49> (color[level] >> 16) & 0xff,\n<55> } else if (use_color == 256 && level != AV_LOG_INFO/8) {\n<61> (color[level] >> 16) & 0xff,\n<63> (color[level] >> 8) & 0xff,
<1> static KVMSlot *kvm_alloc_slot(KVMState *s)\n<9> for (i = 0; i < ARRAY_SIZE(s->slots); i++) {\n<25> fprintf(stderr, "%s: no free slot available\n", __func__);
<1> int kqemu_cpu_exec(CPUState *env)\n<31> LOG_INT_STATE(env);\n<45> kqemu_load_seg(&kenv->ldt, &env->ldt);\n<113> kenv->user_only = (env->kqemu_enabled == 1);\n<163> if (env->cpuid_features & CPUID_FXSR)\n<177> env->eip = kenv->eip;\n<179> env->eflags = kenv->eflags;\n<185> cpu_x86_set_cpl(env, kenv->cpl);\n<211> tlb_flush(env, 1);\n<217> tlb_flush_page(env, pages_to_flush[i]);\n<239> cpu_tlb_update_dirty(env);\n<295> (env->eflags & VM_MASK) ||\n<341> env->hflags |= HF_OSFXSR_MASK;\n<345> env->hflags &= ~HF_OSFXSR_MASK;\n<417> } else if (ret == KQEMU_RET_SOFTMMU) {\n<437> cpu_dump_state(env, stderr, fprintf, 0);\n<439> fprintf(stderr, "Unsupported return value: 0x%x\n", ret);
<1> static void input_linux_event_keyboard(void *opaque)\n<19> if (rc < 0 && errno != EAGAIN) {\n<21> fprintf(stderr, "%s: read: %s\n", __func__, strerror(errno));
<1> static void aio_read_done(void *opaque, int ret)\n<5> struct aio_ctx *ctx = opaque;\n<15> if (ret < 0) {\n<17> printf("readv failed: %s\n", strerror(-ret));\n<25> if (ctx->Pflag) {\n<27> void *cmp_buf = malloc(ctx->qiov.size);\n<31> memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n<33> if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n<41> free(cmp_buf);\n<57> dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n<65> t2 = tsub(t2, ctx->t1);\n<67> print_report("read", &t2, ctx->offset, ctx->qiov.size,\n<73> qemu_io_free(ctx->buf);\n<75> free(ctx);
<1> static int vpc_open(BlockDriverState *bs, QDict *options, int flags,\n<87> if (vpc_checksum(s->footer_buf, HEADER_SIZE) != checksum)\n<89> fprintf(stderr, "block-vpc: The header checksum of '%s' is "
<1> tcp_input(struct mbuf *m, int iphlen, struct socket *inso)\n<49> if (m == NULL) {\n<131> memset(&ti->ti_i.ih_mbuf, 0 , sizeof(struct mbuf_ptr));\n<139> if(cksum(m, len)) {\n<171> optp = mtod(m, caddr_t) + sizeof (struct tcpiphdr);\n<237> if (so->so_fport != ti->ti_dport ||\n<239> so->so_lport != ti->ti_sport ||\n<295> if (tcp_attach(so) < 0) {\n<297> free(so); /* Not sofree (if it failed, it's not insqued) */\n<305> sbreserve(&so->so_snd, TCP_SNDSPACE);\n<307> sbreserve(&so->so_rcv, TCP_RCVSPACE);\n<311> so->so_laddr = ti->ti_src;\n<313> so->so_lport = ti->ti_sport;\n<315> so->so_faddr = ti->ti_dst;\n<321> if ((so->so_iptos = tcp_tos(so)) == 0)\n<323> so->so_iptos = ((struct ip *)ti)->ip_tos;\n<351> tp = sototcpcb(so);\n<533> ti->ti_len <= sbspace(&so->so_rcv)) {\n<603> win = sbspace(&so->so_rcv);\n<731> if((tcp_fconnect(so) == -1) && (errno != EINPROGRESS) && (errno != EWOULDBLOCK)) {\n<733> u_char code=ICMP_UNREACH_NET;\n<737> errno,strerror(errno)));\n<739> if(errno == ECONNREFUSED) {\n<749> if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n<759> m->m_data -= sizeof(struct tcpiphdr)+off-sizeof(struct tcphdr);\n<761> m->m_len  += sizeof(struct tcpiphdr)+off-sizeof(struct tcphdr);\n<765> icmp_error(m, ICMP_UNREACH,code, 0,strerror(errno));\n<771> m_free(m);\n<1069> m_adj(m, todrop);\n<1097> if ((so->so_state & SS_NOFDREF) &&
<81> if ((ret = alloc_picture(h, pic)) < 0)\n<135> for (i = 0; i < h->slice_context_count; i++)\n<153> memset(h->slice_table, -1,\n<155> (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));
<1> static void colored_fputs(int level, const char *str)\n<5> if (!*str)\n<11> if (use_color < 0) {\n<47> use_color = getenv("AV_LOG_FORCE_COLOR") && !getenv("NO_COLOR") &&\n<49> !getenv("AV_LOG_FORCE_NOCOLOR");\n<71> if (use_color == 1 && level != AV_LOG_INFO/8) {\n<77> (color[level] >> 4) & 15,\n<79> color[level] & 15,\n<83> } else if (use_color == 256 && level != AV_LOG_INFO/8) {\n<89> (color[level] >> 16) & 0xff,\n<91> (color[level] >> 8) & 0xff,
<1> static void decode_postinit(H264Context *h, int setup_finished)\n<83> if (FIELD_OR_MBAFF_PICTURE(h))\n<135> cur->f->interlaced_frame = FIELD_OR_MBAFF_PICTURE(h);\n<307> *sd->data = h->sei.afd.active_format_description;\n<315> if (h->sei.a53_caption.a53_caption) {\n<317> H264SEIA53Caption *a53 = &h->sei.a53_caption;\n<325> if (!sd)\n<331> memcpy(sd->data, a53->a53_caption, a53->a53_caption_size);\n<333> av_freep(&a53->a53_caption);\n<407> cnt     += out->poc < h->last_pocs[i];\n<429> h->last_pocs[i] = INT_MIN;\n<515> sizeof(*h->last_pocs) * (MAX_DELAYED_PIC_COUNT - 1));
<1> static const OptionDef *find_option(const OptionDef *po, const char *name)\n<5> const char *p = strchr(name, ':');\n<7> int len = p ? p - name : strlen(name);\n<11> while (po->name != NULL) {\n<13> if (!strncmp(name, po->name, len) && strlen(po->name) == len)\n<17> po++;\n<21> return po;
<1> int avfilter_open(AVFilterContext **filter_ctx, AVFilter *filter, const char *inst_name)\n<11> if (!filter)\n<17> ret = av_mallocz(sizeof(AVFilterContext));\n<33> ret->input_count  = pad_count(filter->inputs);\n<35> if (ret->input_count) {\n<37> ret->input_pads   = av_malloc(sizeof(AVFilterPad) * ret->input_count);\n<39> memcpy(ret->input_pads, filter->inputs, sizeof(AVFilterPad) * ret->input_count);\n<47> ret->output_count = pad_count(filter->outputs);\n<49> if (ret->output_count) {\n<51> ret->output_pads  = av_malloc(sizeof(AVFilterPad) * ret->output_count);\n<53> memcpy(ret->output_pads, filter->outputs, sizeof(AVFilterPad) * ret->output_count);\n<61> *filter_ctx = ret;
<1> static void l2x0_priv_write(void *opaque, target_phys_addr_t offset,\n<11> if (offset >= 0x730 && offset < 0x800) {\n<19> switch (offset) {\n<71> fprintf(stderr, "l2x0_priv_write: Bad offset %x\n", (int)offset);
<1> static int qemu_gluster_parseuri(GlusterConf *gconf, const char *filename)\n<17> if (!uri) {\n<27> if (!strcmp(uri->scheme, "gluster")) {\n<29> gconf->transport = g_strdup("tcp");\n<31> } else if (!strcmp(uri->scheme, "gluster+tcp")) {\n<33> gconf->transport = g_strdup("tcp");\n<35> } else if (!strcmp(uri->scheme, "gluster+unix")) {\n<37> gconf->transport = g_strdup("unix");\n<39> is_unix = true;\n<41> } else if (!strcmp(uri->scheme, "gluster+rdma")) {\n<43> gconf->transport = g_strdup("rdma");\n<47> ret = -EINVAL;\n<55> ret = parse_volume_options(gconf, uri->path);\n<57> if (ret < 0) {\n<79> if (uri->server || uri->port) {\n<87> if (strcmp(qp->p[0].name, "socket")) {\n<89> ret = -EINVAL;\n<95> gconf->server = g_strdup(qp->p[0].value);\n<115> uri_free(uri);
<1> START_TEST(single_quote_string)\n<27> for (i = 0; test_cases[i].encoded; i++) {\n<47> fail_unless(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
<1> static void versatile_init(ram_addr_t ram_size,\n<41> if (!env) {\n<43> fprintf(stderr, "Unable to find CPU definition\n");\n<103> for(n = 0; n < nb_nics; n++) {\n<105> nd = &nd_table[n];\n<109> if ((!nd->model && !done_smc) || strcmp(nd->model, "smc91c111") == 0) {\n<111> smc91c111_init(nd, 0x10010000, sic[25]);\n<113> done_smc = 1;\n<117> pci_nic_init_nofail(nd, "rtl8139", NULL);
<1> static inline void mix_3f_to_stereo(AC3DecodeContext *ctx)\n<19> memset(output[3], 0, sizeof(output[3]));
<1> static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n<25> for (y = 0; y < height; y++)\n<27> memset(t1->data[y], 0, width * sizeof(**t1->data));\n<39> for (y = 0; y < height + 2; y++)\n<41> memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));
<1> static void iv_Decode_Chunk(Indeo3DecodeContext *s,\n<61> strip->ypos = strip->xpos = 0;\n<63> for(strip->width = min_width_160; width > strip->width; strip->width *= 2);\n<65> strip->height = height;\n<67> strip->split_direction = 0;\n<69> strip->split_flag = 0;\n<71> strip->usl7 = 0;\n<83> while(strip >= strip_tbl) {\n<105> if(strip >= strip_tbl + FF_ARRAY_ELEMS(strip_tbl)) {\n<113> memcpy(strip, strip-1, sizeof(*strip));\n<115> strip->split_flag = 1;\n<117> strip->split_direction = 0;\n<119> strip->height = (strip->height > 8 ? ((strip->height+8)>>4)<<3 : 4);\n<127> if(strip >= strip_tbl + FF_ARRAY_ELEMS(strip_tbl)) {\n<135> memcpy(strip, strip-1, sizeof(*strip));\n<137> strip->split_flag = 1;\n<139> strip->split_direction = 1;\n<141> strip->width = (strip->width > 8 ? ((strip->width+8)>>4)<<3 : 4);\n<147> if(strip->usl7 == 0) {\n<149> strip->usl7 = 1;\n<159> if(strip->usl7 == 0) {\n<161> strip->usl7 = 1;\n<175> cur_frm_pos = cur + width * strip->ypos + strip->xpos;\n<527> if(lp2 > 0 || flag1 == 0 || strip->ypos != 0)\n<553> if(lp2 > 0 || flag1 == 0 || strip->ypos != 0)\n<787> if(lp2 > 0 || strip->ypos != 0 || flag1 == 0) {\n<813> if(lp2 > 0 || strip->ypos != 0 || flag1 == 0) {\n<1483> if(strip->split_flag != 0) {\n<1485> strip->split_flag = 0;\n<1487> strip->usl7 = (strip-1)->usl7;\n<1495> strip->width = (strip-1)->width - strip->width;\n<1497> if(region_160_width <= strip->xpos && width < strip->width + strip->xpos)\n<1499> strip->width = width - strip->xpos;\n<1503> strip->ypos += strip->height;\n<1505> strip->height = (strip-1)->height - strip->height;
<1> static int format_name(char *buf, int buf_len, int index)\n<31> if (replace_int_data_in_filename(buf, buf_len, orig_buf_dup, 'v', index) < 1) {\n<49> if (av_stristr(dir, "%v") && proto && !strcmp(proto, "file")) {\n<51> mod_buf_dup = av_strdup(buf);\n<53> if (!mod_buf_dup) {
<1> static int scale_vaapi_filter_frame(AVFilterLink *inlink, AVFrame *input_frame)\n<49> if (!output_frame) {\n<81> memset(&params, 0, sizeof(params));\n<127> vas = vaCreateBuffer(ctx->hwctx->display, ctx->va_context,
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<45> if (l1_table == NULL) {\n<105> if (ret < 0) {\n<123> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> int mov_write_ftyp_tag(ByteIOContext *pb, AVFormatContext *s)\n<11> if (!strcmp("3gp", s->oformat->name))\n<13> put_tag(pb, "3gp4");\n<17> put_tag(pb, "isom");\n<25> if (!strcmp("3gp", s->oformat->name))\n<27> put_tag(pb, "3gp4");\n<31> put_tag(pb, "mp41");
<1> qcrypto_block_luks_create(QCryptoBlock *block,\n<23> uint8_t *masterkey = NULL;\n<25> uint8_t *slotkey = NULL;\n<57> memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n<121> if (!password) {\n<135> memcpy(luks->header.magic, qcrypto_block_luks_magic,\n<159> if (!cipher_alg) {\n<175> cipher_mode_spec = g_strdup_printf("%s-%s:%s", cipher_mode, ivgen_alg,\n<181> cipher_mode_spec = g_strdup_printf("%s-%s", cipher_mode, ivgen_alg);\n<185> hash_alg = QCryptoHashAlgorithm_str(luks_opts.hash_alg);\n<191> if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n<193> error_setg(errp, "Cipher name '%s' is too long for LUKS header",\n<201> if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n<203> error_setg(errp, "Cipher mode '%s' is too long for LUKS header",\n<211> if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n<213> error_setg(errp, "Hash name '%s' is too long for LUKS header",\n<223> if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n<247> strcpy(luks->header.cipher_name, cipher_alg);\n<249> strcpy(luks->header.cipher_mode, cipher_mode_spec);\n<251> strcpy(luks->header.hash_spec, hash_alg);\n<255> luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n<259> luks->header.key_bytes *= 2;\n<459> splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n<495> if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n<515> (uint8_t *)password, strlen(password),\n<555> if (iters > UINT32_MAX) {\n<587> (uint8_t *)password, strlen(password),\n<751> cpu_to_be32s(&luks->header.key_bytes);\n<777> (const uint8_t *)&luks->header,\n<799> be32_to_cpus(&luks->header.key_bytes);\n<863> memset(masterkey, 0, luks->header.key_bytes);\n<865> g_free(masterkey);\n<867> memset(slotkey, 0, luks->header.key_bytes);\n<869> g_free(slotkey);\n<873> g_free(password);\n<891> if (masterkey) {\n<893> memset(masterkey, 0, luks->header.key_bytes);\n<897> g_free(masterkey);\n<899> if (slotkey) {\n<901> memset(slotkey, 0, luks->header.key_bytes);\n<905> g_free(slotkey);\n<907> g_free(splitkey);\n<909> g_free(password);\n<911> g_free(cipher_mode_spec);\n<915> qcrypto_ivgen_free(ivgen);\n<917> qcrypto_cipher_free(cipher);\n<921> g_free(luks);\n<923> return -1;
<1> static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<451> if (!(avctx->flags & CODEC_FLAG_BITEXACT))\n<455> strlen(LIBAVCODEC_IDENT) + 1, LIBAVCODEC_IDENT);
<1> static void pass1 ( vpx_image_t * raw , FILE * infile , const char * outfile_name , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n<9> int frame_count = 0 ;\n<15> encode_frame ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;\n<19> printf ( "\n" ) ;\n<22> printf ( "Pass 1 complete. Processed %d frames.\n" , frame_count ) ;
<1> static void save_native_fp_fxsave(CPUState *env)\n<5> struct fpxstate *fp = &fpx1;\n<31> for(i = 0;i < 8; i++) {\n<33> memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 16], 10);\n<39> if (env->cpuid_features & CPUID_SSE) {\n<43> memcpy(env->xmm_regs, fp->xmm_regs, CPU_NB_REGS * 16);
<1> static int qemu_rdma_exchange_get_response(RDMAContext *rdma,\n<3> RDMAControlHeader *head, int expecting, int idx)\n<11> if (ret < 0) {\n<13> fprintf(stderr, "rdma migration: recv polling control error!\n");\n<23> memcpy(head, rdma->wr_data[idx].control, sizeof(RDMAControlHeader));\n<27> DDDPRINTF("CONTROL: %s receiving...\n", control_desc[expecting]);\n<37> } else if (head->type != expecting || head->type == RDMA_CONTROL_ERROR) {\n<39> fprintf(stderr, "Was expecting a %s (%d) control message"\n<51> if (head->len > RDMA_CONTROL_MAX_BUFFER - sizeof(*head)) {\n<53> fprintf(stderr, "too long length: %d\n", head->len);
<1> static void language_destroy ( hb_language_t * l ) {\n<2> free ( l ) ;
<1> static int ehci_process_itd(EHCIState *ehci,\n<113> ehci->ipacket.status = USB_RET_NAK;\n<123> switch (ehci->ipacket.status) {\n<131> fprintf(stderr, "Unexpected iso usb result: %d\n",
<1> static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){\n<3> SnowContext *s = avctx->priv_data;\n<9> const int width= s->avctx->width;\n<29> memset(s->header_state, 0, sizeof(s->header_state));\n<63> frame_start(s);\n<75> uint8_t *src_plane= s->input_picture.data[0];\n<197> s->m.new_picture.data[0]= src - y*16*stride; //ugly\n<201> for(i=0; i<16 && i + 16*y<height; i++){\n<203> memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n<205> for(x=width; x<16*block_width; x++)\n<211> for(; i<16 && i + 16*y<16*block_height; i++)\n<213> memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n<249> s->m.new_picture.data[0]= src - y*16*stride; //ugly\n<255> assert(width <= stride);\n<257> assert(width <= 16*block_width);\n<261> for(i=0; i<16 && i + 16*y<height; i++){\n<263> memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n<265> for(x=width; x<16*block_width; x++)\n<271> for(; i<16 && i + 16*y<16*block_height; i++)\n<273> memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n<397> encode_header(s);\n<401> decorrelate(s, &s->mb_band   , s->mb_band   .buf, s->mb_band   .stride, 0, 1);\n<403> decorrelate(s, &s->mv_band[0], s->mv_band[0].buf, s->mv_band[0].stride, 0, 1);\n<405> decorrelate(s, &s->mv_band[1], s->mv_band[1].buf, s->mv_band[1].stride, 0 ,1);\n<407> encode_subband(s, &s->mb_band   , s->mb_band   .buf, NULL, s->mb_band   .stride, 0);\n<409> encode_subband(s, &s->mv_band[0], s->mv_band[0].buf, NULL, s->mv_band[0].stride, 0);\n<411> encode_subband(s, &s->mv_band[1], s->mv_band[1].buf, NULL, s->mv_band[1].stride, 0);\n<417> correlate(s, &s->mb_band   , s->mb_band   .buf, s->mb_band   .stride, 1, 1);\n<419> correlate(s, &s->mv_band[0], s->mv_band[0].buf, s->mv_band[0].stride, 1, 1);\n<421> correlate(s, &s->mv_band[1], s->mv_band[1].buf, s->mv_band[1].stride, 1, 1);\n<453> predict_plane(s, s->spatial_dwt_buffer, plane_index, 0);\n<483> quantize(s, b, b->buf, b->stride, s->qbias);\n<487> decorrelate(s, b, b->buf, b->stride, pict->pict_type == P_TYPE, 0);\n<489> encode_subband(s, b, b->buf, b->parent ? b->parent->buf : NULL, b->stride, orientation);\n<495> correlate(s, b, b->buf, b->stride, 1, 0);\n<513> dequantize(s, b, b->buf, b->stride);\n<537> predict_plane(s, s->spatial_dwt_buffer, plane_index, 1);
<1> static void opt_mb_qmax(const char *arg)\n<11> fprintf(stderr, "qmax must be >= 1 and <= 31\n");
<1> static void select_input_picture(MpegEncContext *s){\n<35> if(skip_check(s, s->input_picture[0], s->next_picture_ptr)){\n<117> get_intra_count(s, s->input_picture[i  ]->data[0],\n<237> if(s->reordered_input_picture[0]){\n<315> memset(&s->new_picture, 0, sizeof(Picture));
<1> static int svq3_decode_slice_header(H264Context *h)\n<59> if (length > 0) {\n<61> memcpy((uint8_t *) &s->gb.buffer[get_bits_count(&s->gb) >> 3],\n<63> &s->gb.buffer[s->gb.size_in_bits >> 3], (length - 1));\n<141> if (s->mb_x > 0) {\n<143> memset(h->intra4x4_pred_mode+8*h->mb2br_xy[mb_xy - 1      ]+3, -1, 4*sizeof(int8_t));\n<145> memset(h->intra4x4_pred_mode+8*h->mb2br_xy[mb_xy - s->mb_x]  , -1, 8*sizeof(int8_t)*s->mb_x);\n<149> if (s->mb_y > 0) {\n<151> memset(h->intra4x4_pred_mode+8*h->mb2br_xy[mb_xy - s->mb_stride], -1, 8*sizeof(int8_t)*(s->mb_width - s->mb_x));
<1> struct event_base * event_base_new ( void ) {\n<4> if ( ( base = calloc ( 1 , sizeof ( struct event_base ) ) ) == NULL ) event_err ( 1 , "%s: calloc" , __func__ ) ;\n<5> gettime ( base , & base -> event_tv ) ;\n<10> base -> evbase = NULL ;\n<15> base -> evbase = base -> evsel -> init ( base ) ;\n<17> if ( base -> evbase == NULL ) event_errx ( 1 , "%s: no event mechanism available" , __func__ ) ;\n<19> event_base_priority_init ( base , 1 ) ;\n<20> return ( base ) ;
<1> static int unix_listen_saddr(UnixSocketAddress *saddr,\n<17> if (sock < 0) {\n<27> memset(&un, 0, sizeof(un));\n<31> if (saddr->path && strlen(saddr->path)) {\n<33> snprintf(un.sun_path, sizeof(un.sun_path), "%s", saddr->path);\n<37> const char *tmpdir = getenv("TMPDIR");\n<39> tmpdir = tmpdir ? tmpdir : "/tmp";\n<41> if (snprintf(un.sun_path, sizeof(un.sun_path), "%s/qemu-socket-XXXXXX",\n<43> tmpdir) >= sizeof(un.sun_path)) {\n<85> g_free(saddr->path);\n<95> if (unlink(un.sun_path) < 0 && errno != ENOENT) {\n<105> if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {
<1> static int init_directories(BDRVVVFATState* s,\n<17> memset(&(s->first_sectors[0]),0,0x40*0x200);\n<41> i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;\n<57> direntry_t* entry=array_get_next(&(s->directory));\n<61> memcpy(entry->name,"QEMU VVF",8);\n<63> memcpy(entry->extension,"AT ",3);\n<77> s->cluster_count=sector2cluster(s, s->sector_count);\n<81> mapping = array_get_next(&(s->mapping));\n<91> mapping->path = g_strdup(dirname);\n<93> i = strlen(mapping->path);\n<95> if (i > 0 && mapping->path[i - 1] == '/')\n<97> mapping->path[i - 1] = '\0';\n<103> s->path = mapping->path;\n<107> for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n<117> mapping = array_get(&(s->mapping), i);\n<125> if(read_directory(s, i)) {\n<127> fprintf(stderr, "Could not read directory %s\n",\n<179> if(cluster > s->cluster_count) {\n<181> fprintf(stderr,"Directory does not fit in FAT%d (capacity %.2f MB)\n",\n<183> s->fat_type, s->sector_count / 2000.0);\n<201> fat_set(s, mapping->end - 1, s->max_fat_value);\n<229> bootsector=(bootsector_t*)(s->first_sectors+(s->first_sectors_number-1)*0x200);\n<237> memcpy(bootsector->name,"QEMU    ",8);\n<279> memcpy(bootsector->u.fat16.volume_label,"QEMU VVFAT ",11);\n<281> memcpy(bootsector->fat_type,(s->fat_type==12?"FAT12   ":s->fat_type==16?"FAT16   ":"FAT32   "),8);
<1> static uint64_t mpc8544_guts_read(void *opaque, target_phys_addr_t addr,\n<13> addr &= MPC8544_GUTS_MMIO_SIZE - 1;\n<15> switch (addr) {\n<31> fprintf(stderr, "guts: Unknown register read: %x\n", (int)addr);
<1> static vpx_codec_err_t parse_auto_alt_ref ( SvcContext * svc_ctx , const char * alt_ref_options ) {\n<10> if ( alt_ref_options == NULL || strlen ( alt_ref_options ) == 0 ) {\n<11> return VPX_CODEC_INVALID_PARAM ;\n<14> input_string = strdup ( alt_ref_options ) ;\n<16> token = strtok_r ( input_string , delim , & save_ptr ) ;\n<17> for ( i = 0 ;\n<18> i < svc_ctx -> spatial_layers ;\n<36> if ( res == VPX_CODEC_OK && found != svc_ctx -> spatial_layers ) {\n<40> if ( enabled > REF_FRAMES - svc_ctx -> spatial_layers ) {\n<44> free ( input_string ) ;\n<45> return res ;
<5> CPUX86State *env = &cpu->env;\n<27> if (ret < 0) {\n<55> memcpy(&env->fpip, &xsave->region[XSAVE_CWD_RIP], sizeof(env->fpip));\n<57> memcpy(&env->fpdp, &xsave->region[XSAVE_CWD_RDP], sizeof(env->fpdp));\n<61> memcpy(env->fpregs, &xsave->region[XSAVE_ST_SPACE],\n<67> memcpy(env->bnd_regs, &xsave->region[XSAVE_BNDREGS],\n<71> memcpy(&env->bndcs_regs, &xsave->region[XSAVE_BNDCSR],\n<75> memcpy(env->opmask_regs, &xsave->region[XSAVE_OPMASK],
<1> void qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n<21> if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n<23> fprintf(stderr, "%s", __FUNCTION__);\n<27> fprintf(stderr, "\n");\n<37> if (cursor->chunk.data_size != cursor->data_size) {\n<39> fprintf(stderr, "%s: multiple chunks\n", __FUNCTION__);
<1> static int read_f(BlockBackend *blk, int argc, char **argv)\n<23> int pattern = 0, pattern_offset = 0, pattern_count = 0;\n<27> while ((c = getopt(argc, argv, "bCl:pP:qs:v")) != EOF) {\n<47> pattern_count = cvtnum(optarg);\n<49> if (pattern_count < 0) {\n<51> printf("non-numeric length argument -- %s\n", optarg);\n<71> if (pattern < 0) {\n<89> pattern_offset = cvtnum(optarg);\n<91> if (pattern_offset < 0) {\n<93> printf("non-numeric length argument -- %s\n", optarg);\n<125> if (bflag && pflag) {\n<127> printf("-b and -p cannot be specified at the same time\n");\n<135> offset = cvtnum(argv[optind]);\n<137> if (offset < 0) {\n<139> printf("non-numeric length argument -- %s\n", argv[optind]);\n<149> count = cvtnum(argv[optind]);\n<151> if (count < 0) {\n<153> printf("non-numeric length argument -- %s\n", argv[optind]);\n<171> pattern_count = count - pattern_offset;\n<177> if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n<179> printf("pattern verification range exceeds end of read data\n");\n<199> if (count & 0x1ff) {\n<221> cnt = do_pread(blk, buf, offset, count, &total);\n<225> cnt = do_load_vmstate(blk, buf, offset, count, &total);\n<229> cnt = do_read(blk, buf, offset, count, &total);\n<237> if (cnt < 0) {\n<239> printf("read failed: %s\n", strerror(-cnt));\n<247> if (Pflag) {\n<249> void *cmp_buf = g_malloc(pattern_count);\n<251> memset(cmp_buf, pattern, pattern_count);\n<253> if (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n<263> g_free(cmp_buf);
<1> void kadmin_addprinc ( int argc , char * argv [ ] ) {\n<7> krb5_key_salt_tuple * ks_tuple = NULL ;\n<8> char * pass , * canon = NULL ;\n<12> memset ( & princ , 0 , sizeof ( princ ) ) ;\n<14> if ( kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , "add_principal" ) ) {\n<18> retval = krb5_unparse_name ( context , princ . principal , & canon ) ;\n<41> snprintf ( prompt2 , sizeof ( prompt2 ) , _ ( "Re-enter password for principal \"%s\"" ) , canon ) ;\n<44> com_err ( "add_principal" , retval , _ ( "while reading password for \"%s\"." ) , canon ) ;\n<50> retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n<53> princ . attributes |= KRB5_KDB_DISALLOW_ALL_TIX ;\n<56> retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n<60> com_err ( "add_principal" , retval , "while creating \"%s\"." , canon ) ;\n<63> if ( old_style_randkey ) {\n<64> retval = randkey_princ ( princ . principal , FALSE , n_ks_tuple , ks_tuple ) ;\n<66> com_err ( "add_principal" , retval , _ ( "while randomizing key for \"%s\"." ) , canon ) ;\n<69> princ . attributes &= ~ KRB5_KDB_DISALLOW_ALL_TIX ;\n<71> retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n<72> if ( retval ) {\n<73> com_err ( "add_principal" , retval , _ ( "while clearing DISALLOW_ALL_TIX for \"%s\"." ) , canon ) ;\n<77> printf ( "Principal \"%s\" created.\n" , canon ) ;\n<78> cleanup : krb5_free_principal ( context , princ . principal ) ;\n<79> free ( ks_tuple ) ;\n<80> free ( canon ) ;\n<81> kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;
<1> int rfc2231_parse ( struct rfc822_parser_context * ctx , const char * const * * result_r ) {\n<14> while ( ( ret = rfc822_parse_content_param ( ctx , & key , & value ) ) != 0 ) {\n<15> if ( ret < 0 ) {\n<21> p = strchr ( key , '*' ) ;\n<22> if ( p != NULL ) {\n<40> rfc2231_param . key = t_strdup_until ( key , p2 ) ;\n<46> array_append ( & result , & key , 1 ) ;
<1> static char *sysbus_get_fw_dev_path(DeviceState *dev)\n<13> off = snprintf(path, sizeof(path), "%s", qdev_fw_name(dev));\n<31> return strdup(path);
<1> static int32_t u_printf_hex_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n<7> ufmt_64tou ( result , & len , num , 16 , ( UBool ) ( info -> fSpec == 0x0078 ) , ( info -> fPrecision == - 1 && info -> fZero ) ? info -> fWidth : info -> fPrecision ) ;\n<8> if ( num != 0 && info -> fAlt && len < UPRINTF_BUFFER_SIZE - 2 ) {\n<9> memmove ( result + 2 , result , len * sizeof ( UChar ) ) ;\n<14> return handler -> pad_and_justify ( context , info , result , len ) ;
<1> static int get_dns_addr(struct in_addr *pdns_addr)\n<5> char buff[512];\n<7> char buff2[257];\n<19> if (!f)\n<31> while (fgets(buff, 512, f) != NULL) {\n<33> if (sscanf(buff, "nameserver%*[ \t]%256s", buff2) == 1) {\n<35> if (!inet_aton(buff2, &tmp_addr))\n<57> if (++found > 3) {\n<81> fclose(f);
<1> main(\n<23> char *cert_names[MAX_CERTS];\n<33> if (socket_init() != 0)\n<45> if (cert_count >= MAX_CERTS) {\n<47> printf("too many certificates (max = %d)\n", MAX_CERTS);\n<93> if (cert_count > 0) {\n<105> if (emul_args == NULL) {\n<107> emul_args = (char *)"db=\"/etc/pki/nssdb\"";\n<115> len = strlen(emul_args) + strlen(SOFT_STRING) + 2;\n<117> for (i = 0; i < cert_count; i++) {\n<119> len += strlen(cert_names[i])+1; /* 1 == comma */\n<123> new_args = g_malloc(len);\n<125> strcpy(new_args, emul_args);\n<127> strcat(new_args, SOFT_STRING);\n<129> for (i = 0; i < cert_count; i++) {\n<131> strcat(new_args, cert_names[i]);\n<133> strcat(new_args, ",");\n<137> strcat(new_args, ")");\n<139> emul_args = new_args;\n<157> if (sock == -1) {\n<159> fprintf(stderr, "error opening socket, exiting.\n");\n<185> printf("> ");
<1> static unsigned int dec_bound_r(DisasContext *dc)\n<7> int size = memsize_zz(dc);\n<11> memsize_char(size), dc->op1, dc->op2));\n<13> cris_cc_mask(dc, CC_MASK_NZ);\n<17> dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, l0);
<1> static void load_symbols(struct elfhdr *hdr, int fd)\n<33> symtab = sechdr;\n<65> s = malloc(sizeof(*s));\n<67> syms = malloc(symtab.sh_size);\n<69> if (!syms)\n<73> s->disas_strtab = strings = malloc(strtab.sh_size);\n<75> if (!s->disas_strtab)\n<83> if (read(fd, syms, symtab.sh_size) != symtab.sh_size)\n<115> syms[i] = syms[nsyms];\n<135> syms = realloc(syms, nsyms * sizeof(*syms));\n<139> qsort(syms, nsyms, sizeof(*syms), symcmp);\n<145> if (read(fd, strings, strtab.sh_size) != strtab.sh_size)\n<167> syminfos = s;
<1> static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<17> if ((ret = decode_frame_header(s, avpkt->data, avpkt->size)) < 0)\n<87> if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n<113> memset(s->top_nnz, 0, s->mb_width*sizeof(*s->top_nnz));\n<119> if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {\n<121> memset(curframe->data[0] - s->linesize  -1, 127, s->linesize  +1);\n<123> memset(curframe->data[1] - s->uvlinesize-1, 127, s->uvlinesize+1);\n<125> memset(curframe->data[2] - s->uvlinesize-1, 127, s->uvlinesize+1);\n<131> for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n<151> memset(s->left_nnz, 0, sizeof(s->left_nnz));\n<169> decode_mb_mode(s, mb, mb_x, mb_y, intra4x4 + 4*mb_x);\n<175> decode_mb_coeffs(s, c, mb, s->top_nnz[mb_x], s->left_nnz);\n<187> if (mb->mode <= MODE_I4x4) {\n<189> intra_predict(s, dst, mb, intra4x4 + 4*mb_x, mb_x, mb_y);\n<191> memset(mb->bmv, 0, sizeof(mb->bmv));\n<195> inter_predict(s, dst, mb, mb_x, mb_y);\n<203> idct_mb(s, dst[0], dst[1], dst[2], mb);\n<207> AV_ZERO64(s->left_nnz);\n<217> s->left_nnz[8]      = 0;\n<233> mb++;\n<241> filter_mb_row_simple(s, mb_y-1);\n<245> filter_mb_row(s, mb_y-1);\n<255> filter_mb_row_simple(s, mb_y-1);\n<259> filter_mb_row(s, mb_y-1);
<1> static int mjpeg_decode_com(MJpegDecodeContext *s)\n<15> cbuf = av_malloc(len+1);\n<21> cbuf[i] = get_bits(&s->gb, 8);\n<23> if (cbuf[i-1] == '\n')\n<25> cbuf[i-1] = 0;\n<29> cbuf[i] = 0;\n<33> printf("mjpeg comment: '%s'\n", cbuf);\n<39> if (!strcmp(cbuf, "AVID"))\n<43> s->buggy_avid = 1;\n<53> av_free(cbuf);
<1> static uint64_t mpc8544_guts_read ( void * opaque , hwaddr addr , unsigned size ) {\n<4> addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;\n<5> switch ( addr ) {\n<10> default : fprintf ( stderr , "guts: Unknown register read: %x\n" , ( int ) addr ) ;
<1> int ff_vda_create_decoder(struct vda_context *vda_ctx,\n<3> uint8_t *extradata,\n<35> if (extradata_size >= 4 && (extradata[4] & 0x03) != 0x03) {\n<41> if (!(rw_extradata = av_malloc(extradata_size)))\n<47> memcpy(rw_extradata, extradata, extradata_size);\n<51> rw_extradata[4] |= 0x03;\n<55> avc_data = CFDataCreate(kCFAllocatorDefault, rw_extradata, extradata_size);
<23> if (r == NULL)\n<39> r = malloc(sizeof(PCRecord));\n<47> *pr = r;
<1> START_TEST(qdict_get_try_str_test)\n<13> qdict_put(tests_dict, key, qstring_from_str(str));\n<19> fail_unless(p != NULL);\n<21> fail_unless(strcmp(p, str) == 0);
<1> static int http_parse_request(HTTPContext *c)\n<33> p = c->buffer;\n<35> get_word(cmd, sizeof(cmd), &p);\n<37> av_strlcpy(c->method, cmd, sizeof(c->method));\n<41> if (!strcmp(cmd, "GET"))\n<43> c->post = 0;\n<45> else if (!strcmp(cmd, "POST"))\n<47> c->post = 1;\n<51> return -1;\n<55> get_word(url, sizeof(url), &p);\n<57> av_strlcpy(c->url, url, sizeof(c->url));\n<61> get_word(protocol, sizeof(protocol), (const char **)&p);\n<63> if (strcmp(protocol, "HTTP/1.0") && strcmp(protocol, "HTTP/1.1"))\n<65> return -1;\n<69> av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n<73> if (config.debug)\n<75> http_log("%s - - New connection: %s %s\n", inet_ntoa(c->from_addr.sin_addr), cmd, url);\n<81> p1 = strchr(url, '?');\n<83> if (p1) {\n<85> av_strlcpy(info, p1, sizeof(info));\n<95> av_strlcpy(filename, url + ((*url == '/') ? 1 : 0), sizeof(filename)-1);\n<99> for (p = c->buffer; *p && *p != '\r' && *p != '\n'; ) {\n<101> if (av_strncasecmp(p, "User-Agent:", 11) == 0) {\n<113> p = strchr(p, '\n');\n<115> if (!p)\n<127> redir_type = REDIR_NONE;\n<129> if (av_match_ext(filename, "asx")) {\n<133> filename[strlen(filename)-1] = 'f';\n<135> } else if (av_match_ext(filename, "asf") &&\n<143> } else if (av_match_ext(filename, "rpm,ram")) {\n<147> strcpy(filename + strlen(filename)-2, "m");\n<153> compute_real_filename(filename, sizeof(filename) - 1);\n<155> } else if (av_match_ext(filename, "sdp")) {\n<159> compute_real_filename(filename, sizeof(filename) - 1);\n<167> if (!strlen(filename))\n<169> av_strlcpy(filename, "index.html", sizeof(filename) - 1);\n<173> stream = config.first_stream;\n<175> while (stream) {\n<177> if (!strcmp(stream->filename, filename) && validate_acl(stream, c))\n<181> stream = stream->next;\n<185> if (!stream) {\n<187> snprintf(msg, sizeof(msg), "File '%s' not found", url);\n<197> c->stream = stream;\n<199> memcpy(c->feed_streams, stream->feed_streams, sizeof(c->feed_streams));\n<201> memset(c->switch_feed_streams, -1, sizeof(c->switch_feed_streams));\n<205> if (stream->stream_type == STREAM_TYPE_REDIRECT) {\n<227> q += strlen(q);\n<233> c->buffer_end = q;\n<247> if (modify_current_stream(c, ratebuf)) {\n<249> for (i = 0; i < FF_ARRAY_ELEMS(c->feed_streams); i++) {\n<263> if (c->post == 0 && stream->stream_type == STREAM_TYPE_LIVE)\n<265> current_bandwidth += stream->bandwidth;\n<271> if (stream->feed_opened) {\n<275> http_log("Feed '%s' already being received\n", stream->feed_filename);\n<283> if (c->post == 0 && config.max_bandwidth < current_bandwidth) {\n<287> q = c->buffer;\n<307> q += strlen(q);\n<313> c->buffer_end = q;\n<325> const char *hostinfo = 0;\n<329> for (p = c->buffer; *p && *p != '\r' && *p != '\n'; ) {\n<331> if (av_strncasecmp(p, "Host:", 5) == 0) {\n<333> hostinfo = p + 5;\n<339> p = strchr(p, '\n');\n<341> if (!p)\n<353> if (hostinfo) {\n<361> while (av_isspace(*hostinfo))\n<363> hostinfo++;\n<367> eoh = strchr(hostinfo, '\n');\n<369> if (eoh) {\n<371> if (eoh[-1] == '\r')\n<373> eoh--;\n<377> if (eoh - hostinfo < sizeof(hostbuf) - 1) {\n<379> memcpy(hostbuf, hostinfo, eoh - hostinfo);\n<381> hostbuf[eoh - hostinfo] = 0;\n<389> switch(redir_type) {\n<409> q += strlen(q);\n<427> q += strlen(q);\n<445> q += strlen(q);\n<457> av_strlcpy(hostname, hostbuf, sizeof(hostname));\n<477> q += strlen(q);\n<505> q += strlen(q);\n<529> if (sdp_data_size > 0) {\n<531> memcpy(q, sdp_data, sdp_data_size);\n<533> q += sdp_data_size;\n<537> av_free(sdp_data);\n<559> c->buffer_end = q;\n<581> stream->conns_served++;\n<593> if (!stream->is_feed) {\n<599> const char *logline = 0;\n<605> for (p = c->buffer; *p && *p != '\r' && *p != '\n'; ) {\n<607> if (av_strncasecmp(p, "Pragma: log-line=", 17) == 0) {\n<609> logline = p;\n<615> if (av_strncasecmp(p, "Pragma: client-id=", 18) == 0)\n<619> p = strchr(p, '\n');\n<621> if (!p)\n<633> if (logline) {\n<635> char *eol = strchr(logline, '\n');\n<639> logline += 17;\n<645> if (eol[-1] == '\r')\n<647> eol--;\n<649> http_log("%.*s\n", (int) (eol - logline), logline);\n<701> if (http_start_receive_data(c) < 0) {\n<737> if (open_input_stream(c, info) < 0) {\n<739> snprintf(msg, sizeof(msg), "Input stream corresponding to '%s' not found", url);\n<749> c->buffer[0] = 0;\n<765> if (!strcmp(c->stream->fmt->name,"asf_stream")) {\n<771> c->wmp_client_id = av_lfg_get(&random_state);\n<775> av_strlcatf(c->buffer, c->buffer_size, "Server: Cougar 4.1.0.3923\r\nCache-Control: no-cache\r\nPragma: client-id=%d\r\nPragma: features=\"broadcast\"\r\n", c->wmp_client_id);\n<781> av_strlcatf(c->buffer, c->buffer_size, "\r\n");\n<783> q = c->buffer + strlen(c->buffer);\n<791> c->buffer_ptr = c->buffer;\n<793> c->buffer_end = q;\n<823> q += strlen(q);\n<829> c->buffer_end = q;\n<837> compute_status(c);
<1> static void test_qemu_strtoul_decimal(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoul(str, &endptr, 10, &res);\n<25> g_assert(endptr == str + strlen(str));\n<33> endptr = &f;\n<35> err = qemu_strtoul(str, &endptr, 0, &res);\n<43> g_assert(endptr == str + strlen(str));
<1> static int read_packet(AVFormatContext *s,\n<21> if (avio_read(pb, preamble, MM_PREAMBLE_SIZE) != MM_PREAMBLE_SIZE) {\n<29> type = AV_RL16(&preamble[0]);\n<31> length = AV_RL16(&preamble[2]);\n<53> if (av_new_packet(pkt, length + MM_PREAMBLE_SIZE))\n<57> memcpy(pkt->data, preamble, MM_PREAMBLE_SIZE);\n<59> if (avio_read(pb, pkt->data + MM_PREAMBLE_SIZE, length) != length)\n<63> pkt->size = length + MM_PREAMBLE_SIZE;
<1> struct zip_cdir * _zip_cdir_new ( int nentry , struct zip_error * error ) {\n<3> if ( ( cd = ( struct zip_cdir * ) malloc ( sizeof ( * cd ) ) ) == NULL ) {\n<4> _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n<5> return NULL ;\n<7> if ( ( cd -> entry = ( struct zip_dirent * ) malloc ( sizeof ( * ( cd -> entry ) ) * nentry ) ) == NULL ) {\n<8> _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n<9> free ( cd ) ;\n<10> return NULL ;\n<12> cd -> nentry = nentry ;\n<13> cd -> size = cd -> offset = 0 ;\n<14> cd -> comment = NULL ;\n<15> cd -> comment_len = 0 ;\n<16> return cd ;
<1> static QDict *qmp_check_input_obj(QObject *input_obj, Error **errp)\n<27> for (ent = qdict_first(input_dict); ent; ent = qdict_next(input_dict, ent)){\n<29> const char *arg_name = qdict_entry_key(ent);\n<35> if (!strcmp(arg_name, "execute")) {\n<37> if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n<49> } else if (!strcmp(arg_name, "arguments")) {\n<51> if (qobject_type(arg_obj) != QTYPE_QDICT) {\n<61> } else if (!strcmp(arg_name, "id")) {\n<67> error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n<69> return NULL;
<1> static int mpc7_decode_init(AVCodecContext * avctx)\n<7> MPCContext *c = avctx->priv_data;\n<17> if(avctx->extradata_size < 16){\n<25> memset(c->oldDSCF, 0, sizeof(c->oldDSCF));
<1> static int check_refcounts_l2(BlockDriverState *bs, BdrvCheckResult *res,\n<29> if (ret < 0) {\n<31> fprintf(stderr, "ERROR: I/O error in check_refcounts_l2\n");
<1> int read_ffserver_streams(AVFormatContext *s, const char *filename)\n<21> for(i=0;i<ic->nb_streams;i++) {\n<25> st = av_mallocz(sizeof(AVFormatContext));\n<27> memcpy(st, ic->streams[i], sizeof(AVStream));\n<29> s->streams[i] = st;
<1> void axisdev88_init (ram_addr_t ram_size, int vga_ram_size,\n<5> const char *kernel_filename, const char *kernel_cmdline,\n<51> cpu_register_physical_memory(0x40000000, ram_size, phys_ram | IO_MEM_RAM);\n<133> etraxfs_timer_init(env, pic->irq + 0x1b, pic->nmi + 1, 0x3005e000);\n<151> if (kernel_filename) {\n<185> if (kernel_cmdline && (kcmdline_len = strlen(kernel_cmdline))) {\n<187> if (kcmdline_len > 256) {\n<189> fprintf(stderr, "Too long CRIS kernel cmdline (max 256)\n");\n<195> pstrcpy_targphys(high, 256, kernel_cmdline);\n<199> env->regs[10] = 0x87109563;\n<201> env->regs[11] = high;\n<207> env->pc = bootstrap_pc;\n<211> printf ("pc =%x\n", env->pc);\n<213> printf ("ram size =%ld\n", ram_size);
<1> static void ppc_core99_init (int ram_size, int vga_ram_size,\n<71> if (!env) {\n<73> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<161> vga_bios_size = load_image(buf, phys_ram_base + vga_bios_offset + 8);\n<163> if (vga_bios_size < 0) {\n<167> fprintf(stderr, "qemu: warning: could not load VGA bios '%s'\n", buf);
<1> static int opt_map(OptionsContext *o, const char *opt, const char *arg)\n<25> map = av_strdup(arg);\n<31> if (sync = strchr(map, ',')) {\n<33> *sync = 0;\n<35> sync_file_idx = strtol(sync + 1, &sync, 0);\n<37> if (sync_file_idx >= nb_input_files || sync_file_idx < 0) {\n<45> if (*sync)\n<47> sync++;\n<49> for (i = 0; i < input_files[sync_file_idx].nb_streams; i++)\n<51> if (check_stream_specifier(input_files[sync_file_idx].ctx,\n<61> if (i == input_files[sync_file_idx].nb_streams) {\n<77> file_idx = strtol(map, &p, 0);
<1> static int siff_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> SIFFContext *c = s->priv_data;\n<27> avio_read(s->pb, c->gmc, c->gmcsize);\n<39> size = c->pktsize - c->sndsize - c->gmcsize - 2;\n<47> if (av_new_packet(pkt, size + c->gmcsize + 2) < 0)\n<51> AV_WL16(pkt->data, c->flags);\n<53> if (c->gmcsize)\n<55> memcpy(pkt->data + 2, c->gmc, c->gmcsize);\n<57> if (avio_read(s->pb, pkt->data + 2 + c->gmcsize, size) != size) {
<1> static void test_qemu_strtoull_hex(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoull(str, &endptr, 16, &res);\n<25> g_assert(endptr == str + strlen(str));\n<31> endptr = &f;\n<35> err = qemu_strtoull(str, &endptr, 0, &res);\n<43> g_assert(endptr == str + strlen(str));
<1> tdata_t _TIFFmalloc ( tsize_t s ) {\n<2> if ( s == 0 ) return ( ( void * ) NULL ) ;\n<3> return ( malloc ( ( size_t ) s ) ) ;
<1> void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n<29> if (!src_str || !src_str[0])\n<35> get_str_sep(buf, sizeof(buf), &p, ':');\n<39> if (!strcmp(buf, "tcp") || buf[0] == '\0') {\n<41> is_udp = 0;\n<43> } else if (!strcmp(buf, "udp")) {\n<45> is_udp = 1;\n<55> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<87> monitor_printf(mon, "invalid format\n");
<1> static int vdi_co_read(BlockDriverState *bs,\n<3> int64_t sector_num, uint8_t *buf, int nb_sectors)\n<51> if (!VDI_IS_ALLOCATED(bmap_entry)) {\n<55> memset(buf, 0, n_sectors * SECTOR_SIZE);\n<79> buf += n_sectors * SECTOR_SIZE;
<1> static void vga_draw_graphic(VGAState *s, int full_update)\n<153> full_update |= update_palette16(s);\n<171> full_update |= update_palette16(s);\n<189> switch(s->get_bpp(s)) {\n<195> full_update |= update_palette256(s);\n<205> full_update |= update_palette256(s);\n<255> s->cursor_invalidate(s);\n<329> update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n<347> vga_draw_line(s, d, s->vram_ptr + addr, width);\n<351> s->cursor_draw_line(s, d, y);\n<419> memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);
<1> static int net_init_nic(const NetClientOptions *opts, const char *name,\n<23> if (idx == -1 || nb_nics >= MAX_NICS) {\n<33> nd = &nd_table[idx];\n<37> memset(nd, 0, sizeof(*nd));\n<45> if (!nd->netdev) {\n<99> qemu_macaddr_default_if_unset(&nd->macaddr);
<1> static int mov_open_dref(AVIOContext **pb, const char *src, MOVDref *ref,\n<11> if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n<13> char filename[1024];\n<37> for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n<55> if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n<57> memcpy(filename, src, src_path - src);\n<59> filename[src_path - src] = 0;\n<69> av_strlcat(filename, ref->path + l + 1, sizeof(filename));
<1> void ff_xvmc_decode_mb ( MpegEncContext * s ) {\n<96> i < blocks_per_mb ;\n<98> memset ( s -> pblocks [ i ] , 0 , sizeof ( * s -> pblocks [ i ] ) ) ;\n<117> if ( s -> avctx -> xvmc_acceleration == 1 ) {\n<118> memcpy ( & render -> data_blocks [ render -> next_free_data_block_num * 64 ] , s -> pblocks [ i ] , sizeof ( * s -> pblocks [ i ] ) ) ;
<1> static int rtmp_open(URLContext *s, const char *uri, int flags)\n<5> RTMPContext *rt = s->priv_data;\n<23> rt->listen = 1;\n<31> av_url_split(proto, sizeof(proto), auth, sizeof(auth),\n<39> if (auth[0]) {\n<41> char *ptr = strchr(auth, ':');\n<47> av_strlcpy(rt->username, auth, sizeof(rt->username));\n<49> av_strlcpy(rt->password, ptr + 1, sizeof(rt->password));\n<57> if (rt->listen && strcmp(proto, "rtmp")) {\n<59> av_log(s, AV_LOG_ERROR, "rtmp_listen not available for %s\n",\n<63> return AVERROR(EINVAL);\n<67> if (!strcmp(proto, "rtmpt") || !strcmp(proto, "rtmpts")) {\n<69> if (!strcmp(proto, "rtmpts"))\n<71> av_dict_set(&opts, "ffrtmphttp_tls", "1", 1);\n<77> ff_url_join(buf, sizeof(buf), "ffrtmphttp", NULL, hostname, port, NULL);\n<79> } else if (!strcmp(proto, "rtmps")) {\n<83> if (port < 0)\n<87> ff_url_join(buf, sizeof(buf), "tls", NULL, hostname, port, NULL);\n<89> } else if (!strcmp(proto, "rtmpe") || (!strcmp(proto, "rtmpte"))) {\n<91> if (!strcmp(proto, "rtmpte"))\n<93> av_dict_set(&opts, "ffrtmpcrypt_tunneling", "1", 1);\n<99> ff_url_join(buf, sizeof(buf), "ffrtmpcrypt", NULL, hostname, port, NULL);\n<101> rt->encrypted = 1;\n<107> if (port < 0)\n<111> if (rt->listen)\n<129> if ((ret = ffurl_open(&rt->stream, buf, AVIO_FLAG_READ_WRITE,\n<131> &s->interrupt_callback, &opts)) < 0) {\n<153> if (!rt->listen && (ret = rtmp_handshake(s, rt)) < 0)\n<157> if (rt->listen && (ret = rtmp_server_handshake(s, rt)) < 0)\n<179> if (!rt->app) {\n<191> if (!strncmp(path, "/ondemand/", 10)) {\n<193> fname = path + 10;\n<195> memcpy(rt->app, "ondemand", 9);\n<199> char *next = *path ? path + 1 : path;\n<201> char *p = strchr(next, '/');\n<203> if (!p) {\n<205> fname = next;\n<207> rt->app[0] = '\0';\n<213> char *c = strchr(p + 1, ':');\n<215> fname = strchr(p + 1, '/');\n<217> if (!fname || (c && c < fname)) {\n<219> fname = p + 1;\n<227> av_strlcpy(rt->app, path + 1, fname - path - 1);\n<241> av_free(rt->app);\n<249> if (!rt->playpath) {\n<251> int len = strlen(fname);\n<257> if (!rt->playpath) {\n<267> if (!strchr(fname, ':') && len >= 4 &&\n<269> (!strcmp(fname + len - 4, ".f4v") ||\n<271> !strcmp(fname + len - 4, ".mp4"))) {\n<273> memcpy(rt->playpath, "mp4:", 5);\n<275> } else if (len >= 4 && !strcmp(fname + len - 4, ".flv")) {\n<277> fname[len - 4] = '\0';\n<281> rt->playpath[0] = 0;\n<285> av_strlcat(rt->playpath, fname, PLAYPATH_MAX_LENGTH);\n<303> ff_url_join(rt->tcurl, TCURL_MAX_LENGTH, proto, NULL, hostname,\n<353> av_log(s, AV_LOG_DEBUG, "Proto = %s, path = %s, app = %s, fname = %s\n",\n<359> if ((ret = gen_connect(s, rt)) < 0)\n<387> if (rt->do_reconnect) {\n<397> memset(rt->prev_pkt, 0, sizeof(rt->prev_pkt));\n<399> free_tracked_methods(rt);\n<407> if (rt->is_input) {\n<413> rt->flv_data = av_realloc(rt->flv_data, rt->flv_size);\n<417> memcpy(rt->flv_data, "FLV\1\5\0\0\0\011\0\0\0\0", rt->flv_size);
<1> static void do_exit(void)\n<23> if (show_status)\n<25> printf("\n");
<1> rtsp_read_reply (AVFormatContext *s, RTSPMessageHeader *reply,\n<21> memset(reply, 0, sizeof(*reply));\n<101> rtsp_parse_line(reply, p);\n<117> av_strlcpy(rt->session_id, reply->session_id, sizeof(rt->session_id));\n<121> content_length = reply->content_length;\n<147> if (reply->notice == 2101 /* End-of-Stream Reached */      ||\n<149> reply->notice == 2104 /* Start-of-Stream Reached */    ||\n<151> reply->notice == 2306 /* Continuous Feed Terminated */)\n<155> else if (reply->notice >= 4400 && reply->notice < 5500)\n<159> else if (reply->notice == 2401 /* Ticket Expired */ ||\n<161> (reply->notice >= 5500 && reply->notice < 5600) /* end of term */ )
<1> long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3,\n<21> switch(num) {\n<589> ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3));\n<1491> return ret;
<1> static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n<9> char access[11];\n<11> char type[11];\n<31> while (*p) {\n<49> if (ret < 4 || strcmp(access, "RW")) {\n<53> } else if (!strcmp(type, "FLAT")) {\n<55> if (ret != 5 || flat_offset < 0) {\n<63> } else if (!strcmp(type, "VMFS")) {\n<65> flat_offset = 0;\n<67> } else if (ret != 4) {\n<77> if (sectors <= 0 ||\n<79> (strcmp(type, "FLAT") && strcmp(type, "SPARSE") &&\n<81> strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) ||\n<83> (strcmp(access, "RW"))) {\n<99> if (ret) {\n<109> if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) {\n<115> ret = vmdk_add_extent(bs, extent_file, true, sectors,\n<117> 0, 0, 0, 0, 0, &extent, errp);\n<119> if (ret < 0) {\n<127> } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) {\n<131> ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, errp);\n<133> if (ret) {\n<145> error_setg(errp, "Unsupported extent type '%s'", type);\n<147> return -ENOTSUP;\n<151> extent->type = g_strdup(type);\n<157> while (*p) {
<1> static void cookedprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) {\n<16> if ( ! quiet ) fprintf ( fp , "status=%04x %s,\n" , status , statustoa ( datatype , status ) ) ;\n<18> while ( nextvar ( & length , & data , & name , & value ) ) {\n<19> fmt = varfmt ( name ) ;\n<21> switch ( fmt ) {\n<24> case TS : if ( ! decodets ( value , & lfp ) ) output_raw = '?' ;\n<25> else output ( fp , name , prettydate ( & lfp ) ) ;\n<27> case HA : case NA : if ( ! decodenetnum ( value , & hval ) ) {\n<31> output ( fp , name , nntohost ( & hval ) ) ;\n<34> output ( fp , name , stoa ( & hval ) ) ;\n<37> case RF : if ( decodenetnum ( value , & hval ) ) {\n<38> if ( ISREFCLOCKADR ( & hval ) ) output ( fp , name , refnumtoa ( & hval ) ) ;\n<39> else output ( fp , name , stoa ( & hval ) ) ;\n<41> else if ( strlen ( value ) <= 4 ) {\n<42> output ( fp , name , value ) ;\n<45> output_raw = '?' ;\n<48> case LP : if ( ! decodeuint ( value , & uval ) || uval > 3 ) {\n<55> output ( fp , name , b ) ;\n<58> case OC : if ( ! decodeuint ( value , & uval ) ) {\n<63> output ( fp , name , b ) ;\n<66> case AR : if ( ! decodearr ( value , & narr , lfparr ) ) output_raw = '?' ;\n<67> else outputarr ( fp , name , narr , lfparr ) ;\n<69> case FX : if ( ! decodeuint ( value , & uval ) ) output_raw = '?' ;\n<70> else output ( fp , name , tstflags ( uval ) ) ;\n<72> default : fprintf ( stderr , "Internal error in cookedprint, %s=%s, fmt %d\n" , name , value , fmt ) ;\n<77> atoascii ( name , MAXVARLEN , bn , sizeof ( bn ) ) ;\n<78> atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ;\n<79> if ( output_raw != '*' ) {\n<80> len = strlen ( bv ) ;\n<81> bv [ len ] = output_raw ;\n<82> bv [ len + 1 ] = '\0' ;\n<84> output ( fp , bn , bv ) ;\n<87> endoutput ( fp ) ;
<1> int ff_xvid_rate_control_init(MpegEncContext *s){\n<19> if (fd == -1) {\n<29> for(i=0; i<s->rc_context.num_entries; i++){\n<43> snprintf(tmp, sizeof(tmp), "%c %d %d %d %d %d %d\n",\n<53> write(fd, tmp, strlen(tmp));\n<59> close(fd);\n<63> memset(&xvid_2pass2, 0, sizeof(xvid_2pass2));\n<79> memset(&xvid_plg_create, 0, sizeof(xvid_plg_create));\n<87> xvid_plg_create.param= &xvid_2pass2;\n<91> if(xvid_plugin_2pass2(NULL, XVID_PLG_CREATE, &xvid_plg_create, &s->rc_context.non_lavc_opaque)<0){
<1> CharDriverState *qemu_chr_open(const char *filename)\n<9> if (!strcmp(filename, "vc")) {\n<11> return text_console_init(&display_state);\n<13> } else if (!strcmp(filename, "null")) {\n<15> return qemu_chr_open_null();\n<19> if (strstart(filename, "tcp:", &p)) {\n<37> if (strstart(filename, "mon:", &p)) {\n<39> CharDriverState *drv = qemu_chr_open(p);\n<41> if (drv) {\n<51> printf("Unable to open driver: %s\n", p);\n<67> } else if (strstart(filename, "pipe:", &p)) {\n<71> } else if (!strcmp(filename, "pty")) {\n<73> return qemu_chr_open_pty();\n<75> } else if (!strcmp(filename, "stdio")) {\n<77> return qemu_chr_open_stdio();\n<91> if (strstart(filename, "/dev/", NULL)) {
<1> static int unpack_vectors(Vp3DecodeContext *s, GetBitContext *gb)\n<9> int motion_x[6];\n<11> int motion_y[6];\n<27> if (s->keyframe)\n<33> memset(motion_x, 0, 6 * sizeof(int));\n<35> memset(motion_y, 0, 6 * sizeof(int));\n<109> last_motion_x = motion_x[0];\n<111> last_motion_y = motion_y[0];\n<161> last_motion_x = motion_x[k];\n<163> last_motion_y = motion_y[k];\n<173> motion_x[4] += motion_x[k];\n<175> motion_y[4] += motion_y[k];\n<183> motion_x[4]= RSHIFT(motion_x[4], 2);\n<187> motion_y[4]= RSHIFT(motion_y[4], 2);\n<229> last_motion_x = motion_x[0];\n<231> last_motion_y = motion_y[0];\n<265> s->all_fragments[current_fragment].motion_x = motion_x[k];\n<267> s->all_fragments[current_fragment].motion_y = motion_y[k];\n<271> s->all_fragments[current_fragment].motion_x = motion_x[0];\n<273> s->all_fragments[current_fragment].motion_y = motion_y[0];\n<287> s->all_fragments[current_fragment].motion_x = motion_x[k+4];\n<289> s->all_fragments[current_fragment].motion_y = motion_y[k+4];\n<293> s->all_fragments[current_fragment].motion_x = motion_x[0];\n<295> s->all_fragments[current_fragment].motion_y = motion_y[0];
<1> static void net_rx_packet(void *opaque, const uint8_t *buf, size_t size)\n<37> if (size > XC_PAGE_SIZE - NET_IP_ALIGN) {\n<49> memcpy(&rxreq, RING_GET_REQUEST(&netdev->rx_ring, rc), sizeof(rxreq));\n<61> if (page == NULL) {\n<67> net_rx_response(netdev, &rxreq, NETIF_RSP_ERROR, 0, 0, 0);\n<73> memcpy(page + NET_IP_ALIGN, buf, size);\n<77> net_rx_response(netdev, &rxreq, NETIF_RSP_OKAY, NET_IP_ALIGN, size, 0);
<1> static int xenfb_send_position(struct XenInput *xenfb,\n<11> memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n<33> return xenfb_kbd_event(xenfb, &event);
<1> build_rsdt(GArray *table_data, GArray *linker, GArray *table_offsets)\n<11> const int table_data_len = (sizeof(uint32_t) * table_offsets->len);\n<17> rsdt = acpi_data_push(table_data, rsdt_len);\n<19> memcpy(rsdt->table_offset_entry, table_offsets->data, table_data_len);\n<39> (void *)rsdt, "RSDT", rsdt_len, 1, NULL, NULL);
<1> static inline int mpeg4_decode_dc(MpegEncContext * s, int n, int *dir_ptr)\n<19> if (code < 0 || code > 9 /* && s->nbit<9 */){\n<21> fprintf(stderr, "illegal dc vlc\n");\n<39> if(s->error_resilience>=2){\n<41> fprintf(stderr, "dc marker bit missing\n");\n<53> pred = ff_mpeg4_pred_dc(s, n, &dc_val, dir_ptr);\n<59> if(s->error_resilience>=3){\n<61> fprintf(stderr, "dc<0 at %dx%d\n", s->mb_x, s->mb_y);\n<83> if(*dc_val > 2048 + s->y_dc_scale + s->c_dc_scale){\n<85> fprintf(stderr, "dc overflow at %dx%d\n", s->mb_x, s->mb_y);
<1> static mfxIMPL choose_implementation(const InputStream *ist)\n<41> for (i = 0; i < FF_ARRAY_ELEMS(impl_map); i++)\n<43> if (!strcmp(ist->hwaccel_device, impl_map[i].name)) {\n<45> impl = impl_map[i].impl;\n<53> impl = strtol(ist->hwaccel_device, NULL, 0);
<1> static int update_dimensions(VP8Context *s, int width, int height)\n<41> s->intra4x4_pred_mode_base = av_mallocz(s->b4_stride*(4*s->mb_height+1));\n<47> if (!s->macroblocks_base || !s->intra4x4_pred_mode_base || !s->top_nnz)\n<59> memset(s->intra4x4_pred_mode_base, DC_PRED, s->b4_stride);\n<63> s->intra4x4_pred_mode[i*s->b4_stride-1] = DC_PRED;
<1> static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n<13> if (!dev->conf.dinfo) {\n<15> fprintf(stderr, "%s: no drive specified\n", qdev->info->name);\n<31> if (bus->master) {\n<33> fprintf(stderr, "ide: tried to assign master twice\n");\n<45> if (bus->slave) {\n<47> fprintf(stderr, "ide: tried to assign slave twice\n");
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> PNGDecContext * const s = avctx -> priv_data ;\n<3> const uint8_t * buf = avpkt -> data ;\n<13> if ( buf_size < 8 || memcmp ( buf , ff_pngsig , 8 ) != 0 && memcmp ( buf , ff_mngsig , 8 ) != 0 ) return - 1 ;\n<14> bytestream2_init ( & s -> gb , buf + 8 , buf_size - 8 ) ;\n<15> s -> y = s -> state = 0 ;\n<16> s -> zstream . zalloc = ff_png_zalloc ;\n<17> s -> zstream . zfree = ff_png_zfree ;\n<18> s -> zstream . opaque = NULL ;\n<19> ret = inflateInit ( & s -> zstream ) ;\n<20> if ( ret != Z_OK ) return - 1 ;\n<101> if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) memcpy ( p -> data [ 1 ] , s -> palette , 256 * sizeof ( uint32_t ) ) ;\n<115> if ( png_decode_idat ( s , length ) < 0 ) goto fail ;\n<128> s -> palette [ i ] = ( 0xff << 24 ) | ( r << 16 ) | ( g << 8 ) | b ;\n<133> s -> palette [ i ] = ( 0xff << 24 ) ;\n<146> s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ;
<1> void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) {\n<5> mowgli_string_t * s = mowgli_string_create ( ) ;\n<7> * outbuffer = '\0' ;\n<8> if ( ( ! ( s1 ) || ( * ( s1 ) == '\0' ) ) ) {\n<37> s -> append_char ( s , c ) ;\n<40> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;
<1> DriveInfo *drive_init(QemuOpts *all_opts, BlockInterfaceType block_default_type)\n<155> if (qemu_opt_get(legacy_opts, "boot") != NULL) {\n<157> fprintf(stderr, "qemu-kvm: boot=on|off is deprecated and will be "\n<169> value = qemu_opt_get(legacy_opts, "media");\n<171> if (value) {\n<173> if (!strcmp(value, "disk")) {\n<175> media = MEDIA_DISK;\n<177> } else if (!strcmp(value, "cdrom")) {\n<179> media = MEDIA_CDROM;\n<181> read_only = true;\n<185> error_report("'%s' invalid media", value);\n<197> read_only |= qemu_opt_get_bool(legacy_opts, "read-only", false);\n<199> copy_on_read = qemu_opt_get_bool(legacy_opts, "copy-on-read", false);\n<203> if (read_only && copy_on_read) {\n<215> qstring_from_str(read_only ? "on" : "off"));\n<219> qstring_from_str(copy_on_read ? "on" :"off"));\n<225> value = qemu_opt_get(legacy_opts, "if");\n<227> if (value) {\n<231> type < IF_COUNT && strcmp(value, if_name[type]);\n<233> type++) {\n<239> error_report("unsupported bus type '%s'", value);\n<297> if (value != NULL) {\n<299> if (!cyls) {\n<309> if (!strcmp(value, "none")) {\n<311> translation = BIOS_ATA_TRANSLATION_NONE;\n<313> } else if (!strcmp(value, "lba")) {\n<315> translation = BIOS_ATA_TRANSLATION_LBA;\n<317> } else if (!strcmp(value, "auto")) {\n<319> translation = BIOS_ATA_TRANSLATION_AUTO;\n<323> error_report("'%s' invalid translation type", value);\n<333> if (media == MEDIA_CDROM) {\n<441> new_id = g_strdup_printf("%s%i%s%i", if_name[type], bus_id,
<1> int av_fifo_generic_read(AVFifoBuffer *f, int buf_size, void (*func)(void*, void*, int), void* dest)\n<5> int size = av_fifo_size(f);\n<15> int len = FFMIN(f->end - f->rptr, buf_size);\n<17> if(func) func(dest, f->rptr, len);\n<21> memcpy(dest, f->rptr, len);\n<23> dest = (uint8_t*)dest + len;\n<27> av_fifo_drain(f, len);
<1> static void test_copy(const AVCodec *c1, const AVCodec *c2)\n<7> printf("%s -> %s\nclosed:\n", c1 ? c1->name : "NULL", c2 ? c2->name : "NULL");\n<29> if (ctx1->codec) {\n<31> printf("opened:\n");
<1> static int aasc_decode_frame(AVCodecContext *avctx,\n<35> buf      += 4;\n<45> for (i = avctx->height - 1; i >= 0; i--) {\n<47> memcpy(s->frame.data[0] + i * s->frame.linesize[0], buf, avctx->width * 3);\n<49> buf += stride;
<7> Mpeg1Context *s1      = (Mpeg1Context *) s;\n<73> if (!pan_scan)\n<77> memcpy(pan_scan->data, &s1->pan_scan, sizeof(s1->pan_scan));\n<89> if (sd)\n<91> memcpy(sd->data, s1->a53_caption, s1->a53_caption_size);\n<93> av_freep(&s1->a53_caption);\n<125> if (!sd)
<1> void virtio_scsi_dataplane_start(VirtIOSCSI *s)\n<39> if (rc != 0) {\n<41> fprintf(stderr, "virtio-scsi: Failed to set guest notifiers (%d), "
<1> PXA2xxLCDState *pxa2xx_lcdc_init(MemoryRegion *sysmem,\n<41> switch (surface_bits_per_pixel(surface)) {\n<101> fprintf(stderr, "%s: Bad color depth\n", __FUNCTION__);
<1> static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n<7> char str[1024], key2[32], language[4] = {0};\n<143> ff_mov_lang_to_iso639(langcode, language);\n<177> if (parse)\n<199> if (*language && strcmp(language, "und")) {\n<201> snprintf(key2, sizeof(key2), "%s-%s", key, language);\n<203> av_dict_set(&c->fc->metadata, key2, str, 0);\n<209> av_dlog(c->fc, "lang \"%3s\" ", language);
<1> bool chal_reply_h ( connection_t * c ) {\n<2> char hishash [ MAX_STRING_SIZE ] ;\n<3> char myhash [ EVP_MAX_MD_SIZE ] ;\n<5> if ( sscanf ( c -> buffer , "%*d " MAX_STRING , hishash ) != 1 ) {\n<9> if ( strlen ( hishash ) != ( size_t ) EVP_MD_size ( c -> outdigest ) * 2 ) {\n<10> logger ( LOG_ERR , "Possible intruder %s (%s): %s" , c -> name , c -> hostname , "wrong challenge reply length" ) ;\n<11> return false ;\n<13> if ( ! hex2bin ( hishash , hishash , EVP_MD_size ( c -> outdigest ) ) ) {\n<21> if ( ! EVP_DigestInit ( ctx , c -> outdigest ) || ! EVP_DigestUpdate ( ctx , c -> hischallenge , RSA_size ( c -> rsa_key ) ) || ! EVP_DigestFinal ( ctx , ( unsigned char * ) myhash , NULL ) ) {\n<27> if ( memcmp ( hishash , myhash , EVP_MD_size ( c -> outdigest ) ) ) {\n<28> logger ( LOG_ERR , "Possible intruder %s (%s): %s" , c -> name , c -> hostname , "wrong challenge reply" ) ;\n<29> ifdebug ( SCARY_THINGS ) {\n<30> bin2hex ( myhash , hishash , SHA_DIGEST_LENGTH ) ;\n<31> hishash [ SHA_DIGEST_LENGTH * 2 ] = '\0' ;\n<32> logger ( LOG_DEBUG , "Expected challenge reply: %s" , hishash ) ;\n<34> return false ;\n<36> c -> allow_request = ACK ;\n<37> return send_ack ( c ) ;
<1> static void pxa2xx_ssp_write(void *opaque, hwaddr addr,\n<21> if (value & SSCR0_MOD)\n<23> printf("%s: Attempt to use network mode\n", __FUNCTION__);\n<25> if (s->enable && SSCR0_DSS(value) < 4)\n<27> printf("%s: Wrong data size: %i bits\n", __FUNCTION__,\n<29> SSCR0_DSS(value));\n<51> if (value & (SSCR1_LBM | SSCR1_EFWR))\n<53> printf("%s: Attempt to use SSP test mode\n", __FUNCTION__);
<1> static size_t write_to_port(VirtIOSerialPort *port,\n<3> const uint8_t *buf, size_t size)\n<47> for (i = 0; offset < size && i < elem.in_num; i++) {\n<49> len = MIN(elem.in_sg[i].iov_len, size - offset);\n<53> memcpy(elem.in_sg[i].iov_base, buf + offset, len);\n<55> offset += len;\n<59> virtqueue_push(vq, &elem, len);
<1> target_phys_addr_t omap_l4_attach(struct omap_target_agent_s *ta, int region,\n<19> if (region < 0 || region >= ta->regions) {\n<21> fprintf(stderr, "%s: bad io region (%i)\n", __FUNCTION__, region);
<1> int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)\n<7> const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n<13> if (!o)\n<17> if (!val || o->offset<=0)\n<23> if (o->type == FF_OPT_TYPE_BINARY) {\n<31> int len = strlen(val);\n<37> if (len & 1) return AVERROR(EINVAL);\n<45> int a = hexchar2int(*val++);\n<69> if (o->type != FF_OPT_TYPE_STRING) {\n<95> buf[i]=0;\n<101> const AVOption *o_named = av_opt_find(obj, buf, o->unit, 0, 0);\n<103> if (o_named && o_named->type == FF_OPT_TYPE_CONST)\n<107> else if (!strcmp(buf, "default")) d= o->default_val.dbl;\n<109> else if (!strcmp(buf, "max"    )) d= o->max;\n<111> else if (!strcmp(buf, "min"    )) d= o->min;\n<113> else if (!strcmp(buf, "none"   )) d= 0;\n<115> else if (!strcmp(buf, "all"    )) d= ~0;\n<119> int res = av_expr_parse_and_eval(&d, buf, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj);\n<121> if (res < 0) {\n<133> if (o->type == FF_OPT_TYPE_FLAGS) {\n<149> if ((ret = av_set_number2(obj, name, d, 1, 1, o_out)) < 0)\n<173> val= av_strdup(val);\n<179> memcpy(((uint8_t*)obj) + o->offset, &val, sizeof(val));
<1> static void buffered_flush(QEMUFileBuffered *s)\n<13> if (error != 0) {\n<15> DPRINTF("flush when error, bailing: %s\n", strerror(-error));\n<71> DPRINTF("flushed %zu of %zu byte(s)\n", offset, s->buffer_size);\n<73> memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);
<1> static int scsi_read_dvd_structure(SCSIDiskState *s, SCSIDiskReq *r,\n<3> uint8_t *outbuf)\n<65> if (format >= ARRAY_SIZE(rds_caps_size)) {\n<71> size = rds_caps_size[format];\n<73> memset(outbuf, 0, size);\n<107> stl_be_p(&outbuf[12], (nb_sectors >> 2) - 1); /* end sector */\n<109> stl_be_p(&outbuf[16], (nb_sectors >> 2) - 1); /* l0 end sector */\n<153> stw_be_p(&outbuf[size + 2], rds_caps_size[i]);\n<175> stw_be_p(outbuf, size - 2);
<1> static PGconn * connectDatabase ( const char * dbname , const char * connection_string , const char * pghost , const char * pgport , const char * pguser , trivalue prompt_password , bool fail_on_error ) {\n<7> const char * * keywords = NULL ;\n<8> const char * * values = NULL ;\n<14> char * err_msg = NULL ;\n<16> if ( keywords ) free ( keywords ) ;\n<17> if ( values ) free ( values ) ;\n<20> conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n<21> if ( conn_opts == NULL ) {\n<22> fprintf ( stderr , "%s: %s" , progname , err_msg ) ;\n<68> values [ i ] = dbname ;\n<71> keywords [ i ] = "fallback_application_name" ;\n<72> values [ i ] = progname ;\n<75> conn = PQconnectdbParams ( keywords , values , true ) ;\n<76> if ( ! conn ) {\n<77> fprintf ( stderr , _ ( "%s: could not connect to database \"%s\"\n" ) , progname , dbname ) ;\n<87> if ( PQstatus ( conn ) == CONNECTION_BAD ) {\n<88> if ( fail_on_error ) {\n<89> fprintf ( stderr , _ ( "%s: could not connect to database \"%s\": %s\n" ) , progname , dbname , PQerrorMessage ( conn ) ) ;\n<94> free ( keywords ) ;\n<95> free ( values ) ;\n<100> connstr = constructConnStr ( keywords , values ) ;\n<101> free ( keywords ) ;\n<102> free ( values ) ;\n<105> if ( ! remoteversion_str ) {\n<106> fprintf ( stderr , _ ( "%s: could not get server version\n" ) , progname ) ;\n<110> if ( server_version == 0 ) {\n<111> fprintf ( stderr , _ ( "%s: could not parse server version \"%s\"\n" ) , progname , remoteversion_str ) ;
<1> static int svq3_decode_mb ( SVQ3Context * s , unsigned int mb_type ) {\n<2> H264Context * h = & s -> h ;\n<32> if ( h -> mb_x > 0 && h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - 1 ] + 6 ] != - 1 ) {\n<42> if ( h -> mb_y > 0 ) {\n<43> memcpy ( h -> mv_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , h -> cur_pic . f . motion_val [ m ] [ b_xy - h -> b_stride ] , 4 * 2 * sizeof ( int16_t ) ) ;\n<44> memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 , 4 ) ;\n<47> h -> ref_cache [ m ] [ scan8 [ 0 ] + 4 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride + 1 ] + 6 ] == - 1 || h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n<52> h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride - 1 ] + 3 ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n<56> else memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 - 1 ] , PART_NOT_AVAILABLE , 8 ) ;\n<68> i < 4 ;\n<69> i ++ ) memset ( h -> cur_pic . f . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n<76> i < 4 ;\n<77> i ++ ) memset ( h -> cur_pic . f . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n<82> else if ( mb_type == 8 || mb_type == 33 ) {\n<83> memset ( h -> intra4x4_pred_mode_cache , - 1 , 8 * 5 * sizeof ( int8_t ) ) ;\n<106> left = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 1 ] ;\n<107> top = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 8 ] ;\n<118> i < 4 ;\n<119> i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_PRED , 4 ) ;\n<121> write_back_intra_pred_mode ( h ) ;\n<123> ff_h264_check_intra4x4_pred_mode ( h ) ;\n<129> i < 4 ;\n<130> i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_128_PRED , 4 ) ;\n<139> if ( ( h -> intra16x16_pred_mode = ff_h264_check_intra_pred_mode ( h , dir , 0 ) ) == - 1 ) {\n<148> i < 4 ;\n<149> i ++ ) memset ( h -> cur_pic . f . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n<152> i < 4 ;\n<153> i ++ ) memset ( h -> cur_pic . f . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n<156> if ( ! IS_INTRA4x4 ( mb_type ) ) {\n<157> memset ( h -> intra4x4_pred_mode + h -> mb2br_xy [ mb_xy ] , DC_PRED , 8 ) ;\n<159> if ( ! IS_SKIP ( mb_type ) || h -> pict_type == AV_PICTURE_TYPE_B ) {\n<160> memset ( h -> non_zero_count_cache + 8 , 0 , 14 * 8 * sizeof ( uint8_t ) ) ;\n<230> if ( IS_INTRA ( mb_type ) ) h -> chroma_pred_mode = ff_h264_check_intra_pred_mode ( h , DC_PRED8x8 , 1 ) ;
<1> static void vc1_decode_p_blocks(VC1Context *v)\n<65> memset(v->cbp_base, 0, sizeof(v->cbp_base[0])*2*s->mb_stride);\n<73> for (; s->mb_x < s->mb_width; s->mb_x++) {\n<81> vc1_decode_p_mb_intfi(v);\n<85> vc1_decode_p_mb_intfr(v);\n<87> else vc1_decode_p_mb(v);\n<91> vc1_apply_p_loop_filter(v);\n<109> memmove(v->cbp_base,      v->cbp,      sizeof(v->cbp_base[0])      * s->mb_stride);\n<111> memmove(v->ttblk_base,    v->ttblk,    sizeof(v->ttblk_base[0])    * s->mb_stride);\n<113> memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride);\n<115> memmove(v->luma_mv_base,  v->luma_mv,  sizeof(v->luma_mv_base[0])  * s->mb_stride);\n<133> vc1_apply_p_loop_filter(v);
<1> void pci_device_hot_add(Monitor *mon, const QDict *qdict)\n<9> const char *type = qdict_get_str(qdict, "type");\n<17> if (!strncmp(pci_addr, "pci_addr=", 9)) {\n<19> pci_addr += 9;\n<33> if (!strcmp(pci_addr, "auto"))\n<35> pci_addr = NULL;\n<39> if (strcmp(type, "nic") == 0) {\n<41> dev = qemu_pci_hot_add_nic(mon, pci_addr, opts);\n<43> } else if (strcmp(type, "storage") == 0) {\n<45> dev = qemu_pci_hot_add_storage(mon, pci_addr, opts);\n<49> monitor_printf(mon, "invalid type: %s\n", type);
<1> void arm_load_kernel(ARMCPU *cpu, struct arm_boot_info *info)\n<27> if (!info->kernel_filename) {\n<29> fprintf(stderr, "Kernel image must be specified\n");\n<85> kernel_size = load_elf(info->kernel_filename, NULL, NULL, &elf_entry,\n<93> kernel_size = load_uimage(info->kernel_filename, &entry, NULL,\n<103> kernel_size = load_image_targphys(info->kernel_filename, entry,\n<111> if (kernel_size < 0) {\n<113> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<137> if (initrd_size < 0) {\n<139> fprintf(stderr, "qemu: could not load initrd '%s'\n",\n<177> if (load_dtb(dtb_start, info)) {\n<189> if (info->ram_size >= (1ULL << 32)) {\n<191> fprintf(stderr, "qemu: RAM size must be less than 4GB to boot"\n<217> info->write_secondary_boot(cpu, info);\n<231> env->boot_info = info;
<1> static int av_transcode(AVFormatContext **output_files,\n<25> char error[1024];\n<97> ist->file_index = i;\n<99> ist->index = k;\n<123> for(i=0;i<nb_output_files;i++) {\n<127> if (!os->nb_streams) {\n<129> dump_format(output_files[i], i, output_files[i]->filename, 1);\n<131> fprintf(stderr, "Output file #%d does not contain any stream\n", i);\n<141> if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n<143> fprintf(stderr, "Number of stream maps must match number of output streams\n");\n<157> int si = stream_maps[i].stream_index;\n<161> if (fi < 0 || fi > nb_input_files - 1 ||\n<163> si < 0 || si > file_table[fi].nb_streams - 1) {\n<165> fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si);\n<173> si = stream_maps[i].sync_stream_index;\n<175> if (fi < 0 || fi > nb_input_files - 1 ||\n<177> si < 0 || si > file_table[fi].nb_streams - 1) {\n<179> fprintf(stderr,"Could not find sync stream #%d.%d\n", fi, si);\n<219> ost = ost_table[n];\n<221> ost->file_index = k;\n<223> ost->index = i;\n<237> if (ist_table[ost->source_index]->st->codec->codec_type != ost->st->codec->codec_type) {\n<243> fprintf(stderr, "Codec type mismatch for mapping #%d.%d -> #%d.%d\n",\n<339> if (!found) {\n<345> fprintf(stderr, "Could not find input stream matching output stream #%d.%d\n",\n<453> if(audio_volume != 256) {\n<455> fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");\n<533> if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n<535> fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");\n<599> if(avpicture_alloc((AVPicture*)&ost->pict_tmp, codec->pix_fmt,\n<603> fprintf(stderr, "Cannot allocate temp picture, check pix fmt\n");\n<627> if (ost->img_resample_ctx == NULL) {\n<629> fprintf(stderr, "Cannot get resampling context\n");\n<711> f = fopen(logfilename, "w");\n<713> if (!f) {\n<715> fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));\n<729> if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n<731> fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);\n<749> bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 200);\n<759> bit_buffer = av_malloc(bit_buffer_size);\n<761> if (!bit_buffer) {\n<763> fprintf(stderr, "Cannot allocate %d bytes output buffer\n",\n<791> snprintf(error, sizeof(error), "Encoder (codec id %d) not found for output stream #%d.%d",\n<803> snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",\n<837> snprintf(error, sizeof(error), "Decoder (codec id %d) not found for input stream #%d.%d",\n<849> snprintf(error, sizeof(error), "Error while opening decoder for input stream #%d.%d",\n<907> snprintf(error, sizeof(error), "Invalid output file index %d map_meta_data(%d,%d)",\n<919> snprintf(error, sizeof(error), "Invalid input file index %d map_meta_data(%d,%d)",\n<979> if (av_write_header(os) < 0) {\n<981> snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);\n<989> if (strcmp(output_files[i]->oformat->name, "rtp")) {\n<991> want_sdp = 0;\n<1015> if (verbose >= 0) {\n<1017> fprintf(stderr, "Stream mapping:\n");\n<1019> for(i=0;i<nb_ostreams;i++) {\n<1021> ost = ost_table[i];\n<1033> if (ost->sync_ist != ist_table[ost->source_index])\n<1041> fprintf(stderr, "\n");\n<1049> if (ret) {\n<1051> fprintf(stderr, "%s\n", error);\n<1067> if (!using_stdin && verbose >= 0) {\n<1069> fprintf(stderr, "Press [q] to stop encoding\n");\n<1135> ist = ist_table[ost->source_index];\n<1137> if(ist->is_past_recording_time || no_packet[ist->file_index])\n<1151> if(input_sync ) file_index = ist->file_index;\n<1159> if(!input_sync) file_index = ist->file_index;\n<1179> if(no_packet_count){\n<1183> memset(no_packet, 0, sizeof(no_packet));\n<1213> no_packet[file_index]=1;\n<1221> if (ret < 0) {\n<1239> memset(no_packet, 0, sizeof(no_packet));\n<1337> if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n<1341> if (verbose >= 0)\n<1343> fprintf(stderr, "Error while decoding stream #%d.%d\n",\n<1381> output_packet(ist, i, ost_table, nb_ostreams, NULL);\n<1477> av_free(ist);\n<1481> av_free(ist_table);\n<1519> av_free(ost);
<1> void vga_common_init(VGAState *s, DisplayState *ds, uint8_t *vga_ram_base,\n<57> vga_reset(s);\n<83> switch (vga_retrace_method) {\n<101> memset(&s->retrace_info, 0, sizeof (s->retrace_info));
<1> static void dv_decode_ac(DVVideoDecodeContext *s,\n<201> if (pos >= 64) {\n<229> if (pos >= 64) {\n<235> printf("error pos=%d\n", pos);\n<253> mb->pos = pos;
<1> int gs_main_finit ( gs_main_instance * minst , int exit_status , int code ) {\n<9> tempnames = gs_main_tempnames ( minst ) ;\n<32> if ( tempnames ) free ( tempnames ) ;\n<33> if ( gs_errorname ( i_ctx_p , code , & error_name ) >= 0 ) {\n<38> memcpy ( err_str , error_name . value . const_bytes , r_size ( & error_name ) ) ;\n<39> emprintf2 ( imemory , "ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n" , err_str , code ) ;\n<61> if ( gs_errorname ( i_ctx_p , code , & error_name ) >= 0 ) {\n<66> memcpy ( err_str , error_name . value . const_bytes , r_size ( & error_name ) ) ;\n<67> emprintf3 ( imemory , "ERROR: %s (%d) on closing %s device.\n" , err_str , code , dname ) ;
<1> make_setup_request (AVFormatContext *s, const char *host, int port,\n<69> for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n<71> int len = strlen(rt->rtsp_streams[rtx]->control_url);\n<73> if (len >= 4 &&\n<75> !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4, "/rtx"))\n<85> rtsp_st = rt->rtsp_streams[rtx];
<1> int ff_h264_execute_ref_pic_marking ( H264Context * h , MMCO * mmco , int mmco_count ) {\n<58> remove_short ( h , h -> short_ref [ 0 ] -> frame_num , 0 ) ;\n<73> if ( h -> short_ref_count && h -> short_ref [ 0 ] == h -> cur_pic_ptr ) {\n<86> if ( h -> short_ref_count ) memmove ( & h -> short_ref [ 1 ] , & h -> short_ref [ 0 ] , h -> short_ref_count * sizeof ( Picture * ) ) ;\n<92> if ( h -> long_ref_count + h -> short_ref_count - ( h -> short_ref [ 0 ] == h -> cur_pic_ptr ) > h -> sps . ref_frame_count ) {
<1> static int ztype ( i_ctx_t * i_ctx_p ) {\n<9> if ( op [ - 1 ] . value . pstruct != 0x00 ) {\n<10> const char * sname = gs_struct_type_name_string ( gs_object_type ( imemory , op [ - 1 ] . value . pstruct ) ) ;\n<11> int code = name_ref ( imemory , ( const byte * ) sname , strlen ( sname ) , ( ref * ) ( op - 1 ) , 0 ) ;
<1> const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){\n<15> h->nal_unit_type= src[0]&0x1F;\n<19> src++; length--;\n<57> if(i>0 && src[i-1]==0) i--;\n<61> if(i+2<length && src[i+1]==0 && src[i+2]<=3){\n<63> if(src[i+2]!=3){\n<81> if(i>=length-1){ //no escaped 0\n<101> if (dst == NULL){\n<111> memcpy(dst, src, i);\n<113> si=di=i;\n<119> if(src[si+2]>3){\n<121> dst[di++]= src[si++];\n<123> dst[di++]= src[si++];\n<125> }else if(src[si]==0 && src[si+1]==0){\n<127> if(src[si+2]==3){ //escape\n<131> dst[di++]= 0;\n<145> dst[di++]= src[si++];\n<151> dst[di++]= src[si++];\n<157> memset(dst+di, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<167> return dst;
<1> static int write_elf32_load(DumpState *s, MemoryMapping *memory_mapping,\n<15> memset(&phdr, 0, sizeof(Elf32_Phdr));\n<41> ret = fd_write_vmcore(&phdr, sizeof(Elf32_Phdr), s);
<1> command_loop(void)\n<15> for (i = 0; !done && i < ncmdline; i++) {\n<17> input = strdup(cmdline[i]);\n<19> if (!input) {\n<23> _("cannot strdup command '%s': %s\n"),\n<25> cmdline[i], strerror(errno));\n<31> v = breakline(input, &c);\n<35> ct = find_command(v[0]);\n<37> if (ct) {\n<55> fprintf(stderr, _("command \"%s\" not found\n"),\n<61> doneline(input, v);\n<65> if (cmdline) {\n<67> free(cmdline);\n<79> v = breakline(input, &c);\n<83> ct = find_command(v[0]);\n<85> if (ct)\n<91> fprintf(stderr, _("command \"%s\" not found\n"),\n<97> doneline(input, v);
<1> static int rv34_decode_macroblock(RV34DecContext *r, int8_t *intra_types)\n<25> memset(r->avail_cache, 0, sizeof(r->avail_cache));\n<27> fill_rectangle(r->avail_cache + 5, 2, 2, 4, 1, 4);\n<55> cbp = cbp2 = rv34_decode_mb_header(r, intra_types);\n<67> r->deblock_coefs[mb_pos] = rv34_set_deblock_coef(r);\n<81> if(r->is16){\n<83> memset(block16, 0, sizeof(block16));\n<85> rv34_decode_block(block16, gb, r->cur_vlcs, 3, 0);\n<139> rv34_output_macroblock(r, intra_types, cbp2, r->is16);\n<143> rv34_apply_differences(r, cbp2);
<1> static QemuOpt *qemu_opt_find(QemuOpts *opts, const char *name)\n<9> TAILQ_FOREACH(opt, &opts->head, next) {\n<11> if (strcmp(opt->name, name) != 0)\n<15> return opt;
<1> static char *regname(uint32_t addr)\n<5> static char buf[16];\n<7> if (addr < PCI_IO_SIZE) {\n<9> const char *r = reg[addr / 4];\n<11> if (r != 0) {\n<13> sprintf(buf, "%s+%u", r, addr % 4);\n<17> sprintf(buf, "0x%02x", addr);\n<23> sprintf(buf, "??? 0x%08x", addr);\n<27> return buf;
<1> CPUSPARCState *cpu_sparc_init(void)\n<13> if (!(env = malloc(sizeof(CPUSPARCState))))\n<15> return (NULL);\n<17> memset(env, 0, sizeof(*env));\n<19> env->cwp = 0;\n<21> env->wim = 1;\n<23> env->regwptr = env->regbase + (env->cwp * 16);\n<25> env->access_type = ACCESS_DATA;\n<35> env->psrs = 1;\n<37> env->pc = 0x4000;\n<39> env->npc = env->pc + 4;\n<41> env->mmuregs[0] = (0x10<<24) | MMU_E; /* Impl 1, ver 0, MMU Enabled */\n<43> env->mmuregs[1] = 0x3000 >> 4; /* MMU Context table */\n<47> cpu_single_env = env;\n<49> return (env);
<1> static void vga_update_text(void *opaque, console_ch_t *chardata)\n<107> if (!full_update)\n<113> snprintf(msg_buffer, sizeof(msg_buffer), "%i x %i Text mode",\n<275> if (!full_update)\n<283> snprintf(msg_buffer, sizeof(msg_buffer), "%i x %i Graphic mode",\n<293> if (!full_update)\n<299> snprintf(msg_buffer, sizeof(msg_buffer), "VGA Blank mode");\n<325> size = strlen(msg_buffer);\n<327> width = (s->last_width - size) / 2;\n<333> console_write_ch(dst ++, 0x00200100 | msg_buffer[i]);
<1> static int libopus_encode(AVCodecContext *avctx, AVPacket *avpkt,\n<29> if (frame->nb_samples < opus->opts.packet_size) {\n<31> audio = opus->samples;\n<33> memcpy(audio, frame->data[0], frame->nb_samples * sample_size);\n<41> if (!opus->afq.remaining_samples)\n<45> audio = opus->samples;\n<47> memset(audio, 0, opus->opts.packet_size * sample_size);\n<67> ret = opus_multistream_encode_float(opus->enc, (float *)audio,\n<75> ret = opus_multistream_encode(opus->enc, (opus_int16 *)audio,
<1> static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n<33> for (ent = qdict_first(dict); ent;\n<35> ent = qdict_next(dict, ent)) {\n<37> arg_name = qdict_entry_key(ent);\n<43> if (!strcmp(arg_name, "execute")) {\n<45> if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n<57> } else if (strcmp(arg_name, "arguments")) {\n<59> error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n<61> return NULL;
<1> static int xmlHashGrow ( xmlHashTablePtr table , int size ) {\n<12> if ( oldtable == NULL ) return ( - 1 ) ;\n<14> if ( table -> table == NULL ) {\n<18> memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n<23> if ( oldtable [ i ] . valid == 0 ) continue ;\n<24> key = xmlHashComputeKey ( table , oldtable [ i ] . name , oldtable [ i ] . name2 , oldtable [ i ] . name3 ) ;\n<25> memcpy ( & ( table -> table [ key ] ) , & ( oldtable [ i ] ) , sizeof ( xmlHashEntry ) ) ;\n<31> iter = oldtable [ i ] . next ;\n<34> key = xmlHashComputeKey ( table , iter -> name , iter -> name2 , iter -> name3 ) ;\n<35> if ( table -> table [ key ] . valid == 0 ) {\n<36> memcpy ( & ( table -> table [ key ] ) , iter , sizeof ( xmlHashEntry ) ) ;\n<38> xmlFree ( iter ) ;\n<41> iter -> next = table -> table [ key ] . next ;\n<48> xmlFree ( oldtable ) ;
<1> static int img_snapshot(int argc, char **argv)\n<137> switch(action) {\n<149> memset(&sn, 0, sizeof(sn));\n<163> ret = bdrv_snapshot_create(bs, &sn);\n<165> if (ret) {\n<167> error_report("Could not create snapshot '%s': %d (%s)",\n<169> snapshot_name, ret, strerror(-ret));\n<181> if (ret) {\n<183> error_report("Could not apply snapshot '%s': %d (%s)",\n<185> snapshot_name, ret, strerror(-ret));\n<197> if (ret) {\n<199> error_report("Could not delete snapshot '%s': %d (%s)",\n<201> snapshot_name, ret, strerror(-ret));
<1> static void mipsnet_receive(void *opaque, const uint8_t *buf, size_t size)\n<5> MIPSnetState *s = opaque;\n<15> if (!mipsnet_can_receive(opaque))\n<31> memcpy(s->rx_buffer, buf, size);\n<35> s->rx_count = size;\n<45> mipsnet_update_irq(s);
<1> static void bootp_reply(const struct bootp_t *bp)\n<25> dhcp_decode(bp, &dhcp_msg_type, &preq_addr);\n<53> memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n<57> if ((m = m_get()) == NULL)\n<63> rbp = (struct bootp_t *)m->m_data;\n<67> memset(rbp, 0, sizeof(struct bootp_t));\n<75> bc = request_addr(preq_addr, client_ethaddr);\n<85> if (!bc) {\n<91> if (!bc) {\n<101> memcpy(bc->macaddr, client_ethaddr, 6);\n<103> } else if (preq_addr) {\n<105> bc = request_addr(preq_addr, client_ethaddr);\n<107> if (bc) {\n<111> memcpy(bc->macaddr, client_ethaddr, 6);\n<121> bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n<123> if (!bc) {\n<137> saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n<155> memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n<165> q = rbp->bp_vend;\n<167> memcpy(q, rfc1533_cookie, 4);\n<169> q += 4;\n<173> if (bc) {\n<205> snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), "%s",\n<213> *q++ = 4;\n<215> memcpy(q, &saddr.sin_addr, 4);\n<217> q += 4;\n<235> if (!slirp_restrict) {\n<239> *q++ = 4;\n<241> memcpy(q, &saddr.sin_addr, 4);\n<243> q += 4;\n<249> *q++ = 4;\n<251> dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n<253> memcpy(q, &dns_addr, 4);\n<255> q += 4;\n<263> *q++ = 4;\n<265> val = htonl(LEASE_TIME);\n<267> memcpy(q, &val, 4);\n<269> q += 4;\n<273> if (*slirp_hostname) {\n<275> val = strlen(slirp_hostname);\n<279> *q++ = val;\n<281> memcpy(q, slirp_hostname, val);\n<283> q += val;\n<307> *q++ = sizeof(nak_msg) - 1;\n<309> memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n<311> q += sizeof(nak_msg) - 1;\n<327> udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);
<1> sorecvfrom(so)\n<3> struct socket *so;\n<9> int addrlen = sizeof(struct sockaddr_in);\n<19> if (so->so_type == IPPROTO_ICMP) {   /* This is a "ping" reply */\n<21> char buff[256];\n<35> if(len == -1 || len == 0) {\n<41> if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n<43> else if(errno == ENETUNREACH) code=ICMP_UNREACH_NET;\n<49> errno,strerror(errno)));\n<51> icmp_error(so->so_m, ICMP_UNREACH,code, 0,strerror(errno));\n<63> udp_detach(so);\n<73> if (!(m = m_get())) return;\n<75> m->m_data += IF_MAXLINKHDR;\n<87> len = M_FREEROOM(m);\n<91> ioctlsocket(so->s, FIONREAD, &n);\n<95> if (n > len) {\n<97> n = (m->m_data - m->m_dat) + m->m_len + n + 1;\n<101> len = M_FREEROOM(m);\n<113> DEBUG_MISC((dfd, " did recvfrom %d, errno = %d-%s\n",\n<115> m->m_len, errno,strerror(errno)));\n<117> if(m->m_len<0) {\n<123> if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n<125> else if(errno == ENETUNREACH) code=ICMP_UNREACH_NET;\n<129> DEBUG_MISC((dfd," rx error, tx icmp ICMP_UNREACH:%i\n", code));\n<131> icmp_error(so->so_m, ICMP_UNREACH,code, 0,strerror(errno));\n<133> m_free(m);\n<183> udp_output(so, m, &addr);
<1> int ff_rtsp_connect(AVFormatContext *s)\n<63> while (option_list) {\n<67> option = ++option_list;\n<69> option_list = strchr(option_list, '&');\n<73> *option_list = 0;\n<79> if (!strcmp(option, "udp")) {\n<81> lower_transport_mask |= (1<< RTSP_LOWER_TRANSPORT_UDP);\n<83> } else if (!strcmp(option, "multicast")) {\n<85> lower_transport_mask |= (1<< RTSP_LOWER_TRANSPORT_UDP_MULTICAST);\n<87> } else if (!strcmp(option, "tcp")) {\n<89> lower_transport_mask |= (1<< RTSP_LOWER_TRANSPORT_TCP);\n<91> } else if(!strcmp(option, "http")) {\n<93> lower_transport_mask |= (1<< RTSP_LOWER_TRANSPORT_TCP);\n<95> rt->control_transport = RTSP_MODE_TUNNEL;\n<103> int len = strlen(option);\n<105> memmove(++filename, option, len);\n<107> filename += len;\n<109> if (option_list) *filename = '&';
<1> static int spice_chr_write(CharDriverState *chr, const uint8_t *buf, int len)\n<9> vmc_register_interface(s);\n<13> if (s->bufsize < len) {\n<17> s->buffer = g_realloc(s->buffer, s->bufsize);\n<21> memcpy(s->buffer, buf, len);\n<23> s->datapos = s->buffer;\n<25> s->datalen = len;\n<29> return len;
<1> static PCIDevice *qemu_pci_hot_add_storage(Monitor *mon,\n<19> if (get_param_value(buf, sizeof(buf), "if", opts)) {\n<21> if (!strcmp(buf, "scsi"))\n<23> type = IF_SCSI;\n<25> else if (!strcmp(buf, "virtio")) {\n<27> type = IF_VIRTIO;\n<31> monitor_printf(mon, "type %s not a hotpluggable PCI device.\n", buf);\n<33> return NULL;\n<47> if (get_param_value(buf, sizeof(buf), "file", opts)) {
<1> static void term_completion(void)\n<17> if (!cmdline)\n<21> memcpy(cmdline, term_cmd_buf, term_cmd_buf_index);\n<25> find_completion(cmdline);\n<37> if (nb_completions == 1) {\n<39> len = strlen(completions[0]);\n<41> for(i = completion_index; i < len; i++) {\n<59> for(i = 0; i < nb_completions; i++) {\n<61> len = strlen(completions[i]);\n<63> if (len > max_width)\n<85> term_printf("%-*s", max_width, completions[i]);
<1> static int decode_slice_header(H264Context *h){\n<105> init_dequant_tables(h);\n<139> free_tables(h);\n<153> if(s->dsp.h264_idct_add == ff_h264_idct_add_c){ //FIXME little ugly\n<155> memcpy(h->zigzag_scan, zigzag_scan, 16*sizeof(uint8_t));\n<157> memcpy(h-> field_scan,  field_scan, 16*sizeof(uint8_t));\n<177> h->zigzag_scan_q0 = zigzag_scan;\n<179> h->field_scan_q0 = field_scan;\n<183> h->zigzag_scan_q0 = h->zigzag_scan;\n<185> h->field_scan_q0 = h->field_scan;\n<191> alloc_tables(h);\n<219> frame_start(h);\n<323> init_poc(h);\n<381> fill_default_ref_list(h);\n<387> if(decode_ref_pic_list_reordering(h) < 0)\n<397> pred_weight_table(h);\n<401> implicit_weight_table(h);\n<411> decode_ref_pic_marking(h);
<1> static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n<43> sd_set_sdstatus(sd);\n<59> memset(sd->function_group, 0, sizeof(int) * 6);
<1> static void ref405ep_init (ram_addr_t ram_size,\n<147> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<161> if (bios_size < 0 || bios_size > BIOS_SIZE) {\n<163> fprintf(stderr, "qemu: could not load PowerPC bios '%s'\n",\n<203> if (linux_boot) {\n<211> memset(&bd, 0, sizeof(bd));\n<261> bdloc = ppc405_set_bootinfo(env, &bd, 0x00000001);\n<269> kernel_size = load_image_targphys(kernel_filename, kernel_base,\n<273> if (kernel_size < 0) {\n<275> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<293> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<297> if (initrd_size < 0) {\n<299> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<319> if (kernel_cmdline != NULL) {\n<321> len = strlen(kernel_cmdline);\n<323> bdloc -= ((len + 255) & ~255);\n<325> cpu_physical_memory_write(bdloc, (void *)kernel_cmdline, len + 1);\n<329> env->gpr[7] = bdloc + len;\n<351> bdloc = 0;\n<361> printf("bdloc %016lx\n", (unsigned long)bdloc);
<1> static void pc_init1(ram_addr_t ram_size,\n<159> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<181> ret = rom_add_file_fixed(bios_name, (uint32_t)(-bios_size));\n<183> if (ret != 0) {\n<187> fprintf(stderr, "qemu: could not load PC BIOS '%s'\n", bios_name);\n<311> if (pci_enabled)\n<317> fprintf(stderr, "%s: vmware_vga: no PCI bus\n", __FUNCTION__);\n<391> for(i = 0; i < nb_nics; i++) {\n<393> NICInfo *nd = &nd_table[i];\n<397> if (!pci_enabled || (nd->model && strcmp(nd->model, "ne2k_isa") == 0))\n<399> pc_init_ne2k_isa(nd);\n<403> pci_nic_init_nofail(nd, "e1000", NULL);\n<409> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<411> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static int sbr_lf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_low [ 32 ] [ 40 ] [ 2 ] , const float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n<5> memset ( X_low , 0 , 32 * sizeof ( * X_low ) ) ;
<1> static int decode_frame_header ( ProresContext * ctx , const uint8_t * buf , const int data_size , AVCodecContext * avctx ) {\n<56> if ( flags & 2 ) {\n<57> if ( ptr - buf > hdr_size - 64 ) {\n<61> if ( memcmp ( ctx -> qmat_luma , ptr , 64 ) ) {\n<62> memcpy ( ctx -> qmat_luma , ptr , 64 ) ;\n<63> ctx -> qmat_changed = 1 ;\n<65> ptr += 64 ;\n<68> memset ( ctx -> qmat_luma , 4 , 64 ) ;\n<71> if ( flags & 1 ) {\n<72> if ( ptr - buf > hdr_size - 64 ) {\n<76> if ( memcmp ( ctx -> qmat_chroma , ptr , 64 ) ) {\n<77> memcpy ( ctx -> qmat_chroma , ptr , 64 ) ;\n<78> ctx -> qmat_changed = 1 ;\n<82> memset ( ctx -> qmat_chroma , 4 , 64 ) ;
<1> static uint8_t checkBaseExtUnicode ( UCMStates * baseStates , UCMTable * base , UCMTable * ext , UBool moveToExt , UBool intersectBase ) {\n<42> if ( moveToExt ) {\n<47> fprintf ( stderr , "ucm error: the base table contains a mapping whose input sequence\n" " is a prefix of the input sequence of an extension mapping\n" ) ;\n<48> ucm_printMapping ( base , mb , stderr ) ;\n<49> ucm_printMapping ( ext , me , stderr ) ;\n<60> else if ( intersectBase ) {\n<65> fprintf ( stderr , "ucm error: the base table contains a mapping whose input sequence\n" " is the same as the input sequence of an extension mapping\n" " but it maps differently\n" ) ;\n<66> ucm_printMapping ( base , mb , stderr ) ;\n<67> ucm_printMapping ( ext , me , stderr ) ;
<1> static int asf_read_header(AVFormatContext *s)\n<5> ASFContext *asf = s->priv_data;\n<19> if (ff_guidcmp(&g, &ff_asf_header))\n<31> memset(&asf->asfid2avid, -1, sizeof(asf->asfid2avid));\n<273> if (asf->streams[i].stream_language_index < 128) {\n<275> const char *rfc1766 = asf->stream_languages[asf->streams[i].stream_language_index];\n<277> if (rfc1766 && strlen(rfc1766) > 1) {\n<279> const char primary_tag[3] = { rfc1766[0], rfc1766[1], '\0' }; // ignore country code if any\n<281> const char *iso6392       = av_convert_lang_to(primary_tag,\n<285> if (iso6392)
<1> ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,\n<29> if (mem_path) {\n<45> fprintf(stderr, "-mem-path option unsupported\n");
<1> static int _setup_resv_limits ( slurmdb_reservation_rec_t * resv , char * * cols , char * * vals , char * * extra ) {\n<2> if ( resv -> assocs ) {\n<4> int len = strlen ( resv -> assocs ) - 1 ;\n<5> if ( strchr ( resv -> assocs , '-' ) ) {\n<6> int i = 0 , i2 = 0 ;\n<7> char * assocs = xmalloc ( sizeof ( char ) * len ) ;\n<8> while ( i < len ) {\n<19> xfree ( resv -> assocs ) ;\n<20> len = i2 - 1 ;\n<21> resv -> assocs = assocs ;\n<22> assocs = NULL ;\n<27> xstrfmtcat ( * vals , ", '%s'" , resv -> assocs + start ) ;\n<28> xstrfmtcat ( * extra , ", assoclist='%s'" , resv -> assocs + start ) ;
<1> e1000_receive(VLANClientState *nc, const uint8_t *buf, size_t size)\n<39> if (!receive_filter(s, buf, size))\n<45> if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n<49> memmove((uint8_t *)buf + 4, buf, 12);\n<87> cpu_physical_memory_write(le64_to_cpu(desc.buffer_addr),\n<89> (void *)(buf + vlan_offset), size);
<1> static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n<5> krb5_data ap_req , ap_rep = empty_data ( ) ;\n<6> krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ;\n<15> char * clientstr = NULL , * targetstr = NULL ;\n<22> krb5_address * addr = remote_faddr -> address ;\n<27> strlcpy ( strresult , "Request was truncated" , sizeof ( strresult ) ) ;\n<36> strlcpy ( strresult , "Request length was inconsistent" , sizeof ( strresult ) ) ;\n<44> snprintf ( strresult , sizeof ( strresult ) , "Request contained unknown protocol version number %d" , vno ) ;\n<52> strlcpy ( strresult , "Request was truncated in AP-REQ" , sizeof ( strresult ) ) ;\n<60> strlcpy ( strresult , "Failed initializing auth context" , sizeof ( strresult ) ) ;\n<64> if ( ret ) {\n<66> strlcpy ( strresult , "Failed initializing auth context" , sizeof ( strresult ) ) ;\n<69> ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , "kadmin" , "changepw" , NULL ) ;\n<72> strlcpy ( strresult , "Failed building kadmin/changepw principal" , sizeof ( strresult ) ) ;\n<78> strlcpy ( strresult , "Failed reading application request" , sizeof ( strresult ) ) ;\n<84> strlcpy ( strresult , "Failed replying to application request" , sizeof ( strresult ) ) ;\n<89> ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ;\n<92> strlcpy ( strresult , "Failed decrypting request" , sizeof ( strresult ) ) ;\n<98> ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ;\n<99> if ( ret != 0 ) {\n<101> strlcpy ( strresult , "Failed decoding ChangePasswdData" , sizeof ( strresult ) ) ;\n<105> clear = * clear_data ;\n<106> free ( clear_data ) ;\n<108> ret = krb5_unparse_name ( context , target , & targetstr ) ;\n<111> strlcpy ( strresult , "Failed unparsing target name for log" , sizeof ( strresult ) ) ;\n<116> ret = krb5_unparse_name ( context , client , & clientstr ) ;\n<119> strlcpy ( strresult , "Failed unparsing client name for log" , sizeof ( strresult ) ) ;\n<122> if ( vno == 1 && ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) {\n<124> strlcpy ( strresult , "Ticket must be derived from a password" , sizeof ( strresult ) ) ;\n<128> ret = schpw_util_wrapper ( server_handle , client , target , ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , ptr , NULL , strresult , sizeof ( strresult ) ) ;\n<132> clear = empty_data ( ) ;\n<133> clen = strlen ( clientstr ) ;\n<134> trunc_name ( & clen , & cdots ) ;\n<135> switch ( addr -> addrtype ) {\n<137> struct sockaddr_in * sin = ss2sin ( & ss ) ;\n<139> memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ;\n<145> struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ;\n<147> memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ;\n<164> if ( target == NULL ) {\n<165> tlen = clen ;\n<170> tlen = strlen ( targetstr ) ;\n<171> trunc_name ( & tlen , & tdots ) ;\n<172> targetp = clientstr ;\n<174> krb5_klog_syslog ( LOG_NOTICE , _ ( "setpw request from %s by %.*s%s for " "%.*s%s: %s" ) , addrbuf , ( int ) clen , clientstr , cdots , ( int ) tlen , targetp , tdots , errmsg ? errmsg : "success" ) ;\n<177> krb5_klog_syslog ( LOG_NOTICE , _ ( "chpw request from %s for %.*s%s: %s" ) , addrbuf , ( int ) clen , clientstr , cdots , errmsg ? errmsg : "success" ) ;\n<185> strlcpy ( strresult , "" , sizeof ( strresult ) ) ;\n<190> chpwfail : clear . length = 2 + strlen ( strresult ) ;\n<191> clear . data = ( char * ) malloc ( clear . length ) ;\n<192> ptr = clear . data ;\n<194> * ptr ++ = numresult & 0xff ;\n<195> memcpy ( ptr , strresult , strlen ( strresult ) ) ;\n<196> cipher = empty_data ( ) ;\n<204> ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ;\n<211> if ( cipher . length == 0 ) {\n<212> if ( ap_rep . length ) {\n<213> free ( ap_rep . data ) ;\n<214> ap_rep = empty_data ( ) ;\n<220> if ( ret ) goto bailout ;\n<225> ret = krb5_build_principal ( context , & krberror . server , strlen ( realm ) , realm , "kadmin" , "changepw" , NULL ) ;\n<228> krberror . e_data = clear ;\n<234> if ( ret ) goto bailout ;\n<241> * ptr ++ = ap_rep . length & 0xff ;\n<242> if ( ap_rep . length ) {\n<243> memcpy ( ptr , ap_rep . data , ap_rep . length ) ;\n<244> ptr += ap_rep . length ;\n<246> memcpy ( ptr , cipher . data , cipher . length ) ;\n<250> free ( ap_rep . data ) ;\n<251> free ( clear . data ) ;\n<252> free ( cipher . data ) ;\n<254> krb5_free_unparsed_name ( context , targetstr ) ;
<1> static QDictEntry *qdict_find(const QDict *qdict,\n<3> const char *key, unsigned int hash)\n<11> LIST_FOREACH(entry, &qdict->table[hash], next)\n<13> if (!strcmp(entry->key, key))\n<15> return entry;\n<19> return NULL;
<1> static int vdi_check(BlockDriverState *bs, BdrvCheckResult *res)\n<19> bmap = g_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n<21> memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n<37> if (!VDI_IS_ALLOCATED(bmap[bmap_entry])) {\n<79> g_free(bmap);
<1> static void numa_add(const char *optarg)\n<15> optarg = get_opt_name(option, 128, optarg, ',') + 1;\n<17> if (!strcmp(option, "node")) {\n<19> if (get_param_value(option, 128, "nodeid", optarg) == 0) {\n<31> if (get_param_value(option, 128, "mem", optarg) == 0) {\n<41> if (sval < 0 || *endptr) {\n<43> fprintf(stderr, "qemu: invalid numa mem size: %s\n", optarg);\n<53> if (get_param_value(option, 128, "cpus", optarg) == 0) {\n<61> if (value >= 64) {\n<65> fprintf(stderr, "only 64 CPUs in NUMA mode supported.\n");\n<73> if (endvalue >= 63) {\n<97> nb_numa_nodes++;
<1> static int mov_rewrite_dvd_sub_extradata(AVStream *st)\n<23> for (i = 0; i < 16; i++) {\n<35> pal_s_pos = strlen(pal_s);\n<37> if (pal_s_pos >= sizeof(pal_s))\n<45> snprintf(buf, sizeof(buf), "size: %dx%d\npalette: %s\n",\n<51> av_freep(&st->codec->extradata);\n<55> st->codec->extradata = av_mallocz(strlen(buf) + FF_INPUT_BUFFER_PADDING_SIZE);\n<57> if (!st->codec->extradata)\n<61> st->codec->extradata_size = strlen(buf);\n<63> memcpy(st->codec->extradata, buf, st->codec->extradata_size);
<1> static void opt_new_stream(const char *opt, const char *arg)\n<7> if (nb_output_files <= 0) {\n<9> fprintf(stderr, "At least one output file must be specified\n");\n<19> if      (!strcmp(opt, "newvideo"   )) new_video_stream   (oc);\n<21> else if (!strcmp(opt, "newaudio"   )) new_audio_stream   (oc);\n<23> else if (!strcmp(opt, "newsubtitle")) new_subtitle_stream(oc);\n<25> else assert(0);
<1> static void flat_print_str(WriterContext *wctx, const char *key, const char *value)\n<15> printf("%s=", flat_escape_key_str(&buf, key, flat->sep));\n<19> printf("\"%s\"\n", flat_escape_value_str(&buf, value));
<1> static int usb_audio_handle_data(USBDevice *dev, USBPacket *p)\n<19> ret = usb_audio_handle_dataout(s, p);\n<43> if (ret == USB_RET_STALL && s->debug) {\n<45> fprintf(stderr, "usb-audio: failed data transaction: "
<1> static void input_linux_event_mouse(void *opaque)\n<19> if (rc < 0 && errno != EAGAIN) {\n<21> fprintf(stderr, "%s: read: %s\n", __func__, strerror(errno));
<1> static int decode_dvd_subtitles(AVSubtitle *sub_header,\n<23> if (buf_size < 10)\n<27> memset(sub_header, 0, sizeof(*sub_header));\n<279> if (sub_header->rects != NULL) {\n<281> for (i = 0; i < sub_header->num_rects; i++) {\n<291> av_freep(&sub_header->rects);\n<363> if (sub_header->num_rects > 0)\n<369> if (sub_header->rects != NULL) {\n<371> for (i = 0; i < sub_header->num_rects; i++) {\n<381> av_freep(&sub_header->rects);
<1> void vnc_display_init(const char *id)\n<9> if (vnc_display_find(id) != NULL) {\n<19> vs->id = strdup(id);\n<21> QTAILQ_INSERT_TAIL(&vnc_displays, vs, next);
<149> if (!exp) {\n<183> if (exp->description) {\n<185> size_t len = strlen(exp->description);\n<189> rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION,
<1> void *lsi_scsi_init(PCIBus *bus, int devfn)\n<13> if (s == NULL) {\n<15> fprintf(stderr, "lsi-scsi: Failed to register PCI device\n");
<1> void mips_malta_init(QEMUMachineInitArgs *args)\n<111> if (cpu == NULL) {\n<113> fprintf(stderr, "Unable to find CPU definition\n");\n<141> if (ram_size > (256 << 20)) {\n<147> ((unsigned int)ram_size / (1 << 20)));\n<247> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<263> if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n<323> if (!rom_copy(memory_region_get_ram_ptr(bios_copy),\n<327> memcpy(memory_region_get_ram_ptr(bios_copy),\n<329> memory_region_get_ram_ptr(bios), bios_size);
<1> static void usb_xhci_realize(struct PCIDevice *dev, Error **errp)\n<25> if (strcmp(object_get_typename(OBJECT(dev)), TYPE_NEC_XHCI) == 0) {\n<27> xhci->nec_quirks = true;
<1> int decodenetnum ( const char * num , sockaddr_u * netnum ) {\n<2> struct addrinfo hints , * ai = NULL ;\n<10> REQUIRE ( num != NULL ) ;\n<11> REQUIRE ( strlen ( num ) < sizeof ( name ) ) ;\n<13> if ( '[' != num [ 0 ] ) {\n<14> pp = strchr ( num , ':' ) ;\n<15> if ( NULL == pp ) cp = num ;\n<16> else if ( NULL != strchr ( pp + 1 , ':' ) ) cp = num ;\n<18> strlcpy ( name , num , sizeof ( name ) ) ;\n<19> cp = name ;\n<20> pp = strchr ( cp , ':' ) ;\n<21> * pp = '\0' ;\n<22> port_str = pp + 1 ;\n<26> cp = num + 1 ;\n<35> err = getaddrinfo ( cp , "ntp" , & hints , & ai ) ;\n<36> if ( err != 0 ) return 0 ;\n<37> INSIST ( ai -> ai_addrlen <= sizeof ( * netnum ) ) ;\n<38> ZERO ( * netnum ) ;\n<39> memcpy ( netnum , ai -> ai_addr , ai -> ai_addrlen ) ;\n<40> freeaddrinfo ( ai ) ;\n<41> if ( NULL == port_str || 1 != sscanf ( port_str , "%hu" , & port ) ) port = NTP_PORT ;\n<42> SET_PORT ( netnum , port ) ;
<1> static CharDriverState *qmp_chardev_open_socket(const char *id,\n<37> if (!chr) {\n<149> chr->filename = SocketAddress_to_str("disconnected:",\n<191> if (is_waitconnect) {\n<193> fprintf(stderr, "QEMU waiting for connection on: %s\n",\n<197> tcp_chr_accept(QIO_CHANNEL(s->listen_ioc), G_IO_IN, chr);\n<227> return chr;
<1> static inline void gen_intermediate_code_internal(PowerPCCPU *cpu,\n<35> ctx.nip = pc_start;\n<37> ctx.tb = tb;\n<41> ctx.spr_cb = env->spr_cb;\n<43> ctx.pr = msr_pr;\n<45> ctx.hv = !msr_pr && msr_hv;\n<47> ctx.mem_idx = env->mmu_idx;\n<49> ctx.insns_flags = env->insns_flags;\n<51> ctx.insns_flags2 = env->insns_flags2;\n<53> ctx.access_type = -1;\n<57> ctx.default_tcg_memop_mask = ctx.le_mode ? MO_LE : MO_BE;\n<67> ctx.fpu_enabled = msr_fp;\n<71> ctx.spe_enabled = msr_spe;\n<75> ctx.spe_enabled = 0;\n<79> ctx.altivec_enabled = msr_vr;\n<83> ctx.altivec_enabled = 0;\n<87> ctx.vsx_enabled = msr_vsx;\n<91> ctx.vsx_enabled = 0;\n<97> ctx.singlestep_enabled = CPU_SINGLE_STEP;\n<101> ctx.singlestep_enabled = 0;\n<105> ctx.singlestep_enabled |= CPU_BRANCH_STEP;\n<109> ctx.singlestep_enabled |= GDBSTUB_SINGLE_STEP;\n<137> while (ctx.exception == POWERPC_EXCP_NONE\n<145> if (bp->pc == ctx.nip) {\n<189> if (unlikely(need_byteswap(&ctx))) {\n<191> ctx.opcode = bswap32(cpu_ldl_code(env, ctx.nip));\n<195> ctx.opcode = cpu_ldl_code(env, ctx.nip);\n<199> LOG_DISAS("translate opcode %08x (%02x %02x %02x) (%s)\n",\n<201> ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode),\n<203> opc3(ctx.opcode), ctx.le_mode ? "little" : "big");\n<207> tcg_gen_debug_insn_start(ctx.nip);\n<211> ctx.nip += 4;\n<217> handler = table[opc1(ctx.opcode)];\n<223> handler = table[opc2(ctx.opcode)];\n<229> handler = table[opc3(ctx.opcode)];\n<257> if (unlikely(handler->type & (PPC_SPE | PPC_SPE_SINGLE | PPC_SPE_DOUBLE) && Rc(ctx.opcode))) {\n<269> if (unlikely((ctx.opcode & inval) != 0)) {\n<293> (*(handler->handler))(&ctx);\n<303> if (unlikely(ctx.singlestep_enabled & CPU_SINGLE_STEP &&\n<305> (ctx.nip <= 0x100 || ctx.nip > 0xF00) &&\n<307> ctx.exception != POWERPC_SYSCALL &&\n<309> ctx.exception != POWERPC_EXCP_TRAP &&\n<311> ctx.exception != POWERPC_EXCP_BRANCH)) {\n<315> } else if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n<333> if (tcg_check_temp_count()) {\n<335> fprintf(stderr, "Opcode %02x %02x %02x (%08x) leaked temporaries\n",\n<337> opc1(ctx.opcode), opc2(ctx.opcode), opc3(ctx.opcode),\n<351> if (ctx.exception == POWERPC_EXCP_NONE) {\n<353> gen_goto_tb(&ctx, 0, ctx.nip);\n<355> } else if (ctx.exception != POWERPC_EXCP_BRANCH) {\n<385> tb->size = ctx.nip - pc_start;
<1> static void bamboo_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n<33> kernel_size = load_uimage ( kernel_filename , & entry , & loadaddr , NULL ) ;\n<35> kernel_size = load_elf ( kernel_filename , 0 , & elf_entry , & elf_lowaddr , NULL , 1 , ELF_MACHINE , 0 ) ;\n<39> if ( kernel_size < 0 ) {\n<40> fprintf ( stderr , "qemu: could not load kernel '%s'\n" , kernel_filename ) ;\n<46> initrd_size = load_image_targphys ( initrd_filename , initrd_base , ram_size - initrd_base ) ;\n<47> if ( initrd_size < 0 ) {\n<48> fprintf ( stderr , "qemu: could not load initial ram disk '%s'\n" , initrd_filename ) ;\n<56> if ( fdt == NULL ) {\n<57> fprintf ( stderr , "couldn't load device tree\n" ) ;
<1> static void stereo_processing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34)\n<45> if (ps->num_env_old) {\n<47> memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n<49> memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n<51> memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n<53> memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n<55> memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n<57> memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n<59> memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n<61> memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n<83> map_val_20_to_34(H11[0][0]);\n<85> map_val_20_to_34(H11[1][0]);\n<87> map_val_20_to_34(H12[0][0]);\n<89> map_val_20_to_34(H12[1][0]);\n<91> map_val_20_to_34(H21[0][0]);\n<93> map_val_20_to_34(H21[1][0]);\n<95> map_val_20_to_34(H22[0][0]);\n<97> map_val_20_to_34(H22[1][0]);\n<119> map_val_34_to_20(H11[0][0]);\n<121> map_val_34_to_20(H11[1][0]);\n<123> map_val_34_to_20(H12[0][0]);\n<125> map_val_34_to_20(H12[1][0]);\n<127> map_val_34_to_20(H21[0][0]);\n<129> map_val_34_to_20(H21[1][0]);\n<131> map_val_34_to_20(H22[0][0]);\n<133> map_val_34_to_20(H22[1][0]);
<1> AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)\n<5> AVBitStreamFilter *bsf = first_bitstream_filter;\n<9> while (bsf) {\n<11> if (!strcmp(name, bsf->name)) {\n<15> av_mallocz(sizeof(AVBitStreamFilterContext));\n<17> bsfc->filter    = bsf;\n<19> bsfc->priv_data =\n<21> bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;\n<23> return bsfc;\n<27> bsf = bsf->next;
<1> static void raw_aio_remove(RawAIOCB *acb)\n<15> if (*pacb == NULL) {\n<17> fprintf(stderr, "raw_aio_remove: aio request not found!\n");
<1> static void omap_mcbsp_writeh(void *opaque, target_phys_addr_t addr,\n<35> if (s->tx_req > 1) {\n<53> printf("%s: Tx FIFO overrun\n", __FUNCTION__);\n<81> if (value & (1 << 15))				/* DLB */\n<83> printf("%s: Digital Loopback mode enable attempt\n", __FUNCTION__);\n<145> if (value & 3)					/* XMCM */\n<147> printf("%s: Tx channel selection mode enable attempt\n",\n<157> if (value & 1)					/* RMCM */\n<159> printf("%s: Rx channel selection mode enable attempt\n",
<1> static void check_mc(void)\n<29> static const char *const op_names[2] = { "put", "avg" };\n<31> char str[256];\n<43> int size = 64 >> hsize;\n<53> if (dx || dy) {\n<63> sprintf(str, "%s%d", op_names[op], size);\n<77> call_ref(dst0, size * SIZEOF_PIXEL,\n<89> if (memcmp(dst0, dst1, DST_BUF_SIZE))\n<91> fail();
<1> static void handle_arg_reserved_va(const char *arg)\n<9> reserved_va = strtoul(arg, &p, 0);\n<39> p++;\n<43> if (((reserved_va >> shift) != unshifted)\n<53> fprintf(stderr, "Reserved virtual address too big\n");\n<61> if (*p) {\n<63> fprintf(stderr, "Unrecognised -R size suffix '%s'\n", p);
<1> static void fill_slice_long(AVCodecContext *avctx, DXVA_Slice_H264_Long *slice,\n<17> memset(slice, 0, sizeof(*slice));\n<37> slice->slice_type += 5;
<1> void kadmin_getprinc ( int argc , char * argv [ ] ) {\n<5> char * canon = NULL , * princstr = NULL , * modprincstr = NULL ;\n<8> if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( "-terse" , argv [ 1 ] ) ) ) ) {\n<9> fprintf ( stderr , _ ( "usage: get_principal [-terse] principal\n" ) ) ;\n<10> return ;\n<12> memset ( & dprinc , 0 , sizeof ( dprinc ) ) ;\n<13> retval = kadmin_parse_name ( argv [ argc - 1 ] , & princ ) ;\n<14> if ( retval ) {\n<18> retval = krb5_unparse_name ( context , princ , & canon ) ;\n<23> retval = kadm5_get_principal ( handle , princ , & dprinc , KADM5_PRINCIPAL_NORMAL_MASK | KADM5_KEY_DATA ) ;\n<25> com_err ( "get_principal" , retval , _ ( "while retrieving \"%s\"." ) , canon ) ;\n<28> retval = krb5_unparse_name ( context , dprinc . principal , & princstr ) ;\n<33> retval = krb5_unparse_name ( context , dprinc . mod_name , & modprincstr ) ;\n<38> if ( argc == 2 ) {\n<39> printf ( _ ( "Principal: %s\n" ) , princstr ) ;\n<40> printf ( _ ( "Expiration date: %s\n" ) , dprinc . princ_expire_time ? strdate ( dprinc . princ_expire_time ) : _ ( "[never]" ) ) ;\n<41> printf ( _ ( "Last password change: %s\n" ) , dprinc . last_pwd_change ? strdate ( dprinc . last_pwd_change ) : _ ( "[never]" ) ) ;\n<42> printf ( _ ( "Password expiration date: %s\n" ) , dprinc . pw_expiration ? strdate ( dprinc . pw_expiration ) : _ ( "[none]" ) ) ;\n<43> printf ( _ ( "Maximum ticket life: %s\n" ) , strdur ( dprinc . max_life ) ) ;\n<44> printf ( _ ( "Maximum renewable life: %s\n" ) , strdur ( dprinc . max_renewable_life ) ) ;\n<45> printf ( _ ( "Last modified: %s (%s)\n" ) , strdate ( dprinc . mod_date ) , modprincstr ) ;\n<46> printf ( _ ( "Last successful authentication: %s\n" ) , dprinc . last_success ? strdate ( dprinc . last_success ) : _ ( "[never]" ) ) ;\n<47> printf ( "Last failed authentication: %s\n" , dprinc . last_failed ? strdate ( dprinc . last_failed ) : "[never]" ) ;\n<48> printf ( _ ( "Failed password attempts: %d\n" ) , dprinc . fail_auth_count ) ;\n<49> printf ( _ ( "Number of keys: %d\n" ) , dprinc . n_key_data ) ;\n<51> i < dprinc . n_key_data ;\n<53> krb5_key_data * key_data = & dprinc . key_data [ i ] ;\n<55> if ( krb5_enctype_to_name ( key_data -> key_data_type [ 0 ] , FALSE , enctype , sizeof ( enctype ) ) ) snprintf ( enctype , sizeof ( enctype ) , _ ( "<Encryption type 0x%x>" ) , key_data -> key_data_type [ 0 ] ) ;\n<56> printf ( "Key: vno %d, %s, " , key_data -> key_data_kvno , enctype ) ;\n<57> if ( key_data -> key_data_ver > 1 ) {\n<58> if ( krb5_salttype_to_string ( key_data -> key_data_type [ 1 ] , salttype , sizeof ( salttype ) ) ) snprintf ( salttype , sizeof ( salttype ) , _ ( "<Salt type 0x%x>" ) , key_data -> key_data_type [ 1 ] ) ;\n<59> printf ( "%s\n" , salttype ) ;\n<61> else printf ( _ ( "no salt\n" ) ) ;\n<63> printf ( _ ( "MKey: vno %d\n" ) , dprinc . mkvno ) ;\n<64> printf ( _ ( "Attributes:" ) ) ;\n<68> if ( dprinc . attributes & ( krb5_flags ) 1 << j ) printf ( " %s" , prflags [ j ] ) ;\n<70> printf ( "\n" ) ;\n<71> printf ( _ ( "Policy: %s\n" ) , dprinc . policy ? dprinc . policy : _ ( "[none]" ) ) ;\n<74> printf ( "\"%s\"\t%d\t%d\t%d\t%d\t\"%s\"\t%d\t%d\t%d\t%d\t\"%s\"" "\t%d\t%d\t%d\t%d\t%d" , princstr , dprinc . princ_expire_time , dprinc . last_pwd_change , dprinc . pw_expiration , dprinc . max_life , modprincstr , dprinc . mod_date , dprinc . attributes , dprinc . kvno , dprinc . mkvno , dprinc . policy ? dprinc . policy : "[none]" , dprinc . max_renewable_life , dprinc . last_success , dprinc . last_failed , dprinc . fail_auth_count , dprinc . n_key_data ) ;\n<76> i < dprinc . n_key_data ;\n<77> i ++ ) printf ( "\t%d\t%d\t%d\t%d" , dprinc . key_data [ i ] . key_data_ver , dprinc . key_data [ i ] . key_data_kvno , dprinc . key_data [ i ] . key_data_type [ 0 ] , dprinc . key_data [ i ] . key_data_type [ 1 ] ) ;\n<78> printf ( "\n" ) ;\n<81> kadm5_free_principal_ent ( handle , & dprinc ) ;\n<82> free ( canon ) ;\n<83> free ( princstr ) ;\n<84> free ( modprincstr ) ;
<1> static int get_keycode(const char *key)\n<13> for(p = key_defs; p->name != NULL; p++) {\n<15> if (!strcmp(key, p->name))\n<17> return p->keycode;\n<21> if (strstart(key, "0x", NULL)) {
<1> static inline void mix_3f_1r_to_stereo(AC3DecodeContext *ctx)\n<19> memset(output[3], 0, sizeof(output[3]));\n<21> memset(output[4], 0, sizeof(output[4]));
<1> eth_write(void *opaque, target_phys_addr_t addr,\n<9> uint32_t value = val64;\n<13> addr >>= 2;\n<15> switch (addr)
<1> static int gdb_handle_packet(GDBState *s, CPUState *env, const char *line_buf)\n<9> char buf[MAX_PACKET_LENGTH];\n<11> uint8_t mem_buf[MAX_PACKET_LENGTH];\n<27> ch = *p++;\n<29> switch(ch) {\n<109> fprintf(stderr, "\nQEMU: Terminated via GDBstub\n");\n<243> len = strlen(p) / 2;\n<245> hextomem((uint8_t *)registers, p, len);\n<343> if (!gdb_has_xml)\n<347> addr = strtoull(p, (char **)&p, 16);\n<349> if (*p == '=')\n<351> p++;\n<353> reg_size = strlen(p) / 2;\n<355> hextomem(mem_buf, p, reg_size);\n<487> if (!strcmp(p,"qemu.sstepbits")) {\n<491> snprintf(buf, sizeof(buf), "ENABLE=%x,NOIRQ=%x,NOTIMER=%x",\n<499> put_packet(s, buf);\n<503> } else if (strncmp(p,"qemu.sstep",10) == 0) {\n<561> if (strncmp(p, "Supported", 9) == 0) {\n<563> sprintf(buf, "PacketSize=%x", MAX_PACKET_LENGTH);\n<571> put_packet(s, buf);
<385> if (ff_vc1_parse_frame_header(v, &s->gb) < 0) {\n<393> if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n<685> if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n<697> if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n<727> ff_vc1_decode_blocks(v);\n<739> if (s->pict_type == AV_PICTURE_TYPE_B) {\n<743> 2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2));
<1> fork_exec(struct socket *so, const char *ex, int do_pty)\n<77> lprint("Error: inet socket: %s\n", strerror(errno));\n<91> switch(fork()) {\n<95> lprint("Error: fork failed: %s\n", strerror(errno));\n<145> } while (ret < 0 && errno == EINTR);\n<187> bptr = strdup(ex); /* No need to free() this */\n<189> if (do_pty == 1) {\n<197> argv[i++] = bptr;\n<205> curarg = bptr;\n<209> bptr++;\n<213> *bptr++ = (char)0;\n<215> argv[i++] = strdup(curarg);\n<223> execvp(argv[0], argv);\n<231> char buff[256];\n<235> sprintf(buff, "Error: execvp of %s failed: %s\n",\n<237> argv[0], strerror(errno));\n<239> write(2, buff, strlen(buff)+1);\n<277> } while (so->s < 0 && errno == EINTR);
<1> static int vp3_decode_frame(AVCodecContext *avctx,\n<13> Vp3DecodeContext *s = avctx->priv_data;\n<95> if (!s->all_fragments) {\n<143> init_loop_filter(s);\n<155> init_dequantizer(s, i);\n<187> if (s->keyframe) {\n<225> if (!s->golden_frame.data[0]) {\n<235> if (ff_thread_get_buffer(avctx, &s->golden_frame) < 0) {\n<255> memset(s->all_fragments, 0, s->fragment_count * sizeof(Vp3Fragment));\n<261> if (unpack_superblocks(s, &gb)){\n<269> if (unpack_modes(s, &gb)){\n<277> if (unpack_vectors(s, &gb)){\n<285> if (unpack_block_qpis(s, &gb)){\n<293> if (unpack_dct_coeffs(s, &gb)){\n<323> render_slice(s, i);\n<333> apply_loop_filter(s, i, row, row+1);\n<337> vp3_draw_horiz_band(s, s->avctx->height);
<1> void do_interrupt(CPUState *env)\n<9> D(fprintf (stderr, "exception index=%d interrupt_req=%d\n",\n<17> switch (env->exception_index)\n<27> ex_vec = env->trap_vector;\n<29> env->pregs[PR_ERP] = env->pc + 2;\n<37> ex_vec = env->fault_vector;\n<39> env->pregs[PR_ERP] = env->pc;\n<49> if (!(env->pregs[PR_CCS] & I_FLAG))\n<57> ex_vec = env->interrupt_vector;\n<63> env->pregs[PR_ERP] = env->pc;\n<71> if ((env->pregs[PR_CCS] & U_FLAG)) {\n<73> D(fprintf(logfile, "excp isr=%x PC=%x ERP=%x pid=%x ccs=%x cc=%d %x\n",\n<87> env->pc = ldl_code(env->pregs[PR_EBP] + ex_vec * 4);\n<91> if (env->pregs[PR_CCS] & U_FLAG) {\n<105> cris_shift_ccs(env);\n<107> D(fprintf (logfile, "%s isr=%x vec=%x ccs=%x pid=%d erp=%x\n",
<1> CPUState *ppc405cr_init (target_phys_addr_t ram_bases[4],\n<21> memset(clk_setup, 0, sizeof(clk_setup));\n<23> env = ppc4xx_init("405cr", &clk_setup[PPC405CR_CPU_CLK],\n<105> ppc405cr_cpc_init(env, clk_setup, sysclk);
<1> static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size, uint8_t * buf, int buf_size)\n<135> if (ac3_parse_audio_block(ctx, i)) {\n<165> if (ctx->audio_block.blksw & (1 << j)) {\n<179> samples[l] = (ctx->samples + 1536)[l] * window[l] + (ctx->samples + 2048)[l] * window[255 - l];\n<197> samples[l] = (ctx->samples + 1536)[l] * window[l] + (ctx->samples + 2048)[l] * window[255 - l];\n<201> memcpy(ctx->samples + 2048, ctx->samples + 1792, 256 * sizeof (float));
<1> static void apply_loop_filter(Vp3DecodeContext *s)\n<17> int bounding_values_array[256];\n<41> memset(bounding_values_array, 0, 256 * sizeof(int));
<1> rfbBool rfbSendTextChatMessage ( rfbClientPtr cl , uint32_t length , char * buffer ) {\n<4> memset ( ( char * ) & tc , 0 , sizeof ( tc ) ) ;\n<5> tc . type = rfbTextChat ;\n<6> tc . length = Swap32IfLE ( length ) ;\n<13> if ( cl -> ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE ) {\n<14> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n<16> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & tc , sz_rfbTextChatMsg ) ;\n<17> cl -> ublen += sz_rfbTextChatMsg ;\n<18> if ( bytesToSend > 0 ) {\n<19> memcpy ( & cl -> updateBuf [ cl -> ublen ] , buffer , bytesToSend ) ;\n<20> cl -> ublen += bytesToSend ;\n<22> rfbStatRecordMessageSent ( cl , rfbTextChat , sz_rfbTextChatMsg + bytesToSend , sz_rfbTextChatMsg + bytesToSend ) ;
<1> static int dvvideo_decode_frame(AVCodecContext *avctx,\n<151> if(avctx->get_buffer_callback(avctx, width, height, I_TYPE) < 0){\n<153> fprintf(stderr, "get_buffer() failed\n");
<1> static inline void _t_gen_mov_env_TN(int offset, TCGv tn)\n<5> if (offset > sizeof(CPUCRISState)) {\n<7> fprintf(stderr, "wrong store to env at off=%d\n", offset);\n<11> tcg_gen_st_tl(tn, cpu_env, offset);
<1> static CURLFORMcode FormAdd ( struct curl_httppost * * httppost , struct curl_httppost * * last_post , va_list params ) {\n<10> first_form = calloc ( 1 , sizeof ( struct FormInfo ) ) ;\n<11> if ( ! first_form ) return CURL_FORMADD_MEMORY ;\n<60> if ( filename ) {\n<61> current_form -> value = strdup ( filename ) ;\n<62> if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n<75> if ( filename ) {\n<76> char * fname = strdup ( filename ) ;\n<77> if ( ! fname ) return_value = CURL_FORMADD_MEMORY ;\n<96> if ( filename ) {\n<97> current_form -> value = strdup ( filename ) ;\n<98> if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n<137> if ( contenttype ) {\n<138> char * type = strdup ( contenttype ) ;\n<139> if ( ! type ) return_value = CURL_FORMADD_MEMORY ;\n<158> if ( contenttype ) {\n<159> current_form -> contenttype = strdup ( contenttype ) ;\n<160> if ( ! current_form -> contenttype ) return_value = CURL_FORMADD_MEMORY ;\n<175> if ( current_form -> showfilename ) return_value = CURL_FORMADD_OPTION_TWICE ;\n<177> current_form -> showfilename = strdup ( filename ) ;\n<178> if ( ! current_form -> showfilename ) return_value = CURL_FORMADD_MEMORY ;\n<220> if ( ( ( form -> flags & HTTPPOST_FILENAME ) || ( form -> flags & HTTPPOST_BUFFER ) ) && ! form -> contenttype ) {\n<222> form -> contenttype = strdup ( ContentTypeForFilename ( f , prevtype ) ) ;\n<223> if ( ! form -> contenttype ) {
<1> static void filter(AVFilterContext *ctx, AVFilterBufferRef *dstpic,\n<39> if ((y ^ parity) & 1) {\n<47> uint8_t *dst  = &dstpic->data[i][y*dstpic->linesize[i]];\n<55> memcpy(&dstpic->data[i][y*dstpic->linesize[i]],\n<57> &yadif->cur->data[i][y*refs], w*df);
<1> static void nvdimm_dsm_func_read_fit(AcpiNVDIMMState *state, NvdimmDsmIn *in,\n<15> uint32_t read_len = 0, func_ret_status;\n<21> read_fit = (NvdimmFuncReadFITIn *)in->arg3;\n<23> le32_to_cpus(&read_fit->offset);\n<29> fit = fit_buf->fit;\n<39> if (read_fit->offset > fit->len) {\n<51> if (!read_fit->offset) {\n<67> read_len = MIN(fit->len - read_fit->offset,\n<77> read_fit_out = g_malloc(size);\n<85> memcpy(read_fit_out->fit, fit->data + read_fit->offset, read_len);\n<89> cpu_physical_memory_write(dsm_mem_addr, read_fit_out, size);\n<93> g_free(read_fit_out);
<1> static void test_hash_digest(void)\n<13> for (i = 0; i < G_N_ELEMENTS(expected_outputs) ; i++) {\n<35> strlen(INPUT_TEXT),
<1> static int flv_data_packet(AVFormatContext *s, AVPacket *pkt,\n<37> while ((ret = amf_get_string(pb, buf, sizeof(buf))) > 0) {\n<41> if (type == AMF_DATA_TYPE_STRING && !strcmp(buf, "text")) {\n<43> length = avio_rb16(pb);\n<45> ret    = av_get_packet(pb, pkt, length);\n<47> if (ret < 0)\n<57> if ((ret = amf_skip_tag(pb, type)) < 0)
<1> void *av_realloc(void *ptr, size_t size)\n<15> if (size > (MAX_MALLOC_SIZE-16))\n<33> return realloc(ptr, size + !size);
<1> static void test_acpi_q35_tcg_memhp(void)\n<9> memset(&data, 0, sizeof(data));\n<15> test_acpi_one(" -m 128,slots=3,maxmem=1G -numa node", &data);\n<17> free_test_data(&data);
<1> static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n<7> char *q, buf1[20], c;\n<51> if (len < 1)  // returned error or empty buf1\n<55> if ((q - buf + len) > buf_size - 1)\n<59> memcpy(q, buf1, len);\n<61> q += len;
<1> ff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb,\n<23> av_new_packet(pkt, st->codec->block_align);\n<25> memcpy(pkt->data, ast->pkt.data + st->codec->block_align * //FIXME avoid this
<1> int qemu_global_option(const char *str)\n<5> char driver[64], property[64];\n<13> rc = sscanf(str, "%63[^.].%63[^=]%n", driver, property, &offset);\n<15> if (rc < 2 || str[offset] != '=') {\n<17> error_report("can't parse: \"%s\"", str);\n<27> qemu_opt_set(opts, "driver", driver, &error_abort);\n<29> qemu_opt_set(opts, "property", property, &error_abort);\n<31> qemu_opt_set(opts, "value", str + offset + 1, &error_abort);
<1> void microblaze_load_kernel(MicroBlazeCPU *cpu, target_phys_addr_t ddr_base,\n<13> const char *kernel_cmdline = NULL;\n<25> kernel_cmdline = qemu_opt_get(machine_opts, "append");\n<49> if (kernel_filename) {\n<131> if (kernel_cmdline && strlen(kernel_cmdline)) {\n<133> pstrcpy_targphys("cmdline", boot_info.cmdline, 256, kernel_cmdline);\n<141> microblaze_load_dtb(boot_info.fdt, ram_size, kernel_cmdline,
<1> static void sx1_init(MachineState *machine, const int version)\n<107> if ((dinfo = drive_get(IF_PFLASH, 0, fl_idx)) != NULL) {\n<119> fprintf(stderr, "qemu: Error registering flash memory %d.\n",\n<125> fl_idx++;\n<133> (dinfo = drive_get(IF_PFLASH, 0, fl_idx)) != NULL) {\n<167> fprintf(stderr, "qemu: Error registering flash memory %d.\n",\n<173> fl_idx++;\n<189> if (!machine->kernel_filename && !fl_idx && !qtest_enabled()) {\n<191> fprintf(stderr, "Kernel or Flash image must be specified\n");
<1> static void usbredir_device_disconnect(void *priv)\n<37> usbredir_cleanup_device_queues(dev);\n<39> memset(dev->endpoint, 0, sizeof(dev->endpoint));
<1> static void *spapr_create_fdt_skel(const char *cpu_model,\n<139> modelname = g_strdup(cpu_model);\n<143> for (i = 0; i < strlen(modelname); i++) {\n<145> modelname[i] = toupper(modelname[i]);\n<151> for (env = first_cpu; env != NULL; env = env->next_cpu) {\n<155> uint32_t gserver_prop[] = {cpu_to_be32(index), 0}; /* HACK! */\n<169> if (asprintf(&nodename, "%s@%x", modelname, index) < 0) {\n<171> fprintf(stderr, "Allocation failure\n");\n<173> exit(1);\n<183> free(nodename);\n<241> g_free(modelname);
<1> static inline int onenand_load_spare(OneNANDState *s, int sec, int secn,\n<3> void *dest)\n<13> if (bdrv_read(s->bdrv_cur, s->secs_cur + (sec >> 5), buf, 1) < 0)\n<17> memcpy(dest, buf + ((sec & 31) << 4), secn << 4);\n<19> } else if (sec + secn > s->secs_cur)\n<25> memcpy(dest, s->current + (s->secs_cur << 9) + (sec << 4), secn << 4);
<1> static void dvbsub_parse_clut_segment(AVCodecContext *avctx,\n<57> if (!clut) {\n<59> clut = av_malloc(sizeof(DVBSubCLUT));\n<63> memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n<73> ctx->clut_list = clut;
<1> void ioinst_handle_chsc(S390CPU *cpu, uint32_t ipb)\n<55> req = (ChscReq *)buf;\n<57> len = be16_to_cpu(req->len);\n<61> if ((len < 16) || (len > 4088) || (len & 7)) {\n<69> memset((char *)req + len, 0, TARGET_PAGE_SIZE - len);
<1> static void fmtint ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , LLONG value , int base , int min , int max , int flags ) {\n<3> const char * prefix = "" ;\n<21> if ( base == 8 ) prefix = "0" ;\n<22> if ( base == 16 ) prefix = "0x" ;\n<33> spadlen = min - OSSL_MAX ( max , place ) - ( signvalue ? 1 : 0 ) - strlen ( prefix ) ;\n<48> prefix ++ ;
<1> static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n<13> uint8_t tag = ncq_fis->tag >> 3;\n<21> if (ncq_tfs->used) {\n<25> fprintf(stderr, "%s: tag %d already used\n", __FUNCTION__, tag);
<1> int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n<53> if (!sps_buf)\n<57> sps = (SPS*)sps_buf->data;\n<73> memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n<75> memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n<409> int ret = decode_vui_parameters(gb, avctx, sps);\n<495> if (ps->sps_list[sps_id] &&\n<497> !memcmp(ps->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n<499> av_buffer_unref(&sps_buf);\n<505> ps->sps_list[sps_id] = sps_buf;
<1> int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)\n<137> if (!has_codec_parameters(st->codec))\n<157> if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)\n<165> if(st->parser && st->parser->parser->split && !st->codec->extradata)\n<253> } while (err > 0 && !has_codec_parameters(st->codec));\n<263> } else if (!has_codec_parameters(st->codec)){\n<267> avcodec_string(buf, sizeof(buf), st->codec, 0);\n<289> if ((ret = av_dup_packet(pkt)) < 0)\n<333> if (st->info->duration_count < 2)\n<335> memset(st->info->duration_error, 0, sizeof(st->info->duration_error));\n<337> for (i=1; i<FF_ARRAY_ELEMS(st->info->duration_error); i++) {\n<345> st->info->duration_error[i] += error*error;\n<365> if(st->parser && st->parser->parser->split && !st->codec->extradata){\n<367> int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);\n<369> if (i > 0 && i < FF_MAX_EXTRADATA_SIZE) {\n<371> st->codec->extradata_size= i;\n<373> st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<375> if (!st->codec->extradata)\n<379> memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);\n<381> memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<407> try_decode_frame(st, pkt, (options && i < orig_nb_streams ) ? &options[i] : NULL);\n<427> avcodec_close(st->codec);\n<451> if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > 1 && !st->r_frame_rate.num)\n<457> && tb_unreliable(st->codec) /*&&
<1> static int show_hwaccels(void *optctx, const char *opt, const char *arg)\n<9> printf("Hardware acceleration methods:\n");\n<11> for (i = 0; hwaccels[i].name; i++) {\n<13> printf("%s\n", hwaccels[i].name);\n<17> printf("\n");
<1> static int mptsas_process_scsi_io_request(MPTSASState *s,\n<33> if (status) {\n<53> if (status) {\n<61> if (req->qsg.size < scsi_io->DataLength) {\n<81> if (req->sreq->cmd.xfer > scsi_io->DataLength) {\n<91> if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n<103> if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {\n<115> if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {\n<151> memset(&reply, 0, sizeof(reply));\n<173> mptsas_fix_scsi_io_reply_endianness(&reply);\n<175> mptsas_reply(s, (MPIDefaultReply *)&reply);
<1> int ff_h264_decode_mb_cabac(const H264Context *h, H264SliceContext *sl)\n<259> if ((int) (sl->cabac.bytestream_end - ptr) < mb_size)\n<285> memset(h->non_zero_count[mb_xy], 16, 48);
<1> static int getopt(int argc, char *argv[], char *opts)\n<13> if (sp == 1)\n<17> argv[optind][0] != '-' || argv[optind][1] == '\0')\n<21> else if (!strcmp(argv[optind], "--")) {\n<23> optind++;\n<25> return EOF;\n<29> optopt = c = argv[optind][sp];\n<31> if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n<33> fprintf(stderr, ": illegal option -- %c\n", c);\n<35> if (argv[optind][++sp] == '\0') {\n<43> return '?';\n<47> if (*++cp == ':') {\n<53> else if(++optind >= argc) {\n<55> fprintf(stderr, ": option requires an argument -- %c\n", c);\n<77> optarg = NULL;\n<83> return c;
<1> AVAES *av_aes_init(uint8_t *key, int key_bits, int decrypt) {\n<7> uint8_t tk[8][4];\n<59> if(key_bits!=128 && key_bits!=192 && key_bits!=256)\n<71> memcpy(tk, key, KC*4);\n<75> for(t= 0; t < (rounds+1)*4;) {\n<77> memcpy(a->round_key[0][t], tk, KC*4);
<1> static int mp_decode_frame ( MPADecodeContext * s , OUT_INT * * samples , const uint8_t * buf , int buf_size ) {\n<14> default : nb_frames = mp_decode_layer3 ( s ) ;\n<15> if ( nb_frames < 0 ) return nb_frames ;\n<16> s -> last_buf_size = 0 ;\n<20> if ( i >= 0 && i <= BACKSTEP_SIZE ) {\n<21> memmove ( s -> last_buf , s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) , i ) ;\n<22> s -> last_buf_size = i ;\n<36> memcpy ( s -> last_buf + s -> last_buf_size , s -> gb . buffer + buf_size - HEADER_SIZE - i , i ) ;\n<37> s -> last_buf_size += i ;
<1> void bios_linker_loader_add_pointer(BIOSLinker *linker,\n<5> const char *src_file,\n<15> const BiosLinkerFileEntry *file = bios_linker_find_file(linker, dest_file);\n<27> memset(&entry, 0, sizeof entry);\n<31> sizeof entry.pointer.dest_file - 1);\n<35> sizeof entry.pointer.src_file - 1);\n<49> g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);
<1> int show_formats(void *optctx, const char *opt, const char *arg)\n<21> last_name = "000";\n<31> const char *long_name = NULL;\n<35> while ((ofmt = av_oformat_next(ofmt))) {\n<37> if ((name == NULL || strcmp(ofmt->name, name) < 0) &&\n<39> strcmp(ofmt->name, last_name) > 0) {\n<41> name      = ofmt->name;\n<43> long_name = ofmt->long_name;\n<45> encode    = 1;\n<51> while ((ifmt = av_iformat_next(ifmt))) {\n<53> if ((name == NULL || strcmp(ifmt->name, name) < 0) &&\n<55> strcmp(ifmt->name, last_name) > 0) {\n<57> name      = ifmt->name;\n<59> long_name = ifmt->long_name;\n<61> encode    = 0;\n<65> if (name && strcmp(ifmt->name, name) == 0)\n<67> decode = 1;\n<71> if (name == NULL)\n<75> last_name = name;
<1> static int decode_thread(void *arg)\n<5> VideoState *is = arg;\n<13> AVFormatParameters params, *ap = &params;\n<23> is->video_stream = -1;\n<25> is->audio_stream = -1;\n<27> is->subtitle_stream = -1;\n<37> memset(ap, 0, sizeof(*ap));\n<51> err = av_open_input_file(&ic, is->filename, is->iformat, 0, ap);\n<75> if (err < 0) {\n<77> fprintf(stderr, "%s: could not find codec parameters\n", is->filename);\n<109> if (ret < 0) {\n<111> fprintf(stderr, "%s: could not seek to position %0.3f\n",\n<113> is->filename, (double)timestamp / AV_TIME_BASE);\n<163> dump_format(ic, 0, is->filename, 0);\n<175> stream_component_open(is, audio_index);\n<183> stream_component_open(is, video_index);\n<197> stream_component_open(is, subtitle_index);\n<203> if (is->video_stream < 0 && is->audio_stream < 0) {\n<205> fprintf(stderr, "%s: could not open codecs\n", is->filename);\n<275> ret = av_seek_frame(is->ic, stream_index, seek_target, is->seek_flags);\n<277> if (ret < 0) {\n<279> fprintf(stderr, "%s: error while seeking\n", is->ic->filename);\n<407> stream_component_close(is, is->audio_stream);\n<411> stream_component_close(is, is->video_stream);\n<415> stream_component_close(is, is->subtitle_stream);\n<419> av_close_input_file(is->ic);\n<437> event.user.data1 = is;
<43> for(j=0; j<h->ref_count[1]; j++){\n<47> h->implicit_weight[j][16+2*i] = h->implicit_weight[j][16+2*i+1] = h->implicit_weight[j][i];\n<49> memcpy(h->implicit_weight[16+2*j],   h->implicit_weight[j], sizeof(*h->implicit_weight));\n<51> memcpy(h->implicit_weight[16+2*j+1], h->implicit_weight[j], sizeof(*h->implicit_weight));
<1> static int vc1_decode_p_mb_intfi ( VC1Context * v ) {\n<20> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n<42> vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n<51> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n<62> vc1_mc_1mv ( v , 0 ) ;\n<77> vc1_mc_4mv_luma ( v , i , 0 ) ;\n<79> else if ( i == 4 ) vc1_mc_4mv_chroma ( v , 0 ) ;\n<101> pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n<108> if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;
<1> static int cng_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<3> CNGContext * p = avctx -> priv_data ;\n<9> if ( avpkt -> size ) {\n<12> memset ( p -> target_refl_coef , 0 , p -> order * sizeof ( * p -> target_refl_coef ) ) ;\n<16> p -> target_refl_coef [ i ] = ( avpkt -> data [ 1 + i ] - 127 ) / 128.0 ;\n<19> if ( p -> inited ) {\n<27> memcpy ( p -> refl_coef , p -> target_refl_coef , p -> order * sizeof ( * p -> refl_coef ) ) ;\n<30> make_lpc_coefs ( p -> lpc_coef , p -> refl_coef , p -> order ) ;\n<43> if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n<49> i < avctx -> frame_size ;\n<51> memcpy ( p -> filter_out , p -> filter_out + avctx -> frame_size , p -> order * sizeof ( * p -> filter_out ) ) ;
<1> void ff_sbr_apply ( AACContext * ac , SpectralBandReplication * sbr , int id_aac , float * L , float * R ) {\n<41> if ( sbr -> ps . start ) {\n<45> memcpy ( sbr -> X [ 1 ] , sbr -> X [ 0 ] , sizeof ( sbr -> X [ 0 ] ) ) ;\n<49> sbr_qmf_synthesis ( & sbr -> mdct , & sbr -> dsp , ac -> fdsp , L , sbr -> X [ 0 ] , sbr -> qmf_filter_scratch , sbr -> data [ 0 ] . synthesis_filterbank_samples , & sbr -> data [ 0 ] . synthesis_filterbank_samples_offset , downsampled ) ;\n<50> if ( nch == 2 ) sbr_qmf_synthesis ( & sbr -> mdct , & sbr -> dsp , ac -> fdsp , R , sbr -> X [ 1 ] , sbr -> qmf_filter_scratch , sbr -> data [ 1 ] . synthesis_filterbank_samples , & sbr -> data [ 1 ] . synthesis_filterbank_samples_offset , downsampled ) ;
<1> static void mmap_release_buffer(AVPacket *pkt)\n<13> if (pkt->data == NULL)\n<19> memset(&buf, 0, sizeof(struct v4l2_buffer));\n<33> res = ioctl(fd, VIDIOC_QBUF, &buf);\n<35> if (res < 0)\n<37> av_log(NULL, AV_LOG_ERROR, "ioctl(VIDIOC_QBUF): %s\n",\n<39> strerror(errno));
<1> void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n<25> def = &tcg_op_defs[op];\n<39> for(i = 0; i < nb_args; i++) {\n<45> assert(ct_str != NULL);\n<51> if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n<79> if (*ct_str == '\0')\n<89> ct_str++;\n<95> if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n<97> fprintf(stderr, "Invalid constraint '%s' for arg %d of operation '%s'\n",\n<123> sort_constraints(def, 0, def->nb_oargs);\n<125> sort_constraints(def, def->nb_oargs, def->nb_iargs);
<1> static int s_aes_process ( stream_state * ss , stream_cursor_read * pr , stream_cursor_write * pw , bool last ) {\n<2> stream_aes_state * const state = ( stream_aes_state * ) ss ;\n<4> const long in_size = pr -> limit - pr -> ptr ;\n<5> const long out_size = pw -> limit - pw -> ptr ;\n<29> if ( in_size < 16 ) return 0 ;\n<30> memcpy ( state -> iv , pr -> ptr + 1 , 16 ) ;\n<35> aes_crypt_cbc ( state -> ctx , AES_DECRYPT , 16 , state -> iv , pr -> ptr + 1 , temp ) ;\n<37> if ( last && pr -> ptr == pr -> limit ) {\n<49> memcpy ( pw -> ptr + 1 , temp , 16 - pad ) ;\n<53> memcpy ( pw -> ptr + 1 , temp , 16 ) ;\n<54> pw -> ptr += 16 ;
<1> static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) {\n<2> static char cmd [ BUF_SIZE ] ;\n<7> memset ( cmd , 0 , BUF_SIZE ) ;\n<8> snprintf ( cmd , BUF_SIZE , "%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf" , executable , method , manager -> manager_address , working_dir , server -> port , working_dir , server -> port ) ;\n<9> if ( manager -> acl != NULL ) {\n<10> int len = strlen ( cmd ) ;\n<11> snprintf ( cmd + len , BUF_SIZE - len , " --acl %s" , manager -> acl ) ;\n<13> if ( manager -> timeout != NULL ) {\n<14> int len = strlen ( cmd ) ;\n<15> snprintf ( cmd + len , BUF_SIZE - len , " -t %s" , manager -> timeout ) ;\n<22> int len = strlen ( cmd ) ;\n<23> snprintf ( cmd + len , BUF_SIZE - len , " -a %s" , manager -> user ) ;
<1> static int usb_host_handle_control(USBDevice *dev, USBPacket *p,\n<59> if (length > sizeof(dev->data_buf)) {\n<61> fprintf(stderr, "husb: ctrl buffer too small (%d > %zu)\n",
<1> static char* mpjpeg_get_boundary(AVIOContext* pb)\n<23> while (start != NULL && *start != '\0') {\n<25> start = strchr(start, ';');\n<29> start = start+1;\n<33> while (av_isspace(*start))\n<35> start++;\n<39> if (!av_stristart(start, "boundary=", &start)) {\n<41> end = strchr(start, ';');\n<43> if (end)\n<45> len = end - start - 1;\n<49> len = strlen(start);\n<51> res = av_strndup(start, len);
<1> static void opt_b_frames(const char *arg)\n<7> if (b_frames > FF_MAX_B_FRAMES) {\n<9> fprintf(stderr, "\nCannot have more than %d B frames, increase FF_MAX_B_FRAMES.\n", FF_MAX_B_FRAMES);\n<13> } else if (b_frames < 1) {\n<15> fprintf(stderr, "\nNumber of B frames must be higher than 0\n");
<1> static void do_audio_out(AVFormatContext *s, OutputStream *ost,\n<21> uint8_t *buf = decoded_frame->data[0];\n<23> int size     = decoded_frame->nb_samples * dec->channels * isize;\n<171> if (byte_delta < 0) {\n<191> av_fast_malloc(&async_buf, &allocated_async_buf_size,\n<217> generate_silence(async_buf, dec->sample_fmt, byte_delta);\n<219> memcpy(async_buf + byte_delta, buf, size);\n<223> size += byte_delta;\n<289> if (av_audio_convert(ost->reformat_ctx, obuf, ostride, ibuf, istride, len) < 0) {\n<291> printf("av_audio_convert() failed\n");
<1> static int escape(char **dst, const char *src, const char *special_chars,\n<15> switch (mode) {\n<25> if (mode == ESCAPE_MODE_LAZY && strchr(WHITESPACES, *src))\n<27> av_bprintf(&dstbuf, "\\%c", *src++);\n<31> for (; *src; src++) {\n<33> if ((special_chars && strchr(special_chars, *src)) ||\n<35> strchr("'\\", *src) ||\n<37> (mode == ESCAPE_MODE_FULL && strchr(WHITESPACES, *src)))\n<39> av_bprintf(&dstbuf, "\\%c", *src);\n<43> av_bprint_chars(&dstbuf, *src, 1);\n<49> if (mode == ESCAPE_MODE_LAZY && strchr(WHITESPACES, dstbuf.str[dstbuf.len-1])) {\n<51> char c = dstbuf.str[dstbuf.len-1];\n<53> dstbuf.str[dstbuf.len-1] = '\\';\n<55> av_bprint_chars(&dstbuf, c, 1);
<1> static PhysPageDesc *phys_page_find_alloc(target_phys_addr_t index, int alloc)\n<51> if (!alloc)\n<55> p = qemu_vmalloc(sizeof(PhysPageDesc) * L2_SIZE);\n<57> memset(p, 0, sizeof(PhysPageDesc) * L2_SIZE);\n<59> *lp = p;\n<63> return ((PhysPageDesc *)p) + (index & (L2_SIZE - 1));
<1> static void sun4m_hw_init(const struct sun4m_hwdef *hwdef,\n<3> QEMUMachineInitArgs *args)\n<147> if (graphic_depth != 8 && graphic_depth != 24) {\n<149> fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth);\n<159> tcx_init(hwdef->tcx_base, 0x00100000, graphic_width, graphic_height,\n<225> if (hwdef->fd_base) {\n<229> memset(fd, 0, sizeof(fd));\n<233> sun4m_fdctrl_init(slavio_irq[22], hwdef->fd_base, fd,\n<251> if (drive_get_max_bus(IF_SCSI) > 0) {\n<253> fprintf(stderr, "qemu: too many SCSI bus\n");\n<319> nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, args->kernel_cmdline,\n<357> if (args->kernel_cmdline) {\n<365> fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, args->kernel_cmdline);\n<369> strlen(args->kernel_cmdline) + 1);
<1> void kqemu_record_dump(void)\n<15> pr = malloc(sizeof(PCRecord *) * nb_pc_records);\n<25> pr[i++] = r;\n<33> qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);\n<71> free(pr);
<1> void gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n<49> switch (*fmt++) {\n<61> if (*(fmt++) != 'x')\n<85> fprintf(stderr, "gdbstub: Bad syscall format string '%s'\n",\n<87> fmt - 1);
<1> static void csrhci_in_packet_vendor(struct csrhci_s *s, int ocf,\n<13> switch (ocf) {\n<19> if (len >= 18 + 8 && data[12] == 0x01 && data[13] == 0x00) {\n<23> s->bd_addr.b[0] = data[offset + 7];	/* Beyond cmd packet end(!?) */\n<25> s->bd_addr.b[1] = data[offset + 6];\n<27> s->bd_addr.b[2] = data[offset + 4];\n<29> s->bd_addr.b[3] = data[offset + 0];\n<31> s->bd_addr.b[4] = data[offset + 3];\n<33> s->bd_addr.b[5] = data[offset + 2];\n<39> fprintf(stderr, "%s: bd_address loaded from firmware: "\n<65> fprintf(stderr, "%s: got a bad CMD packet\n", __FUNCTION__);
<23> AVFrame *picture = data;\n<225> if(!s->lossless){\n<227> picture->quality= FFMAX3(s->qscale[0], s->qscale[1], s->qscale[2]);\n<231> picture->qscale_table= s->qscale_table;\n<233> memset(picture->qscale_table, picture->quality, (s->width+15)/16);\n<237> av_log(avctx, AV_LOG_DEBUG, "QP: %d\n", picture->quality);\n<239> picture->quality*= FF_QP2LAMBDA;
<1> static int xenfb_send_motion(struct XenInput *xenfb,\n<11> memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n<27> return xenfb_kbd_event(xenfb, &event);
<1> ram_addr_t qemu_ram_addr_from_host(void *ptr)\n<47> if (!block) {\n<49> fprintf(stderr, "Bad ram pointer %p\n", ptr);
<1> static int nuv_probe(AVProbeData *p) {\n<3> if (p->buf_size < 12)\n<7> if (!memcmp(p->buf, "NuppelVideo", 12))\n<9> return AVPROBE_SCORE_MAX;\n<11> if (!memcmp(p->buf, "MythTVVideo", 12))\n<13> return AVPROBE_SCORE_MAX;\n<15> return 0;
<1> static void tcx24_screen_dump(void *opaque, const char *filename, bool cswitch,\n<7> TCXState *s = opaque;\n<21> if (!f) {\n<23> error_setg(errp, "failed to open file '%s': %s", filename,\n<25> strerror(errno));\n<31> ret = fprintf(f, "P6\n%d %d\n%d\n", s->width, s->height, 255);\n<33> if (ret < 0) {\n<45> for(y = 0; y < s->height; y++) {\n<49> for(x = 0; x < s->width; x++, d++, s24++) {\n<55> ret = fputc((dval >> 16) & 0xff, f);\n<57> if (ret == EOF) {\n<65> if (ret == EOF) {\n<73> if (ret == EOF) {\n<83> ret = fputc(s->r[v], f);\n<85> if (ret == EOF) {\n<93> if (ret == EOF) {\n<101> if (ret == EOF) {\n<119> fclose(f);\n<127> error_setg(errp, "failed to write to file '%s': %s", filename,\n<129> strerror(errno));
<1> static int ac3_eac3_probe(AVProbeData *p, enum AVCodecID expected_codec_id)\n<33> for(frames = 0; buf2 < end; frames++) {\n<45> if(!memcmp(buf2, "\x1\x10\0\0\0\0\0\0", 8))\n<47> buf2+=16;\n<53> buf3[i  ] = buf2[i+1];\n<55> buf3[i+1] = buf2[i  ];\n<65> ret = av_ac3_parse_header(buf2, end - buf2, &bitstream_id,\n<73> if(buf2 + frame_size > end)\n<83> buf3[i  ] = buf2[i+1];\n<85> buf3[i+1] = buf2[i  ];\n<95> if (av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, buf2 + 2, frame_size - 2))\n<105> buf2 += frame_size;
<1> int ff_h264_decode_ref_pic_list_reordering(H264Context *h, H264SliceContext *sl)\n<15> for (list = 0; list < sl->list_count; list++) {\n<17> memcpy(sl->ref_list[list], h->default_ref_list[list], sl->ref_count[list] * sizeof(sl->ref_list[0][0]));\n<177> if (i < 0) {\n<183> memset(&sl->ref_list[list][index], 0, sizeof(sl->ref_list[0][0])); // FIXME\n<201> sl->ref_list[list][i] = sl->ref_list[list][i - 1];\n<205> ref_from_h264pic(&sl->ref_list[list][index], ref);\n<209> pic_as_field(&sl->ref_list[list][index], pic_structure);
<1> char *qemu_strdup(const char *str)\n<7> size_t len = strlen(str);\n<9> ptr = qemu_malloc(len + 1);\n<15> pstrcpy(ptr, len + 1, str);
<1> static int sbr_make_f_master(AACContext *ac, SpectralBandReplication *sbr,\n<209> int16_t vk0[49];\n<243> vk0[0] = 0;\n<257> vk0[0] = sbr->k[0];\n<269> vk0[k] += vk0[k-1];\n<277> int16_t vk1[49];\n<305> vk1[1]           += change;\n<307> vk1[num_bands_1] -= change;\n<317> vk1[0] = sbr->k[1];\n<329> vk1[k] += vk1[k-1];\n<337> if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))\n<343> (num_bands_0 + 1) * sizeof(sbr->f_master[0]));\n<345> memcpy(&sbr->f_master[num_bands_0 + 1], vk1 + 1,\n<347> num_bands_1      * sizeof(sbr->f_master[0]));\n<355> if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))\n<359> memcpy(sbr->f_master, vk0, (num_bands_0 + 1) * sizeof(sbr->f_master[0]));
<1> static void print_codec(const AVCodec *c)\n<5> int encoder = av_codec_is_encoder(c);\n<9> printf("%s %s [%s]:\n", encoder ? "Encoder" : "Decoder", c->name,\n<15> printf("    General capabilities: ");\n<17> if (c->capabilities & AV_CODEC_CAP_DRAW_HORIZ_BAND)\n<19> printf("horizband ");\n<21> if (c->capabilities & AV_CODEC_CAP_DR1)\n<23> printf("dr1 ");\n<25> if (c->capabilities & AV_CODEC_CAP_TRUNCATED)\n<27> printf("trunc ");\n<29> if (c->capabilities & AV_CODEC_CAP_DELAY)\n<31> printf("delay ");\n<33> if (c->capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME)\n<35> printf("small ");\n<37> if (c->capabilities & AV_CODEC_CAP_SUBFRAMES)\n<39> printf("subframes ");\n<41> if (c->capabilities & AV_CODEC_CAP_EXPERIMENTAL)\n<43> printf("exp ");\n<45> if (c->capabilities & AV_CODEC_CAP_CHANNEL_CONF)\n<47> printf("chconf ");\n<49> if (c->capabilities & AV_CODEC_CAP_PARAM_CHANGE)\n<51> printf("small ");\n<53> if (c->capabilities & AV_CODEC_CAP_PARAM_CHANGE)\n<55> printf("variable ");\n<57> if (c->capabilities & (AV_CODEC_CAP_FRAME_THREADS |\n<63> printf("threads ");\n<65> if (!c->capabilities)\n<67> printf("none");\n<69> printf("\n");\n<73> if (c->type == AVMEDIA_TYPE_VIDEO) {\n<75> printf("    Threading capabilities: ");\n<77> switch (c->capabilities & (AV_CODEC_CAP_FRAME_THREADS |\n<85> AV_CODEC_CAP_SLICE_THREADS: printf("frame and slice"); break;\n<87> case AV_CODEC_CAP_FRAME_THREADS: printf("frame");           break;\n<89> case AV_CODEC_CAP_SLICE_THREADS: printf("slice");           break;\n<91> case AV_CODEC_CAP_AUTO_THREADS : printf("auto");            break;\n<93> default:                         printf("none");            break;\n<97> printf("\n");\n<103> if (c->supported_framerates) {\n<105> const AVRational *fps = c->supported_framerates;\n<109> printf("    Supported framerates:");\n<111> while (fps->num) {\n<113> printf(" %d/%d", fps->num, fps->den);\n<115> fps++;\n<119> printf("\n");\n<135> PRINT_CODEC_SUPPORTED(c, channel_layouts, uint64_t, "channel layouts",
<1> int parse_debug_env(const char *name, int max, int initial)\n<5> char *debug_env = getenv(name);\n<13> if (!debug_env) {\n<27> if (debug < 0 || debug > max) {\n<29> fprintf(stderr, "warning: %s not in [0, %d]", name, max);
<1> static int usb_msd_handle_data(USBDevice *dev, USBPacket *p)\n<29> if (p->iov.size != 31) {\n<31> fprintf(stderr, "usb-msd: Bad CBW size");\n<39> if (le32_to_cpu(cbw.sig) != 0x43425355) {\n<41> fprintf(stderr, "usb-msd: Bad signature %08x\n",\n<43> le32_to_cpu(cbw.sig));\n<51> if (cbw.lun != 0) {\n<53> fprintf(stderr, "usb-msd: Bad LUN %d\n", cbw.lun);
<1> static int openfile(char *name, int flags, int growable)\n<5> if (bs) {\n<7> fprintf(stderr, "file open already, try 'help close'\n");\n<31> if (bdrv_open(bs, name, flags) == -1) {\n<33> fprintf(stderr, "%s: can't open device %s\n", progname, name);
<1> static int do_fork(CPUArchState *env, unsigned int flags, abi_ulong newsp,\n<33> if (flags & CLONE_VM) {\n<91> memset(&info, 0, sizeof(info));\n<127> ret = pthread_create(&info.thread, &attr, clone_func, &info);\n<133> sigprocmask(SIG_SETMASK, &info.sigmask, NULL);\n<141> pthread_cond_wait(&info.cond, &info.mutex);\n<143> ret = info.tid;\n<155> pthread_mutex_unlock(&info.mutex);\n<157> pthread_cond_destroy(&info.cond);\n<159> pthread_mutex_destroy(&info.mutex);
<1> static int encode_frame(AVCodecContext * avctx, AVPacket *pkt,\n<427> if(!(avctx->flags & CODEC_FLAG_BITEXACT))\n<429> add_entry(s, TIFF_SOFTWARE_NAME,     TIFF_STRING,\n<431> strlen(LIBAVCODEC_IDENT) + 1, LIBAVCODEC_IDENT);
<1> static void hid_keyboard_event(DeviceState *dev, QemuConsole *src,\n<21> if (hs->n + count > QUEUE_LENGTH) {\n<23> fprintf(stderr, "usb-kbd: warning: key event queue full\n");
<1> static int aio_read_f(int argc, char **argv)\n<7> struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n<11> while ((c = getopt(argc, argv, "CP:qv")) != EOF) {\n<13> switch (c) {\n<17> ctx->Cflag = 1;\n<23> ctx->Pflag = 1;\n<27> if (ctx->pattern < 0) {\n<29> free(ctx);\n<39> ctx->qflag = 1;\n<45> ctx->vflag = 1;\n<51> free(ctx);\n<61> if (optind > argc - 2) {\n<63> free(ctx);\n<71> ctx->offset = cvtnum(argv[optind]);\n<73> if (ctx->offset < 0) {\n<75> printf("non-numeric length argument -- %s\n", argv[optind]);\n<77> free(ctx);\n<87> if (ctx->offset & 0x1ff) {\n<93> free(ctx);\n<103> ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, 0xab);\n<105> if (ctx->buf == NULL) {\n<107> free(ctx);\n<115> gettimeofday(&ctx->t1, NULL);\n<117> bdrv_aio_readv(bs, ctx->offset >> 9, &ctx->qiov,
<1> static void arm_gic_common_reset(DeviceState *dev)\n<5> GICState *s = ARM_GIC_COMMON(dev);\n<9> memset(s->irq_state, 0, GIC_MAXIRQ * sizeof(gic_irq_state));
<1> static int raw_decode ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<18> buf_size = context -> length - AVPALETTE_SIZE ;\n<42> frame -> data [ 1 ] = context -> palette ;\n<45> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<46> if ( pal ) {\n<47> memcpy ( frame -> data [ 1 ] , pal , AVPALETTE_SIZE ) ;
<1> int main ( int argc , char * * argv ) {\n<12> tmpJobID [ 0 ] = '\0' ;\n<14> switch ( ArgIndex ) {\n<17> case 'j' : strncpy ( tmpJobID , optarg , sizeof ( tmpJobID ) ) ;\n<18> if ( tmpJobID [ PBS_MAXCLTJOBID - 1 ] != '\0' ) {\n<19> fprintf ( stderr , "pbs_track: given job ID too large (> %d)\n" , PBS_MAXCLTJOBID ) ;
<1> int hw_device_init_from_string(const char *arg, HWDevice **dev_out)\n<53> type = av_hwdevice_find_type_by_name(type_name);\n<65> if (*p == '=') {\n<107> index_pos = strlen(type_name);\n<109> name = av_malloc(index_pos + 4);\n<121> snprintf(name, index_pos + 4, "%s%d", type_name, index);\n<155> } else if (*p == ':') {\n<159> ++p;\n<161> q = strchr(p, ',');\n<165> device = av_strndup(p, q - p);\n<191> device ? device : p, options, 0);\n<267> av_freep(&type_name);
<1> static void test_dispatch_cmd_io(void)\n<45> assert(!strcmp(qdict_get_str(ret, "string"), "blah1"));\n<49> assert(!strcmp(qdict_get_str(ret_dict, "string"), "blah2"));\n<57> assert(!strcmp(qdict_get_str(ret_dict_dict_userdef, "string"), "hello"));\n<59> assert(!strcmp(qdict_get_str(ret_dict_dict, "string"), "blah3"));\n<67> assert(!strcmp(qdict_get_str(ret_dict_dict2_userdef, "string"), "hello2"));\n<69> assert(!strcmp(qdict_get_str(ret_dict_dict2, "string"), "blah4"));
<1> static int decode_rle(AVCodecContext *avctx, AVSubtitle *sub,\n<21> if (!sub->rects[0]->pict.data[0])\n<27> pixel_count = 0;\n<47> if (color == 0x00) {\n<57> color = flags & 0x80 ? bytestream_get_byte(&buf) : 0;\n<63> if (run > 0 && pixel_count + run <= sub->rects[0]->w * sub->rects[0]->h) {\n<65> memset(sub->rects[0]->pict.data[0] + pixel_count, color, run);\n<67> pixel_count += run;\n<79> if (pixel_count % sub->rects[0]->w > 0)\n<83> pixel_count % sub->rects[0]->w, sub->rects[0]->w);
<1> static int usb_host_auto_scan(void *opaque, int bus_num, int addr, char *port,\n<17> if (class_id == 9)\n<25> f = &s->match;\n<41> if (f->port != NULL && (port == NULL || strcmp(f->port, port) != 0)) {\n<79> usb_host_open(s, bus_num, addr, port, product_name, speed);
<1> static int monitor_parse(const char *devname)\n<11> if (strcmp(devname, "none") == 0)\n<13> return 0;\n<15> if (index == MAX_MONITOR_DEVICES) {\n<17> fprintf(stderr, "qemu: too many monitor devices\n");\n<23> if (index == 0) {\n<33> monitor_hds[index] = qemu_chr_open(label, devname, NULL);\n<35> if (!monitor_hds[index]) {\n<37> fprintf(stderr, "qemu: could not open monitor device '%s'\n",
<1> static int check_directory_consistency(BDRVVVFATState *s,\n<3> int cluster_num, const char* path)\n<13> mapping_t* mapping = find_mapping_for_cluster(s, cluster_num);\n<19> int path_len = strlen(path);\n<25> assert(path_len < PATH_MAX); /* len was tested before! */\n<27> pstrcpy(path2, sizeof(path2), path);\n<35> if (mapping) {\n<37> const char* basename = get_basename(mapping->path);\n<39> const char* basename2 = get_basename(path);\n<53> if (strcmp(basename, basename2))\n<55> schedule_rename(s, cluster_num, g_strdup(path));\n<61> schedule_mkdir(s, cluster_num, g_strdup(path));\n<65> lfn_init(&lfn);\n<79> if (s->used_clusters[cluster_num] & USED_ANY) {\n<81> fprintf(stderr, "cluster %d used more than once\n", (int)cluster_num);\n<91> DLOG(fprintf(stderr, "read cluster %d (sector %d)\n", (int)cluster_num, (int)cluster2sector(s, cluster_num)));\n<93> subret = vvfat_read(s->bs, cluster2sector(s, cluster_num), cluster,\n<97> if (subret) {\n<99> fprintf(stderr, "Error fetching direntries\n");\n<103> free(cluster);\n<111> for (i = 0; i < 0x10 * s->sectors_per_cluster; i++) {\n<127> subret = parse_long_name(&lfn, direntries + i);\n<129> if (subret < 0) {\n<131> fprintf(stderr, "Error in long name\n");\n<143> if (fat_chksum(direntries+i) != lfn.checksum) {\n<145> subret = parse_short_name(s, &lfn, direntries + i);\n<147> if (subret < 0) {\n<149> fprintf(stderr, "Error in short name (%d)\n", subret);\n<155> if (subret > 0 || !strcmp((char*)lfn.name, ".")\n<157> || !strcmp((char*)lfn.name, ".."))\n<163> lfn.checksum = 0x100; /* cannot use long name twice */\n<167> if (path_len + 1 + lfn.len >= PATH_MAX) {\n<169> fprintf(stderr, "Name too long: %s/%s\n", path, lfn.name);\n<183> if (begin_of_direntry(direntries + i) == 0) {\n<195> if (cluster_count == 0) {\n<215> DLOG(fprintf(stderr, "Cluster count mismatch\n"));\n<235> } while(!fat_eof(s, cluster_num));\n<239> free(cluster);
<1> static void bdrv_qed_invalidate_cache(BlockDriverState *bs, Error **errp)\n<5> BDRVQEDState *s = bs->opaque;\n<17> memset(s, 0, sizeof(BDRVQEDState));
<1> static void omap_rtc_write(void *opaque, target_phys_addr_t addr,\n<7> struct omap_rtc_s *s = (struct omap_rtc_s *) opaque;\n<25> switch (offset) {\n<107> memcpy(&new_tm, &s->current_tm, sizeof(new_tm));\n<111> ti[0] = mktimegm(&s->current_tm);\n<113> ti[1] = mktimegm(&new_tm);\n<145> memcpy(&new_tm, &s->current_tm, sizeof(new_tm));\n<149> ti[0] = mktimegm(&s->current_tm);\n<151> ti[1] = mktimegm(&new_tm);
<1> static void print_format_entry(const char *tag,\n<3> const char *val)\n<9> if (tag) {\n<11> printf("%s=%s\n", tag, val);\n<15> printf("%s\n", val);\n<19> } else if (tag && av_dict_get(fmt_entries_to_show, tag, NULL, 0)) {\n<21> if (nb_fmt_entries_to_show > 1)\n<23> printf("%s=", tag);\n<25> printf("%s\n", val);
<1> static void omap_rtc_alarm_update(struct omap_rtc_s *s)\n<7> if (s->alarm_ti == -1)\n<9> printf("%s: conversion failed\n", __FUNCTION__);
<1> ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {\n<3> clone = ( ArchiveHandle * ) pg_malloc ( sizeof ( ArchiveHandle ) ) ;\n<4> memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;\n<5> memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;\n<12> if ( clone -> savedPassword ) clone -> savedPassword = pg_strdup ( clone -> savedPassword ) ;\n<14> if ( AH -> mode == archModeRead ) {\n<16> Assert ( AH -> connection == NULL ) ;\n<17> ConnectDatabase ( ( Archive * ) clone , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;\n<18> _doSetFixedOutputState ( clone ) ;\n<25> Assert ( AH -> connection != NULL ) ;\n<26> dbname = PQdb ( AH -> connection ) ;\n<27> pghost = PQhost ( AH -> connection ) ;\n<28> pgport = PQport ( AH -> connection ) ;\n<29> username = PQuser ( AH -> connection ) ;\n<30> ConnectDatabase ( ( Archive * ) clone , dbname , pghost , pgport , username , TRI_NO ) ;\n<32> ( clone -> ClonePtr ) ( clone ) ;
<1> av_cold int ff_rate_control_init(MpegEncContext *s)\n<149> p = s->avctx->stats_in;\n<151> for (i = -1; p; i++)\n<153> p = strchr(p + 1, ';');\n<177> rce->pict_type  = rce->new_pict_type = AV_PICTURE_TYPE_P;\n<179> rce->qscale     = rce->new_qscale    = FF_QP2LAMBDA * 2;\n<181> rce->misc_bits  = s->mb_num + 10;\n<183> rce->mb_var_sum = s->mb_num * 100;\n<191> p = s->avctx->stats_in;\n<193> for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) {\n<205> next = strchr(p, ';');\n<211> next++;\n<215> e = sscanf(p, " in:%d ", &picture_number);\n<219> assert(picture_number >= 0);\n<221> assert(picture_number < rcc->num_entries);\n<223> rce = &rcc->entry[picture_number];\n<227> e += sscanf(p, " in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d",\n<239> if (e != 14) {\n<253> p = next;\n<337> rce.new_pict_type = rce.pict_type;\n<377> rcc->i_cplx_sum[rce.pict_type]  += rce.i_tex_bits * rce.qscale;\n<379> rcc->p_cplx_sum[rce.pict_type]  += rce.p_tex_bits * rce.qscale;\n<387> get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i);
<1> BusState *qdev_get_child_bus(DeviceState *dev, const char *name)\n<9> LIST_FOREACH(bus, &dev->child_bus, sibling) {\n<11> if (strcmp(name, bus->name) == 0) {\n<13> return bus;\n<19> return NULL;
<1> ff_yuv2packedX_altivec(SwsContext *c, const int16_t *lumFilter,\n<317> switch(c->dstFormat) {\n<345> memcpy (&((uint32_t*)dest)[i], scratch, (dstW-i)/4);
<1> static int idcin_read_packet(AVFormatContext *s,\n<25> uint32_t palette[256];\n<75> palette[i] = (r << 16) | (g << 8) | (b);\n<111> pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n<115> if (ret < 0)\n<119> memcpy(pal, palette, AVPALETTE_SIZE);
<1> void ff_mpc_dequantize_and_synth(MPCContext * c, int maxband, void *data, int channels)\n<17> memset(c->sb_samples, 0, sizeof(c->sb_samples));\n<73> mpc_synth(c, data, channels);
<1> static int cpudef_setfield(const char *name, const char *str, void *opaque)\n<5> x86_def_t *def = opaque;\n<11> if (!strcmp(name, "name")) {\n<13> def->name = strdup(str);\n<15> } else if (!strcmp(name, "model_id")) {\n<17> strncpy(def->model_id, str, sizeof (def->model_id));\n<19> } else if (!strcmp(name, "level")) {\n<21> setscalar(&def->level, str, &err)\n<23> } else if (!strcmp(name, "vendor")) {\n<25> cpyid(&str[0], &def->vendor1);\n<27> cpyid(&str[4], &def->vendor2);\n<29> cpyid(&str[8], &def->vendor3);\n<31> } else if (!strcmp(name, "family")) {\n<33> setscalar(&def->family, str, &err)\n<35> } else if (!strcmp(name, "model")) {\n<37> setscalar(&def->model, str, &err)\n<39> } else if (!strcmp(name, "stepping")) {\n<41> setscalar(&def->stepping, str, &err)\n<43> } else if (!strcmp(name, "feature_edx")) {\n<45> setfeatures(&def->features, str, feature_name, &err);\n<47> } else if (!strcmp(name, "feature_ecx")) {\n<49> setfeatures(&def->ext_features, str, ext_feature_name, &err);\n<51> } else if (!strcmp(name, "extfeature_edx")) {\n<53> setfeatures(&def->ext2_features, str, ext2_feature_name, &err);\n<55> } else if (!strcmp(name, "extfeature_ecx")) {\n<57> setfeatures(&def->ext3_features, str, ext3_feature_name, &err);\n<59> } else if (!strcmp(name, "xlevel")) {\n<61> setscalar(&def->xlevel, str, &err)\n<65> fprintf(stderr, "error: unknown option [%s = %s]\n", name, str);\n<67> return (1);\n<71> if (err) {\n<73> fprintf(stderr, "error: bad option value [%s = %s]\n", name, str);
<1> static int transcode_init(void)\n<101> AVCodecContext *dec_ctx = NULL;\n<117> enc_ctx = ost->stream_copy ? ost->st->codec : ost->enc_ctx;\n<123> dec_ctx = ist->dec_ctx;\n<167> extra_size = (uint64_t)dec_ctx->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n<211> if (dec_ctx->extradata_size) {\n<215> if (!enc_ctx->extradata) {\n<221> memcpy(enc_ctx->extradata, dec_ctx->extradata, dec_ctx->extradata_size);\n<225> enc_ctx->extradata_size= dec_ctx->extradata_size;\n<243> if(!strcmp(oc->oformat->name, "avi")) {\n<245> if ( copy_tb<0 && av_q2d(ist->st->r_frame_rate) >= av_q2d(ist->st->avg_frame_rate)\n<277> } else if(!(oc->oformat->flags & AVFMT_VARIABLE_FPS)\n<279> && strcmp(oc->oformat->name, "mov") && strcmp(oc->oformat->name, "mp4") && strcmp(oc->oformat->name, "3gp")\n<281> && strcmp(oc->oformat->name, "3g2") && strcmp(oc->oformat->name, "psp") && strcmp(oc->oformat->name, "ipod")\n<283> && strcmp(oc->oformat->name, "f4v")\n<347> const AVPacketSideData *sd_src = &ist->st->side_data[j];\n<349> AVPacketSideData *sd_dst = &ost->st->side_data[j];\n<353> sd_dst->data = av_malloc(sd_src->size);\n<355> if (!sd_dst->data)\n<359> memcpy(sd_dst->data, sd_src->data, sd_src->size);\n<361> sd_dst->size = sd_src->size;\n<481> if (!ost->enc)\n<485> if (!ost->enc) {\n<569> if (ost->enc && ost->enc->supported_framerates && !ost->force_fps) {\n<647> if (!strncmp(ost->enc->name, "libx264", 7) &&\n<661> if (!strncmp(ost->enc->name, "mpeg2video", 10) &&\n<683> if (!dec_ctx ||\n<761> if (enc_ctx->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2)) {\n<777> if (!strcmp(ost->enc->name, "libx264")) {\n<779> av_dict_set(&ost->encoder_opts, "stats", logfilename, AV_DICT_DONT_OVERWRITE);\n<783> if (enc_ctx->flags & CODEC_FLAG_PASS2) {\n<803> if (enc_ctx->flags & CODEC_FLAG_PASS1) {\n<807> if (!f) {\n<809> av_log(NULL, AV_LOG_FATAL, "Cannot write log file '%s' for pass-1 encoding: %s\n",\n<811> logfilename, strerror(errno));\n<901> AVCodec      *codec = ost->enc;\n<907> if ((ist = get_input_stream(ost)))\n<911> if (dec && dec->subtitle_header) {\n<915> ost->enc_ctx->subtitle_header = av_mallocz(dec->subtitle_header_size + 1);\n<917> if (!ost->enc_ctx->subtitle_header) {\n<925> memcpy(ost->enc_ctx->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<927> ost->enc_ctx->subtitle_header_size = dec->subtitle_header_size;\n<939> if ((ret = avcodec_open2(ost->enc_ctx, codec, &ost->encoder_opts)) < 0) {\n<971> ret = avcodec_copy_context(ost->st->codec, ost->enc_ctx);\n<993> ret = av_opt_set_dict(ost->enc_ctx, &ost->encoder_opts);\n<1025> avcodec_close(ost->enc_ctx);\n<1075> if ((ret = avformat_write_header(oc, &output_files[i]->opts)) < 0) {\n<1093> if (strcmp(oc->oformat->name, "rtp")) {\n<1095> want_sdp = 0;\n<1183> av_log(NULL, AV_LOG_INFO, " -> Stream #%d:%d (%s)\n", ost->file_index,\n<1185> ost->index, ost->enc ? ost->enc->name : "?");\n<1219> const AVCodec *out_codec   = ost->enc;\n<1223> const char *in_codec_name  = "?";\n<1227> const char *out_codec_name = "?";\n<1233> if (in_codec) {\n<1235> decoder_name  = in_codec->name;\n<1241> in_codec_name = desc->name;\n<1243> if (!strcmp(decoder_name, in_codec_name))\n<1245> decoder_name = "native";\n<1251> if (out_codec) {\n<1253> encoder_name   = out_codec->name;\n<1259> out_codec_name = desc->name;\n<1261> if (!strcmp(encoder_name, out_codec_name))\n<1263> encoder_name = "native";\n<1269> av_log(NULL, AV_LOG_INFO, " (%s (%s) -> %s (%s))",
<1> START_TEST(qstring_get_str_test)\n<13> qstring = qstring_from_str(str);\n<15> ret_str = qstring_get_str(qstring);\n<17> fail_unless(strcmp(ret_str, str) == 0);
<1> static int set_string_fmt(void *obj, const AVOption *o, const char *val, uint8_t *dst,\n<11> if (!val || !strcmp(val, "none")) {\n<13> fmt = -1;\n<17> fmt = get_fmt(val);\n<19> if (fmt == -1) {\n<41> *(int *)dst = fmt;\n<43> return 0;
<1> static void term_insert_char(int ch)\n<5> if (term_cmd_buf_index < TERM_CMD_BUF_SIZE) {\n<11> term_cmd_buf_size - term_cmd_buf_index);
<1> int select_watchdog(const char *p)\n<13> if (strcmp(p, "?") == 0) {\n<15> LIST_FOREACH(model, &watchdog_list, entry) {\n<19> model->wdt_name, model->wdt_description);\n<23> return 2;\n<29> LIST_FOREACH(model, &watchdog_list, entry) {\n<31> if (strcasecmp(model->wdt_name, p) == 0) {\n<47> fprintf(stderr, "Unknown -watchdog device. Supported devices are:\n");\n<49> LIST_FOREACH(model, &watchdog_list, entry) {
<1> void address_space_rw(AddressSpace *as, target_phys_addr_t addr, uint8_t *buf,\n<27> if (l > len)\n<29> l = len;\n<79> } else if (!section->readonly) {\n<89> ptr = qemu_get_ram_ptr(addr1);\n<91> memcpy(ptr, buf, l);\n<93> invalidate_and_set_dirty(addr1, l);\n<95> qemu_put_ram_ptr(ptr);\n<153> memcpy(buf, ptr, l);\n<155> qemu_put_ram_ptr(ptr);\n<161> len -= l;\n<163> buf += l;\n<165> addr += l;
<1> void Process(void *ctx, AVPicture *picture, enum PixelFormat pix_fmt, int width, int height, int64_t pts)\n<199> while ((dent = readdir(d))) {\n<201> if (strncmp("fishimg", dent->d_name, 7) == 0) {\n<203> if (strcmp(".ppm", dent->d_name + strlen(dent->d_name) - 4) == 0) {\n<205> foundfile++;\n<275> f = fopen(fname, "w");\n<277> if (f) {\n<279> fprintf(f, "P6 %d %d 255\n", width, height);\n<281> fwrite(buf, width * height * 3, 1, f);\n<283> fclose(f);
<1> static CharDriverState *qemu_chr_open_socket(QemuOpts *opts)\n<115> qemu_set_fd_handler2(s->listen_fd, NULL, tcp_chr_accept, NULL, chr);\n<131> tcp_chr_connect(chr);\n<169> if (is_listen && is_waitconnect) {\n<175> tcp_chr_accept(chr);\n<181> return chr;
<1> static void steamdiscover_dissect_body_authrequest ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n<14> switch ( tag . field_number ) {\n<23> devicename = tvb_get_string_enc ( strpool , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n<24> if ( devicename && strlen ( devicename ) ) {\n<25> col_append_fstr ( pinfo -> cinfo , COL_INFO , " from %s" , devicename ) ;
<1> static void blizzard_reg_write(void *opaque, uint8_t reg, uint16_t value)\n<5> BlizzardState *s = (BlizzardState *) opaque;\n<9> switch (reg) {\n<43> if ((value & 3) == 0 || (value & 3) == 3)\n<45> fprintf(stderr, "%s: wrong PLL Control bits (%i)\n",\n<47> __FUNCTION__, value & 3);\n<123> if (value & (1 << 7))\n<125> fprintf(stderr, "%s: data swap not supported!\n", __FUNCTION__);\n<211> if (((value >> 4) & 3) == 3)\n<213> fprintf(stderr, "%s: Illegal active-data-links value\n",\n<323> if (value & (1 << 4))\n<325> fprintf(stderr, "%s: Macrovision enable attempt!\n", __FUNCTION__);\n<471> s->iformat = value & 0xf;\n<475> if (!s->bpp)\n<477> fprintf(stderr, "%s: Illegal or unsupported input format %x\n",\n<489> if ((!(s->effect & (1 << 3)) && (s->ix[0] != s->ox[0] ||\n<501> fprintf(stderr, "%s: Illegal input/output window positions\n",\n<607> if (value & s->mode & 1)\n<609> fprintf(stderr, "%s: The display must be disabled before entering "\n<673> fprintf(stderr, "%s: unknown register %02x\n", __FUNCTION__, reg);
<1> static unsigned int dec_addi_acr(DisasContext *dc)\n<7> DIS(fprintf (logfile, "addi.%c $r%u, $r%u, $acr\n",\n<9> memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n<11> cris_cc_mask(dc, 0);
<1> static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<91> ptr    = p->data[0];\n<99> if (buf_end - buf < w * bytes_per_pixel)\n<113> memcpy(ptr, buf, w*bytes_per_pixel);\n<117> ptr += stride;\n<119> buf += w*bytes_per_pixel;
<11> AVCodecContext *enc = &s->streams[stream_index]->codec;\n<13> MOVTrack* trk = &mov->tracks[stream_index];\n<73> if ((enc->codec_id == CODEC_ID_MPEG4 || enc->codec_id == CODEC_ID_AAC)\n<83> trk->vosData = av_malloc(trk->vosLen);\n<85> memcpy(trk->vosData, enc->extradata, trk->vosLen);\n<145> trk->enc = enc;
<1> static void readline_printf_func(void *opaque, const char *fmt, ...)\n<7> va_start(ap, fmt);\n<9> vprintf(fmt, ap);\n<11> va_end(ap);
<25> ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,\n<65> for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {\n<85> memmove(q->weighting_delay, &q->weighting_delay[2],\n<87> 4 * sizeof(*q->weighting_delay));\n<109> ret = decode_channel_sound_unit(q, &q->gb, &q->units[1],\n<129> channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);
<1> void hmp_sendkey(Monitor *mon, const QDict *qdict)\n<5> const char *keys = qdict_get_str(qdict, "keys");\n<23> separator = strchr(keys, '-');\n<25> keyname_len = separator ? separator - keys : strlen(keys);\n<31> if (keys[0] == '<' && keyname_len == 1) {\n<63> if (strstart(keys, "0x", NULL)) {\n<99> if (!separator) {\n<105> keys = separator + 1;
<1> static void x86_cpu_parse_featurestr(CPUState *cs, char *features,\n<27> featurestr = features ? strtok(features, ",") : NULL;\n<35> if (featurestr[0] == '+') {\n<37> add_flagname_to_bitmaps(featurestr + 1, plus_features, &local_err);\n<39> } else if (featurestr[0] == '-') {\n<41> add_flagname_to_bitmaps(featurestr + 1, minus_features, &local_err);\n<43> } else if ((val = strchr(featurestr, '='))) {\n<45> *val = 0; val++;\n<47> feat2prop(featurestr);\n<49> if (!strcmp(featurestr, "tsc-freq")) {\n<55> char num[32];\n<59> tsc_freq = qemu_strtosz_suffix_unit(val, &err,\n<63> if (tsc_freq < 0 || *err) {\n<79> object_property_parse(OBJECT(cpu), val, featurestr, &local_err);\n<85> feat2prop(featurestr);\n<87> object_property_parse(OBJECT(cpu), "on", featurestr, &local_err);\n<91> if (local_err) {\n<99> featurestr = strtok(NULL, ",");
<1> static void *kqemu_vmalloc(size_t size)\n<47> if (phys_ram_fd < 0) {\n<49> tmpdir = getenv("QEMU_TMPDIR");\n<51> if (!tmpdir)\n<63> if (statfs(tmpdir, &stfs) == 0) {\n<75> if ((ram_size + 8192 * 1024) >= free_space) {\n<77> ram_mb = (ram_size / (1024 * 1024));\n<85> if (strcmp(tmpdir, "/dev/shm") == 0) {\n<87> fprintf(stderr, "To have more space available provided you have enough RAM and swap, do as root:\n"\n<91> ram_mb + 16);\n<105> fprintf(stderr, "Or disable the accelerator module with -no-kqemu\n");\n<113> snprintf(phys_ram_file, sizeof(phys_ram_file), "%s/qemuXXXXXX",\n<119> if (phys_ram_fd < 0) {\n<135> phys_ram_fd = mkstemp(phys_ram_file);\n<137> if (phys_ram_fd < 0) {\n<139> fprintf(stderr, "Could not create temporary memory file '%s'\n",\n<149> unlink(phys_ram_file);\n<167> if (ptr == MAP_FAILED) {\n<169> fprintf(stderr, "Could not map physical memory\n");
<1> static int tscc2_decode_mb(TSCC2Context *c, int *q, int vlc_set,\n<3> uint8_t *dst, int stride, int plane)\n<19> val = get_bits(gb, 8);\n<21> for (i = 0; i < 8; i++, dst += stride)\n<23> memset(dst, val, 16);\n<77> c->block[0] = dc;\n<83> if (nc == -1)\n<91> memset(c->block + 1, 0, 15 * sizeof(*c->block));\n<113> c->block[tscc2_zigzag[bpos++]] = val;\n<117> tscc2_idct4_put(c->block, q, dst + k * 4, stride);
<1> static MigrationState *migrate_init(Monitor *mon, int detach, int blk, int inc)\n<5> MigrationState *s = migrate_get_current();\n<11> memset(s, 0, sizeof(*s));\n<39> migrate_fd_monitor_suspend(s, mon);\n<45> return s;
<1> static int aio_write_f(int argc, char **argv)\n<9> struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n<13> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<15> switch (c) {\n<19> ctx->Cflag = 1;\n<25> ctx->qflag = 1;\n<33> if (pattern < 0) {\n<35> free(ctx);\n<45> free(ctx);\n<55> if (optind > argc - 2) {\n<57> free(ctx);\n<65> ctx->offset = cvtnum(argv[optind]);\n<67> if (ctx->offset < 0) {\n<69> printf("non-numeric length argument -- %s\n", argv[optind]);\n<71> free(ctx);\n<81> if (ctx->offset & 0x1ff) {\n<87> free(ctx);\n<97> ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n<99> if (ctx->buf == NULL) {\n<101> free(ctx);\n<109> gettimeofday(&ctx->t1, NULL);\n<111> bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,
<1> static int kvm_get_msr(CPUState *env, struct kvm_msr_entry *msrs, int n)\n<5> struct kvm_msrs *kmsrs = qemu_malloc(sizeof *kmsrs + n * sizeof *msrs);\n<11> kmsrs->nmsrs = n;\n<13> memcpy(kmsrs->entries, msrs, n * sizeof *msrs);\n<15> r = kvm_vcpu_ioctl(env, KVM_GET_MSRS, kmsrs);\n<17> memcpy(msrs, kmsrs->entries, n * sizeof *msrs);\n<19> free(kmsrs);
<1> static int proxy_parse_opts(QemuOpts *opts, struct FsDriverEntry *fs)\n<11> if (!socket && !sock_fd) {\n<13> fprintf(stderr, "socket and sock_fd none of the option specified\n");\n<19> if (socket && sock_fd) {\n<21> fprintf(stderr, "Both socket and sock_fd options specified\n");
<1> static int encode_frame(AVCodecContext* avc_context, uint8_t *outbuf,\n<137> if (buf_size < o_packet.bytes) {\n<145> memcpy(outbuf, o_packet.packet, o_packet.bytes);
<1> void net_tx_pkt_reset(struct NetTxPkt *pkt)\n<11> if (!pkt) {\n<19> memset(&pkt->virt_hdr, 0, sizeof(pkt->virt_hdr));
<1> static void qcow_aio_read_cb(void *opaque, int ret)\n<5> QCowAIOCB *acb = opaque;\n<9> BDRVQcowState *s = bs->opaque;\n<37> qcow2_encrypt_sectors(s, acb->sector_num, acb->buf, acb->buf,\n<53> acb->buf += acb->cur_nr_sectors * 512;\n<83> if (bs->backing_hd) {\n<125> memset(acb->buf, 0, 512 * acb->cur_nr_sectors);\n<127> ret = qcow_schedule_bh(qcow_aio_read_bh, acb);\n<139> if (qcow2_decompress_cluster(bs, acb->cluster_offset) < 0)\n<143> memcpy(acb->buf, s->cluster_cache + index_in_cluster * 512,\n<145> 512 * acb->cur_nr_sectors);\n<147> ret = qcow_schedule_bh(qcow_aio_read_bh, acb);\n<207> qemu_aio_release(acb);
<1> PXA2xxState *pxa270_init(MemoryRegion *address_space,\n<17> if (revision && strncmp(revision, "pxa27", 5)) {\n<19> fprintf(stderr, "Machine requires a PXA27x processor.\n");\n<33> if (s->cpu == NULL) {\n<35> fprintf(stderr, "Unable to find CPU definition\n");\n<99> if (!dinfo) {\n<101> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> static void s390_init(ram_addr_t my_ram_size,\n<7> const char *kernel_cmdline,\n<79> virtio_region_len = my_ram_size - ram_size;\n<83> virtio_region = cpu_physical_memory_map(virtio_region_start,\n<87> memset(virtio_region, 0, virtio_region_len);\n<89> cpu_physical_memory_unmap(virtio_region, virtio_region_len, 1,\n<225> if (initrd_filename) {\n<235> initrd_size = load_image_targphys(initrd_filename, initrd_offset,\n<241> memcpy(rom_ptr(INITRD_PARM_START), &initrd_offset, 8);\n<243> memcpy(rom_ptr(INITRD_PARM_SIZE), &initrd_size, 8);\n<249> if (kernel_cmdline) {\n<253> memcpy(rom_ptr(KERN_PARM_AREA), kernel_cmdline,\n<255> strlen(kernel_cmdline) + 1);\n<263> for(i = 0; i < nb_nics; i++) {\n<265> NICInfo *nd = &nd_table[i];\n<271> if (!nd->model) {\n<273> nd->model = g_strdup("virtio");\n<279> if (strcmp(nd->model, "virtio")) {\n<281> fprintf(stderr, "S390 only supports VirtIO nics\n");\n<283> exit(1);\n<291> qdev_set_nic_properties(dev, nd);
<1> static void extrapolate_isf(float out[LP_ORDER_16k], float isf[LP_ORDER])\n<17> memcpy(out, isf, (LP_ORDER - 1) * sizeof(float));\n<19> out[LP_ORDER_16k - 1] = isf[LP_ORDER - 1];\n<27> diff_isf[i] = isf[i + 1] - isf[i];\n<61> out[i] = isf[i - 1] + isf[i - 1 - i_max_corr]\n<69> est   = 7965 + (out[2] - out[3] - out[4]) / 6.0;\n<71> scale = 0.5 * (FFMIN(est, 7600) - out[LP_ORDER - 2]) /\n<73> (out[LP_ORDER_16k - 2] - out[LP_ORDER - 2]);\n<79> diff_hi[i] = scale * (out[i] - out[i - 1]);\n<103> out[i] = out[i - 1] + diff_hi[i] * (1.0f / (1 << 15));\n<111> out[i] *= 0.8;
<1> static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)\n<67> for (i = 0; i < 5; i++) {\n<69> memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));
<1> static void rtas_ibm_get_system_parameter(PowerPCCPU *cpu,\n<15> target_ulong buffer = rtas_ld(args, 1);\n<17> target_ulong length = rtas_ld(args, 2);\n<23> switch (parameter) {\n<43> ret = sysparm_st(buffer, length, param_val, strlen(param_val) + 1);\n<45> g_free(param_val);
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<61> if ((refcount == 1) != ((l2_offset & QCOW_OFLAG_COPIED) != 0)) {\n<63> printf("ERROR OFLAG_COPIED: l2_offset=%llx refcount=%d\n",\n<71> l2_offset &= ~QCOW_OFLAG_COPIED;\n<73> if (bdrv_pread(s->hd, l2_offset, l2_table, l2_size) != l2_size)\n<85> if (offset & QCOW_OFLAG_COPIED) {\n<87> printf("ERROR: cluster %lld: copied flag must never be set for compressed clusters\n",\n<89> offset >> s->cluster_bits);\n<113> if ((refcount == 1) != ((offset & QCOW_OFLAG_COPIED) != 0)) {\n<115> printf("ERROR OFLAG_COPIED: offset=%llx refcount=%d\n",\n<123> offset &= ~QCOW_OFLAG_COPIED;\n<157> printf("ERROR: I/O error in check_refcounts_l1\n");
<1> QString *qstring_from_substr(const char *str, int start, int end)\n<9> qstring = g_malloc(sizeof(*qstring));\n<13> qstring->length = end - start + 1;\n<19> qstring->string = g_malloc(qstring->capacity + 1);\n<21> memcpy(qstring->string, str + start, qstring->length);\n<27> QOBJECT_INIT(qstring, &qstring_type);\n<31> return qstring;
<1> static int rv34_decode_intra_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n<5> memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n<6> fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n<13> cbp = rv34_decode_intra_mb_header ( r , intra_types ) ;\n<20> rv34_output_i16x16 ( r , intra_types , cbp ) ;\n<23> rv34_output_intra ( r , intra_types , cbp ) ;
<1> static void psy_3gpp_analyze(FFPsyContext *ctx, int channel,\n<9> AacPsyChannel *pch  = &pctx->ch[channel];\n<81> memcpy(pch->prev_band, pch->band, sizeof(pch->band));
<1> static void cpu_common_parse_features(const char *typename, char *features,\n<29> if (cpu_globals_initialized) {\n<39> featurestr = features ? strtok(features, ",") : NULL;\n<43> while (featurestr) {\n<45> val = strchr(featurestr, '=');\n<47> if (val) {\n<53> val++;\n<57> prop->property = g_strdup(featurestr);\n<67> error_setg(errp, "Expected key=value format, found %s.",\n<75> featurestr = strtok(NULL, ",");
<1> static int cpu_x86_fill_model_id(char *str)\n<11> for (i = 0; i < 3; i++) {\n<13> host_cpuid(0x80000002 + i, 0, &eax, &ebx, &ecx, &edx);\n<15> memcpy(str + i * 16 +  0, &eax, 4);\n<17> memcpy(str + i * 16 +  4, &ebx, 4);\n<19> memcpy(str + i * 16 +  8, &ecx, 4);\n<21> memcpy(str + i * 16 + 12, &edx, 4);
<13> if(pps == NULL)\n<117> if(pps->ref_count[0]-1 > 32-1 || pps->ref_count[1]-1 > 32-1){\n<151> memcpy(pps->scaling_matrix4, h->sps_buffers[pps->sps_id]->scaling_matrix4, sizeof(pps->scaling_matrix4));\n<153> memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8));\n<161> decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8);\n<173> build_qp_table(pps, 0, pps->chroma_qp_index_offset[0]);\n<175> build_qp_table(pps, 1, pps->chroma_qp_index_offset[1]);
<1> void pstrcpy_targphys(const char *name, target_phys_addr_t dest, int buf_size,\n<3> const char *source)\n<13> if (buf_size <= 0) return;\n<15> nulp = memchr(source, 0, buf_size);\n<19> rom_add_blob_fixed(name, source, (nulp - source) + 1, dest);\n<23> rom_add_blob_fixed(name, source, buf_size, dest);
<1> static void encode_picture(MpegEncContext *s, int picture_number)\n<109> if(s->pict_type != I_TYPE){\n<129> ff_pre_estimate_p_frame_motion(s, mb_x, mb_y);\n<175> ff_estimate_b_frame_motion(s, mb_x, mb_y);\n<179> ff_estimate_p_frame_motion(s, mb_x, mb_y);\n<191> memset(s->motion_val[0], 0, sizeof(int16_t)*(s->mb_width*2 + 2)*(s->mb_height*2 + 2)*2);\n<193> memset(s->p_mv_table   , 0, sizeof(int16_t)*(s->mb_width+2)*(s->mb_height+2)*2);\n<195> memset(s->mb_type      , MB_TYPE_INTRA, sizeof(uint8_t)*s->mb_width*s->mb_height);\n<241> if(s->scene_change_score > 0 && s->pict_type == P_TYPE){\n<245> memset(s->mb_type   , MB_TYPE_INTRA, sizeof(uint8_t)*s->mb_width*s->mb_height);\n<255> s->f_code= ff_get_best_fcode(s, s->p_mv_table, MB_TYPE_INTER);\n<261> ff_fix_long_p_mvs(s);\n<275> a = ff_get_best_fcode(s, s->b_forw_mv_table, MB_TYPE_FORWARD);\n<277> b = ff_get_best_fcode(s, s->b_bidir_forw_mv_table, MB_TYPE_BIDIR);\n<283> a = ff_get_best_fcode(s, s->b_back_mv_table, MB_TYPE_BACKWARD);\n<285> b = ff_get_best_fcode(s, s->b_bidir_back_mv_table, MB_TYPE_BIDIR);\n<291> ff_fix_long_b_mvs(s, s->b_forw_mv_table, s->f_code, MB_TYPE_FORWARD);\n<293> ff_fix_long_b_mvs(s, s->b_back_mv_table, s->b_code, MB_TYPE_BACKWARD);\n<295> ff_fix_long_b_mvs(s, s->b_bidir_forw_mv_table, s->f_code, MB_TYPE_BIDIR);\n<297> ff_fix_long_b_mvs(s, s->b_bidir_back_mv_table, s->b_code, MB_TYPE_BIDIR);\n<309> s->frame_qscale = ff_rate_estimate_qscale(s);\n<363> convert_matrix(s, s->q_intra_matrix, s->q_intra_matrix16,\n<391> mjpeg_picture_header(s);\n<425> mpeg1_encode_picture_header(s, picture_number);\n<667> copy_context_before_encode(&backup_s, s, -1);\n<697> encode_mb_hq(s, &backup_s, &best_s, MB_TYPE_INTER, pb, pb2, tex_pb,\n<719> encode_mb_hq(s, &backup_s, &best_s, MB_TYPE_INTER4V, pb, pb2, tex_pb,\n<737> encode_mb_hq(s, &backup_s, &best_s, MB_TYPE_FORWARD, pb, pb2, tex_pb,\n<755> encode_mb_hq(s, &backup_s, &best_s, MB_TYPE_BACKWARD, pb, pb2, tex_pb,\n<777> encode_mb_hq(s, &backup_s, &best_s, MB_TYPE_BIDIR, pb, pb2, tex_pb,\n<801> encode_mb_hq(s, &backup_s, &best_s, MB_TYPE_DIRECT, pb, pb2, tex_pb,\n<807> if(mb_type&MB_TYPE_INTRA){\n<819> encode_mb_hq(s, &backup_s, &best_s, MB_TYPE_INTRA, pb, pb2, tex_pb,\n<831> copy_context_after_encode(s, &best_s, -1);\n<919> intra_score= s->dsp.mb_cmp[0](s, s->me.scratchpad, dest_y, s->linesize);\n<977> intra_score+= s->dsp.mb_cmp[1](s, s->me.scratchpad, dest_c, s->uvlinesize);\n<1035> mb_type= MB_TYPE_INTRA;\n<1047> switch(mb_type){\n<1161> printf("illegal MB type\n");\n<1167> encode_mb(s, motion_x, motion_y);\n<1191> MPV_decode_mb(s, s->block);
<1> static void dump_json_image_info(ImageInfo *info)\n<21> printf("%s\n", qstring_get_str(str));
<1> static void exec_accept_incoming_migration(void *opaque)\n<13> if (ret < 0) {\n<15> fprintf(stderr, "load of migration failed\n");
<1> build_header(GArray *linker, GArray *table_data,\n<3> AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n<5> const char *oem_table_id)\n<9> memcpy(&h->signature, sig, 4);\n<15> memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n<19> if (oem_table_id) {\n<21> strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n<25> memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n<27> memcpy(h->oem_table_id + 4, sig, 4);\n<35> memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n<43> bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
<1> static gint detect_version ( wtap * wth , int * err , gchar * * err_info ) {\n<26> bytes_read = file_read ( buffer , 5 * 4 + payload_length , wth -> fh ) ;\n<35> if ( try_header_size == 24 ) {\n<36> tag_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 ) + 1 ;\n<37> log_length = ( guint32 ) strlen ( buffer + 5 * 4 + 1 + tag_length ) + 1 ;\n<38> if ( payload_length == 1 + tag_length + log_length ) {\n<43> tag_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 ) + 1 ;\n<44> log_length = ( guint32 ) strlen ( buffer + 4 * 4 + 1 + tag_length ) + 1 ;\n<45> if ( payload_length == 1 + tag_length + log_length ) {\n<46> if ( file_seek ( wth -> fh , file_offset + 4 * 4 + 1 + tag_length + log_length , SEEK_SET , err ) == - 1 ) {
<1> static void ipvideo_decode_opcodes ( IpvideoContext * s ) {\n<7> if ( ! s -> is_16bpp ) {\n<8> memcpy ( s -> current_frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n<29> ret = ipvideo_decode_block [ opcode ] ( s ) ;\n<33> ret = ipvideo_decode_block16 [ opcode ] ( s ) ;
<1> matroska_read_close (AVFormatContext *s)\n<5> MatroskaDemuxContext *matroska = s->priv_data;\n<13> av_free(matroska->writing_app);\n<17> av_free(matroska->muxing_app);\n<21> av_free(matroska->index);\n<25> if (matroska->packets != NULL) {\n<27> for (n = 0; n < matroska->num_packets; n++) {\n<35> av_free(matroska->packets);\n<41> for (n = 0; n < matroska->num_tracks; n++) {\n<73> memset(matroska, 0, sizeof(MatroskaDemuxContext));
<1> void ff_af_queue_close(AudioFrameQueue *afq)\n<11> memset(afq, 0, sizeof(*afq));
<1> static void encode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n<23> memset(s->sample_buffer, 0, ring_size * MAX_PLANES *\n<35> sample[p][i]= s->sample_buffer + p*ring_size*(w+6) + ((h+i-y)%ring_size)*(w+6) + 3;\n<97> encode_line(s, w, sample[p], (p + 1) / 2, 9);\n<101> encode_line(s, w, sample[p], (p + 1) / 2, bits + 1);
<1> static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n<35> if (ret < 0) {\n<43> if (strcmp(bochs.magic, HEADER_MAGIC) ||\n<45> strcmp(bochs.type, REDOLOG_TYPE) ||\n<47> strcmp(bochs.subtype, GROWING_TYPE) ||\n<49> ((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n<53> error_setg(errp, "Image not in Bochs format");\n<55> return -EINVAL;\n<61> if (le32_to_cpu(bochs.version) == HEADER_V1) {\n<77> s->catalog_size = le32_to_cpu(bochs.catalog);\n<79> if (s->catalog_size > 0x100000) {
<1> target_ulong do_arm_semihosting(CPUARMState *env)\n<7> CPUState *cs = CPU(cpu);\n<37> nr = env->xregs[0] & 0xffffffffU;\n<43> nr = env->regs[0];\n<51> switch (nr) {\n<63> if (!s) {\n<71> if (arg1 >= 12) {\n<79> if (strcmp(s, ":tt") == 0) {\n<81> int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;\n<83> unlock_user(s, arg0, 0);\n<85> return result_fileno;\n<89> if (use_gdb_syscalls()) {\n<97> ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));\n<101> unlock_user(s, arg0, 0);\n<103> return ret;\n<149> if (!(s = lock_user_string(args)))\n<155> len = strlen(s);\n<159> return arm_gdb_syscall(cpu, arm_semi_cb, "write,2,%x,%x",\n<165> ret = write(STDERR_FILENO, s, len);\n<523> if (cmdline == NULL) {\n<525> cmdline = ""; /* Default to an empty line. */\n<529> output_size = strlen(cmdline) + 1; /* Count terminating 0. */\n<553> if (output_size > input_size) {\n<591> pstrcpy(output_buffer, output_size, cmdline);\n<809> if (is_a64(env)) {\n<819> fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr);\n<821> cpu_dump_state(cs, stderr, fprintf, 0);
<1> static int parse_fmtp(AVFormatContext *s,\n<5> const char *attr, const char *value)\n<15> if (!strcmp(attr, "config")) {\n<17> res = parse_fmtp_config(par, value);\n<21> if (res < 0)\n<29> if (par->codec_id == AV_CODEC_ID_AAC) {\n<35> if (!av_strcasecmp(attr, attr_names[i].str)) {\n<55> return 0;
<1> static int kvm_init(MachineState *ms)\n<27> }, *nc = num_cpus;\n<79> if (s->fd == -1) {\n<81> fprintf(stderr, "Could not access KVM kernel module: %m\n");\n<93> if (ret < KVM_API_VERSION) {\n<101> fprintf(stderr, "kvm version too old\n");\n<109> if (ret > KVM_API_VERSION) {\n<113> fprintf(stderr, "kvm version not supported\n");\n<145> if (nc->num > soft_vcpus_limit) {\n<157> if (nc->num > hard_vcpus_limit) {\n<159> fprintf(stderr, "Number of %s cpus requested (%d) exceeds "\n<171> nc++;\n<177> kvm_type = qemu_opt_get(qemu_get_machine_opts(), "kvm-type");\n<183> } else if (kvm_type) {\n<187> fprintf(stderr, "Invalid argument kvm-type=%s\n", kvm_type);\n<203> if (ret < 0) {\n<205> fprintf(stderr, "ioctl(KVM_CREATE_VM) failed: %d %s\n", -ret,\n<207> strerror(-ret));\n<247> if (!missing_cap) {\n<255> if (missing_cap) {
<4> if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ) return - 1 ;\n<9> memcpy ( sbr -> data [ 1 ] . bs_invf_mode [ 1 ] , sbr -> data [ 1 ] . bs_invf_mode [ 0 ] , sizeof ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] ) ) ;\n<10> memcpy ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] , sbr -> data [ 0 ] . bs_invf_mode [ 0 ] , sizeof ( sbr -> data [ 1 ] . bs_invf_mode [ 0 ] ) ) ;
<1> static int dirac_unpack_prediction_parameters(DiracContext *s)\n<117> if (s->globalmc_flag) {\n<119> memset(s->globalmc, 0, sizeof(s->globalmc));
<1> DeviceState *qdev_create(BusState *bus, const char *name)\n<11> for (t = device_type_list; t; t = t->next) {\n<13> if (strcmp(t->info->name, name) == 0) {\n<23> hw_error("Unknown device '%s'\n", name);\n<55> hw_error("Device '%s' on wrong bus type (%d/%d)", name,
<1> static int get_pci_config_device(QEMUFile *f, void *pv, size_t size)\n<13> assert(size == pci_config_size(s));\n<19> qemu_get_buffer(f, config, size);\n<21> for (i = 0; i < size; ++i) {\n<23> if ((config[i] ^ s->config[i]) & s->cmask[i] & ~s->wmask[i]) {\n<33> memcpy(s->config, config, size);\n<37> pci_update_mappings(s);\n<41> qemu_free(config);
<1> static int mpc7_decode_frame(AVCodecContext * avctx, void *data,\n<11> MPCContext *c = avctx->priv_data;\n<19> Band *bands = c->bands;\n<27> memset(bands, 0, sizeof(*bands) * (c->maxbands + 1));\n<79> if (!c->bits)\n<183> memset(c->Q, 0, sizeof(c->Q));\n<191> idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n<195> ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2);
<1> SRP_user_pwd * SRP_VBASE_get_by_user ( SRP_VBASE * vb , char * username ) {\n<7> if ( vb == NULL ) return NULL ;\n<9> i < sk_SRP_user_pwd_num ( vb -> users_pwd ) ;\n<10> i ++ ) {\n<11> user = sk_SRP_user_pwd_value ( vb -> users_pwd , i ) ;\n<12> if ( strcmp ( user -> id , username ) == 0 ) return user ;\n<14> if ( ( vb -> seed_key == NULL ) || ( vb -> default_g == NULL ) || ( vb -> default_N == NULL ) ) return NULL ;\n<16> SRP_user_pwd_set_gN ( user , vb -> default_g , vb -> default_N ) ;\n<17> if ( ! SRP_user_pwd_set_ids ( user , username , NULL ) ) goto err ;\n<18> if ( RAND_pseudo_bytes ( digv , SHA_DIGEST_LENGTH ) < 0 ) goto err ;\n<19> EVP_MD_CTX_init ( & ctxt ) ;\n<20> EVP_DigestInit_ex ( & ctxt , EVP_sha1 ( ) , NULL ) ;\n<21> EVP_DigestUpdate ( & ctxt , vb -> seed_key , strlen ( vb -> seed_key ) ) ;\n<22> EVP_DigestUpdate ( & ctxt , username , strlen ( username ) ) ;\n<23> EVP_DigestFinal_ex ( & ctxt , digs , NULL ) ;\n<24> EVP_MD_CTX_cleanup ( & ctxt ) ;\n<25> if ( SRP_user_pwd_set_sv_BN ( user , BN_bin2bn ( digs , SHA_DIGEST_LENGTH , NULL ) , BN_bin2bn ( digv , SHA_DIGEST_LENGTH , NULL ) ) ) return user ;\n<26> err : SRP_user_pwd_free ( user ) ;
<1> static int64_t cpu_get_icount_locked(void)\n<15> if (!cpu_can_do_io(cpu)) {\n<17> fprintf(stderr, "Bad clock read\n");
<1> int main ( int argc , char * * argv ) {\n<3> if ( argc != 2 ) {\n<4> fprintf ( stderr , "One argument, the input filename, must be provided.\n" ) ;\n<9> fprintf ( stdout , "Processing %s => %s\n" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n<14> if ( ! ok ) {\n<15> fprintf ( stderr , "Decompression failed\n" ) ;
<1> envlist_unsetenv(envlist_t *envlist, const char *env)\n<11> if ((envlist == NULL) || (env == NULL))\n<19> if (strchr(env, '=') != NULL)\n<21> return (EINVAL);\n<33> envname_len = strlen(env);\n<35> for (entry = envlist->el_entries.lh_first; entry != NULL;\n<39> if (strncmp(entry->ev_var, env, envname_len) == 0)\n<45> if (entry != NULL) {\n<47> LIST_REMOVE(entry, ev_link);\n<49> free((char *)entry->ev_var);\n<51> free(entry);\n<59> return (0);
<1> static int v4l2_set_parameters(AVFormatContext *s1)\n<133> if (v4l2_ioctl(s->fd, VIDIOC_G_PARM, &streamparm) != 0) {\n<135> av_log(s1, AV_LOG_ERROR, "ioctl(VIDIOC_G_PARM): %s\n",\n<137> strerror(errno));\n<139> return AVERROR(errno);
<1> static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n<5> switch ( type ) {\n<11> memcpy ( & d , buffer + * position , 8 ) ;\n<12> value = PyFloat_FromDouble ( d ) ;\n<34> memcpy ( & size , buffer + * position , 4 ) ;\n<35> if ( max < size ) {\n<38> value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ;\n<39> if ( ! value ) {\n<42> if ( strcmp ( buffer + * position + 5 , "$ref" ) == 0 ) {\n<44> PyObject * collection = PyDict_GetItemString ( value , "$ref" ) ;\n<45> PyObject * id = PyDict_GetItemString ( value , "$id" ) ;\n<46> PyObject * database = PyDict_GetItemString ( value , "$db" ) ;\n<47> Py_INCREF ( collection ) ;\n<48> PyDict_DelItemString ( value , "$ref" ) ;\n<49> Py_INCREF ( id ) ;\n<50> PyDict_DelItemString ( value , "$id" ) ;\n<51> if ( database == NULL ) {\n<59> dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ;\n<60> Py_DECREF ( value ) ;\n<61> value = dbref ;\n<62> Py_DECREF ( id ) ;\n<63> Py_DECREF ( collection ) ;\n<64> Py_DECREF ( database ) ;\n<65> if ( ! value ) {\n<69> * position += size ;\n<74> memcpy ( & size , buffer + * position , 4 ) ;\n<75> if ( max < size ) {\n<78> end = * position + size - 1 ;\n<84> while ( * position < end ) {\n<86> int type = ( int ) buffer [ ( * position ) ++ ] ;\n<87> int key_size = strlen ( buffer + * position ) ;\n<88> * position += key_size + 1 ;\n<89> to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ;\n<104> memcpy ( & length , buffer + * position , 4 ) ;\n<105> if ( max < length ) {\n<121> data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ;\n<129> if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) {
<1> void pci_device_hot_add(Monitor *mon, const QDict *qdict, QObject **ret_data)\n<9> const char *type = qdict_get_str(qdict, "type");\n<17> if (!strncmp(pci_addr, "pci_addr=", 9)) {\n<19> pci_addr += 9;\n<33> if (!strcmp(pci_addr, "auto"))\n<35> pci_addr = NULL;\n<39> if (strcmp(type, "nic") == 0)\n<41> dev = qemu_pci_hot_add_nic(mon, pci_addr, opts);\n<43> else if (strcmp(type, "storage") == 0)\n<45> dev = qemu_pci_hot_add_storage(mon, pci_addr, opts);\n<49> monitor_printf(mon, "invalid type: %s\n", type);
<1> static char * pool_strdup ( const char * s ) {\n<2> char * r = pool_alloc ( strlen ( s ) + 1 ) ;\n<3> strcpy ( r , s ) ;
<1> static void sigfd_handler(void *opaque)\n<33> if (len != sizeof(info)) {\n<35> printf("read from sigfd returned %zd: %m\n", len);
<1> static int dirac_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *pkt)\n<23> if (s->all_frames[i].avframe->data[0] && !s->all_frames[i].avframe->reference) {\n<27> memset(s->all_frames[i].interpolated, 0, sizeof(s->all_frames[i].interpolated));
<1> static int nprobe(AVFormatContext *s, uint8_t *enc_header, unsigned size,\n<17> if (!enc_header || !n_val ||\n<27> if (!memcmp(&enc_header[pos], "EKB ", 4))\n<29> pos += 32;\n<39> if (AV_RB32(&enc_header[pos]) != oc->rid)\n<73> av_des_crypt(&av_des, oc->r_val, &enc_header[pos], 2, NULL, 1);\n<77> if (!rprobe(s, enc_header, size, oc->r_val))
<1> static int queue_picture(VideoState *is, AVFrame *src_frame, double pts)\n<129> if (img_convert_ctx == NULL) {\n<131> fprintf(stderr, "Cannot initialize the conversion context\n");
<1> static void send_qmp_error_event(BlockDriverState *bs,\n<15> qapi_event_send_block_io_error(bdrv_get_device_name(bs), optype, action,\n<19> error == ENOSPC, strerror(error),
<1> static uint32_t mb_add_cmdline(MultibootState *s, const char *cmdline)\n<7> char *b = (char *)s->mb_buf + p;\n<11> get_opt_value(b, strlen(cmdline) + 1, cmdline);\n<13> s->offset_cmdlines += strlen(b) + 1;
<1> static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)\n<27> if (rdma->host == NULL) {\n<57> if (ret) {\n<73> if (rdma->host && strcmp("", rdma->host)) {\n<79> ret = rdma_getaddrinfo(rdma->host, port_str, NULL, &res);\n<81> if (ret < 0) {\n<131> ERROR(errp, "migration host and port not specified!");\n<133> ret = -EINVAL;\n<153> rdma_destroy_id(listen_id);\n<157> rdma_destroy_event_channel(rdma->channel);\n<159> rdma->channel = NULL;\n<161> rdma->error_state = ret;\n<163> return ret;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<38> buf += 20 ;\n<40> buf += 3 ;\n<44> avctx -> sample_aspect_ratio . den = read32 ( & buf , endian ) ;\n<87> ptr = p -> data [ 0 ] ;\n<89> if ( source_packet_size * avctx -> width * avctx -> height > buf_end - buf ) {\n<109> case 8 : case 12 : case 16 : if ( source_packet_size == target_packet_size ) {\n<111> x < avctx -> height ;\n<113> memcpy ( ptr , buf , target_packet_size * avctx -> width ) ;\n<114> ptr += stride ;\n<115> buf += source_packet_size * avctx -> width ;\n<122> uint8_t * dst = ptr ;\n<124> y < avctx -> width ;\n<126> memcpy ( dst , buf , target_packet_size ) ;\n<127> dst += target_packet_size ;\n<128> buf += source_packet_size ;
<1> static int compare_litqobj_to_qobj(LiteralQObject *lhs, QObject *rhs)\n<13> switch (lhs->type) {\n<21> return (strcmp(lhs->value.qstr, qstring_get_str(qobject_to_qstring(rhs))) == 0);
<1> static ssize_t virtio_net_receive(VLANClientState *vc, const uint8_t *buf, size_t size)\n<43> struct iovec sg[VIRTQUEUE_MAX_SIZE];\n<55> if (i == 0)\n<59> fprintf(stderr, "virtio-net truncating packet\n");\n<67> if (elem.in_num < 1) {\n<69> fprintf(stderr, "virtio-net receive queue contains no in buffers\n");\n<77> if (!n->mergeable_rx_bufs && elem.in_sg[0].iov_len != hdr_len) {\n<79> fprintf(stderr, "virtio-net header not in first element\n");\n<87> memcpy(&sg, &elem.in_sg[0], sizeof(sg[0]) * elem.in_num);
<1> static int mov_open_dref(AVIOContext **pb, char *src, MOVDref *ref,\n<11> if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n<13> char filename[1024];\n<37> for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n<55> if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n<57> memcpy(filename, src, src_path - src);\n<59> filename[src_path - src] = 0;\n<65> av_strlcat(filename, "../", 1024);\n<69> av_strlcat(filename, ref->path + l + 1, 1024);
<1> static int read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)\n<5> BinkDemuxContext *bink = s->priv_data;\n<19> if (avio_seek(s->pb, vst->index_entries[0].pos, SEEK_SET) < 0)\n<27> memset(bink->audio_pts, 0, sizeof(bink->audio_pts));
<1> static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, enum AVMediaType type)\n<77> buf = get_line(s);\n<79> if (!buf[0] || buf[0] == '#') {\n<87> if (!(arg = strchr(buf, '='))) {\n<89> av_log(NULL, AV_LOG_FATAL, "Invalid line found in the preset file.\n");\n<91> exit_program(1);\n<95> *arg++ = 0;\n<97> av_dict_set(&ost->opts, buf, arg, AV_DICT_DONT_OVERWRITE);\n<127> MATCH_PER_STREAM_OPT(bitstream_filters, str, bsf, oc, st);\n<129> while (bsf) {\n<131> if (next = strchr(bsf, ','))\n<133> *next++ = 0;\n<135> if (!(bsfc = av_bitstream_filter_init(bsf))) {\n<155> bsf       = next;\n<165> uint32_t tag = strtol(codec_tag, &next, 0);
<1> static void dump_stream_format(AVFormatContext *ic, int i, int index, int is_output)\n<9> AVStream *st = ic->streams[i];\n<25> if (strlen(st->language) > 0)\n<27> av_log(NULL, AV_LOG_INFO, "(%s)", st->language);
<1> static int qemu_rdma_write_one(QEMUFile *f, RDMAContext *rdma,\n<273> fprintf(stderr, "cannot get lkey!\n");\n<315> fprintf(stderr, "cannot get lkey!\n");\n<333> if (qemu_rdma_register_and_get_keys(rdma, block, (uint8_t *)sge.addr,\n<339> fprintf(stderr, "cannot get lkey!\n");\n<409> if (ret < 0) {\n<411> fprintf(stderr, "rdma migration: failed to make "\n<415> return ret;
<1> static void test_butterflies_float(const float *src0, const float *src1)\n<23> memcpy(cdst,  src0, LEN * sizeof(*src0));\n<25> memcpy(cdst1, src1, LEN * sizeof(*src1));\n<27> memcpy(odst,  src0, LEN * sizeof(*src0));\n<29> memcpy(odst1, src1, LEN * sizeof(*src1));\n<33> call_ref(cdst, cdst1, LEN);\n<35> call_new(odst, odst1, LEN);\n<37> for (i = 0; i < LEN; i++) {\n<39> if (!float_near_abs_eps(cdst[i], odst[i], FLT_EPSILON)) {\n<41> fprintf(stderr, "%d: %- .12f - %- .12f = % .12g\n",\n<43> i, cdst[i], odst[i], cdst[i] - odst[i]);\n<53> memcpy(odst,  src0, LEN * sizeof(*src0));\n<55> memcpy(odst1, src1, LEN * sizeof(*src1));\n<57> bench_new(odst, odst1, LEN);
<1> static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)\n<13> memset(state, 128, sizeof(state));\n<19> unsigned len = get_symbol(c, state, 0) + 1;
<1> static void save_native_fp_fsave(CPUState *env)\n<33> for(i = 0;i < 8; i++) {\n<35> memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);
<1> static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n<15> uint8_t pal[768], transp[3];\n<25> uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n<43> hdr = *src++;\n<47> if (sub_type == 0) {\n<51> memcpy(transp, src, 3);\n<53> src += 3;\n<55> for (j = 0; j < height; j++, dst += c->framebuf_stride)\n<57> for (i = 0; i < width; i++)\n<59> memcpy(dst + i * 3, transp, 3);\n<63> } else if (sub_type == 1) {\n<73> if (sub_type != 2) {\n<75> memcpy(transp, src, 3);\n<77> src += 3;\n<81> npal = *src++ + 1;\n<83> memcpy(pal, src, npal * 3); src += npal * 3;\n<87> for (i = 0; i < npal; i++) {\n<89> if (!memcmp(pal + i * 3, transp, 3)) {\n<91> tidx = i;\n<129> kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n<149> for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n<181> memset(c->jpeg_tile, 0, c->tile_stride * height);\n<183> jpg_decode_data(&c->jc, width, height, src, src_end - src,\n<191> kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,
<1> static void ioreq_unmap(struct ioreq *ioreq)\n<25> if (xc_gnttab_munmap(gnt, ioreq->pages, ioreq->v.niov) != 0) {\n<27> xen_be_printf(&ioreq->blkdev->xendev, 0, "xc_gnttab_munmap failed: %s\n",\n<29> strerror(errno));\n<47> if (xc_gnttab_munmap(gnt, ioreq->page[i], 1) != 0) {\n<49> xen_be_printf(&ioreq->blkdev->xendev, 0, "xc_gnttab_munmap failed: %s\n",\n<51> strerror(errno));
<1> static void load_linux(FWCfgState *fw_cfg,\n<7> const char *kernel_cmdline,\n<19> uint8_t header[8192], *setup, *kernel, *initrd_data;\n<31> cmdline_size = (strlen(kernel_cmdline)+16) & ~15;\n<37> f = fopen(kernel_filename, "rb");\n<43> MIN(ARRAY_SIZE(header), kernel_size)) {\n<45> fprintf(stderr, "qemu: could not load kernel '%s': %s\n",\n<47> kernel_filename, strerror(errno));\n<63> if (ldl_p(header+0x202) == 0x53726448) {\n<73> if (load_multiboot(fw_cfg, f, kernel_filename, initrd_filename,\n<87> if (protocol < 0x200 || !(header[0x211] & 0x01)) {\n<93> cmdline_addr = 0x9a000 - cmdline_size;\n<103> cmdline_addr = 0x9a000 - cmdline_size;\n<163> fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, strlen(kernel_cmdline)+1);\n<165> fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, kernel_cmdline);\n<185> vmode = strstr(kernel_cmdline, "vga=");\n<193> vmode += 4;\n<229> header[0x210] = 0xB0;\n<237> header[0x211] |= 0x80;	/* CAN_USE_HEAP */\n<249> if (protocol < 0x200) {\n<251> fprintf(stderr, "qemu: linux kernel too old to load a ram disk\n");\n<259> initrd_size = get_image_size(initrd_filename);\n<261> if (initrd_size < 0) {\n<263> fprintf(stderr, "qemu: error reading initrd %s: %s\n",\n<265> initrd_filename, strerror(errno));\n<279> load_image(initrd_filename, initrd_data);\n<321> if (fread(setup, 1, setup_size, f) != setup_size) {\n<323> fprintf(stderr, "fread() failed\n");\n<329> if (fread(kernel, 1, kernel_size, f) != kernel_size) {\n<331> fprintf(stderr, "fread() failed\n");\n<339> memcpy(setup, header, MIN(sizeof(header), setup_size));\n<355> fw_cfg_add_bytes(fw_cfg, FW_CFG_SETUP_DATA, setup, setup_size);
<1> static unsigned int dec_subs_r(DisasContext *dc)\n<7> int size = memsize_z(dc);\n<11> memsize_char(size),\n<17> cris_cc_mask(dc, CC_MASK_NZVC);
<1> static int net_tap_init(VLANState *vlan, const char *model,\n<27> if (fd < 0)\n<33> if (!setup_script || !strcmp(setup_script, "no"))\n<35> setup_script = "";\n<37> if (setup_script[0] != '\0') {\n<39> if (launch_script(setup_script, ifname, fd))\n<47> if (!s)\n<51> snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n<57> if (down_script && strcmp(down_script, "no"))\n<59> snprintf(s->down_script, sizeof(s->down_script), "%s", down_script);
<1> static void pc_init1(ram_addr_t ram_size,\n<121> for(i = 0; i < nb_nics; i++) {\n<123> NICInfo *nd = &nd_table[i];\n<127> if (!pci_enabled || (nd->model && strcmp(nd->model, "ne2k_isa") == 0))\n<129> pc_init_ne2k_isa(nd);\n<133> pci_nic_init_nofail(nd, "e1000", NULL);\n<139> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<141> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static void l2cap_frame_in(struct l2cap_instance_s *l2cap,\n<13> if (unlikely(cid >= L2CAP_CID_MAX || !l2cap->cid[cid])) {\n<15> fprintf(stderr, "%s: frame addressed to a non-existent L2CAP "
<1> void ff_print_debug_info(MpegEncContext *s, AVFrame *pict)\n<187> for (i = 0; i < 3; i++) {\n<193> s->visualization_buffer[i]= av_realloc(s->visualization_buffer[i], size);\n<195> memcpy(s->visualization_buffer[i], pict->data[i], size);\n<197> pict->data[i] = s->visualization_buffer[i];
<1> void process_incoming_migration(QEMUFile *f)\n<5> if (qemu_loadvm_state(f) < 0) {\n<7> fprintf(stderr, "load of migration failed\n");
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<59> if ( keyframe && c -> pic . data [ 0 ] ) {\n<70> if ( init_frame ) {\n<71> memset ( c -> pic . data [ 0 ] , 0 , avctx -> height * c -> pic . linesize [ 0 ] ) ;\n<72> memset ( c -> pic . data [ 1 ] , 0x80 , avctx -> height * c -> pic . linesize [ 1 ] / 2 ) ;\n<73> memset ( c -> pic . data [ 2 ] , 0x80 , avctx -> height * c -> pic . linesize [ 2 ] / 2 ) ;\n<77> switch ( comptype ) {\n<89> case NUV_BLACK : memset ( c -> pic . data [ 0 ] , 0 , c -> width * c -> height ) ;\n<90> memset ( c -> pic . data [ 1 ] , 128 , c -> width * c -> height / 4 ) ;\n<91> memset ( c -> pic . data [ 2 ] , 128 , c -> width * c -> height / 4 ) ;
<1> int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n<11> if (!sigset)\n<17> sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n<21> sigmask->len = 8;\n<23> memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n<25> r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n<27> free(sigmask);
<1> static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,\n<3> uint64_t value, unsigned size)\n<15> switch (addr) {\n<199> printf("sm501 disp ctrl : not implemented register write."
<1> int load_multiboot(void *fw_cfg,\n<5> const char *kernel_filename,\n<9> const char *kernel_cmdline,\n<65> if (!is_multiboot)\n<73> memset(bootinfo, 0, sizeof(bootinfo));\n<75> memset(&mbs, 0, sizeof(mbs));\n<79> if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n<81> fprintf(stderr, "qemu: multiboot knows VBE. we don't.\n");\n<85> if (!(flags & 0x00010000)) { /* MULTIBOOT_HEADER_HAS_ADDR */\n<97> if (((struct elf64_hdr*)header)->e_machine == EM_X86_64) {\n<99> fprintf(stderr, "Cannot load x86-64 image, give a 32bit one.\n");\n<107> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<111> if (kernel_size < 0) {\n<113> fprintf(stderr, "Error while loading elf kernel\n");\n<129> if (rom_copy(mbs.mb_buf, mh_load_addr, mb_kernel_size) != mb_kernel_size) {\n<131> fprintf(stderr, "Error while fetching elf kernel from rom\n");\n<209> if (fread(mbs.mb_buf, 1, mb_load_size, f) != mb_load_size) {\n<211> fprintf(stderr, "fread() failed\n");\n<217> memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n<229> mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_kernel_size);\n<237> mbs.mb_buf_size += strlen(kernel_filename) + 1;\n<239> mbs.mb_buf_size += strlen(kernel_cmdline) + 1;\n<241> if (initrd_filename) {\n<243> const char *r = initrd_filename;\n<245> mbs.mb_buf_size += strlen(r) + 1;\n<249> while (*(r = get_opt_value(NULL, 0, r))) {\n<257> mbs.mb_buf_size += MB_MOD_SIZE * mbs.mb_mods_avail;\n<263> mbs.mb_buf_size = TARGET_PAGE_ALIGN(mbs.mb_buf_size);\n<275> if (initrd_filename) {\n<305> target_phys_addr_t c = mb_add_cmdline(&mbs, initrd_filename);\n<307> if ((next_space = strchr(initrd_filename, ' ')))\n<309> *next_space = '\0';\n<311> mb_debug("multiboot loading module: %s\n", initrd_filename);\n<313> mb_mod_length = get_image_size(initrd_filename);\n<315> if (mb_mod_length < 0) {\n<317> fprintf(stderr, "Failed to open file '%s'\n", initrd_filename);\n<325> mbs.mb_buf_size = TARGET_PAGE_ALIGN(mb_mod_length + mbs.mb_buf_size);\n<327> mbs.mb_buf = g_realloc(mbs.mb_buf, mbs.mb_buf_size);\n<331> load_image(initrd_filename, (unsigned char *)mbs.mb_buf + offs);\n<355> char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];\n<361> stl_p(bootinfo + MBI_CMDLINE, mb_add_cmdline(&mbs, kcmdline));\n<365> stl_p(bootinfo + MBI_MODS_ADDR,  mbs.mb_buf_phys + mbs.offset_mbinfo);\n<367> stl_p(bootinfo + MBI_MODS_COUNT, mbs.mb_mods_count); /* mods_count */\n<373> stl_p(bootinfo + MBI_FLAGS, MULTIBOOT_FLAGS_MEMORY\n<383> stl_p(bootinfo + MBI_MEM_LOWER,   640);\n<385> stl_p(bootinfo + MBI_MEM_UPPER,   (ram_size / 1024) - 1024);\n<387> stl_p(bootinfo + MBI_BOOT_DEVICE, 0x8000ffff); /* XXX: use the -boot switch? */\n<389> stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n<399> mb_debug("           mb_mods_count = %d\n", mbs.mb_mods_count);\n<405> mb_bootinfo_data = g_malloc(sizeof(bootinfo));\n<407> memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo));\n<417> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n<429> fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,
<1> milkymist_init(QEMUMachineInitArgs *args)\n<9> const char *kernel_cmdline = args->kernel_cmdline;\n<123> bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<141> if (!kernel_filename && !dinfo && !bios_filename) {\n<143> fprintf(stderr, "qemu: could not load Milkymist One bios '%s'\n",\n<193> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<203> kernel_size = load_image_targphys(kernel_filename, sdram_base,\n<213> if (kernel_size < 0) {\n<215> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<227> if (kernel_cmdline && strlen(kernel_cmdline)) {\n<229> pstrcpy_targphys("cmdline", cmdline_base, TARGET_PAGE_SIZE,\n<233> reset_info->cmdline_base = (uint32_t)cmdline_base;
<1> static ssize_t local_readlink(FsContext *ctx, const char *path,\n<3> char *buf, size_t bufsz)\n<7> return readlink(rpath(ctx, path), buf, bufsz);
<1> static int32_t u_printf_string_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n<6> const char * arg = ( const char * ) ( args [ 0 ] . ptrValue ) ;\n<7> if ( arg ) {\n<8> argSize = ( int32_t ) strlen ( arg ) + 1 ;\n<9> if ( argSize >= MAX_UCHAR_BUFFER_SIZE ( buffer ) ) {\n<10> s = ufmt_defaultCPToUnicode ( arg , argSize , ( UChar * ) uprv_malloc ( MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) , MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) ;\n<16> s = ufmt_defaultCPToUnicode ( arg , argSize , buffer , UPRV_LENGTHOF ( buffer ) ) ;
<1> static int ftp_passive_mode_epsv(FTPContext *s)\n<39> if (!start || !end)\n<47> if (strlen(start) < 5)\n<51> if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)\n<55> start += 3;\n<75> av_free(res);\n<77> s->server_data_port = -1;\n<79> return AVERROR(ENOSYS);
<1> int load_uimage(const char *filename, target_phys_addr_t *ep,\n<37> bswap_uboot_header(hdr);\n<49> if (hdr->ih_type != IH_TYPE_KERNEL) {\n<51> fprintf(stderr, "Can only load u-boot image type \"kernel\"\n");\n<59> switch (hdr->ih_comp) {\n<103> if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n<105> fprintf(stderr, "Error reading file\n");\n<135> if (bytes < 0) {\n<137> fprintf(stderr, "Unable to decompress gzipped image!\n");
<1> static void mxf_write_partition(AVFormatContext *s, int bodysid,\n<5> const uint8_t *key, int write_metadata)\n<37> if (!memcmp(key, body_partition_key, 16)) {\n<39> mxf->body_partition_offset =\n<41> av_realloc(mxf->body_partition_offset,\n<43> (mxf->body_partitions_count+1)*\n<45> sizeof(*mxf->body_partition_offset));\n<47> mxf->body_partition_offset[mxf->body_partitions_count++] = partition_offset;\n<55> put_buffer(pb, key, 16);\n<77> if (!memcmp(key, body_partition_key, 16) && mxf->body_partitions_count > 1)\n<79> put_be64(pb, mxf->body_partition_offset[mxf->body_partitions_count-2]); // PreviousPartition\n<81> else if (!memcmp(key, footer_partition_key, 16))\n<83> put_be64(pb, mxf->body_partition_offset[mxf->body_partitions_count-1]); // PreviousPartition\n<87> put_be64(pb, 0);
<1> static void pc_init1(MachineState *machine,\n<91> if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n<95> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> static int read_f(int argc, char **argv)\n<23> int pattern = 0, pattern_offset = 0, pattern_count = 0;\n<27> while ((c = getopt(argc, argv, "bCl:pP:qs:v")) != EOF) {\n<47> pattern_count = cvtnum(optarg);\n<49> if (pattern_count < 0) {\n<51> printf("non-numeric length argument -- %s\n", optarg);\n<71> if (pattern < 0) {\n<89> pattern_offset = cvtnum(optarg);\n<91> if (pattern_offset < 0) {\n<93> printf("non-numeric length argument -- %s\n", optarg);\n<125> if (bflag && pflag) {\n<127> printf("-b and -p cannot be specified at the same time\n");\n<135> offset = cvtnum(argv[optind]);\n<137> if (offset < 0) {\n<139> printf("non-numeric length argument -- %s\n", argv[optind]);\n<149> count = cvtnum(argv[optind]);\n<151> if (count < 0) {\n<153> printf("non-numeric length argument -- %s\n", argv[optind]);\n<171> pattern_count = count - pattern_offset;\n<177> if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n<179> printf("pattern verification range exceeds end of read data\n");\n<199> if (count & 0x1ff) {\n<221> cnt = do_pread(buf, offset, count, &total);\n<225> cnt = do_load_vmstate(buf, offset, count, &total);\n<229> cnt = do_read(buf, offset, count, &total);\n<237> if (cnt < 0) {\n<239> printf("read failed: %s\n", strerror(-cnt));\n<247> if (Pflag) {\n<249> void *cmp_buf = malloc(pattern_count);\n<251> memset(cmp_buf, pattern, pattern_count);\n<253> if (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n<263> free(cmp_buf);
<1> static AVStream *new_pes_av_stream(PESContext *pes, uint32_t prog_reg_desc, uint32_t code)\n<5> AVStream *st = av_new_stream(pes->stream, pes->pid);\n<25> pes->st = st;\n<29> dprintf(pes->stream, "stream_type=%x pid=%x prog_reg_desc=%.4s\n",\n<47> if (pes->stream_type == 0x83) {\n<59> if (!sub_pes)\n<63> memcpy(sub_pes, pes, sizeof(*sub_pes));\n<67> sub_st = av_new_stream(pes->stream, pes->pid);\n<71> av_free(sub_pes);\n<81> sub_st->priv_data = sub_pes;\n<97> mpegts_find_stream_type(st, pes->stream_type, MISC_types);
<1> void usb_test_hotplug(const char *hcd_id, const int port,\n<63> g_assert(!strcmp(qdict_get_str(response, "event"), "DEVICE_DELETED"));
<1> static void fill_prstatus(struct target_elf_prstatus *prstatus,\n<7> (void) memset(prstatus, 0, sizeof (*prstatus));
<1> static void check_rgb2yuv(void)\n<97> call_ref(dst0, (ptrdiff_t[3]) { y_dst_stride, uv_dst_stride, uv_dst_stride },\n<101> call_new(dst1, (ptrdiff_t[3]) { y_dst_stride, uv_dst_stride, uv_dst_stride },\n<105> if (memcmp(dst0[0], dst1[0], H * y_dst_stride) ||\n<107> memcmp(dst0[1], dst1[1], H * uv_dst_stride >> ss_h) ||\n<109> memcmp(dst0[2], dst1[2], H * uv_dst_stride >> ss_h)) {\n<111> fail();
<1> static int sd_snapshot_goto(BlockDriverState *bs, const char *snapshot_id)\n<5> BDRVSheepdogState *s = bs->opaque;\n<21> old_s = g_malloc(sizeof(BDRVSheepdogState));\n<25> memcpy(old_s, s, sizeof(BDRVSheepdogState));\n<29> pstrcpy(vdi, sizeof(vdi), s->name);\n<41> pstrcpy(tag, sizeof(tag), s->name);\n<47> ret = find_vdi_name(s, vdi, snapid, tag, &vid, 1);\n<49> if (ret) {\n<59> fd = connect_to_sdog(s->addr, s->port);\n<61> if (fd < 0) {\n<75> ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,\n<85> if (ret) {\n<93> memcpy(&s->inode, buf, sizeof(s->inode));\n<97> if (!s->inode.vm_state_size) {\n<113> g_free(buf);\n<115> g_free(old_s);\n<125> memcpy(s, old_s, sizeof(BDRVSheepdogState));\n<127> g_free(buf);\n<129> g_free(old_s);
<1> static void parse_numa_node(MachineState *ms, NumaNodeOptions *node,\n<115> if (node->has_mem) {\n<119> const char *mem_str = qemu_opt_get(opts, "mem");\n<123> if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n<125> mem_size <<= 20;
<1> static int vdi_co_write(BlockDriverState *bs,\n<3> int64_t sector_num, const uint8_t *buf, int nb_sectors)\n<57> if (!VDI_IS_ALLOCATED(bmap_entry)) {\n<73> if (block == NULL) {\n<75> block = g_malloc(s->block_size);\n<85> memset(block, 0, sector_in_block * SECTOR_SIZE);\n<87> memcpy(block + sector_in_block * SECTOR_SIZE,\n<89> buf, n_sectors * SECTOR_SIZE);\n<91> memset(block + (sector_in_block + n_sectors) * SECTOR_SIZE, 0,\n<93> (s->block_sectors - n_sectors - sector_in_block) * SECTOR_SIZE);\n<95> ret = bdrv_write(bs->file, offset, block, s->block_sectors);\n<115> buf += n_sectors * SECTOR_SIZE;
<1> int kvm_arch_init_vcpu(CPUState *env)\n<19> uint32_t signature[3];\n<57> memcpy(signature, "KVMKVMKVM\0\0\0", 12);\n<59> c = &cpuid_data.entries[cpuid_i++];\n<61> memset(c, 0, sizeof(*c));\n<63> c->function = KVM_CPUID_SIGNATURE;\n<65> c->eax = 0;\n<67> c->ebx = signature[0];\n<69> c->ecx = signature[1];\n<71> c->edx = signature[2];\n<75> c = &cpuid_data.entries[cpuid_i++];\n<77> memset(c, 0, sizeof(*c));\n<87> has_msr_async_pf_en = c->eax & (1 << KVM_FEATURE_ASYNC_PF);\n<265> if (ret < 0) {\n<267> fprintf(stderr, "kvm_get_mce_cap_supported: %s", strerror(-ret));\n<287> if (ret < 0) {\n<289> fprintf(stderr, "KVM_X86_SETUP_MCE: %s", strerror(-ret));
<13> if (!build_state || build_state->patched) {\n<35> if (build_state->rsdp) {\n<37> memcpy(build_state->rsdp, tables.rsdp->data, acpi_data_len(tables.rsdp));
<1> static int eightsvx_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<24> if ( ! ( esc -> data [ 0 ] = av_malloc ( chan_size ) ) ) return AVERROR ( ENOMEM ) ;\n<25> if ( avctx -> channels == 2 ) {\n<26> if ( ! ( esc -> data [ 1 ] = av_malloc ( chan_size ) ) ) {\n<31> memcpy ( esc -> data [ 0 ] , & avpkt -> data [ hdr_size ] , chan_size ) ;\n<32> if ( avctx -> channels == 2 ) memcpy ( esc -> data [ 1 ] , & avpkt -> data [ 2 * hdr_size + chan_size ] , chan_size ) ;\n<34> if ( ! esc -> data [ 0 ] ) {
<1> static int asf_read_stream_properties(AVFormatContext *s, int64_t size)\n<51> if (!asf_st)\n<257> avio_read(pb, st->codec->extradata, st->codec->extradata_size);\n<269> if (st->codec->extradata_size && (st->codec->bits_per_coded_sample <= 8)) {\n<283> FFMIN(st->codec->extradata_size, AVPALETTE_SIZE));\n<307> av_freep(&st->codec->extradata);
<1> int ff_eac3_parse_header(AC3DecodeContext *s)\n<357> if (!s->block_switch_syntax)\n<359> memset(s->block_switch, 0, sizeof(s->block_switch));\n<411> if (s->channel_mode > 1) {\n<433> memset(s->cpl_in_use, 0, sizeof(s->cpl_in_use));\n<499> if (parse_aht_info) {\n<535> memset(s->channel_uses_aht, 0, sizeof(s->channel_uses_aht));
<1> static unsigned int dec_move_pm(DisasContext *dc)\n<15> DIS(fprintf (logfile, "move.%c $p%u, [$r%u%s\n",\n<17> memsize_char(memsize),\n<25> if (dc->op2 == PR_CCS)\n<27> cris_evaluate_flags(dc);\n<33> cris_flush_cc_state(dc);\n<35> gen_store(dc, cpu_R[dc->op1], t0, memsize);\n<41> cris_cc_mask(dc, 0);
<1> static int get_device_type(SCSIDiskState *s)\n<19> memset(cmd, 0, sizeof(cmd));\n<21> memset(buf, 0, sizeof(buf));\n<29> memset(&io_header, 0, sizeof(io_header));\n<39> io_header.cmdp = cmd;\n<51> ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n<53> if (ret < 0 || io_header.driver_status || io_header.host_status) {
<1> static int local_set_mapped_file_attrat(int dirfd, const char *name,\n<11> char buf[ATTR_MAX];\n<41> if (!fp) {\n<57> memset(buf, 0, ATTR_MAX);\n<59> while (fgets(buf, ATTR_MAX, fp)) {\n<61> if (!strncmp(buf, "virtfs.uid", 10)) {\n<65> } else if (!strncmp(buf, "virtfs.gid", 10)) {\n<69> } else if (!strncmp(buf, "virtfs.mode", 11)) {\n<73> } else if (!strncmp(buf, "virtfs.rdev", 11)) {\n<79> memset(buf, 0, ATTR_MAX);\n<83> fclose(fp);\n<93> if (!fp) {\n<127> if (uid != -1) {\n<129> fprintf(fp, "virtfs.uid=%d\n", uid);\n<133> if (gid != -1) {\n<135> fprintf(fp, "virtfs.gid=%d\n", gid);\n<139> if (mode != -1) {\n<141> fprintf(fp, "virtfs.mode=%d\n", mode);\n<145> if (rdev != -1) {\n<147> fprintf(fp, "virtfs.rdev=%d\n", rdev);\n<151> fclose(fp);
<1> void hmp_change(Monitor *mon, const QDict *qdict)\n<5> const char *device = qdict_get_str(qdict, "device");\n<7> const char *target = qdict_get_str(qdict, "target");\n<15> if (strcmp(device, "vnc") == 0 &&\n<17> (strcmp(target, "passwd") == 0 ||\n<19> strcmp(target, "password") == 0)) {\n<21> if (!arg) {\n<33> qmp_change(device, target, !!arg, arg, &err);\n<35> if (error_is_type(err, QERR_DEVICE_ENCRYPTED)) {
<1> static inline void do_imdct(AC3DecodeContext *s, int channels)\n<11> if (s->block_switch[ch]) {\n<23> s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, s->add_bias, 128);\n<35> s->dsp.vector_fmul_window(s->output[ch-1], s->delay[ch-1], s->tmp_output, s->window, s->add_bias, 128);\n<37> memcpy(s->delay[ch-1], s->tmp_output+128, 128*sizeof(float));
<1> static void rtsp_send_cmd(AVFormatContext *s,\n<3> const char *cmd, RTSPHeader *reply,\n<9> RTSPState *rt = s->priv_data;\n<23> memset(reply, 0, sizeof(RTSPHeader));\n<29> pstrcpy(buf, sizeof(buf), cmd);\n<35> if (rt->session_id[0] != '\0' && !strstr(cmd, "\nIf-Match:")) {\n<37> snprintf(buf1, sizeof(buf1), "Session: %s\r\n", rt->session_id);\n<39> pstrcat(buf, sizeof(buf), buf1);\n<43> pstrcat(buf, sizeof(buf), "\r\n");\n<51> url_write(rt->rtsp_hd, buf, strlen(buf));\n<63> q = buf;\n<67> if (url_read(rt->rtsp_hd, &ch, 1) == 0)\n<77> if ((q - buf) < sizeof(buf) - 1)\n<95> if (buf[0] == '\0')\n<113> rtsp_parse_line(reply, p);\n<129> pstrcpy(rt->session_id, sizeof(rt->session_id), reply->session_id);\n<133> content_length = reply->content_length;
<4> CinVideoContext * cin = avctx -> priv_data ;\n<17> cin -> palette [ i ] = bytestream_get_le24 ( & buf ) ;\n<25> cin -> palette [ buf [ 0 ] ] = AV_RL24 ( buf + 1 ) ;\n<31> case 9 : cin_decode_rle ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<34> cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<37> cin_decode_rle ( cin -> bitmap_table [ CIN_INT_BMP ] , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<41> cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<43> case 37 : cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<45> case 38 : res = cin_decode_lzss ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<50> cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<54> if ( avctx -> reget_buffer ( avctx , & cin -> frame ) ) {\n<58> memcpy ( cin -> frame . data [ 1 ] , cin -> palette , sizeof ( cin -> palette ) ) ;\n<61> y < cin -> avctx -> height ;\n<62> ++ y ) memcpy ( cin -> frame . data [ 0 ] + ( cin -> avctx -> height - 1 - y ) * cin -> frame . linesize [ 0 ] , cin -> bitmap_table [ CIN_CUR_BMP ] + y * cin -> avctx -> width , cin -> avctx -> width ) ;
<1> void bios_linker_loader_alloc(GArray *linker,\n<3> const char *file,\n<15> memset(&entry, 0, sizeof entry);\n<17> strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n<33> g_array_prepend_val(linker, entry);
<1> static V4L2Buffer* v4l2_dequeue_v4l2buf(V4L2Context *ctx, int timeout)\n<7> struct v4l2_buffer buf = { 0 };\n<107> if (!V4L2_TYPE_IS_OUTPUT(ctx->type)) {\n<111> if (pfd.revents & (POLLIN | POLLRDNORM))\n<123> if (pfd.revents & (POLLOUT | POLLWRNORM))\n<133> memset(&buf, 0, sizeof(buf));\n<139> if (V4L2_TYPE_IS_MULTIPLANAR(ctx->type)) {\n<141> memset(planes, 0, sizeof(planes));\n<145> buf.m.planes = planes;\n<151> ret = ioctl(ctx_to_m2mctx(ctx)->fd, VIDIOC_DQBUF, &buf);\n<169> avbuf = &ctx->buffers[buf.index];\n<173> avbuf->buf = buf;\n<175> if (V4L2_TYPE_IS_MULTIPLANAR(ctx->type)) {\n<177> memcpy(avbuf->planes, planes, sizeof(planes));\n<179> avbuf->buf.m.planes = avbuf->planes;\n<189> return avbuf;
<1> static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){\n<35> occ[j]=1.0;\n<37> for(k=0; k<256; k++){\n<39> double newocc[256]={0};\n<65> newocc[    one_state[    m]] += occ[m]*   p ;\n<67> newocc[256-one_state[256-m]] += occ[m]*(1-p);\n<73> memcpy(occ, newocc, sizeof(occ));
<1> static int idcin_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<9> if ( ff_get_buffer ( avctx , & s -> frame ) ) {\n<13> idcin_decode_vlcs ( s ) ;\n<14> if ( pal ) {\n<16> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<18> memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;
<1> void *qemu_mallocz(size_t size)\n<7> ptr = qemu_malloc(size);\n<9> if (!ptr)\n<13> memset(ptr, 0, size);\n<15> return ptr;
<1> static int local_parse_opts(QemuOpts *opts, struct FsDriverEntry *fse)\n<11> if (!sec_model) {\n<13> fprintf(stderr, "security model not specified, "\n<25> if (!strcmp(sec_model, "passthrough")) {\n<27> fse->export_flags |= V9FS_SM_PASSTHROUGH;\n<29> } else if (!strcmp(sec_model, "mapped")) {\n<31> fse->export_flags |= V9FS_SM_MAPPED;\n<33> } else if (!strcmp(sec_model, "none")) {\n<35> fse->export_flags |= V9FS_SM_NONE;\n<39> fprintf(stderr, "Invalid security model %s specified, valid options are"\n<43> return -1;\n<49> if (!path) {\n<51> fprintf(stderr, "fsdev: No path specified.\n");
<1602> if ( no_of_state_create != 0 ) {\n<1603> memset ( sha1_digest_buf , 0 , STATE_BUFFER_SIZE ) ;
<1> static int64_t http_seek(URLContext *h, int64_t off, int whence)\n<5> HTTPContext *s = h->priv_data;\n<11> uint8_t old_buf[BUFFER_SIZE];\n<27> else if ((s->filesize == -1 && whence == SEEK_END) || h->is_streamed)\n<35> old_buf_size = s->buf_end - s->buf_ptr;\n<37> memcpy(old_buf, s->buf_ptr, old_buf_size);\n<57> if (http_open_cnx(h, &options) < 0) {\n<61> memcpy(s->buffer, old_buf, old_buf_size);\n<63> s->buf_ptr = s->buffer;\n<65> s->buf_end = s->buffer + old_buf_size;
<1> abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n<2067> p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n<2069> if (!p || !p2)\n<2075> if (strncmp((const char *)p, "/proc/self/exe", 14) == 0) {\n<2079> temp = realpath(exec_path,real);\n<2081> ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n<2083> snprintf((char *)p2, arg3, "%s", real);\n<2089> ret = get_errno(readlink(path(p), p2, arg3));\n<2093> unlock_user(p2, arg2, ret);\n<2811> if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n<2815> memset(target_st, 0, sizeof(*target_st));\n<2817> __put_user(st.st_dev, &target_st->st_dev);\n<2819> __put_user(st.st_ino, &target_st->st_ino);\n<2821> __put_user(st.st_mode, &target_st->st_mode);\n<2823> __put_user(st.st_uid, &target_st->st_uid);\n<2825> __put_user(st.st_gid, &target_st->st_gid);\n<2827> __put_user(st.st_nlink, &target_st->st_nlink);\n<2829> __put_user(st.st_rdev, &target_st->st_rdev);\n<2831> __put_user(st.st_size, &target_st->st_size);\n<2833> __put_user(st.st_blksize, &target_st->st_blksize);\n<2835> __put_user(st.st_blocks, &target_st->st_blocks);\n<2837> __put_user(st.st_atime, &target_st->target_st_atime);\n<2839> __put_user(st.st_mtime, &target_st->target_st_mtime);\n<2841> __put_user(st.st_ctime, &target_st->target_st_ctime);\n<2843> unlock_user_struct(target_st, arg2, 1);
<1> static void csrhci_in_packet(struct csrhci_s *s, uint8_t *pkt)\n<11> switch (*pkt ++) {\n<73> if (s->in_hdr != sizeof(csrhci_neg_packet) ||\n<75> memcmp(pkt - 1, csrhci_neg_packet, s->in_hdr)) {\n<77> fprintf(stderr, "%s: got a bad NEG packet\n", __func__);\n<83> pkt += 2;\n<87> rpkt = csrhci_out_packet_csr(s, H4_NEG_PKT, 10);\n<91> *rpkt ++ = 0x20;	/* Operational settings negotiation Ok */\n<93> memcpy(rpkt, pkt, 7); rpkt += 7;\n<105> if (s->in_hdr != 4 || pkt[1] != 0x55 || pkt[2] != 0x00) {\n<107> fprintf(stderr, "%s: got a bad ALIVE packet\n", __func__);\n<133> fprintf(stderr, "%s: got a bad packet\n", __func__);\n<141> csrhci_fifo_wake(s);
<1> static int process_tns_coeffs(TemporalNoiseShaping *tns, float *tns_coefs_raw,\n<11> float *lpc = tns->coef[w][filt];\n<17> float temp[TNS_MAX_ORDER] = {0.0f}, out[TNS_MAX_ORDER] = {0.0f};\n<27> lpc[i] = 2*sin(idx[i]/((idx[i] >= 0) ? iqfac_p : iqfac_m));\n<39> if (lpc[i] != 0.0 ) {\n<51> if (!order)\n<59> out[0] = 1.0f;\n<65> temp[j] = out[j] + lpc[i]*out[i-j];\n<71> out[j] = temp[j];\n<75> out[i] = lpc[i-1];\n<79> memcpy(lpc, out, TNS_MAX_ORDER*sizeof(float));
<1> static int vmdk_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<47> if (bs->backing_hd) {\n<61> memset(buf, 0, 512 * n);\n<85> buf += n * 512;
<1> static void help(int exitcode)
<1> static int ftp_auth(FTPContext *s, char *auth)\n<21> if (user) {\n<23> snprintf(buf, sizeof(buf), "USER %s\r\n", user);\n<25> if ((err = ffurl_write(s->conn_control, buf, strlen(buf))) < 0)\n<27> return err;\n<29> ftp_status(s, &err, NULL, NULL, NULL, -1);\n<31> if (err == 3) {\n<33> if (pass) {\n<35> snprintf(buf, sizeof(buf), "PASS %s\r\n", pass);\n<37> if ((err = ffurl_write(s->conn_control, buf, strlen(buf))) < 0)\n<39> return err;\n<41> ftp_status(s, &err, NULL, NULL, NULL, -1);\n<49> if (err != 2) {\n<57> const char* command = "USER anonymous\r\n";\n<59> if ((err = ffurl_write(s->conn_control, command, strlen(command))) < 0)\n<63> ftp_status(s, &err, NULL, NULL, NULL, -1);\n<65> if (err == 3) {\n<69> snprintf(buf, sizeof(buf), "PASS %s\r\n", s->anonymous_password);\n<73> snprintf(buf, sizeof(buf), "PASS nopassword\r\n");\n<75> if ((err = ffurl_write(s->conn_control, buf, strlen(buf))) < 0)\n<77> return err;\n<79> ftp_status(s, &err, NULL, NULL, NULL, -1);\n<83> if (err != 2) {
<1> static int nut_write_header(AVFormatContext *s)\n<7> AVIOContext *bc = s->pb;\n<45> if (!nut->stream || !nut->chapter || !nut->time_base) {\n<67> ff_parse_specific_params(st->codec, &time_base.den, &ssize, &time_base.num);\n<73> time_base = (AVRational) {1, st->codec->sample_rate};\n<77> time_base = ff_choose_timebase(s, st, 48000);\n<83> avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n<87> for (j = 0; j < nut->time_base_count; j++)\n<89> if (!memcmp(&time_base, &nut->time_base[j], sizeof(AVRational))) {\n<95> nut->time_base[j]        = time_base;\n<97> nut->stream[i].time_base = &nut->time_base[j];\n<105> if (INT64_C(1000) * time_base.num >= time_base.den)\n<115> FFMAX(time_base.den, time_base.num) / time_base.num;\n<123> AVChapter *ch = s->chapters[i];\n<127> for (j = 0; j < nut->time_base_count; j++)\n<129> if (!memcmp(&ch->time_base, &nut->time_base[j], sizeof(AVRational)))\n<135> nut->time_base[j]         = ch->time_base;\n<137> nut->chapter[i].time_base = &nut->time_base[j];\n<157> avio_write(bc, ID_STRING, strlen(ID_STRING));\n<159> avio_w8(bc, 0);
<1> static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) {\n<7> char prefix = descriptor [ 0 ] ;\n<8> log_frame_info ( cm , descriptor , file ) ;\n<11> mi_row < rows ;\n<13> fprintf ( file , "%c " , prefix ) ;\n<15> mi_col < cols ;\n<17> fprintf ( file , "%2d " , * ( ( int * ) ( ( char * ) ( & mi [ mi_index ] -> mbmi ) + member_offset ) ) ) ;\n<20> fprintf ( file , "\n" ) ;\n<23> fprintf ( file , "\n" ) ;
<1> static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n<5> const uint8_t *buf,\n<9> hwaddr l, MemoryRegion *mr)\n<25> if (!memory_access_is_direct(mr, true)) {\n<95> ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n<97> memcpy(ptr, buf, l);\n<99> invalidate_and_set_dirty(mr, addr1, l);\n<117> buf += l;\n<131> l = len;\n<133> mr = address_space_translate(as, addr, &addr1, &l, true);
<1> static void palmte_onoff_gpios(void *opaque, int line, int level)\n<5> switch (line) {\n<9> printf("%s: current to MMC/SD card %sabled.\n",\n<35> __FUNCTION__, line - 1, level ? "high" : "low");\n<45> __FUNCTION__, line - 4, level ? "high" : "low");
<1> static int mxf_read_partition_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n<5> MXFContext *mxf = arg;\n<25> if ((err = av_reallocp_array(&mxf->partitions, mxf->partitions_count + 1,\n<37> if (mxf->parsing_backward) {\n<43> memmove(&mxf->partitions[mxf->last_forward_partition+1],\n<47> (mxf->partitions_count - mxf->last_forward_partition)*sizeof(*mxf->partitions));\n<49> partition = mxf->current_partition = &mxf->partitions[mxf->last_forward_partition];\n<55> partition = mxf->current_partition = &mxf->partitions[mxf->partitions_count];\n<61> memset(partition, 0, sizeof(*partition));\n<101> partition->closed = partition->type == Footer || !(uid[14] & 1);\n<173> mxf->run_in + partition->previous_partition >= klv_offset) {\n<251> if (partition->kag_size <= 0 || partition->kag_size > (1 << 20)) {\n<253> av_log(mxf->fc, AV_LOG_WARNING, "invalid KAGSize %i - guessing ", partition->kag_size);\n<267> av_log(mxf->fc, AV_LOG_WARNING, "%i\n", partition->kag_size);
<1> int ff_h264_decode_ref_pic_list_reordering ( H264Context * h ) {\n<6> list < h -> list_count ;\n<8> memcpy ( h -> ref_list [ list ] , h -> default_ref_list [ list ] , sizeof ( Picture ) * h -> ref_count [ list ] ) ;\n<64> if ( i < 0 ) {\n<66> memset ( & h -> ref_list [ list ] [ index ] , 0 , sizeof ( Picture ) ) ;\n<77> h -> ref_list [ list ] [ i ] = h -> ref_list [ list ] [ i - 1 ] ;\n<79> h -> ref_list [ list ] [ index ] = * ref ;\n<81> pic_as_field ( & h -> ref_list [ list ] [ index ] , pic_structure ) ;
<1> static int ivi_process_empty_tile(AVCodecContext *avctx, IVIBandDesc *band,\n<181> src = band->ref_buf + tile->ypos * band->pitch + tile->xpos;\n<183> dst = band->buf     + tile->ypos * band->pitch + tile->xpos;\n<185> for (y = 0; y < tile->height; y++) {\n<187> memcpy(dst, src, tile->width*sizeof(band->buf[0]));\n<189> src += band->pitch;\n<191> dst += band->pitch;
<1> static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {\n<5> conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n<12> char * dbname = PQgetvalue ( result , i , 0 ) ;\n<13> if ( ! quiet ) {\n<14> printf ( _ ( "%s: reindexing database \"%s\"\n" ) , progname , dbname ) ;\n<17> reindex_one_database ( dbname , dbname , "DATABASE" , host , port , username , prompt_password , progname , echo , verbose ) ;
<1> int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,\n<9> AVProbeData pd = { filename ? filename : "", NULL, -offset };\n<63> buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n<75> if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n<79> if (ret != AVERROR_EOF) {\n<93> pd.buf_size += ret;\n<95> pd.buf = &buf[offset];\n<99> memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n<105> *fmt = av_probe_input_format2(&pd, 1, &score);
<1> static void unref_picture(H264Context *h, Picture *pic)\n<5> int off = offsetof(Picture, tf) + sizeof(pic->tf);\n<11> if (!pic->f.data[0])\n<37> memset((uint8_t*)pic + off, 0, sizeof(*pic) - off);
<1> void ppce500_init(PPCE500Params *params)\n<71> if (cpu == NULL) {\n<73> fprintf(stderr, "Unable to initialize CPU!\n");\n<255> if (!pci_bus)\n<257> printf("couldn't create PCI controller!\n");\n<309> if (kernel_size < 0) {\n<311> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<331> initrd_size = load_image_targphys(params->initrd_filename, initrd_base,\n<337> if (initrd_size < 0) {\n<339> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<363> dt_size = ppce500_load_device_tree(env, params, dt_base, initrd_base,\n<367> if (dt_size < 0) {\n<369> fprintf(stderr, "couldn't load device tree\n");
<1> static inline void direct_ref_list_init(H264Context * const h){\n<25> if(s->picture_structure == PICT_FRAME){\n<27> memcpy(cur->ref_count[0], cur->ref_count[1], sizeof(cur->ref_count[0]));\n<29> memcpy(cur->ref_poc  [0], cur->ref_poc  [1], sizeof(cur->ref_poc  [0]));
<1> int test_sqr ( BIO * bp , BN_CTX * ctx ) {\n<26> if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) {\n<27> fprintf ( stderr , "Square test failed!\n" ) ;
<1> static void test_info_commands(void)\n<13> while (*info) {\n<17> g_assert(strncmp(info, "info ", 5) == 0);\n<19> endp = strchr(&info[5], ' ');\n<21> g_assert(endp != NULL);\n<23> *endp = '\0';\n<27> if (verbose) {\n<29> fprintf(stderr, "\t%s\n", info);\n<33> resp = hmp(info);\n<39> info = strchr(endp + 1, '\n');\n<41> if (!info) {\n<47> info += 1;
<1> static int adx_decode_header(AVCodecContext *avctx, const uint8_t *buf,\n<11> if (buf[0] != 0x80)\n<17> if (bufsize < offset || memcmp(buf + offset - 6, "(c)CRI", 6))\n<19> return 0;\n<23> avctx->channels    = buf[7];\n<25> avctx->sample_rate = AV_RB32(buf + 8);\n<27> avctx->bit_rate    = avctx->sample_rate * avctx->channels * 18 * 8 / 32;\n<31> return offset;
<1> static int myisamchk ( MI_CHECK * param , char * filename ) {\n<13> if ( ! ( info = mi_open ( filename , ( param -> testflag & ( T_DESCRIPT | T_READONLY ) ) ? O_RDONLY : O_RDWR , HA_OPEN_FOR_REPAIR | ( ( param -> testflag & T_WAIT_FOREVER ) ? HA_OPEN_WAIT_IF_LOCKED : ( param -> testflag & T_DESCRIPT ) ? HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED ) ) ) ) {\n<16> case HA_ERR_CRASHED : mi_check_print_error ( param , "'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair" , filename ) ;\n<18> case HA_ERR_NOT_A_TABLE : mi_check_print_error ( param , "'%s' is not a MyISAM-table" , filename ) ;\n<20> case HA_ERR_CRASHED_ON_USAGE : mi_check_print_error ( param , "'%s' is marked as crashed" , filename ) ;\n<22> case HA_ERR_CRASHED_ON_REPAIR : mi_check_print_error ( param , "'%s' is marked as crashed after last repair" , filename ) ;\n<24> case HA_ERR_OLD_FILE : mi_check_print_error ( param , "'%s' is an old type of MyISAM-table" , filename ) ;\n<26> case HA_ERR_END_OF_FILE : mi_check_print_error ( param , "Couldn't read complete header from '%s'" , filename ) ;\n<28> case EAGAIN : mi_check_print_error ( param , "'%s' is locked. Use -w to wait until unlocked" , filename ) ;\n<30> case ENOENT : mi_check_print_error ( param , "File '%s' doesn't exist" , filename ) ;\n<32> case EACCES : mi_check_print_error ( param , "You don't have permission to use '%s'" , filename ) ;\n<34> default : mi_check_print_error ( param , "%d when opening MyISAM-table '%s'" , my_errno , filename ) ;\n<53> if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( "MyISAM file: %s is already checked\n" , filename ) ;\n<55> mi_check_print_error ( param , "%d when closing MyISAM-table '%s'" , my_errno , filename ) ;\n<63> if ( recreate_table ( param , & info , filename ) ) {\n<64> ( void ) fprintf ( stderr , "MyISAM-table '%s' is not fixed because of errors\n" , filename ) ;\n<70> if ( ! ( param -> testflag & T_SILENT ) ) printf ( "- '%s' has old table-format. Recreating index\n" , filename ) ;\n<81> descript ( param , info , filename ) ;\n<89> mi_check_print_error ( param , "Can't lock indexfile of '%s', error: %d" , filename , my_errno ) ;\n<114> if ( param -> testflag & T_REP_BY_SORT ) error = mi_repair_by_sort ( param , info , filename , rep_quick ) ;\n<115> else error = mi_repair_parallel ( param , info , filename , rep_quick ) ;\n<118> else if ( param -> testflag & T_REP_ANY ) error = mi_repair ( param , info , filename , rep_quick ) ;\n<123> error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , MYF ( 0 ) ) ;\n<134> error = mi_sort_records ( param , info , filename , param -> opt_sort_key , ( my_bool ) ! ( param -> testflag & T_REP ) , update_index ) ;\n<143> if ( ! error && param -> testflag & T_SORT_INDEX ) error = mi_sort_index ( param , info , filename ) ;
<1> void ff_g729_postfilter(DSPContext *dsp, int16_t* ht_prev_data, int* voicing,\n<5> int16_t* residual, int16_t* res_filter_data,\n<7> int16_t* pos_filter_data, int16_t *speech, int subframe_size)\n<13> int16_t lp_gn[33]; // (3.12)\n<25> memset(lp_gn, 0, 33 * sizeof(int16_t));\n<47> memcpy(speech - 10, res_filter_data, 10 * sizeof(int16_t));\n<49> residual_filter(residual + RES_PREV_DATA_SIZE, lp_gn + 11, speech, subframe_size);\n<53> memcpy(res_filter_data, speech + subframe_size - 10, 10 * sizeof(int16_t));\n<71> memmove(residual, residual + subframe_size, RES_PREV_DATA_SIZE * sizeof(int16_t));\n<77> tilt_comp_coeff = get_tilt_comp(dsp, lp_gn, lp_gd, residual_filt_buf + 10, subframe_size);\n<83> ff_celp_lp_synthesis_filter(pos_filter_data + 10, lp_gd + 1,\n<89> memcpy(pos_filter_data, pos_filter_data + subframe_size, 10 * sizeof(int16_t));\n<93> *ht_prev_data = apply_tilt_comp(speech, pos_filter_data + 10, tilt_comp_coeff,
<1> static void vnc_dpy_resize(DisplayState *ds)\n<47> memset(vd->guest.dirty, 0xFF, sizeof(vd->guest.dirty));\n<53> vnc_colordepth(vs);\n<57> vnc_desktop_resize(vs);\n<63> vnc_cursor_define(vs);\n<67> memset(vs->dirty, 0xFF, sizeof(vs->dirty));
<1> static void vfio_map_bar(VFIOPCIDevice *vdev, int nr)\n<43> if (ret != sizeof(pci_bar)) {\n<91> strncat(name, " mmap", sizeof(name) - strlen(name) - 1);\n<93> if (vfio_mmap_region(OBJECT(vdev), &bar->region, &bar->region.mem,\n<105> if (vdev->msix && vdev->msix->table_bar == nr) {\n<121> strncat(name, " msix-hi", sizeof(name) - strlen(name) - 1);\n<125> if (vfio_mmap_region(OBJECT(vdev), &bar->region, &bar->region.mem,
<1> static int qemu_signal_init(void)\n<45> if (sigfd == -1) {\n<47> fprintf(stderr, "failed to create signalfd\n");
<1> static int flac_decode_frame(AVCodecContext *avctx, void *data,\n<11> const uint8_t *buf = avpkt->data;\n<39> if (buf_size > 5 && !memcmp(buf, "\177FLAC", 5)) {\n<41> av_log(s->avctx, AV_LOG_DEBUG, "skiping flac header packet 1\n");\n<43> return buf_size;\n<49> if (buf_size > 0 && (*buf & 0x7F) == FLAC_METADATA_TYPE_VORBIS_COMMENT) {\n<73> if (AV_RB32(buf) == MKBETAG('f','L','a','C')) {
<1> static int get_preset_file_2(const char *preset_name, const char *codec_name, AVIOContext **s)\n<9> const char *base[3] = { getenv("AVCONV_DATADIR"),\n<11> getenv("HOME"),\n<19> for (i = 0; i < FF_ARRAY_ELEMS(base) && ret; i++) {
<1> static int decode_p_frame(FourXContext *f, const uint8_t *buf, int length){\n<63> av_fast_malloc(&f->bitstream_buffer, &f->bitstream_buffer_size, bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<65> if (!f->bitstream_buffer)\n<69> f->dsp.bswap_buf(f->bitstream_buffer, (const uint32_t*)(buf + extra), bitstream_size/4);\n<71> memset((uint8_t*)f->bitstream_buffer + bitstream_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
<1> static void qdev_prop_set(DeviceState *dev, const char *name, void *src, enum PropertyType type)\n<9> prop = qdev_prop_find(dev, name);\n<11> if (!prop) {\n<13> fprintf(stderr, "%s: property \"%s.%s\" not found\n",\n<15> __FUNCTION__, object_get_typename(OBJECT(dev)), name);\n<21> if (prop->info->type != type) {\n<23> fprintf(stderr, "%s: property \"%s.%s\" type mismatch\n",\n<25> __FUNCTION__, object_get_typename(OBJECT(dev)), name);
<1> static int rv34_decode_inter_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n<11> memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n<12> fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n<19> cbp = cbp2 = rv34_decode_inter_mb_header ( r , intra_types ) ;\n<22> r -> deblock_coefs [ mb_pos ] = rv34_set_deblock_coef ( r ) | r -> cbp_luma [ mb_pos ] ;\n<26> if ( r -> is16 ) rv34_output_i16x16 ( r , intra_types , cbp ) ;\n<27> else rv34_output_intra ( r , intra_types , cbp ) ;\n<30> if ( r -> is16 ) {\n<32> memset ( block16 , 0 , 16 * sizeof ( * block16 ) ) ;\n<35> if ( rv34_decode_block ( block16 , gb , r -> cur_vlcs , 3 , 0 , q_dc , q_dc , q_ac ) ) r -> rdsp . rv34_inv_transform ( block16 ) ;\n<68> rv34_process_block ( r , dst + 4 * i , s -> linesize , r -> luma_vlc , 0 , q_ac , q_ac ) ;\n<85> rv34_process_block ( r , pdst , s -> uvlinesize , r -> chroma_vlc , 1 , q_dc , q_ac ) ;
<1> static void kvm_set_phys_mem(MemoryRegionSection *section, bool add)\n<131> if (err) {\n<133> fprintf(stderr, "%s: error unregistering overlapping slot: %s\n",\n<135> __func__, strerror(-err));\n<177> if (err) {\n<179> fprintf(stderr, "%s: error updating slot: %s\n", __func__,\n<181> strerror(-err));\n<219> if (err) {\n<221> fprintf(stderr, "%s: error registering prefix slot: %s\n",\n<223> __func__, strerror(-err));\n<267> if (err) {\n<269> fprintf(stderr, "%s: error registering suffix slot: %s\n",\n<271> __func__, strerror(-err));\n<311> if (err) {\n<313> fprintf(stderr, "%s: error registering slot: %s\n", __func__,\n<315> strerror(-err));
<1> static int vfw_read_header(AVFormatContext *s, AVFormatParameters *ap)\n<5> struct vfw_ctx *ctx = s->priv_data;\n<41> ctx->s = s;\n<47> if(!ctx->hwnd) {\n<59> devnum = atoi(s->filename);\n<63> ret = SendMessage(ctx->hwnd, WM_CAP_DRIVER_CONNECT, devnum, 0);\n<65> if(!ret) {\n<69> DestroyWindow(ctx->hwnd);\n<77> SendMessage(ctx->hwnd, WM_CAP_SET_OVERLAY, 0, 0);\n<79> SendMessage(ctx->hwnd, WM_CAP_SET_PREVIEW, 0, 0);\n<83> ret = SendMessage(ctx->hwnd, WM_CAP_SET_CALLBACK_VIDEOSTREAM, 0,\n<87> if(!ret) {\n<97> SetWindowLongPtr(ctx->hwnd, GWLP_USERDATA, (LONG_PTR) ctx);\n<103> if(!st) {\n<115> bisize = SendMessage(ctx->hwnd, WM_CAP_GET_VIDEOFORMAT, 0, 0);\n<117> if(!bisize)\n<121> bi = av_malloc(bisize);\n<123> if(!bi) {\n<131> ret = SendMessage(ctx->hwnd, WM_CAP_GET_VIDEOFORMAT, bisize, (LPARAM) bi);\n<133> if(!ret)\n<177> ret = SendMessage(ctx->hwnd, WM_CAP_SET_VIDEOFORMAT, bisize, (LPARAM) bi);\n<179> if(!ret) {\n<201> ret = SendMessage(ctx->hwnd, WM_CAP_GET_SEQUENCE_SETUP, sizeof(cparms),\n<203> (LPARAM) &cparms);\n<205> if(!ret)\n<231> ret = SendMessage(ctx->hwnd, WM_CAP_SET_SEQUENCE_SETUP, sizeof(cparms),\n<233> (LPARAM) &cparms);\n<235> if(!ret)\n<289> if(!ctx->mutex) {\n<299> if(!ctx->event) {\n<309> ret = SendMessage(ctx->hwnd, WM_CAP_SEQUENCE_NOFILE, 0, 0);\n<311> if(!ret) {
<1> static void init_t38_info_conv ( packet_info * pinfo ) {\n<25> if ( ! p_t38_packet_conv ) {\n<27> if ( ! p_t38_conv ) {\n<49> conversation_add_proto_data ( p_conv , proto_t38 , p_t38_conv ) ;\n<51> p_t38_packet_conv = wmem_new ( wmem_file_scope ( ) , t38_conv ) ;\n<54> memcpy ( & ( p_t38_packet_conv -> src_t38_info ) , & ( p_t38_conv -> src_t38_info ) , sizeof ( t38_conv_info ) ) ;\n<55> memcpy ( & ( p_t38_packet_conv -> dst_t38_info ) , & ( p_t38_conv -> dst_t38_info ) , sizeof ( t38_conv_info ) ) ;\n<59> p_t38_conv_info = & ( p_t38_conv -> src_t38_info ) ;\n<60> p_t38_packet_conv_info = & ( p_t38_packet_conv -> src_t38_info ) ;\n<63> p_t38_conv_info = & ( p_t38_conv -> dst_t38_info ) ;\n<64> p_t38_packet_conv_info = & ( p_t38_packet_conv -> dst_t38_info ) ;
<1> void ide_exec_cmd(IDEBus *bus, uint32_t val)\n<37> if (!ide_cmd_permitted(s, val)) {\n<87> switch(val) {\n<379> memset(s->io_buffer, 0, 0x200);\n<389> s->io_buffer[0x04] = ide_get_sector(s) >> 16;	/* LBA MSB */\n<391> s->io_buffer[0x05] = ide_get_sector(s) >> 8;	/* LBA */\n<393> s->io_buffer[0x06] = ide_get_sector(s) >> 0;	/* LBA LSB */\n<403> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n<479> switch (s->feature) {\n<553> memset(s->io_buffer, 0, 0x200);\n<573> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n<581> memset(s->io_buffer, 0, 0x200);\n<645> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n<653> switch (s->sector) {\n<657> memset(s->io_buffer, 0, 0x200);\n<679> memset(s->io_buffer, 0, 0x200);\n<713> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);
<1> int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w,\n<17> if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {\n<19> if(out + bpp + 1 > outbuf + out_size) return -1;\n<21> *out++ = (count ^ xor_rep) + add_rep;\n<23> memcpy(out, ptr, bpp);\n<25> out += bpp;\n<31> count = count_pixels(ptr, w-x, bpp, 0);\n<33> *out++ = (count ^ xor_raw) + add_raw;\n<37> if(out + bpp*count > outbuf + out_size) return -1;\n<39> memcpy(out, ptr, bpp * count);\n<41> out += bpp * count;\n<47> ptr += count * bpp;
<1> build_srat(GArray *table_data, GArray *linker, MachineState *machine)\n<45> for (i = 0; i < apic_ids->len; i++) {\n<51> core = acpi_data_push(table_data, sizeof *core);\n<63> memset(core->proximity_hi, 0, 3);
<1> static void rv34_output_i16x16(RV34DecContext *r, int8_t *intra_types, int cbp)\n<25> memset(block16, 0, 16 * sizeof(*block16));\n<57> has_ac = rv34_decode_block(block16, gb, r->cur_vlcs, 3, 0, q_dc, q_dc, q_ac);
<1> uint32_t do_arm_semihosting(CPUARMState *env)\n<7> CPUState *cs = CPU(cpu);\n<33> nr = env->regs[0];\n<37> switch (nr) {\n<49> if (!s) {\n<57> if (arg1 >= 12) {\n<65> if (strcmp(s, ":tt") == 0) {\n<67> int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;\n<69> unlock_user(s, arg0, 0);\n<71> return result_fileno;\n<75> if (use_gdb_syscalls()) {\n<85> ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));\n<89> unlock_user(s, arg0, 0);\n<91> return ret;\n<141> if (!(s = lock_user_string(args)))\n<147> len = strlen(s);\n<151> gdb_do_syscall(arm_semi_cb, "write,2,%x,%x\n", args, len);\n<157> ret = write(STDERR_FILENO, s, len);\n<161> unlock_user(s, args, 0);\n<513> output_size = strlen(ts->boot_info->kernel_filename)\n<517> + strlen(ts->boot_info->kernel_cmdline)\n<543> if (output_size > input_size) {\n<581> pstrcpy(output_buffer, output_size, ts->boot_info->kernel_filename);\n<585> pstrcat(output_buffer, output_size, ts->boot_info->kernel_cmdline);\n<749> fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr);\n<751> cpu_dump_state(cs, stderr, fprintf, 0);
<1> static void ppc_heathrow_init (int ram_size, int vga_ram_size,\n<61> if (!env) {\n<63> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<147> vga_bios_size = load_image(buf, phys_ram_base + vga_bios_offset + 8);\n<149> if (vga_bios_size < 0) {\n<153> fprintf(stderr, "qemu: warning: could not load VGA bios '%s'\n", buf);
<1> void vnc_display_open(const char *id, Error **errp)\n<69> if (!opts) {\n<77> if (!vnc || strcmp(vnc, "none") == 0) {\n<79> return;\n<85> sopts = qemu_opts_create(&socket_optslist, NULL, 0, &error_abort);\n<87> wsopts = qemu_opts_create(&socket_optslist, NULL, 0, &error_abort);\n<91> h = strrchr(vnc, ':');\n<93> if (h) {\n<237> share = qemu_opt_get(opts, "share");\n<239> if (share) {\n<241> if (strcmp(share, "ignore") == 0) {\n<243> vs->share_policy = VNC_SHARE_POLICY_IGNORE;\n<245> } else if (strcmp(share, "allow-exclusive") == 0) {\n<247> vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n<249> } else if (strcmp(share, "force-shared") == 0) {\n<251> vs->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n<255> error_setg(errp, "unknown vnc share= option");\n<267> vs->connections_limit = qemu_opt_get_number(opts, "connections", 32);\n<271> websocket = qemu_opt_get(opts, "websocket");\n<273> if (websocket) {\n<569> qemu_opts_del(sopts);\n<571> qemu_opts_del(wsopts);\n<573> vs->enabled = false;
<1> static void init_parse_context(OptionParseContext *octx,\n<15> memset(octx, 0, sizeof(*octx));\n<25> octx->groups    = av_mallocz(sizeof(*octx->groups) * octx->nb_groups);\n<27> if (!octx->groups)\n<33> for (i = 0; i < octx->nb_groups; i++)
<1> static int config(struct vf_instance *vf,\n<13> for(i=0; i<3; i++){\n<25> vf->priv->temp[i]= malloc(vf->priv->temp_stride[i]*h*sizeof(int16_t));\n<27> vf->priv->src [i]= malloc(vf->priv->temp_stride[i]*h*sizeof(uint8_t));\n<77> vf->priv->outbuf_size= (width + BLOCK)*(height + BLOCK)*10;\n<79> vf->priv->outbuf= malloc(vf->priv->outbuf_size);
<1> static int hq_decode_block(HQContext *c, GetBitContext *gb, int16_t block[64],\n<13> memset(block, 0, 64 * sizeof(*block));
<1> START_TEST(keyword_literal)\n<29> fail_unless(strcmp(qstring_get_str(str), "true") == 0);\n<55> fail_unless(strcmp(qstring_get_str(str), "false") == 0);
<1> void ioinst_handle_stsch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n<77> if (css_schid_final(m, cssid, ssid, schid)) {\n<85> memset(&schib, 0, sizeof(schib));
<1> static int rtsp_parse_request(HTTPContext *c)\n<31> get_word(protocol, sizeof(protocol), &p);\n<35> av_strlcpy(c->method, cmd, sizeof(c->method));\n<39> av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n<43> if (avio_open_dyn_buf(&c->pb) < 0) {\n<57> if (strcmp(protocol, "RTSP/1.0") != 0) {\n<59> rtsp_reply_error(c, RTSP_STATUS_VERSION);\n<71> while (*p != '\n' && *p != '\0')\n<75> if (*p == '\n')\n<79> while (*p != '\0') {\n<81> p1 = memchr(p, '\n', (char *)c->buffer_ptr - p);\n<83> if (!p1)\n<89> if (p2 > p && p2[-1] == '\r')\n<95> if (p2 == p)\n<99> len = p2 - p;\n<101> if (len > sizeof(line) - 1)\n<103> len = sizeof(line) - 1;\n<105> memcpy(line, p, len);\n<107> line[len] = '\0';\n<109> ff_rtsp_parse_line(header, line, NULL, NULL);\n<119> c->seq = header->seq;\n<123> if (!strcmp(cmd, "DESCRIBE"))\n<125> rtsp_cmd_describe(c, url);\n<127> else if (!strcmp(cmd, "OPTIONS"))\n<129> rtsp_cmd_options(c, url);\n<131> else if (!strcmp(cmd, "SETUP"))\n<133> rtsp_cmd_setup(c, url, header);\n<135> else if (!strcmp(cmd, "PLAY"))\n<137> rtsp_cmd_play(c, url, header);\n<139> else if (!strcmp(cmd, "PAUSE"))\n<141> rtsp_cmd_interrupt(c, url, header, 1);\n<143> else if (!strcmp(cmd, "TEARDOWN"))\n<145> rtsp_cmd_interrupt(c, url, header, 0);\n<149> rtsp_reply_error(c, RTSP_STATUS_METHOD);
<1> static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n<31> if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n<55> len = strlen(q_ptsname(master_fd)) + 5;\n<57> chr->filename = g_malloc(len);\n<67> fprintf(stderr, "char device redirected to %s%s%s%s\n",\n<69> q_ptsname(master_fd),
<1> static void serial_init_core(SerialState *s)\n<5> if (!s->chr) {\n<7> fprintf(stderr, "Can't create serial device, empty char device\n");
<1> static SaveStateEntry *find_se(const char *idstr, int instance_id)\n<9> QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n<11> if (!strcmp(se->idstr, idstr) &&\n<13> instance_id == se->instance_id)\n<15> return se;\n<19> return NULL;
<1> static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,\n<11> const uint8_t *buf             = avpkt->data;\n<97> } else if (need_copy) {\n<99> memcpy(frame->buf[0]->data, buf, FFMIN(buf_size, context->frame_size));\n<101> buf = frame->buf[0]->data;\n<125> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE,\n<135> context->palette = av_buffer_alloc(AVPALETTE_SIZE);\n<137> if (!context->palette)\n<141> memcpy(context->palette->data, pal, AVPALETTE_SIZE);\n<155> frame->buf[1]  = av_buffer_ref(context->palette);
<1> static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,\n<3> uint16_t code, const char *reason)\n<9> buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));\n<15> ioc->rawoutput.offset += 2;\n<17> if (reason) {\n<19> buffer_append(&ioc->rawoutput, reason, strlen(reason));\n<31> buffer_reset(&ioc->rawoutput);\n<33> qio_channel_websock_write_wire(ioc, NULL);
<1> ser_write(void *opaque, target_phys_addr_t addr,\n<21> switch (addr)\n<53> s->regs[R_INTR] &= ~value;\n<55> D(printf("r_intr=%x\n", s->regs[R_INTR]));
<1> static void ipvideo_decode_opcodes(IpvideoContext *s)\n<25> memcpy(s->current_frame.data[1], s->avctx->palctrl->palette, PALETTE_COUNT * 4);
<1> static void virtio_balloon_receive_stats(VirtIODevice *vdev, VirtQueue *vq)\n<59> if (qemu_gettimeofday(&tv) < 0) {\n<61> fprintf(stderr, "warning: %s: failed to get time of day\n", __func__);
<1> void slirp_input(Slirp *slirp, const uint8_t *pkt, int pkt_len)\n<11> if (pkt_len < ETH_HLEN)\n<31> if (!m)\n<37> if (M_FREEROOM(m) < pkt_len + 2) {\n<39> m_inc(m, pkt_len + 2);\n<45> memcpy(m->m_data + 2, pkt, pkt_len);
<1> static int decode_audio_block(AC3DecodeContext *s, int blk)\n<19> uint8_t bit_alloc_stages[AC3_MAX_CHANNELS];\n<23> memset(bit_alloc_stages, 0, AC3_MAX_CHANNELS);\n<107> if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {\n<109> memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);\n<359> bit_alloc_stages[ch] = 3;\n<401> if(blk > 0 && s->end_freq[ch] != prev)\n<403> memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);\n<467> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<505> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 1);\n<525> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<557> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<599> bit_alloc_stages[CPL_CH] = FFMAX(bit_alloc_stages[CPL_CH], 2);\n<639> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<663> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<685> if(bit_alloc_stages[ch] > 2) {\n<697> if(bit_alloc_stages[ch] > 1) {\n<717> if(bit_alloc_stages[ch] > 0) {
<1> static DeviceState *qbus_find_dev(BusState *bus, char *elem)\n<21> LIST_FOREACH(dev, &bus->children, sibling) {\n<23> if (dev->id  &&  strcmp(dev->id, elem) == 0) {\n<25> return dev;\n<31> LIST_FOREACH(dev, &bus->children, sibling) {\n<33> if (strcmp(dev->info->name, elem) == 0) {\n<35> return dev;\n<41> LIST_FOREACH(dev, &bus->children, sibling) {\n<43> if (dev->info->alias && strcmp(dev->info->alias, elem) == 0) {\n<45> return dev;\n<51> return NULL;
<1> static int http_open_cnx_internal(URLContext *h, AVDictionary **options)\n<21> av_url_split(proto, sizeof(proto), auth, sizeof(auth),\n<27> ff_url_join(hoststr, sizeof(hoststr), NULL, NULL, hostname, port, NULL);\n<31> proxy_path = getenv("http_proxy");\n<33> use_proxy  = !ff_http_match_no_proxy(getenv("no_proxy"), hostname) &&\n<35> proxy_path != NULL && av_strstart(proxy_path, "http://", NULL);\n<39> if (!strcmp(proto, "https")) {\n<41> lower_proto = "tls";\n<43> use_proxy   = 0;\n<45> if (port < 0)\n<73> ff_url_join(urlbuf, sizeof(urlbuf), proto, NULL, hostname, port, "%s",\n<79> av_url_split(NULL, 0, proxyauth, sizeof(proxyauth),\n<87> ff_url_join(buf, sizeof(buf), lower_proto, NULL, hostname, port, NULL);
<13> err = ff_cbs_write_fragment_data(ctx, frag);\n<21> av_new_packet(pkt, frag->data_size);\n<23> if (err < 0)\n<29> memcpy(pkt->data, frag->data, frag->data_size);\n<31> pkt->size = frag->data_size;
<1> static void bt_hid_interrupt_sdu(void *opaque, const uint8_t *data, int len)\n<9> if (len > BT_HID_MTU || len < 1)\n<13> if ((data[0] & 3) != BT_DATA_OUTPUT)\n<17> if ((data[0] >> 4) == BT_DATA) {\n<19> if (hid->intr_state)\n<27> hid->intrdataout.len = 0;\n<29> } else if ((data[0] >> 4) == BT_DATC) {\n<31> if (!hid->intr_state)\n<41> memcpy(hid->intrdataout.buffer + hid->intrdataout.len, data + 1, len - 1);\n<43> hid->intrdataout.len += len - 1;\n<47> if (!hid->intr_state) {\n<49> memcpy(hid->dataout.buffer, hid->intrdataout.buffer,\n<51> hid->dataout.len = hid->intrdataout.len);\n<63> fprintf(stderr, "%s: bad transaction on Interrupt channel.\n",
<1> static int vio_make_devnode(VIOsPAPRDevice *dev,\n<27> if (!dt_name) {\n<35> node_off = fdt_add_subnode(fdt, vdevice_off, dt_name);\n<37> free(dt_name);
<1> static void copy_block(uint16_t *pdest, uint16_t *psrc, int block_size, int pitch)\n<9> for (y = 0; y != block_size; y++, pdest += pitch, psrc += pitch)\n<11> memcpy(pdest, psrc, block_size * sizeof(pdest[0]));
<1> void cpu_loop(CPUMIPSState *env)\n<23> cpu_exec_start(cs);\n<25> trapnr = cpu_mips_exec(env);\n<27> cpu_exec_end(cs);\n<433> fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n",\n<437> cpu_dump_state(cs, stderr, fprintf, 0);
<1> static void ehci_reset(void *opaque)\n<39> memset(&s->mmio[OPREGBASE], 0x00, MMIO_SIZE - OPREGBASE);
<1> static void get_slice_data(ProresContext *ctx, const uint16_t *src,\n<5> DCTELEM *blocks, uint16_t *emu_buf,\n<21> for (i = 0; i < mbs_per_slice; i++, src += mb_width) {\n<23> if (x >= w) {\n<25> memset(blocks, 0, 64 * (mbs_per_slice - i) * blocks_per_mb\n<57> for (j = 0; j < bh; j++) {\n<59> memcpy(emu_buf + j * 16,\n<61> (const uint8_t*)src + j * linesize,\n<63> bw * sizeof(*src));\n<69> emu_buf[j * 16 + k] = pix;\n<73> for (; j < 16; j++)\n<75> memcpy(emu_buf + j * 16,\n<77> emu_buf + (bh - 1) * 16,\n<79> mb_width * sizeof(*emu_buf));\n<99> blocks += 64;\n<105> blocks += 64;\n<117> blocks += 64;\n<127> blocks += 64;
<1> int ff_ps_apply(AVCodecContext *avctx, PSContext *ps, float L[2][38][64], float R[2][38][64], int top)\n<15> top += NR_BANDS[is34] - 64;\n<17> memset(ps->delay+top, 0, (NR_BANDS[is34] - top)*sizeof(ps->delay[0]));\n<19> if (top < NR_ALLPASS_BANDS[is34])\n<21> memset(ps->ap_delay + top, 0, (NR_ALLPASS_BANDS[is34] - top)*sizeof(ps->ap_delay[0]));
<1> static void dumpDatabases ( PGconn * conn ) {\n<7> i < PQntuples ( res ) ;\n<10> char * dbname = PQgetvalue ( res , i , 0 ) ;\n<11> if ( verbose ) fprintf ( stderr , _ ( "%s: dumping database \"%s\"...\n" ) , progname , dbname ) ;\n<12> fprintf ( OPF , "\\connect %s\n\n" , fmtId ( dbname ) ) ;\n<16> ret = runPgDump ( dbname ) ;\n<17> if ( ret != 0 ) {\n<18> fprintf ( stderr , _ ( "%s: pg_dump failed on database \"%s\", exiting\n" ) , progname , dbname ) ;\n<22> OPF = fopen ( filename , PG_BINARY_A ) ;\n<23> if ( ! OPF ) {\n<24> fprintf ( stderr , _ ( "%s: could not re-open the output file \"%s\": %s\n" ) , progname , filename , strerror ( errno ) ) ;
<1> static int id_wellformed(const char *id)\n<15> for (i = 1; id[i]; i++) {\n<17> if (!qemu_isalnum(id[i]) && !strchr("-._", id[i])) {\n<19> return 0;
<1> int av_parse_color(uint8_t *rgba_color, const char *color_string, void *log_ctx)\n<19> if (!strncmp(color_string, "0x", 2)) {\n<23> int len = strlen(color_string);\n<25> unsigned int rgba = strtoul(color_string, &tail, 16);\n<29> if (*tail || (len != 8 && len != 10)) {\n<37> if (len == 10) {\n<63> if (!entry) {\n<71> memcpy(rgba_color, entry->rgba_color, 4);
<1> static inline void code_gen_alloc(size_t tb_size)\n<9> if (code_gen_buffer == NULL) {\n<11> fprintf(stderr, "Could not allocate dynamic translator buffer\n");
<1> static int mxf_write_header(AVFormatContext *s)\n<41> if (!sc)\n<69> sc->component_depth = 8;\n<71> sc->h_chroma_sub_sample = 2;\n<73> sc->color_siting = 0xFF;\n<79> sc->component_depth     = pix_desc->comp[0].depth_minus1 + 1;\n<81> sc->h_chroma_sub_sample = 1 << pix_desc->log2_chroma_w;\n<87> case AVCHROMA_LOC_TOPLEFT: sc->color_siting = 0; break;\n<89> case AVCHROMA_LOC_LEFT:    sc->color_siting = 6; break;\n<91> case AVCHROMA_LOC_TOP:     sc->color_siting = 1; break;\n<93> case AVCHROMA_LOC_CENTER:  sc->color_siting = 3; break;\n<125> sc->video_bit_rate = st->codec->bit_rate ? st->codec->bit_rate : st->codec->rc_max_rate;\n<129> if (sc->video_bit_rate == 50000000) {\n<135> } else if (sc->video_bit_rate == 40000000) {\n<141> } else if (sc->video_bit_rate == 30000000) {\n<171> sc->signal_standard = 1;\n<269> if (!sc->index) {\n<273> if (sc->index == -1) {\n<287> sc->codec_ul = &mxf_essence_container_uls[sc->index].codec_ul;\n<291> memcpy(sc->track_essence_element_key, mxf_essence_container_uls[sc->index].element_ul, 15);\n<293> sc->track_essence_element_key[15] = present[sc->index];\n<295> PRINT_KEY(s, "track essence element key", sc->track_essence_element_key);\n<323> for (i = 0; i < s->nb_streams; i++) {\n<325> MXFStreamContext *sc = s->streams[i]->priv_data;\n<329> sc->track_essence_element_key[13] = present[sc->index];\n<331> if (!memcmp(sc->track_essence_element_key, mxf_essence_container_uls[15].element_ul, 13)) // DV\n<333> sc->order = (0x15 << 24) | AV_RB32(sc->track_essence_element_key+13);\n<337> sc->order = AV_RB32(sc->track_essence_element_key+12);
<1> static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n<3> char * r = NULL ;\n<7> char * component = NULL ;\n<8> data = malloc ( size * sizeof ( krb5_data ) ) ;\n<9> if ( ! data ) {\n<12> if ( ! retval ) {\n<13> r = strdup ( realm ) ;\n<14> if ( ! r ) {\n<19> if ( count == size ) {\n<22> new_data = realloc ( data , size * sizeof ( krb5_data ) ) ;\n<24> data = new_data ;\n<30> if ( ! retval ) {\n<31> data [ count ] . length = strlen ( component ) ;\n<32> data [ count ] . data = strdup ( component ) ;\n<33> if ( ! data [ count ] . data ) {\n<43> princ -> data = data ;\n<45> r = NULL ;\n<46> data = NULL ;\n<48> if ( data ) {\n<49> while ( -- count >= 0 ) {\n<50> free ( data [ count ] . data ) ;\n<52> free ( data ) ;\n<54> free ( r ) ;
<1> static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<9> SchroEncoderParams *p_schro_params = avctx->priv_data;\n<81> enc_buf = schro_encoder_pull(encoder, &presentation_frame);\n<83> if (enc_buf->length <= 0)\n<113> memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,\n<117> p_schro_params->enc_buf_size += enc_buf->length;\n<135> schro_buffer_unref(enc_buf);\n<153> p_frame_output->size     = p_schro_params->enc_buf_size;\n<155> p_frame_output->p_encbuf = p_schro_params->enc_buf;\n<169> p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);\n<177> p_schro_params->enc_buf_size = 0;\n<179> p_schro_params->enc_buf      = NULL;\n<183> schro_buffer_unref(enc_buf);\n<233> if (!p_frame_output)\n<241> if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)\n<245> if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n<255> memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);\n<271> enc_size = p_frame_output->size;\n<279> if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {\n<281> memcpy(pkt->data + enc_size, p_schro_params->enc_buf,\n<285> enc_size += p_schro_params->enc_buf_size;\n<287> av_freep(&p_schro_params->enc_buf);\n<307> libschroedinger_free_frame(p_frame_output);
<1> int read_file(const char *filename, char **bufptr, size_t *size)\n<9> if (!f) {\n<11> av_log(NULL, AV_LOG_ERROR, "Cannot read file '%s': %s\n", filename, strerror(errno));\n<13> return AVERROR(errno);
<1> static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,\n<39> memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n<729> if (def->flags & TCG_OPF_BB_END) {\n<731> memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
<1> static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)\n<7> SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);\n<67> if (r->req.cmd.xfer == 0) {\n<93> if (r->buflen != r->req.cmd.xfer) {\n<99> r->buf = qemu_malloc(r->req.cmd.xfer);\n<101> r->buflen = r->req.cmd.xfer;\n<107> memset(r->buf, 0, r->buflen);
<1> static int decode_cblk(J2kDecoderContext *s, J2kCodingStyle *codsty, J2kT1Context *t1, J2kCblk *cblk,\n<15> for (y = 0; y < height+2; y++)\n<17> memset(t1->flags[y], 0, (width+2)*sizeof(int));\n<21> for (y = 0; y < height; y++)\n<23> memset(t1->data[y], 0, width*sizeof(int));
<1> static int paf_vid_decode(AVCodecContext *avctx, void *data,\n<7> PAFVideoDecContext *c = avctx->priv_data;\n<17> if ((ret = avctx->reget_buffer(avctx, &c->pic)) < 0)\n<29> if (code & 0x20) {\n<31> for (i = 0; i < 4; i++)\n<33> memset(c->frame[i], 0, c->frame_size);\n<37> memset(c->pic.data[1], 0, AVPALETTE_SIZE);\n<57> uint32_t *out = (uint32_t *)c->pic.data[1];\n<69> if (index + count > AVPALETTE_SIZE)\n<113> if ((ret = decode_0(avctx, code, pkt->data)) < 0)\n<141> if (frame != c->current_frame)\n<143> memcpy(c->frame[c->current_frame], c->frame[frame], c->frame_size);\n<159> while (dst < end) {\n<175> count = FFABS(code) + 1;\n<183> if (code < 0)\n<185> memset(dst, bytestream2_get_byteu(&c->gb), count);\n<191> dst += count;\n<207> dst = c->pic.data[0];\n<209> src = c->frame[c->current_frame];\n<211> for (i = 0; i < avctx->height; i++) {\n<213> memcpy(dst, src, avctx->width);\n<215> dst += c->pic.linesize[0];\n<217> src += avctx->width;
<1> vreader_get_reader_by_name(const char *name)\n<13> for (current_entry = vreader_list_get_first(vreader_list); current_entry;\n<15> current_entry = vreader_list_get_next(current_entry)) {\n<17> VReader *creader = vreader_list_get_reader(current_entry);\n<19> if (strcmp(creader->name, name) == 0) {\n<21> reader = creader;\n<27> vreader_free(creader);
<1> static int encode_q_branch(SnowContext *s, int level, int x, int y){\n<3> uint8_t p_buffer[1024];\n<5> uint8_t i_buffer[1024];\n<7> uint8_t p_state[sizeof(s->block_state)];\n<9> uint8_t i_state[sizeof(s->block_state)];\n<13> uint8_t *pbbak= s->c.bytestream;\n<91> if(s->keyframe){\n<277> memcpy(p_state, s->block_state, sizeof(s->block_state));\n<283> put_rac(&pc, &p_state[4 + s_context], 1);\n<285> put_rac(&pc, &p_state[1 + left->type + top->type], 0);\n<289> put_symbol(&pc, &p_state[128 + 1024 + 32*ref_context], best_ref, 0);\n<291> pred_mv(s, &pmx, &pmy, best_ref, left, top, tr);\n<293> put_symbol(&pc, &p_state[128 + 32*(mx_context + 16*!!best_ref)], mx - pmx, 1);\n<295> put_symbol(&pc, &p_state[128 + 32*(my_context + 16*!!best_ref)], my - pmy, 1);\n<297> p_len= pc.bytestream - pc.bytestream_start;\n<341> memcpy(i_state, s->block_state, sizeof(s->block_state));\n<345> put_rac(&ic, &i_state[4 + s_context], 1);\n<347> put_rac(&ic, &i_state[1 + left->type + top->type], 1);\n<349> put_symbol(&ic, &i_state[32],  l-pl , 1);\n<353> put_symbol(&ic, &i_state[64], cb-pcb, 1);\n<355> put_symbol(&ic, &i_state[96], cr-pcr, 1);\n<359> i_len= ic.bytestream - ic.bytestream_start;\n<395> put_rac(&s->c, &s->block_state[4 + s_context], 0);\n<397> score2 = encode_q_branch(s, level+1, 2*x+0, 2*y+0);\n<399> score2+= encode_q_branch(s, level+1, 2*x+1, 2*y+0);\n<401> score2+= encode_q_branch(s, level+1, 2*x+0, 2*y+1);\n<403> score2+= encode_q_branch(s, level+1, 2*x+1, 2*y+1);\n<417> if(iscore < score){\n<419> pred_mv(s, &pmx, &pmy, 0, left, top, tr);\n<421> memcpy(pbbak, i_buffer, i_len);\n<427> s->c.bytestream= pbbak + i_len;\n<429> set_blocks(s, level, x, y, l, cb, cr, pmx, pmy, 0, BLOCK_INTRA);\n<431> memcpy(s->block_state, i_state, sizeof(s->block_state));\n<437> memcpy(pbbak, p_buffer, p_len);\n<443> s->c.bytestream= pbbak + p_len;\n<445> set_blocks(s, level, x, y, pl, pcb, pcr, mx, my, best_ref, 0);\n<447> memcpy(s->block_state, p_state, sizeof(s->block_state));
<1> static void s390_init(ram_addr_t ram_size,\n<7> const char *kernel_cmdline,\n<33> if (!kvm_enabled()) {\n<35> fprintf(stderr, "The S390 target only works with KVM enabled\n");\n<107> if (lduw_phys(KERN_IMAGE_START) != 0x0dd0) {\n<109> fprintf(stderr, "Specified image is not an s390 boot image\n");\n<191> if (kernel_cmdline) {\n<193> cpu_physical_memory_rw(KERN_PARM_AREA, (uint8_t *)kernel_cmdline,\n<195> strlen(kernel_cmdline), 1);\n<203> for(i = 0; i < nb_nics; i++) {\n<205> NICInfo *nd = &nd_table[i];\n<211> if (!nd->model) {\n<213> nd->model = qemu_strdup("virtio");\n<219> if (strcmp(nd->model, "virtio")) {\n<221> fprintf(stderr, "S390 only supports VirtIO nics\n");\n<223> exit(1);\n<231> qdev_set_nic_properties(dev, nd);
<1> static void png_filter_row(PNGDSPContext *dsp, uint8_t *dst, int filter_type,\n<3> uint8_t *src, uint8_t *last, int size, int bpp)\n<11> switch (filter_type) {\n<15> memcpy(dst, src, size);
<1> static int truemotion1_decode_header(TrueMotion1Context *s)\n<13> uint8_t header_buffer[128];  /* logical maximum size of the header */\n<21> if (s->buf[0] < 0x10)\n<35> memset(header_buffer, 0, 128);\n<43> header.compression = header_buffer[0];\n<45> header.deltaset = header_buffer[1];\n<47> header.vectable = header_buffer[2];\n<49> header.ysize = AV_RL16(&header_buffer[3]);\n<51> header.xsize = AV_RL16(&header_buffer[5]);\n<53> header.checksum = AV_RL16(&header_buffer[7]);\n<55> header.version = header_buffer[9];\n<57> header.header_type = header_buffer[10];\n<59> header.flags = header_buffer[11];\n<61> header.control = header_buffer[12];
<1> static int mov_open_dref(MOVContext *c, AVIOContext **pb, const char *src, MOVDref *ref,\n<21> if (ref->nlvl_to > 0 && ref->nlvl_from > 0 && ref->path[0] != '/') {\n<23> char filename[1025];\n<47> for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n<49> if (ref->path[l] == '/') {\n<65> if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n<67> memcpy(filename, src, src_path - src);\n<69> filename[src_path - src] = 0;\n<79> av_strlcat(filename, ref->path + l + 1, sizeof(filename));\n<81> if (!c->use_absolute_path && !c->fc->open_cb)\n<83> if(strstr(ref->path + l + 1, "..") || ref->nlvl_from > 1)\n<85> return AVERROR(ENOENT);\n<89> if (strlen(filename) + 1 == sizeof(filename))\n<91> return AVERROR(ENOENT);\n<93> if (!open_func(c->fc, pb, filename, AVIO_FLAG_READ, int_cb, NULL))
<1> void qxl_render_resize(PCIQXLDevice *qxl)\n<13> switch (sc->format) {\n<43> fprintf(stderr, "%s: unhandled format: %x\n", __FUNCTION__,
<1> static int hls_probe(AVProbeData *p)\n<9> if (strncmp(p->buf, "#EXTM3U", 7))\n<15> if (p->filename && !av_match_ext(p->filename, "m3u8,m3u"))\n<21> if (strstr(p->buf, "#EXT-X-STREAM-INF:")     ||\n<23> strstr(p->buf, "#EXT-X-TARGETDURATION:") ||\n<25> strstr(p->buf, "#EXT-X-MEDIA-SEQUENCE:"))\n<27> return AVPROBE_SCORE_MAX;\n<29> return 0;
<1> e1000_receive(void *opaque, const uint8_t *buf, size_t size)\n<39> if (!receive_filter(s, buf, size))\n<45> if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n<49> memmove((void *)(buf + 4), buf, 12);\n<87> cpu_physical_memory_write(le64_to_cpu(desc.buffer_addr),\n<89> (void *)(buf + vlan_offset), size);
<1> av_cold static int auto_matrix(SwrContext *s)\n<35> out_ch_layout = clean_layout(s, s->out_ch_layout);\n<37> if(!sane_layout(out_ch_layout)){\n<49> memset(s->matrix, 0, sizeof(s->matrix));
<1> static int vc1_parse(AVCodecParserContext *s,\n<21> uint8_t *unesc_buffer = vpc->unesc_buffer;\n<23> size_t unesc_index = vpc->unesc_index;\n<35> if (pic_found && buf_size == 0) {\n<39> memset(unesc_buffer + unesc_index, 0, UNESCAPED_THRESHOLD - unesc_index);
<1> flac_header (AVFormatContext * s, int idx)\n<51> if (get_bits_long(&gb, 32) != FLAC_STREAMINFO_SIZE)\n<57> avpriv_flac_parse_streaminfo(st->codec, &si, streaminfo_start);\n<71> memcpy(st->codec->extradata, streaminfo_start, st->codec->extradata_size);
<1> make_setup_request (AVFormatContext *s, const char *host, int port, int protocol)\n<29> char transport[2048];\n<45> if (protocol == RTSP_PROTOCOL_RTP_UDP) {\n<89> port = rtp_get_local_port(rtsp_st->rtp_handle);\n<91> if (transport[0] != '\0')\n<93> av_strlcat(transport, ",", sizeof(transport));\n<95> snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n<107> else if (protocol == RTSP_PROTOCOL_RTP_TCP) {\n<109> if (transport[0] != '\0')\n<111> av_strlcat(transport, ",", sizeof(transport));\n<113> snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n<121> else if (protocol == RTSP_PROTOCOL_RTP_UDP_MULTICAST) {\n<123> if (transport[0] != '\0')\n<125> av_strlcat(transport, ",", sizeof(transport));\n<127> snprintf(transport + strlen(transport),\n<129> sizeof(transport) - strlen(transport) - 1,
<1> void net_slirp_smb(const char *exported_dir)\n<5> if (slirp_smb_export) {\n<7> fprintf(stderr, "-smb given twice\n");
<1> static int qtrle_decode_frame(AVCodecContext *avctx,\n<9> QtrleContext *s = avctx->priv_data;\n<87> qtrle_decode_1bpp(s, row_ptr, height);\n<99> qtrle_decode_2n4bpp(s, row_ptr, height, 2);\n<111> qtrle_decode_2n4bpp(s, row_ptr, height, 4);\n<123> qtrle_decode_8bpp(s, row_ptr, height);\n<133> qtrle_decode_16bpp(s, row_ptr, height);\n<141> qtrle_decode_24bpp(s, row_ptr, height);\n<149> qtrle_decode_32bpp(s, row_ptr, height);\n<167> if(has_palette) {\n<169> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<173> if (pal) {\n<177> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<185> memcpy(s->frame->data[1], s->pal, AVPALETTE_SIZE);
<1> int DCT_common_init(MpegEncContext *s)\n<93> switch(s->idct_permutation_type){\n<129> fprintf(stderr, "Internal error, IDCT permutation not set\n");
<1> static void fill_slice_long ( AVCodecContext * avctx , DXVA_Slice_H264_Long * slice , unsigned position , unsigned size ) {\n<5> memset ( slice , 0 , sizeof ( * slice ) ) ;\n<13> if ( h -> slice_type_fixed ) slice -> slice_type += 5 ;
<1> void helper_vmrun(target_ulong addr)\n<131> cpu_set_apic_tpr(env, env->cr[8]);\n<205> tlb_flush(env, 1);\n<229> uint16_t valid_err = event_inj & SVM_EVTINJ_VALID_ERR;\n<237> if (loglevel & CPU_LOG_TB_IN_ASM)\n<239> fprintf(logfile, "Injecting(%#hx): ", valid_err);\n<247> env->exception_index = vector;\n<249> env->error_code = event_inj_err;\n<255> if (loglevel & CPU_LOG_TB_IN_ASM)\n<257> fprintf(logfile, "INTR");\n<263> env->exception_index = vector;\n<265> env->error_code = event_inj_err;\n<271> if (loglevel & CPU_LOG_TB_IN_ASM)\n<273> fprintf(logfile, "NMI");\n<279> env->exception_index = vector;\n<281> env->error_code = event_inj_err;\n<287> if (loglevel & CPU_LOG_TB_IN_ASM)\n<289> fprintf(logfile, "EXEPT");\n<295> env->exception_index = vector;\n<297> env->error_code = event_inj_err;\n<303> if (loglevel & CPU_LOG_TB_IN_ASM)\n<305> fprintf(logfile, "SOFT");\n<311> if (loglevel & CPU_LOG_TB_IN_ASM)\n<313> fprintf(logfile, " %#x %#x\n", env->exception_index, env->error_code);
<1> int av_opencl_buffer_read_image(uint8_t **dst_data, int *plane_size, int plane_num,\n<51> temp = mapped;\n<55> for (i = 0;i < plane_num;i++) {\n<57> memcpy(dst_data[i], temp, plane_size[i]);\n<59> temp += plane_size[i];
<1> static int hls_write_header(AVFormatContext *s)\n<11> const char *pattern = "%d.ts";\n<13> const char *pattern_localtime_fmt = "-%s.ts";\n<15> const char *vtt_pattern = "%d.vtt";\n<131> pattern = ".ts";\n<135> if (hls->use_localtime) {\n<137> basename_size = strlen(s->filename) + strlen(pattern_localtime_fmt) + 1;\n<141> basename_size = strlen(s->filename) + strlen(pattern) + 1;\n<145> hls->basename = av_malloc(basename_size);\n<157> av_strlcpy(hls->basename, s->filename, basename_size);\n<169> av_strlcat(hls->basename, pattern_localtime_fmt, basename_size);\n<173> av_strlcat(hls->basename, pattern, basename_size);\n<189> if(hls->has_subtitle) {\n<195> vtt_pattern = ".vtt";\n<197> vtt_basename_size = strlen(s->filename) + strlen(vtt_pattern) + 1;\n<199> hls->vtt_basename = av_malloc(vtt_basename_size);\n<219> av_strlcpy(hls->vtt_basename, s->filename, vtt_basename_size);\n<241> av_strlcat(hls->vtt_basename, vtt_pattern, vtt_basename_size);
<1> void bdrv_iterate_format(void (*it)(void *opaque, const char *name),\n<17> QLIST_FOREACH(drv, &bdrv_drivers, list) {\n<25> while (formats && i && !found) {\n<27> found = !strcmp(formats[--i], drv->format_name);\n<33> if (!found) {\n<37> formats[count++] = drv->format_name;\n<47> qsort(formats, count, sizeof(formats[0]), qsort_strcmp);\n<59> g_free(formats);
<1> static int svq3_decode_slice_header(AVCodecContext *avctx)\n<7> H264Context *h = &svq3->h;\n<63> if (length > 0) {\n<65> memcpy((uint8_t *) &s->gb.buffer[get_bits_count(&s->gb) >> 3],\n<67> &s->gb.buffer[s->gb.size_in_bits >> 3], (length - 1));\n<145> if (s->mb_x > 0) {\n<147> memset(h->intra4x4_pred_mode+h->mb2br_xy[mb_xy - 1      ]+3, -1, 4*sizeof(int8_t));\n<149> memset(h->intra4x4_pred_mode+h->mb2br_xy[mb_xy - s->mb_x]  , -1, 8*sizeof(int8_t)*s->mb_x);\n<153> if (s->mb_y > 0) {\n<155> memset(h->intra4x4_pred_mode+h->mb2br_xy[mb_xy - s->mb_stride], -1, 8*sizeof(int8_t)*(s->mb_width - s->mb_x));
<1> int kvm_arch_init_vcpu(CPUState *cs)\n<15> ARMCPU *cpu = ARM_CPU(cs);\n<19> if (cpu->kvm_target == QEMU_KVM_ARM_TARGET_NONE) {\n<21> fprintf(stderr, "KVM is not supported for this guest CPU type\n");\n<31> memset(cpu->kvm_init_features, 0, sizeof(cpu->kvm_init_features));\n<131> switch (rlp->reg[i] & KVM_REG_SIZE_MASK) {\n<141> fprintf(stderr, "Can't handle size of register in kernel list\n");\n<195> if (!write_kvmstate_to_list(cpu)) {\n<203> fprintf(stderr, "Initial read of kernel register state failed\n");
<1> static int decode_cce(AACContext * ac, GetBitContext * gb, ChannelElement * che) {\n<13> ChannelCoupling * coup     = &che->coup;\n<21> for (c = 0; c <= coup->num_coupled; c++) {\n<47> if (coup->coupling_point == 2) {\n<53> memset(coup, 0, sizeof(ChannelCoupling));
<1> static int write_f(BlockBackend *blk, int argc, char **argv)\n<27> while ((c = getopt(argc, argv, "bcCpP:qz")) != EOF) {\n<99> if (bflag + pflag + zflag > 1) {\n<101> printf("-b, -p, or -z cannot be specified at the same time\n");\n<109> if (zflag && Pflag) {\n<111> printf("-z and -P cannot be specified at the same time\n");\n<119> offset = cvtnum(argv[optind]);\n<121> if (offset < 0) {\n<123> printf("non-numeric length argument -- %s\n", argv[optind]);\n<133> count = cvtnum(argv[optind]);\n<135> if (count < 0) {\n<137> printf("non-numeric length argument -- %s\n", argv[optind]);\n<159> if (count & 0x1ff) {\n<209> if (cnt < 0) {\n<211> printf("write failed: %s\n", strerror(-cnt));
<1> void bdrv_img_create(const char *filename, const char *fmt,\n<29> drv = bdrv_find_format(fmt);\n<41> proto_drv = bdrv_find_protocol(filename, true, errp);\n<147> backing_file = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);\n<149> if (backing_file) {\n<151> if (!strcmp(filename, backing_file)) {\n<153> error_setg(errp, "Error: Trying to create an image with the "\n<165> backing_fmt = qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT);\n<173> size = qemu_opt_get_size(opts, BLOCK_OPT_SIZE, 0);\n<175> if (backing_file && !(flags & BDRV_O_NO_BACKING)) {\n<187> bdrv_get_full_backing_filename_from_filename(filename, backing_file,\n<291> if (!quiet) {\n<293> printf("Formatting '%s', fmt=%s ", filename, fmt);\n<303> ret = bdrv_create(drv, filename, opts, &local_err);\n<323> error_setg(errp, "The image size is too large for file format '%s'"
<1> static void kvm_apic_mem_write(void *opaque, target_phys_addr_t addr,\n<15> if (ret < 0) {\n<17> fprintf(stderr, "KVM: injection failed, MSI lost (%s)\n",\n<19> strerror(-ret));
<1> static void qxl_log_cmd_draw_compat(PCIQXLDevice *qxl, QXLCompatDrawable *draw,\n<9> qxl_name(qxl_draw_type, draw->type),\n<11> qxl_name(qxl_draw_effect, draw->effect));\n<13> if (draw->bitmap_offset) {
<1> void AUD_register_card (const char *name, QEMUSoundCard *card)\n<9> memset (&card->entries, 0, sizeof (card->entries));
<1> kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) {\n<13> krb5_key_salt_tuple * new_ks_tuple = NULL ;\n<22> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;\n<30> if ( kdb == NULL ) return ENOMEM ;\n<31> memset ( kdb , 0 , sizeof ( * kdb ) ) ;\n<32> memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ;\n<61> if ( ( ret = kadm5_copy_principal ( handle -> context , entry -> principal , & ( kdb -> princ ) ) ) ) goto cleanup ;\n<62> if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ;\n<67> ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ;\n<71> ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ;\n<79> ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ;\n<82> ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ;\n<85> ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;\n<87> ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n<95> ret = kdb_put_entry ( handle , kdb , & adb ) ;\n<96> ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n<97> cleanup : free ( new_ks_tuple ) ;\n<98> krb5_db_free_principal ( handle -> context , kdb ) ;
<1> static void store_word(DBDMA_channel *ch, int key, uint32_t addr,\n<21> if (key != KEY_SYSTEM) {\n<23> printf("DBDMA: STORE_WORD, unimplemented key %x\n", key);
<1> static long gethugepagesize(const char *path, Error **errp)\n<13> ret = statfs(path, &fs);\n<35> fprintf(stderr, "Warning: path not on HugeTLBFS: %s\n", path);
<1> static int udp_open(URLContext *h, const char *uri, int flags)\n<45> p = strchr(uri, '?');\n<49> if (av_find_info_tag(buf, sizeof(buf), "reuse", p)) {\n<127> av_url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, NULL, 0, uri);\n<201> if (bind_ret < 0 && bind(udp_fd,(struct sockaddr *)&my_addr, len) < 0) {\n<203> av_log(h, AV_LOG_ERROR, "bind failed: %s\n", strerror(errno));\n<251> if (setsockopt(udp_fd, SOL_SOCKET, SO_SNDBUF, &tmp, sizeof(tmp)) < 0) {\n<253> av_log(h, AV_LOG_ERROR, "setsockopt(SO_SNDBUF): %s\n", strerror(errno));\n<267> if (setsockopt(udp_fd, SOL_SOCKET, SO_RCVBUF, &tmp, sizeof(tmp)) < 0) {\n<269> av_log(h, AV_LOG_WARNING, "setsockopt(SO_RECVBUF): %s\n", strerror(errno));\n<281> if (connect(udp_fd, (struct sockaddr *) &s->dest_addr, s->dest_addr_len)) {\n<283> av_log(h, AV_LOG_ERROR, "connect: %s\n", strerror(errno));
<1> static DriveInfo *blockdev_init(const char *file, QDict *bs_opts,\n<155> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<173> if (!drv) {\n<187> memset(&cfg, 0, sizeof(cfg));\n<245> if (!check_throttle_config(&cfg, &error)) {\n<341> if (throttle_enabled(&cfg)) {\n<345> bdrv_set_io_limits(dinfo->bdrv, &cfg);
<1> static HTTPContext *find_rtp_session_with_url(const char *url,\n<21> if (!rtp_c)\n<31> path = path1;\n<33> if (*path == '/')\n<35> path++;\n<37> if(!strcmp(path, rtp_c->stream->filename)) return rtp_c;\n<39> for(s=0; s<rtp_c->stream->nb_streams; ++s) {\n<45> if(!strncmp(path, buf, sizeof(buf))) {
<1> int inet_connect_opts(QemuOpts *opts, Error **errp)\n<21> memset(&ai,0, sizeof(ai));\n<37> if (addr == NULL || port == NULL) {\n<39> fprintf(stderr, "inet_connect: host and/or port not specified\n");\n<61> if (0 != (rc = getaddrinfo(addr, port, &ai, &res))) {\n<63> fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port,\n<65> gai_strerror(rc));\n<75> for (e = res; e != NULL; e = e->ai_next) {\n<77> if (getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n<83> fprintf(stderr,"%s: getnameinfo: oops\n", __FUNCTION__);\n<91> if (sock < 0) {\n<93> fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__,\n<95> inet_strfamily(e->ai_family), strerror(errno));\n<141> if (NULL == e->ai_next)\n<143> fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__,\n<145> inet_strfamily(e->ai_family),\n<147> e->ai_canonname, uaddr, uport, strerror(errno));
<1> static int dnxhd_encode_init(AVCodecContext *avctx)\n<5> DNXHDEncContext *ctx = avctx->priv_data;\n<49> index = ff_dnxhd_get_cid_table(ctx->cid);\n<53> ctx->cid_table = &ff_dnxhd_cid_table[index];\n<57> ctx->m.avctx = avctx;\n<59> ctx->m.mb_intra = 1;\n<61> ctx->m.h263_aic = 1;\n<69> ff_dct_common_init(&ctx->m);\n<85> ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;\n<87> ctx->block_width_l2 = 4;\n<91> ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;\n<93> ctx->block_width_l2 = 3;\n<113> ctx->interlaced = 1;\n<139> ctx->min_padding = 1600;\n<147> if (dnxhd_init_rc(ctx) < 0)\n<153> FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size, ctx->m.mb_height*sizeof(uint32_t), fail);\n<155> FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs, ctx->m.mb_height*sizeof(uint32_t), fail);\n<157> FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,    ctx->m.mb_num   *sizeof(uint16_t), fail);\n<159> FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,  ctx->m.mb_num   *sizeof(uint8_t),  fail);\n<163> ctx->frame.key_frame = 1;\n<165> ctx->frame.pict_type = AV_PICTURE_TYPE_I;\n<183> for (i = 1; i < avctx->thread_count; i++) {\n<185> ctx->thread[i] =  av_malloc(sizeof(DNXHDEncContext));\n<187> memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));
<1> static void find_best_tables(MpegEncContext * s)\n<105> memset(s->ac_stats, 0, sizeof(int)*(MAX_LEVEL+1)*(MAX_RUN+1)*2*2*2);
<1> static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n<513> if (local_err) {\n<551> opt_overlap_check = qemu_opt_get(opts, "overlap-check") ?: "cached";\n<553> if (!strcmp(opt_overlap_check, "none")) {\n<555> overlap_check_template = 0;\n<557> } else if (!strcmp(opt_overlap_check, "constant")) {\n<559> overlap_check_template = QCOW2_OL_CONSTANT;\n<561> } else if (!strcmp(opt_overlap_check, "cached")) {\n<563> overlap_check_template = QCOW2_OL_CACHED;\n<565> } else if (!strcmp(opt_overlap_check, "all")) {\n<567> overlap_check_template = QCOW2_OL_ALL;\n<571> error_setg(errp, "Unsupported value '%s' for qcow2 option "\n<577> qemu_opts_del(opts);\n<579> ret = -EINVAL;\n<587> s->overlap_check = 0;\n<589> for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n<605> qemu_opts_del(opts);\n<609> if (s->use_lazy_refcounts && s->qcow_version < 3) {\n<641> g_free(s->unknown_header_fields);\n<643> cleanup_unknown_header_ext(bs);\n<645> qcow2_free_snapshots(bs);\n<647> qcow2_refcount_close(bs);\n<649> g_free(s->l1_table);\n<653> s->l1_table = NULL;\n<655> if (s->l2_table_cache) {\n<661> g_free(s->cluster_cache);\n<663> qemu_vfree(s->cluster_data);\n<665> return ret;
<1> static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,\n<11> while (**buf == '[') {\n<13> char *name = parse_link_name(buf, log_ctx);\n<19> if (!name)\n<53> *buf += strspn(*buf, WHITESPACES);
<1> void net_check_clients(void)\n<37> QTAILQ_FOREACH(vlan, &vlans, next) {\n<71> if (has_host_dev && !has_nic)\n<73> fprintf(stderr, "Warning: vlan %d with no nics\n", vlan->id);\n<75> if (has_nic && !has_host_dev)\n<85> QTAILQ_FOREACH(vc, &non_vlan_clients, next) {\n<87> if (!vc->peer) {\n<89> fprintf(stderr, "Warning: %s %s has no peer\n",\n<111> NICInfo *nd = &nd_table[i];\n<113> if (nd->used && !nd->instantiated) {\n<115> fprintf(stderr, "Warning: requested NIC (%s, model %s) "
<1> static int get_key(const char **ropts, const char *delim, char *key, unsigned key_size)\n<7> const char *opts = *ropts;\n<11> opts += strspn(opts, WHITESPACES);\n<13> while (is_key_char(*opts)) {\n<21> (opts)++;\n<25> opts += strspn(opts, WHITESPACES);\n<27> if (!*opts || !strchr(delim, *opts))\n<29> return AVERROR(EINVAL);\n<31> opts++;\n<33> key[key_pos++] = 0;\n<35> if (key_pos == key_size)\n<39> *ropts = opts;\n<41> return 0;
<1> static void build_config ( char * prefix , struct server * server ) {\n<3> int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;\n<4> path = ss_malloc ( path_size ) ;\n<5> snprintf ( path , path_size , "%s/.shadowsocks_%s.conf" , prefix , server -> port ) ;\n<7> if ( f == NULL ) {\n<17> fprintf ( f , "\"password\":\"%s\"" , server -> password ) ;\n<18> if ( server -> fast_open [ 0 ] ) fprintf ( f , ",\n\"fast_open\": %s" , server -> fast_open ) ;\n<19> if ( server -> mode ) fprintf ( f , ",\n\"mode\":\"%s\"" , server -> mode ) ;\n<20> if ( server -> method ) fprintf ( f , ",\n\"method\":\"%s\"" , server -> method ) ;\n<21> if ( server -> plugin ) fprintf ( f , ",\n\"plugin\":\"%s\"" , server -> plugin ) ;\n<22> if ( server -> plugin_opts ) fprintf ( f , ",\n\"plugin_opts\":\"%s\"" , server -> plugin_opts ) ;
<1> soread(so)\n<3> struct socket *so;\n<39> iov[0].iov_base = sb->sb_wptr;\n<51> if (iov[0].iov_len > mss)\n<53> iov[0].iov_len -= iov[0].iov_len%mss;\n<63> if (iov[0].iov_len > len) iov[0].iov_len = len;\n<69> iov[1].iov_base = sb->sb_data;\n<73> if(iov[1].iov_len > len)\n<75> iov[1].iov_len = len;\n<83> if (iov[1].iov_len > lss) {\n<85> iov[1].iov_len -= lss;\n<93> iov[0].iov_len -= lss;\n<105> if (iov[0].iov_len > mss)\n<107> iov[0].iov_len -= iov[0].iov_len%mss;\n<125> nn = recv(so->s, iov[0].iov_base, iov[0].iov_len,0);\n<129> if (nn <= 0) {\n<131> if (nn < 0 && (errno == EINTR || errno == EAGAIN))\n<137> DEBUG_MISC((dfd, " --- soread() disconnected, nn = %d, errno = %d-%s\n", nn, errno,strerror(errno)));\n<139> sofcantrcvmore(so);\n<141> tcp_sockclosed(sototcpcb(so));\n<171> if (n == 2 && nn == iov[0].iov_len)\n<173> nn += recv(so->s, iov[1].iov_base, iov[1].iov_len,0);\n<177> DEBUG_MISC((dfd, " ... read nn = %d bytes\n", nn));
<1> int ff_parse_mpeg2_descriptor(AVFormatContext *fc, AVStream *st, int stream_type,\n<171> if (st->codec->extradata_size == 4 &&\n<173> memcmp(st->codec->extradata, *pp, 4))\n<179> st->codec->extradata = av_malloc(4 + FF_INPUT_BUFFER_PADDING_SIZE);\n<181> if (st->codec->extradata) {\n<185> memcpy(st->codec->extradata, *pp, 4);\n<191> *pp += 4;
<1> static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n<97> if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n<99> fprintf(stderr, "attempt to set frame list size -- value %d\n",\n<101> val & USBCMD_FLS);\n<159> if (ehci_periodic_enabled(s)) {\n<175> if (ehci_async_enabled(s)) {
<1> static int megasas_dcmd_cfg_read(MegasasState *s, MegasasCmd *cmd)\n<59> if (info->size > 4096) {\n<127> ld = (struct mfi_ld_config *)(data + ld_offset);\n<129> memset(ld, 0, sizeof(struct mfi_ld_config));
<1> PyObject * PyString_DecodeEscape ( const char * s , Py_ssize_t len , const char * errors , Py_ssize_t unicode , const char * recode_encoding ) {\n<89> if ( ! errors || strcmp ( errors , "strict" ) == 0 ) {\n<93> if ( strcmp ( errors , "replace" ) == 0 ) {\n<96> else if ( strcmp ( errors , "ignore" ) == 0 ) ;
<1> void xen_map_cache_init(void)\n<37> if (rlimit_as.rlim_max != RLIM_INFINITY) {\n<39> fprintf(stderr, "Warning: QEMU's maximum size of virtual"
<1> static int truespeech_decode_frame(AVCodecContext *avctx,\n<23> int16_t out_buf[240];\n<47> for(j = 0; j < iterations; j++) {\n<61> memset(out_buf, 0, 240 * 2);\n<67> truespeech_place_pulses(c, out_buf + i * 60, i);\n<69> truespeech_update_filters(c, out_buf + i * 60, i);\n<71> truespeech_synth(c, out_buf + i * 60, i);\n<85> *samples++ = out_buf[i];
<1> static void ppc_spapr_init(ram_addr_t ram_size,\n<97> if (!env) {\n<99> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<243> for (i = 0; i < nb_nics; i++) {\n<245> NICInfo *nd = &nd_table[i];\n<249> if (!nd->model) {\n<251> nd->model = g_strdup("ibmveth");\n<257> if (strcmp(nd->model, "ibmveth") == 0) {\n<259> spapr_vlan_create(spapr->vio_bus, 0x1000 + i, nd);\n<263> pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n<285> kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n<299> if (kernel_size < 0) {\n<301> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<317> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<321> if (initrd_size < 0) {\n<323> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<345> if (ram_size < (MIN_RAM_SLOF << 20)) {\n<347> fprintf(stderr, "qemu: pSeries SLOF firmware requires >= "
<1> static void ide_init2(IDEState *ide_state,\n<19> for(i = 0; i < 2; i++) {\n<21> s = ide_state + i;\n<53> bdrv_set_change_cb(s->bs, cdrom_change_cb, s);\n<61> strncpy(s->drive_serial_str, drive_get_serial(s->bs),\n<65> if (strlen(s->drive_serial_str) == 0)\n<67> snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n<69> "QM%05d", s->drive_serial);\n<77> ide_reset(s);
<1> static void openpic_reset(DeviceState *d)\n<41> for (i = 0; i < MAX_CPU; i++) {\n<47> memset(&opp->dst[i].raised, 0, sizeof(IRQ_queue_t));\n<51> memset(&opp->dst[i].servicing, 0, sizeof(IRQ_queue_t));
<1> int ff_h264_decode_mb_cabac(H264Context *h) {\n<91> compute_mb_neighbors(h);\n<97> mb_type = decode_cabac_mb_type_b( h );\n<139> mb_type= decode_cabac_intra_mb_type(h, 17, 0);\n<147> mb_type= decode_cabac_intra_mb_type(h, 3, 1);\n<177> if(IS_INTRA_PCM(mb_type)) {\n<189> ptr= h->cabac.bytestream;\n<191> if(h->cabac.low&0x1) ptr--;\n<195> if(h->cabac.low&0x1FF) ptr--;\n<203> memcpy(h->mb, ptr, 256); ptr+=256;\n<205> if(CHROMA){\n<207> memcpy(h->mb+128, ptr, 128); ptr+=128;\n<229> memset(h->non_zero_count[mb_xy], 16, 16);
<1> static void ipmi_sim_realize(DeviceState *dev, Error **errp)\n<41> ipmi_sdr_init(ibs);\n<51> if (qemu_uuid_set) {\n<53> memcpy(&ibs->uuid, qemu_uuid, 16);\n<57> memset(&ibs->uuid, 0, 16);
<1> static void ppc_spapr_init(QEMUMachineInitArgs *args)\n<173> if (cpu == NULL) {\n<175> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<313> for (i = 0; i < nb_nics; i++) {\n<315> NICInfo *nd = &nd_table[i];\n<319> if (!nd->model) {\n<321> nd->model = g_strdup("ibmveth");\n<327> if (strcmp(nd->model, "ibmveth") == 0) {\n<329> spapr_vlan_create(spapr->vio_bus, nd);\n<333> pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n<375> if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n<377> fprintf(stderr, "qemu: pSeries SLOF firmware requires >= "\n<393> kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n<419> if (kernel_size < 0) {\n<421> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<443> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<447> if (initrd_size < 0) {\n<449> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",
<1> static void stereo_processing(PSContext *ps, float (*l)[32][2], float (*r)[32][2], int is34)\n<45> if (ps->num_env_old) {\n<47> memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n<49> memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n<51> memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n<53> memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n<55> memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n<57> memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n<59> memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n<61> memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n<83> map_val_20_to_34(H11[0][0]);\n<85> map_val_20_to_34(H11[1][0]);\n<87> map_val_20_to_34(H12[0][0]);\n<89> map_val_20_to_34(H12[1][0]);\n<91> map_val_20_to_34(H21[0][0]);\n<93> map_val_20_to_34(H21[1][0]);\n<95> map_val_20_to_34(H22[0][0]);\n<97> map_val_20_to_34(H22[1][0]);\n<119> map_val_34_to_20(H11[0][0]);\n<121> map_val_34_to_20(H11[1][0]);\n<123> map_val_34_to_20(H12[0][0]);\n<125> map_val_34_to_20(H12[1][0]);\n<127> map_val_34_to_20(H21[0][0]);\n<129> map_val_34_to_20(H21[1][0]);\n<131> map_val_34_to_20(H22[0][0]);\n<133> map_val_34_to_20(H22[1][0]);
<1> static inline int64_t get_sector_offset(BlockDriverState *bs,\n<7> BDRVVPCState *s = bs->opaque;\n<45> if (write && (s->last_bitmap_offset != bitmap_offset)) {\n<47> uint8_t bitmap[s->bitmap_size];\n<53> memset(bitmap, 0xff, s->bitmap_size);\n<55> bdrv_pwrite_sync(bs->file, bitmap_offset, bitmap, s->bitmap_size);
<1> static int vmdk_create(const char *filename, QemuOpts *opts, Error **errp)\n<123> if (!adapter_type) {\n<125> adapter_type = g_strdup("ide");\n<127> } else if (strcmp(adapter_type, "ide") &&\n<129> strcmp(adapter_type, "buslogic") &&\n<131> strcmp(adapter_type, "lsilogic") &&\n<133> strcmp(adapter_type, "legacyESX")) {\n<135> error_setg(errp, "Unknown adapter type: '%s'", adapter_type);\n<137> ret = -EINVAL;\n<143> if (strcmp(adapter_type, "ide") != 0) {\n<149> number_heads = 255;\n<153> if (!fmt) {\n<157> fmt = g_strdup("monolithicSparse");\n<159> } else if (strcmp(fmt, "monolithicFlat") &&\n<161> strcmp(fmt, "monolithicSparse") &&\n<163> strcmp(fmt, "twoGbMaxExtentSparse") &&\n<165> strcmp(fmt, "twoGbMaxExtentFlat") &&\n<167> strcmp(fmt, "streamOptimized")) {\n<169> error_setg(errp, "Unknown subformat: '%s'", fmt);\n<171> ret = -EINVAL;\n<177> split = !(strcmp(fmt, "twoGbMaxExtentFlat") &&\n<179> strcmp(fmt, "twoGbMaxExtentSparse"));\n<181> flat = !(strcmp(fmt, "monolithicFlat") &&\n<183> strcmp(fmt, "twoGbMaxExtentFlat"));\n<185> compress = !strcmp(fmt, "streamOptimized");\n<187> if (flat) {\n<197> if (flat && backing_file) {\n<225> if (ret != 0) {\n<231> if (strcmp(bs->drv->format_name, "vmdk")) {\n<233> bdrv_unref(bs);\n<235> ret = -EINVAL;\n<241> parent_cid = vmdk_read_cid(bs, 0);\n<243> bdrv_unref(bs);\n<245> snprintf(parent_desc_line, sizeof(parent_desc_line),\n<255> filesize = total_size;\n<257> while (filesize > 0) {\n<269> if (split && size > split_size) {\n<349> desc_len = strlen(desc);\n<353> if (!split && !flat) {\n<385> ret = bdrv_pwrite(new_bs, desc_offset, desc, desc_len);\n<419> g_free(adapter_type);\n<423> g_free(fmt);\n<425> g_free(desc);
<1> SDState *sd_init(BlockBackend *blk, bool is_spi)\n<9> if (blk && blk_is_read_only(blk)) {\n<11> fprintf(stderr, "sd_init: Cannot use read-only drive\n");
<1> int load_flt_binary(struct linux_binprm * bprm, struct target_pt_regs * regs,\n<23> memset(libinfo, 0, sizeof(libinfo));\n<39> stack_len = 0;\n<41> for (i = 0; i < bprm->argc; ++i) {\n<45> stack_len += strlen(bprm->argv[i]);\n<49> for (i = 0; i < bprm->envc; ++i) {\n<53> stack_len += strlen(bprm->envp[i]);\n<57> stack_len += (bprm->argc + 1) * 4; /* the argv array */\n<65> res = load_flat_file(bprm, libinfo, 0, &stack_len);\n<115> p = copy_strings(p, bprm->envc, bprm->envp);\n<117> p = copy_strings(p, bprm->argc, bprm->argv);
<1> SocketAddressLegacy *socket_parse(const char *str, Error **errp)\n<47> } else if (strstart(str, "vsock:", NULL)) {\n<51> addr->u.vsock.data = g_new(VsockSocketAddress, 1);\n<53> if (vsock_parse(addr->u.vsock.data, str + strlen("vsock:"), errp)) {\n<73> return addr;\n<79> qapi_free_SocketAddressLegacy(addr);\n<81> return NULL;
<1> void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,\n<3> uint8_t *iv, int decrypt)\n<15> xtea_crypt_ecb(ctx, dst, src, decrypt);\n<19> if (iv) {\n<23> dst[i] = dst[i] ^ iv[i];\n<25> memcpy(iv, src, 8);\n<31> if (iv) {\n<35> dst[i] = src[i] ^ iv[i];\n<37> xtea_crypt_ecb(ctx, dst, dst, decrypt);\n<39> memcpy(iv, dst, 8);\n<51> src   += 8;\n<53> dst   += 8;
<1> static uint32_t get_generic_seed(void)\n<25> if(TEST){\n<27> memset(buffer, 0, sizeof(buffer));\n<53> buffer[i & 511]++;\n<57> buffer[++i & 511] += (t - last_t) % 3294638521U;\n<79> av_sha_update(sha, (const uint8_t *)buffer, sizeof(buffer));
<1> static void mvc_fast_memmove(CPUS390XState *env, uint32_t l, uint64_t dest,\n<13> hwaddr len = l;\n<49> dest_p = cpu_physical_memory_map(dest_phys, &len, 1);\n<51> src_p = cpu_physical_memory_map(src_phys, &len, 0);\n<55> memmove(dest_p, src_p, len);\n<59> cpu_physical_memory_unmap(dest_p, 1, len, len);\n<61> cpu_physical_memory_unmap(src_p, 0, len, len);
<1> int rom_add_blob(const char *name, const void *blob, size_t len,\n<11> rom = g_malloc0(sizeof(*rom));\n<19> rom->data    = g_malloc0(rom->romsize);\n<21> memcpy(rom->data, blob, len);\n<23> rom_insert(rom);
<1> static void omap_ppm_save(const char *filename, uint8_t *data,\n<3> int w, int h, int linesize, Error **errp)\n<19> if (!f) {\n<21> error_setg(errp, "failed to open file '%s': %s", filename,\n<23> strerror(errno));\n<29> ret = fprintf(f, "P6\n%d %d\n%d\n", w, h, 255);\n<31> if (ret < 0) {\n<39> bpp = linesize / w;\n<41> for (y = 0; y < h; y ++) {\n<53> ret = fputc((v >> 8) & 0xf8, f);\n<55> if (ret == EOF) {\n<63> if (ret == EOF) {\n<71> if (ret == EOF) {\n<85> ret = fputc((v >> 16) & 0xff, f);\n<87> if (ret == EOF) {\n<95> if (ret == EOF) {\n<103> if (ret == EOF) {\n<123> fclose(f);\n<131> error_setg(errp, "failed to write to file '%s': %s", filename,\n<133> strerror(errno));
<1> static void test_abstract_interfaces(void)\n<39> const char *aname = qdict_get_str(at, "name");\n<51> const char *oname = qdict_get_str(ot, "name");\n<53> if (!strcmp(aname, oname)) {\n<55> found = oname;
<1> static void cirrus_bitblt_cputovideo_next(CirrusVGAState * s)\n<29> (*s->cirrus_rop)(s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n<33> cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,\n<41> if (s->cirrus_srccounter <= 0)\n<53> copy_count = s->cirrus_srcptr_end - end_ptr;\n<55> memmove(s->cirrus_bltbuf, end_ptr, copy_count);\n<57> s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;\n<59> s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;
<1> static void event_loop(VideoState *cur_stream)\n<213> thh = tns/3600;\n<215> tmm = (tns%3600)/60;\n<217> tss = (tns%60);\n<223> hh = ns/3600;\n<225> mm = (ns%3600)/60;\n<227> ss = (ns%60);\n<229> fprintf(stderr, "Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \n", frac*100,
<1> int nbd_receive_negotiate(QIOChannel *ioc, const char *name, uint32_t *flags,\n<23> if (read_sync(ioc, buf, 8) != 8) {\n<33> buf[8] = '\0';\n<35> if (strlen(buf) == 0) {\n<37> error_setg(errp, "Server connection closed unexpectedly");\n<47> qemu_isprint(buf[0]) ? buf[0] : '.',\n<49> qemu_isprint(buf[1]) ? buf[1] : '.',\n<51> qemu_isprint(buf[2]) ? buf[2] : '.',\n<53> qemu_isprint(buf[3]) ? buf[3] : '.',\n<55> qemu_isprint(buf[4]) ? buf[4] : '.',\n<57> qemu_isprint(buf[5]) ? buf[5] : '.',\n<59> qemu_isprint(buf[6]) ? buf[6] : '.',\n<61> qemu_isprint(buf[7]) ? buf[7] : '.');\n<65> if (memcmp(buf, "NBDMAGIC", 8) != 0) {\n<67> error_setg(errp, "Invalid magic received");\n<75> if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {\n<137> if (!name) {\n<157> if (write_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {\n<165> namesize = cpu_to_be32(strlen(name));\n<167> if (write_sync(ioc, &namesize, sizeof(namesize)) !=\n<177> if (write_sync(ioc, (char *)name, strlen(name)) != strlen(name)) {\n<179> error_setg(errp, "Failed to send export name");\n<187> if (read_sync(ioc, &s, sizeof(s)) != sizeof(s)) {\n<259> if (read_sync(ioc, &buf, 124) != 124) {
<1> static void jpeg_table_header(AVCodecContext *avctx, PutBitContext *p,\n<5> uint16_t luma_intra_matrix[64],\n<7> uint16_t chroma_intra_matrix[64],\n<21> if (avctx->codec_id != AV_CODEC_ID_LJPEG) {\n<27> sizeof(luma_intra_matrix[0]) * 64);\n<37> put_bits(p, 16, 2 + matrix_count * (1 + 64));\n<47> put_bits(p, 8, luma_intra_matrix[j]);\n<63> put_bits(p, 8, chroma_intra_matrix[j]);
<1> static int qcow_create2(const char *filename, int64_t total_size,\n<3> const char *backing_file, const char *backing_format,\n<19> QCowCreateState s1, *s = &s1;\n<27> memset(s, 0, sizeof(*s));\n<33> if (fd < 0)\n<37> memset(&header, 0, sizeof(header));\n<49> if (backing_file) {\n<51> if (backing_format) {\n<55> backing_format_len = strlen(backing_format);\n<57> ext_bf.len = (backing_format_len + 7) & ~7;\n<65> backing_filename_len = strlen(backing_file);\n<67> header.backing_file_size = cpu_to_be32(backing_filename_len);\n<79> if (s->cluster_bits < MIN_CLUSTER_BITS ||\n<81> s->cluster_bits > MAX_CLUSTER_BITS)\n<85> fprintf(stderr, "Cluster size must be a power of two between "\n<89> 1 << MIN_CLUSTER_BITS,\n<91> 1 << (MAX_CLUSTER_BITS - 10));\n<97> s->cluster_size = 1 << s->cluster_bits;\n<101> header.cluster_bits = cpu_to_be32(s->cluster_bits);\n<115> l2_bits = s->cluster_bits - 3;\n<117> shift = s->cluster_bits + l2_bits;\n<121> offset = align_offset(header_size, s->cluster_size);\n<125> header.l1_table_offset = cpu_to_be64(s->l1_table_offset);\n<129> offset += align_offset(l1_size * sizeof(uint64_t), s->cluster_size);\n<133> s->refcount_table = qemu_mallocz(s->cluster_size);\n<143> offset += s->cluster_size;\n<151> tmp = offset >> s->cluster_bits;\n<153> ref_clusters = (tmp >> (s->cluster_bits - REFCOUNT_SHIFT)) + 1;\n<159> offset += s->cluster_size;\n<165> s->refcount_block = qemu_mallocz(ref_clusters * s->cluster_size);\n<171> qcow2_create_refcount_update(s, 0, header_size);\n<187> write(fd, &header, sizeof(header));\n<191> if (backing_format_len) {\n<195> int d = ext_bf.len - backing_format_len;\n<199> memset(zero, 0, sizeof(zero));\n<207> write(fd, backing_format, backing_format_len);\n<211> write(fd, zero, d);\n<217> write(fd, backing_file, backing_filename_len);
<1> av_cold void ff_dsputil_init(DSPContext* c, AVCodecContext *avctx)\n<481> memset(c->put_2tap_qpel_pixels_tab, 0, sizeof(c->put_2tap_qpel_pixels_tab));\n<483> memset(c->avg_2tap_qpel_pixels_tab, 0, sizeof(c->avg_2tap_qpel_pixels_tab));\n<667> if (HAVE_MMX)        ff_dsputil_init_mmx   (c, avctx);\n<669> if (ARCH_ARM)        ff_dsputil_init_arm   (c, avctx);\n<671> if (HAVE_VIS)        ff_dsputil_init_vis   (c, avctx);\n<673> if (ARCH_ALPHA)      ff_dsputil_init_alpha (c, avctx);\n<675> if (ARCH_PPC)        ff_dsputil_init_ppc   (c, avctx);\n<677> if (HAVE_MMI)        ff_dsputil_init_mmi   (c, avctx);\n<679> if (ARCH_SH4)        ff_dsputil_init_sh4   (c, avctx);\n<681> if (ARCH_BFIN)       ff_dsputil_init_bfin  (c, avctx);
<1> static int decode_coeffs(WMAProDecodeCtx *s, int c)\n<151> ci->coeffs[cur_coeff] = 0;\n<171> if (cur_coeff < s->subframe_len) {\n<175> sizeof(*ci->coeffs) * (s->subframe_len - cur_coeff));
<1> static void test_visitor_in_native_list_string(TestInputVisitorData *data,\n<49> for (i = 0, elem = cvalue->u.string.data; elem; elem = elem->next, i++) {\n<51> gchar str[8];\n<53> sprintf(str, "%d", i);
<1> static int read_access_unit(AVCodecContext *avctx, void* data, int *data_size,\n<11> MLPDecodeContext *m = avctx->priv_data;\n<55> if (read_major_sync(m, &gb) < 0)\n<203> for (substr = 0; substr <= m->max_decoded_substream; substr++) {\n<213> memset(m->filter_changed, 0, sizeof(m->filter_changed));\n<231> if (read_restart_header(m, &gb, buf, substr) < 0)\n<249> if (read_decoding_params(m, &gb, substr) < 0)\n<287> if (read_block_data(m, &gb, substr) < 0)\n<389> rematrix_channels(m, m->max_decoded_substream);\n<393> if (output_data(m, m->max_decoded_substream, data, data_size) < 0)
<1> static void mcf5208evb_init(QEMUMachineInitArgs *args)\n<35> if (!env) {\n<37> fprintf(stderr, "Unable to find m68k CPU definition\n");\n<91> if (nb_nics > 1) {\n<93> fprintf(stderr, "Too many NICs\n");\n<153> if (!kernel_filename) {\n<155> fprintf(stderr, "Kernel image must be specified\n");\n<163> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<171> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n<177> kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n<185> if (kernel_size < 0) {\n<187> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> static void opt_output_file(void *optctx, const char *filename)\n<19> if (!strcmp(filename, "-"))\n<21> filename = "pipe:";\n<29> print_error(filename, AVERROR(ENOMEM));\n<39> file_oformat = av_guess_format(last_asked_format, NULL, NULL);\n<41> if (!file_oformat) {\n<43> fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format);\n<53> file_oformat = av_guess_format(NULL, filename, NULL);\n<55> if (!file_oformat) {\n<57> fprintf(stderr, "Unable to find a suitable output format for '%s'\n",\n<71> av_strlcpy(oc->filename, filename, sizeof(oc->filename));\n<75> if (!strcmp(file_oformat->name, "ffm") &&\n<77> av_strstart(filename, "http:", NULL)) {\n<83> int err = read_avserver_streams(oc, filename);\n<85> if (err < 0) {\n<87> print_error(filename, err);\n<93> } else if (!o->nb_stream_maps) {\n<215> av_log(NULL, AV_LOG_ERROR, "Cannot map stream #%d.%d - unsupported type.\n",\n<283> if (!file_overwrite &&\n<285> (strchr(filename, ':') == NULL ||\n<287> filename[1] == ':' ||\n<289> av_strstart(filename, "file:", NULL))) {\n<291> if (avio_check(filename, 0) == 0) {\n<293> if (!using_stdin) {\n<295> fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", filename);\n<297> fflush(stderr);\n<299> if (!read_yesno()) {\n<301> fprintf(stderr, "Not overwriting - exiting\n");\n<311> fprintf(stderr,"File '%s' already exists. Exiting.\n", filename);\n<325> if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {\n<367> av_log(NULL, AV_LOG_ERROR, "Invalid input file index %d in chapter mapping.\n",\n<399> av_log(NULL, AV_LOG_ERROR, "Invalid %s index %d while processing metadata maps\n",\
<1> static int ram_load_postcopy(QEMUFile *f)\n<9> bool matching_page_sizes = qemu_host_page_size == TARGET_PAGE_SIZE;\n<29> void *page_buffer = NULL;\n<95> if (host != (last_host + TARGET_PAGE_SIZE)) {\n<121> place_needed = (((uintptr_t)host + TARGET_PAGE_SIZE) &\n<133> switch (flags & ~RAM_SAVE_FLAG_CONTINUE) {\n<137> ch = qemu_get_byte(f);\n<139> memset(page_buffer, ch, TARGET_PAGE_SIZE);\n<157> qemu_get_buffer(f, page_buffer, TARGET_PAGE_SIZE);\n<169> qemu_get_buffer_in_place(f, (uint8_t **)&place_source,\n<203> host + TARGET_PAGE_SIZE -\n<209> ret = postcopy_place_page(mis, host + TARGET_PAGE_SIZE -
<1> static void read_sbr_noise ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data , int ch ) {\n<33> memcpy ( ch_data -> noise_facs [ 0 ] , ch_data -> noise_facs [ ch_data -> bs_num_noise ] , sizeof ( ch_data -> noise_facs [ 0 ] ) ) ;
<1> static int transcode(OutputFile *output_files,\n<21> char error[1024];\n<35> if (!(no_packet = av_mallocz(nb_input_files)))\n<55> if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n<57> av_dump_format(os, i, os->filename, 1);\n<59> fprintf(stderr, "Output file #%d does not contain any stream\n", i);\n<83> codec = ost->st->codec;\n<85> icodec = ist->st->codec;\n<99> uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n<143> if (!codec->extradata) {\n<151> memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n<153> codec->extradata_size= icodec->extradata_size;\n<159> if(!strcmp(os->oformat->name, "avi")) {\n<161> if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > 2*av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0/500){\n<171> } else if(!(os->oformat->flags & AVFMT_VARIABLE_FPS)) {\n<193> if(audio_volume != 256) {\n<195> fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");\n<343> if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n<345> fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");\n<465> f = fopen(logfilename, "wb");\n<467> if (!f) {\n<469> fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));\n<483> if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n<485> fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);\n<505> bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n<515> bit_buffer = av_malloc(bit_buffer_size);\n<517> if (!bit_buffer) {\n<519> fprintf(stderr, "Cannot allocate %d bytes output buffer\n",\n<541> AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n<543> if (!codec) {\n<545> snprintf(error, sizeof(error), "Encoder (codec %s) not found for output stream #%d.%d",\n<557> ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n<559> if (!ost->st->codec->subtitle_header) {\n<567> memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<569> ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n<573> if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n<575> snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",\n<585> assert_codec_experimental(ost->st->codec, 1);\n<607> if ((ret = init_input_stream(i, output_streams, nb_output_streams, error, sizeof(error)) < 0))\n<619> if (avformat_write_header(os, &output_files[i].opts) < 0) {\n<621> snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);\n<631> if (strcmp(os->oformat->name, "rtp")) {\n<633> want_sdp = 0;\n<657> if (verbose >= 0) {\n<659> fprintf(stderr, "Stream mapping:\n");\n<661> for (i = 0; i < nb_output_streams;i ++) {\n<663> ost = &output_streams[i];\n<675> if (ost->sync_ist != &input_streams[ost->source_index])\n<683> if(ost->encoding_needed)\n<695> fprintf(stderr, ": copy");\n<697> fprintf(stderr, "\n");\n<705> if (ret) {\n<707> fprintf(stderr, "%s\n", error);\n<725> if(verbose >= 0)\n<727> fprintf(stderr, "Press [q] to stop, [?] for help\n");\n<799> if (key == 'c' || key == 'C'){\n<801> char ret[4096], target[64], cmd[256], arg[256]={0};\n<805> fprintf(stderr, "\nEnter command: <target> <time> <command>[ <argument>]\n");\n<807> if(scanf("%4095[^\n\r]%*c", ret) == 1 && sscanf(ret, "%63[^ ] %lf %255[^ ] %255[^\n]", target, &ts, cmd, arg) >= 3){\n<809> for(i=0;i<nb_output_streams;i++) {\n<817> if(ts<0){\n<819> r= avfilter_graph_send_command(ost->graph, target, cmd, arg, ret, sizeof(ret), key == 'c' ? AVFILTER_CMD_FLAG_ONE : 0);\n<821> fprintf(stderr, "Command reply for %d: %d, %s\n", i, r, ret);\n<825> r= avfilter_graph_queue_command(ost->graph, target, cmd, arg, 0, ts);\n<835> fprintf(stderr, "Parse error\n");\n<841> if (key == 'd' || key == 'D'){\n<843> int debug=0;\n<845> if(key == 'D') {\n<849> if(!debug) debug = 1;\n<851> while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n<853> debug += debug;\n<857> scanf("%d", &debug);\n<861> input_streams[i].st->codec->debug = debug;\n<869> ost->st->codec->debug = debug;\n<875> fprintf(stderr,"debug=%d\n", debug);\n<879> if (key == '?'){\n<927> ist = &input_streams[ost->source_index];\n<929> if (ost->is_past_recording_time || no_packet[ist->file_index] ||\n<945> if(input_sync ) file_index = ist->file_index;\n<953> if(!input_sync) file_index = ist->file_index;\n<973> if(no_packet_count){\n<977> memset(no_packet, 0, nb_input_files);\n<999> no_packet[file_index]=1;\n<1007> if (ret < 0) {\n<1025> memset(no_packet, 0, nb_input_files);\n<1119> if (output_packet(ist, ist_index, output_streams, nb_output_streams, &pkt) < 0) {\n<1123> if (verbose >= 0)\n<1125> fprintf(stderr, "Error while decoding stream #%d.%d\n",\n<1163> output_packet(ist, i, output_streams, nb_output_streams, NULL);\n<1205> avcodec_close(ost->st->codec);\n<1245> av_freep(&no_packet);\n<1273> av_freep(&ost->st->codec->subtitle_header);
<1> static uint64_t arm_sysctl_read(void *opaque, target_phys_addr_t offset,\n<11> switch (offset) {\n<153> if (board_id(s) != BOARD_ID_VEXPRESS) {\n<163> if (board_id(s) != BOARD_ID_VEXPRESS) {\n<173> if (board_id(s) != BOARD_ID_VEXPRESS) {\n<185> printf ("arm_sysctl_read: Bad register offset 0x%x\n", (int)offset);
<1> static void validate_bootdevices(char *devices)\n<33> if (*p < 'a' || *p > 'p') {\n<35> fprintf(stderr, "Invalid boot device '%c'\n", *p);\n<41> if (bitmap & (1 << (*p - 'a'))) {\n<43> fprintf(stderr, "Boot device '%c' was given twice\n", *p);\n<49> bitmap |= 1 << (*p - 'a');
<1> int av_image_fill_pointers ( uint8_t * data [ 4 ] , enum PixelFormat pix_fmt , int height , uint8_t * ptr , const int linesizes [ 4 ] ) {\n<4> memset ( data , 0 , sizeof ( data [ 0 ] ) * 4 ) ;\n<5> memset ( size , 0 , sizeof ( size ) ) ;\n<6> memset ( has_plane , 0 , sizeof ( has_plane ) ) ;\n<12> size [ 0 ] = ( size [ 0 ] + 3 ) & ~ 3 ;\n<13> data [ 1 ] = ptr + size [ 0 ] ;\n<14> return size [ 0 ] + 256 * 4 ;\n<19> total_size = size [ 0 ] ;\n<21> has_plane [ i ] && i < 4 ;\n<24> data [ i ] = data [ i - 1 ] + size [ i - 1 ] ;\n<28> if ( total_size > INT_MAX - size [ i ] ) return AVERROR ( EINVAL ) ;\n<29> total_size += size [ i ] ;
<1> static int ffm_read_data(AVFormatContext *s,\n<3> uint8_t *buf, int size, int first)\n<7> FFMContext *ffm = s->priv_data;\n<21> len = ffm->packet_end - ffm->packet_ptr;\n<31> if (len == 0) {\n<103> memcpy(buf, ffm->packet_ptr, len);\n<105> buf += len;\n<107> ffm->packet_ptr += len;\n<109> size -= len;
<1> static ssize_t usbnet_receive(VLANClientState *nc, const uint8_t *buf, size_t size)\n<5> USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n<13> msg = (struct rndis_packet_msg_type *) s->in_buf;\n<19> if (size + sizeof(struct rndis_packet_msg_type) > sizeof(s->in_buf))\n<25> memset(msg, 0, sizeof(struct rndis_packet_msg_type));\n<27> msg->MessageType = cpu_to_le32(RNDIS_PACKET_MSG);\n<29> msg->MessageLength = cpu_to_le32(size + sizeof(struct rndis_packet_msg_type));\n<31> msg->DataOffset = cpu_to_le32(sizeof(struct rndis_packet_msg_type) - 8);\n<33> msg->DataLength = cpu_to_le32(size);\n<51> memcpy(msg + 1, buf, size);\n<53> s->in_len = size + sizeof(struct rndis_packet_msg_type);\n<57> if (size > sizeof(s->in_buf))\n<61> memcpy(s->in_buf, buf, size);\n<63> s->in_len = size;\n<69> return size;
<1> int av_grab(AVFormatContext *s)\n<21> AVCodecContext *enc, *first_video_enc = NULL;\n<33> UINT8 *picture_in_buf = NULL, *picture_420p = NULL;\n<59> ost->index = i;\n<61> ost->st = s->streams[i];\n<85> frame_number = 0;\n<101> if (!codec) {\n<103> fprintf(stderr, "Unknown codec\n");\n<109> if (avcodec_open(enc, codec) < 0) {\n<111> fprintf(stderr, "Incorrect encode parameters\n");\n<139> if (!first_video_enc)\n<141> first_video_enc = enc;\n<175> if (ret < 0) {\n<177> fprintf(stderr, "Could not open audio device: disabling audio capture\n");\n<187> if (url_getformat(audio_handle, &f) < 0) {\n<189> fprintf(stderr, "could not read back video grab parameters\n");\n<195> sample_rate = f.sample_rate;\n<203> fprintf(stderr, "Audio sampling: %d Hz, %s\n",\n<225> if (ret < 0) {\n<227> fprintf(stderr,"Could not init video 4 linux capture: disabling video capture\n");\n<239> if (url_getformat(video_handle, &f) < 0) {\n<241> fprintf(stderr, "could not read back video grab parameters\n");\n<247> width = f.width;\n<249> height = f.height;\n<257> pix_fmt_str = "420P";\n<263> pix_fmt_str = "422";\n<269> pix_fmt_str = "RGB24";\n<275> pix_fmt_str = "BGR24";\n<281> pix_fmt_str = "???";\n<287> picture_size = video_handle->packet_size;\n<289> picture_in_buf = malloc(picture_size);\n<291> if (!picture_in_buf)\n<297> if (pix_fmt != PIX_FMT_YUV420P) {\n<299> picture_420p = malloc((width * height * 3) / 2);\n<303> fprintf(stderr, "Video sampling: %dx%d, %s format, %0.2f fps\n",\n<305> width, height, pix_fmt_str, (float)frame_rate / FRAME_RATE_BASE);\n<313> if (!use_video && !use_audio) {\n<315> fprintf(stderr,"Could not open grab devices : exiting\n");\n<325> for(i=0;i<s->nb_streams;i++) {\n<327> ost = ost_table[i];\n<335> ost->audio_resample = 0;\n<339> enc->sample_rate != sample_rate)) {\n<341> ost->audio_resample = 1;\n<343> ost->resample = audio_resample_init(enc->channels, channels,\n<349> if (fifo_init(&ost->fifo, (2 * audio_fifo_size * enc->sample_rate *\n<359> ost->video_resample = 0;\n<361> if (enc->width != width ||\n<363> enc->height != height) {\n<367> ost->video_resample = 1;\n<369> buf = malloc((enc->width * enc->height * 3) / 2);\n<371> if (!buf)\n<375> ost->pict_tmp.data[0] = buf;\n<377> ost->pict_tmp.data[1] = buf + enc->width * height;\n<401> fprintf(stderr, "Press [q] to stop encoding\n");\n<451> ost = ost_table[i];\n<459> if (!ost->audio_resample) {\n<477> fifo_write(&ost->fifo, buftmp, nb_samples_out * enc->channels * 2,\n<491> ost = ost_table[i];\n<511> s->format->write_packet(s, ost->index, audio_out, ret);\n<533> ret = url_read(video_handle, picture_in_buf, picture_size);\n<543> avpicture_fill(picture2, picture_in_buf, pix_fmt, width, height);\n<571> ost = ost_table[i];\n<583> n1 = ((INT64)frame_number * enc->frame_rate) / frame_rate;\n<585> n2 = (((INT64)frame_number + 1) * enc->frame_rate) / frame_rate;\n<613> s->format->write_packet(s, ost->index, video_buffer, ret);\n<621> frame_number++;\n<631> char buf[1024];\n<663> if ((ti - last_ti) >= 0.5) {\n<667> bitrate = (int)((total_size * 8) / ti / 1000.0);\n<671> buf[0] = '\0';\n<673> if (use_video) {\n<675> sprintf(buf + strlen(buf), "frame=%5d fps=%4.1f q=%2d ",\n<677> frame_number, (float)frame_number / ti, first_video_enc->quality);\n<683> sprintf(buf + strlen(buf), "size=%8LdkB time=%0.1f bitrate=%6.1fkbits/s",\n<685> total_size / 1024, ti, bitrate);\n<687> fprintf(stderr, "%s    \r", buf);\n<689> fflush(stderr);\n<747> bitrate = (int)((total_size * 8) / ti / 1000.0);\n<751> fprintf(stderr, "\033[K\nTotal time = %0.1f s, %Ld KBytes, %0.1f kbits/s\n",\n<753> ti, total_size / 1024, bitrate);\n<755> if (use_video) {\n<757> fprintf(stderr, "Total frames = %d\n", frame_number);\n<769> if (picture_in_buf)\n<771> free(picture_in_buf);\n<773> if (picture_420p)\n<775> free(picture_420p);\n<779> ost = ost_table[i];\n<781> if (ost) {\n<785> fifo_free(&ost->fifo);\n<787> if (ost->pict_tmp.data[0])\n<789> free(ost->pict_tmp.data[0]);\n<793> img_resample_close(ost->img_resample_ctx);\n<797> audio_resample_close(ost->resample);\n<799> free(ost);
<1> static int qemu_rbd_set_conf(rados_t cluster, const char *conf,\n<27> while (p) {\n<39> qemu_rbd_unescape(name);\n<59> if (local_err) {\n<69> if (strcmp(name, "conf") == 0) {\n<75> if (only_read_conf_file) {\n<91> } else if (strcmp(name, "id") == 0) {\n<95> } else if (!only_read_conf_file) {\n<97> ret = rados_conf_set(cluster, name, value);
<1> int qemu_savevm_state_complete(QEMUFile *f)\n<31> TAILQ_FOREACH(se, &savevm_handlers, entry) {\n<53> len = strlen(se->idstr);\n<55> qemu_put_byte(f, len);\n<57> qemu_put_buffer(f, (uint8_t *)se->idstr, len);\n<67> vmstate_save(f, se);
<1> static int vmdk_probe(const uint8_t *buf, int buf_size, const char *filename)\n<45> if (*p == ' ') {\n<75> if (end - p >= strlen("version=X\n")) {\n<77> if (strncmp("version=1\n", p, strlen("version=1\n")) == 0 ||\n<79> strncmp("version=2\n", p, strlen("version=2\n")) == 0) {\n<81> return 100;\n<87> if (end - p >= strlen("version=X\r\n")) {\n<89> if (strncmp("version=1\r\n", p, strlen("version=1\r\n")) == 0 ||\n<91> strncmp("version=2\r\n", p, strlen("version=2\r\n")) == 0) {\n<93> return 100;\n<99> return 0;
<1> int ff_h263_decode_frame(AVCodecContext *avctx,\n<5> uint8_t *buf, int buf_size)\n<71> next= ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);\n<75> next= h263_find_frame_end(&s->parse_context, buf, buf_size);\n<87> if( ff_combine_frame(&s->parse_context, next, &buf, &buf_size) < 0 )\n<107> init_get_bits(&s->gb, buf, buf_size*8);\n<571> decode_slice(s);\n<583> if(ff_h263_resync(s)<0)\n<597> decode_slice(s);\n<605> if(msmpeg4_decode_ext_header(s, buf_size) < 0){\n<623> if(   buf_size - current_pos > 5\n<625> && buf_size - current_pos < BITSTREAM_BUFFER_SIZE){\n<631> if(buf[i]==0 && buf[i+1]==0 && buf[i+2]==1 && buf[i+3]==0xB6){\n<643> if(s->gb.buffer == s->bitstream_buffer && buf_size>20){ //xvid style\n<647> current_pos=0;\n<653> if(startcode_found){\n<655> memcpy(s->bitstream_buffer, buf + current_pos, buf_size - current_pos);\n<665> ff_er_frame_end(s);\n<669> MPV_frame_end(s);\n<681> ff_print_debug_info(s, pict);\n<689> ff_print_debug_info(s, pict);\n<717> return get_consumed_bytes(s, buf_size);
<1> static int write_manifest(AVFormatContext *s, int final)\n<13> const char *proto = avio_find_protocol_name(s->filename);\n<15> int use_rename = proto && !strcmp(proto, "file");\n<23> if (!use_rename && !warned_non_file++)
<1> int img_convert(AVPicture *dst, int dst_pix_fmt,\n<141> w >>= dst_pix->x_chroma_shift;\n<147> d = dst->data[i];\n<149> for(y = 0; y< h; y++) {\n<151> memset(d, 128, w);\n<153> d += dst->linesize[i];
<1> static int load_input_picture ( MpegEncContext * s , const AVFrame * pic_arg ) {\n<73> int w = s -> width >> h_shift ;\n<75> uint8_t * src = pic_arg -> data [ i ] ;\n<76> uint8_t * dst = pic -> data [ i ] ;\n<77> if ( ! s -> avctx -> rc_buffer_size ) dst += INPLACE_OFFSET ;\n<78> if ( src_stride == dst_stride ) memcpy ( dst , src , src_stride * h ) ;\n<80> while ( h -- ) {\n<81> memcpy ( dst , src , w ) ;\n<82> dst += dst_stride ;\n<83> src += src_stride ;
<22> buf += 4 ;\n<23> if ( header_size == 8 ) buf += 4 ;\n<25> if ( avctx -> pix_fmt != pix_fmt && f -> data [ 0 ] ) {\n<82> y < avctx -> height ;\n<83> y ++ ) memcpy ( & f -> data [ 0 ] [ ( avctx -> height - y - 1 ) * f -> linesize [ 0 ] ] , & buf [ y * avctx -> width * 3 ] , 3 * avctx -> width ) ;
<1> static void alpha_translate_init(void)\n<23> p = cpu_reg_names;\n<25> for (i = 0; i < 31; i++) {\n<27> sprintf(p, "ir%d", i);\n<33> p += (i < 10) ? 4 : 5;\n<37> sprintf(p, "fir%d", i);\n<43> p += (i < 10) ? 5 : 6;
<1> static CURLcode glob_range ( URLGlob * glob , char * * patternp , size_t * posp , unsigned long * amount , int globindex ) {\n<4> char * pattern = * patternp ;\n<8> if ( ISALPHA ( * pattern ) ) {\n<13> rc = sscanf ( pattern , "%c-%c" , & min_c , & max_c ) ;\n<14> if ( ( rc == 2 ) && ( pattern [ 3 ] == ':' ) ) {\n<18> lstep = strtoul ( & pattern [ 4 ] , & endp , 10 ) ;\n<23> if ( step > ( max_c - min_c ) ) step = - 1 ;\n<26> else pattern += 4 ;\n<27> * posp += ( pattern - * patternp ) ;\n<28> if ( ( rc != 2 ) || ( min_c >= max_c ) || ( ( max_c - min_c ) > ( 'z' - 'a' ) ) || ( step <= 0 ) ) return GLOBERROR ( "bad range" , * posp , CURLE_URL_MALFORMAT ) ;\n<30> pat -> content . CharRange . ptr_c = pat -> content . CharRange . min_c = min_c ;\n<31> pat -> content . CharRange . max_c = max_c ;\n<78> * patternp = pattern ;
<1> void do_commit(Monitor *mon, const QDict *qdict)\n<5> const char *device = qdict_get_str(qdict, "device");\n<11> if (!strcmp(device, "all")) {\n<13> bdrv_commit_all();\n<17> bs = bdrv_find(device);\n<19> if (!bs) {
<1> static void copy_context_before_encode(MpegEncContext *d, MpegEncContext *s, int type){\n<7> memcpy(d->last_mv, s->last_mv, 2*2*2*sizeof(int)); //FIXME is memcpy faster then a loop?
<1> static void lm32_uclinux_init(MachineState *machine)\n<9> const char *kernel_cmdline = machine->kernel_cmdline;\n<81> cpu = cpu_lm32_init(cpu_model);\n<83> if (cpu == NULL) {\n<85> fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model);\n<169> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<189> if (kernel_size < 0) {\n<191> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<233> if (kernel_cmdline && strlen(kernel_cmdline)) {\n<235> pstrcpy_targphys("cmdline", cmdline_base, TARGET_PAGE_SIZE,\n<239> reset_info->cmdline_base = cmdline_base;
<1> void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n<51> for (i = 0; samplesref->data[i]; i++)\n<53> memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);
<1> static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)\n<5> ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);\n<7> ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);\n<9> ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;\n<11> ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;\n<23> assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, "_EJ0", 4));\n<27> if (!eject) {\n<29> memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, "EJ0_", 4);
<1> tight_filter_gradient24(VncState *vs, uint8_t *buf, int w, int h)\n<23> memset(vs->tight_gradient.buffer, 0, w * 3 * sizeof(int));\n<59> prev = (int *)vs->tight_gradient.buffer;
<1> void smbios_add_field(int type, int offset, const void *data, size_t len)\n<25> field = (struct smbios_field *)(smbios_entries + smbios_entries_len);\n<37> memcpy(field->data, data, len);\n<41> smbios_entries_len += sizeof(*field) + len;
<1> int ram_save_live(Monitor *mon, QEMUFile *f, int stage, void *opaque)\n<35> if (stage == 1) {\n<77> qemu_put_be64(f, ram_bytes_total() | RAM_SAVE_FLAG_MEM_SIZE);\n<81> QLIST_FOREACH(block, &ram_list.blocks, next) {\n<83> qemu_put_byte(f, strlen(block->idstr));\n<85> qemu_put_buffer(f, (uint8_t *)block->idstr, strlen(block->idstr));
<1> build_hash_table (const sparc_opcode **opcode_table,\n<3> sparc_opcode_hash **hash_table,\n<11> int hash_count[HASH_SIZE];\n<23> memset (hash_table, 0, HASH_SIZE * sizeof (hash_table[0]));\n<25> memset (hash_count, 0, HASH_SIZE * sizeof (hash_count[0]));\n<27> if (hash_buf != NULL)\n<29> free (hash_buf);\n<31> hash_buf = malloc (sizeof (* hash_buf) * num_opcodes);\n<39> sparc_opcode_hash *h = &hash_buf[i];\n<43> h->next = hash_table[hash];\n<49> ++hash_count[hash];
<1> static int decode_frame_byterun1(AVCodecContext *avctx,\n<9> IffContext *s = avctx->priv_data;\n<21> if (avctx->reget_buffer(avctx, &s->frame) < 0){\n<33> uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n<35> if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved\n<37> memset(row, 0, avctx->pix_fmt == PIX_FMT_PAL8 ? avctx->width : (avctx->width * 4));\n<41> for(x = 0; x < s->planesize && buf < buf_end; ) {\n<47> if (value >= 0) {\n<51> memcpy(s->planebuf + x, buf, FFMIN3(length, s->planesize - x, buf_end - buf));\n<53> buf += length;\n<55> } else if (value > -128) {\n<59> memset(s->planebuf + x, *buf++, FFMIN(length, s->planesize - x));\n<73> decodeplane8(row, s->planebuf, s->planesize, avctx->bits_per_coded_sample, plane);\n<77> decodeplane32((uint32_t *) row, s->planebuf, s->planesize, avctx->bits_per_coded_sample, plane);\n<85> for(x = 0; x < avctx->width && buf < buf_end; ) {\n<91> if (value >= 0) {\n<95> memcpy(row + x, buf, FFMIN3(length, buf_end - buf, avctx->width - x));\n<97> buf += length;\n<99> } else if (value > -128) {\n<103> memset(row + x, *buf++, FFMIN(length, avctx->width - x));
<1> void qemu_chr_fe_printf(CharDriverState *s, const char *fmt, ...)\n<9> va_start(ap, fmt);\n<11> vsnprintf(buf, sizeof(buf), fmt, ap);\n<13> qemu_chr_fe_write(s, (uint8_t *)buf, strlen(buf));\n<15> va_end(ap);
<1> static void opt_format(const char *arg)\n<7> if (!strcmp(arg, "pgmyuv")) {\n<9> opt_image_format(arg);\n<11> arg = "image";\n<17> file_iformat = av_find_input_format(arg);\n<19> file_oformat = guess_format(arg, NULL, NULL);\n<21> if (!file_iformat && !file_oformat) {\n<23> fprintf(stderr, "Unknown input or output format: %s\n", arg);
<1> static int sbr_x_gen ( SpectralBandReplication * sbr , float X [ 2 ] [ 38 ] [ 64 ] , const float Y0 [ 38 ] [ 64 ] [ 2 ] , const float Y1 [ 38 ] [ 64 ] [ 2 ] , const float X_low [ 32 ] [ 40 ] [ 2 ] , int ch ) {\n<5> memset ( X , 0 , 2 * sizeof ( * X ) ) ;
<1> static int ass_get_duration(const uint8_t *p)\n<11> if (sscanf(p, "%*[^,],%d:%d:%d%*c%d,%d:%d:%d%*c%d",\n<15> return 0;\n<17> start = 3600000 * sh + 60000 * sm + 1000 * ss + 10 * sc;\n<19> end   = 3600000 * eh + 60000 * em + 1000 * es + 10 * ec;\n<21> return end - start;
<1> static void av_estimate_timings_from_pts(AVFormatContext *ic)\n<75> start_time = MAXINT64;\n<83> st->start_time < start_time)\n<85> start_time = st->start_time;\n<89> fprintf(stderr, "start=%lld\n", start_time);\n<91> if (start_time != MAXINT64)
<1> static inline int dmg_read_chunk(BDRVDMGState *s,int sector_num)\n<9> uint32_t chunk = search_chunk(s,sector_num);\n<21> switch(s->types[chunk]) {\n<93> memset(s->uncompressed_chunk, 0, 512*s->sectorcounts[chunk]);
<1> static void arm_cpu_reset(CPUState *s)\n<9> CPUARMState *env = &cpu->env;\n<17> memset(env, 0, offsetof(CPUARMState, end_reset_fields));\n<43> if (arm_feature(env, ARM_FEATURE_IWMMXT)) {\n<241> if (arm_feature(env, ARM_FEATURE_V8)) {\n<255> if (arm_feature(env, ARM_FEATURE_M_SECURITY)) {\n<271> } else if (arm_feature(env, ARM_FEATURE_V7)) {\n<275> sizeof(*env->pmsav7.drbar) * cpu->pmsav7_dregion);\n<279> sizeof(*env->pmsav7.drsr) * cpu->pmsav7_dregion);\n<283> sizeof(*env->pmsav7.dracr) * cpu->pmsav7_dregion);
<1> void clear_blocks_dcbz128_ppc(DCTELEM *blocks)\n<15> if (misal) {\n<23> memset(blocks, 0, sizeof(DCTELEM)*6*64);
<1> int main ( int argc , char * * argv ) {\n<6> if ( argc == 2 && ! strcmp ( argv [ 1 ] , "--to-str" ) ) {\n<7> fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n<8> if ( ! feof ( stdin ) ) fail ( "read error or input too large" ) ;\n<9> fail ( "no yet implemented" ) ;\n<11> else if ( argc == 2 && ! strcmp ( argv [ 1 ] , "--to-der" ) ) {\n<12> fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n<13> if ( ! feof ( stdin ) ) fail ( "read error or input too large" ) ;\n<14> err = ksba_dn_str2der ( inputbuf , & buf , & len ) ;\n<15> fail_if_err ( err ) ;\n<16> fwrite ( buf , len , 1 , stdout ) ;\n<18> else if ( argc == 1 ) {\n<24> fprintf ( stderr , "usage: t-dnparser [--to-str|--to-der]\n" ) ;\n<27> return 0 ;
<1> static void test_acpi_piix4_tcg_cphp(void)\n<9> memset(&data, 0, sizeof(data));\n<15> test_acpi_one("-smp 2,cores=3,sockets=2,maxcpus=6"\n<21> free_test_data(&data);
<108> if ( oldpic -> data [ 1 ] ) memcpy ( newpic -> data [ 1 ] , oldpic -> data [ 1 ] , 256 * 4 ) ;
<1> static int _evdns_nameserver_add_impl ( unsigned long int address , int port ) {\n<5> if ( server ) {\n<10> while ( server != started_at ) ;\n<12> ns = ( struct nameserver * ) malloc ( sizeof ( struct nameserver ) ) ;\n<13> if ( ! ns ) return - 1 ;\n<14> memset ( ns , 0 , sizeof ( struct nameserver ) ) ;\n<15> evtimer_set ( & ns -> timeout_event , nameserver_prod_callback , ns ) ;\n<17> if ( ns -> socket < 0 ) {\n<22> ns -> address = address ;\n<23> ns -> port = htons ( port ) ;\n<24> ns -> state = 1 ;\n<25> event_set ( & ns -> event , ns -> socket , EV_READ | EV_PERSIST , nameserver_ready_callback , ns ) ;\n<26> if ( event_add ( & ns -> event , NULL ) < 0 ) {\n<32> ns -> next = ns -> prev = ns ;\n<33> server_head = ns ;\n<38> server_head -> next = ns ;\n<40> server_head -> prev = ns ;\n<45> out2 : CLOSE_SOCKET ( ns -> socket ) ;\n<46> out1 : free ( ns ) ;
<1> static int transcode(AVFormatContext **output_files,\n<25> char error[1024];\n<101> ist->file_index = i;\n<103> ist->index = k;\n<131> if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n<133> av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n<135> fprintf(stderr, "Output file #%d does not contain any stream\n", i);\n<147> if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n<149> fprintf(stderr, "Number of stream maps must match number of output streams\n");\n<165> int si = stream_maps[i].stream_index;\n<169> if (fi < 0 || fi > nb_input_files - 1 ||\n<171> si < 0 || si > file_table[fi].nb_streams - 1) {\n<173> fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si);\n<183> si = stream_maps[i].sync_stream_index;\n<185> if (fi < 0 || fi > nb_input_files - 1 ||\n<187> si < 0 || si > file_table[fi].nb_streams - 1) {\n<189> fprintf(stderr,"Could not find sync stream #%d.%d\n", fi, si);\n<291> ost = ost_table[n] = output_streams_for_file[k][i];\n<305> if (ist_table[ost->source_index]->st->codec->codec_type != ost->st->codec->codec_type) {\n<307> int i= ost->file_index;\n<311> fprintf(stderr, "Codec type mismatch for mapping #%d.%d -> #%d.%d\n",\n<403> if (!found) {\n<405> int i= ost->file_index;\n<409> fprintf(stderr, "Could not find input stream matching output stream #%d.%d\n",\n<449> codec = ost->st->codec;\n<451> icodec = ist->st->codec;\n<473> uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n<513> if (!codec->extradata)\n<517> memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n<519> codec->extradata_size= icodec->extradata_size;\n<539> if(audio_volume != 256) {\n<541> fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");\n<645> if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n<647> fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");\n<665> if(avpicture_alloc((AVPicture*)&ost->pict_tmp, codec->pix_fmt,\n<669> fprintf(stderr, "Cannot allocate temp picture, check pix fmt\n");\n<693> if (ost->img_resample_ctx == NULL) {\n<695> fprintf(stderr, "Cannot get resampling context\n");\n<769> f = fopen(logfilename, "wb");\n<771> if (!f) {\n<773> fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));\n<787> if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n<789> fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);\n<809> bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n<819> bit_buffer = av_malloc(bit_buffer_size);\n<821> if (!bit_buffer) {\n<823> fprintf(stderr, "Cannot allocate %d bytes output buffer\n",\n<845> AVCodecContext *dec = ist_table[ost->source_index]->st->codec;\n<847> if (!codec)\n<851> if (!codec) {\n<853> snprintf(error, sizeof(error), "Encoder (codec id %d) not found for output stream #%d.%d",\n<865> ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n<867> if (!ost->st->codec->subtitle_header) {\n<875> memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<877> ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n<881> if (avcodec_open(ost->st->codec, codec) < 0) {\n<883> snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",\n<911> if (!codec)\n<915> if (!codec) {\n<917> snprintf(error, sizeof(error), "Decoder (codec id %d) not found for input stream #%d.%d",\n<927> if (avcodec_open(ist->st->codec, codec) < 0) {\n<929> snprintf(error, sizeof(error), "Error while opening decoder for input stream #%d.%d",\n<985> snprintf(error, sizeof(error), "Invalid %s index %d while processing metadata maps\n",\\n<1099> snprintf(error, sizeof(error), "Invalid input file index %d in chapter mapping.\n", infile);\n<1109> snprintf(error, sizeof(error), "Invalid output file index %d in chapter mapping.\n",outfile);\n<1153> if (av_write_header(os) < 0) {\n<1155> snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);\n<1163> if (strcmp(output_files[i]->oformat->name, "rtp")) {\n<1165> want_sdp = 0;\n<1189> if (verbose >= 0) {\n<1191> fprintf(stderr, "Stream mapping:\n");\n<1193> for(i=0;i<nb_ostreams;i++) {\n<1195> ost = ost_table[i];\n<1207> if (ost->sync_ist != ist_table[ost->source_index])\n<1215> fprintf(stderr, "\n");\n<1223> if (ret) {\n<1225> fprintf(stderr, "%s\n", error);\n<1243> if(verbose >= 0)\n<1245> fprintf(stderr, "Press [q] to stop encoding\n");\n<1311> ist = ist_table[ost->source_index];\n<1313> if(ist->is_past_recording_time || no_packet[ist->file_index])\n<1327> if(input_sync ) file_index = ist->file_index;\n<1335> if(!input_sync) file_index = ist->file_index;\n<1355> if(no_packet_count){\n<1359> memset(no_packet, 0, sizeof(no_packet));\n<1389> no_packet[file_index]=1;\n<1397> if (ret < 0) {\n<1415> memset(no_packet, 0, sizeof(no_packet));\n<1517> if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n<1521> if (verbose >= 0)\n<1523> fprintf(stderr, "Error while decoding stream #%d.%d\n",\n<1561> output_packet(ist, i, ost_table, nb_ostreams, NULL);\n<1601> avcodec_close(ost->st->codec);\n<1651> av_free(ist);\n<1655> av_free(ist_table);\n<1683> av_freep(&ost->st->codec->subtitle_header);\n<1701> av_free(ost);
<1> int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n<33> qdevs[num++] = kid->child;\n<41> qsort(qdevs, num, sizeof(qdev), compare_reg);\n<73> free(qdevs);
<1> int ff_dirac_golomb_read_32bit(DiracGolombLUT *lut_ctx, const uint8_t *buf,\n<9> int32_t *dst = (int32_t *)_dst;\n<11> DiracGolombLUT *future[4], *l = &lut_ctx[2*LUT_SIZE + buf[0]];\n<29> if ((c_idx + 1) > coeffs)\n<59> memcpy(&dst[c_idx], l->ready, LUT_BITS*sizeof(int32_t));\n<69> l = future[l->need_s ? 3 : !res_bits ? 2 : res_bits & 1];
<1> int kvm_set_signal_mask(CPUState *cpu, const sigset_t *sigset)\n<11> if (!sigset) {\n<19> sigmask = g_malloc(sizeof(*sigmask) + sizeof(*sigset));\n<25> memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n<27> r = kvm_vcpu_ioctl(cpu, KVM_SET_SIGNAL_MASK, sigmask);\n<29> g_free(sigmask);
<1> int main ( int argc , char * * argv ) {\n<7> if ( argc ) {\n<12> argc -- , argv ++ ) {\n<13> err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n<14> if ( err ) {\n<15> fprintf ( stderr , "can't convert `%s': %s\n" , * argv , gpg_strerror ( err ) ) ;\n<18> printf ( "%s ->" , * argv ) ;\n<20> n < buflen ;\n<21> n ++ ) printf ( " %02X" , buffer [ n ] ) ;\n<23> free ( buffer ) ;\n<31> result = ksba_oid_to_str ( buffer , buflen ) ;\n<32> free ( buffer ) ;\n<33> printf ( "%s\n" , result ? result : "[malloc failed]" ) ;\n<34> free ( result ) ;
<1> build_rsdp(GArray *rsdp_table, BIOSLinker *linker, unsigned rsdt_tbl_offset)\n<5> AcpiRsdpDescriptor *rsdp = acpi_data_push(rsdp_table, sizeof *rsdp);\n<21> memcpy(&rsdp->signature, "RSD PTR ", sizeof(rsdp->signature));\n<23> memcpy(rsdp->oem_id, ACPI_BUILD_APPNAME6, sizeof(rsdp->oem_id));\n<45> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
<1> static int configure_accelerator(MachineClass *mc)\n<37> p = get_opt_name(buf, sizeof (buf), p, ':');\n<39> for (i = 0; i < ARRAY_SIZE(accel_list); i++) {\n<41> if (strcmp(accel_list[i].opt_name, buf) == 0) {\n<43> if (!accel_list[i].available()) {\n<57> if (ret < 0) {\n<61> fprintf(stderr, "failed to initialize %s: %s\n",\n<65> strerror(-ret));\n<81> if (i == ARRAY_SIZE(accel_list)) {\n<83> fprintf(stderr, "\"%s\" accelerator does not exist.\n", buf);\n<93> if (!init_failed) {\n<95> fprintf(stderr, "No accelerator found!\n");\n<105> if (init_failed) {\n<107> fprintf(stderr, "Back to %s accelerator.\n", accel_list[i].name);
<1> static void do_eject(int argc, const char **argv)\n<15> if (!*parg) {\n<27> if (!strcmp(*parg, "-f")) {\n<29> force = 1;\n<31> parg++;\n<35> if (!*parg)
<1> S390CPU *cpu_s390x_create(const char *cpu_model, Error **errp)\n<17> name = g_strdup(cpu_model);\n<19> features = strchr(name, ',');\n<25> features++;\n<31> oc = cpu_class_by_name(TYPE_S390_CPU, name);\n<53> cc->parse_features(typename, features, errp);
<1> static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) {\n<2> size_t Data_Buf_Size = 1024 ;\n<3> char Buf [ 1024 ] ;\n<29> while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) {\n<30> num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ;\n<32> if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) {\n<48> UpnpPrintf ( UPNP_INFO , HTTP , __FILE__ , __LINE__ , "<<< (RECVD) <<<\n%s\n-----------------\n" , parser -> msg . msg . buf ) ;\n<64> Data_Buf_Size = parser -> msg . entity . length - entity_offset ;\n<66> memcpy ( Buf , & parser -> msg . msg . buf [ parser -> entity_start_position + entity_offset ] , Data_Buf_Size ) ;\n<67> entity_offset += Data_Buf_Size ;\n<69> int n = virtualDirCallback . write ( Fp , Buf , Data_Buf_Size ) ;\n<76> size_t n = fwrite ( Buf , 1 , Data_Buf_Size , Fp ) ;\n<77> if ( n != Data_Buf_Size ) {
<1> gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n<23> if (search_pc && loglevel)\n<25> fprintf (logfile, "search pc %d\n", search_pc);
<1> static int rv10_decode_packet(AVCodecContext *avctx,\n<17> mb_count = rv10_decode_picture_header(s);\n<19> if (mb_count < 0) {\n<21> fprintf(stderr, "HEADER ERROR\n");\n<29> if (s->mb_x >= s->mb_width ||\n<31> s->mb_y >= s->mb_height) {\n<33> fprintf(stderr, "POS ERROR %d %d\n", s->mb_x, s->mb_y);\n<43> if (mb_count > left) {\n<45> fprintf(stderr, "COUNT ERROR\n");\n<53> if (s->mb_x == 0 && s->mb_y == 0) {\n<85> if(s->mb_y==0) s->first_slice_line=1;\n<123> if (ff_h263_decode_mb(s, s->block) == SLICE_ERROR) {\n<125> fprintf(stderr, "ERROR at MB %d %d\n", s->mb_x, s->mb_y);\n<133> if (++s->mb_x == s->mb_width) {\n<135> s->mb_x = 0;\n<137> s->mb_y++;
<1> void *av_malloc(unsigned int size)\n<67> ptr = malloc(size);\n<71> return ptr;
<1> static int rtp_parse_packet_internal(RTPDemuxContext *s, AVPacket *pkt,\n<3> const uint8_t *buf, int len)\n<21> ext = buf[0] & 0x10;\n<25> if (buf[1] & 0x80)\n<67> if (buf[0] & 0x20) {\n<83> buf += 12;\n<111> buf += ext;\n<121> ret = ff_mpegts_parse_packet(s->ts, pkt, buf, len);\n<133> if (ret < len) {\n<135> s->read_buf_size = len - ret;\n<137> memcpy(s->buf, buf + ret, s->read_buf_size);\n<157> switch(st->codec->codec_id) {\n<165> if (len <= 4)\n<173> buf += 4;\n<175> av_new_packet(pkt, len);\n<177> memcpy(pkt->data, buf, len);\n<193> buf += 4;\n<197> if (h & (1 << 26)) {\n<201> if (len <= 4)\n<205> buf += 4;\n<211> av_new_packet(pkt, len);\n<213> memcpy(pkt->data, buf, len);\n<219> av_new_packet(pkt, len);\n<221> memcpy(pkt->data, buf, len);\n<237> finalize_packet(s, pkt, timestamp);
<1> static void vc1_decode_skip_blocks(VC1Context *v)\n<21> if (s->last_picture.f.data[0]) {\n<23> memcpy(s->dest[0], s->last_picture.f.data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);\n<25> memcpy(s->dest[1], s->last_picture.f.data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n<27> memcpy(s->dest[2], s->last_picture.f.data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);
<1> static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size)\n<21> mem_str = qemu_opt_get(opts, "size");\n<23> if (mem_str) {\n<25> if (!*mem_str) {\n<41> if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n<43> uint64_t overflow_check = sz;\n<47> sz <<= 20;\n<49> if ((sz >> 20) != overflow_check) {
<1> static USBDevice *usb_msd_init(const char *filename)\n<31> p1 = strchr(filename, ':');\n<33> if (p1++) {\n<39> if (strstart(filename, "format=", &p2)) {\n<47> } else if (*filename != ':') {\n<49> printf("unrecognized USB mass-storage option %s\n", filename);\n<59> if (!*filename) {\n<61> printf("block device specification needed\n");\n<67> qemu_opt_set(opts, "file", filename);
<1> static int write_extradata(FFV1Context *f)\n<17> memset(state2, 128, sizeof(state2));\n<19> memset(state, 128, sizeof(state));\n<35> put_symbol(c, state, f->version, 0);
<1> static void apic_init_ipi(APICState *s)\n<17> memset(s->isr, 0, sizeof(s->isr));\n<19> memset(s->tmr, 0, sizeof(s->tmr));\n<21> memset(s->irr, 0, sizeof(s->irr));\n<29> memset(s->icr, 0, sizeof(s->icr));
<1> static int vhdx_open(BlockDriverState *bs, QDict *options, int flags,\n<33> ret = bdrv_pread(bs->file, 0, &signature, sizeof(uint64_t));\n<35> if (ret < 0) {\n<41> if (memcmp(&signature, "vhdxfile", 8)) {\n<43> ret = -EINVAL;\n<57> vhdx_guid_generate(&s->session_guid);\n<61> ret = vhdx_parse_header(bs, s);\n<63> if (ret) {\n<217> qemu_vfree(s->headers[0]);\n<219> qemu_vfree(s->headers[1]);\n<221> qemu_vfree(s->bat);\n<223> qemu_vfree(s->parent_entries);\n<225> return ret;
<1> static int decode_frame_ilbm(AVCodecContext *avctx,\n<21> if (avctx->reget_buffer(avctx, &s->frame) < 0){\n<31> for(y = 0; y < avctx->height; y++ ) {\n<33> uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n<35> memset(row, 0, avctx->pix_fmt == PIX_FMT_PAL8 ? avctx->width : (avctx->width * 4));\n<41> decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), avctx->bits_per_coded_sample, plane);\n<45> decodeplane32(row, buf, FFMIN(s->planesize, buf_end - buf), avctx->bits_per_coded_sample, plane);
<1> static unsigned int dec_move_mr(DisasContext *dc)\n<5> int memsize = memsize_zz(dc);\n<9> DIS(fprintf (logfile, "move.%c [$r%u%s, $r%u\n",\n<11> memsize_char(memsize),\n<21> insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);\n<23> cris_cc_mask(dc, CC_MASK_NZ);\n<25> cris_update_cc_op(dc, CC_OP_MOVE, 4);\n<27> cris_update_cc_x(dc);\n<29> cris_update_result(dc, cpu_R[dc->op2]);\n<41> insn_len = dec_prep_move_m(dc, 0, memsize, t0);\n<43> cris_cc_mask(dc, CC_MASK_NZ);\n<53> do_postinc(dc, memsize);
<1> int qemu_savevm_state_begin(Monitor *mon, QEMUFile *f, int blk_enable,\n<33> QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n<55> len = strlen(se->idstr);\n<57> qemu_put_byte(f, len);\n<59> qemu_put_buffer(f, (uint8_t *)se->idstr, len);
<1> int tm_adopt ( char * id , int adoptCmd , pid_t pid ) {\n<8> if ( init_done ) return TM_BADINIT ;\n<10> if ( ( tm_jobid = getenv ( "PBS_JOBID" ) ) == NULL ) tm_jobid = ( char * ) "ADOPT JOB" ;\n<11> tm_jobid_len = strlen ( tm_jobid ) ;\n<12> if ( ( tm_jobcookie = getenv ( "PBS_JOBCOOKIE" ) ) == NULL ) tm_jobcookie = ( char * ) "ADOPT COOKIE" ;\n<13> tm_jobcookie_len = strlen ( tm_jobcookie ) ;\n<16> if ( ( env = getenv ( "PBS_MOMPORT" ) ) == NULL || ( tm_momport = atoi ( env ) ) == 0 ) tm_momport = PBS_MANAGER_SERVICE_PORT ;\n<18> if ( startcom ( adoptCmd , TM_NULL_EVENT , & chan ) != DIS_SUCCESS ) return TM_ESYSTEM ;\n<23> if ( diswsi ( chan , pid ) != DIS_SUCCESS ) {\n<27> if ( diswcs ( chan , id , strlen ( id ) ) != DIS_SUCCESS ) {\n<28> rc = TM_ENOTCONNECTED ;\n<31> DIS_tcp_wflush ( chan ) ;\n<32> status = disrsi ( chan , & ret ) ;\n<33> if ( ret != DIS_SUCCESS ) {\n<44> tm_adopt_cleanup : if ( chan != NULL ) DIS_tcp_cleanup ( chan ) ;\n<45> return rc ;
<1> static int mss4_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> MSS4Context * c = avctx -> priv_data ;\n<45> if ( frame_type == SKIP_FRAME ) {\n<62> memset ( c -> prev_vec , 0 , sizeof ( c -> prev_vec ) ) ;\n<64> y < mb_height ;\n<66> memset ( c -> dc_cache , 0 , sizeof ( c -> dc_cache ) ) ;\n<72> case DCT_BLOCK : if ( mss4_decode_dct_block ( c , & gb , dst , x , y ) < 0 ) {\n<77> case IMAGE_BLOCK : if ( mss4_decode_image_block ( c , & gb , dst , x , y ) < 0 ) {\n<88> if ( blk_type != DCT_BLOCK ) mss4_update_dc_cache ( c , x ) ;
<1> static int rndis_get_response(USBNetState *s, uint8_t *buf)\n<11> if (!r)\n<17> TAILQ_REMOVE(&s->rndis_resp, r, entries);\n<21> memcpy(buf, r->buf, r->length);\n<23> qemu_free(r);
<1> static void create_watching_parent ( void ) {\n<13> memset ( oldact , 0 , sizeof ( oldact ) ) ;\n<38> if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) {\n<42> if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) {\n<60> if ( WIFSIGNALED ( status ) ) {\n<61> fprintf ( stderr , "%s%s\n" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( " (core dumped)" ) : "" ) ;\n<70> if ( caught_signal ) {\n<71> fprintf ( stderr , _ ( "\nSession terminated, killing shell..." ) ) ;\n<75> if ( caught_signal ) {\n<78> fprintf ( stderr , _ ( " ...killed.\n" ) ) ;\n<80> case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ;\n<82> case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ;\n<84> case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ;
<1> static int usb_device_del(const char *devname)\n<17> if (!used_usb_ports)\n<23> p = strchr(devname, '.');\n<25> if (!p)\n<29> bus_num = strtoul(devname, NULL, 0);
<1> static void set_kernel_args(const struct arm_boot_info *info)\n<53> if (info->kernel_cmdline && *info->kernel_cmdline) {\n<61> cmdline_size = strlen(info->kernel_cmdline);\n<63> cpu_physical_memory_write(p + 8, (void *)info->kernel_cmdline,\n<65> cmdline_size + 1);\n<67> cmdline_size = (cmdline_size >> 2) + 1;\n<87> atag_board_len = (info->atag_board(info, atag_board_buf) + 3) & ~3;
<1> static int device_init(AVFormatContext *ctx, int *width, int *height,\n<21> memset(&fmt, 0, sizeof(struct v4l2_format));\n<37> res = ioctl(fd, VIDIOC_S_FMT, &fmt);
<1> static unsigned int dec_movu_r(DisasContext *dc)\n<7> int size = memsize_z(dc);\n<11> memsize_char(size),\n<17> cris_cc_mask(dc, CC_MASK_NZ);\n<21> dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
<1> static void flat_print_key_prefix(WriterContext *wctx)\n<5> FlatContext *flat = wctx->priv;\n<11> printf("%s", flat->section_header[wctx->level].str);\n<15> if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n<17> int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n<21> printf("%d%s", n, flat->sep_str);
<1> static void os_host_main_loop_wait(int *timeout)\n<47> for (i = (ret - WAIT_OBJECT_0 + 1); i < w->num; i++) {\n<61> } else if (ret2 != WAIT_TIMEOUT) {\n<63> err = GetLastError();\n<65> fprintf(stderr, "WaitForSingleObject error %d %d\n", i, err);\n<71> } else if (ret != WAIT_TIMEOUT) {\n<73> err = GetLastError();\n<75> fprintf(stderr, "WaitForMultipleObjects error %d %d\n", ret, err);
<1> static void vnc_client_read(void *opaque)\n<5> VncState *vs = opaque;\n<39> ret = recv(vs->csock, buffer_end(&vs->input), 4096, 0);\n<41> ret = vnc_client_io_error(vs, ret, socket_error());\n<61> ret = vs->read_handler(vs, vs->input.buffer, len);\n<63> if (vs->csock == -1)\n<69> if (!ret) {\n<71> memmove(vs->input.buffer, vs->input.buffer + len, (vs->input.offset - len));
<1> int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)\n<21> if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {\n<23> if(out + bpp + 1 > outbuf + out_size) return -1;\n<25> *out++ = (count ^ xor) + add;\n<27> memcpy(out, ptr, bpp);\n<29> out += bpp;\n<35> count = count_pixels(ptr, w-x, bpp, 0);\n<37> *out++ = count - 1;\n<41> if(out + bpp*count > outbuf + out_size) return -1;\n<43> memcpy(out, ptr, bpp * count);\n<45> out += bpp * count;\n<51> ptr += count * bpp;
<1> void evhttp_connection_free ( struct evhttp_connection * evcon ) {\n<4> if ( evhttp_connected ( evcon ) && evcon -> closecb != NULL ) ( * evcon -> closecb ) ( evcon , evcon -> closecb_arg ) ;\n<6> while ( ( req = TAILQ_FIRST ( & evcon -> requests ) ) != NULL ) {\n<7> TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n<10> if ( evcon -> http_server != NULL ) {\n<12> TAILQ_REMOVE ( & http -> connections , evcon , next ) ;\n<14> if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;\n<15> if ( event_initialized ( & evcon -> ev ) ) event_del ( & evcon -> ev ) ;\n<16> if ( evcon -> fd != - 1 ) EVUTIL_CLOSESOCKET ( evcon -> fd ) ;\n<17> if ( evcon -> bind_address != NULL ) free ( evcon -> bind_address ) ;\n<18> if ( evcon -> address != NULL ) free ( evcon -> address ) ;\n<19> if ( evcon -> input_buffer != NULL ) evbuffer_free ( evcon -> input_buffer ) ;\n<20> if ( evcon -> output_buffer != NULL ) evbuffer_free ( evcon -> output_buffer ) ;\n<21> free ( evcon ) ;
<1> int v9fs_device_realize_common(V9fsState *s, Error **errp)\n<61> if (!s->fsconf.tag) {\n<81> len = strlen(s->fsconf.tag);\n<83> if (len > MAX_TAG_LEN - 1) {\n<85> error_setg(errp, "mount tag '%s' (%d bytes) is longer than "\n<95> s->tag = g_strdup(s->fsconf.tag);\n<133> if (s->ops->name_to_path(&s->ctx, NULL, "/", &path) < 0) {\n<137> "error in converting name to path %s", strerror(errno));
<1> static int mp3_write_xing(AVFormatContext *s)\n<9> AVDictionaryEntry *enc = av_dict_get(s->streams[mp3->audio_stream_idx]->metadata, "encoder", NULL, 0);\n<207> if (enc) {\n<211> if (   strlen(enc->value) > sizeof(encoder_str)\n<213> && !strcmp("Lavc libmp3lame", enc->value)) {\n<215> memcpy(encoder_str, "Lavf lame", 9);\n<219> memcpy(encoder_str, enc->value, FFMIN(strlen(enc->value), sizeof(encoder_str)));
<1> int main ( int argc , char * argv [ ] ) {\n<10> yyin = fopen ( EF_GBL_OPTIONS -> source_file , "r" ) ;\n<17> setbuf ( stdout , NULL ) ;\n<21> fprintf ( stdout , "\n Parsing source file \'%s\' " , EF_GBL_OPTIONS -> source_file ) ;\n<22> fflush ( stdout ) ;\n<24> if ( yyparse ( ) == 0 ) fprintf ( stdout , " done.\n\n" ) ;\n<25> else fprintf ( stdout , "\n\nThe script contains errors...\n\n" ) ;
<1> static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n<9> MOVTrack *trk = &mov->tracks[pkt->stream_index];\n<11> AVCodecContext *enc = trk->enc;\n<39> len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n<65> if (trk->vosLen == 0 && enc->extradata_size > 0) {\n<69> trk->vosData = av_malloc(trk->vosLen);\n<71> memcpy(trk->vosData, enc->extradata, trk->vosLen);\n<77> if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {\n<93> } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {\n<97> if (size < 640)\n<103> trk->vosData = av_malloc(trk->vosLen);\n<105> memcpy(trk->vosData, pkt->data, 640);\n<161> put_buffer(pb, pkt->data, size);
<1> static void dummy_m68k_init(QEMUMachineInitArgs *args)\n<31> if (!env) {\n<33> fprintf(stderr, "Unable to find m68k CPU definition\n");\n<61> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<69> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n<85> if (kernel_size < 0) {\n<87> fprintf(stderr, "qemu: could not load kernel '%s'\n",
<1> static void mp3_parse_info_tag(AVFormatContext *s, AVStream *st,\n<45> if (v != MKBETAG('X', 'i', 'n', 'g') && !mp3->is_cbr)\n<101> memset(version, 0, sizeof(version));\n<103> avio_read(s->pb, version, 9);
<1> void bdrv_set_boot_sector(BlockDriverState *bs, const uint8_t *data, int size)\n<7> if (size > 512)\n<9> size = 512;\n<11> memcpy(bs->boot_sector_data, data, size);\n<13> memset(bs->boot_sector_data + size, 0, 512 - size);
<1> static void test_to_from_buf_1(void)\n<21> sz = iov_size(iov, niov);\n<27> memcpy(ibuf-4, "aaaa", 4); memcpy(ibuf + sz, "bbbb", 4);\n<31> memcpy(obuf-4, "xxxx", 4); memcpy(obuf + sz, "yyyy", 4);\n<39> ibuf[i] = i & 255;\n<45> for (i = 0; i <= sz; ++i) {\n<67> n = iov_from_buf(iov, niov, i, ibuf + i, -1);\n<69> g_assert(n == sz - i);\n<75> memset(obuf + i, 0, sz - i);\n<79> n = iov_to_buf(iov, niov, i, obuf + i, -1);\n<81> g_assert(n == sz - i);\n<87> g_assert(memcmp(ibuf, obuf, sz) == 0);\n<93> n = iov_to_buf(iov, niov, i, obuf + i, 1);\n<95> g_assert(n == (i < sz));\n<99> g_assert(obuf[i] == (i & 255));\n<105> for (j = i; j <= sz; ++j) {\n<117> g_assert(n == sz);\n<123> n = iov_from_buf(iov, niov, i, ibuf + i, j - i);\n<125> g_assert(n == j - i);\n<131> memset(obuf + i, 0, j - i);\n<137> n = iov_to_buf(iov, niov, i, obuf + i, j - i);\n<145> g_assert(memcmp(ibuf, obuf, sz) == 0);\n<157> g_assert(!memcmp(ibuf-4, "aaaa", 4) && !memcmp(ibuf+sz, "bbbb", 4));\n<161> g_assert(!memcmp(obuf-4, "xxxx", 4) && !memcmp(obuf+sz, "yyyy", 4));
<1> static void *nbd_client_thread(void *arg)\n<63> if (verbose) {\n<65> fprintf(stderr, "NBD device %s is now connected to %s\n",
<1> static void bt_submit_hci(struct HCIInfo *info,\n<3> const uint8_t *data, int length)\n<7> struct bt_hci_s *hci = hci_from_info(info);\n<15> if (length < HCI_COMMAND_HDR_SIZE)\n<21> memcpy(&hci->last_cmd, data, 2);\n<25> cmd = (data[1] << 8) | data[0];\n<27> paramlen = data[2];\n<35> data += HCI_COMMAND_HDR_SIZE;\n<63> LENGTH_CHECK(inquiry);\n<67> if (PARAM(inquiry, length) < 1) {\n<81> hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;\n<87> bt_hci_inquiry_start(hci, PARAM(inquiry, length));\n<95> if (!hci->lm.inquire || hci->lm.periodic) {\n<97> fprintf(stderr, "%s: Inquiry Cancel should only be issued after "\n<127> LENGTH_CHECK(periodic_inquiry);\n<131> if (!(PARAM(periodic_inquiry, length) <\n<133> PARAM16(periodic_inquiry, min_period) &&\n<135> PARAM16(periodic_inquiry, min_period) <\n<137> PARAM16(periodic_inquiry, max_period)) ||\n<139> PARAM(periodic_inquiry, length) < 1 ||\n<141> PARAM16(periodic_inquiry, min_period) < 2 ||\n<143> PARAM16(periodic_inquiry, max_period) < 3) {\n<157> hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);\n<161> hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);\n<165> bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));\n<173> if (!hci->lm.inquire || !hci->lm.periodic) {\n<175> fprintf(stderr, "%s: Inquiry Cancel should only be issued after "\n<205> LENGTH_CHECK(create_conn);\n<221> if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))\n<223> bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));\n<231> LENGTH_CHECK(disconnect);\n<235> if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {\n<247> bt_hci_disconnect(hci, PARAMHANDLE(disconnect),\n<249> PARAM(disconnect, reason));\n<257> LENGTH_CHECK(create_conn_cancel);\n<263> &PARAM(create_conn_cancel, bdaddr))) {\n<271> &PARAM(create_conn_cancel, bdaddr)))\n<281> &PARAM(create_conn_cancel, bdaddr));\n<287> &PARAM(create_conn_cancel, bdaddr));\n<295> LENGTH_CHECK(accept_conn_req);\n<301> bacmp(&PARAM(accept_conn_req, bdaddr),\n<325> LENGTH_CHECK(reject_conn_req);\n<331> bacmp(&PARAM(reject_conn_req, bdaddr),\n<347> PARAM(reject_conn_req, reason));\n<359> LENGTH_CHECK(auth_requested);\n<363> if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))\n<371> bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));\n<381> LENGTH_CHECK(set_conn_encrypt);\n<385> if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))\n<395> PARAMHANDLE(set_conn_encrypt),\n<397> PARAM(set_conn_encrypt, encrypt));\n<407> LENGTH_CHECK(remote_name_req);\n<411> if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))\n<421> LENGTH_CHECK(remote_name_req_cancel);\n<427> &PARAM(remote_name_req_cancel, bdaddr));\n<435> LENGTH_CHECK(read_remote_features);\n<439> if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))\n<449> LENGTH_CHECK(read_remote_ext_features);\n<453> if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))\n<463> PARAMHANDLE(read_remote_ext_features));\n<473> LENGTH_CHECK(read_remote_version);\n<477> if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))\n<487> LENGTH_CHECK(read_clock_offset);\n<491> if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))\n<501> LENGTH_CHECK(read_lmp_handle);\n<507> bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));\n<515> LENGTH_CHECK(hold_mode);\n<519> if (PARAM16(hold_mode, min_interval) >\n<521> PARAM16(hold_mode, max_interval) ||\n<523> PARAM16(hold_mode, min_interval) < 0x0002 ||\n<525> PARAM16(hold_mode, max_interval) > 0xff00 ||\n<527> (PARAM16(hold_mode, min_interval) & 1) ||\n<529> (PARAM16(hold_mode, max_interval) & 1)) {\n<539> if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),\n<541> PARAM16(hold_mode, max_interval),\n<553> LENGTH_CHECK(park_mode);\n<557> if (PARAM16(park_mode, min_interval) >\n<559> PARAM16(park_mode, max_interval) ||\n<561> PARAM16(park_mode, min_interval) < 0x000e ||\n<563> (PARAM16(park_mode, min_interval) & 1) ||\n<565> (PARAM16(park_mode, max_interval) & 1)) {\n<575> if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),\n<577> PARAM16(park_mode, max_interval),\n<589> LENGTH_CHECK(exit_park_mode);\n<593> if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),\n<605> LENGTH_CHECK(role_discovery);\n<609> if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))\n<613> HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);\n<619> HCI_SUCCESS, PARAMHANDLE(role_discovery),\n<623> PARAMHANDLE(role_discovery)));\n<631> LENGTH_CHECK(set_event_mask);\n<635> memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);\n<637> bt_hci_event_complete_status(hci, HCI_SUCCESS);\n<655> if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)\n<661> LENGTH_CHECK(set_event_flt);\n<675> LENGTH_CHECK(flush);\n<679> if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))\n<683> HCI_NO_CONNECTION, PARAMHANDLE(flush));\n<691> &PARAM(flush, handle),\n<697> HCI_SUCCESS, PARAMHANDLE(flush));\n<707> LENGTH_CHECK(change_local_name);\n<711> if (hci->device.lmp_name)\n<713> free((void *) hci->device.lmp_name);\n<715> hci->device.lmp_name = strndup(PARAM(change_local_name, name),\n<717> sizeof(PARAM(change_local_name, name)));\n<745> LENGTH_CHECK(write_conn_accept_timeout);\n<749> if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||\n<751> PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {\n<761> hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);\n<779> LENGTH_CHECK(write_scan_enable);\n<787> !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);\n<791> !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);\n<809> LENGTH_CHECK(write_class_of_dev);\n<813> memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),\n<815> sizeof(PARAM(write_class_of_dev, dev_class)));\n<833> LENGTH_CHECK(write_voice_setting);\n<837> hci->voice_setting = PARAM(write_voice_setting, voice_setting);\n<847> if (length < data[0] * 2 + 1)\n<887> LENGTH_CHECK(write_inquiry_mode);\n<891> if (PARAM(write_inquiry_mode, mode) > 0x01) {\n<901> hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);\n<935> LENGTH_CHECK(read_local_ext_features);\n<941> PARAM(read_local_ext_features, page_num));\n<973> LENGTH_CHECK(read_link_quality);\n<977> bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n<993> fprintf(stderr, "%s: HCI packet too short (%iB)\n",
<1> static void acpi_table_install(const char unsigned *blob, size_t bloblen,\n<5> const struct AcpiTableOptions *hdrs,\n<63> hdr_src = blob;\n<85> hdr_src = dfl_hdr;\n<89> body_size = bloblen - body_start;\n<95> if (acpi_payload_size > UINT16_MAX) {\n<119> acpi_tables = g_realloc(acpi_tables, acpi_tables_len +\n<127> ext_hdr = (struct acpi_table_header *)(acpi_tables + acpi_tables_len);\n<129> acpi_tables_len += ACPI_TABLE_PFX_SIZE;\n<133> memcpy(acpi_tables + acpi_tables_len, hdr_src, sizeof dfl_hdr);\n<135> acpi_tables_len += sizeof dfl_hdr;\n<139> if (blob != NULL) {\n<141> memcpy(acpi_tables + acpi_tables_len, blob + body_start, body_size);\n<143> acpi_tables_len += body_size;\n<163> if (hdrs->has_sig) {\n<165> strncpy(ext_hdr->sig, hdrs->sig, sizeof ext_hdr->sig);\n<203> if (hdrs->has_oem_id) {\n<205> strncpy(ext_hdr->oem_id, hdrs->oem_id, sizeof ext_hdr->oem_id);\n<211> if (hdrs->has_oem_table_id) {\n<213> strncpy(ext_hdr->oem_table_id, hdrs->oem_table_id,\n<229> if (hdrs->has_asl_compiler_id) {\n<231> strncpy(ext_hdr->asl_compiler_id, hdrs->asl_compiler_id,\n<259> ext_hdr->checksum = acpi_checksum((const char unsigned *)ext_hdr +
<1> static int get_channel_idx(char **map, int *ch, char delim, int max_ch)\n<9> int n = 0;\n<15> if (!*map)\n<19> len = strlen(*map);\n<21> sscanf(*map, "%d%n", ch, &n);\n<23> if (n != len)
<1> int kqemu_init(CPUState *env)\n<45> kqemu_fd = open(KQEMU_DEVICE, O_RDWR);\n<47> if (kqemu_fd == KQEMU_INVALID_FD) {\n<49> fprintf(stderr, "Could not open '%s' - QEMU acceleration layer not activated: %s\n",\n<51> KQEMU_DEVICE, strerror(errno));\n<69> ioctl(kqemu_fd, KQEMU_GET_VERSION, &version);\n<73> if (version != KQEMU_VERSION) {\n<75> fprintf(stderr, "Version mismatch between kqemu module and qemu (%08x %08x) - disabling kqemu use\n",\n<117> if (!modified_ram_pages_table)\n<123> memset(&kinit, 0, sizeof(kinit)); /* set the paddings to zero */\n<145> ret = ioctl(kqemu_fd, KQEMU_INIT, &kinit);\n<149> if (ret < 0) {\n<151> fprintf(stderr, "Error %d while initializing QEMU acceleration layer - disabling it for now\n", ret);
<1> static int decode_dvd_subtitles(DVDSubContext *ctx, AVSubtitle *sub_header,\n<23> if (buf_size < 10)\n<27> memset(sub_header, 0, sizeof(*sub_header));\n<279> if (sub_header->rects != NULL) {\n<281> for (i = 0; i < sub_header->num_rects; i++) {\n<291> av_freep(&sub_header->rects);\n<365> if (sub_header->num_rects > 0)\n<371> if (sub_header->rects != NULL) {\n<373> for (i = 0; i < sub_header->num_rects; i++) {\n<383> av_freep(&sub_header->rects);
<1> void cpu_loop(CPUM68KState *env)\n<5> CPUState *cs = CPU(m68k_env_get_cpu(env));\n<19> cpu_exec_start(cs);\n<21> trapnr = cpu_m68k_exec(cs);\n<23> cpu_exec_end(cs);\n<169> fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n",\n<173> cpu_dump_state(cs, stderr, fprintf, 0);
<1> static void do_closefd(Monitor *mon, const QDict *qdict)\n<5> const char *fdname = qdict_get_str(qdict, "fdname");\n<11> LIST_FOREACH(monfd, &mon->fds, next) {\n<13> if (strcmp(monfd->name, fdname) != 0) {\n<21> LIST_REMOVE(monfd, next);\n<25> qemu_free(monfd->name);
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> unsigned char * encoded = ( unsigned char * ) buf ;\n<24> outptr = c -> pic . data [ 0 ] ;\n<42> encoded = c -> decomp_buf ;\n<51> encoded = c -> decomp_buf ;\n<115> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<130> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<131> encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n<132> encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n<133> encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n<134> encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n<135> encoded [ pixel_ptr + 5 ] = uq -= encoded [ pixel_ptr + 5 ] ;\n<136> encoded [ pixel_ptr + 6 ] = vq -= encoded [ pixel_ptr + 6 ] ;\n<137> encoded [ pixel_ptr + 7 ] = vq -= encoded [ pixel_ptr + 7 ] ;\n<150> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<151> encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n<152> encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n<153> encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n<154> encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n<155> encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n<168> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<169> encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n<170> encoded [ pixel_ptr + 2 ] = uq -= encoded [ pixel_ptr + 2 ] ;\n<171> encoded [ pixel_ptr + 3 ] = vq -= encoded [ pixel_ptr + 3 ] ;\n<184> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<185> encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n<186> encoded [ pixel_ptr + 2 ] = y1q -= encoded [ pixel_ptr + 2 ] ;\n<187> encoded [ pixel_ptr + 3 ] = y1q -= encoded [ pixel_ptr + 3 ] ;\n<188> encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n<189> encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n<198> y_out = c -> pic . data [ 0 ] + ( height - 1 ) * c -> pic . linesize [ 0 ] ;\n<221> col < width - 3 ;\n<223> memcpy ( y_out + col , encoded , 4 ) ;\n<224> encoded += 4 ;\n<228> v_out [ ( col >> 1 ) + 1 ] = * encoded ++ + 128 ;\n<230> y_out -= c -> pic . linesize [ 0 ] ;\n<236> row >= 0 ;\n<238> pixel_ptr = row * c -> pic . linesize [ 0 ] ;\n<239> memcpy ( outptr + pixel_ptr , encoded , 3 * width ) ;\n<240> encoded += 3 * width ;\n<247> col < width - 3 ;\n<249> memcpy ( y_out + col , encoded , 4 ) ;\n<250> encoded += 4 ;\n<252> v_out [ col >> 2 ] = * encoded ++ + 128 ;\n<254> y_out -= c -> pic . linesize [ 0 ] ;\n<263> col < width - 1 ;\n<265> memcpy ( y_out + col , encoded , 2 ) ;\n<266> encoded += 2 ;\n<268> v_out [ col >> 1 ] = * encoded ++ + 128 ;\n<270> y_out -= c -> pic . linesize [ 0 ] ;\n<281> col < width - 1 ;\n<283> memcpy ( y_out + col , encoded , 2 ) ;\n<284> encoded += 2 ;\n<285> memcpy ( y_out + col - c -> pic . linesize [ 0 ] , encoded , 2 ) ;\n<286> encoded += 2 ;\n<288> v_out [ col >> 1 ] = * encoded ++ + 128 ;\n<290> y_out -= c -> pic . linesize [ 0 ] << 1 ;
<1> static void ipvideo_decode_format_10_opcodes(IpvideoContext *s, AVFrame *frame)\n<21> memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);\n<65> ipvideo_format_10_passes[pass](s, frame, opcode);\n<121> copy_from(s, s->cur_decode_frame, frame, 0, 0);\n<129> copy_from(s, s->last_frame, frame, 0, 0);
<1> static char *doubles2str(double *dp, int count, const char *sep)\n<11> if (!sep) sep = ", ";\n<13> component_len = 15 + strlen(sep);\n<15> ap = av_malloc(component_len * count);\n<21> ap0   = ap;\n<25> for (i = 0; i < count; i++) {\n<27> unsigned l = snprintf(ap, component_len, "%f%s", dp[i], sep);\n<41> ap0[strlen(ap0) - strlen(sep)] = '\0';\n<43> return ap0;
<1> static int32_t parse_gain(const char *gain)\n<15> if (!gain)\n<21> gain += strspn(gain, " \t");\n<25> db = strtol(gain, &fraction, 0);
<1> USBDevice *usb_msd_init(const char *filename, BlockDriverState **pbs)\n<17> p1 = strchr(filename, ':');\n<19> if (p1++) {\n<25> if (strstart(filename, "format=", &p2)) {\n<33> drv = bdrv_find_format(fmt);\n<35> if (!drv) {\n<37> printf("invalid format %s\n", fmt);\n<43> } else if (*filename != ':') {\n<45> printf("unrecognized USB mass-storage option %s\n", filename);\n<59> if (!*filename) {\n<61> printf("block device specification needed\n");\n<75> if (bdrv_open2(bdrv, filename, 0, drv) < 0)
<1> static void ppc_prep_init (ram_addr_t ram_size,\n<65> if (!env) {\n<67> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<223> if (ppc_boot_device == '\0') {\n<225> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<289> for(i = 0; i < nb_nics1; i++) {\n<291> if (nd_table[i].model == NULL) {\n<293> nd_table[i].model = qemu_strdup("ne2k_isa");\n<297> if (strcmp(nd_table[i].model, "ne2k_isa") == 0) {\n<299> isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);\n<303> pci_nic_init_nofail(&nd_table[i], "ne2k_pci", NULL);\n<311> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<313> fprintf(stderr, "qemu: too many IDE bus\n");
<1> void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)\n<87> switch(enc->codec_type) {\n<97> if (enc->pix_fmt != PIX_FMT_NONE) {\n<99> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<103> avcodec_get_pix_fmt_name(enc->pix_fmt));\n<107> if (enc->width) {\n<109> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<115> if (enc->sample_aspect_ratio.num) {\n<117> av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n<119> enc->width*enc->sample_aspect_ratio.num,\n<121> enc->height*enc->sample_aspect_ratio.den,\n<125> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<135> if(av_log_get_level() >= AV_LOG_DEBUG){\n<139> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<143> enc->time_base.num/g, enc->time_base.den/g);\n<149> if (encode) {\n<151> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<169> if (enc->sample_rate) {\n<171> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<177> av_strlcat(buf, ", ", buf_size);\n<179> avcodec_get_channel_layout_string(buf + strlen(buf), buf_size - strlen(buf), enc->channels, enc->channel_layout);\n<181> if (enc->sample_fmt != SAMPLE_FMT_NONE) {\n<183> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<185> ", %s", avcodec_get_sample_fmt_name(enc->sample_fmt));\n<199> bitrate = enc->sample_rate * enc->channels * 64;\n<215> bitrate = enc->sample_rate * enc->channels * 32;\n<229> bitrate = enc->sample_rate * enc->channels * 24;\n<243> bitrate = enc->sample_rate * enc->channels * 16;\n<257> bitrate = enc->sample_rate * enc->channels * 8;\n<273> snprintf(buf, buf_size, "Data: %s", codec_name);\n<281> snprintf(buf, buf_size, "Subtitle: %s", codec_name);\n<289> snprintf(buf, buf_size, "Attachment: %s", codec_name);\n<305> if (enc->flags & CODEC_FLAG_PASS1)\n<307> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<311> if (enc->flags & CODEC_FLAG_PASS2)\n<313> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<319> if (bitrate != 0) {\n<321> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<323> ", %d kb/s", bitrate / 1000);
<1> static int mpegps_read_header(AVFormatContext *s)\n<19> avio_get_str(s->pb, 6, buffer, sizeof(buffer));\n<21> if (!memcmp("IMKH", buffer, 4)) {\n<23> m->imkh_cctv = 1;\n<25> } else if (!memcmp("Sofdec", buffer, 6)) {\n<27> m->sofdec = 1;\n<31> avio_seek(s->pb, last_pos, SEEK_SET);
<1> void ff_aac_update_ltp(AACEncContext *s, SingleChannelElement *sce)\n<11> float *pred_signal = &sce->ltp_state[0];\n<57> if (!lag) {\n<95> memset(&pred_signal[samples_num], 0, (2048 - samples_num)*sizeof(float));
<1> gpg_err_code_t _gcry_ecc_fill_in_curve ( unsigned int nbits , const char * name , elliptic_curve_t * curve , unsigned int * r_nbits ) {\n<6> domain_parms [ idx ] . desc ;\n<7> idx ++ ) if ( ! strcmp ( name , domain_parms [ idx ] . desc ) ) {\n<8> resname = domain_parms [ idx ] . desc ;\n<11> if ( ! domain_parms [ idx ] . desc ) {\n<13> curve_aliases [ aliasno ] . name ;\n<14> aliasno ++ ) if ( ! strcmp ( name , curve_aliases [ aliasno ] . other ) ) break ;\n<17> domain_parms [ idx ] . desc ;\n<18> idx ++ ) if ( ! strcmp ( curve_aliases [ aliasno ] . name , domain_parms [ idx ] . desc ) ) {\n<19> resname = domain_parms [ idx ] . desc ;\n<30> if ( ! domain_parms [ idx ] . desc ) return GPG_ERR_UNKNOWN_CURVE ;
<1> static void frame_erasure(EVRCContext *e, float *samples)\n<31> if (e->bitrate == RATE_FULL)\n<33> memcpy(e->pitch_back, e->pitch, ACB_SIZE * sizeof(float));\n<81> for (i = 0; i < NB_SUBFRAMES; i++) {\n<121> acb_excitation(e, e->pitch + ACB_SIZE,\n<125> for (j = 0; j < subframe_size; j++)\n<127> e->pitch[ACB_SIZE + j] *= e->fade_scale;\n<133> for (j = 0; j < subframe_size; j++)\n<135> e->pitch[ACB_SIZE + j] = e->energy_vector[i];\n<141> memcpy(e->pitch, e->pitch + subframe_size, ACB_SIZE * sizeof(float));\n<151> e->pitch[ACB_SIZE + j] += f;\n<157> e->pitch[ACB_SIZE + j] = e->energy_vector[i];\n<163> synthesis_filter(e->pitch + ACB_SIZE, ilpc,
<1> real_parse_asm_rulebook(AVFormatContext *s, AVStream *orig_st,\n<3> const char *p)\n<43> if (*p == '\"') p++;\n<45> for (n_rules = 0; s->nb_streams < MAX_STREAMS;) {\n<47> if (!(end = strchr(p, ';')))\n<51> if (!odd && end != p) {\n<61> real_parse_asm_rule(st, p, end);\n<67> p = end + 1;\n<69> odd ^= 1;
<1> void av_opencl_buffer_release(cl_mem *cl_buf)\n<7> if (!cl_buf)\n<19> memset(cl_buf, 0, sizeof(*cl_buf));
<1> void bdrv_query_image_info(BlockDriverState *bs,\n<81> if (backing_filename[0] != '\0') {\n<85> info->backing_filename = g_strdup(backing_filename);\n<89> bdrv_get_full_backing_filename(bs, backing_filename2, 1024, &err);\n<91> if (err) {\n<105> if (strcmp(backing_filename, backing_filename2) != 0) {\n<107> info->full_backing_filename =\n<109> g_strdup(backing_filename2);\n<111> info->has_full_backing_filename = true;\n<125> g_free(backing_filename2);
<138> if ( ff_vc1_parse_frame_header ( v , & s -> gb ) == - 1 ) {\n<143> if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) == - 1 ) {\n<222> if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n<229> if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n<238> ff_vc1_decode_blocks ( v ) ;\n<243> if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n<244> memcpy ( v -> mv_f_base , v -> mv_f_next_base , 2 * ( s -> b8_stride * ( s -> mb_height * 2 + 1 ) + s -> mb_stride * ( s -> mb_height + 1 ) * 2 ) ) ;
<11> for(j=0; j<i; j++){\n<13> if(!memcmp(h->pps.scaling_matrix4[j], h->pps.scaling_matrix4[i], 16*sizeof(uint8_t))){\n<15> h->dequant4_coeff[i] = h->dequant4_buffer[j];\n<39> ((uint32_t)dequant4_coeff_init[idx][(x&1) + ((x>>2)&1)] *
<1> static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)\n<13> if (!target) {\n<21> for (i = 0; i < PCI_SLOT_MAX; i++) {\n<25> if (!pbdev) {\n<33> if (!strcmp(pbdev->target, target)) {\n<35> return pbdev;
<1> static void cmv_decode_inter ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n<11> unsigned char * dst = s -> frame . data [ 0 ] + ( y * 4 ) * s -> frame . linesize [ 0 ] + x * 4 ;\n<12> if ( raw + 16 < buf_end && * raw == 0xFF ) {\n<13> raw ++ ;\n<14> memcpy ( dst , raw , 4 ) ;\n<15> memcpy ( dst + s -> frame . linesize [ 0 ] , raw + 4 , 4 ) ;\n<16> memcpy ( dst + 2 * s -> frame . linesize [ 0 ] , raw + 8 , 4 ) ;\n<17> memcpy ( dst + 3 * s -> frame . linesize [ 0 ] , raw + 12 , 4 ) ;\n<18> raw += 16 ;\n<22> int yoffset = ( ( * raw >> 4 ) ) - 7 ;
<1> static FFPsyWindowInfo psy_lame_window(FFPsyContext *ctx,\n<25> memset(&wi, 0, sizeof(wi));\n<243> lame_apply_block_type(pch, &wi, uselongblock);\n<319> return wi;
<1> static int spapr_check_htab_fd(sPAPRMachineState *spapr)\n<15> if (spapr->htab_fd < 0) {\n<17> error_report("Unable to open fd for reading hash table from KVM: "\n<19> "%s", strerror(errno));
<1> static vpx_codec_err_t parse_quantizer_values ( SvcContext * svc_ctx , const char * quantizer_values ) {\n<10> if ( quantizer_values == NULL || strlen ( quantizer_values ) == 0 ) {\n<11> input_string = strdup ( DEFAULT_QUANTIZER_VALUES ) ;\n<14> input_string = strdup ( quantizer_values ) ;\n<16> token = strtok_r ( input_string , delim , & save_ptr ) ;\n<39> free ( input_string ) ;
<1> static int usb_host_scan_sys(void *opaque, USBScanFunc *func)\n<7> char line[1024];\n<31> while ((de = readdir(dir))) {\n<33> if (de->d_name[0] != '.' && !strchr(de->d_name, ':')) {\n<35> char *tmpstr = de->d_name;\n<37> if (!strncmp(de->d_name, "usb", 3))\n<41> bus_num = atoi(tmpstr);\n<45> if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH "/devices/%s/devnum", de->d_name))\n<49> if (sscanf(line, "%d", &addr) != 1)\n<55> if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH "/devices/%s/bDeviceClass", de->d_name))\n<59> if (sscanf(line, "%x", &class_id) != 1)\n<65> if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH "/devices/%s/idVendor", de->d_name))\n<69> if (sscanf(line, "%x", &vendor_id) != 1)\n<75> if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH "/devices/%s/idProduct", de->d_name))\n<79> if (sscanf(line, "%x", &product_id) != 1)\n<85> if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH "/devices/%s/product", de->d_name)) {\n<91> if (strlen(line) > 0)\n<93> line[strlen(line) - 1] = '\0';\n<95> pstrcpy(product_name, sizeof(product_name), line);\n<101> if (!usb_host_read_file(line, sizeof(line), USBSYSBUS_PATH "/devices/%s/speed", de->d_name))\n<105> if (!strcmp(line, "480\n"))\n<107> speed = USB_SPEED_HIGH;\n<109> else if (!strcmp(line, "1.5\n"))\n<111> speed = USB_SPEED_LOW;\n<115> speed = USB_SPEED_FULL;\n<119> ret = func(opaque, bus_num, addr, class_id, vendor_id,
<1> void define_one_arm_cp_reg_with_opaque(ARMCPU *cpu,\n<83> ARMCPRegInfo *r2 = g_memdup(r, sizeof(ARMCPRegInfo));\n<101> r2->crm = crm;\n<103> r2->opc1 = opc1;\n<105> r2->opc2 = opc2;\n<145> if (oldreg && !(oldreg->type & ARM_CP_OVERRIDE)) {\n<147> fprintf(stderr, "Register redefined: cp=%d %d bit "\n<151> "was %s, now %s\n", r2->cp, 32 + 32 * is64,\n<163> g_hash_table_insert(cpu->cp_regs, key, r2);
<1> void gen_intermediate_code_internal(XtensaCPU *cpu,\n<15> int j, lj = -1;\n<105> if (lj < j) {\n<109> while (lj < j) {\n<111> tcg_ctx.gen_opc_instr_start[lj++] = 0;\n<119> tcg_ctx.gen_opc_instr_start[lj] = 1;\n<257> if (search_pc) {\n<261> memset(tcg_ctx.gen_opc_instr_start + lj + 1, 0,\n<263> (j - lj) * sizeof(tcg_ctx.gen_opc_instr_start[0]));
<1> apr_status_t modsecurity_tx_init ( modsec_rec * msr ) {\n<8> apr_pool_cleanup_register ( msr -> mp , msr , modsecurity_tx_cleanup , apr_pool_cleanup_null ) ;\n<16> if ( msr -> request_content_length == - 1 ) {\n<18> if ( ( transfer_encoding != NULL ) && ( strstr ( transfer_encoding , "chunked" ) != NULL ) ) {\n<19> msr -> reqbody_should_exist = 1 ;\n<20> msr -> reqbody_chunked = 1 ;\n<26> msr -> request_content_type = NULL ;\n<28> if ( s != NULL ) msr -> request_content_type = s ;\n<52> if ( msr -> query_string != NULL ) {\n<54> if ( parse_arguments ( msr , msr -> query_string , strlen ( msr -> query_string ) , msr -> txcfg -> argument_separator , "QUERY_STRING" , msr -> arguments , & invalid_count ) < 0 ) {
<1> static void listflags(char *buf, int bufsize, uint32_t fbits,\n<15> b = 4 <= bufsize ? buf + (bufsize -= 3) - 1 : NULL;\n<33> if (b)\n<35> sprintf(b, "...");
<1> static int vqa_decode_chunk(VqaContext *s)\n<255> if ((res = decode_format80(&s->gb, chunk_size, s->codebook,\n<289> bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);\n<469> s->next_codebook_buffer_index += chunk_size;\n<475> if (s->partial_countdown == 0) {\n<511> bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n<527> bytestream2_init(&gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n<531> if ((res = decode_format80(&gb, s->next_codebook_buffer_index,
<1> static int aa_read_header(AVFormatContext *s)\n<11> uint8_t output[24], dst[8], src[8];\n<23> uint32_t header_key_part[4];\n<25> uint8_t header_key[16];\n<27> AADemuxContext *c = s->priv_data;\n<67> for (i = 0; i < npairs; i++) {\n<69> memset(val, 0, sizeof(val));\n<71> memset(key, 0, sizeof(key));\n<85> avio_read(pb, key, nkey); // key string\n<99> if (!strcmp(key, "codec")) {\n<101> av_log(s, AV_LOG_DEBUG, "Codec is <%s>\n", val);\n<103> strncpy(codec_name, val, sizeof(codec_name) - 1);\n<107> if (!strcmp(key, "HeaderSeed")) {\n<109> av_log(s, AV_LOG_DEBUG, "HeaderSeed is <%s>\n", val);\n<111> header_seed = atoi(val);\n<115> if (!strcmp(key, "HeaderKey")) { // this looks like "1234567890 1234567890 1234567890 1234567890"\n<117> av_log(s, AV_LOG_DEBUG, "HeaderKey is <%s>\n", val);\n<119> sscanf(val, "%u%u%u%u", &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);\n<121> for (idx = 0; idx < 4; idx++) {\n<123> AV_WB32(&header_key[idx * 4], header_key_part[idx]); // convert each part to BE!\n<127> av_log(s, AV_LOG_DEBUG, "Processed HeaderKey is ");\n<129> for (i = 0; i < 16; i++)\n<131> av_log(s, AV_LOG_DEBUG, "%02x", header_key[i]);\n<133> av_log(s, AV_LOG_DEBUG, "\n");\n<155> if ((c->codec_second_size = get_second_size(codec_name)) == -1) {\n<169> if (!c->tea_ctx)\n<175> output[0] = output[1] = 0; // purely for padding purposes\n<177> memcpy(output + 2, header_key, 16);\n<193> output[idx] = output[idx] ^ dst[j];\n<199> memcpy(c->file_key, output + 2, 16); // skip first 2 bytes of output\n<215> if (!st) {\n<225> if (!strcmp(codec_name, "mp332")) {\n<227> st->codec->codec_id = AV_CODEC_ID_MP3;\n<229> st->codec->sample_rate = 22050;\n<231> st->need_parsing = AVSTREAM_PARSE_FULL_RAW;\n<233> st->start_time = 0;\n<235> } else if (!strcmp(codec_name, "acelp85")) {\n<237> st->codec->codec_id = AV_CODEC_ID_SIPR;\n<239> st->codec->block_align = 19;\n<241> st->codec->channels = 1;\n<243> st->codec->sample_rate = 8500;\n<245> } else if (!strcmp(codec_name, "acelp16")) {\n<247> st->codec->codec_id = AV_CODEC_ID_SIPR;\n<249> st->codec->block_align = 20;\n<251> st->codec->channels = 1;\n<253> st->codec->sample_rate = 16000;
<1> static int compress_bidder_init ( struct archive_read_filter * self ) {\n<3> static const size_t out_block_size = 64 * 1024 ;\n<8> state = ( struct private_data * ) calloc ( sizeof ( * state ) , 1 ) ;\n<9> out_block = malloc ( out_block_size ) ;\n<10> if ( state == NULL || out_block == NULL ) {\n<11> free ( out_block ) ;\n<12> free ( state ) ;\n<17> state -> out_block_size = out_block_size ;\n<18> state -> out_block = out_block ;
<1> static int decode_packet(int *got_frame, int cached)\n<19> ret = avcodec_decode_video2(video_dec_ctx, frame, got_frame, &pkt);\n<21> if (ret < 0) {\n<23> fprintf(stderr, "Error decoding video frame (%s)\n", av_err2str(ret));\n<29> if (video_dec_ctx->width != width || video_dec_ctx->height != height ||\n<37> fprintf(stderr, "Error: Width, height and pixel format have to be "\n<47> width, height, av_get_pix_fmt_name(pix_fmt),\n<51> av_get_pix_fmt_name(video_dec_ctx->pix_fmt));\n<59> if (*got_frame) {\n<61> printf("video_frame%s n:%d coded_n:%d pts:%s\n",\n<65> video_frame_count++, frame->coded_picture_number,\n<67> av_ts2timestr(frame->pts, &video_dec_ctx->time_base));\n<93> ret = avcodec_decode_audio4(audio_dec_ctx, frame, got_frame, &pkt);\n<95> if (ret < 0) {\n<97> fprintf(stderr, "Error decoding audio frame (%s)\n", av_err2str(ret));\n<115> if (*got_frame) {\n<117> size_t unpadded_linesize = frame->nb_samples * av_get_bytes_per_sample(frame->format);\n<119> printf("audio_frame%s n:%d nb_samples:%d pts:%s\n",\n<123> audio_frame_count++, frame->nb_samples,\n<125> av_ts2timestr(frame->pts, &audio_dec_ctx->time_base));\n<159> av_frame_unref(frame);
<1> pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)\n<5> char temp[GET_MODE_BUFFER_SIZE];\n<7> char *p= temp;\n<9> static const char filterDelimiters[] = ",/";\n<11> static const char optionDelimiters[] = ":";\n<47> memset(temp, 0, GET_MODE_BUFFER_SIZE);\n<49> av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);\n<69> char *options[OPTIONS_ARRAY_SIZE];\n<81> filterToken= strtok(p, filterDelimiters);\n<83> if(filterToken == NULL) break;\n<85> p+= strlen(filterToken) + 1; // p points to next filterToken\n<87> filterName= strtok(filterToken, optionDelimiters);\n<89> av_log(NULL, AV_LOG_DEBUG, "pp: %s::%s\n", filterToken, filterName);\n<93> if(*filterName == '-'){\n<97> filterName++;\n<105> option= strtok(NULL, optionDelimiters);\n<107> if(option == NULL) break;\n<111> av_log(NULL, AV_LOG_DEBUG, "pp: option: %s\n", option);\n<113> if(!strcmp("autoq", option) || !strcmp("a", option)) q= quality;\n<115> else if(!strcmp("nochrom", option) || !strcmp("y", option)) chrom=0;\n<117> else if(!strcmp("chrom", option) || !strcmp("c", option)) chrom=1;\n<119> else if(!strcmp("noluma", option) || !strcmp("n", option)) luma=0;\n<123> options[numOfUnknownOptions] = option;\n<125> numOfUnknownOptions++;\n<129> if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break;\n<139> for(i=0; replaceTable[2*i]!=NULL; i++){\n<141> if(!strcmp(replaceTable[2*i], filterName)){\n<143> int newlen= strlen(replaceTable[2*i + 1]);\n<151> if(p==NULL) p= temp, *p=0;      //last filter\n<153> else p--, *p=',';               //not last filter\n<157> plen= strlen(p);\n<159> spaceLeft= p - temp + plen;\n<161> if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){\n<169> memmove(p + newlen, p, plen+1);\n<171> memcpy(p, replaceTable[2*i + 1], newlen);\n<181> for(i=0; filters[i].shortName!=NULL; i++){\n<183> if(   !strcmp(filters[i].longName, filterName)\n<185> || !strcmp(filters[i].shortName, filterName)){\n<187> ppMode->lumMode &= ~filters[i].mask;\n<189> ppMode->chromMode &= ~filters[i].mask;\n<193> filterNameOk=1;\n<195> if(!enable) break; // user wants to disable it\n<219> for(o=0; options[o]!=NULL; o++){\n<221> if(  !strcmp(options[o],"fullyrange")\n<223> ||!strcmp(options[o],"f")){\n<225> ppMode->minAllowedY= 0;\n<227> ppMode->maxAllowedY= 255;\n<229> numOfUnknownOptions--;
<1> static unsigned int dec_subu_r(DisasContext *dc)\n<7> int size = memsize_z(dc);\n<11> memsize_char(size),\n<17> cris_cc_mask(dc, CC_MASK_NZVC);
<1> static void mips_fulong2e_init(MachineState *machine)\n<55> if (cpu == NULL) {\n<57> fprintf(stderr, "Unable to find CPU definition\n");\n<185> if (!isa_bus) {\n<187> fprintf(stderr, "vt82c686b_init error\n");
<1> int smbios_entry_add(const char *t)\n<15> int size = get_image_size(buf);\n<19> if (size < sizeof(struct smbios_structure_header)) {\n<21> fprintf(stderr, "Cannot read smbios file %s", buf);\n<51> if (load_image(buf, table->data) != size) {\n<53> fprintf(stderr, "Failed to load smbios file %s", buf);\n<79> if (get_param_value(buf, sizeof(buf), "type", t)) {\n<81> unsigned long type = strtoul(buf, NULL, 0);\n<83> switch (type) {\n<99> fprintf(stderr, "Don't know how to build fields for SMBIOS type "\n<111> fprintf(stderr, "smbios: must specify type= or file=\n");
<1> static int debugcon_parse(const char *devname)\n<17> if (!opts) {\n<19> fprintf(stderr, "qemu: already have a debugcon device\n");
<1> static void do_attach(USBDevice *dev)\n<5> USBBus *bus = usb_bus_from_device(dev);\n<11> if (dev->attached) {\n<13> fprintf(stderr, "Warning: tried to attach usb device %s twice\n",
<1> char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) {\n<5> if ( length > 0 ) {\n<6> buffer = malloc ( length + 1 ) ;\n<7> if ( buffer != NULL ) {\n<11> if ( buffer != NULL ) free ( buffer ) ;
<1> kadm5_ret_t kadm5_modify_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n<8> if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n<9> if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n<10> if ( ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n<22> ret = krb5_db_get_policy ( handle -> context , entry -> policy , & p ) ;\n<67> if ( entry -> allowed_keysalts != NULL ) {\n<68> len = strlen ( entry -> allowed_keysalts ) + 1 ;\n<69> p -> allowed_keysalts = krb5_db_alloc ( handle -> context , NULL , len ) ;\n<70> if ( p -> allowed_keysalts == NULL ) {\n<74> memcpy ( p -> allowed_keysalts , entry -> allowed_keysalts , len ) ;\n<86> ret = krb5_db_put_policy ( handle -> context , p ) ;\n<87> cleanup : krb5_db_free_policy ( handle -> context , p ) ;
<1> static int qcow2_set_key(BlockDriverState *bs, const char *key)\n<7> uint8_t keybuf[16];\n<15> memset(keybuf, 0, 16);\n<17> len = strlen(key);\n<19> if (len > 16)\n<29> keybuf[i] = key[i];\n<45> keybuf, G_N_ELEMENTS(keybuf),
<1> static int blkdebug_open(BlockDriverState *bs, const char *filename, int flags)\n<15> if (strncmp(filename, "blkdebug:", strlen("blkdebug:"))) {\n<17> return -EINVAL;\n<21> filename += strlen("blkdebug:");\n<27> c = strchr(filename, ':');\n<29> if (c == NULL) {\n<37> config = strdup(filename);\n<39> config[c - filename] = '\0';\n<41> ret = read_config(s, config);\n<43> free(config);
<1> ram_addr_t qemu_ram_alloc_from_ptr(DeviceState *dev, const char *name,\n<13> new_block = qemu_mallocz(sizeof(*new_block));\n<31> pstrcat(new_block->idstr, sizeof(new_block->idstr), name);\n<35> QLIST_FOREACH(block, &ram_list.blocks, next) {\n<37> if (!strcmp(block->idstr, new_block->idstr)) {\n<39> fprintf(stderr, "RAMBlock \"%s\" already registered, abort!\n",\n<41> new_block->idstr);\n<43> abort();\n<61> QLIST_INSERT_HEAD(&ram_list.blocks, new_block, next);\n<65> ram_list.phys_dirty = qemu_realloc(ram_list.phys_dirty,\n<69> memset(ram_list.phys_dirty + (new_block->offset >> TARGET_PAGE_BITS),\n<71> 0xff, size >> TARGET_PAGE_BITS);
<1> int kvm_insert_breakpoint(CPUState *current_env, target_ulong addr,\n<37> bp->pc = addr;\n<39> bp->use_count = 1;\n<41> err = kvm_arch_insert_sw_breakpoint(current_env, bp);\n<43> if (err) {\n<45> free(bp);
<1> static PGconn * _connectDB ( ArchiveHandle * AH , const char * reqdb , const char * requser ) {\n<9> if ( ! requser || strlen ( requser ) == 0 ) newuser = PQuser ( AH -> connection ) ;\n<10> else newuser = requser ;\n<11> ahlog ( AH , 1 , "connecting to database \"%s\" as user \"%s\"\n" , newdb , newuser ) ;\n<12> password = AH -> savedPassword ? pg_strdup ( AH -> savedPassword ) : NULL ;\n<13> if ( AH -> promptPassword == TRI_YES && password == NULL ) {\n<15> if ( password == NULL ) exit_horribly ( modulename , "out of memory\n" ) ;\n<25> values [ 2 ] = newuser ;\n<29> values [ 4 ] = newdb ;\n<37> if ( PQstatus ( newConn ) == CONNECTION_BAD ) {\n<40> if ( password ) fprintf ( stderr , "Password incorrect\n" ) ;\n<41> fprintf ( stderr , "Connecting to %s as %s\n" , newdb , newuser ) ;\n<42> if ( password ) free ( password ) ;\n<45> if ( password == NULL ) exit_horribly ( modulename , "out of memory\n" ) ;\n<51> if ( AH -> savedPassword ) free ( AH -> savedPassword ) ;\n<54> if ( password ) free ( password ) ;
<1> static void vp3_decode_flush ( AVCodecContext * avctx ) {\n<2> Vp3DecodeContext * s = avctx -> priv_data ;\n<4> if ( s -> golden_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> last_frame , 0 , sizeof ( AVFrame ) ) ;\n<5> if ( s -> current_frame . data [ 0 ] == s -> golden_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n<9> if ( s -> current_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n<10> ff_thread_release_buffer ( avctx , & s -> last_frame ) ;\n<12> if ( s -> current_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> current_frame ) ;
<1> int ff_h263_decode_frame(AVCodecContext *avctx,\n<5> UINT8 *buf, int buf_size)\n<55> ParseContext *pc= &s->parse_context;\n<63> if(s->codec_id==CODEC_ID_MPEG4){\n<65> next= mpeg4_find_frame_end(s, buf, buf_size);\n<69> fprintf(stderr, "this codec doesnt support truncated bitstreams\n");\n<75> if(next==-1){\n<77> if(buf_size + FF_INPUT_BUFFER_PADDING_SIZE + pc->index > pc->buffer_size){\n<79> pc->buffer_size= buf_size + pc->index + 10*1024;\n<81> pc->buffer= realloc(pc->buffer, pc->buffer_size);\n<87> memcpy(&pc->buffer[pc->index], buf, buf_size);\n<89> pc->index += buf_size;\n<91> return buf_size;\n<97> if(pc->index){\n<99> if(next + FF_INPUT_BUFFER_PADDING_SIZE + pc->index > pc->buffer_size){\n<101> pc->buffer_size= next + pc->index + 10*1024;\n<103> pc->buffer= realloc(pc->buffer, pc->buffer_size);\n<109> memcpy(&pc->buffer[pc->index], buf, next + FF_INPUT_BUFFER_PADDING_SIZE );\n<113> buf= pc->buffer;\n<129> init_get_bits(&s->gb, s->bitstream_buffer, s->bitstream_buffer_size);\n<133> init_get_bits(&s->gb, buf, buf_size);\n<421> if (ret < 0){\n<423> fprintf(stderr, "header damaged\n");\n<467> if(MPV_frame_start(s, avctx) < 0)\n<481> if(s->error_resilience)\n<483> memset(s->error_status_table, MV_ERROR|AC_ERROR|DC_ERROR|VP_START|AC_END|DC_END|MV_END, s->mb_num*sizeof(UINT8));\n<507> decode_slice(s);\n<521> if(ff_h263_resync(s)<0)\n<531> ff_mpeg4_clean_buffers(s);\n<535> decode_slice(s);\n<547> if(msmpeg4_decode_ext_header(s, buf_size) < 0){\n<563> if(   buf_size - current_pos > 5\n<565> && buf_size - current_pos < BITSTREAM_BUFFER_SIZE){\n<573> if(buf[i]==0 && buf[i+1]==0 && buf[i+2]==1 && buf[i+3]==0xB6){\n<583> if(startcode_found){\n<585> memcpy(s->bitstream_buffer, buf + current_pos, buf_size - current_pos);\n<645> if(num_end_markers || error){\n<647> fprintf(stderr, "concealing errors\n");\n<649> ff_error_resilience(s);\n<657> MPV_frame_end(s);\n<741> if(avctx->debug&FF_DEBUG_QP){\n<743> int8_t *qtab= pict->qscale_table;\n<749> for(y=0; y<s->mb_height; y++){\n<751> for(x=0; x<s->mb_width; x++){\n<753> printf("%2d ", qtab[x + y*s->mb_width]);\n<757> printf("\n");\n<761> printf("\n");\n<787> return get_consumed_bytes(s, buf_size);
<1> static void mpegts_push_data(void *opaque,\n<7> PESContext *pes = opaque;\n<21> pes->state = MPEGTS_HEADER;\n<27> p = buf;\n<31> switch(pes->state) {\n<35> len = PES_START_SIZE - pes->data_index;\n<37> if (len > buf_size)\n<39> len = buf_size;\n<41> memcpy(pes->header + pes->data_index, p, len);\n<43> pes->data_index += len;\n<45> p += len;\n<47> buf_size -= len;\n<49> if (pes->data_index == PES_START_SIZE) {\n<61> if (pes->header[0] == 0x00 && pes->header[1] == 0x00 &&\n<63> pes->header[2] == 0x01) {\n<69> code = pes->header[3] | 0x100;\n<77> if (!pes->st) {\n<95> st = av_new_stream(pes->stream, pes->pid);\n<111> pes->state = MPEGTS_PESHEADER_FILL;\n<113> pes->total_size = (pes->header[4] << 8) | pes->header[5];\n<121> pes->total_size += 6;\n<123> pes->pes_header_size = pes->header[8] + 9;\n<133> pes->state = MPEGTS_SKIP;\n<149> len = pes->pes_header_size - pes->data_index;\n<151> if (len > buf_size)\n<153> len = buf_size;\n<155> memcpy(pes->header + pes->data_index, p, len);\n<157> pes->data_index += len;\n<159> p += len;\n<161> buf_size -= len;\n<163> if (pes->data_index == pes->pes_header_size) {\n<175> pes->pts = AV_NOPTS_VALUE;\n<177> pes->dts = AV_NOPTS_VALUE;\n<181> pes->pts = get_pts(r);\n<187> pes->pts = get_pts(r);\n<191> pes->dts = get_pts(r);\n<199> pes->state = MPEGTS_PAYLOAD;\n<209> len = pes->total_size - pes->data_index;\n<221> if (len > 0) {\n<223> AVPacket *pkt = ts->pkt;\n<225> if (pes->st && av_new_packet(pkt, len) == 0) {\n<227> memcpy(pkt->data, p, len);
<1> static void * kq_init ( struct event_base * base ) {\n<4> if ( evutil_getenv ( "EVENT_NOKQUEUE" ) ) return ( NULL ) ;\n<5> if ( ! ( kqueueop = calloc ( 1 , sizeof ( struct kqop ) ) ) ) return ( NULL ) ;\n<6> if ( ( kq = kqueue ( ) ) == - 1 ) {\n<8> free ( kqueueop ) ;\n<11> kqueueop -> kq = kq ;\n<12> kqueueop -> pid = getpid ( ) ;\n<13> kqueueop -> changes = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n<14> if ( kqueueop -> changes == NULL ) {\n<15> free ( kqueueop ) ;\n<18> kqueueop -> events = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n<19> if ( kqueueop -> events == NULL ) {\n<20> free ( kqueueop -> changes ) ;\n<21> free ( kqueueop ) ;\n<24> kqueueop -> nevents = NEVENT ;\n<33> if ( kevent ( kq , kqueueop -> changes , 1 , kqueueop -> events , NEVENT , NULL ) != 1 || kqueueop -> events [ 0 ] . ident != - 1 || kqueueop -> events [ 0 ] . flags != EV_ERROR ) {\n<37> free ( kqueueop -> events ) ;\n<38> free ( kqueueop ) ;\n<42> return ( kqueueop ) ;
<1> int get_frame_filename(char *buf, int buf_size,\n<67> if (percentd_found)\n<73> snprintf(buf1, sizeof(buf1), "%0*d", nd, number);\n<75> len = strlen(buf1);\n<77> if ((q - buf + len) > buf_size - 1)\n<81> memcpy(q, buf1, len);\n<83> q += len;
<1> static inline void mix_2f_2r_to_mono(AC3DecodeContext *ctx)\n<15> memset(output[2], 0, sizeof(output[2]));\n<17> memset(output[3], 0, sizeof(output[3]));\n<19> memset(output[4], 0, sizeof(output[4]));
<1> void qxl_render_update(PCIQXLDevice *qxl)\n<87> if (!qxl->guest_primary.commands) {\n<107> memset(dirty, 0, sizeof(dirty));\n<111> dirty, ARRAY_SIZE(dirty), 1, QXL_SYNC);
<1> static int execute_code(AVCodecContext * avctx, int c)\n<171> if (s->y < avctx->height - s->font_height)\n<173> memset(s->frame.data[0] + (s->y + s->font_height)*s->frame.linesize[0],\n<175> DEFAULT_BG_COLOR, (avctx->height - s->y - s->font_height)*s->frame.linesize[0]);\n<183> if (s->y > 0)\n<185> memset(s->frame.data[0], DEFAULT_BG_COLOR, s->y * s->frame.linesize[0]);
<1> static DisplaySurface *qemu_create_message_surface(int w, int h,\n<3> const char *msg)\n<19> len = strlen(msg);\n<21> x = (w / FONT_WIDTH  - len) / 2;\n<27> glyph = qemu_pixman_glyph_from_vgafont(FONT_HEIGHT, vgafont16, msg[i]);
<1> static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n<21> draw_info -> text = ConstantString ( label ) ;\n<25> if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {\n<29> else if ( ( strlen ( label ) > 0 ) && ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) ) {\n<33> draw_info -> pointsize *= 2.0 ) {\n<44> high = draw_info -> pointsize ;\n<45> for ( low = 1.0 ;\n<46> ( high - low ) > 0.5 ;\n<61> draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ;
<39> dinfo = drive_get_by_blockdev(conf->bs);\n<41> if (*dinfo->serial) {\n<43> *serial = strdup(dinfo->serial);\n<69> s->serial = *serial;
<2> if ( RestoringToDB ( AH ) ) ReconnectToServer ( AH , dbname , NULL ) ;\n<6> ahprintf ( AH , "%s" , qry -> data ) ;\n<9> if ( AH -> currUser ) free ( AH -> currUser ) ;\n<11> if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n<13> if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;
<1> static int mp_decode_layer3(MPADecodeContext *s)\n<147> ff_compute_band_indexes(s, g);\n<171> if (!s->adu_mode) {\n<173> const uint8_t *ptr = s->gb.buffer + (get_bits_count(&s->gb)>>3);\n<175> int extrasize = av_clip(get_bits_left(&s->gb) >> 3, 0, EXTRABYTES);\n<187> memcpy(s->last_buf + s->last_buf_size, ptr, extrasize);\n<195> s->gb.size_in_bits_plus8 += FFMAX(extrasize, LAST_BUF_SIZE - s->last_buf_size) * 8;\n<209> g = &s->granules[ch][gr];\n<211> if (get_bits_count(&s->gb) < 0) {\n<219> memset(g->sb_hybrid, 0, sizeof(g->sb_hybrid));\n<453> exponents_from_scale_factors(s, g, exponents);\n<459> huffman_decode(s, g, exponents, bits_pos + g->part2_3_length);\n<477> reorder_block(s, g);\n<479> compute_antialias(s, g);\n<481> compute_imdct(s, g, &s->sb_samples[ch][18 * gr][0], s->mdct_buf[ch]);
<1> static void ide_identify(IDEState *s)\n<11> memset(s->io_buffer, 0, 512);\n<13> p = (uint16_t *)s->io_buffer;
<1> static int fill_note_info(struct elf_note_info *info,\n<17> (void) memset(info, 0, sizeof (*info));\n<21> TAILQ_INIT(&info->thread_list);\n<27> if (info->notes == NULL)\n<33> if (info->prstatus == NULL)\n<39> if (info->prstatus == NULL)\n<53> fill_prstatus(info->prstatus, ts, signr);\n<57> fill_note(&info->notes[0], "CORE", NT_PRSTATUS,\n<61> fill_psinfo(info->psinfo, ts);\n<63> fill_note(&info->notes[1], "CORE", NT_PRPSINFO,\n<75> for (i = 0; i < info->numnote; i++)\n<77> info->notes_size += note_size(&info->notes[i]);\n<91> fill_thread_info(info, cpu);
<1> ssize_t pcnet_receive ( NetClientState * nc , const uint8_t * buf , size_t size_ ) {\n<4> uint8_t buf1 [ 60 ] ;\n<7> int size = size_ ;\n<8> if ( CSR_DRX ( s ) || CSR_STOP ( s ) || CSR_SPND ( s ) || ! size || ( CSR_LOOP ( s ) && ! s -> looptest ) ) {\n<13> memcpy ( buf1 , buf , size ) ;\n<14> memset ( buf1 + size , 0 , MIN_BUF_SIZE - size ) ;\n<15> buf = buf1 ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> CamtasiaContext * const c = avctx -> priv_data ;\n<33> if ( c -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) {\n<34> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<35> if ( pal ) {\n<37> memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n<39> memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;
<1> real_parse_asm_rule(AVStream *st, const char *p, const char *end)\n<15> if (sscanf(p, " %*1[Aa]verage%*1[Bb]andwidth=%"SCNd64, &st->codec->bit_rate) == 1)\n<21> if (!(p = strchr(p, ',')) || p > end)\n<23> p = end;\n<25> p++;
<1> static DriveInfo *blockdev_init(const char *file, QDict *bs_opts,\n<157> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<175> if (!drv) {\n<189> memset(&cfg, 0, sizeof(cfg));\n<247> if (!check_throttle_config(&cfg, &error)) {\n<345> if (throttle_enabled(&cfg)) {\n<349> bdrv_set_io_limits(dinfo->bdrv, &cfg);
<1> int main(int argc, char *argv[])\n<15> if (argc < 3) {\n<17> printf("Usage: %s <infile.swf> <outfile.swf>\n", argv[0]);\n<51> if (read(fd_in, &buf_in, 8) != 8) {\n<53> printf("Header error\n");\n<65> if (buf_in[0] != 'C' || buf_in[1] != 'W' || buf_in[2] != 'S') {\n<67> printf("Not a compressed flash file\n");\n<83> printf("Compressed size: %d Uncompressed size: %d\n",\n<85> comp_len - 4, uncomp_len - 4);\n<103> zstream.zalloc = NULL;\n<105> zstream.zfree  = NULL;\n<107> zstream.opaque = NULL;\n<109> if (inflateInit(&zstream) != Z_OK) {\n<111> fprintf(stderr, "inflateInit failed\n");\n<133> zstream.next_in   = &buf_in[0];\n<135> zstream.avail_in  = len;\n<137> zstream.next_out  = &buf_out[0];\n<139> zstream.avail_out = 65536;\n<143> ret = inflate(&zstream, Z_SYNC_FLUSH);\n<145> if (ret != Z_STREAM_END && ret != Z_OK) {\n<147> printf("Error while decompressing: %d\n", ret);\n<157> dbgprintf("a_in: %d t_in: %lu a_out: %d t_out: %lu -- %lu out\n",\n<167> zstream.total_out - last_out) {\n<189> if (zstream.total_out != uncomp_len - 8) {\n<191> printf("Size mismatch (%lu != %d), updating header...\n",\n<193> zstream.total_out, uncomp_len - 8);\n<197> buf_in[0] =  (zstream.total_out + 8)        & 0xff;\n<199> buf_in[1] = ((zstream.total_out + 8) >>  8) & 0xff;\n<201> buf_in[2] = ((zstream.total_out + 8) >> 16) & 0xff;\n<203> buf_in[3] = ((zstream.total_out + 8) >> 24) & 0xff;\n<221> inflateEnd(&zstream);
<1> static void do_change_vnc(const char *target)\n<5> if (strcmp(target, "passwd") == 0 ||\n<7> strcmp(target, "password") == 0) {\n<9> char password[9];\n<11> monitor_readline("Password: ", 1, password, sizeof(password));\n<13> if (vnc_display_password(NULL, password) < 0)\n<19> if (vnc_display_open(NULL, target) < 0)
<1> static int decode_nal_units(HEVCContext *s, const uint8_t *buf, int length)\n<89> if (s->nals_allocated < s->nb_nals + 1) {\n<95> if (!tmp) {\n<103> s->nals = tmp;\n<105> memset(s->nals + s->nals_allocated, 0, (new_size - s->nals_allocated) * sizeof(*tmp));\n<159> hls_nal_unit(s);
<7> *cf_lut_status = av_malloc(sizeof(**cf_lut_status) * LUT_BUFF);\n<11> if (!cf_lut || !cf_lut_status) {\n<23> memset(*cf_lut_status, -1, sizeof(**cf_lut_status) * LUT_BUFF);
<1> static int vc1_decode_b_mb_intfr(VC1Context *v)\n<173> s->mb_intra = v->is_intra[s->mb_x] = 1;\n<223> vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n<257> s->mb_intra = v->is_intra[s->mb_x] = 0;\n<345> ff_vc1_mc_4mv_chroma4(v, 1, 1, 1);\n<351> ff_vc1_interp_mc(v);\n<385> ff_vc1_mc_4mv_chroma4(v, 1, 1, 1);\n<415> ff_vc1_interp_mc(v);\n<481> ff_vc1_mc_4mv_chroma4(v, dir, dir2, 0);\n<519> ff_vc1_mc_1mv(v, dir);\n<553> pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n<663> ff_vc1_mc_1mv(v, dir);\n<667> ff_vc1_interp_mc(v);\n<675> if (s->mb_x == s->mb_width - 1)\n<677> memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride);
<1> static int asf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n<5> ASFContext *asf = s->priv_data;\n<21> get_guid(pb, &g);\n<23> if (memcmp(&g, &asf_header, sizeof(GUID)))\n<27> get_le64(pb);\n<29> get_le32(pb);\n<31> get_byte(pb);\n<33> get_byte(pb);\n<35> memset(&asf->asfid2avid, -1, sizeof(asf->asfid2avid));\n<39> get_guid(pb, &g);\n<41> gsize = get_le64(pb);\n<53> if (gsize < 24)\n<57> if (!memcmp(&g, &file_header, sizeof(GUID))) {\n<59> get_guid(pb, &asf->hdr.guid);\n<61> asf->hdr.file_size		= get_le64(pb);\n<63> asf->hdr.create_time	= get_le64(pb);\n<65> asf->hdr.packets_count	= get_le64(pb);\n<67> asf->hdr.play_time		= get_le64(pb);\n<69> asf->hdr.send_time		= get_le64(pb);\n<71> asf->hdr.preroll		= get_le32(pb);\n<73> asf->hdr.ignore		= get_le32(pb);\n<75> asf->hdr.flags		= get_le32(pb);\n<77> asf->hdr.min_pktsize	= get_le32(pb);\n<79> asf->hdr.max_pktsize	= get_le32(pb);\n<81> asf->hdr.max_bitrate	= get_le32(pb);\n<83> asf->packet_size = asf->hdr.max_pktsize;\n<85> asf->nb_packets = asf->hdr.packets_count;\n<87> } else if (!memcmp(&g, &stream_header, sizeof(GUID))) {\n<97> pos1 = url_ftell(pb);\n<101> st = av_mallocz(sizeof(AVStream));\n<103> if (!st)\n<111> if (!asf_st)\n<119> get_guid(pb, &g);\n<121> if (!memcmp(&g, &audio_stream, sizeof(GUID))) {\n<123> type = CODEC_TYPE_AUDIO;\n<125> } else if (!memcmp(&g, &video_stream, sizeof(GUID))) {\n<127> type = CODEC_TYPE_VIDEO;\n<135> get_guid(pb, &g);\n<137> total_size = get_le64(pb);\n<139> get_le32(pb);\n<141> get_le32(pb);\n<143> st->id = get_le16(pb) & 0x7f; /* stream id */\n<147> asf->asfid2avid[st->id] = s->nb_streams++;\n<151> get_le32(pb);\n<153> st->codec.codec_type = type;\n<155> st->codec.frame_rate = 1000; // in packet ticks\n<157> if (type == CODEC_TYPE_AUDIO) {\n<301> pos2 = url_ftell(pb);\n<303> url_fskip(pb, gsize - (pos2 - pos1 + 24));\n<305> } else if (!memcmp(&g, &data_header, sizeof(GUID))) {\n<309> } else if (!memcmp(&g, &comment_header, sizeof(GUID))) {\n<315> len1 = get_le16(pb);\n<317> len2 = get_le16(pb);\n<319> len3 = get_le16(pb);\n<321> len4 = get_le16(pb);\n<323> len5 = get_le16(pb);\n<325> get_str16_nolen(pb, len1, s->title, sizeof(s->title));\n<327> get_str16_nolen(pb, len2, s->author, sizeof(s->author));\n<329> get_str16_nolen(pb, len3, s->copyright, sizeof(s->copyright));\n<331> get_str16_nolen(pb, len4, s->comment, sizeof(s->comment));\n<333> url_fskip(pb, len5);\n<395> } else if (url_feof(pb)) {\n<407> get_guid(pb, &g);\n<409> get_le64(pb);\n<411> get_byte(pb);\n<413> get_byte(pb);\n<415> if (url_feof(pb))\n<431> for(i=0;i<s->nb_streams;i++) {\n<449> return -1;
<1> static int qemu_rbd_create(const char *filename, QEMUOptionParameter *options)\n<27> if (qemu_rbd_parsename(filename, pool, sizeof(pool),\n<43> while (options && options->name) {\n<45> if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n<47> bytes = options->value.n;\n<49> } else if (!strcmp(options->name, BLOCK_OPT_CLUSTER_SIZE)) {\n<51> if (options->value.n) {\n<77> options++;\n<83> if (rados_create(&cluster, NULL) < 0) {\n<93> if (strstr(conf, "conf=") == NULL) {\n<95> if (rados_conf_read_file(cluster, NULL) < 0) {\n<109> if (conf[0] != '\0' &&\n<111> qemu_rbd_set_conf(cluster, conf) < 0) {
<1> static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {\n<5> if ( bitmap_pos < 0 ) {\n<7> bitmap_pos = ext_index_add_object ( object , name ) ;\n<8> free ( name ) ;
<1> ram_addr_t xen_ram_addr_from_mapcache(void *ptr)\n<19> if (reventry->vaddr_req == ptr) {\n<33> if (!found) {\n<35> fprintf(stderr, "%s, could not find %p\n", __func__, ptr);
<1> static int decode_frame(AVCodecContext *avctx,\n<99> buf += 20;\n<107> buf += 3;\n<119> avctx->sample_aspect_ratio.den = read32(&buf, endian);\n<247> ptr    = p->data[0];\n<253> if (source_packet_size*avctx->width*avctx->height > buf_end - buf) {\n<295> if (source_packet_size == target_packet_size) {\n<297> for (x = 0; x < avctx->height; x++) {\n<299> memcpy(ptr, buf, target_packet_size*avctx->width);\n<301> ptr += stride;\n<303> buf += source_packet_size*avctx->width;\n<311> uint8_t *dst = ptr;\n<313> for (y = 0; y < avctx->width; y++) {\n<315> memcpy(dst, buf, target_packet_size);\n<317> dst += target_packet_size;\n<319> buf += source_packet_size;
<1> static int local_symlink(FsContext *fs_ctx, const char *oldpath,\n<39> if (fd == -1) {\n<49> oldpath_size = strlen(oldpath);\n<53> write_size = write(fd, (void *)oldpath, oldpath_size);
<1> static gpgme_error_t status_handler ( void * opaque , int fd ) {\n<8> err = assuan_read_line ( gpgsm -> assuan_ctx , & line , & linelen ) ;\n<12> else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\0' || line [ 3 ] == ' ' ) ) {\n<13> if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n<17> else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\0' || line [ 2 ] == ' ' ) ) {\n<27> else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> colon . fnc ) {\n<33> if ( gpgsm -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n<34> char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n<35> if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n<37> * aline = newline ;\n<42> dst = * aline + * alinelen ;\n<58> err = gpgsm -> colon . fnc ( gpgsm -> colon . fnc_value , * aline ) ;\n<70> else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> inline_data ) {\n<98> else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n<101> rest = strchr ( line + 2 , ' ' ) ;\n<102> if ( ! rest ) rest = line + linelen ;\n<103> else * ( rest ++ ) = 0 ;\n<105> if ( r >= 0 ) {\n<108> else fprintf ( stderr , "[UNKNOWN STATUS]%s %s" , line + 2 , rest ) ;\n<111> else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\0' || line [ 7 ] == ' ' ) ) {
<1> static int net_socket_mcast_create(struct sockaddr_in *mcastaddr, struct in_addr *localaddr)\n<11> if (!IN_MULTICAST(ntohl(mcastaddr->sin_addr.s_addr))) {\n<13> fprintf(stderr, "qemu: error: specified mcastaddr \"%s\" (0x%08x) does not contain a multicast address\n",\n<15> inet_ntoa(mcastaddr->sin_addr),\n<17> (int)ntohl(mcastaddr->sin_addr.s_addr));
<1> static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n<2> free ( g ) ;
<1> static int decode_info_header(NUTContext *nut)\n<17> char name[256], str_value[1024], type_str[256];\n<89> get_str(bc, name, sizeof(name));\n<95> type = "UTF-8";\n<97> get_str(bc, str_value, sizeof(str_value));\n<103> type = type_str;\n<105> get_str(bc, str_value, sizeof(str_value));\n<109> type  = "s";\n<115> type  = "t";\n<121> type = "r";\n<127> type = "v";\n<133> if (stream_id_plus1 > s->nb_streams) {\n<143> if (!strcmp(type, "UTF-8")) {\n<145> if (chapter_id == 0 && !strcmp(name, "Disposition")) {\n<147> set_disposition_bits(s, str_value, stream_id_plus1 - 1);\n<155> if (stream_id_plus1 && !strcmp(name, "r_frame_rate")) {\n<157> sscanf(str_value, "%d/%d", &st->r_frame_rate.num, &st->r_frame_rate.den);\n<159> if (st->r_frame_rate.num >= 1000LL*st->r_frame_rate.den)\n<161> st->r_frame_rate.num = st->r_frame_rate.den = 0;\n<169> if (metadata && av_strcasecmp(name, "Uses") &&\n<171> av_strcasecmp(name, "Depends") && av_strcasecmp(name, "Replaces")) {\n<175> av_dict_set(metadata, name, str_value, 0);
<1> static int check_refcounts_l2(BlockDriverState *bs, BdrvCheckResult *res,\n<31> if (ret < 0) {\n<33> fprintf(stderr, "ERROR: I/O error in check_refcounts_l2\n");
<1> static void cin_decode_rle(const unsigned char *src, int src_size,\n<17> code = *src++;\n<19> if (code & 0x80) {\n<23> memset(dst, *src++, FFMIN(len, dst_end - dst));\n<29> memcpy(dst, src, FFMIN(len, dst_end - dst));\n<31> src += len;\n<35> dst += len;
<1> CPUState *ppc440ep_init(ram_addr_t *ram_size, PCIBus **pcip,\n<31> if (!env) {\n<33> fprintf(stderr, "Unable to initialize CPU!\n");\n<59> memset(ram_bases, 0, sizeof(ram_bases));\n<61> memset(ram_sizes, 0, sizeof(ram_sizes));\n<63> *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n<99> if (!*pcip)\n<101> printf("couldn't create PCI controller!\n");
<1> static void check_threshold_8(void){\n<41> memset(in,     0, WIDTH_PADDED);\n<43> memset(threshold, 0, WIDTH_PADDED);\n<45> memset(min, 0, WIDTH_PADDED);\n<47> memset(max, 0, WIDTH_PADDED);\n<49> memset(out_ref, 0, WIDTH_PADDED);\n<51> memset(out_new, 0, WIDTH_PADDED);\n<53> randomize_buffers(in, WIDTH);\n<55> randomize_buffers(threshold, WIDTH);\n<57> randomize_buffers(min, WIDTH);\n<59> randomize_buffers(max, WIDTH);\n<63> if (check_func(s.threshold, "threshold8")) {\n<65> call_ref(in, threshold, min, max, out_ref, line_size, line_size, line_size, line_size, line_size, w, 1);\n<67> call_new(in, threshold, min, max, out_new, line_size, line_size, line_size, line_size, line_size, w, 1);\n<69> if (memcmp(out_ref, out_new, w))\n<71> fail();\n<73> bench_new(in, threshold, min, max, out_new, line_size, line_size, line_size, line_size, line_size, w, 1);
<1> static void pk_transaction_authorize_actions_finished_cb ( GObject * source_object , GAsyncResult * res , struct AuthorizeActionsData * data ) {\n<3> PkTransactionPrivate * priv = data -> transaction -> priv ;\n<7> action_id = g_ptr_array_index ( data -> actions , 0 ) ;\n<27> if ( g_strcmp0 ( action_id , "org.freedesktop.packagekit.package-install" ) == 0 && pk_bitfield_contain ( priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_ALLOW_REINSTALL ) ) {\n<36> syslog ( LOG_AUTH | LOG_NOTICE , "uid %i failed to obtain auth" , priv -> uid ) ;\n<40> if ( data -> actions -> len <= 1 ) {\n<43> syslog ( LOG_AUTH | LOG_INFO , "uid %i obtained auth for %s" , priv -> uid , action_id ) ;
<59> av_freep(&st->codecpar->extradata);\n<67> if (!st->codecpar->extradata)\n<71> memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);
<1> int ff_h263_decode_mb(MpegEncContext *s,\n<83> else if (cbpc == 20)\n<85> fprintf(stderr, "Stuffing !");\n<559> if(mb_type<0 || mb_type>4){\n<561> printf("illegal MB_type\n");
<1> static int decorrelate(TAKDecContext *s, int c1, int c2, int length)\n<147> s->residues[i] = *p2++ >> dshift;\n<153> x = FF_ARRAY_ELEMS(s->residues) - filter_order;\n<155> for (; length2 > 0; length2 -= tmp) {\n<163> s->residues[filter_order + i] = *p2++ >> dshift;\n<175> v += s->adsp.scalarproduct_int16(&s->residues[i], s->filter,\n<181> v += s->residues[i + 7] * s->filter[7] +\n<183> s->residues[i + 6] * s->filter[6] +\n<185> s->residues[i + 5] * s->filter[5] +\n<187> s->residues[i + 4] * s->filter[4] +\n<189> s->residues[i + 3] * s->filter[3] +\n<191> s->residues[i + 2] * s->filter[2] +\n<193> s->residues[i + 1] * s->filter[1] +\n<195> s->residues[i    ] * s->filter[0];\n<209> memmove(s->residues, &s->residues[tmp], 2 * filter_order);
<1> static ssize_t test_block_read_func(QCryptoBlock *block,\n<5> size_t offset,\n<7> uint8_t *buf,\n<9> size_t buflen,\n<15> Buffer *header = opaque;\n<23> memcpy(buf, header->buffer + offset, buflen);\n<27> return buflen;
<1> void do_load_dcr (void)\n<11> if (loglevel != 0) {\n<13> fprintf(logfile, "No DCR environment\n");\n<19> } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n<21> if (loglevel != 0) {\n<23> fprintf(logfile, "DCR read error %d %03x\n", (int)T0, (int)T0);
<1> static void test_vector_dmul_scalar(const double *src0, const double *src1)\n<17> call_ref(cdst, src0, src1[0], LEN);\n<19> call_new(odst, src0, src1[0], LEN);\n<21> for (i = 0; i < LEN; i++) {\n<23> if (!double_near_abs_eps(cdst[i], odst[i], DBL_EPSILON)) {\n<25> fprintf(stderr, "%d: %- .12f - %- .12f = % .12g\n", i,\n<27> cdst[i], odst[i], cdst[i] - odst[i]);\n<37> bench_new(odst, src0, src1[0], LEN);
<1> static void ffmpeg_cleanup(int ret)\n<9> if (do_benchmark) {\n<11> int maxrss = getmaxrss() / 1024;\n<13> printf("bench: maxrss=%ikB\n", maxrss);
<1> static int load_dtb(hwaddr addr, const struct arm_boot_info *binfo)\n<17> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, binfo->dtb_filename);\n<19> if (!filename) {\n<21> fprintf(stderr, "Couldn't open dtb file %s\n", binfo->dtb_filename);\n<29> fdt = load_device_tree(filename, &size);\n<31> if (!fdt) {\n<33> fprintf(stderr, "Couldn't open dtb file %s\n", filename);\n<35> g_free(filename);\n<47> if (!fdt) {\n<49> fprintf(stderr, "Board was unable to create a dtb blob\n");\n<63> if (acells == 0 || scells == 0) {\n<65> fprintf(stderr, "dtb file invalid (#address-cells or #size-cells 0)\n");\n<73> if (scells < 2 && binfo->ram_size >= (1ULL << 32)) {\n<81> fprintf(stderr, "qemu: dtb file not compatible with "\n<97> if (rc < 0) {\n<99> fprintf(stderr, "couldn't set /memory/reg\n");\n<113> if (rc < 0) {\n<115> fprintf(stderr, "couldn't set /chosen/bootargs\n");\n<131> if (rc < 0) {\n<133> fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");\n<145> if (rc < 0) {\n<147> fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");
<1> static inline void mix_dualmono_to_mono(AC3DecodeContext *ctx)\n<15> memset(output[2], 0, sizeof(output[2]));
<1> static int ipvideo_decode_block_opcode_0xA_16 ( IpvideoContext * s ) {\n<3> uint16_t P [ 8 ] ;\n<8> x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n<9> if ( ! ( P [ 0 ] & 0x8000 ) ) {\n<31> x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n<32> vert = ! ( P [ 4 ] & 0x8000 ) ;\n<38> x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n<44> if ( y == 7 ) {\n<45> memcpy ( P , P + 4 , 8 ) ;
<1> static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n<25> if (rc != 0) {\n<27> fprintf(stderr, "virtio-scsi: Failed to set host notifier (%d)\n",\n<55> if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n<57> fprintf(stderr, "virtio-scsi: VRing setup failed\n");
<1> int _evsignal_set_handler ( struct event_base * base , int evsignal , void ( * handler ) ( int ) ) {\n<6> if ( evsignal >= sig -> sh_old_max ) {\n<9> p = realloc ( sig -> sh_old , new_max * sizeof ( * sig -> sh_old ) ) ;\n<10> if ( p == NULL ) {\n<11> event_warn ( "realloc" ) ;\n<14> memset ( ( char * ) p + sig -> sh_old_max * sizeof ( * sig -> sh_old ) , 0 , ( new_max - sig -> sh_old_max ) * sizeof ( * sig -> sh_old ) ) ;\n<18> sig -> sh_old [ evsignal ] = malloc ( sizeof * sig -> sh_old [ evsignal ] ) ;\n<19> if ( sig -> sh_old [ evsignal ] == NULL ) {\n<20> event_warn ( "malloc" ) ;\n<34> free ( sig -> sh_old [ evsignal ] ) ;
<1> static int vb_decode_framedata(VBDecContext *c, const uint8_t *buf, int offset)\n<23> prev = c->prev_frame + offset;\n<25> cur = c->frame;\n<37> blocktypes = bytestream_get_byte(&buf);\n<45> if(check_line(prev + y*width, pstart, pend))\n<47> memcpy(cur + y*width, prev + y*width, 4);\n<51> memset(cur + y*width, 0, 4);\n<57> t = bytestream_get_byte(&buf);\n<61> for(y = 0; y < 4; y++)\n<63> memcpy(cur + y*width, buf + y*4, 4);\n<65> buf += 16;\n<77> if(check_line(prev + t + y*width, pstart, pend))\n<79> memcpy(cur + y*width, prev + t + y*width, 4);\n<83> memset(cur + y*width, 0, 4);\n<91> t = bytestream_get_byte(&buf);\n<93> for(y = 0; y < 4; y++)\n<95> memset(cur + y*width, t, 4);\n<101> t = bytestream_get_byte(&buf);\n<111> a = bytestream_get_byte(&buf);\n<113> b = bytestream_get_byte(&buf);\n<119> cur[x + y*width] = (pattern & 1) ? b : a;\n<129> a = bytestream_get_byte(&buf);\n<137> cur[x + y*width] = prev[x + y*width];\n<141> cur[x + y*width] = a;\n<159> cur  += 4;\n<161> prev += 4;\n<169> cur  += width * 3;\n<171> prev += width * 3;
<1> static afs_int32 newEntry ( struct rx_call * call , char aname [ ] , afs_int32 flag , afs_int32 oid , afs_int32 * aid , afs_int32 * cid ) {\n<6> stolower ( aname ) ;\n<15> code = WhoIsThisWithName ( call , tt , cid , cname ) ;\n<16> if ( code != 2 ) {\n<21> admin = ( ( ! restricted && ! strcmp ( aname , cname ) ) ) || IsAMemberOf ( tt , * cid , SYSADMINID ) ;\n<24> if ( ! CreateOK ( tt , * cid , oid , flag , admin ) ) ABORT_WITH ( tt , PRPERM ) ;\n<25> code = CreateEntry ( tt , aname , aid , 0 , flag , oid , * cid ) ;
<1> static int http_prepare_data(HTTPContext *c)\n<11> switch(c->state) {\n<15> memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));\n<45> st = av_mallocz(sizeof(AVStream));\n<55> memcpy(st, c->stream->streams[i], sizeof(AVStream));\n<59> memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]],\n<87> av_write_header(&c->fmt_ctx);
<1> QemuOpts *qemu_opts_find(QemuOptsList *list, const char *id)\n<9> TAILQ_FOREACH(opts, &list->head, next) {\n<11> if (!opts->id) {\n<17> if (strcmp(opts->id, id) != 0) {\n<23> return opts;
<1> static void l2cap_channel_close(struct l2cap_instance_s *l2cap,\n<35> if (ch->remote_cid != source_cid) {\n<37> fprintf(stderr, "%s: Ignoring a Disconnection Request with the "
<1> QEMUFile *qemu_popen_cmd(const char *command, const char *mode)\n<21> if (mode == NULL || (mode[0] != 'r' && mode[0] != 'w') || mode[1] != 0) {\n<23> fprintf(stderr, "qemu_popen: Argument validity check failed\n");
<1> void net_cleanup(void)\n<19> for(vc = vlan->first_client; vc != NULL; vc = vc->next) {\n<21> if (vc->fd_read == tap_receive) {\n<23> char ifname[64];\n<29> if (strcmp(vc->model, "tap") == 0 &&\n<31> sscanf(vc->info_str, "ifname=%63s ", ifname) == 1 &&\n<33> s->down_script[0])\n<35> launch_script(s->down_script, ifname, s->fd);
<1> static BlockDriver *find_protocol(const char *filename)\n<25> p = strchr(filename, ':');\n<27> if (!p)\n<31> len = p - filename;\n<33> if (len > sizeof(protocol) - 1)\n<35> len = sizeof(protocol) - 1;\n<37> memcpy(protocol, filename, len);\n<39> protocol[len] = '\0';\n<41> QLIST_FOREACH(drv1, &bdrv_drivers, list) {\n<43> if (drv1->protocol_name &&\n<45> !strcmp(drv1->protocol_name, protocol)) {
<1> static void ahci_test_identify(AHCIQState *ahci)\n<17> uint16_t buff[256];\n<103> memset(&cmd, 0x00, sizeof(cmd));\n<131> memset(&fis, 0x00, sizeof(fis));\n<151> memwrite(table, &fis, sizeof(fis));\n<163> ahci_set_command_header(ahci, i, cx, &cmd);\n<227> ahci_get_command_header(ahci, i, cx, &cmd);\n<269> memread(data_ptr, &buff, 512);\n<283> string_bswap16(&buff[10], 20);\n<285> rc = memcmp(&buff[10], "testdisk            ", 20);\n<291> string_bswap16(&buff[23], 8);\n<293> rc = memcmp(&buff[23], "version ", 8);
<1> void do_migrate_set_downtime(Monitor *mon, const QDict *qdict)\n<13> d = strtod(value, &ptr);\n<15> if (!strcmp(ptr,"ms")) {\n<17> d *= 1000000;\n<19> } else if (!strcmp(ptr,"us")) {\n<21> d *= 1000;\n<23> } else if (!strcmp(ptr,"ns")) {\n<29> d *= 1000000000;
<1> static void musicpal_init(MachineState *machine)\n<53> if (!cpu) {\n<55> fprintf(stderr, "Unable to find CPU definition\n");\n<133> if (flash_size != 8*1024*1024 && flash_size != 16*1024*1024 &&\n<137> fprintf(stderr, "Invalid flash image size\n");
<1> void ff_atrac_iqmf(float *inlo, float *inhi, unsigned int nIn, float *pOut, float *delayBuf, float *temp)\n<11> memcpy(temp, delayBuf, 46*sizeof(float));\n<15> p3 = temp + 46;\n<37> p1 = temp;\n<73> memcpy(delayBuf, temp + nIn*2, 46*sizeof(float));
<1> static int microblaze_load_dtb(target_phys_addr_t addr,\n<65> if (kernel_cmdline) {
<1> static int ws_snd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<3> const uint8_t * buf = avpkt -> data ;\n<6> int sample = 128 ;\n<16> buf += 4 ;\n<26> samples = frame -> data [ 0 ] ;\n<28> if ( in_size == out_size ) {\n<29> memcpy ( samples , buf , out_size ) ;\n<37> count = * buf & 0x3F ;\n<49> if ( samples_end - samples < smp ) break ;\n<51> if ( ( buf - avpkt -> data ) + size > buf_size ) break ;\n<52> switch ( code ) {\n<57> sample += ( code & 0x3 ) - 2 ;\n<67> sample = av_clip_uint8 ( sample ) ;\n<75> sample += ws_adpcm_4bit [ code & 0xF ] ;\n<79> sample = av_clip_uint8 ( sample ) ;\n<83> case 2 : if ( count & 0x20 ) {\n<87> sample += t >> 3 ;\n<88> sample = av_clip_uint8 ( sample ) ;\n<92> memcpy ( samples , buf , smp ) ;\n<93> samples += smp ;\n<94> buf += smp ;\n<95> sample = buf [ - 1 ] ;\n<98> default : memset ( samples , sample , smp ) ;\n<99> samples += smp ;
<1> static void test_qemu_strtoul_negative(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoul(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> struct pxa2xx_state_s *pxa270_init(unsigned int sdram_size,\n<17> if (revision && strncmp(revision, "pxa27", 5)) {\n<19> fprintf(stderr, "Machine requires a PXA27x processor.\n");
<1> int keysym2scancode(void *kbd_layout, int keysym)\n<9> if (k->keysym2keycode[keysym] == 0) {\n<11> trace_keymap_unmapped(keysym);\n<13> fprintf(stderr, "Warning: no scancode found for keysym %d\n",
<1> static int set_string_number(void *obj, const AVOption *o, const char *val, void *dst)\n<31> buf[i] = 0;\n<37> const AVOption *o_named = av_opt_find(obj, buf, o->unit, 0, 0);\n<39> if (o_named && o_named->type == AV_OPT_TYPE_CONST)\n<43> else if (!strcmp(buf, "default")) d = DEFAULT_NUMVAL(o);\n<45> else if (!strcmp(buf, "max"    )) d = o->max;\n<47> else if (!strcmp(buf, "min"    )) d = o->min;\n<49> else if (!strcmp(buf, "none"   )) d = 0;\n<51> else if (!strcmp(buf, "all"    )) d = ~0;\n<55> int res = av_expr_parse_and_eval(&d, buf, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj);\n<57> if (res < 0) {\n<69> if (o->type == AV_OPT_TYPE_FLAGS) {\n<89> if ((ret = write_number(obj, o, dst, d, 1, 1)) < 0)
<1> static void setup_sigframe_v2(struct target_ucontext_v2 *uc,\n<19> memset(&stack, 0, sizeof(stack));\n<27> memcpy(&uc->tuc_stack, &stack, sizeof(stack));
<1> static const char *srt_to_ass(AVCodecContext *avctx, char *out, char *out_end,\n<3> const char *in, int x1, int y1, int x2, int y2)\n<7> char c, *param, buffer[128], tmp[128];\n<9> int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n<11> SrtStack stack[16];\n<41> for (; out < out_end && !end && *in; in++) {\n<43> switch (*in) {\n<81> an += sscanf(in, "{\\an%*1u}%c", &c) == 1;\n<83> if ((an != 1 && sscanf(in, "{\\%*[^}]}%n%c", &len, &c) > 0) ||\n<85> sscanf(in, "{%*1[CcFfoPSsYy]:%*[^}]}%n%c", &len, &c) > 0) {\n<87> in += len - 1;\n<91> *out++ = *in;\n<97> tag_close = in[1] == '/';\n<99> if (sscanf(in+tag_close+1, "%127[^>]>%n%c", buffer, &len,&c) >= 2) {\n<101> if ((param = strchr(buffer, ' ')))\n<103> *param++ = 0;\n<105> if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack)) ||\n<107> ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, buffer))) {\n<109> int i, j, unknown = 0;\n<111> in += len + tag_close;\n<113> if (!tag_close)\n<115> memset(stack+sptr, 0, sizeof(*stack));\n<117> if (!strcmp(buffer, "font")) {\n<119> if (tag_close) {\n<123> if (stack[sptr-1].param[i][0])\n<125> for (j=sptr-2; j>=0; j--)\n<139> while (param) {\n<141> if (!strncmp(param, "size=", 5)) {\n<145> param += 5 + (param[5] == '"');\n<147> if (sscanf(param, "%u", &font_size) == 1) {\n<149> snprintf(stack[sptr].param[PARAM_SIZE],\n<151> sizeof(stack[0].param[PARAM_SIZE]),\n<159> param += 6 + (param[6] == '"');\n<167> html_color_parse(avctx, param));\n<169> } else if (!strncmp(param, "face=", 5)) {\n<171> param += 5 + (param[5] == '"');\n<175> param[-1] == '"' ? "\"" :" ");\n<179> FFMIN(sizeof(tmp), len+1));\n<181> param += len;\n<191> if ((param = strchr(param, ' ')))\n<193> param++;\n<207> } else if (!buffer[1] && strspn(buffer, "bisu") == 1) {\n<209> out += snprintf(out, out_end-out,\n<211> "{\\%c%d}", buffer[0], !tag_close);\n<215> unknown = 1;\n<217> snprintf(tmp, sizeof(tmp), "</%s>", buffer);\n<221> if (tag_close) {\n<223> sptr--;\n<225> } else if (unknown && !strstr(in, tmp)) {\n<227> in -= len + tag_close;\n<229> *out++ = *in;\n<233> av_strlcpy(stack[sptr++].tag, buffer,\n<235> sizeof(stack[0].tag));\n<245> *out++ = *in;
<1> int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src)\n<11> if (avcodec_is_open(dest)) { // check that the dest context is uninitialized\n<25> av_opt_free(dest);\n<27> av_free(dest->priv_data);\n<31> memcpy(dest, src, sizeof(*dest));\n<67> dest->rc_eq = av_strdup(src->rc_eq);\n<69> if (!dest->rc_eq)\n<79> if (src->obj && size > 0) { \\n<83> if (!dest->obj) \\n<87> memcpy(dest->obj, src->obj, size); \\n<89> if (pad) \\n<91> memset(((uint8_t *) dest->obj) + size, 0, pad); \\n<107> dest->subtitle_header_size = src->subtitle_header_size;\n<119> av_freep(&dest->rc_override);\n<121> av_freep(&dest->intra_matrix);\n<123> av_freep(&dest->inter_matrix);\n<125> av_freep(&dest->extradata);\n<127> av_freep(&dest->rc_eq);
<1> static void add_cpreg_to_hashtable(ARMCPU *cpu, const ARMCPRegInfo *r,\n<17> ARMCPRegInfo *r2 = g_memdup(r, sizeof(ARMCPRegInfo));\n<157> *key = ENCODE_CP_REG(r2->cp, is64, ns, r2->crn, crm, opc1, opc2);\n<181> r2->crm = crm;\n<183> r2->opc1 = opc1;\n<185> r2->opc2 = opc2;\n<225> if (oldreg && !(oldreg->type & ARM_CP_OVERRIDE)) {\n<227> fprintf(stderr, "Register redefined: cp=%d %d bit "\n<231> "was %s, now %s\n", r2->cp, 32 + 32 * is64,\n<243> g_hash_table_insert(cpu->cp_regs, key, r2);
<1> void qbus_create_inplace(BusState *bus, BusInfo *info,\n<25> } else if (parent && parent->id) {\n<29> len = strlen(parent->id) + 16;\n<31> buf = qemu_malloc(len);\n<33> snprintf(buf, len, "%s.%d", parent->id, parent->num_child_bus);\n<41> len = strlen(info->name) + 16;\n<43> buf = qemu_malloc(len);
<1> static int mpeg_mux_write_packet(AVFormatContext *ctx, AVPacket *pkt)\n<11> uint8_t *buf= pkt->data;\n<15> StreamInfo *stream = st->priv_data;\n<161> while (size > 0) {\n<169> len = avail_size - stream->buffer_ptr;\n<171> if (len > size)\n<173> len = size;\n<175> memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n<177> stream->buffer_ptr += len;\n<179> buf += len;\n<181> size -= len;
<1> static void pxa2xx_lcdc_write(void *opaque, hwaddr offset,\n<25> if (!(s->control[0] & LCCR0_LCDT) && (value & LCCR0_LCDT))\n<27> printf("%s: internal frame buffer unsupported\n", __FUNCTION__);\n<97> if (!(s->ovl1c[0] & OVLC1_EN) && (value & OVLC1_EN))\n<99> printf("%s: Overlay 1 not supported\n", __FUNCTION__);\n<121> if (!(s->ovl2c[0] & OVLC1_EN) && (value & OVLC1_EN))\n<123> printf("%s: Overlay 2 not supported\n", __FUNCTION__);\n<149> if (!(s->ccr & CCR_CEN) && (value & CCR_CEN))\n<151> printf("%s: Hardware cursor unimplemented\n", __FUNCTION__);
<1> static int alloc_refcount_block(BlockDriverState *bs,\n<93> *refcount_block = NULL;\n<105> int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n<127> if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n<135> if (ret < 0) {\n<143> memset(*refcount_block, 0, s->cluster_size);\n<161> ret = update_refcount(bs, new_block, s->cluster_size, 1);\n<183> if (ret < 0) {\n<191> memset(*refcount_block, 0, s->cluster_size);\n<201> qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n<245> if (ret < 0) {\n<291> uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n<299> uint64_t table_clusters = size_to_clusters(s, table_size);\n<345> uint64_t *new_table = g_malloc0(table_size * sizeof(uint64_t));\n<357> s->refcount_table_size * sizeof(uint64_t));\n<375> uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n<409> cpu_to_be64s(&new_table[i]);\n<417> ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n<431> cpu_to_be64s(&new_table[i]);\n<467> g_free(s->refcount_table);\n<469> s->refcount_table = new_table;\n<503> g_free(new_table);
<1> static void decode_block(BinkAudioContext *s, short *out, int use_dct)\n<23> FFTSample *coeffs = s->coeffs_ptr[ch];\n<27> coeffs[0] = get_float(gb) * s->root;\n<29> coeffs[1] = get_float(gb) * s->root;\n<59> while (i < s->frame_len) {\n<79> if (width == 0) {\n<81> memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n<103> coeffs[i] = -q * coeff;\n<107> coeffs[i] =  q * coeff;\n<111> coeffs[i] = 0.0f;\n<143> s->fmt_conv.float_to_int16_interleave(out, (const float **)s->coeffs_ptr,\n<157> out[i] = (s->previous[i] * (count - i) + out[i] * i) >> shift;\n<167> s->overlap_len * s->channels * sizeof(*out));
<1> static int openfile(char *name, int flags)\n<5> if (bs) {\n<7> fprintf(stderr, "file open already, try 'help close'\n");\n<23> if (bdrv_open(bs, name, flags) == -1) {\n<25> fprintf(stderr, "%s: can't open device %s\n", progname, name);
<1> int acpi_table_add(const char *t)\n<5> static const char *dfl_id = "QEMUQEMU";\n<21> memset(&acpi_hdr, 0, sizeof(acpi_hdr));\n<25> if (get_param_value(buf, sizeof(buf), "sig", t)) {\n<27> strncpy(acpi_hdr.signature, buf, 4);\n<31> strncpy(acpi_hdr.signature, dfl_id, 4);\n<37> val = strtoul(buf, &p, 10);\n<39> if (val > 255 || *p != '\0')\n<53> if (get_param_value(buf, sizeof(buf), "oem_id", t)) {\n<55> strncpy(acpi_hdr.oem_id, buf, 6);\n<59> strncpy(acpi_hdr.oem_id, dfl_id, 6);\n<65> if (get_param_value(buf, sizeof(buf), "oem_table_id", t)) {\n<67> strncpy(acpi_hdr.oem_table_id, buf, 8);\n<71> strncpy(acpi_hdr.oem_table_id, dfl_id, 8);\n<79> val = strtol(buf, &p, 10);\n<81> if(*p != '\0')\n<95> if (get_param_value(buf, sizeof(buf), "asl_compiler_id", t)) {\n<97> strncpy(acpi_hdr.asl_compiler_id, buf, 4);\n<101> strncpy(acpi_hdr.asl_compiler_id, dfl_id, 4);\n<109> val = strtol(buf, &p, 10);\n<111> if(*p != '\0')\n<137> f = buf;\n<139> while (buf[0]) {\n<143> char *n = strchr(f, ':');\n<149> if(stat(f, &s) < 0) {\n<151> fprintf(stderr, "Can't stat file '%s': %s\n", f, strerror(errno));\n<159> if (!n)\n<165> f = n + 1;\n<191> p += sizeof(uint16_t);\n<193> memcpy(p, &acpi_hdr, sizeof(acpi_hdr));\n<199> f = buf;\n<201> while (buf[0]) {\n<207> char *n = strchr(f, ':');\n<213> fd = open(f, O_RDONLY);\n<239> r = read(fd, p + off, s.st_size);\n<261> if (!n)\n<265> f = n + 1;\n<269> if (off < length) {\n<273> memset(p + off, 0, length - off);\n<279> acpi_hdr_p = (struct acpi_table_header*)p;\n<283> acpi_hdr_p->checksum = acpi_checksum((uint8_t*)p, length);
<1> static void taihu_405ep_init(ram_addr_t ram_size,\n<125> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<137> if (bios_size < 0 || bios_size > BIOS_SIZE) {\n<139> fprintf(stderr, "qemu: could not load PowerPC bios '%s'\n",\n<221> kernel_size = load_image_targphys(kernel_filename, kernel_base,\n<225> if (kernel_size < 0) {\n<227> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<241> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<245> if (initrd_size < 0) {
<1> static void virtio_scsi_command_complete(SCSIRequest *r, uint32_t status,\n<27> if (req->resp.cmd->status == GOOD) {\n<35> sense_len = scsi_req_get_sense(r, sense, sizeof(sense));\n<37> sense_len = MIN(sense_len, req->resp_size - sizeof(req->resp.cmd));\n<39> memcpy(req->resp.cmd->sense, sense, sense_len);\n<41> req->resp.cmd->sense_len = tswap32(sense_len);
<1> static void apply_window_mp3(float *in, float *win, int *unused, float *out,\n<23> memcpy(in + 512, in, 32 * sizeof(*in));\n<27> apply_window(in + 16, win     , win + 512, suma, sumc, 16);\n<29> apply_window(in + 32, win + 48, win + 640, sumb, sumd, 16);\n<33> SUM8(MACS, suma[0], win + 32, in + 48);\n<121> SUM8(MLSS, sum, win + 16 + 32, in + 32);
<1> int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples)\n<7> short *bufin[2];\n<11> short *buftmp2[2], *buftmp3[2];\n<17> if (s->input_channels == s->output_channels && s->ratio == 1.0 && 0) {\n<21> memcpy(output, input, nb_samples * s->input_channels * sizeof(short));\n<31> for(i=0; i<s->filter_channels; i++){\n<33> bufin[i]= (short*) av_malloc( (nb_samples + s->temp_len) * sizeof(short) );\n<35> memcpy(bufin[i], s->temp[i], s->temp_len * sizeof(short));\n<37> buftmp2[i] = bufin[i] + s->temp_len;\n<61> } else if (s->output_channels >= 2 && s->input_channels == 1) {\n<65> memcpy(buftmp2[0], input, nb_samples*sizeof(short));\n<67> } else if (s->output_channels >= 2) {\n<79> memcpy(buftmp2[0], input, nb_samples*sizeof(short));\n<93> for(i=0;i<s->filter_channels;i++) {\n<101> nb_samples1 = av_resample(s->resample_context, buftmp3[i], bufin[i], &consumed, nb_samples, lenout, is_last);\n<103> s->temp_len= nb_samples - consumed;\n<105> s->temp[i]= av_realloc(s->temp[i], s->temp_len*sizeof(short));\n<107> memcpy(s->temp[i], bufin[i] + consumed, s->temp_len*sizeof(short));\n<131> av_free(bufin[i]);
<1> static void opt_audio_sample_fmt(const char *arg)\n<5> if (strcmp(arg, "list"))\n<7> audio_sample_fmt = av_get_sample_fmt(arg);\n<11> list_fmts(av_get_sample_fmt_string, AV_SAMPLE_FMT_NB);\n<13> ffmpeg_exit(0);
<1> static int mpegts_write_packet_internal(AVFormatContext *s, AVPacket *pkt)\n<7> int size = pkt->size;\n<9> uint8_t *buf = pkt->data;\n<15> MpegTSWriteStream *ts_st = st->priv_data;\n<79> if (pkt->size < 5 || AV_RB32(pkt->data) != 0x0000001) {\n<107> if (!data)\n<111> memcpy(data + 6, pkt->data, pkt->size);\n<119> buf     = data;\n<121> size    = pkt->size + 6;\n<185> size            = avio_close_dyn_buf(ts_st->amux->pb, &data);\n<189> buf             = data;\n<213> if (ts_st->payload_size + size > ts->pes_payload_size) {\n<217> mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_size,\n<227> if (size > ts->pes_payload_size) {\n<243> if (!ts_st->payload_size) {\n<255> memcpy(ts_st->payload + ts_st->payload_size, buf, size);\n<257> ts_st->payload_size += size;
<1> int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt) {\n<5> uint8_t tk[8][4];\n<57> if(key_bits!=128 && key_bits!=192 && key_bits!=256)\n<67> memcpy(tk, key, KC*4);\n<71> for(t= 0; t < (rounds+1)*16;) {\n<73> memcpy(a->round_key[0][0]+t, tk, KC*4);\n<105> for(i=1; i<rounds; i++){\n<107> uint8_t tmp[3][16];\n<109> memcpy(tmp[2], a->round_key[i][0], 16);\n<113> mix(tmp, dec_multbl, 1, 3);\n<115> memcpy(a->round_key[i][0], tmp[0], 16);
<1> void * xmalloc ( size_t size ) {\n<2> void * ptr = malloc ( size ) ;\n<3> if ( ! ptr && ( size != 0 ) ) {
<1> static int vp3_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n<5> if ( s != s1 ) copy_fields ( s , s1 , golden_frame , current_frame ) ;
<1> int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,\n<3> AVFilterInOut *open_inputs,\n<23> filters += strspn(filters, WHITESPACES);\n<27> if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)\n<33> if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)\n<53> if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)\n<59> if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n<67> filters += strspn(filters, WHITESPACES);\n<69> chr = *filters++;\n<73> if (chr == ';' && curr_inputs) {\n<89> } while (chr == ',' || chr == ';');\n<93> if (chr) {\n<109> if (open_inputs && !strcmp(open_inputs->name, "out") && curr_inputs) {\n<113> const char *tmp = "[out]";\n<115> if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,\n<125> return 0;\n<133> free_inout(open_inputs);\n<137> free_inout(curr_inputs);
<1> void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n<13> if (vga_ioport_invalid(s, addr)) {\n<147> s->dac_cache[s->dac_sub_index] = val;\n<149> if (++s->dac_sub_index == 3) {\n<151> memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);
<1> timer_write(void *opaque, hwaddr addr,\n<13> uint32_t value = val64;\n<19> timer = timer_from_addr(addr);\n<23> D(fprintf(stderr, "%s addr=%x val=%x (timer=%d off=%d)\n",\n<25> __func__, addr * 4, value, timer, addr & 3));\n<37> if (value & TCSR_TINT)\n<57> xt->regs[addr] = value;
<1> static BlockDriverState *bdrv_new_open(const char *filename,\n<45> if (bdrv_open(bs, filename, flags, drv) < 0) {\n<53> if (bdrv_is_encrypted(bs)) {\n<55> printf("Disk image '%s' is encrypted.\n", filename);
<1> int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n<9> MOVTrack *trk = &mov->tracks[pkt->stream_index];\n<11> AVCodecContext *enc = trk->enc;\n<61> if ((ret = mov_flush_fragment_interleaving(s, trk)) < 0)\n<113> len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n<153> trk->vos_data = av_malloc(trk->vos_len);\n<155> if (!trk->vos_data) {\n<163> memcpy(trk->vos_data, enc->extradata, trk->vos_len);\n<189> if (enc->codec_id == AV_CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1 && !TAG_IS_AVCI(trk->tag)) {\n<197> ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,\n<207> size = ff_mov_cenc_avc_parse_nal_units(&trk->cenc, pb, pkt->data, size);\n<219> size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);\n<225> } else if (enc->codec_id == AV_CODEC_ID_HEVC && trk->vos_len > 6 &&\n<227> (AV_RB24(trk->vos_data) == 1 || AV_RB32(trk->vos_data) == 1)) {\n<233> ff_hevc_annexb2mp4_buf(pkt->data, &reformatted_data, &size, 0, NULL);\n<239> size = ff_hevc_annexb2mp4(pb, pkt->data, pkt->size, 0, NULL);\n<269> ret = ff_mov_cenc_avc_write_nal_units(s, &trk->cenc, nal_size_length, pb, pkt->data, size);\n<273> ret = ff_mov_cenc_write_packet(&trk->cenc, pb, pkt->data, size);\n<287> avio_write(pb, pkt->data, size);\n<297> enc->codec_id == AV_CODEC_ID_AC3) && !trk->vos_len) {\n<303> trk->vos_data = av_malloc(size);\n<305> if (!trk->vos_data) {\n<313> memcpy(trk->vos_data, pkt->data, size);\n<339> trk->cluster[trk->entry].pos              = avio_tell(pb) - size;\n<507> mov_parse_vc1_frame(pkt, trk);\n<515> mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);\n<543> ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,
<1> ASN1_BIT_STRING * c2i_ASN1_BIT_STRING ( ASN1_BIT_STRING * * a , const unsigned char * * pp , long len ) {\n<15> i = * ( p ++ ) ;\n<18> if ( len -- > 1 ) {\n<20> if ( s == NULL ) {\n<24> memcpy ( s , p , ( int ) len ) ;\n<25> s [ len - 1 ] &= ( 0xff << i ) ;\n<26> p += len ;\n<31> ret -> data = s ;
<1> char *qmp_human_monitor_command(const char *command_line, bool has_cpu_index,\n<13> memset(&hmp, 0, sizeof(hmp));\n<23> cur_mon = &hmp;\n<47> handle_user_command(&hmp, command_line);\n<53> if (qstring_get_length(hmp.outbuf) > 0) {\n<55> output = g_strdup(qstring_get_str(hmp.outbuf));\n<67> QDECREF(hmp.outbuf);
<1> void cpu_loop (CPUState *env)\n<13> trapnr = cpu_alpha_exec (env);\n<17> switch (trapnr) {\n<21> fprintf(stderr, "Reset requested. Exit\n");\n<29> fprintf(stderr, "Machine check exception. Exit\n");\n<37> fprintf(stderr, "Arithmetic trap.\n");\n<45> fprintf(stderr, "External interrupt. Exit\n");\n<53> fprintf(stderr, "MMU data fault\n");\n<61> fprintf(stderr, "MMU data TLB miss in PALcode\n");\n<69> fprintf(stderr, "MMU instruction TLB miss\n");\n<77> fprintf(stderr, "MMU instruction access violation\n");\n<85> fprintf(stderr, "MMU data TLB miss\n");\n<93> fprintf(stderr, "Unaligned access\n");\n<101> fprintf(stderr, "Invalid instruction\n");\n<109> fprintf(stderr, "Floating-point not allowed\n");\n<123> fprintf(stderr, "Privileged call to PALcode\n");\n<159> printf ("Unhandled trap: 0x%x\n", trapnr);\n<161> cpu_dump_state(env, stderr, fprintf, 0);\n<167> process_pending_signals (env);
<1> int ff_mjpeg_find_marker(MJpegDecodeContext *s,\n<17> av_fast_padded_malloc(&s->buffer, &s->buffer_size, buf_end - *buf_ptr);\n<19> if (!s->buffer)\n<27> if (start_code == SOS && !s->ls) {\n<69> *unescaped_buf_size = dst - s->buffer;\n<81> } else if (start_code == SOS && s->ls) {\n<155> *unescaped_buf_size = (bit_count + 7) >> 3;
<1> static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,\n<67> if (guid_eq(header->log_guid, zero_guid)) {\n<99> sector_offset = offset % VHDX_LOG_SECTOR_SIZE;\n<113> leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);\n<167> new_hdr.log_guid = header->log_guid;\n<171> desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);\n<177> new_hdr.entry_length = total_length;\n<181> vhdx_log_entry_hdr_le_export(&new_hdr);\n<185> buffer = qemu_blockalign(bs, total_length);\n<187> memcpy(buffer, &new_hdr, sizeof(new_hdr));\n<191> new_desc = (VHDXLogDescriptor *) (buffer + sizeof(new_hdr));\n<193> data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);\n<195> data_tmp = data;\n<205> merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);\n<219> if (i == 0 && leading_length) {\n<223> ret = bdrv_pread(bs->file, file_offset, merged_sector,\n<227> if (ret < 0) {\n<233> memcpy(merged_sector + sector_offset, data_tmp, leading_length);\n<235> bytes_written = leading_length;\n<239> } else if (i == sectors - 1 && trailing_length) {\n<247> merged_sector + trailing_length,\n<249> VHDX_LOG_SECTOR_SIZE - trailing_length);\n<251> if (ret < 0) {\n<257> memcpy(merged_sector, data_tmp, trailing_length);\n<259> bytes_written = trailing_length;\n<261> sector_write = merged_sector;\n<285> data_tmp += bytes_written;\n<345> qemu_vfree(buffer);\n<347> qemu_vfree(merged_sector);
<1> static void s390_init(MachineState *machine)\n<87> virtio_region_len = my_ram_size - ram_size;\n<91> virtio_region = cpu_physical_memory_map(virtio_region_start,\n<95> memset(virtio_region, 0, virtio_region_len);\n<97> cpu_physical_memory_unmap(virtio_region, virtio_region_len, 1,
<1> static int qcow2_create2(const char *filename, int64_t total_size,\n<81> if (ret < 0) {\n<91> memset(&header, 0, sizeof(header));\n<123> ret = bdrv_pwrite(bs, 0, &header, sizeof(header));
<1> static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n<19> memset(&info, 0x0, cmd->iov_size);\n<21> if (cmd->iov_size < dcmd_size) {\n<91> memcpy(info.product_name, "MegaRAID SAS 8708EM2", 20);\n<97> memcpy(info.image_component[0].name, "APP", 3);\n<101> memcpy(info.image_component[0].build_date, __DATE__, 11);\n<103> memcpy(info.image_component[0].build_time, __TIME__, 8);\n<107> if (pci_dev->has_rom) {\n<109> uint8_t biosver[32];\n<115> ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n<117> memcpy(biosver, ptr + 0x41, 31);\n<119> memcpy(info.image_component[1].name, "BIOS", 4);\n<121> memcpy(info.image_component[1].version, biosver,\n<123> strlen((const char *)biosver));\n<229> cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
<1> static void vmsvga_bios_write(void *opaque, uint32_t address, uint32_t data)\n<5> printf("%s: what are we supposed to do with (%08x)?\n",
<1> static int get_fw_cfg_order(FWCfgState *s, const char *name)\n<17> for (i = 0; i < ARRAY_SIZE(fw_cfg_order); i++) {\n<19> if (fw_cfg_order[i].name == NULL) {\n<27> if (strcmp(name, fw_cfg_order[i].name) == 0) {\n<29> return fw_cfg_order[i].order;\n<39> error_report("warning: Unknown firmware file in legacy mode: %s", name);
<1> static void lx_init(const LxBoardDesc *board, MachineState *machine)\n<33> const char *kernel_cmdline = qemu_opt_get(machine_opts, "append");\n<163> size_t bp_size = 3 * get_tag_size(0); /* first/last and memory tags */\n<199> if (kernel_cmdline) {\n<201> bp_size += get_tag_size(strlen(kernel_cmdline) + 1);\n<207> bp_size += get_tag_size(sizeof(uint32_t));\n<213> bp_size += get_tag_size(sizeof(BpMemInfo));\n<221> tagptr = (tagptr - bp_size) & ~0xff;\n<231> if (kernel_cmdline) {\n<235> strlen(kernel_cmdline) + 1, kernel_cmdline);
<7> AVCodec *codec = avctx->codec;\n<9> AVCodecContext *src = avctx;\n<75> p->avctx  = copy;\n<79> if (!copy) {\n<99> src = copy;\n<105> err = codec->init(copy);\n<109> update_context_from_thread(avctx, copy, 1);\n<113> copy->priv_data = av_malloc(codec->priv_data_size);\n<115> if (!copy->priv_data) {\n<123> memcpy(copy->priv_data, src->priv_data, codec->priv_data_size);\n<143> err = codec->init_thread_copy(copy);
<1> static void omap_mcbsp_sink_tick(void *opaque)\n<15> if (s->tx_req)\n<17> printf("%s: Tx FIFO underrun\n", __FUNCTION__);
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> JvContext * s = avctx -> priv_data ;\n<11> if ( avctx -> reget_buffer ( avctx , & s -> frame ) < 0 ) {\n<27> int v = * buf ++ ;\n<29> j < avctx -> height ;\n<30> j ++ ) memset ( s -> frame . data [ 0 ] + j * s -> frame . linesize [ 0 ] , v , avctx -> width ) ;\n<42> s -> palette [ i ] = AV_RB24 ( buf ) << 2 ;\n<47> if ( video_size ) {\n<52> memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;
<1> static bool ga_open_pidfile(const char *pidfile)\n<7> char pidstr[32];\n<13> if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n<15> g_critical("Cannot lock pid file, %s", strerror(errno));\n<29> if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n<37> sprintf(pidstr, "%d", getpid());\n<39> if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n<41> g_critical("Failed to write pid file");\n<49> return true;\n<55> unlink(pidfile);\n<57> return false;
<1> static void realtime_init(void)\n<7> if (os_mlock() < 0) {\n<9> fprintf(stderr, "qemu: locking memory failed\n");
<1> static int vpc_create(const char *filename, int64_t total_sectors,\n<7> uint8_t buf[1024];\n<9> struct vhd_footer* footer = (struct vhd_footer*) buf;\n<35> if (fd < 0)\n<51> memset(buf, 0, 1024);\n<55> strncpy(footer->creator, "conectix", 8);\n<59> strncpy(footer->creator_app, "qemu", 4);\n<61> strncpy(footer->creator_os, "Wi2k", 4);\n<105> footer->checksum = be32_to_cpu(vpc_checksum(buf, HEADER_SIZE));\n<127> if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE)\n<135> if (lseek(fd, 3 * 512, SEEK_SET) < 0)\n<141> memset(buf, 0xFF, 512);\n<143> for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++)\n<145> if (write(fd, buf, 512) != 512)\n<155> memset(buf, 0, 1024);\n<159> strncpy(dyndisk_header->magic, "cxsparse", 8);\n<175> dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));
<1> static int synth_superframe(AVCodecContext *ctx, AVFrame *frame,\n<7> WMAVoiceContext *s = ctx->priv_data;\n<13> double lsps[MAX_FRAMES][MAX_LSPS];\n<19> float excitation[MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12];\n<21> float synth[MAX_LSPS + MAX_SFRAMESIZE];\n<29> s->lsps             * sizeof(*synth));\n<33> s->history_nsamples * sizeof(*excitation));\n<49> if ((res = check_bits_for_superframe(gb, s)) == 1) {\n<107> prev_lsps[n] = s->prev_lsps[n] - mean_lsf[n];\n<113> dequant_lsp10r(gb, lsps[2], prev_lsps, a1, a2, s->lsp_q_mode);\n<117> dequant_lsp16r(gb, lsps[2], prev_lsps, a1, a2, s->lsp_q_mode);\n<127> lsps[2][n] += mean_lsf[n];\n<155> for (n = 0; n < 3; n++) {\n<227> s->lsps             * sizeof(*s->prev_lsps));\n<229> memcpy(s->synth_history,      &synth[MAX_SFRAMESIZE],\n<231> s->lsps             * sizeof(*synth));\n<233> memcpy(s->excitation_history, &excitation[MAX_SFRAMESIZE],\n<235> s->history_nsamples * sizeof(*excitation));\n<237> if (s->do_apf)\n<239> memmove(s->zero_exc_pf,       &s->zero_exc_pf[MAX_SFRAMESIZE],\n<241> s->history_nsamples * sizeof(*s->zero_exc_pf));
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<59> if (ret < 0) {\n<61> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> static uint64_t gpio_read(void *opaque, target_phys_addr_t addr, unsigned size)\n<53> D(printf("%s %x=%x\n", __func__, addr, r));
<1> static int op_to_mov(int op)\n<5> switch (op_bits(op)) {\n<21> fprintf(stderr, "op_to_mov: unexpected return value of "
<1> static void omap_lpg_update(struct omap_lpg_s *s)\n<35> if (on == period && s->on < s->period)\n<37> printf("%s: LED is on\n", __FUNCTION__);\n<39> else if (on == 0 && s->on)\n<41> printf("%s: LED is off\n", __FUNCTION__);
<1> static void fill_scaling_lists(const AVCodecContext *avctx, AVDXVAContext *ctx, const H264Context *h, DXVA_Qmatrix_H264 *qm)\n<7> memset(qm, 0, sizeof(*qm));
<1> static int http_connect(URLContext *h, const char *path, const char *hoststr,\n<7> HTTPContext *s = h->priv_data;\n<27> post = h->flags & URL_WRONLY;\n<101> if (http_write(h, s->buffer, strlen(s->buffer)) < 0)\n<103> return AVERROR(EIO);\n<109> s->buf_ptr = s->buffer;\n<111> s->buf_end = s->buffer;\n<113> s->line_count = 0;\n<115> s->off = 0;\n<117> s->filesize = -1;\n<119> if (post) {\n<143> if (http_get_line(s, line, sizeof(line)) < 0)\n<153> err = process_line(h, line, s->line_count, new_location);
<1> static void single_quote_string(void)\n<27> for (i = 0; test_cases[i].encoded; i++) {\n<47> g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
<1> assigned_dev_msix_mmio_read(void *opaque, target_phys_addr_t addr,\n<3> unsigned size)\n<7> AssignedDevice *adev = opaque;\n<13> memcpy(&val, (void *)((uint8_t *)adev->msix_table + addr), size);\n<17> return val;
<1> static void roq_encode_video(RoqContext *enc)\n<5> RoqTempdata *tempData = enc->tmpData;\n<11> memset(tempData, 0, sizeof(*tempData));\n<15> create_cel_evals(enc, tempData);
<1> static int local_set_mapped_file_attr(FsContext *ctx,\n<11> char buf[ATTR_MAX];\n<21> if (!fp) {\n<27> memset(buf, 0, ATTR_MAX);\n<29> while (fgets(buf, ATTR_MAX, fp)) {\n<31> if (!strncmp(buf, "virtfs.uid", 10)) {\n<35> } else if (!strncmp(buf, "virtfs.gid", 10)) {\n<39> } else if (!strncmp(buf, "virtfs.mode", 11)) {\n<43> } else if (!strncmp(buf, "virtfs.rdev", 11)) {\n<49> memset(buf, 0, ATTR_MAX);\n<53> fclose(fp);\n<75> if (!fp) {\n<113> if (uid != -1) {\n<115> fprintf(fp, "virtfs.uid=%d\n", uid);\n<119> if (gid != -1) {\n<121> fprintf(fp, "virtfs.gid=%d\n", gid);\n<125> if (mode != -1) {\n<127> fprintf(fp, "virtfs.mode=%d\n", mode);\n<131> if (rdev != -1) {\n<133> fprintf(fp, "virtfs.rdev=%d\n", rdev);\n<137> fclose(fp);
<1> static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, AVStream *vstream, int64_t max_pos) {\n<5> char str_val[256];\n<15> AVDictionaryEntry *creator = av_dict_get(s->metadata, "metadatacreator",\n<21> if (creator && !strcmp(creator->value, "MEGA")) {\n<35> return 0;\n<41> if(vstream->nb_index_entries>0){\n<51> while (avio_tell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) {\n<69> if(arraylen>>28)\n<75> if       (!strcmp(KEYFRAMES_TIMESTAMP_TAG , str_val) && !times){\n<77> current_array= &times;\n<79> timeslen= arraylen;\n<81> }else if (!strcmp(KEYFRAMES_BYTEOFFSET_TAG, str_val) && !filepositions){\n<83> current_array= &filepositions;\n<85> fileposlen= arraylen;\n<93> if (!(*current_array = av_mallocz(sizeof(**current_array) * arraylen))) {\n<129> if (timeslen == fileposlen) {
<1> static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n<2> EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n<20> case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n<21> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n<22> gctx -> taglen = arg ;\n<24> case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n<25> memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n<27> case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n<28> memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n<32> if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n<33> if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n<34> if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n<37> case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n<40> memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n<44> case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n<45> memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n<49> case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n<50> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n<51> gctx -> tls_aad_len = arg ;\n<53> unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n<62> EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n<67> if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n<69> gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n<70> if ( gctx_out -> iv == NULL ) return 0 ;\n<71> memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;
<1> static void rtsp_cmd_describe(HTTPContext *c, const char *url)\n<23> path = path1;\n<25> if (*path == '/')\n<27> path++;\n<31> for(stream = first_stream; stream != NULL; stream = stream->next) {\n<33> if (!stream->is_feed && stream->fmt == &rtp_mux &&\n<35> !strcmp(path, stream->filename)) {\n<63> content_length = prepare_sdp_description(stream, &content, my_addr.sin_addr);
<1> static void unpack_superblocks(Vp3DecodeContext *s, GetBitContext *gb)\n<27> if (s->keyframe) {\n<33> memset(s->superblock_coding, SB_FULLY_CODED, s->superblock_count);\n<197> memset(s->macroblock_coded, 0, s->macroblock_count);\n<199> for (i = 0; i < s->superblock_count; i++) {
<1> char *socket_address_to_string(struct SocketAddress *addr, Error **errp)\n<11> switch (addr->type) {\n<15> inet = addr->u.inet.data;\n<17> if (strchr(inet->host, ':') == NULL) {\n<19> buf = g_strdup_printf("%s:%s", inet->host, inet->port);\n<23> buf = g_strdup_printf("[%s]:%s", inet->host, inet->port);
<1> static void reanalyze(MpegTSContext *ts) {\n<19> ts->size_stat[1] ++;\n<23> ts->size_stat[2] ++;\n<31> if(ts->size_stat_count > SIZE_STAT_THRESHOLD) {\n<35> if (ts->size_stat[0] > SIZE_STAT_THRESHOLD) {\n<39> } else if (ts->size_stat[1] > SIZE_STAT_THRESHOLD) {\n<43> } else if (ts->size_stat[2] > SIZE_STAT_THRESHOLD) {\n<59> memset(ts->size_stat, 0, sizeof(ts->size_stat));
<1> static uint64_t assigned_dev_ioport_rw(AssignedDevRegion *dev_region,\n<23> if (pwrite(fd, data, size, addr) != size) {\n<27> __func__, strerror(errno));\n<33> if (pread(fd, &val, size, addr) != size) {\n<37> __func__, strerror(errno));
<1> static void rtas_nvram_fetch(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n<31> if (!nvram) {\n<47> len = rtas_ld(args, 2);\n<51> if (((offset + len) < offset)\n<65> membuf = cpu_physical_memory_map(buffer, &len, 1);\n<67> if (nvram->drive) {\n<73> assert(nvram->buf);\n<77> memcpy(membuf, nvram->buf + offset, len);\n<79> alen = len;\n<83> cpu_physical_memory_unmap(membuf, len, 1, len);
<1> static int imc_decode_frame(AVCodecContext * avctx,\n<15> IMCContext *q = avctx->priv_data;\n<71> if(stream_format_code & 1){\n<91> if(q->decoder_reset) {\n<93> memset(q->out_samples, 0, sizeof(q->out_samples));\n<95> for(i = 0; i < BANDS; i++)q->old_floor[i] = 1.0;\n<107> imc_read_level_coeffs(q, stream_format_code, q->levlCoeffBuf);\n<113> imc_decode_level_coefficients(q, q->levlCoeffBuf, q->flcoeffs1, q->flcoeffs2);\n<117> imc_decode_level_coefficients2(q, q->levlCoeffBuf, q->old_floor, q->flcoeffs1, q->flcoeffs2);\n<121> memcpy(q->old_floor, q->flcoeffs1, 32 * sizeof(float));\n<141> memset(q->bandFlagsBuf, 0, BANDS * sizeof(int));\n<153> imc_calculate_coeffs(q, q->flcoeffs1, q->flcoeffs2, q->bandWidthT, q->flcoeffs3, q->flcoeffs5);\n<195> if(bit_allocation (q, stream_format_code, 512 - bitscount - get_bits_count(&q->gb), flag) < 0) {\n<227> imc_get_skip_coeff(q);\n<279> imc_adjust_bit_allocation(q, summer);\n<291> if (!q->skipFlags[j])\n<299> memset(q->codewords, 0, sizeof(q->codewords));\n<303> if(imc_get_coeffs(q) < 0) {\n<315> if(inverse_quant_coeff(q, stream_format_code) < 0) {\n<327> memset(q->skipFlags, 0, sizeof(q->skipFlags));\n<331> imc_imdct256(q);
<1> static void qerror_abort(const QError *qerr, const char *fmt, ...)\n<9> fprintf(stderr, "qerror: bad call in function '%s':\n", qerr->func);\n<11> fprintf(stderr, "qerror: -> ");\n<17> vfprintf(stderr, fmt, ap);\n<23> fprintf(stderr, "\nqerror: call at %s:%d\n", qerr->file, qerr->linenr);
<1> static int flac_decode_frame(AVCodecContext *avctx,\n<5> const uint8_t *buf, int buf_size)\n<9> FLACContext *s = avctx->priv_data;\n<29> s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize);\n<37> if (s->bitstream_size < 4 || AV_RL32(s->bitstream) != MKTAG('f','L','a','C'))\n<39> buf_size= FFMIN(buf_size, s->max_framesize - FFMIN(s->bitstream_size, s->max_framesize));\n<45> if (s->bitstream_size + buf_size < buf_size || s->bitstream_index + s->bitstream_size + buf_size < s->bitstream_index)\n<53> s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->bitstream_size + buf_size);\n<57> if (s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size) {\n<59> memmove(s->bitstream, &s->bitstream[s->bitstream_index],\n<67> memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size],\n<71> buf= &s->bitstream[s->bitstream_index];\n<73> buf_size += s->bitstream_size;\n<93> if (metadata_parse(s))\n<115> if (decode_frame(s, alloc_data_size) < 0) {
<1> static int vhdx_create(const char *filename, QemuOpts *opts, Error **errp)\n<49> if (image_size > VHDX_MAX_IMAGE_SIZE) {\n<61> if (type == NULL) {\n<63> type = g_strdup("dynamic");\n<69> if (!strcmp(type, "dynamic")) {\n<71> image_type = VHDX_TYPE_DYNAMIC;\n<73> } else if (!strcmp(type, "fixed")) {\n<75> image_type = VHDX_TYPE_FIXED;\n<77> } else if (!strcmp(type, "differencing")) {\n<83> ret = -ENOTSUP;\n<89> ret = -EINVAL;\n<101> if (block_size == 0) {\n<131> log_size = ROUND_UP(log_size, MiB);\n<135> block_size = ROUND_UP(block_size, MiB);\n<137> block_size = block_size > VHDX_BLOCK_SIZE_MAX ? VHDX_BLOCK_SIZE_MAX :\n<143> ret = bdrv_create_file(filename, opts, &local_err);\n<145> if (ret < 0) {\n<267> g_free(type);
<13> ret = initialize_cur_frame(h);\n<15> if (ret < 0)\n<81> memset(h->slice_table, -1,\n<83> (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));
<1> void net_slirp_redir(Monitor *mon, const char *redir_str, const char *redir_opt2)\n<9> if (!slirp_inited) {\n<33> if (!strcmp(redir_str, "remove")) {\n<35> net_slirp_redir_rm(mon, redir_opt2);\n<37> return;\n<43> slirp_redirection(mon, redir_str);
<1> static int curl_open(BlockDriverState *bs, QDict *options, int flags,\n<87> s->url = g_strdup(file);\n<109> curl_easy_setopt(state->curl, CURLOPT_HEADERDATA, s);\n<117> if (d)\n<121> else if(!s->len)\n<125> if ((!strncasecmp(s->url, "http://", strlen("http://"))\n<127> || !strncasecmp(s->url, "https://", strlen("https://")))\n<129> && !s->accept_range) {\n<131> pstrcpy(state->errmsg, CURL_ERROR_SIZE,\n<139> DPRINTF("CURL: Size = %zd\n", s->len);\n<143> curl_clean_state(state);\n<145> curl_easy_cleanup(state->curl);\n<147> state->curl = NULL;\n<151> aio_timer_init(bdrv_get_aio_context(bs), &s->timer,\n<165> s->multi = curl_multi_init();\n<167> curl_multi_setopt(s->multi, CURLMOPT_SOCKETDATA, s);\n<169> curl_multi_setopt(s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb);\n<181> qemu_opts_del(opts);\n<183> return 0;\n<189> error_setg(errp, "CURL: Error opening file: %s", state->errmsg);\n<191> curl_easy_cleanup(state->curl);\n<193> state->curl = NULL;\n<197> g_free(s->url);\n<199> qemu_opts_del(opts);\n<201> return -EINVAL;
<1> static void dissect_rsvp_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean e2ei ) {\n<23> if ( ( message_type == RSVP_MSG_ACK ) || ( message_type == RSVP_MSG_SREFRESH ) || ( message_type == RSVP_MSG_HELLO ) ) return ;\n<25> memset ( & request_key , 0 , sizeof ( request_key ) ) ;\n<54> request_val = ( struct rsvp_request_val * ) g_hash_table_lookup ( rsvp_request_hash , & request_key ) ;\n<56> new_request_key = ( struct rsvp_request_key * ) wmem_memdup ( wmem_file_scope ( ) , & request_key , sizeof ( struct rsvp_request_key ) ) ;
<1> static void dump_human_image_check(ImageCheck *check)\n<5> if (!(check->corruptions || check->leaks || check->check_errors)) {\n<7> printf("No errors were found on the image.\n");
<1> int encode_msg ( struct sip_msg * msg , char * payload , int len ) {\n<9> if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ;\n<10> if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) {\n<14> memset ( payload , 0 , len ) ;\n<30> if ( h == 32 ) {\n<34> h = htons ( h ) ;\n<35> memcpy ( payload , & h , 2 ) ;\n<36> h = htons ( ( unsigned short int ) msg -> len ) ;\n<37> memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ;\n<38> if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) {\n<42> else h = htons ( ( unsigned short int ) diff ) ;\n<43> memcpy ( payload + CONTENT_IDX , & h , 2 ) ;\n<44> payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ;\n<45> payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ;\n<46> payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ;\n<47> payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ;\n<48> payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ;\n<55> if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) {\n<59> payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ;\n<71> hf ;\n<73> payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ;\n<74> h = htons ( j ) ;\n<75> memcpy ( & payload [ k + 1 ] , & h , 2 ) ;\n<76> if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) {\n<85> j = htons ( j ) ;\n<86> memcpy ( & payload [ k + 1 ] , & j , 2 ) ;\n<88> j = ntohs ( j ) ;\n<89> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;\n<90> LM_DBG ( "msglen = %d,msg starts at %d\n" , msg -> len , j ) ;\n<91> j = htons ( j ) ;\n<92> memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ;\n<93> return GET_PAY_SIZE ( payload ) ;
<1> static inline int dmg_read_chunk(BlockDriverState *bs, int sector_num)\n<13> uint32_t chunk = search_chunk(s,sector_num);\n<25> switch(s->types[chunk]) {\n<97> memset(s->uncompressed_chunk, 0, 512*s->sectorcounts[chunk]);
<1> int locate_option(int argc, char **argv, const OptionDef *options,\n<3> const char *optname)\n<13> for (i = 1; i < argc; i++) {\n<19> if (*cur_opt++ != '-')\n<25> po = find_option(options, cur_opt);\n<27> if (!po->name && cur_opt[0] == 'n' && cur_opt[1] == 'o')\n<29> po = find_option(options, cur_opt + 2);\n<33> if ((!po->name && !strcmp(cur_opt, optname)) ||\n<35> (po->name && !strcmp(optname, po->name)))\n<37> return i;\n<41> if (!po || po->flags & HAS_ARG)
<1> static int read_sm_data(AVFormatContext *s, AVIOContext *bc, AVPacket *pkt, int is_meta, int64_t maxpos)\n<35> get_str(bc, name, sizeof(name));\n<59> if (avio_tell(bc) + value_len >= maxpos)\n<63> if (!strcmp(name, "Palette")) {\n<65> dst = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, value_len);\n<67> } else if (!strcmp(name, "Extradata")) {\n<69> dst = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, value_len);\n<71> } else if (sscanf(name, "CodecSpecificSide%"SCNd64"", &v64) == 1) {\n<83> } else if (!strcmp(name, "ChannelLayout") && value_len == 8) {\n<85> channel_layout = avio_rl64(bc);\n<91> av_log(s, AV_LOG_WARNING, "Unknown data %s / %s\n", name, type_str);\n<93> avio_skip(bc, value_len);\n<99> if(!dst)\n<113> } else if (value < -4) {\n<119> if (!strcmp(name, "SkipStart")) {\n<121> skip_start = value;\n<123> } else if (!strcmp(name, "SkipEnd")) {\n<125> skip_end = value;\n<127> } else if (!strcmp(name, "Channels")) {\n<129> channels = value;\n<131> } else if (!strcmp(name, "SampleRate")) {\n<133> sample_rate = value;\n<135> } else if (!strcmp(name, "Width")) {\n<137> width = value;\n<139> } else if (!strcmp(name, "Height")) {\n<141> height = value;\n<145> av_log(s, AV_LOG_WARNING, "Unknown integer %s\n", name);
<1> int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)\n<9> int64_t cgu = -inv_table[2];\n<11> int64_t cgv = -inv_table[3];\n<19> memcpy(c->srcColorspaceTable, inv_table, sizeof(int)*4);\n<21> memcpy(c->dstColorspaceTable,     table, sizeof(int)*4);\n<109> ff_yuv2rgb_c_init_tables(c, inv_table, srcRange, brightness, contrast, saturation);
<1> static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct name_path * path , struct strbuf * base , const char * name , void * cb_data ) {\n<11> if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) {\n<12> if ( revs -> ignore_missing_links ) return ;\n<16> show ( obj , path , name , cb_data ) ;\n<19> me . elem_len = strlen ( name ) ;\n<21> strbuf_addstr ( base , name ) ;\n<31> if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , & me , base , entry . path , cb_data ) ;\n<32> else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , & me , entry . path , cb_data ) ;\n<33> else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , & me , entry . path , cb_data ) ;
<1> static int parallels_probe(const uint8_t *buf, int buf_size, const char *filename)\n<5> const ParallelsHeader *ph = (const void *)buf;\n<9> if (buf_size < sizeof(ParallelsHeader))\n<15> if ((!memcmp(ph->magic, HEADER_MAGIC, 16) ||\n<17> !memcmp(ph->magic, HEADER_MAGIC2, 16)) &&\n<19> (le32_to_cpu(ph->version) == HEADER_VERSION))\n<21> return 100;\n<25> return 0;
<1> static int write_elf32_load(DumpState *s, MemoryMapping *memory_mapping,\n<15> memset(&phdr, 0, sizeof(Elf32_Phdr));\n<41> ret = fd_write_vmcore(&phdr, sizeof(Elf32_Phdr), s);
<1> void av_blowfish_crypt(AVBlowfish *ctx, uint8_t *dst, const uint8_t *src,\n<3> int count, uint8_t *iv, int decrypt)\n<17> v0 = AV_RB32(src);\n<33> if (iv) {\n<37> dst[i] = dst[i] ^ iv[i];\n<39> memcpy(iv, src, 8);\n<49> dst[i] = src[i] ^ iv[i];\n<69> AV_WB32(dst, v0);\n<75> if (iv)\n<77> memcpy(iv, dst, 8);\n<83> src   += 8;\n<85> dst   += 8;
<1> static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) {\n<81> p_enc_buf = schro_encoder_pull ( p_sys -> p_schro , & i_presentation_frame ) ;\n<82> p_block = block_Alloc ( p_enc_buf -> length ) ;\n<83> if ( ! p_block ) return NULL ;\n<84> memcpy ( p_block -> p_buffer , p_enc_buf -> data , p_enc_buf -> length ) ;\n<85> schro_buffer_unref ( p_enc_buf ) ;\n<86> if ( 0 == p_block -> p_buffer [ 4 ] ) {\n<88> if ( ! p_enc -> fmt_out . p_extra ) {\n<92> uint32_t len = GetDWBE ( p_block -> p_buffer + 5 ) ;\n<93> p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ;\n<94> if ( ! p_enc -> fmt_out . p_extra ) return NULL ;\n<95> memcpy ( p_enc -> fmt_out . p_extra , p_block -> p_buffer , len ) ;\n<96> memcpy ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len , eos , sizeof ( eos ) ) ;\n<97> SetDWBE ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len + sizeof ( eos ) - 4 , len ) ;\n<101> if ( ReadDiracPictureNumber ( & u_pic_num , p_block ) ) {\n<106> block_ChainAppend ( & p_output_chain , p_block ) ;\n<109> block_ChainAppend ( & p_output_chain , p_block ) ;
<1> static int fourxm_read_packet(AVFormatContext *s,\n<3> AVPacket *pkt)\n<31> if ((ret = get_buffer(s->pb, header, 8)) < 0)\n<35> fourcc_tag = AV_RL32(&header[0]);\n<37> size = AV_RL32(&header[4]);\n<79> if (size + 8 < size || av_new_packet(pkt, size + 8))\n<89> memcpy(pkt->data, header, 8);\n<91> ret = get_buffer(s->pb, &pkt->data[8], size);\n<97> av_free_packet(pkt);\n<119> ret= av_get_packet(s->pb, pkt, size);
<1> xmlHashTablePtr xmlHashCreate ( int size ) {\n<4> table = xmlMalloc ( sizeof ( xmlHashTable ) ) ;\n<9> table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n<10> if ( table -> table ) {\n<11> memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n<12> return ( table ) ;
<1> av_cold int ff_mpv_common_init(MpegEncContext *s)\n<15> if (s->encoding && s->avctx->slices)\n<21> if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n<23> s->mb_height = (s->height + 31) / 32 * 2;\n<27> s->mb_height = (s->height + 15) / 16;\n<43> if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {\n<49> max_slices = FFMIN(MAX_THREADS, s->mb_height);\n<65> if ((s->width || s->height) &&\n<67> av_image_check_size(s->width, s->height, 0, s->avctx))\n<73> dct_init(s);\n<93> for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n<103> memset(&s->next_picture, 0, sizeof(s->next_picture));\n<105> memset(&s->last_picture, 0, sizeof(s->last_picture));\n<107> memset(&s->current_picture, 0, sizeof(s->current_picture));\n<109> memset(&s->new_picture, 0, sizeof(s->new_picture));\n<137> if (init_context_frame(s))\n<147> s->context_initialized = 1;\n<157> for (i = 1; i < nb_slices; i++) {\n<159> s->thread_context[i] = av_malloc(sizeof(MpegEncContext));\n<161> memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n<169> if (init_duplicate_context(s->thread_context[i]) < 0)\n<175> (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n<179> (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n<205> ff_mpv_common_end(s);
<1> int qcow2_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n<5> BDRVQcow2State *s = bs->opaque;\n<11> QCowSnapshot sn1, *sn = &sn1;\n<21> if (s->nb_snapshots >= QCOW_MAX_SNAPSHOTS) {\n<29> memset(sn, 0, sizeof(*sn));\n<109> ret = qcow2_pre_write_overlap_check(bs, 0, sn->l1_table_offset,\n<121> ret = bdrv_pwrite(bs->file, sn->l1_table_offset, l1_table,\n<161> new_snapshot_list = g_new(QCowSnapshot, s->nb_snapshots + 1);\n<163> if (s->snapshots) {\n<167> s->nb_snapshots * sizeof(QCowSnapshot));\n<169> old_snapshot_list = s->snapshots;\n<173> s->snapshots = new_snapshot_list;\n<205> align_offset(sn->vm_state_size, s->cluster_size)\n<231> g_free(sn->id_str);\n<233> g_free(sn->name);
<1> static void an5206_init(MachineState *machine)\n<77> if (qtest_enabled()) {\n<83> fprintf(stderr, "Kernel image must be specified\n");\n<91> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<99> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n<107> kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR,\n<115> if (kernel_size < 0) {\n<117> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> qcrypto_block_luks_open(QCryptoBlock *block,\n<89> if (rv < 0) {\n<127> if (memcmp(luks->header.magic, qcrypto_block_luks_magic,\n<131> error_setg(errp, "Volume is not in LUKS format");\n<133> ret = -EINVAL;\n<139> if (luks->header.version != QCRYPTO_BLOCK_LUKS_VERSION) {\n<169> ivgen_name = strchr(luks->header.cipher_mode, '-');\n<171> if (!ivgen_name) {\n<175> error_setg(errp, "Unexpected cipher mode string format %s",\n<183> *ivgen_name = '\0';\n<185> ivgen_name++;\n<189> ivhash_name = strchr(ivgen_name, ':');\n<191> if (!ivhash_name) {\n<221> ciphermode = qcrypto_block_luks_cipher_mode_lookup(luks->header.cipher_mode,\n<273> ivalg = qcrypto_block_luks_ivgen_name_lookup(ivgen_name,\n<457> g_free(masterkey);\n<459> qcrypto_cipher_free(block->cipher);\n<461> qcrypto_ivgen_free(block->ivgen);\n<463> g_free(luks);\n<465> g_free(password);\n<467> return ret;
<1> static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n<53> ac_val2 = ac_val ;\n<55> if ( dc_pred_dir ) ac_val -= 16 ;\n<56> else ac_val -= 16 * s -> block_wrap [ n ] ;\n<63> if ( coded ) {\n<126> memset ( ac_val2 , 0 , 16 * 2 ) ;\n<128> if ( use_pred ) {\n<129> memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n<136> k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n<141> if ( use_pred ) {\n<142> memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n<149> k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n<158> block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n<166> block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;
<1> int ff_ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile)\n<11> int32_t     prev_dc, trvec[64];\n<123> if (cbp & 1) { /* block coded ? */\n<127> memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */\n<129> memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */\n<195> trvec[pos] = val;\n<197> col_flags[pos & col_mask] |= !!val; /* track columns containing non-zero coeffs */\n<213> prev_dc      += trvec[0];\n<217> col_flags[0] |= !!prev_dc;\n<225> band->inv_transform(trvec, band->buf + buf_offs,
<1> static int scsi_disk_emulate_command(SCSIDiskReq *r)\n<41> r->buflen = MAX(4096, req->cmd.xfer);\n<49> outbuf = r->iov.iov_base;\n<51> switch (req->cmd.buf[0]) {\n<159> memset(outbuf, 0, 8);\n<289> if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n<293> memset(outbuf, 0, req->cmd.xfer);\n<363> buflen = req->cmd.xfer;\n<491> buflen = MIN(buflen, req->cmd.xfer);
<1> int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,\n<15> if (color_string[0] == '#') {\n<19> } else if (!strncmp(color_string, "0x", 2))\n<25> if (slen < 0)\n<27> slen = strlen(color_string);\n<29> av_strlcpy(color_string2, color_string + hex_offset,\n<31> FFMIN(slen-hex_offset+1, sizeof(color_string2)));\n<33> if ((tail = strchr(color_string2, ALPHA_SEP)))\n<35> *tail++ = 0;\n<37> len = strlen(color_string2);\n<39> rgba_color[3] = 255;\n<43> if (!av_strcasecmp(color_string2, "random") || !av_strcasecmp(color_string2, "bikeshed")) {\n<57> strspn(color_string2, "0123456789ABCDEFabcdef") == len) {\n<61> unsigned int rgba = strtoul(color_string2, &tail, 16);\n<65> if (*tail || (len != 6 && len != 8)) {\n<73> if (len == 8) {\n<99> if (!entry) {\n<107> memcpy(rgba_color, entry->rgb_color, 3);\n<117> const char *alpha_string = tail;\n<121> alpha = strtoul(alpha_string, &tail, 16);\n<125> alpha = 255 * strtod(alpha_string, &tail);\n<131> if (tail == alpha_string || *tail || alpha > 255) {\n<133> av_log(log_ctx, AV_LOG_ERROR, "Invalid alpha value specifier '%s' in '%s'\n",
<1> int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,\n<17> AVFilterInOut *open_inputs  = open_inputs_ptr  ? *open_inputs_ptr  : NULL;\n<29> filters += strspn(filters, WHITESPACES);\n<33> if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)\n<39> if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)\n<59> if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)\n<65> if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n<73> filters += strspn(filters, WHITESPACES);\n<75> chr = *filters++;\n<79> if (chr == ';' && curr_inputs) {\n<95> } while (chr == ',' || chr == ';');\n<99> if (chr) {\n<115> if (open_inputs && !strcmp(open_inputs->name, "out") && curr_inputs) {\n<119> const char *tmp = "[out]";\n<121> if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,\n<135> if (open_inputs_ptr) *open_inputs_ptr = open_inputs;\n<137> else avfilter_inout_free(&open_inputs);\n<143> avfilter_inout_free(&curr_inputs);
<1> static int fir_channel(AVFilterContext *ctx, void *arg, int ch, int nb_jobs)\n<5> AudioFIRContext *s = ctx->priv;\n<13> float *sum = s->sum[ch];\n<25> memset(sum, 0, sizeof(*sum) * s->fft_length);\n<27> block = s->block[ch] + s->part_index * s->block_size;\n<29> memset(block, 0, sizeof(*block) * s->fft_length);\n<33> s->fdsp->vector_fmul_scalar(block + s->part_size, src, s->dry_gain, s->nb_samples);\n<39> av_rdft_calc(s->rdft[ch], block);\n<61> s->fcmul_add(sum, block, (const float *)coeff, s->part_size);\n<75> sum[1] = sum[2 * s->part_size];\n<77> av_rdft_calc(s->irdft[ch], sum);\n<85> dst[n] += sum[n];\n<91> dst = (float *)s->buffer->extended_data[ch] + index2 * s->part_size;\n<95> memcpy(dst, sum + s->part_size, s->part_size * sizeof(*dst));
<1> static int vmdk_add_extent(BlockDriverState *bs,\n<33> if (l1_size > 512 * 1024 * 1024) {\n<55> extent = &s->extents[s->num_extents];\n<61> memset(extent, 0, sizeof(VmdkExtent));\n<93> extent->end_sector = (*(extent - 1)).end_sector + extent->sectors;\n<97> extent->end_sector = extent->sectors;\n<101> bs->total_sectors = extent->end_sector;\n<105> *new_extent = extent;
<1> static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict,\n<25> size_t best_bytestream_size = SIZE_MAX;\n<131> for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) {\n<133> size_t row_start = diffFrame->linesize[0] * y + bpp * last_fctl_chunk.x_offset;\n<135> memset(diffFrame->data[0] + row_start, 0, bpp * last_fctl_chunk.width);\n<185> if (bytestream_size < best_bytestream_size) {\n<197> best_bytestream_size = bytestream_size;\n<229> if (best_bytestream != original_bytestream)\n<231> memcpy(original_bytestream, best_bytestream, best_bytestream_size);
<1> static int bt_parse(const char *opt)\n<11> if (strstart(opt, "hci", &endp)) {\n<13> if (!*endp || *endp == ',') {\n<27> } else if (strstart(opt, "vhci", &endp)) {\n<29> if (!*endp || *endp == ',') {\n<33> if (strstart(endp, ",vlan=", &p)) {\n<35> vlan = strtol(p, (char **) &endp, 0);\n<37> if (*endp) {\n<39> fprintf(stderr, "qemu: bad scatternet '%s'\n", p);\n<47> fprintf(stderr, "qemu: bad parameter '%s'\n", endp + 1);\n<65> } else if (strstart(opt, "device:", &endp))\n<71> fprintf(stderr, "qemu: bad bluetooth parameter '%s'\n", opt);
<1> static int mm_decode_intra(MmContext * s, int half_horiz, int half_vert)\n<23> if (color & 0x80) {\n<31> color = bytestream2_get_byte(&s->gb);\n<43> if (run_length > s->avctx->width - x)\n<49> if (color) {\n<51> memset(s->frame->data[0] + y*s->frame->linesize[0] + x, color, run_length);\n<53> if (half_vert)\n<55> memset(s->frame->data[0] + (y+1)*s->frame->linesize[0] + x, color, run_length);\n<59> x+= run_length;
<1> static int ffserver_opt_preset(const char *arg,\n<11> char filename[1000], tmp[1000], tmp2[1000], line[1000];\n<19> if (!(f = get_preset_file(filename, sizeof(filename), arg, 0,\n<23> fprintf(stderr, "File for preset '%s' not found\n", arg);\n<31> while(!feof(f)){\n<33> int e= fscanf(f, "%999[^\n]\n", line) - 1;\n<35> if(line[0] == '#' && !e)\n<39> e|= sscanf(line, "%999[^=]=%999[^\n]\n", tmp, tmp2) - 2;\n<41> if(e){\n<43> fprintf(stderr, "%s: Invalid syntax: '%s'\n", filename, line);\n<51> if(!strcmp(tmp, "acodec")){\n<53> *audio_id = opt_codec(tmp2, AVMEDIA_TYPE_AUDIO);\n<55> }else if(!strcmp(tmp, "vcodec")){\n<57> *video_id = opt_codec(tmp2, AVMEDIA_TYPE_VIDEO);\n<59> }else if(!strcmp(tmp, "scodec")){\n<63> }else if(ffserver_opt_default(tmp, tmp2, avctx, type) < 0){\n<65> fprintf(stderr, "%s: Invalid option or argument: '%s', parsed as '%s' = '%s'\n", filename, line, tmp, tmp2);\n<77> fclose(f);
<1> void ff_http_auth_handle_header(HTTPAuthState *state, const char *key,\n<7> if (!strcmp(key, "WWW-Authenticate") || !strcmp(key, "Proxy-Authenticate")) {\n<11> if (av_stristart(value, "Basic ", &p) &&\n<31> memset(&state->digest_params, 0, sizeof(DigestParams));\n<51> } else if (!strcmp(key, "Authentication-Info")) {\n<53> ff_parse_key_value(value, (ff_parse_key_val_cb) handle_digest_update,
<1> static void test_qemu_strtoull_decimal(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoull(str, &endptr, 10, &res);\n<25> g_assert(endptr == str + strlen(str));\n<31> endptr = &f;\n<35> err = qemu_strtoull(str, &endptr, 0, &res);\n<43> g_assert(endptr == str + strlen(str));
<51> dinfo = drive_get_by_blockdev(bs);\n<53> if (*dinfo->serial) {\n<55> s->serial = strdup(dinfo->serial);\n<63> usb_desc_set_string(dev, STR_SERIALNUMBER, s->serial);\n<93> monitor_read_bdrv_key_start(cur_mon, bs, usb_msd_password_cb, s);
<1> static int create_vorbis_context(vorbis_enc_context *venc,\n<43> vorbis_enc_codebook *cb = &venc->codebooks[book];\n<65> if (!cb->lens || !cb->codewords)\n<69> memcpy(cb->lens, cvectors[book].clens, cvectors[book].len);\n<71> memset(cb->lens + cvectors[book].len, 0, cb->nentries - cvectors[book].len);\n<95> if ((ret = ready_codebook(cb)) < 0)\n<129> static const int a[] = {0, 1, 2, 2, 3, 3, 4, 4};\n<229> rc = &venc->residues[0];\n<245> if (!rc->books)\n<275> memcpy(rc->books, a, sizeof a);\n<279> if ((ret = ready_residue(rc, venc)) < 0)
<1> static int qsort_strcmp(const void *a, const void *b)\n<5> return strcmp(a, b);
<1> static char *pcibus_get_dev_path(DeviceState *dev)\n<21> int domain_len = strlen("DDDD:00");\n<23> int slot_len = strlen(":SS.F");\n<43> path_len = domain_len + slot_len * slot_depth;\n<49> path = malloc(path_len + 1 /* For '\0' */);\n<57> snprintf(path, domain_len, "%04x:00", pci_find_domain(d->bus));
<1> static void ipvideo_decode_opcodes(IpvideoContext *s, AVFrame *frame)\n<17> if (!s->is_16bpp) {\n<21> memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);\n<73> ret = ipvideo_decode_block[opcode](s, frame);\n<81> ret = ipvideo_decode_block16[opcode](s, frame);
<1> static size_t qemu_rdma_save_page(QEMUFile *f, void *opaque,\n<39> if (ret < 0) {\n<41> fprintf(stderr, "rdma migration: write error! %d\n", ret);\n<105> if (ret) {\n<107> fprintf(stderr, "ram block search failed\n");\n<159> if (ret < 0) {\n<161> fprintf(stderr, "rdma migration: polling error! %d\n", ret);\n<187> rdma->error_state = ret;\n<189> return ret;
<1> static void mark_desktop_file_trusted ( CommonJob * common , GCancellable * cancellable , GFile * file , gboolean interactive ) {\n<9> if ( ! g_file_load_contents ( file , cancellable , & contents , & length , NULL , & error ) ) {\n<27> if ( ! g_str_has_prefix ( contents , "#!" ) ) {\n<28> new_length = length + strlen ( TRUSTED_SHEBANG ) ;\n<29> new_contents = g_malloc ( new_length ) ;\n<30> strcpy ( new_contents , TRUSTED_SHEBANG ) ;\n<31> memcpy ( new_contents + strlen ( TRUSTED_SHEBANG ) , contents , length ) ;\n<33> g_free ( contents ) ;\n<54> g_free ( contents ) ;
<41> if (!out) {\n<85> snprintf(value, sizeof(value), "%f", s->luminance[0] * f);\n<103> memmove(&s->luminance[0], &s->luminance[1], sizeof(*s->luminance) * (s->size - 1));
<1> static int alloc_tables(H264Context *h){\n<17> CHECKED_ALLOCZ(h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base))\n<33> memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n<35> h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n<71> init_dequant_tables(h);
<1> static void selfTest(uint8_t *src[4], int stride[4], int w, int h){\n<13> for (dstFormat = 0; dstFormat < PIX_FMT_NB; dstFormat++) {\n<17> sws_format_name(srcFormat),\n<19> sws_format_name(dstFormat));
<1> void mpeg1_encode_mb(MpegEncContext *s,\n<95> } else if (s->mb_intra) {\n<111> s->misc_bits+= get_bits_diff(s);\n<115> memset(s->last_mv, 0, sizeof(s->last_mv));\n<405> mpeg1_encode_block(s, block[i], i);\n<415> s->i_tex_bits+= get_bits_diff(s);\n<419> s->p_tex_bits+= get_bits_diff(s);
<1> static int device_open(AVFormatContext *ctx, uint32_t *capabilities)\n<25> if (fd < 0) {\n<27> av_log(ctx, AV_LOG_ERROR, "Cannot open video device %s : %s\n",\n<29> ctx->filename, strerror(errno));\n<33> return AVERROR(errno);\n<61> if (res < 0) {\n<63> av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_QUERYCAP): %s\n",\n<65> strerror(errno));
<1> static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)\n<7> HisteqContext     *histeq  = ctx->priv;\n<27> if (!outpic) {\n<49> memset(histeq->in_histogram, 0, sizeof(histeq->in_histogram));\n<121> memset(histeq->out_histogram, 0, sizeof(histeq->out_histogram));
<1> const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src,\n<19> h->nal_unit_type = src[0] & 0x1F;\n<23> src++;\n<31> if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {         \\n<111> if (i > 0 && src[i - 1] == 0)\n<123> if (i >= length - 1) { // no escaped 0\n<147> if (dst == NULL)\n<153> memcpy(dst, src, i);\n<155> si = di = i;\n<161> if (src[si + 2] > 3) {\n<163> dst[di++] = src[si++];\n<165> dst[di++] = src[si++];\n<167> } else if (src[si] == 0 && src[si + 1] == 0) {\n<169> if (src[si + 2] == 3) { // escape\n<173> dst[di++]  = 0;\n<187> dst[di++] = src[si++];\n<193> dst[di++] = src[si++];\n<199> memset(dst + di, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<211> return dst;
<1> static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,\n<15> uint32_t read_val = 0, wb_mask;\n<83> if (rc < 0) {\n<87> memset(&read_val, 0xff, len);\n<111> pci_default_write_config(d, addr, val, len);\n<117> read_val <<= (addr & 3) << 3;\n<171> read_val >> ((real_offset & 3) << 3),\n<185> (read_val >> ((real_offset & 3) << 3)),\n<199> (read_val >> ((real_offset & 3) << 3)),
<1> static enum CodecID find_codec_or_die(const char *name, int type, int encoder, int strict)\n<5> const char *codec_string = encoder ? "encoder" : "decoder";\n<17> avcodec_find_encoder_by_name(name) :\n<19> avcodec_find_decoder_by_name(name);\n<21> if(!codec) {\n<23> fprintf(stderr, "Unknown %s '%s'\n", codec_string, name);\n<29> if(codec->type != type) {\n<31> fprintf(stderr, "Invalid %s type '%s'\n", codec_string, name);\n<37> if(codec->capabilities & CODEC_CAP_EXPERIMENTAL &&\n<41> fprintf(stderr, "%s '%s' is experimental and might produce bad "\n<53> if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))\n<55> fprintf(stderr, "Or use the non experimental %s '%s'.\n",
<1> int ssl3_read_bytes ( SSL * s , int type , int * recvd_type , unsigned char * buf , int len , int peek ) {\n<87> if ( len <= 0 ) return ( len ) ;\n<90> if ( ( unsigned int ) len - read_bytes > SSL3_RECORD_get_length ( rr ) ) n = SSL3_RECORD_get_length ( rr ) ;\n<91> else n = ( unsigned int ) len - read_bytes ;\n<92> memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ;\n<93> buf += n ;\n<95> SSL3_RECORD_sub_length ( rr , n ) ;\n<103> if ( SSL3_RECORD_get_length ( rr ) == 0 || ( peek && n == SSL3_RECORD_get_length ( rr ) ) ) {\n<107> read_bytes += n ;\n<109> while ( type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs && read_bytes < ( unsigned int ) len ) ;
<1> static inline void tcg_out_addi(TCGContext *s, int reg, tcg_target_long val)\n<7> if (val == (val & 0xfff))\n<13> fprintf(stderr, "unimplemented addi %ld\n", (long)val);
<1> static void psy_3gpp_analyze_channel(FFPsyContext *ctx, int channel,\n<31> calc_thr_3gpp(wi, num_bands, pch, band_sizes, coefs);\n<333> memcpy(pch->prev_band, pch->band, sizeof(pch->band));
<73> if (st->codec->extradata_size) {\n<75> st->codec->extradata = av_mallocz(st->codec->extradata_size);\n<77> memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size);
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<8> if ( ret < 0 ) {\n<12> if ( ! avctx -> frame_number ) {\n<13> memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * FFABS ( s -> frame . linesize [ 0 ] ) ) ;\n<14> memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n<18> memcpy ( s -> frame . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;
<1> static int svq3_decode_mb(H264Context *h, unsigned int mb_type)\n<55> if (svq3_mc_dir(h, mb_type, PREDICT_MODE, 1, 1) < 0)\n<121> if (s->mb_y > 0) {\n<123> memcpy(h->mv_cache[m][scan8[0] - 1*8], s->current_picture.motion_val[m][b_xy - h->b_stride], 4*2*sizeof(int16_t));\n<125> memset(&h->ref_cache[m][scan8[0] - 1*8], (h->intra4x4_pred_mode[mb_xy - s->mb_stride][4] == -1) ? PART_NOT_AVAILABLE : 1, 4);\n<155> memset(&h->ref_cache[m][scan8[0] - 1*8 - 1], PART_NOT_AVAILABLE, 8);\n<171> if (svq3_mc_dir(h, (mb_type - 1), mode, 0, 0) < 0)\n<179> if (svq3_mc_dir(h, 0, mode, 0, 0) < 0)\n<185> for (i = 0; i < 4; i++) {\n<187> memset(s->current_picture.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<195> if (svq3_mc_dir(h, 0, mode, 1, (mb_type == 3)) < 0)\n<201> for (i = 0; i < 4; i++) {\n<203> memset(s->current_picture.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<215> } else if (mb_type == 8 || mb_type == 33) {   /* INTRA4x4 */\n<217> memset(h->intra4x4_pred_mode_cache, -1, 8*5*sizeof(int8_t));\n<279> left    = &h->intra4x4_pred_mode_cache[scan8[i] - 1];\n<281> top     = &h->intra4x4_pred_mode_cache[scan8[i] - 8];\n<303> for (i = 0; i < 4; i++) {\n<305> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8*i], DC_PRED, 4);\n<313> ff_h264_write_back_intra_pred_mode(h);\n<319> ff_h264_check_intra4x4_pred_mode(h);\n<329> for (i = 0; i < 4; i++) {\n<331> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8*i], DC_128_PRED, 4);\n<355> if ((h->intra16x16_pred_mode = ff_h264_check_intra_pred_mode(h, dir)) == -1){\n<375> for (i = 0; i < 4; i++) {\n<377> memset(s->current_picture.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<383> for (i = 0; i < 4; i++) {\n<385> memset(s->current_picture.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<393> if (!IS_INTRA4x4(mb_type)) {\n<395> memset(h->intra4x4_pred_mode[mb_xy], DC_PRED, 8);\n<399> if (!IS_SKIP(mb_type) || s->pict_type == FF_B_TYPE) {\n<401> memset(h->non_zero_count_cache + 8, 0, 4*9*sizeof(uint8_t));\n<541> h->chroma_pred_mode = ff_h264_check_intra_pred_mode(h, DC_PRED8x8);
<1> static int qcow_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n<43> if (bdrv_pread(s->hd, offset, &ext, sizeof(ext)) != sizeof(ext)) {\n<45> fprintf(stderr, "qcow_handle_extension: ERROR: pread fail from offset %llu\n",\n<55> be32_to_cpus(&ext.len);\n<75> if (ext.len >= sizeof(bs->backing_format)) {\n<77> fprintf(stderr, "ERROR: ext_backing_format: len=%u too large"
<1> static int ipvideo_decode_block_opcode_0xE(IpvideoContext *s)\n<15> pix = *s->stream_ptr++;\n<19> for (y = 0; y < 8; y++) {\n<21> memset(s->pixel_ptr, pix, 8);\n<23> s->pixel_ptr += s->stride;
<1> sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn, size_t window_size)\n<9> if (spapr_tce_find_by_liobn(liobn)) {\n<11> fprintf(stderr, "Attempted to create TCE table with duplicate"
<1> void tlb_flush(CPUState *env, int flush_global)\n<61> memset (env->tb_jmp_cache, 0, TB_JMP_CACHE_SIZE * sizeof (void *));
<1> static void *aio_thread(void *unused)\n<65> TAILQ_REMOVE(&request_list, aiocb, node);\n<75> switch (aiocb->aio_type) {\n<81> ret = handle_aiocb_rw(aiocb);\n<87> ret = handle_aiocb_ioctl(aiocb);\n<93> fprintf(stderr, "invalid aio request (0x%x)\n", aiocb->aio_type);
<1> static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n<53> gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ;\n<55> switch ( datatype ) {\n<59> if ( value_utf8 != NULL && * value_utf8 != '\0' ) {\n<60> GST_DEBUG ( "string value %s" , value_utf8 ) ;\n<61> value_utf8 [ out ] = '\0' ;\n<62> if ( gst_tag_name != NULL ) {\n<63> if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) {\n<64> guint year = atoi ( value_utf8 ) ;\n<65> if ( year > 0 ) {\n<70> else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) {\n<73> if ( sscanf ( value_utf8 , "(%u)" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) {\n<74> GST_DEBUG ( "Genre: %s -> %s" , value_utf8 , genre_str ) ;\n<75> g_free ( value_utf8 ) ;\n<76> value_utf8 = g_strdup ( genre_str ) ;\n<81> tag_type = gst_tag_get_type ( gst_tag_name ) ;\n<82> g_value_init ( & tag_value , tag_type ) ;\n<83> if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) {\n<101> if ( content3D ) {\n<103> if ( strncmp ( "StereoscopicLayout" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n<127> g_free ( value_utf8 ) ;\n<145> if ( ! strcmp ( name_utf8 , "WM/Track" ) ) ++ uint_val ;\n<151> if ( strncmp ( "Stereoscopic" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n<152> if ( bool_val ) {\n<169> if ( gst_tag_name ) {\n<171> if ( strcmp ( name_utf8 , "WM/TrackNumber" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ;\n<172> gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ;\n<175> GST_DEBUG ( "Setting global metadata %s" , name_utf8 ) ;\n<183> g_free ( name_utf8 ) ;
<1> int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n<53> if (check_params(buf, sizeof(buf), params, str) < 0) {\n<55> fprintf(stderr, "qemu: unknown parameter '%s' in '%s'\n",\n<107> if (get_param_value(buf, sizeof(buf), "bus", str)) {\n<111> if (bus_id < 0) {\n<113> fprintf(stderr, "qemu: '%s' invalid bus id\n", str);\n<123> if (get_param_value(buf, sizeof(buf), "unit", str)) {\n<127> if (unit_id < 0) {\n<129> fprintf(stderr, "qemu: '%s' invalid unit id\n", str);\n<139> if (get_param_value(buf, sizeof(buf), "if", str)) {\n<141> pstrcpy(devname, sizeof(devname), buf);\n<143> if (!strcmp(buf, "ide")) {\n<145> type = IF_IDE;\n<147> max_devs = MAX_IDE_DEVS;\n<149> } else if (!strcmp(buf, "scsi")) {\n<151> type = IF_SCSI;\n<153> max_devs = MAX_SCSI_DEVS;\n<155> } else if (!strcmp(buf, "floppy")) {\n<157> type = IF_FLOPPY;\n<159> max_devs = 0;\n<161> } else if (!strcmp(buf, "pflash")) {\n<163> type = IF_PFLASH;\n<165> max_devs = 0;\n<167> } else if (!strcmp(buf, "mtd")) {\n<169> type = IF_MTD;\n<171> max_devs = 0;\n<173> } else if (!strcmp(buf, "sd")) {\n<175> type = IF_SD;\n<177> max_devs = 0;\n<179> } else if (!strcmp(buf, "virtio")) {\n<181> type = IF_VIRTIO;\n<183> max_devs = 0;\n<185> } else if (!strcmp(buf, "xen")) {\n<187> type = IF_XEN;\n<189> max_devs = 0;\n<193> fprintf(stderr, "qemu: '%s' unsupported bus type '%s'\n", str, buf);\n<195> return -1;\n<203> if (get_param_value(buf, sizeof(buf), "index", str)) {\n<207> if (index < 0) {\n<209> fprintf(stderr, "qemu: '%s' invalid index\n", str);\n<235> if (get_param_value(buf, sizeof(buf), "secs", str)) {\n<245> if (cyls < 1 || cyls > 16383) {\n<247> fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", str);\n<253> if (heads < 1 || heads > 16) {\n<255> fprintf(stderr, "qemu: '%s' invalid physical heads number\n", str);\n<261> if (secs < 1 || secs > 63) {\n<263> fprintf(stderr, "qemu: '%s' invalid physical secs number\n", str);\n<273> if (get_param_value(buf, sizeof(buf), "trans", str)) {\n<275> if (!cyls) {\n<287> if (!strcmp(buf, "none"))\n<289> translation = BIOS_ATA_TRANSLATION_NONE;\n<291> else if (!strcmp(buf, "lba"))\n<293> translation = BIOS_ATA_TRANSLATION_LBA;\n<295> else if (!strcmp(buf, "auto"))\n<297> translation = BIOS_ATA_TRANSLATION_AUTO;\n<301> fprintf(stderr, "qemu: '%s' invalid translation type\n", str);\n<303> return -1;\n<311> if (get_param_value(buf, sizeof(buf), "media", str)) {\n<313> if (!strcmp(buf, "disk")) {\n<315> media = MEDIA_DISK;\n<317> } else if (!strcmp(buf, "cdrom")) {\n<319> if (cyls || secs || heads) {\n<333> fprintf(stderr, "qemu: '%s' invalid media\n", str);\n<335> return -1;\n<343> if (get_param_value(buf, sizeof(buf), "snapshot", str)) {\n<345> if (!strcmp(buf, "on"))\n<347> snapshot = 1;\n<349> else if (!strcmp(buf, "off"))\n<351> snapshot = 0;\n<355> fprintf(stderr, "qemu: '%s' invalid snapshot option\n", str);\n<357> return -1;\n<365> if (get_param_value(buf, sizeof(buf), "cache", str)) {\n<367> if (!strcmp(buf, "off") || !strcmp(buf, "none"))\n<369> cache = 0;\n<371> else if (!strcmp(buf, "writethrough"))\n<373> cache = 1;\n<375> else if (!strcmp(buf, "writeback"))\n<377> cache = 2;\n<381> fprintf(stderr, "qemu: invalid cache option\n");\n<383> return -1;\n<391> if (get_param_value(buf, sizeof(buf), "format", str)) {\n<393> if (strcmp(buf, "?") == 0) {\n<395> fprintf(stderr, "qemu: Supported formats:");\n<397> bdrv_iterate_format(bdrv_format_print, NULL);\n<399> fprintf(stderr, "\n");\n<401> return -1;\n<405> drv = bdrv_find_format(buf);\n<407> if (!drv) {\n<409> fprintf(stderr, "qemu: '%s' invalid format\n", buf);\n<429> if (!get_param_value(serial, sizeof(serial), "serial", str))\n<431> memset(serial, 0,  sizeof(serial));\n<437> if (get_param_value(buf, sizeof(serial), "werror", str)) {\n<439> if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n<441> fprintf(stderr, "werror is no supported by this format\n");\n<447> if (!strcmp(buf, "ignore"))\n<449> onerror = BLOCK_ERR_IGNORE;\n<451> else if (!strcmp(buf, "enospc"))\n<453> onerror = BLOCK_ERR_STOP_ENOSPC;\n<455> else if (!strcmp(buf, "stop"))\n<457> onerror = BLOCK_ERR_STOP_ANY;\n<459> else if (!strcmp(buf, "report"))\n<461> onerror = BLOCK_ERR_REPORT;\n<465> fprintf(stderr, "qemu: '%s' invalid write error action\n", buf);\n<467> return -1;\n<479> if (index != -1) {\n<481> if (bus_id != 0 || unit_id != -1) {\n<519> if (unit_id == -1) {\n<523> while (drive_get_index(type, bus_id, unit_id) != -1) {\n<545> if (max_devs && unit_id >= max_devs) {\n<547> fprintf(stderr, "qemu: '%s' unit %d too big (max is %d)\n",\n<549> str, unit_id, max_devs - 1);\n<565> if (drive_get_index(type, bus_id, unit_id) != -1)\n<607> strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n<667> if (!file[0])\n<693> if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n<695> fprintf(stderr, "qemu: could not open disk image %s\n",
<1> static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n<2> hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n<3> if ( unlikely ( ! c ) ) return NULL ;
<833> if (FIELD_PICTURE(h)) {\n<835> for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)\n<837> memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));\n<841> memset(h->slice_table, -1,\n<843> (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));\n<851> if (h != h0 && (ret = clone_slice(h, h0)) < 0)\n<881> if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n<895> FIELD_OR_MBAFF_PICTURE(h);\n<955> ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);\n<965> ret = ff_set_ref_count(h);\n<979> memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {\n<983> ff_h264_fill_default_ref_list(h);\n<991> ret = ff_h264_decode_ref_pic_list_reordering(h);\n<1011> ff_pred_weight_table(h);\n<1017> implicit_weight_table(h, -1);\n<1061> if (FRAME_MBAFF(h)) {\n<1063> ff_h264_fill_mbaff_ref_list(h);\n<1069> implicit_weight_table(h, 0);\n<1071> implicit_weight_table(h, 1);\n<1081> ff_h264_direct_dist_scale_factor(h);\n<1083> ff_h264_direct_ref_list_init(h);\n<1119> h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);\n<1121> h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);\n<1217> if (h->deblocking_filter == 1 && h0->max_contexts > 1) {\n<1219> if (h->avctx->flags2 & CODEC_FLAG2_FAST) {\n<1241> if (h != h0) {\n<1271> memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));
<1> int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n<6> int i , j , x = 0 , y , ymax ;\n<20> UINT8 * data = ptr + 6 ;\n<23> case 7 : lines = I16 ( data ) ;\n<24> data += 2 ;\n<28> UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n<30> packets = I16 ( data ) ;\n<31> data += 2 ;\n<39> buf = ( UINT8 * ) im -> image [ y ] ;\n<42> buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n<44> packets = I16 ( data ) ;\n<45> data += 2 ;\n<47> for ( p = x = 0 ;\n<50> x += data [ 0 ] ;\n<51> if ( data [ 1 ] >= 128 ) {\n<52> i = 256 - data [ 1 ] ;\n<53> if ( x + i + i > state -> xsize ) break ;\n<57> buf [ x ++ ] = data [ 2 ] ;\n<58> buf [ x ++ ] = data [ 3 ] ;\n<60> data += 2 + 2 ;\n<63> i = 2 * ( int ) data [ 1 ] ;\n<64> if ( x + i > state -> xsize ) break ;\n<65> memcpy ( buf + x , data + 2 , i ) ;\n<66> data += 2 + i ;\n<67> x += i ;\n<77> case 12 : y = I16 ( data ) ;\n<78> ymax = y + I16 ( data + 2 ) ;\n<79> data += 4 ;\n<83> UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n<84> int p , packets = * data ++ ;\n<85> for ( p = x = 0 ;\n<87> p ++ , x += i ) {\n<88> x += data [ 0 ] ;\n<89> if ( data [ 1 ] & 0x80 ) {\n<90> i = 256 - data [ 1 ] ;\n<91> if ( x + i > state -> xsize ) break ;\n<92> memset ( out + x , data [ 2 ] , i ) ;\n<93> data += 3 ;\n<96> i = data [ 1 ] ;\n<97> if ( x + i > state -> xsize ) break ;\n<98> memcpy ( out + x , data + 2 , i ) ;\n<99> data += i + 2 ;\n<110> y < state -> ysize ;\n<111> y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n<116> UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n<117> data += 1 ;\n<119> x < state -> xsize ;\n<120> x += i ) {\n<121> if ( data [ 0 ] & 0x80 ) {\n<122> i = 256 - data [ 0 ] ;\n<123> if ( x + i > state -> xsize ) break ;\n<124> memcpy ( out + x , data + 1 , i ) ;\n<125> data += i + 1 ;\n<128> i = data [ 0 ] ;\n<129> if ( x + i > state -> xsize ) break ;\n<130> memset ( out + x , data [ 1 ] , i ) ;\n<131> data += 2 ;\n<134> if ( x != state -> xsize ) {\n<141> y < state -> ysize ;\n<143> UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n<144> memcpy ( buf + x , data , state -> xsize ) ;\n<145> data += state -> xsize ;
<1> static void report_unavailable_features(FeatureWord w, uint32_t mask)\n<5> FeatureWordInfo *f = &feature_word_info[w];\n<11> for (i = 0; i < 32; ++i) {\n<13> if ((1UL << i) & mask) {\n<17> assert(reg);\n<19> fprintf(stderr, "warning: %s doesn't support requested feature: "
<1> static void *spapr_create_fdt_skel(const char *cpu_model,\n<167> modelname = g_strdup(cpu_model);\n<171> for (i = 0; i < strlen(modelname); i++) {\n<173> modelname[i] = toupper(modelname[i]);\n<203> if ((index % smt) != 0) {\n<211> if (asprintf(&nodename, "%s@%x", modelname, index) < 0) {\n<213> fprintf(stderr, "Allocation failure\n");\n<215> exit(1);\n<225> free(nodename);\n<265> servers_prop[i] = cpu_to_be32(index + i);\n<331> g_free(modelname);
<1> static int tgv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> TgvContext * s = avctx -> priv_data ;\n<27> s -> palette [ i ] = AV_RB24 ( buf ) ;\n<33> if ( ! s -> frame . data [ 0 ] ) {\n<39> s -> frame . data [ 1 ] = av_malloc ( AVPALETTE_SIZE ) ;\n<40> if ( ! s -> frame . data [ 1 ] ) {\n<45> memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n<61> if ( tgv_decode_inter ( s , buf , buf_end ) < 0 ) {
<1> void bios_linker_loader_add_pointer(GArray *linker,\n<3> const char *dest_file,\n<5> const char *src_file,\n<17> memset(&entry, 0, sizeof entry);\n<21> sizeof entry.pointer.dest_file - 1);\n<25> sizeof entry.pointer.src_file - 1);\n<39> g_array_append_val(linker, entry);
<1> static int qemu_rbd_set_conf(rados_t cluster, const char *conf)\n<51> if (ret < 0) {\n<59> if (strcmp(name, "conf")) {\n<61> ret = rados_conf_set(cluster, name, value);\n<63> if (ret < 0) {\n<75> ret = rados_conf_read_file(cluster, value);\n<77> if (ret < 0) {
<1> static target_ulong h_get_term_char(CPUState *env, sPAPREnvironment *spapr,\n<29> *len = vty_getchars(sdev, buf, sizeof(buf));\n<31> if (*len < 16) {\n<33> memset(buf + *len, 0, 16 - *len);
<1> static int aasc_decode_frame(AVCodecContext *avctx,\n<35> buf += 4;\n<59> if(avctx->width*3 > buf_size){\n<67> memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3);\n<69> buf += stride;
<1> static void handle_raw_ping ( struct query * q , int dns_fd , int userid ) {\n<2> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<6> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<7> if ( debug >= 1 ) {\n<8> fprintf ( stderr , "IN ping raw, from user %d\n" , userid ) ;\n<10> send_raw ( dns_fd , NULL , 0 , userid , RAW_HDR_CMD_PING , q ) ;
<1> static int rscc_decode_frame(AVCodecContext *avctx, void *data,\n<7> RsccContext *ctx = avctx->priv_data;\n<351> if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n<359> if (pal) {\n<363> memcpy(ctx->pal, pal, AVPALETTE_SIZE);\n<367> memcpy (frame->data[1], ctx->pal, AVPALETTE_SIZE);
<1> static int nbd_send_option_request(QIOChannel *ioc, uint32_t opt,\n<3> uint32_t len, const char *data,\n<15> if (len == -1) {\n<17> req.length = len = strlen(data);\n<29> stl_be_p(&req.length, len);\n<33> if (write_sync(ioc, &req, sizeof(req), errp) < 0) {\n<43> if (len && write_sync(ioc, (char *) data, len, errp) < 0) {
<1> static int rtsp_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> RTSPState *rt = s->priv_data;\n<19> enum AVDiscard cache[MAX_STREAMS];\n<25> cache[i] = s->streams[i]->discard;\n<29> if (!rt->need_subscription) {\n<33> sizeof(enum AVDiscard) * s->nb_streams)) {\n<35> snprintf(cmd, sizeof(cmd),\n<39> rt->last_subscription);\n<41> ff_rtsp_send_cmd(s, "SET_PARAMETER", rt->control_uri,\n<45> if (reply->status_code != RTSP_STATUS_OK)\n<57> if (rt->need_subscription) {\n<65> sizeof(enum AVDiscard) * s->nb_streams);
<1> static int mov_read_trak(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n<95> if (url_fopen(&sc->pb, sc->drefs[sc->dref_id-1].path, URL_RDONLY) < 0)\n<97> av_log(c->fc, AV_LOG_ERROR, "stream %d, error opening file %s: %s\n",\n<99> st->index, sc->drefs[sc->dref_id-1].path, strerror(errno));
<1> static int remoteStreamHandleRead ( struct qemud_client * client , struct qemud_client_stream * stream ) {\n<12> else if ( ret < 0 ) {\n<14> memset ( & rerr , 0 , sizeof rerr ) ;\n<15> remoteDispatchConnError ( & rerr , NULL ) ;\n<16> ret = remoteSerializeStreamError ( client , & rerr , stream -> procedure , stream -> serial ) ;
<1> static int usb_host_scan(void *opaque, USBScanFunc *func)\n<15> char devpath[PATH_MAX];\n<29> strcpy(devpath, USBDEVBUS_PATH);\n<47> strcpy(devpath, USBPROCBUS_PATH);\n<67> strcpy(devpath, USBDEVBUS_PATH);\n<81> if (!usb_fs_type) {\n<93> usb_host_device_path = qemu_mallocz(strlen(devpath)+1);\n<95> strcpy(usb_host_device_path, devpath);
<1> static int cookie_string(AVDictionary *dict, char **cookies)\n<7> int len = 1;\n<13> while (e = av_dict_get(dict, "", e, AV_DICT_IGNORE_SUFFIX))\n<15> len += strlen(e->key) + strlen(e->value) + 1;\n<25> *cookies = av_malloc(len);\n<35> while (e = av_dict_get(dict, "", e, AV_DICT_IGNORE_SUFFIX))\n<37> av_strlcatf(*cookies, len, "%s%s\n", e->key, e->value);
<1> static QEMUCursor *qxl_cursor(PCIQXLDevice *qxl, QXLCursor *cursor,\n<19> switch (cursor->header.type) {\n<37> fprintf(stderr, "%s: not implemented: type %d\n",
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> KmvcContext * const ctx = avctx -> priv_data ;\n<7> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<12> if ( ( ret = ff_get_buffer ( avctx , & ctx -> pic ) ) < 0 ) {\n<22> ctx -> pal [ i + ( header & 0x81 ) ] = bytestream2_get_be24 ( & ctx -> g ) ;\n<40> ctx -> pal [ i ] = bytestream2_get_be24 ( & ctx -> g ) ;\n<43> if ( pal ) {\n<45> memcpy ( ctx -> pal , pal , AVPALETTE_SIZE ) ;\n<51> memcpy ( ctx -> pic . data [ 1 ] , ctx -> pal , 1024 ) ;\n<53> if ( blocksize != 8 && blocksize != 127 ) {\n<57> memset ( ctx -> cur , 0 , 320 * 200 ) ;\n<58> switch ( header & KMVC_METHOD ) {\n<59> case 0 : case 1 : memcpy ( ctx -> cur , ctx -> prev , 320 * 200 ) ;\n<61> case 3 : kmvc_decode_intra_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n<63> case 4 : kmvc_decode_inter_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n<68> out = ctx -> pic . data [ 0 ] ;\n<69> src = ctx -> cur ;\n<71> i < avctx -> height ;\n<73> memcpy ( out , src , avctx -> width ) ;\n<74> src += 320 ;\n<75> out += ctx -> pic . linesize [ 0 ] ;\n<77> if ( ctx -> cur == ctx -> frm0 ) {
<1> static inline int onenand_erase(OneNANDState *s, int sec, int num)\n<9> if (!blankbuf) {\n<17> if (!tmpbuf) {\n<25> memset(blankbuf, 0xff, 512);\n<33> if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {\n<39> if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n<45> memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);\n<55> if (sec + 1 > s->secs_cur) {\n<61> memcpy(s->current + (sec << 9), blankbuf, 512);\n<63> memcpy(s->current + (s->secs_cur << 9) + (sec << 4),\n<65> blankbuf, 1 << 4);\n<75> g_free(blankbuf);\n<85> g_free(blankbuf);
<1> static int audio_decode_frame(VideoState *is, double *pts_ptr)\n<5> AVPacket *pkt_temp = &is->audio_pkt_temp;\n<31> while (pkt_temp->size > 0 || (!pkt_temp->data && new_packet)) {\n<51> if (flush_complete)\n<57> len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);\n<59> if (len1 < 0) {\n<63> pkt_temp->size = 0;\n<71> pkt_temp->data += len1;\n<73> pkt_temp->size -= len1;\n<81> if (!pkt_temp->data && dec->codec->capabilities & CODEC_CAP_DELAY)\n<89> data_size = av_samples_get_buffer_size(NULL, dec->channels,\n<97> dec_channel_layout = (dec->channel_layout && dec->channels == av_get_channel_layout_nb_channels(dec->channel_layout)) ? dec->channel_layout : av_get_default_channel_layout(dec->channels);\n<107> dec->sample_rate != is->audio_src.freq ||\n<123> if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {\n<125> fprintf(stderr, "Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\n",\n<129> av_get_sample_fmt_name(dec->sample_fmt),\n<135> av_get_sample_fmt_name(is->audio_tgt.fmt),\n<165> if (swr_set_compensation(is->swr_ctx, (wanted_nb_samples - is->frame->nb_samples) * is->audio_tgt.freq / dec->sample_rate,\n<169> fprintf(stderr, "swr_set_compensation() failed\n");\n<181> if (len2 < 0) {\n<183> fprintf(stderr, "swr_convert() failed\n");\n<189> if (len2 == sizeof(is->audio_buf2) / is->audio_tgt.channels / av_get_bytes_per_sample(is->audio_tgt.fmt)) {\n<191> fprintf(stderr, "warning: audio buffer is probably too small\n");\n<217> (dec->channels * dec->sample_rate * av_get_bytes_per_sample(dec->sample_fmt));\n<249> memset(pkt_temp, 0, sizeof(*pkt_temp));\n<271> avcodec_flush_buffers(dec);
<1> static int http_open(URLContext *h, const char *uri, int flags)\n<5> HTTPContext *s = h->priv_data;\n<19> if (s->headers) {\n<21> int len = strlen(s->headers);\n<23> if (len < 2 || strcmp("\r\n", s->headers + len - 2))\n<25> av_log(h, AV_LOG_WARNING, "No trailing CRLF found in HTTP header.\n");
<1> static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n<3> const char *filt_name, const char *args, void *log_ctx)\n<21> filt = avfilter_get_by_name(filt_name);\n<37> *filt_ctx = avfilter_graph_alloc_filter(ctx, filt, inst_name);\n<39> if (!*filt_ctx) {\n<51> if (!strcmp(filt_name, "scale") && args && !strstr(args, "flags") &&\n<53> ctx->scale_sws_opts) {\n<55> snprintf(tmp_args, sizeof(tmp_args), "%s:%s",\n<57> args, ctx->scale_sws_opts);\n<59> args = tmp_args;\n<65> ret = avfilter_init_str(*filt_ctx, args);
<1> static int binkb_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_key , int is_chroma ) {\n<30> dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n<33> bx ++ , dst += 8 ) {\n<35> switch ( blk ) {\n<52> j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n<57> j ++ ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n<61> if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n<63> case 2 : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<64> dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTRA_DC ) ;\n<66> read_dct_coeffs ( gb , dctblock , bink_scan , binkb_intra_quant , qp ) ;\n<67> c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n<98> memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<99> dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTER_DC ) ;\n<101> read_dct_coeffs ( gb , dctblock , bink_scan , binkb_inter_quant , qp ) ;\n<102> c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n<116> j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n<133> i < 8 ;\n<134> i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINKB_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;
<1> static inline int decode_seq_parameter_set(H264Context *h){\n<35> if(sps == NULL)\n<47> memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n<49> memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n<69> decode_scaling_matrices(h, sps, NULL, 1, sps->scaling_matrix4, sps->scaling_matrix8);\n<233> decode_vui_parameters(h, sps);
<1> void pdo_stmt_init ( TSRMLS_D ) {\n<9> memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ;
<35> uint8_t black[4] = { 16, 128, 128, 16 };\n<55> for (i = 0; i < 4 && tinterlace->black_data[i]; i++) {\n<61> tinterlace->black_linesize[i] * h);
<1> static void virt_acpi_get_cpu_info(VirtAcpiCpuInfo *cpuinfo)\n<9> memset(cpuinfo->found_cpus, 0, sizeof cpuinfo->found_cpus);\n<13> set_bit(cpu->cpu_index, cpuinfo->found_cpus);
<1> static void sbr_qmf_synthesis ( FFTContext * mdct , SBRDSPContext * sbrdsp , AVFloatDSPContext * dsp , float * out , float X [ 2 ] [ 38 ] [ 64 ] , float mdct_buf [ 2 ] [ 64 ] , float * v0 , int * v_off , const unsigned int div ) {\n<9> if ( * v_off < step ) {\n<11> memcpy ( & v0 [ SBR_SYNTHESIS_BUF_SIZE - saved_samples ] , v0 , saved_samples * sizeof ( float ) ) ;\n<17> v = v0 + * v_off ;
<1> static int check_refcounts_l2(BlockDriverState *bs, BdrvCheckResult *res,\n<27> if (bdrv_pread(bs->file, l2_offset, l2_table, l2_size) != l2_size)\n<191> fprintf(stderr, "ERROR: I/O error in check_refcounts_l2\n");
<1> static int indeo3_decode_frame(AVCodecContext *avctx,\n<49> src = s->cur_frame->Ybuf;\n<51> dest = s->frame.data[0];\n<53> for (y = 0; y < s->height; y++) {\n<55> memcpy(dest, src, s->cur_frame->y_w);\n<57> src += s->cur_frame->y_w;\n<59> dest += s->frame.linesize[0];\n<69> src = s->cur_frame->Ubuf;\n<71> dest = s->frame.data[1];\n<73> for (y = 0; y < s->height / 4; y++) {\n<75> memcpy(dest, src, s->cur_frame->uv_w);\n<77> src += s->cur_frame->uv_w;\n<79> dest += s->frame.linesize[1];\n<85> src = s->cur_frame->Vbuf;\n<87> dest = s->frame.data[2];\n<89> for (y = 0; y < s->height / 4; y++) {\n<91> memcpy(dest, src, s->cur_frame->uv_w);\n<93> src += s->cur_frame->uv_w;\n<95> dest += s->frame.linesize[2];
<1> static int interface_client_monitors_config(QXLInstance *sin,\n<9> QXLRom *rom = memory_region_get_ram_ptr(&qxl->rom_bar);\n<13> unsigned max_outputs = ARRAY_SIZE(rom->client_monitors_config.heads);\n<53> if (!monitors_config) {\n<115> (const uint8_t *)&rom->client_monitors_config,
<1> int check_params(char *buf, int buf_size,\n<3> const char * const *params, const char *str)\n<17> p = get_opt_name(buf, buf_size, p, '=');\n<27> for (i = 0; params[i] != NULL; i++) {\n<29> if (!strcmp(params[i], buf)) {\n<37> if (params[i] == NULL) {
<27> if (rc < 0) {\n<29> error_setg(errp, "cannot get SG_IO version number: %s.  "\n<33> strerror(-rc));
<1> void unregister_savevm(DeviceState *dev, const char *idstr, void *opaque)\n<27> pstrcat(id, sizeof(id), idstr);\n<31> QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n<33> if (strcmp(se->idstr, id) == 0 && se->opaque == opaque) {\n<35> QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n<37> if (se->compat) {\n<43> g_free(se->ops);\n<45> g_free(se);
<1> static void qemu_rbd_parse_filename(const char *filename, QDict *options,\n<19> if (!strstart(filename, "rbd:", &start)) {\n<29> max_keypair_size = strlen(start) + 1;\n<31> buf = g_strdup(start);\n<33> keypairs = g_malloc0(max_keypair_size);\n<49> if (!p) {\n<63> if (strchr(p, '@')) {\n<65> found_str = qemu_rbd_next_tok(RBD_MAX_IMAGE_NAME_SIZE, p,\n<67> '@', "object name", &p, &local_err);\n<69> if (local_err) {\n<97> found_str = qemu_rbd_next_tok(RBD_MAX_IMAGE_NAME_SIZE, p,\n<99> ':', "object name", &p, &local_err);\n<101> if (local_err) {\n<167> qemu_rbd_unescape(name);\n<175> if (local_err) {\n<185> if (!strcmp(name, "conf")) {\n<187> qdict_put(options, "conf", qstring_from_str(value));\n<189> } else if (!strcmp(name, "id")) {\n<191> qdict_put(options, "user" , qstring_from_str(value));\n<205> char *tmp = g_malloc0(max_keypair_size);\n<213> if (keypairs[0]) {\n<215> snprintf(tmp, max_keypair_size, ":%s=%s", name, value);\n<221> snprintf(keypairs, max_keypair_size, "%s=%s", name, value);\n<225> g_free(tmp);
<1> static int qcow2_amend_options(BlockDriverState *bs, QemuOpts *opts,\n<37> while (desc && desc->name) {\n<39> if (!qemu_opt_find(opts, desc->name)) {\n<51> if (!strcmp(desc->name, BLOCK_OPT_COMPAT_LEVEL)) {\n<53> compat = qemu_opt_get(opts, BLOCK_OPT_COMPAT_LEVEL);\n<55> if (!compat) {\n<59> } else if (!strcmp(compat, "0.10")) {\n<61> new_version = 2;\n<63> } else if (!strcmp(compat, "1.1")) {\n<65> new_version = 3;\n<69> error_report("Unknown compatibility level %s", compat);\n<71> return -EINVAL;\n<75> } else if (!strcmp(desc->name, BLOCK_OPT_PREALLOC)) {\n<77> error_report("Cannot change preallocation mode");\n<79> return -ENOTSUP;\n<81> } else if (!strcmp(desc->name, BLOCK_OPT_SIZE)) {\n<83> new_size = qemu_opt_get_size(opts, BLOCK_OPT_SIZE, 0);\n<85> } else if (!strcmp(desc->name, BLOCK_OPT_BACKING_FILE)) {\n<87> backing_file = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);\n<89> } else if (!strcmp(desc->name, BLOCK_OPT_BACKING_FMT)) {\n<91> backing_format = qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT);\n<93> } else if (!strcmp(desc->name, BLOCK_OPT_ENCRYPT)) {\n<95> encrypt = qemu_opt_get_bool(opts, BLOCK_OPT_ENCRYPT,\n<97> !!s->cipher);\n<101> if (encrypt != !!s->cipher) {\n<109> } else if (!strcmp(desc->name, BLOCK_OPT_CLUSTER_SIZE)) {\n<111> cluster_size = qemu_opt_get_size(opts, BLOCK_OPT_CLUSTER_SIZE,\n<115> if (cluster_size != s->cluster_size) {\n<123> } else if (!strcmp(desc->name, BLOCK_OPT_LAZY_REFCOUNTS)) {\n<125> lazy_refcounts = qemu_opt_get_bool(opts, BLOCK_OPT_LAZY_REFCOUNTS,\n<129> } else if (!strcmp(desc->name, BLOCK_OPT_REFCOUNT_BITS)) {\n<131> refcount_bits = qemu_opt_get_number(opts, BLOCK_OPT_REFCOUNT_BITS,\n<137> if (refcount_bits <= 0 || refcount_bits > 64 ||\n<157> abort();\n<163> desc++;
<1> static int decode_p_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n<25> av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<26> if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n<27> f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) ( buf + extra ) , bitstream_size / 4 ) ;\n<28> memset ( ( uint8_t * ) f -> bitstream_buffer + bitstream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;
<1> static int img_rebase(int argc, char **argv)\n<279> buf_old = qemu_blockalign(bs, IO_BUF_SIZE);\n<281> buf_new = qemu_blockalign(bs, IO_BUF_SIZE);\n<335> if (sector >= old_backing_num_sectors) {\n<337> memset(buf_old, 0, n * BDRV_SECTOR_SIZE);\n<349> ret = bdrv_read(bs_old_backing, sector, buf_old, n);\n<363> if (sector >= new_backing_num_sectors) {\n<365> memset(buf_new, 0, n * BDRV_SECTOR_SIZE);\n<377> ret = bdrv_read(bs_new_backing, sector, buf_new, n);\n<403> if (compare_sectors(buf_old + written * 512,\n<405> buf_new + written * 512, n - written, &pnum))\n<413> if (ret < 0) {\n<415> error_report("Error while writing to COW image: %s",\n<417> strerror(-ret));\n<437> qemu_vfree(buf_old);\n<439> qemu_vfree(buf_new);\n<463> } else if (ret < 0) {\n<465> error_report("Could not change the backing file to '%s': %s",\n<467> out_baseimg, strerror(-ret));
<1> static int mpeg_decode_postinit(AVCodecContext *avctx)\n<9> uint8_t old_permutation[64];\n<137> if (ret < 0)\n<211> memcpy(old_permutation, s->idsp.idct_permutation, 64 * sizeof(uint8_t));\n<223> quant_matrix_rebuild(s->intra_matrix,        old_permutation, s->idsp.idct_permutation);
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<30> uint8_t * dst = pic -> data [ 0 ] ;\n<33> field_size = bytestream_get_le32 ( & buf ) ;\n<38> if ( buf_end - buf < field_size ) {\n<42> if ( field ) dst += pic -> linesize [ 0 ] ;\n<44> i < field_h ;\n<46> memcpy ( dst , buf , avctx -> width * 2 ) ;\n<47> buf += avctx -> width * 2 ;\n<48> dst += pic -> linesize [ 0 ] << 1 ;
<1> static int connect_to_sdog(BDRVSheepdogState *s, Error **errp)\n<17> if (ret < 0) {\n<19> error_report("%s", strerror(errno));
<1> static int doTest(uint8_t *ref[4], int refStride[4], int w, int h,\n<77> if (!srcContext) {\n<149> dstContext= sws_getContext(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, NULL, NULL, NULL);\n<151> if (!dstContext) {\n<167> outContext= sws_getContext(dstW, dstH, dstFormat, w, h, PIX_FMT_YUVA420P, flags, NULL, NULL, NULL);\n<169> if (!outContext) {\n<203> sws_scale(dstContext, src, srcStride, 0, srcH, dst, dstStride);\n<205> sws_scale(outContext, dst, dstStride, 0, dstH, out, refStride);
<1> static int rtmp_server_handshake(URLContext *s, RTMPContext *rt)\n<39> if (buffer[0] != 3) {\n<119> ret = rtmp_receive_hs_packet(rt, &temp, &zeroes, buffer,\n<123> if (ret) {\n<139> RTMP_HANDSHAKE_PACKET_SIZE - 8))
<1> static int vhdx_create(const char *filename, QEMUOptionParameter *options,\n<37> while (options && options->name) {\n<39> if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n<41> image_size = options->value.n;\n<43> } else if (!strcmp(options->name, VHDX_BLOCK_OPT_LOG_SIZE)) {\n<45> log_size = options->value.n;\n<47> } else if (!strcmp(options->name, VHDX_BLOCK_OPT_BLOCK_SIZE)) {\n<49> block_size = options->value.n;\n<51> } else if (!strcmp(options->name, BLOCK_OPT_SUBFMT)) {\n<53> type = options->value.s;\n<55> } else if (!strcmp(options->name, VHDX_BLOCK_OPT_ZERO)) {\n<57> use_zero_blocks = options->value.n != 0;\n<61> options++;\n<67> if (image_size > VHDX_MAX_IMAGE_SIZE) {\n<79> if (type == NULL) {\n<81> type = "dynamic";\n<87> if (!strcmp(type, "dynamic")) {\n<89> image_type = VHDX_TYPE_DYNAMIC;\n<91> } else if (!strcmp(type, "fixed")) {\n<93> image_type = VHDX_TYPE_FIXED;\n<95> } else if (!strcmp(type, "differencing")) {\n<101> ret = -ENOTSUP;\n<107> ret = -EINVAL;\n<119> if (block_size == 0) {\n<149> log_size = ROUND_UP(log_size, MiB);\n<153> block_size = ROUND_UP(block_size, MiB);\n<155> block_size = block_size > VHDX_BLOCK_SIZE_MAX ? VHDX_BLOCK_SIZE_MAX :\n<161> ret = bdrv_create_file(filename, options, &local_err);\n<163> if (ret < 0) {
<1> av_cold static int fbdev_read_header(AVFormatContext *avctx,\n<53> if ((fbdev->fd = open(avctx->filename, flags)) == -1) {\n<55> ret = AVERROR(errno);\n<61> avctx->filename, strerror(ret));\n<63> return ret;\n<69> if (ioctl(fbdev->fd, FBIOGET_VSCREENINFO, &fbdev->varinfo) < 0) {\n<71> ret = AVERROR(errno);\n<75> "FBIOGET_VSCREENINFO: %s\n", strerror(errno));\n<83> if (ioctl(fbdev->fd, FBIOGET_FSCREENINFO, &fbdev->fixinfo) < 0) {\n<85> ret = AVERROR(errno);\n<89> "FBIOGET_FSCREENINFO: %s\n", strerror(errno));\n<127> if (fbdev->data == MAP_FAILED) {\n<129> ret = AVERROR(errno);\n<131> av_log(avctx, AV_LOG_ERROR, "Error in mmap(): %s\n", strerror(errno));
<1> static void pool_release_buffer(void *opaque, uint8_t *data)\n<5> BufferPoolEntry *buf = opaque;\n<7> AVBufferPool *pool = buf->pool;\n<11> if(CONFIG_MEMORY_POISONING)\n<13> memset(buf->data, 0x2a, pool->size);\n<17> add_to_pool(buf);\n<21> buffer_pool_free(pool);
<1> static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<13> const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;\n<43> if (!flush_buf)\n<47> memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));\n<49> samples = flush_buf;\n<59> av_freep(&flush_buf);\n<107> av_freep(&flush_buf);
<1> static int mxf_read_header(AVFormatContext *s)\n<5> MXFContext *mxf = s->priv_data;\n<21> if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n<47> if (klv_read_packet(&klv, s->pb) < 0) {\n<51> if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n<63> PRINT_KEY(s, "read header", klv.key);\n<67> if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n<69> IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n<71> IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n<73> IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n<77> if (!mxf->current_partition) {\n<87> if (!mxf->current_partition->essence_offset) {\n<105> round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n<107> round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n<119> mxf->current_partition->essence_offset = avio_tell(s->pb);\n<121> mxf->current_partition->essence_length = klv.length;\n<127> mxf->current_partition->essence_offset = op1a_essence_offset;\n<143> if (mxf_parse_handle_essence(mxf) <= 0)\n<149> } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n<151> klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n<155> if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n<169> for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n<171> if (IS_KLV_KEY(klv.key, metadata->key)) {\n<175> if (klv.key[5] == 0x53) {\n<177> res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n<181> uint64_t next = avio_tell(s->pb) + klv.length;\n<183> res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n<221> avio_skip(s->pb, klv.length);\n<239> mxf_compute_essence_containers(mxf);\n<247> if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n<253> if ((ret = mxf_compute_index_tables(mxf)) < 0)
<1> static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamples)\n<33> if (showwaves->buf_idx == 0 && showwaves->sample_count_mod == 0) {\n<55> memset(outpicref->data[0], 0, showwaves->h*linesize);\n<65> *(outpicref->data[0] + showwaves->buf_idx + h * linesize) += x;
<1> static int decode_subframe(WMAProDecodeCtx *s)\n<347> sizeof(*s->channel[c].coeffs) * subframe_len);\n<377> if (c == s->lfe_channel)\n<379> memset(&s->tmp[cur_subwoofer_cutoff], 0, sizeof(*s->tmp) *\n<401> s->dsp.vector_fmul_scalar(s->tmp + start,\n<413> mdct->imdct_half(mdct, s->channel[c].coeffs, s->tmp);
<1> static void tcg_out_setcond2(TCGContext *s, const TCGArg *args,\n<7> TCGArg new_args[6];\n<13> memcpy(new_args, args+1, 5*sizeof(TCGArg));\n<35> tcg_out_brcond2(s, new_args, const_args+1, 1);\n<67> new_args[4] = tcg_invert_cond(new_args[4]);\n<71> tcg_out_brcond2(s, new_args, const_args+1, 1);
<1> intptr_t (*checkasm_check_func(intptr_t (*func)(), const char *name, ...))()\n<17> va_start(arg, name);\n<19> name_length = vsnprintf(name_buf, sizeof(name_buf), name, arg);\n<21> va_end(arg);\n<25> if (!func || name_length <= 0 || name_length >= sizeof(name_buf))\n<31> state.current_func = get_func(name_buf, name_length);
<1> static void connex_init(MachineState *machine)\n<27> if (!dinfo && !qtest_enabled()) {\n<29> fprintf(stderr, "A flash image must be given with the "\n<49> if (!pflash_cfi01_register(0x00000000, NULL, "connext.rom", connex_rom,\n<57> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> static void term_down_char(void)\n<5> if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n<21> term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
<1> char * ksba_oid_to_str ( const char * buffer , size_t length ) {\n<2> const unsigned char * buf = buffer ;\n<7> string = p = xtrymalloc ( length * ( 1 + 3 ) + 2 + 1 ) ;\n<13> if ( buf [ 0 ] < 40 ) p += sprintf ( p , "0.%d" , buf [ n ] ) ;\n<14> else if ( buf [ 0 ] < 80 ) p += sprintf ( p , "1.%d" , buf [ n ] - 40 ) ;\n<17> while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n<22> val -= 80 ;\n<23> sprintf ( p , "2.%lu" , val ) ;\n<24> p += strlen ( p ) ;\n<29> val = buf [ n ] & 0x7f ;\n<30> while ( ( buf [ n ] & 0x80 ) && ++ n < length ) {\n<33> val |= buf [ n ] & 0x7f ;\n<35> sprintf ( p , ".%lu" , val ) ;\n<36> p += strlen ( p ) ;
<1> static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,\n<95> if (ret < 0) {\n<97> fprintf(stderr, "ERROR: Could not read L2 table: %s\n",\n<99> strerror(-ret));\n<181> if (ret < 0) {\n<183> fprintf(stderr, "ERROR: Could not write L2 table; metadata "\n<185> "overlap check failed: %s\n", strerror(-ret));\n<199> if (ret < 0) {\n<201> fprintf(stderr, "ERROR: Could not write L2 table: %s\n",\n<203> strerror(-ret));
<1> static int sp5x_decode_frame(AVCodecContext *avctx,\n<47> if (!recoded)\n<57> recoded[j++] = 0xD8;\n<61> memcpy(recoded+j, &sp5x_data_dqt[0], sizeof(sp5x_data_dqt));\n<63> memcpy(recoded+j+5, &sp5x_quant_table[qscale * 2], 64);\n<65> memcpy(recoded+j+70, &sp5x_quant_table[(qscale * 2) + 1], 64);\n<67> j += sizeof(sp5x_data_dqt);\n<71> memcpy(recoded+j, &sp5x_data_dht[0], sizeof(sp5x_data_dht));\n<73> j += sizeof(sp5x_data_dht);\n<77> memcpy(recoded+j, &sp5x_data_sof[0], sizeof(sp5x_data_sof));\n<79> recoded[j+5] = (avctx->coded_height >> 8) & 0xFF;\n<81> recoded[j+6] = avctx->coded_height & 0xFF;\n<83> recoded[j+7] = (avctx->coded_width >> 8) & 0xFF;\n<85> recoded[j+8] = avctx->coded_width & 0xFF;\n<87> j += sizeof(sp5x_data_sof);\n<91> memcpy(recoded+j, &sp5x_data_sos[0], sizeof(sp5x_data_sos));
<1> static int decode_user_data(MpegEncContext *s, GetBitContext *gb){\n<3> char buf[256];\n<9> int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n<23> buf[i]=0;\n<29> e=sscanf(buf, "DivX%dBuild%d%c", &ver, &build, &last);\n<31> if(e<2)\n<33> e=sscanf(buf, "DivX%db%d%c", &ver, &build, &last);\n<35> if(e>=2){\n<37> s->divx_version= ver;\n<39> s->divx_build= build;\n<41> s->divx_packed= e==3 && last=='p';\n<53> e=sscanf(buf, "FFmpe%*[^b]b%d", &build)+3;\n<55> if(e!=4)\n<57> e=sscanf(buf, "FFmpeg v%d.%d.%d / libavcodec build: %d", &ver, &ver2, &ver3, &build);\n<59> if(e!=4){\n<61> e=sscanf(buf, "Lavc%d.%d.%d", &ver, &ver2, &ver3)+1;\n<63> if (e>1)\n<65> build= (ver<<16) + (ver2<<8) + ver3;\n<69> if(e!=4){\n<71> if(strcmp(buf, "ffmpeg")==0){\n<73> s->lavc_build= 4600;\n<81> s->lavc_build= build;\n<89> e=sscanf(buf, "XviD%d", &build);\n<91> if(e==1){\n<93> s->xvid_build= build;
<1> sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,\n<19> if (spapr_tce_find_by_liobn(liobn)) {\n<21> fprintf(stderr, "Attempted to create TCE table with duplicate"
<1> int main ( int argc , const char * * argv ) {\n<13> uint32_t frame_cnt = 0 ;\n<21> memset ( & svc_ctx , 0 , sizeof ( svc_ctx ) ) ;\n<24> parse_command_line ( argc , argv , & app_input , & svc_ctx , & enc_cfg ) ;\n<27> if ( vpx_svc_init ( & svc_ctx , & codec , vpx_codec_vp9_cx ( ) , & enc_cfg ) != VPX_CODEC_OK ) die ( "Failed to initialize encoder\n" ) ;\n<31> if ( vpx_svc_get_layer_resolution ( & svc_ctx , svc_ctx . spatial_layers - 1 , ( unsigned int * ) & info . frame_width , ( unsigned int * ) & info . frame_height ) != VPX_CODEC_OK ) {\n<41> while ( ! end_of_stream ) {\n<42> if ( frame_cnt >= app_input . frames_to_code || ! vpx_img_read ( & raw , infile ) ) {\n<45> res = vpx_svc_encode ( & svc_ctx , & codec , ( end_of_stream ? NULL : & raw ) , pts , frame_duration , VPX_DL_GOOD_QUALITY ) ;\n<46> printf ( "%s" , vpx_svc_get_message ( & svc_ctx ) ) ;\n<51> while ( ( frame_size = vpx_svc_get_frame_size ( & svc_ctx ) ) > 0 ) {\n<52> vpx_video_writer_write_frame ( writer , vpx_svc_get_buffer ( & svc_ctx ) , frame_size , pts ) ;\n<55> if ( vpx_svc_get_rc_stats_buffer_size ( & svc_ctx ) > 0 ) {\n<56> stats_write ( & app_input . rc_stats , vpx_svc_get_rc_stats_buffer ( & svc_ctx ) , vpx_svc_get_rc_stats_buffer_size ( & svc_ctx ) ) ;\n<59> ++ frame_cnt ;\n<63> printf ( "Processed %d frames\n" , frame_cnt ) ;\n<71> printf ( "%s" , vpx_svc_dump_statistics ( & svc_ctx ) ) ;\n<72> vpx_svc_release ( & svc_ctx ) ;
<1> int net_client_init(const char *device, const char *p)\n<17> char *name = NULL;\n<33> if (get_param_value(buf, sizeof(buf), "name", p)) {\n<35> name = strdup(buf);\n<39> if (!strcmp(device, "nic")) {\n<51> int idx = nic_get_free_idx();\n<55> if (check_params(nic_params, p) < 0) {\n<57> fprintf(stderr, "qemu: invalid parameter '%s' in '%s'\n",\n<65> if (idx == -1 || nb_nics >= MAX_NICS) {\n<67> fprintf(stderr, "Too Many NICs\n");\n<95> if (parse_macaddr(macaddr, buf) < 0) {\n<97> fprintf(stderr, "invalid syntax for ethernet address\n");\n<107> if (get_param_value(buf, sizeof(buf), "model", p)) {\n<109> nd->model = strdup(buf);\n<115> nd->name = name;\n<119> name = NULL;\n<129> if (!strcmp(device, "none")) {\n<131> if (*p != '\0') {\n<133> fprintf(stderr, "qemu: 'none' takes no parameters\n");\n<289> if (!strcmp(device, "tap")) {\n<291> char ifname[64];\n<293> char setup_script[1024], down_script[1024];\n<297> vlan->nb_host_devs++;\n<299> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<301> if (check_params(fd_params, p) < 0) {\n<303> fprintf(stderr, "qemu: invalid parameter '%s' in '%s'\n",\n<315> net_tap_fd_init(vlan, device, name, fd);\n<327> if (check_params(tap_params, p) < 0) {\n<329> fprintf(stderr, "qemu: invalid parameter '%s' in '%s'\n",\n<355> ret = net_tap_init(vlan, device, name, ifname, setup_script, down_script);\n<363> if (!strcmp(device, "socket")) {\n<365> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<369> if (check_params(fd_params, p) < 0) {\n<371> fprintf(stderr, "qemu: invalid parameter '%s' in '%s'\n",\n<383> if (net_socket_fd_init(vlan, device, name, fd, 1))\n<387> } else if (get_param_value(buf, sizeof(buf), "listen", p) > 0) {\n<395> if (check_params(listen_params, p) < 0) {\n<397> fprintf(stderr, "qemu: invalid parameter '%s' in '%s'\n",\n<405> ret = net_socket_listen_init(vlan, device, name, buf);\n<407> } else if (get_param_value(buf, sizeof(buf), "connect", p) > 0) {\n<415> if (check_params(connect_params, p) < 0) {\n<417> fprintf(stderr, "qemu: invalid parameter '%s' in '%s'\n",\n<425> ret = net_socket_connect_init(vlan, device, name, buf);\n<427> } else if (get_param_value(buf, sizeof(buf), "mcast", p) > 0) {\n<435> if (check_params(mcast_params, p) < 0) {\n<437> fprintf(stderr, "qemu: invalid parameter '%s' in '%s'\n",\n<445> ret = net_socket_mcast_init(vlan, device, name, buf);\n<449> fprintf(stderr, "Unknown socket options: %s\n", p);\n<527> if (!strcmp(device, "dump")) {\n<529> int len = 65536;\n<533> if (get_param_value(buf, sizeof(buf), "len", p) > 0) {\n<539> if (!get_param_value(buf, sizeof(buf), "file", p)) {\n<545> ret = net_dump_init(vlan, device, name, buf, len);\n<549> fprintf(stderr, "Unknown network device: %s\n", device);\n<551> ret = -1;\n<557> if (ret < 0) {\n<559> fprintf(stderr, "Could not initialize device '%s'\n", device);\n<565> if (name)\n<567> free(name);\n<569> return ret;
<1> static int ehci_state_fetchsitd(EHCIState *ehci, int async)\n<25> if (!(sitd.results & SITD_RESULTS_ACTIVE)) {\n<33> fprintf(stderr, "WARNING: Skipping active siTD\n");
<1> static int open_self_cmdline(void *cpu_env, int fd)\n<51> if (!word_skipped) {\n<57> cp_buf = memchr(buf, 0, sizeof(buf));\n<63> cp_buf++;\n<65> nb_read -= cp_buf - buf;\n<77> if (write(fd, cp_buf, nb_read) != nb_read) {
<1> void vp9_print_modes_and_motion_vectors ( VP9_COMMON * cm , const char * file ) {\n<15> log_frame_info ( cm , "Vectors " , mvs ) ;\n<17> mi_row < rows ;\n<19> fprintf ( mvs , "V " ) ;\n<21> mi_col < cols ;\n<23> fprintf ( mvs , "%4d:%4d " , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . col ) ;\n<26> fprintf ( mvs , "\n" ) ;\n<29> fprintf ( mvs , "\n" ) ;\n<30> fclose ( mvs ) ;
<1> int av_opt_is_set_to_default(void *obj, const AVOption *o)\n<27> dst = ((uint8_t*)obj) + o->offset;\n<31> switch (o->type) {\n<59> if (str == o->default_val.str) //2 NULLs\n<63> if (!str || !o->default_val.str) //1 NULL\n<67> return !strcmp(str, o->default_val.str);\n<99> } tmp = {0};\n<101> int opt_size = *(int *)((void **)dst + 1);\n<105> if (!opt_ptr && (!o->default_val.str || !strlen(o->default_val.str)))\n<107> return 1;\n<109> if (opt_ptr && o->default_val.str && !strlen(o->default_val.str))\n<111> return 0;\n<113> if (opt_size != strlen(o->default_val.str) / 2)\n<115> return 0;\n<117> ret = set_string_binary(NULL, NULL, o->default_val.str, &tmp.data);\n<119> if (!ret)\n<121> ret = !memcmp(opt_ptr, tmp.data, tmp.size);\n<123> av_free(tmp.data);\n<125> return ret;\n<137> if (!o->default_val.str || !strcmp(o->default_val.str, "none"))\n<139> w = h = 0;\n<141> else if ((ret = av_parse_video_size(&w, &h, o->default_val.str)) < 0)\n<145> return (w == *(int *)dst) && (h == *((int *)dst+1));\n<165> return !memcmp(color, dst, sizeof(color));
<1> static my_bool get_view_structure ( char * table , char * db ) {\n<23> field = mysql_fetch_field_direct ( table_res , 0 ) ;\n<24> if ( strcmp ( field -> name , "View" ) != 0 ) {\n<25> mysql_free_result ( table_res ) ;\n<26> switch_character_set_results ( mysql , default_charset ) ;\n<27> verbose_msg ( "-- It's base table, skipped\n" ) ;\n<28> DBUG_RETURN ( 0 ) ;\n<46> if ( mysql_query ( mysql , query ) ) {\n<59> row = mysql_fetch_row ( table_res ) ;\n<63> if ( ! ( table_res = mysql_store_result ( mysql ) ) || ! ( row = mysql_fetch_row ( table_res ) ) ) {\n<70> if ( strcmp ( row [ 0 ] , "NONE" ) ) {\n<71> ptr = search_buf ;\n<72> search_len = ( ulong ) ( strxmov ( ptr , "WITH " , row [ 0 ] , " CHECK OPTION" , NullS ) - ptr ) ;\n<73> ptr = replace_buf ;\n<74> replace_len = ( ulong ) ( strxmov ( ptr , "*/\n/*!50002 WITH " , row [ 0 ] , " CHECK OPTION" , NullS ) - ptr ) ;\n<75> replace ( & ds_view , search_buf , search_len , replace_buf , replace_len ) ;
<1> static int qcow2_create(const char *filename, QEMUOptionParameter *options)\n<21> while (options && options->name) {\n<23> if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n<25> sectors = options->value.n / 512;\n<27> } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FILE)) {\n<29> backing_file = options->value.s;\n<31> } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FMT)) {\n<33> backing_fmt = options->value.s;\n<35> } else if (!strcmp(options->name, BLOCK_OPT_ENCRYPT)) {\n<37> flags |= options->value.n ? BLOCK_FLAG_ENCRYPT : 0;\n<39> } else if (!strcmp(options->name, BLOCK_OPT_CLUSTER_SIZE)) {\n<41> if (options->value.n) {\n<47> } else if (!strcmp(options->name, BLOCK_OPT_PREALLOC)) {\n<49> if (!options->value.s || !strcmp(options->value.s, "off")) {\n<51> prealloc = 0;\n<53> } else if (!strcmp(options->value.s, "metadata")) {\n<55> prealloc = 1;\n<59> fprintf(stderr, "Invalid preallocation mode: '%s'\n",\n<61> options->value.s);\n<63> return -EINVAL;\n<69> options++;\n<75> if (backing_file && prealloc) {\n<77> fprintf(stderr, "Backing file and preallocation cannot be used at "
<1> static void opt_frame_pad_left(const char *arg)\n<7> if (frame_padleft < 0) {\n<9> fprintf(stderr, "Incorrect left pad size\n");
<1> hb_shape_plan_t * hb_shape_plan_create ( hb_face_t * face , const hb_segment_properties_t * props , const hb_feature_t * user_features , unsigned int num_user_features , const char * const * shaper_list ) {\n<4> hb_feature_t * features = NULL ;\n<6> if ( unlikely ( ! props || hb_object_is_inert ( face ) ) ) return hb_shape_plan_get_empty ( ) ;\n<7> if ( num_user_features && ! ( features = ( hb_feature_t * ) malloc ( num_user_features * sizeof ( hb_feature_t ) ) ) ) return hb_shape_plan_get_empty ( ) ;\n<8> if ( ! ( shape_plan = hb_object_create < hb_shape_plan_t > ( ) ) ) {\n<9> free ( features ) ;\n<18> shape_plan -> user_features = features ;\n<19> if ( num_user_features ) memcpy ( features , user_features , num_user_features * sizeof ( hb_feature_t ) ) ;\n<20> hb_shape_plan_plan ( shape_plan , user_features , num_user_features , shaper_list ) ;
<1> static void tftp_handle_rrq(Slirp *slirp, struct tftp_t *tp, int pktlen)\n<27> s = tftp_session_allocate(slirp, tp);\n<39> spt = &slirp->tftp_sessions[s];\n<45> if (!slirp->tftp_prefix) {\n<65> prefix_len = strlen(slirp->tftp_prefix);\n<67> spt->filename = qemu_malloc(prefix_len + TFTP_FILENAME_MAX + 2);\n<69> memcpy(spt->filename, slirp->tftp_prefix, prefix_len);\n<77> req_fname = spt->filename + prefix_len + 1;\n<85> tftp_send_error(spt, 2, "Access violation", tp);\n<91> req_fname[k] = (char)tp->x.tp_buf[k];\n<93> if (req_fname[k++] == '\0') {\n<105> if ((pktlen - k) < 6) {\n<107> tftp_send_error(spt, 2, "Access violation", tp);\n<115> if (memcmp(&tp->x.tp_buf[k], "octet\0", 6) != 0) {\n<117> tftp_send_error(spt, 4, "Unsupported transfer mode", tp);\n<119> return;\n<125> k += 6; /* skipping octet */\n<131> if (!strncmp(req_fname, "../", 3) ||\n<133> req_fname[strlen(req_fname) - 1] == '/' ||\n<135> strstr(req_fname, "/../")) {\n<137> tftp_send_error(spt, 2, "Access violation", tp);\n<147> if (tftp_read_data(spt, 0, NULL, 0) < 0) {\n<149> tftp_send_error(spt, 1, "File not found", tp);\n<159> tftp_send_error(spt, 2, "Access violation", tp);\n<167> while (k < pktlen) {\n<173> key = (const char *)&tp->x.tp_buf[k];\n<175> k += strlen(key) + 1;\n<179> if (k >= pktlen) {\n<181> tftp_send_error(spt, 2, "Access violation", tp);\n<189> value = (const char *)&tp->x.tp_buf[k];\n<191> k += strlen(value) + 1;\n<195> if (strcmp(key, "tsize") == 0) {\n<197> int tsize = atoi(value);\n<203> if (tsize == 0) {\n<205> if (stat(spt->filename, &stat_p) == 0)\n<221> tftp_send_oack(spt, "tsize", tsize, tp);\n<231> tftp_send_data(spt, 1, tp);
<1> static void omap_clkm_write(void *opaque, hwaddr addr,\n<125> if ((s->clkm.clocking_scheme ^ (value >> 11)) & 7) {\n<129> printf("%s: clocking scheme set to %s\n", __FUNCTION__,
<1> static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n<2> free ( g ) ;
<1> static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n<5> if ( ! tmp || ! * tmp ) {\n<10> if ( strstr ( tmp , "\\" ) ) {\n<11> put_info ( "DELIMITER cannot contain a backslash character" , INFO_ERROR ) ;\n<12> return 0 ;\n<15> strmake_buf ( delimiter , tmp ) ;\n<16> delimiter_length = ( int ) strlen ( delimiter ) ;\n<17> delimiter_str = delimiter ;\n<18> return 0 ;
<1> void min_heap_dtor ( min_heap_t * s ) {\n<2> free ( s -> p ) ;
<1> qemu_irq *armv7m_init(int flash_size, int sram_size,\n<41> if (!env) {\n<43> fprintf(stderr, "Unable to find CPU definition\n");\n<107> image_size = load_elf(kernel_filename, 0, &entry, &lowaddr, NULL);\n<111> image_size = load_image_targphys(kernel_filename, 0, flash_size);\n<117> if (image_size < 0) {\n<119> fprintf(stderr, "qemu: could not load kernel '%s'\n",
<1> static int nbd_send_negotiate(NBDClient *client)\n<63> memset(buf, 0, sizeof(buf));\n<65> memcpy(buf, "NBDMAGIC", 8);\n<71> cpu_to_be64w((uint64_t*)(buf + 8), NBD_CLIENT_MAGIC);\n<73> cpu_to_be64w((uint64_t*)(buf + 16), client->exp->size);\n<75> cpu_to_be16w((uint16_t*)(buf + 26), client->exp->nbdflags | myflags);\n<79> cpu_to_be64w((uint64_t*)(buf + 8), NBD_OPTS_MAGIC);\n<81> cpu_to_be16w((uint16_t *)(buf + 16), NBD_FLAG_FIXED_NEWSTYLE);\n<99> if (write_sync(csock, buf, 18) != 18) {
<1> static int mjpeg_probe(AVProbeData *p)\n<19> if (p->buf[i] != 0xFF)\n<109> for (i=0; i<FFMIN(p->buf_size - sizeof(ct_jpeg), 100); i++)\n<111> if (!memcmp(p->buf + i, ct_jpeg, sizeof(ct_jpeg) - 1))\n<113> return AVPROBE_SCORE_EXTENSION;
<1> void virtio_blk_data_plane_start(VirtIOBlockDataPlane *s)\n<51> if (r != 0) {\n<53> fprintf(stderr, "virtio-blk failed to set guest notifier (%d), "\n<69> if (r != 0) {\n<71> fprintf(stderr, "virtio-blk failed to set host notifier (%d)\n", r);
<1> static inline void powerpc_excp(CPUState *env, int excp_model, int excp)\n<113> if (qemu_log_enabled()) {\n<121> fprintf(stderr, "Machine check while not allowed. "
<1> static void test_qemu_strtoul_underflow(void)\n<9> const char *endptr = &f;\n<17> err  = qemu_strtoul(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) {\n<8> if ( options == NULL ) return VPX_CODEC_OK ;\n<9> input_string = strdup ( options ) ;\n<10> option_name = strtok_r ( input_string , "=" , & input_ptr ) ;\n<11> while ( option_name != NULL ) {\n<13> if ( option_value == NULL ) {\n<18> if ( strcmp ( "spatial-layers" , option_name ) == 0 ) {\n<19> svc_ctx -> spatial_layers = atoi ( option_value ) ;\n<21> else if ( strcmp ( "temporal-layers" , option_name ) == 0 ) {\n<22> svc_ctx -> temporal_layers = atoi ( option_value ) ;\n<24> else if ( strcmp ( "scale-factors" , option_name ) == 0 ) {\n<25> res = parse_scale_factors ( svc_ctx , option_value ) ;\n<26> if ( res != VPX_CODEC_OK ) break ;\n<28> else if ( strcmp ( "quantizers" , option_name ) == 0 ) {\n<29> res = parse_quantizer_values ( svc_ctx , option_value ) ;\n<30> if ( res != VPX_CODEC_OK ) break ;\n<32> else if ( strcmp ( "auto-alt-refs" , option_name ) == 0 ) {\n<33> res = parse_auto_alt_ref ( svc_ctx , option_value ) ;\n<34> if ( res != VPX_CODEC_OK ) break ;\n<36> else if ( strcmp ( "multi-frame-contexts" , option_name ) == 0 ) {\n<37> si -> use_multiple_frame_contexts = atoi ( option_value ) ;\n<40> svc_log ( svc_ctx , SVC_LOG_ERROR , "invalid option: %s\n" , option_name ) ;\n<41> res = VPX_CODEC_INVALID_PARAM ;\n<44> option_name = strtok_r ( NULL , "=" , & input_ptr ) ;\n<46> free ( input_string ) ;
<1> static int decode_pic(AVSContext *h) {\n<169> } while(ff_cavs_next_mb(h));\n<185> if(!ff_cavs_next_mb(h))\n<207> } while(ff_cavs_next_mb(h));\n<223> if(!ff_cavs_next_mb(h))\n<245> } while(ff_cavs_next_mb(h));\n<251> if(h->pic_type != FF_B_TYPE) {\n<261> memset(&h->picture,0,sizeof(Picture));
<1> static void kvm_mce_inj_srar_dataload(CPUState *env, target_phys_addr_t paddr)\n<29> if (r < 0) {\n<31> fprintf(stderr, "kvm_set_mce: %s\n", strerror(errno));
<1> static int dvbsub_parse_clut_segment(AVCodecContext *avctx,\n<65> if (!clut)\n<71> memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n<83> ctx->clut_list = clut;\n<89> if (clut->version != version) {
<1> static int inc_refcounts(BlockDriverState *bs,\n<59> if (refcount == s->refcount_max) {\n<65> fprintf(stderr, "Use qemu-img amend to increase the refcount entry "
<1> static int copy_to_pbr(DCAXllDecoder *s, uint8_t *data, int size, int delay)\n<5> if (size > DCA_XLL_PBR_BUFFER_MAX)\n<11> if (!s->pbr_buffer && !(s->pbr_buffer = av_malloc(DCA_XLL_PBR_BUFFER_MAX + DCA_BUFFER_PADDING_SIZE)))\n<17> memcpy(s->pbr_buffer, data, size);\n<19> s->pbr_length = size;
<1> static int mpeg_decode_mb(MpegEncContext *s,\n<181> s->qscale = get_qscale(s);\n<185> if (s->concealment_motion_vectors) {\n<209> memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */\n<237> if (mpeg2_decode_block_intra(s, s->pblocks[i], i) < 0)\n<247> if (mpeg1_decode_block_intra(s, s->pblocks[i], i) < 0)
<1> static int ppce500_load_device_tree(CPUPPCState *env,\n<29> const char *toplevel_compat = NULL; /* user override */\n<83> toplevel_compat = qemu_opt_get(machine_opts, "dt_compatible");\n<153> if (ret < 0) {\n<155> fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");\n<165> if (ret < 0) {\n<167> fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");\n<179> if (ret < 0)\n<181> fprintf(stderr, "couldn't set /chosen/bootargs\n");\n<485> if (toplevel_compat) {\n<487> qemu_devtree_setprop(fdt, "/", "compatible", toplevel_compat,\n<489> strlen(toplevel_compat) + 1);
<1> static int decode_frame(AVCodecContext *avctx,\n<99> if(avctx->debug&FF_DEBUG_QP){\n<101> int8_t *qtab= pict->qscale_table;\n<107> for(y=0; y<s->mb_height; y++){\n<109> for(x=0; x<s->mb_width; x++){\n<111> printf("%2d ", qtab[x + y*s->mb_width]);\n<115> printf("\n");\n<119> printf("\n");
<1> void kvm_mips_reset_vcpu(MIPSCPU *cpu)\n<9> if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n<11> fprintf(stderr, "Warning: FPU not supported with KVM, disabling\n");
<1> static void usbredir_interrupt_packet(void *priv, uint32_t id,\n<5> uint8_t *data, int data_len)\n<21> if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n<25> free(data);\n<35> if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n<39> free(data);
<1> static void smbios_validate_table(void)\n<5> if (smbios_type4_count && smbios_type4_count != smp_cpus) {
<1> opts_start_struct(Visitor *v, void **obj, const char *kind,\n<15> if (ov->depth++ > 0) {\n<27> QTAILQ_FOREACH(opt, &ov->opts_root->head, next) {\n<31> assert(strcmp(opt->name, "id") != 0);\n<35> opts_visitor_insert(ov->unprocessed_opts, opt);
<1> long check_dcbzl_effect(void)\n<17> if (!fakedata)\n<31> memset(fakedata, 0xFF, 1024);\n<47> if (fakedata[i] == (char)0)\n<55> av_free(fakedata);
<1> static int open_f(BlockBackend *blk, int argc, char **argv)\n<81> if (imageOpts) {\n<83> printf("--image-opts and 'open -o' are mutually exclusive\n");
<1> static void opt_frame_pad_bottom(const char *arg)\n<7> if (frame_padbottom < 0) {\n<9> fprintf(stderr, "Incorrect bottom pad size\n");
<1> static bool ufd_version_check(int ufd)\n<15> if (ioctl(ufd, UFFDIO_API, &api_struct)) {\n<17> error_report("postcopy_ram_supported_by_host: UFFDIO_API failed: %s",\n<19> strerror(errno));
<1> static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, int frame_off)\n<77> if (src < source || src >= source_end)\n<99> if (src < source || src >= source_end)\n<107> if (*src & 0xC)\n<125> NEXT_BYTE(src);\n<155> NEXT_BYTE(src);\n<169> if (FFABS(dst_end - dst) < len)\n<179> if (dst - frame + SCREEN_WIDE < frame_off ||\n<181> frame_end - dst < frame_off + len)\n<187> dst[i] = dst[frame_off + i];\n<195> if (dst - frame + SCREEN_WIDE < frame_off ||\n<197> frame_end - dst < frame_off + len)\n<203> dst[i] = dst[frame_off + i];\n<213> if (source + src_len - src < len)\n<217> memcpy(dst, src, len);\n<219> dst += len;\n<221> src += len;\n<225> if (src - source < len)\n<229> dst -= len;\n<231> src -= len;\n<233> memcpy(dst, src, len);\n<241> val = forward ? dst[-1] : dst[1];\n<243> if (forward) {\n<245> memset(dst, val, len);\n<247> dst += len;\n<251> dst -= len;\n<253> memset(dst, val, len);\n<265> if (dst == dst_end)
<1> static int qemu_gluster_create(const char *filename,\n<57> if (!glfs) {\n<75> if (!tmp || !strcmp(tmp, "off")) {\n<77> prealloc = 0;\n<79> } else if (!strcmp(tmp, "full") && gluster_supports_zerofill()) {\n<81> prealloc = 1;\n<85> error_setg(errp, "Invalid preallocation mode: '%s'"\n<89> ret = -EINVAL;\n<97> fd = glfs_creat(glfs, gconf->path,\n<99> O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR | S_IWUSR);\n<101> if (!fd) {\n<133> g_free(tmp);
<1> static void ppc_prep_init(MachineState *machine)\n<73> if (cpu == NULL) {\n<75> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<185> if (ppc_boot_device == '\0') {\n<187> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<225> if (pci_bus == NULL) {\n<227> fprintf(stderr, "Couldn't create PCI host controller.\n");\n<287> for(i = 0; i < nb_nics1; i++) {\n<289> if (nd_table[i].model == NULL) {\n<291> nd_table[i].model = g_strdup("ne2k_isa");\n<295> if (strcmp(nd_table[i].model, "ne2k_isa") == 0) {\n<297> isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],\n<299> &nd_table[i]);\n<303> pci_nic_init_nofail(&nd_table[i], pci_bus, "ne2k_pci", NULL);
<1> void configure_icount(QemuOpts *opts, Error **errp)\n<13> if (!option) {\n<49> if (strcmp(option, "auto") != 0) {\n<51> errno = 0;\n<53> icount_time_shift = strtol(option, &rem_str, 0);\n<55> if (errno != 0 || *rem_str != '\0' || !strlen(option)) {\n<57> error_setg(errp, "icount: Invalid shift value");\n<61> use_icount = 1;\n<63> return;\n<65> } else if (icount_align_option) {\n<77> use_icount = 2;\n<85> icount_time_shift = 3;\n<99> icount_rt_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL_RT,\n<105> qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL_RT) + 1000);\n<107> icount_vm_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n<113> qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n<115> get_ticks_per_sec() / 10);
<1> static inline void mix_3f_1r_to_dolby(AC3DecodeContext *ctx)\n<13> output[1][i] += (output[2][i] - output[4][i]);\n<19> memset(output[3], 0, sizeof(output[3]));\n<21> memset(output[4], 0, sizeof(output[4]));
<1> static int slirp_smb ( SlirpState * s , const char * exported_dir , struct in_addr vserver_addr ) {\n<8> if ( ! passwd ) {\n<16> if ( access ( exported_dir , R_OK | X_OK ) ) {\n<17> error_report ( "error accessing shared directory '%s': %s" , exported_dir , strerror ( errno ) ) ;\n<25> snprintf ( smb_conf , sizeof ( smb_conf ) , "%s/%s" , s -> smb_dir , "smb.conf" ) ;\n<27> if ( ! f ) {\n<32> fprintf ( f , "[global]\n" "private dir=%s\n" "interfaces=127.0.0.1\n" "bind interfaces only=yes\n" "pid directory=%s\n" "lock directory=%s\n" "state directory=%s\n" "cache directory=%s\n" "ncalrpc dir=%scalrpc\n" "log file=%s/log.smbd\n" "smb passwd file=%s/smbpasswd\n" "security = user\n" "map to guest = Bad User\n" "load printers = no\n" "printing = bsd\n" "disable spoolss = yes\n" "usershare max shares = 0\n" "[qemu]\n" "path=%s\n" "read only=no\n" "guest ok=yes\n" "force user=%s\n" , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , exported_dir , passwd -> pw_name ) ;\n<33> fclose ( f ) ;\n<34> snprintf ( smb_cmdline , sizeof ( smb_cmdline ) , "%s -l %s -s %s" , CONFIG_SMBD_COMMAND , s -> smb_dir , smb_conf ) ;
<1> static void flush_dpb(AVCodecContext *avctx)\n<5> H264Context *h = avctx->priv_data;\n<11> memset(h->delayed_pic, 0, sizeof(h->delayed_pic));\n<15> ff_h264_flush_change(h);\n<23> ff_h264_unref_picture(h, &h->DPB[i]);\n<27> ff_h264_unref_picture(h, &h->cur_pic);\n<35> ff_h264_free_tables(h);
<1> static void opt_frame_pad_right(const char *arg)\n<7> if (frame_padright < 0) {\n<9> fprintf(stderr, "Incorrect right pad size\n");
<1> static int kvm_put_fpu(CPUState *env)\n<11> memset(&fpu, 0, sizeof fpu);\n<23> memcpy(fpu.fpr, env->fpregs, sizeof env->fpregs);\n<25> memcpy(fpu.xmm, env->xmm_regs, sizeof env->xmm_regs);\n<31> return kvm_vcpu_ioctl(env, KVM_SET_FPU, &fpu);
<1> void ptimer_run(ptimer_state *s, int oneshot)\n<9> if (was_disabled && s->period == 0) {\n<11> fprintf(stderr, "Timer with period zero, disabling\n");
<1> static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n<25> if (mem == NULL) {\n<35> if (!d.dirty_bitmap) {\n<37> d.dirty_bitmap = qemu_malloc(size);\n<39> } else if (size > allocated_size) {\n<41> d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n<45> allocated_size = size;\n<47> memset(d.dirty_bitmap, 0, allocated_size);\n<51> d.slot = mem->slot;\n<55> if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n<67> kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n<75> qemu_free(d.dirty_bitmap);
<1> int qemu_v9fs_synth_mkdir(V9fsSynthNode *parent, int mode,\n<13> if (!v9fs_synth_fs) {\n<19> if (!name || (strlen(name) >= NAME_MAX)) {\n<21> return EINVAL;\n<25> if (!parent) {\n<31> qemu_mutex_lock(&v9fs_synth_mutex);\n<33> QLIST_FOREACH(tmp, &parent->child, sibling) {\n<35> if (!strcmp(tmp->name, name)) {\n<37> ret = EEXIST;\n<47> node = v9fs_add_dir_node(parent, mode, name, NULL, v9fs_synth_node_count++);\n<49> v9fs_add_dir_node(node, parent->attr->mode, "..",\n<51> parent->attr, parent->attr->inode);\n<53> v9fs_add_dir_node(node, node->attr->mode, ".",\n<55> node->attr, node->attr->inode);\n<57> *result = node;\n<59> ret = 0;\n<63> qemu_mutex_unlock(&v9fs_synth_mutex);\n<65> return ret;
<1> static int read_password(char *buf, int buf_size)\n<11> printf("password: ");\n<63> printf("\n");
<1> const ppc_def_t *kvmppc_host_cpu_def(void)\n<17> base_spec = ppc_find_by_pvr(host_pvr);\n<21> spec = g_malloc0(sizeof(*spec));\n<23> memcpy(spec, base_spec, sizeof(*spec));\n<31> alter_insns(&spec->insns_flags, PPC_ALTIVEC, vmx > 0);\n<33> alter_insns(&spec->insns_flags2, PPC2_VSX, vmx > 1);\n<35> alter_insns(&spec->insns_flags2, PPC2_DFP, dfp);\n<39> return spec;
<1> int get_buffer(ByteIOContext *s, unsigned char *buf, int size)\n<13> len = s->buf_end - s->buf_ptr;\n<19> if (len == 0) {\n<21> fill_buffer(s);\n<31> memcpy(buf, s->buf_ptr, len);\n<33> buf += len;\n<35> s->buf_ptr += len;\n<37> size -= len;
<1> static int xps_parse_gradient_stops ( xps_document * doc , char * base_uri , fz_xml * node , struct stop * stops , int maxcount ) {\n<10> while ( node && count < maxcount ) {\n<11> if ( ! strcmp ( fz_xml_tag ( node ) , "GradientStop" ) ) {\n<12> char * offset = fz_xml_att ( node , "Offset" ) ;\n<13> char * color = fz_xml_att ( node , "Color" ) ;\n<14> if ( offset && color ) {\n<43> qsort ( stops , count , sizeof ( struct stop ) , cmp_stop ) ;\n<55> if ( before > 0 ) {\n<56> memmove ( stops , stops + before , ( count - before ) * sizeof ( struct stop ) ) ;\n<61> stops [ 1 ] = stops [ 0 ] ;\n<82> if ( stops [ 0 ] . offset > 0 ) {\n<83> memmove ( stops + 1 , stops , count * sizeof ( struct stop ) ) ;\n<84> stops [ 0 ] = stops [ 1 ] ;\n<89> stops [ count ] = stops [ count - 1 ] ;
<1> static void float_number(void)\n<39> obj = qobject_from_json(test_cases[i].encoded);\n<53> if (test_cases[i].skip == 0) {\n<61> g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
<1> static void img_snapshot(int argc, char **argv)\n<133> switch(action) {\n<145> memset(&sn, 0, sizeof(sn));\n<159> ret = bdrv_snapshot_create(bs, &sn);\n<161> if (ret)\n<163> error("Could not create snapshot '%s': %d (%s)",\n<165> snapshot_name, ret, strerror(-ret));\n<175> if (ret)\n<177> error("Could not apply snapshot '%s': %d (%s)",\n<179> snapshot_name, ret, strerror(-ret));\n<189> if (ret)\n<191> error("Could not delete snapshot '%s': %d (%s)",\n<193> snapshot_name, ret, strerror(-ret));
<1> void monitor_vprintf(Monitor *mon, const char *fmt, va_list ap)\n<11> if (mon->mc && !mon->mc->print_enabled) {\n<19> vsnprintf(buf, sizeof(buf), fmt, ap);\n<21> monitor_puts(mon, buf);
<1> static int megasas_ld_get_info_submit(SCSIDevice *sdev, int lun,\n<3> MegasasCmd *cmd)\n<25> if (!cmd->iov_buf) {\n<27> cmd->iov_buf = g_malloc(dcmd_size);\n<29> memset(cmd->iov_buf, 0x0, dcmd_size);\n<31> info = cmd->iov_buf;\n<35> req = scsi_req_new(sdev, cmd->index, lun, cdb, cmd);\n<43> g_free(cmd->iov_buf);\n<87> memset(info->ld_config.span, 0, sizeof(info->ld_config.span));
<1> static int alloc_buffer(InputStream *ist, FrameBuffer **pbuf)\n<39> if ((ret = av_image_alloc(buf->base, buf->linesize, w, h,\n<59> memset(buf->base[0], 128, ret);
<1> int rom_add_file(const char *file, const char *fw_dir, const char *fw_file,\n<13> rom = qemu_mallocz(sizeof(*rom));\n<17> rom->path = qemu_find_file(QEMU_FILE_TYPE_BIOS, rom->name);\n<27> fd = open(rom->path, O_RDONLY | O_BINARY);\n<29> if (fd == -1) {\n<31> fprintf(stderr, "Could not open option rom '%s': %s\n",\n<33> rom->path, strerror(errno));\n<55> if (rc != rom->romsize) {\n<57> fprintf(stderr, "rom: file %-20s: read error: rc=%d (expected %zd)\n",\n<81> qemu_free(rom->path);\n<83> qemu_free(rom->name);\n<85> qemu_free(rom);
<1> CPUX86State *cpu_x86_init(void)\n<17> env = malloc(sizeof(CPUX86State));\n<19> if (!env)\n<23> memset(env, 0, sizeof(CPUX86State));\n<49> return env;
<1> static void bt_hci_inquiry_result(struct bt_hci_s *hci,\n<19> switch (hci->lm.inquiry_mode) {\n<35> fprintf(stderr, "%s: bad inquiry mode %02x\n", __FUNCTION__,
<1> static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out)\n<27> if (ret < 0) {\n<29> fprintf(stderr, "ibv_poll_cq return %d!\n", ret);\n<31> return ret;\n<41> if (wc.status != IBV_WC_SUCCESS) {\n<43> fprintf(stderr, "ibv_poll_cq wc.status=%d %s!\n",\n<45> wc.status, ibv_wc_status_str(wc.status));\n<47> fprintf(stderr, "ibv_poll_cq wrid=%s!\n", wrid_desc[wr_id]);
<1> static void s390_init(QEMUMachineInitArgs *args)\n<11> const char *kernel_cmdline = args->kernel_cmdline;\n<81> virtio_region_len = my_ram_size - ram_size;\n<85> virtio_region = cpu_physical_memory_map(virtio_region_start,\n<89> memset(virtio_region, 0, virtio_region_len);\n<91> cpu_physical_memory_unmap(virtio_region, virtio_region_len, 1,\n<157> kernel_size = load_elf(kernel_filename, NULL, NULL, NULL, NULL,\n<163> kernel_size = load_image_targphys(kernel_filename, 0, ram_size);\n<167> if (kernel_size == -1UL) {\n<169> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<251> initrd_size = load_image_targphys(initrd_filename, initrd_offset,\n<255> if (initrd_size == -1UL) {\n<257> fprintf(stderr, "qemu: could not load initrd '%s'\n",\n<277> if (rom_ptr(KERN_PARM_AREA)) {\n<281> memcpy(rom_ptr(KERN_PARM_AREA), kernel_cmdline,\n<283> strlen(kernel_cmdline) + 1);\n<291> for(i = 0; i < nb_nics; i++) {\n<293> NICInfo *nd = &nd_table[i];\n<299> if (!nd->model) {\n<301> nd->model = g_strdup("virtio");\n<307> if (strcmp(nd->model, "virtio")) {\n<309> fprintf(stderr, "S390 only supports VirtIO nics\n");\n<311> exit(1);\n<319> qdev_set_nic_properties(dev, nd);
<1> ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n<47> xops = get_xattr_operations(ctx->xops, orig_value);\n<49> if (!xops) {\n<57> if (!value) {\n<59> size += xops->listxattr(ctx, path, orig_value, value, vsize);\n<63> size = xops->listxattr(ctx, path, orig_value, value, vsize);\n<65> if (size < 0) {\n<81> attr_len = strlen(orig_value) + 1;\n<83> parsed_len += attr_len;\n<85> orig_value += attr_len;
<1> static void do_video_out(AVFormatContext *s,\n<3> AVOutputStream *ost,\n<131> if (verbose >= 0)\n<133> fprintf(stderr, "pixel format conversion not handled\n");\n<207> if (verbose >= 0)\n<209> fprintf(stderr, "pixel format conversion not handled\n");\n<269> optr = final_picture->data[i] + (((final_picture->linesize[i] *\n<273> iptr = formatted_picture->data[i];\n<279> for (y = 0; y < yheight; y++) {\n<283> memcpy(optr, iptr, formatted_picture->linesize[i]);\n<285> optr += final_picture->linesize[i];\n<287> iptr += formatted_picture->linesize[i];\n<335> if (verbose >= 0)\n<337> fprintf(stderr, "pixel format conversion not handled\n");\n<477> if (ost->logfile && enc->stats_out) {\n<479> fprintf(ost->logfile, "%s", enc->stats_out);
<1> static int url_alloc_for_protocol(URLContext **puc, struct URLProtocol *up,\n<3> const char *filename, int flags,\n<23> uc = av_mallocz(sizeof(URLContext) + strlen(filename) + 1);\n<25> if (!uc) {\n<37> strcpy(uc->filename, filename);
<1> void ff_xvmc_decode_mb(MpegEncContext *s)\n<265> for (i = 4; i < blocks_per_mb; i++) {\n<267> memset(s->pblocks[i], 0, sizeof(*s->pblocks[i]));  // so we need to clear them\n<319> if (s->avctx->xvmc_acceleration == 1) {\n<321> memcpy(&render->data_blocks[render->next_free_data_block_num*64],
<1> envlist_create(void)\n<9> if ((envlist = malloc(sizeof (*envlist))) == NULL)\n<11> return (NULL);\n<15> LIST_INIT(&envlist->el_entries);\n<17> envlist->el_count = 0;\n<21> return (envlist);
<1> static void bamboo_init(ram_addr_t ram_size,\n<71> kernel_size = load_uimage(kernel_filename, &entry, &loadaddr, NULL);\n<75> kernel_size = load_elf(kernel_filename, 0, &elf_entry, &elf_lowaddr,\n<87> if (kernel_size < 0) {\n<89> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<107> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<113> if (initrd_size < 0) {\n<115> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<145> if (fdt == NULL) {\n<147> fprintf(stderr, "couldn't load device tree\n");
<1> static void x86_cpu_parse_featurestr(const char *typename, char *features,\n<25> if (!features) {\n<33> for (featurestr = strtok(features, ",");\n<35> featurestr;\n<37> featurestr = strtok(NULL, ",")) {\n<41> const char *val = NULL;\n<43> char *eq = NULL;\n<45> char num[32];\n<53> if (featurestr[0] == '+') {\n<57> g_strdup(featurestr + 1));\n<61> } else if (featurestr[0] == '-') {\n<65> g_strdup(featurestr + 1));\n<73> eq = strchr(featurestr, '=');\n<77> *eq++ = 0;\n<89> feat2prop(featurestr);\n<107> if (g_list_find_custom(minus_features, name, compare_string)) {\n<109> error_report("warning: Ambiguous CPU model string. "\n<123> if (!strcmp(name, "tsc-freq")) {\n<129> tsc_freq = qemu_strtosz_metric(val, NULL);\n<131> if (tsc_freq < 0) {\n<151> prop->driver = typename;\n<153> prop->property = g_strdup(name);\n<155> prop->value = g_strdup(val);\n<157> prop->errp = &error_fatal;\n<159> qdev_prop_register_global(prop);\n<165> if (ambiguous) {
<1> static int openfile(char *name, int flags, int growable, QDict *opts)\n<9> if (qemuio_bs) {\n<11> fprintf(stderr, "file open already, try 'help close'\n");\n<21> if (bdrv_open(&qemuio_bs, name, NULL, opts, flags | BDRV_O_PROTOCOL,\n<27> fprintf(stderr, "%s: can't open device %s: %s\n", progname, name,\n<29> error_get_pretty(local_err));\n<43> if (bdrv_open(&qemuio_bs, name, NULL, opts, flags, NULL, &local_err)\n<49> fprintf(stderr, "%s: can't open device %s: %s\n", progname, name,\n<51> error_get_pretty(local_err));
<1> static int qcow2_amend_options(BlockDriverState *bs, QemuOpts *opts,\n<29> while (desc && desc->name) {\n<31> if (!qemu_opt_find(opts, desc->name)) {\n<43> if (!strcmp(desc->name, BLOCK_OPT_COMPAT_LEVEL)) {\n<45> compat = qemu_opt_get(opts, BLOCK_OPT_COMPAT_LEVEL);\n<47> if (!compat) {\n<51> } else if (!strcmp(compat, "0.10")) {\n<53> new_version = 2;\n<55> } else if (!strcmp(compat, "1.1")) {\n<57> new_version = 3;\n<61> fprintf(stderr, "Unknown compatibility level %s.\n", compat);\n<63> return -EINVAL;\n<67> } else if (!strcmp(desc->name, BLOCK_OPT_PREALLOC)) {\n<69> fprintf(stderr, "Cannot change preallocation mode.\n");\n<71> return -ENOTSUP;\n<73> } else if (!strcmp(desc->name, BLOCK_OPT_SIZE)) {\n<75> new_size = qemu_opt_get_size(opts, BLOCK_OPT_SIZE, 0);\n<77> } else if (!strcmp(desc->name, BLOCK_OPT_BACKING_FILE)) {\n<79> backing_file = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);\n<81> } else if (!strcmp(desc->name, BLOCK_OPT_BACKING_FMT)) {\n<83> backing_format = qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT);\n<85> } else if (!strcmp(desc->name, BLOCK_OPT_ENCRYPT)) {\n<87> encrypt = qemu_opt_get_bool(opts, BLOCK_OPT_ENCRYPT,\n<89> s->crypt_method);\n<91> if (encrypt != !!s->crypt_method) {\n<93> fprintf(stderr, "Changing the encryption flag is not "\n<101> } else if (!strcmp(desc->name, BLOCK_OPT_CLUSTER_SIZE)) {\n<103> cluster_size = qemu_opt_get_size(opts, BLOCK_OPT_CLUSTER_SIZE,\n<107> if (cluster_size != s->cluster_size) {\n<109> fprintf(stderr, "Changing the cluster size is not "\n<117> } else if (!strcmp(desc->name, BLOCK_OPT_LAZY_REFCOUNTS)) {\n<119> lazy_refcounts = qemu_opt_get_bool(opts, BLOCK_OPT_LAZY_REFCOUNTS,\n<123> } else if (!strcmp(desc->name, BLOCK_OPT_REFCOUNT_BITS)) {\n<125> error_report("Cannot change refcount entry width");\n<127> return -ENOTSUP;\n<135> assert(false);\n<141> desc++;\n<201> if (s->qcow_version < 3) {\n<203> fprintf(stderr, "Lazy refcounts only supported with compatibility "
<1> static void vscsi_transfer_data(SCSIRequest *sreq, uint32_t len)\n<15> DPRINTF("VSCSI: SCSI xfer complete tag=0x%x len=0x%x, req=%p\n",\n<19> if (req == NULL) {\n<21> fprintf(stderr, "VSCSI: Can't find request for tag 0x%x\n", sreq->tag);\n<37> if (rc < 0) {\n<39> fprintf(stderr, "VSCSI: RDMA error rc=%d!\n", rc);
<1> static void erase_line ( AVCodecContext * avctx , int xoffset , int xlength ) {\n<5> i < s -> font_height ;\n<6> i ++ ) memset ( s -> frame . data [ 0 ] + ( s -> y + i ) * s -> frame . linesize [ 0 ] + xoffset , DEFAULT_BG_COLOR , xlength ) ;
<1> static inline void vmsvga_copy_rect ( struct vmsvga_state_s * s , int x0 , int y0 , int x1 , int y1 , int w , int h ) {\n<6> int width = bypp * w ;\n<8> uint8_t * ptr [ 2 ] ;\n<10> ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 ) ;\n<11> ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 ) ;\n<13> line > 0 ;\n<14> line -- , ptr [ 0 ] -= bypl , ptr [ 1 ] -= bypl ) {\n<15> memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n<19> ptr [ 0 ] = vram + bypp * x0 + bypl * y0 ;\n<20> ptr [ 1 ] = vram + bypp * x1 + bypl * y1 ;\n<22> line > 0 ;\n<23> line -- , ptr [ 0 ] += bypl , ptr [ 1 ] += bypl ) {\n<24> memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;
<1> static bfd_boolean srec_scan ( bfd * abfd ) {\n<57> if ( symname == NULL ) goto error_return ;\n<58> strcpy ( symname , symbuf ) ;\n<59> free ( symbuf ) ;\n<109> if ( buf != NULL ) free ( buf ) ;\n<136> if ( sec != NULL && sec -> vma + sec -> size == address ) {\n<140> char secbuf [ 20 ] ;\n<144> sprintf ( secbuf , ".sec%d" , bfd_count_sections ( abfd ) + 1 ) ;\n<145> amt = strlen ( secbuf ) + 1 ;\n<146> secname = ( char * ) bfd_alloc ( abfd , amt ) ;\n<147> strcpy ( secname , secbuf ) ;\n<187> if ( buf != NULL ) free ( buf ) ;\n<195> if ( buf != NULL ) free ( buf ) ;\n<197> error_return : if ( symbuf != NULL ) free ( symbuf ) ;\n<198> if ( buf != NULL ) free ( buf ) ;
<1> START_TEST(qstring_append_chr_test)\n<9> const char *str = "qstring append char unit-test";\n<19> qstring_append_chr(qstring, str[i]);\n<23> fail_unless(strcmp(str, qstring_get_str(qstring)) == 0);
<1> static unsigned int dec_btst_r(DisasContext *dc)\n<11> cris_cc_mask(dc, CC_MASK_NZ);\n<17> cris_alu(dc, CC_OP_BTST, l0, cpu_R[dc->op2], cpu_R[dc->op1], 4);\n<19> cris_update_cc_op(dc, CC_OP_FLAGS, 4);\n<21> t_gen_mov_preg_TN(dc, PR_CCS, l0);
<1> void ppc_prep_init ( int ram_size , int vga_ram_size , int boot_device , DisplayState * ds , const char * * fd_filename , int snapshot , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename ) {\n<8> if ( linux_boot ) {\n<9> ret = load_image ( kernel_filename , phys_ram_base + KERNEL_LOAD_ADDR ) ;\n<10> if ( ret < 0 ) {\n<11> fprintf ( stderr , "qemu: could not load kernel '%s'\n" , kernel_filename ) ;\n<26> printf ( "load BIOS at %p\n" , phys_ram_base + 0x000f0000 ) ;\n<27> ret = load_image ( buf , phys_ram_base + 0x000f0000 ) ;\n<28> if ( ret != 0x10000 ) {\n<29> fprintf ( stderr , "qemu: could not load PPC bios '%s' (%d)\n%m\n" , buf , ret ) ;
<1> static int parse_fragment(AVFormatContext *s, const char *filename, int64_t *start_ts, int64_t *duration, int64_t *moof_size, int64_t size)\n<45> while (avio_tell(in) < *moof_size) {\n<57> if (tag == MKTAG('u','u','i','d')) {\n<69> avio_read(in, uuid, 16);\n<71> if (!memcmp(uuid, tfxd, 16) && len >= 8 + 16 + 4 + 16) {\n<73> avio_seek(in, 4, SEEK_CUR);\n<75> *start_ts = avio_rb64(in);\n<77> *duration = avio_rb64(in);\n<79> ret = 0;\n<87> avio_seek(in, end, SEEK_SET);
<1> static void ppc_heathrow_init(QEMUMachineInitArgs *args)\n<77> if (cpu == NULL) {\n<79> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<101> if (ram_size > (2047 << 20)) {\n<107> ((unsigned int)ram_size / (1 << 20)));\n<297> if (ppc_boot_device == '\0') {\n<299> fprintf(stderr, "No valid boot device for G3 Beige machine\n");
<1> uint32_t qemu_devtree_get_phandle(void *fdt, const char *path)\n<9> r = fdt_get_phandle(fdt, findnode_nofail(fdt, path));\n<11> if (r <= 0) {\n<13> fprintf(stderr, "%s: Couldn't get phandle for %s: %s\n", __func__,\n<15> path, fdt_strerror(r));
<1> void cpu_loop(CPUAlphaState *env)\n<17> cpu_exec_start(cs);\n<19> trapnr = cpu_alpha_exec(cs);\n<21> cpu_exec_end(cs);\n<35> switch (trapnr) {\n<39> fprintf(stderr, "Reset requested. Exit\n");\n<47> fprintf(stderr, "Machine check exception. Exit\n");\n<59> fprintf(stderr, "External interrupt. Exit\n");\n<357> printf ("Unhandled trap: 0x%x\n", trapnr);\n<359> cpu_dump_state(cs, stderr, fprintf, 0);
<1> static int sbr_hf_gen(AACContext *ac, SpectralBandReplication *sbr,\n<3> float X_high[64][40][2], const float X_low[32][40][2],\n<91> if (k < sbr->m[1] + sbr->kx[1])\n<93> memset(X_high + k, 0, (sbr->m[1] + sbr->kx[1] - k) * sizeof(*X_high));
<1> static void select_soundhw (const char *optarg)\n<9> if (*optarg == '?') {\n<15> printf ("Valid sound card names (comma separated):\n");\n<17> for (c = soundhw; c->name; ++c) {\n<19> printf ("%-11s %s\n", c->name, c->descr);\n<23> printf ("\n-soundhw all will enable all of the above\n");\n<41> if (!strcmp (optarg, "all")) {\n<43> for (c = soundhw; c->name; ++c) {\n<49> return;\n<55> p = optarg;\n<57> while (*p) {\n<59> e = strchr (p, ',');\n<61> l = !e ? strlen (p) : (size_t) (e - p);\n<67> if (!strncmp (c->name, p, l) && !c->name[l]) {\n<79> if (!c->name) {\n<81> if (l > 80) {\n<91> fprintf (stderr, "Unknown sound card name `%.*s'\n",\n<101> p += l + (e != NULL);\n<107> if (bad_card)
<1> static int check_user_and_ip ( int userid , struct query * q ) {\n<12> if ( ! check_ip ) {\n<15> tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n<16> return memcmp ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;
<1> int ff_vorbiscomment_write(uint8_t **p, AVDictionary **m,\n<3> const char *vendor_string)\n<7> bytestream_put_le32(p, strlen(vendor_string));\n<9> bytestream_put_buffer(p, vendor_string, strlen(vendor_string));\n<17> bytestream_put_le32(p, count);\n<19> while ((tag = av_dict_get(*m, "", tag, AV_DICT_IGNORE_SUFFIX))) {\n<21> unsigned int len1 = strlen(tag->key);\n<23> unsigned int len2 = strlen(tag->value);\n<25> bytestream_put_le32(p, len1+1+len2);\n<27> bytestream_put_buffer(p, tag->key, len1);\n<31> bytestream_put_buffer(p, tag->value, len2);\n<37> bytestream_put_le32(p, 0);
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> AnmContext * s = avctx -> priv_data ;\n<42> if ( type == 0 ) break ;\n<54> while ( bytestream2_get_bytes_left ( & s -> gb ) > 0 ) ;\n<55> memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;
<1> static int hds_flush(AVFormatContext *s, OutputStream *os, int final,\n<41> add_fragment(os, target_filename, os->frag_start_ts, end_ts - os->frag_start_ts);\n<47> ret = init_file(s, os, end_ts);\n<65> if (remove > 0) {\n<67> for (i = 0; i < remove; i++) {\n<71> av_free(os->fragments[i]);\n<79> os->nb_fragments * sizeof(*os->fragments));\n<89> ret = write_abst(s, os, final);
<1> DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n<85> if ((buf = qemu_opt_get(opts, "if")) != NULL) {\n<87> for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n<93> error_report("unsupported bus type '%s'", buf);\n<141> if ((buf = qemu_opt_get(opts, "trans")) != NULL) {\n<143> if (!cyls) {\n<153> if (!strcmp(buf, "none"))\n<155> translation = BIOS_ATA_TRANSLATION_NONE;\n<157> else if (!strcmp(buf, "lba"))\n<159> translation = BIOS_ATA_TRANSLATION_LBA;\n<161> else if (!strcmp(buf, "auto"))\n<163> translation = BIOS_ATA_TRANSLATION_AUTO;\n<167> error_report("'%s' invalid translation type", buf);\n<169> return NULL;\n<177> if ((buf = qemu_opt_get(opts, "media")) != NULL) {\n<179> if (!strcmp(buf, "disk")) {\n<181> media = MEDIA_DISK;\n<183> } else if (!strcmp(buf, "cdrom")) {\n<185> if (cyls || secs || heads) {\n<187> error_report("CHS can't be set with media=%s", buf);\n<197> error_report("'%s' invalid media", buf);\n<199> return NULL;\n<207> bdrv_flags |= BDRV_O_CACHE_WB;\n<209> if ((buf = qemu_opt_get(opts, "cache")) != NULL) {\n<317> if (qemu_opt_get(opts, "boot") != NULL) {\n<319> fprintf(stderr, "qemu-kvm: boot=on|off is deprecated and will be "\n<685> if (ret == -EMEDIUMTYPE) {\n<693> error_report("could not open disk image %s: %s",\n<695> file, strerror(-ret));
<1> static inline void gen_intermediate_code_internal(TranslationBlock * tb,\n<11> DisasContext dc1, *dc = &dc1;\n<23> memset(dc, 0, sizeof(DisasContext));\n<31> last_pc = dc->pc;\n<95> if (bp->pc == dc->pc) {\n<97> if (dc->pc != pc_start)\n<99> save_state(dc, cpu_cond);\n<129> gen_opc_pc[lj] = dc->pc;\n<131> gen_opc_npc[lj] = dc->npc;\n<145> last_pc = dc->pc;\n<147> disas_sparc_insn(dc);\n<159> if (dc->pc != (last_pc + 4))\n<211> if (!dc->is_br) {\n<213> if (dc->pc != DYNAMIC_PC &&\n<215> (dc->npc != DYNAMIC_PC && dc->npc != JUMP_PC)) {\n<219> gen_goto_tb(dc, 0, dc->pc, dc->npc);\n<223> if (dc->pc != DYNAMIC_PC)\n<225> tcg_gen_movi_tl(cpu_pc, dc->pc);\n<227> save_npc(dc, cpu_cond);
<1> static int compare_sectors(const uint8_t *buf1, const uint8_t *buf2, int n,\n<13> if (n <= 0) {\n<23> res = !!memcmp(buf1, buf2, 512);\n<25> for(i = 1; i < n; i++) {\n<27> buf1 += 512;\n<29> buf2 += 512;\n<33> if (!!memcmp(buf1, buf2, 512) != res) {\n<45> return res;
<1> static int generate_fake_vps(QSVEncContext *q, AVCodecContext *avctx)\n<15> HEVCSPS sps = { 0 };\n<17> HEVCVPS vps = { 0 };\n<41> ret = ff_h2645_extract_rbsp(avctx->extradata + 4, avctx->extradata_size - 4, &sps_nal);\n<85> ret = ff_hevc_parse_sps(&sps, &gb, &sps_id, 0, NULL, avctx);\n<89> if (ret < 0) {\n<105> memcpy(&vps.ptl, &sps.ptl, sizeof(vps.ptl));\n<153> bytestream2_init_writer(&pbc, vps_buf, sizeof(vps_buf));\n<183> vps_size = bytestream2_tell_p(&pbc);\n<187> if (!new_extradata)\n<191> memcpy(new_extradata, vps_buf, vps_size);\n<193> memcpy(new_extradata + vps_size, avctx->extradata, avctx->extradata_size);\n<197> av_freep(&avctx->extradata);\n<199> avctx->extradata       = new_extradata;\n<201> avctx->extradata_size += vps_size;
<1> void ff_rtp_send_mpegvideo(AVFormatContext *s1, const uint8_t *buf1, int size)\n<27> while (size > 0) {\n<39> if (len >= size) {\n<41> len = size;\n<81> if (r - buf1 < len) {\n<91> len = r - buf1 - 4;\n<103> len = r1 - buf1 - 4;\n<147> *q++ = h;\n<151> memcpy(q, buf1, len);\n<153> q += len;\n<161> ff_rtp_send_data(s1, s->buf, q - s->buf, (len == size));\n<165> buf1 += len;
<1> static ssize_t buffered_flush(QEMUFileBuffered *s)\n<43> DPRINTF("flushed %zu of %zu byte(s)\n", offset, s->buffer_size);\n<45> memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);
<1> PCIBus *pci_apb_init(hwaddr special_base,\n<81> is = &d->iommu;\n<83> memset(is, 0, sizeof(IOMMUState));\n<87> memory_region_init_iommu(&is->iommu, sizeof(is->iommu),\n<93> address_space_init(&is->iommu_as, MEMORY_REGION(&is->iommu), "pbm-as");\n<95> pci_setup_iommu(phb->bus, pbm_pci_dma_iommu, is);
<1> static int audio_get_buffer(AVCodecContext *avctx, AVFrame *frame)\n<37> buf = avci->buffer;\n<53> if (buf->extended_data != buf->data)\n<59> buf->data[0]       = NULL;\n<69> if (buf->extended_data != buf->data)\n<85> if (!buf->extended_data) {\n<97> if ((ret = avcodec_fill_audio_frame(frame, avctx->channels,\n<115> memcpy(buf->data, frame->data, sizeof(frame->data));\n<129> memcpy(frame->data, buf->data, sizeof(frame->data));\n<137> ff_init_buffer_info(avctx, frame);\n<143> av_log(avctx, AV_LOG_DEBUG, "default_get_buffer called on frame %p, "
<1> static int ape_decode_frame(AVCodecContext *avctx, void *data,\n<11> APEContext *s = avctx->priv_data;\n<71> av_fast_padded_malloc(&s->data, &s->data_size, buf_size);\n<73> if (!s->data)\n<81> memset(s->data + (buf_size & ~3), 0, buf_size & 3);\n<149> if (init_frame_decoder(s) < 0) {\n<185> av_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n<189> if (!s->decoded_buffer)\n<193> memset(s->decoded_buffer, 0, s->decoded_size);\n<195> s->decoded[0] = s->decoded_buffer;\n<197> s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n<217> ape_unpack_mono(s, blockstodecode);\n<221> ape_unpack_stereo(s, blockstodecode);
<1> static int unpack_superblocks(Vp3DecodeContext *s, GetBitContext *gb)\n<29> if (s->keyframe) {\n<31> memset(s->superblock_coding, SB_FULLY_CODED, s->superblock_count);\n<43> while (current_superblock < s->superblock_count && get_bits_left(gb) > 0) {\n<45> if (s->theora && current_run == MAXIMUM_LONG_BIT_RUN)\n<47> bit = get_bits1(gb);\n<51> bit ^= 1;\n<59> if (current_run == 34)\n<61> current_run += get_bits(gb, 12);\n<65> if (current_superblock + current_run > s->superblock_count) {\n<77> memset(s->superblock_coding + current_superblock, bit, current_run);\n<81> current_superblock += current_run;\n<85> num_partial_superblocks += current_run;\n<95> if (num_partial_superblocks < s->superblock_count) {\n<109> while (superblocks_decoded < s->superblock_count - num_partial_superblocks &&\n<195> memset(s->macroblock_coding, MODE_COPY, s->macroblock_count);\n<233> if (current_run-- == 0) {\n<235> bit        ^= 1;\n<241> coded = bit;\n<265> s->all_fragments[current_fragment].coding_method =
<1> static void ehci_opreg_write(void *ptr, hwaddr addr,\n<39> if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n<41> fprintf(stderr, "attempt to set frame list size -- value %d\n",\n<43> (int)val & USBCMD_FLS);\n<149> if (ehci_periodic_enabled(s)) {\n<165> if (ehci_async_enabled(s)) {
<1> static int qcow_create(const char *filename, int64_t total_size,\n<3> const char *backing_file, int flags)\n<13> QCowCreateState s1, *s = &s1;\n<17> memset(s, 0, sizeof(*s));\n<23> if (fd < 0)\n<27> memset(&header, 0, sizeof(header));\n<39> if (backing_file) {\n<43> backing_filename_len = strlen(backing_file);\n<45> header.backing_file_size = cpu_to_be32(backing_filename_len);\n<53> s->cluster_size = 1 << s->cluster_bits;\n<55> header.cluster_bits = cpu_to_be32(s->cluster_bits);\n<69> l2_bits = s->cluster_bits - 3;\n<71> shift = s->cluster_bits + l2_bits;\n<75> offset = align_offset(header_size, s->cluster_size);\n<79> header.l1_table_offset = cpu_to_be64(s->l1_table_offset);\n<83> offset += align_offset(l1_size * sizeof(uint64_t), s->cluster_size);\n<87> s->refcount_table = qemu_mallocz(s->cluster_size);\n<89> s->refcount_block = qemu_mallocz(s->cluster_size);\n<99> offset += s->cluster_size;\n<107> offset += s->cluster_size;\n<113> create_refcount_update(s, 0, header_size);\n<115> create_refcount_update(s, s->l1_table_offset, l1_size * sizeof(uint64_t));\n<117> create_refcount_update(s, s->refcount_table_offset, s->cluster_size);\n<119> create_refcount_update(s, s->refcount_block_offset, s->cluster_size);\n<125> write(fd, &header, sizeof(header));\n<129> write(fd, backing_file, backing_filename_len);
<19> struct e1000_tx *tp = &s->tx;\n<105> if (sz >= tp->props.hdr_len && tp->size < tp->props.hdr_len) {\n<107> memmove(tp->header, tp->data, tp->props.hdr_len);\n<115> if (sz == msh) {\n<119> memmove(tp->data, tp->header, tp->props.hdr_len);\n<121> tp->size = tp->props.hdr_len;\n<151> if (!(tp->props.tse && tp->props.cptse && tp->size < tp->props.hdr_len)) {
<1> static ssize_t virtio_net_receive ( VLANClientState * nc , const uint8_t * buf , size_t size ) {\n<14> struct iovec sg [ VIRTQUEUE_MAX_SIZE ] ;\n<16> if ( virtqueue_pop ( n -> rx_vq , & elem ) == 0 ) {\n<17> if ( i == 0 ) return - 1 ;\n<25> if ( ! n -> mergeable_rx_bufs && elem . in_sg [ 0 ] . iov_len != guest_hdr_len ) {\n<29> memcpy ( & sg , & elem . in_sg [ 0 ] , sizeof ( sg [ 0 ] ) * elem . in_num ) ;\n<32> offset += receive_header ( n , sg , elem . in_num , buf + offset , size - offset , guest_hdr_len ) ;\n<35> len = iov_from_buf ( sg , elem . in_num , buf + offset , 0 , size - offset ) ;
<1> static int decode_frame(AVCodecContext * avctx, void *data, int *got_frame,\n<7> KmvcContext *const ctx = avctx->priv_data;\n<19> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<27> if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n<45> ctx->pal[i + (header & 0x81)] = 0xFFU << 24 | bytestream2_get_be24(&ctx->g);\n<81> ctx->pal[i] = 0xFFU << 24 | bytestream2_get_be24(&ctx->g);\n<89> if (pal) {\n<93> memcpy(ctx->pal, pal, AVPALETTE_SIZE);\n<111> memcpy(frame->data[1], ctx->pal, 1024);\n<119> if (blocksize != 8 && blocksize != 127) {\n<127> memset(ctx->cur, 0, 320 * 200);\n<129> switch (header & KMVC_METHOD) {\n<135> memcpy(ctx->cur, ctx->prev, 320 * 200);\n<141> kmvc_decode_intra_8x8(ctx, avctx->width, avctx->height);\n<147> kmvc_decode_inter_8x8(ctx, avctx->width, avctx->height);\n<161> out = frame->data[0];\n<163> src = ctx->cur;\n<165> for (i = 0; i < avctx->height; i++) {\n<167> memcpy(out, src, avctx->width);\n<169> src += 320;\n<171> out += frame->linesize[0];\n<179> if (ctx->cur == ctx->frm0) {
<1> static void add_codec(FFStream *stream, AVCodecContext *av)\n<21> if (av->bit_rate == 0)\n<23> av->bit_rate = 64000;\n<25> if (av->sample_rate == 0)\n<27> av->sample_rate = 22050;\n<29> if (av->channels == 0)\n<31> av->channels = 1;\n<37> if (av->bit_rate == 0)\n<39> av->bit_rate = 64000;\n<49> if (av->width == 0 || av->height == 0) {\n<51> av->width = 160;\n<53> av->height = 128;\n<59> if (av->bit_rate_tolerance == 0)\n<61> av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,\n<65> if (av->qmin == 0)\n<67> av->qmin = 3;\n<69> if (av->qmax == 0)\n<71> av->qmax = 31;\n<73> if (av->max_qdiff == 0)\n<75> av->max_qdiff = 3;\n<77> av->qcompress = 0.5;\n<79> av->qblur = 0.5;\n<83> if (!av->nsse_weight)\n<85> av->nsse_weight = 8;\n<89> av->frame_skip_cmp = FF_CMP_DCTMAX;\n<91> if (!av->me_method)\n<93> av->me_method = ME_EPZS;\n<95> av->rc_buffer_aggressivity = 1.0;\n<99> if (!av->rc_eq)\n<101> av->rc_eq = "tex^qComp";\n<103> if (!av->i_quant_factor)\n<105> av->i_quant_factor = -0.8;\n<107> if (!av->b_quant_factor)\n<109> av->b_quant_factor = 1.25;\n<111> if (!av->b_quant_offset)\n<113> av->b_quant_offset = 1.25;\n<117> av->rc_max_rate = av->bit_rate * 2;\n<121> if (av->rc_max_rate && !av->rc_buffer_size) {\n<123> av->rc_buffer_size = av->rc_max_rate;\n<143> if (!st)\n<147> st->codec = avcodec_alloc_context3(NULL);\n<151> memcpy(st->codec, av, sizeof(AVCodecContext));
<1> static void kvm_do_inject_x86_mce(void *_data)\n<19> if (r == -1) {\n<21> fprintf(stderr, "Failed to get MCE status\n");
<1> static void fill_colmap ( H264Context * h , int map [ 2 ] [ 16 + 32 ] , int list , int field , int colfield , int mbafi ) {\n<7> memset ( map [ list ] , 0 , sizeof ( map [ list ] ) ) ;
<1> void ff_do_elbg(int *points, int dim, int numpoints, int *codebook,\n<13> elbg_data *elbg = &elbg_d;\n<19> int *size_part = av_malloc(numCB*sizeof(int));\n<35> elbg->codebook = codebook;\n<37> elbg->cells = av_malloc(numCB*sizeof(cell *));\n<39> elbg->utility = av_malloc(numCB*sizeof(int));\n<63> memset(elbg->utility, 0, numCB*sizeof(int));\n<65> memset(elbg->cells, 0, numCB*sizeof(cell *));\n<79> best_dist = distance_limited(elbg->points + i*elbg->dim, elbg->codebook + best_idx*elbg->dim, dim, INT_MAX);\n<101> elbg->utility[elbg->nearest_cb[i]] += dist_cb[i];\n<107> elbg->cells[elbg->nearest_cb[i]] = free_cells;\n<115> do_shiftings(elbg);\n<119> memset(size_part, 0, numCB*sizeof(int));\n<123> memset(elbg->codebook, 0, elbg->numCB*dim*sizeof(int));\n<129> size_part[elbg->nearest_cb[i]]++;\n<133> elbg->codebook[elbg->nearest_cb[i]*elbg->dim + j] +=\n<143> vect_division(elbg->codebook + i*elbg->dim,\n<145> elbg->codebook + i*elbg->dim, size_part[i], elbg->dim);\n<149> } while(((last_error - elbg->error) > DELTA_ERR_MAX*elbg->error) &&\n<157> av_free(size_part);\n<159> av_free(elbg->utility);\n<163> av_free(elbg->cells);
<1> static int img_convert(int argc, char **argv)\n<333> if (bs_sectors[bs_i] < 0) {\n<337> argv[optind + bs_i], strerror(-bs_sectors[bs_i]));\n<495> if (encryption) {\n<511> && strcmp(preallocation, "off"))\n<607> if (output_sectors < 0) {\n<609> error_report("unable to get output image length: %s\n",\n<611> strerror(-output_sectors));
<19> switch ( * buf ) {\n<35> case DUL_TYPESCUSCPROLE : role = ( PRV_SCUSCPROLE * ) malloc ( sizeof ( PRV_SCUSCPROLE ) ) ;\n<36> if ( role == NULL ) return EC_MemoryExhausted ;
<11> PAVoiceOut *pa = (PAVoiceOut *) hw;\n<65> if (!pa->pcm_buf) {\n<77> if (audio_pt_init (&pa->pt, qpa_thread_out, hw, AUDIO_CAP, AUDIO_FUNC)) {\n<91> free (pa->pcm_buf);
<1> static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n<10> const char * adb_check_port_templace = "%04x" "shell:cat /proc/%set/tcp" ;\n<19> char model_name [ MODEL_NAME_LENGTH_MAX ] ;\n<38> while ( pos < ( char * ) ( device_list + device_length ) ) {\n<40> pos = strchr ( pos , ' ' ) ;\n<41> i_pos = pos ;\n<42> result = ( int ) ( pos - prev_pos ) ;\n<43> pos = strchr ( pos , '\n' ) + 1 ;\n<44> if ( result >= ( int ) sizeof ( serial_number ) ) {\n<48> memcpy ( serial_number , prev_pos , result ) ;\n<49> serial_number [ result ] = '\0' ;\n<50> serial_number_length = strlen ( serial_number ) ;\n<51> model_name [ 0 ] = '\0' ;\n<52> model_pos = g_strstr_len ( i_pos , pos - i_pos , "model:" ) ;\n<55> if ( device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX ) {\n<56> memcpy ( model_name , model_pos + 6 , device_pos - model_pos - 6 - 1 ) ;\n<57> model_name [ device_pos - model_pos - 6 - 1 ] = '\0' ;\n<60> if ( model_name [ 0 ] == '\0' ) strcpy ( model_name , "unknown" ) ;\n<61> verbose_print ( "VERBOSE: Processing device: \"%s\" <%s>\n" , serial_number , model_name ) ;\n<64> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<76> response = adb_send_and_read ( sock , adb_tcpdump_help , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n<78> if ( response ) {\n<79> response [ data_length ] = '\0' ;\n<80> if ( strstr ( response , "tcpdump version" ) ) {\n<81> new_interface ( extcap_conf , INTERFACE_ANDROID_WIFI_TCPDUMP , model_name , serial_number , "Android WiFi" ) ;\n<90> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<115> new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_EVENTS , model_name , serial_number , "Android Logcat Events" ) ;\n<122> new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_CRASH , model_name , serial_number , "Android Logcat Crash" ) ;\n<128> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<158> new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_HCIDUMP , model_name , serial_number , "Android Bluetooth Hcidump" ) ;\n<165> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<179> if ( ! response || data_length < 1 ) {\n<187> memset ( pid , 0 , sizeof ( pid ) ) ;\n<188> response [ data_length ] = '\0' ;\n<189> data_str = strchr ( response , '\n' ) ;\n<190> if ( data_str && sscanf ( data_str , "%*s %s" , pid ) == 1 ) {\n<191> verbose_print ( "VERBOSE: Android Bluetooth application PID for %s is %s\n" , serial_number , pid ) ;\n<192> sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n<193> if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_1 ;\n<194> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<201> if ( result ) {\n<206> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n<214> if ( ! response ) {\n<218> response [ data_length ] = '\0' ;\n<219> data_str = strchr ( response , '\n' ) ;\n<220> if ( data_str && sscanf ( data_str , "%*s %s" , pid ) == 1 && strcmp ( pid + 9 , "10EA" ) == 0 ) {\n<221> verbose_print ( "VERBOSE: Bluedroid External Parser Port for %s is %s\n" , serial_number , pid + 9 ) ;\n<224> disable_interface = 1 ;\n<225> verbose_print ( "VERBOSE: Bluedroid External Parser Port for %s is unknown\n" , serial_number ) ;\n<230> disable_interface = 1 ;\n<231> verbose_print ( "VERBOSE: Android Bluetooth application PID for %s is unknown\n" , serial_number ) ;\n<234> if ( ! disable_interface ) {\n<235> new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER , model_name , serial_number , "Android Bluetooth External Parser" ) ;\n<238> if ( api_level >= 21 ) {\n<242> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<259> if ( ! response || data_length < 1 ) {\n<267> memset ( pid , 0 , sizeof ( pid ) ) ;\n<268> response [ data_length ] = '\0' ;\n<269> data_str = strchr ( response , '\n' ) ;\n<270> if ( data_str && sscanf ( data_str , "%*s %s" , pid ) == 1 ) {\n<271> verbose_print ( "VERBOSE: Android Bluetooth application PID for %s is %s\n" , serial_number , pid ) ;\n<272> sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n<273> if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_2 ;\n<274> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<281> if ( result ) {\n<286> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n<294> if ( ! response ) {\n<298> response [ data_length ] = '\0' ;\n<299> data_str = strchr ( response , '\n' ) ;\n<300> if ( data_str && sscanf ( data_str , "%*s %s" , pid ) == 1 && strcmp ( pid + 9 , "22A8" ) == 0 ) {\n<301> verbose_print ( "VERBOSE: Btsnoop Net Port for %s is %s\n" , serial_number , pid + 9 ) ;\n<304> disable_interface = 1 ;\n<305> verbose_print ( "VERBOSE: Btsnoop Net Port for %s is unknown\n" , serial_number ) ;\n<310> disable_interface = 1 ;\n<311> verbose_print ( "VERBOSE: Android Bluetooth application PID for %s is unknown\n" , serial_number ) ;\n<314> if ( ! disable_interface ) {\n<315> new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET , model_name , serial_number , "Android Bluetooth Btsnoop Net" ) ;
<15> if (read_len_table(s->len[0], &gb) < 0)\n<25> if (read_len_table(s->len[1], &gb) < 0)\n<31> for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];\n<33> for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];\n<37> if (s->bitstream_bpp >= 24) {\n<39> memcpy(s->bits[1], s->bits[0], 256 * sizeof(uint32_t));\n<41> memcpy(s->len[1] , s->len [0], 256 * sizeof(uint8_t));\n<45> memcpy(s->bits[2], s->bits[1], 256 * sizeof(uint32_t));\n<47> memcpy(s->len[2] , s->len [1], 256 * sizeof(uint8_t));
<1> kadm5_ret_t kadm5_create_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n<7> if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n<8> if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n<9> if ( ! ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n<10> if ( ( mask & KADM5_POLICY_ALLOWED_KEYSALTS ) && entry -> allowed_keysalts != NULL ) {\n<12> if ( ret ) return ret ;\n<14> memset ( & pent , 0 , sizeof ( pent ) ) ;\n<15> pent . name = entry -> policy ;\n<16> p = entry -> policy ;\n<73> if ( ( ret = krb5_db_create_policy ( handle -> context , & pent ) ) ) return ret ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> const uint8_t * buf = avpkt -> data ;\n<4> ZmbvContext * const c = avctx -> priv_data ;\n<17> buf ++ ;\n<18> len -- ;\n<28> buf += 6 ;\n<29> len -= 6 ;\n<83> if ( c -> comp == 0 ) {\n<84> memcpy ( c -> decomp_buf , buf , len ) ;\n<103> c -> decode_intra ( c ) ;\n<108> if ( c -> decomp_len ) c -> decode_xor ( c ) ;
<1> static void ide_cfata_identify(IDEState *s)\n<11> p = (uint16_t *) s->identify_data;\n<13> if (s->identify_set)\n<19> memset(p, 0, sizeof(s->identify_data));\n<27> put_le16(p + 0, 0x848a);			/* CF Storage Card signature */\n<29> put_le16(p + 1, s->cylinders);		/* Default cylinders */\n<31> put_le16(p + 3, s->heads);			/* Default heads */\n<33> put_le16(p + 6, s->sectors);		/* Default sectors per track */\n<35> put_le16(p + 7, s->nb_sectors >> 16);	/* Sectors per card */\n<37> put_le16(p + 8, s->nb_sectors);		/* Sectors per card */\n<39> padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */\n<41> put_le16(p + 22, 0x0004);			/* ECC bytes */\n<43> padstr((char *) (p + 23), s->version, 8);	/* Firmware Revision */\n<45> padstr((char *) (p + 27), "QEMU MICRODRIVE", 40);/* Model number */\n<53> put_le16(p + 47, 0x0000);\n<57> put_le16(p + 49, 0x0f00);			/* Capabilities */\n<59> put_le16(p + 51, 0x0002);			/* PIO cycle timing mode */\n<61> put_le16(p + 52, 0x0001);			/* DMA cycle timing mode */\n<63> put_le16(p + 53, 0x0003);			/* Translation params valid */\n<65> put_le16(p + 54, s->cylinders);		/* Current cylinders */\n<67> put_le16(p + 55, s->heads);			/* Current heads */\n<69> put_le16(p + 56, s->sectors);		/* Current sectors */\n<71> put_le16(p + 57, cur_sec);			/* Current capacity */\n<73> put_le16(p + 58, cur_sec >> 16);		/* Current capacity */\n<77> put_le16(p + 59, 0x100 | s->mult_sectors);\n<79> put_le16(p + 60, s->nb_sectors);		/* Total LBA sectors */\n<81> put_le16(p + 61, s->nb_sectors >> 16);	/* Total LBA sectors */\n<83> put_le16(p + 63, 0x0203);			/* Multiword DMA capability */\n<85> put_le16(p + 64, 0x0001);			/* Flow Control PIO support */\n<87> put_le16(p + 65, 0x0096);			/* Min. Multiword DMA cycle */\n<89> put_le16(p + 66, 0x0096);			/* Rec. Multiword DMA cycle */\n<91> put_le16(p + 68, 0x00b4);			/* Min. PIO cycle time */\n<93> put_le16(p + 82, 0x400c);			/* Command Set supported */\n<95> put_le16(p + 83, 0x7068);			/* Command Set supported */\n<97> put_le16(p + 84, 0x4000);			/* Features supported */\n<99> put_le16(p + 85, 0x000c);			/* Command Set enabled */\n<101> put_le16(p + 86, 0x7044);			/* Command Set enabled */\n<103> put_le16(p + 87, 0x4000);			/* Features enabled */\n<105> put_le16(p + 91, 0x4060);			/* Current APM level */\n<107> put_le16(p + 129, 0x0002);			/* Current features option */\n<109> put_le16(p + 130, 0x0005);			/* Reassigned sectors */\n<111> put_le16(p + 131, 0x0001);			/* Initial power mode */\n<113> put_le16(p + 132, 0x0000);			/* User signature */\n<115> put_le16(p + 160, 0x8100);			/* Power requirement */\n<117> put_le16(p + 161, 0x8001);			/* CF command set */\n<127> memcpy(s->io_buffer, p, sizeof(s->identify_data));
<1> static int usb_net_handle_data(USBDevice *dev, USBPacket *p)\n<19> ret = usb_net_handle_statusin(s, p);\n<27> ret = usb_net_handle_datain(s, p);\n<49> ret = usb_net_handle_dataout(s, p);\n<75> if (ret == USB_RET_STALL)\n<77> fprintf(stderr, "usbnet: failed data transaction: "
<1> static void msrle_decode_pal8(MsrleContext *s)\n<23> while (row_ptr >= 0) {\n<65> if ((row_ptr + pixel_ptr + stream_byte > frame_size) ||\n<69> printf(" MS RLE: frame ptr just went out of bounds (1)\n");\n<81> if (stream_ptr + rle_code + extra_byte > s->size) {\n<83> printf(" MS RLE: stream ptr just went out of bounds (2)\n");\n<115> if ((row_ptr + pixel_ptr + stream_byte > frame_size) ||\n<119> printf(" MS RLE: frame ptr just went out of bounds (2)\n");\n<147> memcpy(s->frame.data[1], s->palette, 256 * 4);\n<153> if (stream_ptr < s->size)\n<155> printf(" MS RLE: ended frame decode with bytes left over (%d < %d)\n",
<1> void event_loop(void)\n<73> incr = -10.0;\n<79> incr = 10.0;\n<85> incr = 60.0;\n<91> incr = -60.0;\n<97> pos = get_master_clock(cur_stream);\n<99> printf("%f %f %d %d %d %d\n", (float)pos, (float)incr, cur_stream->av_sync_type == AV_SYNC_VIDEO_MASTER,\n<101> cur_stream->av_sync_type == AV_SYNC_AUDIO_MASTER, cur_stream->video_st, cur_stream->audio_st);\n<105> stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE));\n<129> thh = tns/3600;\n<131> tmm = (tns%3600)/60;\n<133> tss = (tns%60);\n<139> hh = ns/3600;\n<141> mm = (ns%3600)/60;\n<143> ss = (ns%60);\n<145> fprintf(stderr, "Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \n", frac*100,
<1> static int opt_preset(const char *opt, const char *arg)\n<7> char filename[1000], tmp[1000], tmp2[1000], line[1000];\n<11> const char *base[3]= { getenv("HOME"),\n<21> for(i=!base[0]; i<3 && !f; i++){\n<23> snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s.ffpreset", base[i], i ? "" : ".", arg);\n<25> f= fopen(filename, "r");\n<35> snprintf(filename, sizeof(filename), "%s/%sffmpeg/%s-%s.ffpreset", base[i],  i ? "" : ".", codec_name, arg);\n<37> f= fopen(filename, "r");\n<43> if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||\n<45> is_dos_path(arg))){\n<47> snprintf(filename, sizeof(filename), arg);\n<49> f= fopen(filename, "r");\n<55> if(!f){\n<57> fprintf(stderr, "File for preset '%s' not found\n", arg);\n<65> while(!feof(f)){\n<67> int e= fscanf(f, "%999[^\n]\n", line) - 1;\n<69> if(line[0] == '#' && !e)\n<73> e|= sscanf(line, "%999[^=]=%999[^\n]\n", tmp, tmp2) - 2;\n<75> if(e){\n<77> fprintf(stderr, "%s: Preset file invalid\n", filename);\n<83> if(!strcmp(tmp, "acodec")){\n<85> opt_audio_codec(tmp2);\n<87> }else if(!strcmp(tmp, "vcodec")){\n<89> opt_video_codec(tmp2);\n<91> }else if(!strcmp(tmp, "scodec")){\n<93> opt_subtitle_codec(tmp2);\n<95> }else if(opt_default(tmp, tmp2) < 0){\n<97> fprintf(stderr, "%s: Invalid option or argument: %s=%s\n", filename, tmp, tmp2);
<1> static int alloc_buffer(FrameBuffer **pool, AVCodecContext *s, FrameBuffer **pbuf)\n<49> if ((ret = av_image_alloc(buf->base, buf->linesize, w, h,\n<67> memset(buf->base[0], 128, ret);
<1> static void numa_node_parse_cpus(int nodenr, const char *cpus)\n<25> if (!(endvalue < MAX_CPUMASK_BITS)) {\n<27> endvalue = MAX_CPUMASK_BITS - 1;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<92> if ( ( compr & ( ~ TGA_RLE ) ) == TGA_NODATA ) {\n<93> memset ( p -> data [ 0 ] , 0 , p -> linesize [ 0 ] * h ) ;
<1> START_TEST(qstring_from_substr_test)\n<13> fail_unless(strcmp(qstring_get_str(qs), "tualiza") == 0);
<1> int css_do_tsch(SubchDev *sch, IRB *target_irb)\n<5> SCSW *s = &sch->curr_status.scsw;\n<21> if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n<35> actl = s->ctrl & SCSW_CTRL_MASK_ACTL;\n<41> memset(&irb, 0, sizeof(IRB));\n<47> memcpy(&irb.scsw, s, sizeof(SCSW));\n<69> if ((s->dstat & SCSW_DSTAT_UNIT_CHECK) &&\n<75> memcpy(irb.ecw, sch->sense_data, sizeof(sch->sense_data));\n<85> copy_irb_to_guest(target_irb, &irb, p);\n<93> s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n<101> s->ctrl &= ~SCSW_CTRL_MASK_FCTL;\n<107> s->flags &= ~SCSW_FLAGS_MASK_PNO;\n<125> s->flags &= ~SCSW_FLAGS_MASK_PNO;\n<141> s->ctrl &= ~SCSW_ACTL_RESUME_PEND;\n<151> if (p->chars & PMCW_CHARS_MASK_CSENSE) {\n<153> memset(sch->sense_data, 0 , sizeof(sch->sense_data));
<1> int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n<11> memcpy ( & caf_file_header , fourcc , 4 ) ;\n<12> if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) {\n<16> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) {\n<20> WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ;\n<21> if ( caf_file_header . mFileVersion != 1 ) {\n<22> error_line ( "%s: can't handle version %d .CAF files!" , infilename , caf_file_header . mFileVersion ) ;\n<26> if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) {\n<30> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) {\n<34> WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ;\n<35> if ( ! strncmp ( caf_chunk_header . mChunkType , "desc" , 4 ) ) {\n<37> if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n<41> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n<45> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;\n<46> if ( debug_logging_mode ) {\n<47> char formatstr [ 5 ] ;\n<48> memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ;\n<49> formatstr [ 4 ] = 0 ;\n<50> error_line ( "format = %s, flags = %x, sampling rate = %g" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ;\n<51> error_line ( "packet = %d bytes and %d frames" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ;\n<54> if ( strncmp ( caf_audio_format . mFormatID , "lpcm" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ;\n<55> else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ;\n<58> else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ;\n<63> config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ;\n<68> if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ;\n<75> else if ( ! strncmp ( caf_chunk_header . mChunkType , "chan" , 4 ) ) {\n<76> CAFChannelLayout * caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;\n<77> if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n<79> free ( caf_channel_layout ) ;\n<82> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n<84> free ( caf_channel_layout ) ;\n<87> WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ;\n<89> if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) {\n<91> free ( caf_channel_layout ) ;\n<94> switch ( caf_channel_layout -> mChannelLayoutTag ) {\n<99> if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) {\n<101> free ( caf_channel_layout ) ;\n<104> if ( num_descriptions >= 256 ) {\n<108> channel_reorder = malloc ( num_descriptions ) ;\n<109> memset ( channel_reorder , - 1 , num_descriptions ) ;\n<110> channel_identities = malloc ( num_descriptions + 1 ) ;\n<112> i < num_descriptions ;\n<123> channel_reorder [ i ] = cindex ++ ;\n<128> ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) {\n<130> if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ;\n<131> else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ;\n<134> channel_identities [ idents ++ ] = 0xff ;\n<136> channel_reorder [ i ] = cindex ++ ;\n<140> ++ i ) if ( channel_reorder [ i ] != i ) break ;\n<141> if ( i == num_descriptions ) {\n<142> free ( channel_reorder ) ;\n<149> if ( ! idents ) {\n<150> free ( channel_identities ) ;\n<153> else channel_identities [ idents ] = 0 ;\n<155> error_line ( "layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;\n<156> if ( channel_reorder && num_descriptions <= 8 ) {\n<168> if ( debug_logging_mode ) error_line ( "layout_tag = 0x%08x, so using supplied bitmap of 0x%08x" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;\n<172> ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {\n<175> if ( layouts [ i ] . mChannelReorder ) {\n<176> channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;\n<179> if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;\n<183> if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( "layout_tag 0x%08x not found in table...all channels unassigned" , caf_channel_layout -> mChannelLayoutTag ) ;\n<186> free ( caf_channel_layout ) ;\n<188> else if ( ! strncmp ( caf_chunk_header . mChunkType , "data" , 4 ) ) {\n<225> int bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;\n<226> char * buff = malloc ( bytes_to_copy ) ;\n<227> if ( debug_logging_mode ) error_line ( "extra unknown chunk \"%c%c%c%c\" of %d bytes" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ;\n<228> if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) {\n<230> free ( buff ) ;\n<233> free ( buff ) ;\n<237> if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) {\n<241> if ( channel_identities ) free ( channel_identities ) ;\n<242> if ( channel_layout || channel_reorder ) {\n<243> if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) {\n<247> if ( channel_reorder ) free ( channel_reorder ) ;
<9> Vp3DecodeContext *s = avctx->priv_data;\n<105> init_loop_filter(s);\n<153> avctx->release_buffer(avctx, &s->golden_frame);\n<155> s->last_frame= s->golden_frame; /* ensure that we catch any access to this released frame */\n<161> avctx->release_buffer(avctx, &s->golden_frame);\n<165> avctx->release_buffer(avctx, &s->last_frame);\n<171> s->golden_frame.reference = 3;\n<173> if(avctx->get_buffer(avctx, &s->golden_frame) < 0) {\n<185> memcpy(&s->current_frame, &s->golden_frame, sizeof(AVFrame));\n<209> s->current_frame.reference = 3;\n<211> if(avctx->get_buffer(avctx, &s->current_frame) < 0) {\n<301> if (unpack_dct_coeffs(s, &gb)){\n<315> reverse_dc_prediction(s, 0, s->fragment_width, s->fragment_height);\n<337> render_slice(s, i);\n<359> *(AVFrame*)data= s->current_frame;\n<371> avctx->release_buffer(avctx, &s->last_frame);\n<377> memcpy(&s->last_frame, &s->current_frame, sizeof(AVFrame));
<1> static int bmp_decode_frame(AVCodecContext *avctx,\n<161> depth = bytestream_get_le16(&buf);\n<167> comp = bytestream_get_le32(&buf);\n<193> rgb[2] = bytestream_get_le32(&buf);\n<337> buf = buf0 + hsize;\n<349> if(n * avctx->height > dsize && comp != BMP_RLE4 && comp != BMP_RLE8){\n<363> if(comp == BMP_RLE4 || comp == BMP_RLE8)\n<365> memset(p->data[0], 0, avctx->height * p->linesize[0]);\n<369> if(depth == 4 || depth == 8)\n<371> memset(p->data[1], 0, 1024);\n<377> ptr = p->data[0] + (avctx->height - 1) * p->linesize[0];\n<383> ptr = p->data[0];\n<401> t = bytestream_get_le32(&buf);\n<421> ((uint32_t*)p->data[1])[i] = bytestream_get_le24(&buf);\n<427> ((uint32_t*)p->data[1])[i] = bytestream_get_le32(&buf);\n<431> buf = buf0 + hsize;\n<439> p->data[0] += p->linesize[0] * (avctx->height - 1);\n<449> p->data[0] += p->linesize[0] * (avctx->height - 1);\n<497> for(i = 0; i < avctx->height; i++){\n<499> memcpy(ptr, buf, n);\n<501> buf += n;\n<503> ptr += linesize;
<1> static void add_flagname_to_bitmaps(const char *flagname, uint32_t *features,\n<19> for ( i = 0 ; i < 32 ; i++ )\n<21> if (feature_name[i] && !strcmp (flagname, feature_name[i])) {\n<23> *features |= 1 << i;\n<25> found = 1;\n<29> for ( i = 0 ; i < 32 ; i++ )\n<31> if (ext_feature_name[i] && !strcmp (flagname, ext_feature_name[i])) {\n<33> *ext_features |= 1 << i;\n<35> found = 1;\n<39> for ( i = 0 ; i < 32 ; i++ )\n<41> if (ext2_feature_name[i] && !strcmp (flagname, ext2_feature_name[i])) {\n<43> *ext2_features |= 1 << i;\n<45> found = 1;\n<49> for ( i = 0 ; i < 32 ; i++ )\n<51> if (ext3_feature_name[i] && !strcmp (flagname, ext3_feature_name[i])) {\n<53> *ext3_features |= 1 << i;\n<55> found = 1;\n<59> for ( i = 0 ; i < 32 ; i++ )\n<61> if (kvm_feature_name[i] && !strcmp (flagname, kvm_feature_name[i])) {\n<63> *kvm_features |= 1 << i;\n<65> found = 1;\n<71> if (!found) {\n<73> fprintf(stderr, "CPU feature %s not found\n", flagname);
<13> AVFrame *picture = data;\n<197> if(!s->lossless){\n<199> picture->quality= FFMAX(FFMAX(s->qscale[0], s->qscale[1]), s->qscale[2]);\n<203> picture->qscale_table= s->qscale_table;\n<205> memset(picture->qscale_table, picture->quality, (s->width+15)/16);\n<209> av_log(avctx, AV_LOG_DEBUG, "QP: %d\n", picture->quality);\n<211> picture->quality*= FF_QP2LAMBDA;
<1> static int configure_accelerator(void)\n<45> p = get_opt_name(buf, sizeof (buf), p, ':');\n<47> for (i = 0; i < ARRAY_SIZE(accel_list); i++) {\n<49> if (strcmp(accel_list[i].opt_name, buf) == 0) {\n<51> ret = accel_list[i].init();\n<53> if (ret < 0) {\n<57> if (!accel_list[i].available()) {\n<65> fprintf(stderr, "failed to initialize %s: %s\n",\n<69> strerror(-ret));\n<87> if (i == ARRAY_SIZE(accel_list)) {\n<89> fprintf(stderr, "\"%s\" accelerator does not exist.\n", buf);\n<97> if (!accel_initalised) {\n<99> fprintf(stderr, "No accelerator found!\n");\n<107> if (init_failed) {\n<109> fprintf(stderr, "Back to %s accelerator.\n", accel_list[i].name);
<1> static void test_qemu_strtoul_hex(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoul(str, &endptr, 16, &res);\n<25> g_assert(endptr == str + strlen(str));\n<33> endptr = &f;\n<35> err = qemu_strtoul(str, &endptr, 0, &res);\n<43> g_assert(endptr == str + strlen(str));
<1> static int mss2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> MSS12Context * c = & ctx -> c ;\n<85> if ( ( i = decode_pal_v2 ( c , buf , buf_size ) ) < 0 ) return AVERROR_INVALIDDATA ;\n<149> else if ( ! implicit_rect || wmv9_mask != - 1 ) {\n<166> else memset ( c -> pal_pic , 0 , c -> pal_stride * avctx -> height ) ;\n<184> uint8_t * dst = c -> rgb_pic + y * c -> rgb_stride + x * 3 ;\n<185> if ( wmv9_mask != - 1 ) {\n<186> ctx -> dsp . mss2_gray_fill_masked ( dst , c -> rgb_stride , wmv9_mask , c -> pal_pic + y * c -> pal_stride + x , c -> pal_stride , w , h ) ;\n<190> memset ( dst , 0x80 , w * 3 ) ;\n<191> dst += c -> rgb_stride ;\n<193> while ( -- h ) ;
<1> int unix_listen_opts(QemuOpts *opts, Error **errp)\n<7> const char *path = qemu_opt_get(opts, "path");\n<15> if (sock < 0) {\n<25> memset(&un, 0, sizeof(un));\n<29> if (path && strlen(path)) {\n<31> snprintf(un.sun_path, sizeof(un.sun_path), "%s", path);\n<35> char *tmpdir = getenv("TMPDIR");\n<37> snprintf(un.sun_path, sizeof(un.sun_path), "%s/qemu-socket-XXXXXX",\n<39> tmpdir ? tmpdir : "/tmp");\n<55> fd = mkstemp(un.sun_path); close(fd);\n<57> qemu_opt_set(opts, "path", un.sun_path);\n<65> if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {
<1> VirtIOSCSIReq *virtio_scsi_init_req(VirtIOSCSI *s, VirtQueue *vq)\n<9> const size_t zero_skip = offsetof(VirtIOSCSIReq, vring);\n<13> req = g_malloc(sizeof(*req) + vs->cdb_size);\n<15> req->vq = vq;\n<17> req->dev = s;\n<23> memset((uint8_t *)req + zero_skip, 0, sizeof(*req) - zero_skip);
<1> x11grab_read_header(AVFormatContext *s1)\n<15> int x_off = 0;\n<17> int y_off = 0;\n<37> if (!dpyname)\n<43> offset = strchr(dpyname, '+');\n<45> if (offset) {\n<47> sscanf(offset, "%d,%d", &x_off, &y_off);\n<49> if (strstr(offset, "nomouse")) {\n<57> x11grab->draw_mouse = 0;\n<67> av_log(s1, AV_LOG_INFO, "device: %s -> display: %s x: %d y: %d width: %d height: %d\n",\n<119> XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &x_off, &y_off, &ret, &ret, &ret);\n<121> x_off -= x11grab->width / 2;\n<123> y_off -= x11grab->height / 2;\n<329> x11grab->x_off = x_off;\n<331> x11grab->y_off = y_off;
<1> static void rtsp_send_cmd(AVFormatContext *s,\n<9> RTSPState *rt = s->priv_data;\n<17> av_strlcpy(buf, cmd, sizeof(buf));\n<23> if (rt->session_id[0] != '\0' && !strstr(cmd, "\nIf-Match:")) {\n<25> snprintf(buf1, sizeof(buf1), "Session: %s\r\n", rt->session_id);\n<27> av_strlcat(buf, buf1, sizeof(buf));\n<31> av_strlcat(buf, "\r\n", sizeof(buf));\n<39> url_write(rt->rtsp_hd, buf, strlen(buf));\n<43> rtsp_read_reply(rt, reply, content_ptr);
<1> int sd_do_command(SDState *sd, SDRequest *req,\n<3> uint8_t *response) {\n<41> if (!cmd_valid_while_locked(sd, req)) {\n<45> fprintf(stderr, "SD: Card is locked\n");\n<59> rtype = sd_app_command(sd, *req);\n<65> rtype = sd_normal_command(sd, *req);\n<83> switch (rtype) {\n<99> memcpy(response, sd->cid, sizeof(sd->cid));\n<109> memcpy(response, sd->csd, sizeof(sd->csd));
<1> static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n<15> switch (opc) {\n<577> fprintf(stderr, "Missing: %s\n", tcg_op_defs[opc].name);
<1> int avconv_parse_options(int argc, char **argv)\n<13> memset(&octx, 0, sizeof(octx));\n<19> ret = split_commandline(&octx, argc, argv, options, groups);\n<33> ret = parse_optgroup(NULL, &octx.global_opts);\n<75> uninit_parse_context(&octx);
<57> i < avctx -> channels ;\n<58> i ++ ) memcpy ( frame -> extended_data [ i ] , s -> channel [ i ] . out , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) ) ;\n<60> i < avctx -> channels ;\n<62> memcpy ( & s -> channel [ i ] . out [ 0 ] , & s -> channel [ i ] . out [ s -> samples_per_frame ] , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) >> 1 ) ;
<1> int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)\n<9> opt = qemu_opt_find(opts, name);\n<19> for (i = 0; desc[i].name != NULL; i++) {\n<21> if (strcmp(desc[i].name, name) == 0) {\n<29> if (desc[i].name == NULL) {\n<31> if (i == 0) {\n<37> fprintf(stderr, "option \"%s\" is not valid for %s\n",\n<49> opt->name = qemu_strdup(name);\n<65> opt->str = NULL;\n<69> opt->str = qemu_strdup(value);\n<73> if (qemu_opt_parse(opt) < 0) {\n<75> fprintf(stderr, "Failed to parse \"%s\" for \"%s.%s\"\n", opt->str,\n<79> qemu_opt_del(opt);
<1> static void term_up_char(void)\n<31> if (term_hist_entry >= 0) {\n<37> term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
<1> static int op_to_movi(int op)\n<5> switch (op_bits(op)) {\n<21> fprintf(stderr, "op_to_movi: unexpected return value of "
<1> static void test_separators(const AVDictionary *m, const char pair, const char val)\n<13> char *buffer = NULL;\n<19> av_dict_get_string(dict, &buffer, val, pair);\n<21> printf("%s\n", buffer);\n<25> av_dict_parse_string(&dict, buffer, vals, pairs, 0);
<1> qcrypto_block_luks_create(QCryptoBlock *block,\n<21> uint8_t *masterkey = NULL;\n<23> uint8_t *slotkey = NULL;\n<55> memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n<117> if (!password) {\n<131> memcpy(luks->header.magic, qcrypto_block_luks_magic,\n<155> if (!cipher_alg) {\n<171> cipher_mode_spec = g_strdup_printf("%s-%s:%s", cipher_mode, ivgen_alg,\n<177> cipher_mode_spec = g_strdup_printf("%s-%s", cipher_mode, ivgen_alg);\n<181> hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];\n<187> if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n<189> error_setg(errp, "Cipher name '%s' is too long for LUKS header",\n<197> if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n<199> error_setg(errp, "Cipher mode '%s' is too long for LUKS header",\n<207> if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n<209> error_setg(errp, "Hash name '%s' is too long for LUKS header",\n<219> if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n<243> strcpy(luks->header.cipher_name, cipher_alg);\n<245> strcpy(luks->header.cipher_mode, cipher_mode_spec);\n<247> strcpy(luks->header.hash_spec, hash_alg);\n<251> luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n<255> luks->header.key_bytes *= 2;\n<455> splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n<491> if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n<511> (uint8_t *)password, strlen(password),\n<551> if (iters > UINT32_MAX) {\n<583> (uint8_t *)password, strlen(password),\n<747> cpu_to_be32s(&luks->header.key_bytes);\n<773> (const uint8_t *)&luks->header,\n<795> be32_to_cpus(&luks->header.key_bytes);\n<859> memset(masterkey, 0, luks->header.key_bytes);\n<861> g_free(masterkey);\n<863> memset(slotkey, 0, luks->header.key_bytes);\n<865> g_free(slotkey);\n<869> g_free(password);\n<887> if (masterkey) {\n<889> memset(masterkey, 0, luks->header.key_bytes);\n<893> g_free(masterkey);\n<895> if (slotkey) {\n<897> memset(slotkey, 0, luks->header.key_bytes);\n<901> g_free(slotkey);\n<903> g_free(splitkey);\n<905> g_free(password);\n<907> g_free(cipher_mode_spec);\n<911> qcrypto_ivgen_free(ivgen);\n<913> qcrypto_cipher_free(cipher);\n<917> g_free(luks);\n<919> return -1;
<1> static int ffserver_parse_config_stream(FFServerConfig *config, const char *cmd, const char **p,\n<29> if (!stream)\n<35> q = strrchr(stream->filename, '>');\n<43> for (s = config->first_stream; s; s = s->next) {\n<45> if (!strcmp(stream->filename, s->filename))\n<47> ERROR("Stream '%s' already registered\n", s->filename);\n<53> stream->fmt = ffserver_guess_format(NULL, stream->filename, NULL);\n<81> ffserver_get_arg(arg, sizeof(arg), p);\n<83> sfeed = config->first_feed;\n<85> while (sfeed) {\n<87> if (!strcmp(sfeed->filename, arg))\n<91> sfeed = sfeed->next_feed;\n<95> if (!sfeed)\n<97> ERROR("Feed with name '%s' for stream '%s' is not defined\n", arg, stream->filename);\n<101> stream->feed = sfeed;\n<103> } else if (!av_strcasecmp(cmd, "Format")) {\n<105> ffserver_get_arg(arg, sizeof(arg), p);\n<107> if (!strcmp(arg, "status")) {\n<109> stream->stream_type = STREAM_TYPE_STATUS;\n<111> stream->fmt = NULL;\n<115> stream->stream_type = STREAM_TYPE_LIVE;\n<119> if (!strcmp(arg, "jpeg"))\n<121> strcpy(arg, "mjpeg");\n<123> stream->fmt = ffserver_guess_format(arg, NULL, NULL);\n<125> if (!stream->fmt)\n<159> } else if (!av_strcasecmp(cmd, "Author")    ||\n<161> !av_strcasecmp(cmd, "Comment")   ||\n<163> !av_strcasecmp(cmd, "Copyright") ||\n<165> !av_strcasecmp(cmd, "Title")) {\n<173> for (i = 0; i < strlen(cmd); i++)\n<175> key[i] = av_tolower(cmd[i]);\n<179> WARNING("'%s' option in configuration file is deprecated, "\n<265> } else if (!av_strcasecmp(cmd, "VideoBitRateRange")) {\n<269> ffserver_get_arg(arg, sizeof(arg), p);\n<271> if (sscanf(arg, "%d-%d", &minrate, &maxrate) == 2) {\n<273> if (av_dict_set_int(&config->video_conf, "VideoBitRateRangeMin", minrate, 0) < 0 ||\n<275> av_dict_set_int(&config->video_conf, "VideoBitRateRangeMax", maxrate, 0) < 0)\n<281> ERROR("Incorrect format for VideoBitRateRange -- should be <min>-<max>: %s\n", arg);\n<469> } else if (!av_strcasecmp(cmd, "VideoTag")) {\n<471> ffserver_get_arg(arg, sizeof(arg), p);\n<473> if (strlen(arg) == 4) {\n<475> if (av_dict_set(&config->video_conf, "VideoTag", "arg", 0) < 0)\n<613> } else if (!av_strcasecmp(cmd, "</Stream>")) {\n<615> if (stream->feed && stream->fmt && strcmp(stream->fmt->name, "ffm") != 0) {\n<617> if (config->audio_id != AV_CODEC_ID_NONE) {\n<637> if (config->video_id != AV_CODEC_ID_NONE) {\n<683> return 0;
<1> static int evrc_decode_frame(AVCodecContext *avctx, void *data,\n<11> EVRCContext *e     = avctx->priv_data;\n<25> if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n<45> if (e->bitrate == RATE_QUANT && e->last_valid_bitrate == RATE_FULL\n<55> memset(&e->frame, 0, sizeof(EVRCAFrame));\n<65> uint8_t *p = (uint8_t *) &e->frame;\n<91> if (decode_lspf(e) < 0)\n<135> memcpy(e->pitch, e->pitch_back, ACB_SIZE * sizeof(float));\n<151> for (i = 0; i < NB_SUBFRAMES; i++) {\n<159> acb_excitation(e, e->pitch + ACB_SIZE, e->avg_acb_gain, idelay, subframe_size);\n<161> memcpy(e->pitch, e->pitch + subframe_size, ACB_SIZE * sizeof(float));\n<197> for (i = 0; i < NB_SUBFRAMES; i++) {\n<207> interpolate_lsp(ilspf, e->lspf, e->prev_lspf, i);\n<249> acb_excitation(e, e->pitch + ACB_SIZE,\n<261> for (j = 0; j < subframe_size; j++)\n<263> e->pitch[ACB_SIZE + j] += f * tmp[j];\n<269> for (j = 0; j < subframe_size; j++)\n<271> e->pitch[ACB_SIZE + j] = e->energy_vector[i];\n<277> memcpy(e->pitch, e->pitch + subframe_size, ACB_SIZE * sizeof(float));\n<281> synthesis_filter(e->pitch + ACB_SIZE, ilpc,\n<305> frame_erasure(e, samples);\n<311> memcpy(e->prev_lspf, e->lspf, sizeof(e->prev_lspf));
<1> static int parse_object_segment(AVCodecContext *avctx,\n<29> id = bytestream_get_be16(&buf);\n<33> if (!object) {\n<43> object = &ctx->objects.object[ctx->objects.count++];\n<53> buf += 1;\n<59> sequence_desc = bytestream_get_byte(&buf);\n<67> if (buf_size > object->rle_remaining_len)\n<73> memcpy(object->rle + object->rle_data_len, buf, buf_size);\n<75> object->rle_data_len += buf_size;\n<77> object->rle_remaining_len -= buf_size;\n<97> rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n<101> if (buf_size > rle_bitmap_len) {\n<117> width  = bytestream_get_be16(&buf);\n<119> height = bytestream_get_be16(&buf);\n<141> av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);\n<145> if (!object->rle)\n<151> memcpy(object->rle, buf, buf_size);\n<153> object->rle_data_len = buf_size;\n<155> object->rle_remaining_len = rle_bitmap_len - buf_size;
<1> static int asf_probe(AVProbeData *pd)\n<7> if (pd->buf_size <= 32)\n<13> if (!memcmp(pd->buf, &asf_header, sizeof(GUID)))\n<15> return AVPROBE_SCORE_MAX;\n<19> return 0;
<1> static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vstream, const char *key, unsigned int max_pos, int depth) {\n<129> if(depth == 1 && key) { //only look for metadata values when we are not nested and key != NULL\n<131> acodec = astream ? astream->codec : NULL;\n<133> vcodec = vstream ? vstream->codec : NULL;\n<137> if(amf_type == AMF_DATA_TYPE_BOOL) {\n<139> if(!strcmp(key, "stereo") && acodec) acodec->channels = num_val > 0 ? 2 : 1;\n<141> } else if(amf_type == AMF_DATA_TYPE_NUMBER) {\n<143> if(!strcmp(key, "duration")) s->duration = num_val * AV_TIME_BASE;\n<149> else if(!strcmp(key, "audiocodecid") && acodec) flv_set_audio_codec(s, astream, (int)num_val << FLV_AUDIO_CODECID_OFFSET);\n<151> else if(!strcmp(key, "videocodecid") && vcodec) flv_set_video_codec(s, vstream, (int)num_val);\n<153> else if(!strcmp(key, "audiosamplesize") && acodec && num_val >= 0) {\n<155> acodec->bits_per_sample = num_val;\n<159> if(num_val == 8 && (acodec->codec_id == CODEC_ID_PCM_S16BE || acodec->codec_id == CODEC_ID_PCM_S16LE))\n<165> else if(!strcmp(key, "audiosamplerate") && acodec && num_val >= 0) {\n<169> if (!acodec->sample_rate) {
<1> int qemu_fsdev_add(QemuOpts *opts)\n<11> if (qemu_opts_id(opts) == NULL) {\n<13> fprintf(stderr, "fsdev: No id specified\n");\n<21> for (i = 0; i < ARRAY_SIZE(FsTypes); i++) {\n<23> if (strcmp(FsTypes[i].name, qemu_opt_get(opts, "fstype")) == 0) {\n<33> if (i == ARRAY_SIZE(FsTypes)) {\n<35> fprintf(stderr, "fsdev: fstype %s not found\n",\n<37> qemu_opt_get(opts, "fstype"));
<1> static unsigned int dec_abs_r(DisasContext *dc)\n<13> cris_cc_mask(dc, CC_MASK_NZ);
<1> static int decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<141> if (keyframe && c->pic.data[0])\n<169> switch (comptype) {\n<203> memset(c->pic.data[0], 0, c->width * c->height);\n<205> memset(c->pic.data[1], 128, c->width * c->height / 4);\n<207> memset(c->pic.data[2], 128, c->width * c->height / 4);
<1> static int fbdev_read_packet(AVFormatContext *avctx, AVPacket *pkt)\n<5> FBDevContext *fbdev = avctx->priv_data;\n<67> if (ioctl(fbdev->fd, FBIOGET_VSCREENINFO, &fbdev->varinfo) < 0)\n<71> "Error refreshing variable info: %s\n", strerror(errno));\n<81> pin = fbdev->data + fbdev->bytes_per_pixel * fbdev->varinfo.xoffset +\n<85> pout = pkt->data;\n<89> for (i = 0; i < fbdev->heigth; i++) {\n<91> memcpy(pout, pin, fbdev->frame_linesize);\n<93> pin  += fbdev->fixinfo.line_length;\n<95> pout += fbdev->frame_linesize;
<1> static void preprocess_text_hangul ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , hb_font_t * font ) {\n<13> if ( ! is_zero_width_char ( font , u ) ) {\n<14> hb_glyph_info_t * info = buffer -> out_info ;\n<16> memmove ( & info [ start + 1 ] , & info [ start ] , ( end - start ) * sizeof ( hb_glyph_info_t ) ) ;\n<17> info [ start ] = tone ;
<1> static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n<2> hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n<3> if ( unlikely ( ! c ) ) return NULL ;
<1> int crypto_authenticate_and_decrypt ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n<35> if ( decrypt_nss_2_3 ( instance , buf , buf_len ) != 0 ) {\n<39> memmove ( buf , buf + sizeof ( struct crypto_config_header ) , * buf_len ) ;
<1> static int process_input(int file_index)\n<259> AVPacketSideData *src_sd = &ist->st->side_data[i];\n<269> if (ist->autorotate && src_sd->type == AV_PKT_DATA_DISPLAYMATRIX)\n<275> dst_data = av_packet_new_side_data(&pkt, src_sd->type, src_sd->size);\n<277> if (!dst_data)\n<283> memcpy(dst_data, src_sd->data, src_sd->size);
<1> static int n8x0_atag_setup(void *p, int model)\n<127> stb_p(b++, BT_UART + 1);			/* u8 bt_uart */\n<129> memcpy(b, &n8x0_bd_addr, 6);		/* u8 bd_addr[6] */\n<131> b += 6;
<1> static int synth_superframe ( AVCodecContext * ctx , AVFrame * frame , int * got_frame_ptr ) {\n<2> WMAVoiceContext * s = ctx -> priv_data ;\n<5> double lsps [ MAX_FRAMES ] [ MAX_LSPS ] ;\n<7> float excitation [ MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12 ] ;\n<8> float synth [ MAX_LSPS + MAX_SFRAMESIZE ] ;\n<10> memcpy ( synth , s -> synth_history , s -> lsps * sizeof ( * synth ) ) ;\n<11> memcpy ( excitation , s -> excitation_history , s -> history_nsamples * sizeof ( * excitation ) ) ;\n<17> if ( ( res = check_bits_for_superframe ( gb , s ) ) == 1 ) {\n<35> n ++ ) prev_lsps [ n ] = s -> prev_lsps [ n ] - mean_lsf [ n ] ;\n<37> dequant_lsp10r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n<39> else dequant_lsp16r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n<45> lsps [ 2 ] [ n ] += mean_lsf [ n ] ;\n<59> n < 3 ;\n<72> if ( ( res = synth_frame ( ctx , gb , n , & samples [ n * MAX_FRAMESIZE ] , lsps [ n ] , n == 0 ? s -> prev_lsps : lsps [ n - 1 ] , & excitation [ s -> history_nsamples + n * MAX_FRAMESIZE ] , & synth [ s -> lsps + n * MAX_FRAMESIZE ] ) ) ) {\n<82> memcpy ( s -> prev_lsps , lsps [ 2 ] , s -> lsps * sizeof ( * s -> prev_lsps ) ) ;\n<83> memcpy ( s -> synth_history , & synth [ MAX_SFRAMESIZE ] , s -> lsps * sizeof ( * synth ) ) ;\n<84> memcpy ( s -> excitation_history , & excitation [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * excitation ) ) ;\n<85> if ( s -> do_apf ) memmove ( s -> zero_exc_pf , & s -> zero_exc_pf [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * s -> zero_exc_pf ) ) ;
<1> static int raw_decode(AVCodecContext *avctx,\n<125> frame->data[1]= context->palette;\n<131> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<135> if (pal) {\n<137> memcpy(frame->data[1], pal, AVPALETTE_SIZE);
<1> int ff_h263_decode_frame(AVCodecContext *avctx,\n<9> const uint8_t *buf = avpkt->data;\n<77> next= ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);\n<81> next= ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n<113> init_get_bits(&s->gb, buf, buf_size*8);\n<591> if (avctx->hwaccel->start_frame(avctx, buf, buf_size) < 0)\n<635> decode_slice(s);\n<647> if(ff_h263_resync(s)<0)\n<661> decode_slice(s);\n<669> if(!CONFIG_MSMPEG4_DECODER || msmpeg4_decode_ext_header(s, buf_size) < 0){\n<693> if(buf[i]==0 && buf[i+1]==0 && buf[i+2]==1 && buf[i+3]==0xB6){\n<723> buf_size - current_pos + FF_INPUT_BUFFER_PADDING_SIZE);\n<725> if (!s->bitstream_buffer)\n<729> memcpy(s->bitstream_buffer, buf + current_pos, buf_size - current_pos);\n<741> ff_er_frame_end(s);\n<755> MPV_frame_end(s);\n<779> ff_print_debug_info(s, pict);\n<801> return get_consumed_bytes(s, buf_size);
<1> static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n<47> if (ret < 0) {\n<57> memset(&cow_header, 0, sizeof(cow_header));\n<91> ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));
<1> static void rtas_ibm_configure_connector(PowerPCCPU *cpu,\n<113> switch (tag) {\n<119> name = fdt_get_name(drc->fdt, ccs->fdt_offset, NULL);\n<129> configure_connector_st(wa_addr, wa_offset, name, strlen(name) + 1);\n<173> name = fdt_string(drc->fdt, fdt32_to_cpu(prop->nameoff));\n<183> configure_connector_st(wa_addr, wa_offset, name, strlen(name) + 1);\n<195> wa_offset += strlen(name) + 1,\n<197> rtas_st(wa_addr, CC_IDX_PROP_LEN, prop_len);\n<199> rtas_st(wa_addr, CC_IDX_PROP_DATA_OFFSET, wa_offset);
<1> static int parallels_create(const char *filename, QemuOpts *opts, Error **errp)\n<59> if (ret < 0) {\n<77> memset(&header, 0, sizeof(header));\n<79> memcpy(header.magic, HEADER_MAGIC2, sizeof(header.magic));\n<81> header.version = cpu_to_le32(HEADER_VERSION);\n<85> header.heads = cpu_to_le32(16);\n<87> header.cylinders = cpu_to_le32(total_size / BDRV_SECTOR_SIZE / 16 / 32);\n<89> header.tracks = cpu_to_le32(cl_size >> BDRV_SECTOR_BITS);\n<91> header.catalog_entries = cpu_to_le32(cat_entries);\n<93> header.nb_sectors = cpu_to_le64(DIV_ROUND_UP(total_size, BDRV_SECTOR_SIZE));\n<95> header.data_off = cpu_to_le32(cat_sectors);\n<101> memset(tmp, 0, sizeof(tmp));\n<103> memcpy(tmp, &header, sizeof(header));\n<107> ret = bdrv_pwrite(file, 0, tmp, BDRV_SECTOR_SIZE);
<1> static int pci_ivshmem_init(PCIDevice *dev)\n<35> fprintf(stderr, "ivshmem: ioeventfd/irqfd requires MSI\n");\n<51> } else if (strncmp(s->role, "master", 7) == 0) {\n<57> fprintf(stderr, "ivshmem: 'role' must be 'peer' or 'master'\n");\n<129> if (s->shmobj != NULL) {\n<131> fprintf(stderr, "WARNING: do not specify both 'chardev' "\n<189> if (s->shmobj == NULL) {\n<191> fprintf(stderr, "Must specify 'chardev' or 'shm' to ivshmem\n");\n<211> if (ftruncate(fd, s->ivshmem_size) != 0) {\n<213> fprintf(stderr, "ivshmem: could not truncate shared file\n");\n<223> fprintf(stderr, "ivshmem: could not open shared file\n");
<1> bool is_valid_option_list(const char *param)\n<5> size_t buflen = strlen(param) + 1;\n<7> char *buf = g_malloc(buflen);\n<9> const char *p = param;\n<17> p = get_opt_value(buf, buflen, p);\n<29> if (!*buf || *buf == ',') {\n<43> free(buf);
<1> static int fic_decode_frame(AVCodecContext *avctx, void *data,\n<7> FICContext *ctx = avctx->priv_data;\n<9> uint8_t *src = avpkt->data;\n<35> if (avpkt->size < FIC_HEADER_SIZE + 4) {\n<47> if (memcmp(src, fic_header, 7))\n<49> av_log(avctx, AV_LOG_WARNING, "Invalid FIC Header.\n");\n<61> nslices = src[13];\n<81> tsize = AV_RB24(src + 24);\n<105> sdata = src + tsize + FIC_HEADER_SIZE + 4 * nslices;\n<141> av_fast_malloc(&ctx->slice_data, &ctx->slice_data_size,\n<145> if (!ctx->slice_data_size) {\n<153> memset(ctx->slice_data, 0, nslices * sizeof(ctx->slice_data[0]));\n<159> unsigned slice_off = AV_RB32(src + tsize + FIC_HEADER_SIZE + slice * 4);\n<185> slice_size = AV_RB32(src + tsize + FIC_HEADER_SIZE + slice * 4 + 4);\n<213> if (ret = avctx->execute(avctx, fic_decode_slice, ctx->slice_data,
<1> static int libopenjpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<213> len = cio_tell(stream);\n<215> if ((ret = ff_alloc_packet2(avctx, pkt, len)) < 0) {\n<223> memcpy(pkt->data, stream->buffer, len);
<1> static void rtsp_cmd_setup(HTTPContext *c, const char *url,\n<31> path = path1;\n<33> if (*path == '/')\n<35> path++;\n<41> for(stream = first_stream; stream != NULL; stream = stream->next) {\n<43> if (!stream->is_feed && stream->fmt == &rtp_mux) {\n<47> if (!strcmp(path, stream->filename)) {\n<49> if (stream->nb_streams != 1) {\n<65> for(stream_index = 0; stream_index < stream->nb_streams;\n<67> stream_index++) {\n<73> if (!strcmp(path, buf))\n<95> if (h->session_id[0] == '\0') {\n<107> rtp_c = find_rtp_session(h->session_id);\n<109> if (!rtp_c) {\n<131> rtp_c = rtp_new_connection(&c->from_addr, stream, h->session_id,\n<163> if (rtp_c->stream != stream) {
<1> void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)\n<9> static char prev[LINE_SZ];\n<47> snprintf(line, sizeof(line), "%s%s%s%s", part[0].str, part[1].str, part[2].str, part[3].str);\n<61> if (print_prefix && (flags & AV_LOG_SKIP_REPEATED) && !strcmp(line, prev) &&\n<63> *line && line[strlen(line) - 1] != '\r'){\n<65> count++;\n<67> if (is_atty == 1)\n<69> fprintf(stderr, "    Last message repeated %d times\r", count);\n<75> if (count > 0) {\n<77> fprintf(stderr, "    Last message repeated %d times\n", count);\n<83> strcpy(prev, line);
<1> static void virtio_input_handle_sts(VirtIODevice *vdev, VirtQueue *vq)\n<17> while (virtqueue_pop(vinput->sts, &elem)) {\n<19> memset(&event, 0, sizeof(event));\n<27> vic->handle_status(vinput, &event);
<1> int rtp_parse_packet(RTPDemuxContext *s, AVPacket *pkt,\n<71> if ((buf[0] & 0xc0) != (RTP_VERSION << 6))\n<83> payload_type = buf[1] & 0x7f;\n<85> seq  = (buf[2] << 8) | buf[3];\n<123> buf += 12;\n<131> ret = mpegts_parse_packet(s->ts, pkt, buf, len);\n<137> if (ret < len) {\n<139> s->read_buf_size = len - ret;\n<141> memcpy(s->buf, buf + ret, s->read_buf_size);\n<159> if (len <= 4)\n<167> buf += 4;\n<169> av_new_packet(pkt, len);\n<171> memcpy(pkt->data, buf, len);\n<185> buf += 4;\n<189> if (h & (1 << 26)) {\n<193> if (len <= 4)\n<197> buf += 4;\n<203> av_new_packet(pkt, len);\n<205> memcpy(pkt->data, buf, len);\n<225> if (infos == NULL)\n<229> buf += infos->au_headers_length_bytes + 2;\n<239> av_new_packet(pkt, infos->au_headers[0].size);\n<241> memcpy(pkt->data, buf, infos->au_headers[0].size);\n<243> buf += infos->au_headers[0].size;\n<245> len -= infos->au_headers[0].size;\n<259> if(s->parse_packet) {\n<265> av_new_packet(pkt, len);\n<267> memcpy(pkt->data, buf, len);\n<279> finalize_packet(s, pkt, timestamp);
<1> int av_dict_set(AVDictionary **pm, const char *key, const char *value,\n<11> char *oldval = NULL, *copy_key = NULL, *copy_value = NULL;\n<25> copy_value = (void *)value;\n<29> copy_value = av_strdup(value);\n<35> if (!m || (key && !copy_key) || (value && !copy_value))\n<85> if (oldval && flags & AV_DICT_APPEND) {\n<87> size_t len = strlen(oldval) + strlen(copy_value) + 1;\n<89> char *newval = av_mallocz(len);\n<95> av_strlcat(newval, oldval, len);\n<99> av_strlcat(newval, copy_value, len);\n<141> av_free(copy_value);
<1> void mips_r4k_init (ram_addr_t ram_size,\n<57> if (!env) {\n<59> fprintf(stderr, "Unable to find CPU definition\n");\n<77> if (ram_size > (256 << 20)) {\n<83> ((unsigned int)ram_size / (1 << 20)));\n<115> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<151> } else if ((dinfo = drive_get(IF_PFLASH, 0, 0)) != NULL) {\n<155> if (!pflash_cfi01_register(0x1fc00000, NULL, "mips_r4k.bios", mips_rom,\n<163> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<173> fprintf(stderr, "qemu: Warning, could not load MIPS bios '%s'\n",
<1> static gboolean logcat_read_packet ( struct logcat_phdr * logcat , FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n<7> bytes_read = file_read ( & tmp , 2 , fh ) ;\n<13> payload_length = pletoh16 ( tmp ) ;\n<14> if ( logcat -> version == 1 ) {\n<17> else if ( logcat -> version == 2 ) {\n<24> pd = buffer_start_ptr ( buf ) ;\n<25> memcpy ( pd , tmp , 2 ) ;\n<26> bytes_read = file_read ( pd + 2 , packet_size - 2 , fh ) ;\n<34> phdr -> ts . secs = ( time_t ) pletoh32 ( pd + 12 ) ;\n<35> phdr -> ts . nsecs = ( int ) pletoh32 ( pd + 16 ) ;
<1> int main(int argc,char* argv[]){\n<25> if(argc<3){\n<27> printf("tiny_psnr <file1> <file2> [<elem size> [<shift> [<skip bytes>]]]\n");\n<29> printf("For WAV files use the following:\n");\n<31> printf("./tiny_psnr file1.wav file2.wav 2 0 44 to skip the header.\n");\n<43> if(!f[0] || !f[1]){\n<45> fprintf(stderr, "Could not open input files.\n");\n<105> printf("stddev:%3d.%02d PSNR:%2d.%02d bytes:%d\n",\n<107> (int)(dev/F), (int)(dev%F),\n<109> (int)(psnr/F), (int)(psnr%F),\n<111> i*len);
<1> static void unix_accept_incoming_migration(void *opaque)\n<29> if (c == -1) {\n<31> fprintf(stderr, "could not accept migration connection\n");\n<41> if (f == NULL) {\n<43> fprintf(stderr, "could not qemu_fopen socket\n");\n<53> if (ret < 0) {\n<55> fprintf(stderr, "load of migration failed\n");
<1> static void opt_qmax(const char *arg)\n<11> fprintf(stderr, "qmax must be >= 1 and <= 31\n");
<1> static COMMANDS * find_command ( char * name ) {\n<6> DBUG_PRINT ( "enter" , ( "name: '%s'" , name ) ) ;\n<7> while ( my_isspace ( charset_info , * name ) ) name ++ ;\n<8> if ( ( ! real_binary_mode && strstr ( name , "\\g" ) ) || ( strstr ( name , delimiter ) && ! is_delimiter_command ( name , DELIMITER_NAME_LEN ) ) ) DBUG_RETURN ( ( COMMANDS * ) 0 ) ;\n<9> if ( ( end = strcont ( name , " \t" ) ) ) {\n<14> else len = ( uint ) strlen ( name ) ;\n<17> if ( is_delimiter_command ( name , len ) ) index = delimiter_index ;\n<23> if ( ! my_strnncoll ( & my_charset_latin1 , ( uchar * ) name , len , ( uchar * ) commands [ i ] . name , len ) && ( commands [ i ] . name [ len ] == '\0' ) && ( ! end || commands [ i ] . takes_params ) ) {
<1> av_cold int MPV_common_init(MpegEncContext *s)\n<9> if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n<11> s->mb_height = (s->height + 31) / 32 * 2;\n<13> else if (s->codec_id != CODEC_ID_H264)\n<15> s->mb_height = (s->height + 15) / 16;\n<29> if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) &&\n<31> (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){\n<49> ff_dct_common_init(s);\n<53> s->flags= s->avctx->flags;\n<55> s->flags2= s->avctx->flags2;\n<67> s->b4_stride = s->mb_width*4 + 1;\n<85> s->h_edge_pos= s->mb_width*16;\n<87> s->v_edge_pos= s->mb_height*16;\n<91> s->mb_num = s->mb_width * s->mb_height;\n<109> y_size = s->b8_stride * (2 * s->mb_height + 1);\n<119> s->codec_tag = ff_toupper4(s->avctx->codec_tag);\n<123> s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag);\n<131> FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) //error ressilience code looks cleaner with this\n<143> s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; //FIXME really needed?\n<151> FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base            , mv_table_size * 2 * sizeof(int16_t), fail)\n<153> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n<155> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n<157> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n<159> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n<161> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base     , mv_table_size * 2 * sizeof(int16_t), fail)\n<163> s->p_mv_table           = s->p_mv_table_base            + s->mb_stride + 1;\n<165> s->b_forw_mv_table      = s->b_forw_mv_table_base       + s->mb_stride + 1;\n<167> s->b_back_mv_table      = s->b_back_mv_table_base       + s->mb_stride + 1;\n<169> s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n<171> s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n<173> s->b_direct_mv_table    = s->b_direct_mv_table_base     + s->mb_stride + 1;\n<179> FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail);\n<189> FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type  , mb_array_size * sizeof(uint16_t), fail) //needed for encoding\n<193> FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)\n<197> FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix  , 64*32   * sizeof(int), fail)\n<199> FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix  , 64*32   * sizeof(int), fail)\n<201> FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n<203> FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n<205> FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n<207> FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n<213> FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail)\n<225> FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail)\n<227> for(i = 0; i < s->picture_count; i++) {\n<235> if (s->width && s->height) {\n<237> FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail)\n<241> if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){\n<273> if (s->out_format == FMT_H263) {\n<277> FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size, fail);\n<279> s->coded_block= s->coded_block_base + s->b8_stride + 1;\n<285> FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail)\n<287> FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail)\n<293> if (s->h263_pred || s->h263_plus || !s->encoding) {\n<299> FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);\n<317> FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n<319> memset(s->mbintra_table, 1, mb_array_size);\n<325> FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail);\n<329> FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);\n<341> s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n<349> s->context_initialized = 1;\n<351> s->thread_context[0]= s;\n<355> if (s->width && s->height) {\n<357> if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) {\n<363> for(i=1; i<threads; i++){\n<365> s->thread_context[i]= av_malloc(sizeof(MpegEncContext));\n<367> memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n<375> if(init_duplicate_context(s->thread_context[i], s) < 0)\n<387> if(init_duplicate_context(s, s) < 0) goto fail;\n<403> MPV_common_end(s);
<1> static int decode_header(SnowContext *s){\n<9> memset(kstate, MID_STATE, sizeof(kstate));\n<13> s->keyframe= get_rac(&s->c, kstate);\n<85> for(plane_index=0; plane_index<2; plane_index++){\n<117> memcpy(s->plane[2].hcoeff, s->plane[1].hcoeff, sizeof(s->plane[1].hcoeff));
<1> static void kvm_supported_msrs(CPUState *env)\n<31> if (ret < 0 && ret != -E2BIG) {\n<49> kvm_msr_list->nmsrs = msr_list.nmsrs;\n<51> ret = kvm_ioctl(env->kvm_state, KVM_GET_MSR_INDEX_LIST, kvm_msr_list);\n<59> for (i = 0; i < kvm_msr_list->nmsrs; i++) {\n<83> free(kvm_msr_list);
<1> nand_write(void *opaque, target_phys_addr_t addr, uint64_t value,\n<13> DNAND(printf("%s addr=%x v=%x\n", __func__, addr, (unsigned)value));
<1> sosendoob(struct socket *so)\n<5> struct sbuf *sb = &so->so_rcv;\n<7> char buff[2048]; /* XXX Shouldn't be sending more oob data than this */\n<29> if (sb->sb_rptr < sb->sb_wptr) {\n<53> len = (sb->sb_data + sb->sb_datalen) - sb->sb_rptr;\n<55> if (len > so->so_urgc) len = so->so_urgc;\n<57> memcpy(buff, sb->sb_rptr, len);\n<59> so->so_urgc -= len;\n<61> if (so->so_urgc) {\n<63> n = sb->sb_wptr - sb->sb_data;\n<65> if (n > so->so_urgc) n = so->so_urgc;\n<67> memcpy((buff + len), sb->sb_data, n);\n<69> so->so_urgc -= n;\n<71> len += n;\n<75> n = slirp_send(so, buff, len, (MSG_OOB)); /* |MSG_DONTWAIT)); */\n<93> sb->sb_rptr += n;\n<95> if (sb->sb_rptr >= (sb->sb_data + sb->sb_datalen))
<1> static int vfio_base_device_init(VFIODevice *vbasedev)\n<23> if (!vbasedev->name || strchr(vbasedev->name, '/')) {\n<25> return -EINVAL;\n<33> g_snprintf(path, sizeof(path), "/sys/bus/platform/devices/%s/",\n<35> vbasedev->name);\n<39> if (stat(path, &st) < 0) {\n<49> g_strlcat(path, "iommu_group", sizeof(path));\n<51> len = readlink(path, iommu_group_path, sizeof(iommu_group_path));\n<53> if (len < 0 || len >= sizeof(iommu_group_path)) {\n<65> group_name = basename(iommu_group_path);\n<69> if (sscanf(group_name, "%d", &groupid) != 1) {\n<71> error_report("vfio: error reading %s: %m", path);\n<73> return -errno;\n<79> trace_vfio_platform_base_device_init(vbasedev->name, groupid);\n<83> group = vfio_get_group(groupid, &address_space_memory);\n<85> if (!group) {\n<87> error_report("vfio: failed to get group %d", groupid);\n<95> g_snprintf(path, sizeof(path), "%s", vbasedev->name);\n<99> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {\n<101> if (strcmp(vbasedev_iter->name, vbasedev->name) == 0) {\n<103> error_report("vfio: error: device %s is already attached", path);\n<105> vfio_put_group(group);\n<107> return -EBUSY;\n<113> ret = vfio_get_device(group, path, vbasedev);\n<115> if (ret) {\n<127> ret = vfio_populate_device(vbasedev);
<1> static void * size_checked_malloc ( size_t size ) {\n<2> if ( size > MAX_LIBXML_MALLOC ) {\n<6> return malloc ( size ) ;
<1> static void dump_table ( char * table , char * db ) {\n<14> num_fields = get_table_structure ( table , db , table_type , & ignore_flag ) ;\n<15> if ( strcmp ( table_type , "VIEW" ) == 0 ) DBUG_VOID_RETURN ;\n<22> verbose_msg ( "-- Warning: Skipping data for table '%s' because " "it's of type %s\n" , table , table_type ) ;\n<75> dynstr_append_checked ( & query_string , result_table ) ;\n<101> if ( mysql_num_fields ( res ) != num_fields ) {\n<102> fprintf ( stderr , "%s: Error in field count for table: %s ! Aborting.\n" , my_progname_short , result_table ) ;
<1> int qcow2_update_header(BlockDriverState *bs)\n<5> BDRVQcowState *s = bs->opaque;\n<25> buf = qemu_blockalign(bs, buflen);\n<103> switch (s->qcow_version) {\n<127> buf += ret;\n<129> buflen -= ret;\n<131> memset(buf, 0, buflen);\n<139> if (buflen < s->unknown_header_fields_size) {\n<149> memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);\n<151> buf += s->unknown_header_fields_size;\n<153> buflen -= s->unknown_header_fields_size;\n<161> if (*bs->backing_format) {\n<163> ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n<165> bs->backing_format, strlen(bs->backing_format),\n<223> ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n<273> buf += ret;\n<281> if (*bs->backing_file) {\n<283> size_t backing_file_len = strlen(bs->backing_file);\n<287> if (buflen < backing_file_len) {\n<299> strncpy(buf, bs->backing_file, buflen);\n<303> header->backing_file_offset = cpu_to_be64(buf - ((char*) header));
<1> static int decode_13 ( AVCodecContext * avctx , DxaDecContext * c , uint8_t * dst , uint8_t * src , uint8_t * ref ) {\n<8> data = code + ( ( avctx -> width * avctx -> height ) >> 4 ) ;\n<17> tmp = dst + i ;\n<18> tmp2 = ref + i ;\n<25> tmp2 += x + y * stride ;\n<27> y < 4 ;\n<29> memcpy ( tmp , tmp2 , 4 ) ;\n<30> tmp += stride ;\n<31> tmp2 += stride ;\n<49> tmp [ x ] = ( mask & 0x8000 ) ? * data ++ : tmp2 [ x ] ;\n<53> tmp2 += stride ;\n<57> y < 4 ;\n<59> memset ( tmp , data [ 0 ] , 4 ) ;\n<60> tmp += stride ;\n<62> data ++ ;\n<65> y < 4 ;\n<67> memcpy ( tmp , data , 4 ) ;\n<68> data += 4 ;\n<69> tmp += stride ;\n<78> tmp2 = ref + i + d2 ;\n<84> tmp2 += x + y * stride ;\n<85> case 0x00 : tmp [ d + 0 ] = tmp2 [ 0 ] ;\n<86> tmp [ d + 1 ] = tmp2 [ 1 ] ;\n<87> tmp [ d + 0 + stride ] = tmp2 [ 0 + stride ] ;\n<88> tmp [ d + 1 + stride ] = tmp2 [ 1 + stride ] ;\n<90> case 0x40 : tmp [ d + 0 ] = data [ 0 ] ;\n<91> tmp [ d + 1 ] = data [ 0 ] ;\n<92> tmp [ d + 0 + stride ] = data [ 0 ] ;\n<93> tmp [ d + 1 + stride ] = data [ 0 ] ;\n<94> data ++ ;\n<96> case 0xC0 : tmp [ d + 0 ] = * data ++ ;\n<97> tmp [ d + 1 ] = * data ++ ;\n<98> tmp [ d + 0 + stride ] = * data ++ ;\n<99> tmp [ d + 1 + stride ] = * data ++ ;\n<113> tmp [ x ] = data [ mask & 1 ] ;\n<119> data += 2 ;\n<129> tmp [ x ] = data [ mask & 3 ] ;\n<135> data += type - 30 ;
<1> static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,\n<3> const uint8_t *buf, int size, int64_t pts)\n<11> StreamInfo *stream = st->priv_data;\n<17> while (size > 0) {\n<27> len = s->packet_data_max_size - stream->buffer_ptr;\n<29> if (len > size)\n<31> len = size;\n<33> memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n<35> stream->buffer_ptr += len;\n<37> buf += len;\n<39> size -= len;
<1> static int mov_write_header(AVFormatContext *s)\n<25> if (s->oformat) {\n<27> if (!strcmp("3gp", s->oformat->name)) mov->mode = MODE_3GP;\n<29> else if (!strcmp("3g2", s->oformat->name)) mov->mode = MODE_3GP|MODE_3G2;\n<31> else if (!strcmp("mov", s->oformat->name)) mov->mode = MODE_MOV;\n<33> else if (!strcmp("psp", s->oformat->name)) mov->mode = MODE_PSP;\n<35> else if (!strcmp("ipod",s->oformat->name)) mov->mode = MODE_IPOD;\n<37> else if (!strcmp("ismv",s->oformat->name)) mov->mode = MODE_ISM;\n<39> else if (!strcmp("f4v", s->oformat->name)) mov->mode = MODE_F4V;\n<297> track->st  = st;\n<299> track->enc = st->codec;\n<309> track->tag  = mov_find_codec_tag(s, track);\n<491> avpriv_set_pts_info(st, 64, 1, track->timescale);\n<501> mov_create_dvd_sub_decoder_specific_info(track, st);\n<507> track->vos_data = av_malloc(track->vos_len);\n<509> if (!track->vos_data) {\n<517> memcpy(track->vos_data, st->codec->extradata, track->vos_len);
<1> static int usb_hub_handle_control(USBDevice *dev, USBPacket *p,\n<13> ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n<23> switch(request) {
<1> static void omap_pwl_update(struct omap_pwl_s *s)\n<9> if (output != s->output) {\n<13> printf("%s: Backlight now at %i/256\n", __FUNCTION__, output);
<1> static void vfio_realize(PCIDevice *pdev, Error **errp)\n<53> if (stat(vdev->vbasedev.sysfsdev, &st) < 0) {\n<73> tmp = g_strdup_printf("%s/iommu_group", vdev->vbasedev.sysfsdev);\n<75> len = readlink(tmp, group_path, sizeof(group_path));\n<77> g_free(tmp);\n<81> if (len <= 0 || len >= sizeof(group_path)) {\n<97> group_name = basename(group_path);\n<99> if (sscanf(group_name, "%d", &groupid) != 1) {\n<101> error_setg_errno(errp, errno, "failed to read %s", group_path);\n<109> trace_vfio_realize(vdev->vbasedev.name, groupid);\n<113> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);\n<115> if (!group) {\n<123> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {\n<125> if (strcmp(vbasedev_iter->name, vdev->vbasedev.name) == 0) {\n<127> error_setg(errp, "device is already attached");\n<129> vfio_put_group(group);\n<139> ret = vfio_get_device(group, vdev->vbasedev.name, &vdev->vbasedev, errp);\n<141> if (ret) {\n<151> vfio_populate_device(vdev, &err);\n<171> if (ret < (int)MIN(pci_config_size(&vdev->pdev), vdev->config_size)) {\n<185> vdev->emulated_config_bits = g_malloc0(vdev->config_size);\n<191> memset(vdev->emulated_config_bits + PCI_ROM_ADDRESS, 0xff, 4);\n<215> vfio_add_emulated_word(vdev, PCI_VENDOR_ID, vdev->vendor_id, ~0);\n<237> vfio_add_emulated_word(vdev, PCI_DEVICE_ID, vdev->device_id, ~0);\n<259> vfio_add_emulated_word(vdev, PCI_SUBSYSTEM_VENDOR_ID,\n<271> if (vdev->sub_device_id != PCI_ANY_ID) {\n<273> if (vdev->sub_device_id > 0xffff) {\n<281> vfio_add_emulated_word(vdev, PCI_SUBSYSTEM_ID, vdev->sub_device_id, ~0);\n<323> memset(&vdev->pdev.config[PCI_BASE_ADDRESS_0], 0, 24);\n<325> memset(&vdev->pdev.config[PCI_ROM_ADDRESS], 0, 4);\n<329> vfio_pci_size_rom(vdev);\n<333> vfio_msix_early_setup(vdev, &err);\n<345> vfio_bars_setup(vdev);\n<349> ret = vfio_add_capabilities(vdev, errp);\n<361> vfio_vga_quirk_setup(vdev);\n<369> vfio_bar_quirk_setup(vdev, i);\n<415> ret = vfio_pci_igd_opregion_init(vdev, opregion, errp);\n<431> if (pdev->cap_present & QEMU_PCI_CAP_MSIX) {\n<433> memset(vdev->emulated_config_bits + pdev->msix_cap, 0xff,\n<441> if (pdev->cap_present & QEMU_PCI_CAP_MSI) {\n<443> memset(vdev->emulated_config_bits + pdev->msi_cap, 0xff,\n<459> ret = vfio_intx_enable(vdev, errp);\n<471> vfio_register_err_notifier(vdev);\n<473> vfio_register_req_notifier(vdev);\n<475> vfio_setup_resetfn_quirk(vdev);\n<487> vfio_teardown_msi(vdev);\n<489> vfio_bars_exit(vdev);\n<493> error_prepend(errp, ERR_PREFIX, vdev->vbasedev.name);
<1> icmp_input(struct mbuf *m, int hlen)\n<91> if(udp_attach(so) == -1) {\n<95> errno,strerror(errno)));\n<129> addr.sin_family = AF_INET;\n<141> addr.sin_addr = loopback_addr;\n<145> addr.sin_addr = loopback_addr;\n<151> addr.sin_addr = so->so_faddr;\n<155> addr.sin_port = so->so_fport;\n<157> if(sendto(so->s, icmp_ping_msg, strlen(icmp_ping_msg), 0,\n<159> (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n<161> DEBUG_MISC((dfd,"icmp_input udp sendto tx errno = %d-%s\n",\n<163> errno,strerror(errno)));\n<165> icmp_error(m, ICMP_UNREACH,ICMP_UNREACH_NET, 0,strerror(errno));\n<167> udp_detach(so);
<1> static void inline xan_wc3_build_palette(XanContext *s,\n<3> unsigned int *palette_data)\n<25> switch (s->avctx->pix_fmt) {\n<137> palette32 = (unsigned int *)s->palette;\n<139> memcpy (palette32, palette_data, PALETTE_COUNT * sizeof(unsigned int));
<1> static void default_show_tags(WriterContext *wctx, AVDictionary *dict)\n<7> while ((tag = av_dict_get(dict, "", tag, AV_DICT_IGNORE_SUFFIX))) {\n<9> printf("TAG:");
<1> void ff_aac_search_for_pred(AACEncContext *s, SingleChannelElement *sce)\n<17> if (sce->ics.window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n<27> if (!sce->ics.predictor_initialized) {\n<33> memcpy(sce->prcoeffs, sce->coeffs, 1024*sizeof(float));\n<43> update_pred_resets(sce);\n<45> memcpy(sce->band_alt, sce->band_type, sizeof(sce->band_type));\n<77> abs_pow34_v(O34, &sce->coeffs[start_coef], num_coeffs);\n<79> dist1 = quantize_and_encode_band_cost(s, NULL, &sce->coeffs[start_coef], NULL,\n<119> abs_pow34_v(P34, &sce->prcoeffs[start_coef], num_coeffs);\n<129> dist2 = quantize_and_encode_band_cost(s, NULL, &sce->prcoeffs[start_coef], NULL,\n<149> sce->ics.prediction_used[sfb] = 1;\n<169> if (count && cost_coeffs < cost_pred) {\n<175> RESTORE_PRED(sce, sfb);\n<177> memset(&sce->ics.prediction_used, 0, sizeof(sce->ics.prediction_used));
<1> static int msvideo1_decode_frame(AVCodecContext *avctx,\n<13> Msvideo1Context *s = avctx->priv_data;\n<33> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<37> if (pal) {\n<39> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<51> msvideo1_decode_8bit(s);\n<55> msvideo1_decode_16bit(s);
<1> static void lz_unpack(unsigned char *src, unsigned char *dest)\n<9> unsigned char queue[QUEUE_SIZE];\n<35> memset(queue, QUEUE_SIZE, 0x20);\n<101> *d = queue[chainofs++ & QUEUE_MASK];
<1> static void copy_context_after_encode(MpegEncContext *d, MpegEncContext *s, int type){\n<7> memcpy(d->mv, s->mv, 2*4*2*sizeof(int));\n<9> memcpy(d->last_mv, s->last_mv, 2*2*2*sizeof(int)); //FIXME is memcpy faster then a loop?
<1> static int mpc8_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<5> MPCContext * c = avctx -> priv_data ;\n<18> if ( keyframe ) {\n<19> memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n<172> ff_mpc_dequantize_and_synth ( c , maxband - 1 , ( int16_t * * ) frame -> extended_data , avctx -> channels ) ;
<1> static int shorten_decode_frame(AVCodecContext *avctx,\n<9> const uint8_t *buf = avpkt->data;\n<13> ShortenContext *s = avctx->priv_data;\n<43> s->bitstream = tmp_ptr;\n<51> if(1 && s->max_framesize){//FIXME truncated\n<53> buf_size= FFMIN(buf_size, s->max_framesize - s->bitstream_size);\n<59> if(s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size){\n<61> memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size);\n<67> memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size);\n<69> buf= &s->bitstream[s->bitstream_index];\n<71> buf_size += s->bitstream_size;\n<103> if ((ret = read_header(s)) < 0)\n<167> int blocksize = get_uint(s, av_log2(s->blocksize));\n<263> if ((ret = decode_subframe_lpc(s, cmd, channel, residual_size, coffset)) < 0)\n<313> fix_bitshift(s, s->decoded[channel]);
<1> static void feature_destroy ( hb_feature_t * g ) {\n<2> free ( g ) ;
<1> int ff_draw_init(FFDrawContext *draw, enum AVPixelFormat format, unsigned flags)\n<11> int pixelstep[MAX_PLANES] = { 0 };\n<47> if (pixelstep[c->plane] >= 8)\n<55> if ((desc->log2_chroma_w || desc->log2_chroma_h) && nb_planes < 3)\n<59> memset(draw, 0, sizeof(*draw));\n<67> memcpy(draw->pixelstep, pixelstep, sizeof(draw->pixelstep));
<1> static void clipper_init(MachineState *machine)\n<35> memset(cpus, 0, sizeof(cpus));\n<55> pci_bus = typhoon_init(ram_size, &isa_bus, &rtc_irq, cpus,
<1> static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,\n<3> SingleChannelElement *sce,\n<49> if (!qcnt) {\n<51> memset(sce->sf_idx, 0, sizeof(sce->sf_idx));\n<53> memset(sce->zeroes, 1, sizeof(sce->zeroes));
<1> static int mpegaudio_parse(AVCodecParserContext *s1,\n<11> MpegAudioParseContext *s = s1->priv_data;\n<25> buf_ptr = buf;\n<29> len = s->inbuf_ptr - s->inbuf;\n<39> s->inbuf[0] = s->free_format_next_header >> 24;\n<41> s->inbuf[1] = s->free_format_next_header >> 16;\n<43> s->inbuf[2] = s->free_format_next_header >> 8;\n<45> s->inbuf[3] = s->free_format_next_header;\n<65> if (len > 0) {\n<67> memcpy(s->inbuf_ptr, buf_ptr, len);\n<69> buf_ptr += len;\n<71> buf_size -= len;\n<73> s->inbuf_ptr += len;\n<77> if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {\n<81> header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n<83> (s->inbuf[2] << 8) | s->inbuf[3];\n<89> if (ret < 0) {\n<93> memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n<239> if (len < s->frame_size) {\n<247> if (len > buf_size)\n<249> len = buf_size;\n<251> memcpy(s->inbuf_ptr, buf_ptr, len);\n<253> buf_ptr += len;\n<255> s->inbuf_ptr += len;\n<257> buf_size -= len;\n<265> (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n<267> *poutbuf = s->inbuf;\n<269> *poutbuf_size = s->inbuf_ptr - s->inbuf;
<1> int ff_MPV_common_frame_size_change ( MpegEncContext * s ) {\n<3> if ( s -> slice_context_count > 1 ) {\n<10> i < s -> slice_context_count ;\n<12> av_freep ( & s -> thread_context [ i ] ) ;\n<18> i < s -> picture_count ;\n<22> s -> last_picture_ptr = s -> next_picture_ptr = s -> current_picture_ptr = NULL ;\n<23> if ( s -> codec_id == AV_CODEC_ID_MPEG2VIDEO && ! s -> progressive_sequence ) s -> mb_height = ( s -> height + 31 ) / 32 * 2 ;\n<24> else if ( s -> codec_id != AV_CODEC_ID_H264 ) s -> mb_height = ( s -> height + 15 ) / 16 ;\n<25> if ( ( s -> width || s -> height ) && av_image_check_size ( s -> width , s -> height , 0 , s -> avctx ) ) return AVERROR_INVALIDDATA ;\n<26> if ( ( err = init_context_frame ( s ) ) ) goto fail ;\n<28> if ( s -> width && s -> height ) {\n<32> i < nb_slices ;\n<34> s -> thread_context [ i ] = av_malloc ( sizeof ( MpegEncContext ) ) ;\n<35> memcpy ( s -> thread_context [ i ] , s , sizeof ( MpegEncContext ) ) ;\n<40> if ( init_duplicate_context ( s -> thread_context [ i ] ) < 0 ) goto fail ;\n<41> s -> thread_context [ i ] -> start_mb_y = ( s -> mb_height * ( i ) + nb_slices / 2 ) / nb_slices ;\n<42> s -> thread_context [ i ] -> end_mb_y = ( s -> mb_height * ( i + 1 ) + nb_slices / 2 ) / nb_slices ;\n<53> fail : ff_MPV_common_end ( s ) ;
<1> static int pcm_decode_frame(AVCodecContext *avctx,\n<25> samples = data;\n<27> src = buf;\n<109> switch(avctx->codec->id) {\n<273> memcpy(samples, src, n*sample_size);\n<275> src += n*sample_size;\n<277> samples += n * sample_size;
<1> void scsi_req_build_sense(SCSIRequest *req, SCSISense sense)\n<9> memset(req->sense, 0, 18);
<1> void dsputil_init(DSPContext* c, AVCodecContext *avctx)\n<733> memset(c->put_2tap_qpel_pixels_tab, 0, sizeof(c->put_2tap_qpel_pixels_tab));\n<735> memset(c->avg_2tap_qpel_pixels_tab, 0, sizeof(c->avg_2tap_qpel_pixels_tab));\n<739> if (HAVE_MMX)        dsputil_init_mmx   (c, avctx);\n<741> if (ARCH_ARM)        dsputil_init_arm   (c, avctx);\n<743> if (CONFIG_MLIB)     dsputil_init_mlib  (c, avctx);\n<745> if (HAVE_VIS)        dsputil_init_vis   (c, avctx);\n<747> if (ARCH_ALPHA)      dsputil_init_alpha (c, avctx);\n<749> if (ARCH_PPC)        dsputil_init_ppc   (c, avctx);\n<751> if (HAVE_MMI)        dsputil_init_mmi   (c, avctx);\n<753> if (ARCH_SH4)        dsputil_init_sh4   (c, avctx);\n<755> if (ARCH_BFIN)       dsputil_init_bfin  (c, avctx);
<1> vcard_emul_login(VCard *card, unsigned char *pin, int pin_len)\n<15> if (!nss_emul_init) {\n<33> pin_string = g_malloc(pin_len+1);\n<35> memcpy(pin_string, pin, pin_len);\n<37> pin_string[pin_len] = 0;\n<43> for (i = pin_len-1; i >= 0 && (pin_string[i] == 0xff); i--) {\n<45> pin_string[i] = 0;\n<51> rv = PK11_Authenticate(slot, PR_FALSE, pin_string);\n<53> memset(pin_string, 0, pin_len);  /* don't let the pin hang around in memory\n<57> g_free(pin_string);
<1> static void x86_cpu_reset(CPUState *s)\n<9> CPUX86State *env = &cpu->env;\n<23> memset(env, 0, offsetof(CPUX86State, end_reset_fields));\n<39> env->hflags2 |= HF2_GIF_MASK;\n<43> cpu_x86_update_cr0(env, 0x60000010);\n<121> cpu_set_fpuc(env, 0x37f);\n<139> memset(env->dr, 0, sizeof(env->dr));\n<199> cpu_x86_update_cr4(env, cr4);\n<217> memset(env->mtrr_var, 0, sizeof(env->mtrr_var));\n<219> memset(env->mtrr_fixed, 0, sizeof(env->mtrr_fixed));
<1> static int ehci_execute(EHCIQueue *q)\n<15> if ( !(q->qh.token & QTD_TOKEN_ACTIVE)) {\n<17> fprintf(stderr, "Attempting to execute inactive QH\n");\n<27> if (q->tbytes > BUFF_SIZE) {\n<29> fprintf(stderr, "Request for more bytes than allowed\n");\n<39> switch(q->pid) {\n<47> default: fprintf(stderr, "bad token\n"); break;\n<93> if (ret > BUFF_SIZE) {\n<95> fprintf(stderr, "ret from usb_handle_packet > BUFF_SIZE\n");
<1> void add_boot_device_path(int32_t bootindex, DeviceState *dev,\n<35> if (i->bootindex == bootindex) {\n<37> fprintf(stderr, "Two devices with same boot index %d\n", bootindex);
<1> void kvmppc_read_hptes(ppc_hash_pte64_t *hptes, hwaddr ptex, int n)\n<37> hdr = (struct kvm_get_htab_header *)buf;\n<39> while ((i < n) && ((char *)hdr < (buf + rc))) {\n<45> if (hdr->index != (ptex + i)) {\n<55> memcpy(hptes + i, hdr + 1, HASH_PTE_SIZE_64 * hdr->n_valid);\n<61> if ((n - i) < invalid) {\n<63> invalid = n - i;\n<67> memset(hptes + i, 0, invalid * HASH_PTE_SIZE_64);\n<75> ((char *)(hdr + 1) + HASH_PTE_SIZE_64 * hdr->n_valid);
<1> static void opt_pass(const char *pass_str)\n<9> if (pass != 1 && pass != 2) {\n<11> fprintf(stderr, "pass number can be only 1 or 2\n");
<1> static void taihu_405ep_init(MachineState *machine)\n<255> kernel_size = load_image_targphys(kernel_filename, kernel_base,\n<259> if (kernel_size < 0) {\n<261> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<275> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<279> if (initrd_size < 0) {
<1> static int handle_sigp(S390CPU *cpu, struct kvm_run *run, uint8_t ipa1)\n<23> order_code = decode_basedisp_rs(env, run->s390_sieic.ipb) & SIGP_ORDER_MASK;\n<39> switch (order_code) {\n<67> fprintf(stderr, "KVM: unknown SIGP: 0x%x\n", order_code);
<1> static void sun4m_common_init(int ram_size, int boot_device, DisplayState *ds,\n<11> if ((unsigned int)ram_size > (unsigned int)max_ram) {\n<13> fprintf(stderr, "qemu: Too much memory for this machine: %d, maximum %d\n",\n<15> (unsigned int)ram_size / (1024 * 1024),\n<17> (unsigned int)max_ram / (1024 * 1024));
<1> void hmp_savevm(Monitor *mon, const QDict *qdict)\n<7> QEMUSnapshotInfo sn1, *sn = &sn1, old_sn1, *old_sn = &old_sn1;\n<77> if (ret) {\n<93> memset(sn, 0, sizeof(*sn));\n<115> pstrcpy(sn->name, sizeof(sn->name), old_sn->name);\n<117> pstrcpy(sn->id_str, sizeof(sn->id_str), old_sn->id_str);\n<121> pstrcpy(sn->name, sizeof(sn->name), name);\n<131> strftime(sn->name, sizeof(sn->name), "vm-%Y%m%d%H%M%S", &tm);\n<165> ret = bdrv_all_create_snapshot(sn, bs, vm_state_size, &bs);
<1> void set_context_opts(void *ctx, void *opts_ctx, int flags, AVCodec *codec)\n<9> if(!strcmp("AVCodecContext", (*(AVClass**)ctx)->class_name)){\n<11> AVCodecContext *avctx= ctx;\n<13> if(codec && codec->priv_class && avctx->priv_data){\n<19> } else if (!strcmp("AVFormatContext", (*(AVClass**)ctx)->class_name)) {\n<21> AVFormatContext *avctx = ctx;\n<23> if (avctx->oformat && avctx->oformat->priv_class) {
<1> DeviceState *pc_vga_init(ISABus *isa_bus, PCIBus *pci_bus)\n<23> if (pci_bus) {\n<27> if (!dev) {\n<29> fprintf(stderr, "Warning: vmware_vga not available,"\n<39> fprintf(stderr, "%s: vmware_vga: no PCI bus\n", __FUNCTION__);
<1> static char *make_digest_auth(HTTPAuthState *state, const char *username,\n<9> DigestParams *digest = &state->digest_params;\n<33> snprintf(nc, sizeof(nc), "%08x", digest->nc);\n<43> ff_data_to_hex(cnonce, (const uint8_t*) cnonce_buf, sizeof(cnonce_buf), 1);\n<45> cnonce[2*sizeof(cnonce_buf)] = 0;\n<51> if (!md5ctx)\n<59> update_md5_strings(md5ctx, username, ":", state->realm, ":", password, NULL);\n<69> if (!strcmp(digest->algorithm, "") || !strcmp(digest->algorithm, "MD5")) {\n<71> } else if (!strcmp(digest->algorithm, "MD5-sess")) {\n<73> av_md5_init(md5ctx);\n<75> update_md5_strings(md5ctx, A1hash, ":", digest->nonce, ":", cnonce, NULL);\n<77> av_md5_final(md5ctx, hash);\n<79> ff_data_to_hex(A1hash, hash, 16, 1);\n<81> A1hash[32] = 0;\n<87> av_free(md5ctx);\n<89> return NULL;\n<95> av_md5_init(md5ctx);\n<97> update_md5_strings(md5ctx, method, ":", uri, NULL);\n<99> av_md5_final(md5ctx, hash);\n<101> ff_data_to_hex(A2hash, hash, 16, 1);\n<103> A2hash[32] = 0;\n<107> av_md5_init(md5ctx);\n<109> update_md5_strings(md5ctx, A1hash, ":", digest->nonce, NULL);\n<111> if (!strcmp(digest->qop, "auth") || !strcmp(digest->qop, "auth-int")) {\n<113> update_md5_strings(md5ctx, ":", nc, ":", cnonce, ":", digest->qop, NULL);\n<117> update_md5_strings(md5ctx, ":", A2hash, NULL);\n<119> av_md5_final(md5ctx, hash);\n<121> ff_data_to_hex(response, hash, 16, 1);\n<123> response[32] = 0;\n<127> av_free(md5ctx);\n<131> if (!strcmp(digest->qop, "") || !strcmp(digest->qop, "auth")) {\n<133> } else if (!strcmp(digest->qop, "auth-int")) {\n<137> return NULL;\n<143> return NULL;\n<149> len = strlen(username) + strlen(state->realm) + strlen(digest->nonce) +\n<151> strlen(uri) + strlen(response) + strlen(digest->algorithm) +\n<153> strlen(digest->opaque) + strlen(digest->qop) + strlen(cnonce) +\n<155> strlen(nc) + 150;\n<159> authstr = av_malloc(len);\n<161> if (!authstr)\n<171> av_strlcatf(authstr, len, "username=\"%s\"",   username);\n<173> av_strlcatf(authstr, len, ",realm=\"%s\"",     state->realm);\n<175> av_strlcatf(authstr, len, ",nonce=\"%s\"",     digest->nonce);\n<177> av_strlcatf(authstr, len, ",uri=\"%s\"",       uri);\n<179> av_strlcatf(authstr, len, ",response=\"%s\"",  response);\n<183> av_strlcatf(authstr, len, ",algorithm=%s",  digest->algorithm);\n<187> av_strlcatf(authstr, len, ",opaque=\"%s\"", digest->opaque);\n<191> av_strlcatf(authstr, len, ",qop=\"%s\"",    digest->qop);\n<193> av_strlcatf(authstr, len, ",cnonce=\"%s\"", cnonce);\n<195> av_strlcatf(authstr, len, ",nc=%s",         nc);
<1> void *s1d13745_init(qemu_irq gpio_int)\n<25> switch (surface_bits_per_pixel(surface)) {\n<77> fprintf(stderr, "%s: Bad color depth\n", __FUNCTION__);
<1> static int megasas_dcmd_ld_get_list(MegasasState *s, MegasasCmd *cmd)\n<7> size_t dcmd_size = sizeof(info), resid;\n<17> memset(&info, 0, dcmd_size);\n<19> if (cmd->iov_size < dcmd_size) {\n<73> resid = dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
<1> static int flush_packet(AVFormatContext *ctx, int stream_index,\n<101> if (stream->bytes_to_iframe == 0 || s->packet_number == 0) {\n<109> put_buffer(ctx->pb, buffer, size);\n<137> memset(buffer, 0, 128);\n<139> buf_ptr = buffer;\n<177> size = buf_ptr - buffer;
<1> static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc,\n<65> dst  = frame->data[plane_idx]  + 8*by*stride;\n<67> for (bx = 0; bx < bw; bx++, dst += 8) {\n<71> switch (blk) {\n<107> dst[coordmap[*scan++]] = v;\n<113> dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n<121> dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n<127> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<129> dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC);\n<133> read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp);\n<135> c->binkdsp.idct_put(dst, stride, dctblock);\n<193> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<195> dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC);\n<199> read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp);\n<201> c->binkdsp.idct_add(dst, stride, dctblock);\n<225> dst[i*stride + j] = col[v & 1];\n<257> for (i = 0; i < 8; i++)\n<259> memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8);
<1> static int get_riff(AVFormatContext *s, AVIOContext *pb)\n<15> avio_read(pb, header, 4);\n<25> for(i=0; avi_headers[i][0]; i++)\n<27> if(!memcmp(header, avi_headers[i], 8))\n<37> if(header[7] == 0x19)
<1> static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<149> if (w != avctx->width || h != avctx->height)\n<151> avcodec_set_dimensions(avctx, w, h);\n<167> ptr    = p->data[0];\n<213> for (y=0; y<h; y++, ptr+=stride) {\n<215> pcx_rle_decode(&gb, scanline, bytes_per_scanline, compressed);\n<217> memcpy(ptr, scanline, w);\n<337> av_free(scanline);
<1> static void prstat_to_stat(struct stat *stbuf, ProxyStat *prstat)\n<5> memset(stbuf, 0, sizeof(*stbuf));
<1> static void opt_mb_qmin(const char *arg)\n<11> fprintf(stderr, "qmin must be >= 1 and <= 31\n");
<1> static int open_input(struct variant *var)\n<5> struct segment *seg = var->segments[var->cur_seq_no - var->start_seq_no];\n<13> } else if (seg->key_type == KEY_AES_128) {\n<19> if (strcmp(seg->key, var->key_url)) {\n<23> if (ffurl_open(&uc, seg->key, AVIO_FLAG_READ,\n<25> &var->parent->interrupt_callback, NULL) == 0) {\n<47> av_strlcpy(var->key_url, seg->key, sizeof(var->key_url));\n<57> if (strstr(seg->url, "://"))\n<59> snprintf(url, sizeof(url), "crypto+%s", seg->url);\n<63> snprintf(url, sizeof(url), "crypto:%s", seg->url);
<1> static int split_init(AVFilterContext *ctx, const char *args, void *opaque)\n<27> for (i = 0; i < nb_outputs; i++) {\n<37> pad.type = !strcmp(ctx->name, "split") ? AVMEDIA_TYPE_VIDEO : AVMEDIA_TYPE_AUDIO;\n<43> avfilter_insert_outpad(ctx, i, &pad);
<1> static int test_vector_fmac_scalar(AVFloatDSPContext *fdsp, AVFloatDSPContext *cdsp,\n<3> const float *v1, const float *src0, float scale)\n<15> memcpy(cdst, v1, LEN * sizeof(*v1));\n<17> memcpy(odst, v1, LEN * sizeof(*v1));\n<21> cdsp->vector_fmac_scalar(cdst, src0, scale, LEN);\n<23> fdsp->vector_fmac_scalar(odst, src0, scale, LEN);
<1> static void thread_pool_init_one(ThreadPool *pool, AioContext *ctx)\n<13> memset(pool, 0, sizeof(*pool));\n<15> event_notifier_init(&pool->notifier, false);\n<19> qemu_mutex_init(&pool->lock);\n<21> qemu_cond_init(&pool->check_cancel);\n<23> qemu_cond_init(&pool->worker_stopped);\n<25> qemu_sem_init(&pool->sem, 0);\n<29> pool->new_thread_bh = aio_bh_new(ctx, spawn_thread_bh_fn, pool);\n<39> aio_set_event_notifier(ctx, &pool->notifier, event_notifier_ready);
<1> static void gic_reset(gic_state *s)\n<7> memset(s->irq_state, 0, GIC_NIRQ * sizeof(gic_irq_state));\n<9> for (i = 0 ; i < NUM_CPU(s); i++) {
<1> static void versatile_init(MachineState *machine, int board_id)\n<43> if (!cpu) {\n<45> fprintf(stderr, "Unable to find CPU definition\n");\n<141> for(n = 0; n < nb_nics; n++) {\n<143> nd = &nd_table[n];\n<147> if (!done_smc && (!nd->model || strcmp(nd->model, "smc91c111") == 0)) {\n<149> smc91c111_init(nd, 0x10010000, sic[25]);\n<151> done_smc = 1;\n<155> pci_nic_init_nofail(nd, pci_bus, "rtl8139", NULL);\n<329> if (!pflash_cfi01_register(VERSATILE_FLASH_ADDR, NULL, "versatile.flash",\n<341> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> static void show_packet(AVFormatContext *fmt_ctx, AVPacket *pkt)\n<11> printf("[PACKET]\n");\n<13> printf("codec_type=%s\n", media_type_string(st->codec->codec_type));\n<15> printf("stream_index=%d\n", pkt->stream_index);\n<17> printf("pts=%s\n", ts_value_string(val_str, sizeof(val_str), pkt->pts));\n<19> printf("pts_time=%s\n", time_value_string(val_str, sizeof(val_str),\n<23> printf("dts=%s\n", ts_value_string(val_str, sizeof(val_str), pkt->dts));\n<25> printf("dts_time=%s\n", time_value_string(val_str, sizeof(val_str),\n<29> printf("duration=%s\n", ts_value_string(val_str, sizeof(val_str),\n<33> printf("duration_time=%s\n", time_value_string(val_str, sizeof(val_str),\n<39> printf("size=%s\n", value_string(val_str, sizeof(val_str),\n<45> printf("flags=%c\n", pkt->flags & AV_PKT_FLAG_KEY ? 'K' : '_');\n<47> printf("[/PACKET]\n");
<1> int av_picture_pad(AVPicture *dst, const AVPicture *src, int height, int width,\n<5> int *color)\n<35> if (padtop || padleft) {\n<39> dst->linesize[i] * (padtop >> y_shift) + (padleft >> x_shift));\n<47> optr = dst->data[i] + dst->linesize[i] * (padtop >> y_shift) +\n<53> for (y = 0; y < yheight; y++) {\n<55> memset(optr, color[i], (padleft + padright) >> x_shift);\n<57> optr += dst->linesize[i];\n<65> if (src) { /* first line */\n<67> uint8_t *iptr = src->data[i];\n<69> optr = dst->data[i] + dst->linesize[i] * (padtop >> y_shift) +\n<73> memcpy(optr, iptr, (width - padleft - padright) >> x_shift);\n<75> iptr += src->linesize[i];\n<77> optr = dst->data[i] + dst->linesize[i] * (padtop >> y_shift) +\n<83> for (y = 0; y < yheight; y++) {\n<85> memset(optr, color[i], (padleft + padright) >> x_shift);\n<87> memcpy(optr + ((padleft + padright) >> x_shift), iptr,\n<89> (width - padleft - padright) >> x_shift);\n<91> iptr += src->linesize[i];\n<93> optr += dst->linesize[i];\n<101> if (padbottom || padright) {\n<109> (padbottom >> y_shift) + (padright >> x_shift));
<1> int fw_cfg_add_file(FWCfgState *s,  const char *dir, const char *filename,\n<27> if (index == FW_CFG_FILE_SLOTS) {\n<29> fprintf(stderr, "fw_cfg: out of file slots\n");
<1> static void mspack_fmap_free ( void * mem ) {\n<2> free ( mem ) ;
<1> void fdt_build_clock_node(void *host_fdt, void *guest_fdt,\n<55> r = qemu_fdt_getprop(host_fdt, node_path, "compatible", &prop_len,\n<59> if (strcmp(r, "fixed-clock")) {\n<61> error_setg(&error_fatal,
<1> static void portio_list_add_1(PortioList *piolist,\n<3> const MemoryRegionPortio *pio_init,\n<23> pio = g_new(MemoryRegionPortio, count + 1);\n<25> memcpy(pio, pio_init, sizeof(MemoryRegionPortio) * count);\n<27> memset(pio + count, 0, sizeof(MemoryRegionPortio));\n<43> ops->old_portio = pio;
<1> int xenstore_domain_init1(const char *kernel, const char *ramdisk,\n<65> xenstore_write_int(dom, "memory/target", ram_size >> 10);  // kB\n<79> xenstore_write_str(dom, path, "online");\n<95> free(dom);
<1> static void *qemu_kvm_cpu_thread_fn(void *arg)\n<19> if (r < 0) {\n<21> fprintf(stderr, "kvm_init_vcpu failed: %s\n", strerror(-r));
<1> static uint8_t *csrhci_out_packet(struct csrhci_s *s, int len)\n<17> if (off + len > FIFO_LEN && (s->out_size = off + len) > FIFO_LEN * 2) {\n<19> fprintf(stderr, "%s: can't alloc %i bytes\n", __func__, len);\n<31> if (s->out_len > s->out_size) {\n<33> fprintf(stderr, "%s: can't alloc %i bytes\n", __func__, len);
<1> static void do_sendkey(const char *string)\n<19> separator = strchr(string, '-');\n<21> keyname_len = separator ? separator - string : strlen(string);\n<25> pstrcpy(keyname_buf, sizeof(keyname_buf), string);\n<59> if (!separator)\n<63> string = separator + 1;
<1> static int aac_encode_frame(AVCodecContext *avctx,\n<3> uint8_t *frame, int buf_size, void *data)\n<7> AACEncContext *s = avctx->priv_data;\n<29> if (!s->psypp) {\n<31> memcpy(s->samples + 1024 * avctx->channels, data,\n<33> 1024 * avctx->channels * sizeof(s->samples[0]));\n<59> if (!avctx->frame_number) {\n<61> memcpy(s->samples, s->samples + 1024 * avctx->channels,\n<63> 1024 * avctx->channels * sizeof(s->samples[0]));\n<95> if (!data)\n<137> apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2);\n<153> put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);\n<157> memset(chan_el_counter, 0, sizeof(chan_el_counter));\n<171> put_bits(&s->pb, 4, chan_el_counter[tag]++);\n<215> adjust_frame_information(s, cpe, chans);\n<223> put_ics_info(s, &cpe->ch[0].ics);\n<235> encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window);\n<247> if (frame_bits <= 6144 * avctx->channels - 3) {\n<287> if (!data)\n<291> memcpy(s->samples, s->samples + 1024 * avctx->channels,\n<293> 1024 * avctx->channels * sizeof(s->samples[0]));
<1> int ff_img_read_header(AVFormatContext *s1)\n<291> probe_buffer_size = avio_read(s1->pb, probe_buffer, probe_buffer_size);\n<293> if (probe_buffer_size < 0) {\n<301> memset(probe_buffer + probe_buffer_size, 0, AVPROBE_PADDING_SIZE);
<1> int av_opt_set_from_string(void *ctx, const char *opts,\n<31> if ((ret = get_key(&opts, key_val_sep, key_buf, sizeof(key_buf))) < 0) {\n<39> av_log(ctx, AV_LOG_ERROR, "No option name near '%s'\n", opts);\n<57> if (!(value = av_get_token(&opts, pairs_sep)))\n<61> if (*opts && strchr(pairs_sep, *opts))\n<63> opts++;
<1> static int iff_read_header(AVFormatContext *s)\n<261> if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n<265> if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n<267> st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n<269> else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n<271> st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n<273> else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n<275> st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n<277> else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n<279> st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n<281> else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n<283> st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n<287> av_log_ask_for_sample(s, "unsupported color format\n");\n<289> return AVERROR_PATCHWELCOME;\n<349> if (metadata_tag) {
<1> static BusState *qbus_find_bus(DeviceState *dev, char *elem)\n<9> LIST_FOREACH(child, &dev->child_bus, sibling) {\n<11> if (strcmp(child->name, elem) == 0) {\n<13> return child;\n<19> return NULL;
<1> static int mp3_header_compress(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,\n<5> const uint8_t *buf, int buf_size, int keyframe){\n<23> header = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];\n<29> if(ff_mpa_check_header(header) < 0 || (header&0x70000) != 0x30000){\n<47> *poutbuf= av_malloc(buf_size - 4 + FF_INPUT_BUFFER_PADDING_SIZE);\n<49> memcpy(*poutbuf, buf + 4, buf_size - 4 + FF_INPUT_BUFFER_PADDING_SIZE);
<1> void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n<15> for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n<17> if (!strcmp(vc->name, device))\n<23> if (!vc) {\n<25> monitor_printf(mon, "can't find device %s\n", device);\n<31> qemu_del_vlan_client(vc);
<1> static void load_linux(const char *kernel_filename,\n<5> const char *kernel_cmdline)\n<31> cmdline_size = (strlen(kernel_cmdline)+16) & ~15;\n<37> f = fopen(kernel_filename, "rb");\n<43> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<77> cmdline_addr = 0x9a000 - cmdline_size;\n<87> cmdline_addr = 0x9a000 - cmdline_size;\n<145> pstrcpy_targphys(cmdline_addr, 4096, kernel_cmdline);\n<193> if (protocol < 0x200) {\n<195> fprintf(stderr, "qemu: linux kernel too old to load a ram disk\n");\n<203> fi = fopen(initrd_filename, "rb");\n<205> if (!fi) {\n<207> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<229> if (!fread_targphys_ok(initrd_addr, initrd_size, fi)) {\n<231> fprintf(stderr, "qemu: read error on initial ram disk '%s'\n",\n<271> if (!fread_targphys_ok(real_addr+1024, setup_size-1024, f) ||\n<275> fprintf(stderr, "qemu: read error on kernel '%s'\n",\n<295> memset(gpr, 0, sizeof gpr);\n<301> generate_bootsect(gpr, seg, 0);
<76> i < 3 ;\n<78> memcpy ( s -> visualization_buffer [ i ] , pict -> data [ i ] , ( i == 0 ) ? pict -> linesize [ i ] * height : pict -> linesize [ i ] * height >> v_chroma_shift ) ;\n<79> pict -> data [ i ] = s -> visualization_buffer [ i ] ;
<1> char *get_boot_devices_list(uint32_t *size)\n<13> QTAILQ_FOREACH(i, &fw_boot_order, link) {\n<31> if (i->suffix && devpath) {\n<33> bootpath = qemu_malloc(strlen(devpath) + strlen(i->suffix) + 1);\n<35> sprintf(bootpath, "%s%s", devpath, i->suffix);\n<37> qemu_free(devpath);\n<39> } else if (devpath) {\n<41> bootpath = devpath;\n<45> bootpath = strdup(i->suffix);\n<47> assert(bootpath);\n<59> len = strlen(bootpath) + 1;\n<61> list = qemu_realloc(list, total + len);\n<63> memcpy(&list[total], bootpath, len);\n<65> total += len;\n<67> qemu_free(bootpath);
<1> static void vncws_send_handshake_response(VncState *vs, const char* key)\n<39> if (accept == NULL) {\n<51> response = g_strdup_printf(WS_HANDSHAKE, accept);\n<53> vnc_client_write_buf(vs, (const uint8_t *)response, strlen(response));\n<59> g_free(response);
<1> static void omap_rfbi_transfer_start(struct omap_dss_s *s)\n<25> if (s->rfbi.control & (1 << 1)) {				/* BYPASS */\n<31> fprintf(stderr, "%s: Bypass mode unimplemented\n", __FUNCTION__);
<1> gen_intermediate_code_internal(TriCoreCPU *cpu, struct TranslationBlock *tb,\n<45> ctx.mem_idx = cpu_mmu_index(env);\n<57> decode_opc(env, &ctx, 0);\n<95> if (search_pc) {\n<97> printf("done_generating search pc\n");\n<107> if (tcg_check_temp_count()) {\n<109> printf("LEAK at %08x\n", env->PC);
<1> static void usage(void)\n<5> printf("Escape an input string, adopting the av_get_token() escaping logic\n");\n<7> printf("usage: ffescape [OPTIONS]\n");
<1> static int virtcon_parse(const char *devname)\n<15> if (strcmp(devname, "none") == 0)\n<17> return 0;\n<19> if (index == MAX_VIRTIO_CONSOLES) {\n<21> fprintf(stderr, "qemu: too many virtio consoles\n");\n<29> bus_opts = qemu_opts_create(device, NULL, 0, &error_abort);\n<31> if (arch_type == QEMU_ARCH_S390X) {\n<43> dev_opts = qemu_opts_create(device, NULL, 0, &error_abort);\n<45> qemu_opt_set(dev_opts, "driver", "virtconsole", &error_abort);\n<49> snprintf(label, sizeof(label), "virtcon%d", index);\n<51> virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n<53> if (!virtcon_hds[index]) {\n<55> fprintf(stderr, "qemu: could not connect virtio console"
<1> static void vp5_parse_coeff_models(VP56Context *s)\n<19> memset(def_prob, 0x80, sizeof(def_prob));\n<31> model->coeff_dccv[pt][node] = def_prob[node];\n<35> model->coeff_dccv[pt][node] = def_prob[node];\n<53> model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n<57> model->coeff_ract[pt][ct][cg][node] = def_prob[node];
<1> int MBS_ApplyPatch ( const MBSPatchHeader * header , int patchfd , unsigned char * fbuffer , int filefd ) {\n<3> unsigned char * buf = ( unsigned char * ) malloc ( header -> cblen + header -> difflen + header -> extralen ) ;\n<4> if ( ! buf ) return MEM_ERROR ;
<1> static struct object_list * * process_tree ( struct tree * tree , struct object_list * * p , struct name_path * path , const char * name ) {\n<7> if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return p ;\n<10> name = xstrdup ( name ) ;\n<14> me . elem_len = strlen ( name ) ;\n<17> case OBJ_TREE : p = process_tree ( lookup_tree ( entry . sha1 ) , p , & me , name ) ;\n<19> case OBJ_BLOB : p = process_blob ( lookup_blob ( entry . sha1 ) , p , & me , name ) ;
<1> void cpu_state_reset(CPUMIPSState *env)\n<7> qemu_log("CPU Reset (CPU %d)\n", env->cpu_index);\n<9> log_cpu_state(env, 0);\n<15> memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n<17> tlb_flush(env, 1);
<1> int rom_copy(uint8_t *dest, target_phys_addr_t addr, size_t size)\n<37> d = dest + (rom->addr - addr);\n<39> s = rom->data;\n<41> l = rom->romsize;\n<47> d = dest;\n<49> s += (addr - rom->addr);\n<51> l -= (addr - rom->addr);\n<57> l = dest - d;\n<63> memcpy(d, s, l);\n<69> return (d + l) - dest;
<1> static void decode_scaling_list(H264Context *h, uint8_t *factors, int size,\n<3> const uint8_t *jvt_list,\n<5> const uint8_t *fallback_list)\n<13> if (!get_bits1(&h->gb)) /* matrix not written, we use the predicted one */\n<15> memcpy(factors, fallback_list, size * sizeof(uint8_t));\n<25> if (!i && !next) { /* matrix not written, we use the preset one */\n<27> memcpy(factors, jvt_list, size * sizeof(uint8_t));\n<33> last = factors[scan[i]] = next ? next : last;
<1> static int css_interpret_ccw(SubchDev *sch, hwaddr ccw_addr,\n<115> if (check_len) {\n<117> if (ccw.count != sizeof(sch->sense_data)) {\n<133> memset(sch->sense_data, 0, sizeof(sch->sense_data));
<1> timer_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n<11> switch (addr) {\n<45> D(printf ("%s %x\n", __func__, addr));
<1> static void extract_common_blockdev_options(QemuOpts *opts, int *bdrv_flags,\n<3> const char **throttling_group, ThrottleConfig *throttle_cfg,\n<47> if ((aio = qemu_opt_get(opts, "aio")) != NULL) {\n<49> if (!strcmp(aio, "native")) {\n<51> *bdrv_flags |= BDRV_O_NATIVE_AIO;\n<53> } else if (!strcmp(aio, "threads")) {\n<59> error_setg(errp, "invalid aio option");\n<61> return;\n<73> if (throttling_group) {\n<81> if (throttle_cfg) {\n<83> memset(throttle_cfg, 0, sizeof(*throttle_cfg));\n<143> if (!check_throttle_config(throttle_cfg, errp)) {
<1> static int sunrast_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<60> if ( buf_end - buf < maplength ) return AVERROR_INVALIDDATA ;\n<73> x ++ , ptr += 4 ) * ( uint32_t * ) ptr = ( buf [ x ] << 16 ) + ( buf [ len + x ] << 8 ) + buf [ len + len + x ] ;\n<76> ptr = p -> data [ 0 ] ;\n<105> if ( buf_end - buf < len ) break ;\n<106> memcpy ( ptr , buf , len ) ;\n<107> ptr += stride ;\n<108> buf += alen ;
<1> static int mpegts_set_stream_info(AVStream *st, PESContext *pes,\n<33> pes->st = st;\n<61> if (pes->stream_type == 0x83) {\n<73> if (!sub_pes)\n<77> memcpy(sub_pes, pes, sizeof(*sub_pes));\n<81> sub_st = avformat_new_stream(pes->stream, NULL);\n<85> av_free(sub_pes);\n<93> sub_st->id = pes->pid;\n<97> sub_st->priv_data = sub_pes;\n<113> mpegts_find_stream_type(st, pes->stream_type, MISC_types);
<1> static int dmg_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<7> BDRVDMGState *s = bs->opaque;\n<17> if(dmg_read_chunk(bs, sector_num+i) != 0)\n<23> memcpy(buf+i*512,s->uncompressed_chunk+sector_offset_in_chunk*512,512);
<1> AVFilterBufferRef *avfilter_default_get_video_buffer(AVFilterLink *link, int perms, int w, int h)\n<5> AVFilterBuffer *pic = av_mallocz(sizeof(AVFilterBuffer));\n<7> AVFilterBufferRef *ref = av_mallocz(sizeof(AVFilterBufferRef));\n<43> pic->linesize[i] = FFALIGN(pic->linesize[i], 16);\n<53> av_fill_image_pointers(pic->data, ref->format, ref->video->h, buf, pic->linesize);\n<57> memcpy(ref->data,     pic->data,     sizeof(ref->data));\n<59> memcpy(ref->linesize, pic->linesize, sizeof(ref->linesize));\n<63> return ref;
<1> int tmx_check_pretran ( sip_msg_t * msg ) {\n<51> scallid = msg -> callid -> body ;\n<53> scseqmet = get_cseq ( msg ) -> method ;\n<55> scseqnum = get_cseq ( msg ) -> number ;\n<57> sftag = get_from ( msg ) -> tag_value ;\n<63> if ( _tmx_proc_ptran == NULL ) {\n<67> memset ( _tmx_proc_ptran , 0 , sizeof ( pretran_t ) ) ;\n<72> svbranch = vbr -> value ;\n<78> if ( dsize > _tmx_proc_ptran -> dbuf . len ) {\n<81> if ( _tmx_proc_ptran -> dbuf . s == NULL ) {\n<89> _tmx_proc_ptran -> callid . s = _tmx_proc_ptran -> dbuf . s ;\n<90> memcpy ( _tmx_proc_ptran -> callid . s , scallid . s , scallid . len ) ;\n<91> _tmx_proc_ptran -> callid . len = scallid . len ;\n<92> _tmx_proc_ptran -> callid . s [ _tmx_proc_ptran -> callid . len ] = '\0' ;\n<93> _tmx_proc_ptran -> ftag . s = _tmx_proc_ptran -> callid . s + _tmx_proc_ptran -> callid . len + 1 ;\n<94> memcpy ( _tmx_proc_ptran -> ftag . s , sftag . s , sftag . len ) ;\n<95> _tmx_proc_ptran -> ftag . len = sftag . len ;\n<96> _tmx_proc_ptran -> ftag . s [ _tmx_proc_ptran -> ftag . len ] = '\0' ;\n<97> _tmx_proc_ptran -> cseqnum . s = _tmx_proc_ptran -> ftag . s + _tmx_proc_ptran -> ftag . len + 1 ;\n<98> memcpy ( _tmx_proc_ptran -> cseqnum . s , scseqnum . s , scseqnum . len ) ;\n<99> _tmx_proc_ptran -> cseqnum . len = scseqnum . len ;\n<100> _tmx_proc_ptran -> cseqnum . s [ _tmx_proc_ptran -> cseqnum . len ] = '\0' ;\n<101> _tmx_proc_ptran -> cseqmet . s = _tmx_proc_ptran -> cseqnum . s + _tmx_proc_ptran -> cseqnum . len + 1 ;\n<102> memcpy ( _tmx_proc_ptran -> cseqmet . s , scseqmet . s , scseqmet . len ) ;\n<103> _tmx_proc_ptran -> cseqmet . len = scseqmet . len ;\n<104> _tmx_proc_ptran -> cseqmet . s [ _tmx_proc_ptran -> cseqmet . len ] = '\0' ;\n<105> if ( likely ( vbr != NULL ) ) {\n<106> _tmx_proc_ptran -> vbranch . s = _tmx_proc_ptran -> cseqmet . s + _tmx_proc_ptran -> cseqmet . len + 1 ;\n<107> memcpy ( _tmx_proc_ptran -> vbranch . s , svbranch . s , svbranch . len ) ;\n<108> _tmx_proc_ptran -> vbranch . len = svbranch . len ;\n<109> _tmx_proc_ptran -> vbranch . s [ _tmx_proc_ptran -> vbranch . len ] = '\0' ;\n<119> it != NULL ;\n<120> it = it -> next ) {\n<121> if ( _tmx_proc_ptran -> hid != it -> hid || _tmx_proc_ptran -> cseqmetid != it -> cseqmetid || _tmx_proc_ptran -> callid . len != it -> callid . len || _tmx_proc_ptran -> ftag . len != it -> ftag . len || _tmx_proc_ptran -> cseqmet . len != it -> cseqmet . len || _tmx_proc_ptran -> cseqnum . len != it -> cseqnum . len ) continue ;\n<122> if ( _tmx_proc_ptran -> vbranch . s != NULL && it -> vbranch . s != NULL ) {\n<124> if ( _tmx_proc_ptran -> vbranch . s [ it -> vbranch . len - 1 ] != it -> vbranch . s [ it -> vbranch . len - 1 ] ) continue ;\n<125> if ( memcmp ( _tmx_proc_ptran -> vbranch . s , it -> vbranch . s , it -> vbranch . len ) != 0 ) continue ;\n<127> if ( memcmp ( _tmx_proc_ptran -> callid . s , it -> callid . s , it -> callid . len ) != 0 || memcmp ( _tmx_proc_ptran -> ftag . s , it -> ftag . s , it -> ftag . len ) != 0 || memcmp ( _tmx_proc_ptran -> cseqnum . s , it -> cseqnum . s , it -> cseqnum . len ) != 0 ) continue ;\n<128> if ( ( it -> cseqmetid == METHOD_OTHER || it -> cseqmetid == METHOD_UNDEF ) && memcmp ( _tmx_proc_ptran -> cseqmet . s , it -> cseqmet . s , it -> cseqmet . len ) != 0 ) continue ;\n<129> LM_DBG ( "matched another pre-transaction by pid %d for [%.*s]\n" , it -> pid , it -> callid . len , it -> callid . s ) ;
<1> int bdrv_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)\n<11> if (!drv->bdrv_get_info)\n<15> memset(bdi, 0, sizeof(*bdi));\n<17> return drv->bdrv_get_info(bs, bdi);
<1> static int flashsv_decode_frame(AVCodecContext *avctx, void *data,\n<3> int *got_frame, AVPacket *avpkt)\n<9> FlashSVContext *s = avctx->priv_data;\n<29> init_get_bits(&gb, avpkt->data, buf_size * 8);\n<173> if ((err = av_reallocp(&s->keyframedata, avpkt->size)) < 0)\n<177> memcpy(s->keyframedata, avpkt->data, avpkt->size);\n<289> if (!s->keyframe) {\n<375> for (k = 0; k < cur_blk_height; k++) {\n<377> int x = off - k * s->frame->linesize[0] + x_pos * 3;\n<381> cur_blk_width * 3);\n<413> if (!s->keyframe) {\n<417> if (!s->keyframe) {\n<429> s->frame->linesize[0] * avctx->height);
<1> int xen_hvm_init(void)\n<81> hw_error("map buffered IO page returned error %d", errno);\n<99> if (rc == -1) {\n<101> fprintf(stderr, "bind interdomain ioctl error %d\n", errno);\n<137> if (xen_be_init() != 0) {\n<139> fprintf(stderr, "%s: xen backend core setup failed\n", __FUNCTION__);
<1> static int bfi_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<7> uint8_t * frame_end = bfi -> dst + avctx -> width * avctx -> height ;\n<12> if ( ( ret = ff_get_buffer ( avctx , & bfi -> frame ) ) < 0 ) {\n<91> src = bfi -> dst ;\n<92> dst = bfi -> frame . data [ 0 ] ;\n<93> while ( height -- ) {\n<94> memcpy ( dst , src , avctx -> width ) ;\n<95> src += avctx -> width ;\n<96> dst += bfi -> frame . linesize [ 0 ] ;
<1> void bt_l2cap_psm_register(struct bt_l2cap_device_s *dev, int psm, int min_mtu,\n<9> struct bt_l2cap_psm_s *new_psm = l2cap_psm(dev, psm);\n<13> if (new_psm) {\n<15> fprintf(stderr, "%s: PSM %04x already registered for device `%s'.\n",\n<27> new_psm->psm = psm;
<1> static char *usb_get_fw_dev_path(DeviceState *qdev)\n<9> int pos = 0;\n<15> fw_path = qemu_malloc(32 + strlen(dev->port->path) * 6);\n<17> in = dev->port->path;\n<21> nr = strtol(in, &in, 10);\n<23> if (in[0] == '.') {\n<27> pos += sprintf(fw_path + pos, "hub@%ld/", nr);\n<35> pos += sprintf(fw_path + pos, "%s@%ld", qdev_fw_name(qdev), nr);\n<43> return fw_path;
<1> static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> Msvideo1Context * s = avctx -> priv_data ;\n<14> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<15> if ( pal ) {\n<16> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<20> if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;\n<21> else msvideo1_decode_16bit ( s ) ;
<1> static void get_fcb_param(FCBParam *optim, int16_t *impulse_resp,\n<9> int16_t impulse_r[SUBFRAME_LEN];\n<31> memcpy(impulse_r, impulse_resp, sizeof(int16_t) * SUBFRAME_LEN);\n<39> gen_dirac_train(impulse_r, pitch_lag);\n<47> temp_corr[i] = impulse_r[i] >> 1;\n<53> temp = dot_product(temp_corr, temp_corr, SUBFRAME_LEN);\n<65> temp = dot_product(temp_corr + i, temp_corr, SUBFRAME_LEN - i);\n<79> temp = dot_product(buf + i, impulse_r, SUBFRAME_LEN - i);\n<149> for (j = 1; j < 5; j++) {\n<153> temp_corr[k] = 0;\n<167> temp_corr[param.pulse_pos[0]] = 1;\n<207> temp_corr[param.pulse_pos[k]] = 1;\n<215> memset(temp_corr, 0, sizeof(int16_t) * SUBFRAME_LEN);\n<221> temp_corr[param.pulse_pos[k]] = param.pulse_sign[k];\n<231> int prod = av_clipl_int32((int64_t)temp_corr[l] *\n<239> temp_corr[k] = temp << 2 >> 16;\n<253> prod = av_clipl_int32((int64_t)buf[k] * temp_corr[k] << 1);\n<257> prod = av_clipl_int32((int64_t)temp_corr[k] * temp_corr[k]);
<1> static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n<2> hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n<3> if ( unlikely ( ! c ) ) return NULL ;
<1> static void do_video_out(AVFormatContext *s,\n<151> if (!check_recording_time(ost))\n<181> write_frame(s, &pkt, ost);\n<237> ret = avcodec_encode_video2(enc, &pkt, &big_picture, &got_packet);\n<283> write_frame(s, &pkt, ost);\n<295> if (ost->logfile && enc->stats_out) {\n<297> fprintf(ost->logfile, "%s", enc->stats_out);\n<329> do_video_stats(output_files[ost->file_index]->ctx, ost, frame_size);
<1> static int usb_host_handle_iso_data(USBHostDevice *s, USBPacket *p, int in)\n<63> printf("husb: received iso data is larger then packet\n");\n<91> if (len > max_packet_size) {\n<93> printf("husb: send iso data is larger then max packet size\n");
<1> static int xiph_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n<19> if (!data->split_buf || data->split_pos + 2 > data->split_buf_len ||\n<31> data->split_pos += 2;\n<41> if (av_new_packet(pkt, pkt_len)) {\n<51> memcpy(pkt->data, data->split_buf + data->split_pos, pkt_len);\n<53> data->split_pos += pkt_len;\n<81> num_pkts    = buf[3] & 0xf;\n<127> buf += 6; // move past header bits\n<135> if (av_new_packet(pkt, pkt_len)) {\n<145> memcpy(pkt->data, buf, pkt_len);\n<147> buf += pkt_len;\n<149> len -= pkt_len;\n<157> if (len > data->split_buf_size || !data->split_buf) {\n<159> av_freep(&data->split_buf);\n<161> data->split_buf_size = 2 * len;\n<165> if (!data->split_buf) {\n<169> av_free_packet(pkt);\n<177> memcpy(data->split_buf, buf, len);\n<179> data->split_buf_len = len;
<1> static gpgme_error_t status_handler ( void * opaque , int fd ) {\n<8> err = assuan_read_line ( uiserver -> assuan_ctx , & line , & linelen ) ;\n<12> else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\0' || line [ 3 ] == ' ' ) ) {\n<13> if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n<17> else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\0' || line [ 2 ] == ' ' ) ) {\n<27> else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> colon . fnc ) {\n<33> if ( uiserver -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n<34> char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n<35> if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n<37> * aline = newline ;\n<42> dst = * aline + * alinelen ;\n<58> err = uiserver -> colon . fnc ( uiserver -> colon . fnc_value , * aline ) ;\n<70> else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> inline_data ) {\n<98> else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n<101> rest = strchr ( line + 2 , ' ' ) ;\n<102> if ( ! rest ) rest = line + linelen ;\n<103> else * ( rest ++ ) = 0 ;\n<105> if ( r >= 0 ) {\n<108> else fprintf ( stderr , "[UNKNOWN STATUS]%s %s" , line + 2 , rest ) ;\n<111> else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\0' || line [ 7 ] == ' ' ) ) {
<1> FsTypeEntry *get_fsdev_fsentry(char *id)\n<11> if (strcmp(fsle->fse.fsdev_id, id) == 0) {\n<13> return &fsle->fse;\n<19> return NULL;
<1> static void tcg_liveness_analysis(TCGContext *s)\n<23> tcg_la_func_end(s, dead_temps, mem_temps);\n<83> if (!dead_temps[arg] || mem_temps[arg]) {\n<121> dead_temps[arg] = 1;\n<123> mem_temps[arg] = 0;\n<129> if (!(call_flags & TCG_CALL_NO_READ_GLOBALS)) {\n<133> memset(mem_temps, 1, s->nb_globals);\n<143> memset(dead_temps, 1, s->nb_globals);\n<163> dead_temps[arg] = 0;\n<187> dead_temps[args[0]] = 1;\n<189> mem_temps[args[0]] = 0;\n<231> if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n<233> if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n<307> if (dead_temps[args[1]] && !mem_temps[args[1]]) {\n<309> if (dead_temps[args[0]] && !mem_temps[args[0]]) {\n<325> } else if (have_opc_new2 && dead_temps[args[0]]\n<327> && !mem_temps[args[0]]) {\n<375> if (!dead_temps[arg] || mem_temps[arg]) {\n<385> tcg_op_remove(s, op);\n<413> dead_temps[arg] = 1;\n<415> mem_temps[arg] = 0;\n<425> tcg_la_bb_end(s, dead_temps, mem_temps);\n<427> } else if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n<431> memset(mem_temps, 1, s->nb_globals);\n<449> dead_temps[arg] = 0;
<1> static int tosa_dac_recv(I2CSlave *s)\n<5> printf("%s: recv not supported!!!\n", __FUNCTION__);
<1> static void do_video_out(AVFormatContext *s,\n<133> ret = avcodec_receive_packet(enc, &pkt);\n<147> output_packet(s, &pkt, ost);\n<155> if (ost->logfile && enc->stats_out) {\n<157> fprintf(ost->logfile, "%s", enc->stats_out);
<1> vubr_backend_recv_cb(int sock, void *ctx)\n<65> if (!elem) {\n<73> if (elem->in_num < 1) {\n<75> fprintf(stderr, "virtio-net contains no in buffers\n");\n<101> iov_from_buf(sg, elem->in_num, 0, &hdr, sizeof hdr);\n<137> iov_restore_front(elem->in_sg, sg, hdrlen);\n<143> if (ret == -1) {\n<145> if (errno == EWOULDBLOCK) {\n<163> iov_truncate(elem->in_sg, elem->in_num, total);\n<165> vu_queue_fill(dev, vq, elem, total, i++);\n<169> free(elem);\n<171> elem = NULL;\n<197> free(elem);
<1> static void steamdiscover_dissect_body_status ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n<21> switch ( tag . field_number ) {\n<37> hostname = tvb_get_string_enc ( strpool , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n<38> if ( hostname && strlen ( hostname ) ) {\n<39> col_add_fstr ( pinfo -> cinfo , COL_INFO , "%s from %s" , hf_steam_ihs_discovery_header_msgtype_strings [ STEAMDISCOVER_MSGTYPE_CLIENTBROADCASTMSGSTATUS ] . strptr , hostname ) ;
<1> static int qcow2_create(const char *filename, QemuOpts *opts, Error **errp)\n<73> if (!buf) {\n<77> } else if (!strcmp(buf, "0.10")) {\n<79> version = 2;\n<81> } else if (!strcmp(buf, "1.1")) {\n<83> version = 3;\n<87> error_setg(errp, "Invalid compatibility level: '%s'", buf);\n<89> ret = -EINVAL;\n<97> if (qemu_opt_get_bool_del(opts, BLOCK_OPT_LAZY_REFCOUNTS, false)) {\n<105> if (backing_file && prealloc != PREALLOC_MODE_OFF) {\n<191> g_free(buf);
<1> static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n<105> tight_encode_indexed_rect32(vs->tight.buffer, w * h, palette);\n<109> tight_encode_indexed_rect16(vs->tight.buffer, w * h, palette);\n<123> buf = qemu_malloc(w * 3);\n<129> if (color_type == PNG_COLOR_TYPE_PALETTE) {\n<131> memcpy(buf, vs->tight.buffer + (dy * w), w);\n<135> rgb_prepare_row(vs, buf, x, y + dy, w);\n<139> png_write_row(png_ptr, buf);
<1> static void error(const char *fmt, ...)\n<9> fprintf(stderr, "qemu-img: ");\n<11> vfprintf(stderr, fmt, ap);\n<13> fprintf(stderr, "\n");
<1> static void vfio_pci_load_rom(VFIOPCIDevice *vdev)\n<45> if (!vdev->rom_size) {\n<65> vdev->rom = g_malloc(size);\n<67> memset(vdev->rom, 0xff, size);\n<73> bytes = pread(vdev->vbasedev.fd, vdev->rom + off,
<1> static int qcow2_create2(const char *filename, int64_t total_size,\n<85> if (ret < 0) {\n<97> memset(&header, 0, sizeof(header));\n<143> ret = bdrv_pwrite(bs, 0, &header, sizeof(header));
<1> static int compile_kernel_file(GPUEnv *gpu_env, const char *build_options)\n<9> size_t source_str_len = 0;\n<17> if (!gpu_env->kernel_code[i].is_compiled)\n<19> source_str_len += strlen(gpu_env->kernel_code[i].kernel_string);\n<23> if (!source_str_len) {\n<37> temp = source_str;\n<41> if (!gpu_env->kernel_code[i].is_compiled) {\n<43> memcpy(temp, gpu_env->kernel_code[i].kernel_string,\n<45> strlen(gpu_env->kernel_code[i].kernel_string));\n<49> temp += strlen(gpu_env->kernel_code[i].kernel_string);
<1> static void kvm_get_fallback_smmu_info(PowerPCCPU *cpu,\n<3> struct kvm_ppc_smmu_info *info)\n<13> memset(info, 0, sizeof(*info));\n<109> info->flags |= KVM_PPC_1T_SEGMENTS;
<1> uint32_t vfio_pci_read_config(PCIDevice *pdev, uint32_t addr, int len)\n<5> VFIOPCIDevice *vdev = DO_UPCAST(VFIOPCIDevice, pdev, pdev);\n<7> uint32_t emu_bits = 0, emu_val = 0, phys_val = 0, val;\n<11> memcpy(&emu_bits, vdev->emulated_config_bits + addr, len);\n<13> emu_bits = le32_to_cpu(emu_bits);\n<19> emu_val = pci_default_read_config(pdev, addr, len);\n<25> if (~emu_bits & (0xffffffffU >> (32 - len * 8))) {\n<53> val = (emu_val & emu_bits) | (phys_val & ~emu_bits);
<1> static int ipvideo_decode_block_opcode_0xA(IpvideoContext *s)\n<7> unsigned char P[4];\n<21> if (s->stream_ptr[0] <= s->stream_ptr[1]) {\n<35> if (!(y & 3)) {\n<37> memcpy(P, s->stream_ptr, 4);\n<39> s->stream_ptr += 4;\n<41> flags = bytestream_get_le32(&s->stream_ptr);\n<49> *s->pixel_ptr++ = P[flags & 0x03];\n<67> int vert = s->stream_ptr[12] <= s->stream_ptr[13];\n<83> if (!(y & 7)) {\n<85> memcpy(P, s->stream_ptr, 4);\n<87> s->stream_ptr += 4;\n<89> flags = bytestream_get_le64(&s->stream_ptr);\n<97> *s->pixel_ptr++ = P[flags & 0x03];
<1> static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n<31> if (!f) {\n<49> if (fgets(line, sizeof(line), f) == NULL) {\n<55> if (strlen(line) > 0) {\n<57> line[strlen(line) - 1] = '\0';\n<61> if (line[0] == 'T' && line[1] == ':') {\n<63> if (device_count && (vendor_id || product_id)) {\n<71> if (ret) {\n<79> if (get_tag_value(buf, sizeof(buf), line, "Bus=", " ") < 0) {\n<87> if (get_tag_value(buf, sizeof(buf), line, "Dev#=", " ") < 0) {\n<95> if (get_tag_value(buf, sizeof(buf), line, "Spd=", " ") < 0) {\n<101> if (!strcmp(buf, "5000")) {\n<103> speed = USB_SPEED_SUPER;\n<105> } else if (!strcmp(buf, "480")) {\n<107> speed = USB_SPEED_HIGH;\n<109> } else if (!strcmp(buf, "1.5")) {\n<111> speed = USB_SPEED_LOW;\n<115> speed = USB_SPEED_FULL;\n<129> } else if (line[0] == 'P' && line[1] == ':') {\n<131> if (get_tag_value(buf, sizeof(buf), line, "Vendor=", " ") < 0) {\n<137> vendor_id = strtoul(buf, NULL, 16);\n<139> if (get_tag_value(buf, sizeof(buf), line, "ProdID=", " ") < 0) {\n<145> product_id = strtoul(buf, NULL, 16);\n<147> } else if (line[0] == 'S' && line[1] == ':') {\n<149> if (get_tag_value(buf, sizeof(buf), line, "Product=", "") < 0) {\n<157> } else if (line[0] == 'D' && line[1] == ':') {\n<159> if (get_tag_value(buf, sizeof(buf), line, "Cls=", " (") < 0) {\n<165> class_id = strtoul(buf, NULL, 16);\n<173> if (device_count && (vendor_id || product_id)) {\n<187> fclose(f);
<1> void virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n<79> switch (type & ~(VIRTIO_BLK_T_OUT | VIRTIO_BLK_T_BARRIER)) {\n<189> const char *serial = s->conf.serial ? s->conf.serial : "";\n<191> size_t size = MIN(strlen(serial) + 1,\n<197> iov_from_buf(in_iov, in_num, 0, serial, size);
<1> int set_wep_key ( char * string ) {\n<5> char s [ strlen ( string ) + 1 ] ;\n<9> memset ( GBL_WIFI -> wkey , 0 , sizeof ( GBL_WIFI -> wkey ) ) ;\n<11> strcpy ( s , string ) ;\n<33> USER_MSG ( "Using WEP key: %s\n" , str_tohex ( tmp_wkey , tmp_wkey_len , tmp , sizeof ( tmp ) ) ) ;\n<34> memcpy ( GBL_WIFI -> wkey , tmp_wkey , sizeof ( GBL_WIFI -> wkey ) ) ;
<1> static int vivo_probe(AVProbeData *p)\n<21> c = *buf++;\n<27> c = *buf++;\n<33> if (c & 0x80 || length > 1024 || length < 21)\n<39> if (memcmp(buf, "\r\nVersion:Vivo/", 15))\n<41> return 0;\n<43> buf += 15;\n<47> if (*buf < '0' && *buf > '2')
<1> static int ipvideo_decode_frame(AVCodecContext *avctx,\n<13> IpvideoContext *s = avctx->priv_data;\n<103> if (pal && size == AVPALETTE_SIZE) {\n<107> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<119> ipvideo_decode_opcodes(s, frame);
<1> static void ide_atapi_identify(IDEState *s)\n<9> if (s->identify_set) {\n<11> memcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));\n<19> memset(s->io_buffer, 0, 512);\n<21> p = (uint16_t *)s->io_buffer;\n<99> memcpy(s->identify_data, p, sizeof(s->identify_data));
<1> static ssize_t gem_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n<15> uint8_t    rxbuf[2048];\n<37> if (gem_mac_address_filter(s, buf) == GEM_RX_REJECT) {\n<55> type_len = buf[12] << 8 | buf[13];\n<61> if (size < type_len) {\n<103> if (s->regs[GEM_NWCFG] & GEM_NWCFG_STRIP_FCS) {\n<123> memcpy(rxbuf, buf, size);\n<125> memset(rxbuf + size, 0, sizeof(rxbuf) - size);\n<129> crc_val = cpu_to_le32(crc32(0, rxbuf, MAX(size, 60)));\n<133> crc_offset = 60;\n<137> crc_offset = size;\n<141> memcpy(rxbuf + crc_offset, &crc_val, sizeof(crc_val));\n<301> gem_receive_updatestats(s, buf, size);
<1> static void kbd_write_command(void *opaque, hwaddr addr,\n<29> if((val & KBD_CCMD_PULSE_BITS_3_0) == KBD_CCMD_PULSE_BITS_3_0) {\n<33> val = KBD_CCMD_RESET;\n<37> val = KBD_CCMD_NO_OP;\n<43> switch(val) {\n<163> fprintf(stderr, "qemu: unsupported keyboard cmd=0x%02x\n", (int)val);
<1> static void dynticks_rearm_timer(struct qemu_alarm_timer *t)\n<29> if (timer_gettime(host_timer, &timeout)) {\n<33> fprintf(stderr, "Internal timer error: aborting\n");\n<55> if (timer_settime(host_timer, 0 /* RELATIVE */, &timeout, NULL)) {\n<59> fprintf(stderr, "Internal timer error: aborting\n");
<1> static int sd_parse_uri(BDRVSheepdogState *s, const char *filename,\n<17> if (!uri) {\n<27> if (!strcmp(uri->scheme, "sheepdog")) {\n<29> s->is_unix = false;\n<31> } else if (!strcmp(uri->scheme, "sheepdog+tcp")) {\n<33> s->is_unix = false;\n<35> } else if (!strcmp(uri->scheme, "sheepdog+unix")) {\n<37> s->is_unix = true;\n<41> ret = -EINVAL;\n<49> if (uri->path == NULL || !strcmp(uri->path, "/")) {\n<51> ret = -EINVAL;\n<57> pstrcpy(vdi, SD_MAX_VDI_LEN, uri->path + 1);\n<61> qp = query_params_parse(uri->query);\n<63> if (qp->n > 1 || (s->is_unix && !qp->n) || (!s->is_unix && qp->n)) {\n<73> if (s->is_unix) {\n<77> if (uri->server || uri->port || strcmp(qp->p[0].name, "socket")) {\n<79> ret = -EINVAL;\n<85> s->host_spec = g_strdup(qp->p[0].value);\n<101> if (uri->fragment) {\n<127> uri_free(uri);
<1> static int vpc_create(const char *filename, QEMUOptionParameter *options)\n<5> uint8_t buf[1024];\n<7> struct vhd_footer *footer = (struct vhd_footer *) buf;\n<37> if (disk_type_param && disk_type_param->value.s) {\n<39> if (!strcmp(disk_type_param->value.s, "dynamic")) {\n<41> disk_type = VHD_DYNAMIC;\n<43> } else if (!strcmp(disk_type_param->value.s, "fixed")) {\n<45> disk_type = VHD_FIXED;\n<49> return -EINVAL;\n<63> fd = qemu_open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);\n<65> if (fd < 0) {\n<85> for (i = 0; total_sectors > (int64_t)cyls * heads * secs_per_cyl; i++) {\n<109> memset(buf, 0, 1024);\n<113> memcpy(footer->creator, "conectix", 8);\n<117> memcpy(footer->creator_app, "qemu", 4);\n<119> memcpy(footer->creator_os, "Wi2k", 4);\n<177> footer->checksum = be32_to_cpu(vpc_checksum(buf, HEADER_SIZE));
<1> event_thread(void *arg)\n<33> if (reader_id == VSCARD_UNDEFINED_READER_ID &&\n<75> if (reader_id == VSCARD_UNDEFINED_READER_ID) {\n<113> reader_name = vreader_get_name(event->reader);\n<115> if (verbose > 10) {\n<117> printf(" READER INSERT: %s\n", reader_name);\n<133> if (verbose > 10) {\n<135> printf(" READER REMOVE: %u\n", reader_id);\n<139> send_msg(VSC_ReaderRemove, reader_id, NULL, 0);\n<155> if (verbose > 10) {\n<157> printf(" CARD INSERT %u: ", reader_id);\n<163> send_msg(VSC_ATR, reader_id, atr, atr_len);\n<171> if (verbose > 10) {\n<173> printf(" CARD REMOVE %u:\n", reader_id);\n<177> send_msg(VSC_CardRemove, reader_id, NULL, 0);
<1> static CharDriverState *qemu_chr_open_socket_fd(int fd, bool do_nodelay,\n<21> socklen_t ss_len = sizeof(ss);\n<25> memset(&ss, 0, ss_len);\n<27> if (getsockname(fd, (struct sockaddr *) &ss, &ss_len) != 0) {\n<59> chr->filename = g_malloc(256);\n<71> ((struct sockaddr_un *)(&ss))->sun_path,\n<91> getnameinfo((struct sockaddr *) &ss, ss_len, host, sizeof(host),\n<139> s->listen_tag = g_io_add_watch(s->listen_chan, G_IO_IN, tcp_chr_accept, chr);\n<157> tcp_chr_connect(chr);\n<163> if (is_listen && is_waitconnect) {\n<165> fprintf(stderr, "QEMU waiting for connection on: %s\n",\n<169> tcp_chr_accept(s->listen_chan, G_IO_IN, chr);\n<175> return chr;
<1> static void connex_init(ram_addr_t ram_size, int vga_ram_size,\n<17> uint32_t connex_rom = 0x01000000;\n<19> uint32_t connex_ram = 0x04000000;\n<23> if (ram_size < (connex_ram + connex_rom + PXA2XX_INTERNAL_SIZE)) {\n<25> fprintf(stderr, "This platform requires %i bytes of memory\n",\n<41> if (index == -1) {\n<43> fprintf(stderr, "A flash image must be given with the "\n<53> if (!pflash_cfi01_register(0x00000000, qemu_ram_alloc(connex_rom),\n<59> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> static void virtio_net_set_config(VirtIODevice *vdev, const uint8_t *config)\n<5> VirtIONet *n = VIRTIO_NET(vdev);\n<7> struct virtio_net_config netcfg = {};\n<11> memcpy(&netcfg, config, n->config_size);\n<15> if (!(vdev->guest_features >> VIRTIO_NET_F_CTRL_MAC_ADDR & 1) &&\n<17> memcmp(netcfg.mac, n->mac, ETH_ALEN)) {\n<19> memcpy(n->mac, netcfg.mac, ETH_ALEN);\n<21> qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);
<13> ret = h264_slice_header_parse(h, sl, nal);\n<107> av_assert0(sl == h->slice_ctx);\n<167> ret = h264_field_start(h, sl, nal, first_slice);\n<219> FIELD_OR_MBAFF_PICTURE(h);\n<229> if (!h->setup_finished) {\n<237> memcpy(h->mmco, sl->mmco, sl->nb_mmco * sizeof(*h->mmco));\n<247> ret = ff_h264_build_ref_list(h, sl);\n<259> implicit_weight_table(h, sl, -1);\n<261> if (FRAME_MBAFF(h)) {\n<263> implicit_weight_table(h, sl, 0);\n<265> implicit_weight_table(h, sl, 1);\n<275> ff_h264_direct_dist_scale_factor(h, sl);\n<277> ff_h264_direct_ref_list_init(h, sl);
<1> static int sd_open(BlockDriverState *bs, const char *filename, int flags)\n<31> memset(vdi, 0, sizeof(vdi));\n<33> memset(tag, 0, sizeof(tag));\n<35> if (parse_vdiname(s, filename, vdi, &snapid, tag) < 0) {\n<55> ret = find_vdi_name(s, vdi, snapid, tag, &vid, 0);\n<127> ret = read_object(fd, buf, vid_to_vdi_oid(vid), 0, SD_INODE_SIZE, 0,\n<137> if (ret) {\n<145> memcpy(&s->inode, buf, sizeof(s->inode));\n<159> g_free(buf);
<1> static void multiwrite_help(void)
<1> int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) {\n<8> if ( ! file_read ( frame , 6 , _fin ) ) return 0 ;\n<9> if ( memcmp ( frame , "FRAME" , 5 ) ) {\n<10> fprintf ( stderr , "Loss of framing in Y4M input data\n" ) ;\n<11> return - 1 ;\n<13> if ( frame [ 5 ] != '\n' ) {\n<20> if ( j == 79 ) {\n<21> fprintf ( stderr , "Error parsing Y4M frame header\n" ) ;\n<25> if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) {\n<26> fprintf ( stderr , "Error reading Y4M frame data.\n" ) ;\n<29> if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {\n<30> fprintf ( stderr , "Error reading Y4M frame data.\n" ) ;\n<34> memset ( _img , 0 , sizeof ( * _img ) ) ;
<1> void virtio_scsi_set_iothread(VirtIOSCSI *s, IOThread *iothread)\n<21> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {\n<23> fprintf(stderr, "virtio-scsi: Failed to set iothread "
<1> static int ohci_service_td(OHCIState *ohci, struct ohci_ed *ed)\n<51> if (!ohci_read_td(ohci, addr, &td)) {\n<53> fprintf(stderr, "usb-ohci: TD read error at %x\n", addr);\n<83> switch (dir) {\n<123> fprintf(stderr, "usb-ohci: Bad direction\n");\n<339> if (ret >= 0) {\n<347> switch (ret) {\n<377> fprintf(stderr, "usb-ohci: Bad device response %d\n", ret);
<1> static ObjectClass *alpha_cpu_class_by_name(const char *cpu_model)\n<21> oc = object_class_by_name(cpu_model);\n<33> for (i = 0; i < ARRAY_SIZE(alpha_cpu_aliases); i++) {\n<35> if (strcmp(cpu_model, alpha_cpu_aliases[i].alias) == 0) {\n<37> oc = object_class_by_name(alpha_cpu_aliases[i].typename);\n<39> assert(oc != NULL && !object_class_is_abstract(oc));\n<41> return oc;
<13> CinVideoContext *cin = avctx->priv_data;\n<47> cin->palette[i] = 0xFFU << 24 | bytestream_get_le24(&buf);\n<57> cin->palette[buf[0]] = 0xFFU << 24 | AV_RL24(buf+1);\n<87> cin_apply_delta_data(cin->bitmap_table[CIN_PRE_BMP],\n<99> cin_decode_rle(cin->bitmap_table[CIN_INT_BMP], bitmap_frame_size,\n<115> cin_apply_delta_data(cin->bitmap_table[CIN_PRE_BMP],\n<155> cin_apply_delta_data(cin->bitmap_table[CIN_PRE_BMP],\n<167> if ((res = avctx->reget_buffer(avctx, &cin->frame))) {\n<177> memcpy(cin->frame.data[1], cin->palette, sizeof(cin->palette));\n<181> for (y = 0; y < cin->avctx->height; ++y)\n<183> memcpy(cin->frame.data[0] + (cin->avctx->height - 1 - y) * cin->frame.linesize[0],\n<185> cin->bitmap_table[CIN_CUR_BMP] + y * cin->avctx->width,
<1> static int nprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *n_val)\n<13> if (!enc_header || !n_val)\n<21> if (!memcmp(&enc_header[pos], "EKB ", 4))\n<23> pos += 32;\n<27> if (AV_RB32(&enc_header[pos]) != oc->rid)\n<47> av_des_crypt(&av_des, oc->r_val, &enc_header[pos], 2, NULL, 1);\n<51> if (!rprobe(s, enc_header, oc->r_val))
<1> static void ehci_execute_complete(EHCIQueue *q)\n<9> assert(p != NULL);\n<25> if (p->usb_status < 0) {\n<27> switch (p->usb_status) {\n<67> fprintf(stderr, "USB invalid response %d\n", p->usb_status);\n<107> ehci_finish_transfer(q, p->usb_status);
<1> static void write_audio_frame(AVFormatContext *oc, AVStream *st)\n<63> if (ret < 0) {\n<65> fprintf(stderr, "Error while converting\n");\n<93> if (ret < 0) {\n<95> fprintf(stderr, "Error encoding audio frame: %s\n", av_err2str(ret));\n<111> if (ret != 0) {\n<113> fprintf(stderr, "Error while writing audio frame: %s\n",\n<115> av_err2str(ret));
<1> void tcp_connect(struct socket *inso)\n<53> if (tcp_attach(so) < 0) {\n<55> free(so); /* NOT sofree */
<1> static int dirac_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *pkt)\n<21> if (s->all_frames[i].avframe.data[0] && !s->all_frames[i].avframe.reference) {\n<25> memset(s->all_frames[i].interpolated, 0, sizeof(s->all_frames[i].interpolated));
<1> static inline CopyRet copy_frame(AVCodecContext *avctx,\n<41> uint8_t *src = output->Ybuff;\n<117> bwidth = av_image_get_linesize(avctx->pix_fmt, width, 0);\n<149> dst     = priv->pic.data[0];\n<183> for (sY = 0; sY < height; dY++, sY++) {\n<185> memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);
<19> ape_apply_filters(ctx, ctx->decoded[0], NULL, count);\n<31> if (ctx->channels == 2) {\n<33> memcpy(ctx->decoded[1], ctx->decoded[0], count * sizeof(*ctx->decoded[1]));
<1> int ff_MPV_frame_start ( MpegEncContext * s , AVCodecContext * avctx ) {\n<6> if ( s -> pict_type != AV_PICTURE_TYPE_B && s -> last_picture_ptr && s -> last_picture_ptr != s -> next_picture_ptr && s -> last_picture_ptr -> f . data [ 0 ] ) {\n<57> if ( ( s -> last_picture_ptr == NULL || s -> last_picture_ptr -> f . data [ 0 ] == NULL ) && ( s -> pict_type != AV_PICTURE_TYPE_I || s -> picture_structure != PICT_FRAME ) ) {\n<68> if ( ff_alloc_picture ( s , s -> last_picture_ptr , 0 ) < 0 ) {\n<72> memset ( s -> last_picture_ptr -> f . data [ 0 ] , 0 , avctx -> height * s -> last_picture_ptr -> f . linesize [ 0 ] ) ;\n<73> memset ( s -> last_picture_ptr -> f . data [ 1 ] , 0x80 , ( avctx -> height >> v_chroma_shift ) * s -> last_picture_ptr -> f . linesize [ 1 ] ) ;\n<74> memset ( s -> last_picture_ptr -> f . data [ 2 ] , 0x80 , ( avctx -> height >> v_chroma_shift ) * s -> last_picture_ptr -> f . linesize [ 2 ] ) ;\n<101> assert ( s -> pict_type == AV_PICTURE_TYPE_I || ( s -> last_picture_ptr && s -> last_picture_ptr -> f . data [ 0 ] ) ) ;
<1> static DevicePropertyInfo *make_device_property_info(ObjectClass *klass,\n<3> const char *name,\n<19> for (prop = DEVICE_CLASS(klass)->props; prop && prop->name; prop++) {\n<21> if (strcmp(name, prop->name) != 0) {\n<41> if (!prop->info->set) {\n<51> info->name = g_strdup(prop->name);\n<73> info->name = g_strdup(name);
<1> static void ehci_advance_state(EHCIState *ehci,\n<47> switch(ehci_get_state(ehci, async)) {\n<147> fprintf(stderr, "Bad state!\n");\n<159> if (again < 0) {\n<161> fprintf(stderr, "processing error - resetting ehci HC\n");
<1> static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *insamples)\n<41> if (!outpicref)\n<59> memset(outpicref->data[0], 0, showwaves->h*linesize);\n<69> *(outpicref->data[0] + showwaves->buf_idx + h * linesize) += x;
<1> static int dash_init(AVFormatContext *s)\n<69> OutputStream *os = &c->streams[i];\n<145> ctx->oformat = av_guess_format(os->format_name, NULL, NULL);\n<207> if (ret < 0)\n<215> if (!strcmp(os->format_name, "mp4")) {\n<217> av_dict_set(&opts, "movflags", "frag_custom+dash+delay_moov", 0);\n<221> av_dict_set_int(&opts, "cluster_time_limit", c->min_seg_duration / 1000, 0);\n<223> av_dict_set_int(&opts, "cluster_size_limit", 5 * 1024 * 1024, 0); // set a large cluster size limit\n<225> av_dict_set_int(&opts, "dash", 1, 0);\n<227> av_dict_set_int(&opts, "dash_track_number", i + 1, 0);\n<229> av_dict_set_int(&opts, "live", 1, 0);\n<233> if ((ret = avformat_init_output(ctx, &opts)) < 0)\n<255> if (strcmp(os->format_name, "mp4")) {\n<257> flush_init_segment(s, os);
<1> static ssize_t rtl8139_do_receive(VLANClientState *nc, const uint8_t *buf, size_t size_, int do_interrupt)\n<15> uint8_t buf1[60];\n<59> if (s->RxConfig & AcceptAllPhys) {\n<69> if (!memcmp(buf,  broadcast_macaddr, 6)) {\n<73> if (!(s->RxConfig & AcceptBroadcast))\n<107> } else if (buf[0] & 0x01) {\n<131> int mcast_idx = compute_mcast_idx(buf);\n<169> } else if (s->phys[0] == buf[0] &&\n<171> s->phys[1] == buf[1] &&\n<173> s->phys[2] == buf[2] &&\n<175> s->phys[3] == buf[3] &&\n<177> s->phys[4] == buf[4] &&\n<179> s->phys[5] == buf[5]) {\n<241> if (size < MIN_BUF_SIZE) {\n<243> memcpy(buf1, buf, size);\n<245> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<247> buf = buf1;\n<417> cpu_physical_memory_write( rx_addr, buf, size );\n<639> rtl8139_write_buffer(s, buf, size);
<1> ResampleContext *ff_audio_resample_init(AVAudioResampleContext *avr)\n<113> if (!c->filter_bank)\n<119> if (build_filter(c) < 0)\n<125> memcpy(&c->filter_bank[(c->filter_length * phase_count + 1) * felem_size],\n<127> c->filter_bank, (c->filter_length - 1) * felem_size);\n<129> memcpy(&c->filter_bank[c->filter_length * phase_count * felem_size],\n<131> &c->filter_bank[(c->filter_length - 1) * felem_size], felem_size);\n<177> return c;\n<185> av_free(c->filter_bank);
<1> static uint64_t *store_bitmap_data(BlockDriverState *bs,\n<121> if (write_size < s->cluster_size) {\n<123> memset(buf + write_size, 0, s->cluster_size - write_size);
<1> static void do_smbios_option(const char *optarg)\n<5> if (smbios_entry_add(optarg) < 0) {\n<7> fprintf(stderr, "Wrong smbios provided\n");
<1> static void msvideo1_decode_8bit(Msvideo1Context *s)\n<31> unsigned char colors[8];\n<119> colors[0] = s->buf[stream_ptr++];\n<121> colors[1] = s->buf[stream_ptr++];\n<129> pixels[pixel_ptr++] = colors[(flags & 0x1) ^ 1];\n<135> } else if (byte_b >= 0x90) {\n<145> memcpy(colors, &s->buf[stream_ptr], 8);\n<169> colors[0] = byte_a;\n<177> pixels[pixel_ptr++] = colors[0];\n<199> if (s->avctx->pix_fmt == PIX_FMT_PAL8)\n<201> memcpy(s->frame.data[1], s->palette, PALETTE_COUNT * 4);
<16> static void feature_destroy ( hb_feature_t * g ) {\n<17> free ( g ) ;\n<19> HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n<20> hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n<21> if ( unlikely ( ! c ) ) return NULL ;
<1> static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n<61> if (offset > INT64_MAX - s->cluster_size) {\n<75> if (ret < 0) {\n<85> if (size < 0) {\n<115> if (cluster >= *nb_clusters) {\n<153> fprintf(stderr, "ERROR could not resize image: %s\n",\n<155> strerror(-ret));
<1> static unsigned int dec_addu_r(DisasContext *dc)\n<7> int size = memsize_z(dc);\n<11> memsize_char(size),\n<17> cris_cc_mask(dc, CC_MASK_NZVC);
<1> void ff_print_debug_info2(AVCodecContext *avctx, AVFrame *pict, uint8_t *mbskip_table,\n<31> if (!mvs)\n<155> if (!sd) {\n<163> memcpy(sd->data, mvs, mbcount * sizeof(AVMotionVector));\n<169> av_freep(&mvs);
<1> void address_space_rw(AddressSpace *as, hwaddr addr, uint8_t *buf,\n<27> if (l > len)\n<29> l = len;\n<79> } else if (!section->readonly) {\n<89> ptr = qemu_get_ram_ptr(addr1);\n<91> memcpy(ptr, buf, l);\n<93> invalidate_and_set_dirty(addr1, l);\n<151> memcpy(buf, ptr, l);\n<157> len -= l;\n<159> buf += l;\n<161> addr += l;
<1> int av_opt_set(void *obj, const char *name, const char *val, int search_flags)\n<37> switch (o->type) {\n<107> if (!val || !strcmp(val, "none")) {\n<109> *(int64_t *)dst = 0;\n<113> int64_t cl = av_get_channel_layout(val);\n<115> if (!cl) {\n<123> *(int64_t *)dst = cl;\n<125> return ret;\n<135> av_log(obj, AV_LOG_ERROR, "Invalid option type.\n");\n<137> return AVERROR(EINVAL);
<1> static UserDefTwo *nested_struct_create(void)\n<7> udnp->string0 = strdup("test_string0");\n<11> udnp->dict1->string1 = strdup("test_string1");\n<21> udnp->dict1->dict2->userdef->string = strdup("test_string");\n<23> udnp->dict1->dict2->string = strdup("test_string2");\n<35> udnp->dict1->dict3->userdef->string = strdup("test_string");\n<37> udnp->dict1->dict3->string = strdup("test_string3");\n<39> return udnp;
<1> static void qemu_rbd_complete_aio(RADOSCB *rcb)\n<33> if (r < 0) {\n<35> memset(rcb->buf, 0, rcb->size);\n<41> } else if (r < rcb->size) {\n<43> memset(rcb->buf + r, 0, rcb->size - r);\n<65> g_free(rcb);
<1> static void add_pc_test_case(const char *mname)\n<31> if (g_str_has_suffix(mname, "-1.4") ||\n<33> (strcmp(mname, "pc-1.3") == 0) ||\n<35> (strcmp(mname, "pc-1.2") == 0) ||\n<37> (strcmp(mname, "pc-1.1") == 0) ||\n<39> (strcmp(mname, "pc-1.0") == 0) ||\n<41> (strcmp(mname, "pc-0.15") == 0) ||\n<43> (strcmp(mname, "pc-0.14") == 0) ||\n<45> (strcmp(mname, "pc-0.13") == 0) ||\n<47> (strcmp(mname, "pc-0.12") == 0) ||\n<49> (strcmp(mname, "pc-0.11") == 0) ||\n<51> (strcmp(mname, "pc-0.10") == 0)) {\n<53> path = g_strdup_printf("cpu/%s/init/%ux%ux%u&maxcpus=%u",\n<67> path = g_strdup_printf("cpu/%s/add/%ux%ux%u&maxcpus=%u",
<1> matroska_read_header (AVFormatContext    *s,\n<25> if ((res = ebml_read_header(matroska, &doctype, &version)) < 0)\n<29> if ((doctype == NULL) || strcmp(doctype, "matroska")) {\n<31> av_log(matroska->ctx, AV_LOG_ERROR,\n<35> doctype ? doctype : "(none)");\n<37> if (doctype)\n<39> av_free(doctype);\n<41> return AVERROR_NOFMT;\n<45> av_free(doctype);\n<47> if (version > 2) {\n<287> int extradata_offset = 0;\n<289> track = matroska->tracks[i];\n<297> if ((track->type == MATROSKA_TRACK_TYPE_SUBTITLE) ||\n<299> (track->codec_id == NULL))\n<305> for(j=0; codec_tags[j].str; j++){\n<309> strlen(codec_tags[j].str))){\n<331> (track->codec_priv_size >= 40) &&\n<333> (track->codec_priv != NULL)) {\n<341> p = (unsigned char *)track->codec_priv + 16;\n<343> ((MatroskaVideoTrack *)track)->fourcc = (p[3] << 24) |\n<345> (p[2] << 16) | (p[1] << 8) | p[0];\n<347> codec_id = codec_get_id(codec_bmp_tags, ((MatroskaVideoTrack *)track)->fourcc);\n<359> else if (!strcmp(track->codec_id,\n<363> (track->codec_priv_size >= 18) &&\n<365> (track->codec_priv != NULL)) {\n<375> p = (unsigned char *)track->codec_priv;\n<377> tag = (p[1] << 8) | p[0];\n<379> codec_id = codec_get_id(codec_wav_tags, tag);\n<387> else if (codec_id == CODEC_ID_MPEG1VIDEO ||\n<397> track->flags |= MATROSKA_TRACK_REORDER;\n<403> else if (codec_id == CODEC_ID_AAC && !track->codec_priv_size) {\n<405> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;\n<407> int profile = matroska_aac_profile(track->codec_id);\n<413> if (extradata == NULL)\n<421> if (strstr(track->codec_id, "SBR")) {\n<423> sri = matroska_aac_sri(audiotrack->samplerate);\n<425> extradata[2] = 0x56;\n<427> extradata[3] = 0xE5;\n<429> extradata[4] = 0x80 | (sri<<3);\n<431> extradata_size = 5;\n<435> extradata_size = 2;\n<439> track->default_duration = 1024*1000 / audiotrack->internal_samplerate;\n<447> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;\n<483> extradata_offset = 26;\n<485> track->codec_priv_size -= extradata_offset;\n<487> track->flags |= MATROSKA_TRACK_REAL_V;\n<493> if (codec_id == CODEC_ID_NONE) {\n<505> track->stream_index = matroska->num_streams;\n<509> matroska->num_streams++;\n<511> st = av_new_stream(s, track->stream_index);\n<513> if (st == NULL)\n<527> av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,\n<539> } else if(track->codec_priv && track->codec_priv_size > 0){\n<541> st->codec->extradata = av_malloc(track->codec_priv_size);\n<543> if(st->codec->extradata == NULL)\n<547> st->codec->extradata_size = track->codec_priv_size;\n<549> memcpy(st->codec->extradata,track->codec_priv+extradata_offset,\n<557> if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n<559> MatroskaVideoTrack *videotrack = (MatroskaVideoTrack *)track;\n<589> } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n<591> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n<601> } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {
<1> static void dump_json_image_info_list(ImageInfoList *list)\n<21> printf("%s\n", qstring_get_str(str));
<1> static int voc_probe(AVProbeData *p)\n<9> if (p->buf_size < 26)\n<13> if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))\n<15> return 0;\n<17> version = p->buf[22] | (p->buf[23] << 8);\n<19> check = p->buf[24] | (p->buf[25] << 8);\n<21> if (~version + 0x1234 != check)
<1> void av_aes_crypt(AVAES *a, uint8_t *dst_, const uint8_t *src_,\n<11> av_aes_block        *iv = (av_aes_block *) iv_;\n<17> addkey(&a->state[1], src, &a->round_key[a->rounds]);\n<23> if (iv) {\n<25> addkey(&a->state[0], &a->state[0], iv);\n<27> memcpy(iv, src, 16);\n<37> addkey(&a->state[1], &a->state[1], iv);\n<41> addkey(dst, &a->state[0], &a->round_key[0]);\n<43> if (iv)\n<45> memcpy(iv, dst, 16);\n<49> src++;\n<51> dst++;
<1> int ff_h264_decode_mb_cavlc(H264Context *h){\n<143> if(IS_INTRA_PCM(mb_type)){\n<171> memset(h->non_zero_count[mb_xy], 16, 16);
<1> static int colo_packet_compare(Packet *ppkt, Packet *spkt)\n<15> if (ppkt->size == spkt->size) {\n<17> return memcmp(ppkt->data, spkt->data, spkt->size);
<1> static int sd_open(BlockDriverState *bs, QDict *options, int flags,\n<37> if (local_err) {\n<49> filename = qemu_opt_get(opts, "filename");\n<63> memset(vdi, 0, sizeof(vdi));\n<65> memset(tag, 0, sizeof(tag));\n<69> if (strstr(filename, "://")) {\n<71> ret = sd_parse_uri(s, filename, vdi, &snapid, tag);\n<75> ret = parse_vdiname(s, filename, vdi, &snapid, tag);\n<139> fd = connect_to_sdog(s, errp);\n<153> ret = read_object(fd, s->aio_context, buf, vid_to_vdi_oid(vid),\n<163> if (ret) {\n<173> memcpy(&s->inode, buf, sizeof(s->inode));\n<191> g_free(buf);
<1> struct omap_mpu_state_s *omap2420_mpu_init(MemoryRegion *sysmem,\n<31> if (s->cpu == NULL) {\n<33> fprintf(stderr, "Unable to find CPU definition\n");\n<439> if (!dinfo) {\n<441> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> int kvm_init(void)\n<59> if (s->fd == -1) {\n<61> fprintf(stderr, "Could not access KVM kernel module: %m\n");\n<73> if (ret < KVM_API_VERSION) {\n<81> fprintf(stderr, "kvm version too old\n");\n<89> if (ret > KVM_API_VERSION) {\n<93> fprintf(stderr, "kvm version not supported\n");\n<103> if (smp_cpus > max_vcpus) {\n<107> fprintf(stderr, "Number of SMP cpus requested (%d) exceeds max cpus "\n<117> if (max_cpus > max_vcpus) {\n<121> fprintf(stderr, "Number of hotpluggable cpus requested (%d) exceeds max cpus "\n<153> if (!missing_cap) {\n<161> if (missing_cap) {
<1> static void draw_bar(TestSourceContext *test, const uint8_t color[4],\n<33> for (plane = 0; frame->data[plane]; plane++) {\n<35> const int c = color[plane];\n<47> pw = AV_CEIL_RSHIFT(w, desc->log2_chroma_w);\n<57> pw = w;\n<67> p0 = p = frame->data[plane] + py * linesize + px;\n<69> memset(p, c, pw);\n<71> p += linesize;\n<73> for (i = 1; i < ph; i++, p += linesize)\n<75> memcpy(p, p0, pw);
<1> static int wv_read_packet(AVFormatContext *s,\n<7> WVContext *wc = s->priv_data;\n<27> samples = LE_32(wc->extra);\n<39> if(av_new_packet(pkt, wc->blksize + WV_EXTRA_SIZE) < 0)\n<43> memcpy(pkt->data, wc->extra, WV_EXTRA_SIZE);\n<45> ret = get_buffer(&s->pb, pkt->data + WV_EXTRA_SIZE, wc->blksize);\n<49> av_free_packet(pkt);\n<59> pkt->size = ret + WV_EXTRA_SIZE;
<1> static void skip_block (uint8_t *current, uint8_t *previous, int pitch, int x, int y) {\n<11> src = &previous[x + y*pitch];\n<13> dst = current;\n<17> for (i=0; i < 16; i++) {\n<19> memcpy (dst, src, 16);\n<21> src += pitch;\n<23> dst += pitch;
<1> static void check_mct(uint8_t *ref0, uint8_t *ref1, uint8_t *ref2,\n<11> call_ref(ref0, ref1, ref2, BUF_SIZE / sizeof(int32_t));\n<13> call_new(new0, new1, new2, BUF_SIZE / sizeof(int32_t));\n<15> if (memcmp(ref0, new0, BUF_SIZE) || memcmp(ref1, new1, BUF_SIZE) ||\n<17> memcmp(ref2, new2, BUF_SIZE))\n<19> fail();\n<21> bench_new(new0, new1, new2, BUF_SIZE / sizeof(int32_t));
<1> av_cold int ffv1_init_slice_contexts(FFV1Context *f)\n<21> for (i = 0; i < f->slice_count; i++) {\n<23> FFV1Context *fs = av_mallocz(sizeof(*fs));\n<25> int sx          = i % f->num_h_slices;\n<27> int sy          = i / f->num_h_slices;\n<29> int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n<31> int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n<33> int sys         = f->avctx->height *  sy      / f->num_v_slices;\n<35> int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n<37> f->slice_context[i] = fs;\n<39> memcpy(fs, f, sizeof(*fs));\n<41> memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n<45> fs->slice_width  = sxe - sxs;\n<47> fs->slice_height = sye - sys;\n<49> fs->slice_x      = sxs;\n<51> fs->slice_y      = sys;\n<55> fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n<59> if (!fs->sample_buffer)
<1> static int g723_1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<2> G723_1_Context * p = avctx -> priv_data ;\n<6> int dec_mode = buf [ 0 ] & 3 ;\n<19> if ( unpack_bitstream ( p , buf , buf_size ) < 0 ) {\n<25> if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n<30> if ( p -> cur_frame_type == ACTIVE_FRAME ) {\n<34> lsp_interpolate ( lpc , cur_lsp , p -> prev_lsp ) ;\n<35> memcpy ( p -> prev_lsp , cur_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n<36> memcpy ( p -> excitation , p -> prev_excitation , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<37> if ( ! p -> erased_frames ) {\n<38> int16_t * vector_ptr = p -> excitation + PITCH_MAX ;\n<44> gen_acb_excitation ( acb_vector , & p -> excitation [ SUBFRAME_LEN * i ] , p -> pitch_lag [ i >> 1 ] , & p -> subframe [ i ] , p -> cur_rate ) ;\n<53> vector_ptr = p -> excitation + PITCH_MAX ;\n<54> p -> interp_index = comp_interp_index ( p , p -> pitch_lag [ 1 ] , & p -> sid_gain , & p -> cur_gain ) ;\n<59> i += SUBFRAME_LEN , j ++ ) comp_ppf_coeff ( p , i , p -> pitch_lag [ j >> 1 ] , ppf + j , p -> cur_rate ) ;\n<67> memcpy ( p -> prev_excitation , p -> excitation + FRAME_LEN , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<71> if ( p -> erased_frames == 3 ) {\n<72> memset ( p -> excitation , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * p -> excitation ) ) ;\n<73> memset ( p -> prev_excitation , 0 , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<74> memset ( frame -> data [ 0 ] , 0 , ( FRAME_LEN + LPC_ORDER ) * sizeof ( int16_t ) ) ;\n<78> residual_interp ( p -> excitation , buf , p -> interp_index , p -> interp_gain , & p -> random_seed ) ;\n<79> memcpy ( p -> prev_excitation , buf + ( FRAME_LEN - PITCH_MAX ) , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<94> generate_noise ( p ) ;\n<95> lsp_interpolate ( lpc , p -> sid_lsp , p -> prev_lsp ) ;\n<96> memcpy ( p -> prev_lsp , p -> sid_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n<99> memcpy ( p -> audio , p -> synth_mem , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n<102> i += SUBFRAME_LEN , j ++ ) ff_celp_lp_synthesis_filter ( p -> audio + i , & lpc [ j * LPC_ORDER ] , audio + i , SUBFRAME_LEN , LPC_ORDER , 0 , 1 , 1 << 12 ) ;\n<103> memcpy ( p -> synth_mem , p -> audio + FRAME_LEN , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n<105> formant_postfilter ( p , lpc , p -> audio , out ) ;
<1> static int decode_plane10(UtvideoContext *c, int plane_no,\n<113> if (!slice_size) {\n<125> memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n<133> init_get_bits(&gb, c->slice_bits, slice_size * 8);
<1> static int laio_do_submit(int fd, struct qemu_laiocb *laiocb, off_t offset,\n<3> int type)\n<15> switch (type) {\n<33> fprintf(stderr, "%s: invalid AIO request type 0x%x.\n",
<1> int opt_default(void *optctx, const char *opt, const char *arg)\n<25> if (!strcmp(opt, "debug") || !strcmp(opt, "fdebug"))\n<27> av_log_set_level(AV_LOG_DEBUG);\n<31> if (!(p = strchr(opt, ':')))\n<33> p = opt + strlen(opt);\n<35> av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));\n<43> ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&\n<57> av_dict_set(&format_opts, opt, arg, FLAGS);\n<61> av_log(NULL, AV_LOG_VERBOSE, "Routing option %s to both codec and muxer layer\n", opt);\n<113> if (!consumed && !strcmp(opt, "sws_flags")) {\n<115> av_log(NULL, AV_LOG_WARNING, "Ignoring %s %s, due to disabled swscale\n", opt, arg);\n<117> consumed = 1;
<1> void cpu_loop(CPUUniCore32State *env)\n<19> trapnr = uc32_cpu_exec(cs);\n<21> cpu_exec_end(cs);\n<145> fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n", trapnr);\n<147> cpu_dump_state(cs, stderr, fprintf, 0);
<1> void hmp_info_block(Monitor *mon, const QDict *qdict)\n<9> const char *device = qdict_get_try_str(qdict, "device");\n<19> for (info = block_list; info; info = info->next) {\n<21> if (device && strcmp(device, info->value->device)) {\n<29> info->value->device, info->value->removable);\n<33> if (info->value->removable) {\n<43> if (info->value->has_io_status) {\n<53> if (info->value->has_inserted) {\n<137> monitor_printf(mon, "\n");
<2> MDECContext * const a = avctx -> priv_data ;\n<10> if ( ( ret = ff_thread_get_buffer ( avctx , p ) ) < 0 ) {\n<30> a -> mb_x < a -> mb_width ;\n<36> idct_put ( a , a -> mb_x , a -> mb_y ) ;\n<39> p -> quality = a -> qscale * FF_QP2LAMBDA ;\n<40> memset ( p -> qscale_table , a -> qscale , a -> mb_width ) ;
<1> static int avi_read_packet(AVFormatContext *s, AVPacket *pkt)\n<9> int n, d[8], size;\n<17> memset(d, -1, sizeof(int)*8);\n<57> d[j]= d[j+1];\n<63> size= d[4] + (d[5]<<8) + (d[6]<<16) + (d[7]<<24);\n<69> n= (d[2] - '0') * 10 + (d[3] - '0');\n<71> if(    d[2] >= '0' && d[2] <= '9'\n<73> && d[3] >= '0' && d[3] <= '9'\n<75> && d[0] == 'i' && d[1] == 'x'\n<91> if(d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K' &&\n<105> n= (d[0] - '0') * 10 + (d[1] - '0');\n<107> if(    d[0] >= '0' && d[0] <= '9'\n<109> && d[1] >= '0' && d[1] <= '9'\n<111> && ((d[2] == 'd' && d[3] == 'c') ||\n<113> (d[2] == 'w' && d[3] == 'b') ||\n<115> (d[2] == 'd' && d[3] == 'b') ||\n<117> (d[2] == '_' && d[3] == '_'))
<5> WMACodecContext *s = avctx->priv_data;\n<25> for (ch = 0; ch < avctx->channels; ch++) {\n<27> memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n<29> s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n<31> s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n<35> s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n<37> mdct->mdct_calc(mdct, s->coefs[ch], s->output);
<1> static int client_migrate_info(Monitor *mon, const QDict *qdict,\n<7> const char *protocol = qdict_get_str(qdict, "protocol");\n<23> if (strcmp(protocol, "spice") == 0) {\n<25> if (!qemu_using_spice(&err)) {\n<63> qerror_report(QERR_INVALID_PARAMETER, "protocol");\n<65> return -1;
<1> static int xface_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<7> XFaceContext *xface = avctx->priv_data;\n<11> uint8_t bitmap_copy[XFACE_PIXELS];\n<25> if (avctx->width || avctx->height) {\n<27> if (avctx->width != XFACE_WIDTH || avctx->height != XFACE_HEIGHT) {\n<51> for (i = 0, j = 0; i < XFACE_PIXELS; ) {\n<55> xface->bitmap[i++] = (buf[j]>>(7-k))&1;\n<71> memcpy(bitmap_copy, xface->bitmap, XFACE_PIXELS);\n<73> ff_xface_generate_face(xface->bitmap, bitmap_copy);
<1> SDState *sd_init(BlockDriverState *bs, bool is_spi)\n<9> if (bs && bdrv_is_read_only(bs)) {\n<11> fprintf(stderr, "sd_init: Cannot use read-only drive\n");
<1> static int vfio_load_rom(VFIODevice *vdev)\n<19> if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {\n<39> memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);\n<41> ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);\n<43> memset(ptr, 0xff, size);\n<49> bytes = pread(vdev->fd, ptr + off, size, voff + off);
<1> static int to_integer(char *p, int len)\n<7> char *q = av_malloc(sizeof(char) * len);\n<9> if (!q) return -1;\n<11> strncpy(q, p, len);\n<13> ret = atoi(q);
<1> static uint32_t virtio_blk_get_features(VirtIODevice *vdev)\n<5> VirtIOBlock *s = to_virtio_blk(vdev);\n<27> if (strcmp(s->serial_str, "0"))\n<29> features |= 1 << VIRTIO_BLK_F_IDENTIFY;
<1> void av_md5_update(AVMD5 *ctx, const uint8_t *src, int len)\n<17> if (j) {\n<19> int cnt = FFMIN(len, 64 - j);\n<21> memcpy(ctx->block + j, src, cnt);\n<23> src += cnt;\n<25> len -= cnt;\n<27> if (j + cnt < 64)\n<41> while (src < end) {\n<43> memcpy(ctx->block, src, 64);\n<45> body(ctx->ABCD, (uint32_t *) ctx->block);\n<47> src += 64;\n<53> while (src < end) {\n<65> if (len > 0)\n<67> memcpy(ctx->block, src, len);
<1> struct omap_mpu_state_s *omap310_mpu_init(MemoryRegion *system_memory,\n<35> if (s->cpu == NULL) {\n<37> fprintf(stderr, "Unable to find CPU definition\n");\n<301> if (!dinfo) {\n<303> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> static void n8x0_nand_setup(struct n800_s *s)\n<43> otp_region = onenand_raw_otp(s->nand);\n<47> memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));\n<49> memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));
<1> static void lm32_evr_init(MachineState *machine)\n<63> cpu = cpu_lm32_init(cpu_model);\n<65> if (cpu == NULL) {\n<67> fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model);\n<149> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<169> if (kernel_size < 0) {\n<171> fprintf(stderr, "qemu: could not load kernel '%s'\n",
<1> static int mpeg4_decode_video_packet_header(MpegEncContext *s)\n<25> if(len!=ff_mpeg4_get_video_packet_prefix_length(s)){\n<27> printf("marker does not match f_code\n");\n<47> if(mb_num>=s->mb_num){\n<49> fprintf(stderr, "illegal mb_num in video packet (%d %d) \n", mb_num, s->mb_num);\n<113> if(s->pict_type == S_TYPE && s->vol_sprite_usage==GMC_SPRITE){\n<117> fprintf(stderr, "untested\n");\n<131> if(f_code==0){\n<133> printf("Error, video packet header damaged (f_code=0)\n");\n<143> if(b_code==0){\n<145> printf("Error, video packet header damaged (b_code=0)\n");
<1> static int on2avc_decode_band_scales(On2AVCContext *c, GetBitContext *gb)\n<7> int band_off = 0;\n<13> if (!c->grouping[w]) {\n<17> c->band_scales + band_off - c->num_bands,\n<19> c->num_bands * sizeof(*c->band_scales));\n<21> band_off += c->num_bands;\n<51> c->band_scales[band_off++] = 0;\n<81> c->band_scales[band_off++] = c->scale_tab[scale];
<79> if (++(ast->sub_packet_cnt) < h)\n<93> av_new_packet(pkt, st->codec->block_align);\n<95> memcpy(pkt->data, ast->pkt.data, st->codec->block_align); //FIXME avoid this\n<145> av_free_packet(pkt);
<1> void hmp_migrate_set_parameter(Monitor *mon, const QDict *qdict)\n<5> const char *param = qdict_get_str(qdict, "parameter");\n<21> for (i = 0; i < MIGRATION_PARAMETER__MAX; i++) {\n<23> if (strcmp(param, MigrationParameter_lookup[i]) == 0) {\n<25> MigrationParameters p = { 0 };\n<27> switch (i) {\n<169> error_setg(&err, QERR_INVALID_PARAMETER, param);
<1> static void sd_close(BlockDriverState *bs)\n<19> DPRINTF("%s\n", s->name);\n<23> fd = connect_to_sdog(s, &local_err);\n<25> if (fd < 0) {\n<35> memset(&hdr, 0, sizeof(hdr));\n<45> wlen = strlen(s->name) + 1;\n<47> hdr.data_length = wlen;\n<53> ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,
<1> static int sunrast_decode_frame(AVCodecContext *avctx, void *data,\n<145> if (buf_end - buf < maplength)\n<185> *(uint32_t *)ptr = (buf[x]<<16) + (buf[len+x]<<8) + buf[len+len+x];\n<195> ptr    = p->data[0];\n<265> if (buf_end - buf < len)\n<269> memcpy(ptr, buf, len);\n<271> ptr += stride;\n<273> buf += alen;
<1> static int vp3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> Vp3DecodeContext * s = avctx -> priv_data ;\n<27> if ( s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_loop_filter ( s ) ;\n<30> i ++ ) if ( s -> qps [ i ] != s -> last_qps [ i ] || s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_dequantizer ( s , i ) ;\n<39> if ( s -> keyframe ) {\n<54> if ( ! s -> golden_frame . data [ 0 ] ) {\n<58> if ( ff_thread_get_buffer ( avctx , & s -> golden_frame ) < 0 ) {\n<67> memset ( s -> all_fragments , 0 , s -> fragment_count * sizeof ( Vp3Fragment ) ) ;\n<69> if ( unpack_superblocks ( s , & gb ) ) {\n<73> if ( unpack_modes ( s , & gb ) ) {\n<77> if ( unpack_vectors ( s , & gb ) ) {\n<81> if ( unpack_block_qpis ( s , & gb ) ) {\n<85> if ( unpack_dct_coeffs ( s , & gb ) ) {\n<99> i ++ ) render_slice ( s , i ) ;\n<104> apply_loop_filter ( s , i , row , row + 1 ) ;\n<106> vp3_draw_horiz_band ( s , s -> avctx -> height ) ;
<1> static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n<25> ( void ) CloneString ( & draw_info -> text , caption ) ;\n<31> text = AcquireString ( caption ) ;\n<43> text = AcquireString ( caption ) ;\n<64> if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) {\n<69> text = AcquireString ( caption ) ;\n<89> text = AcquireString ( caption ) ;\n<107> i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ;\n<108> ( void ) CloneString ( & draw_info -> text , caption ) ;
<1> static int colo_packet_compare_common(Packet *ppkt, Packet *spkt)\n<15> if (ppkt->size == spkt->size) {\n<17> return memcmp(ppkt->data, spkt->data, spkt->size);
<1> int ioinst_handle_stsch(CPUS390XState *env, uint64_t reg1, uint32_t ipb)\n<41> if (!schib || len != sizeof(*schib)) {\n<71> if (css_schid_final(m, cssid, ssid, schid)) {\n<79> memset(schib, 0, sizeof(*schib));\n<89> s390_cpu_physical_memory_unmap(env, schib, len, 1);
<1> static void prstatfs_to_statfs(struct statfs *stfs, ProxyStatFS *prstfs)\n<5> memset(stfs, 0, sizeof(*stfs));
<1> static int analyze(const uint8_t *buf, int size, int packet_size, int *index,\n<7> int stat[TS_MAX_PACKET_SIZE];\n<17> memset(stat, 0, packet_size * sizeof(*stat));\n<29> stat[x]++;\n<33> if (stat[x] > best_score) {\n<35> best_score = stat[x];
<1> static void _slurm_rpc_allocate_pack ( slurm_msg_t * msg ) {\n<136> hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n<137> if ( tmp_str [ 0 ] == '[' ) {\n<138> tmp_offset = strchr ( tmp_str , ']' ) ;\n<140> tmp_offset = tmp_str + 1 ;\n<156> xfree ( tmp_str ) ;
<1> int av_find_stream_info(AVFormatContext *ic)\n<119> if (!has_codec_parameters(st->codec))\n<125> if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)\n<131> if(st->parser && st->parser->parser->split && !st->codec->extradata)\n<197> if (!has_codec_parameters(st->codec)){\n<201> avcodec_string(buf, sizeof(buf), st->codec, 0);\n<221> if(av_dup_packet(pkt) < 0) {\n<269> if(info[index].duration_count < 2)\n<271> memset(info[index].duration_error, 0, sizeof(info[index].duration_error));\n<281> info[index].duration_error[i] += error*error;\n<301> if(st->parser && st->parser->parser->split && !st->codec->extradata){\n<303> int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);\n<305> if(i){\n<307> st->codec->extradata_size= i;\n<309> st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<311> memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);\n<313> memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<329> if (!has_codec_parameters(st->codec) || !has_decode_delay_been_guessed(st))\n<331> try_decode_frame(st, pkt);\n<351> avcodec_close(st->codec);\n<381> if (tb_unreliable(st->codec) && info[i].duration_count > 15 && info[i].duration_gcd > 1 && !st->r_frame_rate.num)\n<387> && tb_unreliable(st->codec) /*&&
<1> static void ioreq_release(struct ioreq *ioreq)\n<9> LIST_REMOVE(ioreq, list);\n<11> memset(ioreq, 0, sizeof(*ioreq));\n<15> LIST_INSERT_HEAD(&blkdev->freelist, ioreq, list);
<1> static char *ctime1(char *buf2, int buf_size)\n<15> av_strlcpy(buf2, p, buf_size);\n<17> p = buf2 + strlen(p) - 1;
<1> static int yop_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<16> if ( ! avctx -> frame_number ) memset ( s -> frame . data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n<24> palette = ( uint32_t * ) s -> frame . data [ 1 ] ;
<1> static int write_f(int argc, char **argv)\n<25> while ((c = getopt(argc, argv, "bCpP:q")) != EOF) {\n<83> if (bflag && pflag) {\n<85> printf("-b and -p cannot be specified at the same time\n");\n<93> offset = cvtnum(argv[optind]);\n<95> if (offset < 0) {\n<97> printf("non-numeric length argument -- %s\n", argv[optind]);\n<107> count = cvtnum(argv[optind]);\n<109> if (count < 0) {\n<111> printf("non-numeric length argument -- %s\n", argv[optind]);\n<133> if (count & 0x1ff) {\n<171> if (cnt < 0) {\n<173> printf("write failed: %s\n", strerror(-cnt));
<1> void bareetraxfs_init (ram_addr_t ram_size, int vga_ram_size,\n<5> const char *kernel_filename, const char *kernel_cmdline,\n<49> cpu_register_physical_memory(0x40000000, ram_size, phys_ram | IO_MEM_RAM);\n<125> etraxfs_timer_init(env, pic->irq + 0x1b, pic->nmi + 1, 0x3005e000);\n<143> if (kernel_filename) {\n<177> if (kernel_cmdline && (kcmdline_len = strlen(kernel_cmdline))) {\n<179> if (kcmdline_len > 256) {\n<181> fprintf(stderr, "Too long CRIS kernel cmdline (max 256)\n");\n<187> pstrcpy_targphys(high, 256, kernel_cmdline);\n<191> env->regs[10] = 0x87109563;\n<193> env->regs[11] = high;\n<199> env->pc = bootstrap_pc;\n<203> printf ("pc =%x\n", env->pc);\n<205> printf ("ram size =%ld\n", ram_size);
<1> int gtod_load(QEMUFile *f, void *opaque, int version_id)\n<13> if (qemu_get_byte(f) == S390_TOD_CLOCK_VALUE_MISSING) {\n<15> fprintf(stderr, "WARNING: Guest clock was not migrated. This could "\n<31> r = s390_set_clock(&tod_high, &tod_low);\n<33> if (r) {\n<35> fprintf(stderr, "WARNING: Unable to set guest clock value. "
<1> static void update(Real288_internal *glob)\n<5> float buffer1[40], temp1[37];\n<7> float buffer2[8], temp2[11];\n<11> memcpy(buffer1     , glob->output + 20, 20*sizeof(*buffer1));\n<13> memcpy(buffer1 + 20, glob->output     , 20*sizeof(*buffer1));\n<17> do_hybrid_window(36, 40, 35, buffer1, temp1, glob->st1a, glob->st1b,\n<29> memcpy(buffer2    , glob->history + 4, 4*sizeof(*buffer2));\n<31> memcpy(buffer2 + 4, glob->history    , 4*sizeof(*buffer2));\n<35> do_hybrid_window(10, 8, 20, buffer2, temp2, glob->st2a, glob->st2b,
<1> static void n8x0_init(ram_addr_t ram_size, const char *boot_device,\n<13> int sdram_size = binfo->ram_size;\n<15> int onenandram_size = 0x00010000;\n<21> if (ram_size < sdram_size + onenandram_size + OMAP242X_SRAM_SIZE) {\n<23> fprintf(stderr, "This architecture uses %i bytes of memory\n",\n<151> if (option_rom[0] && (boot_device[0] == 'n' || !kernel_filename)) {\n<187> printf("%i bytes of image loaded\n", rom_size);
<1> static uint64_t get_cluster_offset(BlockDriverState *bs,\n<11> BDRVQcowState *s = bs->opaque;\n<103> l2_table = s->l2_cache + (min_index << s->l2_bits);\n<105> if (new_l2_table) {\n<107> memset(l2_table, 0, s->l2_size * sizeof(uint64_t));\n<109> if (bdrv_pwrite_sync(bs->file, l2_offset, l2_table,\n<207> if (i < n_start || i >= n_end) {\n<211> memset(s->cluster_data, 0x00, 512);
<1> static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,\n<45> static const uint8_t nalu_header[4] = {0, 0, 0, 1};\n<73> unit_size = AV_RB16(extradata);\n<87> if (!out)\n<91> memcpy(out+total_size-unit_size-4, nalu_header, 4);\n<93> memcpy(out+total_size-unit_size,   extradata+2, unit_size);\n<95> extradata += 2+unit_size;
<1> void qmp_block_commit(bool has_job_id, const char *job_id, const char *device,\n<83> if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_COMMIT_SOURCE, errp)) {\n<97> if (has_top && top) {\n<99> if (strcmp(bs->filename, top) != 0) {\n<101> top_bs = bdrv_find_backing_image(bs, top);\n<111> error_setg(errp, "Top image file %s not found", top ? top : "NULL");\n<169> if (top_bs == bs) {\n<181> commit_active_start(has_job_id ? job_id : NULL, bs, base_bs, speed,\n<187> commit_start(has_job_id ? job_id : NULL, bs, base_bs, top_bs, speed,
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> VmncContext * const c = avctx -> priv_data ;\n<33> outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n<35> i < h ;\n<37> memcpy ( outptr , c -> screendta + i * c -> cur_w * c -> bpp2 , w * c -> bpp2 ) ;\n<38> outptr += c -> pic . linesize [ 0 ] ;\n<74> c -> screendta = av_realloc ( c -> screendta , c -> cur_w * c -> cur_h * c -> bpp2 ) ;\n<75> load_cursor ( c , src ) ;\n<118> res = decode_hextile ( c , outptr , src , size_left , w , h , c -> pic . linesize [ 0 ] ) ;\n<143> outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n<145> i < h ;\n<147> memcpy ( c -> screendta + i * c -> cur_w * c -> bpp2 , outptr , w * c -> bpp2 ) ;\n<148> outptr += c -> pic . linesize [ 0 ] ;
<1> static int synth_superframe(AVCodecContext *ctx,\n<7> WMAVoiceContext *s = ctx->priv_data;\n<13> double lsps[MAX_FRAMES][MAX_LSPS];\n<19> float excitation[MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12];\n<21> float synth[MAX_LSPS + MAX_SFRAMESIZE];\n<27> s->lsps             * sizeof(*synth));\n<31> s->history_nsamples * sizeof(*excitation));\n<47> if ((res = check_bits_for_superframe(gb, s)) == 1) {\n<103> prev_lsps[n] = s->prev_lsps[n] - mean_lsf[n];\n<109> dequant_lsp10r(gb, lsps[2], prev_lsps, a1, a2, s->lsp_q_mode);\n<113> dequant_lsp16r(gb, lsps[2], prev_lsps, a1, a2, s->lsp_q_mode);\n<123> lsps[2][n] += mean_lsf[n];\n<137> for (n = 0; n < 3; n++) {\n<211> s->lsps             * sizeof(*s->prev_lsps));\n<213> memcpy(s->synth_history,      &synth[MAX_SFRAMESIZE],\n<215> s->lsps             * sizeof(*synth));\n<217> memcpy(s->excitation_history, &excitation[MAX_SFRAMESIZE],\n<219> s->history_nsamples * sizeof(*excitation));\n<221> if (s->do_apf)\n<223> memmove(s->zero_exc_pf,       &s->zero_exc_pf[MAX_SFRAMESIZE],\n<225> s->history_nsamples * sizeof(*s->zero_exc_pf));
<1> int vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<27> if (ret < 0)\n<53> if (s->pix_fmt < 0) {\n<85> if (avctx->skip_frame >= skip_thresh) {\n<89> memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);\n<143> if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n<167> if ((ret = vp8_alloc_frame(s, curframe, referenced))) {\n<217> if (avctx->hwaccel) {\n<221> if (ret < 0)\n<229> if (ret < 0)\n<237> if (ret < 0)\n<251> memset(s->top_nnz, 0, s->mb_width * sizeof(*s->top_nnz));\n<257> if (!s->mb_layout)\n<259> memset(s->macroblocks + s->mb_height * 2 - 1, 0,\n<261> (s->mb_width + 1) * sizeof(*s->macroblocks));\n<263> if (!s->mb_layout && s->keyframe)\n<265> memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width * 4);\n<269> memset(s->ref_count, 0, sizeof(s->ref_count));\n<343> memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);\n<375> memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);
<1> int ff_hevc_extract_rbsp(HEVCContext *s, const uint8_t *src, int length,\n<19> if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {     \\n<95> if (i > 0 && src[i - 1] == 0)\n<107> if (i >= length - 1) { // no escaped 0\n<127> if (!nal->rbsp_buffer)\n<133> dst = nal->rbsp_buffer;\n<137> memcpy(dst, src, i);\n<139> si = di = i;\n<141> while (si + 2 < length) {\n<145> if (src[si + 2] > 3) {\n<147> dst[di++] = src[si++];\n<149> dst[di++] = src[si++];\n<151> } else if (src[si] == 0 && src[si + 1] == 0) {\n<153> if (src[si + 2] == 3) { // escape\n<157> dst[di++] = 0;\n<191> nal->skipped_bytes_pos[nal->skipped_bytes-1] = di - 1;\n<205> dst[di++] = src[si++];\n<211> dst[di++] = src[si++];\n<217> memset(dst + di, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n<221> nal->data = dst;\n<225> nal->raw_data = src;
<1> static int get_blocksize(BlockDriverState *bdrv)\n<17> memset(cmd, 0, sizeof(cmd));\n<19> memset(buf, 0, sizeof(buf));\n<25> memset(&io_header, 0, sizeof(io_header));\n<35> io_header.cmdp = cmd;\n<47> ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
<1> static int synchronize_audio(VideoState *is, short *samples,\n<97> samples_end = (uint8_t *)samples + samples_size - n;\n<99> q = samples_end + n;\n<101> while (nb > 0) {\n<103> memcpy(q, samples_end, n);\n<105> q += n;\n<107> nb -= n;
<1> bool challenge_h ( connection_t * c ) {\n<2> char buffer [ MAX_STRING_SIZE ] ;\n<4> if ( sscanf ( c -> buffer , "%*d " MAX_STRING , buffer ) != 1 ) {\n<9> if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n<10> logger ( LOG_ERR , "Possible intruder %s (%s): %s" , c -> name , c -> hostname , "wrong challenge length" ) ;\n<11> return false ;\n<13> c -> mychallenge = xrealloc ( c -> mychallenge , len ) ;\n<14> if ( ! hex2bin ( buffer , c -> mychallenge , len ) ) {
<1> static int fill_default_ref_list(H264Context *h){\n<177> len[list] = split_field_ref_list(h->default_ref_list[list],\n<207> if(len[list] < h->ref_count[ list ])\n<209> memset(&h->default_ref_list[list][len[list]], 0, sizeof(Picture)*(h->ref_count[ list ] - len[list]));\n<269> if(index < h->ref_count[0])\n<271> memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));
<1> static int net_vde_init(VLANState *vlan, const char *model,\n<3> const char *name, const char *sock,\n<5> int port, const char *group, int mode)\n<11> char *init_group = strlen(group) ? (char *)group : NULL;\n<13> char *init_sock = strlen(sock) ? (char *)sock : NULL;\n<21> .group = init_group,\n<29> s = qemu_mallocz(sizeof(VDEState));\n<31> s->vde = vde_open(init_sock, (char *)"QEMU", &args);\n<33> if (!s->vde){\n<35> free(s);\n<47> snprintf(s->vc->info_str, sizeof(s->vc->info_str), "sock=%s,fd=%d",
<1> void virtio_input_send(VirtIOInput *vinput, virtio_input_event *event)\n<73> if (!elem) {\n<77> fprintf(stderr, "%s: Huh?  No vq elem available ...\n", __func__);
<1> int pci_add_capability(PCIDevice *pdev, uint8_t cap_id,\n<15> if (!offset) {\n<17> offset = pci_find_space(pdev, size);\n<21> assert(offset);\n<33> for (i = offset; i < offset + size; i++) {\n<35> overlapping_cap = pci_find_capability_at_offset(pdev, i);\n<71> memset(pdev->used + offset, 0xFF, QEMU_ALIGN_UP(size, 4));\n<75> memset(pdev->wmask + offset, 0, size);\n<79> memset(pdev->cmask + offset, 0xFF, size);
<1> void *qemu_try_blockalign0(BlockDriverState *bs, size_t size)\n<5> void *mem = qemu_try_blockalign(bs, size);\n<9> if (mem) {\n<11> memset(mem, 0, size);\n<17> return mem;
<1> int qemu_savevm_state_begin(QEMUFile *f)\n<15> TAILQ_FOREACH(se, &savevm_handlers, entry) {\n<37> len = strlen(se->idstr);\n<39> qemu_put_byte(f, len);\n<41> qemu_put_buffer(f, (uint8_t *)se->idstr, len);
<1> static int ac3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<3> const uint8_t * buf = avpkt -> data ;\n<5> AC3DecodeContext * s = avctx -> priv_data ;\n<8> const float * output [ AC3_MAX_CHANNELS ] ;\n<9> if ( buf_size >= 2 && AV_RB16 ( buf ) == 0x770B ) {\n<13> else memcpy ( s -> input_buffer , buf , FFMIN ( buf_size , AC3_FRAME_BUFFER_SIZE ) ) ;\n<14> buf = s -> input_buffer ;\n<16> err = parse_frame_header ( s ) ;\n<68> set_downmix_coeffs ( s ) ;\n<87> if ( ch < s -> out_channels ) s -> outptr [ channel_map [ ch ] ] = ( float * ) frame -> data [ ch ] ;\n<89> output [ ch ] = s -> output [ ch ] ;\n<94> if ( ! err && decode_audio_block ( s , blk ) ) {\n<99> ch < s -> out_channels ;\n<100> ch ++ ) memcpy ( s -> outptr [ channel_map [ ch ] ] , output [ ch ] , 1024 ) ;\n<104> output [ ch ] = s -> outptr [ channel_map [ ch ] ] ;\n<105> s -> outptr [ channel_map [ ch ] ] += AC3_BLOCK_SIZE ;\n<109> ch < s -> out_channels ;\n<110> ch ++ ) memcpy ( s -> output [ ch ] , output [ ch ] , 1024 ) ;
<1> int nbd_receive_negotiate(int csock, const char *name, uint32_t *flags,\n<19> if (read_sync(csock, buf, 8) != 8) {\n<31> buf[8] = '\0';\n<33> if (strlen(buf) == 0) {\n<35> LOG("server connection closed");\n<37> errno = EINVAL;\n<39> return -1;\n<47> qemu_isprint(buf[0]) ? buf[0] : '.',\n<49> qemu_isprint(buf[1]) ? buf[1] : '.',\n<51> qemu_isprint(buf[2]) ? buf[2] : '.',\n<53> qemu_isprint(buf[3]) ? buf[3] : '.',\n<55> qemu_isprint(buf[4]) ? buf[4] : '.',\n<57> qemu_isprint(buf[5]) ? buf[5] : '.',\n<59> qemu_isprint(buf[6]) ? buf[6] : '.',\n<61> qemu_isprint(buf[7]) ? buf[7] : '.');\n<65> if (memcmp(buf, "NBDMAGIC", 8) != 0) {\n<67> LOG("Invalid magic received");\n<69> errno = EINVAL;\n<71> return -1;\n<77> if (read_sync(csock, &magic, sizeof(magic)) != sizeof(magic)) {\n<157> if (write_sync(csock, &opt, sizeof(opt)) != sizeof(opt)) {\n<167> namesize = cpu_to_be32(strlen(name));\n<169> if (write_sync(csock, &namesize, sizeof(namesize)) !=\n<181> if (write_sync(csock, (char*)name, strlen(name)) != strlen(name)) {\n<183> LOG("write failed (name)");\n<185> errno = EINVAL;\n<187> return -1;\n<211> if (read_sync(csock, &s, sizeof(s)) != sizeof(s)) {\n<229> if (!name) {\n<259> if (read_sync(csock, &buf, 124) != 124) {
<1> static int decode_mb_cabac(H264Context *h) {\n<167> if(IS_INTRA_PCM(mb_type)) {\n<257> memset(h->non_zero_count[mb_xy], 16, 16);
<1> static void pc_q35_init(MachineState *machine)\n<125> if (xen_enabled() && xen_hvm_init(pcms, &ram_memory) != 0) {\n<127> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> void qxl_log_cmd_cursor(PCIQXLDevice *qxl, QXLCursorCmd *cmd, int group_id)\n<11> qxl_name(qxl_cursor_cmd, cmd->type));\n<13> switch (cmd->type) {\n<45> fprintf(stderr, " +%d+%d", cmd->u.position.x, cmd->u.position.y);
<1> static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n<5> if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n<6> return ENOMEM ;\n<8> memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n<9> for ( i = 0 ;\n<10> i < ( 2 << 20 ) ;\n<17> buf [ i + j ] = j + off ;\n<20> if ( SIZEOF_XOFF_T == 4 ) {\n<21> ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;\n<35> fail : free ( buf ) ;\n<36> return ret ;
<25> switch ( * buf ) {\n<32> case DUL_TYPETRANSFERSYNTAX : subItem = ( DUL_SUBITEM * ) malloc ( sizeof ( DUL_SUBITEM ) ) ;\n<33> if ( subItem == NULL ) return EC_MemoryExhausted ;
<1> static void flush_packet(AVFormatContext *ctx, int stream_index, int last_pkt)\n<7> StreamInfo *stream = ctx->streams[stream_index]->priv_data;\n<163> put_buffer(&ctx->pb, stream->buffer, payload_size - stuffing_size);\n<177> memmove(stream->buffer, stream->buffer + stream->buffer_ptr - len, len);\n<179> stream->buffer_ptr = len;
<1> static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,\n<3> AVCodecContext *avctx, const char *args,\n<45> if (!ctx->extradata_parsed) {\n<47> if (args && strstr(args, "private_spspps_buf"))\n<49> ctx->private_spspps = 1;
<1> static void sbr_qmf_synthesis(DSPContext *dsp, FFTContext *mdct,\n<7> float *v0, int *v_off, const unsigned int div)\n<21> if (*v_off < step) {\n<25> memcpy(&v0[SBR_SYNTHESIS_BUF_SIZE - saved_samples], v0, saved_samples * sizeof(float));\n<35> v = v0 + *v_off;
<1> ram_addr_t qemu_ram_alloc(DeviceState *dev, const char *name, ram_addr_t size)\n<11> new_block = qemu_mallocz(sizeof(*new_block));\n<29> pstrcat(new_block->idstr, sizeof(new_block->idstr), name);\n<33> QLIST_FOREACH(block, &ram_list.blocks, next) {\n<35> if (!strcmp(block->idstr, new_block->idstr)) {\n<37> fprintf(stderr, "RAMBlock \"%s\" already registered, abort!\n",\n<39> new_block->idstr);\n<41> abort();\n<49> if (mem_path) {\n<69> fprintf(stderr, "-mem-path option unsupported\n");\n<107> QLIST_INSERT_HEAD(&ram_list.blocks, new_block, next);\n<111> ram_list.phys_dirty = qemu_realloc(ram_list.phys_dirty,\n<115> memset(ram_list.phys_dirty + (new_block->offset >> TARGET_PAGE_BITS),\n<117> 0xff, size >> TARGET_PAGE_BITS);
<1> static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<11> VmncContext * const c = avctx->priv_data;\n<81> outptr = c->pic->data[0] + dx * c->bpp2 + dy * c->pic->linesize[0];\n<83> for (i = 0; i < h; i++) {\n<85> memcpy(outptr, c->screendta + i * c->cur_w * c->bpp2,\n<87> w * c->bpp2);\n<89> outptr += c->pic->linesize[0];\n<171> (ret = av_reallocp(&c->screendta, screen_size)) < 0) {\n<181> load_cursor(c);\n<303> res = decode_hextile(c, outptr, gb, w, h, c->pic->linesize[0]);\n<361> outptr = c->pic->data[0] + dx * c->bpp2 + dy * c->pic->linesize[0];\n<363> for (i = 0; i < h; i++) {\n<365> memcpy(c->screendta + i * c->cur_w * c->bpp2, outptr,\n<367> w * c->bpp2);\n<369> outptr += c->pic->linesize[0];
<1> static int mmap_start(AVFormatContext *ctx)\n<13> for (i = 0; i < s->buffers; i++) {\n<19> memset(&buf, 0, sizeof(struct v4l2_buffer));\n<21> buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n<23> buf.memory = V4L2_MEMORY_MMAP;\n<25> buf.index  = i;\n<29> res = ioctl(s->fd, VIDIOC_QBUF, &buf);\n<31> if (res < 0) {\n<33> av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_QBUF): %s\n",\n<35> strerror(errno));\n<39> return AVERROR(errno);\n<51> if (res < 0) {\n<53> av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_STREAMON): %s\n",\n<55> strerror(errno));\n<59> return AVERROR(errno);
<1> static int protocol_client_msg(VncState *vs, char *data, size_t len)\n<11> switch (data[0]) {\n<49> for (i = 0; i < limit; i++) {\n<51> int32_t val = read_s32(data, 4 + (i * 4));\n<53> memcpy(data + 4 + (i * 4), &val, sizeof(val));\n<123> printf("Msg: %d\n", data[0]);
<1> static char * memdup ( const char * src , size_t buffer_length ) {\n<3> bool add = FALSE ;\n<5> if ( buffer_length ) length = buffer_length ;\n<6> else if ( src ) {\n<7> length = strlen ( src ) ;\n<8> add = TRUE ;\n<10> else return strdup ( "" ) ;\n<11> buffer = malloc ( length + add ) ;\n<12> if ( ! buffer ) return NULL ;\n<13> memcpy ( buffer , src , length ) ;\n<15> return buffer ;
<1> static const char *keyval_parse_one(QDict *qdict, const char *params,\n<27> if (implied_key && len && key[len] != '=') {\n<33> len = strlen(implied_key);\n<37> key_end = key + len;\n<55> for (len = 0; s + len < key_end && s[len] != '.'; len++) {\n<61> assert(key != implied_key);\n<71> if (len >= sizeof(key_in_cur)) {\n<73> assert(key != implied_key);\n<87> if (s != key) {\n<91> key, s - 1, errp);\n<93> if (!next) {\n<107> memcpy(key_in_cur, s, len);\n<109> key_in_cur[len] = 0;\n<111> s += len;\n<115> if (*s != '.') {\n<127> if (key == implied_key) {\n<177> if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {
<1> int ff_vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<53> res = s->parse_header(s, buf, remaining_buf_size, &golden_frame);\n<81> if (!is_alpha) {\n<95> if (res == 2)\n<97> if (vp56_size_changed(avctx)) {\n<113> s->default_models_init(s);\n<123> vp56_parse_mb_type_models(s);\n<125> s->parse_vector_models(s);\n<133> s->parse_coeff_models(s);\n<137> memset(s->prev_dc, 0, sizeof(s->prev_dc));\n<175> for (mb_row=0; mb_row<s->mb_height; mb_row++) {\n<197> memset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));\n<199> memset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));\n<233> vp56_decode_mb(s, mb_row, mb_col, is_alpha);
<1> static int ape_decode_frame(AVCodecContext * avctx,\n<13> APEContext *s = avctx->priv_data;\n<83> if (s->samples <= 0) {\n<93> memset(s->decoded0,  0, sizeof(s->decoded0));\n<95> memset(s->decoded1,  0, sizeof(s->decoded1));\n<101> init_frame_decoder(s);\n<129> ape_unpack_mono(s, blockstodecode);\n<133> ape_unpack_stereo(s, blockstodecode);
<1> static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags,\n<29> opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n<65> clientname = qemu_rbd_parse_clientname(conf, clientname_buf);\n<69> if (r < 0) {\n<115> if (strstr(conf, "conf=") == NULL) {\n<119> rados_conf_read_file(s->cluster, NULL);\n<125> if (conf[0] != '\0') {\n<127> r = qemu_rbd_set_conf(s->cluster, conf, errp);\n<175> bs->read_only = (s->snap != NULL);
<1> static void config_connection_input ( struct config_connection * conn ) {\n<20> while ( ( args = config_connection_next_line ( conn ) ) != NULL ) {\n<21> if ( args [ 0 ] == NULL ) continue ;\n<22> if ( strcmp ( args [ 0 ] , "REQ" ) == 0 ) {\n<23> if ( config_connection_request ( conn , args + 1 ) < 0 ) break ;
<1> static int parallel_parse(const char *devname)\n<11> if (strcmp(devname, "none") == 0)\n<13> return 0;\n<15> if (index == MAX_PARALLEL_PORTS) {\n<17> fprintf(stderr, "qemu: too many parallel ports\n");\n<23> snprintf(label, sizeof(label), "parallel%d", index);\n<25> parallel_hds[index] = qemu_chr_new(label, devname, NULL);\n<27> if (!parallel_hds[index]) {\n<29> fprintf(stderr, "qemu: could not connect parallel device"
<1> static void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n<151> if (cirrus_hook_write_palette(s, val))\n<155> s->dac_cache[s->dac_sub_index] = val;\n<157> if (++s->dac_sub_index == 3) {\n<159> memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);
<1> static void dvbsub_parse_region_segment(AVCodecContext *avctx,\n<39> if (!region) {\n<41> region = av_mallocz(sizeof(DVBSubRegion));\n<45> region->id = region_id;\n<49> region->next = ctx->region_list;\n<71> if (region->width * region->height != region->buf_size) {\n<81> region->pbuf = av_malloc(region->buf_size);\n<107> region->bgcolor = *buf++;\n<117> region->bgcolor = (((*buf++) >> 4) & 15);\n<121> region->bgcolor = (((*buf++) >> 2) & 3);\n<131> if (fill) {\n<133> memset(region->pbuf, region->bgcolor, region->buf_size);\n<135> av_dlog(avctx, "Fill region (%d)\n", region->bgcolor);\n<141> delete_region_display_list(ctx, region);
<1> void msix_reset(PCIDevice *dev)\n<5> if (!(dev->cap_present & QEMU_PCI_CAP_MSIX))\n<9> msix_free_irq_entries(dev);\n<15> memset(dev->msix_table_page, 0, MSIX_PAGE_SIZE);\n<17> msix_mask_all(dev, dev->msix_entries_nr);
<1> static int cpu_x86_register (CPUX86State *env, const char *cpu_model)\n<9> if (cpu_x86_find_by_name(def, cpu_model) < 0)\n<65> if (!model_id)\n<67> model_id = "";\n<69> len = strlen(model_id);\n<73> if (i >= len)\n<79> c = (uint8_t)model_id[i];
<1> print_with_operands (const struct cris_opcode *opcodep,\n<147> tp = format_sup_reg ((insn >> 12) & 15, tp, with_reg_prefix);\n<157> *tp++ = REGISTER_PREFIX_CHAR;\n<159> *tp++ = 'a';\n<175> *tp++ = *s;\n<221> tp = format_reg (disdata, insn & 15, tp, with_reg_prefix);\n<229> tp = format_reg (disdata, (insn >> 12) & 15, tp, with_reg_prefix);\n<251> *tp = 0;\n<281> *tp = 0;\n<433> strcpy (tp, "bug");\n<449> tp = format_dec (number, tp, signedp);\n<483> *tp = 0;\n<503> tp = format_hex (number, tp, disdata);\n<575> *tp++ = '[';\n<643> *tp = 0;\n<899> *tp = 0;\n<1021> tp = format_reg (disdata, (insn >> 12) & 15, tp, with_reg_prefix);\n<1033> tp = format_dec (insn & 63, tp, 0);\n<1071> *tp = 0;\n<1091> tp = format_dec (insn & 31, tp, 0);\n<1099> tp = format_dec (insn & 15, tp, 0);\n<1135> *tp = 0;\n<1165> tp = format_dec (number, tp, 1);\n<1179> tp = print_flags (disdata, insn, tp);\n<1187> tp = format_dec ((insn & 32) ? (insn & 31) | ~31L : insn & 31, tp, 1);\n<1203> if (sregp->name == NULL)\n<1207> *tp++ = '?';\n<1215> *tp++ = REGISTER_PREFIX_CHAR;\n<1217> strcpy (tp, sregp->name);\n<1219> tp += strlen (tp);\n<1231> strcpy (tp, "???");
<1> struct HCIInfo *hci_init(const char *str)\n<11> if (!strcmp(str, "null"))\n<15> return &null_hci;\n<17> else if (!strncmp(str, "host", 4) && (str[4] == '\0' || str[4] == ':'))\n<23> else if (!strncmp(str, "hci", 3)) {\n<43> if (vlan)\n<51> fprintf(stderr, "qemu: Unknown bluetooth HCI `%s'.\n", str);
<1> static void check_refcounts(BlockDriverState *bs)\n<85> for(i = 0; i < nb_clusters; i++) {\n<87> refcount1 = get_refcount(bs, i);\n<91> if (refcount1 != refcount2)\n<93> fprintf(stderr, "ERROR cluster %d refcount=%d reference=%d\n",
<1> static int decode_init(AVCodecContext * avctx)\n<91> for(i=1;i<16;i++) {\n<105> memset(tmp_bits , 0, sizeof(tmp_bits ));\n<107> memset(tmp_codes, 0, sizeof(tmp_codes));\n<123> tmp_bits [(x << 4) | y]= h->bits [j  ];\n<125> tmp_codes[(x << 4) | y]= h->codes[j++];
<1> static int patch_hypercalls(VAPICROMState *s)\n<35> cpu_physical_memory_read(rom_paddr, rom, s->rom_size);\n<39> for (pos = 0; pos < s->rom_size - sizeof(vmcall_pattern); pos++) {\n<43> pattern = outl_pattern;\n<53> pattern = vmcall_pattern;\n<63> if (memcmp(rom + pos, pattern, 7) == 0 &&\n<65> (rom[pos + 7] == alternates[0] || rom[pos + 7] == alternates[1])) {\n<67> cpu_physical_memory_write(rom_paddr + pos + 5, patch, 3);
<1> static VmdkExtent *vmdk_add_extent(BlockDriverState *bs,\n<23> extent = &s->extents[s->num_extents];\n<29> memset(extent, 0, sizeof(VmdkExtent));\n<53> extent->end_sector = (*(extent - 1)).end_sector + extent->sectors;\n<57> extent->end_sector = extent->sectors;\n<61> bs->total_sectors = extent->end_sector;\n<63> return extent;
<1> static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) {\n<2> size_t width = ( 79 - strlen ( prefix ) ) ;\n<8> if ( ! print_buffer ) return ;\n<9> len = strlen ( print_buffer ) ;\n<10> ptr = print_buffer ;\n<11> while ( len > 0 ) {\n<12> fputs ( prefix , config -> errors ) ;\n<13> if ( len > width ) {\n<29> curl_free ( print_buffer ) ;
<1> static void virtio_net_add_queue(VirtIONet *n, int index)\n<13> if (n->net_conf.tx && !strcmp(n->net_conf.tx, "timer")) {\n<15> n->vqs[index].tx_vq =\n<17> virtio_add_queue(vdev, 256, virtio_net_handle_tx_timer);\n<19> n->vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n<23> &n->vqs[index]);\n<27> n->vqs[index].tx_vq =\n<29> virtio_add_queue(vdev, 256, virtio_net_handle_tx_bh);\n<31> n->vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[index]);
<1> static inline int msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block,\n<33> level = msmpeg4_decode_dc(s, n, &dc_pred_dir);\n<51> if (level < 0){\n<53> fprintf(stderr, "dc overflow- block: %d qscale: %d//\n", n, s->qscale);\n<61> if (n < 4) {\n<65> if(level > 256*s->y_dc_scale){\n<67> fprintf(stderr, "dc overflow+ L qscale: %d//\n", s->qscale);\n<77> if(level > 256*s->c_dc_scale){\n<79> fprintf(stderr, "dc overflow+ C qscale: %d//\n", s->qscale);\n<209> if(s->qscale<8){\n<215> if(SHOW_UBITS(re, &s->gb, 1)) printf("cool a new vlc code ,contact the ffmpeg developers and upload the file\n");\n<453> if(i+192 == 64 && level/qmul==-1){\n<455> fprintf(stderr, "ignoring overflow at %d %d\n", s->mb_x, s->mb_y);\n<461> fprintf(stderr, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);\n<491> mpeg4_pred_ac(s, block, n, dc_pred_dir);
<1> static BusState *qbus_find_recursive(BusState *bus, const char *name,\n<15> if (name && (strcmp(bus->name, name) != 0)) {\n<17> match = 0;\n<29> return bus;\n<39> ret = qbus_find_recursive(child, name, info);
<1> int pci_device_load(PCIDevice *s, QEMUFile *f)\n<21> for (i = 0; i < sizeof config; ++i)\n<23> if ((config[i] ^ s->config[i]) & s->cmask[i] & ~s->wmask[i])\n<27> memcpy(s->config, config, sizeof config);\n<31> pci_update_mappings(s);
<1> static void hscroll ( AVCodecContext * avctx ) {\n<10> i < avctx -> height - s -> font_height ;\n<11> i ++ ) memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , s -> frame . data [ 0 ] + ( i + s -> font_height ) * s -> frame . linesize [ 0 ] , avctx -> width ) ;\n<13> i < avctx -> height ;\n<14> i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;
<1> static int vpc_open(BlockDriverState *bs, int flags)\n<67> if (vpc_checksum(s->footer_buf, HEADER_SIZE) != checksum)\n<69> fprintf(stderr, "block-vpc: The header checksum of '%s' is "
<1> static int msrle_decode_init(AVCodecContext *avctx)\n<5> MsrleContext *s = (MsrleContext *)avctx->priv_data;\n<29> memset (s->palette, 0, 256 * 4);
<1> static void v9fs_create_post_lstat(V9fsState *s, V9fsCreateState *vs, int err)\n<47> } else if (vs->perm & P9_STAT_MODE_DEVICE) {\n<57> if (sscanf(vs->extension.data, "%c %u %u", &ctype, &major,\n<61> err = -errno;\n<63> v9fs_post_create(s, vs, err);\n<95> err = v9fs_do_mknod(s, vs, nmode, makedev(major, minor));
<1> static void ttafilter_init(TTAContext *s, TTAFilter *c, int32_t shift) {\n<3> memset(c, 0, sizeof(TTAFilter));
<1> static int qdm2_decode(QDM2Context *q, const uint8_t *in, int16_t *out)\n<21> memmove(q->output_buffer, &q->output_buffer[frame_size], frame_size * sizeof(float));\n<23> memset(&q->output_buffer[frame_size], 0, frame_size * sizeof(float));\n<35> qdm2_decode_super_block(q);\n<47> qdm2_decode_fft_packets(q);\n<51> qdm2_fft_tone_synthesizer(q, q->sub_packet);\n<61> qdm2_calculate_fft(q, ch, q->sub_packet);\n<81> qdm2_synthesis_filter(q, q->sub_packet);
<1> build_facs(GArray *table_data, GArray *linker)\n<5> AcpiFacsDescriptorRev1 *facs = acpi_data_push(table_data, sizeof *facs);\n<7> memcpy(&facs->signature, "FACS", 4);
<8> if ( ! * buffer ) {\n<11> if ( * currlen > 0 ) {\n<12> assert ( * sbuffer != NULL ) ;\n<13> memcpy ( * buffer , * sbuffer , * currlen ) ;\n<24> if ( * currlen < * maxlen ) {
<1> void spapr_cpu_parse_features(sPAPRMachineState *spapr)\n<31> gchar *compat_str = NULL;\n<53> compat_str = inpieces[i];\n<73> if (compat_str) {\n<75> char *val = compat_str + strlen("compat=");\n<79> object_property_set_str(OBJECT(spapr), val, "max-cpu-compat",
<1> static void rv34_idct_add_c(uint8_t *dst, ptrdiff_t stride, DCTELEM *block){\n<11> rv34_row_transform(temp, block);\n<13> memset(block, 0, 16*sizeof(DCTELEM));
<1> static void mpc8_parse_seektable(AVFormatContext *s, int64_t off)\n<31> mpc8_get_chunk_header(s->pb, &tag, &size);\n<49> if(!(buf = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE)))\n<53> avio_read(s->pb, buf, size);\n<55> memset(buf+size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
<1> static int bdrv_snapshot_find(BlockDriverState *bs, QEMUSnapshotInfo *sn_info,\n<3> const char *name)\n<21> for(i = 0; i < nb_sns; i++) {\n<23> sn = &sn_tab[i];\n<25> if (!strcmp(sn->id_str, name) || !strcmp(sn->name, name)) {\n<27> *sn_info = *sn;\n<29> ret = 0;
<1> int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)\n<25> if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && pkt->size == 0) {\n<45> if (pkt->dts == AV_NOPTS_VALUE && !(s->oformat->flags & AVFMT_NOTIMESTAMPS)) {\n<67> int ret = interleave_packet(s, &opkt, pkt, flush);\n<69> if (pkt) {\n<71> memset(pkt, 0, sizeof(*pkt));\n<73> av_init_packet(pkt);
<1> static void lm32_uclinux_init(QEMUMachineInitArgs *args)\n<9> const char *kernel_cmdline = args->kernel_cmdline;\n<157> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<177> if (kernel_size < 0) {\n<179> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<221> if (kernel_cmdline && strlen(kernel_cmdline)) {\n<223> pstrcpy_targphys("cmdline", cmdline_base, TARGET_PAGE_SIZE,\n<227> reset_info->cmdline_base = cmdline_base;
<1> static int sonic_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<7> SonicContext *s = avctx->priv_data;\n<21> if ((ret = ff_alloc_packet2(avctx, avpkt, s->frame_size * 5 + 1000)) < 0)\n<31> memset(state, 128, sizeof(state));\n<89> memset(s->window, 0, 4* s->window_size);\n<119> modified_levinson_durbin(s->window, s->window_size,\n<123> if ((ret = intlist_write(&c, state, s->predictor_k, s->num_taps, 0)) < 0)
<1> hb_bool_t _hb_graphite2_shape ( hb_shape_plan_t * shape_plan , hb_font_t * font , hb_buffer_t * buffer , const hb_feature_t * features , unsigned int num_features ) {\n<5> const char * lang = hb_language_to_string ( hb_buffer_get_language ( buffer ) ) ;\n<6> const char * lang_end = lang ? strchr ( lang , '-' ) : NULL ;\n<7> int lang_len = lang_end ? lang_end - lang : - 1 ;
<1> int avpriv_vsnprintf(char *restrict s, size_t n, const char *restrict fmt,\n<3> va_list ap)\n<15> else if (n > INT_MAX)\n<33> memset(s, 0, n);\n<35> ret = vsnprintf(s, n - 1, fmt, ap);\n<37> if (ret == -1)
<1> static int usb_hub_handle_control(USBDevice *dev, int request, int value,\n<13> ret = usb_desc_handle_control(dev, request, value, index, length, data);\n<23> switch(request) {
<1> static void pflash_write(pflash_t *pfl, hwaddr offset,\n<55> p = pfl->storage;\n<57> offset &= ~(pfl->sector_len - 1);\n<67> if (!pfl->ro) {\n<69> memset(p + offset, 0xff, pfl->sector_len);\n<71> pflash_update(pfl, offset, pfl->sector_len);
<7> res = r -> parse_slice_header ( r , gb , & r -> si ) ;\n<13> if ( slice_type != s -> pict_type ) {\n<27> memset ( r -> intra_types_hist , - 1 , r -> intra_types_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ;\n<32> while ( ! check_slice_end ( r , s ) ) {\n<34> if ( r -> si . type ) res = rv34_decode_inter_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n<35> else res = rv34_decode_intra_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n<40> if ( ++ s -> mb_x == s -> mb_width ) {\n<44> memmove ( r -> intra_types_hist , r -> intra_types , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n<45> memset ( r -> intra_types , - 1 , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n<46> if ( r -> loop_filter && s -> mb_y >= 2 ) r -> loop_filter ( r , s -> mb_y - 2 ) ;
<1> static int kvm_mce_in_progress(CPUState *env)\n<17> if (r == -1 || r == 0) {\n<19> fprintf(stderr, "Failed to get MCE status\n");
<1> bool id_h ( connection_t * c ) {\n<7> if ( ! check_id ( name ) ) {\n<11> if ( c -> outgoing ) {\n<12> if ( strcmp ( c -> name , name ) ) {\n<13> logger ( LOG_ERR , "Peer %s is %s instead of %s" , c -> hostname , name , c -> name ) ;\n<14> return false ;\n<18> if ( c -> name ) {\n<19> free ( c -> name ) ;\n<23> if ( c -> protocol_version != myself -> connection -> protocol_version ) {\n<24> logger ( LOG_ERR , "Peer %s (%s) uses incompatible version %d" , c -> name , c -> hostname , c -> protocol_version ) ;\n<32> return send_ack ( c ) ;\n<36> if ( ! read_connection_config ( c ) ) {\n<37> logger ( LOG_ERR , "Peer %s had unknown identity (%s)" , c -> hostname , c -> name ) ;\n<41> if ( ! read_rsa_public_key ( c ) ) {\n<45> return send_metakey ( c ) ;
<1> static void kvm_mce_inj_srao_memscrub(CPUState *env, target_phys_addr_t paddr)\n<29> if (r < 0) {\n<31> fprintf(stderr, "kvm_set_mce: %s\n", strerror(errno));
<1> static void term_delete_char(void)\n<5> if (term_cmd_buf_index < term_cmd_buf_size) {\n<11> term_cmd_buf_size - term_cmd_buf_index - 1);
<1> CharDriverState *qemu_chr_find(const char *name)\n<9> TAILQ_FOREACH(chr, &chardevs, next) {\n<11> if (strcmp(chr->label, name) != 0)\n<15> return chr;
<27> if (rc < 0) {\n<29> error_report("cannot get SG_IO version number: %s.  "\n<33> strerror(-rc));
<1> static char *addr_to_string(const char *format,\n<17> if ((err = getnameinfo((struct sockaddr *)sa, salen,\n<35> if (asprintf(&addr, format, host, serv) < 0)\n<37> return NULL;\n<41> return addr;
<1> static int queue_picture(VideoState *is, AVFrame *src_frame, double pts, int64_t pos)\n<181> if (is->img_convert_ctx == NULL) {\n<183> fprintf(stderr, "Cannot initialize the conversion context\n");
<1> static void omap_disc_write(void *opaque, hwaddr addr,\n<65> if (!((s->dispc.l[1].attr | s->dispc.l[2].attr) & 1)) {\n<67> fprintf(stderr, "%s: Overlay Optimization when no overlay "\n<303> if (value & (3 << 9))\n<305> fprintf(stderr, "%s: Big-endian pixel format not supported\n",
<1> AVOption *av_set_string(void *obj, const char *name, const char *val){\n<3> AVOption *o= find_opt(obj, name);\n<5> if(!o || !val || o->offset<=0)\n<9> if(o->type != FF_OPT_TYPE_STRING){\n<25> buf[i]=0;\n<39> AVOption *o_named= find_opt(obj, buf);\n<41> if(o_named && o_named->type == FF_OPT_TYPE_CONST)\n<45> else if(!strcmp(buf, "default")) d+= o->default_val;\n<47> else if(!strcmp(buf, "max"    )) d+= o->max;\n<49> else if(!strcmp(buf, "min"    )) d+= o->min;\n<51> else return NULL;\n<57> if(*val == '+') val++;\n<59> if(!*val)\n<71> memcpy(((uint8_t*)obj) + o->offset, val, sizeof(val));
<1> static void draw_curves(AVFilterContext *ctx, AVFilterLink *inlink, AVFrame *out)\n<15> if (!colors)\n<21> memset(out->data[0], 0, s->h * out->linesize[0]);\n<99> AV_WL32(out->data[0] + y * out->linesize[0] + x * 4, AV_RL32(fg));\n<105> AV_WL32(out->data[0] + y * out->linesize[0] + x * 4, AV_RL32(fg));
<1> static int mux_proc_byte(CharDriverState *chr, MuxDriver *d, int ch)\n<13> switch(ch) {\n<27> const char *term =  "QEMU: Terminated\n\r";\n<29> qemu_chr_fe_write(chr, (uint8_t *)term, strlen(term));
<1> static void addFile ( const char * filename , const char * name , const char * source , UBool sourceTOC , UBool verbose ) {\n<5> if ( fileCount == fileMax ) {\n<8> if ( files == NULL ) {\n<9> fprintf ( stderr , "pkgdata/gencmn: Could not allocate %u bytes for %d files\n" , ( unsigned int ) ( fileMax * sizeof ( files [ 0 ] ) ) , fileCount ) ;\n<15> if ( uprv_pathIsAbsolute ( filename ) ) {\n<16> fprintf ( stderr , "gencmn: Error: absolute path encountered. Old style paths are not supported. Use relative paths such as 'fur.res' or 'translit%cfur.res'.\n\tBad path: '%s'\n" , U_FILE_SEP_CHAR , filename ) ;\n<19> fullPath = pathToFullPath ( filename , source ) ;\n<30> file = T_FileStream_open ( fullPath , "rb" ) ;\n<31> if ( file == NULL ) {\n<32> fprintf ( stderr , "gencmn: unable to open listed file %s\n" , fullPath ) ;\n<35> length = T_FileStream_size ( file ) ;\n<36> if ( T_FileStream_error ( file ) || length <= 20 ) {\n<37> fprintf ( stderr , "gencmn: unable to get length of listed file %s\n" , fullPath ) ;\n<41> if ( maxSize && length > maxSize ) {\n<42> if ( verbose ) {\n<43> printf ( "%s ignored (size %ld > %ld)\n" , fullPath , ( long ) length , ( long ) maxSize ) ;\n<71> ++ fileCount ;
<1> static int sd_snapshot_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab)\n<5> BDRVSheepdogState *s = bs->opaque;\n<35> if (fd < 0) {\n<51> memset(&req, 0, sizeof(req));\n<61> ret = do_req(fd, (SheepdogReq *)&req, vdi_inuse, &wlen, &rlen);\n<67> if (ret) {\n<81> hval = fnv_64a_buf(s->name, strlen(s->name), FNV1A_64_INIT);\n<83> start_nr = hval & (SD_NR_VDIS - 1);\n<113> ret = read_object(fd, (char *)&inode, vid_to_vdi_oid(vid),\n<121> if (ret) {\n<129> if (!strcmp(inode.name, s->name) && is_snapshot(&inode)) {\n<131> sn_tab[found].date_sec = inode.snap_ctime >> 32;\n<133> sn_tab[found].date_nsec = inode.snap_ctime & 0xffffffff;\n<135> sn_tab[found].vm_state_size = inode.vm_state_size;\n<137> sn_tab[found].vm_clock_nsec = inode.vm_clock_nsec;\n<141> snprintf(sn_tab[found].id_str, sizeof(sn_tab[found].id_str), "%u",\n<143> inode.snap_id);\n<145> pstrcpy(sn_tab[found].name,\n<147> MIN(sizeof(sn_tab[found].name), sizeof(inode.tag)),\n<149> inode.tag);\n<151> found++;
<1> static void palmte_init(MachineState *machine)\n<95> rom_size = get_image_size(option_rom[0].name);\n<97> if (rom_size > flash_size) {\n<99> fprintf(stderr, "%s: ROM image too big (%x > %x)\n",\n<109> rom_size = load_image_targphys(option_rom[0].name, OMAP_CS0_BASE,\n<117> if (rom_size < 0) {\n<129> if (!rom_loaded && !kernel_filename && !qtest_enabled()) {\n<131> fprintf(stderr, "Kernel or ROM image must be specified\n");
<1> static AVFrame *apply_palette(AVFilterLink *inlink, AVFrame *in)\n<61> if (s->set_frame(s, out, in, x, y, w, h) < 0) {\n<69> memcpy(out->data[1], s->palette, AVPALETTE_SIZE);\n<73> debug_mean_error(s, in, out, inlink->frame_count_out);
<1> DriveInfo *drive_init(QemuOpts *opts, void *opaque,\n<107> if ((buf = qemu_opt_get(opts, "if")) != NULL) {\n<109> pstrcpy(devname, sizeof(devname), buf);\n<111> if (!strcmp(buf, "ide")) {\n<113> type = IF_IDE;\n<115> max_devs = MAX_IDE_DEVS;\n<117> } else if (!strcmp(buf, "scsi")) {\n<119> type = IF_SCSI;\n<121> max_devs = MAX_SCSI_DEVS;\n<123> } else if (!strcmp(buf, "floppy")) {\n<125> type = IF_FLOPPY;\n<127> max_devs = 0;\n<129> } else if (!strcmp(buf, "pflash")) {\n<131> type = IF_PFLASH;\n<133> max_devs = 0;\n<135> } else if (!strcmp(buf, "mtd")) {\n<137> type = IF_MTD;\n<139> max_devs = 0;\n<141> } else if (!strcmp(buf, "sd")) {\n<143> type = IF_SD;\n<145> max_devs = 0;\n<147> } else if (!strcmp(buf, "virtio")) {\n<149> type = IF_VIRTIO;\n<151> max_devs = 0;\n<153> } else if (!strcmp(buf, "xen")) {\n<155> type = IF_XEN;\n<157> max_devs = 0;\n<159> } else if (!strcmp(buf, "none")) {\n<161> type = IF_NONE;\n<163> max_devs = 0;\n<167> fprintf(stderr, "qemu: unsupported bus type '%s'\n", buf);\n<169> return NULL;\n<177> if (cyls || heads || secs) {\n<179> if (cyls < 1 || cyls > 16383) {\n<181> fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", buf);\n<187> if (heads < 1 || heads > 16) {\n<189> fprintf(stderr, "qemu: '%s' invalid physical heads number\n", buf);\n<195> if (secs < 1 || secs > 63) {\n<197> fprintf(stderr, "qemu: '%s' invalid physical secs number\n", buf);\n<207> if ((buf = qemu_opt_get(opts, "trans")) != NULL) {\n<209> if (!cyls) {\n<221> if (!strcmp(buf, "none"))\n<223> translation = BIOS_ATA_TRANSLATION_NONE;\n<225> else if (!strcmp(buf, "lba"))\n<227> translation = BIOS_ATA_TRANSLATION_LBA;\n<229> else if (!strcmp(buf, "auto"))\n<231> translation = BIOS_ATA_TRANSLATION_AUTO;\n<235> fprintf(stderr, "qemu: '%s' invalid translation type\n", buf);\n<237> return NULL;\n<245> if ((buf = qemu_opt_get(opts, "media")) != NULL) {\n<247> if (!strcmp(buf, "disk")) {\n<249> media = MEDIA_DISK;\n<251> } else if (!strcmp(buf, "cdrom")) {\n<253> if (cyls || secs || heads) {\n<267> fprintf(stderr, "qemu: '%s' invalid media\n", buf);\n<269> return NULL;\n<277> if ((buf = qemu_opt_get(opts, "cache")) != NULL) {\n<279> if (!strcmp(buf, "off") || !strcmp(buf, "none"))\n<281> cache = 0;\n<283> else if (!strcmp(buf, "writethrough"))\n<285> cache = 1;\n<287> else if (!strcmp(buf, "writeback"))\n<289> cache = 2;\n<293> fprintf(stderr, "qemu: invalid cache option\n");\n<295> return NULL;\n<329> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<331> if (strcmp(buf, "?") == 0) {\n<333> fprintf(stderr, "qemu: Supported formats:");\n<335> bdrv_iterate_format(bdrv_format_print, NULL);\n<337> fprintf(stderr, "\n");\n<339> return NULL;\n<343> drv = bdrv_find_format(buf);\n<345> if (!drv) {\n<347> fprintf(stderr, "qemu: '%s' invalid format\n", buf);\n<359> if ((buf = qemu_opt_get(opts, "werror")) != NULL) {\n<361> if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n<363> fprintf(stderr, "werror is no supported by this format\n");\n<369> if (!strcmp(buf, "ignore"))\n<371> onerror = BLOCK_ERR_IGNORE;\n<373> else if (!strcmp(buf, "enospc"))\n<375> onerror = BLOCK_ERR_STOP_ENOSPC;\n<377> else if (!strcmp(buf, "stop"))\n<379> onerror = BLOCK_ERR_STOP_ANY;\n<381> else if (!strcmp(buf, "report"))\n<383> onerror = BLOCK_ERR_REPORT;\n<387> fprintf(stderr, "qemu: '%s' invalid write error action\n", buf);\n<389> return NULL;\n<397> if ((devaddr = qemu_opt_get(opts, "addr")) != NULL) {\n<399> if (type != IF_VIRTIO) {\n<401> fprintf(stderr, "addr is not supported\n");\n<417> if (bus_id != 0 || unit_id != -1) {\n<455> if (unit_id == -1) {\n<459> while (drive_get(type, bus_id, unit_id) != NULL) {\n<481> if (max_devs && unit_id >= max_devs) {\n<483> fprintf(stderr, "qemu: unit %d too big (max is %d)\n",\n<485> unit_id, max_devs - 1);\n<515> dinfo = qemu_mallocz(sizeof(*dinfo));\n<559> if (serial)\n<561> strncpy(dinfo->serial, serial, sizeof(serial));\n<563> TAILQ_INSERT_TAIL(&drives, dinfo, next);\n<681> if (bdrv_open2(dinfo->bdrv, file, bdrv_flags, drv) < 0) {\n<683> fprintf(stderr, "qemu: could not open disk image %s\n",\n<699> return dinfo;
<1> int ff_start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n<93> if (av_pix_fmt_descriptors[link->format].flags & PIX_FMT_PAL)\n<95> memcpy(link->cur_buf->data[1], link->src_buf-> data[1], AVPALETTE_SIZE);
<1> void os_host_main_loop_wait(int *timeout)\n<45> for(i = (ret - WAIT_OBJECT_0 + 1); i < w->num; i++) {\n<59> } else if (ret2 == WAIT_TIMEOUT) {\n<63> err = GetLastError();\n<65> fprintf(stderr, "WaitForSingleObject error %d %d\n", i, err);\n<71> } else if (ret == WAIT_TIMEOUT) {\n<75> err = GetLastError();\n<77> fprintf(stderr, "WaitForMultipleObjects error %d %d\n", ret, err);
<1> static gcry_err_code_t sexp_to_key ( gcry_sexp_t sexp , int want_private , int use , const char * override_elems , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * r_is_ecc ) {\n<18> if ( ! name ) {\n<22> if ( ! strcmp ( name , "ecc" ) ) is_ecc = 2 ;\n<23> else if ( ! strcmp ( name , "ecdsa" ) || ! strcmp ( name , "ecdh" ) ) is_ecc = 1 ;\n<24> else is_ecc = 0 ;\n<28> else module = gcry_pk_lookup_name ( name ) ;\n<30> gcry_free ( name ) ;\n<31> if ( ! module ) {\n<39> if ( override_elems ) elems = override_elems ;\n<40> else if ( want_private ) elems = pubkey -> elements_skey ;\n<41> else elems = pubkey -> elements_pkey ;\n<42> array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n<43> if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n<45> if ( is_ecc ) err = sexp_elements_extract_ecc ( list , elems , array , extraspec , want_private ) ;\n<46> else err = sexp_elements_extract ( list , elems , array , pubkey -> name ) ;
<1> AVFilterContext *avfilter_graph_get_filter(AVFilterGraph *graph, char *name)\n<9> if(!name)\n<15> for(i = 0; i < graph->filter_count; i ++)\n<17> if(graph->filters[i]->name && !strcmp(name, graph->filters[i]->name))\n<19> return graph->filters[i];
<1> static void print_report(const char *op, struct timeval *t, int64_t offset,\n<3> int64_t count, int64_t total, int cnt, int Cflag)\n<11> timestr(t, ts, sizeof(ts), Cflag ? VERBOSE_FIXED_TIME : 0);\n<13> if (!Cflag) {\n<15> cvtstr((double)total, s1, sizeof(s1));\n<17> cvtstr(tdiv((double)total, *t), s2, sizeof(s2));\n<23> printf("%s, %d ops; %s (%s/sec and %.4f ops/sec)\n",\n<25> s1, cnt, ts, s2, tdiv((double)cnt, *t));
<1> int tap_open(char *ifname, int ifname_size, int *vnet_hdr,\n<19> if (fd < 0) {\n<27> memset(&ifr, 0, sizeof(ifr));\n<33> if (ioctl(fd, TUNGETFEATURES, &features) == -1) {\n<35> error_report("warning: TUNGETFEATURES failed: %s", strerror(errno));\n<127> ret = ioctl(fd, TUNSETIFF, (void *) &ifr);\n<133> error_setg_errno(errp, errno, "could not configure %s (%s)",\n<139> error_setg_errno(errp, errno, "could not configure %s",\n<151> pstrcpy(ifname, ifname_size, ifr.ifr_name);
<1> static inline void dv_decode_video_segment(DVVideoContext *s,\n<47> memset(sblock, 0, sizeof(sblock));
<1> int main ( int argc , char * * argv ) {\n<37> printf ( "Using %s\n" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n<54> if ( res ) {\n<55> printf ( "Failed to get config: %s\n" , vpx_codec_err_to_string ( res ) ) ;\n<174> printf ( "\n" ) ;\n<175> printf ( "Frame cnt and encoding time/FPS stats for encoding: %d %f %f \n" , frame_cnt , * ( float ) cx_time / ( double ) ( frame_cnt * 1000000 ) , * ( double ) frame_cnt / ( double ) cx_time ) ;
<1> static void mpc8544_guts_write(void *opaque, target_phys_addr_t addr,\n<3> uint64_t value, unsigned size)\n<7> addr &= MPC8544_GUTS_MMIO_SIZE - 1;\n<11> switch (addr) {\n<25> fprintf(stderr, "guts: Unknown register write: %x = %x\n",
<1> int ff_mov_iso639_to_lang(const char *lang, int mp4)\n<11> for (i = 0; !mp4 && i < FF_ARRAY_ELEMS(mov_mdhd_language_map); i++) {\n<13> if (mov_mdhd_language_map[i] && !strcmp(lang, mov_mdhd_language_map[i]))\n<15> return i;\n<27> if (lang[0] == '\0')\n<35> unsigned char c = (unsigned char)lang[i];
<1> static int ra144_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<15> int32_t lpc_data[NBLOCKS * BLOCKSIZE];\n<65> energy += (lpc_data[i] * lpc_data[i]) >> 4;\n<77> energy += (lpc_data[i] * lpc_data[i]) >> 4;\n<83> if (i < NBLOCKS * BLOCKSIZE)\n<85> memset(&lpc_data[i], 0, (NBLOCKS * BLOCKSIZE - i) * sizeof(*lpc_data));\n<127> if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) {\n<131> memset(lpc_refl, 0, sizeof(lpc_refl));\n<141> idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]);\n<149> ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);\n<161> refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);\n<171> ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE,\n<189> if (frame) {\n<193> ractx->curr_block[i] = samples[i] >> 2;\n<197> if ((ret = ff_af_queue_add(&ractx->afq, frame)) < 0)\n<207> (NBLOCKS * BLOCKSIZE - i) * sizeof(*ractx->curr_block));
<1> void IGDstartelt ( void * d , const char * name , int l ) {\n<2> struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n<3> memcpy ( datas -> cureltname , name , l ) ;\n<6> if ( ( l == 7 ) && ! memcmp ( name , "service" , l ) ) {\n<7> datas -> tmp . controlurl [ 0 ] = '\0' ;\n<8> datas -> tmp . eventsuburl [ 0 ] = '\0' ;\n<9> datas -> tmp . scpdurl [ 0 ] = '\0' ;\n<10> datas -> tmp . servicetype [ 0 ] = '\0' ;
<1> int av_opencl_buffer_write(cl_mem dst_cl_buf, uint8_t *src_buf, size_t buf_size)\n<7> void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, dst_cl_buf,\n<9> CL_TRUE,CL_MAP_WRITE, 0, sizeof(uint8_t) * buf_size,\n<15> if (status != CL_SUCCESS) {\n<23> memcpy(mapped, src_buf, buf_size);\n<27> status = clEnqueueUnmapMemObject(gpu_env.command_queue, dst_cl_buf, mapped, 0, NULL, NULL);
<1> static int m25p80_init(SSISlave *ss)\n<9> M25P80Class *mc = M25P80_GET_CLASS(s);\n<21> s->storage = qemu_blockalign(s->bdrv, s->size);\n<29> if (dinfo) {\n<39> if (bdrv_read(s->bdrv, 0, s->storage, DIV_ROUND_UP(s->size,\n<43> fprintf(stderr, "Failed to initialize SPI flash!\n");\n<53> memset(s->storage, 0xFF, s->size);
<1> static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vstream, const char *key, int64_t max_pos, int depth) {\n<129> if(depth == 1 && key) { //only look for metadata values when we are not nested and key != NULL\n<133> vcodec = vstream ? vstream->codec : NULL;\n<139> } else if(amf_type == AMF_DATA_TYPE_NUMBER) {\n<141> if(!strcmp(key, "duration")) s->duration = num_val * AV_TIME_BASE;\n<143> else if(!strcmp(key, "videodatarate") && vcodec && 0 <= (int)(num_val * 1024.0))\n<145> vcodec->bit_rate = num_val * 1024.0;
<1> static int open_output_file(OptionsContext *o, const char *filename)\n<89> if (!strcmp(filename, "-"))\n<91> filename = "pipe:";\n<95> err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);\n<115> file_oformat= oc->oformat;\n<161> if (!strcmp(file_oformat->name, "ffm") &&\n<163> av_strstart(filename, "http:", NULL)) {\n<165> int err = parse_option(o, "metadata", "creation_time=now", options);\n<167> if (err < 0) {\n<179> if (!strcmp(file_oformat->name, "ffm") && !override_ffserver &&\n<181> av_strstart(filename, "http:", NULL)) {\n<189> int err = read_ffserver_streams(o, oc, filename);\n<191> if (err < 0) {\n<199> for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {\n<237> } else if (!o->nb_stream_maps) {\n<343> StreamMap *map = &o->stream_maps[i];\n<367> for (k = 0; k < fg->nb_outputs; k++) {\n<369> AVFilterInOut *out = fg->outputs[k]->out_tmp;\n<371> if (out && !strcmp(out->name, map->linklabel)) {\n<373> ofilter = fg->outputs[k];\n<387> av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist "\n<537> && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))\n<567> while ((e = av_dict_get(unused_opts, "", e, AV_DICT_IGNORE_SUFFIX))) {\n<575> if (!option)\n<581> av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for "\n<597> if (!strcmp(e->key, "gop_timecode"))\n<603> av_log(NULL, AV_LOG_WARNING, "Codec AVOption %s (%s) specified for "\n<611> "which was not actually used for any stream.\n", e->key,\n<613> option->help ? option->help : "", nb_output_files - 1, filename);\n<637> if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n<659> } else if (strcmp(oc->oformat->name, "image2")==0 && !av_filename_number_test(filename))\n<661> assert_file_overwrite(filename);\n<783> for (i = 0; i < o->nb_metadata; i++) {\n<795> val = strchr(o->metadata[i].u.str, '=');\n<797> if (!val) {\n<799> av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n",\n<819> av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n<861> av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);
<1> static int g723_1_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<7> G723_1_Context *p = avctx->priv_data;\n<17> int16_t vector[FRAME_LEN + PITCH_MAX];\n<31> highpass_filter(in, &p->hpf_fir_mem, &p->hpf_iir_mem);\n<35> memcpy(vector, p->prev_data, HALF_FRAME_LEN * sizeof(int16_t));\n<37> memcpy(vector + HALF_FRAME_LEN, in, FRAME_LEN * sizeof(int16_t));\n<41> comp_lpc_coeff(vector, unq_lpc);\n<43> lpc2lsp(&unq_lpc[LPC_ORDER * 3], p->prev_lsp, cur_lsp);\n<51> memcpy(vector + LPC_ORDER, p->prev_data + SUBFRAME_LEN,\n<53> sizeof(int16_t) * SUBFRAME_LEN);\n<57> sizeof(int16_t) * (HALF_FRAME_LEN + SUBFRAME_LEN));\n<59> memcpy(p->prev_data, in + HALF_FRAME_LEN,\n<61> sizeof(int16_t) * HALF_FRAME_LEN);\n<63> memcpy(in, vector + LPC_ORDER, sizeof(int16_t) * FRAME_LEN);\n<67> perceptual_filter(p, weighted_lpc, unq_lpc, vector);\n<71> memcpy(in, vector + LPC_ORDER, sizeof(int16_t) * FRAME_LEN);\n<73> memcpy(vector, p->prev_weight_sig, sizeof(int16_t) * PITCH_MAX);\n<75> memcpy(vector + PITCH_MAX, in, sizeof(int16_t) * FRAME_LEN);\n<79> scale_vector(vector, vector, FRAME_LEN + PITCH_MAX);\n<85> p->pitch_lag[1] = estimate_pitch(vector, PITCH_MAX + HALF_FRAME_LEN);\n<95> memcpy(vector, p->prev_weight_sig, sizeof(int16_t) * PITCH_MAX);\n<97> memcpy(vector + PITCH_MAX, in, sizeof(int16_t) * FRAME_LEN);\n<99> memcpy(p->prev_weight_sig, vector + FRAME_LEN, sizeof(int16_t) * PITCH_MAX);\n<105> harmonic_filter(hf + j, vector + PITCH_MAX + i, in + i);\n<111> lsp_interpolate(qnt_lpc, cur_lsp, p->prev_lsp);\n<115> memcpy(p->prev_lsp, cur_lsp, sizeof(int16_t) * LPC_ORDER);\n<121> for (i = 0; i < SUBFRAMES; i++) {\n<127> int16_t flt_in[SUBFRAME_LEN];\n<129> int16_t zero[LPC_ORDER], fir[LPC_ORDER], iir[LPC_ORDER];\n<141> memset(zero, 0, sizeof(int16_t) * LPC_ORDER);\n<143> memset(vector, 0, sizeof(int16_t) * PITCH_MAX);\n<145> memset(flt_in, 0, sizeof(int16_t) * SUBFRAME_LEN);\n<151> synth_percept_filter(qnt_lpc + offset, weighted_lpc + (offset << 1),\n<153> zero, zero, flt_in, vector + PITCH_MAX, 1);\n<155> harmonic_filter(hf + i, vector + PITCH_MAX, impulse_resp);\n<161> flt_in[0] = 0;\n<163> memcpy(fir, p->perf_fir_mem, sizeof(int16_t) * LPC_ORDER);\n<165> memcpy(iir, p->perf_iir_mem, sizeof(int16_t) * LPC_ORDER);\n<169> synth_percept_filter(qnt_lpc + offset, weighted_lpc + (offset << 1),\n<171> fir, iir, flt_in, vector + PITCH_MAX, 0);\n<173> memcpy(vector, p->harmonic_mem, sizeof(int16_t) * PITCH_MAX);\n<175> harmonic_noise_sub(hf + i, vector + PITCH_MAX, in);\n<179> acb_search(p, residual, impulse_resp, in, i);\n<181> gen_acb_excitation(residual, p->prev_excitation,p->pitch_lag[i >> 1],\n<189> fcb_search(p, impulse_resp, in, i);\n<195> gen_acb_excitation(impulse_resp, p->prev_excitation, p->pitch_lag[i >> 1],\n<201> memmove(p->prev_excitation, p->prev_excitation + SUBFRAME_LEN,\n<203> sizeof(int16_t) * (PITCH_MAX - SUBFRAME_LEN));\n<207> in[j] = av_clip_int16((in[j] << 1) + impulse_resp[j]);\n<209> memcpy(p->prev_excitation + PITCH_MAX - SUBFRAME_LEN, in,\n<211> sizeof(int16_t) * SUBFRAME_LEN);\n<217> synth_percept_filter(qnt_lpc + offset, weighted_lpc + (offset << 1),\n<221> in, vector + PITCH_MAX, 0);\n<223> memmove(p->harmonic_mem, p->harmonic_mem + SUBFRAME_LEN,\n<225> sizeof(int16_t) * (PITCH_MAX - SUBFRAME_LEN));\n<227> memcpy(p->harmonic_mem + PITCH_MAX - SUBFRAME_LEN, vector + PITCH_MAX,\n<229> sizeof(int16_t) * SUBFRAME_LEN);\n<249> avpkt->size = pack_bitstream(p, avpkt->data, avpkt->size);
<1> static void write_codec_attr(AVStream *st, VariantStream *vs) {\n<3> int codec_strlen = strlen(vs->codec_attr);\n<65> if (!av_stristr(vs->codec_attr, attr)) {\n<67> snprintf(vs->codec_attr + codec_strlen,\n<69> sizeof(vs->codec_attr) - codec_strlen,
<1> static void dump_ops(const uint16_t *opc_buf)\n<15> fprintf(logfile, "0x%04x: %s\n", opc_ptr - opc_buf - 1, op_str[c]);\n<17> if (c == INDEX_op_end)
<1> static void add_flagname_to_bitmaps(char *flagname, uint32_t *features,\n<17> for ( i = 0 ; i < 32 ; i++ )\n<19> if (feature_name[i] && !strcmp (flagname, feature_name[i])) {\n<21> *features |= 1 << i;\n<23> found = 1;\n<27> for ( i = 0 ; i < 32 ; i++ )\n<29> if (ext_feature_name[i] && !strcmp (flagname, ext_feature_name[i])) {\n<31> *ext_features |= 1 << i;\n<33> found = 1;\n<37> for ( i = 0 ; i < 32 ; i++ )\n<39> if (ext2_feature_name[i] && !strcmp (flagname, ext2_feature_name[i])) {\n<41> *ext2_features |= 1 << i;\n<43> found = 1;\n<47> for ( i = 0 ; i < 32 ; i++ )\n<49> if (ext3_feature_name[i] && !strcmp (flagname, ext3_feature_name[i])) {\n<51> *ext3_features |= 1 << i;\n<53> found = 1;\n<57> if (!found) {\n<59> fprintf(stderr, "CPU feature %s not found\n", flagname);
<1> int ff_mjpeg_decode_sos(MJpegDecodeContext *s,\n<195> if(ff_jpegls_decode_picture(s, predictor, point_transform, ilv) < 0)\n<203> if(ljpeg_decode_rgb_scan(s, nb_components, predictor, point_transform) < 0)\n<209> if(ljpeg_decode_yuv_scan(s, predictor, point_transform) < 0)\n<223> if(mjpeg_decode_scan_progressive_ac(s, predictor, ilv, prev_shift, point_transform) < 0)\n<229> if(mjpeg_decode_scan(s, nb_components, prev_shift, point_transform,\n<255> uint8_t *dst = &((uint8_t *)s->picture_ptr->data[2])[(s->height - 1) * s->linesize[2]];\n<263> if (src1 == src2) {\n<265> memcpy(dst, src1, s->width);\n<269> for (index = 0; index < s->width; index++)\n<271> dst[index] = (src1[index] + src2[index]) >> 1;\n<275> dst -= s->linesize[2];
<1> static int cpu_x86_find_by_name(X86CPU *cpu, x86_def_t *x86_cpu_def,\n<13> if (name == NULL) {\n<19> if (kvm_enabled() && strcmp(name, "host") == 0) {\n<21> kvm_cpu_fill_host(x86_cpu_def);\n<23> object_property_set_bool(OBJECT(cpu), true, "pmu", &error_abort);\n<25> return 0;\n<31> for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {\n<33> def = &builtin_x86_defs[i];\n<35> if (strcmp(name, def->name) == 0) {\n<37> memcpy(x86_cpu_def, def, sizeof(*def));\n<53> if (kvm_enabled()) {\n<59> x86_cpu_vendor_words2str(x86_cpu_def->vendor, ebx, edx, ecx);\n<63> return 0;
<1> static int kvm_put_sregs(CPUState *env)\n<9> memset(sregs.interrupt_bitmap, 0, sizeof(sregs.interrupt_bitmap));\n<89> return kvm_vcpu_ioctl(env, KVM_SET_SREGS, &sregs);
<1> static inline abi_long target_to_host_cmsg(struct msghdr *msgh,\n<37> void *data = CMSG_DATA(cmsg);\n<39> void *target_data = TARGET_CMSG_DATA(target_cmsg);\n<75> cmsg->cmsg_len = CMSG_LEN(len);\n<79> if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n<83> memcpy(data, target_data, len);
<1> static void async_complete(void *opaque)\n<25> if (urbs > 2) {\n<27> fprintf(stderr, "husb: %d iso urbs finished at once\n", urbs);\n<91> if (inflight == 0 && is_iso_started(s, pid, ep)) {\n<93> fprintf(stderr, "husb: out of buffers for iso stream\n");
<1> static void mvc_fast_memset(CPUS390XState *env, uint32_t l, uint64_t dest,\n<3> uint8_t byte)\n<11> hwaddr len = l;\n<23> cpu_stb_data(env, dest, byte);\n<33> dest_p = cpu_physical_memory_map(dest_phys, &len, 1);\n<37> memset(dest_p, byte, len);\n<41> cpu_physical_memory_unmap(dest_p, 1, len, len);
<1> xsltDocumentPtr xsltNewDocument ( xsltTransformContextPtr ctxt , xmlDocPtr doc ) {\n<4> if ( cur == NULL ) {\n<8> memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n<13> ctxt -> docList = cur ;\n<16> return ( cur ) ;
<1> static void kvm_arm_gic_put(GICState *s)\n<53> kvm_gicd_access(s, 0x4, 0, &reg, false);\n<61> if (num_irq < s->num_irq) {\n<63> fprintf(stderr, "Restoring %u IRQs, but kernel supports max %d\n",\n<69> } else if (num_cpu != s->num_cpu) {\n<71> fprintf(stderr, "Restoring %u CPU interfaces, kernel only has %d\n",\n<89> kvm_dist_put(s, 0x180, 1, s->num_irq, translate_clear);\n<91> kvm_dist_put(s, 0x100, 1, s->num_irq, translate_enabled);\n<97> kvm_dist_put(s, 0x80, 1, s->num_irq, translate_group);\n<107> kvm_dist_put(s, 0x800, 8, s->num_irq, translate_targets);\n<117> kvm_dist_put(s, 0xc00, 2, s->num_irq, translate_trigger);\n<123> kvm_dist_put(s, 0x280, 1, s->num_irq, translate_clear);\n<125> kvm_dist_put(s, 0x200, 1, s->num_irq, translate_pending);\n<131> kvm_dist_put(s, 0x380, 1, s->num_irq, translate_clear);\n<133> kvm_dist_put(s, 0x300, 1, s->num_irq, translate_active);\n<141> kvm_dist_put(s, 0x400, 8, s->num_irq, translate_priority);\n<147> kvm_dist_put(s, 0xf10, 8, GIC_NR_SGIS, translate_clear);\n<149> kvm_dist_put(s, 0xf20, 8, GIC_NR_SGIS, translate_sgisource);\n<163> for (cpu = 0; cpu < s->num_cpu; cpu++) {
<1> static void nic_receive(void *opaque, const uint8_t * buf, size_t size)\n<13> EEPRO100State *s = opaque;\n<49> } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & 8)) {\n<59> } else if (memcmp(buf, s->macaddr, 6) == 0) {       // !!!\n<65> logout("%p received frame for me, len=%d\n", s, size);\n<67> } else if (memcmp(buf, broadcast_macaddr, 6) == 0) {\n<71> logout("%p received broadcast, len=%d\n", s, size);\n<73> rfd_status |= 0x0002;\n<75> } else if (buf[0] & 0x01) { // !!!\n<79> logout("%p received multicast, len=%d\n", s, size);\n<85> int mcast_idx = compute_mcast_idx(buf);\n<99> logout("%p received frame in promiscuous mode, len=%d\n", s, size);\n<105> logout("%p received frame, ignored, len=%d,%s\n", s, size,\n<107> nic_dump(buf, size));\n<115> if (get_ru_state(s) != ru_ready) {\n<119> logout("no ressources, state=%u\n", get_ru_state(s));\n<173> cpu_physical_memory_write(s->ru_base + s->ru_offset +\n<179> eepro100_fr_interrupt(s);\n<195> set_ru_state(s, ru_suspended);
<1> int64_t cpu_get_icount ( void ) {\n<6> if ( ! can_do_io ( env ) ) {\n<7> fprintf ( stderr , "Bad clock read\n" ) ;
<1> static int get_stream_blocksize(BlockDriverState *bdrv)\n<17> memset(cmd, 0, sizeof(cmd));\n<19> memset(buf, 0, sizeof(buf));\n<27> memset(&io_header, 0, sizeof(io_header));\n<37> io_header.cmdp = cmd;\n<49> ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n<51> if (ret < 0 || io_header.driver_status || io_header.host_status) {
<1> int ff_h264_decode_ref_pic_list_reordering(H264Context *h)\n<155> if (i < 0) {\n<159> memset(&h->ref_list[list][index], 0, sizeof(Picture)); //FIXME\n<179> COPY_PICTURE(&h->ref_list[list][index], ref);\n<183> pic_as_field(&h->ref_list[list][index], pic_structure);\n<213> COPY_PICTURE(&h->ref_list[list][index], &h->default_ref_list[list][0]);
<1> static void pc_init1(MachineState *machine)\n<125> if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n<129> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> qcrypto_block_luks_load_key(QCryptoBlock *block,\n<5> const char *password,\n<45> uint8_t keydigest[QCRYPTO_BLOCK_LUKS_DIGEST_LEN];\n<53> if (slot->active != QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED) {\n<85> (const uint8_t *)password, strlen(password),\n<277> if (memcmp(keydigest, luks->header.master_key_digest,\n<283> ret = 1;\n<295> ret = 0;
<1> static int mov_read_dref(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n<33> MOVDref *dref = &sc->drefs[i];\n<103> get_buffer(pb, dref->path, len);\n<105> if (len > volume_len && !strncmp(dref->path, volume, volume_len)) {\n<107> len -= volume_len;\n<109> memmove(dref->path, dref->path+volume_len, len);\n<111> dref->path[len] = 0;\n<115> for (j = 0; j < len; j++)\n<117> if (dref->path[j] == ':')\n<119> dref->path[j] = '/';\n<121> av_log(c->fc, AV_LOG_DEBUG, "path %s\n", dref->path);
<1> static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size){\n<43> if(avctx->get_buffer(avctx, p) < 0){\n<45> fprintf(stderr, "get_buffer() failed\n");\n<75> if(s->yuy2){\n<87> fprintf(stderr, "YUY2 output isnt implemenetd yet\n");\n<389> if(s->bgr32){\n<391> switch(s->predictor){\n<431> fprintf(stderr, "prediction type not supported!\n");\n<439> fprintf(stderr, "BGR24 output isnt implemenetd yet\n");
<1> static int blkverify_open(BlockDriverState *bs, const char *filename, int flags)\n<15> if (strncmp(filename, "blkverify:", strlen("blkverify:"))) {\n<17> return -EINVAL;\n<21> filename += strlen("blkverify:");\n<27> c = strchr(filename, ':');\n<29> if (c == NULL) {\n<37> raw = strdup(filename);\n<39> raw[c - filename] = '\0';\n<41> ret = bdrv_file_open(&bs->file, raw, flags);\n<43> free(raw);
<19> if ( intern -> u . dir . sub_path && intern -> u . dir . sub_path [ 0 ] ) {\n<23> subdir -> u . dir . sub_path_len = strlen ( intern -> u . dir . entry . d_name ) ;\n<24> subdir -> u . dir . sub_path = estrndup ( intern -> u . dir . entry . d_name , subdir -> u . dir . sub_path_len ) ;
<1> static int dca_subsubframe(DCAContext *s, int base_channel, int block_index)\n<91> if (!abits) {\n<95> memset(block + 8 * l, 0, 8 * sizeof(block[0]));\n<149> block[8 * l + m] = get_sbits(&s->gb, abits - 3);\n<173> s->fmt_conv.int32_to_float_fmul_array8(&s->fmt_conv, subband_samples[k][0],
<1> static void setup_rt_frame(int usig, struct emulated_sigaction *ka,\n<19> if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n<39> memset(&stack, 0, sizeof(stack));\n<47> memcpy(&frame->uc.tuc_stack, &stack, sizeof(stack));
<1> static int mpegts_push_data(MpegTSFilter *filter,\n<9> PESContext *pes = filter->u.pes_filter.opaque;\n<29> new_pes_packet(pes, ts->pkt);\n<37> pes->data_index = 0;\n<43> p = buf;\n<47> switch(pes->state) {\n<51> len = PES_START_SIZE - pes->data_index;\n<53> if (len > buf_size)\n<55> len = buf_size;\n<57> memcpy(pes->header + pes->data_index, p, len);\n<59> pes->data_index += len;\n<61> p += len;\n<63> buf_size -= len;\n<65> if (pes->data_index == PES_START_SIZE) {\n<77> if (pes->header[0] == 0x00 && pes->header[1] == 0x00 &&\n<79> pes->header[2] == 0x01) {\n<83> code = pes->header[3] | 0x100;\n<101> pes->st = new_pes_av_stream(pes, 0, code);\n<125> if (!pes->buffer)\n<147> pes->data_index = 0;\n<175> len = pes->pes_header_size - pes->data_index;\n<177> if (len < 0)\n<181> if (len > buf_size)\n<183> len = buf_size;\n<185> memcpy(pes->header + pes->data_index, p, len);\n<187> pes->data_index += len;\n<189> p += len;\n<191> buf_size -= len;\n<193> if (pes->data_index == pes->pes_header_size) {\n<233> pes->data_index = 0;\n<241> if (buf_size > 0) {\n<243> if (pes->data_index+buf_size > pes->total_size) {\n<245> new_pes_packet(pes, ts->pkt);\n<251> if (!pes->buffer)\n<259> memcpy(pes->buffer+pes->data_index, p, buf_size);\n<261> pes->data_index += buf_size;
<1> static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt)\n<5> const uint8_t *buf = avpkt->data;\n<9> ZmbvContext * const c = avctx->priv_data;\n<43> buf++; len--;\n<65> buf += 6;\n<67> len -= 6;\n<209> if (c->comp == 0) { //Uncompressed data\n<211> memcpy(c->decomp_buf, buf, len);\n<247> c->decode_intra(c);\n<257> c->decode_xor(c);
<1> long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3,\n<23> switch(num) {\n<1539> p2 = lock_user(arg2, arg3, 0);\n<1541> ret = get_errno(readlink(path(p), p2, arg3));\n<1543> unlock_user(p2, arg2, ret);
<1> int avpriv_adx_decode_header(AVCodecContext *avctx, const uint8_t *buf,\n<17> if (AV_RB16(buf) != 0x8000)\n<27> if (bufsize >= offset && memcmp(buf + offset - 6, "(c)CRI", 6))\n<29> return AVERROR_INVALIDDATA;\n<35> if (buf[4] != 3 || buf[5] != 18 || buf[6] != 4) {
<1> void ff_er_frame_start(ERContext *s)\n<5> if (!s->avctx->err_recognition)\n<11> memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,\n<13> s->mb_stride * s->mb_height * sizeof(uint8_t));
<1> static int qemu_rdma_post_send_control(RDMAContext *rdma, uint8_t *buf,\n<3> RDMAControlHeader *head)\n<9> RDMAWorkRequestData *wr = &rdma->wr_data[RDMA_WRID_CONTROL];\n<15> .addr = (uint64_t)(wr->control),\n<59> assert(head->len <= RDMA_CONTROL_MAX_BUFFER - sizeof(*head));\n<61> memcpy(wr->control, head, sizeof(RDMAControlHeader));\n<63> control_to_network((void *) wr->control);\n<67> if (buf) {\n<69> memcpy(wr->control + sizeof(RDMAControlHeader), buf, head->len);\n<85> if (ret < 0) {\n<87> fprintf(stderr, "Failed to use post IB SEND for control!\n");\n<97> if (ret < 0) {\n<99> fprintf(stderr, "rdma migration: send polling control error!\n");
<1> static sd_rsp_type_t sd_app_command(SDState *sd,\n<3> SDRequest req)\n<7> DPRINTF("ACMD%d 0x%08x\n", req.cmd, req.arg);\n<15> switch (sd->state) {\n<39> switch (sd->state) {\n<65> switch (sd->state) {\n<95> switch (sd->state) {\n<125> switch (sd->state) {\n<163> switch (sd->state) {\n<185> switch (sd->state) {\n<219> fprintf(stderr, "SD: ACMD%i in a wrong state\n", req.cmd);
<1> static int bink_decode_plane(BinkContext *c, AVFrame *frame, GetBitContext *gb,\n<107> dst  = frame->data[plane_idx]  + 8*by*stride;\n<113> for (bx = 0; bx < bw; bx++, dst += 8, prev += 8) {\n<131> switch (blk) {\n<143> switch (blk) {\n<193> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<195> dctblock[0] = get_value(c, BINK_SRC_INTRA_DC);\n<197> read_dct_coeffs(gb, dctblock, bink_scan, bink_intra_quant, -1);\n<199> c->binkdsp.idct_put(ublock, 8, dctblock);\n<309> dst[coordmap[*scan++]] = v;\n<315> dst[coordmap[*scan++]] = get_value(c, BINK_SRC_COLORS);\n<323> dst[coordmap[*scan++]] = get_value(c, BINK_SRC_COLORS);\n<359> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<361> dctblock[0] = get_value(c, BINK_SRC_INTRA_DC);\n<363> read_dct_coeffs(gb, dctblock, bink_scan, bink_intra_quant, -1);\n<365> c->binkdsp.idct_put(dst, stride, dctblock);\n<387> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<389> dctblock[0] = get_value(c, BINK_SRC_INTER_DC);\n<391> read_dct_coeffs(gb, dctblock, bink_scan, bink_inter_quant, -1);\n<393> c->binkdsp.idct_add(dst, stride, dctblock);\n<409> dst[i*stride + j] = col[v & 1];\n<417> for (i = 0; i < 8; i++)\n<419> memcpy(dst + i*stride, c->bundle[BINK_SRC_COLORS].cur_ptr + i*8, 8);
<1> static void arm_sysctl_write(void *opaque, target_phys_addr_t offset,\n<11> switch (offset) {\n<241> if (board_id(s) != BOARD_ID_VEXPRESS) {\n<253> if (board_id(s) != BOARD_ID_VEXPRESS) {\n<287> if (board_id(s) != BOARD_ID_VEXPRESS) {\n<301> printf ("arm_sysctl_write: Bad register offset 0x%x\n", (int)offset);
<1> static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,\n<7> const char *vendor = bitexact ? "ffmpeg" : LIBAVFORMAT_IDENT;\n<11> if (extradata_size != 34)\n<37> bytestream_put_buffer(&p, extradata, 34);\n<39> oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;\n<41> oggstream->header[1] = av_mallocz(oggstream->header_len[1]);\n<43> p = oggstream->header[1];\n<45> bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment\n<47> bytestream_put_be24(&p, oggstream->header_len[1] - 4);\n<49> bytestream_put_le32(&p, strlen(vendor));\n<51> bytestream_put_buffer(&p, vendor, strlen(vendor));\n<53> bytestream_put_le32(&p, 0); // user comment list length
<1> static void process_packet_data ( struct wtap_pkthdr * phdr , Buffer * target , guint8 * buffer , gint len , k12_t * k12 ) {\n<17> buffer_offset = ( type == K12_REC_D0020 ) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME ;\n<18> ws_buffer_assure_space ( target , length ) ;\n<19> memcpy ( ws_buffer_start_ptr ( target ) , buffer + buffer_offset , length ) ;\n<20> extra_len = len - buffer_offset - length ;\n<21> ws_buffer_assure_space ( & ( k12 -> extra_info ) , extra_len ) ;\n<22> memcpy ( ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) , buffer + buffer_offset + length , extra_len ) ;\n<23> phdr -> pseudo_header . k12 . extra_info = ( guint8 * ) ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) ;\n<24> phdr -> pseudo_header . k12 . extra_length = extra_len ;\n<27> phdr -> pseudo_header . k12 . input = src_id ;\n<28> if ( ! ( src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id ) ) ) ) {\n<29> src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id & K12_RECORD_SRC_ID_MASK ) ) ;\n<31> if ( src_desc ) {\n<36> switch ( src_desc -> input_type ) {\n<37> case K12_PORT_ATMPVC : if ( ( long ) ( buffer_offset + length + K12_PACKET_OFFSET_CID ) < len ) {\n<43> default : memcpy ( & ( phdr -> pseudo_header . k12 . input_info ) , & ( src_desc -> input_info ) , sizeof ( src_desc -> input_info ) ) ;\n<49> memset ( & ( phdr -> pseudo_header . k12 ) , 0 , sizeof ( phdr -> pseudo_header . k12 ) ) ;
<1> int main_loop(void *opaque)\n<141> n = read(net_fd, buf, MAX_ETH_FRAME_SIZE);\n<145> if (n < 60) {\n<147> memset(buf + n, 0, 60 - n);
<1> static int authenticate_nss_2_3 ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n<4> int datalen = * buf_len - hash_len [ instance -> crypto_hash_type ] ;\n<5> if ( calculate_nss_hash ( instance , buf , datalen , tmp_hash ) < 0 ) {\n<8> if ( memcmp ( tmp_hash , buf + datalen , hash_len [ instance -> crypto_hash_type ] ) != 0 ) {\n<9> log_printf ( instance -> log_level_error , "Digest does not match" ) ;\n<10> return - 1 ;\n<12> * buf_len = datalen ;\n<14> return 0 ;
<1> static void qxl_log_image(PCIQXLDevice *qxl, QXLPHYSICAL addr, int group_id)\n<39> fprintf(stderr, ")");
<1> static int net_init_nic(QemuOpts *opts,\n<21> if (idx == -1 || nb_nics >= MAX_NICS) {\n<31> nd = &nd_table[idx];\n<35> memset(nd, 0, sizeof(*nd));\n<43> if (!nd->netdev) {\n<95> net_parse_macaddr(nd->macaddr, qemu_opt_get(opts, "macaddr")) < 0) {\n<107> if (nd->nvectors != NIC_NVECTORS_UNSPECIFIED &&\n<109> (nd->nvectors < 0 || nd->nvectors > 0x7ffffff)) {\n<111> qemu_error("invalid # of vectors: %d\n", nd->nvectors);
<1> void os_daemonize(void)\n<51> else if (status == 1) {\n<53> fprintf(stderr, "Could not acquire pidfile\n");
<1> static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)\n<33> if (v > 0 && v < 0xC0) {\n<37> int length = FFMIN(v, width - x);\n<39> memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);\n<43> v   -= length;\n<45> } while (v > 0);
<1> static gint64 ascend_seek ( wtap * wth , int * err , gchar * * err_info ) {\n<4> size_t string_level [ ASCEND_MAGIC_STRINGS ] ;\n<7> memset ( & string_level , 0 , sizeof ( string_level ) ) ;\n<15> string_i < ASCEND_MAGIC_STRINGS ;\n<16> string_i ++ ) {\n<17> const gchar * strptr = ascend_magic [ string_i ] . strptr ;\n<18> size_t len = strlen ( strptr ) ;\n<19> if ( byte == * ( strptr + string_level [ string_i ] ) ) {\n<21> if ( string_level [ string_i ] >= len ) {\n<23> if ( cur_off == - 1 ) {\n<27> if ( strcmp ( strptr , ASCEND_DATE ) == 0 ) {\n<28> date_off = cur_off - len ;\n<31> if ( date_off == - 1 ) {\n<37> type = ascend_magic [ string_i ] . type ;\n<49> found : if ( file_seek ( wth -> fh , packet_off , SEEK_SET , err ) == - 1 ) return - 1 ;
<16> static void feature_destroy ( hb_feature_t * g ) {\n<17> free ( g ) ;\n<19> HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy ) static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n<20> hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n<21> if ( unlikely ( ! c ) ) return NULL ;
<1> __attribute__ ( ( format ( printf , 2 , 3 ) ) ) static int cmd_submitf ( int id , const char * fmt , ... ) {\n<2> char cmd [ MAX_EXTERNAL_COMMAND_LENGTH ] ;\n<10> if ( fmt ) {\n<11> va_start ( ap , fmt ) ;\n<12> len2 = vsnprintf ( & cmd [ len ] , sizeof ( cmd ) - len - 1 , fmt , ap ) ;\n<13> va_end ( ap ) ;\n<14> if ( len2 < 0 ) return ERROR ;
<1> static void bt_dummy_lmp_disconnect_master(struct bt_link_s *link)\n<5> fprintf(stderr, "%s: stray LMP_detach received, fixme\n", __func__);
<1> build_header(BIOSLinker *linker, GArray *table_data,\n<3> AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n<5> const char *oem_id, const char *oem_table_id)\n<9> memcpy(&h->signature, sig, 4);\n<17> if (oem_id) {\n<19> strncpy((char *)h->oem_id, oem_id, sizeof h->oem_id);\n<23> memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n<29> if (oem_table_id) {\n<31> strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n<35> memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n<37> memcpy(h->oem_table_id + 4, sig, 4);\n<45> memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n<53> bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
<1> static void fill_picture_parameters ( struct dxva_context * ctx , const H264Context * h , DXVA_PicParams_H264 * pp ) {\n<4> memset ( pp , 0 , sizeof ( * pp ) ) ;\n<5> fill_picture_entry ( & pp -> CurrPic , ff_dxva2_get_surface_index ( ctx , current_picture ) , h -> picture_structure == PICT_BOTTOM_FIELD ) ;\n<9> i < FF_ARRAY_ELEMS ( pp -> RefFrameList ) ;\n<24> if ( r -> f . reference & PICT_TOP_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 0 ) ;\n<25> if ( r -> f . reference & PICT_BOTTOM_FIELD ) pp -> UsedForReferenceFlags |= 1 << ( 2 * i + 1 ) ;
<1> static int scsi_generic_initfn(SCSIDevice *dev)\n<5> SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, dev);\n<53> if (bdrv_ioctl(s->bs, SG_GET_SCSI_ID, &scsiid)) {\n<105> memset(s->sensebuf, 0, sizeof(s->sensebuf));
<1> static void print_sdp(void)\n<23> av_sdp_create(avc, nb_output_files, sdp, sizeof(sdp));\n<25> printf("SDP:\n%s\n", sdp);
<1> static int a52_decode_frame(AVCodecContext *avctx,\n<9> AC3DecodeState *s = avctx->priv_data;\n<33> buf_ptr = buf;\n<37> len = s->inbuf_ptr - s->inbuf;\n<39> if (s->frame_size == 0) {\n<45> if (len > buf_size)\n<47> len = buf_size;\n<49> memcpy(s->inbuf_ptr, buf_ptr, len);\n<51> buf_ptr += len;\n<53> s->inbuf_ptr += len;\n<55> buf_size -= len;\n<59> len = s->a52_syncinfo(s->inbuf, &s->flags, &sample_rate, &bit_rate);\n<61> if (len == 0) {\n<65> memcpy(s->inbuf, s->inbuf + 1, HEADER_SIZE - 1);\n<101> } else if (len < s->frame_size) {\n<105> if (len > buf_size)\n<107> len = buf_size;\n<111> memcpy(s->inbuf_ptr, buf_ptr, len);\n<113> buf_ptr += len;\n<115> s->inbuf_ptr += len;\n<117> buf_size -= len;
<1> build_header(GArray *linker, GArray *table_data,\n<3> AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n<5> const char *oem_id, const char *oem_table_id)\n<9> memcpy(&h->signature, sig, 4);\n<17> if (oem_id) {\n<19> strncpy((char *)h->oem_id, oem_id, sizeof h->oem_id);\n<23> memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n<29> if (oem_table_id) {\n<31> strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n<35> memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n<37> memcpy(h->oem_table_id + 4, sig, 4);\n<45> memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n<53> bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
<1> static int vmd_decode(VmdVideoContext *s, AVFrame *frame)\n<113> s->avctx->height * frame->linesize[0]);\n<181> dp = &frame->data[0][frame_y * frame->linesize[0] + frame_x];\n<183> pp = &s->prev_frame.data[0][frame_y * s->prev_frame.linesize[0] + frame_x];\n<197> if (len & 0x80) {\n<205> bytestream2_get_buffer(&gb, &dp[ofs], len);\n<213> if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])\n<217> memcpy(&dp[ofs], &pp[ofs], len + 1);\n<235> dp += frame->linesize[0];\n<237> pp += s->prev_frame.linesize[0];\n<271> if (len & 0x80) {\n<285> bytestream2_get_buffer(&gb, &dp[ofs], len);\n<293> if (ofs + len + 1 > frame_width || !s->prev_frame.data[0])\n<297> memcpy(&dp[ofs], &pp[ofs], len + 1);\n<315> dp += frame->linesize[0];\n<317> pp += s->prev_frame.linesize[0];
<1> int dissect_ber_GeneralizedTime ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id ) {\n<6> char first_delim [ 2 ] ;\n<8> char second_delim [ 2 ] ;\n<38> if ( ( len < 14 ) || ( len > 23 ) ) {\n<49> strptr += g_snprintf ( str , 20 , "%.4s-%.2s-%.2s %.2s:%.2s:%.2s" , tmpstr , tmpstr + 4 , tmpstr + 6 , tmpstr + 8 , tmpstr + 10 , tmpstr + 12 ) ;\n<50> first_delim [ 0 ] = 0 ;\n<51> second_delim [ 0 ] = 0 ;\n<52> ret = sscanf ( tmpstr , "%14d%1[.,+-Z]%4d%1[+-Z]%4d" , & tmp_int , first_delim , & first_digits , second_delim , & second_digits ) ;\n<53> if ( ret < 1 ) {\n<54> cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , "invalid_generalized_time" , "GeneralizedTime invalid format: %s" , tmpstr ) ;\n<63> case '.' : case ',' : strptr += g_snprintf ( strptr , 5 , "%c%.3d" , first_delim [ 0 ] , first_digits ) ;\n<65> case '+' : case '-' : g_snprintf ( strptr , 12 , " (UTC%c%.4d)" , second_delim [ 0 ] , second_digits ) ;\n<73> case '+' : case '-' : g_snprintf ( strptr , 12 , " (UTC%c%.4d)" , first_delim [ 0 ] , first_digits ) ;
<1> static int sclp_parse(const char *devname)\n<15> if (strcmp(devname, "none") == 0) {\n<17> return 0;\n<21> if (index == MAX_SCLP_CONSOLES) {\n<23> fprintf(stderr, "qemu: too many sclp consoles\n");\n<31> assert(arch_type == QEMU_ARCH_S390X);\n<35> dev_opts = qemu_opts_create(device, NULL, 0, NULL);\n<37> qemu_opt_set(dev_opts, "driver", "sclpconsole", &error_abort);\n<41> snprintf(label, sizeof(label), "sclpcon%d", index);\n<43> sclp_hds[index] = qemu_chr_new(label, devname, NULL);\n<45> if (!sclp_hds[index]) {\n<47> fprintf(stderr, "qemu: could not connect sclp console"
<1> void qxl_log_command(PCIQXLDevice *qxl, const char *ring, QXLCommandExt *ext)\n<11> if (!qxl->cmdlog) {\n<61> fprintf(stderr, "\n");
<1> static int blk_connect(struct XenDevice *xendev)\n<25> if (strcmp(blkdev->mode, "w") == 0) {\n<27> qflags |= BDRV_O_RDWR;\n<29> readonly = false;\n<109> bdrv_attach_dev_nofail(blkdev->bs, blkdev);\n<113> if (blkdev->file_size < 0) {\n<115> xen_be_printf(&blkdev->xendev, 1, "bdrv_getlength: %d (%s) | drv %s\n",\n<117> (int)blkdev->file_size, strerror(-blkdev->file_size),\n<175> if (blkdev->xendev.protocol) {\n<177> if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_32) == 0) {\n<179> blkdev->protocol = BLKIF_PROTOCOL_X86_32;\n<183> if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_64) == 0) {\n<185> blkdev->protocol = BLKIF_PROTOCOL_X86_64;\n<275> xen_be_bind_evtchn(&blkdev->xendev);\n<279> xen_be_printf(&blkdev->xendev, 1, "ok: proto %s, ring-ref %d, "
<1> static void do_acpitable_option(const char *optarg)\n<5> if (acpi_table_add(optarg) < 0) {\n<7> fprintf(stderr, "Wrong acpi table provided\n");
<1> static uint32_t vmsvga_value_read(void *opaque, uint32_t address)\n<7> struct vmsvga_state_s *s = opaque;\n<235> if (s->index >= SVGA_SCRATCH_BASE &&\n<237> s->index < SVGA_SCRATCH_BASE + s->scratch_size)\n<241> printf("%s: Bad register %02x\n", __FUNCTION__, s->index);
<1> static void decode(RA288Context *ractx, float gain, int cb_coef)\n<13> memmove(ractx->sp_block + 5, ractx->sp_block, 36*sizeof(*ractx->sp_block));\n<19> ractx->sp_block[i] = -scalar_product_float(ractx->sp_block + i + 1,\n<59> memmove(ractx->gain_block, ractx->gain_block - 1,\n<61> 10 * sizeof(*ractx->gain_block));
<1> static int htab_save_setup(QEMUFile *f, void *opaque)\n<31> if (spapr->htab_fd < 0) {\n<33> fprintf(stderr, "Unable to open fd for reading hash table from KVM: %s\n",\n<35> strerror(errno));
<1> void call_pal (CPUState *env, int palcode)\n<9> if (logfile != NULL)\n<11> fprintf(logfile, "%s: palcode %02x\n", __func__, palcode);\n<71> if (logfile != NULL)\n<73> fprintf(logfile, "%s: unhandled palcode %02x\n",
<1> static int usb_host_update_interfaces(USBHostDevice *dev, int configuration)\n<67> if (i >= dev->descr_len) {\n<69> printf("usb_host: error - device has no matching configuration\n");\n<119> if (errno == EBUSY) {
<1> static void test_dealloc_partial(void)\n<27> qdict_put_obj(ud2_dict, "string0", QOBJECT(qstring_from_str(text)));\n<45> assert(ud2 != NULL);\n<47> assert(ud2->string0 != NULL);\n<49> assert(strcmp(ud2->string0, text) == 0);\n<63> qapi_free_UserDefTwo(ud2);
<1> static int nvenc_get_frame(AVCodecContext *avctx, AVPacket *pkt)\n<9> NV_ENC_LOCK_BITSTREAM params    = { 0 };\n<25> params.version         = NV_ENC_LOCK_BITSTREAM_VER;\n<27> params.outputBitstream = out->out;\n<39> ret = ff_alloc_packet(pkt, params.bitstreamSizeInBytes);\n<41> if (ret < 0)\n<47> memcpy(pkt->data, params.bitstreamBufferPtr, pkt->size);\n<63> ret = nvenc_set_timestamp(ctx, &params, pkt);
<1> void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n<21> char *base_core_type = spapr_get_cpu_core_type(machine->cpu_model);\n<23> const char *type = object_get_typename(OBJECT(dev));\n<27> if (!smc->dr_cpu_enabled) {\n<37> if (strcmp(base_core_type, type)) {\n<39> error_setg(&local_err, "CPU core type should be %s", base_core_type);\n<47> if (cc->nr_threads != smp_threads) {\n<91> g_free(base_core_type);
<1> static void bt_vhci_add(int vlan_id)\n<5> struct bt_scatternet_s *vlan = qemu_find_bt_vlan(vlan_id);\n<9> if (!vlan->slave)\n<11> fprintf(stderr, "qemu: warning: adding a VHCI to "
<1> static int http_proxy_open(URLContext *h, const char *uri, int flags)\n<5> HTTPContext *s = h->priv_data;\n<47> ret = ffurl_open(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,\n<51> if (ret < 0)\n<83> if ((ret = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)\n<89> s->buf_ptr = s->buffer;\n<91> s->buf_end = s->buffer;\n<93> s->line_count = 0;\n<95> s->filesize = -1;\n<97> cur_auth_type = s->proxy_auth_state.auth_type;\n<119> ret = http_read_header(h, &new_loc);\n<121> if (ret < 0)\n<135> ffurl_closep(&s->hd);\n<153> http_proxy_close(h);\n<155> return ret;
<1> static int64_t load_kernel (void)\n<33> if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n<39> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<57> initrd_size = get_image_size (loaderparams.initrd_filename);\n<63> if (initrd_offset + initrd_size > ram_size) {\n<75> initrd_size = load_image_targphys(loaderparams.initrd_filename,\n<83> if (initrd_size == (target_ulong) -1) {\n<85> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<105> prom_set(prom_buf, prom_index++, "%s", loaderparams.kernel_filename);
<1> static int mov_write_single_packet(AVFormatContext *s, AVPacket *pkt)\n<9> AVCodecParameters *par = trk->par;\n<61> int side_size = 0;\n<63> uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n<65> if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n<67> void *newextra = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n<69> if (!newextra)\n<73> av_free(par->extradata);\n<75> par->extradata = newextra;\n<77> memcpy(par->extradata, side, side_size);\n<79> par->extradata_size = side_size;
<1> static void * size_checked_realloc ( void * ptr , size_t size ) {\n<2> if ( size > MAX_LIBXML_MALLOC ) {\n<6> return realloc ( ptr , size ) ;
<1> static void load_word(DBDMA_channel *ch, int key, uint32_t addr,\n<21> if (key != KEY_SYSTEM) {\n<23> printf("DBDMA: LOAD_WORD, unimplemented key %x\n", key);
<1> void qtest_init(const char *qtest_chrdev, const char *qtest_log, Error **errp)\n<35> if (qtest_log) {\n<37> if (strcmp(qtest_log, "none") != 0) {\n<39> qtest_log_fp = fopen(qtest_log, "w+");
<1> static int hdev_create(const char *filename, QEMUOptionParameter *options)\n<17> while (options && options->name) {\n<19> if (!strcmp(options->name, "size")) {\n<21> total_size = options->value.n / 512;\n<25> options++;
<1> static uint64_t icp_pic_read(void *opaque, target_phys_addr_t offset,\n<11> switch (offset >> 2) {\n<49> printf ("icp_pic_read: Bad register offset 0x%x\n", (int)offset);
<1> int ff_dca_lbr_parse(DCALbrDecoder *s, uint8_t *data, DCAExssAsset *asset)\n<67> if ((ret = parse_decoder_init(s, &gb)) < 0) {\n<113> switch (chunk_id & 0x7f) {\n<117> if (s->avctx->err_recognition & (AV_EF_CRCCHECK | AV_EF_CAREFUL)) {\n<131> if (checksum != res) {\n<135> if (s->avctx->err_recognition & AV_EF_EXPLODE)\n<165> memset(s->quant_levels, 0, sizeof(s->quant_levels));\n<167> memset(s->sb_indices, 0xff, sizeof(s->sb_indices));\n<169> memset(s->sec_ch_sbms, 0, sizeof(s->sec_ch_sbms));\n<171> memset(s->sec_ch_lrms, 0, sizeof(s->sec_ch_lrms));\n<173> memset(s->ch_pres, 0, sizeof(s->ch_pres));\n<175> memset(s->grid_1_scf, 0, sizeof(s->grid_1_scf));\n<177> memset(s->grid_2_scf, 0, sizeof(s->grid_2_scf));\n<179> memset(s->grid_3_avg, 0, sizeof(s->grid_3_avg));\n<181> memset(s->grid_3_scf, 0, sizeof(s->grid_3_scf));\n<183> memset(s->grid_3_pres, 0, sizeof(s->grid_3_pres));\n<185> memset(s->tonal_scf, 0, sizeof(s->tonal_scf));\n<187> memset(s->lfe_data, 0, sizeof(s->lfe_data));\n<209> memset(s->lpc_coeff[s->framenum & 1], 0, sizeof(s->lpc_coeff[0]));\n<401> ret = parse_lfe_chunk(s, &chunk.lfe);\n<405> ret |= parse_tonal_chunk(s, &chunk.tonal);\n<411> ret |= parse_tonal_group(s, &chunk.tonal_grp[i]);\n<423> if (parse_grid_1_chunk (s, &chunk.grid1  [i], ch1, ch2) < 0 ||\n<425> parse_high_res_grid(s, &chunk.hr_grid[i], ch1, ch2) < 0) {\n<443> if (parse_ts1_chunk(s, &chunk.ts1[i], ch1, ch2) < 0 ||\n<445> parse_ts2_chunk(s, &chunk.ts2[i], ch1, ch2) < 0) {
<1> static int tiff_decode_tag(TiffContext *s, const uint8_t *start,\n<31> off = tget_long(&buf, s->le);\n<57> value = tget(&buf, type, s->le);\n<105> if (buf && (buf < start || buf > end_buf)) {\n<629> char *ap = av_malloc(s->geotags[i].count);\n<631> if (!ap) {\n<639> memcpy(ap, &buf[s->geotags[i].offset], s->geotags[i].count);\n<641> ap[s->geotags[i].count - 1] = '\0'; //replace the "|" delimiter with a 0 byte\n<643> s->geotags[i].val = ap;
<1> static int load_multiboot(void *fw_cfg,\n<5> const char *kernel_filename,\n<7> const char *initrd_filename,\n<9> const char *kernel_cmdline,\n<65> if (!is_multiboot)\n<79> if (flags & 0x00000004) { /* MULTIBOOT_HEADER_HAS_VBE */\n<81> fprintf(stderr, "qemu: multiboot knows VBE. we don't.\n");\n<93> kernel_size = load_elf(kernel_filename, 0, &elf_entry, NULL, NULL,\n<97> if (kernel_size < 0) {\n<99> fprintf(stderr, "Error while loading elf kernel\n");\n<185> if (!fread_targphys_ok(mh_load_addr, mb_kernel_size, f)) {\n<187> fprintf(stderr, "qemu: read error on multiboot kernel '%s' (%#x)\n",\n<203> mb_mod_end = mh_load_addr + mb_kernel_size;\n<211> if (initrd_filename) {\n<219> uint32_t mb_mod_length = mb_kernel_size;\n<231> next_initrd = strchr(initrd_filename, ',');\n<241> cpu_physical_memory_write(mb_mod_cmdline, (uint8_t*)initrd_filename,\n<243> strlen(initrd_filename) + 1);\n<245> stl_phys(mb_mod_info + 8, mb_mod_cmdline); /* string */\n<247> mb_mod_cmdline += strlen(initrd_filename) + 1;\n<249> if ((next_space = strchr(initrd_filename, ' ')))\n<251> *next_space = '\0';\n<259> f = fopen(initrd_filename, "rb");\n<263> mb_mod_start = (mb_mod_start + mb_mod_length + (TARGET_PAGE_SIZE - 1))\n<273> if (!fread_targphys_ok(mb_mod_start, mb_mod_length, f)) {\n<275> fprintf(stderr, "qemu: read error on multiboot module '%s' (%#x)\n",\n<289> stl_phys(mb_mod_info + 4, mb_mod_start + mb_mod_length);\n<303> initrd_filename = next_initrd+1;\n<327> t = strlen(kernel_filename);\n<329> cpu_physical_memory_write(mb_cmdline, (uint8_t*)kernel_filename, t);\n<335> t = strlen(kernel_cmdline) + 1;\n<337> cpu_physical_memory_write(mb_cmdline, (uint8_t*)kernel_cmdline, t);
<1> static void audio_encode_example(const char *filename)\n<25> printf("Encode audio file %s\n", filename);\n<33> if (!codec) {\n<35> fprintf(stderr, "Codec not found\n");\n<45> if (!c) {\n<47> fprintf(stderr, "Could not allocate audio codec context\n");\n<65> if (!check_sample_fmt(codec, c->sample_fmt)) {\n<67> fprintf(stderr, "Encoder does not support sample format %s",\n<69> av_get_sample_fmt_name(c->sample_fmt));\n<89> if (avcodec_open2(c, codec, NULL) < 0) {\n<91> fprintf(stderr, "Could not open codec\n");\n<99> f = fopen(filename, "wb");\n<101> if (!f) {\n<103> fprintf(stderr, "Could not open %s\n", filename);\n<115> if (!frame) {\n<117> fprintf(stderr, "Could not allocate audio frame\n");\n<141> if (!buffer_size) {\n<143> fprintf(stderr, "Could not get sample buffer size\n");\n<149> samples = av_malloc(buffer_size);\n<151> if (!samples) {\n<153> fprintf(stderr, "Could not allocate %d bytes for samples buffer\n",\n<163> ret = avcodec_fill_audio_frame(frame, c->channels, c->sample_fmt,\n<167> if (ret < 0) {\n<169> fprintf(stderr, "Could not setup audio frame\n");\n<211> if (ret < 0) {\n<213> fprintf(stderr, "Error encoding audio frame\n");\n<237> if (ret < 0) {\n<239> fprintf(stderr, "Error encoding frame\n");
<1> static void write_video_frame(AVFormatContext *oc, AVStream *st)\n<37> if (!sws_ctx) {\n<105> if (ret < 0) {\n<107> fprintf(stderr, "Error encoding video frame: %s\n", av_err2str(ret));\n<129> if (ret != 0) {\n<131> fprintf(stderr, "Error while writing video frame: %s\n", av_err2str(ret));
<1> static inline void dv_decode_video_segment(DVVideoContext *s,\n<37> memset(sblock, 0, sizeof(sblock));
<1> static unsigned long copy_strings(int argc,char ** argv,unsigned long *page,\n<21> if (!(tmp1 = tmp = get_user(argv+argc))) {\n<23> fprintf(stderr, "VFS: argc is wrong");
<1> static ssize_t virtio_net_receive(VLANClientState *nc, const uint8_t *buf, size_t size)\n<45> while (offset < size) {\n<51> struct iovec sg[VIRTQUEUE_MAX_SIZE];\n<63> if (i == 0)\n<67> fprintf(stderr, "virtio-net truncating packet: "\n<79> if (elem.in_num < 1) {\n<81> fprintf(stderr, "virtio-net receive queue contains no in buffers\n");\n<89> if (!n->mergeable_rx_bufs && elem.in_sg[0].iov_len != hdr_len) {\n<91> fprintf(stderr, "virtio-net header not in first element\n");\n<99> memcpy(&sg, &elem.in_sg[0], sizeof(sg[0]) * elem.in_num);\n<113> buf + offset, size - offset, hdr_len);\n<125> buf + offset, size - offset);
<1> static int idcin_decode_frame(AVCodecContext *avctx,\n<15> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<35> if (idcin_decode_vlcs(s, frame))\n<41> if (pal) {\n<45> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<51> memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);
<1> static int remoteStreamHandleFinish ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n<5> memset ( & rerr , 0 , sizeof rerr ) ;\n<10> remoteDispatchConnError ( & rerr , client -> conn ) ;\n<11> return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
<1> static void iscsi_close(BlockDriverState *bs)\n<5> IscsiLun *iscsilun = bs->opaque;\n<21> g_free(iscsilun->zeroblock);\n<23> g_free(iscsilun->allocationmap);\n<25> memset(iscsilun, 0, sizeof(IscsiLun));
<1> dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,\n<15> const char *device_name = ctx->device_name[devtype];\n<87> if (r != S_OK)\n<91> unique_name = dup_wchar_to_utf8(olestr);\n<95> for (i = 0; i < strlen(unique_name); i++) {\n<97> if (unique_name[i] == ':')\n<99> unique_name[i] = '_';\n<121> friendly_name = dup_wchar_to_utf8(var.bstrVal);\n<125> if (pfilter) {\n<127> if (strcmp(device_name, friendly_name) && strcmp(device_name, unique_name))\n<133> if (!skip--) {\n<139> av_log(avctx, AV_LOG_ERROR, "Unable to BindToObject for %s\n", device_name);\n<151> av_log(avctx, AV_LOG_INFO, "    Alternative name \"%s\"\n", unique_name);\n<167> av_free(friendly_name);\n<169> av_free(unique_name);\n<189> av_log(avctx, AV_LOG_ERROR, "Could not find %s device with name [%s] among source devices of type %s.\n",
<1> int av_image_fill_linesizes(int linesizes[4], enum PixelFormat pix_fmt, int width)\n<15> memset(linesizes, 0, 4*sizeof(linesizes[0]));
<1> static int g722_decode_frame(AVCodecContext *avctx, void *data,\n<7> G722Context *c = avctx->priv_data;\n<63> c->prev_samples[c->prev_samples_pos++] = rlow - rhigh;\n<65> ff_g722_apply_qmf(c->prev_samples + c->prev_samples_pos - 24,\n<73> if (c->prev_samples_pos >= PREV_SAMPLES_BUF_SIZE) {\n<75> memmove(c->prev_samples, c->prev_samples + c->prev_samples_pos - 22,\n<77> 22 * sizeof(c->prev_samples[0]));
<1> static VirtIOSerialPort *find_port_by_name(char *name)\n<15> QTAILQ_FOREACH(port, &vser->ports, next) {\n<17> if (!strcmp(port->name, name)) {\n<19> return port;\n<27> return NULL;
<1> static int qemu_rdma_registration_stop(QEMUFile *f, void *opaque,\n<39> RDMAControlHeader resp = {.type = RDMA_CONTROL_RAM_BLOCKS_RESULT };\n<69> ret = qemu_rdma_exchange_send(rdma, &head, NULL, &resp,\n<75> if (ret < 0) {\n<85> qemu_rdma_move_header(rdma, reg_result_idx, &resp);\n<93> nb_remote_blocks = resp.len / sizeof(RDMARemoteBlock);\n<137> network_to_remote_block(&rdma->block[i]);\n<201> ret = qemu_rdma_exchange_send(rdma, &head, NULL, NULL, NULL, NULL);
<1> void ff_rtp_send_aac(AVFormatContext *s1, const uint8_t *buff, int size)\n<5> RTPMuxContext *s = s1->priv_data;\n<19> buff += 7;\n<29> len = (s->buf_ptr - s->buf);\n<37> p = s->buf + MAX_AU_HEADERS_SIZE - au_size - 2;\n<39> if (p != s->buf) {\n<41> memmove(p + 2, s->buf + 2, au_size);\n<47> p[0] = ((au_size * 8) & 0xFF) >> 8;\n<53> ff_rtp_send_data(s1, p, s->buf_ptr - p, 1);\n<63> s->buf_ptr = s->buf + MAX_AU_HEADERS_SIZE;\n<71> if (size <= max_packet_size) {\n<77> *p = (size & 0x1F) << 3;\n<79> memcpy(s->buf_ptr, buff, size);\n<81> s->buf_ptr += size;\n<95> p = s->buf;\n<97> p[0] = 0;\n<99> p[1] = 16;\n<101> while (size > 0) {\n<105> p[2] = len >> 5;\n<107> p[3] = (size & 0x1F) << 3;\n<109> memcpy(p + 4, buff, len);\n<111> ff_rtp_send_data(s1, p, len + 4, len == size);\n<115> buff += len;
<1> int qemu_v9fs_synth_add_file(V9fsSynthNode *parent, int mode,\n<15> if (!v9fs_synth_fs) {\n<21> if (!name || (strlen(name) >= NAME_MAX)) {\n<23> return EINVAL;\n<27> if (!parent) {\n<35> qemu_mutex_lock(&v9fs_synth_mutex);\n<37> QLIST_FOREACH(tmp, &parent->child, sibling) {\n<39> if (!strcmp(tmp->name, name)) {\n<41> ret = EEXIST;\n<51> mode = ((mode & 0777) | S_IFREG);\n<53> node = g_malloc0(sizeof(V9fsSynthNode));\n<55> node->attr         = &node->actual_attr;\n<57> node->attr->inode  = v9fs_synth_node_count++;\n<59> node->attr->nlink  = 1;\n<61> node->attr->read   = read;\n<63> node->attr->write  = write;\n<65> node->attr->mode   = mode;\n<67> node->private      = arg;\n<69> pstrcpy(node->name, sizeof(node->name), name);\n<71> QLIST_INSERT_HEAD_RCU(&parent->child, node, sibling);\n<73> ret = 0;\n<77> qemu_mutex_unlock(&v9fs_synth_mutex);\n<79> return ret;
<1> static int parse_uri(const char *filename, QDict *options, Error **errp)\n<15> if (!uri) {\n<23> if (strcmp(uri->scheme, "ssh") != 0) {\n<25> error_setg(errp, "URI scheme must be 'ssh'");\n<33> if (!uri->server || strcmp(uri->server, "") == 0) {\n<35> error_setg(errp, "missing hostname in URI");\n<43> if (!uri->path || strcmp(uri->path, "") == 0) {\n<45> error_setg(errp, "missing remote path in URI");\n<53> qp = query_params_parse(uri->query);\n<55> if (!qp) {\n<65> if(uri->user && strcmp(uri->user, "") != 0) {\n<67> qdict_put(options, "user", qstring_from_str(uri->user));\n<73> qdict_put(options, "host", qstring_from_str(uri->server));\n<85> qdict_put(options, "path", qstring_from_str(uri->path));\n<95> for (i = 0; i < qp->n; ++i) {\n<97> if (strcmp(qp->p[i].name, "host_key_check") == 0) {\n<101> qstring_from_str(qp->p[i].value));\n<111> uri_free(uri);\n<119> if (qp) {\n<125> if (uri) {\n<127> uri_free(uri);\n<131> return -EINVAL;
<1> size_t compile_tree ( struct filter_op * * fop ) {\n<6> fprintf ( stdout , " Unfolding the meta-tree " ) ;\n<7> fflush ( stdout ) ;\n<9> fprintf ( stdout , " done.\n\n" ) ;\n<11> TAILQ_FOREACH ( ue , & unfolded_tree , next ) {\n<12> if ( ue -> label == 0 ) {\n<13> SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n<14> memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ;
<1> int vnc_display_open(DisplayState *ds, const char *arg)\n<21> VncState *vs = ds ? (VncState *)ds->opaque : vnc_state;\n<27> if (strcmp(arg, "none") == 0)\n<29> return 0;\n<33> if (!(vs->display = strdup(arg)))\n<35> return -1;\n<39> if (strstart(arg, "unix:", &p)) {\n<49> if (vs->lsock == -1) {\n<51> fprintf(stderr, "Could not create socket\n");\n<53> free(vs->display);\n<65> memset(uaddr.sun_path, 0, 108);\n<67> snprintf(uaddr.sun_path, 108, "%s", p);\n<85> if (parse_host_port(&iaddr, arg) < 0) {\n<87> fprintf(stderr, "Could not parse VNC address\n");\n<89> free(vs->display);\n<105> if (vs->lsock == -1) {\n<107> fprintf(stderr, "Could not create socket\n");\n<109> free(vs->display);\n<125> if (ret == -1) {\n<127> fprintf(stderr, "setsockopt() failed\n");\n<133> free(vs->display);\n<145> if (bind(vs->lsock, addr, addrlen) == -1) {\n<147> fprintf(stderr, "bind() failed\n");\n<153> free(vs->display);\n<163> if (listen(vs->lsock, 1) == -1) {\n<165> fprintf(stderr, "listen() failed\n");\n<171> free(vs->display);\n<181> return qemu_set_fd_handler2(vs->lsock, vnc_listen_poll, vnc_listen_read, NULL, vs);
<1> static void test_qemu_strtoul_octal(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoul(str, &endptr, 8, &res);\n<25> g_assert(endptr == str + strlen(str));\n<31> endptr = &f;\n<33> err = qemu_strtoul(str, &endptr, 0, &res);\n<41> g_assert(endptr == str + strlen(str));
<1> static int buffered_put_buffer(void *opaque, const uint8_t *buf, int64_t pos, int size)\n<5> QEMUFileBuffered *s = opaque;\n<17> if (error) {\n<19> DPRINTF("flush when error, bailing: %s\n", strerror(-error));\n<27> if (size <= 0) {\n<35> if (size > (s->buffer_capacity - s->buffer_size)) {\n<47> s->buffer = g_realloc(s->buffer, s->buffer_capacity);\n<53> memcpy(s->buffer + s->buffer_size, buf, size);\n<55> s->buffer_size += size;\n<59> return size;
<1> static int ipvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> IpvideoContext * s = avctx -> priv_data ;\n<16> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<17> if ( pal ) {\n<19> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<22> ipvideo_decode_opcodes ( s ) ;
<1> static QDict *monitor_parse_arguments(Monitor *mon,\n<15> const char *p = *endp;\n<29> typestr = key_get_info(typestr, &key);\n<31> if (!typestr)\n<39> switch(c) {\n<53> while (qemu_isspace(*p))\n<55> p++;\n<61> if (*p == '\0') {\n<71> ret = get_str(buf, sizeof(buf), &p);\n<131> p++;\n<135> if (!*p)\n<139> if (get_str(buf, sizeof(buf), &p) < 0) {\n<171> p++;\n<173> if (*p == '/') {\n<177> p++;\n<189> p++;\n<215> format = *p++;\n<223> p++;\n<231> p++;\n<239> p++;\n<249> p++;\n<263> if (*p != '\0' && !qemu_isspace(*p)) {\n<331> while (qemu_isspace(*p))\n<333> p++;\n<339> if (*p == '\0') {\n<349> if (*p == '.') {\n<351> p++;\n<353> while (qemu_isspace(*p))\n<355> p++;\n<371> if (get_expr(mon, &val, &p))\n<415> while (qemu_isspace(*p)) {\n<417> p++;\n<425> if (*p == '\0') {\n<445> p = end;\n<459> while (qemu_isspace(*p))\n<461> p++;\n<467> if (*p == '\0') {\n<475> if (get_double(mon, &val, &p) < 0) {\n<481> if (p[0] && p[1] == 's') {\n<487> val /= 1e3; p += 2; break;\n<491> val /= 1e6; p += 2; break;\n<495> val /= 1e9; p += 2; break;\n<501> if (*p && !qemu_isspace(*p)) {\n<533> while (qemu_isgraph(*p)) {\n<539> if (p - beg == 2 && !memcmp(beg, "on", p - beg)) {\n<541> val = true;\n<543> } else if (p - beg == 3 && !memcmp(beg, "off", p - beg)) {\n<545> val = false;\n<549> monitor_printf(mon, "Expected 'on' or 'off'\n");\n<555> qdict_put(qdict, key, qbool_from_bool(val));\n<581> p++;\n<583> if (*p == '-') {\n<587> if(c != *p) {\n<609> p = tmp;\n<615> p++;\n<637> while (qemu_isspace(*p)) {\n<639> p++;\n<643> if (*typestr == '?') {\n<647> if (*p == '\0') {\n<657> len = strlen(p);\n<659> if (len <= 0) {\n<669> qdict_put(qdict, key, qstring_from_str(p));\n<671> p += len;\n<687> g_free(key);\n<689> key = NULL;\n<717> QDECREF(qdict);\n<719> g_free(key);\n<721> return NULL;
<1> static char * get_pid_environ_val ( pid_t pid , char * val ) {\n<2> char temp [ 500 ] ;\n<6> sprintf ( temp , "/proc/%d/environ" , pid ) ;\n<7> fp = fopen ( temp , "r" ) ;\n<13> if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\0' || temp [ i ] == EOF ) ) {\n<15> temp [ i ] = 0 ;\n<16> ret = malloc ( strlen ( temp ) + 10 ) ;\n<17> sprintf ( ret , "%s" , temp ) ;\n<19> return ret ;\n<21> switch ( temp [ i ] ) {\n<24> case '=' : temp [ i ] = 0 ;\n<25> if ( ! strcmp ( temp , val ) ) {\n<26> foundit = 1 ;
<1> static int process_output_surface(AVCodecContext *avctx, AVPacket *pkt, NvencSurface *tmpoutsurf)\n<17> NV_ENC_LOCK_BITSTREAM lock_params = { 0 };\n<67> lock_params.version = NV_ENC_LOCK_BITSTREAM_VER;\n<71> lock_params.doNotWait = 0;\n<73> lock_params.outputBitstream = tmpoutsurf->output_surface;\n<75> lock_params.sliceOffsets = slice_offsets;\n<91> if (res = ff_alloc_packet2(avctx, pkt, lock_params.bitstreamSizeInBytes,0)) {\n<101> memcpy(pkt->data, lock_params.bitstreamBufferPtr, lock_params.bitstreamSizeInBytes);\n<209> res = nvenc_set_timestamp(avctx, &lock_params, pkt);
<1> PXA2xxState *pxa255_init(unsigned int sdram_size)\n<19> if (!s->env) {\n<21> fprintf(stderr, "Unable to find CPU definition\n");\n<65> if (!dinfo) {\n<67> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)\n<13> const char *boot_cpu = s->boot_cpu ? s->boot_cpu : "apu-cpu[0]";\n<169> for (i = 0; i < XLNX_ZYNQMP_NUM_APU_CPUS; i++) {\n<183> name = object_get_canonical_path_component(OBJECT(&s->apu_cpu[i]));\n<185> if (strcmp(name, boot_cpu)) {\n<189> object_property_set_bool(OBJECT(&s->apu_cpu[i]), true,\n<191> "start-powered-off", &error_abort);\n<195> s->boot_cpu_ptr = &s->apu_cpu[i];\n<199> g_free(name);\n<247> for (i = 0; i < XLNX_ZYNQMP_NUM_RPU_CPUS; i++) {\n<253> name = object_get_canonical_path_component(OBJECT(&s->rpu_cpu[i]));\n<255> if (strcmp(name, boot_cpu)) {\n<259> object_property_set_bool(OBJECT(&s->rpu_cpu[i]), true,\n<261> "start-powered-off", &error_abort);\n<265> s->boot_cpu_ptr = &s->rpu_cpu[i];\n<269> g_free(name);\n<295> error_setg(errp, "ZynqMP Boot cpu %s not found", boot_cpu);
<1> static void vga_screen_dump_blank(VGAState *s, const char *filename)\n<11> w = s->last_scr_width * sizeof(uint32_t);\n<13> h = s->last_scr_height;\n<19> if (!f)\n<23> fprintf(f, "P6\n%d %d\n%d\n", w, h, 255);\n<25> for (y = 0; y < h; y++) {\n<27> for (x = 0; x < w; x++) {\n<29> fputc(0, f);\n<35> fclose(f);
<1> static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n<57> inc_refcounts(bs, res, *refcount_table, *nb_clusters,\n<95> if ((new_offset >> s->cluster_bits) >= *nb_clusters) {\n<103> *refcount_table = g_renew(uint16_t, *refcount_table,\n<117> inc_refcounts(bs, res, *refcount_table, *nb_clusters,
<1> static int handle_cmd(AHCIState *s, int port, int slot)\n<77> ide_state = &s->dev[port].port.ifs[0];\n<91> debug_print_fis(cmd_fis, 0x90);\n<237> ide_set_sector(ide_state, ((uint64_t)cmd_fis[10] << 40)\n<265> if (opts & AHCI_CMD_ATAPI) {\n<267> memcpy(ide_state->io_buffer, &cmd_fis[AHCI_COMMAND_TABLE_ACMD], 0x10);\n<273> debug_print_fis(ide_state->io_buffer, 0x10);
<1> static int rtsp_read_packet(AVFormatContext *s,\n<7> RTSPState *rt = s->priv_data;\n<21> enum AVDiscard cache[MAX_STREAMS];\n<27> cache[i] = s->streams[i]->discard;\n<31> if (!rt->need_subscription) {\n<35> sizeof(enum AVDiscard) * s->nb_streams)) {\n<37> av_strlcatf(cmd, sizeof(cmd),\n<43> s->filename, rt->last_subscription);\n<45> rtsp_send_cmd(s, cmd, reply, NULL);\n<47> if (reply->status_code != RTSP_STATUS_OK)\n<59> if (rt->need_subscription) {\n<67> sizeof(enum AVDiscard) * s->nb_streams);
<1> static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n<3> struct vmsvga_cursor_definition_s *c)\n<19> switch (c->bpp) {\n<63> fprintf(stderr, "%s: unhandled bpp %d, using fallback cursor\n",
<1> int qemu_opts_id_wellformed(const char *id)\n<15> for (i = 1; id[i]; i++) {\n<17> if (!qemu_isalnum(id[i]) && !strchr("-._", id[i])) {\n<19> return 0;
<1> static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, enum AVMediaType type, int source_index)\n<115> buf = get_line(s);\n<117> if (!buf[0] || buf[0] == '#') {\n<125> if (!(arg = strchr(buf, '='))) {\n<127> av_log(NULL, AV_LOG_FATAL, "Invalid line found in the preset file.\n");\n<129> exit_program(1);\n<133> *arg++ = 0;\n<135> av_dict_set(&ost->encoder_opts, buf, arg, AV_DICT_DONT_OVERWRITE);
<1> static int img_compare(int argc, char **argv)\n<181> if (total_sectors1 < 0) {\n<185> filename1, strerror(-total_sectors1));\n<195> if (total_sectors2 < 0) {\n<199> filename2, strerror(-total_sectors2));
<1> static void bt_dummy_lmp_acl_resp(struct bt_link_s *link,\n<7> fprintf(stderr, "%s: stray ACL response PDU, fixme\n", __FUNCTION__);
<1> void MPV_decode_mb(MpegEncContext *s, DCTELEM block[6][64])\n<37> if(s->mbintra_table[mb_x + mb_y*s->mb_width])\n<63> memset(s->ac_val[0][xy], 0, 16 * sizeof(INT16));\n<65> memset(s->ac_val[0][xy + 1], 0, 16 * sizeof(INT16));\n<67> memset(s->ac_val[0][xy + wrap], 0, 16 * sizeof(INT16));\n<69> memset(s->ac_val[0][xy + 1 + wrap], 0, 16 * sizeof(INT16));\n<95> memset(s->ac_val[1][xy], 0, 16 * sizeof(INT16));\n<97> memset(s->ac_val[2][xy], 0, 16 * sizeof(INT16));
<1> static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)\n<17> if (s->profile > 1) {\n<41> memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_epel_pixels_tab, sizeof(s->put_pixels_tab));\n<55> if (s->keyframe) {\n<73> vp78_reset_probability_tables(s);\n<75> memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter,\n<79> memcpy(s->prob->pred8x8c, vp8_pred8x8c_prob_inter,\n<83> for (i = 0; i < 2; i++)\n<85> memcpy(s->prob->mvc[i], vp7_mv_default_prob[i],\n<89> memset(&s->segmentation, 0, sizeof(s->segmentation));\n<91> memset(&s->lf_delta, 0, sizeof(s->lf_delta));\n<93> memcpy(s->prob[0].scan, zigzag_scan, sizeof(s->prob[0].scan));\n<99> if (s->keyframe || s->profile > 0)\n<101> memset(s->inter_dc_pred, 0 , sizeof(s->inter_dc_pred));\n<159> if ((ret = vp7_update_dimensions(s, width, height)) < 0)\n<169> vp7_get_quants(s);\n<215> if ((ret = vp7_fade_frame(s ,c)) < 0)\n<237> s->prob[0].scan[i] = zigzag_scan[vp8_rac_get_uint(c, 4)];\n<255> vp78_update_probability_tables(s);\n<271> vp78_update_pred16x16_pred8x8_mvc_probabilities(s, VP7_MVC_SIZE);
<1> static int amr_probe(AVProbeData *p)\n<13> if (p->buf_size < 5)\n<17> if(memcmp(p->buf,AMR_header,5)==0)\n<19> return AVPROBE_SCORE_MAX;\n<23> return 0;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<60> out = outdata ;\n<68> if ( code & 0x80 ) {\n<69> pix = * buf ++ ;\n<70> if ( ( out + ( 257 - code ) ) > ( outdata + a -> pic . linesize [ 0 ] ) ) break ;\n<71> memset ( out , pix , 257 - code ) ;\n<72> out += 257 - code ;\n<78> if ( buf_end - buf < code + 1 ) return AVERROR_INVALIDDATA ;\n<79> memcpy ( out , buf , code + 1 ) ;\n<80> out += code + 1 ;\n<81> buf += code + 1 ;
<1> static VALUE cState_indent_set ( VALUE self , VALUE indent ) {\n<6> if ( len == 0 ) {\n<15> state -> indent = strdup ( RSTRING_PTR ( indent ) ) ;
<1> static void do_sendkey(Monitor *mon, const QDict *qdict)\n<11> const char *keys = qdict_get_str(qdict, "keys");\n<35> separator = strchr(keys, '-');\n<37> keyname_len = separator ? separator - keys : strlen(keys);\n<41> pstrcpy(keyname_buf, sizeof(keyname_buf), keys);\n<103> if (!separator)\n<107> keys = separator + 1;
<1> static int parse_ffconfig(const char *filename)\n<27> f = fopen(filename, "r");\n<29> if (!f) {\n<51> stream = NULL;\n<53> feed = NULL;\n<63> if (fgets(line, sizeof(line), f) == NULL)\n<67> line_num++;\n<69> p = line;\n<71> while (isspace(*p))\n<75> if (*p == '\0' || *p == '#')\n<89> val = atoi(arg);\n<91> if (val < 1 || val > 65536) {\n<107> if (resolve_host(&my_http_addr.sin_addr, arg) != 0) {\n<109> fprintf(stderr, "%s:%d: Invalid host/IP address: %s\n",\n<125> val = atoi(arg);\n<127> if (val < 1 || val > 65536) {\n<137> my_rtsp_addr.sin_port = htons(atoi(arg));\n<143> if (resolve_host(&my_rtsp_addr.sin_addr, arg) != 0) {\n<145> fprintf(stderr, "%s:%d: Invalid host/IP address: %s\n",\n<157> val = atoi(arg);\n<159> if (val < 1 || val > 65536) {\n<161> fprintf(stderr, "%s:%d: Invalid MaxHTTPConnections: %s\n",\n<175> val = atoi(arg);\n<177> if (val < 1 || val > nb_max_http_connections) {\n<179> fprintf(stderr, "%s:%d: Invalid MaxClients: %s\n",\n<197> llval = atoll(arg);\n<199> if (llval < 10 || llval > 10000000) {\n<201> fprintf(stderr, "%s:%d: Invalid MaxBandwidth: %s\n",\n<225> if (stream || feed) {\n<233> feed = av_mallocz(sizeof(FFStream));\n<237> q = strrchr(feed->filename, '>');\n<245> for (s = first_feed; s; s = s->next) {\n<247> if (!strcmp(feed->filename, s->filename)) {\n<249> fprintf(stderr, "%s:%d: Feed '%s' already registered\n",\n<251> filename, line_num, s->filename);\n<253> errors++;\n<261> feed->fmt = guess_format("ffm", NULL, NULL);\n<265> snprintf(feed->feed_filename, sizeof(feed->feed_filename),\n<269> feed->feed_max_size = 5 * 1024 * 1024;\n<271> feed->is_feed = 1;\n<273> feed->feed = feed; /* self feeding :-) */\n<293> if (feed) {\n<299> feed->child_argv = av_mallocz(64 * sizeof(char *));\n<307> if (!arg[0])\n<319> feed->child_argv[i] = av_malloc(30 + strlen(feed->filename));\n<323> snprintf(feed->child_argv[i], 30+strlen(feed->filename),\n<329> inet_ntoa(my_http_addr.sin_addr),\n<331> ntohs(my_http_addr.sin_port), feed->filename);\n<341> feed->readonly = 1;\n<345> get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n<357> get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n<365> feed->truncate = strtod(arg, NULL);\n<409> if (feed->feed_max_size < FFM_PACKET_SIZE*4) {\n<411> fprintf(stderr, "%s:%d: Feed max file size is too small, "\n<413> "must be at least %d\n", filename, line_num, FFM_PACKET_SIZE*4);\n<423> if (!feed) {\n<425> fprintf(stderr, "%s:%d: No corresponding <Feed> for </Feed>\n",\n<433> feed = NULL;\n<443> if (stream || feed) {\n<451> FFStream *s;\n<455> stream = av_mallocz(sizeof(FFStream));\n<459> q = strrchr(stream->filename, '>');\n<467> for (s = first_stream; s; s = s->next) {\n<469> if (!strcmp(stream->filename, s->filename)) {\n<471> fprintf(stderr, "%s:%d: Stream '%s' already registered\n",\n<473> filename, line_num, s->filename);\n<475> errors++;\n<483> stream->fmt = guess_stream_format(NULL, stream->filename, NULL);\n<491> avcodec_get_context_defaults(&video_enc);\n<493> class = video_enc.av_class;\n<495> memset(&audio_enc, 0, sizeof(AVCodecContext));\n<497> memset(&video_enc, 0, sizeof(AVCodecContext));\n<499> audio_enc.av_class = class;\n<517> *last_stream = stream;\n<525> get_arg(arg, sizeof(arg), &p);\n<535> while (sfeed != NULL) {\n<537> if (!strcmp(sfeed->filename, arg))\n<541> sfeed = sfeed->next_feed;\n<545> if (!sfeed)\n<547> fprintf(stderr, "%s:%d: feed '%s' not defined\n",\n<553> stream->feed = sfeed;\n<559> get_arg(arg, sizeof(arg), &p);\n<561> if (stream) {\n<563> if (!strcmp(arg, "status")) {\n<565> stream->stream_type = STREAM_TYPE_STATUS;\n<567> stream->fmt = NULL;\n<571> stream->stream_type = STREAM_TYPE_LIVE;\n<575> if (!strcmp(arg, "jpeg"))\n<577> strcpy(arg, "mjpeg");\n<579> stream->fmt = guess_stream_format(arg, NULL, NULL);\n<581> if (!stream->fmt) {\n<609> stream->ifmt = av_find_input_format(arg);\n<611> if (!stream->ifmt) {\n<613> fprintf(stderr, "%s:%d: Unknown input format: %s\n",\n<623> if (stream && stream->stream_type == STREAM_TYPE_STATUS) {\n<625> get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n<629> fprintf(stderr, "%s:%d: FaviconURL only permitted for status streams\n",\n<641> get_arg(stream->author, sizeof(stream->author), &p);\n<647> get_arg(stream->comment, sizeof(stream->comment), &p);\n<653> get_arg(stream->copyright, sizeof(stream->copyright), &p);\n<659> get_arg(stream->title, sizeof(stream->title), &p);\n<667> stream->prebuffer = atof(arg) * 1000;\n<673> stream->send_on_key = 1;\n<679> audio_id = opt_audio_codec(arg);\n<681> if (audio_id == CODEC_ID_NONE) {\n<683> fprintf(stderr, "%s:%d: Unknown AudioCodec: %s\n",\n<695> video_id = opt_video_codec(arg);\n<697> if (video_id == CODEC_ID_NONE) {\n<699> fprintf(stderr, "%s:%d: Unknown VideoCodec: %s\n",\n<713> stream->max_time = atof(arg) * 1000;\n<721> audio_enc.bit_rate = atoi(arg) * 1000;\n<729> audio_enc.channels = atoi(arg);\n<737> audio_enc.sample_rate = atoi(arg);\n<751> if (stream) {\n<757> get_arg(arg, sizeof(arg), &p);\n<761> if (sscanf(arg, "%d-%d", &minrate, &maxrate) == 2) {\n<763> video_enc.rc_min_rate = minrate * 1000;\n<765> video_enc.rc_max_rate = maxrate * 1000;\n<769> fprintf(stderr, "%s:%d: Incorrect format for VideoBitRateRange -- should be <min>-<max>: %s\n",\n<773> errors++;\n<785> video_enc.debug = strtol(arg,0,0);\n<795> video_enc.strict_std_compliance = atoi(arg);\n<805> video_enc.rc_buffer_size = atoi(arg) * 8*1024;\n<815> video_enc.bit_rate_tolerance = atoi(arg) * 1000;\n<825> video_enc.bit_rate = atoi(arg) * 1000;\n<835> av_parse_video_frame_size(&video_enc.width, &video_enc.height, arg);\n<837> if ((video_enc.width % 16) != 0 ||\n<839> (video_enc.height % 16) != 0) {\n<841> fprintf(stderr, "%s:%d: Image size must be a multiple of 16\n",\n<859> if (av_parse_video_frame_rate(&frame_rate, arg) < 0) {\n<861> fprintf(stderr, "Incorrect frame rate\n");\n<881> video_enc.gop_size = atoi(arg);\n<887> video_enc.gop_size = 1;\n<893> video_enc.mb_decision = FF_MB_DECISION_BITS;\n<899> video_enc.mb_decision = FF_MB_DECISION_BITS; //FIXME remove\n<901> video_enc.flags |= CODEC_FLAG_4MV;\n<921> avctx = &video_enc;\n<927> avctx = &audio_enc;\n<933> if (ffserver_opt_default(arg, arg2, avctx, type|AV_OPT_FLAG_ENCODING_PARAM)) {\n<935> fprintf(stderr, "AVOption error: %s %s\n", arg, arg2);\n<941> } else if (!strcasecmp(cmd, "VideoTag")) {\n<943> get_arg(arg, sizeof(arg), &p);\n<945> if ((strlen(arg) == 4) && stream)\n<947> video_enc.codec_tag = AV_RL32(arg);\n<953> video_enc.flags |= CODEC_FLAG_BITEXACT;\n<959> video_enc.dct_algo  = FF_DCT_FASTINT;\n<965> video_enc.idct_algo = FF_IDCT_SIMPLE;\n<973> video_enc.flags |= CODEC_FLAG_QSCALE;\n<975> video_enc.global_quality = FF_QP2LAMBDA * atoi(arg);\n<987> if (video_enc.max_qdiff < 1 || video_enc.max_qdiff > 31) {\n<989> fprintf(stderr, "%s:%d: VideoQDiff out of range\n",\n<1007> if (video_enc.qmax < 1 || video_enc.qmax > 31) {\n<1009> fprintf(stderr, "%s:%d: VideoQMax out of range\n",\n<1027> if (video_enc.qmin < 1 || video_enc.qmin > 31) {\n<1029> fprintf(stderr, "%s:%d: VideoQMin out of range\n",\n<1045> video_enc.luma_elim_threshold = atoi(arg);\n<1053> video_enc.chroma_elim_threshold = atoi(arg);\n<1061> video_enc.lumi_masking = atof(arg);\n<1069> video_enc.dark_masking = atof(arg);\n<1091> else if (strcasecmp(arg, "deny") == 0)\n<1097> fprintf(stderr, "%s:%d: ACL action '%s' is not ALLOW or DENY\n",\n<1111> if (resolve_host(&acl.first, arg) != 0) {\n<1113> fprintf(stderr, "%s:%d: ACL refers to invalid host or ip address '%s'\n",\n<1131> if (resolve_host(&acl.last, arg) != 0) {\n<1133> fprintf(stderr, "%s:%d: ACL refers to invalid host or ip address '%s'\n",\n<1163> else if (feed)\n<1169> fprintf(stderr, "%s:%d: ACL found not in <stream> or <feed>\n",\n<1199> av_freep(&stream->rtsp_option);\n<1201> stream->rtsp_option = av_strdup(arg);\n<1211> if (resolve_host(&stream->multicast_ip, arg) != 0) {\n<1213> fprintf(stderr, "%s:%d: Invalid host/IP address: %s\n",\n<1221> stream->is_multicast = 1;\n<1223> stream->loop = 1; /* default is looping */\n<1233> stream->multicast_port = atoi(arg);\n<1241> stream->multicast_ttl = atoi(arg);\n<1247> stream->loop = 0;\n<1251> if (!stream) {\n<1253> fprintf(stderr, "%s:%d: No corresponding <Stream> for </Stream>\n",\n<1261> if (stream->feed && stream->fmt && strcmp(stream->fmt->name, "ffm") != 0) {\n<1263> if (audio_id != CODEC_ID_NONE) {\n<1265> audio_enc.codec_type = CODEC_TYPE_AUDIO;\n<1267> audio_enc.codec_id = audio_id;\n<1269> add_codec(stream, &audio_enc);\n<1273> if (video_id != CODEC_ID_NONE) {\n<1275> video_enc.codec_type = CODEC_TYPE_VIDEO;\n<1277> video_enc.codec_id = video_id;\n<1279> add_codec(stream, &video_enc);\n<1285> stream = NULL;\n<1295> if (stream || feed || redirect) {\n<1333> if (!redirect) {\n<1335> fprintf(stderr, "%s:%d: No corresponding <Redirect> for </Redirect>\n",\n<1343> if (!redirect->feed_filename[0]) {\n<1345> fprintf(stderr, "%s:%d: No URL found for <Redirect>\n",\n<1353> redirect = NULL;\n<1357> } else if (!strcasecmp(cmd, "LoadModule")) {\n<1359> get_arg(arg, sizeof(arg), &p);\n<1367> fprintf(stderr, "%s:%d: Module support not compiled into this version: '%s'\n",\n<1377> fprintf(stderr, "%s:%d: Incorrect keyword: '%s'\n",\n<1387> fclose(f);
<1> static CheckasmFunc *get_func(const char *name, int length)\n<11> while ((f = *f_ptr)) {\n<13> int cmp = cmp_func_names(name, f->name);\n<29> f = *f_ptr = checkasm_malloc(sizeof(CheckasmFunc) + length);\n<31> memcpy(f->name, name, length+1);\n<35> return f;
<1> static void mpc8544ds_init(ram_addr_t ram_size,\n<51> if (!env) {\n<53> fprintf(stderr, "Unable to initialize CPU!\n");\n<121> if (!pci_bus)\n<123> printf("couldn't create PCI controller!\n");\n<149> kernel_size = load_uimage(kernel_filename, &entry, &loadaddr, NULL);\n<153> kernel_size = load_elf(kernel_filename, 0, &elf_entry, &elf_lowaddr,\n<165> if (kernel_size < 0) {\n<167> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<183> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<189> if (initrd_size < 0) {\n<191> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<211> if (fdt == NULL) {\n<213> fprintf(stderr, "couldn't load device tree\n");
<7> H264Context *h = dst->priv_data, *h1 = src->priv_data;\n<111> if ((err = h264_slice_header_init(h)) < 0) {\n<123> memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));\n<151> ff_h264_unref_picture(h, &h->DPB[i]);\n<155> (ret = ff_h264_ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0)\n<163> h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1);\n<165> ff_h264_unref_picture(h, &h->cur_pic);\n<169> ret = ff_h264_ref_picture(h, &h->cur_pic, &h1->cur_pic);\n<199> copy_fields(h, h1, poc_lsb, current_slice);\n<203> copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1);\n<205> copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1);\n<207> copy_picture_range(h->delayed_pic, h1->delayed_pic,\n<221> err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
<1> static int usb_hid_handle_control(USBDevice *dev, int request, int value,\n<13> ret = usb_desc_handle_control(dev, request, value, index, length, data);\n<107> if (s->kind == USB_MOUSE) {\n<115> } else if (s->kind == USB_TABLET) {\n<117> memcpy(data, qemu_tablet_hid_report_descriptor,\n<123> } else if (s->kind == USB_KEYBOARD) {\n<125> memcpy(data, qemu_keyboard_hid_report_descriptor,
<1> static int handle_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n<3> const char *name, V9fsPath *target)\n<19> if (!strcmp(name, ".") || !strcmp(name, "..")) {\n<21> errno = EINVAL;\n<23> return -1;\n<29> if (dir_path) {\n<41> if (dirfd < 0) {\n<53> snprintf(buffer, PATH_MAX, "./%s", name);
<1> static void do_apply_filter(APEContext *ctx, int version, APEFilter *f,\n<91> if (f->delay == f->historybuffer + HISTORY_SIZE + (order * 2)) {\n<93> memmove(f->historybuffer, f->delay - (order * 2),\n<95> (order * 2) * sizeof(*f->historybuffer));\n<97> f->delay = f->historybuffer + order * 2;\n<99> f->adaptcoeffs = f->historybuffer + order;
<1> static int do_load_save_vmstate(BDRVSheepdogState *s, uint8_t *data,\n<69> if (ret < 0) {\n<71> error_report("failed to save vmstate %s", strerror(errno));
<1> static int com_connect ( String * buffer , char * line ) {\n<5> bzero ( buff , sizeof ( buff ) ) ;\n<7> tmp = strmake ( buff , line , sizeof ( buff ) - 2 ) ;\n<13> tmp = get_arg ( buff , 1 ) ;\n<25> error = sql_connect ( current_host , current_db , current_user , opt_password , 0 ) ;\n<27> if ( connected ) {\n<28> sprintf ( buff , "Connection id: %lu" , mysql_thread_id ( & mysql ) ) ;\n<29> put_info ( buff , INFO_INFO ) ;\n<30> sprintf ( buff , "Current database: %.128s\n" , current_db ? current_db : "*** NONE ***" ) ;\n<31> put_info ( buff , INFO_INFO ) ;
<1> static int enable_write_target(BDRVVVFATState *s)\n<13> int size = sector2cluster(s, s->sector_count);\n<15> s->used_clusters = calloc(size, 1);\n<93> *(void**)s->bs->backing_hd->opaque = s;
<1> static int truespeech_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<15> if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n<19> samples = ( int16_t * ) frame -> data [ 0 ] ;\n<20> memset ( samples , 0 , iterations * 240 * sizeof ( * samples ) ) ;\n<32> truespeech_place_pulses ( c , samples , i ) ;
<1> static int ipvideo_decode_block_opcode_0xB(IpvideoContext *s)\n<15> for (y = 0; y < 8; y++) {\n<17> memcpy(s->pixel_ptr, s->stream_ptr, 8);\n<19> s->stream_ptr += 8;\n<21> s->pixel_ptr  += s->stride;
<1> static inline void vmsvga_update_rect(struct vmsvga_state_s *s,\n<3> int x, int y, int w, int h)\n<21> if (x + w > s->width) {\n<23> fprintf(stderr, "%s: update width too large x: %d, w: %d\n",\n<27> x = MIN(x, s->width);\n<35> if (y + h > s->height) {\n<37> fprintf(stderr, "%s: update height too large y: %d, h: %d\n",\n<41> y = MIN(y, s->height);\n<53> width = s->bypp * w;\n<57> src = s->vga.vram_ptr + start;\n<59> dst = ds_get_data(s->vga.ds) + start;\n<63> for (; line > 0; line --, src += bypl, dst += bypl)\n<65> memcpy(dst, src, width);
<1> static int kvm_physical_sync_dirty_bitmap(MemoryRegionSection *section)\n<27> if (mem == NULL) {\n<63> if (!d.dirty_bitmap) {\n<65> d.dirty_bitmap = g_malloc(size);\n<67> } else if (size > allocated_size) {\n<69> d.dirty_bitmap = g_realloc(d.dirty_bitmap, size);\n<73> allocated_size = size;\n<75> memset(d.dirty_bitmap, 0, allocated_size);\n<79> d.slot = mem->slot;\n<83> if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n<95> kvm_get_dirty_pages_log_range(section, d.dirty_bitmap);\n<101> g_free(d.dirty_bitmap);
<1> static void ne2000_receive(void *opaque, const uint8_t *buf, size_t size)\n<5> NE2000State *s = opaque;\n<11> uint8_t buf1[60];\n<27> if (s->cmd & E8390_STOP || ne2000_buffer_full(s))\n<35> if (s->rxcr & 0x10) {\n<41> if (!memcmp(buf,  broadcast_macaddr, 6)) {\n<45> if (!(s->rxcr & 0x04))\n<49> } else if (buf[0] & 0x01) {\n<57> mcast_idx = compute_mcast_idx(buf);\n<63> } else if (s->mem[0] == buf[0] &&\n<65> s->mem[2] == buf[1] &&\n<67> s->mem[4] == buf[2] &&\n<69> s->mem[6] == buf[3] &&\n<71> s->mem[8] == buf[4] &&\n<73> s->mem[10] == buf[5]) {\n<91> if (size < MIN_BUF_SIZE) {\n<93> memcpy(buf1, buf, size);\n<95> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<97> buf = buf1;\n<127> if (buf[0] & 0x01)\n<145> while (size > 0) {\n<147> if (index <= s->stop)\n<149> avail = s->stop - index;\n<157> if (len > avail)\n<159> len = avail;\n<161> memcpy(s->mem + index, buf, len);\n<163> buf += len;\n<165> index += len;\n<171> size -= len;
<1> vpx_codec_err_t vpx_svc_set_quantizers ( SvcContext * svc_ctx , const char * quantizers ) {\n<2> SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n<3> if ( svc_ctx == NULL || quantizers == NULL || si == NULL ) {\n<6> strncpy ( si -> quantizers , quantizers , sizeof ( si -> quantizers ) ) ;
<1> void helper_booke206_tlbwe(CPUPPCState *env)\n<55> if (((env->spr[SPR_BOOKE_MAS0] & MAS0_ATSEL) == MAS0_ATSEL_LRAT) &&\n<61> fprintf(stderr, "cpu: don't support LRAT setting yet\n");
<1> int avfilter_parse_graph(AVFilterGraph *graph, const char *filters,\n<3> AVFilterInOut *openLinks, AVClass *log_ctx)\n<27> pad = parse_inputs(&filters, &currInputs, &openLinks, log_ctx);\n<49> pad = parse_inputs(&tmp, &currInputs, &openLinks, log_ctx);\n<59> if(link_filter_inouts(filter, &currInputs, &openLinks, log_ctx) < 0)\n<65> pad = parse_outputs(&filters, &currInputs, &openLinks, log_ctx);\n<81> if(chr == ';' && currInputs) {\n<95> } while(chr == ',' || chr == ';');\n<99> if(openLinks && !strcmp(openLinks->name, "out") && currInputs) {\n<103> const char *tmp = "[out]";\n<105> if(parse_outputs(&tmp, &currInputs, &openLinks, log_ctx) < 0)\n<113> return 0;\n<121> free_inout(openLinks);\n<123> free_inout(currInputs);
<1> static void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n<17> char *base_core_type = spapr_get_cpu_core_type(machine->cpu_model);\n<19> const char *type = object_get_typename(OBJECT(dev));\n<29> if (dev->hotplugged && !mc->has_hotpluggable_cpus) {\n<39> if (strcmp(base_core_type, type)) {\n<41> error_setg(&local_err, "CPU core type should be %s", base_core_type);\n<49> if (cc->core_id % smp_threads) {\n<125> g_free(base_core_type);\n<127> error_propagate(errp, local_err);
<1> int msmpeg4_decode_picture_header(MpegEncContext * s)\n<37> if(start_code!=0x00000100){\n<39> fprintf(stderr, "invalid startcode\n");\n<59> fprintf(stderr, "invalid picture type\n");\n<89> if(code==0 || code>s->mb_height){\n<91> fprintf(stderr, "invalid slice height %d\n", code);\n<105> if (code < 0x17){\n<107> fprintf(stderr, "error, slice code was %X\n", code);
<1> static char *isabus_get_fw_dev_path(DeviceState *dev)\n<13> off = snprintf(path, sizeof(path), "%s", qdev_fw_name(dev));\n<23> return strdup(path);
<1> static int vmdk_open_desc_file(BlockDriverState *bs, int flags, char *buf,\n<15> if (vmdk_parse_description(buf, "createType", ct, sizeof(ct))) {\n<25> if (strcmp(ct, "monolithicFlat") &&\n<27> strcmp(ct, "vmfs") &&\n<29> strcmp(ct, "vmfsSparse") &&\n<31> strcmp(ct, "twoGbMaxExtentSparse") &&\n<33> strcmp(ct, "twoGbMaxExtentFlat")) {\n<35> error_setg(errp, "Unsupported image type '%s'", ct);\n<37> ret = -ENOTSUP;\n<43> s->create_type = g_strdup(ct);\n<45> s->desc_offset = 0;\n<47> ret = vmdk_parse_extents(buf, bs, bs->file->exact_filename, errp);
<1> static int flac_decode_frame(AVCodecContext *avctx,\n<5> uint8_t *buf, int buf_size)\n<9> FLACContext *s = avctx->priv_data;\n<31> s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize);\n<37> if(1 && s->max_framesize){//FIXME truncated\n<39> buf_size= FFMIN(buf_size, s->max_framesize - s->bitstream_size);\n<45> if(s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size){\n<49> memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size);\n<55> memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size);\n<57> buf= &s->bitstream[s->bitstream_index];\n<59> buf_size += s->bitstream_size;\n<123> metadata_streaminfo(s);\n<125> dump_headers(s);\n<165> if (decode_frame(s) < 0)
<1> CharDriverState *qemu_chr_open_opts(QemuOpts *opts,\n<13> if (qemu_opts_id(opts) == NULL) {\n<15> fprintf(stderr, "chardev: no id specified\n");\n<23> for (i = 0; i < ARRAY_SIZE(backend_table); i++) {\n<25> if (strcmp(backend_table[i].name, qemu_opt_get(opts, "backend")) == 0)\n<31> if (i == ARRAY_SIZE(backend_table)) {\n<33> fprintf(stderr, "chardev: backend \"%s\" not found\n",\n<35> qemu_opt_get(opts, "backend"));\n<45> if (!chr) {\n<47> fprintf(stderr, "chardev: opening backend \"%s\" failed\n",\n<49> qemu_opt_get(opts, "backend"));\n<67> if (qemu_opt_get_bool(opts, "mux", 0)) {\n<71> int len = strlen(qemu_opts_id(opts)) + 6;\n<73> base->label = qemu_malloc(len);
<1> static void dump_regs(TCGContext *s)\n<13> for(i = 0; i < s->nb_temps; i++) {\n<15> ts = &s->temps[i];\n<17> printf("  %10s: ", tcg_get_arg_str_idx(s, buf, sizeof(buf), i));\n<19> switch(ts->val_type) {\n<23> printf("%s", tcg_target_reg_names[ts->reg]);\n<29> printf("%d(%s)", (int)ts->mem_offset, tcg_target_reg_names[ts->mem_reg]);\n<41> printf("D");\n<47> printf("???");\n<53> printf("\n");\n<61> if (s->reg_to_temp[i] >= 0) {\n<67> tcg_get_arg_str_idx(s, buf, sizeof(buf), s->reg_to_temp[i]));
<1> static int libvorbis_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<27> buffer = vorbis_analysis_buffer(&s->vd, samples);\n<29> for (c = 0; c < channels; c++) {\n<37> samples * sizeof(*buffer[c]));
<1> static int spapr_vio_busdev_init(DeviceState *qdev)\n<15> if (dev->reg != -1) {\n<29> VIOsPAPRDevice *other = reg_conflict(dev);\n<33> if (other) {\n<35> fprintf(stderr, "vio: %s and %s devices conflict at address %#x\n",\n<37> object_get_typename(OBJECT(qdev)),\n<39> object_get_typename(OBJECT(&other->qdev)),
<1> static void configure_rtc(QemuOpts *opts)\n<9> value = qemu_opt_get(opts, "base");\n<11> if (value) {\n<13> if (!strcmp(value, "utc")) {\n<15> rtc_utc = 1;\n<17> } else if (!strcmp(value, "localtime")) {\n<19> rtc_utc = 0;\n<23> configure_rtc_date_offset(value, 0);\n<29> value = qemu_opt_get(opts, "clock");\n<31> if (value) {\n<33> if (!strcmp(value, "host")) {\n<35> rtc_clock = QEMU_CLOCK_HOST;\n<37> } else if (!strcmp(value, "rt")) {\n<39> rtc_clock = QEMU_CLOCK_REALTIME;\n<41> } else if (!strcmp(value, "vm")) {\n<43> rtc_clock = QEMU_CLOCK_VIRTUAL;\n<47> fprintf(stderr, "qemu: invalid option value '%s'\n", value);\n<49> exit(1);\n<55> value = qemu_opt_get(opts, "driftfix");\n<57> if (value) {\n<59> if (!strcmp(value, "slew")) {\n<65> .driver   = "mc146818rtc",\n<67> .property = "lost_tick_policy",\n<69> .value    = "slew",\n<73> { /* end of list */ }\n<79> qdev_prop_register_global_list(slew_lost_ticks);\n<81> } else if (!strcmp(value, "none")) {\n<87> fprintf(stderr, "qemu: invalid option value '%s'\n", value);\n<89> exit(1);
<1> static void nand_command(NANDFlashState *s)\n<7> switch (s->cmd) {\n<143> printf("%s: Unknown NAND command 0x%02x\n", __FUNCTION__, s->cmd);
<1> static DisplayType select_display(const char *p)\n<13> if (strstart(p, "sdl", &opts)) {\n<131> fprintf(stderr, "SDL support is disabled\n");\n<137> } else if (strstart(p, "vnc", &opts)) {\n<161> fprintf(stderr, "VNC support is disabled\n");\n<167> } else if (strstart(p, "curses", &opts)) {\n<175> fprintf(stderr, "Curses support is disabled\n");\n<181> } else if (strstart(p, "gtk", &opts)) {\n<245> fprintf(stderr, "GTK support is disabled\n");\n<251> } else if (strstart(p, "none", &opts)) {\n<257> fprintf(stderr, "Unknown display type: %s\n", p);
<1> static int v4l2_read_header(AVFormatContext *s1)\n<93> if (v4l2_ioctl(s->fd, VIDIOC_G_FMT, &fmt) < 0) {\n<95> av_log(s1, AV_LOG_ERROR, "ioctl(VIDIOC_G_FMT): %s\n",\n<97> strerror(errno));\n<99> return AVERROR(errno);
<1> int jbig2_decode_generic_mmr ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image ) {\n<3> const int rowstride = image -> stride ;\n<4> byte * dst = image -> data ;\n<10> y < image -> height ;\n<12> memset ( dst , 0 , rowstride ) ;\n<13> code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n<16> dst += rowstride ;
<1> static void sun4m_hw_init(const struct sun4m_hwdef *hwdef, ram_addr_t RAM_size,\n<59> if (!env) {\n<61> fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n");\n<101> if ((uint64_t)RAM_size > hwdef->max_mem) {\n<107> (unsigned int)(RAM_size / (1024 * 1024)),\n<109> (unsigned int)(hwdef->max_mem / (1024 * 1024)));\n<141> ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);\n<145> ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);\n<147> if (ret < 0 || ret > PROM_SIZE_MAX) {\n<149> fprintf(stderr, "qemu: could not load prom '%s'\n",\n<215> if (graphic_depth != 8 && graphic_depth != 24) {\n<217> fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth);\n<225> tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset,\n<231> if (nd_table[0].model == NULL)\n<233> nd_table[0].model = "lance";\n<235> if (strcmp(nd_table[0].model, "lance") == 0) {\n<237> lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);\n<239> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<241> fprintf(stderr, "qemu: Supported NICs: lance\n");\n<243> exit (1);\n<247> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<249> exit (1);\n<293> if (hwdef->fd_base) {\n<297> memset(fd, 0, sizeof(fd));\n<307> sun4m_fdctrl_init(slavio_irq[hwdef->fd_irq], hwdef->fd_base, fd,\n<315> if (drive_get_max_bus(IF_SCSI) > 0) {\n<317> fprintf(stderr, "qemu: too many SCSI bus\n");
<1> static int create_dynamic_disk(int fd, uint8_t *buf, int64_t total_sectors)\n<39> if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n<49> if (lseek(fd, 3 * 512, SEEK_SET) < 0) {\n<57> memset(buf, 0xFF, 512);\n<59> for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {\n<61> if (write(fd, buf, 512) != 512) {\n<73> memset(buf, 0, 1024);\n<77> memcpy(dyndisk_header->magic, "cxsparse", 8);\n<101> dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));
<1> iscsi_aio_readv(BlockDriverState *bs, int64_t sector_num,\n<39> trace_iscsi_aio_readv(iscsi, sector_num, nb_sectors, opaque, acb);\n<91> acb->task = malloc(sizeof(struct scsi_task));\n<93> if (acb->task == NULL) {\n<105> memset(acb->task, 0, sizeof(struct scsi_task));\n<149> ret = iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,
<1> static char *assign_name(NetClientState *nc1, const char *model)\n<15> if (nc == nc1) {\n<23> if (strcmp(nc->model, model) == 0 &&\n<25> net_hub_id_for_client(nc, NULL) == 0) {\n<27> id++;\n<35> snprintf(buf, sizeof(buf), "%s.%d", model, id);
<1> static void unpack_vectors(Vp3DecodeContext *s, GetBitContext *gb)\n<9> int motion_x[6];\n<11> int motion_y[6];\n<31> if (s->keyframe) {\n<43> memset(motion_x, 0, 6 * sizeof(int));\n<45> memset(motion_y, 0, 6 * sizeof(int));\n<81> switch (s->all_fragments[current_fragment].coding_method) {\n<93> motion_x[0] = get_motion_vector_vlc(gb);\n<95> motion_y[0] = get_motion_vector_vlc(gb);\n<99> motion_x[0] = get_motion_vector_fixed(gb);\n<101> motion_y[0] = get_motion_vector_fixed(gb);\n<107> motion_x[k] = motion_x[0];\n<109> motion_y[k] = motion_y[0];\n<125> last_motion_x = motion_x[0];\n<127> last_motion_y = motion_y[0];\n<147> motion_x[k] = get_motion_vector_vlc(gb);\n<149> motion_y[k] = get_motion_vector_vlc(gb);\n<153> motion_x[k] = get_motion_vector_fixed(gb);\n<155> motion_y[k] = get_motion_vector_fixed(gb);\n<159> motion_x[4] += motion_x[k];\n<161> motion_y[4] += motion_y[k];\n<167> if (motion_x[4] >= 0)\n<169> motion_x[4] = (motion_x[4] + 2) / 4;\n<173> motion_x[4] = (motion_x[4] - 2) / 4;\n<175> motion_x[5] = motion_x[4];\n<179> if (motion_y[4] >= 0)\n<181> motion_y[4] = (motion_y[4] + 2) / 4;\n<185> motion_y[4] = (motion_y[4] - 2) / 4;\n<187> motion_y[5] = motion_y[4];\n<199> last_motion_x = motion_x[3];\n<201> last_motion_y = motion_y[3];\n<211> motion_x[0] = last_motion_x;\n<213> motion_y[0] = last_motion_y;\n<217> motion_x[k] = motion_x[0];\n<219> motion_y[k] = motion_y[0];\n<239> motion_x[0] = prior_last_motion_x;\n<241> motion_y[0] = prior_last_motion_y;\n<245> motion_x[k] = motion_x[0];\n<247> motion_y[k] = motion_y[0];\n<259> last_motion_x = motion_x[0];\n<261> last_motion_y = motion_y[0];\n<271> memset(motion_x, 0, 6 * sizeof(int));\n<273> memset(motion_y, 0, 6 * sizeof(int));\n<305> s->all_fragments[current_fragment].motion_x = motion_x[k];\n<307> s->all_fragments[current_fragment].motion_y = motion_y[k];\n<309> debug_vectors("    vector %d: fragment %d = (%d, %d), index %d\n",
<1> GuestNetworkInterfaceList *qmp_guest_network_get_interfaces(Error **errp)\n<13> if (getifaddrs(&ifap) < 0) {\n<17> "getifaddrs failed: %s", strerror(errno));\n<61> info->value->name = g_strdup(ifa->ifa_name);\n<89> if (sock == -1) {\n<93> "failed to create socket: %s", strerror(errno));\n<103> memset(&ifr, 0, sizeof(ifr));\n<105> strncpy(ifr.ifr_name,  info->value->name, IF_NAMESIZE);\n<107> if (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1) {\n<115> strerror(errno));\n<125> mac_addr = (unsigned char *) &ifr.ifr_hwaddr.sa_data;\n<137> (int) mac_addr[4], (int) mac_addr[5]) == -1) {\n<139> snprintf(err_msg, sizeof(err_msg),\n<141> "failed to format MAC: %s", strerror(errno));\n<143> error_set(errp, QERR_QGA_COMMAND_FAILED, err_msg);\n<151> info->value->has_hardware_address = true;\n<153> close(sock);\n<159> if (ifa->ifa_addr &&\n<171> if (!inet_ntop(AF_INET, p, addr4, sizeof(addr4))) {\n<175> "inet_ntop failed : %s", strerror(errno));\n<215> if (!inet_ntop(AF_INET6, p, addr6, sizeof(addr6))) {\n<219> "inet_ntop failed : %s", strerror(errno));\n<309> freeifaddrs(ifap);\n<311> qapi_free_GuestNetworkInterfaceList(head);\n<313> return NULL;
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<75> if (refcount < 0) {\n<129> if (ret < 0) {\n<147> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> int64_t av_get_channel_layout(const char *name)\n<9> if (!strcmp(channel_layout_map[i].name, name))\n<11> return channel_layout_map[i].layout;\n<13> i++;\n<15> } while (channel_layout_map[i].name);
<1> static unsigned int dec_swap_r(DisasContext *dc)\n<15> swapmode_name(dc->op2, modename), dc->op1));\n<19> cris_cc_mask(dc, CC_MASK_NZ);\n<23> t_gen_mov_TN_reg(t0, dc->op1);
<1> static void truemotion1_decode_16bit(TrueMotion1Context *s)\n<45> memset(s->vert_pred, 0, s->avctx->width * sizeof(unsigned int));\n<63> vert_pred = s->vert_pred;
<1> void os_mem_prealloc(int fd, char *area, size_t memory)\n<13> memset(&act, 0, sizeof(act));\n<21> ret = sigaction(SIGBUS, &act, &oldact);\n<43> if (sigsetjmp(sigjump, 1)) {\n<45> fprintf(stderr, "os_mem_prealloc: Insufficient free host memory "\n<63> for (i = 0; i < numpages; i++) {\n<65> memset(area + (hpagesize * i), 0, 1);
<1> int ff_frame_thread_encoder_init(AVCodecContext *avctx, AVDictionary *options){\n<11> if(   !(avctx->thread_type & FF_THREAD_FRAME)\n<23> && !(avctx->flags & CODEC_FLAG_QSCALE)) {\n<39> && !(avctx->flags & CODEC_FLAG_QSCALE))\n<63> if (avctx->codec_id == AV_CODEC_ID_HUFFYUV ||\n<65> avctx->codec_id == AV_CODEC_ID_FFVHUFF) {\n<69> if (avctx->context_model > 0 || (avctx->flags & CODEC_FLAG_PASS1))\n<77> if(avctx->thread_count > MAX_THREADS)\n<123> AVCodecContext *thread_avctx = avcodec_alloc_context3(avctx->codec);\n<125> if(!thread_avctx)\n<129> tmpv = thread_avctx->priv_data;\n<133> thread_avctx->priv_data = tmpv;\n<137> memcpy(thread_avctx->priv_data, avctx->priv_data, avctx->codec->priv_data_size);\n<149> if(avcodec_open2(thread_avctx, avctx->codec, &tmp) < 0) {\n<163> if(pthread_create(&c->worker[i], NULL, worker, thread_avctx)) {\n<183> av_log(avctx, AV_LOG_ERROR, "ff_frame_thread_encoder_init failed\n");\n<185> ff_frame_thread_encoder_free(avctx);
<1> CPUState *cpu_copy(CPUState *env)\n<5> CPUState *new_env = cpu_init(env->cpu_model_str);\n<21> memcpy(new_env, env, sizeof(CPUState));\n<39> TAILQ_INIT(&env->breakpoints);\n<41> TAILQ_INIT(&env->watchpoints);\n<63> return new_env;
<1> static void joint_decode(COOKContext *q, float* mlt_buffer1,\n<3> float* mlt_buffer2) {\n<19> memset(decouple_tab, 0, sizeof(decouple_tab));\n<21> memset(decode_buffer, 0, sizeof(decode_buffer));\n<27> memset(mlt_buffer1,0, 1024*sizeof(float));\n<29> memset(mlt_buffer2,0, 1024*sizeof(float));\n<31> decouple_info(q, decouple_tab);\n<33> mono_decode(q, decode_buffer);
<1> static MachineClass *machine_parse(const char *name)\n<23> if (name && !is_help_option(name)) {\n<31> printf("Supported machines are:\n");\n<33> for (el = machines; el; el = el->next) {\n<35> MachineClass *mc = el->data;\n<37> if (mc->alias) {\n<39> printf("%-20s %s (alias of %s)\n", mc->alias, mc->desc, mc->name);
<1> int img_pad(AVPicture *dst, const AVPicture *src, int height, int width,\n<5> int *color)\n<35> if (padtop || padleft) {\n<39> dst->linesize[i] * (padtop >> y_shift) + (padleft >> x_shift));\n<47> if (src) { /* first line */\n<49> iptr = src->data[i];\n<51> optr = dst->data[i] + dst->linesize[i] * (padtop >> y_shift) +\n<55> memcpy(optr, iptr, src->linesize[i]);\n<57> iptr += src->linesize[i];\n<61> optr = dst->data[i] + dst->linesize[i] * (padtop >> y_shift) +\n<67> for (y = 0; y < yheight; y++) {\n<69> memset(optr, color[i], (padleft + padright) >> x_shift);\n<71> if (src) {\n<73> memcpy(optr + ((padleft + padright) >> x_shift), iptr,\n<77> iptr += src->linesize[i];\n<81> optr += dst->linesize[i];\n<89> if (padbottom || padright) {\n<97> (padbottom >> y_shift) + (padright >> x_shift));
<1> static int transcode_init(OutputFile *output_files,\n<21> char error[1024];\n<49> if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n<51> av_dump_format(os, i, os->filename, 1);\n<53> fprintf(stderr, "Output file #%d does not contain any stream\n", i);\n<75> codec = ost->st->codec;\n<77> icodec = ist->st->codec;\n<91> uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n<133> if (!codec->extradata) {\n<139> memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n<141> codec->extradata_size= icodec->extradata_size;\n<161> if(audio_volume != 256) {\n<163> fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");\n<311> if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n<313> fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");\n<343> if(avpicture_alloc((AVPicture*)&ost->pict_tmp, codec->pix_fmt,\n<347> fprintf(stderr, "Cannot allocate temp picture, check pix fmt\n");\n<369> if (ost->img_resample_ctx == NULL) {\n<371> fprintf(stderr, "Cannot get resampling context\n");\n<463> f = fopen(logfilename, "wb");\n<465> if (!f) {\n<467> fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));\n<481> if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n<483> fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);\n<501> bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 200);\n<511> bit_buffer = av_malloc(bit_buffer_size);\n<513> if (!bit_buffer) {\n<515> fprintf(stderr, "Cannot allocate %d bytes output buffer\n",\n<535> AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n<537> if (!codec) {\n<539> snprintf(error, sizeof(error), "Encoder (codec id %d) not found for output stream #%d.%d",\n<551> ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n<553> if (!ost->st->codec->subtitle_header) {\n<561> memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<563> ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n<567> if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n<569> snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",\n<579> assert_codec_experimental(ost->st->codec, 1);\n<601> if ((ret = init_input_stream(i, output_streams, nb_output_streams, error, sizeof(error))) < 0)\n<613> if (avformat_write_header(os, &output_files[i].opts) < 0) {\n<615> snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);\n<625> if (strcmp(os->oformat->name, "rtp")) {\n<627> want_sdp = 0;\n<651> if (verbose >= 0) {\n<653> fprintf(stderr, "Stream mapping:\n");\n<655> for (i = 0; i < nb_output_streams;i ++) {\n<657> ost = &output_streams[i];\n<669> if (ost->sync_ist != &input_streams[ost->source_index])\n<677> if (ost->st->stream_copy)\n<679> fprintf(stderr, " (copy)");\n<683> fprintf(stderr, " (%s -> %s)", input_streams[ost->source_index].dec ?\n<689> fprintf(stderr, "\n");\n<697> if (ret) {\n<699> fprintf(stderr, "%s\n", error);
<1> solisten(port, laddr, lport, flags)\n<45> if ((so->so_tcpcb = tcp_newtcpcb(so)) == NULL) {\n<47> free(so);
<1> void bt_device_done(struct bt_device_s *dev)\n<13> if (*p != dev) {\n<15> fprintf(stderr, "%s: bad bt device \"%s\"\n", __FUNCTION__,
<1> void smbios_entry_add(QemuOpts *opts)\n<171> val = qemu_opt_get(opts, "release");\n<173> if (val) {\n<175> if (sscanf(val, "%hhu.%hhu", &type0.major, &type0.minor) != 2) {\n<177> error_report("Invalid release");\n<179> exit(1);
<1> int rtp_packetize_xiph_config ( sout_stream_id_sys_t * id , const char * fmtp , int64_t i_pts ) {\n<2> if ( fmtp == NULL ) return VLC_EGENERIC ;\n<3> char * start = strstr ( fmtp , "configuration=" ) ;\n<4> assert ( start != NULL ) ;\n<9> size_t len = end - start ;\n<10> char b64 [ len + 1 ] ;\n<11> memcpy ( b64 , start , len ) ;\n<16> i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ;\n<17> if ( i_data <= 9 ) {\n<18> free ( p_orig ) ;\n<21> p_data = p_orig + 9 ;\n<25> i < i_count ;\n<41> rtp_packetize_common ( id , out , 0 , i_pts ) ;\n<42> SetDWBE ( out -> p_buffer + 12 , header ) ;\n<43> SetWBE ( out -> p_buffer + 16 , i_payload ) ;\n<44> memcpy ( & out -> p_buffer [ 18 ] , p_data , i_payload ) ;\n<46> rtp_packetize_send ( id , out ) ;\n<47> p_data += i_payload ;\n<48> i_data -= i_payload ;\n<50> free ( p_orig ) ;
<1> static void decorrelation(PSContext *ps, float (*out)[32][2], const float (*s)[32][2], int is34)\n<41> if (is34 != ps->is34bands_old) {\n<43> memset(ps->peak_decay_nrg,         0, sizeof(ps->peak_decay_nrg));\n<45> memset(ps->power_smooth,           0, sizeof(ps->power_smooth));\n<47> memset(ps->peak_decay_diff_smooth, 0, sizeof(ps->peak_decay_diff_smooth));\n<49> memset(ps->delay,                  0, sizeof(ps->delay));\n<51> memset(ps->ap_delay,               0, sizeof(ps->ap_delay));\n<57> for (n = n0; n < nL; n++) {\n<75> for (n = n0; n < nL; n++) {\n<115> for (k = 0; k < NR_ALLPASS_BANDS[is34]; k++) {\n<125> memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));\n<127> memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));\n<129> for (m = 0; m < PS_AP_LINKS; m++) {\n<131> memcpy(ap_delay[k][m],   ap_delay[k][m]+numQMFSlots,           5*sizeof(ap_delay[k][m][0]));\n<137> for (n = n0; n < nL; n++) {\n<183> for (; k < SHORT_DELAY_BAND[is34]; k++) {\n<185> memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));\n<187> memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));\n<189> for (n = n0; n < nL; n++) {\n<201> for (; k < NR_BANDS[is34]; k++) {\n<203> memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));\n<205> memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));\n<207> for (n = n0; n < nL; n++) {
<1> void cpu_physical_memory_write_rom(target_phys_addr_t addr,\n<3> const uint8_t *buf, int len)\n<25> if (l > len)\n<27> l = len;\n<49> ptr = qemu_get_ram_ptr(addr1);\n<51> memcpy(ptr, buf, l);\n<53> invalidate_and_set_dirty(addr1, l);\n<55> qemu_put_ram_ptr(ptr);\n<61> buf += l;
<1> void DefaultTTFEnglishNames ( struct ttflangname * dummy , SplineFont * sf ) {\n<4> char buffer [ 200 ] ;\n<7> if ( dummy -> names [ ttf_subfamily ] == NULL || * dummy -> names [ ttf_subfamily ] == '\0' ) dummy -> names [ ttf_subfamily ] = utf8_verify_copy ( SFGetModifiers ( sf ) ) ;\n<8> if ( dummy -> names [ ttf_uniqueid ] == NULL || * dummy -> names [ ttf_uniqueid ] == '\0' ) {\n<10> tm = localtime ( & now ) ;\n<11> sprintf ( buffer , "%s : %s : %d-%d-%d" , BDFFoundry ? BDFFoundry : TTFFoundry ? TTFFoundry : "FontForge 2.0" , sf -> fullname != NULL ? sf -> fullname : sf -> fontname , tm -> tm_mday , tm -> tm_mon + 1 , tm -> tm_year + 1900 ) ;\n<12> dummy -> names [ ttf_uniqueid ] = copy ( buffer ) ;\n<16> if ( sf -> subfontcnt != 0 ) sprintf ( buffer , "Version %f " , ( double ) sf -> cidversion ) ;\n<17> else if ( sf -> version != NULL ) sprintf ( buffer , "Version %.20s " , sf -> version ) ;\n<19> dummy -> names [ ttf_version ] = copy ( buffer ) ;
<1> static void sdl_resize(DisplayState *ds)\n<29> if (!real_screen) {\n<31> fprintf(stderr, "Could not open SDL display\n");\n<47> if (!real_screen->pixels) {\n<49> fprintf(stderr, "Could not open SDL display\n");
<1> BlockAIOCB *laio_submit(BlockDriverState *bs, LinuxAioState *s, int fd,\n<25> laiocb->is_read = (type == QEMU_AIO_READ);\n<35> switch (type) {\n<53> fprintf(stderr, "%s: invalid AIO request type 0x%x.\n",
<1> static void vnc_client_write(void *opaque)\n<39> if (!ret)\n<45> memmove(vs->output.buffer, vs->output.buffer + ret, (vs->output.offset - ret));
<1> static void an5206_init(QEMUMachineInitArgs *args)\n<79> if (!kernel_filename) {\n<81> fprintf(stderr, "Kernel image must be specified\n");\n<89> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<97> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n<103> kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR,\n<111> if (kernel_size < 0) {\n<113> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> static int readv_f(BlockBackend *blk, int argc, char **argv)\n<23> int pattern = 0;\n<29> while ((c = getopt(argc, argv, "CP:qv")) != EOF) {\n<45> if (pattern < 0) {\n<85> offset = cvtnum(argv[optind]);\n<87> if (offset < 0) {\n<89> printf("non-numeric length argument -- %s\n", argv[optind]);\n<113> buf = create_iovec(blk, &qiov, &argv[optind], nr_iov, 0xab);\n<115> if (buf == NULL) {\n<131> if (cnt < 0) {\n<133> printf("readv failed: %s\n", strerror(-cnt));\n<141> if (Pflag) {\n<143> void *cmp_buf = g_malloc(qiov.size);\n<145> memset(cmp_buf, pattern, qiov.size);\n<147> if (memcmp(buf, cmp_buf, qiov.size)) {\n<155> g_free(cmp_buf);\n<171> dump_buffer(buf, offset, qiov.size);\n<181> print_report("read", &t2, offset, qiov.size, total, cnt, Cflag);\n<187> qemu_iovec_destroy(&qiov);\n<189> qemu_io_free(buf);
<1> static void test_qemu_strtoull_underflow(void)\n<9> const char *endptr = &f;\n<17> err  = qemu_strtoull(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> static void test_hash_base64(void)\n<13> for (i = 0; i < G_N_ELEMENTS(expected_outputs) ; i++) {\n<25> strlen(INPUT_TEXT),
<1> static int16_t long_term_filter(DSPContext *dsp, int pitch_delay_int,\n<3> const int16_t* residual, int16_t *residual_filt,\n<75> tmp |= FFABS(residual[i]);\n<93> sig_scaled[i] = residual[i] >> shift;\n<99> sig_scaled[i] = residual[i] << -shift;\n<209> &sig_scaled[RES_PREV_DATA_SIZE - best_delay_int],\n<379> if (!gain_num) {\n<381> memcpy(residual_filt, residual + RES_PREV_DATA_SIZE, subframe_size * sizeof(int16_t));
<1> static int amovie_get_samples(AVFilterLink *outlink)\n<89> if (data_size < 0)\n<97> memcpy(movie->samplesref->data[0], movie->frame->data[0], data_size);
<1> static void mpeg_decode_picture_coding_extension(Mpeg1Context *s1)\n<5> MpegEncContext *s= &s1->mpeg_enc_ctx;\n<97> if(s->picture_structure == PICT_FRAME){\n<109> memset(s->mbskip_table, 0, s->mb_stride*s->mb_height);
<1> static void usage(void)\n<25> maxarglen = maxenvlen = 0;\n<29> for (arginfo = arg_table; arginfo->handle_opt != NULL; arginfo++) {\n<31> if (strlen(arginfo->env) > maxenvlen) {\n<33> maxenvlen = strlen(arginfo->env);\n<37> if (strlen(arginfo->argv) > maxarglen) {\n<39> maxarglen = strlen(arginfo->argv);\n<47> printf("%-*s%-*sDescription\n", maxarglen+3, "Argument",\n<49> maxenvlen+1, "Env-variable");\n<53> for (arginfo = arg_table; arginfo->handle_opt != NULL; arginfo++) {\n<55> if (arginfo->has_arg) {\n<59> (int)(maxarglen-strlen(arginfo->argv)), arginfo->example,\n<65> printf("-%-*s %-*s %s\n", maxarglen+1, arginfo->argv,
<1> void ff_mqc_init_contexts(MqcState *mqc)\n<7> memset(mqc->cx_states, 0, sizeof(mqc->cx_states));
<1> int udp_output2(struct socket *so, struct mbuf *m,\n<49> memset(&ui->ui_i.ih_mbuf, 0 , sizeof(struct mbuf_ptr));
<1> int ide_init_drive(IDEState *s, BlockDriverState *bs, IDEDriveKind kind,\n<3> const char *version, const char *serial)\n<69> bdrv_set_dev_ops(bs, &ide_cd_block_ops, s);\n<93> if (serial) {\n<95> strncpy(s->drive_serial_str, serial, sizeof(s->drive_serial_str));\n<117> ide_reset(s);
<1> static void nbd_parse_filename(const char *filename, QDict *options,\n<17> if (nbd_has_filename_options_conflict(options, errp)) {\n<25> if (strstr(filename, "://")) {\n<27> int ret = nbd_parse_uri(filename, options);\n<29> if (ret < 0) {\n<35> return;\n<41> file = g_strdup(filename);\n<45> export_name = strstr(file, EN_OPTSTR);\n<47> if (export_name) {\n<49> if (export_name[strlen(EN_OPTSTR)] == 0) {\n<55> export_name[0] = 0; /* truncate 'file' */\n<57> export_name += strlen(EN_OPTSTR);\n<61> qdict_put(options, "export", qstring_from_str(export_name));\n<69> if (!strstart(file, "nbd:", &host_spec)) {\n<125> g_free(file);
<1> static int wma_decode_superframe ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<5> WMACodecContext * s = avctx -> priv_data ;\n<20> init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n<42> if ( ( s -> last_superframe_len + ( ( bit_offset + 7 ) >> 3 ) ) > MAX_CODED_SUPERFRAME_SIZE ) goto fail ;\n<43> q = s -> last_superframe + s -> last_superframe_len ;\n<46> * q ++ = ( get_bits ) ( & s -> gb , 8 ) ;\n<50> * q ++ = ( get_bits ) ( & s -> gb , len ) << ( 8 - len ) ;\n<52> memset ( q , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<53> init_get_bits ( & s -> gb , s -> last_superframe , s -> last_superframe_len * 8 + bit_offset ) ;\n<55> if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n<68> if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n<74> len = buf_size - pos ;\n<75> if ( len > MAX_CODED_SUPERFRAME_SIZE || len < 0 ) {\n<80> memcpy ( s -> last_superframe , buf + pos , len ) ;
<1> static int fill_psinfo(struct target_elf_prpsinfo *psinfo, const TaskState *ts)\n<11> (void) memset(psinfo, 0, sizeof (*psinfo));\n<21> if (copy_from_user(&psinfo->pr_psargs, ts->info->arg_start, len))\n<49> filename = strdup(ts->bprm->filename);\n<51> base_filename = strdup(basename(filename));\n<53> (void) strncpy(psinfo->pr_fname, base_filename,\n<57> free(base_filename);\n<59> free(filename);
<1> static int ogg_buffer_data(AVFormatContext *s, AVStream *st,\n<15> uint8_t *p = data;\n<61> for (i = 0; i < total_segments; ) {\n<63> OGGPage *page = &oggstream->page;\n<67> segments = FFMIN(total_segments - i, 255 - page->segments_count);\n<71> if (i && !page->segments_count)\n<77> memset(page->segments+page->segments_count, 255, segments - 1);\n<85> page->segments[page->segments_count++] = len - (segments-1)*255;\n<87> memcpy(page->data+page->size, p, len);\n<89> p += len;\n<91> size -= len;\n<95> page->size += len;\n<123> (ogg->pref_size     > 0 && page->size   >= ogg->pref_size) ||
<1> static void tcx_rblit_writel(void *opaque, hwaddr addr,\n<7> TCXState *s = opaque;\n<25> len = ((val >> 24) & 0x1f) + 1;\n<27> if (adsr == 0xffffff) {\n<29> memset(&s->vram[addr], s->tmpblit, len);\n<33> val = s->tmpblit & 0xffffff;\n<37> for (i = 0; i < len; i++) {\n<49> memcpy(&s->vram[addr], &s->vram[adsr], len);\n<51> if (s->depth == 24) {\n<53> memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n<55> memcpy(&s->cplane[addr], &s->cplane[adsr], len * 4);\n<61> memory_region_set_dirty(&s->vram_mem, addr, len);
<1> static int cmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> CmvContext * s = avctx -> priv_data ;\n<17> if ( ff_get_buffer ( avctx , & s -> frame ) < 0 ) {\n<21> memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n<24> cmv_decode_inter ( s , buf + 2 , buf_end ) ;\n<31> cmv_decode_intra ( s , buf + 2 , buf_end ) ;
<1> static int mpc8_decode_frame(AVCodecContext * avctx, void *data,\n<11> MPCContext *c = avctx->priv_data;\n<45> if(keyframe){\n<47> memset(c->Q, 0, sizeof(c->Q));\n<347> ff_mpc_dequantize_and_synth(c, maxband - 1, c->frame.data[0],
<1> static int ape_decode_frame(AVCodecContext *avctx,\n<13> APEContext *s = avctx->priv_data;\n<107> if (!nblocks || nblocks > INT_MAX) {\n<119> memset(s->decoded0,  0, sizeof(s->decoded0));\n<121> memset(s->decoded1,  0, sizeof(s->decoded1));\n<127> if (init_frame_decoder(s) < 0) {\n<161> ape_unpack_mono(s, blockstodecode);\n<165> ape_unpack_stereo(s, blockstodecode);
<1> int rtp_check_and_send_back_rr(RTPDemuxContext *s, int count)\n<39> if (url_open_dyn_buf(&pb) < 0)\n<77> len = strlen(s->hostname);\n<79> put_be16(&pb, (6 + len + 3) / 4); /* length in words - 1 */\n<85> put_byte(&pb, len);\n<87> put_buffer(&pb, s->hostname, len);
<1> static int prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,\n<21> if (avc == NULL || !rtp_format) {\n<75> av_sdp_create(&avc, 1, *pbuffer, 2048);\n<91> return strlen(*pbuffer);
<1> static int parse_picture_segment(AVCodecContext *avctx,\n<27> buf += 3;\n<33> sequence_desc = bytestream_get_byte(&buf);\n<41> if (buf_size > ctx->picture.rle_remaining_len)\n<47> memcpy(ctx->picture.rle + ctx->picture.rle_data_len, buf, buf_size);\n<49> ctx->picture.rle_data_len += buf_size;\n<51> ctx->picture.rle_remaining_len -= buf_size;\n<65> buf_size -= 7;\n<71> rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n<77> width  = bytestream_get_be16(&buf);\n<79> height = bytestream_get_be16(&buf);\n<101> av_fast_malloc(&ctx->picture.rle, &ctx->picture.rle_buffer_size, rle_bitmap_len);\n<105> if (!ctx->picture.rle)\n<111> memcpy(ctx->picture.rle, buf, buf_size);\n<113> ctx->picture.rle_data_len = buf_size;\n<115> ctx->picture.rle_remaining_len = rle_bitmap_len - buf_size;
<1> void helper_tlb_update(uint32_t T0)\n<13> if (srs != 1 && srs != 2)\n<19> vaddr = cris_mmu_tlb_latest_update(env, T0);\n<21> D(printf("flush old_vaddr=%x vaddr=%x T0=%x\n", vaddr,\n<23> env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n<25> tlb_flush_page(env, vaddr);
<1> static void sd_blk_write(SDState *sd, uint64_t addr, uint32_t len)\n<9> if ((addr & 511) || len < 512)\n<11> if (!sd->bdrv || bdrv_read(sd->bdrv, addr >> 9, sd->buf, 1) < 0) {\n<13> fprintf(stderr, "sd_blk_write: read error on host side\n");\n<21> if (end > (addr & ~511) + 512) {\n<23> memcpy(sd->buf + (addr & 511), sd->data, 512 - (addr & 511));\n<25> if (bdrv_write(sd->bdrv, addr >> 9, sd->buf, 1) < 0) {\n<27> fprintf(stderr, "sd_blk_write: write error on host side\n");\n<35> if (bdrv_read(sd->bdrv, end >> 9, sd->buf, 1) < 0) {\n<37> fprintf(stderr, "sd_blk_write: read error on host side\n");\n<43> memcpy(sd->buf, sd->data + 512 - (addr & 511), end & 511);\n<45> if (bdrv_write(sd->bdrv, end >> 9, sd->buf, 1) < 0) {\n<47> fprintf(stderr, "sd_blk_write: write error on host side\n");\n<53> memcpy(sd->buf + (addr & 511), sd->data, len);\n<55> if (!sd->bdrv || bdrv_write(sd->bdrv, addr >> 9, sd->buf, 1) < 0) {\n<57> fprintf(stderr, "sd_blk_write: write error on host side\n");
<1> static void deinterlace_bottom_field_inplace(uint8_t *src1, int src_wrap,\n<13> buf = av_malloc(width);\n<17> src_m1 = src1;\n<19> memcpy(buf,src_m1,width);\n<21> src_0=&src_m1[src_wrap];\n<29> deinterlace_line_inplace(buf,src_m1,src_0,src_p1,src_p2,width);\n<43> deinterlace_line_inplace(buf,src_m1,src_0,src_0,src_0,width);
<1> kadm5_ret_t kadm5_get_policy ( void * server_handle , kadm5_policy_t name , kadm5_policy_ent_t entry ) {\n<5> memset ( entry , 0 , sizeof ( * entry ) ) ;\n<8> if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n<9> if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n<10> ret = krb5_db_get_policy ( handle -> context , name , & t ) ;\n<11> if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n<12> else if ( ret ) return ret ;\n<13> if ( ( entry -> policy = strdup ( t -> name ) ) == NULL ) {\n<14> ret = ENOMEM ;\n<17> entry -> pw_min_life = t -> pw_min_life ;\n<18> entry -> pw_max_life = t -> pw_max_life ;\n<19> entry -> pw_min_length = t -> pw_min_length ;\n<20> entry -> pw_min_classes = t -> pw_min_classes ;\n<21> entry -> pw_history_num = t -> pw_history_num ;\n<22> entry -> policy_refcnt = t -> policy_refcnt ;\n<23> if ( handle -> api_version >= KADM5_API_VERSION_3 ) {\n<28> if ( handle -> api_version >= KADM5_API_VERSION_4 ) {\n<32> if ( t -> allowed_keysalts ) {\n<33> entry -> allowed_keysalts = strdup ( t -> allowed_keysalts ) ;\n<34> if ( ! entry -> allowed_keysalts ) {\n<39> ret = copy_tl_data ( t -> n_tl_data , t -> tl_data , & entry -> tl_data ) ;\n<44> cleanup : if ( ret ) kadm5_free_policy_ent ( handle , entry ) ;\n<45> krb5_db_free_policy ( handle -> context , t ) ;
<1> static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) {\n<6> if ( len == 0 ) {\n<14> state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ;
<1> static void spapr_tce_reset(DeviceState *dev)\n<5> sPAPRTCETable *tcet = SPAPR_TCE_TABLE(dev);\n<7> size_t table_size = tcet->nb_table * sizeof(uint64_t);\n<13> memset(tcet->table, 0, table_size);
<1> static void suspend_request(BlockDriverState *bs, BlkdebugRule *rule)\n<27> printf("blkdebug: Suspended request '%s'\n", r.tag);\n<31> printf("blkdebug: Resuming request '%s'\n", r.tag);\n<35> QLIST_REMOVE(&r, next);\n<37> g_free(r.tag);
<1> int qemu_uuid_parse(const char *str, uint8_t *uuid)\n<9> if(strlen(str) != 36)\n<11> return -1;\n<15> ret = sscanf(str, UUID_FMT, &uuid[0], &uuid[1], &uuid[2], &uuid[3],\n<17> &uuid[4], &uuid[5], &uuid[6], &uuid[7], &uuid[8], &uuid[9],\n<19> &uuid[10], &uuid[11], &uuid[12], &uuid[13], &uuid[14], &uuid[15]);\n<23> if(ret != 16)
<1> static int vfio_container_do_ioctl(AddressSpace *as, int32_t groupid,\n<33> if (ret < 0) {\n<35> error_report("vfio: failed to ioctl %d to container: ret=%d, %s",\n<37> _IOC_NR(req) - VFIO_BASE, ret, strerror(errno));
<1> static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n<107> tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n<111> tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n<127> buf = (uint8_t *)pixman_image_get_data(linebuf);\n<133> if (color_type == PNG_COLOR_TYPE_PALETTE) {\n<135> memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n<139> qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n<143> png_write_row(png_ptr, buf);
<1> void cpu_loop(CPUS390XState *env)\n<17> cpu_exec_start(cs);\n<19> trapnr = cpu_s390x_exec(cs);\n<21> cpu_exec_end(cs);\n<23> switch (trapnr) {\n<73> n = env->int_pgm_code;\n<75> switch (n) {\n<189> fprintf(stderr, "Unhandled program exception: %#x\n", n);\n<191> cpu_dump_state(cs, stderr, fprintf, 0);\n<223> fprintf(stderr, "Unhandled trap: 0x%x\n", trapnr);\n<225> cpu_dump_state(cs, stderr, fprintf, 0);
<1> static void win32_rearm_timer(struct qemu_alarm_timer *t)\n<41> if (!data->timerId) {\n<43> fprintf(stderr, "Failed to re-arm win32 alarm timer %ld\n",
<1> static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n<27> switch (cmd = vmsvga_fifo_read(s)) {\n<313> if (len < 0) {\n<325> printf("%s: Unknown command 0x%02x in SVGA command FIFO\n",
<1> static void tosa_init(ram_addr_t ram_size, int vga_ram_size,\n<19> if (ram_size < (TOSA_RAM + TOSA_ROM + PXA2XX_INTERNAL_SIZE + TC6393XB_RAM)) {\n<21> fprintf(stderr, "This platform requires %i bytes of memory\n",
<1> static int decode_format80(VqaContext *s, int src_size,\n<3> unsigned char *dest, int dest_size, int check_size) {\n<71> } else if (opcode == 0xFE) {\n<79> av_dlog(s->avctx, "(2) set %X bytes to %02X\n", count, color);\n<83> memset(&dest[dest_index], color, count);\n<85> dest_index += count;\n<121> bytestream2_get_buffer(&s->gb, &dest[dest_index], count);
<1> static int load_input_picture(MpegEncContext *s, AVFrame *pic_arg){\n<147> int w= s->width >>h_shift;\n<151> uint8_t *src= pic_arg->data[i];\n<153> uint8_t *dst= pic->data[i];\n<159> dst +=INPLACE_OFFSET;\n<163> if(src_stride==dst_stride)\n<165> memcpy(dst, src, src_stride*h);\n<169> while(h--){\n<171> memcpy(dst, src, w);\n<173> dst += dst_stride;\n<175> src += src_stride;
<1> static int mov_read_stsd(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n<173> get_buffer(pb, codec_name, 32); /* codec name, pascal string */\n<175> if (codec_name[0] <= 31) {\n<177> memcpy(st->codec->codec_name, &codec_name[1],codec_name[0]);\n<179> st->codec->codec_name[codec_name[0]] = 0;
<1> static CharDriverState *qemu_chr_open_pty(const char *id,\n<23> if (master_fd < 0) {\n<45> ret->pty = g_strdup(pty_name);\n<51> fprintf(stderr, "char device redirected to %s (label %s)\n",
<1> static void vararg_string(void)\n<23> for (i = 0; test_cases[i].decoded; i++) {\n<31> obj = qobject_from_jsonf("%s", test_cases[i].decoded);\n<43> g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
<1> int ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries)\n<141> if (st->codec->codec_type==AVMEDIA_TYPE_VIDEO) {\n<187> mov_read_mac_string(c, pb, len, st->codec->codec_name, 32);\n<195> if (!memcmp(st->codec->codec_name, "Planar Y'CbCr 8-bit 4:2:0", 25))\n<197> st->codec->codec_tag=MKTAG('I', '4', '2', '0');
<1> static ssize_t test_block_read_func(QCryptoBlock *block,\n<3> size_t offset,\n<5> uint8_t *buf,\n<7> size_t buflen,\n<15> Buffer *header = opaque;\n<23> memcpy(buf, header->buffer + offset, buflen);\n<27> return buflen;
<1> static int opt_output_file(const char *opt, const char *filename)\n<17> if (!strcmp(filename, "-"))\n<19> filename = "pipe:";\n<23> err = avformat_alloc_output_context2(&oc, NULL, last_asked_format, filename);\n<29> print_error(filename, err);\n<35> file_oformat= oc->oformat;\n<39> if (!strcmp(file_oformat->name, "ffm") &&\n<41> av_strstart(filename, "http:", NULL)) {\n<47> int err = read_ffserver_streams(oc, filename);\n<49> if (err < 0) {\n<51> print_error(filename, err);\n<57> } else if (!nb_stream_maps) {\n<179> av_log(NULL, AV_LOG_ERROR, "Cannot map stream #%d.%d - unsupported type.\n",\n<245> if (!file_overwrite &&\n<247> (strchr(filename, ':') == NULL ||\n<249> filename[1] == ':' ||\n<251> av_strstart(filename, "file:", NULL))) {\n<253> if (avio_check(filename, 0) == 0) {\n<255> if (!using_stdin) {\n<257> fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", filename);\n<259> fflush(stderr);\n<261> if (!read_yesno()) {\n<263> fprintf(stderr, "Not overwriting - exiting\n");\n<273> fprintf(stderr,"File '%s' already exists. Exiting.\n", filename);\n<287> if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) {\n<307> av_log(NULL, AV_LOG_WARNING, "-loop_output is deprecated, use -loop\n");\n<337> av_log(NULL, AV_LOG_ERROR, "Invalid input file index %d in chapter mapping.\n",\n<369> av_log(NULL, AV_LOG_ERROR, "Invalid %s index %d while processing metadata maps\n",\
<1> static int bochs_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<15> if (block_offset >= 0) {\n<27> memset(buf, 0, 512);\n<33> buf += 512;
<1> static void smbios_build_type_1_table(void)\n<17> if (qemu_uuid_set) {\n<23> memset(&t->uuid, 0, 16);
<1> void EVP_EncodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n<5> if ( inl <= 0 ) return ;\n<7> if ( ( ctx -> num + inl ) < ctx -> length ) {\n<8> memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , inl ) ;\n<9> ctx -> num += inl ;\n<12> if ( ctx -> num != 0 ) {\n<13> i = ctx -> length - ctx -> num ;\n<14> memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , i ) ;\n<15> in += i ;\n<16> inl -= i ;\n<17> j = EVP_EncodeBlock ( out , ctx -> enc_data , ctx -> length ) ;\n<26> in += ctx -> length ;\n<33> if ( inl != 0 ) memcpy ( & ( ctx -> enc_data [ 0 ] ) , in , inl ) ;\n<34> ctx -> num = inl ;
<1> static void evhttp_handle_request ( struct evhttp_request * req , void * arg ) {\n<12> if ( http -> gencb ) {\n<21> free ( escaped_html ) ;
<1> static void cpu_openrisc_load_kernel(ram_addr_t ram_size,\n<49> if (kernel_size < 0) {\n<51> fprintf(stderr, "QEMU: couldn't load the kernel '%s'\n",
<1> static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb,\n<101> pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n<105> if (pal) {\n<107> memcpy(pal, s->palette, AVPALETTE_SIZE);
<1> static struct bt_device_s *bt_device_add(const char *opt)\n<9> char *endp = strstr(opt, ",vlan=");\n<11> int len = (endp ? endp - opt : strlen(opt)) + 1;\n<17> pstrcpy(devname, MIN(sizeof(devname), len), opt);\n<21> if (endp) {\n<25> if (*endp) {\n<27> fprintf(stderr, "qemu: unrecognised bluetooth vlan Id\n");\n<37> vlan = qemu_find_bt_vlan(vlan_id);\n<41> if (!vlan->slave)\n<43> fprintf(stderr, "qemu: warning: adding a slave device to "\n<49> if (!strcmp(devname, "keyboard"))\n<51> return bt_keyboard_init(vlan);\n<55> fprintf(stderr, "qemu: unsupported bluetooth device `%s'\n", devname);\n<57> return 0;
<1> static inline void memcpy_tofs(void * to, const void * from, unsigned long n)\n<5> memcpy(to, from, n);
<1> static int tmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<14> if ( avpkt -> size < 2 * char_rows * char_cols ) {\n<23> memcpy ( tmv -> pic . data [ 1 ] , ff_cga_palette , 16 * 4 ) ;
<1> ParseResult mime_parser_parse ( MIMEParser * parser , HdrHeap * heap , MIMEHdrImpl * mh , const char * * real_s , const char * real_e , bool must_copy_strings , bool eof ) {\n<31> if ( ( ! ParseRules : : is_token ( * field_name_first ) ) && ( * field_name_first != '@' ) ) {\n<34> colon = ( char * ) memchr ( line_c , ':' , ( line_e - line_c ) ) ;\n<35> if ( ! colon ) {
<1> static void smc91c111_receive(void *opaque, const uint8_t *buf, size_t size)\n<51> if (packetnum == 0x80)\n<79> *(p++) = packetsize >> 8;\n<81> memcpy(p, buf, size & ~1);\n<83> p += (size & ~1);\n<87> if (size < 64) {\n<95> *(p++) = buf[size - 1];\n<97> pad = 64 - size;\n<99> memset(p, 0, pad);\n<101> p += pad;\n<117> crc = crc32(~0, buf, size);\n<131> *(p++) = buf[size - 1];
<1> char *qemu_find_file(int type, const char *name)\n<15> if ((strchr(name, '/') || strchr(name, '\\'))\n<17> && access(name, R_OK) == 0) {\n<19> return g_strdup(name);\n<23> switch (type) {\n<27> subdir = "";\n<33> subdir = "keymaps/";\n<43> len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n<45> buf = g_malloc0(len);\n<47> snprintf(buf, len, "%s/%s%s", data_dir, subdir, name);\n<49> if (access(buf, R_OK)) {
<1> static void vc1_decode_i_blocks_adv ( VC1Context * v ) {\n<30> if ( s -> start_mb_y ) {\n<33> memset ( & s -> coded_block [ s -> block_index [ 0 ] - s -> b8_stride ] , 0 , ( 1 + s -> b8_stride ) * sizeof ( * s -> coded_block ) ) ;
<1> static int gdev_pdf_put_params_impl ( gx_device * dev , const gx_device_pdf * save_dev , gs_param_list * plist ) {\n<3> gx_device_pdf * pdev = ( gx_device_pdf * ) dev ;\n<7> pdev -> pdf_memory = gs_memory_stable ( pdev -> memory ) ;\n<84> code = gs_param_read_items ( plist , pdev , pdf_param_items ) ;\n<87> if ( code == 0 && ! pdev -> is_ps2write && ! ( locked && pdev -> params . LockDistillerParams ) ) pdev -> ForOPDFRead = ForOPDFRead ;\n<93> if ( fon != save_dev -> FirstObjectNumber ) {\n<94> if ( fon <= 0 || fon > 0x7fff0000 || ( pdev -> next_id != 0 && pdev -> next_id != save_dev -> FirstObjectNumber + pdf_num_initial_ids ) ) {\n<107> pdf_set_process_color_model ( pdev , pcm ) ;\n<109> pdev -> icc_struct = 0 ;\n<113> if ( pdev -> is_ps2write && ( code = param_read_bool ( plist , "ProduceDSC" , & pdev -> ProduceDSC ) ) < 0 ) {\n<116> if ( pdev -> PDFA < 0 || pdev -> PDFA > 3 ) {\n<121> if ( pdev -> PDFA != 0 && pdev -> AbortPDFAX ) pdev -> PDFA = 0 ;\n<122> if ( pdev -> PDFX && pdev -> AbortPDFAX ) pdev -> PDFX = 0 ;\n<123> if ( pdev -> PDFX && pdev -> PDFA != 0 ) {\n<128> if ( pdev -> PDFX && pdev -> ForOPDFRead ) {\n<133> if ( pdev -> PDFA != 0 && pdev -> ForOPDFRead ) {\n<138> if ( pdev -> PDFA == 1 || pdev -> PDFX || pdev -> CompatibilityLevel < 1.4 ) {\n<139> pdev -> HaveTransparency = false ;\n<140> pdev -> PreserveSMask = false ;\n<143> if ( pdev -> PDFA != 0 && cl < 1.4 ) cl = ( float ) 1.4 ;\n<146> pdev -> ResourcesBeforeUsage = true ;\n<147> pdev -> HaveCFF = false ;\n<148> pdev -> HavePDFWidths = false ;\n<149> pdev -> HaveStrokeColor = false ;\n<151> pdev -> MaxInlineImageSize = max_long ;\n<155> pdev -> ResourcesBeforeUsage = false ;\n<156> pdev -> HaveCFF = true ;\n<157> pdev -> HavePDFWidths = true ;\n<158> pdev -> HaveStrokeColor = true ;\n<160> pdev -> ParamCompatibilityLevel = cl ;\n<162> pdev -> HaveCFF = false ;\n<166> if ( pdev -> CompatibilityLevel > 1.7 && pdev -> params . TransferFunctionInfo == tfi_Preserve ) {\n<168> emprintf ( pdev -> memory , "\nIt is not possible to preserve transfer functions in PDF 2.0\ntransfer functions will be applied instead\n" ) ;\n<172> emprintf ( pdev -> memory , "ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\n" ) ;\n<176> emprintf ( pdev -> memory , "ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\n" ) ;\n<179> if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , "reset default profile\n" ) ;\n<191> if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , "reset default profile\n" ) ;\n<197> if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , "reset default profile\n" ) ;\n<204> if ( pdev -> icc_struct ) rc_decrement ( pdev -> icc_struct , "reset default profile\n" ) ;\n<212> if ( cl < 1.5f && pdev -> params . ColorImage . Filter != NULL && ! strcmp ( pdev -> params . ColorImage . Filter , "JPXEncode" ) ) {\n<213> emprintf ( pdev -> memory , "JPXEncode requires CompatibilityLevel >= 1.5 .\n" ) ;\n<216> if ( cl < 1.5f && pdev -> params . GrayImage . Filter != NULL && ! strcmp ( pdev -> params . GrayImage . Filter , "JPXEncode" ) ) {\n<217> emprintf ( pdev -> memory , "JPXEncode requires CompatibilityLevel >= 1.5 .\n" ) ;\n<220> if ( cl < 1.4f && pdev -> params . MonoImage . Filter != NULL && ! strcmp ( pdev -> params . MonoImage . Filter , "JBIG2Encode" ) ) {\n<221> emprintf ( pdev -> memory , "JBIG2Encode requires CompatibilityLevel >= 1.4 .\n" ) ;\n<224> if ( pdev -> HaveTrueTypes && pdev -> version == psdf_version_level2 ) {\n<228> if ( pdev -> FirstObjectNumber != save_dev -> FirstObjectNumber ) {\n<238> if ( pdev -> OwnerPassword . size != save_dev -> OwnerPassword . size || ( pdev -> OwnerPassword . size != 0 && memcmp ( pdev -> OwnerPassword . data , save_dev -> OwnerPassword . data , pdev -> OwnerPassword . size ) != 0 ) ) {\n<251> if ( pdev -> Linearise && pdev -> OwnerPassword . size != 0 ) {\n<257> fail : pdev -> version = save_dev -> version ;\n<258> pdf_set_process_color_model ( pdev , save_dev -> pcm_color_info_index ) ;\n<259> pdev -> saved_fill_color = save_dev -> saved_fill_color ;\n<260> pdev -> saved_stroke_color = save_dev -> saved_fill_color ;\n<262> const gs_param_item_t * ppi = pdf_param_items ;\n<264> ppi -> key ;\n<265> ++ ppi ) memcpy ( ( char * ) pdev + ppi -> offset , ( char * ) save_dev + ppi -> offset , gs_param_type_sizes [ ppi -> type ] ) ;
<1> static int qcow_set_key(BlockDriverState *bs, const char *key)\n<7> uint8_t keybuf[16];\n<15> memset(keybuf, 0, 16);\n<17> len = strlen(key);\n<19> if (len > 16)\n<29> keybuf[i] = key[i];\n<45> keybuf, G_N_ELEMENTS(keybuf),
<1> void arm_gen_test_cc(int cc, int label)\n<11> switch (cc) {\n<139> fprintf(stderr, "Bad condition code 0x%x\n", cc);
<1> void bdrv_img_create(const char *filename, const char *fmt,\n<27> drv = bdrv_find_format(fmt);\n<39> proto_drv = bdrv_find_protocol(filename);\n<125> if (backing_file && backing_file->value.s) {\n<127> if (!strcmp(filename, backing_file->value.s)) {\n<129> error_setg(errp, "Error: Trying to create an image with the "\n<141> backing_fmt = get_option_parameter(param, BLOCK_OPT_BACKING_FMT);\n<143> if (backing_fmt && backing_fmt->value.s) {\n<169> if (backing_file && backing_file->value.s) {\n<227> if (!quiet) {\n<229> printf("Formatting '%s', fmt=%s ", filename, fmt);\n<237> ret = bdrv_create(drv, filename, param);\n<243> error_setg(errp,"Formatting or formatting option not supported for "\n<247> } else if (ret == -EFBIG) {\n<249> error_setg(errp, "The image size is too large for file format '%s'",\n<255> error_setg(errp, "%s: error while creating %s: %s", filename, fmt,\n<257> strerror(-ret));
<1> static void opt_target(const char *arg)\n<15> arg += 4;\n<21> arg += 5;\n<23> } else if(!strncmp(arg, "film-", 5)) {\n<27> arg += 5;\n<91> if(verbose && norm != UNKNOWN)\n<93> fprintf(stderr, "Assuming %s for target.\n", norm == PAL ? "PAL" : "NTSC");\n<99> if(norm == UNKNOWN) {\n<101> fprintf(stderr, "Could not determine norm (PAL/NTSC/NTSC-Film) for target.\n");\n<103> fprintf(stderr, "Please prefix target with \"pal-\", \"ntsc-\" or \"film-\",\n");\n<105> fprintf(stderr, "or set a framerate with \"-r xxx\".\n");\n<113> if(!strcmp(arg, "vcd")) {\n<117> opt_video_codec("mpeg1video");\n<119> opt_audio_codec("mp2");\n<121> opt_format("vcd");\n<125> opt_frame_size(norm == PAL ? "352x288" : "352x240");\n<127> opt_frame_rate(NULL, frame_rates[norm]);\n<129> opt_default("g", norm == PAL ? "15" : "18");\n<133> opt_default("b", "1150000");\n<135> opt_default("maxrate", "1150000");\n<137> opt_default("minrate", "1150000");\n<139> opt_default("bufsize", "327680"); // 40*1024*8;\n<143> opt_default("ab", "224000");\n<145> audio_sample_rate = 44100;\n<147> audio_channels = 2;\n<151> opt_default("packetsize", "2324");\n<153> opt_default("muxrate", "1411200"); // 2352 * 75 * 8;\n<167> mux_preload= (36000+3*1200) / 90000.0; //0.44\n<169> } else if(!strcmp(arg, "svcd")) {\n<173> opt_video_codec("mpeg2video");\n<175> opt_audio_codec("mp2");\n<177> opt_format("svcd");\n<181> opt_frame_size(norm == PAL ? "480x576" : "480x480");\n<183> opt_frame_rate(NULL, frame_rates[norm]);\n<185> opt_default("g", norm == PAL ? "15" : "18");\n<189> opt_default("b", "2040000");\n<191> opt_default("maxrate", "2516000");\n<193> opt_default("minrate", "0"); //1145000;\n<195> opt_default("bufsize", "1835008"); //224*1024*8;\n<197> opt_default("flags", "+scan_offset");\n<203> opt_default("ab", "224000");\n<205> audio_sample_rate = 44100;\n<209> opt_default("packetsize", "2324");\n<213> } else if(!strcmp(arg, "dvd")) {\n<217> opt_video_codec("mpeg2video");\n<219> opt_audio_codec("ac3");\n<221> opt_format("dvd");\n<225> opt_frame_size(norm == PAL ? "720x576" : "720x480");\n<227> opt_frame_rate(NULL, frame_rates[norm]);\n<229> opt_default("g", norm == PAL ? "15" : "18");\n<233> opt_default("b", "6000000");\n<235> opt_default("maxrate", "9000000");\n<237> opt_default("minrate", "0"); //1500000;\n<239> opt_default("bufsize", "1835008"); //224*1024*8;\n<243> opt_default("packetsize", "2048");  // from www.mpucoder.com: DVD sectors contain 2048 bytes of data, this is also the size of one pack.\n<245> opt_default("muxrate", "10080000"); // from mplex project: data_rate = 1260000. mux_rate = data_rate * 8\n<249> opt_default("ab", "448000");\n<251> audio_sample_rate = 48000;\n<255> } else if(!strncmp(arg, "dv", 2)) {\n<281> fprintf(stderr, "Unknown target: %s\n", arg);
<1> static int analyze(const uint8_t *buf, int size, int packet_size,\n<7> int stat[TS_MAX_PACKET_SIZE];\n<17> memset(stat, 0, packet_size * sizeof(*stat));\n<29> stat[x]++;\n<33> if (stat[x] > best_score) {\n<35> best_score = stat[x];
<1> static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {\n<5> protocol = strsep ( & line , " " ) ;\n<8> if ( line == NULL ) return ( - 1 ) ;\n<9> readable = line ;\n<10> if ( strcmp ( protocol , "HTTP/1.0" ) == 0 ) {\n<11> req -> major = 1 ;\n<12> req -> minor = 0 ;\n<14> else if ( strcmp ( protocol , "HTTP/1.1" ) == 0 ) {\n<15> req -> major = 1 ;\n<16> req -> minor = 1 ;\n<19> event_debug ( ( "%s: bad protocol \"%s\"" , __func__ , protocol ) ) ;\n<20> return ( - 1 ) ;\n<22> req -> response_code = atoi ( number ) ;\n<23> if ( ! evhttp_valid_response_code ( req -> response_code ) ) {\n<27> if ( ( req -> response_code_line = strdup ( readable ) ) == NULL ) event_err ( 1 , "%s: strdup" , __func__ ) ;
<1> static int nut_probe(AVProbeData *p) {\n<3> if (p->buf_size >= ID_LENGTH && !memcmp(p->buf, ID_STRING, ID_LENGTH)) return AVPROBE_SCORE_MAX;\n<7> return 0;
<1> int qdev_prop_parse(DeviceState *dev, const char *name, const char *value)\n<11> prop = qdev_prop_find(dev, name);\n<13> if (!prop) {\n<15> fprintf(stderr, "property \"%s.%s\" not found\n",\n<23> if (!prop->info->parse) {\n<25> fprintf(stderr, "property \"%s.%s\" has no parser\n",\n<33> ret = prop->info->parse(dev, prop, value);\n<37> switch (ret) {\n<41> fprintf(stderr, "property \"%s.%s\": \"%s\" is already in use\n",\n<51> fprintf(stderr, "property \"%s.%s\": failed to parse \"%s\"\n",\n<59> fprintf(stderr, "property \"%s.%s\": could not find \"%s\"\n",
<1> static void usbredir_bulk_packet(void *priv, uint32_t id,\n<5> uint8_t *data, int data_len)\n<27> if (!aurb) {\n<29> free(data);\n<55> usbredir_log_data(dev, "bulk data in:", data, data_len);\n<59> usb_packet_copy(aurb->packet, data, data_len);\n<81> free(data);
<1> static int convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst, int max_size)\n<5> switch (AV_RB32(src)) {\n<11> memcpy(dst, src, src_size);\n<13> return src_size;
<1> static void v9fs_create(void *opaque)\n<157> } else if (perm & P9_STAT_MODE_DEVICE) {\n<167> if (sscanf(extension.data, "%c %u %u", &ctype, &major, &minor) != 3) {\n<169> err = -errno;\n<177> switch (ctype) {\n<205> makedev(major, minor), nmode, &stbuf);\n<321> v9fs_string_free(&extension);
<1> static int usb_host_read_file(char *line, size_t line_size, const char *device_file, const char *device_name)\n<15> f = fopen(filename, "r");\n<17> if (f) {\n<19> fgets(line, line_size, f);\n<21> fclose(f);
<1> void term_printf(const char *fmt, ...)\n<9> va_start(ap, fmt);\n<11> vsnprintf(buf, sizeof(buf), fmt, ap);\n<13> qemu_chr_write(monitor_hd, buf, strlen(buf));\n<15> va_end(ap);
<1> static NetSocketState *net_socket_fd_init_dgram(NetClientState *peer,\n<35> if (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n<39> if (saddr.sin_addr.s_addr == 0) {\n<41> fprintf(stderr, "qemu: error: init_dgram: fd=%d unbound, "\n<75> fd, strerror(errno));\n<129> closesocket(fd);
<1> static void predictor_decompress_fir_adapt(int32_t *error_buffer,\n<3> int32_t *buffer_out,\n<29> if (output_size <= 1)\n<37> (output_size - 1) * sizeof(*buffer_out));
<1> static void omap_pwt_write(void *opaque, hwaddr addr,\n<35> if (value & 1)\n<37> printf("%s: %iHz buzz on\n", __FUNCTION__, (int)\n<71> printf("%s: silence!\n", __FUNCTION__);
<1> static int mpegps_read_header(AVFormatContext *s,\n<23> if ((p=memchr(buffer, 'S', sizeof(buffer))))\n<25> if (!memcmp(p, "Sofdec", 6))\n<27> m->sofdec = 1;
<1> static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) {\n<48> if ( ! img ) {\n<49> img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;\n<50> if ( ! img ) goto fail ;\n<54> memset ( img , 0 , sizeof ( vpx_image_t ) ) ;\n<61> if ( ! img -> img_data ) goto fail ;\n<71> if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ;\n<72> fail : vpx_img_free ( img ) ;
<1> static unsigned int dec_rfe_etc(DisasContext *dc)\n<5> cris_cc_mask(dc, 0);\n<15> switch (dc->op2 & 7) {\n<21> DIS(fprintf(logfile, "rfe\n"));\n<35> DIS(fprintf(logfile, "rfn\n"));\n<47> DIS(fprintf(logfile, "break %d\n", dc->op1));\n<49> cris_evaluate_flags (dc);\n<61> tcg_const_tl(dc->op1 + 16));\n<71> printf ("op2=%x\n", dc->op2);
<1> int ff_asf_parse_packet(AVFormatContext *s, ByteIOContext *pb, AVPacket *pkt)\n<83> asf_st = asf->asf_st;\n<239> for(i=0; i<asf_st->pkt.size && !asf_st->pkt.data[i]; i++);\n<269> uint8_t *newdata = av_malloc(asf_st->pkt.size);\n<275> while (offset < asf_st->pkt.size) {\n<277> int off = offset / asf_st->ds_chunk_size;\n<295> asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n<299> offset += asf_st->ds_chunk_size;
<1> void spapr_tce_reset(DMAContext *dma)\n<5> if (dma) {\n<7> sPAPRTCETable *tcet = DO_UPCAST(sPAPRTCETable, dma, dma);\n<9> size_t table_size = (tcet->window_size >> SPAPR_TCE_PAGE_SHIFT)\n<15> memset(tcet->table, 0, table_size);
<1> int ff_aac_ac3_parse(AVCodecParserContext *s1,\n<11> AACAC3ParseContext *s = s1->priv_data;\n<25> buf_ptr = buf;\n<31> len = s->inbuf_ptr - s->inbuf;\n<35> if(len<size_needed){\n<37> len = FFMIN(size_needed - len, buf_size);\n<39> memcpy(s->inbuf_ptr, buf_ptr, len);\n<41> buf_ptr      += len;\n<43> s->inbuf_ptr += len;\n<45> buf_size     -= len;\n<55> len = s->sync(s->inbuf, &channels, &sample_rate, &bit_rate,\n<59> if (len == 0) {\n<63> memmove(s->inbuf, s->inbuf + 1, s->header_size - 1);
<1> void kvm_arm_reset_vcpu(ARMCPU *cpu)\n<7> memmove(cpu->cpreg_values, cpu->cpreg_reset_values,\n<9> cpu->cpreg_array_len * sizeof(cpu->cpreg_values[0]));\n<13> if (!write_list_to_kvmstate(cpu)) {
<1> int postcopy_ram_enable_notify(MigrationIncomingState *mis)\n<9> if (mis->userfault_fd == -1) {\n<11> error_report("%s: Failed to open userfault fd: %s", __func__,\n<13> strerror(errno));\n<41> if (mis->userfault_quit_fd == -1) {\n<43> error_report("%s: Opening userfault_quit_fd: %s", __func__,\n<45> strerror(errno));
<1> int event_base_priority_init ( struct event_base * base , int npriorities ) {\n<3> if ( base -> event_count_active ) return ( - 1 ) ;\n<4> if ( base -> nactivequeues && npriorities != base -> nactivequeues ) {\n<6> i < base -> nactivequeues ;\n<8> free ( base -> activequeues [ i ] ) ;\n<10> free ( base -> activequeues ) ;\n<12> base -> nactivequeues = npriorities ;\n<13> base -> activequeues = ( struct event_list * * ) calloc ( base -> nactivequeues , sizeof ( struct event_list * ) ) ;\n<14> if ( base -> activequeues == NULL ) event_err ( 1 , "%s: calloc" , __func__ ) ;\n<16> i < base -> nactivequeues ;\n<18> base -> activequeues [ i ] = malloc ( sizeof ( struct event_list ) ) ;\n<19> if ( base -> activequeues [ i ] == NULL ) event_err ( 1 , "%s: malloc" , __func__ ) ;
<1> static int mxf_read_local_tags(MXFContext *mxf, KLVPacket *klv, int (*read_child)(), int ctx_size, enum MXFMetadataSetType type)\n<45> if (local_tag == tag) {\n<47> memcpy(uid, mxf->local_tags+i*18+2, 16);\n<69> read_child(ctx, pb, tag, size, uid);
<1> static inline direntry_t* create_short_and_long_name(BDRVVVFATState* s,\n<3> unsigned int directory_start, const char* filename, int is_dot)\n<15> if(is_dot) {\n<17> entry=array_get_next(&(s->directory));\n<19> memset(entry->name,0x20,11);\n<21> memcpy(entry->name,filename,strlen(filename));\n<23> return entry;\n<29> entry_long=create_long_filename(s,filename);\n<33> i = strlen(filename);\n<35> for(j = i - 1; j>0  && filename[j]!='.';j--);\n<39> i = (j > 8 ? 8 : j);\n<41> else if (i > 8)\n<43> i = 8;\n<47> entry=array_get_next(&(s->directory));\n<49> memset(entry->name,0x20,11);\n<51> memcpy(entry->name, filename, i);\n<57> for (i = 0; i < 3 && filename[j+1+i]; i++)\n<59> entry->extension[i] = filename[j+1+i];\n<69> if(entry->name[i]<=' ' || entry->name[i]>0x7f\n<71> || strchr(".*?<>|\":/\\[];,+='",entry->name[i]))\n<73> entry->name[i]='_';\n<75> else if(entry->name[i]>='a' && entry->name[i]<='z')\n<77> entry->name[i]+='A'-'a';\n<93> for(;entry1<entry;entry1++)\n<95> if(!is_long_name(entry1) && !memcmp(entry1->name,entry->name,11))\n<99> if(entry1==entry) /* no dupe found */\n<107> if(entry->name[7]==' ') {\n<111> for(j=6;j>0 && entry->name[j]==' ';j--)\n<113> entry->name[j]='~';\n<121> for(j=7;j>0 && entry->name[j]=='9';j--)\n<123> entry->name[j]='0';\n<129> entry->name[j]='0';\n<133> entry->name[j]++;\n<145> uint8_t chksum=fat_chksum(entry);\n<153> while(entry_long<entry && is_long_name(entry_long)) {\n<165> return entry;
<1> static void vexpress_a9_init(ram_addr_t ram_size,\n<59> if (!env) {\n<61> fprintf(stderr, "Unable to find CPU definition\n");\n<75> if (ram_size > 0x40000000) {\n<79> fprintf(stderr, "vexpress: cannot model more than 1GB RAM\n");
<1> static int mpc8_decode_init(AVCodecContext * avctx)\n<7> MPCContext *c = avctx->priv_data;\n<15> if(avctx->extradata_size < 2){\n<23> memset(c->oldDSCF, 0, sizeof(c->oldDSCF));
<1> void ff_er_frame_end(MpegEncContext *s){\n<35> pic->ref_index[i]= av_mallocz(size * sizeof(uint8_t));\n<53> if(pic->ref_index[i])\n<55> memset(pic->ref_index[i], 0, size * sizeof(uint8_t));
<1> static void sun4uv_init(ram_addr_t RAM_size,\n<59> if (!env) {\n<61> fprintf(stderr, "Unable to find Sparc CPU definition\n");\n<133> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<159> if (ret < 0) {\n<161> fprintf(stderr, "qemu: could not load prom '%s'\n",\n<179> kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL);\n<195> if (kernel_size < 0) {\n<197> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<217> if (initrd_size < 0) {\n<219> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<313> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<315> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n<73> if (r->req.cmd.buf[2] != 0) {\n<83> r->len = MIN(r->req.cmd.xfer, SCSI_INQUIRY_LEN);\n<85> memset(r->buf, 0, r->len);\n<87> if (r->req.lun != 0) {\n<99> r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n<103> memcpy(&r->buf[8], "QEMU    ", 8);\n<105> memcpy(&r->buf[16], "QEMU TARGET     ", 16);\n<107> pstrcpy((char *) &r->buf[32], 4, qemu_get_version());
<1> static int parse_bootdevices(char *devices)\n<33> if (*p < 'a' || *p > 'p') {\n<35> fprintf(stderr, "Invalid boot device '%c'\n", *p);\n<41> if (bitmap & (1 << (*p - 'a'))) {\n<43> fprintf(stderr, "Boot device '%c' was given twice\n", *p);\n<49> bitmap |= 1 << (*p - 'a');
<1> static int encode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3])\n<23> memset(s->sample_buffer, 0, ring_size * MAX_PLANES *\n<35> sample[p][i]= s->sample_buffer + p*ring_size*(w+6) + ((h+i-y)%ring_size)*(w+6) + 3;\n<99> ret = encode_line(s, w, sample[p], (p + 1) / 2, 9);\n<103> ret = encode_line(s, w, sample[p], (p + 1) / 2, bits + 1);
<1> static int dca_subframe_header(DCAContext *s, int base_channel, int block_index)\n<135> for (j = base_channel; j < s->prim_channels; j++) {\n<145> s->subband_activity[j] * sizeof(s->scale_factor[0][0][0]) * 2);
<1> static inline void mix_3f_2r_to_dolby(AC3DecodeContext *ctx)\n<13> output[1][i] += (output[2][i] - output[4][i] - output[5][i]);\n<19> memset(output[3], 0, sizeof(output[3]));\n<21> memset(output[4], 0, sizeof(output[4]));\n<23> memset(output[5], 0, sizeof(output[5]));
<1> static void restore_native_fp_fxrstor(CPUState *env)\n<5> struct fpxstate *fp = &fpx1;\n<27> for(i = 0;i < 8; i++) {\n<29> memcpy(&fp->fpregs1[i * 16], &env->fpregs[j].d, 10);\n<35> if (env->cpuid_features & CPUID_SSE) {\n<43> memcpy(fp->xmm_regs, env->xmm_regs, CPU_NB_REGS * 16);
<1> void qemu_opts_print(QemuOpts *opts)\n<11> if (desc[0].name == NULL) {\n<13> QTAILQ_FOREACH(opt, &opts->head, next) {\n<15> printf("%s=\"%s\" ", opt->name, opt->str);\n<23> for (; desc && desc->name; desc++) {\n<27> QemuOpt *opt = qemu_opt_find(opts, desc->name);\n<33> if (!value) {\n<39> if (desc->type == QEMU_OPT_STRING) {\n<41> printf("%s='%s' ", desc->name, value);\n<51> printf("%s=%s ", desc->name, value);
<1> static int vc1_decode_p_mb_intfr ( VC1Context * v ) {\n<53> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n<76> vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n<101> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n<119> vc1_mc_4mv_luma ( v , i , 0 ) ;\n<122> vc1_mc_4mv_chroma4 ( v ) ;\n<142> vc1_mc_4mv_chroma4 ( v ) ;\n<151> vc1_mc_1mv ( v , 0 ) ;\n<165> pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : ( s -> linesize << fieldtx ) , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n<174> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n<188> vc1_mc_1mv ( v , 0 ) ;\n<190> if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;
<1> static int svq1_decode_frame(AVCodecContext *avctx, void *data,\n<113> if (!pmv)\n<163> if (s->pict_type == AV_PICTURE_TYPE_I) {\n<197> memset(pmv, 0, ((width / 8) + 3) * sizeof(svq1_pmv));\n<205> result = svq1_decode_delta_block(s, &s->gb, &current[x],\n<259> av_free(pmv);
<1> static int aac_decode_frame(AVCodecContext * avccontext, void * data, int * data_size, const uint8_t * buf, int buf_size) {\n<79> switch (elem_type) {\n<129> enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];\n<131> memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));\n<133> if((err = decode_pce(ac, new_che_pos, &gb)))
<1> rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n<23> if ( buffer != NULL ) free ( buffer ) ;\n<28> if ( buffer != NULL ) free ( buffer ) ;\n<42> case rfbFileTransferRequest : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n<43> if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n<45> if ( DB ) rfbLog ( "rfbProcessFileTransfer() rfbFileTransferRequest(\"%s\"->\"%s\") Open: %s fd=%d\n" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? "Failed" : "Success" ) , cl -> fileTransfer . fd ) ;\n<47> if ( fstat ( cl -> fileTransfer . fd , & statbuf ) != 0 ) {\n<52> strftime ( timespec , sizeof ( timespec ) , "%m/%d/%Y %H:%M" , gmtime ( & statbuf . st_ctime ) ) ;\n<53> buffer = realloc ( buffer , length + strlen ( timespec ) + 2 ) ;\n<54> if ( buffer == NULL ) {\n<55> rfbLog ( "rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\n" , length + strlen ( timespec ) + 2 ) ;\n<58> strcat ( buffer , "," ) ;\n<59> strcat ( buffer , timespec ) ;\n<60> length = strlen ( buffer ) ;\n<61> if ( DB ) rfbLog ( "rfbProcessFileTransfer() buffer is now: \"%s\"\n" , buffer ) ;\n<65> retval = rfbSendFileTransferMessage ( cl , rfbFileHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : statbuf . st_size ) , length , buffer ) ;\n<67> if ( buffer != NULL ) free ( buffer ) ;\n<80> if ( buffer != NULL ) free ( buffer ) ;\n<96> if ( p != NULL ) {\n<97> * p = '\0' ;\n<98> strncpy ( szFileTime , p + 1 , sizeof ( szFileTime ) ) ;\n<105> if ( buffer != NULL ) free ( buffer ) ;\n<111> if ( DB ) rfbLog ( "rfbProcessFileTransfer() rfbFileTransferOffer(\"%s\"->\"%s\") %s %s fd=%d\n" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? "Failed" : "Success" ) , ( cl -> fileTransfer . fd == - 1 ? strerror ( errno ) : "" ) , cl -> fileTransfer . fd ) ;\n<112> retval = rfbSendFileTransferMessage ( cl , rfbFileAcceptHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : 0 ) , length , buffer ) ;\n<113> if ( cl -> fileTransfer . fd == - 1 ) {\n<114> free ( buffer ) ;\n<185> if ( buffer != NULL ) free ( buffer ) ;\n<194> if ( buffer != NULL ) free ( buffer ) ;\n<205> if ( buffer != NULL ) free ( buffer ) ;\n<212> if ( buffer != NULL ) free ( buffer ) ;\n<214> fail : if ( buffer != NULL ) free ( buffer ) ;
<1> pic_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n<11> rval = fs->regs[addr >> 2];\n<13> D(printf("%s %x=%x\n", __func__, addr, rval));\n<15> return rval;
<1> static char *scsibus_get_fw_dev_path(DeviceState *dev)\n<11> snprintf(path, sizeof(path), "channel@%x/%s@%x,%x", d->channel,\n<17> return strdup(path);
<1> static ssize_t test_block_write_func(QCryptoBlock *block,\n<3> size_t offset,\n<5> const uint8_t *buf,\n<7> size_t buflen,\n<15> Buffer *header = opaque;\n<23> memcpy(header->buffer + offset, buf, buflen);\n<25> header->offset = offset + buflen;\n<29> return buflen;
<1> static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res)\n<61> if (ret < 0) {\n<63> fprintf(stderr, "ERROR: Could not read L2 table: %s\n",\n<65> strerror(-ret));
<1> static void dump_sprs (CPUPPCState *env)\n<7> uint32_t pvr = env->spr[SPR_PVR];\n<15> printf("* SPRs for PVR=%08x\n", pvr);\n<23> spr = &env->spr_cb[n];\n<43> if (sw || sr || uw || ur) {\n<47> (i << 5) | j, (i << 5) | j, spr->name,
<1> static int lag_decode_frame(AVCodecContext *avctx,\n<7> const uint8_t *buf = avpkt->data;\n<75> dst = p->data[0];\n<91> for (j = 0; j < avctx->height; j++) {\n<93> memset(dst, buf[1], avctx->width * planes);\n<95> dst += p->linesize[0];
<1> static void monitor_find_completion(const char *cmdline)\n<19> parse_cmdline(cmdline, &nb_args, args);\n<37> len = strlen(cmdline);\n<39> if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n<51> if (nb_args <= 1) {\n<57> cmdname = "";\n<61> cmdname = args[0];\n<63> readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n<67> cmd_completion(cmdname, cmd->name);\n<75> for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n<85> if (!cmd->name) {\n<109> str = args[nb_args - 1];\n<117> switch(*ptype) {\n<123> readline_set_completion_index(cur_mon->rs, strlen(str));\n<125> file_completion(str);\n<133> readline_set_completion_index(cur_mon->rs, strlen(str));\n<135> bdrv_iterate(block_completion_it, (void *)str);\n<143> if (!strcmp(cmd->name, "info")) {\n<145> readline_set_completion_index(cur_mon->rs, strlen(str));\n<147> for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n<149> cmd_completion(str, cmd->name);\n<153> } else if (!strcmp(cmd->name, "sendkey")) {\n<155> char *sep = strrchr(str, '-');\n<157> if (sep)\n<159> str = sep + 1;\n<161> readline_set_completion_index(cur_mon->rs, strlen(str));\n<163> for(key = key_defs; key->name != NULL; key++) {\n<165> cmd_completion(str, key->name);\n<169> } else if (!strcmp(cmd->name, "help|?")) {\n<171> readline_set_completion_index(cur_mon->rs, strlen(str));\n<173> for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n<175> cmd_completion(str, cmd->name);
<1> static int mpc8_decode_frame(AVCodecContext * avctx,\n<13> MPCContext *c = avctx->priv_data;\n<33> if(keyframe){\n<35> memset(c->Q, 0, sizeof(c->Q));\n<325> ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);
<1> static void encode_cblk(Jpeg2000EncoderContext *s, Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk, Jpeg2000Tile *tile,\n<13> for (y = 0; y < height+2; y++)\n<15> memset(t1->flags[y], 0, (width+2)*sizeof(int));
<1> static void omap_mcbsp_source_tick(void *opaque)\n<15> if (s->rx_req)\n<17> printf("%s: Rx FIFO overrun\n", __FUNCTION__);
<1> static int mss1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> MSS12Context * c = & ctx -> ctx ;\n<24> pal_changed = decode_pal ( c , & acoder ) ;\n<34> if ( c -> corrupted ) return AVERROR_INVALIDDATA ;\n<35> memcpy ( ctx -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;
<1> static int decode_plane(UtvideoContext *c, int plane_no,\n<115> if (!slice_size) {\n<127> memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n<135> init_get_bits(&gb, c->slice_bits, slice_size * 8);
<1> static void kvm_openpic_realize(DeviceState *dev, Error **errp)\n<61> if (ret < 0) {\n<65> cd.type, strerror(errno));
<1> static uint64_t pxa2xx_ssp_read(void *opaque, hwaddr addr,\n<45> if (s->rx_level < 1) {\n<47> printf("%s: SSP Rx Underrun\n", __FUNCTION__);
<1> static int truespeech_decode_frame(AVCodecContext *avctx,\n<19> int16_t out_buf[240];\n<29> while (consumed < buf_size) {\n<43> memset(out_buf, 0, 240 * 2);\n<49> truespeech_place_pulses(c, out_buf + i * 60, i);\n<51> truespeech_update_filters(c, out_buf + i * 60, i);\n<53> truespeech_synth(c, out_buf + i * 60, i);\n<67> *samples++ = out_buf[i];
<1> static int sbr_make_f_master ( AACContext * ac , SpectralBandReplication * sbr , SpectrumParameters * spectrum ) {\n<89> int16_t vk0 [ 49 ] ;\n<103> vk0 [ 0 ] = 0 ;\n<107> vk0 [ 0 ] = sbr -> k [ 0 ] ;\n<115> vk0 [ k ] += vk0 [ k - 1 ] ;\n<118> int16_t vk1 [ 49 ] ;\n<127> vk1 [ 1 ] += change ;\n<128> vk1 [ num_bands_1 ] -= change ;\n<131> vk1 [ 0 ] = sbr -> k [ 1 ] ;\n<139> vk1 [ k ] += vk1 [ k - 1 ] ;\n<142> if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n<143> memcpy ( & sbr -> f_master [ 0 ] , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n<144> memcpy ( & sbr -> f_master [ num_bands_0 + 1 ] , vk1 + 1 , num_bands_1 * sizeof ( sbr -> f_master [ 0 ] ) ) ;\n<148> if ( check_n_master ( ac -> avctx , sbr -> n_master , sbr -> spectrum_params . bs_xover_band ) ) return - 1 ;\n<149> memcpy ( sbr -> f_master , vk0 , ( num_bands_0 + 1 ) * sizeof ( sbr -> f_master [ 0 ] ) ) ;
<1> static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n<5> char local[13];\n<9> memcpy(local, version, 12);\n<11> local[12] = 0;\n<15> if (sscanf(local, "RFB %03d.%03d\n", &vs->major, &vs->minor) != 2) {\n<17> VNC_DEBUG("Malformed protocol version %s\n", local);\n<19> vnc_client_error(vs);\n<21> return 0;\n<25> VNC_DEBUG("Client request protocol version %d.%d\n", vs->major, vs->minor);\n<27> if (vs->major != 3 ||\n<29> (vs->minor != 3 &&\n<31> vs->minor != 4 &&\n<33> vs->minor != 5 &&\n<35> vs->minor != 7 &&\n<37> vs->minor != 8)) {\n<57> if (vs->minor == 4 || vs->minor == 5)\n<63> if (vs->minor == 3) {
<1> int av_expr_parse(AVExpr **expr, const char *s,\n<17> char *w = av_malloc(strlen(s) + 1);\n<19> char *wp = w;\n<21> const char *s0 = s;\n<27> if (!w)\n<35> if (!isspace(*s++)) *wp++ = s[-1];
<1> int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush){\n<61> memset(streams, 0, sizeof(streams));\n<69> if(streams[ pktl->pkt.stream_index ] == 0)\n<73> streams[ pktl->pkt.stream_index ]++;
<1> static void audio_init (void)\n<83> drvname = audio_get_conf_str ("QEMU_AUDIO_DRV", NULL, &def);\n<95> for (i = 0; i < ARRAY_SIZE (drvtab); i++) {\n<97> if (!strcmp (drvname, drvtab[i]->name)) {\n<99> done = !audio_driver_init (s, drvtab[i]);\n<101> found = 1;\n<113> dolog ("Unknown audio driver `%s'\n", drvname);\n<129> done = !audio_driver_init (s, drvtab[i]);
<1> static void tgq_decode_mb ( TgqContext * s , int mb_y , int mb_x ) {\n<4> int8_t dc [ 6 ] ;\n<16> if ( mode == 3 ) {\n<17> memset ( dc , bytestream2_get_byte ( & s -> gb ) , 4 ) ;\n<35> tgq_idct_put_mb_dconly ( s , mb_x , mb_y , dc ) ;
<1> static void check_loopfilter()\n<55> memcpy(buf1 - midoff, buf0 - midoff,\n<57> 16 * 8 * SIZEOF_PIXEL);\n<63> if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 8 * SIZEOF_PIXEL))\n<65> fail();\n<93> memcpy(buf1 - midoff, buf0 - midoff, 16 * 16 * SIZEOF_PIXEL);\n<99> if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 16 * SIZEOF_PIXEL))\n<101> fail();\n<125> memcpy(buf1 - midoff, buf0 - midoff, 16 * 16 * SIZEOF_PIXEL);\n<133> if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 16 * SIZEOF_PIXEL))\n<135> fail();
<1> static NetSocketState *net_socket_fd_init(VLANState *vlan,\n<13> if(getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&so_type,\n<17> fprintf(stderr, "qemu: error: getsockopt(SO_TYPE) for fd=%d failed\n", fd);\n<23> switch(so_type) {\n<37> fprintf(stderr, "qemu: warning: socket type=%d for fd=%d is not SOCK_DGRAM or SOCK_STREAM\n", so_type, fd);\n<39> return net_socket_fd_init_stream(vlan, model, name, fd, is_connected);
<1> static int qcow2_open ( BlockDriverState * bs , QDict * options , int flags , Error * * errp ) {\n<252> if ( local_err ) {\n<263> opt_overlap_check = qemu_opt_get ( opts , "overlap-check" ) ? : "cached" ;\n<264> if ( ! strcmp ( opt_overlap_check , "none" ) ) {\n<265> overlap_check_template = 0 ;\n<267> else if ( ! strcmp ( opt_overlap_check , "constant" ) ) {\n<268> overlap_check_template = QCOW2_OL_CONSTANT ;\n<270> else if ( ! strcmp ( opt_overlap_check , "cached" ) ) {\n<271> overlap_check_template = QCOW2_OL_CACHED ;\n<273> else if ( ! strcmp ( opt_overlap_check , "all" ) ) {\n<274> overlap_check_template = QCOW2_OL_ALL ;\n<277> error_setg ( errp , "Unsupported value '%s' for qcow2 option " "'overlap-check'. Allowed are either of the following: " "none, constant, cached, all" , opt_overlap_check ) ;\n<278> qemu_opts_del ( opts ) ;\n<279> ret = - EINVAL ;\n<282> s -> overlap_check = 0 ;\n<283> for ( i = 0 ;\n<284> i < QCOW2_OL_MAX_BITNR ;\n<288> qemu_opts_del ( opts ) ;\n<289> if ( s -> use_lazy_refcounts && s -> qcow_version < 3 ) {
<1> void register_device_unmigratable(DeviceState *dev, const char *idstr,\n<29> pstrcat(id, sizeof(id), idstr);\n<33> QTAILQ_FOREACH(se, &savevm_handlers, entry) {\n<35> if (strcmp(se->idstr, id) == 0 && se->opaque == opaque) {\n<37> se->no_migrate = 1;
<1> static int qcelp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<4> QCELPContext * q = avctx -> priv_data ;\n<12> if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n<25> if ( q -> bitrate > SILENCE ) {\n<30> memset ( & q -> frame , 0 , sizeof ( QCELPFrame ) ) ;\n<55> if ( decode_lspf ( q , quantized_lspf ) < 0 ) {\n<59> apply_pitch_filters ( q , outbuffer ) ;\n<65> decode_lspf ( q , quantized_lspf ) ;\n<66> apply_pitch_filters ( q , outbuffer ) ;\n<73> interpolate_lpc ( q , quantized_lspf , lpc , i ) ;\n<77> postfilter ( q , outbuffer , lpc ) ;\n<78> memcpy ( q -> formant_mem , q -> formant_mem + 160 , 10 * sizeof ( float ) ) ;\n<79> memcpy ( q -> prev_lspf , quantized_lspf , sizeof ( q -> prev_lspf ) ) ;
<1> PCIBus *ppc4xx_pci_init(CPUState *env, qemu_irq pci_irqs[4],\n<59> if (index < 0)\n<75> if (index < 0)\n<87> if (index < 0)\n<113> printf("%s error\n", __func__);
<1> int xen_domain_build_pv(const char *kernel, const char *ramdisk,\n<21> memcpy(uuid, qemu_uuid, sizeof(uuid));\n<23> rc = xc_domain_create(xen_xc, ssidref, uuid, flags, &xen_domid);\n<25> if (rc < 0) {\n<27> fprintf(stderr, "xen: xc_domain_create() failed\n");\n<47> if (rc < 0) {\n<49> fprintf(stderr, "xen: xc_domain_max_vcpus() failed\n");\n<75> if (rc < 0) {\n<77> fprintf(stderr, "xen: xc_domain_setmaxmem() failed\n");\n<101> if (rc < 0) {\n<103> fprintf(stderr, "xen: xc_linux_build() failed\n");\n<121> if (rc < 0) {\n<123> fprintf(stderr, "xen: xc_domain_unpause() failed\n");
<1> static int decode_plane(UtvideoContext *c, int plane_no,\n<35> src      += 256;\n<65> slice_size       = slice_data_end - slice_data_start;\n<69> if (!slice_size) {\n<87> memcpy(c->slice_bits, src + slice_data_start + c->slices * 4, slice_size);\n<89> memset(c->slice_bits + slice_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<91> c->dsp.bswap_buf((uint32_t*)c->slice_bits, (uint32_t*)c->slice_bits,\n<95> init_get_bits(&gb, c->slice_bits, slice_size * 8);
<1> static void realview_init(ram_addr_t ram_size,\n<35> if (!cpu_model)\n<37> cpu_model = "arm926";\n<41> if (strcmp(cpu_model, "arm11mpcore") == 0) {\n<43> ncpu = 4;\n<47> ncpu = 1;\n<55> env = cpu_init(cpu_model);\n<57> if (!env) {\n<59> fprintf(stderr, "Unable to find CPU definition\n");\n<183> for(n = 0; n < nb_nics; n++) {\n<185> nd = &nd_table[n];\n<189> if ((!nd->model && !done_smc) || strcmp(nd->model, "smc91c111") == 0) {\n<191> smc91c111_init(nd, 0x4e000000, pic[28]);\n<193> done_smc = 1;\n<197> pci_nic_init_nofail(nd, "rtl8139", NULL);
<1> static int mp_decode_frame(MPADecodeContext *s,\n<27> switch(s->layer) {\n<51> nb_frames = mp_decode_layer3(s);\n<55> s->last_buf_size=0;\n<63> if(i >= 0 && i <= BACKSTEP_SIZE){\n<65> memmove(s->last_buf, s->gb.buffer + (get_bits_count(&s->gb)>>3), i);\n<67> s->last_buf_size=i;\n<99> memcpy(s->last_buf + s->last_buf_size, s->gb.buffer + buf_size - HEADER_SIZE - i, i);\n<101> s->last_buf_size += i;
<1> static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n<13> char access[11];\n<15> char type[11];\n<39> while (*p) {\n<61> if (matches < 4 || strcmp(access, "RW")) {\n<65> } else if (!strcmp(type, "FLAT")) {\n<67> if (matches != 5 || flat_offset < 0) {\n<75> } else if (!strcmp(type, "VMFS")) {\n<77> if (matches == 4) {\n<89> } else if (matches != 4) {\n<99> if (sectors <= 0 ||\n<101> (strcmp(type, "FLAT") && strcmp(type, "SPARSE") &&\n<103> strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) ||\n<105> (strcmp(access, "RW"))) {\n<147> if (local_err) {\n<159> if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) {\n<165> ret = vmdk_add_extent(bs, extent_file, true, sectors,\n<167> 0, 0, 0, 0, 0, &extent, errp);\n<169> if (ret < 0) {\n<179> } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) {\n<183> char *buf = vmdk_read_desc(extent_file->bs, 0, errp);\n<185> if (!buf) {\n<197> g_free(buf);\n<199> if (ret) {\n<211> error_setg(errp, "Unsupported extent type '%s'", type);\n<213> bdrv_unref_child(bs, extent_file);\n<215> return -ENOTSUP;\n<219> extent->type = g_strdup(type);\n<225> while (*p) {
<1> static void omap_lpg_tick(void *opaque)\n<21> printf("%s: LED is %s\n", __FUNCTION__, s->cycle ? "on" : "off");
<1> static int parse_ifo_palette(DVDSubContext *ctx, char *p)\n<23> if ((ifo = fopen(p, "r")) == NULL) {\n<25> av_log(ctx, AV_LOG_WARNING, "Unable to open IFO file \"%s\": %s\n", p, strerror(errno));\n<31> if (fread(ifostr, 12, 1, ifo) != 1 || memcmp(ifostr, "DVDVIDEO-VTS", 12)) {\n<33> av_log(ctx, AV_LOG_WARNING, "\"%s\" is not a proper IFO file\n", p);\n<35> ret = AVERROR_INVALIDDATA;\n<41> fseek(ifo, 0xCC, SEEK_SET);\n<43> if (fread(&sp_pgci, 4, 1, ifo) == 1) {\n<85> if (ctx->has_palette == 0) {
<1> void opt_input_file(const char *filename)\n<7> AVFormatParameters params, *ap = &params;\n<15> memset(ap, 0, sizeof(*ap));\n<31> err = av_open_input_file(&ic, filename, file_iformat, 0, ap);\n<35> print_error(filename, err);\n<49> if (ret < 0) {\n<51> fprintf(stderr, "%s: could not find codec parameters\n", filename);\n<61> for(i=0;i<ic->nb_streams;i++) {\n<85> if (enc->frame_rate != rfps) {\n<87> fprintf(stderr,"\nSeems that stream %d comes from film source: %2.2f->%2.2f\n",\n<89> i, (float)enc->frame_rate / FRAME_RATE_BASE,\n<91> (float)rfps / FRAME_RATE_BASE);\n<115> dump_format(ic, nb_input_files, filename, 0);
<1> static VALUE cState_space_set ( VALUE self , VALUE space ) {\n<6> if ( len == 0 ) {\n<15> state -> space = strdup ( RSTRING_PTR ( space ) ) ;
<1> static void sd_reset(SDState *sd)\n<43> sd_set_sdstatus(sd);\n<57> memset(sd->function_group, 0, sizeof(sd->function_group));
<1> static int img_check(int argc, char **argv)\n<31> switch(c) {\n<43> fmt = optarg;\n<53> if (!strcmp(optarg, "leaks")) {\n<55> fix = BDRV_FIX_LEAKS;\n<57> } else if (!strcmp(optarg, "all")) {\n<59> fix = BDRV_FIX_LEAKS | BDRV_FIX_ERRORS;\n<63> help();\n<91> ret = bdrv_check(bs, &result, fix);\n<107> if (result.corruptions_fixed || result.leaks_fixed) {\n<109> printf("The following inconsistencies were found and repaired:\n\n"\n<121> ret = bdrv_check(bs, &result, 0);\n<127> if (!(result.corruptions || result.leaks || result.check_errors)) {\n<129> printf("No errors were found on the image.\n");\n<133> if (result.corruptions) {\n<135> printf("\n%d errors were found on the image.\n"\n<147> if (result.leaks) {\n<149> printf("\n%d leaked clusters were found on the image.\n"\n<159> if (result.check_errors) {\n<161> printf("\n%d internal errors have occurred during the check.\n",\n<189> if (ret < 0 || result.check_errors) {\n<191> printf("\nAn error has occurred during the check: %s\n"\n<195> strerror(-ret));
<1> static int flic_decode_frame_15_16BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n<28> pixels = s -> frame . data [ 0 ] ;\n<38> switch ( chunk_type ) {\n<90> case FLI_BLACK : memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n<107> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<119> pixels [ pixel_ptr ++ ] = palette_idx1 ;
<1> static ssize_t proxy_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n<9> retval = v9fs_request(fs_ctx->private, T_READLINK, buf, "sd",\n<13> if (retval < 0) {\n<21> return strlen(buf);
<1> static void lsi_execute_script(LSIState *s)\n<759> if (!(s->sien0 & LSI_SIST0_UDC))\n<761> fprintf(stderr, "inf. loop with UDC masked\n");
<1> void unregister_savevm(const char *idstr, void *opaque)\n<9> TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n<11> if (strcmp(se->idstr, idstr) == 0 && se->opaque == opaque) {\n<13> TAILQ_REMOVE(&savevm_handlers, se, entry);\n<15> qemu_free(se);
<1> static ssize_t qemu_enqueue_packet_iov(VLANClientState *sender,\n<21> packet = qemu_malloc(sizeof(VLANPacket) + max_len);\n<27> packet->size = 0;\n<31> for (i = 0; i < iovcnt; i++) {\n<33> size_t len = iov[i].iov_len;\n<37> memcpy(packet->data + packet->size, iov[i].iov_base, len);\n<39> packet->size += len;
<1> static int cdg_decode_frame(AVCodecContext *avctx,\n<39> if (!avctx->frame_number)\n<41> memset(cc->frame->data[0], 0, cc->frame->linesize[0] * avctx->height);\n<63> if (!(cdg_data[1] & 0x0F))\n<65> memset(cc->frame->data[0], cdg_data[0] & 0x0F,\n<67> cc->frame->linesize[0] * CDG_FULL_HEIGHT);
<1> static void put_ebml_utf8(ByteIOContext *pb, unsigned int elementid, char *str)\n<5> put_ebml_binary(pb, elementid, str, strlen(str));
<1> static int asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt)\n<89> av_assert0(asf_st);\n<191> pal = av_packet_new_side_data(&asf_st->pkt, AV_PKT_DATA_PALETTE,\n<195> if (!pal) {\n<201> memcpy(pal, asf_st->palette, AVPALETTE_SIZE);\n<233> av_dlog(asf, "READ PACKET s:%d  os:%d  o:%d,%d  l:%d   DATA:%p\n",\n<265> if (asf->packet_frag_offset != asf_st->frag_offset && !asf_st->pkt_clean) {\n<267> memset(asf_st->pkt.data + asf_st->frag_offset, 0, asf_st->pkt.size - asf_st->frag_offset);\n<281> if (ret < 0 || asf->packet_frag_offset + ret == 0)\n<287> if (asf_st->ds_span > 1) {\n<295> memset(asf_st->pkt.data + asf->packet_frag_offset + ret, 0,\n<297> asf->packet_frag_size - ret);\n<331> for (i = 0; i < asf_st->pkt.size && !asf_st->pkt.data[i]; i++)\n<355> if (asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span) {\n<373> if (buf) {\n<375> uint8_t *newdata = buf->data;\n<383> while (offset < asf_st->pkt.size) {\n<385> int off = offset / asf_st->ds_chunk_size;\n<399> asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n<403> offset += asf_st->ds_chunk_size;
<1> static int alloc_addbyter ( int output , FILE * data ) {\n<2> struct asprintf * infop = ( struct asprintf * ) data ;\n<4> if ( ! infop -> buffer ) {\n<5> infop -> buffer = malloc ( 32 ) ;\n<6> if ( ! infop -> buffer ) {\n<13> else if ( infop -> len + 1 >= infop -> alloc ) {\n<15> newptr = realloc ( infop -> buffer , infop -> alloc * 2 ) ;\n<16> if ( ! newptr ) {
<1> static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s ) {\n<3> unsigned char P [ 2 ] ;\n<5> y < 8 ;\n<8> P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n<9> P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n<11> memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ;\n<12> memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ;\n<13> s -> pixel_ptr += s -> stride ;
<1> static void modified_levinson_durbin(int *window, int window_entries,\n<9> int *state = av_calloc(window_entries, sizeof(*state));\n<13> memcpy(state, window, 4* window_entries);\n<27> int *x_ptr = &(window[step]);\n<97> x_ptr = &(window[step]);\n<139> av_free(state);
<1> static void usbredir_control_packet(void *priv, uint32_t id,\n<3> struct usb_redir_control_packet_header *control_packet,\n<5> uint8_t *data, int data_len)\n<17> DPRINTF("ctrl-in status %d len %d id %u\n", control_packet->status,\n<25> if (!aurb) {\n<27> free(data);\n<35> aurb->control_packet.status = control_packet->status;\n<37> aurb->control_packet.length = control_packet->length;\n<43> ERROR("return control packet mismatch, please report this!\n");\n<45> len = USB_RET_NAK;\n<53> len = usbredir_handle_status(dev, control_packet->status, len);\n<57> usbredir_log_data(dev, "ctrl data in:", data, data_len);\n<59> if (data_len <= sizeof(dev->dev.data_buf)) {\n<61> memcpy(dev->dev.data_buf, data, data_len);\n<77> usb_generic_async_ctrl_complete(&dev->dev, aurb->packet);\n<81> async_free(dev, aurb);\n<83> free(data);
<1> bool metakey_h ( connection_t * c ) {\n<2> char buffer [ MAX_STRING_SIZE ] ;\n<5> if ( sscanf ( c -> buffer , "%*d %d %d %d %d " MAX_STRING , & cipher , & digest , & maclength , & compression , buffer ) != 5 ) {\n<10> if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n<11> logger ( LOG_ERR , "Possible intruder %s (%s): %s" , c -> name , c -> hostname , "wrong keylength" ) ;\n<12> return false ;\n<14> c -> inkey = xrealloc ( c -> inkey , len ) ;\n<15> if ( ! c -> inctx ) {\n<21> if ( ! hex2bin ( buffer , buffer , len ) ) {
<1> static ssize_t local_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n<3> char *buf, size_t bufsz)\n<39> } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n<43> tsize = readlink(rpath(fs_ctx, path, buffer), buf, bufsz);\n<47> return tsize;
<1> ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,\n<15> trace_object_class_dynamic_cast_assert(class ? class->type->name : "(null)",\n<41> if (!class->interfaces) {\n<51> ret = object_class_dynamic_cast(class, typename);\n<53> if (!ret && class) {\n<55> fprintf(stderr, "%s:%d:%s: Object %p is not an instance of type %s\n",
<1> bool address_space_rw(AddressSpace *as, hwaddr addr, uint8_t *buf,\n<23> l = len;\n<25> mr = address_space_translate(as, addr, &addr1, &l, is_write);\n<31> if (!memory_access_is_direct(mr, is_write)) {\n<71> ptr = qemu_get_ram_ptr(addr1);\n<73> memcpy(ptr, buf, l);\n<75> invalidate_and_set_dirty(addr1, l);\n<81> if (!memory_access_is_direct(mr, is_write)) {\n<117> ptr = qemu_get_ram_ptr(mr->ram_addr + addr1);\n<119> memcpy(buf, ptr, l);\n<125> len -= l;\n<127> buf += l;\n<129> addr += l;
<1> static void write_header(FFV1Context *f)\n<13> memset(state, 128, sizeof(state));\n<19> put_symbol(c, state, f->version, 0);\n<53> put_symbol(c, state, f->slice_count, 0);
<93> convert(out->data[p], in->data[map->channel_map[p]], len);\n<123> if (map->channel_copy[p])\n<125> memcpy(out->data[p], out->data[map->channel_copy[p]],\n<127> len * out->stride);\n<131> av_samples_set_silence(&out->data[p], 0, len, 1, ac->out_fmt);
<1> static int mov_read_trak(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n<89> if (url_fopen(&sc->pb, sc->drefs[sc->dref_id-1].path, URL_RDONLY) < 0)\n<91> av_log(c->fc, AV_LOG_ERROR, "stream %d, error opening file %s: %s\n",\n<93> st->index, sc->drefs[sc->dref_id-1].path, strerror(errno));
<1> int cpu_cris_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n<17> D(printf ("%s addr=%x pc=%x rw=%x\n", __func__, address, env->pc, rw));\n<19> miss = cris_mmu_translate(&res, env, address & TARGET_PAGE_MASK,\n<65> tlb_set_page(env, address & TARGET_PAGE_MASK, phy,
<1> static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) {\n<4> int num_versions = 1 ;\n<8> if ( n_key_data <= 0 ) return NULL ;\n<9> key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ;\n<10> if ( key_data_in == NULL ) goto cleanup ;\n<11> memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ;\n<24> i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;\n<25> ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;\n<26> if ( ret == NULL ) {\n<36> if ( ret [ j ] == NULL ) goto cleanup ;\n<37> err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;\n<38> if ( err ) goto cleanup ;\n<39> ret [ j ] -> bv_len = code -> length ;\n<40> ret [ j ] -> bv_val = code -> data ;\n<41> free ( code ) ;\n<47> ret [ num_versions ] = NULL ;\n<48> cleanup : free ( key_data ) ;\n<50> if ( ret != NULL ) {\n<53> i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ;\n<54> free ( ret ) ;\n<58> return ret ;
<1> static void local_mapped_file_attr(int dirfd, const char *name,\n<9> char buf[ATTR_MAX];\n<29> if (!fp) {\n<35> memset(buf, 0, ATTR_MAX);\n<37> while (fgets(buf, ATTR_MAX, fp)) {\n<39> if (!strncmp(buf, "virtfs.uid", 10)) {\n<43> } else if (!strncmp(buf, "virtfs.gid", 10)) {\n<47> } else if (!strncmp(buf, "virtfs.mode", 11)) {\n<51> } else if (!strncmp(buf, "virtfs.rdev", 11)) {\n<57> memset(buf, 0, ATTR_MAX);\n<61> fclose(fp);
<1> static void bench_undrained_flush_cb(void *opaque, int ret)\n<5> if (ret < 0) {\n<7> error_report("Failed flush request: %s\n", strerror(-ret));
<1> static int mov_init(AVFormatContext *s)\n<5> MOVMuxContext *mov = s->priv_data;\n<23> if (s->oformat) {\n<25> if (!strcmp("3gp", s->oformat->name)) mov->mode = MODE_3GP;\n<27> else if (!strcmp("3g2", s->oformat->name)) mov->mode = MODE_3GP|MODE_3G2;\n<29> else if (!strcmp("mov", s->oformat->name)) mov->mode = MODE_MOV;\n<31> else if (!strcmp("psp", s->oformat->name)) mov->mode = MODE_PSP;\n<33> else if (!strcmp("ipod",s->oformat->name)) mov->mode = MODE_IPOD;\n<35> else if (!strcmp("ismv",s->oformat->name)) mov->mode = MODE_ISM;\n<37> else if (!strcmp("f4v", s->oformat->name)) mov->mode = MODE_F4V;\n<279> if (!mov->tracks)\n<285> if (mov->encryption_scheme_str != NULL && strcmp(mov->encryption_scheme_str, "none") != 0) {\n<287> if (strcmp(mov->encryption_scheme_str, "cenc-aes-ctr") == 0) {\n<289> mov->encryption_scheme = MOV_ENC_CENC_AES_CTR;\n<293> if (mov->encryption_key_len != AES_CTR_KEY_SIZE) {\n<317> av_log(s, AV_LOG_ERROR, "unsupported encryption scheme %s\n",\n<319> mov->encryption_scheme_str);\n<321> return AVERROR(EINVAL);\n<329> for (i = 0; i < s->nb_streams; i++) {
<1> static void ppc_heathrow_init (ram_addr_t ram_size,\n<63> if (!env) {\n<65> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<83> if (ram_size > (2047 << 20)) {\n<89> ((unsigned int)ram_size / (1 << 20)));\n<273> if (ppc_boot_device == '\0') {\n<275> fprintf(stderr, "No valid boot device for G3 Beige machine\n");
<1> static int waveformat_from_audio_settings (WAVEFORMATEX *wfx, audsettings_t *as)\n<5> memset (wfx, 0, sizeof (*wfx));\n<41> wfx->nAvgBytesPerSec <<= 1;\n<43> wfx->nBlockAlign <<= 1;\n<55> wfx->nAvgBytesPerSec <<= 2;\n<57> wfx->nBlockAlign <<= 2;
<1> static int rtsp_read_header(AVFormatContext *s,\n<115> char transport[2048];\n<179> port = rtp_get_local_port(url_fileno(&rtsp_st->ic->pb));\n<181> if (transport[0] != '\0')\n<183> pstrcat(transport, sizeof(transport), ",");\n<185> snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n<197> if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_TCP)) {\n<199> if (transport[0] != '\0')\n<201> pstrcat(transport, sizeof(transport), ",");\n<203> snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n<211> if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP_MULTICAST)) {\n<213> if (transport[0] != '\0')\n<215> pstrcat(transport, sizeof(transport), ",");\n<217> snprintf(transport + strlen(transport),\n<219> sizeof(transport) - strlen(transport) - 1,
<1> int MPV_common_init(MpegEncContext *s)\n<301> if (s->motion_val == NULL)\n<305> memset(s->motion_val, 0, size * 2 * sizeof(INT16));\n<369> s->mbintra_table = av_mallocz(s->mb_num);\n<371> if (!s->mbintra_table)\n<375> memset(s->mbintra_table, 1, s->mb_num);\n<397> s->mbskip_table = av_mallocz(s->mb_num);\n<415> MPV_common_end(s);
<1> SplineChar * PSCharStringToSplines ( uint8 * type1 , int len , struct pscontext * context , struct pschars * subrs , struct pschars * gsubrs , const char * name ) {\n<28> HintMask * counters [ 96 ] ;\n<32> if ( ! is_type2 && context -> instance_count > 1 ) memset ( unblended , 0 , sizeof ( unblended ) ) ;\n<39> while ( len > 0 ) {\n<886> if ( cp != 0 ) {\n<888> ret -> countermasks = malloc ( cp * sizeof ( HintMask ) ) ;\n<891> i < cp ;\n<893> memcpy ( & ret -> countermasks [ i ] , counters [ i ] , sizeof ( HintMask ) ) ;\n<894> chunkfree ( counters [ i ] , sizeof ( HintMask ) ) ;\n<914> SCGuessHHintInstancesList ( ret , ly_fore ) ;\n<915> SCGuessVHintInstancesList ( ret , ly_fore ) ;\n<918> if ( context -> instance_count == 1 && ! ret -> hconflicts && ! ret -> vconflicts ) SCClearHintMasks ( ret , ly_fore , false ) ;\n<919> HintsRenumber ( ret ) ;\n<920> if ( name != NULL && strcmp ( name , ".notdef" ) != 0 ) ret -> widthset = true ;\n<921> return ( ret ) ;
<1> int rom_add_file(const char *file, const char *fw_dir,\n<15> rom = g_malloc0(sizeof(*rom));\n<19> rom->path = qemu_find_file(QEMU_FILE_TYPE_BIOS, rom->name);\n<29> fd = open(rom->path, O_RDONLY | O_BINARY);\n<31> if (fd == -1) {\n<33> fprintf(stderr, "Could not open option rom '%s': %s\n",\n<35> rom->path, strerror(errno));\n<61> if (rc != rom->romsize) {\n<63> fprintf(stderr, "rom: file %-20s: read error: rc=%d (expected %zd)\n",\n<125> g_free(rom->path);\n<127> g_free(rom->name);\n<129> g_free(rom);
<1> static void virtio_net_set_features(VirtIODevice *vdev, uint64_t features)\n<35> virtio_net_apply_guest_offloads(n);\n<59> if (__virtio_has_feature(features, VIRTIO_NET_F_CTRL_VLAN)) {\n<61> memset(n->vlans, 0, MAX_VLAN >> 3);\n<65> memset(n->vlans, 0xff, MAX_VLAN >> 3);
<1> static int hpet_init(SysBusDevice *dev)\n<23> if (hpet_cfg.count == 8) {\n<25> fprintf(stderr, "Only 8 instances of HPET is allowed\n");
<1> static int nuv_header(AVFormatContext *s)\n<19> avio_read(pb, id_string, 12);\n<21> is_mythtv = !memcmp(id_string, "MythTVVideo", 12);\n<167> if ((ret = get_codec_data(pb, vst, ast, is_mythtv)) < 0)
<1> static void bwf_write_bext_chunk(AVFormatContext *s)\n<27> time_reference = strtoll(tmp_tag->value, NULL, 10);\n<35> if (tmp_tag = av_dict_get(s->metadata, "umid", NULL, 0)) {\n<37> unsigned char umidpart_str[17] = {0};\n<43> size_t len = strlen(tmp_tag->value+2);\n<47> for (i = 0; i < len/16; i++) {\n<49> memcpy(umidpart_str, tmp_tag->value + 2 + (i*16), 16);\n<51> umidpart = strtoll(umidpart_str, NULL, 16);
<1> int ff_mpv_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n<227> if (alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n<239> avctx->height * s->last_picture_ptr->f->linesize[0]);
<1> altivec_yuv2packedX (SwsContext *c,\n<35> unsigned long scratch[16] __attribute__ ((aligned (16)));\n<205> if (i < dstW) {\n<323> memcpy (&((uint32_t*)dest)[i], scratch, (dstW-i)/4);\n<329> if (vYCoeffsBank) free (vYCoeffsBank);\n<331> if (vCCoeffsBank) free (vCCoeffsBank);
<1> static void verdex_init(MachineState *machine)\n<29> if (!dinfo && !qtest_enabled()) {\n<31> fprintf(stderr, "A flash image must be given with the "\n<51> if (!pflash_cfi01_register(0x00000000, NULL, "verdex.rom", verdex_rom,\n<59> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> static int v4l2_set_parameters(AVFormatContext *s1, AVFormatParameters *ap)\n<41> memset (&input, 0, sizeof (input));\n<45> if (ioctl(s->fd, VIDIOC_ENUMINPUT, &input) < 0) {\n<55> av_log(s1, AV_LOG_DEBUG, "The V4L2 driver set input_id: %d, input: %s\n",\n<59> if (ioctl(s->fd, VIDIOC_S_INPUT, &input.index) < 0) {\n<73> if (s->standard) {\n<81> memset (&standard, 0, sizeof (standard));\n<87> if (ioctl(s->fd, VIDIOC_ENUMSTD, &standard) < 0) {\n<101> if (!av_strcasecmp(standard.name, s->standard)) {\n<117> if (ioctl(s->fd, VIDIOC_S_STD, &standard.id) < 0) {\n<177> if (ioctl(s->fd, VIDIOC_G_PARM, &streamparm) != 0) {\n<179> av_log(s1, AV_LOG_ERROR, "ioctl(VIDIOC_G_PARM): %s\n",\n<181> strerror(errno));\n<183> return AVERROR(errno);
<1> static void pcnet_receive(void *opaque, const uint8_t *buf, int size)\n<9> uint8_t buf1[60];\n<29> if (size < MIN_BUF_SIZE) {\n<31> memcpy(buf1, buf, size);\n<33> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<35> buf = buf1;
<1> static void show_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {\n<4> add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ;\n<6> free ( ( char * ) name ) ;
<1> static void virtio_input_handle_event(DeviceState *dev, QemuConsole *src,\n<21> if (qcode && keymap_qcode[qcode]) {\n<33> if (evt->key->down) {\n<35> fprintf(stderr, "%s: unmapped key: %d [%s]\n", __func__,\n<59> if (evt->btn->down) {\n<61> fprintf(stderr, "%s: unmapped button: %d [%s]\n", __func__,
<1> static AVCodec *choose_codec(OptionsContext *o, AVFormatContext *s, AVStream *st, enum AVMediaType type)\n<13> if (!codec_name) {\n<23> } else if (!strcmp(codec_name, "copy"))\n<25> st->stream_copy = 1;\n<29> st->codec->codec_id = find_codec_or_die(codec_name, type, s->iformat == NULL);\n<31> return s->oformat ? avcodec_find_encoder_by_name(codec_name) :\n<39> return NULL;
<1> static void xen_domain_watcher(void)\n<61> if (errno == EINTR)\n<65> qemu_log("%s: Huh? read error: %s\n", __FUNCTION__, strerror(errno));
<9> ret = av_packet_copy_props(dst, src);\n<19> ret = packet_alloc(&dst->buf, src->size);\n<21> if (ret < 0)\n<25> memcpy(dst->buf->data, src->data, src->size);\n<33> dst->size = src->size;\n<35> dst->data = dst->buf->data;
<1> static int v9fs_complete_rename(V9fsState *s, V9fsRenameState *vs)\n<13> if (vs->newdirfid != -1) {\n<21> if (dirfidp == NULL) {\n<39> strcpy(new_name, dirfidp->path.data);\n<41> strcat(new_name, "/");\n<43> strcat(new_name + dirfidp->path.size, vs->name.data);\n<61> new_name = qemu_mallocz(end - old_name + vs->name.size + 1);\n<65> strncat(new_name, old_name, end - old_name);\n<67> strncat(new_name + (end - old_name), vs->name.data, vs->name.size);\n<73> v9fs_string_free(&vs->name);\n<75> vs->name.data = qemu_strdup(new_name);\n<77> vs->name.size = strlen(new_name);\n<81> if (strcmp(new_name, vs->fidp->path.data) != 0) {\n<83> if (v9fs_do_rename(s, &vs->fidp->path, &vs->name)) {\n<101> if (vs->fidp == fidp) {\n<117> strlen(vs->fidp->path.data))) {\n<123> strlen(vs->fidp->path.data));\n<129> v9fs_string_copy(&vs->fidp->path, &vs->name);\n<137> v9fs_string_free(&vs->name);
<1> static int audio_decode_frame(VideoState *is)\n<5> AVPacket *pkt_temp = &is->audio_pkt_temp;\n<37> while (pkt_temp->size > 0 || (!pkt_temp->data && new_packet) || is->audio_buf_frames_pending) {\n<55> if (is->audioq.serial != is->audio_pkt_temp_serial)\n<69> if (flush_complete)\n<75> len1 = avcodec_decode_audio4(dec, is->frame, &got_frame, pkt_temp);\n<77> if (len1 < 0) {\n<81> pkt_temp->size = 0;\n<89> pkt_temp->data += len1;\n<91> pkt_temp->size -= len1;\n<99> if (!pkt_temp->data && dec->codec->capabilities & CODEC_CAP_DELAY)\n<119> if (pkt_temp->pts != AV_NOPTS_VALUE)\n<121> pkt_temp->pts += (double) is->frame->nb_samples / is->frame->sample_rate / av_q2d(is->audio_st->time_base);\n<253> if (!is->swr_ctx || swr_init(is->swr_ctx) < 0) {\n<291> if (out_size < 0) {\n<301> if (swr_set_compensation(is->swr_ctx, (wanted_nb_samples - is->frame->nb_samples) * is->audio_tgt.freq / is->frame->sample_rate,\n<321> if (len2 < 0) {\n<395> memset(pkt_temp, 0, sizeof(*pkt_temp));
<1> static void exynos4210_rtc_write(void *opaque, target_phys_addr_t offset,\n<99> if (value > TICNT_THRESHHOLD) {
<1> static CharDriverState *qemu_chr_open_stdio(ChardevStdio *opts)\n<23> if (stdio->hStdIn == INVALID_HANDLE_VALUE) {\n<25> fprintf(stderr, "cannot open stdio: invalid handle\n");\n<51> fprintf(stderr, "qemu_add_wait_object: failed\n");\n<77> fprintf(stderr, "cannot create stdio thread or event\n");\n<87> fprintf(stderr, "qemu_add_wait_object: failed\n");
<1> static int parse_args(int argc, char **argv)\n<13> for (arginfo = arg_table; arginfo->handle_opt != NULL; arginfo++) {\n<15> if (arginfo->env == NULL) {\n<23> r = getenv(arginfo->env);\n<25> if (r != NULL) {\n<39> if (optind >= argc) {\n<47> if (r[0] != '-') {\n<55> r++;\n<57> if (!strcmp(r, "-")) {\n<65> for (arginfo = arg_table; arginfo->handle_opt != NULL; arginfo++) {\n<67> if (!strcmp(r, arginfo->argv)) {\n<69> if (optind >= argc) {\n<77> arginfo->handle_opt(argv[optind]);\n<81> if (arginfo->has_arg) {\n<99> if (arginfo->handle_opt == NULL) {
<1> static void peak_write_chunk(AVFormatContext *s)\n<29> memset(timestamp, 0, sizeof(timestamp));\n<65> avio_write(pb, timestamp, 28);              /* ASCII time stamp */
<1> print_insn_sparc (bfd_vma memaddr, disassemble_info *info)\n<39> if (!opcodes_initialized)\n<43> malloc (sparc_num_opcodes * sizeof (sparc_opcode *));\n<121> const sparc_opcode *opcode = op->opcode;\n<177> if (X_RS1 (insn) != X_RD (insn)\n<179> && strchr (opcode->args, 'r') != NULL)\n<185> if (X_RS2 (insn) != X_RD (insn)\n<187> && strchr (opcode->args, 'O') != NULL)\n<211> for (s = opcode->args; *s != '\0'; ++s)
<1> static char *idebus_get_fw_dev_path(DeviceState *dev)\n<9> snprintf(path, sizeof(path), "%s@%d", qdev_fw_name(dev),\n<15> return strdup(path);
<1> static void generate_bootsect(uint32_t gpr[8], uint16_t segs[6], uint16_t ip)\n<15> if (hda == -1) {\n<17> fprintf(stderr, "A disk image must be given for 'hda' when booting "\n<27> memset(bootsect, 0, sizeof(bootsect));\n<33> bdrv_read(drives_table[hda].bdrv, 0, bootsect, 1);
<1> static int decode_rle(GetBitContext *gb, uint8_t *pal_dst, int pal_stride,\n<245> } else if (last_symbol == -1 && prev_avail) {\n<249> memcpy(rp, rp - rgb_stride, 3);\n<253> rp += 3;
<1> static int vda_h264_decode_slice(AVCodecContext *avctx,\n<3> const uint8_t *buffer,\n<9> VDAContext *vda                     = avctx->internal->hwaccel_priv_data;\n<29> if (!tmp)\n<35> vda->bitstream = tmp;\n<39> AV_WB32(vda->bitstream + vda->bitstream_size, size);\n<41> memcpy(vda->bitstream + vda->bitstream_size + 4, buffer, size);\n<45> vda->bitstream_size += size + 4;
<1> static void nand_realize(DeviceState *dev, Error **errp)\n<93> if (pagesize) {\n<95> s->storage = (uint8_t *) memset(g_malloc(s->pages * pagesize),\n<97> 0xff, s->pages * pagesize);
<1> static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n<15> svc_ctx -> spatial_layers = default_spatial_layers ;\n<17> res = vpx_codec_enc_config_default ( vpx_codec_vp9_cx ( ) , enc_cfg , 0 ) ;\n<22> enc_cfg -> g_h = default_height ;\n<23> enc_cfg -> g_timebase . num = default_timebase_num ;\n<24> enc_cfg -> g_timebase . den = default_timebase_den ;\n<27> enc_cfg -> kf_max_dist = default_kf_dist ;\n<29> app_input -> frames_to_code = default_frames_to_code ;\n<30> app_input -> frames_to_skip = default_frames_to_skip ;\n<31> argv = argv_dup ( argc - 1 , argv_ + 1 ) ;\n<37> app_input -> frames_to_code = arg_parse_uint ( & arg ) ;\n<43> enc_cfg -> g_h = arg_parse_uint ( & arg ) ;\n<52> app_input -> frames_to_skip = arg_parse_uint ( & arg ) ;\n<55> svc_ctx -> spatial_layers = arg_parse_uint ( & arg ) ;\n<62> enc_cfg -> kf_max_dist = enc_cfg -> kf_min_dist ;\n<65> vpx_svc_set_scale_factors ( svc_ctx , arg . val ) ;\n<68> vpx_svc_set_quantizers ( svc_ctx , arg . val ) ;\n<102> if ( pass ) {\n<103> fprintf ( stderr , "pass is ignored since there's only one pass\n" ) ;\n<130> if ( enc_cfg -> rc_target_bitrate > 0 ) {\n<132> enc_cfg -> rc_2pass_vbr_minsection_pct = min_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n<135> enc_cfg -> rc_2pass_vbr_maxsection_pct = max_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n<138> for ( argi = argv ;\n<139> * argi ;\n<140> ++ argi ) if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) die ( "Error: Unrecognized option %s\n" , * argi ) ;\n<141> if ( argv [ 0 ] == NULL || argv [ 1 ] == 0 ) {\n<146> free ( argv ) ;\n<147> if ( enc_cfg -> g_w < 16 || enc_cfg -> g_w % 2 || enc_cfg -> g_h < 16 || enc_cfg -> g_h % 2 ) die ( "Invalid resolution: %d x %d\n" , enc_cfg -> g_w , enc_cfg -> g_h ) ;\n<148> printf ( "Codec %s\nframes: %d, skip: %d\n" "layers: %d\n" "width %d, height: %d,\n" "num: %d, den: %d, bitrate: %d,\n" "gop size: %d\n" , vpx_codec_iface_name ( vpx_codec_vp9_cx ( ) ) , app_input -> frames_to_code , app_input -> frames_to_skip , svc_ctx -> spatial_layers , enc_cfg -> g_w , enc_cfg -> g_h , enc_cfg -> g_timebase . num , enc_cfg -> g_timebase . den , enc_cfg -> rc_target_bitrate , enc_cfg -> kf_max_dist ) ;
<1> static CharDriverState *qemu_chr_open_spice_vmc(const char *id,\n<11> const char *type = backend->u.spicevmc->type;\n<17> for (; *psubtype != NULL; ++psubtype) {\n<19> if (strcmp(type, *psubtype) == 0) {\n<27> if (*psubtype == NULL) {\n<29> fprintf(stderr, "spice-qemu-char: unsupported type: %s\n", type);\n<39> return chr_open(type, spice_vmc_set_fe_open);
<1> static int decode_frame(AVCodecContext *avctx,\n<9> PNGDecContext *const s = avctx->priv_data;\n<11> const uint8_t *buf     = avpkt->data;\n<27> if (buf_size < 8 ||\n<29> memcmp(buf, ff_pngsig, 8) != 0 &&\n<31> memcmp(buf, ff_mngsig, 8) != 0)\n<37> bytestream2_init(&s->gb, buf + 8, buf_size - 8);\n<259> if (s->color_type == PNG_COLOR_TYPE_PALETTE)\n<261> memcpy(p->data[1], s->palette, 256 * sizeof(uint32_t));\n<305> if (png_decode_idat(s, length) < 0)\n<337> s->palette[i] = (0xff << 24) | (r << 16) | (g << 8) | b;\n<343> s->palette[i] = (0xff << 24);\n<375> s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);
<1> static int img_resize(int argc, char **argv)\n<193> switch (ret) {\n<197> printf("Image resized.\n");
<1> int ff_probe_input_buffer(ByteIOContext **pb, AVInputFormat **fmt,\n<9> AVProbeData pd = { filename ? filename : "", NULL, -offset };\n<59> buf = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n<61> if ((ret = get_buffer(*pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n<65> if (ret != AVERROR_EOF) {\n<79> pd.buf_size += ret;\n<81> pd.buf = &buf[offset];\n<85> memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n<91> *fmt = av_probe_input_format2(&pd, 1, &score);
<1> static void spitz_common_init(int ram_size, int vga_ram_size,\n<11> uint32_t spitz_ram = 0x04000000;\n<13> uint32_t spitz_rom = 0x00800000;\n<27> if (ram_size < spitz_ram + spitz_rom) {\n<29> fprintf(stderr, "This platform requires %i bytes of memory\n",
<1> static void rng_egd_chr_read(void *opaque, const uint8_t *buf, int size)\n<7> size_t buf_offset = 0;\n<11> while (size > 0 && s->parent.requests) {\n<13> RngRequest *req = s->parent.requests->data;\n<15> int len = MIN(size, req->size - req->offset);\n<19> memcpy(req->data + req->offset, buf + buf_offset, len);\n<21> buf_offset += len;\n<23> req->offset += len;\n<25> size -= len;\n<37> req->receive_entropy(req->opaque, req->data, req->size);
<1> static UHCIAsync *uhci_async_alloc(UHCIState *s)\n<5> UHCIAsync *async = g_malloc(sizeof(UHCIAsync));\n<9> memset(&async->packet, 0, sizeof(async->packet));\n<23> usb_packet_init(&async->packet);\n<29> return async;
<1> static void vga_draw_graphic(VGACommonState *s, int full_update)\n<179> full_update |= update_palette16(s);\n<195> full_update |= update_palette16(s);\n<211> switch(s->get_bpp(s)) {\n<217> full_update |= update_palette256(s);\n<227> full_update |= update_palette256(s);\n<277> s->cursor_invalidate(s);\n<343> update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n<361> vga_draw_line(s, d, s->vram_ptr + addr, width);\n<365> s->cursor_draw_line(s, d, y);\n<437> memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);
<1> static int write_elf64_load(DumpState *s, MemoryMapping *memory_mapping,\n<15> memset(&phdr, 0, sizeof(Elf64_Phdr));\n<41> ret = fd_write_vmcore(&phdr, sizeof(Elf64_Phdr), s);
<1> static int encode_thread ( AVCodecContext * c , void * arg ) {\n<2> MpegEncContext * s = * ( void * * ) arg ;\n<35> memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;\n<38> case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : case AV_CODEC_ID_FLV1 : if ( CONFIG_H263_ENCODER ) s -> gob_index = ff_h263_get_gob_height ( s ) ;\n<40> case AV_CODEC_ID_MPEG4 : if ( CONFIG_MPEG4_ENCODER && s -> partitioned_frame ) ff_mpeg4_init_partitions ( s ) ;\n<52> ff_set_qscale ( s , s -> qscale ) ;\n<53> ff_init_block_index ( s ) ;\n<73> ff_update_block_index ( s ) ;\n<75> ff_h261_reorder_mb_index ( s ) ;\n<93> write_slice_end ( s ) ;\n<95> ff_mpeg4_init_partitions ( s ) ;\n<113> update_mb_info ( s , 1 ) ;\n<116> ff_mpeg4_encode_video_packet_header ( s ) ;\n<117> ff_mpeg4_clean_buffers ( s ) ;\n<121> ff_mpeg1_encode_slice_header ( s ) ;\n<122> ff_mpeg1_clean_buffers ( s ) ;\n<125> case AV_CODEC_ID_H263 : case AV_CODEC_ID_H263P : if ( CONFIG_H263_ENCODER ) ff_h263_encode_gob_header ( s , mb_y ) ;\n<144> update_mb_info ( s , 0 ) ;\n<148> copy_context_before_encode ( & backup_s , s , - 1 ) ;\n<150> best_s . data_partitioning = s -> data_partitioning ;\n<151> best_s . partitioned_frame = s -> partitioned_frame ;\n<162> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n<175> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n<183> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_SKIPPED , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n<195> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER4V , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n<203> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 0 ] [ 0 ] [ 0 ] , s -> mv [ 0 ] [ 0 ] [ 1 ] ) ;\n<211> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ 1 ] [ 0 ] [ 0 ] , s -> mv [ 1 ] [ 0 ] [ 1 ] ) ;\n<221> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n<234> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_FORWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n<247> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BACKWARD_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n<264> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_BIDIR_I , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n<272> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTRA , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n<275> else ff_clean_intra_table_entries ( s ) ;\n<279> if ( best_s . mv_type == MV_TYPE_16X16 ) {\n<282> int16_t ac [ 6 ] [ 16 ] ;\n<283> const int mvdir = ( best_s . mv_dir & MV_DIR_BACKWARD ) ? 1 : 0 ;\n<288> s -> mv_dir = best_s . mv_dir ;\n<290> s -> mb_intra = best_s . mb_intra ;\n<305> i < 6 ;\n<308> memcpy ( ac [ i ] , s -> ac_val [ 0 ] [ s -> block_index [ i ] ] , sizeof ( int16_t ) * 16 ) ;\n<311> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , s -> mv [ mvdir ] [ 0 ] [ 0 ] , s -> mv [ mvdir ] [ 0 ] [ 1 ] ) ;\n<312> if ( best_s . qscale != qp ) {\n<315> i < 6 ;\n<318> memcpy ( s -> ac_val [ 0 ] [ s -> block_index [ i ] ] , ac [ i ] , sizeof ( int16_t ) * 16 ) ;\n<331> ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n<332> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n<338> ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n<339> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_DIRECT , pb , pb2 , tex_pb , & dmin , & next_block , 0 , 0 ) ;\n<341> if ( ! best_s . mb_intra && s -> mpv_flags & FF_MPV_FLAG_SKIP_RD ) {\n<346> if ( coded ) {\n<348> memcpy ( s -> mv , best_s . mv , sizeof ( s -> mv ) ) ;\n<349> if ( CONFIG_MPEG4_ENCODER && best_s . mv_dir & MV_DIRECT ) {\n<351> ff_mpeg4_set_direct_mv ( s , mx , my ) ;\n<353> else if ( best_s . mv_dir & MV_DIR_BACKWARD ) {\n<361> s -> mv_dir = best_s . mv_dir ;\n<362> s -> mv_type = best_s . mv_type ;\n<366> encode_mb_hq ( s , & backup_s , & best_s , CANDIDATE_MB_TYPE_INTER , pb , pb2 , tex_pb , & dmin , & next_block , mx , my ) ;\n<370> s -> current_picture . f . qscale_table [ xy ] = best_s . qscale ;\n<371> copy_context_after_encode ( s , & best_s , - 1 ) ;\n<387> if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n<393> if ( s -> avctx -> mb_decision == FF_MB_DECISION_BITS ) ff_MPV_decode_mb ( s , s -> block ) ;\n<435> ff_mpeg4_set_direct_mv ( s , motion_x , motion_y ) ;\n<441> ff_mpeg4_set_direct_mv ( s , 0 , 0 ) ;\n<500> encode_mb ( s , motion_x , motion_y ) ;\n<502> if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 && s -> pict_type != AV_PICTURE_TYPE_B ) ff_h263_update_motion_val ( s ) ;\n<503> ff_MPV_decode_mb ( s , s -> block ) ;\n<514> s -> current_picture . f . error [ 0 ] += sse ( s , s -> new_picture . f . data [ 0 ] + s -> mb_x * 16 + s -> mb_y * s -> linesize * 16 , s -> dest [ 0 ] , w , h , s -> linesize ) ;\n<515> s -> current_picture . f . error [ 1 ] += sse ( s , s -> new_picture . f . data [ 1 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 1 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n<516> s -> current_picture . f . error [ 2 ] += sse ( s , s -> new_picture . f . data [ 2 ] + s -> mb_x * 8 + s -> mb_y * s -> uvlinesize * chr_h , s -> dest [ 2 ] , w >> 1 , h >> s -> chroma_y_shift , s -> uvlinesize ) ;\n<519> if ( CONFIG_H263_ENCODER && s -> out_format == FMT_H263 ) ff_h263_loop_filter ( s ) ;\n<525> write_slice_end ( s ) ;
<1> static int test_vector_dmac_scalar(AVFloatDSPContext *fdsp, AVFloatDSPContext *cdsp,\n<3> const double *v1, const double *src0, double scale)\n<15> memcpy(cdst, v1, LEN * sizeof(*v1));\n<17> memcpy(odst, v1, LEN * sizeof(*v1));\n<21> cdsp->vector_dmac_scalar(cdst, src0, scale, LEN);\n<23> fdsp->vector_dmac_scalar(odst, src0, scale, LEN);
<85> if (ret < 0) {\n<87> monitor_printf(mon, "migration failed: %s\n", strerror(-ret));
<1> static void ffm_write_data(AVFormatContext *s,\n<3> const uint8_t *buf, int size,\n<9> FFMContext *ffm = s->priv_data;\n<27> while (size > 0) {\n<29> len = ffm->packet_end - ffm->packet_ptr;\n<31> if (len > size)\n<33> len = size;\n<35> memcpy(ffm->packet_ptr, buf, len);\n<39> ffm->packet_ptr += len;\n<41> buf += len;\n<43> size -= len;
<1> static void v9fs_wstat_post_chown(V9fsState *s, V9fsWstatState *vs, int err)\n<15> if (vs->v9stat.name.size != 0) {\n<39> new_name = qemu_mallocz(end - old_name + vs->v9stat.name.size + 1);\n<43> memcpy(new_name, old_name, end - old_name);\n<45> memcpy(new_name + (end - old_name), vs->v9stat.name.data,\n<49> vs->nname.data = new_name;\n<51> vs->nname.size = strlen(new_name);\n<55> if (strcmp(new_name, vs->fidp->path.data) != 0) {\n<57> if (v9fs_do_rename(s, &vs->fidp->path, &vs->nname)) {\n<75> if (vs->fidp == fidp) {\n<91> strlen(vs->fidp->path.data))) {\n<97> strlen(vs->fidp->path.data));\n<103> v9fs_string_copy(&vs->fidp->path, &vs->nname);\n<111> v9fs_wstat_post_rename(s, vs, err);
<1> static gcry_err_code_t sexp_to_sig ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo ) {\n<17> if ( ! name ) {\n<22> else if ( ! strcmp ( name , "flags" ) ) {\n<23> gcry_free ( name ) ;\n<24> gcry_sexp_release ( l2 ) ;\n<25> l2 = gcry_sexp_nth ( list , 2 ) ;\n<26> if ( ! l2 ) {\n<32> ath_mutex_lock ( & pubkeys_registered_lock ) ;\n<33> module = gcry_pk_lookup_name ( name ) ;\n<34> ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n<35> gcry_free ( name ) ;\n<36> name = NULL ;\n<37> if ( ! module ) {\n<43> elems = pubkey -> elements_sig ;\n<44> array = gcry_calloc ( strlen ( elems ) + 1 , sizeof * array ) ;\n<45> if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n<46> if ( ! err ) err = sexp_elements_extract ( list , elems , array , NULL ) ;
<1> int cpu_ppc_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n<41> } else if (ret < 0) {\n<387> switch (access_type) {\n<443> printf("DSI: invalid exception (%d)\n", ret);
<1> static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) {\n<4> unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ;\n<12> if ( NIL_P ( init_v ) ) memcpy ( iv , "OpenSSL for Ruby rulez!" , sizeof ( iv ) ) ;\n<15> if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) {\n<16> memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ;\n<17> memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ;\n<19> else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ;\n<21> EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ;
<1> void Process(void *ctx, AVPicture *picture, enum PixelFormat pix_fmt, int width, int height, INT64 pts)\n<123> for (p = buff; p; p = q) {\n<125> q = strchr(p, '\n');\n<129> *q++ = 0;\n<133> imlib_text_draw_with_return_metrics(x, y, p, &wid, &hig, &h_a, &v_a);
<1> static int execute_ref_pic_marking(H264Context *h, MMCO *mmco, int mmco_count){\n<193> pic= remove_short(h, h->short_ref[0]->frame_num);\n<249> if (h->short_ref_count && h->short_ref[0] == s->current_picture_ptr) {\n<301> if(h->short_ref_count)\n<303> memmove(&h->short_ref[1], &h->short_ref[0], h->short_ref_count*sizeof(Picture*));
<1> CPUState *ppc405ep_init (target_phys_addr_t ram_bases[2],\n<21> memset(clk_setup, 0, sizeof(clk_setup));\n<25> env = ppc4xx_init("405ep", &clk_setup[PPC405EP_CPU_CLK],\n<153> ppc405ep_cpc_init(env, clk_setup, sysclk);
<1> connect_to_qemu(\n<19> if (sock < 0) {\n<23> fprintf(stderr, "Error opening socket!\n");\n<31> memset(&hints, 0, sizeof(struct addrinfo));\n<43> ret = getaddrinfo(host, port, &hints, &server);\n<47> if (ret != 0) {\n<51> fprintf(stderr, "getaddrinfo failed\n");\n<59> if (connect(sock, server->ai_addr, server->ai_addrlen) < 0) {\n<63> fprintf(stderr, "Could not connect\n");\n<69> if (verbose) {\n<71> printf("Connected (sizeof Header=%zd)!\n", sizeof(VSCMsgHeader));
<1> const AVOption *av_opt_find(void *obj, const char *name, const char *unit,\n<15> (o = c->opt_find(obj, name, unit, opt_flags, search_flags)))\n<21> while (o = av_next_option(obj, o)) {\n<23> if (!strcmp(o->name, name) && (!unit || (o->unit && !strcmp(o->unit, unit))) &&\n<25> (o->flags & opt_flags) == opt_flags)\n<27> return o;
<1> static int copy_parameter_set(void **to, void **from, int count, int size)\n<11> if (to[i] && !from[i]) {\n<13> av_freep(&to[i]);\n<15> } else if (from[i] && !to[i]) {\n<17> to[i] = av_malloc(size);\n<19> if (!to[i])\n<27> if (from[i])\n<29> memcpy(to[i], from[i], size);
<1> static int vc1_decode_p_mb_intfr(VC1Context *v)\n<133> v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n<183> vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n<241> s->mb_intra = v->is_intra[s->mb_x] = 0;\n<273> ff_vc1_mc_4mv_luma(v, i, 0, 0);\n<277> ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n<315> ff_vc1_mc_4mv_chroma4(v, 0, 0, 0);\n<331> ff_vc1_mc_1mv(v, 0);\n<363> pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n<387> s->mb_intra = v->is_intra[s->mb_x] = 0;\n<411> ff_vc1_mc_1mv(v, 0);\n<415> if (s->mb_x == s->mb_width - 1)\n<417> memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0])*s->mb_stride);
<1> static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n<21> void *big_buf = NULL;\n<31> argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n<33> if (!argptr) {\n<41> thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n<49> big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n<51> memcpy(big_buf, buf_temp, target_size);\n<53> buf_temp = big_buf;\n<55> host_dm = big_buf;\n<71> host_data = (char*)host_dm + host_dm->data_start;\n<75> argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);\n<77> switch (ie->host_cmd) {\n<111> memcpy(host_data, argptr, guest_data_size);\n<117> memcpy(host_data, argptr, guest_data_size);\n<119> *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);\n<133> int spec_size = thunk_type_size(arg_type, 0);\n<139> for (i = 0; i < host_dm->target_count; i++) {\n<149> thunk_convert(spec, gspec, arg_type, THUNK_HOST);\n<151> slen = strlen((char*)gspec + spec_size) + 1;\n<155> spec->next = sizeof(*spec) + slen;\n<177> unlock_user(argptr, guest_data, 0);\n<221> struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;\n<229> int nl_size = 12; /* can't use thunk_size due to alignment */\n<237> if (next) {\n<239> nl->next = nl_size + (strlen(nl->name) + 1);\n<243> if (remaining_data < nl->next) {\n<251> thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);\n<253> strcpy(cur_data + nl_size, nl->name);\n<265> nl = (void*)nl + next;\n<291> for (i = 0; i < host_dm->target_count; i++) {\n<295> int slen = strlen((char*)&spec[1]) + 1;\n<297> spec->next = (cur_data - argptr) + spec_size + slen;\n<357> struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n<365> int vers_size = thunk_type_size(arg_type, 0);\n<373> if (next) {\n<375> vers->next = vers_size + (strlen(vers->name) + 1);\n<379> if (remaining_data < vers->next) {\n<387> thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n<389> strcpy(cur_data + vers_size, vers->name);\n<401> vers = (void*)vers + next;\n<421> argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n<439> if (big_buf) {\n<441> free(big_buf);
<1> static void vscsi_command_complete(SCSIRequest *sreq, uint32_t status)\n<13> dprintf("VSCSI: SCSI cmd complete, r=0x%x tag=0x%x status=0x%x, req=%p\n",\n<17> if (req == NULL) {\n<19> fprintf(stderr, "VSCSI: Can't find request for tag 0x%x\n", sreq->tag);
<1> static void qemu_chr_parse_udp(QemuOpts *opts, ChardevBackend *backend,\n<21> if (host == NULL || strlen(host) == 0) {\n<23> host = "localhost";\n<27> if (port == NULL || strlen(port) == 0) {\n<29> error_setg(errp, "chardev: udp: remote port not specified");\n<31> return;\n<35> if (localport == NULL || strlen(localport) == 0) {\n<37> localport = "0";\n<41> has_local = true;\n<45> if (localaddr == NULL || strlen(localaddr) == 0) {\n<47> localaddr = "";\n<51> has_local = true;\n<57> backend->udp = g_new0(ChardevUdp, 1);\n<61> addr = g_new0(SocketAddress, 1);\n<63> addr->kind = SOCKET_ADDRESS_KIND_INET;\n<65> addr->inet = g_new0(InetSocketAddress, 1);\n<67> addr->inet->host = g_strdup(host);\n<69> addr->inet->port = g_strdup(port);\n<71> addr->inet->has_ipv4 = qemu_opt_get(opts, "ipv4");\n<73> addr->inet->ipv4 = qemu_opt_get_bool(opts, "ipv4", 0);\n<75> addr->inet->has_ipv6 = qemu_opt_get(opts, "ipv6");\n<77> addr->inet->ipv6 = qemu_opt_get_bool(opts, "ipv6", 0);\n<79> backend->udp->remote = addr;\n<83> if (has_local) {\n<93> addr->inet->host = g_strdup(localaddr);\n<95> addr->inet->port = g_strdup(localport);
<1> int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n<27> ret = -2;\n<35> if (access_type == ACCESS_CODE && rw) {\n<37> printf("%s: ERROR WRITE CODE ACCESS\n", __func__);\n<53> } else if (ret < 0) {\n<133> switch (access_type) {\n<169> printf("DSI: invalid exception (%d)\n", ret);
<1> static void sun4uv_init(MemoryRegion *address_space_mem,\n<3> QEMUMachineInitArgs *args,\n<141> sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", args->ram_size,\n<175> if (args->kernel_cmdline) {\n<179> strlen(args->kernel_cmdline) + 1);\n<181> fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, args->kernel_cmdline);
<1> static unsigned int dec_move_rp(DisasContext *dc)\n<7> DIS(fprintf (logfile, "move $r%u, $p%u\n", dc->op1, dc->op2));\n<9> cris_cc_mask(dc, 0);\n<15> if (dc->op2 == PR_CCS) {\n<17> cris_evaluate_flags(dc);\n<19> t_gen_mov_TN_reg(t[0], dc->op1);\n<41> t_gen_mov_TN_reg(t[0], dc->op1);
<1> static void integratorcp_init(ram_addr_t ram_size, int vga_ram_size,\n<29> if (!env) {\n<31> fprintf(stderr, "Unable to find CPU definition\n");\n<79> if (sd == -1) {\n<81> fprintf(stderr, "qemu: missing SecureDigital card\n");\n<91> if (nd_table[0].model == NULL\n<93> || strcmp(nd_table[0].model, "smc91c111") == 0) {\n<95> smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n<97> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<99> fprintf(stderr, "qemu: Supported NICs: smc91c111\n");\n<101> exit (1);\n<105> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<107> exit (1);
<1> static VALUE cState_array_nl_set ( VALUE self , VALUE array_nl ) {\n<6> if ( len == 0 ) {\n<14> state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ;
<1> static int aio_write_f(BlockBackend *blk, int argc, char **argv)\n<87> if (ctx->zflag && optind != argc - 2) {\n<89> printf("-z supports only a single length parameter\n");\n<99> if ((flags & BDRV_REQ_MAY_UNMAP) && !ctx->zflag) {\n<101> printf("-u requires -z to be specified\n");\n<111> if (ctx->zflag && ctx->Pflag) {\n<113> printf("-z and -P cannot be specified at the same time\n");
<1> static int read_extra_header(FFV1Context *f)\n<15> memset(state2, 128, sizeof(state2));\n<17> memset(state, 128, sizeof(state));\n<27> f->version = get_symbol(c, state, 0);\n<147> (pred + get_symbol(c, state2[k], 1)) & 0xFF;
<1> static void handle_control_message(VirtIOSerial *vser, void *buf, size_t len)\n<37> if (!port && cpkt.event != VIRTIO_CONSOLE_DEVICE_READY)\n<103> send_control_event(port, VIRTIO_CONSOLE_CONSOLE_PORT, 1);\n<109> if (port->name) {\n<117> buffer_len = sizeof(cpkt) + strlen(port->name) + 1;\n<119> buffer = qemu_malloc(buffer_len);\n<123> memcpy(buffer, &cpkt, sizeof(cpkt));\n<125> memcpy(buffer + sizeof(cpkt), port->name, strlen(port->name));\n<131> send_control_msg(port, buffer, buffer_len);\n<141> send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN, 1);\n<161> port->info->guest_ready(port);
<1> av_cold int ff_dvvideo_init(AVCodecContext *avctx)\n<151> memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);
<1> static int mmap_init(AVFormatContext *ctx)\n<135> if (s->buf_start[i] == MAP_FAILED) {\n<137> av_log(ctx, AV_LOG_ERROR, "mmap: %s\n", strerror(errno));\n<141> return AVERROR(errno);
<1> static void rx_init_frame(eTSEC *etsec, const uint8_t *buf, size_t size)\n<13> if (prsdep != 0) {\n<27> memset(etsec->rx_fcb, 0x0, sizeof(etsec->rx_fcb));
<1> static void rtas_nvram_fetch(sPAPREnvironment *spapr,\n<31> if (!nvram) {\n<47> len = rtas_ld(args, 2);\n<51> if (((offset + len) < offset)\n<65> membuf = cpu_physical_memory_map(buffer, &len, 1);\n<67> if (nvram->drive) {\n<73> assert(nvram->buf);\n<77> memcpy(membuf, nvram->buf + offset, len);\n<79> alen = len;\n<83> cpu_physical_memory_unmap(membuf, len, 1, len);
<1> static int huffman_decode(MPADecodeContext *s, GranuleDef *g,\n<41> if(!l){\n<43> memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid)*j);\n<247> memset(&g->sb_hybrid[s_index], 0, sizeof(*g->sb_hybrid)*(576 - s_index));
<1> RxFilterInfoList *qmp_query_rx_filter(bool has_name, const char *name,\n<13> QTAILQ_FOREACH(nc, &net_clients, next) {\n<21> if (has_name && strcmp(nc->name, name) != 0) {\n<35> error_setg(errp, "net client(%s) isn't a NIC", name);\n<49> info = nc->info->query_rx_filter(nc);\n<71> error_setg(errp, "net client(%s) doesn't support"\n<91> if (filter_list == NULL && !error_is_set(errp) && has_name) {\n<93> error_setg(errp, "invalid net client name: %s", name);
<1> static gcry_err_code_t sexp_elements_extract ( gcry_sexp_t key_sexp , const char * element_names , gcry_mpi_t * elements , const char * algo_name ) {\n<21> if ( * name ) {\n<23> if ( algo_name && ! strcmp ( algo_name , "RSA" ) && ! strcmp ( element_names , "nedpqu" ) ) {\n<24> if ( elements [ 0 ] && elements [ 1 ] && elements [ 2 ] && ! elements [ 3 ] && ! elements [ 4 ] && ! elements [ 5 ] ) err = 0 ;
<1> int ff_h263_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<7> const uint8_t *buf = avpkt->data;\n<63> next = ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);\n<67> next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n<71> next = ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n<103> if (buf[i]==0 && buf[i+1]==0 && buf[i+2]==1) {\n<105> if (buf[i+3]==0xB0) {\n<131> ret = init_get_bits8(&s->gb, buf, buf_size);\n<507> ff_MPV_frame_end(s);\n<531> if (buf[i]     == 0 &&\n<533> buf[i + 1] == 0 &&\n<535> buf[i + 2] == 1 &&\n<537> buf[i + 3] == 0xB6) {\n<539> startcode_found = !(buf[i + 4] & 0x40);\n<555> buf_size - current_pos +\n<559> if (!s->bitstream_buffer)\n<565> buf_size - current_pos);\n<591> ff_print_debug_info(s, s->current_picture_ptr, pict);\n<593> ff_mpv_export_qp_table(s, pict, s->current_picture_ptr, FF_QSCALE_TYPE_MPEG1);\n<601> ff_print_debug_info(s, s->last_picture_ptr, pict);\n<603> ff_mpv_export_qp_table(s, pict, s->last_picture_ptr, FF_QSCALE_TYPE_MPEG1);\n<653> return get_consumed_bytes(s, buf_size);
<1> bool ans_key_h ( connection_t * c ) {\n<4> char key [ MAX_STRING_SIZE ] ;\n<18> if ( ! from ) {\n<27> if ( to != myself ) {\n<35> if ( ! * address && from -> address . sa . sa_family != AF_UNSPEC && to -> minmtu ) {\n<38> sockaddr2str ( & from -> address , & address , & port ) ;\n<39> send_request ( to -> nexthop -> connection , "%s %s %s" , c -> buffer , address , port ) ;\n<40> free ( address ) ;\n<41> free ( port ) ;\n<47> from -> outkey = xrealloc ( from -> outkey , strlen ( key ) / 2 ) ;\n<48> from -> outkeylength = strlen ( key ) / 2 ;\n<49> if ( ! hex2bin ( key , from -> outkey , from -> outkeylength ) ) {
<1> send_msg(\n<3> VSCMsgType type,\n<5> uint32_t reader_id,\n<9> unsigned int length\n<21> if (verbose > 10) {\n<23> printf("sending type=%d id=%u, len =%u (0x%x)\n",\n<31> mhHeader.type = htonl(type);\n<35> mhHeader.length = htonl(length);
<1> static void omap_prcm_write(void *opaque, hwaddr addr,\n<527> if (value & 0xffffff30)\n<529> fprintf(stderr, "%s: write 0s in CM_CLKEN_PLL for "\n<565> if (value & 0xfc4000d7)\n<567> fprintf(stderr, "%s: write 0s in CM_CLKSEL1_PLL for "\n<589> if (value & ~3)\n<591> fprintf(stderr, "%s: write 0s in CM_CLKSEL2_PLL[31:2] for "
<1> static Asn1Generic * DecodeAsn1DerOctetString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n<6> d_ptr ++ ;\n<10> d_ptr ++ ;\n<14> d_ptr ++ ;\n<15> if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {\n<19> if ( length > max_size ) return NULL ;\n<21> if ( a == NULL ) return NULL ;\n<25> if ( a -> str == NULL ) {\n<29> memcpy ( a -> str , ( const char * ) d_ptr , length ) ;\n<31> d_ptr += length ;\n<33> return a ;
<1> static int write_elf64_load(DumpState *s, MemoryMapping *memory_mapping,\n<15> memset(&phdr, 0, sizeof(Elf64_Phdr));\n<41> ret = fd_write_vmcore(&phdr, sizeof(Elf64_Phdr), s);
<1> int av_packet_copy_props(AVPacket *dst, const AVPacket *src)\n<33> uint8_t *src_data = src->side_data[i].data;\n<35> uint8_t *dst_data = av_packet_new_side_data(dst, type, size);\n<39> if (!dst_data) {\n<47> memcpy(dst_data, src_data, size);
<1> static int add_file(AVFormatContext *avf, char *filename, ConcatFile **rfile,\n<17> url_len = strlen(avf->filename) + strlen(filename) + 16;\n<19> if (!(url = av_malloc(url_len)))\n<23> ff_make_absolute_url(url, url_len, avf->filename, filename);\n<29> if (cat->nb_files >= *nb_files_alloc) {\n<35> if (n <= cat->nb_files || n > SIZE_MAX / sizeof(*cat->files) ||\n<49> file = &cat->files[cat->nb_files++];\n<51> memset(file, 0, sizeof(*file));\n<53> *rfile = file;
<1> static int vnc_set_x509_credential(VncDisplay *vs,\n<3> const char *certdir,\n<5> const char *filename,\n<27> *cred = qemu_malloc(strlen(certdir) + strlen(filename) + 2);\n<31> strcpy(*cred, certdir);\n<33> strcat(*cred, "/");\n<35> strcat(*cred, filename);\n<39> VNC_DEBUG("Check %s\n", *cred);
<1> static void ich9_cc_write(void *opaque, hwaddr addr,\n<3> uint64_t val, unsigned len)\n<7> ICH9LPCState *lpc = (ICH9LPCState *)opaque;\n<11> ich9_cc_addr_len(&addr, &len);\n<13> memcpy(lpc->chip_config + addr, &val, len);
<1> static int mov_read_smi(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n<23> if (!st->codec->extradata)\n<29> memcpy(st->codec->extradata, "SVQ3", 4); // fake\n<31> get_buffer(pb, st->codec->extradata + 0x5a, atom.size);
<1> static void ne2000_receive(void *opaque, const uint8_t *buf, int size)\n<5> NE2000State *s = opaque;\n<11> uint8_t buf1[60];\n<27> if (s->cmd & E8390_STOP || ne2000_buffer_full(s))\n<35> if (s->rxcr & 0x10) {\n<41> if (!memcmp(buf,  broadcast_macaddr, 6)) {\n<45> if (!(s->rxcr & 0x04))\n<49> } else if (buf[0] & 0x01) {\n<57> mcast_idx = compute_mcast_idx(buf);\n<63> } else if (s->mem[0] == buf[0] &&\n<65> s->mem[2] == buf[1] &&\n<67> s->mem[4] == buf[2] &&\n<69> s->mem[6] == buf[3] &&\n<71> s->mem[8] == buf[4] &&\n<73> s->mem[10] == buf[5]) {\n<91> if (size < MIN_BUF_SIZE) {\n<93> memcpy(buf1, buf, size);\n<95> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<97> buf = buf1;\n<127> if (buf[0] & 0x01)\n<145> while (size > 0) {\n<147> avail = s->stop - index;\n<151> if (len > avail)\n<153> len = avail;\n<155> memcpy(s->mem + index, buf, len);\n<157> buf += len;\n<159> index += len;\n<165> size -= len;
<1> static int usb_device_add(const char *devname, int is_hotplug)\n<17> if (strstart(devname, "host:", &p)) {\n<21> } else if (!strcmp(devname, "mouse")) {\n<23> dev = usb_mouse_init();\n<25> } else if (!strcmp(devname, "tablet")) {\n<27> dev = usb_tablet_init();\n<29> } else if (!strcmp(devname, "keyboard")) {\n<31> dev = usb_keyboard_init();\n<33> } else if (strstart(devname, "disk:", &p)) {\n<59> } else if (!strcmp(devname, "wacom-tablet")) {\n<61> dev = usb_wacom_init();\n<63> } else if (strstart(devname, "serial:", &p)) {\n<75> } else if (strstart(devname, "net:", &p)) {\n<89> } else if (!strcmp(devname, "bt") || strstart(devname, "bt:", &p)) {\n<91> dev = usb_bt_init(devname[2] ? hci_init(p) :\n<97> return -1;\n<101> if (!dev)
<1> static uint8_t virtio_scsi_do_command(QVirtIOSCSI *vs, const uint8_t *cdb,\n<15> struct virtio_scsi_cmd_req req = { { 0 } };\n<35> memcpy(req.cdb, cdb, VIRTIO_SCSI_CDB_SIZE);
<1> int qemu_loadvm_state(QEMUFile *f)\n<29> if (v == QEMU_VM_FILE_VERSION_COMPAT) {\n<31> fprintf(stderr, "SaveVM v2 format is obsolete and don't work anymore\n");\n<43> while ((section_type = qemu_get_byte(f)) != QEMU_VM_EOF) {\n<69> idstr[len] = 0;\n<79> se = find_se(idstr, instance_id);\n<81> if (se == NULL) {\n<83> fprintf(stderr, "Unknown savevm section or instance '%s' %d\n", idstr, instance_id);\n<95> if (version_id > se->version_id) {\n<97> fprintf(stderr, "savevm: unsupported version %d for '%s' v%d\n",\n<129> fprintf(stderr, "qemu: warning: error while loading state for instance 0x%x of device '%s'\n",\n<149> if (le->section_id == section_id) {\n<159> fprintf(stderr, "Unknown savevm section %d\n", section_id);\n<173> fprintf(stderr, "qemu: warning: error while loading state section id %d\n",\n<185> fprintf(stderr, "Unknown savevm section type %d\n", section_type);
<1> void qemu_spice_display_resize(SimpleSpiceDisplay *ssd)\n<11> memset(&ssd->dirty, 0, sizeof(ssd->dirty));\n<23> qemu_spice_create_host_primary(ssd);\n<29> memset(&ssd->dirty, 0, sizeof(ssd->dirty));
<1> aio_read_f(int argc, char **argv)\n<7> struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n<13> while ((c = getopt(argc, argv, "CP:qv")) != EOF) {\n<15> switch (c) {\n<19> ctx->Cflag = 1;\n<25> ctx->Pflag = 1;\n<27> ctx->pattern = atoi(optarg);\n<33> ctx->qflag = 1;\n<39> ctx->vflag = 1;\n<45> free(ctx);\n<55> if (optind > argc - 2) {\n<57> free(ctx);\n<65> ctx->offset = cvtnum(argv[optind]);\n<67> if (ctx->offset < 0) {\n<69> printf("non-numeric length argument -- %s\n", argv[optind]);\n<71> free(ctx);\n<81> if (ctx->offset & 0x1ff) {\n<85> (long long)ctx->offset);\n<87> free(ctx);\n<97> ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, 0xab);\n<101> gettimeofday(&ctx->t1, NULL);\n<103> acb = bdrv_aio_readv(bs, ctx->offset >> 9, &ctx->qiov,\n<107> if (!acb) {\n<109> free(ctx->buf);\n<111> free(ctx);
<1> static void mxf_write_identification(AVFormatContext *s)\n<9> const char *company = "Libav";\n<11> const char *product = "OP1a Muxer";\n<25> version = s->streams[0]->codec->flags & CODEC_FLAG_BITEXACT ?\n<29> length = 84 + (strlen(company)+strlen(product)+strlen(version))*2; // utf-16\n<31> klv_encode_ber_length(pb, length);\n<53> mxf_write_local_tag_utf16(pb, 0x3C01, company); // Company Name\n<55> mxf_write_local_tag_utf16(pb, 0x3C02, product); // Product Name\n<57> mxf_write_local_tag_utf16(pb, 0x3C04, version); // Version String
<1> CPUAlphaState * cpu_alpha_init (const char *cpu_model)\n<33> for (i = 0; i < max; i++) {\n<35> if (strcmp (cpu_model, cpu_defs[i].name) == 0) {\n<37> implver = cpu_defs[i].implver;\n<39> amask = cpu_defs[i].amask;
<1> void save_config ( struct recvbuf * rbufp , int restrict_mask ) {\n<12> snprintf ( reply , sizeof ( reply ) , "saveconfig prohibited by restrict ... nomodify" ) ;\n<13> ctl_putdata ( reply , strlen ( reply ) , 0 ) ;
<1> int evbuffer_add ( struct evbuffer * buf , const void * data , size_t datlen ) {\n<4> if ( buf -> totallen < need ) {\n<5> if ( evbuffer_expand ( buf , datlen ) == - 1 ) return ( - 1 ) ;\n<7> memcpy ( buf -> buffer + buf -> off , data , datlen ) ;\n<8> buf -> off += datlen ;\n<9> if ( datlen && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;
<1> static int transcode(void)\n<23> if (!(no_packet = av_mallocz(nb_input_files)))\n<109> if (key == 'c' || key == 'C'){\n<111> char buf[4096], target[64], command[256], arg[256] = {0};\n<117> fprintf(stderr, "\nEnter command: <target> <time> <command>[ <argument>]\n");\n<125> buf[i++] = k;\n<127> buf[i] = 0;\n<129> if (k > 0 &&\n<131> (n = sscanf(buf, "%63[^ ] %lf %255[^ ] %255[^\n]", target, &time, command, arg)) >= 3) {\n<133> av_log(NULL, AV_LOG_DEBUG, "Processing command target:%s time:%f command:%s arg:%s",\n<137> for (i = 0; i < nb_filtergraphs; i++) {\n<143> if (time < 0) {\n<145> ret = avfilter_graph_send_command(fg->graph, target, command, arg, buf, sizeof(buf),\n<149> fprintf(stderr, "Command reply for stream %d: ret:%d res:%s\n", i, ret, buf);\n<153> ret = avfilter_graph_queue_command(fg->graph, target, command, arg, 0, time);\n<173> if (key == 'd' || key == 'D'){\n<175> int debug=0;\n<177> if(key == 'D') {\n<181> if(!debug) debug = 1;\n<183> while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n<185> debug += debug;\n<189> if(scanf("%d", &debug)!=1)\n<191> fprintf(stderr,"error parsing debug value\n");\n<195> input_streams[i]->st->codec->debug = debug;\n<203> ost->st->codec->debug = debug;\n<209> fprintf(stderr,"debug=%d\n", debug);\n<213> if (key == '?'){\n<255> file_index = select_input_file(no_packet);\n<261> if (no_packet_count) {\n<265> memset(no_packet, 0, nb_input_files);\n<287> no_packet[file_index] = 1;\n<295> if (ret < 0) {\n<327> memset(no_packet, 0, nb_input_files);\n<595> av_freep(&no_packet);
<1> START_TEST(vararg_string)\n<23> for (i = 0; test_cases[i].decoded; i++) {\n<31> obj = qobject_from_jsonf("%s", test_cases[i].decoded);\n<43> fail_unless(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
<1> static int bt_hci_parse(const char *str)\n<11> if (nb_hcis >= MAX_NICS) {\n<13> fprintf(stderr, "qemu: Too many bluetooth HCIs (max %i).\n", MAX_NICS);
<1> static void qemu_kill_report(void)\n<5> if (!qtest_driver() && shutdown_signal != -1) {\n<7> fprintf(stderr, "qemu: terminating on signal %d", shutdown_signal);\n<17> fputc('\n', stderr);
<1> static char *pcibus_get_fw_dev_path(DeviceState *dev)\n<23> return strdup(path);
<1> int main(int argc, char **argv, char **envp)\n<179> popt = lookup_opt(argc, argv, &optarg, &optind);\n<247> popt = lookup_opt(argc, argv, &optarg, &optind);\n<249> if (!(popt->arch_mask & arch_type)) {\n<251> printf("Option %s not supported for this target\n", popt->name);\n<257> switch(popt->index) {\n<261> machine = machine_parse(optarg);\n<269> if (*optarg == '?') {\n<271> list_cpus(stdout, &fprintf, optarg);\n<277> cpu_model = optarg;\n<285> initrd_filename = optarg;\n<315> drive_add(IF_DEFAULT, 0, optarg, buf);\n<327> drive_add(IF_DEFAULT, popt->index - QEMU_OPTION_hda, optarg,\n<335> if (drive_def(optarg) == NULL) {\n<345> if (qemu_set_option(optarg) != 0)\n<353> if (qemu_global_option(optarg) != 0)\n<361> drive_add(IF_MTD, -1, optarg, MTD_OPTS);\n<367> drive_add(IF_SD, 0, optarg, SD_OPTS);\n<373> drive_add(IF_PFLASH, -1, optarg, PFLASH_OPTS);\n<389> p = optarg;\n<393> if (cyls < 1 || cyls > 16383)\n<397> if (*p != ',')\n<401> p++;\n<405> if (heads < 1 || heads > 16)\n<409> if (*p != ',')\n<413> p++;\n<417> if (secs < 1 || secs > 63)\n<421> if (*p == ',') {\n<423> p++;\n<425> if (!strcmp(p, "none"))\n<427> translation = BIOS_ATA_TRANSLATION_NONE;\n<429> else if (!strcmp(p, "lba"))\n<431> translation = BIOS_ATA_TRANSLATION_LBA;\n<433> else if (!strcmp(p, "auto"))\n<435> translation = BIOS_ATA_TRANSLATION_AUTO;\n<441> } else if (*p != '\0') {\n<445> fprintf(stderr, "qemu: invalid physical CHS format\n");\n<447> exit(1);\n<483> if (nb_numa_nodes >= MAX_NODES) {\n<485> fprintf(stderr, "qemu: too many NUMA nodes\n");\n<491> numa_add(optarg);\n<497> display_type = select_display(optarg);\n<515> fprintf(stderr, "Curses support is disabled\n");\n<531> graphic_rotate = strtol(optarg, (char **) &optarg, 10);\n<549> kernel_filename = optarg;\n<555> kernel_cmdline = optarg;\n<561> drive_add(IF_DEFAULT, 2, optarg, CDROM_OPTS);\n<585> if (!strchr(optarg, '=')) {\n<587> legacy = 1;\n<589> pstrcpy(buf, sizeof(buf), optarg);\n<591> } else if (check_params(buf, sizeof(buf), params, optarg) < 0) {\n<607> get_param_value(buf, sizeof(buf), "order", optarg)) {\n<609> validate_bootdevices(buf);\n<637> if (!strcmp(buf, "on")) {\n<639> boot_menu = 1;\n<641> } else if (!strcmp(buf, "off")) {\n<643> boot_menu = 0;\n<653> exit(1);\n<673> drive_add(IF_FLOPPY, popt->index - QEMU_OPTION_fda,\n<687> if (net_client_parse(qemu_find_opts("netdev"), optarg) == -1) {\n<697> if (net_client_parse(qemu_find_opts("net"), optarg) == -1) {\n<731> add_device_config(DEV_BT, optarg);\n<737> if (!(audio_available())) {\n<739> printf("Option %s not supported for this target\n", popt->name);\n<753> if (!(audio_available())) {\n<755> printf("Option %s not supported for this target\n", popt->name);\n<761> select_soundhw (optarg);\n<787> value = strtosz(optarg, &end);\n<789> if (value < 0 || *end) {\n<791> fprintf(stderr, "qemu: invalid ram size: %s\n", optarg);\n<799> if (value != (uint64_t)(ram_addr_t)value) {\n<801> fprintf(stderr, "qemu: ram size too large\n");\n<815> mem_path = optarg;\n<831> log_mask = optarg;\n<837> log_file = optarg;\n<849> gdbstub_dev = optarg;\n<855> data_dir = optarg;\n<861> bios_name = optarg;\n<879> keyboard_layout = optarg;\n<891> select_vgahw (optarg);\n<903> p = optarg;\n<907> if (w <= 0) {\n<911> fprintf(stderr, "qemu: invalid resolution or depth\n");\n<917> if (*p != 'x')\n<921> p++;\n<925> if (h <= 0)\n<929> if (*p == 'x') {\n<931> p++;\n<941> } else if (*p == '\0') {\n<969> term_escape_char = strtol(optarg, &r, 0);\n<971> if (r == optarg)\n<973> printf("Bad argument to echr\n");\n<981> monitor_parse(optarg, "readline");\n<989> monitor_parse(optarg, "control");\n<997> opts = qemu_opts_parse(qemu_find_opts("mon"), optarg, 1);\n<1011> opts = qemu_opts_parse(qemu_find_opts("chardev"), optarg, 1);\n<1025> if (!olist) {\n<1027> fprintf(stderr, "fsdev is not supported by this qemu build.\n");\n<1033> opts = qemu_opts_parse(olist, optarg, 1);\n<1035> if (!opts) {\n<1037> fprintf(stderr, "parse error: %s\n", optarg);\n<1057> if (!olist) {\n<1059> fprintf(stderr, "virtfs is not supported by this qemu build.\n");\n<1065> opts = qemu_opts_parse(olist, optarg, 1);\n<1067> if (!opts) {\n<1069> fprintf(stderr, "parse error: %s\n", optarg);\n<1083> fprintf(stderr, "Usage: -virtfs fsdriver,path=/share_path/,"\n<1097> if (!fsdev) {\n<1101> qemu_opt_get(opts, "mount_tag"));\n<1111> if (writeout) {\n<1119> fprintf(stderr, "writeout=immediate not supported on "\n<1169> if (!fsdev) {\n<1171> fprintf(stderr, "duplicate option: %s\n", "virtfs_synth");\n<1197> add_device_config(DEV_SERIAL, optarg);\n<1201> if (strncmp(optarg, "mon:", 4) == 0) {\n<1211> if (watchdog) {\n<1221> watchdog = optarg;\n<1227> if (select_watchdog_action(optarg) == -1) {\n<1229> fprintf(stderr, "Unknown -watchdog-action parameter\n");\n<1239> add_device_config(DEV_VIRTCON, optarg);\n<1243> if (strncmp(optarg, "mon:", 4) == 0) {\n<1253> add_device_config(DEV_PARALLEL, optarg);\n<1257> if (strncmp(optarg, "mon:", 4) == 0) {\n<1267> add_device_config(DEV_DEBUGCON, optarg);\n<1273> loadvm = optarg;\n<1327> fprintf(stderr, "SDL support is disabled\n");\n<1335> pid_file = optarg;\n<1353> do_acpitable_option(optarg);\n<1359> do_smbios_option(optarg);\n<1379> opts = qemu_opts_parse(olist, optarg, 1);\n<1381> if (!opts) {\n<1383> fprintf(stderr, "parse error: %s\n", optarg);\n<1389> optarg = qemu_opt_get(opts, "type");\n<1393> machine = machine_parse(optarg);\n<1409> add_device_config(DEV_USB, optarg);\n<1415> if (!qemu_opts_parse(qemu_find_opts("device"), optarg, 1)) {\n<1425> smp_parse(optarg);\n<1427> if (smp_cpus < 1) {\n<1429> fprintf(stderr, "Invalid number of CPUs\n");\n<1435> if (max_cpus < smp_cpus) {\n<1437> fprintf(stderr, "maxcpus must be equal to or greater than "\n<1445> if (max_cpus > 255) {\n<1447> fprintf(stderr, "Unsupported number of maxcpus\n");\n<1465> fprintf(stderr, "VNC support is disabled\n");\n<1487> if (balloon_parse(optarg) < 0) {\n<1489> fprintf(stderr, "Unknown -balloon argument %s\n", optarg);\n<1517> if(qemu_uuid_parse(optarg, qemu_uuid) < 0) {\n<1531> if (nb_option_roms >= MAX_OPTION_ROMS) {\n<1533> fprintf(stderr, "Too many option ROMs\n");\n<1539> opts = qemu_opts_parse(qemu_find_opts("option-rom"), optarg, 1);\n<1547> if (!option_rom[nb_option_roms].name) {\n<1549> fprintf(stderr, "Option ROM file is not specified\n");\n<1567> qemu_name = g_strdup(optarg);\n<1571> char *p = strchr(qemu_name, ',');\n<1573> if (p != NULL) {\n<1577> if (strncmp(p, "process=", 8)) {\n<1579> fprintf(stderr, "Unknown subargument %s to -name\n", p);\n<1585> p += 8;\n<1597> if (nb_prom_envs >= MAX_PROM_ENVS) {\n<1599> fprintf(stderr, "Too many prom variables\n");\n<1605> prom_envs[nb_prom_envs] = optarg;\n<1619> configure_alarms(optarg);\n<1625> configure_rtc_date_offset(optarg, 1);\n<1631> opts = qemu_opts_parse(qemu_find_opts("rtc"), optarg, 0);\n<1645> tcg_tb_size = strtol(optarg, NULL, 0);\n<1657> icount_option = optarg;\n<1663> incoming = optarg;\n<1691> if (!(xen_available())) {\n<1693> printf("Option %s not supported for this target\n", popt->name);\n<1699> xen_domid = atoi(optarg);\n<1705> if (!(xen_available())) {\n<1707> printf("Option %s not supported for this target\n", popt->name);\n<1719> if (!(xen_available())) {\n<1721> printf("Option %s not supported for this target\n", popt->name);\n<1735> opts = qemu_opts_parse(qemu_find_opts("trace"), optarg, 0);\n<1755> int ret = qemu_read_config_file(optarg);\n<1757> if (ret < 0) {\n<1759> fprintf(stderr, "read config %s: %s\n", optarg,\n<1761> strerror(-ret));\n<1775> if (!olist) {\n<1777> fprintf(stderr, "spice is not supported by this qemu build.\n");\n<1783> opts = qemu_opts_parse(olist, optarg, 0);\n<1785> if (!opts) {\n<1787> fprintf(stderr, "parse error: %s\n", optarg);\n<1801> if (strcmp(optarg, "-") == 0) {\n<1803> fp = stdout;\n<1807> fp = fopen(optarg, "w");\n<1809> if (fp == NULL) {\n<1811> fprintf(stderr, "open %s: %s\n", optarg, strerror(errno));\n<1829> os_parse_cmd_args(popt->index, optarg);\n<1893> if (machine == NULL) {\n<1895> fprintf(stderr, "No machine found.\n");\n<1919> if (smp_cpus > machine->max_cpus) {\n<1921> fprintf(stderr, "Number of SMP cpus requested (%d), exceeds max cpus "\n<1959> opts = qemu_opts_parse(list, machine->default_machine_opts, 0);\n<1961> if (!opts) {\n<1963> fprintf(stderr, "parse error for machine %s: %s\n",\n<2133> if (qemu_init_main_loop()) {\n<2135> fprintf(stderr, "qemu_init_main_loop failed\n");\n<2145> if (!linux_boot && *kernel_cmdline != '\0') {\n<2147> fprintf(stderr, "-append only allowed with -kernel option\n");\n<2155> if (!linux_boot && initrd_filename != NULL) {\n<2157> fprintf(stderr, "-initrd only allowed with -kernel option\n");\n<2169> if (init_timer_alarm() < 0) {\n<2171> fprintf(stderr, "could not initialize alarm timer\n");\n<2179> if (icount_option && (kvm_enabled() || xen_enabled())) {\n<2181> fprintf(stderr, "-icount is not allowed with kvm or xen\n");\n<2211> if (ram_size > (2047 << 20) && HOST_LONG_BITS == 32) {\n<2213> fprintf(stderr, "qemu: at most 2047 MB RAM can be simulated\n");\n<2427> current_machine = machine;\n<2601> if (gdbstub_dev && gdbserver_start(gdbstub_dev) < 0) {\n<2603> fprintf(stderr, "qemu: could not open gdbserver on device '%s'\n",\n<2617> if (rom_load_all() != 0) {\n<2619> fprintf(stderr, "rom loading failed\n");\n<2655> int ret = qemu_start_incoming_migration(incoming);\n<2657> if (ret < 0) {\n<2659> fprintf(stderr, "Migration failed. Exit code %s(%d), exiting.\n",\n<2663> exit(ret);
<1> static int roq_encode_video(RoqContext *enc)\n<5> RoqTempdata *tempData = enc->tmpData;\n<11> memset(tempData, 0, sizeof(*tempData));\n<15> ret = create_cel_evals(enc, tempData);\n<23> ret = generate_new_codebooks(enc, tempData);\n<45> gather_data_for_cel(tempData->cel_evals + i, enc, tempData);\n<51> if (tempData->mainChunkSize/8 > 65535) {\n<65> memset(tempData->used_option, 0, sizeof(tempData->used_option));\n<83> remap_codebooks(enc, tempData);\n<87> write_codebooks(enc, tempData);\n<91> reconstruct_and_encode_image(enc, tempData, enc->width, enc->height,
<1> int ff_pnm_decode_header(AVCodecContext *avctx, PNMContext * const s)\n<13> s->type= buf1[1]-'0';\n<15> if(buf1[0] != 'P')\n<39> } else if (s->type==7) {\n<53> pnm_get(s, buf1, sizeof(buf1));\n<55> if (!strcmp(buf1, "WIDTH")) {\n<57> pnm_get(s, buf1, sizeof(buf1));\n<59> w = strtol(buf1, NULL, 10);\n<61> } else if (!strcmp(buf1, "HEIGHT")) {\n<63> pnm_get(s, buf1, sizeof(buf1));\n<65> h = strtol(buf1, NULL, 10);\n<67> } else if (!strcmp(buf1, "DEPTH")) {\n<69> pnm_get(s, buf1, sizeof(buf1));\n<71> depth = strtol(buf1, NULL, 10);\n<73> } else if (!strcmp(buf1, "MAXVAL")) {\n<75> pnm_get(s, buf1, sizeof(buf1));\n<77> maxval = strtol(buf1, NULL, 10);\n<79> } else if (!strcmp(buf1, "TUPLTYPE") ||\n<83> !strcmp(buf1, "TUPLETYPE")) {\n<85> pnm_get(s, tuple_type, sizeof(tuple_type));\n<87> } else if (!strcmp(buf1, "ENDHDR")) {\n<93> return AVERROR_INVALIDDATA;\n<101> if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\0' || av_image_check_size(w, h, 0, avctx) || s->bytestream >= s->bytestream_end)
<1> OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n<6> ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n<9> if ( pduLength < 2 + 2 + 16 + 16 + 32 ) return makeLengthError ( "associate PDU" , pduLength , 2 + 2 + 16 + 16 + 32 ) ;\n<12> EXTRACT_LONG_BIG ( buf , assoc -> length ) ;\n<14> EXTRACT_SHORT_BIG ( buf , assoc -> protocol ) ;\n<17> if ( ( assoc -> protocol & DUL_PROTOCOL ) == 0 ) {\n<25> assoc -> rsv2 [ 1 ] = * buf ++ ;\n<27> ( void ) strncpy ( assoc -> calledAPTitle , ( char * ) buf , 16 ) ;\n<29> trim_trailing_spaces ( assoc -> calledAPTitle ) ;\n<30> buf += 16 ;\n<32> ( void ) strncpy ( assoc -> callingAPTitle , ( char * ) buf , 16 ) ;\n<34> trim_trailing_spaces ( assoc -> callingAPTitle ) ;\n<35> buf += 16 ;\n<37> ( void ) memcpy ( assoc -> rsv3 , buf , 32 ) ;\n<38> buf += 32 ;\n<43> if ( assoc -> type == DUL_TYPEASSOCIATERQ ) s = "A-ASSOCIATE RQ" ;\n<44> else if ( assoc -> type == DUL_TYPEASSOCIATEAC ) s = "A-ASSOCIATE AC" ;\n<51> switch ( type ) {\n<52> case DUL_TYPEAPPLICATIONCONTEXT : cond = parseSubItem ( & assoc -> applicationContext , buf , & itemLength , pduLength ) ;\n<59> case DUL_TYPEPRESENTATIONCONTEXTRQ : case DUL_TYPEPRESENTATIONCONTEXTAC : context = ( PRV_PRESENTATIONCONTEXTITEM * ) malloc ( sizeof ( PRV_PRESENTATIONCONTEXTITEM ) ) ;\n<60> if ( context == NULL ) return EC_MemoryExhausted ;\n<61> ( void ) memset ( context , 0 , sizeof ( * context ) ) ;\n<62> cond = parsePresentationContext ( type , context , buf , & itemLength , pduLength ) ;\n<66> LST_Enqueue ( & assoc -> presentationContextList , ( LST_NODE * ) context ) ;\n<69> case DUL_TYPEUSERINFO : cond = parseUserInfo ( & assoc -> userInfo , buf , & itemLength , assoc -> type , pduLength ) ;
<1> static int qemu_gluster_parse_uri(BlockdevOptionsGluster *gconf,\n<21> if (!uri) {\n<37> if (!uri->scheme || !strcmp(uri->scheme, "gluster")) {\n<39> gsconf->type = SOCKET_ADDRESS_TYPE_INET;\n<41> } else if (!strcmp(uri->scheme, "gluster+tcp")) {\n<43> gsconf->type = SOCKET_ADDRESS_TYPE_INET;\n<45> } else if (!strcmp(uri->scheme, "gluster+unix")) {\n<47> gsconf->type = SOCKET_ADDRESS_TYPE_UNIX;\n<49> is_unix = true;\n<51> } else if (!strcmp(uri->scheme, "gluster+rdma")) {\n<53> gsconf->type = SOCKET_ADDRESS_TYPE_INET;\n<55> error_report("Warning: rdma feature is not supported, falling "\n<61> ret = -EINVAL;\n<69> ret = parse_volume_options(gconf, uri->path);\n<71> if (ret < 0) {\n<93> if (uri->server || uri->port) {\n<101> if (strcmp(qp->p[0].name, "socket")) {\n<103> ret = -EINVAL;\n<109> gsconf->u.q_unix.path = g_strdup(qp->p[0].value);\n<137> uri_free(uri);
<1> static int decode_vol_header(MpegEncContext *s, GetBitContext *gb){\n<49> if(chroma_format!=1){\n<51> printf("illegal chroma format\n");\n<97> if(s->shape != RECT_SHAPE) printf("only rectangular vol supported\n");\n<99> if(s->shape == GRAY_SHAPE && vo_ver_id != 1){\n<101> printf("Gray shape not supported\n");\n<165> if(!get_bits1(gb)) printf("OBMC not supported (very likely buggy encoder)\n");   /* OBMC Disable */\n<177> if(s->vol_sprite_usage==STATIC_SPRITE) printf("Static Sprites not supported\n");\n<221> if(get_bits(gb, 4)!=8) printf("N-bit not supported\n"); /* bits_per_pixel */\n<223> if(s->quant_precision!=5) printf("quant precission %d\n", s->quant_precision);\n<369> if(!get_bits1(gb)) printf("Complexity estimation not supported\n");\n<383> if(s->rvlc){\n<385> printf("reversible vlc not supported\n");\n<397> if(s->new_pred){\n<399> printf("new pred not supported\n");\n<409> if(s->reduced_res_vop) printf("reduced resolution VOP not supported\n");\n<463> if(   h_sampling_factor_n==0 || h_sampling_factor_m==0\n<479> printf("scalability not supported\n");
<1> void bios_linker_loader_add_checksum(GArray *linker, const char *file,\n<31> memset(&entry, 0, sizeof entry);\n<33> strncpy(entry.cksum.file, file, sizeof entry.cksum.file - 1);\n<45> g_array_append_vals(linker, &entry, sizeof entry);
<1> void ppc_hw_interrupt (CPUPPCState *env)\n<11> if (loglevel & CPU_LOG_INT) {\n<13> fprintf(logfile, "%s: %p pending %08x req %08x me %d ee %d\n",\n<25> if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {\n<37> env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);\n<43> if (raised == 0 && msr_me != 0) {\n<47> if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {\n<51> env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);\n<59> if (raised == 0 && msr_ee != 0) {\n<79> if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {\n<83> env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);\n<89> } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {\n<93> env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n<99> } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n<103> env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n<109> } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n<113> env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n<119> } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n<173> do_interrupt(env);
<1> static void h245_setup_channels ( packet_info * pinfo , channel_info_t * upcoming_channel_lcl ) {\n<5> if ( ! upcoming_channel_lcl ) return ;\n<6> if ( ! strcmp ( upcoming_channel_lcl -> data_type_str , "t38fax" ) ) {\n<7> if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n<10> return ;\n<12> if ( upcoming_channel_lcl -> rfc2198 > 0 ) {\n<21> if ( upcoming_channel_lcl -> srtp_flag ) {\n<24> if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n<27> if ( upcoming_channel_lcl -> media_control_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_control_addr . port != 0 && rtcp_handle ) {
<1> static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,\n<21> if (!user_data)\n<33> user_data[i] = 0;\n<35> e = sscanf(user_data + 16, "x264 - core %d", &build);\n<37> if (e == 1 && build > 0)\n<39> h->x264_build = build;\n<41> if (e == 1 && build == 1 && !strncmp(user_data+16, "x264 - core 0000", 16))\n<47> if (strlen(user_data + 16) > 0)\n<49> av_log(logctx, AV_LOG_DEBUG, "user data:\"%s\"\n", user_data + 16);
<1> matroska_probe (AVProbeData *p)\n<69> for (n = 4 + size; n <= 4 + size + total - sizeof(probe_data); n++)\n<71> if (!memcmp (&p->buf[n], probe_data, sizeof(probe_data)))\n<73> return AVPROBE_SCORE_MAX;
<1> int mdb_search ( Operation * op , SlapReply * rs ) {\n<402> pdn = base -> e_name ;\n<403> pndn = base -> e_nname ;\n<418> d = e -> e_name . bv_val ;\n<419> n = e -> e_nname . bv_val ;\n<422> i >= 0 ;\n<424> memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n<425> d += isc . rdns [ i ] . bv_len ;\n<426> * d ++ = ',' ;\n<427> memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n<428> n += isc . nrdns [ i ] . bv_len ;\n<429> * n ++ = ',' ;\n<434> i < isc . numrdns ;\n<436> memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n<437> d += isc . rdns [ i ] . bv_len ;\n<438> * d ++ = ',' ;\n<439> memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n<440> n += isc . nrdns [ i ] . bv_len ;\n<441> * n ++ = ',' ;\n<444> if ( pdn . bv_len ) {\n<445> memcpy ( d , pdn . bv_val , pdn . bv_len + 1 ) ;\n<446> memcpy ( n , pndn . bv_val , pndn . bv_len + 1 ) ;\n<454> if ( pndn . bv_val != base -> e_nname . bv_val ) {\n<456> op -> o_tmpfree ( pdn . bv_val , op -> o_tmpmemctx ) ;
<1> static int kvm_put_fpu(X86CPU *cpu)\n<5> CPUX86State *env = &cpu->env;\n<13> memset(&fpu, 0, sizeof fpu);\n<33> memcpy(fpu.fpr, env->fpregs, sizeof env->fpregs);\n<35> memcpy(fpu.xmm, env->xmm_regs, sizeof env->xmm_regs);\n<41> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_FPU, &fpu);
<1> static void arm_gicv3_icc_reset(CPUARMState *env, const ARMCPRegInfo *ri)\n<13> c = (GICv3CPUState *)env->gicv3state;\n<45> memset(c->icc_apr, 0, sizeof(c->icc_apr));\n<47> memset(c->icc_igrpen, 0, sizeof(c->icc_igrpen));
<1> static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n<5> method = strsep ( & line , " " ) ;\n<7> uri = strsep ( & line , " " ) ;\n<9> version = strsep ( & line , " " ) ;\n<10> if ( line != NULL ) return ( - 1 ) ;\n<11> if ( strcmp ( method , "GET" ) == 0 ) {\n<12> req -> type = EVHTTP_REQ_GET ;\n<14> else if ( strcmp ( method , "POST" ) == 0 ) {\n<15> req -> type = EVHTTP_REQ_POST ;\n<17> else if ( strcmp ( method , "HEAD" ) == 0 ) {\n<18> req -> type = EVHTTP_REQ_HEAD ;\n<21> event_debug ( ( "%s: bad method %s on request %p from %s" , __func__ , method , req , req -> remote_host ) ) ;\n<22> return ( - 1 ) ;\n<24> if ( strcmp ( version , "HTTP/1.0" ) == 0 ) {\n<25> req -> major = 1 ;\n<26> req -> minor = 0 ;\n<28> else if ( strcmp ( version , "HTTP/1.1" ) == 0 ) {\n<29> req -> major = 1 ;\n<30> req -> minor = 1 ;\n<33> event_debug ( ( "%s: bad version %s on request %p from %s" , __func__ , version , req , req -> remote_host ) ) ;\n<34> return ( - 1 ) ;\n<36> if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n<37> event_debug ( ( "%s: evhttp_decode_uri" , __func__ ) ) ;\n<38> return ( - 1 ) ;\n<40> if ( strlen ( req -> uri ) > 0 && req -> uri [ 0 ] != '/' ) req -> flags |= EVHTTP_PROXY_REQUEST ;\n<41> return ( 0 ) ;
<1> static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n<9> char access[11];\n<11> char type[11];\n<27> while (*p) {\n<45> if (ret < 4 || strcmp(access, "RW")) {\n<49> } else if (!strcmp(type, "FLAT")) {\n<51> if (ret != 5 || flat_offset < 0) {\n<57> } else if (ret != 4) {\n<65> if (sectors <= 0 ||\n<67> (strcmp(type, "FLAT") && strcmp(type, "SPARSE")) ||\n<69> (strcmp(access, "RW"))) {\n<83> if (ret) {\n<93> if (!strcmp(type, "FLAT")) {\n<101> extent = vmdk_add_extent(bs, extent_file, true, sectors,\n<105> extent->flat_start_offset = flat_offset << 9;\n<107> } else if (!strcmp(type, "SPARSE")) {\n<111> ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n<113> if (ret) {\n<127> return -ENOTSUP;\n<135> while (*p && *p != '\n') {\n<141> p++;
<1> static void hybrid_synthesis(float out[2][38][64], float in[91][32][2], int is34, int len)\n<9> for (n = 0; n < len; n++) {\n<11> memset(out[0][n], 0, 5*sizeof(out[0][n][0]));\n<13> memset(out[1][n], 0, 5*sizeof(out[1][n][0]));\n<25> out[0][n][1] += in[12+i][n][0];\n<27> out[1][n][1] += in[12+i][n][1];\n<33> out[0][n][2] += in[20+i][n][0];\n<35> out[1][n][2] += in[20+i][n][1];\n<37> out[0][n][3] += in[24+i][n][0];\n<39> out[1][n][3] += in[24+i][n][1];\n<41> out[0][n][4] += in[28+i][n][0];\n<43> out[1][n][4] += in[28+i][n][1];
<1> static int find_partition(BlockBackend *blk, int partition,\n<19> if ((ret = blk_read(blk, 0, data, 1)) < 0) {\n<21> error_report("error while reading: %s", strerror(-ret));\n<61> if ((ret = blk_read(blk, mbr[i].start_sector_abs, data1, 1)) < 0) {\n<63> error_report("error while reading: %s", strerror(-ret));
<1> static void rtsp_parse_transport(RTSPMessageHeader *reply, const char *p)\n<89> while (*p != '\0' && *p != ',') {\n<91> get_word_sep(parameter, sizeof(parameter), "=;,", &p);\n<93> if (!strcmp(parameter, "port")) {\n<95> if (*p == '=') {\n<103> } else if (!strcmp(parameter, "client_port")) {\n<105> if (*p == '=') {\n<115> } else if (!strcmp(parameter, "server_port")) {\n<117> if (*p == '=') {\n<127> } else if (!strcmp(parameter, "interleaved")) {\n<129> if (*p == '=') {\n<139> } else if (!strcmp(parameter, "multicast")) {\n<141> if (th->lower_transport == RTSP_LOWER_TRANSPORT_UDP)\n<145> } else if (!strcmp(parameter, "ttl")) {\n<147> if (*p == '=') {\n<155> } else if (!strcmp(parameter, "destination")) {\n<161> if (*p == '=') {
<1> int loader_exec(const char * filename, char ** argv, char ** envp,\n<5> struct linux_binprm *bprm)\n<17> memset(bprm->page, 0, sizeof(bprm->page));\n<41> retval = prepare_binprm(bprm);\n<55> retval = load_elf_binary(bprm, regs, infop);
<1> static void onenand_command(OneNANDState *s)\n<41> switch (s->command) {\n<401> fprintf(stderr, "%s: unknown OneNAND command %x\n",\n<409> onenand_intr_update(s);
<1> static void mips_fulong2e_init(ram_addr_t ram_size, const char *boot_device,\n<49> if (!env) {\n<51> fprintf(stderr, "Unable to find CPU definition\n");\n<121> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<139> if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n<141> fprintf(stderr, "qemu: Could not load MIPS bios '%s'\n", bios_name);\n<175> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<177> fprintf(stderr, "qemu: too many IDE bus\n");\n<195> if (via_devfn < 0) {\n<197> fprintf(stderr, "vt82c686b_init error \n");\n<219> eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n<221> memcpy(eeprom_buf, eeprom_spd, sizeof(eeprom_spd));\n<229> qdev_prop_set_ptr(eeprom, "data", eeprom_buf);
<1> static void postfilter(EVRCContext *e, float *in, const float *coeff,\n<11> scratch[SUBFRAME_SIZE], temp[SUBFRAME_SIZE],\n<13> mem[SUBFRAME_SIZE];\n<43> scratch[i] = in[i] - tilt * e->last;\n<53> residual_filter(&e->postfilter_residual[ACB_SIZE], scratch, wcoef1, e->postfilter_fir, length);\n<65> sum2 += e->postfilter_residual[n] * e->postfilter_residual[n - i];\n<81> sum1 += e->postfilter_residual[i - best] * e->postfilter_residual[i - best];\n<85> sum2 += e->postfilter_residual[i] * e->postfilter_residual[i - best];\n<89> if (sum2 * sum1 == 0 || e->bitrate == RATE_QUANT) {\n<91> memcpy(temp, e->postfilter_residual + ACB_SIZE, length * sizeof(float));\n<97> if (gamma < 0.5)\n<99> memcpy(temp, e->postfilter_residual + ACB_SIZE, length * sizeof(float));\n<109> temp[i] = e->postfilter_residual[ACB_SIZE + i] + gamma *\n<121> memcpy(scratch, temp, length * sizeof(float));\n<123> memcpy(mem, e->postfilter_iir, FILTER_ORDER * sizeof(float));\n<125> synthesis_filter(scratch, wcoef2, mem, length, scratch);\n<145> temp[i] *= gain;\n<151> synthesis_filter(temp, wcoef2, e->postfilter_iir, length, out);\n<157> e->postfilter_residual + length, ACB_SIZE * sizeof(float));
<1> USBDevice *usb_msd_init(const char *filename)\n<17> p1 = strchr(filename, ':');\n<19> if (p1++) {\n<25> if (strstart(filename, "format=", &p2)) {\n<33> drv = bdrv_find_format(fmt);\n<35> if (!drv) {\n<37> printf("invalid format %s\n", fmt);\n<43> } else if (*filename != ':') {\n<45> printf("unrecognized USB mass-storage option %s\n", filename);\n<59> if (!*filename) {\n<61> printf("block device specification needed\n");\n<75> if (bdrv_open2(bdrv, filename, 0, drv) < 0)
<1> VirtIODevice *virtio_9p_init(DeviceState *dev, V9fsConf *conf)\n<17> s = (V9fsState *)virtio_common_init("virtio-9p",\n<45> fse = get_fsdev_fsentry(conf->fsdev_id);\n<49> if (!fse) {\n<53> fprintf(stderr, "Virtio-9p device couldn't find fsdev "\n<63> if (!fse->path || !conf->tag) {\n<79> if (!strcmp(fse->security_model, "passthrough")) {\n<83> s->ctx.fs_sm = SM_PASSTHROUGH;\n<85> } else if (!strcmp(fse->security_model, "mapped")) {\n<93> s->ctx.fs_sm = SM_MAPPED;\n<95> } else if (!strcmp(fse->security_model, "none")) {\n<103> s->ctx.fs_sm = SM_NONE;\n<109> fprintf(stderr, "Default to security_model=none. You may want"\n<117> s->ctx.fs_sm = SM_NONE;\n<123> if (lstat(fse->path, &stat)) {\n<125> fprintf(stderr, "share path %s does not exist\n", fse->path);\n<129> } else if (!S_ISDIR(stat.st_mode)) {\n<131> fprintf(stderr, "share path %s is not a directory \n", fse->path);\n<139> s->ctx.fs_root = qemu_strdup(fse->path);\n<141> len = strlen(conf->tag);\n<143> if (len > MAX_TAG_LEN) {\n<151> s->tag = qemu_malloc(len);\n<153> memcpy(s->tag, conf->tag, len);\n<155> s->tag_len = len;
<1> int iommu_dma_memory_rw(DMAContext *dma, dma_addr_t addr,\n<3> void *buf, dma_addr_t len, DMADirection dir)\n<27> if (err) {\n<39> memset(buf, 0, len);
<1> CharDriverState *qemu_chr_new_from_opts(QemuOpts *opts,\n<47> for (i = backends; i; i = i->next) {\n<49> cd = i->data;\n<53> if (strcmp(cd->name, qemu_opt_get(opts, "backend")) == 0) {
<1> static void sd_blk_read(SDState *sd, uint64_t addr, uint32_t len)\n<9> DPRINTF("sd_blk_read: addr = 0x%08llx, len = %d\n",\n<13> if (!sd->bdrv || bdrv_read(sd->bdrv, addr >> 9, sd->buf, 1) < 0) {\n<15> fprintf(stderr, "sd_blk_read: read error on host side\n");\n<23> if (end > (addr & ~511) + 512) {\n<25> memcpy(sd->data, sd->buf + (addr & 511), 512 - (addr & 511));\n<29> if (bdrv_read(sd->bdrv, end >> 9, sd->buf, 1) < 0) {\n<31> fprintf(stderr, "sd_blk_read: read error on host side\n");\n<37> memcpy(sd->data + 512 - (addr & 511), sd->buf, end & 511);\n<41> memcpy(sd->data, sd->buf + (addr & 511), len);
<48> tf = ( rtmpt_frag_t * ) wmem_tree_lookup32_le ( rconv -> frags [ cdir ] , seq + offset - 1 ) ;\n<50> RTMPT_DEBUG ( " tf seq=%d lseq=%d h=%d l=%d\n" , tf -> seq , tf -> lastseq , tf -> have , tf -> len ) ;\n<51> if ( tf -> have >= tf -> len || seq + offset < tf -> seq || seq + offset > tf -> lastseq + tf -> len - tf -> have ) {\n<82> if ( tf -> have < tf -> len ) {\n<88> if ( ! tf ) {\n<131> message_hlen = tf -> len - basic_hlen ;\n<213> if ( ! tf && body_len <= chunk_size && tp -> want <= remain ) {\n<227> tp -> data . p = ( guint8 * ) wmem_alloc ( wmem_file_scope ( ) , tp -> bhlen + tp -> mhlen + tp -> len ) ;\n<228> if ( tf && tf -> ishdr ) {\n<229> memcpy ( tp -> data . p , tf -> saved . d , tf -> len ) ;\n<260> tvb_memcpy ( tvb , tp -> data . p + tp -> have , offset , want ) ;
<8> frag = ( hm_fragment * ) item -> data ;\n<14> if ( al == 0 ) {\n<15> unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n<16> memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n<18> dtls1_hm_fragment_free ( frag ) ;
<1> static void load_linux(void *fw_cfg,\n<9> const char *kernel_cmdline,\n<39> cmdline_size = (strlen(kernel_cmdline)+16) & ~15;\n<45> f = fopen(kernel_filename, "rb");\n<53> fprintf(stderr, "qemu: could not load kernel '%s': %s\n",\n<55> kernel_filename, strerror(errno));\n<71> if (ldl_p(header+0x202) == 0x53726448)\n<99> cmdline_addr = 0x9a000 - cmdline_size;\n<109> cmdline_addr = 0x9a000 - cmdline_size;\n<167> pstrcpy_targphys(cmdline_addr, 4096, kernel_cmdline);\n<187> vmode = strstr(kernel_cmdline, "vga=");\n<195> vmode += 4;\n<251> if (protocol < 0x200) {\n<253> fprintf(stderr, "qemu: linux kernel too old to load a ram disk\n");\n<261> fi = fopen(initrd_filename, "rb");\n<263> if (!fi) {\n<265> fprintf(stderr, "qemu: could not load initial ram disk '%s': %s\n",\n<267> initrd_filename, strerror(errno));\n<281> if (!fread_targphys_ok(initrd_addr, initrd_size, fi)) {\n<283> fprintf(stderr, "qemu: read error on initial ram disk '%s': %s\n",\n<285> initrd_filename, strerror(errno));\n<339> if (!fread_targphys_ok(real_addr + ARRAY_SIZE(header),\n<345> fprintf(stderr, "qemu: read error on kernel '%s'\n",\n<365> memset(gpr, 0, sizeof gpr);\n<375> option_rom_setup_reset(cmdline_addr, cmdline_size);\n<383> generate_bootsect(option_rom, gpr, seg, 0);
<1> static int usb_net_handle_control(USBDevice *dev, int request, int value,\n<3> int index, int length, uint8_t *data)\n<13> switch(request) {\n<31> if (value == USB_DEVICE_REMOTE_WAKEUP) {\n<49> if (value == USB_DEVICE_REMOTE_WAKEUP) {\n<77> if (!s->rndis || value || index != 0)\n<113> if (!s->rndis || value || index != 0)\n<157> switch(value >> 8) {\n<161> ret = sizeof(qemu_net_dev_descriptor);\n<163> memcpy(data, qemu_net_dev_descriptor, ret);\n<171> switch (value & 0xff) {\n<175> ret = sizeof(qemu_net_rndis_config_descriptor);\n<177> memcpy(data, qemu_net_rndis_config_descriptor, ret);\n<185> ret = sizeof(qemu_net_cdc_config_descriptor);\n<187> memcpy(data, qemu_net_cdc_config_descriptor, ret);\n<201> data[2] = ret & 0xff;\n<241> if (usb_net_stringtable[value & 0xff]) {\n<283> switch (value & 0xff) {\n<339> fprintf(stderr, "usbnet: failed control transaction: "\n<351> return ret;
<1> static int kvm_get_fpu(X86CPU *cpu)\n<5> CPUX86State *env = &cpu->env;\n<15> if (ret < 0) {\n<41> memcpy(env->fpregs, fpu.fpr, sizeof env->fpregs);\n<43> memcpy(env->xmm_regs, fpu.xmm, sizeof env->xmm_regs);
<1> static int draw_text(AVFilterContext *ctx, AVFilterBufferRef *picref,\n<7> DrawTextContext *dtext = ctx->priv;\n<47> if (!buf) {\n<49> buf_size = 2*strlen(dtext->text)+1;\n<51> buf = av_malloc(buf_size);\n<63> if(strchr(dtext->text, '%'))\n<65> ltime= *localtime(&now);\n<75> if (strftime(buf, buf_size, dtext->text, &ltime) != 0 || *buf == 0)\n<85> if (!buf)\n<89> text = dtext->expanded_text = buf;\n<93> if ((len = strlen(text)) > dtext->nb_positions) {\n<95> if (!(dtext->positions =\n<97> av_realloc(dtext->positions, len*sizeof(*dtext->positions))))\n<107> x = dtext->x;\n<109> y = dtext->y;\n<115> for (i = 0, p = text; *p; i++) {\n<139> text_height = y_max - y_min;\n<145> glyph = NULL;\n<147> for (i = 0, p = text; *p; i++) {\n<227> str_w = FFMIN(width - dtext->x - 1, FFMAX(str_w, x - dtext->x));\n<229> y     = FFMIN(y + text_height, height - 1);\n<235> if (dtext->draw_box)\n<245> if (dtext->shadowx || dtext->shadowy) {\n<247> if ((ret = draw_glyphs(dtext, picref, width, height, dtext->shadowcolor_rgba,\n<257> if ((ret = draw_glyphs(dtext, picref, width, height, dtext->fontcolor_rgba,
<1> static int http_connect(URLContext *h, const char *path, const char *hoststr)\n<5> HTTPContext *s = h->priv_data;\n<17> post = h->flags & URL_WRONLY;\n<43> if (http_write(h, s->buffer, strlen(s->buffer)) < 0)\n<45> return AVERROR_IO;\n<51> s->buf_ptr = s->buffer;\n<53> s->buf_end = s->buffer;\n<55> s->line_count = 0;\n<57> s->location[0] = '\0';\n<59> if (post) {\n<75> ch = http_getc(s);\n<97> err = process_line(s, line, s->line_count);
<1> void cpu_x86_inject_mce(CPUState *cenv, int bank, uint64_t status,\n<27> if (!cpu_x86_support_mca_broadcast(cenv)) {\n<29> fprintf(stderr, "Current CPU does not support broadcast\n");
<42> if ( ! data -> state . this_is_a_follow ) {\n<43> free ( data -> state . first_host ) ;\n<44> data -> state . first_host = strdup ( conn -> host . name ) ;\n<45> if ( ! data -> state . first_host ) return CURLE_OUT_OF_MEMORY ;\n<69> if ( Curl_checkheaders ( conn , "User-Agent:" ) ) {\n<70> free ( conn -> allocptr . uagent ) ;
<1> static int parse_picture_segment ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) {\n<8> picture_id = bytestream_get_be16 ( & buf ) ;\n<9> buf ++ ;\n<10> sequence_desc = bytestream_get_byte ( & buf ) ;\n<12> if ( buf_size > ctx -> pictures [ picture_id ] . rle_remaining_len ) return - 1 ;\n<13> memcpy ( ctx -> pictures [ picture_id ] . rle + ctx -> pictures [ picture_id ] . rle_data_len , buf , buf_size ) ;\n<14> ctx -> pictures [ picture_id ] . rle_data_len += buf_size ;\n<15> ctx -> pictures [ picture_id ] . rle_remaining_len -= buf_size ;\n<19> buf_size -= 7 ;\n<20> rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2 ;\n<21> width = bytestream_get_be16 ( & buf ) ;\n<22> height = bytestream_get_be16 ( & buf ) ;\n<29> av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ) ;\n<30> if ( ! ctx -> pictures [ picture_id ] . rle ) return - 1 ;\n<31> memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ) ;\n<32> ctx -> pictures [ picture_id ] . rle_data_len = buf_size ;\n<33> ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size ;
<1> static void do_token_setup(USBDevice *s, USBPacket *p)\n<67> if (s->setup_len > sizeof(s->data_buf)) {
<1> static int read_packet(AVFormatContext *s1, AVPacket *pkt)\n<53> for(i=0; i<3; i++){\n<63> av_log(s1, AV_LOG_ERROR, "Could not open file : %s\n",filename);\n<73> if(!s->split_planes)\n<77> filename[ strlen(filename) - 1 ]= 'U' + i;
<1> static void dissect_q931_pdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean is_over_ip ) {\n<18> reset_q931_packet_info ( q931_pi ) ;\n<42> if ( call_ref_len != 0 ) {\n<43> tvb_memcpy ( tvb , call_ref , offset , call_ref_len ) ;\n<46> call_ref [ 0 ] &= 0x7F ;\n<47> proto_tree_add_bytes ( q931_tree , hf_q931_call_ref , tvb , offset , call_ref_len , call_ref ) ;\n<50> call_ref [ 0 ] &= 0x7F ;\n<52> memcpy ( & ( q931_pi -> crv ) , call_ref , call_ref_len > sizeof ( q931_pi -> crv ) ? sizeof ( q931_pi -> crv ) : call_ref_len ) ;
<1> static int vc1_decode_p_mb_intfi(VC1Context *v)\n<47> v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n<99> vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n<125> s->mb_intra = v->is_intra[s->mb_x] = 0;\n<143> ff_vc1_mc_1mv(v, 0);\n<167> ff_vc1_mc_4mv_luma(v, i, 0, 0);\n<171> ff_vc1_mc_4mv_chroma(v, 0);\n<211> pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n<233> if (s->mb_x == s->mb_width - 1)\n<235> memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride);
<1> static inline void mix_3f_2r_to_mono(AC3DecodeContext *ctx)\n<15> memset(output[2], 0, sizeof(output[2]));\n<17> memset(output[3], 0, sizeof(output[3]));\n<19> memset(output[4], 0, sizeof(output[4]));\n<21> memset(output[5], 0, sizeof(output[5]));
<1> static void omap_rtc_reset(struct omap_rtc_s *s)\n<23> memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));
<1> static void input_linux_complete(UserCreatable *uc, Error **errp)\n<95> if (evtmap & (1 << EV_KEY)) {\n<97> memset(keymap, 0, sizeof(keymap));
<1> void ram_handle_compressed(void *host, uint8_t ch, uint64_t size)\n<5> if (ch != 0 || !is_zero_range(host, size)) {\n<7> memset(host, ch, size);\n<11> if (ch == 0 && (!kvm_enabled() || kvm_has_sync_mmu())) {\n<13> size = size & ~(getpagesize() - 1);\n<17> qemu_madvise(host, size, QEMU_MADV_DONTNEED);
<1> static int kvm_handle_internal_error(CPUState *env, struct kvm_run *run)\n<5> fprintf(stderr, "KVM internal error.");\n<7> if (kvm_check_extension(kvm_state, KVM_CAP_INTERNAL_ERROR_DATA)) {\n<13> fprintf(stderr, " Suberror: %d\n", run->internal.suberror);\n<25> fprintf(stderr, "\n");\n<29> if (run->internal.suberror == KVM_INTERNAL_ERROR_EMULATION) {\n<31> fprintf(stderr, "emulation failure\n");\n<33> if (!kvm_arch_stop_on_emulation_error(env)) {\n<35> cpu_dump_state(env, stderr, fprintf, CPU_DUMP_CODE);
<1> void *paio_init(void)\n<37> if (pipe(fds) == -1) {\n<39> fprintf(stderr, "failed to create pipe\n");
<1> static void add_flagname_to_bitmaps(const char *flagname, uint32_t *features,\n<17> for ( i = 0 ; i < 32 ; i++ )\n<19> if (feature_name[i] && !strcmp (flagname, feature_name[i])) {\n<21> *features |= 1 << i;\n<23> found = 1;\n<27> for ( i = 0 ; i < 32 ; i++ )\n<29> if (ext_feature_name[i] && !strcmp (flagname, ext_feature_name[i])) {\n<31> *ext_features |= 1 << i;\n<33> found = 1;\n<37> for ( i = 0 ; i < 32 ; i++ )\n<39> if (ext2_feature_name[i] && !strcmp (flagname, ext2_feature_name[i])) {\n<41> *ext2_features |= 1 << i;\n<43> found = 1;\n<47> for ( i = 0 ; i < 32 ; i++ )\n<49> if (ext3_feature_name[i] && !strcmp (flagname, ext3_feature_name[i])) {\n<51> *ext3_features |= 1 << i;\n<53> found = 1;\n<57> if (!found) {\n<59> fprintf(stderr, "CPU feature %s not found\n", flagname);
<1> static int planarCopyWrapper(SwsContext *c, const uint8_t *src[],\n<5> uint8_t *dst[], int dstStride[])\n<17> int length = (plane == 0 || plane == 3) ? c->srcW  : -((-c->srcW  ) >> c->chrDstHSubSample);\n<23> const uint8_t *srcPtr = src[plane];\n<25> uint8_t *dstPtr = dst[plane] + dstStride[plane] * y;\n<29> if (!dst[plane])\n<37> if (!src[plane] || (plane == 1 && !src[2])) {\n<299> srcPtr  += srcStride[plane]; \\n<343> dstPtr[ j << 1     ] = srcPtr[j];\n<345> dstPtr[(j << 1) + 1] = srcPtr[j];\n<349> srcPtr += srcStride[plane];\n<375> srcStride[plane] > 0 && srcStride[plane] == length) {\n<377> memcpy(dst[plane] + dstStride[plane] * y, src[plane],\n<379> height * dstStride[plane]);\n<385> length *= 2;\n<389> length >>= 3; // monowhite/black\n<391> for (i = 0; i < height; i++) {\n<393> memcpy(dstPtr, srcPtr, length);\n<395> srcPtr += srcStride[plane];\n<397> dstPtr += dstStride[plane];
<1> static void read_sbr_envelope(SpectralBandReplication *sbr, GetBitContext *gb,\n<131> memcpy(ch_data->env_facs_q[0], ch_data->env_facs_q[ch_data->bs_num_env],
<1> static int add_calxeda_midway_xgmac_fdt_node(SysBusDevice *sbdev, void *opaque)\n<21> VFIOPlatformDevice *vdev = VFIO_PLATFORM_DEVICE(sbdev);\n<37> compat_str_len = strlen(vdev->compat) + 1;
<1> void avfilter_draw_slice(AVFilterLink *link, int y, int h)\n<5> uint8_t *src[4], *dst[4];\n<19> src[0] = link->srcpic-> data[0] + y * link->srcpic-> linesize[0];\n<21> dst[0] = link->cur_pic->data[0] + y * link->cur_pic->linesize[0];\n<29> dst[i] = link->cur_pic->data[i] + (y >> vsub) * link->cur_pic->linesize[i];\n<33> src[i] = dst[i] = NULL;\n<37> for(j = 0; j < h; j ++) {\n<39> memcpy(dst[0], src[0], link->cur_pic->linesize[0]);\n<41> src[0] += link->srcpic ->linesize[0];\n<43> dst[0] += link->cur_pic->linesize[0];\n<49> if(!src[i]) continue;\n<53> for(j = 0; j < h >> vsub; j ++) {\n<55> memcpy(dst[i], src[i], link->cur_pic->linesize[i]);\n<57> src[i] += link->srcpic ->linesize[i];\n<59> dst[i] += link->cur_pic->linesize[i];
<1> on_host_init(VSCMsgHeader *mhHeader, VSCMsgInit *incoming)\n<19> if (incoming->version != VSCARD_VERSION) {\n<21> if (verbose > 0) {\n<23> printf("warning: host has version %d, we have %d\n",\n<31> if (incoming->magic != VSCARD_MAGIC) {\n<33> printf("unexpected magic: got %d, expected %d\n",
<1> static void qemu_init_child_watch(void)\n<11> memset(&act, 0, sizeof(act));\n<17> sigaction(SIGCHLD, &act, NULL);
<1> SwsContext *getSwsContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags,\n<31> if(srcW<4 || srcH<1 || dstW<8 || dstH<1) return NULL; //FIXME check if these are enough and try to lowwer them after fixing the relevant parts of the code\n<47> c= memalign(64, sizeof(SwsContext));\n<49> memset(c, 0, sizeof(SwsContext));\n<53> c->srcW= srcW;\n<55> c->srcH= srcH;\n<57> c->dstW= dstW;\n<59> c->dstH= dstH;\n<79> if(!c->canMMX2BeUsed && dstW >=srcW && (srcW&15)==0 && (flags&SWS_FAST_BILINEAR))\n<83> if(flags&SWS_PRINT_INFO)\n<85> fprintf(stderr, "SwScaler: output Width is not a multiple of 32 -> no MMX2 scaler\n");\n<137> c->chrXInc= ((c->chrSrcW<<16) + (c->chrDstW>>1))/c->chrDstW;\n<139> c->chrYInc= ((c->chrSrcH<<16) + (c->chrDstH>>1))/c->chrDstH;\n<165> c->lumXInc+= 20;\n<167> c->chrXInc+= 20;\n<179> c->chrXInc = ((c->chrSrcW-2)<<16)/(c->chrDstW-2) - 20;\n<195> initFilter(&c->hLumFilter, &c->hLumFilterPos, &c->hLumFilterSize, c->lumXInc,\n<201> initFilter(&c->hChrFilter, &c->hChrFilterPos, &c->hChrFilterSize, c->chrXInc,\n<235> initFilter(&c->vLumFilter, &c->vLumFilterPos, &c->vLumFilterSize, c->lumYInc,\n<241> initFilter(&c->vChrFilter, &c->vChrFilterPos, &c->vChrFilterSize, c->chrYInc,\n<251> c->vLumBufSize= c->vLumFilterSize;\n<253> c->vChrBufSize= c->vChrFilterSize;\n<259> int chrI= i*c->chrDstH / dstH;\n<261> int nextSlice= MAX(c->vLumFilterPos[i   ] + c->vLumFilterSize - 1,\n<263> ((c->vChrFilterPos[chrI] + c->vChrFilterSize - 1)<<1));\n<267> if(c->vLumFilterPos[i   ] + c->vLumBufSize < nextSlice)\n<271> if(c->vChrFilterPos[chrI] + c->vChrBufSize < (nextSlice>>1))\n<281> c->lumPixBuf= (int16_t**)memalign(4, c->vLumBufSize*2*sizeof(int16_t*));\n<283> c->chrPixBuf= (int16_t**)memalign(4, c->vChrBufSize*2*sizeof(int16_t*));\n<287> for(i=0; i<c->vLumBufSize; i++)\n<289> c->lumPixBuf[i]= c->lumPixBuf[i+c->vLumBufSize]= (uint16_t*)memalign(8, 4000);\n<291> for(i=0; i<c->vChrBufSize; i++)\n<293> c->chrPixBuf[i]= c->chrPixBuf[i+c->vChrBufSize]= (uint16_t*)memalign(8, 8000);\n<299> for(i=0; i<c->vLumBufSize; i++) memset(c->lumPixBuf[i], 0, 4000);\n<301> for(i=0; i<c->vChrBufSize; i++) memset(c->chrPixBuf[i], 64, 8000);\n<305> ASSERT(c->chrDstH <= dstH)\n<315> c->lumMmxFilter= (int16_t*)memalign(8, c->vLumFilterSize*      dstH*4*sizeof(int16_t));\n<317> c->chrMmxFilter= (int16_t*)memalign(8, c->vChrFilterSize*c->chrDstH*4*sizeof(int16_t));\n<319> for(i=0; i<c->vLumFilterSize*dstH; i++)\n<325> for(i=0; i<c->vChrFilterSize*c->chrDstH; i++)\n<345> char *dither= "";\n<349> if(flags&SWS_FAST_BILINEAR)\n<351> fprintf(stderr, "\nSwScaler: FAST_BILINEAR scaler, ");\n<353> else if(flags&SWS_BILINEAR)\n<355> fprintf(stderr, "\nSwScaler: BILINEAR scaler, ");\n<357> else if(flags&SWS_BICUBIC)\n<359> fprintf(stderr, "\nSwScaler: BICUBIC scaler, ");\n<361> else if(flags&SWS_X)\n<363> fprintf(stderr, "\nSwScaler: Experimental scaler, ");\n<365> else if(flags&SWS_POINT)\n<367> fprintf(stderr, "\nSwScaler: Nearest Neighbor / POINT scaler, ");\n<369> else if(flags&SWS_AREA)\n<371> fprintf(stderr, "\nSwScaler: Area Averageing scaler, ");\n<375> fprintf(stderr, "\nSwScaler: ehh flags invalid?! ");\n<379> if(dstFormat==IMGFMT_BGR15 || dstFormat==IMGFMT_BGR16)\n<383> vo_format_name(srcFormat), dither, vo_format_name(dstFormat));\n<389> vo_format_name(srcFormat), vo_format_name(dstFormat));\n<393> if(cpuCaps.hasMMX2)\n<395> fprintf(stderr, "using MMX2\n");\n<397> else if(cpuCaps.has3DNow)\n<399> fprintf(stderr, "using 3DNOW\n");\n<401> else if(cpuCaps.hasMMX)\n<403> fprintf(stderr, "using MMX\n");\n<407> fprintf(stderr, "using C\n");\n<413> if((flags & SWS_PRINT_INFO) && verbose)\n<421> if(c->canMMX2BeUsed && (flags&SWS_FAST_BILINEAR))\n<423> printf("SwScaler: using FAST_BILINEAR MMX2 scaler for horizontal scaling\n");\n<429> if(c->hLumFilterSize==4)\n<431> printf("SwScaler: using 4-tap MMX scaler for horizontal luminance scaling\n");\n<433> else if(c->hLumFilterSize==8)\n<435> printf("SwScaler: using 8-tap MMX scaler for horizontal luminance scaling\n");\n<439> printf("SwScaler: using n-tap MMX scaler for horizontal luminance scaling\n");\n<443> if(c->hChrFilterSize==4)\n<445> printf("SwScaler: using 4-tap MMX scaler for horizontal chrominance scaling\n");\n<447> else if(c->hChrFilterSize==8)\n<449> printf("SwScaler: using 8-tap MMX scaler for horizontal chrominance scaling\n");\n<453> printf("SwScaler: using n-tap MMX scaler for horizontal chrominance scaling\n");\n<469> if(flags & SWS_FAST_BILINEAR)\n<471> printf("SwScaler: using FAST_BILINEAR C scaler for horizontal scaling\n");\n<475> printf("SwScaler: using C scaler for horizontal scaling\n");\n<485> if(c->vLumFilterSize==1)\n<487> printf("SwScaler: using 1-tap %s \"scaler\" for vertical scaling (YV12 like)\n", cpuCaps.hasMMX ? "MMX" : "C");\n<491> printf("SwScaler: using n-tap %s scaler for vertical scaling (YV12 like)\n", cpuCaps.hasMMX ? "MMX" : "C");\n<499> if(c->vLumFilterSize==1 && c->vChrFilterSize==2)\n<501> printf("SwScaler: using 1-tap %s \"scaler\" for vertical luminance scaling (BGR)\n"\n<505> else if(c->vLumFilterSize==2 && c->vChrFilterSize==2)\n<507> printf("SwScaler: using 2-tap linear %s scaler for vertical scaling (BGR)\n", cpuCaps.hasMMX ? "MMX" : "C");\n<511> printf("SwScaler: using n-tap %s scaler for vertical scaling (BGR)\n", cpuCaps.hasMMX ? "MMX" : "C");\n<517> if(dstFormat==IMGFMT_BGR24)\n<519> printf("SwScaler: using %s YV12->BGR24 Converter\n",\n<521> cpuCaps.hasMMX2 ? "MMX2" : (cpuCaps.hasMMX ? "MMX" : "C"));\n<523> else if(dstFormat==IMGFMT_BGR32)\n<525> printf("SwScaler: using %s YV12->BGR32 Converter\n", cpuCaps.hasMMX ? "MMX" : "C");\n<527> else if(dstFormat==IMGFMT_BGR16)\n<529> printf("SwScaler: using %s YV12->BGR16 Converter\n", cpuCaps.hasMMX ? "MMX" : "C");\n<531> else if(dstFormat==IMGFMT_BGR15)\n<533> printf("SwScaler: using %s YV12->BGR15 Converter\n", cpuCaps.hasMMX ? "MMX" : "C");\n<537> printf("SwScaler: %dx%d -> %dx%d\n", srcW, srcH, dstW, dstH);\n<541> if((flags & SWS_PRINT_INFO) && verbose>1)\n<545> printf("SwScaler:Lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n",\n<549> printf("SwScaler:Chr srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n",\n<557> return c;
<1> static uint16_t blizzard_reg_read(void *opaque, uint8_t reg)\n<9> switch (reg) {\n<397> fprintf(stderr, "%s: unknown register %02x\n", __FUNCTION__, reg);
<1> static int tosa_dac_event(I2CSlave *i2c, enum i2c_event event)\n<11> switch (event) {\n<19> printf("%s: recv not supported!!!\n", __FUNCTION__);
<1> int qsv_transcode_init(OutputStream *ost)\n<45> if (*pix_fmt == AV_PIX_FMT_NONE)\n<51> if (strcmp(ost->avfilter, "null") || ost->source_index < 0)\n<53> return 0;\n<59> ist = input_streams[ost->source_index];\n<61> if (ist->hwaccel_id != HWACCEL_QSV || !ist->dec || !ist->dec->pix_fmts)\n<79> if (output_streams[i] != ost &&\n<127> qsv->ost = ost;
<1> static int handle_buffered_iopage(XenIOState *state)\n<15> if (!buf_page) {\n<23> memset(&req, 0x00, sizeof(req));\n<73> qw = (req.size == 8);\n<87> req.data |= ((uint64_t)buf_req->data) << 32;\n<95> handle_ioreq(state, &req);
<1> static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n<19> memset(&blkcfg, 0, sizeof(blkcfg));\n<33> blkcfg.heads = conf->heads;\n<59> blkcfg.sectors = conf->secs & ~s->sector_mask;\n<63> blkcfg.sectors = conf->secs;\n<67> blkcfg.size_max = 0;\n<69> blkcfg.physical_block_exp = get_physical_block_exp(conf);\n<71> blkcfg.alignment_offset = 0;\n<73> blkcfg.wce = bdrv_enable_write_cache(s->bs);\n<75> memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));
<1> static bool append_open_options(QDict *d, BlockDriverState *bs)\n<13> for (entry = qdict_first(bs->options); entry;\n<21> if (strchr(qdict_entry_key(entry), '.')) {\n<31> for (desc = bdrv_runtime_opts.desc; desc->name; desc++) {\n<33> if (!strcmp(qdict_entry_key(entry), desc->name)) {\n<41> if (desc->name) {
<1> static void block_io_signals(void)\n<33> memset(&sigact, 0, sizeof(sigact));\n<37> sigaction(SIGUSR1, &sigact, NULL);
<1> static void combine_addr(char *buf, size_t len, const char* address,\n<9> if (strstr(address, ":")) {\n<11> snprintf(buf, len, "[%s]:%u", address, port);\n<15> snprintf(buf, len, "%s:%u", address, port);
<1> void test_fcmp(double a, double b)\n<21> a, b, fpus & (0x4500 | FPUS_EMASK));\n<35> a, b, fpus & (0x4500 | FPUS_EMASK));\n<37> if (TEST_FCOMI) {\n<57> a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n<75> a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n<89> printf("fxam(%f)=%04lx\n", a, fpus & 0x4700);
<1> static void niagara_init(MachineState *machine)\n<93> if (size > 0) {\n<109> fprintf(stderr, "qemu: could not load ram disk '%s'\n",
<1> static int opt_streamid(const char *opt, const char *arg)\n<13> av_strlcpy(idx_str, arg, sizeof(idx_str));\n<15> p = strchr(idx_str, ':');\n<17> if (!p) {\n<31> idx = parse_number_or_die(opt, idx_str, OPT_INT, 0, INT_MAX);
<1> static void gain_compensate(COOKContext *q, cook_gains *gains_ptr,\n<3> float* previous_buffer)\n<9> float *buffer = q->mono_mdct_output;\n<17> for(i=0 ; i<q->samples_per_channel ; i++) {\n<21> buffer[i] += previous_buffer[i];\n<33> interpolate(q, &buffer[q->gain_size_factor * i],\n<43> memcpy(previous_buffer, buffer+q->samples_per_channel,\n<45> sizeof(float)*q->samples_per_channel);
<1> enum nss_status _nss_nis_getaliasbyname_r ( const char * name , struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n<2> if ( name == NULL ) {\n<6> size_t namlen = strlen ( name ) ;\n<7> char name2 [ namlen + 1 ] ;\n<12> i < namlen ;\n<13> ++ i ) name2 [ i ] = _tolower ( name [ i ] ) ;\n<17> int yperr = yp_match ( domain , "mail.aliases" , name2 , namlen , & result , & len ) ;\n<23> if ( __builtin_expect ( ( size_t ) ( len + 1 ) > buflen , 0 ) ) {\n<24> free ( result ) ;\n<28> char * p = strncpy ( buffer , result , len ) ;\n<30> while ( isspace ( * p ) ) ++ p ;\n<31> free ( result ) ;\n<33> int parse_res = _nss_nis_parse_aliasent ( name , p , alias , buffer , buflen , errnop ) ;
<1> static int compute_bit_allocation(AC3EncodeContext *s,\n<3> uint8_t bap[AC3_MAX_BLOCKS][AC3_MAX_CHANNELS][AC3_MAX_COEFS],\n<151> bit_alloc(s, mask, psd, bap, frame_bits, coarse_snr_offset, 0) < 0)\n<171> memcpy(bap, bap1, sizeof(bap1));\n<177> bit_alloc(s, mask, psd, bap1, frame_bits, coarse_snr_offset + 1, 0) >= 0) {\n<181> memcpy(bap, bap1, sizeof(bap1));\n<197> memcpy(bap, bap1, sizeof(bap1));\n<209> memcpy(bap, bap1, sizeof(bap1));
<1> static void dmg_close(BlockDriverState *bs)\n<5> BDRVDMGState *s = bs->opaque;\n<9> if(s->n_chunks>0) {\n<11> free(s->types);\n<13> free(s->offsets);\n<15> free(s->lengths);\n<17> free(s->sectors);\n<19> free(s->sectorcounts);\n<23> free(s->compressed_chunk);\n<25> free(s->uncompressed_chunk);
<1> int ff_h264_decode_seq_parameter_set(H264Context *h)\n<47> if (!sps)\n<65> memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n<67> memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n<401> int ret = decode_vui_parameters(h, sps);\n<483> h->sps_buffers[sps_id] = sps;\n<495> av_free(sps);
<1> static void mixer_reset (AC97LinkState *s)\n<11> memset (s->mixer_data, 0, sizeof (s->mixer_data));\n<13> memset (active, 0, sizeof (active));\n<15> mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */\n<17> mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);\n<19> mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);\n<23> mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);\n<25> mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);\n<27> mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);\n<29> mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);\n<31> mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);\n<33> mixer_store (s, AC97_General_Purpose         , 0x0000);\n<35> mixer_store (s, AC97_3D_Control              , 0x0000);\n<37> mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);\n<47> mixer_store (s, AC97_Vendor_ID1              , 0x8384);\n<49> mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */\n<53> mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);\n<55> mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);\n<57> mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);\n<59> mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);\n<61> mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);\n<63> mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);\n<65> mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);\n<69> record_select (s, 0);\n<71> set_volume (s, AC97_Master_Volume_Mute, 0x8000);\n<73> set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);\n<75> set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);\n<79> reset_voices (s, active);
<1> static int shorten_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<3> const uint8_t * buf = avpkt -> data ;\n<5> ShortenContext * s = avctx -> priv_data ;\n<16> s -> bitstream = tmp_ptr ;\n<19> buf_size = FFMIN ( buf_size , s -> max_framesize - s -> bitstream_size ) ;\n<21> if ( s -> bitstream_index + s -> bitstream_size + buf_size > s -> allocated_bitstream_size ) {\n<22> memmove ( s -> bitstream , & s -> bitstream [ s -> bitstream_index ] , s -> bitstream_size ) ;\n<25> if ( buf ) memcpy ( & s -> bitstream [ s -> bitstream_index + s -> bitstream_size ] , buf , buf_size ) ;\n<26> buf = & s -> bitstream [ s -> bitstream_index ] ;\n<27> buf_size += s -> bitstream_size ;\n<37> if ( ( ret = read_header ( s ) ) < 0 ) return ret ;\n<67> unsigned blocksize = get_uint ( s , av_log2 ( s -> blocksize ) ) ;\n<110> if ( ( ret = decode_subframe_lpc ( s , cmd , channel , residual_size , coffset ) ) < 0 ) return ret ;\n<126> fix_bitshift ( s , s -> decoded [ channel ] ) ;
<1> static int test_butterflies_float(AVFloatDSPContext *fdsp, AVFloatDSPContext *cdsp,\n<3> const float *v1, const float *v2)\n<19> memcpy(cv1, v1, LEN * sizeof(*v1));\n<21> memcpy(cv2, v2, LEN * sizeof(*v2));\n<23> memcpy(ov1, v1, LEN * sizeof(*v1));\n<25> memcpy(ov2, v2, LEN * sizeof(*v2));\n<29> cdsp->butterflies_float(cv1, cv2, LEN);\n<31> fdsp->butterflies_float(ov1, ov2, LEN);
<1> static int decode_update_thread_context(AVCodecContext *dst, const AVCodecContext *src){\n<3> H264Context *h= dst->priv_data, *h1= src->priv_data;\n<25> if(!inited){\n<39> memcpy(&h->s + 1, &h1->s + 1, sizeof(H264Context) - sizeof(MpegEncContext)); //copy all fields after MpegEnc\n<41> memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n<43> memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n<45> if (ff_h264_alloc_tables(h) < 0) {\n<53> context_init(h);\n<67> h->thread_context[0] = h;\n<79> s->dsp.clear_blocks(h->mb);\n<81> s->dsp.clear_blocks(h->mb+(24*16<<h->pixel_shift));\n<95> copy_parameter_set((void**)h->sps_buffers, (void**)h1->sps_buffers, MAX_SPS_COUNT, sizeof(SPS));\n<99> copy_parameter_set((void**)h->pps_buffers, (void**)h1->pps_buffers, MAX_PPS_COUNT, sizeof(PPS));\n<109> copy_fields(h, h1, dequant4_buffer, dequant4_coeff);\n<131> copy_fields(h, h1, poc_lsb, redundant_pic_count);\n<137> copy_fields(h, h1, ref_count, list_count);\n<139> copy_fields(h, h1, ref_list,  intra_gb);\n<141> copy_fields(h, h1, short_ref, cabac_init_idc);\n<165> err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
<1> do_send_recv(int sockfd, struct iovec *iov, unsigned iov_cnt, bool do_send)\n<39> while (i < iov_cnt) {\n<43> ? send(sockfd, iov[i].iov_base, iov[i].iov_len, 0)\n<45> : recv(sockfd, iov[i].iov_base, iov[i].iov_len, 0);
<1> static void pc_init1(QEMUMachineInitArgs *args,\n<57> if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {\n<59> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> static void qxl_flip(PCIQXLDevice *qxl, QXLRect *rect)\n<19> src += rect->left * qxl->guest_primary.bytes_pp;\n<21> dst += rect->left * qxl->guest_primary.bytes_pp;\n<23> len  = (rect->right - rect->left) * qxl->guest_primary.bytes_pp;\n<27> for (i = rect->top; i < rect->bottom; i++) {\n<29> memcpy(dst, src, len);\n<31> dst += qxl->guest_primary.stride;\n<33> src -= qxl->guest_primary.stride;
<1> static inline uint16_t get_hwc_color(SM501State *state, int crt, int index)\n<19> switch (index) {\n<41> printf("invalid hw cursor color.\n");
<1> static int userauth_hostbased ( struct ssh * ssh ) {\n<9> if ( ! authctxt -> valid ) {\n<13> if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( "%s: packet parsing: %s" , __func__ , ssh_err ( r ) ) ;\n<14> debug ( "%s: cuser %s chost %s pkalg %s slen %zu" , __func__ , cuser , chost , pkalg , slen ) ;\n<19> logit ( "%s: unsupported public key algorithm: %s" , __func__ , pkalg ) ;\n<22> if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n<27> error ( "%s: cannot decode key: %s" , __func__ , pkalg ) ;\n<38> if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) {\n<43> if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , "hostbased" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( "%s: buffer error: %s" , __func__ , ssh_err ( r ) ) ;\n<47> if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ;\n<52> free ( pkalg ) ;\n<53> free ( pkblob ) ;\n<54> free ( cuser ) ;\n<55> free ( chost ) ;\n<56> free ( sig ) ;
<1> static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob ) {\n<2> size_t dirlen = strlen ( directory ) ;\n<20> meta = __glob_pattern_type ( pattern , ! ( flags & GLOB_NOESCAPE ) ) ;\n<24> else if ( meta == 0 ) {\n<27> size_t patlen = strlen ( pattern ) ;\n<28> char * fullname = ( char * ) __alloca ( dirlen + 1 + patlen + 1 ) ;\n<29> mempcpy ( mempcpy ( mempcpy ( fullname , directory , dirlen ) , "/" , 1 ) , pattern , patlen + 1 ) ;\n<33> stream = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_opendir ) ( directory ) : opendir ( directory ) ) ;\n<34> if ( stream == NULL ) {\n<64> if ( fnmatch ( pattern , name , fnm_flags ) == 0 ) {\n<65> if ( ! DIRENT_MIGHT_BE_SYMLINK ( d ) || link_exists_p ( dfd , directory , dirlen , name , pglob , flags ) ) {\n<66> if ( cur == names -> count ) {\n<70> allocasize += size ;\n<71> if ( __libc_use_alloca ( allocasize ) ) newnames = names_alloca = __alloca ( size ) ;\n<72> else if ( ( newnames = malloc ( size ) ) == NULL ) goto memory_error ;\n<73> newnames -> count = count ;\n<74> newnames -> next = names ;\n<75> names = newnames ;\n<76> cur = 0 ;\n<78> len = NAMLEN ( d ) ;\n<79> names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n<80> if ( names -> name [ cur ] == NULL ) goto memory_error ;\n<88> if ( nfound == 0 && ( flags & GLOB_NOCHECK ) ) {\n<89> size_t len = strlen ( pattern ) ;\n<91> names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n<92> if ( names -> name [ cur ] == NULL ) goto memory_error ;\n<93> * ( ( char * ) mempcpy ( names -> name [ cur ++ ] , pattern , len ) ) = '\0' ;\n<96> if ( nfound != 0 ) {\n<99> new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( pglob -> gl_pathc + pglob -> gl_offs + nfound + 1 ) * sizeof ( char * ) ) ;\n<100> if ( new_gl_pathv == NULL ) {\n<102> struct globnames * old = names ;\n<103> for ( size_t i = 0 ;\n<104> i < cur ;\n<105> ++ i ) free ( names -> name [ i ] ) ;\n<106> names = names -> next ;\n<107> if ( names == NULL ) {\n<112> if ( old == names_alloca ) names_alloca = names ;\n<113> else free ( old ) ;\n<115> result = GLOB_NOSPACE ;\n<129> if ( old == names_alloca ) names_alloca = names ;\n<130> else free ( old ) ;\n<137> if ( stream != NULL ) {
<1> static void render_slice(Vp3DecodeContext *s, int slice)\n<323> if(s->avctx->idct_algo==FF_IDCT_VP3){\n<327> memset(block, 0, sizeof(block));\n<331> block[coeff->index]= coeff->coeff * dequantizer[coeff->index];\n<341> memset(block, 0, sizeof(block));\n<345> block[coeff->index]= (coeff->coeff * dequantizer[coeff->index] + 2)>>2;\n<363> block[0] += 128<<3;
<1> int write_output ( void ) {\n<8> if ( fop == NULL ) return - E_NOTHANDLED ;\n<10> ON_ERROR ( fd , - 1 , "Can't create file %s" , EF_GBL_OPTIONS -> output_file ) ;\n<11> fprintf ( stdout , " Writing output to \'%s\' " , EF_GBL_OPTIONS -> output_file ) ;\n<12> fflush ( stdout ) ;\n<14> strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;\n<26> fprintf ( stdout , " done.\n\n" ) ;\n<27> fprintf ( stdout , " -> Script encoded into %d instructions.\n\n" , ( int ) ( i - 1 ) ) ;
<1> static int calculate_new_instance_id(const char *idstr)\n<11> TAILQ_FOREACH(se, &savevm_handlers, entry) {\n<13> if (strcmp(idstr, se->idstr) == 0\n<15> && instance_id <= se->instance_id) {\n<17> instance_id = se->instance_id + 1;
<1> static void rtsp_parse_rtp_info(RTSPState *rt, const char *p)\n<15> p += strspn(p, SPACE_CHARS);\n<21> get_word_sep(key, sizeof(key), "=", &p);\n<23> if (*p != '=')\n<27> p++;\n<29> get_word_sep(value, sizeof(value), ";, ", &p);\n<33> if (!strcmp(key, "url"))\n<35> av_strlcpy(url, value, sizeof(url));\n<37> else if (!strcmp(key, "seq"))\n<39> seq = strtol(value, NULL, 10);\n<41> else if (!strcmp(key, "rtptime"))\n<43> rtptime = strtol(value, NULL, 10);\n<45> if (*p == ',') {\n<59> p++;
<1> static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){\n<19> memset(map[list], 0, sizeof(map[list]));
<1> static inline void mix_2f_1r_to_dolby(AC3DecodeContext *ctx)\n<19> memset(output[3], 0, sizeof(output[3]));
<1> static void ref405ep_init(MachineState *machine)\n<227> if (linux_boot) {\n<235> memset(&bd, 0, sizeof(bd));\n<285> bdloc = ppc405_set_bootinfo(env, &bd, 0x00000001);\n<293> kernel_size = load_image_targphys(kernel_filename, kernel_base,\n<297> if (kernel_size < 0) {\n<299> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<317> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<321> if (initrd_size < 0) {\n<323> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<343> if (kernel_cmdline != NULL) {\n<345> len = strlen(kernel_cmdline);\n<347> bdloc -= ((len + 255) & ~255);\n<349> cpu_physical_memory_write(bdloc, kernel_cmdline, len + 1);\n<353> env->gpr[7] = bdloc + len;
<1> void input_type_enum(Visitor *v, int *obj, const char *strings[],\n<15> assert(strings);\n<19> visit_type_str(v, &enum_str, name, errp);\n<29> while (strings[value] != NULL) {\n<31> if (strcmp(strings[value], enum_str) == 0) {\n<37> value++;\n<43> if (strings[value] == NULL) {\n<47> g_free(enum_str);\n<55> g_free(enum_str);
<1> static inline abi_long do_msgsnd(int msqid, abi_long msgp,\n<3> unsigned int msgsz, int msgflg)\n<15> if (!lock_user_struct(VERIFY_READ, target_mb, msgp, 0))\n<19> host_mb = malloc(msgsz+sizeof(long));\n<21> host_mb->mtype = (abi_long) tswapal(target_mb->mtype);\n<23> memcpy(host_mb->mtext, target_mb->mtext, msgsz);\n<25> ret = get_errno(msgsnd(msqid, host_mb, msgsz, msgflg));\n<27> free(host_mb);\n<29> unlock_user_struct(target_mb, msgp, 0);
<1> static int get_cod(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n<21> tmp.log2_prec_height = 15;\n<25> tmp.csty = bytestream_get_byte(&s->buf);\n<31> tmp.prog_order = bytestream_get_byte(&s->buf);\n<35> tmp.nlayers = bytestream_get_be16(&s->buf);\n<37> tmp.mct     = bytestream_get_byte(&s->buf); // multiple component transformation\n<41> get_cox(s, &tmp);\n<43> for (compno = 0; compno < s->ncomponents; compno++)\n<45> if (!(properties[compno] & HAD_COC))\n<47> memcpy(c + compno, &tmp, sizeof(tmp));
<1> static void cpu_pre_save(void *opaque)\n<9> if (!write_cpustate_to_list(cpu)) {\n<21> memcpy(cpu->cpreg_vmstate_indexes, cpu->cpreg_indexes,\n<23> cpu->cpreg_array_len * sizeof(uint64_t));\n<25> memcpy(cpu->cpreg_vmstate_values, cpu->cpreg_values,\n<27> cpu->cpreg_array_len * sizeof(uint64_t));
<1> int cmdutils_read_file(const char *filename, char **bufptr, size_t *size)\n<11> if (!f) {\n<13> av_log(NULL, AV_LOG_ERROR, "Cannot read file '%s': %s\n", filename,\n<15> strerror(errno));\n<17> return AVERROR(errno);\n<45> if (ferror(f)) {\n<47> av_log(NULL, AV_LOG_ERROR, "Error while reading file '%s': %s\n",\n<49> filename, strerror(errno));\n<51> ret = AVERROR(errno);
<1> static int read_frame_internal(AVFormatContext *s, AVPacket *pkt)\n<237> AVPacketSideData *src_sd = &st->side_data[i];\n<249> dst_data = av_packet_new_side_data(pkt, src_sd->type, src_sd->size);\n<251> if (!dst_data) {\n<261> memcpy(dst_data, src_sd->data, src_sd->size);
<1> static int doTest(uint8_t *ref[4], int refStride[4], int w, int h, int srcFormat, int dstFormat,\n<5> uint8_t *src[4] = {0};\n<7> uint8_t *dst[4] = {0};\n<9> uint8_t *out[4] = {0};\n<27> for (i=0; i<4; i++){\n<59> src[i]= (uint8_t*) malloc(srcStride[i]*srcH);\n<61> dst[i]= (uint8_t*) malloc(dstStride[i]*dstH);\n<63> out[i]= (uint8_t*) malloc(refStride[i]*h);\n<65> if (!src[i] || !dst[i] || !out[i]) {\n<83> if (!srcContext) {\n<87> sws_format_name(PIX_FMT_YUVA420P),\n<89> sws_format_name(srcFormat));\n<101> if (!dstContext) {\n<105> sws_format_name(srcFormat),\n<107> sws_format_name(dstFormat));\n<119> if (!outContext) {\n<123> sws_format_name(dstFormat),\n<125> sws_format_name(PIX_FMT_YUVA420P));\n<143> sws_scale(dstContext, src, srcStride, 0, srcH, dst, dstStride);\n<145> sws_scale(outContext, dst, dstStride, 0, dstH, out, refStride);\n<199> for (i=0; i<4; i++){\n<201> free(src[i]);\n<203> free(dst[i]);\n<205> free(out[i]);
<1> static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n<5> if (r < 0 || r > 15)\n<7> fprintf(stderr, "wrong register write $p%d\n", r);\n<9> if (r == PR_BZ || r == PR_WZ || r == PR_DZ)
<1> USBDevice *usbdevice_create(const char *cmdline)\n<19> params = strchr(cmdline,':');\n<23> params++;\n<25> len = params - cmdline;\n<31> pstrcpy(driver, len, cmdline);\n<37> pstrcpy(driver, sizeof(driver), cmdline);\n<43> for (info = device_info_list; info != NULL; info = info->next) {\n<49> usb = DO_UPCAST(USBDeviceInfo, qdev, info);\n<51> if (usb->usbdevice_name == NULL)\n<55> if (strcmp(usb->usbdevice_name, driver) != 0)\n<83> error_report("usbdevice %s accepts no params", driver);
<1> static void tcx_blit_writel(void *opaque, hwaddr addr,\n<7> TCXState *s = opaque;\n<25> len = ((val >> 24) & 0x1f) + 1;\n<27> if (adsr == 0xffffff) {\n<29> memset(&s->vram[addr], s->tmpblit, len);\n<33> val = s->tmpblit & 0xffffff;\n<37> for (i = 0; i < len; i++) {\n<47> memcpy(&s->vram[addr], &s->vram[adsr], len);\n<49> if (s->depth == 24) {\n<51> memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n<57> memory_region_set_dirty(&s->vram_mem, addr, len);
<1> static void sbr_turnoff ( SpectralBandReplication * sbr ) {\n<6> memset ( & sbr -> spectrum_params , - 1 , sizeof ( SpectrumParameters ) ) ;
<1> static int alloc_f(int argc, char **argv)\n<19> if (offset & 0x1ff) {\n<33> nb_sectors = cvtnum(argv[2]);\n<37> nb_sectors = 1;\n<45> sum_alloc = 0;\n<49> ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n<55> sum_alloc += num;\n<63> cvtstr(offset, s1, sizeof(s1));\n<67> printf("%d/%d sectors allocated at offset %s\n",
<1> static int sunrast_decode_frame(AVCodecContext *avctx, void *data,\n<159> if (buf_end - buf < maplength)\n<191> *(uint32_t *)ptr = (0xFFU<<24) + (buf[x]<<16) + (buf[len+x]<<8) + buf[len+len+x];\n<205> if (!ptr)\n<213> ptr    = p->data[0];\n<285> if (buf_end - buf < len)\n<289> memcpy(ptr, buf, len);\n<291> ptr += stride;\n<293> buf += alen;
<1> int stpcifc_service_call(S390CPU *cpu, uint8_t r1, uint64_t fiba, uint8_t ar)\n<45> if (!pbdev) {\n<55> memset(&fib, 0, sizeof(fib));\n<113> if (s390_cpu_virt_mem_write(cpu, fiba, ar, (uint8_t *)&fib, sizeof(fib))) {
<1> static int mpeg_decode_slice(AVCodecContext *avctx,\n<13> MpegEncContext *s = &s1->mpeg_enc_ctx;\n<21> if (start_code >= s->mb_height){\n<23> fprintf(stderr, "slice below image (%d >= %d)\n", start_code, s->mb_height);\n<35> memset(s->last_mv, 0, sizeof(s->last_mv));\n<43> if(MPV_frame_start(s, avctx) < 0)\n<49> if(s->avctx->debug&FF_DEBUG_PICT_INFO){\n<51> printf("qp:%d fc:%2d%2d%2d%2d %s %s %s %s dc:%d pstruct:%d fdct:%d cmv:%d qtype:%d ivlc:%d rff:%d %s\n",\n<73> s->qscale = get_qscale(s);\n<127> ret = mpeg_decode_mb(s, s->block);\n<137> MPV_decode_mb(s, s->block);\n<143> ff_draw_horiz_band(s);\n<197> if(s->mb_y >= s->mb_height){\n<199> fprintf(stderr, "slice too long\n");\n<231> MPV_frame_end(s);
<1> PCIDevice *virtio_net_init(PCIBus *bus, NICInfo *nd, int devfn)\n<19> if (!n)\n<35> memcpy(n->mac, nd->macaddr, 6);\n<37> n->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<43> qemu_format_nic_info_str(n->vc, n->mac);
<1> void test_self_modifying_code(void)\n<11> printf("self modifying code:\n");\n<13> printf("func1 = 0x%x\n", func());\n<17> printf("func1 = 0x%x\n", func());
<1> static int pci_add_option_rom(PCIDevice *pdev, bool is_default_rom)\n<17> if (!pdev->romfile)\n<21> if (strlen(pdev->romfile) == 0)\n<23> return 0;\n<27> if (!pdev->rom_bar) {\n<41> rom_add_vga(pdev->romfile);\n<45> rom_add_option(pdev->romfile, -1);\n<55> path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);
<1> static int discard_f(BlockBackend *blk, int argc, char **argv)\n<95> if (ret < 0) {\n<97> printf("discard failed: %s\n", strerror(-ret));
<1> static int raw_pread_aligned(BlockDriverState *bs, int64_t offset,\n<21> ret = pread(s->fd, buf, count, offset);\n<23> if (ret == count)\n<35> if (offset >= size) {\n<37> memset(buf, 0, count);\n<39> ret = count;
<1> void syscall_init(void)\n<31> ie = ioctl_entries;\n<35> if (((ie->target_cmd >> TARGET_IOC_SIZESHIFT) & TARGET_IOC_SIZEMASK) ==\n<41> if (arg_type[0] != TYPE_PTR) {\n<43> fprintf(stderr, "cannot patch size for ioctl 0x%x\n",\n<89> ie++;
<1> static void init_ppc_proc (CPUPPCState *env, ppc_def_t *def)\n<35> printf("%s: PVR %08x mask %08x => %08x\n", __func__,\n<37> def->pvr, def->pvr_mask, def->pvr & def->pvr_mask);
<1> int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n<11> switch (run->exit_reason) {\n<39> fprintf(stderr, "Unknown KVM exit: %d\n", run->exit_reason);
<6> AVFrame * picture = data ;\n<68> if ( ! s -> lossless ) {\n<69> picture -> quality = FFMAX3 ( s -> qscale [ 0 ] , s -> qscale [ 1 ] , s -> qscale [ 2 ] ) ;\n<71> picture -> qscale_table = s -> qscale_table ;\n<72> memset ( picture -> qscale_table , picture -> quality , ( s -> width + 15 ) / 16 ) ;\n<73> if ( avctx -> debug & FF_DEBUG_QP ) av_log ( avctx , AV_LOG_DEBUG , "QP: %d\n" , picture -> quality ) ;\n<74> picture -> quality *= FF_QP2LAMBDA ;
<1> static void qemu_cpu_kick_thread(CPUState *cpu)\n<11> err = pthread_kill(cpu->thread->thread, SIG_IPI);\n<13> if (err) {\n<15> fprintf(stderr, "qemu:%s: %s", __func__, strerror(err));
<1> START_TEST(qdict_get_str_test)\n<13> qdict_put(tests_dict, key, qstring_from_str(str));\n<19> fail_unless(p != NULL);\n<21> fail_unless(strcmp(p, str) == 0);
<1> DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type)\n<199> if (qemu_opt_get(legacy_opts, "boot") != NULL) {\n<201> fprintf(stderr, "qemu-kvm: boot=on|off is deprecated and will be "\n<233> value = qemu_opt_get(legacy_opts, "media");\n<235> if (value) {\n<237> if (!strcmp(value, "disk")) {\n<239> media = MEDIA_DISK;\n<241> } else if (!strcmp(value, "cdrom")) {\n<243> media = MEDIA_CDROM;\n<245> read_only = true;\n<249> error_report("'%s' invalid media", value);\n<261> read_only |= qemu_opt_get_bool(legacy_opts, BDRV_OPT_READ_ONLY, false);\n<263> copy_on_read = qemu_opt_get_bool(legacy_opts, "copy-on-read", false);\n<267> if (read_only && copy_on_read) {\n<277> qdict_put_str(bs_opts, BDRV_OPT_READ_ONLY, read_only ? "on" : "off");\n<279> qdict_put_str(bs_opts, "copy-on-read", copy_on_read ? "on" : "off");\n<285> value = qemu_opt_get(legacy_opts, "if");\n<287> if (value) {\n<291> type < IF_COUNT && strcmp(value, if_name[type]);\n<293> type++) {\n<299> error_report("unsupported bus type '%s'", value);\n<357> if (value != NULL) {\n<359> if (!cyls) {\n<369> if (!strcmp(value, "none")) {\n<371> translation = BIOS_ATA_TRANSLATION_NONE;\n<373> } else if (!strcmp(value, "lba")) {\n<375> translation = BIOS_ATA_TRANSLATION_LBA;\n<377> } else if (!strcmp(value, "large")) {\n<379> translation = BIOS_ATA_TRANSLATION_LARGE;\n<381> } else if (!strcmp(value, "rechs")) {\n<383> translation = BIOS_ATA_TRANSLATION_RECHS;\n<385> } else if (!strcmp(value, "auto")) {\n<387> translation = BIOS_ATA_TRANSLATION_AUTO;\n<391> error_report("'%s' invalid translation type", value);\n<401> if (media == MEDIA_CDROM) {\n<515> new_id = g_strdup_printf("%s%i%s%i", if_name[type], bus_id,
<1> static void test_commands(void)\n<11> for (i = 0; hmp_cmds[i] != NULL; i++) {\n<13> if (verbose) {\n<15> fprintf(stderr, "\t%s\n", hmp_cmds[i]);\n<19> response = hmp(hmp_cmds[i]);
<1> void avcodec_get_context_defaults(AVCodecContext *s){\n<3> memset(s, 0, sizeof(AVCodecContext));\n<11> s->bit_rate_tolerance= s->bit_rate*10;\n<61> s->lmin= FF_QP2LAMBDA * s->qmin;\n<63> s->lmax= FF_QP2LAMBDA * s->qmax;
<1> void test_segs(void)\n<97> printf("FS[1] = %02x\n", res);\n<113> printf("GS[1] = %02x\n", res);\n<141> printf("DS[1] = %02x\n", res);\n<143> printf("SS[tmp] = %02x\n", res2);\n<159> printf("FS:reg = %04x:%08x\n", res2, res);
<1> static int vp3_decode_frame(AVCodecContext *avctx,\n<9> Vp3DecodeContext *s = avctx->priv_data;\n<91> init_dequantizer(s);\n<137> avctx->release_buffer(avctx, &s->golden_frame);\n<139> s->last_frame= s->golden_frame; /* ensure that we catch any access to this released frame */\n<145> avctx->release_buffer(avctx, &s->golden_frame);\n<149> avctx->release_buffer(avctx, &s->last_frame);\n<155> s->golden_frame.reference = 3;\n<157> if(avctx->get_buffer(avctx, &s->golden_frame) < 0) {\n<169> memcpy(&s->current_frame, &s->golden_frame, sizeof(AVFrame));\n<193> s->current_frame.reference = 3;\n<195> if(avctx->get_buffer(avctx, &s->current_frame) < 0) {\n<263> render_fragments(s, 0, s->width, s->height, 0);\n<269> if ((avctx->flags & CODEC_FLAG_GRAY) == 0) {\n<281> render_fragments(s, s->v_fragment_start, s->width / 2, s->height / 2, 2);\n<285> memset(s->current_frame.data[1], 0x80, s->width * s->height / 4);\n<287> memset(s->current_frame.data[2], 0x80, s->width * s->height / 4);\n<303> *(AVFrame*)data= s->current_frame;\n<315> avctx->release_buffer(avctx, &s->last_frame);\n<321> memcpy(&s->last_frame, &s->current_frame, sizeof(AVFrame));
<1> static void add_codec(FFServerStream *stream, AVCodecContext *av)\n<21> if (av->bit_rate == 0)\n<23> av->bit_rate = 64000;\n<25> if (av->sample_rate == 0)\n<27> av->sample_rate = 22050;\n<29> if (av->channels == 0)\n<31> av->channels = 1;\n<37> if (av->bit_rate == 0)\n<39> av->bit_rate = 64000;\n<49> if (av->width == 0 || av->height == 0) {\n<51> av->width = 160;\n<53> av->height = 128;\n<59> if (av->bit_rate_tolerance == 0)\n<61> av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,\n<65> if (av->qmin == 0)\n<67> av->qmin = 3;\n<69> if (av->qmax == 0)\n<71> av->qmax = 31;\n<73> if (av->max_qdiff == 0)\n<75> av->max_qdiff = 3;\n<77> av->qcompress = 0.5;\n<79> av->qblur = 0.5;\n<83> if (!av->nsse_weight)\n<85> av->nsse_weight = 8;\n<89> av->frame_skip_cmp = FF_CMP_DCTMAX;\n<91> if (!av->me_method)\n<93> av->me_method = ME_EPZS;\n<95> av->rc_buffer_aggressivity = 1.0;\n<99> if (!av->rc_eq)\n<101> av->rc_eq = av_strdup("tex^qComp");\n<103> if (!av->i_quant_factor)\n<105> av->i_quant_factor = -0.8;\n<107> if (!av->b_quant_factor)\n<109> av->b_quant_factor = 1.25;\n<111> if (!av->b_quant_offset)\n<113> av->b_quant_offset = 1.25;\n<117> av->rc_max_rate = av->bit_rate * 2;\n<121> if (av->rc_max_rate && !av->rc_buffer_size) {\n<123> av->rc_buffer_size = av->rc_max_rate;\n<143> if (!st)\n<147> st->codec = avcodec_alloc_context3(NULL);\n<151> memcpy(st->codec, av, sizeof(AVCodecContext));
<1> static void do_audio_out(AVFormatContext *s,\n<7> unsigned char *buf, int size)\n<21> AVCodecContext *enc= ost->st->codec;\n<23> AVCodecContext *dec= ist->st->codec;\n<57> if(audio_out_size > INT_MAX || audio_buf_size > INT_MAX){\n<59> fprintf(stderr, "Buffer sizes too large\n");\n<71> if (!audio_buf || !audio_out){\n<73> fprintf(stderr, "Out of memory in do_audio_out\n");\n<89> if (dec->sample_fmt != SAMPLE_FMT_S16)\n<91> fprintf(stderr, "Warning, using s16 intermediate sample format for resampling\n");\n<93> ost->resample = av_audio_resample_init(enc->channels,    dec->channels,\n<101> if (!ost->resample) {\n<103> fprintf(stderr, "Can not resample %d channels @ %d Hz to %d channels @ %d Hz\n",\n<131> if (!ost->reformat_ctx) {\n<133> fprintf(stderr, "Cannot convert %s sample format to %s sample format\n",\n<135> avcodec_get_sample_fmt_name(dec->sample_fmt),\n<137> avcodec_get_sample_fmt_name(enc->sample_fmt));\n<151> double delta = get_sync_ipts(ost) * enc->sample_rate - ost->sync_opts\n<153> - av_fifo_size(ost->fifo)/(enc->channels * 2);\n<155> double idelta= delta*dec->sample_rate / enc->sample_rate;\n<157> int byte_delta= ((int)idelta)*2*dec->channels;\n<165> if(ist->is_start || fabs(delta) > audio_drift_threshold*enc->sample_rate){\n<175> if(verbose > 2)\n<177> fprintf(stderr, "discarding %d audio samples\n", (int)-delta);\n<189> input_tmp= av_realloc(input_tmp, byte_delta + size);\n<193> if(byte_delta > allocated_for_size - size){\n<205> memset(input_tmp, 0, byte_delta);\n<207> memcpy(input_tmp + byte_delta, buf, size);\n<209> buf= input_tmp;\n<211> size += byte_delta;\n<213> if(verbose > 2)\n<215> fprintf(stderr, "adding %d audio samples of silence\n", (int)delta);\n<221> int comp= av_clip(delta, -audio_sync_method, audio_sync_method);\n<225> if(verbose > 2)\n<227> fprintf(stderr, "compensating audio timestamp drift:%f compensation:%d in:%d\n", delta, comp, enc->sample_rate);\n<231> av_resample_compensate(*(struct AVResampleContext**)ost->resample, comp, enc->sample_rate);\n<239> ost->sync_opts= lrintf(get_sync_ipts(ost) * enc->sample_rate)\n<241> - av_fifo_size(ost->fifo)/(enc->channels * 2); //FIXME wrong\n<253> size / (dec->channels * isize));\n<279> if (av_audio_convert(ost->reformat_ctx, obuf, ostride, ibuf, istride, len)<0) {\n<281> printf("av_audio_convert() failed\n");\n<305> if (av_fifo_realloc2(ost->fifo, av_fifo_size(ost->fifo) + size_out) < 0) {\n<307> fprintf(stderr, "av_fifo_realloc2() failed\n");\n<341> if (ret < 0) {\n<343> fprintf(stderr, "Audio encoding failed\n");\n<395> if(size_out > audio_out_size){\n<397> fprintf(stderr, "Internal error, buffer size too small\n");\n<411> if (ret < 0) {\n<413> fprintf(stderr, "Audio encoding failed\n");
<1> static void virtio_net_device_realize(DeviceState *dev, Error **errp)\n<33> if (n->net_conf.tx && strcmp(n->net_conf.tx, "timer")\n<35> && strcmp(n->net_conf.tx, "bh")) {\n<41> n->net_conf.tx);\n<43> error_report("Defaulting to \"bh\"");\n<49> if (n->net_conf.tx && !strcmp(n->net_conf.tx, "timer")) {\n<51> n->vqs[0].tx_vq = virtio_add_queue(vdev, 256,\n<55> n->vqs[0].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, virtio_net_tx_timer,\n<57> &n->vqs[0]);\n<61> n->vqs[0].tx_vq = virtio_add_queue(vdev, 256,\n<65> n->vqs[0].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[0]);\n<71> qemu_macaddr_default_if_unset(&n->nic_conf.macaddr);\n<73> memcpy(&n->mac[0], &n->nic_conf.macaddr, sizeof(n->mac));
<1> static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)\n<41> if (errno == EAGAIN) {\n<51> av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_DQBUF): %s\n",\n<53> strerror(errno));\n<57> return AVERROR(errno);\n<101> res = av_new_packet(pkt, buf.bytesused);\n<103> if (res < 0) {\n<111> memcpy(pkt->data, s->buf_start[buf.index], buf.bytesused);\n<115> res = ioctl(s->fd, VIDIOC_QBUF, &buf);\n<121> av_free_packet(pkt);
<1> int configure_filtergraph(FilterGraph *fg)\n<23> if (simple) {\n<27> char args[512];\n<33> args[0] = 0;\n<39> av_strlcatf(args, sizeof(args), "%s=%s:", e->key, e->value);\n<43> if (strlen(args))\n<45> args[strlen(args)-1] = 0;\n<47> fg->graph->scale_sws_opts = av_strdup(args);\n<51> args[0] = 0;\n<57> av_strlcatf(args, sizeof(args), "%s=%s:", e->key, e->value);\n<61> if (strlen(args))\n<63> args[strlen(args)-1] = 0;\n<65> av_opt_set(fg->graph, "aresample_swr_opts", args, 0);\n<69> args[0] = '\0';\n<75> av_strlcatf(args, sizeof(args), "%s=%s:", e->key, e->value);\n<79> if (strlen(args))\n<81> args[strlen(args) - 1] = '\0';\n<83> fg->graph->resample_lavr_opts = av_strdup(args);
<1> static int rtp_open(URLContext *h, const char *uri, int flags)\n<25> if (!s)\n<33> url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,\n<43> p = strchr(uri, '?');\n<47> if (find_info_tag(buf, sizeof(buf), "ttl", p)) {
<1> int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick ) {\n<25> if ( ! ( param -> testflag & T_SILENT ) ) {\n<26> printf ( "- parallel recovering (with sort) MyISAM-table '%s'\n" , name ) ;\n<27> printf ( "Data records: %s\n" , llstr ( start_records , llbuff ) ) ;\n<79> rec_per_key_part = param -> rec_per_key_part ;\n<84> rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) {\n<88> if ( ! mi_is_key_active ( key_map , key ) ) {\n<89> memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n<94> if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( "- Fixing index %d\n" , key + 1 ) ;
<1> static void tc6393xb_gpio_set(void *opaque, int line, int level)\n<9> if (line > TC6393XB_GPIOS) {\n<11> printf("%s: No GPIO pin %i\n", __FUNCTION__, line);
<1> static int read_thread(void *arg)\n<5> VideoState *is = arg;\n<29> memset(st_index, -1, sizeof(st_index));\n<31> is->last_video_stream = is->video_stream = -1;\n<33> is->last_audio_stream = is->audio_stream = -1;\n<35> is->last_subtitle_stream = is->subtitle_stream = -1;\n<45> err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n<85> if (err < 0) {\n<87> fprintf(stderr, "%s: could not find codec parameters\n", is->filename);\n<137> if (ret < 0) {\n<139> fprintf(stderr, "%s: could not seek to position %0.3f\n",\n<141> is->filename, (double)timestamp / AV_TIME_BASE);\n<185> (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n<195> av_dump_format(ic, 0, is->filename, 0);\n<207> if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n<209> stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n<217> if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n<219> ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);\n<229> is->refresh_tid = SDL_CreateThread(refresh_thread, is);\n<233> if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {\n<235> stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);\n<241> if (is->video_stream < 0 && is->audio_stream < 0) {\n<243> fprintf(stderr, "%s: could not open codecs\n", is->filename);\n<313> ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n<315> if (ret < 0) {\n<317> fprintf(stderr, "%s: error while seeking\n", is->ic->filename);\n<349> update_external_clock_pts(is, (double)AV_NOPTS_VALUE);\n<353> update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE);\n<365> step_to_next_frame(is);\n<441> stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n<531> stream_component_close(is, is->audio_stream);\n<535> stream_component_close(is, is->video_stream);\n<539> stream_component_close(is, is->subtitle_stream);\n<543> avformat_close_input(&is->ic);\n<557> event.user.data1 = is;
<1> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n<11> if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {\n<12> free ( ext_fb_list -> ext_fb [ i ] . data ) ;\n<13> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ;\n<15> ext_fb_list -> ext_fb [ i ] . size = min_size ;
<1> static int flic_decode_frame_15_16BPP(AVCodecContext *avctx,\n<73> pixels = s->frame.data[0];\n<125> switch (chunk_type) {\n<261> s->frame.linesize[0] * s->avctx->height);\n<301> pixels[pixel_ptr++] = palette_idx1;\n<327> pixels[pixel_ptr++] = palette_idx1;
<1> static int connect_namedsocket(const char *path)\n<11> if (strlen(path) >= sizeof(helper.sun_path)) {\n<13> fprintf(stderr, "Socket name too large\n");\n<15> return -1;\n<19> sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n<21> if (sockfd < 0) {\n<23> fprintf(stderr, "failed to create socket: %s\n", strerror(errno));\n<29> strcpy(helper.sun_path, path);\n<33> size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n<35> if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n<37> fprintf(stderr, "failed to connect to %s: %s\n", path, strerror(errno));
<1> static void evalPrimary(Parser *p){\n<15> if(next != p->s){\n<29> for(i=0; p->const_name[i]; i++){\n<31> if(strmatch(p->s, p->const_name[i])){\n<33> push(p, p->const_value[i]);\n<35> p->s+= strlen(p->const_name[i]);\n<45> p->s= strchr(p->s, '(');\n<47> if(p->s==NULL){
<1> static int udp_read(URLContext *h, uint8_t *buf, int size)\n<5> UDPContext *s = h->priv_data;\n<79> if (!(h->flags & AVIO_FLAG_NONBLOCK)) {\n<81> ret = ff_network_wait_fd(s->udp_fd, 0);\n<83> if (ret < 0)\n<89> ret = recv(s->udp_fd, buf, size, 0);\n<93> return ret < 0 ? ff_neterrno() : ret;
<1> static int vble_unpack(VBLEContext *ctx, GetBitContext *gb)\n<31> for (i = 0; i < ctx->size; i++) {\n<67> memset(ctx->val, 0, ctx->size);\n<71> for (i = 0; i < ctx->size; i++) {
<1> static int decode_init_thread_copy(AVCodecContext *avctx)\n<5> H264Context *h = avctx->priv_data;\n<11> if (!avctx->internal->is_copy)\n<15> memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n<17> memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n<21> ret = h264_init_context(avctx, h);
<1> CharDriverState *text_console_init(DisplayState *ds, const char *p)\n<19> if (!chr)\n<25> if (!s) {\n<27> free(chr);
<1> DriveInfo *drive_get_by_id(const char *id)\n<9> TAILQ_FOREACH(dinfo, &drives, next) {\n<11> if (strcmp(id, dinfo->id))\n<15> return dinfo;
<1> static void test_qemu_strtoull_octal(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoull(str, &endptr, 8, &res);\n<25> g_assert(endptr == str + strlen(str));\n<29> endptr = &f;\n<33> err = qemu_strtoull(str, &endptr, 0, &res);\n<41> g_assert(endptr == str + strlen(str));
<1> static void l2cap_command(struct l2cap_instance_s *l2cap, int code, int id,\n<31> if (id == l2cap->next_id) {\n<47> switch (code) {\n<51> if (unlikely(len != 2 && len != 4 && len != 6)) {\n<63> fprintf(stderr, "%s: stray Command Reject (%02x, %04x) "\n<67> le16_to_cpu(((l2cap_cmd_rej *) params)->reason));\n<97> if (unlikely(len != L2CAP_CONN_RSP_SIZE)) {\n<109> fprintf(stderr, "%s: unexpected Connection Response (%02x) "\n<167> fprintf(stderr, "%s: unexpected Configure Response (%02x) "\n<199> if (unlikely(len != L2CAP_DISCONN_RSP_SIZE)) {\n<211> fprintf(stderr, "%s: unexpected Disconnection Response (%02x) "\n<231> fprintf(stderr, "%s: unexpected Echo Response (%02x) "\n<259> if (unlikely(len != L2CAP_INFO_RSP_SIZE)) {\n<271> fprintf(stderr, "%s: unexpected Information Response (%02x) "
<1> void helper_xssqrtqp(CPUPPCState *env, uint32_t opcode)\n<15> memset(&xt, 0, sizeof(xt));\n<69> putVSR(rD(opcode) + 32, &xt, env);
<1> static int ipvideo_decode_block_opcode_0x9(IpvideoContext *s)\n<7> unsigned char P[4];\n<17> memcpy(P, s->stream_ptr, 4);\n<19> s->stream_ptr += 4;\n<23> if (P[0] <= P[1]) {\n<25> if (P[2] <= P[3]) {\n<43> *s->pixel_ptr++ = P[flags & 0x03];\n<77> s->pixel_ptr[x + 1 + s->stride] = P[flags & 0x03];\n<103> if (P[2] <= P[3]) {\n<111> s->pixel_ptr[x + 1] = P[flags & 0x03];\n<127> s->pixel_ptr[x + s->stride] = P[flags & 0x03];
<1> TEST_F ( TransportSecurityPersisterTest , PublicKeyHashes ) {\n<9> memset ( sha1 . data ( ) , '1' , sha1 . size ( ) ) ;\n<28> EXPECT_EQ ( 0 , memcmp ( domain_state . dynamic_spki_hashes [ 0 ] . data ( ) , sha1 . data ( ) , sha1 . size ( ) ) ) ;
<1> static void acpi_get_hotplug_info(AcpiMiscInfo *misc)\n<11> if (!bus) {\n<15> memset(misc->slot_hotplug_enable, 0, sizeof misc->slot_hotplug_enable);\n<25> DIV_ROUND_UP(PCI_SLOT_MAX, BITS_PER_BYTE));\n<55> clear_bit(slot, misc->slot_hotplug_enable);
<1> void ff_rtp_send_jpeg(AVFormatContext *s1, const uint8_t *buf, int size)\n<63> if (buf[i] != 0xff)\n<69> if (buf[i + 1] == DQT) {\n<81> nb_qtables = AV_RB16(&buf[i + 2]) / 65;\n<95> } else if (buf[i + 1] == SOF0) {\n<97> if (buf[i + 14] != 17 || buf[i + 17] != 17) {\n<107> } else if (buf[i + 1] == SOS) {\n<123> buf  += i;\n<131> if (buf[i] == 0xff && buf[i + 1] == EOI) {\n<145> p = s->buf_ptr;\n<147> while (size > 0) {\n<161> len = FFMIN(size, s->max_payload_size - hdr_size);\n<167> bytestream_put_byte(&p, 0);\n<169> bytestream_put_be24(&p, off);\n<171> bytestream_put_byte(&p, type);\n<173> bytestream_put_byte(&p, 255);\n<175> bytestream_put_byte(&p, w);\n<177> bytestream_put_byte(&p, h);\n<185> bytestream_put_byte(&p, 0);\n<187> bytestream_put_byte(&p, 0);\n<189> bytestream_put_be16(&p, 64 * nb_qtables);\n<195> bytestream_put_buffer(&p, &qtables[65 * i + 1], 64);\n<203> memcpy(p, buf, len);\n<209> ff_rtp_send_data(s1, s->buf, len + hdr_size, size == len);\n<213> buf  += len;\n<219> p     = s->buf;
<1> static int a64multi_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<41> int charset_size = 0x800 * (INTERLACED + 1);\n<141> buf = pkt->data;\n<159> if (ret < 0)\n<167> render_charset(avctx, charset, colram);\n<173> memcpy(buf, charset, charset_size);\n<179> buf      += charset_size;\n<181> charset  += charset_size;\n<237> AV_WB32(avctx->extradata + 8,  charset_size);
<1> static void test_io(void)\n<29> iov_random(&iov, &niov);\n<45> siov = g_memdup(iov, sizeof(*iov) * niov);\n<85> for (j = i; j <= sz; ++j) {\n<93> r = iov_send(sv[1], iov, niov, k, s);\n<95> g_assert(memcmp(iov, siov, sizeof(*iov)*niov) == 0);\n<119> } while(k < j);\n<125> iov_free(iov, niov);\n<129> g_free(siov);\n<157> for (j = i; j <= sz; ++j) {\n<167> r = iov_recv(sv[0], iov, niov, k, s);\n<169> g_assert(memcmp(iov, siov, sizeof(*iov)*niov) == 0);\n<199> } while(k < j);\n<201> test_iov_bytes(iov, niov, i, j - i);\n<213> g_free(siov);
<1> static int xan_decode_frame(AVCodecContext *avctx,\n<13> XanContext *s = avctx->priv_data;\n<51> tmpptr = av_realloc(s->palettes, (s->palettes_count + 1) * AVPALETTE_SIZE);\n<57> s->palettes = tmpptr;\n<125> if ((ret = avctx->get_buffer(avctx, &s->current_frame))) {\n<143> memcpy(s->current_frame.data[1], s->palettes + s->cur_palette * AVPALETTE_COUNT, AVPALETTE_SIZE);
<1> static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)\n<5> DynBuffer *d = opaque;\n<33> if (new_allocated_size > d->allocated_size) {\n<37> if (!new_buffer)\n<41> memcpy(new_buffer, d->buffer, d->size);\n<43> av_free(d->buffer);\n<45> d->buffer = new_buffer;\n<51> memcpy(d->buffer + d->pos, buf, buf_size);\n<55> if (d->pos > d->size)
<1> static void colo_compare_complete(UserCreatable *uc, Error **errp)\n<5> CompareState *s = COLO_COMPARE(uc);\n<9> char thread_name[64];\n<15> if (!s->pri_indev || !s->sec_indev || !s->outdev) {\n<23> } else if (!strcmp(s->pri_indev, s->outdev) ||\n<25> !strcmp(s->sec_indev, s->outdev) ||\n<27> !strcmp(s->pri_indev, s->sec_indev)) {\n<29> error_setg(errp, "'indev' and 'outdev' could not be same "\n<33> return;\n<39> if (find_and_check_chardev(&chr, s->pri_indev, errp) ||\n<49> if (find_and_check_chardev(&chr, s->sec_indev, errp) ||\n<59> if (find_and_check_chardev(&chr, s->outdev, errp) ||\n<89> sprintf(thread_name, "colo-compare %d", compare_id);\n<97> compare_id++;
<1> void av_free(void *ptr)\n<17> free(ptr);
<1> static void vtd_realize(DeviceState *dev, Error **errp)\n<39> if (!vtd_decide_config(s, errp)) {\n<49> memset(s->vtd_as_by_bus_num, 0, sizeof(s->vtd_as_by_bus_num));\n<51> memory_region_init_io(&s->csrmem, OBJECT(s), &vtd_mem_ops, s,\n<55> sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->csrmem);\n<67> vtd_init(s);\n<69> sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, Q35_HOST_BRIDGE_IOMMU_ADDR);\n<75> pcms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
<1> static void raw_reopen_commit(BDRVReopenState *state)\n<5> BDRVRawState *new_s = state->opaque;\n<7> BDRVRawState *s = state->bs->opaque;\n<11> memcpy(s, new_s, sizeof(BDRVRawState));
<1> int main ( int argc , char * * argv ) {\n<2> if ( argc > 1 && ! strcmp ( argv [ 1 ] , "--verbose" ) ) verbose = 1 ;\n<3> else if ( argc > 1 && ! strcmp ( argv [ 1 ] , "--debug" ) ) verbose = debug = 1 ;
<1> static int tpm_passthrough_unix_tx_bufs(TPMPassthruState *tpm_pt,\n<25> (tpm_pt->tpm_op_canceled && errno != ECANCELED)) {\n<27> error_report("tpm_passthrough: error while transmitting data "\n<31> strerror(errno), errno);\n<51> (tpm_pt->tpm_op_canceled && errno != ECANCELED)) {\n<53> error_report("tpm_passthrough: error while reading data from "\n<57> strerror(errno), errno);
<1> static void bastardized_rice_decompress(ALACContext *alac,\n<3> int32_t *output_buffer,\n<191> if (block_size > 0) {\n<193> memset(&output_buffer[output_count+1], 0, block_size * 4);
<1> START_TEST(qdict_stress_test)\n<65> if (!value)\n<71> str1 = qstring_get_str(value);\n<77> fail_unless(str2 != NULL);\n<81> fail_unless(strcmp(str1, str2) == 0);
<1> static CharDriverState *qemu_chr_open_pty(void)\n<11> if (openpty(&master_fd, &slave_fd, NULL, NULL, NULL) < 0) {\n<27> fprintf(stderr, "char device redirected to %s\n", ptsname(master_fd));
<1> static int selinux_setprocattr ( struct task_struct * p , char * name , void * value , size_t size ) {\n<7> if ( current != p ) {\n<10> if ( ! strcmp ( name , "exec" ) ) error = current_has_perm ( p , PROCESS__SETEXEC ) ;\n<11> else if ( ! strcmp ( name , "fscreate" ) ) error = current_has_perm ( p , PROCESS__SETFSCREATE ) ;\n<12> else if ( ! strcmp ( name , "keycreate" ) ) error = current_has_perm ( p , PROCESS__SETKEYCREATE ) ;\n<13> else if ( ! strcmp ( name , "sockcreate" ) ) error = current_has_perm ( p , PROCESS__SETSOCKCREATE ) ;\n<14> else if ( ! strcmp ( name , "current" ) ) error = current_has_perm ( p , PROCESS__SETCURRENT ) ;\n<15> else error = - EINVAL ;\n<17> if ( size && str [ 1 ] && str [ 1 ] != '\n' ) {\n<23> if ( error == - EINVAL && ! strcmp ( name , "fscreate" ) ) {\n<24> if ( ! capable ( CAP_MAC_ADMIN ) ) {\n<37> if ( error ) return error ;\n<40> if ( ! new ) return - ENOMEM ;\n<42> if ( ! strcmp ( name , "exec" ) ) {\n<43> tsec -> exec_sid = sid ;\n<45> else if ( ! strcmp ( name , "fscreate" ) ) {\n<46> tsec -> create_sid = sid ;\n<48> else if ( ! strcmp ( name , "keycreate" ) ) {\n<49> error = may_create_key ( sid , p ) ;\n<50> if ( error ) goto abort_change ;\n<53> else if ( ! strcmp ( name , "sockcreate" ) ) {\n<54> tsec -> sockcreate_sid = sid ;\n<56> else if ( ! strcmp ( name , "current" ) ) {\n<57> error = - EINVAL ;\n<58> if ( sid == 0 ) goto abort_change ;\n<74> error = - EINVAL ;\n<77> commit_creds ( new ) ;\n<78> return size ;\n<79> abort_change : abort_creds ( new ) ;\n<80> return error ;
<1> int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n<3> const uint8_t *name, uint8_t *dst, int dst_size)\n<7> int namelen = strlen(name);\n<39> if (size < 0 || size >= data_end - data)\n<45> if (size == namelen && !memcmp(data-size, name, namelen)) {\n<47> switch (*data++) {\n<79> len = ff_amf_tag_size(data, data_end);\n<81> if (len < 0 || len >= data_end - data)
<1> int jbig2_decode_halftone_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , Jbig2HalftoneRegionParams * params , const byte * data , const size_t size , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n<11> memset ( image -> data , params -> HDEFPIXEL , image -> stride * image -> height ) ;\n<41> jbig2_image_compose ( ctx , image , HPATS -> patterns [ gray_val ] , x , y , params -> op ) ;
<1> static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset)\n<9> switch (offset) {\n<145> printf ("arm_sysctl_read: Bad register offset 0x%x\n", (int)offset);
<1> x11grab_read_header(AVFormatContext *s1, AVFormatParameters *ap)\n<15> int x_off = 0;\n<17> int y_off = 0;\n<29> param = av_strdup(s1->filename);\n<31> offset = strchr(param, '+');\n<33> if (offset) {\n<35> sscanf(offset, "%d,%d", &x_off, &y_off);\n<37> x11grab->nomouse= strstr(offset, "nomouse");\n<77> av_log(s1, AV_LOG_INFO, "device: %s -> display: %s x: %d y: %d width: %d height: %d\n",\n<171> image = XGetImage(dpy, RootWindow(dpy, DefaultScreen(dpy)),\n<287> x11grab->x_off = x_off;\n<289> x11grab->y_off = y_off;
<1> static enum AVHWDeviceType hw_device_match_type_in_name(const char *codec_name)\n<11> type != AV_HWDEVICE_TYPE_NONE;\n<13> type = av_hwdevice_iterate_types(type)) {\n<15> type_name = av_hwdevice_get_type_name(type);\n<17> if (strstr(codec_name, type_name))\n<19> return type;
<1> static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)\n<103> av_buffersink_get_frame_flags(lavfi->sinks[min_pts_sink_idx], frame, 0);\n<113> if ((ret = av_new_packet(pkt, size)) < 0)\n<119> memcpy(pict.data,     frame->data,     4*sizeof(frame->data[0]));\n<121> memcpy(pict.linesize, frame->linesize, 4*sizeof(frame->linesize[0]));\n<125> avpicture_layout(&pict, frame->format, frame->width, frame->height,\n<135> if ((ret = av_new_packet(pkt, size)) < 0)\n<139> memcpy(pkt->data, frame->data[0], size);\n<145> frame_metadata = av_frame_get_metadata(frame);\n<157> av_bprint_init(&meta_buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n<161> av_bprintf(&meta_buf, "%s", e->key);\n<163> av_bprint_chars(&meta_buf, '\0', 1);\n<165> av_bprintf(&meta_buf, "%s", e->value);\n<167> av_bprint_chars(&meta_buf, '\0', 1);\n<173> !(metadata = av_packet_new_side_data(pkt, AV_PKT_DATA_STRINGS_METADATA,\n<183> memcpy(metadata, meta_buf.str, meta_buf.len);\n<185> av_bprint_finalize(&meta_buf, NULL);\n<191> if ((ret = create_subcc_packet(avctx, frame, min_pts_sink_idx)) < 0) {\n<193> av_frame_unref(frame);\n<195> av_packet_unref(pkt);\n<207> pkt->pos = av_frame_get_pkt_pos(frame);\n<209> pkt->size = size;\n<211> av_frame_unref(frame);\n<213> return size;
<1> static void check_pred16x16(H264PredContext *h, uint8_t *buf0, uint8_t *buf1,\n<17> if (check_pred_func(h->pred16x16[pred_mode], "16x16", pred16x16_modes[codec][pred_mode])) {\n<25> if (memcmp(buf0, buf1, BUF_SIZE))\n<27> fail();
<1> static vpx_codec_err_t parse_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n<11> if ( scale_factors == NULL || strlen ( scale_factors ) == 0 ) {\n<12> input_string = strdup ( DEFAULT_SCALE_FACTORS ) ;\n<15> input_string = strdup ( scale_factors ) ;\n<17> token = strtok_r ( input_string , delim , & save_ptr ) ;\n<50> free ( input_string ) ;
<1> tcp_dooptions(struct tcpcb *tp, u_char *cp, int cnt, struct tcpiphdr *ti)\n<17> for (; cnt > 0; cnt -= optlen, cp += optlen) {\n<55> if (!(ti->ti_flags & TH_SYN))\n<59> memcpy((char *) &mss, (char *) cp + 2, sizeof(mss));\n<63> (void) tcp_mss(tp, mss);	/* sets t_maxseg */
<1> static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size)\n<7> HEVCLocalContext *lc = &s->HEVClc;\n<39> SAMPLE_CTB(s->skip_flag, x_cb, y_cb) = 0;\n<61> uint8_t skip_flag = ff_hevc_skip_flag_decode(s, x0, y0, x_cb, y_cb);\n<69> for (y = 0; y < length; y++) {\n<71> memset(&s->skip_flag[x], skip_flag, length);\n<83> if (SAMPLE_CTB(s->skip_flag, x_cb, y_cb)) {\n<281> for (y = 0; y < length; y++) {\n<283> memset(&s->qp_y_tab[x], lc->qp_y, length);
<1> static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) {\n<5> if ( length <= 0 ) return ;\n<6> b = ( uint8_t * ) malloc ( length ) ;\n<7> if ( b == NULL ) return ;\n<8> for ( s = ( u_char * ) p , t = b , i = length ;\n<23> length = t - b ;\n<24> if ( length < 1 ) goto trunc ;\n<26> switch ( proto ) {\n<33> if ( length < 2 ) goto trunc ;\n<34> proto = EXTRACT_16BITS ( b ) ;\n<35> switch ( proto ) {\n<36> case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ;\n<44> free ( b ) ;\n<47> free ( b ) ;
<1> static int userauth_pubkey ( struct ssh * ssh ) {\n<6> char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;\n<12> if ( ! authctxt -> valid ) {\n<16> if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( "%s: parse request failed: %s" , __func__ , ssh_err ( r ) ) ;\n<22> if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n<48> if ( have_sig ) {\n<49> debug3 ( "%s: have %s signature for %s%s%s" , __func__ , pkalg , key_s , ca_s == NULL ? "" : " CA " , ca_s == NULL ? "" : ca_s ) ;\n<50> if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( "%s: %s" , __func__ , ssh_err ( r ) ) ;\n<58> xasprintf ( & userstyle , "%s%s%s" , authctxt -> user , authctxt -> style ? ":" : "" , authctxt -> style ? authctxt -> style : "" ) ;\n<59> if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , "publickey" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( "%s: build packet failed: %s" , __func__ , ssh_err ( r ) ) ;\n<62> if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) {\n<66> free ( sig ) ;\n<70> debug ( "%s: test pkalg %s pkblob %s%s%s" , __func__ , pkalg , key_s , ca_s == NULL ? "" : " CA " , ca_s == NULL ? "" : ca_s ) ;\n<73> if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( "%s: %s" , __func__ , ssh_err ( r ) ) ;\n<81> debug2 ( "%s: authenticated %d pkalg %s" , __func__ , authenticated , pkalg ) ;\n<84> free ( userstyle ) ;\n<85> free ( pkalg ) ;\n<86> free ( pkblob ) ;\n<87> free ( key_s ) ;\n<88> free ( ca_s ) ;
<1> static void configure_rtc_date_offset(const char *startdate, int legacy)\n<11> if (!strcmp(startdate, "now") && legacy) {\n<13> rtc_date_offset = -1;\n<19> &tm.tm_year,\n<21> &tm.tm_mon,\n<23> &tm.tm_mday,\n<25> &tm.tm_hour,\n<27> &tm.tm_min,\n<29> &tm.tm_sec) == 6) {\n<35> &tm.tm_year,\n<37> &tm.tm_mon,\n<39> &tm.tm_mday) == 3) {\n<41> tm.tm_hour = 0;\n<43> tm.tm_min = 0;\n<45> tm.tm_sec = 0;\n<53> tm.tm_year -= 1900;\n<55> tm.tm_mon--;\n<57> rtc_start_date = mktimegm(&tm);\n<59> if (rtc_start_date == -1) {\n<63> fprintf(stderr, "Invalid date format. Valid formats are:\n"\n<67> exit(1);\n<71> rtc_date_offset = time(NULL) - rtc_start_date;
<1> static void tcp_accept_incoming_migration(void *opaque)\n<29> if (c == -1) {\n<31> fprintf(stderr, "could not accept migration connection\n");\n<41> if (f == NULL) {\n<43> fprintf(stderr, "could not qemu_fopen socket\n");\n<53> if (ret < 0) {\n<55> fprintf(stderr, "load of migration failed\n");
<1> static void kvm_arm_machine_init_done(Notifier *notifier, void *data)\n<15> if (kvm_vm_ioctl(kvm_state, KVM_ARM_SET_DEVICE_ADDR,\n<19> fprintf(stderr, "KVM_ARM_SET_DEVICE_ADDRESS failed: %s\n",\n<21> strerror(errno));
<1> void gtod_save(QEMUFile *f, void *opaque)\n<13> r = s390_get_clock(&tod_high, &tod_low);\n<15> if (r) {\n<17> fprintf(stderr, "WARNING: Unable to get guest clock for migration. "
<1> static void kvm_handle_internal_error(CPUState *env, struct kvm_run *run)\n<7> if (kvm_check_extension(kvm_state, KVM_CAP_INTERNAL_ERROR_DATA)) {\n<13> fprintf(stderr, "KVM internal error. Suberror: %d\n",\n<29> cpu_dump_state(env, stderr, fprintf, 0);\n<31> if (run->internal.suberror == KVM_INTERNAL_ERROR_EMULATION) {\n<33> fprintf(stderr, "emulation failure\n");\n<35> if (!kvm_arch_stop_on_emulation_error(env)) {
<1> int nbd_client(int fd)\n<17> if (ret == -1 && errno == EPIPE) {\n<27> ret = 0;\n<31> serrno = errno;\n<35> TRACE("NBD loop returned %d: %s", ret, strerror(serrno));\n<51> errno = serrno;\n<53> return ret;
<1> int show_filters(void *optctx, const char *opt, const char *arg)\n<9> printf("Filters:\n");
<1> static int mpeg_decode_mb ( MpegEncContext * s , int16_t block [ 12 ] [ 64 ] ) {\n<57> if ( IS_QUANT ( mb_type ) ) s -> qscale = get_qscale ( s ) ;\n<58> if ( s -> concealment_motion_vectors ) {\n<64> else memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;\n<67> ff_xvmc_pack_pblocks ( s , - 1 ) ;\n<69> exchange_uv ( s ) ;\n<77> mpeg2_fast_decode_block_intra ( s , * s -> pblocks [ i ] , i ) ;\n<84> if ( mpeg2_decode_block_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;\n<92> if ( mpeg1_decode_block_intra ( s , * s -> pblocks [ i ] , i ) < 0 ) return - 1 ;
<1> static void show_stream(AVFormatContext *fmt_ctx, int stream_idx)\n<5> AVStream *stream = fmt_ctx->streams[stream_idx];\n<19> printf("[STREAM]\n");\n<23> printf("index=%d\n", stream->index);\n<27> if ((dec_ctx = stream->codec)) {\n<29> if ((dec = dec_ctx->codec)) {\n<31> printf("codec_name=%s\n", dec->name);\n<33> printf("codec_long_name=%s\n", dec->long_name);\n<37> printf("codec_name=unknown\n");\n<43> printf("codec_type=%s\n", media_type_string(dec_ctx->codec_type));\n<53> av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n<55> printf("codec_tag_string=%s\n", val_str);\n<57> printf("codec_tag=0x%04x\n", dec_ctx->codec_tag);\n<61> switch (dec_ctx->codec_type) {\n<65> printf("width=%d\n", dec_ctx->width);\n<67> printf("height=%d\n", dec_ctx->height);\n<69> printf("has_b_frames=%d\n", dec_ctx->has_b_frames);\n<71> if (dec_ctx->sample_aspect_ratio.num) {\n<79> av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n<81> dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n<83> dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n<99> printf("level=%d\n", dec_ctx->level);\n<107> printf("sample_rate=%s\n", value_string(val_str, sizeof(val_str),\n<113> printf("channels=%d\n", dec_ctx->channels);\n<117> av_get_bits_per_sample(dec_ctx->codec_id));\n<125> printf("codec_type=unknown\n");\n<131> if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)\n<133> printf("id=0x%x\n", stream->id);\n<169> printf("TAG:%s=%s\n", tag->key, tag->value);\n<173> printf("[/STREAM]\n");
<1> BlockDriverAIOCB *bdrv_aio_write(BlockDriverState *bs, int64_t sector_num,\n<3> const uint8_t *buf, int nb_sectors,\n<23> if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n<25> memcpy(bs->boot_sector_data, buf, 512);\n<31> ret = drv->bdrv_aio_write(bs, sector_num, buf, nb_sectors, cb, opaque);
<1> static int inet_listen_saddr(InetSocketAddress *saddr,\n<13> char port[33];\n<25> memset(&ai,0, sizeof(ai));\n<27> ai.ai_flags = AI_PASSIVE;\n<31> ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n<35> ai.ai_family = inet_ai_family_from_address(saddr, &err);\n<37> ai.ai_socktype = SOCK_STREAM;\n<51> if (saddr->host == NULL) {\n<59> if (saddr->port != NULL) {\n<61> pstrcpy(port, sizeof(port), saddr->port);\n<65> port[0] = '\0';\n<73> if (port_offset) {\n<77> if (strlen(port) == 0) {\n<79> error_setg(errp, "port not specified");\n<81> return -1;\n<85> if (parse_uint_full(port, &baseport, 10) < 0) {\n<103> snprintf(port, sizeof(port), "%d", (int)baseport + port_offset);\n<107> rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n<109> strlen(port) ? port : NULL, &ai, &res);\n<111> if (rc != 0) {\n<113> error_setg(errp, "address resolution failed for %s:%s: %s",\n<125> for (e = res; e != NULL; e = e->ai_next) {\n<161> if (try_bind(slisten, saddr, e) >= 0) {\n<183> freeaddrinfo(res);\n<197> freeaddrinfo(res);\n<205> g_free(saddr->host);\n<221> freeaddrinfo(res);
<1> int avpriv_ac3_parse_header(GetBitContext *gbc, AC3HeaderInfo *hdr)\n<9> memset(hdr, 0, sizeof(*hdr));\n<15> if(hdr->sync_word != 0x0B77)\n<25> if(hdr->bitstream_id > 16)\n<43> if(hdr->bitstream_id <= 10) {\n<51> if(hdr->sr_code == 3)\n<75> if(hdr->channel_mode == AC3_CHMODE_STEREO) {\n<81> if((hdr->channel_mode & 1) && hdr->channel_mode != AC3_CHMODE_MONO)\n<85> if(hdr->channel_mode & 4)\n<95> hdr->sr_shift = FFMAX(hdr->bitstream_id, 8) - 8;\n<97> hdr->sample_rate = ff_ac3_sample_rate_tab[hdr->sr_code] >> hdr->sr_shift;\n<99> hdr->bit_rate = (ff_ac3_bitrate_tab[frame_size_code>>1] * 1000) >> hdr->sr_shift;\n<101> hdr->channels = ff_ac3_channels_tab[hdr->channel_mode] + hdr->lfe_on;\n<117> if(hdr->frame_type == EAC3_FRAME_TYPE_RESERVED)\n<129> if(hdr->frame_size < AC3_HEADER_SIZE)\n<137> if (hdr->sr_code == 3) {\n<167> hdr->bit_rate = (uint32_t)(8.0 * hdr->frame_size * hdr->sample_rate /\n<169> (hdr->num_blocks * 256.0));\n<171> hdr->channels = ff_ac3_channels_tab[hdr->channel_mode] + hdr->lfe_on;\n<179> hdr->channel_layout |= AV_CH_LOW_FREQUENCY;
<1> static USBDevice *usb_msd_init(USBBus *bus, const char *filename)\n<33> p1 = strchr(filename, ':');\n<35> if (p1++) {\n<41> if (strstart(filename, "format=", &p2)) {\n<69> qemu_opt_set(opts, "file", filename);
<1> static void musicpal_init(ram_addr_t ram_size,\n<53> if (!env) {\n<55> fprintf(stderr, "Unable to find CPU definition\n");\n<143> if (flash_size != 8*1024*1024 && flash_size != 16*1024*1024 &&\n<147> fprintf(stderr, "Invalid flash image size\n");
<1> static void tcx_screen_dump(void *opaque, const char *filename, bool cswitch,\n<7> TCXState *s = opaque;\n<19> if (!f) {\n<21> error_setg(errp, "failed to open file '%s': %s", filename,\n<23> strerror(errno));\n<29> ret = fprintf(f, "P6\n%d %d\n%d\n", s->width, s->height, 255);\n<31> if (ret < 0) {\n<39> for(y = 0; y < s->height; y++) {\n<43> for(x = 0; x < s->width; x++) {\n<47> ret = fputc(s->r[v], f);\n<49> if (ret == EOF) {\n<57> if (ret == EOF) {\n<65> if (ret == EOF) {\n<83> fclose(f);\n<91> error_setg(errp, "failed to write to file '%s': %s", filename,\n<93> strerror(errno));
<1> static int mon_init_func(void *opaque, QemuOpts *opts, Error **errp)\n<17> if (mode == NULL) {\n<19> mode = "readline";\n<23> if (strcmp(mode, "readline") == 0) {\n<25> flags = MONITOR_USE_READLINE;\n<27> } else if (strcmp(mode, "control") == 0) {\n<29> flags = MONITOR_USE_CONTROL;\n<33> fprintf(stderr, "unknown monitor mode \"%s\"\n", mode);\n<35> exit(1);\n<55> chr = qemu_chr_find(chardev);\n<57> if (chr == NULL) {\n<59> fprintf(stderr, "chardev \"%s\" not found\n", chardev);
<1> static void sun4m_load_kernel(long vram_size, int ram_size, int boot_device,\n<39> ret = load_elf(buf, 0, NULL, NULL, NULL);\n<41> if (ret < 0) {\n<43> fprintf(stderr, "qemu: could not load prom '%s'\n",\n<57> kernel_size = load_elf(kernel_filename, -0xf0000000, NULL, NULL, NULL);\n<61> kernel_size = load_aout(kernel_filename, phys_ram_base + KERNEL_LOAD_ADDR);\n<65> kernel_size = load_image(kernel_filename, phys_ram_base + KERNEL_LOAD_ADDR);\n<67> if (kernel_size < 0) {\n<69> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<85> initrd_size = load_image(initrd_filename, phys_ram_base + INITRD_LOAD_ADDR);\n<87> if (initrd_size < 0) {\n<89> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",
<1> static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) {\n<3> if ( ! strcmp ( attr , "packetization-mode" ) ) {\n<4> av_log ( s , AV_LOG_DEBUG , "RTP Packetization Mode: %d\n" , atoi ( value ) ) ;\n<5> h264_data -> packetization_mode = atoi ( value ) ;\n<6> if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , "Interleaved RTP mode is not supported yet.\n" ) ;\n<8> else if ( ! strcmp ( attr , "profile-level-id" ) ) {\n<9> if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ;\n<11> else if ( ! strcmp ( attr , "sprop-parameter-sets" ) ) {\n<13> if ( value [ strlen ( value ) - 1 ] == ',' ) {\n<14> av_log ( s , AV_LOG_WARNING , "Missing PPS in sprop-parameter-sets, ignoring\n" ) ;\n<15> return 0 ;\n<17> par -> extradata_size = 0 ;\n<18> av_freep ( & par -> extradata ) ;\n<19> ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ;\n<20> av_log ( s , AV_LOG_DEBUG , "Extradata set to %p (size: %d)\n" , par -> extradata , par -> extradata_size ) ;\n<21> return ret ;\n<23> return 0 ;
<1> static void do_bit_allocation(AC3DecodeContext *ctx, int flags)\n<5> ac3_audio_block *ab = &ctx->audio_block;\n<33> if (!snroffst) {\n<35> memset(ab->cplbap, 0, sizeof (ab->cplbap));\n<37> for (i = 0; i < ctx->bsi.nfchans; i++)\n<39> memset(ab->bap[i], 0, sizeof (ab->bap[i]));\n<41> memset(ab->lfebap, 0, sizeof (ab->lfebap));
<1> static void eepro100_cu_command(EEPRO100State * s, uint8_t val)\n<9> switch (val) {\n<411> dump_statistics(s);\n<413> memset(&s->statistics, 0, sizeof(s->statistics));
<1> void av_fifo_write(AVFifoBuffer *f, const uint8_t *buf, int size)\n<5> while (size > 0) {\n<7> int len = FFMIN(f->end - f->wptr, size);\n<9> memcpy(f->wptr, buf, len);\n<11> f->wptr += len;\n<17> buf += len;\n<19> size -= len;
<1> static size_t v9fs_packunpack(void *addr, struct iovec *sg, int sg_count,\n<27> len = MIN(sg[i].iov_len - offset, size);\n<29> if (pack) {\n<31> memcpy(sg[i].iov_base + offset, addr, len);\n<35> memcpy(addr, sg[i].iov_base + offset, len);\n<39> size -= len;\n<41> copied += len;\n<43> addr += len;
<1> static OFCondition parseSCUSCPRole ( PRV_SCUSCPROLE * role , unsigned char * buf , unsigned long * length , unsigned long availData ) {\n<9> buf += 2 ;\n<12> if ( role -> length - 4 < UIDLength ) return makeLengthError ( "SCU-SCP role list UID" , role -> length , 0 , UIDLength ) ;\n<13> ( void ) memcpy ( role -> SOPClassUID , buf , UIDLength ) ;\n<15> buf += UIDLength ;
<1> eth_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n<15> switch (addr) {\n<27> D(printf ("%s %x\n", __func__, addr * 4));