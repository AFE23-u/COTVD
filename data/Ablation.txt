You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void mainstone_common_init(ram_addr_t ram_size, int vga_ram_size,\n<2> \n<3> const char *kernel_filename,\n<4> \n<5> const char *kernel_cmdline, const char *initrd_filename,\n<6> \n<7> const char *cpu_model, enum mainstone_model_e model, int arm_id)\n<8> \n<9> {\n<10> \n<11> uint32_t sector_len = 256 * 1024;\n<12> \n<13> target_phys_addr_t mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n<14> \n<15> struct pxa2xx_state_s *cpu;\n<16> \n<17> qemu_irq *mst_irq;\n<18> \n<19> int i, index;\n<20> \n<21> \n<22> \n<23> if (!cpu_model)\n<24> \n<25> cpu_model = "pxa270-c5";\n<26> \n<27> \n<28> \n<29> /* Setup CPU & memory */\n<30> \n<31> if (ram_size < MAINSTONE_RAM + MAINSTONE_ROM + 2 * MAINSTONE_FLASH +\n<32> \n<33> PXA2XX_INTERNAL_SIZE) {\n<34> \n<35> fprintf(stderr, "This platform requires %i bytes of memory\n",\n<36> \n<37> MAINSTONE_RAM + MAINSTONE_ROM + 2 * MAINSTONE_FLASH +\n<38> \n<39> PXA2XX_INTERNAL_SIZE);\n<40> \n<41> exit(1);\n<42> \n<43> }\n<44> \n<45> \n<46> \n<47> cpu = pxa270_init(mainstone_binfo.ram_size, cpu_model);\n<48> \n<49> cpu_register_physical_memory(0, MAINSTONE_ROM,\n<50> \n<51> qemu_ram_alloc(MAINSTONE_ROM) | IO_MEM_ROM);\n<52> \n<53> \n<54> \n<55> /* Setup initial (reset) machine state */\n<56> \n<57> cpu->env->regs[15] = mainstone_binfo.loader_start;\n<58> \n<59> \n<60> \n<61> /* There are two 32MiB flash devices on the board */\n<62> \n<63> for (i = 0; i < 2; i ++) {\n<64> \n<65> index = drive_get_index(IF_PFLASH, 0, i);\n<66> \n<67> if (index == -1) {\n<68> \n<69> fprintf(stderr, "Two flash images must be given with the "\n<70> \n<71> "'pflash' parameter\n");\n<72> \n<73> exit(1);\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> if (!pflash_cfi01_register(mainstone_flash_base[i],\n<80> \n<81> qemu_ram_alloc(MAINSTONE_FLASH),\n<82> \n<83> drives_table[index].bdrv, sector_len,\n<84> \n<85> MAINSTONE_FLASH / sector_len, 4, 0, 0, 0, 0)) {\n<86> \n<87> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<88> \n<89> exit(1);\n<90> \n<91> }\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> mst_irq = mst_irq_init(cpu, MST_FPGA_PHYS, PXA2XX_PIC_GPIO_0);\n<98> \n<99> \n<100> \n<101> /* setup keypad */\n<102> \n<103> printf("map addr %p\n", &map);\n<104> \n<105> pxa27x_register_keypad(cpu->kp, map, 0xe0);\n<106> \n<107> \n<108> \n<109> /* MMC/SD host */\n<110> \n<111> pxa2xx_mmci_handlers(cpu->mmc, NULL, mst_irq[MMC_IRQ]);\n<112> \n<113> \n<114> \n<115> smc91c111_init(&nd_table[0], MST_ETH_PHYS, mst_irq[ETHERNET_IRQ]);\n<116> \n<117> \n<118> \n<119> mainstone_binfo.kernel_filename = kernel_filename;\n<120> \n<121> mainstone_binfo.kernel_cmdline = kernel_cmdline;\n<122> \n<123> mainstone_binfo.initrd_filename = initrd_filename;\n<124> \n<125> mainstone_binfo.board_id = arm_id;\n<126> \n<127> arm_load_kernel(cpu->env, &mainstone_binfo);\n<128> \n<129> }\n<130> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int opt_input_file(const char *opt, const char *filename)\n<2> \n<3> {\n<4> \n<5> AVFormatContext *ic;\n<6> \n<7> AVInputFormat *file_iformat = NULL;\n<8> \n<9> int err, i, ret, rfps, rfps_base;\n<10> \n<11> int64_t timestamp;\n<12> \n<13> uint8_t buf[128];\n<14> \n<15> AVDictionary **opts;\n<16> \n<17> int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n<18> \n<19> \n<20> \n<21> if (last_asked_format) {\n<22> \n<23> if (!(file_iformat = av_find_input_format(last_asked_format))) {\n<24> \n<25> fprintf(stderr, "Unknown input format: '%s'\n", last_asked_format);\n<26> \n<27> ffmpeg_exit(1);\n<28> \n<29> }\n<30> \n<31> last_asked_format = NULL;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> if (!strcmp(filename, "-"))\n<38> \n<39> filename = "pipe:";\n<40> \n<41> \n<42> \n<43> using_stdin |= !strncmp(filename, "pipe:", 5) ||\n<44> \n<45> !strcmp(filename, "/dev/stdin");\n<46> \n<47> \n<48> \n<49> /* get default parameters from command line */\n<50> \n<51> ic = avformat_alloc_context();\n<52> \n<53> if (!ic) {\n<54> \n<55> print_error(filename, AVERROR(ENOMEM));\n<56> \n<57> ffmpeg_exit(1);\n<58> \n<59> }\n<60> \n<61> if (audio_sample_rate) {\n<62> \n<63> snprintf(buf, sizeof(buf), "%d", audio_sample_rate);\n<64> \n<65> av_dict_set(&format_opts, "sample_rate", buf, 0);\n<66> \n<67> }\n<68> \n<69> if (audio_channels) {\n<70> \n<71> snprintf(buf, sizeof(buf), "%d", audio_channels);\n<72> \n<73> av_dict_set(&format_opts, "channels", buf, 0);\n<74> \n<75> }\n<76> \n<77> if (frame_rate.num) {\n<78> \n<79> snprintf(buf, sizeof(buf), "%d/%d", frame_rate.num, frame_rate.den);\n<80> \n<81> av_dict_set(&format_opts, "framerate", buf, 0);\n<82> \n<83> }\n<84> \n<85> if (frame_width && frame_height) {\n<86> \n<87> snprintf(buf, sizeof(buf), "%dx%d", frame_width, frame_height);\n<88> \n<89> av_dict_set(&format_opts, "video_size", buf, 0);\n<90> \n<91> }\n<92> \n<93> if (frame_pix_fmt != PIX_FMT_NONE)\n<94> \n<95> av_dict_set(&format_opts, "pixel_format", av_get_pix_fmt_name(frame_pix_fmt), 0);\n<96> \n<97> \n<98> \n<99> ic->video_codec_id   =\n<100> \n<101> find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);\n<102> \n<103> ic->audio_codec_id   =\n<104> \n<105> find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);\n<106> \n<107> ic->subtitle_codec_id=\n<108> \n<109> find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);\n<110> \n<111> ic->flags |= AVFMT_FLAG_NONBLOCK;\n<112> \n<113> \n<114> \n<115> /* open the input file with generic libav function */\n<116> \n<117> err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n<118> \n<119> if (err < 0) {\n<120> \n<121> print_error(filename, err);\n<122> \n<123> ffmpeg_exit(1);\n<124> \n<125> }\n<126> \n<127> assert_avoptions(format_opts);\n<128> \n<129> \n<130> \n<131> if(opt_programid) {\n<132> \n<133> int i, j;\n<134> \n<135> int found=0;\n<136> \n<137> for(i=0; i<ic->nb_streams; i++){\n<138> \n<139> ic->streams[i]->discard= AVDISCARD_ALL;\n<140> \n<141> }\n<142> \n<143> for(i=0; i<ic->nb_programs; i++){\n<144> \n<145> AVProgram *p= ic->programs[i];\n<146> \n<147> if(p->id != opt_programid){\n<148> \n<149> p->discard = AVDISCARD_ALL;\n<150> \n<151> }else{\n<152> \n<153> found=1;\n<154> \n<155> for(j=0; j<p->nb_stream_indexes; j++){\n<156> \n<157> ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;\n<158> \n<159> }\n<160> \n<161> }\n<162> \n<163> }\n<164> \n<165> if(!found){\n<166> \n<167> fprintf(stderr, "Specified program id not found\n");\n<168> \n<169> ffmpeg_exit(1);\n<170> \n<171> }\n<172> \n<173> opt_programid=0;\n<174> \n<175> }\n<176> \n<177> \n<178> \n<179> if (loop_input) {\n<180> \n<181> av_log(NULL, AV_LOG_WARNING, "-loop_input is deprecated, use -loop 1\n");\n<182> \n<183> ic->loop_input = loop_input;\n<184> \n<185> }\n<186> \n<187> \n<188> \n<189> /* Set AVCodecContext options for avformat_find_stream_info */\n<190> \n<191> opts = setup_find_stream_info_opts(ic, codec_opts);\n<192> \n<193> orig_nb_streams = ic->nb_streams;\n<194> \n<195> \n<196> \n<197> /* If not enough info to get the stream parameters, we decode the\n<198> \n<199> first frames to get it. (used in mpeg case for example) */\n<200> \n<201> ret = avformat_find_stream_info(ic, opts);\n<202> \n<203> if (ret < 0 && verbose >= 0) {\n<204> \n<205> fprintf(stderr, "%s: could not find codec parameters\n", filename);\n<206> \n<207> av_close_input_file(ic);\n<208> \n<209> ffmpeg_exit(1);\n<210> \n<211> }\n<212> \n<213> \n<214> \n<215> timestamp = start_time;\n<216> \n<217> /* add the stream start time */\n<218> \n<219> if (ic->start_time != AV_NOPTS_VALUE)\n<220> \n<221> timestamp += ic->start_time;\n<222> \n<223> \n<224> \n<225> /* if seeking requested, we execute it */\n<226> \n<227> if (start_time != 0) {\n<228> \n<229> ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n<230> \n<231> if (ret < 0) {\n<232> \n<233> fprintf(stderr, "%s: could not seek to position %0.3f\n",\n<234> \n<235> filename, (double)timestamp / AV_TIME_BASE);\n<236> \n<237> }\n<238> \n<239> /* reset seek info */\n<240> \n<241> start_time = 0;\n<242> \n<243> }\n<244> \n<245> \n<246> \n<247> /* update the current parameters so that they match the one of the input stream */\n<248> \n<249> for(i=0;i<ic->nb_streams;i++) {\n<250> \n<251> AVStream *st = ic->streams[i];\n<252> \n<253> AVCodecContext *dec = st->codec;\n<254> \n<255> InputStream *ist;\n<256> \n<257> \n<258> \n<259> dec->thread_count = thread_count;\n<260> \n<261> \n<262> \n<263> input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);\n<264> \n<265> ist = &input_streams[nb_input_streams - 1];\n<266> \n<267> ist->st = st;\n<268> \n<269> ist->file_index = nb_input_files;\n<270> \n<271> ist->discard = 1;\n<272> \n<273> ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);\n<274> \n<275> \n<276> \n<277> if (i < nb_ts_scale)\n<278> \n<279> ist->ts_scale = ts_scale[i];\n<280> \n<281> \n<282> \n<283> switch (dec->codec_type) {\n<284> \n<285> case AVMEDIA_TYPE_AUDIO:\n<286> \n<287> ist->dec = avcodec_find_decoder_by_name(audio_codec_name);\n<288> \n<289> if(!ist->dec)\n<290> \n<291> ist->dec = avcodec_find_decoder(dec->codec_id);\n<292> \n<293> if(audio_disable)\n<294> \n<295> st->discard= AVDISCARD_ALL;\n<296> \n<297> break;\n<298> \n<299> case AVMEDIA_TYPE_VIDEO:\n<300> \n<301> ist->dec= avcodec_find_decoder_by_name(video_codec_name);\n<302> \n<303> if(!ist->dec)\n<304> \n<305> ist->dec = avcodec_find_decoder(dec->codec_id);\n<306> \n<307> rfps      = ic->streams[i]->r_frame_rate.num;\n<308> \n<309> rfps_base = ic->streams[i]->r_frame_rate.den;\n<310> \n<311> if (dec->lowres) {\n<312> \n<313> dec->flags |= CODEC_FLAG_EMU_EDGE;\n<314> \n<315> }\n<316> \n<317> if(me_threshold)\n<318> \n<319> dec->debug |= FF_DEBUG_MV;\n<320> \n<321> \n<322> \n<323> if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n<324> \n<325> \n<326> \n<327> if (verbose >= 0)\n<328> \n<329> fprintf(stderr,"\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n",\n<330> \n<331> i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n<332> \n<333> \n<334> \n<335> (float)rfps / rfps_base, rfps, rfps_base);\n<336> \n<337> }\n<338> \n<339> \n<340> \n<341> if(video_disable)\n<342> \n<343> st->discard= AVDISCARD_ALL;\n<344> \n<345> else if(video_discard)\n<346> \n<347> st->discard= video_discard;\n<348> \n<349> break;\n<350> \n<351> case AVMEDIA_TYPE_DATA:\n<352> \n<353> break;\n<354> \n<355> case AVMEDIA_TYPE_SUBTITLE:\n<356> \n<357> ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);\n<358> \n<359> if(!ist->dec)\n<360> \n<361> ist->dec = avcodec_find_decoder(dec->codec_id);\n<362> \n<363> if(subtitle_disable)\n<364> \n<365> st->discard = AVDISCARD_ALL;\n<366> \n<367> break;\n<368> \n<369> case AVMEDIA_TYPE_ATTACHMENT:\n<370> \n<371> case AVMEDIA_TYPE_UNKNOWN:\n<372> \n<373> break;\n<374> \n<375> default:\n<376> \n<377> abort();\n<378> \n<379> }\n<380> \n<381> }\n<382> \n<383> \n<384> \n<385> /* dump the file content */\n<386> \n<387> if (verbose >= 0)\n<388> \n<389> av_dump_format(ic, nb_input_files, filename, 0);\n<390> \n<391> \n<392> \n<393> input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n<394> \n<395> input_files[nb_input_files - 1].ctx        = ic;\n<396> \n<397> input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n<398> \n<399> input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);\n<400> \n<401> \n<402> \n<403> top_field_first = -1;\n<404> \n<405> frame_rate    = (AVRational){0, 0};\n<406> \n<407> frame_pix_fmt = PIX_FMT_NONE;\n<408> \n<409> frame_height = 0;\n<410> \n<411> frame_width  = 0;\n<412> \n<413> audio_sample_rate = 0;\n<414> \n<415> audio_channels    = 0;\n<416> \n<417> audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n<418> \n<419> av_freep(&ts_scale);\n<420> \n<421> nb_ts_scale = 0;\n<422> \n<423> \n<424> \n<425> for (i = 0; i < orig_nb_streams; i++)\n<426> \n<427> av_dict_free(&opts[i]);\n<428> \n<429> av_freep(&opts);\n<430> \n<431> av_freep(&video_codec_name);\n<432> \n<433> av_freep(&audio_codec_name);\n<434> \n<435> av_freep(&subtitle_codec_name);\n<436> \n<437> uninit_opts();\n<438> \n<439> init_opts();\n<440> \n<441> return 0;\n<442> \n<443> }\n<444> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mpeg_decode_mb(MpegEncContext *s, DCTELEM block[12][64])\n<2> \n<3> {\n<4> \n<5> int i, j, k, cbp, val, mb_type, motion_type;\n<6> \n<7> const int mb_block_count = 4 + (1 << s->chroma_format);\n<8> \n<9> \n<10> \n<11> av_dlog(s->avctx, "decode_mb: x=%d y=%d\n", s->mb_x, s->mb_y);\n<12> \n<13> \n<14> \n<15> assert(s->mb_skipped == 0);\n<16> \n<17> \n<18> \n<19> if (s->mb_skip_run-- != 0) {\n<20> \n<21> if (s->pict_type == AV_PICTURE_TYPE_P) {\n<22> \n<23> s->mb_skipped = 1;\n<24> \n<25> s->current_picture.f.mb_type[s->mb_x + s->mb_y * s->mb_stride] = MB_TYPE_SKIP | MB_TYPE_L0 | MB_TYPE_16x16;\n<26> \n<27> } else {\n<28> \n<29> int mb_type;\n<30> \n<31> \n<32> \n<33> if (s->mb_x)\n<34> \n<35> mb_type = s->current_picture.f.mb_type[s->mb_x + s->mb_y * s->mb_stride - 1];\n<36> \n<37> else\n<38> \n<39> mb_type = s->current_picture.f.mb_type[s->mb_width + (s->mb_y - 1) * s->mb_stride - 1]; // FIXME not sure if this is allowed in MPEG at all\n<40> \n<41> if (IS_INTRA(mb_type))\n<42> \n<43> return -1;\n<44> \n<45> s->current_picture.f.mb_type[s->mb_x + s->mb_y*s->mb_stride] =\n<46> \n<47> mb_type | MB_TYPE_SKIP;\n<48> \n<49> //            assert(s->current_picture.f.mb_type[s->mb_x + s->mb_y * s->mb_stride - 1] & (MB_TYPE_16x16 | MB_TYPE_16x8));\n<50> \n<51> \n<52> \n<53> if ((s->mv[0][0][0] | s->mv[0][0][1] | s->mv[1][0][0] | s->mv[1][0][1]) == 0)\n<54> \n<55> s->mb_skipped = 1;\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> return 0;\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> switch (s->pict_type) {\n<68> \n<69> default:\n<70> \n<71> case AV_PICTURE_TYPE_I:\n<72> \n<73> if (get_bits1(&s->gb) == 0) {\n<74> \n<75> if (get_bits1(&s->gb) == 0) {\n<76> \n<77> av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in I Frame at %d %d\n", s->mb_x, s->mb_y);\n<78> \n<79> return -1;\n<80> \n<81> }\n<82> \n<83> mb_type = MB_TYPE_QUANT | MB_TYPE_INTRA;\n<84> \n<85> } else {\n<86> \n<87> mb_type = MB_TYPE_INTRA;\n<88> \n<89> }\n<90> \n<91> break;\n<92> \n<93> case AV_PICTURE_TYPE_P:\n<94> \n<95> mb_type = get_vlc2(&s->gb, mb_ptype_vlc.table, MB_PTYPE_VLC_BITS, 1);\n<96> \n<97> if (mb_type < 0) {\n<98> \n<99> av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in P Frame at %d %d\n", s->mb_x, s->mb_y);\n<100> \n<101> return -1;\n<102> \n<103> }\n<104> \n<105> mb_type = ptype2mb_type[mb_type];\n<106> \n<107> break;\n<108> \n<109> case AV_PICTURE_TYPE_B:\n<110> \n<111> mb_type = get_vlc2(&s->gb, mb_btype_vlc.table, MB_BTYPE_VLC_BITS, 1);\n<112> \n<113> if (mb_type < 0) {\n<114> \n<115> av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in B Frame at %d %d\n", s->mb_x, s->mb_y);\n<116> \n<117> return -1;\n<118> \n<119> }\n<120> \n<121> mb_type = btype2mb_type[mb_type];\n<122> \n<123> break;\n<124> \n<125> }\n<126> \n<127> av_dlog(s->avctx, "mb_type=%x\n", mb_type);\n<128> \n<129> //    motion_type = 0; /* avoid warning */\n<130> \n<131> if (IS_INTRA(mb_type)) {\n<132> \n<133> s->dsp.clear_blocks(s->block[0]);\n<134> \n<135> \n<136> \n<137> if (!s->chroma_y_shift) {\n<138> \n<139> s->dsp.clear_blocks(s->block[6]);\n<140> \n<141> }\n<142> \n<143> \n<144> \n<145> /* compute DCT type */\n<146> \n<147> if (s->picture_structure == PICT_FRAME && // FIXME add an interlaced_dct coded var?\n<148> \n<149> !s->frame_pred_frame_dct) {\n<150> \n<151> s->interlaced_dct = get_bits1(&s->gb);\n<152> \n<153> }\n<154> \n<155> \n<156> \n<157> if (IS_QUANT(mb_type))\n<158> \n<159> s->qscale = get_qscale(s);\n<160> \n<161> \n<162> \n<163> if (s->concealment_motion_vectors) {\n<164> \n<165> /* just parse them */\n<166> \n<167> if (s->picture_structure != PICT_FRAME)\n<168> \n<169> skip_bits1(&s->gb); /* field select */\n<170> \n<171> \n<172> \n<173> s->mv[0][0][0]= s->last_mv[0][0][0]= s->last_mv[0][1][0] =\n<174> \n<175> mpeg_decode_motion(s, s->mpeg_f_code[0][0], s->last_mv[0][0][0]);\n<176> \n<177> s->mv[0][0][1]= s->last_mv[0][0][1]= s->last_mv[0][1][1] =\n<178> \n<179> mpeg_decode_motion(s, s->mpeg_f_code[0][1], s->last_mv[0][0][1]);\n<180> \n<181> \n<182> \n<183> skip_bits1(&s->gb); /* marker */\n<184> \n<185> } else\n<186> \n<187> memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */\n<188> \n<189> s->mb_intra = 1;\n<190> \n<191> // if 1, we memcpy blocks in xvmcvideo\n<192> \n<193> if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration > 1) {\n<194> \n<195> ff_xvmc_pack_pblocks(s, -1); // inter are always full blocks\n<196> \n<197> if (s->swap_uv) {\n<198> \n<199> exchange_uv(s);\n<200> \n<201> }\n<202> \n<203> }\n<204> \n<205> \n<206> \n<207> if (s->codec_id == CODEC_ID_MPEG2VIDEO) {\n<208> \n<209> if (s->flags2 & CODEC_FLAG2_FAST) {\n<210> \n<211> for (i = 0; i < 6; i++) {\n<212> \n<213> mpeg2_fast_decode_block_intra(s, *s->pblocks[i], i);\n<214> \n<215> }\n<216> \n<217> } else {\n<218> \n<219> for (i = 0; i < mb_block_count; i++) {\n<220> \n<221> if (mpeg2_decode_block_intra(s, *s->pblocks[i], i) < 0)\n<222> \n<223> return -1;\n<224> \n<225> }\n<226> \n<227> }\n<228> \n<229> } else {\n<230> \n<231> for (i = 0; i < 6; i++) {\n<232> \n<233> if (mpeg1_decode_block_intra(s, *s->pblocks[i], i) < 0)\n<234> \n<235> return -1;\n<236> \n<237> }\n<238> \n<239> }\n<240> \n<241> } else {\n<242> \n<243> if (mb_type & MB_TYPE_ZERO_MV) {\n<244> \n<245> assert(mb_type & MB_TYPE_CBP);\n<246> \n<247> \n<248> \n<249> s->mv_dir = MV_DIR_FORWARD;\n<250> \n<251> if (s->picture_structure == PICT_FRAME) {\n<252> \n<253> if (!s->frame_pred_frame_dct)\n<254> \n<255> s->interlaced_dct = get_bits1(&s->gb);\n<256> \n<257> s->mv_type = MV_TYPE_16X16;\n<258> \n<259> } else {\n<260> \n<261> s->mv_type = MV_TYPE_FIELD;\n<262> \n<263> mb_type |= MB_TYPE_INTERLACED;\n<264> \n<265> s->field_select[0][0] = s->picture_structure - 1;\n<266> \n<267> }\n<268> \n<269> \n<270> \n<271> if (IS_QUANT(mb_type))\n<272> \n<273> s->qscale = get_qscale(s);\n<274> \n<275> \n<276> \n<277> s->last_mv[0][0][0] = 0;\n<278> \n<279> s->last_mv[0][0][1] = 0;\n<280> \n<281> s->last_mv[0][1][0] = 0;\n<282> \n<283> s->last_mv[0][1][1] = 0;\n<284> \n<285> s->mv[0][0][0] = 0;\n<286> \n<287> s->mv[0][0][1] = 0;\n<288> \n<289> } else {\n<290> \n<291> assert(mb_type & MB_TYPE_L0L1);\n<292> \n<293> // FIXME decide if MBs in field pictures are MB_TYPE_INTERLACED\n<294> \n<295> /* get additional motion vector type */\n<296> \n<297> if (s->frame_pred_frame_dct)\n<298> \n<299> motion_type = MT_FRAME;\n<300> \n<301> else {\n<302> \n<303> motion_type = get_bits(&s->gb, 2);\n<304> \n<305> if (s->picture_structure == PICT_FRAME && HAS_CBP(mb_type))\n<306> \n<307> s->interlaced_dct = get_bits1(&s->gb);\n<308> \n<309> }\n<310> \n<311> \n<312> \n<313> if (IS_QUANT(mb_type))\n<314> \n<315> s->qscale = get_qscale(s);\n<316> \n<317> \n<318> \n<319> /* motion vectors */\n<320> \n<321> s->mv_dir = (mb_type >> 13) & 3;\n<322> \n<323> av_dlog(s->avctx, "motion_type=%d\n", motion_type);\n<324> \n<325> switch (motion_type) {\n<326> \n<327> case MT_FRAME: /* or MT_16X8 */\n<328> \n<329> if (s->picture_structure == PICT_FRAME) {\n<330> \n<331> mb_type |= MB_TYPE_16x16;\n<332> \n<333> s->mv_type = MV_TYPE_16X16;\n<334> \n<335> for (i = 0; i < 2; i++) {\n<336> \n<337> if (USES_LIST(mb_type, i)) {\n<338> \n<339> /* MT_FRAME */\n<340> \n<341> s->mv[i][0][0]= s->last_mv[i][0][0]= s->last_mv[i][1][0] =\n<342> \n<343> mpeg_decode_motion(s, s->mpeg_f_code[i][0], s->last_mv[i][0][0]);\n<344> \n<345> s->mv[i][0][1]= s->last_mv[i][0][1]= s->last_mv[i][1][1] =\n<346> \n<347> mpeg_decode_motion(s, s->mpeg_f_code[i][1], s->last_mv[i][0][1]);\n<348> \n<349> /* full_pel: only for MPEG-1 */\n<350> \n<351> if (s->full_pel[i]) {\n<352> \n<353> s->mv[i][0][0] <<= 1;\n<354> \n<355> s->mv[i][0][1] <<= 1;\n<356> \n<357> }\n<358> \n<359> }\n<360> \n<361> }\n<362> \n<363> } else {\n<364> \n<365> mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;\n<366> \n<367> s->mv_type = MV_TYPE_16X8;\n<368> \n<369> for (i = 0; i < 2; i++) {\n<370> \n<371> if (USES_LIST(mb_type, i)) {\n<372> \n<373> /* MT_16X8 */\n<374> \n<375> for (j = 0; j < 2; j++) {\n<376> \n<377> s->field_select[i][j] = get_bits1(&s->gb);\n<378> \n<379> for (k = 0; k < 2; k++) {\n<380> \n<381> val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],\n<382> \n<383> s->last_mv[i][j][k]);\n<384> \n<385> s->last_mv[i][j][k] = val;\n<386> \n<387> s->mv[i][j][k]      = val;\n<388> \n<389> }\n<390> \n<391> }\n<392> \n<393> }\n<394> \n<395> }\n<396> \n<397> }\n<398> \n<399> break;\n<400> \n<401> case MT_FIELD:\n<402> \n<403> if(s->progressive_sequence){\n<404> \n<405> av_log(s->avctx, AV_LOG_ERROR, "MT_FIELD in progressive_sequence\n");\n<406> \n<407> return -1;\n<408> \n<409> }\n<410> \n<411> s->mv_type = MV_TYPE_FIELD;\n<412> \n<413> if (s->picture_structure == PICT_FRAME) {\n<414> \n<415> mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;\n<416> \n<417> for (i = 0; i < 2; i++) {\n<418> \n<419> if (USES_LIST(mb_type, i)) {\n<420> \n<421> for (j = 0; j < 2; j++) {\n<422> \n<423> s->field_select[i][j] = get_bits1(&s->gb);\n<424> \n<425> val = mpeg_decode_motion(s, s->mpeg_f_code[i][0],\n<426> \n<427> s->last_mv[i][j][0]);\n<428> \n<429> s->last_mv[i][j][0] = val;\n<430> \n<431> s->mv[i][j][0]      = val;\n<432> \n<433> av_dlog(s->avctx, "fmx=%d\n", val);\n<434> \n<435> val = mpeg_decode_motion(s, s->mpeg_f_code[i][1],\n<436> \n<437> s->last_mv[i][j][1] >> 1);\n<438> \n<439> s->last_mv[i][j][1] = val << 1;\n<440> \n<441> s->mv[i][j][1]      = val;\n<442> \n<443> av_dlog(s->avctx, "fmy=%d\n", val);\n<444> \n<445> }\n<446> \n<447> }\n<448> \n<449> }\n<450> \n<451> } else {\n<452> \n<453> av_assert0(!s->progressive_sequence);\n<454> \n<455> mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED;\n<456> \n<457> for (i = 0; i < 2; i++) {\n<458> \n<459> if (USES_LIST(mb_type, i)) {\n<460> \n<461> s->field_select[i][0] = get_bits1(&s->gb);\n<462> \n<463> for (k = 0; k < 2; k++) {\n<464> \n<465> val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],\n<466> \n<467> s->last_mv[i][0][k]);\n<468> \n<469> s->last_mv[i][0][k] = val;\n<470> \n<471> s->last_mv[i][1][k] = val;\n<472> \n<473> s->mv[i][0][k]      = val;\n<474> \n<475> }\n<476> \n<477> }\n<478> \n<479> }\n<480> \n<481> }\n<482> \n<483> break;\n<484> \n<485> case MT_DMV:\n<486> \n<487> if(s->progressive_sequence){\n<488> \n<489> av_log(s->avctx, AV_LOG_ERROR, "MT_DMV in progressive_sequence\n");\n<490> \n<491> return -1;\n<492> \n<493> }\n<494> \n<495> s->mv_type = MV_TYPE_DMV;\n<496> \n<497> for (i = 0; i < 2; i++) {\n<498> \n<499> if (USES_LIST(mb_type, i)) {\n<500> \n<501> int dmx, dmy, mx, my, m;\n<502> \n<503> const int my_shift = s->picture_structure == PICT_FRAME;\n<504> \n<505> \n<506> \n<507> mx = mpeg_decode_motion(s, s->mpeg_f_code[i][0],\n<508> \n<509> s->last_mv[i][0][0]);\n<510> \n<511> s->last_mv[i][0][0] = mx;\n<512> \n<513> s->last_mv[i][1][0] = mx;\n<514> \n<515> dmx = get_dmv(s);\n<516> \n<517> my  = mpeg_decode_motion(s, s->mpeg_f_code[i][1],\n<518> \n<519> s->last_mv[i][0][1] >> my_shift);\n<520> \n<521> dmy = get_dmv(s);\n<522> \n<523> \n<524> \n<525> \n<526> \n<527> s->last_mv[i][0][1] = my << my_shift;\n<528> \n<529> s->last_mv[i][1][1] = my << my_shift;\n<530> \n<531> \n<532> \n<533> s->mv[i][0][0] = mx;\n<534> \n<535> s->mv[i][0][1] = my;\n<536> \n<537> s->mv[i][1][0] = mx; // not used\n<538> \n<539> s->mv[i][1][1] = my; // not used\n<540> \n<541> \n<542> \n<543> if (s->picture_structure == PICT_FRAME) {\n<544> \n<545> mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED;\n<546> \n<547> \n<548> \n<549> // m = 1 + 2 * s->top_field_first;\n<550> \n<551> m = s->top_field_first ? 1 : 3;\n<552> \n<553> \n<554> \n<555> /* top -> top pred */\n<556> \n<557> s->mv[i][2][0] = ((mx * m + (mx > 0)) >> 1) + dmx;\n<558> \n<559> s->mv[i][2][1] = ((my * m + (my > 0)) >> 1) + dmy - 1;\n<560> \n<561> m = 4 - m;\n<562> \n<563> s->mv[i][3][0] = ((mx * m + (mx > 0)) >> 1) + dmx;\n<564> \n<565> s->mv[i][3][1] = ((my * m + (my > 0)) >> 1) + dmy + 1;\n<566> \n<567> } else {\n<568> \n<569> mb_type |= MB_TYPE_16x16;\n<570> \n<571> \n<572> \n<573> s->mv[i][2][0] = ((mx + (mx > 0)) >> 1) + dmx;\n<574> \n<575> s->mv[i][2][1] = ((my + (my > 0)) >> 1) + dmy;\n<576> \n<577> if (s->picture_structure == PICT_TOP_FIELD)\n<578> \n<579> s->mv[i][2][1]--;\n<580> \n<581> else\n<582> \n<583> s->mv[i][2][1]++;\n<584> \n<585> }\n<586> \n<587> }\n<588> \n<589> }\n<590> \n<591> break;\n<592> \n<593> default:\n<594> \n<595> av_log(s->avctx, AV_LOG_ERROR, "00 motion_type at %d %d\n", s->mb_x, s->mb_y);\n<596> \n<597> return -1;\n<598> \n<599> }\n<600> \n<601> }\n<602> \n<603> \n<604> \n<605> s->mb_intra = 0;\n<606> \n<607> if (HAS_CBP(mb_type)) {\n<608> \n<609> s->dsp.clear_blocks(s->block[0]);\n<610> \n<611> \n<612> \n<613> cbp = get_vlc2(&s->gb, mb_pat_vlc.table, MB_PAT_VLC_BITS, 1);\n<614> \n<615> if (mb_block_count > 6) {\n<616> \n<617> cbp <<= mb_block_count - 6;\n<618> \n<619> cbp  |= get_bits(&s->gb, mb_block_count - 6);\n<620> \n<621> s->dsp.clear_blocks(s->block[6]);\n<622> \n<623> }\n<624> \n<625> if (cbp <= 0) {\n<626> \n<627> av_log(s->avctx, AV_LOG_ERROR, "invalid cbp at %d %d\n", s->mb_x, s->mb_y);\n<628> \n<629> return -1;\n<630> \n<631> }\n<632> \n<633> \n<634> \n<635> //if 1, we memcpy blocks in xvmcvideo\n<636> \n<637> if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration > 1) {\n<638> \n<639> ff_xvmc_pack_pblocks(s, cbp);\n<640> \n<641> if (s->swap_uv) {\n<642> \n<643> exchange_uv(s);\n<644> \n<645> }\n<646> \n<647> }\n<648> \n<649> \n<650> \n<651> if (s->codec_id == CODEC_ID_MPEG2VIDEO) {\n<652> \n<653> if (s->flags2 & CODEC_FLAG2_FAST) {\n<654> \n<655> for (i = 0; i < 6; i++) {\n<656> \n<657> if (cbp & 32) {\n<658> \n<659> mpeg2_fast_decode_block_non_intra(s, *s->pblocks[i], i);\n<660> \n<661> } else {\n<662> \n<663> s->block_last_index[i] = -1;\n<664> \n<665> }\n<666> \n<667> cbp += cbp;\n<668> \n<669> }\n<670> \n<671> } else {\n<672> \n<673> cbp <<= 12-mb_block_count;\n<674> \n<675> \n<676> \n<677> for (i = 0; i < mb_block_count; i++) {\n<678> \n<679> if (cbp & (1 << 11)) {\n<680> \n<681> if (mpeg2_decode_block_non_intra(s, *s->pblocks[i], i) < 0)\n<682> \n<683> return -1;\n<684> \n<685> } else {\n<686> \n<687> s->block_last_index[i] = -1;\n<688> \n<689> }\n<690> \n<691> cbp += cbp;\n<692> \n<693> }\n<694> \n<695> }\n<696> \n<697> } else {\n<698> \n<699> if (s->flags2 & CODEC_FLAG2_FAST) {\n<700> \n<701> for (i = 0; i < 6; i++) {\n<702> \n<703> if (cbp & 32) {\n<704> \n<705> mpeg1_fast_decode_block_inter(s, *s->pblocks[i], i);\n<706> \n<707> } else {\n<708> \n<709> s->block_last_index[i] = -1;\n<710> \n<711> }\n<712> \n<713> cbp += cbp;\n<714> \n<715> }\n<716> \n<717> } else {\n<718> \n<719> for (i = 0; i < 6; i++) {\n<720> \n<721> if (cbp & 32) {\n<722> \n<723> if (mpeg1_decode_block_inter(s, *s->pblocks[i], i) < 0)\n<724> \n<725> return -1;\n<726> \n<727> } else {\n<728> \n<729> s->block_last_index[i] = -1;\n<730> \n<731> }\n<732> \n<733> cbp += cbp;\n<734> \n<735> }\n<736> \n<737> }\n<738> \n<739> }\n<740> \n<741> } else {\n<742> \n<743> for (i = 0; i < 12; i++)\n<744> \n<745> s->block_last_index[i] = -1;\n<746> \n<747> }\n<748> \n<749> }\n<750> \n<751> \n<752> \n<753> s->current_picture.f.mb_type[s->mb_x + s->mb_y * s->mb_stride] = mb_type;\n<754> \n<755> \n<756> \n<757> return 0;\n<758> \n<759> }\n<760> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void xmlInitializeGlobalState ( xmlGlobalStatePtr gs ) {\n<2> # ifdef DEBUG_GLOBALS fprintf ( stderr , "Initializing globals at %lu for thread %d\n" , ( unsigned long ) gs , xmlGetThreadId ( ) ) ;\n<3> # endif if ( xmlThrDefMutex == NULL ) xmlInitGlobals ( ) ;\n<4> xmlMutexLock ( xmlThrDefMutex ) ;\n<5> # if defined ( LIBXML_DOCB_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) && defined ( LIBXML_SAX1_ENABLED ) initdocbDefaultSAXHandler ( & gs -> docbDefaultSAXHandler ) ;\n<6> # endif # if defined ( LIBXML_HTML_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) inithtmlDefaultSAXHandler ( & gs -> htmlDefaultSAXHandler ) ;\n<7> # endif gs -> oldXMLWDcompatibility = 0 ;\n<8> gs -> xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef ;\n<9> gs -> xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef ;\n<10> # if defined ( LIBXML_SAX1_ENABLED ) && defined ( LIBXML_LEGACY_ENABLED ) initxmlDefaultSAXHandler ( & gs -> xmlDefaultSAXHandler , 1 ) ;\n<11> # endif gs -> xmlDefaultSAXLocator . getPublicId = xmlSAX2GetPublicId ;\n<12> gs -> xmlDefaultSAXLocator . getSystemId = xmlSAX2GetSystemId ;\n<13> gs -> xmlDefaultSAXLocator . getLineNumber = xmlSAX2GetLineNumber ;\n<14> gs -> xmlDefaultSAXLocator . getColumnNumber = xmlSAX2GetColumnNumber ;\n<15> gs -> xmlDoValidityCheckingDefaultValue = xmlDoValidityCheckingDefaultValueThrDef ;\n<16> # if defined ( DEBUG_MEMORY_LOCATION ) | defined ( DEBUG_MEMORY ) gs -> xmlFree = ( xmlFreeFunc ) xmlMemFree ;\n<17> gs -> xmlMalloc = ( xmlMallocFunc ) xmlMemMalloc ;\n<18> gs -> xmlMallocAtomic = ( xmlMallocFunc ) xmlMemMalloc ;\n<19> gs -> xmlRealloc = ( xmlReallocFunc ) xmlMemRealloc ;\n<20> gs -> xmlMemStrdup = ( xmlStrdupFunc ) xmlMemoryStrdup ;\n<21> # else gs -> xmlFree = ( xmlFreeFunc ) free ;\n<22> gs -> xmlMalloc = ( xmlMallocFunc ) malloc ;\n<23> gs -> xmlMallocAtomic = ( xmlMallocFunc ) malloc ;\n<24> gs -> xmlRealloc = ( xmlReallocFunc ) realloc ;\n<25> gs -> xmlMemStrdup = ( xmlStrdupFunc ) xmlStrdup ;\n<26> # endif gs -> xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef ;\n<27> gs -> xmlIndentTreeOutput = xmlIndentTreeOutputThrDef ;\n<28> gs -> xmlTreeIndentString = xmlTreeIndentStringThrDef ;\n<29> gs -> xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef ;\n<30> gs -> xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef ;\n<31> gs -> xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef ;\n<32> gs -> xmlParserDebugEntities = xmlParserDebugEntitiesThrDef ;\n<33> gs -> xmlParserVersion = LIBXML_VERSION_STRING ;\n<34> gs -> xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef ;\n<35> gs -> xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef ;\n<36> gs -> xmlSubstituteEntitiesDefaultValue = xmlSubstituteEntitiesDefaultValueThrDef ;\n<37> gs -> xmlGenericError = xmlGenericErrorThrDef ;\n<38> gs -> xmlStructuredError = xmlStructuredErrorThrDef ;\n<39> gs -> xmlGenericErrorContext = xmlGenericErrorContextThrDef ;\n<40> gs -> xmlStructuredErrorContext = xmlStructuredErrorContextThrDef ;\n<41> gs -> xmlRegisterNodeDefaultValue = xmlRegisterNodeDefaultValueThrDef ;\n<42> gs -> xmlDeregisterNodeDefaultValue = xmlDeregisterNodeDefaultValueThrDef ;\n<43> gs -> xmlParserInputBufferCreateFilenameValue = xmlParserInputBufferCreateFilenameValueThrDef ;\n<44> gs -> xmlOutputBufferCreateFilenameValue = xmlOutputBufferCreateFilenameValueThrDef ;\n<45> memset ( & gs -> xmlLastError , 0 , sizeof ( xmlError ) ) ;\n<46> xmlMutexUnlock ( xmlThrDefMutex ) ;\n<47> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void flush_encoders(void)\n<2> \n<3> {\n<4> \n<5> int i, ret;\n<6> \n<7> \n<8> \n<9> for (i = 0; i < nb_output_streams; i++) {\n<10> \n<11> OutputStream   *ost = output_streams[i];\n<12> \n<13> AVCodecContext *enc = ost->enc_ctx;\n<14> \n<15> AVFormatContext *os = output_files[ost->file_index]->ctx;\n<16> \n<17> int stop_encoding = 0;\n<18> \n<19> \n<20> \n<21> if (!ost->encoding_needed)\n<22> \n<23> continue;\n<24> \n<25> \n<26> \n<27> if (enc->codec_type == AVMEDIA_TYPE_AUDIO && enc->frame_size <= 1)\n<28> \n<29> continue;\n<30> \n<31> \n<32> \n<33> if (enc->codec_type != AVMEDIA_TYPE_VIDEO && enc->codec_type != AVMEDIA_TYPE_AUDIO)\n<34> \n<35> continue;\n<36> \n<37> \n<38> \n<39> avcodec_send_frame(enc, NULL);\n<40> \n<41> \n<42> \n<43> for (;;) {\n<44> \n<45> const char *desc = NULL;\n<46> \n<47> \n<48> \n<49> switch (enc->codec_type) {\n<50> \n<51> case AVMEDIA_TYPE_AUDIO:\n<52> \n<53> desc   = "Audio";\n<54> \n<55> break;\n<56> \n<57> case AVMEDIA_TYPE_VIDEO:\n<58> \n<59> desc   = "Video";\n<60> \n<61> break;\n<62> \n<63> default:\n<64> \n<65> av_assert0(0);\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> if (1) {\n<72> \n<73> AVPacket pkt;\n<74> \n<75> av_init_packet(&pkt);\n<76> \n<77> pkt.data = NULL;\n<78> \n<79> pkt.size = 0;\n<80> \n<81> \n<82> \n<83> ret = avcodec_receive_packet(enc, &pkt);\n<84> \n<85> if (ret < 0 && ret != AVERROR_EOF) {\n<86> \n<87> av_log(NULL, AV_LOG_FATAL, "%s encoding failed\n", desc);\n<88> \n<89> exit_program(1);\n<90> \n<91> }\n<92> \n<93> if (ost->logfile && enc->stats_out) {\n<94> \n<95> fprintf(ost->logfile, "%s", enc->stats_out);\n<96> \n<97> }\n<98> \n<99> if (ret == AVERROR_EOF) {\n<100> \n<101> stop_encoding = 1;\n<102> \n<103> break;\n<104> \n<105> }\n<106> \n<107> av_packet_rescale_ts(&pkt, enc->time_base, ost->st->time_base);\n<108> \n<109> output_packet(os, &pkt, ost);\n<110> \n<111> }\n<112> \n<113> \n<114> \n<115> if (stop_encoding)\n<116> \n<117> break;\n<118> \n<119> }\n<120> \n<121> }\n<122> \n<123> }\n<124> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int read_restart_header(MLPDecodeContext *m, GetBitContext *gbp,\n<2> \n<3> const uint8_t *buf, unsigned int substr)\n<4> \n<5> {\n<6> \n<7> SubStream *s = &m->substream[substr];\n<8> \n<9> unsigned int ch;\n<10> \n<11> int sync_word, tmp;\n<12> \n<13> uint8_t checksum;\n<14> \n<15> uint8_t lossless_check;\n<16> \n<17> int start_count = get_bits_count(gbp);\n<18> \n<19> const int max_matrix_channel = m->avctx->codec_id == CODEC_ID_MLP\n<20> \n<21> ? MAX_MATRIX_CHANNEL_MLP\n<22> \n<23> : MAX_MATRIX_CHANNEL_TRUEHD;\n<24> \n<25> \n<26> \n<27> sync_word = get_bits(gbp, 13);\n<28> \n<29> \n<30> \n<31> if (sync_word != 0x31ea >> 1) {\n<32> \n<33> av_log(m->avctx, AV_LOG_ERROR,\n<34> \n<35> "restart header sync incorrect (got 0x%04x)\n", sync_word);\n<36> \n<37> return AVERROR_INVALIDDATA;\n<38> \n<39> }\n<40> \n<41> \n<42> \n<43> s->noise_type = get_bits1(gbp);\n<44> \n<45> \n<46> \n<47> if (m->avctx->codec_id == CODEC_ID_MLP && s->noise_type) {\n<48> \n<49> av_log(m->avctx, AV_LOG_ERROR, "MLP must have 0x31ea sync word.\n");\n<50> \n<51> return AVERROR_INVALIDDATA;\n<52> \n<53> }\n<54> \n<55> \n<56> \n<57> skip_bits(gbp, 16); /* Output timestamp */\n<58> \n<59> \n<60> \n<61> s->min_channel        = get_bits(gbp, 4);\n<62> \n<63> s->max_channel        = get_bits(gbp, 4);\n<64> \n<65> s->max_matrix_channel = get_bits(gbp, 4);\n<66> \n<67> \n<68> \n<69> if (s->max_matrix_channel > max_matrix_channel) {\n<70> \n<71> av_log(m->avctx, AV_LOG_ERROR,\n<72> \n<73> "Max matrix channel cannot be greater than %d.\n",\n<74> \n<75> max_matrix_channel);\n<76> \n<77> return AVERROR_INVALIDDATA;\n<78> \n<79> }\n<80> \n<81> \n<82> \n<83> if (s->max_channel != s->max_matrix_channel) {\n<84> \n<85> av_log(m->avctx, AV_LOG_ERROR,\n<86> \n<87> "Max channel must be equal max matrix channel.\n");\n<88> \n<89> return AVERROR_INVALIDDATA;\n<90> \n<91> }\n<92> \n<93> \n<94> \n<95> /* This should happen for TrueHD streams with >6 channels and MLP's noise\n<96> \n<97> * type. It is not yet known if this is allowed. */\n<98> \n<99> if (s->max_channel > MAX_MATRIX_CHANNEL_MLP && !s->noise_type) {\n<100> \n<101> av_log_ask_for_sample(m->avctx,\n<102> \n<103> "Number of channels %d is larger than the maximum supported "\n<104> \n<105> "by the decoder.\n", s->max_channel + 2);\n<106> \n<107> return AVERROR_PATCHWELCOME;\n<108> \n<109> }\n<110> \n<111> \n<112> \n<113> if (s->min_channel > s->max_channel) {\n<114> \n<115> av_log(m->avctx, AV_LOG_ERROR,\n<116> \n<117> "Substream min channel cannot be greater than max channel.\n");\n<118> \n<119> return AVERROR_INVALIDDATA;\n<120> \n<121> }\n<122> \n<123> \n<124> \n<125> if (m->avctx->request_channels > 0\n<126> \n<127> && s->max_channel + 1 >= m->avctx->request_channels\n<128> \n<129> && substr < m->max_decoded_substream) {\n<130> \n<131> av_log(m->avctx, AV_LOG_DEBUG,\n<132> \n<133> "Extracting %d channel downmix from substream %d. "\n<134> \n<135> "Further substreams will be skipped.\n",\n<136> \n<137> s->max_channel + 1, substr);\n<138> \n<139> m->max_decoded_substream = substr;\n<140> \n<141> }\n<142> \n<143> \n<144> \n<145> s->noise_shift   = get_bits(gbp,  4);\n<146> \n<147> s->noisegen_seed = get_bits(gbp, 23);\n<148> \n<149> \n<150> \n<151> skip_bits(gbp, 19);\n<152> \n<153> \n<154> \n<155> s->data_check_present = get_bits1(gbp);\n<156> \n<157> lossless_check = get_bits(gbp, 8);\n<158> \n<159> if (substr == m->max_decoded_substream\n<160> \n<161> && s->lossless_check_data != 0xffffffff) {\n<162> \n<163> tmp = xor_32_to_8(s->lossless_check_data);\n<164> \n<165> if (tmp != lossless_check)\n<166> \n<167> av_log(m->avctx, AV_LOG_WARNING,\n<168> \n<169> "Lossless check failed - expected %02x, calculated %02x.\n",\n<170> \n<171> lossless_check, tmp);\n<172> \n<173> }\n<174> \n<175> \n<176> \n<177> skip_bits(gbp, 16);\n<178> \n<179> \n<180> \n<181> memset(s->ch_assign, 0, sizeof(s->ch_assign));\n<182> \n<183> \n<184> \n<185> for (ch = 0; ch <= s->max_matrix_channel; ch++) {\n<186> \n<187> int ch_assign = get_bits(gbp, 6);\n<188> \n<189> if (ch_assign > s->max_matrix_channel) {\n<190> \n<191> av_log_ask_for_sample(m->avctx,\n<192> \n<193> "Assignment of matrix channel %d to invalid output channel %d.\n",\n<194> \n<195> ch, ch_assign);\n<196> \n<197> return AVERROR_PATCHWELCOME;\n<198> \n<199> }\n<200> \n<201> s->ch_assign[ch_assign] = ch;\n<202> \n<203> }\n<204> \n<205> \n<206> \n<207> if (m->avctx->codec_id == CODEC_ID_MLP && m->needs_reordering) {\n<208> \n<209> if (m->avctx->channel_layout == (AV_CH_LAYOUT_QUAD|AV_CH_LOW_FREQUENCY) ||\n<210> \n<211> m->avctx->channel_layout == AV_CH_LAYOUT_5POINT0_BACK) {\n<212> \n<213> int i = s->ch_assign[4];\n<214> \n<215> s->ch_assign[4] = s->ch_assign[3];\n<216> \n<217> s->ch_assign[3] = s->ch_assign[2];\n<218> \n<219> s->ch_assign[2] = i;\n<220> \n<221> } else if (m->avctx->channel_layout == AV_CH_LAYOUT_5POINT1_BACK) {\n<222> \n<223> FFSWAP(int, s->ch_assign[2], s->ch_assign[4]);\n<224> \n<225> FFSWAP(int, s->ch_assign[3], s->ch_assign[5]);\n<226> \n<227> }\n<228> \n<229> }\n<230> \n<231> if (m->avctx->codec_id == CODEC_ID_TRUEHD &&\n<232> \n<233> (m->avctx->channel_layout == AV_CH_LAYOUT_7POINT1 ||\n<234> \n<235> m->avctx->channel_layout == AV_CH_LAYOUT_7POINT1_WIDE)) {\n<236> \n<237> FFSWAP(int, s->ch_assign[4], s->ch_assign[6]);\n<238> \n<239> FFSWAP(int, s->ch_assign[5], s->ch_assign[7]);\n<240> \n<241> } else if (m->avctx->codec_id == CODEC_ID_TRUEHD &&\n<242> \n<243> (m->avctx->channel_layout == AV_CH_LAYOUT_6POINT1 ||\n<244> \n<245> m->avctx->channel_layout == (AV_CH_LAYOUT_6POINT1 | AV_CH_TOP_CENTER) ||\n<246> \n<247> m->avctx->channel_layout == (AV_CH_LAYOUT_6POINT1 | AV_CH_TOP_FRONT_CENTER))) {\n<248> \n<249> int i = s->ch_assign[6];\n<250> \n<251> s->ch_assign[6] = s->ch_assign[5];\n<252> \n<253> s->ch_assign[5] = s->ch_assign[4];\n<254> \n<255> s->ch_assign[4] = i;\n<256> \n<257> }\n<258> \n<259> \n<260> \n<261> checksum = ff_mlp_restart_checksum(buf, get_bits_count(gbp) - start_count);\n<262> \n<263> \n<264> \n<265> if (checksum != get_bits(gbp, 8))\n<266> \n<267> av_log(m->avctx, AV_LOG_ERROR, "restart header checksum error\n");\n<268> \n<269> \n<270> \n<271> /* Set default decoding parameters. */\n<272> \n<273> s->param_presence_flags   = 0xff;\n<274> \n<275> s->num_primitive_matrices = 0;\n<276> \n<277> s->blocksize              = 8;\n<278> \n<279> s->lossless_check_data    = 0;\n<280> \n<281> \n<282> \n<283> memset(s->output_shift   , 0, sizeof(s->output_shift   ));\n<284> \n<285> memset(s->quant_step_size, 0, sizeof(s->quant_step_size));\n<286> \n<287> \n<288> \n<289> for (ch = s->min_channel; ch <= s->max_channel; ch++) {\n<290> \n<291> ChannelParams *cp = &s->channel_params[ch];\n<292> \n<293> cp->filter_params[FIR].order = 0;\n<294> \n<295> cp->filter_params[IIR].order = 0;\n<296> \n<297> cp->filter_params[FIR].shift = 0;\n<298> \n<299> cp->filter_params[IIR].shift = 0;\n<300> \n<301> \n<302> \n<303> /* Default audio coding is 24-bit raw PCM. */\n<304> \n<305> cp->huff_offset      = 0;\n<306> \n<307> cp->sign_huff_offset = (-1) << 23;\n<308> \n<309> cp->codebook         = 0;\n<310> \n<311> cp->huff_lsbs        = 24;\n<312> \n<313> }\n<314> \n<315> \n<316> \n<317> if (substr == m->max_decoded_substream)\n<318> \n<319> m->avctx->channels = s->max_matrix_channel + 1;\n<320> \n<321> \n<322> \n<323> return 0;\n<324> \n<325> }\n<326> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> build_rsdt(GArray *table_data, BIOSLinker *linker, GArray *table_offsets,\n<2> \n<3> const char *oem_id, const char *oem_table_id)\n<4> \n<5> {\n<6> \n<7> AcpiRsdtDescriptorRev1 *rsdt;\n<8> \n<9> size_t rsdt_len;\n<10> \n<11> int i;\n<12> \n<13> const int table_data_len = (sizeof(uint32_t) * table_offsets->len);\n<14> \n<15> \n<16> \n<17> rsdt_len = sizeof(*rsdt) + table_data_len;\n<18> \n<19> rsdt = acpi_data_push(table_data, rsdt_len);\n<20> \n<21> memcpy(rsdt->table_offset_entry, table_offsets->data, table_data_len);\n<22> \n<23> for (i = 0; i < table_offsets->len; ++i) {\n<24> \n<25> /* rsdt->table_offset_entry to be filled by Guest linker */\n<26> \n<27> bios_linker_loader_add_pointer(linker,\n<28> \n<29> ACPI_BUILD_TABLE_FILE,\n<30> \n<31> ACPI_BUILD_TABLE_FILE,\n<32> \n<33> &rsdt->table_offset_entry[i],\n<34> \n<35> sizeof(uint32_t));\n<36> \n<37> }\n<38> \n<39> build_header(linker, table_data,\n<40> \n<41> (void *)rsdt, "RSDT", rsdt_len, 1, oem_id, oem_table_id);\n<42> \n<43> }\n<44> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int cuvid_test_dummy_decoder(AVCodecContext *avctx,\n<2> \n<3> const CUVIDPARSERPARAMS *cuparseinfo,\n<4> \n<5> int probed_width,\n<6> \n<7> int probed_height)\n<8> \n<9> {\n<10> \n<11> CuvidContext *ctx = avctx->priv_data;\n<12> \n<13> CUVIDDECODECREATEINFO cuinfo;\n<14> \n<15> CUvideodecoder cudec = 0;\n<16> \n<17> int ret = 0;\n<18> \n<19> \n<20> \n<21> memset(&cuinfo, 0, sizeof(cuinfo));\n<22> \n<23> \n<24> \n<25> cuinfo.CodecType = cuparseinfo->CodecType;\n<26> \n<27> cuinfo.ChromaFormat = cudaVideoChromaFormat_420;\n<28> \n<29> cuinfo.OutputFormat = cudaVideoSurfaceFormat_NV12;\n<30> \n<31> \n<32> \n<33> cuinfo.ulWidth = probed_width;\n<34> \n<35> cuinfo.ulHeight = probed_height;\n<36> \n<37> cuinfo.ulTargetWidth = cuinfo.ulWidth;\n<38> \n<39> cuinfo.ulTargetHeight = cuinfo.ulHeight;\n<40> \n<41> \n<42> \n<43> cuinfo.target_rect.left = 0;\n<44> \n<45> cuinfo.target_rect.top = 0;\n<46> \n<47> cuinfo.target_rect.right = cuinfo.ulWidth;\n<48> \n<49> cuinfo.target_rect.bottom = cuinfo.ulHeight;\n<50> \n<51> \n<52> \n<53> cuinfo.ulNumDecodeSurfaces = ctx->nb_surfaces;\n<54> \n<55> cuinfo.ulNumOutputSurfaces = 1;\n<56> \n<57> cuinfo.ulCreationFlags = cudaVideoCreate_PreferCUVID;\n<58> \n<59> cuinfo.bitDepthMinus8 = 0;\n<60> \n<61> \n<62> \n<63> cuinfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Weave;\n<64> \n<65> \n<66> \n<67> ret = CHECK_CU(ctx->cvdl->cuvidCreateDecoder(&cudec, &cuinfo));\n<68> \n<69> if (ret < 0)\n<70> \n<71> return ret;\n<72> \n<73> \n<74> \n<75> ret = CHECK_CU(ctx->cvdl->cuvidDestroyDecoder(cudec));\n<76> \n<77> if (ret < 0)\n<78> \n<79> return ret;\n<80> \n<81> \n<82> \n<83> return 0;\n<84> \n<85> }\n<86> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int jbig2_immediate_generic_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n<2> Jbig2RegionSegmentInfo rsi ;\n<3> byte seg_flags ;\n<4> int8_t gbat [ 8 ] ;\n<5> int offset ;\n<6> int gbat_bytes = 0 ;\n<7> Jbig2GenericRegionParams params ;\n<8> int code = 0 ;\n<9> Jbig2Image * image = NULL ;\n<10> Jbig2WordStream * ws = NULL ;\n<11> Jbig2ArithState * as = NULL ;\n<12> Jbig2ArithCx * GB_stats = NULL ;\n<13> if ( segment -> data_length < 18 ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Segment too short" ) ;\n<14> jbig2_get_region_segment_info ( & rsi , segment_data ) ;\n<15> jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , "generic region: %d x %d @ (%d, %d), flags = %02x" , rsi . width , rsi . height , rsi . x , rsi . y , rsi . flags ) ;\n<16> seg_flags = segment_data [ 17 ] ;\n<17> jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , "segment flags = %02x" , seg_flags ) ;\n<18> if ( ( seg_flags & 1 ) && ( seg_flags & 6 ) ) jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , "MMR is 1, but GBTEMPLATE is not 0" ) ;\n<19> if ( ! ( seg_flags & 1 ) ) {\n<20> gbat_bytes = ( seg_flags & 6 ) ? 2 : 8 ;\n<21> if ( 18 + gbat_bytes > segment -> data_length ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Segment too short" ) ;\n<22> memcpy ( gbat , segment_data + 18 , gbat_bytes ) ;\n<23> jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , "gbat: %d, %d" , gbat [ 0 ] , gbat [ 1 ] ) ;\n<24> }\n<25> offset = 18 + gbat_bytes ;\n<26> params . MMR = seg_flags & 1 ;\n<27> params . GBTEMPLATE = ( seg_flags & 6 ) >> 1 ;\n<28> params . TPGDON = ( seg_flags & 8 ) >> 3 ;\n<29> params . USESKIP = 0 ;\n<30> memcpy ( params . gbat , gbat , gbat_bytes ) ;\n<31> image = jbig2_image_new ( ctx , rsi . width , rsi . height ) ;\n<32> if ( image == NULL ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "unable to allocate generic image" ) ;\n<33> jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , "allocated %d x %d image buffer for region decode results" , rsi . width , rsi . height ) ;\n<34> if ( params . MMR ) {\n<35> code = jbig2_decode_generic_mmr ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , image ) ;\n<36> }\n<37> else {\n<38> int stats_size = jbig2_generic_stats_size ( ctx , params . GBTEMPLATE ) ;\n<39> GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n<40> if ( GB_stats == NULL ) {\n<41> code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "unable to allocate GB_stats in jbig2_immediate_generic_region" ) ;\n<42> goto cleanup ;\n<43> }\n<44> memset ( GB_stats , 0 , stats_size ) ;\n<45> ws = jbig2_word_stream_buf_new ( ctx , segment_data + offset , segment -> data_length - offset ) ;\n<46> if ( ws == NULL ) {\n<47> code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "unable to allocate ws in jbig2_immediate_generic_region" ) ;\n<48> goto cleanup ;\n<49> }\n<50> as = jbig2_arith_new ( ctx , ws ) ;\n<51> if ( as == NULL ) {\n<52> code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "unable to allocate as in jbig2_immediate_generic_region" ) ;\n<53> goto cleanup ;\n<54> }\n<55> code = jbig2_decode_generic_region ( ctx , segment , & params , as , image , GB_stats ) ;\n<56> }\n<57> if ( code >= 0 ) jbig2_page_add_result ( ctx , & ctx -> pages [ ctx -> current_page ] , image , rsi . x , rsi . y , rsi . op ) ;\n<58> else jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "error while decoding immediate_generic_region" ) ;\n<59> cleanup : jbig2_free ( ctx -> allocator , as ) ;\n<60> jbig2_word_stream_buf_free ( ctx , ws ) ;\n<61> jbig2_free ( ctx -> allocator , GB_stats ) ;\n<62> jbig2_image_release ( ctx , image ) ;\n<63> return code ;\n<64> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n<2> gx_ttfReader * r = ( gx_ttfReader * ) self ;\n<3> const byte * q ;\n<4> if ( ! r -> error ) {\n<5> if ( r -> extra_glyph_index != - 1 ) {\n<6> q = r -> glyph_data . bits . data + r -> pos ;\n<7> r -> error = ( r -> glyph_data . bits . size - r -> pos < n ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n<8> if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n<9> }\n<10> else {\n<11> unsigned int cnt ;\n<12> for ( cnt = 0 ;\n<13> cnt < ( uint ) n ;\n<14> cnt += r -> error ) {\n<15> r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;\n<16> if ( r -> error < 0 ) break ;\n<17> else if ( r -> error == 0 ) {\n<18> memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n<19> break ;\n<20> }\n<21> else {\n<22> memcpy ( ( char * ) p + cnt , q , r -> error ) ;\n<23> }\n<24> }\n<25> }\n<26> }\n<27> if ( r -> error ) {\n<28> memset ( p , 0 , n ) ;\n<29> return ;\n<30> }\n<31> r -> pos += n ;\n<32> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void qemu_spice_init(void)\n<2> \n<3> {\n<4> \n<5> QemuOpts *opts = QTAILQ_FIRST(&qemu_spice_opts.head);\n<6> \n<7> const char *password, *str, *x509_dir, *addr,\n<8> \n<9> *x509_key_password = NULL,\n<10> \n<11> *x509_dh_file = NULL,\n<12> \n<13> *tls_ciphers = NULL;\n<14> \n<15> char *x509_key_file = NULL,\n<16> \n<17> *x509_cert_file = NULL,\n<18> \n<19> *x509_cacert_file = NULL;\n<20> \n<21> int port, tls_port, len, addr_flags;\n<22> \n<23> spice_image_compression_t compression;\n<24> \n<25> spice_wan_compression_t wan_compr;\n<26> \n<27> \n<28> \n<29> qemu_thread_get_self(&me);\n<30> \n<31> \n<32> \n<33> if (!opts) {\n<34> \n<35> return;\n<36> \n<37> }\n<38> \n<39> port = qemu_opt_get_number(opts, "port", 0);\n<40> \n<41> tls_port = qemu_opt_get_number(opts, "tls-port", 0);\n<42> \n<43> if (!port && !tls_port) {\n<44> \n<45> fprintf(stderr, "neither port nor tls-port specified for spice.");\n<46> \n<47> exit(1);\n<48> \n<49> }\n<50> \n<51> if (port < 0 || port > 65535) {\n<52> \n<53> fprintf(stderr, "spice port is out of range");\n<54> \n<55> exit(1);\n<56> \n<57> }\n<58> \n<59> if (tls_port < 0 || tls_port > 65535) {\n<60> \n<61> fprintf(stderr, "spice tls-port is out of range");\n<62> \n<63> exit(1);\n<64> \n<65> }\n<66> \n<67> password = qemu_opt_get(opts, "password");\n<68> \n<69> \n<70> \n<71> if (tls_port) {\n<72> \n<73> x509_dir = qemu_opt_get(opts, "x509-dir");\n<74> \n<75> if (NULL == x509_dir) {\n<76> \n<77> x509_dir = ".";\n<78> \n<79> }\n<80> \n<81> len = strlen(x509_dir) + 32;\n<82> \n<83> \n<84> \n<85> str = qemu_opt_get(opts, "x509-key-file");\n<86> \n<87> if (str) {\n<88> \n<89> x509_key_file = g_strdup(str);\n<90> \n<91> } else {\n<92> \n<93> x509_key_file = g_malloc(len);\n<94> \n<95> snprintf(x509_key_file, len, "%s/%s", x509_dir, X509_SERVER_KEY_FILE);\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> str = qemu_opt_get(opts, "x509-cert-file");\n<102> \n<103> if (str) {\n<104> \n<105> x509_cert_file = g_strdup(str);\n<106> \n<107> } else {\n<108> \n<109> x509_cert_file = g_malloc(len);\n<110> \n<111> snprintf(x509_cert_file, len, "%s/%s", x509_dir, X509_SERVER_CERT_FILE);\n<112> \n<113> }\n<114> \n<115> \n<116> \n<117> str = qemu_opt_get(opts, "x509-cacert-file");\n<118> \n<119> if (str) {\n<120> \n<121> x509_cacert_file = g_strdup(str);\n<122> \n<123> } else {\n<124> \n<125> x509_cacert_file = g_malloc(len);\n<126> \n<127> snprintf(x509_cacert_file, len, "%s/%s", x509_dir, X509_CA_CERT_FILE);\n<128> \n<129> }\n<130> \n<131> \n<132> \n<133> x509_key_password = qemu_opt_get(opts, "x509-key-password");\n<134> \n<135> x509_dh_file = qemu_opt_get(opts, "x509-dh-file");\n<136> \n<137> tls_ciphers = qemu_opt_get(opts, "tls-ciphers");\n<138> \n<139> }\n<140> \n<141> \n<142> \n<143> addr = qemu_opt_get(opts, "addr");\n<144> \n<145> addr_flags = 0;\n<146> \n<147> if (qemu_opt_get_bool(opts, "ipv4", 0)) {\n<148> \n<149> addr_flags |= SPICE_ADDR_FLAG_IPV4_ONLY;\n<150> \n<151> } else if (qemu_opt_get_bool(opts, "ipv6", 0)) {\n<152> \n<153> addr_flags |= SPICE_ADDR_FLAG_IPV6_ONLY;\n<154> \n<155> }\n<156> \n<157> \n<158> \n<159> spice_server = spice_server_new();\n<160> \n<161> spice_server_set_addr(spice_server, addr ? addr : "", addr_flags);\n<162> \n<163> if (port) {\n<164> \n<165> spice_server_set_port(spice_server, port);\n<166> \n<167> }\n<168> \n<169> if (tls_port) {\n<170> \n<171> spice_server_set_tls(spice_server, tls_port,\n<172> \n<173> x509_cacert_file,\n<174> \n<175> x509_cert_file,\n<176> \n<177> x509_key_file,\n<178> \n<179> x509_key_password,\n<180> \n<181> x509_dh_file,\n<182> \n<183> tls_ciphers);\n<184> \n<185> }\n<186> \n<187> if (password) {\n<188> \n<189> spice_server_set_ticket(spice_server, password, 0, 0, 0);\n<190> \n<191> }\n<192> \n<193> if (qemu_opt_get_bool(opts, "sasl", 0)) {\n<194> \n<195> #if SPICE_SERVER_VERSION >= 0x000900 /* 0.9.0 */\n<196> \n<197> if (spice_server_set_sasl_appname(spice_server, "qemu") == -1 ||\n<198> \n<199> spice_server_set_sasl(spice_server, 1) == -1) {\n<200> \n<201> fprintf(stderr, "spice: failed to enable sasl\n");\n<202> \n<203> exit(1);\n<204> \n<205> }\n<206> \n<207> #else\n<208> \n<209> fprintf(stderr, "spice: sasl is not available (spice >= 0.9 required)\n");\n<210> \n<211> exit(1);\n<212> \n<213> #endif\n<214> \n<215> }\n<216> \n<217> if (qemu_opt_get_bool(opts, "disable-ticketing", 0)) {\n<218> \n<219> auth = "none";\n<220> \n<221> spice_server_set_noauth(spice_server);\n<222> \n<223> }\n<224> \n<225> \n<226> \n<227> #if SPICE_SERVER_VERSION >= 0x000801\n<228> \n<229> if (qemu_opt_get_bool(opts, "disable-copy-paste", 0)) {\n<230> \n<231> spice_server_set_agent_copypaste(spice_server, false);\n<232> \n<233> }\n<234> \n<235> #endif\n<236> \n<237> \n<238> \n<239> compression = SPICE_IMAGE_COMPRESS_AUTO_GLZ;\n<240> \n<241> str = qemu_opt_get(opts, "image-compression");\n<242> \n<243> if (str) {\n<244> \n<245> compression = parse_compression(str);\n<246> \n<247> }\n<248> \n<249> spice_server_set_image_compression(spice_server, compression);\n<250> \n<251> \n<252> \n<253> wan_compr = SPICE_WAN_COMPRESSION_AUTO;\n<254> \n<255> str = qemu_opt_get(opts, "jpeg-wan-compression");\n<256> \n<257> if (str) {\n<258> \n<259> wan_compr = parse_wan_compression(str);\n<260> \n<261> }\n<262> \n<263> spice_server_set_jpeg_compression(spice_server, wan_compr);\n<264> \n<265> \n<266> \n<267> wan_compr = SPICE_WAN_COMPRESSION_AUTO;\n<268> \n<269> str = qemu_opt_get(opts, "zlib-glz-wan-compression");\n<270> \n<271> if (str) {\n<272> \n<273> wan_compr = parse_wan_compression(str);\n<274> \n<275> }\n<276> \n<277> spice_server_set_zlib_glz_compression(spice_server, wan_compr);\n<278> \n<279> \n<280> \n<281> str = qemu_opt_get(opts, "streaming-video");\n<282> \n<283> if (str) {\n<284> \n<285> int streaming_video = parse_stream_video(str);\n<286> \n<287> spice_server_set_streaming_video(spice_server, streaming_video);\n<288> \n<289> }\n<290> \n<291> \n<292> \n<293> spice_server_set_agent_mouse\n<294> \n<295> (spice_server, qemu_opt_get_bool(opts, "agent-mouse", 1));\n<296> \n<297> spice_server_set_playback_compression\n<298> \n<299> (spice_server, qemu_opt_get_bool(opts, "playback-compression", 1));\n<300> \n<301> \n<302> \n<303> qemu_opt_foreach(opts, add_channel, NULL, 0);\n<304> \n<305> \n<306> \n<307> if (0 != spice_server_init(spice_server, &core_interface)) {\n<308> \n<309> fprintf(stderr, "failed to initialize spice server");\n<310> \n<311> exit(1);\n<312> \n<313> };\n<314> \n<315> using_spice = 1;\n<316> \n<317> \n<318> \n<319> migration_state.notify = migration_state_notifier;\n<320> \n<321> add_migration_state_change_notifier(&migration_state);\n<322> \n<323> #ifdef SPICE_INTERFACE_MIGRATION\n<324> \n<325> spice_migrate.sin.base.sif = &migrate_interface.base;\n<326> \n<327> spice_migrate.connect_complete.cb = NULL;\n<328> \n<329> qemu_spice_add_interface(&spice_migrate.sin.base);\n<330> \n<331> #endif\n<332> \n<333> \n<334> \n<335> qemu_spice_input_init();\n<336> \n<337> qemu_spice_audio_init();\n<338> \n<339> \n<340> \n<341> g_free(x509_key_file);\n<342> \n<343> g_free(x509_cert_file);\n<344> \n<345> g_free(x509_cacert_file);\n<346> \n<347> }\n<348> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int qcow_read(BlockDriverState *bs, int64_t sector_num,\n<2> \n<3> uint8_t *buf, int nb_sectors)\n<4> \n<5> {\n<6> \n<7> BDRVQcowState *s = bs->opaque;\n<8> \n<9> int ret, index_in_cluster, n, n1;\n<10> \n<11> uint64_t cluster_offset;\n<12> \n<13> \n<14> \n<15> while (nb_sectors > 0) {\n<16> \n<17> n = nb_sectors;\n<18> \n<19> cluster_offset = qcow2_get_cluster_offset(bs, sector_num << 9, &n);\n<20> \n<21> index_in_cluster = sector_num & (s->cluster_sectors - 1);\n<22> \n<23> if (!cluster_offset) {\n<24> \n<25> if (bs->backing_hd) {\n<26> \n<27> /* read from the base image */\n<28> \n<29> n1 = qcow2_backing_read1(bs->backing_hd, sector_num, buf, n);\n<30> \n<31> if (n1 > 0) {\n<32> \n<33> BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING);\n<34> \n<35> ret = bdrv_read(bs->backing_hd, sector_num, buf, n1);\n<36> \n<37> if (ret < 0)\n<38> \n<39> return -1;\n<40> \n<41> }\n<42> \n<43> } else {\n<44> \n<45> memset(buf, 0, 512 * n);\n<46> \n<47> }\n<48> \n<49> } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n<50> \n<51> if (qcow2_decompress_cluster(bs, cluster_offset) < 0)\n<52> \n<53> return -1;\n<54> \n<55> memcpy(buf, s->cluster_cache + index_in_cluster * 512, 512 * n);\n<56> \n<57> } else {\n<58> \n<59> BLKDBG_EVENT(bs->file, BLKDBG_READ);\n<60> \n<61> ret = bdrv_pread(bs->file, cluster_offset + index_in_cluster * 512, buf, n * 512);\n<62> \n<63> if (ret != n * 512)\n<64> \n<65> return -1;\n<66> \n<67> if (s->crypt_method) {\n<68> \n<69> qcow2_encrypt_sectors(s, sector_num, buf, buf, n, 0,\n<70> \n<71> &s->aes_decrypt_key);\n<72> \n<73> }\n<74> \n<75> }\n<76> \n<77> nb_sectors -= n;\n<78> \n<79> sector_num += n;\n<80> \n<81> buf += n * 512;\n<82> \n<83> }\n<84> \n<85> return 0;\n<86> \n<87> }\n<88> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> build_ssdt(GArray *table_data, GArray *linker,\n<2> \n<3> AcpiCpuInfo *cpu, AcpiPmInfo *pm, AcpiMiscInfo *misc,\n<4> \n<5> PcPciInfo *pci, PcGuestInfo *guest_info)\n<6> \n<7> {\n<8> \n<9> int acpi_cpus = MIN(0xff, guest_info->apic_id_limit);\n<10> \n<11> int ssdt_start = table_data->len;\n<12> \n<13> uint8_t *ssdt_ptr;\n<14> \n<15> int i;\n<16> \n<17> \n<18> \n<19> /* Copy header and patch values in the S3_ / S4_ / S5_ packages */\n<20> \n<21> ssdt_ptr = acpi_data_push(table_data, sizeof(ssdp_misc_aml));\n<22> \n<23> memcpy(ssdt_ptr, ssdp_misc_aml, sizeof(ssdp_misc_aml));\n<24> \n<25> if (pm->s3_disabled) {\n<26> \n<27> ssdt_ptr[acpi_s3_name[0]] = 'X';\n<28> \n<29> }\n<30> \n<31> if (pm->s4_disabled) {\n<32> \n<33> ssdt_ptr[acpi_s4_name[0]] = 'X';\n<34> \n<35> } else {\n<36> \n<37> ssdt_ptr[acpi_s4_pkg[0] + 1] = ssdt_ptr[acpi_s4_pkg[0] + 3] =\n<38> \n<39> pm->s4_val;\n<40> \n<41> }\n<42> \n<43> \n<44> \n<45> patch_pci_windows(pci, ssdt_ptr, sizeof(ssdp_misc_aml));\n<46> \n<47> \n<48> \n<49> ACPI_BUILD_SET_LE(ssdt_ptr, sizeof(ssdp_misc_aml),\n<50> \n<51> ssdt_isa_pest[0], 16, misc->pvpanic_port);\n<52> \n<53> \n<54> \n<55> {\n<56> \n<57> GArray *sb_scope = build_alloc_array();\n<58> \n<59> uint8_t op = 0x10; /* ScopeOp */\n<60> \n<61> \n<62> \n<63> build_append_nameseg(sb_scope, "_SB_");\n<64> \n<65> \n<66> \n<67> /* build Processor object for each processor */\n<68> \n<69> for (i = 0; i < acpi_cpus; i++) {\n<70> \n<71> uint8_t *proc = acpi_data_push(sb_scope, ACPI_PROC_SIZEOF);\n<72> \n<73> memcpy(proc, ACPI_PROC_AML, ACPI_PROC_SIZEOF);\n<74> \n<75> proc[ACPI_PROC_OFFSET_CPUHEX] = acpi_get_hex(i >> 4);\n<76> \n<77> proc[ACPI_PROC_OFFSET_CPUHEX+1] = acpi_get_hex(i);\n<78> \n<79> proc[ACPI_PROC_OFFSET_CPUID1] = i;\n<80> \n<81> proc[ACPI_PROC_OFFSET_CPUID2] = i;\n<82> \n<83> }\n<84> \n<85> \n<86> \n<87> /* build this code:\n<88> \n<89> *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n<90> \n<91> */\n<92> \n<93> /* Arg0 = Processor ID = APIC ID */\n<94> \n<95> build_append_notify_method(sb_scope, "NTFY", "CP%0.02X", acpi_cpus);\n<96> \n<97> \n<98> \n<99> /* build "Name(CPON, Package() { One, One, ..., Zero, Zero, ... })" */\n<100> \n<101> build_append_byte(sb_scope, 0x08); /* NameOp */\n<102> \n<103> build_append_nameseg(sb_scope, "CPON");\n<104> \n<105> \n<106> \n<107> {\n<108> \n<109> GArray *package = build_alloc_array();\n<110> \n<111> uint8_t op = 0x12; /* PackageOp */\n<112> \n<113> \n<114> \n<115> build_append_byte(package, acpi_cpus); /* NumElements */\n<116> \n<117> for (i = 0; i < acpi_cpus; i++) {\n<118> \n<119> uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;\n<120> \n<121> build_append_byte(package, b);\n<122> \n<123> }\n<124> \n<125> \n<126> \n<127> build_package(package, op, 2);\n<128> \n<129> build_append_array(sb_scope, package);\n<130> \n<131> build_free_array(package);\n<132> \n<133> }\n<134> \n<135> \n<136> \n<137> {\n<138> \n<139> AcpiBuildPciBusHotplugState hotplug_state;\n<140> \n<141> Object *pci_host;\n<142> \n<143> PCIBus *bus = NULL;\n<144> \n<145> bool ambiguous;\n<146> \n<147> \n<148> \n<149> pci_host = object_resolve_path_type("", TYPE_PCI_HOST_BRIDGE, &ambiguous);\n<150> \n<151> if (!ambiguous && pci_host) {\n<152> \n<153> bus = PCI_HOST_BRIDGE(pci_host)->bus;\n<154> \n<155> }\n<156> \n<157> \n<158> \n<159> build_pci_bus_state_init(&hotplug_state, NULL);\n<160> \n<161> \n<162> \n<163> if (bus) {\n<164> \n<165> /* Scan all PCI buses. Generate tables to support hotplug. */\n<166> \n<167> pci_for_each_bus_depth_first(bus, build_pci_bus_begin,\n<168> \n<169> build_pci_bus_end, &hotplug_state);\n<170> \n<171> }\n<172> \n<173> \n<174> \n<175> build_append_array(sb_scope, hotplug_state.device_table);\n<176> \n<177> build_pci_bus_state_cleanup(&hotplug_state);\n<178> \n<179> }\n<180> \n<181> \n<182> \n<183> build_package(sb_scope, op, 3);\n<184> \n<185> build_append_array(table_data, sb_scope);\n<186> \n<187> build_free_array(sb_scope);\n<188> \n<189> }\n<190> \n<191> \n<192> \n<193> build_header(linker, table_data,\n<194> \n<195> (void *)(table_data->data + ssdt_start),\n<196> \n<197> ACPI_SSDT_SIGNATURE, table_data->len - ssdt_start, 1);\n<198> \n<199> }\n<200> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void smbios_build_type_0_fields(QemuOpts *opts)\n<2> \n<3> {\n<4> \n<5> const char *val;\n<6> \n<7> unsigned char major, minor;\n<8> \n<9> \n<10> \n<11> val = qemu_opt_get(opts, "vendor");\n<12> \n<13> if (val) {\n<14> \n<15> smbios_add_field(0, offsetof(struct smbios_type_0, vendor_str),\n<16> \n<17> val, strlen(val) + 1);\n<18> \n<19> }\n<20> \n<21> val = qemu_opt_get(opts, "version");\n<22> \n<23> if (val) {\n<24> \n<25> smbios_add_field(0, offsetof(struct smbios_type_0, bios_version_str),\n<26> \n<27> val, strlen(val) + 1);\n<28> \n<29> }\n<30> \n<31> val = qemu_opt_get(opts, "date");\n<32> \n<33> if (val) {\n<34> \n<35> smbios_add_field(0, offsetof(struct smbios_type_0,\n<36> \n<37> bios_release_date_str),\n<38> \n<39> val, strlen(val) + 1);\n<40> \n<41> }\n<42> \n<43> val = qemu_opt_get(opts, "release");\n<44> \n<45> if (val) {\n<46> \n<47> if (sscanf(val, "%hhu.%hhu", &major, &minor) != 2) {\n<48> \n<49> error_report("Invalid release");\n<50> \n<51> exit(1);\n<52> \n<53> }\n<54> \n<55> smbios_add_field(0, offsetof(struct smbios_type_0,\n<56> \n<57> system_bios_major_release),\n<58> \n<59> &major, 1);\n<60> \n<61> smbios_add_field(0, offsetof(struct smbios_type_0,\n<62> \n<63> system_bios_minor_release),\n<64> \n<65> &minor, 1);\n<66> \n<67> }\n<68> \n<69> }\n<70> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static char *qemu_rbd_next_tok(int max_len,\n<2> \n<3> char *src, char delim,\n<4> \n<5> const char *name,\n<6> \n<7> char **p, Error **errp)\n<8> \n<9> {\n<10> \n<11> int l;\n<12> \n<13> char *end;\n<14> \n<15> \n<16> \n<17> *p = NULL;\n<18> \n<19> \n<20> \n<21> if (delim != '\0') {\n<22> \n<23> for (end = src; *end; ++end) {\n<24> \n<25> if (*end == delim) {\n<26> \n<27> break;\n<28> \n<29> }\n<30> \n<31> if (*end == '\\' && end[1] != '\0') {\n<32> \n<33> end++;\n<34> \n<35> }\n<36> \n<37> }\n<38> \n<39> if (*end == delim) {\n<40> \n<41> *p = end + 1;\n<42> \n<43> *end = '\0';\n<44> \n<45> }\n<46> \n<47> }\n<48> \n<49> l = strlen(src);\n<50> \n<51> if (l >= max_len) {\n<52> \n<53> error_setg(errp, "%s too long", name);\n<54> \n<55> return NULL;\n<56> \n<57> } else if (l == 0) {\n<58> \n<59> error_setg(errp, "%s too short", name);\n<60> \n<61> return NULL;\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> return src;\n<68> \n<69> }\n<70> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void qemu_chr_printf(CharDriverState *s, const char *fmt, ...)\n<2> \n<3> {\n<4> \n<5> char buf[4096];\n<6> \n<7> va_list ap;\n<8> \n<9> va_start(ap, fmt);\n<10> \n<11> vsnprintf(buf, sizeof(buf), fmt, ap);\n<12> \n<13> qemu_chr_write(s, (uint8_t *)buf, strlen(buf));\n<14> \n<15> va_end(ap);\n<16> \n<17> }\n<18> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mpegts_write_packet(AVFormatContext *s, AVPacket *pkt)\n<2> \n<3> {\n<4> \n<5> AVStream *st = s->streams[pkt->stream_index];\n<6> \n<7> int size= pkt->size;\n<8> \n<9> uint8_t *buf= pkt->data;\n<10> \n<11> MpegTSWriteStream *ts_st = st->priv_data;\n<12> \n<13> int len, max_payload_size;\n<14> \n<15> const uint8_t *access_unit_index = NULL;\n<16> \n<17> \n<18> \n<19> if (st->codec->codec_type == CODEC_TYPE_SUBTITLE) {\n<20> \n<21> /* for subtitle, a single PES packet must be generated */\n<22> \n<23> mpegts_write_pes(s, st, buf, size, pkt->pts, AV_NOPTS_VALUE);\n<24> \n<25> return 0;\n<26> \n<27> }\n<28> \n<29> \n<30> \n<31> if (st->codec->codec_id == CODEC_ID_DIRAC) {\n<32> \n<33> /* for Dirac, a single PES packet must be generated */\n<34> \n<35> mpegts_write_pes(s, st, buf, size, pkt->pts, pkt->dts);\n<36> \n<37> return 0;\n<38> \n<39> }\n<40> \n<41> max_payload_size = DEFAULT_PES_PAYLOAD_SIZE;\n<42> \n<43> if (st->codec->codec_id == CODEC_ID_MPEG2VIDEO ||\n<44> \n<45> st->codec->codec_id == CODEC_ID_MPEG1VIDEO) {\n<46> \n<47> const uint8_t *p = pkt->data;\n<48> \n<49> const uint8_t *end = pkt->data+pkt->size;\n<50> \n<51> uint32_t state = -1;\n<52> \n<53> while (p < end) {\n<54> \n<55> p = ff_find_start_code(p, end, &state);\n<56> \n<57> if (state == PICTURE_START_CODE) {\n<58> \n<59> access_unit_index = p - 4;\n<60> \n<61> break;\n<62> \n<63> }\n<64> \n<65> }\n<66> \n<67> } else if (st->codec->codec_type == CODEC_TYPE_AUDIO) {\n<68> \n<69> access_unit_index = pkt->data;\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> if (!access_unit_index) {\n<76> \n<77> av_log(s, AV_LOG_ERROR, "error, could not find access unit start\n");\n<78> \n<79> return -1;\n<80> \n<81> }\n<82> \n<83> \n<84> \n<85> while (size > 0) {\n<86> \n<87> len = max_payload_size - ts_st->payload_index;\n<88> \n<89> if (len > size)\n<90> \n<91> len = size;\n<92> \n<93> memcpy(ts_st->payload + ts_st->payload_index, buf, len);\n<94> \n<95> buf += len;\n<96> \n<97> size -= len;\n<98> \n<99> ts_st->payload_index += len;\n<100> \n<101> if (access_unit_index && access_unit_index < buf &&\n<102> \n<103> ts_st->payload_pts == AV_NOPTS_VALUE &&\n<104> \n<105> ts_st->payload_dts == AV_NOPTS_VALUE) {\n<106> \n<107> ts_st->payload_dts = pkt->dts;\n<108> \n<109> ts_st->payload_pts = pkt->pts;\n<110> \n<111> }\n<112> \n<113> if (ts_st->payload_index >= max_payload_size) {\n<114> \n<115> mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_index,\n<116> \n<117> ts_st->payload_pts, ts_st->payload_dts);\n<118> \n<119> ts_st->payload_pts = AV_NOPTS_VALUE;\n<120> \n<121> ts_st->payload_dts = AV_NOPTS_VALUE;\n<122> \n<123> ts_st->payload_index = 0;\n<124> \n<125> access_unit_index = NULL; // unset access unit to avoid setting pts/dts again\n<126> \n<127> }\n<128> \n<129> }\n<130> \n<131> return 0;\n<132> \n<133> }\n<134> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void kempf_restore_buf(const uint8_t *src, int len,\n<2> \n<3> uint8_t *dst, int stride,\n<4> \n<5> const uint8_t *jpeg_tile, int tile_stride,\n<6> \n<7> int width, int height,\n<8> \n<9> const uint8_t *pal, int npal, int tidx)\n<10> \n<11> {\n<12> \n<13> GetBitContext gb;\n<14> \n<15> int i, j, nb, col;\n<16> \n<17> \n<18> \n<19> init_get_bits8(&gb, src, len);\n<20> \n<21> \n<22> \n<23> if (npal <= 2)       nb = 1;\n<24> \n<25> else if (npal <= 4)  nb = 2;\n<26> \n<27> else if (npal <= 16) nb = 4;\n<28> \n<29> else                 nb = 8;\n<30> \n<31> \n<32> \n<33> for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {\n<34> \n<35> if (get_bits(&gb, 8))\n<36> \n<37> continue;\n<38> \n<39> for (i = 0; i < width; i++) {\n<40> \n<41> col = get_bits(&gb, nb);\n<42> \n<43> if (col != tidx)\n<44> \n<45> memcpy(dst + i * 3, pal + col * 3, 3);\n<46> \n<47> else\n<48> \n<49> memcpy(dst + i * 3, jpeg_tile + i * 3, 3);\n<50> \n<51> }\n<52> \n<53> }\n<54> \n<55> }\n<56> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void qemu_enqueue_packet(VLANClientState *sender,\n<2> \n<3> const uint8_t *buf, int size,\n<4> \n<5> NetPacketSent *sent_cb)\n<6> \n<7> {\n<8> \n<9> VLANPacket *packet;\n<10> \n<11> \n<12> \n<13> packet = qemu_malloc(sizeof(VLANPacket) + size);\n<14> \n<15> packet->sender = sender;\n<16> \n<17> packet->size = size;\n<18> \n<19> packet->sent_cb = sent_cb;\n<20> \n<21> memcpy(packet->data, buf, size);\n<22> \n<23> \n<24> \n<25> TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);\n<26> \n<27> }\n<28> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> ssize_t qemu_sendv_packet(VLANClientState *sender, const struct iovec *iov,\n<2> \n<3> int iovcnt)\n<4> \n<5> {\n<6> \n<7> VLANState *vlan = sender->vlan;\n<8> \n<9> VLANClientState *vc;\n<10> \n<11> VLANPacket *packet;\n<12> \n<13> ssize_t max_len = 0;\n<14> \n<15> int i;\n<16> \n<17> \n<18> \n<19> if (sender->link_down)\n<20> \n<21> return calc_iov_length(iov, iovcnt);\n<22> \n<23> \n<24> \n<25> if (vlan->delivering) {\n<26> \n<27> max_len = calc_iov_length(iov, iovcnt);\n<28> \n<29> \n<30> \n<31> packet = qemu_malloc(sizeof(VLANPacket) + max_len);\n<32> \n<33> packet->next = vlan->send_queue;\n<34> \n<35> packet->sender = sender;\n<36> \n<37> packet->size = 0;\n<38> \n<39> for (i = 0; i < iovcnt; i++) {\n<40> \n<41> size_t len = iov[i].iov_len;\n<42> \n<43> \n<44> \n<45> memcpy(packet->data + packet->size, iov[i].iov_base, len);\n<46> \n<47> packet->size += len;\n<48> \n<49> }\n<50> \n<51> vlan->send_queue = packet;\n<52> \n<53> } else {\n<54> \n<55> vlan->delivering = 1;\n<56> \n<57> \n<58> \n<59> for (vc = vlan->first_client; vc != NULL; vc = vc->next) {\n<60> \n<61> ssize_t len = 0;\n<62> \n<63> \n<64> \n<65> if (vc == sender) {\n<66> \n<67> continue;\n<68> \n<69> }\n<70> \n<71> if (vc->link_down) {\n<72> \n<73> len = calc_iov_length(iov, iovcnt);\n<74> \n<75> } else if (vc->receive_iov) {\n<76> \n<77> len = vc->receive_iov(vc->opaque, iov, iovcnt);\n<78> \n<79> } else if (vc->receive) {\n<80> \n<81> len = vc_sendv_compat(vc, iov, iovcnt);\n<82> \n<83> }\n<84> \n<85> max_len = MAX(max_len, len);\n<86> \n<87> }\n<88> \n<89> \n<90> \n<91> while ((packet = vlan->send_queue) != NULL) {\n<92> \n<93> vlan->send_queue = packet->next;\n<94> \n<95> qemu_deliver_packet(packet->sender, packet->data, packet->size);\n<96> \n<97> qemu_free(packet);\n<98> \n<99> }\n<100> \n<101> vlan->delivering = 0;\n<102> \n<103> }\n<104> \n<105> \n<106> \n<107> return max_len;\n<108> \n<109> }\n<110> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void readline_update(ReadLineState *rs)\n<2> \n<3> {\n<4> \n<5> int i, delta, len;\n<6> \n<7> \n<8> \n<9> if (rs->cmd_buf_size != rs->last_cmd_buf_size ||\n<10> \n<11> memcmp(rs->cmd_buf, rs->last_cmd_buf, rs->cmd_buf_size) != 0) {\n<12> \n<13> for(i = 0; i < rs->last_cmd_buf_index; i++) {\n<14> \n<15> monitor_printf(rs->mon, "\033[D");\n<16> \n<17> }\n<18> \n<19> rs->cmd_buf[rs->cmd_buf_size] = '\0';\n<20> \n<21> if (rs->read_password) {\n<22> \n<23> len = strlen(rs->cmd_buf);\n<24> \n<25> for(i = 0; i < len; i++)\n<26> \n<27> monitor_printf(rs->mon, "*");\n<28> \n<29> } else {\n<30> \n<31> monitor_printf(rs->mon, "%s", rs->cmd_buf);\n<32> \n<33> }\n<34> \n<35> monitor_printf(rs->mon, "\033[K");\n<36> \n<37> memcpy(rs->last_cmd_buf, rs->cmd_buf, rs->cmd_buf_size);\n<38> \n<39> rs->last_cmd_buf_size = rs->cmd_buf_size;\n<40> \n<41> rs->last_cmd_buf_index = rs->cmd_buf_size;\n<42> \n<43> }\n<44> \n<45> if (rs->cmd_buf_index != rs->last_cmd_buf_index) {\n<46> \n<47> delta = rs->cmd_buf_index - rs->last_cmd_buf_index;\n<48> \n<49> if (delta > 0) {\n<50> \n<51> for(i = 0;i < delta; i++) {\n<52> \n<53> monitor_printf(rs->mon, "\033[C");\n<54> \n<55> }\n<56> \n<57> } else {\n<58> \n<59> delta = -delta;\n<60> \n<61> for(i = 0;i < delta; i++) {\n<62> \n<63> monitor_printf(rs->mon, "\033[D");\n<64> \n<65> }\n<66> \n<67> }\n<68> \n<69> rs->last_cmd_buf_index = rs->cmd_buf_index;\n<70> \n<71> }\n<72> \n<73> monitor_flush(rs->mon);\n<74> \n<75> }\n<76> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void sun4m_hw_init(const struct sun4m_hwdef *hwdef,\n<2> \n<3> MachineState *machine)\n<4> \n<5> {\n<6> \n<7> const char *cpu_model = machine->cpu_model;\n<8> \n<9> unsigned int i;\n<10> \n<11> void *iommu, *espdma, *ledma, *nvram;\n<12> \n<13> qemu_irq *cpu_irqs[MAX_CPUS], slavio_irq[32], slavio_cpu_irq[MAX_CPUS],\n<14> \n<15> espdma_irq, ledma_irq;\n<16> \n<17> qemu_irq esp_reset, dma_enable;\n<18> \n<19> qemu_irq fdc_tc;\n<20> \n<21> qemu_irq *cpu_halt;\n<22> \n<23> unsigned long kernel_size;\n<24> \n<25> DriveInfo *fd[MAX_FD];\n<26> \n<27> FWCfgState *fw_cfg;\n<28> \n<29> unsigned int num_vsimms;\n<30> \n<31> \n<32> \n<33> /* init CPUs */\n<34> \n<35> if (!cpu_model)\n<36> \n<37> cpu_model = hwdef->default_cpu_model;\n<38> \n<39> \n<40> \n<41> for(i = 0; i < smp_cpus; i++) {\n<42> \n<43> cpu_devinit(cpu_model, i, hwdef->slavio_base, &cpu_irqs[i]);\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> for (i = smp_cpus; i < MAX_CPUS; i++)\n<50> \n<51> cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);\n<52> \n<53> \n<54> \n<55> \n<56> \n<57> /* set up devices */\n<58> \n<59> ram_init(0, machine->ram_size, hwdef->max_mem);\n<60> \n<61> /* models without ECC don't trap when missing ram is accessed */\n<62> \n<63> if (!hwdef->ecc_base) {\n<64> \n<65> empty_slot_init(machine->ram_size, hwdef->max_mem - machine->ram_size);\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> prom_init(hwdef->slavio_base, bios_name);\n<72> \n<73> \n<74> \n<75> slavio_intctl = slavio_intctl_init(hwdef->intctl_base,\n<76> \n<77> hwdef->intctl_base + 0x10000ULL,\n<78> \n<79> cpu_irqs);\n<80> \n<81> \n<82> \n<83> for (i = 0; i < 32; i++) {\n<84> \n<85> slavio_irq[i] = qdev_get_gpio_in(slavio_intctl, i);\n<86> \n<87> }\n<88> \n<89> for (i = 0; i < MAX_CPUS; i++) {\n<90> \n<91> slavio_cpu_irq[i] = qdev_get_gpio_in(slavio_intctl, 32 + i);\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> if (hwdef->idreg_base) {\n<98> \n<99> idreg_init(hwdef->idreg_base);\n<100> \n<101> }\n<102> \n<103> \n<104> \n<105> if (hwdef->afx_base) {\n<106> \n<107> afx_init(hwdef->afx_base);\n<108> \n<109> }\n<110> \n<111> \n<112> \n<113> iommu = iommu_init(hwdef->iommu_base, hwdef->iommu_version,\n<114> \n<115> slavio_irq[30]);\n<116> \n<117> \n<118> \n<119> if (hwdef->iommu_pad_base) {\n<120> \n<121> /* On the real hardware (SS-5, LX) the MMU is not padded, but aliased.\n<122> \n<123> Software shouldn't use aliased addresses, neither should it crash\n<124> \n<125> when does. Using empty_slot instead of aliasing can help with\n<126> \n<127> debugging such accesses */\n<128> \n<129> empty_slot_init(hwdef->iommu_pad_base,hwdef->iommu_pad_len);\n<130> \n<131> }\n<132> \n<133> \n<134> \n<135> espdma = sparc32_dma_init(hwdef->dma_base, slavio_irq[18],\n<136> \n<137> iommu, &espdma_irq, 0);\n<138> \n<139> \n<140> \n<141> ledma = sparc32_dma_init(hwdef->dma_base + 16ULL,\n<142> \n<143> slavio_irq[16], iommu, &ledma_irq, 1);\n<144> \n<145> \n<146> \n<147> if (graphic_depth != 8 && graphic_depth != 24) {\n<148> \n<149> error_report("Unsupported depth: %d", graphic_depth);\n<150> \n<151> exit (1);\n<152> \n<153> }\n<154> \n<155> num_vsimms = 0;\n<156> \n<157> if (num_vsimms == 0) {\n<158> \n<159> if (vga_interface_type == VGA_CG3) {\n<160> \n<161> if (graphic_depth != 8) {\n<162> \n<163> error_report("Unsupported depth: %d", graphic_depth);\n<164> \n<165> exit(1);\n<166> \n<167> }\n<168> \n<169> \n<170> \n<171> if (!(graphic_width == 1024 && graphic_height == 768) &&\n<172> \n<173> !(graphic_width == 1152 && graphic_height == 900)) {\n<174> \n<175> error_report("Unsupported resolution: %d x %d", graphic_width,\n<176> \n<177> graphic_height);\n<178> \n<179> exit(1);\n<180> \n<181> }\n<182> \n<183> \n<184> \n<185> /* sbus irq 5 */\n<186> \n<187> cg3_init(hwdef->tcx_base, slavio_irq[11], 0x00100000,\n<188> \n<189> graphic_width, graphic_height, graphic_depth);\n<190> \n<191> } else {\n<192> \n<193> /* If no display specified, default to TCX */\n<194> \n<195> if (graphic_depth != 8 && graphic_depth != 24) {\n<196> \n<197> error_report("Unsupported depth: %d", graphic_depth);\n<198> \n<199> exit(1);\n<200> \n<201> }\n<202> \n<203> \n<204> \n<205> if (!(graphic_width == 1024 && graphic_height == 768)) {\n<206> \n<207> error_report("Unsupported resolution: %d x %d",\n<208> \n<209> graphic_width, graphic_height);\n<210> \n<211> exit(1);\n<212> \n<213> }\n<214> \n<215> \n<216> \n<217> tcx_init(hwdef->tcx_base, slavio_irq[11], 0x00100000,\n<218> \n<219> graphic_width, graphic_height, graphic_depth);\n<220> \n<221> }\n<222> \n<223> }\n<224> \n<225> \n<226> \n<227> for (i = num_vsimms; i < MAX_VSIMMS; i++) {\n<228> \n<229> /* vsimm registers probed by OBP */\n<230> \n<231> if (hwdef->vsimm[i].reg_base) {\n<232> \n<233> empty_slot_init(hwdef->vsimm[i].reg_base, 0x2000);\n<234> \n<235> }\n<236> \n<237> }\n<238> \n<239> \n<240> \n<241> if (hwdef->sx_base) {\n<242> \n<243> empty_slot_init(hwdef->sx_base, 0x2000);\n<244> \n<245> }\n<246> \n<247> \n<248> \n<249> lance_init(&nd_table[0], hwdef->le_base, ledma, ledma_irq);\n<250> \n<251> \n<252> \n<253> nvram = m48t59_init(slavio_irq[0], hwdef->nvram_base, 0, 0x2000, 1968, 8);\n<254> \n<255> \n<256> \n<257> slavio_timer_init_all(hwdef->counter_base, slavio_irq[19], slavio_cpu_irq, smp_cpus);\n<258> \n<259> \n<260> \n<261> slavio_serial_ms_kbd_init(hwdef->ms_kb_base, slavio_irq[14],\n<262> \n<263> display_type == DT_NOGRAPHIC, ESCC_CLOCK, 1);\n<264> \n<265> /* Slavio TTYA (base+4, Linux ttyS0) is the first QEMU serial device\n<266> \n<267> Slavio TTYB (base+0, Linux ttyS1) is the second QEMU serial device */\n<268> \n<269> escc_init(hwdef->serial_base, slavio_irq[15], slavio_irq[15],\n<270> \n<271> serial_hds[0], serial_hds[1], ESCC_CLOCK, 1);\n<272> \n<273> \n<274> \n<275> cpu_halt = qemu_allocate_irqs(cpu_halt_signal, NULL, 1);\n<276> \n<277> if (hwdef->apc_base) {\n<278> \n<279> apc_init(hwdef->apc_base, cpu_halt[0]);\n<280> \n<281> }\n<282> \n<283> \n<284> \n<285> if (hwdef->fd_base) {\n<286> \n<287> /* there is zero or one floppy drive */\n<288> \n<289> memset(fd, 0, sizeof(fd));\n<290> \n<291> fd[0] = drive_get(IF_FLOPPY, 0, 0);\n<292> \n<293> sun4m_fdctrl_init(slavio_irq[22], hwdef->fd_base, fd,\n<294> \n<295> &fdc_tc);\n<296> \n<297> } else {\n<298> \n<299> fdc_tc = *qemu_allocate_irqs(dummy_fdc_tc, NULL, 1);\n<300> \n<301> }\n<302> \n<303> \n<304> \n<305> slavio_misc_init(hwdef->slavio_base, hwdef->aux1_base, hwdef->aux2_base,\n<306> \n<307> slavio_irq[30], fdc_tc);\n<308> \n<309> \n<310> \n<311> if (drive_get_max_bus(IF_SCSI) > 0) {\n<312> \n<313> fprintf(stderr, "qemu: too many SCSI bus\n");\n<314> \n<315> exit(1);\n<316> \n<317> }\n<318> \n<319> \n<320> \n<321> esp_init(hwdef->esp_base, 2,\n<322> \n<323> espdma_memory_read, espdma_memory_write,\n<324> \n<325> espdma, espdma_irq, &esp_reset, &dma_enable);\n<326> \n<327> \n<328> \n<329> qdev_connect_gpio_out(espdma, 0, esp_reset);\n<330> \n<331> qdev_connect_gpio_out(espdma, 1, dma_enable);\n<332> \n<333> \n<334> \n<335> if (hwdef->cs_base) {\n<336> \n<337> sysbus_create_simple("SUNW,CS4231", hwdef->cs_base,\n<338> \n<339> slavio_irq[5]);\n<340> \n<341> }\n<342> \n<343> \n<344> \n<345> if (hwdef->dbri_base) {\n<346> \n<347> /* ISDN chip with attached CS4215 audio codec */\n<348> \n<349> /* prom space */\n<350> \n<351> empty_slot_init(hwdef->dbri_base+0x1000, 0x30);\n<352> \n<353> /* reg space */\n<354> \n<355> empty_slot_init(hwdef->dbri_base+0x10000, 0x100);\n<356> \n<357> }\n<358> \n<359> \n<360> \n<361> if (hwdef->bpp_base) {\n<362> \n<363> /* parallel port */\n<364> \n<365> empty_slot_init(hwdef->bpp_base, 0x20);\n<366> \n<367> }\n<368> \n<369> \n<370> \n<371> kernel_size = sun4m_load_kernel(machine->kernel_filename,\n<372> \n<373> machine->initrd_filename,\n<374> \n<375> machine->ram_size);\n<376> \n<377> \n<378> \n<379> nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, machine->kernel_cmdline,\n<380> \n<381> machine->boot_order, machine->ram_size, kernel_size,\n<382> \n<383> graphic_width, graphic_height, graphic_depth,\n<384> \n<385> hwdef->nvram_machine_id, "Sun4m");\n<386> \n<387> \n<388> \n<389> if (hwdef->ecc_base)\n<390> \n<391> ecc_init(hwdef->ecc_base, slavio_irq[28],\n<392> \n<393> hwdef->ecc_version);\n<394> \n<395> \n<396> \n<397> fw_cfg = fw_cfg_init_mem(CFG_ADDR, CFG_ADDR + 2);\n<398> \n<399> fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n<400> \n<401> fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n<402> \n<403> fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n<404> \n<405> fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n<406> \n<407> fw_cfg_add_i16(fw_cfg, FW_CFG_SUN4M_DEPTH, graphic_depth);\n<408> \n<409> fw_cfg_add_i16(fw_cfg, FW_CFG_SUN4M_WIDTH, graphic_width);\n<410> \n<411> fw_cfg_add_i16(fw_cfg, FW_CFG_SUN4M_HEIGHT, graphic_height);\n<412> \n<413> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n<414> \n<415> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n<416> \n<417> if (machine->kernel_cmdline) {\n<418> \n<419> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n<420> \n<421> pstrcpy_targphys("cmdline", CMDLINE_ADDR, TARGET_PAGE_SIZE,\n<422> \n<423> machine->kernel_cmdline);\n<424> \n<425> fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);\n<426> \n<427> fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,\n<428> \n<429> strlen(machine->kernel_cmdline) + 1);\n<430> \n<431> } else {\n<432> \n<433> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n<434> \n<435> fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, 0);\n<436> \n<437> }\n<438> \n<439> fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n<440> \n<441> fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, 0); // not used\n<442> \n<443> fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, machine->boot_order[0]);\n<444> \n<445> qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n<446> \n<447> }\n<448> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_h264_decode_ref_pic_marking(H264Context *h, GetBitContext *gb,\n<2> \n<3> int first_slice)\n<4> \n<5> {\n<6> \n<7> int i, ret;\n<8> \n<9> MMCO mmco_temp[MAX_MMCO_COUNT], *mmco = mmco_temp;\n<10> \n<11> int mmco_index = 0;\n<12> \n<13> \n<14> \n<15> if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields\n<16> \n<17> skip_bits1(gb); // broken_link\n<18> \n<19> if (get_bits1(gb)) {\n<20> \n<21> mmco[0].opcode   = MMCO_LONG;\n<22> \n<23> mmco[0].long_arg = 0;\n<24> \n<25> mmco_index       = 1;\n<26> \n<27> }\n<28> \n<29> } else {\n<30> \n<31> if (get_bits1(gb)) { // adaptive_ref_pic_marking_mode_flag\n<32> \n<33> for (i = 0; i < MAX_MMCO_COUNT; i++) {\n<34> \n<35> MMCOOpcode opcode = get_ue_golomb_31(gb);\n<36> \n<37> \n<38> \n<39> mmco[i].opcode = opcode;\n<40> \n<41> if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {\n<42> \n<43> mmco[i].short_pic_num =\n<44> \n<45> (h->curr_pic_num - get_ue_golomb(gb) - 1) &\n<46> \n<47> (h->max_pic_num - 1);\n<48> \n<49> #if 0\n<50> \n<51> if (mmco[i].short_pic_num >= h->short_ref_count ||\n<52> \n<53> !h->short_ref[mmco[i].short_pic_num]) {\n<54> \n<55> av_log(s->avctx, AV_LOG_ERROR,\n<56> \n<57> "illegal short ref in memory management control "\n<58> \n<59> "operation %d\n", mmco);\n<60> \n<61> return -1;\n<62> \n<63> }\n<64> \n<65> #endif\n<66> \n<67> }\n<68> \n<69> if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||\n<70> \n<71> opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {\n<72> \n<73> unsigned int long_arg = get_ue_golomb_31(gb);\n<74> \n<75> if (long_arg >= 32 ||\n<76> \n<77> (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&\n<78> \n<79> long_arg == 16) &&\n<80> \n<81> !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {\n<82> \n<83> av_log(h->avctx, AV_LOG_ERROR,\n<84> \n<85> "illegal long ref in memory management control "\n<86> \n<87> "operation %d\n", opcode);\n<88> \n<89> return -1;\n<90> \n<91> }\n<92> \n<93> mmco[i].long_arg = long_arg;\n<94> \n<95> }\n<96> \n<97> \n<98> \n<99> if (opcode > (unsigned) MMCO_LONG) {\n<100> \n<101> av_log(h->avctx, AV_LOG_ERROR,\n<102> \n<103> "illegal memory management control operation %d\n",\n<104> \n<105> opcode);\n<106> \n<107> return -1;\n<108> \n<109> }\n<110> \n<111> if (opcode == MMCO_END)\n<112> \n<113> break;\n<114> \n<115> }\n<116> \n<117> mmco_index = i;\n<118> \n<119> } else {\n<120> \n<121> if (first_slice) {\n<122> \n<123> ret = ff_generate_sliding_window_mmcos(h, first_slice);\n<124> \n<125> if (ret < 0 && h->avctx->err_recognition & AV_EF_EXPLODE)\n<126> \n<127> return ret;\n<128> \n<129> }\n<130> \n<131> mmco_index = -1;\n<132> \n<133> }\n<134> \n<135> }\n<136> \n<137> \n<138> \n<139> if (first_slice && mmco_index != -1) {\n<140> \n<141> memcpy(h->mmco, mmco_temp, sizeof(h->mmco));\n<142> \n<143> h->mmco_index = mmco_index;\n<144> \n<145> } else if (!first_slice && mmco_index >= 0 &&\n<146> \n<147> (mmco_index != h->mmco_index ||\n<148> \n<149> check_opcodes(h->mmco, mmco_temp, mmco_index))) {\n<150> \n<151> av_log(h->avctx, AV_LOG_ERROR,\n<152> \n<153> "Inconsistent MMCO state between slices [%d, %d]\n",\n<154> \n<155> mmco_index, h->mmco_index);\n<156> \n<157> return AVERROR_INVALIDDATA;\n<158> \n<159> }\n<160> \n<161> \n<162> \n<163> return 0;\n<164> \n<165> }\n<166> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void avcodec_get_context_defaults2(AVCodecContext *s, enum AVMediaType codec_type){\n<2> \n<3> int flags=0;\n<4> \n<5> memset(s, 0, sizeof(AVCodecContext));\n<6> \n<7> \n<8> \n<9> s->av_class= &av_codec_context_class;\n<10> \n<11> \n<12> \n<13> s->codec_type = codec_type;\n<14> \n<15> if(codec_type == AVMEDIA_TYPE_AUDIO)\n<16> \n<17> flags= AV_OPT_FLAG_AUDIO_PARAM;\n<18> \n<19> else if(codec_type == AVMEDIA_TYPE_VIDEO)\n<20> \n<21> flags= AV_OPT_FLAG_VIDEO_PARAM;\n<22> \n<23> else if(codec_type == AVMEDIA_TYPE_SUBTITLE)\n<24> \n<25> flags= AV_OPT_FLAG_SUBTITLE_PARAM;\n<26> \n<27> av_opt_set_defaults2(s, flags, flags);\n<28> \n<29> \n<30> \n<31> s->time_base= (AVRational){0,1};\n<32> \n<33> s->get_buffer= avcodec_default_get_buffer;\n<34> \n<35> s->release_buffer= avcodec_default_release_buffer;\n<36> \n<37> s->get_format= avcodec_default_get_format;\n<38> \n<39> s->execute= avcodec_default_execute;\n<40> \n<41> s->execute2= avcodec_default_execute2;\n<42> \n<43> s->sample_aspect_ratio= (AVRational){0,1};\n<44> \n<45> s->pix_fmt= PIX_FMT_NONE;\n<46> \n<47> s->sample_fmt= AV_SAMPLE_FMT_NONE;\n<48> \n<49> \n<50> \n<51> s->palctrl = NULL;\n<52> \n<53> s->reget_buffer= avcodec_default_reget_buffer;\n<54> \n<55> s->reordered_opaque= AV_NOPTS_VALUE;\n<56> \n<57> }\n<58> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline void mix_stereo_to_mono(AC3DecodeContext *ctx)\n<2> \n<3> {\n<4> \n<5> int i;\n<6> \n<7> float (*output)[256] = ctx->audio_block.block_output;\n<8> \n<9> \n<10> \n<11> for (i = 0; i < 256; i++)\n<12> \n<13> output[1][i] += output[2][i];\n<14> \n<15> memset(output[2], 0, sizeof(output[2]));\n<16> \n<17> }\n<18> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void simplestring_addn ( simplestring * target , const char * source , int add_len ) {\n<2> if ( target && source ) {\n<3> if ( ! target -> str ) {\n<4> simplestring_init_str ( target ) ;\n<5> }\n<6> if ( target -> len + add_len + 1 > target -> size ) {\n<7> int newsize = target -> len + add_len + 1 ;\n<8> int incr = target -> size * 2 ;\n<9> newsize = newsize - ( newsize % incr ) + incr ;\n<10> target -> str = ( char * ) realloc ( target -> str , newsize ) ;\n<11> target -> size = target -> str ? newsize : 0 ;\n<12> }\n<13> if ( target -> str ) {\n<14> if ( add_len ) {\n<15> memcpy ( target -> str + target -> len , source , add_len ) ;\n<16> }\n<17> target -> len += add_len ;\n<18> target -> str [ target -> len ] = 0 ;\n<19> }\n<20> }\n<21> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void kvm_s390_interrupt_internal(S390CPU *cpu, int type, uint32_t parm,\n<2> \n<3> uint64_t parm64, int vm)\n<4> \n<5> {\n<6> \n<7> CPUState *cs = CPU(cpu);\n<8> \n<9> struct kvm_s390_interrupt kvmint;\n<10> \n<11> int r;\n<12> \n<13> \n<14> \n<15> if (!cs->kvm_state) {\n<16> \n<17> return;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> kvmint.type = type;\n<24> \n<25> kvmint.parm = parm;\n<26> \n<27> kvmint.parm64 = parm64;\n<28> \n<29> \n<30> \n<31> if (vm) {\n<32> \n<33> r = kvm_vm_ioctl(cs->kvm_state, KVM_S390_INTERRUPT, &kvmint);\n<34> \n<35> } else {\n<36> \n<37> r = kvm_vcpu_ioctl(cs, KVM_S390_INTERRUPT, &kvmint);\n<38> \n<39> }\n<40> \n<41> \n<42> \n<43> if (r < 0) {\n<44> \n<45> fprintf(stderr, "KVM failed to inject interrupt\n");\n<46> \n<47> exit(1);\n<48> \n<49> }\n<50> \n<51> }\n<52> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int serial_parse(const char *devname)\n<2> \n<3> {\n<4> \n<5> static int index = 0;\n<6> \n<7> char label[32];\n<8> \n<9> \n<10> \n<11> if (strcmp(devname, "none") == 0)\n<12> \n<13> return 0;\n<14> \n<15> if (index == MAX_SERIAL_PORTS) {\n<16> \n<17> fprintf(stderr, "qemu: too many serial ports\n");\n<18> \n<19> exit(1);\n<20> \n<21> }\n<22> \n<23> snprintf(label, sizeof(label), "serial%d", index);\n<24> \n<25> serial_hds[index] = qemu_chr_new(label, devname, NULL);\n<26> \n<27> if (!serial_hds[index]) {\n<28> \n<29> fprintf(stderr, "qemu: could not connect serial device"\n<30> \n<31> " to character backend '%s'\n", devname);\n<32> \n<33> return -1;\n<34> \n<35> }\n<36> \n<37> index++;\n<38> \n<39> return 0;\n<40> \n<41> }\n<42> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int cpu_x86_find_by_name(x86_def_t *x86_cpu_def, const char *cpu_model)\n<2> \n<3> {\n<4> \n<5> unsigned int i;\n<6> \n<7> x86_def_t *def;\n<8> \n<9> \n<10> \n<11> char *s = strdup(cpu_model);\n<12> \n<13> char *featurestr, *name = strtok(s, ",");\n<14> \n<15> uint32_t plus_features = 0, plus_ext_features = 0, plus_ext2_features = 0, plus_ext3_features = 0;\n<16> \n<17> uint32_t minus_features = 0, minus_ext_features = 0, minus_ext2_features = 0, minus_ext3_features = 0;\n<18> \n<19> int family = -1, model = -1, stepping = -1;\n<20> \n<21> \n<22> \n<23> def = NULL;\n<24> \n<25> for (i = 0; i < ARRAY_SIZE(x86_defs); i++) {\n<26> \n<27> if (strcmp(name, x86_defs[i].name) == 0) {\n<28> \n<29> def = &x86_defs[i];\n<30> \n<31> break;\n<32> \n<33> }\n<34> \n<35> }\n<36> \n<37> if (kvm_enabled() && strcmp(name, "host") == 0) {\n<38> \n<39> cpu_x86_fill_host(x86_cpu_def);\n<40> \n<41> } else if (!def) {\n<42> \n<43> goto error;\n<44> \n<45> } else {\n<46> \n<47> memcpy(x86_cpu_def, def, sizeof(*def));\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> add_flagname_to_bitmaps("hypervisor", &plus_features,\n<54> \n<55> &plus_ext_features, &plus_ext2_features, &plus_ext3_features);\n<56> \n<57> \n<58> \n<59> featurestr = strtok(NULL, ",");\n<60> \n<61> \n<62> \n<63> while (featurestr) {\n<64> \n<65> char *val;\n<66> \n<67> if (featurestr[0] == '+') {\n<68> \n<69> add_flagname_to_bitmaps(featurestr + 1, &plus_features, &plus_ext_features, &plus_ext2_features, &plus_ext3_features);\n<70> \n<71> } else if (featurestr[0] == '-') {\n<72> \n<73> add_flagname_to_bitmaps(featurestr + 1, &minus_features, &minus_ext_features, &minus_ext2_features, &minus_ext3_features);\n<74> \n<75> } else if ((val = strchr(featurestr, '='))) {\n<76> \n<77> *val = 0; val++;\n<78> \n<79> if (!strcmp(featurestr, "family")) {\n<80> \n<81> char *err;\n<82> \n<83> family = strtol(val, &err, 10);\n<84> \n<85> if (!*val || *err || family < 0) {\n<86> \n<87> fprintf(stderr, "bad numerical value %s\n", val);\n<88> \n<89> goto error;\n<90> \n<91> }\n<92> \n<93> x86_cpu_def->family = family;\n<94> \n<95> } else if (!strcmp(featurestr, "model")) {\n<96> \n<97> char *err;\n<98> \n<99> model = strtol(val, &err, 10);\n<100> \n<101> if (!*val || *err || model < 0 || model > 0xff) {\n<102> \n<103> fprintf(stderr, "bad numerical value %s\n", val);\n<104> \n<105> goto error;\n<106> \n<107> }\n<108> \n<109> x86_cpu_def->model = model;\n<110> \n<111> } else if (!strcmp(featurestr, "stepping")) {\n<112> \n<113> char *err;\n<114> \n<115> stepping = strtol(val, &err, 10);\n<116> \n<117> if (!*val || *err || stepping < 0 || stepping > 0xf) {\n<118> \n<119> fprintf(stderr, "bad numerical value %s\n", val);\n<120> \n<121> goto error;\n<122> \n<123> }\n<124> \n<125> x86_cpu_def->stepping = stepping;\n<126> \n<127> } else if (!strcmp(featurestr, "vendor")) {\n<128> \n<129> if (strlen(val) != 12) {\n<130> \n<131> fprintf(stderr, "vendor string must be 12 chars long\n");\n<132> \n<133> goto error;\n<134> \n<135> }\n<136> \n<137> x86_cpu_def->vendor1 = 0;\n<138> \n<139> x86_cpu_def->vendor2 = 0;\n<140> \n<141> x86_cpu_def->vendor3 = 0;\n<142> \n<143> for(i = 0; i < 4; i++) {\n<144> \n<145> x86_cpu_def->vendor1 |= ((uint8_t)val[i    ]) << (8 * i);\n<146> \n<147> x86_cpu_def->vendor2 |= ((uint8_t)val[i + 4]) << (8 * i);\n<148> \n<149> x86_cpu_def->vendor3 |= ((uint8_t)val[i + 8]) << (8 * i);\n<150> \n<151> }\n<152> \n<153> x86_cpu_def->vendor_override = 1;\n<154> \n<155> } else if (!strcmp(featurestr, "model_id")) {\n<156> \n<157> pstrcpy(x86_cpu_def->model_id, sizeof(x86_cpu_def->model_id),\n<158> \n<159> val);\n<160> \n<161> } else {\n<162> \n<163> fprintf(stderr, "unrecognized feature %s\n", featurestr);\n<164> \n<165> goto error;\n<166> \n<167> }\n<168> \n<169> } else {\n<170> \n<171> fprintf(stderr, "feature string `%s' not in format (+feature|-feature|feature=xyz)\n", featurestr);\n<172> \n<173> goto error;\n<174> \n<175> }\n<176> \n<177> featurestr = strtok(NULL, ",");\n<178> \n<179> }\n<180> \n<181> x86_cpu_def->features |= plus_features;\n<182> \n<183> x86_cpu_def->ext_features |= plus_ext_features;\n<184> \n<185> x86_cpu_def->ext2_features |= plus_ext2_features;\n<186> \n<187> x86_cpu_def->ext3_features |= plus_ext3_features;\n<188> \n<189> x86_cpu_def->features &= ~minus_features;\n<190> \n<191> x86_cpu_def->ext_features &= ~minus_ext_features;\n<192> \n<193> x86_cpu_def->ext2_features &= ~minus_ext2_features;\n<194> \n<195> x86_cpu_def->ext3_features &= ~minus_ext3_features;\n<196> \n<197> free(s);\n<198> \n<199> return 0;\n<200> \n<201> \n<202> \n<203> error:\n<204> \n<205> free(s);\n<206> \n<207> return -1;\n<208> \n<209> }\n<210> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void decode_vui(HEVCContext *s, HEVCSPS *sps)\n<2> \n<3> {\n<4> \n<5> VUI *vui          = &sps->vui;\n<6> \n<7> GetBitContext *gb = &s->HEVClc->gb;\n<8> \n<9> GetBitContext backup;\n<10> \n<11> int sar_present, alt = 0;\n<12> \n<13> \n<14> \n<15> av_log(s->avctx, AV_LOG_DEBUG, "Decoding VUI\n");\n<16> \n<17> \n<18> \n<19> sar_present = get_bits1(gb);\n<20> \n<21> if (sar_present) {\n<22> \n<23> uint8_t sar_idx = get_bits(gb, 8);\n<24> \n<25> if (sar_idx < FF_ARRAY_ELEMS(vui_sar))\n<26> \n<27> vui->sar = vui_sar[sar_idx];\n<28> \n<29> else if (sar_idx == 255) {\n<30> \n<31> vui->sar.num = get_bits(gb, 16);\n<32> \n<33> vui->sar.den = get_bits(gb, 16);\n<34> \n<35> } else\n<36> \n<37> av_log(s->avctx, AV_LOG_WARNING,\n<38> \n<39> "Unknown SAR index: %u.\n", sar_idx);\n<40> \n<41> }\n<42> \n<43> \n<44> \n<45> vui->overscan_info_present_flag = get_bits1(gb);\n<46> \n<47> if (vui->overscan_info_present_flag)\n<48> \n<49> vui->overscan_appropriate_flag = get_bits1(gb);\n<50> \n<51> \n<52> \n<53> vui->video_signal_type_present_flag = get_bits1(gb);\n<54> \n<55> if (vui->video_signal_type_present_flag) {\n<56> \n<57> vui->video_format                    = get_bits(gb, 3);\n<58> \n<59> vui->video_full_range_flag           = get_bits1(gb);\n<60> \n<61> vui->colour_description_present_flag = get_bits1(gb);\n<62> \n<63> if (vui->video_full_range_flag && sps->pix_fmt == AV_PIX_FMT_YUV420P)\n<64> \n<65> sps->pix_fmt = AV_PIX_FMT_YUVJ420P;\n<66> \n<67> if (vui->colour_description_present_flag) {\n<68> \n<69> vui->colour_primaries        = get_bits(gb, 8);\n<70> \n<71> vui->transfer_characteristic = get_bits(gb, 8);\n<72> \n<73> vui->matrix_coeffs           = get_bits(gb, 8);\n<74> \n<75> \n<76> \n<77> // Set invalid values to "unspecified"\n<78> \n<79> if (vui->colour_primaries >= AVCOL_PRI_NB)\n<80> \n<81> vui->colour_primaries = AVCOL_PRI_UNSPECIFIED;\n<82> \n<83> if (vui->transfer_characteristic >= AVCOL_TRC_NB)\n<84> \n<85> vui->transfer_characteristic = AVCOL_TRC_UNSPECIFIED;\n<86> \n<87> if (vui->matrix_coeffs >= AVCOL_SPC_NB)\n<88> \n<89> vui->matrix_coeffs = AVCOL_SPC_UNSPECIFIED;\n<90> \n<91> }\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> vui->chroma_loc_info_present_flag = get_bits1(gb);\n<98> \n<99> if (vui->chroma_loc_info_present_flag) {\n<100> \n<101> vui->chroma_sample_loc_type_top_field    = get_ue_golomb_long(gb);\n<102> \n<103> vui->chroma_sample_loc_type_bottom_field = get_ue_golomb_long(gb);\n<104> \n<105> }\n<106> \n<107> \n<108> \n<109> vui->neutra_chroma_indication_flag = get_bits1(gb);\n<110> \n<111> vui->field_seq_flag                = get_bits1(gb);\n<112> \n<113> vui->frame_field_info_present_flag = get_bits1(gb);\n<114> \n<115> \n<116> \n<117> vui->default_display_window_flag = get_bits1(gb);\n<118> \n<119> // Backup context in case an alternate header is detected\n<120> \n<121> if( get_bits_left(gb) >= 66)\n<122> \n<123> memcpy(&backup, gb, sizeof(backup));\n<124> \n<125> \n<126> \n<127> if (vui->default_display_window_flag) {\n<128> \n<129> //TODO: * 2 is only valid for 420\n<130> \n<131> vui->def_disp_win.left_offset   = get_ue_golomb_long(gb) * 2;\n<132> \n<133> vui->def_disp_win.right_offset  = get_ue_golomb_long(gb) * 2;\n<134> \n<135> vui->def_disp_win.top_offset    = get_ue_golomb_long(gb) * 2;\n<136> \n<137> vui->def_disp_win.bottom_offset = get_ue_golomb_long(gb) * 2;\n<138> \n<139> \n<140> \n<141> if (s->apply_defdispwin &&\n<142> \n<143> s->avctx->flags2 & CODEC_FLAG2_IGNORE_CROP) {\n<144> \n<145> av_log(s->avctx, AV_LOG_DEBUG,\n<146> \n<147> "discarding vui default display window, "\n<148> \n<149> "original values are l:%u r:%u t:%u b:%u\n",\n<150> \n<151> vui->def_disp_win.left_offset,\n<152> \n<153> vui->def_disp_win.right_offset,\n<154> \n<155> vui->def_disp_win.top_offset,\n<156> \n<157> vui->def_disp_win.bottom_offset);\n<158> \n<159> \n<160> \n<161> vui->def_disp_win.left_offset   =\n<162> \n<163> vui->def_disp_win.right_offset  =\n<164> \n<165> vui->def_disp_win.top_offset    =\n<166> \n<167> vui->def_disp_win.bottom_offset = 0;\n<168> \n<169> }\n<170> \n<171> }\n<172> \n<173> \n<174> \n<175> vui->vui_timing_info_present_flag = get_bits1(gb);\n<176> \n<177> \n<178> \n<179> if (vui->vui_timing_info_present_flag) {\n<180> \n<181> if( get_bits_left(gb) < 66) {\n<182> \n<183> // The alternate syntax seem to have timing info located\n<184> \n<185> // at where def_disp_win is normally located\n<186> \n<187> av_log(s->avctx, AV_LOG_WARNING,\n<188> \n<189> "Strange VUI timing information, retrying...\n");\n<190> \n<191> vui->default_display_window_flag = 0;\n<192> \n<193> memset(&vui->def_disp_win, 0, sizeof(vui->def_disp_win));\n<194> \n<195> memcpy(gb, &backup, sizeof(backup));\n<196> \n<197> alt = 1;\n<198> \n<199> }\n<200> \n<201> vui->vui_num_units_in_tick               = get_bits_long(gb, 32);\n<202> \n<203> vui->vui_time_scale                      = get_bits_long(gb, 32);\n<204> \n<205> if (alt) {\n<206> \n<207> av_log(s->avctx, AV_LOG_INFO, "Retry got %i/%i fps\n",\n<208> \n<209> vui->vui_time_scale, vui->vui_num_units_in_tick);\n<210> \n<211> }\n<212> \n<213> vui->vui_poc_proportional_to_timing_flag = get_bits1(gb);\n<214> \n<215> if (vui->vui_poc_proportional_to_timing_flag)\n<216> \n<217> vui->vui_num_ticks_poc_diff_one_minus1 = get_ue_golomb_long(gb);\n<218> \n<219> vui->vui_hrd_parameters_present_flag = get_bits1(gb);\n<220> \n<221> if (vui->vui_hrd_parameters_present_flag)\n<222> \n<223> decode_hrd(s, 1, sps->max_sub_layers);\n<224> \n<225> }\n<226> \n<227> \n<228> \n<229> vui->bitstream_restriction_flag = get_bits1(gb);\n<230> \n<231> if (vui->bitstream_restriction_flag) {\n<232> \n<233> vui->tiles_fixed_structure_flag              = get_bits1(gb);\n<234> \n<235> vui->motion_vectors_over_pic_boundaries_flag = get_bits1(gb);\n<236> \n<237> vui->restricted_ref_pic_lists_flag           = get_bits1(gb);\n<238> \n<239> vui->min_spatial_segmentation_idc            = get_ue_golomb_long(gb);\n<240> \n<241> vui->max_bytes_per_pic_denom                 = get_ue_golomb_long(gb);\n<242> \n<243> vui->max_bits_per_min_cu_denom               = get_ue_golomb_long(gb);\n<244> \n<245> vui->log2_max_mv_length_horizontal           = get_ue_golomb_long(gb);\n<246> \n<247> vui->log2_max_mv_length_vertical             = get_ue_golomb_long(gb);\n<248> \n<249> }\n<250> \n<251> }\n<252> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void cpu_physical_memory_write_rom(hwaddr addr,\n<2> \n<3> const uint8_t *buf, int len)\n<4> \n<5> {\n<6> \n<7> hwaddr l;\n<8> \n<9> uint8_t *ptr;\n<10> \n<11> hwaddr addr1;\n<12> \n<13> MemoryRegion *mr;\n<14> \n<15> \n<16> \n<17> while (len > 0) {\n<18> \n<19> l = len;\n<20> \n<21> mr = address_space_translate(&address_space_memory,\n<22> \n<23> addr, &addr1, &l, true);\n<24> \n<25> \n<26> \n<27> if (!(memory_region_is_ram(mr) ||\n<28> \n<29> memory_region_is_romd(mr))) {\n<30> \n<31> /* do nothing */\n<32> \n<33> } else {\n<34> \n<35> addr1 += memory_region_get_ram_addr(mr);\n<36> \n<37> /* ROM/RAM case */\n<38> \n<39> ptr = qemu_get_ram_ptr(addr1);\n<40> \n<41> memcpy(ptr, buf, l);\n<42> \n<43> invalidate_and_set_dirty(addr1, l);\n<44> \n<45> }\n<46> \n<47> len -= l;\n<48> \n<49> buf += l;\n<50> \n<51> addr += l;\n<52> \n<53> }\n<54> \n<55> }\n<56> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int spapr_vga_init(PCIBus *pci_bus)\n<2> \n<3> {\n<4> \n<5> switch (vga_interface_type) {\n<6> \n<7> case VGA_STD:\n<8> \n<9> pci_std_vga_init(pci_bus);\n<10> \n<11> return 1;\n<12> \n<13> case VGA_NONE:\n<14> \n<15> return 0;\n<16> \n<17> default:\n<18> \n<19> fprintf(stderr, "This vga model is not supported,"\n<20> \n<21> "currently it only supports -vga std\n");\n<22> \n<23> exit(0);\n<24> \n<25> break;\n<26> \n<27> }\n<28> \n<29> }\n<30> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void ide_init_drive(IDEState *s, DriveInfo *dinfo,\n<2> \n<3> const char *version, const char *serial)\n<4> \n<5> {\n<6> \n<7> int cylinders, heads, secs;\n<8> \n<9> uint64_t nb_sectors;\n<10> \n<11> \n<12> \n<13> s->bs = dinfo->bdrv;\n<14> \n<15> bdrv_get_geometry(s->bs, &nb_sectors);\n<16> \n<17> bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n<18> \n<19> s->cylinders = cylinders;\n<20> \n<21> s->heads = heads;\n<22> \n<23> s->sectors = secs;\n<24> \n<25> s->nb_sectors = nb_sectors;\n<26> \n<27> /* The SMART values should be preserved across power cycles\n<28> \n<29> but they aren't.  */\n<30> \n<31> s->smart_enabled = 1;\n<32> \n<33> s->smart_autosave = 1;\n<34> \n<35> s->smart_errors = 0;\n<36> \n<37> s->smart_selftest_count = 0;\n<38> \n<39> if (bdrv_get_type_hint(s->bs) == BDRV_TYPE_CDROM) {\n<40> \n<41> s->is_cdrom = 1;\n<42> \n<43> bdrv_set_change_cb(s->bs, cdrom_change_cb, s);\n<44> \n<45> }\n<46> \n<47> if (serial && *serial) {\n<48> \n<49> strncpy(s->drive_serial_str, serial, sizeof(s->drive_serial_str));\n<50> \n<51> } else {\n<52> \n<53> snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n<54> \n<55> "QM%05d", s->drive_serial);\n<56> \n<57> }\n<58> \n<59> if (version) {\n<60> \n<61> pstrcpy(s->version, sizeof(s->version), version);\n<62> \n<63> } else {\n<64> \n<65> pstrcpy(s->version, sizeof(s->version), QEMU_VERSION);\n<66> \n<67> }\n<68> \n<69> ide_reset(s);\n<70> \n<71> }\n<72> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int create_header64(DumpState *s)\n<2> \n<3> {\n<4> \n<5> int ret = 0;\n<6> \n<7> DiskDumpHeader64 *dh = NULL;\n<8> \n<9> KdumpSubHeader64 *kh = NULL;\n<10> \n<11> size_t size;\n<12> \n<13> int endian = s->dump_info.d_endian;\n<14> \n<15> uint32_t block_size;\n<16> \n<17> uint32_t sub_hdr_size;\n<18> \n<19> uint32_t bitmap_blocks;\n<20> \n<21> uint32_t status = 0;\n<22> \n<23> uint64_t offset_note;\n<24> \n<25> \n<26> \n<27> /* write common header, the version of kdump-compressed format is 6th */\n<28> \n<29> size = sizeof(DiskDumpHeader64);\n<30> \n<31> dh = g_malloc0(size);\n<32> \n<33> \n<34> \n<35> strncpy(dh->signature, KDUMP_SIGNATURE, strlen(KDUMP_SIGNATURE));\n<36> \n<37> dh->header_version = cpu_convert_to_target32(6, endian);\n<38> \n<39> block_size = s->page_size;\n<40> \n<41> dh->block_size = cpu_convert_to_target32(block_size, endian);\n<42> \n<43> sub_hdr_size = sizeof(struct KdumpSubHeader64) + s->note_size;\n<44> \n<45> sub_hdr_size = DIV_ROUND_UP(sub_hdr_size, block_size);\n<46> \n<47> dh->sub_hdr_size = cpu_convert_to_target32(sub_hdr_size, endian);\n<48> \n<49> /* dh->max_mapnr may be truncated, full 64bit is in kh.max_mapnr_64 */\n<50> \n<51> dh->max_mapnr = cpu_convert_to_target32(MIN(s->max_mapnr, UINT_MAX),\n<52> \n<53> endian);\n<54> \n<55> dh->nr_cpus = cpu_convert_to_target32(s->nr_cpus, endian);\n<56> \n<57> bitmap_blocks = DIV_ROUND_UP(s->len_dump_bitmap, block_size) * 2;\n<58> \n<59> dh->bitmap_blocks = cpu_convert_to_target32(bitmap_blocks, endian);\n<60> \n<61> strncpy(dh->utsname.machine, ELF_MACHINE_UNAME, sizeof(dh->utsname.machine));\n<62> \n<63> \n<64> \n<65> if (s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) {\n<66> \n<67> status |= DUMP_DH_COMPRESSED_ZLIB;\n<68> \n<69> }\n<70> \n<71> #ifdef CONFIG_LZO\n<72> \n<73> if (s->flag_compress & DUMP_DH_COMPRESSED_LZO) {\n<74> \n<75> status |= DUMP_DH_COMPRESSED_LZO;\n<76> \n<77> }\n<78> \n<79> #endif\n<80> \n<81> #ifdef CONFIG_SNAPPY\n<82> \n<83> if (s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) {\n<84> \n<85> status |= DUMP_DH_COMPRESSED_SNAPPY;\n<86> \n<87> }\n<88> \n<89> #endif\n<90> \n<91> dh->status = cpu_convert_to_target32(status, endian);\n<92> \n<93> \n<94> \n<95> if (write_buffer(s->fd, 0, dh, size) < 0) {\n<96> \n<97> dump_error(s, "dump: failed to write disk dump header.\n");\n<98> \n<99> ret = -1;\n<100> \n<101> goto out;\n<102> \n<103> }\n<104> \n<105> \n<106> \n<107> /* write sub header */\n<108> \n<109> size = sizeof(KdumpSubHeader64);\n<110> \n<111> kh = g_malloc0(size);\n<112> \n<113> \n<114> \n<115> /* 64bit max_mapnr_64 */\n<116> \n<117> kh->max_mapnr_64 = cpu_convert_to_target64(s->max_mapnr, endian);\n<118> \n<119> kh->phys_base = cpu_convert_to_target64(PHYS_BASE, endian);\n<120> \n<121> kh->dump_level = cpu_convert_to_target32(DUMP_LEVEL, endian);\n<122> \n<123> \n<124> \n<125> offset_note = DISKDUMP_HEADER_BLOCKS * block_size + size;\n<126> \n<127> kh->offset_note = cpu_convert_to_target64(offset_note, endian);\n<128> \n<129> kh->note_size = cpu_convert_to_target64(s->note_size, endian);\n<130> \n<131> \n<132> \n<133> if (write_buffer(s->fd, DISKDUMP_HEADER_BLOCKS *\n<134> \n<135> block_size, kh, size) < 0) {\n<136> \n<137> dump_error(s, "dump: failed to write kdump sub header.\n");\n<138> \n<139> ret = -1;\n<140> \n<141> goto out;\n<142> \n<143> }\n<144> \n<145> \n<146> \n<147> /* write note */\n<148> \n<149> s->note_buf = g_malloc0(s->note_size);\n<150> \n<151> s->note_buf_offset = 0;\n<152> \n<153> \n<154> \n<155> /* use s->note_buf to store notes temporarily */\n<156> \n<157> if (write_elf64_notes(buf_write_note, s) < 0) {\n<158> \n<159> ret = -1;\n<160> \n<161> goto out;\n<162> \n<163> }\n<164> \n<165> \n<166> \n<167> if (write_buffer(s->fd, offset_note, s->note_buf,\n<168> \n<169> s->note_size) < 0) {\n<170> \n<171> dump_error(s, "dump: failed to write notes");\n<172> \n<173> ret = -1;\n<174> \n<175> goto out;\n<176> \n<177> }\n<178> \n<179> \n<180> \n<181> /* get offset of dump_bitmap */\n<182> \n<183> s->offset_dump_bitmap = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size) *\n<184> \n<185> block_size;\n<186> \n<187> \n<188> \n<189> /* get offset of page */\n<190> \n<191> s->offset_page = (DISKDUMP_HEADER_BLOCKS + sub_hdr_size + bitmap_blocks) *\n<192> \n<193> block_size;\n<194> \n<195> \n<196> \n<197> out:\n<198> \n<199> g_free(dh);\n<200> \n<201> g_free(kh);\n<202> \n<203> g_free(s->note_buf);\n<204> \n<205> \n<206> \n<207> return ret;\n<208> \n<209> }\n<210> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int net_client_init(Monitor *mon, const char *device, const char *p)\n<2> \n<3> {\n<4> \n<5> static const char * const fd_params[] = {\n<6> \n<7> "vlan", "name", "fd", NULL\n<8> \n<9> };\n<10> \n<11> char buf[1024];\n<12> \n<13> int vlan_id, ret;\n<14> \n<15> VLANState *vlan;\n<16> \n<17> char *name = NULL;\n<18> \n<19> \n<20> \n<21> vlan_id = 0;\n<22> \n<23> if (get_param_value(buf, sizeof(buf), "vlan", p)) {\n<24> \n<25> vlan_id = strtol(buf, NULL, 0);\n<26> \n<27> }\n<28> \n<29> vlan = qemu_find_vlan(vlan_id);\n<30> \n<31> \n<32> \n<33> if (get_param_value(buf, sizeof(buf), "name", p)) {\n<34> \n<35> name = qemu_strdup(buf);\n<36> \n<37> }\n<38> \n<39> if (!strcmp(device, "nic")) {\n<40> \n<41> static const char * const nic_params[] = {\n<42> \n<43> "vlan", "name", "macaddr", "model", "addr", NULL\n<44> \n<45> };\n<46> \n<47> NICInfo *nd;\n<48> \n<49> uint8_t *macaddr;\n<50> \n<51> int idx = nic_get_free_idx();\n<52> \n<53> \n<54> \n<55> if (check_params(buf, sizeof(buf), nic_params, p) < 0) {\n<56> \n<57> config_error(mon, "invalid parameter '%s' in '%s'\n", buf, p);\n<58> \n<59> ret = -1;\n<60> \n<61> goto out;\n<62> \n<63> }\n<64> \n<65> if (idx == -1 || nb_nics >= MAX_NICS) {\n<66> \n<67> config_error(mon, "Too Many NICs\n");\n<68> \n<69> ret = -1;\n<70> \n<71> goto out;\n<72> \n<73> }\n<74> \n<75> nd = &nd_table[idx];\n<76> \n<77> macaddr = nd->macaddr;\n<78> \n<79> macaddr[0] = 0x52;\n<80> \n<81> macaddr[1] = 0x54;\n<82> \n<83> macaddr[2] = 0x00;\n<84> \n<85> macaddr[3] = 0x12;\n<86> \n<87> macaddr[4] = 0x34;\n<88> \n<89> macaddr[5] = 0x56 + idx;\n<90> \n<91> \n<92> \n<93> if (get_param_value(buf, sizeof(buf), "macaddr", p)) {\n<94> \n<95> if (parse_macaddr(macaddr, buf) < 0) {\n<96> \n<97> config_error(mon, "invalid syntax for ethernet address\n");\n<98> \n<99> ret = -1;\n<100> \n<101> goto out;\n<102> \n<103> }\n<104> \n<105> }\n<106> \n<107> if (get_param_value(buf, sizeof(buf), "model", p)) {\n<108> \n<109> nd->model = strdup(buf);\n<110> \n<111> }\n<112> \n<113> if (get_param_value(buf, sizeof(buf), "addr", p)) {\n<114> \n<115> nd->devaddr = strdup(buf);\n<116> \n<117> }\n<118> \n<119> nd->vlan = vlan;\n<120> \n<121> nd->name = name;\n<122> \n<123> nd->used = 1;\n<124> \n<125> name = NULL;\n<126> \n<127> nb_nics++;\n<128> \n<129> vlan->nb_guest_devs++;\n<130> \n<131> ret = idx;\n<132> \n<133> } else\n<134> \n<135> if (!strcmp(device, "none")) {\n<136> \n<137> if (*p != '\0') {\n<138> \n<139> config_error(mon, "'none' takes no parameters\n");\n<140> \n<141> ret = -1;\n<142> \n<143> goto out;\n<144> \n<145> }\n<146> \n<147> /* does nothing. It is needed to signal that no network cards\n<148> \n<149> are wanted */\n<150> \n<151> ret = 0;\n<152> \n<153> } else\n<154> \n<155> #ifdef CONFIG_SLIRP\n<156> \n<157> if (!strcmp(device, "user")) {\n<158> \n<159> static const char * const slirp_params[] = {\n<160> \n<161> "vlan", "name", "hostname", "restrict", "ip", NULL\n<162> \n<163> };\n<164> \n<165> int restricted = 0;\n<166> \n<167> char *ip = NULL;\n<168> \n<169> \n<170> \n<171> if (check_params(buf, sizeof(buf), slirp_params, p) < 0) {\n<172> \n<173> config_error(mon, "invalid parameter '%s' in '%s'\n", buf, p);\n<174> \n<175> ret = -1;\n<176> \n<177> goto out;\n<178> \n<179> }\n<180> \n<181> if (get_param_value(buf, sizeof(buf), "hostname", p)) {\n<182> \n<183> pstrcpy(slirp_hostname, sizeof(slirp_hostname), buf);\n<184> \n<185> }\n<186> \n<187> if (get_param_value(buf, sizeof(buf), "restrict", p)) {\n<188> \n<189> restricted = (buf[0] == 'y') ? 1 : 0;\n<190> \n<191> }\n<192> \n<193> if (get_param_value(buf, sizeof(buf), "ip", p)) {\n<194> \n<195> ip = qemu_strdup(buf);\n<196> \n<197> }\n<198> \n<199> vlan->nb_host_devs++;\n<200> \n<201> ret = net_slirp_init(vlan, device, name, restricted, ip);\n<202> \n<203> qemu_free(ip);\n<204> \n<205> } else if (!strcmp(device, "channel")) {\n<206> \n<207> long port;\n<208> \n<209> char name[20], *devname;\n<210> \n<211> struct VMChannel *vmc;\n<212> \n<213> \n<214> \n<215> port = strtol(p, &devname, 10);\n<216> \n<217> devname++;\n<218> \n<219> if (port < 1 || port > 65535) {\n<220> \n<221> config_error(mon, "vmchannel wrong port number\n");\n<222> \n<223> ret = -1;\n<224> \n<225> goto out;\n<226> \n<227> }\n<228> \n<229> vmc = malloc(sizeof(struct VMChannel));\n<230> \n<231> snprintf(name, 20, "vmchannel%ld", port);\n<232> \n<233> vmc->hd = qemu_chr_open(name, devname, NULL);\n<234> \n<235> if (!vmc->hd) {\n<236> \n<237> config_error(mon, "could not open vmchannel device '%s'\n",\n<238> \n<239> devname);\n<240> \n<241> ret = -1;\n<242> \n<243> goto out;\n<244> \n<245> }\n<246> \n<247> vmc->port = port;\n<248> \n<249> slirp_add_exec(3, vmc->hd, 4, port);\n<250> \n<251> qemu_chr_add_handlers(vmc->hd, vmchannel_can_read, vmchannel_read,\n<252> \n<253> NULL, vmc);\n<254> \n<255> ret = 0;\n<256> \n<257> } else\n<258> \n<259> #endif\n<260> \n<261> #ifdef _WIN32\n<262> \n<263> if (!strcmp(device, "tap")) {\n<264> \n<265> static const char * const tap_params[] = {\n<266> \n<267> "vlan", "name", "ifname", NULL\n<268> \n<269> };\n<270> \n<271> char ifname[64];\n<272> \n<273> \n<274> \n<275> if (check_params(buf, sizeof(buf), tap_params, p) < 0) {\n<276> \n<277> config_error(mon, "invalid parameter '%s' in '%s'\n", buf, p);\n<278> \n<279> ret = -1;\n<280> \n<281> goto out;\n<282> \n<283> }\n<284> \n<285> if (get_param_value(ifname, sizeof(ifname), "ifname", p) <= 0) {\n<286> \n<287> config_error(mon, "tap: no interface name\n");\n<288> \n<289> ret = -1;\n<290> \n<291> goto out;\n<292> \n<293> }\n<294> \n<295> vlan->nb_host_devs++;\n<296> \n<297> ret = tap_win32_init(vlan, device, name, ifname);\n<298> \n<299> } else\n<300> \n<301> #elif defined (_AIX)\n<302> \n<303> #else\n<304> \n<305> if (!strcmp(device, "tap")) {\n<306> \n<307> char ifname[64], chkbuf[64];\n<308> \n<309> char setup_script[1024], down_script[1024];\n<310> \n<311> TAPState *s;\n<312> \n<313> int fd;\n<314> \n<315> vlan->nb_host_devs++;\n<316> \n<317> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<318> \n<319> if (check_params(chkbuf, sizeof(chkbuf), fd_params, p) < 0) {\n<320> \n<321> config_error(mon, "invalid parameter '%s' in '%s'\n", chkbuf, p);\n<322> \n<323> ret = -1;\n<324> \n<325> goto out;\n<326> \n<327> }\n<328> \n<329> fd = strtol(buf, NULL, 0);\n<330> \n<331> fcntl(fd, F_SETFL, O_NONBLOCK);\n<332> \n<333> s = net_tap_fd_init(vlan, device, name, fd);\n<334> \n<335> } else {\n<336> \n<337> static const char * const tap_params[] = {\n<338> \n<339> "vlan", "name", "ifname", "script", "downscript", NULL\n<340> \n<341> };\n<342> \n<343> if (check_params(chkbuf, sizeof(chkbuf), tap_params, p) < 0) {\n<344> \n<345> config_error(mon, "invalid parameter '%s' in '%s'\n", chkbuf, p);\n<346> \n<347> ret = -1;\n<348> \n<349> goto out;\n<350> \n<351> }\n<352> \n<353> if (get_param_value(ifname, sizeof(ifname), "ifname", p) <= 0) {\n<354> \n<355> ifname[0] = '\0';\n<356> \n<357> }\n<358> \n<359> if (get_param_value(setup_script, sizeof(setup_script), "script", p) == 0) {\n<360> \n<361> pstrcpy(setup_script, sizeof(setup_script), DEFAULT_NETWORK_SCRIPT);\n<362> \n<363> }\n<364> \n<365> if (get_param_value(down_script, sizeof(down_script), "downscript", p) == 0) {\n<366> \n<367> pstrcpy(down_script, sizeof(down_script), DEFAULT_NETWORK_DOWN_SCRIPT);\n<368> \n<369> }\n<370> \n<371> s = net_tap_init(vlan, device, name, ifname, setup_script, down_script);\n<372> \n<373> }\n<374> \n<375> if (s != NULL) {\n<376> \n<377> ret = 0;\n<378> \n<379> } else {\n<380> \n<381> ret = -1;\n<382> \n<383> }\n<384> \n<385> } else\n<386> \n<387> #endif\n<388> \n<389> if (!strcmp(device, "socket")) {\n<390> \n<391> char chkbuf[64];\n<392> \n<393> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<394> \n<395> int fd;\n<396> \n<397> if (check_params(chkbuf, sizeof(chkbuf), fd_params, p) < 0) {\n<398> \n<399> config_error(mon, "invalid parameter '%s' in '%s'\n", chkbuf, p);\n<400> \n<401> ret = -1;\n<402> \n<403> goto out;\n<404> \n<405> }\n<406> \n<407> fd = strtol(buf, NULL, 0);\n<408> \n<409> ret = -1;\n<410> \n<411> if (net_socket_fd_init(vlan, device, name, fd, 1))\n<412> \n<413> ret = 0;\n<414> \n<415> } else if (get_param_value(buf, sizeof(buf), "listen", p) > 0) {\n<416> \n<417> static const char * const listen_params[] = {\n<418> \n<419> "vlan", "name", "listen", NULL\n<420> \n<421> };\n<422> \n<423> if (check_params(chkbuf, sizeof(chkbuf), listen_params, p) < 0) {\n<424> \n<425> config_error(mon, "invalid parameter '%s' in '%s'\n", chkbuf, p);\n<426> \n<427> ret = -1;\n<428> \n<429> goto out;\n<430> \n<431> }\n<432> \n<433> ret = net_socket_listen_init(vlan, device, name, buf);\n<434> \n<435> } else if (get_param_value(buf, sizeof(buf), "connect", p) > 0) {\n<436> \n<437> static const char * const connect_params[] = {\n<438> \n<439> "vlan", "name", "connect", NULL\n<440> \n<441> };\n<442> \n<443> if (check_params(chkbuf, sizeof(chkbuf), connect_params, p) < 0) {\n<444> \n<445> config_error(mon, "invalid parameter '%s' in '%s'\n", chkbuf, p);\n<446> \n<447> ret = -1;\n<448> \n<449> goto out;\n<450> \n<451> }\n<452> \n<453> ret = net_socket_connect_init(vlan, device, name, buf);\n<454> \n<455> } else if (get_param_value(buf, sizeof(buf), "mcast", p) > 0) {\n<456> \n<457> static const char * const mcast_params[] = {\n<458> \n<459> "vlan", "name", "mcast", NULL\n<460> \n<461> };\n<462> \n<463> if (check_params(chkbuf, sizeof(chkbuf), mcast_params, p) < 0) {\n<464> \n<465> config_error(mon, "invalid parameter '%s' in '%s'\n", chkbuf, p);\n<466> \n<467> ret = -1;\n<468> \n<469> goto out;\n<470> \n<471> }\n<472> \n<473> ret = net_socket_mcast_init(vlan, device, name, buf);\n<474> \n<475> } else {\n<476> \n<477> config_error(mon, "Unknown socket options: %s\n", p);\n<478> \n<479> ret = -1;\n<480> \n<481> goto out;\n<482> \n<483> }\n<484> \n<485> vlan->nb_host_devs++;\n<486> \n<487> } else\n<488> \n<489> #ifdef CONFIG_VDE\n<490> \n<491> if (!strcmp(device, "vde")) {\n<492> \n<493> static const char * const vde_params[] = {\n<494> \n<495> "vlan", "name", "sock", "port", "group", "mode", NULL\n<496> \n<497> };\n<498> \n<499> char vde_sock[1024], vde_group[512];\n<500> \n<501> int vde_port, vde_mode;\n<502> \n<503> \n<504> \n<505> if (check_params(buf, sizeof(buf), vde_params, p) < 0) {\n<506> \n<507> config_error(mon, "invalid parameter '%s' in '%s'\n", buf, p);\n<508> \n<509> ret = -1;\n<510> \n<511> goto out;\n<512> \n<513> }\n<514> \n<515> vlan->nb_host_devs++;\n<516> \n<517> if (get_param_value(vde_sock, sizeof(vde_sock), "sock", p) <= 0) {\n<518> \n<519> vde_sock[0] = '\0';\n<520> \n<521> }\n<522> \n<523> if (get_param_value(buf, sizeof(buf), "port", p) > 0) {\n<524> \n<525> vde_port = strtol(buf, NULL, 10);\n<526> \n<527> } else {\n<528> \n<529> vde_port = 0;\n<530> \n<531> }\n<532> \n<533> if (get_param_value(vde_group, sizeof(vde_group), "group", p) <= 0) {\n<534> \n<535> vde_group[0] = '\0';\n<536> \n<537> }\n<538> \n<539> if (get_param_value(buf, sizeof(buf), "mode", p) > 0) {\n<540> \n<541> vde_mode = strtol(buf, NULL, 8);\n<542> \n<543> } else {\n<544> \n<545> vde_mode = 0700;\n<546> \n<547> }\n<548> \n<549> ret = net_vde_init(vlan, device, name, vde_sock, vde_port, vde_group, vde_mode);\n<550> \n<551> } else\n<552> \n<553> #endif\n<554> \n<555> if (!strcmp(device, "dump")) {\n<556> \n<557> int len = 65536;\n<558> \n<559> \n<560> \n<561> if (get_param_value(buf, sizeof(buf), "len", p) > 0) {\n<562> \n<563> len = strtol(buf, NULL, 0);\n<564> \n<565> }\n<566> \n<567> if (!get_param_value(buf, sizeof(buf), "file", p)) {\n<568> \n<569> snprintf(buf, sizeof(buf), "qemu-vlan%d.pcap", vlan_id);\n<570> \n<571> }\n<572> \n<573> ret = net_dump_init(mon, vlan, device, name, buf, len);\n<574> \n<575> } else {\n<576> \n<577> config_error(mon, "Unknown network device: %s\n", device);\n<578> \n<579> ret = -1;\n<580> \n<581> goto out;\n<582> \n<583> }\n<584> \n<585> if (ret < 0) {\n<586> \n<587> config_error(mon, "Could not initialize device '%s'\n", device);\n<588> \n<589> }\n<590> \n<591> out:\n<592> \n<593> qemu_free(name);\n<594> \n<595> return ret;\n<596> \n<597> }\n<598> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void *av_realloc(void *ptr, unsigned int size)\n<2> \n<3> {\n<4> \n<5> #ifdef MEMALIGN_HACK\n<6> \n<7> int diff;\n<8> \n<9> #endif\n<10> \n<11> \n<12> \n<13> /* let's disallow possible ambiguous cases */\n<14> \n<15> if(size > INT_MAX)\n<16> \n<17> return NULL;\n<18> \n<19> \n<20> \n<21> #ifdef MEMALIGN_HACK\n<22> \n<23> //FIXME this isn't aligned correctly, though it probably isn't needed\n<24> \n<25> if(!ptr) return av_malloc(size);\n<26> \n<27> diff= ((char*)ptr)[-1];\n<28> \n<29> return realloc(ptr - diff, size + diff) + diff;\n<30> \n<31> #else\n<32> \n<33> return realloc(ptr, size);\n<34> \n<35> #endif\n<36> \n<37> }\n<38> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n<2> gcry_err_code_t err = 0 ;\n<3> gcry_sexp_t list = NULL , l2 = NULL ;\n<4> gcry_pk_spec_t * pubkey = NULL ;\n<5> gcry_module_t module = NULL ;\n<6> char * name = NULL ;\n<7> size_t n ;\n<8> int parsed_flags = 0 ;\n<9> const char * elems ;\n<10> gcry_mpi_t * array = NULL ;\n<11> * ret_modern = 0 ;\n<12> list = gcry_sexp_find_token ( sexp , "enc-val" , 0 ) ;\n<13> if ( ! list ) {\n<14> err = GPG_ERR_INV_OBJ ;\n<15> goto leave ;\n<16> }\n<17> l2 = gcry_sexp_nth ( list , 1 ) ;\n<18> if ( ! l2 ) {\n<19> err = GPG_ERR_NO_OBJ ;\n<20> goto leave ;\n<21> }\n<22> name = _gcry_sexp_nth_string ( l2 , 0 ) ;\n<23> if ( ! name ) {\n<24> err = GPG_ERR_INV_OBJ ;\n<25> goto leave ;\n<26> }\n<27> if ( ! strcmp ( name , "flags" ) ) {\n<28> const char * s ;\n<29> int i ;\n<30> * ret_modern = 1 ;\n<31> for ( i = gcry_sexp_length ( l2 ) - 1 ;\n<32> i > 0 ;\n<33> i -- ) {\n<34> s = gcry_sexp_nth_data ( l2 , i , & n ) ;\n<35> if ( ! s ) ;\n<36> else if ( n == 3 && ! memcmp ( s , "raw" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_RAW ;\n<37> else if ( n == 5 && ! memcmp ( s , "pkcs1" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n<38> else if ( n == 4 && ! memcmp ( s , "oaep" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n<39> else if ( n == 3 && ! memcmp ( s , "pss" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n<40> err = GPG_ERR_CONFLICT ;\n<41> goto leave ;\n<42> }\n<43> else if ( n == 11 && ! memcmp ( s , "no-blinding" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n<44> else {\n<45> err = GPG_ERR_INV_FLAG ;\n<46> goto leave ;\n<47> }\n<48> }\n<49> gcry_sexp_release ( l2 ) ;\n<50> if ( ctx -> encoding == PUBKEY_ENC_OAEP ) {\n<51> l2 = gcry_sexp_find_token ( list , "hash-algo" , 0 ) ;\n<52> if ( l2 ) {\n<53> s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n<54> if ( ! s ) err = GPG_ERR_NO_OBJ ;\n<55> else {\n<56> ctx -> hash_algo = get_hash_algo ( s , n ) ;\n<57> if ( ! ctx -> hash_algo ) err = GPG_ERR_DIGEST_ALGO ;\n<58> }\n<59> gcry_sexp_release ( l2 ) ;\n<60> if ( err ) goto leave ;\n<61> }\n<62> l2 = gcry_sexp_find_token ( list , "label" , 0 ) ;\n<63> if ( l2 ) {\n<64> s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n<65> if ( ! s ) err = GPG_ERR_NO_OBJ ;\n<66> else if ( n > 0 ) {\n<67> ctx -> label = gcry_malloc ( n ) ;\n<68> if ( ! ctx -> label ) err = gpg_err_code_from_syserror ( ) ;\n<69> else {\n<70> memcpy ( ctx -> label , s , n ) ;\n<71> ctx -> labellen = n ;\n<72> }\n<73> }\n<74> gcry_sexp_release ( l2 ) ;\n<75> if ( err ) goto leave ;\n<76> }\n<77> }\n<78> for ( i = 2 ;\n<79> ( l2 = gcry_sexp_nth ( list , i ) ) != NULL ;\n<80> i ++ ) {\n<81> s = gcry_sexp_nth_data ( l2 , 0 , & n ) ;\n<82> if ( ! ( n == 9 && ! memcmp ( s , "hash-algo" , 9 ) ) && ! ( n == 5 && ! memcmp ( s , "label" , 5 ) ) && ! ( n == 15 && ! memcmp ( s , "random-override" , 15 ) ) ) break ;\n<83> gcry_sexp_release ( l2 ) ;\n<84> }\n<85> if ( ! l2 ) {\n<86> err = GPG_ERR_NO_OBJ ;\n<87> goto leave ;\n<88> }\n<89> gcry_free ( name ) ;\n<90> name = _gcry_sexp_nth_string ( l2 , 0 ) ;\n<91> if ( ! name ) {\n<92> err = GPG_ERR_INV_OBJ ;\n<93> goto leave ;\n<94> }\n<95> gcry_sexp_release ( list ) ;\n<96> list = l2 ;\n<97> l2 = NULL ;\n<98> }\n<99> ath_mutex_lock ( & pubkeys_registered_lock ) ;\n<100> module = gcry_pk_lookup_name ( name ) ;\n<101> ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n<102> if ( ! module ) {\n<103> err = GPG_ERR_PUBKEY_ALGO ;\n<104> goto leave ;\n<105> }\n<106> pubkey = ( gcry_pk_spec_t * ) module -> spec ;\n<107> elems = pubkey -> elements_enc ;\n<108> array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n<109> if ( ! array ) {\n<110> err = gpg_err_code_from_syserror ( ) ;\n<111> goto leave ;\n<112> }\n<113> err = sexp_elements_extract ( list , elems , array , NULL ) ;\n<114> leave : gcry_sexp_release ( list ) ;\n<115> gcry_sexp_release ( l2 ) ;\n<116> gcry_free ( name ) ;\n<117> if ( err ) {\n<118> ath_mutex_lock ( & pubkeys_registered_lock ) ;\n<119> _gcry_module_release ( module ) ;\n<120> ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n<121> gcry_free ( array ) ;\n<122> gcry_free ( ctx -> label ) ;\n<123> ctx -> label = NULL ;\n<124> }\n<125> else {\n<126> * retarray = array ;\n<127> * retalgo = module ;\n<128> * flags = parsed_flags ;\n<129> }\n<130> return err ;\n<131> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void mcf_fec_receive(void *opaque, const uint8_t *buf, size_t size)\n<2> \n<3> {\n<4> \n<5> mcf_fec_state *s = (mcf_fec_state *)opaque;\n<6> \n<7> mcf_fec_bd bd;\n<8> \n<9> uint32_t flags = 0;\n<10> \n<11> uint32_t addr;\n<12> \n<13> uint32_t crc;\n<14> \n<15> uint32_t buf_addr;\n<16> \n<17> uint8_t *crc_ptr;\n<18> \n<19> unsigned int buf_len;\n<20> \n<21> \n<22> \n<23> DPRINTF("do_rx len %d\n", size);\n<24> \n<25> if (!s->rx_enabled) {\n<26> \n<27> fprintf(stderr, "mcf_fec_receive: Unexpected packet\n");\n<28> \n<29> }\n<30> \n<31> /* 4 bytes for the CRC.  */\n<32> \n<33> size += 4;\n<34> \n<35> crc = cpu_to_be32(crc32(~0, buf, size));\n<36> \n<37> crc_ptr = (uint8_t *)&crc;\n<38> \n<39> /* Huge frames are truncted.  */\n<40> \n<41> if (size > FEC_MAX_FRAME_SIZE) {\n<42> \n<43> size = FEC_MAX_FRAME_SIZE;\n<44> \n<45> flags |= FEC_BD_TR | FEC_BD_LG;\n<46> \n<47> }\n<48> \n<49> /* Frames larger than the user limit just set error flags.  */\n<50> \n<51> if (size > (s->rcr >> 16)) {\n<52> \n<53> flags |= FEC_BD_LG;\n<54> \n<55> }\n<56> \n<57> addr = s->rx_descriptor;\n<58> \n<59> while (size > 0) {\n<60> \n<61> mcf_fec_read_bd(&bd, addr);\n<62> \n<63> if ((bd.flags & FEC_BD_E) == 0) {\n<64> \n<65> /* No descriptors available.  Bail out.  */\n<66> \n<67> /* FIXME: This is wrong.  We should probably either save the\n<68> \n<69> remainder for when more RX buffers are available, or\n<70> \n<71> flag an error.  */\n<72> \n<73> fprintf(stderr, "mcf_fec: Lost end of frame\n");\n<74> \n<75> break;\n<76> \n<77> }\n<78> \n<79> buf_len = (size <= s->emrbr) ? size: s->emrbr;\n<80> \n<81> bd.length = buf_len;\n<82> \n<83> size -= buf_len;\n<84> \n<85> DPRINTF("rx_bd %x length %d\n", addr, bd.length);\n<86> \n<87> /* The last 4 bytes are the CRC.  */\n<88> \n<89> if (size < 4)\n<90> \n<91> buf_len += size - 4;\n<92> \n<93> buf_addr = bd.data;\n<94> \n<95> cpu_physical_memory_write(buf_addr, buf, buf_len);\n<96> \n<97> buf += buf_len;\n<98> \n<99> if (size < 4) {\n<100> \n<101> cpu_physical_memory_write(buf_addr + buf_len, crc_ptr, 4 - size);\n<102> \n<103> crc_ptr += 4 - size;\n<104> \n<105> }\n<106> \n<107> bd.flags &= ~FEC_BD_E;\n<108> \n<109> if (size == 0) {\n<110> \n<111> /* Last buffer in frame.  */\n<112> \n<113> bd.flags |= flags | FEC_BD_L;\n<114> \n<115> DPRINTF("rx frame flags %04x\n", bd.flags);\n<116> \n<117> s->eir |= FEC_INT_RXF;\n<118> \n<119> } else {\n<120> \n<121> s->eir |= FEC_INT_RXB;\n<122> \n<123> }\n<124> \n<125> mcf_fec_write_bd(&bd, addr);\n<126> \n<127> /* Advance to the next descriptor.  */\n<128> \n<129> if ((bd.flags & FEC_BD_W) != 0) {\n<130> \n<131> addr = s->erdsr;\n<132> \n<133> } else {\n<134> \n<135> addr += 8;\n<136> \n<137> }\n<138> \n<139> }\n<140> \n<141> s->rx_descriptor = addr;\n<142> \n<143> mcf_fec_enable_rx(s);\n<144> \n<145> mcf_fec_update(s);\n<146> \n<147> }\n<148> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void term_hist_add(const char *cmdline)\n<2> \n<3> {\n<4> \n<5> char *hist_entry, *new_entry;\n<6> \n<7> int idx;\n<8> \n<9> \n<10> \n<11> if (cmdline[0] == '\0')\n<12> \n<13> return;\n<14> \n<15> new_entry = NULL;\n<16> \n<17> if (term_hist_entry != -1) {\n<18> \n<19> /* We were editing an existing history entry: replace it */\n<20> \n<21> hist_entry = term_history[term_hist_entry];\n<22> \n<23> idx = term_hist_entry;\n<24> \n<25> if (strcmp(hist_entry, cmdline) == 0) {\n<26> \n<27> goto same_entry;\n<28> \n<29> }\n<30> \n<31> }\n<32> \n<33> /* Search cmdline in history buffers */\n<34> \n<35> for (idx = 0; idx < TERM_MAX_CMDS; idx++) {\n<36> \n<37> hist_entry = term_history[idx];\n<38> \n<39> if (hist_entry == NULL)\n<40> \n<41> break;\n<42> \n<43> if (strcmp(hist_entry, cmdline) == 0) {\n<44> \n<45> same_entry:\n<46> \n<47> new_entry = hist_entry;\n<48> \n<49> /* Put this entry at the end of history */\n<50> \n<51> memmove(&term_history[idx], &term_history[idx + 1],\n<52> \n<53> &term_history[TERM_MAX_CMDS] - &term_history[idx + 1]);\n<54> \n<55> term_history[TERM_MAX_CMDS - 1] = NULL;\n<56> \n<57> for (; idx < TERM_MAX_CMDS; idx++) {\n<58> \n<59> if (term_history[idx] == NULL)\n<60> \n<61> break;\n<62> \n<63> }\n<64> \n<65> break;\n<66> \n<67> }\n<68> \n<69> }\n<70> \n<71> if (idx == TERM_MAX_CMDS) {\n<72> \n<73> /* Need to get one free slot */\n<74> \n<75> free(term_history[0]);\n<76> \n<77> memcpy(term_history, &term_history[1],\n<78> \n<79> &term_history[TERM_MAX_CMDS] - &term_history[1]);\n<80> \n<81> term_history[TERM_MAX_CMDS - 1] = NULL;\n<82> \n<83> idx = TERM_MAX_CMDS - 1;\n<84> \n<85> }\n<86> \n<87> if (new_entry == NULL)\n<88> \n<89> new_entry = strdup(cmdline);\n<90> \n<91> term_history[idx] = new_entry;\n<92> \n<93> term_hist_entry = -1;\n<94> \n<95> }\n<96> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n<2> \n<3> AVFrame *p, AVPacket *avpkt)\n<4> \n<5> {\n<6> \n<7> AVDictionary **metadatap = NULL;\n<8> \n<9> uint32_t tag, length;\n<10> \n<11> int decode_next_dat = 0;\n<12> \n<13> int ret;\n<14> \n<15> \n<16> \n<17> for (;;) {\n<18> \n<19> length = bytestream2_get_bytes_left(&s->gb);\n<20> \n<21> if (length <= 0) {\n<22> \n<23> \n<24> \n<25> if (avctx->codec_id == AV_CODEC_ID_PNG &&\n<26> \n<27> avctx->skip_frame == AVDISCARD_ALL) {\n<28> \n<29> return 0;\n<30> \n<31> }\n<32> \n<33> \n<34> \n<35> if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && length == 0) {\n<36> \n<37> if (!(s->pic_state & PNG_IDAT))\n<38> \n<39> return 0;\n<40> \n<41> else\n<42> \n<43> goto exit_loop;\n<44> \n<45> }\n<46> \n<47> av_log(avctx, AV_LOG_ERROR, "%d bytes left\n", length);\n<48> \n<49> if (   s->pic_state & PNG_ALLIMAGE\n<50> \n<51> && avctx->strict_std_compliance <= FF_COMPLIANCE_NORMAL)\n<52> \n<53> goto exit_loop;\n<54> \n<55> ret = AVERROR_INVALIDDATA;\n<56> \n<57> goto fail;\n<58> \n<59> }\n<60> \n<61> \n<62> \n<63> length = bytestream2_get_be32(&s->gb);\n<64> \n<65> if (length > 0x7fffffff || length > bytestream2_get_bytes_left(&s->gb)) {\n<66> \n<67> av_log(avctx, AV_LOG_ERROR, "chunk too big\n");\n<68> \n<69> ret = AVERROR_INVALIDDATA;\n<70> \n<71> goto fail;\n<72> \n<73> }\n<74> \n<75> tag = bytestream2_get_le32(&s->gb);\n<76> \n<77> if (avctx->debug & FF_DEBUG_STARTCODE)\n<78> \n<79> av_log(avctx, AV_LOG_DEBUG, "png: tag=%s length=%u\n",\n<80> \n<81> av_fourcc2str(tag), length);\n<82> \n<83> \n<84> \n<85> if (avctx->codec_id == AV_CODEC_ID_PNG &&\n<86> \n<87> avctx->skip_frame == AVDISCARD_ALL) {\n<88> \n<89> switch(tag) {\n<90> \n<91> case MKTAG('I', 'H', 'D', 'R'):\n<92> \n<93> case MKTAG('p', 'H', 'Y', 's'):\n<94> \n<95> case MKTAG('t', 'E', 'X', 't'):\n<96> \n<97> case MKTAG('I', 'D', 'A', 'T'):\n<98> \n<99> case MKTAG('t', 'R', 'N', 'S'):\n<100> \n<101> break;\n<102> \n<103> default:\n<104> \n<105> goto skip_tag;\n<106> \n<107> }\n<108> \n<109> }\n<110> \n<111> \n<112> \n<113> metadatap = &p->metadata;\n<114> \n<115> switch (tag) {\n<116> \n<117> case MKTAG('I', 'H', 'D', 'R'):\n<118> \n<119> if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n<120> \n<121> goto fail;\n<122> \n<123> break;\n<124> \n<125> case MKTAG('p', 'H', 'Y', 's'):\n<126> \n<127> if ((ret = decode_phys_chunk(avctx, s)) < 0)\n<128> \n<129> goto fail;\n<130> \n<131> break;\n<132> \n<133> case MKTAG('f', 'c', 'T', 'L'):\n<134> \n<135> if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n<136> \n<137> goto skip_tag;\n<138> \n<139> if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n<140> \n<141> goto fail;\n<142> \n<143> decode_next_dat = 1;\n<144> \n<145> break;\n<146> \n<147> case MKTAG('f', 'd', 'A', 'T'):\n<148> \n<149> if (!CONFIG_APNG_DECODER || avctx->codec_id != AV_CODEC_ID_APNG)\n<150> \n<151> goto skip_tag;\n<152> \n<153> if (!decode_next_dat) {\n<154> \n<155> ret = AVERROR_INVALIDDATA;\n<156> \n<157> goto fail;\n<158> \n<159> }\n<160> \n<161> bytestream2_get_be32(&s->gb);\n<162> \n<163> length -= 4;\n<164> \n<165> /* fallthrough */\n<166> \n<167> case MKTAG('I', 'D', 'A', 'T'):\n<168> \n<169> if (CONFIG_APNG_DECODER && avctx->codec_id == AV_CODEC_ID_APNG && !decode_next_dat)\n<170> \n<171> goto skip_tag;\n<172> \n<173> if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n<174> \n<175> goto fail;\n<176> \n<177> break;\n<178> \n<179> case MKTAG('P', 'L', 'T', 'E'):\n<180> \n<181> if (decode_plte_chunk(avctx, s, length) < 0)\n<182> \n<183> goto skip_tag;\n<184> \n<185> break;\n<186> \n<187> case MKTAG('t', 'R', 'N', 'S'):\n<188> \n<189> if (decode_trns_chunk(avctx, s, length) < 0)\n<190> \n<191> goto skip_tag;\n<192> \n<193> break;\n<194> \n<195> case MKTAG('t', 'E', 'X', 't'):\n<196> \n<197> if (decode_text_chunk(s, length, 0, metadatap) < 0)\n<198> \n<199> av_log(avctx, AV_LOG_WARNING, "Broken tEXt chunk\n");\n<200> \n<201> bytestream2_skip(&s->gb, length + 4);\n<202> \n<203> break;\n<204> \n<205> case MKTAG('z', 'T', 'X', 't'):\n<206> \n<207> if (decode_text_chunk(s, length, 1, metadatap) < 0)\n<208> \n<209> av_log(avctx, AV_LOG_WARNING, "Broken zTXt chunk\n");\n<210> \n<211> bytestream2_skip(&s->gb, length + 4);\n<212> \n<213> break;\n<214> \n<215> case MKTAG('s', 'T', 'E', 'R'): {\n<216> \n<217> int mode = bytestream2_get_byte(&s->gb);\n<218> \n<219> AVStereo3D *stereo3d = av_stereo3d_create_side_data(p);\n<220> \n<221> if (!stereo3d)\n<222> \n<223> goto fail;\n<224> \n<225> \n<226> \n<227> if (mode == 0 || mode == 1) {\n<228> \n<229> stereo3d->type  = AV_STEREO3D_SIDEBYSIDE;\n<230> \n<231> stereo3d->flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT;\n<232> \n<233> } else {\n<234> \n<235> av_log(avctx, AV_LOG_WARNING,\n<236> \n<237> "Unknown value in sTER chunk (%d)\n", mode);\n<238> \n<239> }\n<240> \n<241> bytestream2_skip(&s->gb, 4); /* crc */\n<242> \n<243> break;\n<244> \n<245> }\n<246> \n<247> case MKTAG('i', 'C', 'C', 'P'): {\n<248> \n<249> if (decode_iccp_chunk(s, length, p) < 0)\n<250> \n<251> goto fail;\n<252> \n<253> break;\n<254> \n<255> }\n<256> \n<257> case MKTAG('I', 'E', 'N', 'D'):\n<258> \n<259> if (!(s->pic_state & PNG_ALLIMAGE))\n<260> \n<261> av_log(avctx, AV_LOG_ERROR, "IEND without all image\n");\n<262> \n<263> if (!(s->pic_state & (PNG_ALLIMAGE|PNG_IDAT))) {\n<264> \n<265> ret = AVERROR_INVALIDDATA;\n<266> \n<267> goto fail;\n<268> \n<269> }\n<270> \n<271> bytestream2_skip(&s->gb, 4); /* crc */\n<272> \n<273> goto exit_loop;\n<274> \n<275> default:\n<276> \n<277> /* skip tag */\n<278> \n<279> skip_tag:\n<280> \n<281> bytestream2_skip(&s->gb, length + 4);\n<282> \n<283> break;\n<284> \n<285> }\n<286> \n<287> }\n<288> \n<289> exit_loop:\n<290> \n<291> \n<292> \n<293> if (avctx->codec_id == AV_CODEC_ID_PNG &&\n<294> \n<295> avctx->skip_frame == AVDISCARD_ALL) {\n<296> \n<297> return 0;\n<298> \n<299> }\n<300> \n<301> \n<302> \n<303> if (s->bits_per_pixel <= 4)\n<304> \n<305> handle_small_bpp(s, p);\n<306> \n<307> \n<308> \n<309> /* apply transparency if needed */\n<310> \n<311> if (s->has_trns && s->color_type != PNG_COLOR_TYPE_PALETTE) {\n<312> \n<313> size_t byte_depth = s->bit_depth > 8 ? 2 : 1;\n<314> \n<315> size_t raw_bpp = s->bpp - byte_depth;\n<316> \n<317> unsigned x, y;\n<318> \n<319> \n<320> \n<321> av_assert0(s->bit_depth > 1);\n<322> \n<323> \n<324> \n<325> for (y = 0; y < s->height; ++y) {\n<326> \n<327> uint8_t *row = &s->image_buf[s->image_linesize * y];\n<328> \n<329> \n<330> \n<331> /* since we're updating in-place, we have to go from right to left */\n<332> \n<333> for (x = s->width; x > 0; --x) {\n<334> \n<335> uint8_t *pixel = &row[s->bpp * (x - 1)];\n<336> \n<337> memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n<338> \n<339> \n<340> \n<341> if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n<342> \n<343> memset(&pixel[raw_bpp], 0, byte_depth);\n<344> \n<345> } else {\n<346> \n<347> memset(&pixel[raw_bpp], 0xff, byte_depth);\n<348> \n<349> }\n<350> \n<351> }\n<352> \n<353> }\n<354> \n<355> }\n<356> \n<357> \n<358> \n<359> /* handle P-frames only if a predecessor frame is available */\n<360> \n<361> if (s->last_picture.f->data[0]) {\n<362> \n<363> if (   !(avpkt->flags & AV_PKT_FLAG_KEY) && avctx->codec_tag != AV_RL32("MPNG")\n<364> \n<365> && s->last_picture.f->width == p->width\n<366> \n<367> && s->last_picture.f->height== p->height\n<368> \n<369> && s->last_picture.f->format== p->format\n<370> \n<371> ) {\n<372> \n<373> if (CONFIG_PNG_DECODER && avctx->codec_id != AV_CODEC_ID_APNG)\n<374> \n<375> handle_p_frame_png(s, p);\n<376> \n<377> else if (CONFIG_APNG_DECODER &&\n<378> \n<379> avctx->codec_id == AV_CODEC_ID_APNG &&\n<380> \n<381> (ret = handle_p_frame_apng(avctx, s, p)) < 0)\n<382> \n<383> goto fail;\n<384> \n<385> }\n<386> \n<387> }\n<388> \n<389> ff_thread_report_progress(&s->picture, INT_MAX, 0);\n<390> \n<391> ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n<392> \n<393> \n<394> \n<395> return 0;\n<396> \n<397> \n<398> \n<399> fail:\n<400> \n<401> ff_thread_report_progress(&s->picture, INT_MAX, 0);\n<402> \n<403> ff_thread_report_progress(&s->previous_picture, INT_MAX, 0);\n<404> \n<405> return ret;\n<406> \n<407> }\n<408> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> AVFilterContext *ff_filter_alloc(const AVFilter *filter, const char *inst_name)\n<2> \n<3> {\n<4> \n<5> AVFilterContext *ret;\n<6> \n<7> \n<8> \n<9> if (!filter)\n<10> \n<11> return NULL;\n<12> \n<13> \n<14> \n<15> ret = av_mallocz(sizeof(AVFilterContext));\n<16> \n<17> if (!ret)\n<18> \n<19> return NULL;\n<20> \n<21> \n<22> \n<23> ret->av_class = &avfilter_class;\n<24> \n<25> ret->filter   = filter;\n<26> \n<27> ret->name     = inst_name ? av_strdup(inst_name) : NULL;\n<28> \n<29> if (filter->priv_size) {\n<30> \n<31> ret->priv     = av_mallocz(filter->priv_size);\n<32> \n<33> if (!ret->priv)\n<34> \n<35> goto err;\n<36> \n<37> }\n<38> \n<39> \n<40> \n<41> if (filter->priv_class) {\n<42> \n<43> *(const AVClass**)ret->priv = filter->priv_class;\n<44> \n<45> av_opt_set_defaults(ret->priv);\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> ret->nb_inputs = pad_count(filter->inputs);\n<52> \n<53> if (ret->nb_inputs ) {\n<54> \n<55> ret->input_pads   = av_malloc(sizeof(AVFilterPad) * ret->nb_inputs);\n<56> \n<57> if (!ret->input_pads)\n<58> \n<59> goto err;\n<60> \n<61> memcpy(ret->input_pads, filter->inputs, sizeof(AVFilterPad) * ret->nb_inputs);\n<62> \n<63> ret->inputs       = av_mallocz(sizeof(AVFilterLink*) * ret->nb_inputs);\n<64> \n<65> if (!ret->inputs)\n<66> \n<67> goto err;\n<68> \n<69> }\n<70> \n<71> \n<72> \n<73> ret->nb_outputs = pad_count(filter->outputs);\n<74> \n<75> if (ret->nb_outputs) {\n<76> \n<77> ret->output_pads  = av_malloc(sizeof(AVFilterPad) * ret->nb_outputs);\n<78> \n<79> if (!ret->output_pads)\n<80> \n<81> goto err;\n<82> \n<83> memcpy(ret->output_pads, filter->outputs, sizeof(AVFilterPad) * ret->nb_outputs);\n<84> \n<85> ret->outputs      = av_mallocz(sizeof(AVFilterLink*) * ret->nb_outputs);\n<86> \n<87> if (!ret->outputs)\n<88> \n<89> goto err;\n<90> \n<91> }\n<92> \n<93> #if FF_API_FOO_COUNT\n<94> \n<95> ret->output_count = ret->nb_outputs;\n<96> \n<97> ret->input_count  = ret->nb_inputs;\n<98> \n<99> #endif\n<100> \n<101> \n<102> \n<103> return ret;\n<104> \n<105> \n<106> \n<107> err:\n<108> \n<109> av_freep(&ret->inputs);\n<110> \n<111> av_freep(&ret->input_pads);\n<112> \n<113> ret->nb_inputs = 0;\n<114> \n<115> av_freep(&ret->outputs);\n<116> \n<117> av_freep(&ret->output_pads);\n<118> \n<119> ret->nb_outputs = 0;\n<120> \n<121> av_freep(&ret->priv);\n<122> \n<123> av_free(ret);\n<124> \n<125> return NULL;\n<126> \n<127> }\n<128> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> size_t iov_from_buf(struct iovec *iov, unsigned int iov_cnt, size_t iov_off,\n<2> \n<3> const void *buf, size_t size)\n<4> \n<5> {\n<6> \n<7> size_t iovec_off, buf_off;\n<8> \n<9> unsigned int i;\n<10> \n<11> \n<12> \n<13> iovec_off = 0;\n<14> \n<15> buf_off = 0;\n<16> \n<17> for (i = 0; i < iov_cnt && size; i++) {\n<18> \n<19> if (iov_off < (iovec_off + iov[i].iov_len)) {\n<20> \n<21> size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off, size);\n<22> \n<23> \n<24> \n<25> memcpy(iov[i].iov_base + (iov_off - iovec_off), buf + buf_off, len);\n<26> \n<27> \n<28> \n<29> buf_off += len;\n<30> \n<31> iov_off += len;\n<32> \n<33> size -= len;\n<34> \n<35> }\n<36> \n<37> iovec_off += iov[i].iov_len;\n<38> \n<39> }\n<40> \n<41> return buf_off;\n<42> \n<43> }\n<44> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int dvdsub_parse(AVCodecParserContext *s,\n<2> \n<3> AVCodecContext *avctx,\n<4> \n<5> const uint8_t **poutbuf, int *poutbuf_size,\n<6> \n<7> const uint8_t *buf, int buf_size)\n<8> \n<9> {\n<10> \n<11> DVDSubParseContext *pc = s->priv_data;\n<12> \n<13> \n<14> \n<15> if (pc->packet_index == 0) {\n<16> \n<17> if (buf_size < 2)\n<18> \n<19> return buf_size;\n<20> \n<21> pc->packet_len = AV_RB16(buf);\n<22> \n<23> if (pc->packet_len == 0) /* HD-DVD subpicture packet */\n<24> \n<25> pc->packet_len = AV_RB32(buf+2);\n<26> \n<27> av_freep(&pc->packet);\n<28> \n<29> pc->packet = av_malloc(pc->packet_len);\n<30> \n<31> }\n<32> \n<33> if (pc->packet) {\n<34> \n<35> if (pc->packet_index + buf_size <= pc->packet_len) {\n<36> \n<37> memcpy(pc->packet + pc->packet_index, buf, buf_size);\n<38> \n<39> pc->packet_index += buf_size;\n<40> \n<41> if (pc->packet_index >= pc->packet_len) {\n<42> \n<43> *poutbuf = pc->packet;\n<44> \n<45> *poutbuf_size = pc->packet_len;\n<46> \n<47> pc->packet_index = 0;\n<48> \n<49> return buf_size;\n<50> \n<51> }\n<52> \n<53> } else {\n<54> \n<55> /* erroneous size */\n<56> \n<57> pc->packet_index = 0;\n<58> \n<59> }\n<60> \n<61> }\n<62> \n<63> *poutbuf = NULL;\n<64> \n<65> *poutbuf_size = 0;\n<66> \n<67> return buf_size;\n<68> \n<69> }\n<70> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void omap_pwt_write(void *opaque, target_phys_addr_t addr,\n<2> \n<3> uint64_t value, unsigned size)\n<4> \n<5> {\n<6> \n<7> struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n<8> \n<9> int offset = addr & OMAP_MPUI_REG_MASK;\n<10> \n<11> \n<12> \n<13> if (size != 1) {\n<14> \n<15> return omap_badwidth_write8(opaque, addr, value);\n<16> \n<17> }\n<18> \n<19> \n<20> \n<21> switch (offset) {\n<22> \n<23> case 0x00:	/* FRC */\n<24> \n<25> s->frc = value & 0x3f;\n<26> \n<27> break;\n<28> \n<29> case 0x04:	/* VRC */\n<30> \n<31> if ((value ^ s->vrc) & 1) {\n<32> \n<33> if (value & 1)\n<34> \n<35> printf("%s: %iHz buzz on\n", __FUNCTION__, (int)\n<36> \n<37> /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n<38> \n<39> ((omap_clk_getrate(s->clk) >> 3) /\n<40> \n<41> /* Pre-multiplexer divider */\n<42> \n<43> ((s->gcr & 2) ? 1 : 154) /\n<44> \n<45> /* Octave multiplexer */\n<46> \n<47> (2 << (value & 3)) *\n<48> \n<49> /* 101/107 divider */\n<50> \n<51> ((value & (1 << 2)) ? 101 : 107) *\n<52> \n<53> /*  49/55 divider */\n<54> \n<55> ((value & (1 << 3)) ?  49 : 55) *\n<56> \n<57> /*  50/63 divider */\n<58> \n<59> ((value & (1 << 4)) ?  50 : 63) *\n<60> \n<61> /*  80/127 divider */\n<62> \n<63> ((value & (1 << 5)) ?  80 : 127) /\n<64> \n<65> (107 * 55 * 63 * 127)));\n<66> \n<67> else\n<68> \n<69> printf("%s: silence!\n", __FUNCTION__);\n<70> \n<71> }\n<72> \n<73> s->vrc = value & 0x7f;\n<74> \n<75> break;\n<76> \n<77> case 0x08:	/* GCR */\n<78> \n<79> s->gcr = value & 3;\n<80> \n<81> break;\n<82> \n<83> default:\n<84> \n<85> OMAP_BAD_REG(addr);\n<86> \n<87> return;\n<88> \n<89> }\n<90> \n<91> }\n<92> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void short_usage ( FILE * f ) {\n<2> short_usage_sub ( f ) ;\n<3> fprintf ( f , "For more options, use %s --help\n" , my_progname_short ) ;\n<4> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> av_cold void ff_rl_init(RLTable *rl,\n<2> \n<3> uint8_t static_store[2][2 * MAX_RUN + MAX_LEVEL + 3])\n<4> \n<5> {\n<6> \n<7> int8_t  max_level[MAX_RUN + 1], max_run[MAX_LEVEL + 1];\n<8> \n<9> uint8_t index_run[MAX_RUN + 1];\n<10> \n<11> int last, run, level, start, end, i;\n<12> \n<13> \n<14> \n<15> /* If table is static, we can quit if rl->max_level[0] is not NULL */\n<16> \n<17> if (static_store && rl->max_level[0])\n<18> \n<19> return;\n<20> \n<21> \n<22> \n<23> /* compute max_level[], max_run[] and index_run[] */\n<24> \n<25> for (last = 0; last < 2; last++) {\n<26> \n<27> if (last == 0) {\n<28> \n<29> start = 0;\n<30> \n<31> end = rl->last;\n<32> \n<33> } else {\n<34> \n<35> start = rl->last;\n<36> \n<37> end = rl->n;\n<38> \n<39> }\n<40> \n<41> \n<42> \n<43> memset(max_level, 0, MAX_RUN + 1);\n<44> \n<45> memset(max_run, 0, MAX_LEVEL + 1);\n<46> \n<47> memset(index_run, rl->n, MAX_RUN + 1);\n<48> \n<49> for (i = start; i < end; i++) {\n<50> \n<51> run   = rl->table_run[i];\n<52> \n<53> level = rl->table_level[i];\n<54> \n<55> if (index_run[run] == rl->n)\n<56> \n<57> index_run[run] = i;\n<58> \n<59> if (level > max_level[run])\n<60> \n<61> max_level[run] = level;\n<62> \n<63> if (run > max_run[level])\n<64> \n<65> max_run[level] = run;\n<66> \n<67> }\n<68> \n<69> if (static_store)\n<70> \n<71> rl->max_level[last] = static_store[last];\n<72> \n<73> else\n<74> \n<75> rl->max_level[last] = av_malloc(MAX_RUN + 1);\n<76> \n<77> memcpy(rl->max_level[last], max_level, MAX_RUN + 1);\n<78> \n<79> if (static_store)\n<80> \n<81> rl->max_run[last]   = static_store[last] + MAX_RUN + 1;\n<82> \n<83> else\n<84> \n<85> rl->max_run[last]   = av_malloc(MAX_LEVEL + 1);\n<86> \n<87> memcpy(rl->max_run[last], max_run, MAX_LEVEL + 1);\n<88> \n<89> if (static_store)\n<90> \n<91> rl->index_run[last] = static_store[last] + MAX_RUN + MAX_LEVEL + 2;\n<92> \n<93> else\n<94> \n<95> rl->index_run[last] = av_malloc(MAX_RUN + 1);\n<96> \n<97> memcpy(rl->index_run[last], index_run, MAX_RUN + 1);\n<98> \n<99> }\n<100> \n<101> }\n<102> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int do_attach(USBDevice *dev)\n<2> \n<3> {\n<4> \n<5> USBBus *bus = usb_bus_from_device(dev);\n<6> \n<7> USBPort *port;\n<8> \n<9> \n<10> \n<11> if (dev->attached) {\n<12> \n<13> error_report("Error: tried to attach usb device %s twice\n",\n<14> \n<15> dev->product_desc);\n<16> \n<17> return -1;\n<18> \n<19> }\n<20> \n<21> if (bus->nfree == 0) {\n<22> \n<23> error_report("Error: tried to attach usb device %s to a bus with no free ports\n",\n<24> \n<25> dev->product_desc);\n<26> \n<27> return -1;\n<28> \n<29> }\n<30> \n<31> if (dev->port_path) {\n<32> \n<33> QTAILQ_FOREACH(port, &bus->free, next) {\n<34> \n<35> if (strcmp(port->path, dev->port_path) == 0) {\n<36> \n<37> break;\n<38> \n<39> }\n<40> \n<41> }\n<42> \n<43> if (port == NULL) {\n<44> \n<45> error_report("Error: usb port %s (bus %s) not found\n",\n<46> \n<47> dev->port_path, bus->qbus.name);\n<48> \n<49> return -1;\n<50> \n<51> }\n<52> \n<53> } else {\n<54> \n<55> port = QTAILQ_FIRST(&bus->free);\n<56> \n<57> }\n<58> \n<59> if (!(port->speedmask & dev->speedmask)) {\n<60> \n<61> error_report("Warning: speed mismatch trying to attach usb device %s to bus %s\n",\n<62> \n<63> dev->product_desc, bus->qbus.name);\n<64> \n<65> return -1;\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> dev->attached++;\n<72> \n<73> QTAILQ_REMOVE(&bus->free, port, next);\n<74> \n<75> bus->nfree--;\n<76> \n<77> \n<78> \n<79> usb_attach(port, dev);\n<80> \n<81> \n<82> \n<83> QTAILQ_INSERT_TAIL(&bus->used, port, next);\n<84> \n<85> bus->nused++;\n<86> \n<87> \n<88> \n<89> return 0;\n<90> \n<91> }\n<92> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline abi_long target_to_host_sockaddr(int fd, struct sockaddr *addr,\n<2> \n<3> abi_ulong target_addr,\n<4> \n<5> socklen_t len)\n<6> \n<7> {\n<8> \n<9> const socklen_t unix_maxlen = sizeof (struct sockaddr_un);\n<10> \n<11> sa_family_t sa_family;\n<12> \n<13> struct target_sockaddr *target_saddr;\n<14> \n<15> \n<16> \n<17> if (fd_trans_target_to_host_addr(fd)) {\n<18> \n<19> return fd_trans_target_to_host_addr(fd)(addr, target_addr, len);\n<20> \n<21> }\n<22> \n<23> \n<24> \n<25> target_saddr = lock_user(VERIFY_READ, target_addr, len, 1);\n<26> \n<27> if (!target_saddr)\n<28> \n<29> return -TARGET_EFAULT;\n<30> \n<31> \n<32> \n<33> sa_family = tswap16(target_saddr->sa_family);\n<34> \n<35> \n<36> \n<37> /* Oops. The caller might send a incomplete sun_path; sun_path\n<38> \n<39> * must be terminated by \0 (see the manual page), but\n<40> \n<41> * unfortunately it is quite common to specify sockaddr_un\n<42> \n<43> * length as "strlen(x->sun_path)" while it should be\n<44> \n<45> * "strlen(...) + 1". We'll fix that here if needed.\n<46> \n<47> * Linux kernel has a similar feature.\n<48> \n<49> */\n<50> \n<51> \n<52> \n<53> if (sa_family == AF_UNIX) {\n<54> \n<55> if (len < unix_maxlen && len > 0) {\n<56> \n<57> char *cp = (char*)target_saddr;\n<58> \n<59> \n<60> \n<61> if ( cp[len-1] && !cp[len] )\n<62> \n<63> len++;\n<64> \n<65> }\n<66> \n<67> if (len > unix_maxlen)\n<68> \n<69> len = unix_maxlen;\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> memcpy(addr, target_saddr, len);\n<76> \n<77> addr->sa_family = sa_family;\n<78> \n<79> if (sa_family == AF_PACKET) {\n<80> \n<81> struct target_sockaddr_ll *lladdr;\n<82> \n<83> \n<84> \n<85> lladdr = (struct target_sockaddr_ll *)addr;\n<86> \n<87> lladdr->sll_ifindex = tswap32(lladdr->sll_ifindex);\n<88> \n<89> lladdr->sll_hatype = tswap16(lladdr->sll_hatype);\n<90> \n<91> }\n<92> \n<93> unlock_user(target_saddr, target_addr, 0);\n<94> \n<95> \n<96> \n<97> return 0;\n<98> \n<99> }\n<100> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void arm_load_kernel(CPUState *env, struct arm_boot_info *info)\n<2> \n<3> {\n<4> \n<5> int kernel_size;\n<6> \n<7> int initrd_size;\n<8> \n<9> int n;\n<10> \n<11> int is_linux = 0;\n<12> \n<13> uint64_t elf_entry;\n<14> \n<15> target_phys_addr_t entry;\n<16> \n<17> int big_endian;\n<18> \n<19> \n<20> \n<21> /* Load the kernel.  */\n<22> \n<23> if (!info->kernel_filename) {\n<24> \n<25> fprintf(stderr, "Kernel image must be specified\n");\n<26> \n<27> exit(1);\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> if (!info->secondary_cpu_reset_hook) {\n<34> \n<35> info->secondary_cpu_reset_hook = default_reset_secondary;\n<36> \n<37> }\n<38> \n<39> if (!info->write_secondary_boot) {\n<40> \n<41> info->write_secondary_boot = default_write_secondary;\n<42> \n<43> }\n<44> \n<45> \n<46> \n<47> if (info->nb_cpus == 0)\n<48> \n<49> info->nb_cpus = 1;\n<50> \n<51> \n<52> \n<53> #ifdef TARGET_WORDS_BIGENDIAN\n<54> \n<55> big_endian = 1;\n<56> \n<57> #else\n<58> \n<59> big_endian = 0;\n<60> \n<61> #endif\n<62> \n<63> \n<64> \n<65> /* Assume that raw images are linux kernels, and ELF images are not.  */\n<66> \n<67> kernel_size = load_elf(info->kernel_filename, NULL, NULL, &elf_entry,\n<68> \n<69> NULL, NULL, big_endian, ELF_MACHINE, 1);\n<70> \n<71> entry = elf_entry;\n<72> \n<73> if (kernel_size < 0) {\n<74> \n<75> kernel_size = load_uimage(info->kernel_filename, &entry, NULL,\n<76> \n<77> &is_linux);\n<78> \n<79> }\n<80> \n<81> if (kernel_size < 0) {\n<82> \n<83> entry = info->loader_start + KERNEL_LOAD_ADDR;\n<84> \n<85> kernel_size = load_image_targphys(info->kernel_filename, entry,\n<86> \n<87> ram_size - KERNEL_LOAD_ADDR);\n<88> \n<89> is_linux = 1;\n<90> \n<91> }\n<92> \n<93> if (kernel_size < 0) {\n<94> \n<95> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<96> \n<97> info->kernel_filename);\n<98> \n<99> exit(1);\n<100> \n<101> }\n<102> \n<103> info->entry = entry;\n<104> \n<105> if (is_linux) {\n<106> \n<107> if (info->initrd_filename) {\n<108> \n<109> initrd_size = load_image_targphys(info->initrd_filename,\n<110> \n<111> info->loader_start\n<112> \n<113> + INITRD_LOAD_ADDR,\n<114> \n<115> ram_size - INITRD_LOAD_ADDR);\n<116> \n<117> if (initrd_size < 0) {\n<118> \n<119> fprintf(stderr, "qemu: could not load initrd '%s'\n",\n<120> \n<121> info->initrd_filename);\n<122> \n<123> exit(1);\n<124> \n<125> }\n<126> \n<127> } else {\n<128> \n<129> initrd_size = 0;\n<130> \n<131> }\n<132> \n<133> bootloader[1] |= info->board_id & 0xff;\n<134> \n<135> bootloader[2] |= (info->board_id >> 8) & 0xff;\n<136> \n<137> bootloader[5] = info->loader_start + KERNEL_ARGS_ADDR;\n<138> \n<139> bootloader[6] = entry;\n<140> \n<141> for (n = 0; n < sizeof(bootloader) / 4; n++) {\n<142> \n<143> bootloader[n] = tswap32(bootloader[n]);\n<144> \n<145> }\n<146> \n<147> rom_add_blob_fixed("bootloader", bootloader, sizeof(bootloader),\n<148> \n<149> info->loader_start);\n<150> \n<151> if (info->nb_cpus > 1) {\n<152> \n<153> info->write_secondary_boot(env, info);\n<154> \n<155> }\n<156> \n<157> info->initrd_size = initrd_size;\n<158> \n<159> }\n<160> \n<161> info->is_linux = is_linux;\n<162> \n<163> \n<164> \n<165> for (; env; env = env->next_cpu) {\n<166> \n<167> env->boot_info = info;\n<168> \n<169> qemu_register_reset(do_cpu_reset, env);\n<170> \n<171> }\n<172> \n<173> }\n<174> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline int dmg_read_chunk(BlockDriverState *bs, uint64_t sector_num)\n<2> \n<3> {\n<4> \n<5> BDRVDMGState *s = bs->opaque;\n<6> \n<7> \n<8> \n<9> if (!is_sector_in_chunk(s, s->current_chunk, sector_num)) {\n<10> \n<11> int ret;\n<12> \n<13> uint32_t chunk = search_chunk(s, sector_num);\n<14> \n<15> #ifdef CONFIG_BZIP2\n<16> \n<17> uint64_t total_out;\n<18> \n<19> #endif\n<20> \n<21> \n<22> \n<23> if (chunk >= s->n_chunks) {\n<24> \n<25> return -1;\n<26> \n<27> }\n<28> \n<29> \n<30> \n<31> s->current_chunk = s->n_chunks;\n<32> \n<33> switch (s->types[chunk]) { /* block entry type */\n<34> \n<35> case 0x80000005: { /* zlib compressed */\n<36> \n<37> /* we need to buffer, because only the chunk as whole can be\n<38> \n<39> * inflated. */\n<40> \n<41> ret = bdrv_pread(bs->file, s->offsets[chunk],\n<42> \n<43> s->compressed_chunk, s->lengths[chunk]);\n<44> \n<45> if (ret != s->lengths[chunk]) {\n<46> \n<47> return -1;\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> s->zstream.next_in = s->compressed_chunk;\n<54> \n<55> s->zstream.avail_in = s->lengths[chunk];\n<56> \n<57> s->zstream.next_out = s->uncompressed_chunk;\n<58> \n<59> s->zstream.avail_out = 512 * s->sectorcounts[chunk];\n<60> \n<61> ret = inflateReset(&s->zstream);\n<62> \n<63> if (ret != Z_OK) {\n<64> \n<65> return -1;\n<66> \n<67> }\n<68> \n<69> ret = inflate(&s->zstream, Z_FINISH);\n<70> \n<71> if (ret != Z_STREAM_END ||\n<72> \n<73> s->zstream.total_out != 512 * s->sectorcounts[chunk]) {\n<74> \n<75> return -1;\n<76> \n<77> }\n<78> \n<79> break; }\n<80> \n<81> #ifdef CONFIG_BZIP2\n<82> \n<83> case 0x80000006: /* bzip2 compressed */\n<84> \n<85> /* we need to buffer, because only the chunk as whole can be\n<86> \n<87> * inflated. */\n<88> \n<89> ret = bdrv_pread(bs->file, s->offsets[chunk],\n<90> \n<91> s->compressed_chunk, s->lengths[chunk]);\n<92> \n<93> if (ret != s->lengths[chunk]) {\n<94> \n<95> return -1;\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> ret = BZ2_bzDecompressInit(&s->bzstream, 0, 0);\n<102> \n<103> if (ret != BZ_OK) {\n<104> \n<105> return -1;\n<106> \n<107> }\n<108> \n<109> s->bzstream.next_in = (char *)s->compressed_chunk;\n<110> \n<111> s->bzstream.avail_in = (unsigned int) s->lengths[chunk];\n<112> \n<113> s->bzstream.next_out = (char *)s->uncompressed_chunk;\n<114> \n<115> s->bzstream.avail_out = (unsigned int) 512 * s->sectorcounts[chunk];\n<116> \n<117> ret = BZ2_bzDecompress(&s->bzstream);\n<118> \n<119> total_out = ((uint64_t)s->bzstream.total_out_hi32 << 32) +\n<120> \n<121> s->bzstream.total_out_lo32;\n<122> \n<123> BZ2_bzDecompressEnd(&s->bzstream);\n<124> \n<125> if (ret != BZ_STREAM_END ||\n<126> \n<127> total_out != 512 * s->sectorcounts[chunk]) {\n<128> \n<129> return -1;\n<130> \n<131> }\n<132> \n<133> break;\n<134> \n<135> #endif /* CONFIG_BZIP2 */\n<136> \n<137> case 1: /* copy */\n<138> \n<139> ret = bdrv_pread(bs->file, s->offsets[chunk],\n<140> \n<141> s->uncompressed_chunk, s->lengths[chunk]);\n<142> \n<143> if (ret != s->lengths[chunk]) {\n<144> \n<145> return -1;\n<146> \n<147> }\n<148> \n<149> break;\n<150> \n<151> case 2: /* zero */\n<152> \n<153> memset(s->uncompressed_chunk, 0, 512 * s->sectorcounts[chunk]);\n<154> \n<155> break;\n<156> \n<157> }\n<158> \n<159> s->current_chunk = chunk;\n<160> \n<161> }\n<162> \n<163> return 0;\n<164> \n<165> }\n<166> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void qdm2_decode_super_block(QDM2Context *q)\n<2> \n<3> {\n<4> \n<5> GetBitContext gb;\n<6> \n<7> QDM2SubPacket header, *packet;\n<8> \n<9> int i, packet_bytes, sub_packet_size, sub_packets_D;\n<10> \n<11> unsigned int next_index = 0;\n<12> \n<13> \n<14> \n<15> memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1));\n<16> \n<17> memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid));\n<18> \n<19> memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2));\n<20> \n<21> \n<22> \n<23> q->sub_packets_B = 0;\n<24> \n<25> sub_packets_D    = 0;\n<26> \n<27> \n<28> \n<29> average_quantized_coeffs(q); // average elements in quantized_coeffs[max_ch][10][8]\n<30> \n<31> \n<32> \n<33> init_get_bits(&gb, q->compressed_data, q->compressed_size * 8);\n<34> \n<35> qdm2_decode_sub_packet_header(&gb, &header);\n<36> \n<37> \n<38> \n<39> if (header.type < 2 || header.type >= 8) {\n<40> \n<41> q->has_errors = 1;\n<42> \n<43> av_log(NULL, AV_LOG_ERROR, "bad superblock type\n");\n<44> \n<45> return;\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> q->superblocktype_2_3 = (header.type == 2 || header.type == 3);\n<52> \n<53> packet_bytes          = (q->compressed_size - get_bits_count(&gb) / 8);\n<54> \n<55> \n<56> \n<57> init_get_bits(&gb, header.data, header.size * 8);\n<58> \n<59> \n<60> \n<61> if (header.type == 2 || header.type == 4 || header.type == 5) {\n<62> \n<63> int csum = 257 * get_bits(&gb, 8);\n<64> \n<65> csum += 2 * get_bits(&gb, 8);\n<66> \n<67> \n<68> \n<69> csum = qdm2_packet_checksum(q->compressed_data, q->checksum_size, csum);\n<70> \n<71> \n<72> \n<73> if (csum != 0) {\n<74> \n<75> q->has_errors = 1;\n<76> \n<77> av_log(NULL, AV_LOG_ERROR, "bad packet checksum\n");\n<78> \n<79> return;\n<80> \n<81> }\n<82> \n<83> }\n<84> \n<85> \n<86> \n<87> q->sub_packet_list_B[0].packet = NULL;\n<88> \n<89> q->sub_packet_list_D[0].packet = NULL;\n<90> \n<91> \n<92> \n<93> for (i = 0; i < 6; i++)\n<94> \n<95> if (--q->fft_level_exp[i] < 0)\n<96> \n<97> q->fft_level_exp[i] = 0;\n<98> \n<99> \n<100> \n<101> for (i = 0; packet_bytes > 0; i++) {\n<102> \n<103> int j;\n<104> \n<105> \n<106> \n<107> if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) {\n<108> \n<109> SAMPLES_NEEDED_2("too many packet bytes");\n<110> \n<111> return;\n<112> \n<113> }\n<114> \n<115> \n<116> \n<117> q->sub_packet_list_A[i].next = NULL;\n<118> \n<119> \n<120> \n<121> if (i > 0) {\n<122> \n<123> q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i];\n<124> \n<125> \n<126> \n<127> /* seek to next block */\n<128> \n<129> init_get_bits(&gb, header.data, header.size * 8);\n<130> \n<131> skip_bits(&gb, next_index * 8);\n<132> \n<133> \n<134> \n<135> if (next_index >= header.size)\n<136> \n<137> break;\n<138> \n<139> }\n<140> \n<141> \n<142> \n<143> /* decode subpacket */\n<144> \n<145> packet = &q->sub_packets[i];\n<146> \n<147> qdm2_decode_sub_packet_header(&gb, packet);\n<148> \n<149> next_index      = packet->size + get_bits_count(&gb) / 8;\n<150> \n<151> sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2;\n<152> \n<153> \n<154> \n<155> if (packet->type == 0)\n<156> \n<157> break;\n<158> \n<159> \n<160> \n<161> if (sub_packet_size > packet_bytes) {\n<162> \n<163> if (packet->type != 10 && packet->type != 11 && packet->type != 12)\n<164> \n<165> break;\n<166> \n<167> packet->size += packet_bytes - sub_packet_size;\n<168> \n<169> }\n<170> \n<171> \n<172> \n<173> packet_bytes -= sub_packet_size;\n<174> \n<175> \n<176> \n<177> /* add subpacket to 'all subpackets' list */\n<178> \n<179> q->sub_packet_list_A[i].packet = packet;\n<180> \n<181> \n<182> \n<183> /* add subpacket to related list */\n<184> \n<185> if (packet->type == 8) {\n<186> \n<187> SAMPLES_NEEDED_2("packet type 8");\n<188> \n<189> return;\n<190> \n<191> } else if (packet->type >= 9 && packet->type <= 12) {\n<192> \n<193> /* packets for MPEG Audio like Synthesis Filter */\n<194> \n<195> QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet);\n<196> \n<197> } else if (packet->type == 13) {\n<198> \n<199> for (j = 0; j < 6; j++)\n<200> \n<201> q->fft_level_exp[j] = get_bits(&gb, 6);\n<202> \n<203> } else if (packet->type == 14) {\n<204> \n<205> for (j = 0; j < 6; j++)\n<206> \n<207> q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2);\n<208> \n<209> } else if (packet->type == 15) {\n<210> \n<211> SAMPLES_NEEDED_2("packet type 15")\n<212> \n<213> return;\n<214> \n<215> } else if (packet->type >= 16 && packet->type < 48 &&\n<216> \n<217> !fft_subpackets[packet->type - 16]) {\n<218> \n<219> /* packets for FFT */\n<220> \n<221> QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet);\n<222> \n<223> }\n<224> \n<225> } // Packet bytes loop\n<226> \n<227> \n<228> \n<229> if (q->sub_packet_list_D[0].packet != NULL) {\n<230> \n<231> process_synthesis_subpackets(q, q->sub_packet_list_D);\n<232> \n<233> q->do_synth_filter = 1;\n<234> \n<235> } else if (q->do_synth_filter) {\n<236> \n<237> process_subpacket_10(q, NULL);\n<238> \n<239> process_subpacket_11(q, NULL);\n<240> \n<241> process_subpacket_12(q, NULL);\n<242> \n<243> }\n<244> \n<245> }\n<246> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n<2> \n<3> {\n<4> \n<5> int size, l;\n<6> \n<7> \n<8> \n<9> if (f->is_write)\n<10> \n<11> abort();\n<12> \n<13> \n<14> \n<15> size = size1;\n<16> \n<17> while (size > 0) {\n<18> \n<19> l = f->buf_size - f->buf_index;\n<20> \n<21> if (l == 0) {\n<22> \n<23> qemu_fill_buffer(f);\n<24> \n<25> l = f->buf_size - f->buf_index;\n<26> \n<27> if (l == 0)\n<28> \n<29> break;\n<30> \n<31> }\n<32> \n<33> if (l > size)\n<34> \n<35> l = size;\n<36> \n<37> memcpy(buf, f->buf + f->buf_index, l);\n<38> \n<39> f->buf_index += l;\n<40> \n<41> buf += l;\n<42> \n<43> size -= l;\n<44> \n<45> }\n<46> \n<47> return size1 - size;\n<48> \n<49> }\n<50> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int svq1_encode_plane ( SVQ1Context * s , int plane , unsigned char * src_plane , unsigned char * ref_plane , unsigned char * decoded_plane , int width , int height , int src_stride , int stride ) {\n<2> int x , y ;\n<3> int i ;\n<4> int block_width , block_height ;\n<5> int level ;\n<6> int threshold [ 6 ] ;\n<7> uint8_t * src = s -> scratchbuf + stride * 16 ;\n<8> const int lambda = ( s -> picture . quality * s -> picture . quality ) >> ( 2 * FF_LAMBDA_SHIFT ) ;\n<9> threshold [ 5 ] = QUALITY_THRESHOLD ;\n<10> for ( level = 4 ;\n<11> level >= 0 ;\n<12> level -- ) threshold [ level ] = threshold [ level + 1 ] * THRESHOLD_MULTIPLIER ;\n<13> block_width = ( width + 15 ) / 16 ;\n<14> block_height = ( height + 15 ) / 16 ;\n<15> if ( s -> picture . pict_type == AV_PICTURE_TYPE_P ) {\n<16> s -> m . avctx = s -> avctx ;\n<17> s -> m . current_picture_ptr = & s -> m . current_picture ;\n<18> s -> m . last_picture_ptr = & s -> m . last_picture ;\n<19> s -> m . last_picture . f . data [ 0 ] = ref_plane ;\n<20> s -> m . linesize = s -> m . last_picture . f . linesize [ 0 ] = s -> m . new_picture . f . linesize [ 0 ] = s -> m . current_picture . f . linesize [ 0 ] = stride ;\n<21> s -> m . width = width ;\n<22> s -> m . height = height ;\n<23> s -> m . mb_width = block_width ;\n<24> s -> m . mb_height = block_height ;\n<25> s -> m . mb_stride = s -> m . mb_width + 1 ;\n<26> s -> m . b8_stride = 2 * s -> m . mb_width + 1 ;\n<27> s -> m . f_code = 1 ;\n<28> s -> m . pict_type = s -> picture . pict_type ;\n<29> s -> m . me_method = s -> avctx -> me_method ;\n<30> s -> m . me . scene_change_score = 0 ;\n<31> s -> m . flags = s -> avctx -> flags ;\n<32> s -> m . lambda = s -> picture . quality ;\n<33> s -> m . qscale = s -> m . lambda * 139 + FF_LAMBDA_SCALE * 64 >> FF_LAMBDA_SHIFT + 7 ;\n<34> s -> m . lambda2 = s -> m . lambda * s -> m . lambda + FF_LAMBDA_SCALE / 2 >> FF_LAMBDA_SHIFT ;\n<35> if ( ! s -> motion_val8 [ plane ] ) {\n<36> s -> motion_val8 [ plane ] = av_mallocz ( ( s -> m . b8_stride * block_height * 2 + 2 ) * 2 * sizeof ( int16_t ) ) ;\n<37> s -> motion_val16 [ plane ] = av_mallocz ( ( s -> m . mb_stride * ( block_height + 2 ) + 1 ) * 2 * sizeof ( int16_t ) ) ;\n<38> }\n<39> s -> m . mb_type = s -> mb_type ;\n<40> s -> m . current_picture . mb_mean = ( uint8_t * ) s -> dummy ;\n<41> s -> m . current_picture . mb_var = ( uint16_t * ) s -> dummy ;\n<42> s -> m . current_picture . mc_mb_var = ( uint16_t * ) s -> dummy ;\n<43> s -> m . current_picture . f . mb_type = s -> dummy ;\n<44> s -> m . current_picture . f . motion_val [ 0 ] = s -> motion_val8 [ plane ] + 2 ;\n<45> s -> m . p_mv_table = s -> motion_val16 [ plane ] + s -> m . mb_stride + 1 ;\n<46> s -> m . dsp = s -> dsp ;\n<47> ff_init_me ( & s -> m ) ;\n<48> s -> m . me . dia_size = s -> avctx -> dia_size ;\n<49> s -> m . first_slice_line = 1 ;\n<50> for ( y = 0 ;\n<51> y < block_height ;\n<52> y ++ ) {\n<53> s -> m . new_picture . f . data [ 0 ] = src - y * 16 * stride ;\n<54> s -> m . mb_y = y ;\n<55> for ( i = 0 ;\n<56> i < 16 && i + 16 * y < height ;\n<57> i ++ ) {\n<58> memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n<59> for ( x = width ;\n<60> x < 16 * block_width ;\n<61> x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n<62> }\n<63> for ( ;\n<64> i < 16 && i + 16 * y < 16 * block_height ;\n<65> i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n<66> for ( x = 0 ;\n<67> x < block_width ;\n<68> x ++ ) {\n<69> s -> m . mb_x = x ;\n<70> ff_init_block_index ( & s -> m ) ;\n<71> ff_update_block_index ( & s -> m ) ;\n<72> ff_estimate_p_frame_motion ( & s -> m , x , y ) ;\n<73> }\n<74> s -> m . first_slice_line = 0 ;\n<75> }\n<76> ff_fix_long_p_mvs ( & s -> m ) ;\n<77> ff_fix_long_mvs ( & s -> m , NULL , 0 , s -> m . p_mv_table , s -> m . f_code , CANDIDATE_MB_TYPE_INTER , 0 ) ;\n<78> }\n<79> s -> m . first_slice_line = 1 ;\n<80> for ( y = 0 ;\n<81> y < block_height ;\n<82> y ++ ) {\n<83> for ( i = 0 ;\n<84> i < 16 && i + 16 * y < height ;\n<85> i ++ ) {\n<86> memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n<87> for ( x = width ;\n<88> x < 16 * block_width ;\n<89> x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n<90> }\n<91> for ( ;\n<92> i < 16 && i + 16 * y < 16 * block_height ;\n<93> i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n<94> s -> m . mb_y = y ;\n<95> for ( x = 0 ;\n<96> x < block_width ;\n<97> x ++ ) {\n<98> uint8_t reorder_buffer [ 3 ] [ 6 ] [ 7 * 32 ] ;\n<99> int count [ 3 ] [ 6 ] ;\n<100> int offset = y * 16 * stride + x * 16 ;\n<101> uint8_t * decoded = decoded_plane + offset ;\n<102> uint8_t * ref = ref_plane + offset ;\n<103> int score [ 4 ] = {\n<104> 0 , 0 , 0 , 0 }\n<105> , best ;\n<106> uint8_t * temp = s -> scratchbuf ;\n<107> if ( s -> pb . buf_end - s -> pb . buf - ( put_bits_count ( & s -> pb ) >> 3 ) < 3000 ) {\n<108> av_log ( s -> avctx , AV_LOG_ERROR , "encoded frame too large\n" ) ;\n<109> return - 1 ;\n<110> }\n<111> s -> m . mb_x = x ;\n<112> ff_init_block_index ( & s -> m ) ;\n<113> ff_update_block_index ( & s -> m ) ;\n<114> if ( s -> picture . pict_type == AV_PICTURE_TYPE_I || ( s -> m . mb_type [ x + y * s -> m . mb_stride ] & CANDIDATE_MB_TYPE_INTRA ) ) {\n<115> for ( i = 0 ;\n<116> i < 6 ;\n<117> i ++ ) init_put_bits ( & s -> reorder_pb [ i ] , reorder_buffer [ 0 ] [ i ] , 7 * 32 ) ;\n<118> if ( s -> picture . pict_type == AV_PICTURE_TYPE_P ) {\n<119> const uint8_t * vlc = ff_svq1_block_type_vlc [ SVQ1_BLOCK_INTRA ] ;\n<120> put_bits ( & s -> reorder_pb [ 5 ] , vlc [ 1 ] , vlc [ 0 ] ) ;\n<121> score [ 0 ] = vlc [ 1 ] * lambda ;\n<122> }\n<123> score [ 0 ] += encode_block ( s , src + 16 * x , NULL , temp , stride , 5 , 64 , lambda , 1 ) ;\n<124> for ( i = 0 ;\n<125> i < 6 ;\n<126> i ++ ) {\n<127> count [ 0 ] [ i ] = put_bits_count ( & s -> reorder_pb [ i ] ) ;\n<128> flush_put_bits ( & s -> reorder_pb [ i ] ) ;\n<129> }\n<130> }\n<131> else score [ 0 ] = INT_MAX ;\n<132> best = 0 ;\n<133> if ( s -> picture . pict_type == AV_PICTURE_TYPE_P ) {\n<134> const uint8_t * vlc = ff_svq1_block_type_vlc [ SVQ1_BLOCK_INTER ] ;\n<135> int mx , my , pred_x , pred_y , dxy ;\n<136> int16_t * motion_ptr ;\n<137> motion_ptr = ff_h263_pred_motion ( & s -> m , 0 , 0 , & pred_x , & pred_y ) ;\n<138> if ( s -> m . mb_type [ x + y * s -> m . mb_stride ] & CANDIDATE_MB_TYPE_INTER ) {\n<139> for ( i = 0 ;\n<140> i < 6 ;\n<141> i ++ ) init_put_bits ( & s -> reorder_pb [ i ] , reorder_buffer [ 1 ] [ i ] , 7 * 32 ) ;\n<142> put_bits ( & s -> reorder_pb [ 5 ] , vlc [ 1 ] , vlc [ 0 ] ) ;\n<143> s -> m . pb = s -> reorder_pb [ 5 ] ;\n<144> mx = motion_ptr [ 0 ] ;\n<145> my = motion_ptr [ 1 ] ;\n<146> assert ( mx >= - 32 && mx <= 31 ) ;\n<147> assert ( my >= - 32 && my <= 31 ) ;\n<148> assert ( pred_x >= - 32 && pred_x <= 31 ) ;\n<149> assert ( pred_y >= - 32 && pred_y <= 31 ) ;\n<150> ff_h263_encode_motion ( & s -> m , mx - pred_x , 1 ) ;\n<151> ff_h263_encode_motion ( & s -> m , my - pred_y , 1 ) ;\n<152> s -> reorder_pb [ 5 ] = s -> m . pb ;\n<153> score [ 1 ] += lambda * put_bits_count ( & s -> reorder_pb [ 5 ] ) ;\n<154> dxy = ( mx & 1 ) + 2 * ( my & 1 ) ;\n<155> s -> dsp . put_pixels_tab [ 0 ] [ dxy ] ( temp + 16 , ref + ( mx >> 1 ) + stride * ( my >> 1 ) , stride , 16 ) ;\n<156> score [ 1 ] += encode_block ( s , src + 16 * x , temp + 16 , decoded , stride , 5 , 64 , lambda , 0 ) ;\n<157> best = score [ 1 ] <= score [ 0 ] ;\n<158> vlc = ff_svq1_block_type_vlc [ SVQ1_BLOCK_SKIP ] ;\n<159> score [ 2 ] = s -> dsp . sse [ 0 ] ( NULL , src + 16 * x , ref , stride , 16 ) ;\n<160> score [ 2 ] += vlc [ 1 ] * lambda ;\n<161> if ( score [ 2 ] < score [ best ] && mx == 0 && my == 0 ) {\n<162> best = 2 ;\n<163> s -> dsp . put_pixels_tab [ 0 ] [ 0 ] ( decoded , ref , stride , 16 ) ;\n<164> for ( i = 0 ;\n<165> i < 6 ;\n<166> i ++ ) count [ 2 ] [ i ] = 0 ;\n<167> put_bits ( & s -> pb , vlc [ 1 ] , vlc [ 0 ] ) ;\n<168> }\n<169> }\n<170> if ( best == 1 ) {\n<171> for ( i = 0 ;\n<172> i < 6 ;\n<173> i ++ ) {\n<174> count [ 1 ] [ i ] = put_bits_count ( & s -> reorder_pb [ i ] ) ;\n<175> flush_put_bits ( & s -> reorder_pb [ i ] ) ;\n<176> }\n<177> }\n<178> else {\n<179> motion_ptr [ 0 ] = motion_ptr [ 1 ] = motion_ptr [ 2 ] = motion_ptr [ 3 ] = motion_ptr [ 0 + 2 * s -> m . b8_stride ] = motion_ptr [ 1 + 2 * s -> m . b8_stride ] = motion_ptr [ 2 + 2 * s -> m . b8_stride ] = motion_ptr [ 3 + 2 * s -> m . b8_stride ] = 0 ;\n<180> }\n<181> }\n<182> s -> rd_total += score [ best ] ;\n<183> for ( i = 5 ;\n<184> i >= 0 ;\n<185> i -- ) avpriv_copy_bits ( & s -> pb , reorder_buffer [ best ] [ i ] , count [ best ] [ i ] ) ;\n<186> if ( best == 0 ) s -> dsp . put_pixels_tab [ 0 ] [ 0 ] ( decoded , temp , stride , 16 ) ;\n<187> }\n<188> s -> m . first_slice_line = 0 ;\n<189> }\n<190> return 0 ;\n<191> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int gdb_handle_packet(GDBState *s, const char *line_buf)\n<2> \n<3> {\n<4> \n<5> CPUState *env;\n<6> \n<7> const char *p;\n<8> \n<9> int ch, reg_size, type, res, thread;\n<10> \n<11> char buf[MAX_PACKET_LENGTH];\n<12> \n<13> uint8_t mem_buf[MAX_PACKET_LENGTH];\n<14> \n<15> uint8_t *registers;\n<16> \n<17> target_ulong addr, len;\n<18> \n<19> \n<20> \n<21> #ifdef DEBUG_GDB\n<22> \n<23> printf("command='%s'\n", line_buf);\n<24> \n<25> #endif\n<26> \n<27> p = line_buf;\n<28> \n<29> ch = *p++;\n<30> \n<31> switch(ch) {\n<32> \n<33> case '?':\n<34> \n<35> /* TODO: Make this return the correct value for user-mode.  */\n<36> \n<37> snprintf(buf, sizeof(buf), "T%02xthread:%02x;", GDB_SIGNAL_TRAP,\n<38> \n<39> s->c_cpu->cpu_index+1);\n<40> \n<41> put_packet(s, buf);\n<42> \n<43> /* Remove all the breakpoints when this query is issued,\n<44> \n<45> * because gdb is doing and initial connect and the state\n<46> \n<47> * should be cleaned up.\n<48> \n<49> */\n<50> \n<51> gdb_breakpoint_remove_all();\n<52> \n<53> break;\n<54> \n<55> case 'c':\n<56> \n<57> if (*p != '\0') {\n<58> \n<59> addr = strtoull(p, (char **)&p, 16);\n<60> \n<61> #if defined(TARGET_I386)\n<62> \n<63> s->c_cpu->eip = addr;\n<64> \n<65> #elif defined (TARGET_PPC)\n<66> \n<67> s->c_cpu->nip = addr;\n<68> \n<69> #elif defined (TARGET_SPARC)\n<70> \n<71> s->c_cpu->pc = addr;\n<72> \n<73> s->c_cpu->npc = addr + 4;\n<74> \n<75> #elif defined (TARGET_ARM)\n<76> \n<77> s->c_cpu->regs[15] = addr;\n<78> \n<79> #elif defined (TARGET_SH4)\n<80> \n<81> s->c_cpu->pc = addr;\n<82> \n<83> #elif defined (TARGET_MIPS)\n<84> \n<85> s->c_cpu->active_tc.PC = addr;\n<86> \n<87> #elif defined (TARGET_CRIS)\n<88> \n<89> s->c_cpu->pc = addr;\n<90> \n<91> #elif defined (TARGET_ALPHA)\n<92> \n<93> s->c_cpu->pc = addr;\n<94> \n<95> #endif\n<96> \n<97> }\n<98> \n<99> s->signal = 0;\n<100> \n<101> gdb_continue(s);\n<102> \n<103> return RS_IDLE;\n<104> \n<105> case 'C':\n<106> \n<107> s->signal = gdb_signal_to_target (strtoul(p, (char **)&p, 16));\n<108> \n<109> if (s->signal == -1)\n<110> \n<111> s->signal = 0;\n<112> \n<113> gdb_continue(s);\n<114> \n<115> return RS_IDLE;\n<116> \n<117> case 'k':\n<118> \n<119> /* Kill the target */\n<120> \n<121> fprintf(stderr, "\nQEMU: Terminated via GDBstub\n");\n<122> \n<123> exit(0);\n<124> \n<125> case 'D':\n<126> \n<127> /* Detach packet */\n<128> \n<129> gdb_breakpoint_remove_all();\n<130> \n<131> gdb_continue(s);\n<132> \n<133> put_packet(s, "OK");\n<134> \n<135> break;\n<136> \n<137> case 's':\n<138> \n<139> if (*p != '\0') {\n<140> \n<141> addr = strtoull(p, (char **)&p, 16);\n<142> \n<143> #if defined(TARGET_I386)\n<144> \n<145> s->c_cpu->eip = addr;\n<146> \n<147> #elif defined (TARGET_PPC)\n<148> \n<149> s->c_cpu->nip = addr;\n<150> \n<151> #elif defined (TARGET_SPARC)\n<152> \n<153> s->c_cpu->pc = addr;\n<154> \n<155> s->c_cpu->npc = addr + 4;\n<156> \n<157> #elif defined (TARGET_ARM)\n<158> \n<159> s->c_cpu->regs[15] = addr;\n<160> \n<161> #elif defined (TARGET_SH4)\n<162> \n<163> s->c_cpu->pc = addr;\n<164> \n<165> #elif defined (TARGET_MIPS)\n<166> \n<167> s->c_cpu->active_tc.PC = addr;\n<168> \n<169> #elif defined (TARGET_CRIS)\n<170> \n<171> s->c_cpu->pc = addr;\n<172> \n<173> #elif defined (TARGET_ALPHA)\n<174> \n<175> s->c_cpu->pc = addr;\n<176> \n<177> #endif\n<178> \n<179> }\n<180> \n<181> cpu_single_step(s->c_cpu, sstep_flags);\n<182> \n<183> gdb_continue(s);\n<184> \n<185> return RS_IDLE;\n<186> \n<187> case 'F':\n<188> \n<189> {\n<190> \n<191> target_ulong ret;\n<192> \n<193> target_ulong err;\n<194> \n<195> \n<196> \n<197> ret = strtoull(p, (char **)&p, 16);\n<198> \n<199> if (*p == ',') {\n<200> \n<201> p++;\n<202> \n<203> err = strtoull(p, (char **)&p, 16);\n<204> \n<205> } else {\n<206> \n<207> err = 0;\n<208> \n<209> }\n<210> \n<211> if (*p == ',')\n<212> \n<213> p++;\n<214> \n<215> type = *p;\n<216> \n<217> if (gdb_current_syscall_cb)\n<218> \n<219> gdb_current_syscall_cb(s->c_cpu, ret, err);\n<220> \n<221> if (type == 'C') {\n<222> \n<223> put_packet(s, "T02");\n<224> \n<225> } else {\n<226> \n<227> gdb_continue(s);\n<228> \n<229> }\n<230> \n<231> }\n<232> \n<233> break;\n<234> \n<235> case 'g':\n<236> \n<237> len = 0;\n<238> \n<239> for (addr = 0; addr < num_g_regs; addr++) {\n<240> \n<241> reg_size = gdb_read_register(s->g_cpu, mem_buf + len, addr);\n<242> \n<243> len += reg_size;\n<244> \n<245> }\n<246> \n<247> memtohex(buf, mem_buf, len);\n<248> \n<249> put_packet(s, buf);\n<250> \n<251> break;\n<252> \n<253> case 'G':\n<254> \n<255> registers = mem_buf;\n<256> \n<257> len = strlen(p) / 2;\n<258> \n<259> hextomem((uint8_t *)registers, p, len);\n<260> \n<261> for (addr = 0; addr < num_g_regs && len > 0; addr++) {\n<262> \n<263> reg_size = gdb_write_register(s->g_cpu, registers, addr);\n<264> \n<265> len -= reg_size;\n<266> \n<267> registers += reg_size;\n<268> \n<269> }\n<270> \n<271> put_packet(s, "OK");\n<272> \n<273> break;\n<274> \n<275> case 'm':\n<276> \n<277> addr = strtoull(p, (char **)&p, 16);\n<278> \n<279> if (*p == ',')\n<280> \n<281> p++;\n<282> \n<283> len = strtoull(p, NULL, 16);\n<284> \n<285> if (cpu_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 0) != 0) {\n<286> \n<287> put_packet (s, "E14");\n<288> \n<289> } else {\n<290> \n<291> memtohex(buf, mem_buf, len);\n<292> \n<293> put_packet(s, buf);\n<294> \n<295> }\n<296> \n<297> break;\n<298> \n<299> case 'M':\n<300> \n<301> addr = strtoull(p, (char **)&p, 16);\n<302> \n<303> if (*p == ',')\n<304> \n<305> p++;\n<306> \n<307> len = strtoull(p, (char **)&p, 16);\n<308> \n<309> if (*p == ':')\n<310> \n<311> p++;\n<312> \n<313> hextomem(mem_buf, p, len);\n<314> \n<315> if (cpu_memory_rw_debug(s->g_cpu, addr, mem_buf, len, 1) != 0)\n<316> \n<317> put_packet(s, "E14");\n<318> \n<319> else\n<320> \n<321> put_packet(s, "OK");\n<322> \n<323> break;\n<324> \n<325> case 'p':\n<326> \n<327> /* Older gdb are really dumb, and don't use 'g' if 'p' is avaialable.\n<328> \n<329> This works, but can be very slow.  Anything new enough to\n<330> \n<331> understand XML also knows how to use this properly.  */\n<332> \n<333> if (!gdb_has_xml)\n<334> \n<335> goto unknown_command;\n<336> \n<337> addr = strtoull(p, (char **)&p, 16);\n<338> \n<339> reg_size = gdb_read_register(s->g_cpu, mem_buf, addr);\n<340> \n<341> if (reg_size) {\n<342> \n<343> memtohex(buf, mem_buf, reg_size);\n<344> \n<345> put_packet(s, buf);\n<346> \n<347> } else {\n<348> \n<349> put_packet(s, "E14");\n<350> \n<351> }\n<352> \n<353> break;\n<354> \n<355> case 'P':\n<356> \n<357> if (!gdb_has_xml)\n<358> \n<359> goto unknown_command;\n<360> \n<361> addr = strtoull(p, (char **)&p, 16);\n<362> \n<363> if (*p == '=')\n<364> \n<365> p++;\n<366> \n<367> reg_size = strlen(p) / 2;\n<368> \n<369> hextomem(mem_buf, p, reg_size);\n<370> \n<371> gdb_write_register(s->g_cpu, mem_buf, addr);\n<372> \n<373> put_packet(s, "OK");\n<374> \n<375> break;\n<376> \n<377> case 'Z':\n<378> \n<379> case 'z':\n<380> \n<381> type = strtoul(p, (char **)&p, 16);\n<382> \n<383> if (*p == ',')\n<384> \n<385> p++;\n<386> \n<387> addr = strtoull(p, (char **)&p, 16);\n<388> \n<389> if (*p == ',')\n<390> \n<391> p++;\n<392> \n<393> len = strtoull(p, (char **)&p, 16);\n<394> \n<395> if (ch == 'Z')\n<396> \n<397> res = gdb_breakpoint_insert(addr, len, type);\n<398> \n<399> else\n<400> \n<401> res = gdb_breakpoint_remove(addr, len, type);\n<402> \n<403> if (res >= 0)\n<404> \n<405> put_packet(s, "OK");\n<406> \n<407> else if (res == -ENOSYS)\n<408> \n<409> put_packet(s, "");\n<410> \n<411> else\n<412> \n<413> put_packet(s, "E22");\n<414> \n<415> break;\n<416> \n<417> case 'H':\n<418> \n<419> type = *p++;\n<420> \n<421> thread = strtoull(p, (char **)&p, 16);\n<422> \n<423> if (thread == -1 || thread == 0) {\n<424> \n<425> put_packet(s, "OK");\n<426> \n<427> break;\n<428> \n<429> }\n<430> \n<431> for (env = first_cpu; env != NULL; env = env->next_cpu)\n<432> \n<433> if (env->cpu_index + 1 == thread)\n<434> \n<435> break;\n<436> \n<437> if (env == NULL) {\n<438> \n<439> put_packet(s, "E22");\n<440> \n<441> break;\n<442> \n<443> }\n<444> \n<445> switch (type) {\n<446> \n<447> case 'c':\n<448> \n<449> s->c_cpu = env;\n<450> \n<451> put_packet(s, "OK");\n<452> \n<453> break;\n<454> \n<455> case 'g':\n<456> \n<457> s->g_cpu = env;\n<458> \n<459> put_packet(s, "OK");\n<460> \n<461> break;\n<462> \n<463> default:\n<464> \n<465> put_packet(s, "E22");\n<466> \n<467> break;\n<468> \n<469> }\n<470> \n<471> break;\n<472> \n<473> case 'T':\n<474> \n<475> thread = strtoull(p, (char **)&p, 16);\n<476> \n<477> #ifndef CONFIG_USER_ONLY\n<478> \n<479> if (thread > 0 && thread < smp_cpus + 1)\n<480> \n<481> #else\n<482> \n<483> if (thread == 1)\n<484> \n<485> #endif\n<486> \n<487> put_packet(s, "OK");\n<488> \n<489> else\n<490> \n<491> put_packet(s, "E22");\n<492> \n<493> break;\n<494> \n<495> case 'q':\n<496> \n<497> case 'Q':\n<498> \n<499> /* parse any 'q' packets here */\n<500> \n<501> if (!strcmp(p,"qemu.sstepbits")) {\n<502> \n<503> /* Query Breakpoint bit definitions */\n<504> \n<505> snprintf(buf, sizeof(buf), "ENABLE=%x,NOIRQ=%x,NOTIMER=%x",\n<506> \n<507> SSTEP_ENABLE,\n<508> \n<509> SSTEP_NOIRQ,\n<510> \n<511> SSTEP_NOTIMER);\n<512> \n<513> put_packet(s, buf);\n<514> \n<515> break;\n<516> \n<517> } else if (strncmp(p,"qemu.sstep",10) == 0) {\n<518> \n<519> /* Display or change the sstep_flags */\n<520> \n<521> p += 10;\n<522> \n<523> if (*p != '=') {\n<524> \n<525> /* Display current setting */\n<526> \n<527> snprintf(buf, sizeof(buf), "0x%x", sstep_flags);\n<528> \n<529> put_packet(s, buf);\n<530> \n<531> break;\n<532> \n<533> }\n<534> \n<535> p++;\n<536> \n<537> type = strtoul(p, (char **)&p, 16);\n<538> \n<539> sstep_flags = type;\n<540> \n<541> put_packet(s, "OK");\n<542> \n<543> break;\n<544> \n<545> } else if (strcmp(p,"C") == 0) {\n<546> \n<547> /* "Current thread" remains vague in the spec, so always return\n<548> \n<549> *  the first CPU (gdb returns the first thread). */\n<550> \n<551> put_packet(s, "QC1");\n<552> \n<553> break;\n<554> \n<555> } else if (strcmp(p,"fThreadInfo") == 0) {\n<556> \n<557> s->query_cpu = first_cpu;\n<558> \n<559> goto report_cpuinfo;\n<560> \n<561> } else if (strcmp(p,"sThreadInfo") == 0) {\n<562> \n<563> report_cpuinfo:\n<564> \n<565> if (s->query_cpu) {\n<566> \n<567> snprintf(buf, sizeof(buf), "m%x", s->query_cpu->cpu_index+1);\n<568> \n<569> put_packet(s, buf);\n<570> \n<571> s->query_cpu = s->query_cpu->next_cpu;\n<572> \n<573> } else\n<574> \n<575> put_packet(s, "l");\n<576> \n<577> break;\n<578> \n<579> } else if (strncmp(p,"ThreadExtraInfo,", 16) == 0) {\n<580> \n<581> thread = strtoull(p+16, (char **)&p, 16);\n<582> \n<583> for (env = first_cpu; env != NULL; env = env->next_cpu)\n<584> \n<585> if (env->cpu_index + 1 == thread) {\n<586> \n<587> len = snprintf((char *)mem_buf, sizeof(mem_buf),\n<588> \n<589> "CPU#%d [%s]", env->cpu_index,\n<590> \n<591> env->halted ? "halted " : "running");\n<592> \n<593> memtohex(buf, mem_buf, len);\n<594> \n<595> put_packet(s, buf);\n<596> \n<597> break;\n<598> \n<599> }\n<600> \n<601> break;\n<602> \n<603> }\n<604> \n<605> #ifdef CONFIG_LINUX_USER\n<606> \n<607> else if (strncmp(p, "Offsets", 7) == 0) {\n<608> \n<609> TaskState *ts = s->c_cpu->opaque;\n<610> \n<611> \n<612> \n<613> snprintf(buf, sizeof(buf),\n<614> \n<615> "Text=" TARGET_ABI_FMT_lx ";Data=" TARGET_ABI_FMT_lx\n<616> \n<617> ";Bss=" TARGET_ABI_FMT_lx,\n<618> \n<619> ts->info->code_offset,\n<620> \n<621> ts->info->data_offset,\n<622> \n<623> ts->info->data_offset);\n<624> \n<625> put_packet(s, buf);\n<626> \n<627> break;\n<628> \n<629> }\n<630> \n<631> #endif\n<632> \n<633> if (strncmp(p, "Supported", 9) == 0) {\n<634> \n<635> snprintf(buf, sizeof(buf), "PacketSize=%x", MAX_PACKET_LENGTH);\n<636> \n<637> #ifdef GDB_CORE_XML\n<638> \n<639> strcat(buf, ";qXfer:features:read+");\n<640> \n<641> #endif\n<642> \n<643> put_packet(s, buf);\n<644> \n<645> break;\n<646> \n<647> }\n<648> \n<649> #ifdef GDB_CORE_XML\n<650> \n<651> if (strncmp(p, "Xfer:features:read:", 19) == 0) {\n<652> \n<653> const char *xml;\n<654> \n<655> target_ulong total_len;\n<656> \n<657> \n<658> \n<659> gdb_has_xml = 1;\n<660> \n<661> p += 19;\n<662> \n<663> xml = get_feature_xml(p, &p);\n<664> \n<665> if (!xml) {\n<666> \n<667> snprintf(buf, sizeof(buf), "E00");\n<668> \n<669> put_packet(s, buf);\n<670> \n<671> break;\n<672> \n<673> }\n<674> \n<675> \n<676> \n<677> if (*p == ':')\n<678> \n<679> p++;\n<680> \n<681> addr = strtoul(p, (char **)&p, 16);\n<682> \n<683> if (*p == ',')\n<684> \n<685> p++;\n<686> \n<687> len = strtoul(p, (char **)&p, 16);\n<688> \n<689> \n<690> \n<691> total_len = strlen(xml);\n<692> \n<693> if (addr > total_len) {\n<694> \n<695> snprintf(buf, sizeof(buf), "E00");\n<696> \n<697> put_packet(s, buf);\n<698> \n<699> break;\n<700> \n<701> }\n<702> \n<703> if (len > (MAX_PACKET_LENGTH - 5) / 2)\n<704> \n<705> len = (MAX_PACKET_LENGTH - 5) / 2;\n<706> \n<707> if (len < total_len - addr) {\n<708> \n<709> buf[0] = 'm';\n<710> \n<711> len = memtox(buf + 1, xml + addr, len);\n<712> \n<713> } else {\n<714> \n<715> buf[0] = 'l';\n<716> \n<717> len = memtox(buf + 1, xml + addr, total_len - addr);\n<718> \n<719> }\n<720> \n<721> put_packet_binary(s, buf, len + 1);\n<722> \n<723> break;\n<724> \n<725> }\n<726> \n<727> #endif\n<728> \n<729> /* Unrecognised 'q' command.  */\n<730> \n<731> goto unknown_command;\n<732> \n<733> \n<734> \n<735> default:\n<736> \n<737> unknown_command:\n<738> \n<739> /* put empty packet */\n<740> \n<741> buf[0] = '\0';\n<742> \n<743> put_packet(s, buf);\n<744> \n<745> break;\n<746> \n<747> }\n<748> \n<749> return RS_IDLE;\n<750> \n<751> }\n<752> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int load_image_gzipped(const char *filename, hwaddr addr, uint64_t max_sz)\n<2> \n<3> {\n<4> \n<5> uint8_t *compressed_data = NULL;\n<6> \n<7> uint8_t *data = NULL;\n<8> \n<9> gsize len;\n<10> \n<11> ssize_t bytes;\n<12> \n<13> int ret = -1;\n<14> \n<15> \n<16> \n<17> if (!g_file_get_contents(filename, (char **) &compressed_data, &len,\n<18> \n<19> NULL)) {\n<20> \n<21> goto out;\n<22> \n<23> }\n<24> \n<25> \n<26> \n<27> /* Is it a gzip-compressed file? */\n<28> \n<29> if (len < 2 ||\n<30> \n<31> compressed_data[0] != 0x1f ||\n<32> \n<33> compressed_data[1] != 0x8b) {\n<34> \n<35> goto out;\n<36> \n<37> }\n<38> \n<39> \n<40> \n<41> if (max_sz > LOAD_IMAGE_MAX_GUNZIP_BYTES) {\n<42> \n<43> max_sz = LOAD_IMAGE_MAX_GUNZIP_BYTES;\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> data = g_malloc(max_sz);\n<50> \n<51> bytes = gunzip(data, max_sz, compressed_data, len);\n<52> \n<53> if (bytes < 0) {\n<54> \n<55> fprintf(stderr, "%s: unable to decompress gzipped kernel file\n",\n<56> \n<57> filename);\n<58> \n<59> goto out;\n<60> \n<61> }\n<62> \n<63> \n<64> \n<65> rom_add_blob_fixed(filename, data, bytes, addr);\n<66> \n<67> ret = bytes;\n<68> \n<69> \n<70> \n<71> out:\n<72> \n<73> g_free(compressed_data);\n<74> \n<75> g_free(data);\n<76> \n<77> return ret;\n<78> \n<79> }\n<80> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void *qemu_malloc(size_t size)\n<2> \n<3> {\n<4> \n<5> return malloc(size);\n<6> \n<7> }\n<8> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static unsigned int dec_movem_rm(DisasContext *dc)\n<2> \n<3> {\n<4> \n<5> TCGv tmp;\n<6> \n<7> TCGv addr;\n<8> \n<9> int i;\n<10> \n<11> \n<12> \n<13> DIS(fprintf (logfile, "movem $r%u, [$r%u%s\n", dc->op2, dc->op1,\n<14> \n<15> dc->postinc ? "+]" : "]"));\n<16> \n<17> \n<18> \n<19> cris_flush_cc_state(dc);\n<20> \n<21> \n<22> \n<23> tmp = tcg_temp_new(TCG_TYPE_TL);\n<24> \n<25> addr = tcg_temp_new(TCG_TYPE_TL);\n<26> \n<27> tcg_gen_movi_tl(tmp, 4);\n<28> \n<29> tcg_gen_mov_tl(addr, cpu_R[dc->op1]);\n<30> \n<31> for (i = 0; i <= dc->op2; i++) {\n<32> \n<33> /* Displace addr.  */\n<34> \n<35> /* Perform the store.  */\n<36> \n<37> gen_store(dc, addr, cpu_R[i], 4);\n<38> \n<39> tcg_gen_add_tl(addr, addr, tmp);\n<40> \n<41> }\n<42> \n<43> if (dc->postinc)\n<44> \n<45> tcg_gen_mov_tl(cpu_R[dc->op1], addr);\n<46> \n<47> cris_cc_mask(dc, 0);\n<48> \n<49> tcg_temp_free(tmp);\n<50> \n<51> tcg_temp_free(addr);\n<52> \n<53> return 2;\n<54> \n<55> }\n<56> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void checkasm_check_h264qpel(void)\n<2> \n<3> {\n<4> \n<5> LOCAL_ALIGNED_16(uint8_t, buf0, [BUF_SIZE]);\n<6> \n<7> LOCAL_ALIGNED_16(uint8_t, buf1, [BUF_SIZE]);\n<8> \n<9> LOCAL_ALIGNED_16(uint8_t, dst0, [BUF_SIZE]);\n<10> \n<11> LOCAL_ALIGNED_16(uint8_t, dst1, [BUF_SIZE]);\n<12> \n<13> H264QpelContext h;\n<14> \n<15> int op, bit_depth, i, j;\n<16> \n<17> \n<18> \n<19> for (op = 0; op < 2; op++) {\n<20> \n<21> qpel_mc_func (*tab)[16] = op ? h.avg_h264_qpel_pixels_tab : h.put_h264_qpel_pixels_tab;\n<22> \n<23> const char *op_name = op ? "avg" : "put";\n<24> \n<25> \n<26> \n<27> for (bit_depth = 8; bit_depth <= 10; bit_depth++) {\n<28> \n<29> ff_h264qpel_init(&h, bit_depth);\n<30> \n<31> for (i = 0; i < (op ? 3 : 4); i++) {\n<32> \n<33> int size = 16 >> i;\n<34> \n<35> for (j = 0; j < 16; j++)\n<36> \n<37> if (check_func(tab[i][j], "%s_h264_qpel_%d_mc%d%d_%d", op_name, size, j & 3, j >> 2, bit_depth)) {\n<38> \n<39> randomize_buffers();\n<40> \n<41> call_ref(dst0, src0, (ptrdiff_t)size * SIZEOF_PIXEL);\n<42> \n<43> call_new(dst1, src1, (ptrdiff_t)size * SIZEOF_PIXEL);\n<44> \n<45> if (memcmp(buf0, buf1, BUF_SIZE) || memcmp(dst0, dst1, BUF_SIZE))\n<46> \n<47> fail();\n<48> \n<49> bench_new(dst1, src1, (ptrdiff_t)size * SIZEOF_PIXEL);\n<50> \n<51> }\n<52> \n<53> }\n<54> \n<55> }\n<56> \n<57> report("%s", op_name);\n<58> \n<59> }\n<60> \n<61> }\n<62> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void qmp_block_set_io_throttle(const char *device, int64_t bps, int64_t bps_rd,\n<2> \n<3> int64_t bps_wr,\n<4> \n<5> int64_t iops,\n<6> \n<7> int64_t iops_rd,\n<8> \n<9> int64_t iops_wr,\n<10> \n<11> bool has_bps_max,\n<12> \n<13> int64_t bps_max,\n<14> \n<15> bool has_bps_rd_max,\n<16> \n<17> int64_t bps_rd_max,\n<18> \n<19> bool has_bps_wr_max,\n<20> \n<21> int64_t bps_wr_max,\n<22> \n<23> bool has_iops_max,\n<24> \n<25> int64_t iops_max,\n<26> \n<27> bool has_iops_rd_max,\n<28> \n<29> int64_t iops_rd_max,\n<30> \n<31> bool has_iops_wr_max,\n<32> \n<33> int64_t iops_wr_max,\n<34> \n<35> bool has_iops_size,\n<36> \n<37> int64_t iops_size,\n<38> \n<39> bool has_group,\n<40> \n<41> const char *group, Error **errp)\n<42> \n<43> {\n<44> \n<45> ThrottleConfig cfg;\n<46> \n<47> BlockDriverState *bs;\n<48> \n<49> BlockBackend *blk;\n<50> \n<51> AioContext *aio_context;\n<52> \n<53> \n<54> \n<55> blk = blk_by_name(device);\n<56> \n<57> if (!blk) {\n<58> \n<59> error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n<60> \n<61> "Device '%s' not found", device);\n<62> \n<63> return;\n<64> \n<65> }\n<66> \n<67> \n<68> \n<69> aio_context = blk_get_aio_context(blk);\n<70> \n<71> aio_context_acquire(aio_context);\n<72> \n<73> \n<74> \n<75> bs = blk_bs(blk);\n<76> \n<77> if (!bs) {\n<78> \n<79> error_setg(errp, "Device '%s' has no medium", device);\n<80> \n<81> goto out;\n<82> \n<83> }\n<84> \n<85> \n<86> \n<87> memset(&cfg, 0, sizeof(cfg));\n<88> \n<89> cfg.buckets[THROTTLE_BPS_TOTAL].avg = bps;\n<90> \n<91> cfg.buckets[THROTTLE_BPS_READ].avg  = bps_rd;\n<92> \n<93> cfg.buckets[THROTTLE_BPS_WRITE].avg = bps_wr;\n<94> \n<95> \n<96> \n<97> cfg.buckets[THROTTLE_OPS_TOTAL].avg = iops;\n<98> \n<99> cfg.buckets[THROTTLE_OPS_READ].avg  = iops_rd;\n<100> \n<101> cfg.buckets[THROTTLE_OPS_WRITE].avg = iops_wr;\n<102> \n<103> \n<104> \n<105> if (has_bps_max) {\n<106> \n<107> cfg.buckets[THROTTLE_BPS_TOTAL].max = bps_max;\n<108> \n<109> }\n<110> \n<111> if (has_bps_rd_max) {\n<112> \n<113> cfg.buckets[THROTTLE_BPS_READ].max = bps_rd_max;\n<114> \n<115> }\n<116> \n<117> if (has_bps_wr_max) {\n<118> \n<119> cfg.buckets[THROTTLE_BPS_WRITE].max = bps_wr_max;\n<120> \n<121> }\n<122> \n<123> if (has_iops_max) {\n<124> \n<125> cfg.buckets[THROTTLE_OPS_TOTAL].max = iops_max;\n<126> \n<127> }\n<128> \n<129> if (has_iops_rd_max) {\n<130> \n<131> cfg.buckets[THROTTLE_OPS_READ].max = iops_rd_max;\n<132> \n<133> }\n<134> \n<135> if (has_iops_wr_max) {\n<136> \n<137> cfg.buckets[THROTTLE_OPS_WRITE].max = iops_wr_max;\n<138> \n<139> }\n<140> \n<141> \n<142> \n<143> if (has_iops_size) {\n<144> \n<145> cfg.op_size = iops_size;\n<146> \n<147> }\n<148> \n<149> \n<150> \n<151> if (!check_throttle_config(&cfg, errp)) {\n<152> \n<153> goto out;\n<154> \n<155> }\n<156> \n<157> \n<158> \n<159> if (throttle_enabled(&cfg)) {\n<160> \n<161> /* Enable I/O limits if they're not enabled yet, otherwise\n<162> \n<163> * just update the throttling group. */\n<164> \n<165> if (!bs->io_limits_enabled) {\n<166> \n<167> bdrv_io_limits_enable(bs, has_group ? group : device);\n<168> \n<169> } else if (has_group) {\n<170> \n<171> bdrv_io_limits_update_group(bs, group);\n<172> \n<173> }\n<174> \n<175> /* Set the new throttling configuration */\n<176> \n<177> bdrv_set_io_limits(bs, &cfg);\n<178> \n<179> } else if (bs->io_limits_enabled) {\n<180> \n<181> /* If all throttling settings are set to 0, disable I/O limits */\n<182> \n<183> bdrv_io_limits_disable(bs);\n<184> \n<185> }\n<186> \n<187> \n<188> \n<189> out:\n<190> \n<191> aio_context_release(aio_context);\n<192> \n<193> }\n<194> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> GType hb_gobject_ ## name ## _get_type ( void ) \ {\n<2> static gsize type_id = 0 ;\n<3> if ( g_once_init_enter ( & type_id ) ) {\n<4> GType id = g_boxed_type_register_static ( g_intern_static_string ( "hb_" # name "_t" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n<5> g_once_init_leave ( & type_id , id ) ;\n<6> }\n<7> return type_id ;\n<8> \ }\n<9> # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n<10> HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n<11> hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n<12> if ( unlikely ( ! c ) ) return NULL ;\n<13> * c = * g ;\n<14> return c ;\n<15> }\n<16> static void feature_destroy ( hb_feature_t * g ) {\n<17> free ( g ) ;\n<18> }\n<19> HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy )\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int os_host_main_loop_wait(int64_t timeout)\n<2> \n<3> {\n<4> \n<5> int ret;\n<6> \n<7> static int spin_counter;\n<8> \n<9> \n<10> \n<11> glib_pollfds_fill(&timeout);\n<12> \n<13> \n<14> \n<15> /* If the I/O thread is very busy or we are incorrectly busy waiting in\n<16> \n<17> * the I/O thread, this can lead to starvation of the BQL such that the\n<18> \n<19> * VCPU threads never run.  To make sure we can detect the later case,\n<20> \n<21> * print a message to the screen.  If we run into this condition, create\n<22> \n<23> * a fake timeout in order to give the VCPU threads a chance to run.\n<24> \n<25> */\n<26> \n<27> if (!timeout && (spin_counter > MAX_MAIN_LOOP_SPIN)) {\n<28> \n<29> static bool notified;\n<30> \n<31> \n<32> \n<33> if (!notified && !qtest_driver()) {\n<34> \n<35> fprintf(stderr,\n<36> \n<37> "main-loop: WARNING: I/O thread spun for %d iterations\n",\n<38> \n<39> MAX_MAIN_LOOP_SPIN);\n<40> \n<41> notified = true;\n<42> \n<43> }\n<44> \n<45> \n<46> \n<47> timeout = SCALE_MS;\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> if (timeout) {\n<54> \n<55> spin_counter = 0;\n<56> \n<57> qemu_mutex_unlock_iothread();\n<58> \n<59> } else {\n<60> \n<61> spin_counter++;\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);\n<68> \n<69> \n<70> \n<71> if (timeout) {\n<72> \n<73> qemu_mutex_lock_iothread();\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> glib_pollfds_poll();\n<80> \n<81> return ret;\n<82> \n<83> }\n<84> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void find_completion(const char *cmdline)\n<2> \n<3> {\n<4> \n<5> const char *cmdname;\n<6> \n<7> char *args[MAX_ARGS];\n<8> \n<9> int nb_args, i, len;\n<10> \n<11> const char *ptype, *str;\n<12> \n<13> term_cmd_t *cmd;\n<14> \n<15> \n<16> \n<17> parse_cmdline(cmdline, &nb_args, args);\n<18> \n<19> #ifdef DEBUG_COMPLETION\n<20> \n<21> for(i = 0; i < nb_args; i++) {\n<22> \n<23> term_printf("arg%d = '%s'\n", i, (char *)args[i]);\n<24> \n<25> }\n<26> \n<27> #endif\n<28> \n<29> \n<30> \n<31> /* if the line ends with a space, it means we want to complete the\n<32> \n<33> next arg */\n<34> \n<35> len = strlen(cmdline);\n<36> \n<37> if (len > 0 && isspace(cmdline[len - 1])) {\n<38> \n<39> if (nb_args >= MAX_ARGS)\n<40> \n<41> return;\n<42> \n<43> args[nb_args++] = qemu_strdup("");\n<44> \n<45> }\n<46> \n<47> if (nb_args <= 1) {\n<48> \n<49> /* command completion */\n<50> \n<51> if (nb_args == 0)\n<52> \n<53> cmdname = "";\n<54> \n<55> else\n<56> \n<57> cmdname = args[0];\n<58> \n<59> completion_index = strlen(cmdname);\n<60> \n<61> for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n<62> \n<63> cmd_completion(cmdname, cmd->name);\n<64> \n<65> }\n<66> \n<67> } else {\n<68> \n<69> /* find the command */\n<70> \n<71> for(cmd = term_cmds; cmd->name != NULL; cmd++) {\n<72> \n<73> if (compare_cmd(args[0], cmd->name))\n<74> \n<75> goto found;\n<76> \n<77> }\n<78> \n<79> return;\n<80> \n<81> found:\n<82> \n<83> ptype = cmd->args_type;\n<84> \n<85> for(i = 0; i < nb_args - 2; i++) {\n<86> \n<87> if (*ptype != '\0') {\n<88> \n<89> ptype++;\n<90> \n<91> while (*ptype == '?')\n<92> \n<93> ptype++;\n<94> \n<95> }\n<96> \n<97> }\n<98> \n<99> str = args[nb_args - 1];\n<100> \n<101> switch(*ptype) {\n<102> \n<103> case 'F':\n<104> \n<105> /* file completion */\n<106> \n<107> completion_index = strlen(str);\n<108> \n<109> file_completion(str);\n<110> \n<111> break;\n<112> \n<113> case 'B':\n<114> \n<115> /* block device name completion */\n<116> \n<117> completion_index = strlen(str);\n<118> \n<119> bdrv_iterate(block_completion_it, (void *)str);\n<120> \n<121> break;\n<122> \n<123> default:\n<124> \n<125> break;\n<126> \n<127> }\n<128> \n<129> }\n<130> \n<131> for(i = 0; i < nb_args; i++)\n<132> \n<133> qemu_free(args[i]);\n<134> \n<135> }\n<136> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int create_ppc_opcodes (CPUPPCState *env, const ppc_def_t *def)\n<2> \n<3> {\n<4> \n<5> opcode_t *opc, *start, *end;\n<6> \n<7> \n<8> \n<9> fill_new_table(env->opcodes, 0x40);\n<10> \n<11> if (&opc_start < &opc_end) {\n<12> \n<13> start = &opc_start;\n<14> \n<15> end = &opc_end;\n<16> \n<17> } else {\n<18> \n<19> start = &opc_end;\n<20> \n<21> end = &opc_start;\n<22> \n<23> }\n<24> \n<25> for (opc = start + 1; opc != end; opc++) {\n<26> \n<27> if ((opc->handler.type & def->insns_flags) != 0) {\n<28> \n<29> if (register_insn(env->opcodes, opc) < 0) {\n<30> \n<31> printf("*** ERROR initializing PowerPC instruction "\n<32> \n<33> "0x%02x 0x%02x 0x%02x\n", opc->opc1, opc->opc2,\n<34> \n<35> opc->opc3);\n<36> \n<37> return -1;\n<38> \n<39> }\n<40> \n<41> }\n<42> \n<43> }\n<44> \n<45> fix_opcode_tables(env->opcodes);\n<46> \n<47> fflush(stdout);\n<48> \n<49> fflush(stderr);\n<50> \n<51> \n<52> \n<53> return 0;\n<54> \n<55> }\n<56> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static struct iovec *lock_iovec(int type, abi_ulong target_addr,\n<2> \n<3> int count, int copy)\n<4> \n<5> {\n<6> \n<7> struct target_iovec *target_vec;\n<8> \n<9> struct iovec *vec;\n<10> \n<11> abi_ulong total_len, max_len;\n<12> \n<13> int i;\n<14> \n<15> int err = 0;\n<16> \n<17> \n<18> \n<19> if (count == 0) {\n<20> \n<21> errno = 0;\n<22> \n<23> return NULL;\n<24> \n<25> }\n<26> \n<27> if (count < 0 || count > IOV_MAX) {\n<28> \n<29> errno = EINVAL;\n<30> \n<31> return NULL;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> vec = calloc(count, sizeof(struct iovec));\n<38> \n<39> if (vec == NULL) {\n<40> \n<41> errno = ENOMEM;\n<42> \n<43> return NULL;\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> target_vec = lock_user(VERIFY_READ, target_addr,\n<50> \n<51> count * sizeof(struct target_iovec), 1);\n<52> \n<53> if (target_vec == NULL) {\n<54> \n<55> err = EFAULT;\n<56> \n<57> goto fail2;\n<58> \n<59> }\n<60> \n<61> \n<62> \n<63> /* ??? If host page size > target page size, this will result in a\n<64> \n<65> value larger than what we can actually support.  */\n<66> \n<67> max_len = 0x7fffffff & TARGET_PAGE_MASK;\n<68> \n<69> total_len = 0;\n<70> \n<71> \n<72> \n<73> for (i = 0; i < count; i++) {\n<74> \n<75> abi_ulong base = tswapal(target_vec[i].iov_base);\n<76> \n<77> abi_long len = tswapal(target_vec[i].iov_len);\n<78> \n<79> \n<80> \n<81> if (len < 0) {\n<82> \n<83> err = EINVAL;\n<84> \n<85> goto fail;\n<86> \n<87> } else if (len == 0) {\n<88> \n<89> /* Zero length pointer is ignored.  */\n<90> \n<91> vec[i].iov_base = 0;\n<92> \n<93> } else {\n<94> \n<95> vec[i].iov_base = lock_user(type, base, len, copy);\n<96> \n<97> if (!vec[i].iov_base) {\n<98> \n<99> err = EFAULT;\n<100> \n<101> goto fail;\n<102> \n<103> }\n<104> \n<105> if (len > max_len - total_len) {\n<106> \n<107> len = max_len - total_len;\n<108> \n<109> }\n<110> \n<111> }\n<112> \n<113> vec[i].iov_len = len;\n<114> \n<115> total_len += len;\n<116> \n<117> }\n<118> \n<119> \n<120> \n<121> unlock_user(target_vec, target_addr, 0);\n<122> \n<123> return vec;\n<124> \n<125> \n<126> \n<127> fail:\n<128> \n<129> unlock_user(target_vec, target_addr, 0);\n<130> \n<131> fail2:\n<132> \n<133> free(vec);\n<134> \n<135> errno = err;\n<136> \n<137> return NULL;\n<138> \n<139> }\n<140> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void validate_bootdevices(const char *devices)\n<2> \n<3> {\n<4> \n<5> /* We just do some generic consistency checks */\n<6> \n<7> const char *p;\n<8> \n<9> int bitmap = 0;\n<10> \n<11> \n<12> \n<13> for (p = devices; *p != '\0'; p++) {\n<14> \n<15> /* Allowed boot devices are:\n<16> \n<17> * a-b: floppy disk drives\n<18> \n<19> * c-f: IDE disk drives\n<20> \n<21> * g-m: machine implementation dependent drives\n<22> \n<23> * n-p: network devices\n<24> \n<25> * It's up to each machine implementation to check if the given boot\n<26> \n<27> * devices match the actual hardware implementation and firmware\n<28> \n<29> * features.\n<30> \n<31> */\n<32> \n<33> if (*p < 'a' || *p > 'p') {\n<34> \n<35> fprintf(stderr, "Invalid boot device '%c'\n", *p);\n<36> \n<37> exit(1);\n<38> \n<39> }\n<40> \n<41> if (bitmap & (1 << (*p - 'a'))) {\n<42> \n<43> fprintf(stderr, "Boot device '%c' was given twice\n", *p);\n<44> \n<45> exit(1);\n<46> \n<47> }\n<48> \n<49> bitmap |= 1 << (*p - 'a');\n<50> \n<51> }\n<52> \n<53> }\n<54> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n<2> \n<3> {\n<4> \n<5> unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n<6> \n<7> int i, j, pwlen;\n<8> \n<9> unsigned char key[8];\n<10> \n<11> time_t now = time(NULL);\n<12> \n<13> \n<14> \n<15> if (!vs->vd->password || !vs->vd->password[0]) {\n<16> \n<17> VNC_DEBUG("No password configured on server");\n<18> \n<19> goto reject;\n<20> \n<21> }\n<22> \n<23> if (vs->vd->expires < now) {\n<24> \n<25> VNC_DEBUG("Password is expired");\n<26> \n<27> goto reject;\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n<34> \n<35> \n<36> \n<37> /* Calculate the expected challenge response */\n<38> \n<39> pwlen = strlen(vs->vd->password);\n<40> \n<41> for (i=0; i<sizeof(key); i++)\n<42> \n<43> key[i] = i<pwlen ? vs->vd->password[i] : 0;\n<44> \n<45> deskey(key, EN0);\n<46> \n<47> for (j = 0; j < VNC_AUTH_CHALLENGE_SIZE; j += 8)\n<48> \n<49> des(response+j, response+j);\n<50> \n<51> \n<52> \n<53> /* Compare expected vs actual challenge response */\n<54> \n<55> if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n<56> \n<57> VNC_DEBUG("Client challenge reponse did not match\n");\n<58> \n<59> goto reject;\n<60> \n<61> } else {\n<62> \n<63> VNC_DEBUG("Accepting VNC challenge response\n");\n<64> \n<65> vnc_write_u32(vs, 0); /* Accept auth */\n<66> \n<67> vnc_flush(vs);\n<68> \n<69> \n<70> \n<71> start_client_init(vs);\n<72> \n<73> }\n<74> \n<75> return 0;\n<76> \n<77> \n<78> \n<79> reject:\n<80> \n<81> vnc_write_u32(vs, 1); /* Reject auth */\n<82> \n<83> if (vs->minor >= 8) {\n<84> \n<85> static const char err[] = "Authentication failed";\n<86> \n<87> vnc_write_u32(vs, sizeof(err));\n<88> \n<89> vnc_write(vs, err, sizeof(err));\n<90> \n<91> }\n<92> \n<93> vnc_flush(vs);\n<94> \n<95> vnc_client_error(vs);\n<96> \n<97> return 0;\n<98> \n<99> }\n<100> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ram_load(QEMUFile *f, void *opaque, int version_id)\n<2> \n<3> {\n<4> \n<5> ram_addr_t addr;\n<6> \n<7> int flags;\n<8> \n<9> \n<10> \n<11> if (version_id != 3)\n<12> \n<13> return -EINVAL;\n<14> \n<15> \n<16> \n<17> do {\n<18> \n<19> addr = qemu_get_be64(f);\n<20> \n<21> \n<22> \n<23> flags = addr & ~TARGET_PAGE_MASK;\n<24> \n<25> addr &= TARGET_PAGE_MASK;\n<26> \n<27> \n<28> \n<29> if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n<30> \n<31> if (addr != last_ram_offset)\n<32> \n<33> return -EINVAL;\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> if (flags & RAM_SAVE_FLAG_COMPRESS) {\n<40> \n<41> uint8_t ch = qemu_get_byte(f);\n<42> \n<43> memset(qemu_get_ram_ptr(addr), ch, TARGET_PAGE_SIZE);\n<44> \n<45> #ifndef _WIN32\n<46> \n<47> if (ch == 0 &&\n<48> \n<49> (!kvm_enabled() || kvm_has_sync_mmu())) {\n<50> \n<51> madvise(qemu_get_ram_ptr(addr), TARGET_PAGE_SIZE, MADV_DONTNEED);\n<52> \n<53> }\n<54> \n<55> #endif\n<56> \n<57> } else if (flags & RAM_SAVE_FLAG_PAGE) {\n<58> \n<59> qemu_get_buffer(f, qemu_get_ram_ptr(addr), TARGET_PAGE_SIZE);\n<60> \n<61> }\n<62> \n<63> if (qemu_file_has_error(f)) {\n<64> \n<65> return -EIO;\n<66> \n<67> }\n<68> \n<69> } while (!(flags & RAM_SAVE_FLAG_EOS));\n<70> \n<71> \n<72> \n<73> return 0;\n<74> \n<75> }\n<76> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int create_filtergraph(AVFilterContext *ctx,\n<2> \n<3> const AVFrame *in, const AVFrame *out)\n<4> \n<5> {\n<6> \n<7> ColorSpaceContext *s = ctx->priv;\n<8> \n<9> const AVPixFmtDescriptor *in_desc  = av_pix_fmt_desc_get(in->format);\n<10> \n<11> const AVPixFmtDescriptor *out_desc = av_pix_fmt_desc_get(out->format);\n<12> \n<13> int emms = 0, m, n, o, res, fmt_identical, redo_yuv2rgb = 0, redo_rgb2yuv = 0;\n<14> \n<15> \n<16> \n<17> #define supported_depth(d) ((d) == 8 || (d) == 10 || (d) == 12)\n<18> \n<19> #define supported_subsampling(lcw, lch) \\n<20> \n<21> (((lcw) == 0 && (lch) == 0) || ((lcw) == 1 && (lch) == 0) || ((lcw) == 1 && (lch) == 1))\n<22> \n<23> #define supported_format(d) \\n<24> \n<25> ((d) != NULL && (d)->nb_components == 3 && \\n<26> \n<27> !((d)->flags & AV_PIX_FMT_FLAG_RGB) && \\n<28> \n<29> supported_depth((d)->comp[0].depth) && \\n<30> \n<31> supported_subsampling((d)->log2_chroma_w, (d)->log2_chroma_h))\n<32> \n<33> \n<34> \n<35> if (!supported_format(in_desc)) {\n<36> \n<37> av_log(ctx, AV_LOG_ERROR,\n<38> \n<39> "Unsupported input format %d (%s) or bitdepth (%d)\n",\n<40> \n<41> in->format, av_get_pix_fmt_name(in->format),\n<42> \n<43> in_desc ? in_desc->comp[0].depth : -1);\n<44> \n<45> return AVERROR(EINVAL);\n<46> \n<47> }\n<48> \n<49> if (!supported_format(out_desc)) {\n<50> \n<51> av_log(ctx, AV_LOG_ERROR,\n<52> \n<53> "Unsupported output format %d (%s) or bitdepth (%d)\n",\n<54> \n<55> out->format, av_get_pix_fmt_name(out->format),\n<56> \n<57> out_desc ? out_desc->comp[0].depth : -1);\n<58> \n<59> return AVERROR(EINVAL);\n<60> \n<61> }\n<62> \n<63> \n<64> \n<65> if (in->color_primaries  != s->in_prm)  s->in_primaries  = NULL;\n<66> \n<67> if (out->color_primaries != s->out_prm) s->out_primaries = NULL;\n<68> \n<69> if (in->color_trc        != s->in_trc)  s->in_txchr      = NULL;\n<70> \n<71> if (out->color_trc       != s->out_trc) s->out_txchr     = NULL;\n<72> \n<73> if (in->colorspace       != s->in_csp ||\n<74> \n<75> in->color_range      != s->in_rng)  s->in_lumacoef   = NULL;\n<76> \n<77> if (out->colorspace      != s->out_csp ||\n<78> \n<79> out->color_range     != s->out_rng) s->out_lumacoef  = NULL;\n<80> \n<81> \n<82> \n<83> if (!s->out_primaries || !s->in_primaries) {\n<84> \n<85> s->in_prm = in->color_primaries;\n<86> \n<87> if (s->user_iall != CS_UNSPECIFIED)\n<88> \n<89> s->in_prm = default_prm[FFMIN(s->user_iall, CS_NB)];\n<90> \n<91> if (s->user_iprm != AVCOL_PRI_UNSPECIFIED)\n<92> \n<93> s->in_prm = s->user_iprm;\n<94> \n<95> s->in_primaries = get_color_primaries(s->in_prm);\n<96> \n<97> if (!s->in_primaries) {\n<98> \n<99> av_log(ctx, AV_LOG_ERROR,\n<100> \n<101> "Unsupported input primaries %d (%s)\n",\n<102> \n<103> s->in_prm, av_color_primaries_name(s->in_prm));\n<104> \n<105> return AVERROR(EINVAL);\n<106> \n<107> }\n<108> \n<109> s->out_prm = out->color_primaries;\n<110> \n<111> s->out_primaries = get_color_primaries(s->out_prm);\n<112> \n<113> if (!s->out_primaries) {\n<114> \n<115> if (s->out_prm == AVCOL_PRI_UNSPECIFIED) {\n<116> \n<117> if (s->user_all == CS_UNSPECIFIED) {\n<118> \n<119> av_log(ctx, AV_LOG_ERROR, "Please specify output primaries\n");\n<120> \n<121> } else {\n<122> \n<123> av_log(ctx, AV_LOG_ERROR,\n<124> \n<125> "Unsupported output color property %d\n", s->user_all);\n<126> \n<127> }\n<128> \n<129> } else {\n<130> \n<131> av_log(ctx, AV_LOG_ERROR,\n<132> \n<133> "Unsupported output primaries %d (%s)\n",\n<134> \n<135> s->out_prm, av_color_primaries_name(s->out_prm));\n<136> \n<137> }\n<138> \n<139> return AVERROR(EINVAL);\n<140> \n<141> }\n<142> \n<143> s->lrgb2lrgb_passthrough = !memcmp(s->in_primaries, s->out_primaries,\n<144> \n<145> sizeof(*s->in_primaries));\n<146> \n<147> if (!s->lrgb2lrgb_passthrough) {\n<148> \n<149> double rgb2xyz[3][3], xyz2rgb[3][3], rgb2rgb[3][3];\n<150> \n<151> \n<152> \n<153> fill_rgb2xyz_table(s->out_primaries, rgb2xyz);\n<154> \n<155> invert_matrix3x3(rgb2xyz, xyz2rgb);\n<156> \n<157> fill_rgb2xyz_table(s->in_primaries, rgb2xyz);\n<158> \n<159> if (s->out_primaries->wp != s->in_primaries->wp &&\n<160> \n<161> s->wp_adapt != WP_ADAPT_IDENTITY) {\n<162> \n<163> double wpconv[3][3], tmp[3][3];\n<164> \n<165> \n<166> \n<167> fill_whitepoint_conv_table(wpconv, s->wp_adapt, s->in_primaries->wp,\n<168> \n<169> s->out_primaries->wp);\n<170> \n<171> mul3x3(tmp, rgb2xyz, wpconv);\n<172> \n<173> mul3x3(rgb2rgb, tmp, xyz2rgb);\n<174> \n<175> } else {\n<176> \n<177> mul3x3(rgb2rgb, rgb2xyz, xyz2rgb);\n<178> \n<179> }\n<180> \n<181> for (m = 0; m < 3; m++)\n<182> \n<183> for (n = 0; n < 3; n++) {\n<184> \n<185> s->lrgb2lrgb_coeffs[m][n][0] = lrint(16384.0 * rgb2rgb[m][n]);\n<186> \n<187> for (o = 1; o < 8; o++)\n<188> \n<189> s->lrgb2lrgb_coeffs[m][n][o] = s->lrgb2lrgb_coeffs[m][n][0];\n<190> \n<191> }\n<192> \n<193> \n<194> \n<195> emms = 1;\n<196> \n<197> }\n<198> \n<199> }\n<200> \n<201> \n<202> \n<203> if (!s->in_txchr) {\n<204> \n<205> av_freep(&s->lin_lut);\n<206> \n<207> s->in_trc = in->color_trc;\n<208> \n<209> if (s->user_iall != CS_UNSPECIFIED)\n<210> \n<211> s->in_trc = default_trc[FFMIN(s->user_iall, CS_NB)];\n<212> \n<213> if (s->user_itrc != AVCOL_TRC_UNSPECIFIED)\n<214> \n<215> s->in_trc = s->user_itrc;\n<216> \n<217> s->in_txchr = get_transfer_characteristics(s->in_trc);\n<218> \n<219> if (!s->in_txchr) {\n<220> \n<221> av_log(ctx, AV_LOG_ERROR,\n<222> \n<223> "Unsupported input transfer characteristics %d (%s)\n",\n<224> \n<225> s->in_trc, av_color_transfer_name(s->in_trc));\n<226> \n<227> return AVERROR(EINVAL);\n<228> \n<229> }\n<230> \n<231> }\n<232> \n<233> \n<234> \n<235> if (!s->out_txchr) {\n<236> \n<237> av_freep(&s->lin_lut);\n<238> \n<239> s->out_trc = out->color_trc;\n<240> \n<241> s->out_txchr = get_transfer_characteristics(s->out_trc);\n<242> \n<243> if (!s->out_txchr) {\n<244> \n<245> if (s->out_trc == AVCOL_TRC_UNSPECIFIED) {\n<246> \n<247> if (s->user_all == CS_UNSPECIFIED) {\n<248> \n<249> av_log(ctx, AV_LOG_ERROR,\n<250> \n<251> "Please specify output transfer characteristics\n");\n<252> \n<253> } else {\n<254> \n<255> av_log(ctx, AV_LOG_ERROR,\n<256> \n<257> "Unsupported output color property %d\n", s->user_all);\n<258> \n<259> }\n<260> \n<261> } else {\n<262> \n<263> av_log(ctx, AV_LOG_ERROR,\n<264> \n<265> "Unsupported output transfer characteristics %d (%s)\n",\n<266> \n<267> s->out_trc, av_color_transfer_name(s->out_trc));\n<268> \n<269> }\n<270> \n<271> return AVERROR(EINVAL);\n<272> \n<273> }\n<274> \n<275> }\n<276> \n<277> \n<278> \n<279> s->rgb2rgb_passthrough = s->fast_mode || (s->lrgb2lrgb_passthrough &&\n<280> \n<281> !memcmp(s->in_txchr, s->out_txchr, sizeof(*s->in_txchr)));\n<282> \n<283> if (!s->rgb2rgb_passthrough && !s->lin_lut) {\n<284> \n<285> res = fill_gamma_table(s);\n<286> \n<287> if (res < 0)\n<288> \n<289> return res;\n<290> \n<291> emms = 1;\n<292> \n<293> }\n<294> \n<295> \n<296> \n<297> if (!s->in_lumacoef) {\n<298> \n<299> s->in_csp = in->colorspace;\n<300> \n<301> if (s->user_iall != CS_UNSPECIFIED)\n<302> \n<303> s->in_csp = default_csp[FFMIN(s->user_iall, CS_NB)];\n<304> \n<305> if (s->user_icsp != AVCOL_SPC_UNSPECIFIED)\n<306> \n<307> s->in_csp = s->user_icsp;\n<308> \n<309> s->in_rng = in->color_range;\n<310> \n<311> if (s->user_irng != AVCOL_RANGE_UNSPECIFIED)\n<312> \n<313> s->in_rng = s->user_irng;\n<314> \n<315> s->in_lumacoef = get_luma_coefficients(s->in_csp);\n<316> \n<317> if (!s->in_lumacoef) {\n<318> \n<319> av_log(ctx, AV_LOG_ERROR,\n<320> \n<321> "Unsupported input colorspace %d (%s)\n",\n<322> \n<323> s->in_csp, av_color_space_name(s->in_csp));\n<324> \n<325> return AVERROR(EINVAL);\n<326> \n<327> }\n<328> \n<329> redo_yuv2rgb = 1;\n<330> \n<331> }\n<332> \n<333> \n<334> \n<335> if (!s->out_lumacoef) {\n<336> \n<337> s->out_csp = out->colorspace;\n<338> \n<339> s->out_rng = out->color_range;\n<340> \n<341> s->out_lumacoef = get_luma_coefficients(s->out_csp);\n<342> \n<343> if (!s->out_lumacoef) {\n<344> \n<345> if (s->out_csp == AVCOL_SPC_UNSPECIFIED) {\n<346> \n<347> if (s->user_all == CS_UNSPECIFIED) {\n<348> \n<349> av_log(ctx, AV_LOG_ERROR,\n<350> \n<351> "Please specify output transfer characteristics\n");\n<352> \n<353> } else {\n<354> \n<355> av_log(ctx, AV_LOG_ERROR,\n<356> \n<357> "Unsupported output color property %d\n", s->user_all);\n<358> \n<359> }\n<360> \n<361> } else {\n<362> \n<363> av_log(ctx, AV_LOG_ERROR,\n<364> \n<365> "Unsupported output transfer characteristics %d (%s)\n",\n<366> \n<367> s->out_csp, av_color_space_name(s->out_csp));\n<368> \n<369> }\n<370> \n<371> return AVERROR(EINVAL);\n<372> \n<373> }\n<374> \n<375> redo_rgb2yuv = 1;\n<376> \n<377> }\n<378> \n<379> \n<380> \n<381> fmt_identical = in_desc->log2_chroma_h == out_desc->log2_chroma_h &&\n<382> \n<383> in_desc->log2_chroma_w == out_desc->log2_chroma_w;\n<384> \n<385> s->yuv2yuv_fastmode = s->rgb2rgb_passthrough && fmt_identical;\n<386> \n<387> s->yuv2yuv_passthrough = s->yuv2yuv_fastmode && s->in_rng == s->out_rng &&\n<388> \n<389> !memcmp(s->in_lumacoef, s->out_lumacoef,\n<390> \n<391> sizeof(*s->in_lumacoef)) &&\n<392> \n<393> in_desc->comp[0].depth == out_desc->comp[0].depth;\n<394> \n<395> if (!s->yuv2yuv_passthrough) {\n<396> \n<397> if (redo_yuv2rgb) {\n<398> \n<399> double rgb2yuv[3][3], (*yuv2rgb)[3] = s->yuv2rgb_dbl_coeffs;\n<400> \n<401> int off, bits, in_rng;\n<402> \n<403> \n<404> \n<405> res = get_range_off(&off, &s->in_y_rng, &s->in_uv_rng,\n<406> \n<407> s->in_rng, in_desc->comp[0].depth);\n<408> \n<409> if (res < 0) {\n<410> \n<411> av_log(ctx, AV_LOG_ERROR,\n<412> \n<413> "Unsupported input color range %d (%s)\n",\n<414> \n<415> s->in_rng, av_color_range_name(s->in_rng));\n<416> \n<417> return res;\n<418> \n<419> }\n<420> \n<421> for (n = 0; n < 8; n++)\n<422> \n<423> s->yuv_offset[0][n] = off;\n<424> \n<425> fill_rgb2yuv_table(s->in_lumacoef, rgb2yuv);\n<426> \n<427> invert_matrix3x3(rgb2yuv, yuv2rgb);\n<428> \n<429> bits = 1 << (in_desc->comp[0].depth - 1);\n<430> \n<431> for (n = 0; n < 3; n++) {\n<432> \n<433> for (in_rng = s->in_y_rng, m = 0; m < 3; m++, in_rng = s->in_uv_rng) {\n<434> \n<435> s->yuv2rgb_coeffs[n][m][0] = lrint(28672 * bits * yuv2rgb[n][m] / in_rng);\n<436> \n<437> for (o = 1; o < 8; o++)\n<438> \n<439> s->yuv2rgb_coeffs[n][m][o] = s->yuv2rgb_coeffs[n][m][0];\n<440> \n<441> }\n<442> \n<443> }\n<444> \n<445> av_assert2(s->yuv2rgb_coeffs[0][1][0] == 0);\n<446> \n<447> av_assert2(s->yuv2rgb_coeffs[2][2][0] == 0);\n<448> \n<449> av_assert2(s->yuv2rgb_coeffs[0][0][0] == s->yuv2rgb_coeffs[1][0][0]);\n<450> \n<451> av_assert2(s->yuv2rgb_coeffs[0][0][0] == s->yuv2rgb_coeffs[2][0][0]);\n<452> \n<453> s->yuv2rgb = s->dsp.yuv2rgb[(in_desc->comp[0].depth - 8) >> 1]\n<454> \n<455> [in_desc->log2_chroma_h + in_desc->log2_chroma_w];\n<456> \n<457> emms = 1;\n<458> \n<459> }\n<460> \n<461> \n<462> \n<463> if (redo_rgb2yuv) {\n<464> \n<465> double (*rgb2yuv)[3] = s->rgb2yuv_dbl_coeffs;\n<466> \n<467> int off, out_rng, bits;\n<468> \n<469> \n<470> \n<471> res = get_range_off(&off, &s->out_y_rng, &s->out_uv_rng,\n<472> \n<473> s->out_rng, out_desc->comp[0].depth);\n<474> \n<475> if (res < 0) {\n<476> \n<477> av_log(ctx, AV_LOG_ERROR,\n<478> \n<479> "Unsupported output color range %d (%s)\n",\n<480> \n<481> s->out_rng, av_color_range_name(s->out_rng));\n<482> \n<483> return res;\n<484> \n<485> }\n<486> \n<487> for (n = 0; n < 8; n++)\n<488> \n<489> s->yuv_offset[1][n] = off;\n<490> \n<491> fill_rgb2yuv_table(s->out_lumacoef, rgb2yuv);\n<492> \n<493> bits = 1 << (29 - out_desc->comp[0].depth);\n<494> \n<495> for (out_rng = s->out_y_rng, n = 0; n < 3; n++, out_rng = s->out_uv_rng) {\n<496> \n<497> for (m = 0; m < 3; m++) {\n<498> \n<499> s->rgb2yuv_coeffs[n][m][0] = lrint(bits * out_rng * rgb2yuv[n][m] / 28672);\n<500> \n<501> for (o = 1; o < 8; o++)\n<502> \n<503> s->rgb2yuv_coeffs[n][m][o] = s->rgb2yuv_coeffs[n][m][0];\n<504> \n<505> }\n<506> \n<507> }\n<508> \n<509> av_assert2(s->rgb2yuv_coeffs[1][2][0] == s->rgb2yuv_coeffs[2][0][0]);\n<510> \n<511> s->rgb2yuv = s->dsp.rgb2yuv[(out_desc->comp[0].depth - 8) >> 1]\n<512> \n<513> [out_desc->log2_chroma_h + out_desc->log2_chroma_w];\n<514> \n<515> s->rgb2yuv_fsb = s->dsp.rgb2yuv_fsb[(out_desc->comp[0].depth - 8) >> 1]\n<516> \n<517> [out_desc->log2_chroma_h + out_desc->log2_chroma_w];\n<518> \n<519> emms = 1;\n<520> \n<521> }\n<522> \n<523> \n<524> \n<525> if (s->yuv2yuv_fastmode && (redo_yuv2rgb || redo_rgb2yuv)) {\n<526> \n<527> int idepth = in_desc->comp[0].depth, odepth = out_desc->comp[0].depth;\n<528> \n<529> double (*rgb2yuv)[3] = s->rgb2yuv_dbl_coeffs;\n<530> \n<531> double (*yuv2rgb)[3] = s->yuv2rgb_dbl_coeffs;\n<532> \n<533> double yuv2yuv[3][3];\n<534> \n<535> int in_rng, out_rng;\n<536> \n<537> \n<538> \n<539> mul3x3(yuv2yuv, yuv2rgb, rgb2yuv);\n<540> \n<541> for (out_rng = s->out_y_rng, m = 0; m < 3; m++, out_rng = s->out_uv_rng) {\n<542> \n<543> for (in_rng = s->in_y_rng, n = 0; n < 3; n++, in_rng = s->in_uv_rng) {\n<544> \n<545> s->yuv2yuv_coeffs[m][n][0] =\n<546> \n<547> lrint(16384 * yuv2yuv[m][n] * out_rng * (1 << idepth) /\n<548> \n<549> (in_rng * (1 << odepth)));\n<550> \n<551> for (o = 1; o < 8; o++)\n<552> \n<553> s->yuv2yuv_coeffs[m][n][o] = s->yuv2yuv_coeffs[m][n][0];\n<554> \n<555> }\n<556> \n<557> }\n<558> \n<559> av_assert2(s->yuv2yuv_coeffs[1][0][0] == 0);\n<560> \n<561> av_assert2(s->yuv2yuv_coeffs[2][0][0] == 0);\n<562> \n<563> s->yuv2yuv = s->dsp.yuv2yuv[(idepth - 8) >> 1][(odepth - 8) >> 1]\n<564> \n<565> [in_desc->log2_chroma_h + in_desc->log2_chroma_w];\n<566> \n<567> }\n<568> \n<569> }\n<570> \n<571> \n<572> \n<573> if (emms)\n<574> \n<575> emms_c();\n<576> \n<577> \n<578> \n<579> return 0;\n<580> \n<581> }\n<582> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void curses_refresh(DisplayChangeListener *dcl)\n<2> \n<3> {\n<4> \n<5> int chr, nextchr, keysym, keycode, keycode_alt;\n<6> \n<7> \n<8> \n<9> curses_winch_check();\n<10> \n<11> \n<12> \n<13> if (invalidate) {\n<14> \n<15> clear();\n<16> \n<17> refresh();\n<18> \n<19> curses_calc_pad();\n<20> \n<21> graphic_hw_invalidate(NULL);\n<22> \n<23> invalidate = 0;\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> graphic_hw_text_update(NULL, screen);\n<30> \n<31> \n<32> \n<33> nextchr = ERR;\n<34> \n<35> while (1) {\n<36> \n<37> /* while there are any pending key strokes to process */\n<38> \n<39> if (nextchr == ERR)\n<40> \n<41> chr = getch();\n<42> \n<43> else {\n<44> \n<45> chr = nextchr;\n<46> \n<47> nextchr = ERR;\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> if (chr == ERR)\n<54> \n<55> break;\n<56> \n<57> \n<58> \n<59> #ifdef KEY_RESIZE\n<60> \n<61> /* this shouldn't occur when we use a custom SIGWINCH handler */\n<62> \n<63> if (chr == KEY_RESIZE) {\n<64> \n<65> clear();\n<66> \n<67> refresh();\n<68> \n<69> curses_calc_pad();\n<70> \n<71> curses_update(dcl, 0, 0, width, height);\n<72> \n<73> continue;\n<74> \n<75> }\n<76> \n<77> #endif\n<78> \n<79> \n<80> \n<81> keycode = curses2keycode[chr];\n<82> \n<83> keycode_alt = 0;\n<84> \n<85> \n<86> \n<87> /* alt key */\n<88> \n<89> if (keycode == 1) {\n<90> \n<91> nextchr = getch();\n<92> \n<93> \n<94> \n<95> if (nextchr != ERR) {\n<96> \n<97> chr = nextchr;\n<98> \n<99> keycode_alt = ALT;\n<100> \n<101> keycode = curses2keycode[nextchr];\n<102> \n<103> nextchr = ERR;\n<104> \n<105> \n<106> \n<107> if (keycode != -1) {\n<108> \n<109> keycode |= ALT;\n<110> \n<111> \n<112> \n<113> /* process keys reserved for qemu */\n<114> \n<115> if (keycode >= QEMU_KEY_CONSOLE0 &&\n<116> \n<117> keycode < QEMU_KEY_CONSOLE0 + 9) {\n<118> \n<119> erase();\n<120> \n<121> wnoutrefresh(stdscr);\n<122> \n<123> console_select(keycode - QEMU_KEY_CONSOLE0);\n<124> \n<125> \n<126> \n<127> invalidate = 1;\n<128> \n<129> continue;\n<130> \n<131> }\n<132> \n<133> }\n<134> \n<135> }\n<136> \n<137> }\n<138> \n<139> \n<140> \n<141> if (kbd_layout) {\n<142> \n<143> keysym = -1;\n<144> \n<145> if (chr < CURSES_KEYS)\n<146> \n<147> keysym = curses2keysym[chr];\n<148> \n<149> \n<150> \n<151> if (keysym == -1) {\n<152> \n<153> if (chr < ' ') {\n<154> \n<155> keysym = chr + '@';\n<156> \n<157> if (keysym >= 'A' && keysym <= 'Z')\n<158> \n<159> keysym += 'a' - 'A';\n<160> \n<161> keysym |= KEYSYM_CNTRL;\n<162> \n<163> } else\n<164> \n<165> keysym = chr;\n<166> \n<167> }\n<168> \n<169> \n<170> \n<171> keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK);\n<172> \n<173> if (keycode == 0)\n<174> \n<175> continue;\n<176> \n<177> \n<178> \n<179> keycode |= (keysym & ~KEYSYM_MASK) >> 16;\n<180> \n<181> keycode |= keycode_alt;\n<182> \n<183> }\n<184> \n<185> \n<186> \n<187> if (keycode == -1)\n<188> \n<189> continue;\n<190> \n<191> \n<192> \n<193> if (qemu_console_is_graphic(NULL)) {\n<194> \n<195> /* since terminals don't know about key press and release\n<196> \n<197> * events, we need to emit both for each key received */\n<198> \n<199> if (keycode & SHIFT) {\n<200> \n<201> qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);\n<202> \n<203> qemu_input_event_send_key_delay(0);\n<204> \n<205> }\n<206> \n<207> if (keycode & CNTRL) {\n<208> \n<209> qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n<210> \n<211> qemu_input_event_send_key_delay(0);\n<212> \n<213> }\n<214> \n<215> if (keycode & ALT) {\n<216> \n<217> qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n<218> \n<219> qemu_input_event_send_key_delay(0);\n<220> \n<221> }\n<222> \n<223> if (keycode & ALTGR) {\n<224> \n<225> qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n<226> \n<227> qemu_input_event_send_key_delay(0);\n<228> \n<229> }\n<230> \n<231> \n<232> \n<233> qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);\n<234> \n<235> qemu_input_event_send_key_delay(0);\n<236> \n<237> qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);\n<238> \n<239> qemu_input_event_send_key_delay(0);\n<240> \n<241> \n<242> \n<243> if (keycode & ALTGR) {\n<244> \n<245> qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n<246> \n<247> qemu_input_event_send_key_delay(0);\n<248> \n<249> }\n<250> \n<251> if (keycode & ALT) {\n<252> \n<253> qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n<254> \n<255> qemu_input_event_send_key_delay(0);\n<256> \n<257> }\n<258> \n<259> if (keycode & CNTRL) {\n<260> \n<261> qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n<262> \n<263> qemu_input_event_send_key_delay(0);\n<264> \n<265> }\n<266> \n<267> if (keycode & SHIFT) {\n<268> \n<269> qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n<270> \n<271> qemu_input_event_send_key_delay(0);\n<272> \n<273> }\n<274> \n<275> } else {\n<276> \n<277> keysym = -1;\n<278> \n<279> if (chr < CURSES_KEYS) {\n<280> \n<281> keysym = curses2qemu[chr];\n<282> \n<283> }\n<284> \n<285> if (keysym == -1)\n<286> \n<287> keysym = chr;\n<288> \n<289> \n<290> \n<291> kbd_put_keysym(keysym);\n<292> \n<293> }\n<294> \n<295> }\n<296> \n<297> }\n<298> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ppce500_load_device_tree(CPUPPCState *env,\n<2> \n<3> QEMUMachineInitArgs *args,\n<4> \n<5> PPCE500Params *params,\n<6> \n<7> hwaddr addr,\n<8> \n<9> hwaddr initrd_base,\n<10> \n<11> hwaddr initrd_size)\n<12> \n<13> {\n<14> \n<15> int ret = -1;\n<16> \n<17> uint64_t mem_reg_property[] = { 0, cpu_to_be64(args->ram_size) };\n<18> \n<19> int fdt_size;\n<20> \n<21> void *fdt;\n<22> \n<23> uint8_t hypercall[16];\n<24> \n<25> uint32_t clock_freq = 400000000;\n<26> \n<27> uint32_t tb_freq = 400000000;\n<28> \n<29> int i;\n<30> \n<31> char compatible_sb[] = "fsl,mpc8544-immr\0simple-bus";\n<32> \n<33> char soc[128];\n<34> \n<35> char mpic[128];\n<36> \n<37> uint32_t mpic_ph;\n<38> \n<39> uint32_t msi_ph;\n<40> \n<41> char gutil[128];\n<42> \n<43> char pci[128];\n<44> \n<45> char msi[128];\n<46> \n<47> uint32_t *pci_map = NULL;\n<48> \n<49> int len;\n<50> \n<51> uint32_t pci_ranges[14] =\n<52> \n<53> {\n<54> \n<55> 0x2000000, 0x0, 0xc0000000,\n<56> \n<57> 0x0, 0xc0000000,\n<58> \n<59> 0x0, 0x20000000,\n<60> \n<61> \n<62> \n<63> 0x1000000, 0x0, 0x0,\n<64> \n<65> 0x0, 0xe1000000,\n<66> \n<67> 0x0, 0x10000,\n<68> \n<69> };\n<70> \n<71> QemuOpts *machine_opts = qemu_get_machine_opts();\n<72> \n<73> const char *dtb_file = qemu_opt_get(machine_opts, "dtb");\n<74> \n<75> const char *toplevel_compat = qemu_opt_get(machine_opts, "dt_compatible");\n<76> \n<77> \n<78> \n<79> if (dtb_file) {\n<80> \n<81> char *filename;\n<82> \n<83> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, dtb_file);\n<84> \n<85> if (!filename) {\n<86> \n<87> goto out;\n<88> \n<89> }\n<90> \n<91> \n<92> \n<93> fdt = load_device_tree(filename, &fdt_size);\n<94> \n<95> if (!fdt) {\n<96> \n<97> goto out;\n<98> \n<99> }\n<100> \n<101> goto done;\n<102> \n<103> }\n<104> \n<105> \n<106> \n<107> fdt = create_device_tree(&fdt_size);\n<108> \n<109> if (fdt == NULL) {\n<110> \n<111> goto out;\n<112> \n<113> }\n<114> \n<115> \n<116> \n<117> /* Manipulate device tree in memory. */\n<118> \n<119> qemu_devtree_setprop_cell(fdt, "/", "#address-cells", 2);\n<120> \n<121> qemu_devtree_setprop_cell(fdt, "/", "#size-cells", 2);\n<122> \n<123> \n<124> \n<125> qemu_devtree_add_subnode(fdt, "/memory");\n<126> \n<127> qemu_devtree_setprop_string(fdt, "/memory", "device_type", "memory");\n<128> \n<129> qemu_devtree_setprop(fdt, "/memory", "reg", mem_reg_property,\n<130> \n<131> sizeof(mem_reg_property));\n<132> \n<133> \n<134> \n<135> qemu_devtree_add_subnode(fdt, "/chosen");\n<136> \n<137> if (initrd_size) {\n<138> \n<139> ret = qemu_devtree_setprop_cell(fdt, "/chosen", "linux,initrd-start",\n<140> \n<141> initrd_base);\n<142> \n<143> if (ret < 0) {\n<144> \n<145> fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");\n<146> \n<147> }\n<148> \n<149> \n<150> \n<151> ret = qemu_devtree_setprop_cell(fdt, "/chosen", "linux,initrd-end",\n<152> \n<153> (initrd_base + initrd_size));\n<154> \n<155> if (ret < 0) {\n<156> \n<157> fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");\n<158> \n<159> }\n<160> \n<161> }\n<162> \n<163> \n<164> \n<165> ret = qemu_devtree_setprop_string(fdt, "/chosen", "bootargs",\n<166> \n<167> args->kernel_cmdline);\n<168> \n<169> if (ret < 0)\n<170> \n<171> fprintf(stderr, "couldn't set /chosen/bootargs\n");\n<172> \n<173> \n<174> \n<175> if (kvm_enabled()) {\n<176> \n<177> /* Read out host's frequencies */\n<178> \n<179> clock_freq = kvmppc_get_clockfreq();\n<180> \n<181> tb_freq = kvmppc_get_tbfreq();\n<182> \n<183> \n<184> \n<185> /* indicate KVM hypercall interface */\n<186> \n<187> qemu_devtree_add_subnode(fdt, "/hypervisor");\n<188> \n<189> qemu_devtree_setprop_string(fdt, "/hypervisor", "compatible",\n<190> \n<191> "linux,kvm");\n<192> \n<193> kvmppc_get_hypercall(env, hypercall, sizeof(hypercall));\n<194> \n<195> qemu_devtree_setprop(fdt, "/hypervisor", "hcall-instructions",\n<196> \n<197> hypercall, sizeof(hypercall));\n<198> \n<199> /* if KVM supports the idle hcall, set property indicating this */\n<200> \n<201> if (kvmppc_get_hasidle(env)) {\n<202> \n<203> qemu_devtree_setprop(fdt, "/hypervisor", "has-idle", NULL, 0);\n<204> \n<205> }\n<206> \n<207> }\n<208> \n<209> \n<210> \n<211> /* Create CPU nodes */\n<212> \n<213> qemu_devtree_add_subnode(fdt, "/cpus");\n<214> \n<215> qemu_devtree_setprop_cell(fdt, "/cpus", "#address-cells", 1);\n<216> \n<217> qemu_devtree_setprop_cell(fdt, "/cpus", "#size-cells", 0);\n<218> \n<219> \n<220> \n<221> /* We need to generate the cpu nodes in reverse order, so Linux can pick\n<222> \n<223> the first node as boot node and be happy */\n<224> \n<225> for (i = smp_cpus - 1; i >= 0; i--) {\n<226> \n<227> CPUState *cpu;\n<228> \n<229> char cpu_name[128];\n<230> \n<231> uint64_t cpu_release_addr = MPC8544_SPIN_BASE + (i * 0x20);\n<232> \n<233> \n<234> \n<235> cpu = qemu_get_cpu(i);\n<236> \n<237> if (cpu == NULL) {\n<238> \n<239> continue;\n<240> \n<241> }\n<242> \n<243> env = cpu->env_ptr;\n<244> \n<245> \n<246> \n<247> snprintf(cpu_name, sizeof(cpu_name), "/cpus/PowerPC,8544@%x",\n<248> \n<249> cpu->cpu_index);\n<250> \n<251> qemu_devtree_add_subnode(fdt, cpu_name);\n<252> \n<253> qemu_devtree_setprop_cell(fdt, cpu_name, "clock-frequency", clock_freq);\n<254> \n<255> qemu_devtree_setprop_cell(fdt, cpu_name, "timebase-frequency", tb_freq);\n<256> \n<257> qemu_devtree_setprop_string(fdt, cpu_name, "device_type", "cpu");\n<258> \n<259> qemu_devtree_setprop_cell(fdt, cpu_name, "reg", cpu->cpu_index);\n<260> \n<261> qemu_devtree_setprop_cell(fdt, cpu_name, "d-cache-line-size",\n<262> \n<263> env->dcache_line_size);\n<264> \n<265> qemu_devtree_setprop_cell(fdt, cpu_name, "i-cache-line-size",\n<266> \n<267> env->icache_line_size);\n<268> \n<269> qemu_devtree_setprop_cell(fdt, cpu_name, "d-cache-size", 0x8000);\n<270> \n<271> qemu_devtree_setprop_cell(fdt, cpu_name, "i-cache-size", 0x8000);\n<272> \n<273> qemu_devtree_setprop_cell(fdt, cpu_name, "bus-frequency", 0);\n<274> \n<275> if (cpu->cpu_index) {\n<276> \n<277> qemu_devtree_setprop_string(fdt, cpu_name, "status", "disabled");\n<278> \n<279> qemu_devtree_setprop_string(fdt, cpu_name, "enable-method", "spin-table");\n<280> \n<281> qemu_devtree_setprop_u64(fdt, cpu_name, "cpu-release-addr",\n<282> \n<283> cpu_release_addr);\n<284> \n<285> } else {\n<286> \n<287> qemu_devtree_setprop_string(fdt, cpu_name, "status", "okay");\n<288> \n<289> }\n<290> \n<291> }\n<292> \n<293> \n<294> \n<295> qemu_devtree_add_subnode(fdt, "/aliases");\n<296> \n<297> /* XXX These should go into their respective devices' code */\n<298> \n<299> snprintf(soc, sizeof(soc), "/soc@%llx", MPC8544_CCSRBAR_BASE);\n<300> \n<301> qemu_devtree_add_subnode(fdt, soc);\n<302> \n<303> qemu_devtree_setprop_string(fdt, soc, "device_type", "soc");\n<304> \n<305> qemu_devtree_setprop(fdt, soc, "compatible", compatible_sb,\n<306> \n<307> sizeof(compatible_sb));\n<308> \n<309> qemu_devtree_setprop_cell(fdt, soc, "#address-cells", 1);\n<310> \n<311> qemu_devtree_setprop_cell(fdt, soc, "#size-cells", 1);\n<312> \n<313> qemu_devtree_setprop_cells(fdt, soc, "ranges", 0x0,\n<314> \n<315> MPC8544_CCSRBAR_BASE >> 32, MPC8544_CCSRBAR_BASE,\n<316> \n<317> MPC8544_CCSRBAR_SIZE);\n<318> \n<319> /* XXX should contain a reasonable value */\n<320> \n<321> qemu_devtree_setprop_cell(fdt, soc, "bus-frequency", 0);\n<322> \n<323> \n<324> \n<325> snprintf(mpic, sizeof(mpic), "%s/pic@%llx", soc, MPC8544_MPIC_REGS_OFFSET);\n<326> \n<327> qemu_devtree_add_subnode(fdt, mpic);\n<328> \n<329> qemu_devtree_setprop_string(fdt, mpic, "device_type", "open-pic");\n<330> \n<331> qemu_devtree_setprop_string(fdt, mpic, "compatible", "fsl,mpic");\n<332> \n<333> qemu_devtree_setprop_cells(fdt, mpic, "reg", MPC8544_MPIC_REGS_OFFSET,\n<334> \n<335> 0x40000);\n<336> \n<337> qemu_devtree_setprop_cell(fdt, mpic, "#address-cells", 0);\n<338> \n<339> qemu_devtree_setprop_cell(fdt, mpic, "#interrupt-cells", 2);\n<340> \n<341> mpic_ph = qemu_devtree_alloc_phandle(fdt);\n<342> \n<343> qemu_devtree_setprop_cell(fdt, mpic, "phandle", mpic_ph);\n<344> \n<345> qemu_devtree_setprop_cell(fdt, mpic, "linux,phandle", mpic_ph);\n<346> \n<347> qemu_devtree_setprop(fdt, mpic, "interrupt-controller", NULL, 0);\n<348> \n<349> \n<350> \n<351> /*\n<352> \n<353> * We have to generate ser1 first, because Linux takes the first\n<354> \n<355> * device it finds in the dt as serial output device. And we generate\n<356> \n<357> * devices in reverse order to the dt.\n<358> \n<359> */\n<360> \n<361> dt_serial_create(fdt, MPC8544_SERIAL1_REGS_OFFSET,\n<362> \n<363> soc, mpic, "serial1", 1, false);\n<364> \n<365> dt_serial_create(fdt, MPC8544_SERIAL0_REGS_OFFSET,\n<366> \n<367> soc, mpic, "serial0", 0, true);\n<368> \n<369> \n<370> \n<371> snprintf(gutil, sizeof(gutil), "%s/global-utilities@%llx", soc,\n<372> \n<373> MPC8544_UTIL_OFFSET);\n<374> \n<375> qemu_devtree_add_subnode(fdt, gutil);\n<376> \n<377> qemu_devtree_setprop_string(fdt, gutil, "compatible", "fsl,mpc8544-guts");\n<378> \n<379> qemu_devtree_setprop_cells(fdt, gutil, "reg", MPC8544_UTIL_OFFSET, 0x1000);\n<380> \n<381> qemu_devtree_setprop(fdt, gutil, "fsl,has-rstcr", NULL, 0);\n<382> \n<383> \n<384> \n<385> snprintf(msi, sizeof(msi), "/%s/msi@%llx", soc, MPC8544_MSI_REGS_OFFSET);\n<386> \n<387> qemu_devtree_add_subnode(fdt, msi);\n<388> \n<389> qemu_devtree_setprop_string(fdt, msi, "compatible", "fsl,mpic-msi");\n<390> \n<391> qemu_devtree_setprop_cells(fdt, msi, "reg", MPC8544_MSI_REGS_OFFSET, 0x200);\n<392> \n<393> msi_ph = qemu_devtree_alloc_phandle(fdt);\n<394> \n<395> qemu_devtree_setprop_cells(fdt, msi, "msi-available-ranges", 0x0, 0x100);\n<396> \n<397> qemu_devtree_setprop_phandle(fdt, msi, "interrupt-parent", mpic);\n<398> \n<399> qemu_devtree_setprop_cells(fdt, msi, "interrupts",\n<400> \n<401> 0xe0, 0x0,\n<402> \n<403> 0xe1, 0x0,\n<404> \n<405> 0xe2, 0x0,\n<406> \n<407> 0xe3, 0x0,\n<408> \n<409> 0xe4, 0x0,\n<410> \n<411> 0xe5, 0x0,\n<412> \n<413> 0xe6, 0x0,\n<414> \n<415> 0xe7, 0x0);\n<416> \n<417> qemu_devtree_setprop_cell(fdt, msi, "phandle", msi_ph);\n<418> \n<419> qemu_devtree_setprop_cell(fdt, msi, "linux,phandle", msi_ph);\n<420> \n<421> \n<422> \n<423> snprintf(pci, sizeof(pci), "/pci@%llx", MPC8544_PCI_REGS_BASE);\n<424> \n<425> qemu_devtree_add_subnode(fdt, pci);\n<426> \n<427> qemu_devtree_setprop_cell(fdt, pci, "cell-index", 0);\n<428> \n<429> qemu_devtree_setprop_string(fdt, pci, "compatible", "fsl,mpc8540-pci");\n<430> \n<431> qemu_devtree_setprop_string(fdt, pci, "device_type", "pci");\n<432> \n<433> qemu_devtree_setprop_cells(fdt, pci, "interrupt-map-mask", 0xf800, 0x0,\n<434> \n<435> 0x0, 0x7);\n<436> \n<437> pci_map = pci_map_create(fdt, qemu_devtree_get_phandle(fdt, mpic),\n<438> \n<439> params->pci_first_slot, params->pci_nr_slots,\n<440> \n<441> &len);\n<442> \n<443> qemu_devtree_setprop(fdt, pci, "interrupt-map", pci_map, len);\n<444> \n<445> qemu_devtree_setprop_phandle(fdt, pci, "interrupt-parent", mpic);\n<446> \n<447> qemu_devtree_setprop_cells(fdt, pci, "interrupts", 24, 2);\n<448> \n<449> qemu_devtree_setprop_cells(fdt, pci, "bus-range", 0, 255);\n<450> \n<451> for (i = 0; i < 14; i++) {\n<452> \n<453> pci_ranges[i] = cpu_to_be32(pci_ranges[i]);\n<454> \n<455> }\n<456> \n<457> qemu_devtree_setprop_cell(fdt, pci, "fsl,msi", msi_ph);\n<458> \n<459> qemu_devtree_setprop(fdt, pci, "ranges", pci_ranges, sizeof(pci_ranges));\n<460> \n<461> qemu_devtree_setprop_cells(fdt, pci, "reg", MPC8544_PCI_REGS_BASE >> 32,\n<462> \n<463> MPC8544_PCI_REGS_BASE, 0, 0x1000);\n<464> \n<465> qemu_devtree_setprop_cell(fdt, pci, "clock-frequency", 66666666);\n<466> \n<467> qemu_devtree_setprop_cell(fdt, pci, "#interrupt-cells", 1);\n<468> \n<469> qemu_devtree_setprop_cell(fdt, pci, "#size-cells", 2);\n<470> \n<471> qemu_devtree_setprop_cell(fdt, pci, "#address-cells", 3);\n<472> \n<473> qemu_devtree_setprop_string(fdt, "/aliases", "pci0", pci);\n<474> \n<475> \n<476> \n<477> params->fixup_devtree(params, fdt);\n<478> \n<479> \n<480> \n<481> if (toplevel_compat) {\n<482> \n<483> qemu_devtree_setprop(fdt, "/", "compatible", toplevel_compat,\n<484> \n<485> strlen(toplevel_compat) + 1);\n<486> \n<487> }\n<488> \n<489> \n<490> \n<491> done:\n<492> \n<493> qemu_devtree_dumpdtb(fdt, fdt_size);\n<494> \n<495> ret = rom_add_blob_fixed(BINARY_DEVICE_TREE_FILE, fdt, fdt_size, addr);\n<496> \n<497> if (ret < 0) {\n<498> \n<499> goto out;\n<500> \n<501> }\n<502> \n<503> g_free(fdt);\n<504> \n<505> ret = fdt_size;\n<506> \n<507> \n<508> \n<509> out:\n<510> \n<511> g_free(pci_map);\n<512> \n<513> \n<514> \n<515> return ret;\n<516> \n<517> }\n<518> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void xhci_port_write(void *ptr, hwaddr reg,\n<2> \n<3> uint64_t val, unsigned size)\n<4> \n<5> {\n<6> \n<7> XHCIPort *port = ptr;\n<8> \n<9> uint32_t portsc, notify;\n<10> \n<11> \n<12> \n<13> trace_usb_xhci_port_write(port->portnr, reg, val);\n<14> \n<15> \n<16> \n<17> switch (reg) {\n<18> \n<19> case 0x00: /* PORTSC */\n<20> \n<21> /* write-1-to-start bits */\n<22> \n<23> if (val & PORTSC_PR) {\n<24> \n<25> xhci_port_reset(port);\n<26> \n<27> break;\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> portsc = port->portsc;\n<34> \n<35> notify = 0;\n<36> \n<37> /* write-1-to-clear bits*/\n<38> \n<39> portsc &= ~(val & (PORTSC_CSC|PORTSC_PEC|PORTSC_WRC|PORTSC_OCC|\n<40> \n<41> PORTSC_PRC|PORTSC_PLC|PORTSC_CEC));\n<42> \n<43> if (val & PORTSC_LWS) {\n<44> \n<45> /* overwrite PLS only when LWS=1 */\n<46> \n<47> uint32_t old_pls = get_field(port->portsc, PORTSC_PLS);\n<48> \n<49> uint32_t new_pls = get_field(val, PORTSC_PLS);\n<50> \n<51> switch (new_pls) {\n<52> \n<53> case PLS_U0:\n<54> \n<55> if (old_pls != PLS_U0) {\n<56> \n<57> set_field(&portsc, new_pls, PORTSC_PLS);\n<58> \n<59> trace_usb_xhci_port_link(port->portnr, new_pls);\n<60> \n<61> notify = PORTSC_PLC;\n<62> \n<63> }\n<64> \n<65> break;\n<66> \n<67> case PLS_U3:\n<68> \n<69> if (old_pls < PLS_U3) {\n<70> \n<71> set_field(&portsc, new_pls, PORTSC_PLS);\n<72> \n<73> trace_usb_xhci_port_link(port->portnr, new_pls);\n<74> \n<75> }\n<76> \n<77> break;\n<78> \n<79> case PLS_RESUME:\n<80> \n<81> /* windows does this for some reason, don't spam stderr */\n<82> \n<83> break;\n<84> \n<85> default:\n<86> \n<87> fprintf(stderr, "%s: ignore pls write (old %d, new %d)\n",\n<88> \n<89> __func__, old_pls, new_pls);\n<90> \n<91> break;\n<92> \n<93> }\n<94> \n<95> }\n<96> \n<97> /* read/write bits */\n<98> \n<99> portsc &= ~(PORTSC_PP|PORTSC_WCE|PORTSC_WDE|PORTSC_WOE);\n<100> \n<101> portsc |= (val & (PORTSC_PP|PORTSC_WCE|PORTSC_WDE|PORTSC_WOE));\n<102> \n<103> port->portsc = portsc;\n<104> \n<105> if (notify) {\n<106> \n<107> xhci_port_notify(port, notify);\n<108> \n<109> }\n<110> \n<111> break;\n<112> \n<113> case 0x04: /* PORTPMSC */\n<114> \n<115> case 0x08: /* PORTLI */\n<116> \n<117> default:\n<118> \n<119> trace_usb_xhci_unimplemented("port write", reg);\n<120> \n<121> }\n<122> \n<123> }\n<124> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> SocketAddress *socket_parse(const char *str, Error **errp)\n<2> \n<3> {\n<4> \n<5> SocketAddress *addr;\n<6> \n<7> \n<8> \n<9> addr = g_new0(SocketAddress, 1);\n<10> \n<11> if (strstart(str, "unix:", NULL)) {\n<12> \n<13> if (str[5] == '\0') {\n<14> \n<15> error_setg(errp, "invalid Unix socket address");\n<16> \n<17> goto fail;\n<18> \n<19> } else {\n<20> \n<21> addr->type = SOCKET_ADDRESS_KIND_UNIX;\n<22> \n<23> addr->u.q_unix.data = g_new(UnixSocketAddress, 1);\n<24> \n<25> addr->u.q_unix.data->path = g_strdup(str + 5);\n<26> \n<27> }\n<28> \n<29> } else if (strstart(str, "fd:", NULL)) {\n<30> \n<31> if (str[3] == '\0') {\n<32> \n<33> error_setg(errp, "invalid file descriptor address");\n<34> \n<35> goto fail;\n<36> \n<37> } else {\n<38> \n<39> addr->type = SOCKET_ADDRESS_KIND_FD;\n<40> \n<41> addr->u.fd.data = g_new(String, 1);\n<42> \n<43> addr->u.fd.data->str = g_strdup(str + 3);\n<44> \n<45> }\n<46> \n<47> } else if (strstart(str, "vsock:", NULL)) {\n<48> \n<49> addr->type = SOCKET_ADDRESS_KIND_VSOCK;\n<50> \n<51> addr->u.vsock.data = g_new(VsockSocketAddress, 1);\n<52> \n<53> if (vsock_parse(addr->u.vsock.data, str + strlen("vsock:"), errp)) {\n<54> \n<55> goto fail;\n<56> \n<57> }\n<58> \n<59> } else {\n<60> \n<61> addr->type = SOCKET_ADDRESS_KIND_INET;\n<62> \n<63> addr->u.inet.data = g_new(InetSocketAddress, 1);\n<64> \n<65> if (inet_parse(addr->u.inet.data, str, errp)) {\n<66> \n<67> goto fail;\n<68> \n<69> }\n<70> \n<71> }\n<72> \n<73> return addr;\n<74> \n<75> \n<76> \n<77> fail:\n<78> \n<79> qapi_free_SocketAddress(addr);\n<80> \n<81> return NULL;\n<82> \n<83> }\n<84> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int decrypt_init(AVFormatContext *s, ID3v2ExtraMeta *em, uint8_t *header)\n<2> \n<3> {\n<4> \n<5> OMAContext *oc = s->priv_data;\n<6> \n<7> ID3v2ExtraMetaGEOB *geob = NULL;\n<8> \n<9> uint8_t *gdata;\n<10> \n<11> \n<12> \n<13> oc->encrypted = 1;\n<14> \n<15> av_log(s, AV_LOG_INFO, "File is encrypted\n");\n<16> \n<17> \n<18> \n<19> /* find GEOB metadata */\n<20> \n<21> while (em) {\n<22> \n<23> if (!strcmp(em->tag, "GEOB") &&\n<24> \n<25> (geob = em->data) &&\n<26> \n<27> (!strcmp(geob->description, "OMG_LSI") ||\n<28> \n<29> !strcmp(geob->description, "OMG_BKLSI"))) {\n<30> \n<31> break;\n<32> \n<33> }\n<34> \n<35> em = em->next;\n<36> \n<37> }\n<38> \n<39> if (!em) {\n<40> \n<41> av_log(s, AV_LOG_ERROR, "No encryption header found\n");\n<42> \n<43> return -1;\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> if (geob->datasize < 64) {\n<50> \n<51> av_log(s, AV_LOG_ERROR, "Invalid GEOB data size: %u\n", geob->datasize);\n<52> \n<53> return -1;\n<54> \n<55> }\n<56> \n<57> \n<58> \n<59> gdata = geob->data;\n<60> \n<61> \n<62> \n<63> if (AV_RB16(gdata) != 1)\n<64> \n<65> av_log(s, AV_LOG_WARNING, "Unknown version in encryption header\n");\n<66> \n<67> \n<68> \n<69> oc->k_size = AV_RB16(&gdata[2]);\n<70> \n<71> oc->e_size = AV_RB16(&gdata[4]);\n<72> \n<73> oc->i_size = AV_RB16(&gdata[6]);\n<74> \n<75> oc->s_size = AV_RB16(&gdata[8]);\n<76> \n<77> \n<78> \n<79> if (memcmp(&gdata[OMA_ENC_HEADER_SIZE], "KEYRING     ", 12)) {\n<80> \n<81> av_log(s, AV_LOG_ERROR, "Invalid encryption header\n");\n<82> \n<83> return -1;\n<84> \n<85> }\n<86> \n<87> if (oc->k_size + oc->e_size + oc->i_size > geob->datasize) {\n<88> \n<89> av_log(s, AV_LOG_ERROR, "Too little GEOB data\n");\n<90> \n<91> return AVERROR_INVALIDDATA;\n<92> \n<93> }\n<94> \n<95> oc->rid = AV_RB32(&gdata[OMA_ENC_HEADER_SIZE + 28]);\n<96> \n<97> av_log(s, AV_LOG_DEBUG, "RID: %.8x\n", oc->rid);\n<98> \n<99> \n<100> \n<101> memcpy(oc->iv, &header[0x58], 8);\n<102> \n<103> hex_log(s, AV_LOG_DEBUG, "IV", oc->iv, 8);\n<104> \n<105> \n<106> \n<107> hex_log(s, AV_LOG_DEBUG, "CBC-MAC", &gdata[OMA_ENC_HEADER_SIZE+oc->k_size+oc->e_size+oc->i_size], 8);\n<108> \n<109> \n<110> \n<111> if (s->keylen > 0) {\n<112> \n<113> kset(s, s->key, s->key, s->keylen);\n<114> \n<115> }\n<116> \n<117> if (!memcmp(oc->r_val, (const uint8_t[8]){0}, 8) ||\n<118> \n<119> rprobe(s, gdata, oc->r_val) < 0 &&\n<120> \n<121> nprobe(s, gdata, geob->datasize, oc->n_val) < 0) {\n<122> \n<123> int i;\n<124> \n<125> for (i = 0; i < FF_ARRAY_ELEMS(leaf_table); i += 2) {\n<126> \n<127> uint8_t buf[16];\n<128> \n<129> AV_WL64(buf, leaf_table[i]);\n<130> \n<131> AV_WL64(&buf[8], leaf_table[i+1]);\n<132> \n<133> kset(s, buf, buf, 16);\n<134> \n<135> if (!rprobe(s, gdata, oc->r_val) || !nprobe(s, gdata, geob->datasize, oc->n_val))\n<136> \n<137> break;\n<138> \n<139> }\n<140> \n<141> if (i >= FF_ARRAY_ELEMS(leaf_table)) {\n<142> \n<143> av_log(s, AV_LOG_ERROR, "Invalid key\n");\n<144> \n<145> return -1;\n<146> \n<147> }\n<148> \n<149> }\n<150> \n<151> \n<152> \n<153> /* e_val */\n<154> \n<155> av_des_init(&oc->av_des, oc->m_val, 64, 0);\n<156> \n<157> av_des_crypt(&oc->av_des, oc->e_val, &gdata[OMA_ENC_HEADER_SIZE + 40], 1, NULL, 0);\n<158> \n<159> hex_log(s, AV_LOG_DEBUG, "EK", oc->e_val, 8);\n<160> \n<161> \n<162> \n<163> /* init e_val */\n<164> \n<165> av_des_init(&oc->av_des, oc->e_val, 64, 1);\n<166> \n<167> \n<168> \n<169> return 0;\n<170> \n<171> }\n<172> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void encode_plane(FFV1Context *s, uint8_t *src, int w, int h,\n<2> \n<3> int stride, int plane_index)\n<4> \n<5> {\n<6> \n<7> int x, y, i;\n<8> \n<9> const int ring_size = s->avctx->context_model ? 3 : 2;\n<10> \n<11> int16_t *sample[3];\n<12> \n<13> s->run_index = 0;\n<14> \n<15> \n<16> \n<17> memset(s->sample_buffer, 0, ring_size * (w + 6) * sizeof(*s->sample_buffer));\n<18> \n<19> \n<20> \n<21> for (y = 0; y < h; y++) {\n<22> \n<23> for (i = 0; i < ring_size; i++)\n<24> \n<25> sample[i] = s->sample_buffer + (w + 6) * ((h + i - y) % ring_size) + 3;\n<26> \n<27> \n<28> \n<29> sample[0][-1]= sample[1][0  ];\n<30> \n<31> sample[1][ w]= sample[1][w-1];\n<32> \n<33> // { START_TIMER\n<34> \n<35> if (s->bits_per_raw_sample <= 8) {\n<36> \n<37> for (x = 0; x < w; x++)\n<38> \n<39> sample[0][x] = src[x + stride * y];\n<40> \n<41> encode_line(s, w, sample, plane_index, 8);\n<42> \n<43> } else {\n<44> \n<45> if (s->packed_at_lsb) {\n<46> \n<47> for (x = 0; x < w; x++) {\n<48> \n<49> sample[0][x] = ((uint16_t*)(src + stride*y))[x];\n<50> \n<51> }\n<52> \n<53> } else {\n<54> \n<55> for (x = 0; x < w; x++) {\n<56> \n<57> sample[0][x] = ((uint16_t*)(src + stride*y))[x] >> (16 - s->bits_per_raw_sample);\n<58> \n<59> }\n<60> \n<61> }\n<62> \n<63> encode_line(s, w, sample, plane_index, s->bits_per_raw_sample);\n<64> \n<65> }\n<66> \n<67> // STOP_TIMER("encode line") }\n<68> \n<69> }\n<70> \n<71> }\n<72> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void sbr_mapping(AACContext *ac, SpectralBandReplication *sbr,\n<2> \n<3> SBRData *ch_data, int e_a[2])\n<4> \n<5> {\n<6> \n<7> int e, i, m;\n<8> \n<9> \n<10> \n<11> memset(ch_data->s_indexmapped[1], 0, 7*sizeof(ch_data->s_indexmapped[1]));\n<12> \n<13> for (e = 0; e < ch_data->bs_num_env; e++) {\n<14> \n<15> const unsigned int ilim = sbr->n[ch_data->bs_freq_res[e + 1]];\n<16> \n<17> uint16_t *table = ch_data->bs_freq_res[e + 1] ? sbr->f_tablehigh : sbr->f_tablelow;\n<18> \n<19> int k;\n<20> \n<21> \n<22> \n<23> for (i = 0; i < ilim; i++)\n<24> \n<25> for (m = table[i]; m < table[i + 1]; m++)\n<26> \n<27> sbr->e_origmapped[e][m - sbr->kx[1]] = ch_data->env_facs[e+1][i];\n<28> \n<29> \n<30> \n<31> // ch_data->bs_num_noise > 1 => 2 noise floors\n<32> \n<33> k = (ch_data->bs_num_noise > 1) && (ch_data->t_env[e] >= ch_data->t_q[1]);\n<34> \n<35> for (i = 0; i < sbr->n_q; i++)\n<36> \n<37> for (m = sbr->f_tablenoise[i]; m < sbr->f_tablenoise[i + 1]; m++)\n<38> \n<39> sbr->q_mapped[e][m - sbr->kx[1]] = ch_data->noise_facs[k+1][i];\n<40> \n<41> \n<42> \n<43> for (i = 0; i < sbr->n[1]; i++) {\n<44> \n<45> if (ch_data->bs_add_harmonic_flag) {\n<46> \n<47> const unsigned int m_midpoint =\n<48> \n<49> (sbr->f_tablehigh[i] + sbr->f_tablehigh[i + 1]) >> 1;\n<50> \n<51> \n<52> \n<53> ch_data->s_indexmapped[e + 1][m_midpoint - sbr->kx[1]] = ch_data->bs_add_harmonic[i] *\n<54> \n<55> (e >= e_a[1] || (ch_data->s_indexmapped[0][m_midpoint - sbr->kx[1]] == 1));\n<56> \n<57> }\n<58> \n<59> }\n<60> \n<61> \n<62> \n<63> for (i = 0; i < ilim; i++) {\n<64> \n<65> int additional_sinusoid_present = 0;\n<66> \n<67> for (m = table[i]; m < table[i + 1]; m++) {\n<68> \n<69> if (ch_data->s_indexmapped[e + 1][m - sbr->kx[1]]) {\n<70> \n<71> additional_sinusoid_present = 1;\n<72> \n<73> break;\n<74> \n<75> }\n<76> \n<77> }\n<78> \n<79> memset(&sbr->s_mapped[e][table[i] - sbr->kx[1]], additional_sinusoid_present,\n<80> \n<81> (table[i + 1] - table[i]) * sizeof(sbr->s_mapped[e][0]));\n<82> \n<83> }\n<84> \n<85> }\n<86> \n<87> \n<88> \n<89> memcpy(ch_data->s_indexmapped[0], ch_data->s_indexmapped[ch_data->bs_num_env], sizeof(ch_data->s_indexmapped[0]));\n<90> \n<91> }\n<92> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void av_url_split(char *proto, int proto_size,\n<2> \n<3> char *authorization, int authorization_size,\n<4> \n<5> char *hostname, int hostname_size,\n<6> \n<7> int *port_ptr,\n<8> \n<9> char *path, int path_size,\n<10> \n<11> const char *url)\n<12> \n<13> {\n<14> \n<15> const char *p, *ls, *ls2, *at, *col, *brk;\n<16> \n<17> \n<18> \n<19> if (port_ptr)               *port_ptr = -1;\n<20> \n<21> if (proto_size > 0)         proto[0] = 0;\n<22> \n<23> if (authorization_size > 0) authorization[0] = 0;\n<24> \n<25> if (hostname_size > 0)      hostname[0] = 0;\n<26> \n<27> if (path_size > 0)          path[0] = 0;\n<28> \n<29> \n<30> \n<31> /* parse protocol */\n<32> \n<33> if ((p = strchr(url, ':'))) {\n<34> \n<35> av_strlcpy(proto, url, FFMIN(proto_size, p + 1 - url));\n<36> \n<37> p++; /* skip ':' */\n<38> \n<39> if (*p == '/') p++;\n<40> \n<41> if (*p == '/') p++;\n<42> \n<43> } else {\n<44> \n<45> /* no protocol means plain filename */\n<46> \n<47> av_strlcpy(path, url, path_size);\n<48> \n<49> return;\n<50> \n<51> }\n<52> \n<53> \n<54> \n<55> /* separate path from hostname */\n<56> \n<57> ls = strchr(p, '/');\n<58> \n<59> ls2 = strchr(p, '?');\n<60> \n<61> if(!ls)\n<62> \n<63> ls = ls2;\n<64> \n<65> else if (ls && ls2)\n<66> \n<67> ls = FFMIN(ls, ls2);\n<68> \n<69> if(ls)\n<70> \n<71> av_strlcpy(path, ls, path_size);\n<72> \n<73> else\n<74> \n<75> ls = &p[strlen(p)]; // XXX\n<76> \n<77> \n<78> \n<79> /* the rest is hostname, use that to parse auth/port */\n<80> \n<81> if (ls != p) {\n<82> \n<83> /* authorization (user[:pass]@hostname) */\n<84> \n<85> if ((at = strchr(p, '@')) && at < ls) {\n<86> \n<87> av_strlcpy(authorization, p,\n<88> \n<89> FFMIN(authorization_size, at + 1 - p));\n<90> \n<91> p = at + 1; /* skip '@' */\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> if (*p == '[' && (brk = strchr(p, ']')) && brk < ls) {\n<98> \n<99> /* [host]:port */\n<100> \n<101> av_strlcpy(hostname, p + 1,\n<102> \n<103> FFMIN(hostname_size, brk - p));\n<104> \n<105> if (brk[1] == ':' && port_ptr)\n<106> \n<107> *port_ptr = atoi(brk + 2);\n<108> \n<109> } else if ((col = strchr(p, ':')) && col < ls) {\n<110> \n<111> av_strlcpy(hostname, p,\n<112> \n<113> FFMIN(col + 1 - p, hostname_size));\n<114> \n<115> if (port_ptr) *port_ptr = atoi(col + 1);\n<116> \n<117> } else\n<118> \n<119> av_strlcpy(hostname, p,\n<120> \n<121> FFMIN(ls + 1 - p, hostname_size));\n<122> \n<123> }\n<124> \n<125> }\n<126> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static unsigned int dec_btstq(DisasContext *dc)\n<2> \n<3> {\n<4> \n<5> TCGv l0;\n<6> \n<7> dc->op1 = EXTRACT_FIELD(dc->ir, 0, 4);\n<8> \n<9> DIS(fprintf (logfile, "btstq %u, $r%d\n", dc->op1, dc->op2));\n<10> \n<11> \n<12> \n<13> cris_cc_mask(dc, CC_MASK_NZ);\n<14> \n<15> l0 = tcg_temp_local_new(TCG_TYPE_TL);\n<16> \n<17> cris_alu(dc, CC_OP_BTST,\n<18> \n<19> l0, cpu_R[dc->op2], tcg_const_tl(dc->op1), 4);\n<20> \n<21> cris_update_cc_op(dc, CC_OP_FLAGS, 4);\n<22> \n<23> t_gen_mov_preg_TN(dc, PR_CCS, l0);\n<24> \n<25> dc->flags_uptodate = 1;\n<26> \n<27> tcg_temp_free(l0);\n<28> \n<29> return 2;\n<30> \n<31> }\n<32> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)\n<2> \n<3> {\n<4> \n<5> uint8_t *cdb = req->iu.srp.cmd.cdb;\n<6> \n<7> uint8_t resp_data[36];\n<8> \n<9> int rc, len, alen;\n<10> \n<11> \n<12> \n<13> /* We dont do EVPD. Also check that page_code is 0 */\n<14> \n<15> if ((cdb[1] & 0x01) || (cdb[1] & 0x01) || cdb[2] != 0) {\n<16> \n<17> /* Send INVALID FIELD IN CDB */\n<18> \n<19> vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0);\n<20> \n<21> vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n<22> \n<23> return;\n<24> \n<25> }\n<26> \n<27> alen = cdb[3];\n<28> \n<29> alen = (alen << 8) | cdb[4];\n<30> \n<31> len = MIN(alen, 36);\n<32> \n<33> \n<34> \n<35> /* Fake up inquiry using PQ=3 */\n<36> \n<37> memset(resp_data, 0, 36);\n<38> \n<39> resp_data[0] = 0x7f;   /* Not capable of supporting a device here */\n<40> \n<41> resp_data[2] = 0x06;   /* SPS-4 */\n<42> \n<43> resp_data[3] = 0x02;   /* Resp data format */\n<44> \n<45> resp_data[4] = 36 - 5; /* Additional length */\n<46> \n<47> resp_data[7] = 0x10;   /* Sync transfers */\n<48> \n<49> memcpy(&resp_data[16], "QEMU EMPTY      ", 16);\n<50> \n<51> memcpy(&resp_data[8], "QEMU    ", 8);\n<52> \n<53> \n<54> \n<55> req->writing = 0;\n<56> \n<57> vscsi_preprocess_desc(req);\n<58> \n<59> rc = vscsi_srp_transfer_data(s, req, 0, resp_data, len);\n<60> \n<61> if (rc < 0) {\n<62> \n<63> vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n<64> \n<65> vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n<66> \n<67> } else {\n<68> \n<69> vscsi_send_rsp(s, req, 0, 36 - rc, 0);\n<70> \n<71> }\n<72> \n<73> }\n<74> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int get_pci_irq_state(QEMUFile *f, void *pv, size_t size)\n<2> \n<3> {\n<4> \n<5> PCIDevice *s = container_of(pv, PCIDevice, config);\n<6> \n<7> uint32_t irq_state[PCI_NUM_PINS];\n<8> \n<9> int i;\n<10> \n<11> for (i = 0; i < PCI_NUM_PINS; ++i) {\n<12> \n<13> irq_state[i] = qemu_get_be32(f);\n<14> \n<15> if (irq_state[i] != 0x1 && irq_state[i] != 0) {\n<16> \n<17> fprintf(stderr, "irq state %d: must be 0 or 1.\n",\n<18> \n<19> irq_state[i]);\n<20> \n<21> return -EINVAL;\n<22> \n<23> }\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> for (i = 0; i < PCI_NUM_PINS; ++i) {\n<30> \n<31> pci_set_irq_state(s, i, irq_state[i]);\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> return 0;\n<38> \n<39> }\n<40> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mxf_parse_structural_metadata(MXFContext *mxf)\n<2> \n<3> {\n<4> \n<5> MXFPackage *material_package = NULL;\n<6> \n<7> MXFPackage *source_package = NULL;\n<8> \n<9> MXFPackage *temp_package = NULL;\n<10> \n<11> int i, j, k;\n<12> \n<13> \n<14> \n<15> dprintf("metadata sets count %d\n", mxf->metadata_sets_count);\n<16> \n<17> /* TODO: handle multiple material packages (OP3x) */\n<18> \n<19> for (i = 0; i < mxf->packages_count; i++) {\n<20> \n<21> if (!(temp_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i]))) {\n<22> \n<23> av_log(mxf->fc, AV_LOG_ERROR, "could not resolve package strong ref\n");\n<24> \n<25> return -1;\n<26> \n<27> }\n<28> \n<29> if (temp_package->type == MaterialPackage) {\n<30> \n<31> material_package = temp_package;\n<32> \n<33> break;\n<34> \n<35> }\n<36> \n<37> }\n<38> \n<39> if (!material_package) {\n<40> \n<41> av_log(mxf->fc, AV_LOG_ERROR, "no material package found\n");\n<42> \n<43> return -1;\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> for (i = 0; i < material_package->tracks_count; i++) {\n<50> \n<51> MXFTrack *material_track = NULL;\n<52> \n<53> MXFTrack *source_track = NULL;\n<54> \n<55> MXFTrack *temp_track = NULL;\n<56> \n<57> MXFDescriptor *descriptor = NULL;\n<58> \n<59> MXFStructuralComponent *component = NULL;\n<60> \n<61> const MXFCodecUL *codec_ul = NULL;\n<62> \n<63> const MXFCodecUL *container_ul = NULL;\n<64> \n<65> AVStream *st;\n<66> \n<67> \n<68> \n<69> if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i]))) {\n<70> \n<71> av_log(mxf->fc, AV_LOG_ERROR, "could not resolve material track strong ref\n");\n<72> \n<73> continue;\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref))) {\n<80> \n<81> av_log(mxf->fc, AV_LOG_ERROR, "could not resolve material track sequence strong ref\n");\n<82> \n<83> return -1;\n<84> \n<85> }\n<86> \n<87> \n<88> \n<89> /* TODO: handle multiple source clips */\n<90> \n<91> for (j = 0; j < material_track->sequence->structural_components_count; j++) {\n<92> \n<93> /* TODO: handle timecode component */\n<94> \n<95> component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j]);\n<96> \n<97> if (!component || component->type != SourceClip)\n<98> \n<99> continue;\n<100> \n<101> \n<102> \n<103> for (k = 0; k < mxf->packages_count; k++) {\n<104> \n<105> if (!(temp_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[k]))) {\n<106> \n<107> av_log(mxf->fc, AV_LOG_ERROR, "could not resolve source track strong ref\n");\n<108> \n<109> return -1;\n<110> \n<111> }\n<112> \n<113> if (!memcmp(temp_package->package_uid, component->source_package_uid, 16)) {\n<114> \n<115> source_package = temp_package;\n<116> \n<117> break;\n<118> \n<119> }\n<120> \n<121> }\n<122> \n<123> if (!source_package) {\n<124> \n<125> av_log(mxf->fc, AV_LOG_ERROR, "material track %d: no corresponding source package found\n", material_track->track_id);\n<126> \n<127> break;\n<128> \n<129> }\n<130> \n<131> for (k = 0; k < source_package->tracks_count; k++) {\n<132> \n<133> if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k]))) {\n<134> \n<135> av_log(mxf->fc, AV_LOG_ERROR, "could not resolve source track strong ref\n");\n<136> \n<137> return -1;\n<138> \n<139> }\n<140> \n<141> if (temp_track->track_id == component->source_track_id) {\n<142> \n<143> source_track = temp_track;\n<144> \n<145> break;\n<146> \n<147> }\n<148> \n<149> }\n<150> \n<151> if (!source_track) {\n<152> \n<153> av_log(mxf->fc, AV_LOG_ERROR, "material track %d: no corresponding source track found\n", material_track->track_id);\n<154> \n<155> break;\n<156> \n<157> }\n<158> \n<159> }\n<160> \n<161> if (!source_track)\n<162> \n<163> continue;\n<164> \n<165> \n<166> \n<167> st = av_new_stream(mxf->fc, source_track->track_id);\n<168> \n<169> st->priv_data = source_track;\n<170> \n<171> st->duration = component->duration;\n<172> \n<173> if (st->duration == -1)\n<174> \n<175> st->duration = AV_NOPTS_VALUE;\n<176> \n<177> st->start_time = component->start_position;\n<178> \n<179> av_set_pts_info(st, 64, material_track->edit_rate.num, material_track->edit_rate.den);\n<180> \n<181> \n<182> \n<183> if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref))) {\n<184> \n<185> av_log(mxf->fc, AV_LOG_ERROR, "could not resolve source track sequence strong ref\n");\n<186> \n<187> return -1;\n<188> \n<189> }\n<190> \n<191> \n<192> \n<193> #ifdef DEBUG\n<194> \n<195> PRINT_KEY("data definition   ul", source_track->sequence->data_definition_ul);\n<196> \n<197> #endif\n<198> \n<199> st->codec->codec_type = mxf_get_codec_type(mxf_data_definition_uls, &source_track->sequence->data_definition_ul);\n<200> \n<201> \n<202> \n<203> source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref);\n<204> \n<205> if (source_package->descriptor) {\n<206> \n<207> if (source_package->descriptor->type == MultipleDescriptor) {\n<208> \n<209> for (j = 0; j < source_package->descriptor->sub_descriptors_count; j++) {\n<210> \n<211> MXFDescriptor *sub_descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor->sub_descriptors_refs[j]);\n<212> \n<213> \n<214> \n<215> if (!sub_descriptor) {\n<216> \n<217> av_log(mxf->fc, AV_LOG_ERROR, "could not resolve sub descriptor strong ref\n");\n<218> \n<219> continue;\n<220> \n<221> }\n<222> \n<223> if (sub_descriptor->linked_track_id == source_track->track_id) {\n<224> \n<225> descriptor = sub_descriptor;\n<226> \n<227> break;\n<228> \n<229> }\n<230> \n<231> }\n<232> \n<233> } else\n<234> \n<235> descriptor = source_package->descriptor;\n<236> \n<237> }\n<238> \n<239> if (!descriptor) {\n<240> \n<241> av_log(mxf->fc, AV_LOG_INFO, "source track %d: stream %d, no descriptor found\n", source_track->track_id, st->index);\n<242> \n<243> continue;\n<244> \n<245> }\n<246> \n<247> #ifdef DEBUG\n<248> \n<249> PRINT_KEY("essence codec     ul", descriptor->essence_codec_ul);\n<250> \n<251> PRINT_KEY("essence container ul", descriptor->essence_container_ul);\n<252> \n<253> #endif\n<254> \n<255> /* TODO: drop PictureEssenceCoding and SoundEssenceCompression, only check EssenceContainer */\n<256> \n<257> codec_ul = mxf_get_codec_ul(mxf_codec_uls, &descriptor->essence_codec_ul);\n<258> \n<259> st->codec->codec_id = codec_ul->id;\n<260> \n<261> if (descriptor->extradata) {\n<262> \n<263> st->codec->extradata = descriptor->extradata;\n<264> \n<265> st->codec->extradata_size = descriptor->extradata_size;\n<266> \n<267> }\n<268> \n<269> if (st->codec->codec_type == CODEC_TYPE_VIDEO) {\n<270> \n<271> container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, &descriptor->essence_container_ul);\n<272> \n<273> if (st->codec->codec_id == CODEC_ID_NONE)\n<274> \n<275> st->codec->codec_id = container_ul->id;\n<276> \n<277> st->codec->width = descriptor->width;\n<278> \n<279> st->codec->height = descriptor->height;\n<280> \n<281> st->codec->bits_per_sample = descriptor->bits_per_sample; /* Uncompressed */\n<282> \n<283> st->need_parsing = 2; /* only parse headers */\n<284> \n<285> } else if (st->codec->codec_type == CODEC_TYPE_AUDIO) {\n<286> \n<287> container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, &descriptor->essence_container_ul);\n<288> \n<289> if (st->codec->codec_id == CODEC_ID_NONE)\n<290> \n<291> st->codec->codec_id = container_ul->id;\n<292> \n<293> st->codec->channels = descriptor->channels;\n<294> \n<295> st->codec->bits_per_sample = descriptor->bits_per_sample;\n<296> \n<297> st->codec->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den;\n<298> \n<299> /* TODO: implement CODEC_ID_RAWAUDIO */\n<300> \n<301> if (st->codec->codec_id == CODEC_ID_PCM_S16LE) {\n<302> \n<303> if (descriptor->bits_per_sample == 24)\n<304> \n<305> st->codec->codec_id = CODEC_ID_PCM_S24LE;\n<306> \n<307> else if (descriptor->bits_per_sample == 32)\n<308> \n<309> st->codec->codec_id = CODEC_ID_PCM_S32LE;\n<310> \n<311> } else if (st->codec->codec_id == CODEC_ID_PCM_S16BE) {\n<312> \n<313> if (descriptor->bits_per_sample == 24)\n<314> \n<315> st->codec->codec_id = CODEC_ID_PCM_S24BE;\n<316> \n<317> else if (descriptor->bits_per_sample == 32)\n<318> \n<319> st->codec->codec_id = CODEC_ID_PCM_S32BE;\n<320> \n<321> if (descriptor->essence_container_ul[13] == 0x01) /* D-10 Mapping */\n<322> \n<323> st->codec->channels = 8; /* force channels to 8 */\n<324> \n<325> } else if (st->codec->codec_id == CODEC_ID_MP2) {\n<326> \n<327> st->need_parsing = 1;\n<328> \n<329> }\n<330> \n<331> }\n<332> \n<333> if (container_ul && container_ul->wrapping == Clip) {\n<334> \n<335> dprintf("stream %d: clip wrapped essence\n", st->index);\n<336> \n<337> st->need_parsing = 1;\n<338> \n<339> }\n<340> \n<341> }\n<342> \n<343> return 0;\n<344> \n<345> }\n<346> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static float pvq_band_cost(CeltPVQ *pvq, CeltFrame *f, OpusRangeCoder *rc, int band,\n<2> \n<3> float *bits, float lambda)\n<4> \n<5> {\n<6> \n<7> int i, b = 0;\n<8> \n<9> uint32_t cm[2] = { (1 << f->blocks) - 1, (1 << f->blocks) - 1 };\n<10> \n<11> const int band_size = ff_celt_freq_range[band] << f->size;\n<12> \n<13> float buf[176 * 2], lowband_scratch[176], norm1[176], norm2[176];\n<14> \n<15> float dist, cost, err_x = 0.0f, err_y = 0.0f;\n<16> \n<17> float *X = buf;\n<18> \n<19> float *X_orig = f->block[0].coeffs + (ff_celt_freq_bands[band] << f->size);\n<20> \n<21> float *Y = (f->channels == 2) ? &buf[176] : NULL;\n<22> \n<23> float *Y_orig = f->block[1].coeffs + (ff_celt_freq_bands[band] << f->size);\n<24> \n<25> OPUS_RC_CHECKPOINT_SPAWN(rc);\n<26> \n<27> \n<28> \n<29> memcpy(X, X_orig, band_size*sizeof(float));\n<30> \n<31> if (Y)\n<32> \n<33> memcpy(Y, Y_orig, band_size*sizeof(float));\n<34> \n<35> \n<36> \n<37> f->remaining2 = ((f->framebits << 3) - f->anticollapse_needed) - opus_rc_tell_frac(rc) - 1;\n<38> \n<39> if (band <= f->coded_bands - 1) {\n<40> \n<41> int curr_balance = f->remaining / FFMIN(3, f->coded_bands - band);\n<42> \n<43> b = av_clip_uintp2(FFMIN(f->remaining2 + 1, f->pulses[band] + curr_balance), 14);\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> if (f->dual_stereo) {\n<50> \n<51> pvq->quant_band(pvq, f, rc, band, X, NULL, band_size, b / 2, f->blocks, NULL,\n<52> \n<53> f->size, norm1, 0, 1.0f, lowband_scratch, cm[0]);\n<54> \n<55> \n<56> \n<57> pvq->quant_band(pvq, f, rc, band, Y, NULL, band_size, b / 2, f->blocks, NULL,\n<58> \n<59> f->size, norm2, 0, 1.0f, lowband_scratch, cm[1]);\n<60> \n<61> } else {\n<62> \n<63> pvq->quant_band(pvq, f, rc, band, X, Y, band_size, b, f->blocks, NULL, f->size,\n<64> \n<65> norm1, 0, 1.0f, lowband_scratch, cm[0] | cm[1]);\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> for (i = 0; i < band_size; i++) {\n<72> \n<73> err_x += (X[i] - X_orig[i])*(X[i] - X_orig[i]);\n<74> \n<75> if (Y)\n<76> \n<77> err_y += (Y[i] - Y_orig[i])*(Y[i] - Y_orig[i]);\n<78> \n<79> }\n<80> \n<81> \n<82> \n<83> dist = sqrtf(err_x) + sqrtf(err_y);\n<84> \n<85> cost = OPUS_RC_CHECKPOINT_BITS(rc)/8.0f;\n<86> \n<87> *bits += cost;\n<88> \n<89> \n<90> \n<91> OPUS_RC_CHECKPOINT_ROLLBACK(rc);\n<92> \n<93> \n<94> \n<95> return lambda*dist*cost;\n<96> \n<97> }\n<98> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,\n<2> \n<3> enum AVSampleFormat sample_fmt, int size,\n<4> \n<5> int64_t channel_layout, int planar)\n<6> \n<7> {\n<8> \n<9> AVFilterBuffer *samples = av_mallocz(sizeof(AVFilterBuffer));\n<10> \n<11> AVFilterBufferRef *ref = NULL;\n<12> \n<13> int i, sample_size, chans_nb, bufsize, per_channel_size, step_size = 0;\n<14> \n<15> char *buf;\n<16> \n<17> \n<18> \n<19> if (!samples || !(ref = av_mallocz(sizeof(AVFilterBufferRef))))\n<20> \n<21> goto fail;\n<22> \n<23> \n<24> \n<25> ref->buf                   = samples;\n<26> \n<27> ref->format                = sample_fmt;\n<28> \n<29> \n<30> \n<31> ref->audio = av_mallocz(sizeof(AVFilterBufferRefAudioProps));\n<32> \n<33> if (!ref->audio)\n<34> \n<35> goto fail;\n<36> \n<37> \n<38> \n<39> ref->audio->channel_layout = channel_layout;\n<40> \n<41> ref->audio->size           = size;\n<42> \n<43> ref->audio->planar         = planar;\n<44> \n<45> \n<46> \n<47> /* make sure the buffer gets read permission or it's useless for output */\n<48> \n<49> ref->perms = perms | AV_PERM_READ;\n<50> \n<51> \n<52> \n<53> samples->refcount   = 1;\n<54> \n<55> samples->free       = ff_avfilter_default_free_buffer;\n<56> \n<57> \n<58> \n<59> sample_size = av_get_bytes_per_sample(sample_fmt);\n<60> \n<61> chans_nb = av_get_channel_layout_nb_channels(channel_layout);\n<62> \n<63> \n<64> \n<65> per_channel_size = size/chans_nb;\n<66> \n<67> ref->audio->nb_samples = per_channel_size/sample_size;\n<68> \n<69> \n<70> \n<71> /* Set the number of bytes to traverse to reach next sample of a particular channel:\n<72> \n<73> * For planar, this is simply the sample size.\n<74> \n<75> * For packed, this is the number of samples * sample_size.\n<76> \n<77> */\n<78> \n<79> for (i = 0; i < chans_nb; i++)\n<80> \n<81> samples->linesize[i] = planar > 0 ? per_channel_size : sample_size;\n<82> \n<83> memset(&samples->linesize[chans_nb], 0, (8-chans_nb) * sizeof(samples->linesize[0]));\n<84> \n<85> \n<86> \n<87> /* Calculate total buffer size, round to multiple of 16 to be SIMD friendly */\n<88> \n<89> bufsize = (size + 15)&~15;\n<90> \n<91> buf = av_malloc(bufsize);\n<92> \n<93> if (!buf)\n<94> \n<95> goto fail;\n<96> \n<97> \n<98> \n<99> /* For planar, set the start point of each channel's data within the buffer\n<100> \n<101> * For packed, set the start point of the entire buffer only\n<102> \n<103> */\n<104> \n<105> samples->data[0] = buf;\n<106> \n<107> if (buf && planar) {\n<108> \n<109> for (i = 1; i < chans_nb; i++) {\n<110> \n<111> step_size += per_channel_size;\n<112> \n<113> samples->data[i] = buf + step_size;\n<114> \n<115> }\n<116> \n<117> } else {\n<118> \n<119> for (i = 1; i < chans_nb; i++)\n<120> \n<121> samples->data[i] = buf;\n<122> \n<123> }\n<124> \n<125> \n<126> \n<127> memset(&samples->data[chans_nb], 0, (8-chans_nb) * sizeof(samples->data[0]));\n<128> \n<129> \n<130> \n<131> memcpy(ref->data,     samples->data,     sizeof(ref->data));\n<132> \n<133> memcpy(ref->linesize, samples->linesize, sizeof(ref->linesize));\n<134> \n<135> \n<136> \n<137> return ref;\n<138> \n<139> \n<140> \n<141> fail:\n<142> \n<143> if (ref)\n<144> \n<145> av_free(ref->audio);\n<146> \n<147> av_free(ref);\n<148> \n<149> av_free(samples);\n<150> \n<151> return NULL;\n<152> \n<153> }\n<154> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int msrle_decode_frame(AVCodecContext *avctx,\n<2> \n<3> void *data, int *got_frame,\n<4> \n<5> AVPacket *avpkt)\n<6> \n<7> {\n<8> \n<9> const uint8_t *buf = avpkt->data;\n<10> \n<11> int buf_size = avpkt->size;\n<12> \n<13> MsrleContext *s = avctx->priv_data;\n<14> \n<15> int istride = FFALIGN(avctx->width*avctx->bits_per_coded_sample, 32) / 8;\n<16> \n<17> int ret;\n<18> \n<19> \n<20> \n<21> s->buf = buf;\n<22> \n<23> s->size = buf_size;\n<24> \n<25> \n<26> \n<27> if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n<28> \n<29> return ret;\n<30> \n<31> \n<32> \n<33> if (avctx->bits_per_coded_sample > 1 && avctx->bits_per_coded_sample <= 8) {\n<34> \n<35> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<36> \n<37> \n<38> \n<39> if (pal) {\n<40> \n<41> s->frame->palette_has_changed = 1;\n<42> \n<43> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<44> \n<45> }\n<46> \n<47> /* make the palette available */\n<48> \n<49> memcpy(s->frame->data[1], s->pal, AVPALETTE_SIZE);\n<50> \n<51> }\n<52> \n<53> \n<54> \n<55> /* FIXME how to correctly detect RLE ??? */\n<56> \n<57> if (avctx->height * istride == avpkt->size) { /* assume uncompressed */\n<58> \n<59> int linesize = (avctx->width * avctx->bits_per_coded_sample + 7) / 8;\n<60> \n<61> uint8_t *ptr = s->frame->data[0];\n<62> \n<63> uint8_t *buf = avpkt->data + (avctx->height-1)*istride;\n<64> \n<65> int i, j;\n<66> \n<67> \n<68> \n<69> for (i = 0; i < avctx->height; i++) {\n<70> \n<71> if (avctx->bits_per_coded_sample == 4) {\n<72> \n<73> for (j = 0; j < avctx->width - 1; j += 2) {\n<74> \n<75> ptr[j+0] = buf[j>>1] >> 4;\n<76> \n<77> ptr[j+1] = buf[j>>1] & 0xF;\n<78> \n<79> }\n<80> \n<81> if (avctx->width & 1)\n<82> \n<83> ptr[j+0] = buf[j>>1] >> 4;\n<84> \n<85> } else {\n<86> \n<87> memcpy(ptr, buf, linesize);\n<88> \n<89> }\n<90> \n<91> buf -= istride;\n<92> \n<93> ptr += s->frame->linesize[0];\n<94> \n<95> }\n<96> \n<97> } else {\n<98> \n<99> bytestream2_init(&s->gb, buf, buf_size);\n<100> \n<101> ff_msrle_decode(avctx, (AVPicture*)s->frame, avctx->bits_per_coded_sample, &s->gb);\n<102> \n<103> }\n<104> \n<105> \n<106> \n<107> if ((ret = av_frame_ref(data, s->frame)) < 0)\n<108> \n<109> return ret;\n<110> \n<111> \n<112> \n<113> *got_frame      = 1;\n<114> \n<115> \n<116> \n<117> /* report that the buffer was completely consumed */\n<118> \n<119> return buf_size;\n<120> \n<121> }\n<122> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n<2> FlicDecodeContext * s = avctx -> priv_data ;\n<3> GetByteContext g2 ;\n<4> int stream_ptr_after_color_chunk ;\n<5> int pixel_ptr ;\n<6> int palette_ptr ;\n<7> unsigned char palette_idx1 ;\n<8> unsigned char palette_idx2 ;\n<9> unsigned int frame_size ;\n<10> int num_chunks ;\n<11> unsigned int chunk_size ;\n<12> int chunk_type ;\n<13> int i , j , ret ;\n<14> int color_packets ;\n<15> int color_changes ;\n<16> int color_shift ;\n<17> unsigned char r , g , b ;\n<18> int lines ;\n<19> int compressed_lines ;\n<20> int starting_line ;\n<21> signed short line_packets ;\n<22> int y_ptr ;\n<23> int byte_run ;\n<24> int pixel_skip ;\n<25> int pixel_countdown ;\n<26> unsigned char * pixels ;\n<27> unsigned int pixel_limit ;\n<28> bytestream2_init ( & g2 , buf , buf_size ) ;\n<29> s -> frame . reference = 1 ;\n<30> s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n<31> if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n<32> av_log ( avctx , AV_LOG_ERROR , "reget_buffer() failed\n" ) ;\n<33> return ret ;\n<34> }\n<35> pixels = s -> frame . data [ 0 ] ;\n<36> pixel_limit = s -> avctx -> height * s -> frame . linesize [ 0 ] ;\n<37> frame_size = bytestream2_get_le32 ( & g2 ) ;\n<38> bytestream2_skip ( & g2 , 2 ) ;\n<39> num_chunks = bytestream2_get_le16 ( & g2 ) ;\n<40> bytestream2_skip ( & g2 , 8 ) ;\n<41> frame_size -= 16 ;\n<42> while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n<43> chunk_size = bytestream2_get_le32 ( & g2 ) ;\n<44> chunk_type = bytestream2_get_le16 ( & g2 ) ;\n<45> switch ( chunk_type ) {\n<46> case FLI_256_COLOR : case FLI_COLOR : stream_ptr_after_color_chunk = bytestream2_tell ( & g2 ) + chunk_size - 6 ;\n<47> if ( ( chunk_type == FLI_256_COLOR ) && ( s -> fli_type != FLC_MAGIC_CARPET_SYNTHETIC_TYPE_CODE ) ) color_shift = 0 ;\n<48> else color_shift = 2 ;\n<49> color_packets = bytestream2_get_le16 ( & g2 ) ;\n<50> palette_ptr = 0 ;\n<51> for ( i = 0 ;\n<52> i < color_packets ;\n<53> i ++ ) {\n<54> palette_ptr += bytestream2_get_byte ( & g2 ) ;\n<55> color_changes = bytestream2_get_byte ( & g2 ) ;\n<56> if ( color_changes == 0 ) color_changes = 256 ;\n<57> for ( j = 0 ;\n<58> j < color_changes ;\n<59> j ++ ) {\n<60> unsigned int entry ;\n<61> if ( ( unsigned ) palette_ptr >= 256 ) palette_ptr = 0 ;\n<62> r = bytestream2_get_byte ( & g2 ) << color_shift ;\n<63> g = bytestream2_get_byte ( & g2 ) << color_shift ;\n<64> b = bytestream2_get_byte ( & g2 ) << color_shift ;\n<65> entry = ( r << 16 ) | ( g << 8 ) | b ;\n<66> if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ;\n<67> s -> palette [ palette_ptr ++ ] = entry ;\n<68> }\n<69> }\n<70> if ( stream_ptr_after_color_chunk - bytestream2_tell ( & g2 ) > 0 ) bytestream2_skip ( & g2 , stream_ptr_after_color_chunk - bytestream2_tell ( & g2 ) ) ;\n<71> break ;\n<72> case FLI_DELTA : y_ptr = 0 ;\n<73> compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n<74> while ( compressed_lines > 0 ) {\n<75> line_packets = bytestream2_get_le16 ( & g2 ) ;\n<76> if ( ( line_packets & 0xC000 ) == 0xC000 ) {\n<77> line_packets = - line_packets ;\n<78> y_ptr += line_packets * s -> frame . linesize [ 0 ] ;\n<79> }\n<80> else if ( ( line_packets & 0xC000 ) == 0x4000 ) {\n<81> av_log ( avctx , AV_LOG_ERROR , "Undefined opcode (%x) in DELTA_FLI\n" , line_packets ) ;\n<82> }\n<83> else if ( ( line_packets & 0xC000 ) == 0x8000 ) {\n<84> pixel_ptr = y_ptr + s -> frame . linesize [ 0 ] - 1 ;\n<85> CHECK_PIXEL_PTR ( 0 ) ;\n<86> pixels [ pixel_ptr ] = line_packets & 0xff ;\n<87> }\n<88> else {\n<89> compressed_lines -- ;\n<90> pixel_ptr = y_ptr ;\n<91> CHECK_PIXEL_PTR ( 0 ) ;\n<92> pixel_countdown = s -> avctx -> width ;\n<93> for ( i = 0 ;\n<94> i < line_packets ;\n<95> i ++ ) {\n<96> pixel_skip = bytestream2_get_byte ( & g2 ) ;\n<97> pixel_ptr += pixel_skip ;\n<98> pixel_countdown -= pixel_skip ;\n<99> byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n<100> if ( byte_run < 0 ) {\n<101> byte_run = - byte_run ;\n<102> palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n<103> palette_idx2 = bytestream2_get_byte ( & g2 ) ;\n<104> CHECK_PIXEL_PTR ( byte_run * 2 ) ;\n<105> for ( j = 0 ;\n<106> j < byte_run ;\n<107> j ++ , pixel_countdown -= 2 ) {\n<108> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<109> pixels [ pixel_ptr ++ ] = palette_idx2 ;\n<110> }\n<111> }\n<112> else {\n<113> CHECK_PIXEL_PTR ( byte_run * 2 ) ;\n<114> for ( j = 0 ;\n<115> j < byte_run * 2 ;\n<116> j ++ , pixel_countdown -- ) {\n<117> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<118> }\n<119> }\n<120> }\n<121> y_ptr += s -> frame . linesize [ 0 ] ;\n<122> }\n<123> }\n<124> break ;\n<125> case FLI_LC : starting_line = bytestream2_get_le16 ( & g2 ) ;\n<126> y_ptr = 0 ;\n<127> y_ptr += starting_line * s -> frame . linesize [ 0 ] ;\n<128> compressed_lines = bytestream2_get_le16 ( & g2 ) ;\n<129> while ( compressed_lines > 0 ) {\n<130> pixel_ptr = y_ptr ;\n<131> CHECK_PIXEL_PTR ( 0 ) ;\n<132> pixel_countdown = s -> avctx -> width ;\n<133> line_packets = bytestream2_get_byte ( & g2 ) ;\n<134> if ( line_packets > 0 ) {\n<135> for ( i = 0 ;\n<136> i < line_packets ;\n<137> i ++ ) {\n<138> pixel_skip = bytestream2_get_byte ( & g2 ) ;\n<139> pixel_ptr += pixel_skip ;\n<140> pixel_countdown -= pixel_skip ;\n<141> byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n<142> if ( byte_run > 0 ) {\n<143> CHECK_PIXEL_PTR ( byte_run ) ;\n<144> for ( j = 0 ;\n<145> j < byte_run ;\n<146> j ++ , pixel_countdown -- ) {\n<147> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<148> }\n<149> }\n<150> else if ( byte_run < 0 ) {\n<151> byte_run = - byte_run ;\n<152> palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n<153> CHECK_PIXEL_PTR ( byte_run ) ;\n<154> for ( j = 0 ;\n<155> j < byte_run ;\n<156> j ++ , pixel_countdown -- ) {\n<157> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<158> }\n<159> }\n<160> }\n<161> }\n<162> y_ptr += s -> frame . linesize [ 0 ] ;\n<163> compressed_lines -- ;\n<164> }\n<165> break ;\n<166> case FLI_BLACK : memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n<167> break ;\n<168> case FLI_BRUN : y_ptr = 0 ;\n<169> for ( lines = 0 ;\n<170> lines < s -> avctx -> height ;\n<171> lines ++ ) {\n<172> pixel_ptr = y_ptr ;\n<173> bytestream2_skip ( & g2 , 1 ) ;\n<174> pixel_countdown = s -> avctx -> width ;\n<175> while ( pixel_countdown > 0 ) {\n<176> byte_run = sign_extend ( bytestream2_get_byte ( & g2 ) , 8 ) ;\n<177> if ( ! byte_run ) {\n<178> av_log ( avctx , AV_LOG_ERROR , "Invalid byte run value.\n" ) ;\n<179> return AVERROR_INVALIDDATA ;\n<180> }\n<181> if ( byte_run > 0 ) {\n<182> palette_idx1 = bytestream2_get_byte ( & g2 ) ;\n<183> CHECK_PIXEL_PTR ( byte_run ) ;\n<184> for ( j = 0 ;\n<185> j < byte_run ;\n<186> j ++ ) {\n<187> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<188> pixel_countdown -- ;\n<189> if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ) ;\n<190> }\n<191> }\n<192> else {\n<193> byte_run = - byte_run ;\n<194> CHECK_PIXEL_PTR ( byte_run ) ;\n<195> for ( j = 0 ;\n<196> j < byte_run ;\n<197> j ++ ) {\n<198> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<199> pixel_countdown -- ;\n<200> if ( pixel_countdown < 0 ) av_log ( avctx , AV_LOG_ERROR , "pixel_countdown < 0 (%d) at line %d\n" , pixel_countdown , lines ) ;\n<201> }\n<202> }\n<203> }\n<204> y_ptr += s -> frame . linesize [ 0 ] ;\n<205> }\n<206> break ;\n<207> case FLI_COPY : if ( chunk_size - 6 > s -> avctx -> width * s -> avctx -> height ) {\n<208> av_log ( avctx , AV_LOG_ERROR , "In chunk FLI_COPY : source data (%d bytes) " \ "bigger than image, skipping chunk\n" , chunk_size - 6 ) ;\n<209> bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n<210> }\n<211> else {\n<212> for ( y_ptr = 0 ;\n<213> y_ptr < s -> frame . linesize [ 0 ] * s -> avctx -> height ;\n<214> y_ptr += s -> frame . linesize [ 0 ] ) {\n<215> bytestream2_get_buffer ( & g2 , & pixels [ y_ptr ] , s -> avctx -> width ) ;\n<216> }\n<217> }\n<218> break ;\n<219> case FLI_MINI : bytestream2_skip ( & g2 , chunk_size - 6 ) ;\n<220> break ;\n<221> default : av_log ( avctx , AV_LOG_ERROR , "Unrecognized chunk type: %d\n" , chunk_type ) ;\n<222> break ;\n<223> }\n<224> frame_size -= chunk_size ;\n<225> num_chunks -- ;\n<226> }\n<227> if ( ( bytestream2_get_bytes_left ( & g2 ) != 0 ) && ( bytestream2_get_bytes_left ( & g2 ) != 1 ) ) av_log ( avctx , AV_LOG_ERROR , "Processed FLI chunk where chunk size = %d " \ "and final chunk ptr = %d\n" , buf_size , buf_size - bytestream2_get_bytes_left ( & g2 ) ) ;\n<228> memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n<229> if ( s -> new_palette ) {\n<230> s -> frame . palette_has_changed = 1 ;\n<231> s -> new_palette = 0 ;\n<232> }\n<233> * got_frame = 1 ;\n<234> * ( AVFrame * ) data = s -> frame ;\n<235> return buf_size ;\n<236> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int flac_probe(AVProbeData *p)\n<2> \n<3> {\n<4> \n<5> uint8_t *bufptr = p->buf;\n<6> \n<7> \n<8> \n<9> if(ff_id3v2_match(bufptr))\n<10> \n<11> bufptr += ff_id3v2_tag_len(bufptr);\n<12> \n<13> \n<14> \n<15> if(memcmp(bufptr, "fLaC", 4)) return 0;\n<16> \n<17> else                          return AVPROBE_SCORE_MAX / 2;\n<18> \n<19> }\n<20> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> TSReturnCode TSHttpTxnConfigFind ( const char * name , int length , TSOverridableConfigKey * conf , TSRecordDataType * type ) {\n<2> sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) name ) == TS_SUCCESS ) ;\n<3> sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) conf ) == TS_SUCCESS ) ;\n<4> TSOverridableConfigKey cnf = TS_CONFIG_NULL ;\n<5> TSRecordDataType typ = TS_RECORDDATATYPE_INT ;\n<6> if ( length == - 1 ) {\n<7> length = strlen ( name ) ;\n<8> }\n<9> switch ( length ) {\n<10> case 24 : if ( ! strncmp ( name , "proxy.config.srv_enabled" , length ) ) {\n<11> cnf = TS_CONFIG_SRV_ENABLED ;\n<12> }\n<13> break ;\n<14> case 28 : if ( ! strncmp ( name , "proxy.config.http.cache.http" , length ) ) {\n<15> cnf = TS_CONFIG_HTTP_CACHE_HTTP ;\n<16> }\n<17> break ;\n<18> case 29 : if ( ! strncmp ( name , "proxy.config.ssl.hsts_max_age" , length ) ) {\n<19> cnf = TS_CONFIG_SSL_HSTS_MAX_AGE ;\n<20> }\n<21> break ;\n<22> case 31 : if ( ! strncmp ( name , "proxy.config.http.chunking.size" , length ) ) {\n<23> cnf = TS_CONFIG_HTTP_CHUNKING_SIZE ;\n<24> }\n<25> break ;\n<26> case 33 : if ( ! strncmp ( name , "proxy.config.http.cache.fuzz.time" , length ) ) {\n<27> cnf = TS_CONFIG_HTTP_CACHE_FUZZ_TIME ;\n<28> }\n<29> else if ( ! strncmp ( name , "proxy.config.ssl.client.cert.path" , length ) ) {\n<30> cnf = TS_CONFIG_SSL_CERT_FILEPATH ;\n<31> typ = TS_RECORDDATATYPE_STRING ;\n<32> }\n<33> break ;\n<34> case 34 : if ( ! strncmp ( name , "proxy.config.http.chunking_enabled" , length ) ) {\n<35> cnf = TS_CONFIG_HTTP_CHUNKING_ENABLED ;\n<36> }\n<37> else if ( ! strncmp ( name , "proxy.config.http.cache.generation" , length ) ) {\n<38> cnf = TS_CONFIG_HTTP_CACHE_GENERATION ;\n<39> }\n<40> else if ( ! strncmp ( name , "proxy.config.http.insert_client_ip" , length ) ) {\n<41> cnf = TS_CONFIG_HTTP_ANONYMIZE_INSERT_CLIENT_IP ;\n<42> }\n<43> break ;\n<44> case 35 : switch ( name [ length - 1 ] ) {\n<45> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.range.write" , length ) ) {\n<46> cnf = TS_CONFIG_HTTP_CACHE_RANGE_WRITE ;\n<47> }\n<48> break ;\n<49> case 'p' : if ( ! strncmp ( name , "proxy.config.http.normalize_ae_gzip" , length ) ) {\n<50> cnf = TS_CONFIG_HTTP_NORMALIZE_AE_GZIP ;\n<51> }\n<52> break ;\n<53> }\n<54> break ;\n<55> case 36 : switch ( name [ length - 1 ] ) {\n<56> case 'p' : if ( ! strncmp ( name , "proxy.config.http.cache.range.lookup" , length ) ) {\n<57> cnf = TS_CONFIG_HTTP_CACHE_RANGE_LOOKUP ;\n<58> }\n<59> break ;\n<60> case 't' : if ( ! strncmp ( name , "proxy.config.net.sock_packet_tos_out" , length ) ) {\n<61> cnf = TS_CONFIG_NET_SOCK_PACKET_TOS_OUT ;\n<62> }\n<63> break ;\n<64> case 'd' : if ( ! strncmp ( name , "proxy.config.http.slow.log.threshold" , length ) ) {\n<65> cnf = TS_CONFIG_HTTP_SLOW_LOG_THRESHOLD ;\n<66> }\n<67> break ;\n<68> }\n<69> break ;\n<70> case 37 : switch ( name [ length - 1 ] ) {\n<71> case 'd' : if ( ! strncmp ( name , "proxy.config.http.redirection_enabled" , length ) ) {\n<72> cnf = TS_CONFIG_HTTP_ENABLE_REDIRECTION ;\n<73> }\n<74> break ;\n<75> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.max_stale_age" , length ) ) {\n<76> cnf = TS_CONFIG_HTTP_CACHE_MAX_STALE_AGE ;\n<77> }\n<78> else if ( ! strncmp ( name , "proxy.config.http.cache.fuzz.min_time" , length ) ) {\n<79> cnf = TS_CONFIG_HTTP_CACHE_FUZZ_MIN_TIME ;\n<80> }\n<81> else if ( ! strncmp ( name , "proxy.config.http.default_buffer_size" , length ) ) {\n<82> cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_SIZE ;\n<83> }\n<84> else if ( ! strncmp ( name , "proxy.config.ssl.client.cert.filename" , length ) ) {\n<85> cnf = TS_CONFIG_SSL_CERT_FILENAME ;\n<86> typ = TS_RECORDDATATYPE_STRING ;\n<87> }\n<88> break ;\n<89> case 'r' : if ( ! strncmp ( name , "proxy.config.http.response_server_str" , length ) ) {\n<90> cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_STR ;\n<91> typ = TS_RECORDDATATYPE_STRING ;\n<92> }\n<93> else if ( ! strncmp ( name , "proxy.config.ssl.client.verify.server" , length ) ) {\n<94> cnf = TS_CONFIG_SSL_CLIENT_VERIFY_SERVER ;\n<95> }\n<96> break ;\n<97> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_post_out" , length ) ) {\n<98> cnf = TS_CONFIG_HTTP_KEEP_ALIVE_POST_OUT ;\n<99> }\n<100> else if ( ! strncmp ( name , "proxy.config.net.sock_option_flag_out" , length ) ) {\n<101> cnf = TS_CONFIG_NET_SOCK_OPTION_FLAG_OUT ;\n<102> }\n<103> else if ( ! strncmp ( name , "proxy.config.net.sock_packet_mark_out" , length ) ) {\n<104> cnf = TS_CONFIG_NET_SOCK_PACKET_MARK_OUT ;\n<105> }\n<106> else if ( ! strncmp ( name , "proxy.config.websocket.active_timeout" , length ) ) {\n<107> cnf = TS_CONFIG_WEBSOCKET_ACTIVE_TIMEOUT ;\n<108> }\n<109> break ;\n<110> }\n<111> break ;\n<112> case 38 : switch ( name [ length - 1 ] ) {\n<113> case 'd' : if ( ! strncmp ( name , "proxy.config.http.server_tcp_init_cwnd" , length ) ) {\n<114> cnf = TS_CONFIG_HTTP_SERVER_TCP_INIT_CWND ;\n<115> }\n<116> else if ( ! strncmp ( name , "proxy.config.http.flow_control.enabled" , length ) ) {\n<117> cnf = TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED ;\n<118> }\n<119> break ;\n<120> break ;\n<121> case 's' : if ( ! strncmp ( name , "proxy.config.http.send_http11_requests" , length ) ) {\n<122> cnf = TS_CONFIG_HTTP_SEND_HTTP11_REQUESTS ;\n<123> }\n<124> break ;\n<125> }\n<126> break ;\n<127> case 39 : switch ( name [ length - 1 ] ) {\n<128> case 'e' : if ( ! strncmp ( name , "proxy.config.body_factory.template_base" , length ) ) {\n<129> cnf = TS_CONFIG_BODY_FACTORY_TEMPLATE_BASE ;\n<130> typ = TS_RECORDDATATYPE_STRING ;\n<131> }\n<132> break ;\n<133> case 'm' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_from" , length ) ) {\n<134> cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_FROM ;\n<135> }\n<136> break ;\n<137> case 'n' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_enabled_in" , length ) ) {\n<138> cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_IN ;\n<139> }\n<140> break ;\n<141> case 's' : if ( ! strncmp ( name , "proxy.config.http.doc_in_cache_skip_dns" , length ) ) {\n<142> cnf = TS_CONFIG_HTTP_DOC_IN_CACHE_SKIP_DNS ;\n<143> }\n<144> break ;\n<145> }\n<146> break ;\n<147> case 40 : switch ( name [ length - 1 ] ) {\n<148> case 'd' : if ( ! strncmp ( name , "proxy.config.http.forward_connect_method" , length ) ) {\n<149> cnf = TS_CONFIG_HTTP_FORWARD_CONNECT_METHOD ;\n<150> }\n<151> break ;\n<152> case 'e' : if ( ! strncmp ( name , "proxy.config.http.down_server.cache_time" , length ) ) {\n<153> cnf = TS_CONFIG_HTTP_DOWN_SERVER_CACHE_TIME ;\n<154> }\n<155> else if ( ! strncmp ( name , "proxy.config.http.insert_age_in_response" , length ) ) {\n<156> cnf = TS_CONFIG_HTTP_INSERT_AGE_IN_RESPONSE ;\n<157> }\n<158> break ;\n<159> case 'r' : if ( ! strncmp ( name , "proxy.config.url_remap.pristine_host_hdr" , length ) ) {\n<160> cnf = TS_CONFIG_URL_REMAP_PRISTINE_HOST_HDR ;\n<161> }\n<162> else if ( ! strncmp ( name , "proxy.config.http.insert_request_via_str" , length ) ) {\n<163> cnf = TS_CONFIG_HTTP_INSERT_REQUEST_VIA_STR ;\n<164> }\n<165> else if ( ! strncmp ( name , "proxy.config.http.flow_control.low_water" , length ) ) {\n<166> cnf = TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER_MARK ;\n<167> }\n<168> break ;\n<169> case 's' : if ( ! strncmp ( name , "proxy.config.http.origin_max_connections" , length ) ) {\n<170> cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS ;\n<171> }\n<172> else if ( ! strncmp ( name , "proxy.config.http.cache.required_headers" , length ) ) {\n<173> cnf = TS_CONFIG_HTTP_CACHE_REQUIRED_HEADERS ;\n<174> }\n<175> else if ( ! strncmp ( name , "proxy.config.ssl.hsts_include_subdomains" , length ) ) {\n<176> cnf = TS_CONFIG_SSL_HSTS_INCLUDE_SUBDOMAINS ;\n<177> }\n<178> else if ( ! strncmp ( name , "proxy.config.http.number_of_redirections" , length ) ) {\n<179> cnf = TS_CONFIG_HTTP_NUMBER_OF_REDIRECTIONS ;\n<180> }\n<181> break ;\n<182> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_enabled_out" , length ) ) {\n<183> cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_OUT ;\n<184> }\n<185> break ;\n<186> case 'y' : if ( ! strncmp ( name , "proxy.config.http.cache.fuzz.probability" , length ) ) {\n<187> typ = TS_RECORDDATATYPE_FLOAT ;\n<188> cnf = TS_CONFIG_HTTP_CACHE_FUZZ_PROBABILITY ;\n<189> }\n<190> break ;\n<191> }\n<192> break ;\n<193> case 41 : switch ( name [ length - 1 ] ) {\n<194> case 'd' : if ( ! strncmp ( name , "proxy.config.http.response_server_enabled" , length ) ) {\n<195> cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_ENABLED ;\n<196> }\n<197> break ;\n<198> case 'e' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_cookie" , length ) ) {\n<199> cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_COOKIE ;\n<200> }\n<201> else if ( ! strncmp ( name , "proxy.config.http.request_header_max_size" , length ) ) {\n<202> cnf = TS_CONFIG_HTTP_REQUEST_HEADER_MAX_SIZE ;\n<203> }\n<204> else if ( ! strncmp ( name , "proxy.config.http.safe_requests_retryable" , length ) ) {\n<205> cnf = TS_CONFIG_HTTP_SAFE_REQUESTS_RETRYABLE ;\n<206> }\n<207> else if ( ! strncmp ( name , "proxy.config.http.parent_proxy.retry_time" , length ) ) {\n<208> cnf = TS_CONFIG_HTTP_PARENT_PROXY_RETRY_TIME ;\n<209> }\n<210> break ;\n<211> case 'r' : if ( ! strncmp ( name , "proxy.config.http.insert_response_via_str" , length ) ) {\n<212> cnf = TS_CONFIG_HTTP_INSERT_RESPONSE_VIA_STR ;\n<213> }\n<214> else if ( ! strncmp ( name , "proxy.config.http.flow_control.high_water" , length ) ) {\n<215> cnf = TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER_MARK ;\n<216> }\n<217> break ;\n<218> }\n<219> break ;\n<220> case 42 : switch ( name [ length - 1 ] ) {\n<221> case 'd' : if ( ! strncmp ( name , "proxy.config.http.negative_caching_enabled" , length ) ) {\n<222> cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_ENABLED ;\n<223> }\n<224> break ;\n<225> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.when_to_revalidate" , length ) ) {\n<226> cnf = TS_CONFIG_HTTP_CACHE_WHEN_TO_REVALIDATE ;\n<227> }\n<228> else if ( ! strncmp ( name , "proxy.config.http.response_header_max_size" , length ) ) {\n<229> cnf = TS_CONFIG_HTTP_RESPONSE_HEADER_MAX_SIZE ;\n<230> }\n<231> break ;\n<232> case 'r' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_referer" , length ) ) {\n<233> cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_REFERER ;\n<234> }\n<235> else if ( ! strncmp ( name , "proxy.config.http.global_user_agent_header" , length ) ) {\n<236> cnf = TS_CONFIG_HTTP_GLOBAL_USER_AGENT_HEADER ;\n<237> typ = TS_RECORDDATATYPE_STRING ;\n<238> }\n<239> break ;\n<240> case 't' : if ( ! strncmp ( name , "proxy.config.net.sock_recv_buffer_size_out" , length ) ) {\n<241> cnf = TS_CONFIG_NET_SOCK_RECV_BUFFER_SIZE_OUT ;\n<242> }\n<243> else if ( ! strncmp ( name , "proxy.config.net.sock_send_buffer_size_out" , length ) ) {\n<244> cnf = TS_CONFIG_NET_SOCK_SEND_BUFFER_SIZE_OUT ;\n<245> }\n<246> else if ( ! strncmp ( name , "proxy.config.http.connect_attempts_timeout" , length ) ) {\n<247> cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_TIMEOUT ;\n<248> }\n<249> else if ( ! strncmp ( name , "proxy.config.websocket.no_activity_timeout" , length ) ) {\n<250> cnf = TS_CONFIG_WEBSOCKET_NO_ACTIVITY_TIMEOUT ;\n<251> }\n<252> break ;\n<253> }\n<254> break ;\n<255> case 43 : switch ( name [ length - 1 ] ) {\n<256> case 'e' : if ( ! strncmp ( name , "proxy.config.http.negative_caching_lifetime" , length ) ) {\n<257> cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_LIFETIME ;\n<258> }\n<259> break ;\n<260> case 'k' : if ( ! strncmp ( name , "proxy.config.http.default_buffer_water_mark" , length ) ) {\n<261> cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_WATER_MARK ;\n<262> }\n<263> break ;\n<264> case 'l' : if ( ! strncmp ( name , "proxy.config.http.cache.cluster_cache_local" , length ) ) {\n<265> cnf = TS_CONFIG_HTTP_CACHE_CLUSTER_CACHE_LOCAL ;\n<266> }\n<267> break ;\n<268> case 'r' : if ( ! strncmp ( name , "proxy.config.http.cache.heuristic_lm_factor" , length ) ) {\n<269> typ = TS_RECORDDATATYPE_FLOAT ;\n<270> cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_LM_FACTOR ;\n<271> }\n<272> break ;\n<273> }\n<274> break ;\n<275> case 44 : switch ( name [ length - 1 ] ) {\n<276> case 'p' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_client_ip" , length ) ) {\n<277> cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_CLIENT_IP ;\n<278> }\n<279> break ;\n<280> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.open_read_retry_time" , length ) ) {\n<281> cnf = TS_CONFIG_HTTP_CACHE_OPEN_READ_RETRY_TIME ;\n<282> }\n<283> break ;\n<284> }\n<285> break ;\n<286> case 45 : switch ( name [ length - 1 ] ) {\n<287> case 'd' : if ( ! strncmp ( name , "proxy.config.http.down_server.abort_threshold" , length ) ) {\n<288> cnf = TS_CONFIG_HTTP_DOWN_SERVER_ABORT_THRESHOLD ;\n<289> }\n<290> else if ( ! strncmp ( name , "proxy.config.http.parent_proxy.fail_threshold" , length ) ) {\n<291> cnf = TS_CONFIG_HTTP_PARENT_PROXY_FAIL_THRESHOLD ;\n<292> }\n<293> break ;\n<294> case 'n' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_authentication" , length ) ) {\n<295> cnf = TS_CONFIG_HTTP_CACHE_IGNORE_AUTHENTICATION ;\n<296> }\n<297> break ;\n<298> case 't' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_user_agent" , length ) ) {\n<299> cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_USER_AGENT ;\n<300> }\n<301> break ;\n<302> case 's' : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_rr_retries" , length ) ) {\n<303> cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_RR_RETRIES ;\n<304> }\n<305> else if ( ! strncmp ( name , "proxy.config.http.cache.max_open_read_retries" , length ) ) {\n<306> cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_READ_RETRIES ;\n<307> }\n<308> break ;\n<309> case 'e' : if ( 0 == strncmp ( name , "proxy.config.http.auth_server_session_private" , length ) ) {\n<310> cnf = TS_CONFIG_HTTP_AUTH_SERVER_SESSION_PRIVATE ;\n<311> }\n<312> break ;\n<313> case 'y' : if ( ! strncmp ( name , "proxy.config.http.redirect_use_orig_cache_key" , length ) ) {\n<314> cnf = TS_CONFIG_HTTP_REDIRECT_USE_ORIG_CACHE_KEY ;\n<315> }\n<316> break ;\n<317> }\n<318> break ;\n<319> case 46 : switch ( name [ length - 1 ] ) {\n<320> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_client_no_cache" , length ) ) {\n<321> cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_NO_CACHE ;\n<322> }\n<323> else if ( ! strncmp ( name , "proxy.config.http.cache.ims_on_client_no_cache" , length ) ) {\n<324> cnf = TS_CONFIG_HTTP_CACHE_IMS_ON_CLIENT_NO_CACHE ;\n<325> }\n<326> else if ( ! strncmp ( name , "proxy.config.http.cache.ignore_server_no_cache" , length ) ) {\n<327> cnf = TS_CONFIG_HTTP_CACHE_IGNORE_SERVER_NO_CACHE ;\n<328> }\n<329> else if ( ! strncmp ( name , "proxy.config.http.cache.heuristic_min_lifetime" , length ) ) {\n<330> cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MIN_LIFETIME ;\n<331> }\n<332> else if ( ! strncmp ( name , "proxy.config.http.cache.heuristic_max_lifetime" , length ) ) {\n<333> cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MAX_LIFETIME ;\n<334> }\n<335> else if ( ! strncmp ( name , "proxy.config.http.origin_max_connections_queue" , length ) ) {\n<336> cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS_QUEUE ;\n<337> }\n<338> break ;\n<339> case 'r' : if ( ! strncmp ( name , "proxy.config.http.insert_squid_x_forwarded_for" , length ) ) {\n<340> cnf = TS_CONFIG_HTTP_INSERT_SQUID_X_FORWARDED_FOR ;\n<341> }\n<342> break ;\n<343> case 's' : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_max_retries" , length ) ) {\n<344> cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES ;\n<345> }\n<346> else if ( ! strncmp ( name , "proxy.config.http.cache.max_open_write_retries" , length ) ) {\n<347> cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_WRITE_RETRIES ;\n<348> }\n<349> break ;\n<350> case 't' : if ( ! strncmp ( name , "proxy.config.http.forward.proxy_auth_to_parent" , length ) ) {\n<351> cnf = TS_CONFIG_HTTP_FORWARD_PROXY_AUTH_TO_PARENT ;\n<352> }\n<353> break ;\n<354> case 'h' : if ( 0 == strncmp ( name , "proxy.config.http.server_session_sharing.match" , length ) ) {\n<355> cnf = TS_CONFIG_HTTP_SERVER_SESSION_SHARING_MATCH ;\n<356> }\n<357> break ;\n<358> case 'n' : if ( ! strncmp ( name , "proxy.config.http.cache.open_write_fail_action" , length ) ) {\n<359> cnf = TS_CONFIG_HTTP_CACHE_OPEN_WRITE_FAIL_ACTION ;\n<360> }\n<361> break ;\n<362> }\n<363> break ;\n<364> case 47 : switch ( name [ length - 1 ] ) {\n<365> case 'b' : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.mark_down_hostdb" , length ) ) {\n<366> cnf = TS_CONFIG_PARENT_FAILURES_UPDATE_HOSTDB ;\n<367> }\n<368> break ;\n<369> case 'd' : if ( ! strncmp ( name , "proxy.config.http.negative_revalidating_enabled" , length ) ) {\n<370> cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_ENABLED ;\n<371> }\n<372> break ;\n<373> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.guaranteed_min_lifetime" , length ) ) {\n<374> cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MIN_LIFETIME ;\n<375> }\n<376> else if ( ! strncmp ( name , "proxy.config.http.cache.guaranteed_max_lifetime" , length ) ) {\n<377> cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MAX_LIFETIME ;\n<378> }\n<379> break ;\n<380> case 'n' : if ( ! strncmp ( name , "proxy.config.http.transaction_active_timeout_in" , length ) ) {\n<381> cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN ;\n<382> }\n<383> break ;\n<384> case 't' : if ( ! strncmp ( name , "proxy.config.http.post_connect_attempts_timeout" , length ) ) {\n<385> cnf = TS_CONFIG_HTTP_POST_CONNECT_ATTEMPTS_TIMEOUT ;\n<386> }\n<387> break ;\n<388> }\n<389> break ;\n<390> case 48 : switch ( name [ length - 1 ] ) {\n<391> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_client_cc_max_age" , length ) ) {\n<392> cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_CC_MAX_AGE ;\n<393> }\n<394> else if ( ! strncmp ( name , "proxy.config.http.negative_revalidating_lifetime" , length ) ) {\n<395> cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_LIFETIME ;\n<396> }\n<397> break ;\n<398> case 't' : switch ( name [ length - 4 ] ) {\n<399> case '_' : if ( ! strncmp ( name , "proxy.config.http.transaction_active_timeout_out" , length ) ) {\n<400> cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_OUT ;\n<401> }\n<402> break ;\n<403> case 'e' : if ( ! strncmp ( name , "proxy.config.http.background_fill_active_timeout" , length ) ) {\n<404> cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_ACTIVE_TIMEOUT ;\n<405> }\n<406> break ;\n<407> }\n<408> break ;\n<409> }\n<410> break ;\n<411> case 49 : if ( ! strncmp ( name , "proxy.config.http.attach_server_session_to_client" , length ) ) {\n<412> cnf = TS_CONFIG_HTTP_ATTACH_SERVER_SESSION_TO_CLIENT ;\n<413> }\n<414> break ;\n<415> case 50 : if ( ! strncmp ( name , "proxy.config.http.cache.cache_responses_to_cookies" , length ) ) {\n<416> cnf = TS_CONFIG_HTTP_CACHE_CACHE_RESPONSES_TO_COOKIES ;\n<417> }\n<418> break ;\n<419> case 51 : switch ( name [ length - 1 ] ) {\n<420> case 'n' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_no_activity_timeout_in" , length ) ) {\n<421> cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_IN ;\n<422> }\n<423> break ;\n<424> case 'd' : if ( ! strncmp ( name , "proxy.config.http.post.check.content_length.enabled" , length ) ) {\n<425> cnf = TS_CONFIG_HTTP_POST_CHECK_CONTENT_LENGTH_ENABLED ;\n<426> }\n<427> break ;\n<428> }\n<429> break ;\n<430> case 52 : switch ( name [ length - 1 ] ) {\n<431> case 'c' : if ( ! strncmp ( name , "proxy.config.http.cache.cache_urls_that_look_dynamic" , length ) ) {\n<432> cnf = TS_CONFIG_HTTP_CACHE_CACHE_URLS_THAT_LOOK_DYNAMIC ;\n<433> }\n<434> break ;\n<435> case 'n' : if ( ! strncmp ( name , "proxy.config.http.transaction_no_activity_timeout_in" , length ) ) {\n<436> cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_IN ;\n<437> }\n<438> break ;\n<439> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_no_activity_timeout_out" , length ) ) {\n<440> cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_OUT ;\n<441> }\n<442> else if ( ! strncmp ( name , "proxy.config.http.uncacheable_requests_bypass_parent" , length ) ) {\n<443> cnf = TS_CONFIG_HTTP_UNCACHEABLE_REQUESTS_BYPASS_PARENT ;\n<444> }\n<445> break ;\n<446> }\n<447> break ;\n<448> case 53 : switch ( name [ length - 1 ] ) {\n<449> case 't' : if ( ! strncmp ( name , "proxy.config.http.transaction_no_activity_timeout_out" , length ) ) {\n<450> cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_OUT ;\n<451> }\n<452> break ;\n<453> case 'd' : if ( ! strncmp ( name , "proxy.config.http.background_fill_completed_threshold" , length ) ) {\n<454> typ = TS_RECORDDATATYPE_FLOAT ;\n<455> cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_COMPLETED_THRESHOLD ;\n<456> }\n<457> break ;\n<458> case 's' : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.total_connect_attempts" , length ) ) {\n<459> cnf = TS_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS ;\n<460> }\n<461> break ;\n<462> }\n<463> break ;\n<464> case 55 : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.connect_attempts_timeout" , length ) ) {\n<465> cnf = TS_CONFIG_HTTP_PARENT_CONNECT_ATTEMPT_TIMEOUT ;\n<466> }\n<467> break ;\n<468> case 58 : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_max_retries_dead_server" , length ) ) {\n<469> cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES_DEAD_SERVER ;\n<470> }\n<471> else if ( ! strncmp ( name , "proxy.config.http.parent_proxy.per_parent_connect_attempts" , length ) ) {\n<472> cnf = TS_CONFIG_HTTP_PER_PARENT_CONNECT_ATTEMPTS ;\n<473> }\n<474> break ;\n<475> }\n<476> * conf = cnf ;\n<477> if ( type ) {\n<478> * type = typ ;\n<479> }\n<480> return ( ( cnf != TS_CONFIG_NULL ) ? TS_SUCCESS : TS_ERROR ) ;\n<481> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n<2> \n<3> {\n<4> \n<5> int err, i, result = 0, pref_code_found = 0, wait_count = 100;\n<6> \n<7> char buf[CONTROL_BUFFER_SIZE];\n<8> \n<9> \n<10> \n<11> /* Set blocking mode */\n<12> \n<13> s->conn_control_block_flag = 0;\n<14> \n<15> for (;;) {\n<16> \n<17> if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {\n<18> \n<19> if (err == AVERROR_EXIT) {\n<20> \n<21> if (!pref_code_found && wait_count--) {\n<22> \n<23> av_usleep(10000);\n<24> \n<25> continue;\n<26> \n<27> }\n<28> \n<29> }\n<30> \n<31> return result;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> av_log(s, AV_LOG_DEBUG, "%s\n", buf);\n<38> \n<39> \n<40> \n<41> if (!pref_code_found) {\n<42> \n<43> if (strlen(buf) < 3)\n<44> \n<45> continue;\n<46> \n<47> \n<48> \n<49> err = 0;\n<50> \n<51> for (i = 0; i < 3; ++i) {\n<52> \n<53> if (buf[i] < '0' || buf[i] > '9')\n<54> \n<55> continue;\n<56> \n<57> err *= 10;\n<58> \n<59> err += buf[i] - '0';\n<60> \n<61> }\n<62> \n<63> \n<64> \n<65> for (i = 0; response_codes[i]; ++i) {\n<66> \n<67> if (err == response_codes[i]) {\n<68> \n<69> /* first code received. Now get all lines in non blocking mode */\n<70> \n<71> s->conn_control_block_flag = 1;\n<72> \n<73> pref_code_found = 1;\n<74> \n<75> result = err;\n<76> \n<77> if (line)\n<78> \n<79> *line = av_strdup(buf);\n<80> \n<81> break;\n<82> \n<83> }\n<84> \n<85> }\n<86> \n<87> }\n<88> \n<89> }\n<90> \n<91> return result;\n<92> \n<93> }\n<94> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int decode_i_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n<2> int x , y , ret ;\n<3> const int width = f -> avctx -> width ;\n<4> const int height = f -> avctx -> height ;\n<5> const unsigned int bitstream_size = AV_RL32 ( buf ) ;\n<6> int token_count av_unused ;\n<7> unsigned int prestream_size ;\n<8> const uint8_t * prestream ;\n<9> if ( length < bitstream_size + 12 ) {\n<10> av_log ( f -> avctx , AV_LOG_ERROR , "packet size too small\n" ) ;\n<11> return AVERROR_INVALIDDATA ;\n<12> }\n<13> token_count = AV_RL32 ( buf + bitstream_size + 8 ) ;\n<14> prestream_size = 4 * AV_RL32 ( buf + bitstream_size + 4 ) ;\n<15> prestream = buf + bitstream_size + 12 ;\n<16> if ( prestream_size + bitstream_size + 12 != length || bitstream_size > ( 1 << 26 ) || prestream_size > ( 1 << 26 ) ) {\n<17> av_log ( f -> avctx , AV_LOG_ERROR , "size mismatch %d %d %d\n" , prestream_size , bitstream_size , length ) ;\n<18> return AVERROR_INVALIDDATA ;\n<19> }\n<20> prestream = read_huffman_tables ( f , prestream ) ;\n<21> if ( ! prestream ) {\n<22> av_log ( f -> avctx , AV_LOG_ERROR , "Error reading Huffman tables.\n" ) ;\n<23> return AVERROR_INVALIDDATA ;\n<24> }\n<25> init_get_bits ( & f -> gb , buf + 4 , 8 * bitstream_size ) ;\n<26> prestream_size = length + buf - prestream ;\n<27> av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , prestream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<28> if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n<29> f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) prestream , prestream_size / 4 ) ;\n<30> memset ( ( uint8_t * ) f -> bitstream_buffer + prestream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<31> init_get_bits ( & f -> pre_gb , f -> bitstream_buffer , 8 * prestream_size ) ;\n<32> f -> last_dc = 0 * 128 * 8 * 8 ;\n<33> for ( y = 0 ;\n<34> y < height ;\n<35> y += 16 ) {\n<36> for ( x = 0 ;\n<37> x < width ;\n<38> x += 16 ) {\n<39> if ( ( ret = decode_i_mb ( f ) ) < 0 ) return ret ;\n<40> idct_put ( f , x , y ) ;\n<41> }\n<42> }\n<43> if ( get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) != 256 ) av_log ( f -> avctx , AV_LOG_ERROR , "end mismatch\n" ) ;\n<44> return 0 ;\n<45> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void do_exec ( struct st_command * command ) {\n<2> int error ;\n<3> char buf [ 512 ] ;\n<4> FILE * res_file ;\n<5> char * cmd = command -> first_argument ;\n<6> DYNAMIC_STRING ds_cmd ;\n<7> DYNAMIC_STRING ds_sorted , * ds_result ;\n<8> DBUG_ENTER ( "do_exec" ) ;\n<9> DBUG_PRINT ( "enter" , ( "cmd: '%s'" , cmd ) ) ;\n<10> while ( * cmd && my_isspace ( charset_info , * cmd ) ) cmd ++ ;\n<11> if ( ! * cmd ) {\n<12> report_or_die ( "Missing argument in exec" ) ;\n<13> return ;\n<14> }\n<15> command -> last_argument = command -> end ;\n<16> init_dynamic_string ( & ds_cmd , 0 , command -> query_len + 256 , 256 ) ;\n<17> do_eval ( & ds_cmd , cmd , command -> end , ! is_windows ) ;\n<18> if ( builtin_echo [ 0 ] && strncmp ( cmd , "echo" , 4 ) == 0 ) {\n<19> replace ( & ds_cmd , "echo" , 4 , builtin_echo , strlen ( builtin_echo ) ) ;\n<20> }\n<21> # ifdef __WIN__ # ifndef USE_CYGWIN while ( replace ( & ds_cmd , "/devull" , 9 , "NUL" , 3 ) == 0 ) ;\n<22> while ( replace ( & ds_cmd , ">&-" , 3 , ">&4" , 3 ) == 0 ) ;\n<23> # endif # endif while ( replace ( & ds_cmd , "\n" , 1 , " " , 1 ) == 0 ) ;\n<24> DBUG_PRINT ( "info" , ( "Executing '%s' as '%s'" , command -> first_argument , ds_cmd . str ) ) ;\n<25> if ( ! ( res_file = my_popen ( & ds_cmd , "r" ) ) ) {\n<26> dynstr_free ( & ds_cmd ) ;\n<27> if ( command -> abort_on_error ) report_or_die ( "popen(\"%s\", \"r\") failed" , command -> first_argument ) ;\n<28> return ;\n<29> }\n<30> ds_result = & ds_res ;\n<31> if ( display_result_sorted ) {\n<32> init_dynamic_string ( & ds_sorted , "" , 1024 , 1024 ) ;\n<33> ds_result = & ds_sorted ;\n<34> }\n<35> while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n<36> if ( disable_result_log ) {\n<37> buf [ strlen ( buf ) - 1 ] = 0 ;\n<38> DBUG_PRINT ( "exec_result" , ( "%s" , buf ) ) ;\n<39> }\n<40> else {\n<41> replace_dynstr_append ( ds_result , buf ) ;\n<42> }\n<43> }\n<44> error = pclose ( res_file ) ;\n<45> if ( display_result_sorted ) {\n<46> dynstr_append_sorted ( & ds_res , & ds_sorted , 0 ) ;\n<47> dynstr_free ( & ds_sorted ) ;\n<48> }\n<49> if ( error > 0 ) {\n<50> uint status = WEXITSTATUS ( error ) ;\n<51> int i ;\n<52> if ( command -> abort_on_error ) {\n<53> report_or_die ( "exec of '%s' failed, error: %d, status: %d, errno: %d\n" "Output from before failure:\n%s\n" , ds_cmd . str , error , status , errno , ds_res . str ) ;\n<54> dynstr_free ( & ds_cmd ) ;\n<55> return ;\n<56> }\n<57> DBUG_PRINT ( "info" , ( "error: %d, status: %d" , error , status ) ) ;\n<58> i = match_expected_error ( command , status , NULL ) ;\n<59> if ( i >= 0 ) DBUG_PRINT ( "info" , ( "command \"%s\" failed with expected error: %d" , command -> first_argument , status ) ) ;\n<60> else {\n<61> dynstr_free ( & ds_cmd ) ;\n<62> if ( command -> expected_errors . count > 0 ) report_or_die ( "command \"%s\" failed with wrong error: %d" , command -> first_argument , status ) ;\n<63> }\n<64> }\n<65> else if ( command -> expected_errors . err [ 0 ] . type == ERR_ERRNO && command -> expected_errors . err [ 0 ] . code . errnum != 0 ) {\n<66> log_msg ( "exec of '%s failed, error: %d, errno: %d" , ds_cmd . str , error , errno ) ;\n<67> dynstr_free ( & ds_cmd ) ;\n<68> report_or_die ( "command \"%s\" succeeded - should have failed with " "errno %d..." , command -> first_argument , command -> expected_errors . err [ 0 ] . code . errnum ) ;\n<69> }\n<70> dynstr_free ( & ds_cmd ) ;\n<71> DBUG_VOID_RETURN ;\n<72> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mpeg4_decode_partitioned_mb(MpegEncContext *s, DCTELEM block[6][64])\n<2> \n<3> {\n<4> \n<5> int cbp, mb_type;\n<6> \n<7> const int xy= s->mb_x + s->mb_y*s->mb_width;\n<8> \n<9> \n<10> \n<11> mb_type= s->mb_type[xy];\n<12> \n<13> cbp = s->cbp_table[xy];\n<14> \n<15> \n<16> \n<17> if(s->current_picture.qscale_table[xy] != s->qscale){\n<18> \n<19> s->qscale= s->current_picture.qscale_table[xy];\n<20> \n<21> s->y_dc_scale= s->y_dc_scale_table[ s->qscale ];\n<22> \n<23> s->c_dc_scale= s->c_dc_scale_table[ s->qscale ];\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> if (s->pict_type == P_TYPE || s->pict_type==S_TYPE) {\n<30> \n<31> int i;\n<32> \n<33> for(i=0; i<4; i++){\n<34> \n<35> s->mv[0][i][0] = s->motion_val[ s->block_index[i] ][0];\n<36> \n<37> s->mv[0][i][1] = s->motion_val[ s->block_index[i] ][1];\n<38> \n<39> }\n<40> \n<41> s->mb_intra = mb_type&MB_TYPE_INTRA;\n<42> \n<43> \n<44> \n<45> if (mb_type&MB_TYPE_SKIPED) {\n<46> \n<47> /* skip mb */\n<48> \n<49> for(i=0;i<6;i++)\n<50> \n<51> s->block_last_index[i] = -1;\n<52> \n<53> s->mv_dir = MV_DIR_FORWARD;\n<54> \n<55> s->mv_type = MV_TYPE_16X16;\n<56> \n<57> if(s->pict_type==S_TYPE && s->vol_sprite_usage==GMC_SPRITE){\n<58> \n<59> s->mcsel=1;\n<60> \n<61> s->mb_skiped = 0;\n<62> \n<63> }else{\n<64> \n<65> s->mcsel=0;\n<66> \n<67> s->mb_skiped = 1;\n<68> \n<69> }\n<70> \n<71> }else if(s->mb_intra){\n<72> \n<73> s->ac_pred = s->pred_dir_table[xy]>>7;\n<74> \n<75> \n<76> \n<77> /* decode each block */\n<78> \n<79> for (i = 0; i < 6; i++) {\n<80> \n<81> if(mpeg4_decode_block(s, block[i], i, cbp&32, 1) < 0){\n<82> \n<83> fprintf(stderr, "texture corrupted at %d %d\n", s->mb_x, s->mb_y);\n<84> \n<85> return -1;\n<86> \n<87> }\n<88> \n<89> cbp+=cbp;\n<90> \n<91> }\n<92> \n<93> }else if(!s->mb_intra){\n<94> \n<95> //            s->mcsel= 0; //FIXME do we need to init that\n<96> \n<97> \n<98> \n<99> s->mv_dir = MV_DIR_FORWARD;\n<100> \n<101> if (mb_type&MB_TYPE_INTER4V) {\n<102> \n<103> s->mv_type = MV_TYPE_8X8;\n<104> \n<105> } else {\n<106> \n<107> s->mv_type = MV_TYPE_16X16;\n<108> \n<109> }\n<110> \n<111> /* decode each block */\n<112> \n<113> for (i = 0; i < 6; i++) {\n<114> \n<115> if(mpeg4_decode_block(s, block[i], i, cbp&32, 0) < 0){\n<116> \n<117> fprintf(stderr, "texture corrupted at %d %d (trying to continue with mc/dc only)\n", s->mb_x, s->mb_y);\n<118> \n<119> return -1;\n<120> \n<121> }\n<122> \n<123> cbp+=cbp;\n<124> \n<125> }\n<126> \n<127> }\n<128> \n<129> } else { /* I-Frame */\n<130> \n<131> int i;\n<132> \n<133> s->mb_intra = 1;\n<134> \n<135> s->ac_pred = s->pred_dir_table[xy]>>7;\n<136> \n<137> \n<138> \n<139> /* decode each block */\n<140> \n<141> for (i = 0; i < 6; i++) {\n<142> \n<143> if(mpeg4_decode_block(s, block[i], i, cbp&32, 1) < 0){\n<144> \n<145> fprintf(stderr, "texture corrupted at %d %d (trying to continue with dc only)\n", s->mb_x, s->mb_y);\n<146> \n<147> return -1;\n<148> \n<149> }\n<150> \n<151> cbp+=cbp;\n<152> \n<153> }\n<154> \n<155> }\n<156> \n<157> \n<158> \n<159> s->error_status_table[xy]&= ~AC_ERROR;\n<160> \n<161> \n<162> \n<163> /* per-MB end of slice check */\n<164> \n<165> \n<166> \n<167> if(--s->mb_num_left <= 0){\n<168> \n<169> //printf("%06X %d\n", show_bits(&s->gb, 24), s->gb.size*8 - get_bits_count(&s->gb));\n<170> \n<171> if(mpeg4_is_resync(s))\n<172> \n<173> return SLICE_END;\n<174> \n<175> else\n<176> \n<177> return SLICE_NOEND;\n<178> \n<179> }else{\n<180> \n<181> if(s->cbp_table[xy+1] && mpeg4_is_resync(s))\n<182> \n<183> return SLICE_END;\n<184> \n<185> else\n<186> \n<187> return SLICE_OK;\n<188> \n<189> }\n<190> \n<191> }\n<192> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int rm_read_audio_stream_info(AVFormatContext *s, ByteIOContext *pb,\n<2> \n<3> AVStream *st, int read_all)\n<4> \n<5> {\n<6> \n<7> RMDemuxContext *rm = s->priv_data;\n<8> \n<9> char buf[256];\n<10> \n<11> uint32_t version;\n<12> \n<13> int i;\n<14> \n<15> \n<16> \n<17> /* ra type header */\n<18> \n<19> version = get_be32(pb); /* version */\n<20> \n<21> if (((version >> 16) & 0xff) == 3) {\n<22> \n<23> int64_t startpos = url_ftell(pb);\n<24> \n<25> /* very old version */\n<26> \n<27> for(i = 0; i < 14; i++)\n<28> \n<29> get_byte(pb);\n<30> \n<31> get_str8(pb, s->title, sizeof(s->title));\n<32> \n<33> get_str8(pb, s->author, sizeof(s->author));\n<34> \n<35> get_str8(pb, s->copyright, sizeof(s->copyright));\n<36> \n<37> get_str8(pb, s->comment, sizeof(s->comment));\n<38> \n<39> if ((startpos + (version & 0xffff)) >= url_ftell(pb) + 2) {\n<40> \n<41> // fourcc (should always be "lpcJ")\n<42> \n<43> get_byte(pb);\n<44> \n<45> get_str8(pb, buf, sizeof(buf));\n<46> \n<47> }\n<48> \n<49> // Skip extra header crap (this should never happen)\n<50> \n<51> if ((startpos + (version & 0xffff)) > url_ftell(pb))\n<52> \n<53> url_fskip(pb, (version & 0xffff) + startpos - url_ftell(pb));\n<54> \n<55> st->codec->sample_rate = 8000;\n<56> \n<57> st->codec->channels = 1;\n<58> \n<59> st->codec->codec_type = CODEC_TYPE_AUDIO;\n<60> \n<61> st->codec->codec_id = CODEC_ID_RA_144;\n<62> \n<63> } else {\n<64> \n<65> int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n<66> \n<67> /* old version (4) */\n<68> \n<69> get_be32(pb); /* .ra4 */\n<70> \n<71> get_be32(pb); /* data size */\n<72> \n<73> get_be16(pb); /* version2 */\n<74> \n<75> get_be32(pb); /* header size */\n<76> \n<77> flavor= get_be16(pb); /* add codec info / flavor */\n<78> \n<79> rm->coded_framesize = coded_framesize = get_be32(pb); /* coded frame size */\n<80> \n<81> get_be32(pb); /* ??? */\n<82> \n<83> get_be32(pb); /* ??? */\n<84> \n<85> get_be32(pb); /* ??? */\n<86> \n<87> rm->sub_packet_h = sub_packet_h = get_be16(pb); /* 1 */\n<88> \n<89> st->codec->block_align= get_be16(pb); /* frame size */\n<90> \n<91> rm->sub_packet_size = sub_packet_size = get_be16(pb); /* sub packet size */\n<92> \n<93> get_be16(pb); /* ??? */\n<94> \n<95> if (((version >> 16) & 0xff) == 5) {\n<96> \n<97> get_be16(pb); get_be16(pb); get_be16(pb);\n<98> \n<99> }\n<100> \n<101> st->codec->sample_rate = get_be16(pb);\n<102> \n<103> get_be32(pb);\n<104> \n<105> st->codec->channels = get_be16(pb);\n<106> \n<107> if (((version >> 16) & 0xff) == 5) {\n<108> \n<109> get_be32(pb);\n<110> \n<111> buf[0] = get_byte(pb);\n<112> \n<113> buf[1] = get_byte(pb);\n<114> \n<115> buf[2] = get_byte(pb);\n<116> \n<117> buf[3] = get_byte(pb);\n<118> \n<119> buf[4] = 0;\n<120> \n<121> } else {\n<122> \n<123> get_str8(pb, buf, sizeof(buf)); /* desc */\n<124> \n<125> get_str8(pb, buf, sizeof(buf)); /* desc */\n<126> \n<127> }\n<128> \n<129> st->codec->codec_type = CODEC_TYPE_AUDIO;\n<130> \n<131> if (!strcmp(buf, "dnet")) {\n<132> \n<133> st->codec->codec_id = CODEC_ID_AC3;\n<134> \n<135> st->need_parsing = AVSTREAM_PARSE_FULL;\n<136> \n<137> } else if (!strcmp(buf, "28_8")) {\n<138> \n<139> st->codec->codec_id = CODEC_ID_RA_288;\n<140> \n<141> st->codec->extradata_size= 0;\n<142> \n<143> rm->audio_framesize = st->codec->block_align;\n<144> \n<145> st->codec->block_align = coded_framesize;\n<146> \n<147> \n<148> \n<149> if(rm->audio_framesize >= UINT_MAX / sub_packet_h){\n<150> \n<151> av_log(s, AV_LOG_ERROR, "rm->audio_framesize * sub_packet_h too large\n");\n<152> \n<153> return -1;\n<154> \n<155> }\n<156> \n<157> \n<158> \n<159> rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h);\n<160> \n<161> } else if ((!strcmp(buf, "cook")) || (!strcmp(buf, "atrc")) || (!strcmp(buf, "sipr"))) {\n<162> \n<163> int codecdata_length, i;\n<164> \n<165> get_be16(pb); get_byte(pb);\n<166> \n<167> if (((version >> 16) & 0xff) == 5)\n<168> \n<169> get_byte(pb);\n<170> \n<171> codecdata_length = get_be32(pb);\n<172> \n<173> if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n<174> \n<175> av_log(s, AV_LOG_ERROR, "codecdata_length too large\n");\n<176> \n<177> return -1;\n<178> \n<179> }\n<180> \n<181> \n<182> \n<183> if(sub_packet_size <= 0){\n<184> \n<185> av_log(s, AV_LOG_ERROR, "sub_packet_size is invalid\n");\n<186> \n<187> return -1;\n<188> \n<189> }\n<190> \n<191> \n<192> \n<193> if (!strcmp(buf, "cook")) st->codec->codec_id = CODEC_ID_COOK;\n<194> \n<195> else if (!strcmp(buf, "sipr")) st->codec->codec_id = CODEC_ID_SIPR;\n<196> \n<197> else st->codec->codec_id = CODEC_ID_ATRAC3;\n<198> \n<199> st->codec->extradata_size= codecdata_length;\n<200> \n<201> st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<202> \n<203> for(i = 0; i < codecdata_length; i++)\n<204> \n<205> ((uint8_t*)st->codec->extradata)[i] = get_byte(pb);\n<206> \n<207> rm->audio_framesize = st->codec->block_align;\n<208> \n<209> st->codec->block_align = rm->sub_packet_size;\n<210> \n<211> \n<212> \n<213> if(rm->audio_framesize >= UINT_MAX / sub_packet_h){\n<214> \n<215> av_log(s, AV_LOG_ERROR, "rm->audio_framesize * sub_packet_h too large\n");\n<216> \n<217> return -1;\n<218> \n<219> }\n<220> \n<221> \n<222> \n<223> rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h);\n<224> \n<225> } else if (!strcmp(buf, "raac") || !strcmp(buf, "racp")) {\n<226> \n<227> int codecdata_length, i;\n<228> \n<229> get_be16(pb); get_byte(pb);\n<230> \n<231> if (((version >> 16) & 0xff) == 5)\n<232> \n<233> get_byte(pb);\n<234> \n<235> st->codec->codec_id = CODEC_ID_AAC;\n<236> \n<237> codecdata_length = get_be32(pb);\n<238> \n<239> if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n<240> \n<241> av_log(s, AV_LOG_ERROR, "codecdata_length too large\n");\n<242> \n<243> return -1;\n<244> \n<245> }\n<246> \n<247> if (codecdata_length >= 1) {\n<248> \n<249> st->codec->extradata_size = codecdata_length - 1;\n<250> \n<251> st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<252> \n<253> get_byte(pb);\n<254> \n<255> for(i = 0; i < st->codec->extradata_size; i++)\n<256> \n<257> ((uint8_t*)st->codec->extradata)[i] = get_byte(pb);\n<258> \n<259> }\n<260> \n<261> } else {\n<262> \n<263> st->codec->codec_id = CODEC_ID_NONE;\n<264> \n<265> av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n<266> \n<267> }\n<268> \n<269> if (read_all) {\n<270> \n<271> get_byte(pb);\n<272> \n<273> get_byte(pb);\n<274> \n<275> get_byte(pb);\n<276> \n<277> \n<278> \n<279> get_str8(pb, s->title, sizeof(s->title));\n<280> \n<281> get_str8(pb, s->author, sizeof(s->author));\n<282> \n<283> get_str8(pb, s->copyright, sizeof(s->copyright));\n<284> \n<285> get_str8(pb, s->comment, sizeof(s->comment));\n<286> \n<287> }\n<288> \n<289> }\n<290> \n<291> return 0;\n<292> \n<293> }\n<294> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int svq3_decode_mb(SVQ3Context *s, unsigned int mb_type)\n<2> \n<3> {\n<4> \n<5> H264Context *h = &s->h;\n<6> \n<7> int i, j, k, m, dir, mode;\n<8> \n<9> int cbp = 0;\n<10> \n<11> uint32_t vlc;\n<12> \n<13> int8_t *top, *left;\n<14> \n<15> const int mb_xy         = h->mb_xy;\n<16> \n<17> const int b_xy          = 4 * h->mb_x + 4 * h->mb_y * h->b_stride;\n<18> \n<19> \n<20> \n<21> h->top_samples_available      = (h->mb_y == 0) ? 0x33FF : 0xFFFF;\n<22> \n<23> h->left_samples_available     = (h->mb_x == 0) ? 0x5F5F : 0xFFFF;\n<24> \n<25> h->topright_samples_available = 0xFFFF;\n<26> \n<27> \n<28> \n<29> if (mb_type == 0) {           /* SKIP */\n<30> \n<31> if (h->pict_type == AV_PICTURE_TYPE_P ||\n<32> \n<33> s->next_pic->mb_type[mb_xy] == -1) {\n<34> \n<35> svq3_mc_dir_part(s, 16 * h->mb_x, 16 * h->mb_y, 16, 16,\n<36> \n<37> 0, 0, 0, 0, 0, 0);\n<38> \n<39> \n<40> \n<41> if (h->pict_type == AV_PICTURE_TYPE_B)\n<42> \n<43> svq3_mc_dir_part(s, 16 * h->mb_x, 16 * h->mb_y, 16, 16,\n<44> \n<45> 0, 0, 0, 0, 1, 1);\n<46> \n<47> \n<48> \n<49> mb_type = MB_TYPE_SKIP;\n<50> \n<51> } else {\n<52> \n<53> mb_type = FFMIN(s->next_pic->mb_type[mb_xy], 6);\n<54> \n<55> if (svq3_mc_dir(s, mb_type, PREDICT_MODE, 0, 0) < 0)\n<56> \n<57> return -1;\n<58> \n<59> if (svq3_mc_dir(s, mb_type, PREDICT_MODE, 1, 1) < 0)\n<60> \n<61> return -1;\n<62> \n<63> \n<64> \n<65> mb_type = MB_TYPE_16x16;\n<66> \n<67> }\n<68> \n<69> } else if (mb_type < 8) {     /* INTER */\n<70> \n<71> if (s->thirdpel_flag && s->halfpel_flag == !get_bits1(&h->gb))\n<72> \n<73> mode = THIRDPEL_MODE;\n<74> \n<75> else if (s->halfpel_flag &&\n<76> \n<77> s->thirdpel_flag == !get_bits1(&h->gb))\n<78> \n<79> mode = HALFPEL_MODE;\n<80> \n<81> else\n<82> \n<83> mode = FULLPEL_MODE;\n<84> \n<85> \n<86> \n<87> /* fill caches */\n<88> \n<89> /* note ref_cache should contain here:\n<90> \n<91> *  ????????\n<92> \n<93> *  ???11111\n<94> \n<95> *  N??11111\n<96> \n<97> *  N??11111\n<98> \n<99> *  N??11111\n<100> \n<101> */\n<102> \n<103> \n<104> \n<105> for (m = 0; m < 2; m++) {\n<106> \n<107> if (h->mb_x > 0 && h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - 1] + 6] != -1) {\n<108> \n<109> for (i = 0; i < 4; i++)\n<110> \n<111> AV_COPY32(h->mv_cache[m][scan8[0] - 1 + i * 8],\n<112> \n<113> h->cur_pic.motion_val[m][b_xy - 1 + i * h->b_stride]);\n<114> \n<115> } else {\n<116> \n<117> for (i = 0; i < 4; i++)\n<118> \n<119> AV_ZERO32(h->mv_cache[m][scan8[0] - 1 + i * 8]);\n<120> \n<121> }\n<122> \n<123> if (h->mb_y > 0) {\n<124> \n<125> memcpy(h->mv_cache[m][scan8[0] - 1 * 8],\n<126> \n<127> h->cur_pic.motion_val[m][b_xy - h->b_stride],\n<128> \n<129> 4 * 2 * sizeof(int16_t));\n<130> \n<131> memset(&h->ref_cache[m][scan8[0] - 1 * 8],\n<132> \n<133> (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride]] == -1) ? PART_NOT_AVAILABLE : 1, 4);\n<134> \n<135> \n<136> \n<137> if (h->mb_x < h->mb_width - 1) {\n<138> \n<139> AV_COPY32(h->mv_cache[m][scan8[0] + 4 - 1 * 8],\n<140> \n<141> h->cur_pic.motion_val[m][b_xy - h->b_stride + 4]);\n<142> \n<143> h->ref_cache[m][scan8[0] + 4 - 1 * 8] =\n<144> \n<145> (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride + 1] + 6] == -1 ||\n<146> \n<147> h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride]] == -1) ? PART_NOT_AVAILABLE : 1;\n<148> \n<149> } else\n<150> \n<151> h->ref_cache[m][scan8[0] + 4 - 1 * 8] = PART_NOT_AVAILABLE;\n<152> \n<153> if (h->mb_x > 0) {\n<154> \n<155> AV_COPY32(h->mv_cache[m][scan8[0] - 1 - 1 * 8],\n<156> \n<157> h->cur_pic.motion_val[m][b_xy - h->b_stride - 1]);\n<158> \n<159> h->ref_cache[m][scan8[0] - 1 - 1 * 8] =\n<160> \n<161> (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride - 1] + 3] == -1) ? PART_NOT_AVAILABLE : 1;\n<162> \n<163> } else\n<164> \n<165> h->ref_cache[m][scan8[0] - 1 - 1 * 8] = PART_NOT_AVAILABLE;\n<166> \n<167> } else\n<168> \n<169> memset(&h->ref_cache[m][scan8[0] - 1 * 8 - 1],\n<170> \n<171> PART_NOT_AVAILABLE, 8);\n<172> \n<173> \n<174> \n<175> if (h->pict_type != AV_PICTURE_TYPE_B)\n<176> \n<177> break;\n<178> \n<179> }\n<180> \n<181> \n<182> \n<183> /* decode motion vector(s) and form prediction(s) */\n<184> \n<185> if (h->pict_type == AV_PICTURE_TYPE_P) {\n<186> \n<187> if (svq3_mc_dir(s, mb_type - 1, mode, 0, 0) < 0)\n<188> \n<189> return -1;\n<190> \n<191> } else {        /* AV_PICTURE_TYPE_B */\n<192> \n<193> if (mb_type != 2) {\n<194> \n<195> if (svq3_mc_dir(s, 0, mode, 0, 0) < 0)\n<196> \n<197> return -1;\n<198> \n<199> } else {\n<200> \n<201> for (i = 0; i < 4; i++)\n<202> \n<203> memset(h->cur_pic.motion_val[0][b_xy + i * h->b_stride],\n<204> \n<205> 0, 4 * 2 * sizeof(int16_t));\n<206> \n<207> }\n<208> \n<209> if (mb_type != 1) {\n<210> \n<211> if (svq3_mc_dir(s, 0, mode, 1, mb_type == 3) < 0)\n<212> \n<213> return -1;\n<214> \n<215> } else {\n<216> \n<217> for (i = 0; i < 4; i++)\n<218> \n<219> memset(h->cur_pic.motion_val[1][b_xy + i * h->b_stride],\n<220> \n<221> 0, 4 * 2 * sizeof(int16_t));\n<222> \n<223> }\n<224> \n<225> }\n<226> \n<227> \n<228> \n<229> mb_type = MB_TYPE_16x16;\n<230> \n<231> } else if (mb_type == 8 || mb_type == 33) {   /* INTRA4x4 */\n<232> \n<233> memset(h->intra4x4_pred_mode_cache, -1, 8 * 5 * sizeof(int8_t));\n<234> \n<235> \n<236> \n<237> if (mb_type == 8) {\n<238> \n<239> if (h->mb_x > 0) {\n<240> \n<241> for (i = 0; i < 4; i++)\n<242> \n<243> h->intra4x4_pred_mode_cache[scan8[0] - 1 + i * 8] = h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - 1] + 6 - i];\n<244> \n<245> if (h->intra4x4_pred_mode_cache[scan8[0] - 1] == -1)\n<246> \n<247> h->left_samples_available = 0x5F5F;\n<248> \n<249> }\n<250> \n<251> if (h->mb_y > 0) {\n<252> \n<253> h->intra4x4_pred_mode_cache[4 + 8 * 0] = h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride] + 0];\n<254> \n<255> h->intra4x4_pred_mode_cache[5 + 8 * 0] = h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride] + 1];\n<256> \n<257> h->intra4x4_pred_mode_cache[6 + 8 * 0] = h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride] + 2];\n<258> \n<259> h->intra4x4_pred_mode_cache[7 + 8 * 0] = h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride] + 3];\n<260> \n<261> \n<262> \n<263> if (h->intra4x4_pred_mode_cache[4 + 8 * 0] == -1)\n<264> \n<265> h->top_samples_available = 0x33FF;\n<266> \n<267> }\n<268> \n<269> \n<270> \n<271> /* decode prediction codes for luma blocks */\n<272> \n<273> for (i = 0; i < 16; i += 2) {\n<274> \n<275> vlc = svq3_get_ue_golomb(&h->gb);\n<276> \n<277> \n<278> \n<279> if (vlc >= 25U) {\n<280> \n<281> av_log(h->avctx, AV_LOG_ERROR, "luma prediction:%d\n", vlc);\n<282> \n<283> return -1;\n<284> \n<285> }\n<286> \n<287> \n<288> \n<289> left = &h->intra4x4_pred_mode_cache[scan8[i] - 1];\n<290> \n<291> top  = &h->intra4x4_pred_mode_cache[scan8[i] - 8];\n<292> \n<293> \n<294> \n<295> left[1] = svq3_pred_1[top[0] + 1][left[0] + 1][svq3_pred_0[vlc][0]];\n<296> \n<297> left[2] = svq3_pred_1[top[1] + 1][left[1] + 1][svq3_pred_0[vlc][1]];\n<298> \n<299> \n<300> \n<301> if (left[1] == -1 || left[2] == -1) {\n<302> \n<303> av_log(h->avctx, AV_LOG_ERROR, "weird prediction\n");\n<304> \n<305> return -1;\n<306> \n<307> }\n<308> \n<309> }\n<310> \n<311> } else {    /* mb_type == 33, DC_128_PRED block type */\n<312> \n<313> for (i = 0; i < 4; i++)\n<314> \n<315> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8 * i], DC_PRED, 4);\n<316> \n<317> }\n<318> \n<319> \n<320> \n<321> write_back_intra_pred_mode(h);\n<322> \n<323> \n<324> \n<325> if (mb_type == 8) {\n<326> \n<327> ff_h264_check_intra4x4_pred_mode(h);\n<328> \n<329> \n<330> \n<331> h->top_samples_available  = (h->mb_y == 0) ? 0x33FF : 0xFFFF;\n<332> \n<333> h->left_samples_available = (h->mb_x == 0) ? 0x5F5F : 0xFFFF;\n<334> \n<335> } else {\n<336> \n<337> for (i = 0; i < 4; i++)\n<338> \n<339> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8 * i], DC_128_PRED, 4);\n<340> \n<341> \n<342> \n<343> h->top_samples_available  = 0x33FF;\n<344> \n<345> h->left_samples_available = 0x5F5F;\n<346> \n<347> }\n<348> \n<349> \n<350> \n<351> mb_type = MB_TYPE_INTRA4x4;\n<352> \n<353> } else {                      /* INTRA16x16 */\n<354> \n<355> dir = i_mb_type_info[mb_type - 8].pred_mode;\n<356> \n<357> dir = (dir >> 1) ^ 3 * (dir & 1) ^ 1;\n<358> \n<359> \n<360> \n<361> if ((h->intra16x16_pred_mode = ff_h264_check_intra_pred_mode(h, dir, 0)) == -1) {\n<362> \n<363> av_log(h->avctx, AV_LOG_ERROR, "check_intra_pred_mode = -1\n");\n<364> \n<365> return -1;\n<366> \n<367> }\n<368> \n<369> \n<370> \n<371> cbp     = i_mb_type_info[mb_type - 8].cbp;\n<372> \n<373> mb_type = MB_TYPE_INTRA16x16;\n<374> \n<375> }\n<376> \n<377> \n<378> \n<379> if (!IS_INTER(mb_type) && h->pict_type != AV_PICTURE_TYPE_I) {\n<380> \n<381> for (i = 0; i < 4; i++)\n<382> \n<383> memset(h->cur_pic.motion_val[0][b_xy + i * h->b_stride],\n<384> \n<385> 0, 4 * 2 * sizeof(int16_t));\n<386> \n<387> if (h->pict_type == AV_PICTURE_TYPE_B) {\n<388> \n<389> for (i = 0; i < 4; i++)\n<390> \n<391> memset(h->cur_pic.motion_val[1][b_xy + i * h->b_stride],\n<392> \n<393> 0, 4 * 2 * sizeof(int16_t));\n<394> \n<395> }\n<396> \n<397> }\n<398> \n<399> if (!IS_INTRA4x4(mb_type)) {\n<400> \n<401> memset(h->intra4x4_pred_mode + h->mb2br_xy[mb_xy], DC_PRED, 8);\n<402> \n<403> }\n<404> \n<405> if (!IS_SKIP(mb_type) || h->pict_type == AV_PICTURE_TYPE_B) {\n<406> \n<407> memset(h->non_zero_count_cache + 8, 0, 14 * 8 * sizeof(uint8_t));\n<408> \n<409> }\n<410> \n<411> \n<412> \n<413> if (!IS_INTRA16x16(mb_type) &&\n<414> \n<415> (!IS_SKIP(mb_type) || h->pict_type == AV_PICTURE_TYPE_B)) {\n<416> \n<417> if ((vlc = svq3_get_ue_golomb(&h->gb)) >= 48U){\n<418> \n<419> av_log(h->avctx, AV_LOG_ERROR, "cbp_vlc=%d\n", vlc);\n<420> \n<421> return -1;\n<422> \n<423> }\n<424> \n<425> \n<426> \n<427> cbp = IS_INTRA(mb_type) ? golomb_to_intra4x4_cbp[vlc]\n<428> \n<429> : golomb_to_inter_cbp[vlc];\n<430> \n<431> }\n<432> \n<433> if (IS_INTRA16x16(mb_type) ||\n<434> \n<435> (h->pict_type != AV_PICTURE_TYPE_I && s->adaptive_quant && cbp)) {\n<436> \n<437> h->qscale += svq3_get_se_golomb(&h->gb);\n<438> \n<439> \n<440> \n<441> if (h->qscale > 31u) {\n<442> \n<443> av_log(h->avctx, AV_LOG_ERROR, "qscale:%d\n", h->qscale);\n<444> \n<445> return -1;\n<446> \n<447> }\n<448> \n<449> }\n<450> \n<451> if (IS_INTRA16x16(mb_type)) {\n<452> \n<453> AV_ZERO128(h->mb_luma_dc[0] + 0);\n<454> \n<455> AV_ZERO128(h->mb_luma_dc[0] + 8);\n<456> \n<457> if (svq3_decode_block(&h->gb, h->mb_luma_dc[0], 0, 1)) {\n<458> \n<459> av_log(h->avctx, AV_LOG_ERROR,\n<460> \n<461> "error while decoding intra luma dc\n");\n<462> \n<463> return -1;\n<464> \n<465> }\n<466> \n<467> }\n<468> \n<469> \n<470> \n<471> if (cbp) {\n<472> \n<473> const int index = IS_INTRA16x16(mb_type) ? 1 : 0;\n<474> \n<475> const int type  = ((h->qscale < 24 && IS_INTRA4x4(mb_type)) ? 2 : 1);\n<476> \n<477> \n<478> \n<479> for (i = 0; i < 4; i++)\n<480> \n<481> if ((cbp & (1 << i))) {\n<482> \n<483> for (j = 0; j < 4; j++) {\n<484> \n<485> k = index ? (1 * (j & 1) + 2 * (i & 1) +\n<486> \n<487> 2 * (j & 2) + 4 * (i & 2))\n<488> \n<489> : (4 * i + j);\n<490> \n<491> h->non_zero_count_cache[scan8[k]] = 1;\n<492> \n<493> \n<494> \n<495> if (svq3_decode_block(&h->gb, &h->mb[16 * k], index, type)) {\n<496> \n<497> av_log(h->avctx, AV_LOG_ERROR,\n<498> \n<499> "error while decoding block\n");\n<500> \n<501> return -1;\n<502> \n<503> }\n<504> \n<505> }\n<506> \n<507> }\n<508> \n<509> \n<510> \n<511> if ((cbp & 0x30)) {\n<512> \n<513> for (i = 1; i < 3; ++i)\n<514> \n<515> if (svq3_decode_block(&h->gb, &h->mb[16 * 16 * i], 0, 3)) {\n<516> \n<517> av_log(h->avctx, AV_LOG_ERROR,\n<518> \n<519> "error while decoding chroma dc block\n");\n<520> \n<521> return -1;\n<522> \n<523> }\n<524> \n<525> \n<526> \n<527> if ((cbp & 0x20)) {\n<528> \n<529> for (i = 1; i < 3; i++) {\n<530> \n<531> for (j = 0; j < 4; j++) {\n<532> \n<533> k                                 = 16 * i + j;\n<534> \n<535> h->non_zero_count_cache[scan8[k]] = 1;\n<536> \n<537> \n<538> \n<539> if (svq3_decode_block(&h->gb, &h->mb[16 * k], 1, 1)) {\n<540> \n<541> av_log(h->avctx, AV_LOG_ERROR,\n<542> \n<543> "error while decoding chroma ac block\n");\n<544> \n<545> return -1;\n<546> \n<547> }\n<548> \n<549> }\n<550> \n<551> }\n<552> \n<553> }\n<554> \n<555> }\n<556> \n<557> }\n<558> \n<559> \n<560> \n<561> h->cbp                              = cbp;\n<562> \n<563> h->cur_pic.mb_type[mb_xy] = mb_type;\n<564> \n<565> \n<566> \n<567> if (IS_INTRA(mb_type))\n<568> \n<569> h->chroma_pred_mode = ff_h264_check_intra_pred_mode(h, DC_PRED8x8, 1);\n<570> \n<571> \n<572> \n<573> return 0;\n<574> \n<575> }\n<576> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static uint get_table_structure ( char * table , char * db , char * table_type , char * ignore_flag ) {\n<2> my_bool init = 0 , delayed , write_data , complete_insert ;\n<3> my_ulonglong num_fields ;\n<4> char * result_table , * opt_quoted_table ;\n<5> const char * insert_option ;\n<6> char name_buff [ NAME_LEN + 3 ] , table_buff [ NAME_LEN * 2 + 3 ] ;\n<7> char table_buff2 [ NAME_LEN * 2 + 3 ] , query_buff [ QUERY_LENGTH ] ;\n<8> const char * show_fields_stmt = "SELECT `COLUMN_NAME` AS `Field`, " "`COLUMN_TYPE` AS `Type`, " "`IS_NULLABLE` AS `Null`, " "`COLUMN_KEY` AS `Key`, " "`COLUMN_DEFAULT` AS `Default`, " "`EXTRA` AS `Extra`, " "`COLUMN_COMMENT` AS `Comment` " "FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE " "TABLE_SCHEMA = '%s' AND TABLE_NAME = '%s'" ;\n<9> FILE * sql_file = md_result_file ;\n<10> int len ;\n<11> my_bool is_log_table ;\n<12> MYSQL_RES * result ;\n<13> MYSQL_ROW row ;\n<14> DBUG_ENTER ( "get_table_structure" ) ;\n<15> DBUG_PRINT ( "enter" , ( "db: %s table: %s" , db , table ) ) ;\n<16> * ignore_flag = check_if_ignore_table ( table , table_type ) ;\n<17> delayed = opt_delayed ;\n<18> if ( delayed && ( * ignore_flag & IGNORE_INSERT_DELAYED ) ) {\n<19> delayed = 0 ;\n<20> verbose_msg ( "-- Warning: Unable to use delayed inserts for table '%s' " "because it's of type %s\n" , table , table_type ) ;\n<21> }\n<22> complete_insert = 0 ;\n<23> if ( ( write_data = ! ( * ignore_flag & IGNORE_DATA ) ) ) {\n<24> complete_insert = opt_complete_insert ;\n<25> if ( ! insert_pat_inited ) {\n<26> insert_pat_inited = 1 ;\n<27> init_dynamic_string_checked ( & insert_pat , "" , 1024 , 1024 ) ;\n<28> }\n<29> else dynstr_set_checked ( & insert_pat , "" ) ;\n<30> }\n<31> insert_option = ( ( delayed && opt_ignore ) ? " DELAYED IGNORE " : delayed ? " DELAYED " : opt_ignore ? " IGNORE " : "" ) ;\n<32> verbose_msg ( "-- Retrieving table structure for table %s...\n" , table ) ;\n<33> len = my_snprintf ( query_buff , sizeof ( query_buff ) , "SET SQL_QUOTE_SHOW_CREATE=%d" , ( opt_quoted || opt_keywords ) ) ;\n<34> if ( ! create_options ) strmov ( query_buff + len , "/*!40102 ,SQL_MODE=concat(@@sql_mode, _utf8 ',NO_KEY_OPTIONS,NO_TABLE_OPTIONS,NO_FIELD_OPTIONS') */" ) ;\n<35> result_table = quote_name ( table , table_buff , 1 ) ;\n<36> opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n<37> if ( opt_order_by_primary ) order_by = primary_key_fields ( result_table ) ;\n<38> if ( ! opt_xml && ! mysql_query_with_error_report ( mysql , 0 , query_buff ) ) {\n<39> if ( ! opt_no_create_info ) {\n<40> char buff [ 20 + FN_REFLEN ] ;\n<41> MYSQL_FIELD * field ;\n<42> my_snprintf ( buff , sizeof ( buff ) , "show create table %s" , result_table ) ;\n<43> if ( switch_character_set_results ( mysql , "binary" ) || mysql_query_with_error_report ( mysql , & result , buff ) || switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 0 ) ;\n<44> if ( path ) {\n<45> if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) DBUG_RETURN ( 0 ) ;\n<46> write_header ( sql_file , db ) ;\n<47> }\n<48> if ( strcmp ( table_type , "VIEW" ) == 0 ) print_comment ( sql_file , 0 , "\n--\n-- Temporary table structure for view %s\n--\n\n" , result_table ) ;\n<49> else print_comment ( sql_file , 0 , "\n--\n-- Table structure for table %s\n--\n\n" , result_table ) ;\n<50> if ( opt_drop ) {\n<51> if ( ! general_log_or_slow_log_tables ( db , table ) ) fprintf ( sql_file , "DROP TABLE IF EXISTS %s;\n<52> \n" , opt_quoted_table ) ;\n<53> check_io ( sql_file ) ;\n<54> }\n<55> field = mysql_fetch_field_direct ( result , 0 ) ;\n<56> if ( strcmp ( field -> name , "View" ) == 0 ) {\n<57> char * scv_buff = NULL ;\n<58> my_ulonglong n_cols ;\n<59> verbose_msg ( "-- It's a view, create dummy table for view\n" ) ;\n<60> if ( ( row = mysql_fetch_row ( result ) ) && ( scv_buff = row [ 1 ] ) ) scv_buff = my_strdup ( scv_buff , MYF ( 0 ) ) ;\n<61> mysql_free_result ( result ) ;\n<62> my_snprintf ( query_buff , sizeof ( query_buff ) , "SHOW FIELDS FROM %s" , result_table ) ;\n<63> if ( switch_character_set_results ( mysql , "binary" ) || mysql_query_with_error_report ( mysql , & result , query_buff ) || switch_character_set_results ( mysql , default_charset ) ) {\n<64> if ( mysql_errno ( mysql ) == ER_VIEW_INVALID ) fprintf ( sql_file , "\n-- failed on view %s: %s\n\n" , result_table , scv_buff ? scv_buff : "" ) ;\n<65> my_free ( scv_buff ) ;\n<66> DBUG_RETURN ( 0 ) ;\n<67> }\n<68> else my_free ( scv_buff ) ;\n<69> n_cols = mysql_num_rows ( result ) ;\n<70> if ( 0 != n_cols ) {\n<71> if ( n_cols >= 1000 ) fprintf ( stderr , "-- Warning: Creating a stand-in table for view %s may" " fail when replaying the dump file produced because " "of the number of columns exceeding 1000. Exercise " "caution when replaying the produced dump file.\n" , table ) ;\n<72> if ( opt_drop ) {\n<73> fprintf ( sql_file , "/*!50001 DROP VIEW IF EXISTS %s*/;\n<74> \n" , opt_quoted_table ) ;\n<75> check_io ( sql_file ) ;\n<76> }\n<77> fprintf ( sql_file , "SET @saved_cs_client = @@character_set_client;\n<78> \n" "SET character_set_client = utf8;\n<79> \n" "/*!50001 CREATE TABLE %s (\n" , result_table ) ;\n<80> row = mysql_fetch_row ( result ) ;\n<81> fprintf ( sql_file , " %s tinyint NOT NULL" , quote_name ( row [ 0 ] , name_buff , 0 ) ) ;\n<82> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<83> fprintf ( sql_file , ",\n %s tinyint NOT NULL" , quote_name ( row [ 0 ] , name_buff , 0 ) ) ;\n<84> }\n<85> fprintf ( sql_file , "\n) ENGINE=MyISAM */;\n<86> \n" "SET character_set_client = @saved_cs_client;\n<87> \n" ) ;\n<88> check_io ( sql_file ) ;\n<89> }\n<90> mysql_free_result ( result ) ;\n<91> if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n<92> seen_views = 1 ;\n<93> DBUG_RETURN ( 0 ) ;\n<94> }\n<95> row = mysql_fetch_row ( result ) ;\n<96> is_log_table = general_log_or_slow_log_tables ( db , table ) ;\n<97> if ( is_log_table ) row [ 1 ] += 13 ;\n<98> if ( opt_compatible_mode & 3 ) {\n<99> fprintf ( sql_file , is_log_table ? "CREATE TABLE IF NOT EXISTS %s;\n<100> \n" : "%s;\n<101> \n" , row [ 1 ] ) ;\n<102> }\n<103> else {\n<104> fprintf ( sql_file , "/*!40101 SET @saved_cs_client = @@character_set_client */;\n<105> \n" "/*!40101 SET character_set_client = utf8 */;\n<106> \n" "%s%s;\n<107> \n" "/*!40101 SET character_set_client = @saved_cs_client */;\n<108> \n" , is_log_table ? "CREATE TABLE IF NOT EXISTS " : "" , row [ 1 ] ) ;\n<109> }\n<110> check_io ( sql_file ) ;\n<111> mysql_free_result ( result ) ;\n<112> }\n<113> my_snprintf ( query_buff , sizeof ( query_buff ) , "show fields from %s" , result_table ) ;\n<114> if ( mysql_query_with_error_report ( mysql , & result , query_buff ) ) {\n<115> if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n<116> DBUG_RETURN ( 0 ) ;\n<117> }\n<118> if ( write_data ) {\n<119> if ( opt_replace_into ) dynstr_append_checked ( & insert_pat , "REPLACE " ) ;\n<120> else dynstr_append_checked ( & insert_pat , "INSERT " ) ;\n<121> dynstr_append_checked ( & insert_pat , insert_option ) ;\n<122> dynstr_append_checked ( & insert_pat , "INTO " ) ;\n<123> dynstr_append_checked ( & insert_pat , opt_quoted_table ) ;\n<124> if ( complete_insert ) {\n<125> dynstr_append_checked ( & insert_pat , " (" ) ;\n<126> }\n<127> else {\n<128> dynstr_append_checked ( & insert_pat , " VALUES " ) ;\n<129> if ( ! extended_insert ) dynstr_append_checked ( & insert_pat , "(" ) ;\n<130> }\n<131> }\n<132> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<133> if ( complete_insert ) {\n<134> if ( init ) {\n<135> dynstr_append_checked ( & insert_pat , ", " ) ;\n<136> }\n<137> init = 1 ;\n<138> dynstr_append_checked ( & insert_pat , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) ) ;\n<139> }\n<140> }\n<141> num_fields = mysql_num_rows ( result ) ;\n<142> mysql_free_result ( result ) ;\n<143> }\n<144> else {\n<145> verbose_msg ( "%s: Warning: Can't set SQL_QUOTE_SHOW_CREATE option (%s)\n" , my_progname_short , mysql_error ( mysql ) ) ;\n<146> my_snprintf ( query_buff , sizeof ( query_buff ) , show_fields_stmt , db , table ) ;\n<147> if ( mysql_query_with_error_report ( mysql , & result , query_buff ) ) DBUG_RETURN ( 0 ) ;\n<148> if ( ! opt_no_create_info ) {\n<149> if ( path ) {\n<150> if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) DBUG_RETURN ( 0 ) ;\n<151> write_header ( sql_file , db ) ;\n<152> }\n<153> print_comment ( sql_file , 0 , "\n--\n-- Table structure for table %s\n--\n\n" , result_table ) ;\n<154> if ( opt_drop ) fprintf ( sql_file , "DROP TABLE IF EXISTS %s;\n<155> \n" , result_table ) ;\n<156> if ( ! opt_xml ) fprintf ( sql_file , "CREATE TABLE %s (\n" , result_table ) ;\n<157> else print_xml_tag ( sql_file , "\t" , "\n" , "table_structure" , "name=" , table , NullS ) ;\n<158> check_io ( sql_file ) ;\n<159> }\n<160> if ( write_data ) {\n<161> if ( opt_replace_into ) dynstr_append_checked ( & insert_pat , "REPLACE " ) ;\n<162> else dynstr_append_checked ( & insert_pat , "INSERT " ) ;\n<163> dynstr_append_checked ( & insert_pat , insert_option ) ;\n<164> dynstr_append_checked ( & insert_pat , "INTO " ) ;\n<165> dynstr_append_checked ( & insert_pat , result_table ) ;\n<166> if ( complete_insert ) dynstr_append_checked ( & insert_pat , " (" ) ;\n<167> else {\n<168> dynstr_append_checked ( & insert_pat , " VALUES " ) ;\n<169> if ( ! extended_insert ) dynstr_append_checked ( & insert_pat , "(" ) ;\n<170> }\n<171> }\n<172> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<173> ulong * lengths = mysql_fetch_lengths ( result ) ;\n<174> if ( init ) {\n<175> if ( ! opt_xml && ! opt_no_create_info ) {\n<176> fputs ( ",\n" , sql_file ) ;\n<177> check_io ( sql_file ) ;\n<178> }\n<179> if ( complete_insert ) dynstr_append_checked ( & insert_pat , ", " ) ;\n<180> }\n<181> init = 1 ;\n<182> if ( complete_insert ) dynstr_append_checked ( & insert_pat , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) ) ;\n<183> if ( ! opt_no_create_info ) {\n<184> if ( opt_xml ) {\n<185> print_xml_row ( sql_file , "field" , result , & row , NullS ) ;\n<186> continue ;\n<187> }\n<188> if ( opt_keywords ) fprintf ( sql_file , " %s.%s %s" , result_table , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n<189> else fprintf ( sql_file , " %s %s" , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n<190> if ( row [ SHOW_DEFAULT ] ) {\n<191> fputs ( " DEFAULT " , sql_file ) ;\n<192> unescape ( sql_file , row [ SHOW_DEFAULT ] , lengths [ SHOW_DEFAULT ] ) ;\n<193> }\n<194> if ( ! row [ SHOW_NULL ] [ 0 ] ) fputs ( " NOT NULL" , sql_file ) ;\n<195> if ( row [ SHOW_EXTRA ] [ 0 ] ) fprintf ( sql_file , " %s" , row [ SHOW_EXTRA ] ) ;\n<196> check_io ( sql_file ) ;\n<197> }\n<198> }\n<199> num_fields = mysql_num_rows ( result ) ;\n<200> mysql_free_result ( result ) ;\n<201> if ( ! opt_no_create_info ) {\n<202> char buff [ 20 + FN_REFLEN ] ;\n<203> uint keynr , primary_key ;\n<204> my_snprintf ( buff , sizeof ( buff ) , "show keys from %s" , result_table ) ;\n<205> if ( mysql_query_with_error_report ( mysql , & result , buff ) ) {\n<206> if ( mysql_errno ( mysql ) == ER_WRONG_OBJECT ) {\n<207> fputs ( "\t\t<options Comment=\"view\" />\n" , sql_file ) ;\n<208> goto continue_xml ;\n<209> }\n<210> fprintf ( stderr , "%s: Can't get keys for table %s (%s)\n" , my_progname_short , result_table , mysql_error ( mysql ) ) ;\n<211> if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n<212> DBUG_RETURN ( 0 ) ;\n<213> }\n<214> keynr = 0 ;\n<215> primary_key = INT_MAX ;\n<216> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<217> if ( atoi ( row [ 3 ] ) == 1 ) {\n<218> keynr ++ ;\n<219> # ifdef FORCE_PRIMARY_KEY if ( atoi ( row [ 1 ] ) == 0 && primary_key == INT_MAX ) primary_key = keynr ;\n<220> # endif if ( ! strcmp ( row [ 2 ] , "PRIMARY" ) ) {\n<221> primary_key = keynr ;\n<222> break ;\n<223> }\n<224> }\n<225> }\n<226> mysql_data_seek ( result , 0 ) ;\n<227> keynr = 0 ;\n<228> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<229> if ( opt_xml ) {\n<230> print_xml_row ( sql_file , "key" , result , & row , NullS ) ;\n<231> continue ;\n<232> }\n<233> if ( atoi ( row [ 3 ] ) == 1 ) {\n<234> if ( keynr ++ ) putc ( ')' , sql_file ) ;\n<235> if ( atoi ( row [ 1 ] ) ) fprintf ( sql_file , ",\n KEY %s (" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n<236> else if ( keynr == primary_key ) fputs ( ",\n PRIMARY KEY (" , sql_file ) ;\n<237> else fprintf ( sql_file , ",\n UNIQUE %s (" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n<238> }\n<239> else putc ( ',' , sql_file ) ;\n<240> fputs ( quote_name ( row [ 4 ] , name_buff , 0 ) , sql_file ) ;\n<241> if ( row [ 7 ] ) fprintf ( sql_file , " (%s)" , row [ 7 ] ) ;\n<242> check_io ( sql_file ) ;\n<243> }\n<244> mysql_free_result ( result ) ;\n<245> if ( ! opt_xml ) {\n<246> if ( keynr ) putc ( ')' , sql_file ) ;\n<247> fputs ( "\n)" , sql_file ) ;\n<248> check_io ( sql_file ) ;\n<249> }\n<250> if ( create_options ) {\n<251> char show_name_buff [ NAME_LEN * 2 + 2 + 24 ] ;\n<252> my_snprintf ( buff , sizeof ( buff ) , "show table status like %s" , quote_for_like ( table , show_name_buff ) ) ;\n<253> if ( mysql_query_with_error_report ( mysql , & result , buff ) ) {\n<254> if ( mysql_errno ( mysql ) != ER_PARSE_ERROR ) {\n<255> verbose_msg ( "-- Warning: Couldn't get status information for " "table %s (%s)\n" , result_table , mysql_error ( mysql ) ) ;\n<256> }\n<257> }\n<258> else if ( ! ( row = mysql_fetch_row ( result ) ) ) {\n<259> fprintf ( stderr , "Error: Couldn't read status information for table %s (%s)\n" , result_table , mysql_error ( mysql ) ) ;\n<260> }\n<261> else {\n<262> if ( opt_xml ) print_xml_row ( sql_file , "options" , result , & row , NullS ) ;\n<263> else {\n<264> fputs ( "/*!" , sql_file ) ;\n<265> print_value ( sql_file , result , row , "engine=" , "Engine" , 0 ) ;\n<266> print_value ( sql_file , result , row , "" , "Create_options" , 0 ) ;\n<267> print_value ( sql_file , result , row , "comment=" , "Comment" , 1 ) ;\n<268> fputs ( " */" , sql_file ) ;\n<269> check_io ( sql_file ) ;\n<270> }\n<271> }\n<272> mysql_free_result ( result ) ;\n<273> }\n<274> continue_xml : if ( ! opt_xml ) fputs ( ";\n<275> \n" , sql_file ) ;\n<276> else fputs ( "\t</table_structure>\n" , sql_file ) ;\n<277> check_io ( sql_file ) ;\n<278> }\n<279> }\n<280> if ( complete_insert ) {\n<281> dynstr_append_checked ( & insert_pat , ") VALUES " ) ;\n<282> if ( ! extended_insert ) dynstr_append_checked ( & insert_pat , "(" ) ;\n<283> }\n<284> if ( sql_file != md_result_file ) {\n<285> fputs ( "\n" , sql_file ) ;\n<286> write_footer ( sql_file ) ;\n<287> my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n<288> }\n<289> DBUG_RETURN ( ( uint ) num_fields ) ;\n<290> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
gemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int avpicture_layout(const AVPicture* src, enum AVPixelFormat pix_fmt,\n<2> \n<3> int width, int height,\n<4> \n<5> unsigned char *dest, int dest_size)\n<6> \n<7> {\n<8> \n<9> int i, j, nb_planes = 0, linesizes[4];\n<10> \n<11> const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n<12> \n<13> int size = avpicture_get_size(pix_fmt, width, height);\n<14> \n<15> \n<16> \n<17> if (size > dest_size || size < 0)\n<18> \n<19> return AVERROR(EINVAL);\n<20> \n<21> \n<22> \n<23> for (i = 0; i < desc->nb_components; i++)\n<24> \n<25> nb_planes = FFMAX(desc->comp[i].plane, nb_planes);\n<26> \n<27> \n<28> \n<29> nb_planes++;\n<30> \n<31> \n<32> \n<33> av_image_fill_linesizes(linesizes, pix_fmt, width);\n<34> \n<35> for (i = 0; i < nb_planes; i++) {\n<36> \n<37> int h, shift = (i == 1 || i == 2) ? desc->log2_chroma_h : 0;\n<38> \n<39> const unsigned char *s = src->data[i];\n<40> \n<41> h = (height + (1 << shift) - 1) >> shift;\n<42> \n<43> \n<44> \n<45> for (j = 0; j < h; j++) {\n<46> \n<47> memcpy(dest, s, linesizes[i]);\n<48> \n<49> dest += linesizes[i];\n<50> \n<51> s += src->linesize[i];\n<52> \n<53> }\n<54> \n<55> }\n<56> \n<57> \n<58> \n<59> if (desc->flags & AV_PIX_FMT_FLAG_PAL)\n<60> \n<61> memcpy((unsigned char *)(((size_t)dest + 3) & ~3),\n<62> \n<63> src->data[1], 256 * 4);\n<64> \n<65> \n<66> \n<67> return size;\n<68> \n<69> }\n<70> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_dxva2_commit_buffer(AVCodecContext *avctx,\n<2> \n<3> AVDXVAContext *ctx,\n<4> \n<5> DECODER_BUFFER_DESC *dsc,\n<6> \n<7> unsigned type, const void *data, unsigned size,\n<8> \n<9> unsigned mb_count)\n<10> \n<11> {\n<12> \n<13> void     *dxva_data;\n<14> \n<15> unsigned dxva_size;\n<16> \n<17> int      result;\n<18> \n<19> HRESULT hr;\n<20> \n<21> \n<22> \n<23> #if CONFIG_D3D11VA\n<24> \n<25> if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n<26> \n<27> hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,\n<28> \n<29> D3D11VA_CONTEXT(ctx)->decoder,\n<30> \n<31> type,\n<32> \n<33> &dxva_size, &dxva_data);\n<34> \n<35> #endif\n<36> \n<37> #if CONFIG_DXVA2\n<38> \n<39> if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n<40> \n<41> hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,\n<42> \n<43> &dxva_data, &dxva_size);\n<44> \n<45> #endif\n<46> \n<47> if (FAILED(hr)) {\n<48> \n<49> av_log(avctx, AV_LOG_ERROR, "Failed to get a buffer for %u: 0x%x\n",\n<50> \n<51> type, hr);\n<52> \n<53> return -1;\n<54> \n<55> }\n<56> \n<57> if (size <= dxva_size) {\n<58> \n<59> memcpy(dxva_data, data, size);\n<60> \n<61> \n<62> \n<63> #if CONFIG_D3D11VA\n<64> \n<65> if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {\n<66> \n<67> D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;\n<68> \n<69> memset(dsc11, 0, sizeof(*dsc11));\n<70> \n<71> dsc11->BufferType           = type;\n<72> \n<73> dsc11->DataSize             = size;\n<74> \n<75> dsc11->NumMBsInBuffer       = mb_count;\n<76> \n<77> }\n<78> \n<79> #endif\n<80> \n<81> #if CONFIG_DXVA2\n<82> \n<83> if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {\n<84> \n<85> DXVA2_DecodeBufferDesc *dsc2 = dsc;\n<86> \n<87> memset(dsc2, 0, sizeof(*dsc2));\n<88> \n<89> dsc2->CompressedBufferType = type;\n<90> \n<91> dsc2->DataSize             = size;\n<92> \n<93> dsc2->NumMBsInBuffer       = mb_count;\n<94> \n<95> }\n<96> \n<97> #endif\n<98> \n<99> \n<100> \n<101> result = 0;\n<102> \n<103> } else {\n<104> \n<105> av_log(avctx, AV_LOG_ERROR, "Buffer for type %u was too small\n", type);\n<106> \n<107> result = -1;\n<108> \n<109> }\n<110> \n<111> \n<112> \n<113> #if CONFIG_D3D11VA\n<114> \n<115> if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n<116> \n<117> hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context, D3D11VA_CONTEXT(ctx)->decoder, type);\n<118> \n<119> #endif\n<120> \n<121> #if CONFIG_DXVA2\n<122> \n<123> if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n<124> \n<125> hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);\n<126> \n<127> #endif\n<128> \n<129> if (FAILED(hr)) {\n<130> \n<131> av_log(avctx, AV_LOG_ERROR,\n<132> \n<133> "Failed to release buffer type %u: 0x%x\n",\n<134> \n<135> type, hr);\n<136> \n<137> result = -1;\n<138> \n<139> }\n<140> \n<141> return result;\n<142> \n<143> }\n<144> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)\n<2> \n<3> {\n<4> \n<5> VirtIOBlock *s;\n<6> \n<7> int cylinders, heads, secs;\n<8> \n<9> static int virtio_blk_id;\n<10> \n<11> DriveInfo *dinfo;\n<12> \n<13> \n<14> \n<15> if (!blk->conf.bs) {\n<16> \n<17> error_report("drive property not set");\n<18> \n<19> return NULL;\n<20> \n<21> }\n<22> \n<23> if (!bdrv_is_inserted(blk->conf.bs)) {\n<24> \n<25> error_report("Device needs media, but drive is empty");\n<26> \n<27> return NULL;\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> if (!blk->serial) {\n<34> \n<35> /* try to fall back to value set with legacy -drive serial=... */\n<36> \n<37> dinfo = drive_get_by_blockdev(blk->conf.bs);\n<38> \n<39> if (*dinfo->serial) {\n<40> \n<41> blk->serial = strdup(dinfo->serial);\n<42> \n<43> }\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK,\n<50> \n<51> sizeof(struct virtio_blk_config),\n<52> \n<53> sizeof(VirtIOBlock));\n<54> \n<55> \n<56> \n<57> s->vdev.get_config = virtio_blk_update_config;\n<58> \n<59> s->vdev.get_features = virtio_blk_get_features;\n<60> \n<61> s->vdev.reset = virtio_blk_reset;\n<62> \n<63> s->bs = blk->conf.bs;\n<64> \n<65> s->conf = &blk->conf;\n<66> \n<67> s->blk = blk;\n<68> \n<69> s->rq = NULL;\n<70> \n<71> s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n<72> \n<73> bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n<74> \n<75> \n<76> \n<77> s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n<78> \n<79> \n<80> \n<81> qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n<82> \n<83> s->qdev = dev;\n<84> \n<85> register_savevm(dev, "virtio-blk", virtio_blk_id++, 2,\n<86> \n<87> virtio_blk_save, virtio_blk_load, s);\n<88> \n<89> bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n<90> \n<91> bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n<92> \n<93> \n<94> \n<95> bdrv_iostatus_enable(s->bs);\n<96> \n<97> add_boot_device_path(s->conf->bootindex, dev, "/disk@0,0");\n<98> \n<99> \n<100> \n<101> return &s->vdev;\n<102> \n<103> }\n<104> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n<2> \n<3> {\n<4> \n<5> int i, ret;\n<6> \n<7> Picture *pic;\n<8> \n<9> s->mb_skipped = 0;\n<10> \n<11> \n<12> \n<13> if (!ff_thread_can_start_frame(avctx)) {\n<14> \n<15> av_log(avctx, AV_LOG_ERROR, "Attempt to start a frame outside SETUP state\n");\n<16> \n<17> return -1;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> /* mark & release old frames */\n<24> \n<25> if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&\n<26> \n<27> s->last_picture_ptr != s->next_picture_ptr &&\n<28> \n<29> s->last_picture_ptr->f.buf[0]) {\n<30> \n<31> ff_mpeg_unref_picture(s, s->last_picture_ptr);\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> /* release forgotten pictures */\n<38> \n<39> /* if (mpeg124/h263) */\n<40> \n<41> for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n<42> \n<43> if (&s->picture[i] != s->last_picture_ptr &&\n<44> \n<45> &s->picture[i] != s->next_picture_ptr &&\n<46> \n<47> s->picture[i].reference && !s->picture[i].needs_realloc) {\n<48> \n<49> if (!(avctx->active_thread_type & FF_THREAD_FRAME))\n<50> \n<51> av_log(avctx, AV_LOG_ERROR,\n<52> \n<53> "releasing zombie picture\n");\n<54> \n<55> ff_mpeg_unref_picture(s, &s->picture[i]);\n<56> \n<57> }\n<58> \n<59> }\n<60> \n<61> \n<62> \n<63> ff_mpeg_unref_picture(s, &s->current_picture);\n<64> \n<65> \n<66> \n<67> release_unused_pictures(s);\n<68> \n<69> \n<70> \n<71> if (s->current_picture_ptr &&\n<72> \n<73> s->current_picture_ptr->f.buf[0] == NULL) {\n<74> \n<75> // we already have a unused image\n<76> \n<77> // (maybe it was set before reading the header)\n<78> \n<79> pic = s->current_picture_ptr;\n<80> \n<81> } else {\n<82> \n<83> i   = ff_find_unused_picture(s, 0);\n<84> \n<85> if (i < 0) {\n<86> \n<87> av_log(s->avctx, AV_LOG_ERROR, "no frame buffer available\n");\n<88> \n<89> return i;\n<90> \n<91> }\n<92> \n<93> pic = &s->picture[i];\n<94> \n<95> }\n<96> \n<97> \n<98> \n<99> pic->reference = 0;\n<100> \n<101> if (!s->droppable) {\n<102> \n<103> if (s->pict_type != AV_PICTURE_TYPE_B)\n<104> \n<105> pic->reference = 3;\n<106> \n<107> }\n<108> \n<109> \n<110> \n<111> pic->f.coded_picture_number = s->coded_picture_number++;\n<112> \n<113> \n<114> \n<115> if (ff_alloc_picture(s, pic, 0) < 0)\n<116> \n<117> return -1;\n<118> \n<119> \n<120> \n<121> s->current_picture_ptr = pic;\n<122> \n<123> // FIXME use only the vars from current_pic\n<124> \n<125> s->current_picture_ptr->f.top_field_first = s->top_field_first;\n<126> \n<127> if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||\n<128> \n<129> s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n<130> \n<131> if (s->picture_structure != PICT_FRAME)\n<132> \n<133> s->current_picture_ptr->f.top_field_first =\n<134> \n<135> (s->picture_structure == PICT_TOP_FIELD) == s->first_field;\n<136> \n<137> }\n<138> \n<139> s->current_picture_ptr->f.interlaced_frame = !s->progressive_frame &&\n<140> \n<141> !s->progressive_sequence;\n<142> \n<143> s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;\n<144> \n<145> \n<146> \n<147> s->current_picture_ptr->f.pict_type = s->pict_type;\n<148> \n<149> // if (s->flags && CODEC_FLAG_QSCALE)\n<150> \n<151> //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;\n<152> \n<153> s->current_picture_ptr->f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n<154> \n<155> \n<156> \n<157> if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,\n<158> \n<159> s->current_picture_ptr)) < 0)\n<160> \n<161> return ret;\n<162> \n<163> \n<164> \n<165> if (s->pict_type != AV_PICTURE_TYPE_B) {\n<166> \n<167> s->last_picture_ptr = s->next_picture_ptr;\n<168> \n<169> if (!s->droppable)\n<170> \n<171> s->next_picture_ptr = s->current_picture_ptr;\n<172> \n<173> }\n<174> \n<175> av_dlog(s->avctx, "L%p N%p C%p L%p N%p C%p type:%d drop:%d\n",\n<176> \n<177> s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,\n<178> \n<179> s->last_picture_ptr    ? s->last_picture_ptr->f.data[0]    : NULL,\n<180> \n<181> s->next_picture_ptr    ? s->next_picture_ptr->f.data[0]    : NULL,\n<182> \n<183> s->current_picture_ptr ? s->current_picture_ptr->f.data[0] : NULL,\n<184> \n<185> s->pict_type, s->droppable);\n<186> \n<187> \n<188> \n<189> if ((s->last_picture_ptr == NULL ||\n<190> \n<191> s->last_picture_ptr->f.buf[0] == NULL) &&\n<192> \n<193> (s->pict_type != AV_PICTURE_TYPE_I ||\n<194> \n<195> s->picture_structure != PICT_FRAME)) {\n<196> \n<197> int h_chroma_shift, v_chroma_shift;\n<198> \n<199> av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n<200> \n<201> &h_chroma_shift, &v_chroma_shift);\n<202> \n<203> if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f.buf[0])\n<204> \n<205> av_log(avctx, AV_LOG_DEBUG,\n<206> \n<207> "allocating dummy last picture for B frame\n");\n<208> \n<209> else if (s->pict_type != AV_PICTURE_TYPE_I)\n<210> \n<211> av_log(avctx, AV_LOG_ERROR,\n<212> \n<213> "warning: first frame is no keyframe\n");\n<214> \n<215> else if (s->picture_structure != PICT_FRAME)\n<216> \n<217> av_log(avctx, AV_LOG_DEBUG,\n<218> \n<219> "allocate dummy last picture for field based first keyframe\n");\n<220> \n<221> \n<222> \n<223> /* Allocate a dummy frame */\n<224> \n<225> i = ff_find_unused_picture(s, 0);\n<226> \n<227> if (i < 0) {\n<228> \n<229> av_log(s->avctx, AV_LOG_ERROR, "no frame buffer available\n");\n<230> \n<231> return i;\n<232> \n<233> }\n<234> \n<235> s->last_picture_ptr = &s->picture[i];\n<236> \n<237> \n<238> \n<239> s->last_picture_ptr->reference   = 3;\n<240> \n<241> s->last_picture_ptr->f.key_frame = 0;\n<242> \n<243> s->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n<244> \n<245> \n<246> \n<247> if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n<248> \n<249> s->last_picture_ptr = NULL;\n<250> \n<251> return -1;\n<252> \n<253> }\n<254> \n<255> \n<256> \n<257> memset(s->last_picture_ptr->f.data[0], 0x80,\n<258> \n<259> avctx->height * s->last_picture_ptr->f.linesize[0]);\n<260> \n<261> memset(s->last_picture_ptr->f.data[1], 0x80,\n<262> \n<263> (avctx->height >> v_chroma_shift) *\n<264> \n<265> s->last_picture_ptr->f.linesize[1]);\n<266> \n<267> memset(s->last_picture_ptr->f.data[2], 0x80,\n<268> \n<269> (avctx->height >> v_chroma_shift) *\n<270> \n<271> s->last_picture_ptr->f.linesize[2]);\n<272> \n<273> \n<274> \n<275> if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){\n<276> \n<277> for(i=0; i<avctx->height; i++)\n<278> \n<279> memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);\n<280> \n<281> }\n<282> \n<283> \n<284> \n<285> ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);\n<286> \n<287> ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);\n<288> \n<289> }\n<290> \n<291> if ((s->next_picture_ptr == NULL ||\n<292> \n<293> s->next_picture_ptr->f.buf[0] == NULL) &&\n<294> \n<295> s->pict_type == AV_PICTURE_TYPE_B) {\n<296> \n<297> /* Allocate a dummy frame */\n<298> \n<299> i = ff_find_unused_picture(s, 0);\n<300> \n<301> if (i < 0) {\n<302> \n<303> av_log(s->avctx, AV_LOG_ERROR, "no frame buffer available\n");\n<304> \n<305> return i;\n<306> \n<307> }\n<308> \n<309> s->next_picture_ptr = &s->picture[i];\n<310> \n<311> \n<312> \n<313> s->next_picture_ptr->reference   = 3;\n<314> \n<315> s->next_picture_ptr->f.key_frame = 0;\n<316> \n<317> s->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n<318> \n<319> \n<320> \n<321> if (ff_alloc_picture(s, s->next_picture_ptr, 0) < 0) {\n<322> \n<323> s->next_picture_ptr = NULL;\n<324> \n<325> return -1;\n<326> \n<327> }\n<328> \n<329> ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);\n<330> \n<331> ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);\n<332> \n<333> }\n<334> \n<335> \n<336> \n<337> #if 0 // BUFREF-FIXME\n<338> \n<339> memset(s->last_picture.f.data, 0, sizeof(s->last_picture.f.data));\n<340> \n<341> memset(s->next_picture.f.data, 0, sizeof(s->next_picture.f.data));\n<342> \n<343> #endif\n<344> \n<345> if (s->last_picture_ptr) {\n<346> \n<347> ff_mpeg_unref_picture(s, &s->last_picture);\n<348> \n<349> if (s->last_picture_ptr->f.buf[0] &&\n<350> \n<351> (ret = ff_mpeg_ref_picture(s, &s->last_picture,\n<352> \n<353> s->last_picture_ptr)) < 0)\n<354> \n<355> return ret;\n<356> \n<357> }\n<358> \n<359> if (s->next_picture_ptr) {\n<360> \n<361> ff_mpeg_unref_picture(s, &s->next_picture);\n<362> \n<363> if (s->next_picture_ptr->f.buf[0] &&\n<364> \n<365> (ret = ff_mpeg_ref_picture(s, &s->next_picture,\n<366> \n<367> s->next_picture_ptr)) < 0)\n<368> \n<369> return ret;\n<370> \n<371> }\n<372> \n<373> \n<374> \n<375> av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n<376> \n<377> s->last_picture_ptr->f.buf[0]));\n<378> \n<379> \n<380> \n<381> if (s->picture_structure!= PICT_FRAME) {\n<382> \n<383> int i;\n<384> \n<385> for (i = 0; i < 4; i++) {\n<386> \n<387> if (s->picture_structure == PICT_BOTTOM_FIELD) {\n<388> \n<389> s->current_picture.f.data[i] +=\n<390> \n<391> s->current_picture.f.linesize[i];\n<392> \n<393> }\n<394> \n<395> s->current_picture.f.linesize[i] *= 2;\n<396> \n<397> s->last_picture.f.linesize[i]    *= 2;\n<398> \n<399> s->next_picture.f.linesize[i]    *= 2;\n<400> \n<401> }\n<402> \n<403> }\n<404> \n<405> \n<406> \n<407> s->err_recognition = avctx->err_recognition;\n<408> \n<409> \n<410> \n<411> /* set dequantizer, we can't do it during init as\n<412> \n<413> * it might change for mpeg4 and we can't do it in the header\n<414> \n<415> * decode as init is not called for mpeg4 there yet */\n<416> \n<417> if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n<418> \n<419> s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n<420> \n<421> s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n<422> \n<423> } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n<424> \n<425> s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n<426> \n<427> s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n<428> \n<429> } else {\n<430> \n<431> s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n<432> \n<433> s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n<434> \n<435> }\n<436> \n<437> \n<438> \n<439> return 0;\n<440> \n<441> }\n<442> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int spapr_phb_init(SysBusDevice *s)\n<2> \n<3> {\n<4> \n<5> sPAPRPHBState *sphb = SPAPR_PCI_HOST_BRIDGE(s);\n<6> \n<7> PCIHostState *phb = PCI_HOST_BRIDGE(s);\n<8> \n<9> char *namebuf;\n<10> \n<11> int i;\n<12> \n<13> PCIBus *bus;\n<14> \n<15> \n<16> \n<17> sphb->dtbusname = g_strdup_printf("pci@%" PRIx64, sphb->buid);\n<18> \n<19> namebuf = alloca(strlen(sphb->dtbusname) + 32);\n<20> \n<21> \n<22> \n<23> /* Initialize memory regions */\n<24> \n<25> sprintf(namebuf, "%s.mmio", sphb->dtbusname);\n<26> \n<27> memory_region_init(&sphb->memspace, namebuf, INT64_MAX);\n<28> \n<29> \n<30> \n<31> sprintf(namebuf, "%s.mmio-alias", sphb->dtbusname);\n<32> \n<33> memory_region_init_alias(&sphb->memwindow, namebuf, &sphb->memspace,\n<34> \n<35> SPAPR_PCI_MEM_WIN_BUS_OFFSET, sphb->mem_win_size);\n<36> \n<37> memory_region_add_subregion(get_system_memory(), sphb->mem_win_addr,\n<38> \n<39> &sphb->memwindow);\n<40> \n<41> \n<42> \n<43> /* On ppc, we only have MMIO no specific IO space from the CPU\n<44> \n<45> * perspective.  In theory we ought to be able to embed the PCI IO\n<46> \n<47> * memory region direction in the system memory space.  However,\n<48> \n<49> * if any of the IO BAR subregions use the old_portio mechanism,\n<50> \n<51> * that won't be processed properly unless accessed from the\n<52> \n<53> * system io address space.  This hack to bounce things via\n<54> \n<55> * system_io works around the problem until all the users of\n<56> \n<57> * old_portion are updated */\n<58> \n<59> sprintf(namebuf, "%s.io", sphb->dtbusname);\n<60> \n<61> memory_region_init(&sphb->iospace, namebuf, SPAPR_PCI_IO_WIN_SIZE);\n<62> \n<63> /* FIXME: fix to support multiple PHBs */\n<64> \n<65> memory_region_add_subregion(get_system_io(), 0, &sphb->iospace);\n<66> \n<67> \n<68> \n<69> sprintf(namebuf, "%s.io-alias", sphb->dtbusname);\n<70> \n<71> memory_region_init_io(&sphb->iowindow, &spapr_io_ops, sphb,\n<72> \n<73> namebuf, SPAPR_PCI_IO_WIN_SIZE);\n<74> \n<75> memory_region_add_subregion(get_system_memory(), sphb->io_win_addr,\n<76> \n<77> &sphb->iowindow);\n<78> \n<79> \n<80> \n<81> /* As MSI/MSIX interrupts trigger by writing at MSI/MSIX vectors,\n<82> \n<83> * we need to allocate some memory to catch those writes coming\n<84> \n<85> * from msi_notify()/msix_notify() */\n<86> \n<87> if (msi_supported) {\n<88> \n<89> sprintf(namebuf, "%s.msi", sphb->dtbusname);\n<90> \n<91> memory_region_init_io(&sphb->msiwindow, &spapr_msi_ops, sphb,\n<92> \n<93> namebuf, SPAPR_MSIX_MAX_DEVS * 0x10000);\n<94> \n<95> memory_region_add_subregion(get_system_memory(), sphb->msi_win_addr,\n<96> \n<97> &sphb->msiwindow);\n<98> \n<99> }\n<100> \n<101> \n<102> \n<103> bus = pci_register_bus(DEVICE(s),\n<104> \n<105> sphb->busname ? sphb->busname : sphb->dtbusname,\n<106> \n<107> pci_spapr_set_irq, pci_spapr_map_irq, sphb,\n<108> \n<109> &sphb->memspace, &sphb->iospace,\n<110> \n<111> PCI_DEVFN(0, 0), PCI_NUM_PINS);\n<112> \n<113> phb->bus = bus;\n<114> \n<115> \n<116> \n<117> sphb->dma_liobn = SPAPR_PCI_BASE_LIOBN | (pci_find_domain(bus) << 16);\n<118> \n<119> sphb->dma_window_start = 0;\n<120> \n<121> sphb->dma_window_size = 0x40000000;\n<122> \n<123> sphb->dma = spapr_tce_new_dma_context(sphb->dma_liobn, sphb->dma_window_size);\n<124> \n<125> pci_setup_iommu(bus, spapr_pci_dma_context_fn, sphb);\n<126> \n<127> \n<128> \n<129> QLIST_INSERT_HEAD(&spapr->phbs, sphb, list);\n<130> \n<131> \n<132> \n<133> /* Initialize the LSI table */\n<134> \n<135> for (i = 0; i < PCI_NUM_PINS; i++) {\n<136> \n<137> uint32_t irq;\n<138> \n<139> \n<140> \n<141> irq = spapr_allocate_lsi(0);\n<142> \n<143> if (!irq) {\n<144> \n<145> return -1;\n<146> \n<147> }\n<148> \n<149> \n<150> \n<151> sphb->lsi_table[i].irq = irq;\n<152> \n<153> }\n<154> \n<155> \n<156> \n<157> return 0;\n<158> \n<159> }\n<160> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int smacker_read_packet(AVFormatContext *s, AVPacket *pkt)\n<2> \n<3> {\n<4> \n<5> SmackerContext *smk = s->priv_data;\n<6> \n<7> int flags;\n<8> \n<9> int ret;\n<10> \n<11> int i;\n<12> \n<13> int frame_size = 0;\n<14> \n<15> int palchange = 0;\n<16> \n<17> \n<18> \n<19> if (s->pb->eof_reached || smk->cur_frame >= smk->frames)\n<20> \n<21> return AVERROR_EOF;\n<22> \n<23> \n<24> \n<25> /* if we demuxed all streams, pass another frame */\n<26> \n<27> if(smk->curstream < 0) {\n<28> \n<29> avio_seek(s->pb, smk->nextpos, 0);\n<30> \n<31> frame_size = smk->frm_size[smk->cur_frame] & (~3);\n<32> \n<33> flags = smk->frm_flags[smk->cur_frame];\n<34> \n<35> /* handle palette change event */\n<36> \n<37> if(flags & SMACKER_PAL){\n<38> \n<39> int size, sz, t, off, j, pos;\n<40> \n<41> uint8_t *pal = smk->pal;\n<42> \n<43> uint8_t oldpal[768];\n<44> \n<45> \n<46> \n<47> memcpy(oldpal, pal, 768);\n<48> \n<49> size = avio_r8(s->pb);\n<50> \n<51> size = size * 4 - 1;\n<52> \n<53> frame_size -= size;\n<54> \n<55> frame_size--;\n<56> \n<57> sz = 0;\n<58> \n<59> pos = avio_tell(s->pb) + size;\n<60> \n<61> while(sz < 256){\n<62> \n<63> t = avio_r8(s->pb);\n<64> \n<65> if(t & 0x80){ /* skip palette entries */\n<66> \n<67> sz += (t & 0x7F) + 1;\n<68> \n<69> pal += ((t & 0x7F) + 1) * 3;\n<70> \n<71> } else if(t & 0x40){ /* copy with offset */\n<72> \n<73> off = avio_r8(s->pb);\n<74> \n<75> j = (t & 0x3F) + 1;\n<76> \n<77> if (off + j > 0x100) {\n<78> \n<79> av_log(s, AV_LOG_ERROR,\n<80> \n<81> "Invalid palette update, offset=%d length=%d extends beyond palette size\n",\n<82> \n<83> off, j);\n<84> \n<85> return AVERROR_INVALIDDATA;\n<86> \n<87> }\n<88> \n<89> off *= 3;\n<90> \n<91> while(j-- && sz < 256) {\n<92> \n<93> *pal++ = oldpal[off + 0];\n<94> \n<95> *pal++ = oldpal[off + 1];\n<96> \n<97> *pal++ = oldpal[off + 2];\n<98> \n<99> sz++;\n<100> \n<101> off += 3;\n<102> \n<103> }\n<104> \n<105> } else { /* new entries */\n<106> \n<107> *pal++ = smk_pal[t];\n<108> \n<109> *pal++ = smk_pal[avio_r8(s->pb) & 0x3F];\n<110> \n<111> *pal++ = smk_pal[avio_r8(s->pb) & 0x3F];\n<112> \n<113> sz++;\n<114> \n<115> }\n<116> \n<117> }\n<118> \n<119> avio_seek(s->pb, pos, 0);\n<120> \n<121> palchange |= 1;\n<122> \n<123> }\n<124> \n<125> flags >>= 1;\n<126> \n<127> smk->curstream = -1;\n<128> \n<129> /* if audio chunks are present, put them to stack and retrieve later */\n<130> \n<131> for(i = 0; i < 7; i++) {\n<132> \n<133> if(flags & 1) {\n<134> \n<135> int size;\n<136> \n<137> uint8_t *tmpbuf;\n<138> \n<139> \n<140> \n<141> size = avio_rl32(s->pb) - 4;\n<142> \n<143> frame_size -= size;\n<144> \n<145> frame_size -= 4;\n<146> \n<147> smk->curstream++;\n<148> \n<149> tmpbuf = av_realloc(smk->bufs[smk->curstream], size);\n<150> \n<151> if (!tmpbuf)\n<152> \n<153> return AVERROR(ENOMEM);\n<154> \n<155> smk->bufs[smk->curstream] = tmpbuf;\n<156> \n<157> smk->buf_sizes[smk->curstream] = size;\n<158> \n<159> ret = avio_read(s->pb, smk->bufs[smk->curstream], size);\n<160> \n<161> if(ret != size)\n<162> \n<163> return AVERROR(EIO);\n<164> \n<165> smk->stream_id[smk->curstream] = smk->indexes[i];\n<166> \n<167> }\n<168> \n<169> flags >>= 1;\n<170> \n<171> }\n<172> \n<173> if (frame_size < 0)\n<174> \n<175> return AVERROR_INVALIDDATA;\n<176> \n<177> if (av_new_packet(pkt, frame_size + 769))\n<178> \n<179> return AVERROR(ENOMEM);\n<180> \n<181> if(smk->frm_size[smk->cur_frame] & 1)\n<182> \n<183> palchange |= 2;\n<184> \n<185> pkt->data[0] = palchange;\n<186> \n<187> memcpy(pkt->data + 1, smk->pal, 768);\n<188> \n<189> ret = avio_read(s->pb, pkt->data + 769, frame_size);\n<190> \n<191> if(ret != frame_size)\n<192> \n<193> return AVERROR(EIO);\n<194> \n<195> pkt->stream_index = smk->videoindex;\n<196> \n<197> pkt->pts          = smk->cur_frame;\n<198> \n<199> pkt->size = ret + 769;\n<200> \n<201> smk->cur_frame++;\n<202> \n<203> smk->nextpos = avio_tell(s->pb);\n<204> \n<205> } else {\n<206> \n<207> if (av_new_packet(pkt, smk->buf_sizes[smk->curstream]))\n<208> \n<209> return AVERROR(ENOMEM);\n<210> \n<211> memcpy(pkt->data, smk->bufs[smk->curstream], smk->buf_sizes[smk->curstream]);\n<212> \n<213> pkt->size = smk->buf_sizes[smk->curstream];\n<214> \n<215> pkt->stream_index = smk->stream_id[smk->curstream];\n<216> \n<217> pkt->pts = smk->aud_pts[smk->curstream];\n<218> \n<219> smk->aud_pts[smk->curstream] += AV_RL32(pkt->data);\n<220> \n<221> smk->curstream--;\n<222> \n<223> }\n<224> \n<225> \n<226> \n<227> return 0;\n<228> \n<229> }\n<230> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static unsigned int dec_move_rs(DisasContext *dc)\n<2> \n<3> {\n<4> \n<5> DIS(fprintf (logfile, "move $r%u, $s%u\n", dc->op1, dc->op2));\n<6> \n<7> cris_cc_mask(dc, 0);\n<8> \n<9> tcg_gen_helper_0_2(helper_movl_sreg_reg,\n<10> \n<11> tcg_const_tl(dc->op2), tcg_const_tl(dc->op1));\n<12> \n<13> return 2;\n<14> \n<15> }\n<16> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void end_frame(AVFilterLink *link)\n<2> \n<3> {\n<4> \n<5> DeshakeContext *deshake = link->dst->priv;\n<6> \n<7> AVFilterBufferRef *in  = link->cur_buf;\n<8> \n<9> AVFilterBufferRef *out = link->dst->outputs[0]->out_buf;\n<10> \n<11> Transform t;\n<12> \n<13> float matrix[9];\n<14> \n<15> float alpha = 2.0 / deshake->refcount;\n<16> \n<17> char tmp[256];\n<18> \n<19> Transform orig;\n<20> \n<21> \n<22> \n<23> if (deshake->cx < 0 || deshake->cy < 0 || deshake->cw < 0 || deshake->ch < 0) {\n<24> \n<25> // Find the most likely global motion for the current frame\n<26> \n<27> find_motion(deshake, (deshake->ref == NULL) ? in->data[0] : deshake->ref->data[0], in->data[0], link->w, link->h, in->linesize[0], &t);\n<28> \n<29> } else {\n<30> \n<31> uint8_t *src1 = (deshake->ref == NULL) ? in->data[0] : deshake->ref->data[0];\n<32> \n<33> uint8_t *src2 = in->data[0];\n<34> \n<35> \n<36> \n<37> deshake->cx = FFMIN(deshake->cx, link->w);\n<38> \n<39> deshake->cy = FFMIN(deshake->cy, link->h);\n<40> \n<41> \n<42> \n<43> if ((unsigned)deshake->cx + (unsigned)deshake->cw > link->w) deshake->cw = link->w - deshake->cx;\n<44> \n<45> if ((unsigned)deshake->cy + (unsigned)deshake->ch > link->h) deshake->ch = link->h - deshake->cy;\n<46> \n<47> \n<48> \n<49> // Quadword align right margin\n<50> \n<51> deshake->cw &= ~15;\n<52> \n<53> \n<54> \n<55> src1 += deshake->cy * in->linesize[0] + deshake->cx;\n<56> \n<57> src2 += deshake->cy * in->linesize[0] + deshake->cx;\n<58> \n<59> \n<60> \n<61> find_motion(deshake, src1, src2, deshake->cw, deshake->ch, in->linesize[0], &t);\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> \n<68> \n<69> // Copy transform so we can output it later to compare to the smoothed value\n<70> \n<71> orig.vector.x = t.vector.x;\n<72> \n<73> orig.vector.y = t.vector.y;\n<74> \n<75> orig.angle = t.angle;\n<76> \n<77> orig.zoom = t.zoom;\n<78> \n<79> \n<80> \n<81> // Generate a one-sided moving exponential average\n<82> \n<83> deshake->avg.vector.x = alpha * t.vector.x + (1.0 - alpha) * deshake->avg.vector.x;\n<84> \n<85> deshake->avg.vector.y = alpha * t.vector.y + (1.0 - alpha) * deshake->avg.vector.y;\n<86> \n<87> deshake->avg.angle = alpha * t.angle + (1.0 - alpha) * deshake->avg.angle;\n<88> \n<89> deshake->avg.zoom = alpha * t.zoom + (1.0 - alpha) * deshake->avg.zoom;\n<90> \n<91> \n<92> \n<93> // Remove the average from the current motion to detect the motion that\n<94> \n<95> // is not on purpose, just as jitter from bumping the camera\n<96> \n<97> t.vector.x -= deshake->avg.vector.x;\n<98> \n<99> t.vector.y -= deshake->avg.vector.y;\n<100> \n<101> t.angle -= deshake->avg.angle;\n<102> \n<103> t.zoom -= deshake->avg.zoom;\n<104> \n<105> \n<106> \n<107> // Invert the motion to undo it\n<108> \n<109> t.vector.x *= -1;\n<110> \n<111> t.vector.y *= -1;\n<112> \n<113> t.angle *= -1;\n<114> \n<115> \n<116> \n<117> // Write statistics to file\n<118> \n<119> if (deshake->fp) {\n<120> \n<121> snprintf(tmp, 256, "%f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f\n", orig.vector.x, deshake->avg.vector.x, t.vector.x, orig.vector.y, deshake->avg.vector.y, t.vector.y, orig.angle, deshake->avg.angle, t.angle, orig.zoom, deshake->avg.zoom, t.zoom);\n<122> \n<123> fwrite(tmp, sizeof(char), strlen(tmp), deshake->fp);\n<124> \n<125> }\n<126> \n<127> \n<128> \n<129> // Turn relative current frame motion into absolute by adding it to the\n<130> \n<131> // last absolute motion\n<132> \n<133> t.vector.x += deshake->last.vector.x;\n<134> \n<135> t.vector.y += deshake->last.vector.y;\n<136> \n<137> t.angle += deshake->last.angle;\n<138> \n<139> t.zoom += deshake->last.zoom;\n<140> \n<141> \n<142> \n<143> // Shrink motion by 10% to keep things centered in the camera frame\n<144> \n<145> t.vector.x *= 0.9;\n<146> \n<147> t.vector.y *= 0.9;\n<148> \n<149> t.angle *= 0.9;\n<150> \n<151> \n<152> \n<153> // Store the last absolute motion information\n<154> \n<155> deshake->last.vector.x = t.vector.x;\n<156> \n<157> deshake->last.vector.y = t.vector.y;\n<158> \n<159> deshake->last.angle = t.angle;\n<160> \n<161> deshake->last.zoom = t.zoom;\n<162> \n<163> \n<164> \n<165> // Generate a luma transformation matrix\n<166> \n<167> avfilter_get_matrix(t.vector.x, t.vector.y, t.angle, 1.0 + t.zoom / 100.0, matrix);\n<168> \n<169> \n<170> \n<171> // Transform the luma plane\n<172> \n<173> avfilter_transform(in->data[0], out->data[0], in->linesize[0], out->linesize[0], link->w, link->h, matrix, INTERPOLATE_BILINEAR, deshake->edge);\n<174> \n<175> \n<176> \n<177> // Generate a chroma transformation matrix\n<178> \n<179> avfilter_get_matrix(t.vector.x / (link->w / CHROMA_WIDTH(link)), t.vector.y / (link->h / CHROMA_HEIGHT(link)), t.angle, 1.0 + t.zoom / 100.0, matrix);\n<180> \n<181> \n<182> \n<183> // Transform the chroma planes\n<184> \n<185> avfilter_transform(in->data[1], out->data[1], in->linesize[1], out->linesize[1], CHROMA_WIDTH(link), CHROMA_HEIGHT(link), matrix, INTERPOLATE_BILINEAR, deshake->edge);\n<186> \n<187> avfilter_transform(in->data[2], out->data[2], in->linesize[2], out->linesize[2], CHROMA_WIDTH(link), CHROMA_HEIGHT(link), matrix, INTERPOLATE_BILINEAR, deshake->edge);\n<188> \n<189> \n<190> \n<191> // Store the current frame as the reference frame for calculating the\n<192> \n<193> // motion of the next frame\n<194> \n<195> if (deshake->ref != NULL)\n<196> \n<197> avfilter_unref_buffer(deshake->ref);\n<198> \n<199> \n<200> \n<201> // Cleanup the old reference frame\n<202> \n<203> deshake->ref = in;\n<204> \n<205> \n<206> \n<207> // Draw the transformed frame information\n<208> \n<209> avfilter_draw_slice(link->dst->outputs[0], 0, link->h, 1);\n<210> \n<211> avfilter_end_frame(link->dst->outputs[0]);\n<212> \n<213> avfilter_unref_buffer(out);\n<214> \n<215> }\n<216> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void netfilter_set_status(Object *obj, const char *str, Error **errp)\n<2> \n<3> {\n<4> \n<5> NetFilterState *nf = NETFILTER(obj);\n<6> \n<7> NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n<8> \n<9> \n<10> \n<11> if (strcmp(str, "on") && strcmp(str, "off")) {\n<12> \n<13> error_setg(errp, "Invalid value for netfilter status, "\n<14> \n<15> "should be 'on' or 'off'");\n<16> \n<17> return;\n<18> \n<19> }\n<20> \n<21> if (nf->on == !strcmp(str, "on")) {\n<22> \n<23> return;\n<24> \n<25> }\n<26> \n<27> nf->on = !nf->on;\n<28> \n<29> if (nfc->status_changed) {\n<30> \n<31> nfc->status_changed(nf, errp);\n<32> \n<33> }\n<34> \n<35> }\n<36> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int css_register_io_adapter(CssIoAdapterType type, uint8_t isc, bool swap,\n<2> \n<3> bool maskable, uint32_t *id)\n<4> \n<5> {\n<6> \n<7> IoAdapter *adapter;\n<8> \n<9> bool found = false;\n<10> \n<11> int ret;\n<12> \n<13> S390FLICState *fs = s390_get_flic();\n<14> \n<15> S390FLICStateClass *fsc = S390_FLIC_COMMON_GET_CLASS(fs);\n<16> \n<17> \n<18> \n<19> *id = 0;\n<20> \n<21> QTAILQ_FOREACH(adapter, &channel_subsys.io_adapters, sibling) {\n<22> \n<23> if ((adapter->type == type) && (adapter->isc == isc)) {\n<24> \n<25> *id = adapter->id;\n<26> \n<27> found = true;\n<28> \n<29> ret = 0;\n<30> \n<31> break;\n<32> \n<33> }\n<34> \n<35> if (adapter->id >= *id) {\n<36> \n<37> *id = adapter->id + 1;\n<38> \n<39> }\n<40> \n<41> }\n<42> \n<43> if (found) {\n<44> \n<45> goto out;\n<46> \n<47> }\n<48> \n<49> adapter = g_new0(IoAdapter, 1);\n<50> \n<51> ret = fsc->register_io_adapter(fs, *id, isc, swap, maskable);\n<52> \n<53> if (ret == 0) {\n<54> \n<55> adapter->id = *id;\n<56> \n<57> adapter->isc = isc;\n<58> \n<59> adapter->type = type;\n<60> \n<61> QTAILQ_INSERT_TAIL(&channel_subsys.io_adapters, adapter, sibling);\n<62> \n<63> } else {\n<64> \n<65> g_free(adapter);\n<66> \n<67> fprintf(stderr, "Unexpected error %d when registering adapter %d\n",\n<68> \n<69> ret, *id);\n<70> \n<71> }\n<72> \n<73> out:\n<74> \n<75> return ret;\n<76> \n<77> }\n<78> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void *circular_buffer_task( void *_URLContext)\n<2> \n<3> {\n<4> \n<5> URLContext *h = _URLContext;\n<6> \n<7> UDPContext *s = h->priv_data;\n<8> \n<9> int old_cancelstate;\n<10> \n<11> \n<12> \n<13> pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_cancelstate);\n<14> \n<15> ff_socket_nonblock(s->udp_fd, 0);\n<16> \n<17> while(1) {\n<18> \n<19> int left;\n<20> \n<21> int len;\n<22> \n<23> \n<24> \n<25> /* How much do we have left to the end of the buffer */\n<26> \n<27> /* Whats the minimum we can read so that we dont comletely fill the buffer */\n<28> \n<29> left = av_fifo_space(s->fifo);\n<30> \n<31> \n<32> \n<33> /* Blocking operations are always cancellation points;\n<34> \n<35> see "General Information" / "Thread Cancelation Overview"\n<36> \n<37> in Single Unix. */\n<38> \n<39> pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &old_cancelstate);\n<40> \n<41> len = recv(s->udp_fd, s->tmp+4, sizeof(s->tmp)-4, 0);\n<42> \n<43> pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &old_cancelstate);\n<44> \n<45> if (len < 0) {\n<46> \n<47> if (ff_neterrno() != AVERROR(EAGAIN) && ff_neterrno() != AVERROR(EINTR)) {\n<48> \n<49> s->circular_buffer_error = AVERROR(EIO);\n<50> \n<51> goto end;\n<52> \n<53> }\n<54> \n<55> continue;\n<56> \n<57> }\n<58> \n<59> AV_WL32(s->tmp, len);\n<60> \n<61> if(left < len + 4) {\n<62> \n<63> /* No Space left */\n<64> \n<65> if (s->overrun_nonfatal) {\n<66> \n<67> av_log(h, AV_LOG_WARNING, "Circular buffer overrun. "\n<68> \n<69> "Surviving due to overrun_nonfatal option\n");\n<70> \n<71> continue;\n<72> \n<73> } else {\n<74> \n<75> av_log(h, AV_LOG_ERROR, "Circular buffer overrun. "\n<76> \n<77> "To avoid, increase fifo_size URL option. "\n<78> \n<79> "To survive in such case, use overrun_nonfatal option\n");\n<80> \n<81> s->circular_buffer_error = AVERROR(EIO);\n<82> \n<83> goto end;\n<84> \n<85> }\n<86> \n<87> }\n<88> \n<89> pthread_mutex_lock(&s->mutex);\n<90> \n<91> av_fifo_generic_write(s->fifo, s->tmp, len+4, NULL);\n<92> \n<93> pthread_cond_signal(&s->cond);\n<94> \n<95> pthread_mutex_unlock(&s->mutex);\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> end:\n<102> \n<103> pthread_mutex_lock(&s->mutex);\n<104> \n<105> pthread_cond_signal(&s->cond);\n<106> \n<107> pthread_mutex_unlock(&s->mutex);\n<108> \n<109> return NULL;\n<110> \n<111> }\n<112> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int get_sot(Jpeg2000DecoderContext *s, int n)\n<2> \n<3> {\n<4> \n<5> Jpeg2000TilePart *tp;\n<6> \n<7> uint16_t Isot;\n<8> \n<9> uint32_t Psot;\n<10> \n<11> uint8_t TPsot;\n<12> \n<13> \n<14> \n<15> if (bytestream2_get_bytes_left(&s->g) < 8)\n<16> \n<17> return AVERROR_INVALIDDATA;\n<18> \n<19> \n<20> \n<21> s->curtileno = 0;\n<22> \n<23> Isot = bytestream2_get_be16u(&s->g);        // Isot\n<24> \n<25> if (Isot >= s->numXtiles * s->numYtiles)\n<26> \n<27> return AVERROR_INVALIDDATA;\n<28> \n<29> \n<30> \n<31> s->curtileno = Isot;\n<32> \n<33> Psot  = bytestream2_get_be32u(&s->g);       // Psot\n<34> \n<35> TPsot = bytestream2_get_byteu(&s->g);       // TPsot\n<36> \n<37> \n<38> \n<39> /* Read TNSot but not used */\n<40> \n<41> bytestream2_get_byteu(&s->g);               // TNsot\n<42> \n<43> \n<44> \n<45> if (!Psot)\n<46> \n<47> Psot = bytestream2_get_bytes_left(&s->g) + n + 2;\n<48> \n<49> \n<50> \n<51> if (Psot > bytestream2_get_bytes_left(&s->g) + n + 2) {\n<52> \n<53> av_log(s->avctx, AV_LOG_ERROR, "Psot %"PRIu32" too big\n", Psot);\n<54> \n<55> return AVERROR_INVALIDDATA;\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> if (TPsot >= FF_ARRAY_ELEMS(s->tile[Isot].tile_part)) {\n<62> \n<63> avpriv_request_sample(s->avctx, "Support for %"PRIu8" components", TPsot);\n<64> \n<65> return AVERROR_PATCHWELCOME;\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> s->tile[Isot].tp_idx = TPsot;\n<72> \n<73> tp             = s->tile[Isot].tile_part + TPsot;\n<74> \n<75> tp->tile_index = Isot;\n<76> \n<77> tp->tp_end     = s->g.buffer + Psot - n - 2;\n<78> \n<79> \n<80> \n<81> if (!TPsot) {\n<82> \n<83> Jpeg2000Tile *tile = s->tile + s->curtileno;\n<84> \n<85> \n<86> \n<87> /* copy defaults */\n<88> \n<89> memcpy(tile->codsty, s->codsty, s->ncomponents * sizeof(Jpeg2000CodingStyle));\n<90> \n<91> memcpy(tile->qntsty, s->qntsty, s->ncomponents * sizeof(Jpeg2000QuantStyle));\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> return 0;\n<98> \n<99> }\n<100> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int avfilter_parse_graph(AVFilterGraph *graph, const char *filters,\n<2> \n<3> AVFilterInOut *open_inputs,\n<4> \n<5> AVFilterInOut *open_outputs, AVClass *log_ctx)\n<6> \n<7> {\n<8> \n<9> int index = 0;\n<10> \n<11> char chr = 0;\n<12> \n<13> \n<14> \n<15> AVFilterInOut *curr_inputs = NULL;\n<16> \n<17> \n<18> \n<19> do {\n<20> \n<21> AVFilterContext *filter;\n<22> \n<23> filters += consume_whitespace(filters);\n<24> \n<25> \n<26> \n<27> if(parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx) < 0)\n<28> \n<29> goto fail;\n<30> \n<31> \n<32> \n<33> filter = parse_filter(&filters, graph, index, log_ctx);\n<34> \n<35> \n<36> \n<37> if(!filter)\n<38> \n<39> goto fail;\n<40> \n<41> \n<42> \n<43> if(filter->input_count == 1 && !curr_inputs && !index) {\n<44> \n<45> /* First input can be omitted if it is "[in]" */\n<46> \n<47> const char *tmp = "[in]";\n<48> \n<49> if(parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx) < 0)\n<50> \n<51> goto fail;\n<52> \n<53> }\n<54> \n<55> \n<56> \n<57> if(link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx) < 0)\n<58> \n<59> goto fail;\n<60> \n<61> \n<62> \n<63> if(parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n<64> \n<65> log_ctx) < 0)\n<66> \n<67> goto fail;\n<68> \n<69> \n<70> \n<71> filters += consume_whitespace(filters);\n<72> \n<73> chr = *filters++;\n<74> \n<75> \n<76> \n<77> if(chr == ';' && curr_inputs) {\n<78> \n<79> av_log(log_ctx, AV_LOG_ERROR,\n<80> \n<81> "Could not find a output to link when parsing \"%s\"\n",\n<82> \n<83> filters - 1);\n<84> \n<85> goto fail;\n<86> \n<87> }\n<88> \n<89> index++;\n<90> \n<91> } while(chr == ',' || chr == ';');\n<92> \n<93> \n<94> \n<95> if (*filters) {\n<96> \n<97> av_log(log_ctx, AV_LOG_ERROR,\n<98> \n<99> "Unable to parse graph description substring: \"%s\"\n",\n<100> \n<101> filters - 1);\n<102> \n<103> goto fail;\n<104> \n<105> }\n<106> \n<107> \n<108> \n<109> if(open_inputs && !strcmp(open_inputs->name, "out") && curr_inputs) {\n<110> \n<111> /* Last output can be omitted if it is "[out]" */\n<112> \n<113> const char *tmp = "[out]";\n<114> \n<115> if(parse_outputs(&tmp, &curr_inputs, &open_inputs,\n<116> \n<117> &open_outputs, log_ctx) < 0)\n<118> \n<119> goto fail;\n<120> \n<121> }\n<122> \n<123> \n<124> \n<125> return 0;\n<126> \n<127> \n<128> \n<129> fail:\n<130> \n<131> avfilter_destroy_graph(graph);\n<132> \n<133> free_inout(open_inputs);\n<134> \n<135> free_inout(open_outputs);\n<136> \n<137> free_inout(curr_inputs);\n<138> \n<139> return -1;\n<140> \n<141> }\n<142> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> MKSCALE16(scale16be, AV_RB16, AV_WB16)\n<2> \n<3> MKSCALE16(scale16le, AV_RL16, AV_WL16)\n<4> \n<5> \n<6> \n<7> static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,\n<8> \n<9> AVPacket *avpkt)\n<10> \n<11> {\n<12> \n<13> const AVPixFmtDescriptor *desc;\n<14> \n<15> RawVideoContext *context       = avctx->priv_data;\n<16> \n<17> const uint8_t *buf             = avpkt->data;\n<18> \n<19> int buf_size                   = avpkt->size;\n<20> \n<21> int linesize_align             = 4;\n<22> \n<23> int stride;\n<24> \n<25> int res, len;\n<26> \n<27> int need_copy;\n<28> \n<29> \n<30> \n<31> AVFrame   *frame   = data;\n<32> \n<33> \n<34> \n<35> if (avctx->width <= 0) {\n<36> \n<37> av_log(avctx, AV_LOG_ERROR, "width is not set\n");\n<38> \n<39> return AVERROR_INVALIDDATA;\n<40> \n<41> }\n<42> \n<43> if (avctx->height <= 0) {\n<44> \n<45> av_log(avctx, AV_LOG_ERROR, "height is not set\n");\n<46> \n<47> return AVERROR_INVALIDDATA;\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> if (context->is_nut_mono)\n<54> \n<55> stride = avctx->width / 8 + (avctx->width & 7 ? 1 : 0);\n<56> \n<57> else if (context->is_nut_pal8)\n<58> \n<59> stride = avctx->width;\n<60> \n<61> else\n<62> \n<63> stride = avpkt->size / avctx->height;\n<64> \n<65> \n<66> \n<67> av_log(avctx, AV_LOG_DEBUG, "PACKET SIZE: %d, STRIDE: %d\n", avpkt->size, stride);\n<68> \n<69> \n<70> \n<71> if (stride == 0 || avpkt->size < stride * avctx->height) {\n<72> \n<73> av_log(avctx, AV_LOG_ERROR, "Packet too small (%d)\n", avpkt->size);\n<74> \n<75> return AVERROR_INVALIDDATA;\n<76> \n<77> }\n<78> \n<79> \n<80> \n<81> desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n<82> \n<83> \n<84> \n<85> if ((avctx->bits_per_coded_sample == 8 || avctx->bits_per_coded_sample == 4 ||\n<86> \n<87> avctx->bits_per_coded_sample == 2 || avctx->bits_per_coded_sample == 1 ||\n<88> \n<89> (avctx->bits_per_coded_sample == 0 && (context->is_nut_pal8 || context->is_mono)) ) &&\n<90> \n<91> (context->is_mono || context->is_pal8) &&\n<92> \n<93> (!avctx->codec_tag || avctx->codec_tag == MKTAG('r','a','w',' ') ||\n<94> \n<95> context->is_nut_mono || context->is_nut_pal8)) {\n<96> \n<97> context->is_1_2_4_8_bpp = 1;\n<98> \n<99> if (context->is_mono) {\n<100> \n<101> int row_bytes = avctx->width / 8 + (avctx->width & 7 ? 1 : 0);\n<102> \n<103> context->frame_size = av_image_get_buffer_size(avctx->pix_fmt,\n<104> \n<105> FFALIGN(row_bytes, 16) * 8,\n<106> \n<107> avctx->height, 1);\n<108> \n<109> } else\n<110> \n<111> context->frame_size = av_image_get_buffer_size(avctx->pix_fmt,\n<112> \n<113> FFALIGN(avctx->width, 16),\n<114> \n<115> avctx->height, 1);\n<116> \n<117> } else {\n<118> \n<119> context->is_lt_16bpp = av_get_bits_per_pixel(desc) == 16 && avctx->bits_per_coded_sample && avctx->bits_per_coded_sample < 16;\n<120> \n<121> context->frame_size = av_image_get_buffer_size(avctx->pix_fmt, avctx->width,\n<122> \n<123> avctx->height, 1);\n<124> \n<125> }\n<126> \n<127> if (context->frame_size < 0)\n<128> \n<129> return context->frame_size;\n<130> \n<131> \n<132> \n<133> need_copy = !avpkt->buf || context->is_1_2_4_8_bpp || context->is_yuv2 || context->is_lt_16bpp;\n<134> \n<135> \n<136> \n<137> frame->pict_type        = AV_PICTURE_TYPE_I;\n<138> \n<139> frame->key_frame        = 1;\n<140> \n<141> \n<142> \n<143> res = ff_decode_frame_props(avctx, frame);\n<144> \n<145> if (res < 0)\n<146> \n<147> return res;\n<148> \n<149> \n<150> \n<151> av_frame_set_pkt_pos     (frame, avctx->internal->pkt->pos);\n<152> \n<153> av_frame_set_pkt_duration(frame, avctx->internal->pkt->duration);\n<154> \n<155> \n<156> \n<157> if (context->tff >= 0) {\n<158> \n<159> frame->interlaced_frame = 1;\n<160> \n<161> frame->top_field_first  = context->tff;\n<162> \n<163> }\n<164> \n<165> \n<166> \n<167> if ((res = av_image_check_size(avctx->width, avctx->height, 0, avctx)) < 0)\n<168> \n<169> return res;\n<170> \n<171> \n<172> \n<173> if (need_copy)\n<174> \n<175> frame->buf[0] = av_buffer_alloc(FFMAX(context->frame_size, buf_size));\n<176> \n<177> else\n<178> \n<179> frame->buf[0] = av_buffer_ref(avpkt->buf);\n<180> \n<181> if (!frame->buf[0])\n<182> \n<183> return AVERROR(ENOMEM);\n<184> \n<185> \n<186> \n<187> // 1, 2, 4 and 8 bpp in avi/mov, 1 and 8 bpp in nut\n<188> \n<189> if (context->is_1_2_4_8_bpp) {\n<190> \n<191> int i, j, row_pix = 0;\n<192> \n<193> uint8_t *dst = frame->buf[0]->data;\n<194> \n<195> buf_size = context->frame_size - (context->is_pal8 ? AVPALETTE_SIZE : 0);\n<196> \n<197> if (avctx->bits_per_coded_sample == 8 || context->is_nut_pal8 || context->is_mono) {\n<198> \n<199> int pix_per_byte = context->is_mono ? 8 : 1;\n<200> \n<201> for (i = 0, j = 0; j < buf_size && i<avpkt->size; i++, j++) {\n<202> \n<203> dst[j] = buf[i];\n<204> \n<205> row_pix += pix_per_byte;\n<206> \n<207> if (row_pix >= avctx->width) {\n<208> \n<209> i += stride - (i % stride) - 1;\n<210> \n<211> j += 16 - (j % 16) - 1;\n<212> \n<213> row_pix = 0;\n<214> \n<215> }\n<216> \n<217> }\n<218> \n<219> } else if (avctx->bits_per_coded_sample == 4) {\n<220> \n<221> for (i = 0, j = 0; 2 * j + 1 < buf_size && i<avpkt->size; i++, j++) {\n<222> \n<223> dst[2 * j + 0] = buf[i] >> 4;\n<224> \n<225> dst[2 * j + 1] = buf[i] & 15;\n<226> \n<227> row_pix += 2;\n<228> \n<229> if (row_pix >= avctx->width) {\n<230> \n<231> i += stride - (i % stride) - 1;\n<232> \n<233> j += 8 - (j % 8) - 1;\n<234> \n<235> row_pix = 0;\n<236> \n<237> }\n<238> \n<239> }\n<240> \n<241> } else if (avctx->bits_per_coded_sample == 2) {\n<242> \n<243> for (i = 0, j = 0; 4 * j + 3 < buf_size && i<avpkt->size; i++, j++) {\n<244> \n<245> dst[4 * j + 0] = buf[i] >> 6;\n<246> \n<247> dst[4 * j + 1] = buf[i] >> 4 & 3;\n<248> \n<249> dst[4 * j + 2] = buf[i] >> 2 & 3;\n<250> \n<251> dst[4 * j + 3] = buf[i]      & 3;\n<252> \n<253> row_pix += 4;\n<254> \n<255> if (row_pix >= avctx->width) {\n<256> \n<257> i += stride - (i % stride) - 1;\n<258> \n<259> j += 4 - (j % 4) - 1;\n<260> \n<261> row_pix = 0;\n<262> \n<263> }\n<264> \n<265> }\n<266> \n<267> } else {\n<268> \n<269> av_assert0(avctx->bits_per_coded_sample == 1);\n<270> \n<271> for (i = 0, j = 0; 8 * j + 7 < buf_size && i<avpkt->size; i++, j++) {\n<272> \n<273> dst[8 * j + 0] = buf[i] >> 7;\n<274> \n<275> dst[8 * j + 1] = buf[i] >> 6 & 1;\n<276> \n<277> dst[8 * j + 2] = buf[i] >> 5 & 1;\n<278> \n<279> dst[8 * j + 3] = buf[i] >> 4 & 1;\n<280> \n<281> dst[8 * j + 4] = buf[i] >> 3 & 1;\n<282> \n<283> dst[8 * j + 5] = buf[i] >> 2 & 1;\n<284> \n<285> dst[8 * j + 6] = buf[i] >> 1 & 1;\n<286> \n<287> dst[8 * j + 7] = buf[i]      & 1;\n<288> \n<289> row_pix += 8;\n<290> \n<291> if (row_pix >= avctx->width) {\n<292> \n<293> i += stride - (i % stride) - 1;\n<294> \n<295> j += 2 - (j % 2) - 1;\n<296> \n<297> row_pix = 0;\n<298> \n<299> }\n<300> \n<301> }\n<302> \n<303> }\n<304> \n<305> linesize_align = 16;\n<306> \n<307> buf = dst;\n<308> \n<309> } else if (context->is_lt_16bpp) {\n<310> \n<311> uint8_t *dst = frame->buf[0]->data;\n<312> \n<313> int packed = (avctx->codec_tag & 0xFFFFFF) == MKTAG('B','I','T', 0);\n<314> \n<315> int swap   =  avctx->codec_tag >> 24;\n<316> \n<317> \n<318> \n<319> if (packed && swap) {\n<320> \n<321> av_fast_padded_malloc(&context->bitstream_buf, &context->bitstream_buf_size, buf_size);\n<322> \n<323> if (!context->bitstream_buf)\n<324> \n<325> return AVERROR(ENOMEM);\n<326> \n<327> if (swap == 16)\n<328> \n<329> context->bbdsp.bswap16_buf(context->bitstream_buf, (const uint16_t*)buf, buf_size / 2);\n<330> \n<331> else if (swap == 32)\n<332> \n<333> context->bbdsp.bswap_buf(context->bitstream_buf, (const uint32_t*)buf, buf_size / 4);\n<334> \n<335> else\n<336> \n<337> return AVERROR_INVALIDDATA;\n<338> \n<339> buf = context->bitstream_buf;\n<340> \n<341> }\n<342> \n<343> \n<344> \n<345> if (desc->flags & AV_PIX_FMT_FLAG_BE)\n<346> \n<347> scale16be(avctx, dst, buf, buf_size, packed);\n<348> \n<349> else\n<350> \n<351> scale16le(avctx, dst, buf, buf_size, packed);\n<352> \n<353> \n<354> \n<355> buf = dst;\n<356> \n<357> } else if (need_copy) {\n<358> \n<359> memcpy(frame->buf[0]->data, buf, buf_size);\n<360> \n<361> buf = frame->buf[0]->data;\n<362> \n<363> }\n<364> \n<365> \n<366> \n<367> if (avctx->codec_tag == MKTAG('A', 'V', '1', 'x') ||\n<368> \n<369> avctx->codec_tag == MKTAG('A', 'V', 'u', 'p'))\n<370> \n<371> buf += buf_size - context->frame_size;\n<372> \n<373> \n<374> \n<375> len = context->frame_size - (avctx->pix_fmt==AV_PIX_FMT_PAL8 ? AVPALETTE_SIZE : 0);\n<376> \n<377> if (buf_size < len && ((avctx->codec_tag & 0xFFFFFF) != MKTAG('B','I','T', 0) || !need_copy)) {\n<378> \n<379> av_log(avctx, AV_LOG_ERROR, "Invalid buffer size, packet size %d < expected frame_size %d\n", buf_size, len);\n<380> \n<381> av_buffer_unref(&frame->buf[0]);\n<382> \n<383> return AVERROR(EINVAL);\n<384> \n<385> }\n<386> \n<387> \n<388> \n<389> if ((res = av_image_fill_arrays(frame->data, frame->linesize,\n<390> \n<391> buf, avctx->pix_fmt,\n<392> \n<393> avctx->width, avctx->height, 1)) < 0) {\n<394> \n<395> av_buffer_unref(&frame->buf[0]);\n<396> \n<397> return res;\n<398> \n<399> }\n<400> \n<401> \n<402> \n<403> if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n<404> \n<405> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE,\n<406> \n<407> NULL);\n<408> \n<409> int ret;\n<410> \n<411> if (!context->palette)\n<412> \n<413> context->palette = av_buffer_alloc(AVPALETTE_SIZE);\n<414> \n<415> if (!context->palette) {\n<416> \n<417> av_buffer_unref(&frame->buf[0]);\n<418> \n<419> return AVERROR(ENOMEM);\n<420> \n<421> }\n<422> \n<423> ret = av_buffer_make_writable(&context->palette);\n<424> \n<425> if (ret < 0) {\n<426> \n<427> av_buffer_unref(&frame->buf[0]);\n<428> \n<429> return ret;\n<430> \n<431> }\n<432> \n<433> \n<434> \n<435> if (pal) {\n<436> \n<437> memcpy(context->palette->data, pal, AVPALETTE_SIZE);\n<438> \n<439> frame->palette_has_changed = 1;\n<440> \n<441> } else if (context->is_nut_pal8) {\n<442> \n<443> int vid_size = avctx->width * avctx->height;\n<444> \n<445> int pal_size = avpkt->size - vid_size;\n<446> \n<447> \n<448> \n<449> if (avpkt->size > vid_size && pal_size <= AVPALETTE_SIZE) {\n<450> \n<451> pal = avpkt->data + vid_size;\n<452> \n<453> memcpy(context->palette->data, pal, pal_size);\n<454> \n<455> frame->palette_has_changed = 1;\n<456> \n<457> }\n<458> \n<459> }\n<460> \n<461> }\n<462> \n<463> \n<464> \n<465> if ((avctx->pix_fmt==AV_PIX_FMT_RGB24    ||\n<466> \n<467> avctx->pix_fmt==AV_PIX_FMT_BGR24     ||\n<468> \n<469> avctx->pix_fmt==AV_PIX_FMT_GRAY8     ||\n<470> \n<471> avctx->pix_fmt==AV_PIX_FMT_RGB555LE  ||\n<472> \n<473> avctx->pix_fmt==AV_PIX_FMT_RGB555BE  ||\n<474> \n<475> avctx->pix_fmt==AV_PIX_FMT_RGB565LE  ||\n<476> \n<477> avctx->pix_fmt==AV_PIX_FMT_MONOWHITE ||\n<478> \n<479> avctx->pix_fmt==AV_PIX_FMT_MONOBLACK ||\n<480> \n<481> avctx->pix_fmt==AV_PIX_FMT_PAL8) &&\n<482> \n<483> FFALIGN(frame->linesize[0], linesize_align) * avctx->height <= buf_size)\n<484> \n<485> frame->linesize[0] = FFALIGN(frame->linesize[0], linesize_align);\n<486> \n<487> \n<488> \n<489> if (avctx->pix_fmt == AV_PIX_FMT_NV12 && avctx->codec_tag == MKTAG('N', 'V', '1', '2') &&\n<490> \n<491> FFALIGN(frame->linesize[0], linesize_align) * avctx->height +\n<492> \n<493> FFALIGN(frame->linesize[1], linesize_align) * ((avctx->height + 1) / 2) <= buf_size) {\n<494> \n<495> int la0 = FFALIGN(frame->linesize[0], linesize_align);\n<496> \n<497> frame->data[1] += (la0 - frame->linesize[0]) * avctx->height;\n<498> \n<499> frame->linesize[0] = la0;\n<500> \n<501> frame->linesize[1] = FFALIGN(frame->linesize[1], linesize_align);\n<502> \n<503> }\n<504> \n<505> \n<506> \n<507> if ((avctx->pix_fmt == AV_PIX_FMT_PAL8 && buf_size < context->frame_size) ||\n<508> \n<509> (desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)) {\n<510> \n<511> frame->buf[1]  = av_buffer_ref(context->palette);\n<512> \n<513> if (!frame->buf[1]) {\n<514> \n<515> av_buffer_unref(&frame->buf[0]);\n<516> \n<517> return AVERROR(ENOMEM);\n<518> \n<519> }\n<520> \n<521> frame->data[1] = frame->buf[1]->data;\n<522> \n<523> }\n<524> \n<525> \n<526> \n<527> if (avctx->pix_fmt == AV_PIX_FMT_BGR24 &&\n<528> \n<529> ((frame->linesize[0] + 3) & ~3) * avctx->height <= buf_size)\n<530> \n<531> frame->linesize[0] = (frame->linesize[0] + 3) & ~3;\n<532> \n<533> \n<534> \n<535> if (context->flip)\n<536> \n<537> flip(avctx, frame);\n<538> \n<539> \n<540> \n<541> if (avctx->codec_tag == MKTAG('Y', 'V', '1', '2') ||\n<542> \n<543> avctx->codec_tag == MKTAG('Y', 'V', '1', '6') ||\n<544> \n<545> avctx->codec_tag == MKTAG('Y', 'V', '2', '4') ||\n<546> \n<547> avctx->codec_tag == MKTAG('Y', 'V', 'U', '9'))\n<548> \n<549> FFSWAP(uint8_t *, frame->data[1], frame->data[2]);\n<550> \n<551> \n<552> \n<553> if (avctx->codec_tag == AV_RL32("I420") && (avctx->width+1)*(avctx->height+1) * 3/2 == buf_size) {\n<554> \n<555> frame->data[1] = frame->data[1] +  (avctx->width+1)*(avctx->height+1) -avctx->width*avctx->height;\n<556> \n<557> frame->data[2] = frame->data[2] + ((avctx->width+1)*(avctx->height+1) -avctx->width*avctx->height)*5/4;\n<558> \n<559> }\n<560> \n<561> \n<562> \n<563> if (avctx->codec_tag == AV_RL32("yuv2") &&\n<564> \n<565> avctx->pix_fmt   == AV_PIX_FMT_YUYV422) {\n<566> \n<567> int x, y;\n<568> \n<569> uint8_t *line = frame->data[0];\n<570> \n<571> for (y = 0; y < avctx->height; y++) {\n<572> \n<573> for (x = 0; x < avctx->width; x++)\n<574> \n<575> line[2 * x + 1] ^= 0x80;\n<576> \n<577> line += frame->linesize[0];\n<578> \n<579> }\n<580> \n<581> }\n<582> \n<583> \n<584> \n<585> if (avctx->codec_tag == AV_RL32("b64a") &&\n<586> \n<587> avctx->pix_fmt   == AV_PIX_FMT_RGBA64BE) {\n<588> \n<589> uint8_t *dst = frame->data[0];\n<590> \n<591> uint64_t v;\n<592> \n<593> int x;\n<594> \n<595> for (x = 0; x >> 3 < avctx->width * avctx->height; x += 8) {\n<596> \n<597> v = AV_RB64(&dst[x]);\n<598> \n<599> AV_WB64(&dst[x], v << 16 | v >> 48);\n<600> \n<601> }\n<602> \n<603> }\n<604> \n<605> \n<606> \n<607> if (avctx->field_order > AV_FIELD_PROGRESSIVE) { /* we have interlaced material flagged in container */\n<608> \n<609> frame->interlaced_frame = 1;\n<610> \n<611> if (avctx->field_order == AV_FIELD_TT || avctx->field_order == AV_FIELD_TB)\n<612> \n<613> frame->top_field_first = 1;\n<614> \n<615> }\n<616> \n<617> \n<618> \n<619> *got_frame = 1;\n<620> \n<621> return buf_size;\n<622> \n<623> }\n<624> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> PGconn * GetConnection ( void ) {\n<2> PGconn * tmpconn ;\n<3> int argcount = 7 ;\n<4> int i ;\n<5> const char * * keywords ;\n<6> const char * * values ;\n<7> const char * tmpparam ;\n<8> bool need_password ;\n<9> PQconninfoOption * conn_opts = NULL ;\n<10> PQconninfoOption * conn_opt ;\n<11> char * err_msg = NULL ;\n<12> i = 0 ;\n<13> if ( connection_string ) {\n<14> conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n<15> if ( conn_opts == NULL ) {\n<16> fprintf ( stderr , "%s: %s" , progname , err_msg ) ;\n<17> exit ( 1 ) ;\n<18> }\n<19> for ( conn_opt = conn_opts ;\n<20> conn_opt -> keyword != NULL ;\n<21> conn_opt ++ ) {\n<22> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) argcount ++ ;\n<23> }\n<24> keywords = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * keywords ) ) ;\n<25> values = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * values ) ) ;\n<26> for ( conn_opt = conn_opts ;\n<27> conn_opt -> keyword != NULL ;\n<28> conn_opt ++ ) {\n<29> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' ) {\n<30> keywords [ i ] = conn_opt -> keyword ;\n<31> values [ i ] = conn_opt -> val ;\n<32> i ++ ;\n<33> }\n<34> }\n<35> }\n<36> else {\n<37> keywords = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * keywords ) ) ;\n<38> values = pg_malloc0 ( ( argcount + 1 ) * sizeof ( * values ) ) ;\n<39> }\n<40> keywords [ i ] = "dbname" ;\n<41> values [ i ] = dbname == NULL ? "replication" : dbname ;\n<42> i ++ ;\n<43> keywords [ i ] = "replication" ;\n<44> values [ i ] = dbname == NULL ? "true" : "database" ;\n<45> i ++ ;\n<46> keywords [ i ] = "fallback_application_name" ;\n<47> values [ i ] = progname ;\n<48> i ++ ;\n<49> if ( dbhost ) {\n<50> keywords [ i ] = "host" ;\n<51> values [ i ] = dbhost ;\n<52> i ++ ;\n<53> }\n<54> if ( dbuser ) {\n<55> keywords [ i ] = "user" ;\n<56> values [ i ] = dbuser ;\n<57> i ++ ;\n<58> }\n<59> if ( dbport ) {\n<60> keywords [ i ] = "port" ;\n<61> values [ i ] = dbport ;\n<62> i ++ ;\n<63> }\n<64> need_password = ( dbgetpassword == 1 && dbpassword == NULL ) ;\n<65> do {\n<66> if ( need_password ) {\n<67> if ( dbpassword ) free ( dbpassword ) ;\n<68> dbpassword = simple_prompt ( _ ( "Password: " ) , 100 , false ) ;\n<69> need_password = false ;\n<70> }\n<71> if ( dbpassword ) {\n<72> keywords [ i ] = "password" ;\n<73> values [ i ] = dbpassword ;\n<74> }\n<75> else {\n<76> keywords [ i ] = NULL ;\n<77> values [ i ] = NULL ;\n<78> }\n<79> tmpconn = PQconnectdbParams ( keywords , values , true ) ;\n<80> if ( ! tmpconn ) {\n<81> fprintf ( stderr , _ ( "%s: could not connect to server\n" ) , progname ) ;\n<82> exit ( 1 ) ;\n<83> }\n<84> if ( PQstatus ( tmpconn ) == CONNECTION_BAD && PQconnectionNeedsPassword ( tmpconn ) && dbgetpassword != - 1 ) {\n<85> PQfinish ( tmpconn ) ;\n<86> need_password = true ;\n<87> }\n<88> }\n<89> while ( need_password ) ;\n<90> if ( PQstatus ( tmpconn ) != CONNECTION_OK ) {\n<91> fprintf ( stderr , _ ( "%s: could not connect to server: %s" ) , progname , PQerrorMessage ( tmpconn ) ) ;\n<92> PQfinish ( tmpconn ) ;\n<93> free ( values ) ;\n<94> free ( keywords ) ;\n<95> if ( conn_opts ) PQconninfoFree ( conn_opts ) ;\n<96> return NULL ;\n<97> }\n<98> free ( values ) ;\n<99> free ( keywords ) ;\n<100> if ( conn_opts ) PQconninfoFree ( conn_opts ) ;\n<101> tmpparam = PQparameterStatus ( tmpconn , "integer_datetimes" ) ;\n<102> if ( ! tmpparam ) {\n<103> fprintf ( stderr , _ ( "%s: could not determine server setting for integer_datetimes\n" ) , progname ) ;\n<104> PQfinish ( tmpconn ) ;\n<105> exit ( 1 ) ;\n<106> }\n<107> # ifdef HAVE_INT64_TIMESTAMP if ( strcmp ( tmpparam , "on" ) != 0 ) # else if ( strcmp ( tmpparam , "off" ) != 0 ) # endif {\n<108> fprintf ( stderr , _ ( "%s: integer_datetimes compile flag does not match server\n" ) , progname ) ;\n<109> PQfinish ( tmpconn ) ;\n<110> exit ( 1 ) ;\n<111> }\n<112> return tmpconn ;\n<113> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ass_split(ASSSplitContext *ctx, const char *buf)\n<2> \n<3> {\n<4> \n<5> char c, section[16];\n<6> \n<7> int i;\n<8> \n<9> \n<10> \n<11> if (ctx->current_section >= 0)\n<12> \n<13> buf = ass_split_section(ctx, buf);\n<14> \n<15> \n<16> \n<17> while (buf && *buf) {\n<18> \n<19> if (sscanf(buf, "[%15[0-9A-Za-z+ ]]%c", section, &c) == 2) {\n<20> \n<21> buf += strcspn(buf, "\n") + 1;\n<22> \n<23> for (i=0; i<FF_ARRAY_ELEMS(ass_sections); i++)\n<24> \n<25> if (!strcmp(section, ass_sections[i].section)) {\n<26> \n<27> ctx->current_section = i;\n<28> \n<29> buf = ass_split_section(ctx, buf);\n<30> \n<31> }\n<32> \n<33> } else\n<34> \n<35> buf += strcspn(buf, "\n") + 1;\n<36> \n<37> }\n<38> \n<39> return buf ? 0 : AVERROR_INVALIDDATA;\n<40> \n<41> }\n<42> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mss2_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<2> \n<3> AVPacket *avpkt)\n<4> \n<5> {\n<6> \n<7> const uint8_t *buf = avpkt->data;\n<8> \n<9> int buf_size       = avpkt->size;\n<10> \n<11> MSS2Context *ctx = avctx->priv_data;\n<12> \n<13> MSS12Context *c  = &ctx->c;\n<14> \n<15> AVFrame *frame   = data;\n<16> \n<17> GetBitContext gb;\n<18> \n<19> GetByteContext gB;\n<20> \n<21> ArithCoder acoder;\n<22> \n<23> \n<24> \n<25> int keyframe, has_wmv9, has_mv, is_rle, is_555, ret;\n<26> \n<27> \n<28> \n<29> Rectangle wmv9rects[MAX_WMV9_RECTANGLES], *r;\n<30> \n<31> int used_rects = 0, i, implicit_rect = 0, av_uninit(wmv9_mask);\n<32> \n<33> \n<34> \n<35> if ((ret = init_get_bits8(&gb, buf, buf_size)) < 0)\n<36> \n<37> return ret;\n<38> \n<39> \n<40> \n<41> if (keyframe = get_bits1(&gb))\n<42> \n<43> skip_bits(&gb, 7);\n<44> \n<45> has_wmv9 = get_bits1(&gb);\n<46> \n<47> has_mv   = keyframe ? 0 : get_bits1(&gb);\n<48> \n<49> is_rle   = get_bits1(&gb);\n<50> \n<51> is_555   = is_rle && get_bits1(&gb);\n<52> \n<53> if (c->slice_split > 0)\n<54> \n<55> ctx->split_position = c->slice_split;\n<56> \n<57> else if (c->slice_split < 0) {\n<58> \n<59> if (get_bits1(&gb)) {\n<60> \n<61> if (get_bits1(&gb)) {\n<62> \n<63> if (get_bits1(&gb))\n<64> \n<65> ctx->split_position = get_bits(&gb, 16);\n<66> \n<67> else\n<68> \n<69> ctx->split_position = get_bits(&gb, 12);\n<70> \n<71> } else\n<72> \n<73> ctx->split_position = get_bits(&gb, 8) << 4;\n<74> \n<75> } else {\n<76> \n<77> if (keyframe)\n<78> \n<79> ctx->split_position = avctx->height / 2;\n<80> \n<81> }\n<82> \n<83> } else\n<84> \n<85> ctx->split_position = avctx->height;\n<86> \n<87> \n<88> \n<89> if (c->slice_split && (ctx->split_position < 1 - is_555 ||\n<90> \n<91> ctx->split_position > avctx->height - 1))\n<92> \n<93> return AVERROR_INVALIDDATA;\n<94> \n<95> \n<96> \n<97> align_get_bits(&gb);\n<98> \n<99> buf      += get_bits_count(&gb) >> 3;\n<100> \n<101> buf_size -= get_bits_count(&gb) >> 3;\n<102> \n<103> \n<104> \n<105> if (buf_size < 1)\n<106> \n<107> return AVERROR_INVALIDDATA;\n<108> \n<109> \n<110> \n<111> if (is_555 && (has_wmv9 || has_mv || c->slice_split && ctx->split_position))\n<112> \n<113> return AVERROR_INVALIDDATA;\n<114> \n<115> \n<116> \n<117> avctx->pix_fmt = is_555 ? AV_PIX_FMT_RGB555 : AV_PIX_FMT_RGB24;\n<118> \n<119> if (ctx->last_pic->format != avctx->pix_fmt)\n<120> \n<121> av_frame_unref(ctx->last_pic);\n<122> \n<123> \n<124> \n<125> if (has_wmv9) {\n<126> \n<127> bytestream2_init(&gB, buf, buf_size + ARITH2_PADDING);\n<128> \n<129> arith2_init(&acoder, &gB);\n<130> \n<131> \n<132> \n<133> implicit_rect = !arith2_get_bit(&acoder);\n<134> \n<135> \n<136> \n<137> while (arith2_get_bit(&acoder)) {\n<138> \n<139> if (used_rects == MAX_WMV9_RECTANGLES)\n<140> \n<141> return AVERROR_INVALIDDATA;\n<142> \n<143> r = &wmv9rects[used_rects];\n<144> \n<145> if (!used_rects)\n<146> \n<147> r->x = arith2_get_number(&acoder, avctx->width);\n<148> \n<149> else\n<150> \n<151> r->x = arith2_get_number(&acoder, avctx->width -\n<152> \n<153> wmv9rects[used_rects - 1].x) +\n<154> \n<155> wmv9rects[used_rects - 1].x;\n<156> \n<157> r->y = arith2_get_number(&acoder, avctx->height);\n<158> \n<159> r->w = arith2_get_number(&acoder, avctx->width  - r->x) + 1;\n<160> \n<161> r->h = arith2_get_number(&acoder, avctx->height - r->y) + 1;\n<162> \n<163> used_rects++;\n<164> \n<165> }\n<166> \n<167> \n<168> \n<169> if (implicit_rect && used_rects) {\n<170> \n<171> av_log(avctx, AV_LOG_ERROR, "implicit_rect && used_rects > 0\n");\n<172> \n<173> return AVERROR_INVALIDDATA;\n<174> \n<175> }\n<176> \n<177> \n<178> \n<179> if (implicit_rect) {\n<180> \n<181> wmv9rects[0].x = 0;\n<182> \n<183> wmv9rects[0].y = 0;\n<184> \n<185> wmv9rects[0].w = avctx->width;\n<186> \n<187> wmv9rects[0].h = avctx->height;\n<188> \n<189> \n<190> \n<191> used_rects = 1;\n<192> \n<193> }\n<194> \n<195> for (i = 0; i < used_rects; i++) {\n<196> \n<197> if (!implicit_rect && arith2_get_bit(&acoder)) {\n<198> \n<199> av_log(avctx, AV_LOG_ERROR, "Unexpected grandchildren\n");\n<200> \n<201> return AVERROR_INVALIDDATA;\n<202> \n<203> }\n<204> \n<205> if (!i) {\n<206> \n<207> wmv9_mask = arith2_get_bit(&acoder) - 1;\n<208> \n<209> if (!wmv9_mask)\n<210> \n<211> wmv9_mask = arith2_get_number(&acoder, 256);\n<212> \n<213> }\n<214> \n<215> wmv9rects[i].coded = arith2_get_number(&acoder, 2);\n<216> \n<217> }\n<218> \n<219> \n<220> \n<221> buf      += arith2_get_consumed_bytes(&acoder);\n<222> \n<223> buf_size -= arith2_get_consumed_bytes(&acoder);\n<224> \n<225> if (buf_size < 1)\n<226> \n<227> return AVERROR_INVALIDDATA;\n<228> \n<229> }\n<230> \n<231> \n<232> \n<233> c->mvX = c->mvY = 0;\n<234> \n<235> if (keyframe && !is_555) {\n<236> \n<237> if ((i = decode_pal_v2(c, buf, buf_size)) < 0)\n<238> \n<239> return AVERROR_INVALIDDATA;\n<240> \n<241> buf      += i;\n<242> \n<243> buf_size -= i;\n<244> \n<245> } else if (has_mv) {\n<246> \n<247> buf      += 4;\n<248> \n<249> buf_size -= 4;\n<250> \n<251> if (buf_size < 1)\n<252> \n<253> return AVERROR_INVALIDDATA;\n<254> \n<255> c->mvX = AV_RB16(buf - 4) - avctx->width;\n<256> \n<257> c->mvY = AV_RB16(buf - 2) - avctx->height;\n<258> \n<259> }\n<260> \n<261> \n<262> \n<263> if (c->mvX < 0 || c->mvY < 0) {\n<264> \n<265> FFSWAP(uint8_t *, c->pal_pic, c->last_pal_pic);\n<266> \n<267> \n<268> \n<269> if ((ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n<270> \n<271> return ret;\n<272> \n<273> \n<274> \n<275> if (ctx->last_pic->data[0]) {\n<276> \n<277> av_assert0(frame->linesize[0] == ctx->last_pic->linesize[0]);\n<278> \n<279> c->last_rgb_pic = ctx->last_pic->data[0] +\n<280> \n<281> ctx->last_pic->linesize[0] * (avctx->height - 1);\n<282> \n<283> } else {\n<284> \n<285> av_log(avctx, AV_LOG_ERROR, "Missing keyframe\n");\n<286> \n<287> return AVERROR_INVALIDDATA;\n<288> \n<289> }\n<290> \n<291> } else {\n<292> \n<293> if ((ret = ff_reget_buffer(avctx, ctx->last_pic)) < 0)\n<294> \n<295> return ret;\n<296> \n<297> if ((ret = av_frame_ref(frame, ctx->last_pic)) < 0)\n<298> \n<299> return ret;\n<300> \n<301> \n<302> \n<303> c->last_rgb_pic = NULL;\n<304> \n<305> }\n<306> \n<307> c->rgb_pic    = frame->data[0] +\n<308> \n<309> frame->linesize[0] * (avctx->height - 1);\n<310> \n<311> c->rgb_stride = -frame->linesize[0];\n<312> \n<313> \n<314> \n<315> frame->key_frame = keyframe;\n<316> \n<317> frame->pict_type = keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n<318> \n<319> \n<320> \n<321> if (is_555) {\n<322> \n<323> bytestream2_init(&gB, buf, buf_size);\n<324> \n<325> \n<326> \n<327> if (decode_555(&gB, (uint16_t *)c->rgb_pic, c->rgb_stride >> 1,\n<328> \n<329> keyframe, avctx->width, avctx->height))\n<330> \n<331> return AVERROR_INVALIDDATA;\n<332> \n<333> \n<334> \n<335> buf_size -= bytestream2_tell(&gB);\n<336> \n<337> } else {\n<338> \n<339> if (keyframe) {\n<340> \n<341> c->corrupted = 0;\n<342> \n<343> ff_mss12_slicecontext_reset(&ctx->sc[0]);\n<344> \n<345> if (c->slice_split)\n<346> \n<347> ff_mss12_slicecontext_reset(&ctx->sc[1]);\n<348> \n<349> }\n<350> \n<351> if (is_rle) {\n<352> \n<353> if ((ret = init_get_bits8(&gb, buf, buf_size)) < 0)\n<354> \n<355> return ret;\n<356> \n<357> if (ret = decode_rle(&gb, c->pal_pic, c->pal_stride,\n<358> \n<359> c->rgb_pic, c->rgb_stride, c->pal, keyframe,\n<360> \n<361> ctx->split_position, 0,\n<362> \n<363> avctx->width, avctx->height))\n<364> \n<365> return ret;\n<366> \n<367> align_get_bits(&gb);\n<368> \n<369> \n<370> \n<371> if (c->slice_split)\n<372> \n<373> if (ret = decode_rle(&gb, c->pal_pic, c->pal_stride,\n<374> \n<375> c->rgb_pic, c->rgb_stride, c->pal, keyframe,\n<376> \n<377> ctx->split_position, 1,\n<378> \n<379> avctx->width, avctx->height))\n<380> \n<381> return ret;\n<382> \n<383> \n<384> \n<385> align_get_bits(&gb);\n<386> \n<387> buf      += get_bits_count(&gb) >> 3;\n<388> \n<389> buf_size -= get_bits_count(&gb) >> 3;\n<390> \n<391> } else if (!implicit_rect || wmv9_mask != -1) {\n<392> \n<393> if (c->corrupted)\n<394> \n<395> return AVERROR_INVALIDDATA;\n<396> \n<397> bytestream2_init(&gB, buf, buf_size + ARITH2_PADDING);\n<398> \n<399> arith2_init(&acoder, &gB);\n<400> \n<401> c->keyframe = keyframe;\n<402> \n<403> if (c->corrupted = ff_mss12_decode_rect(&ctx->sc[0], &acoder, 0, 0,\n<404> \n<405> avctx->width,\n<406> \n<407> ctx->split_position))\n<408> \n<409> return AVERROR_INVALIDDATA;\n<410> \n<411> \n<412> \n<413> buf      += arith2_get_consumed_bytes(&acoder);\n<414> \n<415> buf_size -= arith2_get_consumed_bytes(&acoder);\n<416> \n<417> if (c->slice_split) {\n<418> \n<419> if (buf_size < 1)\n<420> \n<421> return AVERROR_INVALIDDATA;\n<422> \n<423> bytestream2_init(&gB, buf, buf_size + ARITH2_PADDING);\n<424> \n<425> arith2_init(&acoder, &gB);\n<426> \n<427> if (c->corrupted = ff_mss12_decode_rect(&ctx->sc[1], &acoder, 0,\n<428> \n<429> ctx->split_position,\n<430> \n<431> avctx->width,\n<432> \n<433> avctx->height - ctx->split_position))\n<434> \n<435> return AVERROR_INVALIDDATA;\n<436> \n<437> \n<438> \n<439> buf      += arith2_get_consumed_bytes(&acoder);\n<440> \n<441> buf_size -= arith2_get_consumed_bytes(&acoder);\n<442> \n<443> }\n<444> \n<445> } else\n<446> \n<447> memset(c->pal_pic, 0, c->pal_stride * avctx->height);\n<448> \n<449> }\n<450> \n<451> \n<452> \n<453> if (has_wmv9) {\n<454> \n<455> for (i = 0; i < used_rects; i++) {\n<456> \n<457> int x = wmv9rects[i].x;\n<458> \n<459> int y = wmv9rects[i].y;\n<460> \n<461> int w = wmv9rects[i].w;\n<462> \n<463> int h = wmv9rects[i].h;\n<464> \n<465> if (wmv9rects[i].coded) {\n<466> \n<467> int WMV9codedFrameSize;\n<468> \n<469> if (buf_size < 4 || !(WMV9codedFrameSize = AV_RL24(buf)))\n<470> \n<471> return AVERROR_INVALIDDATA;\n<472> \n<473> if (ret = decode_wmv9(avctx, buf + 3, buf_size - 3,\n<474> \n<475> x, y, w, h, wmv9_mask))\n<476> \n<477> return ret;\n<478> \n<479> buf      += WMV9codedFrameSize + 3;\n<480> \n<481> buf_size -= WMV9codedFrameSize + 3;\n<482> \n<483> } else {\n<484> \n<485> uint8_t *dst = c->rgb_pic + y * c->rgb_stride + x * 3;\n<486> \n<487> if (wmv9_mask != -1) {\n<488> \n<489> ctx->dsp.mss2_gray_fill_masked(dst, c->rgb_stride,\n<490> \n<491> wmv9_mask,\n<492> \n<493> c->pal_pic + y * c->pal_stride + x,\n<494> \n<495> c->pal_stride,\n<496> \n<497> w, h);\n<498> \n<499> } else {\n<500> \n<501> do {\n<502> \n<503> memset(dst, 0x80, w * 3);\n<504> \n<505> dst += c->rgb_stride;\n<506> \n<507> } while (--h);\n<508> \n<509> }\n<510> \n<511> }\n<512> \n<513> }\n<514> \n<515> }\n<516> \n<517> \n<518> \n<519> if (buf_size)\n<520> \n<521> av_log(avctx, AV_LOG_WARNING, "buffer not fully consumed\n");\n<522> \n<523> \n<524> \n<525> if (c->mvX < 0 || c->mvY < 0) {\n<526> \n<527> av_frame_unref(ctx->last_pic);\n<528> \n<529> ret = av_frame_ref(ctx->last_pic, frame);\n<530> \n<531> if (ret < 0)\n<532> \n<533> return ret;\n<534> \n<535> }\n<536> \n<537> \n<538> \n<539> *got_frame       = 1;\n<540> \n<541> \n<542> \n<543> return avpkt->size;\n<544> \n<545> }\n<546> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void qemu_put_buffer(QEMUFile *f, const uint8_t *buf, int size)\n<2> \n<3> {\n<4> \n<5> int l;\n<6> \n<7> while (size > 0) {\n<8> \n<9> l = IO_BUF_SIZE - f->buf_index;\n<10> \n<11> if (l > size)\n<12> \n<13> l = size;\n<14> \n<15> memcpy(f->buf + f->buf_index, buf, l);\n<16> \n<17> f->buf_index += l;\n<18> \n<19> buf += l;\n<20> \n<21> size -= l;\n<22> \n<23> if (f->buf_index >= IO_BUF_SIZE)\n<24> \n<25> qemu_fflush(f);\n<26> \n<27> }\n<28> \n<29> }\n<30> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int parse_adaptation_sets(AVFormatContext *s)\n<2> \n<3> {\n<4> \n<5> WebMDashMuxContext *w = s->priv_data;\n<6> \n<7> char *p = w->adaptation_sets;\n<8> \n<9> char *q;\n<10> \n<11> enum { new_set, parsed_id, parsing_streams } state;\n<12> \n<13> // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on\n<14> \n<15> state = new_set;\n<16> \n<17> while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n<18> \n<19> if (*p == ' ')\n<20> \n<21> continue;\n<22> \n<23> else if (state == new_set && !strncmp(p, "id=", 3)) {\n<24> \n<25> w->as = av_realloc(w->as, sizeof(*w->as) * ++w->nb_as);\n<26> \n<27> if (w->as == NULL) return -1;\n<28> \n<29> w->as[w->nb_as - 1].nb_streams = 0;\n<30> \n<31> w->as[w->nb_as - 1].streams = NULL;\n<32> \n<33> p += 3; // consume "id="\n<34> \n<35> q = w->as[w->nb_as - 1].id;\n<36> \n<37> while (*p != ',') *q++ = *p++;\n<38> \n<39> *q = 0;\n<40> \n<41> p++;\n<42> \n<43> state = parsed_id;\n<44> \n<45> } else if (state == parsed_id && !strncmp(p, "streams=", 8)) {\n<46> \n<47> p += 8; // consume "streams="\n<48> \n<49> state = parsing_streams;\n<50> \n<51> } else if (state == parsing_streams) {\n<52> \n<53> struct AdaptationSet *as = &w->as[w->nb_as - 1];\n<54> \n<55> q = p;\n<56> \n<57> while (*q != '\0' && *q != ',' && *q != ' ') q++;\n<58> \n<59> as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);\n<60> \n<61> if (as->streams == NULL) return -1;\n<62> \n<63> as->streams[as->nb_streams - 1] = to_integer(p, q - p);\n<64> \n<65> if (as->streams[as->nb_streams - 1] < 0) return -1;\n<66> \n<67> if (*q == '\0') break;\n<68> \n<69> if (*q == ' ') state = new_set;\n<70> \n<71> p = ++q;\n<72> \n<73> } else {\n<74> \n<75> return -1;\n<76> \n<77> }\n<78> \n<79> }\n<80> \n<81> return 0;\n<82> \n<83> }\n<84> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> PXA2xxState *pxa270_init(unsigned int sdram_size, const char *revision)\n<2> \n<3> {\n<4> \n<5> PXA2xxState *s;\n<6> \n<7> int iomemtype, i;\n<8> \n<9> DriveInfo *dinfo;\n<10> \n<11> s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));\n<12> \n<13> \n<14> \n<15> if (revision && strncmp(revision, "pxa27", 5)) {\n<16> \n<17> fprintf(stderr, "Machine requires a PXA27x processor.\n");\n<18> \n<19> exit(1);\n<20> \n<21> }\n<22> \n<23> if (!revision)\n<24> \n<25> revision = "pxa270";\n<26> \n<27> \n<28> \n<29> s->env = cpu_init(revision);\n<30> \n<31> if (!s->env) {\n<32> \n<33> fprintf(stderr, "Unable to find CPU definition\n");\n<34> \n<35> exit(1);\n<36> \n<37> }\n<38> \n<39> s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];\n<40> \n<41> \n<42> \n<43> /* SDRAM & Internal Memory Storage */\n<44> \n<45> cpu_register_physical_memory(PXA2XX_SDRAM_BASE,\n<46> \n<47> sdram_size, qemu_ram_alloc(NULL, "pxa270.sdram",\n<48> \n<49> sdram_size) | IO_MEM_RAM);\n<50> \n<51> cpu_register_physical_memory(PXA2XX_INTERNAL_BASE,\n<52> \n<53> 0x40000, qemu_ram_alloc(NULL, "pxa270.internal",\n<54> \n<55> 0x40000) | IO_MEM_RAM);\n<56> \n<57> \n<58> \n<59> s->pic = pxa2xx_pic_init(0x40d00000, s->env);\n<60> \n<61> \n<62> \n<63> s->dma = pxa27x_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);\n<64> \n<65> \n<66> \n<67> pxa27x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0],\n<68> \n<69> s->pic[PXA27X_PIC_OST_4_11]);\n<70> \n<71> \n<72> \n<73> s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 121);\n<74> \n<75> \n<76> \n<77> dinfo = drive_get(IF_SD, 0, 0);\n<78> \n<79> if (!dinfo) {\n<80> \n<81> fprintf(stderr, "qemu: missing SecureDigital device\n");\n<82> \n<83> exit(1);\n<84> \n<85> }\n<86> \n<87> s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,\n<88> \n<89> s->pic[PXA2XX_PIC_MMC], s->dma);\n<90> \n<91> \n<92> \n<93> for (i = 0; pxa270_serial[i].io_base; i ++)\n<94> \n<95> if (serial_hds[i])\n<96> \n<97> #ifdef TARGET_WORDS_BIGENDIAN\n<98> \n<99> serial_mm_init(pxa270_serial[i].io_base, 2,\n<100> \n<101> s->pic[pxa270_serial[i].irqn], 14857000/16,\n<102> \n<103> serial_hds[i], 1, 1);\n<104> \n<105> #else\n<106> \n<107> serial_mm_init(pxa270_serial[i].io_base, 2,\n<108> \n<109> s->pic[pxa270_serial[i].irqn], 14857000/16,\n<110> \n<111> serial_hds[i], 1, 0);\n<112> \n<113> #endif\n<114> \n<115> else\n<116> \n<117> break;\n<118> \n<119> if (serial_hds[i])\n<120> \n<121> s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],\n<122> \n<123> s->dma, serial_hds[i]);\n<124> \n<125> \n<126> \n<127> s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);\n<128> \n<129> \n<130> \n<131> s->cm_base = 0x41300000;\n<132> \n<133> s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */\n<134> \n<135> s->clkcfg = 0x00000009;		/* Turbo mode active */\n<136> \n<137> iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn,\n<138> \n<139> pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN);\n<140> \n<141> cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);\n<142> \n<143> register_savevm(NULL, "pxa2xx_cm", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s);\n<144> \n<145> \n<146> \n<147> cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);\n<148> \n<149> \n<150> \n<151> s->mm_base = 0x48000000;\n<152> \n<153> s->mm_regs[MDMRS >> 2] = 0x00020002;\n<154> \n<155> s->mm_regs[MDREFR >> 2] = 0x03ca4000;\n<156> \n<157> s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */\n<158> \n<159> iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn,\n<160> \n<161> pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN);\n<162> \n<163> cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);\n<164> \n<165> register_savevm(NULL, "pxa2xx_mm", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s);\n<166> \n<167> \n<168> \n<169> s->pm_base = 0x40f00000;\n<170> \n<171> iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn,\n<172> \n<173> pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN);\n<174> \n<175> cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);\n<176> \n<177> register_savevm(NULL, "pxa2xx_pm", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s);\n<178> \n<179> \n<180> \n<181> for (i = 0; pxa27x_ssp[i].io_base; i ++);\n<182> \n<183> s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);\n<184> \n<185> for (i = 0; pxa27x_ssp[i].io_base; i ++) {\n<186> \n<187> DeviceState *dev;\n<188> \n<189> dev = sysbus_create_simple("pxa2xx-ssp", pxa27x_ssp[i].io_base,\n<190> \n<191> s->pic[pxa27x_ssp[i].irqn]);\n<192> \n<193> s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, "ssi");\n<194> \n<195> }\n<196> \n<197> \n<198> \n<199> if (usb_enabled) {\n<200> \n<201> sysbus_create_simple("sysbus-ohci", 0x4c000000,\n<202> \n<203> s->pic[PXA2XX_PIC_USBH1]);\n<204> \n<205> }\n<206> \n<207> \n<208> \n<209> s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n<210> \n<211> s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n<212> \n<213> \n<214> \n<215> s->rtc_base = 0x40900000;\n<216> \n<217> iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n<218> \n<219> pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n<220> \n<221> cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);\n<222> \n<223> pxa2xx_rtc_init(s);\n<224> \n<225> register_savevm(NULL, "pxa2xx_rtc", 0, 0, pxa2xx_rtc_save,\n<226> \n<227> pxa2xx_rtc_load, s);\n<228> \n<229> \n<230> \n<231> s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n<232> \n<233> s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n<234> \n<235> \n<236> \n<237> s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n<238> \n<239> \n<240> \n<241> s->kp = pxa27x_keypad_init(0x41500000, s->pic[PXA2XX_PIC_KEYPAD]);\n<242> \n<243> \n<244> \n<245> /* GPIO1 resets the processor */\n<246> \n<247> /* The handler can be overridden by board-specific code */\n<248> \n<249> qdev_connect_gpio_out(s->gpio, 1, s->reset);\n<250> \n<251> return s;\n<252> \n<253> }\n<254> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> build_rsdp(GArray *rsdp_table, BIOSLinker *linker, unsigned rsdt)\n<2> \n<3> {\n<4> \n<5> AcpiRsdpDescriptor *rsdp = acpi_data_push(rsdp_table, sizeof *rsdp);\n<6> \n<7> \n<8> \n<9> bios_linker_loader_alloc(linker, ACPI_BUILD_RSDP_FILE, rsdp_table, 16,\n<10> \n<11> true /* fseg memory */);\n<12> \n<13> \n<14> \n<15> memcpy(&rsdp->signature, "RSD PTR ", 8);\n<16> \n<17> memcpy(rsdp->oem_id, ACPI_BUILD_APPNAME6, 6);\n<18> \n<19> rsdp->rsdt_physical_address = cpu_to_le32(rsdt);\n<20> \n<21> /* Address to be filled by Guest linker */\n<22> \n<23> bios_linker_loader_add_pointer(linker, ACPI_BUILD_RSDP_FILE,\n<24> \n<25> ACPI_BUILD_TABLE_FILE,\n<26> \n<27> &rsdp->rsdt_physical_address,\n<28> \n<29> sizeof rsdp->rsdt_physical_address);\n<30> \n<31> rsdp->checksum = 0;\n<32> \n<33> /* Checksum to be filled by Guest linker */\n<34> \n<35> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,\n<36> \n<37> rsdp, sizeof *rsdp,\n<38> \n<39> &rsdp->checksum);\n<40> \n<41> \n<42> \n<43> return rsdp_table;\n<44> \n<45> }\n<46> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int dissect_dns_answer ( tvbuff_t * tvb , int offsetx , int dns_data_offset , column_info * cinfo , proto_tree * dns_tree , packet_info * pinfo , gboolean is_mdns ) {\n<2> int len ;\n<3> const guchar * name ;\n<4> gchar * name_out ;\n<5> int name_len ;\n<6> int dns_type ;\n<7> int dns_class ;\n<8> int flush ;\n<9> const char * class_name ;\n<10> const char * type_name ;\n<11> int data_offset ;\n<12> int cur_offset ;\n<13> int data_start ;\n<14> gushort data_len ;\n<15> proto_tree * rr_tree = NULL ;\n<16> proto_item * trr = NULL ;\n<17> data_start = data_offset = offsetx ;\n<18> cur_offset = offsetx ;\n<19> len = get_dns_name_type_class ( tvb , offsetx , dns_data_offset , & name , & name_len , & dns_type , & dns_class ) ;\n<20> data_offset += len ;\n<21> cur_offset += len ;\n<22> if ( is_mdns ) {\n<23> flush = dns_class & C_FLUSH ;\n<24> dns_class &= ~ C_FLUSH ;\n<25> }\n<26> else {\n<27> flush = 0 ;\n<28> }\n<29> type_name = val_to_str_ext ( dns_type , & dns_types_vals_ext , "Unknown (%d)" ) ;\n<30> class_name = val_to_str_const ( dns_class , dns_classes , "Unknown" ) ;\n<31> data_offset += 4 ;\n<32> cur_offset += 4 ;\n<33> data_len = tvb_get_ntohs ( tvb , data_offset ) ;\n<34> data_offset += 2 ;\n<35> cur_offset += 2 ;\n<36> if ( cinfo != NULL ) {\n<37> col_append_fstr ( cinfo , COL_INFO , "%s" , type_name ) ;\n<38> if ( is_mdns && flush ) {\n<39> col_append_str ( cinfo , COL_INFO , ", cache flush" ) ;\n<40> }\n<41> }\n<42> if ( dns_tree != NULL ) {\n<43> name_out = format_text ( name , strlen ( name ) ) ;\n<44> if ( dns_type != T_OPT ) {\n<45> rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , "%s: type %s, class %s" , name_out , type_name , class_name ) ;\n<46> add_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , dns_type , pinfo , is_mdns ) ;\n<47> }\n<48> else {\n<49> rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , "%s: type %s" , name_out , type_name ) ;\n<50> add_opt_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , is_mdns ) ;\n<51> }\n<52> if ( is_mdns && flush ) {\n<53> proto_item_append_text ( trr , ", cache flush" ) ;\n<54> }\n<55> }\n<56> if ( data_len == 0 ) {\n<57> return data_offset - data_start ;\n<58> }\n<59> switch ( dns_type ) {\n<60> case T_A : {\n<61> const char * addr ;\n<62> addr = tvb_ip_to_str ( tvb , cur_offset ) ;\n<63> if ( cinfo != NULL ) {\n<64> col_append_fstr ( cinfo , COL_INFO , " %s" , addr ) ;\n<65> }\n<66> proto_item_append_text ( trr , ", addr %s" , addr ) ;\n<67> proto_tree_add_item ( rr_tree , hf_dns_a , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<68> if ( dns_use_for_addr_resolution && ( dns_class & 0x7f ) == C_IN ) {\n<69> guint32 addr_int ;\n<70> tvb_memcpy ( tvb , & addr_int , cur_offset , sizeof ( addr_int ) ) ;\n<71> add_ipv4_name ( addr_int , name ) ;\n<72> }\n<73> }\n<74> break ;\n<75> case T_NS : {\n<76> const guchar * ns_name ;\n<77> int ns_name_len ;\n<78> ns_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & ns_name ) ;\n<79> name_out = format_text ( ns_name , strlen ( ns_name ) ) ;\n<80> if ( cinfo != NULL ) {\n<81> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<82> }\n<83> proto_item_append_text ( trr , ", ns %s" , name_out ) ;\n<84> proto_tree_add_string ( rr_tree , hf_dns_ns , tvb , cur_offset , ns_name_len , name_out ) ;\n<85> }\n<86> break ;\n<87> case T_MD : {\n<88> int hostname_len ;\n<89> const guchar * hostname_str ;\n<90> if ( cinfo != NULL ) {\n<91> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<92> }\n<93> hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n<94> proto_tree_add_string ( rr_tree , hf_dns_md , tvb , cur_offset , hostname_len , hostname_str ) ;\n<95> }\n<96> break ;\n<97> case T_MF : {\n<98> int hostname_len ;\n<99> const guchar * hostname_str ;\n<100> if ( cinfo != NULL ) {\n<101> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<102> }\n<103> hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n<104> proto_tree_add_string ( rr_tree , hf_dns_mf , tvb , cur_offset , hostname_len , hostname_str ) ;\n<105> }\n<106> break ;\n<107> case T_CNAME : {\n<108> const guchar * cname ;\n<109> int cname_len ;\n<110> cname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & cname ) ;\n<111> name_out = format_text ( cname , strlen ( cname ) ) ;\n<112> if ( cinfo != NULL ) {\n<113> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<114> }\n<115> proto_item_append_text ( trr , ", cname %s" , name_out ) ;\n<116> proto_tree_add_string ( rr_tree , hf_dns_cname , tvb , cur_offset , cname_len , name_out ) ;\n<117> }\n<118> break ;\n<119> case T_SOA : {\n<120> const guchar * mname ;\n<121> int mname_len ;\n<122> const guchar * rname ;\n<123> int rname_len ;\n<124> proto_item * ti_soa ;\n<125> mname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mname ) ;\n<126> name_out = format_text ( mname , strlen ( mname ) ) ;\n<127> if ( cinfo != NULL ) {\n<128> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<129> }\n<130> proto_item_append_text ( trr , ", mname %s" , name_out ) ;\n<131> proto_tree_add_string ( rr_tree , hf_dns_soa_mname , tvb , cur_offset , mname_len , name_out ) ;\n<132> cur_offset += mname_len ;\n<133> rname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rname ) ;\n<134> name_out = format_text ( rname , strlen ( rname ) ) ;\n<135> proto_tree_add_string ( rr_tree , hf_dns_soa_rname , tvb , cur_offset , rname_len , name_out ) ;\n<136> cur_offset += rname_len ;\n<137> proto_tree_add_item ( rr_tree , hf_dns_soa_serial_number , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<138> cur_offset += 4 ;\n<139> ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_refresh_interval , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<140> proto_item_append_text ( ti_soa , " (%s)" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n<141> cur_offset += 4 ;\n<142> ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_retry_interval , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<143> proto_item_append_text ( ti_soa , " (%s)" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n<144> cur_offset += 4 ;\n<145> ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_expire_limit , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<146> proto_item_append_text ( ti_soa , " (%s)" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n<147> cur_offset += 4 ;\n<148> ti_soa = proto_tree_add_item ( rr_tree , hf_dns_soa_minimum_ttl , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<149> proto_item_append_text ( ti_soa , " (%s)" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n<150> }\n<151> break ;\n<152> case T_MB : {\n<153> int hostname_len ;\n<154> const guchar * hostname_str ;\n<155> if ( cinfo != NULL ) {\n<156> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<157> }\n<158> hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n<159> proto_tree_add_string ( rr_tree , hf_dns_mb , tvb , cur_offset , hostname_len , hostname_str ) ;\n<160> }\n<161> break ;\n<162> case T_MG : {\n<163> int hostname_len ;\n<164> const guchar * hostname_str ;\n<165> if ( cinfo != NULL ) {\n<166> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<167> }\n<168> hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n<169> proto_tree_add_string ( rr_tree , hf_dns_mg , tvb , cur_offset , hostname_len , hostname_str ) ;\n<170> }\n<171> break ;\n<172> case T_MR : {\n<173> int hostname_len ;\n<174> const guchar * hostname_str ;\n<175> if ( cinfo != NULL ) {\n<176> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<177> }\n<178> hostname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & hostname_str ) ;\n<179> proto_tree_add_string ( rr_tree , hf_dns_mr , tvb , cur_offset , hostname_len , hostname_str ) ;\n<180> }\n<181> break ;\n<182> case T_NULL : {\n<183> if ( cinfo != NULL ) {\n<184> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<185> }\n<186> proto_tree_add_item ( rr_tree , hf_dns_null , tvb , cur_offset , data_len , ENC_NA ) ;\n<187> }\n<188> break ;\n<189> case T_WKS : {\n<190> int rr_len = data_len ;\n<191> const char * wks_addr ;\n<192> guint8 protocol ;\n<193> guint8 bits ;\n<194> int mask ;\n<195> int port_num ;\n<196> int i ;\n<197> proto_item * ti_wks ;\n<198> wmem_strbuf_t * bitnames = wmem_strbuf_new_label ( wmem_packet_scope ( ) ) ;\n<199> wks_addr = tvb_ip_to_str ( tvb , cur_offset ) ;\n<200> if ( cinfo != NULL ) {\n<201> col_append_fstr ( cinfo , COL_INFO , " %s" , wks_addr ) ;\n<202> }\n<203> proto_item_append_text ( trr , ", addr %s" , wks_addr ) ;\n<204> proto_tree_add_item ( rr_tree , hf_dns_wks_address , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<205> cur_offset += 4 ;\n<206> rr_len -= 4 ;\n<207> proto_tree_add_item ( rr_tree , hf_dns_wks_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<208> protocol = tvb_get_guint8 ( tvb , cur_offset ) ;\n<209> cur_offset += 1 ;\n<210> rr_len -= 1 ;\n<211> port_num = 0 ;\n<212> while ( rr_len != 0 ) {\n<213> bits = tvb_get_guint8 ( tvb , cur_offset ) ;\n<214> if ( bits != 0 ) {\n<215> mask = 1 << 7 ;\n<216> wmem_strbuf_truncate ( bitnames , 0 ) ;\n<217> for ( i = 0 ;\n<218> i < 8 ;\n<219> i ++ ) {\n<220> if ( bits & mask ) {\n<221> if ( wmem_strbuf_get_len ( bitnames ) > 0 ) {\n<222> wmem_strbuf_append ( bitnames , ", " ) ;\n<223> }\n<224> switch ( protocol ) {\n<225> case IP_PROTO_TCP : wmem_strbuf_append ( bitnames , tcp_port_to_display ( wmem_packet_scope ( ) , port_num ) ) ;\n<226> break ;\n<227> case IP_PROTO_UDP : wmem_strbuf_append ( bitnames , udp_port_to_display ( wmem_packet_scope ( ) , port_num ) ) ;\n<228> break ;\n<229> default : wmem_strbuf_append_printf ( bitnames , "%u" , port_num ) ;\n<230> break ;\n<231> }\n<232> }\n<233> mask >>= 1 ;\n<234> port_num ++ ;\n<235> }\n<236> ti_wks = proto_tree_add_item ( rr_tree , hf_dns_wks_bits , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<237> proto_item_append_text ( ti_wks , " (%s)" , wmem_strbuf_get_str ( bitnames ) ) ;\n<238> }\n<239> else {\n<240> port_num += 8 ;\n<241> }\n<242> cur_offset += 1 ;\n<243> rr_len -= 1 ;\n<244> }\n<245> }\n<246> break ;\n<247> case T_PTR : {\n<248> const guchar * pname ;\n<249> int pname_len ;\n<250> pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n<251> name_out = format_text ( pname , strlen ( pname ) ) ;\n<252> if ( cinfo != NULL ) {\n<253> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<254> }\n<255> proto_item_append_text ( trr , ", %s" , name_out ) ;\n<256> proto_tree_add_string ( rr_tree , hf_dns_ptr_domain_name , tvb , cur_offset , pname_len , name_out ) ;\n<257> }\n<258> break ;\n<259> case T_HINFO : {\n<260> int cpu_offset ;\n<261> int cpu_len ;\n<262> const char * cpu ;\n<263> int os_offset ;\n<264> int os_len ;\n<265> const char * os ;\n<266> cpu_offset = cur_offset ;\n<267> cpu_len = tvb_get_guint8 ( tvb , cpu_offset ) ;\n<268> cpu = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cpu_offset + 1 , cpu_len , ENC_ASCII | ENC_NA ) ;\n<269> os_offset = cpu_offset + 1 + cpu_len ;\n<270> os_len = tvb_get_guint8 ( tvb , os_offset ) ;\n<271> os = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , os_offset + 1 , os_len , ENC_ASCII | ENC_NA ) ;\n<272> if ( cinfo != NULL ) {\n<273> col_append_fstr ( cinfo , COL_INFO , " %.*s %.*s" , cpu_len , cpu , os_len , os ) ;\n<274> }\n<275> proto_item_append_text ( trr , ", CPU %.*s, OS %.*s" , cpu_len , cpu , os_len , os ) ;\n<276> proto_tree_add_item ( rr_tree , hf_dns_hinfo_cpu_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<277> cur_offset += 1 ;\n<278> proto_tree_add_item ( rr_tree , hf_dns_hinfo_cpu , tvb , cur_offset , cpu_len , ENC_ASCII | ENC_NA ) ;\n<279> cur_offset += cpu_len ;\n<280> proto_tree_add_item ( rr_tree , hf_dns_hinfo_os_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<281> cur_offset += 1 ;\n<282> proto_tree_add_item ( rr_tree , hf_dns_hinfo_os , tvb , cur_offset , os_len , ENC_ASCII | ENC_NA ) ;\n<283> }\n<284> break ;\n<285> case T_MINFO : {\n<286> int rmailbx_len , emailbx_len ;\n<287> const guchar * rmailbx_str , * emailbx_str ;\n<288> if ( cinfo != NULL ) {\n<289> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<290> }\n<291> rmailbx_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rmailbx_str ) ;\n<292> proto_tree_add_string ( rr_tree , hf_dns_minfo_r_mailbox , tvb , cur_offset , rmailbx_len , rmailbx_str ) ;\n<293> cur_offset += rmailbx_len ;\n<294> emailbx_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & emailbx_str ) ;\n<295> proto_tree_add_string ( rr_tree , hf_dns_minfo_e_mailbox , tvb , cur_offset , emailbx_len , emailbx_str ) ;\n<296> }\n<297> break ;\n<298> case T_MX : {\n<299> guint16 preference = 0 ;\n<300> const guchar * mx_name ;\n<301> int mx_name_len ;\n<302> preference = tvb_get_ntohs ( tvb , cur_offset ) ;\n<303> mx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & mx_name ) ;\n<304> name_out = format_text ( mx_name , strlen ( mx_name ) ) ;\n<305> if ( cinfo != NULL ) {\n<306> col_append_fstr ( cinfo , COL_INFO , " %u %s" , preference , name_out ) ;\n<307> }\n<308> proto_item_append_text ( trr , ", preference %u, mx %s" , preference , name_out ) ;\n<309> proto_tree_add_item ( rr_tree , hf_dns_mx_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<310> cur_offset += 2 ;\n<311> proto_tree_add_string ( rr_tree , hf_dns_mx_mail_exchange , tvb , cur_offset , mx_name_len , name_out ) ;\n<312> }\n<313> break ;\n<314> case T_TXT : {\n<315> int rr_len = data_len ;\n<316> int txt_offset ;\n<317> int txt_len ;\n<318> txt_offset = cur_offset ;\n<319> while ( rr_len != 0 ) {\n<320> txt_len = tvb_get_guint8 ( tvb , txt_offset ) ;\n<321> proto_tree_add_item ( rr_tree , hf_dns_txt_length , tvb , txt_offset , 1 , ENC_BIG_ENDIAN ) ;\n<322> txt_offset += 1 ;\n<323> rr_len -= 1 ;\n<324> proto_tree_add_item ( rr_tree , hf_dns_txt , tvb , txt_offset , txt_len , ENC_ASCII | ENC_NA ) ;\n<325> txt_offset += txt_len ;\n<326> rr_len -= txt_len ;\n<327> }\n<328> }\n<329> break ;\n<330> case T_RP : {\n<331> int mbox_dname_len , txt_dname_len ;\n<332> const guchar * mbox_dname , * txt_dname ;\n<333> if ( cinfo != NULL ) {\n<334> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<335> }\n<336> mbox_dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mbox_dname ) ;\n<337> proto_tree_add_string ( rr_tree , hf_dns_rp_mailbox , tvb , cur_offset , mbox_dname_len , mbox_dname ) ;\n<338> cur_offset += mbox_dname_len ;\n<339> txt_dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & txt_dname ) ;\n<340> proto_tree_add_string ( rr_tree , hf_dns_rp_txt_rr , tvb , cur_offset , txt_dname_len , txt_dname ) ;\n<341> }\n<342> break ;\n<343> case T_AFSDB : {\n<344> const guchar * host_name ;\n<345> int host_name_len ;\n<346> if ( cinfo != NULL ) {\n<347> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<348> }\n<349> host_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & host_name ) ;\n<350> proto_tree_add_item ( rr_tree , hf_dns_afsdb_subtype , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<351> cur_offset += 2 ;\n<352> proto_tree_add_string ( rr_tree , hf_dns_afsdb_hostname , tvb , cur_offset , host_name_len , host_name ) ;\n<353> }\n<354> break ;\n<355> case T_X25 : {\n<356> guint8 x25_len ;\n<357> if ( cinfo != NULL ) {\n<358> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<359> }\n<360> proto_tree_add_item ( rr_tree , hf_dns_x25_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<361> x25_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<362> cur_offset += 1 ;\n<363> proto_tree_add_item ( rr_tree , hf_dns_x25_psdn_address , tvb , cur_offset , x25_len , ENC_ASCII | ENC_NA ) ;\n<364> }\n<365> break ;\n<366> case T_ISDN : {\n<367> guint8 isdn_address_len , isdn_sa_len ;\n<368> int rr_len = data_len ;\n<369> if ( cinfo != NULL ) {\n<370> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<371> }\n<372> proto_tree_add_item ( rr_tree , hf_dns_isdn_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<373> isdn_address_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<374> cur_offset += 1 ;\n<375> rr_len -= 1 ;\n<376> proto_tree_add_item ( rr_tree , hf_dns_isdn_address , tvb , cur_offset , isdn_address_len , ENC_ASCII | ENC_NA ) ;\n<377> cur_offset += isdn_address_len ;\n<378> rr_len -= isdn_address_len ;\n<379> if ( rr_len > 1 ) {\n<380> proto_tree_add_item ( rr_tree , hf_dns_isdn_sa_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<381> isdn_sa_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<382> cur_offset += 1 ;\n<383> proto_tree_add_item ( rr_tree , hf_dns_isdn_sa , tvb , cur_offset , isdn_sa_len , ENC_ASCII | ENC_NA ) ;\n<384> }\n<385> }\n<386> break ;\n<387> case T_RT : {\n<388> const guchar * host_name ;\n<389> int host_name_len ;\n<390> if ( cinfo != NULL ) {\n<391> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<392> }\n<393> host_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & host_name ) ;\n<394> proto_tree_add_item ( rr_tree , hf_dns_rt_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<395> cur_offset += 2 ;\n<396> proto_tree_add_string ( rr_tree , hf_dns_rt_intermediate_host , tvb , cur_offset , host_name_len , host_name ) ;\n<397> }\n<398> break ;\n<399> case T_NSAP : {\n<400> if ( cinfo != NULL ) {\n<401> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<402> }\n<403> proto_tree_add_item ( rr_tree , hf_dns_nsap_rdata , tvb , cur_offset , data_len , ENC_NA ) ;\n<404> }\n<405> break ;\n<406> case T_NSAP_PTR : {\n<407> int nsap_ptr_owner_len ;\n<408> const guchar * nsap_ptr_owner ;\n<409> if ( cinfo != NULL ) {\n<410> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<411> }\n<412> nsap_ptr_owner_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & nsap_ptr_owner ) ;\n<413> proto_tree_add_string ( rr_tree , hf_dns_nsap_ptr_owner , tvb , cur_offset , nsap_ptr_owner_len , nsap_ptr_owner ) ;\n<414> }\n<415> break ;\n<416> case T_KEY : {\n<417> int rr_len = data_len ;\n<418> guint16 flags ;\n<419> proto_item * tf , * ti_gen ;\n<420> proto_tree * flags_tree ;\n<421> guint8 algo ;\n<422> guint16 key_id ;\n<423> tf = proto_tree_add_item ( rr_tree , hf_dns_key_flags , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<424> flags_tree = proto_item_add_subtree ( tf , ett_key_flags ) ;\n<425> flags = tvb_get_ntohs ( tvb , cur_offset ) ;\n<426> proto_tree_add_item ( flags_tree , hf_dns_key_flags_authentication , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<427> proto_tree_add_item ( flags_tree , hf_dns_key_flags_confidentiality , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<428> if ( ( flags & 0xC000 ) != 0xC000 ) {\n<429> proto_tree_add_item ( flags_tree , hf_dns_key_flags_key_required , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<430> proto_tree_add_item ( flags_tree , hf_dns_key_flags_associated_user , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<431> proto_tree_add_item ( flags_tree , hf_dns_key_flags_associated_named_entity , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<432> proto_tree_add_item ( flags_tree , hf_dns_key_flags_ipsec , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<433> proto_tree_add_item ( flags_tree , hf_dns_key_flags_mime , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<434> proto_tree_add_item ( flags_tree , hf_dns_key_flags_signatory , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<435> }\n<436> cur_offset += 2 ;\n<437> rr_len -= 2 ;\n<438> proto_tree_add_item ( rr_tree , hf_dns_key_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<439> cur_offset += 1 ;\n<440> rr_len -= 1 ;\n<441> proto_tree_add_item ( rr_tree , hf_dns_key_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<442> algo = tvb_get_guint8 ( tvb , cur_offset ) ;\n<443> cur_offset += 1 ;\n<444> rr_len -= 1 ;\n<445> key_id = compute_key_id ( tvb , cur_offset - 4 , rr_len + 4 , algo ) ;\n<446> ti_gen = proto_tree_add_uint ( rr_tree , hf_dns_key_key_id , tvb , 0 , 0 , key_id ) ;\n<447> PROTO_ITEM_SET_GENERATED ( ti_gen ) ;\n<448> if ( rr_len != 0 ) {\n<449> proto_tree_add_item ( rr_tree , hf_dns_key_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n<450> }\n<451> }\n<452> break ;\n<453> case T_PX : {\n<454> int px_map822_len , px_mapx400_len ;\n<455> const guchar * px_map822_dnsname , * px_mapx400_dnsname ;\n<456> if ( cinfo != NULL ) {\n<457> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<458> }\n<459> proto_tree_add_item ( rr_tree , hf_dns_px_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<460> cur_offset += 2 ;\n<461> px_map822_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & px_map822_dnsname ) ;\n<462> proto_tree_add_string ( rr_tree , hf_dns_px_map822 , tvb , cur_offset , px_map822_len , px_map822_dnsname ) ;\n<463> cur_offset += px_map822_len ;\n<464> px_mapx400_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & px_mapx400_dnsname ) ;\n<465> proto_tree_add_string ( rr_tree , hf_dns_px_mapx400 , tvb , cur_offset , px_mapx400_len , px_mapx400_dnsname ) ;\n<466> }\n<467> break ;\n<468> case T_GPOS : {\n<469> guint8 long_len , lat_len , alt_len ;\n<470> if ( cinfo != NULL ) {\n<471> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<472> }\n<473> proto_tree_add_item ( rr_tree , hf_dns_gpos_longitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<474> long_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<475> cur_offset += 1 ;\n<476> proto_tree_add_item ( rr_tree , hf_dns_gpos_longitude , tvb , cur_offset , long_len , ENC_ASCII | ENC_NA ) ;\n<477> cur_offset += long_len ;\n<478> proto_tree_add_item ( rr_tree , hf_dns_gpos_latitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<479> lat_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<480> cur_offset += 1 ;\n<481> proto_tree_add_item ( rr_tree , hf_dns_gpos_latitude , tvb , cur_offset , lat_len , ENC_ASCII | ENC_NA ) ;\n<482> cur_offset += lat_len ;\n<483> proto_tree_add_item ( rr_tree , hf_dns_gpos_altitude_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<484> alt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<485> cur_offset += 1 ;\n<486> proto_tree_add_item ( rr_tree , hf_dns_gpos_altitude , tvb , cur_offset , alt_len , ENC_ASCII | ENC_NA ) ;\n<487> }\n<488> break ;\n<489> case T_AAAA : {\n<490> const char * addr6 ;\n<491> addr6 = tvb_ip6_to_str ( tvb , cur_offset ) ;\n<492> if ( cinfo != NULL ) {\n<493> col_append_fstr ( cinfo , COL_INFO , " %s" , addr6 ) ;\n<494> }\n<495> proto_item_append_text ( trr , ", addr %s" , addr6 ) ;\n<496> proto_tree_add_item ( rr_tree , hf_dns_aaaa , tvb , cur_offset , 16 , ENC_NA ) ;\n<497> if ( dns_use_for_addr_resolution && ( dns_class & 0x7f ) == C_IN ) {\n<498> struct e_in6_addr addr_in6 ;\n<499> tvb_memcpy ( tvb , & addr_in6 , cur_offset , sizeof ( addr_in6 ) ) ;\n<500> add_ipv6_name ( & addr_in6 , name ) ;\n<501> }\n<502> }\n<503> break ;\n<504> case T_LOC : {\n<505> guint8 version ;\n<506> proto_item * ti ;\n<507> version = tvb_get_guint8 ( tvb , cur_offset ) ;\n<508> proto_tree_add_item ( rr_tree , hf_dns_loc_version , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<509> if ( version == 0 ) {\n<510> cur_offset ++ ;\n<511> ti = proto_tree_add_item ( rr_tree , hf_dns_loc_size , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<512> proto_item_append_text ( ti , " (%g m)" , rfc1867_size ( tvb , cur_offset ) ) ;\n<513> cur_offset ++ ;\n<514> ti = proto_tree_add_item ( rr_tree , hf_dns_loc_horizontal_precision , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<515> proto_item_append_text ( ti , " (%g m)" , rfc1867_size ( tvb , cur_offset ) ) ;\n<516> cur_offset ++ ;\n<517> ti = proto_tree_add_item ( rr_tree , hf_dns_loc_vertical_precision , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<518> proto_item_append_text ( ti , " (%g m)" , rfc1867_size ( tvb , cur_offset ) ) ;\n<519> cur_offset ++ ;\n<520> ti = proto_tree_add_item ( rr_tree , hf_dns_loc_latitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<521> proto_item_append_text ( ti , " (%s)" , rfc1867_angle ( tvb , cur_offset , "NS" ) ) ;\n<522> cur_offset += 4 ;\n<523> ti = proto_tree_add_item ( rr_tree , hf_dns_loc_longitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<524> proto_item_append_text ( ti , " (%s)" , rfc1867_angle ( tvb , cur_offset , "EW" ) ) ;\n<525> cur_offset += 4 ;\n<526> ti = proto_tree_add_item ( rr_tree , hf_dns_loc_altitude , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<527> proto_item_append_text ( ti , " (%g m)" , ( ( gint32 ) tvb_get_ntohl ( tvb , cur_offset ) - 10000000 ) / 100.0 ) ;\n<528> }\n<529> else {\n<530> proto_tree_add_item ( rr_tree , hf_dns_loc_unknown_data , tvb , cur_offset , data_len , ENC_NA ) ;\n<531> }\n<532> }\n<533> break ;\n<534> case T_NXT : {\n<535> int rr_len = data_len ;\n<536> const guchar * next_domain_name ;\n<537> int next_domain_name_len ;\n<538> next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n<539> name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n<540> if ( cinfo != NULL ) {\n<541> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<542> }\n<543> proto_item_append_text ( trr , ", next domain name %s" , name_out ) ;\n<544> proto_tree_add_string ( rr_tree , hf_dns_nxt_next_domain_name , tvb , cur_offset , next_domain_name_len , name_out ) ;\n<545> cur_offset += next_domain_name_len ;\n<546> rr_len -= next_domain_name_len ;\n<547> dissect_type_bitmap_nxt ( rr_tree , tvb , cur_offset , rr_len ) ;\n<548> }\n<549> break ;\n<550> case T_SRV : {\n<551> guint16 priority = 0 ;\n<552> guint16 weight = 0 ;\n<553> guint16 port = 0 ;\n<554> const guchar * target ;\n<555> int target_len ;\n<556> proto_tree_add_item ( rr_tree , hf_dns_srv_priority , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<557> priority = tvb_get_ntohs ( tvb , cur_offset ) ;\n<558> cur_offset += 2 ;\n<559> proto_tree_add_item ( rr_tree , hf_dns_srv_weight , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<560> weight = tvb_get_ntohs ( tvb , cur_offset ) ;\n<561> cur_offset += 2 ;\n<562> proto_tree_add_item ( rr_tree , hf_dns_srv_port , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<563> port = tvb_get_ntohs ( tvb , cur_offset ) ;\n<564> cur_offset += 2 ;\n<565> target_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & target ) ;\n<566> name_out = format_text ( target , strlen ( target ) ) ;\n<567> proto_tree_add_string ( rr_tree , hf_dns_srv_target , tvb , cur_offset , target_len , name_out ) ;\n<568> if ( cinfo != NULL ) {\n<569> col_append_fstr ( cinfo , COL_INFO , " %u %u %u %s" , priority , weight , port , name_out ) ;\n<570> }\n<571> proto_item_append_text ( trr , ", priority %u, weight %u, port %u, target %s" , priority , weight , port , name_out ) ;\n<572> }\n<573> break ;\n<574> case T_NAPTR : {\n<575> proto_item * ti_len ;\n<576> int offset = cur_offset ;\n<577> guint16 order ;\n<578> guint16 preference ;\n<579> gchar * flags ;\n<580> guint8 flags_len ;\n<581> guint8 service_len ;\n<582> guint8 regex_len ;\n<583> const guchar * replacement ;\n<584> int replacement_len ;\n<585> proto_tree_add_item ( rr_tree , hf_dns_naptr_order , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n<586> order = tvb_get_ntohs ( tvb , offset ) ;\n<587> offset += 2 ;\n<588> proto_tree_add_item ( rr_tree , hf_dns_naptr_preference , tvb , offset , 2 , ENC_BIG_ENDIAN ) ;\n<589> preference = tvb_get_ntohs ( tvb , offset ) ;\n<590> offset += 2 ;\n<591> proto_tree_add_item ( rr_tree , hf_dns_naptr_flags_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n<592> flags_len = tvb_get_guint8 ( tvb , offset ) ;\n<593> offset += 1 ;\n<594> proto_tree_add_item ( rr_tree , hf_dns_naptr_flags , tvb , offset , flags_len , ENC_ASCII | ENC_NA ) ;\n<595> flags = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , flags_len , ENC_ASCII | ENC_NA ) ;\n<596> offset += flags_len ;\n<597> proto_tree_add_item ( rr_tree , hf_dns_naptr_service_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n<598> service_len = tvb_get_guint8 ( tvb , offset ) ;\n<599> offset += 1 ;\n<600> proto_tree_add_item ( rr_tree , hf_dns_naptr_service , tvb , offset , service_len , ENC_ASCII | ENC_NA ) ;\n<601> offset += service_len ;\n<602> proto_tree_add_item ( rr_tree , hf_dns_naptr_regex_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n<603> regex_len = tvb_get_guint8 ( tvb , offset ) ;\n<604> offset += 1 ;\n<605> proto_tree_add_item ( rr_tree , hf_dns_naptr_regex , tvb , offset , regex_len , ENC_ASCII | ENC_NA ) ;\n<606> offset += regex_len ;\n<607> replacement_len = get_dns_name ( tvb , offset , 0 , dns_data_offset , & replacement ) ;\n<608> name_out = format_text ( replacement , strlen ( replacement ) ) ;\n<609> ti_len = proto_tree_add_uint ( rr_tree , hf_dns_naptr_replacement_length , tvb , offset , 0 , replacement_len ) ;\n<610> PROTO_ITEM_SET_GENERATED ( ti_len ) ;\n<611> proto_tree_add_string ( rr_tree , hf_dns_naptr_replacement , tvb , offset , replacement_len , name_out ) ;\n<612> if ( cinfo != NULL ) {\n<613> col_append_fstr ( cinfo , COL_INFO , " %u %u %s" , order , preference , flags ) ;\n<614> }\n<615> proto_item_append_text ( trr , ", order %u, preference %u, flags %s" , order , preference , flags ) ;\n<616> }\n<617> break ;\n<618> case T_KX : {\n<619> const guchar * kx_name ;\n<620> int kx_name_len ;\n<621> kx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & kx_name ) ;\n<622> name_out = format_text ( kx_name , strlen ( kx_name ) ) ;\n<623> if ( cinfo != NULL ) {\n<624> col_append_fstr ( cinfo , COL_INFO , " %u %s" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n<625> }\n<626> proto_item_append_text ( trr , ", preference %u, kx %s" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n<627> proto_tree_add_item ( rr_tree , hf_dns_kx_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<628> proto_tree_add_string ( rr_tree , hf_dns_kx_key_exchange , tvb , cur_offset + 2 , kx_name_len , name_out ) ;\n<629> }\n<630> break ;\n<631> case T_CERT : {\n<632> int rr_len = data_len ;\n<633> proto_tree_add_item ( rr_tree , hf_dns_cert_type , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<634> cur_offset += 2 ;\n<635> rr_len -= 2 ;\n<636> proto_tree_add_item ( rr_tree , hf_dns_cert_key_tag , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<637> cur_offset += 2 ;\n<638> rr_len -= 2 ;\n<639> proto_tree_add_item ( rr_tree , hf_dns_cert_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<640> cur_offset += 1 ;\n<641> rr_len -= 1 ;\n<642> if ( rr_len != 0 ) {\n<643> proto_tree_add_item ( rr_tree , hf_dns_cert_certificate , tvb , cur_offset , rr_len , ENC_NA ) ;\n<644> }\n<645> }\n<646> break ;\n<647> case T_A6 : {\n<648> unsigned short pre_len ;\n<649> unsigned short suf_len ;\n<650> unsigned short suf_octet_count ;\n<651> const guchar * pname ;\n<652> int pname_len ;\n<653> int a6_offset ;\n<654> int suf_offset ;\n<655> struct e_in6_addr suffix ;\n<656> address suffix_addr ;\n<657> a6_offset = cur_offset ;\n<658> pre_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<659> cur_offset ++ ;\n<660> suf_len = 128 - pre_len ;\n<661> suf_octet_count = suf_len ? ( suf_len - 1 ) / 8 + 1 : 0 ;\n<662> for ( suf_offset = 0 ;\n<663> suf_offset < 16 - suf_octet_count ;\n<664> suf_offset ++ ) {\n<665> suffix . bytes [ suf_offset ] = 0 ;\n<666> }\n<667> for ( ;\n<668> suf_offset < 16 ;\n<669> suf_offset ++ ) {\n<670> suffix . bytes [ suf_offset ] = tvb_get_guint8 ( tvb , cur_offset ) ;\n<671> cur_offset ++ ;\n<672> }\n<673> if ( pre_len > 0 ) {\n<674> pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n<675> }\n<676> else {\n<677> pname = "" ;\n<678> pname_len = 0 ;\n<679> }\n<680> name_out = format_text ( pname , strlen ( pname ) ) ;\n<681> SET_ADDRESS ( & suffix_addr , AT_IPv6 , 16 , suffix . bytes ) ;\n<682> if ( cinfo != NULL ) {\n<683> col_append_fstr ( cinfo , COL_INFO , " %d %s %s" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n<684> }\n<685> proto_tree_add_item ( rr_tree , hf_dns_a6_prefix_len , tvb , a6_offset , 1 , ENC_BIG_ENDIAN ) ;\n<686> a6_offset ++ ;\n<687> if ( suf_len ) {\n<688> proto_tree_add_ipv6 ( rr_tree , hf_dns_a6_address_suffix , tvb , a6_offset , suf_octet_count , suffix . bytes ) ;\n<689> a6_offset += suf_octet_count ;\n<690> }\n<691> if ( pre_len > 0 ) {\n<692> proto_tree_add_string ( rr_tree , hf_dns_a6_prefix_name , tvb , a6_offset , pname_len , name_out ) ;\n<693> }\n<694> proto_item_append_text ( trr , ", addr %d %s %s" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n<695> }\n<696> break ;\n<697> case T_DNAME : {\n<698> const guchar * dname ;\n<699> int dname_len ;\n<700> dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n<701> name_out = format_text ( dname , strlen ( dname ) ) ;\n<702> if ( cinfo != NULL ) {\n<703> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<704> }\n<705> proto_item_append_text ( trr , ", dname %s" , name_out ) ;\n<706> proto_tree_add_string ( rr_tree , hf_dns_dname , tvb , cur_offset , dname_len , name_out ) ;\n<707> }\n<708> break ;\n<709> case T_OPT : {\n<710> int rropt_len = data_len ;\n<711> guint16 optcode , optlen ;\n<712> proto_item * rropt , * rroptlen ;\n<713> proto_tree * rropt_tree ;\n<714> while ( rropt_len > 0 ) {\n<715> optcode = tvb_get_ntohs ( tvb , cur_offset ) ;\n<716> rropt_len -= 2 ;\n<717> optlen = tvb_get_ntohs ( tvb , cur_offset + 2 ) ;\n<718> rropt_len -= 2 ;\n<719> rropt = proto_tree_add_item ( rr_tree , hf_dns_opt , tvb , cur_offset , 4 + optlen , ENC_NA ) ;\n<720> proto_item_append_text ( rropt , ": %s" , val_to_str ( optcode , edns0_opt_code_vals , "Unknown (%d)" ) ) ;\n<721> rropt_tree = proto_item_add_subtree ( rropt , ett_dns_opts ) ;\n<722> rropt = proto_tree_add_item ( rropt_tree , hf_dns_opt_code , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<723> cur_offset += 2 ;\n<724> rroptlen = proto_tree_add_item ( rropt_tree , hf_dns_opt_len , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<725> cur_offset += 2 ;\n<726> proto_tree_add_item ( rropt_tree , hf_dns_opt_data , tvb , cur_offset , optlen , ENC_NA ) ;\n<727> switch ( optcode ) {\n<728> case O_DAU : while ( optlen != 0 ) {\n<729> proto_tree_add_item ( rropt_tree , hf_dns_opt_dau , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<730> cur_offset += 1 ;\n<731> rropt_len -= 1 ;\n<732> optlen -= 1 ;\n<733> }\n<734> break ;\n<735> case O_DHU : while ( optlen != 0 ) {\n<736> proto_tree_add_item ( rropt_tree , hf_dns_opt_dhu , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<737> cur_offset += 1 ;\n<738> rropt_len -= 1 ;\n<739> optlen -= 1 ;\n<740> }\n<741> break ;\n<742> case O_N3U : while ( optlen != 0 ) {\n<743> proto_tree_add_item ( rropt_tree , hf_dns_opt_n3u , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<744> cur_offset += 1 ;\n<745> rropt_len -= 1 ;\n<746> optlen -= 1 ;\n<747> }\n<748> break ;\n<749> case O_CLIENT_SUBNET_EXP : expert_add_info_format ( pinfo , rropt , & ei_dns_depr_opc , "Deprecated opcode. Client subnet OPT assigned as %d." , O_CLIENT_SUBNET ) ;\n<750> case O_CLIENT_SUBNET : {\n<751> guint16 family ;\n<752> union {\n<753> guint32 addr ;\n<754> guint8 bytes [ 16 ] ;\n<755> }\n<756> ip_addr = {\n<757> 0 }\n<758> ;\n<759> family = tvb_get_ntohs ( tvb , cur_offset ) ;\n<760> proto_tree_add_item ( rropt_tree , hf_dns_opt_client_family , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<761> cur_offset += 2 ;\n<762> proto_tree_add_item ( rropt_tree , hf_dns_opt_client_netmask , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<763> cur_offset += 1 ;\n<764> proto_tree_add_item ( rropt_tree , hf_dns_opt_client_scope , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<765> cur_offset += 1 ;\n<766> if ( optlen - 4 > 16 ) {\n<767> expert_add_info ( pinfo , rroptlen , & ei_dns_opt_bad_length ) ;\n<768> optlen = 20 ;\n<769> }\n<770> tvb_memcpy ( tvb , ip_addr . bytes , cur_offset , ( optlen - 4 ) ) ;\n<771> switch ( family ) {\n<772> case AFNUM_INET : proto_tree_add_ipv4 ( rropt_tree , hf_dns_opt_client_addr4 , tvb , cur_offset , ( optlen - 4 ) , ip_addr . addr ) ;\n<773> break ;\n<774> case AFNUM_INET6 : proto_tree_add_ipv6 ( rropt_tree , hf_dns_opt_client_addr6 , tvb , cur_offset , ( optlen - 4 ) , ip_addr . bytes ) ;\n<775> break ;\n<776> default : proto_tree_add_item ( rropt_tree , hf_dns_opt_client_addr , tvb , cur_offset , ( optlen - 4 ) , ENC_NA ) ;\n<777> break ;\n<778> }\n<779> cur_offset += ( optlen - 4 ) ;\n<780> rropt_len -= optlen ;\n<781> }\n<782> break ;\n<783> default : cur_offset += optlen ;\n<784> rropt_len -= optlen ;\n<785> break ;\n<786> }\n<787> }\n<788> }\n<789> break ;\n<790> case T_APL : {\n<791> int rr_len = data_len ;\n<792> guint16 afamily ;\n<793> guint8 afdpart_len ;\n<794> guint8 * addr_copy ;\n<795> if ( cinfo != NULL ) {\n<796> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<797> }\n<798> while ( rr_len > 1 ) {\n<799> afamily = tvb_get_ntohs ( tvb , cur_offset ) ;\n<800> proto_tree_add_item ( rr_tree , hf_dns_apl_address_family , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<801> cur_offset += 2 ;\n<802> rr_len -= 2 ;\n<803> proto_tree_add_item ( rr_tree , hf_dns_apl_coded_prefix , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<804> cur_offset += 1 ;\n<805> rr_len -= 1 ;\n<806> afdpart_len = tvb_get_guint8 ( tvb , cur_offset ) & DNS_APL_AFDLENGTH ;\n<807> proto_tree_add_item ( rr_tree , hf_dns_apl_negation , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<808> proto_tree_add_item ( rr_tree , hf_dns_apl_afdlength , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<809> cur_offset += 1 ;\n<810> rr_len -= 1 ;\n<811> if ( afamily == 1 && afdpart_len <= 4 ) {\n<812> addr_copy = ( guint8 * ) wmem_alloc0 ( wmem_file_scope ( ) , 4 ) ;\n<813> tvb_memcpy ( tvb , ( guint8 * ) addr_copy , cur_offset , afdpart_len ) ;\n<814> proto_tree_add_ipv4 ( rr_tree , hf_dns_apl_afdpart_ipv4 , tvb , cur_offset , afdpart_len , * addr_copy ) ;\n<815> }\n<816> else if ( afamily == 2 && afdpart_len <= 16 ) {\n<817> addr_copy = ( guint8 * ) wmem_alloc0 ( wmem_file_scope ( ) , 16 ) ;\n<818> tvb_memcpy ( tvb , ( guint8 * ) addr_copy , cur_offset , afdpart_len ) ;\n<819> proto_tree_add_ipv6 ( rr_tree , hf_dns_apl_afdpart_ipv6 , tvb , cur_offset , afdpart_len , addr_copy ) ;\n<820> }\n<821> else {\n<822> proto_tree_add_item ( rr_tree , hf_dns_apl_afdpart_data , tvb , cur_offset , afdpart_len , ENC_NA ) ;\n<823> }\n<824> cur_offset += afdpart_len ;\n<825> rr_len -= afdpart_len ;\n<826> }\n<827> }\n<828> break ;\n<829> case T_DS : case T_CDS : case T_DLV : {\n<830> int rr_len = data_len ;\n<831> proto_tree_add_item ( rr_tree , hf_dns_ds_key_id , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<832> cur_offset += 2 ;\n<833> rr_len -= 2 ;\n<834> proto_tree_add_item ( rr_tree , hf_dns_ds_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<835> cur_offset += 1 ;\n<836> rr_len -= 1 ;\n<837> proto_tree_add_item ( rr_tree , hf_dns_ds_digest_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<838> cur_offset += 1 ;\n<839> rr_len -= 1 ;\n<840> proto_tree_add_item ( rr_tree , hf_dns_ds_digest , tvb , cur_offset , rr_len , ENC_NA ) ;\n<841> }\n<842> break ;\n<843> case T_SSHFP : {\n<844> int rr_len = data_len ;\n<845> proto_tree_add_item ( rr_tree , hf_dns_sshfp_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<846> cur_offset += 1 ;\n<847> rr_len -= 1 ;\n<848> proto_tree_add_item ( rr_tree , hf_dns_sshfp_fingerprint_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<849> cur_offset += 1 ;\n<850> rr_len -= 1 ;\n<851> if ( rr_len != 0 ) {\n<852> proto_tree_add_item ( rr_tree , hf_dns_sshfp_fingerprint , tvb , cur_offset , rr_len , ENC_NA ) ;\n<853> }\n<854> }\n<855> break ;\n<856> case T_IPSECKEY : {\n<857> int rr_len = data_len ;\n<858> guint8 gw_type ;\n<859> const guchar * gw ;\n<860> int gw_name_len ;\n<861> proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_precedence , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<862> cur_offset += 1 ;\n<863> rr_len -= 1 ;\n<864> proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<865> gw_type = tvb_get_guint8 ( tvb , cur_offset ) ;\n<866> cur_offset += 1 ;\n<867> rr_len -= 1 ;\n<868> proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<869> cur_offset += 1 ;\n<870> rr_len -= 1 ;\n<871> switch ( gw_type ) {\n<872> case 0 : break ;\n<873> case 1 : proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_ipv4 , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<874> cur_offset += 4 ;\n<875> rr_len -= 4 ;\n<876> break ;\n<877> case 2 : proto_tree_add_item ( rr_tree , hf_dns_ipseckey_gateway_ipv6 , tvb , cur_offset , 16 , ENC_NA ) ;\n<878> cur_offset += 16 ;\n<879> rr_len -= 16 ;\n<880> break ;\n<881> case 3 : gw_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & gw ) ;\n<882> proto_tree_add_string ( rr_tree , hf_dns_ipseckey_gateway_dns , tvb , cur_offset , gw_name_len , gw ) ;\n<883> cur_offset += gw_name_len ;\n<884> rr_len -= gw_name_len ;\n<885> break ;\n<886> default : break ;\n<887> }\n<888> if ( rr_len != 0 ) {\n<889> proto_tree_add_item ( rr_tree , hf_dns_ipseckey_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n<890> }\n<891> }\n<892> break ;\n<893> case T_RRSIG : case T_SIG : {\n<894> int rr_len = data_len ;\n<895> const guchar * signer_name ;\n<896> int signer_name_len ;\n<897> proto_item * ti ;\n<898> proto_tree_add_item ( rr_tree , hf_dns_rrsig_type_covered , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<899> cur_offset += 2 ;\n<900> rr_len -= 2 ;\n<901> proto_tree_add_item ( rr_tree , hf_dns_rrsig_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<902> cur_offset += 1 ;\n<903> rr_len -= 1 ;\n<904> proto_tree_add_item ( rr_tree , hf_dns_rrsig_labels , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<905> cur_offset += 1 ;\n<906> rr_len -= 1 ;\n<907> ti = proto_tree_add_item ( rr_tree , hf_dns_rrsig_original_ttl , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<908> proto_item_append_text ( ti , " (%s)" , time_secs_to_str ( wmem_packet_scope ( ) , tvb_get_ntohl ( tvb , cur_offset ) ) ) ;\n<909> cur_offset += 4 ;\n<910> rr_len -= 4 ;\n<911> proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature_expiration , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<912> cur_offset += 4 ;\n<913> rr_len -= 4 ;\n<914> proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature_inception , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<915> cur_offset += 4 ;\n<916> rr_len -= 4 ;\n<917> proto_tree_add_item ( rr_tree , hf_dns_rrsig_key_tag , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<918> cur_offset += 2 ;\n<919> rr_len -= 2 ;\n<920> signer_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & signer_name ) ;\n<921> proto_tree_add_string ( rr_tree , hf_dns_rrsig_signers_name , tvb , cur_offset , signer_name_len , signer_name ) ;\n<922> cur_offset += signer_name_len ;\n<923> rr_len -= signer_name_len ;\n<924> if ( rr_len != 0 ) {\n<925> proto_tree_add_item ( rr_tree , hf_dns_rrsig_signature , tvb , cur_offset , rr_len , ENC_NA ) ;\n<926> }\n<927> }\n<928> break ;\n<929> case T_NSEC : {\n<930> int rr_len = data_len ;\n<931> const guchar * next_domain_name ;\n<932> int next_domain_name_len ;\n<933> next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n<934> name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n<935> if ( cinfo != NULL ) {\n<936> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<937> }\n<938> proto_item_append_text ( trr , ", next domain name %s" , name_out ) ;\n<939> proto_tree_add_string ( rr_tree , hf_dns_nsec_next_domain_name , tvb , cur_offset , next_domain_name_len , name_out ) ;\n<940> cur_offset += next_domain_name_len ;\n<941> rr_len -= next_domain_name_len ;\n<942> dissect_type_bitmap ( rr_tree , tvb , cur_offset , rr_len ) ;\n<943> }\n<944> break ;\n<945> case T_DNSKEY : case T_CDNSKEY : {\n<946> int rr_len = data_len ;\n<947> proto_item * tf , * ti_gen ;\n<948> proto_tree * flags_tree ;\n<949> guint16 key_id ;\n<950> guint8 algo ;\n<951> tf = proto_tree_add_item ( rr_tree , hf_dns_dnskey_flags , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<952> flags_tree = proto_item_add_subtree ( tf , ett_key_flags ) ;\n<953> proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_zone_key , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<954> proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_key_revoked , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<955> proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_secure_entry_point , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<956> proto_tree_add_item ( flags_tree , hf_dns_dnskey_flags_reserved , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<957> cur_offset += 2 ;\n<958> rr_len -= 2 ;\n<959> proto_tree_add_item ( flags_tree , hf_dns_dnskey_protocol , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<960> cur_offset += 1 ;\n<961> rr_len -= 1 ;\n<962> proto_tree_add_item ( flags_tree , hf_dns_dnskey_algorithm , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<963> algo = tvb_get_guint8 ( tvb , cur_offset ) ;\n<964> cur_offset += 1 ;\n<965> rr_len -= 1 ;\n<966> key_id = compute_key_id ( tvb , cur_offset - 4 , rr_len + 4 , algo ) ;\n<967> ti_gen = proto_tree_add_uint ( rr_tree , hf_dns_dnskey_key_id , tvb , 0 , 0 , key_id ) ;\n<968> PROTO_ITEM_SET_GENERATED ( ti_gen ) ;\n<969> proto_tree_add_item ( rr_tree , hf_dns_dnskey_public_key , tvb , cur_offset , rr_len , ENC_NA ) ;\n<970> }\n<971> break ;\n<972> case T_DHCID : {\n<973> if ( cinfo != NULL ) {\n<974> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<975> }\n<976> proto_tree_add_item ( rr_tree , hf_dns_dhcid_rdata , tvb , cur_offset , data_len , ENC_NA ) ;\n<977> }\n<978> break ;\n<979> case T_NSEC3 : {\n<980> int rr_len , initial_offset = cur_offset ;\n<981> guint8 salt_len , hash_len ;\n<982> proto_item * flags_item ;\n<983> proto_tree * flags_tree ;\n<984> proto_tree_add_item ( rr_tree , hf_dns_nsec3_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<985> cur_offset += 1 ;\n<986> flags_item = proto_tree_add_item ( rr_tree , hf_dns_nsec3_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<987> flags_tree = proto_item_add_subtree ( flags_item , ett_nsec3_flags ) ;\n<988> proto_tree_add_item ( flags_tree , hf_dns_nsec3_flag_optout , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<989> cur_offset += 1 ;\n<990> proto_tree_add_item ( rr_tree , hf_dns_nsec3_iterations , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<991> cur_offset += 2 ;\n<992> proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<993> salt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<994> cur_offset += 1 ;\n<995> proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_value , tvb , cur_offset , salt_len , ENC_NA ) ;\n<996> cur_offset += salt_len ;\n<997> proto_tree_add_item ( rr_tree , hf_dns_nsec3_hash_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<998> hash_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<999> cur_offset += 1 ;\n<1000> proto_tree_add_item ( rr_tree , hf_dns_nsec3_hash_value , tvb , cur_offset , hash_len , ENC_NA ) ;\n<1001> cur_offset += hash_len ;\n<1002> rr_len = data_len - ( cur_offset - initial_offset ) ;\n<1003> dissect_type_bitmap ( rr_tree , tvb , cur_offset , rr_len ) ;\n<1004> }\n<1005> break ;\n<1006> case T_NSEC3PARAM : {\n<1007> int salt_len ;\n<1008> if ( cinfo != NULL ) {\n<1009> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<1010> }\n<1011> proto_tree_add_item ( rr_tree , hf_dns_nsec3_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1012> cur_offset += 1 ;\n<1013> proto_tree_add_item ( rr_tree , hf_dns_nsec3_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1014> cur_offset += 1 ;\n<1015> proto_tree_add_item ( rr_tree , hf_dns_nsec3_iterations , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1016> cur_offset += 2 ;\n<1017> proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1018> salt_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<1019> cur_offset += 1 ;\n<1020> proto_tree_add_item ( rr_tree , hf_dns_nsec3_salt_value , tvb , cur_offset , salt_len , ENC_NA ) ;\n<1021> }\n<1022> break ;\n<1023> case T_TLSA : {\n<1024> int rr_len = data_len ;\n<1025> if ( cinfo != NULL ) {\n<1026> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<1027> }\n<1028> proto_tree_add_item ( rr_tree , hf_dns_tlsa_certificate_usage , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1029> cur_offset ++ ;\n<1030> rr_len -- ;\n<1031> proto_tree_add_item ( rr_tree , hf_dns_tlsa_selector , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1032> cur_offset ++ ;\n<1033> rr_len -- ;\n<1034> proto_tree_add_item ( rr_tree , hf_dns_tlsa_matching_type , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1035> cur_offset ++ ;\n<1036> rr_len -- ;\n<1037> proto_tree_add_item ( rr_tree , hf_dns_tlsa_certificate_association_data , tvb , cur_offset , rr_len , ENC_NA ) ;\n<1038> }\n<1039> break ;\n<1040> case T_HIP : {\n<1041> guint8 hit_len ;\n<1042> guint16 pk_len ;\n<1043> int rr_len = data_len ;\n<1044> int rendezvous_len ;\n<1045> const guchar * rend_server_dns_name ;\n<1046> if ( cinfo != NULL ) {\n<1047> col_append_fstr ( cinfo , COL_INFO , " %s" , name ) ;\n<1048> }\n<1049> hit_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<1050> proto_tree_add_item ( rr_tree , hf_dns_hip_hit_length , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1051> cur_offset += 1 ;\n<1052> rr_len -= 1 ;\n<1053> proto_tree_add_item ( rr_tree , hf_dns_hip_pk_algo , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1054> cur_offset += 1 ;\n<1055> rr_len -= 1 ;\n<1056> pk_len = tvb_get_ntohs ( tvb , cur_offset ) ;\n<1057> proto_tree_add_item ( rr_tree , hf_dns_hip_pk_length , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1058> cur_offset += 2 ;\n<1059> rr_len -= 2 ;\n<1060> proto_tree_add_item ( rr_tree , hf_dns_hip_hit , tvb , cur_offset , hit_len , ENC_NA ) ;\n<1061> cur_offset += hit_len ;\n<1062> rr_len -= hit_len ;\n<1063> proto_tree_add_item ( rr_tree , hf_dns_hip_pk , tvb , cur_offset , pk_len , ENC_NA ) ;\n<1064> cur_offset += pk_len ;\n<1065> rr_len -= pk_len ;\n<1066> while ( rr_len > 1 ) {\n<1067> rendezvous_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rend_server_dns_name ) ;\n<1068> proto_tree_add_string ( rr_tree , hf_dns_hip_rendezvous_server , tvb , cur_offset , rendezvous_len , rend_server_dns_name ) ;\n<1069> cur_offset += rendezvous_len ;\n<1070> rr_len -= rendezvous_len ;\n<1071> }\n<1072> }\n<1073> break ;\n<1074> case T_OPENPGPKEY : {\n<1075> proto_tree_add_item ( rr_tree , hf_dns_openpgpkey , tvb , cur_offset , data_len , ENC_ASCII | ENC_NA ) ;\n<1076> }\n<1077> break ;\n<1078> case T_SPF : {\n<1079> int rr_len = data_len ;\n<1080> int spf_offset ;\n<1081> int spf_len ;\n<1082> spf_offset = cur_offset ;\n<1083> while ( rr_len != 0 ) {\n<1084> spf_len = tvb_get_guint8 ( tvb , spf_offset ) ;\n<1085> proto_tree_add_item ( rr_tree , hf_dns_spf_length , tvb , spf_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1086> spf_offset += 1 ;\n<1087> rr_len -= 1 ;\n<1088> proto_tree_add_item ( rr_tree , hf_dns_spf , tvb , spf_offset , spf_len , ENC_ASCII | ENC_NA ) ;\n<1089> spf_offset += spf_len ;\n<1090> rr_len -= spf_len ;\n<1091> }\n<1092> }\n<1093> break ;\n<1094> case T_NID : {\n<1095> proto_tree_add_item ( rr_tree , hf_dns_ilnp_nodeid_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1096> cur_offset += 2 ;\n<1097> proto_tree_add_item ( rr_tree , hf_dns_ilnp_nodeid , tvb , cur_offset , 8 , ENC_NA ) ;\n<1098> }\n<1099> break ;\n<1100> case T_L32 : {\n<1101> proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator32_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1102> cur_offset += 2 ;\n<1103> proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator32 , tvb , cur_offset , 4 , ENC_NA ) ;\n<1104> }\n<1105> break ;\n<1106> case T_L64 : {\n<1107> proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator64_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1108> cur_offset += 2 ;\n<1109> proto_tree_add_item ( rr_tree , hf_dns_ilnp_locator64 , tvb , cur_offset , 8 , ENC_NA ) ;\n<1110> }\n<1111> break ;\n<1112> case T_LP : {\n<1113> int lp_len ;\n<1114> const guchar * lp_str ;\n<1115> proto_tree_add_item ( rr_tree , hf_dns_ilnp_locatorfqdn_preference , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1116> cur_offset += 2 ;\n<1117> lp_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & lp_str ) ;\n<1118> proto_tree_add_string ( rr_tree , hf_dns_ilnp_locatorfqdn , tvb , cur_offset , lp_len , lp_str ) ;\n<1119> }\n<1120> break ;\n<1121> case T_EUI48 : {\n<1122> proto_tree_add_item ( rr_tree , hf_dns_eui48 , tvb , cur_offset , 6 , ENC_NA ) ;\n<1123> }\n<1124> break ;\n<1125> case T_EUI64 : {\n<1126> proto_tree_add_item ( rr_tree , hf_dns_eui64 , tvb , cur_offset , 8 , ENC_NA ) ;\n<1127> }\n<1128> break ;\n<1129> case T_TKEY : {\n<1130> const guchar * tkey_algname ;\n<1131> int tkey_algname_len ;\n<1132> guint16 tkey_mode , tkey_keylen , tkey_otherlen ;\n<1133> proto_tree * key_tree ;\n<1134> proto_item * key_item ;\n<1135> tkey_algname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & tkey_algname ) ;\n<1136> proto_tree_add_string ( rr_tree , hf_dns_tkey_algo_name , tvb , cur_offset , tkey_algname_len , tkey_algname ) ;\n<1137> cur_offset += tkey_algname_len ;\n<1138> proto_tree_add_item ( rr_tree , hf_dns_tkey_signature_inception , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1139> cur_offset += 4 ;\n<1140> proto_tree_add_item ( rr_tree , hf_dns_tkey_signature_expiration , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1141> cur_offset += 4 ;\n<1142> proto_tree_add_item ( rr_tree , hf_dns_tkey_mode , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1143> tkey_mode = tvb_get_ntohs ( tvb , cur_offset ) ;\n<1144> cur_offset += 2 ;\n<1145> proto_tree_add_item ( rr_tree , hf_dns_tkey_error , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1146> cur_offset += 2 ;\n<1147> proto_tree_add_item ( rr_tree , hf_dns_tkey_key_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1148> tkey_keylen = tvb_get_ntohs ( tvb , cur_offset ) ;\n<1149> cur_offset += 2 ;\n<1150> if ( tkey_keylen != 0 ) {\n<1151> key_item = proto_tree_add_item ( rr_tree , hf_dns_tkey_key_data , tvb , cur_offset , tkey_keylen , ENC_NA ) ;\n<1152> key_tree = proto_item_add_subtree ( key_item , ett_t_key ) ;\n<1153> switch ( tkey_mode ) {\n<1154> case TKEYMODE_GSSAPI : {\n<1155> tvbuff_t * gssapi_tvb ;\n<1156> gssapi_tvb = tvb_new_subset_length ( tvb , cur_offset , tkey_keylen ) ;\n<1157> if ( tvb_strneql ( gssapi_tvb , 0 , "NTLMSSP" , 7 ) == 0 ) {\n<1158> call_dissector ( ntlmssp_handle , gssapi_tvb , pinfo , key_tree ) ;\n<1159> }\n<1160> else {\n<1161> call_dissector ( gssapi_handle , gssapi_tvb , pinfo , key_tree ) ;\n<1162> }\n<1163> break ;\n<1164> }\n<1165> default : break ;\n<1166> }\n<1167> cur_offset += tkey_keylen ;\n<1168> }\n<1169> proto_tree_add_item ( rr_tree , hf_dns_tkey_other_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1170> tkey_otherlen = tvb_get_ntohs ( tvb , cur_offset ) ;\n<1171> cur_offset += 2 ;\n<1172> if ( tkey_otherlen != 0 ) {\n<1173> proto_tree_add_item ( rr_tree , hf_dns_tkey_other_data , tvb , cur_offset , tkey_otherlen , ENC_NA ) ;\n<1174> }\n<1175> }\n<1176> break ;\n<1177> case T_TSIG : {\n<1178> guint16 tsig_siglen , tsig_otherlen ;\n<1179> const guchar * tsig_algname ;\n<1180> int tsig_algname_len ;\n<1181> proto_item * ti ;\n<1182> tsig_algname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & tsig_algname ) ;\n<1183> proto_tree_add_string ( rr_tree , hf_dns_tsig_algorithm_name , tvb , cur_offset , tsig_algname_len , tsig_algname ) ;\n<1184> cur_offset += tsig_algname_len ;\n<1185> ti = proto_tree_add_item ( rr_tree , hf_dns_tsig_time_signed , tvb , cur_offset , 6 , ENC_NA ) ;\n<1186> if ( tvb_get_ntohs ( tvb , cur_offset ) ) {\n<1187> proto_item_append_text ( ti , " (high bits set)" ) ;\n<1188> }\n<1189> cur_offset += 6 ;\n<1190> proto_tree_add_item ( rr_tree , hf_dns_tsig_fudge , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1191> cur_offset += 2 ;\n<1192> tsig_siglen = tvb_get_ntohs ( tvb , cur_offset ) ;\n<1193> proto_tree_add_item ( rr_tree , hf_dns_tsig_mac_size , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1194> cur_offset += 2 ;\n<1195> if ( tsig_siglen != 0 ) {\n<1196> proto_item * mac_item ;\n<1197> proto_tree * mac_tree ;\n<1198> tvbuff_t * sub_tvb ;\n<1199> mac_item = proto_tree_add_item ( rr_tree , hf_dns_tsig_mac , tvb , cur_offset , tsig_siglen , ENC_NA ) ;\n<1200> mac_tree = proto_item_add_subtree ( mac_item , ett_dns_mac ) ;\n<1201> sub_tvb = tvb_new_subset_length ( tvb , cur_offset , tsig_siglen ) ;\n<1202> if ( ! dissector_try_string ( dns_tsig_dissector_table , tsig_algname , sub_tvb , pinfo , mac_tree , NULL ) ) {\n<1203> expert_add_info_format ( pinfo , mac_item , & ei_dns_tsig_alg , "No dissector for algorithm:%s" , tsig_algname ) ;\n<1204> }\n<1205> cur_offset += tsig_siglen ;\n<1206> }\n<1207> proto_tree_add_item ( rr_tree , hf_dns_tsig_original_id , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1208> cur_offset += 2 ;\n<1209> proto_tree_add_item ( rr_tree , hf_dns_tsig_error , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1210> cur_offset += 2 ;\n<1211> proto_tree_add_item ( rr_tree , hf_dns_tsig_other_len , tvb , cur_offset , 2 , ENC_BIG_ENDIAN ) ;\n<1212> tsig_otherlen = tvb_get_ntohs ( tvb , cur_offset ) ;\n<1213> cur_offset += 2 ;\n<1214> if ( tsig_otherlen != 0 ) {\n<1215> proto_tree_add_item ( rr_tree , hf_dns_tsig_other_data , tvb , cur_offset , tsig_otherlen , ENC_NA ) ;\n<1216> }\n<1217> }\n<1218> break ;\n<1219> case T_CAA : {\n<1220> proto_item * caa_item ;\n<1221> proto_tree * caa_tree ;\n<1222> guint8 tag_len ;\n<1223> const char * tag ;\n<1224> gushort value_len ;\n<1225> const guchar * value ;\n<1226> int cur_hf = - 1 ;\n<1227> caa_item = proto_tree_add_item ( rr_tree , hf_dns_caa_flags , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1228> caa_tree = proto_item_add_subtree ( caa_item , ett_caa_flags ) ;\n<1229> proto_tree_add_item ( caa_tree , hf_dns_caa_flag_issuer_critical , tvb , cur_offset , 1 , ENC_BIG_ENDIAN ) ;\n<1230> cur_offset ++ ;\n<1231> tag_len = tvb_get_guint8 ( tvb , cur_offset ) ;\n<1232> tag = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cur_offset + 1 , tag_len , ENC_ASCII | ENC_NA ) ;\n<1233> value_len = data_len - ( tag_len + 2 ) ;\n<1234> value = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , cur_offset + 1 + tag_len , value_len , ENC_ASCII | ENC_NA ) ;\n<1235> value = format_text ( value , value_len ) ;\n<1236> if ( strncmp ( tag , "issue" , tag_len ) == 0 ) {\n<1237> cur_hf = hf_dns_caa_issue ;\n<1238> }\n<1239> else if ( strncmp ( tag , "issuewild" , tag_len ) == 0 ) {\n<1240> cur_hf = hf_dns_caa_issuewild ;\n<1241> }\n<1242> else if ( strncmp ( tag , "iodef" , tag_len ) == 0 ) {\n<1243> cur_hf = hf_dns_caa_iodef ;\n<1244> }\n<1245> else {\n<1246> cur_hf = hf_dns_caa_unknown ;\n<1247> }\n<1248> caa_item = proto_tree_add_string ( rr_tree , cur_hf , tvb , cur_offset , 1 + tag_len + value_len , value ) ;\n<1249> caa_tree = proto_item_add_subtree ( caa_item , ett_caa_data ) ;\n<1250> proto_tree_add_uint ( caa_tree , hf_dns_caa_tag_length , tvb , cur_offset , 1 , tag_len ) ;\n<1251> proto_tree_add_string ( caa_tree , hf_dns_caa_tag , tvb , cur_offset + 1 , tag_len , tag ) ;\n<1252> proto_tree_add_string ( caa_tree , hf_dns_caa_value , tvb , cur_offset + 1 + tag_len , value_len , value ) ;\n<1253> }\n<1254> break ;\n<1255> case T_WINS : {\n<1256> int rr_len = data_len ;\n<1257> guint32 nservers ;\n<1258> proto_tree_add_item ( rr_tree , hf_dns_wins_local_flag , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1259> cur_offset += 4 ;\n<1260> rr_len -= 4 ;\n<1261> proto_tree_add_item ( rr_tree , hf_dns_wins_lookup_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1262> cur_offset += 4 ;\n<1263> rr_len -= 4 ;\n<1264> proto_tree_add_item ( rr_tree , hf_dns_wins_cache_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1265> cur_offset += 4 ;\n<1266> rr_len -= 4 ;\n<1267> proto_tree_add_item ( rr_tree , hf_dns_wins_nb_wins_servers , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1268> nservers = tvb_get_ntohl ( tvb , cur_offset ) ;\n<1269> cur_offset += 4 ;\n<1270> rr_len -= 4 ;\n<1271> while ( rr_len != 0 && nservers != 0 ) {\n<1272> proto_tree_add_item ( rr_tree , hf_dns_wins_server , tvb , cur_offset , 4 , ENC_NA ) ;\n<1273> cur_offset += 4 ;\n<1274> rr_len -= 4 ;\n<1275> nservers -- ;\n<1276> }\n<1277> }\n<1278> break ;\n<1279> case T_WINS_R : {\n<1280> const guchar * dname ;\n<1281> int dname_len ;\n<1282> proto_tree_add_item ( rr_tree , hf_dns_winsr_local_flag , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1283> cur_offset += 4 ;\n<1284> proto_tree_add_item ( rr_tree , hf_dns_winsr_lookup_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1285> cur_offset += 4 ;\n<1286> proto_tree_add_item ( rr_tree , hf_dns_winsr_cache_timeout , tvb , cur_offset , 4 , ENC_BIG_ENDIAN ) ;\n<1287> cur_offset += 4 ;\n<1288> dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n<1289> name_out = format_text ( dname , strlen ( dname ) ) ;\n<1290> proto_tree_add_string ( rr_tree , hf_dns_winsr_name_result_domain , tvb , cur_offset , dname_len , name_out ) ;\n<1291> if ( cinfo != NULL ) {\n<1292> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<1293> }\n<1294> proto_item_append_text ( trr , ", name result domain %s" , name_out ) ;\n<1295> }\n<1296> break ;\n<1297> default : expert_add_info_format ( pinfo , trr , & ei_dns_undecoded_option , "Dissector for DNS Type (%d)" " code not implemented, Contact Wireshark developers" " if you want this supported" , dns_type ) ;\n<1298> proto_tree_add_item ( rr_tree , hf_dns_data , tvb , cur_offset , data_len , ENC_NA ) ;\n<1299> break ;\n<1300> }\n<1301> data_offset += data_len ;\n<1302> return data_offset - data_start ;\n<1303> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static uint dump_routines_for_db ( char * db ) {\n<2> char query_buff [ QUERY_LENGTH ] ;\n<3> const char * routine_type [ ] = {\n<4> "FUNCTION" , "PROCEDURE" }\n<5> ;\n<6> char db_name_buff [ NAME_LEN * 2 + 3 ] , name_buff [ NAME_LEN * 2 + 3 ] ;\n<7> char * routine_name ;\n<8> int i ;\n<9> FILE * sql_file = md_result_file ;\n<10> MYSQL_RES * routine_res , * routine_list_res ;\n<11> MYSQL_ROW row , routine_list_row ;\n<12> char db_cl_name [ MY_CS_NAME_SIZE ] ;\n<13> int db_cl_altered = FALSE ;\n<14> DBUG_ENTER ( "dump_routines_for_db" ) ;\n<15> DBUG_PRINT ( "enter" , ( "db: '%s'" , db ) ) ;\n<16> mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n<17> print_comment ( sql_file , 0 , "\n--\n-- Dumping routines for database '%s'\n--\n" , db ) ;\n<18> if ( lock_tables ) mysql_query ( mysql , "LOCK TABLES mysql.proc READ" ) ;\n<19> if ( fetch_db_collation ( db , db_cl_name , sizeof ( db_cl_name ) ) ) DBUG_RETURN ( 1 ) ;\n<20> if ( switch_character_set_results ( mysql , "binary" ) ) DBUG_RETURN ( 1 ) ;\n<21> if ( opt_xml ) fputs ( "\t<routines>\n" , sql_file ) ;\n<22> for ( i = 0 ;\n<23> i <= 1 ;\n<24> i ++ ) {\n<25> my_snprintf ( query_buff , sizeof ( query_buff ) , "SHOW %s STATUS WHERE Db = '%s'" , routine_type [ i ] , db_name_buff ) ;\n<26> if ( mysql_query_with_error_report ( mysql , & routine_list_res , query_buff ) ) DBUG_RETURN ( 1 ) ;\n<27> if ( mysql_num_rows ( routine_list_res ) ) {\n<28> while ( ( routine_list_row = mysql_fetch_row ( routine_list_res ) ) ) {\n<29> routine_name = quote_name ( routine_list_row [ 1 ] , name_buff , 0 ) ;\n<30> DBUG_PRINT ( "info" , ( "retrieving CREATE %s for %s" , routine_type [ i ] , name_buff ) ) ;\n<31> my_snprintf ( query_buff , sizeof ( query_buff ) , "SHOW CREATE %s %s" , routine_type [ i ] , routine_name ) ;\n<32> if ( mysql_query_with_error_report ( mysql , & routine_res , query_buff ) ) DBUG_RETURN ( 1 ) ;\n<33> while ( ( row = mysql_fetch_row ( routine_res ) ) ) {\n<34> DBUG_PRINT ( "info" , ( "length of body for %s row[2] '%s' is %zu" , routine_name , row [ 2 ] ? row [ 2 ] : "(null)" , row [ 2 ] ? strlen ( row [ 2 ] ) : 0 ) ) ;\n<35> if ( row [ 2 ] == NULL ) {\n<36> print_comment ( sql_file , 1 , "\n-- insufficient privileges to %s\n" , query_buff ) ;\n<37> print_comment ( sql_file , 1 , "-- does %s have permissions on mysql.proc?\n\n" , current_user ) ;\n<38> maybe_die ( EX_MYSQLERR , "%s has insufficent privileges to %s!" , current_user , query_buff ) ;\n<39> }\n<40> else if ( strlen ( row [ 2 ] ) ) {\n<41> if ( opt_xml ) {\n<42> if ( i ) print_xml_row ( sql_file , "routine" , routine_res , & row , "Create Procedure" ) ;\n<43> else print_xml_row ( sql_file , "routine" , routine_res , & row , "Create Function" ) ;\n<44> continue ;\n<45> }\n<46> if ( opt_drop ) fprintf ( sql_file , "/*!50003 DROP %s IF EXISTS %s */;\n<47> \n" , routine_type [ i ] , routine_name ) ;\n<48> if ( mysql_num_fields ( routine_res ) >= 6 ) {\n<49> if ( switch_db_collation ( sql_file , db , ";\n<50> " , db_cl_name , row [ 5 ] , & db_cl_altered ) ) {\n<51> DBUG_RETURN ( 1 ) ;\n<52> }\n<53> switch_cs_variables ( sql_file , ";\n<54> " , row [ 3 ] , row [ 3 ] , row [ 4 ] ) ;\n<55> }\n<56> else {\n<57> fprintf ( sql_file , "--\n" "-- WARNING: old server version. " "The following dump may be incomplete.\n" "--\n" ) ;\n<58> }\n<59> switch_sql_mode ( sql_file , ";\n<60> " , row [ 1 ] ) ;\n<61> fprintf ( sql_file , "DELIMITER ;\n<62> ;\n<63> \n" "%s ;\n<64> ;\n<65> \n" "DELIMITER ;\n<66> \n" , ( const char * ) row [ 2 ] ) ;\n<67> restore_sql_mode ( sql_file , ";\n<68> " ) ;\n<69> if ( mysql_num_fields ( routine_res ) >= 6 ) {\n<70> restore_cs_variables ( sql_file , ";\n<71> " ) ;\n<72> if ( db_cl_altered ) {\n<73> if ( restore_db_collation ( sql_file , db , ";\n<74> " , db_cl_name ) ) DBUG_RETURN ( 1 ) ;\n<75> }\n<76> }\n<77> }\n<78> }\n<79> mysql_free_result ( routine_res ) ;\n<80> }\n<81> }\n<82> mysql_free_result ( routine_list_res ) ;\n<83> }\n<84> if ( opt_xml ) {\n<85> fputs ( "\t</routines>\n" , sql_file ) ;\n<86> check_io ( sql_file ) ;\n<87> }\n<88> if ( switch_character_set_results ( mysql , default_charset ) ) DBUG_RETURN ( 1 ) ;\n<89> if ( lock_tables ) ( void ) mysql_query_with_error_report ( mysql , 0 , "UNLOCK TABLES" ) ;\n<90> DBUG_RETURN ( 0 ) ;\n<91> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void ps2_common_post_load ( PS2State * s ) {\n<2> PS2Queue * q = & s -> queue ;\n<3> int size ;\n<4> int i ;\n<5> int tmp_data [ PS2_QUEUE_SIZE ] ;\n<6> size = q -> count > PS2_QUEUE_SIZE ? 0 : q -> count ;\n<7> if ( size > 0 ) {\n<8> for ( i = 0 ;\n<9> i < size ;\n<10> i ++ ) {\n<11> tmp_data [ i ] = q -> data [ q -> rptr ] ;\n<12> if ( ++ q -> rptr == 256 ) {\n<13> q -> rptr = 0 ;\n<14> }\n<15> }\n<16> memcpy ( q -> data , tmp_data , size ) ;\n<17> }\n<18> q -> rptr = 0 ;\n<19> q -> wptr = size ;\n<20> q -> count = size ;\n<21> s -> update_irq ( s -> update_arg , q -> count != 0 ) ;\n<22> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int svq1_decode_frame(AVCodecContext *avctx, void *data,\n<2> \n<3> int *got_frame, AVPacket *avpkt)\n<4> \n<5> {\n<6> \n<7> const uint8_t *buf = avpkt->data;\n<8> \n<9> int buf_size       = avpkt->size;\n<10> \n<11> SVQ1Context     *s = avctx->priv_data;\n<12> \n<13> AVFrame       *cur = s->cur;\n<14> \n<15> uint8_t *current;\n<16> \n<17> int result, i, x, y, width, height;\n<18> \n<19> svq1_pmv *pmv;\n<20> \n<21> \n<22> \n<23> if (cur->data[0])\n<24> \n<25> avctx->release_buffer(avctx, cur);\n<26> \n<27> \n<28> \n<29> /* initialize bit buffer */\n<30> \n<31> init_get_bits(&s->gb, buf, buf_size * 8);\n<32> \n<33> \n<34> \n<35> /* decode frame header */\n<36> \n<37> s->frame_code = get_bits(&s->gb, 22);\n<38> \n<39> \n<40> \n<41> if ((s->frame_code & ~0x70) || !(s->frame_code & 0x60))\n<42> \n<43> return AVERROR_INVALIDDATA;\n<44> \n<45> \n<46> \n<47> /* swap some header bytes (why?) */\n<48> \n<49> if (s->frame_code != 0x20) {\n<50> \n<51> uint32_t *src = (uint32_t *)(buf + 4);\n<52> \n<53> \n<54> \n<55> if (buf_size < 36)\n<56> \n<57> return AVERROR_INVALIDDATA;\n<58> \n<59> \n<60> \n<61> for (i = 0; i < 4; i++)\n<62> \n<63> src[i] = ((src[i] << 16) | (src[i] >> 16)) ^ src[7 - i];\n<64> \n<65> }\n<66> \n<67> \n<68> \n<69> result = svq1_decode_frame_header(avctx, cur);\n<70> \n<71> if (result != 0) {\n<72> \n<73> av_dlog(avctx, "Error in svq1_decode_frame_header %i\n", result);\n<74> \n<75> return result;\n<76> \n<77> }\n<78> \n<79> avcodec_set_dimensions(avctx, s->width, s->height);\n<80> \n<81> \n<82> \n<83> if ((avctx->skip_frame >= AVDISCARD_NONREF && s->nonref) ||\n<84> \n<85> (avctx->skip_frame >= AVDISCARD_NONKEY &&\n<86> \n<87> cur->pict_type != AV_PICTURE_TYPE_I) ||\n<88> \n<89> avctx->skip_frame >= AVDISCARD_ALL)\n<90> \n<91> return buf_size;\n<92> \n<93> \n<94> \n<95> result = ff_get_buffer(avctx, cur);\n<96> \n<97> if (result < 0)\n<98> \n<99> return result;\n<100> \n<101> \n<102> \n<103> pmv = av_malloc((FFALIGN(s->width, 16) / 8 + 3) * sizeof(*pmv));\n<104> \n<105> if (!pmv)\n<106> \n<107> return AVERROR(ENOMEM);\n<108> \n<109> \n<110> \n<111> /* decode y, u and v components */\n<112> \n<113> for (i = 0; i < 3; i++) {\n<114> \n<115> int linesize = cur->linesize[i];\n<116> \n<117> if (i == 0) {\n<118> \n<119> width    = FFALIGN(s->width,  16);\n<120> \n<121> height   = FFALIGN(s->height, 16);\n<122> \n<123> } else {\n<124> \n<125> if (avctx->flags & CODEC_FLAG_GRAY)\n<126> \n<127> break;\n<128> \n<129> width    = FFALIGN(s->width  / 4, 16);\n<130> \n<131> height   = FFALIGN(s->height / 4, 16);\n<132> \n<133> }\n<134> \n<135> \n<136> \n<137> current = cur->data[i];\n<138> \n<139> \n<140> \n<141> if (cur->pict_type == AV_PICTURE_TYPE_I) {\n<142> \n<143> /* keyframe */\n<144> \n<145> for (y = 0; y < height; y += 16) {\n<146> \n<147> for (x = 0; x < width; x += 16) {\n<148> \n<149> result = svq1_decode_block_intra(&s->gb, &current[x],\n<150> \n<151> linesize);\n<152> \n<153> if (result) {\n<154> \n<155> av_log(avctx, AV_LOG_ERROR,\n<156> \n<157> "Error in svq1_decode_block %i (keyframe)\n",\n<158> \n<159> result);\n<160> \n<161> goto err;\n<162> \n<163> }\n<164> \n<165> }\n<166> \n<167> current += 16 * linesize;\n<168> \n<169> }\n<170> \n<171> } else {\n<172> \n<173> /* delta frame */\n<174> \n<175> uint8_t *previous = s->prev->data[i];\n<176> \n<177> if (!previous) {\n<178> \n<179> av_log(avctx, AV_LOG_ERROR, "Missing reference frame.\n");\n<180> \n<181> result = AVERROR_INVALIDDATA;\n<182> \n<183> goto err;\n<184> \n<185> }\n<186> \n<187> \n<188> \n<189> memset(pmv, 0, ((width / 8) + 3) * sizeof(svq1_pmv));\n<190> \n<191> \n<192> \n<193> for (y = 0; y < height; y += 16) {\n<194> \n<195> for (x = 0; x < width; x += 16) {\n<196> \n<197> result = svq1_decode_delta_block(avctx, &s->dsp,\n<198> \n<199> &s->gb, &current[x],\n<200> \n<201> previous, linesize,\n<202> \n<203> pmv, x, y);\n<204> \n<205> if (result) {\n<206> \n<207> av_dlog(avctx,\n<208> \n<209> "Error in svq1_decode_delta_block %i\n",\n<210> \n<211> result);\n<212> \n<213> goto err;\n<214> \n<215> }\n<216> \n<217> }\n<218> \n<219> \n<220> \n<221> pmv[0].x     =\n<222> \n<223> pmv[0].y = 0;\n<224> \n<225> \n<226> \n<227> current += 16 * linesize;\n<228> \n<229> }\n<230> \n<231> }\n<232> \n<233> }\n<234> \n<235> \n<236> \n<237> *(AVFrame*)data = *cur;\n<238> \n<239> cur->qscale_table = NULL;\n<240> \n<241> if (!s->nonref)\n<242> \n<243> FFSWAP(AVFrame*, s->cur, s->prev);\n<244> \n<245> \n<246> \n<247> *got_frame = 1;\n<248> \n<249> result     = buf_size;\n<250> \n<251> \n<252> \n<253> err:\n<254> \n<255> av_free(pmv);\n<256> \n<257> return result;\n<258> \n<259> }\n<260> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline void tcg_out_ldst(TCGContext *s, int ret, int addr, int offset, int op)\n<2> \n<3> {\n<4> \n<5> if (offset == (offset & 0xfff))\n<6> \n<7> tcg_out32(s, op | INSN_RD(ret) | INSN_RS1(addr) |\n<8> \n<9> INSN_IMM13(offset));\n<10> \n<11> else\n<12> \n<13> fprintf(stderr, "unimplemented %s with offset %d\n", __func__, offset);\n<14> \n<15> }\n<16> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int css_do_tsch_get_irb(SubchDev *sch, IRB *target_irb, int *irb_len)\n<2> \n<3> {\n<4> \n<5> SCSW *s = &sch->curr_status.scsw;\n<6> \n<7> PMCW *p = &sch->curr_status.pmcw;\n<8> \n<9> uint16_t stctl;\n<10> \n<11> IRB irb;\n<12> \n<13> \n<14> \n<15> if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n<16> \n<17> return 3;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> stctl = s->ctrl & SCSW_CTRL_MASK_STCTL;\n<24> \n<25> \n<26> \n<27> /* Prepare the irb for the guest. */\n<28> \n<29> memset(&irb, 0, sizeof(IRB));\n<30> \n<31> \n<32> \n<33> /* Copy scsw from current status. */\n<34> \n<35> memcpy(&irb.scsw, s, sizeof(SCSW));\n<36> \n<37> if (stctl & SCSW_STCTL_STATUS_PEND) {\n<38> \n<39> if (s->cstat & (SCSW_CSTAT_DATA_CHECK |\n<40> \n<41> SCSW_CSTAT_CHN_CTRL_CHK |\n<42> \n<43> SCSW_CSTAT_INTF_CTRL_CHK)) {\n<44> \n<45> irb.scsw.flags |= SCSW_FLAGS_MASK_ESWF;\n<46> \n<47> irb.esw[0] = 0x04804000;\n<48> \n<49> } else {\n<50> \n<51> irb.esw[0] = 0x00800000;\n<52> \n<53> }\n<54> \n<55> /* If a unit check is pending, copy sense data. */\n<56> \n<57> if ((s->dstat & SCSW_DSTAT_UNIT_CHECK) &&\n<58> \n<59> (p->chars & PMCW_CHARS_MASK_CSENSE)) {\n<60> \n<61> int i;\n<62> \n<63> \n<64> \n<65> irb.scsw.flags |= SCSW_FLAGS_MASK_ESWF | SCSW_FLAGS_MASK_ECTL;\n<66> \n<67> /* Attention: sense_data is already BE! */\n<68> \n<69> memcpy(irb.ecw, sch->sense_data, sizeof(sch->sense_data));\n<70> \n<71> for (i = 0; i < ARRAY_SIZE(irb.ecw); i++) {\n<72> \n<73> irb.ecw[i] = be32_to_cpu(irb.ecw[i]);\n<74> \n<75> }\n<76> \n<77> irb.esw[1] = 0x01000000 | (sizeof(sch->sense_data) << 8);\n<78> \n<79> }\n<80> \n<81> }\n<82> \n<83> /* Store the irb to the guest. */\n<84> \n<85> copy_irb_to_guest(target_irb, &irb, p, irb_len);\n<86> \n<87> \n<88> \n<89> return ((stctl & SCSW_STCTL_STATUS_PEND) == 0);\n<90> \n<91> }\n<92> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int bochs_open(BlockDriverState *bs, const char *filename, int flags)\n<2> \n<3> {\n<4> \n<5> BDRVBochsState *s = bs->opaque;\n<6> \n<7> int fd, i;\n<8> \n<9> struct bochs_header bochs;\n<10> \n<11> struct bochs_header_v1 header_v1;\n<12> \n<13> \n<14> \n<15> fd = open(filename, O_RDWR | O_BINARY);\n<16> \n<17> if (fd < 0) {\n<18> \n<19> fd = open(filename, O_RDONLY | O_BINARY);\n<20> \n<21> if (fd < 0)\n<22> \n<23> return -1;\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> bs->read_only = 1; // no write support yet\n<30> \n<31> \n<32> \n<33> s->fd = fd;\n<34> \n<35> \n<36> \n<37> if (read(fd, &bochs, sizeof(bochs)) != sizeof(bochs)) {\n<38> \n<39> goto fail;\n<40> \n<41> }\n<42> \n<43> \n<44> \n<45> if (strcmp(bochs.magic, HEADER_MAGIC) ||\n<46> \n<47> strcmp(bochs.type, REDOLOG_TYPE) ||\n<48> \n<49> strcmp(bochs.subtype, GROWING_TYPE) ||\n<50> \n<51> ((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n<52> \n<53> (le32_to_cpu(bochs.version) != HEADER_V1))) {\n<54> \n<55> goto fail;\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> if (le32_to_cpu(bochs.version) == HEADER_V1) {\n<62> \n<63> memcpy(&header_v1, &bochs, sizeof(bochs));\n<64> \n<65> bs->total_sectors = le64_to_cpu(header_v1.extra.redolog.disk) / 512;\n<66> \n<67> } else {\n<68> \n<69> bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> lseek(s->fd, le32_to_cpu(bochs.header), SEEK_SET);\n<76> \n<77> \n<78> \n<79> s->catalog_size = le32_to_cpu(bochs.extra.redolog.catalog);\n<80> \n<81> s->catalog_bitmap = qemu_malloc(s->catalog_size * 4);\n<82> \n<83> if (read(s->fd, s->catalog_bitmap, s->catalog_size * 4) !=\n<84> \n<85> s->catalog_size * 4)\n<86> \n<87> goto fail;\n<88> \n<89> for (i = 0; i < s->catalog_size; i++)\n<90> \n<91> le32_to_cpus(&s->catalog_bitmap[i]);\n<92> \n<93> \n<94> \n<95> s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n<96> \n<97> \n<98> \n<99> s->bitmap_blocks = 1 + (le32_to_cpu(bochs.extra.redolog.bitmap) - 1) / 512;\n<100> \n<101> s->extent_blocks = 1 + (le32_to_cpu(bochs.extra.redolog.extent) - 1) / 512;\n<102> \n<103> \n<104> \n<105> s->extent_size = le32_to_cpu(bochs.extra.redolog.extent);\n<106> \n<107> \n<108> \n<109> return 0;\n<110> \n<111> fail:\n<112> \n<113> close(fd);\n<114> \n<115> return -1;\n<116> \n<117> }\n<118> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void sun4m_hw_init(const struct hwdef *hwdef, int ram_size,\n<2> \n<3> DisplayState *ds, const char *cpu_model)\n<4> \n<5> \n<6> \n<7> {\n<8> \n<9> CPUState *env, *envs[MAX_CPUS];\n<10> \n<11> unsigned int i;\n<12> \n<13> void *iommu, *espdma, *ledma, *main_esp;\n<14> \n<15> const sparc_def_t *def;\n<16> \n<17> qemu_irq *cpu_irqs[MAX_CPUS], *slavio_irq, *slavio_cpu_irq,\n<18> \n<19> *espdma_irq, *ledma_irq;\n<20> \n<21> \n<22> \n<23> /* init CPUs */\n<24> \n<25> sparc_find_by_name(cpu_model, &def);\n<26> \n<27> if (def == NULL) {\n<28> \n<29> fprintf(stderr, "Unable to find Sparc CPU definition\n");\n<30> \n<31> exit(1);\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> for(i = 0; i < smp_cpus; i++) {\n<38> \n<39> env = cpu_init();\n<40> \n<41> cpu_sparc_register(env, def);\n<42> \n<43> envs[i] = env;\n<44> \n<45> if (i == 0) {\n<46> \n<47> qemu_register_reset(main_cpu_reset, env);\n<48> \n<49> } else {\n<50> \n<51> qemu_register_reset(secondary_cpu_reset, env);\n<52> \n<53> env->halted = 1;\n<54> \n<55> }\n<56> \n<57> register_savevm("cpu", i, 3, cpu_save, cpu_load, env);\n<58> \n<59> cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS);\n<60> \n<61> }\n<62> \n<63> \n<64> \n<65> for (i = smp_cpus; i < MAX_CPUS; i++)\n<66> \n<67> cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS);\n<68> \n<69> \n<70> \n<71> /* allocate RAM */\n<72> \n<73> cpu_register_physical_memory(0, ram_size, 0);\n<74> \n<75> \n<76> \n<77> iommu = iommu_init(hwdef->iommu_base);\n<78> \n<79> slavio_intctl = slavio_intctl_init(hwdef->intctl_base,\n<80> \n<81> hwdef->intctl_base + 0x10000ULL,\n<82> \n<83> &hwdef->intbit_to_level[0],\n<84> \n<85> &slavio_irq, &slavio_cpu_irq,\n<86> \n<87> cpu_irqs,\n<88> \n<89> hwdef->clock_irq);\n<90> \n<91> \n<92> \n<93> espdma = sparc32_dma_init(hwdef->dma_base, slavio_irq[hwdef->esp_irq],\n<94> \n<95> iommu, &espdma_irq);\n<96> \n<97> ledma = sparc32_dma_init(hwdef->dma_base + 16ULL,\n<98> \n<99> slavio_irq[hwdef->le_irq], iommu, &ledma_irq);\n<100> \n<101> \n<102> \n<103> if (graphic_depth != 8 && graphic_depth != 24) {\n<104> \n<105> fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth);\n<106> \n<107> exit (1);\n<108> \n<109> }\n<110> \n<111> tcx_init(ds, hwdef->tcx_base, phys_ram_base + ram_size, ram_size,\n<112> \n<113> hwdef->vram_size, graphic_width, graphic_height, graphic_depth);\n<114> \n<115> \n<116> \n<117> if (nd_table[0].model == NULL\n<118> \n<119> || strcmp(nd_table[0].model, "lance") == 0) {\n<120> \n<121> lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq);\n<122> \n<123> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<124> \n<125> fprintf(stderr, "qemu: Supported NICs: lance\n");\n<126> \n<127> exit (1);\n<128> \n<129> } else {\n<130> \n<131> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<132> \n<133> exit (1);\n<134> \n<135> }\n<136> \n<137> \n<138> \n<139> nvram = m48t59_init(slavio_irq[0], hwdef->nvram_base, 0,\n<140> \n<141> hwdef->nvram_size, 8);\n<142> \n<143> for (i = 0; i < MAX_CPUS; i++) {\n<144> \n<145> slavio_timer_init(hwdef->counter_base +\n<146> \n<147> (target_phys_addr_t)(i * TARGET_PAGE_SIZE),\n<148> \n<149> slavio_cpu_irq[i], 0);\n<150> \n<151> }\n<152> \n<153> slavio_timer_init(hwdef->counter_base + 0x10000ULL,\n<154> \n<155> slavio_irq[hwdef->clock1_irq], 2);\n<156> \n<157> slavio_serial_ms_kbd_init(hwdef->ms_kb_base, slavio_irq[hwdef->ms_kb_irq]);\n<158> \n<159> // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n<160> \n<161> // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n<162> \n<163> slavio_serial_init(hwdef->serial_base, slavio_irq[hwdef->ser_irq],\n<164> \n<165> serial_hds[1], serial_hds[0]);\n<166> \n<167> fdctrl_init(slavio_irq[hwdef->fd_irq], 0, 1, hwdef->fd_base, fd_table);\n<168> \n<169> main_esp = esp_init(bs_table, hwdef->esp_base, espdma, *espdma_irq);\n<170> \n<171> \n<172> \n<173> for (i = 0; i < MAX_DISKS; i++) {\n<174> \n<175> if (bs_table[i]) {\n<176> \n<177> esp_scsi_attach(main_esp, bs_table[i], i);\n<178> \n<179> }\n<180> \n<181> }\n<182> \n<183> \n<184> \n<185> slavio_misc = slavio_misc_init(hwdef->slavio_base, hwdef->power_base,\n<186> \n<187> slavio_irq[hwdef->me_irq]);\n<188> \n<189> if (hwdef->cs_base != (target_phys_addr_t)-1)\n<190> \n<191> cs_init(hwdef->cs_base, hwdef->cs_irq, slavio_intctl);\n<192> \n<193> }\n<194> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_h2645_packet_split(H2645Packet *pkt, const uint8_t *buf, int length,\n<2> \n<3> void *logctx, int is_nalff, int nal_length_size,\n<4> \n<5> enum AVCodecID codec_id)\n<6> \n<7> {\n<8> \n<9> int consumed, ret = 0;\n<10> \n<11> const uint8_t *next_avc = buf + (is_nalff ? 0 : length);\n<12> \n<13> \n<14> \n<15> pkt->nb_nals = 0;\n<16> \n<17> while (length >= 4) {\n<18> \n<19> H2645NAL *nal;\n<20> \n<21> int extract_length = 0;\n<22> \n<23> int skip_trailing_zeros = 1;\n<24> \n<25> \n<26> \n<27> /*\n<28> \n<29> * Only parse an AVC1 length field if one is expected at the current\n<30> \n<31> * buffer position. There are unfortunately streams with multiple\n<32> \n<33> * NAL units covered by the length field. Those NAL units are delimited\n<34> \n<35> * by Annex B start code prefixes. ff_h2645_extract_rbsp() detects it\n<36> \n<37> * correctly and consumes only the first NAL unit. The additional NAL\n<38> \n<39> * units are handled here in the Annex B parsing code.\n<40> \n<41> */\n<42> \n<43> if (buf == next_avc) {\n<44> \n<45> int i;\n<46> \n<47> for (i = 0; i < nal_length_size; i++)\n<48> \n<49> extract_length = (extract_length << 8) | buf[i];\n<50> \n<51> \n<52> \n<53> if (extract_length > length) {\n<54> \n<55> av_log(logctx, AV_LOG_ERROR, "Invalid NAL unit size.\n");\n<56> \n<57> return AVERROR_INVALIDDATA;\n<58> \n<59> }\n<60> \n<61> buf     += nal_length_size;\n<62> \n<63> length  -= nal_length_size;\n<64> \n<65> // keep track of the next AVC1 length field\n<66> \n<67> next_avc = buf + extract_length;\n<68> \n<69> } else {\n<70> \n<71> /*\n<72> \n<73> * expected to return immediately except for streams with mixed\n<74> \n<75> * NAL unit coding\n<76> \n<77> */\n<78> \n<79> int buf_index = find_next_start_code(buf, next_avc);\n<80> \n<81> \n<82> \n<83> buf    += buf_index;\n<84> \n<85> length -= buf_index;\n<86> \n<87> \n<88> \n<89> /*\n<90> \n<91> * break if an AVC1 length field is expected at the current buffer\n<92> \n<93> * position\n<94> \n<95> */\n<96> \n<97> if (buf == next_avc)\n<98> \n<99> continue;\n<100> \n<101> \n<102> \n<103> if (length > 0) {\n<104> \n<105> extract_length = length;\n<106> \n<107> } else if (pkt->nb_nals == 0) {\n<108> \n<109> av_log(logctx, AV_LOG_ERROR, "No NAL unit found\n");\n<110> \n<111> return AVERROR_INVALIDDATA;\n<112> \n<113> } else {\n<114> \n<115> break;\n<116> \n<117> }\n<118> \n<119> }\n<120> \n<121> \n<122> \n<123> if (pkt->nals_allocated < pkt->nb_nals + 1) {\n<124> \n<125> int new_size = pkt->nals_allocated + 1;\n<126> \n<127> H2645NAL *tmp = av_realloc_array(pkt->nals, new_size, sizeof(*tmp));\n<128> \n<129> if (!tmp)\n<130> \n<131> return AVERROR(ENOMEM);\n<132> \n<133> \n<134> \n<135> pkt->nals = tmp;\n<136> \n<137> memset(pkt->nals + pkt->nals_allocated, 0,\n<138> \n<139> (new_size - pkt->nals_allocated) * sizeof(*tmp));\n<140> \n<141> pkt->nals_allocated = new_size;\n<142> \n<143> }\n<144> \n<145> nal = &pkt->nals[pkt->nb_nals++];\n<146> \n<147> \n<148> \n<149> consumed = ff_h2645_extract_rbsp(buf, extract_length, nal);\n<150> \n<151> if (consumed < 0)\n<152> \n<153> return consumed;\n<154> \n<155> \n<156> \n<157> /* see commit 3566042a0 */\n<158> \n<159> if (consumed < length - 3 &&\n<160> \n<161> buf[consumed]     == 0x00 && buf[consumed + 1] == 0x00 &&\n<162> \n<163> buf[consumed + 2] == 0x01 && buf[consumed + 3] == 0xE0)\n<164> \n<165> skip_trailing_zeros = 0;\n<166> \n<167> \n<168> \n<169> nal->size_bits = get_bit_length(nal, skip_trailing_zeros);\n<170> \n<171> \n<172> \n<173> ret = init_get_bits(&nal->gb, nal->data, nal->size_bits);\n<174> \n<175> if (ret < 0)\n<176> \n<177> return ret;\n<178> \n<179> \n<180> \n<181> if (codec_id == AV_CODEC_ID_HEVC)\n<182> \n<183> ret = hevc_parse_nal_header(nal, logctx);\n<184> \n<185> else\n<186> \n<187> ret = h264_parse_nal_header(nal, logctx);\n<188> \n<189> if (ret <= 0) {\n<190> \n<191> if (ret < 0) {\n<192> \n<193> av_log(logctx, AV_LOG_ERROR, "Invalid NAL unit %d, skipping.\n",\n<194> \n<195> nal->type);\n<196> \n<197> }\n<198> \n<199> pkt->nb_nals--;\n<200> \n<201> }\n<202> \n<203> \n<204> \n<205> buf    += consumed;\n<206> \n<207> length -= consumed;\n<208> \n<209> }\n<210> \n<211> \n<212> \n<213> return 0;\n<214> \n<215> }\n<216> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int qcow_create2(const char *filename, int64_t total_size,\n<2> \n<3> const char *backing_file, const char *backing_format,\n<4> \n<5> int flags)\n<6> \n<7> {\n<8> \n<9> \n<10> \n<11> int fd, header_size, backing_filename_len, l1_size, i, shift, l2_bits;\n<12> \n<13> int backing_format_len = 0;\n<14> \n<15> QCowHeader header;\n<16> \n<17> uint64_t tmp, offset;\n<18> \n<19> QCowCreateState s1, *s = &s1;\n<20> \n<21> QCowExtension ext_bf = {0, 0};\n<22> \n<23> \n<24> \n<25> \n<26> \n<27> memset(s, 0, sizeof(*s));\n<28> \n<29> \n<30> \n<31> fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0644);\n<32> \n<33> if (fd < 0)\n<34> \n<35> return -1;\n<36> \n<37> memset(&header, 0, sizeof(header));\n<38> \n<39> header.magic = cpu_to_be32(QCOW_MAGIC);\n<40> \n<41> header.version = cpu_to_be32(QCOW_VERSION);\n<42> \n<43> header.size = cpu_to_be64(total_size * 512);\n<44> \n<45> header_size = sizeof(header);\n<46> \n<47> backing_filename_len = 0;\n<48> \n<49> if (backing_file) {\n<50> \n<51> if (backing_format) {\n<52> \n<53> ext_bf.magic = QCOW_EXT_MAGIC_BACKING_FORMAT;\n<54> \n<55> backing_format_len = strlen(backing_format);\n<56> \n<57> ext_bf.len = (backing_format_len + 7) & ~7;\n<58> \n<59> header_size += ((sizeof(ext_bf) + ext_bf.len + 7) & ~7);\n<60> \n<61> }\n<62> \n<63> header.backing_file_offset = cpu_to_be64(header_size);\n<64> \n<65> backing_filename_len = strlen(backing_file);\n<66> \n<67> header.backing_file_size = cpu_to_be32(backing_filename_len);\n<68> \n<69> header_size += backing_filename_len;\n<70> \n<71> }\n<72> \n<73> s->cluster_bits = 12;  /* 4 KB clusters */\n<74> \n<75> s->cluster_size = 1 << s->cluster_bits;\n<76> \n<77> header.cluster_bits = cpu_to_be32(s->cluster_bits);\n<78> \n<79> header_size = (header_size + 7) & ~7;\n<80> \n<81> if (flags & BLOCK_FLAG_ENCRYPT) {\n<82> \n<83> header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n<84> \n<85> } else {\n<86> \n<87> header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n<88> \n<89> }\n<90> \n<91> l2_bits = s->cluster_bits - 3;\n<92> \n<93> shift = s->cluster_bits + l2_bits;\n<94> \n<95> l1_size = (((total_size * 512) + (1LL << shift) - 1) >> shift);\n<96> \n<97> offset = align_offset(header_size, s->cluster_size);\n<98> \n<99> s->l1_table_offset = offset;\n<100> \n<101> header.l1_table_offset = cpu_to_be64(s->l1_table_offset);\n<102> \n<103> header.l1_size = cpu_to_be32(l1_size);\n<104> \n<105> offset += align_offset(l1_size * sizeof(uint64_t), s->cluster_size);\n<106> \n<107> \n<108> \n<109> s->refcount_table = qemu_mallocz(s->cluster_size);\n<110> \n<111> s->refcount_block = qemu_mallocz(s->cluster_size);\n<112> \n<113> \n<114> \n<115> s->refcount_table_offset = offset;\n<116> \n<117> header.refcount_table_offset = cpu_to_be64(offset);\n<118> \n<119> header.refcount_table_clusters = cpu_to_be32(1);\n<120> \n<121> offset += s->cluster_size;\n<122> \n<123> \n<124> \n<125> s->refcount_table[0] = cpu_to_be64(offset);\n<126> \n<127> s->refcount_block_offset = offset;\n<128> \n<129> offset += s->cluster_size;\n<130> \n<131> \n<132> \n<133> /* update refcounts */\n<134> \n<135> create_refcount_update(s, 0, header_size);\n<136> \n<137> create_refcount_update(s, s->l1_table_offset, l1_size * sizeof(uint64_t));\n<138> \n<139> create_refcount_update(s, s->refcount_table_offset, s->cluster_size);\n<140> \n<141> create_refcount_update(s, s->refcount_block_offset, s->cluster_size);\n<142> \n<143> \n<144> \n<145> /* write all the data */\n<146> \n<147> write(fd, &header, sizeof(header));\n<148> \n<149> if (backing_file) {\n<150> \n<151> if (backing_format_len) {\n<152> \n<153> char zero[16];\n<154> \n<155> int d = ext_bf.len - backing_format_len;\n<156> \n<157> \n<158> \n<159> memset(zero, 0, sizeof(zero));\n<160> \n<161> cpu_to_be32s(&ext_bf.magic);\n<162> \n<163> cpu_to_be32s(&ext_bf.len);\n<164> \n<165> write(fd, &ext_bf, sizeof(ext_bf));\n<166> \n<167> write(fd, backing_format, backing_format_len);\n<168> \n<169> if (d>0) {\n<170> \n<171> write(fd, zero, d);\n<172> \n<173> }\n<174> \n<175> }\n<176> \n<177> write(fd, backing_file, backing_filename_len);\n<178> \n<179> }\n<180> \n<181> lseek(fd, s->l1_table_offset, SEEK_SET);\n<182> \n<183> tmp = 0;\n<184> \n<185> for(i = 0;i < l1_size; i++) {\n<186> \n<187> write(fd, &tmp, sizeof(tmp));\n<188> \n<189> }\n<190> \n<191> lseek(fd, s->refcount_table_offset, SEEK_SET);\n<192> \n<193> write(fd, s->refcount_table, s->cluster_size);\n<194> \n<195> \n<196> \n<197> lseek(fd, s->refcount_block_offset, SEEK_SET);\n<198> \n<199> write(fd, s->refcount_block, s->cluster_size);\n<200> \n<201> \n<202> \n<203> qemu_free(s->refcount_table);\n<204> \n<205> qemu_free(s->refcount_block);\n<206> \n<207> close(fd);\n<208> \n<209> return 0;\n<210> \n<211> }\n<212> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void * jas_malloc ( size_t size ) {\n<2> void * result ;\n<3> JAS_DBGLOG ( 101 , ( "jas_malloc called with %zu\n" , size ) ) ;\n<4> result = malloc ( size ) ;\n<5> JAS_DBGLOG ( 100 , ( "jas_malloc(%zu) -> %p\n" , size , result ) ) ;\n<6> return result ;\n<7> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void mdct512(AC3MDCTContext *mdct, int32_t *out, int16_t *in)\n<2> \n<3> {\n<4> \n<5> int i, re, im, n, n2, n4;\n<6> \n<7> int16_t *rot = mdct->rot_tmp;\n<8> \n<9> IComplex *x  = mdct->cplx_tmp;\n<10> \n<11> \n<12> \n<13> n  = 1 << mdct->nbits;\n<14> \n<15> n2 = n >> 1;\n<16> \n<17> n4 = n >> 2;\n<18> \n<19> \n<20> \n<21> /* shift to simplify computations */\n<22> \n<23> for (i = 0; i <n4; i++)\n<24> \n<25> rot[i] = -in[i + 3*n4];\n<26> \n<27> memcpy(&rot[n4], &in[0], 3*n4*sizeof(*in));\n<28> \n<29> \n<30> \n<31> /* pre rotation */\n<32> \n<33> for (i = 0; i < n4; i++) {\n<34> \n<35> re =  ((int)rot[   2*i] - (int)rot[ n-1-2*i]) >> 1;\n<36> \n<37> im = -((int)rot[n2+2*i] - (int)rot[n2-1-2*i]) >> 1;\n<38> \n<39> CMUL(x[i].re, x[i].im, re, im, -mdct->xcos1[i], mdct->xsin1[i], 15);\n<40> \n<41> }\n<42> \n<43> \n<44> \n<45> fft(mdct, x, mdct->nbits - 2);\n<46> \n<47> \n<48> \n<49> /* post rotation */\n<50> \n<51> for (i = 0; i < n4; i++) {\n<52> \n<53> re = x[i].re;\n<54> \n<55> im = x[i].im;\n<56> \n<57> CMUL(out[n2-1-2*i], out[2*i], re, im, mdct->xsin1[i], mdct->xcos1[i], 0);\n<58> \n<59> }\n<60> \n<61> }\n<62> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void test_qemu_strtoul_overflow(void)\n<2> \n<3> {\n<4> \n<5> const char *str = "99999999999999999999999999999999999999999999";\n<6> \n<7> char f = 'X';\n<8> \n<9> const char *endptr = &f;\n<10> \n<11> unsigned long res = 999;\n<12> \n<13> int err;\n<14> \n<15> \n<16> \n<17> err = qemu_strtoul(str, &endptr, 0, &res);\n<18> \n<19> \n<20> \n<21> g_assert_cmpint(err, ==, -ERANGE);\n<22> \n<23> g_assert_cmpint(res, ==, ULONG_MAX);\n<24> \n<25> g_assert(endptr == str + strlen(str));\n<26> \n<27> }\n<28> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n<2> \n<3> int64_t pos, uint64_t cluster_time,\n<4> \n<5> int is_keyframe, int is_bframe,\n<6> \n<7> int *ptrack, AVPacket **ppkt)\n<8> \n<9> {\n<10> \n<11> int res = 0;\n<12> \n<13> int track;\n<14> \n<15> AVPacket *pkt;\n<16> \n<17> uint8_t *origdata = data;\n<18> \n<19> int16_t block_time;\n<20> \n<21> uint32_t *lace_size = NULL;\n<22> \n<23> int n, flags, laces = 0;\n<24> \n<25> uint64_t num;\n<26> \n<27> \n<28> \n<29> /* first byte(s): tracknum */\n<30> \n<31> if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {\n<32> \n<33> av_log(matroska->ctx, AV_LOG_ERROR, "EBML block data error\n");\n<34> \n<35> av_free(origdata);\n<36> \n<37> return res;\n<38> \n<39> }\n<40> \n<41> data += n;\n<42> \n<43> size -= n;\n<44> \n<45> \n<46> \n<47> /* fetch track from num */\n<48> \n<49> track = matroska_find_track_by_num(matroska, num);\n<50> \n<51> if (ptrack)  *ptrack = track;\n<52> \n<53> if (size <= 3 || track < 0 || track >= matroska->num_tracks) {\n<54> \n<55> av_log(matroska->ctx, AV_LOG_INFO,\n<56> \n<57> "Invalid stream %d or size %u\n", track, size);\n<58> \n<59> av_free(origdata);\n<60> \n<61> return res;\n<62> \n<63> }\n<64> \n<65> if(matroska->ctx->streams[ matroska->tracks[track]->stream_index ]->discard >= AVDISCARD_ALL){\n<66> \n<67> av_free(origdata);\n<68> \n<69> return res;\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> /* block_time (relative to cluster time) */\n<76> \n<77> block_time = (data[0] << 8) | data[1];\n<78> \n<79> data += 2;\n<80> \n<81> size -= 2;\n<82> \n<83> flags = *data;\n<84> \n<85> data += 1;\n<86> \n<87> size -= 1;\n<88> \n<89> if (is_keyframe == -1)\n<90> \n<91> is_keyframe = flags & 1 ? PKT_FLAG_KEY : 0;\n<92> \n<93> switch ((flags & 0x06) >> 1) {\n<94> \n<95> case 0x0: /* no lacing */\n<96> \n<97> laces = 1;\n<98> \n<99> lace_size = av_mallocz(sizeof(int));\n<100> \n<101> lace_size[0] = size;\n<102> \n<103> break;\n<104> \n<105> \n<106> \n<107> case 0x1: /* xiph lacing */\n<108> \n<109> case 0x2: /* fixed-size lacing */\n<110> \n<111> case 0x3: /* EBML lacing */\n<112> \n<113> if (size == 0) {\n<114> \n<115> res = -1;\n<116> \n<117> break;\n<118> \n<119> }\n<120> \n<121> laces = (*data) + 1;\n<122> \n<123> data += 1;\n<124> \n<125> size -= 1;\n<126> \n<127> lace_size = av_mallocz(laces * sizeof(int));\n<128> \n<129> \n<130> \n<131> switch ((flags & 0x06) >> 1) {\n<132> \n<133> case 0x1: /* xiph lacing */ {\n<134> \n<135> uint8_t temp;\n<136> \n<137> uint32_t total = 0;\n<138> \n<139> for (n = 0; res == 0 && n < laces - 1; n++) {\n<140> \n<141> while (1) {\n<142> \n<143> if (size == 0) {\n<144> \n<145> res = -1;\n<146> \n<147> break;\n<148> \n<149> }\n<150> \n<151> temp = *data;\n<152> \n<153> lace_size[n] += temp;\n<154> \n<155> data += 1;\n<156> \n<157> size -= 1;\n<158> \n<159> if (temp != 0xff)\n<160> \n<161> break;\n<162> \n<163> }\n<164> \n<165> total += lace_size[n];\n<166> \n<167> }\n<168> \n<169> lace_size[n] = size - total;\n<170> \n<171> break;\n<172> \n<173> }\n<174> \n<175> \n<176> \n<177> case 0x2: /* fixed-size lacing */\n<178> \n<179> for (n = 0; n < laces; n++)\n<180> \n<181> lace_size[n] = size / laces;\n<182> \n<183> break;\n<184> \n<185> \n<186> \n<187> case 0x3: /* EBML lacing */ {\n<188> \n<189> uint32_t total;\n<190> \n<191> n = matroska_ebmlnum_uint(data, size, &num);\n<192> \n<193> if (n < 0) {\n<194> \n<195> av_log(matroska->ctx, AV_LOG_INFO,\n<196> \n<197> "EBML block data error\n");\n<198> \n<199> break;\n<200> \n<201> }\n<202> \n<203> data += n;\n<204> \n<205> size -= n;\n<206> \n<207> total = lace_size[0] = num;\n<208> \n<209> for (n = 1; res == 0 && n < laces - 1; n++) {\n<210> \n<211> int64_t snum;\n<212> \n<213> int r;\n<214> \n<215> r = matroska_ebmlnum_sint (data, size, &snum);\n<216> \n<217> if (r < 0) {\n<218> \n<219> av_log(matroska->ctx, AV_LOG_INFO,\n<220> \n<221> "EBML block data error\n");\n<222> \n<223> break;\n<224> \n<225> }\n<226> \n<227> data += r;\n<228> \n<229> size -= r;\n<230> \n<231> lace_size[n] = lace_size[n - 1] + snum;\n<232> \n<233> total += lace_size[n];\n<234> \n<235> }\n<236> \n<237> lace_size[n] = size - total;\n<238> \n<239> break;\n<240> \n<241> }\n<242> \n<243> }\n<244> \n<245> break;\n<246> \n<247> }\n<248> \n<249> \n<250> \n<251> if (res == 0) {\n<252> \n<253> int real_v = matroska->tracks[track]->flags & MATROSKA_TRACK_REAL_V;\n<254> \n<255> for (n = 0; n < laces; n++) {\n<256> \n<257> uint64_t timecode = AV_NOPTS_VALUE;\n<258> \n<259> int slice, slices = 1;\n<260> \n<261> \n<262> \n<263> if (real_v) {\n<264> \n<265> slices = *data++ + 1;\n<266> \n<267> lace_size[n]--;\n<268> \n<269> }\n<270> \n<271> if (cluster_time != (uint64_t)-1 && n == 0) {\n<272> \n<273> if (cluster_time + block_time >= 0)\n<274> \n<275> timecode = cluster_time + block_time;\n<276> \n<277> }\n<278> \n<279> /* FIXME: duration */\n<280> \n<281> \n<282> \n<283> for (slice=0; slice<slices; slice++) {\n<284> \n<285> int slice_size, slice_offset = 0;\n<286> \n<287> if (real_v)\n<288> \n<289> slice_offset = rv_offset(data, slice, slices);\n<290> \n<291> if (slice+1 == slices)\n<292> \n<293> slice_size = lace_size[n] - slice_offset;\n<294> \n<295> else\n<296> \n<297> slice_size = rv_offset(data, slice+1, slices) - slice_offset;\n<298> \n<299> pkt = av_mallocz(sizeof(AVPacket));\n<300> \n<301> if (ppkt)  *ppkt = pkt;\n<302> \n<303> /* XXX: prevent data copy... */\n<304> \n<305> if (av_new_packet(pkt, slice_size) < 0) {\n<306> \n<307> res = AVERROR_NOMEM;\n<308> \n<309> n = laces-1;\n<310> \n<311> break;\n<312> \n<313> }\n<314> \n<315> memcpy (pkt->data, data+slice_offset, slice_size);\n<316> \n<317> \n<318> \n<319> if (n == 0)\n<320> \n<321> pkt->flags = is_keyframe;\n<322> \n<323> pkt->stream_index = matroska->tracks[track]->stream_index;\n<324> \n<325> \n<326> \n<327> pkt->pts = timecode;\n<328> \n<329> pkt->pos = pos;\n<330> \n<331> \n<332> \n<333> if (matroska->tracks[track]->flags & MATROSKA_TRACK_REORDER)\n<334> \n<335> matroska_queue_packet_reordered(matroska, pkt, is_bframe);\n<336> \n<337> else\n<338> \n<339> matroska_queue_packet(matroska, pkt);\n<340> \n<341> }\n<342> \n<343> data += lace_size[n];\n<344> \n<345> }\n<346> \n<347> }\n<348> \n<349> \n<350> \n<351> av_free(lace_size);\n<352> \n<353> av_free(origdata);\n<354> \n<355> return res;\n<356> \n<357> }\n<358> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int rle_unpack(unsigned char *src, unsigned char *dest, int len)\n<2> \n<3> {\n<4> \n<5> unsigned char *ps;\n<6> \n<7> unsigned char *pd;\n<8> \n<9> int i, l;\n<10> \n<11> \n<12> \n<13> ps = src;\n<14> \n<15> pd = dest;\n<16> \n<17> if (len & 1)\n<18> \n<19> *pd++ = *ps++;\n<20> \n<21> \n<22> \n<23> len >>= 1;\n<24> \n<25> i = 0;\n<26> \n<27> do {\n<28> \n<29> l = *ps++;\n<30> \n<31> if (l & 0x80) {\n<32> \n<33> l = (l & 0x7F) * 2;\n<34> \n<35> memcpy(pd, ps, l);\n<36> \n<37> ps += l;\n<38> \n<39> pd += l;\n<40> \n<41> } else {\n<42> \n<43> for (i = 0; i < l; i++) {\n<44> \n<45> *pd++ = ps[0];\n<46> \n<47> *pd++ = ps[1];\n<48> \n<49> }\n<50> \n<51> ps += 2;\n<52> \n<53> }\n<54> \n<55> i += l;\n<56> \n<57> } while (i < len);\n<58> \n<59> \n<60> \n<61> return (ps - src);\n<62> \n<63> }\n<64> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int tight_init_stream(VncState *vs, int stream_id,\n<2> \n<3> int level, int strategy)\n<4> \n<5> {\n<6> \n<7> z_streamp zstream = &vs->tight_stream[stream_id];\n<8> \n<9> \n<10> \n<11> if (zstream->opaque == NULL) {\n<12> \n<13> int err;\n<14> \n<15> \n<16> \n<17> VNC_DEBUG("VNC: TIGHT: initializing zlib stream %d\n", stream_id);\n<18> \n<19> VNC_DEBUG("VNC: TIGHT: opaque = %p | vs = %p\n", zstream->opaque, vs);\n<20> \n<21> zstream->zalloc = vnc_zlib_zalloc;\n<22> \n<23> zstream->zfree = vnc_zlib_zfree;\n<24> \n<25> \n<26> \n<27> err = deflateInit2(zstream, level, Z_DEFLATED, MAX_WBITS,\n<28> \n<29> MAX_MEM_LEVEL, strategy);\n<30> \n<31> \n<32> \n<33> if (err != Z_OK) {\n<34> \n<35> fprintf(stderr, "VNC: error initializing zlib\n");\n<36> \n<37> return -1;\n<38> \n<39> }\n<40> \n<41> \n<42> \n<43> vs->tight_levels[stream_id] = level;\n<44> \n<45> zstream->opaque = vs;\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> if (vs->tight_levels[stream_id] != level) {\n<52> \n<53> if (deflateParams(zstream, level, strategy) != Z_OK) {\n<54> \n<55> return -1;\n<56> \n<57> }\n<58> \n<59> vs->tight_levels[stream_id] = level;\n<60> \n<61> }\n<62> \n<63> return 0;\n<64> \n<65> }\n<66> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void test_rfc2231_parser ( void ) {\n<2> const char * input = ";\n<3> key4*=us-ascii''foo" ";\n<4> key*2=ba%" ";\n<5> key2*0=a" ";\n<6> key3*0*=us-ascii'en'xyz" ";\n<7> key*0=\"foo\"" ";\n<8> key2*1*=b%25" ";\n<9> key3*1=plop%" ";\n<10> key*1=baz" ;\n<11> const char * output [ ] = {\n<12> "key" , "foobazba%" , "key2*" , "''ab%25" , "key3*" , "us-ascii'en'xyzplop%25" , "key4*" , "us-ascii''foo" , NULL }\n<13> ;\n<14> struct rfc822_parser_context parser ;\n<15> const char * const * result ;\n<16> unsigned int i ;\n<17> test_begin ( "rfc2231 parser" ) ;\n<18> rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;\n<19> test_assert ( rfc2231_parse ( & parser , & result ) == 0 ) ;\n<20> for ( i = 0 ;\n<21> output [ i ] != NULL && result [ i ] != NULL ;\n<22> i ++ ) test_assert ( strcmp ( output [ i ] , result [ i ] ) == 0 ) ;\n<23> test_assert ( output [ i ] == NULL && result [ i ] == NULL ) ;\n<24> test_end ( ) ;\n<25> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> sorecvfrom(struct socket *so)\n<2> \n<3> {\n<4> \n<5> struct sockaddr_storage addr;\n<6> \n<7> socklen_t addrlen = sizeof(struct sockaddr_storage);\n<8> \n<9> \n<10> \n<11> DEBUG_CALL("sorecvfrom");\n<12> \n<13> DEBUG_ARG("so = %p", so);\n<14> \n<15> \n<16> \n<17> if (so->so_type == IPPROTO_ICMP) {   /* This is a "ping" reply */\n<18> \n<19> char buff[256];\n<20> \n<21> int len;\n<22> \n<23> \n<24> \n<25> len = recvfrom(so->s, buff, 256, 0,\n<26> \n<27> (struct sockaddr *)&addr, &addrlen);\n<28> \n<29> /* XXX Check if reply is "correct"? */\n<30> \n<31> \n<32> \n<33> if(len == -1 || len == 0) {\n<34> \n<35> u_char code=ICMP_UNREACH_PORT;\n<36> \n<37> \n<38> \n<39> if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n<40> \n<41> else if(errno == ENETUNREACH) code=ICMP_UNREACH_NET;\n<42> \n<43> \n<44> \n<45> DEBUG_MISC((dfd," udp icmp rx errno = %d-%s\n",\n<46> \n<47> errno,strerror(errno)));\n<48> \n<49> icmp_error(so->so_m, ICMP_UNREACH,code, 0,strerror(errno));\n<50> \n<51> } else {\n<52> \n<53> icmp_reflect(so->so_m);\n<54> \n<55> so->so_m = NULL; /* Don't m_free() it again! */\n<56> \n<57> }\n<58> \n<59> /* No need for this socket anymore, udp_detach it */\n<60> \n<61> udp_detach(so);\n<62> \n<63> } else {                            	/* A "normal" UDP packet */\n<64> \n<65> struct mbuf *m;\n<66> \n<67> int len;\n<68> \n<69> #ifdef _WIN32\n<70> \n<71> unsigned long n;\n<72> \n<73> #else\n<74> \n<75> int n;\n<76> \n<77> #endif\n<78> \n<79> \n<80> \n<81> m = m_get(so->slirp);\n<82> \n<83> if (!m) {\n<84> \n<85> return;\n<86> \n<87> }\n<88> \n<89> m->m_data += IF_MAXLINKHDR;\n<90> \n<91> \n<92> \n<93> /*\n<94> \n<95> * XXX Shouldn't FIONREAD packets destined for port 53,\n<96> \n<97> * but I don't know the max packet size for DNS lookups\n<98> \n<99> */\n<100> \n<101> len = M_FREEROOM(m);\n<102> \n<103> /* if (so->so_fport != htons(53)) { */\n<104> \n<105> ioctlsocket(so->s, FIONREAD, &n);\n<106> \n<107> \n<108> \n<109> if (n > len) {\n<110> \n<111> n = (m->m_data - m->m_dat) + m->m_len + n + 1;\n<112> \n<113> m_inc(m, n);\n<114> \n<115> len = M_FREEROOM(m);\n<116> \n<117> }\n<118> \n<119> /* } */\n<120> \n<121> \n<122> \n<123> m->m_len = recvfrom(so->s, m->m_data, len, 0,\n<124> \n<125> (struct sockaddr *)&addr, &addrlen);\n<126> \n<127> DEBUG_MISC((dfd, " did recvfrom %d, errno = %d-%s\n",\n<128> \n<129> m->m_len, errno,strerror(errno)));\n<130> \n<131> if(m->m_len<0) {\n<132> \n<133> u_char code=ICMP_UNREACH_PORT;\n<134> \n<135> \n<136> \n<137> if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n<138> \n<139> else if(errno == ENETUNREACH) code=ICMP_UNREACH_NET;\n<140> \n<141> \n<142> \n<143> DEBUG_MISC((dfd," rx error, tx icmp ICMP_UNREACH:%i\n", code));\n<144> \n<145> icmp_error(so->so_m, ICMP_UNREACH,code, 0,strerror(errno));\n<146> \n<147> m_free(m);\n<148> \n<149> } else {\n<150> \n<151> /*\n<152> \n<153> * Hack: domain name lookup will be used the most for UDP,\n<154> \n<155> * and since they'll only be used once there's no need\n<156> \n<157> * for the 4 minute (or whatever) timeout... So we time them\n<158> \n<159> * out much quicker (10 seconds  for now...)\n<160> \n<161> */\n<162> \n<163> if (so->so_expire) {\n<164> \n<165> if (so->so_fport == htons(53))\n<166> \n<167> so->so_expire = curtime + SO_EXPIREFAST;\n<168> \n<169> else\n<170> \n<171> so->so_expire = curtime + SO_EXPIRE;\n<172> \n<173> }\n<174> \n<175> \n<176> \n<177> /*\n<178> \n<179> * If this packet was destined for CTL_ADDR,\n<180> \n<181> * make it look like that's where it came from, done by udp_output\n<182> \n<183> */\n<184> \n<185> switch (so->so_ffamily) {\n<186> \n<187> case AF_INET:\n<188> \n<189> udp_output(so, m, (struct sockaddr_in *) &addr);\n<190> \n<191> break;\n<192> \n<193> default:\n<194> \n<195> break;\n<196> \n<197> }\n<198> \n<199> } /* rx error */\n<200> \n<201> } /* if ping packet */\n<202> \n<203> }\n<204> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int av_image_fill_pointers(uint8_t *data[4], enum PixelFormat pix_fmt, int height,\n<2> \n<3> uint8_t *ptr, const int linesizes[4])\n<4> \n<5> {\n<6> \n<7> int i, total_size, size[4], has_plane[4];\n<8> \n<9> \n<10> \n<11> const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n<12> \n<13> memset(data     , 0, sizeof(data[0])*4);\n<14> \n<15> memset(size     , 0, sizeof(size));\n<16> \n<17> memset(has_plane, 0, sizeof(has_plane));\n<18> \n<19> \n<20> \n<21> if (desc->flags & PIX_FMT_HWACCEL)\n<22> \n<23> return AVERROR(EINVAL);\n<24> \n<25> \n<26> \n<27> data[0] = ptr;\n<28> \n<29> size[0] = linesizes[0] * height;\n<30> \n<31> \n<32> \n<33> if (desc->flags & PIX_FMT_PAL) {\n<34> \n<35> size[0] = (size[0] + 3) & ~3;\n<36> \n<37> data[1] = ptr + size[0]; /* palette is stored here as 256 32 bits words */\n<38> \n<39> return size[0] + 256 * 4;\n<40> \n<41> }\n<42> \n<43> \n<44> \n<45> for (i = 0; i < 4; i++)\n<46> \n<47> has_plane[desc->comp[i].plane] = 1;\n<48> \n<49> \n<50> \n<51> total_size = size[0];\n<52> \n<53> for (i = 1; has_plane[i] && i < 4; i++) {\n<54> \n<55> int h, s = (i == 1 || i == 2) ? desc->log2_chroma_h : 0;\n<56> \n<57> data[i] = data[i-1] + size[i-1];\n<58> \n<59> h = (height + (1 << s) - 1) >> s;\n<60> \n<61> size[i] = h * linesizes[i];\n<62> \n<63> total_size += size[i];\n<64> \n<65> }\n<66> \n<67> \n<68> \n<69> return total_size;\n<70> \n<71> }\n<72> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void onenand_reset(OneNANDState *s, int cold)\n<2> \n<3> {\n<4> \n<5> memset(&s->addr, 0, sizeof(s->addr));\n<6> \n<7> s->command = 0;\n<8> \n<9> s->count = 1;\n<10> \n<11> s->bufaddr = 0;\n<12> \n<13> s->config[0] = 0x40c0;\n<14> \n<15> s->config[1] = 0x0000;\n<16> \n<17> onenand_intr_update(s);\n<18> \n<19> qemu_irq_raise(s->rdy);\n<20> \n<21> s->status = 0x0000;\n<22> \n<23> s->intstatus = cold ? 0x8080 : 0x8010;\n<24> \n<25> s->unladdr[0] = 0;\n<26> \n<27> s->unladdr[1] = 0;\n<28> \n<29> s->wpstatus = 0x0002;\n<30> \n<31> s->cycle = 0;\n<32> \n<33> s->otpmode = 0;\n<34> \n<35> s->bdrv_cur = s->bdrv;\n<36> \n<37> s->current = s->image;\n<38> \n<39> s->secs_cur = s->secs;\n<40> \n<41> \n<42> \n<43> if (cold) {\n<44> \n<45> /* Lock the whole flash */\n<46> \n<47> memset(s->blockwp, ONEN_LOCK_LOCKED, s->blocks);\n<48> \n<49> \n<50> \n<51> if (s->bdrv_cur && bdrv_read(s->bdrv_cur, 0, s->boot[0], 8) < 0) {\n<52> \n<53> hw_error("%s: Loading the BootRAM failed.\n", __func__);\n<54> \n<55> }\n<56> \n<57> }\n<58> \n<59> }\n<60> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static unsigned int dec_adds_r(DisasContext *dc)\n<2> \n<3> {\n<4> \n<5> TCGv t0;\n<6> \n<7> int size = memsize_z(dc);\n<8> \n<9> DIS(fprintf (logfile, "adds.%c $r%u, $r%u\n",\n<10> \n<11> memsize_char(size),\n<12> \n<13> dc->op1, dc->op2));\n<14> \n<15> \n<16> \n<17> cris_cc_mask(dc, CC_MASK_NZVC);\n<18> \n<19> t0 = tcg_temp_new(TCG_TYPE_TL);\n<20> \n<21> /* Size can only be qi or hi.  */\n<22> \n<23> t_gen_sext(t0, cpu_R[dc->op1], size);\n<24> \n<25> cris_alu(dc, CC_OP_ADD,\n<26> \n<27> cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n<28> \n<29> tcg_temp_free(t0);\n<30> \n<31> return 2;\n<32> \n<33> }\n<34> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> qcrypto_block_luks_open(QCryptoBlock *block,\n<2> \n<3> QCryptoBlockOpenOptions *options,\n<4> \n<5> const char *optprefix,\n<6> \n<7> QCryptoBlockReadFunc readfunc,\n<8> \n<9> void *opaque,\n<10> \n<11> unsigned int flags,\n<12> \n<13> Error **errp)\n<14> \n<15> {\n<16> \n<17> QCryptoBlockLUKS *luks;\n<18> \n<19> Error *local_err = NULL;\n<20> \n<21> int ret = 0;\n<22> \n<23> size_t i;\n<24> \n<25> ssize_t rv;\n<26> \n<27> uint8_t *masterkey = NULL;\n<28> \n<29> size_t masterkeylen;\n<30> \n<31> char *ivgen_name, *ivhash_name;\n<32> \n<33> QCryptoCipherMode ciphermode;\n<34> \n<35> QCryptoCipherAlgorithm cipheralg;\n<36> \n<37> QCryptoIVGenAlgorithm ivalg;\n<38> \n<39> QCryptoCipherAlgorithm ivcipheralg;\n<40> \n<41> QCryptoHashAlgorithm hash;\n<42> \n<43> QCryptoHashAlgorithm ivhash;\n<44> \n<45> char *password = NULL;\n<46> \n<47> \n<48> \n<49> if (!(flags & QCRYPTO_BLOCK_OPEN_NO_IO)) {\n<50> \n<51> if (!options->u.luks.key_secret) {\n<52> \n<53> error_setg(errp, "Parameter '%skey-secret' is required for cipher",\n<54> \n<55> optprefix ? optprefix : "");\n<56> \n<57> return -1;\n<58> \n<59> }\n<60> \n<61> password = qcrypto_secret_lookup_as_utf8(\n<62> \n<63> options->u.luks.key_secret, errp);\n<64> \n<65> if (!password) {\n<66> \n<67> return -1;\n<68> \n<69> }\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> luks = g_new0(QCryptoBlockLUKS, 1);\n<76> \n<77> block->opaque = luks;\n<78> \n<79> \n<80> \n<81> /* Read the entire LUKS header, minus the key material from\n<82> \n<83> * the underlying device */\n<84> \n<85> rv = readfunc(block, 0,\n<86> \n<87> (uint8_t *)&luks->header,\n<88> \n<89> sizeof(luks->header),\n<90> \n<91> opaque,\n<92> \n<93> errp);\n<94> \n<95> if (rv < 0) {\n<96> \n<97> ret = rv;\n<98> \n<99> goto fail;\n<100> \n<101> }\n<102> \n<103> \n<104> \n<105> /* The header is always stored in big-endian format, so\n<106> \n<107> * convert everything to native */\n<108> \n<109> be16_to_cpus(&luks->header.version);\n<110> \n<111> be32_to_cpus(&luks->header.payload_offset);\n<112> \n<113> be32_to_cpus(&luks->header.key_bytes);\n<114> \n<115> be32_to_cpus(&luks->header.master_key_iterations);\n<116> \n<117> \n<118> \n<119> for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n<120> \n<121> be32_to_cpus(&luks->header.key_slots[i].active);\n<122> \n<123> be32_to_cpus(&luks->header.key_slots[i].iterations);\n<124> \n<125> be32_to_cpus(&luks->header.key_slots[i].key_offset);\n<126> \n<127> be32_to_cpus(&luks->header.key_slots[i].stripes);\n<128> \n<129> }\n<130> \n<131> \n<132> \n<133> if (memcmp(luks->header.magic, qcrypto_block_luks_magic,\n<134> \n<135> QCRYPTO_BLOCK_LUKS_MAGIC_LEN) != 0) {\n<136> \n<137> error_setg(errp, "Volume is not in LUKS format");\n<138> \n<139> ret = -EINVAL;\n<140> \n<141> goto fail;\n<142> \n<143> }\n<144> \n<145> if (luks->header.version != QCRYPTO_BLOCK_LUKS_VERSION) {\n<146> \n<147> error_setg(errp, "LUKS version %" PRIu32 " is not supported",\n<148> \n<149> luks->header.version);\n<150> \n<151> ret = -ENOTSUP;\n<152> \n<153> goto fail;\n<154> \n<155> }\n<156> \n<157> \n<158> \n<159> /*\n<160> \n<161> * The cipher_mode header contains a string that we have\n<162> \n<163> * to further parse, of the format\n<164> \n<165> *\n<166> \n<167> *    <cipher-mode>-<iv-generator>[:<iv-hash>]\n<168> \n<169> *\n<170> \n<171> * eg  cbc-essiv:sha256, cbc-plain64\n<172> \n<173> */\n<174> \n<175> ivgen_name = strchr(luks->header.cipher_mode, '-');\n<176> \n<177> if (!ivgen_name) {\n<178> \n<179> ret = -EINVAL;\n<180> \n<181> error_setg(errp, "Unexpected cipher mode string format %s",\n<182> \n<183> luks->header.cipher_mode);\n<184> \n<185> goto fail;\n<186> \n<187> }\n<188> \n<189> *ivgen_name = '\0';\n<190> \n<191> ivgen_name++;\n<192> \n<193> \n<194> \n<195> ivhash_name = strchr(ivgen_name, ':');\n<196> \n<197> if (!ivhash_name) {\n<198> \n<199> ivhash = 0;\n<200> \n<201> } else {\n<202> \n<203> *ivhash_name = '\0';\n<204> \n<205> ivhash_name++;\n<206> \n<207> \n<208> \n<209> ivhash = qcrypto_block_luks_hash_name_lookup(ivhash_name,\n<210> \n<211> &local_err);\n<212> \n<213> if (local_err) {\n<214> \n<215> ret = -ENOTSUP;\n<216> \n<217> error_propagate(errp, local_err);\n<218> \n<219> goto fail;\n<220> \n<221> }\n<222> \n<223> }\n<224> \n<225> \n<226> \n<227> ciphermode = qcrypto_block_luks_cipher_mode_lookup(luks->header.cipher_mode,\n<228> \n<229> &local_err);\n<230> \n<231> if (local_err) {\n<232> \n<233> ret = -ENOTSUP;\n<234> \n<235> error_propagate(errp, local_err);\n<236> \n<237> goto fail;\n<238> \n<239> }\n<240> \n<241> \n<242> \n<243> cipheralg = qcrypto_block_luks_cipher_name_lookup(luks->header.cipher_name,\n<244> \n<245> ciphermode,\n<246> \n<247> luks->header.key_bytes,\n<248> \n<249> &local_err);\n<250> \n<251> if (local_err) {\n<252> \n<253> ret = -ENOTSUP;\n<254> \n<255> error_propagate(errp, local_err);\n<256> \n<257> goto fail;\n<258> \n<259> }\n<260> \n<261> \n<262> \n<263> hash = qcrypto_block_luks_hash_name_lookup(luks->header.hash_spec,\n<264> \n<265> &local_err);\n<266> \n<267> if (local_err) {\n<268> \n<269> ret = -ENOTSUP;\n<270> \n<271> error_propagate(errp, local_err);\n<272> \n<273> goto fail;\n<274> \n<275> }\n<276> \n<277> \n<278> \n<279> ivalg = qcrypto_block_luks_ivgen_name_lookup(ivgen_name,\n<280> \n<281> &local_err);\n<282> \n<283> if (local_err) {\n<284> \n<285> ret = -ENOTSUP;\n<286> \n<287> error_propagate(errp, local_err);\n<288> \n<289> goto fail;\n<290> \n<291> }\n<292> \n<293> \n<294> \n<295> if (ivalg == QCRYPTO_IVGEN_ALG_ESSIV) {\n<296> \n<297> if (!ivhash_name) {\n<298> \n<299> ret = -EINVAL;\n<300> \n<301> error_setg(errp, "Missing IV generator hash specification");\n<302> \n<303> goto fail;\n<304> \n<305> }\n<306> \n<307> ivcipheralg = qcrypto_block_luks_essiv_cipher(cipheralg,\n<308> \n<309> ivhash,\n<310> \n<311> &local_err);\n<312> \n<313> if (local_err) {\n<314> \n<315> ret = -ENOTSUP;\n<316> \n<317> error_propagate(errp, local_err);\n<318> \n<319> goto fail;\n<320> \n<321> }\n<322> \n<323> } else {\n<324> \n<325> /* Note we parsed the ivhash_name earlier in the cipher_mode\n<326> \n<327> * spec string even with plain/plain64 ivgens, but we\n<328> \n<329> * will ignore it, since it is irrelevant for these ivgens.\n<330> \n<331> * This is for compat with dm-crypt which will silently\n<332> \n<333> * ignore hash names with these ivgens rather than report\n<334> \n<335> * an error about the invalid usage\n<336> \n<337> */\n<338> \n<339> ivcipheralg = cipheralg;\n<340> \n<341> }\n<342> \n<343> \n<344> \n<345> if (!(flags & QCRYPTO_BLOCK_OPEN_NO_IO)) {\n<346> \n<347> /* Try to find which key slot our password is valid for\n<348> \n<349> * and unlock the master key from that slot.\n<350> \n<351> */\n<352> \n<353> if (qcrypto_block_luks_find_key(block,\n<354> \n<355> password,\n<356> \n<357> cipheralg, ciphermode,\n<358> \n<359> hash,\n<360> \n<361> ivalg,\n<362> \n<363> ivcipheralg,\n<364> \n<365> ivhash,\n<366> \n<367> &masterkey, &masterkeylen,\n<368> \n<369> readfunc, opaque,\n<370> \n<371> errp) < 0) {\n<372> \n<373> ret = -EACCES;\n<374> \n<375> goto fail;\n<376> \n<377> }\n<378> \n<379> \n<380> \n<381> /* We have a valid master key now, so can setup the\n<382> \n<383> * block device payload decryption objects\n<384> \n<385> */\n<386> \n<387> block->kdfhash = hash;\n<388> \n<389> block->niv = qcrypto_cipher_get_iv_len(cipheralg,\n<390> \n<391> ciphermode);\n<392> \n<393> block->ivgen = qcrypto_ivgen_new(ivalg,\n<394> \n<395> ivcipheralg,\n<396> \n<397> ivhash,\n<398> \n<399> masterkey, masterkeylen,\n<400> \n<401> errp);\n<402> \n<403> if (!block->ivgen) {\n<404> \n<405> ret = -ENOTSUP;\n<406> \n<407> goto fail;\n<408> \n<409> }\n<410> \n<411> \n<412> \n<413> block->cipher = qcrypto_cipher_new(cipheralg,\n<414> \n<415> ciphermode,\n<416> \n<417> masterkey, masterkeylen,\n<418> \n<419> errp);\n<420> \n<421> if (!block->cipher) {\n<422> \n<423> ret = -ENOTSUP;\n<424> \n<425> goto fail;\n<426> \n<427> }\n<428> \n<429> }\n<430> \n<431> \n<432> \n<433> block->payload_offset = luks->header.payload_offset *\n<434> \n<435> QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n<436> \n<437> \n<438> \n<439> luks->cipher_alg = cipheralg;\n<440> \n<441> luks->cipher_mode = ciphermode;\n<442> \n<443> luks->ivgen_alg = ivalg;\n<444> \n<445> luks->ivgen_hash_alg = ivhash;\n<446> \n<447> luks->hash_alg = hash;\n<448> \n<449> \n<450> \n<451> g_free(masterkey);\n<452> \n<453> g_free(password);\n<454> \n<455> \n<456> \n<457> return 0;\n<458> \n<459> \n<460> \n<461> fail:\n<462> \n<463> g_free(masterkey);\n<464> \n<465> qcrypto_cipher_free(block->cipher);\n<466> \n<467> qcrypto_ivgen_free(block->ivgen);\n<468> \n<469> g_free(luks);\n<470> \n<471> g_free(password);\n<472> \n<473> return ret;\n<474> \n<475> }\n<476> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline void mix_2f_2r_to_stereo(AC3DecodeContext *ctx)\n<2> \n<3> {\n<4> \n<5> int i;\n<6> \n<7> float (*output)[256] = ctx->audio_block.block_output;\n<8> \n<9> \n<10> \n<11> for (i = 0; i < 256; i++) {\n<12> \n<13> output[1][i] += output[3][i];\n<14> \n<15> output[2][i] += output[4][i];\n<16> \n<17> }\n<18> \n<19> memset(output[3], 0, sizeof(output[3]));\n<20> \n<21> memset(output[4], 0, sizeof(output[4]));\n<22> \n<23> }\n<24> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static PCIDevice *do_pci_register_device(PCIDevice *pci_dev, PCIBus *bus,\n<2> \n<3> const char *name, int devfn,\n<4> \n<5> PCIConfigReadFunc *config_read,\n<6> \n<7> PCIConfigWriteFunc *config_write)\n<8> \n<9> {\n<10> \n<11> if (devfn < 0) {\n<12> \n<13> for(devfn = bus->devfn_min ; devfn < 256; devfn += 8) {\n<14> \n<15> if (!bus->devices[devfn])\n<16> \n<17> goto found;\n<18> \n<19> }\n<20> \n<21> return NULL;\n<22> \n<23> found: ;\n<24> \n<25> } else if (bus->devices[devfn]) {\n<26> \n<27> return NULL;\n<28> \n<29> }\n<30> \n<31> pci_dev->bus = bus;\n<32> \n<33> pci_dev->devfn = devfn;\n<34> \n<35> pstrcpy(pci_dev->name, sizeof(pci_dev->name), name);\n<36> \n<37> memset(pci_dev->irq_state, 0, sizeof(pci_dev->irq_state));\n<38> \n<39> pci_config_alloc(pci_dev);\n<40> \n<41> pci_set_default_subsystem_id(pci_dev);\n<42> \n<43> pci_init_cmask(pci_dev);\n<44> \n<45> pci_init_wmask(pci_dev);\n<46> \n<47> \n<48> \n<49> if (!config_read)\n<50> \n<51> config_read = pci_default_read_config;\n<52> \n<53> if (!config_write)\n<54> \n<55> config_write = pci_default_write_config;\n<56> \n<57> pci_dev->config_read = config_read;\n<58> \n<59> pci_dev->config_write = config_write;\n<60> \n<61> bus->devices[devfn] = pci_dev;\n<62> \n<63> pci_dev->irq = qemu_allocate_irqs(pci_set_irq, pci_dev, PCI_NUM_PINS);\n<64> \n<65> pci_dev->version_id = 2; /* Current pci device vmstate version */\n<66> \n<67> return pci_dev;\n<68> \n<69> }\n<70> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int get_segment (CPUState *env, mmu_ctx_t *ctx,\n<2> \n<3> target_ulong eaddr, int rw, int type)\n<4> \n<5> {\n<6> \n<7> target_phys_addr_t sdr, hash, mask, sdr_mask, htab_mask;\n<8> \n<9> target_ulong sr, vsid, vsid_mask, pgidx, page_mask;\n<10> \n<11> #if defined(TARGET_PPC64)\n<12> \n<13> int attr;\n<14> \n<15> #endif\n<16> \n<17> int ds, nx, vsid_sh, sdr_sh;\n<18> \n<19> int ret, ret2;\n<20> \n<21> \n<22> \n<23> #if defined(TARGET_PPC64)\n<24> \n<25> if (env->mmu_model == POWERPC_MMU_64B) {\n<26> \n<27> #if defined (DEBUG_MMU)\n<28> \n<29> if (loglevel != 0) {\n<30> \n<31> fprintf(logfile, "Check SLBs\n");\n<32> \n<33> }\n<34> \n<35> #endif\n<36> \n<37> ret = slb_lookup(env, eaddr, &vsid, &page_mask, &attr);\n<38> \n<39> if (ret < 0)\n<40> \n<41> return ret;\n<42> \n<43> ctx->key = ((attr & 0x40) && msr_pr == 1) ||\n<44> \n<45> ((attr & 0x80) && msr_pr == 0) ? 1 : 0;\n<46> \n<47> ds = 0;\n<48> \n<49> nx = attr & 0x20 ? 1 : 0;\n<50> \n<51> vsid_mask = 0x00003FFFFFFFFF80ULL;\n<52> \n<53> vsid_sh = 7;\n<54> \n<55> sdr_sh = 18;\n<56> \n<57> sdr_mask = 0x3FF80;\n<58> \n<59> } else\n<60> \n<61> #endif /* defined(TARGET_PPC64) */\n<62> \n<63> {\n<64> \n<65> sr = env->sr[eaddr >> 28];\n<66> \n<67> page_mask = 0x0FFFFFFF;\n<68> \n<69> ctx->key = (((sr & 0x20000000) && msr_pr == 1) ||\n<70> \n<71> ((sr & 0x40000000) && msr_pr == 0)) ? 1 : 0;\n<72> \n<73> ds = sr & 0x80000000 ? 1 : 0;\n<74> \n<75> nx = sr & 0x10000000 ? 1 : 0;\n<76> \n<77> vsid = sr & 0x00FFFFFF;\n<78> \n<79> vsid_mask = 0x01FFFFC0;\n<80> \n<81> vsid_sh = 6;\n<82> \n<83> sdr_sh = 16;\n<84> \n<85> sdr_mask = 0xFFC0;\n<86> \n<87> #if defined (DEBUG_MMU)\n<88> \n<89> if (loglevel != 0) {\n<90> \n<91> fprintf(logfile, "Check segment v=0x" ADDRX " %d 0x" ADDRX\n<92> \n<93> " nip=0x" ADDRX " lr=0x" ADDRX\n<94> \n<95> " ir=%d dr=%d pr=%d %d t=%d\n",\n<96> \n<97> eaddr, (int)(eaddr >> 28), sr, env->nip,\n<98> \n<99> env->lr, msr_ir, msr_dr, msr_pr, rw, type);\n<100> \n<101> }\n<102> \n<103> #endif\n<104> \n<105> }\n<106> \n<107> #if defined (DEBUG_MMU)\n<108> \n<109> if (loglevel != 0) {\n<110> \n<111> fprintf(logfile, "pte segment: key=%d ds %d nx %d vsid " ADDRX "\n",\n<112> \n<113> ctx->key, ds, nx, vsid);\n<114> \n<115> }\n<116> \n<117> #endif\n<118> \n<119> ret = -1;\n<120> \n<121> if (!ds) {\n<122> \n<123> /* Check if instruction fetch is allowed, if needed */\n<124> \n<125> if (type != ACCESS_CODE || nx == 0) {\n<126> \n<127> /* Page address translation */\n<128> \n<129> /* Primary table address */\n<130> \n<131> sdr = env->sdr1;\n<132> \n<133> pgidx = (eaddr & page_mask) >> TARGET_PAGE_BITS;\n<134> \n<135> #if defined(TARGET_PPC64)\n<136> \n<137> if (env->mmu_model == POWERPC_MMU_64B) {\n<138> \n<139> htab_mask = 0x0FFFFFFF >> (28 - (sdr & 0x1F));\n<140> \n<141> /* XXX: this is false for 1 TB segments */\n<142> \n<143> hash = ((vsid ^ pgidx) << vsid_sh) & vsid_mask;\n<144> \n<145> } else\n<146> \n<147> #endif\n<148> \n<149> {\n<150> \n<151> htab_mask = sdr & 0x000001FF;\n<152> \n<153> hash = ((vsid ^ pgidx) << vsid_sh) & vsid_mask;\n<154> \n<155> }\n<156> \n<157> mask = (htab_mask << sdr_sh) | sdr_mask;\n<158> \n<159> #if defined (DEBUG_MMU)\n<160> \n<161> if (loglevel != 0) {\n<162> \n<163> fprintf(logfile, "sdr " PADDRX " sh %d hash " PADDRX " mask "\n<164> \n<165> PADDRX " " ADDRX "\n", sdr, sdr_sh, hash, mask,\n<166> \n<167> page_mask);\n<168> \n<169> }\n<170> \n<171> #endif\n<172> \n<173> ctx->pg_addr[0] = get_pgaddr(sdr, sdr_sh, hash, mask);\n<174> \n<175> /* Secondary table address */\n<176> \n<177> hash = (~hash) & vsid_mask;\n<178> \n<179> #if defined (DEBUG_MMU)\n<180> \n<181> if (loglevel != 0) {\n<182> \n<183> fprintf(logfile, "sdr " PADDRX " sh %d hash " PADDRX " mask "\n<184> \n<185> PADDRX "\n", sdr, sdr_sh, hash, mask);\n<186> \n<187> }\n<188> \n<189> #endif\n<190> \n<191> ctx->pg_addr[1] = get_pgaddr(sdr, sdr_sh, hash, mask);\n<192> \n<193> #if defined(TARGET_PPC64)\n<194> \n<195> if (env->mmu_model == POWERPC_MMU_64B) {\n<196> \n<197> /* Only 5 bits of the page index are used in the AVPN */\n<198> \n<199> ctx->ptem = (vsid << 12) | ((pgidx >> 4) & 0x0F80);\n<200> \n<201> } else\n<202> \n<203> #endif\n<204> \n<205> {\n<206> \n<207> ctx->ptem = (vsid << 7) | (pgidx >> 10);\n<208> \n<209> }\n<210> \n<211> /* Initialize real address with an invalid value */\n<212> \n<213> ctx->raddr = (target_ulong)-1;\n<214> \n<215> if (unlikely(env->mmu_model == POWERPC_MMU_SOFT_6xx ||\n<216> \n<217> env->mmu_model == POWERPC_MMU_SOFT_74xx)) {\n<218> \n<219> /* Software TLB search */\n<220> \n<221> ret = ppc6xx_tlb_check(env, ctx, eaddr, rw, type);\n<222> \n<223> } else {\n<224> \n<225> #if defined (DEBUG_MMU)\n<226> \n<227> if (loglevel != 0) {\n<228> \n<229> fprintf(logfile, "0 sdr1=0x" PADDRX " vsid=0x%06x "\n<230> \n<231> "api=0x%04x hash=0x%07x pg_addr=0x" PADDRX "\n",\n<232> \n<233> sdr, (uint32_t)vsid, (uint32_t)pgidx,\n<234> \n<235> (uint32_t)hash, ctx->pg_addr[0]);\n<236> \n<237> }\n<238> \n<239> #endif\n<240> \n<241> /* Primary table lookup */\n<242> \n<243> ret = find_pte(env, ctx, 0, rw);\n<244> \n<245> if (ret < 0) {\n<246> \n<247> /* Secondary table lookup */\n<248> \n<249> #if defined (DEBUG_MMU)\n<250> \n<251> if (eaddr != 0xEFFFFFFF && loglevel != 0) {\n<252> \n<253> fprintf(logfile,\n<254> \n<255> "1 sdr1=0x" PADDRX " vsid=0x%06x api=0x%04x "\n<256> \n<257> "hash=0x%05x pg_addr=0x" PADDRX "\n",\n<258> \n<259> sdr, (uint32_t)vsid, (uint32_t)pgidx,\n<260> \n<261> (uint32_t)hash, ctx->pg_addr[1]);\n<262> \n<263> }\n<264> \n<265> #endif\n<266> \n<267> ret2 = find_pte(env, ctx, 1, rw);\n<268> \n<269> if (ret2 != -1)\n<270> \n<271> ret = ret2;\n<272> \n<273> }\n<274> \n<275> }\n<276> \n<277> #if defined (DEBUG_MMU)\n<278> \n<279> if (loglevel != 0) {\n<280> \n<281> target_phys_addr_t curaddr;\n<282> \n<283> uint32_t a0, a1, a2, a3;\n<284> \n<285> fprintf(logfile,\n<286> \n<287> "Page table: " PADDRX " len " PADDRX "\n",\n<288> \n<289> sdr, mask + 0x80);\n<290> \n<291> for (curaddr = sdr; curaddr < (sdr + mask + 0x80);\n<292> \n<293> curaddr += 16) {\n<294> \n<295> a0 = ldl_phys(curaddr);\n<296> \n<297> a1 = ldl_phys(curaddr + 4);\n<298> \n<299> a2 = ldl_phys(curaddr + 8);\n<300> \n<301> a3 = ldl_phys(curaddr + 12);\n<302> \n<303> if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) {\n<304> \n<305> fprintf(logfile,\n<306> \n<307> PADDRX ": %08x %08x %08x %08x\n",\n<308> \n<309> curaddr, a0, a1, a2, a3);\n<310> \n<311> }\n<312> \n<313> }\n<314> \n<315> }\n<316> \n<317> #endif\n<318> \n<319> } else {\n<320> \n<321> #if defined (DEBUG_MMU)\n<322> \n<323> if (loglevel != 0)\n<324> \n<325> fprintf(logfile, "No access allowed\n");\n<326> \n<327> #endif\n<328> \n<329> ret = -3;\n<330> \n<331> }\n<332> \n<333> } else {\n<334> \n<335> #if defined (DEBUG_MMU)\n<336> \n<337> if (loglevel != 0)\n<338> \n<339> fprintf(logfile, "direct store...\n");\n<340> \n<341> #endif\n<342> \n<343> /* Direct-store segment : absolutely *BUGGY* for now */\n<344> \n<345> switch (type) {\n<346> \n<347> case ACCESS_INT:\n<348> \n<349> /* Integer load/store : only access allowed */\n<350> \n<351> break;\n<352> \n<353> case ACCESS_CODE:\n<354> \n<355> /* No code fetch is allowed in direct-store areas */\n<356> \n<357> return -4;\n<358> \n<359> case ACCESS_FLOAT:\n<360> \n<361> /* Floating point load/store */\n<362> \n<363> return -4;\n<364> \n<365> case ACCESS_RES:\n<366> \n<367> /* lwarx, ldarx or srwcx. */\n<368> \n<369> return -4;\n<370> \n<371> case ACCESS_CACHE:\n<372> \n<373> /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n<374> \n<375> /* Should make the instruction do no-op.\n<376> \n<377> * As it already do no-op, it's quite easy :-)\n<378> \n<379> */\n<380> \n<381> ctx->raddr = eaddr;\n<382> \n<383> return 0;\n<384> \n<385> case ACCESS_EXT:\n<386> \n<387> /* eciwx or ecowx */\n<388> \n<389> return -4;\n<390> \n<391> default:\n<392> \n<393> if (logfile) {\n<394> \n<395> fprintf(logfile, "ERROR: instruction should not need "\n<396> \n<397> "address translation\n");\n<398> \n<399> }\n<400> \n<401> return -4;\n<402> \n<403> }\n<404> \n<405> if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n<406> \n<407> ctx->raddr = eaddr;\n<408> \n<409> ret = 2;\n<410> \n<411> } else {\n<412> \n<413> ret = -2;\n<414> \n<415> }\n<416> \n<417> }\n<418> \n<419> \n<420> \n<421> return ret;\n<422> \n<423> }\n<424> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int rwpipe_read_ppm_header( rwpipe *rw, int *width, int *height )\n<2> \n<3> {\n<4> \n<5> char line[ 3 ];\n<6> \n<7> FILE *in = rwpipe_reader( rw );\n<8> \n<9> int max;\n<10> \n<11> \n<12> \n<13> fgets( line, 3, in );\n<14> \n<15> if ( !strncmp( line, "P6", 2 ) )\n<16> \n<17> {\n<18> \n<19> *width = rwpipe_read_number( rw );\n<20> \n<21> *height = rwpipe_read_number( rw );\n<22> \n<23> max = rwpipe_read_number( rw );\n<24> \n<25> return max != 255 || *width <= 0 || *height <= 0;\n<26> \n<27> }\n<28> \n<29> return 1;\n<30> \n<31> }\n<32> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int openfile(char *name, int flags, QDict *opts)\n<2> \n<3> {\n<4> \n<5> Error *local_err = NULL;\n<6> \n<7> BlockDriverState *bs;\n<8> \n<9> \n<10> \n<11> if (qemuio_blk) {\n<12> \n<13> error_report("file open already, try 'help close'");\n<14> \n<15> QDECREF(opts);\n<16> \n<17> return 1;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> qemuio_blk = blk_new_open(name, NULL, opts, flags, &local_err);\n<24> \n<25> if (!qemuio_blk) {\n<26> \n<27> error_reportf_err(local_err, "can't open%s%s: ",\n<28> \n<29> name ? " device " : "", name ?: "");\n<30> \n<31> return 1;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> bs = blk_bs(qemuio_blk);\n<38> \n<39> if (bdrv_is_encrypted(bs)) {\n<40> \n<41> char password[256];\n<42> \n<43> printf("Disk image '%s' is encrypted.\n", name);\n<44> \n<45> if (qemu_read_password(password, sizeof(password)) < 0) {\n<46> \n<47> error_report("No password given");\n<48> \n<49> goto error;\n<50> \n<51> }\n<52> \n<53> if (bdrv_set_key(bs, password) < 0) {\n<54> \n<55> error_report("invalid password");\n<56> \n<57> goto error;\n<58> \n<59> }\n<60> \n<61> }\n<62> \n<63> \n<64> \n<65> \n<66> \n<67> return 0;\n<68> \n<69> \n<70> \n<71> error:\n<72> \n<73> blk_unref(qemuio_blk);\n<74> \n<75> qemuio_blk = NULL;\n<76> \n<77> return 1;\n<78> \n<79> }\n<80> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int readv_f(int argc, char **argv)\n<2> \n<3> {\n<4> \n<5> struct timeval t1, t2;\n<6> \n<7> int Cflag = 0, qflag = 0, vflag = 0;\n<8> \n<9> int c, cnt;\n<10> \n<11> char *buf;\n<12> \n<13> int64_t offset;\n<14> \n<15> /* Some compilers get confused and warn if this is not initialized.  */\n<16> \n<17> int total = 0;\n<18> \n<19> int nr_iov;\n<20> \n<21> QEMUIOVector qiov;\n<22> \n<23> int pattern = 0;\n<24> \n<25> int Pflag = 0;\n<26> \n<27> \n<28> \n<29> while ((c = getopt(argc, argv, "CP:qv")) != EOF) {\n<30> \n<31> switch (c) {\n<32> \n<33> case 'C':\n<34> \n<35> Cflag = 1;\n<36> \n<37> break;\n<38> \n<39> case 'P':\n<40> \n<41> Pflag = 1;\n<42> \n<43> pattern = parse_pattern(optarg);\n<44> \n<45> if (pattern < 0) {\n<46> \n<47> return 0;\n<48> \n<49> }\n<50> \n<51> break;\n<52> \n<53> case 'q':\n<54> \n<55> qflag = 1;\n<56> \n<57> break;\n<58> \n<59> case 'v':\n<60> \n<61> vflag = 1;\n<62> \n<63> break;\n<64> \n<65> default:\n<66> \n<67> return command_usage(&readv_cmd);\n<68> \n<69> }\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> if (optind > argc - 2) {\n<76> \n<77> return command_usage(&readv_cmd);\n<78> \n<79> }\n<80> \n<81> \n<82> \n<83> \n<84> \n<85> offset = cvtnum(argv[optind]);\n<86> \n<87> if (offset < 0) {\n<88> \n<89> printf("non-numeric length argument -- %s\n", argv[optind]);\n<90> \n<91> return 0;\n<92> \n<93> }\n<94> \n<95> optind++;\n<96> \n<97> \n<98> \n<99> if (offset & 0x1ff) {\n<100> \n<101> printf("offset %" PRId64 " is not sector aligned\n",\n<102> \n<103> offset);\n<104> \n<105> return 0;\n<106> \n<107> }\n<108> \n<109> \n<110> \n<111> nr_iov = argc - optind;\n<112> \n<113> buf = create_iovec(&qiov, &argv[optind], nr_iov, 0xab);\n<114> \n<115> if (buf == NULL) {\n<116> \n<117> return 0;\n<118> \n<119> }\n<120> \n<121> \n<122> \n<123> gettimeofday(&t1, NULL);\n<124> \n<125> cnt = do_aio_readv(&qiov, offset, &total);\n<126> \n<127> gettimeofday(&t2, NULL);\n<128> \n<129> \n<130> \n<131> if (cnt < 0) {\n<132> \n<133> printf("readv failed: %s\n", strerror(-cnt));\n<134> \n<135> goto out;\n<136> \n<137> }\n<138> \n<139> \n<140> \n<141> if (Pflag) {\n<142> \n<143> void *cmp_buf = malloc(qiov.size);\n<144> \n<145> memset(cmp_buf, pattern, qiov.size);\n<146> \n<147> if (memcmp(buf, cmp_buf, qiov.size)) {\n<148> \n<149> printf("Pattern verification failed at offset %"\n<150> \n<151> PRId64 ", %zd bytes\n", offset, qiov.size);\n<152> \n<153> }\n<154> \n<155> free(cmp_buf);\n<156> \n<157> }\n<158> \n<159> \n<160> \n<161> if (qflag) {\n<162> \n<163> goto out;\n<164> \n<165> }\n<166> \n<167> \n<168> \n<169> if (vflag) {\n<170> \n<171> dump_buffer(buf, offset, qiov.size);\n<172> \n<173> }\n<174> \n<175> \n<176> \n<177> /* Finally, report back -- -C gives a parsable format */\n<178> \n<179> t2 = tsub(t2, t1);\n<180> \n<181> print_report("read", &t2, offset, qiov.size, total, cnt, Cflag);\n<182> \n<183> \n<184> \n<185> out:\n<186> \n<187> qemu_io_free(buf);\n<188> \n<189> return 0;\n<190> \n<191> }\n<192> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n<2> \n<3> bool exact_size)\n<4> \n<5> {\n<6> \n<7> BDRVQcowState *s = bs->opaque;\n<8> \n<9> int new_l1_size2, ret, i;\n<10> \n<11> uint64_t *new_l1_table;\n<12> \n<13> int64_t new_l1_table_offset, new_l1_size;\n<14> \n<15> uint8_t data[12];\n<16> \n<17> \n<18> \n<19> if (min_size <= s->l1_size)\n<20> \n<21> return 0;\n<22> \n<23> \n<24> \n<25> if (exact_size) {\n<26> \n<27> new_l1_size = min_size;\n<28> \n<29> } else {\n<30> \n<31> /* Bump size up to reduce the number of times we have to grow */\n<32> \n<33> new_l1_size = s->l1_size;\n<34> \n<35> if (new_l1_size == 0) {\n<36> \n<37> new_l1_size = 1;\n<38> \n<39> }\n<40> \n<41> while (min_size > new_l1_size) {\n<42> \n<43> new_l1_size = (new_l1_size * 3 + 1) / 2;\n<44> \n<45> }\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> if (new_l1_size > INT_MAX) {\n<52> \n<53> return -EFBIG;\n<54> \n<55> }\n<56> \n<57> \n<58> \n<59> #ifdef DEBUG_ALLOC2\n<60> \n<61> fprintf(stderr, "grow l1_table from %d to %" PRId64 "\n",\n<62> \n<63> s->l1_size, new_l1_size);\n<64> \n<65> #endif\n<66> \n<67> \n<68> \n<69> new_l1_size2 = sizeof(uint64_t) * new_l1_size;\n<70> \n<71> new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n<72> \n<73> memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n<74> \n<75> \n<76> \n<77> /* write new table (align to cluster) */\n<78> \n<79> BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);\n<80> \n<81> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);\n<82> \n<83> if (new_l1_table_offset < 0) {\n<84> \n<85> g_free(new_l1_table);\n<86> \n<87> return new_l1_table_offset;\n<88> \n<89> }\n<90> \n<91> \n<92> \n<93> ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n<94> \n<95> if (ret < 0) {\n<96> \n<97> goto fail;\n<98> \n<99> }\n<100> \n<101> \n<102> \n<103> /* the L1 position has not yet been updated, so these clusters must\n<104> \n<105> * indeed be completely free */\n<106> \n<107> ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_DEFAULT,\n<108> \n<109> new_l1_table_offset, new_l1_size2);\n<110> \n<111> if (ret < 0) {\n<112> \n<113> goto fail;\n<114> \n<115> }\n<116> \n<117> \n<118> \n<119> BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_WRITE_TABLE);\n<120> \n<121> for(i = 0; i < s->l1_size; i++)\n<122> \n<123> new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n<124> \n<125> ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n<126> \n<127> if (ret < 0)\n<128> \n<129> goto fail;\n<130> \n<131> for(i = 0; i < s->l1_size; i++)\n<132> \n<133> new_l1_table[i] = be64_to_cpu(new_l1_table[i]);\n<134> \n<135> \n<136> \n<137> /* set new table */\n<138> \n<139> BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ACTIVATE_TABLE);\n<140> \n<141> cpu_to_be32w((uint32_t*)data, new_l1_size);\n<142> \n<143> cpu_to_be64wu((uint64_t*)(data + 4), new_l1_table_offset);\n<144> \n<145> ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, l1_size), data,sizeof(data));\n<146> \n<147> if (ret < 0) {\n<148> \n<149> goto fail;\n<150> \n<151> }\n<152> \n<153> g_free(s->l1_table);\n<154> \n<155> qcow2_free_clusters(bs, s->l1_table_offset, s->l1_size * sizeof(uint64_t),\n<156> \n<157> QCOW2_DISCARD_OTHER);\n<158> \n<159> s->l1_table_offset = new_l1_table_offset;\n<160> \n<161> s->l1_table = new_l1_table;\n<162> \n<163> s->l1_size = new_l1_size;\n<164> \n<165> return 0;\n<166> \n<167> fail:\n<168> \n<169> g_free(new_l1_table);\n<170> \n<171> qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2,\n<172> \n<173> QCOW2_DISCARD_OTHER);\n<174> \n<175> return ret;\n<176> \n<177> }\n<178> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> BlockDriverAIOCB *bdrv_aio_read(BlockDriverState *bs, int64_t sector_num,\n<2> \n<3> uint8_t *buf, int nb_sectors,\n<4> \n<5> BlockDriverCompletionFunc *cb, void *opaque)\n<6> \n<7> {\n<8> \n<9> BlockDriver *drv = bs->drv;\n<10> \n<11> BlockDriverAIOCB *ret;\n<12> \n<13> \n<14> \n<15> if (!drv)\n<16> \n<17> return NULL;\n<18> \n<19> \n<20> \n<21> /* XXX: we assume that nb_sectors == 0 is suppored by the async read */\n<22> \n<23> if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n<24> \n<25> memcpy(buf, bs->boot_sector_data, 512);\n<26> \n<27> sector_num++;\n<28> \n<29> nb_sectors--;\n<30> \n<31> buf += 512;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> ret = drv->bdrv_aio_read(bs, sector_num, buf, nb_sectors, cb, opaque);\n<38> \n<39> \n<40> \n<41> if (ret) {\n<42> \n<43> /* Update stats even though technically transfer has not happened. */\n<44> \n<45> bs->rd_bytes += (unsigned) nb_sectors * SECTOR_SIZE;\n<46> \n<47> bs->rd_ops ++;\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> return ret;\n<54> \n<55> }\n<56> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> PCIBus *ppce500_pci_init(qemu_irq pci_irqs[4], target_phys_addr_t registers)\n<2> \n<3> {\n<4> \n<5> PPCE500PCIState *controller;\n<6> \n<7> PCIDevice *d;\n<8> \n<9> int index;\n<10> \n<11> static int ppce500_pci_id;\n<12> \n<13> \n<14> \n<15> controller = qemu_mallocz(sizeof(PPCE500PCIState));\n<16> \n<17> \n<18> \n<19> controller->pci_state.bus = pci_register_bus(NULL, "pci",\n<20> \n<21> mpc85xx_pci_set_irq,\n<22> \n<23> mpc85xx_pci_map_irq,\n<24> \n<25> pci_irqs, 0x88, 4);\n<26> \n<27> d = pci_register_device(controller->pci_state.bus,\n<28> \n<29> "host bridge", sizeof(PCIDevice),\n<30> \n<31> 0, NULL, NULL);\n<32> \n<33> \n<34> \n<35> pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_FREESCALE);\n<36> \n<37> pci_config_set_device_id(d->config, PCI_DEVICE_ID_MPC8533E);\n<38> \n<39> pci_config_set_class(d->config, PCI_CLASS_PROCESSOR_POWERPC);\n<40> \n<41> \n<42> \n<43> controller->pci_dev = d;\n<44> \n<45> \n<46> \n<47> /* CFGADDR */\n<48> \n<49> index = cpu_register_io_memory(pcie500_cfgaddr_read,\n<50> \n<51> pcie500_cfgaddr_write, controller);\n<52> \n<53> if (index < 0)\n<54> \n<55> goto free;\n<56> \n<57> cpu_register_physical_memory(registers + PCIE500_CFGADDR, 4, index);\n<58> \n<59> \n<60> \n<61> /* CFGDATA */\n<62> \n<63> index = cpu_register_io_memory(pcie500_cfgdata_read,\n<64> \n<65> pcie500_cfgdata_write,\n<66> \n<67> &controller->pci_state);\n<68> \n<69> if (index < 0)\n<70> \n<71> goto free;\n<72> \n<73> cpu_register_physical_memory(registers + PCIE500_CFGDATA, 4, index);\n<74> \n<75> \n<76> \n<77> index = cpu_register_io_memory(e500_pci_reg_read,\n<78> \n<79> e500_pci_reg_write, controller);\n<80> \n<81> if (index < 0)\n<82> \n<83> goto free;\n<84> \n<85> cpu_register_physical_memory(registers + PCIE500_REG_BASE,\n<86> \n<87> PCIE500_REG_SIZE, index);\n<88> \n<89> \n<90> \n<91> /* XXX load/save code not tested. */\n<92> \n<93> register_savevm("ppce500_pci", ppce500_pci_id++, 1,\n<94> \n<95> ppce500_pci_save, ppce500_pci_load, controller);\n<96> \n<97> \n<98> \n<99> return controller->pci_state.bus;\n<100> \n<101> \n<102> \n<103> free:\n<104> \n<105> printf("%s error\n", __func__);\n<106> \n<107> qemu_free(controller);\n<108> \n<109> return NULL;\n<110> \n<111> }\n<112> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> vpx_codec_err_t vpx_svc_set_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n<2> SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n<3> if ( svc_ctx == NULL || scale_factors == NULL || si == NULL ) {\n<4> return VPX_CODEC_INVALID_PARAM ;\n<5> }\n<6> strncpy ( si -> scale_factors , scale_factors , sizeof ( si -> scale_factors ) ) ;\n<7> si -> scale_factors [ sizeof ( si -> scale_factors ) - 1 ] = '\0' ;\n<8> return VPX_CODEC_OK ;\n<9> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void versatile_init(ram_addr_t ram_size, int vga_ram_size,\n<2> \n<3> const char *boot_device, DisplayState *ds,\n<4> \n<5> const char *kernel_filename, const char *kernel_cmdline,\n<6> \n<7> const char *initrd_filename, const char *cpu_model,\n<8> \n<9> int board_id)\n<10> \n<11> {\n<12> \n<13> CPUState *env;\n<14> \n<15> qemu_irq *pic;\n<16> \n<17> qemu_irq *sic;\n<18> \n<19> void *scsi_hba;\n<20> \n<21> PCIBus *pci_bus;\n<22> \n<23> NICInfo *nd;\n<24> \n<25> int n;\n<26> \n<27> int done_smc = 0;\n<28> \n<29> int index;\n<30> \n<31> \n<32> \n<33> if (!cpu_model)\n<34> \n<35> cpu_model = "arm926";\n<36> \n<37> env = cpu_init(cpu_model);\n<38> \n<39> if (!env) {\n<40> \n<41> fprintf(stderr, "Unable to find CPU definition\n");\n<42> \n<43> exit(1);\n<44> \n<45> }\n<46> \n<47> /* ??? RAM should repeat to fill physical memory space.  */\n<48> \n<49> /* SDRAM at address zero.  */\n<50> \n<51> cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n<52> \n<53> \n<54> \n<55> arm_sysctl_init(0x10000000, 0x41007004);\n<56> \n<57> pic = arm_pic_init_cpu(env);\n<58> \n<59> pic = pl190_init(0x10140000, pic[0], pic[1]);\n<60> \n<61> sic = vpb_sic_init(0x10003000, pic, 31);\n<62> \n<63> pl050_init(0x10006000, sic[3], 0);\n<64> \n<65> pl050_init(0x10007000, sic[4], 1);\n<66> \n<67> \n<68> \n<69> pci_bus = pci_vpb_init(sic, 27, 0);\n<70> \n<71> /* The Versatile PCI bridge does not provide access to PCI IO space,\n<72> \n<73> so many of the qemu PCI devices are not useable.  */\n<74> \n<75> for(n = 0; n < nb_nics; n++) {\n<76> \n<77> nd = &nd_table[n];\n<78> \n<79> if (!nd->model)\n<80> \n<81> nd->model = done_smc ? "rtl8139" : "smc91c111";\n<82> \n<83> if (strcmp(nd->model, "smc91c111") == 0) {\n<84> \n<85> smc91c111_init(nd, 0x10010000, sic[25]);\n<86> \n<87> } else {\n<88> \n<89> pci_nic_init(pci_bus, nd, -1);\n<90> \n<91> }\n<92> \n<93> }\n<94> \n<95> if (usb_enabled) {\n<96> \n<97> usb_ohci_init_pci(pci_bus, 3, -1);\n<98> \n<99> }\n<100> \n<101> if (drive_get_max_bus(IF_SCSI) > 0) {\n<102> \n<103> fprintf(stderr, "qemu: too many SCSI bus\n");\n<104> \n<105> exit(1);\n<106> \n<107> }\n<108> \n<109> scsi_hba = lsi_scsi_init(pci_bus, -1);\n<110> \n<111> for (n = 0; n < LSI_MAX_DEVS; n++) {\n<112> \n<113> index = drive_get_index(IF_SCSI, 0, n);\n<114> \n<115> if (index == -1)\n<116> \n<117> continue;\n<118> \n<119> lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n<120> \n<121> }\n<122> \n<123> \n<124> \n<125> pl011_init(0x101f1000, pic[12], serial_hds[0], PL011_ARM);\n<126> \n<127> pl011_init(0x101f2000, pic[13], serial_hds[1], PL011_ARM);\n<128> \n<129> pl011_init(0x101f3000, pic[14], serial_hds[2], PL011_ARM);\n<130> \n<131> pl011_init(0x10009000, sic[6], serial_hds[3], PL011_ARM);\n<132> \n<133> \n<134> \n<135> pl080_init(0x10130000, pic[17], 8);\n<136> \n<137> sp804_init(0x101e2000, pic[4]);\n<138> \n<139> sp804_init(0x101e3000, pic[5]);\n<140> \n<141> \n<142> \n<143> /* The versatile/PB actually has a modified Color LCD controller\n<144> \n<145> that includes hardware cursor support from the PL111.  */\n<146> \n<147> pl110_init(ds, 0x10120000, pic[16], 1);\n<148> \n<149> \n<150> \n<151> index = drive_get_index(IF_SD, 0, 0);\n<152> \n<153> if (index == -1) {\n<154> \n<155> fprintf(stderr, "qemu: missing SecureDigital card\n");\n<156> \n<157> exit(1);\n<158> \n<159> }\n<160> \n<161> \n<162> \n<163> pl181_init(0x10005000, drives_table[index].bdrv, sic[22], sic[1]);\n<164> \n<165> #if 0\n<166> \n<167> /* Disabled because there's no way of specifying a block device.  */\n<168> \n<169> pl181_init(0x1000b000, NULL, sic, 23, 2);\n<170> \n<171> #endif\n<172> \n<173> \n<174> \n<175> /* Add PL031 Real Time Clock. */\n<176> \n<177> pl031_init(0x101e8000,pic[10]);\n<178> \n<179> \n<180> \n<181> /* Memory map for Versatile/PB:  */\n<182> \n<183> /* 0x10000000 System registers.  */\n<184> \n<185> /* 0x10001000 PCI controller config registers.  */\n<186> \n<187> /* 0x10002000 Serial bus interface.  */\n<188> \n<189> /*  0x10003000 Secondary interrupt controller.  */\n<190> \n<191> /* 0x10004000 AACI (audio).  */\n<192> \n<193> /*  0x10005000 MMCI0.  */\n<194> \n<195> /*  0x10006000 KMI0 (keyboard).  */\n<196> \n<197> /*  0x10007000 KMI1 (mouse).  */\n<198> \n<199> /* 0x10008000 Character LCD Interface.  */\n<200> \n<201> /*  0x10009000 UART3.  */\n<202> \n<203> /* 0x1000a000 Smart card 1.  */\n<204> \n<205> /*  0x1000b000 MMCI1.  */\n<206> \n<207> /*  0x10010000 Ethernet.  */\n<208> \n<209> /* 0x10020000 USB.  */\n<210> \n<211> /* 0x10100000 SSMC.  */\n<212> \n<213> /* 0x10110000 MPMC.  */\n<214> \n<215> /*  0x10120000 CLCD Controller.  */\n<216> \n<217> /*  0x10130000 DMA Controller.  */\n<218> \n<219> /*  0x10140000 Vectored interrupt controller.  */\n<220> \n<221> /* 0x101d0000 AHB Monitor Interface.  */\n<222> \n<223> /* 0x101e0000 System Controller.  */\n<224> \n<225> /* 0x101e1000 Watchdog Interface.  */\n<226> \n<227> /* 0x101e2000 Timer 0/1.  */\n<228> \n<229> /* 0x101e3000 Timer 2/3.  */\n<230> \n<231> /* 0x101e4000 GPIO port 0.  */\n<232> \n<233> /* 0x101e5000 GPIO port 1.  */\n<234> \n<235> /* 0x101e6000 GPIO port 2.  */\n<236> \n<237> /* 0x101e7000 GPIO port 3.  */\n<238> \n<239> /* 0x101e8000 RTC.  */\n<240> \n<241> /* 0x101f0000 Smart card 0.  */\n<242> \n<243> /*  0x101f1000 UART0.  */\n<244> \n<245> /*  0x101f2000 UART1.  */\n<246> \n<247> /*  0x101f3000 UART2.  */\n<248> \n<249> /* 0x101f4000 SSPI.  */\n<250> \n<251> \n<252> \n<253> versatile_binfo.ram_size = ram_size;\n<254> \n<255> versatile_binfo.kernel_filename = kernel_filename;\n<256> \n<257> versatile_binfo.kernel_cmdline = kernel_cmdline;\n<258> \n<259> versatile_binfo.initrd_filename = initrd_filename;\n<260> \n<261> versatile_binfo.board_id = board_id;\n<262> \n<263> arm_load_kernel(env, &versatile_binfo);\n<264> \n<265> }\n<266> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void keyword_literal(void)\n<2> \n<3> {\n<4> \n<5> QObject *obj;\n<6> \n<7> QBool *qbool;\n<8> \n<9> QObject *null;\n<10> \n<11> QString *str;\n<12> \n<13> \n<14> \n<15> obj = qobject_from_json("true");\n<16> \n<17> g_assert(obj != NULL);\n<18> \n<19> g_assert(qobject_type(obj) == QTYPE_QBOOL);\n<20> \n<21> \n<22> \n<23> qbool = qobject_to_qbool(obj);\n<24> \n<25> g_assert(qbool_get_bool(qbool) == true);\n<26> \n<27> \n<28> \n<29> str = qobject_to_json(obj);\n<30> \n<31> g_assert(strcmp(qstring_get_str(str), "true") == 0);\n<32> \n<33> QDECREF(str);\n<34> \n<35> \n<36> \n<37> QDECREF(qbool);\n<38> \n<39> \n<40> \n<41> obj = qobject_from_json("false");\n<42> \n<43> g_assert(obj != NULL);\n<44> \n<45> g_assert(qobject_type(obj) == QTYPE_QBOOL);\n<46> \n<47> \n<48> \n<49> qbool = qobject_to_qbool(obj);\n<50> \n<51> g_assert(qbool_get_bool(qbool) == false);\n<52> \n<53> \n<54> \n<55> str = qobject_to_json(obj);\n<56> \n<57> g_assert(strcmp(qstring_get_str(str), "false") == 0);\n<58> \n<59> QDECREF(str);\n<60> \n<61> \n<62> \n<63> QDECREF(qbool);\n<64> \n<65> \n<66> \n<67> obj = qobject_from_jsonf("%i", false);\n<68> \n<69> g_assert(obj != NULL);\n<70> \n<71> g_assert(qobject_type(obj) == QTYPE_QBOOL);\n<72> \n<73> \n<74> \n<75> qbool = qobject_to_qbool(obj);\n<76> \n<77> g_assert(qbool_get_bool(qbool) == false);\n<78> \n<79> \n<80> \n<81> QDECREF(qbool);\n<82> \n<83> \n<84> \n<85> /* Test that non-zero values other than 1 get collapsed to true */\n<86> \n<87> obj = qobject_from_jsonf("%i", 2);\n<88> \n<89> g_assert(obj != NULL);\n<90> \n<91> g_assert(qobject_type(obj) == QTYPE_QBOOL);\n<92> \n<93> \n<94> \n<95> qbool = qobject_to_qbool(obj);\n<96> \n<97> g_assert(qbool_get_bool(qbool) == true);\n<98> \n<99> \n<100> \n<101> QDECREF(qbool);\n<102> \n<103> \n<104> \n<105> obj = qobject_from_json("null");\n<106> \n<107> g_assert(obj != NULL);\n<108> \n<109> g_assert(qobject_type(obj) == QTYPE_QNULL);\n<110> \n<111> \n<112> \n<113> null = qnull();\n<114> \n<115> g_assert(null == obj);\n<116> \n<117> \n<118> \n<119> qobject_decref(obj);\n<120> \n<121> qobject_decref(null);\n<122> \n<123> }\n<124> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int set_boot_dev(ISADevice *s, const char *boot_device)\n<2> \n<3> {\n<4> \n<5> #define PC_MAX_BOOT_DEVICES 3\n<6> \n<7> int nbds, bds[3] = { 0, };\n<8> \n<9> int i;\n<10> \n<11> \n<12> \n<13> nbds = strlen(boot_device);\n<14> \n<15> if (nbds > PC_MAX_BOOT_DEVICES) {\n<16> \n<17> error_report("Too many boot devices for PC");\n<18> \n<19> return(1);\n<20> \n<21> }\n<22> \n<23> for (i = 0; i < nbds; i++) {\n<24> \n<25> bds[i] = boot_device2nibble(boot_device[i]);\n<26> \n<27> if (bds[i] == 0) {\n<28> \n<29> error_report("Invalid boot device for PC: '%c'",\n<30> \n<31> boot_device[i]);\n<32> \n<33> return(1);\n<34> \n<35> }\n<36> \n<37> }\n<38> \n<39> rtc_set_memory(s, 0x3d, (bds[1] << 4) | bds[0]);\n<40> \n<41> rtc_set_memory(s, 0x38, (bds[2] << 4) | (fd_bootchk ? 0x0 : 0x1));\n<42> \n<43> return(0);\n<44> \n<45> }\n<46> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void ff_build_rac_states(RangeCoder *c, int factor, int max_p){\n<2> \n<3> const int64_t one= 1LL<<32;\n<4> \n<5> int64_t p;\n<6> \n<7> int last_p8, p8, i;\n<8> \n<9> \n<10> \n<11> memset(c->zero_state, 0, sizeof(c->zero_state));\n<12> \n<13> memset(c-> one_state, 0, sizeof(c-> one_state));\n<14> \n<15> \n<16> \n<17> #if 0\n<18> \n<19> for(i=1; i<256; i++){\n<20> \n<21> if(c->one_state[i])\n<22> \n<23> continue;\n<24> \n<25> \n<26> \n<27> p= (i*one + 128) >> 8;\n<28> \n<29> last_p8= i;\n<30> \n<31> for(;;){\n<32> \n<33> p+= ((one-p)*factor + one/2) >> 32;\n<34> \n<35> p8= (256*p + one/2) >> 32; //FIXME try without the one\n<36> \n<37> if(p8 <= last_p8) p8= last_p8+1;\n<38> \n<39> if(p8 > max_p) p8= max_p;\n<40> \n<41> if(p8 < last_p8)\n<42> \n<43> break;\n<44> \n<45> c->one_state[last_p8]=     p8;\n<46> \n<47> if(p8 == last_p8)\n<48> \n<49> break;\n<50> \n<51> last_p8= p8;\n<52> \n<53> }\n<54> \n<55> }\n<56> \n<57> #endif\n<58> \n<59> #if 1\n<60> \n<61> last_p8= 0;\n<62> \n<63> p= one/2;\n<64> \n<65> for(i=0; i<128; i++){\n<66> \n<67> p8= (256*p + one/2) >> 32; //FIXME try without the one\n<68> \n<69> if(p8 <= last_p8) p8= last_p8+1;\n<70> \n<71> if(last_p8 && last_p8<256 && p8<=max_p)\n<72> \n<73> c->one_state[last_p8]= p8;\n<74> \n<75> \n<76> \n<77> p+= ((one-p)*factor + one/2) >> 32;\n<78> \n<79> last_p8= p8;\n<80> \n<81> }\n<82> \n<83> #endif\n<84> \n<85> for(i=256-max_p; i<=max_p; i++){\n<86> \n<87> if(c->one_state[i])\n<88> \n<89> continue;\n<90> \n<91> \n<92> \n<93> p= (i*one + 128) >> 8;\n<94> \n<95> p+= ((one-p)*factor + one/2) >> 32;\n<96> \n<97> p8= (256*p + one/2) >> 32; //FIXME try without the one\n<98> \n<99> if(p8 <= i) p8= i+1;\n<100> \n<101> if(p8 > max_p) p8= max_p;\n<102> \n<103> c->one_state[    i]=     p8;\n<104> \n<105> }\n<106> \n<107> \n<108> \n<109> for(i=0; i<256; i++)\n<110> \n<111> c->zero_state[i]= 256-c->one_state[256-i];\n<112> \n<113> #if 0\n<114> \n<115> for(i=0; i<256; i++)\n<116> \n<117> av_log(NULL, AV_LOG_DEBUG, "%3d %3d\n", i, c->one_state[i]);\n<118> \n<119> #endif\n<120> \n<121> }\n<122> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int flashsv_encode_frame(AVCodecContext *avctx, uint8_t *buf, int buf_size, void *data)\n<2> \n<3> {\n<4> \n<5> FlashSVContext * const s = avctx->priv_data;\n<6> \n<7> AVFrame *pict = data;\n<8> \n<9> AVFrame * const p = &s->frame;\n<10> \n<11> int res;\n<12> \n<13> int I_frame = 0;\n<14> \n<15> int opt_w, opt_h;\n<16> \n<17> \n<18> \n<19> *p = *pict;\n<20> \n<21> \n<22> \n<23> /* First frame needs to be a keyframe */\n<24> \n<25> if (avctx->frame_number == 0) {\n<26> \n<27> s->previous_frame = av_mallocz(p->linesize[0]*s->image_height);\n<28> \n<29> if (!s->previous_frame) {\n<30> \n<31> av_log(avctx, AV_LOG_ERROR, "Memory allocation failed.\n");\n<32> \n<33> return -1;\n<34> \n<35> }\n<36> \n<37> I_frame = 1;\n<38> \n<39> }\n<40> \n<41> \n<42> \n<43> /* Check the placement of keyframes */\n<44> \n<45> if (avctx->gop_size > 0) {\n<46> \n<47> if (avctx->frame_number >= s->last_key_frame + avctx->gop_size) {\n<48> \n<49> I_frame = 1;\n<50> \n<51> }\n<52> \n<53> }\n<54> \n<55> \n<56> \n<57> #if 0\n<58> \n<59> int w, h;\n<60> \n<61> int optim_sizes[16][16];\n<62> \n<63> int smallest_size;\n<64> \n<65> //Try all possible combinations and store the encoded frame sizes\n<66> \n<67> for (w=1 ; w<17 ; w++) {\n<68> \n<69> for (h=1 ; h<17 ; h++) {\n<70> \n<71> optim_sizes[w-1][h-1] = encode_bitstream(s, p, s->encbuffer, s->image_width*s->image_height*4, w*16, h*16, s->previous_frame);\n<72> \n<73> //av_log(avctx, AV_LOG_ERROR, "[%d][%d]size = %d\n",w,h,optim_sizes[w-1][h-1]);\n<74> \n<75> }\n<76> \n<77> }\n<78> \n<79> \n<80> \n<81> //Search for the smallest framesize and encode the frame with those parameters\n<82> \n<83> smallest_size=optim_sizes[0][0];\n<84> \n<85> opt_w = 0;\n<86> \n<87> opt_h = 0;\n<88> \n<89> for (w=0 ; w<16 ; w++) {\n<90> \n<91> for (h=0 ; h<16 ; h++) {\n<92> \n<93> if (optim_sizes[w][h] < smallest_size) {\n<94> \n<95> smallest_size = optim_sizes[w][h];\n<96> \n<97> opt_w = w;\n<98> \n<99> opt_h = h;\n<100> \n<101> }\n<102> \n<103> }\n<104> \n<105> }\n<106> \n<107> res = encode_bitstream(s, p, buf, buf_size, (opt_w+1)*16, (opt_h+1)*16, s->previous_frame);\n<108> \n<109> av_log(avctx, AV_LOG_ERROR, "[%d][%d]optimal size = %d, res = %d|\n", opt_w, opt_h, smallest_size, res);\n<110> \n<111> \n<112> \n<113> if (buf_size < res)\n<114> \n<115> av_log(avctx, AV_LOG_ERROR, "buf_size %d < res %d\n", buf_size, res);\n<116> \n<117> \n<118> \n<119> #else\n<120> \n<121> opt_w=1;\n<122> \n<123> opt_h=1;\n<124> \n<125> \n<126> \n<127> if (buf_size < s->image_width*s->image_height*3) {\n<128> \n<129> //Conservative upper bound check for compressed data\n<130> \n<131> av_log(avctx, AV_LOG_ERROR, "buf_size %d <  %d\n", buf_size, s->image_width*s->image_height*3);\n<132> \n<133> return -1;\n<134> \n<135> }\n<136> \n<137> \n<138> \n<139> res = encode_bitstream(s, p, buf, buf_size, opt_w*16, opt_h*16, s->previous_frame, &I_frame);\n<140> \n<141> #endif\n<142> \n<143> //save the current frame\n<144> \n<145> memcpy(s->previous_frame, p->data[0], s->image_height*p->linesize[0]);\n<146> \n<147> \n<148> \n<149> //mark the frame type so the muxer can mux it correctly\n<150> \n<151> if (I_frame) {\n<152> \n<153> p->pict_type = FF_I_TYPE;\n<154> \n<155> p->key_frame = 1;\n<156> \n<157> s->last_key_frame = avctx->frame_number;\n<158> \n<159> av_log(avctx, AV_LOG_DEBUG, "Inserting key frame at frame %d\n",avctx->frame_number);\n<160> \n<161> } else {\n<162> \n<163> p->pict_type = FF_P_TYPE;\n<164> \n<165> p->key_frame = 0;\n<166> \n<167> }\n<168> \n<169> \n<170> \n<171> avctx->coded_frame = p;\n<172> \n<173> \n<174> \n<175> return res;\n<176> \n<177> }\n<178> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size, uint8_t *buf, int buf_size)\n<2> \n<3> {\n<4> \n<5> AC3DecodeContext *ctx = (AC3DecodeContext *)avctx->priv_data;\n<6> \n<7> ac3_audio_block *ab = &ctx->audio_block;\n<8> \n<9> int frame_start;\n<10> \n<11> int i, j, k, l, value;\n<12> \n<13> float tmp_block_first_half[128], tmp_block_second_half[128];\n<14> \n<15> int16_t *out_samples = (int16_t *)data;\n<16> \n<17> int nfchans;\n<18> \n<19> \n<20> \n<21> //Synchronize the frame.\n<22> \n<23> frame_start = ac3_synchronize(buf, buf_size);\n<24> \n<25> if (frame_start == -1) {\n<26> \n<27> av_log(avctx, AV_LOG_ERROR, "frame is not synchronized\n");\n<28> \n<29> *data_size = 0;\n<30> \n<31> return buf_size;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> //Initialize the GetBitContext with the start of valid AC3 Frame.\n<38> \n<39> init_get_bits(&(ctx->gb), buf + frame_start, (buf_size - frame_start) * 8);\n<40> \n<41> \n<42> \n<43> //Parse the syncinfo.\n<44> \n<45> //If 'fscod' or 'bsid' is not valid the decoder shall mute as per the standard.\n<46> \n<47> if (!ac3_parse_sync_info(ctx)) {\n<48> \n<49> av_log(avctx, AV_LOG_ERROR, "\n");\n<50> \n<51> *data_size = 0;\n<52> \n<53> return -1;\n<54> \n<55> }\n<56> \n<57> \n<58> \n<59> //Check for the errors.\n<60> \n<61> /* if (ac3_error_check(ctx)) {\n<62> \n<63> *data_size = 0;\n<64> \n<65> return -1;\n<66> \n<67> } */\n<68> \n<69> \n<70> \n<71> //Parse the BSI.\n<72> \n<73> //If 'bsid' is not valid decoder shall not decode the audio as per the standard.\n<74> \n<75> if (ac3_parse_bsi(ctx)) {\n<76> \n<77> av_log(avctx, AV_LOG_ERROR, "bsid is not valid\n");\n<78> \n<79> *data_size = 0;\n<80> \n<81> return -1;\n<82> \n<83> }\n<84> \n<85> \n<86> \n<87> for (i = 0; i < MAX_BLOCKS; i++)\n<88> \n<89> memset(ctx->delay[i], 0, sizeof(ctx->delay[i]));\n<90> \n<91> avctx->sample_rate = ctx->sync_info.sampling_rate;\n<92> \n<93> avctx->bit_rate = ctx->sync_info.bit_rate;\n<94> \n<95> if (avctx->channels == 0) {\n<96> \n<97> //avctx->channels = ctx->bsi.nfchans + ((ctx->bsi.flags & AC3_BSI_LFEON) ? 1 : 0);\n<98> \n<99> ctx->output = AC3_OUTPUT_UNMODIFIED;\n<100> \n<101> }\n<102> \n<103> else if ((ctx->bsi.nfchans + ((ctx->bsi.flags & AC3_BSI_LFEON) ? 1 : 0)) < avctx->channels) {\n<104> \n<105> av_log(avctx, AV_LOG_INFO, "ac3_decoder: AC3 Source Channels Are Less Then Specified %d: Output to %d Channels\n",\n<106> \n<107> avctx->channels, (ctx->bsi.nfchans + ((ctx->bsi.flags & AC3_BSI_LFEON) ? 1 : 0)));\n<108> \n<109> //avctx->channels = ctx->bsi.nfchans + ((ctx->bsi.flags & AC3_BSI_LFEON) ? 1 : 0);\n<110> \n<111> ctx->output = AC3_OUTPUT_UNMODIFIED;\n<112> \n<113> }\n<114> \n<115> else if (avctx->channels == 1) {\n<116> \n<117> ctx->output = AC3_OUTPUT_MONO;\n<118> \n<119> } else if (avctx->channels == 2) {\n<120> \n<121> if (ctx->bsi.dsurmod == 0x02)\n<122> \n<123> ctx->output = AC3_OUTPUT_DOLBY;\n<124> \n<125> else\n<126> \n<127> ctx->output = AC3_OUTPUT_STEREO;\n<128> \n<129> }\n<130> \n<131> \n<132> \n<133> \n<134> \n<135> av_log(avctx, AV_LOG_INFO, "channels = %d \t bit rate = %d \t sampling rate = %d \n", avctx->channels, avctx->sample_rate, avctx->bit_rate);\n<136> \n<137> \n<138> \n<139> //Parse the Audio Blocks.\n<140> \n<141> *data_size = 0;\n<142> \n<143> for (i = 0; i < 6; i++) {\n<144> \n<145> if (ac3_parse_audio_block(ctx, i)) {\n<146> \n<147> av_log(avctx, AV_LOG_ERROR, "error parsing the audio block\n");\n<148> \n<149> *data_size = 0;\n<150> \n<151> return -1;\n<152> \n<153> }\n<154> \n<155> \n<156> \n<157> av_log(NULL, AV_LOG_INFO, "doing imdct\n");\n<158> \n<159> \n<160> \n<161> if (ctx->bsi.flags & AC3_BSI_LFEON) {\n<162> \n<163> ff_imdct_calc(&ctx->imdct_ctx_512, ctx->tmp_output, ab->transform_coeffs[0], ctx->tmp_imdct);\n<164> \n<165> for (l = 0; l < 256; l++)\n<166> \n<167> ab->block_output[0][l] = ctx->tmp_output[l] * window[l] + ctx->delay[0][l] * window[255 -l];\n<168> \n<169> memcpy(ctx->delay[0], ctx->tmp_output + 256, sizeof(ctx->delay[0]));\n<170> \n<171> }\n<172> \n<173> \n<174> \n<175> for (j = 0; j < ctx->bsi.nfchans; j++) {\n<176> \n<177> if (ctx->audio_block.blksw & (1 << j)) {\n<178> \n<179> for (k = 0; k < 128; k++) {\n<180> \n<181> tmp_block_first_half[k] = ab->transform_coeffs[j + 1][2 * k];\n<182> \n<183> tmp_block_second_half[k] = ab->transform_coeffs[j + 1][2 * k + 1];\n<184> \n<185> }\n<186> \n<187> ff_imdct_calc(&ctx->imdct_ctx_256, ctx->tmp_output, tmp_block_first_half, ctx->tmp_imdct);\n<188> \n<189> for (l = 0; l < 256; l++)\n<190> \n<191> ab->block_output[j + 1][l] = ctx->tmp_output[l] * window[l] + ctx->delay[j + 1][l] * window[255 - l];\n<192> \n<193> ff_imdct_calc(&ctx->imdct_ctx_256, ctx->delay[j + 1], tmp_block_second_half, ctx->tmp_imdct);\n<194> \n<195> } else {\n<196> \n<197> ff_imdct_calc(&ctx->imdct_ctx_512, ctx->tmp_output, ab->transform_coeffs[j + 1], ctx->tmp_imdct);\n<198> \n<199> for (l = 0; l < 256; l++)\n<200> \n<201> ab->block_output[j + 1][l] = ctx->tmp_output[l] * window[l] + ctx->delay[j + 1][l] * window[255 - l];\n<202> \n<203> memcpy(ctx->delay[j + 1], ctx->tmp_output + 256, sizeof(ctx->delay[j + 1]));\n<204> \n<205> }\n<206> \n<207> }\n<208> \n<209> if (ctx->bsi.flags & AC3_BSI_LFEON) {\n<210> \n<211> for (l = 0; l < 256; l++) {\n<212> \n<213> value = lrint(ab->block_output[0][l]);\n<214> \n<215> if (value < -32768)\n<216> \n<217> value = -32768;\n<218> \n<219> else if (value > 32767)\n<220> \n<221> value = 32767;\n<222> \n<223> *(out_samples++) = value;\n<224> \n<225> }\n<226> \n<227> *data_size += 256 * sizeof(int16_t);\n<228> \n<229> }\n<230> \n<231> do_downmix(ctx);\n<232> \n<233> if (ctx->output == AC3_OUTPUT_UNMODIFIED)\n<234> \n<235> nfchans = ctx->bsi.nfchans;\n<236> \n<237> else\n<238> \n<239> nfchans = avctx->channels;\n<240> \n<241> for (k = 0; k < nfchans; k++)\n<242> \n<243> for (l = 0; l < 256; l++) {\n<244> \n<245> value = lrint(ab->block_output[k + 1][l]);\n<246> \n<247> if (value < -32768)\n<248> \n<249> value = -32768;\n<250> \n<251> else if (value > 32767)\n<252> \n<253> value = 32767;\n<254> \n<255> *(out_samples++) = value;\n<256> \n<257> }\n<258> \n<259> *data_size += nfchans * 256 * sizeof (int16_t);\n<260> \n<261> }\n<262> \n<263> \n<264> \n<265> return ctx->sync_info.framesize;\n<266> \n<267> }\n<268> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void read_ttag(AVFormatContext *s, int taglen, const char *key)\n<2> \n<3> {\n<4> \n<5> char *q, dst[512];\n<6> \n<7> int len, dstlen = sizeof(dst) - 1;\n<8> \n<9> unsigned genre;\n<10> \n<11> \n<12> \n<13> dst[0] = 0;\n<14> \n<15> if (taglen < 1)\n<16> \n<17> return;\n<18> \n<19> \n<20> \n<21> taglen--; /* account for encoding type byte */\n<22> \n<23> \n<24> \n<25> switch (get_byte(s->pb)) { /* encoding type */\n<26> \n<27> \n<28> \n<29> case 0:  /* ISO-8859-1 (0 - 255 maps directly into unicode) */\n<30> \n<31> q = dst;\n<32> \n<33> while (taglen--) {\n<34> \n<35> uint8_t tmp;\n<36> \n<37> PUT_UTF8(get_byte(s->pb), tmp, if (q - dst < dstlen - 1) *q++ = tmp;)\n<38> \n<39> }\n<40> \n<41> *q = '\0';\n<42> \n<43> break;\n<44> \n<45> \n<46> \n<47> case 3:  /* UTF-8 */\n<48> \n<49> len = FFMIN(taglen, dstlen - 1);\n<50> \n<51> get_buffer(s->pb, dst, len);\n<52> \n<53> dst[len] = 0;\n<54> \n<55> break;\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> if (!strcmp(key, "genre")\n<62> \n<63> && (sscanf(dst, "(%d)", &genre) == 1 || sscanf(dst, "%d", &genre) == 1)\n<64> \n<65> && genre <= ID3v1_GENRE_MAX)\n<66> \n<67> av_strlcpy(dst, ff_id3v1_genre_str[genre], sizeof(dst));\n<68> \n<69> \n<70> \n<71> if (*dst)\n<72> \n<73> av_metadata_set(&s->metadata, key, dst);\n<74> \n<75> }\n<76> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void sun4uv_init(MemoryRegion *address_space_mem,\n<2> \n<3> MachineState *machine,\n<4> \n<5> const struct hwdef *hwdef)\n<6> \n<7> {\n<8> \n<9> SPARCCPU *cpu;\n<10> \n<11> Nvram *nvram;\n<12> \n<13> unsigned int i;\n<14> \n<15> uint64_t initrd_addr, initrd_size, kernel_addr, kernel_size, kernel_entry;\n<16> \n<17> PCIBus *pci_bus, *pci_bus2, *pci_bus3;\n<18> \n<19> ISABus *isa_bus;\n<20> \n<21> SysBusDevice *s;\n<22> \n<23> qemu_irq *ivec_irqs, *pbm_irqs;\n<24> \n<25> DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n<26> \n<27> DriveInfo *fd[MAX_FD];\n<28> \n<29> FWCfgState *fw_cfg;\n<30> \n<31> \n<32> \n<33> /* init CPUs */\n<34> \n<35> cpu = cpu_devinit(machine->cpu_model, hwdef);\n<36> \n<37> \n<38> \n<39> /* set up devices */\n<40> \n<41> ram_init(0, machine->ram_size);\n<42> \n<43> \n<44> \n<45> prom_init(hwdef->prom_addr, bios_name);\n<46> \n<47> \n<48> \n<49> ivec_irqs = qemu_allocate_irqs(cpu_set_ivec_irq, cpu, IVEC_MAX);\n<50> \n<51> pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, ivec_irqs, &pci_bus2,\n<52> \n<53> &pci_bus3, &pbm_irqs);\n<54> \n<55> pci_vga_init(pci_bus);\n<56> \n<57> \n<58> \n<59> // XXX Should be pci_bus3\n<60> \n<61> isa_bus = pci_ebus_init(pci_bus, -1, pbm_irqs);\n<62> \n<63> \n<64> \n<65> i = 0;\n<66> \n<67> if (hwdef->console_serial_base) {\n<68> \n<69> serial_mm_init(address_space_mem, hwdef->console_serial_base, 0,\n<70> \n<71> NULL, 115200, serial_hds[i], DEVICE_BIG_ENDIAN);\n<72> \n<73> i++;\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> serial_hds_isa_init(isa_bus, MAX_SERIAL_PORTS);\n<80> \n<81> parallel_hds_isa_init(isa_bus, MAX_PARALLEL_PORTS);\n<82> \n<83> \n<84> \n<85> for(i = 0; i < nb_nics; i++)\n<86> \n<87> pci_nic_init_nofail(&nd_table[i], pci_bus, "ne2k_pci", NULL);\n<88> \n<89> \n<90> \n<91> ide_drive_get(hd, ARRAY_SIZE(hd));\n<92> \n<93> \n<94> \n<95> pci_cmd646_ide_init(pci_bus, hd, 1);\n<96> \n<97> \n<98> \n<99> isa_create_simple(isa_bus, "i8042");\n<100> \n<101> for(i = 0; i < MAX_FD; i++) {\n<102> \n<103> fd[i] = drive_get(IF_FLOPPY, 0, i);\n<104> \n<105> }\n<106> \n<107> fdctrl_init_isa(isa_bus, fd);\n<108> \n<109> \n<110> \n<111> /* Map NVRAM into I/O (ebus) space */\n<112> \n<113> nvram = m48t59_init(NULL, 0, 0, NVRAM_SIZE, 1968, 59);\n<114> \n<115> s = SYS_BUS_DEVICE(nvram);\n<116> \n<117> memory_region_add_subregion(get_system_io(), 0x2000,\n<118> \n<119> sysbus_mmio_get_region(s, 0));\n<120> \n<121> \n<122> \n<123> initrd_size = 0;\n<124> \n<125> initrd_addr = 0;\n<126> \n<127> kernel_size = sun4u_load_kernel(machine->kernel_filename,\n<128> \n<129> machine->initrd_filename,\n<130> \n<131> ram_size, &initrd_size, &initrd_addr,\n<132> \n<133> &kernel_addr, &kernel_entry);\n<134> \n<135> \n<136> \n<137> sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", machine->ram_size,\n<138> \n<139> machine->boot_order,\n<140> \n<141> kernel_addr, kernel_size,\n<142> \n<143> machine->kernel_cmdline,\n<144> \n<145> initrd_addr, initrd_size,\n<146> \n<147> /* XXX: need an option to load a NVRAM image */\n<148> \n<149> 0,\n<150> \n<151> graphic_width, graphic_height, graphic_depth,\n<152> \n<153> (uint8_t *)&nd_table[0].macaddr);\n<154> \n<155> \n<156> \n<157> fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n<158> \n<159> fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n<160> \n<161> fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n<162> \n<163> fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n<164> \n<165> fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n<166> \n<167> fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_entry);\n<168> \n<169> fw_cfg_add_i64(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n<170> \n<171> if (machine->kernel_cmdline) {\n<172> \n<173> fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE,\n<174> \n<175> strlen(machine->kernel_cmdline) + 1);\n<176> \n<177> fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);\n<178> \n<179> } else {\n<180> \n<181> fw_cfg_add_i32(fw_cfg, FW_CFG_CMDLINE_SIZE, 0);\n<182> \n<183> }\n<184> \n<185> fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_ADDR, initrd_addr);\n<186> \n<187> fw_cfg_add_i64(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n<188> \n<189> fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, machine->boot_order[0]);\n<190> \n<191> \n<192> \n<193> fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_WIDTH, graphic_width);\n<194> \n<195> fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_HEIGHT, graphic_height);\n<196> \n<197> fw_cfg_add_i16(fw_cfg, FW_CFG_SPARC64_DEPTH, graphic_depth);\n<198> \n<199> \n<200> \n<201> qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n<202> \n<203> }\n<204> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> length_f(int argc, char **argv)\n<2> \n<3> {\n<4> \n<5> int64_t size;\n<6> \n<7> char s1[64];\n<8> \n<9> \n<10> \n<11> size = bdrv_getlength(bs);\n<12> \n<13> if (size < 0) {\n<14> \n<15> printf("getlength: %s", strerror(size));\n<16> \n<17> return 0;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> cvtstr(size, s1, sizeof(s1));\n<24> \n<25> printf("%s\n", s1);\n<26> \n<27> return 0;\n<28> \n<29> }\n<30> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int video_get_buffer(AVCodecContext *s, AVFrame *pic)\n<2> \n<3> {\n<4> \n<5> FramePool *pool = s->internal->pool;\n<6> \n<7> const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pic->format);\n<8> \n<9> int i;\n<10> \n<11> \n<12> \n<13> if (pic->data[0]) {\n<14> \n<15> av_log(s, AV_LOG_ERROR, "pic->data[0]!=NULL in avcodec_default_get_buffer\n");\n<16> \n<17> return -1;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> if (!desc) {\n<24> \n<25> av_log(s, AV_LOG_ERROR,\n<26> \n<27> "Unable to get pixel format descriptor for format %s\n",\n<28> \n<29> av_get_pix_fmt_name(pic->format));\n<30> \n<31> return AVERROR(EINVAL);\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> memset(pic->data, 0, sizeof(pic->data));\n<38> \n<39> pic->extended_data = pic->data;\n<40> \n<41> \n<42> \n<43> for (i = 0; i < 4 && pool->pools[i]; i++) {\n<44> \n<45> pic->linesize[i] = pool->linesize[i];\n<46> \n<47> \n<48> \n<49> pic->buf[i] = av_buffer_pool_get(pool->pools[i]);\n<50> \n<51> if (!pic->buf[i])\n<52> \n<53> goto fail;\n<54> \n<55> \n<56> \n<57> pic->data[i] = pic->buf[i]->data;\n<58> \n<59> }\n<60> \n<61> for (; i < AV_NUM_DATA_POINTERS; i++) {\n<62> \n<63> pic->data[i] = NULL;\n<64> \n<65> pic->linesize[i] = 0;\n<66> \n<67> }\n<68> \n<69> if (desc->flags & AV_PIX_FMT_FLAG_PAL ||\n<70> \n<71> desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)\n<72> \n<73> avpriv_set_systematic_pal2((uint32_t *)pic->data[1], pic->format);\n<74> \n<75> \n<76> \n<77> if (s->debug & FF_DEBUG_BUFFERS)\n<78> \n<79> av_log(s, AV_LOG_DEBUG, "default_get_buffer called on pic %p\n", pic);\n<80> \n<81> \n<82> \n<83> return 0;\n<84> \n<85> fail:\n<86> \n<87> av_frame_unref(pic);\n<88> \n<89> return AVERROR(ENOMEM);\n<90> \n<91> }\n<92> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n<2> \n<3> abi_long arg2, abi_long arg3, abi_long arg4,\n<4> \n<5> abi_long arg5, abi_long arg6, abi_long arg7,\n<6> \n<7> abi_long arg8)\n<8> \n<9> {\n<10> \n<11> abi_long ret;\n<12> \n<13> struct stat st;\n<14> \n<15> struct statfs stfs;\n<16> \n<17> void *p;\n<18> \n<19> \n<20> \n<21> #ifdef DEBUG\n<22> \n<23> gemu_log("syscall %d", num);\n<24> \n<25> #endif\n<26> \n<27> if(do_strace)\n<28> \n<29> print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);\n<30> \n<31> \n<32> \n<33> switch(num) {\n<34> \n<35> case TARGET_NR_exit:\n<36> \n<37> #ifdef CONFIG_USE_NPTL\n<38> \n<39> /* In old applications this may be used to implement _exit(2).\n<40> \n<41> However in threaded applictions it is used for thread termination,\n<42> \n<43> and _exit_group is used for application termination.\n<44> \n<45> Do thread termination if we have more then one thread.  */\n<46> \n<47> /* FIXME: This probably breaks if a signal arrives.  We should probably\n<48> \n<49> be disabling signals.  */\n<50> \n<51> if (first_cpu->next_cpu) {\n<52> \n<53> TaskState *ts;\n<54> \n<55> CPUArchState **lastp;\n<56> \n<57> CPUArchState *p;\n<58> \n<59> \n<60> \n<61> cpu_list_lock();\n<62> \n<63> lastp = &first_cpu;\n<64> \n<65> p = first_cpu;\n<66> \n<67> while (p && p != (CPUArchState *)cpu_env) {\n<68> \n<69> lastp = &p->next_cpu;\n<70> \n<71> p = p->next_cpu;\n<72> \n<73> }\n<74> \n<75> /* If we didn't find the CPU for this thread then something is\n<76> \n<77> horribly wrong.  */\n<78> \n<79> if (!p)\n<80> \n<81> abort();\n<82> \n<83> /* Remove the CPU from the list.  */\n<84> \n<85> *lastp = p->next_cpu;\n<86> \n<87> cpu_list_unlock();\n<88> \n<89> ts = ((CPUArchState *)cpu_env)->opaque;\n<90> \n<91> if (ts->child_tidptr) {\n<92> \n<93> put_user_u32(0, ts->child_tidptr);\n<94> \n<95> sys_futex(g2h(ts->child_tidptr), FUTEX_WAKE, INT_MAX,\n<96> \n<97> NULL, NULL, 0);\n<98> \n<99> }\n<100> \n<101> thread_env = NULL;\n<102> \n<103> object_delete(OBJECT(ENV_GET_CPU(cpu_env)));\n<104> \n<105> g_free(ts);\n<106> \n<107> pthread_exit(NULL);\n<108> \n<109> }\n<110> \n<111> #endif\n<112> \n<113> #ifdef TARGET_GPROF\n<114> \n<115> _mcleanup();\n<116> \n<117> #endif\n<118> \n<119> gdb_exit(cpu_env, arg1);\n<120> \n<121> _exit(arg1);\n<122> \n<123> ret = 0; /* avoid warning */\n<124> \n<125> break;\n<126> \n<127> case TARGET_NR_read:\n<128> \n<129> if (arg3 == 0)\n<130> \n<131> ret = 0;\n<132> \n<133> else {\n<134> \n<135> if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n<136> \n<137> goto efault;\n<138> \n<139> ret = get_errno(read(arg1, p, arg3));\n<140> \n<141> unlock_user(p, arg2, ret);\n<142> \n<143> }\n<144> \n<145> break;\n<146> \n<147> case TARGET_NR_write:\n<148> \n<149> if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n<150> \n<151> goto efault;\n<152> \n<153> ret = get_errno(write(arg1, p, arg3));\n<154> \n<155> unlock_user(p, arg2, 0);\n<156> \n<157> break;\n<158> \n<159> case TARGET_NR_open:\n<160> \n<161> if (!(p = lock_user_string(arg1)))\n<162> \n<163> goto efault;\n<164> \n<165> ret = get_errno(do_open(cpu_env, p,\n<166> \n<167> target_to_host_bitmask(arg2, fcntl_flags_tbl),\n<168> \n<169> arg3));\n<170> \n<171> unlock_user(p, arg1, 0);\n<172> \n<173> break;\n<174> \n<175> #if defined(TARGET_NR_openat) && defined(__NR_openat)\n<176> \n<177> case TARGET_NR_openat:\n<178> \n<179> if (!(p = lock_user_string(arg2)))\n<180> \n<181> goto efault;\n<182> \n<183> ret = get_errno(sys_openat(arg1,\n<184> \n<185> path(p),\n<186> \n<187> target_to_host_bitmask(arg3, fcntl_flags_tbl),\n<188> \n<189> arg4));\n<190> \n<191> unlock_user(p, arg2, 0);\n<192> \n<193> break;\n<194> \n<195> #endif\n<196> \n<197> case TARGET_NR_close:\n<198> \n<199> ret = get_errno(close(arg1));\n<200> \n<201> break;\n<202> \n<203> case TARGET_NR_brk:\n<204> \n<205> ret = do_brk(arg1);\n<206> \n<207> break;\n<208> \n<209> case TARGET_NR_fork:\n<210> \n<211> ret = get_errno(do_fork(cpu_env, SIGCHLD, 0, 0, 0, 0));\n<212> \n<213> break;\n<214> \n<215> #ifdef TARGET_NR_waitpid\n<216> \n<217> case TARGET_NR_waitpid:\n<218> \n<219> {\n<220> \n<221> int status;\n<222> \n<223> ret = get_errno(waitpid(arg1, &status, arg3));\n<224> \n<225> if (!is_error(ret) && arg2 && ret\n<226> \n<227> && put_user_s32(host_to_target_waitstatus(status), arg2))\n<228> \n<229> goto efault;\n<230> \n<231> }\n<232> \n<233> break;\n<234> \n<235> #endif\n<236> \n<237> #ifdef TARGET_NR_waitid\n<238> \n<239> case TARGET_NR_waitid:\n<240> \n<241> {\n<242> \n<243> siginfo_t info;\n<244> \n<245> info.si_pid = 0;\n<246> \n<247> ret = get_errno(waitid(arg1, arg2, &info, arg4));\n<248> \n<249> if (!is_error(ret) && arg3 && info.si_pid != 0) {\n<250> \n<251> if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_siginfo_t), 0)))\n<252> \n<253> goto efault;\n<254> \n<255> host_to_target_siginfo(p, &info);\n<256> \n<257> unlock_user(p, arg3, sizeof(target_siginfo_t));\n<258> \n<259> }\n<260> \n<261> }\n<262> \n<263> break;\n<264> \n<265> #endif\n<266> \n<267> #ifdef TARGET_NR_creat /* not on alpha */\n<268> \n<269> case TARGET_NR_creat:\n<270> \n<271> if (!(p = lock_user_string(arg1)))\n<272> \n<273> goto efault;\n<274> \n<275> ret = get_errno(creat(p, arg2));\n<276> \n<277> unlock_user(p, arg1, 0);\n<278> \n<279> break;\n<280> \n<281> #endif\n<282> \n<283> case TARGET_NR_link:\n<284> \n<285> {\n<286> \n<287> void * p2;\n<288> \n<289> p = lock_user_string(arg1);\n<290> \n<291> p2 = lock_user_string(arg2);\n<292> \n<293> if (!p || !p2)\n<294> \n<295> ret = -TARGET_EFAULT;\n<296> \n<297> else\n<298> \n<299> ret = get_errno(link(p, p2));\n<300> \n<301> unlock_user(p2, arg2, 0);\n<302> \n<303> unlock_user(p, arg1, 0);\n<304> \n<305> }\n<306> \n<307> break;\n<308> \n<309> #if defined(TARGET_NR_linkat) && defined(__NR_linkat)\n<310> \n<311> case TARGET_NR_linkat:\n<312> \n<313> {\n<314> \n<315> void * p2 = NULL;\n<316> \n<317> if (!arg2 || !arg4)\n<318> \n<319> goto efault;\n<320> \n<321> p  = lock_user_string(arg2);\n<322> \n<323> p2 = lock_user_string(arg4);\n<324> \n<325> if (!p || !p2)\n<326> \n<327> ret = -TARGET_EFAULT;\n<328> \n<329> else\n<330> \n<331> ret = get_errno(sys_linkat(arg1, p, arg3, p2, arg5));\n<332> \n<333> unlock_user(p, arg2, 0);\n<334> \n<335> unlock_user(p2, arg4, 0);\n<336> \n<337> }\n<338> \n<339> break;\n<340> \n<341> #endif\n<342> \n<343> case TARGET_NR_unlink:\n<344> \n<345> if (!(p = lock_user_string(arg1)))\n<346> \n<347> goto efault;\n<348> \n<349> ret = get_errno(unlink(p));\n<350> \n<351> unlock_user(p, arg1, 0);\n<352> \n<353> break;\n<354> \n<355> #if defined(TARGET_NR_unlinkat) && defined(__NR_unlinkat)\n<356> \n<357> case TARGET_NR_unlinkat:\n<358> \n<359> if (!(p = lock_user_string(arg2)))\n<360> \n<361> goto efault;\n<362> \n<363> ret = get_errno(sys_unlinkat(arg1, p, arg3));\n<364> \n<365> unlock_user(p, arg2, 0);\n<366> \n<367> break;\n<368> \n<369> #endif\n<370> \n<371> case TARGET_NR_execve:\n<372> \n<373> {\n<374> \n<375> char **argp, **envp;\n<376> \n<377> int argc, envc;\n<378> \n<379> abi_ulong gp;\n<380> \n<381> abi_ulong guest_argp;\n<382> \n<383> abi_ulong guest_envp;\n<384> \n<385> abi_ulong addr;\n<386> \n<387> char **q;\n<388> \n<389> int total_size = 0;\n<390> \n<391> \n<392> \n<393> argc = 0;\n<394> \n<395> guest_argp = arg2;\n<396> \n<397> for (gp = guest_argp; gp; gp += sizeof(abi_ulong)) {\n<398> \n<399> if (get_user_ual(addr, gp))\n<400> \n<401> goto efault;\n<402> \n<403> if (!addr)\n<404> \n<405> break;\n<406> \n<407> argc++;\n<408> \n<409> }\n<410> \n<411> envc = 0;\n<412> \n<413> guest_envp = arg3;\n<414> \n<415> for (gp = guest_envp; gp; gp += sizeof(abi_ulong)) {\n<416> \n<417> if (get_user_ual(addr, gp))\n<418> \n<419> goto efault;\n<420> \n<421> if (!addr)\n<422> \n<423> break;\n<424> \n<425> envc++;\n<426> \n<427> }\n<428> \n<429> \n<430> \n<431> argp = alloca((argc + 1) * sizeof(void *));\n<432> \n<433> envp = alloca((envc + 1) * sizeof(void *));\n<434> \n<435> \n<436> \n<437> for (gp = guest_argp, q = argp; gp;\n<438> \n<439> gp += sizeof(abi_ulong), q++) {\n<440> \n<441> if (get_user_ual(addr, gp))\n<442> \n<443> goto execve_efault;\n<444> \n<445> if (!addr)\n<446> \n<447> break;\n<448> \n<449> if (!(*q = lock_user_string(addr)))\n<450> \n<451> goto execve_efault;\n<452> \n<453> total_size += strlen(*q) + 1;\n<454> \n<455> }\n<456> \n<457> *q = NULL;\n<458> \n<459> \n<460> \n<461> for (gp = guest_envp, q = envp; gp;\n<462> \n<463> gp += sizeof(abi_ulong), q++) {\n<464> \n<465> if (get_user_ual(addr, gp))\n<466> \n<467> goto execve_efault;\n<468> \n<469> if (!addr)\n<470> \n<471> break;\n<472> \n<473> if (!(*q = lock_user_string(addr)))\n<474> \n<475> goto execve_efault;\n<476> \n<477> total_size += strlen(*q) + 1;\n<478> \n<479> }\n<480> \n<481> *q = NULL;\n<482> \n<483> \n<484> \n<485> /* This case will not be caught by the host's execve() if its\n<486> \n<487> page size is bigger than the target's. */\n<488> \n<489> if (total_size > MAX_ARG_PAGES * TARGET_PAGE_SIZE) {\n<490> \n<491> ret = -TARGET_E2BIG;\n<492> \n<493> goto execve_end;\n<494> \n<495> }\n<496> \n<497> if (!(p = lock_user_string(arg1)))\n<498> \n<499> goto execve_efault;\n<500> \n<501> ret = get_errno(execve(p, argp, envp));\n<502> \n<503> unlock_user(p, arg1, 0);\n<504> \n<505> \n<506> \n<507> goto execve_end;\n<508> \n<509> \n<510> \n<511> execve_efault:\n<512> \n<513> ret = -TARGET_EFAULT;\n<514> \n<515> \n<516> \n<517> execve_end:\n<518> \n<519> for (gp = guest_argp, q = argp; *q;\n<520> \n<521> gp += sizeof(abi_ulong), q++) {\n<522> \n<523> if (get_user_ual(addr, gp)\n<524> \n<525> || !addr)\n<526> \n<527> break;\n<528> \n<529> unlock_user(*q, addr, 0);\n<530> \n<531> }\n<532> \n<533> for (gp = guest_envp, q = envp; *q;\n<534> \n<535> gp += sizeof(abi_ulong), q++) {\n<536> \n<537> if (get_user_ual(addr, gp)\n<538> \n<539> || !addr)\n<540> \n<541> break;\n<542> \n<543> unlock_user(*q, addr, 0);\n<544> \n<545> }\n<546> \n<547> }\n<548> \n<549> break;\n<550> \n<551> case TARGET_NR_chdir:\n<552> \n<553> if (!(p = lock_user_string(arg1)))\n<554> \n<555> goto efault;\n<556> \n<557> ret = get_errno(chdir(p));\n<558> \n<559> unlock_user(p, arg1, 0);\n<560> \n<561> break;\n<562> \n<563> #ifdef TARGET_NR_time\n<564> \n<565> case TARGET_NR_time:\n<566> \n<567> {\n<568> \n<569> time_t host_time;\n<570> \n<571> ret = get_errno(time(&host_time));\n<572> \n<573> if (!is_error(ret)\n<574> \n<575> && arg1\n<576> \n<577> && put_user_sal(host_time, arg1))\n<578> \n<579> goto efault;\n<580> \n<581> }\n<582> \n<583> break;\n<584> \n<585> #endif\n<586> \n<587> case TARGET_NR_mknod:\n<588> \n<589> if (!(p = lock_user_string(arg1)))\n<590> \n<591> goto efault;\n<592> \n<593> ret = get_errno(mknod(p, arg2, arg3));\n<594> \n<595> unlock_user(p, arg1, 0);\n<596> \n<597> break;\n<598> \n<599> #if defined(TARGET_NR_mknodat) && defined(__NR_mknodat)\n<600> \n<601> case TARGET_NR_mknodat:\n<602> \n<603> if (!(p = lock_user_string(arg2)))\n<604> \n<605> goto efault;\n<606> \n<607> ret = get_errno(sys_mknodat(arg1, p, arg3, arg4));\n<608> \n<609> unlock_user(p, arg2, 0);\n<610> \n<611> break;\n<612> \n<613> #endif\n<614> \n<615> case TARGET_NR_chmod:\n<616> \n<617> if (!(p = lock_user_string(arg1)))\n<618> \n<619> goto efault;\n<620> \n<621> ret = get_errno(chmod(p, arg2));\n<622> \n<623> unlock_user(p, arg1, 0);\n<624> \n<625> break;\n<626> \n<627> #ifdef TARGET_NR_break\n<628> \n<629> case TARGET_NR_break:\n<630> \n<631> goto unimplemented;\n<632> \n<633> #endif\n<634> \n<635> #ifdef TARGET_NR_oldstat\n<636> \n<637> case TARGET_NR_oldstat:\n<638> \n<639> goto unimplemented;\n<640> \n<641> #endif\n<642> \n<643> case TARGET_NR_lseek:\n<644> \n<645> ret = get_errno(lseek(arg1, arg2, arg3));\n<646> \n<647> break;\n<648> \n<649> #if defined(TARGET_NR_getxpid) && defined(TARGET_ALPHA)\n<650> \n<651> /* Alpha specific */\n<652> \n<653> case TARGET_NR_getxpid:\n<654> \n<655> ((CPUAlphaState *)cpu_env)->ir[IR_A4] = getppid();\n<656> \n<657> ret = get_errno(getpid());\n<658> \n<659> break;\n<660> \n<661> #endif\n<662> \n<663> #ifdef TARGET_NR_getpid\n<664> \n<665> case TARGET_NR_getpid:\n<666> \n<667> ret = get_errno(getpid());\n<668> \n<669> break;\n<670> \n<671> #endif\n<672> \n<673> case TARGET_NR_mount:\n<674> \n<675> {\n<676> \n<677> /* need to look at the data field */\n<678> \n<679> void *p2, *p3;\n<680> \n<681> p = lock_user_string(arg1);\n<682> \n<683> p2 = lock_user_string(arg2);\n<684> \n<685> p3 = lock_user_string(arg3);\n<686> \n<687> if (!p || !p2 || !p3)\n<688> \n<689> ret = -TARGET_EFAULT;\n<690> \n<691> else {\n<692> \n<693> /* FIXME - arg5 should be locked, but it isn't clear how to\n<694> \n<695> * do that since it's not guaranteed to be a NULL-terminated\n<696> \n<697> * string.\n<698> \n<699> */\n<700> \n<701> if ( ! arg5 )\n<702> \n<703> ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, NULL));\n<704> \n<705> else\n<706> \n<707> ret = get_errno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5)));\n<708> \n<709> }\n<710> \n<711> unlock_user(p, arg1, 0);\n<712> \n<713> unlock_user(p2, arg2, 0);\n<714> \n<715> unlock_user(p3, arg3, 0);\n<716> \n<717> break;\n<718> \n<719> }\n<720> \n<721> #ifdef TARGET_NR_umount\n<722> \n<723> case TARGET_NR_umount:\n<724> \n<725> if (!(p = lock_user_string(arg1)))\n<726> \n<727> goto efault;\n<728> \n<729> ret = get_errno(umount(p));\n<730> \n<731> unlock_user(p, arg1, 0);\n<732> \n<733> break;\n<734> \n<735> #endif\n<736> \n<737> #ifdef TARGET_NR_stime /* not on alpha */\n<738> \n<739> case TARGET_NR_stime:\n<740> \n<741> {\n<742> \n<743> time_t host_time;\n<744> \n<745> if (get_user_sal(host_time, arg1))\n<746> \n<747> goto efault;\n<748> \n<749> ret = get_errno(stime(&host_time));\n<750> \n<751> }\n<752> \n<753> break;\n<754> \n<755> #endif\n<756> \n<757> case TARGET_NR_ptrace:\n<758> \n<759> goto unimplemented;\n<760> \n<761> #ifdef TARGET_NR_alarm /* not on alpha */\n<762> \n<763> case TARGET_NR_alarm:\n<764> \n<765> ret = alarm(arg1);\n<766> \n<767> break;\n<768> \n<769> #endif\n<770> \n<771> #ifdef TARGET_NR_oldfstat\n<772> \n<773> case TARGET_NR_oldfstat:\n<774> \n<775> goto unimplemented;\n<776> \n<777> #endif\n<778> \n<779> #ifdef TARGET_NR_pause /* not on alpha */\n<780> \n<781> case TARGET_NR_pause:\n<782> \n<783> ret = get_errno(pause());\n<784> \n<785> break;\n<786> \n<787> #endif\n<788> \n<789> #ifdef TARGET_NR_utime\n<790> \n<791> case TARGET_NR_utime:\n<792> \n<793> {\n<794> \n<795> struct utimbuf tbuf, *host_tbuf;\n<796> \n<797> struct target_utimbuf *target_tbuf;\n<798> \n<799> if (arg2) {\n<800> \n<801> if (!lock_user_struct(VERIFY_READ, target_tbuf, arg2, 1))\n<802> \n<803> goto efault;\n<804> \n<805> tbuf.actime = tswapal(target_tbuf->actime);\n<806> \n<807> tbuf.modtime = tswapal(target_tbuf->modtime);\n<808> \n<809> unlock_user_struct(target_tbuf, arg2, 0);\n<810> \n<811> host_tbuf = &tbuf;\n<812> \n<813> } else {\n<814> \n<815> host_tbuf = NULL;\n<816> \n<817> }\n<818> \n<819> if (!(p = lock_user_string(arg1)))\n<820> \n<821> goto efault;\n<822> \n<823> ret = get_errno(utime(p, host_tbuf));\n<824> \n<825> unlock_user(p, arg1, 0);\n<826> \n<827> }\n<828> \n<829> break;\n<830> \n<831> #endif\n<832> \n<833> case TARGET_NR_utimes:\n<834> \n<835> {\n<836> \n<837> struct timeval *tvp, tv[2];\n<838> \n<839> if (arg2) {\n<840> \n<841> if (copy_from_user_timeval(&tv[0], arg2)\n<842> \n<843> || copy_from_user_timeval(&tv[1],\n<844> \n<845> arg2 + sizeof(struct target_timeval)))\n<846> \n<847> goto efault;\n<848> \n<849> tvp = tv;\n<850> \n<851> } else {\n<852> \n<853> tvp = NULL;\n<854> \n<855> }\n<856> \n<857> if (!(p = lock_user_string(arg1)))\n<858> \n<859> goto efault;\n<860> \n<861> ret = get_errno(utimes(p, tvp));\n<862> \n<863> unlock_user(p, arg1, 0);\n<864> \n<865> }\n<866> \n<867> break;\n<868> \n<869> #if defined(TARGET_NR_futimesat) && defined(__NR_futimesat)\n<870> \n<871> case TARGET_NR_futimesat:\n<872> \n<873> {\n<874> \n<875> struct timeval *tvp, tv[2];\n<876> \n<877> if (arg3) {\n<878> \n<879> if (copy_from_user_timeval(&tv[0], arg3)\n<880> \n<881> || copy_from_user_timeval(&tv[1],\n<882> \n<883> arg3 + sizeof(struct target_timeval)))\n<884> \n<885> goto efault;\n<886> \n<887> tvp = tv;\n<888> \n<889> } else {\n<890> \n<891> tvp = NULL;\n<892> \n<893> }\n<894> \n<895> if (!(p = lock_user_string(arg2)))\n<896> \n<897> goto efault;\n<898> \n<899> ret = get_errno(sys_futimesat(arg1, path(p), tvp));\n<900> \n<901> unlock_user(p, arg2, 0);\n<902> \n<903> }\n<904> \n<905> break;\n<906> \n<907> #endif\n<908> \n<909> #ifdef TARGET_NR_stty\n<910> \n<911> case TARGET_NR_stty:\n<912> \n<913> goto unimplemented;\n<914> \n<915> #endif\n<916> \n<917> #ifdef TARGET_NR_gtty\n<918> \n<919> case TARGET_NR_gtty:\n<920> \n<921> goto unimplemented;\n<922> \n<923> #endif\n<924> \n<925> case TARGET_NR_access:\n<926> \n<927> if (!(p = lock_user_string(arg1)))\n<928> \n<929> goto efault;\n<930> \n<931> ret = get_errno(access(path(p), arg2));\n<932> \n<933> unlock_user(p, arg1, 0);\n<934> \n<935> break;\n<936> \n<937> #if defined(TARGET_NR_faccessat) && defined(__NR_faccessat)\n<938> \n<939> case TARGET_NR_faccessat:\n<940> \n<941> if (!(p = lock_user_string(arg2)))\n<942> \n<943> goto efault;\n<944> \n<945> ret = get_errno(sys_faccessat(arg1, p, arg3));\n<946> \n<947> unlock_user(p, arg2, 0);\n<948> \n<949> break;\n<950> \n<951> #endif\n<952> \n<953> #ifdef TARGET_NR_nice /* not on alpha */\n<954> \n<955> case TARGET_NR_nice:\n<956> \n<957> ret = get_errno(nice(arg1));\n<958> \n<959> break;\n<960> \n<961> #endif\n<962> \n<963> #ifdef TARGET_NR_ftime\n<964> \n<965> case TARGET_NR_ftime:\n<966> \n<967> goto unimplemented;\n<968> \n<969> #endif\n<970> \n<971> case TARGET_NR_sync:\n<972> \n<973> sync();\n<974> \n<975> ret = 0;\n<976> \n<977> break;\n<978> \n<979> case TARGET_NR_kill:\n<980> \n<981> ret = get_errno(kill(arg1, target_to_host_signal(arg2)));\n<982> \n<983> break;\n<984> \n<985> case TARGET_NR_rename:\n<986> \n<987> {\n<988> \n<989> void *p2;\n<990> \n<991> p = lock_user_string(arg1);\n<992> \n<993> p2 = lock_user_string(arg2);\n<994> \n<995> if (!p || !p2)\n<996> \n<997> ret = -TARGET_EFAULT;\n<998> \n<999> else\n<1000> \n<1001> ret = get_errno(rename(p, p2));\n<1002> \n<1003> unlock_user(p2, arg2, 0);\n<1004> \n<1005> unlock_user(p, arg1, 0);\n<1006> \n<1007> }\n<1008> \n<1009> break;\n<1010> \n<1011> #if defined(TARGET_NR_renameat) && defined(__NR_renameat)\n<1012> \n<1013> case TARGET_NR_renameat:\n<1014> \n<1015> {\n<1016> \n<1017> void *p2;\n<1018> \n<1019> p  = lock_user_string(arg2);\n<1020> \n<1021> p2 = lock_user_string(arg4);\n<1022> \n<1023> if (!p || !p2)\n<1024> \n<1025> ret = -TARGET_EFAULT;\n<1026> \n<1027> else\n<1028> \n<1029> ret = get_errno(sys_renameat(arg1, p, arg3, p2));\n<1030> \n<1031> unlock_user(p2, arg4, 0);\n<1032> \n<1033> unlock_user(p, arg2, 0);\n<1034> \n<1035> }\n<1036> \n<1037> break;\n<1038> \n<1039> #endif\n<1040> \n<1041> case TARGET_NR_mkdir:\n<1042> \n<1043> if (!(p = lock_user_string(arg1)))\n<1044> \n<1045> goto efault;\n<1046> \n<1047> ret = get_errno(mkdir(p, arg2));\n<1048> \n<1049> unlock_user(p, arg1, 0);\n<1050> \n<1051> break;\n<1052> \n<1053> #if defined(TARGET_NR_mkdirat) && defined(__NR_mkdirat)\n<1054> \n<1055> case TARGET_NR_mkdirat:\n<1056> \n<1057> if (!(p = lock_user_string(arg2)))\n<1058> \n<1059> goto efault;\n<1060> \n<1061> ret = get_errno(sys_mkdirat(arg1, p, arg3));\n<1062> \n<1063> unlock_user(p, arg2, 0);\n<1064> \n<1065> break;\n<1066> \n<1067> #endif\n<1068> \n<1069> case TARGET_NR_rmdir:\n<1070> \n<1071> if (!(p = lock_user_string(arg1)))\n<1072> \n<1073> goto efault;\n<1074> \n<1075> ret = get_errno(rmdir(p));\n<1076> \n<1077> unlock_user(p, arg1, 0);\n<1078> \n<1079> break;\n<1080> \n<1081> case TARGET_NR_dup:\n<1082> \n<1083> ret = get_errno(dup(arg1));\n<1084> \n<1085> break;\n<1086> \n<1087> case TARGET_NR_pipe:\n<1088> \n<1089> ret = do_pipe(cpu_env, arg1, 0, 0);\n<1090> \n<1091> break;\n<1092> \n<1093> #ifdef TARGET_NR_pipe2\n<1094> \n<1095> case TARGET_NR_pipe2:\n<1096> \n<1097> ret = do_pipe(cpu_env, arg1,\n<1098> \n<1099> target_to_host_bitmask(arg2, fcntl_flags_tbl), 1);\n<1100> \n<1101> break;\n<1102> \n<1103> #endif\n<1104> \n<1105> case TARGET_NR_times:\n<1106> \n<1107> {\n<1108> \n<1109> struct target_tms *tmsp;\n<1110> \n<1111> struct tms tms;\n<1112> \n<1113> ret = get_errno(times(&tms));\n<1114> \n<1115> if (arg1) {\n<1116> \n<1117> tmsp = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_tms), 0);\n<1118> \n<1119> if (!tmsp)\n<1120> \n<1121> goto efault;\n<1122> \n<1123> tmsp->tms_utime = tswapal(host_to_target_clock_t(tms.tms_utime));\n<1124> \n<1125> tmsp->tms_stime = tswapal(host_to_target_clock_t(tms.tms_stime));\n<1126> \n<1127> tmsp->tms_cutime = tswapal(host_to_target_clock_t(tms.tms_cutime));\n<1128> \n<1129> tmsp->tms_cstime = tswapal(host_to_target_clock_t(tms.tms_cstime));\n<1130> \n<1131> }\n<1132> \n<1133> if (!is_error(ret))\n<1134> \n<1135> ret = host_to_target_clock_t(ret);\n<1136> \n<1137> }\n<1138> \n<1139> break;\n<1140> \n<1141> #ifdef TARGET_NR_prof\n<1142> \n<1143> case TARGET_NR_prof:\n<1144> \n<1145> goto unimplemented;\n<1146> \n<1147> #endif\n<1148> \n<1149> #ifdef TARGET_NR_signal\n<1150> \n<1151> case TARGET_NR_signal:\n<1152> \n<1153> goto unimplemented;\n<1154> \n<1155> #endif\n<1156> \n<1157> case TARGET_NR_acct:\n<1158> \n<1159> if (arg1 == 0) {\n<1160> \n<1161> ret = get_errno(acct(NULL));\n<1162> \n<1163> } else {\n<1164> \n<1165> if (!(p = lock_user_string(arg1)))\n<1166> \n<1167> goto efault;\n<1168> \n<1169> ret = get_errno(acct(path(p)));\n<1170> \n<1171> unlock_user(p, arg1, 0);\n<1172> \n<1173> }\n<1174> \n<1175> break;\n<1176> \n<1177> #ifdef TARGET_NR_umount2 /* not on alpha */\n<1178> \n<1179> case TARGET_NR_umount2:\n<1180> \n<1181> if (!(p = lock_user_string(arg1)))\n<1182> \n<1183> goto efault;\n<1184> \n<1185> ret = get_errno(umount2(p, arg2));\n<1186> \n<1187> unlock_user(p, arg1, 0);\n<1188> \n<1189> break;\n<1190> \n<1191> #endif\n<1192> \n<1193> #ifdef TARGET_NR_lock\n<1194> \n<1195> case TARGET_NR_lock:\n<1196> \n<1197> goto unimplemented;\n<1198> \n<1199> #endif\n<1200> \n<1201> case TARGET_NR_ioctl:\n<1202> \n<1203> ret = do_ioctl(arg1, arg2, arg3);\n<1204> \n<1205> break;\n<1206> \n<1207> case TARGET_NR_fcntl:\n<1208> \n<1209> ret = do_fcntl(arg1, arg2, arg3);\n<1210> \n<1211> break;\n<1212> \n<1213> #ifdef TARGET_NR_mpx\n<1214> \n<1215> case TARGET_NR_mpx:\n<1216> \n<1217> goto unimplemented;\n<1218> \n<1219> #endif\n<1220> \n<1221> case TARGET_NR_setpgid:\n<1222> \n<1223> ret = get_errno(setpgid(arg1, arg2));\n<1224> \n<1225> break;\n<1226> \n<1227> #ifdef TARGET_NR_ulimit\n<1228> \n<1229> case TARGET_NR_ulimit:\n<1230> \n<1231> goto unimplemented;\n<1232> \n<1233> #endif\n<1234> \n<1235> #ifdef TARGET_NR_oldolduname\n<1236> \n<1237> case TARGET_NR_oldolduname:\n<1238> \n<1239> goto unimplemented;\n<1240> \n<1241> #endif\n<1242> \n<1243> case TARGET_NR_umask:\n<1244> \n<1245> ret = get_errno(umask(arg1));\n<1246> \n<1247> break;\n<1248> \n<1249> case TARGET_NR_chroot:\n<1250> \n<1251> if (!(p = lock_user_string(arg1)))\n<1252> \n<1253> goto efault;\n<1254> \n<1255> ret = get_errno(chroot(p));\n<1256> \n<1257> unlock_user(p, arg1, 0);\n<1258> \n<1259> break;\n<1260> \n<1261> case TARGET_NR_ustat:\n<1262> \n<1263> goto unimplemented;\n<1264> \n<1265> case TARGET_NR_dup2:\n<1266> \n<1267> ret = get_errno(dup2(arg1, arg2));\n<1268> \n<1269> break;\n<1270> \n<1271> #if defined(CONFIG_DUP3) && defined(TARGET_NR_dup3)\n<1272> \n<1273> case TARGET_NR_dup3:\n<1274> \n<1275> ret = get_errno(dup3(arg1, arg2, arg3));\n<1276> \n<1277> break;\n<1278> \n<1279> #endif\n<1280> \n<1281> #ifdef TARGET_NR_getppid /* not on alpha */\n<1282> \n<1283> case TARGET_NR_getppid:\n<1284> \n<1285> ret = get_errno(getppid());\n<1286> \n<1287> break;\n<1288> \n<1289> #endif\n<1290> \n<1291> case TARGET_NR_getpgrp:\n<1292> \n<1293> ret = get_errno(getpgrp());\n<1294> \n<1295> break;\n<1296> \n<1297> case TARGET_NR_setsid:\n<1298> \n<1299> ret = get_errno(setsid());\n<1300> \n<1301> break;\n<1302> \n<1303> #ifdef TARGET_NR_sigaction\n<1304> \n<1305> case TARGET_NR_sigaction:\n<1306> \n<1307> {\n<1308> \n<1309> #if defined(TARGET_ALPHA)\n<1310> \n<1311> struct target_sigaction act, oact, *pact = 0;\n<1312> \n<1313> struct target_old_sigaction *old_act;\n<1314> \n<1315> if (arg2) {\n<1316> \n<1317> if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n<1318> \n<1319> goto efault;\n<1320> \n<1321> act._sa_handler = old_act->_sa_handler;\n<1322> \n<1323> target_siginitset(&act.sa_mask, old_act->sa_mask);\n<1324> \n<1325> act.sa_flags = old_act->sa_flags;\n<1326> \n<1327> act.sa_restorer = 0;\n<1328> \n<1329> unlock_user_struct(old_act, arg2, 0);\n<1330> \n<1331> pact = &act;\n<1332> \n<1333> }\n<1334> \n<1335> ret = get_errno(do_sigaction(arg1, pact, &oact));\n<1336> \n<1337> if (!is_error(ret) && arg3) {\n<1338> \n<1339> if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n<1340> \n<1341> goto efault;\n<1342> \n<1343> old_act->_sa_handler = oact._sa_handler;\n<1344> \n<1345> old_act->sa_mask = oact.sa_mask.sig[0];\n<1346> \n<1347> old_act->sa_flags = oact.sa_flags;\n<1348> \n<1349> unlock_user_struct(old_act, arg3, 1);\n<1350> \n<1351> }\n<1352> \n<1353> #elif defined(TARGET_MIPS)\n<1354> \n<1355> struct target_sigaction act, oact, *pact, *old_act;\n<1356> \n<1357> \n<1358> \n<1359> if (arg2) {\n<1360> \n<1361> if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n<1362> \n<1363> goto efault;\n<1364> \n<1365> act._sa_handler = old_act->_sa_handler;\n<1366> \n<1367> target_siginitset(&act.sa_mask, old_act->sa_mask.sig[0]);\n<1368> \n<1369> act.sa_flags = old_act->sa_flags;\n<1370> \n<1371> unlock_user_struct(old_act, arg2, 0);\n<1372> \n<1373> pact = &act;\n<1374> \n<1375> } else {\n<1376> \n<1377> pact = NULL;\n<1378> \n<1379> }\n<1380> \n<1381> \n<1382> \n<1383> ret = get_errno(do_sigaction(arg1, pact, &oact));\n<1384> \n<1385> \n<1386> \n<1387> if (!is_error(ret) && arg3) {\n<1388> \n<1389> if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n<1390> \n<1391> goto efault;\n<1392> \n<1393> old_act->_sa_handler = oact._sa_handler;\n<1394> \n<1395> old_act->sa_flags = oact.sa_flags;\n<1396> \n<1397> old_act->sa_mask.sig[0] = oact.sa_mask.sig[0];\n<1398> \n<1399> old_act->sa_mask.sig[1] = 0;\n<1400> \n<1401> old_act->sa_mask.sig[2] = 0;\n<1402> \n<1403> old_act->sa_mask.sig[3] = 0;\n<1404> \n<1405> unlock_user_struct(old_act, arg3, 1);\n<1406> \n<1407> }\n<1408> \n<1409> #else\n<1410> \n<1411> struct target_old_sigaction *old_act;\n<1412> \n<1413> struct target_sigaction act, oact, *pact;\n<1414> \n<1415> if (arg2) {\n<1416> \n<1417> if (!lock_user_struct(VERIFY_READ, old_act, arg2, 1))\n<1418> \n<1419> goto efault;\n<1420> \n<1421> act._sa_handler = old_act->_sa_handler;\n<1422> \n<1423> target_siginitset(&act.sa_mask, old_act->sa_mask);\n<1424> \n<1425> act.sa_flags = old_act->sa_flags;\n<1426> \n<1427> act.sa_restorer = old_act->sa_restorer;\n<1428> \n<1429> unlock_user_struct(old_act, arg2, 0);\n<1430> \n<1431> pact = &act;\n<1432> \n<1433> } else {\n<1434> \n<1435> pact = NULL;\n<1436> \n<1437> }\n<1438> \n<1439> ret = get_errno(do_sigaction(arg1, pact, &oact));\n<1440> \n<1441> if (!is_error(ret) && arg3) {\n<1442> \n<1443> if (!lock_user_struct(VERIFY_WRITE, old_act, arg3, 0))\n<1444> \n<1445> goto efault;\n<1446> \n<1447> old_act->_sa_handler = oact._sa_handler;\n<1448> \n<1449> old_act->sa_mask = oact.sa_mask.sig[0];\n<1450> \n<1451> old_act->sa_flags = oact.sa_flags;\n<1452> \n<1453> old_act->sa_restorer = oact.sa_restorer;\n<1454> \n<1455> unlock_user_struct(old_act, arg3, 1);\n<1456> \n<1457> }\n<1458> \n<1459> #endif\n<1460> \n<1461> }\n<1462> \n<1463> break;\n<1464> \n<1465> #endif\n<1466> \n<1467> case TARGET_NR_rt_sigaction:\n<1468> \n<1469> {\n<1470> \n<1471> #if defined(TARGET_ALPHA)\n<1472> \n<1473> struct target_sigaction act, oact, *pact = 0;\n<1474> \n<1475> struct target_rt_sigaction *rt_act;\n<1476> \n<1477> /* ??? arg4 == sizeof(sigset_t).  */\n<1478> \n<1479> if (arg2) {\n<1480> \n<1481> if (!lock_user_struct(VERIFY_READ, rt_act, arg2, 1))\n<1482> \n<1483> goto efault;\n<1484> \n<1485> act._sa_handler = rt_act->_sa_handler;\n<1486> \n<1487> act.sa_mask = rt_act->sa_mask;\n<1488> \n<1489> act.sa_flags = rt_act->sa_flags;\n<1490> \n<1491> act.sa_restorer = arg5;\n<1492> \n<1493> unlock_user_struct(rt_act, arg2, 0);\n<1494> \n<1495> pact = &act;\n<1496> \n<1497> }\n<1498> \n<1499> ret = get_errno(do_sigaction(arg1, pact, &oact));\n<1500> \n<1501> if (!is_error(ret) && arg3) {\n<1502> \n<1503> if (!lock_user_struct(VERIFY_WRITE, rt_act, arg3, 0))\n<1504> \n<1505> goto efault;\n<1506> \n<1507> rt_act->_sa_handler = oact._sa_handler;\n<1508> \n<1509> rt_act->sa_mask = oact.sa_mask;\n<1510> \n<1511> rt_act->sa_flags = oact.sa_flags;\n<1512> \n<1513> unlock_user_struct(rt_act, arg3, 1);\n<1514> \n<1515> }\n<1516> \n<1517> #else\n<1518> \n<1519> struct target_sigaction *act;\n<1520> \n<1521> struct target_sigaction *oact;\n<1522> \n<1523> \n<1524> \n<1525> if (arg2) {\n<1526> \n<1527> if (!lock_user_struct(VERIFY_READ, act, arg2, 1))\n<1528> \n<1529> goto efault;\n<1530> \n<1531> } else\n<1532> \n<1533> act = NULL;\n<1534> \n<1535> if (arg3) {\n<1536> \n<1537> if (!lock_user_struct(VERIFY_WRITE, oact, arg3, 0)) {\n<1538> \n<1539> ret = -TARGET_EFAULT;\n<1540> \n<1541> goto rt_sigaction_fail;\n<1542> \n<1543> }\n<1544> \n<1545> } else\n<1546> \n<1547> oact = NULL;\n<1548> \n<1549> ret = get_errno(do_sigaction(arg1, act, oact));\n<1550> \n<1551> rt_sigaction_fail:\n<1552> \n<1553> if (act)\n<1554> \n<1555> unlock_user_struct(act, arg2, 0);\n<1556> \n<1557> if (oact)\n<1558> \n<1559> unlock_user_struct(oact, arg3, 1);\n<1560> \n<1561> #endif\n<1562> \n<1563> }\n<1564> \n<1565> break;\n<1566> \n<1567> #ifdef TARGET_NR_sgetmask /* not on alpha */\n<1568> \n<1569> case TARGET_NR_sgetmask:\n<1570> \n<1571> {\n<1572> \n<1573> sigset_t cur_set;\n<1574> \n<1575> abi_ulong target_set;\n<1576> \n<1577> sigprocmask(0, NULL, &cur_set);\n<1578> \n<1579> host_to_target_old_sigset(&target_set, &cur_set);\n<1580> \n<1581> ret = target_set;\n<1582> \n<1583> }\n<1584> \n<1585> break;\n<1586> \n<1587> #endif\n<1588> \n<1589> #ifdef TARGET_NR_ssetmask /* not on alpha */\n<1590> \n<1591> case TARGET_NR_ssetmask:\n<1592> \n<1593> {\n<1594> \n<1595> sigset_t set, oset, cur_set;\n<1596> \n<1597> abi_ulong target_set = arg1;\n<1598> \n<1599> sigprocmask(0, NULL, &cur_set);\n<1600> \n<1601> target_to_host_old_sigset(&set, &target_set);\n<1602> \n<1603> sigorset(&set, &set, &cur_set);\n<1604> \n<1605> sigprocmask(SIG_SETMASK, &set, &oset);\n<1606> \n<1607> host_to_target_old_sigset(&target_set, &oset);\n<1608> \n<1609> ret = target_set;\n<1610> \n<1611> }\n<1612> \n<1613> break;\n<1614> \n<1615> #endif\n<1616> \n<1617> #ifdef TARGET_NR_sigprocmask\n<1618> \n<1619> case TARGET_NR_sigprocmask:\n<1620> \n<1621> {\n<1622> \n<1623> #if defined(TARGET_ALPHA)\n<1624> \n<1625> sigset_t set, oldset;\n<1626> \n<1627> abi_ulong mask;\n<1628> \n<1629> int how;\n<1630> \n<1631> \n<1632> \n<1633> switch (arg1) {\n<1634> \n<1635> case TARGET_SIG_BLOCK:\n<1636> \n<1637> how = SIG_BLOCK;\n<1638> \n<1639> break;\n<1640> \n<1641> case TARGET_SIG_UNBLOCK:\n<1642> \n<1643> how = SIG_UNBLOCK;\n<1644> \n<1645> break;\n<1646> \n<1647> case TARGET_SIG_SETMASK:\n<1648> \n<1649> how = SIG_SETMASK;\n<1650> \n<1651> break;\n<1652> \n<1653> default:\n<1654> \n<1655> ret = -TARGET_EINVAL;\n<1656> \n<1657> goto fail;\n<1658> \n<1659> }\n<1660> \n<1661> mask = arg2;\n<1662> \n<1663> target_to_host_old_sigset(&set, &mask);\n<1664> \n<1665> \n<1666> \n<1667> ret = get_errno(sigprocmask(how, &set, &oldset));\n<1668> \n<1669> if (!is_error(ret)) {\n<1670> \n<1671> host_to_target_old_sigset(&mask, &oldset);\n<1672> \n<1673> ret = mask;\n<1674> \n<1675> ((CPUAlphaState *)cpu_env)->ir[IR_V0] = 0; /* force no error */\n<1676> \n<1677> }\n<1678> \n<1679> #else\n<1680> \n<1681> sigset_t set, oldset, *set_ptr;\n<1682> \n<1683> int how;\n<1684> \n<1685> \n<1686> \n<1687> if (arg2) {\n<1688> \n<1689> switch (arg1) {\n<1690> \n<1691> case TARGET_SIG_BLOCK:\n<1692> \n<1693> how = SIG_BLOCK;\n<1694> \n<1695> break;\n<1696> \n<1697> case TARGET_SIG_UNBLOCK:\n<1698> \n<1699> how = SIG_UNBLOCK;\n<1700> \n<1701> break;\n<1702> \n<1703> case TARGET_SIG_SETMASK:\n<1704> \n<1705> how = SIG_SETMASK;\n<1706> \n<1707> break;\n<1708> \n<1709> default:\n<1710> \n<1711> ret = -TARGET_EINVAL;\n<1712> \n<1713> goto fail;\n<1714> \n<1715> }\n<1716> \n<1717> if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n<1718> \n<1719> goto efault;\n<1720> \n<1721> target_to_host_old_sigset(&set, p);\n<1722> \n<1723> unlock_user(p, arg2, 0);\n<1724> \n<1725> set_ptr = &set;\n<1726> \n<1727> } else {\n<1728> \n<1729> how = 0;\n<1730> \n<1731> set_ptr = NULL;\n<1732> \n<1733> }\n<1734> \n<1735> ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n<1736> \n<1737> if (!is_error(ret) && arg3) {\n<1738> \n<1739> if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n<1740> \n<1741> goto efault;\n<1742> \n<1743> host_to_target_old_sigset(p, &oldset);\n<1744> \n<1745> unlock_user(p, arg3, sizeof(target_sigset_t));\n<1746> \n<1747> }\n<1748> \n<1749> #endif\n<1750> \n<1751> }\n<1752> \n<1753> break;\n<1754> \n<1755> #endif\n<1756> \n<1757> case TARGET_NR_rt_sigprocmask:\n<1758> \n<1759> {\n<1760> \n<1761> int how = arg1;\n<1762> \n<1763> sigset_t set, oldset, *set_ptr;\n<1764> \n<1765> \n<1766> \n<1767> if (arg2) {\n<1768> \n<1769> switch(how) {\n<1770> \n<1771> case TARGET_SIG_BLOCK:\n<1772> \n<1773> how = SIG_BLOCK;\n<1774> \n<1775> break;\n<1776> \n<1777> case TARGET_SIG_UNBLOCK:\n<1778> \n<1779> how = SIG_UNBLOCK;\n<1780> \n<1781> break;\n<1782> \n<1783> case TARGET_SIG_SETMASK:\n<1784> \n<1785> how = SIG_SETMASK;\n<1786> \n<1787> break;\n<1788> \n<1789> default:\n<1790> \n<1791> ret = -TARGET_EINVAL;\n<1792> \n<1793> goto fail;\n<1794> \n<1795> }\n<1796> \n<1797> if (!(p = lock_user(VERIFY_READ, arg2, sizeof(target_sigset_t), 1)))\n<1798> \n<1799> goto efault;\n<1800> \n<1801> target_to_host_sigset(&set, p);\n<1802> \n<1803> unlock_user(p, arg2, 0);\n<1804> \n<1805> set_ptr = &set;\n<1806> \n<1807> } else {\n<1808> \n<1809> how = 0;\n<1810> \n<1811> set_ptr = NULL;\n<1812> \n<1813> }\n<1814> \n<1815> ret = get_errno(sigprocmask(how, set_ptr, &oldset));\n<1816> \n<1817> if (!is_error(ret) && arg3) {\n<1818> \n<1819> if (!(p = lock_user(VERIFY_WRITE, arg3, sizeof(target_sigset_t), 0)))\n<1820> \n<1821> goto efault;\n<1822> \n<1823> host_to_target_sigset(p, &oldset);\n<1824> \n<1825> unlock_user(p, arg3, sizeof(target_sigset_t));\n<1826> \n<1827> }\n<1828> \n<1829> }\n<1830> \n<1831> break;\n<1832> \n<1833> #ifdef TARGET_NR_sigpending\n<1834> \n<1835> case TARGET_NR_sigpending:\n<1836> \n<1837> {\n<1838> \n<1839> sigset_t set;\n<1840> \n<1841> ret = get_errno(sigpending(&set));\n<1842> \n<1843> if (!is_error(ret)) {\n<1844> \n<1845> if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n<1846> \n<1847> goto efault;\n<1848> \n<1849> host_to_target_old_sigset(p, &set);\n<1850> \n<1851> unlock_user(p, arg1, sizeof(target_sigset_t));\n<1852> \n<1853> }\n<1854> \n<1855> }\n<1856> \n<1857> break;\n<1858> \n<1859> #endif\n<1860> \n<1861> case TARGET_NR_rt_sigpending:\n<1862> \n<1863> {\n<1864> \n<1865> sigset_t set;\n<1866> \n<1867> ret = get_errno(sigpending(&set));\n<1868> \n<1869> if (!is_error(ret)) {\n<1870> \n<1871> if (!(p = lock_user(VERIFY_WRITE, arg1, sizeof(target_sigset_t), 0)))\n<1872> \n<1873> goto efault;\n<1874> \n<1875> host_to_target_sigset(p, &set);\n<1876> \n<1877> unlock_user(p, arg1, sizeof(target_sigset_t));\n<1878> \n<1879> }\n<1880> \n<1881> }\n<1882> \n<1883> break;\n<1884> \n<1885> #ifdef TARGET_NR_sigsuspend\n<1886> \n<1887> case TARGET_NR_sigsuspend:\n<1888> \n<1889> {\n<1890> \n<1891> sigset_t set;\n<1892> \n<1893> #if defined(TARGET_ALPHA)\n<1894> \n<1895> abi_ulong mask = arg1;\n<1896> \n<1897> target_to_host_old_sigset(&set, &mask);\n<1898> \n<1899> #else\n<1900> \n<1901> if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n<1902> \n<1903> goto efault;\n<1904> \n<1905> target_to_host_old_sigset(&set, p);\n<1906> \n<1907> unlock_user(p, arg1, 0);\n<1908> \n<1909> #endif\n<1910> \n<1911> ret = get_errno(sigsuspend(&set));\n<1912> \n<1913> }\n<1914> \n<1915> break;\n<1916> \n<1917> #endif\n<1918> \n<1919> case TARGET_NR_rt_sigsuspend:\n<1920> \n<1921> {\n<1922> \n<1923> sigset_t set;\n<1924> \n<1925> if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n<1926> \n<1927> goto efault;\n<1928> \n<1929> target_to_host_sigset(&set, p);\n<1930> \n<1931> unlock_user(p, arg1, 0);\n<1932> \n<1933> ret = get_errno(sigsuspend(&set));\n<1934> \n<1935> }\n<1936> \n<1937> break;\n<1938> \n<1939> case TARGET_NR_rt_sigtimedwait:\n<1940> \n<1941> {\n<1942> \n<1943> sigset_t set;\n<1944> \n<1945> struct timespec uts, *puts;\n<1946> \n<1947> siginfo_t uinfo;\n<1948> \n<1949> \n<1950> \n<1951> if (!(p = lock_user(VERIFY_READ, arg1, sizeof(target_sigset_t), 1)))\n<1952> \n<1953> goto efault;\n<1954> \n<1955> target_to_host_sigset(&set, p);\n<1956> \n<1957> unlock_user(p, arg1, 0);\n<1958> \n<1959> if (arg3) {\n<1960> \n<1961> puts = &uts;\n<1962> \n<1963> target_to_host_timespec(puts, arg3);\n<1964> \n<1965> } else {\n<1966> \n<1967> puts = NULL;\n<1968> \n<1969> }\n<1970> \n<1971> ret = get_errno(sigtimedwait(&set, &uinfo, puts));\n<1972> \n<1973> if (!is_error(ret) && arg2) {\n<1974> \n<1975> if (!(p = lock_user(VERIFY_WRITE, arg2, sizeof(target_siginfo_t), 0)))\n<1976> \n<1977> goto efault;\n<1978> \n<1979> host_to_target_siginfo(p, &uinfo);\n<1980> \n<1981> unlock_user(p, arg2, sizeof(target_siginfo_t));\n<1982> \n<1983> }\n<1984> \n<1985> }\n<1986> \n<1987> break;\n<1988> \n<1989> case TARGET_NR_rt_sigqueueinfo:\n<1990> \n<1991> {\n<1992> \n<1993> siginfo_t uinfo;\n<1994> \n<1995> if (!(p = lock_user(VERIFY_READ, arg3, sizeof(target_sigset_t), 1)))\n<1996> \n<1997> goto efault;\n<1998> \n<1999> target_to_host_siginfo(&uinfo, p);\n<2000> \n<2001> unlock_user(p, arg1, 0);\n<2002> \n<2003> ret = get_errno(sys_rt_sigqueueinfo(arg1, arg2, &uinfo));\n<2004> \n<2005> }\n<2006> \n<2007> break;\n<2008> \n<2009> #ifdef TARGET_NR_sigreturn\n<2010> \n<2011> case TARGET_NR_sigreturn:\n<2012> \n<2013> /* NOTE: ret is eax, so not transcoding must be done */\n<2014> \n<2015> ret = do_sigreturn(cpu_env);\n<2016> \n<2017> break;\n<2018> \n<2019> #endif\n<2020> \n<2021> case TARGET_NR_rt_sigreturn:\n<2022> \n<2023> /* NOTE: ret is eax, so not transcoding must be done */\n<2024> \n<2025> ret = do_rt_sigreturn(cpu_env);\n<2026> \n<2027> break;\n<2028> \n<2029> case TARGET_NR_sethostname:\n<2030> \n<2031> if (!(p = lock_user_string(arg1)))\n<2032> \n<2033> goto efault;\n<2034> \n<2035> ret = get_errno(sethostname(p, arg2));\n<2036> \n<2037> unlock_user(p, arg1, 0);\n<2038> \n<2039> break;\n<2040> \n<2041> case TARGET_NR_setrlimit:\n<2042> \n<2043> {\n<2044> \n<2045> int resource = target_to_host_resource(arg1);\n<2046> \n<2047> struct target_rlimit *target_rlim;\n<2048> \n<2049> struct rlimit rlim;\n<2050> \n<2051> if (!lock_user_struct(VERIFY_READ, target_rlim, arg2, 1))\n<2052> \n<2053> goto efault;\n<2054> \n<2055> rlim.rlim_cur = target_to_host_rlim(target_rlim->rlim_cur);\n<2056> \n<2057> rlim.rlim_max = target_to_host_rlim(target_rlim->rlim_max);\n<2058> \n<2059> unlock_user_struct(target_rlim, arg2, 0);\n<2060> \n<2061> ret = get_errno(setrlimit(resource, &rlim));\n<2062> \n<2063> }\n<2064> \n<2065> break;\n<2066> \n<2067> case TARGET_NR_getrlimit:\n<2068> \n<2069> {\n<2070> \n<2071> int resource = target_to_host_resource(arg1);\n<2072> \n<2073> struct target_rlimit *target_rlim;\n<2074> \n<2075> struct rlimit rlim;\n<2076> \n<2077> \n<2078> \n<2079> ret = get_errno(getrlimit(resource, &rlim));\n<2080> \n<2081> if (!is_error(ret)) {\n<2082> \n<2083> if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n<2084> \n<2085> goto efault;\n<2086> \n<2087> target_rlim->rlim_cur = host_to_target_rlim(rlim.rlim_cur);\n<2088> \n<2089> target_rlim->rlim_max = host_to_target_rlim(rlim.rlim_max);\n<2090> \n<2091> unlock_user_struct(target_rlim, arg2, 1);\n<2092> \n<2093> }\n<2094> \n<2095> }\n<2096> \n<2097> break;\n<2098> \n<2099> case TARGET_NR_getrusage:\n<2100> \n<2101> {\n<2102> \n<2103> struct rusage rusage;\n<2104> \n<2105> ret = get_errno(getrusage(arg1, &rusage));\n<2106> \n<2107> if (!is_error(ret)) {\n<2108> \n<2109> host_to_target_rusage(arg2, &rusage);\n<2110> \n<2111> }\n<2112> \n<2113> }\n<2114> \n<2115> break;\n<2116> \n<2117> case TARGET_NR_gettimeofday:\n<2118> \n<2119> {\n<2120> \n<2121> struct timeval tv;\n<2122> \n<2123> ret = get_errno(gettimeofday(&tv, NULL));\n<2124> \n<2125> if (!is_error(ret)) {\n<2126> \n<2127> if (copy_to_user_timeval(arg1, &tv))\n<2128> \n<2129> goto efault;\n<2130> \n<2131> }\n<2132> \n<2133> }\n<2134> \n<2135> break;\n<2136> \n<2137> case TARGET_NR_settimeofday:\n<2138> \n<2139> {\n<2140> \n<2141> struct timeval tv;\n<2142> \n<2143> if (copy_from_user_timeval(&tv, arg1))\n<2144> \n<2145> goto efault;\n<2146> \n<2147> ret = get_errno(settimeofday(&tv, NULL));\n<2148> \n<2149> }\n<2150> \n<2151> break;\n<2152> \n<2153> #if defined(TARGET_NR_select) && !defined(TARGET_S390X) && !defined(TARGET_S390)\n<2154> \n<2155> case TARGET_NR_select:\n<2156> \n<2157> {\n<2158> \n<2159> struct target_sel_arg_struct *sel;\n<2160> \n<2161> abi_ulong inp, outp, exp, tvp;\n<2162> \n<2163> long nsel;\n<2164> \n<2165> \n<2166> \n<2167> if (!lock_user_struct(VERIFY_READ, sel, arg1, 1))\n<2168> \n<2169> goto efault;\n<2170> \n<2171> nsel = tswapal(sel->n);\n<2172> \n<2173> inp = tswapal(sel->inp);\n<2174> \n<2175> outp = tswapal(sel->outp);\n<2176> \n<2177> exp = tswapal(sel->exp);\n<2178> \n<2179> tvp = tswapal(sel->tvp);\n<2180> \n<2181> unlock_user_struct(sel, arg1, 0);\n<2182> \n<2183> ret = do_select(nsel, inp, outp, exp, tvp);\n<2184> \n<2185> }\n<2186> \n<2187> break;\n<2188> \n<2189> #endif\n<2190> \n<2191> #ifdef TARGET_NR_pselect6\n<2192> \n<2193> case TARGET_NR_pselect6:\n<2194> \n<2195> {\n<2196> \n<2197> abi_long rfd_addr, wfd_addr, efd_addr, n, ts_addr;\n<2198> \n<2199> fd_set rfds, wfds, efds;\n<2200> \n<2201> fd_set *rfds_ptr, *wfds_ptr, *efds_ptr;\n<2202> \n<2203> struct timespec ts, *ts_ptr;\n<2204> \n<2205> \n<2206> \n<2207> /*\n<2208> \n<2209> * The 6th arg is actually two args smashed together,\n<2210> \n<2211> * so we cannot use the C library.\n<2212> \n<2213> */\n<2214> \n<2215> sigset_t set;\n<2216> \n<2217> struct {\n<2218> \n<2219> sigset_t *set;\n<2220> \n<2221> size_t size;\n<2222> \n<2223> } sig, *sig_ptr;\n<2224> \n<2225> \n<2226> \n<2227> abi_ulong arg_sigset, arg_sigsize, *arg7;\n<2228> \n<2229> target_sigset_t *target_sigset;\n<2230> \n<2231> \n<2232> \n<2233> n = arg1;\n<2234> \n<2235> rfd_addr = arg2;\n<2236> \n<2237> wfd_addr = arg3;\n<2238> \n<2239> efd_addr = arg4;\n<2240> \n<2241> ts_addr = arg5;\n<2242> \n<2243> \n<2244> \n<2245> ret = copy_from_user_fdset_ptr(&rfds, &rfds_ptr, rfd_addr, n);\n<2246> \n<2247> if (ret) {\n<2248> \n<2249> goto fail;\n<2250> \n<2251> }\n<2252> \n<2253> ret = copy_from_user_fdset_ptr(&wfds, &wfds_ptr, wfd_addr, n);\n<2254> \n<2255> if (ret) {\n<2256> \n<2257> goto fail;\n<2258> \n<2259> }\n<2260> \n<2261> ret = copy_from_user_fdset_ptr(&efds, &efds_ptr, efd_addr, n);\n<2262> \n<2263> if (ret) {\n<2264> \n<2265> goto fail;\n<2266> \n<2267> }\n<2268> \n<2269> \n<2270> \n<2271> /*\n<2272> \n<2273> * This takes a timespec, and not a timeval, so we cannot\n<2274> \n<2275> * use the do_select() helper ...\n<2276> \n<2277> */\n<2278> \n<2279> if (ts_addr) {\n<2280> \n<2281> if (target_to_host_timespec(&ts, ts_addr)) {\n<2282> \n<2283> goto efault;\n<2284> \n<2285> }\n<2286> \n<2287> ts_ptr = &ts;\n<2288> \n<2289> } else {\n<2290> \n<2291> ts_ptr = NULL;\n<2292> \n<2293> }\n<2294> \n<2295> \n<2296> \n<2297> /* Extract the two packed args for the sigset */\n<2298> \n<2299> if (arg6) {\n<2300> \n<2301> sig_ptr = &sig;\n<2302> \n<2303> sig.size = _NSIG / 8;\n<2304> \n<2305> \n<2306> \n<2307> arg7 = lock_user(VERIFY_READ, arg6, sizeof(*arg7) * 2, 1);\n<2308> \n<2309> if (!arg7) {\n<2310> \n<2311> goto efault;\n<2312> \n<2313> }\n<2314> \n<2315> arg_sigset = tswapal(arg7[0]);\n<2316> \n<2317> arg_sigsize = tswapal(arg7[1]);\n<2318> \n<2319> unlock_user(arg7, arg6, 0);\n<2320> \n<2321> \n<2322> \n<2323> if (arg_sigset) {\n<2324> \n<2325> sig.set = &set;\n<2326> \n<2327> if (arg_sigsize != sizeof(*target_sigset)) {\n<2328> \n<2329> /* Like the kernel, we enforce correct size sigsets */\n<2330> \n<2331> ret = -TARGET_EINVAL;\n<2332> \n<2333> goto fail;\n<2334> \n<2335> }\n<2336> \n<2337> target_sigset = lock_user(VERIFY_READ, arg_sigset,\n<2338> \n<2339> sizeof(*target_sigset), 1);\n<2340> \n<2341> if (!target_sigset) {\n<2342> \n<2343> goto efault;\n<2344> \n<2345> }\n<2346> \n<2347> target_to_host_sigset(&set, target_sigset);\n<2348> \n<2349> unlock_user(target_sigset, arg_sigset, 0);\n<2350> \n<2351> } else {\n<2352> \n<2353> sig.set = NULL;\n<2354> \n<2355> }\n<2356> \n<2357> } else {\n<2358> \n<2359> sig_ptr = NULL;\n<2360> \n<2361> }\n<2362> \n<2363> \n<2364> \n<2365> ret = get_errno(sys_pselect6(n, rfds_ptr, wfds_ptr, efds_ptr,\n<2366> \n<2367> ts_ptr, sig_ptr));\n<2368> \n<2369> \n<2370> \n<2371> if (!is_error(ret)) {\n<2372> \n<2373> if (rfd_addr && copy_to_user_fdset(rfd_addr, &rfds, n))\n<2374> \n<2375> goto efault;\n<2376> \n<2377> if (wfd_addr && copy_to_user_fdset(wfd_addr, &wfds, n))\n<2378> \n<2379> goto efault;\n<2380> \n<2381> if (efd_addr && copy_to_user_fdset(efd_addr, &efds, n))\n<2382> \n<2383> goto efault;\n<2384> \n<2385> \n<2386> \n<2387> if (ts_addr && host_to_target_timespec(ts_addr, &ts))\n<2388> \n<2389> goto efault;\n<2390> \n<2391> }\n<2392> \n<2393> }\n<2394> \n<2395> break;\n<2396> \n<2397> #endif\n<2398> \n<2399> case TARGET_NR_symlink:\n<2400> \n<2401> {\n<2402> \n<2403> void *p2;\n<2404> \n<2405> p = lock_user_string(arg1);\n<2406> \n<2407> p2 = lock_user_string(arg2);\n<2408> \n<2409> if (!p || !p2)\n<2410> \n<2411> ret = -TARGET_EFAULT;\n<2412> \n<2413> else\n<2414> \n<2415> ret = get_errno(symlink(p, p2));\n<2416> \n<2417> unlock_user(p2, arg2, 0);\n<2418> \n<2419> unlock_user(p, arg1, 0);\n<2420> \n<2421> }\n<2422> \n<2423> break;\n<2424> \n<2425> #if defined(TARGET_NR_symlinkat) && defined(__NR_symlinkat)\n<2426> \n<2427> case TARGET_NR_symlinkat:\n<2428> \n<2429> {\n<2430> \n<2431> void *p2;\n<2432> \n<2433> p  = lock_user_string(arg1);\n<2434> \n<2435> p2 = lock_user_string(arg3);\n<2436> \n<2437> if (!p || !p2)\n<2438> \n<2439> ret = -TARGET_EFAULT;\n<2440> \n<2441> else\n<2442> \n<2443> ret = get_errno(sys_symlinkat(p, arg2, p2));\n<2444> \n<2445> unlock_user(p2, arg3, 0);\n<2446> \n<2447> unlock_user(p, arg1, 0);\n<2448> \n<2449> }\n<2450> \n<2451> break;\n<2452> \n<2453> #endif\n<2454> \n<2455> #ifdef TARGET_NR_oldlstat\n<2456> \n<2457> case TARGET_NR_oldlstat:\n<2458> \n<2459> goto unimplemented;\n<2460> \n<2461> #endif\n<2462> \n<2463> case TARGET_NR_readlink:\n<2464> \n<2465> {\n<2466> \n<2467> void *p2, *temp;\n<2468> \n<2469> p = lock_user_string(arg1);\n<2470> \n<2471> p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n<2472> \n<2473> if (!p || !p2)\n<2474> \n<2475> ret = -TARGET_EFAULT;\n<2476> \n<2477> else {\n<2478> \n<2479> if (strncmp((const char *)p, "/proc/self/exe", 14) == 0) {\n<2480> \n<2481> char real[PATH_MAX];\n<2482> \n<2483> temp = realpath(exec_path,real);\n<2484> \n<2485> ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n<2486> \n<2487> snprintf((char *)p2, arg3, "%s", real);\n<2488> \n<2489> }\n<2490> \n<2491> else\n<2492> \n<2493> ret = get_errno(readlink(path(p), p2, arg3));\n<2494> \n<2495> }\n<2496> \n<2497> unlock_user(p2, arg2, ret);\n<2498> \n<2499> unlock_user(p, arg1, 0);\n<2500> \n<2501> }\n<2502> \n<2503> break;\n<2504> \n<2505> #if defined(TARGET_NR_readlinkat) && defined(__NR_readlinkat)\n<2506> \n<2507> case TARGET_NR_readlinkat:\n<2508> \n<2509> {\n<2510> \n<2511> void *p2;\n<2512> \n<2513> p  = lock_user_string(arg2);\n<2514> \n<2515> p2 = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n<2516> \n<2517> if (!p || !p2)\n<2518> \n<2519> ret = -TARGET_EFAULT;\n<2520> \n<2521> else\n<2522> \n<2523> ret = get_errno(sys_readlinkat(arg1, path(p), p2, arg4));\n<2524> \n<2525> unlock_user(p2, arg3, ret);\n<2526> \n<2527> unlock_user(p, arg2, 0);\n<2528> \n<2529> }\n<2530> \n<2531> break;\n<2532> \n<2533> #endif\n<2534> \n<2535> #ifdef TARGET_NR_uselib\n<2536> \n<2537> case TARGET_NR_uselib:\n<2538> \n<2539> goto unimplemented;\n<2540> \n<2541> #endif\n<2542> \n<2543> #ifdef TARGET_NR_swapon\n<2544> \n<2545> case TARGET_NR_swapon:\n<2546> \n<2547> if (!(p = lock_user_string(arg1)))\n<2548> \n<2549> goto efault;\n<2550> \n<2551> ret = get_errno(swapon(p, arg2));\n<2552> \n<2553> unlock_user(p, arg1, 0);\n<2554> \n<2555> break;\n<2556> \n<2557> #endif\n<2558> \n<2559> case TARGET_NR_reboot:\n<2560> \n<2561> if (!(p = lock_user_string(arg4)))\n<2562> \n<2563> goto efault;\n<2564> \n<2565> ret = reboot(arg1, arg2, arg3, p);\n<2566> \n<2567> unlock_user(p, arg4, 0);\n<2568> \n<2569> break;\n<2570> \n<2571> #ifdef TARGET_NR_readdir\n<2572> \n<2573> case TARGET_NR_readdir:\n<2574> \n<2575> goto unimplemented;\n<2576> \n<2577> #endif\n<2578> \n<2579> #ifdef TARGET_NR_mmap\n<2580> \n<2581> case TARGET_NR_mmap:\n<2582> \n<2583> #if (defined(TARGET_I386) && defined(TARGET_ABI32)) || defined(TARGET_ARM) || \\n<2584> \n<2585> defined(TARGET_M68K) || defined(TARGET_CRIS) || defined(TARGET_MICROBLAZE) \\n<2586> \n<2587> || defined(TARGET_S390X)\n<2588> \n<2589> {\n<2590> \n<2591> abi_ulong *v;\n<2592> \n<2593> abi_ulong v1, v2, v3, v4, v5, v6;\n<2594> \n<2595> if (!(v = lock_user(VERIFY_READ, arg1, 6 * sizeof(abi_ulong), 1)))\n<2596> \n<2597> goto efault;\n<2598> \n<2599> v1 = tswapal(v[0]);\n<2600> \n<2601> v2 = tswapal(v[1]);\n<2602> \n<2603> v3 = tswapal(v[2]);\n<2604> \n<2605> v4 = tswapal(v[3]);\n<2606> \n<2607> v5 = tswapal(v[4]);\n<2608> \n<2609> v6 = tswapal(v[5]);\n<2610> \n<2611> unlock_user(v, arg1, 0);\n<2612> \n<2613> ret = get_errno(target_mmap(v1, v2, v3,\n<2614> \n<2615> target_to_host_bitmask(v4, mmap_flags_tbl),\n<2616> \n<2617> v5, v6));\n<2618> \n<2619> }\n<2620> \n<2621> #else\n<2622> \n<2623> ret = get_errno(target_mmap(arg1, arg2, arg3,\n<2624> \n<2625> target_to_host_bitmask(arg4, mmap_flags_tbl),\n<2626> \n<2627> arg5,\n<2628> \n<2629> arg6));\n<2630> \n<2631> #endif\n<2632> \n<2633> break;\n<2634> \n<2635> #endif\n<2636> \n<2637> #ifdef TARGET_NR_mmap2\n<2638> \n<2639> case TARGET_NR_mmap2:\n<2640> \n<2641> #ifndef MMAP_SHIFT\n<2642> \n<2643> #define MMAP_SHIFT 12\n<2644> \n<2645> #endif\n<2646> \n<2647> ret = get_errno(target_mmap(arg1, arg2, arg3,\n<2648> \n<2649> target_to_host_bitmask(arg4, mmap_flags_tbl),\n<2650> \n<2651> arg5,\n<2652> \n<2653> arg6 << MMAP_SHIFT));\n<2654> \n<2655> break;\n<2656> \n<2657> #endif\n<2658> \n<2659> case TARGET_NR_munmap:\n<2660> \n<2661> ret = get_errno(target_munmap(arg1, arg2));\n<2662> \n<2663> break;\n<2664> \n<2665> case TARGET_NR_mprotect:\n<2666> \n<2667> {\n<2668> \n<2669> TaskState *ts = ((CPUArchState *)cpu_env)->opaque;\n<2670> \n<2671> /* Special hack to detect libc making the stack executable.  */\n<2672> \n<2673> if ((arg3 & PROT_GROWSDOWN)\n<2674> \n<2675> && arg1 >= ts->info->stack_limit\n<2676> \n<2677> && arg1 <= ts->info->start_stack) {\n<2678> \n<2679> arg3 &= ~PROT_GROWSDOWN;\n<2680> \n<2681> arg2 = arg2 + arg1 - ts->info->stack_limit;\n<2682> \n<2683> arg1 = ts->info->stack_limit;\n<2684> \n<2685> }\n<2686> \n<2687> }\n<2688> \n<2689> ret = get_errno(target_mprotect(arg1, arg2, arg3));\n<2690> \n<2691> break;\n<2692> \n<2693> #ifdef TARGET_NR_mremap\n<2694> \n<2695> case TARGET_NR_mremap:\n<2696> \n<2697> ret = get_errno(target_mremap(arg1, arg2, arg3, arg4, arg5));\n<2698> \n<2699> break;\n<2700> \n<2701> #endif\n<2702> \n<2703> /* ??? msync/mlock/munlock are broken for softmmu.  */\n<2704> \n<2705> #ifdef TARGET_NR_msync\n<2706> \n<2707> case TARGET_NR_msync:\n<2708> \n<2709> ret = get_errno(msync(g2h(arg1), arg2, arg3));\n<2710> \n<2711> break;\n<2712> \n<2713> #endif\n<2714> \n<2715> #ifdef TARGET_NR_mlock\n<2716> \n<2717> case TARGET_NR_mlock:\n<2718> \n<2719> ret = get_errno(mlock(g2h(arg1), arg2));\n<2720> \n<2721> break;\n<2722> \n<2723> #endif\n<2724> \n<2725> #ifdef TARGET_NR_munlock\n<2726> \n<2727> case TARGET_NR_munlock:\n<2728> \n<2729> ret = get_errno(munlock(g2h(arg1), arg2));\n<2730> \n<2731> break;\n<2732> \n<2733> #endif\n<2734> \n<2735> #ifdef TARGET_NR_mlockall\n<2736> \n<2737> case TARGET_NR_mlockall:\n<2738> \n<2739> ret = get_errno(mlockall(arg1));\n<2740> \n<2741> break;\n<2742> \n<2743> #endif\n<2744> \n<2745> #ifdef TARGET_NR_munlockall\n<2746> \n<2747> case TARGET_NR_munlockall:\n<2748> \n<2749> ret = get_errno(munlockall());\n<2750> \n<2751> break;\n<2752> \n<2753> #endif\n<2754> \n<2755> case TARGET_NR_truncate:\n<2756> \n<2757> if (!(p = lock_user_string(arg1)))\n<2758> \n<2759> goto efault;\n<2760> \n<2761> ret = get_errno(truncate(p, arg2));\n<2762> \n<2763> unlock_user(p, arg1, 0);\n<2764> \n<2765> break;\n<2766> \n<2767> case TARGET_NR_ftruncate:\n<2768> \n<2769> ret = get_errno(ftruncate(arg1, arg2));\n<2770> \n<2771> break;\n<2772> \n<2773> case TARGET_NR_fchmod:\n<2774> \n<2775> ret = get_errno(fchmod(arg1, arg2));\n<2776> \n<2777> break;\n<2778> \n<2779> #if defined(TARGET_NR_fchmodat) && defined(__NR_fchmodat)\n<2780> \n<2781> case TARGET_NR_fchmodat:\n<2782> \n<2783> if (!(p = lock_user_string(arg2)))\n<2784> \n<2785> goto efault;\n<2786> \n<2787> ret = get_errno(sys_fchmodat(arg1, p, arg3));\n<2788> \n<2789> unlock_user(p, arg2, 0);\n<2790> \n<2791> break;\n<2792> \n<2793> #endif\n<2794> \n<2795> case TARGET_NR_getpriority:\n<2796> \n<2797> /* Note that negative values are valid for getpriority, so we must\n<2798> \n<2799> differentiate based on errno settings.  */\n<2800> \n<2801> errno = 0;\n<2802> \n<2803> ret = getpriority(arg1, arg2);\n<2804> \n<2805> if (ret == -1 && errno != 0) {\n<2806> \n<2807> ret = -host_to_target_errno(errno);\n<2808> \n<2809> break;\n<2810> \n<2811> }\n<2812> \n<2813> #ifdef TARGET_ALPHA\n<2814> \n<2815> /* Return value is the unbiased priority.  Signal no error.  */\n<2816> \n<2817> ((CPUAlphaState *)cpu_env)->ir[IR_V0] = 0;\n<2818> \n<2819> #else\n<2820> \n<2821> /* Return value is a biased priority to avoid negative numbers.  */\n<2822> \n<2823> ret = 20 - ret;\n<2824> \n<2825> #endif\n<2826> \n<2827> break;\n<2828> \n<2829> case TARGET_NR_setpriority:\n<2830> \n<2831> ret = get_errno(setpriority(arg1, arg2, arg3));\n<2832> \n<2833> break;\n<2834> \n<2835> #ifdef TARGET_NR_profil\n<2836> \n<2837> case TARGET_NR_profil:\n<2838> \n<2839> goto unimplemented;\n<2840> \n<2841> #endif\n<2842> \n<2843> case TARGET_NR_statfs:\n<2844> \n<2845> if (!(p = lock_user_string(arg1)))\n<2846> \n<2847> goto efault;\n<2848> \n<2849> ret = get_errno(statfs(path(p), &stfs));\n<2850> \n<2851> unlock_user(p, arg1, 0);\n<2852> \n<2853> convert_statfs:\n<2854> \n<2855> if (!is_error(ret)) {\n<2856> \n<2857> struct target_statfs *target_stfs;\n<2858> \n<2859> \n<2860> \n<2861> if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n<2862> \n<2863> goto efault;\n<2864> \n<2865> __put_user(stfs.f_type, &target_stfs->f_type);\n<2866> \n<2867> __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n<2868> \n<2869> __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n<2870> \n<2871> __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n<2872> \n<2873> __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n<2874> \n<2875> __put_user(stfs.f_files, &target_stfs->f_files);\n<2876> \n<2877> __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n<2878> \n<2879> __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n<2880> \n<2881> __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n<2882> \n<2883> __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n<2884> \n<2885> __put_user(stfs.f_frsize, &target_stfs->f_frsize);\n<2886> \n<2887> memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));\n<2888> \n<2889> unlock_user_struct(target_stfs, arg2, 1);\n<2890> \n<2891> }\n<2892> \n<2893> break;\n<2894> \n<2895> case TARGET_NR_fstatfs:\n<2896> \n<2897> ret = get_errno(fstatfs(arg1, &stfs));\n<2898> \n<2899> goto convert_statfs;\n<2900> \n<2901> #ifdef TARGET_NR_statfs64\n<2902> \n<2903> case TARGET_NR_statfs64:\n<2904> \n<2905> if (!(p = lock_user_string(arg1)))\n<2906> \n<2907> goto efault;\n<2908> \n<2909> ret = get_errno(statfs(path(p), &stfs));\n<2910> \n<2911> unlock_user(p, arg1, 0);\n<2912> \n<2913> convert_statfs64:\n<2914> \n<2915> if (!is_error(ret)) {\n<2916> \n<2917> struct target_statfs64 *target_stfs;\n<2918> \n<2919> \n<2920> \n<2921> if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg3, 0))\n<2922> \n<2923> goto efault;\n<2924> \n<2925> __put_user(stfs.f_type, &target_stfs->f_type);\n<2926> \n<2927> __put_user(stfs.f_bsize, &target_stfs->f_bsize);\n<2928> \n<2929> __put_user(stfs.f_blocks, &target_stfs->f_blocks);\n<2930> \n<2931> __put_user(stfs.f_bfree, &target_stfs->f_bfree);\n<2932> \n<2933> __put_user(stfs.f_bavail, &target_stfs->f_bavail);\n<2934> \n<2935> __put_user(stfs.f_files, &target_stfs->f_files);\n<2936> \n<2937> __put_user(stfs.f_ffree, &target_stfs->f_ffree);\n<2938> \n<2939> __put_user(stfs.f_fsid.__val[0], &target_stfs->f_fsid.val[0]);\n<2940> \n<2941> __put_user(stfs.f_fsid.__val[1], &target_stfs->f_fsid.val[1]);\n<2942> \n<2943> __put_user(stfs.f_namelen, &target_stfs->f_namelen);\n<2944> \n<2945> __put_user(stfs.f_frsize, &target_stfs->f_frsize);\n<2946> \n<2947> memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));\n<2948> \n<2949> unlock_user_struct(target_stfs, arg3, 1);\n<2950> \n<2951> }\n<2952> \n<2953> break;\n<2954> \n<2955> case TARGET_NR_fstatfs64:\n<2956> \n<2957> ret = get_errno(fstatfs(arg1, &stfs));\n<2958> \n<2959> goto convert_statfs64;\n<2960> \n<2961> #endif\n<2962> \n<2963> #ifdef TARGET_NR_ioperm\n<2964> \n<2965> case TARGET_NR_ioperm:\n<2966> \n<2967> goto unimplemented;\n<2968> \n<2969> #endif\n<2970> \n<2971> #ifdef TARGET_NR_socketcall\n<2972> \n<2973> case TARGET_NR_socketcall:\n<2974> \n<2975> ret = do_socketcall(arg1, arg2);\n<2976> \n<2977> break;\n<2978> \n<2979> #endif\n<2980> \n<2981> #ifdef TARGET_NR_accept\n<2982> \n<2983> case TARGET_NR_accept:\n<2984> \n<2985> ret = do_accept(arg1, arg2, arg3);\n<2986> \n<2987> break;\n<2988> \n<2989> #endif\n<2990> \n<2991> #ifdef TARGET_NR_bind\n<2992> \n<2993> case TARGET_NR_bind:\n<2994> \n<2995> ret = do_bind(arg1, arg2, arg3);\n<2996> \n<2997> break;\n<2998> \n<2999> #endif\n<3000> \n<3001> #ifdef TARGET_NR_connect\n<3002> \n<3003> case TARGET_NR_connect:\n<3004> \n<3005> ret = do_connect(arg1, arg2, arg3);\n<3006> \n<3007> break;\n<3008> \n<3009> #endif\n<3010> \n<3011> #ifdef TARGET_NR_getpeername\n<3012> \n<3013> case TARGET_NR_getpeername:\n<3014> \n<3015> ret = do_getpeername(arg1, arg2, arg3);\n<3016> \n<3017> break;\n<3018> \n<3019> #endif\n<3020> \n<3021> #ifdef TARGET_NR_getsockname\n<3022> \n<3023> case TARGET_NR_getsockname:\n<3024> \n<3025> ret = do_getsockname(arg1, arg2, arg3);\n<3026> \n<3027> break;\n<3028> \n<3029> #endif\n<3030> \n<3031> #ifdef TARGET_NR_getsockopt\n<3032> \n<3033> case TARGET_NR_getsockopt:\n<3034> \n<3035> ret = do_getsockopt(arg1, arg2, arg3, arg4, arg5);\n<3036> \n<3037> break;\n<3038> \n<3039> #endif\n<3040> \n<3041> #ifdef TARGET_NR_listen\n<3042> \n<3043> case TARGET_NR_listen:\n<3044> \n<3045> ret = get_errno(listen(arg1, arg2));\n<3046> \n<3047> break;\n<3048> \n<3049> #endif\n<3050> \n<3051> #ifdef TARGET_NR_recv\n<3052> \n<3053> case TARGET_NR_recv:\n<3054> \n<3055> ret = do_recvfrom(arg1, arg2, arg3, arg4, 0, 0);\n<3056> \n<3057> break;\n<3058> \n<3059> #endif\n<3060> \n<3061> #ifdef TARGET_NR_recvfrom\n<3062> \n<3063> case TARGET_NR_recvfrom:\n<3064> \n<3065> ret = do_recvfrom(arg1, arg2, arg3, arg4, arg5, arg6);\n<3066> \n<3067> break;\n<3068> \n<3069> #endif\n<3070> \n<3071> #ifdef TARGET_NR_recvmsg\n<3072> \n<3073> case TARGET_NR_recvmsg:\n<3074> \n<3075> ret = do_sendrecvmsg(arg1, arg2, arg3, 0);\n<3076> \n<3077> break;\n<3078> \n<3079> #endif\n<3080> \n<3081> #ifdef TARGET_NR_send\n<3082> \n<3083> case TARGET_NR_send:\n<3084> \n<3085> ret = do_sendto(arg1, arg2, arg3, arg4, 0, 0);\n<3086> \n<3087> break;\n<3088> \n<3089> #endif\n<3090> \n<3091> #ifdef TARGET_NR_sendmsg\n<3092> \n<3093> case TARGET_NR_sendmsg:\n<3094> \n<3095> ret = do_sendrecvmsg(arg1, arg2, arg3, 1);\n<3096> \n<3097> break;\n<3098> \n<3099> #endif\n<3100> \n<3101> #ifdef TARGET_NR_sendto\n<3102> \n<3103> case TARGET_NR_sendto:\n<3104> \n<3105> ret = do_sendto(arg1, arg2, arg3, arg4, arg5, arg6);\n<3106> \n<3107> break;\n<3108> \n<3109> #endif\n<3110> \n<3111> #ifdef TARGET_NR_shutdown\n<3112> \n<3113> case TARGET_NR_shutdown:\n<3114> \n<3115> ret = get_errno(shutdown(arg1, arg2));\n<3116> \n<3117> break;\n<3118> \n<3119> #endif\n<3120> \n<3121> #ifdef TARGET_NR_socket\n<3122> \n<3123> case TARGET_NR_socket:\n<3124> \n<3125> ret = do_socket(arg1, arg2, arg3);\n<3126> \n<3127> break;\n<3128> \n<3129> #endif\n<3130> \n<3131> #ifdef TARGET_NR_socketpair\n<3132> \n<3133> case TARGET_NR_socketpair:\n<3134> \n<3135> ret = do_socketpair(arg1, arg2, arg3, arg4);\n<3136> \n<3137> break;\n<3138> \n<3139> #endif\n<3140> \n<3141> #ifdef TARGET_NR_setsockopt\n<3142> \n<3143> case TARGET_NR_setsockopt:\n<3144> \n<3145> ret = do_setsockopt(arg1, arg2, arg3, arg4, (socklen_t) arg5);\n<3146> \n<3147> break;\n<3148> \n<3149> #endif\n<3150> \n<3151> \n<3152> \n<3153> case TARGET_NR_syslog:\n<3154> \n<3155> if (!(p = lock_user_string(arg2)))\n<3156> \n<3157> goto efault;\n<3158> \n<3159> ret = get_errno(sys_syslog((int)arg1, p, (int)arg3));\n<3160> \n<3161> unlock_user(p, arg2, 0);\n<3162> \n<3163> break;\n<3164> \n<3165> \n<3166> \n<3167> case TARGET_NR_setitimer:\n<3168> \n<3169> {\n<3170> \n<3171> struct itimerval value, ovalue, *pvalue;\n<3172> \n<3173> \n<3174> \n<3175> if (arg2) {\n<3176> \n<3177> pvalue = &value;\n<3178> \n<3179> if (copy_from_user_timeval(&pvalue->it_interval, arg2)\n<3180> \n<3181> || copy_from_user_timeval(&pvalue->it_value,\n<3182> \n<3183> arg2 + sizeof(struct target_timeval)))\n<3184> \n<3185> goto efault;\n<3186> \n<3187> } else {\n<3188> \n<3189> pvalue = NULL;\n<3190> \n<3191> }\n<3192> \n<3193> ret = get_errno(setitimer(arg1, pvalue, &ovalue));\n<3194> \n<3195> if (!is_error(ret) && arg3) {\n<3196> \n<3197> if (copy_to_user_timeval(arg3,\n<3198> \n<3199> &ovalue.it_interval)\n<3200> \n<3201> || copy_to_user_timeval(arg3 + sizeof(struct target_timeval),\n<3202> \n<3203> &ovalue.it_value))\n<3204> \n<3205> goto efault;\n<3206> \n<3207> }\n<3208> \n<3209> }\n<3210> \n<3211> break;\n<3212> \n<3213> case TARGET_NR_getitimer:\n<3214> \n<3215> {\n<3216> \n<3217> struct itimerval value;\n<3218> \n<3219> \n<3220> \n<3221> ret = get_errno(getitimer(arg1, &value));\n<3222> \n<3223> if (!is_error(ret) && arg2) {\n<3224> \n<3225> if (copy_to_user_timeval(arg2,\n<3226> \n<3227> &value.it_interval)\n<3228> \n<3229> || copy_to_user_timeval(arg2 + sizeof(struct target_timeval),\n<3230> \n<3231> &value.it_value))\n<3232> \n<3233> goto efault;\n<3234> \n<3235> }\n<3236> \n<3237> }\n<3238> \n<3239> break;\n<3240> \n<3241> case TARGET_NR_stat:\n<3242> \n<3243> if (!(p = lock_user_string(arg1)))\n<3244> \n<3245> goto efault;\n<3246> \n<3247> ret = get_errno(stat(path(p), &st));\n<3248> \n<3249> unlock_user(p, arg1, 0);\n<3250> \n<3251> goto do_stat;\n<3252> \n<3253> case TARGET_NR_lstat:\n<3254> \n<3255> if (!(p = lock_user_string(arg1)))\n<3256> \n<3257> goto efault;\n<3258> \n<3259> ret = get_errno(lstat(path(p), &st));\n<3260> \n<3261> unlock_user(p, arg1, 0);\n<3262> \n<3263> goto do_stat;\n<3264> \n<3265> case TARGET_NR_fstat:\n<3266> \n<3267> {\n<3268> \n<3269> ret = get_errno(fstat(arg1, &st));\n<3270> \n<3271> do_stat:\n<3272> \n<3273> if (!is_error(ret)) {\n<3274> \n<3275> struct target_stat *target_st;\n<3276> \n<3277> \n<3278> \n<3279> if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n<3280> \n<3281> goto efault;\n<3282> \n<3283> memset(target_st, 0, sizeof(*target_st));\n<3284> \n<3285> __put_user(st.st_dev, &target_st->st_dev);\n<3286> \n<3287> __put_user(st.st_ino, &target_st->st_ino);\n<3288> \n<3289> __put_user(st.st_mode, &target_st->st_mode);\n<3290> \n<3291> __put_user(st.st_uid, &target_st->st_uid);\n<3292> \n<3293> __put_user(st.st_gid, &target_st->st_gid);\n<3294> \n<3295> __put_user(st.st_nlink, &target_st->st_nlink);\n<3296> \n<3297> __put_user(st.st_rdev, &target_st->st_rdev);\n<3298> \n<3299> __put_user(st.st_size, &target_st->st_size);\n<3300> \n<3301> __put_user(st.st_blksize, &target_st->st_blksize);\n<3302> \n<3303> __put_user(st.st_blocks, &target_st->st_blocks);\n<3304> \n<3305> __put_user(st.st_atime, &target_st->target_st_atime);\n<3306> \n<3307> __put_user(st.st_mtime, &target_st->target_st_mtime);\n<3308> \n<3309> __put_user(st.st_ctime, &target_st->target_st_ctime);\n<3310> \n<3311> unlock_user_struct(target_st, arg2, 1);\n<3312> \n<3313> }\n<3314> \n<3315> }\n<3316> \n<3317> break;\n<3318> \n<3319> #ifdef TARGET_NR_olduname\n<3320> \n<3321> case TARGET_NR_olduname:\n<3322> \n<3323> goto unimplemented;\n<3324> \n<3325> #endif\n<3326> \n<3327> #ifdef TARGET_NR_iopl\n<3328> \n<3329> case TARGET_NR_iopl:\n<3330> \n<3331> goto unimplemented;\n<3332> \n<3333> #endif\n<3334> \n<3335> case TARGET_NR_vhangup:\n<3336> \n<3337> ret = get_errno(vhangup());\n<3338> \n<3339> break;\n<3340> \n<3341> #ifdef TARGET_NR_idle\n<3342> \n<3343> case TARGET_NR_idle:\n<3344> \n<3345> goto unimplemented;\n<3346> \n<3347> #endif\n<3348> \n<3349> #ifdef TARGET_NR_syscall\n<3350> \n<3351> case TARGET_NR_syscall:\n<3352> \n<3353> ret = do_syscall(cpu_env, arg1 & 0xffff, arg2, arg3, arg4, arg5,\n<3354> \n<3355> arg6, arg7, arg8, 0);\n<3356> \n<3357> break;\n<3358> \n<3359> #endif\n<3360> \n<3361> case TARGET_NR_wait4:\n<3362> \n<3363> {\n<3364> \n<3365> int status;\n<3366> \n<3367> abi_long status_ptr = arg2;\n<3368> \n<3369> struct rusage rusage, *rusage_ptr;\n<3370> \n<3371> abi_ulong target_rusage = arg4;\n<3372> \n<3373> if (target_rusage)\n<3374> \n<3375> rusage_ptr = &rusage;\n<3376> \n<3377> else\n<3378> \n<3379> rusage_ptr = NULL;\n<3380> \n<3381> ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n<3382> \n<3383> if (!is_error(ret)) {\n<3384> \n<3385> if (status_ptr && ret) {\n<3386> \n<3387> status = host_to_target_waitstatus(status);\n<3388> \n<3389> if (put_user_s32(status, status_ptr))\n<3390> \n<3391> goto efault;\n<3392> \n<3393> }\n<3394> \n<3395> if (target_rusage)\n<3396> \n<3397> host_to_target_rusage(target_rusage, &rusage);\n<3398> \n<3399> }\n<3400> \n<3401> }\n<3402> \n<3403> break;\n<3404> \n<3405> #ifdef TARGET_NR_swapoff\n<3406> \n<3407> case TARGET_NR_swapoff:\n<3408> \n<3409> if (!(p = lock_user_string(arg1)))\n<3410> \n<3411> goto efault;\n<3412> \n<3413> ret = get_errno(swapoff(p));\n<3414> \n<3415> unlock_user(p, arg1, 0);\n<3416> \n<3417> break;\n<3418> \n<3419> #endif\n<3420> \n<3421> case TARGET_NR_sysinfo:\n<3422> \n<3423> {\n<3424> \n<3425> struct target_sysinfo *target_value;\n<3426> \n<3427> struct sysinfo value;\n<3428> \n<3429> ret = get_errno(sysinfo(&value));\n<3430> \n<3431> if (!is_error(ret) && arg1)\n<3432> \n<3433> {\n<3434> \n<3435> if (!lock_user_struct(VERIFY_WRITE, target_value, arg1, 0))\n<3436> \n<3437> goto efault;\n<3438> \n<3439> __put_user(value.uptime, &target_value->uptime);\n<3440> \n<3441> __put_user(value.loads[0], &target_value->loads[0]);\n<3442> \n<3443> __put_user(value.loads[1], &target_value->loads[1]);\n<3444> \n<3445> __put_user(value.loads[2], &target_value->loads[2]);\n<3446> \n<3447> __put_user(value.totalram, &target_value->totalram);\n<3448> \n<3449> __put_user(value.freeram, &target_value->freeram);\n<3450> \n<3451> __put_user(value.sharedram, &target_value->sharedram);\n<3452> \n<3453> __put_user(value.bufferram, &target_value->bufferram);\n<3454> \n<3455> __put_user(value.totalswap, &target_value->totalswap);\n<3456> \n<3457> __put_user(value.freeswap, &target_value->freeswap);\n<3458> \n<3459> __put_user(value.procs, &target_value->procs);\n<3460> \n<3461> __put_user(value.totalhigh, &target_value->totalhigh);\n<3462> \n<3463> __put_user(value.freehigh, &target_value->freehigh);\n<3464> \n<3465> __put_user(value.mem_unit, &target_value->mem_unit);\n<3466> \n<3467> unlock_user_struct(target_value, arg1, 1);\n<3468> \n<3469> }\n<3470> \n<3471> }\n<3472> \n<3473> break;\n<3474> \n<3475> #ifdef TARGET_NR_ipc\n<3476> \n<3477> case TARGET_NR_ipc:\n<3478> \n<3479> ret = do_ipc(arg1, arg2, arg3, arg4, arg5, arg6);\n<3480> \n<3481> break;\n<3482> \n<3483> #endif\n<3484> \n<3485> #ifdef TARGET_NR_semget\n<3486> \n<3487> case TARGET_NR_semget:\n<3488> \n<3489> ret = get_errno(semget(arg1, arg2, arg3));\n<3490> \n<3491> break;\n<3492> \n<3493> #endif\n<3494> \n<3495> #ifdef TARGET_NR_semop\n<3496> \n<3497> case TARGET_NR_semop:\n<3498> \n<3499> ret = get_errno(do_semop(arg1, arg2, arg3));\n<3500> \n<3501> break;\n<3502> \n<3503> #endif\n<3504> \n<3505> #ifdef TARGET_NR_semctl\n<3506> \n<3507> case TARGET_NR_semctl:\n<3508> \n<3509> ret = do_semctl(arg1, arg2, arg3, (union target_semun)(abi_ulong)arg4);\n<3510> \n<3511> break;\n<3512> \n<3513> #endif\n<3514> \n<3515> #ifdef TARGET_NR_msgctl\n<3516> \n<3517> case TARGET_NR_msgctl:\n<3518> \n<3519> ret = do_msgctl(arg1, arg2, arg3);\n<3520> \n<3521> break;\n<3522> \n<3523> #endif\n<3524> \n<3525> #ifdef TARGET_NR_msgget\n<3526> \n<3527> case TARGET_NR_msgget:\n<3528> \n<3529> ret = get_errno(msgget(arg1, arg2));\n<3530> \n<3531> break;\n<3532> \n<3533> #endif\n<3534> \n<3535> #ifdef TARGET_NR_msgrcv\n<3536> \n<3537> case TARGET_NR_msgrcv:\n<3538> \n<3539> ret = do_msgrcv(arg1, arg2, arg3, arg4, arg5);\n<3540> \n<3541> break;\n<3542> \n<3543> #endif\n<3544> \n<3545> #ifdef TARGET_NR_msgsnd\n<3546> \n<3547> case TARGET_NR_msgsnd:\n<3548> \n<3549> ret = do_msgsnd(arg1, arg2, arg3, arg4);\n<3550> \n<3551> break;\n<3552> \n<3553> #endif\n<3554> \n<3555> #ifdef TARGET_NR_shmget\n<3556> \n<3557> case TARGET_NR_shmget:\n<3558> \n<3559> ret = get_errno(shmget(arg1, arg2, arg3));\n<3560> \n<3561> break;\n<3562> \n<3563> #endif\n<3564> \n<3565> #ifdef TARGET_NR_shmctl\n<3566> \n<3567> case TARGET_NR_shmctl:\n<3568> \n<3569> ret = do_shmctl(arg1, arg2, arg3);\n<3570> \n<3571> break;\n<3572> \n<3573> #endif\n<3574> \n<3575> #ifdef TARGET_NR_shmat\n<3576> \n<3577> case TARGET_NR_shmat:\n<3578> \n<3579> ret = do_shmat(arg1, arg2, arg3);\n<3580> \n<3581> break;\n<3582> \n<3583> #endif\n<3584> \n<3585> #ifdef TARGET_NR_shmdt\n<3586> \n<3587> case TARGET_NR_shmdt:\n<3588> \n<3589> ret = do_shmdt(arg1);\n<3590> \n<3591> break;\n<3592> \n<3593> #endif\n<3594> \n<3595> case TARGET_NR_fsync:\n<3596> \n<3597> ret = get_errno(fsync(arg1));\n<3598> \n<3599> break;\n<3600> \n<3601> case TARGET_NR_clone:\n<3602> \n<3603> #if defined(TARGET_SH4) || defined(TARGET_ALPHA)\n<3604> \n<3605> ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg5, arg4));\n<3606> \n<3607> #elif defined(TARGET_CRIS)\n<3608> \n<3609> ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg4, arg5));\n<3610> \n<3611> #elif defined(TARGET_S390X)\n<3612> \n<3613> ret = get_errno(do_fork(cpu_env, arg2, arg1, arg3, arg5, arg4));\n<3614> \n<3615> #else\n<3616> \n<3617> ret = get_errno(do_fork(cpu_env, arg1, arg2, arg3, arg4, arg5));\n<3618> \n<3619> #endif\n<3620> \n<3621> break;\n<3622> \n<3623> #ifdef __NR_exit_group\n<3624> \n<3625> /* new thread calls */\n<3626> \n<3627> case TARGET_NR_exit_group:\n<3628> \n<3629> #ifdef TARGET_GPROF\n<3630> \n<3631> _mcleanup();\n<3632> \n<3633> #endif\n<3634> \n<3635> gdb_exit(cpu_env, arg1);\n<3636> \n<3637> ret = get_errno(exit_group(arg1));\n<3638> \n<3639> break;\n<3640> \n<3641> #endif\n<3642> \n<3643> case TARGET_NR_setdomainname:\n<3644> \n<3645> if (!(p = lock_user_string(arg1)))\n<3646> \n<3647> goto efault;\n<3648> \n<3649> ret = get_errno(setdomainname(p, arg2));\n<3650> \n<3651> unlock_user(p, arg1, 0);\n<3652> \n<3653> break;\n<3654> \n<3655> case TARGET_NR_uname:\n<3656> \n<3657> /* no need to transcode because we use the linux syscall */\n<3658> \n<3659> {\n<3660> \n<3661> struct new_utsname * buf;\n<3662> \n<3663> \n<3664> \n<3665> if (!lock_user_struct(VERIFY_WRITE, buf, arg1, 0))\n<3666> \n<3667> goto efault;\n<3668> \n<3669> ret = get_errno(sys_uname(buf));\n<3670> \n<3671> if (!is_error(ret)) {\n<3672> \n<3673> /* Overrite the native machine name with whatever is being\n<3674> \n<3675> emulated. */\n<3676> \n<3677> strcpy (buf->machine, cpu_to_uname_machine(cpu_env));\n<3678> \n<3679> /* Allow the user to override the reported release.  */\n<3680> \n<3681> if (qemu_uname_release && *qemu_uname_release)\n<3682> \n<3683> strcpy (buf->release, qemu_uname_release);\n<3684> \n<3685> }\n<3686> \n<3687> unlock_user_struct(buf, arg1, 1);\n<3688> \n<3689> }\n<3690> \n<3691> break;\n<3692> \n<3693> #ifdef TARGET_I386\n<3694> \n<3695> case TARGET_NR_modify_ldt:\n<3696> \n<3697> ret = do_modify_ldt(cpu_env, arg1, arg2, arg3);\n<3698> \n<3699> break;\n<3700> \n<3701> #if !defined(TARGET_X86_64)\n<3702> \n<3703> case TARGET_NR_vm86old:\n<3704> \n<3705> goto unimplemented;\n<3706> \n<3707> case TARGET_NR_vm86:\n<3708> \n<3709> ret = do_vm86(cpu_env, arg1, arg2);\n<3710> \n<3711> break;\n<3712> \n<3713> #endif\n<3714> \n<3715> #endif\n<3716> \n<3717> case TARGET_NR_adjtimex:\n<3718> \n<3719> goto unimplemented;\n<3720> \n<3721> #ifdef TARGET_NR_create_module\n<3722> \n<3723> case TARGET_NR_create_module:\n<3724> \n<3725> #endif\n<3726> \n<3727> case TARGET_NR_init_module:\n<3728> \n<3729> case TARGET_NR_delete_module:\n<3730> \n<3731> #ifdef TARGET_NR_get_kernel_syms\n<3732> \n<3733> case TARGET_NR_get_kernel_syms:\n<3734> \n<3735> #endif\n<3736> \n<3737> goto unimplemented;\n<3738> \n<3739> case TARGET_NR_quotactl:\n<3740> \n<3741> goto unimplemented;\n<3742> \n<3743> case TARGET_NR_getpgid:\n<3744> \n<3745> ret = get_errno(getpgid(arg1));\n<3746> \n<3747> break;\n<3748> \n<3749> case TARGET_NR_fchdir:\n<3750> \n<3751> ret = get_errno(fchdir(arg1));\n<3752> \n<3753> break;\n<3754> \n<3755> #ifdef TARGET_NR_bdflush /* not on x86_64 */\n<3756> \n<3757> case TARGET_NR_bdflush:\n<3758> \n<3759> goto unimplemented;\n<3760> \n<3761> #endif\n<3762> \n<3763> #ifdef TARGET_NR_sysfs\n<3764> \n<3765> case TARGET_NR_sysfs:\n<3766> \n<3767> goto unimplemented;\n<3768> \n<3769> #endif\n<3770> \n<3771> case TARGET_NR_personality:\n<3772> \n<3773> ret = get_errno(personality(arg1));\n<3774> \n<3775> break;\n<3776> \n<3777> #ifdef TARGET_NR_afs_syscall\n<3778> \n<3779> case TARGET_NR_afs_syscall:\n<3780> \n<3781> goto unimplemented;\n<3782> \n<3783> #endif\n<3784> \n<3785> #ifdef TARGET_NR__llseek /* Not on alpha */\n<3786> \n<3787> case TARGET_NR__llseek:\n<3788> \n<3789> {\n<3790> \n<3791> int64_t res;\n<3792> \n<3793> #if !defined(__NR_llseek)\n<3794> \n<3795> res = lseek(arg1, ((uint64_t)arg2 << 32) | arg3, arg5);\n<3796> \n<3797> if (res == -1) {\n<3798> \n<3799> ret = get_errno(res);\n<3800> \n<3801> } else {\n<3802> \n<3803> ret = 0;\n<3804> \n<3805> }\n<3806> \n<3807> #else\n<3808> \n<3809> ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n<3810> \n<3811> #endif\n<3812> \n<3813> if ((ret == 0) && put_user_s64(res, arg4)) {\n<3814> \n<3815> goto efault;\n<3816> \n<3817> }\n<3818> \n<3819> }\n<3820> \n<3821> break;\n<3822> \n<3823> #endif\n<3824> \n<3825> case TARGET_NR_getdents:\n<3826> \n<3827> #if TARGET_ABI_BITS == 32 && HOST_LONG_BITS == 64\n<3828> \n<3829> {\n<3830> \n<3831> struct target_dirent *target_dirp;\n<3832> \n<3833> struct linux_dirent *dirp;\n<3834> \n<3835> abi_long count = arg3;\n<3836> \n<3837> \n<3838> \n<3839> dirp = malloc(count);\n<3840> \n<3841> if (!dirp) {\n<3842> \n<3843> ret = -TARGET_ENOMEM;\n<3844> \n<3845> goto fail;\n<3846> \n<3847> }\n<3848> \n<3849> \n<3850> \n<3851> ret = get_errno(sys_getdents(arg1, dirp, count));\n<3852> \n<3853> if (!is_error(ret)) {\n<3854> \n<3855> struct linux_dirent *de;\n<3856> \n<3857> struct target_dirent *tde;\n<3858> \n<3859> int len = ret;\n<3860> \n<3861> int reclen, treclen;\n<3862> \n<3863> int count1, tnamelen;\n<3864> \n<3865> \n<3866> \n<3867> count1 = 0;\n<3868> \n<3869> de = dirp;\n<3870> \n<3871> if (!(target_dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n<3872> \n<3873> goto efault;\n<3874> \n<3875> tde = target_dirp;\n<3876> \n<3877> while (len > 0) {\n<3878> \n<3879> reclen = de->d_reclen;\n<3880> \n<3881> tnamelen = reclen - offsetof(struct linux_dirent, d_name);\n<3882> \n<3883> assert(tnamelen >= 0);\n<3884> \n<3885> treclen = tnamelen + offsetof(struct target_dirent, d_name);\n<3886> \n<3887> assert(count1 + treclen <= count);\n<3888> \n<3889> tde->d_reclen = tswap16(treclen);\n<3890> \n<3891> tde->d_ino = tswapal(de->d_ino);\n<3892> \n<3893> tde->d_off = tswapal(de->d_off);\n<3894> \n<3895> memcpy(tde->d_name, de->d_name, tnamelen);\n<3896> \n<3897> de = (struct linux_dirent *)((char *)de + reclen);\n<3898> \n<3899> len -= reclen;\n<3900> \n<3901> tde = (struct target_dirent *)((char *)tde + treclen);\n<3902> \n<3903> count1 += treclen;\n<3904> \n<3905> }\n<3906> \n<3907> ret = count1;\n<3908> \n<3909> unlock_user(target_dirp, arg2, ret);\n<3910> \n<3911> }\n<3912> \n<3913> free(dirp);\n<3914> \n<3915> }\n<3916> \n<3917> #else\n<3918> \n<3919> {\n<3920> \n<3921> struct linux_dirent *dirp;\n<3922> \n<3923> abi_long count = arg3;\n<3924> \n<3925> \n<3926> \n<3927> if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n<3928> \n<3929> goto efault;\n<3930> \n<3931> ret = get_errno(sys_getdents(arg1, dirp, count));\n<3932> \n<3933> if (!is_error(ret)) {\n<3934> \n<3935> struct linux_dirent *de;\n<3936> \n<3937> int len = ret;\n<3938> \n<3939> int reclen;\n<3940> \n<3941> de = dirp;\n<3942> \n<3943> while (len > 0) {\n<3944> \n<3945> reclen = de->d_reclen;\n<3946> \n<3947> if (reclen > len)\n<3948> \n<3949> break;\n<3950> \n<3951> de->d_reclen = tswap16(reclen);\n<3952> \n<3953> tswapls(&de->d_ino);\n<3954> \n<3955> tswapls(&de->d_off);\n<3956> \n<3957> de = (struct linux_dirent *)((char *)de + reclen);\n<3958> \n<3959> len -= reclen;\n<3960> \n<3961> }\n<3962> \n<3963> }\n<3964> \n<3965> unlock_user(dirp, arg2, ret);\n<3966> \n<3967> }\n<3968> \n<3969> #endif\n<3970> \n<3971> break;\n<3972> \n<3973> #if defined(TARGET_NR_getdents64) && defined(__NR_getdents64)\n<3974> \n<3975> case TARGET_NR_getdents64:\n<3976> \n<3977> {\n<3978> \n<3979> struct linux_dirent64 *dirp;\n<3980> \n<3981> abi_long count = arg3;\n<3982> \n<3983> if (!(dirp = lock_user(VERIFY_WRITE, arg2, count, 0)))\n<3984> \n<3985> goto efault;\n<3986> \n<3987> ret = get_errno(sys_getdents64(arg1, dirp, count));\n<3988> \n<3989> if (!is_error(ret)) {\n<3990> \n<3991> struct linux_dirent64 *de;\n<3992> \n<3993> int len = ret;\n<3994> \n<3995> int reclen;\n<3996> \n<3997> de = dirp;\n<3998> \n<3999> while (len > 0) {\n<4000> \n<4001> reclen = de->d_reclen;\n<4002> \n<4003> if (reclen > len)\n<4004> \n<4005> break;\n<4006> \n<4007> de->d_reclen = tswap16(reclen);\n<4008> \n<4009> tswap64s((uint64_t *)&de->d_ino);\n<4010> \n<4011> tswap64s((uint64_t *)&de->d_off);\n<4012> \n<4013> de = (struct linux_dirent64 *)((char *)de + reclen);\n<4014> \n<4015> len -= reclen;\n<4016> \n<4017> }\n<4018> \n<4019> }\n<4020> \n<4021> unlock_user(dirp, arg2, ret);\n<4022> \n<4023> }\n<4024> \n<4025> break;\n<4026> \n<4027> #endif /* TARGET_NR_getdents64 */\n<4028> \n<4029> #if defined(TARGET_NR__newselect) || defined(TARGET_S390X)\n<4030> \n<4031> #ifdef TARGET_S390X\n<4032> \n<4033> case TARGET_NR_select:\n<4034> \n<4035> #else\n<4036> \n<4037> case TARGET_NR__newselect:\n<4038> \n<4039> #endif\n<4040> \n<4041> ret = do_select(arg1, arg2, arg3, arg4, arg5);\n<4042> \n<4043> break;\n<4044> \n<4045> #endif\n<4046> \n<4047> #if defined(TARGET_NR_poll) || defined(TARGET_NR_ppoll)\n<4048> \n<4049> # ifdef TARGET_NR_poll\n<4050> \n<4051> case TARGET_NR_poll:\n<4052> \n<4053> # endif\n<4054> \n<4055> # ifdef TARGET_NR_ppoll\n<4056> \n<4057> case TARGET_NR_ppoll:\n<4058> \n<4059> # endif\n<4060> \n<4061> {\n<4062> \n<4063> struct target_pollfd *target_pfd;\n<4064> \n<4065> unsigned int nfds = arg2;\n<4066> \n<4067> int timeout = arg3;\n<4068> \n<4069> struct pollfd *pfd;\n<4070> \n<4071> unsigned int i;\n<4072> \n<4073> \n<4074> \n<4075> target_pfd = lock_user(VERIFY_WRITE, arg1, sizeof(struct target_pollfd) * nfds, 1);\n<4076> \n<4077> if (!target_pfd)\n<4078> \n<4079> goto efault;\n<4080> \n<4081> \n<4082> \n<4083> pfd = alloca(sizeof(struct pollfd) * nfds);\n<4084> \n<4085> for(i = 0; i < nfds; i++) {\n<4086> \n<4087> pfd[i].fd = tswap32(target_pfd[i].fd);\n<4088> \n<4089> pfd[i].events = tswap16(target_pfd[i].events);\n<4090> \n<4091> }\n<4092> \n<4093> \n<4094> \n<4095> # ifdef TARGET_NR_ppoll\n<4096> \n<4097> if (num == TARGET_NR_ppoll) {\n<4098> \n<4099> struct timespec _timeout_ts, *timeout_ts = &_timeout_ts;\n<4100> \n<4101> target_sigset_t *target_set;\n<4102> \n<4103> sigset_t _set, *set = &_set;\n<4104> \n<4105> \n<4106> \n<4107> if (arg3) {\n<4108> \n<4109> if (target_to_host_timespec(timeout_ts, arg3)) {\n<4110> \n<4111> unlock_user(target_pfd, arg1, 0);\n<4112> \n<4113> goto efault;\n<4114> \n<4115> }\n<4116> \n<4117> } else {\n<4118> \n<4119> timeout_ts = NULL;\n<4120> \n<4121> }\n<4122> \n<4123> \n<4124> \n<4125> if (arg4) {\n<4126> \n<4127> target_set = lock_user(VERIFY_READ, arg4, sizeof(target_sigset_t), 1);\n<4128> \n<4129> if (!target_set) {\n<4130> \n<4131> unlock_user(target_pfd, arg1, 0);\n<4132> \n<4133> goto efault;\n<4134> \n<4135> }\n<4136> \n<4137> target_to_host_sigset(set, target_set);\n<4138> \n<4139> } else {\n<4140> \n<4141> set = NULL;\n<4142> \n<4143> }\n<4144> \n<4145> \n<4146> \n<4147> ret = get_errno(sys_ppoll(pfd, nfds, timeout_ts, set, _NSIG/8));\n<4148> \n<4149> \n<4150> \n<4151> if (!is_error(ret) && arg3) {\n<4152> \n<4153> host_to_target_timespec(arg3, timeout_ts);\n<4154> \n<4155> }\n<4156> \n<4157> if (arg4) {\n<4158> \n<4159> unlock_user(target_set, arg4, 0);\n<4160> \n<4161> }\n<4162> \n<4163> } else\n<4164> \n<4165> # endif\n<4166> \n<4167> ret = get_errno(poll(pfd, nfds, timeout));\n<4168> \n<4169> \n<4170> \n<4171> if (!is_error(ret)) {\n<4172> \n<4173> for(i = 0; i < nfds; i++) {\n<4174> \n<4175> target_pfd[i].revents = tswap16(pfd[i].revents);\n<4176> \n<4177> }\n<4178> \n<4179> }\n<4180> \n<4181> unlock_user(target_pfd, arg1, sizeof(struct target_pollfd) * nfds);\n<4182> \n<4183> }\n<4184> \n<4185> break;\n<4186> \n<4187> #endif\n<4188> \n<4189> case TARGET_NR_flock:\n<4190> \n<4191> /* NOTE: the flock constant seems to be the same for every\n<4192> \n<4193> Linux platform */\n<4194> \n<4195> ret = get_errno(flock(arg1, arg2));\n<4196> \n<4197> break;\n<4198> \n<4199> case TARGET_NR_readv:\n<4200> \n<4201> {\n<4202> \n<4203> int count = arg3;\n<4204> \n<4205> struct iovec *vec;\n<4206> \n<4207> \n<4208> \n<4209> vec = alloca(count * sizeof(struct iovec));\n<4210> \n<4211> if (lock_iovec(VERIFY_WRITE, vec, arg2, count, 0) < 0)\n<4212> \n<4213> goto efault;\n<4214> \n<4215> ret = get_errno(readv(arg1, vec, count));\n<4216> \n<4217> unlock_iovec(vec, arg2, count, 1);\n<4218> \n<4219> }\n<4220> \n<4221> break;\n<4222> \n<4223> case TARGET_NR_writev:\n<4224> \n<4225> {\n<4226> \n<4227> int count = arg3;\n<4228> \n<4229> struct iovec *vec;\n<4230> \n<4231> \n<4232> \n<4233> vec = alloca(count * sizeof(struct iovec));\n<4234> \n<4235> if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n<4236> \n<4237> goto efault;\n<4238> \n<4239> ret = get_errno(writev(arg1, vec, count));\n<4240> \n<4241> unlock_iovec(vec, arg2, count, 0);\n<4242> \n<4243> }\n<4244> \n<4245> break;\n<4246> \n<4247> case TARGET_NR_getsid:\n<4248> \n<4249> ret = get_errno(getsid(arg1));\n<4250> \n<4251> break;\n<4252> \n<4253> #if defined(TARGET_NR_fdatasync) /* Not on alpha (osf_datasync ?) */\n<4254> \n<4255> case TARGET_NR_fdatasync:\n<4256> \n<4257> ret = get_errno(fdatasync(arg1));\n<4258> \n<4259> break;\n<4260> \n<4261> #endif\n<4262> \n<4263> case TARGET_NR__sysctl:\n<4264> \n<4265> /* We don't implement this, but ENOTDIR is always a safe\n<4266> \n<4267> return value. */\n<4268> \n<4269> ret = -TARGET_ENOTDIR;\n<4270> \n<4271> break;\n<4272> \n<4273> case TARGET_NR_sched_getaffinity:\n<4274> \n<4275> {\n<4276> \n<4277> unsigned int mask_size;\n<4278> \n<4279> unsigned long *mask;\n<4280> \n<4281> \n<4282> \n<4283> /*\n<4284> \n<4285> * sched_getaffinity needs multiples of ulong, so need to take\n<4286> \n<4287> * care of mismatches between target ulong and host ulong sizes.\n<4288> \n<4289> */\n<4290> \n<4291> if (arg2 & (sizeof(abi_ulong) - 1)) {\n<4292> \n<4293> ret = -TARGET_EINVAL;\n<4294> \n<4295> break;\n<4296> \n<4297> }\n<4298> \n<4299> mask_size = (arg2 + (sizeof(*mask) - 1)) & ~(sizeof(*mask) - 1);\n<4300> \n<4301> \n<4302> \n<4303> mask = alloca(mask_size);\n<4304> \n<4305> ret = get_errno(sys_sched_getaffinity(arg1, mask_size, mask));\n<4306> \n<4307> \n<4308> \n<4309> if (!is_error(ret)) {\n<4310> \n<4311> if (copy_to_user(arg3, mask, ret)) {\n<4312> \n<4313> goto efault;\n<4314> \n<4315> }\n<4316> \n<4317> }\n<4318> \n<4319> }\n<4320> \n<4321> break;\n<4322> \n<4323> case TARGET_NR_sched_setaffinity:\n<4324> \n<4325> {\n<4326> \n<4327> unsigned int mask_size;\n<4328> \n<4329> unsigned long *mask;\n<4330> \n<4331> \n<4332> \n<4333> /*\n<4334> \n<4335> * sched_setaffinity needs multiples of ulong, so need to take\n<4336> \n<4337> * care of mismatches between target ulong and host ulong sizes.\n<4338> \n<4339> */\n<4340> \n<4341> if (arg2 & (sizeof(abi_ulong) - 1)) {\n<4342> \n<4343> ret = -TARGET_EINVAL;\n<4344> \n<4345> break;\n<4346> \n<4347> }\n<4348> \n<4349> mask_size = (arg2 + (sizeof(*mask) - 1)) & ~(sizeof(*mask) - 1);\n<4350> \n<4351> \n<4352> \n<4353> mask = alloca(mask_size);\n<4354> \n<4355> if (!lock_user_struct(VERIFY_READ, p, arg3, 1)) {\n<4356> \n<4357> goto efault;\n<4358> \n<4359> }\n<4360> \n<4361> memcpy(mask, p, arg2);\n<4362> \n<4363> unlock_user_struct(p, arg2, 0);\n<4364> \n<4365> \n<4366> \n<4367> ret = get_errno(sys_sched_setaffinity(arg1, mask_size, mask));\n<4368> \n<4369> }\n<4370> \n<4371> break;\n<4372> \n<4373> case TARGET_NR_sched_setparam:\n<4374> \n<4375> {\n<4376> \n<4377> struct sched_param *target_schp;\n<4378> \n<4379> struct sched_param schp;\n<4380> \n<4381> \n<4382> \n<4383> if (!lock_user_struct(VERIFY_READ, target_schp, arg2, 1))\n<4384> \n<4385> goto efault;\n<4386> \n<4387> schp.sched_priority = tswap32(target_schp->sched_priority);\n<4388> \n<4389> unlock_user_struct(target_schp, arg2, 0);\n<4390> \n<4391> ret = get_errno(sched_setparam(arg1, &schp));\n<4392> \n<4393> }\n<4394> \n<4395> break;\n<4396> \n<4397> case TARGET_NR_sched_getparam:\n<4398> \n<4399> {\n<4400> \n<4401> struct sched_param *target_schp;\n<4402> \n<4403> struct sched_param schp;\n<4404> \n<4405> ret = get_errno(sched_getparam(arg1, &schp));\n<4406> \n<4407> if (!is_error(ret)) {\n<4408> \n<4409> if (!lock_user_struct(VERIFY_WRITE, target_schp, arg2, 0))\n<4410> \n<4411> goto efault;\n<4412> \n<4413> target_schp->sched_priority = tswap32(schp.sched_priority);\n<4414> \n<4415> unlock_user_struct(target_schp, arg2, 1);\n<4416> \n<4417> }\n<4418> \n<4419> }\n<4420> \n<4421> break;\n<4422> \n<4423> case TARGET_NR_sched_setscheduler:\n<4424> \n<4425> {\n<4426> \n<4427> struct sched_param *target_schp;\n<4428> \n<4429> struct sched_param schp;\n<4430> \n<4431> if (!lock_user_struct(VERIFY_READ, target_schp, arg3, 1))\n<4432> \n<4433> goto efault;\n<4434> \n<4435> schp.sched_priority = tswap32(target_schp->sched_priority);\n<4436> \n<4437> unlock_user_struct(target_schp, arg3, 0);\n<4438> \n<4439> ret = get_errno(sched_setscheduler(arg1, arg2, &schp));\n<4440> \n<4441> }\n<4442> \n<4443> break;\n<4444> \n<4445> case TARGET_NR_sched_getscheduler:\n<4446> \n<4447> ret = get_errno(sched_getscheduler(arg1));\n<4448> \n<4449> break;\n<4450> \n<4451> case TARGET_NR_sched_yield:\n<4452> \n<4453> ret = get_errno(sched_yield());\n<4454> \n<4455> break;\n<4456> \n<4457> case TARGET_NR_sched_get_priority_max:\n<4458> \n<4459> ret = get_errno(sched_get_priority_max(arg1));\n<4460> \n<4461> break;\n<4462> \n<4463> case TARGET_NR_sched_get_priority_min:\n<4464> \n<4465> ret = get_errno(sched_get_priority_min(arg1));\n<4466> \n<4467> break;\n<4468> \n<4469> case TARGET_NR_sched_rr_get_interval:\n<4470> \n<4471> {\n<4472> \n<4473> struct timespec ts;\n<4474> \n<4475> ret = get_errno(sched_rr_get_interval(arg1, &ts));\n<4476> \n<4477> if (!is_error(ret)) {\n<4478> \n<4479> host_to_target_timespec(arg2, &ts);\n<4480> \n<4481> }\n<4482> \n<4483> }\n<4484> \n<4485> break;\n<4486> \n<4487> case TARGET_NR_nanosleep:\n<4488> \n<4489> {\n<4490> \n<4491> struct timespec req, rem;\n<4492> \n<4493> target_to_host_timespec(&req, arg1);\n<4494> \n<4495> ret = get_errno(nanosleep(&req, &rem));\n<4496> \n<4497> if (is_error(ret) && arg2) {\n<4498> \n<4499> host_to_target_timespec(arg2, &rem);\n<4500> \n<4501> }\n<4502> \n<4503> }\n<4504> \n<4505> break;\n<4506> \n<4507> #ifdef TARGET_NR_query_module\n<4508> \n<4509> case TARGET_NR_query_module:\n<4510> \n<4511> goto unimplemented;\n<4512> \n<4513> #endif\n<4514> \n<4515> #ifdef TARGET_NR_nfsservctl\n<4516> \n<4517> case TARGET_NR_nfsservctl:\n<4518> \n<4519> goto unimplemented;\n<4520> \n<4521> #endif\n<4522> \n<4523> case TARGET_NR_prctl:\n<4524> \n<4525> switch (arg1) {\n<4526> \n<4527> case PR_GET_PDEATHSIG:\n<4528> \n<4529> {\n<4530> \n<4531> int deathsig;\n<4532> \n<4533> ret = get_errno(prctl(arg1, &deathsig, arg3, arg4, arg5));\n<4534> \n<4535> if (!is_error(ret) && arg2\n<4536> \n<4537> && put_user_ual(deathsig, arg2)) {\n<4538> \n<4539> goto efault;\n<4540> \n<4541> }\n<4542> \n<4543> break;\n<4544> \n<4545> }\n<4546> \n<4547> #ifdef PR_GET_NAME\n<4548> \n<4549> case PR_GET_NAME:\n<4550> \n<4551> {\n<4552> \n<4553> void *name = lock_user(VERIFY_WRITE, arg2, 16, 1);\n<4554> \n<4555> if (!name) {\n<4556> \n<4557> goto efault;\n<4558> \n<4559> }\n<4560> \n<4561> ret = get_errno(prctl(arg1, (unsigned long)name,\n<4562> \n<4563> arg3, arg4, arg5));\n<4564> \n<4565> unlock_user(name, arg2, 16);\n<4566> \n<4567> break;\n<4568> \n<4569> }\n<4570> \n<4571> case PR_SET_NAME:\n<4572> \n<4573> {\n<4574> \n<4575> void *name = lock_user(VERIFY_READ, arg2, 16, 1);\n<4576> \n<4577> if (!name) {\n<4578> \n<4579> goto efault;\n<4580> \n<4581> }\n<4582> \n<4583> ret = get_errno(prctl(arg1, (unsigned long)name,\n<4584> \n<4585> arg3, arg4, arg5));\n<4586> \n<4587> unlock_user(name, arg2, 0);\n<4588> \n<4589> break;\n<4590> \n<4591> }\n<4592> \n<4593> #endif\n<4594> \n<4595> default:\n<4596> \n<4597> /* Most prctl options have no pointer arguments */\n<4598> \n<4599> ret = get_errno(prctl(arg1, arg2, arg3, arg4, arg5));\n<4600> \n<4601> break;\n<4602> \n<4603> }\n<4604> \n<4605> break;\n<4606> \n<4607> #ifdef TARGET_NR_arch_prctl\n<4608> \n<4609> case TARGET_NR_arch_prctl:\n<4610> \n<4611> #if defined(TARGET_I386) && !defined(TARGET_ABI32)\n<4612> \n<4613> ret = do_arch_prctl(cpu_env, arg1, arg2);\n<4614> \n<4615> break;\n<4616> \n<4617> #else\n<4618> \n<4619> goto unimplemented;\n<4620> \n<4621> #endif\n<4622> \n<4623> #endif\n<4624> \n<4625> #ifdef TARGET_NR_pread\n<4626> \n<4627> case TARGET_NR_pread:\n<4628> \n<4629> if (regpairs_aligned(cpu_env))\n<4630> \n<4631> arg4 = arg5;\n<4632> \n<4633> if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n<4634> \n<4635> goto efault;\n<4636> \n<4637> ret = get_errno(pread(arg1, p, arg3, arg4));\n<4638> \n<4639> unlock_user(p, arg2, ret);\n<4640> \n<4641> break;\n<4642> \n<4643> case TARGET_NR_pwrite:\n<4644> \n<4645> if (regpairs_aligned(cpu_env))\n<4646> \n<4647> arg4 = arg5;\n<4648> \n<4649> if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n<4650> \n<4651> goto efault;\n<4652> \n<4653> ret = get_errno(pwrite(arg1, p, arg3, arg4));\n<4654> \n<4655> unlock_user(p, arg2, 0);\n<4656> \n<4657> break;\n<4658> \n<4659> #endif\n<4660> \n<4661> #ifdef TARGET_NR_pread64\n<4662> \n<4663> case TARGET_NR_pread64:\n<4664> \n<4665> if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))\n<4666> \n<4667> goto efault;\n<4668> \n<4669> ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));\n<4670> \n<4671> unlock_user(p, arg2, ret);\n<4672> \n<4673> break;\n<4674> \n<4675> case TARGET_NR_pwrite64:\n<4676> \n<4677> if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))\n<4678> \n<4679> goto efault;\n<4680> \n<4681> ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));\n<4682> \n<4683> unlock_user(p, arg2, 0);\n<4684> \n<4685> break;\n<4686> \n<4687> #endif\n<4688> \n<4689> case TARGET_NR_getcwd:\n<4690> \n<4691> if (!(p = lock_user(VERIFY_WRITE, arg1, arg2, 0)))\n<4692> \n<4693> goto efault;\n<4694> \n<4695> ret = get_errno(sys_getcwd1(p, arg2));\n<4696> \n<4697> unlock_user(p, arg1, ret);\n<4698> \n<4699> break;\n<4700> \n<4701> case TARGET_NR_capget:\n<4702> \n<4703> goto unimplemented;\n<4704> \n<4705> case TARGET_NR_capset:\n<4706> \n<4707> goto unimplemented;\n<4708> \n<4709> case TARGET_NR_sigaltstack:\n<4710> \n<4711> #if defined(TARGET_I386) || defined(TARGET_ARM) || defined(TARGET_MIPS) || \\n<4712> \n<4713> defined(TARGET_SPARC) || defined(TARGET_PPC) || defined(TARGET_ALPHA) || \\n<4714> \n<4715> defined(TARGET_M68K) || defined(TARGET_S390X) || defined(TARGET_OPENRISC)\n<4716> \n<4717> ret = do_sigaltstack(arg1, arg2, get_sp_from_cpustate((CPUArchState *)cpu_env));\n<4718> \n<4719> break;\n<4720> \n<4721> #else\n<4722> \n<4723> goto unimplemented;\n<4724> \n<4725> #endif\n<4726> \n<4727> case TARGET_NR_sendfile:\n<4728> \n<4729> goto unimplemented;\n<4730> \n<4731> #ifdef TARGET_NR_getpmsg\n<4732> \n<4733> case TARGET_NR_getpmsg:\n<4734> \n<4735> goto unimplemented;\n<4736> \n<4737> #endif\n<4738> \n<4739> #ifdef TARGET_NR_putpmsg\n<4740> \n<4741> case TARGET_NR_putpmsg:\n<4742> \n<4743> goto unimplemented;\n<4744> \n<4745> #endif\n<4746> \n<4747> #ifdef TARGET_NR_vfork\n<4748> \n<4749> case TARGET_NR_vfork:\n<4750> \n<4751> ret = get_errno(do_fork(cpu_env, CLONE_VFORK | CLONE_VM | SIGCHLD,\n<4752> \n<4753> 0, 0, 0, 0));\n<4754> \n<4755> break;\n<4756> \n<4757> #endif\n<4758> \n<4759> #ifdef TARGET_NR_ugetrlimit\n<4760> \n<4761> case TARGET_NR_ugetrlimit:\n<4762> \n<4763> {\n<4764> \n<4765> struct rlimit rlim;\n<4766> \n<4767> int resource = target_to_host_resource(arg1);\n<4768> \n<4769> ret = get_errno(getrlimit(resource, &rlim));\n<4770> \n<4771> if (!is_error(ret)) {\n<4772> \n<4773> struct target_rlimit *target_rlim;\n<4774> \n<4775> if (!lock_user_struct(VERIFY_WRITE, target_rlim, arg2, 0))\n<4776> \n<4777> goto efault;\n<4778> \n<4779> target_rlim->rlim_cur = host_to_target_rlim(rlim.rlim_cur);\n<4780> \n<4781> target_rlim->rlim_max = host_to_target_rlim(rlim.rlim_max);\n<4782> \n<4783> unlock_user_struct(target_rlim, arg2, 1);\n<4784> \n<4785> }\n<4786> \n<4787> break;\n<4788> \n<4789> }\n<4790> \n<4791> #endif\n<4792> \n<4793> #ifdef TARGET_NR_truncate64\n<4794> \n<4795> case TARGET_NR_truncate64:\n<4796> \n<4797> if (!(p = lock_user_string(arg1)))\n<4798> \n<4799> goto efault;\n<4800> \n<4801> ret = target_truncate64(cpu_env, p, arg2, arg3, arg4);\n<4802> \n<4803> unlock_user(p, arg1, 0);\n<4804> \n<4805> break;\n<4806> \n<4807> #endif\n<4808> \n<4809> #ifdef TARGET_NR_ftruncate64\n<4810> \n<4811> case TARGET_NR_ftruncate64:\n<4812> \n<4813> ret = target_ftruncate64(cpu_env, arg1, arg2, arg3, arg4);\n<4814> \n<4815> break;\n<4816> \n<4817> #endif\n<4818> \n<4819> #ifdef TARGET_NR_stat64\n<4820> \n<4821> case TARGET_NR_stat64:\n<4822> \n<4823> if (!(p = lock_user_string(arg1)))\n<4824> \n<4825> goto efault;\n<4826> \n<4827> ret = get_errno(stat(path(p), &st));\n<4828> \n<4829> unlock_user(p, arg1, 0);\n<4830> \n<4831> if (!is_error(ret))\n<4832> \n<4833> ret = host_to_target_stat64(cpu_env, arg2, &st);\n<4834> \n<4835> break;\n<4836> \n<4837> #endif\n<4838> \n<4839> #ifdef TARGET_NR_lstat64\n<4840> \n<4841> case TARGET_NR_lstat64:\n<4842> \n<4843> if (!(p = lock_user_string(arg1)))\n<4844> \n<4845> goto efault;\n<4846> \n<4847> ret = get_errno(lstat(path(p), &st));\n<4848> \n<4849> unlock_user(p, arg1, 0);\n<4850> \n<4851> if (!is_error(ret))\n<4852> \n<4853> ret = host_to_target_stat64(cpu_env, arg2, &st);\n<4854> \n<4855> break;\n<4856> \n<4857> #endif\n<4858> \n<4859> #ifdef TARGET_NR_fstat64\n<4860> \n<4861> case TARGET_NR_fstat64:\n<4862> \n<4863> ret = get_errno(fstat(arg1, &st));\n<4864> \n<4865> if (!is_error(ret))\n<4866> \n<4867> ret = host_to_target_stat64(cpu_env, arg2, &st);\n<4868> \n<4869> break;\n<4870> \n<4871> #endif\n<4872> \n<4873> #if (defined(TARGET_NR_fstatat64) || defined(TARGET_NR_newfstatat)) && \\n<4874> \n<4875> (defined(__NR_fstatat64) || defined(__NR_newfstatat))\n<4876> \n<4877> #ifdef TARGET_NR_fstatat64\n<4878> \n<4879> case TARGET_NR_fstatat64:\n<4880> \n<4881> #endif\n<4882> \n<4883> #ifdef TARGET_NR_newfstatat\n<4884> \n<4885> case TARGET_NR_newfstatat:\n<4886> \n<4887> #endif\n<4888> \n<4889> if (!(p = lock_user_string(arg2)))\n<4890> \n<4891> goto efault;\n<4892> \n<4893> #ifdef __NR_fstatat64\n<4894> \n<4895> ret = get_errno(sys_fstatat64(arg1, path(p), &st, arg4));\n<4896> \n<4897> #else\n<4898> \n<4899> ret = get_errno(sys_newfstatat(arg1, path(p), &st, arg4));\n<4900> \n<4901> #endif\n<4902> \n<4903> if (!is_error(ret))\n<4904> \n<4905> ret = host_to_target_stat64(cpu_env, arg3, &st);\n<4906> \n<4907> break;\n<4908> \n<4909> #endif\n<4910> \n<4911> case TARGET_NR_lchown:\n<4912> \n<4913> if (!(p = lock_user_string(arg1)))\n<4914> \n<4915> goto efault;\n<4916> \n<4917> ret = get_errno(lchown(p, low2highuid(arg2), low2highgid(arg3)));\n<4918> \n<4919> unlock_user(p, arg1, 0);\n<4920> \n<4921> break;\n<4922> \n<4923> #ifdef TARGET_NR_getuid\n<4924> \n<4925> case TARGET_NR_getuid:\n<4926> \n<4927> ret = get_errno(high2lowuid(getuid()));\n<4928> \n<4929> break;\n<4930> \n<4931> #endif\n<4932> \n<4933> #ifdef TARGET_NR_getgid\n<4934> \n<4935> case TARGET_NR_getgid:\n<4936> \n<4937> ret = get_errno(high2lowgid(getgid()));\n<4938> \n<4939> break;\n<4940> \n<4941> #endif\n<4942> \n<4943> #ifdef TARGET_NR_geteuid\n<4944> \n<4945> case TARGET_NR_geteuid:\n<4946> \n<4947> ret = get_errno(high2lowuid(geteuid()));\n<4948> \n<4949> break;\n<4950> \n<4951> #endif\n<4952> \n<4953> #ifdef TARGET_NR_getegid\n<4954> \n<4955> case TARGET_NR_getegid:\n<4956> \n<4957> ret = get_errno(high2lowgid(getegid()));\n<4958> \n<4959> break;\n<4960> \n<4961> #endif\n<4962> \n<4963> case TARGET_NR_setreuid:\n<4964> \n<4965> ret = get_errno(setreuid(low2highuid(arg1), low2highuid(arg2)));\n<4966> \n<4967> break;\n<4968> \n<4969> case TARGET_NR_setregid:\n<4970> \n<4971> ret = get_errno(setregid(low2highgid(arg1), low2highgid(arg2)));\n<4972> \n<4973> break;\n<4974> \n<4975> case TARGET_NR_getgroups:\n<4976> \n<4977> {\n<4978> \n<4979> int gidsetsize = arg1;\n<4980> \n<4981> target_id *target_grouplist;\n<4982> \n<4983> gid_t *grouplist;\n<4984> \n<4985> int i;\n<4986> \n<4987> \n<4988> \n<4989> grouplist = alloca(gidsetsize * sizeof(gid_t));\n<4990> \n<4991> ret = get_errno(getgroups(gidsetsize, grouplist));\n<4992> \n<4993> if (gidsetsize == 0)\n<4994> \n<4995> break;\n<4996> \n<4997> if (!is_error(ret)) {\n<4998> \n<4999> target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 2, 0);\n<5000> \n<5001> if (!target_grouplist)\n<5002> \n<5003> goto efault;\n<5004> \n<5005> for(i = 0;i < ret; i++)\n<5006> \n<5007> target_grouplist[i] = tswapid(high2lowgid(grouplist[i]));\n<5008> \n<5009> unlock_user(target_grouplist, arg2, gidsetsize * 2);\n<5010> \n<5011> }\n<5012> \n<5013> }\n<5014> \n<5015> break;\n<5016> \n<5017> case TARGET_NR_setgroups:\n<5018> \n<5019> {\n<5020> \n<5021> int gidsetsize = arg1;\n<5022> \n<5023> target_id *target_grouplist;\n<5024> \n<5025> gid_t *grouplist;\n<5026> \n<5027> int i;\n<5028> \n<5029> \n<5030> \n<5031> grouplist = alloca(gidsetsize * sizeof(gid_t));\n<5032> \n<5033> target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 2, 1);\n<5034> \n<5035> if (!target_grouplist) {\n<5036> \n<5037> ret = -TARGET_EFAULT;\n<5038> \n<5039> goto fail;\n<5040> \n<5041> }\n<5042> \n<5043> for(i = 0;i < gidsetsize; i++)\n<5044> \n<5045> grouplist[i] = low2highgid(tswapid(target_grouplist[i]));\n<5046> \n<5047> unlock_user(target_grouplist, arg2, 0);\n<5048> \n<5049> ret = get_errno(setgroups(gidsetsize, grouplist));\n<5050> \n<5051> }\n<5052> \n<5053> break;\n<5054> \n<5055> case TARGET_NR_fchown:\n<5056> \n<5057> ret = get_errno(fchown(arg1, low2highuid(arg2), low2highgid(arg3)));\n<5058> \n<5059> break;\n<5060> \n<5061> #if defined(TARGET_NR_fchownat) && defined(__NR_fchownat)\n<5062> \n<5063> case TARGET_NR_fchownat:\n<5064> \n<5065> if (!(p = lock_user_string(arg2)))\n<5066> \n<5067> goto efault;\n<5068> \n<5069> ret = get_errno(sys_fchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5));\n<5070> \n<5071> unlock_user(p, arg2, 0);\n<5072> \n<5073> break;\n<5074> \n<5075> #endif\n<5076> \n<5077> #ifdef TARGET_NR_setresuid\n<5078> \n<5079> case TARGET_NR_setresuid:\n<5080> \n<5081> ret = get_errno(setresuid(low2highuid(arg1),\n<5082> \n<5083> low2highuid(arg2),\n<5084> \n<5085> low2highuid(arg3)));\n<5086> \n<5087> break;\n<5088> \n<5089> #endif\n<5090> \n<5091> #ifdef TARGET_NR_getresuid\n<5092> \n<5093> case TARGET_NR_getresuid:\n<5094> \n<5095> {\n<5096> \n<5097> uid_t ruid, euid, suid;\n<5098> \n<5099> ret = get_errno(getresuid(&ruid, &euid, &suid));\n<5100> \n<5101> if (!is_error(ret)) {\n<5102> \n<5103> if (put_user_u16(high2lowuid(ruid), arg1)\n<5104> \n<5105> || put_user_u16(high2lowuid(euid), arg2)\n<5106> \n<5107> || put_user_u16(high2lowuid(suid), arg3))\n<5108> \n<5109> goto efault;\n<5110> \n<5111> }\n<5112> \n<5113> }\n<5114> \n<5115> break;\n<5116> \n<5117> #endif\n<5118> \n<5119> #ifdef TARGET_NR_getresgid\n<5120> \n<5121> case TARGET_NR_setresgid:\n<5122> \n<5123> ret = get_errno(setresgid(low2highgid(arg1),\n<5124> \n<5125> low2highgid(arg2),\n<5126> \n<5127> low2highgid(arg3)));\n<5128> \n<5129> break;\n<5130> \n<5131> #endif\n<5132> \n<5133> #ifdef TARGET_NR_getresgid\n<5134> \n<5135> case TARGET_NR_getresgid:\n<5136> \n<5137> {\n<5138> \n<5139> gid_t rgid, egid, sgid;\n<5140> \n<5141> ret = get_errno(getresgid(&rgid, &egid, &sgid));\n<5142> \n<5143> if (!is_error(ret)) {\n<5144> \n<5145> if (put_user_u16(high2lowgid(rgid), arg1)\n<5146> \n<5147> || put_user_u16(high2lowgid(egid), arg2)\n<5148> \n<5149> || put_user_u16(high2lowgid(sgid), arg3))\n<5150> \n<5151> goto efault;\n<5152> \n<5153> }\n<5154> \n<5155> }\n<5156> \n<5157> break;\n<5158> \n<5159> #endif\n<5160> \n<5161> case TARGET_NR_chown:\n<5162> \n<5163> if (!(p = lock_user_string(arg1)))\n<5164> \n<5165> goto efault;\n<5166> \n<5167> ret = get_errno(chown(p, low2highuid(arg2), low2highgid(arg3)));\n<5168> \n<5169> unlock_user(p, arg1, 0);\n<5170> \n<5171> break;\n<5172> \n<5173> case TARGET_NR_setuid:\n<5174> \n<5175> ret = get_errno(setuid(low2highuid(arg1)));\n<5176> \n<5177> break;\n<5178> \n<5179> case TARGET_NR_setgid:\n<5180> \n<5181> ret = get_errno(setgid(low2highgid(arg1)));\n<5182> \n<5183> break;\n<5184> \n<5185> case TARGET_NR_setfsuid:\n<5186> \n<5187> ret = get_errno(setfsuid(arg1));\n<5188> \n<5189> break;\n<5190> \n<5191> case TARGET_NR_setfsgid:\n<5192> \n<5193> ret = get_errno(setfsgid(arg1));\n<5194> \n<5195> break;\n<5196> \n<5197> \n<5198> \n<5199> #ifdef TARGET_NR_lchown32\n<5200> \n<5201> case TARGET_NR_lchown32:\n<5202> \n<5203> if (!(p = lock_user_string(arg1)))\n<5204> \n<5205> goto efault;\n<5206> \n<5207> ret = get_errno(lchown(p, arg2, arg3));\n<5208> \n<5209> unlock_user(p, arg1, 0);\n<5210> \n<5211> break;\n<5212> \n<5213> #endif\n<5214> \n<5215> #ifdef TARGET_NR_getuid32\n<5216> \n<5217> case TARGET_NR_getuid32:\n<5218> \n<5219> ret = get_errno(getuid());\n<5220> \n<5221> break;\n<5222> \n<5223> #endif\n<5224> \n<5225> \n<5226> \n<5227> #if defined(TARGET_NR_getxuid) && defined(TARGET_ALPHA)\n<5228> \n<5229> /* Alpha specific */\n<5230> \n<5231> case TARGET_NR_getxuid:\n<5232> \n<5233> {\n<5234> \n<5235> uid_t euid;\n<5236> \n<5237> euid=geteuid();\n<5238> \n<5239> ((CPUAlphaState *)cpu_env)->ir[IR_A4]=euid;\n<5240> \n<5241> }\n<5242> \n<5243> ret = get_errno(getuid());\n<5244> \n<5245> break;\n<5246> \n<5247> #endif\n<5248> \n<5249> #if defined(TARGET_NR_getxgid) && defined(TARGET_ALPHA)\n<5250> \n<5251> /* Alpha specific */\n<5252> \n<5253> case TARGET_NR_getxgid:\n<5254> \n<5255> {\n<5256> \n<5257> uid_t egid;\n<5258> \n<5259> egid=getegid();\n<5260> \n<5261> ((CPUAlphaState *)cpu_env)->ir[IR_A4]=egid;\n<5262> \n<5263> }\n<5264> \n<5265> ret = get_errno(getgid());\n<5266> \n<5267> break;\n<5268> \n<5269> #endif\n<5270> \n<5271> #if defined(TARGET_NR_osf_getsysinfo) && defined(TARGET_ALPHA)\n<5272> \n<5273> /* Alpha specific */\n<5274> \n<5275> case TARGET_NR_osf_getsysinfo:\n<5276> \n<5277> ret = -TARGET_EOPNOTSUPP;\n<5278> \n<5279> switch (arg1) {\n<5280> \n<5281> case TARGET_GSI_IEEE_FP_CONTROL:\n<5282> \n<5283> {\n<5284> \n<5285> uint64_t swcr, fpcr = cpu_alpha_load_fpcr (cpu_env);\n<5286> \n<5287> \n<5288> \n<5289> /* Copied from linux ieee_fpcr_to_swcr.  */\n<5290> \n<5291> swcr = (fpcr >> 35) & SWCR_STATUS_MASK;\n<5292> \n<5293> swcr |= (fpcr >> 36) & SWCR_MAP_DMZ;\n<5294> \n<5295> swcr |= (~fpcr >> 48) & (SWCR_TRAP_ENABLE_INV\n<5296> \n<5297> | SWCR_TRAP_ENABLE_DZE\n<5298> \n<5299> | SWCR_TRAP_ENABLE_OVF);\n<5300> \n<5301> swcr |= (~fpcr >> 57) & (SWCR_TRAP_ENABLE_UNF\n<5302> \n<5303> | SWCR_TRAP_ENABLE_INE);\n<5304> \n<5305> swcr |= (fpcr >> 47) & SWCR_MAP_UMZ;\n<5306> \n<5307> swcr |= (~fpcr >> 41) & SWCR_TRAP_ENABLE_DNO;\n<5308> \n<5309> \n<5310> \n<5311> if (put_user_u64 (swcr, arg2))\n<5312> \n<5313> goto efault;\n<5314> \n<5315> ret = 0;\n<5316> \n<5317> }\n<5318> \n<5319> break;\n<5320> \n<5321> \n<5322> \n<5323> /* case GSI_IEEE_STATE_AT_SIGNAL:\n<5324> \n<5325> -- Not implemented in linux kernel.\n<5326> \n<5327> case GSI_UACPROC:\n<5328> \n<5329> -- Retrieves current unaligned access state; not much used.\n<5330> \n<5331> case GSI_PROC_TYPE:\n<5332> \n<5333> -- Retrieves implver information; surely not used.\n<5334> \n<5335> case GSI_GET_HWRPB:\n<5336> \n<5337> -- Grabs a copy of the HWRPB; surely not used.\n<5338> \n<5339> */\n<5340> \n<5341> }\n<5342> \n<5343> break;\n<5344> \n<5345> #endif\n<5346> \n<5347> #if defined(TARGET_NR_osf_setsysinfo) && defined(TARGET_ALPHA)\n<5348> \n<5349> /* Alpha specific */\n<5350> \n<5351> case TARGET_NR_osf_setsysinfo:\n<5352> \n<5353> ret = -TARGET_EOPNOTSUPP;\n<5354> \n<5355> switch (arg1) {\n<5356> \n<5357> case TARGET_SSI_IEEE_FP_CONTROL:\n<5358> \n<5359> {\n<5360> \n<5361> uint64_t swcr, fpcr, orig_fpcr;\n<5362> \n<5363> \n<5364> \n<5365> if (get_user_u64 (swcr, arg2)) {\n<5366> \n<5367> goto efault;\n<5368> \n<5369> }\n<5370> \n<5371> orig_fpcr = cpu_alpha_load_fpcr(cpu_env);\n<5372> \n<5373> fpcr = orig_fpcr & FPCR_DYN_MASK;\n<5374> \n<5375> \n<5376> \n<5377> /* Copied from linux ieee_swcr_to_fpcr.  */\n<5378> \n<5379> fpcr |= (swcr & SWCR_STATUS_MASK) << 35;\n<5380> \n<5381> fpcr |= (swcr & SWCR_MAP_DMZ) << 36;\n<5382> \n<5383> fpcr |= (~swcr & (SWCR_TRAP_ENABLE_INV\n<5384> \n<5385> | SWCR_TRAP_ENABLE_DZE\n<5386> \n<5387> | SWCR_TRAP_ENABLE_OVF)) << 48;\n<5388> \n<5389> fpcr |= (~swcr & (SWCR_TRAP_ENABLE_UNF\n<5390> \n<5391> | SWCR_TRAP_ENABLE_INE)) << 57;\n<5392> \n<5393> fpcr |= (swcr & SWCR_MAP_UMZ ? FPCR_UNDZ | FPCR_UNFD : 0);\n<5394> \n<5395> fpcr |= (~swcr & SWCR_TRAP_ENABLE_DNO) << 41;\n<5396> \n<5397> \n<5398> \n<5399> cpu_alpha_store_fpcr(cpu_env, fpcr);\n<5400> \n<5401> ret = 0;\n<5402> \n<5403> }\n<5404> \n<5405> break;\n<5406> \n<5407> \n<5408> \n<5409> case TARGET_SSI_IEEE_RAISE_EXCEPTION:\n<5410> \n<5411> {\n<5412> \n<5413> uint64_t exc, fpcr, orig_fpcr;\n<5414> \n<5415> int si_code;\n<5416> \n<5417> \n<5418> \n<5419> if (get_user_u64(exc, arg2)) {\n<5420> \n<5421> goto efault;\n<5422> \n<5423> }\n<5424> \n<5425> \n<5426> \n<5427> orig_fpcr = cpu_alpha_load_fpcr(cpu_env);\n<5428> \n<5429> \n<5430> \n<5431> /* We only add to the exception status here.  */\n<5432> \n<5433> fpcr = orig_fpcr | ((exc & SWCR_STATUS_MASK) << 35);\n<5434> \n<5435> \n<5436> \n<5437> cpu_alpha_store_fpcr(cpu_env, fpcr);\n<5438> \n<5439> ret = 0;\n<5440> \n<5441> \n<5442> \n<5443> /* Old exceptions are not signaled.  */\n<5444> \n<5445> fpcr &= ~(orig_fpcr & FPCR_STATUS_MASK);\n<5446> \n<5447> \n<5448> \n<5449> /* If any exceptions set by this call,\n<5450> \n<5451> and are unmasked, send a signal.  */\n<5452> \n<5453> si_code = 0;\n<5454> \n<5455> if ((fpcr & (FPCR_INE | FPCR_INED)) == FPCR_INE) {\n<5456> \n<5457> si_code = TARGET_FPE_FLTRES;\n<5458> \n<5459> }\n<5460> \n<5461> if ((fpcr & (FPCR_UNF | FPCR_UNFD)) == FPCR_UNF) {\n<5462> \n<5463> si_code = TARGET_FPE_FLTUND;\n<5464> \n<5465> }\n<5466> \n<5467> if ((fpcr & (FPCR_OVF | FPCR_OVFD)) == FPCR_OVF) {\n<5468> \n<5469> si_code = TARGET_FPE_FLTOVF;\n<5470> \n<5471> }\n<5472> \n<5473> if ((fpcr & (FPCR_DZE | FPCR_DZED)) == FPCR_DZE) {\n<5474> \n<5475> si_code = TARGET_FPE_FLTDIV;\n<5476> \n<5477> }\n<5478> \n<5479> if ((fpcr & (FPCR_INV | FPCR_INVD)) == FPCR_INV) {\n<5480> \n<5481> si_code = TARGET_FPE_FLTINV;\n<5482> \n<5483> }\n<5484> \n<5485> if (si_code != 0) {\n<5486> \n<5487> target_siginfo_t info;\n<5488> \n<5489> info.si_signo = SIGFPE;\n<5490> \n<5491> info.si_errno = 0;\n<5492> \n<5493> info.si_code = si_code;\n<5494> \n<5495> info._sifields._sigfault._addr\n<5496> \n<5497> = ((CPUArchState *)cpu_env)->pc;\n<5498> \n<5499> queue_signal((CPUArchState *)cpu_env, info.si_signo, &info);\n<5500> \n<5501> }\n<5502> \n<5503> }\n<5504> \n<5505> break;\n<5506> \n<5507> \n<5508> \n<5509> /* case SSI_NVPAIRS:\n<5510> \n<5511> -- Used with SSIN_UACPROC to enable unaligned accesses.\n<5512> \n<5513> case SSI_IEEE_STATE_AT_SIGNAL:\n<5514> \n<5515> case SSI_IEEE_IGNORE_STATE_AT_SIGNAL:\n<5516> \n<5517> -- Not implemented in linux kernel\n<5518> \n<5519> */\n<5520> \n<5521> }\n<5522> \n<5523> break;\n<5524> \n<5525> #endif\n<5526> \n<5527> #ifdef TARGET_NR_osf_sigprocmask\n<5528> \n<5529> /* Alpha specific.  */\n<5530> \n<5531> case TARGET_NR_osf_sigprocmask:\n<5532> \n<5533> {\n<5534> \n<5535> abi_ulong mask;\n<5536> \n<5537> int how;\n<5538> \n<5539> sigset_t set, oldset;\n<5540> \n<5541> \n<5542> \n<5543> switch(arg1) {\n<5544> \n<5545> case TARGET_SIG_BLOCK:\n<5546> \n<5547> how = SIG_BLOCK;\n<5548> \n<5549> break;\n<5550> \n<5551> case TARGET_SIG_UNBLOCK:\n<5552> \n<5553> how = SIG_UNBLOCK;\n<5554> \n<5555> break;\n<5556> \n<5557> case TARGET_SIG_SETMASK:\n<5558> \n<5559> how = SIG_SETMASK;\n<5560> \n<5561> break;\n<5562> \n<5563> default:\n<5564> \n<5565> ret = -TARGET_EINVAL;\n<5566> \n<5567> goto fail;\n<5568> \n<5569> }\n<5570> \n<5571> mask = arg2;\n<5572> \n<5573> target_to_host_old_sigset(&set, &mask);\n<5574> \n<5575> sigprocmask(how, &set, &oldset);\n<5576> \n<5577> host_to_target_old_sigset(&mask, &oldset);\n<5578> \n<5579> ret = mask;\n<5580> \n<5581> }\n<5582> \n<5583> break;\n<5584> \n<5585> #endif\n<5586> \n<5587> \n<5588> \n<5589> #ifdef TARGET_NR_getgid32\n<5590> \n<5591> case TARGET_NR_getgid32:\n<5592> \n<5593> ret = get_errno(getgid());\n<5594> \n<5595> break;\n<5596> \n<5597> #endif\n<5598> \n<5599> #ifdef TARGET_NR_geteuid32\n<5600> \n<5601> case TARGET_NR_geteuid32:\n<5602> \n<5603> ret = get_errno(geteuid());\n<5604> \n<5605> break;\n<5606> \n<5607> #endif\n<5608> \n<5609> #ifdef TARGET_NR_getegid32\n<5610> \n<5611> case TARGET_NR_getegid32:\n<5612> \n<5613> ret = get_errno(getegid());\n<5614> \n<5615> break;\n<5616> \n<5617> #endif\n<5618> \n<5619> #ifdef TARGET_NR_setreuid32\n<5620> \n<5621> case TARGET_NR_setreuid32:\n<5622> \n<5623> ret = get_errno(setreuid(arg1, arg2));\n<5624> \n<5625> break;\n<5626> \n<5627> #endif\n<5628> \n<5629> #ifdef TARGET_NR_setregid32\n<5630> \n<5631> case TARGET_NR_setregid32:\n<5632> \n<5633> ret = get_errno(setregid(arg1, arg2));\n<5634> \n<5635> break;\n<5636> \n<5637> #endif\n<5638> \n<5639> #ifdef TARGET_NR_getgroups32\n<5640> \n<5641> case TARGET_NR_getgroups32:\n<5642> \n<5643> {\n<5644> \n<5645> int gidsetsize = arg1;\n<5646> \n<5647> uint32_t *target_grouplist;\n<5648> \n<5649> gid_t *grouplist;\n<5650> \n<5651> int i;\n<5652> \n<5653> \n<5654> \n<5655> grouplist = alloca(gidsetsize * sizeof(gid_t));\n<5656> \n<5657> ret = get_errno(getgroups(gidsetsize, grouplist));\n<5658> \n<5659> if (gidsetsize == 0)\n<5660> \n<5661> break;\n<5662> \n<5663> if (!is_error(ret)) {\n<5664> \n<5665> target_grouplist = lock_user(VERIFY_WRITE, arg2, gidsetsize * 4, 0);\n<5666> \n<5667> if (!target_grouplist) {\n<5668> \n<5669> ret = -TARGET_EFAULT;\n<5670> \n<5671> goto fail;\n<5672> \n<5673> }\n<5674> \n<5675> for(i = 0;i < ret; i++)\n<5676> \n<5677> target_grouplist[i] = tswap32(grouplist[i]);\n<5678> \n<5679> unlock_user(target_grouplist, arg2, gidsetsize * 4);\n<5680> \n<5681> }\n<5682> \n<5683> }\n<5684> \n<5685> break;\n<5686> \n<5687> #endif\n<5688> \n<5689> #ifdef TARGET_NR_setgroups32\n<5690> \n<5691> case TARGET_NR_setgroups32:\n<5692> \n<5693> {\n<5694> \n<5695> int gidsetsize = arg1;\n<5696> \n<5697> uint32_t *target_grouplist;\n<5698> \n<5699> gid_t *grouplist;\n<5700> \n<5701> int i;\n<5702> \n<5703> \n<5704> \n<5705> grouplist = alloca(gidsetsize * sizeof(gid_t));\n<5706> \n<5707> target_grouplist = lock_user(VERIFY_READ, arg2, gidsetsize * 4, 1);\n<5708> \n<5709> if (!target_grouplist) {\n<5710> \n<5711> ret = -TARGET_EFAULT;\n<5712> \n<5713> goto fail;\n<5714> \n<5715> }\n<5716> \n<5717> for(i = 0;i < gidsetsize; i++)\n<5718> \n<5719> grouplist[i] = tswap32(target_grouplist[i]);\n<5720> \n<5721> unlock_user(target_grouplist, arg2, 0);\n<5722> \n<5723> ret = get_errno(setgroups(gidsetsize, grouplist));\n<5724> \n<5725> }\n<5726> \n<5727> break;\n<5728> \n<5729> #endif\n<5730> \n<5731> #ifdef TARGET_NR_fchown32\n<5732> \n<5733> case TARGET_NR_fchown32:\n<5734> \n<5735> ret = get_errno(fchown(arg1, arg2, arg3));\n<5736> \n<5737> break;\n<5738> \n<5739> #endif\n<5740> \n<5741> #ifdef TARGET_NR_setresuid32\n<5742> \n<5743> case TARGET_NR_setresuid32:\n<5744> \n<5745> ret = get_errno(setresuid(arg1, arg2, arg3));\n<5746> \n<5747> break;\n<5748> \n<5749> #endif\n<5750> \n<5751> #ifdef TARGET_NR_getresuid32\n<5752> \n<5753> case TARGET_NR_getresuid32:\n<5754> \n<5755> {\n<5756> \n<5757> uid_t ruid, euid, suid;\n<5758> \n<5759> ret = get_errno(getresuid(&ruid, &euid, &suid));\n<5760> \n<5761> if (!is_error(ret)) {\n<5762> \n<5763> if (put_user_u32(ruid, arg1)\n<5764> \n<5765> || put_user_u32(euid, arg2)\n<5766> \n<5767> || put_user_u32(suid, arg3))\n<5768> \n<5769> goto efault;\n<5770> \n<5771> }\n<5772> \n<5773> }\n<5774> \n<5775> break;\n<5776> \n<5777> #endif\n<5778> \n<5779> #ifdef TARGET_NR_setresgid32\n<5780> \n<5781> case TARGET_NR_setresgid32:\n<5782> \n<5783> ret = get_errno(setresgid(arg1, arg2, arg3));\n<5784> \n<5785> break;\n<5786> \n<5787> #endif\n<5788> \n<5789> #ifdef TARGET_NR_getresgid32\n<5790> \n<5791> case TARGET_NR_getresgid32:\n<5792> \n<5793> {\n<5794> \n<5795> gid_t rgid, egid, sgid;\n<5796> \n<5797> ret = get_errno(getresgid(&rgid, &egid, &sgid));\n<5798> \n<5799> if (!is_error(ret)) {\n<5800> \n<5801> if (put_user_u32(rgid, arg1)\n<5802> \n<5803> || put_user_u32(egid, arg2)\n<5804> \n<5805> || put_user_u32(sgid, arg3))\n<5806> \n<5807> goto efault;\n<5808> \n<5809> }\n<5810> \n<5811> }\n<5812> \n<5813> break;\n<5814> \n<5815> #endif\n<5816> \n<5817> #ifdef TARGET_NR_chown32\n<5818> \n<5819> case TARGET_NR_chown32:\n<5820> \n<5821> if (!(p = lock_user_string(arg1)))\n<5822> \n<5823> goto efault;\n<5824> \n<5825> ret = get_errno(chown(p, arg2, arg3));\n<5826> \n<5827> unlock_user(p, arg1, 0);\n<5828> \n<5829> break;\n<5830> \n<5831> #endif\n<5832> \n<5833> #ifdef TARGET_NR_setuid32\n<5834> \n<5835> case TARGET_NR_setuid32:\n<5836> \n<5837> ret = get_errno(setuid(arg1));\n<5838> \n<5839> break;\n<5840> \n<5841> #endif\n<5842> \n<5843> #ifdef TARGET_NR_setgid32\n<5844> \n<5845> case TARGET_NR_setgid32:\n<5846> \n<5847> ret = get_errno(setgid(arg1));\n<5848> \n<5849> break;\n<5850> \n<5851> #endif\n<5852> \n<5853> #ifdef TARGET_NR_setfsuid32\n<5854> \n<5855> case TARGET_NR_setfsuid32:\n<5856> \n<5857> ret = get_errno(setfsuid(arg1));\n<5858> \n<5859> break;\n<5860> \n<5861> #endif\n<5862> \n<5863> #ifdef TARGET_NR_setfsgid32\n<5864> \n<5865> case TARGET_NR_setfsgid32:\n<5866> \n<5867> ret = get_errno(setfsgid(arg1));\n<5868> \n<5869> break;\n<5870> \n<5871> #endif\n<5872> \n<5873> \n<5874> \n<5875> case TARGET_NR_pivot_root:\n<5876> \n<5877> goto unimplemented;\n<5878> \n<5879> #ifdef TARGET_NR_mincore\n<5880> \n<5881> case TARGET_NR_mincore:\n<5882> \n<5883> {\n<5884> \n<5885> void *a;\n<5886> \n<5887> ret = -TARGET_EFAULT;\n<5888> \n<5889> if (!(a = lock_user(VERIFY_READ, arg1,arg2, 0)))\n<5890> \n<5891> goto efault;\n<5892> \n<5893> if (!(p = lock_user_string(arg3)))\n<5894> \n<5895> goto mincore_fail;\n<5896> \n<5897> ret = get_errno(mincore(a, arg2, p));\n<5898> \n<5899> unlock_user(p, arg3, ret);\n<5900> \n<5901> mincore_fail:\n<5902> \n<5903> unlock_user(a, arg1, 0);\n<5904> \n<5905> }\n<5906> \n<5907> break;\n<5908> \n<5909> #endif\n<5910> \n<5911> #ifdef TARGET_NR_arm_fadvise64_64\n<5912> \n<5913> case TARGET_NR_arm_fadvise64_64:\n<5914> \n<5915> {\n<5916> \n<5917> /*\n<5918> \n<5919> * arm_fadvise64_64 looks like fadvise64_64 but\n<5920> \n<5921> * with different argument order\n<5922> \n<5923> */\n<5924> \n<5925> abi_long temp;\n<5926> \n<5927> temp = arg3;\n<5928> \n<5929> arg3 = arg4;\n<5930> \n<5931> arg4 = temp;\n<5932> \n<5933> }\n<5934> \n<5935> #endif\n<5936> \n<5937> #if defined(TARGET_NR_fadvise64_64) || defined(TARGET_NR_arm_fadvise64_64) || defined(TARGET_NR_fadvise64)\n<5938> \n<5939> #ifdef TARGET_NR_fadvise64_64\n<5940> \n<5941> case TARGET_NR_fadvise64_64:\n<5942> \n<5943> #endif\n<5944> \n<5945> #ifdef TARGET_NR_fadvise64\n<5946> \n<5947> case TARGET_NR_fadvise64:\n<5948> \n<5949> #endif\n<5950> \n<5951> #ifdef TARGET_S390X\n<5952> \n<5953> switch (arg4) {\n<5954> \n<5955> case 4: arg4 = POSIX_FADV_NOREUSE + 1; break; /* make sure it's an invalid value */\n<5956> \n<5957> case 5: arg4 = POSIX_FADV_NOREUSE + 2; break; /* ditto */\n<5958> \n<5959> case 6: arg4 = POSIX_FADV_DONTNEED; break;\n<5960> \n<5961> case 7: arg4 = POSIX_FADV_NOREUSE; break;\n<5962> \n<5963> default: break;\n<5964> \n<5965> }\n<5966> \n<5967> #endif\n<5968> \n<5969> ret = -posix_fadvise(arg1, arg2, arg3, arg4);\n<5970> \n<5971> break;\n<5972> \n<5973> #endif\n<5974> \n<5975> #ifdef TARGET_NR_madvise\n<5976> \n<5977> case TARGET_NR_madvise:\n<5978> \n<5979> /* A straight passthrough may not be safe because qemu sometimes\n<5980> \n<5981> turns private flie-backed mappings into anonymous mappings.\n<5982> \n<5983> This will break MADV_DONTNEED.\n<5984> \n<5985> This is a hint, so ignoring and returning success is ok.  */\n<5986> \n<5987> ret = get_errno(0);\n<5988> \n<5989> break;\n<5990> \n<5991> #endif\n<5992> \n<5993> #if TARGET_ABI_BITS == 32\n<5994> \n<5995> case TARGET_NR_fcntl64:\n<5996> \n<5997> {\n<5998> \n<5999> int cmd;\n<6000> \n<6001> struct flock64 fl;\n<6002> \n<6003> struct target_flock64 *target_fl;\n<6004> \n<6005> #ifdef TARGET_ARM\n<6006> \n<6007> struct target_eabi_flock64 *target_efl;\n<6008> \n<6009> #endif\n<6010> \n<6011> \n<6012> \n<6013> cmd = target_to_host_fcntl_cmd(arg2);\n<6014> \n<6015> if (cmd == -TARGET_EINVAL) {\n<6016> \n<6017> ret = cmd;\n<6018> \n<6019> break;\n<6020> \n<6021> }\n<6022> \n<6023> \n<6024> \n<6025> switch(arg2) {\n<6026> \n<6027> case TARGET_F_GETLK64:\n<6028> \n<6029> #ifdef TARGET_ARM\n<6030> \n<6031> if (((CPUARMState *)cpu_env)->eabi) {\n<6032> \n<6033> if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1))\n<6034> \n<6035> goto efault;\n<6036> \n<6037> fl.l_type = tswap16(target_efl->l_type);\n<6038> \n<6039> fl.l_whence = tswap16(target_efl->l_whence);\n<6040> \n<6041> fl.l_start = tswap64(target_efl->l_start);\n<6042> \n<6043> fl.l_len = tswap64(target_efl->l_len);\n<6044> \n<6045> fl.l_pid = tswap32(target_efl->l_pid);\n<6046> \n<6047> unlock_user_struct(target_efl, arg3, 0);\n<6048> \n<6049> } else\n<6050> \n<6051> #endif\n<6052> \n<6053> {\n<6054> \n<6055> if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1))\n<6056> \n<6057> goto efault;\n<6058> \n<6059> fl.l_type = tswap16(target_fl->l_type);\n<6060> \n<6061> fl.l_whence = tswap16(target_fl->l_whence);\n<6062> \n<6063> fl.l_start = tswap64(target_fl->l_start);\n<6064> \n<6065> fl.l_len = tswap64(target_fl->l_len);\n<6066> \n<6067> fl.l_pid = tswap32(target_fl->l_pid);\n<6068> \n<6069> unlock_user_struct(target_fl, arg3, 0);\n<6070> \n<6071> }\n<6072> \n<6073> ret = get_errno(fcntl(arg1, cmd, &fl));\n<6074> \n<6075> if (ret == 0) {\n<6076> \n<6077> #ifdef TARGET_ARM\n<6078> \n<6079> if (((CPUARMState *)cpu_env)->eabi) {\n<6080> \n<6081> if (!lock_user_struct(VERIFY_WRITE, target_efl, arg3, 0))\n<6082> \n<6083> goto efault;\n<6084> \n<6085> target_efl->l_type = tswap16(fl.l_type);\n<6086> \n<6087> target_efl->l_whence = tswap16(fl.l_whence);\n<6088> \n<6089> target_efl->l_start = tswap64(fl.l_start);\n<6090> \n<6091> target_efl->l_len = tswap64(fl.l_len);\n<6092> \n<6093> target_efl->l_pid = tswap32(fl.l_pid);\n<6094> \n<6095> unlock_user_struct(target_efl, arg3, 1);\n<6096> \n<6097> } else\n<6098> \n<6099> #endif\n<6100> \n<6101> {\n<6102> \n<6103> if (!lock_user_struct(VERIFY_WRITE, target_fl, arg3, 0))\n<6104> \n<6105> goto efault;\n<6106> \n<6107> target_fl->l_type = tswap16(fl.l_type);\n<6108> \n<6109> target_fl->l_whence = tswap16(fl.l_whence);\n<6110> \n<6111> target_fl->l_start = tswap64(fl.l_start);\n<6112> \n<6113> target_fl->l_len = tswap64(fl.l_len);\n<6114> \n<6115> target_fl->l_pid = tswap32(fl.l_pid);\n<6116> \n<6117> unlock_user_struct(target_fl, arg3, 1);\n<6118> \n<6119> }\n<6120> \n<6121> }\n<6122> \n<6123> break;\n<6124> \n<6125> \n<6126> \n<6127> case TARGET_F_SETLK64:\n<6128> \n<6129> case TARGET_F_SETLKW64:\n<6130> \n<6131> #ifdef TARGET_ARM\n<6132> \n<6133> if (((CPUARMState *)cpu_env)->eabi) {\n<6134> \n<6135> if (!lock_user_struct(VERIFY_READ, target_efl, arg3, 1))\n<6136> \n<6137> goto efault;\n<6138> \n<6139> fl.l_type = tswap16(target_efl->l_type);\n<6140> \n<6141> fl.l_whence = tswap16(target_efl->l_whence);\n<6142> \n<6143> fl.l_start = tswap64(target_efl->l_start);\n<6144> \n<6145> fl.l_len = tswap64(target_efl->l_len);\n<6146> \n<6147> fl.l_pid = tswap32(target_efl->l_pid);\n<6148> \n<6149> unlock_user_struct(target_efl, arg3, 0);\n<6150> \n<6151> } else\n<6152> \n<6153> #endif\n<6154> \n<6155> {\n<6156> \n<6157> if (!lock_user_struct(VERIFY_READ, target_fl, arg3, 1))\n<6158> \n<6159> goto efault;\n<6160> \n<6161> fl.l_type = tswap16(target_fl->l_type);\n<6162> \n<6163> fl.l_whence = tswap16(target_fl->l_whence);\n<6164> \n<6165> fl.l_start = tswap64(target_fl->l_start);\n<6166> \n<6167> fl.l_len = tswap64(target_fl->l_len);\n<6168> \n<6169> fl.l_pid = tswap32(target_fl->l_pid);\n<6170> \n<6171> unlock_user_struct(target_fl, arg3, 0);\n<6172> \n<6173> }\n<6174> \n<6175> ret = get_errno(fcntl(arg1, cmd, &fl));\n<6176> \n<6177> break;\n<6178> \n<6179> default:\n<6180> \n<6181> ret = do_fcntl(arg1, arg2, arg3);\n<6182> \n<6183> break;\n<6184> \n<6185> }\n<6186> \n<6187> break;\n<6188> \n<6189> }\n<6190> \n<6191> #endif\n<6192> \n<6193> #ifdef TARGET_NR_cacheflush\n<6194> \n<6195> case TARGET_NR_cacheflush:\n<6196> \n<6197> /* self-modifying code is handled automatically, so nothing needed */\n<6198> \n<6199> ret = 0;\n<6200> \n<6201> break;\n<6202> \n<6203> #endif\n<6204> \n<6205> #ifdef TARGET_NR_security\n<6206> \n<6207> case TARGET_NR_security:\n<6208> \n<6209> goto unimplemented;\n<6210> \n<6211> #endif\n<6212> \n<6213> #ifdef TARGET_NR_getpagesize\n<6214> \n<6215> case TARGET_NR_getpagesize:\n<6216> \n<6217> ret = TARGET_PAGE_SIZE;\n<6218> \n<6219> break;\n<6220> \n<6221> #endif\n<6222> \n<6223> case TARGET_NR_gettid:\n<6224> \n<6225> ret = get_errno(gettid());\n<6226> \n<6227> break;\n<6228> \n<6229> #ifdef TARGET_NR_readahead\n<6230> \n<6231> case TARGET_NR_readahead:\n<6232> \n<6233> #if TARGET_ABI_BITS == 32\n<6234> \n<6235> if (regpairs_aligned(cpu_env)) {\n<6236> \n<6237> arg2 = arg3;\n<6238> \n<6239> arg3 = arg4;\n<6240> \n<6241> arg4 = arg5;\n<6242> \n<6243> }\n<6244> \n<6245> ret = get_errno(readahead(arg1, ((off64_t)arg3 << 32) | arg2, arg4));\n<6246> \n<6247> #else\n<6248> \n<6249> ret = get_errno(readahead(arg1, arg2, arg3));\n<6250> \n<6251> #endif\n<6252> \n<6253> break;\n<6254> \n<6255> #endif\n<6256> \n<6257> #ifdef CONFIG_ATTR\n<6258> \n<6259> #ifdef TARGET_NR_setxattr\n<6260> \n<6261> case TARGET_NR_listxattr:\n<6262> \n<6263> case TARGET_NR_llistxattr:\n<6264> \n<6265> {\n<6266> \n<6267> void *p, *b = 0;\n<6268> \n<6269> if (arg2) {\n<6270> \n<6271> b = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n<6272> \n<6273> if (!b) {\n<6274> \n<6275> ret = -TARGET_EFAULT;\n<6276> \n<6277> break;\n<6278> \n<6279> }\n<6280> \n<6281> }\n<6282> \n<6283> p = lock_user_string(arg1);\n<6284> \n<6285> if (p) {\n<6286> \n<6287> if (num == TARGET_NR_listxattr) {\n<6288> \n<6289> ret = get_errno(listxattr(p, b, arg3));\n<6290> \n<6291> } else {\n<6292> \n<6293> ret = get_errno(llistxattr(p, b, arg3));\n<6294> \n<6295> }\n<6296> \n<6297> } else {\n<6298> \n<6299> ret = -TARGET_EFAULT;\n<6300> \n<6301> }\n<6302> \n<6303> unlock_user(p, arg1, 0);\n<6304> \n<6305> unlock_user(b, arg2, arg3);\n<6306> \n<6307> break;\n<6308> \n<6309> }\n<6310> \n<6311> case TARGET_NR_flistxattr:\n<6312> \n<6313> {\n<6314> \n<6315> void *b = 0;\n<6316> \n<6317> if (arg2) {\n<6318> \n<6319> b = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n<6320> \n<6321> if (!b) {\n<6322> \n<6323> ret = -TARGET_EFAULT;\n<6324> \n<6325> break;\n<6326> \n<6327> }\n<6328> \n<6329> }\n<6330> \n<6331> ret = get_errno(flistxattr(arg1, b, arg3));\n<6332> \n<6333> unlock_user(b, arg2, arg3);\n<6334> \n<6335> break;\n<6336> \n<6337> }\n<6338> \n<6339> case TARGET_NR_setxattr:\n<6340> \n<6341> case TARGET_NR_lsetxattr:\n<6342> \n<6343> {\n<6344> \n<6345> void *p, *n, *v = 0;\n<6346> \n<6347> if (arg3) {\n<6348> \n<6349> v = lock_user(VERIFY_READ, arg3, arg4, 1);\n<6350> \n<6351> if (!v) {\n<6352> \n<6353> ret = -TARGET_EFAULT;\n<6354> \n<6355> break;\n<6356> \n<6357> }\n<6358> \n<6359> }\n<6360> \n<6361> p = lock_user_string(arg1);\n<6362> \n<6363> n = lock_user_string(arg2);\n<6364> \n<6365> if (p && n) {\n<6366> \n<6367> if (num == TARGET_NR_setxattr) {\n<6368> \n<6369> ret = get_errno(setxattr(p, n, v, arg4, arg5));\n<6370> \n<6371> } else {\n<6372> \n<6373> ret = get_errno(lsetxattr(p, n, v, arg4, arg5));\n<6374> \n<6375> }\n<6376> \n<6377> } else {\n<6378> \n<6379> ret = -TARGET_EFAULT;\n<6380> \n<6381> }\n<6382> \n<6383> unlock_user(p, arg1, 0);\n<6384> \n<6385> unlock_user(n, arg2, 0);\n<6386> \n<6387> unlock_user(v, arg3, 0);\n<6388> \n<6389> }\n<6390> \n<6391> break;\n<6392> \n<6393> case TARGET_NR_fsetxattr:\n<6394> \n<6395> {\n<6396> \n<6397> void *n, *v = 0;\n<6398> \n<6399> if (arg3) {\n<6400> \n<6401> v = lock_user(VERIFY_READ, arg3, arg4, 1);\n<6402> \n<6403> if (!v) {\n<6404> \n<6405> ret = -TARGET_EFAULT;\n<6406> \n<6407> break;\n<6408> \n<6409> }\n<6410> \n<6411> }\n<6412> \n<6413> n = lock_user_string(arg2);\n<6414> \n<6415> if (n) {\n<6416> \n<6417> ret = get_errno(fsetxattr(arg1, n, v, arg4, arg5));\n<6418> \n<6419> } else {\n<6420> \n<6421> ret = -TARGET_EFAULT;\n<6422> \n<6423> }\n<6424> \n<6425> unlock_user(n, arg2, 0);\n<6426> \n<6427> unlock_user(v, arg3, 0);\n<6428> \n<6429> }\n<6430> \n<6431> break;\n<6432> \n<6433> case TARGET_NR_getxattr:\n<6434> \n<6435> case TARGET_NR_lgetxattr:\n<6436> \n<6437> {\n<6438> \n<6439> void *p, *n, *v = 0;\n<6440> \n<6441> if (arg3) {\n<6442> \n<6443> v = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n<6444> \n<6445> if (!v) {\n<6446> \n<6447> ret = -TARGET_EFAULT;\n<6448> \n<6449> break;\n<6450> \n<6451> }\n<6452> \n<6453> }\n<6454> \n<6455> p = lock_user_string(arg1);\n<6456> \n<6457> n = lock_user_string(arg2);\n<6458> \n<6459> if (p && n) {\n<6460> \n<6461> if (num == TARGET_NR_getxattr) {\n<6462> \n<6463> ret = get_errno(getxattr(p, n, v, arg4));\n<6464> \n<6465> } else {\n<6466> \n<6467> ret = get_errno(lgetxattr(p, n, v, arg4));\n<6468> \n<6469> }\n<6470> \n<6471> } else {\n<6472> \n<6473> ret = -TARGET_EFAULT;\n<6474> \n<6475> }\n<6476> \n<6477> unlock_user(p, arg1, 0);\n<6478> \n<6479> unlock_user(n, arg2, 0);\n<6480> \n<6481> unlock_user(v, arg3, arg4);\n<6482> \n<6483> }\n<6484> \n<6485> break;\n<6486> \n<6487> case TARGET_NR_fgetxattr:\n<6488> \n<6489> {\n<6490> \n<6491> void *n, *v = 0;\n<6492> \n<6493> if (arg3) {\n<6494> \n<6495> v = lock_user(VERIFY_WRITE, arg3, arg4, 0);\n<6496> \n<6497> if (!v) {\n<6498> \n<6499> ret = -TARGET_EFAULT;\n<6500> \n<6501> break;\n<6502> \n<6503> }\n<6504> \n<6505> }\n<6506> \n<6507> n = lock_user_string(arg2);\n<6508> \n<6509> if (n) {\n<6510> \n<6511> ret = get_errno(fgetxattr(arg1, n, v, arg4));\n<6512> \n<6513> } else {\n<6514> \n<6515> ret = -TARGET_EFAULT;\n<6516> \n<6517> }\n<6518> \n<6519> unlock_user(n, arg2, 0);\n<6520> \n<6521> unlock_user(v, arg3, arg4);\n<6522> \n<6523> }\n<6524> \n<6525> break;\n<6526> \n<6527> case TARGET_NR_removexattr:\n<6528> \n<6529> case TARGET_NR_lremovexattr:\n<6530> \n<6531> {\n<6532> \n<6533> void *p, *n;\n<6534> \n<6535> p = lock_user_string(arg1);\n<6536> \n<6537> n = lock_user_string(arg2);\n<6538> \n<6539> if (p && n) {\n<6540> \n<6541> if (num == TARGET_NR_removexattr) {\n<6542> \n<6543> ret = get_errno(removexattr(p, n));\n<6544> \n<6545> } else {\n<6546> \n<6547> ret = get_errno(lremovexattr(p, n));\n<6548> \n<6549> }\n<6550> \n<6551> } else {\n<6552> \n<6553> ret = -TARGET_EFAULT;\n<6554> \n<6555> }\n<6556> \n<6557> unlock_user(p, arg1, 0);\n<6558> \n<6559> unlock_user(n, arg2, 0);\n<6560> \n<6561> }\n<6562> \n<6563> break;\n<6564> \n<6565> case TARGET_NR_fremovexattr:\n<6566> \n<6567> {\n<6568> \n<6569> void *n;\n<6570> \n<6571> n = lock_user_string(arg2);\n<6572> \n<6573> if (n) {\n<6574> \n<6575> ret = get_errno(fremovexattr(arg1, n));\n<6576> \n<6577> } else {\n<6578> \n<6579> ret = -TARGET_EFAULT;\n<6580> \n<6581> }\n<6582> \n<6583> unlock_user(n, arg2, 0);\n<6584> \n<6585> }\n<6586> \n<6587> break;\n<6588> \n<6589> #endif\n<6590> \n<6591> #endif /* CONFIG_ATTR */\n<6592> \n<6593> #ifdef TARGET_NR_set_thread_area\n<6594> \n<6595> case TARGET_NR_set_thread_area:\n<6596> \n<6597> #if defined(TARGET_MIPS)\n<6598> \n<6599> ((CPUMIPSState *) cpu_env)->tls_value = arg1;\n<6600> \n<6601> ret = 0;\n<6602> \n<6603> break;\n<6604> \n<6605> #elif defined(TARGET_CRIS)\n<6606> \n<6607> if (arg1 & 0xff)\n<6608> \n<6609> ret = -TARGET_EINVAL;\n<6610> \n<6611> else {\n<6612> \n<6613> ((CPUCRISState *) cpu_env)->pregs[PR_PID] = arg1;\n<6614> \n<6615> ret = 0;\n<6616> \n<6617> }\n<6618> \n<6619> break;\n<6620> \n<6621> #elif defined(TARGET_I386) && defined(TARGET_ABI32)\n<6622> \n<6623> ret = do_set_thread_area(cpu_env, arg1);\n<6624> \n<6625> break;\n<6626> \n<6627> #else\n<6628> \n<6629> goto unimplemented_nowarn;\n<6630> \n<6631> #endif\n<6632> \n<6633> #endif\n<6634> \n<6635> #ifdef TARGET_NR_get_thread_area\n<6636> \n<6637> case TARGET_NR_get_thread_area:\n<6638> \n<6639> #if defined(TARGET_I386) && defined(TARGET_ABI32)\n<6640> \n<6641> ret = do_get_thread_area(cpu_env, arg1);\n<6642> \n<6643> #else\n<6644> \n<6645> goto unimplemented_nowarn;\n<6646> \n<6647> #endif\n<6648> \n<6649> #endif\n<6650> \n<6651> #ifdef TARGET_NR_getdomainname\n<6652> \n<6653> case TARGET_NR_getdomainname:\n<6654> \n<6655> goto unimplemented_nowarn;\n<6656> \n<6657> #endif\n<6658> \n<6659> \n<6660> \n<6661> #ifdef TARGET_NR_clock_gettime\n<6662> \n<6663> case TARGET_NR_clock_gettime:\n<6664> \n<6665> {\n<6666> \n<6667> struct timespec ts;\n<6668> \n<6669> ret = get_errno(clock_gettime(arg1, &ts));\n<6670> \n<6671> if (!is_error(ret)) {\n<6672> \n<6673> host_to_target_timespec(arg2, &ts);\n<6674> \n<6675> }\n<6676> \n<6677> break;\n<6678> \n<6679> }\n<6680> \n<6681> #endif\n<6682> \n<6683> #ifdef TARGET_NR_clock_getres\n<6684> \n<6685> case TARGET_NR_clock_getres:\n<6686> \n<6687> {\n<6688> \n<6689> struct timespec ts;\n<6690> \n<6691> ret = get_errno(clock_getres(arg1, &ts));\n<6692> \n<6693> if (!is_error(ret)) {\n<6694> \n<6695> host_to_target_timespec(arg2, &ts);\n<6696> \n<6697> }\n<6698> \n<6699> break;\n<6700> \n<6701> }\n<6702> \n<6703> #endif\n<6704> \n<6705> #ifdef TARGET_NR_clock_nanosleep\n<6706> \n<6707> case TARGET_NR_clock_nanosleep:\n<6708> \n<6709> {\n<6710> \n<6711> struct timespec ts;\n<6712> \n<6713> target_to_host_timespec(&ts, arg3);\n<6714> \n<6715> ret = get_errno(clock_nanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL));\n<6716> \n<6717> if (arg4)\n<6718> \n<6719> host_to_target_timespec(arg4, &ts);\n<6720> \n<6721> break;\n<6722> \n<6723> }\n<6724> \n<6725> #endif\n<6726> \n<6727> \n<6728> \n<6729> #if defined(TARGET_NR_set_tid_address) && defined(__NR_set_tid_address)\n<6730> \n<6731> case TARGET_NR_set_tid_address:\n<6732> \n<6733> ret = get_errno(set_tid_address((int *)g2h(arg1)));\n<6734> \n<6735> break;\n<6736> \n<6737> #endif\n<6738> \n<6739> \n<6740> \n<6741> #if defined(TARGET_NR_tkill) && defined(__NR_tkill)\n<6742> \n<6743> case TARGET_NR_tkill:\n<6744> \n<6745> ret = get_errno(sys_tkill((int)arg1, target_to_host_signal(arg2)));\n<6746> \n<6747> break;\n<6748> \n<6749> #endif\n<6750> \n<6751> \n<6752> \n<6753> #if defined(TARGET_NR_tgkill) && defined(__NR_tgkill)\n<6754> \n<6755> case TARGET_NR_tgkill:\n<6756> \n<6757> ret = get_errno(sys_tgkill((int)arg1, (int)arg2,\n<6758> \n<6759> target_to_host_signal(arg3)));\n<6760> \n<6761> break;\n<6762> \n<6763> #endif\n<6764> \n<6765> \n<6766> \n<6767> #ifdef TARGET_NR_set_robust_list\n<6768> \n<6769> case TARGET_NR_set_robust_list:\n<6770> \n<6771> goto unimplemented_nowarn;\n<6772> \n<6773> #endif\n<6774> \n<6775> \n<6776> \n<6777> #if defined(TARGET_NR_utimensat) && defined(__NR_utimensat)\n<6778> \n<6779> case TARGET_NR_utimensat:\n<6780> \n<6781> {\n<6782> \n<6783> struct timespec *tsp, ts[2];\n<6784> \n<6785> if (!arg3) {\n<6786> \n<6787> tsp = NULL;\n<6788> \n<6789> } else {\n<6790> \n<6791> target_to_host_timespec(ts, arg3);\n<6792> \n<6793> target_to_host_timespec(ts+1, arg3+sizeof(struct target_timespec));\n<6794> \n<6795> tsp = ts;\n<6796> \n<6797> }\n<6798> \n<6799> if (!arg2)\n<6800> \n<6801> ret = get_errno(sys_utimensat(arg1, NULL, tsp, arg4));\n<6802> \n<6803> else {\n<6804> \n<6805> if (!(p = lock_user_string(arg2))) {\n<6806> \n<6807> ret = -TARGET_EFAULT;\n<6808> \n<6809> goto fail;\n<6810> \n<6811> }\n<6812> \n<6813> ret = get_errno(sys_utimensat(arg1, path(p), tsp, arg4));\n<6814> \n<6815> unlock_user(p, arg2, 0);\n<6816> \n<6817> }\n<6818> \n<6819> }\n<6820> \n<6821> break;\n<6822> \n<6823> #endif\n<6824> \n<6825> #if defined(CONFIG_USE_NPTL)\n<6826> \n<6827> case TARGET_NR_futex:\n<6828> \n<6829> ret = do_futex(arg1, arg2, arg3, arg4, arg5, arg6);\n<6830> \n<6831> break;\n<6832> \n<6833> #endif\n<6834> \n<6835> #if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n<6836> \n<6837> case TARGET_NR_inotify_init:\n<6838> \n<6839> ret = get_errno(sys_inotify_init());\n<6840> \n<6841> break;\n<6842> \n<6843> #endif\n<6844> \n<6845> #ifdef CONFIG_INOTIFY1\n<6846> \n<6847> #if defined(TARGET_NR_inotify_init1) && defined(__NR_inotify_init1)\n<6848> \n<6849> case TARGET_NR_inotify_init1:\n<6850> \n<6851> ret = get_errno(sys_inotify_init1(arg1));\n<6852> \n<6853> break;\n<6854> \n<6855> #endif\n<6856> \n<6857> #endif\n<6858> \n<6859> #if defined(TARGET_NR_inotify_add_watch) && defined(__NR_inotify_add_watch)\n<6860> \n<6861> case TARGET_NR_inotify_add_watch:\n<6862> \n<6863> p = lock_user_string(arg2);\n<6864> \n<6865> ret = get_errno(sys_inotify_add_watch(arg1, path(p), arg3));\n<6866> \n<6867> unlock_user(p, arg2, 0);\n<6868> \n<6869> break;\n<6870> \n<6871> #endif\n<6872> \n<6873> #if defined(TARGET_NR_inotify_rm_watch) && defined(__NR_inotify_rm_watch)\n<6874> \n<6875> case TARGET_NR_inotify_rm_watch:\n<6876> \n<6877> ret = get_errno(sys_inotify_rm_watch(arg1, arg2));\n<6878> \n<6879> break;\n<6880> \n<6881> #endif\n<6882> \n<6883> \n<6884> \n<6885> #if defined(TARGET_NR_mq_open) && defined(__NR_mq_open)\n<6886> \n<6887> case TARGET_NR_mq_open:\n<6888> \n<6889> {\n<6890> \n<6891> struct mq_attr posix_mq_attr;\n<6892> \n<6893> \n<6894> \n<6895> p = lock_user_string(arg1 - 1);\n<6896> \n<6897> if (arg4 != 0)\n<6898> \n<6899> copy_from_user_mq_attr (&posix_mq_attr, arg4);\n<6900> \n<6901> ret = get_errno(mq_open(p, arg2, arg3, &posix_mq_attr));\n<6902> \n<6903> unlock_user (p, arg1, 0);\n<6904> \n<6905> }\n<6906> \n<6907> break;\n<6908> \n<6909> \n<6910> \n<6911> case TARGET_NR_mq_unlink:\n<6912> \n<6913> p = lock_user_string(arg1 - 1);\n<6914> \n<6915> ret = get_errno(mq_unlink(p));\n<6916> \n<6917> unlock_user (p, arg1, 0);\n<6918> \n<6919> break;\n<6920> \n<6921> \n<6922> \n<6923> case TARGET_NR_mq_timedsend:\n<6924> \n<6925> {\n<6926> \n<6927> struct timespec ts;\n<6928> \n<6929> \n<6930> \n<6931> p = lock_user (VERIFY_READ, arg2, arg3, 1);\n<6932> \n<6933> if (arg5 != 0) {\n<6934> \n<6935> target_to_host_timespec(&ts, arg5);\n<6936> \n<6937> ret = get_errno(mq_timedsend(arg1, p, arg3, arg4, &ts));\n<6938> \n<6939> host_to_target_timespec(arg5, &ts);\n<6940> \n<6941> }\n<6942> \n<6943> else\n<6944> \n<6945> ret = get_errno(mq_send(arg1, p, arg3, arg4));\n<6946> \n<6947> unlock_user (p, arg2, arg3);\n<6948> \n<6949> }\n<6950> \n<6951> break;\n<6952> \n<6953> \n<6954> \n<6955> case TARGET_NR_mq_timedreceive:\n<6956> \n<6957> {\n<6958> \n<6959> struct timespec ts;\n<6960> \n<6961> unsigned int prio;\n<6962> \n<6963> \n<6964> \n<6965> p = lock_user (VERIFY_READ, arg2, arg3, 1);\n<6966> \n<6967> if (arg5 != 0) {\n<6968> \n<6969> target_to_host_timespec(&ts, arg5);\n<6970> \n<6971> ret = get_errno(mq_timedreceive(arg1, p, arg3, &prio, &ts));\n<6972> \n<6973> host_to_target_timespec(arg5, &ts);\n<6974> \n<6975> }\n<6976> \n<6977> else\n<6978> \n<6979> ret = get_errno(mq_receive(arg1, p, arg3, &prio));\n<6980> \n<6981> unlock_user (p, arg2, arg3);\n<6982> \n<6983> if (arg4 != 0)\n<6984> \n<6985> put_user_u32(prio, arg4);\n<6986> \n<6987> }\n<6988> \n<6989> break;\n<6990> \n<6991> \n<6992> \n<6993> /* Not implemented for now... */\n<6994> \n<6995> /*     case TARGET_NR_mq_notify: */\n<6996> \n<6997> /*         break; */\n<6998> \n<6999> \n<7000> \n<7001> case TARGET_NR_mq_getsetattr:\n<7002> \n<7003> {\n<7004> \n<7005> struct mq_attr posix_mq_attr_in, posix_mq_attr_out;\n<7006> \n<7007> ret = 0;\n<7008> \n<7009> if (arg3 != 0) {\n<7010> \n<7011> ret = mq_getattr(arg1, &posix_mq_attr_out);\n<7012> \n<7013> copy_to_user_mq_attr(arg3, &posix_mq_attr_out);\n<7014> \n<7015> }\n<7016> \n<7017> if (arg2 != 0) {\n<7018> \n<7019> copy_from_user_mq_attr(&posix_mq_attr_in, arg2);\n<7020> \n<7021> ret |= mq_setattr(arg1, &posix_mq_attr_in, &posix_mq_attr_out);\n<7022> \n<7023> }\n<7024> \n<7025> \n<7026> \n<7027> }\n<7028> \n<7029> break;\n<7030> \n<7031> #endif\n<7032> \n<7033> \n<7034> \n<7035> #ifdef CONFIG_SPLICE\n<7036> \n<7037> #ifdef TARGET_NR_tee\n<7038> \n<7039> case TARGET_NR_tee:\n<7040> \n<7041> {\n<7042> \n<7043> ret = get_errno(tee(arg1,arg2,arg3,arg4));\n<7044> \n<7045> }\n<7046> \n<7047> break;\n<7048> \n<7049> #endif\n<7050> \n<7051> #ifdef TARGET_NR_splice\n<7052> \n<7053> case TARGET_NR_splice:\n<7054> \n<7055> {\n<7056> \n<7057> loff_t loff_in, loff_out;\n<7058> \n<7059> loff_t *ploff_in = NULL, *ploff_out = NULL;\n<7060> \n<7061> if(arg2) {\n<7062> \n<7063> get_user_u64(loff_in, arg2);\n<7064> \n<7065> ploff_in = &loff_in;\n<7066> \n<7067> }\n<7068> \n<7069> if(arg4) {\n<7070> \n<7071> get_user_u64(loff_out, arg2);\n<7072> \n<7073> ploff_out = &loff_out;\n<7074> \n<7075> }\n<7076> \n<7077> ret = get_errno(splice(arg1, ploff_in, arg3, ploff_out, arg5, arg6));\n<7078> \n<7079> }\n<7080> \n<7081> break;\n<7082> \n<7083> #endif\n<7084> \n<7085> #ifdef TARGET_NR_vmsplice\n<7086> \n<7087> case TARGET_NR_vmsplice:\n<7088> \n<7089> {\n<7090> \n<7091> int count = arg3;\n<7092> \n<7093> struct iovec *vec;\n<7094> \n<7095> \n<7096> \n<7097> vec = alloca(count * sizeof(struct iovec));\n<7098> \n<7099> if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n<7100> \n<7101> goto efault;\n<7102> \n<7103> ret = get_errno(vmsplice(arg1, vec, count, arg4));\n<7104> \n<7105> unlock_iovec(vec, arg2, count, 0);\n<7106> \n<7107> }\n<7108> \n<7109> break;\n<7110> \n<7111> #endif\n<7112> \n<7113> #endif /* CONFIG_SPLICE */\n<7114> \n<7115> #ifdef CONFIG_EVENTFD\n<7116> \n<7117> #if defined(TARGET_NR_eventfd)\n<7118> \n<7119> case TARGET_NR_eventfd:\n<7120> \n<7121> ret = get_errno(eventfd(arg1, 0));\n<7122> \n<7123> break;\n<7124> \n<7125> #endif\n<7126> \n<7127> #if defined(TARGET_NR_eventfd2)\n<7128> \n<7129> case TARGET_NR_eventfd2:\n<7130> \n<7131> ret = get_errno(eventfd(arg1, arg2));\n<7132> \n<7133> break;\n<7134> \n<7135> #endif\n<7136> \n<7137> #endif /* CONFIG_EVENTFD  */\n<7138> \n<7139> #if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n<7140> \n<7141> case TARGET_NR_fallocate:\n<7142> \n<7143> #if TARGET_ABI_BITS == 32\n<7144> \n<7145> ret = get_errno(fallocate(arg1, arg2, target_offset64(arg3, arg4),\n<7146> \n<7147> target_offset64(arg5, arg6)));\n<7148> \n<7149> #else\n<7150> \n<7151> ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n<7152> \n<7153> #endif\n<7154> \n<7155> break;\n<7156> \n<7157> #endif\n<7158> \n<7159> #if defined(CONFIG_SYNC_FILE_RANGE)\n<7160> \n<7161> #if defined(TARGET_NR_sync_file_range)\n<7162> \n<7163> case TARGET_NR_sync_file_range:\n<7164> \n<7165> #if TARGET_ABI_BITS == 32\n<7166> \n<7167> #if defined(TARGET_MIPS)\n<7168> \n<7169> ret = get_errno(sync_file_range(arg1, target_offset64(arg3, arg4),\n<7170> \n<7171> target_offset64(arg5, arg6), arg7));\n<7172> \n<7173> #else\n<7174> \n<7175> ret = get_errno(sync_file_range(arg1, target_offset64(arg2, arg3),\n<7176> \n<7177> target_offset64(arg4, arg5), arg6));\n<7178> \n<7179> #endif /* !TARGET_MIPS */\n<7180> \n<7181> #else\n<7182> \n<7183> ret = get_errno(sync_file_range(arg1, arg2, arg3, arg4));\n<7184> \n<7185> #endif\n<7186> \n<7187> break;\n<7188> \n<7189> #endif\n<7190> \n<7191> #if defined(TARGET_NR_sync_file_range2)\n<7192> \n<7193> case TARGET_NR_sync_file_range2:\n<7194> \n<7195> /* This is like sync_file_range but the arguments are reordered */\n<7196> \n<7197> #if TARGET_ABI_BITS == 32\n<7198> \n<7199> ret = get_errno(sync_file_range(arg1, target_offset64(arg3, arg4),\n<7200> \n<7201> target_offset64(arg5, arg6), arg2));\n<7202> \n<7203> #else\n<7204> \n<7205> ret = get_errno(sync_file_range(arg1, arg3, arg4, arg2));\n<7206> \n<7207> #endif\n<7208> \n<7209> break;\n<7210> \n<7211> #endif\n<7212> \n<7213> #endif\n<7214> \n<7215> #if defined(CONFIG_EPOLL)\n<7216> \n<7217> #if defined(TARGET_NR_epoll_create)\n<7218> \n<7219> case TARGET_NR_epoll_create:\n<7220> \n<7221> ret = get_errno(epoll_create(arg1));\n<7222> \n<7223> break;\n<7224> \n<7225> #endif\n<7226> \n<7227> #if defined(TARGET_NR_epoll_create1) && defined(CONFIG_EPOLL_CREATE1)\n<7228> \n<7229> case TARGET_NR_epoll_create1:\n<7230> \n<7231> ret = get_errno(epoll_create1(arg1));\n<7232> \n<7233> break;\n<7234> \n<7235> #endif\n<7236> \n<7237> #if defined(TARGET_NR_epoll_ctl)\n<7238> \n<7239> case TARGET_NR_epoll_ctl:\n<7240> \n<7241> {\n<7242> \n<7243> struct epoll_event ep;\n<7244> \n<7245> struct epoll_event *epp = 0;\n<7246> \n<7247> if (arg4) {\n<7248> \n<7249> struct target_epoll_event *target_ep;\n<7250> \n<7251> if (!lock_user_struct(VERIFY_READ, target_ep, arg4, 1)) {\n<7252> \n<7253> goto efault;\n<7254> \n<7255> }\n<7256> \n<7257> ep.events = tswap32(target_ep->events);\n<7258> \n<7259> /* The epoll_data_t union is just opaque data to the kernel,\n<7260> \n<7261> * so we transfer all 64 bits across and need not worry what\n<7262> \n<7263> * actual data type it is.\n<7264> \n<7265> */\n<7266> \n<7267> ep.data.u64 = tswap64(target_ep->data.u64);\n<7268> \n<7269> unlock_user_struct(target_ep, arg4, 0);\n<7270> \n<7271> epp = &ep;\n<7272> \n<7273> }\n<7274> \n<7275> ret = get_errno(epoll_ctl(arg1, arg2, arg3, epp));\n<7276> \n<7277> break;\n<7278> \n<7279> }\n<7280> \n<7281> #endif\n<7282> \n<7283> \n<7284> \n<7285> #if defined(TARGET_NR_epoll_pwait) && defined(CONFIG_EPOLL_PWAIT)\n<7286> \n<7287> #define IMPLEMENT_EPOLL_PWAIT\n<7288> \n<7289> #endif\n<7290> \n<7291> #if defined(TARGET_NR_epoll_wait) || defined(IMPLEMENT_EPOLL_PWAIT)\n<7292> \n<7293> #if defined(TARGET_NR_epoll_wait)\n<7294> \n<7295> case TARGET_NR_epoll_wait:\n<7296> \n<7297> #endif\n<7298> \n<7299> #if defined(IMPLEMENT_EPOLL_PWAIT)\n<7300> \n<7301> case TARGET_NR_epoll_pwait:\n<7302> \n<7303> #endif\n<7304> \n<7305> {\n<7306> \n<7307> struct target_epoll_event *target_ep;\n<7308> \n<7309> struct epoll_event *ep;\n<7310> \n<7311> int epfd = arg1;\n<7312> \n<7313> int maxevents = arg3;\n<7314> \n<7315> int timeout = arg4;\n<7316> \n<7317> \n<7318> \n<7319> target_ep = lock_user(VERIFY_WRITE, arg2,\n<7320> \n<7321> maxevents * sizeof(struct target_epoll_event), 1);\n<7322> \n<7323> if (!target_ep) {\n<7324> \n<7325> goto efault;\n<7326> \n<7327> }\n<7328> \n<7329> \n<7330> \n<7331> ep = alloca(maxevents * sizeof(struct epoll_event));\n<7332> \n<7333> \n<7334> \n<7335> switch (num) {\n<7336> \n<7337> #if defined(IMPLEMENT_EPOLL_PWAIT)\n<7338> \n<7339> case TARGET_NR_epoll_pwait:\n<7340> \n<7341> {\n<7342> \n<7343> target_sigset_t *target_set;\n<7344> \n<7345> sigset_t _set, *set = &_set;\n<7346> \n<7347> \n<7348> \n<7349> if (arg5) {\n<7350> \n<7351> target_set = lock_user(VERIFY_READ, arg5,\n<7352> \n<7353> sizeof(target_sigset_t), 1);\n<7354> \n<7355> if (!target_set) {\n<7356> \n<7357> unlock_user(target_ep, arg2, 0);\n<7358> \n<7359> goto efault;\n<7360> \n<7361> }\n<7362> \n<7363> target_to_host_sigset(set, target_set);\n<7364> \n<7365> unlock_user(target_set, arg5, 0);\n<7366> \n<7367> } else {\n<7368> \n<7369> set = NULL;\n<7370> \n<7371> }\n<7372> \n<7373> \n<7374> \n<7375> ret = get_errno(epoll_pwait(epfd, ep, maxevents, timeout, set));\n<7376> \n<7377> break;\n<7378> \n<7379> }\n<7380> \n<7381> #endif\n<7382> \n<7383> #if defined(TARGET_NR_epoll_wait)\n<7384> \n<7385> case TARGET_NR_epoll_wait:\n<7386> \n<7387> ret = get_errno(epoll_wait(epfd, ep, maxevents, timeout));\n<7388> \n<7389> break;\n<7390> \n<7391> #endif\n<7392> \n<7393> default:\n<7394> \n<7395> ret = -TARGET_ENOSYS;\n<7396> \n<7397> }\n<7398> \n<7399> if (!is_error(ret)) {\n<7400> \n<7401> int i;\n<7402> \n<7403> for (i = 0; i < ret; i++) {\n<7404> \n<7405> target_ep[i].events = tswap32(ep[i].events);\n<7406> \n<7407> target_ep[i].data.u64 = tswap64(ep[i].data.u64);\n<7408> \n<7409> }\n<7410> \n<7411> }\n<7412> \n<7413> unlock_user(target_ep, arg2, ret * sizeof(struct target_epoll_event));\n<7414> \n<7415> break;\n<7416> \n<7417> }\n<7418> \n<7419> #endif\n<7420> \n<7421> #endif\n<7422> \n<7423> #ifdef TARGET_NR_prlimit64\n<7424> \n<7425> case TARGET_NR_prlimit64:\n<7426> \n<7427> {\n<7428> \n<7429> /* args: pid, resource number, ptr to new rlimit, ptr to old rlimit */\n<7430> \n<7431> struct target_rlimit64 *target_rnew, *target_rold;\n<7432> \n<7433> struct host_rlimit64 rnew, rold, *rnewp = 0;\n<7434> \n<7435> if (arg3) {\n<7436> \n<7437> if (!lock_user_struct(VERIFY_READ, target_rnew, arg3, 1)) {\n<7438> \n<7439> goto efault;\n<7440> \n<7441> }\n<7442> \n<7443> rnew.rlim_cur = tswap64(target_rnew->rlim_cur);\n<7444> \n<7445> rnew.rlim_max = tswap64(target_rnew->rlim_max);\n<7446> \n<7447> unlock_user_struct(target_rnew, arg3, 0);\n<7448> \n<7449> rnewp = &rnew;\n<7450> \n<7451> }\n<7452> \n<7453> \n<7454> \n<7455> ret = get_errno(sys_prlimit64(arg1, arg2, rnewp, arg4 ? &rold : 0));\n<7456> \n<7457> if (!is_error(ret) && arg4) {\n<7458> \n<7459> if (!lock_user_struct(VERIFY_WRITE, target_rold, arg4, 1)) {\n<7460> \n<7461> goto efault;\n<7462> \n<7463> }\n<7464> \n<7465> target_rold->rlim_cur = tswap64(rold.rlim_cur);\n<7466> \n<7467> target_rold->rlim_max = tswap64(rold.rlim_max);\n<7468> \n<7469> unlock_user_struct(target_rold, arg4, 1);\n<7470> \n<7471> }\n<7472> \n<7473> break;\n<7474> \n<7475> }\n<7476> \n<7477> #endif\n<7478> \n<7479> default:\n<7480> \n<7481> unimplemented:\n<7482> \n<7483> gemu_log("qemu: Unsupported syscall: %d\n", num);\n<7484> \n<7485> #if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n<7486> \n<7487> unimplemented_nowarn:\n<7488> \n<7489> #endif\n<7490> \n<7491> ret = -TARGET_ENOSYS;\n<7492> \n<7493> break;\n<7494> \n<7495> }\n<7496> \n<7497> fail:\n<7498> \n<7499> #ifdef DEBUG\n<7500> \n<7501> gemu_log(" = " TARGET_ABI_FMT_ld "\n", ret);\n<7502> \n<7503> #endif\n<7504> \n<7505> if(do_strace)\n<7506> \n<7507> print_syscall_ret(num, ret);\n<7508> \n<7509> return ret;\n<7510> \n<7511> efault:\n<7512> \n<7513> ret = -TARGET_EFAULT;\n<7514> \n<7515> goto fail;\n<7516> \n<7517> }\n<7518> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int kvm_init(int smp_cpus)\n<2> \n<3> {\n<4> \n<5> static const char upgrade_note[] =\n<6> \n<7> "Please upgrade to at least kernel 2.6.29 or recent kvm-kmod\n"\n<8> \n<9> "(see http://sourceforge.net/projects/kvm).\n";\n<10> \n<11> KVMState *s;\n<12> \n<13> int ret;\n<14> \n<15> int i;\n<16> \n<17> \n<18> \n<19> if (smp_cpus > 1) {\n<20> \n<21> fprintf(stderr, "No SMP KVM support, use '-smp 1'\n");\n<22> \n<23> return -EINVAL;\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> s = qemu_mallocz(sizeof(KVMState));\n<30> \n<31> \n<32> \n<33> #ifdef KVM_CAP_SET_GUEST_DEBUG\n<34> \n<35> TAILQ_INIT(&s->kvm_sw_breakpoints);\n<36> \n<37> #endif\n<38> \n<39> for (i = 0; i < ARRAY_SIZE(s->slots); i++)\n<40> \n<41> s->slots[i].slot = i;\n<42> \n<43> \n<44> \n<45> s->vmfd = -1;\n<46> \n<47> s->fd = open("/dev/kvm", O_RDWR);\n<48> \n<49> if (s->fd == -1) {\n<50> \n<51> fprintf(stderr, "Could not access KVM kernel module: %m\n");\n<52> \n<53> ret = -errno;\n<54> \n<55> goto err;\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n<62> \n<63> if (ret < KVM_API_VERSION) {\n<64> \n<65> if (ret > 0)\n<66> \n<67> ret = -EINVAL;\n<68> \n<69> fprintf(stderr, "kvm version too old\n");\n<70> \n<71> goto err;\n<72> \n<73> }\n<74> \n<75> \n<76> \n<77> if (ret > KVM_API_VERSION) {\n<78> \n<79> ret = -EINVAL;\n<80> \n<81> fprintf(stderr, "kvm version not supported\n");\n<82> \n<83> goto err;\n<84> \n<85> }\n<86> \n<87> \n<88> \n<89> s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n<90> \n<91> if (s->vmfd < 0)\n<92> \n<93> goto err;\n<94> \n<95> \n<96> \n<97> /* initially, KVM allocated its own memory and we had to jump through\n<98> \n<99> * hooks to make phys_ram_base point to this.  Modern versions of KVM\n<100> \n<101> * just use a user allocated buffer so we can use regular pages\n<102> \n<103> * unmodified.  Make sure we have a sufficiently modern version of KVM.\n<104> \n<105> */\n<106> \n<107> if (!kvm_check_extension(s, KVM_CAP_USER_MEMORY)) {\n<108> \n<109> ret = -EINVAL;\n<110> \n<111> fprintf(stderr, "kvm does not support KVM_CAP_USER_MEMORY\n%s",\n<112> \n<113> upgrade_note);\n<114> \n<115> goto err;\n<116> \n<117> }\n<118> \n<119> \n<120> \n<121> /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n<122> \n<123> * destroyed properly.  Since we rely on this capability, refuse to work\n<124> \n<125> * with any kernel without this capability. */\n<126> \n<127> if (!kvm_check_extension(s, KVM_CAP_DESTROY_MEMORY_REGION_WORKS)) {\n<128> \n<129> ret = -EINVAL;\n<130> \n<131> \n<132> \n<133> fprintf(stderr,\n<134> \n<135> "KVM kernel module broken (DESTROY_MEMORY_REGION).\n%s",\n<136> \n<137> upgrade_note);\n<138> \n<139> goto err;\n<140> \n<141> }\n<142> \n<143> \n<144> \n<145> #ifdef KVM_CAP_COALESCED_MMIO\n<146> \n<147> s->coalesced_mmio = kvm_check_extension(s, KVM_CAP_COALESCED_MMIO);\n<148> \n<149> #else\n<150> \n<151> s->coalesced_mmio = 0;\n<152> \n<153> #endif\n<154> \n<155> \n<156> \n<157> s->broken_set_mem_region = 1;\n<158> \n<159> #ifdef KVM_CAP_JOIN_MEMORY_REGIONS_WORKS\n<160> \n<161> ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_JOIN_MEMORY_REGIONS_WORKS);\n<162> \n<163> if (ret > 0) {\n<164> \n<165> s->broken_set_mem_region = 0;\n<166> \n<167> }\n<168> \n<169> #endif\n<170> \n<171> \n<172> \n<173> ret = kvm_arch_init(s, smp_cpus);\n<174> \n<175> if (ret < 0)\n<176> \n<177> goto err;\n<178> \n<179> \n<180> \n<181> kvm_state = s;\n<182> \n<183> \n<184> \n<185> return 0;\n<186> \n<187> \n<188> \n<189> err:\n<190> \n<191> if (s) {\n<192> \n<193> if (s->vmfd != -1)\n<194> \n<195> close(s->vmfd);\n<196> \n<197> if (s->fd != -1)\n<198> \n<199> close(s->fd);\n<200> \n<201> }\n<202> \n<203> qemu_free(s);\n<204> \n<205> \n<206> \n<207> return ret;\n<208> \n<209> }\n<210> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mpc7_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<2> AVFrame * frame = data ;\n<3> const uint8_t * buf = avpkt -> data ;\n<4> int buf_size ;\n<5> MPCContext * c = avctx -> priv_data ;\n<6> GetBitContext gb ;\n<7> int i , ch ;\n<8> int mb = - 1 ;\n<9> Band * bands = c -> bands ;\n<10> int off , ret , last_frame , skip ;\n<11> int bits_used , bits_avail ;\n<12> memset ( bands , 0 , sizeof ( * bands ) * ( c -> maxbands + 1 ) ) ;\n<13> buf_size = avpkt -> size & ~ 3 ;\n<14> if ( buf_size <= 0 ) {\n<15> av_log ( avctx , AV_LOG_ERROR , "packet size is too small (%i bytes)\n" , avpkt -> size ) ;\n<16> return AVERROR_INVALIDDATA ;\n<17> }\n<18> if ( buf_size != avpkt -> size ) {\n<19> av_log ( avctx , AV_LOG_WARNING , "packet size is not a multiple of 4. " "extra bytes at the end will be skipped.\n" ) ;\n<20> }\n<21> skip = buf [ 0 ] ;\n<22> last_frame = buf [ 1 ] ;\n<23> buf += 4 ;\n<24> buf_size -= 4 ;\n<25> frame -> nb_samples = last_frame ? c -> lastframelen : MPC_FRAME_SIZE ;\n<26> if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n<27> av_log ( avctx , AV_LOG_ERROR , "get_buffer() failed\n" ) ;\n<28> return ret ;\n<29> }\n<30> av_fast_padded_malloc ( & c -> bits , & c -> buf_size , buf_size ) ;\n<31> if ( ! c -> bits ) return AVERROR ( ENOMEM ) ;\n<32> c -> dsp . bswap_buf ( ( uint32_t * ) c -> bits , ( const uint32_t * ) buf , buf_size >> 2 ) ;\n<33> init_get_bits ( & gb , c -> bits , buf_size * 8 ) ;\n<34> skip_bits_long ( & gb , skip ) ;\n<35> for ( i = 0 ;\n<36> i <= c -> maxbands ;\n<37> i ++ ) {\n<38> for ( ch = 0 ;\n<39> ch < 2 ;\n<40> ch ++ ) {\n<41> int t = 4 ;\n<42> if ( i ) t = get_vlc2 ( & gb , hdr_vlc . table , MPC7_HDR_BITS , 1 ) - 5 ;\n<43> if ( t == 4 ) bands [ i ] . res [ ch ] = get_bits ( & gb , 4 ) ;\n<44> else bands [ i ] . res [ ch ] = av_clip ( bands [ i - 1 ] . res [ ch ] + t , 0 , 17 ) ;\n<45> }\n<46> if ( bands [ i ] . res [ 0 ] || bands [ i ] . res [ 1 ] ) {\n<47> mb = i ;\n<48> if ( c -> MSS ) bands [ i ] . msf = get_bits1 ( & gb ) ;\n<49> }\n<50> }\n<51> for ( i = 0 ;\n<52> i <= mb ;\n<53> i ++ ) for ( ch = 0 ;\n<54> ch < 2 ;\n<55> ch ++ ) if ( bands [ i ] . res [ ch ] ) bands [ i ] . scfi [ ch ] = get_vlc2 ( & gb , scfi_vlc . table , MPC7_SCFI_BITS , 1 ) ;\n<56> for ( i = 0 ;\n<57> i <= mb ;\n<58> i ++ ) {\n<59> for ( ch = 0 ;\n<60> ch < 2 ;\n<61> ch ++ ) {\n<62> if ( bands [ i ] . res [ ch ] ) {\n<63> bands [ i ] . scf_idx [ ch ] [ 2 ] = c -> oldDSCF [ ch ] [ i ] ;\n<64> bands [ i ] . scf_idx [ ch ] [ 0 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 2 ] ) ;\n<65> switch ( bands [ i ] . scfi [ ch ] ) {\n<66> case 0 : bands [ i ] . scf_idx [ ch ] [ 1 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 0 ] ) ;\n<67> bands [ i ] . scf_idx [ ch ] [ 2 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 1 ] ) ;\n<68> break ;\n<69> case 1 : bands [ i ] . scf_idx [ ch ] [ 1 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 0 ] ) ;\n<70> bands [ i ] . scf_idx [ ch ] [ 2 ] = bands [ i ] . scf_idx [ ch ] [ 1 ] ;\n<71> break ;\n<72> case 2 : bands [ i ] . scf_idx [ ch ] [ 1 ] = bands [ i ] . scf_idx [ ch ] [ 0 ] ;\n<73> bands [ i ] . scf_idx [ ch ] [ 2 ] = get_scale_idx ( & gb , bands [ i ] . scf_idx [ ch ] [ 1 ] ) ;\n<74> break ;\n<75> case 3 : bands [ i ] . scf_idx [ ch ] [ 2 ] = bands [ i ] . scf_idx [ ch ] [ 1 ] = bands [ i ] . scf_idx [ ch ] [ 0 ] ;\n<76> break ;\n<77> }\n<78> c -> oldDSCF [ ch ] [ i ] = bands [ i ] . scf_idx [ ch ] [ 2 ] ;\n<79> }\n<80> }\n<81> }\n<82> memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n<83> off = 0 ;\n<84> for ( i = 0 ;\n<85> i < BANDS ;\n<86> i ++ , off += SAMPLES_PER_BAND ) for ( ch = 0 ;\n<87> ch < 2 ;\n<88> ch ++ ) idx_to_quant ( c , & gb , bands [ i ] . res [ ch ] , c -> Q [ ch ] + off ) ;\n<89> ff_mpc_dequantize_and_synth ( c , mb , ( int16_t * * ) frame -> extended_data , 2 ) ;\n<90> bits_used = get_bits_count ( & gb ) ;\n<91> bits_avail = buf_size * 8 ;\n<92> if ( ! last_frame && ( ( bits_avail < bits_used ) || ( bits_used + 32 <= bits_avail ) ) ) {\n<93> av_log ( avctx , AV_LOG_ERROR , "Error decoding frame: used %i of %i bits\n" , bits_used , bits_avail ) ;\n<94> return - 1 ;\n<95> }\n<96> if ( c -> frames_to_skip ) {\n<97> c -> frames_to_skip -- ;\n<98> * got_frame_ptr = 0 ;\n<99> return avpkt -> size ;\n<100> }\n<101> * got_frame_ptr = 1 ;\n<102> return avpkt -> size ;\n<103> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n<2> \n<3> {\n<4> \n<5> QXLCursorCmd *cmd = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);\n<6> \n<7> QXLCursor *cursor;\n<8> \n<9> QEMUCursor *c;\n<10> \n<11> \n<12> \n<13> if (!cmd) {\n<14> \n<15> return 1;\n<16> \n<17> }\n<18> \n<19> \n<20> \n<21> if (!dpy_cursor_define_supported(qxl->vga.con)) {\n<22> \n<23> return 0;\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n<30> \n<31> fprintf(stderr, "%s", __FUNCTION__);\n<32> \n<33> qxl_log_cmd_cursor(qxl, cmd, ext->group_id);\n<34> \n<35> fprintf(stderr, "\n");\n<36> \n<37> }\n<38> \n<39> switch (cmd->type) {\n<40> \n<41> case QXL_CURSOR_SET:\n<42> \n<43> cursor = qxl_phys2virt(qxl, cmd->u.set.shape, ext->group_id);\n<44> \n<45> if (!cursor) {\n<46> \n<47> return 1;\n<48> \n<49> }\n<50> \n<51> c = qxl_cursor(qxl, cursor, ext->group_id);\n<52> \n<53> if (c == NULL) {\n<54> \n<55> c = cursor_builtin_left_ptr();\n<56> \n<57> }\n<58> \n<59> qemu_mutex_lock(&qxl->ssd.lock);\n<60> \n<61> if (qxl->ssd.cursor) {\n<62> \n<63> cursor_put(qxl->ssd.cursor);\n<64> \n<65> }\n<66> \n<67> qxl->ssd.cursor = c;\n<68> \n<69> qxl->ssd.mouse_x = cmd->u.set.position.x;\n<70> \n<71> qxl->ssd.mouse_y = cmd->u.set.position.y;\n<72> \n<73> qemu_mutex_unlock(&qxl->ssd.lock);\n<74> \n<75> qemu_bh_schedule(qxl->ssd.cursor_bh);\n<76> \n<77> break;\n<78> \n<79> case QXL_CURSOR_MOVE:\n<80> \n<81> qemu_mutex_lock(&qxl->ssd.lock);\n<82> \n<83> qxl->ssd.mouse_x = cmd->u.position.x;\n<84> \n<85> qxl->ssd.mouse_y = cmd->u.position.y;\n<86> \n<87> qemu_mutex_unlock(&qxl->ssd.lock);\n<88> \n<89> qemu_bh_schedule(qxl->ssd.cursor_bh);\n<90> \n<91> break;\n<92> \n<93> }\n<94> \n<95> return 0;\n<96> \n<97> }\n<98> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void stellaris_enet_receive(void *opaque, const uint8_t *buf, size_t size)\n<2> \n<3> {\n<4> \n<5> stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n<6> \n<7> int n;\n<8> \n<9> uint8_t *p;\n<10> \n<11> uint32_t crc;\n<12> \n<13> \n<14> \n<15> if ((s->rctl & SE_RCTL_RXEN) == 0)\n<16> \n<17> return;\n<18> \n<19> if (s->np >= 31) {\n<20> \n<21> DPRINTF("Packet dropped\n");\n<22> \n<23> return;\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> DPRINTF("Received packet len=%d\n", size);\n<30> \n<31> n = s->next_packet + s->np;\n<32> \n<33> if (n >= 31)\n<34> \n<35> n -= 31;\n<36> \n<37> s->np++;\n<38> \n<39> \n<40> \n<41> s->rx[n].len = size + 6;\n<42> \n<43> p = s->rx[n].data;\n<44> \n<45> *(p++) = (size + 6);\n<46> \n<47> *(p++) = (size + 6) >> 8;\n<48> \n<49> memcpy (p, buf, size);\n<50> \n<51> p += size;\n<52> \n<53> crc = crc32(~0, buf, size);\n<54> \n<55> *(p++) = crc;\n<56> \n<57> *(p++) = crc >> 8;\n<58> \n<59> *(p++) = crc >> 16;\n<60> \n<61> *(p++) = crc >> 24;\n<62> \n<63> /* Clear the remaining bytes in the last word.  */\n<64> \n<65> if ((size & 3) != 2) {\n<66> \n<67> memset(p, 0, (6 - size) & 3);\n<68> \n<69> }\n<70> \n<71> \n<72> \n<73> s->ris |= SE_INT_RX;\n<74> \n<75> stellaris_enet_update(s);\n<76> \n<77> }\n<78> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n<2> \n<3> {\n<4> \n<5> PowerPCCPU *cpu = ppc_env_get_cpu(env);\n<6> \n<7> CPUState *cs = CPU(cpu);\n<8> \n<9> uint32_t *hc = (uint32_t*)buf;\n<10> \n<11> \n<12> \n<13> struct kvm_ppc_pvinfo pvinfo;\n<14> \n<15> \n<16> \n<17> if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n<18> \n<19> !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n<20> \n<21> memcpy(buf, pvinfo.hcall, buf_len);\n<22> \n<23> \n<24> \n<25> return 0;\n<26> \n<27> }\n<28> \n<29> \n<30> \n<31> /*\n<32> \n<33> * Fallback to always fail hypercalls:\n<34> \n<35> *\n<36> \n<37> *     li r3, -1\n<38> \n<39> *     nop\n<40> \n<41> *     nop\n<42> \n<43> *     nop\n<44> \n<45> */\n<46> \n<47> \n<48> \n<49> hc[0] = 0x3860ffff;\n<50> \n<51> hc[1] = 0x60000000;\n<52> \n<53> hc[2] = 0x60000000;\n<54> \n<55> hc[3] = 0x60000000;\n<56> \n<57> \n<58> \n<59> return 0;\n<60> \n<61> }\n<62> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int adx_parse(AVCodecParserContext *s1,\n<2> \n<3> AVCodecContext *avctx,\n<4> \n<5> const uint8_t **poutbuf, int *poutbuf_size,\n<6> \n<7> const uint8_t *buf, int buf_size)\n<8> \n<9> {\n<10> \n<11> ADXParseContext *s = s1->priv_data;\n<12> \n<13> ParseContext *pc = &s->pc;\n<14> \n<15> int next = END_NOT_FOUND;\n<16> \n<17> \n<18> \n<19> if (!avctx->extradata_size) {\n<20> \n<21> int ret;\n<22> \n<23> \n<24> \n<25> ff_combine_frame(pc, END_NOT_FOUND, &buf, &buf_size);\n<26> \n<27> \n<28> \n<29> if (!s->header_size && pc->index >= MIN_HEADER_SIZE) {\n<30> \n<31> if (ret = avpriv_adx_decode_header(avctx, pc->buffer, pc->index,\n<32> \n<33> &s->header_size, NULL))\n<34> \n<35> return AVERROR_INVALIDDATA;\n<36> \n<37> s->block_size = BLOCK_SIZE * avctx->channels;\n<38> \n<39> }\n<40> \n<41> if (s->header_size && s->header_size <= pc->index) {\n<42> \n<43> avctx->extradata = av_mallocz(s->header_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<44> \n<45> if (!avctx->extradata)\n<46> \n<47> return AVERROR(ENOMEM);\n<48> \n<49> avctx->extradata_size = s->header_size;\n<50> \n<51> memcpy(avctx->extradata, pc->buffer, s->header_size);\n<52> \n<53> memmove(pc->buffer, pc->buffer + s->header_size, s->header_size);\n<54> \n<55> pc->index -= s->header_size;\n<56> \n<57> }\n<58> \n<59> *poutbuf      = NULL;\n<60> \n<61> *poutbuf_size = 0;\n<62> \n<63> return buf_size;\n<64> \n<65> }\n<66> \n<67> \n<68> \n<69> if (pc->index - s->buf_pos >= s->block_size) {\n<70> \n<71> *poutbuf      = &pc->buffer[s->buf_pos];\n<72> \n<73> *poutbuf_size = s->block_size;\n<74> \n<75> s->buf_pos   += s->block_size;\n<76> \n<77> return 0;\n<78> \n<79> }\n<80> \n<81> if (pc->index && s->buf_pos) {\n<82> \n<83> memmove(pc->buffer, &pc->buffer[s->buf_pos], pc->index - s->buf_pos);\n<84> \n<85> pc->index -= s->buf_pos;\n<86> \n<87> s->buf_pos = 0;\n<88> \n<89> }\n<90> \n<91> if (buf_size + pc->index >= s->block_size)\n<92> \n<93> next = s->block_size - pc->index;\n<94> \n<95> \n<96> \n<97> if (ff_combine_frame(pc, next, &buf, &buf_size) < 0 || !buf_size) {\n<98> \n<99> *poutbuf      = NULL;\n<100> \n<101> *poutbuf_size = 0;\n<102> \n<103> return buf_size;\n<104> \n<105> }\n<106> \n<107> *poutbuf = buf;\n<108> \n<109> *poutbuf_size = buf_size;\n<110> \n<111> return next;\n<112> \n<113> }\n<114> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mpjpeg_read_packet(AVFormatContext *s, AVPacket *pkt)\n<2> \n<3> {\n<4> \n<5> int size;\n<6> \n<7> int ret;\n<8> \n<9> \n<10> \n<11> MPJPEGDemuxContext *mpjpeg = s->priv_data;\n<12> \n<13> if (mpjpeg->boundary == NULL) {\n<14> \n<15> mpjpeg->boundary = av_strdup("--");\n<16> \n<17> mpjpeg->searchstr = av_strdup("\r\n--");\n<18> \n<19> if (!mpjpeg->boundary || !mpjpeg->searchstr) {\n<20> \n<21> av_freep(&mpjpeg->boundary);\n<22> \n<23> av_freep(&mpjpeg->searchstr);\n<24> \n<25> return AVERROR(ENOMEM);\n<26> \n<27> }\n<28> \n<29> mpjpeg->searchstr_len = strlen(mpjpeg->searchstr);\n<30> \n<31> }\n<32> \n<33> \n<34> \n<35> ret = parse_multipart_header(s->pb, &size, mpjpeg->boundary, s);\n<36> \n<37> \n<38> \n<39> \n<40> \n<41> if (ret < 0)\n<42> \n<43> return ret;\n<44> \n<45> \n<46> \n<47> if (size > 0) {\n<48> \n<49> /* size has been provided to us in MIME header */\n<50> \n<51> ret = av_get_packet(s->pb, pkt, size);\n<52> \n<53> } else {\n<54> \n<55> /* no size was given -- we read until the next boundary or end-of-file */\n<56> \n<57> int remaining = 0, len;\n<58> \n<59> \n<60> \n<61> const int read_chunk = 2048;\n<62> \n<63> av_init_packet(pkt);\n<64> \n<65> pkt->data = NULL;\n<66> \n<67> pkt->size = 0;\n<68> \n<69> pkt->pos  = avio_tell(s->pb);\n<70> \n<71> \n<72> \n<73> /* we may need to return as much as all we've read back to the buffer */\n<74> \n<75> ffio_ensure_seekback(s->pb, read_chunk);\n<76> \n<77> \n<78> \n<79> while ((ret = av_append_packet(s->pb, pkt, read_chunk - remaining)) >= 0) {\n<80> \n<81> /* scan the new data */\n<82> \n<83> len = ret + remaining;\n<84> \n<85> char *start = pkt->data + pkt->size - len;\n<86> \n<87> do {\n<88> \n<89> if (!memcmp(start, mpjpeg->searchstr, mpjpeg->searchstr_len)) {\n<90> \n<91> // got the boundary! rewind the stream\n<92> \n<93> avio_seek(s->pb, -(len-2), SEEK_CUR);\n<94> \n<95> pkt->size -= (len-2);\n<96> \n<97> return pkt->size;\n<98> \n<99> }\n<100> \n<101> len--;\n<102> \n<103> start++;\n<104> \n<105> } while (len >= mpjpeg->searchstr_len);\n<106> \n<107> remaining = len;\n<108> \n<109> }\n<110> \n<111> \n<112> \n<113> /* error or EOF occurred */\n<114> \n<115> if (ret == AVERROR_EOF) {\n<116> \n<117> ret = pkt->size > 0 ? pkt->size : AVERROR_EOF;\n<118> \n<119> } else {\n<120> \n<121> av_packet_unref(pkt);\n<122> \n<123> }\n<124> \n<125> }\n<126> \n<127> \n<128> \n<129> return ret;\n<130> \n<131> }\n<132> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int authreadkeys ( const char * file ) {\n<2> FILE * fp ;\n<3> char * line ;\n<4> char * token ;\n<5> keyid_t keyno ;\n<6> int keytype ;\n<7> char buf [ 512 ] ;\n<8> u_char keystr [ 32 ] ;\n<9> size_t len ;\n<10> size_t j ;\n<11> fp = fopen ( file , "r" ) ;\n<12> if ( fp == NULL ) {\n<13> msyslog ( LOG_ERR , "authreadkeys: file %s: %m" , file ) ;\n<14> return ( 0 ) ;\n<15> }\n<16> INIT_SSL ( ) ;\n<17> auth_delkeys ( ) ;\n<18> while ( ( line = fgets ( buf , sizeof buf , fp ) ) != NULL ) {\n<19> token = nexttok ( & line ) ;\n<20> if ( token == NULL ) continue ;\n<21> keyno = atoi ( token ) ;\n<22> if ( keyno == 0 ) {\n<23> msyslog ( LOG_ERR , "authreadkeys: cannot change key %s" , token ) ;\n<24> continue ;\n<25> }\n<26> if ( keyno > NTP_MAXKEY ) {\n<27> msyslog ( LOG_ERR , "authreadkeys: key %s > %d reserved for Autokey" , token , NTP_MAXKEY ) ;\n<28> continue ;\n<29> }\n<30> token = nexttok ( & line ) ;\n<31> if ( token == NULL ) {\n<32> msyslog ( LOG_ERR , "authreadkeys: no key type for key %d" , keyno ) ;\n<33> continue ;\n<34> }\n<35> # ifdef OPENSSL keytype = keytype_from_text ( token , NULL ) ;\n<36> if ( keytype == 0 ) {\n<37> msyslog ( LOG_ERR , "authreadkeys: invalid type for key %d" , keyno ) ;\n<38> continue ;\n<39> }\n<40> if ( EVP_get_digestbynid ( keytype ) == NULL ) {\n<41> msyslog ( LOG_ERR , "authreadkeys: no algorithm for key %d" , keyno ) ;\n<42> continue ;\n<43> }\n<44> # else if ( ! ( * token == 'M' || * token == 'm' ) ) {\n<45> msyslog ( LOG_ERR , "authreadkeys: invalid type for key %d" , keyno ) ;\n<46> continue ;\n<47> }\n<48> keytype = KEY_TYPE_MD5 ;\n<49> # endif token = nexttok ( & line ) ;\n<50> if ( token == NULL ) {\n<51> msyslog ( LOG_ERR , "authreadkeys: no key for key %d" , keyno ) ;\n<52> continue ;\n<53> }\n<54> len = strlen ( token ) ;\n<55> if ( len <= 20 ) {\n<56> MD5auth_setkey ( keyno , keytype , ( u_char * ) token , len ) ;\n<57> }\n<58> else {\n<59> char hex [ ] = "0123456789abcdef" ;\n<60> u_char temp ;\n<61> char * ptr ;\n<62> size_t jlim ;\n<63> jlim = min ( len , 2 * sizeof ( keystr ) ) ;\n<64> for ( j = 0 ;\n<65> j < jlim ;\n<66> j ++ ) {\n<67> ptr = strchr ( hex , tolower ( ( unsigned char ) token [ j ] ) ) ;\n<68> if ( ptr == NULL ) break ;\n<69> temp = ( u_char ) ( ptr - hex ) ;\n<70> if ( j & 1 ) keystr [ j / 2 ] |= temp ;\n<71> else keystr [ j / 2 ] = temp << 4 ;\n<72> }\n<73> if ( j < jlim ) {\n<74> msyslog ( LOG_ERR , "authreadkeys: invalid hex digit for key %d" , keyno ) ;\n<75> continue ;\n<76> }\n<77> MD5auth_setkey ( keyno , keytype , keystr , jlim / 2 ) ;\n<78> }\n<79> }\n<80> fclose ( fp ) ;\n<81> return ( 1 ) ;\n<82> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size,\n<2> \n<3> AVPacket *avpkt)\n<4> \n<5> {\n<6> \n<7> const uint8_t *buf = avpkt->data;\n<8> \n<9> int buf_size = avpkt->size;\n<10> \n<11> AC3DecodeContext *s = avctx->priv_data;\n<12> \n<13> int16_t *out_samples = (int16_t *)data;\n<14> \n<15> int blk, ch, err;\n<16> \n<17> const uint8_t *channel_map;\n<18> \n<19> const float *output[AC3_MAX_CHANNELS];\n<20> \n<21> \n<22> \n<23> /* initialize the GetBitContext with the start of valid AC-3 Frame */\n<24> \n<25> if (s->input_buffer) {\n<26> \n<27> /* copy input buffer to decoder context to avoid reading past the end\n<28> \n<29> of the buffer, which can be caused by a damaged input stream. */\n<30> \n<31> memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));\n<32> \n<33> init_get_bits(&s->gbc, s->input_buffer, buf_size * 8);\n<34> \n<35> } else {\n<36> \n<37> init_get_bits(&s->gbc, buf, buf_size * 8);\n<38> \n<39> }\n<40> \n<41> \n<42> \n<43> /* parse the syncinfo */\n<44> \n<45> *data_size = 0;\n<46> \n<47> err = parse_frame_header(s);\n<48> \n<49> \n<50> \n<51> /* check that reported frame size fits in input buffer */\n<52> \n<53> if(s->frame_size > buf_size) {\n<54> \n<55> av_log(avctx, AV_LOG_ERROR, "incomplete frame\n");\n<56> \n<57> err = AAC_AC3_PARSE_ERROR_FRAME_SIZE;\n<58> \n<59> }\n<60> \n<61> \n<62> \n<63> /* check for crc mismatch */\n<64> \n<65> if(err != AAC_AC3_PARSE_ERROR_FRAME_SIZE && avctx->error_recognition >= FF_ER_CAREFUL) {\n<66> \n<67> if(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) {\n<68> \n<69> av_log(avctx, AV_LOG_ERROR, "frame CRC mismatch\n");\n<70> \n<71> err = AAC_AC3_PARSE_ERROR_CRC;\n<72> \n<73> }\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> if(err && err != AAC_AC3_PARSE_ERROR_CRC) {\n<80> \n<81> switch(err) {\n<82> \n<83> case AAC_AC3_PARSE_ERROR_SYNC:\n<84> \n<85> av_log(avctx, AV_LOG_ERROR, "frame sync error\n");\n<86> \n<87> return -1;\n<88> \n<89> case AAC_AC3_PARSE_ERROR_BSID:\n<90> \n<91> av_log(avctx, AV_LOG_ERROR, "invalid bitstream id\n");\n<92> \n<93> break;\n<94> \n<95> case AAC_AC3_PARSE_ERROR_SAMPLE_RATE:\n<96> \n<97> av_log(avctx, AV_LOG_ERROR, "invalid sample rate\n");\n<98> \n<99> break;\n<100> \n<101> case AAC_AC3_PARSE_ERROR_FRAME_SIZE:\n<102> \n<103> av_log(avctx, AV_LOG_ERROR, "invalid frame size\n");\n<104> \n<105> break;\n<106> \n<107> case AAC_AC3_PARSE_ERROR_FRAME_TYPE:\n<108> \n<109> /* skip frame if CRC is ok. otherwise use error concealment. */\n<110> \n<111> /* TODO: add support for substreams and dependent frames */\n<112> \n<113> if(s->frame_type == EAC3_FRAME_TYPE_DEPENDENT || s->substreamid) {\n<114> \n<115> av_log(avctx, AV_LOG_ERROR, "unsupported frame type : skipping frame\n");\n<116> \n<117> return s->frame_size;\n<118> \n<119> } else {\n<120> \n<121> av_log(avctx, AV_LOG_ERROR, "invalid frame type\n");\n<122> \n<123> }\n<124> \n<125> break;\n<126> \n<127> default:\n<128> \n<129> av_log(avctx, AV_LOG_ERROR, "invalid header\n");\n<130> \n<131> break;\n<132> \n<133> }\n<134> \n<135> }\n<136> \n<137> \n<138> \n<139> /* if frame is ok, set audio parameters */\n<140> \n<141> if (!err) {\n<142> \n<143> avctx->sample_rate = s->sample_rate;\n<144> \n<145> avctx->bit_rate = s->bit_rate;\n<146> \n<147> \n<148> \n<149> /* channel config */\n<150> \n<151> s->out_channels = s->channels;\n<152> \n<153> s->output_mode = s->channel_mode;\n<154> \n<155> if(s->lfe_on)\n<156> \n<157> s->output_mode |= AC3_OUTPUT_LFEON;\n<158> \n<159> if (avctx->request_channels > 0 && avctx->request_channels <= 2 &&\n<160> \n<161> avctx->request_channels < s->channels) {\n<162> \n<163> s->out_channels = avctx->request_channels;\n<164> \n<165> s->output_mode  = avctx->request_channels == 1 ? AC3_CHMODE_MONO : AC3_CHMODE_STEREO;\n<166> \n<167> s->channel_layout = ff_ac3_channel_layout_tab[s->output_mode];\n<168> \n<169> }\n<170> \n<171> avctx->channels = s->out_channels;\n<172> \n<173> avctx->channel_layout = s->channel_layout;\n<174> \n<175> \n<176> \n<177> /* set downmixing coefficients if needed */\n<178> \n<179> if(s->channels != s->out_channels && !((s->output_mode & AC3_OUTPUT_LFEON) &&\n<180> \n<181> s->fbw_channels == s->out_channels)) {\n<182> \n<183> set_downmix_coeffs(s);\n<184> \n<185> }\n<186> \n<187> } else if (!s->out_channels) {\n<188> \n<189> s->out_channels = avctx->channels;\n<190> \n<191> if(s->out_channels < s->channels)\n<192> \n<193> s->output_mode  = s->out_channels == 1 ? AC3_CHMODE_MONO : AC3_CHMODE_STEREO;\n<194> \n<195> }\n<196> \n<197> \n<198> \n<199> /* decode the audio blocks */\n<200> \n<201> channel_map = ff_ac3_dec_channel_map[s->output_mode & ~AC3_OUTPUT_LFEON][s->lfe_on];\n<202> \n<203> for (ch = 0; ch < s->out_channels; ch++)\n<204> \n<205> output[ch] = s->output[channel_map[ch]];\n<206> \n<207> for (blk = 0; blk < s->num_blocks; blk++) {\n<208> \n<209> if (!err && decode_audio_block(s, blk)) {\n<210> \n<211> av_log(avctx, AV_LOG_ERROR, "error decoding the audio block\n");\n<212> \n<213> err = 1;\n<214> \n<215> }\n<216> \n<217> s->dsp.float_to_int16_interleave(out_samples, output, 256, s->out_channels);\n<218> \n<219> out_samples += 256 * s->out_channels;\n<220> \n<221> }\n<222> \n<223> *data_size = s->num_blocks * 256 * avctx->channels * sizeof (int16_t);\n<224> \n<225> return s->frame_size;\n<226> \n<227> }\n<228> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void mcf5208evb_init(MachineState *machine)\n<2> \n<3> {\n<4> \n<5> ram_addr_t ram_size = machine->ram_size;\n<6> \n<7> const char *cpu_model = machine->cpu_model;\n<8> \n<9> const char *kernel_filename = machine->kernel_filename;\n<10> \n<11> M68kCPU *cpu;\n<12> \n<13> CPUM68KState *env;\n<14> \n<15> int kernel_size;\n<16> \n<17> uint64_t elf_entry;\n<18> \n<19> hwaddr entry;\n<20> \n<21> qemu_irq *pic;\n<22> \n<23> MemoryRegion *address_space_mem = get_system_memory();\n<24> \n<25> MemoryRegion *ram = g_new(MemoryRegion, 1);\n<26> \n<27> MemoryRegion *sram = g_new(MemoryRegion, 1);\n<28> \n<29> \n<30> \n<31> if (!cpu_model) {\n<32> \n<33> cpu_model = "m5208";\n<34> \n<35> }\n<36> \n<37> cpu = M68K_CPU(cpu_generic_init(TYPE_M68K_CPU, cpu_model));\n<38> \n<39> env = &cpu->env;\n<40> \n<41> \n<42> \n<43> /* Initialize CPU registers.  */\n<44> \n<45> env->vbr = 0;\n<46> \n<47> /* TODO: Configure BARs.  */\n<48> \n<49> \n<50> \n<51> /* DRAM at 0x40000000 */\n<52> \n<53> memory_region_allocate_system_memory(ram, NULL, "mcf5208.ram", ram_size);\n<54> \n<55> memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n<56> \n<57> \n<58> \n<59> /* Internal SRAM.  */\n<60> \n<61> memory_region_init_ram(sram, NULL, "mcf5208.sram", 16384, &error_fatal);\n<62> \n<63> memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n<64> \n<65> \n<66> \n<67> /* Internal peripherals.  */\n<68> \n<69> pic = mcf_intc_init(address_space_mem, 0xfc048000, cpu);\n<70> \n<71> \n<72> \n<73> mcf_uart_mm_init(0xfc060000, pic[26], serial_hds[0]);\n<74> \n<75> mcf_uart_mm_init(0xfc064000, pic[27], serial_hds[1]);\n<76> \n<77> mcf_uart_mm_init(0xfc068000, pic[28], serial_hds[2]);\n<78> \n<79> \n<80> \n<81> mcf5208_sys_init(address_space_mem, pic);\n<82> \n<83> \n<84> \n<85> if (nb_nics > 1) {\n<86> \n<87> fprintf(stderr, "Too many NICs\n");\n<88> \n<89> exit(1);\n<90> \n<91> }\n<92> \n<93> if (nd_table[0].used) {\n<94> \n<95> mcf_fec_init(address_space_mem, &nd_table[0],\n<96> \n<97> 0xfc030000, pic + 36);\n<98> \n<99> }\n<100> \n<101> \n<102> \n<103> /*  0xfc000000 SCM.  */\n<104> \n<105> /*  0xfc004000 XBS.  */\n<106> \n<107> /*  0xfc008000 FlexBus CS.  */\n<108> \n<109> /* 0xfc030000 FEC.  */\n<110> \n<111> /*  0xfc040000 SCM + Power management.  */\n<112> \n<113> /*  0xfc044000 eDMA.  */\n<114> \n<115> /* 0xfc048000 INTC.  */\n<116> \n<117> /*  0xfc058000 I2C.  */\n<118> \n<119> /*  0xfc05c000 QSPI.  */\n<120> \n<121> /* 0xfc060000 UART0.  */\n<122> \n<123> /* 0xfc064000 UART0.  */\n<124> \n<125> /* 0xfc068000 UART0.  */\n<126> \n<127> /*  0xfc070000 DMA timers.  */\n<128> \n<129> /* 0xfc080000 PIT0.  */\n<130> \n<131> /* 0xfc084000 PIT1.  */\n<132> \n<133> /*  0xfc088000 EPORT.  */\n<134> \n<135> /*  0xfc08c000 Watchdog.  */\n<136> \n<137> /*  0xfc090000 clock module.  */\n<138> \n<139> /*  0xfc0a0000 CCM + reset.  */\n<140> \n<141> /*  0xfc0a4000 GPIO.  */\n<142> \n<143> /* 0xfc0a8000 SDRAM controller.  */\n<144> \n<145> \n<146> \n<147> /* Load kernel.  */\n<148> \n<149> if (!kernel_filename) {\n<150> \n<151> if (qtest_enabled()) {\n<152> \n<153> return;\n<154> \n<155> }\n<156> \n<157> fprintf(stderr, "Kernel image must be specified\n");\n<158> \n<159> exit(1);\n<160> \n<161> }\n<162> \n<163> \n<164> \n<165> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<166> \n<167> NULL, NULL, 1, EM_68K, 0, 0);\n<168> \n<169> entry = elf_entry;\n<170> \n<171> if (kernel_size < 0) {\n<172> \n<173> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n<174> \n<175> NULL, NULL);\n<176> \n<177> }\n<178> \n<179> if (kernel_size < 0) {\n<180> \n<181> kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n<182> \n<183> ram_size);\n<184> \n<185> entry = 0x40000000;\n<186> \n<187> }\n<188> \n<189> if (kernel_size < 0) {\n<190> \n<191> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);\n<192> \n<193> exit(1);\n<194> \n<195> }\n<196> \n<197> \n<198> \n<199> env->pc = entry;\n<200> \n<201> }\n<202> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int open_self_maps(void *cpu_env, int fd)\n<2> \n<3> {\n<4> \n<5> #if defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_UNICORE32)\n<6> \n<7> CPUState *cpu = ENV_GET_CPU((CPUArchState *)cpu_env);\n<8> \n<9> TaskState *ts = cpu->opaque;\n<10> \n<11> #endif\n<12> \n<13> FILE *fp;\n<14> \n<15> char *line = NULL;\n<16> \n<17> size_t len = 0;\n<18> \n<19> ssize_t read;\n<20> \n<21> \n<22> \n<23> fp = fopen("/proc/self/maps", "r");\n<24> \n<25> if (fp == NULL) {\n<26> \n<27> return -EACCES;\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> while ((read = getline(&line, &len, fp)) != -1) {\n<34> \n<35> int fields, dev_maj, dev_min, inode;\n<36> \n<37> uint64_t min, max, offset;\n<38> \n<39> char flag_r, flag_w, flag_x, flag_p;\n<40> \n<41> char path[512] = "";\n<42> \n<43> fields = sscanf(line, "%"PRIx64"-%"PRIx64" %c%c%c%c %"PRIx64" %x:%x %d"\n<44> \n<45> " %512s", &min, &max, &flag_r, &flag_w, &flag_x,\n<46> \n<47> &flag_p, &offset, &dev_maj, &dev_min, &inode, path);\n<48> \n<49> \n<50> \n<51> if ((fields < 10) || (fields > 11)) {\n<52> \n<53> continue;\n<54> \n<55> }\n<56> \n<57> if (!strncmp(path, "[stack]", 7)) {\n<58> \n<59> continue;\n<60> \n<61> }\n<62> \n<63> if (h2g_valid(min) && h2g_valid(max)) {\n<64> \n<65> dprintf(fd, TARGET_ABI_FMT_lx "-" TARGET_ABI_FMT_lx\n<66> \n<67> " %c%c%c%c %08" PRIx64 " %02x:%02x %d %s%s\n",\n<68> \n<69> h2g(min), h2g(max), flag_r, flag_w,\n<70> \n<71> flag_x, flag_p, offset, dev_maj, dev_min, inode,\n<72> \n<73> path[0] ? "         " : "", path);\n<74> \n<75> }\n<76> \n<77> }\n<78> \n<79> \n<80> \n<81> free(line);\n<82> \n<83> fclose(fp);\n<84> \n<85> \n<86> \n<87> #if defined(TARGET_ARM) || defined(TARGET_M68K) || defined(TARGET_UNICORE32)\n<88> \n<89> dprintf(fd, "%08llx-%08llx rw-p %08llx 00:00 0          [stack]\n",\n<90> \n<91> (unsigned long long)ts->info->stack_limit,\n<92> \n<93> (unsigned long long)(ts->info->start_stack +\n<94> \n<95> (TARGET_PAGE_SIZE - 1)) & TARGET_PAGE_MASK,\n<96> \n<97> (unsigned long long)0);\n<98> \n<99> #endif\n<100> \n<101> \n<102> \n<103> return 0;\n<104> \n<105> }\n<106> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static char *shorts2str(int *sp, int count, const char *sep)\n<2> \n<3> {\n<4> \n<5> int i;\n<6> \n<7> char *ap, *ap0;\n<8> \n<9> if (!sep) sep = ", ";\n<10> \n<11> ap = av_malloc((5 + strlen(sep)) * count);\n<12> \n<13> if (!ap)\n<14> \n<15> return NULL;\n<16> \n<17> ap0   = ap;\n<18> \n<19> ap[0] = '\0';\n<20> \n<21> for (i = 0; i < count; i++) {\n<22> \n<23> int l = snprintf(ap, 5 + strlen(sep), "%d%s", sp[i], sep);\n<24> \n<25> ap += l;\n<26> \n<27> }\n<28> \n<29> ap0[strlen(ap0) - strlen(sep)] = '\0';\n<30> \n<31> return ap0;\n<32> \n<33> }\n<34> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n<2> \n<3> {\n<4> \n<5> QObject *token;\n<6> \n<7> const char *val;\n<8> \n<9> \n<10> \n<11> if (ap == NULL) {\n<12> \n<13> return NULL;\n<14> \n<15> }\n<16> \n<17> \n<18> \n<19> token = parser_context_pop_token(ctxt);\n<20> \n<21> assert(token && token_get_type(token) == JSON_ESCAPE);\n<22> \n<23> val = token_get_value(token);\n<24> \n<25> \n<26> \n<27> if (!strcmp(val, "%p")) {\n<28> \n<29> return va_arg(*ap, QObject *);\n<30> \n<31> } else if (!strcmp(val, "%i")) {\n<32> \n<33> return QOBJECT(qbool_from_bool(va_arg(*ap, int)));\n<34> \n<35> } else if (!strcmp(val, "%d")) {\n<36> \n<37> return QOBJECT(qint_from_int(va_arg(*ap, int)));\n<38> \n<39> } else if (!strcmp(val, "%ld")) {\n<40> \n<41> return QOBJECT(qint_from_int(va_arg(*ap, long)));\n<42> \n<43> } else if (!strcmp(val, "%lld") ||\n<44> \n<45> !strcmp(val, "%I64d")) {\n<46> \n<47> return QOBJECT(qint_from_int(va_arg(*ap, long long)));\n<48> \n<49> } else if (!strcmp(val, "%s")) {\n<50> \n<51> return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n<52> \n<53> } else if (!strcmp(val, "%f")) {\n<54> \n<55> return QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n<56> \n<57> }\n<58> \n<59> return NULL;\n<60> \n<61> }\n<62> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick ) {\n<2> int error , got_error ;\n<3> ha_rows start_records , new_header_length ;\n<4> my_off_t del ;\n<5> File new_file ;\n<6> MYISAM_SHARE * share = info -> s ;\n<7> char llbuff [ 22 ] , llbuff2 [ 22 ] ;\n<8> SORT_INFO sort_info ;\n<9> MI_SORT_PARAM sort_param ;\n<10> DBUG_ENTER ( "mi_repair" ) ;\n<11> bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ;\n<12> bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ;\n<13> start_records = info -> state -> records ;\n<14> new_header_length = ( param -> testflag & T_UNPACK ) ? 0L : share -> pack . header_length ;\n<15> got_error = 1 ;\n<16> new_file = - 1 ;\n<17> sort_param . sort_info = & sort_info ;\n<18> if ( ! ( param -> testflag & T_SILENT ) ) {\n<19> printf ( "- recovering (with keycache) MyISAM-table '%s'\n" , name ) ;\n<20> printf ( "Data records: %s\n" , llstr ( info -> state -> records , llbuff ) ) ;\n<21> }\n<22> param -> testflag |= T_REP ;\n<23> if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ;\n<24> DBUG_ASSERT ( param -> use_buffers < SIZE_T_MAX ) ;\n<25> if ( ! param -> using_global_keycache ) ( void ) init_key_cache ( dflt_key_cache , param -> key_cache_block_size , param -> use_buffers , 0 , 0 ) ;\n<26> if ( init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) ) {\n<27> bzero ( & info -> rec_cache , sizeof ( info -> rec_cache ) ) ;\n<28> goto err ;\n<29> }\n<30> if ( ! rep_quick ) if ( init_io_cache ( & info -> rec_cache , - 1 , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) ) ) goto err ;\n<31> info -> opt_flag |= WRITE_CACHE_USED ;\n<32> if ( ! mi_alloc_rec_buff ( info , - 1 , & sort_param . record ) || ! mi_alloc_rec_buff ( info , - 1 , & sort_param . rec_buff ) ) {\n<33> mi_check_print_error ( param , "Not enough memory for extra record" ) ;\n<34> goto err ;\n<35> }\n<36> if ( ! rep_quick ) {\n<37> if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , share -> data_file_name , "" , DATA_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) < 0 ) {\n<38> mi_check_print_error ( param , "Can't create new tempfile: '%s'" , param -> temp_filename ) ;\n<39> goto err ;\n<40> }\n<41> if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , "datafile-header" ) ) goto err ;\n<42> info -> s -> state . dellink = HA_OFFSET_ERROR ;\n<43> info -> rec_cache . file = new_file ;\n<44> if ( param -> testflag & T_UNPACK ) {\n<45> share -> options &= ~ HA_OPTION_COMPRESS_RECORD ;\n<46> mi_int2store ( share -> state . header . options , share -> options ) ;\n<47> }\n<48> }\n<49> sort_info . info = info ;\n<50> sort_info . param = param ;\n<51> sort_param . read_cache = param -> read_cache ;\n<52> sort_param . pos = sort_param . max_pos = share -> pack . header_length ;\n<53> sort_param . filepos = new_header_length ;\n<54> param -> read_cache . end_of_file = sort_info . filelength = mysql_file_seek ( info -> dfile , 0L , MY_SEEK_END , MYF ( 0 ) ) ;\n<55> sort_info . dupp = 0 ;\n<56> sort_param . fix_datafile = ( my_bool ) ( ! rep_quick ) ;\n<57> sort_param . master = 1 ;\n<58> sort_info . max_records = ~ ( ha_rows ) 0 ;\n<59> set_data_file_type ( & sort_info , share ) ;\n<60> del = info -> state -> del ;\n<61> info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n<62> info -> state -> empty = 0 ;\n<63> param -> glob_crc = 0 ;\n<64> if ( param -> testflag & T_CALC_CHECKSUM ) sort_param . calc_checksum = 1 ;\n<65> info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n<66> if ( param -> testflag & T_CREATE_MISSING_KEYS ) mi_set_all_keys_active ( share -> state . key_map , share -> base . keys ) ;\n<67> mi_drop_all_indexes ( param , info , TRUE ) ;\n<68> lock_memory ( param ) ;\n<69> while ( ! ( error = sort_get_next_record ( & sort_param ) ) ) {\n<70> if ( writekeys ( & sort_param ) ) {\n<71> if ( my_errno != HA_ERR_FOUND_DUPP_KEY ) goto err ;\n<72> DBUG_DUMP ( "record" , ( uchar * ) sort_param . record , share -> base . pack_reclength ) ;\n<73> mi_check_print_info ( param , "Duplicate key %2d for record at %10s against new record at %10s" , info -> errkey + 1 , llstr ( sort_param . start_recpos , llbuff ) , llstr ( info -> dupp_key_pos , llbuff2 ) ) ;\n<74> if ( param -> testflag & T_VERBOSE ) {\n<75> ( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ;\n<76> _mi_print_key ( stdout , share -> keyinfo [ info -> errkey ] . seg , info -> lastkey , USE_WHOLE_KEY ) ;\n<77> }\n<78> sort_info . dupp ++ ;\n<79> if ( ( param -> testflag & ( T_FORCE_UNIQUENESS | T_QUICK ) ) == T_QUICK ) {\n<80> param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n<81> param -> error_printed = 1 ;\n<82> goto err ;\n<83> }\n<84> continue ;\n<85> }\n<86> if ( sort_write_record ( & sort_param ) ) goto err ;\n<87> }\n<88> if ( error > 0 || write_data_suffix ( & sort_info , ( my_bool ) ! rep_quick ) || flush_io_cache ( & info -> rec_cache ) || param -> read_cache . error < 0 ) goto err ;\n<89> if ( param -> testflag & T_WRITE_LOOP ) {\n<90> ( void ) fputs ( " \r" , stdout ) ;\n<91> ( void ) fflush ( stdout ) ;\n<92> }\n<93> if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) {\n<94> mi_check_print_warning ( param , "Can't change size of indexfile, error: %d" , my_errno ) ;\n<95> goto err ;\n<96> }\n<97> if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n<98> mi_check_print_error ( param , "Couldn't fix table with quick recovery: Found wrong number of deleted records" ) ;\n<99> mi_check_print_error ( param , "Run recovery again without -q" ) ;\n<100> got_error = 1 ;\n<101> param -> retry_repair = 1 ;\n<102> param -> testflag |= T_RETRY_WITHOUT_QUICK ;\n<103> goto err ;\n<104> }\n<105> if ( param -> testflag & T_SAFE_REPAIR ) {\n<106> if ( info -> state -> records + 1 < start_records ) {\n<107> info -> state -> records = start_records ;\n<108> got_error = 1 ;\n<109> goto err ;\n<110> }\n<111> }\n<112> if ( ! rep_quick ) {\n<113> mysql_file_close ( info -> dfile , MYF ( 0 ) ) ;\n<114> info -> dfile = new_file ;\n<115> info -> state -> data_file_length = sort_param . filepos ;\n<116> share -> state . version = ( ulong ) time ( ( time_t * ) 0 ) ;\n<117> }\n<118> else {\n<119> info -> state -> data_file_length = sort_param . max_pos ;\n<120> }\n<121> if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n<122> if ( ! ( param -> testflag & T_SILENT ) ) {\n<123> if ( start_records != info -> state -> records ) printf ( "Data records: %s\n" , llstr ( info -> state -> records , llbuff ) ) ;\n<124> if ( sort_info . dupp ) mi_check_print_warning ( param , "%s records have been removed" , llstr ( sort_info . dupp , llbuff ) ) ;\n<125> }\n<126> got_error = 0 ;\n<127> if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n<128> err : if ( ! got_error ) {\n<129> if ( new_file >= 0 ) {\n<130> mysql_file_close ( new_file , MYF ( 0 ) ) ;\n<131> info -> dfile = new_file = - 1 ;\n<132> if ( info -> s -> file_map ) {\n<133> ( void ) my_munmap ( ( char * ) info -> s -> file_map , ( size_t ) info -> s -> mmaped_length ) ;\n<134> info -> s -> file_map = NULL ;\n<135> }\n<136> if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n<137> param -> retry_repair = 0 ;\n<138> }\n<139> }\n<140> if ( got_error ) {\n<141> if ( ! param -> error_printed ) mi_check_print_error ( param , "%d for record at pos %s" , my_errno , llstr ( sort_param . start_recpos , llbuff ) ) ;\n<142> if ( new_file >= 0 ) {\n<143> ( void ) mysql_file_close ( new_file , MYF ( 0 ) ) ;\n<144> ( void ) mysql_file_delete ( mi_key_file_datatmp , param -> temp_filename , MYF ( MY_WME ) ) ;\n<145> info -> rec_cache . file = - 1 ;\n<146> }\n<147> mi_mark_crashed_on_repair ( info ) ;\n<148> }\n<149> my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n<150> my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;\n<151> my_free ( sort_info . buff ) ;\n<152> ( void ) end_io_cache ( & param -> read_cache ) ;\n<153> info -> opt_flag &= ~ ( READ_CACHE_USED | WRITE_CACHE_USED ) ;\n<154> ( void ) end_io_cache ( & info -> rec_cache ) ;\n<155> got_error |= flush_blocks ( param , share -> key_cache , share -> kfile ) ;\n<156> if ( ! got_error && param -> testflag & T_UNPACK ) {\n<157> share -> state . header . options [ 0 ] &= ( uchar ) ~ HA_OPTION_COMPRESS_RECORD ;\n<158> share -> pack . header_length = 0 ;\n<159> share -> data_file_type = sort_info . new_data_file_type ;\n<160> }\n<161> share -> state . changed |= ( STATE_NOT_OPTIMIZED_KEYS | STATE_NOT_SORTED_PAGES | STATE_NOT_ANALYZED ) ;\n<162> DBUG_RETURN ( got_error ) ;\n<163> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void rtas_nvram_store(sPAPREnvironment *spapr,\n<2> \n<3> uint32_t token, uint32_t nargs,\n<4> \n<5> target_ulong args,\n<6> \n<7> uint32_t nret, target_ulong rets)\n<8> \n<9> {\n<10> \n<11> sPAPRNVRAM *nvram = spapr->nvram;\n<12> \n<13> hwaddr offset, buffer, len;\n<14> \n<15> int alen;\n<16> \n<17> void *membuf;\n<18> \n<19> \n<20> \n<21> if ((nargs != 3) || (nret != 2)) {\n<22> \n<23> rtas_st(rets, 0, -3);\n<24> \n<25> return;\n<26> \n<27> }\n<28> \n<29> \n<30> \n<31> if (!nvram) {\n<32> \n<33> rtas_st(rets, 0, -1);\n<34> \n<35> return;\n<36> \n<37> }\n<38> \n<39> \n<40> \n<41> offset = rtas_ld(args, 0);\n<42> \n<43> buffer = rtas_ld(args, 1);\n<44> \n<45> len = rtas_ld(args, 2);\n<46> \n<47> \n<48> \n<49> if (((offset + len) < offset)\n<50> \n<51> || ((offset + len) > nvram->size)) {\n<52> \n<53> rtas_st(rets, 0, -3);\n<54> \n<55> return;\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> membuf = cpu_physical_memory_map(buffer, &len, 0);\n<62> \n<63> if (nvram->drive) {\n<64> \n<65> alen = bdrv_pwrite(nvram->drive, offset, membuf, len);\n<66> \n<67> } else {\n<68> \n<69> assert(nvram->buf);\n<70> \n<71> \n<72> \n<73> memcpy(nvram->buf + offset, membuf, len);\n<74> \n<75> alen = len;\n<76> \n<77> }\n<78> \n<79> cpu_physical_memory_unmap(membuf, len, 0, len);\n<80> \n<81> \n<82> \n<83> rtas_st(rets, 0, (alen < len) ? -1 : 0);\n<84> \n<85> rtas_st(rets, 1, (alen < 0) ? 0 : alen);\n<86> \n<87> }\n<88> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int update_rom_mapping(VAPICROMState *s, CPUX86State *env, target_ulong ip)\n<2> \n<3> {\n<4> \n<5> target_phys_addr_t paddr;\n<6> \n<7> uint32_t rom_state_vaddr;\n<8> \n<9> uint32_t pos, patch, offset;\n<10> \n<11> \n<12> \n<13> /* nothing to do if already activated */\n<14> \n<15> if (s->state == VAPIC_ACTIVE) {\n<16> \n<17> return 0;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> /* bail out if ROM init code was not executed (missing ROM?) */\n<24> \n<25> if (s->state == VAPIC_INACTIVE) {\n<26> \n<27> return -1;\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> /* find out virtual address of the ROM */\n<34> \n<35> rom_state_vaddr = s->rom_state_paddr + (ip & 0xf0000000);\n<36> \n<37> paddr = cpu_get_phys_page_debug(env, rom_state_vaddr);\n<38> \n<39> if (paddr == -1) {\n<40> \n<41> return -1;\n<42> \n<43> }\n<44> \n<45> paddr += rom_state_vaddr & ~TARGET_PAGE_MASK;\n<46> \n<47> if (paddr != s->rom_state_paddr) {\n<48> \n<49> return -1;\n<50> \n<51> }\n<52> \n<53> read_guest_rom_state(s);\n<54> \n<55> if (memcmp(s->rom_state.signature, "kvm aPiC", 8) != 0) {\n<56> \n<57> return -1;\n<58> \n<59> }\n<60> \n<61> s->rom_state_vaddr = rom_state_vaddr;\n<62> \n<63> \n<64> \n<65> /* fixup addresses in ROM if needed */\n<66> \n<67> if (rom_state_vaddr == le32_to_cpu(s->rom_state.vaddr)) {\n<68> \n<69> return 0;\n<70> \n<71> }\n<72> \n<73> for (pos = le32_to_cpu(s->rom_state.fixup_start);\n<74> \n<75> pos < le32_to_cpu(s->rom_state.fixup_end);\n<76> \n<77> pos += 4) {\n<78> \n<79> cpu_physical_memory_rw(paddr + pos - s->rom_state.vaddr,\n<80> \n<81> (void *)&offset, sizeof(offset), 0);\n<82> \n<83> offset = le32_to_cpu(offset);\n<84> \n<85> cpu_physical_memory_rw(paddr + offset, (void *)&patch,\n<86> \n<87> sizeof(patch), 0);\n<88> \n<89> patch = le32_to_cpu(patch);\n<90> \n<91> patch += rom_state_vaddr - le32_to_cpu(s->rom_state.vaddr);\n<92> \n<93> patch = cpu_to_le32(patch);\n<94> \n<95> cpu_physical_memory_rw(paddr + offset, (void *)&patch,\n<96> \n<97> sizeof(patch), 1);\n<98> \n<99> }\n<100> \n<101> read_guest_rom_state(s);\n<102> \n<103> s->vapic_paddr = paddr + le32_to_cpu(s->rom_state.vapic_vaddr) -\n<104> \n<105> le32_to_cpu(s->rom_state.vaddr);\n<106> \n<107> \n<108> \n<109> return 0;\n<110> \n<111> }\n<112> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ffio_ensure_seekback(AVIOContext *s, int buf_size)\n<2> \n<3> {\n<4> \n<5> uint8_t *buffer;\n<6> \n<7> int max_buffer_size = s->max_packet_size ?\n<8> \n<9> s->max_packet_size : IO_BUFFER_SIZE;\n<10> \n<11> \n<12> \n<13> buf_size += s->buf_ptr - s->buffer + max_buffer_size;\n<14> \n<15> \n<16> \n<17> if (buf_size < s->buffer_size || s->seekable)\n<18> \n<19> return 0;\n<20> \n<21> av_assert0(!s->write_flag);\n<22> \n<23> \n<24> \n<25> buffer = av_malloc(buf_size);\n<26> \n<27> if (!buffer)\n<28> \n<29> return AVERROR(ENOMEM);\n<30> \n<31> \n<32> \n<33> memcpy(buffer, s->buffer, s->buffer_size);\n<34> \n<35> av_free(s->buffer);\n<36> \n<37> s->buf_ptr = buffer + (s->buf_ptr - s->buffer);\n<38> \n<39> s->buf_end = buffer + (s->buf_end - s->buffer);\n<40> \n<41> s->buffer = buffer;\n<42> \n<43> s->buffer_size = buf_size;\n<44> \n<45> return 0;\n<46> \n<47> }\n<48> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int dump_tablespaces ( char * ts_where ) {\n<2> MYSQL_ROW row ;\n<3> MYSQL_RES * tableres ;\n<4> char buf [ FN_REFLEN ] ;\n<5> DYNAMIC_STRING sqlbuf ;\n<6> int first = 0 ;\n<7> char extra_format [ ] = "UNDO_BUFFER_SIZE=" ;\n<8> char * ubs ;\n<9> char * endsemi ;\n<10> DBUG_ENTER ( "dump_tablespaces" ) ;\n<11> mysql_query ( mysql , "set optimizer_switch='semijoin=off'" ) ;\n<12> init_dynamic_string_checked ( & sqlbuf , "SELECT LOGFILE_GROUP_NAME," " FILE_NAME," " TOTAL_EXTENTS," " INITIAL_SIZE," " ENGINE," " EXTRA" " FROM INFORMATION_SCHEMA.FILES" " WHERE FILE_TYPE = 'UNDO LOG'" " AND FILE_NAME IS NOT NULL" , 256 , 1024 ) ;\n<13> if ( ts_where ) {\n<14> dynstr_append_checked ( & sqlbuf , " AND LOGFILE_GROUP_NAME IN (" "SELECT DISTINCT LOGFILE_GROUP_NAME" " FROM INFORMATION_SCHEMA.FILES" " WHERE FILE_TYPE = 'DATAFILE'" ) ;\n<15> dynstr_append_checked ( & sqlbuf , ts_where ) ;\n<16> dynstr_append_checked ( & sqlbuf , ")" ) ;\n<17> }\n<18> dynstr_append_checked ( & sqlbuf , " GROUP BY LOGFILE_GROUP_NAME, FILE_NAME" ", ENGINE" " ORDER BY LOGFILE_GROUP_NAME" ) ;\n<19> if ( mysql_query ( mysql , sqlbuf . str ) || ! ( tableres = mysql_store_result ( mysql ) ) ) {\n<20> dynstr_free ( & sqlbuf ) ;\n<21> if ( mysql_errno ( mysql ) == ER_BAD_TABLE_ERROR || mysql_errno ( mysql ) == ER_BAD_DB_ERROR || mysql_errno ( mysql ) == ER_UNKNOWN_TABLE ) {\n<22> fprintf ( md_result_file , "\n--\n-- Not dumping tablespaces as no INFORMATION_SCHEMA.FILES" " table on this server\n--\n" ) ;\n<23> check_io ( md_result_file ) ;\n<24> DBUG_RETURN ( 0 ) ;\n<25> }\n<26> fprintf ( stderr , "%s: Error: '%s' when trying to dump tablespaces\n" , my_progname_short , mysql_error ( mysql ) ) ;\n<27> DBUG_RETURN ( 1 ) ;\n<28> }\n<29> buf [ 0 ] = 0 ;\n<30> while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n<31> if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n<32> if ( first ) {\n<33> print_comment ( md_result_file , 0 , "\n--\n-- Logfile group: %s\n--\n" , row [ 0 ] ) ;\n<34> fprintf ( md_result_file , "\nCREATE" ) ;\n<35> }\n<36> else {\n<37> fprintf ( md_result_file , "\nALTER" ) ;\n<38> }\n<39> fprintf ( md_result_file , " LOGFILE GROUP %s\n" " ADD UNDOFILE '%s'\n" , row [ 0 ] , row [ 1 ] ) ;\n<40> if ( first ) {\n<41> ubs = strstr ( row [ 5 ] , extra_format ) ;\n<42> if ( ! ubs ) break ;\n<43> ubs += strlen ( extra_format ) ;\n<44> endsemi = strstr ( ubs , ";\n<45> " ) ;\n<46> if ( endsemi ) endsemi [ 0 ] = '\0' ;\n<47> fprintf ( md_result_file , " UNDO_BUFFER_SIZE %s\n" , ubs ) ;\n<48> }\n<49> fprintf ( md_result_file , " INITIAL_SIZE %s\n" " ENGINE=%s;\n<50> \n" , row [ 3 ] , row [ 4 ] ) ;\n<51> check_io ( md_result_file ) ;\n<52> if ( first ) {\n<53> first = 0 ;\n<54> strxmov ( buf , row [ 0 ] , NullS ) ;\n<55> }\n<56> }\n<57> dynstr_free ( & sqlbuf ) ;\n<58> mysql_free_result ( tableres ) ;\n<59> init_dynamic_string_checked ( & sqlbuf , "SELECT DISTINCT TABLESPACE_NAME," " FILE_NAME," " LOGFILE_GROUP_NAME," " EXTENT_SIZE," " INITIAL_SIZE," " ENGINE" " FROM INFORMATION_SCHEMA.FILES" " WHERE FILE_TYPE = 'DATAFILE'" , 256 , 1024 ) ;\n<60> if ( ts_where ) dynstr_append_checked ( & sqlbuf , ts_where ) ;\n<61> dynstr_append_checked ( & sqlbuf , " ORDER BY TABLESPACE_NAME, LOGFILE_GROUP_NAME" ) ;\n<62> if ( mysql_query_with_error_report ( mysql , & tableres , sqlbuf . str ) ) {\n<63> dynstr_free ( & sqlbuf ) ;\n<64> DBUG_RETURN ( 1 ) ;\n<65> }\n<66> buf [ 0 ] = 0 ;\n<67> while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n<68> if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n<69> if ( first ) {\n<70> print_comment ( md_result_file , 0 , "\n--\n-- Tablespace: %s\n--\n" , row [ 0 ] ) ;\n<71> fprintf ( md_result_file , "\nCREATE" ) ;\n<72> }\n<73> else {\n<74> fprintf ( md_result_file , "\nALTER" ) ;\n<75> }\n<76> fprintf ( md_result_file , " TABLESPACE %s\n" " ADD DATAFILE '%s'\n" , row [ 0 ] , row [ 1 ] ) ;\n<77> if ( first ) {\n<78> fprintf ( md_result_file , " USE LOGFILE GROUP %s\n" " EXTENT_SIZE %s\n" , row [ 2 ] , row [ 3 ] ) ;\n<79> }\n<80> fprintf ( md_result_file , " INITIAL_SIZE %s\n" " ENGINE=%s;\n<81> \n" , row [ 4 ] , row [ 5 ] ) ;\n<82> check_io ( md_result_file ) ;\n<83> if ( first ) {\n<84> first = 0 ;\n<85> strxmov ( buf , row [ 0 ] , NullS ) ;\n<86> }\n<87> }\n<88> mysql_free_result ( tableres ) ;\n<89> dynstr_free ( & sqlbuf ) ;\n<90> mysql_query ( mysql , "set optimizer_switch=default" ) ;\n<91> DBUG_RETURN ( 0 ) ;\n<92> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,\n<2> \n<3> const char *core)\n<4> \n<5> {\n<6> \n<7> struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n<8> \n<9> g_malloc0(sizeof(struct omap_mpu_state_s));\n<10> \n<11> ram_addr_t sram_base, q2_base;\n<12> \n<13> qemu_irq *cpu_irq;\n<14> \n<15> qemu_irq dma_irqs[4];\n<16> \n<17> DriveInfo *dinfo;\n<18> \n<19> int i;\n<20> \n<21> SysBusDevice *busdev;\n<22> \n<23> struct omap_target_agent_s *ta;\n<24> \n<25> \n<26> \n<27> /* Core */\n<28> \n<29> s->mpu_model = omap2420;\n<30> \n<31> s->env = cpu_init(core ?: "arm1136-r2");\n<32> \n<33> if (!s->env) {\n<34> \n<35> fprintf(stderr, "Unable to find CPU definition\n");\n<36> \n<37> exit(1);\n<38> \n<39> }\n<40> \n<41> s->sdram_size = sdram_size;\n<42> \n<43> s->sram_size = OMAP242X_SRAM_SIZE;\n<44> \n<45> \n<46> \n<47> s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];\n<48> \n<49> \n<50> \n<51> /* Clocks */\n<52> \n<53> omap_clk_init(s);\n<54> \n<55> \n<56> \n<57> /* Memory-mapped stuff */\n<58> \n<59> cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,\n<60> \n<61> (q2_base = qemu_ram_alloc(NULL, "omap2.dram",\n<62> \n<63> s->sdram_size)) | IO_MEM_RAM);\n<64> \n<65> cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size,\n<66> \n<67> (sram_base = qemu_ram_alloc(NULL, "omap2.sram",\n<68> \n<69> s->sram_size)) | IO_MEM_RAM);\n<70> \n<71> \n<72> \n<73> s->l4 = omap_l4_init(OMAP2_L4_BASE, 54);\n<74> \n<75> \n<76> \n<77> /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */\n<78> \n<79> cpu_irq = arm_pic_init_cpu(s->env);\n<80> \n<81> s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0],\n<82> \n<83> cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ],\n<84> \n<85> omap_findclk(s, "mpu_intc_fclk"),\n<86> \n<87> omap_findclk(s, "mpu_intc_iclk"));\n<88> \n<89> \n<90> \n<91> s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),\n<92> \n<93> s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s);\n<94> \n<95> \n<96> \n<97> s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),\n<98> \n<99> omap_findclk(s, "omapctrl_iclk"), s);\n<100> \n<101> \n<102> \n<103> for (i = 0; i < 4; i ++)\n<104> \n<105> dma_irqs[i] =\n<106> \n<107> s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr];\n<108> \n<109> s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32,\n<110> \n<111> omap_findclk(s, "sdma_iclk"),\n<112> \n<113> omap_findclk(s, "sdma_fclk"));\n<114> \n<115> s->port->addr_valid = omap2_validate_addr;\n<116> \n<117> \n<118> \n<119> /* Register SDRAM and SRAM ports for fast DMA transfers.  */\n<120> \n<121> soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base),\n<122> \n<123> OMAP2_Q2_BASE, s->sdram_size);\n<124> \n<125> soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base),\n<126> \n<127> OMAP2_SRAM_BASE, s->sram_size);\n<128> \n<129> \n<130> \n<131> s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19),\n<132> \n<133> s->irq[0][OMAP_INT_24XX_UART1_IRQ],\n<134> \n<135> omap_findclk(s, "uart1_fclk"),\n<136> \n<137> omap_findclk(s, "uart1_iclk"),\n<138> \n<139> s->drq[OMAP24XX_DMA_UART1_TX],\n<140> \n<141> s->drq[OMAP24XX_DMA_UART1_RX],\n<142> \n<143> "uart1",\n<144> \n<145> serial_hds[0]);\n<146> \n<147> s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20),\n<148> \n<149> s->irq[0][OMAP_INT_24XX_UART2_IRQ],\n<150> \n<151> omap_findclk(s, "uart2_fclk"),\n<152> \n<153> omap_findclk(s, "uart2_iclk"),\n<154> \n<155> s->drq[OMAP24XX_DMA_UART2_TX],\n<156> \n<157> s->drq[OMAP24XX_DMA_UART2_RX],\n<158> \n<159> "uart2",\n<160> \n<161> serial_hds[0] ? serial_hds[1] : NULL);\n<162> \n<163> s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21),\n<164> \n<165> s->irq[0][OMAP_INT_24XX_UART3_IRQ],\n<166> \n<167> omap_findclk(s, "uart3_fclk"),\n<168> \n<169> omap_findclk(s, "uart3_iclk"),\n<170> \n<171> s->drq[OMAP24XX_DMA_UART3_TX],\n<172> \n<173> s->drq[OMAP24XX_DMA_UART3_RX],\n<174> \n<175> "uart3",\n<176> \n<177> serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n<178> \n<179> \n<180> \n<181> s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),\n<182> \n<183> s->irq[0][OMAP_INT_24XX_GPTIMER1],\n<184> \n<185> omap_findclk(s, "wu_gpt1_clk"),\n<186> \n<187> omap_findclk(s, "wu_l4_iclk"));\n<188> \n<189> s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),\n<190> \n<191> s->irq[0][OMAP_INT_24XX_GPTIMER2],\n<192> \n<193> omap_findclk(s, "core_gpt2_clk"),\n<194> \n<195> omap_findclk(s, "core_l4_iclk"));\n<196> \n<197> s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),\n<198> \n<199> s->irq[0][OMAP_INT_24XX_GPTIMER3],\n<200> \n<201> omap_findclk(s, "core_gpt3_clk"),\n<202> \n<203> omap_findclk(s, "core_l4_iclk"));\n<204> \n<205> s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),\n<206> \n<207> s->irq[0][OMAP_INT_24XX_GPTIMER4],\n<208> \n<209> omap_findclk(s, "core_gpt4_clk"),\n<210> \n<211> omap_findclk(s, "core_l4_iclk"));\n<212> \n<213> s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),\n<214> \n<215> s->irq[0][OMAP_INT_24XX_GPTIMER5],\n<216> \n<217> omap_findclk(s, "core_gpt5_clk"),\n<218> \n<219> omap_findclk(s, "core_l4_iclk"));\n<220> \n<221> s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),\n<222> \n<223> s->irq[0][OMAP_INT_24XX_GPTIMER6],\n<224> \n<225> omap_findclk(s, "core_gpt6_clk"),\n<226> \n<227> omap_findclk(s, "core_l4_iclk"));\n<228> \n<229> s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),\n<230> \n<231> s->irq[0][OMAP_INT_24XX_GPTIMER7],\n<232> \n<233> omap_findclk(s, "core_gpt7_clk"),\n<234> \n<235> omap_findclk(s, "core_l4_iclk"));\n<236> \n<237> s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),\n<238> \n<239> s->irq[0][OMAP_INT_24XX_GPTIMER8],\n<240> \n<241> omap_findclk(s, "core_gpt8_clk"),\n<242> \n<243> omap_findclk(s, "core_l4_iclk"));\n<244> \n<245> s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),\n<246> \n<247> s->irq[0][OMAP_INT_24XX_GPTIMER9],\n<248> \n<249> omap_findclk(s, "core_gpt9_clk"),\n<250> \n<251> omap_findclk(s, "core_l4_iclk"));\n<252> \n<253> s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),\n<254> \n<255> s->irq[0][OMAP_INT_24XX_GPTIMER10],\n<256> \n<257> omap_findclk(s, "core_gpt10_clk"),\n<258> \n<259> omap_findclk(s, "core_l4_iclk"));\n<260> \n<261> s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),\n<262> \n<263> s->irq[0][OMAP_INT_24XX_GPTIMER11],\n<264> \n<265> omap_findclk(s, "core_gpt11_clk"),\n<266> \n<267> omap_findclk(s, "core_l4_iclk"));\n<268> \n<269> s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),\n<270> \n<271> s->irq[0][OMAP_INT_24XX_GPTIMER12],\n<272> \n<273> omap_findclk(s, "core_gpt12_clk"),\n<274> \n<275> omap_findclk(s, "core_l4_iclk"));\n<276> \n<277> \n<278> \n<279> omap_tap_init(omap_l4ta(s->l4, 2), s);\n<280> \n<281> \n<282> \n<283> s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,\n<284> \n<285> omap_findclk(s, "clk32-kHz"),\n<286> \n<287> omap_findclk(s, "core_l4_iclk"));\n<288> \n<289> \n<290> \n<291> s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5),\n<292> \n<293> s->irq[0][OMAP_INT_24XX_I2C1_IRQ],\n<294> \n<295> &s->drq[OMAP24XX_DMA_I2C1_TX],\n<296> \n<297> omap_findclk(s, "i2c1.fclk"),\n<298> \n<299> omap_findclk(s, "i2c1.iclk"));\n<300> \n<301> s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6),\n<302> \n<303> s->irq[0][OMAP_INT_24XX_I2C2_IRQ],\n<304> \n<305> &s->drq[OMAP24XX_DMA_I2C2_TX],\n<306> \n<307> omap_findclk(s, "i2c2.fclk"),\n<308> \n<309> omap_findclk(s, "i2c2.iclk"));\n<310> \n<311> \n<312> \n<313> s->gpio = qdev_create(NULL, "omap2-gpio");\n<314> \n<315> qdev_prop_set_int32(s->gpio, "mpu_model", s->mpu_model);\n<316> \n<317> qdev_prop_set_ptr(s->gpio, "iclk", omap_findclk(s, "gpio_iclk"));\n<318> \n<319> qdev_prop_set_ptr(s->gpio, "fclk0", omap_findclk(s, "gpio1_dbclk"));\n<320> \n<321> qdev_prop_set_ptr(s->gpio, "fclk1", omap_findclk(s, "gpio2_dbclk"));\n<322> \n<323> qdev_prop_set_ptr(s->gpio, "fclk2", omap_findclk(s, "gpio3_dbclk"));\n<324> \n<325> qdev_prop_set_ptr(s->gpio, "fclk3", omap_findclk(s, "gpio4_dbclk"));\n<326> \n<327> if (s->mpu_model == omap2430) {\n<328> \n<329> qdev_prop_set_ptr(s->gpio, "fclk4", omap_findclk(s, "gpio5_dbclk"));\n<330> \n<331> }\n<332> \n<333> qdev_init_nofail(s->gpio);\n<334> \n<335> busdev = sysbus_from_qdev(s->gpio);\n<336> \n<337> sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]);\n<338> \n<339> sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]);\n<340> \n<341> sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]);\n<342> \n<343> sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]);\n<344> \n<345> ta = omap_l4ta(s->l4, 3);\n<346> \n<347> sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));\n<348> \n<349> sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));\n<350> \n<351> sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));\n<352> \n<353> sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));\n<354> \n<355> sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));\n<356> \n<357> \n<358> \n<359> s->sdrc = omap_sdrc_init(0x68009000);\n<360> \n<361> s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ],\n<362> \n<363> s->drq[OMAP24XX_DMA_GPMC]);\n<364> \n<365> \n<366> \n<367> dinfo = drive_get(IF_SD, 0, 0);\n<368> \n<369> if (!dinfo) {\n<370> \n<371> fprintf(stderr, "qemu: missing SecureDigital device\n");\n<372> \n<373> exit(1);\n<374> \n<375> }\n<376> \n<377> s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv,\n<378> \n<379> s->irq[0][OMAP_INT_24XX_MMC_IRQ],\n<380> \n<381> &s->drq[OMAP24XX_DMA_MMC1_TX],\n<382> \n<383> omap_findclk(s, "mmc_fclk"), omap_findclk(s, "mmc_iclk"));\n<384> \n<385> \n<386> \n<387> s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,\n<388> \n<389> s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ],\n<390> \n<391> &s->drq[OMAP24XX_DMA_SPI1_TX0],\n<392> \n<393> omap_findclk(s, "spi1_fclk"),\n<394> \n<395> omap_findclk(s, "spi1_iclk"));\n<396> \n<397> s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,\n<398> \n<399> s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ],\n<400> \n<401> &s->drq[OMAP24XX_DMA_SPI2_TX0],\n<402> \n<403> omap_findclk(s, "spi2_fclk"),\n<404> \n<405> omap_findclk(s, "spi2_iclk"));\n<406> \n<407> \n<408> \n<409> s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800,\n<410> \n<411> /* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together */\n<412> \n<413> s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS],\n<414> \n<415> omap_findclk(s, "dss_clk1"), omap_findclk(s, "dss_clk2"),\n<416> \n<417> omap_findclk(s, "dss_54m_clk"),\n<418> \n<419> omap_findclk(s, "dss_l3_iclk"),\n<420> \n<421> omap_findclk(s, "dss_l4_iclk"));\n<422> \n<423> \n<424> \n<425> omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000,\n<426> \n<427> s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, "emul_ck"),\n<428> \n<429> serial_hds[0] && serial_hds[1] && serial_hds[2] ?\n<430> \n<431> serial_hds[3] : NULL);\n<432> \n<433> \n<434> \n<435> s->eac = omap_eac_init(omap_l4ta(s->l4, 32),\n<436> \n<437> s->irq[0][OMAP_INT_24XX_EAC_IRQ],\n<438> \n<439> /* Ten consecutive lines */\n<440> \n<441> &s->drq[OMAP24XX_DMA_EAC_AC_RD],\n<442> \n<443> omap_findclk(s, "func_96m_clk"),\n<444> \n<445> omap_findclk(s, "core_l4_iclk"));\n<446> \n<447> \n<448> \n<449> /* All register mappings (includin those not currenlty implemented):\n<450> \n<451> * SystemControlMod	48000000 - 48000fff\n<452> \n<453> * SystemControlL4	48001000 - 48001fff\n<454> \n<455> * 32kHz Timer Mod	48004000 - 48004fff\n<456> \n<457> * 32kHz Timer L4	48005000 - 48005fff\n<458> \n<459> * PRCM ModA	48008000 - 480087ff\n<460> \n<461> * PRCM ModB	48008800 - 48008fff\n<462> \n<463> * PRCM L4		48009000 - 48009fff\n<464> \n<465> * TEST-BCM Mod	48012000 - 48012fff\n<466> \n<467> * TEST-BCM L4	48013000 - 48013fff\n<468> \n<469> * TEST-TAP Mod	48014000 - 48014fff\n<470> \n<471> * TEST-TAP L4	48015000 - 48015fff\n<472> \n<473> * GPIO1 Mod	48018000 - 48018fff\n<474> \n<475> * GPIO Top		48019000 - 48019fff\n<476> \n<477> * GPIO2 Mod	4801a000 - 4801afff\n<478> \n<479> * GPIO L4		4801b000 - 4801bfff\n<480> \n<481> * GPIO3 Mod	4801c000 - 4801cfff\n<482> \n<483> * GPIO4 Mod	4801e000 - 4801efff\n<484> \n<485> * WDTIMER1 Mod	48020000 - 48010fff\n<486> \n<487> * WDTIMER Top	48021000 - 48011fff\n<488> \n<489> * WDTIMER2 Mod	48022000 - 48012fff\n<490> \n<491> * WDTIMER L4	48023000 - 48013fff\n<492> \n<493> * WDTIMER3 Mod	48024000 - 48014fff\n<494> \n<495> * WDTIMER3 L4	48025000 - 48015fff\n<496> \n<497> * WDTIMER4 Mod	48026000 - 48016fff\n<498> \n<499> * WDTIMER4 L4	48027000 - 48017fff\n<500> \n<501> * GPTIMER1 Mod	48028000 - 48018fff\n<502> \n<503> * GPTIMER1 L4	48029000 - 48019fff\n<504> \n<505> * GPTIMER2 Mod	4802a000 - 4801afff\n<506> \n<507> * GPTIMER2 L4	4802b000 - 4801bfff\n<508> \n<509> * L4-Config AP	48040000 - 480407ff\n<510> \n<511> * L4-Config IP	48040800 - 48040fff\n<512> \n<513> * L4-Config LA	48041000 - 48041fff\n<514> \n<515> * ARM11ETB Mod	48048000 - 48049fff\n<516> \n<517> * ARM11ETB L4	4804a000 - 4804afff\n<518> \n<519> * DISPLAY Top	48050000 - 480503ff\n<520> \n<521> * DISPLAY DISPC	48050400 - 480507ff\n<522> \n<523> * DISPLAY RFBI	48050800 - 48050bff\n<524> \n<525> * DISPLAY VENC	48050c00 - 48050fff\n<526> \n<527> * DISPLAY L4	48051000 - 48051fff\n<528> \n<529> * CAMERA Top	48052000 - 480523ff\n<530> \n<531> * CAMERA core	48052400 - 480527ff\n<532> \n<533> * CAMERA DMA	48052800 - 48052bff\n<534> \n<535> * CAMERA MMU	48052c00 - 48052fff\n<536> \n<537> * CAMERA L4	48053000 - 48053fff\n<538> \n<539> * SDMA Mod		48056000 - 48056fff\n<540> \n<541> * SDMA L4		48057000 - 48057fff\n<542> \n<543> * SSI Top		48058000 - 48058fff\n<544> \n<545> * SSI GDD		48059000 - 48059fff\n<546> \n<547> * SSI Port1	4805a000 - 4805afff\n<548> \n<549> * SSI Port2	4805b000 - 4805bfff\n<550> \n<551> * SSI L4		4805c000 - 4805cfff\n<552> \n<553> * USB Mod		4805e000 - 480fefff\n<554> \n<555> * USB L4		4805f000 - 480fffff\n<556> \n<557> * WIN_TRACER1 Mod	48060000 - 48060fff\n<558> \n<559> * WIN_TRACER1 L4	48061000 - 48061fff\n<560> \n<561> * WIN_TRACER2 Mod	48062000 - 48062fff\n<562> \n<563> * WIN_TRACER2 L4	48063000 - 48063fff\n<564> \n<565> * WIN_TRACER3 Mod	48064000 - 48064fff\n<566> \n<567> * WIN_TRACER3 L4	48065000 - 48065fff\n<568> \n<569> * WIN_TRACER4 Top	48066000 - 480660ff\n<570> \n<571> * WIN_TRACER4 ETT	48066100 - 480661ff\n<572> \n<573> * WIN_TRACER4 WT	48066200 - 480662ff\n<574> \n<575> * WIN_TRACER4 L4	48067000 - 48067fff\n<576> \n<577> * XTI Mod		48068000 - 48068fff\n<578> \n<579> * XTI L4		48069000 - 48069fff\n<580> \n<581> * UART1 Mod	4806a000 - 4806afff\n<582> \n<583> * UART1 L4		4806b000 - 4806bfff\n<584> \n<585> * UART2 Mod	4806c000 - 4806cfff\n<586> \n<587> * UART2 L4		4806d000 - 4806dfff\n<588> \n<589> * UART3 Mod	4806e000 - 4806efff\n<590> \n<591> * UART3 L4		4806f000 - 4806ffff\n<592> \n<593> * I2C1 Mod		48070000 - 48070fff\n<594> \n<595> * I2C1 L4		48071000 - 48071fff\n<596> \n<597> * I2C2 Mod		48072000 - 48072fff\n<598> \n<599> * I2C2 L4		48073000 - 48073fff\n<600> \n<601> * McBSP1 Mod	48074000 - 48074fff\n<602> \n<603> * McBSP1 L4	48075000 - 48075fff\n<604> \n<605> * McBSP2 Mod	48076000 - 48076fff\n<606> \n<607> * McBSP2 L4	48077000 - 48077fff\n<608> \n<609> * GPTIMER3 Mod	48078000 - 48078fff\n<610> \n<611> * GPTIMER3 L4	48079000 - 48079fff\n<612> \n<613> * GPTIMER4 Mod	4807a000 - 4807afff\n<614> \n<615> * GPTIMER4 L4	4807b000 - 4807bfff\n<616> \n<617> * GPTIMER5 Mod	4807c000 - 4807cfff\n<618> \n<619> * GPTIMER5 L4	4807d000 - 4807dfff\n<620> \n<621> * GPTIMER6 Mod	4807e000 - 4807efff\n<622> \n<623> * GPTIMER6 L4	4807f000 - 4807ffff\n<624> \n<625> * GPTIMER7 Mod	48080000 - 48080fff\n<626> \n<627> * GPTIMER7 L4	48081000 - 48081fff\n<628> \n<629> * GPTIMER8 Mod	48082000 - 48082fff\n<630> \n<631> * GPTIMER8 L4	48083000 - 48083fff\n<632> \n<633> * GPTIMER9 Mod	48084000 - 48084fff\n<634> \n<635> * GPTIMER9 L4	48085000 - 48085fff\n<636> \n<637> * GPTIMER10 Mod	48086000 - 48086fff\n<638> \n<639> * GPTIMER10 L4	48087000 - 48087fff\n<640> \n<641> * GPTIMER11 Mod	48088000 - 48088fff\n<642> \n<643> * GPTIMER11 L4	48089000 - 48089fff\n<644> \n<645> * GPTIMER12 Mod	4808a000 - 4808afff\n<646> \n<647> * GPTIMER12 L4	4808b000 - 4808bfff\n<648> \n<649> * EAC Mod		48090000 - 48090fff\n<650> \n<651> * EAC L4		48091000 - 48091fff\n<652> \n<653> * FAC Mod		48092000 - 48092fff\n<654> \n<655> * FAC L4		48093000 - 48093fff\n<656> \n<657> * MAILBOX Mod	48094000 - 48094fff\n<658> \n<659> * MAILBOX L4	48095000 - 48095fff\n<660> \n<661> * SPI1 Mod		48098000 - 48098fff\n<662> \n<663> * SPI1 L4		48099000 - 48099fff\n<664> \n<665> * SPI2 Mod		4809a000 - 4809afff\n<666> \n<667> * SPI2 L4		4809b000 - 4809bfff\n<668> \n<669> * MMC/SDIO Mod	4809c000 - 4809cfff\n<670> \n<671> * MMC/SDIO L4	4809d000 - 4809dfff\n<672> \n<673> * MS_PRO Mod	4809e000 - 4809efff\n<674> \n<675> * MS_PRO L4	4809f000 - 4809ffff\n<676> \n<677> * RNG Mod		480a0000 - 480a0fff\n<678> \n<679> * RNG L4		480a1000 - 480a1fff\n<680> \n<681> * DES3DES Mod	480a2000 - 480a2fff\n<682> \n<683> * DES3DES L4	480a3000 - 480a3fff\n<684> \n<685> * SHA1MD5 Mod	480a4000 - 480a4fff\n<686> \n<687> * SHA1MD5 L4	480a5000 - 480a5fff\n<688> \n<689> * AES Mod		480a6000 - 480a6fff\n<690> \n<691> * AES L4		480a7000 - 480a7fff\n<692> \n<693> * PKA Mod		480a8000 - 480a9fff\n<694> \n<695> * PKA L4		480aa000 - 480aafff\n<696> \n<697> * MG Mod		480b0000 - 480b0fff\n<698> \n<699> * MG L4		480b1000 - 480b1fff\n<700> \n<701> * HDQ/1-wire Mod	480b2000 - 480b2fff\n<702> \n<703> * HDQ/1-wire L4	480b3000 - 480b3fff\n<704> \n<705> * MPU interrupt	480fe000 - 480fefff\n<706> \n<707> * STI channel base	54000000 - 5400ffff\n<708> \n<709> * IVA RAM		5c000000 - 5c01ffff\n<710> \n<711> * IVA ROM		5c020000 - 5c027fff\n<712> \n<713> * IMG_BUF_A	5c040000 - 5c040fff\n<714> \n<715> * IMG_BUF_B	5c042000 - 5c042fff\n<716> \n<717> * VLCDS		5c048000 - 5c0487ff\n<718> \n<719> * IMX_COEF		5c049000 - 5c04afff\n<720> \n<721> * IMX_CMD		5c051000 - 5c051fff\n<722> \n<723> * VLCDQ		5c053000 - 5c0533ff\n<724> \n<725> * VLCDH		5c054000 - 5c054fff\n<726> \n<727> * SEQ_CMD		5c055000 - 5c055fff\n<728> \n<729> * IMX_REG		5c056000 - 5c0560ff\n<730> \n<731> * VLCD_REG		5c056100 - 5c0561ff\n<732> \n<733> * SEQ_REG		5c056200 - 5c0562ff\n<734> \n<735> * IMG_BUF_REG	5c056300 - 5c0563ff\n<736> \n<737> * SEQIRQ_REG	5c056400 - 5c0564ff\n<738> \n<739> * OCP_REG		5c060000 - 5c060fff\n<740> \n<741> * SYSC_REG		5c070000 - 5c070fff\n<742> \n<743> * MMU_REG		5d000000 - 5d000fff\n<744> \n<745> * sDMA R		68000400 - 680005ff\n<746> \n<747> * sDMA W		68000600 - 680007ff\n<748> \n<749> * Display Control	68000800 - 680009ff\n<750> \n<751> * DSP subsystem	68000a00 - 68000bff\n<752> \n<753> * MPU subsystem	68000c00 - 68000dff\n<754> \n<755> * IVA subsystem	68001000 - 680011ff\n<756> \n<757> * USB		68001200 - 680013ff\n<758> \n<759> * Camera		68001400 - 680015ff\n<760> \n<761> * VLYNQ (firewall)	68001800 - 68001bff\n<762> \n<763> * VLYNQ		68001e00 - 68001fff\n<764> \n<765> * SSI		68002000 - 680021ff\n<766> \n<767> * L4		68002400 - 680025ff\n<768> \n<769> * DSP (firewall)	68002800 - 68002bff\n<770> \n<771> * DSP subsystem	68002e00 - 68002fff\n<772> \n<773> * IVA (firewall)	68003000 - 680033ff\n<774> \n<775> * IVA		68003600 - 680037ff\n<776> \n<777> * GFX		68003a00 - 68003bff\n<778> \n<779> * CMDWR emulation	68003c00 - 68003dff\n<780> \n<781> * SMS		68004000 - 680041ff\n<782> \n<783> * OCM		68004200 - 680043ff\n<784> \n<785> * GPMC		68004400 - 680045ff\n<786> \n<787> * RAM (firewall)	68005000 - 680053ff\n<788> \n<789> * RAM (err login)	68005400 - 680057ff\n<790> \n<791> * ROM (firewall)	68005800 - 68005bff\n<792> \n<793> * ROM (err login)	68005c00 - 68005fff\n<794> \n<795> * GPMC (firewall)	68006000 - 680063ff\n<796> \n<797> * GPMC (err login)	68006400 - 680067ff\n<798> \n<799> * SMS (err login)	68006c00 - 68006fff\n<800> \n<801> * SMS registers	68008000 - 68008fff\n<802> \n<803> * SDRC registers	68009000 - 68009fff\n<804> \n<805> * GPMC registers	6800a000   6800afff\n<806> \n<807> */\n<808> \n<809> \n<810> \n<811> qemu_register_reset(omap2_mpu_reset, s);\n<812> \n<813> \n<814> \n<815> return s;\n<816> \n<817> }\n<818> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int decode_ref_pic_list_reordering(H264Context *h){\n<2> \n<3> MpegEncContext * const s = &h->s;\n<4> \n<5> int list, index, pic_structure;\n<6> \n<7> \n<8> \n<9> print_short_term(h);\n<10> \n<11> print_long_term(h);\n<12> \n<13> if(h->slice_type==FF_I_TYPE || h->slice_type==FF_SI_TYPE) return 0; //FIXME move before func\n<14> \n<15> \n<16> \n<17> for(list=0; list<h->list_count; list++){\n<18> \n<19> memcpy(h->ref_list[list], h->default_ref_list[list], sizeof(Picture)*h->ref_count[list]);\n<20> \n<21> \n<22> \n<23> if(get_bits1(&s->gb)){\n<24> \n<25> int pred= h->curr_pic_num;\n<26> \n<27> \n<28> \n<29> for(index=0; ; index++){\n<30> \n<31> unsigned int reordering_of_pic_nums_idc= get_ue_golomb(&s->gb);\n<32> \n<33> unsigned int pic_id;\n<34> \n<35> int i;\n<36> \n<37> Picture *ref = NULL;\n<38> \n<39> \n<40> \n<41> if(reordering_of_pic_nums_idc==3)\n<42> \n<43> break;\n<44> \n<45> \n<46> \n<47> if(index >= h->ref_count[list]){\n<48> \n<49> av_log(h->s.avctx, AV_LOG_ERROR, "reference count overflow\n");\n<50> \n<51> return -1;\n<52> \n<53> }\n<54> \n<55> \n<56> \n<57> if(reordering_of_pic_nums_idc<3){\n<58> \n<59> if(reordering_of_pic_nums_idc<2){\n<60> \n<61> const unsigned int abs_diff_pic_num= get_ue_golomb(&s->gb) + 1;\n<62> \n<63> int frame_num;\n<64> \n<65> \n<66> \n<67> if(abs_diff_pic_num > h->max_pic_num){\n<68> \n<69> av_log(h->s.avctx, AV_LOG_ERROR, "abs_diff_pic_num overflow\n");\n<70> \n<71> return -1;\n<72> \n<73> }\n<74> \n<75> \n<76> \n<77> if(reordering_of_pic_nums_idc == 0) pred-= abs_diff_pic_num;\n<78> \n<79> else                                pred+= abs_diff_pic_num;\n<80> \n<81> pred &= h->max_pic_num - 1;\n<82> \n<83> \n<84> \n<85> frame_num = pic_num_extract(h, pred, &pic_structure);\n<86> \n<87> \n<88> \n<89> for(i= h->short_ref_count-1; i>=0; i--){\n<90> \n<91> ref = h->short_ref[i];\n<92> \n<93> assert(ref->reference);\n<94> \n<95> assert(!ref->long_ref);\n<96> \n<97> if(ref->data[0] != NULL &&\n<98> \n<99> ref->frame_num == frame_num &&\n<100> \n<101> (ref->reference & pic_structure) &&\n<102> \n<103> ref->long_ref == 0) // ignore non existing pictures by testing data[0] pointer\n<104> \n<105> break;\n<106> \n<107> }\n<108> \n<109> if(i>=0)\n<110> \n<111> ref->pic_id= pred;\n<112> \n<113> }else{\n<114> \n<115> int long_idx;\n<116> \n<117> pic_id= get_ue_golomb(&s->gb); //long_term_pic_idx\n<118> \n<119> \n<120> \n<121> long_idx= pic_num_extract(h, pic_id, &pic_structure);\n<122> \n<123> \n<124> \n<125> if(long_idx>31){\n<126> \n<127> av_log(h->s.avctx, AV_LOG_ERROR, "long_term_pic_idx overflow\n");\n<128> \n<129> return -1;\n<130> \n<131> }\n<132> \n<133> ref = h->long_ref[long_idx];\n<134> \n<135> assert(!(ref && !ref->reference));\n<136> \n<137> if(ref && (ref->reference & pic_structure)){\n<138> \n<139> ref->pic_id= pic_id;\n<140> \n<141> assert(ref->long_ref);\n<142> \n<143> i=0;\n<144> \n<145> }else{\n<146> \n<147> i=-1;\n<148> \n<149> }\n<150> \n<151> }\n<152> \n<153> \n<154> \n<155> if (i < 0) {\n<156> \n<157> av_log(h->s.avctx, AV_LOG_ERROR, "reference picture missing during reorder\n");\n<158> \n<159> memset(&h->ref_list[list][index], 0, sizeof(Picture)); //FIXME\n<160> \n<161> } else {\n<162> \n<163> for(i=index; i+1<h->ref_count[list]; i++){\n<164> \n<165> if(ref->long_ref == h->ref_list[list][i].long_ref && ref->pic_id == h->ref_list[list][i].pic_id)\n<166> \n<167> break;\n<168> \n<169> }\n<170> \n<171> for(; i > index; i--){\n<172> \n<173> h->ref_list[list][i]= h->ref_list[list][i-1];\n<174> \n<175> }\n<176> \n<177> h->ref_list[list][index]= *ref;\n<178> \n<179> if (FIELD_PICTURE){\n<180> \n<181> pic_as_field(&h->ref_list[list][index], pic_structure);\n<182> \n<183> }\n<184> \n<185> }\n<186> \n<187> }else{\n<188> \n<189> av_log(h->s.avctx, AV_LOG_ERROR, "illegal reordering_of_pic_nums_idc\n");\n<190> \n<191> return -1;\n<192> \n<193> }\n<194> \n<195> }\n<196> \n<197> }\n<198> \n<199> }\n<200> \n<201> for(list=0; list<h->list_count; list++){\n<202> \n<203> for(index= 0; index < h->ref_count[list]; index++){\n<204> \n<205> if(!h->ref_list[list][index].data[0])\n<206> \n<207> h->ref_list[list][index]= s->current_picture;\n<208> \n<209> }\n<210> \n<211> }\n<212> \n<213> \n<214> \n<215> if(h->slice_type==FF_B_TYPE && !h->direct_spatial_mv_pred)\n<216> \n<217> direct_dist_scale_factor(h);\n<218> \n<219> direct_ref_list_init(h);\n<220> \n<221> return 0;\n<222> \n<223> }\n<224> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int init_output_stream(OutputStream *ost, char *error, int error_len)\n<2> \n<3> {\n<4> \n<5> int ret = 0;\n<6> \n<7> \n<8> \n<9> if (ost->encoding_needed) {\n<10> \n<11> AVCodec      *codec = ost->enc;\n<12> \n<13> AVCodecContext *dec = NULL;\n<14> \n<15> InputStream *ist;\n<16> \n<17> \n<18> \n<19> ret = init_output_stream_encode(ost);\n<20> \n<21> if (ret < 0)\n<22> \n<23> return ret;\n<24> \n<25> \n<26> \n<27> if ((ist = get_input_stream(ost)))\n<28> \n<29> dec = ist->dec_ctx;\n<30> \n<31> if (dec && dec->subtitle_header) {\n<32> \n<33> ost->enc_ctx->subtitle_header = av_malloc(dec->subtitle_header_size);\n<34> \n<35> if (!ost->enc_ctx->subtitle_header)\n<36> \n<37> return AVERROR(ENOMEM);\n<38> \n<39> memcpy(ost->enc_ctx->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<40> \n<41> ost->enc_ctx->subtitle_header_size = dec->subtitle_header_size;\n<42> \n<43> }\n<44> \n<45> if (!av_dict_get(ost->encoder_opts, "threads", NULL, 0))\n<46> \n<47> av_dict_set(&ost->encoder_opts, "threads", "auto", 0);\n<48> \n<49> \n<50> \n<51> if (ost->filter && ost->filter->filter->inputs[0]->hw_frames_ctx) {\n<52> \n<53> ost->enc_ctx->hw_frames_ctx = av_buffer_ref(ost->filter->filter->inputs[0]->hw_frames_ctx);\n<54> \n<55> if (!ost->enc_ctx->hw_frames_ctx)\n<56> \n<57> return AVERROR(ENOMEM);\n<58> \n<59> }\n<60> \n<61> \n<62> \n<63> if ((ret = avcodec_open2(ost->enc_ctx, codec, &ost->encoder_opts)) < 0) {\n<64> \n<65> if (ret == AVERROR_EXPERIMENTAL)\n<66> \n<67> abort_codec_experimental(codec, 1);\n<68> \n<69> snprintf(error, error_len,\n<70> \n<71> "Error while opening encoder for output stream #%d:%d - "\n<72> \n<73> "maybe incorrect parameters such as bit_rate, rate, width or height",\n<74> \n<75> ost->file_index, ost->index);\n<76> \n<77> return ret;\n<78> \n<79> }\n<80> \n<81> assert_avoptions(ost->encoder_opts);\n<82> \n<83> if (ost->enc_ctx->bit_rate && ost->enc_ctx->bit_rate < 1000)\n<84> \n<85> av_log(NULL, AV_LOG_WARNING, "The bitrate parameter is set too low."\n<86> \n<87> "It takes bits/s as argument, not kbits/s\n");\n<88> \n<89> \n<90> \n<91> ret = avcodec_parameters_from_context(ost->st->codecpar, ost->enc_ctx);\n<92> \n<93> if (ret < 0) {\n<94> \n<95> av_log(NULL, AV_LOG_FATAL,\n<96> \n<97> "Error initializing the output stream codec context.\n");\n<98> \n<99> exit_program(1);\n<100> \n<101> }\n<102> \n<103> \n<104> \n<105> if (ost->enc_ctx->nb_coded_side_data) {\n<106> \n<107> int i;\n<108> \n<109> \n<110> \n<111> ost->st->side_data = av_realloc_array(NULL, ost->enc_ctx->nb_coded_side_data,\n<112> \n<113> sizeof(*ost->st->side_data));\n<114> \n<115> if (!ost->st->side_data)\n<116> \n<117> return AVERROR(ENOMEM);\n<118> \n<119> \n<120> \n<121> for (i = 0; i < ost->enc_ctx->nb_coded_side_data; i++) {\n<122> \n<123> const AVPacketSideData *sd_src = &ost->enc_ctx->coded_side_data[i];\n<124> \n<125> AVPacketSideData *sd_dst = &ost->st->side_data[i];\n<126> \n<127> \n<128> \n<129> sd_dst->data = av_malloc(sd_src->size);\n<130> \n<131> if (!sd_dst->data)\n<132> \n<133> return AVERROR(ENOMEM);\n<134> \n<135> memcpy(sd_dst->data, sd_src->data, sd_src->size);\n<136> \n<137> sd_dst->size = sd_src->size;\n<138> \n<139> sd_dst->type = sd_src->type;\n<140> \n<141> ost->st->nb_side_data++;\n<142> \n<143> }\n<144> \n<145> }\n<146> \n<147> \n<148> \n<149> ost->st->time_base = ost->enc_ctx->time_base;\n<150> \n<151> } else if (ost->stream_copy) {\n<152> \n<153> ret = init_output_stream_streamcopy(ost);\n<154> \n<155> if (ret < 0)\n<156> \n<157> return ret;\n<158> \n<159> \n<160> \n<161> /*\n<162> \n<163> * FIXME: will the codec context used by the parser during streamcopy\n<164> \n<165> * This should go away with the new parser API.\n<166> \n<167> */\n<168> \n<169> ret = avcodec_parameters_to_context(ost->parser_avctx, ost->st->codecpar);\n<170> \n<171> if (ret < 0)\n<172> \n<173> return ret;\n<174> \n<175> }\n<176> \n<177> \n<178> \n<179> /* initialize bitstream filters for the output stream\n<180> \n<181> * needs to be done here, because the codec id for streamcopy is not\n<182> \n<183> * known until now */\n<184> \n<185> ret = init_output_bsfs(ost);\n<186> \n<187> if (ret < 0)\n<188> \n<189> return ret;\n<190> \n<191> \n<192> \n<193> ost->mux_timebase = ost->st->time_base;\n<194> \n<195> \n<196> \n<197> ost->initialized = 1;\n<198> \n<199> \n<200> \n<201> ret = check_init_output_file(output_files[ost->file_index], ost->file_index);\n<202> \n<203> if (ret < 0)\n<204> \n<205> return ret;\n<206> \n<207> \n<208> \n<209> return ret;\n<210> \n<211> }\n<212> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> gcry_error_t gcry_mpi_print ( enum gcry_mpi_format format , unsigned char * buffer , size_t buflen , size_t * nwritten , struct gcry_mpi * a ) {\n<2> unsigned int nbits = mpi_get_nbits ( a ) ;\n<3> size_t len ;\n<4> size_t dummy_nwritten ;\n<5> int negative ;\n<6> if ( ! nwritten ) nwritten = & dummy_nwritten ;\n<7> if ( a -> sign && _gcry_mpi_cmp_ui ( a , 0 ) ) negative = 1 ;\n<8> else negative = 0 ;\n<9> len = buflen ;\n<10> * nwritten = 0 ;\n<11> if ( format == GCRYMPI_FMT_STD ) {\n<12> unsigned char * tmp ;\n<13> int extra = 0 ;\n<14> unsigned int n ;\n<15> if ( negative ) return gcry_error ( GPG_ERR_INTERNAL ) ;\n<16> tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n<17> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<18> if ( n && ( * tmp & 0x80 ) ) {\n<19> n ++ ;\n<20> extra = 1 ;\n<21> }\n<22> if ( buffer && n > len ) {\n<23> gcry_free ( tmp ) ;\n<24> return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n<25> }\n<26> if ( buffer ) {\n<27> unsigned char * s = buffer ;\n<28> if ( extra ) * s ++ = 0 ;\n<29> memcpy ( s , tmp , n - extra ) ;\n<30> }\n<31> gcry_free ( tmp ) ;\n<32> * nwritten = n ;\n<33> return 0 ;\n<34> }\n<35> else if ( format == GCRYMPI_FMT_USG ) {\n<36> unsigned int n = ( nbits + 7 ) / 8 ;\n<37> if ( buffer && n > len ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n<38> if ( buffer ) {\n<39> unsigned char * tmp ;\n<40> tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n<41> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<42> memcpy ( buffer , tmp , n ) ;\n<43> gcry_free ( tmp ) ;\n<44> }\n<45> * nwritten = n ;\n<46> return 0 ;\n<47> }\n<48> else if ( format == GCRYMPI_FMT_PGP ) {\n<49> unsigned int n = ( nbits + 7 ) / 8 ;\n<50> if ( negative ) return gcry_error ( GPG_ERR_INV_ARG ) ;\n<51> if ( buffer && n + 2 > len ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n<52> if ( buffer ) {\n<53> unsigned char * tmp ;\n<54> unsigned char * s = buffer ;\n<55> s [ 0 ] = nbits >> 8 ;\n<56> s [ 1 ] = nbits ;\n<57> tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n<58> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<59> memcpy ( s + 2 , tmp , n ) ;\n<60> gcry_free ( tmp ) ;\n<61> }\n<62> * nwritten = n + 2 ;\n<63> return 0 ;\n<64> }\n<65> else if ( format == GCRYMPI_FMT_SSH ) {\n<66> unsigned char * tmp ;\n<67> int extra = 0 ;\n<68> unsigned int n ;\n<69> if ( negative ) return gcry_error ( GPG_ERR_INTERNAL ) ;\n<70> tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n<71> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<72> if ( n && ( * tmp & 0x80 ) ) {\n<73> n ++ ;\n<74> extra = 1 ;\n<75> }\n<76> if ( buffer && n + 4 > len ) {\n<77> gcry_free ( tmp ) ;\n<78> return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n<79> }\n<80> if ( buffer ) {\n<81> unsigned char * s = buffer ;\n<82> * s ++ = n >> 24 ;\n<83> * s ++ = n >> 16 ;\n<84> * s ++ = n >> 8 ;\n<85> * s ++ = n ;\n<86> if ( extra ) * s ++ = 0 ;\n<87> memcpy ( s , tmp , n - extra ) ;\n<88> }\n<89> gcry_free ( tmp ) ;\n<90> * nwritten = 4 + n ;\n<91> return 0 ;\n<92> }\n<93> else if ( format == GCRYMPI_FMT_HEX ) {\n<94> unsigned char * tmp ;\n<95> int i ;\n<96> int extra = 0 ;\n<97> unsigned int n = 0 ;\n<98> tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n<99> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<100> if ( ! n || ( * tmp & 0x80 ) ) extra = 2 ;\n<101> if ( buffer && 2 * n + extra + negative + 1 > len ) {\n<102> gcry_free ( tmp ) ;\n<103> return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n<104> }\n<105> if ( buffer ) {\n<106> unsigned char * s = buffer ;\n<107> if ( negative ) * s ++ = '-' ;\n<108> if ( extra ) {\n<109> * s ++ = '0' ;\n<110> * s ++ = '0' ;\n<111> }\n<112> for ( i = 0 ;\n<113> i < n ;\n<114> i ++ ) {\n<115> unsigned int c = tmp [ i ] ;\n<116> * s ++ = ( c >> 4 ) < 10 ? '0' + ( c >> 4 ) : 'A' + ( c >> 4 ) - 10 ;\n<117> c &= 15 ;\n<118> * s ++ = c < 10 ? '0' + c : 'A' + c - 10 ;\n<119> }\n<120> * s ++ = 0 ;\n<121> * nwritten = s - buffer ;\n<122> }\n<123> else {\n<124> * nwritten = 2 * n + extra + negative + 1 ;\n<125> }\n<126> gcry_free ( tmp ) ;\n<127> return 0 ;\n<128> }\n<129> else return gcry_error ( GPG_ERR_INV_ARG ) ;\n<130> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n<2> \n<3> int y, int w, int h)\n<4> \n<5> {\n<6> \n<7> int i, j;\n<8> \n<9> int has_fg, has_bg;\n<10> \n<11> uint8_t *last_fg, *last_bg;\n<12> \n<13> VncDisplay *vd = vs->vd;\n<14> \n<15> \n<16> \n<17> last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n<18> \n<19> last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n<20> \n<21> has_fg = has_bg = 0;\n<22> \n<23> for (j = y; j < (y + h); j += 16) {\n<24> \n<25> for (i = x; i < (x + w); i += 16) {\n<26> \n<27> vs->send_hextile_tile(vs, i, j,\n<28> \n<29> MIN(16, x + w - i), MIN(16, y + h - j),\n<30> \n<31> last_bg, last_fg, &has_bg, &has_fg);\n<32> \n<33> }\n<34> \n<35> }\n<36> \n<37> free(last_fg);\n<38> \n<39> free(last_bg);\n<40> \n<41> \n<42> \n<43> return 1;\n<44> \n<45> }\n<46> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void cpu_loop(CPUSH4State *env)\n<2> \n<3> {\n<4> \n<5> CPUState *cs = CPU(sh_env_get_cpu(env));\n<6> \n<7> int trapnr, ret;\n<8> \n<9> target_siginfo_t info;\n<10> \n<11> \n<12> \n<13> while (1) {\n<14> \n<15> cpu_exec_start(cs);\n<16> \n<17> trapnr = cpu_sh4_exec(cs);\n<18> \n<19> cpu_exec_end(cs);\n<20> \n<21> \n<22> \n<23> switch (trapnr) {\n<24> \n<25> case 0x160:\n<26> \n<27> env->pc += 2;\n<28> \n<29> ret = do_syscall(env,\n<30> \n<31> env->gregs[3],\n<32> \n<33> env->gregs[4],\n<34> \n<35> env->gregs[5],\n<36> \n<37> env->gregs[6],\n<38> \n<39> env->gregs[7],\n<40> \n<41> env->gregs[0],\n<42> \n<43> env->gregs[1],\n<44> \n<45> 0, 0);\n<46> \n<47> env->gregs[0] = ret;\n<48> \n<49> break;\n<50> \n<51> case EXCP_INTERRUPT:\n<52> \n<53> /* just indicate that signals should be handled asap */\n<54> \n<55> break;\n<56> \n<57> case EXCP_DEBUG:\n<58> \n<59> {\n<60> \n<61> int sig;\n<62> \n<63> \n<64> \n<65> sig = gdb_handlesig(cs, TARGET_SIGTRAP);\n<66> \n<67> if (sig)\n<68> \n<69> {\n<70> \n<71> info.si_signo = sig;\n<72> \n<73> info.si_errno = 0;\n<74> \n<75> info.si_code = TARGET_TRAP_BRKPT;\n<76> \n<77> queue_signal(env, info.si_signo, &info);\n<78> \n<79> }\n<80> \n<81> }\n<82> \n<83> break;\n<84> \n<85> case 0xa0:\n<86> \n<87> case 0xc0:\n<88> \n<89> info.si_signo = TARGET_SIGSEGV;\n<90> \n<91> info.si_errno = 0;\n<92> \n<93> info.si_code = TARGET_SEGV_MAPERR;\n<94> \n<95> info._sifields._sigfault._addr = env->tea;\n<96> \n<97> queue_signal(env, info.si_signo, &info);\n<98> \n<99> break;\n<100> \n<101> \n<102> \n<103> default:\n<104> \n<105> printf ("Unhandled trap: 0x%x\n", trapnr);\n<106> \n<107> cpu_dump_state(cs, stderr, fprintf, 0);\n<108> \n<109> exit(EXIT_FAILURE);\n<110> \n<111> }\n<112> \n<113> process_pending_signals (env);\n<114> \n<115> }\n<116> \n<117> }\n<118> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int rv34_decode_mv ( RV34DecContext * r , int block_type ) {\n<2> MpegEncContext * s = & r -> s ;\n<3> GetBitContext * gb = & s -> gb ;\n<4> int i , j , k , l ;\n<5> int mv_pos = s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ;\n<6> int next_bt ;\n<7> memset ( r -> dmv , 0 , sizeof ( r -> dmv ) ) ;\n<8> for ( i = 0 ;\n<9> i < num_mvs [ block_type ] ;\n<10> i ++ ) {\n<11> r -> dmv [ i ] [ 0 ] = svq3_get_se_golomb ( gb ) ;\n<12> r -> dmv [ i ] [ 1 ] = svq3_get_se_golomb ( gb ) ;\n<13> }\n<14> switch ( block_type ) {\n<15> case RV34_MB_TYPE_INTRA : case RV34_MB_TYPE_INTRA16x16 : ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n<16> return 0 ;\n<17> case RV34_MB_SKIP : if ( s -> pict_type == AV_PICTURE_TYPE_P ) {\n<18> ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n<19> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n<20> break ;\n<21> }\n<22> case RV34_MB_B_DIRECT : if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) ff_thread_await_progress ( & s -> next_picture_ptr -> f , FFMAX ( 0 , s -> mb_y - 1 ) , 0 ) ;\n<23> next_bt = s -> next_picture_ptr -> f . mb_type [ s -> mb_x + s -> mb_y * s -> mb_stride ] ;\n<24> if ( IS_INTRA ( next_bt ) || IS_SKIP ( next_bt ) ) {\n<25> ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n<26> ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 1 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n<27> }\n<28> else for ( j = 0 ;\n<29> j < 2 ;\n<30> j ++ ) for ( i = 0 ;\n<31> i < 2 ;\n<32> i ++ ) for ( k = 0 ;\n<33> k < 2 ;\n<34> k ++ ) for ( l = 0 ;\n<35> l < 2 ;\n<36> l ++ ) s -> current_picture_ptr -> f . motion_val [ l ] [ mv_pos + i + j * s -> b8_stride ] [ k ] = calc_add_mv ( r , l , s -> next_picture_ptr -> f . motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ k ] ) ;\n<37> if ( ! ( IS_16X8 ( next_bt ) || IS_8X16 ( next_bt ) || IS_8X8 ( next_bt ) ) ) rv34_mc_2mv ( r , block_type ) ;\n<38> else rv34_mc_2mv_skip ( r ) ;\n<39> ZERO8x2 ( s -> current_picture_ptr -> f . motion_val [ 0 ] [ s -> mb_x * 2 + s -> mb_y * 2 * s -> b8_stride ] , s -> b8_stride ) ;\n<40> break ;\n<41> case RV34_MB_P_16x16 : case RV34_MB_P_MIX16x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n<42> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n<43> break ;\n<44> case RV34_MB_B_FORWARD : case RV34_MB_B_BACKWARD : r -> dmv [ 1 ] [ 0 ] = r -> dmv [ 0 ] [ 0 ] ;\n<45> r -> dmv [ 1 ] [ 1 ] = r -> dmv [ 0 ] [ 1 ] ;\n<46> if ( r -> rv30 ) rv34_pred_mv_rv3 ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n<47> else rv34_pred_mv_b ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n<48> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , block_type == RV34_MB_B_BACKWARD ) ;\n<49> break ;\n<50> case RV34_MB_P_16x8 : case RV34_MB_P_8x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n<51> rv34_pred_mv ( r , block_type , 1 + ( block_type == RV34_MB_P_16x8 ) , 1 ) ;\n<52> if ( block_type == RV34_MB_P_16x8 ) {\n<53> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 1 , 0 ) ;\n<54> rv34_mc_1mv ( r , block_type , 0 , 8 , s -> b8_stride , 2 , 1 , 0 ) ;\n<55> }\n<56> if ( block_type == RV34_MB_P_8x16 ) {\n<57> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 1 , 2 , 0 ) ;\n<58> rv34_mc_1mv ( r , block_type , 8 , 0 , 1 , 1 , 2 , 0 ) ;\n<59> }\n<60> break ;\n<61> case RV34_MB_B_BIDIR : rv34_pred_mv_b ( r , block_type , 0 ) ;\n<62> rv34_pred_mv_b ( r , block_type , 1 ) ;\n<63> rv34_mc_2mv ( r , block_type ) ;\n<64> break ;\n<65> case RV34_MB_P_8x8 : for ( i = 0 ;\n<66> i < 4 ;\n<67> i ++ ) {\n<68> rv34_pred_mv ( r , block_type , i , i ) ;\n<69> rv34_mc_1mv ( r , block_type , ( i & 1 ) << 3 , ( i & 2 ) << 2 , ( i & 1 ) + ( i >> 1 ) * s -> b8_stride , 1 , 1 , 0 ) ;\n<70> }\n<71> break ;\n<72> }\n<73> return 0 ;\n<74> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void logerr (struct audio_pt *pt, int err, const char *fmt, ...)\n<2> \n<3> {\n<4> \n<5> va_list ap;\n<6> \n<7> \n<8> \n<9> va_start (ap, fmt);\n<10> \n<11> AUD_vlog (pt->drv, fmt, ap);\n<12> \n<13> va_end (ap);\n<14> \n<15> \n<16> \n<17> AUD_log (NULL, "\n");\n<18> \n<19> AUD_log (pt->drv, "Reason: %s\n", strerror (err));\n<20> \n<21> }\n<22> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void ff_er_add_slice(ERContext *s, int startx, int starty,\n<2> \n<3> int endx, int endy, int status)\n<4> \n<5> {\n<6> \n<7> const int start_i  = av_clip(startx + starty * s->mb_width, 0, s->mb_num - 1);\n<8> \n<9> const int end_i    = av_clip(endx   + endy   * s->mb_width, 0, s->mb_num);\n<10> \n<11> const int start_xy = s->mb_index2xy[start_i];\n<12> \n<13> const int end_xy   = s->mb_index2xy[end_i];\n<14> \n<15> int mask           = -1;\n<16> \n<17> \n<18> \n<19> if (s->avctx->hwaccel)\n<20> \n<21> return;\n<22> \n<23> \n<24> \n<25> if (start_i > end_i || start_xy > end_xy) {\n<26> \n<27> av_log(s->avctx, AV_LOG_ERROR,\n<28> \n<29> "internal error, slice end before start\n");\n<30> \n<31> return;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> if (!s->avctx->err_recognition)\n<38> \n<39> return;\n<40> \n<41> \n<42> \n<43> mask &= ~VP_START;\n<44> \n<45> if (status & (ER_AC_ERROR | ER_AC_END)) {\n<46> \n<47> mask           &= ~(ER_AC_ERROR | ER_AC_END);\n<48> \n<49> s->error_count -= end_i - start_i + 1;\n<50> \n<51> }\n<52> \n<53> if (status & (ER_DC_ERROR | ER_DC_END)) {\n<54> \n<55> mask           &= ~(ER_DC_ERROR | ER_DC_END);\n<56> \n<57> s->error_count -= end_i - start_i + 1;\n<58> \n<59> }\n<60> \n<61> if (status & (ER_MV_ERROR | ER_MV_END)) {\n<62> \n<63> mask           &= ~(ER_MV_ERROR | ER_MV_END);\n<64> \n<65> s->error_count -= end_i - start_i + 1;\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> if (status & ER_MB_ERROR) {\n<72> \n<73> s->error_occurred = 1;\n<74> \n<75> s->error_count    = INT_MAX;\n<76> \n<77> }\n<78> \n<79> \n<80> \n<81> if (mask == ~0x7F) {\n<82> \n<83> memset(&s->error_status_table[start_xy], 0,\n<84> \n<85> (end_xy - start_xy) * sizeof(uint8_t));\n<86> \n<87> } else {\n<88> \n<89> int i;\n<90> \n<91> for (i = start_xy; i < end_xy; i++)\n<92> \n<93> s->error_status_table[i] &= mask;\n<94> \n<95> }\n<96> \n<97> \n<98> \n<99> if (end_i == s->mb_num)\n<100> \n<101> s->error_count = INT_MAX;\n<102> \n<103> else {\n<104> \n<105> s->error_status_table[end_xy] &= mask;\n<106> \n<107> s->error_status_table[end_xy] |= status;\n<108> \n<109> }\n<110> \n<111> \n<112> \n<113> s->error_status_table[start_xy] |= VP_START;\n<114> \n<115> \n<116> \n<117> if (start_xy > 0 && !(s->avctx->active_thread_type & FF_THREAD_SLICE) &&\n<118> \n<119> s->avctx->skip_top * s->mb_width < start_i) {\n<120> \n<121> int prev_status = s->error_status_table[s->mb_index2xy[start_i - 1]];\n<122> \n<123> \n<124> \n<125> prev_status &= ~ VP_START;\n<126> \n<127> if (prev_status != (ER_MV_END | ER_DC_END | ER_AC_END)) {\n<128> \n<129> s->error_occurred = 1;\n<130> \n<131> s->error_count = INT_MAX;\n<132> \n<133> }\n<134> \n<135> }\n<136> \n<137> }\n<138> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int qemu_rdma_drain_cq(QEMUFile *f, RDMAContext *rdma)\n<2> \n<3> {\n<4> \n<5> int ret;\n<6> \n<7> \n<8> \n<9> if (qemu_rdma_write_flush(f, rdma) < 0) {\n<10> \n<11> return -EIO;\n<12> \n<13> }\n<14> \n<15> \n<16> \n<17> while (rdma->nb_sent) {\n<18> \n<19> ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_RDMA_WRITE);\n<20> \n<21> if (ret < 0) {\n<22> \n<23> fprintf(stderr, "rdma migration: complete polling error!\n");\n<24> \n<25> return -EIO;\n<26> \n<27> }\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> qemu_rdma_unregister_waiting(rdma);\n<34> \n<35> \n<36> \n<37> return 0;\n<38> \n<39> }\n<40> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void sm501_draw_crt(SM501State *s)\n<2> \n<3> {\n<4> \n<5> DisplaySurface *surface = qemu_console_surface(s->con);\n<6> \n<7> int y, c_x = 0, c_y = 0;\n<8> \n<9> uint8_t *hwc_src = NULL, *src = s->local_mem;\n<10> \n<11> int width = get_width(s, 1);\n<12> \n<13> int height = get_height(s, 1);\n<14> \n<15> int src_bpp = get_bpp(s, 1);\n<16> \n<17> int dst_bpp = surface_bytes_per_pixel(surface);\n<18> \n<19> uint32_t *palette = (uint32_t *)&s->dc_palette[SM501_DC_CRT_PALETTE -\n<20> \n<21> SM501_DC_PANEL_PALETTE];\n<22> \n<23> uint8_t hwc_palette[3 * 3];\n<24> \n<25> int ds_depth_index = get_depth_index(surface);\n<26> \n<27> draw_line_func *draw_line = NULL;\n<28> \n<29> draw_hwc_line_func *draw_hwc_line = NULL;\n<30> \n<31> int full_update = 0;\n<32> \n<33> int y_start = -1;\n<34> \n<35> ram_addr_t page_min = ~0l;\n<36> \n<37> ram_addr_t page_max = 0l;\n<38> \n<39> ram_addr_t offset = 0;\n<40> \n<41> \n<42> \n<43> /* choose draw_line function */\n<44> \n<45> switch (src_bpp) {\n<46> \n<47> case 1:\n<48> \n<49> draw_line = draw_line8_funcs[ds_depth_index];\n<50> \n<51> break;\n<52> \n<53> case 2:\n<54> \n<55> draw_line = draw_line16_funcs[ds_depth_index];\n<56> \n<57> break;\n<58> \n<59> case 4:\n<60> \n<61> draw_line = draw_line32_funcs[ds_depth_index];\n<62> \n<63> break;\n<64> \n<65> default:\n<66> \n<67> printf("sm501 draw crt : invalid DC_CRT_CONTROL=%x.\n",\n<68> \n<69> s->dc_crt_control);\n<70> \n<71> abort();\n<72> \n<73> break;\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> /* set up to draw hardware cursor */\n<80> \n<81> if (is_hwc_enabled(s, 1)) {\n<82> \n<83> /* choose cursor draw line function */\n<84> \n<85> draw_hwc_line = draw_hwc_line_funcs[ds_depth_index];\n<86> \n<87> hwc_src = get_hwc_address(s, 1);\n<88> \n<89> c_x = get_hwc_x(s, 1);\n<90> \n<91> c_y = get_hwc_y(s, 1);\n<92> \n<93> get_hwc_palette(s, 1, hwc_palette);\n<94> \n<95> }\n<96> \n<97> \n<98> \n<99> /* adjust console size */\n<100> \n<101> if (s->last_width != width || s->last_height != height) {\n<102> \n<103> qemu_console_resize(s->con, width, height);\n<104> \n<105> surface = qemu_console_surface(s->con);\n<106> \n<107> s->last_width = width;\n<108> \n<109> s->last_height = height;\n<110> \n<111> full_update = 1;\n<112> \n<113> }\n<114> \n<115> \n<116> \n<117> /* draw each line according to conditions */\n<118> \n<119> memory_region_sync_dirty_bitmap(&s->local_mem_region);\n<120> \n<121> for (y = 0; y < height; y++) {\n<122> \n<123> int update, update_hwc;\n<124> \n<125> ram_addr_t page0 = offset;\n<126> \n<127> ram_addr_t page1 = offset + width * src_bpp - 1;\n<128> \n<129> \n<130> \n<131> /* check if hardware cursor is enabled and we're within its range */\n<132> \n<133> update_hwc = draw_hwc_line && c_y <= y && y < c_y + SM501_HWC_HEIGHT;\n<134> \n<135> update = full_update || update_hwc;\n<136> \n<137> /* check dirty flags for each line */\n<138> \n<139> update |= memory_region_get_dirty(&s->local_mem_region, page0,\n<140> \n<141> page1 - page0, DIRTY_MEMORY_VGA);\n<142> \n<143> \n<144> \n<145> /* draw line and change status */\n<146> \n<147> if (update) {\n<148> \n<149> uint8_t *d = surface_data(surface);\n<150> \n<151> d +=  y * width * dst_bpp;\n<152> \n<153> \n<154> \n<155> /* draw graphics layer */\n<156> \n<157> draw_line(d, src, width, palette);\n<158> \n<159> \n<160> \n<161> /* draw hardware cursor */\n<162> \n<163> if (update_hwc) {\n<164> \n<165> draw_hwc_line(d, hwc_src, width, hwc_palette, c_x, y - c_y);\n<166> \n<167> }\n<168> \n<169> \n<170> \n<171> if (y_start < 0) {\n<172> \n<173> y_start = y;\n<174> \n<175> }\n<176> \n<177> if (page0 < page_min) {\n<178> \n<179> page_min = page0;\n<180> \n<181> }\n<182> \n<183> if (page1 > page_max) {\n<184> \n<185> page_max = page1;\n<186> \n<187> }\n<188> \n<189> } else {\n<190> \n<191> if (y_start >= 0) {\n<192> \n<193> /* flush to display */\n<194> \n<195> dpy_gfx_update(s->con, 0, y_start, width, y - y_start);\n<196> \n<197> y_start = -1;\n<198> \n<199> }\n<200> \n<201> }\n<202> \n<203> \n<204> \n<205> src += width * src_bpp;\n<206> \n<207> offset += width * src_bpp;\n<208> \n<209> }\n<210> \n<211> \n<212> \n<213> /* complete flush to display */\n<214> \n<215> if (y_start >= 0) {\n<216> \n<217> dpy_gfx_update(s->con, 0, y_start, width, y - y_start);\n<218> \n<219> }\n<220> \n<221> \n<222> \n<223> /* clear dirty flags */\n<224> \n<225> if (page_min != ~0l) {\n<226> \n<227> memory_region_reset_dirty(&s->local_mem_region,\n<228> \n<229> page_min, page_max + TARGET_PAGE_SIZE,\n<230> \n<231> DIRTY_MEMORY_VGA);\n<232> \n<233> }\n<234> \n<235> }\n<236> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void object_property_add(Object *obj, const char *name, const char *type,\n<2> \n<3> ObjectPropertyAccessor *get,\n<4> \n<5> ObjectPropertyAccessor *set,\n<6> \n<7> ObjectPropertyRelease *release,\n<8> \n<9> void *opaque, Error **errp)\n<10> \n<11> {\n<12> \n<13> ObjectProperty *prop;\n<14> \n<15> \n<16> \n<17> QTAILQ_FOREACH(prop, &obj->properties, node) {\n<18> \n<19> if (strcmp(prop->name, name) == 0) {\n<20> \n<21> error_setg(errp, "attempt to add duplicate property '%s'"\n<22> \n<23> " to object (type '%s')", name,\n<24> \n<25> object_get_typename(obj));\n<26> \n<27> return;\n<28> \n<29> }\n<30> \n<31> }\n<32> \n<33> \n<34> \n<35> prop = g_malloc0(sizeof(*prop));\n<36> \n<37> \n<38> \n<39> prop->name = g_strdup(name);\n<40> \n<41> prop->type = g_strdup(type);\n<42> \n<43> \n<44> \n<45> prop->get = get;\n<46> \n<47> prop->set = set;\n<48> \n<49> prop->release = release;\n<50> \n<51> prop->opaque = opaque;\n<52> \n<53> \n<54> \n<55> QTAILQ_INSERT_TAIL(&obj->properties, prop, node);\n<56> \n<57> }\n<58> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void omap_prcm_apll_update(struct omap_prcm_s *s)\n<2> \n<3> {\n<4> \n<5> int mode[2];\n<6> \n<7> \n<8> \n<9> mode[0] = (s->clken[9] >> 6) & 3;\n<10> \n<11> s->apll_lock[0] = (mode[0] == 3);\n<12> \n<13> mode[1] = (s->clken[9] >> 2) & 3;\n<14> \n<15> s->apll_lock[1] = (mode[1] == 3);\n<16> \n<17> /* TODO: update clocks */\n<18> \n<19> \n<20> \n<21> if (mode[0] == 1 || mode[0] == 2 || mode[1] == 1 || mode[1] == 2)\n<22> \n<23> fprintf(stderr, "%s: bad EN_54M_PLL or bad EN_96M_PLL\n",\n<24> \n<25> __FUNCTION__);\n<26> \n<27> }\n<28> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void init_dequant8_coeff_table(H264Context *h){\n<2> \n<3> int i,q,x;\n<4> \n<5> const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly\n<6> \n<7> h->dequant8_coeff[0] = h->dequant8_buffer[0];\n<8> \n<9> h->dequant8_coeff[1] = h->dequant8_buffer[1];\n<10> \n<11> \n<12> \n<13> for(i=0; i<2; i++ ){\n<14> \n<15> if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){\n<16> \n<17> h->dequant8_coeff[1] = h->dequant8_buffer[0];\n<18> \n<19> break;\n<20> \n<21> }\n<22> \n<23> \n<24> \n<25> for(q=0; q<52; q++){\n<26> \n<27> int shift = div6[q];\n<28> \n<29> int idx = rem6[q];\n<30> \n<31> for(x=0; x<64; x++)\n<32> \n<33> h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =\n<34> \n<35> ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *\n<36> \n<37> h->pps.scaling_matrix8[i][x]) << shift;\n<38> \n<39> }\n<40> \n<41> }\n<42> \n<43> }\n<44> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> rdt_parse_sdp_line (AVFormatContext *s, int st_index,\n<2> \n<3> PayloadContext *rdt, const char *line)\n<4> \n<5> {\n<6> \n<7> AVStream *stream = s->streams[st_index];\n<8> \n<9> const char *p = line;\n<10> \n<11> \n<12> \n<13> if (av_strstart(p, "OpaqueData:buffer;", &p)) {\n<14> \n<15> rdt->mlti_data = rdt_parse_b64buf(&rdt->mlti_data_size, p);\n<16> \n<17> } else if (av_strstart(p, "StartTime:integer;", &p))\n<18> \n<19> stream->first_dts = atoi(p);\n<20> \n<21> else if (av_strstart(p, "ASMRuleBook:string;", &p)) {\n<22> \n<23> int n, first = -1;\n<24> \n<25> \n<26> \n<27> for (n = 0; n < s->nb_streams; n++)\n<28> \n<29> if (s->streams[n]->id == stream->id) {\n<30> \n<31> int count = s->streams[n]->index + 1;\n<32> \n<33> if (first == -1) first = n;\n<34> \n<35> if (rdt->nb_rmst < count) {\n<36> \n<37> RMStream **rmst= av_realloc(rdt->rmst, count*sizeof(*rmst));\n<38> \n<39> if (!rmst)\n<40> \n<41> return AVERROR(ENOMEM);\n<42> \n<43> memset(rmst + rdt->nb_rmst, 0,\n<44> \n<45> (count - rdt->nb_rmst) * sizeof(*rmst));\n<46> \n<47> rdt->rmst    = rmst;\n<48> \n<49> rdt->nb_rmst = count;\n<50> \n<51> }\n<52> \n<53> rdt->rmst[s->streams[n]->index] = ff_rm_alloc_rmstream();\n<54> \n<55> rdt_load_mdpr(rdt, s->streams[n], (n - first) * 2);\n<56> \n<57> \n<58> \n<59> if (s->streams[n]->codec->codec_id == CODEC_ID_AAC)\n<60> \n<61> s->streams[n]->codec->frame_size = 1; // FIXME\n<62> \n<63> }\n<64> \n<65> }\n<66> \n<67> \n<68> \n<69> return 0;\n<70> \n<71> }\n<72> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int qio_dns_resolver_lookup_sync_inet(QIODNSResolver *resolver,\n<2> \n<3> SocketAddress *addr,\n<4> \n<5> size_t *naddrs,\n<6> \n<7> SocketAddress ***addrs,\n<8> \n<9> Error **errp)\n<10> \n<11> {\n<12> \n<13> struct addrinfo ai, *res, *e;\n<14> \n<15> InetSocketAddress *iaddr = addr->u.inet.data;\n<16> \n<17> char port[33];\n<18> \n<19> char uaddr[INET6_ADDRSTRLEN + 1];\n<20> \n<21> char uport[33];\n<22> \n<23> int rc;\n<24> \n<25> Error *err = NULL;\n<26> \n<27> size_t i;\n<28> \n<29> \n<30> \n<31> *naddrs = 0;\n<32> \n<33> *addrs = NULL;\n<34> \n<35> \n<36> \n<37> memset(&ai, 0, sizeof(ai));\n<38> \n<39> ai.ai_flags = AI_PASSIVE;\n<40> \n<41> if (iaddr->has_numeric && iaddr->numeric) {\n<42> \n<43> ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n<44> \n<45> }\n<46> \n<47> ai.ai_family = inet_ai_family_from_address(iaddr, &err);\n<48> \n<49> ai.ai_socktype = SOCK_STREAM;\n<50> \n<51> \n<52> \n<53> if (err) {\n<54> \n<55> error_propagate(errp, err);\n<56> \n<57> return -1;\n<58> \n<59> }\n<60> \n<61> \n<62> \n<63> if (iaddr->host == NULL) {\n<64> \n<65> error_setg(errp, "host not specified");\n<66> \n<67> return -1;\n<68> \n<69> }\n<70> \n<71> if (iaddr->port != NULL) {\n<72> \n<73> pstrcpy(port, sizeof(port), iaddr->port);\n<74> \n<75> } else {\n<76> \n<77> port[0] = '\0';\n<78> \n<79> }\n<80> \n<81> \n<82> \n<83> rc = getaddrinfo(strlen(iaddr->host) ? iaddr->host : NULL,\n<84> \n<85> strlen(port) ? port : NULL, &ai, &res);\n<86> \n<87> if (rc != 0) {\n<88> \n<89> error_setg(errp, "address resolution failed for %s:%s: %s",\n<90> \n<91> iaddr->host, port, gai_strerror(rc));\n<92> \n<93> return -1;\n<94> \n<95> }\n<96> \n<97> \n<98> \n<99> for (e = res; e != NULL; e = e->ai_next) {\n<100> \n<101> (*naddrs)++;\n<102> \n<103> }\n<104> \n<105> \n<106> \n<107> *addrs = g_new0(SocketAddress *, *naddrs);\n<108> \n<109> \n<110> \n<111> /* create socket + bind */\n<112> \n<113> for (i = 0, e = res; e != NULL; i++, e = e->ai_next) {\n<114> \n<115> SocketAddress *newaddr = g_new0(SocketAddress, 1);\n<116> \n<117> InetSocketAddress *newiaddr = g_new0(InetSocketAddress, 1);\n<118> \n<119> newaddr->u.inet.data = newiaddr;\n<120> \n<121> newaddr->type = SOCKET_ADDRESS_KIND_INET;\n<122> \n<123> \n<124> \n<125> getnameinfo((struct sockaddr *)e->ai_addr, e->ai_addrlen,\n<126> \n<127> uaddr, INET6_ADDRSTRLEN, uport, 32,\n<128> \n<129> NI_NUMERICHOST | NI_NUMERICSERV);\n<130> \n<131> \n<132> \n<133> *newiaddr = (InetSocketAddress){\n<134> \n<135> .host = g_strdup(uaddr),\n<136> \n<137> .port = g_strdup(uport),\n<138> \n<139> .has_numeric = true,\n<140> \n<141> .numeric = true,\n<142> \n<143> .has_to = iaddr->has_to,\n<144> \n<145> .to = iaddr->to,\n<146> \n<147> .has_ipv4 = false,\n<148> \n<149> .has_ipv6 = false,\n<150> \n<151> };\n<152> \n<153> \n<154> \n<155> (*addrs)[i] = newaddr;\n<156> \n<157> }\n<158> \n<159> freeaddrinfo(res);\n<160> \n<161> return 0;\n<162> \n<163> }\n<164> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline void mix_3f_2r_to_stereo(AC3DecodeContext *ctx)\n<2> \n<3> {\n<4> \n<5> int i;\n<6> \n<7> float (*output)[256] = ctx->audio_block.block_output;\n<8> \n<9> \n<10> \n<11> for (i = 0; i < 256; i++) {\n<12> \n<13> output[1][i] += (output[2][i] + output[4][i]);\n<14> \n<15> output[2][i] += (output[3][i] + output[5][i]);\n<16> \n<17> }\n<18> \n<19> memset(output[3], 0, sizeof(output[3]));\n<20> \n<21> memset(output[4], 0, sizeof(output[4]));\n<22> \n<23> memset(output[5], 0, sizeof(output[5]));\n<24> \n<25> }\n<26> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ehci_init_transfer(EHCIQueue *q)\n<2> \n<3> {\n<4> \n<5> uint32_t cpage, offset, bytes, plen;\n<6> \n<7> target_phys_addr_t page;\n<8> \n<9> \n<10> \n<11> cpage  = get_field(q->qh.token, QTD_TOKEN_CPAGE);\n<12> \n<13> bytes  = get_field(q->qh.token, QTD_TOKEN_TBYTES);\n<14> \n<15> offset = q->qh.bufptr[0] & ~QTD_BUFPTR_MASK;\n<16> \n<17> qemu_sglist_init(&q->sgl, 5);\n<18> \n<19> \n<20> \n<21> while (bytes > 0) {\n<22> \n<23> if (cpage > 4) {\n<24> \n<25> fprintf(stderr, "cpage out of range (%d)\n", cpage);\n<26> \n<27> return USB_RET_PROCERR;\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> page  = q->qh.bufptr[cpage] & QTD_BUFPTR_MASK;\n<34> \n<35> page += offset;\n<36> \n<37> plen  = bytes;\n<38> \n<39> if (plen > 4096 - offset) {\n<40> \n<41> plen = 4096 - offset;\n<42> \n<43> offset = 0;\n<44> \n<45> cpage++;\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> qemu_sglist_add(&q->sgl, page, plen);\n<52> \n<53> bytes -= plen;\n<54> \n<55> }\n<56> \n<57> return 0;\n<58> \n<59> }\n<60> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ffurl_alloc(URLContext **puc, const char *filename, int flags,\n<2> \n<3> const AVIOInterruptCB *int_cb)\n<4> \n<5> {\n<6> \n<7> URLProtocol *up = NULL;\n<8> \n<9> char proto_str[128], proto_nested[128], *ptr;\n<10> \n<11> size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n<12> \n<13> \n<14> \n<15> if (filename[proto_len] != ':' || is_dos_path(filename))\n<16> \n<17> strcpy(proto_str, "file");\n<18> \n<19> else\n<20> \n<21> av_strlcpy(proto_str, filename,\n<22> \n<23> FFMIN(proto_len + 1, sizeof(proto_str)));\n<24> \n<25> \n<26> \n<27> av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n<28> \n<29> if ((ptr = strchr(proto_nested, '+')))\n<30> \n<31> *ptr = '\0';\n<32> \n<33> \n<34> \n<35> while (up = ffurl_protocol_next(up)) {\n<36> \n<37> if (!strcmp(proto_str, up->name))\n<38> \n<39> return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n<40> \n<41> if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n<42> \n<43> !strcmp(proto_nested, up->name))\n<44> \n<45> return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n<46> \n<47> }\n<48> \n<49> *puc = NULL;\n<50> \n<51> return AVERROR_PROTOCOL_NOT_FOUND;\n<52> \n<53> }\n<54> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void tcg_reg_alloc_op(TCGContext *s,\n<2> \n<3> const TCGOpDef *def, TCGOpcode opc,\n<4> \n<5> const TCGArg *args, uint16_t dead_args,\n<6> \n<7> uint8_t sync_args)\n<8> \n<9> {\n<10> \n<11> TCGRegSet allocated_regs;\n<12> \n<13> int i, k, nb_iargs, nb_oargs, reg;\n<14> \n<15> TCGArg arg;\n<16> \n<17> const TCGArgConstraint *arg_ct;\n<18> \n<19> TCGTemp *ts;\n<20> \n<21> TCGArg new_args[TCG_MAX_OP_ARGS];\n<22> \n<23> int const_args[TCG_MAX_OP_ARGS];\n<24> \n<25> \n<26> \n<27> nb_oargs = def->nb_oargs;\n<28> \n<29> nb_iargs = def->nb_iargs;\n<30> \n<31> \n<32> \n<33> /* copy constants */\n<34> \n<35> memcpy(new_args + nb_oargs + nb_iargs,\n<36> \n<37> args + nb_oargs + nb_iargs,\n<38> \n<39> sizeof(TCGArg) * def->nb_cargs);\n<40> \n<41> \n<42> \n<43> /* satisfy input constraints */\n<44> \n<45> tcg_regset_set(allocated_regs, s->reserved_regs);\n<46> \n<47> for(k = 0; k < nb_iargs; k++) {\n<48> \n<49> i = def->sorted_args[nb_oargs + k];\n<50> \n<51> arg = args[i];\n<52> \n<53> arg_ct = &def->args_ct[i];\n<54> \n<55> ts = &s->temps[arg];\n<56> \n<57> if (ts->val_type == TEMP_VAL_MEM) {\n<58> \n<59> reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);\n<60> \n<61> tcg_out_ld(s, ts->type, reg, ts->mem_reg, ts->mem_offset);\n<62> \n<63> ts->val_type = TEMP_VAL_REG;\n<64> \n<65> ts->reg = reg;\n<66> \n<67> ts->mem_coherent = 1;\n<68> \n<69> s->reg_to_temp[reg] = arg;\n<70> \n<71> } else if (ts->val_type == TEMP_VAL_CONST) {\n<72> \n<73> if (tcg_target_const_match(ts->val, ts->type, arg_ct)) {\n<74> \n<75> /* constant is OK for instruction */\n<76> \n<77> const_args[i] = 1;\n<78> \n<79> new_args[i] = ts->val;\n<80> \n<81> goto iarg_end;\n<82> \n<83> } else {\n<84> \n<85> /* need to move to a register */\n<86> \n<87> reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);\n<88> \n<89> tcg_out_movi(s, ts->type, reg, ts->val);\n<90> \n<91> ts->val_type = TEMP_VAL_REG;\n<92> \n<93> ts->reg = reg;\n<94> \n<95> ts->mem_coherent = 0;\n<96> \n<97> s->reg_to_temp[reg] = arg;\n<98> \n<99> }\n<100> \n<101> }\n<102> \n<103> assert(ts->val_type == TEMP_VAL_REG);\n<104> \n<105> if (arg_ct->ct & TCG_CT_IALIAS) {\n<106> \n<107> if (ts->fixed_reg) {\n<108> \n<109> /* if fixed register, we must allocate a new register\n<110> \n<111> if the alias is not the same register */\n<112> \n<113> if (arg != args[arg_ct->alias_index])\n<114> \n<115> goto allocate_in_reg;\n<116> \n<117> } else {\n<118> \n<119> /* if the input is aliased to an output and if it is\n<120> \n<121> not dead after the instruction, we must allocate\n<122> \n<123> a new register and move it */\n<124> \n<125> if (!IS_DEAD_ARG(i)) {\n<126> \n<127> goto allocate_in_reg;\n<128> \n<129> }\n<130> \n<131> /* check if the current register has already been allocated\n<132> \n<133> for another input aliased to an output */\n<134> \n<135> int k2, i2;\n<136> \n<137> for (k2 = 0 ; k2 < k ; k2++) {\n<138> \n<139> i2 = def->sorted_args[nb_oargs + k2];\n<140> \n<141> if ((def->args_ct[i2].ct & TCG_CT_IALIAS) &&\n<142> \n<143> (new_args[i2] == ts->reg)) {\n<144> \n<145> goto allocate_in_reg;\n<146> \n<147> }\n<148> \n<149> }\n<150> \n<151> }\n<152> \n<153> }\n<154> \n<155> reg = ts->reg;\n<156> \n<157> if (tcg_regset_test_reg(arg_ct->u.regs, reg)) {\n<158> \n<159> /* nothing to do : the constraint is satisfied */\n<160> \n<161> } else {\n<162> \n<163> allocate_in_reg:\n<164> \n<165> /* allocate a new register matching the constraint\n<166> \n<167> and move the temporary register into it */\n<168> \n<169> reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);\n<170> \n<171> tcg_out_mov(s, ts->type, reg, ts->reg);\n<172> \n<173> }\n<174> \n<175> new_args[i] = reg;\n<176> \n<177> const_args[i] = 0;\n<178> \n<179> tcg_regset_set_reg(allocated_regs, reg);\n<180> \n<181> iarg_end: ;\n<182> \n<183> }\n<184> \n<185> \n<186> \n<187> /* mark dead temporaries and free the associated registers */\n<188> \n<189> for (i = nb_oargs; i < nb_oargs + nb_iargs; i++) {\n<190> \n<191> if (IS_DEAD_ARG(i)) {\n<192> \n<193> temp_dead(s, args[i]);\n<194> \n<195> }\n<196> \n<197> }\n<198> \n<199> \n<200> \n<201> if (def->flags & TCG_OPF_BB_END) {\n<202> \n<203> tcg_reg_alloc_bb_end(s, allocated_regs);\n<204> \n<205> } else {\n<206> \n<207> if (def->flags & TCG_OPF_CALL_CLOBBER) {\n<208> \n<209> /* XXX: permit generic clobber register list ? */\n<210> \n<211> for(reg = 0; reg < TCG_TARGET_NB_REGS; reg++) {\n<212> \n<213> if (tcg_regset_test_reg(tcg_target_call_clobber_regs, reg)) {\n<214> \n<215> tcg_reg_free(s, reg);\n<216> \n<217> }\n<218> \n<219> }\n<220> \n<221> }\n<222> \n<223> if (def->flags & TCG_OPF_SIDE_EFFECTS) {\n<224> \n<225> /* sync globals if the op has side effects and might trigger\n<226> \n<227> an exception. */\n<228> \n<229> sync_globals(s, allocated_regs);\n<230> \n<231> }\n<232> \n<233> \n<234> \n<235> /* satisfy the output constraints */\n<236> \n<237> tcg_regset_set(allocated_regs, s->reserved_regs);\n<238> \n<239> for(k = 0; k < nb_oargs; k++) {\n<240> \n<241> i = def->sorted_args[k];\n<242> \n<243> arg = args[i];\n<244> \n<245> arg_ct = &def->args_ct[i];\n<246> \n<247> ts = &s->temps[arg];\n<248> \n<249> if (arg_ct->ct & TCG_CT_ALIAS) {\n<250> \n<251> reg = new_args[arg_ct->alias_index];\n<252> \n<253> } else {\n<254> \n<255> /* if fixed register, we try to use it */\n<256> \n<257> reg = ts->reg;\n<258> \n<259> if (ts->fixed_reg &&\n<260> \n<261> tcg_regset_test_reg(arg_ct->u.regs, reg)) {\n<262> \n<263> goto oarg_end;\n<264> \n<265> }\n<266> \n<267> reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);\n<268> \n<269> }\n<270> \n<271> tcg_regset_set_reg(allocated_regs, reg);\n<272> \n<273> /* if a fixed register is used, then a move will be done afterwards */\n<274> \n<275> if (!ts->fixed_reg) {\n<276> \n<277> if (ts->val_type == TEMP_VAL_REG) {\n<278> \n<279> s->reg_to_temp[ts->reg] = -1;\n<280> \n<281> }\n<282> \n<283> ts->val_type = TEMP_VAL_REG;\n<284> \n<285> ts->reg = reg;\n<286> \n<287> /* temp value is modified, so the value kept in memory is\n<288> \n<289> potentially not the same */\n<290> \n<291> ts->mem_coherent = 0;\n<292> \n<293> s->reg_to_temp[reg] = arg;\n<294> \n<295> }\n<296> \n<297> oarg_end:\n<298> \n<299> new_args[i] = reg;\n<300> \n<301> }\n<302> \n<303> }\n<304> \n<305> \n<306> \n<307> /* emit instruction */\n<308> \n<309> tcg_out_op(s, opc, new_args, const_args);\n<310> \n<311> \n<312> \n<313> /* move the outputs in the correct register if needed */\n<314> \n<315> for(i = 0; i < nb_oargs; i++) {\n<316> \n<317> ts = &s->temps[args[i]];\n<318> \n<319> reg = new_args[i];\n<320> \n<321> if (ts->fixed_reg && ts->reg != reg) {\n<322> \n<323> tcg_out_mov(s, ts->type, ts->reg, reg);\n<324> \n<325> }\n<326> \n<327> if (NEED_SYNC_ARG(i)) {\n<328> \n<329> tcg_reg_sync(s, reg);\n<330> \n<331> }\n<332> \n<333> if (IS_DEAD_ARG(i)) {\n<334> \n<335> temp_dead(s, args[i]);\n<336> \n<337> }\n<338> \n<339> }\n<340> \n<341> }\n<342> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void handle_null_request ( int tun_fd , int dns_fd , struct query * q , int domain_len ) {\n<2> struct in_addr tempip ;\n<3> char in [ 512 ] ;\n<4> char logindata [ 16 ] ;\n<5> char out [ 64 * 1024 ] ;\n<6> char unpacked [ 64 * 1024 ] ;\n<7> char * tmp [ 2 ] ;\n<8> int userid ;\n<9> int read ;\n<10> userid = - 1 ;\n<11> if ( domain_len < 2 ) return ;\n<12> memcpy ( in , q -> name , MIN ( domain_len , sizeof ( in ) ) ) ;\n<13> if ( in [ 0 ] == 'V' || in [ 0 ] == 'v' ) {\n<14> int version = 0 ;\n<15> read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n<16> if ( read > 4 ) {\n<17> version = ( ( ( unpacked [ 0 ] & 0xff ) << 24 ) | ( ( unpacked [ 1 ] & 0xff ) << 16 ) | ( ( unpacked [ 2 ] & 0xff ) << 8 ) | ( ( unpacked [ 3 ] & 0xff ) ) ) ;\n<18> }\n<19> if ( version == VERSION ) {\n<20> userid = find_available_user ( ) ;\n<21> if ( userid >= 0 ) {\n<22> int i ;\n<23> struct sockaddr_in * tempin ;\n<24> users [ userid ] . seed = rand ( ) ;\n<25> tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n<26> memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n<27> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<28> users [ userid ] . encoder = get_base32_encoder ( ) ;\n<29> users [ userid ] . downenc = 'T' ;\n<30> send_version_response ( dns_fd , VERSION_ACK , users [ userid ] . seed , userid , q ) ;\n<31> syslog ( LOG_INFO , "accepted version for user #%d from %s" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n<32> users [ userid ] . q . id = 0 ;\n<33> users [ userid ] . q . id2 = 0 ;\n<34> users [ userid ] . q_sendrealsoon . id = 0 ;\n<35> users [ userid ] . q_sendrealsoon . id2 = 0 ;\n<36> users [ userid ] . q_sendrealsoon_new = 0 ;\n<37> users [ userid ] . outpacket . len = 0 ;\n<38> users [ userid ] . outpacket . offset = 0 ;\n<39> users [ userid ] . outpacket . sentlen = 0 ;\n<40> users [ userid ] . outpacket . seqno = 0 ;\n<41> users [ userid ] . outpacket . fragment = 0 ;\n<42> users [ userid ] . outfragresent = 0 ;\n<43> users [ userid ] . inpacket . len = 0 ;\n<44> users [ userid ] . inpacket . offset = 0 ;\n<45> users [ userid ] . inpacket . seqno = 0 ;\n<46> users [ userid ] . inpacket . fragment = 0 ;\n<47> users [ userid ] . fragsize = 100 ;\n<48> users [ userid ] . conn = CONN_DNS_NULL ;\n<49> users [ userid ] . lazy = 0 ;\n<50> # ifdef OUTPACKETQ_LEN users [ userid ] . outpacketq_nexttouse = 0 ;\n<51> users [ userid ] . outpacketq_filled = 0 ;\n<52> # endif # ifdef DNSCACHE_LEN {\n<53> for ( i = 0 ;\n<54> i < DNSCACHE_LEN ;\n<55> i ++ ) {\n<56> users [ userid ] . dnscache_q [ i ] . id = 0 ;\n<57> users [ userid ] . dnscache_answerlen [ i ] = 0 ;\n<58> }\n<59> }\n<60> users [ userid ] . dnscache_lastfilled = 0 ;\n<61> # endif for ( i = 0 ;\n<62> i < QMEMPING_LEN ;\n<63> i ++ ) users [ userid ] . qmemping_type [ i ] = T_UNSET ;\n<64> users [ userid ] . qmemping_lastfilled = 0 ;\n<65> for ( i = 0 ;\n<66> i < QMEMDATA_LEN ;\n<67> i ++ ) users [ userid ] . qmemdata_type [ i ] = T_UNSET ;\n<68> users [ userid ] . qmemdata_lastfilled = 0 ;\n<69> }\n<70> else {\n<71> send_version_response ( dns_fd , VERSION_FULL , created_users , 0 , q ) ;\n<72> syslog ( LOG_INFO , "dropped user from %s, server full" , format_addr ( & q -> from , q -> fromlen ) ) ;\n<73> }\n<74> }\n<75> else {\n<76> send_version_response ( dns_fd , VERSION_NACK , VERSION , 0 , q ) ;\n<77> syslog ( LOG_INFO , "dropped user from %s, sent bad version %08X" , format_addr ( & q -> from , q -> fromlen ) , version ) ;\n<78> }\n<79> return ;\n<80> }\n<81> else if ( in [ 0 ] == 'L' || in [ 0 ] == 'l' ) {\n<82> read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n<83> if ( read < 17 ) {\n<84> write_dns ( dns_fd , q , "BADLEN" , 6 , 'T' ) ;\n<85> return ;\n<86> }\n<87> userid = unpacked [ 0 ] ;\n<88> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<89> write_dns ( dns_fd , q , "BADIP" , 5 , 'T' ) ;\n<90> syslog ( LOG_WARNING , "dropped login request from user #%d from unexpected source %s" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n<91> return ;\n<92> }\n<93> else {\n<94> users [ userid ] . last_pkt = time ( NULL ) ;\n<95> login_calculate ( logindata , 16 , password , users [ userid ] . seed ) ;\n<96> if ( read >= 18 && ( memcmp ( logindata , unpacked + 1 , 16 ) == 0 ) ) {\n<97> tempip . s_addr = my_ip ;\n<98> tmp [ 0 ] = strdup ( inet_ntoa ( tempip ) ) ;\n<99> tempip . s_addr = users [ userid ] . tun_ip ;\n<100> tmp [ 1 ] = strdup ( inet_ntoa ( tempip ) ) ;\n<101> read = snprintf ( out , sizeof ( out ) , "%s-%s-%d-%d" , tmp [ 0 ] , tmp [ 1 ] , my_mtu , netmask ) ;\n<102> write_dns ( dns_fd , q , out , read , users [ userid ] . downenc ) ;\n<103> q -> id = 0 ;\n<104> syslog ( LOG_NOTICE , "accepted password from user #%d, given IP %s" , userid , tmp [ 1 ] ) ;\n<105> free ( tmp [ 1 ] ) ;\n<106> free ( tmp [ 0 ] ) ;\n<107> }\n<108> else {\n<109> write_dns ( dns_fd , q , "LNAK" , 4 , 'T' ) ;\n<110> syslog ( LOG_WARNING , "rejected login request from user #%d from %s, bad password" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n<111> }\n<112> }\n<113> return ;\n<114> }\n<115> else if ( in [ 0 ] == 'I' || in [ 0 ] == 'i' ) {\n<116> in_addr_t replyaddr ;\n<117> unsigned addr ;\n<118> char reply [ 5 ] ;\n<119> userid = b32_8to5 ( in [ 1 ] ) ;\n<120> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<121> write_dns ( dns_fd , q , "BADIP" , 5 , 'T' ) ;\n<122> return ;\n<123> }\n<124> if ( ns_ip != INADDR_ANY ) {\n<125> replyaddr = ns_ip ;\n<126> }\n<127> else {\n<128> memcpy ( & replyaddr , & q -> destination . s_addr , sizeof ( in_addr_t ) ) ;\n<129> }\n<130> addr = htonl ( replyaddr ) ;\n<131> reply [ 0 ] = 'I' ;\n<132> reply [ 1 ] = ( addr >> 24 ) & 0xFF ;\n<133> reply [ 2 ] = ( addr >> 16 ) & 0xFF ;\n<134> reply [ 3 ] = ( addr >> 8 ) & 0xFF ;\n<135> reply [ 4 ] = ( addr >> 0 ) & 0xFF ;\n<136> write_dns ( dns_fd , q , reply , sizeof ( reply ) , 'T' ) ;\n<137> }\n<138> else if ( in [ 0 ] == 'Z' || in [ 0 ] == 'z' ) {\n<139> write_dns ( dns_fd , q , in , domain_len , 'T' ) ;\n<140> return ;\n<141> }\n<142> else if ( in [ 0 ] == 'S' || in [ 0 ] == 's' ) {\n<143> int codec ;\n<144> struct encoder * enc ;\n<145> if ( domain_len < 3 ) {\n<146> write_dns ( dns_fd , q , "BADLEN" , 6 , 'T' ) ;\n<147> return ;\n<148> }\n<149> userid = b32_8to5 ( in [ 1 ] ) ;\n<150> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<151> write_dns ( dns_fd , q , "BADIP" , 5 , 'T' ) ;\n<152> return ;\n<153> }\n<154> codec = b32_8to5 ( in [ 2 ] ) ;\n<155> switch ( codec ) {\n<156> case 5 : enc = get_base32_encoder ( ) ;\n<157> user_switch_codec ( userid , enc ) ;\n<158> write_dns ( dns_fd , q , enc -> name , strlen ( enc -> name ) , users [ userid ] . downenc ) ;\n<159> break ;\n<160> case 6 : enc = get_base64_encoder ( ) ;\n<161> user_switch_codec ( userid , enc ) ;\n<162> write_dns ( dns_fd , q , enc -> name , strlen ( enc -> name ) , users [ userid ] . downenc ) ;\n<163> break ;\n<164> case 26 : enc = get_base64u_encoder ( ) ;\n<165> user_switch_codec ( userid , enc ) ;\n<166> write_dns ( dns_fd , q , enc -> name , strlen ( enc -> name ) , users [ userid ] . downenc ) ;\n<167> break ;\n<168> case 7 : enc = get_base128_encoder ( ) ;\n<169> user_switch_codec ( userid , enc ) ;\n<170> write_dns ( dns_fd , q , enc -> name , strlen ( enc -> name ) , users [ userid ] . downenc ) ;\n<171> break ;\n<172> default : write_dns ( dns_fd , q , "BADCODEC" , 8 , users [ userid ] . downenc ) ;\n<173> break ;\n<174> }\n<175> return ;\n<176> }\n<177> else if ( in [ 0 ] == 'O' || in [ 0 ] == 'o' ) {\n<178> if ( domain_len < 3 ) {\n<179> write_dns ( dns_fd , q , "BADLEN" , 6 , 'T' ) ;\n<180> return ;\n<181> }\n<182> userid = b32_8to5 ( in [ 1 ] ) ;\n<183> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<184> write_dns ( dns_fd , q , "BADIP" , 5 , 'T' ) ;\n<185> return ;\n<186> }\n<187> switch ( in [ 2 ] ) {\n<188> case 'T' : case 't' : users [ userid ] . downenc = 'T' ;\n<189> write_dns ( dns_fd , q , "Base32" , 6 , users [ userid ] . downenc ) ;\n<190> break ;\n<191> case 'S' : case 's' : users [ userid ] . downenc = 'S' ;\n<192> write_dns ( dns_fd , q , "Base64" , 6 , users [ userid ] . downenc ) ;\n<193> break ;\n<194> case 'U' : case 'u' : users [ userid ] . downenc = 'U' ;\n<195> write_dns ( dns_fd , q , "Base64u" , 7 , users [ userid ] . downenc ) ;\n<196> break ;\n<197> case 'V' : case 'v' : users [ userid ] . downenc = 'V' ;\n<198> write_dns ( dns_fd , q , "Base128" , 7 , users [ userid ] . downenc ) ;\n<199> break ;\n<200> case 'R' : case 'r' : users [ userid ] . downenc = 'R' ;\n<201> write_dns ( dns_fd , q , "Raw" , 3 , users [ userid ] . downenc ) ;\n<202> break ;\n<203> case 'L' : case 'l' : users [ userid ] . lazy = 1 ;\n<204> write_dns ( dns_fd , q , "Lazy" , 4 , users [ userid ] . downenc ) ;\n<205> break ;\n<206> case 'I' : case 'i' : users [ userid ] . lazy = 0 ;\n<207> write_dns ( dns_fd , q , "Immediate" , 9 , users [ userid ] . downenc ) ;\n<208> break ;\n<209> default : write_dns ( dns_fd , q , "BADCODEC" , 8 , users [ userid ] . downenc ) ;\n<210> break ;\n<211> }\n<212> return ;\n<213> }\n<214> else if ( in [ 0 ] == 'Y' || in [ 0 ] == 'y' ) {\n<215> int i ;\n<216> char * datap ;\n<217> int datalen ;\n<218> if ( domain_len < 6 ) {\n<219> write_dns ( dns_fd , q , "BADLEN" , 6 , 'T' ) ;\n<220> return ;\n<221> }\n<222> i = b32_8to5 ( in [ 2 ] ) ;\n<223> switch ( i ) {\n<224> case 1 : datap = DOWNCODECCHECK1 ;\n<225> datalen = DOWNCODECCHECK1_LEN ;\n<226> break ;\n<227> default : write_dns ( dns_fd , q , "BADLEN" , 6 , 'T' ) ;\n<228> return ;\n<229> }\n<230> switch ( in [ 1 ] ) {\n<231> case 'T' : case 't' : if ( q -> type == T_TXT || q -> type == T_SRV || q -> type == T_MX || q -> type == T_CNAME || q -> type == T_A ) {\n<232> write_dns ( dns_fd , q , datap , datalen , 'T' ) ;\n<233> return ;\n<234> }\n<235> break ;\n<236> case 'S' : case 's' : if ( q -> type == T_TXT || q -> type == T_SRV || q -> type == T_MX || q -> type == T_CNAME || q -> type == T_A ) {\n<237> write_dns ( dns_fd , q , datap , datalen , 'S' ) ;\n<238> return ;\n<239> }\n<240> break ;\n<241> case 'U' : case 'u' : if ( q -> type == T_TXT || q -> type == T_SRV || q -> type == T_MX || q -> type == T_CNAME || q -> type == T_A ) {\n<242> write_dns ( dns_fd , q , datap , datalen , 'U' ) ;\n<243> return ;\n<244> }\n<245> break ;\n<246> case 'V' : case 'v' : if ( q -> type == T_TXT || q -> type == T_SRV || q -> type == T_MX || q -> type == T_CNAME || q -> type == T_A ) {\n<247> write_dns ( dns_fd , q , datap , datalen , 'V' ) ;\n<248> return ;\n<249> }\n<250> break ;\n<251> case 'R' : case 'r' : if ( q -> type == T_NULL || q -> type == T_TXT ) {\n<252> write_dns ( dns_fd , q , datap , datalen , 'R' ) ;\n<253> return ;\n<254> }\n<255> break ;\n<256> }\n<257> write_dns ( dns_fd , q , "BADCODEC" , 8 , 'T' ) ;\n<258> return ;\n<259> }\n<260> else if ( in [ 0 ] == 'R' || in [ 0 ] == 'r' ) {\n<261> int req_frag_size ;\n<262> if ( domain_len < 16 ) {\n<263> write_dns ( dns_fd , q , "BADLEN" , 6 , 'T' ) ;\n<264> return ;\n<265> }\n<266> userid = ( b32_8to5 ( in [ 1 ] ) >> 1 ) & 15 ;\n<267> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<268> write_dns ( dns_fd , q , "BADIP" , 5 , 'T' ) ;\n<269> return ;\n<270> }\n<271> req_frag_size = ( ( b32_8to5 ( in [ 1 ] ) & 1 ) << 10 ) | ( ( b32_8to5 ( in [ 2 ] ) & 31 ) << 5 ) | ( b32_8to5 ( in [ 3 ] ) & 31 ) ;\n<272> if ( req_frag_size < 2 || req_frag_size > 2047 ) {\n<273> write_dns ( dns_fd , q , "BADFRAG" , 7 , users [ userid ] . downenc ) ;\n<274> }\n<275> else {\n<276> char buf [ 2048 ] ;\n<277> int i ;\n<278> unsigned int v = ( ( unsigned int ) rand ( ) ) & 0xff ;\n<279> memset ( buf , 0 , sizeof ( buf ) ) ;\n<280> buf [ 0 ] = ( req_frag_size >> 8 ) & 0xff ;\n<281> buf [ 1 ] = req_frag_size & 0xff ;\n<282> buf [ 2 ] = 107 ;\n<283> for ( i = 3 ;\n<284> i < 2048 ;\n<285> i ++ , v = ( v + 107 ) & 0xff ) buf [ i ] = v ;\n<286> write_dns ( dns_fd , q , buf , req_frag_size , users [ userid ] . downenc ) ;\n<287> }\n<288> return ;\n<289> }\n<290> else if ( in [ 0 ] == 'N' || in [ 0 ] == 'n' ) {\n<291> int max_frag_size ;\n<292> read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n<293> if ( read < 3 ) {\n<294> write_dns ( dns_fd , q , "BADLEN" , 6 , 'T' ) ;\n<295> return ;\n<296> }\n<297> userid = unpacked [ 0 ] ;\n<298> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<299> write_dns ( dns_fd , q , "BADIP" , 5 , 'T' ) ;\n<300> return ;\n<301> }\n<302> max_frag_size = ( ( unpacked [ 1 ] & 0xff ) << 8 ) | ( unpacked [ 2 ] & 0xff ) ;\n<303> if ( max_frag_size < 2 ) {\n<304> write_dns ( dns_fd , q , "BADFRAG" , 7 , users [ userid ] . downenc ) ;\n<305> }\n<306> else {\n<307> users [ userid ] . fragsize = max_frag_size ;\n<308> write_dns ( dns_fd , q , & unpacked [ 1 ] , 2 , users [ userid ] . downenc ) ;\n<309> }\n<310> return ;\n<311> }\n<312> else if ( in [ 0 ] == 'P' || in [ 0 ] == 'p' ) {\n<313> int dn_seq ;\n<314> int dn_frag ;\n<315> int didsend = 0 ;\n<316> if ( q -> id == 0 ) return ;\n<317> read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n<318> if ( read < 4 ) return ;\n<319> userid = unpacked [ 0 ] ;\n<320> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<321> write_dns ( dns_fd , q , "BADIP" , 5 , 'T' ) ;\n<322> return ;\n<323> }\n<324> # ifdef DNSCACHE_LEN if ( answer_from_dnscache ( dns_fd , userid , q ) ) return ;\n<325> # endif if ( answer_from_qmem ( dns_fd , q , users [ userid ] . qmemping_cmc , users [ userid ] . qmemping_type , QMEMPING_LEN , ( void * ) unpacked ) ) return ;\n<326> if ( users [ userid ] . q . id != 0 && q -> type == users [ userid ] . q . type && ! strcmp ( q -> name , users [ userid ] . q . name ) && users [ userid ] . lazy ) {\n<327> if ( debug >= 2 ) {\n<328> fprintf ( stderr , "PING pkt from user %d = dupe from impatient DNS server, remembering\n" , userid ) ;\n<329> }\n<330> users [ userid ] . q . id2 = q -> id ;\n<331> users [ userid ] . q . fromlen2 = q -> fromlen ;\n<332> memcpy ( & ( users [ userid ] . q . from2 ) , & ( q -> from ) , q -> fromlen ) ;\n<333> return ;\n<334> }\n<335> if ( users [ userid ] . q_sendrealsoon . id != 0 && q -> type == users [ userid ] . q_sendrealsoon . type && ! strcmp ( q -> name , users [ userid ] . q_sendrealsoon . name ) ) {\n<336> if ( debug >= 2 ) {\n<337> fprintf ( stderr , "PING pkt from user %d = dupe from impatient DNS server, remembering\n" , userid ) ;\n<338> }\n<339> users [ userid ] . q_sendrealsoon . id2 = q -> id ;\n<340> users [ userid ] . q_sendrealsoon . fromlen2 = q -> fromlen ;\n<341> memcpy ( & ( users [ userid ] . q_sendrealsoon . from2 ) , & ( q -> from ) , q -> fromlen ) ;\n<342> return ;\n<343> }\n<344> dn_seq = unpacked [ 1 ] >> 4 ;\n<345> dn_frag = unpacked [ 1 ] & 15 ;\n<346> if ( debug >= 1 ) {\n<347> fprintf ( stderr , "PING pkt from user %d, ack for downstream %d/%d\n" , userid , dn_seq , dn_frag ) ;\n<348> }\n<349> process_downstream_ack ( userid , dn_seq , dn_frag ) ;\n<350> if ( debug >= 3 ) {\n<351> fprintf ( stderr , "PINGret (if any) will ack upstream %d/%d\n" , users [ userid ] . inpacket . seqno , users [ userid ] . inpacket . fragment ) ;\n<352> }\n<353> if ( users [ userid ] . q_sendrealsoon . id != 0 ) {\n<354> send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q_sendrealsoon ) ;\n<355> }\n<356> if ( users [ userid ] . q . id != 0 ) {\n<357> didsend = 1 ;\n<358> if ( send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) == 1 ) didsend = 0 ;\n<359> }\n<360> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<361> users [ userid ] . last_pkt = time ( NULL ) ;\n<362> if ( ( ! didsend && users [ userid ] . outpacket . len > 0 ) || ! users [ userid ] . lazy ) send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) ;\n<363> }\n<364> else if ( ( in [ 0 ] >= '0' && in [ 0 ] <= '9' ) || ( in [ 0 ] >= 'a' && in [ 0 ] <= 'f' ) || ( in [ 0 ] >= 'A' && in [ 0 ] <= 'F' ) ) {\n<365> int up_seq , up_frag , dn_seq , dn_frag , lastfrag ;\n<366> int upstream_ok = 1 ;\n<367> int didsend = 0 ;\n<368> int code = - 1 ;\n<369> if ( domain_len < 6 ) return ;\n<370> if ( q -> id == 0 ) return ;\n<371> if ( ( in [ 0 ] >= '0' && in [ 0 ] <= '9' ) ) code = in [ 0 ] - '0' ;\n<372> if ( ( in [ 0 ] >= 'a' && in [ 0 ] <= 'f' ) ) code = in [ 0 ] - 'a' + 10 ;\n<373> if ( ( in [ 0 ] >= 'A' && in [ 0 ] <= 'F' ) ) code = in [ 0 ] - 'A' + 10 ;\n<374> userid = code ;\n<375> if ( check_user_and_ip ( userid , q ) != 0 ) {\n<376> write_dns ( dns_fd , q , "BADIP" , 5 , 'T' ) ;\n<377> return ;\n<378> }\n<379> # ifdef DNSCACHE_LEN if ( answer_from_dnscache ( dns_fd , userid , q ) ) return ;\n<380> # endif if ( answer_from_qmem_data ( dns_fd , userid , q ) ) return ;\n<381> if ( users [ userid ] . q . id != 0 && q -> type == users [ userid ] . q . type && ! strcmp ( q -> name , users [ userid ] . q . name ) && users [ userid ] . lazy ) {\n<382> if ( debug >= 2 ) {\n<383> fprintf ( stderr , "IN pkt from user %d = dupe from impatient DNS server, remembering\n" , userid ) ;\n<384> }\n<385> users [ userid ] . q . id2 = q -> id ;\n<386> users [ userid ] . q . fromlen2 = q -> fromlen ;\n<387> memcpy ( & ( users [ userid ] . q . from2 ) , & ( q -> from ) , q -> fromlen ) ;\n<388> return ;\n<389> }\n<390> if ( users [ userid ] . q_sendrealsoon . id != 0 && q -> type == users [ userid ] . q_sendrealsoon . type && ! strcmp ( q -> name , users [ userid ] . q_sendrealsoon . name ) ) {\n<391> if ( debug >= 2 ) {\n<392> fprintf ( stderr , "IN pkt from user %d = dupe from impatient DNS server, remembering\n" , userid ) ;\n<393> }\n<394> users [ userid ] . q_sendrealsoon . id2 = q -> id ;\n<395> users [ userid ] . q_sendrealsoon . fromlen2 = q -> fromlen ;\n<396> memcpy ( & ( users [ userid ] . q_sendrealsoon . from2 ) , & ( q -> from ) , q -> fromlen ) ;\n<397> return ;\n<398> }\n<399> up_seq = ( b32_8to5 ( in [ 1 ] ) >> 2 ) & 7 ;\n<400> up_frag = ( ( b32_8to5 ( in [ 1 ] ) & 3 ) << 2 ) | ( ( b32_8to5 ( in [ 2 ] ) >> 3 ) & 3 ) ;\n<401> dn_seq = ( b32_8to5 ( in [ 2 ] ) & 7 ) ;\n<402> dn_frag = b32_8to5 ( in [ 3 ] ) >> 1 ;\n<403> lastfrag = b32_8to5 ( in [ 3 ] ) & 1 ;\n<404> process_downstream_ack ( userid , dn_seq , dn_frag ) ;\n<405> if ( up_seq == users [ userid ] . inpacket . seqno && up_frag <= users [ userid ] . inpacket . fragment ) {\n<406> if ( debug >= 1 ) {\n<407> fprintf ( stderr , "IN pkt seq# %d, frag %d, dropped duplicate frag\n" , up_seq , up_frag ) ;\n<408> }\n<409> upstream_ok = 0 ;\n<410> }\n<411> else if ( up_seq != users [ userid ] . inpacket . seqno && recent_seqno ( users [ userid ] . inpacket . seqno , up_seq ) ) {\n<412> if ( debug >= 1 ) {\n<413> fprintf ( stderr , "IN pkt seq# %d, frag %d, dropped duplicate recent seqno\n" , up_seq , up_frag ) ;\n<414> }\n<415> upstream_ok = 0 ;\n<416> }\n<417> else if ( up_seq != users [ userid ] . inpacket . seqno ) {\n<418> users [ userid ] . inpacket . seqno = up_seq ;\n<419> users [ userid ] . inpacket . fragment = up_frag ;\n<420> users [ userid ] . inpacket . len = 0 ;\n<421> users [ userid ] . inpacket . offset = 0 ;\n<422> }\n<423> else {\n<424> users [ userid ] . inpacket . fragment = up_frag ;\n<425> }\n<426> if ( debug >= 3 ) {\n<427> fprintf ( stderr , "INpack with upstream %d/%d, we are going to ack upstream %d/%d\n" , up_seq , up_frag , users [ userid ] . inpacket . seqno , users [ userid ] . inpacket . fragment ) ;\n<428> }\n<429> if ( upstream_ok ) {\n<430> read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 5 ] ) , domain_len - 5 , users [ userid ] . encoder ) ;\n<431> read = MIN ( read , sizeof ( users [ userid ] . inpacket . data ) - users [ userid ] . inpacket . offset ) ;\n<432> memcpy ( users [ userid ] . inpacket . data + users [ userid ] . inpacket . offset , unpacked , read ) ;\n<433> users [ userid ] . inpacket . len += read ;\n<434> users [ userid ] . inpacket . offset += read ;\n<435> if ( debug >= 1 ) {\n<436> fprintf ( stderr , "IN pkt seq# %d, frag %d (last=%d), fragsize %d, total %d, from user %d\n" , up_seq , up_frag , lastfrag , read , users [ userid ] . inpacket . len , userid ) ;\n<437> }\n<438> }\n<439> if ( upstream_ok && lastfrag ) {\n<440> handle_full_packet ( tun_fd , dns_fd , userid ) ;\n<441> }\n<442> if ( users [ userid ] . q_sendrealsoon . id != 0 ) {\n<443> didsend = 1 ;\n<444> if ( send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q_sendrealsoon ) == 1 ) didsend = 0 ;\n<445> }\n<446> if ( users [ userid ] . q . id != 0 ) {\n<447> if ( ( users [ userid ] . outpacket . len > 0 && ! didsend ) || ( upstream_ok && ! lastfrag && ! didsend ) || ( ! upstream_ok && ! didsend ) || ! users [ userid ] . lazy ) {\n<448> didsend = 1 ;\n<449> if ( send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) == 1 ) didsend = 0 ;\n<450> }\n<451> else {\n<452> memcpy ( & ( users [ userid ] . q_sendrealsoon ) , & ( users [ userid ] . q ) , sizeof ( struct query ) ) ;\n<453> users [ userid ] . q_sendrealsoon_new = 1 ;\n<454> users [ userid ] . q . id = 0 ;\n<455> didsend = 1 ;\n<456> }\n<457> }\n<458> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<459> users [ userid ] . last_pkt = time ( NULL ) ;\n<460> if ( users [ userid ] . outpacket . len > 0 && ! didsend ) send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) ;\n<461> else if ( ! didsend || ! users [ userid ] . lazy ) {\n<462> if ( upstream_ok && lastfrag ) {\n<463> memcpy ( & ( users [ userid ] . q_sendrealsoon ) , & ( users [ userid ] . q ) , sizeof ( struct query ) ) ;\n<464> users [ userid ] . q_sendrealsoon_new = 1 ;\n<465> users [ userid ] . q . id = 0 ;\n<466> }\n<467> else {\n<468> send_chunk_or_dataless ( dns_fd , userid , & users [ userid ] . q ) ;\n<469> }\n<470> }\n<471> }\n<472> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n<2> EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ;\n<3> switch ( type ) {\n<4> case EVP_CTRL_INIT : cctx -> key_set = 0 ;\n<5> cctx -> iv_set = 0 ;\n<6> cctx -> L = 8 ;\n<7> cctx -> M = 12 ;\n<8> cctx -> tag_set = 0 ;\n<9> cctx -> len_set = 0 ;\n<10> cctx -> tls_aad_len = - 1 ;\n<11> return 1 ;\n<12> case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n<13> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n<14> cctx -> tls_aad_len = arg ;\n<15> {\n<16> uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n<17> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ;\n<18> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) len -= cctx -> M ;\n<19> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ;\n<20> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ;\n<21> }\n<22> return cctx -> M ;\n<23> case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ;\n<24> memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ;\n<25> return 1 ;\n<26> case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ;\n<27> case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ;\n<28> cctx -> L = arg ;\n<29> return 1 ;\n<30> case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ;\n<31> if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ;\n<32> if ( ptr ) {\n<33> cctx -> tag_set = 1 ;\n<34> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n<35> }\n<36> cctx -> M = arg ;\n<37> return 1 ;\n<38> case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ;\n<39> if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ;\n<40> cctx -> tag_set = 0 ;\n<41> cctx -> iv_set = 0 ;\n<42> cctx -> len_set = 0 ;\n<43> return 1 ;\n<44> case EVP_CTRL_COPY : {\n<45> EVP_CIPHER_CTX * out = ptr ;\n<46> EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ;\n<47> if ( cctx -> ccm . key ) {\n<48> if ( cctx -> ccm . key != & cctx -> ks ) return 0 ;\n<49> cctx_out -> ccm . key = & cctx_out -> ks ;\n<50> }\n<51> return 1 ;\n<52> }\n<53> default : return - 1 ;\n<54> }\n<55> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline void bt_hci_lmp_acl_data(struct bt_hci_s *hci, uint16_t handle,\n<2> \n<3> const uint8_t *data, int start, int len)\n<4> \n<5> {\n<6> \n<7> struct hci_acl_hdr *pkt = (void *) hci->acl_buf;\n<8> \n<9> \n<10> \n<11> /* TODO: packet flags */\n<12> \n<13> /* TODO: avoid memcpy'ing */\n<14> \n<15> \n<16> \n<17> if (len + HCI_ACL_HDR_SIZE > sizeof(hci->acl_buf)) {\n<18> \n<19> fprintf(stderr, "%s: can't take ACL packets %i bytes long\n",\n<20> \n<21> __FUNCTION__, len);\n<22> \n<23> return;\n<24> \n<25> }\n<26> \n<27> memcpy(hci->acl_buf + HCI_ACL_HDR_SIZE, data, len);\n<28> \n<29> \n<30> \n<31> pkt->handle = cpu_to_le16(\n<32> \n<33> acl_handle_pack(handle, start ? ACL_START : ACL_CONT));\n<34> \n<35> pkt->dlen = cpu_to_le16(len);\n<36> \n<37> hci->info.acl_recv(hci->info.opaque,\n<38> \n<39> hci->acl_buf, len + HCI_ACL_HDR_SIZE);\n<40> \n<41> }\n<42> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void sdl_audio_callback(void *opaque, Uint8 *stream, int len)\n<2> \n<3> {\n<4> \n<5> VideoState *is = opaque;\n<6> \n<7> int audio_size, len1;\n<8> \n<9> int bytes_per_sec;\n<10> \n<11> int frame_size = av_samples_get_buffer_size(NULL, is->audio_tgt.channels, 1, is->audio_tgt.fmt, 1);\n<12> \n<13> double pts;\n<14> \n<15> \n<16> \n<17> audio_callback_time = av_gettime();\n<18> \n<19> \n<20> \n<21> while (len > 0) {\n<22> \n<23> if (is->audio_buf_index >= is->audio_buf_size) {\n<24> \n<25> audio_size = audio_decode_frame(is, &pts);\n<26> \n<27> if (audio_size < 0) {\n<28> \n<29> /* if error, just output silence */\n<30> \n<31> is->audio_buf      = is->silence_buf;\n<32> \n<33> is->audio_buf_size = sizeof(is->silence_buf) / frame_size * frame_size;\n<34> \n<35> } else {\n<36> \n<37> if (is->show_mode != SHOW_MODE_VIDEO)\n<38> \n<39> update_sample_display(is, (int16_t *)is->audio_buf, audio_size);\n<40> \n<41> is->audio_buf_size = audio_size;\n<42> \n<43> }\n<44> \n<45> is->audio_buf_index = 0;\n<46> \n<47> }\n<48> \n<49> len1 = is->audio_buf_size - is->audio_buf_index;\n<50> \n<51> if (len1 > len)\n<52> \n<53> len1 = len;\n<54> \n<55> memcpy(stream, (uint8_t *)is->audio_buf + is->audio_buf_index, len1);\n<56> \n<57> len -= len1;\n<58> \n<59> stream += len1;\n<60> \n<61> is->audio_buf_index += len1;\n<62> \n<63> }\n<64> \n<65> bytes_per_sec = is->audio_tgt.freq * is->audio_tgt.channels * av_get_bytes_per_sample(is->audio_tgt.fmt);\n<66> \n<67> is->audio_write_buf_size = is->audio_buf_size - is->audio_buf_index;\n<68> \n<69> /* Let's assume the audio driver that is used by SDL has two periods. */\n<70> \n<71> is->audio_current_pts = is->audio_clock - (double)(2 * is->audio_hw_buf_size + is->audio_write_buf_size) / bytes_per_sec;\n<72> \n<73> is->audio_current_pts_drift = is->audio_current_pts - audio_callback_time / 1000000.0;\n<74> \n<75> check_external_clock_sync(is, is->audio_current_pts);\n<76> \n<77> }\n<78> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void dtls1_stop_timer ( SSL * s ) {\n<2> memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;\n<3> memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;\n<4> s -> d1 -> timeout_duration = 1 ;\n<5> BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;\n<6> dtls1_clear_record_buffer ( s ) ;\n<7> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void prom_set(uint32_t* prom_buf, int index, const char *string, ...)\n<2> \n<3> {\n<4> \n<5> va_list ap;\n<6> \n<7> int32_t table_addr;\n<8> \n<9> \n<10> \n<11> if (index >= ENVP_NB_ENTRIES)\n<12> \n<13> return;\n<14> \n<15> \n<16> \n<17> if (string == NULL) {\n<18> \n<19> prom_buf[index] = 0;\n<20> \n<21> return;\n<22> \n<23> }\n<24> \n<25> \n<26> \n<27> table_addr = sizeof(int32_t) * ENVP_NB_ENTRIES + index * ENVP_ENTRY_SIZE;\n<28> \n<29> prom_buf[index] = tswap32(ENVP_ADDR + table_addr);\n<30> \n<31> \n<32> \n<33> va_start(ap, string);\n<34> \n<35> vsnprintf((char *)prom_buf + table_addr, ENVP_ENTRY_SIZE, string, ap);\n<36> \n<37> va_end(ap);\n<38> \n<39> }\n<40> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_h264_execute_ref_pic_marking(H264Context *h, MMCO *mmco, int mmco_count)\n<2> \n<3> {\n<4> \n<5> int i, av_uninit(j);\n<6> \n<7> int current_ref_assigned = 0, err = 0;\n<8> \n<9> H264Picture *av_uninit(pic);\n<10> \n<11> \n<12> \n<13> if ((h->avctx->debug & FF_DEBUG_MMCO) && mmco_count == 0)\n<14> \n<15> av_log(h->avctx, AV_LOG_DEBUG, "no mmco here\n");\n<16> \n<17> \n<18> \n<19> for (i = 0; i < mmco_count; i++) {\n<20> \n<21> int av_uninit(structure), av_uninit(frame_num);\n<22> \n<23> if (h->avctx->debug & FF_DEBUG_MMCO)\n<24> \n<25> av_log(h->avctx, AV_LOG_DEBUG, "mmco:%d %d %d\n", h->mmco[i].opcode,\n<26> \n<27> h->mmco[i].short_pic_num, h->mmco[i].long_arg);\n<28> \n<29> \n<30> \n<31> if (mmco[i].opcode == MMCO_SHORT2UNUSED ||\n<32> \n<33> mmco[i].opcode == MMCO_SHORT2LONG) {\n<34> \n<35> frame_num = pic_num_extract(h, mmco[i].short_pic_num, &structure);\n<36> \n<37> pic       = find_short(h, frame_num, &j);\n<38> \n<39> if (!pic) {\n<40> \n<41> if (mmco[i].opcode != MMCO_SHORT2LONG ||\n<42> \n<43> !h->long_ref[mmco[i].long_arg]    ||\n<44> \n<45> h->long_ref[mmco[i].long_arg]->frame_num != frame_num) {\n<46> \n<47> av_log(h->avctx, AV_LOG_ERROR, "mmco: unref short failure\n");\n<48> \n<49> err = AVERROR_INVALIDDATA;\n<50> \n<51> }\n<52> \n<53> continue;\n<54> \n<55> }\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> switch (mmco[i].opcode) {\n<62> \n<63> case MMCO_SHORT2UNUSED:\n<64> \n<65> if (h->avctx->debug & FF_DEBUG_MMCO)\n<66> \n<67> av_log(h->avctx, AV_LOG_DEBUG, "mmco: unref short %d count %d\n",\n<68> \n<69> h->mmco[i].short_pic_num, h->short_ref_count);\n<70> \n<71> remove_short(h, frame_num, structure ^ PICT_FRAME);\n<72> \n<73> break;\n<74> \n<75> case MMCO_SHORT2LONG:\n<76> \n<77> if (h->long_ref[mmco[i].long_arg] != pic)\n<78> \n<79> remove_long(h, mmco[i].long_arg, 0);\n<80> \n<81> \n<82> \n<83> remove_short_at_index(h, j);\n<84> \n<85> h->long_ref[ mmco[i].long_arg ] = pic;\n<86> \n<87> if (h->long_ref[mmco[i].long_arg]) {\n<88> \n<89> h->long_ref[mmco[i].long_arg]->long_ref = 1;\n<90> \n<91> h->long_ref_count++;\n<92> \n<93> }\n<94> \n<95> break;\n<96> \n<97> case MMCO_LONG2UNUSED:\n<98> \n<99> j   = pic_num_extract(h, mmco[i].long_arg, &structure);\n<100> \n<101> pic = h->long_ref[j];\n<102> \n<103> if (pic) {\n<104> \n<105> remove_long(h, j, structure ^ PICT_FRAME);\n<106> \n<107> } else if (h->avctx->debug & FF_DEBUG_MMCO)\n<108> \n<109> av_log(h->avctx, AV_LOG_DEBUG, "mmco: unref long failure\n");\n<110> \n<111> break;\n<112> \n<113> case MMCO_LONG:\n<114> \n<115> // Comment below left from previous code as it is an interresting note.\n<116> \n<117> /* First field in pair is in short term list or\n<118> \n<119> * at a different long term index.\n<120> \n<121> * This is not allowed; see 7.4.3.3, notes 2 and 3.\n<122> \n<123> * Report the problem and keep the pair where it is,\n<124> \n<125> * and mark this field valid.\n<126> \n<127> */\n<128> \n<129> if (h->short_ref[0] == h->cur_pic_ptr)\n<130> \n<131> remove_short_at_index(h, 0);\n<132> \n<133> \n<134> \n<135> /* make sure the current picture is not already assigned as a long ref */\n<136> \n<137> if (h->cur_pic_ptr->long_ref) {\n<138> \n<139> for (j = 0; j < FF_ARRAY_ELEMS(h->long_ref); j++) {\n<140> \n<141> if (h->long_ref[j] == h->cur_pic_ptr)\n<142> \n<143> remove_long(h, j, 0);\n<144> \n<145> }\n<146> \n<147> }\n<148> \n<149> \n<150> \n<151> \n<152> \n<153> if (h->long_ref[mmco[i].long_arg] != h->cur_pic_ptr) {\n<154> \n<155> remove_long(h, mmco[i].long_arg, 0);\n<156> \n<157> \n<158> \n<159> h->long_ref[mmco[i].long_arg]           = h->cur_pic_ptr;\n<160> \n<161> h->long_ref[mmco[i].long_arg]->long_ref = 1;\n<162> \n<163> h->long_ref_count++;\n<164> \n<165> }\n<166> \n<167> \n<168> \n<169> h->cur_pic_ptr->reference |= h->picture_structure;\n<170> \n<171> current_ref_assigned = 1;\n<172> \n<173> break;\n<174> \n<175> case MMCO_SET_MAX_LONG:\n<176> \n<177> assert(mmco[i].long_arg <= 16);\n<178> \n<179> // just remove the long term which index is greater than new max\n<180> \n<181> for (j = mmco[i].long_arg; j < 16; j++) {\n<182> \n<183> remove_long(h, j, 0);\n<184> \n<185> }\n<186> \n<187> break;\n<188> \n<189> case MMCO_RESET:\n<190> \n<191> while (h->short_ref_count) {\n<192> \n<193> remove_short(h, h->short_ref[0]->frame_num, 0);\n<194> \n<195> }\n<196> \n<197> for (j = 0; j < 16; j++) {\n<198> \n<199> remove_long(h, j, 0);\n<200> \n<201> }\n<202> \n<203> h->frame_num  = h->cur_pic_ptr->frame_num = 0;\n<204> \n<205> h->mmco_reset = 1;\n<206> \n<207> h->cur_pic_ptr->mmco_reset = 1;\n<208> \n<209> break;\n<210> \n<211> default: assert(0);\n<212> \n<213> }\n<214> \n<215> }\n<216> \n<217> \n<218> \n<219> if (!current_ref_assigned) {\n<220> \n<221> /* Second field of complementary field pair; the first field of\n<222> \n<223> * which is already referenced. If short referenced, it\n<224> \n<225> * should be first entry in short_ref. If not, it must exist\n<226> \n<227> * in long_ref; trying to put it on the short list here is an\n<228> \n<229> * error in the encoded bit stream (ref: 7.4.3.3, NOTE 2 and 3).\n<230> \n<231> */\n<232> \n<233> if (h->short_ref_count && h->short_ref[0] == h->cur_pic_ptr) {\n<234> \n<235> /* Just mark the second field valid */\n<236> \n<237> h->cur_pic_ptr->reference = PICT_FRAME;\n<238> \n<239> } else if (h->cur_pic_ptr->long_ref) {\n<240> \n<241> av_log(h->avctx, AV_LOG_ERROR, "illegal short term reference "\n<242> \n<243> "assignment for second field "\n<244> \n<245> "in complementary field pair "\n<246> \n<247> "(first field is long term)\n");\n<248> \n<249> err = AVERROR_INVALIDDATA;\n<250> \n<251> } else {\n<252> \n<253> pic = remove_short(h, h->cur_pic_ptr->frame_num, 0);\n<254> \n<255> if (pic) {\n<256> \n<257> av_log(h->avctx, AV_LOG_ERROR, "illegal short term buffer state detected\n");\n<258> \n<259> err = AVERROR_INVALIDDATA;\n<260> \n<261> }\n<262> \n<263> \n<264> \n<265> if (h->short_ref_count)\n<266> \n<267> memmove(&h->short_ref[1], &h->short_ref[0],\n<268> \n<269> h->short_ref_count * sizeof(H264Picture*));\n<270> \n<271> \n<272> \n<273> h->short_ref[0] = h->cur_pic_ptr;\n<274> \n<275> h->short_ref_count++;\n<276> \n<277> h->cur_pic_ptr->reference |= h->picture_structure;\n<278> \n<279> }\n<280> \n<281> }\n<282> \n<283> \n<284> \n<285> if (h->long_ref_count + h->short_ref_count -\n<286> \n<287> (h->short_ref[0] == h->cur_pic_ptr) > h->sps.ref_frame_count) {\n<288> \n<289> \n<290> \n<291> /* We have too many reference frames, probably due to corrupted\n<292> \n<293> * stream. Need to discard one frame. Prevents overrun of the\n<294> \n<295> * short_ref and long_ref buffers.\n<296> \n<297> */\n<298> \n<299> av_log(h->avctx, AV_LOG_ERROR,\n<300> \n<301> "number of reference frames (%d+%d) exceeds max (%d; probably "\n<302> \n<303> "corrupt input), discarding one\n",\n<304> \n<305> h->long_ref_count, h->short_ref_count, h->sps.ref_frame_count);\n<306> \n<307> err = AVERROR_INVALIDDATA;\n<308> \n<309> \n<310> \n<311> if (h->long_ref_count && !h->short_ref_count) {\n<312> \n<313> for (i = 0; i < 16; ++i)\n<314> \n<315> if (h->long_ref[i])\n<316> \n<317> break;\n<318> \n<319> \n<320> \n<321> assert(i < 16);\n<322> \n<323> remove_long(h, i, 0);\n<324> \n<325> } else {\n<326> \n<327> pic = h->short_ref[h->short_ref_count - 1];\n<328> \n<329> remove_short(h, pic->frame_num, 0);\n<330> \n<331> }\n<332> \n<333> }\n<334> \n<335> \n<336> \n<337> print_short_term(h);\n<338> \n<339> print_long_term(h);\n<340> \n<341> return (h->avctx->err_recognition & AV_EF_EXPLODE) ? err : 0;\n<342> \n<343> }\n<344> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void net_socket_send(void *opaque)\n<2> \n<3> {\n<4> \n<5> NetSocketState *s = opaque;\n<6> \n<7> int size, err;\n<8> \n<9> unsigned l;\n<10> \n<11> uint8_t buf1[NET_BUFSIZE];\n<12> \n<13> const uint8_t *buf;\n<14> \n<15> \n<16> \n<17> size = qemu_recv(s->fd, buf1, sizeof(buf1), 0);\n<18> \n<19> if (size < 0) {\n<20> \n<21> err = socket_error();\n<22> \n<23> if (err != EWOULDBLOCK)\n<24> \n<25> goto eoc;\n<26> \n<27> } else if (size == 0) {\n<28> \n<29> /* end of connection */\n<30> \n<31> eoc:\n<32> \n<33> net_socket_read_poll(s, false);\n<34> \n<35> net_socket_write_poll(s, false);\n<36> \n<37> if (s->listen_fd != -1) {\n<38> \n<39> qemu_set_fd_handler(s->listen_fd, net_socket_accept, NULL, s);\n<40> \n<41> }\n<42> \n<43> closesocket(s->fd);\n<44> \n<45> \n<46> \n<47> s->fd = -1;\n<48> \n<49> s->state = 0;\n<50> \n<51> s->index = 0;\n<52> \n<53> s->packet_len = 0;\n<54> \n<55> s->nc.link_down = true;\n<56> \n<57> memset(s->buf, 0, sizeof(s->buf));\n<58> \n<59> memset(s->nc.info_str, 0, sizeof(s->nc.info_str));\n<60> \n<61> \n<62> \n<63> return;\n<64> \n<65> }\n<66> \n<67> buf = buf1;\n<68> \n<69> while (size > 0) {\n<70> \n<71> /* reassemble a packet from the network */\n<72> \n<73> switch(s->state) {\n<74> \n<75> case 0:\n<76> \n<77> l = 4 - s->index;\n<78> \n<79> if (l > size)\n<80> \n<81> l = size;\n<82> \n<83> memcpy(s->buf + s->index, buf, l);\n<84> \n<85> buf += l;\n<86> \n<87> size -= l;\n<88> \n<89> s->index += l;\n<90> \n<91> if (s->index == 4) {\n<92> \n<93> /* got length */\n<94> \n<95> s->packet_len = ntohl(*(uint32_t *)s->buf);\n<96> \n<97> s->index = 0;\n<98> \n<99> s->state = 1;\n<100> \n<101> }\n<102> \n<103> break;\n<104> \n<105> case 1:\n<106> \n<107> l = s->packet_len - s->index;\n<108> \n<109> if (l > size)\n<110> \n<111> l = size;\n<112> \n<113> if (s->index + l <= sizeof(s->buf)) {\n<114> \n<115> memcpy(s->buf + s->index, buf, l);\n<116> \n<117> } else {\n<118> \n<119> fprintf(stderr, "serious error: oversized packet received,"\n<120> \n<121> "connection terminated.\n");\n<122> \n<123> s->state = 0;\n<124> \n<125> goto eoc;\n<126> \n<127> }\n<128> \n<129> \n<130> \n<131> s->index += l;\n<132> \n<133> buf += l;\n<134> \n<135> size -= l;\n<136> \n<137> if (s->index >= s->packet_len) {\n<138> \n<139> qemu_send_packet(&s->nc, s->buf, s->packet_len);\n<140> \n<141> s->index = 0;\n<142> \n<143> s->state = 0;\n<144> \n<145> }\n<146> \n<147> break;\n<148> \n<149> }\n<150> \n<151> }\n<152> \n<153> }\n<154> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int s390_ipl_init(SysBusDevice *dev)\n<2> \n<3> {\n<4> \n<5> S390IPLState *ipl = S390_IPL(dev);\n<6> \n<7> uint64_t pentry = KERN_IMAGE_START;\n<8> \n<9> int kernel_size;\n<10> \n<11> \n<12> \n<13> int bios_size;\n<14> \n<15> char *bios_filename;\n<16> \n<17> \n<18> \n<19> /*\n<20> \n<21> * Always load the bios if it was enforced,\n<22> \n<23> * even if an external kernel has been defined.\n<24> \n<25> */\n<26> \n<27> if (!ipl->kernel || ipl->enforce_bios) {\n<28> \n<29> uint64_t fwbase = (MIN(ram_size, 0x80000000U) - 0x200000) & ~0xffffUL;\n<30> \n<31> \n<32> \n<33> if (bios_name == NULL) {\n<34> \n<35> bios_name = ipl->firmware;\n<36> \n<37> }\n<38> \n<39> \n<40> \n<41> bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<42> \n<43> if (bios_filename == NULL) {\n<44> \n<45> hw_error("could not find stage1 bootloader\n");\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> bios_size = load_elf(bios_filename, bios_translate_addr, &fwbase,\n<52> \n<53> &ipl->bios_start_addr, NULL, NULL, 1,\n<54> \n<55> ELF_MACHINE, 0);\n<56> \n<57> if (bios_size > 0) {\n<58> \n<59> /* Adjust ELF start address to final location */\n<60> \n<61> ipl->bios_start_addr += fwbase;\n<62> \n<63> } else {\n<64> \n<65> /* Try to load non-ELF file (e.g. s390-zipl.rom) */\n<66> \n<67> bios_size = load_image_targphys(bios_filename, ZIPL_IMAGE_START,\n<68> \n<69> 4096);\n<70> \n<71> ipl->bios_start_addr = ZIPL_IMAGE_START;\n<72> \n<73> if (bios_size > 4096) {\n<74> \n<75> hw_error("stage1 bootloader is > 4k\n");\n<76> \n<77> }\n<78> \n<79> }\n<80> \n<81> g_free(bios_filename);\n<82> \n<83> \n<84> \n<85> if (bios_size == -1) {\n<86> \n<87> hw_error("could not load bootloader '%s'\n", bios_name);\n<88> \n<89> }\n<90> \n<91> \n<92> \n<93> /* default boot target is the bios */\n<94> \n<95> ipl->start_addr = ipl->bios_start_addr;\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> if (ipl->kernel) {\n<102> \n<103> kernel_size = load_elf(ipl->kernel, NULL, NULL, &pentry, NULL,\n<104> \n<105> NULL, 1, ELF_MACHINE, 0);\n<106> \n<107> if (kernel_size < 0) {\n<108> \n<109> kernel_size = load_image_targphys(ipl->kernel, 0, ram_size);\n<110> \n<111> }\n<112> \n<113> if (kernel_size < 0) {\n<114> \n<115> fprintf(stderr, "could not load kernel '%s'\n", ipl->kernel);\n<116> \n<117> return -1;\n<118> \n<119> }\n<120> \n<121> /*\n<122> \n<123> * Is it a Linux kernel (starting at 0x10000)? If yes, we fill in the\n<124> \n<125> * kernel parameters here as well. Note: For old kernels (up to 3.2)\n<126> \n<127> * we can not rely on the ELF entry point - it was 0x800 (the SALIPL\n<128> \n<129> * loader) and it won't work. For this case we force it to 0x10000, too.\n<130> \n<131> */\n<132> \n<133> if (pentry == KERN_IMAGE_START || pentry == 0x800) {\n<134> \n<135> ipl->start_addr = KERN_IMAGE_START;\n<136> \n<137> /* Overwrite parameters in the kernel image, which are "rom" */\n<138> \n<139> strcpy(rom_ptr(KERN_PARM_AREA), ipl->cmdline);\n<140> \n<141> } else {\n<142> \n<143> ipl->start_addr = pentry;\n<144> \n<145> }\n<146> \n<147> \n<148> \n<149> if (ipl->initrd) {\n<150> \n<151> ram_addr_t initrd_offset;\n<152> \n<153> int initrd_size;\n<154> \n<155> \n<156> \n<157> initrd_offset = INITRD_START;\n<158> \n<159> while (kernel_size + 0x100000 > initrd_offset) {\n<160> \n<161> initrd_offset += 0x100000;\n<162> \n<163> }\n<164> \n<165> initrd_size = load_image_targphys(ipl->initrd, initrd_offset,\n<166> \n<167> ram_size - initrd_offset);\n<168> \n<169> if (initrd_size == -1) {\n<170> \n<171> fprintf(stderr, "qemu: could not load initrd '%s'\n",\n<172> \n<173> ipl->initrd);\n<174> \n<175> exit(1);\n<176> \n<177> }\n<178> \n<179> \n<180> \n<181> /*\n<182> \n<183> * we have to overwrite values in the kernel image,\n<184> \n<185> * which are "rom"\n<186> \n<187> */\n<188> \n<189> stq_p(rom_ptr(INITRD_PARM_START), initrd_offset);\n<190> \n<191> stq_p(rom_ptr(INITRD_PARM_SIZE), initrd_size);\n<192> \n<193> }\n<194> \n<195> }\n<196> \n<197> return 0;\n<198> \n<199> }\n<200> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_parse_packing_format(int *ret, const char *arg, void *log_ctx)\n<2> \n<3> {\n<4> \n<5> char *tail;\n<6> \n<7> int planar = strtol(arg, &tail, 10);\n<8> \n<9> if (*tail) {\n<10> \n<11> planar = (strcmp(arg, "packed") != 0);\n<12> \n<13> } else if (planar != 0 && planar != 1) {\n<14> \n<15> av_log(log_ctx, AV_LOG_ERROR, "Invalid packing format '%s'\n", arg);\n<16> \n<17> return AVERROR(EINVAL);\n<18> \n<19> }\n<20> \n<21> *ret = planar;\n<22> \n<23> return 0;\n<24> \n<25> }\n<26> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void open_help(void)\n<2> \n<3> {\n<4> \n<5> printf(\n<6> \n<7> "\n"\n<8> \n<9> " opens a new file in the requested mode\n"\n<10> \n<11> "\n"\n<12> \n<13> " Example:\n"\n<14> \n<15> " 'open -Cn /tmp/data' - creates/opens data file read-write and uncached\n"\n<16> \n<17> "\n"\n<18> \n<19> " Opens a file for subsequent use by all of the other qemu-io commands.\n"\n<20> \n<21> " -r, -- open file read-only\n"\n<22> \n<23> " -s, -- use snapshot file\n"\n<24> \n<25> " -n, -- disable host cache\n"\n<26> \n<27> " -o, -- options to be given to the block driver"\n<28> \n<29> "\n");\n<30> \n<31> }\n<32> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int check_refcounts_l2(BlockDriverState *bs, BdrvCheckResult *res,\n<2> \n<3> uint16_t *refcount_table, int refcount_table_size, int64_t l2_offset,\n<4> \n<5> int check_copied)\n<6> \n<7> {\n<8> \n<9> BDRVQcowState *s = bs->opaque;\n<10> \n<11> uint64_t *l2_table, l2_entry;\n<12> \n<13> int i, l2_size, nb_csectors, refcount;\n<14> \n<15> \n<16> \n<17> /* Read L2 table from disk */\n<18> \n<19> l2_size = s->l2_size * sizeof(uint64_t);\n<20> \n<21> l2_table = g_malloc(l2_size);\n<22> \n<23> \n<24> \n<25> if (bdrv_pread(bs->file, l2_offset, l2_table, l2_size) != l2_size)\n<26> \n<27> goto fail;\n<28> \n<29> \n<30> \n<31> /* Do the actual checks */\n<32> \n<33> for(i = 0; i < s->l2_size; i++) {\n<34> \n<35> l2_entry = be64_to_cpu(l2_table[i]);\n<36> \n<37> \n<38> \n<39> switch (qcow2_get_cluster_type(l2_entry)) {\n<40> \n<41> case QCOW2_CLUSTER_COMPRESSED:\n<42> \n<43> /* Compressed clusters don't have QCOW_OFLAG_COPIED */\n<44> \n<45> if (l2_entry & QCOW_OFLAG_COPIED) {\n<46> \n<47> fprintf(stderr, "ERROR: cluster %" PRId64 ": "\n<48> \n<49> "copied flag must never be set for compressed "\n<50> \n<51> "clusters\n", l2_entry >> s->cluster_bits);\n<52> \n<53> l2_entry &= ~QCOW_OFLAG_COPIED;\n<54> \n<55> res->corruptions++;\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> /* Mark cluster as used */\n<62> \n<63> nb_csectors = ((l2_entry >> s->csize_shift) &\n<64> \n<65> s->csize_mask) + 1;\n<66> \n<67> l2_entry &= s->cluster_offset_mask;\n<68> \n<69> inc_refcounts(bs, res, refcount_table, refcount_table_size,\n<70> \n<71> l2_entry & ~511, nb_csectors * 512);\n<72> \n<73> break;\n<74> \n<75> \n<76> \n<77> case QCOW2_CLUSTER_ZERO:\n<78> \n<79> if ((l2_entry & L2E_OFFSET_MASK) == 0) {\n<80> \n<81> break;\n<82> \n<83> }\n<84> \n<85> /* fall through */\n<86> \n<87> \n<88> \n<89> case QCOW2_CLUSTER_NORMAL:\n<90> \n<91> {\n<92> \n<93> /* QCOW_OFLAG_COPIED must be set iff refcount == 1 */\n<94> \n<95> uint64_t offset = l2_entry & L2E_OFFSET_MASK;\n<96> \n<97> \n<98> \n<99> if (check_copied) {\n<100> \n<101> refcount = get_refcount(bs, offset >> s->cluster_bits);\n<102> \n<103> if (refcount < 0) {\n<104> \n<105> fprintf(stderr, "Can't get refcount for offset %"\n<106> \n<107> PRIx64 ": %s\n", l2_entry, strerror(-refcount));\n<108> \n<109> goto fail;\n<110> \n<111> }\n<112> \n<113> if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) {\n<114> \n<115> fprintf(stderr, "ERROR OFLAG_COPIED: offset=%"\n<116> \n<117> PRIx64 " refcount=%d\n", l2_entry, refcount);\n<118> \n<119> res->corruptions++;\n<120> \n<121> }\n<122> \n<123> }\n<124> \n<125> \n<126> \n<127> /* Mark cluster as used */\n<128> \n<129> inc_refcounts(bs, res, refcount_table,refcount_table_size,\n<130> \n<131> offset, s->cluster_size);\n<132> \n<133> \n<134> \n<135> /* Correct offsets are cluster aligned */\n<136> \n<137> if (offset & (s->cluster_size - 1)) {\n<138> \n<139> fprintf(stderr, "ERROR offset=%" PRIx64 ": Cluster is not "\n<140> \n<141> "properly aligned; L2 entry corrupted.\n", offset);\n<142> \n<143> res->corruptions++;\n<144> \n<145> }\n<146> \n<147> break;\n<148> \n<149> }\n<150> \n<151> \n<152> \n<153> case QCOW2_CLUSTER_UNALLOCATED:\n<154> \n<155> break;\n<156> \n<157> \n<158> \n<159> default:\n<160> \n<161> abort();\n<162> \n<163> }\n<164> \n<165> }\n<166> \n<167> \n<168> \n<169> g_free(l2_table);\n<170> \n<171> return 0;\n<172> \n<173> \n<174> \n<175> fail:\n<176> \n<177> fprintf(stderr, "ERROR: I/O error in check_refcounts_l2\n");\n<178> \n<179> g_free(l2_table);\n<180> \n<181> return -EIO;\n<182> \n<183> }\n<184> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> truncate_f(int argc, char **argv)\n<2> \n<3> {\n<4> \n<5> int64_t offset;\n<6> \n<7> int ret;\n<8> \n<9> \n<10> \n<11> offset = cvtnum(argv[1]);\n<12> \n<13> if (offset < 0) {\n<14> \n<15> printf("non-numeric truncate argument -- %s\n", argv[1]);\n<16> \n<17> return 0;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> ret = bdrv_truncate(bs, offset);\n<24> \n<25> if (ret < 0) {\n<26> \n<27> printf("truncate: %s", strerror(ret));\n<28> \n<29> return 0;\n<30> \n<31> }\n<32> \n<33> \n<34> \n<35> return 0;\n<36> \n<37> }\n<38> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void uninit(struct vf_instance *vf)\n<2> \n<3> {\n<4> \n<5> free(vf->priv);\n<6> \n<7> }\n<8> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> struct XenDevice *xen_be_find_xendev(const char *type, int dom, int dev)\n<2> \n<3> {\n<4> \n<5> struct XenDevice *xendev;\n<6> \n<7> \n<8> \n<9> TAILQ_FOREACH(xendev, &xendevs, next) {\n<10> \n<11> if (xendev->dom != dom)\n<12> \n<13> continue;\n<14> \n<15> if (xendev->dev != dev)\n<16> \n<17> continue;\n<18> \n<19> if (strcmp(xendev->type, type) != 0)\n<20> \n<21> continue;\n<22> \n<23> return xendev;\n<24> \n<25> }\n<26> \n<27> return NULL;\n<28> \n<29> }\n<30> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int flic_read_header(AVFormatContext *s,\n<2> \n<3> AVFormatParameters *ap)\n<4> \n<5> {\n<6> \n<7> FlicDemuxContext *flic = s->priv_data;\n<8> \n<9> ByteIOContext *pb = &s->pb;\n<10> \n<11> unsigned char header[FLIC_HEADER_SIZE];\n<12> \n<13> AVStream *st;\n<14> \n<15> int speed;\n<16> \n<17> int magic_number;\n<18> \n<19> \n<20> \n<21> flic->pts = 0;\n<22> \n<23> \n<24> \n<25> /* load the whole header and pull out the width and height */\n<26> \n<27> if (get_buffer(pb, header, FLIC_HEADER_SIZE) != FLIC_HEADER_SIZE)\n<28> \n<29> return AVERROR(EIO);\n<30> \n<31> \n<32> \n<33> magic_number = AV_RL16(&header[4]);\n<34> \n<35> speed = AV_RL32(&header[0x10]);\n<36> \n<37> \n<38> \n<39> /* initialize the decoder streams */\n<40> \n<41> st = av_new_stream(s, 0);\n<42> \n<43> if (!st)\n<44> \n<45> return AVERROR(ENOMEM);\n<46> \n<47> flic->video_stream_index = st->index;\n<48> \n<49> st->codec->codec_type = CODEC_TYPE_VIDEO;\n<50> \n<51> st->codec->codec_id = CODEC_ID_FLIC;\n<52> \n<53> st->codec->codec_tag = 0;  /* no fourcc */\n<54> \n<55> st->codec->width = AV_RL16(&header[0x08]);\n<56> \n<57> st->codec->height = AV_RL16(&header[0x0A]);\n<58> \n<59> \n<60> \n<61> if (!st->codec->width || !st->codec->height)\n<62> \n<63> return AVERROR_INVALIDDATA;\n<64> \n<65> \n<66> \n<67> /* send over the whole 128-byte FLIC header */\n<68> \n<69> st->codec->extradata_size = FLIC_HEADER_SIZE;\n<70> \n<71> st->codec->extradata = av_malloc(FLIC_HEADER_SIZE);\n<72> \n<73> memcpy(st->codec->extradata, header, FLIC_HEADER_SIZE);\n<74> \n<75> \n<76> \n<77> av_set_pts_info(st, 33, 1, 90000);\n<78> \n<79> \n<80> \n<81> /* Time to figure out the framerate: If there is a FLIC chunk magic\n<82> \n<83> * number at offset 0x10, assume this is from the Bullfrog game,\n<84> \n<85> * Magic Carpet. */\n<86> \n<87> if (AV_RL16(&header[0x10]) == FLIC_CHUNK_MAGIC_1) {\n<88> \n<89> \n<90> \n<91> flic->frame_pts_inc = FLIC_MC_PTS_INC;\n<92> \n<93> \n<94> \n<95> /* rewind the stream since the first chunk is at offset 12 */\n<96> \n<97> url_fseek(pb, 12, SEEK_SET);\n<98> \n<99> \n<100> \n<101> /* send over abbreviated FLIC header chunk */\n<102> \n<103> av_free(st->codec->extradata);\n<104> \n<105> st->codec->extradata_size = 12;\n<106> \n<107> st->codec->extradata = av_malloc(12);\n<108> \n<109> memcpy(st->codec->extradata, header, 12);\n<110> \n<111> \n<112> \n<113> } else if (magic_number == FLIC_FILE_MAGIC_1) {\n<114> \n<115> /*\n<116> \n<117> * in this case, the speed (n) is number of 1/70s ticks between frames:\n<118> \n<119> *\n<120> \n<121> *    pts        n * frame #\n<122> \n<123> *  --------  =  -----------  => pts = n * (90000/70) * frame #\n<124> \n<125> *   90000           70\n<126> \n<127> *\n<128> \n<129> *  therefore, the frame pts increment = n * 1285.7\n<130> \n<131> */\n<132> \n<133> flic->frame_pts_inc = speed * 1285.7;\n<134> \n<135> } else if ((magic_number == FLIC_FILE_MAGIC_2) ||\n<136> \n<137> (magic_number == FLIC_FILE_MAGIC_3)) {\n<138> \n<139> /*\n<140> \n<141> * in this case, the speed (n) is number of milliseconds between frames:\n<142> \n<143> *\n<144> \n<145> *    pts        n * frame #\n<146> \n<147> *  --------  =  -----------  => pts = n * 90 * frame #\n<148> \n<149> *   90000          1000\n<150> \n<151> *\n<152> \n<153> *  therefore, the frame pts increment = n * 90\n<154> \n<155> */\n<156> \n<157> flic->frame_pts_inc = speed * 90;\n<158> \n<159> } else {\n<160> \n<161> av_log(s, AV_LOG_INFO, "Invalid or unsupported magic chunk in file\n");\n<162> \n<163> return AVERROR_INVALIDDATA;\n<164> \n<165> }\n<166> \n<167> \n<168> \n<169> if (flic->frame_pts_inc == 0)\n<170> \n<171> flic->frame_pts_inc = FLIC_DEFAULT_PTS_INC;\n<172> \n<173> \n<174> \n<175> return 0;\n<176> \n<177> }\n<178> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static BusState *qbus_find_recursive(BusState *bus, const char *name,\n<2> \n<3> const char *bus_typename)\n<4> \n<5> {\n<6> \n<7> BusChild *kid;\n<8> \n<9> BusState *child, *ret;\n<10> \n<11> int match = 1;\n<12> \n<13> \n<14> \n<15> if (name && (strcmp(bus->name, name) != 0)) {\n<16> \n<17> match = 0;\n<18> \n<19> }\n<20> \n<21> if (bus_typename &&\n<22> \n<23> (strcmp(object_get_typename(OBJECT(bus)), bus_typename) != 0)) {\n<24> \n<25> match = 0;\n<26> \n<27> }\n<28> \n<29> if (match) {\n<30> \n<31> return bus;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> QTAILQ_FOREACH(kid, &bus->children, sibling) {\n<38> \n<39> DeviceState *dev = kid->child;\n<40> \n<41> QLIST_FOREACH(child, &dev->child_bus, sibling) {\n<42> \n<43> ret = qbus_find_recursive(child, name, bus_typename);\n<44> \n<45> if (ret) {\n<46> \n<47> return ret;\n<48> \n<49> }\n<50> \n<51> }\n<52> \n<53> }\n<54> \n<55> return NULL;\n<56> \n<57> }\n<58> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static AVStream * parse_media_type(AVFormatContext *s, AVStream *st, int sid,\n<2> \n<3> ff_asf_guid mediatype, ff_asf_guid subtype,\n<4> \n<5> ff_asf_guid formattype, int size)\n<6> \n<7> {\n<8> \n<9> WtvContext *wtv = s->priv_data;\n<10> \n<11> AVIOContext *pb = wtv->pb;\n<12> \n<13> if (!ff_guidcmp(subtype, ff_mediasubtype_cpfilters_processed) &&\n<14> \n<15> !ff_guidcmp(formattype, ff_format_cpfilters_processed)) {\n<16> \n<17> ff_asf_guid actual_subtype;\n<18> \n<19> ff_asf_guid actual_formattype;\n<20> \n<21> \n<22> \n<23> if (size < 32) {\n<24> \n<25> av_log(s, AV_LOG_WARNING, "format buffer size underflow\n");\n<26> \n<27> avio_skip(pb, size);\n<28> \n<29> return NULL;\n<30> \n<31> }\n<32> \n<33> \n<34> \n<35> avio_skip(pb, size - 32);\n<36> \n<37> ff_get_guid(pb, &actual_subtype);\n<38> \n<39> ff_get_guid(pb, &actual_formattype);\n<40> \n<41> avio_seek(pb, -size, SEEK_CUR);\n<42> \n<43> \n<44> \n<45> st = parse_media_type(s, st, sid, mediatype, actual_subtype, actual_formattype, size - 32);\n<46> \n<47> avio_skip(pb, 32);\n<48> \n<49> return st;\n<50> \n<51> } else if (!ff_guidcmp(mediatype, ff_mediatype_audio)) {\n<52> \n<53> st = new_stream(s, st, sid, AVMEDIA_TYPE_AUDIO);\n<54> \n<55> if (!st)\n<56> \n<57> return NULL;\n<58> \n<59> if (!ff_guidcmp(formattype, ff_format_waveformatex)) {\n<60> \n<61> int ret = ff_get_wav_header(pb, st->codec, size);\n<62> \n<63> if (ret < 0)\n<64> \n<65> return NULL;\n<66> \n<67> } else {\n<68> \n<69> if (ff_guidcmp(formattype, ff_format_none))\n<70> \n<71> av_log(s, AV_LOG_WARNING, "unknown formattype:"FF_PRI_GUID"\n", FF_ARG_GUID(formattype));\n<72> \n<73> avio_skip(pb, size);\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> if (!memcmp(subtype + 4, (const uint8_t[]){FF_MEDIASUBTYPE_BASE_GUID}, 12)) {\n<80> \n<81> st->codec->codec_id = ff_wav_codec_get_id(AV_RL32(subtype), st->codec->bits_per_coded_sample);\n<82> \n<83> } else if (!ff_guidcmp(subtype, mediasubtype_mpeg1payload)) {\n<84> \n<85> if (st->codec->extradata && st->codec->extradata_size >= 22)\n<86> \n<87> parse_mpeg1waveformatex(st);\n<88> \n<89> else\n<90> \n<91> av_log(s, AV_LOG_WARNING, "MPEG1WAVEFORMATEX underflow\n");\n<92> \n<93> } else {\n<94> \n<95> st->codec->codec_id = ff_codec_guid_get_id(ff_codec_wav_guids, subtype);\n<96> \n<97> if (st->codec->codec_id == AV_CODEC_ID_NONE)\n<98> \n<99> av_log(s, AV_LOG_WARNING, "unknown subtype:"FF_PRI_GUID"\n", FF_ARG_GUID(subtype));\n<100> \n<101> }\n<102> \n<103> return st;\n<104> \n<105> } else if (!ff_guidcmp(mediatype, ff_mediatype_video)) {\n<106> \n<107> st = new_stream(s, st, sid, AVMEDIA_TYPE_VIDEO);\n<108> \n<109> if (!st)\n<110> \n<111> return NULL;\n<112> \n<113> if (!ff_guidcmp(formattype, ff_format_videoinfo2)) {\n<114> \n<115> int consumed = parse_videoinfoheader2(s, st);\n<116> \n<117> avio_skip(pb, FFMAX(size - consumed, 0));\n<118> \n<119> } else if (!ff_guidcmp(formattype, ff_format_mpeg2_video)) {\n<120> \n<121> int consumed = parse_videoinfoheader2(s, st);\n<122> \n<123> int count;\n<124> \n<125> avio_skip(pb, 4);\n<126> \n<127> count = avio_rl32(pb);\n<128> \n<129> avio_skip(pb, 12);\n<130> \n<131> if (count && ff_get_extradata(st->codec, pb, count) < 0) {\n<132> \n<133> ff_free_stream(s, st);\n<134> \n<135> return NULL;\n<136> \n<137> }\n<138> \n<139> consumed += 20 + count;\n<140> \n<141> avio_skip(pb, FFMAX(size - consumed, 0));\n<142> \n<143> } else {\n<144> \n<145> if (ff_guidcmp(formattype, ff_format_none))\n<146> \n<147> av_log(s, AV_LOG_WARNING, "unknown formattype:"FF_PRI_GUID"\n", FF_ARG_GUID(formattype));\n<148> \n<149> avio_skip(pb, size);\n<150> \n<151> }\n<152> \n<153> \n<154> \n<155> if (!memcmp(subtype + 4, (const uint8_t[]){FF_MEDIASUBTYPE_BASE_GUID}, 12)) {\n<156> \n<157> st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, AV_RL32(subtype));\n<158> \n<159> } else {\n<160> \n<161> st->codec->codec_id = ff_codec_guid_get_id(ff_video_guids, subtype);\n<162> \n<163> }\n<164> \n<165> if (st->codec->codec_id == AV_CODEC_ID_NONE)\n<166> \n<167> av_log(s, AV_LOG_WARNING, "unknown subtype:"FF_PRI_GUID"\n", FF_ARG_GUID(subtype));\n<168> \n<169> return st;\n<170> \n<171> } else if (!ff_guidcmp(mediatype, mediatype_mpeg2_pes) &&\n<172> \n<173> !ff_guidcmp(subtype, mediasubtype_dvb_subtitle)) {\n<174> \n<175> st = new_stream(s, st, sid, AVMEDIA_TYPE_SUBTITLE);\n<176> \n<177> if (!st)\n<178> \n<179> return NULL;\n<180> \n<181> if (ff_guidcmp(formattype, ff_format_none))\n<182> \n<183> av_log(s, AV_LOG_WARNING, "unknown formattype:"FF_PRI_GUID"\n", FF_ARG_GUID(formattype));\n<184> \n<185> avio_skip(pb, size);\n<186> \n<187> st->codec->codec_id = AV_CODEC_ID_DVB_SUBTITLE;\n<188> \n<189> return st;\n<190> \n<191> } else if (!ff_guidcmp(mediatype, mediatype_mstvcaption) &&\n<192> \n<193> (!ff_guidcmp(subtype, mediasubtype_teletext) || !ff_guidcmp(subtype, mediasubtype_dtvccdata))) {\n<194> \n<195> st = new_stream(s, st, sid, AVMEDIA_TYPE_SUBTITLE);\n<196> \n<197> if (!st)\n<198> \n<199> return NULL;\n<200> \n<201> if (ff_guidcmp(formattype, ff_format_none))\n<202> \n<203> av_log(s, AV_LOG_WARNING, "unknown formattype:"FF_PRI_GUID"\n", FF_ARG_GUID(formattype));\n<204> \n<205> avio_skip(pb, size);\n<206> \n<207> st->codec->codec_id = !ff_guidcmp(subtype, mediasubtype_teletext) ? AV_CODEC_ID_DVB_TELETEXT : AV_CODEC_ID_EIA_608;\n<208> \n<209> return st;\n<210> \n<211> } else if (!ff_guidcmp(mediatype, mediatype_mpeg2_sections) &&\n<212> \n<213> !ff_guidcmp(subtype, mediasubtype_mpeg2_sections)) {\n<214> \n<215> if (ff_guidcmp(formattype, ff_format_none))\n<216> \n<217> av_log(s, AV_LOG_WARNING, "unknown formattype:"FF_PRI_GUID"\n", FF_ARG_GUID(formattype));\n<218> \n<219> avio_skip(pb, size);\n<220> \n<221> return NULL;\n<222> \n<223> }\n<224> \n<225> \n<226> \n<227> av_log(s, AV_LOG_WARNING, "unknown media type, mediatype:"FF_PRI_GUID\n<228> \n<229> ", subtype:"FF_PRI_GUID", formattype:"FF_PRI_GUID"\n",\n<230> \n<231> FF_ARG_GUID(mediatype), FF_ARG_GUID(subtype), FF_ARG_GUID(formattype));\n<232> \n<233> avio_skip(pb, size);\n<234> \n<235> return NULL;\n<236> \n<237> }\n<238> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {\n<2> xmlListPtr l ;\n<3> if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {\n<4> xmlGenericError ( xmlGenericErrorContext , "Cannot initialize memory for list" ) ;\n<5> return ( NULL ) ;\n<6> }\n<7> memset ( l , 0 , sizeof ( xmlList ) ) ;\n<8> if ( NULL == ( l -> sentinel = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ) ) {\n<9> xmlGenericError ( xmlGenericErrorContext , "Cannot initialize memory for sentinel" ) ;\n<10> xmlFree ( l ) ;\n<11> return ( NULL ) ;\n<12> }\n<13> l -> sentinel -> next = l -> sentinel ;\n<14> l -> sentinel -> prev = l -> sentinel ;\n<15> l -> sentinel -> data = NULL ;\n<16> if ( deallocator != NULL ) l -> linkDeallocator = deallocator ;\n<17> if ( compare != NULL ) l -> linkCompare = compare ;\n<18> else l -> linkCompare = xmlLinkCompare ;\n<19> return l ;\n<20> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static ssize_t nic_receive(NetClientState *nc, const uint8_t * buf, size_t size)\n<2> \n<3> {\n<4> \n<5> /* TODO:\n<6> \n<7> * - Magic packets should set bit 30 in power management driver register.\n<8> \n<9> * - Interesting packets should set bit 29 in power management driver register.\n<10> \n<11> */\n<12> \n<13> EEPRO100State *s = DO_UPCAST(NICState, nc, nc)->opaque;\n<14> \n<15> uint16_t rfd_status = 0xa000;\n<16> \n<17> #if defined(CONFIG_PAD_RECEIVED_FRAMES)\n<18> \n<19> uint8_t min_buf[60];\n<20> \n<21> #endif\n<22> \n<23> static const uint8_t broadcast_macaddr[6] =\n<24> \n<25> { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n<26> \n<27> \n<28> \n<29> #if defined(CONFIG_PAD_RECEIVED_FRAMES)\n<30> \n<31> /* Pad to minimum Ethernet frame length */\n<32> \n<33> if (size < sizeof(min_buf)) {\n<34> \n<35> memcpy(min_buf, buf, size);\n<36> \n<37> memset(&min_buf[size], 0, sizeof(min_buf) - size);\n<38> \n<39> buf = min_buf;\n<40> \n<41> size = sizeof(min_buf);\n<42> \n<43> }\n<44> \n<45> #endif\n<46> \n<47> \n<48> \n<49> if (s->configuration[8] & 0x80) {\n<50> \n<51> /* CSMA is disabled. */\n<52> \n<53> logout("%p received while CSMA is disabled\n", s);\n<54> \n<55> return -1;\n<56> \n<57> #if !defined(CONFIG_PAD_RECEIVED_FRAMES)\n<58> \n<59> } else if (size < 64 && (s->configuration[7] & BIT(0))) {\n<60> \n<61> /* Short frame and configuration byte 7/0 (discard short receive) set:\n<62> \n<63> * Short frame is discarded */\n<64> \n<65> logout("%p received short frame (%zu byte)\n", s, size);\n<66> \n<67> s->statistics.rx_short_frame_errors++;\n<68> \n<69> return -1;\n<70> \n<71> #endif\n<72> \n<73> } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & BIT(3))) {\n<74> \n<75> /* Long frame and configuration byte 18/3 (long receive ok) not set:\n<76> \n<77> * Long frames are discarded. */\n<78> \n<79> logout("%p received long frame (%zu byte), ignored\n", s, size);\n<80> \n<81> return -1;\n<82> \n<83> } else if (memcmp(buf, s->conf.macaddr.a, 6) == 0) {       /* !!! */\n<84> \n<85> /* Frame matches individual address. */\n<86> \n<87> /* TODO: check configuration byte 15/4 (ignore U/L). */\n<88> \n<89> TRACE(RXTX, logout("%p received frame for me, len=%zu\n", s, size));\n<90> \n<91> } else if (memcmp(buf, broadcast_macaddr, 6) == 0) {\n<92> \n<93> /* Broadcast frame. */\n<94> \n<95> TRACE(RXTX, logout("%p received broadcast, len=%zu\n", s, size));\n<96> \n<97> rfd_status |= 0x0002;\n<98> \n<99> } else if (buf[0] & 0x01) {\n<100> \n<101> /* Multicast frame. */\n<102> \n<103> TRACE(RXTX, logout("%p received multicast, len=%zu,%s\n", s, size, nic_dump(buf, size)));\n<104> \n<105> if (s->configuration[21] & BIT(3)) {\n<106> \n<107> /* Multicast all bit is set, receive all multicast frames. */\n<108> \n<109> } else {\n<110> \n<111> unsigned mcast_idx = e100_compute_mcast_idx(buf);\n<112> \n<113> assert(mcast_idx < 64);\n<114> \n<115> if (s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))) {\n<116> \n<117> /* Multicast frame is allowed in hash table. */\n<118> \n<119> } else if (s->configuration[15] & BIT(0)) {\n<120> \n<121> /* Promiscuous: receive all. */\n<122> \n<123> rfd_status |= 0x0004;\n<124> \n<125> } else {\n<126> \n<127> TRACE(RXTX, logout("%p multicast ignored\n", s));\n<128> \n<129> return -1;\n<130> \n<131> }\n<132> \n<133> }\n<134> \n<135> /* TODO: Next not for promiscuous mode? */\n<136> \n<137> rfd_status |= 0x0002;\n<138> \n<139> } else if (s->configuration[15] & BIT(0)) {\n<140> \n<141> /* Promiscuous: receive all. */\n<142> \n<143> TRACE(RXTX, logout("%p received frame in promiscuous mode, len=%zu\n", s, size));\n<144> \n<145> rfd_status |= 0x0004;\n<146> \n<147> } else if (s->configuration[20] & BIT(6)) {\n<148> \n<149> /* Multiple IA bit set. */\n<150> \n<151> unsigned mcast_idx = compute_mcast_idx(buf);\n<152> \n<153> assert(mcast_idx < 64);\n<154> \n<155> if (s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))) {\n<156> \n<157> TRACE(RXTX, logout("%p accepted, multiple IA bit set\n", s));\n<158> \n<159> } else {\n<160> \n<161> TRACE(RXTX, logout("%p frame ignored, multiple IA bit set\n", s));\n<162> \n<163> return -1;\n<164> \n<165> }\n<166> \n<167> } else {\n<168> \n<169> TRACE(RXTX, logout("%p received frame, ignored, len=%zu,%s\n", s, size,\n<170> \n<171> nic_dump(buf, size)));\n<172> \n<173> return size;\n<174> \n<175> }\n<176> \n<177> \n<178> \n<179> if (get_ru_state(s) != ru_ready) {\n<180> \n<181> /* No resources available. */\n<182> \n<183> logout("no resources, state=%u\n", get_ru_state(s));\n<184> \n<185> /* TODO: RNR interrupt only at first failed frame? */\n<186> \n<187> eepro100_rnr_interrupt(s);\n<188> \n<189> s->statistics.rx_resource_errors++;\n<190> \n<191> #if 0\n<192> \n<193> assert(!"no resources");\n<194> \n<195> #endif\n<196> \n<197> return -1;\n<198> \n<199> }\n<200> \n<201> /* !!! */\n<202> \n<203> eepro100_rx_t rx;\n<204> \n<205> pci_dma_read(&s->dev, s->ru_base + s->ru_offset,\n<206> \n<207> &rx, sizeof(eepro100_rx_t));\n<208> \n<209> uint16_t rfd_command = le16_to_cpu(rx.command);\n<210> \n<211> uint16_t rfd_size = le16_to_cpu(rx.size);\n<212> \n<213> \n<214> \n<215> if (size > rfd_size) {\n<216> \n<217> logout("Receive buffer (%" PRId16 " bytes) too small for data "\n<218> \n<219> "(%zu bytes); data truncated\n", rfd_size, size);\n<220> \n<221> size = rfd_size;\n<222> \n<223> }\n<224> \n<225> #if !defined(CONFIG_PAD_RECEIVED_FRAMES)\n<226> \n<227> if (size < 64) {\n<228> \n<229> rfd_status |= 0x0080;\n<230> \n<231> }\n<232> \n<233> #endif\n<234> \n<235> TRACE(OTHER, logout("command 0x%04x, link 0x%08x, addr 0x%08x, size %u\n",\n<236> \n<237> rfd_command, rx.link, rx.rx_buf_addr, rfd_size));\n<238> \n<239> stw_le_pci_dma(&s->dev, s->ru_base + s->ru_offset +\n<240> \n<241> offsetof(eepro100_rx_t, status), rfd_status);\n<242> \n<243> stw_le_pci_dma(&s->dev, s->ru_base + s->ru_offset +\n<244> \n<245> offsetof(eepro100_rx_t, count), size);\n<246> \n<247> /* Early receive interrupt not supported. */\n<248> \n<249> #if 0\n<250> \n<251> eepro100_er_interrupt(s);\n<252> \n<253> #endif\n<254> \n<255> /* Receive CRC Transfer not supported. */\n<256> \n<257> if (s->configuration[18] & BIT(2)) {\n<258> \n<259> missing("Receive CRC Transfer");\n<260> \n<261> return -1;\n<262> \n<263> }\n<264> \n<265> /* TODO: check stripping enable bit. */\n<266> \n<267> #if 0\n<268> \n<269> assert(!(s->configuration[17] & BIT(0)));\n<270> \n<271> #endif\n<272> \n<273> pci_dma_write(&s->dev, s->ru_base + s->ru_offset +\n<274> \n<275> sizeof(eepro100_rx_t), buf, size);\n<276> \n<277> s->statistics.rx_good_frames++;\n<278> \n<279> eepro100_fr_interrupt(s);\n<280> \n<281> s->ru_offset = le32_to_cpu(rx.link);\n<282> \n<283> if (rfd_command & COMMAND_EL) {\n<284> \n<285> /* EL bit is set, so this was the last frame. */\n<286> \n<287> logout("receive: Running out of frames\n");\n<288> \n<289> set_ru_state(s, ru_suspended);\n<290> \n<291> }\n<292> \n<293> if (rfd_command & COMMAND_S) {\n<294> \n<295> /* S bit is set. */\n<296> \n<297> set_ru_state(s, ru_suspended);\n<298> \n<299> }\n<300> \n<301> return size;\n<302> \n<303> }\n<304> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static ssize_t test_block_write_func(QCryptoBlock *block,\n<2> \n<3> void *opaque,\n<4> \n<5> size_t offset,\n<6> \n<7> const uint8_t *buf,\n<8> \n<9> size_t buflen,\n<10> \n<11> Error **errp)\n<12> \n<13> {\n<14> \n<15> Buffer *header = opaque;\n<16> \n<17> \n<18> \n<19> g_assert_cmpint(buflen + offset, <=, header->capacity);\n<20> \n<21> \n<22> \n<23> memcpy(header->buffer + offset, buf, buflen);\n<24> \n<25> header->offset = offset + buflen;\n<26> \n<27> \n<28> \n<29> return buflen;\n<30> \n<31> }\n<32> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline int msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block,\n<2> \n<3> int n, int coded, const uint8_t *scan_table)\n<4> \n<5> {\n<6> \n<7> int level, i, last, run, run_diff;\n<8> \n<9> int dc_pred_dir;\n<10> \n<11> RLTable *rl;\n<12> \n<13> RL_VLC_ELEM *rl_vlc;\n<14> \n<15> int qmul, qadd;\n<16> \n<17> \n<18> \n<19> if (s->mb_intra) {\n<20> \n<21> qmul=1;\n<22> \n<23> qadd=0;\n<24> \n<25> \n<26> \n<27> /* DC coef */\n<28> \n<29> set_stat(ST_DC);\n<30> \n<31> level = msmpeg4_decode_dc(s, n, &dc_pred_dir);\n<32> \n<33> #ifdef PRINT_MB\n<34> \n<35> {\n<36> \n<37> static int c;\n<38> \n<39> if(n==0) c=0;\n<40> \n<41> if(n==4) printf("%X", c);\n<42> \n<43> c+= c +dc_pred_dir;\n<44> \n<45> }\n<46> \n<47> #endif\n<48> \n<49> if (level < 0){\n<50> \n<51> fprintf(stderr, "dc overflow- block: %d qscale: %d//\n", n, s->qscale);\n<52> \n<53> if(s->inter_intra_pred) level=0;\n<54> \n<55> else                    return -1;\n<56> \n<57> }\n<58> \n<59> if (n < 4) {\n<60> \n<61> rl = &rl_table[s->rl_table_index];\n<62> \n<63> if(level > 256*s->y_dc_scale){\n<64> \n<65> fprintf(stderr, "dc overflow+ L qscale: %d//\n", s->qscale);\n<66> \n<67> if(!s->inter_intra_pred) return -1;\n<68> \n<69> }\n<70> \n<71> } else {\n<72> \n<73> rl = &rl_table[3 + s->rl_chroma_table_index];\n<74> \n<75> if(level > 256*s->c_dc_scale){\n<76> \n<77> fprintf(stderr, "dc overflow+ C qscale: %d//\n", s->qscale);\n<78> \n<79> if(!s->inter_intra_pred) return -1;\n<80> \n<81> }\n<82> \n<83> }\n<84> \n<85> block[0] = level;\n<86> \n<87> \n<88> \n<89> run_diff = 0;\n<90> \n<91> i = 0;\n<92> \n<93> if (!coded) {\n<94> \n<95> goto not_coded;\n<96> \n<97> }\n<98> \n<99> if (s->ac_pred) {\n<100> \n<101> if (dc_pred_dir == 0)\n<102> \n<103> scan_table = s->intra_v_scantable.permutated; /* left */\n<104> \n<105> else\n<106> \n<107> scan_table = s->intra_h_scantable.permutated; /* top */\n<108> \n<109> } else {\n<110> \n<111> scan_table = s->intra_scantable.permutated;\n<112> \n<113> }\n<114> \n<115> set_stat(ST_INTRA_AC);\n<116> \n<117> rl_vlc= rl->rl_vlc[0];\n<118> \n<119> } else {\n<120> \n<121> qmul = s->qscale << 1;\n<122> \n<123> qadd = (s->qscale - 1) | 1;\n<124> \n<125> i = -1;\n<126> \n<127> rl = &rl_table[3 + s->rl_table_index];\n<128> \n<129> \n<130> \n<131> if(s->msmpeg4_version==2)\n<132> \n<133> run_diff = 0;\n<134> \n<135> else\n<136> \n<137> run_diff = 1;\n<138> \n<139> \n<140> \n<141> if (!coded) {\n<142> \n<143> s->block_last_index[n] = i;\n<144> \n<145> return 0;\n<146> \n<147> }\n<148> \n<149> if(!scan_table)\n<150> \n<151> scan_table = s->inter_scantable.permutated;\n<152> \n<153> set_stat(ST_INTER_AC);\n<154> \n<155> rl_vlc= rl->rl_vlc[s->qscale];\n<156> \n<157> }\n<158> \n<159> {\n<160> \n<161> OPEN_READER(re, &s->gb);\n<162> \n<163> for(;;) {\n<164> \n<165> UPDATE_CACHE(re, &s->gb);\n<166> \n<167> GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2);\n<168> \n<169> if (level==0) {\n<170> \n<171> int cache;\n<172> \n<173> cache= GET_CACHE(re, &s->gb);\n<174> \n<175> /* escape */\n<176> \n<177> if (s->msmpeg4_version==1 || (cache&0x80000000)==0) {\n<178> \n<179> if (s->msmpeg4_version==1 || (cache&0x40000000)==0) {\n<180> \n<181> /* third escape */\n<182> \n<183> if(s->msmpeg4_version!=1) LAST_SKIP_BITS(re, &s->gb, 2);\n<184> \n<185> UPDATE_CACHE(re, &s->gb);\n<186> \n<187> if(s->msmpeg4_version<=3){\n<188> \n<189> last=  SHOW_UBITS(re, &s->gb, 1); SKIP_CACHE(re, &s->gb, 1);\n<190> \n<191> run=   SHOW_UBITS(re, &s->gb, 6); SKIP_CACHE(re, &s->gb, 6);\n<192> \n<193> level= SHOW_SBITS(re, &s->gb, 8); LAST_SKIP_CACHE(re, &s->gb, 8);\n<194> \n<195> SKIP_COUNTER(re, &s->gb, 1+6+8);\n<196> \n<197> }else{\n<198> \n<199> int sign;\n<200> \n<201> last=  SHOW_UBITS(re, &s->gb, 1); SKIP_BITS(re, &s->gb, 1);\n<202> \n<203> if(!s->esc3_level_length){\n<204> \n<205> int ll;\n<206> \n<207> //printf("ESC-3 %X at %d %d\n", show_bits(&s->gb, 24), s->mb_x, s->mb_y);\n<208> \n<209> if(s->qscale<8){\n<210> \n<211> ll= SHOW_UBITS(re, &s->gb, 3); SKIP_BITS(re, &s->gb, 3);\n<212> \n<213> if(ll==0){\n<214> \n<215> if(SHOW_UBITS(re, &s->gb, 1)) printf("cool a new vlc code ,contact the ffmpeg developers and upload the file\n");\n<216> \n<217> SKIP_BITS(re, &s->gb, 1);\n<218> \n<219> ll=8;\n<220> \n<221> }\n<222> \n<223> }else{\n<224> \n<225> ll=2;\n<226> \n<227> while(ll<8 && SHOW_UBITS(re, &s->gb, 1)==0){\n<228> \n<229> ll++;\n<230> \n<231> SKIP_BITS(re, &s->gb, 1);\n<232> \n<233> }\n<234> \n<235> if(ll<8) SKIP_BITS(re, &s->gb, 1);\n<236> \n<237> }\n<238> \n<239> \n<240> \n<241> s->esc3_level_length= ll;\n<242> \n<243> s->esc3_run_length= SHOW_UBITS(re, &s->gb, 2) + 3; SKIP_BITS(re, &s->gb, 2);\n<244> \n<245> //printf("level length:%d, run length: %d\n", ll, s->esc3_run_length);\n<246> \n<247> UPDATE_CACHE(re, &s->gb);\n<248> \n<249> }\n<250> \n<251> run=   SHOW_UBITS(re, &s->gb, s->esc3_run_length);\n<252> \n<253> SKIP_BITS(re, &s->gb, s->esc3_run_length);\n<254> \n<255> \n<256> \n<257> sign=  SHOW_UBITS(re, &s->gb, 1);\n<258> \n<259> SKIP_BITS(re, &s->gb, 1);\n<260> \n<261> \n<262> \n<263> level= SHOW_UBITS(re, &s->gb, s->esc3_level_length);\n<264> \n<265> SKIP_BITS(re, &s->gb, s->esc3_level_length);\n<266> \n<267> if(sign) level= -level;\n<268> \n<269> }\n<270> \n<271> //printf("level: %d, run: %d at %d %d\n", level, run, s->mb_x, s->mb_y);\n<272> \n<273> #if 0 // waste of time / this will detect very few errors\n<274> \n<275> {\n<276> \n<277> const int abs_level= ABS(level);\n<278> \n<279> const int run1= run - rl->max_run[last][abs_level] - run_diff;\n<280> \n<281> if(abs_level<=MAX_LEVEL && run<=MAX_RUN){\n<282> \n<283> if(abs_level <= rl->max_level[last][run]){\n<284> \n<285> fprintf(stderr, "illegal 3. esc, vlc encoding possible\n");\n<286> \n<287> return DECODING_AC_LOST;\n<288> \n<289> }\n<290> \n<291> if(abs_level <= rl->max_level[last][run]*2){\n<292> \n<293> fprintf(stderr, "illegal 3. esc, esc 1 encoding possible\n");\n<294> \n<295> return DECODING_AC_LOST;\n<296> \n<297> }\n<298> \n<299> if(run1>=0 && abs_level <= rl->max_level[last][run1]){\n<300> \n<301> fprintf(stderr, "illegal 3. esc, esc 2 encoding possible\n");\n<302> \n<303> return DECODING_AC_LOST;\n<304> \n<305> }\n<306> \n<307> }\n<308> \n<309> }\n<310> \n<311> #endif\n<312> \n<313> //level = level * qmul + (level>0) * qadd - (level<=0) * qadd ;\n<314> \n<315> if (level>0) level= level * qmul + qadd;\n<316> \n<317> else         level= level * qmul - qadd;\n<318> \n<319> #if 0 // waste of time too :(\n<320> \n<321> if(level>2048 || level<-2048){\n<322> \n<323> fprintf(stderr, "|level| overflow in 3. esc\n");\n<324> \n<325> return DECODING_AC_LOST;\n<326> \n<327> }\n<328> \n<329> #endif\n<330> \n<331> i+= run + 1;\n<332> \n<333> if(last) i+=192;\n<334> \n<335> #ifdef ERROR_DETAILS\n<336> \n<337> if(run==66)\n<338> \n<339> fprintf(stderr, "illegal vlc code in ESC3 level=%d\n", level);\n<340> \n<341> else if((i>62 && i<192) || i>192+63)\n<342> \n<343> fprintf(stderr, "run overflow in ESC3 i=%d run=%d level=%d\n", i, run, level);\n<344> \n<345> #endif\n<346> \n<347> } else {\n<348> \n<349> /* second escape */\n<350> \n<351> #if MIN_CACHE_BITS < 23\n<352> \n<353> LAST_SKIP_BITS(re, &s->gb, 2);\n<354> \n<355> UPDATE_CACHE(re, &s->gb);\n<356> \n<357> #else\n<358> \n<359> SKIP_BITS(re, &s->gb, 2);\n<360> \n<361> #endif\n<362> \n<363> GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2);\n<364> \n<365> i+= run + rl->max_run[run>>7][level/qmul] + run_diff; //FIXME opt indexing\n<366> \n<367> level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n<368> \n<369> LAST_SKIP_BITS(re, &s->gb, 1);\n<370> \n<371> #ifdef ERROR_DETAILS\n<372> \n<373> if(run==66)\n<374> \n<375> fprintf(stderr, "illegal vlc code in ESC2 level=%d\n", level);\n<376> \n<377> else if((i>62 && i<192) || i>192+63)\n<378> \n<379> fprintf(stderr, "run overflow in ESC2 i=%d run=%d level=%d\n", i, run, level);\n<380> \n<381> #endif\n<382> \n<383> }\n<384> \n<385> } else {\n<386> \n<387> /* first escape */\n<388> \n<389> #if MIN_CACHE_BITS < 22\n<390> \n<391> LAST_SKIP_BITS(re, &s->gb, 1);\n<392> \n<393> UPDATE_CACHE(re, &s->gb);\n<394> \n<395> #else\n<396> \n<397> SKIP_BITS(re, &s->gb, 1);\n<398> \n<399> #endif\n<400> \n<401> GET_RL_VLC(level, run, re, &s->gb, rl_vlc, TEX_VLC_BITS, 2);\n<402> \n<403> i+= run;\n<404> \n<405> level = level + rl->max_level[run>>7][(run-1)&63] * qmul;//FIXME opt indexing\n<406> \n<407> level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n<408> \n<409> LAST_SKIP_BITS(re, &s->gb, 1);\n<410> \n<411> #ifdef ERROR_DETAILS\n<412> \n<413> if(run==66)\n<414> \n<415> fprintf(stderr, "illegal vlc code in ESC1 level=%d\n", level);\n<416> \n<417> else if((i>62 && i<192) || i>192+63)\n<418> \n<419> fprintf(stderr, "run overflow in ESC1 i=%d run=%d level=%d\n", i, run, level);\n<420> \n<421> #endif\n<422> \n<423> }\n<424> \n<425> } else {\n<426> \n<427> i+= run;\n<428> \n<429> level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n<430> \n<431> LAST_SKIP_BITS(re, &s->gb, 1);\n<432> \n<433> #ifdef ERROR_DETAILS\n<434> \n<435> if(run==66)\n<436> \n<437> fprintf(stderr, "illegal vlc code level=%d\n", level);\n<438> \n<439> else if((i>62 && i<192) || i>192+63)\n<440> \n<441> fprintf(stderr, "run overflow i=%d run=%d level=%d\n", i, run, level);\n<442> \n<443> #endif\n<444> \n<445> }\n<446> \n<447> if (i > 62){\n<448> \n<449> i-= 192;\n<450> \n<451> if(i&(~63)){\n<452> \n<453> const int left= s->gb.size*8 - get_bits_count(&s->gb);\n<454> \n<455> if(((i+192 == 64 && level/qmul==-1) || s->error_resilience<=1) && left>=0){\n<456> \n<457> fprintf(stderr, "ignoring overflow at %d %d\n", s->mb_x, s->mb_y);\n<458> \n<459> break;\n<460> \n<461> }else{\n<462> \n<463> fprintf(stderr, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);\n<464> \n<465> return -1;\n<466> \n<467> }\n<468> \n<469> }\n<470> \n<471> \n<472> \n<473> block[scan_table[i]] = level;\n<474> \n<475> break;\n<476> \n<477> }\n<478> \n<479> \n<480> \n<481> block[scan_table[i]] = level;\n<482> \n<483> }\n<484> \n<485> CLOSE_READER(re, &s->gb);\n<486> \n<487> }\n<488> \n<489> not_coded:\n<490> \n<491> if (s->mb_intra) {\n<492> \n<493> mpeg4_pred_ac(s, block, n, dc_pred_dir);\n<494> \n<495> if (s->ac_pred) {\n<496> \n<497> i = 63; /* XXX: not optimal */\n<498> \n<499> }\n<500> \n<501> }\n<502> \n<503> if(s->msmpeg4_version>=4 && i>0) i=63; //FIXME/XXX optimize\n<504> \n<505> s->block_last_index[n] = i;\n<506> \n<507> \n<508> \n<509> return 0;\n<510> \n<511> }\n<512> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline void gen_intermediate_code_internal(SPARCCPU *cpu,\n<2> \n<3> TranslationBlock *tb,\n<4> \n<5> bool spc)\n<6> \n<7> {\n<8> \n<9> CPUState *cs = CPU(cpu);\n<10> \n<11> CPUSPARCState *env = &cpu->env;\n<12> \n<13> target_ulong pc_start, last_pc;\n<14> \n<15> uint16_t *gen_opc_end;\n<16> \n<17> DisasContext dc1, *dc = &dc1;\n<18> \n<19> CPUBreakpoint *bp;\n<20> \n<21> int j, lj = -1;\n<22> \n<23> int num_insns;\n<24> \n<25> int max_insns;\n<26> \n<27> unsigned int insn;\n<28> \n<29> \n<30> \n<31> memset(dc, 0, sizeof(DisasContext));\n<32> \n<33> dc->tb = tb;\n<34> \n<35> pc_start = tb->pc;\n<36> \n<37> dc->pc = pc_start;\n<38> \n<39> last_pc = dc->pc;\n<40> \n<41> dc->npc = (target_ulong) tb->cs_base;\n<42> \n<43> dc->cc_op = CC_OP_DYNAMIC;\n<44> \n<45> dc->mem_idx = cpu_mmu_index(env);\n<46> \n<47> dc->def = env->def;\n<48> \n<49> dc->fpu_enabled = tb_fpu_enabled(tb->flags);\n<50> \n<51> dc->address_mask_32bit = tb_am_enabled(tb->flags);\n<52> \n<53> dc->singlestep = (cs->singlestep_enabled || singlestep);\n<54> \n<55> gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;\n<56> \n<57> \n<58> \n<59> num_insns = 0;\n<60> \n<61> max_insns = tb->cflags & CF_COUNT_MASK;\n<62> \n<63> if (max_insns == 0)\n<64> \n<65> max_insns = CF_COUNT_MASK;\n<66> \n<67> gen_tb_start();\n<68> \n<69> do {\n<70> \n<71> if (unlikely(!QTAILQ_EMPTY(&cs->breakpoints))) {\n<72> \n<73> QTAILQ_FOREACH(bp, &cs->breakpoints, entry) {\n<74> \n<75> if (bp->pc == dc->pc) {\n<76> \n<77> if (dc->pc != pc_start)\n<78> \n<79> save_state(dc);\n<80> \n<81> gen_helper_debug(cpu_env);\n<82> \n<83> tcg_gen_exit_tb(0);\n<84> \n<85> dc->is_br = 1;\n<86> \n<87> goto exit_gen_loop;\n<88> \n<89> }\n<90> \n<91> }\n<92> \n<93> }\n<94> \n<95> if (spc) {\n<96> \n<97> qemu_log("Search PC...\n");\n<98> \n<99> j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n<100> \n<101> if (lj < j) {\n<102> \n<103> lj++;\n<104> \n<105> while (lj < j)\n<106> \n<107> tcg_ctx.gen_opc_instr_start[lj++] = 0;\n<108> \n<109> tcg_ctx.gen_opc_pc[lj] = dc->pc;\n<110> \n<111> gen_opc_npc[lj] = dc->npc;\n<112> \n<113> tcg_ctx.gen_opc_instr_start[lj] = 1;\n<114> \n<115> tcg_ctx.gen_opc_icount[lj] = num_insns;\n<116> \n<117> }\n<118> \n<119> }\n<120> \n<121> if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n<122> \n<123> gen_io_start();\n<124> \n<125> last_pc = dc->pc;\n<126> \n<127> insn = cpu_ldl_code(env, dc->pc);\n<128> \n<129> \n<130> \n<131> disas_sparc_insn(dc, insn);\n<132> \n<133> num_insns++;\n<134> \n<135> \n<136> \n<137> if (dc->is_br)\n<138> \n<139> break;\n<140> \n<141> /* if the next PC is different, we abort now */\n<142> \n<143> if (dc->pc != (last_pc + 4))\n<144> \n<145> break;\n<146> \n<147> /* if we reach a page boundary, we stop generation so that the\n<148> \n<149> PC of a TT_TFAULT exception is always in the right page */\n<150> \n<151> if ((dc->pc & (TARGET_PAGE_SIZE - 1)) == 0)\n<152> \n<153> break;\n<154> \n<155> /* if single step mode, we generate only one instruction and\n<156> \n<157> generate an exception */\n<158> \n<159> if (dc->singlestep) {\n<160> \n<161> break;\n<162> \n<163> }\n<164> \n<165> } while ((tcg_ctx.gen_opc_ptr < gen_opc_end) &&\n<166> \n<167> (dc->pc - pc_start) < (TARGET_PAGE_SIZE - 32) &&\n<168> \n<169> num_insns < max_insns);\n<170> \n<171> \n<172> \n<173> exit_gen_loop:\n<174> \n<175> if (tb->cflags & CF_LAST_IO) {\n<176> \n<177> gen_io_end();\n<178> \n<179> }\n<180> \n<181> if (!dc->is_br) {\n<182> \n<183> if (dc->pc != DYNAMIC_PC &&\n<184> \n<185> (dc->npc != DYNAMIC_PC && dc->npc != JUMP_PC)) {\n<186> \n<187> /* static PC and NPC: we can use direct chaining */\n<188> \n<189> gen_goto_tb(dc, 0, dc->pc, dc->npc);\n<190> \n<191> } else {\n<192> \n<193> if (dc->pc != DYNAMIC_PC) {\n<194> \n<195> tcg_gen_movi_tl(cpu_pc, dc->pc);\n<196> \n<197> }\n<198> \n<199> save_npc(dc);\n<200> \n<201> tcg_gen_exit_tb(0);\n<202> \n<203> }\n<204> \n<205> }\n<206> \n<207> gen_tb_end(tb, num_insns);\n<208> \n<209> *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n<210> \n<211> if (spc) {\n<212> \n<213> j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n<214> \n<215> lj++;\n<216> \n<217> while (lj <= j)\n<218> \n<219> tcg_ctx.gen_opc_instr_start[lj++] = 0;\n<220> \n<221> #if 0\n<222> \n<223> log_page_dump();\n<224> \n<225> #endif\n<226> \n<227> gen_opc_jump_pc[0] = dc->jump_pc[0];\n<228> \n<229> gen_opc_jump_pc[1] = dc->jump_pc[1];\n<230> \n<231> } else {\n<232> \n<233> tb->size = last_pc + 4 - pc_start;\n<234> \n<235> tb->icount = num_insns;\n<236> \n<237> }\n<238> \n<239> #ifdef DEBUG_DISAS\n<240> \n<241> if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n<242> \n<243> qemu_log("--------------\n");\n<244> \n<245> qemu_log("IN: %s\n", lookup_symbol(pc_start));\n<246> \n<247> log_target_disas(env, pc_start, last_pc + 4 - pc_start, 0);\n<248> \n<249> qemu_log("\n");\n<250> \n<251> }\n<252> \n<253> #endif\n<254> \n<255> }\n<256> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n<2> \n<3> {\n<4> \n<5> char host[65], port[33], width[8], height[8];\n<6> \n<7> int pos;\n<8> \n<9> const char *p;\n<10> \n<11> QemuOpts *opts;\n<12> \n<13> Error *local_err = NULL;\n<14> \n<15> \n<16> \n<17> opts = qemu_opts_create(qemu_find_opts("chardev"), label, 1, &local_err);\n<18> \n<19> if (local_err) {\n<20> \n<21> error_report_err(local_err);\n<22> \n<23> return NULL;\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> if (strstart(filename, "mon:", &p)) {\n<30> \n<31> filename = p;\n<32> \n<33> qemu_opt_set(opts, "mux", "on", &error_abort);\n<34> \n<35> if (strcmp(filename, "stdio") == 0) {\n<36> \n<37> /* Monitor is muxed to stdio: do not exit on Ctrl+C by default\n<38> \n<39> * but pass it to the guest.  Handle this only for compat syntax,\n<40> \n<41> * for -chardev syntax we have special option for this.\n<42> \n<43> * This is what -nographic did, redirecting+muxing serial+monitor\n<44> \n<45> * to stdio causing Ctrl+C to be passed to guest. */\n<46> \n<47> qemu_opt_set(opts, "signal", "off", &error_abort);\n<48> \n<49> }\n<50> \n<51> }\n<52> \n<53> \n<54> \n<55> if (strcmp(filename, "null")    == 0 ||\n<56> \n<57> strcmp(filename, "pty")     == 0 ||\n<58> \n<59> strcmp(filename, "msmouse") == 0 ||\n<60> \n<61> strcmp(filename, "braille") == 0 ||\n<62> \n<63> strcmp(filename, "testdev") == 0 ||\n<64> \n<65> strcmp(filename, "stdio")   == 0) {\n<66> \n<67> qemu_opt_set(opts, "backend", filename, &error_abort);\n<68> \n<69> return opts;\n<70> \n<71> }\n<72> \n<73> if (strstart(filename, "vc", &p)) {\n<74> \n<75> qemu_opt_set(opts, "backend", "vc", &error_abort);\n<76> \n<77> if (*p == ':') {\n<78> \n<79> if (sscanf(p+1, "%7[0-9]x%7[0-9]", width, height) == 2) {\n<80> \n<81> /* pixels */\n<82> \n<83> qemu_opt_set(opts, "width", width, &error_abort);\n<84> \n<85> qemu_opt_set(opts, "height", height, &error_abort);\n<86> \n<87> } else if (sscanf(p+1, "%7[0-9]Cx%7[0-9]C", width, height) == 2) {\n<88> \n<89> /* chars */\n<90> \n<91> qemu_opt_set(opts, "cols", width, &error_abort);\n<92> \n<93> qemu_opt_set(opts, "rows", height, &error_abort);\n<94> \n<95> } else {\n<96> \n<97> goto fail;\n<98> \n<99> }\n<100> \n<101> }\n<102> \n<103> return opts;\n<104> \n<105> }\n<106> \n<107> if (strcmp(filename, "con:") == 0) {\n<108> \n<109> qemu_opt_set(opts, "backend", "console", &error_abort);\n<110> \n<111> return opts;\n<112> \n<113> }\n<114> \n<115> if (strstart(filename, "COM", NULL)) {\n<116> \n<117> qemu_opt_set(opts, "backend", "serial", &error_abort);\n<118> \n<119> qemu_opt_set(opts, "path", filename, &error_abort);\n<120> \n<121> return opts;\n<122> \n<123> }\n<124> \n<125> if (strstart(filename, "file:", &p)) {\n<126> \n<127> qemu_opt_set(opts, "backend", "file", &error_abort);\n<128> \n<129> qemu_opt_set(opts, "path", p, &error_abort);\n<130> \n<131> return opts;\n<132> \n<133> }\n<134> \n<135> if (strstart(filename, "pipe:", &p)) {\n<136> \n<137> qemu_opt_set(opts, "backend", "pipe", &error_abort);\n<138> \n<139> qemu_opt_set(opts, "path", p, &error_abort);\n<140> \n<141> return opts;\n<142> \n<143> }\n<144> \n<145> if (strstart(filename, "tcp:", &p) ||\n<146> \n<147> strstart(filename, "telnet:", &p)) {\n<148> \n<149> if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) {\n<150> \n<151> host[0] = 0;\n<152> \n<153> if (sscanf(p, ":%32[^,]%n", port, &pos) < 1)\n<154> \n<155> goto fail;\n<156> \n<157> }\n<158> \n<159> qemu_opt_set(opts, "backend", "socket", &error_abort);\n<160> \n<161> qemu_opt_set(opts, "host", host, &error_abort);\n<162> \n<163> qemu_opt_set(opts, "port", port, &error_abort);\n<164> \n<165> if (p[pos] == ',') {\n<166> \n<167> if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n<168> \n<169> goto fail;\n<170> \n<171> }\n<172> \n<173> if (strstart(filename, "telnet:", &p))\n<174> \n<175> qemu_opt_set(opts, "telnet", "on", &error_abort);\n<176> \n<177> return opts;\n<178> \n<179> }\n<180> \n<181> if (strstart(filename, "udp:", &p)) {\n<182> \n<183> qemu_opt_set(opts, "backend", "udp", &error_abort);\n<184> \n<185> if (sscanf(p, "%64[^:]:%32[^@,]%n", host, port, &pos) < 2) {\n<186> \n<187> host[0] = 0;\n<188> \n<189> if (sscanf(p, ":%32[^@,]%n", port, &pos) < 1) {\n<190> \n<191> goto fail;\n<192> \n<193> }\n<194> \n<195> }\n<196> \n<197> qemu_opt_set(opts, "host", host, &error_abort);\n<198> \n<199> qemu_opt_set(opts, "port", port, &error_abort);\n<200> \n<201> if (p[pos] == '@') {\n<202> \n<203> p += pos + 1;\n<204> \n<205> if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) {\n<206> \n<207> host[0] = 0;\n<208> \n<209> if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) {\n<210> \n<211> goto fail;\n<212> \n<213> }\n<214> \n<215> }\n<216> \n<217> qemu_opt_set(opts, "localaddr", host, &error_abort);\n<218> \n<219> qemu_opt_set(opts, "localport", port, &error_abort);\n<220> \n<221> }\n<222> \n<223> return opts;\n<224> \n<225> }\n<226> \n<227> if (strstart(filename, "unix:", &p)) {\n<228> \n<229> qemu_opt_set(opts, "backend", "socket", &error_abort);\n<230> \n<231> if (qemu_opts_do_parse(opts, p, "path") != 0)\n<232> \n<233> goto fail;\n<234> \n<235> return opts;\n<236> \n<237> }\n<238> \n<239> if (strstart(filename, "/dev/parport", NULL) ||\n<240> \n<241> strstart(filename, "/dev/ppi", NULL)) {\n<242> \n<243> qemu_opt_set(opts, "backend", "parport", &error_abort);\n<244> \n<245> qemu_opt_set(opts, "path", filename, &error_abort);\n<246> \n<247> return opts;\n<248> \n<249> }\n<250> \n<251> if (strstart(filename, "/dev/", NULL)) {\n<252> \n<253> qemu_opt_set(opts, "backend", "tty", &error_abort);\n<254> \n<255> qemu_opt_set(opts, "path", filename, &error_abort);\n<256> \n<257> return opts;\n<258> \n<259> }\n<260> \n<261> \n<262> \n<263> fail:\n<264> \n<265> qemu_opts_del(opts);\n<266> \n<267> return NULL;\n<268> \n<269> }\n<270> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void ppc_core99_init(MachineState *machine)\n<2> \n<3> {\n<4> \n<5> ram_addr_t ram_size = machine->ram_size;\n<6> \n<7> const char *cpu_model = machine->cpu_model;\n<8> \n<9> const char *kernel_filename = machine->kernel_filename;\n<10> \n<11> const char *kernel_cmdline = machine->kernel_cmdline;\n<12> \n<13> const char *initrd_filename = machine->initrd_filename;\n<14> \n<15> const char *boot_device = machine->boot_order;\n<16> \n<17> PowerPCCPU *cpu = NULL;\n<18> \n<19> CPUPPCState *env = NULL;\n<20> \n<21> char *filename;\n<22> \n<23> qemu_irq *pic, **openpic_irqs;\n<24> \n<25> MemoryRegion *isa = g_new(MemoryRegion, 1);\n<26> \n<27> MemoryRegion *unin_memory = g_new(MemoryRegion, 1);\n<28> \n<29> MemoryRegion *unin2_memory = g_new(MemoryRegion, 1);\n<30> \n<31> int linux_boot, i, j, k;\n<32> \n<33> MemoryRegion *ram = g_new(MemoryRegion, 1), *bios = g_new(MemoryRegion, 1);\n<34> \n<35> hwaddr kernel_base, initrd_base, cmdline_base = 0;\n<36> \n<37> long kernel_size, initrd_size;\n<38> \n<39> PCIBus *pci_bus;\n<40> \n<41> PCIDevice *macio;\n<42> \n<43> MACIOIDEState *macio_ide;\n<44> \n<45> BusState *adb_bus;\n<46> \n<47> MacIONVRAMState *nvr;\n<48> \n<49> int bios_size;\n<50> \n<51> MemoryRegion *pic_mem, *escc_mem;\n<52> \n<53> MemoryRegion *escc_bar = g_new(MemoryRegion, 1);\n<54> \n<55> int ppc_boot_device;\n<56> \n<57> DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n<58> \n<59> void *fw_cfg;\n<60> \n<61> int machine_arch;\n<62> \n<63> SysBusDevice *s;\n<64> \n<65> DeviceState *dev;\n<66> \n<67> int *token = g_new(int, 1);\n<68> \n<69> hwaddr nvram_addr = 0xFFF04000;\n<70> \n<71> uint64_t tbfreq;\n<72> \n<73> \n<74> \n<75> linux_boot = (kernel_filename != NULL);\n<76> \n<77> \n<78> \n<79> /* init CPUs */\n<80> \n<81> if (cpu_model == NULL)\n<82> \n<83> #ifdef TARGET_PPC64\n<84> \n<85> cpu_model = "970fx";\n<86> \n<87> #else\n<88> \n<89> cpu_model = "G4";\n<90> \n<91> #endif\n<92> \n<93> for (i = 0; i < smp_cpus; i++) {\n<94> \n<95> cpu = cpu_ppc_init(cpu_model);\n<96> \n<97> if (cpu == NULL) {\n<98> \n<99> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<100> \n<101> exit(1);\n<102> \n<103> }\n<104> \n<105> env = &cpu->env;\n<106> \n<107> \n<108> \n<109> /* Set time-base frequency to 100 Mhz */\n<110> \n<111> cpu_ppc_tb_init(env, TBFREQ);\n<112> \n<113> qemu_register_reset(ppc_core99_reset, cpu);\n<114> \n<115> }\n<116> \n<117> \n<118> \n<119> /* allocate RAM */\n<120> \n<121> memory_region_allocate_system_memory(ram, NULL, "ppc_core99.ram", ram_size);\n<122> \n<123> memory_region_add_subregion(get_system_memory(), 0, ram);\n<124> \n<125> \n<126> \n<127> /* allocate and load BIOS */\n<128> \n<129> memory_region_init_ram(bios, NULL, "ppc_core99.bios", BIOS_SIZE,\n<130> \n<131> &error_abort);\n<132> \n<133> vmstate_register_ram_global(bios);\n<134> \n<135> \n<136> \n<137> if (bios_name == NULL)\n<138> \n<139> bios_name = PROM_FILENAME;\n<140> \n<141> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<142> \n<143> memory_region_set_readonly(bios, true);\n<144> \n<145> memory_region_add_subregion(get_system_memory(), PROM_ADDR, bios);\n<146> \n<147> \n<148> \n<149> /* Load OpenBIOS (ELF) */\n<150> \n<151> if (filename) {\n<152> \n<153> bios_size = load_elf(filename, NULL, NULL, NULL,\n<154> \n<155> NULL, NULL, 1, ELF_MACHINE, 0);\n<156> \n<157> \n<158> \n<159> g_free(filename);\n<160> \n<161> } else {\n<162> \n<163> bios_size = -1;\n<164> \n<165> }\n<166> \n<167> if (bios_size < 0 || bios_size > BIOS_SIZE) {\n<168> \n<169> hw_error("qemu: could not load PowerPC bios '%s'\n", bios_name);\n<170> \n<171> exit(1);\n<172> \n<173> }\n<174> \n<175> \n<176> \n<177> if (linux_boot) {\n<178> \n<179> uint64_t lowaddr = 0;\n<180> \n<181> int bswap_needed;\n<182> \n<183> \n<184> \n<185> #ifdef BSWAP_NEEDED\n<186> \n<187> bswap_needed = 1;\n<188> \n<189> #else\n<190> \n<191> bswap_needed = 0;\n<192> \n<193> #endif\n<194> \n<195> kernel_base = KERNEL_LOAD_ADDR;\n<196> \n<197> \n<198> \n<199> kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n<200> \n<201> NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n<202> \n<203> if (kernel_size < 0)\n<204> \n<205> kernel_size = load_aout(kernel_filename, kernel_base,\n<206> \n<207> ram_size - kernel_base, bswap_needed,\n<208> \n<209> TARGET_PAGE_SIZE);\n<210> \n<211> if (kernel_size < 0)\n<212> \n<213> kernel_size = load_image_targphys(kernel_filename,\n<214> \n<215> kernel_base,\n<216> \n<217> ram_size - kernel_base);\n<218> \n<219> if (kernel_size < 0) {\n<220> \n<221> hw_error("qemu: could not load kernel '%s'\n", kernel_filename);\n<222> \n<223> exit(1);\n<224> \n<225> }\n<226> \n<227> /* load initrd */\n<228> \n<229> if (initrd_filename) {\n<230> \n<231> initrd_base = round_page(kernel_base + kernel_size + KERNEL_GAP);\n<232> \n<233> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<234> \n<235> ram_size - initrd_base);\n<236> \n<237> if (initrd_size < 0) {\n<238> \n<239> hw_error("qemu: could not load initial ram disk '%s'\n",\n<240> \n<241> initrd_filename);\n<242> \n<243> exit(1);\n<244> \n<245> }\n<246> \n<247> cmdline_base = round_page(initrd_base + initrd_size);\n<248> \n<249> } else {\n<250> \n<251> initrd_base = 0;\n<252> \n<253> initrd_size = 0;\n<254> \n<255> cmdline_base = round_page(kernel_base + kernel_size + KERNEL_GAP);\n<256> \n<257> }\n<258> \n<259> ppc_boot_device = 'm';\n<260> \n<261> } else {\n<262> \n<263> kernel_base = 0;\n<264> \n<265> kernel_size = 0;\n<266> \n<267> initrd_base = 0;\n<268> \n<269> initrd_size = 0;\n<270> \n<271> ppc_boot_device = '\0';\n<272> \n<273> /* We consider that NewWorld PowerMac never have any floppy drive\n<274> \n<275> * For now, OHW cannot boot from the network.\n<276> \n<277> */\n<278> \n<279> for (i = 0; boot_device[i] != '\0'; i++) {\n<280> \n<281> if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {\n<282> \n<283> ppc_boot_device = boot_device[i];\n<284> \n<285> break;\n<286> \n<287> }\n<288> \n<289> }\n<290> \n<291> if (ppc_boot_device == '\0') {\n<292> \n<293> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<294> \n<295> exit(1);\n<296> \n<297> }\n<298> \n<299> }\n<300> \n<301> \n<302> \n<303> /* Register 8 MB of ISA IO space */\n<304> \n<305> memory_region_init_alias(isa, NULL, "isa_mmio",\n<306> \n<307> get_system_io(), 0, 0x00800000);\n<308> \n<309> memory_region_add_subregion(get_system_memory(), 0xf2000000, isa);\n<310> \n<311> \n<312> \n<313> /* UniN init: XXX should be a real device */\n<314> \n<315> memory_region_init_io(unin_memory, NULL, &unin_ops, token, "unin", 0x1000);\n<316> \n<317> memory_region_add_subregion(get_system_memory(), 0xf8000000, unin_memory);\n<318> \n<319> \n<320> \n<321> memory_region_init_io(unin2_memory, NULL, &unin_ops, token, "unin", 0x1000);\n<322> \n<323> memory_region_add_subregion(get_system_memory(), 0xf3000000, unin2_memory);\n<324> \n<325> \n<326> \n<327> openpic_irqs = g_malloc0(smp_cpus * sizeof(qemu_irq *));\n<328> \n<329> openpic_irqs[0] =\n<330> \n<331> g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n<332> \n<333> for (i = 0; i < smp_cpus; i++) {\n<334> \n<335> /* Mac99 IRQ connection between OpenPIC outputs pins\n<336> \n<337> * and PowerPC input pins\n<338> \n<339> */\n<340> \n<341> switch (PPC_INPUT(env)) {\n<342> \n<343> case PPC_FLAGS_INPUT_6xx:\n<344> \n<345> openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n<346> \n<347> openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n<348> \n<349> ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n<350> \n<351> openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n<352> \n<353> ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n<354> \n<355> openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n<356> \n<357> ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n<358> \n<359> /* Not connected ? */\n<360> \n<361> openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n<362> \n<363> /* Check this */\n<364> \n<365> openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n<366> \n<367> ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n<368> \n<369> break;\n<370> \n<371> #if defined(TARGET_PPC64)\n<372> \n<373> case PPC_FLAGS_INPUT_970:\n<374> \n<375> openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n<376> \n<377> openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n<378> \n<379> ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n<380> \n<381> openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n<382> \n<383> ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n<384> \n<385> openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n<386> \n<387> ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n<388> \n<389> /* Not connected ? */\n<390> \n<391> openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n<392> \n<393> /* Check this */\n<394> \n<395> openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n<396> \n<397> ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n<398> \n<399> break;\n<400> \n<401> #endif /* defined(TARGET_PPC64) */\n<402> \n<403> default:\n<404> \n<405> hw_error("Bus model not supported on mac99 machine\n");\n<406> \n<407> exit(1);\n<408> \n<409> }\n<410> \n<411> }\n<412> \n<413> \n<414> \n<415> pic = g_new0(qemu_irq, 64);\n<416> \n<417> \n<418> \n<419> dev = qdev_create(NULL, TYPE_OPENPIC);\n<420> \n<421> qdev_prop_set_uint32(dev, "model", OPENPIC_MODEL_RAVEN);\n<422> \n<423> qdev_init_nofail(dev);\n<424> \n<425> s = SYS_BUS_DEVICE(dev);\n<426> \n<427> pic_mem = s->mmio[0].memory;\n<428> \n<429> k = 0;\n<430> \n<431> for (i = 0; i < smp_cpus; i++) {\n<432> \n<433> for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {\n<434> \n<435> sysbus_connect_irq(s, k++, openpic_irqs[i][j]);\n<436> \n<437> }\n<438> \n<439> }\n<440> \n<441> \n<442> \n<443> for (i = 0; i < 64; i++) {\n<444> \n<445> pic[i] = qdev_get_gpio_in(dev, i);\n<446> \n<447> }\n<448> \n<449> \n<450> \n<451> if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {\n<452> \n<453> /* 970 gets a U3 bus */\n<454> \n<455> pci_bus = pci_pmac_u3_init(pic, get_system_memory(), get_system_io());\n<456> \n<457> machine_arch = ARCH_MAC99_U3;\n<458> \n<459> machine->usb |= defaults_enabled();\n<460> \n<461> } else {\n<462> \n<463> pci_bus = pci_pmac_init(pic, get_system_memory(), get_system_io());\n<464> \n<465> machine_arch = ARCH_MAC99;\n<466> \n<467> }\n<468> \n<469> \n<470> \n<471> /* Timebase Frequency */\n<472> \n<473> if (kvm_enabled()) {\n<474> \n<475> tbfreq = kvmppc_get_tbfreq();\n<476> \n<477> } else {\n<478> \n<479> tbfreq = TBFREQ;\n<480> \n<481> }\n<482> \n<483> \n<484> \n<485> /* init basic PC hardware */\n<486> \n<487> escc_mem = escc_init(0, pic[0x25], pic[0x24],\n<488> \n<489> serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);\n<490> \n<491> memory_region_init_alias(escc_bar, NULL, "escc-bar",\n<492> \n<493> escc_mem, 0, memory_region_size(escc_mem));\n<494> \n<495> \n<496> \n<497> macio = pci_create(pci_bus, -1, TYPE_NEWWORLD_MACIO);\n<498> \n<499> dev = DEVICE(macio);\n<500> \n<501> qdev_connect_gpio_out(dev, 0, pic[0x19]); /* CUDA */\n<502> \n<503> qdev_connect_gpio_out(dev, 1, pic[0x0d]); /* IDE */\n<504> \n<505> qdev_connect_gpio_out(dev, 2, pic[0x02]); /* IDE DMA */\n<506> \n<507> qdev_connect_gpio_out(dev, 3, pic[0x0e]); /* IDE */\n<508> \n<509> qdev_connect_gpio_out(dev, 4, pic[0x03]); /* IDE DMA */\n<510> \n<511> qdev_prop_set_uint64(dev, "frequency", tbfreq);\n<512> \n<513> macio_init(macio, pic_mem, escc_bar);\n<514> \n<515> \n<516> \n<517> /* We only emulate 2 out of 3 IDE controllers for now */\n<518> \n<519> ide_drive_get(hd, ARRAY_SIZE(hd));\n<520> \n<521> \n<522> \n<523> macio_ide = MACIO_IDE(object_resolve_path_component(OBJECT(macio),\n<524> \n<525> "ide[0]"));\n<526> \n<527> macio_ide_init_drives(macio_ide, hd);\n<528> \n<529> \n<530> \n<531> macio_ide = MACIO_IDE(object_resolve_path_component(OBJECT(macio),\n<532> \n<533> "ide[1]"));\n<534> \n<535> macio_ide_init_drives(macio_ide, &hd[MAX_IDE_DEVS]);\n<536> \n<537> \n<538> \n<539> dev = DEVICE(object_resolve_path_component(OBJECT(macio), "cuda"));\n<540> \n<541> adb_bus = qdev_get_child_bus(dev, "adb.0");\n<542> \n<543> dev = qdev_create(adb_bus, TYPE_ADB_KEYBOARD);\n<544> \n<545> qdev_init_nofail(dev);\n<546> \n<547> dev = qdev_create(adb_bus, TYPE_ADB_MOUSE);\n<548> \n<549> qdev_init_nofail(dev);\n<550> \n<551> \n<552> \n<553> if (machine->usb) {\n<554> \n<555> pci_create_simple(pci_bus, -1, "pci-ohci");\n<556> \n<557> \n<558> \n<559> /* U3 needs to use USB for input because Linux doesn't support via-cuda\n<560> \n<561> on PPC64 */\n<562> \n<563> if (machine_arch == ARCH_MAC99_U3) {\n<564> \n<565> USBBus *usb_bus = usb_bus_find(-1);\n<566> \n<567> \n<568> \n<569> usb_create_simple(usb_bus, "usb-kbd");\n<570> \n<571> usb_create_simple(usb_bus, "usb-mouse");\n<572> \n<573> }\n<574> \n<575> }\n<576> \n<577> \n<578> \n<579> pci_vga_init(pci_bus);\n<580> \n<581> \n<582> \n<583> if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8) {\n<584> \n<585> graphic_depth = 15;\n<586> \n<587> }\n<588> \n<589> \n<590> \n<591> for (i = 0; i < nb_nics; i++) {\n<592> \n<593> pci_nic_init_nofail(&nd_table[i], pci_bus, "ne2k_pci", NULL);\n<594> \n<595> }\n<596> \n<597> \n<598> \n<599> /* The NewWorld NVRAM is not located in the MacIO device */\n<600> \n<601> #ifdef CONFIG_KVM\n<602> \n<603> if (kvm_enabled() && getpagesize() > 4096) {\n<604> \n<605> /* We can't combine read-write and read-only in a single page, so\n<606> \n<607> move the NVRAM out of ROM again for KVM */\n<608> \n<609> nvram_addr = 0xFFE00000;\n<610> \n<611> }\n<612> \n<613> #endif\n<614> \n<615> dev = qdev_create(NULL, TYPE_MACIO_NVRAM);\n<616> \n<617> qdev_prop_set_uint32(dev, "size", 0x2000);\n<618> \n<619> qdev_prop_set_uint32(dev, "it_shift", 1);\n<620> \n<621> qdev_init_nofail(dev);\n<622> \n<623> sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, nvram_addr);\n<624> \n<625> nvr = MACIO_NVRAM(dev);\n<626> \n<627> pmac_format_nvram_partition(nvr, 0x2000);\n<628> \n<629> /* No PCI init: the BIOS will do it */\n<630> \n<631> \n<632> \n<633> fw_cfg = fw_cfg_init_mem(CFG_ADDR, CFG_ADDR + 2);\n<634> \n<635> fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)max_cpus);\n<636> \n<637> fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n<638> \n<639> fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n<640> \n<641> fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);\n<642> \n<643> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n<644> \n<645> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n<646> \n<647> if (kernel_cmdline) {\n<648> \n<649> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, cmdline_base);\n<650> \n<651> pstrcpy_targphys("cmdline", cmdline_base, TARGET_PAGE_SIZE, kernel_cmdline);\n<652> \n<653> } else {\n<654> \n<655> fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n<656> \n<657> }\n<658> \n<659> fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n<660> \n<661> fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n<662> \n<663> fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n<664> \n<665> \n<666> \n<667> fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n<668> \n<669> fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n<670> \n<671> fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n<672> \n<673> \n<674> \n<675> fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n<676> \n<677> if (kvm_enabled()) {\n<678> \n<679> #ifdef CONFIG_KVM\n<680> \n<681> uint8_t *hypercall;\n<682> \n<683> \n<684> \n<685> hypercall = g_malloc(16);\n<686> \n<687> kvmppc_get_hypercall(env, hypercall, 16);\n<688> \n<689> fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n<690> \n<691> fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n<692> \n<693> #endif\n<694> \n<695> }\n<696> \n<697> fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, tbfreq);\n<698> \n<699> /* Mac OS X requires a "known good" clock-frequency value; pass it one. */\n<700> \n<701> fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_CLOCKFREQ, CLOCKFREQ);\n<702> \n<703> fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_BUSFREQ, BUSFREQ);\n<704> \n<705> fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_NVRAM_ADDR, nvram_addr);\n<706> \n<707> \n<708> \n<709> qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n<710> \n<711> }\n<712> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void qmp_ringbuf_write(const char *device, const char *data,\n<2> \n<3> bool has_format, enum DataFormat format,\n<4> \n<5> Error **errp)\n<6> \n<7> {\n<8> \n<9> CharDriverState *chr;\n<10> \n<11> const uint8_t *write_data;\n<12> \n<13> int ret;\n<14> \n<15> gsize write_count;\n<16> \n<17> \n<18> \n<19> chr = qemu_chr_find(device);\n<20> \n<21> if (!chr) {\n<22> \n<23> error_setg(errp, "Device '%s' not found", device);\n<24> \n<25> return;\n<26> \n<27> }\n<28> \n<29> \n<30> \n<31> if (!chr_is_ringbuf(chr)) {\n<32> \n<33> error_setg(errp,"%s is not a ringbuf device", device);\n<34> \n<35> return;\n<36> \n<37> }\n<38> \n<39> \n<40> \n<41> if (has_format && (format == DATA_FORMAT_BASE64)) {\n<42> \n<43> write_data = g_base64_decode(data, &write_count);\n<44> \n<45> } else {\n<46> \n<47> write_data = (uint8_t *)data;\n<48> \n<49> write_count = strlen(data);\n<50> \n<51> }\n<52> \n<53> \n<54> \n<55> ret = ringbuf_chr_write(chr, write_data, write_count);\n<56> \n<57> \n<58> \n<59> if (write_data != (uint8_t *)data) {\n<60> \n<61> g_free((void *)write_data);\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> if (ret < 0) {\n<68> \n<69> error_setg(errp, "Failed to write to device %s", device);\n<70> \n<71> return;\n<72> \n<73> }\n<74> \n<75> }\n<76> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int MP3lame_encode_frame(AVCodecContext *avctx,\n<2> \n<3> unsigned char *frame, int buf_size, void *data)\n<4> \n<5> {\n<6> \n<7> Mp3AudioContext *s = avctx->priv_data;\n<8> \n<9> int len;\n<10> \n<11> int lame_result;\n<12> \n<13> \n<14> \n<15> /* lame 3.91 dies on '1-channel interleaved' data */\n<16> \n<17> \n<18> \n<19> if(data){\n<20> \n<21> if (s->stereo) {\n<22> \n<23> lame_result = lame_encode_buffer_interleaved(\n<24> \n<25> s->gfp,\n<26> \n<27> data,\n<28> \n<29> avctx->frame_size,\n<30> \n<31> s->buffer + s->buffer_index,\n<32> \n<33> BUFFER_SIZE - s->buffer_index\n<34> \n<35> );\n<36> \n<37> } else {\n<38> \n<39> lame_result = lame_encode_buffer(\n<40> \n<41> s->gfp,\n<42> \n<43> data,\n<44> \n<45> data,\n<46> \n<47> avctx->frame_size,\n<48> \n<49> s->buffer + s->buffer_index,\n<50> \n<51> BUFFER_SIZE - s->buffer_index\n<52> \n<53> );\n<54> \n<55> }\n<56> \n<57> }else{\n<58> \n<59> lame_result= lame_encode_flush(\n<60> \n<61> s->gfp,\n<62> \n<63> s->buffer + s->buffer_index,\n<64> \n<65> BUFFER_SIZE - s->buffer_index\n<66> \n<67> );\n<68> \n<69> }\n<70> \n<71> \n<72> \n<73> if(lame_result==-1) {\n<74> \n<75> /* output buffer too small */\n<76> \n<77> av_log(avctx, AV_LOG_ERROR, "lame: output buffer too small (buffer index: %d, free bytes: %d)\n", s->buffer_index, BUFFER_SIZE - s->buffer_index);\n<78> \n<79> return 0;\n<80> \n<81> }\n<82> \n<83> \n<84> \n<85> s->buffer_index += lame_result;\n<86> \n<87> \n<88> \n<89> if(s->buffer_index<4)\n<90> \n<91> return 0;\n<92> \n<93> \n<94> \n<95> len= mp3len(s->buffer, NULL, NULL);\n<96> \n<97> //av_log(avctx, AV_LOG_DEBUG, "in:%d packet-len:%d index:%d\n", avctx->frame_size, len, s->buffer_index);\n<98> \n<99> if(len <= s->buffer_index){\n<100> \n<101> memcpy(frame, s->buffer, len);\n<102> \n<103> s->buffer_index -= len;\n<104> \n<105> \n<106> \n<107> memmove(s->buffer, s->buffer+len, s->buffer_index);\n<108> \n<109> //FIXME fix the audio codec API, so we do not need the memcpy()\n<110> \n<111> /*for(i=0; i<len; i++){\n<112> \n<113> av_log(avctx, AV_LOG_DEBUG, "%2X ", frame[i]);\n<114> \n<115> }*/\n<116> \n<117> return len;\n<118> \n<119> }else\n<120> \n<121> return 0;\n<122> \n<123> }\n<124> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n<2> \n<3> {\n<4> \n<5> fprintf_ftype       fprintf = info->fprintf_func;\n<6> \n<7> void *              stream = info->stream;\n<8> \n<9> unsigned long       inst, prev_inst;\n<10> \n<11> struct op_code_struct * op, *pop;\n<12> \n<13> int                 immval = 0;\n<14> \n<15> bfd_boolean         immfound = FALSE;\n<16> \n<17> static bfd_vma prev_insn_addr = -1; /*init the prev insn addr */\n<18> \n<19> static int     prev_insn_vma = -1;  /*init the prev insn vma */\n<20> \n<21> int            curr_insn_vma = info->buffer_vma;\n<22> \n<23> \n<24> \n<25> info->bytes_per_chunk = 4;\n<26> \n<27> \n<28> \n<29> inst = read_insn_microblaze (memaddr, info, &op);\n<30> \n<31> if (inst == 0) {\n<32> \n<33> return -1;\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> if (prev_insn_vma == curr_insn_vma) {\n<40> \n<41> if (memaddr-(info->bytes_per_chunk) == prev_insn_addr) {\n<42> \n<43> prev_inst = read_insn_microblaze (prev_insn_addr, info, &pop);\n<44> \n<45> if (prev_inst == 0)\n<46> \n<47> return -1;\n<48> \n<49> if (pop->instr == imm) {\n<50> \n<51> immval = (get_int_field_imm(prev_inst) << 16) & 0xffff0000;\n<52> \n<53> immfound = TRUE;\n<54> \n<55> }\n<56> \n<57> else {\n<58> \n<59> immval = 0;\n<60> \n<61> immfound = FALSE;\n<62> \n<63> }\n<64> \n<65> }\n<66> \n<67> }\n<68> \n<69> /* make curr insn as prev insn */\n<70> \n<71> prev_insn_addr = memaddr;\n<72> \n<73> prev_insn_vma = curr_insn_vma;\n<74> \n<75> \n<76> \n<77> if (op->name == 0) {\n<78> \n<79> fprintf (stream, ".short 0x%04lx", inst);\n<80> \n<81> }\n<82> \n<83> else\n<84> \n<85> {\n<86> \n<87> fprintf (stream, "%s", op->name);\n<88> \n<89> \n<90> \n<91> switch (op->inst_type)\n<92> \n<93> {\n<94> \n<95> case INST_TYPE_RD_R1_R2:\n<96> \n<97> fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_r2(inst));\n<98> \n<99> break;\n<100> \n<101> case INST_TYPE_RD_R1_IMM:\n<102> \n<103> fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_imm(inst));\n<104> \n<105> if (info->print_address_func && get_int_field_r1(inst) == 0 && info->symbol_at_address_func) {\n<106> \n<107> if (immfound)\n<108> \n<109> immval |= (get_int_field_imm(inst) & 0x0000ffff);\n<110> \n<111> else {\n<112> \n<113> immval = get_int_field_imm(inst);\n<114> \n<115> if (immval & 0x8000)\n<116> \n<117> immval |= 0xFFFF0000;\n<118> \n<119> }\n<120> \n<121> if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n<122> \n<123> fprintf (stream, "\t// ");\n<124> \n<125> info->print_address_func (immval, info);\n<126> \n<127> }\n<128> \n<129> }\n<130> \n<131> break;\n<132> \n<133> case INST_TYPE_RD_R1_IMM5:\n<134> \n<135> fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_imm5(inst));\n<136> \n<137> break;\n<138> \n<139> case INST_TYPE_RD_RFSL:\n<140> \n<141> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_rfsl(inst));\n<142> \n<143> break;\n<144> \n<145> case INST_TYPE_R1_RFSL:\n<146> \n<147> fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_rfsl(inst));\n<148> \n<149> break;\n<150> \n<151> case INST_TYPE_RD_SPECIAL:\n<152> \n<153> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_special(inst, op));\n<154> \n<155> break;\n<156> \n<157> case INST_TYPE_SPECIAL_R1:\n<158> \n<159> fprintf(stream, "\t%s, %s", get_field_special(inst, op), get_field_r1(inst));\n<160> \n<161> break;\n<162> \n<163> case INST_TYPE_RD_R1:\n<164> \n<165> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r1(inst));\n<166> \n<167> break;\n<168> \n<169> case INST_TYPE_R1_R2:\n<170> \n<171> fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_r2(inst));\n<172> \n<173> break;\n<174> \n<175> case INST_TYPE_R1_IMM:\n<176> \n<177> fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_imm(inst));\n<178> \n<179> /* The non-pc relative instructions are returns, which shouldn't\n<180> \n<181> have a label printed */\n<182> \n<183> if (info->print_address_func && op->inst_offset_type == INST_PC_OFFSET && info->symbol_at_address_func) {\n<184> \n<185> if (immfound)\n<186> \n<187> immval |= (get_int_field_imm(inst) & 0x0000ffff);\n<188> \n<189> else {\n<190> \n<191> immval = get_int_field_imm(inst);\n<192> \n<193> if (immval & 0x8000)\n<194> \n<195> immval |= 0xFFFF0000;\n<196> \n<197> }\n<198> \n<199> immval += memaddr;\n<200> \n<201> if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n<202> \n<203> fprintf (stream, "\t// ");\n<204> \n<205> info->print_address_func (immval, info);\n<206> \n<207> } else {\n<208> \n<209> fprintf (stream, "\t\t// ");\n<210> \n<211> fprintf (stream, "%x", immval);\n<212> \n<213> }\n<214> \n<215> }\n<216> \n<217> break;\n<218> \n<219> case INST_TYPE_RD_IMM:\n<220> \n<221> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_imm(inst));\n<222> \n<223> if (info->print_address_func && info->symbol_at_address_func) {\n<224> \n<225> if (immfound)\n<226> \n<227> immval |= (get_int_field_imm(inst) & 0x0000ffff);\n<228> \n<229> else {\n<230> \n<231> immval = get_int_field_imm(inst);\n<232> \n<233> if (immval & 0x8000)\n<234> \n<235> immval |= 0xFFFF0000;\n<236> \n<237> }\n<238> \n<239> if (op->inst_offset_type == INST_PC_OFFSET)\n<240> \n<241> immval += (int) memaddr;\n<242> \n<243> if (info->symbol_at_address_func(immval, info)) {\n<244> \n<245> fprintf (stream, "\t// ");\n<246> \n<247> info->print_address_func (immval, info);\n<248> \n<249> }\n<250> \n<251> }\n<252> \n<253> break;\n<254> \n<255> case INST_TYPE_IMM:\n<256> \n<257> fprintf(stream, "\t%s", get_field_imm(inst));\n<258> \n<259> if (info->print_address_func && info->symbol_at_address_func && op->instr != imm) {\n<260> \n<261> if (immfound)\n<262> \n<263> immval |= (get_int_field_imm(inst) & 0x0000ffff);\n<264> \n<265> else {\n<266> \n<267> immval = get_int_field_imm(inst);\n<268> \n<269> if (immval & 0x8000)\n<270> \n<271> immval |= 0xFFFF0000;\n<272> \n<273> }\n<274> \n<275> if (op->inst_offset_type == INST_PC_OFFSET)\n<276> \n<277> immval += (int) memaddr;\n<278> \n<279> if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n<280> \n<281> fprintf (stream, "\t// ");\n<282> \n<283> info->print_address_func (immval, info);\n<284> \n<285> } else if (op->inst_offset_type == INST_PC_OFFSET) {\n<286> \n<287> fprintf (stream, "\t\t// ");\n<288> \n<289> fprintf (stream, "%x", immval);\n<290> \n<291> }\n<292> \n<293> }\n<294> \n<295> break;\n<296> \n<297> case INST_TYPE_RD_R2:\n<298> \n<299> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r2(inst));\n<300> \n<301> break;\n<302> \n<303> case INST_TYPE_R2:\n<304> \n<305> fprintf(stream, "\t%s", get_field_r2(inst));\n<306> \n<307> break;\n<308> \n<309> case INST_TYPE_R1:\n<310> \n<311> fprintf(stream, "\t%s", get_field_r1(inst));\n<312> \n<313> break;\n<314> \n<315> case INST_TYPE_RD_R1_SPECIAL:\n<316> \n<317> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r2(inst));\n<318> \n<319> break;\n<320> \n<321> case INST_TYPE_RD_IMM15:\n<322> \n<323> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_imm15(inst));\n<324> \n<325> break;\n<326> \n<327> /* For tuqula instruction */\n<328> \n<329> case INST_TYPE_RD:\n<330> \n<331> fprintf(stream, "\t%s", get_field_rd(inst));\n<332> \n<333> break;\n<334> \n<335> case INST_TYPE_RFSL:\n<336> \n<337> fprintf(stream, "\t%s", get_field_rfsl(inst));\n<338> \n<339> break;\n<340> \n<341> default:\n<342> \n<343> /* if the disassembler lags the instruction set */\n<344> \n<345> fprintf (stream, "\tundecoded operands, inst is 0x%04lx", inst);\n<346> \n<347> break;\n<348> \n<349> }\n<350> \n<351> }\n<352> \n<353> \n<354> \n<355> /* Say how many bytes we consumed? */\n<356> \n<357> return 4;\n<358> \n<359> }\n<360> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static abi_ulong load_elf_interp(struct elfhdr * interp_elf_ex,\n<2> \n<3> int interpreter_fd,\n<4> \n<5> abi_ulong *interp_load_addr,\n<6> \n<7> char bprm_buf[BPRM_BUF_SIZE])\n<8> \n<9> {\n<10> \n<11> struct elf_phdr *elf_phdata  =  NULL;\n<12> \n<13> abi_ulong load_addr, load_bias, loaddr, hiaddr;\n<14> \n<15> int retval;\n<16> \n<17> abi_ulong error;\n<18> \n<19> int i;\n<20> \n<21> \n<22> \n<23> bswap_ehdr(interp_elf_ex);\n<24> \n<25> /* First of all, some simple consistency checks */\n<26> \n<27> if ((interp_elf_ex->e_type != ET_EXEC &&\n<28> \n<29> interp_elf_ex->e_type != ET_DYN) ||\n<30> \n<31> !elf_check_arch(interp_elf_ex->e_machine)) {\n<32> \n<33> return ~((abi_ulong)0UL);\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> /* Now read in all of the header information */\n<40> \n<41> \n<42> \n<43> if (sizeof(struct elf_phdr) * interp_elf_ex->e_phnum > TARGET_PAGE_SIZE)\n<44> \n<45> return ~(abi_ulong)0UL;\n<46> \n<47> \n<48> \n<49> elf_phdata =  (struct elf_phdr *)\n<50> \n<51> malloc(sizeof(struct elf_phdr) * interp_elf_ex->e_phnum);\n<52> \n<53> \n<54> \n<55> if (!elf_phdata)\n<56> \n<57> return ~((abi_ulong)0UL);\n<58> \n<59> \n<60> \n<61> /*\n<62> \n<63> * If the size of this structure has changed, then punt, since\n<64> \n<65> * we will be doing the wrong thing.\n<66> \n<67> */\n<68> \n<69> if (interp_elf_ex->e_phentsize != sizeof(struct elf_phdr)) {\n<70> \n<71> free(elf_phdata);\n<72> \n<73> return ~((abi_ulong)0UL);\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> i = interp_elf_ex->e_phnum * sizeof(struct elf_phdr);\n<80> \n<81> if (interp_elf_ex->e_phoff + i <= BPRM_BUF_SIZE) {\n<82> \n<83> memcpy(elf_phdata, bprm_buf + interp_elf_ex->e_phoff, i);\n<84> \n<85> } else {\n<86> \n<87> retval = pread(interpreter_fd, elf_phdata, i, interp_elf_ex->e_phoff);\n<88> \n<89> if (retval != i) {\n<90> \n<91> perror("load_elf_interp");\n<92> \n<93> exit(-1);\n<94> \n<95> }\n<96> \n<97> }\n<98> \n<99> bswap_phdr(elf_phdata, interp_elf_ex->e_phnum);\n<100> \n<101> \n<102> \n<103> /* Find the maximum size of the image and allocate an appropriate\n<104> \n<105> amount of memory to handle that.  */\n<106> \n<107> loaddr = -1, hiaddr = 0;\n<108> \n<109> for (i = 0; i < interp_elf_ex->e_phnum; ++i) {\n<110> \n<111> if (elf_phdata[i].p_type == PT_LOAD) {\n<112> \n<113> abi_ulong a = elf_phdata[i].p_vaddr;\n<114> \n<115> if (a < loaddr) {\n<116> \n<117> loaddr = a;\n<118> \n<119> }\n<120> \n<121> a += elf_phdata[i].p_memsz;\n<122> \n<123> if (a > hiaddr) {\n<124> \n<125> hiaddr = a;\n<126> \n<127> }\n<128> \n<129> }\n<130> \n<131> }\n<132> \n<133> \n<134> \n<135> load_addr = loaddr;\n<136> \n<137> if (interp_elf_ex->e_type == ET_DYN) {\n<138> \n<139> /* The image indicates that it can be loaded anywhere.  Find a\n<140> \n<141> location that can hold the memory space required.  If the\n<142> \n<143> image is pre-linked, LOADDR will be non-zero.  Since we do\n<144> \n<145> not supply MAP_FIXED here we'll use that address if and\n<146> \n<147> only if it remains available.  */\n<148> \n<149> load_addr = target_mmap(loaddr, hiaddr - loaddr, PROT_NONE,\n<150> \n<151> MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,\n<152> \n<153> -1, 0);\n<154> \n<155> if (load_addr == -1) {\n<156> \n<157> perror("mmap");\n<158> \n<159> exit(-1);\n<160> \n<161> }\n<162> \n<163> }\n<164> \n<165> load_bias = load_addr - loaddr;\n<166> \n<167> \n<168> \n<169> for (i = 0; i < interp_elf_ex->e_phnum; i++) {\n<170> \n<171> struct elf_phdr *eppnt = elf_phdata + i;\n<172> \n<173> if (eppnt->p_type == PT_LOAD) {\n<174> \n<175> abi_ulong vaddr, vaddr_po, vaddr_ps, vaddr_ef, vaddr_em;\n<176> \n<177> int elf_prot = 0;\n<178> \n<179> \n<180> \n<181> if (eppnt->p_flags & PF_R) elf_prot =  PROT_READ;\n<182> \n<183> if (eppnt->p_flags & PF_W) elf_prot |= PROT_WRITE;\n<184> \n<185> if (eppnt->p_flags & PF_X) elf_prot |= PROT_EXEC;\n<186> \n<187> \n<188> \n<189> vaddr = load_bias + eppnt->p_vaddr;\n<190> \n<191> vaddr_po = TARGET_ELF_PAGEOFFSET(vaddr);\n<192> \n<193> vaddr_ps = TARGET_ELF_PAGESTART(vaddr);\n<194> \n<195> \n<196> \n<197> error = target_mmap(vaddr_ps, eppnt->p_filesz + vaddr_po,\n<198> \n<199> elf_prot, MAP_PRIVATE | MAP_FIXED,\n<200> \n<201> interpreter_fd, eppnt->p_offset - vaddr_po);\n<202> \n<203> if (error == -1) {\n<204> \n<205> /* Real error */\n<206> \n<207> close(interpreter_fd);\n<208> \n<209> free(elf_phdata);\n<210> \n<211> return ~((abi_ulong)0UL);\n<212> \n<213> }\n<214> \n<215> \n<216> \n<217> vaddr_ef = vaddr + eppnt->p_filesz;\n<218> \n<219> vaddr_em = vaddr + eppnt->p_memsz;\n<220> \n<221> \n<222> \n<223> /* If the load segment requests extra zeros (e.g. bss), map it.  */\n<224> \n<225> if (vaddr_ef < vaddr_em) {\n<226> \n<227> zero_bss(vaddr_ef, vaddr_em, elf_prot);\n<228> \n<229> }\n<230> \n<231> }\n<232> \n<233> }\n<234> \n<235> \n<236> \n<237> if (qemu_log_enabled()) {\n<238> \n<239> load_symbols(interp_elf_ex, interpreter_fd, load_bias);\n<240> \n<241> }\n<242> \n<243> \n<244> \n<245> close(interpreter_fd);\n<246> \n<247> free(elf_phdata);\n<248> \n<249> \n<250> \n<251> *interp_load_addr = load_addr;\n<252> \n<253> return ((abi_ulong) interp_elf_ex->e_entry) + load_bias;\n<254> \n<255> }\n<256> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)\n<2> \n<3> {\n<4> \n<5> uintptr_t host_start, host_map_start, host_end;\n<6> \n<7> \n<8> \n<9> last_bss = TARGET_PAGE_ALIGN(last_bss);\n<10> \n<11> \n<12> \n<13> /* ??? There is confusion between qemu_real_host_page_size and\n<14> \n<15> qemu_host_page_size here and elsewhere in target_mmap, which\n<16> \n<17> may lead to the end of the data section mapping from the file\n<18> \n<19> not being mapped.  At least there was an explicit test and\n<20> \n<21> comment for that here, suggesting that "the file size must\n<22> \n<23> be known".  The comment probably pre-dates the introduction\n<24> \n<25> of the fstat system call in target_mmap which does in fact\n<26> \n<27> find out the size.  What isn't clear is if the workaround\n<28> \n<29> here is still actually needed.  For now, continue with it,\n<30> \n<31> but merge it with the "normal" mmap that would allocate the bss.  */\n<32> \n<33> \n<34> \n<35> host_start = (uintptr_t) g2h(elf_bss);\n<36> \n<37> host_end = (uintptr_t) g2h(last_bss);\n<38> \n<39> host_map_start = (host_start + qemu_real_host_page_size - 1);\n<40> \n<41> host_map_start &= -qemu_real_host_page_size;\n<42> \n<43> \n<44> \n<45> if (host_map_start < host_end) {\n<46> \n<47> void *p = mmap((void *)host_map_start, host_end - host_map_start,\n<48> \n<49> prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n<50> \n<51> if (p == MAP_FAILED) {\n<52> \n<53> perror("cannot mmap brk");\n<54> \n<55> exit(-1);\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> /* Since we didn't use target_mmap, make sure to record\n<62> \n<63> the validity of the pages with qemu.  */\n<64> \n<65> page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> if (host_start < host_map_start) {\n<72> \n<73> memset((void *)host_start, 0, host_map_start - host_start);\n<74> \n<75> }\n<76> \n<77> }\n<78> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void check_itxfm(void)\n<2> \n<3> {\n<4> \n<5> LOCAL_ALIGNED_32(uint8_t, src, [32 * 32 * 2]);\n<6> \n<7> LOCAL_ALIGNED_32(uint8_t, dst, [32 * 32 * 2]);\n<8> \n<9> LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]);\n<10> \n<11> LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]);\n<12> \n<13> LOCAL_ALIGNED_32(int16_t, coef, [32 * 32 * 2]);\n<14> \n<15> LOCAL_ALIGNED_32(int16_t, subcoef0, [32 * 32 * 2]);\n<16> \n<17> LOCAL_ALIGNED_32(int16_t, subcoef1, [32 * 32 * 2]);\n<18> \n<19> declare_func_emms(AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMXEXT, void, uint8_t *dst, ptrdiff_t stride, int16_t *block, int eob);\n<20> \n<21> VP9DSPContext dsp;\n<22> \n<23> int y, x, tx, txtp, bit_depth, sub;\n<24> \n<25> static const char *const txtp_types[N_TXFM_TYPES] = {\n<26> \n<27> [DCT_DCT] = "dct_dct", [DCT_ADST] = "adst_dct",\n<28> \n<29> [ADST_DCT] = "dct_adst", [ADST_ADST] = "adst_adst"\n<30> \n<31> };\n<32> \n<33> \n<34> \n<35> for (bit_depth = 8; bit_depth <= 12; bit_depth += 2) {\n<36> \n<37> ff_vp9dsp_init(&dsp, bit_depth, 0);\n<38> \n<39> \n<40> \n<41> for (tx = TX_4X4; tx <= N_TXFM_SIZES /* 4 = lossless */; tx++) {\n<42> \n<43> int sz = 4 << (tx & 3);\n<44> \n<45> int n_txtps = tx < TX_32X32 ? N_TXFM_TYPES : 1;\n<46> \n<47> \n<48> \n<49> for (txtp = 0; txtp < n_txtps; txtp++) {\n<50> \n<51> if (check_func(dsp.itxfm_add[tx][txtp], "vp9_inv_%s_%dx%d_add_%d",\n<52> \n<53> tx == 4 ? "wht_wht" : txtp_types[txtp], sz, sz,\n<54> \n<55> bit_depth)) {\n<56> \n<57> randomize_buffers();\n<58> \n<59> ftx(coef, tx, txtp, sz, bit_depth);\n<60> \n<61> \n<62> \n<63> for (sub = (txtp == 0) ? 1 : 2; sub <= sz; sub <<= 1) {\n<64> \n<65> int eob;\n<66> \n<67> \n<68> \n<69> if (sub < sz) {\n<70> \n<71> eob = copy_subcoefs(subcoef0, coef, tx, txtp,\n<72> \n<73> sz, sub, bit_depth);\n<74> \n<75> } else {\n<76> \n<77> eob = sz * sz;\n<78> \n<79> memcpy(subcoef0, coef, sz * sz * SIZEOF_COEF);\n<80> \n<81> }\n<82> \n<83> \n<84> \n<85> memcpy(dst0, dst, sz * sz * SIZEOF_PIXEL);\n<86> \n<87> memcpy(dst1, dst, sz * sz * SIZEOF_PIXEL);\n<88> \n<89> memcpy(subcoef1, subcoef0, sz * sz * SIZEOF_COEF);\n<90> \n<91> call_ref(dst0, sz * SIZEOF_PIXEL, subcoef0, eob);\n<92> \n<93> call_new(dst1, sz * SIZEOF_PIXEL, subcoef1, eob);\n<94> \n<95> if (memcmp(dst0, dst1, sz * sz * SIZEOF_PIXEL) ||\n<96> \n<97> !iszero(subcoef0, sz * sz * SIZEOF_COEF) ||\n<98> \n<99> !iszero(subcoef1, sz * sz * SIZEOF_COEF))\n<100> \n<101> fail();\n<102> \n<103> }\n<104> \n<105> bench_new(dst, sz * SIZEOF_PIXEL, coef, sz * sz);\n<106> \n<107> }\n<108> \n<109> }\n<110> \n<111> }\n<112> \n<113> }\n<114> \n<115> report("itxfm");\n<116> \n<117> }\n<118> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void ptimer_reload(ptimer_state *s)\n<2> \n<3> {\n<4> \n<5> if (s->delta == 0) {\n<6> \n<7> ptimer_trigger(s);\n<8> \n<9> s->delta = s->limit;\n<10> \n<11> }\n<12> \n<13> if (s->delta == 0 || s->period == 0) {\n<14> \n<15> fprintf(stderr, "Timer with period zero, disabling\n");\n<16> \n<17> s->enabled = 0;\n<18> \n<19> return;\n<20> \n<21> }\n<22> \n<23> \n<24> \n<25> s->last_event = s->next_event;\n<26> \n<27> s->next_event = s->last_event + s->delta * s->period;\n<28> \n<29> if (s->period_frac) {\n<30> \n<31> s->next_event += ((int64_t)s->period_frac * s->delta) >> 32;\n<32> \n<33> }\n<34> \n<35> timer_mod(s->timer, s->next_event);\n<36> \n<37> }\n<38> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline void tcg_out_op(TCGContext *s, int opc, const TCGArg *args,\n<2> \n<3> const int *const_args)\n<4> \n<5> {\n<6> \n<7> int c;\n<8> \n<9> \n<10> \n<11> switch (opc) {\n<12> \n<13> case INDEX_op_exit_tb:\n<14> \n<15> tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0]);\n<16> \n<17> tcg_out32(s, JMPL | INSN_RD(TCG_REG_G0) | INSN_RS1(TCG_REG_I7) |\n<18> \n<19> INSN_IMM13(8));\n<20> \n<21> tcg_out32(s, RESTORE | INSN_RD(TCG_REG_G0) | INSN_RS1(TCG_REG_G0) |\n<22> \n<23> INSN_RS2(TCG_REG_G0));\n<24> \n<25> break;\n<26> \n<27> case INDEX_op_goto_tb:\n<28> \n<29> if (s->tb_jmp_offset) {\n<30> \n<31> /* direct jump method */\n<32> \n<33> if (ABS(args[0] - (unsigned long)s->code_ptr) ==\n<34> \n<35> (ABS(args[0] - (unsigned long)s->code_ptr) & 0x1fffff)) {\n<36> \n<37> tcg_out32(s, BA |\n<38> \n<39> INSN_OFF22(args[0] - (unsigned long)s->code_ptr));\n<40> \n<41> } else {\n<42> \n<43> tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I5, args[0]);\n<44> \n<45> tcg_out32(s, JMPL | INSN_RD(TCG_REG_G0) | INSN_RS1(TCG_REG_I5) |\n<46> \n<47> INSN_RS2(TCG_REG_G0));\n<48> \n<49> }\n<50> \n<51> s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n<52> \n<53> } else {\n<54> \n<55> /* indirect jump method */\n<56> \n<57> tcg_out_ld_ptr(s, TCG_REG_I5, (tcg_target_long)(s->tb_next + args[0]));\n<58> \n<59> tcg_out32(s, JMPL | INSN_RD(TCG_REG_G0) | INSN_RS1(TCG_REG_I5) |\n<60> \n<61> INSN_RS2(TCG_REG_G0));\n<62> \n<63> }\n<64> \n<65> tcg_out_nop(s);\n<66> \n<67> s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n<68> \n<69> break;\n<70> \n<71> case INDEX_op_call:\n<72> \n<73> if (const_args[0]) {\n<74> \n<75> tcg_out32(s, CALL | ((((tcg_target_ulong)args[0]\n<76> \n<77> - (tcg_target_ulong)s->code_ptr) >> 2)\n<78> \n<79> & 0x3fffffff));\n<80> \n<81> tcg_out_nop(s);\n<82> \n<83> } else {\n<84> \n<85> tcg_out_ld_ptr(s, TCG_REG_O7, (tcg_target_long)(s->tb_next + args[0]));\n<86> \n<87> tcg_out32(s, JMPL | INSN_RD(TCG_REG_O7) | INSN_RS1(TCG_REG_O7) |\n<88> \n<89> INSN_RS2(TCG_REG_G0));\n<90> \n<91> tcg_out_nop(s);\n<92> \n<93> }\n<94> \n<95> break;\n<96> \n<97> case INDEX_op_jmp:\n<98> \n<99> fprintf(stderr, "unimplemented jmp\n");\n<100> \n<101> break;\n<102> \n<103> case INDEX_op_br:\n<104> \n<105> fprintf(stderr, "unimplemented br\n");\n<106> \n<107> break;\n<108> \n<109> case INDEX_op_movi_i32:\n<110> \n<111> tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);\n<112> \n<113> break;\n<114> \n<115> \n<116> \n<117> #if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n<118> \n<119> #define OP_32_64(x)                             \\n<120> \n<121> glue(glue(case INDEX_op_, x), _i32:)    \\n<122> \n<123> glue(glue(case INDEX_op_, x), _i64:)\n<124> \n<125> #else\n<126> \n<127> #define OP_32_64(x)                             \\n<128> \n<129> glue(glue(case INDEX_op_, x), _i32:)\n<130> \n<131> #endif\n<132> \n<133> OP_32_64(ld8u);\n<134> \n<135> tcg_out_ldst(s, args[0], args[1], args[2], LDUB);\n<136> \n<137> break;\n<138> \n<139> OP_32_64(ld8s);\n<140> \n<141> tcg_out_ldst(s, args[0], args[1], args[2], LDSB);\n<142> \n<143> break;\n<144> \n<145> OP_32_64(ld16u);\n<146> \n<147> tcg_out_ldst(s, args[0], args[1], args[2], LDUH);\n<148> \n<149> break;\n<150> \n<151> OP_32_64(ld16s);\n<152> \n<153> tcg_out_ldst(s, args[0], args[1], args[2], LDSH);\n<154> \n<155> break;\n<156> \n<157> case INDEX_op_ld_i32:\n<158> \n<159> #if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n<160> \n<161> case INDEX_op_ld32u_i64:\n<162> \n<163> #endif\n<164> \n<165> tcg_out_ldst(s, args[0], args[1], args[2], LDUW);\n<166> \n<167> break;\n<168> \n<169> OP_32_64(st8);\n<170> \n<171> tcg_out_ldst(s, args[0], args[1], args[2], STB);\n<172> \n<173> break;\n<174> \n<175> OP_32_64(st16);\n<176> \n<177> tcg_out_ldst(s, args[0], args[1], args[2], STH);\n<178> \n<179> break;\n<180> \n<181> case INDEX_op_st_i32:\n<182> \n<183> #if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n<184> \n<185> case INDEX_op_st32_i64:\n<186> \n<187> #endif\n<188> \n<189> tcg_out_ldst(s, args[0], args[1], args[2], STW);\n<190> \n<191> break;\n<192> \n<193> OP_32_64(add);\n<194> \n<195> c = ARITH_ADD;\n<196> \n<197> goto gen_arith32;\n<198> \n<199> OP_32_64(sub);\n<200> \n<201> c = ARITH_SUB;\n<202> \n<203> goto gen_arith32;\n<204> \n<205> OP_32_64(and);\n<206> \n<207> c = ARITH_AND;\n<208> \n<209> goto gen_arith32;\n<210> \n<211> OP_32_64(or);\n<212> \n<213> c = ARITH_OR;\n<214> \n<215> goto gen_arith32;\n<216> \n<217> OP_32_64(xor);\n<218> \n<219> c = ARITH_XOR;\n<220> \n<221> goto gen_arith32;\n<222> \n<223> case INDEX_op_shl_i32:\n<224> \n<225> c = SHIFT_SLL;\n<226> \n<227> goto gen_arith32;\n<228> \n<229> case INDEX_op_shr_i32:\n<230> \n<231> c = SHIFT_SRL;\n<232> \n<233> goto gen_arith32;\n<234> \n<235> case INDEX_op_sar_i32:\n<236> \n<237> c = SHIFT_SRA;\n<238> \n<239> goto gen_arith32;\n<240> \n<241> case INDEX_op_mul_i32:\n<242> \n<243> c = ARITH_UMUL;\n<244> \n<245> goto gen_arith32;\n<246> \n<247> case INDEX_op_div2_i32:\n<248> \n<249> #if defined(__sparc_v9__) || defined(__sparc_v8plus__)\n<250> \n<251> c = ARITH_SDIVX;\n<252> \n<253> goto gen_arith32;\n<254> \n<255> #else\n<256> \n<257> tcg_out_sety(s, 0);\n<258> \n<259> c = ARITH_SDIV;\n<260> \n<261> goto gen_arith32;\n<262> \n<263> #endif\n<264> \n<265> case INDEX_op_divu2_i32:\n<266> \n<267> #if defined(__sparc_v9__) || defined(__sparc_v8plus__)\n<268> \n<269> c = ARITH_UDIVX;\n<270> \n<271> goto gen_arith32;\n<272> \n<273> #else\n<274> \n<275> tcg_out_sety(s, 0);\n<276> \n<277> c = ARITH_UDIV;\n<278> \n<279> goto gen_arith32;\n<280> \n<281> #endif\n<282> \n<283> \n<284> \n<285> case INDEX_op_brcond_i32:\n<286> \n<287> fprintf(stderr, "unimplemented brcond\n");\n<288> \n<289> break;\n<290> \n<291> \n<292> \n<293> case INDEX_op_qemu_ld8u:\n<294> \n<295> fprintf(stderr, "unimplemented qld\n");\n<296> \n<297> break;\n<298> \n<299> case INDEX_op_qemu_ld8s:\n<300> \n<301> fprintf(stderr, "unimplemented qld\n");\n<302> \n<303> break;\n<304> \n<305> case INDEX_op_qemu_ld16u:\n<306> \n<307> fprintf(stderr, "unimplemented qld\n");\n<308> \n<309> break;\n<310> \n<311> case INDEX_op_qemu_ld16s:\n<312> \n<313> fprintf(stderr, "unimplemented qld\n");\n<314> \n<315> break;\n<316> \n<317> case INDEX_op_qemu_ld32u:\n<318> \n<319> fprintf(stderr, "unimplemented qld\n");\n<320> \n<321> break;\n<322> \n<323> case INDEX_op_qemu_ld32s:\n<324> \n<325> fprintf(stderr, "unimplemented qld\n");\n<326> \n<327> break;\n<328> \n<329> case INDEX_op_qemu_st8:\n<330> \n<331> fprintf(stderr, "unimplemented qst\n");\n<332> \n<333> break;\n<334> \n<335> case INDEX_op_qemu_st16:\n<336> \n<337> fprintf(stderr, "unimplemented qst\n");\n<338> \n<339> break;\n<340> \n<341> case INDEX_op_qemu_st32:\n<342> \n<343> fprintf(stderr, "unimplemented qst\n");\n<344> \n<345> break;\n<346> \n<347> \n<348> \n<349> #if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n<350> \n<351> case INDEX_op_movi_i64:\n<352> \n<353> tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]);\n<354> \n<355> break;\n<356> \n<357> case INDEX_op_ld32s_i64:\n<358> \n<359> tcg_out_ldst(s, args[0], args[1], args[2], LDSW);\n<360> \n<361> break;\n<362> \n<363> case INDEX_op_ld_i64:\n<364> \n<365> tcg_out_ldst(s, args[0], args[1], args[2], LDX);\n<366> \n<367> break;\n<368> \n<369> case INDEX_op_st_i64:\n<370> \n<371> tcg_out_ldst(s, args[0], args[1], args[2], STX);\n<372> \n<373> break;\n<374> \n<375> case INDEX_op_shl_i64:\n<376> \n<377> c = SHIFT_SLLX;\n<378> \n<379> goto gen_arith32;\n<380> \n<381> case INDEX_op_shr_i64:\n<382> \n<383> c = SHIFT_SRLX;\n<384> \n<385> goto gen_arith32;\n<386> \n<387> case INDEX_op_sar_i64:\n<388> \n<389> c = SHIFT_SRAX;\n<390> \n<391> goto gen_arith32;\n<392> \n<393> case INDEX_op_mul_i64:\n<394> \n<395> c = ARITH_MULX;\n<396> \n<397> goto gen_arith32;\n<398> \n<399> case INDEX_op_div2_i64:\n<400> \n<401> c = ARITH_SDIVX;\n<402> \n<403> goto gen_arith32;\n<404> \n<405> case INDEX_op_divu2_i64:\n<406> \n<407> c = ARITH_UDIVX;\n<408> \n<409> goto gen_arith32;\n<410> \n<411> \n<412> \n<413> case INDEX_op_brcond_i64:\n<414> \n<415> fprintf(stderr, "unimplemented brcond\n");\n<416> \n<417> break;\n<418> \n<419> case INDEX_op_qemu_ld64:\n<420> \n<421> fprintf(stderr, "unimplemented qld\n");\n<422> \n<423> break;\n<424> \n<425> case INDEX_op_qemu_st64:\n<426> \n<427> fprintf(stderr, "unimplemented qst\n");\n<428> \n<429> break;\n<430> \n<431> \n<432> \n<433> #endif\n<434> \n<435> gen_arith32:\n<436> \n<437> if (const_args[2]) {\n<438> \n<439> tcg_out_arithi(s, args[0], args[1], args[2], c);\n<440> \n<441> } else {\n<442> \n<443> tcg_out_arith(s, args[0], args[1], args[2], c);\n<444> \n<445> }\n<446> \n<447> break;\n<448> \n<449> \n<450> \n<451> default:\n<452> \n<453> fprintf(stderr, "unknown opcode 0x%x\n", opc);\n<454> \n<455> tcg_abort();\n<456> \n<457> }\n<458> \n<459> }\n<460> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> alloc_f(int argc, char **argv)\n<2> \n<3> {\n<4> \n<5> int64_t offset;\n<6> \n<7> int nb_sectors;\n<8> \n<9> char s1[64];\n<10> \n<11> int num;\n<12> \n<13> int ret;\n<14> \n<15> const char *retstr;\n<16> \n<17> \n<18> \n<19> offset = cvtnum(argv[1]);\n<20> \n<21> if (offset & 0x1ff) {\n<22> \n<23> printf("offset %lld is not sector aligned\n",\n<24> \n<25> (long long)offset);\n<26> \n<27> return 0;\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> if (argc == 3)\n<34> \n<35> nb_sectors = cvtnum(argv[2]);\n<36> \n<37> else\n<38> \n<39> nb_sectors = 1;\n<40> \n<41> \n<42> \n<43> ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n<44> \n<45> \n<46> \n<47> cvtstr(offset, s1, sizeof(s1));\n<48> \n<49> \n<50> \n<51> retstr = ret ? "allocated" : "not allocated";\n<52> \n<53> if (nb_sectors == 1)\n<54> \n<55> printf("sector %s at offset %s\n", retstr, s1);\n<56> \n<57> else\n<58> \n<59> printf("%d/%d sectors %s at offset %s\n",\n<60> \n<61> num, nb_sectors, retstr, s1);\n<62> \n<63> return 0;\n<64> \n<65> }\n<66> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> avfilter_get_video_buffer_ref_from_arrays(uint8_t *data[4], int linesize[4], int perms,\n<2> \n<3> int w, int h, enum PixelFormat format)\n<4> \n<5> {\n<6> \n<7> AVFilterBuffer *pic = av_mallocz(sizeof(AVFilterBuffer));\n<8> \n<9> AVFilterBufferRef *picref = av_mallocz(sizeof(AVFilterBufferRef));\n<10> \n<11> \n<12> \n<13> if (!pic || !picref)\n<14> \n<15> goto fail;\n<16> \n<17> \n<18> \n<19> picref->buf = pic;\n<20> \n<21> picref->buf->free = ff_avfilter_default_free_buffer;\n<22> \n<23> if (!(picref->video = av_mallocz(sizeof(AVFilterBufferRefVideoProps))))\n<24> \n<25> goto fail;\n<26> \n<27> \n<28> \n<29> picref->video->w = w;\n<30> \n<31> picref->video->h = h;\n<32> \n<33> \n<34> \n<35> /* make sure the buffer gets read permission or it's useless for output */\n<36> \n<37> picref->perms = perms | AV_PERM_READ;\n<38> \n<39> \n<40> \n<41> pic->refcount = 1;\n<42> \n<43> picref->type = AVMEDIA_TYPE_VIDEO;\n<44> \n<45> picref->format = format;\n<46> \n<47> \n<48> \n<49> memcpy(pic->data,        data,          sizeof(pic->data));\n<50> \n<51> memcpy(pic->linesize,    linesize,      sizeof(pic->linesize));\n<52> \n<53> memcpy(picref->data,     pic->data,     sizeof(picref->data));\n<54> \n<55> memcpy(picref->linesize, pic->linesize, sizeof(picref->linesize));\n<56> \n<57> \n<58> \n<59> return picref;\n<60> \n<61> \n<62> \n<63> fail:\n<64> \n<65> if (picref && picref->video)\n<66> \n<67> av_free(picref->video);\n<68> \n<69> av_free(picref);\n<70> \n<71> av_free(pic);\n<72> \n<73> return NULL;\n<74> \n<75> }\n<76> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static inline CopyRet copy_frame(AVCodecContext *avctx,\n<2> \n<3> BC_DTS_PROC_OUT *output,\n<4> \n<5> void *data, int *data_size)\n<6> \n<7> {\n<8> \n<9> BC_STATUS ret;\n<10> \n<11> BC_DTS_STATUS decoder_status = { 0, };\n<12> \n<13> uint8_t trust_interlaced;\n<14> \n<15> uint8_t interlaced;\n<16> \n<17> \n<18> \n<19> CHDContext *priv = avctx->priv_data;\n<20> \n<21> int64_t pkt_pts  = AV_NOPTS_VALUE;\n<22> \n<23> uint8_t pic_type = 0;\n<24> \n<25> \n<26> \n<27> uint8_t bottom_field = (output->PicInfo.flags & VDEC_FLAG_BOTTOMFIELD) ==\n<28> \n<29> VDEC_FLAG_BOTTOMFIELD;\n<30> \n<31> uint8_t bottom_first = !!(output->PicInfo.flags & VDEC_FLAG_BOTTOM_FIRST);\n<32> \n<33> \n<34> \n<35> int width    = output->PicInfo.width;\n<36> \n<37> int height   = output->PicInfo.height;\n<38> \n<39> int bwidth;\n<40> \n<41> uint8_t *src = output->Ybuff;\n<42> \n<43> int sStride;\n<44> \n<45> uint8_t *dst;\n<46> \n<47> int dStride;\n<48> \n<49> \n<50> \n<51> if (output->PicInfo.timeStamp != 0) {\n<52> \n<53> OpaqueList *node = opaque_list_pop(priv, output->PicInfo.timeStamp);\n<54> \n<55> if (node) {\n<56> \n<57> pkt_pts = node->reordered_opaque;\n<58> \n<59> pic_type = node->pic_type;\n<60> \n<61> av_free(node);\n<62> \n<63> } else {\n<64> \n<65> /*\n<66> \n<67> * We will encounter a situation where a timestamp cannot be\n<68> \n<69> * popped if a second field is being returned. In this case,\n<70> \n<71> * each field has the same timestamp and the first one will\n<72> \n<73> * cause it to be popped. To keep subsequent calculations\n<74> \n<75> * simple, pic_type should be set a FIELD value - doesn't\n<76> \n<77> * matter which, but I chose BOTTOM.\n<78> \n<79> */\n<80> \n<81> pic_type = PICT_BOTTOM_FIELD;\n<82> \n<83> }\n<84> \n<85> av_log(avctx, AV_LOG_VERBOSE, "output \"pts\": %"PRIu64"\n",\n<86> \n<87> output->PicInfo.timeStamp);\n<88> \n<89> av_log(avctx, AV_LOG_VERBOSE, "output picture type %d\n",\n<90> \n<91> pic_type);\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> ret = DtsGetDriverStatus(priv->dev, &decoder_status);\n<98> \n<99> if (ret != BC_STS_SUCCESS) {\n<100> \n<101> av_log(avctx, AV_LOG_ERROR,\n<102> \n<103> "CrystalHD: GetDriverStatus failed: %u\n", ret);\n<104> \n<105> return RET_ERROR;\n<106> \n<107> }\n<108> \n<109> \n<110> \n<111> /*\n<112> \n<113> * For most content, we can trust the interlaced flag returned\n<114> \n<115> * by the hardware, but sometimes we can't. These are the\n<116> \n<117> * conditions under which we can trust the flag:\n<118> \n<119> *\n<120> \n<121> * 1) It's not h.264 content\n<122> \n<123> * 2) The UNKNOWN_SRC flag is not set\n<124> \n<125> * 3) We know we're expecting a second field\n<126> \n<127> * 4) The hardware reports this picture and the next picture\n<128> \n<129> *    have the same picture number.\n<130> \n<131> *\n<132> \n<133> * Note that there can still be interlaced content that will\n<134> \n<135> * fail this check, if the hardware hasn't decoded the next\n<136> \n<137> * picture or if there is a corruption in the stream. (In either\n<138> \n<139> * case a 0 will be returned for the next picture number)\n<140> \n<141> */\n<142> \n<143> trust_interlaced = avctx->codec->id != CODEC_ID_H264 ||\n<144> \n<145> !(output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC) ||\n<146> \n<147> priv->need_second_field ||\n<148> \n<149> (decoder_status.picNumFlags & ~0x40000000) ==\n<150> \n<151> output->PicInfo.picture_number;\n<152> \n<153> \n<154> \n<155> /*\n<156> \n<157> * If we got a false negative for trust_interlaced on the first field,\n<158> \n<159> * we will realise our mistake here when we see that the picture number is that\n<160> \n<161> * of the previous picture. We cannot recover the frame and should discard the\n<162> \n<163> * second field to keep the correct number of output frames.\n<164> \n<165> */\n<166> \n<167> if (output->PicInfo.picture_number == priv->last_picture && !priv->need_second_field) {\n<168> \n<169> av_log(avctx, AV_LOG_WARNING,\n<170> \n<171> "Incorrectly guessed progressive frame. Discarding second field\n");\n<172> \n<173> /* Returning without providing a picture. */\n<174> \n<175> return RET_OK;\n<176> \n<177> }\n<178> \n<179> \n<180> \n<181> interlaced = (output->PicInfo.flags & VDEC_FLAG_INTERLACED_SRC) &&\n<182> \n<183> trust_interlaced;\n<184> \n<185> \n<186> \n<187> if (!trust_interlaced && (decoder_status.picNumFlags & ~0x40000000) == 0) {\n<188> \n<189> av_log(avctx, AV_LOG_VERBOSE,\n<190> \n<191> "Next picture number unknown. Assuming progressive frame.\n");\n<192> \n<193> }\n<194> \n<195> \n<196> \n<197> av_log(avctx, AV_LOG_VERBOSE, "Interlaced state: %d | trust_interlaced %d\n",\n<198> \n<199> interlaced, trust_interlaced);\n<200> \n<201> \n<202> \n<203> if (priv->pic.data[0] && !priv->need_second_field)\n<204> \n<205> avctx->release_buffer(avctx, &priv->pic);\n<206> \n<207> \n<208> \n<209> priv->need_second_field = interlaced && !priv->need_second_field;\n<210> \n<211> \n<212> \n<213> priv->pic.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE |\n<214> \n<215> FF_BUFFER_HINTS_REUSABLE;\n<216> \n<217> if (!priv->pic.data[0]) {\n<218> \n<219> if (avctx->get_buffer(avctx, &priv->pic) < 0) {\n<220> \n<221> av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n");\n<222> \n<223> return RET_ERROR;\n<224> \n<225> }\n<226> \n<227> }\n<228> \n<229> \n<230> \n<231> bwidth = av_image_get_linesize(avctx->pix_fmt, width, 0);\n<232> \n<233> if (priv->is_70012) {\n<234> \n<235> int pStride;\n<236> \n<237> \n<238> \n<239> if (width <= 720)\n<240> \n<241> pStride = 720;\n<242> \n<243> else if (width <= 1280)\n<244> \n<245> pStride = 1280;\n<246> \n<247> else pStride = 1920;\n<248> \n<249> sStride = av_image_get_linesize(avctx->pix_fmt, pStride, 0);\n<250> \n<251> } else {\n<252> \n<253> sStride = bwidth;\n<254> \n<255> }\n<256> \n<257> \n<258> \n<259> dStride = priv->pic.linesize[0];\n<260> \n<261> dst     = priv->pic.data[0];\n<262> \n<263> \n<264> \n<265> av_log(priv->avctx, AV_LOG_VERBOSE, "CrystalHD: Copying out frame\n");\n<266> \n<267> \n<268> \n<269> if (interlaced) {\n<270> \n<271> int dY = 0;\n<272> \n<273> int sY = 0;\n<274> \n<275> \n<276> \n<277> height /= 2;\n<278> \n<279> if (bottom_field) {\n<280> \n<281> av_log(priv->avctx, AV_LOG_VERBOSE, "Interlaced: bottom field\n");\n<282> \n<283> dY = 1;\n<284> \n<285> } else {\n<286> \n<287> av_log(priv->avctx, AV_LOG_VERBOSE, "Interlaced: top field\n");\n<288> \n<289> dY = 0;\n<290> \n<291> }\n<292> \n<293> \n<294> \n<295> for (sY = 0; sY < height; dY++, sY++) {\n<296> \n<297> memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);\n<298> \n<299> dY++;\n<300> \n<301> }\n<302> \n<303> } else {\n<304> \n<305> av_image_copy_plane(dst, dStride, src, sStride, bwidth, height);\n<306> \n<307> }\n<308> \n<309> \n<310> \n<311> priv->pic.interlaced_frame = interlaced;\n<312> \n<313> if (interlaced)\n<314> \n<315> priv->pic.top_field_first = !bottom_first;\n<316> \n<317> \n<318> \n<319> priv->pic.pkt_pts = pkt_pts;\n<320> \n<321> \n<322> \n<323> if (!priv->need_second_field) {\n<324> \n<325> *data_size       = sizeof(AVFrame);\n<326> \n<327> *(AVFrame *)data = priv->pic;\n<328> \n<329> }\n<330> \n<331> \n<332> \n<333> /*\n<334> \n<335> * Two types of PAFF content have been observed. One form causes the\n<336> \n<337> * hardware to return a field pair and the other individual fields,\n<338> \n<339> * even though the input is always individual fields. We must skip\n<340> \n<341> * copying on the next decode() call to maintain pipeline length in\n<342> \n<343> * the first case.\n<344> \n<345> */\n<346> \n<347> if (!interlaced && (output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC) &&\n<348> \n<349> (pic_type == PICT_TOP_FIELD || pic_type == PICT_BOTTOM_FIELD)) {\n<350> \n<351> av_log(priv->avctx, AV_LOG_VERBOSE, "Fieldpair from two packets.\n");\n<352> \n<353> return RET_SKIP_NEXT_COPY;\n<354> \n<355> }\n<356> \n<357> \n<358> \n<359> /*\n<360> \n<361> * Testing has shown that in all cases where we don't want to return the\n<362> \n<363> * full frame immediately, VDEC_FLAG_UNKNOWN_SRC is set.\n<364> \n<365> */\n<366> \n<367> return priv->need_second_field &&\n<368> \n<369> !(output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC) ?\n<370> \n<371> RET_COPY_NEXT_FIELD : RET_OK;\n<372> \n<373> }\n<374> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int pefromupx ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 , uint32_t * magic , uint32_t dend ) {\n<2> char * imports , * sections = NULL , * pehdr = NULL , * newbuf ;\n<3> unsigned int sectcnt = 0 , upd = 1 ;\n<4> uint32_t realstuffsz = 0 , valign = 0 ;\n<5> uint32_t foffset = 0xd0 + 0xf8 ;\n<6> if ( ( dst == NULL ) || ( src == NULL ) ) return 0 ;\n<7> while ( ( valign = magic [ sectcnt ++ ] ) ) {\n<8> if ( ep - upx1 + valign <= ssize - 5 && src [ ep - upx1 + valign - 2 ] == '\x8d' && src [ ep - upx1 + valign - 1 ] == '\xbe' ) break ;\n<9> }\n<10> if ( ! valign && ep - upx1 + 0x80 < ssize - 8 ) {\n<11> const char * pt = & src [ ep - upx1 + 0x80 ] ;\n<12> cli_dbgmsg ( "UPX: bad magic - scanning for imports\n" ) ;\n<13> while ( ( pt = cli_memstr ( pt , ssize - ( pt - src ) - 8 , "\x8d\xbe" , 2 ) ) ) {\n<14> if ( pt [ 6 ] == '\x8b' && pt [ 7 ] == '\x07' ) {\n<15> valign = pt - src + 2 - ep + upx1 ;\n<16> break ;\n<17> }\n<18> pt ++ ;\n<19> }\n<20> }\n<21> if ( valign && CLI_ISCONTAINED ( src , ssize , src + ep - upx1 + valign , 4 ) ) {\n<22> imports = dst + cli_readint32 ( src + ep - upx1 + valign ) ;\n<23> realstuffsz = imports - dst ;\n<24> if ( realstuffsz >= * dsize ) {\n<25> cli_dbgmsg ( "UPX: wrong realstuff size\n" ) ;\n<26> }\n<27> else {\n<28> pehdr = imports ;\n<29> while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 8 ) && cli_readint32 ( pehdr ) ) {\n<30> pehdr += 8 ;\n<31> while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) {\n<32> pehdr ++ ;\n<33> while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) pehdr ++ ;\n<34> pehdr ++ ;\n<35> }\n<36> pehdr ++ ;\n<37> }\n<38> pehdr += 4 ;\n<39> if ( ! ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) pehdr = NULL ;\n<40> }\n<41> }\n<42> if ( ! pehdr && dend > 0xf8 + 0x28 ) {\n<43> cli_dbgmsg ( "UPX: no luck - scanning for PE\n" ) ;\n<44> pehdr = & dst [ dend - 0xf8 - 0x28 ] ;\n<45> while ( pehdr > dst ) {\n<46> if ( ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) break ;\n<47> pehdr -- ;\n<48> }\n<49> if ( ! ( realstuffsz = pehdr - dst ) ) pehdr = NULL ;\n<50> }\n<51> if ( ! pehdr ) {\n<52> uint32_t rebsz = PESALIGN ( dend , 0x1000 ) ;\n<53> cli_dbgmsg ( "UPX: no luck - brutally crafing a reasonable PE\n" ) ;\n<54> if ( ! ( newbuf = ( char * ) cli_calloc ( rebsz + 0x200 , sizeof ( char ) ) ) ) {\n<55> cli_dbgmsg ( "UPX: malloc failed - giving up rebuild\n" ) ;\n<56> return 0 ;\n<57> }\n<58> memcpy ( newbuf , HEADERS , 0xd0 ) ;\n<59> memcpy ( newbuf + 0xd0 , FAKEPE , 0x120 ) ;\n<60> memcpy ( newbuf + 0x200 , dst , dend ) ;\n<61> memcpy ( dst , newbuf , dend + 0x200 ) ;\n<62> free ( newbuf ) ;\n<63> cli_writeint32 ( dst + 0xd0 + 0x50 , rebsz + 0x1000 ) ;\n<64> cli_writeint32 ( dst + 0xd0 + 0x100 , rebsz ) ;\n<65> cli_writeint32 ( dst + 0xd0 + 0x108 , rebsz ) ;\n<66> * dsize = rebsz + 0x200 ;\n<67> cli_dbgmsg ( "UPX: PE structure added to uncompressed data\n" ) ;\n<68> return 1 ;\n<69> }\n<70> if ( ! sections ) sectcnt = 0 ;\n<71> foffset = PESALIGN ( foffset + 0x28 * sectcnt , valign ) ;\n<72> for ( upd = 0 ;\n<73> upd < sectcnt ;\n<74> upd ++ ) {\n<75> uint32_t vsize = PESALIGN ( ( uint32_t ) cli_readint32 ( sections + 8 ) , valign ) ;\n<76> uint32_t urva = PEALIGN ( ( uint32_t ) cli_readint32 ( sections + 12 ) , valign ) ;\n<77> if ( ! CLI_ISCONTAINED ( upx0 , realstuffsz , urva , vsize ) ) {\n<78> cli_dbgmsg ( "UPX: Sect %d out of bounds - giving up rebuild\n" , upd ) ;\n<79> return 0 ;\n<80> }\n<81> cli_writeint32 ( sections + 8 , vsize ) ;\n<82> cli_writeint32 ( sections + 12 , urva ) ;\n<83> cli_writeint32 ( sections + 16 , vsize ) ;\n<84> cli_writeint32 ( sections + 20 , foffset ) ;\n<85> if ( foffset + vsize < foffset ) {\n<86> return 0 ;\n<87> }\n<88> foffset += vsize ;\n<89> sections += 0x28 ;\n<90> }\n<91> cli_writeint32 ( pehdr + 8 , 0x4d414c43 ) ;\n<92> cli_writeint32 ( pehdr + 0x3c , valign ) ;\n<93> if ( ! ( newbuf = ( char * ) cli_calloc ( foffset , sizeof ( char ) ) ) ) {\n<94> cli_dbgmsg ( "UPX: malloc failed - giving up rebuild\n" ) ;\n<95> return 0 ;\n<96> }\n<97> memcpy ( newbuf , HEADERS , 0xd0 ) ;\n<98> memcpy ( newbuf + 0xd0 , pehdr , 0xf8 + 0x28 * sectcnt ) ;\n<99> sections = pehdr + 0xf8 ;\n<100> for ( upd = 0 ;\n<101> upd < sectcnt ;\n<102> upd ++ ) {\n<103> uint32_t offset1 , offset2 , offset3 ;\n<104> offset1 = ( uint32_t ) cli_readint32 ( sections + 20 ) ;\n<105> offset2 = ( uint32_t ) cli_readint32 ( sections + 16 ) ;\n<106> if ( offset1 > foffset || offset2 > foffset || offset1 + offset2 > foffset ) {\n<107> free ( newbuf ) ;\n<108> return 1 ;\n<109> }\n<110> offset3 = ( uint32_t ) cli_readint32 ( sections + 12 ) ;\n<111> if ( offset3 - upx0 > * dsize ) {\n<112> free ( newbuf ) ;\n<113> return 1 ;\n<114> }\n<115> memcpy ( newbuf + offset1 , dst + offset3 - upx0 , offset2 ) ;\n<116> sections += 0x28 ;\n<117> }\n<118> if ( foffset > * dsize + 8192 ) {\n<119> cli_dbgmsg ( "UPX: wrong raw size - giving up rebuild\n" ) ;\n<120> free ( newbuf ) ;\n<121> return 0 ;\n<122> }\n<123> memcpy ( dst , newbuf , foffset ) ;\n<124> * dsize = foffset ;\n<125> free ( newbuf ) ;\n<126> cli_dbgmsg ( "UPX: PE structure rebuilt from compressed file\n" ) ;\n<127> return 1 ;\n<128> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mjpeg_decode_init(AVCodecContext *avctx)\n<2> \n<3> {\n<4> \n<5> MJpegDecodeContext *s = avctx->priv_data;\n<6> \n<7> MpegEncContext s2;\n<8> \n<9> \n<10> \n<11> s->avctx = avctx;\n<12> \n<13> \n<14> \n<15> /* ugly way to get the idct & scantable */\n<16> \n<17> memset(&s2, 0, sizeof(MpegEncContext));\n<18> \n<19> s2.flags= avctx->flags;\n<20> \n<21> s2.avctx= avctx;\n<22> \n<23> //    s2->out_format = FMT_MJPEG;\n<24> \n<25> s2.width = 8;\n<26> \n<27> s2.height = 8;\n<28> \n<29> if (MPV_common_init(&s2) < 0)\n<30> \n<31> return -1;\n<32> \n<33> s->scantable= s2.intra_scantable;\n<34> \n<35> s->idct_put= s2.idct_put;\n<36> \n<37> MPV_common_end(&s2);\n<38> \n<39> \n<40> \n<41> s->mpeg_enc_ctx_allocated = 0;\n<42> \n<43> s->buffer_size = 102400; /* smaller buffer should be enough,\n<44> \n<45> but photojpg files could ahive bigger sizes */\n<46> \n<47> s->buffer = av_malloc(s->buffer_size);\n<48> \n<49> if (!s->buffer)\n<50> \n<51> return -1;\n<52> \n<53> s->start_code = -1;\n<54> \n<55> s->first_picture = 1;\n<56> \n<57> s->org_width = avctx->width;\n<58> \n<59> s->org_height = avctx->height;\n<60> \n<61> \n<62> \n<63> build_vlc(&s->vlcs[0][0], bits_dc_luminance, val_dc_luminance, 12);\n<64> \n<65> build_vlc(&s->vlcs[0][1], bits_dc_chrominance, val_dc_chrominance, 12);\n<66> \n<67> build_vlc(&s->vlcs[1][0], bits_ac_luminance, val_ac_luminance, 251);\n<68> \n<69> build_vlc(&s->vlcs[1][1], bits_ac_chrominance, val_ac_chrominance, 251);\n<70> \n<71> \n<72> \n<73> if (avctx->flags & CODEC_FLAG_EXTERN_HUFF)\n<74> \n<75> {\n<76> \n<77> printf("mjpeg: using external huffman table\n");\n<78> \n<79> init_get_bits(&s->gb, avctx->extradata, avctx->extradata_size);\n<80> \n<81> mjpeg_decode_dht(s);\n<82> \n<83> /* should check for error - but dunno */\n<84> \n<85> }\n<86> \n<87> \n<88> \n<89> return 0;\n<90> \n<91> }\n<92> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int multiwrite_f(BlockBackend *blk, int argc, char **argv)\n<2> \n<3> {\n<4> \n<5> struct timeval t1, t2;\n<6> \n<7> int Cflag = 0, qflag = 0;\n<8> \n<9> int c, cnt;\n<10> \n<11> char **buf;\n<12> \n<13> int64_t offset, first_offset = 0;\n<14> \n<15> /* Some compilers get confused and warn if this is not initialized.  */\n<16> \n<17> int total = 0;\n<18> \n<19> int nr_iov;\n<20> \n<21> int nr_reqs;\n<22> \n<23> int pattern = 0xcd;\n<24> \n<25> QEMUIOVector *qiovs;\n<26> \n<27> int i;\n<28> \n<29> BlockRequest *reqs;\n<30> \n<31> \n<32> \n<33> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<34> \n<35> switch (c) {\n<36> \n<37> case 'C':\n<38> \n<39> Cflag = 1;\n<40> \n<41> break;\n<42> \n<43> case 'q':\n<44> \n<45> qflag = 1;\n<46> \n<47> break;\n<48> \n<49> case 'P':\n<50> \n<51> pattern = parse_pattern(optarg);\n<52> \n<53> if (pattern < 0) {\n<54> \n<55> return 0;\n<56> \n<57> }\n<58> \n<59> break;\n<60> \n<61> default:\n<62> \n<63> return qemuio_command_usage(&writev_cmd);\n<64> \n<65> }\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> if (optind > argc - 2) {\n<72> \n<73> return qemuio_command_usage(&writev_cmd);\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> nr_reqs = 1;\n<80> \n<81> for (i = optind; i < argc; i++) {\n<82> \n<83> if (!strcmp(argv[i], ";")) {\n<84> \n<85> nr_reqs++;\n<86> \n<87> }\n<88> \n<89> }\n<90> \n<91> \n<92> \n<93> reqs = g_new0(BlockRequest, nr_reqs);\n<94> \n<95> buf = g_new0(char *, nr_reqs);\n<96> \n<97> qiovs = g_new(QEMUIOVector, nr_reqs);\n<98> \n<99> \n<100> \n<101> for (i = 0; i < nr_reqs && optind < argc; i++) {\n<102> \n<103> int j;\n<104> \n<105> \n<106> \n<107> /* Read the offset of the request */\n<108> \n<109> offset = cvtnum(argv[optind]);\n<110> \n<111> if (offset < 0) {\n<112> \n<113> printf("non-numeric offset argument -- %s\n", argv[optind]);\n<114> \n<115> goto out;\n<116> \n<117> }\n<118> \n<119> optind++;\n<120> \n<121> \n<122> \n<123> if (offset & 0x1ff) {\n<124> \n<125> printf("offset %lld is not sector aligned\n",\n<126> \n<127> (long long)offset);\n<128> \n<129> goto out;\n<130> \n<131> }\n<132> \n<133> \n<134> \n<135> if (i == 0) {\n<136> \n<137> first_offset = offset;\n<138> \n<139> }\n<140> \n<141> \n<142> \n<143> /* Read lengths for qiov entries */\n<144> \n<145> for (j = optind; j < argc; j++) {\n<146> \n<147> if (!strcmp(argv[j], ";")) {\n<148> \n<149> break;\n<150> \n<151> }\n<152> \n<153> }\n<154> \n<155> \n<156> \n<157> nr_iov = j - optind;\n<158> \n<159> \n<160> \n<161> /* Build request */\n<162> \n<163> buf[i] = create_iovec(blk, &qiovs[i], &argv[optind], nr_iov, pattern);\n<164> \n<165> if (buf[i] == NULL) {\n<166> \n<167> goto out;\n<168> \n<169> }\n<170> \n<171> \n<172> \n<173> reqs[i].qiov = &qiovs[i];\n<174> \n<175> reqs[i].sector = offset >> 9;\n<176> \n<177> reqs[i].nb_sectors = reqs[i].qiov->size >> 9;\n<178> \n<179> \n<180> \n<181> optind = j + 1;\n<182> \n<183> \n<184> \n<185> pattern++;\n<186> \n<187> }\n<188> \n<189> \n<190> \n<191> /* If there were empty requests at the end, ignore them */\n<192> \n<193> nr_reqs = i;\n<194> \n<195> \n<196> \n<197> gettimeofday(&t1, NULL);\n<198> \n<199> cnt = do_aio_multiwrite(blk, reqs, nr_reqs, &total);\n<200> \n<201> gettimeofday(&t2, NULL);\n<202> \n<203> \n<204> \n<205> if (cnt < 0) {\n<206> \n<207> printf("aio_multiwrite failed: %s\n", strerror(-cnt));\n<208> \n<209> goto out;\n<210> \n<211> }\n<212> \n<213> \n<214> \n<215> if (qflag) {\n<216> \n<217> goto out;\n<218> \n<219> }\n<220> \n<221> \n<222> \n<223> /* Finally, report back -- -C gives a parsable format */\n<224> \n<225> t2 = tsub(t2, t1);\n<226> \n<227> print_report("wrote", &t2, first_offset, total, total, cnt, Cflag);\n<228> \n<229> out:\n<230> \n<231> for (i = 0; i < nr_reqs; i++) {\n<232> \n<233> qemu_io_free(buf[i]);\n<234> \n<235> if (reqs[i].qiov != NULL) {\n<236> \n<237> qemu_iovec_destroy(&qiovs[i]);\n<238> \n<239> }\n<240> \n<241> }\n<242> \n<243> g_free(buf);\n<244> \n<245> g_free(reqs);\n<246> \n<247> g_free(qiovs);\n<248> \n<249> return 0;\n<250> \n<251> }\n<252> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n<2> char myhash [ 16 ] ;\n<3> if ( len < 16 ) return ;\n<4> if ( userid < 0 || userid >= created_users ) return ;\n<5> if ( ! users [ userid ] . active || users [ userid ] . disabled ) return ;\n<6> if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;\n<7> if ( debug >= 1 ) {\n<8> fprintf ( stderr , "IN login raw, len %d, from user %d\n" , len , userid ) ;\n<9> }\n<10> login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;\n<11> if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n<12> struct sockaddr_in * tempin ;\n<13> users [ userid ] . last_pkt = time ( NULL ) ;\n<14> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<15> tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n<16> memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n<17> user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n<18> login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;\n<19> send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;\n<20> }\n<21> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int oggvorbis_encode_frame(AVCodecContext *avctx, unsigned char *packets,\n<2> \n<3> int buf_size, void *data)\n<4> \n<5> {\n<6> \n<7> OggVorbisContext *s = avctx->priv_data;\n<8> \n<9> ogg_packet op;\n<10> \n<11> float *audio = data;\n<12> \n<13> int pkt_size;\n<14> \n<15> \n<16> \n<17> /* send samples to libvorbis */\n<18> \n<19> if (data) {\n<20> \n<21> const int samples = avctx->frame_size;\n<22> \n<23> float **buffer;\n<24> \n<25> int c, channels = s->vi.channels;\n<26> \n<27> \n<28> \n<29> buffer = vorbis_analysis_buffer(&s->vd, samples);\n<30> \n<31> for (c = 0; c < channels; c++) {\n<32> \n<33> int i;\n<34> \n<35> int co = (channels > 8) ? c :\n<36> \n<37> ff_vorbis_encoding_channel_layout_offsets[channels - 1][c];\n<38> \n<39> for (i = 0; i < samples; i++)\n<40> \n<41> buffer[c][i] = audio[i * channels + co];\n<42> \n<43> }\n<44> \n<45> vorbis_analysis_wrote(&s->vd, samples);\n<46> \n<47> } else {\n<48> \n<49> if (!s->eof)\n<50> \n<51> vorbis_analysis_wrote(&s->vd, 0);\n<52> \n<53> s->eof = 1;\n<54> \n<55> }\n<56> \n<57> \n<58> \n<59> /* retrieve available packets from libvorbis */\n<60> \n<61> while (vorbis_analysis_blockout(&s->vd, &s->vb) == 1) {\n<62> \n<63> vorbis_analysis(&s->vb, NULL);\n<64> \n<65> vorbis_bitrate_addblock(&s->vb);\n<66> \n<67> \n<68> \n<69> /* add any available packets to the output packet buffer */\n<70> \n<71> while (vorbis_bitrate_flushpacket(&s->vd, &op)) {\n<72> \n<73> /* i'd love to say the following line is a hack, but sadly it's\n<74> \n<75> * not, apparently the end of stream decision is in libogg. */\n<76> \n<77> if (op.bytes == 1 && op.e_o_s)\n<78> \n<79> continue;\n<80> \n<81> if (s->buffer_index + sizeof(ogg_packet) + op.bytes > BUFFER_SIZE) {\n<82> \n<83> av_log(avctx, AV_LOG_ERROR, "libvorbis: buffer overflow.");\n<84> \n<85> return -1;\n<86> \n<87> }\n<88> \n<89> memcpy(s->buffer + s->buffer_index, &op, sizeof(ogg_packet));\n<90> \n<91> s->buffer_index += sizeof(ogg_packet);\n<92> \n<93> memcpy(s->buffer + s->buffer_index, op.packet, op.bytes);\n<94> \n<95> s->buffer_index += op.bytes;\n<96> \n<97> }\n<98> \n<99> }\n<100> \n<101> \n<102> \n<103> /* output then next packet from the output buffer, if available */\n<104> \n<105> pkt_size = 0;\n<106> \n<107> if (s->buffer_index) {\n<108> \n<109> ogg_packet *op2 = (ogg_packet *)s->buffer;\n<110> \n<111> op2->packet     = s->buffer + sizeof(ogg_packet);\n<112> \n<113> \n<114> \n<115> pkt_size = op2->bytes;\n<116> \n<117> // FIXME: we should use the user-supplied pts and duration\n<118> \n<119> avctx->coded_frame->pts = ff_samples_to_time_base(avctx,\n<120> \n<121> op2->granulepos);\n<122> \n<123> if (pkt_size > buf_size) {\n<124> \n<125> av_log(avctx, AV_LOG_ERROR, "libvorbis: buffer overflow.");\n<126> \n<127> return -1;\n<128> \n<129> }\n<130> \n<131> \n<132> \n<133> memcpy(packets, op2->packet, pkt_size);\n<134> \n<135> s->buffer_index -= pkt_size + sizeof(ogg_packet);\n<136> \n<137> memmove(s->buffer, s->buffer + pkt_size + sizeof(ogg_packet),\n<138> \n<139> s->buffer_index);\n<140> \n<141> }\n<142> \n<143> \n<144> \n<145> return pkt_size;\n<146> \n<147> }\n<148> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int display_end_segment(AVCodecContext *avctx, void *data,\n<2> \n<3> const uint8_t *buf, int buf_size)\n<4> \n<5> {\n<6> \n<7> AVSubtitle    *sub = data;\n<8> \n<9> PGSSubContext *ctx = avctx->priv_data;\n<10> \n<11> \n<12> \n<13> /*\n<14> \n<15> *      The end display time is a timeout value and is only reached\n<16> \n<17> *      if the next subtitle is later then timeout or subtitle has\n<18> \n<19> *      not been cleared by a subsequent empty display command.\n<20> \n<21> */\n<22> \n<23> \n<24> \n<25> memset(sub, 0, sizeof(*sub));\n<26> \n<27> // Blank if last object_number was 0.\n<28> \n<29> // Note that this may be wrong for more complex subtitles.\n<30> \n<31> if (!ctx->presentation.object_number)\n<32> \n<33> return 1;\n<34> \n<35> sub->start_display_time = 0;\n<36> \n<37> sub->end_display_time   = 20000;\n<38> \n<39> sub->format             = 0;\n<40> \n<41> \n<42> \n<43> sub->rects     = av_mallocz(sizeof(*sub->rects));\n<44> \n<45> sub->rects[0]  = av_mallocz(sizeof(*sub->rects[0]));\n<46> \n<47> sub->num_rects = 1;\n<48> \n<49> \n<50> \n<51> sub->rects[0]->x    = ctx->presentation.x;\n<52> \n<53> sub->rects[0]->y    = ctx->presentation.y;\n<54> \n<55> sub->rects[0]->w    = ctx->picture.w;\n<56> \n<57> sub->rects[0]->h    = ctx->picture.h;\n<58> \n<59> sub->rects[0]->type = SUBTITLE_BITMAP;\n<60> \n<61> \n<62> \n<63> /* Process bitmap */\n<64> \n<65> sub->rects[0]->pict.linesize[0] = ctx->picture.w;\n<66> \n<67> \n<68> \n<69> if (ctx->picture.rle) {\n<70> \n<71> if (ctx->picture.rle_remaining_len)\n<72> \n<73> av_log(avctx, AV_LOG_ERROR, "RLE data length %u is %u bytes shorter than expected\n",\n<74> \n<75> ctx->picture.rle_data_len, ctx->picture.rle_remaining_len);\n<76> \n<77> if(decode_rle(avctx, sub, ctx->picture.rle, ctx->picture.rle_data_len) < 0)\n<78> \n<79> return 0;\n<80> \n<81> }\n<82> \n<83> /* Allocate memory for colors */\n<84> \n<85> sub->rects[0]->nb_colors    = 256;\n<86> \n<87> sub->rects[0]->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n<88> \n<89> \n<90> \n<91> memcpy(sub->rects[0]->pict.data[1], ctx->clut, sub->rects[0]->nb_colors * sizeof(uint32_t));\n<92> \n<93> \n<94> \n<95> return 1;\n<96> \n<97> }\n<98> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static const char *ass_split_section(ASSSplitContext *ctx, const char *buf)\n<2> \n<3> {\n<4> \n<5> const ASSSection *section = &ass_sections[ctx->current_section];\n<6> \n<7> int *number = &ctx->field_number[ctx->current_section];\n<8> \n<9> int *order = ctx->field_order[ctx->current_section];\n<10> \n<11> int *tmp, i, len;\n<12> \n<13> \n<14> \n<15> while (buf && *buf) {\n<16> \n<17> if (buf[0] == '[') {\n<18> \n<19> ctx->current_section = -1;\n<20> \n<21> break;\n<22> \n<23> }\n<24> \n<25> if (buf[0] == ';' || (buf[0] == '!' && buf[1] == ':')) {\n<26> \n<27> /* skip comments */\n<28> \n<29> } else if (section->format_header && !order) {\n<30> \n<31> len = strlen(section->format_header);\n<32> \n<33> if (strncmp(buf, section->format_header, len) || buf[len] != ':')\n<34> \n<35> return NULL;\n<36> \n<37> buf += len + 1;\n<38> \n<39> while (!is_eol(*buf)) {\n<40> \n<41> buf = skip_space(buf);\n<42> \n<43> len = strcspn(buf, ", \r\n");\n<44> \n<45> if (!(tmp = av_realloc(order, (*number + 1) * sizeof(*order))))\n<46> \n<47> return NULL;\n<48> \n<49> order = tmp;\n<50> \n<51> order[*number] = -1;\n<52> \n<53> for (i=0; section->fields[i].name; i++)\n<54> \n<55> if (!strncmp(buf, section->fields[i].name, len)) {\n<56> \n<57> order[*number] = i;\n<58> \n<59> break;\n<60> \n<61> }\n<62> \n<63> (*number)++;\n<64> \n<65> buf = skip_space(buf + len + (buf[len] == ','));\n<66> \n<67> }\n<68> \n<69> ctx->field_order[ctx->current_section] = order;\n<70> \n<71> } else if (section->fields_header) {\n<72> \n<73> len = strlen(section->fields_header);\n<74> \n<75> if (!strncmp(buf, section->fields_header, len) && buf[len] == ':') {\n<76> \n<77> uint8_t *ptr, *struct_ptr = realloc_section_array(ctx);\n<78> \n<79> if (!struct_ptr)  return NULL;\n<80> \n<81> buf += len + 1;\n<82> \n<83> for (i=0; !is_eol(*buf) && i < *number; i++) {\n<84> \n<85> int last = i == *number - 1;\n<86> \n<87> buf = skip_space(buf);\n<88> \n<89> len = strcspn(buf, last ? "\r\n" : ",\r\n");\n<90> \n<91> if (order[i] >= 0) {\n<92> \n<93> ASSFieldType type = section->fields[order[i]].type;\n<94> \n<95> ptr = struct_ptr + section->fields[order[i]].offset;\n<96> \n<97> convert_func[type](ptr, buf, len);\n<98> \n<99> }\n<100> \n<101> buf = skip_space(buf + len + !last);\n<102> \n<103> }\n<104> \n<105> }\n<106> \n<107> } else {\n<108> \n<109> len = strcspn(buf, ":\r\n");\n<110> \n<111> if (buf[len] == ':') {\n<112> \n<113> for (i=0; section->fields[i].name; i++)\n<114> \n<115> if (!strncmp(buf, section->fields[i].name, len)) {\n<116> \n<117> ASSFieldType type = section->fields[i].type;\n<118> \n<119> uint8_t *ptr = (uint8_t *)&ctx->ass + section->offset;\n<120> \n<121> ptr += section->fields[i].offset;\n<122> \n<123> buf = skip_space(buf + len + 1);\n<124> \n<125> convert_func[type](ptr, buf, strcspn(buf, "\r\n"));\n<126> \n<127> break;\n<128> \n<129> }\n<130> \n<131> }\n<132> \n<133> }\n<134> \n<135> buf += strcspn(buf, "\n");\n<136> \n<137> buf += !!*buf;\n<138> \n<139> }\n<140> \n<141> return buf;\n<142> \n<143> }\n<144> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void mainstone_common_init(ram_addr_t ram_size,\n<2> \n<3> const char *kernel_filename,\n<4> \n<5> const char *kernel_cmdline, const char *initrd_filename,\n<6> \n<7> const char *cpu_model, enum mainstone_model_e model, int arm_id)\n<8> \n<9> {\n<10> \n<11> uint32_t sector_len = 256 * 1024;\n<12> \n<13> target_phys_addr_t mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n<14> \n<15> PXA2xxState *cpu;\n<16> \n<17> DeviceState *mst_irq;\n<18> \n<19> DriveInfo *dinfo;\n<20> \n<21> int i;\n<22> \n<23> int be;\n<24> \n<25> \n<26> \n<27> if (!cpu_model)\n<28> \n<29> cpu_model = "pxa270-c5";\n<30> \n<31> \n<32> \n<33> /* Setup CPU & memory */\n<34> \n<35> cpu = pxa270_init(mainstone_binfo.ram_size, cpu_model);\n<36> \n<37> cpu_register_physical_memory(0, MAINSTONE_ROM,\n<38> \n<39> qemu_ram_alloc(NULL, "mainstone.rom",\n<40> \n<41> MAINSTONE_ROM) | IO_MEM_ROM);\n<42> \n<43> \n<44> \n<45> #ifdef TARGET_WORDS_BIGENDIAN\n<46> \n<47> be = 1;\n<48> \n<49> #else\n<50> \n<51> be = 0;\n<52> \n<53> #endif\n<54> \n<55> /* There are two 32MiB flash devices on the board */\n<56> \n<57> for (i = 0; i < 2; i ++) {\n<58> \n<59> dinfo = drive_get(IF_PFLASH, 0, i);\n<60> \n<61> if (!dinfo) {\n<62> \n<63> fprintf(stderr, "Two flash images must be given with the "\n<64> \n<65> "'pflash' parameter\n");\n<66> \n<67> exit(1);\n<68> \n<69> }\n<70> \n<71> \n<72> \n<73> if (!pflash_cfi01_register(mainstone_flash_base[i],\n<74> \n<75> qemu_ram_alloc(NULL, i ? "mainstone.flash1" :\n<76> \n<77> "mainstone.flash0",\n<78> \n<79> MAINSTONE_FLASH),\n<80> \n<81> dinfo->bdrv, sector_len,\n<82> \n<83> MAINSTONE_FLASH / sector_len, 4, 0, 0, 0, 0,\n<84> \n<85> be)) {\n<86> \n<87> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<88> \n<89> exit(1);\n<90> \n<91> }\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> mst_irq = sysbus_create_simple("mainstone-fpga", MST_FPGA_PHYS,\n<98> \n<99> cpu->pic[PXA2XX_PIC_GPIO_0]);\n<100> \n<101> \n<102> \n<103> /* setup keypad */\n<104> \n<105> printf("map addr %p\n", &map);\n<106> \n<107> pxa27x_register_keypad(cpu->kp, map, 0xe0);\n<108> \n<109> \n<110> \n<111> /* MMC/SD host */\n<112> \n<113> pxa2xx_mmci_handlers(cpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n<114> \n<115> \n<116> \n<117> smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n<118> \n<119> qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n<120> \n<121> \n<122> \n<123> mainstone_binfo.kernel_filename = kernel_filename;\n<124> \n<125> mainstone_binfo.kernel_cmdline = kernel_cmdline;\n<126> \n<127> mainstone_binfo.initrd_filename = initrd_filename;\n<128> \n<129> mainstone_binfo.board_id = arm_id;\n<130> \n<131> arm_load_kernel(cpu->env, &mainstone_binfo);\n<132> \n<133> }\n<134> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int alloc_refcount_block(BlockDriverState *bs,\n<2> \n<3> int64_t cluster_index, void **refcount_block)\n<4> \n<5> {\n<6> \n<7> BDRVQcowState *s = bs->opaque;\n<8> \n<9> unsigned int refcount_table_index;\n<10> \n<11> int ret;\n<12> \n<13> \n<14> \n<15> BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n<16> \n<17> \n<18> \n<19> /* Find the refcount block for the given cluster */\n<20> \n<21> refcount_table_index = cluster_index >> s->refcount_block_bits;\n<22> \n<23> \n<24> \n<25> if (refcount_table_index < s->refcount_table_size) {\n<26> \n<27> \n<28> \n<29> uint64_t refcount_block_offset =\n<30> \n<31> s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n<32> \n<33> \n<34> \n<35> /* If it's already there, we're done */\n<36> \n<37> if (refcount_block_offset) {\n<38> \n<39> if (offset_into_cluster(s, refcount_block_offset)) {\n<40> \n<41> qcow2_signal_corruption(bs, true, -1, -1, "Refblock offset %#"\n<42> \n<43> PRIx64 " unaligned (reftable index: "\n<44> \n<45> "%#x)", refcount_block_offset,\n<46> \n<47> refcount_table_index);\n<48> \n<49> return -EIO;\n<50> \n<51> }\n<52> \n<53> \n<54> \n<55> return load_refcount_block(bs, refcount_block_offset,\n<56> \n<57> refcount_block);\n<58> \n<59> }\n<60> \n<61> }\n<62> \n<63> \n<64> \n<65> /*\n<66> \n<67> * If we came here, we need to allocate something. Something is at least\n<68> \n<69> * a cluster for the new refcount block. It may also include a new refcount\n<70> \n<71> * table if the old refcount table is too small.\n<72> \n<73> *\n<74> \n<75> * Note that allocating clusters here needs some special care:\n<76> \n<77> *\n<78> \n<79> * - We can't use the normal qcow2_alloc_clusters(), it would try to\n<80> \n<81> *   increase the refcount and very likely we would end up with an endless\n<82> \n<83> *   recursion. Instead we must place the refcount blocks in a way that\n<84> \n<85> *   they can describe them themselves.\n<86> \n<87> *\n<88> \n<89> * - We need to consider that at this point we are inside update_refcounts\n<90> \n<91> *   and potentially doing an initial refcount increase. This means that\n<92> \n<93> *   some clusters have already been allocated by the caller, but their\n<94> \n<95> *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n<96> \n<97> *   need to return -EAGAIN to signal the caller that it needs to restart\n<98> \n<99> *   the search for free clusters.\n<100> \n<101> *\n<102> \n<103> * - alloc_clusters_noref and qcow2_free_clusters may load a different\n<104> \n<105> *   refcount block into the cache\n<106> \n<107> */\n<108> \n<109> \n<110> \n<111> *refcount_block = NULL;\n<112> \n<113> \n<114> \n<115> /* We write to the refcount table, so we might depend on L2 tables */\n<116> \n<117> ret = qcow2_cache_flush(bs, s->l2_table_cache);\n<118> \n<119> if (ret < 0) {\n<120> \n<121> return ret;\n<122> \n<123> }\n<124> \n<125> \n<126> \n<127> /* Allocate the refcount block itself and mark it as used */\n<128> \n<129> int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n<130> \n<131> if (new_block < 0) {\n<132> \n<133> return new_block;\n<134> \n<135> }\n<136> \n<137> \n<138> \n<139> #ifdef DEBUG_ALLOC2\n<140> \n<141> fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64\n<142> \n<143> " at %" PRIx64 "\n",\n<144> \n<145> refcount_table_index, cluster_index << s->cluster_bits, new_block);\n<146> \n<147> #endif\n<148> \n<149> \n<150> \n<151> if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n<152> \n<153> /* Zero the new refcount block before updating it */\n<154> \n<155> ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n<156> \n<157> refcount_block);\n<158> \n<159> if (ret < 0) {\n<160> \n<161> goto fail_block;\n<162> \n<163> }\n<164> \n<165> \n<166> \n<167> memset(*refcount_block, 0, s->cluster_size);\n<168> \n<169> \n<170> \n<171> /* The block describes itself, need to update the cache */\n<172> \n<173> int block_index = (new_block >> s->cluster_bits) &\n<174> \n<175> (s->refcount_block_size - 1);\n<176> \n<177> s->set_refcount(*refcount_block, block_index, 1);\n<178> \n<179> } else {\n<180> \n<181> /* Described somewhere else. This can recurse at most twice before we\n<182> \n<183> * arrive at a block that describes itself. */\n<184> \n<185> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n<186> \n<187> QCOW2_DISCARD_NEVER);\n<188> \n<189> if (ret < 0) {\n<190> \n<191> goto fail_block;\n<192> \n<193> }\n<194> \n<195> \n<196> \n<197> ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n<198> \n<199> if (ret < 0) {\n<200> \n<201> goto fail_block;\n<202> \n<203> }\n<204> \n<205> \n<206> \n<207> /* Initialize the new refcount block only after updating its refcount,\n<208> \n<209> * update_refcount uses the refcount cache itself */\n<210> \n<211> ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n<212> \n<213> refcount_block);\n<214> \n<215> if (ret < 0) {\n<216> \n<217> goto fail_block;\n<218> \n<219> }\n<220> \n<221> \n<222> \n<223> memset(*refcount_block, 0, s->cluster_size);\n<224> \n<225> }\n<226> \n<227> \n<228> \n<229> /* Now the new refcount block needs to be written to disk */\n<230> \n<231> BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n<232> \n<233> qcow2_cache_entry_mark_dirty(bs, s->refcount_block_cache, *refcount_block);\n<234> \n<235> ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n<236> \n<237> if (ret < 0) {\n<238> \n<239> goto fail_block;\n<240> \n<241> }\n<242> \n<243> \n<244> \n<245> /* If the refcount table is big enough, just hook the block up there */\n<246> \n<247> if (refcount_table_index < s->refcount_table_size) {\n<248> \n<249> uint64_t data64 = cpu_to_be64(new_block);\n<250> \n<251> BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n<252> \n<253> ret = bdrv_pwrite_sync(bs->file,\n<254> \n<255> s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n<256> \n<257> &data64, sizeof(data64));\n<258> \n<259> if (ret < 0) {\n<260> \n<261> goto fail_block;\n<262> \n<263> }\n<264> \n<265> \n<266> \n<267> s->refcount_table[refcount_table_index] = new_block;\n<268> \n<269> \n<270> \n<271> /* The new refcount block may be where the caller intended to put its\n<272> \n<273> * data, so let it restart the search. */\n<274> \n<275> return -EAGAIN;\n<276> \n<277> }\n<278> \n<279> \n<280> \n<281> ret = qcow2_cache_put(bs, s->refcount_block_cache, refcount_block);\n<282> \n<283> if (ret < 0) {\n<284> \n<285> goto fail_block;\n<286> \n<287> }\n<288> \n<289> \n<290> \n<291> /*\n<292> \n<293> * If we come here, we need to grow the refcount table. Again, a new\n<294> \n<295> * refcount table needs some space and we can't simply allocate to avoid\n<296> \n<297> * endless recursion.\n<298> \n<299> *\n<300> \n<301> * Therefore let's grab new refcount blocks at the end of the image, which\n<302> \n<303> * will describe themselves and the new refcount table. This way we can\n<304> \n<305> * reference them only in the new table and do the switch to the new\n<306> \n<307> * refcount table at once without producing an inconsistent state in\n<308> \n<309> * between.\n<310> \n<311> */\n<312> \n<313> BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n<314> \n<315> \n<316> \n<317> /* Calculate the number of refcount blocks needed so far; this will be the\n<318> \n<319> * basis for calculating the index of the first cluster used for the\n<320> \n<321> * self-describing refcount structures which we are about to create.\n<322> \n<323> *\n<324> \n<325> * Because we reached this point, there cannot be any refcount entries for\n<326> \n<327> * cluster_index or higher indices yet. However, because new_block has been\n<328> \n<329> * allocated to describe that cluster (and it will assume this role later\n<330> \n<331> * on), we cannot use that index; also, new_block may actually have a higher\n<332> \n<333> * cluster index than cluster_index, so it needs to be taken into account\n<334> \n<335> * here (and 1 needs to be added to its value because that cluster is used).\n<336> \n<337> */\n<338> \n<339> uint64_t blocks_used = DIV_ROUND_UP(MAX(cluster_index + 1,\n<340> \n<341> (new_block >> s->cluster_bits) + 1),\n<342> \n<343> s->refcount_block_size);\n<344> \n<345> \n<346> \n<347> if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n<348> \n<349> return -EFBIG;\n<350> \n<351> }\n<352> \n<353> \n<354> \n<355> /* And now we need at least one block more for the new metadata */\n<356> \n<357> uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n<358> \n<359> uint64_t last_table_size;\n<360> \n<361> uint64_t blocks_clusters;\n<362> \n<363> do {\n<364> \n<365> uint64_t table_clusters =\n<366> \n<367> size_to_clusters(s, table_size * sizeof(uint64_t));\n<368> \n<369> blocks_clusters = 1 +\n<370> \n<371> ((table_clusters + s->refcount_block_size - 1)\n<372> \n<373> / s->refcount_block_size);\n<374> \n<375> uint64_t meta_clusters = table_clusters + blocks_clusters;\n<376> \n<377> \n<378> \n<379> last_table_size = table_size;\n<380> \n<381> table_size = next_refcount_table_size(s, blocks_used +\n<382> \n<383> ((meta_clusters + s->refcount_block_size - 1)\n<384> \n<385> / s->refcount_block_size));\n<386> \n<387> \n<388> \n<389> } while (last_table_size != table_size);\n<390> \n<391> \n<392> \n<393> #ifdef DEBUG_ALLOC2\n<394> \n<395> fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " => %" PRId64 "\n",\n<396> \n<397> s->refcount_table_size, table_size);\n<398> \n<399> #endif\n<400> \n<401> \n<402> \n<403> /* Create the new refcount table and blocks */\n<404> \n<405> uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n<406> \n<407> s->cluster_size;\n<408> \n<409> uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n<410> \n<411> uint64_t *new_table = g_try_new0(uint64_t, table_size);\n<412> \n<413> void *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);\n<414> \n<415> \n<416> \n<417> assert(table_size > 0 && blocks_clusters > 0);\n<418> \n<419> if (new_table == NULL || new_blocks == NULL) {\n<420> \n<421> ret = -ENOMEM;\n<422> \n<423> goto fail_table;\n<424> \n<425> }\n<426> \n<427> \n<428> \n<429> /* Fill the new refcount table */\n<430> \n<431> memcpy(new_table, s->refcount_table,\n<432> \n<433> s->refcount_table_size * sizeof(uint64_t));\n<434> \n<435> new_table[refcount_table_index] = new_block;\n<436> \n<437> \n<438> \n<439> int i;\n<440> \n<441> for (i = 0; i < blocks_clusters; i++) {\n<442> \n<443> new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n<444> \n<445> }\n<446> \n<447> \n<448> \n<449> /* Fill the refcount blocks */\n<450> \n<451> uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n<452> \n<453> int block = 0;\n<454> \n<455> for (i = 0; i < table_clusters + blocks_clusters; i++) {\n<456> \n<457> s->set_refcount(new_blocks, block++, 1);\n<458> \n<459> }\n<460> \n<461> \n<462> \n<463> /* Write refcount blocks to disk */\n<464> \n<465> BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n<466> \n<467> ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n<468> \n<469> blocks_clusters * s->cluster_size);\n<470> \n<471> g_free(new_blocks);\n<472> \n<473> new_blocks = NULL;\n<474> \n<475> if (ret < 0) {\n<476> \n<477> goto fail_table;\n<478> \n<479> }\n<480> \n<481> \n<482> \n<483> /* Write refcount table to disk */\n<484> \n<485> for(i = 0; i < table_size; i++) {\n<486> \n<487> cpu_to_be64s(&new_table[i]);\n<488> \n<489> }\n<490> \n<491> \n<492> \n<493> BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n<494> \n<495> ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n<496> \n<497> table_size * sizeof(uint64_t));\n<498> \n<499> if (ret < 0) {\n<500> \n<501> goto fail_table;\n<502> \n<503> }\n<504> \n<505> \n<506> \n<507> for(i = 0; i < table_size; i++) {\n<508> \n<509> be64_to_cpus(&new_table[i]);\n<510> \n<511> }\n<512> \n<513> \n<514> \n<515> /* Hook up the new refcount table in the qcow2 header */\n<516> \n<517> uint8_t data[12];\n<518> \n<519> cpu_to_be64w((uint64_t*)data, table_offset);\n<520> \n<521> cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n<522> \n<523> BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n<524> \n<525> ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n<526> \n<527> data, sizeof(data));\n<528> \n<529> if (ret < 0) {\n<530> \n<531> goto fail_table;\n<532> \n<533> }\n<534> \n<535> \n<536> \n<537> /* And switch it in memory */\n<538> \n<539> uint64_t old_table_offset = s->refcount_table_offset;\n<540> \n<541> uint64_t old_table_size = s->refcount_table_size;\n<542> \n<543> \n<544> \n<545> g_free(s->refcount_table);\n<546> \n<547> s->refcount_table = new_table;\n<548> \n<549> s->refcount_table_size = table_size;\n<550> \n<551> s->refcount_table_offset = table_offset;\n<552> \n<553> \n<554> \n<555> /* Free old table. */\n<556> \n<557> qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n<558> \n<559> QCOW2_DISCARD_OTHER);\n<560> \n<561> \n<562> \n<563> ret = load_refcount_block(bs, new_block, refcount_block);\n<564> \n<565> if (ret < 0) {\n<566> \n<567> return ret;\n<568> \n<569> }\n<570> \n<571> \n<572> \n<573> /* If we were trying to do the initial refcount update for some cluster\n<574> \n<575> * allocation, we might have used the same clusters to store newly\n<576> \n<577> * allocated metadata. Make the caller search some new space. */\n<578> \n<579> return -EAGAIN;\n<580> \n<581> \n<582> \n<583> fail_table:\n<584> \n<585> g_free(new_blocks);\n<586> \n<587> g_free(new_table);\n<588> \n<589> fail_block:\n<590> \n<591> if (*refcount_block != NULL) {\n<592> \n<593> qcow2_cache_put(bs, s->refcount_block_cache, refcount_block);\n<594> \n<595> }\n<596> \n<597> return ret;\n<598> \n<599> }\n<600> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void spapr_reallocate_hpt(sPAPRMachineState *spapr, int shift,\n<2> \n<3> Error **errp)\n<4> \n<5> {\n<6> \n<7> long rc;\n<8> \n<9> \n<10> \n<11> /* Clean up any HPT info from a previous boot */\n<12> \n<13> g_free(spapr->htab);\n<14> \n<15> spapr->htab = NULL;\n<16> \n<17> spapr->htab_shift = 0;\n<18> \n<19> close_htab_fd(spapr);\n<20> \n<21> \n<22> \n<23> rc = kvmppc_reset_htab(shift);\n<24> \n<25> if (rc < 0) {\n<26> \n<27> /* kernel-side HPT needed, but couldn't allocate one */\n<28> \n<29> error_setg_errno(errp, errno,\n<30> \n<31> "Failed to allocate KVM HPT of order %d (try smaller maxmem?)",\n<32> \n<33> shift);\n<34> \n<35> /* This is almost certainly fatal, but if the caller really\n<36> \n<37> * wants to carry on with shift == 0, it's welcome to try */\n<38> \n<39> } else if (rc > 0) {\n<40> \n<41> /* kernel-side HPT allocated */\n<42> \n<43> if (rc != shift) {\n<44> \n<45> error_setg(errp,\n<46> \n<47> "Requested order %d HPT, but kernel allocated order %ld (try smaller maxmem?)",\n<48> \n<49> shift, rc);\n<50> \n<51> }\n<52> \n<53> \n<54> \n<55> spapr->htab_shift = shift;\n<56> \n<57> kvmppc_kern_htab = true;\n<58> \n<59> } else {\n<60> \n<61> /* kernel-side HPT not needed, allocate in userspace instead */\n<62> \n<63> size_t size = 1ULL << shift;\n<64> \n<65> int i;\n<66> \n<67> \n<68> \n<69> spapr->htab = qemu_memalign(size, size);\n<70> \n<71> if (!spapr->htab) {\n<72> \n<73> error_setg_errno(errp, errno,\n<74> \n<75> "Could not allocate HPT of order %d", shift);\n<76> \n<77> return;\n<78> \n<79> }\n<80> \n<81> \n<82> \n<83> memset(spapr->htab, 0, size);\n<84> \n<85> spapr->htab_shift = shift;\n<86> \n<87> kvmppc_kern_htab = false;\n<88> \n<89> \n<90> \n<91> for (i = 0; i < size / HASH_PTE_SIZE_64; i++) {\n<92> \n<93> DIRTY_HPTE(HPTE(spapr->htab, i));\n<94> \n<95> }\n<96> \n<97> }\n<98> \n<99> }\n<100> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,\n<2> \n<3> AVPacket *pkt)\n<4> \n<5> {\n<6> \n<7> MatroskaMuxContext *mkv = s->priv_data;\n<8> \n<9> int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;\n<10> \n<11> uint8_t *start, *end, *data = pkt->data;\n<12> \n<13> ebml_master blockgroup;\n<14> \n<15> char buffer[2048];\n<16> \n<17> \n<18> \n<19> while (data_size) {\n<20> \n<21> int duration = ass_get_duration(data);\n<22> \n<23> max_duration = FFMAX(duration, max_duration);\n<24> \n<25> end          = memchr(data, '\n', data_size);\n<26> \n<27> size         = line_size = end ? end - data + 1 : data_size;\n<28> \n<29> size        -= end ? (end[-1] == '\r') + 1 : 0;\n<30> \n<31> start        = data;\n<32> \n<33> for (i = 0; i < 3; i++, start++)\n<34> \n<35> if (!(start = memchr(start, ',', size - (start - data))))\n<36> \n<37> return max_duration;\n<38> \n<39> size -= start - data;\n<40> \n<41> sscanf(data, "Dialogue: %d,", &layer);\n<42> \n<43> i = snprintf(buffer, sizeof(buffer), "%" PRId64 ",%d,",\n<44> \n<45> s->streams[pkt->stream_index]->nb_frames, layer);\n<46> \n<47> size = FFMIN(i + size, sizeof(buffer));\n<48> \n<49> memcpy(buffer + i, start, size - i);\n<50> \n<51> \n<52> \n<53> av_log(s, AV_LOG_DEBUG,\n<54> \n<55> "Writing block at offset %" PRIu64 ", size %d, "\n<56> \n<57> "pts %" PRId64 ", duration %d\n",\n<58> \n<59> avio_tell(pb), size, pkt->pts, duration);\n<60> \n<61> blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n<62> \n<63> mkv_blockgroup_size(size));\n<64> \n<65> put_ebml_id(pb, MATROSKA_ID_BLOCK);\n<66> \n<67> put_ebml_num(pb, size + 4, 0);\n<68> \n<69> // this assumes stream_index is less than 126\n<70> \n<71> avio_w8(pb, 0x80 | (pkt->stream_index + 1));\n<72> \n<73> avio_wb16(pb, pkt->pts - mkv->cluster_pts);\n<74> \n<75> avio_w8(pb, 0);\n<76> \n<77> avio_write(pb, buffer, size);\n<78> \n<79> put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);\n<80> \n<81> end_ebml_master(pb, blockgroup);\n<82> \n<83> \n<84> \n<85> data      += line_size;\n<86> \n<87> data_size -= line_size;\n<88> \n<89> }\n<90> \n<91> \n<92> \n<93> return max_duration;\n<94> \n<95> }\n<96> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf)\n<2> \n<3> {\n<4> \n<5> SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n<6> \n<7> uint64_t nb_sectors;\n<8> \n<9> bool dbd;\n<10> \n<11> int page, buflen, ret, page_control;\n<12> \n<13> uint8_t *p;\n<14> \n<15> uint8_t dev_specific_param;\n<16> \n<17> \n<18> \n<19> dbd = (r->req.cmd.buf[1] & 0x8) != 0;\n<20> \n<21> page = r->req.cmd.buf[2] & 0x3f;\n<22> \n<23> page_control = (r->req.cmd.buf[2] & 0xc0) >> 6;\n<24> \n<25> DPRINTF("Mode Sense(%d) (page %d, xfer %zd, page_control %d)\n",\n<26> \n<27> (r->req.cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, r->req.cmd.xfer, page_control);\n<28> \n<29> memset(outbuf, 0, r->req.cmd.xfer);\n<30> \n<31> p = outbuf;\n<32> \n<33> \n<34> \n<35> if (s->qdev.type == TYPE_DISK) {\n<36> \n<37> dev_specific_param = s->features & (1 << SCSI_DISK_F_DPOFUA) ? 0x10 : 0;\n<38> \n<39> if (bdrv_is_read_only(s->qdev.conf.bs)) {\n<40> \n<41> dev_specific_param |= 0x80; /* Readonly.  */\n<42> \n<43> }\n<44> \n<45> } else {\n<46> \n<47> /* MMC prescribes that CD/DVD drives have no block descriptors,\n<48> \n<49> * and defines no device-specific parameter.  */\n<50> \n<51> dev_specific_param = 0x00;\n<52> \n<53> dbd = true;\n<54> \n<55> }\n<56> \n<57> \n<58> \n<59> if (r->req.cmd.buf[0] == MODE_SENSE) {\n<60> \n<61> p[1] = 0; /* Default media type.  */\n<62> \n<63> p[2] = dev_specific_param;\n<64> \n<65> p[3] = 0; /* Block descriptor length.  */\n<66> \n<67> p += 4;\n<68> \n<69> } else { /* MODE_SENSE_10 */\n<70> \n<71> p[2] = 0; /* Default media type.  */\n<72> \n<73> p[3] = dev_specific_param;\n<74> \n<75> p[6] = p[7] = 0; /* Block descriptor length.  */\n<76> \n<77> p += 8;\n<78> \n<79> }\n<80> \n<81> \n<82> \n<83> bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n<84> \n<85> if (!dbd && nb_sectors) {\n<86> \n<87> if (r->req.cmd.buf[0] == MODE_SENSE) {\n<88> \n<89> outbuf[3] = 8; /* Block descriptor length  */\n<90> \n<91> } else { /* MODE_SENSE_10 */\n<92> \n<93> outbuf[7] = 8; /* Block descriptor length  */\n<94> \n<95> }\n<96> \n<97> nb_sectors /= (s->qdev.blocksize / 512);\n<98> \n<99> if (nb_sectors > 0xffffff) {\n<100> \n<101> nb_sectors = 0;\n<102> \n<103> }\n<104> \n<105> p[0] = 0; /* media density code */\n<106> \n<107> p[1] = (nb_sectors >> 16) & 0xff;\n<108> \n<109> p[2] = (nb_sectors >> 8) & 0xff;\n<110> \n<111> p[3] = nb_sectors & 0xff;\n<112> \n<113> p[4] = 0; /* reserved */\n<114> \n<115> p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n<116> \n<117> p[6] = s->qdev.blocksize >> 8;\n<118> \n<119> p[7] = 0;\n<120> \n<121> p += 8;\n<122> \n<123> }\n<124> \n<125> \n<126> \n<127> if (page_control == 3) {\n<128> \n<129> /* Saved Values */\n<130> \n<131> scsi_check_condition(r, SENSE_CODE(SAVING_PARAMS_NOT_SUPPORTED));\n<132> \n<133> return -1;\n<134> \n<135> }\n<136> \n<137> \n<138> \n<139> if (page == 0x3f) {\n<140> \n<141> for (page = 0; page <= 0x3e; page++) {\n<142> \n<143> mode_sense_page(s, page, &p, page_control);\n<144> \n<145> }\n<146> \n<147> } else {\n<148> \n<149> ret = mode_sense_page(s, page, &p, page_control);\n<150> \n<151> if (ret == -1) {\n<152> \n<153> return -1;\n<154> \n<155> }\n<156> \n<157> }\n<158> \n<159> \n<160> \n<161> buflen = p - outbuf;\n<162> \n<163> /*\n<164> \n<165> * The mode data length field specifies the length in bytes of the\n<166> \n<167> * following data that is available to be transferred. The mode data\n<168> \n<169> * length does not include itself.\n<170> \n<171> */\n<172> \n<173> if (r->req.cmd.buf[0] == MODE_SENSE) {\n<174> \n<175> outbuf[0] = buflen - 1;\n<176> \n<177> } else { /* MODE_SENSE_10 */\n<178> \n<179> outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n<180> \n<181> outbuf[1] = (buflen - 2) & 0xff;\n<182> \n<183> }\n<184> \n<185> return buflen;\n<186> \n<187> }\n<188> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n<2> \n<3> {\n<4> \n<5> BDRVSheepdogState *s = bs->opaque;\n<6> \n<7> int ret, fd;\n<8> \n<9> uint32_t new_vid;\n<10> \n<11> SheepdogInode *inode;\n<12> \n<13> unsigned int datalen;\n<14> \n<15> \n<16> \n<17> dprintf("sn_info: name %s id_str %s s: name %s vm_state_size %" PRId64 " "\n<18> \n<19> "is_snapshot %d\n", sn_info->name, sn_info->id_str,\n<20> \n<21> s->name, sn_info->vm_state_size, s->is_snapshot);\n<22> \n<23> \n<24> \n<25> if (s->is_snapshot) {\n<26> \n<27> error_report("You can't create a snapshot of a snapshot VDI, "\n<28> \n<29> "%s (%" PRIu32 ").", s->name, s->inode.vdi_id);\n<30> \n<31> \n<32> \n<33> return -EINVAL;\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> dprintf("%s %s\n", sn_info->name, sn_info->id_str);\n<40> \n<41> \n<42> \n<43> s->inode.vm_state_size = sn_info->vm_state_size;\n<44> \n<45> s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n<46> \n<47> /* It appears that inode.tag does not require a NUL terminator,\n<48> \n<49> * which means this use of strncpy is ok.\n<50> \n<51> */\n<52> \n<53> strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n<54> \n<55> /* we don't need to update entire object */\n<56> \n<57> datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n<58> \n<59> \n<60> \n<61> /* refresh inode. */\n<62> \n<63> fd = connect_to_sdog(s->addr, s->port);\n<64> \n<65> if (fd < 0) {\n<66> \n<67> ret = fd;\n<68> \n<69> goto cleanup;\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n<76> \n<77> s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n<78> \n<79> if (ret < 0) {\n<80> \n<81> error_report("failed to write snapshot's inode.");\n<82> \n<83> goto cleanup;\n<84> \n<85> }\n<86> \n<87> \n<88> \n<89> ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n<90> \n<91> s->addr, s->port);\n<92> \n<93> if (ret < 0) {\n<94> \n<95> error_report("failed to create inode for snapshot. %s",\n<96> \n<97> strerror(errno));\n<98> \n<99> goto cleanup;\n<100> \n<101> }\n<102> \n<103> \n<104> \n<105> inode = (SheepdogInode *)g_malloc(datalen);\n<106> \n<107> \n<108> \n<109> ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n<110> \n<111> s->inode.nr_copies, datalen, 0, s->cache_enabled);\n<112> \n<113> \n<114> \n<115> if (ret < 0) {\n<116> \n<117> error_report("failed to read new inode info. %s", strerror(errno));\n<118> \n<119> goto cleanup;\n<120> \n<121> }\n<122> \n<123> \n<124> \n<125> memcpy(&s->inode, inode, datalen);\n<126> \n<127> dprintf("s->inode: name %s snap_id %x oid %x\n",\n<128> \n<129> s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n<130> \n<131> \n<132> \n<133> cleanup:\n<134> \n<135> closesocket(fd);\n<136> \n<137> return ret;\n<138> \n<139> }\n<140> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ar_parse_gnu_filename_table ( struct archive_read * a ) {\n<2> struct ar * ar ;\n<3> char * p ;\n<4> size_t size ;\n<5> ar = ( struct ar * ) ( a -> format -> data ) ;\n<6> size = ar -> strtab_size ;\n<7> for ( p = ar -> strtab ;\n<8> p < ar -> strtab + size - 1 ;\n<9> ++ p ) {\n<10> if ( * p == '/' ) {\n<11> * p ++ = '\0' ;\n<12> if ( * p != '\n' ) goto bad_string_table ;\n<13> * p = '\0' ;\n<14> }\n<15> }\n<16> if ( p != ar -> strtab + size && * p != '\n' && * p != '`' ) goto bad_string_table ;\n<17> ar -> strtab [ size - 1 ] = '\0' ;\n<18> return ( ARCHIVE_OK ) ;\n<19> bad_string_table : archive_set_error ( & a -> archive , EINVAL , "Invalid string table" ) ;\n<20> free ( ar -> strtab ) ;\n<21> ar -> strtab = NULL ;\n<22> return ( ARCHIVE_WARN ) ;\n<23> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int check_refcounts_l1(BlockDriverState *bs,\n<2> \n<3> BdrvCheckResult *res,\n<4> \n<5> void **refcount_table,\n<6> \n<7> int64_t *refcount_table_size,\n<8> \n<9> int64_t l1_table_offset, int l1_size,\n<10> \n<11> int flags)\n<12> \n<13> {\n<14> \n<15> BDRVQcow2State *s = bs->opaque;\n<16> \n<17> uint64_t *l1_table = NULL, l2_offset, l1_size2;\n<18> \n<19> int i, ret;\n<20> \n<21> \n<22> \n<23> l1_size2 = l1_size * sizeof(uint64_t);\n<24> \n<25> \n<26> \n<27> /* Mark L1 table as used */\n<28> \n<29> ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n<30> \n<31> l1_table_offset, l1_size2);\n<32> \n<33> if (ret < 0) {\n<34> \n<35> goto fail;\n<36> \n<37> }\n<38> \n<39> \n<40> \n<41> /* Read L1 table entries from disk */\n<42> \n<43> if (l1_size2 > 0) {\n<44> \n<45> l1_table = g_try_malloc(l1_size2);\n<46> \n<47> if (l1_table == NULL) {\n<48> \n<49> ret = -ENOMEM;\n<50> \n<51> res->check_errors++;\n<52> \n<53> goto fail;\n<54> \n<55> }\n<56> \n<57> ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n<58> \n<59> if (ret < 0) {\n<60> \n<61> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");\n<62> \n<63> res->check_errors++;\n<64> \n<65> goto fail;\n<66> \n<67> }\n<68> \n<69> for(i = 0;i < l1_size; i++)\n<70> \n<71> be64_to_cpus(&l1_table[i]);\n<72> \n<73> }\n<74> \n<75> \n<76> \n<77> /* Do the actual checks */\n<78> \n<79> for(i = 0; i < l1_size; i++) {\n<80> \n<81> l2_offset = l1_table[i];\n<82> \n<83> if (l2_offset) {\n<84> \n<85> /* Mark L2 table as used */\n<86> \n<87> l2_offset &= L1E_OFFSET_MASK;\n<88> \n<89> ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n<90> \n<91> l2_offset, s->cluster_size);\n<92> \n<93> if (ret < 0) {\n<94> \n<95> goto fail;\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> /* L2 tables are cluster aligned */\n<102> \n<103> if (offset_into_cluster(s, l2_offset)) {\n<104> \n<105> fprintf(stderr, "ERROR l2_offset=%" PRIx64 ": Table is not "\n<106> \n<107> "cluster aligned; L1 entry corrupted\n", l2_offset);\n<108> \n<109> res->corruptions++;\n<110> \n<111> }\n<112> \n<113> \n<114> \n<115> /* Process and check L2 entries */\n<116> \n<117> ret = check_refcounts_l2(bs, res, refcount_table,\n<118> \n<119> refcount_table_size, l2_offset, flags);\n<120> \n<121> if (ret < 0) {\n<122> \n<123> goto fail;\n<124> \n<125> }\n<126> \n<127> }\n<128> \n<129> }\n<130> \n<131> g_free(l1_table);\n<132> \n<133> return 0;\n<134> \n<135> \n<136> \n<137> fail:\n<138> \n<139> g_free(l1_table);\n<140> \n<141> return ret;\n<142> \n<143> }\n<144> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n<2> \n<3> {\n<4> \n<5> int ret = 0;\n<6> \n<7> if (av_strstart(p, "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &p)) {\n<8> \n<9> AVIOContext pb;\n<10> \n<11> RTSPState *rt = s->priv_data;\n<12> \n<13> AVDictionary *opts = NULL;\n<14> \n<15> int len = strlen(p) * 6 / 8;\n<16> \n<17> char *buf = av_mallocz(len);\n<18> \n<19> av_base64_decode(buf, p, len);\n<20> \n<21> \n<22> \n<23> if (rtp_asf_fix_header(buf, len) < 0)\n<24> \n<25> av_log(s, AV_LOG_ERROR,\n<26> \n<27> "Failed to fix invalid RTSP-MS/ASF min_pktsize\n");\n<28> \n<29> init_packetizer(&pb, buf, len);\n<30> \n<31> if (rt->asf_ctx) {\n<32> \n<33> avformat_close_input(&rt->asf_ctx);\n<34> \n<35> }\n<36> \n<37> if (!(rt->asf_ctx = avformat_alloc_context()))\n<38> \n<39> return AVERROR(ENOMEM);\n<40> \n<41> rt->asf_ctx->pb      = &pb;\n<42> \n<43> av_dict_set(&opts, "no_resync_search", "1", 0);\n<44> \n<45> ret = avformat_open_input(&rt->asf_ctx, "", &ff_asf_demuxer, &opts);\n<46> \n<47> av_dict_free(&opts);\n<48> \n<49> if (ret < 0)\n<50> \n<51> return ret;\n<52> \n<53> av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);\n<54> \n<55> rt->asf_pb_pos = avio_tell(&pb);\n<56> \n<57> av_free(buf);\n<58> \n<59> rt->asf_ctx->pb = NULL;\n<60> \n<61> }\n<62> \n<63> return ret;\n<64> \n<65> }\n<66> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_mpeg_update_thread_context(AVCodecContext *dst,\n<2> \n<3> const AVCodecContext *src)\n<4> \n<5> {\n<6> \n<7> int i;\n<8> \n<9> MpegEncContext *s = dst->priv_data, *s1 = src->priv_data;\n<10> \n<11> \n<12> \n<13> if (dst == src)\n<14> \n<15> return 0;\n<16> \n<17> \n<18> \n<19> // FIXME can parameters change on I-frames?\n<20> \n<21> // in that case dst may need a reinit\n<22> \n<23> if (!s->context_initialized) {\n<24> \n<25> memcpy(s, s1, sizeof(MpegEncContext));\n<26> \n<27> \n<28> \n<29> s->avctx                 = dst;\n<30> \n<31> s->bitstream_buffer      = NULL;\n<32> \n<33> s->bitstream_buffer_size = s->allocated_bitstream_buffer_size = 0;\n<34> \n<35> \n<36> \n<37> if (s1->context_initialized){\n<38> \n<39> s->picture_range_start  += MAX_PICTURE_COUNT;\n<40> \n<41> s->picture_range_end    += MAX_PICTURE_COUNT;\n<42> \n<43> ff_MPV_common_init(s);\n<44> \n<45> }\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> if (s->height != s1->height || s->width != s1->width || s->context_reinit) {\n<52> \n<53> int err;\n<54> \n<55> s->context_reinit = 0;\n<56> \n<57> s->height = s1->height;\n<58> \n<59> s->width  = s1->width;\n<60> \n<61> if ((err = ff_MPV_common_frame_size_change(s)) < 0)\n<62> \n<63> return err;\n<64> \n<65> }\n<66> \n<67> \n<68> \n<69> s->avctx->coded_height  = s1->avctx->coded_height;\n<70> \n<71> s->avctx->coded_width   = s1->avctx->coded_width;\n<72> \n<73> s->avctx->width         = s1->avctx->width;\n<74> \n<75> s->avctx->height        = s1->avctx->height;\n<76> \n<77> \n<78> \n<79> s->coded_picture_number = s1->coded_picture_number;\n<80> \n<81> s->picture_number       = s1->picture_number;\n<82> \n<83> s->input_picture_number = s1->input_picture_number;\n<84> \n<85> \n<86> \n<87> memcpy(s->picture, s1->picture, s1->picture_count * sizeof(Picture));\n<88> \n<89> memcpy(&s->last_picture, &s1->last_picture,\n<90> \n<91> (char *) &s1->last_picture_ptr - (char *) &s1->last_picture);\n<92> \n<93> \n<94> \n<95> // reset s->picture[].f.extended_data to s->picture[].f.data\n<96> \n<97> for (i = 0; i < s->picture_count; i++)\n<98> \n<99> s->picture[i].f.extended_data = s->picture[i].f.data;\n<100> \n<101> \n<102> \n<103> s->last_picture_ptr    = REBASE_PICTURE(s1->last_picture_ptr,    s, s1);\n<104> \n<105> s->current_picture_ptr = REBASE_PICTURE(s1->current_picture_ptr, s, s1);\n<106> \n<107> s->next_picture_ptr    = REBASE_PICTURE(s1->next_picture_ptr,    s, s1);\n<108> \n<109> \n<110> \n<111> // Error/bug resilience\n<112> \n<113> s->next_p_frame_damaged = s1->next_p_frame_damaged;\n<114> \n<115> s->workaround_bugs      = s1->workaround_bugs;\n<116> \n<117> s->padding_bug_score    = s1->padding_bug_score;\n<118> \n<119> \n<120> \n<121> // MPEG4 timing info\n<122> \n<123> memcpy(&s->time_increment_bits, &s1->time_increment_bits,\n<124> \n<125> (char *) &s1->shape - (char *) &s1->time_increment_bits);\n<126> \n<127> \n<128> \n<129> // B-frame info\n<130> \n<131> s->max_b_frames = s1->max_b_frames;\n<132> \n<133> s->low_delay    = s1->low_delay;\n<134> \n<135> s->dropable     = s1->dropable;\n<136> \n<137> \n<138> \n<139> // DivX handling (doesn't work)\n<140> \n<141> s->divx_packed  = s1->divx_packed;\n<142> \n<143> \n<144> \n<145> if (s1->bitstream_buffer) {\n<146> \n<147> if (s1->bitstream_buffer_size +\n<148> \n<149> FF_INPUT_BUFFER_PADDING_SIZE > s->allocated_bitstream_buffer_size)\n<150> \n<151> av_fast_malloc(&s->bitstream_buffer,\n<152> \n<153> &s->allocated_bitstream_buffer_size,\n<154> \n<155> s1->allocated_bitstream_buffer_size);\n<156> \n<157> s->bitstream_buffer_size = s1->bitstream_buffer_size;\n<158> \n<159> memcpy(s->bitstream_buffer, s1->bitstream_buffer,\n<160> \n<161> s1->bitstream_buffer_size);\n<162> \n<163> memset(s->bitstream_buffer + s->bitstream_buffer_size, 0,\n<164> \n<165> FF_INPUT_BUFFER_PADDING_SIZE);\n<166> \n<167> }\n<168> \n<169> \n<170> \n<171> // MPEG2/interlacing info\n<172> \n<173> memcpy(&s->progressive_sequence, &s1->progressive_sequence,\n<174> \n<175> (char *) &s1->rtp_mode - (char *) &s1->progressive_sequence);\n<176> \n<177> \n<178> \n<179> if (!s1->first_field) {\n<180> \n<181> s->last_pict_type = s1->pict_type;\n<182> \n<183> if (s1->current_picture_ptr)\n<184> \n<185> s->last_lambda_for[s1->pict_type] = s1->current_picture_ptr->f.quality;\n<186> \n<187> \n<188> \n<189> if (s1->pict_type != AV_PICTURE_TYPE_B) {\n<190> \n<191> s->last_non_b_pict_type = s1->pict_type;\n<192> \n<193> }\n<194> \n<195> }\n<196> \n<197> \n<198> \n<199> return 0;\n<200> \n<201> }\n<202> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void v9fs_version(void *opaque)\n<2> \n<3> {\n<4> \n<5> V9fsPDU *pdu = opaque;\n<6> \n<7> V9fsState *s = pdu->s;\n<8> \n<9> V9fsString version;\n<10> \n<11> size_t offset = 7;\n<12> \n<13> \n<14> \n<15> pdu_unmarshal(pdu, offset, "ds", &s->msize, &version);\n<16> \n<17> trace_v9fs_version(pdu->tag, pdu->id, s->msize, version.data);\n<18> \n<19> \n<20> \n<21> virtfs_reset(pdu);\n<22> \n<23> \n<24> \n<25> if (!strcmp(version.data, "9P2000.u")) {\n<26> \n<27> s->proto_version = V9FS_PROTO_2000U;\n<28> \n<29> } else if (!strcmp(version.data, "9P2000.L")) {\n<30> \n<31> s->proto_version = V9FS_PROTO_2000L;\n<32> \n<33> } else {\n<34> \n<35> v9fs_string_sprintf(&version, "unknown");\n<36> \n<37> }\n<38> \n<39> \n<40> \n<41> offset += pdu_marshal(pdu, offset, "ds", s->msize, &version);\n<42> \n<43> trace_v9fs_version_return(pdu->tag, pdu->id, s->msize, version.data);\n<44> \n<45> \n<46> \n<47> complete_pdu(s, pdu, offset);\n<48> \n<49> \n<50> \n<51> v9fs_string_free(&version);\n<52> \n<53> return;\n<54> \n<55> }\n<56> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int grab_read_header(AVFormatContext *s1, AVFormatParameters *ap)\n<2> \n<3> {\n<4> \n<5> VideoData *s = s1->priv_data;\n<6> \n<7> AVStream *st;\n<8> \n<9> int video_fd;\n<10> \n<11> int desired_palette, desired_depth;\n<12> \n<13> struct video_tuner tuner;\n<14> \n<15> struct video_audio audio;\n<16> \n<17> struct video_picture pict;\n<18> \n<19> int j;\n<20> \n<21> int vformat_num = FF_ARRAY_ELEMS(video_formats);\n<22> \n<23> \n<24> \n<25> av_log(s1, AV_LOG_WARNING, "V4L input device is deprecated and will be removed in the next release.");\n<26> \n<27> \n<28> \n<29> if (ap->time_base.den <= 0) {\n<30> \n<31> av_log(s1, AV_LOG_ERROR, "Wrong time base (%d)\n", ap->time_base.den);\n<32> \n<33> return -1;\n<34> \n<35> }\n<36> \n<37> s->time_base = ap->time_base;\n<38> \n<39> \n<40> \n<41> s->video_win.width = ap->width;\n<42> \n<43> s->video_win.height = ap->height;\n<44> \n<45> \n<46> \n<47> st = avformat_new_stream(s1, NULL);\n<48> \n<49> if (!st)\n<50> \n<51> return AVERROR(ENOMEM);\n<52> \n<53> avpriv_set_pts_info(st, 64, 1, 1000000); /* 64 bits pts in us */\n<54> \n<55> \n<56> \n<57> video_fd = open(s1->filename, O_RDWR);\n<58> \n<59> if (video_fd < 0) {\n<60> \n<61> av_log(s1, AV_LOG_ERROR, "%s: %s\n", s1->filename, strerror(errno));\n<62> \n<63> goto fail;\n<64> \n<65> }\n<66> \n<67> \n<68> \n<69> if (ioctl(video_fd, VIDIOCGCAP, &s->video_cap) < 0) {\n<70> \n<71> av_log(s1, AV_LOG_ERROR, "VIDIOCGCAP: %s\n", strerror(errno));\n<72> \n<73> goto fail;\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> if (!(s->video_cap.type & VID_TYPE_CAPTURE)) {\n<80> \n<81> av_log(s1, AV_LOG_ERROR, "Fatal: grab device does not handle capture\n");\n<82> \n<83> goto fail;\n<84> \n<85> }\n<86> \n<87> \n<88> \n<89> /* no values set, autodetect them */\n<90> \n<91> if (s->video_win.width <= 0 || s->video_win.height <= 0) {\n<92> \n<93> if (ioctl(video_fd, VIDIOCGWIN, &s->video_win, sizeof(s->video_win)) < 0) {\n<94> \n<95> av_log(s1, AV_LOG_ERROR, "VIDIOCGWIN: %s\n", strerror(errno));\n<96> \n<97> goto fail;\n<98> \n<99> }\n<100> \n<101> }\n<102> \n<103> \n<104> \n<105> if(av_image_check_size(s->video_win.width, s->video_win.height, 0, s1) < 0)\n<106> \n<107> return -1;\n<108> \n<109> \n<110> \n<111> desired_palette = -1;\n<112> \n<113> desired_depth = -1;\n<114> \n<115> for (j = 0; j < vformat_num; j++) {\n<116> \n<117> if (ap->pix_fmt == video_formats[j].pix_fmt) {\n<118> \n<119> desired_palette = video_formats[j].palette;\n<120> \n<121> desired_depth = video_formats[j].depth;\n<122> \n<123> break;\n<124> \n<125> }\n<126> \n<127> }\n<128> \n<129> \n<130> \n<131> /* set tv standard */\n<132> \n<133> if (!ioctl(video_fd, VIDIOCGTUNER, &tuner)) {\n<134> \n<135> tuner.mode = s->standard;\n<136> \n<137> ioctl(video_fd, VIDIOCSTUNER, &tuner);\n<138> \n<139> }\n<140> \n<141> \n<142> \n<143> /* unmute audio */\n<144> \n<145> audio.audio = 0;\n<146> \n<147> ioctl(video_fd, VIDIOCGAUDIO, &audio);\n<148> \n<149> memcpy(&s->audio_saved, &audio, sizeof(audio));\n<150> \n<151> audio.flags &= ~VIDEO_AUDIO_MUTE;\n<152> \n<153> ioctl(video_fd, VIDIOCSAUDIO, &audio);\n<154> \n<155> \n<156> \n<157> ioctl(video_fd, VIDIOCGPICT, &pict);\n<158> \n<159> av_dlog(s1, "v4l: colour=%d hue=%d brightness=%d constrast=%d whiteness=%d\n",\n<160> \n<161> pict.colour, pict.hue, pict.brightness, pict.contrast, pict.whiteness);\n<162> \n<163> /* try to choose a suitable video format */\n<164> \n<165> pict.palette = desired_palette;\n<166> \n<167> pict.depth= desired_depth;\n<168> \n<169> if (desired_palette == -1 || ioctl(video_fd, VIDIOCSPICT, &pict) < 0) {\n<170> \n<171> for (j = 0; j < vformat_num; j++) {\n<172> \n<173> pict.palette = video_formats[j].palette;\n<174> \n<175> pict.depth = video_formats[j].depth;\n<176> \n<177> if (-1 != ioctl(video_fd, VIDIOCSPICT, &pict))\n<178> \n<179> break;\n<180> \n<181> }\n<182> \n<183> if (j >= vformat_num)\n<184> \n<185> goto fail1;\n<186> \n<187> }\n<188> \n<189> \n<190> \n<191> if (ioctl(video_fd, VIDIOCGMBUF, &s->gb_buffers) < 0) {\n<192> \n<193> /* try to use read based access */\n<194> \n<195> int val;\n<196> \n<197> \n<198> \n<199> s->video_win.x = 0;\n<200> \n<201> s->video_win.y = 0;\n<202> \n<203> s->video_win.chromakey = -1;\n<204> \n<205> s->video_win.flags = 0;\n<206> \n<207> \n<208> \n<209> if (ioctl(video_fd, VIDIOCSWIN, s->video_win) < 0) {\n<210> \n<211> av_log(s1, AV_LOG_ERROR, "VIDIOCSWIN: %s\n", strerror(errno));\n<212> \n<213> goto fail;\n<214> \n<215> }\n<216> \n<217> \n<218> \n<219> s->frame_format = pict.palette;\n<220> \n<221> \n<222> \n<223> val = 1;\n<224> \n<225> if (ioctl(video_fd, VIDIOCCAPTURE, &val) < 0) {\n<226> \n<227> av_log(s1, AV_LOG_ERROR, "VIDIOCCAPTURE: %s\n", strerror(errno));\n<228> \n<229> goto fail;\n<230> \n<231> }\n<232> \n<233> \n<234> \n<235> s->time_frame = av_gettime() * s->time_base.den / s->time_base.num;\n<236> \n<237> s->use_mmap = 0;\n<238> \n<239> } else {\n<240> \n<241> s->video_buf = mmap(0, s->gb_buffers.size, PROT_READ|PROT_WRITE, MAP_SHARED, video_fd, 0);\n<242> \n<243> if ((unsigned char*)-1 == s->video_buf) {\n<244> \n<245> s->video_buf = mmap(0, s->gb_buffers.size, PROT_READ|PROT_WRITE, MAP_PRIVATE, video_fd, 0);\n<246> \n<247> if ((unsigned char*)-1 == s->video_buf) {\n<248> \n<249> av_log(s1, AV_LOG_ERROR, "mmap: %s\n", strerror(errno));\n<250> \n<251> goto fail;\n<252> \n<253> }\n<254> \n<255> }\n<256> \n<257> s->gb_frame = 0;\n<258> \n<259> s->time_frame = av_gettime() * s->time_base.den / s->time_base.num;\n<260> \n<261> \n<262> \n<263> /* start to grab the first frame */\n<264> \n<265> s->gb_buf.frame = s->gb_frame % s->gb_buffers.frames;\n<266> \n<267> s->gb_buf.height = s->video_win.height;\n<268> \n<269> s->gb_buf.width = s->video_win.width;\n<270> \n<271> s->gb_buf.format = pict.palette;\n<272> \n<273> \n<274> \n<275> if (ioctl(video_fd, VIDIOCMCAPTURE, &s->gb_buf) < 0) {\n<276> \n<277> if (errno != EAGAIN) {\n<278> \n<279> fail1:\n<280> \n<281> av_log(s1, AV_LOG_ERROR, "VIDIOCMCAPTURE: %s\n", strerror(errno));\n<282> \n<283> } else {\n<284> \n<285> av_log(s1, AV_LOG_ERROR, "Fatal: grab device does not receive any video signal\n");\n<286> \n<287> }\n<288> \n<289> goto fail;\n<290> \n<291> }\n<292> \n<293> for (j = 1; j < s->gb_buffers.frames; j++) {\n<294> \n<295> s->gb_buf.frame = j;\n<296> \n<297> ioctl(video_fd, VIDIOCMCAPTURE, &s->gb_buf);\n<298> \n<299> }\n<300> \n<301> s->frame_format = s->gb_buf.format;\n<302> \n<303> s->use_mmap = 1;\n<304> \n<305> }\n<306> \n<307> \n<308> \n<309> for (j = 0; j < vformat_num; j++) {\n<310> \n<311> if (s->frame_format == video_formats[j].palette) {\n<312> \n<313> s->frame_size = s->video_win.width * s->video_win.height * video_formats[j].depth / 8;\n<314> \n<315> st->codec->pix_fmt = video_formats[j].pix_fmt;\n<316> \n<317> break;\n<318> \n<319> }\n<320> \n<321> }\n<322> \n<323> \n<324> \n<325> if (j >= vformat_num)\n<326> \n<327> goto fail;\n<328> \n<329> \n<330> \n<331> s->fd = video_fd;\n<332> \n<333> \n<334> \n<335> st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n<336> \n<337> st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;\n<338> \n<339> st->codec->width = s->video_win.width;\n<340> \n<341> st->codec->height = s->video_win.height;\n<342> \n<343> st->codec->time_base = s->time_base;\n<344> \n<345> st->codec->bit_rate = s->frame_size * 1/av_q2d(st->codec->time_base) * 8;\n<346> \n<347> \n<348> \n<349> return 0;\n<350> \n<351> fail:\n<352> \n<353> if (video_fd >= 0)\n<354> \n<355> close(video_fd);\n<356> \n<357> return AVERROR(EIO);\n<358> \n<359> }\n<360> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> START_TEST(qdict_new_test)\n<2> \n<3> {\n<4> \n<5> QDict *qdict;\n<6> \n<7> \n<8> \n<9> qdict = qdict_new();\n<10> \n<11> fail_unless(qdict != NULL);\n<12> \n<13> fail_unless(qdict_size(qdict) == 0);\n<14> \n<15> fail_unless(qdict->base.refcnt == 1);\n<16> \n<17> fail_unless(qobject_type(QOBJECT(qdict)) == QTYPE_QDICT);\n<18> \n<19> \n<20> \n<21> // destroy doesn't exit yet\n<22> \n<23> free(qdict);\n<24> \n<25> }\n<26> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n<2> CPUState * env = NULL ;\n<3> ram_addr_t ram_addr ;\n<4> ram_addr_t kernel_size = 0 ;\n<5> ram_addr_t initrd_offset ;\n<6> ram_addr_t initrd_size = 0 ;\n<7> int i ;\n<8> if ( ! kvm_enabled ( ) ) {\n<9> fprintf ( stderr , "The S390 target only works with KVM enabled\n" ) ;\n<10> exit ( 1 ) ;\n<11> }\n<12> s390_bus = s390_virtio_bus_init ( & ram_size ) ;\n<13> ram_addr = qemu_ram_alloc ( ram_size ) ;\n<14> cpu_register_physical_memory ( 0 , ram_size , ram_addr ) ;\n<15> if ( cpu_model == NULL ) {\n<16> cpu_model = "host" ;\n<17> }\n<18> ipi_states = qemu_malloc ( sizeof ( CPUState * ) * smp_cpus ) ;\n<19> for ( i = 0 ;\n<20> i < smp_cpus ;\n<21> i ++ ) {\n<22> CPUState * tmp_env ;\n<23> tmp_env = cpu_init ( cpu_model ) ;\n<24> if ( ! env ) {\n<25> env = tmp_env ;\n<26> }\n<27> ipi_states [ i ] = tmp_env ;\n<28> tmp_env -> halted = 1 ;\n<29> tmp_env -> exception_index = EXCP_HLT ;\n<30> }\n<31> env -> halted = 0 ;\n<32> env -> exception_index = 0 ;\n<33> if ( kernel_filename ) {\n<34> kernel_size = load_image ( kernel_filename , qemu_get_ram_ptr ( 0 ) ) ;\n<35> if ( lduw_phys ( KERN_IMAGE_START ) != 0x0dd0 ) {\n<36> fprintf ( stderr , "Specified image is not an s390 boot image\n" ) ;\n<37> exit ( 1 ) ;\n<38> }\n<39> cpu_synchronize_state ( env ) ;\n<40> env -> psw . addr = KERN_IMAGE_START ;\n<41> env -> psw . mask = 0x0000000180000000ULL ;\n<42> }\n<43> if ( initrd_filename ) {\n<44> initrd_offset = INITRD_START ;\n<45> while ( kernel_size + 0x100000 > initrd_offset ) {\n<46> initrd_offset += 0x100000 ;\n<47> }\n<48> initrd_size = load_image ( initrd_filename , qemu_get_ram_ptr ( initrd_offset ) ) ;\n<49> stq_phys ( INITRD_PARM_START , initrd_offset ) ;\n<50> stq_phys ( INITRD_PARM_SIZE , initrd_size ) ;\n<51> }\n<52> if ( kernel_cmdline ) {\n<53> cpu_physical_memory_rw ( KERN_PARM_AREA , ( uint8_t * ) kernel_cmdline , strlen ( kernel_cmdline ) , 1 ) ;\n<54> }\n<55> for ( i = 0 ;\n<56> i < MAX_VIRTIO_CONSOLES ;\n<57> i ++ ) {\n<58> if ( virtcon_hds [ i ] ) {\n<59> qdev_init_nofail ( qdev_create ( ( BusState * ) s390_bus , "virtio-console-s390" ) ) ;\n<60> }\n<61> }\n<62> for ( i = 0 ;\n<63> i < nb_nics ;\n<64> i ++ ) {\n<65> NICInfo * nd = & nd_table [ i ] ;\n<66> DeviceState * dev ;\n<67> if ( ! nd -> model ) {\n<68> nd -> model = qemu_strdup ( "virtio" ) ;\n<69> }\n<70> if ( strcmp ( nd -> model , "virtio" ) ) {\n<71> fprintf ( stderr , "S390 only supports VirtIO nics\n" ) ;\n<72> exit ( 1 ) ;\n<73> }\n<74> dev = qdev_create ( ( BusState * ) s390_bus , "virtio-net-s390" ) ;\n<75> qdev_set_nic_properties ( dev , nd ) ;\n<76> qdev_init_nofail ( dev ) ;\n<77> }\n<78> for ( i = 0 ;\n<79> i < MAX_BLK_DEVS ;\n<80> i ++ ) {\n<81> DriveInfo * dinfo ;\n<82> DeviceState * dev ;\n<83> dinfo = drive_get ( IF_IDE , 0 , i ) ;\n<84> if ( ! dinfo ) {\n<85> continue ;\n<86> }\n<87> dev = qdev_create ( ( BusState * ) s390_bus , "virtio-blk-s390" ) ;\n<88> qdev_prop_set_drive ( dev , "drive" , dinfo ) ;\n<89> qdev_init_nofail ( dev ) ;\n<90> }\n<91> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> AVBufferRef *av_buffer_alloc(int size)\n<2> \n<3> {\n<4> \n<5> AVBufferRef *ret = NULL;\n<6> \n<7> uint8_t    *data = NULL;\n<8> \n<9> \n<10> \n<11> data = av_malloc(size);\n<12> \n<13> if (!data)\n<14> \n<15> return NULL;\n<16> \n<17> \n<18> \n<19> if(CONFIG_MEMORY_POISONING)\n<20> \n<21> memset(data, 0x2a, size);\n<22> \n<23> \n<24> \n<25> ret = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);\n<26> \n<27> if (!ret)\n<28> \n<29> av_freep(&data);\n<30> \n<31> \n<32> \n<33> return ret;\n<34> \n<35> }\n<36> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> mips_mipssim_init (ram_addr_t ram_size, int vga_ram_size,\n<2> \n<3> const char *boot_device, DisplayState *ds,\n<4> \n<5> const char *kernel_filename, const char *kernel_cmdline,\n<6> \n<7> const char *initrd_filename, const char *cpu_model)\n<8> \n<9> {\n<10> \n<11> char buf[1024];\n<12> \n<13> unsigned long bios_offset;\n<14> \n<15> CPUState *env;\n<16> \n<17> int bios_size;\n<18> \n<19> \n<20> \n<21> /* Init CPUs. */\n<22> \n<23> if (cpu_model == NULL) {\n<24> \n<25> #ifdef TARGET_MIPS64\n<26> \n<27> cpu_model = "5Kf";\n<28> \n<29> #else\n<30> \n<31> cpu_model = "24Kf";\n<32> \n<33> #endif\n<34> \n<35> }\n<36> \n<37> env = cpu_init(cpu_model);\n<38> \n<39> if (!env) {\n<40> \n<41> fprintf(stderr, "Unable to find CPU definition\n");\n<42> \n<43> exit(1);\n<44> \n<45> }\n<46> \n<47> qemu_register_reset(main_cpu_reset, env);\n<48> \n<49> \n<50> \n<51> /* Allocate RAM. */\n<52> \n<53> cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n<54> \n<55> \n<56> \n<57> /* Load a BIOS / boot exception handler image. */\n<58> \n<59> bios_offset = ram_size + vga_ram_size;\n<60> \n<61> if (bios_name == NULL)\n<62> \n<63> bios_name = BIOS_FILENAME;\n<64> \n<65> snprintf(buf, sizeof(buf), "%s/%s", bios_dir, bios_name);\n<66> \n<67> bios_size = load_image(buf, phys_ram_base + bios_offset);\n<68> \n<69> if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n<70> \n<71> /* Bail out if we have neither a kernel image nor boot vector code. */\n<72> \n<73> fprintf(stderr,\n<74> \n<75> "qemu: Could not load MIPS bios '%s', and no -kernel argument was specified\n",\n<76> \n<77> buf);\n<78> \n<79> exit(1);\n<80> \n<81> } else {\n<82> \n<83> /* Map the BIOS / boot exception handler. */\n<84> \n<85> cpu_register_physical_memory(0x1fc00000LL,\n<86> \n<87> bios_size, bios_offset | IO_MEM_ROM);\n<88> \n<89> /* We have a boot vector start address. */\n<90> \n<91> env->active_tc.PC = (target_long)(int32_t)0xbfc00000;\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> if (kernel_filename) {\n<98> \n<99> loaderparams.ram_size = ram_size;\n<100> \n<101> loaderparams.kernel_filename = kernel_filename;\n<102> \n<103> loaderparams.kernel_cmdline = kernel_cmdline;\n<104> \n<105> loaderparams.initrd_filename = initrd_filename;\n<106> \n<107> load_kernel(env);\n<108> \n<109> }\n<110> \n<111> \n<112> \n<113> /* Init CPU internal devices. */\n<114> \n<115> cpu_mips_irq_init_cpu(env);\n<116> \n<117> cpu_mips_clock_init(env);\n<118> \n<119> \n<120> \n<121> /* Register 64 KB of ISA IO space at 0x1fd00000. */\n<122> \n<123> isa_mmio_init(0x1fd00000, 0x00010000);\n<124> \n<125> \n<126> \n<127> /* A single 16450 sits at offset 0x3f8. It is attached to\n<128> \n<129> MIPS CPU INT2, which is interrupt 4. */\n<130> \n<131> if (serial_hds[0])\n<132> \n<133> serial_init(0x3f8, env->irq[4], 115200, serial_hds[0]);\n<134> \n<135> \n<136> \n<137> if (nd_table[0].vlan) {\n<138> \n<139> if (nd_table[0].model == NULL\n<140> \n<141> || strcmp(nd_table[0].model, "mipsnet") == 0) {\n<142> \n<143> /* MIPSnet uses the MIPS CPU INT0, which is interrupt 2. */\n<144> \n<145> mipsnet_init(0x4200, env->irq[2], &nd_table[0]);\n<146> \n<147> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<148> \n<149> fprintf(stderr, "qemu: Supported NICs: mipsnet\n");\n<150> \n<151> exit (1);\n<152> \n<153> } else {\n<154> \n<155> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<156> \n<157> exit (1);\n<158> \n<159> }\n<160> \n<161> }\n<162> \n<163> }\n<164> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void qcow2_invalidate_cache(BlockDriverState *bs, Error **errp)\n<2> \n<3> {\n<4> \n<5> BDRVQcow2State *s = bs->opaque;\n<6> \n<7> int flags = s->flags;\n<8> \n<9> QCryptoCipher *cipher = NULL;\n<10> \n<11> QDict *options;\n<12> \n<13> Error *local_err = NULL;\n<14> \n<15> int ret;\n<16> \n<17> \n<18> \n<19> /*\n<20> \n<21> * Backing files are read-only which makes all of their metadata immutable,\n<22> \n<23> * that means we don't have to worry about reopening them here.\n<24> \n<25> */\n<26> \n<27> \n<28> \n<29> cipher = s->cipher;\n<30> \n<31> s->cipher = NULL;\n<32> \n<33> \n<34> \n<35> qcow2_close(bs);\n<36> \n<37> \n<38> \n<39> bdrv_invalidate_cache(bs->file->bs, &local_err);\n<40> \n<41> if (local_err) {\n<42> \n<43> error_propagate(errp, local_err);\n<44> \n<45> bs->drv = NULL;\n<46> \n<47> return;\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> memset(s, 0, sizeof(BDRVQcow2State));\n<54> \n<55> options = qdict_clone_shallow(bs->options);\n<56> \n<57> \n<58> \n<59> flags &= ~BDRV_O_INACTIVE;\n<60> \n<61> ret = qcow2_open(bs, options, flags, &local_err);\n<62> \n<63> QDECREF(options);\n<64> \n<65> if (local_err) {\n<66> \n<67> error_propagate(errp, local_err);\n<68> \n<69> error_prepend(errp, "Could not reopen qcow2 layer: ");\n<70> \n<71> bs->drv = NULL;\n<72> \n<73> return;\n<74> \n<75> } else if (ret < 0) {\n<76> \n<77> error_setg_errno(errp, -ret, "Could not reopen qcow2 layer");\n<78> \n<79> bs->drv = NULL;\n<80> \n<81> return;\n<82> \n<83> }\n<84> \n<85> \n<86> \n<87> s->cipher = cipher;\n<88> \n<89> }\n<90> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int h264_export_frame_props(H264Context *h)\n<2> \n<3> {\n<4> \n<5> const SPS *sps = h->ps.sps;\n<6> \n<7> H264Picture *cur = h->cur_pic_ptr;\n<8> \n<9> \n<10> \n<11> cur->f->interlaced_frame = 0;\n<12> \n<13> cur->f->repeat_pict      = 0;\n<14> \n<15> \n<16> \n<17> /* Signal interlacing information externally. */\n<18> \n<19> /* Prioritize picture timing SEI information over used\n<20> \n<21> * decoding process if it exists. */\n<22> \n<23> \n<24> \n<25> if (sps->pic_struct_present_flag) {\n<26> \n<27> H264SEIPictureTiming *pt = &h->sei.picture_timing;\n<28> \n<29> switch (pt->pic_struct) {\n<30> \n<31> case SEI_PIC_STRUCT_FRAME:\n<32> \n<33> break;\n<34> \n<35> case SEI_PIC_STRUCT_TOP_FIELD:\n<36> \n<37> case SEI_PIC_STRUCT_BOTTOM_FIELD:\n<38> \n<39> cur->f->interlaced_frame = 1;\n<40> \n<41> break;\n<42> \n<43> case SEI_PIC_STRUCT_TOP_BOTTOM:\n<44> \n<45> case SEI_PIC_STRUCT_BOTTOM_TOP:\n<46> \n<47> if (FIELD_OR_MBAFF_PICTURE(h))\n<48> \n<49> cur->f->interlaced_frame = 1;\n<50> \n<51> else\n<52> \n<53> // try to flag soft telecine progressive\n<54> \n<55> cur->f->interlaced_frame = h->prev_interlaced_frame;\n<56> \n<57> break;\n<58> \n<59> case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n<60> \n<61> case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n<62> \n<63> /* Signal the possibility of telecined film externally\n<64> \n<65> * (pic_struct 5,6). From these hints, let the applications\n<66> \n<67> * decide if they apply deinterlacing. */\n<68> \n<69> cur->f->repeat_pict = 1;\n<70> \n<71> break;\n<72> \n<73> case SEI_PIC_STRUCT_FRAME_DOUBLING:\n<74> \n<75> cur->f->repeat_pict = 2;\n<76> \n<77> break;\n<78> \n<79> case SEI_PIC_STRUCT_FRAME_TRIPLING:\n<80> \n<81> cur->f->repeat_pict = 4;\n<82> \n<83> break;\n<84> \n<85> }\n<86> \n<87> \n<88> \n<89> if ((pt->ct_type & 3) &&\n<90> \n<91> pt->pic_struct <= SEI_PIC_STRUCT_BOTTOM_TOP)\n<92> \n<93> cur->f->interlaced_frame = (pt->ct_type & (1 << 1)) != 0;\n<94> \n<95> } else {\n<96> \n<97> /* Derive interlacing flag from used decoding process. */\n<98> \n<99> cur->f->interlaced_frame = FIELD_OR_MBAFF_PICTURE(h);\n<100> \n<101> }\n<102> \n<103> h->prev_interlaced_frame = cur->f->interlaced_frame;\n<104> \n<105> \n<106> \n<107> if (cur->field_poc[0] != cur->field_poc[1]) {\n<108> \n<109> /* Derive top_field_first from field pocs. */\n<110> \n<111> cur->f->top_field_first = cur->field_poc[0] < cur->field_poc[1];\n<112> \n<113> } else {\n<114> \n<115> if (cur->f->interlaced_frame || sps->pic_struct_present_flag) {\n<116> \n<117> /* Use picture timing SEI information. Even if it is a\n<118> \n<119> * information of a past frame, better than nothing. */\n<120> \n<121> if (h->sei.picture_timing.pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM ||\n<122> \n<123> h->sei.picture_timing.pic_struct == SEI_PIC_STRUCT_TOP_BOTTOM_TOP)\n<124> \n<125> cur->f->top_field_first = 1;\n<126> \n<127> else\n<128> \n<129> cur->f->top_field_first = 0;\n<130> \n<131> } else {\n<132> \n<133> /* Most likely progressive */\n<134> \n<135> cur->f->top_field_first = 0;\n<136> \n<137> }\n<138> \n<139> }\n<140> \n<141> \n<142> \n<143> if (h->sei.frame_packing.present &&\n<144> \n<145> h->sei.frame_packing.arrangement_type >= 0 &&\n<146> \n<147> h->sei.frame_packing.arrangement_type <= 6 &&\n<148> \n<149> h->sei.frame_packing.content_interpretation_type > 0 &&\n<150> \n<151> h->sei.frame_packing.content_interpretation_type < 3) {\n<152> \n<153> H264SEIFramePacking *fp = &h->sei.frame_packing;\n<154> \n<155> AVStereo3D *stereo = av_stereo3d_create_side_data(cur->f);\n<156> \n<157> if (!stereo)\n<158> \n<159> return AVERROR(ENOMEM);\n<160> \n<161> \n<162> \n<163> switch (fp->arrangement_type) {\n<164> \n<165> case 0:\n<166> \n<167> stereo->type = AV_STEREO3D_CHECKERBOARD;\n<168> \n<169> break;\n<170> \n<171> case 1:\n<172> \n<173> stereo->type = AV_STEREO3D_COLUMNS;\n<174> \n<175> break;\n<176> \n<177> case 2:\n<178> \n<179> stereo->type = AV_STEREO3D_LINES;\n<180> \n<181> break;\n<182> \n<183> case 3:\n<184> \n<185> if (fp->quincunx_subsampling)\n<186> \n<187> stereo->type = AV_STEREO3D_SIDEBYSIDE_QUINCUNX;\n<188> \n<189> else\n<190> \n<191> stereo->type = AV_STEREO3D_SIDEBYSIDE;\n<192> \n<193> break;\n<194> \n<195> case 4:\n<196> \n<197> stereo->type = AV_STEREO3D_TOPBOTTOM;\n<198> \n<199> break;\n<200> \n<201> case 5:\n<202> \n<203> stereo->type = AV_STEREO3D_FRAMESEQUENCE;\n<204> \n<205> break;\n<206> \n<207> case 6:\n<208> \n<209> stereo->type = AV_STEREO3D_2D;\n<210> \n<211> break;\n<212> \n<213> }\n<214> \n<215> \n<216> \n<217> if (fp->content_interpretation_type == 2)\n<218> \n<219> stereo->flags = AV_STEREO3D_FLAG_INVERT;\n<220> \n<221> }\n<222> \n<223> \n<224> \n<225> if (h->sei.display_orientation.present &&\n<226> \n<227> (h->sei.display_orientation.anticlockwise_rotation ||\n<228> \n<229> h->sei.display_orientation.hflip ||\n<230> \n<231> h->sei.display_orientation.vflip)) {\n<232> \n<233> H264SEIDisplayOrientation *o = &h->sei.display_orientation;\n<234> \n<235> double angle = o->anticlockwise_rotation * 360 / (double) (1 << 16);\n<236> \n<237> AVFrameSideData *rotation = av_frame_new_side_data(cur->f,\n<238> \n<239> AV_FRAME_DATA_DISPLAYMATRIX,\n<240> \n<241> sizeof(int32_t) * 9);\n<242> \n<243> if (!rotation)\n<244> \n<245> return AVERROR(ENOMEM);\n<246> \n<247> \n<248> \n<249> av_display_rotation_set((int32_t *)rotation->data, angle);\n<250> \n<251> av_display_matrix_flip((int32_t *)rotation->data,\n<252> \n<253> o->hflip, o->vflip);\n<254> \n<255> }\n<256> \n<257> \n<258> \n<259> if (h->sei.afd.present) {\n<260> \n<261> AVFrameSideData *sd = av_frame_new_side_data(cur->f, AV_FRAME_DATA_AFD,\n<262> \n<263> sizeof(uint8_t));\n<264> \n<265> if (!sd)\n<266> \n<267> return AVERROR(ENOMEM);\n<268> \n<269> \n<270> \n<271> *sd->data = h->sei.afd.active_format_description;\n<272> \n<273> h->sei.afd.present = 0;\n<274> \n<275> }\n<276> \n<277> \n<278> \n<279> if (h->sei.a53_caption.a53_caption) {\n<280> \n<281> H264SEIA53Caption *a53 = &h->sei.a53_caption;\n<282> \n<283> AVFrameSideData *sd = av_frame_new_side_data(cur->f,\n<284> \n<285> AV_FRAME_DATA_A53_CC,\n<286> \n<287> a53->a53_caption_size);\n<288> \n<289> if (!sd)\n<290> \n<291> return AVERROR(ENOMEM);\n<292> \n<293> \n<294> \n<295> memcpy(sd->data, a53->a53_caption, a53->a53_caption_size);\n<296> \n<297> av_freep(&a53->a53_caption);\n<298> \n<299> a53->a53_caption_size = 0;\n<300> \n<301> }\n<302> \n<303> \n<304> \n<305> return 0;\n<306> \n<307> }\n<308> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> envlist_free(envlist_t *envlist)\n<2> \n<3> {\n<4> \n<5> struct envlist_entry *entry;\n<6> \n<7> \n<8> \n<9> assert(envlist != NULL);\n<10> \n<11> \n<12> \n<13> while (envlist->el_entries.lh_first != NULL) {\n<14> \n<15> entry = envlist->el_entries.lh_first;\n<16> \n<17> LIST_REMOVE(entry, ev_link);\n<18> \n<19> \n<20> \n<21> free((char *)entry->ev_var);\n<22> \n<23> free(entry);\n<24> \n<25> }\n<26> \n<27> free(envlist);\n<28> \n<29> }\n<30> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void usb_host_handle_control(USBDevice *udev, USBPacket *p,\n<2> \n<3> int request, int value, int index,\n<4> \n<5> int length, uint8_t *data)\n<6> \n<7> {\n<8> \n<9> USBHostDevice *s = USB_HOST_DEVICE(udev);\n<10> \n<11> USBHostRequest *r;\n<12> \n<13> int rc;\n<14> \n<15> \n<16> \n<17> trace_usb_host_req_control(s->bus_num, s->addr, p, request, value, index);\n<18> \n<19> \n<20> \n<21> if (s->dh == NULL) {\n<22> \n<23> p->status = USB_RET_NODEV;\n<24> \n<25> trace_usb_host_req_emulated(s->bus_num, s->addr, p, p->status);\n<26> \n<27> return;\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> switch (request) {\n<34> \n<35> case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n<36> \n<37> usb_host_set_address(s, value);\n<38> \n<39> trace_usb_host_req_emulated(s->bus_num, s->addr, p, p->status);\n<40> \n<41> return;\n<42> \n<43> \n<44> \n<45> case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n<46> \n<47> usb_host_set_config(s, value & 0xff, p);\n<48> \n<49> trace_usb_host_req_emulated(s->bus_num, s->addr, p, p->status);\n<50> \n<51> return;\n<52> \n<53> \n<54> \n<55> case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n<56> \n<57> usb_host_set_interface(s, index, value, p);\n<58> \n<59> trace_usb_host_req_emulated(s->bus_num, s->addr, p, p->status);\n<60> \n<61> return;\n<62> \n<63> \n<64> \n<65> case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n<66> \n<67> if (value == 0) { /* clear halt */\n<68> \n<69> int pid = (index & USB_DIR_IN) ? USB_TOKEN_IN : USB_TOKEN_OUT;\n<70> \n<71> libusb_clear_halt(s->dh, index);\n<72> \n<73> usb_ep_set_halted(udev, pid, index & 0x0f, 0);\n<74> \n<75> trace_usb_host_req_emulated(s->bus_num, s->addr, p, p->status);\n<76> \n<77> return;\n<78> \n<79> }\n<80> \n<81> }\n<82> \n<83> \n<84> \n<85> r = usb_host_req_alloc(s, p, (request >> 8) & USB_DIR_IN, length + 8);\n<86> \n<87> r->cbuf = data;\n<88> \n<89> r->clen = length;\n<90> \n<91> memcpy(r->buffer, udev->setup_buf, 8);\n<92> \n<93> if (!r->in) {\n<94> \n<95> memcpy(r->buffer + 8, r->cbuf, r->clen);\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> /* Fix up USB-3 ep0 maxpacket size to allow superspeed connected devices\n<102> \n<103> * to work redirected to a not superspeed capable hcd */\n<104> \n<105> if (udev->speed == USB_SPEED_SUPER &&\n<106> \n<107> !(udev->port->speedmask & USB_SPEED_MASK_SUPER) &&\n<108> \n<109> request == 0x8006 && value == 0x100 && index == 0) {\n<110> \n<111> r->usb3ep0quirk = true;\n<112> \n<113> }\n<114> \n<115> \n<116> \n<117> libusb_fill_control_transfer(r->xfer, s->dh, r->buffer,\n<118> \n<119> usb_host_req_complete_ctrl, r,\n<120> \n<121> CONTROL_TIMEOUT);\n<122> \n<123> rc = libusb_submit_transfer(r->xfer);\n<124> \n<125> if (rc != 0) {\n<126> \n<127> p->status = USB_RET_NODEV;\n<128> \n<129> trace_usb_host_req_complete(s->bus_num, s->addr, p,\n<130> \n<131> p->status, p->actual_length);\n<132> \n<133> if (rc == LIBUSB_ERROR_NO_DEVICE) {\n<134> \n<135> usb_host_nodev(s);\n<136> \n<137> }\n<138> \n<139> return;\n<140> \n<141> }\n<142> \n<143> \n<144> \n<145> p->status = USB_RET_ASYNC;\n<146> \n<147> }\n<148> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int select_input_picture ( MpegEncContext * s ) {\n<2> int i ;\n<3> for ( i = 1 ;\n<4> i < MAX_PICTURE_COUNT ;\n<5> i ++ ) s -> reordered_input_picture [ i - 1 ] = s -> reordered_input_picture [ i ] ;\n<6> s -> reordered_input_picture [ MAX_PICTURE_COUNT - 1 ] = NULL ;\n<7> if ( s -> reordered_input_picture [ 0 ] == NULL && s -> input_picture [ 0 ] ) {\n<8> if ( s -> next_picture_ptr == NULL || s -> intra_only ) {\n<9> s -> reordered_input_picture [ 0 ] = s -> input_picture [ 0 ] ;\n<10> s -> reordered_input_picture [ 0 ] -> f . pict_type = AV_PICTURE_TYPE_I ;\n<11> s -> reordered_input_picture [ 0 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n<12> }\n<13> else {\n<14> int b_frames ;\n<15> if ( s -> avctx -> frame_skip_threshold || s -> avctx -> frame_skip_factor ) {\n<16> if ( s -> picture_in_gop_number < s -> gop_size && skip_check ( s , s -> input_picture [ 0 ] , s -> next_picture_ptr ) ) {\n<17> if ( s -> input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_SHARED ) {\n<18> for ( i = 0 ;\n<19> i < 4 ;\n<20> i ++ ) s -> input_picture [ 0 ] -> f . data [ i ] = NULL ;\n<21> s -> input_picture [ 0 ] -> f . type = 0 ;\n<22> }\n<23> else {\n<24> assert ( s -> input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_USER || s -> input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_INTERNAL ) ;\n<25> s -> avctx -> release_buffer ( s -> avctx , & s -> input_picture [ 0 ] -> f ) ;\n<26> }\n<27> emms_c ( ) ;\n<28> ff_vbv_update ( s , 0 ) ;\n<29> goto no_output_pic ;\n<30> }\n<31> }\n<32> if ( s -> flags & CODEC_FLAG_PASS2 ) {\n<33> for ( i = 0 ;\n<34> i < s -> max_b_frames + 1 ;\n<35> i ++ ) {\n<36> int pict_num = s -> input_picture [ 0 ] -> f . display_picture_number + i ;\n<37> if ( pict_num >= s -> rc_context . num_entries ) break ;\n<38> if ( ! s -> input_picture [ i ] ) {\n<39> s -> rc_context . entry [ pict_num - 1 ] . new_pict_type = AV_PICTURE_TYPE_P ;\n<40> break ;\n<41> }\n<42> s -> input_picture [ i ] -> f . pict_type = s -> rc_context . entry [ pict_num ] . new_pict_type ;\n<43> }\n<44> }\n<45> if ( s -> avctx -> b_frame_strategy == 0 ) {\n<46> b_frames = s -> max_b_frames ;\n<47> while ( b_frames && ! s -> input_picture [ b_frames ] ) b_frames -- ;\n<48> }\n<49> else if ( s -> avctx -> b_frame_strategy == 1 ) {\n<50> for ( i = 1 ;\n<51> i < s -> max_b_frames + 1 ;\n<52> i ++ ) {\n<53> if ( s -> input_picture [ i ] && s -> input_picture [ i ] -> b_frame_score == 0 ) {\n<54> s -> input_picture [ i ] -> b_frame_score = get_intra_count ( s , s -> input_picture [ i ] -> f . data [ 0 ] , s -> input_picture [ i - 1 ] -> f . data [ 0 ] , s -> linesize ) + 1 ;\n<55> }\n<56> }\n<57> for ( i = 0 ;\n<58> i < s -> max_b_frames + 1 ;\n<59> i ++ ) {\n<60> if ( s -> input_picture [ i ] == NULL || s -> input_picture [ i ] -> b_frame_score - 1 > s -> mb_num / s -> avctx -> b_sensitivity ) break ;\n<61> }\n<62> b_frames = FFMAX ( 0 , i - 1 ) ;\n<63> for ( i = 0 ;\n<64> i < b_frames + 1 ;\n<65> i ++ ) {\n<66> s -> input_picture [ i ] -> b_frame_score = 0 ;\n<67> }\n<68> }\n<69> else if ( s -> avctx -> b_frame_strategy == 2 ) {\n<70> b_frames = estimate_best_b_count ( s ) ;\n<71> }\n<72> else {\n<73> av_log ( s -> avctx , AV_LOG_ERROR , "illegal b frame strategy\n" ) ;\n<74> b_frames = 0 ;\n<75> }\n<76> emms_c ( ) ;\n<77> for ( i = b_frames - 1 ;\n<78> i >= 0 ;\n<79> i -- ) {\n<80> int type = s -> input_picture [ i ] -> f . pict_type ;\n<81> if ( type && type != AV_PICTURE_TYPE_B ) b_frames = i ;\n<82> }\n<83> if ( s -> input_picture [ b_frames ] -> f . pict_type == AV_PICTURE_TYPE_B && b_frames == s -> max_b_frames ) {\n<84> av_log ( s -> avctx , AV_LOG_ERROR , "warning, too many b frames in a row\n" ) ;\n<85> }\n<86> if ( s -> picture_in_gop_number + b_frames >= s -> gop_size ) {\n<87> if ( ( s -> mpv_flags & FF_MPV_FLAG_STRICT_GOP ) && s -> gop_size > s -> picture_in_gop_number ) {\n<88> b_frames = s -> gop_size - s -> picture_in_gop_number - 1 ;\n<89> }\n<90> else {\n<91> if ( s -> flags & CODEC_FLAG_CLOSED_GOP ) b_frames = 0 ;\n<92> s -> input_picture [ b_frames ] -> f . pict_type = AV_PICTURE_TYPE_I ;\n<93> }\n<94> }\n<95> if ( ( s -> flags & CODEC_FLAG_CLOSED_GOP ) && b_frames && s -> input_picture [ b_frames ] -> f . pict_type == AV_PICTURE_TYPE_I ) b_frames -- ;\n<96> s -> reordered_input_picture [ 0 ] = s -> input_picture [ b_frames ] ;\n<97> if ( s -> reordered_input_picture [ 0 ] -> f . pict_type != AV_PICTURE_TYPE_I ) s -> reordered_input_picture [ 0 ] -> f . pict_type = AV_PICTURE_TYPE_P ;\n<98> s -> reordered_input_picture [ 0 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n<99> for ( i = 0 ;\n<100> i < b_frames ;\n<101> i ++ ) {\n<102> s -> reordered_input_picture [ i + 1 ] = s -> input_picture [ i ] ;\n<103> s -> reordered_input_picture [ i + 1 ] -> f . pict_type = AV_PICTURE_TYPE_B ;\n<104> s -> reordered_input_picture [ i + 1 ] -> f . coded_picture_number = s -> coded_picture_number ++ ;\n<105> }\n<106> }\n<107> }\n<108> no_output_pic : if ( s -> reordered_input_picture [ 0 ] ) {\n<109> s -> reordered_input_picture [ 0 ] -> f . reference = s -> reordered_input_picture [ 0 ] -> f . pict_type != AV_PICTURE_TYPE_B ? 3 : 0 ;\n<110> ff_copy_picture ( & s -> new_picture , s -> reordered_input_picture [ 0 ] ) ;\n<111> if ( s -> reordered_input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_SHARED || s -> avctx -> rc_buffer_size ) {\n<112> Picture * pic ;\n<113> int i = ff_find_unused_picture ( s , 0 ) ;\n<114> if ( i < 0 ) return i ;\n<115> pic = & s -> picture [ i ] ;\n<116> pic -> f . reference = s -> reordered_input_picture [ 0 ] -> f . reference ;\n<117> if ( ff_alloc_picture ( s , pic , 0 ) < 0 ) {\n<118> return - 1 ;\n<119> }\n<120> if ( s -> reordered_input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_INTERNAL ) s -> avctx -> release_buffer ( s -> avctx , & s -> reordered_input_picture [ 0 ] -> f ) ;\n<121> for ( i = 0 ;\n<122> i < 4 ;\n<123> i ++ ) s -> reordered_input_picture [ 0 ] -> f . data [ i ] = NULL ;\n<124> s -> reordered_input_picture [ 0 ] -> f . type = 0 ;\n<125> copy_picture_attributes ( s , & pic -> f , & s -> reordered_input_picture [ 0 ] -> f ) ;\n<126> s -> current_picture_ptr = pic ;\n<127> }\n<128> else {\n<129> assert ( s -> reordered_input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_USER || s -> reordered_input_picture [ 0 ] -> f . type == FF_BUFFER_TYPE_INTERNAL ) ;\n<130> s -> current_picture_ptr = s -> reordered_input_picture [ 0 ] ;\n<131> for ( i = 0 ;\n<132> i < 4 ;\n<133> i ++ ) {\n<134> s -> new_picture . f . data [ i ] += INPLACE_OFFSET ;\n<135> }\n<136> }\n<137> ff_copy_picture ( & s -> current_picture , s -> current_picture_ptr ) ;\n<138> s -> picture_number = s -> new_picture . f . display_picture_number ;\n<139> }\n<140> else {\n<141> memset ( & s -> new_picture , 0 , sizeof ( Picture ) ) ;\n<142> }\n<143> return 0 ;\n<144> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_rate_control_init(MpegEncContext *s)\n<2> \n<3> {\n<4> \n<5> RateControlContext *rcc= &s->rc_context;\n<6> \n<7> int i;\n<8> \n<9> char *error = NULL;\n<10> \n<11> static const char *const_names[]={\n<12> \n<13> "PI",\n<14> \n<15> "E",\n<16> \n<17> "iTex",\n<18> \n<19> "pTex",\n<20> \n<21> "tex",\n<22> \n<23> "mv",\n<24> \n<25> "fCode",\n<26> \n<27> "iCount",\n<28> \n<29> "mcVar",\n<30> \n<31> "var",\n<32> \n<33> "isI",\n<34> \n<35> "isP",\n<36> \n<37> "isB",\n<38> \n<39> "avgQP",\n<40> \n<41> "qComp",\n<42> \n<43> /*        "lastIQP",\n<44> \n<45> "lastPQP",\n<46> \n<47> "lastBQP",\n<48> \n<49> "nextNonBQP",*/\n<50> \n<51> "avgIITex",\n<52> \n<53> "avgPITex",\n<54> \n<55> "avgPPTex",\n<56> \n<57> "avgBPTex",\n<58> \n<59> "avgTex",\n<60> \n<61> NULL\n<62> \n<63> };\n<64> \n<65> static double (*func1[])(void *, double)={\n<66> \n<67> (void *)bits2qp,\n<68> \n<69> (void *)qp2bits,\n<70> \n<71> NULL\n<72> \n<73> };\n<74> \n<75> static const char *func1_names[]={\n<76> \n<77> "bits2qp",\n<78> \n<79> "qp2bits",\n<80> \n<81> NULL\n<82> \n<83> };\n<84> \n<85> emms_c();\n<86> \n<87> \n<88> \n<89> rcc->rc_eq_eval = ff_parse(s->avctx->rc_eq, const_names, func1, func1_names, NULL, NULL, &error);\n<90> \n<91> if (!rcc->rc_eq_eval) {\n<92> \n<93> av_log(s->avctx, AV_LOG_ERROR, "Error parsing rc_eq \"%s\": %s\n", s->avctx->rc_eq, error? error : "");\n<94> \n<95> return -1;\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> for(i=0; i<5; i++){\n<102> \n<103> rcc->pred[i].coeff= FF_QP2LAMBDA * 7.0;\n<104> \n<105> rcc->pred[i].count= 1.0;\n<106> \n<107> \n<108> \n<109> rcc->pred[i].decay= 0.4;\n<110> \n<111> rcc->i_cplx_sum [i]=\n<112> \n<113> rcc->p_cplx_sum [i]=\n<114> \n<115> rcc->mv_bits_sum[i]=\n<116> \n<117> rcc->qscale_sum [i]=\n<118> \n<119> rcc->frame_count[i]= 1; // 1 is better cuz of 1/0 and such\n<120> \n<121> rcc->last_qscale_for[i]=FF_QP2LAMBDA * 5;\n<122> \n<123> }\n<124> \n<125> rcc->buffer_index= s->avctx->rc_initial_buffer_occupancy;\n<126> \n<127> \n<128> \n<129> if(s->flags&CODEC_FLAG_PASS2){\n<130> \n<131> int i;\n<132> \n<133> char *p;\n<134> \n<135> \n<136> \n<137> /* find number of pics */\n<138> \n<139> p= s->avctx->stats_in;\n<140> \n<141> for(i=-1; p; i++){\n<142> \n<143> p= strchr(p+1, ';');\n<144> \n<145> }\n<146> \n<147> i+= s->max_b_frames;\n<148> \n<149> if(i<=0 || i>=INT_MAX / sizeof(RateControlEntry))\n<150> \n<151> return -1;\n<152> \n<153> rcc->entry = (RateControlEntry*)av_mallocz(i*sizeof(RateControlEntry));\n<154> \n<155> rcc->num_entries= i;\n<156> \n<157> \n<158> \n<159> /* init all to skipped p frames (with b frames we might have a not encoded frame at the end FIXME) */\n<160> \n<161> for(i=0; i<rcc->num_entries; i++){\n<162> \n<163> RateControlEntry *rce= &rcc->entry[i];\n<164> \n<165> rce->pict_type= rce->new_pict_type=P_TYPE;\n<166> \n<167> rce->qscale= rce->new_qscale=FF_QP2LAMBDA * 2;\n<168> \n<169> rce->misc_bits= s->mb_num + 10;\n<170> \n<171> rce->mb_var_sum= s->mb_num*100;\n<172> \n<173> }\n<174> \n<175> \n<176> \n<177> /* read stats */\n<178> \n<179> p= s->avctx->stats_in;\n<180> \n<181> for(i=0; i<rcc->num_entries - s->max_b_frames; i++){\n<182> \n<183> RateControlEntry *rce;\n<184> \n<185> int picture_number;\n<186> \n<187> int e;\n<188> \n<189> char *next;\n<190> \n<191> \n<192> \n<193> next= strchr(p, ';');\n<194> \n<195> if(next){\n<196> \n<197> (*next)=0; //sscanf in unbelievably slow on looong strings //FIXME copy / do not write\n<198> \n<199> next++;\n<200> \n<201> }\n<202> \n<203> e= sscanf(p, " in:%d ", &picture_number);\n<204> \n<205> \n<206> \n<207> assert(picture_number >= 0);\n<208> \n<209> assert(picture_number < rcc->num_entries);\n<210> \n<211> rce= &rcc->entry[picture_number];\n<212> \n<213> \n<214> \n<215> e+=sscanf(p, " in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d",\n<216> \n<217> &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits, &rce->mv_bits, &rce->misc_bits,\n<218> \n<219> &rce->f_code, &rce->b_code, &rce->mc_mb_var_sum, &rce->mb_var_sum, &rce->i_count, &rce->skip_count, &rce->header_bits);\n<220> \n<221> if(e!=14){\n<222> \n<223> av_log(s->avctx, AV_LOG_ERROR, "statistics are damaged at line %d, parser out=%d\n", i, e);\n<224> \n<225> return -1;\n<226> \n<227> }\n<228> \n<229> \n<230> \n<231> p= next;\n<232> \n<233> }\n<234> \n<235> \n<236> \n<237> if(init_pass2(s) < 0) return -1;\n<238> \n<239> \n<240> \n<241> //FIXME maybe move to end\n<242> \n<243> if((s->flags&CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) {\n<244> \n<245> #ifdef CONFIG_LIBXVID\n<246> \n<247> return ff_xvid_rate_control_init(s);\n<248> \n<249> #else\n<250> \n<251> av_log(s->avctx, AV_LOG_ERROR, "XviD ratecontrol requires libavcodec compiled with XviD support\n");\n<252> \n<253> return -1;\n<254> \n<255> #endif\n<256> \n<257> }\n<258> \n<259> }\n<260> \n<261> \n<262> \n<263> if(!(s->flags&CODEC_FLAG_PASS2)){\n<264> \n<265> \n<266> \n<267> rcc->short_term_qsum=0.001;\n<268> \n<269> rcc->short_term_qcount=0.001;\n<270> \n<271> \n<272> \n<273> rcc->pass1_rc_eq_output_sum= 0.001;\n<274> \n<275> rcc->pass1_wanted_bits=0.001;\n<276> \n<277> \n<278> \n<279> if(s->avctx->qblur > 1.0){\n<280> \n<281> av_log(s->avctx, AV_LOG_ERROR, "qblur too large\n");\n<282> \n<283> return -1;\n<284> \n<285> }\n<286> \n<287> /* init stuff with the user specified complexity */\n<288> \n<289> if(s->avctx->rc_initial_cplx){\n<290> \n<291> for(i=0; i<60*30; i++){\n<292> \n<293> double bits= s->avctx->rc_initial_cplx * (i/10000.0 + 1.0)*s->mb_num;\n<294> \n<295> RateControlEntry rce;\n<296> \n<297> double q;\n<298> \n<299> \n<300> \n<301> if     (i%((s->gop_size+3)/4)==0) rce.pict_type= I_TYPE;\n<302> \n<303> else if(i%(s->max_b_frames+1))    rce.pict_type= B_TYPE;\n<304> \n<305> else                              rce.pict_type= P_TYPE;\n<306> \n<307> \n<308> \n<309> rce.new_pict_type= rce.pict_type;\n<310> \n<311> rce.mc_mb_var_sum= bits*s->mb_num/100000;\n<312> \n<313> rce.mb_var_sum   = s->mb_num;\n<314> \n<315> rce.qscale   = FF_QP2LAMBDA * 2;\n<316> \n<317> rce.f_code   = 2;\n<318> \n<319> rce.b_code   = 1;\n<320> \n<321> rce.misc_bits= 1;\n<322> \n<323> \n<324> \n<325> if(s->pict_type== I_TYPE){\n<326> \n<327> rce.i_count   = s->mb_num;\n<328> \n<329> rce.i_tex_bits= bits;\n<330> \n<331> rce.p_tex_bits= 0;\n<332> \n<333> rce.mv_bits= 0;\n<334> \n<335> }else{\n<336> \n<337> rce.i_count   = 0; //FIXME we do know this approx\n<338> \n<339> rce.i_tex_bits= 0;\n<340> \n<341> rce.p_tex_bits= bits*0.9;\n<342> \n<343> rce.mv_bits= bits*0.1;\n<344> \n<345> }\n<346> \n<347> rcc->i_cplx_sum [rce.pict_type] += rce.i_tex_bits*rce.qscale;\n<348> \n<349> rcc->p_cplx_sum [rce.pict_type] += rce.p_tex_bits*rce.qscale;\n<350> \n<351> rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits;\n<352> \n<353> rcc->frame_count[rce.pict_type] ++;\n<354> \n<355> \n<356> \n<357> bits= rce.i_tex_bits + rce.p_tex_bits;\n<358> \n<359> \n<360> \n<361> q= get_qscale(s, &rce, rcc->pass1_wanted_bits/rcc->pass1_rc_eq_output_sum, i);\n<362> \n<363> rcc->pass1_wanted_bits+= s->bit_rate/(1/av_q2d(s->avctx->time_base)); //FIXME misbehaves a little for variable fps\n<364> \n<365> }\n<366> \n<367> }\n<368> \n<369> \n<370> \n<371> }\n<372> \n<373> \n<374> \n<375> return 0;\n<376> \n<377> }\n<378> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int nprobe(AVFormatContext *s, uint8_t *enc_header, int size, const uint8_t *n_val)\n<2> \n<3> {\n<4> \n<5> OMAContext *oc = s->priv_data;\n<6> \n<7> uint32_t pos, taglen, datalen;\n<8> \n<9> struct AVDES av_des;\n<10> \n<11> \n<12> \n<13> if (!enc_header || !n_val)\n<14> \n<15> return -1;\n<16> \n<17> \n<18> \n<19> pos = OMA_ENC_HEADER_SIZE + oc->k_size;\n<20> \n<21> if (!memcmp(&enc_header[pos], "EKB ", 4))\n<22> \n<23> pos += 32;\n<24> \n<25> \n<26> \n<27> if (AV_RB32(&enc_header[pos]) != oc->rid)\n<28> \n<29> av_log(s, AV_LOG_DEBUG, "Mismatching RID\n");\n<30> \n<31> \n<32> \n<33> taglen = AV_RB32(&enc_header[pos+32]);\n<34> \n<35> datalen = AV_RB32(&enc_header[pos+36]) >> 4;\n<36> \n<37> \n<38> \n<39> if(taglen + (((uint64_t)datalen)<<4) + 44 > size)\n<40> \n<41> return -1;\n<42> \n<43> \n<44> \n<45> pos += 44 + taglen;\n<46> \n<47> \n<48> \n<49> av_des_init(&av_des, n_val, 192, 1);\n<50> \n<51> while (datalen-- > 0) {\n<52> \n<53> av_des_crypt(&av_des, oc->r_val, &enc_header[pos], 2, NULL, 1);\n<54> \n<55> kset(s, oc->r_val, NULL, 16);\n<56> \n<57> if (!rprobe(s, enc_header, oc->r_val))\n<58> \n<59> return 0;\n<60> \n<61> pos += 16;\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> return -1;\n<68> \n<69> }\n<70> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int decode_frame(AVCodecContext *avctx, void *data,\n<2> \n<3> int *got_frame, AVPacket *avpkt)\n<4> \n<5> {\n<6> \n<7> const uint8_t *buf = avpkt->data;\n<8> \n<9> int buf_size = avpkt->size;\n<10> \n<11> C93DecoderContext * const c93 = avctx->priv_data;\n<12> \n<13> AVFrame * const newpic = &c93->pictures[c93->currentpic];\n<14> \n<15> AVFrame * const oldpic = &c93->pictures[c93->currentpic^1];\n<16> \n<17> GetByteContext gb;\n<18> \n<19> uint8_t *out;\n<20> \n<21> int stride, ret, i, x, y, b, bt = 0;\n<22> \n<23> \n<24> \n<25> c93->currentpic ^= 1;\n<26> \n<27> \n<28> \n<29> if ((ret = ff_reget_buffer(avctx, newpic)) < 0)\n<30> \n<31> return ret;\n<32> \n<33> \n<34> \n<35> stride = newpic->linesize[0];\n<36> \n<37> \n<38> \n<39> bytestream2_init(&gb, buf, buf_size);\n<40> \n<41> b = bytestream2_get_byte(&gb);\n<42> \n<43> if (b & C93_FIRST_FRAME) {\n<44> \n<45> newpic->pict_type = AV_PICTURE_TYPE_I;\n<46> \n<47> newpic->key_frame = 1;\n<48> \n<49> } else {\n<50> \n<51> newpic->pict_type = AV_PICTURE_TYPE_P;\n<52> \n<53> newpic->key_frame = 0;\n<54> \n<55> }\n<56> \n<57> \n<58> \n<59> for (y = 0; y < HEIGHT; y += 8) {\n<60> \n<61> out = newpic->data[0] + y * stride;\n<62> \n<63> for (x = 0; x < WIDTH; x += 8) {\n<64> \n<65> uint8_t *copy_from = oldpic->data[0];\n<66> \n<67> unsigned int offset, j;\n<68> \n<69> uint8_t cols[4], grps[4];\n<70> \n<71> C93BlockType block_type;\n<72> \n<73> \n<74> \n<75> if (!bt)\n<76> \n<77> bt = bytestream2_get_byte(&gb);\n<78> \n<79> \n<80> \n<81> block_type= bt & 0x0F;\n<82> \n<83> switch (block_type) {\n<84> \n<85> case C93_8X8_FROM_PREV:\n<86> \n<87> offset = bytestream2_get_le16(&gb);\n<88> \n<89> if ((ret = copy_block(avctx, out, copy_from, offset, 8, stride)) < 0)\n<90> \n<91> return ret;\n<92> \n<93> break;\n<94> \n<95> \n<96> \n<97> case C93_4X4_FROM_CURR:\n<98> \n<99> copy_from = newpic->data[0];\n<100> \n<101> case C93_4X4_FROM_PREV:\n<102> \n<103> for (j = 0; j < 8; j += 4) {\n<104> \n<105> for (i = 0; i < 8; i += 4) {\n<106> \n<107> offset = bytestream2_get_le16(&gb);\n<108> \n<109> if ((ret = copy_block(avctx, &out[j*stride+i],\n<110> \n<111> copy_from, offset, 4, stride)) < 0)\n<112> \n<113> return ret;\n<114> \n<115> }\n<116> \n<117> }\n<118> \n<119> break;\n<120> \n<121> \n<122> \n<123> case C93_8X8_2COLOR:\n<124> \n<125> bytestream2_get_buffer(&gb, cols, 2);\n<126> \n<127> for (i = 0; i < 8; i++) {\n<128> \n<129> draw_n_color(out + i*stride, stride, 8, 1, 1, cols,\n<130> \n<131> NULL, bytestream2_get_byte(&gb));\n<132> \n<133> }\n<134> \n<135> \n<136> \n<137> break;\n<138> \n<139> \n<140> \n<141> case C93_4X4_2COLOR:\n<142> \n<143> case C93_4X4_4COLOR:\n<144> \n<145> case C93_4X4_4COLOR_GRP:\n<146> \n<147> for (j = 0; j < 8; j += 4) {\n<148> \n<149> for (i = 0; i < 8; i += 4) {\n<150> \n<151> if (block_type == C93_4X4_2COLOR) {\n<152> \n<153> bytestream2_get_buffer(&gb, cols, 2);\n<154> \n<155> draw_n_color(out + i + j*stride, stride, 4, 4,\n<156> \n<157> 1, cols, NULL, bytestream2_get_le16(&gb));\n<158> \n<159> } else if (block_type == C93_4X4_4COLOR) {\n<160> \n<161> bytestream2_get_buffer(&gb, cols, 4);\n<162> \n<163> draw_n_color(out + i + j*stride, stride, 4, 4,\n<164> \n<165> 2, cols, NULL, bytestream2_get_le32(&gb));\n<166> \n<167> } else {\n<168> \n<169> bytestream2_get_buffer(&gb, grps, 4);\n<170> \n<171> draw_n_color(out + i + j*stride, stride, 4, 4,\n<172> \n<173> 1, cols, grps, bytestream2_get_le16(&gb));\n<174> \n<175> }\n<176> \n<177> }\n<178> \n<179> }\n<180> \n<181> break;\n<182> \n<183> \n<184> \n<185> case C93_NOOP:\n<186> \n<187> break;\n<188> \n<189> \n<190> \n<191> case C93_8X8_INTRA:\n<192> \n<193> for (j = 0; j < 8; j++)\n<194> \n<195> bytestream2_get_buffer(&gb, out + j*stride, 8);\n<196> \n<197> break;\n<198> \n<199> \n<200> \n<201> default:\n<202> \n<203> av_log(avctx, AV_LOG_ERROR, "unexpected type %x at %dx%d\n",\n<204> \n<205> block_type, x, y);\n<206> \n<207> return AVERROR_INVALIDDATA;\n<208> \n<209> }\n<210> \n<211> bt >>= 4;\n<212> \n<213> out += 8;\n<214> \n<215> }\n<216> \n<217> }\n<218> \n<219> \n<220> \n<221> if (b & C93_HAS_PALETTE) {\n<222> \n<223> uint32_t *palette = (uint32_t *) newpic->data[1];\n<224> \n<225> for (i = 0; i < 256; i++) {\n<226> \n<227> palette[i] = 0xFFU << 24 | bytestream2_get_be24(&gb);\n<228> \n<229> }\n<230> \n<231> newpic->palette_has_changed = 1;\n<232> \n<233> } else {\n<234> \n<235> if (oldpic->data[1])\n<236> \n<237> memcpy(newpic->data[1], oldpic->data[1], 256 * 4);\n<238> \n<239> }\n<240> \n<241> \n<242> \n<243> if ((ret = av_frame_ref(data, newpic)) < 0)\n<244> \n<245> return ret;\n<246> \n<247> *got_frame = 1;\n<248> \n<249> \n<250> \n<251> return buf_size;\n<252> \n<253> }\n<254> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int vmdk_write_cid(BlockDriverState *bs, uint32_t cid)\n<2> \n<3> {\n<4> \n<5> char desc[DESC_SIZE], tmp_desc[DESC_SIZE];\n<6> \n<7> char *p_name, *tmp_str;\n<8> \n<9> BDRVVmdkState *s = bs->opaque;\n<10> \n<11> \n<12> \n<13> memset(desc, 0, sizeof(desc));\n<14> \n<15> if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n<16> \n<17> return -EIO;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> tmp_str = strstr(desc,"parentCID");\n<24> \n<25> pstrcpy(tmp_desc, sizeof(tmp_desc), tmp_str);\n<26> \n<27> if ((p_name = strstr(desc,"CID")) != NULL) {\n<28> \n<29> p_name += sizeof("CID");\n<30> \n<31> snprintf(p_name, sizeof(desc) - (p_name - desc), "%x\n", cid);\n<32> \n<33> pstrcat(desc, sizeof(desc), tmp_desc);\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> if (bdrv_pwrite_sync(bs->file, s->desc_offset, desc, DESC_SIZE) < 0) {\n<40> \n<41> return -EIO;\n<42> \n<43> }\n<44> \n<45> return 0;\n<46> \n<47> }\n<48> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void monitor_handle_command(Monitor *mon, const char *cmdline)\n<2> \n<3> {\n<4> \n<5> const char *p, *pstart, *typestr;\n<6> \n<7> char *q;\n<8> \n<9> int c, nb_args, len, i, has_arg;\n<10> \n<11> const mon_cmd_t *cmd;\n<12> \n<13> char cmdname[256];\n<14> \n<15> char buf[1024];\n<16> \n<17> void *str_allocated[MAX_ARGS];\n<18> \n<19> void *args[MAX_ARGS];\n<20> \n<21> void (*handler_0)(Monitor *mon);\n<22> \n<23> void (*handler_1)(Monitor *mon, void *arg0);\n<24> \n<25> void (*handler_2)(Monitor *mon, void *arg0, void *arg1);\n<26> \n<27> void (*handler_3)(Monitor *mon, void *arg0, void *arg1, void *arg2);\n<28> \n<29> void (*handler_4)(Monitor *mon, void *arg0, void *arg1, void *arg2,\n<30> \n<31> void *arg3);\n<32> \n<33> void (*handler_5)(Monitor *mon, void *arg0, void *arg1, void *arg2,\n<34> \n<35> void *arg3, void *arg4);\n<36> \n<37> void (*handler_6)(Monitor *mon, void *arg0, void *arg1, void *arg2,\n<38> \n<39> void *arg3, void *arg4, void *arg5);\n<40> \n<41> void (*handler_7)(Monitor *mon, void *arg0, void *arg1, void *arg2,\n<42> \n<43> void *arg3, void *arg4, void *arg5, void *arg6);\n<44> \n<45> \n<46> \n<47> #ifdef DEBUG\n<48> \n<49> monitor_printf(mon, "command='%s'\n", cmdline);\n<50> \n<51> #endif\n<52> \n<53> \n<54> \n<55> /* extract the command name */\n<56> \n<57> p = cmdline;\n<58> \n<59> q = cmdname;\n<60> \n<61> while (qemu_isspace(*p))\n<62> \n<63> p++;\n<64> \n<65> if (*p == '\0')\n<66> \n<67> return;\n<68> \n<69> pstart = p;\n<70> \n<71> while (*p != '\0' && *p != '/' && !qemu_isspace(*p))\n<72> \n<73> p++;\n<74> \n<75> len = p - pstart;\n<76> \n<77> if (len > sizeof(cmdname) - 1)\n<78> \n<79> len = sizeof(cmdname) - 1;\n<80> \n<81> memcpy(cmdname, pstart, len);\n<82> \n<83> cmdname[len] = '\0';\n<84> \n<85> \n<86> \n<87> /* find the command */\n<88> \n<89> for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n<90> \n<91> if (compare_cmd(cmdname, cmd->name))\n<92> \n<93> goto found;\n<94> \n<95> }\n<96> \n<97> monitor_printf(mon, "unknown command: '%s'\n", cmdname);\n<98> \n<99> return;\n<100> \n<101> found:\n<102> \n<103> \n<104> \n<105> for(i = 0; i < MAX_ARGS; i++)\n<106> \n<107> str_allocated[i] = NULL;\n<108> \n<109> \n<110> \n<111> /* parse the parameters */\n<112> \n<113> typestr = cmd->args_type;\n<114> \n<115> nb_args = 0;\n<116> \n<117> for(;;) {\n<118> \n<119> c = *typestr;\n<120> \n<121> if (c == '\0')\n<122> \n<123> break;\n<124> \n<125> typestr++;\n<126> \n<127> switch(c) {\n<128> \n<129> case 'F':\n<130> \n<131> case 'B':\n<132> \n<133> case 's':\n<134> \n<135> {\n<136> \n<137> int ret;\n<138> \n<139> char *str;\n<140> \n<141> \n<142> \n<143> while (qemu_isspace(*p))\n<144> \n<145> p++;\n<146> \n<147> if (*typestr == '?') {\n<148> \n<149> typestr++;\n<150> \n<151> if (*p == '\0') {\n<152> \n<153> /* no optional string: NULL argument */\n<154> \n<155> str = NULL;\n<156> \n<157> goto add_str;\n<158> \n<159> }\n<160> \n<161> }\n<162> \n<163> ret = get_str(buf, sizeof(buf), &p);\n<164> \n<165> if (ret < 0) {\n<166> \n<167> switch(c) {\n<168> \n<169> case 'F':\n<170> \n<171> monitor_printf(mon, "%s: filename expected\n",\n<172> \n<173> cmdname);\n<174> \n<175> break;\n<176> \n<177> case 'B':\n<178> \n<179> monitor_printf(mon, "%s: block device name expected\n",\n<180> \n<181> cmdname);\n<182> \n<183> break;\n<184> \n<185> default:\n<186> \n<187> monitor_printf(mon, "%s: string expected\n", cmdname);\n<188> \n<189> break;\n<190> \n<191> }\n<192> \n<193> goto fail;\n<194> \n<195> }\n<196> \n<197> str = qemu_malloc(strlen(buf) + 1);\n<198> \n<199> pstrcpy(str, sizeof(buf), buf);\n<200> \n<201> str_allocated[nb_args] = str;\n<202> \n<203> add_str:\n<204> \n<205> if (nb_args >= MAX_ARGS) {\n<206> \n<207> error_args:\n<208> \n<209> monitor_printf(mon, "%s: too many arguments\n", cmdname);\n<210> \n<211> goto fail;\n<212> \n<213> }\n<214> \n<215> args[nb_args++] = str;\n<216> \n<217> }\n<218> \n<219> break;\n<220> \n<221> case '/':\n<222> \n<223> {\n<224> \n<225> int count, format, size;\n<226> \n<227> \n<228> \n<229> while (qemu_isspace(*p))\n<230> \n<231> p++;\n<232> \n<233> if (*p == '/') {\n<234> \n<235> /* format found */\n<236> \n<237> p++;\n<238> \n<239> count = 1;\n<240> \n<241> if (qemu_isdigit(*p)) {\n<242> \n<243> count = 0;\n<244> \n<245> while (qemu_isdigit(*p)) {\n<246> \n<247> count = count * 10 + (*p - '0');\n<248> \n<249> p++;\n<250> \n<251> }\n<252> \n<253> }\n<254> \n<255> size = -1;\n<256> \n<257> format = -1;\n<258> \n<259> for(;;) {\n<260> \n<261> switch(*p) {\n<262> \n<263> case 'o':\n<264> \n<265> case 'd':\n<266> \n<267> case 'u':\n<268> \n<269> case 'x':\n<270> \n<271> case 'i':\n<272> \n<273> case 'c':\n<274> \n<275> format = *p++;\n<276> \n<277> break;\n<278> \n<279> case 'b':\n<280> \n<281> size = 1;\n<282> \n<283> p++;\n<284> \n<285> break;\n<286> \n<287> case 'h':\n<288> \n<289> size = 2;\n<290> \n<291> p++;\n<292> \n<293> break;\n<294> \n<295> case 'w':\n<296> \n<297> size = 4;\n<298> \n<299> p++;\n<300> \n<301> break;\n<302> \n<303> case 'g':\n<304> \n<305> case 'L':\n<306> \n<307> size = 8;\n<308> \n<309> p++;\n<310> \n<311> break;\n<312> \n<313> default:\n<314> \n<315> goto next;\n<316> \n<317> }\n<318> \n<319> }\n<320> \n<321> next:\n<322> \n<323> if (*p != '\0' && !qemu_isspace(*p)) {\n<324> \n<325> monitor_printf(mon, "invalid char in format: '%c'\n",\n<326> \n<327> *p);\n<328> \n<329> goto fail;\n<330> \n<331> }\n<332> \n<333> if (format < 0)\n<334> \n<335> format = default_fmt_format;\n<336> \n<337> if (format != 'i') {\n<338> \n<339> /* for 'i', not specifying a size gives -1 as size */\n<340> \n<341> if (size < 0)\n<342> \n<343> size = default_fmt_size;\n<344> \n<345> default_fmt_size = size;\n<346> \n<347> }\n<348> \n<349> default_fmt_format = format;\n<350> \n<351> } else {\n<352> \n<353> count = 1;\n<354> \n<355> format = default_fmt_format;\n<356> \n<357> if (format != 'i') {\n<358> \n<359> size = default_fmt_size;\n<360> \n<361> } else {\n<362> \n<363> size = -1;\n<364> \n<365> }\n<366> \n<367> }\n<368> \n<369> if (nb_args + 3 > MAX_ARGS)\n<370> \n<371> goto error_args;\n<372> \n<373> args[nb_args++] = (void*)(long)count;\n<374> \n<375> args[nb_args++] = (void*)(long)format;\n<376> \n<377> args[nb_args++] = (void*)(long)size;\n<378> \n<379> }\n<380> \n<381> break;\n<382> \n<383> case 'i':\n<384> \n<385> case 'l':\n<386> \n<387> {\n<388> \n<389> int64_t val;\n<390> \n<391> \n<392> \n<393> while (qemu_isspace(*p))\n<394> \n<395> p++;\n<396> \n<397> if (*typestr == '?' || *typestr == '.') {\n<398> \n<399> if (*typestr == '?') {\n<400> \n<401> if (*p == '\0')\n<402> \n<403> has_arg = 0;\n<404> \n<405> else\n<406> \n<407> has_arg = 1;\n<408> \n<409> } else {\n<410> \n<411> if (*p == '.') {\n<412> \n<413> p++;\n<414> \n<415> while (qemu_isspace(*p))\n<416> \n<417> p++;\n<418> \n<419> has_arg = 1;\n<420> \n<421> } else {\n<422> \n<423> has_arg = 0;\n<424> \n<425> }\n<426> \n<427> }\n<428> \n<429> typestr++;\n<430> \n<431> if (nb_args >= MAX_ARGS)\n<432> \n<433> goto error_args;\n<434> \n<435> args[nb_args++] = (void *)(long)has_arg;\n<436> \n<437> if (!has_arg) {\n<438> \n<439> if (nb_args >= MAX_ARGS)\n<440> \n<441> goto error_args;\n<442> \n<443> val = -1;\n<444> \n<445> goto add_num;\n<446> \n<447> }\n<448> \n<449> }\n<450> \n<451> if (get_expr(mon, &val, &p))\n<452> \n<453> goto fail;\n<454> \n<455> add_num:\n<456> \n<457> if (c == 'i') {\n<458> \n<459> if (nb_args >= MAX_ARGS)\n<460> \n<461> goto error_args;\n<462> \n<463> args[nb_args++] = (void *)(long)val;\n<464> \n<465> } else {\n<466> \n<467> if ((nb_args + 1) >= MAX_ARGS)\n<468> \n<469> goto error_args;\n<470> \n<471> #if TARGET_PHYS_ADDR_BITS > 32\n<472> \n<473> args[nb_args++] = (void *)(long)((val >> 32) & 0xffffffff);\n<474> \n<475> #else\n<476> \n<477> args[nb_args++] = (void *)0;\n<478> \n<479> #endif\n<480> \n<481> args[nb_args++] = (void *)(long)(val & 0xffffffff);\n<482> \n<483> }\n<484> \n<485> }\n<486> \n<487> break;\n<488> \n<489> case '-':\n<490> \n<491> {\n<492> \n<493> int has_option;\n<494> \n<495> /* option */\n<496> \n<497> \n<498> \n<499> c = *typestr++;\n<500> \n<501> if (c == '\0')\n<502> \n<503> goto bad_type;\n<504> \n<505> while (qemu_isspace(*p))\n<506> \n<507> p++;\n<508> \n<509> has_option = 0;\n<510> \n<511> if (*p == '-') {\n<512> \n<513> p++;\n<514> \n<515> if (*p != c) {\n<516> \n<517> monitor_printf(mon, "%s: unsupported option -%c\n",\n<518> \n<519> cmdname, *p);\n<520> \n<521> goto fail;\n<522> \n<523> }\n<524> \n<525> p++;\n<526> \n<527> has_option = 1;\n<528> \n<529> }\n<530> \n<531> if (nb_args >= MAX_ARGS)\n<532> \n<533> goto error_args;\n<534> \n<535> args[nb_args++] = (void *)(long)has_option;\n<536> \n<537> }\n<538> \n<539> break;\n<540> \n<541> default:\n<542> \n<543> bad_type:\n<544> \n<545> monitor_printf(mon, "%s: unknown type '%c'\n", cmdname, c);\n<546> \n<547> goto fail;\n<548> \n<549> }\n<550> \n<551> }\n<552> \n<553> /* check that all arguments were parsed */\n<554> \n<555> while (qemu_isspace(*p))\n<556> \n<557> p++;\n<558> \n<559> if (*p != '\0') {\n<560> \n<561> monitor_printf(mon, "%s: extraneous characters at the end of line\n",\n<562> \n<563> cmdname);\n<564> \n<565> goto fail;\n<566> \n<567> }\n<568> \n<569> \n<570> \n<571> switch(nb_args) {\n<572> \n<573> case 0:\n<574> \n<575> handler_0 = cmd->handler;\n<576> \n<577> handler_0(mon);\n<578> \n<579> break;\n<580> \n<581> case 1:\n<582> \n<583> handler_1 = cmd->handler;\n<584> \n<585> handler_1(mon, args[0]);\n<586> \n<587> break;\n<588> \n<589> case 2:\n<590> \n<591> handler_2 = cmd->handler;\n<592> \n<593> handler_2(mon, args[0], args[1]);\n<594> \n<595> break;\n<596> \n<597> case 3:\n<598> \n<599> handler_3 = cmd->handler;\n<600> \n<601> handler_3(mon, args[0], args[1], args[2]);\n<602> \n<603> break;\n<604> \n<605> case 4:\n<606> \n<607> handler_4 = cmd->handler;\n<608> \n<609> handler_4(mon, args[0], args[1], args[2], args[3]);\n<610> \n<611> break;\n<612> \n<613> case 5:\n<614> \n<615> handler_5 = cmd->handler;\n<616> \n<617> handler_5(mon, args[0], args[1], args[2], args[3], args[4]);\n<618> \n<619> break;\n<620> \n<621> case 6:\n<622> \n<623> handler_6 = cmd->handler;\n<624> \n<625> handler_6(mon, args[0], args[1], args[2], args[3], args[4], args[5]);\n<626> \n<627> break;\n<628> \n<629> case 7:\n<630> \n<631> handler_7 = cmd->handler;\n<632> \n<633> handler_7(mon, args[0], args[1], args[2], args[3], args[4], args[5],\n<634> \n<635> args[6]);\n<636> \n<637> break;\n<638> \n<639> default:\n<640> \n<641> monitor_printf(mon, "unsupported number of arguments: %d\n", nb_args);\n<642> \n<643> goto fail;\n<644> \n<645> }\n<646> \n<647> fail:\n<648> \n<649> for(i = 0; i < MAX_ARGS; i++)\n<650> \n<651> qemu_free(str_allocated[i]);\n<652> \n<653> return;\n<654> \n<655> }\n<656> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void omap2_inth_write(void *opaque, target_phys_addr_t addr,\n<2> \n<3> uint64_t value, unsigned size)\n<4> \n<5> {\n<6> \n<7> struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;\n<8> \n<9> int offset = addr;\n<10> \n<11> int bank_no, line_no;\n<12> \n<13> struct omap_intr_handler_bank_s *bank = NULL;\n<14> \n<15> \n<16> \n<17> if ((offset & 0xf80) == 0x80) {\n<18> \n<19> bank_no = (offset & 0x60) >> 5;\n<20> \n<21> if (bank_no < s->nbanks) {\n<22> \n<23> offset &= ~0x60;\n<24> \n<25> bank = &s->bank[bank_no];\n<26> \n<27> }\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> switch (offset) {\n<34> \n<35> case 0x10:	/* INTC_SYSCONFIG */\n<36> \n<37> s->autoidle &= 4;\n<38> \n<39> s->autoidle |= (value & 1) << 2;\n<40> \n<41> if (value & 2)						/* SOFTRESET */\n<42> \n<43> omap_inth_reset(s);\n<44> \n<45> return;\n<46> \n<47> \n<48> \n<49> case 0x48:	/* INTC_CONTROL */\n<50> \n<51> s->mask = (value & 4) ? 0 : ~0;				/* GLOBALMASK */\n<52> \n<53> if (value & 2) {					/* NEWFIQAGR */\n<54> \n<55> qemu_set_irq(s->parent_intr[1], 0);\n<56> \n<57> s->new_agr[1] = ~0;\n<58> \n<59> omap_inth_update(s, 1);\n<60> \n<61> }\n<62> \n<63> if (value & 1) {					/* NEWIRQAGR */\n<64> \n<65> qemu_set_irq(s->parent_intr[0], 0);\n<66> \n<67> s->new_agr[0] = ~0;\n<68> \n<69> omap_inth_update(s, 0);\n<70> \n<71> }\n<72> \n<73> return;\n<74> \n<75> \n<76> \n<77> case 0x4c:	/* INTC_PROTECTION */\n<78> \n<79> /* TODO: Make a bitmap (or sizeof(char)map) of access privileges\n<80> \n<81> * for every register, see Chapter 3 and 4 for privileged mode.  */\n<82> \n<83> if (value & 1)\n<84> \n<85> fprintf(stderr, "%s: protection mode enable attempt\n",\n<86> \n<87> __FUNCTION__);\n<88> \n<89> return;\n<90> \n<91> \n<92> \n<93> case 0x50:	/* INTC_IDLE */\n<94> \n<95> s->autoidle &= ~3;\n<96> \n<97> s->autoidle |= value & 3;\n<98> \n<99> return;\n<100> \n<101> \n<102> \n<103> /* Per-bank registers */\n<104> \n<105> case 0x84:	/* INTC_MIR */\n<106> \n<107> bank->mask = value;\n<108> \n<109> omap_inth_update(s, 0);\n<110> \n<111> omap_inth_update(s, 1);\n<112> \n<113> return;\n<114> \n<115> \n<116> \n<117> case 0x88:	/* INTC_MIR_CLEAR */\n<118> \n<119> bank->mask &= ~value;\n<120> \n<121> omap_inth_update(s, 0);\n<122> \n<123> omap_inth_update(s, 1);\n<124> \n<125> return;\n<126> \n<127> \n<128> \n<129> case 0x8c:	/* INTC_MIR_SET */\n<130> \n<131> bank->mask |= value;\n<132> \n<133> return;\n<134> \n<135> \n<136> \n<137> case 0x90:	/* INTC_ISR_SET */\n<138> \n<139> bank->irqs |= bank->swi |= value;\n<140> \n<141> omap_inth_update(s, 0);\n<142> \n<143> omap_inth_update(s, 1);\n<144> \n<145> return;\n<146> \n<147> \n<148> \n<149> case 0x94:	/* INTC_ISR_CLEAR */\n<150> \n<151> bank->swi &= ~value;\n<152> \n<153> bank->irqs = bank->swi & bank->inputs;\n<154> \n<155> return;\n<156> \n<157> \n<158> \n<159> /* Per-line registers */\n<160> \n<161> case 0x100 ... 0x300:	/* INTC_ILR */\n<162> \n<163> bank_no = (offset - 0x100) >> 7;\n<164> \n<165> if (bank_no > s->nbanks)\n<166> \n<167> break;\n<168> \n<169> bank = &s->bank[bank_no];\n<170> \n<171> line_no = (offset & 0x7f) >> 2;\n<172> \n<173> bank->priority[line_no] = (value >> 2) & 0x3f;\n<174> \n<175> bank->fiq &= ~(1 << line_no);\n<176> \n<177> bank->fiq |= (value & 1) << line_no;\n<178> \n<179> return;\n<180> \n<181> \n<182> \n<183> case 0x00:	/* INTC_REVISION */\n<184> \n<185> case 0x14:	/* INTC_SYSSTATUS */\n<186> \n<187> case 0x40:	/* INTC_SIR_IRQ */\n<188> \n<189> case 0x44:	/* INTC_SIR_FIQ */\n<190> \n<191> case 0x80:	/* INTC_ITR */\n<192> \n<193> case 0x98:	/* INTC_PENDING_IRQ */\n<194> \n<195> case 0x9c:	/* INTC_PENDING_FIQ */\n<196> \n<197> OMAP_RO_REG(addr);\n<198> \n<199> return;\n<200> \n<201> }\n<202> \n<203> OMAP_BAD_REG(addr);\n<204> \n<205> }\n<206> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int32_t scsi_send_command(SCSIDevice *d, uint32_t tag,\n<2> \n<3> uint8_t *buf, int lun)\n<4> \n<5> {\n<6> \n<7> SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n<8> \n<9> uint64_t nb_sectors;\n<10> \n<11> uint64_t lba;\n<12> \n<13> uint32_t len;\n<14> \n<15> int cmdlen;\n<16> \n<17> int is_write;\n<18> \n<19> uint8_t command;\n<20> \n<21> uint8_t *outbuf;\n<22> \n<23> SCSIRequest *r;\n<24> \n<25> \n<26> \n<27> command = buf[0];\n<28> \n<29> r = scsi_find_request(s, tag);\n<30> \n<31> if (r) {\n<32> \n<33> BADF("Tag 0x%x already in use\n", tag);\n<34> \n<35> scsi_cancel_io(d, tag);\n<36> \n<37> }\n<38> \n<39> /* ??? Tags are not unique for different luns.  We only implement a\n<40> \n<41> single lun, so this should not matter.  */\n<42> \n<43> r = scsi_new_request(d, tag);\n<44> \n<45> outbuf = (uint8_t *)r->iov.iov_base;\n<46> \n<47> is_write = 0;\n<48> \n<49> DPRINTF("Command: lun=%d tag=0x%x data=0x%02x", lun, tag, buf[0]);\n<50> \n<51> switch (command >> 5) {\n<52> \n<53> case 0:\n<54> \n<55> lba = (uint64_t) buf[3] | ((uint64_t) buf[2] << 8) |\n<56> \n<57> (((uint64_t) buf[1] & 0x1f) << 16);\n<58> \n<59> len = buf[4];\n<60> \n<61> cmdlen = 6;\n<62> \n<63> break;\n<64> \n<65> case 1:\n<66> \n<67> case 2:\n<68> \n<69> lba = (uint64_t) buf[5] | ((uint64_t) buf[4] << 8) |\n<70> \n<71> ((uint64_t) buf[3] << 16) | ((uint64_t) buf[2] << 24);\n<72> \n<73> len = buf[8] | (buf[7] << 8);\n<74> \n<75> cmdlen = 10;\n<76> \n<77> break;\n<78> \n<79> case 4:\n<80> \n<81> lba = (uint64_t) buf[9] | ((uint64_t) buf[8] << 8) |\n<82> \n<83> ((uint64_t) buf[7] << 16) | ((uint64_t) buf[6] << 24) |\n<84> \n<85> ((uint64_t) buf[5] << 32) | ((uint64_t) buf[4] << 40) |\n<86> \n<87> ((uint64_t) buf[3] << 48) | ((uint64_t) buf[2] << 56);\n<88> \n<89> len = buf[13] | (buf[12] << 8) | (buf[11] << 16) | (buf[10] << 24);\n<90> \n<91> cmdlen = 16;\n<92> \n<93> break;\n<94> \n<95> case 5:\n<96> \n<97> lba = (uint64_t) buf[5] | ((uint64_t) buf[4] << 8) |\n<98> \n<99> ((uint64_t) buf[3] << 16) | ((uint64_t) buf[2] << 24);\n<100> \n<101> len = buf[9] | (buf[8] << 8) | (buf[7] << 16) | (buf[6] << 24);\n<102> \n<103> cmdlen = 12;\n<104> \n<105> break;\n<106> \n<107> default:\n<108> \n<109> BADF("Unsupported command length, command %x\n", command);\n<110> \n<111> goto fail;\n<112> \n<113> }\n<114> \n<115> #ifdef DEBUG_SCSI\n<116> \n<117> {\n<118> \n<119> int i;\n<120> \n<121> for (i = 1; i < cmdlen; i++) {\n<122> \n<123> printf(" 0x%02x", buf[i]);\n<124> \n<125> }\n<126> \n<127> printf("\n");\n<128> \n<129> }\n<130> \n<131> #endif\n<132> \n<133> if (lun || buf[1] >> 5) {\n<134> \n<135> /* Only LUN 0 supported.  */\n<136> \n<137> DPRINTF("Unimplemented LUN %d\n", lun ? lun : buf[1] >> 5);\n<138> \n<139> if (command != 0x03 && command != 0x12) /* REQUEST SENSE and INQUIRY */\n<140> \n<141> goto fail;\n<142> \n<143> }\n<144> \n<145> switch (command) {\n<146> \n<147> case 0x0:\n<148> \n<149> DPRINTF("Test Unit Ready\n");\n<150> \n<151> if (!bdrv_is_inserted(s->dinfo->bdrv))\n<152> \n<153> goto notready;\n<154> \n<155> break;\n<156> \n<157> case 0x03:\n<158> \n<159> DPRINTF("Request Sense (len %d)\n", len);\n<160> \n<161> if (len < 4)\n<162> \n<163> goto fail;\n<164> \n<165> memset(outbuf, 0, 4);\n<166> \n<167> r->iov.iov_len = 4;\n<168> \n<169> if (s->sense == SENSE_NOT_READY && len >= 18) {\n<170> \n<171> memset(outbuf, 0, 18);\n<172> \n<173> r->iov.iov_len = 18;\n<174> \n<175> outbuf[7] = 10;\n<176> \n<177> /* asc 0x3a, ascq 0: Medium not present */\n<178> \n<179> outbuf[12] = 0x3a;\n<180> \n<181> outbuf[13] = 0;\n<182> \n<183> }\n<184> \n<185> outbuf[0] = 0xf0;\n<186> \n<187> outbuf[1] = 0;\n<188> \n<189> outbuf[2] = s->sense;\n<190> \n<191> break;\n<192> \n<193> case 0x12:\n<194> \n<195> DPRINTF("Inquiry (len %d)\n", len);\n<196> \n<197> if (buf[1] & 0x2) {\n<198> \n<199> /* Command support data - optional, not implemented */\n<200> \n<201> BADF("optional INQUIRY command support request not implemented\n");\n<202> \n<203> goto fail;\n<204> \n<205> }\n<206> \n<207> else if (buf[1] & 0x1) {\n<208> \n<209> /* Vital product data */\n<210> \n<211> uint8_t page_code = buf[2];\n<212> \n<213> if (len < 4) {\n<214> \n<215> BADF("Error: Inquiry (EVPD[%02X]) buffer size %d is "\n<216> \n<217> "less than 4\n", page_code, len);\n<218> \n<219> goto fail;\n<220> \n<221> }\n<222> \n<223> \n<224> \n<225> switch (page_code) {\n<226> \n<227> case 0x00:\n<228> \n<229> {\n<230> \n<231> /* Supported page codes, mandatory */\n<232> \n<233> DPRINTF("Inquiry EVPD[Supported pages] "\n<234> \n<235> "buffer size %d\n", len);\n<236> \n<237> \n<238> \n<239> r->iov.iov_len = 0;\n<240> \n<241> \n<242> \n<243> if (bdrv_get_type_hint(s->dinfo->bdrv) == BDRV_TYPE_CDROM) {\n<244> \n<245> outbuf[r->iov.iov_len++] = 5;\n<246> \n<247> } else {\n<248> \n<249> outbuf[r->iov.iov_len++] = 0;\n<250> \n<251> }\n<252> \n<253> \n<254> \n<255> outbuf[r->iov.iov_len++] = 0x00; // this page\n<256> \n<257> outbuf[r->iov.iov_len++] = 0x00;\n<258> \n<259> outbuf[r->iov.iov_len++] = 3;    // number of pages\n<260> \n<261> outbuf[r->iov.iov_len++] = 0x00; // list of supported pages (this page)\n<262> \n<263> outbuf[r->iov.iov_len++] = 0x80; // unit serial number\n<264> \n<265> outbuf[r->iov.iov_len++] = 0x83; // device identification\n<266> \n<267> }\n<268> \n<269> break;\n<270> \n<271> case 0x80:\n<272> \n<273> {\n<274> \n<275> int l;\n<276> \n<277> \n<278> \n<279> /* Device serial number, optional */\n<280> \n<281> if (len < 4) {\n<282> \n<283> BADF("Error: EVPD[Serial number] Inquiry buffer "\n<284> \n<285> "size %d too small, %d needed\n", len, 4);\n<286> \n<287> goto fail;\n<288> \n<289> }\n<290> \n<291> \n<292> \n<293> DPRINTF("Inquiry EVPD[Serial number] buffer size %d\n", len);\n<294> \n<295> l = MIN(len, strlen(s->drive_serial_str));\n<296> \n<297> \n<298> \n<299> r->iov.iov_len = 0;\n<300> \n<301> \n<302> \n<303> /* Supported page codes */\n<304> \n<305> if (bdrv_get_type_hint(s->dinfo->bdrv) == BDRV_TYPE_CDROM) {\n<306> \n<307> outbuf[r->iov.iov_len++] = 5;\n<308> \n<309> } else {\n<310> \n<311> outbuf[r->iov.iov_len++] = 0;\n<312> \n<313> }\n<314> \n<315> \n<316> \n<317> outbuf[r->iov.iov_len++] = 0x80; // this page\n<318> \n<319> outbuf[r->iov.iov_len++] = 0x00;\n<320> \n<321> outbuf[r->iov.iov_len++] = l;\n<322> \n<323> memcpy(&outbuf[r->iov.iov_len], s->drive_serial_str, l);\n<324> \n<325> r->iov.iov_len += l;\n<326> \n<327> }\n<328> \n<329> \n<330> \n<331> break;\n<332> \n<333> case 0x83:\n<334> \n<335> {\n<336> \n<337> /* Device identification page, mandatory */\n<338> \n<339> int max_len = 255 - 8;\n<340> \n<341> int id_len = strlen(bdrv_get_device_name(s->dinfo->bdrv));\n<342> \n<343> if (id_len > max_len)\n<344> \n<345> id_len = max_len;\n<346> \n<347> \n<348> \n<349> DPRINTF("Inquiry EVPD[Device identification] "\n<350> \n<351> "buffer size %d\n", len);\n<352> \n<353> r->iov.iov_len = 0;\n<354> \n<355> if (bdrv_get_type_hint(s->dinfo->bdrv) == BDRV_TYPE_CDROM) {\n<356> \n<357> outbuf[r->iov.iov_len++] = 5;\n<358> \n<359> } else {\n<360> \n<361> outbuf[r->iov.iov_len++] = 0;\n<362> \n<363> }\n<364> \n<365> \n<366> \n<367> outbuf[r->iov.iov_len++] = 0x83; // this page\n<368> \n<369> outbuf[r->iov.iov_len++] = 0x00;\n<370> \n<371> outbuf[r->iov.iov_len++] = 3 + id_len;\n<372> \n<373> \n<374> \n<375> outbuf[r->iov.iov_len++] = 0x2; // ASCII\n<376> \n<377> outbuf[r->iov.iov_len++] = 0;   // not officially assigned\n<378> \n<379> outbuf[r->iov.iov_len++] = 0;   // reserved\n<380> \n<381> outbuf[r->iov.iov_len++] = id_len; // length of data following\n<382> \n<383> \n<384> \n<385> memcpy(&outbuf[r->iov.iov_len],\n<386> \n<387> bdrv_get_device_name(s->dinfo->bdrv), id_len);\n<388> \n<389> r->iov.iov_len += id_len;\n<390> \n<391> }\n<392> \n<393> break;\n<394> \n<395> default:\n<396> \n<397> BADF("Error: unsupported Inquiry (EVPD[%02X]) "\n<398> \n<399> "buffer size %d\n", page_code, len);\n<400> \n<401> goto fail;\n<402> \n<403> }\n<404> \n<405> /* done with EVPD */\n<406> \n<407> break;\n<408> \n<409> }\n<410> \n<411> else {\n<412> \n<413> /* Standard INQUIRY data */\n<414> \n<415> if (buf[2] != 0) {\n<416> \n<417> BADF("Error: Inquiry (STANDARD) page or code "\n<418> \n<419> "is non-zero [%02X]\n", buf[2]);\n<420> \n<421> goto fail;\n<422> \n<423> }\n<424> \n<425> \n<426> \n<427> /* PAGE CODE == 0 */\n<428> \n<429> if (len < 5) {\n<430> \n<431> BADF("Error: Inquiry (STANDARD) buffer size %d "\n<432> \n<433> "is less than 5\n", len);\n<434> \n<435> goto fail;\n<436> \n<437> }\n<438> \n<439> \n<440> \n<441> if (len < 36) {\n<442> \n<443> BADF("Error: Inquiry (STANDARD) buffer size %d "\n<444> \n<445> "is less than 36 (TODO: only 5 required)\n", len);\n<446> \n<447> }\n<448> \n<449> }\n<450> \n<451> \n<452> \n<453> if(len > SCSI_MAX_INQUIRY_LEN)\n<454> \n<455> len = SCSI_MAX_INQUIRY_LEN;\n<456> \n<457> \n<458> \n<459> memset(outbuf, 0, len);\n<460> \n<461> \n<462> \n<463> if (lun || buf[1] >> 5) {\n<464> \n<465> outbuf[0] = 0x7f;	/* LUN not supported */\n<466> \n<467> } else if (bdrv_get_type_hint(s->dinfo->bdrv) == BDRV_TYPE_CDROM) {\n<468> \n<469> outbuf[0] = 5;\n<470> \n<471> outbuf[1] = 0x80;\n<472> \n<473> memcpy(&outbuf[16], "QEMU CD-ROM    ", 16);\n<474> \n<475> } else {\n<476> \n<477> outbuf[0] = 0;\n<478> \n<479> memcpy(&outbuf[16], "QEMU HARDDISK  ", 16);\n<480> \n<481> }\n<482> \n<483> memcpy(&outbuf[8], "QEMU   ", 8);\n<484> \n<485> memcpy(&outbuf[32], QEMU_VERSION, 4);\n<486> \n<487> /* Identify device as SCSI-3 rev 1.\n<488> \n<489> Some later commands are also implemented. */\n<490> \n<491> outbuf[2] = 3;\n<492> \n<493> outbuf[3] = 2; /* Format 2 */\n<494> \n<495> outbuf[4] = len - 5; /* Additional Length = (Len - 1) - 4 */\n<496> \n<497> /* Sync data transfer and TCQ.  */\n<498> \n<499> outbuf[7] = 0x10 | (r->bus->tcq ? 0x02 : 0);\n<500> \n<501> r->iov.iov_len = len;\n<502> \n<503> break;\n<504> \n<505> case 0x16:\n<506> \n<507> DPRINTF("Reserve(6)\n");\n<508> \n<509> if (buf[1] & 1)\n<510> \n<511> goto fail;\n<512> \n<513> break;\n<514> \n<515> case 0x17:\n<516> \n<517> DPRINTF("Release(6)\n");\n<518> \n<519> if (buf[1] & 1)\n<520> \n<521> goto fail;\n<522> \n<523> break;\n<524> \n<525> case 0x1a:\n<526> \n<527> case 0x5a:\n<528> \n<529> {\n<530> \n<531> uint8_t *p;\n<532> \n<533> int page;\n<534> \n<535> \n<536> \n<537> page = buf[2] & 0x3f;\n<538> \n<539> DPRINTF("Mode Sense (page %d, len %d)\n", page, len);\n<540> \n<541> p = outbuf;\n<542> \n<543> memset(p, 0, 4);\n<544> \n<545> outbuf[1] = 0; /* Default media type.  */\n<546> \n<547> outbuf[3] = 0; /* Block descriptor length.  */\n<548> \n<549> if (bdrv_get_type_hint(s->dinfo->bdrv) == BDRV_TYPE_CDROM) {\n<550> \n<551> outbuf[2] = 0x80; /* Readonly.  */\n<552> \n<553> }\n<554> \n<555> p += 4;\n<556> \n<557> if (page == 4) {\n<558> \n<559> int cylinders, heads, secs;\n<560> \n<561> \n<562> \n<563> /* Rigid disk device geometry page. */\n<564> \n<565> p[0] = 4;\n<566> \n<567> p[1] = 0x16;\n<568> \n<569> /* if a geometry hint is available, use it */\n<570> \n<571> bdrv_get_geometry_hint(s->dinfo->bdrv, &cylinders, &heads, &secs);\n<572> \n<573> p[2] = (cylinders >> 16) & 0xff;\n<574> \n<575> p[3] = (cylinders >> 8) & 0xff;\n<576> \n<577> p[4] = cylinders & 0xff;\n<578> \n<579> p[5] = heads & 0xff;\n<580> \n<581> /* Write precomp start cylinder, disabled */\n<582> \n<583> p[6] = (cylinders >> 16) & 0xff;\n<584> \n<585> p[7] = (cylinders >> 8) & 0xff;\n<586> \n<587> p[8] = cylinders & 0xff;\n<588> \n<589> /* Reduced current start cylinder, disabled */\n<590> \n<591> p[9] = (cylinders >> 16) & 0xff;\n<592> \n<593> p[10] = (cylinders >> 8) & 0xff;\n<594> \n<595> p[11] = cylinders & 0xff;\n<596> \n<597> /* Device step rate [ns], 200ns */\n<598> \n<599> p[12] = 0;\n<600> \n<601> p[13] = 200;\n<602> \n<603> /* Landing zone cylinder */\n<604> \n<605> p[14] = 0xff;\n<606> \n<607> p[15] =  0xff;\n<608> \n<609> p[16] = 0xff;\n<610> \n<611> /* Medium rotation rate [rpm], 5400 rpm */\n<612> \n<613> p[20] = (5400 >> 8) & 0xff;\n<614> \n<615> p[21] = 5400 & 0xff;\n<616> \n<617> p += 0x16;\n<618> \n<619> } else if (page == 5) {\n<620> \n<621> int cylinders, heads, secs;\n<622> \n<623> \n<624> \n<625> /* Flexible disk device geometry page. */\n<626> \n<627> p[0] = 5;\n<628> \n<629> p[1] = 0x1e;\n<630> \n<631> /* Transfer rate [kbit/s], 5Mbit/s */\n<632> \n<633> p[2] = 5000 >> 8;\n<634> \n<635> p[3] = 5000 & 0xff;\n<636> \n<637> /* if a geometry hint is available, use it */\n<638> \n<639> bdrv_get_geometry_hint(s->dinfo->bdrv, &cylinders, &heads, &secs);\n<640> \n<641> p[4] = heads & 0xff;\n<642> \n<643> p[5] = secs & 0xff;\n<644> \n<645> p[6] = s->cluster_size * 2;\n<646> \n<647> p[8] = (cylinders >> 8) & 0xff;\n<648> \n<649> p[9] = cylinders & 0xff;\n<650> \n<651> /* Write precomp start cylinder, disabled */\n<652> \n<653> p[10] = (cylinders >> 8) & 0xff;\n<654> \n<655> p[11] = cylinders & 0xff;\n<656> \n<657> /* Reduced current start cylinder, disabled */\n<658> \n<659> p[12] = (cylinders >> 8) & 0xff;\n<660> \n<661> p[13] = cylinders & 0xff;\n<662> \n<663> /* Device step rate [100us], 100us */\n<664> \n<665> p[14] = 0;\n<666> \n<667> p[15] = 1;\n<668> \n<669> /* Device step pulse width [us], 1us */\n<670> \n<671> p[16] = 1;\n<672> \n<673> /* Device head settle delay [100us], 100us */\n<674> \n<675> p[17] = 0;\n<676> \n<677> p[18] = 1;\n<678> \n<679> /* Motor on delay [0.1s], 0.1s */\n<680> \n<681> p[19] = 1;\n<682> \n<683> /* Motor off delay [0.1s], 0.1s */\n<684> \n<685> p[20] = 1;\n<686> \n<687> /* Medium rotation rate [rpm], 5400 rpm */\n<688> \n<689> p[28] = (5400 >> 8) & 0xff;\n<690> \n<691> p[29] = 5400 & 0xff;\n<692> \n<693> p += 0x1e;\n<694> \n<695> } else if ((page == 8 || page == 0x3f)) {\n<696> \n<697> /* Caching page.  */\n<698> \n<699> memset(p,0,20);\n<700> \n<701> p[0] = 8;\n<702> \n<703> p[1] = 0x12;\n<704> \n<705> if (bdrv_enable_write_cache(s->dinfo->bdrv)) {\n<706> \n<707> p[2] = 4; /* WCE */\n<708> \n<709> }\n<710> \n<711> p += 20;\n<712> \n<713> }\n<714> \n<715> if ((page == 0x3f || page == 0x2a)\n<716> \n<717> && (bdrv_get_type_hint(s->dinfo->bdrv) == BDRV_TYPE_CDROM)) {\n<718> \n<719> /* CD Capabilities and Mechanical Status page. */\n<720> \n<721> p[0] = 0x2a;\n<722> \n<723> p[1] = 0x14;\n<724> \n<725> p[2] = 3; // CD-R & CD-RW read\n<726> \n<727> p[3] = 0; // Writing not supported\n<728> \n<729> p[4] = 0x7f; /* Audio, composite, digital out,\n<730> \n<731> mode 2 form 1&2, multi session */\n<732> \n<733> p[5] = 0xff; /* CD DA, DA accurate, RW supported,\n<734> \n<735> RW corrected, C2 errors, ISRC,\n<736> \n<737> UPC, Bar code */\n<738> \n<739> p[6] = 0x2d | (bdrv_is_locked(s->dinfo->bdrv)? 2 : 0);\n<740> \n<741> /* Locking supported, jumper present, eject, tray */\n<742> \n<743> p[7] = 0; /* no volume & mute control, no\n<744> \n<745> changer */\n<746> \n<747> p[8] = (50 * 176) >> 8; // 50x read speed\n<748> \n<749> p[9] = (50 * 176) & 0xff;\n<750> \n<751> p[10] = 0 >> 8; // No volume\n<752> \n<753> p[11] = 0 & 0xff;\n<754> \n<755> p[12] = 2048 >> 8; // 2M buffer\n<756> \n<757> p[13] = 2048 & 0xff;\n<758> \n<759> p[14] = (16 * 176) >> 8; // 16x read speed current\n<760> \n<761> p[15] = (16 * 176) & 0xff;\n<762> \n<763> p[18] = (16 * 176) >> 8; // 16x write speed\n<764> \n<765> p[19] = (16 * 176) & 0xff;\n<766> \n<767> p[20] = (16 * 176) >> 8; // 16x write speed current\n<768> \n<769> p[21] = (16 * 176) & 0xff;\n<770> \n<771> p += 22;\n<772> \n<773> }\n<774> \n<775> r->iov.iov_len = p - outbuf;\n<776> \n<777> outbuf[0] = r->iov.iov_len - 4;\n<778> \n<779> if (r->iov.iov_len > len)\n<780> \n<781> r->iov.iov_len = len;\n<782> \n<783> }\n<784> \n<785> break;\n<786> \n<787> case 0x1b:\n<788> \n<789> DPRINTF("Start Stop Unit\n");\n<790> \n<791> if (bdrv_get_type_hint(s->dinfo->bdrv) == BDRV_TYPE_CDROM &&\n<792> \n<793> (buf[4] & 2))\n<794> \n<795> /* load/eject medium */\n<796> \n<797> bdrv_eject(s->dinfo->bdrv, !(buf[4] & 1));\n<798> \n<799> break;\n<800> \n<801> case 0x1e:\n<802> \n<803> DPRINTF("Prevent Allow Medium Removal (prevent = %d)\n", buf[4] & 3);\n<804> \n<805> bdrv_set_locked(s->dinfo->bdrv, buf[4] & 1);\n<806> \n<807> break;\n<808> \n<809> case 0x25:\n<810> \n<811> DPRINTF("Read Capacity\n");\n<812> \n<813> /* The normal LEN field for this command is zero.  */\n<814> \n<815> memset(outbuf, 0, 8);\n<816> \n<817> bdrv_get_geometry(s->dinfo->bdrv, &nb_sectors);\n<818> \n<819> nb_sectors /= s->cluster_size;\n<820> \n<821> /* Returned value is the address of the last sector.  */\n<822> \n<823> if (nb_sectors) {\n<824> \n<825> nb_sectors--;\n<826> \n<827> /* Remember the new size for read/write sanity checking. */\n<828> \n<829> s->max_lba = nb_sectors;\n<830> \n<831> /* Clip to 2TB, instead of returning capacity modulo 2TB. */\n<832> \n<833> if (nb_sectors > UINT32_MAX)\n<834> \n<835> nb_sectors = UINT32_MAX;\n<836> \n<837> outbuf[0] = (nb_sectors >> 24) & 0xff;\n<838> \n<839> outbuf[1] = (nb_sectors >> 16) & 0xff;\n<840> \n<841> outbuf[2] = (nb_sectors >> 8) & 0xff;\n<842> \n<843> outbuf[3] = nb_sectors & 0xff;\n<844> \n<845> outbuf[4] = 0;\n<846> \n<847> outbuf[5] = 0;\n<848> \n<849> outbuf[6] = s->cluster_size * 2;\n<850> \n<851> outbuf[7] = 0;\n<852> \n<853> r->iov.iov_len = 8;\n<854> \n<855> } else {\n<856> \n<857> notready:\n<858> \n<859> scsi_command_complete(r, STATUS_CHECK_CONDITION, SENSE_NOT_READY);\n<860> \n<861> return 0;\n<862> \n<863> }\n<864> \n<865> break;\n<866> \n<867> case 0x08:\n<868> \n<869> case 0x28:\n<870> \n<871> case 0x88:\n<872> \n<873> DPRINTF("Read (sector %" PRId64 ", count %d)\n", lba, len);\n<874> \n<875> if (lba > s->max_lba)\n<876> \n<877> goto illegal_lba;\n<878> \n<879> r->sector = lba * s->cluster_size;\n<880> \n<881> r->sector_count = len * s->cluster_size;\n<882> \n<883> break;\n<884> \n<885> case 0x0a:\n<886> \n<887> case 0x2a:\n<888> \n<889> case 0x8a:\n<890> \n<891> DPRINTF("Write (sector %" PRId64 ", count %d)\n", lba, len);\n<892> \n<893> if (lba > s->max_lba)\n<894> \n<895> goto illegal_lba;\n<896> \n<897> r->sector = lba * s->cluster_size;\n<898> \n<899> r->sector_count = len * s->cluster_size;\n<900> \n<901> is_write = 1;\n<902> \n<903> break;\n<904> \n<905> case 0x35:\n<906> \n<907> DPRINTF("Synchronise cache (sector %" PRId64 ", count %d)\n", lba, len);\n<908> \n<909> bdrv_flush(s->dinfo->bdrv);\n<910> \n<911> break;\n<912> \n<913> case 0x43:\n<914> \n<915> {\n<916> \n<917> int start_track, format, msf, toclen;\n<918> \n<919> \n<920> \n<921> msf = buf[1] & 2;\n<922> \n<923> format = buf[2] & 0xf;\n<924> \n<925> start_track = buf[6];\n<926> \n<927> bdrv_get_geometry(s->dinfo->bdrv, &nb_sectors);\n<928> \n<929> DPRINTF("Read TOC (track %d format %d msf %d)\n", start_track, format, msf >> 1);\n<930> \n<931> nb_sectors /= s->cluster_size;\n<932> \n<933> switch(format) {\n<934> \n<935> case 0:\n<936> \n<937> toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n<938> \n<939> break;\n<940> \n<941> case 1:\n<942> \n<943> /* multi session : only a single session defined */\n<944> \n<945> toclen = 12;\n<946> \n<947> memset(outbuf, 0, 12);\n<948> \n<949> outbuf[1] = 0x0a;\n<950> \n<951> outbuf[2] = 0x01;\n<952> \n<953> outbuf[3] = 0x01;\n<954> \n<955> break;\n<956> \n<957> case 2:\n<958> \n<959> toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n<960> \n<961> break;\n<962> \n<963> default:\n<964> \n<965> goto error_cmd;\n<966> \n<967> }\n<968> \n<969> if (toclen > 0) {\n<970> \n<971> if (len > toclen)\n<972> \n<973> len = toclen;\n<974> \n<975> r->iov.iov_len = len;\n<976> \n<977> break;\n<978> \n<979> }\n<980> \n<981> error_cmd:\n<982> \n<983> DPRINTF("Read TOC error\n");\n<984> \n<985> goto fail;\n<986> \n<987> }\n<988> \n<989> case 0x46:\n<990> \n<991> DPRINTF("Get Configuration (rt %d, maxlen %d)\n", buf[1] & 3, len);\n<992> \n<993> memset(outbuf, 0, 8);\n<994> \n<995> /* ??? This should probably return much more information.  For now\n<996> \n<997> just return the basic header indicating the CD-ROM profile.  */\n<998> \n<999> outbuf[7] = 8; // CD-ROM\n<1000> \n<1001> r->iov.iov_len = 8;\n<1002> \n<1003> break;\n<1004> \n<1005> case 0x56:\n<1006> \n<1007> DPRINTF("Reserve(10)\n");\n<1008> \n<1009> if (buf[1] & 3)\n<1010> \n<1011> goto fail;\n<1012> \n<1013> break;\n<1014> \n<1015> case 0x57:\n<1016> \n<1017> DPRINTF("Release(10)\n");\n<1018> \n<1019> if (buf[1] & 3)\n<1020> \n<1021> goto fail;\n<1022> \n<1023> break;\n<1024> \n<1025> case 0x9e:\n<1026> \n<1027> /* Service Action In subcommands. */\n<1028> \n<1029> if ((buf[1] & 31) == 0x10) {\n<1030> \n<1031> DPRINTF("SAI READ CAPACITY(16)\n");\n<1032> \n<1033> memset(outbuf, 0, len);\n<1034> \n<1035> bdrv_get_geometry(s->dinfo->bdrv, &nb_sectors);\n<1036> \n<1037> nb_sectors /= s->cluster_size;\n<1038> \n<1039> /* Returned value is the address of the last sector.  */\n<1040> \n<1041> if (nb_sectors) {\n<1042> \n<1043> nb_sectors--;\n<1044> \n<1045> /* Remember the new size for read/write sanity checking. */\n<1046> \n<1047> s->max_lba = nb_sectors;\n<1048> \n<1049> outbuf[0] = (nb_sectors >> 56) & 0xff;\n<1050> \n<1051> outbuf[1] = (nb_sectors >> 48) & 0xff;\n<1052> \n<1053> outbuf[2] = (nb_sectors >> 40) & 0xff;\n<1054> \n<1055> outbuf[3] = (nb_sectors >> 32) & 0xff;\n<1056> \n<1057> outbuf[4] = (nb_sectors >> 24) & 0xff;\n<1058> \n<1059> outbuf[5] = (nb_sectors >> 16) & 0xff;\n<1060> \n<1061> outbuf[6] = (nb_sectors >> 8) & 0xff;\n<1062> \n<1063> outbuf[7] = nb_sectors & 0xff;\n<1064> \n<1065> outbuf[8] = 0;\n<1066> \n<1067> outbuf[9] = 0;\n<1068> \n<1069> outbuf[10] = s->cluster_size * 2;\n<1070> \n<1071> outbuf[11] = 0;\n<1072> \n<1073> /* Protection, exponent and lowest lba field left blank. */\n<1074> \n<1075> r->iov.iov_len = len;\n<1076> \n<1077> } else {\n<1078> \n<1079> scsi_command_complete(r, STATUS_CHECK_CONDITION, SENSE_NOT_READY);\n<1080> \n<1081> return 0;\n<1082> \n<1083> }\n<1084> \n<1085> break;\n<1086> \n<1087> }\n<1088> \n<1089> DPRINTF("Unsupported Service Action In\n");\n<1090> \n<1091> goto fail;\n<1092> \n<1093> case 0xa0:\n<1094> \n<1095> DPRINTF("Report LUNs (len %d)\n", len);\n<1096> \n<1097> if (len < 16)\n<1098> \n<1099> goto fail;\n<1100> \n<1101> memset(outbuf, 0, 16);\n<1102> \n<1103> outbuf[3] = 8;\n<1104> \n<1105> r->iov.iov_len = 16;\n<1106> \n<1107> break;\n<1108> \n<1109> case 0x2f:\n<1110> \n<1111> DPRINTF("Verify (sector %" PRId64 ", count %d)\n", lba, len);\n<1112> \n<1113> break;\n<1114> \n<1115> default:\n<1116> \n<1117> DPRINTF("Unknown SCSI command (%2.2x)\n", buf[0]);\n<1118> \n<1119> fail:\n<1120> \n<1121> scsi_command_complete(r, STATUS_CHECK_CONDITION, SENSE_ILLEGAL_REQUEST);\n<1122> \n<1123> return 0;\n<1124> \n<1125> illegal_lba:\n<1126> \n<1127> scsi_command_complete(r, STATUS_CHECK_CONDITION, SENSE_HARDWARE_ERROR);\n<1128> \n<1129> return 0;\n<1130> \n<1131> }\n<1132> \n<1133> if (r->sector_count == 0 && r->iov.iov_len == 0) {\n<1134> \n<1135> scsi_command_complete(r, STATUS_GOOD, SENSE_NO_SENSE);\n<1136> \n<1137> }\n<1138> \n<1139> len = r->sector_count * 512 + r->iov.iov_len;\n<1140> \n<1141> if (is_write) {\n<1142> \n<1143> return -len;\n<1144> \n<1145> } else {\n<1146> \n<1147> if (!r->sector_count)\n<1148> \n<1149> r->sector_count = -1;\n<1150> \n<1151> return len;\n<1152> \n<1153> }\n<1154> \n<1155> }\n<1156> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void test_qemu_strtoull_negative(void)\n<2> \n<3> {\n<4> \n<5> const char *str = "  \t -321";\n<6> \n<7> char f = 'X';\n<8> \n<9> const char *endptr = &f;\n<10> \n<11> uint64_t res = 999;\n<12> \n<13> int err;\n<14> \n<15> \n<16> \n<17> err = qemu_strtoull(str, &endptr, 0, &res);\n<18> \n<19> \n<20> \n<21> g_assert_cmpint(err, ==, 0);\n<22> \n<23> g_assert_cmpint(res, ==, -321);\n<24> \n<25> g_assert(endptr == str + strlen(str));\n<26> \n<27> }\n<28> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void realview_init(ram_addr_t ram_size, int vga_ram_size,\n<2> \n<3> const char *boot_device, DisplayState *ds,\n<4> \n<5> const char *kernel_filename, const char *kernel_cmdline,\n<6> \n<7> const char *initrd_filename, const char *cpu_model)\n<8> \n<9> {\n<10> \n<11> CPUState *env;\n<12> \n<13> qemu_irq *pic;\n<14> \n<15> void *scsi_hba;\n<16> \n<17> PCIBus *pci_bus;\n<18> \n<19> NICInfo *nd;\n<20> \n<21> int n;\n<22> \n<23> int done_smc = 0;\n<24> \n<25> qemu_irq cpu_irq[4];\n<26> \n<27> int ncpu;\n<28> \n<29> int index;\n<30> \n<31> \n<32> \n<33> if (!cpu_model)\n<34> \n<35> cpu_model = "arm926";\n<36> \n<37> /* FIXME: obey smp_cpus.  */\n<38> \n<39> if (strcmp(cpu_model, "arm11mpcore") == 0) {\n<40> \n<41> ncpu = 4;\n<42> \n<43> } else {\n<44> \n<45> ncpu = 1;\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> for (n = 0; n < ncpu; n++) {\n<52> \n<53> env = cpu_init(cpu_model);\n<54> \n<55> if (!env) {\n<56> \n<57> fprintf(stderr, "Unable to find CPU definition\n");\n<58> \n<59> exit(1);\n<60> \n<61> }\n<62> \n<63> pic = arm_pic_init_cpu(env);\n<64> \n<65> cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];\n<66> \n<67> if (n > 0) {\n<68> \n<69> /* Set entry point for secondary CPUs.  This assumes we're using\n<70> \n<71> the init code from arm_boot.c.  Real hardware resets all CPUs\n<72> \n<73> the same.  */\n<74> \n<75> env->regs[15] = 0x80000000;\n<76> \n<77> }\n<78> \n<79> }\n<80> \n<81> \n<82> \n<83> /* ??? RAM should repeat to fill physical memory space.  */\n<84> \n<85> /* SDRAM at address zero.  */\n<86> \n<87> cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n<88> \n<89> \n<90> \n<91> arm_sysctl_init(0x10000000, 0xc1400400);\n<92> \n<93> \n<94> \n<95> if (ncpu == 1) {\n<96> \n<97> /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\n<98> \n<99> is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\n<100> \n<101> GIC1 to be nIRQ and ignores all the others, so do that for now.  */\n<102> \n<103> pic = realview_gic_init(0x10040000, cpu_irq[0]);\n<104> \n<105> } else {\n<106> \n<107> pic = mpcore_irq_init(cpu_irq);\n<108> \n<109> }\n<110> \n<111> \n<112> \n<113> pl050_init(0x10006000, pic[20], 0);\n<114> \n<115> pl050_init(0x10007000, pic[21], 1);\n<116> \n<117> \n<118> \n<119> pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);\n<120> \n<121> pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);\n<122> \n<123> pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);\n<124> \n<125> pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);\n<126> \n<127> \n<128> \n<129> /* DMA controller is optional, apparently.  */\n<130> \n<131> pl080_init(0x10030000, pic[24], 2);\n<132> \n<133> \n<134> \n<135> sp804_init(0x10011000, pic[4]);\n<136> \n<137> sp804_init(0x10012000, pic[5]);\n<138> \n<139> \n<140> \n<141> pl110_init(ds, 0x10020000, pic[23], 1);\n<142> \n<143> \n<144> \n<145> index = drive_get_index(IF_SD, 0, 0);\n<146> \n<147> if (index == -1) {\n<148> \n<149> fprintf(stderr, "qemu: missing SecureDigital card\n");\n<150> \n<151> exit(1);\n<152> \n<153> }\n<154> \n<155> pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);\n<156> \n<157> \n<158> \n<159> pl031_init(0x10017000, pic[10]);\n<160> \n<161> \n<162> \n<163> pci_bus = pci_vpb_init(pic, 48, 1);\n<164> \n<165> if (usb_enabled) {\n<166> \n<167> usb_ohci_init_pci(pci_bus, 3, -1);\n<168> \n<169> }\n<170> \n<171> if (drive_get_max_bus(IF_SCSI) > 0) {\n<172> \n<173> fprintf(stderr, "qemu: too many SCSI bus\n");\n<174> \n<175> exit(1);\n<176> \n<177> }\n<178> \n<179> scsi_hba = lsi_scsi_init(pci_bus, -1);\n<180> \n<181> for (n = 0; n < LSI_MAX_DEVS; n++) {\n<182> \n<183> index = drive_get_index(IF_SCSI, 0, n);\n<184> \n<185> if (index == -1)\n<186> \n<187> continue;\n<188> \n<189> lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n<190> \n<191> }\n<192> \n<193> for(n = 0; n < nb_nics; n++) {\n<194> \n<195> nd = &nd_table[n];\n<196> \n<197> if (!nd->model)\n<198> \n<199> nd->model = done_smc ? "rtl8139" : "smc91c111";\n<200> \n<201> if (strcmp(nd->model, "smc91c111") == 0) {\n<202> \n<203> smc91c111_init(nd, 0x4e000000, pic[28]);\n<204> \n<205> } else {\n<206> \n<207> pci_nic_init(pci_bus, nd, -1);\n<208> \n<209> }\n<210> \n<211> }\n<212> \n<213> \n<214> \n<215> /* Memory map for RealView Emulation Baseboard:  */\n<216> \n<217> /* 0x10000000 System registers.  */\n<218> \n<219> /*  0x10001000 System controller.  */\n<220> \n<221> /*  0x10002000 Two-Wire Serial Bus.  */\n<222> \n<223> /* 0x10003000 Reserved.  */\n<224> \n<225> /*  0x10004000 AACI.  */\n<226> \n<227> /*  0x10005000 MCI.  */\n<228> \n<229> /* 0x10006000 KMI0.  */\n<230> \n<231> /* 0x10007000 KMI1.  */\n<232> \n<233> /*  0x10008000 Character LCD.  */\n<234> \n<235> /* 0x10009000 UART0.  */\n<236> \n<237> /* 0x1000a000 UART1.  */\n<238> \n<239> /* 0x1000b000 UART2.  */\n<240> \n<241> /* 0x1000c000 UART3.  */\n<242> \n<243> /*  0x1000d000 SSPI.  */\n<244> \n<245> /*  0x1000e000 SCI.  */\n<246> \n<247> /* 0x1000f000 Reserved.  */\n<248> \n<249> /*  0x10010000 Watchdog.  */\n<250> \n<251> /* 0x10011000 Timer 0+1.  */\n<252> \n<253> /* 0x10012000 Timer 2+3.  */\n<254> \n<255> /*  0x10013000 GPIO 0.  */\n<256> \n<257> /*  0x10014000 GPIO 1.  */\n<258> \n<259> /*  0x10015000 GPIO 2.  */\n<260> \n<261> /* 0x10016000 Reserved.  */\n<262> \n<263> /* 0x10017000 RTC.  */\n<264> \n<265> /*  0x10018000 DMC.  */\n<266> \n<267> /*  0x10019000 PCI controller config.  */\n<268> \n<269> /*  0x10020000 CLCD.  */\n<270> \n<271> /* 0x10030000 DMA Controller.  */\n<272> \n<273> /* 0x10040000 GIC1.  */\n<274> \n<275> /* 0x10050000 GIC2.  */\n<276> \n<277> /* 0x10060000 GIC3.  */\n<278> \n<279> /* 0x10070000 GIC4.  */\n<280> \n<281> /*  0x10080000 SMC.  */\n<282> \n<283> /*  0x40000000 NOR flash.  */\n<284> \n<285> /*  0x44000000 DoC flash.  */\n<286> \n<287> /*  0x48000000 SRAM.  */\n<288> \n<289> /*  0x4c000000 Configuration flash.  */\n<290> \n<291> /* 0x4e000000 Ethernet.  */\n<292> \n<293> /*  0x4f000000 USB.  */\n<294> \n<295> /*  0x50000000 PISMO.  */\n<296> \n<297> /*  0x54000000 PISMO.  */\n<298> \n<299> /*  0x58000000 PISMO.  */\n<300> \n<301> /*  0x5c000000 PISMO.  */\n<302> \n<303> /* 0x60000000 PCI.  */\n<304> \n<305> /* 0x61000000 PCI Self Config.  */\n<306> \n<307> /* 0x62000000 PCI Config.  */\n<308> \n<309> /* 0x63000000 PCI IO.  */\n<310> \n<311> /* 0x64000000 PCI mem 0.  */\n<312> \n<313> /* 0x68000000 PCI mem 1.  */\n<314> \n<315> /* 0x6c000000 PCI mem 2.  */\n<316> \n<317> \n<318> \n<319> realview_binfo.ram_size = ram_size;\n<320> \n<321> realview_binfo.kernel_filename = kernel_filename;\n<322> \n<323> realview_binfo.kernel_cmdline = kernel_cmdline;\n<324> \n<325> realview_binfo.initrd_filename = initrd_filename;\n<326> \n<327> realview_binfo.nb_cpus = ncpu;\n<328> \n<329> arm_load_kernel(first_cpu, &realview_binfo);\n<330> \n<331> \n<332> \n<333> /* ??? Hack to map an additional page of ram for the secondary CPU\n<334> \n<335> startup code.  I guess this works on real hardware because the\n<336> \n<337> BootROM happens to be in ROM/flash or in memory that isn't clobbered\n<338> \n<339> until after Linux boots the secondary CPUs.  */\n<340> \n<341> cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n<342> \n<343> }\n<344> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void omap_mcbsp_writew(void *opaque, target_phys_addr_t addr,\n<2> \n<3> uint32_t value)\n<4> \n<5> {\n<6> \n<7> struct omap_mcbsp_s *s = (struct omap_mcbsp_s *) opaque;\n<8> \n<9> int offset = addr & OMAP_MPUI_REG_MASK;\n<10> \n<11> \n<12> \n<13> if (offset == 0x04) {				/* DXR */\n<14> \n<15> if (((s->xcr[0] >> 5) & 7) < 3)			/* XWDLEN1 */\n<16> \n<17> return;\n<18> \n<19> if (s->tx_req > 3) {\n<20> \n<21> s->tx_req -= 4;\n<22> \n<23> if (s->codec && s->codec->cts) {\n<24> \n<25> s->codec->out.fifo[s->codec->out.len ++] =\n<26> \n<27> (value >> 24) & 0xff;\n<28> \n<29> s->codec->out.fifo[s->codec->out.len ++] =\n<30> \n<31> (value >> 16) & 0xff;\n<32> \n<33> s->codec->out.fifo[s->codec->out.len ++] =\n<34> \n<35> (value >> 8) & 0xff;\n<36> \n<37> s->codec->out.fifo[s->codec->out.len ++] =\n<38> \n<39> (value >> 0) & 0xff;\n<40> \n<41> }\n<42> \n<43> if (s->tx_req < 4)\n<44> \n<45> omap_mcbsp_tx_done(s);\n<46> \n<47> } else\n<48> \n<49> printf("%s: Tx FIFO overrun\n", __FUNCTION__);\n<50> \n<51> return;\n<52> \n<53> }\n<54> \n<55> \n<56> \n<57> omap_badwidth_write16(opaque, addr, value);\n<58> \n<59> }\n<60> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void seek_to_maindata(MPADecodeContext *s, long backstep)\n<2> \n<3> {\n<4> \n<5> UINT8 *ptr;\n<6> \n<7> \n<8> \n<9> /* compute current position in stream */\n<10> \n<11> ptr = s->gb.buffer + (get_bits_count(&s->gb)>>3);\n<12> \n<13> \n<14> \n<15> /* copy old data before current one */\n<16> \n<17> ptr -= backstep;\n<18> \n<19> memcpy(ptr, s->inbuf1[s->inbuf_index ^ 1] +\n<20> \n<21> BACKSTEP_SIZE + s->old_frame_size - backstep, backstep);\n<22> \n<23> /* init get bits again */\n<24> \n<25> init_get_bits(&s->gb, ptr, s->frame_size + backstep);\n<26> \n<27> \n<28> \n<29> /* prepare next buffer */\n<30> \n<31> s->inbuf_index ^= 1;\n<32> \n<33> s->inbuf = &s->inbuf1[s->inbuf_index][BACKSTEP_SIZE];\n<34> \n<35> s->old_frame_size = s->frame_size;\n<36> \n<37> }\n<38> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int gxf_probe(AVProbeData *p) {\n<2> \n<3> static const uint8_t startcode[] = {0, 0, 0, 0, 1, 0xbc}; // start with map packet\n<4> \n<5> static const uint8_t endcode[] = {0, 0, 0, 0, 0xe1, 0xe2};\n<6> \n<7> if (p->buf_size < 16)\n<8> \n<9> return 0;\n<10> \n<11> if (!memcmp(p->buf, startcode, sizeof(startcode)) &&\n<12> \n<13> !memcmp(&p->buf[16 - sizeof(endcode)], endcode, sizeof(endcode)))\n<14> \n<15> return AVPROBE_SCORE_MAX;\n<16> \n<17> return 0;\n<18> \n<19> }\n<20> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_hevc_split_packet(HEVCContext *s, HEVCPacket *pkt, const uint8_t *buf, int length,\n<2> \n<3> AVCodecContext *avctx, int is_nalff, int nal_length_size)\n<4> \n<5> {\n<6> \n<7> int consumed, ret = 0;\n<8> \n<9> \n<10> \n<11> pkt->nb_nals = 0;\n<12> \n<13> while (length >= 4) {\n<14> \n<15> HEVCNAL *nal;\n<16> \n<17> int extract_length = 0;\n<18> \n<19> \n<20> \n<21> if (is_nalff) {\n<22> \n<23> int i;\n<24> \n<25> for (i = 0; i < nal_length_size; i++)\n<26> \n<27> extract_length = (extract_length << 8) | buf[i];\n<28> \n<29> buf    += nal_length_size;\n<30> \n<31> length -= nal_length_size;\n<32> \n<33> \n<34> \n<35> if (extract_length > length) {\n<36> \n<37> av_log(avctx, AV_LOG_ERROR, "Invalid NAL unit size.\n");\n<38> \n<39> return AVERROR_INVALIDDATA;\n<40> \n<41> }\n<42> \n<43> } else {\n<44> \n<45> /* search start code */\n<46> \n<47> while (buf[0] != 0 || buf[1] != 0 || buf[2] != 1) {\n<48> \n<49> ++buf;\n<50> \n<51> --length;\n<52> \n<53> if (length < 4) {\n<54> \n<55> if (pkt->nb_nals > 0) {\n<56> \n<57> // No more start codes: we discarded some irrelevant\n<58> \n<59> // bytes at the end of the packet.\n<60> \n<61> return 0;\n<62> \n<63> } else {\n<64> \n<65> av_log(avctx, AV_LOG_ERROR, "No start code is found.\n");\n<66> \n<67> return AVERROR_INVALIDDATA;\n<68> \n<69> }\n<70> \n<71> }\n<72> \n<73> }\n<74> \n<75> \n<76> \n<77> buf           += 3;\n<78> \n<79> length        -= 3;\n<80> \n<81> extract_length = length;\n<82> \n<83> }\n<84> \n<85> \n<86> \n<87> if (pkt->nals_allocated < pkt->nb_nals + 1) {\n<88> \n<89> int new_size = pkt->nals_allocated + 1;\n<90> \n<91> void *tmp = av_realloc_array(pkt->nals, new_size, sizeof(*pkt->nals));\n<92> \n<93> \n<94> \n<95> if (!tmp)\n<96> \n<97> return AVERROR(ENOMEM);\n<98> \n<99> \n<100> \n<101> pkt->nals = tmp;\n<102> \n<103> memset(pkt->nals + pkt->nals_allocated, 0,\n<104> \n<105> (new_size - pkt->nals_allocated) * sizeof(*pkt->nals));\n<106> \n<107> \n<108> \n<109> nal = &pkt->nals[pkt->nb_nals];\n<110> \n<111> nal->skipped_bytes_pos_size = 1024; // initial buffer size\n<112> \n<113> nal->skipped_bytes_pos = av_malloc_array(nal->skipped_bytes_pos_size, sizeof(*nal->skipped_bytes_pos));\n<114> \n<115> if (!nal->skipped_bytes_pos)\n<116> \n<117> return AVERROR(ENOMEM);\n<118> \n<119> \n<120> \n<121> pkt->nals_allocated = new_size;\n<122> \n<123> }\n<124> \n<125> nal = &pkt->nals[pkt->nb_nals];\n<126> \n<127> \n<128> \n<129> consumed = ff_hevc_extract_rbsp(s, buf, extract_length, nal);\n<130> \n<131> if (consumed < 0)\n<132> \n<133> return consumed;\n<134> \n<135> \n<136> \n<137> pkt->nb_nals++;\n<138> \n<139> \n<140> \n<141> ret = init_get_bits8(&nal->gb, nal->data, nal->size);\n<142> \n<143> if (ret < 0)\n<144> \n<145> return ret;\n<146> \n<147> \n<148> \n<149> ret = hls_nal_unit(nal, avctx);\n<150> \n<151> if (ret <= 0) {\n<152> \n<153> if (ret < 0) {\n<154> \n<155> av_log(avctx, AV_LOG_ERROR, "Invalid NAL unit %d, skipping.\n",\n<156> \n<157> nal->type);\n<158> \n<159> }\n<160> \n<161> pkt->nb_nals--;\n<162> \n<163> }\n<164> \n<165> \n<166> \n<167> buf    += consumed;\n<168> \n<169> length -= consumed;\n<170> \n<171> }\n<172> \n<173> \n<174> \n<175> return 0;\n<176> \n<177> }\n<178> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void reset_contexts(SnowContext *s){\n<2> \n<3> int plane_index, level, orientation;\n<4> \n<5> \n<6> \n<7> for(plane_index=0; plane_index<2; plane_index++){\n<8> \n<9> for(level=0; level<s->spatial_decomposition_count; level++){\n<10> \n<11> for(orientation=level ? 1:0; orientation<4; orientation++){\n<12> \n<13> memset(s->plane[plane_index].band[level][orientation].state, 0, sizeof(s->plane[plane_index].band[level][orientation].state));\n<14> \n<15> }\n<16> \n<17> }\n<18> \n<19> }\n<20> \n<21> memset(s->mb_band.state, 0, sizeof(s->mb_band.state));\n<22> \n<23> memset(s->mv_band[0].state, 0, sizeof(s->mv_band[0].state));\n<24> \n<25> memset(s->mv_band[1].state, 0, sizeof(s->mv_band[1].state));\n<26> \n<27> memset(s->header_state, 0, sizeof(s->header_state));\n<28> \n<29> }\n<30> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n<2> free ( g ) ;\n<3> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> const uint8_t * buf = avpkt -> data ;\n<3> int ret , buf_size = avpkt -> size ;\n<4> XanContext * s = avctx -> priv_data ;\n<5> GetByteContext ctx ;\n<6> int tag = 0 ;\n<7> bytestream2_init ( & ctx , buf , buf_size ) ;\n<8> while ( bytestream2_get_bytes_left ( & ctx ) > 8 && tag != VGA__TAG ) {\n<9> unsigned * tmpptr ;\n<10> uint32_t new_pal ;\n<11> int size ;\n<12> int i ;\n<13> tag = bytestream2_get_le32 ( & ctx ) ;\n<14> size = bytestream2_get_be32 ( & ctx ) ;\n<15> size = FFMIN ( size , bytestream2_get_bytes_left ( & ctx ) ) ;\n<16> switch ( tag ) {\n<17> case PALT_TAG : if ( size < PALETTE_SIZE ) return AVERROR_INVALIDDATA ;\n<18> if ( s -> palettes_count >= PALETTES_MAX ) return AVERROR_INVALIDDATA ;\n<19> tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n<20> if ( ! tmpptr ) return AVERROR ( ENOMEM ) ;\n<21> s -> palettes = tmpptr ;\n<22> tmpptr += s -> palettes_count * AVPALETTE_COUNT ;\n<23> for ( i = 0 ;\n<24> i < PALETTE_COUNT ;\n<25> i ++ ) {\n<26> # if RUNTIME_GAMMA int r = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n<27> int g = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n<28> int b = gamma_corr ( bytestream2_get_byteu ( & ctx ) ) ;\n<29> # else int r = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n<30> int g = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n<31> int b = gamma_lookup [ bytestream2_get_byteu ( & ctx ) ] ;\n<32> # endif * tmpptr ++ = ( r << 16 ) | ( g << 8 ) | b ;\n<33> }\n<34> s -> palettes_count ++ ;\n<35> break ;\n<36> case SHOT_TAG : if ( size < 4 ) return AVERROR_INVALIDDATA ;\n<37> new_pal = bytestream2_get_le32 ( & ctx ) ;\n<38> if ( new_pal < s -> palettes_count ) {\n<39> s -> cur_palette = new_pal ;\n<40> }\n<41> else av_log ( avctx , AV_LOG_ERROR , "Invalid palette selected\n" ) ;\n<42> break ;\n<43> case VGA__TAG : break ;\n<44> default : bytestream2_skip ( & ctx , size ) ;\n<45> break ;\n<46> }\n<47> }\n<48> buf_size = bytestream2_get_bytes_left ( & ctx ) ;\n<49> if ( s -> palettes_count <= 0 ) {\n<50> av_log ( s -> avctx , AV_LOG_ERROR , "No palette found\n" ) ;\n<51> return AVERROR_INVALIDDATA ;\n<52> }\n<53> if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) ) {\n<54> av_log ( s -> avctx , AV_LOG_ERROR , "get_buffer() failed\n" ) ;\n<55> return ret ;\n<56> }\n<57> s -> current_frame . reference = 3 ;\n<58> if ( ! s -> frame_size ) s -> frame_size = s -> current_frame . linesize [ 0 ] * s -> avctx -> height ;\n<59> memcpy ( s -> current_frame . data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;\n<60> s -> buf = ctx . buffer ;\n<61> s -> size = buf_size ;\n<62> if ( xan_wc3_decode_frame ( s ) < 0 ) return AVERROR_INVALIDDATA ;\n<63> if ( s -> last_frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> last_frame ) ;\n<64> * got_frame = 1 ;\n<65> * ( AVFrame * ) data = s -> current_frame ;\n<66> FFSWAP ( AVFrame , s -> current_frame , s -> last_frame ) ;\n<67> return buf_size ;\n<68> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n<2> BMVDecContext * const c = avctx -> priv_data ;\n<3> int type , scr_off ;\n<4> int i , ret ;\n<5> uint8_t * srcptr , * outptr ;\n<6> c -> stream = pkt -> data ;\n<7> type = bytestream_get_byte ( & c -> stream ) ;\n<8> if ( type & BMV_AUDIO ) {\n<9> int blobs = bytestream_get_byte ( & c -> stream ) ;\n<10> if ( pkt -> size < blobs * 65 + 2 ) {\n<11> av_log ( avctx , AV_LOG_ERROR , "Audio data doesn't fit in frame\n" ) ;\n<12> return AVERROR_INVALIDDATA ;\n<13> }\n<14> c -> stream += blobs * 65 ;\n<15> }\n<16> if ( type & BMV_COMMAND ) {\n<17> int command_size = ( type & BMV_PRINT ) ? 8 : 10 ;\n<18> if ( c -> stream - pkt -> data + command_size > pkt -> size ) {\n<19> av_log ( avctx , AV_LOG_ERROR , "Command data doesn't fit in frame\n" ) ;\n<20> return AVERROR_INVALIDDATA ;\n<21> }\n<22> c -> stream += command_size ;\n<23> }\n<24> if ( type & BMV_PALETTE ) {\n<25> if ( c -> stream - pkt -> data > pkt -> size - 768 ) {\n<26> av_log ( avctx , AV_LOG_ERROR , "Palette data doesn't fit in frame\n" ) ;\n<27> return AVERROR_INVALIDDATA ;\n<28> }\n<29> for ( i = 0 ;\n<30> i < 256 ;\n<31> i ++ ) c -> pal [ i ] = bytestream_get_be24 ( & c -> stream ) ;\n<32> }\n<33> if ( type & BMV_SCROLL ) {\n<34> if ( c -> stream - pkt -> data > pkt -> size - 2 ) {\n<35> av_log ( avctx , AV_LOG_ERROR , "Screen offset data doesn't fit in frame\n" ) ;\n<36> return AVERROR_INVALIDDATA ;\n<37> }\n<38> scr_off = ( int16_t ) bytestream_get_le16 ( & c -> stream ) ;\n<39> }\n<40> else if ( ( type & BMV_INTRA ) == BMV_INTRA ) {\n<41> scr_off = - 640 ;\n<42> }\n<43> else {\n<44> scr_off = 0 ;\n<45> }\n<46> if ( c -> pic . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> pic ) ;\n<47> c -> pic . reference = 3 ;\n<48> if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n<49> av_log ( avctx , AV_LOG_ERROR , "get_buffer() failed\n" ) ;\n<50> return ret ;\n<51> }\n<52> if ( decode_bmv_frame ( c -> stream , pkt -> size - ( c -> stream - pkt -> data ) , c -> frame , scr_off ) ) {\n<53> av_log ( avctx , AV_LOG_ERROR , "Error decoding frame data\n" ) ;\n<54> return AVERROR_INVALIDDATA ;\n<55> }\n<56> memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n<57> c -> pic . palette_has_changed = type & BMV_PALETTE ;\n<58> outptr = c -> pic . data [ 0 ] ;\n<59> srcptr = c -> frame ;\n<60> for ( i = 0 ;\n<61> i < avctx -> height ;\n<62> i ++ ) {\n<63> memcpy ( outptr , srcptr , avctx -> width ) ;\n<64> srcptr += avctx -> width ;\n<65> outptr += c -> pic . linesize [ 0 ] ;\n<66> }\n<67> * got_frame = 1 ;\n<68> * ( AVFrame * ) data = c -> pic ;\n<69> return pkt -> size ;\n<70> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int decode(AVCodecContext *avctx, void *data, int *got_sub, AVPacket *avpkt)\n<2> \n<3> {\n<4> \n<5> CCaptionSubContext *ctx = avctx->priv_data;\n<6> \n<7> AVSubtitle *sub = data;\n<8> \n<9> const int64_t start_time = sub->pts;\n<10> \n<11> uint8_t *bptr = NULL;\n<12> \n<13> int len = avpkt->size;\n<14> \n<15> int ret = 0;\n<16> \n<17> int i;\n<18> \n<19> \n<20> \n<21> if (ctx->pktbuf->size < len) {\n<22> \n<23> ret = av_buffer_realloc(&ctx->pktbuf, len);\n<24> \n<25> if (ret < 0) {\n<26> \n<27> av_log(ctx, AV_LOG_WARNING, "Insufficient Memory of %d truncated to %d\n", len, ctx->pktbuf->size);\n<28> \n<29> len = ctx->pktbuf->size;\n<30> \n<31> ret = 0;\n<32> \n<33> }\n<34> \n<35> }\n<36> \n<37> memcpy(ctx->pktbuf->data, avpkt->data, len);\n<38> \n<39> bptr = ctx->pktbuf->data;\n<40> \n<41> \n<42> \n<43> for (i  = 0; i < len; i += 3) {\n<44> \n<45> uint8_t cc_type = *(bptr + i) & 3;\n<46> \n<47> if (validate_cc_data_pair(bptr + i))\n<48> \n<49> continue;\n<50> \n<51> /* ignoring data field 1 */\n<52> \n<53> if(cc_type == 1)\n<54> \n<55> continue;\n<56> \n<57> else\n<58> \n<59> process_cc608(ctx, start_time, *(bptr + i + 1) & 0x7f, *(bptr + i + 2) & 0x7f);\n<60> \n<61> \n<62> \n<63> if (!ctx->buffer_changed)\n<64> \n<65> continue;\n<66> \n<67> ctx->buffer_changed = 0;\n<68> \n<69> \n<70> \n<71> if (*ctx->buffer.str || ctx->real_time)\n<72> \n<73> {\n<74> \n<75> ff_dlog(ctx, "cdp writing data (%s)\n",ctx->buffer.str);\n<76> \n<77> ret = ff_ass_add_rect(sub, ctx->buffer.str, ctx->readorder++, 0, NULL, NULL);\n<78> \n<79> if (ret < 0)\n<80> \n<81> return ret;\n<82> \n<83> sub->pts = ctx->start_time;\n<84> \n<85> if (!ctx->real_time)\n<86> \n<87> sub->end_display_time = av_rescale_q(ctx->end_time - ctx->start_time,\n<88> \n<89> AV_TIME_BASE_Q, ms_tb);\n<90> \n<91> else\n<92> \n<93> sub->end_display_time = -1;\n<94> \n<95> ctx->buffer_changed = 0;\n<96> \n<97> ctx->last_real_time = sub->pts;\n<98> \n<99> ctx->screen_touched = 0;\n<100> \n<101> }\n<102> \n<103> }\n<104> \n<105> \n<106> \n<107> if (ctx->real_time && ctx->screen_touched &&\n<108> \n<109> sub->pts > ctx->last_real_time + av_rescale_q(200, ms_tb, AV_TIME_BASE_Q)) {\n<110> \n<111> ctx->last_real_time = sub->pts;\n<112> \n<113> ctx->screen_touched = 0;\n<114> \n<115> \n<116> \n<117> capture_screen(ctx);\n<118> \n<119> ctx->buffer_changed = 0;\n<120> \n<121> \n<122> \n<123> ret = ff_ass_add_rect(sub, ctx->buffer.str, ctx->readorder++, 0, NULL, NULL);\n<124> \n<125> if (ret < 0)\n<126> \n<127> return ret;\n<128> \n<129> sub->end_display_time = -1;\n<130> \n<131> }\n<132> \n<133> \n<134> \n<135> *got_sub = sub->num_rects > 0;\n<136> \n<137> return ret;\n<138> \n<139> }\n<140> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void set_svc_parameters ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx ) {\n<2> int layer , layer_index ;\n<3> vpx_svc_parameters_t svc_params ;\n<4> SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n<5> memset ( & svc_params , 0 , sizeof ( svc_params ) ) ;\n<6> svc_params . temporal_layer = 0 ;\n<7> svc_params . spatial_layer = si -> layer ;\n<8> layer = si -> layer ;\n<9> if ( VPX_CODEC_OK != vpx_svc_get_layer_resolution ( svc_ctx , layer , & svc_params . width , & svc_params . height ) ) {\n<10> svc_log ( svc_ctx , SVC_LOG_ERROR , "vpx_svc_get_layer_resolution failed\n" ) ;\n<11> }\n<12> layer_index = layer + VPX_SS_MAX_LAYERS - si -> layers ;\n<13> if ( codec_ctx -> config . enc -> g_pass == VPX_RC_ONE_PASS ) {\n<14> svc_params . min_quantizer = si -> quantizer [ layer_index ] ;\n<15> svc_params . max_quantizer = si -> quantizer [ layer_index ] ;\n<16> }\n<17> else {\n<18> svc_params . min_quantizer = codec_ctx -> config . enc -> rc_min_quantizer ;\n<19> svc_params . max_quantizer = codec_ctx -> config . enc -> rc_max_quantizer ;\n<20> }\n<21> svc_params . distance_from_i_frame = si -> frame_within_gop ;\n<22> vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & svc_params ) ;\n<23> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int qemu_rbd_open(BlockDriverState *bs, const char *filename, int flags)\n<2> \n<3> {\n<4> \n<5> BDRVRBDState *s = bs->opaque;\n<6> \n<7> char pool[RBD_MAX_POOL_NAME_SIZE];\n<8> \n<9> char snap_buf[RBD_MAX_SNAP_NAME_SIZE];\n<10> \n<11> char conf[RBD_MAX_CONF_SIZE];\n<12> \n<13> int r;\n<14> \n<15> \n<16> \n<17> if (qemu_rbd_parsename(filename, pool, sizeof(pool),\n<18> \n<19> snap_buf, sizeof(snap_buf),\n<20> \n<21> s->name, sizeof(s->name),\n<22> \n<23> conf, sizeof(conf)) < 0) {\n<24> \n<25> return -EINVAL;\n<26> \n<27> }\n<28> \n<29> s->snap = NULL;\n<30> \n<31> if (snap_buf[0] != '\0') {\n<32> \n<33> s->snap = g_strdup(snap_buf);\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> r = rados_create(&s->cluster, NULL);\n<40> \n<41> if (r < 0) {\n<42> \n<43> error_report("error initializing");\n<44> \n<45> return r;\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> if (strstr(conf, "conf=") == NULL) {\n<52> \n<53> r = rados_conf_read_file(s->cluster, NULL);\n<54> \n<55> if (r < 0) {\n<56> \n<57> error_report("error reading config file");\n<58> \n<59> rados_shutdown(s->cluster);\n<60> \n<61> return r;\n<62> \n<63> }\n<64> \n<65> }\n<66> \n<67> \n<68> \n<69> if (conf[0] != '\0') {\n<70> \n<71> r = qemu_rbd_set_conf(s->cluster, conf);\n<72> \n<73> if (r < 0) {\n<74> \n<75> error_report("error setting config options");\n<76> \n<77> rados_shutdown(s->cluster);\n<78> \n<79> return r;\n<80> \n<81> }\n<82> \n<83> }\n<84> \n<85> \n<86> \n<87> r = rados_connect(s->cluster);\n<88> \n<89> if (r < 0) {\n<90> \n<91> error_report("error connecting");\n<92> \n<93> rados_shutdown(s->cluster);\n<94> \n<95> return r;\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> r = rados_ioctx_create(s->cluster, pool, &s->io_ctx);\n<102> \n<103> if (r < 0) {\n<104> \n<105> error_report("error opening pool %s", pool);\n<106> \n<107> rados_shutdown(s->cluster);\n<108> \n<109> return r;\n<110> \n<111> }\n<112> \n<113> \n<114> \n<115> r = rbd_open(s->io_ctx, s->name, &s->image, s->snap);\n<116> \n<117> if (r < 0) {\n<118> \n<119> error_report("error reading header from %s", s->name);\n<120> \n<121> rados_ioctx_destroy(s->io_ctx);\n<122> \n<123> rados_shutdown(s->cluster);\n<124> \n<125> return r;\n<126> \n<127> }\n<128> \n<129> \n<130> \n<131> bs->read_only = (s->snap != NULL);\n<132> \n<133> \n<134> \n<135> s->event_reader_pos = 0;\n<136> \n<137> r = qemu_pipe(s->fds);\n<138> \n<139> if (r < 0) {\n<140> \n<141> error_report("error opening eventfd");\n<142> \n<143> goto failed;\n<144> \n<145> }\n<146> \n<147> fcntl(s->fds[0], F_SETFL, O_NONBLOCK);\n<148> \n<149> fcntl(s->fds[1], F_SETFL, O_NONBLOCK);\n<150> \n<151> qemu_aio_set_fd_handler(s->fds[RBD_FD_READ], qemu_rbd_aio_event_reader,\n<152> \n<153> NULL, qemu_rbd_aio_flush_cb, NULL, s);\n<154> \n<155> \n<156> \n<157> \n<158> \n<159> return 0;\n<160> \n<161> \n<162> \n<163> failed:\n<164> \n<165> rbd_close(s->image);\n<166> \n<167> rados_ioctx_destroy(s->io_ctx);\n<168> \n<169> rados_shutdown(s->cluster);\n<170> \n<171> return r;\n<172> \n<173> }\n<174> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int av_probe_input_buffer2(AVIOContext *pb, AVInputFormat **fmt,\n<2> \n<3> const char *filename, void *logctx,\n<4> \n<5> unsigned int offset, unsigned int max_probe_size)\n<6> \n<7> {\n<8> \n<9> AVProbeData pd = { filename ? filename : "" };\n<10> \n<11> uint8_t *buf = NULL;\n<12> \n<13> uint8_t *mime_type;\n<14> \n<15> int ret = 0, probe_size, buf_offset = 0;\n<16> \n<17> int score = 0;\n<18> \n<19> \n<20> \n<21> if (!max_probe_size)\n<22> \n<23> max_probe_size = PROBE_BUF_MAX;\n<24> \n<25> else if (max_probe_size < PROBE_BUF_MIN) {\n<26> \n<27> av_log(logctx, AV_LOG_ERROR,\n<28> \n<29> "Specified probe size value %u cannot be < %u\n", max_probe_size, PROBE_BUF_MIN);\n<30> \n<31> return AVERROR(EINVAL);\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> if (offset >= max_probe_size)\n<38> \n<39> return AVERROR(EINVAL);\n<40> \n<41> \n<42> \n<43> #ifdef FF_API_PROBE_MIME\n<44> \n<45> if (pb->av_class)\n<46> \n<47> av_opt_get(pb, "mime_type", AV_OPT_SEARCH_CHILDREN, &pd.mime_type);\n<48> \n<49> #endif\n<50> \n<51> \n<52> \n<53> #if !FF_API_PROBE_MIME\n<54> \n<55> if (!*fmt && pb->av_class && av_opt_get(pb, "mime_type", AV_OPT_SEARCH_CHILDREN, &mime_type) >= 0 && mime_type) {\n<56> \n<57> if (!av_strcasecmp(mime_type, "audio/aacp")) {\n<58> \n<59> *fmt = av_find_input_format("aac");\n<60> \n<61> }\n<62> \n<63> av_freep(&mime_type);\n<64> \n<65> }\n<66> \n<67> #endif\n<68> \n<69> \n<70> \n<71> for (probe_size = PROBE_BUF_MIN; probe_size <= max_probe_size && !*fmt;\n<72> \n<73> probe_size = FFMIN(probe_size << 1,\n<74> \n<75> FFMAX(max_probe_size, probe_size + 1))) {\n<76> \n<77> score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;\n<78> \n<79> \n<80> \n<81> /* Read probe data. */\n<82> \n<83> if ((ret = av_reallocp(&buf, probe_size + AVPROBE_PADDING_SIZE)) < 0)\n<84> \n<85> goto fail;\n<86> \n<87> if ((ret = avio_read(pb, buf + buf_offset,\n<88> \n<89> probe_size - buf_offset)) < 0) {\n<90> \n<91> /* Fail if error was not end of file, otherwise, lower score. */\n<92> \n<93> if (ret != AVERROR_EOF)\n<94> \n<95> goto fail;\n<96> \n<97> \n<98> \n<99> score = 0;\n<100> \n<101> ret   = 0;          /* error was end of file, nothing read */\n<102> \n<103> }\n<104> \n<105> buf_offset += ret;\n<106> \n<107> if (buf_offset < offset)\n<108> \n<109> continue;\n<110> \n<111> pd.buf_size = buf_offset - offset;\n<112> \n<113> pd.buf = &buf[offset];\n<114> \n<115> \n<116> \n<117> memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n<118> \n<119> \n<120> \n<121> /* Guess file format. */\n<122> \n<123> *fmt = av_probe_input_format2(&pd, 1, &score);\n<124> \n<125> if (*fmt) {\n<126> \n<127> /* This can only be true in the last iteration. */\n<128> \n<129> if (score <= AVPROBE_SCORE_RETRY) {\n<130> \n<131> av_log(logctx, AV_LOG_WARNING,\n<132> \n<133> "Format %s detected only with low score of %d, "\n<134> \n<135> "misdetection possible!\n", (*fmt)->name, score);\n<136> \n<137> } else\n<138> \n<139> av_log(logctx, AV_LOG_DEBUG,\n<140> \n<141> "Format %s probed with size=%d and score=%d\n",\n<142> \n<143> (*fmt)->name, probe_size, score);\n<144> \n<145> #if 0\n<146> \n<147> FILE *f = fopen("probestat.tmp", "ab");\n<148> \n<149> fprintf(f, "probe_size:%d format:%s score:%d filename:%s\n", probe_size, (*fmt)->name, score, filename);\n<150> \n<151> fclose(f);\n<152> \n<153> #endif\n<154> \n<155> }\n<156> \n<157> }\n<158> \n<159> \n<160> \n<161> if (!*fmt)\n<162> \n<163> ret = AVERROR_INVALIDDATA;\n<164> \n<165> \n<166> \n<167> fail:\n<168> \n<169> /* Rewind. Reuse probe buffer to avoid seeking. */\n<170> \n<171> if (ret >= 0)\n<172> \n<173> ret = ffio_rewind_with_probe_data(pb, &buf, buf_offset);\n<174> \n<175> \n<176> \n<177> #ifdef FF_API_PROBE_MIME\n<178> \n<179> av_free(pd.mime_type);\n<180> \n<181> #endif\n<182> \n<183> return ret < 0 ? ret : score;\n<184> \n<185> }\n<186> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static ssize_t vnc_tls_pull(gnutls_transport_ptr_t transport,\n<2> \n<3> void *data,\n<4> \n<5> size_t len) {\n<6> \n<7> struct VncState *vs = (struct VncState *)transport;\n<8> \n<9> int ret;\n<10> \n<11> \n<12> \n<13> retry:\n<14> \n<15> ret = recv(vs->csock, data, len, 0);\n<16> \n<17> if (ret < 0) {\n<18> \n<19> if (errno == EINTR)\n<20> \n<21> goto retry;\n<22> \n<23> return -1;\n<24> \n<25> }\n<26> \n<27> return ret;\n<28> \n<29> }\n<30> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void probe_codec(AVFormatContext *s, AVStream *st, const AVPacket *pkt)\n<2> \n<3> {\n<4> \n<5> if(st->codec->codec_id == CODEC_ID_PROBE){\n<6> \n<7> AVProbeData *pd = &st->probe_data;\n<8> \n<9> av_log(s, AV_LOG_DEBUG, "probing stream %d\n", st->index);\n<10> \n<11> --st->probe_packets;\n<12> \n<13> \n<14> \n<15> pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n<16> \n<17> memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n<18> \n<19> pd->buf_size += pkt->size;\n<20> \n<21> memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n<22> \n<23> \n<24> \n<25> if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){\n<26> \n<27> //FIXME we do not reduce score to 0 for the case of running out of buffer space in bytes\n<28> \n<29> set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);\n<30> \n<31> if(st->codec->codec_id != CODEC_ID_PROBE){\n<32> \n<33> pd->buf_size=0;\n<34> \n<35> av_freep(&pd->buf);\n<36> \n<37> av_log(s, AV_LOG_DEBUG, "probed stream %d\n", st->index);\n<38> \n<39> }\n<40> \n<41> }\n<42> \n<43> }\n<44> \n<45> }\n<46> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n<2> \n<3> const char *model, const char *name,\n<4> \n<5> const char *ifname, const char *script,\n<6> \n<7> const char *downscript, const char *vhostfdname,\n<8> \n<9> int vnet_hdr, int fd)\n<10> \n<11> {\n<12> \n<13> TAPState *s;\n<14> \n<15> \n<16> \n<17> s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);\n<18> \n<19> if (!s) {\n<20> \n<21> close(fd);\n<22> \n<23> return -1;\n<24> \n<25> }\n<26> \n<27> \n<28> \n<29> if (tap_set_sndbuf(s->fd, tap) < 0) {\n<30> \n<31> return -1;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> if (tap->has_fd || tap->has_fds) {\n<38> \n<39> snprintf(s->nc.info_str, sizeof(s->nc.info_str), "fd=%d", fd);\n<40> \n<41> } else if (tap->has_helper) {\n<42> \n<43> snprintf(s->nc.info_str, sizeof(s->nc.info_str), "helper=%s",\n<44> \n<45> tap->helper);\n<46> \n<47> } else {\n<48> \n<49> snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n<50> \n<51> "ifname=%s,script=%s,downscript=%s", ifname, script,\n<52> \n<53> downscript);\n<54> \n<55> \n<56> \n<57> if (strcmp(downscript, "no") != 0) {\n<58> \n<59> snprintf(s->down_script, sizeof(s->down_script), "%s", downscript);\n<60> \n<61> snprintf(s->down_script_arg, sizeof(s->down_script_arg),\n<62> \n<63> "%s", ifname);\n<64> \n<65> }\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> if (tap->has_vhost ? tap->vhost :\n<72> \n<73> vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {\n<74> \n<75> int vhostfd;\n<76> \n<77> \n<78> \n<79> if (tap->has_vhostfd) {\n<80> \n<81> vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);\n<82> \n<83> if (vhostfd == -1) {\n<84> \n<85> return -1;\n<86> \n<87> }\n<88> \n<89> } else {\n<90> \n<91> vhostfd = -1;\n<92> \n<93> }\n<94> \n<95> \n<96> \n<97> s->vhost_net = vhost_net_init(&s->nc, vhostfd,\n<98> \n<99> tap->has_vhostforce && tap->vhostforce);\n<100> \n<101> if (!s->vhost_net) {\n<102> \n<103> error_report("vhost-net requested but could not be initialized");\n<104> \n<105> return -1;\n<106> \n<107> }\n<108> \n<109> } else if (tap->has_vhostfd || tap->has_vhostfds) {\n<110> \n<111> error_report("vhostfd= is not valid without vhost");\n<112> \n<113> return -1;\n<114> \n<115> }\n<116> \n<117> \n<118> \n<119> return 0;\n<120> \n<121> }\n<122> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void ide_init2(IDEBus *bus, DriveInfo *hd0, DriveInfo *hd1,\n<2> \n<3> qemu_irq irq)\n<4> \n<5> {\n<6> \n<7> IDEState *s;\n<8> \n<9> static int drive_serial = 1;\n<10> \n<11> int i, cylinders, heads, secs;\n<12> \n<13> uint64_t nb_sectors;\n<14> \n<15> \n<16> \n<17> for(i = 0; i < 2; i++) {\n<18> \n<19> s = bus->ifs + i;\n<20> \n<21> s->bus = bus;\n<22> \n<23> s->unit = i;\n<24> \n<25> if (i == 0 && hd0)\n<26> \n<27> s->bs = hd0->bdrv;\n<28> \n<29> if (i == 1 && hd1)\n<30> \n<31> s->bs = hd1->bdrv;\n<32> \n<33> s->io_buffer = qemu_blockalign(s->bs, IDE_DMA_BUF_SECTORS*512 + 4);\n<34> \n<35> if (s->bs) {\n<36> \n<37> bdrv_get_geometry(s->bs, &nb_sectors);\n<38> \n<39> bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n<40> \n<41> s->cylinders = cylinders;\n<42> \n<43> s->heads = heads;\n<44> \n<45> s->sectors = secs;\n<46> \n<47> s->nb_sectors = nb_sectors;\n<48> \n<49> /* The SMART values should be preserved across power cycles\n<50> \n<51> but they aren't.  */\n<52> \n<53> s->smart_enabled = 1;\n<54> \n<55> s->smart_autosave = 1;\n<56> \n<57> s->smart_errors = 0;\n<58> \n<59> s->smart_selftest_count = 0;\n<60> \n<61> s->smart_selftest_data = qemu_blockalign(s->bs, 512);\n<62> \n<63> if (bdrv_get_type_hint(s->bs) == BDRV_TYPE_CDROM) {\n<64> \n<65> s->is_cdrom = 1;\n<66> \n<67> bdrv_set_change_cb(s->bs, cdrom_change_cb, s);\n<68> \n<69> }\n<70> \n<71> }\n<72> \n<73> s->drive_serial = drive_serial++;\n<74> \n<75> strncpy(s->drive_serial_str, drive_get_serial(s->bs),\n<76> \n<77> sizeof(s->drive_serial_str));\n<78> \n<79> if (strlen(s->drive_serial_str) == 0)\n<80> \n<81> snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n<82> \n<83> "QM%05d", s->drive_serial);\n<84> \n<85> s->sector_write_timer = qemu_new_timer(vm_clock,\n<86> \n<87> ide_sector_write_timer_cb, s);\n<88> \n<89> ide_reset(s);\n<90> \n<91> }\n<92> \n<93> bus->irq = irq;\n<94> \n<95> }\n<96> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

todo
You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static AVStream *add_av_stream1(FFStream *stream, AVCodecContext *codec, int copy)\n<2> \n<3> {\n<4> \n<5> AVStream *fst;\n<6> \n<7> \n<8> \n<9> fst = av_mallocz(sizeof(AVStream));\n<10> \n<11> if (!fst)\n<12> \n<13> return NULL;\n<14> \n<15> if (copy) {\n<16> \n<17> fst->codec= avcodec_alloc_context();\n<18> \n<19> memcpy(fst->codec, codec, sizeof(AVCodecContext));\n<20> \n<21> if (codec->extradata_size) {\n<22> \n<23> fst->codec->extradata = av_malloc(codec->extradata_size);\n<24> \n<25> memcpy(fst->codec->extradata, codec->extradata,\n<26> \n<27> codec->extradata_size);\n<28> \n<29> }\n<30> \n<31> } else {\n<32> \n<33> /* live streams must use the actual feed's codec since it may be\n<34> \n<35> * updated later to carry extradata needed by the streams.\n<36> \n<37> */\n<38> \n<39> fst->codec = codec;\n<40> \n<41> }\n<42> \n<43> fst->priv_data = av_mallocz(sizeof(FeedData));\n<44> \n<45> fst->index = stream->nb_streams;\n<46> \n<47> av_set_pts_info(fst, 33, 1, 90000);\n<48> \n<49> fst->sample_aspect_ratio = (AVRational){0,1};\n<50> \n<51> stream->streams[stream->nb_streams++] = fst;\n<52> \n<53> return fst;\n<54> \n<55> }\n<56> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static uint64_t l2x0_priv_read(void *opaque, target_phys_addr_t offset,\n<2> \n<3> unsigned size)\n<4> \n<5> {\n<6> \n<7> uint32_t cache_data;\n<8> \n<9> l2x0_state *s = (l2x0_state *)opaque;\n<10> \n<11> offset &= 0xfff;\n<12> \n<13> if (offset >= 0x730 && offset < 0x800) {\n<14> \n<15> return 0; /* cache ops complete */\n<16> \n<17> }\n<18> \n<19> switch (offset) {\n<20> \n<21> case 0:\n<22> \n<23> return CACHE_ID;\n<24> \n<25> case 0x4:\n<26> \n<27> /* aux_ctrl values affect cache_type values */\n<28> \n<29> cache_data = (s->aux_ctrl & (7 << 17)) >> 15;\n<30> \n<31> cache_data |= (s->aux_ctrl & (1 << 16)) >> 16;\n<32> \n<33> return s->cache_type |= (cache_data << 18) | (cache_data << 6);\n<34> \n<35> case 0x100:\n<36> \n<37> return s->ctrl;\n<38> \n<39> case 0x104:\n<40> \n<41> return s->aux_ctrl;\n<42> \n<43> case 0x108:\n<44> \n<45> return s->tag_ctrl;\n<46> \n<47> case 0x10C:\n<48> \n<49> return s->data_ctrl;\n<50> \n<51> case 0xC00:\n<52> \n<53> return s->filter_start;\n<54> \n<55> case 0xC04:\n<56> \n<57> return s->filter_end;\n<58> \n<59> case 0xF40:\n<60> \n<61> return 0;\n<62> \n<63> case 0xF60:\n<64> \n<65> return 0;\n<66> \n<67> case 0xF80:\n<68> \n<69> return 0;\n<70> \n<71> default:\n<72> \n<73> fprintf(stderr, "l2x0_priv_read: Bad offset %x\n", (int)offset);\n<74> \n<75> break;\n<76> \n<77> }\n<78> \n<79> return 0;\n<80> \n<81> }\n<82> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void sd_lock_command(SDState *sd)\n<2> \n<3> {\n<4> \n<5> int erase, lock, clr_pwd, set_pwd, pwd_len;\n<6> \n<7> erase = !!(sd->data[0] & 0x08);\n<8> \n<9> lock = sd->data[0] & 0x04;\n<10> \n<11> clr_pwd = sd->data[0] & 0x02;\n<12> \n<13> set_pwd = sd->data[0] & 0x01;\n<14> \n<15> \n<16> \n<17> if (sd->blk_len > 1)\n<18> \n<19> pwd_len = sd->data[1];\n<20> \n<21> else\n<22> \n<23> pwd_len = 0;\n<24> \n<25> \n<26> \n<27> if (erase) {\n<28> \n<29> if (!(sd->card_status & CARD_IS_LOCKED) || sd->blk_len > 1 ||\n<30> \n<31> set_pwd || clr_pwd || lock || sd->wp_switch ||\n<32> \n<33> (sd->csd[14] & 0x20)) {\n<34> \n<35> sd->card_status |= LOCK_UNLOCK_FAILED;\n<36> \n<37> return;\n<38> \n<39> }\n<40> \n<41> memset(sd->wp_groups, 0, sizeof(int) * (sd->size >>\n<42> \n<43> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)));\n<44> \n<45> sd->csd[14] &= ~0x10;\n<46> \n<47> sd->card_status &= ~CARD_IS_LOCKED;\n<48> \n<49> sd->pwd_len = 0;\n<50> \n<51> /* Erasing the entire card here! */\n<52> \n<53> fprintf(stderr, "SD: Card force-erased by CMD42\n");\n<54> \n<55> return;\n<56> \n<57> }\n<58> \n<59> \n<60> \n<61> if (sd->blk_len < 2 + pwd_len ||\n<62> \n<63> pwd_len <= sd->pwd_len ||\n<64> \n<65> pwd_len > sd->pwd_len + 16) {\n<66> \n<67> sd->card_status |= LOCK_UNLOCK_FAILED;\n<68> \n<69> return;\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> if (sd->pwd_len && memcmp(sd->pwd, sd->data + 2, sd->pwd_len)) {\n<76> \n<77> sd->card_status |= LOCK_UNLOCK_FAILED;\n<78> \n<79> return;\n<80> \n<81> }\n<82> \n<83> \n<84> \n<85> pwd_len -= sd->pwd_len;\n<86> \n<87> if ((pwd_len && !set_pwd) ||\n<88> \n<89> (clr_pwd && (set_pwd || lock)) ||\n<90> \n<91> (lock && !sd->pwd_len && !set_pwd) ||\n<92> \n<93> (!set_pwd && !clr_pwd &&\n<94> \n<95> (((sd->card_status & CARD_IS_LOCKED) && lock) ||\n<96> \n<97> (!(sd->card_status & CARD_IS_LOCKED) && !lock)))) {\n<98> \n<99> sd->card_status |= LOCK_UNLOCK_FAILED;\n<100> \n<101> return;\n<102> \n<103> }\n<104> \n<105> \n<106> \n<107> if (set_pwd) {\n<108> \n<109> memcpy(sd->pwd, sd->data + 2 + sd->pwd_len, pwd_len);\n<110> \n<111> sd->pwd_len = pwd_len;\n<112> \n<113> }\n<114> \n<115> \n<116> \n<117> if (clr_pwd) {\n<118> \n<119> sd->pwd_len = 0;\n<120> \n<121> }\n<122> \n<123> \n<124> \n<125> if (lock)\n<126> \n<127> sd->card_status |= CARD_IS_LOCKED;\n<128> \n<129> else\n<130> \n<131> sd->card_status &= ~CARD_IS_LOCKED;\n<132> \n<133> }\n<134> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ff_pulse_audio_get_devices(AVDeviceInfoList *devices, const char *server, int output)\n<2> \n<3> {\n<4> \n<5> pa_mainloop *pa_ml = NULL;\n<6> \n<7> pa_mainloop_api *pa_mlapi = NULL;\n<8> \n<9> pa_operation *pa_op = NULL;\n<10> \n<11> pa_context *pa_ctx = NULL;\n<12> \n<13> enum pa_operation_state op_state;\n<14> \n<15> enum PulseAudioContextState loop_state = PULSE_CONTEXT_INITIALIZING;\n<16> \n<17> PulseAudioDeviceList dev_list = { 0 };\n<18> \n<19> int i;\n<20> \n<21> \n<22> \n<23> dev_list.output = output;\n<24> \n<25> dev_list.devices = devices;\n<26> \n<27> if (!devices)\n<28> \n<29> return AVERROR(EINVAL);\n<30> \n<31> devices->nb_devices = 0;\n<32> \n<33> devices->devices = NULL;\n<34> \n<35> if (!(pa_ml = pa_mainloop_new()))\n<36> \n<37> return AVERROR(ENOMEM);\n<38> \n<39> if (!(pa_mlapi = pa_mainloop_get_api(pa_ml))) {\n<40> \n<41> dev_list.error_code = AVERROR_EXTERNAL;\n<42> \n<43> goto fail;\n<44> \n<45> }\n<46> \n<47> if (!(pa_ctx = pa_context_new(pa_mlapi, "Query devices"))) {\n<48> \n<49> dev_list.error_code = AVERROR(ENOMEM);\n<50> \n<51> goto fail;\n<52> \n<53> }\n<54> \n<55> pa_context_set_state_callback(pa_ctx, pa_state_cb, &loop_state);\n<56> \n<57> if (pa_context_connect(pa_ctx, server, 0, NULL) < 0) {\n<58> \n<59> dev_list.error_code = AVERROR_EXTERNAL;\n<60> \n<61> goto fail;\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> while (loop_state == PULSE_CONTEXT_INITIALIZING)\n<68> \n<69> pa_mainloop_iterate(pa_ml, 1, NULL);\n<70> \n<71> if (loop_state == PULSE_CONTEXT_FINISHED) {\n<72> \n<73> dev_list.error_code = AVERROR_EXTERNAL;\n<74> \n<75> goto fail;\n<76> \n<77> }\n<78> \n<79> \n<80> \n<81> if (output)\n<82> \n<83> pa_op = pa_context_get_sink_info_list(pa_ctx, pulse_audio_sink_device_cb, &dev_list);\n<84> \n<85> else\n<86> \n<87> pa_op = pa_context_get_source_info_list(pa_ctx, pulse_audio_source_device_cb, &dev_list);\n<88> \n<89> while ((op_state = pa_operation_get_state(pa_op)) == PA_OPERATION_RUNNING)\n<90> \n<91> pa_mainloop_iterate(pa_ml, 1, NULL);\n<92> \n<93> if (op_state != PA_OPERATION_DONE)\n<94> \n<95> dev_list.error_code = AVERROR_EXTERNAL;\n<96> \n<97> pa_operation_unref(pa_op);\n<98> \n<99> if (dev_list.error_code < 0)\n<100> \n<101> goto fail;\n<102> \n<103> \n<104> \n<105> pa_op = pa_context_get_server_info(pa_ctx, pulse_server_info_cb, &dev_list);\n<106> \n<107> while ((op_state = pa_operation_get_state(pa_op)) == PA_OPERATION_RUNNING)\n<108> \n<109> pa_mainloop_iterate(pa_ml, 1, NULL);\n<110> \n<111> if (op_state != PA_OPERATION_DONE)\n<112> \n<113> dev_list.error_code = AVERROR_EXTERNAL;\n<114> \n<115> pa_operation_unref(pa_op);\n<116> \n<117> if (dev_list.error_code < 0)\n<118> \n<119> goto fail;\n<120> \n<121> \n<122> \n<123> devices->default_device = -1;\n<124> \n<125> for (i = 0; i < devices->nb_devices; i++) {\n<126> \n<127> if (!strcmp(devices->devices[i]->device_name, dev_list.default_device)) {\n<128> \n<129> devices->default_device = i;\n<130> \n<131> break;\n<132> \n<133> }\n<134> \n<135> }\n<136> \n<137> \n<138> \n<139> fail:\n<140> \n<141> av_free(dev_list.default_device);\n<142> \n<143> if(pa_ctx)\n<144> \n<145> pa_context_disconnect(pa_ctx);\n<146> \n<147> if (pa_ctx)\n<148> \n<149> pa_context_unref(pa_ctx);\n<150> \n<151> if (pa_ml)\n<152> \n<153> pa_mainloop_free(pa_ml);\n<154> \n<155> return dev_list.error_code;\n<156> \n<157> }\n<158> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static ssize_t vc_sendv_compat(VLANClientState *vc, const struct iovec *iov,\n<2> \n<3> int iovcnt)\n<4> \n<5> {\n<6> \n<7> uint8_t buffer[4096];\n<8> \n<9> size_t offset = 0;\n<10> \n<11> int i;\n<12> \n<13> \n<14> \n<15> for (i = 0; i < iovcnt; i++) {\n<16> \n<17> size_t len;\n<18> \n<19> \n<20> \n<21> len = MIN(sizeof(buffer) - offset, iov[i].iov_len);\n<22> \n<23> memcpy(buffer + offset, iov[i].iov_base, len);\n<24> \n<25> offset += len;\n<26> \n<27> }\n<28> \n<29> \n<30> \n<31> vc->receive(vc->opaque, buffer, offset);\n<32> \n<33> \n<34> \n<35> return offset;\n<36> \n<37> }\n<38> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int posix_aio_init(void)\n<2> \n<3> {\n<4> \n<5> struct sigaction act;\n<6> \n<7> PosixAioState *s;\n<8> \n<9> int fds[2];\n<10> \n<11> struct qemu_paioinit ai;\n<12> \n<13> \n<14> \n<15> if (posix_aio_state)\n<16> \n<17> return 0;\n<18> \n<19> \n<20> \n<21> s = qemu_malloc(sizeof(PosixAioState));\n<22> \n<23> \n<24> \n<25> sigfillset(&act.sa_mask);\n<26> \n<27> act.sa_flags = 0; /* do not restart syscalls to interrupt select() */\n<28> \n<29> act.sa_handler = aio_signal_handler;\n<30> \n<31> sigaction(SIGUSR2, &act, NULL);\n<32> \n<33> \n<34> \n<35> s->first_aio = NULL;\n<36> \n<37> if (pipe(fds) == -1) {\n<38> \n<39> fprintf(stderr, "failed to create pipe\n");\n<40> \n<41> return -errno;\n<42> \n<43> }\n<44> \n<45> \n<46> \n<47> s->rfd = fds[0];\n<48> \n<49> s->wfd = fds[1];\n<50> \n<51> \n<52> \n<53> fcntl(s->rfd, F_SETFL, O_NONBLOCK);\n<54> \n<55> fcntl(s->wfd, F_SETFL, O_NONBLOCK);\n<56> \n<57> \n<58> \n<59> qemu_aio_set_fd_handler(s->rfd, posix_aio_read, NULL, posix_aio_flush, s);\n<60> \n<61> \n<62> \n<63> memset(&ai, 0, sizeof(ai));\n<64> \n<65> ai.aio_threads = 64;\n<66> \n<67> ai.aio_num = 64;\n<68> \n<69> qemu_paio_init(&ai);\n<70> \n<71> \n<72> \n<73> posix_aio_state = s;\n<74> \n<75> \n<76> \n<77> return 0;\n<78> \n<79> }\n<80> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int cinepak_decode (CinepakContext *s)\n<2> \n<3> {\n<4> \n<5> uint8_t      *eod = (s->data + s->size);\n<6> \n<7> int           i, result, strip_size, frame_flags, num_strips;\n<8> \n<9> int           y0 = 0;\n<10> \n<11> int           encoded_buf_size;\n<12> \n<13> /* if true, Cinepak data is from a Sega FILM/CPK file */\n<14> \n<15> int           sega_film_data = 0;\n<16> \n<17> \n<18> \n<19> if (s->size < 10)\n<20> \n<21> return -1;\n<22> \n<23> \n<24> \n<25> frame_flags = s->data[0];\n<26> \n<27> num_strips  = BE_16 (&s->data[8]);\n<28> \n<29> encoded_buf_size = ((s->data[1] << 16) | BE_16 (&s->data[2]));\n<30> \n<31> if (encoded_buf_size != s->size)\n<32> \n<33> sega_film_data = 1;\n<34> \n<35> if (sega_film_data)\n<36> \n<37> s->data    += 12;\n<38> \n<39> else\n<40> \n<41> s->data    += 10;\n<42> \n<43> \n<44> \n<45> if (num_strips > MAX_STRIPS)\n<46> \n<47> num_strips = MAX_STRIPS;\n<48> \n<49> \n<50> \n<51> for (i=0; i < num_strips; i++) {\n<52> \n<53> if ((s->data + 12) > eod)\n<54> \n<55> return -1;\n<56> \n<57> \n<58> \n<59> s->strips[i].id = BE_16 (s->data);\n<60> \n<61> s->strips[i].y1 = y0;\n<62> \n<63> s->strips[i].x1 = 0;\n<64> \n<65> s->strips[i].y2 = y0 + BE_16 (&s->data[8]);\n<66> \n<67> s->strips[i].x2 = s->avctx->width;\n<68> \n<69> \n<70> \n<71> strip_size = BE_16 (&s->data[2]) - 12;\n<72> \n<73> s->data   += 12;\n<74> \n<75> strip_size = ((s->data + strip_size) > eod) ? (eod - s->data) : strip_size;\n<76> \n<77> \n<78> \n<79> if ((i > 0) && !(frame_flags & 0x01)) {\n<80> \n<81> memcpy (s->strips[i].v4_codebook, s->strips[i-1].v4_codebook,\n<82> \n<83> sizeof(s->strips[i].v4_codebook));\n<84> \n<85> memcpy (s->strips[i].v1_codebook, s->strips[i-1].v1_codebook,\n<86> \n<87> sizeof(s->strips[i].v1_codebook));\n<88> \n<89> }\n<90> \n<91> \n<92> \n<93> result = cinepak_decode_strip (s, &s->strips[i], s->data, strip_size);\n<94> \n<95> \n<96> \n<97> if (result != 0)\n<98> \n<99> return result;\n<100> \n<101> \n<102> \n<103> s->data += strip_size;\n<104> \n<105> y0    = s->strips[i].y2;\n<106> \n<107> }\n<108> \n<109> return 0;\n<110> \n<111> }\n<112> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int net_host_check_device(const char *device)\n<2> \n<3> {\n<4> \n<5> int i;\n<6> \n<7> const char *valid_param_list[] = { "tap", "socket", "dump"\n<8> \n<9> #ifdef CONFIG_NET_BRIDGE\n<10> \n<11> , "bridge"\n<12> \n<13> #endif\n<14> \n<15> #ifdef CONFIG_SLIRP\n<16> \n<17> ,"user"\n<18> \n<19> #endif\n<20> \n<21> #ifdef CONFIG_VDE\n<22> \n<23> ,"vde"\n<24> \n<25> #endif\n<26> \n<27> };\n<28> \n<29> for (i = 0; i < ARRAY_SIZE(valid_param_list); i++) {\n<30> \n<31> if (!strncmp(valid_param_list[i], device,\n<32> \n<33> strlen(valid_param_list[i])))\n<34> \n<35> return 1;\n<36> \n<37> }\n<38> \n<39> \n<40> \n<41> return 0;\n<42> \n<43> }\n<44> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> do_socket_read(GIOChannel *source,\n<2> \n<3> GIOCondition condition,\n<4> \n<5> gpointer data)\n<6> \n<7> {\n<8> \n<9> int rv;\n<10> \n<11> int dwSendLength;\n<12> \n<13> int dwRecvLength;\n<14> \n<15> uint8_t pbRecvBuffer[APDUBufSize];\n<16> \n<17> static uint8_t pbSendBuffer[APDUBufSize];\n<18> \n<19> VReaderStatus reader_status;\n<20> \n<21> VReader *reader = NULL;\n<22> \n<23> static VSCMsgHeader mhHeader;\n<24> \n<25> VSCMsgError *error_msg;\n<26> \n<27> GError *err = NULL;\n<28> \n<29> \n<30> \n<31> static gchar *buf;\n<32> \n<33> static gsize br, to_read;\n<34> \n<35> static int state = STATE_HEADER;\n<36> \n<37> \n<38> \n<39> if (state == STATE_HEADER && to_read == 0) {\n<40> \n<41> buf = (gchar *)&mhHeader;\n<42> \n<43> to_read = sizeof(mhHeader);\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> if (to_read > 0) {\n<50> \n<51> g_io_channel_read_chars(source, (gchar *)buf, to_read, &br, &err);\n<52> \n<53> if (err != NULL) {\n<54> \n<55> g_error("error while reading: %s", err->message);\n<56> \n<57> }\n<58> \n<59> buf += br;\n<60> \n<61> to_read -= br;\n<62> \n<63> if (to_read != 0) {\n<64> \n<65> return TRUE;\n<66> \n<67> }\n<68> \n<69> }\n<70> \n<71> \n<72> \n<73> if (state == STATE_HEADER) {\n<74> \n<75> mhHeader.type = ntohl(mhHeader.type);\n<76> \n<77> mhHeader.reader_id = ntohl(mhHeader.reader_id);\n<78> \n<79> mhHeader.length = ntohl(mhHeader.length);\n<80> \n<81> if (verbose) {\n<82> \n<83> printf("Header: type=%d, reader_id=%u length=%d (0x%x)\n",\n<84> \n<85> mhHeader.type, mhHeader.reader_id, mhHeader.length,\n<86> \n<87> mhHeader.length);\n<88> \n<89> }\n<90> \n<91> switch (mhHeader.type) {\n<92> \n<93> case VSC_APDU:\n<94> \n<95> case VSC_Flush:\n<96> \n<97> case VSC_Error:\n<98> \n<99> case VSC_Init:\n<100> \n<101> buf = (gchar *)pbSendBuffer;\n<102> \n<103> to_read = mhHeader.length;\n<104> \n<105> state = STATE_MESSAGE;\n<106> \n<107> return TRUE;\n<108> \n<109> default:\n<110> \n<111> fprintf(stderr, "Unexpected message of type 0x%X\n", mhHeader.type);\n<112> \n<113> return FALSE;\n<114> \n<115> }\n<116> \n<117> }\n<118> \n<119> \n<120> \n<121> if (state == STATE_MESSAGE) {\n<122> \n<123> switch (mhHeader.type) {\n<124> \n<125> case VSC_APDU:\n<126> \n<127> if (verbose) {\n<128> \n<129> printf(" recv APDU: ");\n<130> \n<131> print_byte_array(pbSendBuffer, mhHeader.length);\n<132> \n<133> }\n<134> \n<135> /* Transmit received APDU */\n<136> \n<137> dwSendLength = mhHeader.length;\n<138> \n<139> dwRecvLength = sizeof(pbRecvBuffer);\n<140> \n<141> reader = vreader_get_reader_by_id(mhHeader.reader_id);\n<142> \n<143> reader_status = vreader_xfr_bytes(reader,\n<144> \n<145> pbSendBuffer, dwSendLength,\n<146> \n<147> pbRecvBuffer, &dwRecvLength);\n<148> \n<149> if (reader_status == VREADER_OK) {\n<150> \n<151> mhHeader.length = dwRecvLength;\n<152> \n<153> if (verbose) {\n<154> \n<155> printf(" send response: ");\n<156> \n<157> print_byte_array(pbRecvBuffer, mhHeader.length);\n<158> \n<159> }\n<160> \n<161> send_msg(VSC_APDU, mhHeader.reader_id,\n<162> \n<163> pbRecvBuffer, dwRecvLength);\n<164> \n<165> } else {\n<166> \n<167> rv = reader_status; /* warning: not meaningful */\n<168> \n<169> send_msg(VSC_Error, mhHeader.reader_id, &rv, sizeof(uint32_t));\n<170> \n<171> }\n<172> \n<173> vreader_free(reader);\n<174> \n<175> reader = NULL; /* we've freed it, don't use it by accident\n<176> \n<177> again */\n<178> \n<179> break;\n<180> \n<181> case VSC_Flush:\n<182> \n<183> /* TODO: actually flush */\n<184> \n<185> send_msg(VSC_FlushComplete, mhHeader.reader_id, NULL, 0);\n<186> \n<187> break;\n<188> \n<189> case VSC_Error:\n<190> \n<191> error_msg = (VSCMsgError *) pbSendBuffer;\n<192> \n<193> if (error_msg->code == VSC_SUCCESS) {\n<194> \n<195> qemu_mutex_lock(&pending_reader_lock);\n<196> \n<197> if (pending_reader) {\n<198> \n<199> vreader_set_id(pending_reader, mhHeader.reader_id);\n<200> \n<201> vreader_free(pending_reader);\n<202> \n<203> pending_reader = NULL;\n<204> \n<205> qemu_cond_signal(&pending_reader_condition);\n<206> \n<207> }\n<208> \n<209> qemu_mutex_unlock(&pending_reader_lock);\n<210> \n<211> break;\n<212> \n<213> }\n<214> \n<215> printf("warning: qemu refused to add reader\n");\n<216> \n<217> if (error_msg->code == VSC_CANNOT_ADD_MORE_READERS) {\n<218> \n<219> /* clear pending reader, qemu can't handle any more */\n<220> \n<221> qemu_mutex_lock(&pending_reader_lock);\n<222> \n<223> if (pending_reader) {\n<224> \n<225> pending_reader = NULL;\n<226> \n<227> /* make sure the event loop doesn't hang */\n<228> \n<229> qemu_cond_signal(&pending_reader_condition);\n<230> \n<231> }\n<232> \n<233> qemu_mutex_unlock(&pending_reader_lock);\n<234> \n<235> }\n<236> \n<237> break;\n<238> \n<239> case VSC_Init:\n<240> \n<241> if (on_host_init(&mhHeader, (VSCMsgInit *)pbSendBuffer) < 0) {\n<242> \n<243> return FALSE;\n<244> \n<245> }\n<246> \n<247> break;\n<248> \n<249> default:\n<250> \n<251> g_assert_not_reached();\n<252> \n<253> return FALSE;\n<254> \n<255> }\n<256> \n<257> \n<258> \n<259> state = STATE_HEADER;\n<260> \n<261> }\n<262> \n<263> \n<264> \n<265> \n<266> \n<267> return TRUE;\n<268> \n<269> }\n<270> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void x86_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n<2> \n<3> const char *optarg)\n<4> \n<5> {\n<6> \n<7> unsigned char model = !strcmp("?model", optarg);\n<8> \n<9> unsigned char dump = !strcmp("?dump", optarg);\n<10> \n<11> unsigned char cpuid = !strcmp("?cpuid", optarg);\n<12> \n<13> x86_def_t *def;\n<14> \n<15> char buf[256];\n<16> \n<17> \n<18> \n<19> if (cpuid) {\n<20> \n<21> (*cpu_fprintf)(f, "Recognized CPUID flags:\n");\n<22> \n<23> listflags(buf, sizeof (buf), (uint32_t)~0, feature_name, 1);\n<24> \n<25> (*cpu_fprintf)(f, "  f_edx: %s\n", buf);\n<26> \n<27> listflags(buf, sizeof (buf), (uint32_t)~0, ext_feature_name, 1);\n<28> \n<29> (*cpu_fprintf)(f, "  f_ecx: %s\n", buf);\n<30> \n<31> listflags(buf, sizeof (buf), (uint32_t)~0, ext2_feature_name, 1);\n<32> \n<33> (*cpu_fprintf)(f, "  extf_edx: %s\n", buf);\n<34> \n<35> listflags(buf, sizeof (buf), (uint32_t)~0, ext3_feature_name, 1);\n<36> \n<37> (*cpu_fprintf)(f, "  extf_ecx: %s\n", buf);\n<38> \n<39> return;\n<40> \n<41> }\n<42> \n<43> for (def = x86_defs; def; def = def->next) {\n<44> \n<45> snprintf(buf, sizeof (buf), def->flags ? "[%s]": "%s", def->name);\n<46> \n<47> if (model || dump) {\n<48> \n<49> (*cpu_fprintf)(f, "x86 %16s  %-48s\n", buf, def->model_id);\n<50> \n<51> } else {\n<52> \n<53> (*cpu_fprintf)(f, "x86 %16s\n", buf);\n<54> \n<55> }\n<56> \n<57> if (dump) {\n<58> \n<59> memcpy(buf, &def->vendor1, sizeof (def->vendor1));\n<60> \n<61> memcpy(buf + 4, &def->vendor2, sizeof (def->vendor2));\n<62> \n<63> memcpy(buf + 8, &def->vendor3, sizeof (def->vendor3));\n<64> \n<65> buf[12] = '\0';\n<66> \n<67> (*cpu_fprintf)(f,\n<68> \n<69> "  family %d model %d stepping %d level %d xlevel 0x%x"\n<70> \n<71> " vendor \"%s\"\n",\n<72> \n<73> def->family, def->model, def->stepping, def->level,\n<74> \n<75> def->xlevel, buf);\n<76> \n<77> listflags(buf, sizeof (buf), def->features, feature_name, 0);\n<78> \n<79> (*cpu_fprintf)(f, "  feature_edx %08x (%s)\n", def->features,\n<80> \n<81> buf);\n<82> \n<83> listflags(buf, sizeof (buf), def->ext_features, ext_feature_name,\n<84> \n<85> 0);\n<86> \n<87> (*cpu_fprintf)(f, "  feature_ecx %08x (%s)\n", def->ext_features,\n<88> \n<89> buf);\n<90> \n<91> listflags(buf, sizeof (buf), def->ext2_features, ext2_feature_name,\n<92> \n<93> 0);\n<94> \n<95> (*cpu_fprintf)(f, "  extfeature_edx %08x (%s)\n",\n<96> \n<97> def->ext2_features, buf);\n<98> \n<99> listflags(buf, sizeof (buf), def->ext3_features, ext3_feature_name,\n<100> \n<101> 0);\n<102> \n<103> (*cpu_fprintf)(f, "  extfeature_ecx %08x (%s)\n",\n<104> \n<105> def->ext3_features, buf);\n<106> \n<107> (*cpu_fprintf)(f, "\n");\n<108> \n<109> }\n<110> \n<111> }\n<112> \n<113> if (kvm_enabled()) {\n<114> \n<115> (*cpu_fprintf)(f, "x86 %16s\n", "[host]");\n<116> \n<117> }\n<118> \n<119> }\n<120> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int bdrv_prwv_co(BlockDriverState *bs, int64_t offset,\n<2> \n<3> QEMUIOVector *qiov, bool is_write,\n<4> \n<5> BdrvRequestFlags flags)\n<6> \n<7> {\n<8> \n<9> Coroutine *co;\n<10> \n<11> RwCo rwco = {\n<12> \n<13> .bs = bs,\n<14> \n<15> .offset = offset,\n<16> \n<17> .qiov = qiov,\n<18> \n<19> .is_write = is_write,\n<20> \n<21> .ret = NOT_DONE,\n<22> \n<23> .flags = flags,\n<24> \n<25> };\n<26> \n<27> \n<28> \n<29> /**\n<30> \n<31> * In sync call context, when the vcpu is blocked, this throttling timer\n<32> \n<33> * will not fire; so the I/O throttling function has to be disabled here\n<34> \n<35> * if it has been enabled.\n<36> \n<37> */\n<38> \n<39> if (bs->io_limits_enabled) {\n<40> \n<41> fprintf(stderr, "Disabling I/O throttling on '%s' due "\n<42> \n<43> "to synchronous I/O.\n", bdrv_get_device_name(bs));\n<44> \n<45> bdrv_io_limits_disable(bs);\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> if (qemu_in_coroutine()) {\n<52> \n<53> /* Fast-path if already in coroutine context */\n<54> \n<55> bdrv_rw_co_entry(&rwco);\n<56> \n<57> } else {\n<58> \n<59> AioContext *aio_context = bdrv_get_aio_context(bs);\n<60> \n<61> \n<62> \n<63> co = qemu_coroutine_create(bdrv_rw_co_entry);\n<64> \n<65> qemu_coroutine_enter(co, &rwco);\n<66> \n<67> while (rwco.ret == NOT_DONE) {\n<68> \n<69> aio_poll(aio_context, true);\n<70> \n<71> }\n<72> \n<73> }\n<74> \n<75> return rwco.ret;\n<76> \n<77> }\n<78> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) {\n<2> EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n<3> switch ( type ) {\n<4> case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ;\n<5> if ( actx == NULL ) {\n<6> EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ;\n<7> return 0 ;\n<8> }\n<9> actx -> len . aad = 0 ;\n<10> actx -> len . text = 0 ;\n<11> actx -> aad = 0 ;\n<12> actx -> mac_inited = 0 ;\n<13> actx -> tag_len = 0 ;\n<14> actx -> nonce_len = 12 ;\n<15> actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ;\n<16> return 1 ;\n<17> case EVP_CTRL_COPY : if ( actx ) {\n<18> EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ;\n<19> dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ;\n<20> if ( dst -> cipher_data == NULL ) {\n<21> EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ;\n<22> return 0 ;\n<23> }\n<24> }\n<25> return 1 ;\n<26> case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ;\n<27> actx -> nonce_len = arg ;\n<28> return 1 ;\n<29> case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ;\n<30> actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ;\n<31> actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 4 ) ;\n<32> actx -> nonce [ 2 ] = actx -> key . counter [ 3 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr + 8 ) ;\n<33> return 1 ;\n<34> case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ;\n<35> if ( ptr != NULL ) {\n<36> memcpy ( actx -> tag , ptr , arg ) ;\n<37> actx -> tag_len = arg ;\n<38> }\n<39> return 1 ;\n<40> case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ;\n<41> memcpy ( ptr , actx -> tag , arg ) ;\n<42> return 1 ;\n<43> case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n<44> {\n<45> unsigned int len ;\n<46> unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ;\n<47> len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ;\n<48> if ( ! ctx -> encrypt ) {\n<49> len -= POLY1305_BLOCK_SIZE ;\n<50> memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;\n<51> aad = temp ;\n<52> temp [ EVP_AEAD_TLS1_AAD_LEN - 2 ] = ( unsigned char ) ( len >> 8 ) ;\n<53> temp [ EVP_AEAD_TLS1_AAD_LEN - 1 ] = ( unsigned char ) len ;\n<54> }\n<55> actx -> tls_payload_length = len ;\n<56> actx -> key . counter [ 1 ] = actx -> nonce [ 0 ] ;\n<57> actx -> key . counter [ 2 ] = actx -> nonce [ 1 ] ^ CHACHA_U8TOU32 ( aad ) ;\n<58> actx -> key . counter [ 3 ] = actx -> nonce [ 2 ] ^ CHACHA_U8TOU32 ( aad + 4 ) ;\n<59> actx -> mac_inited = 0 ;\n<60> chacha20_poly1305_cipher ( ctx , NULL , aad , EVP_AEAD_TLS1_AAD_LEN ) ;\n<61> return POLY1305_BLOCK_SIZE ;\n<62> }\n<63> case EVP_CTRL_AEAD_SET_MAC_KEY : return 1 ;\n<64> default : return - 1 ;\n<65> }\n<66> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> timer_write(void *opaque, target_phys_addr_t addr,\n<2> \n<3> uint64_t val64, unsigned int size)\n<4> \n<5> {\n<6> \n<7> struct etrax_timer *t = opaque;\n<8> \n<9> uint32_t value = val64;\n<10> \n<11> \n<12> \n<13> switch (addr)\n<14> \n<15> {\n<16> \n<17> case RW_TMR0_DIV:\n<18> \n<19> t->rw_tmr0_div = value;\n<20> \n<21> break;\n<22> \n<23> case RW_TMR0_CTRL:\n<24> \n<25> D(printf ("RW_TMR0_CTRL=%x\n", value));\n<26> \n<27> t->rw_tmr0_ctrl = value;\n<28> \n<29> update_ctrl(t, 0);\n<30> \n<31> break;\n<32> \n<33> case RW_TMR1_DIV:\n<34> \n<35> t->rw_tmr1_div = value;\n<36> \n<37> break;\n<38> \n<39> case RW_TMR1_CTRL:\n<40> \n<41> D(printf ("RW_TMR1_CTRL=%x\n", value));\n<42> \n<43> t->rw_tmr1_ctrl = value;\n<44> \n<45> update_ctrl(t, 1);\n<46> \n<47> break;\n<48> \n<49> case RW_INTR_MASK:\n<50> \n<51> D(printf ("RW_INTR_MASK=%x\n", value));\n<52> \n<53> t->rw_intr_mask = value;\n<54> \n<55> timer_update_irq(t);\n<56> \n<57> break;\n<58> \n<59> case RW_WD_CTRL:\n<60> \n<61> timer_watchdog_update(t, value);\n<62> \n<63> break;\n<64> \n<65> case RW_ACK_INTR:\n<66> \n<67> t->rw_ack_intr = value;\n<68> \n<69> timer_update_irq(t);\n<70> \n<71> t->rw_ack_intr = 0;\n<72> \n<73> break;\n<74> \n<75> default:\n<76> \n<77> printf ("%s " TARGET_FMT_plx " %x\n",\n<78> \n<79> __func__, addr, value);\n<80> \n<81> break;\n<82> \n<83> }\n<84> \n<85> }\n<86> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void icp_pic_write(void *opaque, target_phys_addr_t offset,\n<2> \n<3> uint64_t value, unsigned size)\n<4> \n<5> {\n<6> \n<7> icp_pic_state *s = (icp_pic_state *)opaque;\n<8> \n<9> \n<10> \n<11> switch (offset >> 2) {\n<12> \n<13> case 2: /* IRQ_ENABLESET */\n<14> \n<15> s->irq_enabled |= value;\n<16> \n<17> break;\n<18> \n<19> case 3: /* IRQ_ENABLECLR */\n<20> \n<21> s->irq_enabled &= ~value;\n<22> \n<23> break;\n<24> \n<25> case 4: /* INT_SOFTSET */\n<26> \n<27> if (value & 1)\n<28> \n<29> icp_pic_set_irq(s, 0, 1);\n<30> \n<31> break;\n<32> \n<33> case 5: /* INT_SOFTCLR */\n<34> \n<35> if (value & 1)\n<36> \n<37> icp_pic_set_irq(s, 0, 0);\n<38> \n<39> break;\n<40> \n<41> case 10: /* FRQ_ENABLESET */\n<42> \n<43> s->fiq_enabled |= value;\n<44> \n<45> break;\n<46> \n<47> case 11: /* FRQ_ENABLECLR */\n<48> \n<49> s->fiq_enabled &= ~value;\n<50> \n<51> break;\n<52> \n<53> case 0: /* IRQ_STATUS */\n<54> \n<55> case 1: /* IRQ_RAWSTAT */\n<56> \n<57> case 8: /* FRQ_STATUS */\n<58> \n<59> case 9: /* FRQ_RAWSTAT */\n<60> \n<61> default:\n<62> \n<63> printf ("icp_pic_write: Bad register offset 0x%x\n", (int)offset);\n<64> \n<65> return;\n<66> \n<67> }\n<68> \n<69> icp_pic_update(s);\n<70> \n<71> }\n<72> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void qdev_prop_set_globals_for_type(DeviceState *dev, const char *typename,\n<2> \n<3> Error **errp)\n<4> \n<5> {\n<6> \n<7> GlobalProperty *prop;\n<8> \n<9> \n<10> \n<11> QTAILQ_FOREACH(prop, &global_props, next) {\n<12> \n<13> Error *err = NULL;\n<14> \n<15> \n<16> \n<17> if (strcmp(typename, prop->driver) != 0) {\n<18> \n<19> continue;\n<20> \n<21> }\n<22> \n<23> prop->not_used = false;\n<24> \n<25> object_property_parse(OBJECT(dev), prop->value, prop->property, &err);\n<26> \n<27> if (err != NULL) {\n<28> \n<29> error_propagate(errp, err);\n<30> \n<31> return;\n<32> \n<33> }\n<34> \n<35> }\n<36> \n<37> }\n<38> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int stream_component_open(PlayerState *is, int stream_index)\n<2> \n<3> {\n<4> \n<5> AVFormatContext *ic = is->ic;\n<6> \n<7> AVCodecContext *avctx;\n<8> \n<9> AVCodec *codec;\n<10> \n<11> SDL_AudioSpec wanted_spec, spec;\n<12> \n<13> AVDictionary *opts;\n<14> \n<15> AVDictionaryEntry *t = NULL;\n<16> \n<17> int ret = 0;\n<18> \n<19> \n<20> \n<21> if (stream_index < 0 || stream_index >= ic->nb_streams)\n<22> \n<23> return -1;\n<24> \n<25> avctx = ic->streams[stream_index]->codec;\n<26> \n<27> \n<28> \n<29> opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], NULL);\n<30> \n<31> \n<32> \n<33> codec = avcodec_find_decoder(avctx->codec_id);\n<34> \n<35> avctx->workaround_bugs   = workaround_bugs;\n<36> \n<37> avctx->idct_algo         = idct;\n<38> \n<39> avctx->skip_frame        = skip_frame;\n<40> \n<41> avctx->skip_idct         = skip_idct;\n<42> \n<43> avctx->skip_loop_filter  = skip_loop_filter;\n<44> \n<45> avctx->error_concealment = error_concealment;\n<46> \n<47> \n<48> \n<49> if (fast)\n<50> \n<51> avctx->flags2 |= AV_CODEC_FLAG2_FAST;\n<52> \n<53> \n<54> \n<55> if (!av_dict_get(opts, "threads", NULL, 0))\n<56> \n<57> av_dict_set(&opts, "threads", "auto", 0);\n<58> \n<59> if (avctx->codec_type == AVMEDIA_TYPE_VIDEO)\n<60> \n<61> av_dict_set(&opts, "refcounted_frames", "1", 0);\n<62> \n<63> if (!codec ||\n<64> \n<65> (ret = avcodec_open2(avctx, codec, &opts)) < 0) {\n<66> \n<67> goto fail;\n<68> \n<69> }\n<70> \n<71> if ((t = av_dict_get(opts, "", NULL, AV_DICT_IGNORE_SUFFIX))) {\n<72> \n<73> av_log(NULL, AV_LOG_ERROR, "Option %s not found.\n", t->key);\n<74> \n<75> ret =  AVERROR_OPTION_NOT_FOUND;\n<76> \n<77> goto fail;\n<78> \n<79> }\n<80> \n<81> \n<82> \n<83> /* prepare audio output */\n<84> \n<85> if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n<86> \n<87> is->sdl_sample_rate = avctx->sample_rate;\n<88> \n<89> \n<90> \n<91> if (!avctx->channel_layout)\n<92> \n<93> avctx->channel_layout = av_get_default_channel_layout(avctx->channels);\n<94> \n<95> if (!avctx->channel_layout) {\n<96> \n<97> fprintf(stderr, "unable to guess channel layout\n");\n<98> \n<99> ret = AVERROR_INVALIDDATA;\n<100> \n<101> goto fail;\n<102> \n<103> }\n<104> \n<105> if (avctx->channels == 1)\n<106> \n<107> is->sdl_channel_layout = AV_CH_LAYOUT_MONO;\n<108> \n<109> else\n<110> \n<111> is->sdl_channel_layout = AV_CH_LAYOUT_STEREO;\n<112> \n<113> is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout);\n<114> \n<115> \n<116> \n<117> wanted_spec.format = AUDIO_S16SYS;\n<118> \n<119> wanted_spec.freq = is->sdl_sample_rate;\n<120> \n<121> wanted_spec.channels = is->sdl_channels;\n<122> \n<123> wanted_spec.silence = 0;\n<124> \n<125> wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;\n<126> \n<127> wanted_spec.callback = sdl_audio_callback;\n<128> \n<129> wanted_spec.userdata = is;\n<130> \n<131> if (SDL_OpenAudio(&wanted_spec, &spec) < 0) {\n<132> \n<133> fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError());\n<134> \n<135> ret = AVERROR_UNKNOWN;\n<136> \n<137> goto fail;\n<138> \n<139> }\n<140> \n<141> is->audio_hw_buf_size = spec.size;\n<142> \n<143> is->sdl_sample_fmt          = AV_SAMPLE_FMT_S16;\n<144> \n<145> is->resample_sample_fmt     = is->sdl_sample_fmt;\n<146> \n<147> is->resample_channel_layout = avctx->channel_layout;\n<148> \n<149> is->resample_sample_rate    = avctx->sample_rate;\n<150> \n<151> }\n<152> \n<153> \n<154> \n<155> ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;\n<156> \n<157> switch (avctx->codec_type) {\n<158> \n<159> case AVMEDIA_TYPE_AUDIO:\n<160> \n<161> is->audio_stream = stream_index;\n<162> \n<163> is->audio_st = ic->streams[stream_index];\n<164> \n<165> is->audio_buf_size  = 0;\n<166> \n<167> is->audio_buf_index = 0;\n<168> \n<169> \n<170> \n<171> /* init averaging filter */\n<172> \n<173> is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);\n<174> \n<175> is->audio_diff_avg_count = 0;\n<176> \n<177> /* since we do not have a precise anough audio fifo fullness,\n<178> \n<179> we correct audio sync only if larger than this threshold */\n<180> \n<181> is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / avctx->sample_rate;\n<182> \n<183> \n<184> \n<185> memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));\n<186> \n<187> packet_queue_init(&is->audioq);\n<188> \n<189> SDL_PauseAudio(0);\n<190> \n<191> break;\n<192> \n<193> case AVMEDIA_TYPE_VIDEO:\n<194> \n<195> is->video_stream = stream_index;\n<196> \n<197> is->video_st = ic->streams[stream_index];\n<198> \n<199> \n<200> \n<201> packet_queue_init(&is->videoq);\n<202> \n<203> is->video_tid = SDL_CreateThread(video_thread, is);\n<204> \n<205> break;\n<206> \n<207> case AVMEDIA_TYPE_SUBTITLE:\n<208> \n<209> is->subtitle_stream = stream_index;\n<210> \n<211> is->subtitle_st = ic->streams[stream_index];\n<212> \n<213> packet_queue_init(&is->subtitleq);\n<214> \n<215> \n<216> \n<217> is->subtitle_tid = SDL_CreateThread(subtitle_thread, is);\n<218> \n<219> break;\n<220> \n<221> default:\n<222> \n<223> break;\n<224> \n<225> }\n<226> \n<227> \n<228> \n<229> fail:\n<230> \n<231> av_dict_free(&opts);\n<232> \n<233> \n<234> \n<235> return ret;\n<236> \n<237> }\n<238> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) {\n<2> struct cpio * cpio ;\n<3> const void * h ;\n<4> struct archive_string_conv * sconv ;\n<5> size_t namelength ;\n<6> size_t name_pad ;\n<7> int r ;\n<8> cpio = ( struct cpio * ) ( a -> format -> data ) ;\n<9> sconv = cpio -> opt_sconv ;\n<10> if ( sconv == NULL ) {\n<11> if ( ! cpio -> init_default_conversion ) {\n<12> cpio -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ;\n<13> cpio -> init_default_conversion = 1 ;\n<14> }\n<15> sconv = cpio -> sconv_default ;\n<16> }\n<17> r = ( cpio -> read_header ( a , cpio , entry , & namelength , & name_pad ) ) ;\n<18> if ( r < ARCHIVE_WARN ) return ( r ) ;\n<19> h = __archive_read_ahead ( a , namelength + name_pad , NULL ) ;\n<20> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<21> if ( archive_entry_copy_pathname_l ( entry , ( const char * ) h , namelength , sconv ) != 0 ) {\n<22> if ( errno == ENOMEM ) {\n<23> archive_set_error ( & a -> archive , ENOMEM , "Can't allocate memory for Pathname" ) ;\n<24> return ( ARCHIVE_FATAL ) ;\n<25> }\n<26> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Pathname can't be converted from %s to current locale." , archive_string_conversion_charset_name ( sconv ) ) ;\n<27> r = ARCHIVE_WARN ;\n<28> }\n<29> cpio -> entry_offset = 0 ;\n<30> __archive_read_consume ( a , namelength + name_pad ) ;\n<31> if ( archive_entry_filetype ( entry ) == AE_IFLNK ) {\n<32> h = __archive_read_ahead ( a , ( size_t ) cpio -> entry_bytes_remaining , NULL ) ;\n<33> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<34> if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) {\n<35> if ( errno == ENOMEM ) {\n<36> archive_set_error ( & a -> archive , ENOMEM , "Can't allocate memory for Linkname" ) ;\n<37> return ( ARCHIVE_FATAL ) ;\n<38> }\n<39> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Linkname can't be converted from %s to " "current locale." , archive_string_conversion_charset_name ( sconv ) ) ;\n<40> r = ARCHIVE_WARN ;\n<41> }\n<42> __archive_read_consume ( a , cpio -> entry_bytes_remaining ) ;\n<43> cpio -> entry_bytes_remaining = 0 ;\n<44> }\n<45> if ( namelength == 11 && strcmp ( ( const char * ) h , "TRAILER!!!" ) == 0 ) {\n<46> archive_clear_error ( & a -> archive ) ;\n<47> return ( ARCHIVE_EOF ) ;\n<48> }\n<49> if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) {\n<50> return ( ARCHIVE_FATAL ) ;\n<51> }\n<52> return ( r ) ;\n<53> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n<2> \n<3> {\n<4> \n<5> struct nand_state_t *s = opaque;\n<6> \n<7> uint32_t r;\n<8> \n<9> int rdy;\n<10> \n<11> \n<12> \n<13> r = nand_getio(s->nand);\n<14> \n<15> nand_getpins(s->nand, &rdy);\n<16> \n<17> s->rdy = rdy;\n<18> \n<19> \n<20> \n<21> DNAND(printf("%s addr=%x r=%x\n", __func__, addr, r));\n<22> \n<23> return r;\n<24> \n<25> }\n<26> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int xvid_strip_vol_header(AVCodecContext *avctx,\n<2> \n<3> AVPacket *pkt,\n<4> \n<5> unsigned int header_len,\n<6> \n<7> unsigned int frame_len) {\n<8> \n<9> int vo_len = 0, i;\n<10> \n<11> \n<12> \n<13> for( i = 0; i < header_len - 3; i++ ) {\n<14> \n<15> if( pkt->data[i] == 0x00 &&\n<16> \n<17> pkt->data[i+1] == 0x00 &&\n<18> \n<19> pkt->data[i+2] == 0x01 &&\n<20> \n<21> pkt->data[i+3] == 0xB6 ) {\n<22> \n<23> vo_len = i;\n<24> \n<25> break;\n<26> \n<27> }\n<28> \n<29> }\n<30> \n<31> \n<32> \n<33> if( vo_len > 0 ) {\n<34> \n<35> /* We need to store the header, so extract it */\n<36> \n<37> if( avctx->extradata == NULL ) {\n<38> \n<39> avctx->extradata = av_malloc(vo_len);\n<40> \n<41> memcpy(avctx->extradata, pkt->data, vo_len);\n<42> \n<43> avctx->extradata_size = vo_len;\n<44> \n<45> }\n<46> \n<47> /* Less dangerous now, memmove properly copies the two\n<48> \n<49> chunks of overlapping data */\n<50> \n<51> memmove(pkt->data, &pkt->data[vo_len], frame_len - vo_len);\n<52> \n<53> pkt->size = frame_len - vo_len;\n<54> \n<55> }\n<56> \n<57> return 0;\n<58> \n<59> }\n<60> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int oggvorbis_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<2> \n<3> const AVFrame *frame, int *got_packet_ptr)\n<4> \n<5> {\n<6> \n<7> OggVorbisEncContext *s = avctx->priv_data;\n<8> \n<9> ogg_packet op;\n<10> \n<11> int ret, duration;\n<12> \n<13> \n<14> \n<15> /* send samples to libvorbis */\n<16> \n<17> if (frame) {\n<18> \n<19> const int samples = frame->nb_samples;\n<20> \n<21> float **buffer;\n<22> \n<23> int c, channels = s->vi.channels;\n<24> \n<25> \n<26> \n<27> buffer = vorbis_analysis_buffer(&s->vd, samples);\n<28> \n<29> for (c = 0; c < channels; c++) {\n<30> \n<31> int co = (channels > 8) ? c :\n<32> \n<33> ff_vorbis_encoding_channel_layout_offsets[channels - 1][c];\n<34> \n<35> memcpy(buffer[c], frame->extended_data[co],\n<36> \n<37> samples * sizeof(*buffer[c]));\n<38> \n<39> }\n<40> \n<41> if ((ret = vorbis_analysis_wrote(&s->vd, samples)) < 0) {\n<42> \n<43> av_log(avctx, AV_LOG_ERROR, "error in vorbis_analysis_wrote()\n");\n<44> \n<45> return vorbis_error_to_averror(ret);\n<46> \n<47> }\n<48> \n<49> if ((ret = ff_af_queue_add(&s->afq, frame)) < 0)\n<50> \n<51> return ret;\n<52> \n<53> } else {\n<54> \n<55> if (!s->eof)\n<56> \n<57> if ((ret = vorbis_analysis_wrote(&s->vd, 0)) < 0) {\n<58> \n<59> av_log(avctx, AV_LOG_ERROR, "error in vorbis_analysis_wrote()\n");\n<60> \n<61> return vorbis_error_to_averror(ret);\n<62> \n<63> }\n<64> \n<65> s->eof = 1;\n<66> \n<67> }\n<68> \n<69> \n<70> \n<71> /* retrieve available packets from libvorbis */\n<72> \n<73> while ((ret = vorbis_analysis_blockout(&s->vd, &s->vb)) == 1) {\n<74> \n<75> if ((ret = vorbis_analysis(&s->vb, NULL)) < 0)\n<76> \n<77> break;\n<78> \n<79> if ((ret = vorbis_bitrate_addblock(&s->vb)) < 0)\n<80> \n<81> break;\n<82> \n<83> \n<84> \n<85> /* add any available packets to the output packet buffer */\n<86> \n<87> while ((ret = vorbis_bitrate_flushpacket(&s->vd, &op)) == 1) {\n<88> \n<89> if (av_fifo_space(s->pkt_fifo) < sizeof(ogg_packet) + op.bytes) {\n<90> \n<91> av_log(avctx, AV_LOG_ERROR, "packet buffer is too small\n");\n<92> \n<93> return AVERROR_BUG;\n<94> \n<95> }\n<96> \n<97> av_fifo_generic_write(s->pkt_fifo, &op, sizeof(ogg_packet), NULL);\n<98> \n<99> av_fifo_generic_write(s->pkt_fifo, op.packet, op.bytes, NULL);\n<100> \n<101> }\n<102> \n<103> if (ret < 0) {\n<104> \n<105> av_log(avctx, AV_LOG_ERROR, "error getting available packets\n");\n<106> \n<107> break;\n<108> \n<109> }\n<110> \n<111> }\n<112> \n<113> if (ret < 0) {\n<114> \n<115> av_log(avctx, AV_LOG_ERROR, "error getting available packets\n");\n<116> \n<117> return vorbis_error_to_averror(ret);\n<118> \n<119> }\n<120> \n<121> \n<122> \n<123> /* check for available packets */\n<124> \n<125> if (av_fifo_size(s->pkt_fifo) < sizeof(ogg_packet))\n<126> \n<127> return 0;\n<128> \n<129> \n<130> \n<131> av_fifo_generic_read(s->pkt_fifo, &op, sizeof(ogg_packet), NULL);\n<132> \n<133> \n<134> \n<135> if ((ret = ff_alloc_packet2(avctx, avpkt, op.bytes)))\n<136> \n<137> return ret;\n<138> \n<139> av_fifo_generic_read(s->pkt_fifo, avpkt->data, op.bytes, NULL);\n<140> \n<141> \n<142> \n<143> avpkt->pts = ff_samples_to_time_base(avctx, op.granulepos);\n<144> \n<145> \n<146> \n<147> duration = avpriv_vorbis_parse_frame(&s->vp, avpkt->data, avpkt->size);\n<148> \n<149> if (duration > 0) {\n<150> \n<151> /* we do not know encoder delay until we get the first packet from\n<152> \n<153> * libvorbis, so we have to update the AudioFrameQueue counts */\n<154> \n<155> if (!avctx->delay && s->afq.frames) {\n<156> \n<157> avctx->delay              = duration;\n<158> \n<159> av_assert0(!s->afq.remaining_delay);\n<160> \n<161> s->afq.frames->duration  += duration;\n<162> \n<163> s->afq.frames->pts       -= duration;\n<164> \n<165> s->afq.remaining_samples += duration;\n<166> \n<167> }\n<168> \n<169> ff_af_queue_remove(&s->afq, duration, &avpkt->pts, &avpkt->duration);\n<170> \n<171> }\n<172> \n<173> \n<174> \n<175> *got_packet_ptr = 1;\n<176> \n<177> return 0;\n<178> \n<179> }\n<180> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> qemu_inject_x86_mce(CPUState *cenv, int bank, uint64_t status,\n<2> \n<3> uint64_t mcg_status, uint64_t addr, uint64_t misc)\n<4> \n<5> {\n<6> \n<7> uint64_t mcg_cap = cenv->mcg_cap;\n<8> \n<9> uint64_t *banks = cenv->mce_banks;\n<10> \n<11> \n<12> \n<13> /*\n<14> \n<15> * if MSR_MCG_CTL is not all 1s, the uncorrected error\n<16> \n<17> * reporting is disabled\n<18> \n<19> */\n<20> \n<21> if ((status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n<22> \n<23> cenv->mcg_ctl != ~(uint64_t)0) {\n<24> \n<25> return;\n<26> \n<27> }\n<28> \n<29> banks += 4 * bank;\n<30> \n<31> /*\n<32> \n<33> * if MSR_MCi_CTL is not all 1s, the uncorrected error\n<34> \n<35> * reporting is disabled for the bank\n<36> \n<37> */\n<38> \n<39> if ((status & MCI_STATUS_UC) && banks[0] != ~(uint64_t)0) {\n<40> \n<41> return;\n<42> \n<43> }\n<44> \n<45> if (status & MCI_STATUS_UC) {\n<46> \n<47> if ((cenv->mcg_status & MCG_STATUS_MCIP) ||\n<48> \n<49> !(cenv->cr[4] & CR4_MCE_MASK)) {\n<50> \n<51> fprintf(stderr, "injects mce exception while previous "\n<52> \n<53> "one is in progress!\n");\n<54> \n<55> qemu_log_mask(CPU_LOG_RESET, "Triple fault\n");\n<56> \n<57> qemu_system_reset_request();\n<58> \n<59> return;\n<60> \n<61> }\n<62> \n<63> if (banks[1] & MCI_STATUS_VAL) {\n<64> \n<65> status |= MCI_STATUS_OVER;\n<66> \n<67> }\n<68> \n<69> banks[2] = addr;\n<70> \n<71> banks[3] = misc;\n<72> \n<73> cenv->mcg_status = mcg_status;\n<74> \n<75> banks[1] = status;\n<76> \n<77> cpu_interrupt(cenv, CPU_INTERRUPT_MCE);\n<78> \n<79> } else if (!(banks[1] & MCI_STATUS_VAL)\n<80> \n<81> || !(banks[1] & MCI_STATUS_UC)) {\n<82> \n<83> if (banks[1] & MCI_STATUS_VAL) {\n<84> \n<85> status |= MCI_STATUS_OVER;\n<86> \n<87> }\n<88> \n<89> banks[2] = addr;\n<90> \n<91> banks[3] = misc;\n<92> \n<93> banks[1] = status;\n<94> \n<95> } else {\n<96> \n<97> banks[1] |= MCI_STATUS_OVER;\n<98> \n<99> }\n<100> \n<101> }\n<102> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void qemu_rdma_dump_id(const char *who, struct ibv_context *verbs)\n<2> \n<3> {\n<4> \n<5> struct ibv_port_attr port;\n<6> \n<7> \n<8> \n<9> if (ibv_query_port(verbs, 1, &port)) {\n<10> \n<11> error_report("Failed to query port information");\n<12> \n<13> return;\n<14> \n<15> }\n<16> \n<17> \n<18> \n<19> printf("%s RDMA Device opened: kernel name %s "\n<20> \n<21> "uverbs device name %s, "\n<22> \n<23> "infiniband_verbs class device path %s, "\n<24> \n<25> "infiniband class device path %s, "\n<26> \n<27> "transport: (%d) %s\n",\n<28> \n<29> who,\n<30> \n<31> verbs->device->name,\n<32> \n<33> verbs->device->dev_name,\n<34> \n<35> verbs->device->dev_path,\n<36> \n<37> verbs->device->ibdev_path,\n<38> \n<39> port.link_layer,\n<40> \n<41> (port.link_layer == IBV_LINK_LAYER_INFINIBAND) ? "Infiniband" :\n<42> \n<43> ((port.link_layer == IBV_LINK_LAYER_ETHERNET)\n<44> \n<45> ? "Ethernet" : "Unknown"));\n<46> \n<47> }\n<48> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int nbd_send_rep_list(int csock, NBDExport *exp)\n<2> \n<3> {\n<4> \n<5> uint64_t magic, name_len;\n<6> \n<7> uint32_t opt, type, len;\n<8> \n<9> \n<10> \n<11> name_len = strlen(exp->name);\n<12> \n<13> magic = cpu_to_be64(NBD_REP_MAGIC);\n<14> \n<15> if (write_sync(csock, &magic, sizeof(magic)) != sizeof(magic)) {\n<16> \n<17> LOG("write failed (magic)");\n<18> \n<19> return -EINVAL;\n<20> \n<21> }\n<22> \n<23> opt = cpu_to_be32(NBD_OPT_LIST);\n<24> \n<25> if (write_sync(csock, &opt, sizeof(opt)) != sizeof(opt)) {\n<26> \n<27> LOG("write failed (opt)");\n<28> \n<29> return -EINVAL;\n<30> \n<31> }\n<32> \n<33> type = cpu_to_be32(NBD_REP_SERVER);\n<34> \n<35> if (write_sync(csock, &type, sizeof(type)) != sizeof(type)) {\n<36> \n<37> LOG("write failed (reply type)");\n<38> \n<39> return -EINVAL;\n<40> \n<41> }\n<42> \n<43> len = cpu_to_be32(name_len + sizeof(len));\n<44> \n<45> if (write_sync(csock, &len, sizeof(len)) != sizeof(len)) {\n<46> \n<47> LOG("write failed (length)");\n<48> \n<49> return -EINVAL;\n<50> \n<51> }\n<52> \n<53> len = cpu_to_be32(name_len);\n<54> \n<55> if (write_sync(csock, &len, sizeof(len)) != sizeof(len)) {\n<56> \n<57> LOG("write failed (length)");\n<58> \n<59> return -EINVAL;\n<60> \n<61> }\n<62> \n<63> if (write_sync(csock, exp->name, name_len) != name_len) {\n<64> \n<65> LOG("write failed (buffer)");\n<66> \n<67> return -EINVAL;\n<68> \n<69> }\n<70> \n<71> return 0;\n<72> \n<73> }\n<74> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int yuv4_write_packet(AVFormatContext *s, AVPacket *pkt)\n<2> \n<3> {\n<4> \n<5> AVStream *st = s->streams[pkt->stream_index];\n<6> \n<7> AVIOContext *pb = s->pb;\n<8> \n<9> AVFrame *frame;\n<10> \n<11> int* first_pkt = s->priv_data;\n<12> \n<13> int width, height, h_chroma_shift, v_chroma_shift;\n<14> \n<15> int i;\n<16> \n<17> char buf2[Y4M_LINE_MAX + 1];\n<18> \n<19> uint8_t *ptr, *ptr1, *ptr2;\n<20> \n<21> \n<22> \n<23> frame = (AVFrame *)pkt->data;\n<24> \n<25> \n<26> \n<27> /* for the first packet we have to output the header as well */\n<28> \n<29> if (*first_pkt) {\n<30> \n<31> *first_pkt = 0;\n<32> \n<33> if (yuv4_generate_header(s, buf2) < 0) {\n<34> \n<35> av_log(s, AV_LOG_ERROR,\n<36> \n<37> "Error. YUV4MPEG stream header write failed.\n");\n<38> \n<39> return AVERROR(EIO);\n<40> \n<41> } else {\n<42> \n<43> avio_write(pb, buf2, strlen(buf2));\n<44> \n<45> }\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> /* construct frame header */\n<52> \n<53> \n<54> \n<55> avio_printf(s->pb, "%s\n", Y4M_FRAME_MAGIC);\n<56> \n<57> \n<58> \n<59> width  = st->codecpar->width;\n<60> \n<61> height = st->codecpar->height;\n<62> \n<63> \n<64> \n<65> ptr = frame->data[0];\n<66> \n<67> \n<68> \n<69> switch (st->codecpar->format) {\n<70> \n<71> case AV_PIX_FMT_GRAY8:\n<72> \n<73> case AV_PIX_FMT_YUV411P:\n<74> \n<75> case AV_PIX_FMT_YUV420P:\n<76> \n<77> case AV_PIX_FMT_YUV422P:\n<78> \n<79> case AV_PIX_FMT_YUV444P:\n<80> \n<81> break;\n<82> \n<83> case AV_PIX_FMT_GRAY16:\n<84> \n<85> case AV_PIX_FMT_YUV420P9:\n<86> \n<87> case AV_PIX_FMT_YUV422P9:\n<88> \n<89> case AV_PIX_FMT_YUV444P9:\n<90> \n<91> case AV_PIX_FMT_YUV420P10:\n<92> \n<93> case AV_PIX_FMT_YUV422P10:\n<94> \n<95> case AV_PIX_FMT_YUV444P10:\n<96> \n<97> case AV_PIX_FMT_YUV420P12:\n<98> \n<99> case AV_PIX_FMT_YUV422P12:\n<100> \n<101> case AV_PIX_FMT_YUV444P12:\n<102> \n<103> case AV_PIX_FMT_YUV420P14:\n<104> \n<105> case AV_PIX_FMT_YUV422P14:\n<106> \n<107> case AV_PIX_FMT_YUV444P14:\n<108> \n<109> case AV_PIX_FMT_YUV420P16:\n<110> \n<111> case AV_PIX_FMT_YUV422P16:\n<112> \n<113> case AV_PIX_FMT_YUV444P16:\n<114> \n<115> width *= 2;\n<116> \n<117> break;\n<118> \n<119> default:\n<120> \n<121> av_log(s, AV_LOG_ERROR, "The pixel format '%s' is not supported.\n",\n<122> \n<123> av_get_pix_fmt_name(st->codecpar->format));\n<124> \n<125> return AVERROR(EINVAL);\n<126> \n<127> }\n<128> \n<129> \n<130> \n<131> for (i = 0; i < height; i++) {\n<132> \n<133> avio_write(pb, ptr, width);\n<134> \n<135> ptr += frame->linesize[0];\n<136> \n<137> }\n<138> \n<139> \n<140> \n<141> if (st->codecpar->format != AV_PIX_FMT_GRAY8 &&\n<142> \n<143> st->codecpar->format != AV_PIX_FMT_GRAY16) {\n<144> \n<145> // Adjust for smaller Cb and Cr planes\n<146> \n<147> av_pix_fmt_get_chroma_sub_sample(st->codecpar->format, &h_chroma_shift,\n<148> \n<149> &v_chroma_shift);\n<150> \n<151> // Shift right, rounding up\n<152> \n<153> width  = AV_CEIL_RSHIFT(width,  h_chroma_shift);\n<154> \n<155> height = AV_CEIL_RSHIFT(height, v_chroma_shift);\n<156> \n<157> \n<158> \n<159> ptr1 = frame->data[1];\n<160> \n<161> ptr2 = frame->data[2];\n<162> \n<163> for (i = 0; i < height; i++) {     /* Cb */\n<164> \n<165> avio_write(pb, ptr1, width);\n<166> \n<167> ptr1 += frame->linesize[1];\n<168> \n<169> }\n<170> \n<171> for (i = 0; i < height; i++) {     /* Cr */\n<172> \n<173> avio_write(pb, ptr2, width);\n<174> \n<175> ptr2 += frame->linesize[2];\n<176> \n<177> }\n<178> \n<179> }\n<180> \n<181> \n<182> \n<183> return 0;\n<184> \n<185> }\n<186> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
geminigemini

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int omap_dma_ch_reg_write(struct omap_dma_s *s,\n<2> \n<3> int ch, int reg, uint16_t value) {\n<4> \n<5> switch (reg) {\n<6> \n<7> case 0x00:	/* SYS_DMA_CSDP_CH0 */\n<8> \n<9> s->ch[ch].burst[1] = (value & 0xc000) >> 14;\n<10> \n<11> s->ch[ch].pack[1] = (value & 0x2000) >> 13;\n<12> \n<13> s->ch[ch].port[1] = (enum omap_dma_port) ((value & 0x1e00) >> 9);\n<14> \n<15> s->ch[ch].burst[0] = (value & 0x0180) >> 7;\n<16> \n<17> s->ch[ch].pack[0] = (value & 0x0040) >> 6;\n<18> \n<19> s->ch[ch].port[0] = (enum omap_dma_port) ((value & 0x003c) >> 2);\n<20> \n<21> s->ch[ch].data_type = (1 << (value & 3));\n<22> \n<23> if (s->ch[ch].port[0] >= omap_dma_port_last)\n<24> \n<25> printf("%s: invalid DMA port %i\n", __FUNCTION__,\n<26> \n<27> s->ch[ch].port[0]);\n<28> \n<29> if (s->ch[ch].port[1] >= omap_dma_port_last)\n<30> \n<31> printf("%s: invalid DMA port %i\n", __FUNCTION__,\n<32> \n<33> s->ch[ch].port[1]);\n<34> \n<35> if ((value & 3) == 3)\n<36> \n<37> printf("%s: bad data_type for DMA channel %i\n", __FUNCTION__, ch);\n<38> \n<39> break;\n<40> \n<41> \n<42> \n<43> case 0x02:	/* SYS_DMA_CCR_CH0 */\n<44> \n<45> s->ch[ch].mode[1] = (omap_dma_addressing_t) ((value & 0xc000) >> 14);\n<46> \n<47> s->ch[ch].mode[0] = (omap_dma_addressing_t) ((value & 0x3000) >> 12);\n<48> \n<49> s->ch[ch].end_prog = (value & 0x0800) >> 11;\n<50> \n<51> s->ch[ch].repeat = (value & 0x0200) >> 9;\n<52> \n<53> s->ch[ch].auto_init = (value & 0x0100) >> 8;\n<54> \n<55> s->ch[ch].priority = (value & 0x0040) >> 6;\n<56> \n<57> s->ch[ch].fs = (value & 0x0020) >> 5;\n<58> \n<59> s->ch[ch].sync = value & 0x001f;\n<60> \n<61> if (value & 0x0080) {\n<62> \n<63> if (s->ch[ch].running) {\n<64> \n<65> if (!s->ch[ch].signalled &&\n<66> \n<67> s->ch[ch].auto_init && s->ch[ch].end_prog)\n<68> \n<69> omap_dma_channel_load(s, ch);\n<70> \n<71> } else {\n<72> \n<73> s->ch[ch].running = 1;\n<74> \n<75> omap_dma_channel_load(s, ch);\n<76> \n<77> }\n<78> \n<79> if (!s->ch[ch].sync || (s->drq & (1 << s->ch[ch].sync)))\n<80> \n<81> omap_dma_request_run(s, ch, 0);\n<82> \n<83> } else {\n<84> \n<85> s->ch[ch].running = 0;\n<86> \n<87> omap_dma_request_stop(s, ch);\n<88> \n<89> }\n<90> \n<91> break;\n<92> \n<93> \n<94> \n<95> case 0x04:	/* SYS_DMA_CICR_CH0 */\n<96> \n<97> s->ch[ch].interrupts = value & 0x003f;\n<98> \n<99> break;\n<100> \n<101> \n<102> \n<103> case 0x06:	/* SYS_DMA_CSR_CH0 */\n<104> \n<105> return 1;\n<106> \n<107> \n<108> \n<109> case 0x08:	/* SYS_DMA_CSSA_L_CH0 */\n<110> \n<111> s->ch[ch].addr[0] &= 0xffff0000;\n<112> \n<113> s->ch[ch].addr[0] |= value;\n<114> \n<115> break;\n<116> \n<117> \n<118> \n<119> case 0x0a:	/* SYS_DMA_CSSA_U_CH0 */\n<120> \n<121> s->ch[ch].addr[0] &= 0x0000ffff;\n<122> \n<123> s->ch[ch].addr[0] |= value << 16;\n<124> \n<125> break;\n<126> \n<127> \n<128> \n<129> case 0x0c:	/* SYS_DMA_CDSA_L_CH0 */\n<130> \n<131> s->ch[ch].addr[1] &= 0xffff0000;\n<132> \n<133> s->ch[ch].addr[1] |= value;\n<134> \n<135> break;\n<136> \n<137> \n<138> \n<139> case 0x0e:	/* SYS_DMA_CDSA_U_CH0 */\n<140> \n<141> s->ch[ch].addr[1] &= 0x0000ffff;\n<142> \n<143> s->ch[ch].addr[1] |= value << 16;\n<144> \n<145> break;\n<146> \n<147> \n<148> \n<149> case 0x10:	/* SYS_DMA_CEN_CH0 */\n<150> \n<151> s->ch[ch].elements = value & 0xffff;\n<152> \n<153> break;\n<154> \n<155> \n<156> \n<157> case 0x12:	/* SYS_DMA_CFN_CH0 */\n<158> \n<159> s->ch[ch].frames = value & 0xffff;\n<160> \n<161> break;\n<162> \n<163> \n<164> \n<165> case 0x14:	/* SYS_DMA_CFI_CH0 */\n<166> \n<167> s->ch[ch].frame_index = value & 0xffff;\n<168> \n<169> break;\n<170> \n<171> \n<172> \n<173> case 0x16:	/* SYS_DMA_CEI_CH0 */\n<174> \n<175> s->ch[ch].element_index = value & 0xffff;\n<176> \n<177> break;\n<178> \n<179> \n<180> \n<181> case 0x18:	/* SYS_DMA_CPC_CH0 */\n<182> \n<183> return 1;\n<184> \n<185> \n<186> \n<187> default:\n<188> \n<189> OMAP_BAD_REG((unsigned long) reg);\n<190> \n<191> }\n<192> \n<193> return 0;\n<194> \n<195> }\n<196> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void *kvmppc_create_spapr_tce(uint32_t liobn, uint32_t window_size, int *pfd)\n<2> \n<3> {\n<4> \n<5> struct kvm_create_spapr_tce args = {\n<6> \n<7> .liobn = liobn,\n<8> \n<9> .window_size = window_size,\n<10> \n<11> };\n<12> \n<13> long len;\n<14> \n<15> int fd;\n<16> \n<17> void *table;\n<18> \n<19> \n<20> \n<21> /* Must set fd to -1 so we don't try to munmap when called for\n<22> \n<23> * destroying the table, which the upper layers -will- do\n<24> \n<25> */\n<26> \n<27> *pfd = -1;\n<28> \n<29> if (!cap_spapr_tce) {\n<30> \n<31> return NULL;\n<32> \n<33> }\n<34> \n<35> \n<36> \n<37> fd = kvm_vm_ioctl(kvm_state, KVM_CREATE_SPAPR_TCE, &args);\n<38> \n<39> if (fd < 0) {\n<40> \n<41> fprintf(stderr, "KVM: Failed to create TCE table for liobn 0x%x\n",\n<42> \n<43> liobn);\n<44> \n<45> return NULL;\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> len = (window_size / SPAPR_TCE_PAGE_SIZE) * sizeof(sPAPRTCE);\n<52> \n<53> /* FIXME: round this up to page size */\n<54> \n<55> \n<56> \n<57> table = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n<58> \n<59> if (table == MAP_FAILED) {\n<60> \n<61> fprintf(stderr, "KVM: Failed to map TCE table for liobn 0x%x\n",\n<62> \n<63> liobn);\n<64> \n<65> close(fd);\n<66> \n<67> return NULL;\n<68> \n<69> }\n<70> \n<71> \n<72> \n<73> *pfd = fd;\n<74> \n<75> return table;\n<76> \n<77> }\n<78> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int jbig2_decode_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2TextRegionParams * params , const Jbig2SymbolDict * const * dicts , const int n_dicts , Jbig2Image * image , const byte * data , const size_t size , Jbig2ArithCx * GR_stats , Jbig2ArithState * as , Jbig2WordStream * ws ) {\n<2> uint32_t NINSTANCES ;\n<3> uint32_t ID ;\n<4> int32_t STRIPT ;\n<5> int32_t FIRSTS ;\n<6> int32_t DT ;\n<7> int32_t DFS ;\n<8> int32_t IDS ;\n<9> int32_t CURS ;\n<10> int32_t CURT ;\n<11> int S , T ;\n<12> int x , y ;\n<13> bool first_symbol ;\n<14> uint32_t index , SBNUMSYMS ;\n<15> Jbig2Image * IB = NULL ;\n<16> Jbig2HuffmanState * hs = NULL ;\n<17> Jbig2HuffmanTable * SBSYMCODES = NULL ;\n<18> int code = 0 ;\n<19> int RI ;\n<20> SBNUMSYMS = 0 ;\n<21> for ( index = 0 ;\n<22> index < n_dicts ;\n<23> index ++ ) {\n<24> SBNUMSYMS += dicts [ index ] -> n_symbols ;\n<25> }\n<26> jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , "symbol list contains %d glyphs in %d dictionaries" , SBNUMSYMS , n_dicts ) ;\n<27> if ( params -> SBHUFF ) {\n<28> Jbig2HuffmanTable * runcodes = NULL ;\n<29> Jbig2HuffmanParams runcodeparams ;\n<30> Jbig2HuffmanLine runcodelengths [ 35 ] ;\n<31> Jbig2HuffmanLine * symcodelengths = NULL ;\n<32> Jbig2HuffmanParams symcodeparams ;\n<33> int err , len , range , r ;\n<34> jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , "huffman coded text region" ) ;\n<35> hs = jbig2_huffman_new ( ctx , ws ) ;\n<36> if ( hs == NULL ) {\n<37> jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , "failed to allocate storage for text region" ) ;\n<38> return - 1 ;\n<39> }\n<40> for ( index = 0 ;\n<41> index < 35 ;\n<42> index ++ ) {\n<43> runcodelengths [ index ] . PREFLEN = jbig2_huffman_get_bits ( hs , 4 , & code ) ;\n<44> if ( code < 0 ) goto cleanup1 ;\n<45> runcodelengths [ index ] . RANGELEN = 0 ;\n<46> runcodelengths [ index ] . RANGELOW = index ;\n<47> jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , " read runcode%d length %d" , index , runcodelengths [ index ] . PREFLEN ) ;\n<48> }\n<49> runcodeparams . HTOOB = 0 ;\n<50> runcodeparams . lines = runcodelengths ;\n<51> runcodeparams . n_lines = 35 ;\n<52> runcodes = jbig2_build_huffman_table ( ctx , & runcodeparams ) ;\n<53> if ( runcodes == NULL ) {\n<54> jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "error constructing symbol id runcode table!" ) ;\n<55> code = - 1 ;\n<56> goto cleanup1 ;\n<57> }\n<58> symcodelengths = jbig2_new ( ctx , Jbig2HuffmanLine , SBNUMSYMS ) ;\n<59> if ( symcodelengths == NULL ) {\n<60> jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "memory allocation failure reading symbol ID huffman table!" ) ;\n<61> code = - 1 ;\n<62> goto cleanup1 ;\n<63> }\n<64> index = 0 ;\n<65> while ( index < SBNUMSYMS ) {\n<66> code = jbig2_huffman_get ( hs , runcodes , & err ) ;\n<67> if ( err != 0 || code < 0 || code >= 35 ) {\n<68> jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "error reading symbol ID huffman table!" ) ;\n<69> code = err ? err : - 1 ;\n<70> goto cleanup1 ;\n<71> }\n<72> if ( code < 32 ) {\n<73> len = code ;\n<74> range = 1 ;\n<75> }\n<76> else {\n<77> if ( code == 32 ) {\n<78> if ( index < 1 ) {\n<79> jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "error decoding symbol id table: run length with no antecedent!" ) ;\n<80> code = - 1 ;\n<81> goto cleanup1 ;\n<82> }\n<83> len = symcodelengths [ index - 1 ] . PREFLEN ;\n<84> }\n<85> else {\n<86> len = 0 ;\n<87> }\n<88> err = 0 ;\n<89> if ( code == 32 ) range = jbig2_huffman_get_bits ( hs , 2 , & err ) + 3 ;\n<90> else if ( code == 33 ) range = jbig2_huffman_get_bits ( hs , 3 , & err ) + 3 ;\n<91> else if ( code == 34 ) range = jbig2_huffman_get_bits ( hs , 7 , & err ) + 11 ;\n<92> if ( err < 0 ) goto cleanup1 ;\n<93> }\n<94> jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , " read runcode%d at index %d (length %d range %d)" , code , index , len , range ) ;\n<95> if ( index + range > SBNUMSYMS ) {\n<96> jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , "runlength extends %d entries beyond the end of symbol id table!" , index + range - SBNUMSYMS ) ;\n<97> range = SBNUMSYMS - index ;\n<98> }\n<99> for ( r = 0 ;\n<100> r < range ;\n<101> r ++ ) {\n<102> symcodelengths [ index + r ] . PREFLEN = len ;\n<103> symcodelengths [ index + r ] . RANGELEN = 0 ;\n<104> symcodelengths [ index + r ] . RANGELOW = index + r ;\n<105> }\n<106> index += r ;\n<107> }\n<108> if ( index < SBNUMSYMS ) {\n<109> jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , "runlength codes do not cover the available symbol set" ) ;\n<110> }\n<111> symcodeparams . HTOOB = 0 ;\n<112> symcodeparams . lines = symcodelengths ;\n<113> symcodeparams . n_lines = SBNUMSYMS ;\n<114> jbig2_huffman_skip ( hs ) ;\n<115> SBSYMCODES = jbig2_build_huffman_table ( ctx , & symcodeparams ) ;\n<116> cleanup1 : jbig2_free ( ctx -> allocator , symcodelengths ) ;\n<117> jbig2_release_huffman_table ( ctx , runcodes ) ;\n<118> if ( SBSYMCODES == NULL ) {\n<119> jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "could not construct Symbol ID huffman table!" ) ;\n<120> jbig2_huffman_free ( ctx , hs ) ;\n<121> return ( ( code != 0 ) ? code : - 1 ) ;\n<122> }\n<123> }\n<124> jbig2_image_clear ( ctx , image , params -> SBDEFPIXEL ) ;\n<125> if ( params -> SBHUFF ) {\n<126> STRIPT = jbig2_huffman_get ( hs , params -> SBHUFFDT , & code ) ;\n<127> }\n<128> else {\n<129> code = jbig2_arith_int_decode ( params -> IADT , as , & STRIPT ) ;\n<130> }\n<131> if ( code < 0 ) goto cleanup2 ;\n<132> STRIPT *= - ( params -> SBSTRIPS ) ;\n<133> FIRSTS = 0 ;\n<134> NINSTANCES = 0 ;\n<135> while ( NINSTANCES < params -> SBNUMINSTANCES ) {\n<136> if ( params -> SBHUFF ) {\n<137> DT = jbig2_huffman_get ( hs , params -> SBHUFFDT , & code ) ;\n<138> }\n<139> else {\n<140> code = jbig2_arith_int_decode ( params -> IADT , as , & DT ) ;\n<141> }\n<142> if ( code < 0 ) goto cleanup2 ;\n<143> DT *= params -> SBSTRIPS ;\n<144> STRIPT += DT ;\n<145> first_symbol = TRUE ;\n<146> for ( ;\n<147> ;\n<148> ) {\n<149> if ( first_symbol ) {\n<150> if ( params -> SBHUFF ) {\n<151> DFS = jbig2_huffman_get ( hs , params -> SBHUFFFS , & code ) ;\n<152> }\n<153> else {\n<154> code = jbig2_arith_int_decode ( params -> IAFS , as , & DFS ) ;\n<155> }\n<156> if ( code < 0 ) goto cleanup2 ;\n<157> FIRSTS += DFS ;\n<158> CURS = FIRSTS ;\n<159> first_symbol = FALSE ;\n<160> }\n<161> else {\n<162> if ( NINSTANCES > params -> SBNUMINSTANCES ) {\n<163> code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "too many NINSTANCES (%d) decoded" , NINSTANCES ) ;\n<164> break ;\n<165> }\n<166> if ( params -> SBHUFF ) {\n<167> IDS = jbig2_huffman_get ( hs , params -> SBHUFFDS , & code ) ;\n<168> }\n<169> else {\n<170> code = jbig2_arith_int_decode ( params -> IADS , as , & IDS ) ;\n<171> }\n<172> if ( code ) {\n<173> break ;\n<174> }\n<175> CURS += IDS + params -> SBDSOFFSET ;\n<176> }\n<177> if ( params -> SBSTRIPS == 1 ) {\n<178> CURT = 0 ;\n<179> }\n<180> else if ( params -> SBHUFF ) {\n<181> CURT = jbig2_huffman_get_bits ( hs , params -> LOGSBSTRIPS , & code ) ;\n<182> }\n<183> else {\n<184> code = jbig2_arith_int_decode ( params -> IAIT , as , & CURT ) ;\n<185> }\n<186> if ( code < 0 ) goto cleanup2 ;\n<187> T = STRIPT + CURT ;\n<188> if ( params -> SBHUFF ) {\n<189> ID = jbig2_huffman_get ( hs , SBSYMCODES , & code ) ;\n<190> }\n<191> else {\n<192> code = jbig2_arith_iaid_decode ( params -> IAID , as , ( int * ) & ID ) ;\n<193> }\n<194> if ( code < 0 ) goto cleanup2 ;\n<195> if ( ID >= SBNUMSYMS ) {\n<196> code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "symbol id out of range! (%d/%d)" , ID , SBNUMSYMS ) ;\n<197> goto cleanup2 ;\n<198> }\n<199> {\n<200> uint32_t id = ID ;\n<201> index = 0 ;\n<202> while ( id >= dicts [ index ] -> n_symbols ) id -= dicts [ index ++ ] -> n_symbols ;\n<203> IB = jbig2_image_clone ( ctx , dicts [ index ] -> glyphs [ id ] ) ;\n<204> if ( ! IB ) {\n<205> code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "missing glyph %d/%d!" , index , id ) ;\n<206> goto cleanup2 ;\n<207> }\n<208> }\n<209> if ( params -> SBREFINE ) {\n<210> if ( params -> SBHUFF ) {\n<211> RI = jbig2_huffman_get_bits ( hs , 1 , & code ) ;\n<212> }\n<213> else {\n<214> code = jbig2_arith_int_decode ( params -> IARI , as , & RI ) ;\n<215> }\n<216> if ( code < 0 ) goto cleanup2 ;\n<217> }\n<218> else {\n<219> RI = 0 ;\n<220> }\n<221> if ( RI ) {\n<222> Jbig2RefinementRegionParams rparams ;\n<223> Jbig2Image * IBO ;\n<224> int32_t RDW , RDH , RDX , RDY ;\n<225> Jbig2Image * refimage ;\n<226> int BMSIZE = 0 ;\n<227> int code1 = 0 ;\n<228> int code2 = 0 ;\n<229> int code3 = 0 ;\n<230> int code4 = 0 ;\n<231> int code5 = 0 ;\n<232> if ( ! params -> SBHUFF ) {\n<233> code1 = jbig2_arith_int_decode ( params -> IARDW , as , & RDW ) ;\n<234> code2 = jbig2_arith_int_decode ( params -> IARDH , as , & RDH ) ;\n<235> code3 = jbig2_arith_int_decode ( params -> IARDX , as , & RDX ) ;\n<236> code4 = jbig2_arith_int_decode ( params -> IARDY , as , & RDY ) ;\n<237> }\n<238> else {\n<239> RDW = jbig2_huffman_get ( hs , params -> SBHUFFRDW , & code1 ) ;\n<240> RDH = jbig2_huffman_get ( hs , params -> SBHUFFRDH , & code2 ) ;\n<241> RDX = jbig2_huffman_get ( hs , params -> SBHUFFRDX , & code3 ) ;\n<242> RDY = jbig2_huffman_get ( hs , params -> SBHUFFRDY , & code4 ) ;\n<243> BMSIZE = jbig2_huffman_get ( hs , params -> SBHUFFRSIZE , & code5 ) ;\n<244> jbig2_huffman_skip ( hs ) ;\n<245> }\n<246> if ( ( code1 < 0 ) || ( code2 < 0 ) || ( code3 < 0 ) || ( code4 < 0 ) || ( code5 < 0 ) ) {\n<247> code = jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "failed to decode data" ) ;\n<248> goto cleanup2 ;\n<249> }\n<250> IBO = IB ;\n<251> refimage = jbig2_image_new ( ctx , IBO -> width + RDW , IBO -> height + RDH ) ;\n<252> if ( refimage == NULL ) {\n<253> jbig2_image_release ( ctx , IBO ) ;\n<254> if ( params -> SBHUFF ) {\n<255> jbig2_release_huffman_table ( ctx , SBSYMCODES ) ;\n<256> }\n<257> return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "couldn't allocate reference image" ) ;\n<258> }\n<259> jbig2_image_clear ( ctx , refimage , 0x00 ) ;\n<260> rparams . GRTEMPLATE = params -> SBRTEMPLATE ;\n<261> rparams . reference = IBO ;\n<262> rparams . DX = ( RDW >> 1 ) + RDX ;\n<263> rparams . DY = ( RDH >> 1 ) + RDY ;\n<264> rparams . TPGRON = 0 ;\n<265> memcpy ( rparams . grat , params -> sbrat , 4 ) ;\n<266> code = jbig2_decode_refinement_region ( ctx , segment , & rparams , as , refimage , GR_stats ) ;\n<267> if ( code < 0 ) {\n<268> jbig2_image_release ( ctx , refimage ) ;\n<269> goto cleanup2 ;\n<270> }\n<271> IB = refimage ;\n<272> jbig2_image_release ( ctx , IBO ) ;\n<273> if ( params -> SBHUFF ) {\n<274> jbig2_huffman_advance ( hs , BMSIZE ) ;\n<275> }\n<276> }\n<277> if ( ( ! params -> TRANSPOSED ) && ( params -> REFCORNER > 1 ) ) {\n<278> CURS += IB -> width - 1 ;\n<279> }\n<280> else if ( ( params -> TRANSPOSED ) && ! ( params -> REFCORNER & 1 ) ) {\n<281> CURS += IB -> height - 1 ;\n<282> }\n<283> S = CURS ;\n<284> if ( ! params -> TRANSPOSED ) {\n<285> switch ( params -> REFCORNER ) {\n<286> case JBIG2_CORNER_TOPLEFT : x = S ;\n<287> y = T ;\n<288> break ;\n<289> case JBIG2_CORNER_TOPRIGHT : x = S - IB -> width + 1 ;\n<290> y = T ;\n<291> break ;\n<292> case JBIG2_CORNER_BOTTOMLEFT : x = S ;\n<293> y = T - IB -> height + 1 ;\n<294> break ;\n<295> default : case JBIG2_CORNER_BOTTOMRIGHT : x = S - IB -> width + 1 ;\n<296> y = T - IB -> height + 1 ;\n<297> break ;\n<298> }\n<299> }\n<300> else {\n<301> switch ( params -> REFCORNER ) {\n<302> case JBIG2_CORNER_TOPLEFT : x = T ;\n<303> y = S ;\n<304> break ;\n<305> case JBIG2_CORNER_TOPRIGHT : x = T - IB -> width + 1 ;\n<306> y = S ;\n<307> break ;\n<308> case JBIG2_CORNER_BOTTOMLEFT : x = T ;\n<309> y = S - IB -> height + 1 ;\n<310> break ;\n<311> default : case JBIG2_CORNER_BOTTOMRIGHT : x = T - IB -> width + 1 ;\n<312> y = S - IB -> height + 1 ;\n<313> break ;\n<314> }\n<315> }\n<316> # ifdef JBIG2_DEBUG jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , segment -> number , "composing glyph id %d: %dx%d @ (%d,%d) symbol %d/%d" , ID , IB -> width , IB -> height , x , y , NINSTANCES + 1 , params -> SBNUMINSTANCES ) ;\n<317> # endif code = jbig2_image_compose ( ctx , image , IB , x , y , params -> SBCOMBOP ) ;\n<318> if ( code < 0 ) {\n<319> jbig2_image_release ( ctx , IB ) ;\n<320> goto cleanup2 ;\n<321> }\n<322> if ( ( ! params -> TRANSPOSED ) && ( params -> REFCORNER < 2 ) ) {\n<323> CURS += IB -> width - 1 ;\n<324> }\n<325> else if ( ( params -> TRANSPOSED ) && ( params -> REFCORNER & 1 ) ) {\n<326> CURS += IB -> height - 1 ;\n<327> }\n<328> NINSTANCES ++ ;\n<329> jbig2_image_release ( ctx , IB ) ;\n<330> }\n<331> }\n<332> cleanup2 : if ( params -> SBHUFF ) {\n<333> jbig2_release_huffman_table ( ctx , SBSYMCODES ) ;\n<334> }\n<335> jbig2_huffman_free ( ctx , hs ) ;\n<336> return code ;\n<337> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int spapr_vio_check_reg(VIOsPAPRDevice *sdev, VIOsPAPRDeviceInfo *info)\n<2> \n<3> {\n<4> \n<5> VIOsPAPRDevice *other_sdev;\n<6> \n<7> DeviceState *qdev;\n<8> \n<9> VIOsPAPRBus *sbus;\n<10> \n<11> \n<12> \n<13> sbus = DO_UPCAST(VIOsPAPRBus, bus, sdev->qdev.parent_bus);\n<14> \n<15> \n<16> \n<17> /*\n<18> \n<19> * Check two device aren't given clashing addresses by the user (or some\n<20> \n<21> * other mechanism). We have to open code this because we have to check\n<22> \n<23> * for matches with devices other than us.\n<24> \n<25> */\n<26> \n<27> QTAILQ_FOREACH(qdev, &sbus->bus.children, sibling) {\n<28> \n<29> other_sdev = DO_UPCAST(VIOsPAPRDevice, qdev, qdev);\n<30> \n<31> \n<32> \n<33> if (other_sdev != sdev && other_sdev->reg == sdev->reg) {\n<34> \n<35> fprintf(stderr, "vio: %s and %s devices conflict at address %#x\n",\n<36> \n<37> info->qdev.name, other_sdev->qdev.info->name, sdev->reg);\n<38> \n<39> return -EEXIST;\n<40> \n<41> }\n<42> \n<43> }\n<44> \n<45> \n<46> \n<47> return 0;\n<48> \n<49> }\n<50> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static const mon_cmd_t *monitor_parse_command(Monitor *mon,\n<2> \n<3> const char *cmdline,\n<4> \n<5> int start,\n<6> \n<7> mon_cmd_t *table,\n<8> \n<9> QDict *qdict)\n<10> \n<11> {\n<12> \n<13> const char *p, *typestr;\n<14> \n<15> int c;\n<16> \n<17> const mon_cmd_t *cmd;\n<18> \n<19> char cmdname[256];\n<20> \n<21> char buf[1024];\n<22> \n<23> char *key;\n<24> \n<25> \n<26> \n<27> /* extract the command name */\n<28> \n<29> p = get_command_name(cmdline + start, cmdname, sizeof(cmdname));\n<30> \n<31> if (!p)\n<32> \n<33> return NULL;\n<34> \n<35> \n<36> \n<37> cmd = search_dispatch_table(table, cmdname);\n<38> \n<39> if (!cmd) {\n<40> \n<41> monitor_printf(mon, "unknown command: '%.*s'\n",\n<42> \n<43> (int)(p - cmdline), cmdline);\n<44> \n<45> return NULL;\n<46> \n<47> }\n<48> \n<49> \n<50> \n<51> /* filter out following useless space */\n<52> \n<53> while (qemu_isspace(*p)) {\n<54> \n<55> p++;\n<56> \n<57> }\n<58> \n<59> /* search sub command */\n<60> \n<61> if (cmd->sub_table != NULL) {\n<62> \n<63> /* check if user set additional command */\n<64> \n<65> if (*p == '\0') {\n<66> \n<67> return cmd;\n<68> \n<69> }\n<70> \n<71> return monitor_parse_command(mon, cmdline, p - cmdline,\n<72> \n<73> cmd->sub_table, qdict);\n<74> \n<75> }\n<76> \n<77> \n<78> \n<79> /* parse the parameters */\n<80> \n<81> typestr = cmd->args_type;\n<82> \n<83> for(;;) {\n<84> \n<85> typestr = key_get_info(typestr, &key);\n<86> \n<87> if (!typestr)\n<88> \n<89> break;\n<90> \n<91> c = *typestr;\n<92> \n<93> typestr++;\n<94> \n<95> switch(c) {\n<96> \n<97> case 'F':\n<98> \n<99> case 'B':\n<100> \n<101> case 's':\n<102> \n<103> {\n<104> \n<105> int ret;\n<106> \n<107> \n<108> \n<109> while (qemu_isspace(*p))\n<110> \n<111> p++;\n<112> \n<113> if (*typestr == '?') {\n<114> \n<115> typestr++;\n<116> \n<117> if (*p == '\0') {\n<118> \n<119> /* no optional string: NULL argument */\n<120> \n<121> break;\n<122> \n<123> }\n<124> \n<125> }\n<126> \n<127> ret = get_str(buf, sizeof(buf), &p);\n<128> \n<129> if (ret < 0) {\n<130> \n<131> switch(c) {\n<132> \n<133> case 'F':\n<134> \n<135> monitor_printf(mon, "%s: filename expected\n",\n<136> \n<137> cmdname);\n<138> \n<139> break;\n<140> \n<141> case 'B':\n<142> \n<143> monitor_printf(mon, "%s: block device name expected\n",\n<144> \n<145> cmdname);\n<146> \n<147> break;\n<148> \n<149> default:\n<150> \n<151> monitor_printf(mon, "%s: string expected\n", cmdname);\n<152> \n<153> break;\n<154> \n<155> }\n<156> \n<157> goto fail;\n<158> \n<159> }\n<160> \n<161> qdict_put(qdict, key, qstring_from_str(buf));\n<162> \n<163> }\n<164> \n<165> break;\n<166> \n<167> case 'O':\n<168> \n<169> {\n<170> \n<171> QemuOptsList *opts_list;\n<172> \n<173> QemuOpts *opts;\n<174> \n<175> \n<176> \n<177> opts_list = qemu_find_opts(key);\n<178> \n<179> if (!opts_list || opts_list->desc->name) {\n<180> \n<181> goto bad_type;\n<182> \n<183> }\n<184> \n<185> while (qemu_isspace(*p)) {\n<186> \n<187> p++;\n<188> \n<189> }\n<190> \n<191> if (!*p)\n<192> \n<193> break;\n<194> \n<195> if (get_str(buf, sizeof(buf), &p) < 0) {\n<196> \n<197> goto fail;\n<198> \n<199> }\n<200> \n<201> opts = qemu_opts_parse(opts_list, buf, 1);\n<202> \n<203> if (!opts) {\n<204> \n<205> goto fail;\n<206> \n<207> }\n<208> \n<209> qemu_opts_to_qdict(opts, qdict);\n<210> \n<211> qemu_opts_del(opts);\n<212> \n<213> }\n<214> \n<215> break;\n<216> \n<217> case '/':\n<218> \n<219> {\n<220> \n<221> int count, format, size;\n<222> \n<223> \n<224> \n<225> while (qemu_isspace(*p))\n<226> \n<227> p++;\n<228> \n<229> if (*p == '/') {\n<230> \n<231> /* format found */\n<232> \n<233> p++;\n<234> \n<235> count = 1;\n<236> \n<237> if (qemu_isdigit(*p)) {\n<238> \n<239> count = 0;\n<240> \n<241> while (qemu_isdigit(*p)) {\n<242> \n<243> count = count * 10 + (*p - '0');\n<244> \n<245> p++;\n<246> \n<247> }\n<248> \n<249> }\n<250> \n<251> size = -1;\n<252> \n<253> format = -1;\n<254> \n<255> for(;;) {\n<256> \n<257> switch(*p) {\n<258> \n<259> case 'o':\n<260> \n<261> case 'd':\n<262> \n<263> case 'u':\n<264> \n<265> case 'x':\n<266> \n<267> case 'i':\n<268> \n<269> case 'c':\n<270> \n<271> format = *p++;\n<272> \n<273> break;\n<274> \n<275> case 'b':\n<276> \n<277> size = 1;\n<278> \n<279> p++;\n<280> \n<281> break;\n<282> \n<283> case 'h':\n<284> \n<285> size = 2;\n<286> \n<287> p++;\n<288> \n<289> break;\n<290> \n<291> case 'w':\n<292> \n<293> size = 4;\n<294> \n<295> p++;\n<296> \n<297> break;\n<298> \n<299> case 'g':\n<300> \n<301> case 'L':\n<302> \n<303> size = 8;\n<304> \n<305> p++;\n<306> \n<307> break;\n<308> \n<309> default:\n<310> \n<311> goto next;\n<312> \n<313> }\n<314> \n<315> }\n<316> \n<317> next:\n<318> \n<319> if (*p != '\0' && !qemu_isspace(*p)) {\n<320> \n<321> monitor_printf(mon, "invalid char in format: '%c'\n",\n<322> \n<323> *p);\n<324> \n<325> goto fail;\n<326> \n<327> }\n<328> \n<329> if (format < 0)\n<330> \n<331> format = default_fmt_format;\n<332> \n<333> if (format != 'i') {\n<334> \n<335> /* for 'i', not specifying a size gives -1 as size */\n<336> \n<337> if (size < 0)\n<338> \n<339> size = default_fmt_size;\n<340> \n<341> default_fmt_size = size;\n<342> \n<343> }\n<344> \n<345> default_fmt_format = format;\n<346> \n<347> } else {\n<348> \n<349> count = 1;\n<350> \n<351> format = default_fmt_format;\n<352> \n<353> if (format != 'i') {\n<354> \n<355> size = default_fmt_size;\n<356> \n<357> } else {\n<358> \n<359> size = -1;\n<360> \n<361> }\n<362> \n<363> }\n<364> \n<365> qdict_put(qdict, "count", qint_from_int(count));\n<366> \n<367> qdict_put(qdict, "format", qint_from_int(format));\n<368> \n<369> qdict_put(qdict, "size", qint_from_int(size));\n<370> \n<371> }\n<372> \n<373> break;\n<374> \n<375> case 'i':\n<376> \n<377> case 'l':\n<378> \n<379> case 'M':\n<380> \n<381> {\n<382> \n<383> int64_t val;\n<384> \n<385> \n<386> \n<387> while (qemu_isspace(*p))\n<388> \n<389> p++;\n<390> \n<391> if (*typestr == '?' || *typestr == '.') {\n<392> \n<393> if (*typestr == '?') {\n<394> \n<395> if (*p == '\0') {\n<396> \n<397> typestr++;\n<398> \n<399> break;\n<400> \n<401> }\n<402> \n<403> } else {\n<404> \n<405> if (*p == '.') {\n<406> \n<407> p++;\n<408> \n<409> while (qemu_isspace(*p))\n<410> \n<411> p++;\n<412> \n<413> } else {\n<414> \n<415> typestr++;\n<416> \n<417> break;\n<418> \n<419> }\n<420> \n<421> }\n<422> \n<423> typestr++;\n<424> \n<425> }\n<426> \n<427> if (get_expr(mon, &val, &p))\n<428> \n<429> goto fail;\n<430> \n<431> /* Check if 'i' is greater than 32-bit */\n<432> \n<433> if ((c == 'i') && ((val >> 32) & 0xffffffff)) {\n<434> \n<435> monitor_printf(mon, "\'%s\' has failed: ", cmdname);\n<436> \n<437> monitor_printf(mon, "integer is for 32-bit values\n");\n<438> \n<439> goto fail;\n<440> \n<441> } else if (c == 'M') {\n<442> \n<443> if (val < 0) {\n<444> \n<445> monitor_printf(mon, "enter a positive value\n");\n<446> \n<447> goto fail;\n<448> \n<449> }\n<450> \n<451> val <<= 20;\n<452> \n<453> }\n<454> \n<455> qdict_put(qdict, key, qint_from_int(val));\n<456> \n<457> }\n<458> \n<459> break;\n<460> \n<461> case 'o':\n<462> \n<463> {\n<464> \n<465> int64_t val;\n<466> \n<467> char *end;\n<468> \n<469> \n<470> \n<471> while (qemu_isspace(*p)) {\n<472> \n<473> p++;\n<474> \n<475> }\n<476> \n<477> if (*typestr == '?') {\n<478> \n<479> typestr++;\n<480> \n<481> if (*p == '\0') {\n<482> \n<483> break;\n<484> \n<485> }\n<486> \n<487> }\n<488> \n<489> val = strtosz(p, &end);\n<490> \n<491> if (val < 0) {\n<492> \n<493> monitor_printf(mon, "invalid size\n");\n<494> \n<495> goto fail;\n<496> \n<497> }\n<498> \n<499> qdict_put(qdict, key, qint_from_int(val));\n<500> \n<501> p = end;\n<502> \n<503> }\n<504> \n<505> break;\n<506> \n<507> case 'T':\n<508> \n<509> {\n<510> \n<511> double val;\n<512> \n<513> \n<514> \n<515> while (qemu_isspace(*p))\n<516> \n<517> p++;\n<518> \n<519> if (*typestr == '?') {\n<520> \n<521> typestr++;\n<522> \n<523> if (*p == '\0') {\n<524> \n<525> break;\n<526> \n<527> }\n<528> \n<529> }\n<530> \n<531> if (get_double(mon, &val, &p) < 0) {\n<532> \n<533> goto fail;\n<534> \n<535> }\n<536> \n<537> if (p[0] && p[1] == 's') {\n<538> \n<539> switch (*p) {\n<540> \n<541> case 'm':\n<542> \n<543> val /= 1e3; p += 2; break;\n<544> \n<545> case 'u':\n<546> \n<547> val /= 1e6; p += 2; break;\n<548> \n<549> case 'n':\n<550> \n<551> val /= 1e9; p += 2; break;\n<552> \n<553> }\n<554> \n<555> }\n<556> \n<557> if (*p && !qemu_isspace(*p)) {\n<558> \n<559> monitor_printf(mon, "Unknown unit suffix\n");\n<560> \n<561> goto fail;\n<562> \n<563> }\n<564> \n<565> qdict_put(qdict, key, qfloat_from_double(val));\n<566> \n<567> }\n<568> \n<569> break;\n<570> \n<571> case 'b':\n<572> \n<573> {\n<574> \n<575> const char *beg;\n<576> \n<577> bool val;\n<578> \n<579> \n<580> \n<581> while (qemu_isspace(*p)) {\n<582> \n<583> p++;\n<584> \n<585> }\n<586> \n<587> beg = p;\n<588> \n<589> while (qemu_isgraph(*p)) {\n<590> \n<591> p++;\n<592> \n<593> }\n<594> \n<595> if (p - beg == 2 && !memcmp(beg, "on", p - beg)) {\n<596> \n<597> val = true;\n<598> \n<599> } else if (p - beg == 3 && !memcmp(beg, "off", p - beg)) {\n<600> \n<601> val = false;\n<602> \n<603> } else {\n<604> \n<605> monitor_printf(mon, "Expected 'on' or 'off'\n");\n<606> \n<607> goto fail;\n<608> \n<609> }\n<610> \n<611> qdict_put(qdict, key, qbool_from_bool(val));\n<612> \n<613> }\n<614> \n<615> break;\n<616> \n<617> case '-':\n<618> \n<619> {\n<620> \n<621> const char *tmp = p;\n<622> \n<623> int skip_key = 0;\n<624> \n<625> /* option */\n<626> \n<627> \n<628> \n<629> c = *typestr++;\n<630> \n<631> if (c == '\0')\n<632> \n<633> goto bad_type;\n<634> \n<635> while (qemu_isspace(*p))\n<636> \n<637> p++;\n<638> \n<639> if (*p == '-') {\n<640> \n<641> p++;\n<642> \n<643> if(c != *p) {\n<644> \n<645> if(!is_valid_option(p, typestr)) {\n<646> \n<647> \n<648> \n<649> monitor_printf(mon, "%s: unsupported option -%c\n",\n<650> \n<651> cmdname, *p);\n<652> \n<653> goto fail;\n<654> \n<655> } else {\n<656> \n<657> skip_key = 1;\n<658> \n<659> }\n<660> \n<661> }\n<662> \n<663> if(skip_key) {\n<664> \n<665> p = tmp;\n<666> \n<667> } else {\n<668> \n<669> /* has option */\n<670> \n<671> p++;\n<672> \n<673> qdict_put(qdict, key, qbool_from_bool(true));\n<674> \n<675> }\n<676> \n<677> }\n<678> \n<679> }\n<680> \n<681> break;\n<682> \n<683> case 'S':\n<684> \n<685> {\n<686> \n<687> /* package all remaining string */\n<688> \n<689> int len;\n<690> \n<691> \n<692> \n<693> while (qemu_isspace(*p)) {\n<694> \n<695> p++;\n<696> \n<697> }\n<698> \n<699> if (*typestr == '?') {\n<700> \n<701> typestr++;\n<702> \n<703> if (*p == '\0') {\n<704> \n<705> /* no remaining string: NULL argument */\n<706> \n<707> break;\n<708> \n<709> }\n<710> \n<711> }\n<712> \n<713> len = strlen(p);\n<714> \n<715> if (len <= 0) {\n<716> \n<717> monitor_printf(mon, "%s: string expected\n",\n<718> \n<719> cmdname);\n<720> \n<721> break;\n<722> \n<723> }\n<724> \n<725> qdict_put(qdict, key, qstring_from_str(p));\n<726> \n<727> p += len;\n<728> \n<729> }\n<730> \n<731> break;\n<732> \n<733> default:\n<734> \n<735> bad_type:\n<736> \n<737> monitor_printf(mon, "%s: unknown type '%c'\n", cmdname, c);\n<738> \n<739> goto fail;\n<740> \n<741> }\n<742> \n<743> g_free(key);\n<744> \n<745> key = NULL;\n<746> \n<747> }\n<748> \n<749> /* check that all arguments were parsed */\n<750> \n<751> while (qemu_isspace(*p))\n<752> \n<753> p++;\n<754> \n<755> if (*p != '\0') {\n<756> \n<757> monitor_printf(mon, "%s: extraneous characters at the end of line\n",\n<758> \n<759> cmdname);\n<760> \n<761> goto fail;\n<762> \n<763> }\n<764> \n<765> \n<766> \n<767> return cmd;\n<768> \n<769> \n<770> \n<771> fail:\n<772> \n<773> g_free(key);\n<774> \n<775> return NULL;\n<776> \n<777> }\n<778> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void ehci_advance_periodic_state(EHCIState *ehci)\n<2> \n<3> {\n<4> \n<5> uint32_t entry;\n<6> \n<7> uint32_t list;\n<8> \n<9> const int async = 0;\n<10> \n<11> \n<12> \n<13> // 4.6\n<14> \n<15> \n<16> \n<17> switch(ehci_get_state(ehci, async)) {\n<18> \n<19> case EST_INACTIVE:\n<20> \n<21> if (!(ehci->frindex & 7) && ehci_periodic_enabled(ehci)) {\n<22> \n<23> ehci_set_state(ehci, async, EST_ACTIVE);\n<24> \n<25> // No break, fall through to ACTIVE\n<26> \n<27> } else\n<28> \n<29> break;\n<30> \n<31> \n<32> \n<33> case EST_ACTIVE:\n<34> \n<35> if (!(ehci->frindex & 7) && !ehci_periodic_enabled(ehci)) {\n<36> \n<37> ehci_queues_rip_all(ehci, async);\n<38> \n<39> ehci_set_state(ehci, async, EST_INACTIVE);\n<40> \n<41> break;\n<42> \n<43> }\n<44> \n<45> \n<46> \n<47> list = ehci->periodiclistbase & 0xfffff000;\n<48> \n<49> /* check that register has been set */\n<50> \n<51> if (list == 0) {\n<52> \n<53> break;\n<54> \n<55> }\n<56> \n<57> list |= ((ehci->frindex & 0x1ff8) >> 1);\n<58> \n<59> \n<60> \n<61> pci_dma_read(&ehci->dev, list, &entry, sizeof entry);\n<62> \n<63> entry = le32_to_cpu(entry);\n<64> \n<65> \n<66> \n<67> DPRINTF("PERIODIC state adv fr=%d.  [%08X] -> %08X\n",\n<68> \n<69> ehci->frindex / 8, list, entry);\n<70> \n<71> ehci_set_fetch_addr(ehci, async,entry);\n<72> \n<73> ehci_set_state(ehci, async, EST_FETCHENTRY);\n<74> \n<75> ehci_advance_state(ehci, async);\n<76> \n<77> ehci_queues_rip_unused(ehci, async, 0);\n<78> \n<79> break;\n<80> \n<81> \n<82> \n<83> default:\n<84> \n<85> /* this should only be due to a developer mistake */\n<86> \n<87> fprintf(stderr, "ehci: Bad periodic state %d. "\n<88> \n<89> "Resetting to active\n", ehci->pstate);\n<90> \n<91> assert(0);\n<92> \n<93> }\n<94> \n<95> }\n<96> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void kvmclock_vm_state_change(void *opaque, int running,\n<2> \n<3> RunState state)\n<4> \n<5> {\n<6> \n<7> KVMClockState *s = opaque;\n<8> \n<9> CPUState *cpu;\n<10> \n<11> int cap_clock_ctrl = kvm_check_extension(kvm_state, KVM_CAP_KVMCLOCK_CTRL);\n<12> \n<13> int ret;\n<14> \n<15> \n<16> \n<17> if (running) {\n<18> \n<19> struct kvm_clock_data data = {};\n<20> \n<21> uint64_t time_at_migration = kvmclock_current_nsec(s);\n<22> \n<23> \n<24> \n<25> s->clock_valid = false;\n<26> \n<27> \n<28> \n<29> /* We can't rely on the migrated clock value, just discard it */\n<30> \n<31> if (time_at_migration) {\n<32> \n<33> s->clock = time_at_migration;\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> data.clock = s->clock;\n<40> \n<41> ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &data);\n<42> \n<43> if (ret < 0) {\n<44> \n<45> fprintf(stderr, "KVM_SET_CLOCK failed: %s\n", strerror(ret));\n<46> \n<47> abort();\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> if (!cap_clock_ctrl) {\n<54> \n<55> return;\n<56> \n<57> }\n<58> \n<59> CPU_FOREACH(cpu) {\n<60> \n<61> ret = kvm_vcpu_ioctl(cpu, KVM_KVMCLOCK_CTRL, 0);\n<62> \n<63> if (ret) {\n<64> \n<65> if (ret != -EINVAL) {\n<66> \n<67> fprintf(stderr, "%s: %s\n", __func__, strerror(-ret));\n<68> \n<69> }\n<70> \n<71> return;\n<72> \n<73> }\n<74> \n<75> }\n<76> \n<77> } else {\n<78> \n<79> struct kvm_clock_data data;\n<80> \n<81> int ret;\n<82> \n<83> \n<84> \n<85> if (s->clock_valid) {\n<86> \n<87> return;\n<88> \n<89> }\n<90> \n<91> \n<92> \n<93> kvm_synchronize_all_tsc();\n<94> \n<95> \n<96> \n<97> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n<98> \n<99> if (ret < 0) {\n<100> \n<101> fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret));\n<102> \n<103> abort();\n<104> \n<105> }\n<106> \n<107> s->clock = data.clock;\n<108> \n<109> \n<110> \n<111> /*\n<112> \n<113> * If the VM is stopped, declare the clock state valid to\n<114> \n<115> * avoid re-reading it on next vmsave (which would return\n<116> \n<117> * a different value). Will be reset when the VM is continued.\n<118> \n<119> */\n<120> \n<121> s->clock_valid = true;\n<122> \n<123> }\n<124> \n<125> }\n<126> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int xen_host_pci_get_value(XenHostPCIDevice *d, const char *name,\n<2> \n<3> unsigned int *pvalue, int base)\n<4> \n<5> {\n<6> \n<7> char path[PATH_MAX];\n<8> \n<9> char buf[XEN_HOST_PCI_GET_VALUE_BUFFER_SIZE];\n<10> \n<11> int fd, rc;\n<12> \n<13> unsigned long value;\n<14> \n<15> char *endptr;\n<16> \n<17> \n<18> \n<19> xen_host_pci_sysfs_path(d, name, path, sizeof(path));\n<20> \n<21> \n<22> \n<23> fd = open(path, O_RDONLY);\n<24> \n<25> if (fd == -1) {\n<26> \n<27> XEN_HOST_PCI_LOG("Error: Can't open %s: %s\n", path, strerror(errno));\n<28> \n<29> return -errno;\n<30> \n<31> }\n<32> \n<33> do {\n<34> \n<35> rc = read(fd, &buf, sizeof (buf) - 1);\n<36> \n<37> if (rc < 0 && errno != EINTR) {\n<38> \n<39> rc = -errno;\n<40> \n<41> goto out;\n<42> \n<43> }\n<44> \n<45> } while (rc < 0);\n<46> \n<47> buf[rc] = 0;\n<48> \n<49> value = strtol(buf, &endptr, base);\n<50> \n<51> if (endptr == buf || *endptr != '\n') {\n<52> \n<53> rc = -1;\n<54> \n<55> } else if ((value == LONG_MIN || value == LONG_MAX) && errno == ERANGE) {\n<56> \n<57> rc = -errno;\n<58> \n<59> } else {\n<60> \n<61> rc = 0;\n<62> \n<63> *pvalue = value;\n<64> \n<65> }\n<66> \n<67> out:\n<68> \n<69> close(fd);\n<70> \n<71> return rc;\n<72> \n<73> }\n<74> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int send_response(GAState *s, QObject *payload)\n<2> \n<3> {\n<4> \n<5> const char *buf;\n<6> \n<7> QString *payload_qstr;\n<8> \n<9> GIOStatus status;\n<10> \n<11> \n<12> \n<13> g_assert(payload && s->channel);\n<14> \n<15> \n<16> \n<17> payload_qstr = qobject_to_json(payload);\n<18> \n<19> if (!payload_qstr) {\n<20> \n<21> return -EINVAL;\n<22> \n<23> }\n<24> \n<25> \n<26> \n<27> qstring_append_chr(payload_qstr, '\n');\n<28> \n<29> buf = qstring_get_str(payload_qstr);\n<30> \n<31> status = ga_channel_write_all(s->channel, buf, strlen(buf));\n<32> \n<33> QDECREF(payload_qstr);\n<34> \n<35> if (status != G_IO_STATUS_NORMAL) {\n<36> \n<37> return -EIO;\n<38> \n<39> }\n<40> \n<41> \n<42> \n<43> return 0;\n<44> \n<45> }\n<46> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void test_rfc822_parse_quoted_string ( void ) {\n<2> const struct {\n<3> const char * input , * output ;\n<4> int ret ;\n<5> }\n<6> tests [ ] = {\n<7> {\n<8> "\"" , "" , - 1 }\n<9> , {\n<10> "\"\"" , "" , 0 }\n<11> , {\n<12> "\"foo\"" , "foo" , 0 }\n<13> , {\n<14> "\"\"foo" , "" , 1 }\n<15> , {\n<16> "\"\"\"" , "" , 1 }\n<17> , {\n<18> "\"\\\"\"" , "\"" , 0 }\n<19> , {\n<20> "\"\\\\\"" , "\\" , 0 }\n<21> , {\n<22> "\"\\\\foo\\\\foo\\\\\"" , "\\foo\\foo\\" , 0 }\n<23> }\n<24> ;\n<25> struct rfc822_parser_context parser ;\n<26> string_t * str = t_str_new ( 64 ) ;\n<27> unsigned int i = 0 ;\n<28> test_begin ( "rfc822 parse quoted string" ) ;\n<29> for ( i = 0 ;\n<30> i < N_ELEMENTS ( tests ) ;\n<31> i ++ ) {\n<32> rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;\n<33> test_assert_idx ( rfc822_parse_quoted_string ( & parser , str ) == tests [ i ] . ret , i ) ;\n<34> test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;\n<35> str_truncate ( str , 0 ) ;\n<36> }\n<37> test_end ( ) ;\n<38> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void do_log(int argc, const char **argv)\n<2> \n<3> {\n<4> \n<5> int mask;\n<6> \n<7> \n<8> \n<9> if (argc != 2)\n<10> \n<11> goto help;\n<12> \n<13> if (!strcmp(argv[1], "none")) {\n<14> \n<15> mask = 0;\n<16> \n<17> } else {\n<18> \n<19> mask = cpu_str_to_log_mask(argv[1]);\n<20> \n<21> if (!mask) {\n<22> \n<23> help:\n<24> \n<25> help_cmd(argv[0]);\n<26> \n<27> return;\n<28> \n<29> }\n<30> \n<31> }\n<32> \n<33> cpu_set_log(mask);\n<34> \n<35> }\n<36> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void parse_numa_node(NumaNodeOptions *node, QemuOpts *opts, Error **errp)\n<2> \n<3> {\n<4> \n<5> uint16_t nodenr;\n<6> \n<7> uint16List *cpus = NULL;\n<8> \n<9> \n<10> \n<11> if (node->has_nodeid) {\n<12> \n<13> nodenr = node->nodeid;\n<14> \n<15> } else {\n<16> \n<17> nodenr = nb_numa_nodes;\n<18> \n<19> }\n<20> \n<21> \n<22> \n<23> if (nodenr >= MAX_NODES) {\n<24> \n<25> error_setg(errp, "Max number of NUMA nodes reached: %"\n<26> \n<27> PRIu16 "", nodenr);\n<28> \n<29> return;\n<30> \n<31> }\n<32> \n<33> \n<34> \n<35> if (numa_info[nodenr].present) {\n<36> \n<37> error_setg(errp, "Duplicate NUMA nodeid: %" PRIu16, nodenr);\n<38> \n<39> return;\n<40> \n<41> }\n<42> \n<43> \n<44> \n<45> for (cpus = node->cpus; cpus; cpus = cpus->next) {\n<46> \n<47> if (cpus->value >= max_cpus) {\n<48> \n<49> error_setg(errp,\n<50> \n<51> "CPU index (%" PRIu16 ")"\n<52> \n<53> " should be smaller than maxcpus (%d)",\n<54> \n<55> cpus->value, max_cpus);\n<56> \n<57> return;\n<58> \n<59> }\n<60> \n<61> bitmap_set(numa_info[nodenr].node_cpu, cpus->value, 1);\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> if (node->has_mem && node->has_memdev) {\n<68> \n<69> error_setg(errp, "qemu: cannot specify both mem= and memdev=");\n<70> \n<71> return;\n<72> \n<73> }\n<74> \n<75> \n<76> \n<77> if (have_memdevs == -1) {\n<78> \n<79> have_memdevs = node->has_memdev;\n<80> \n<81> }\n<82> \n<83> if (node->has_memdev != have_memdevs) {\n<84> \n<85> error_setg(errp, "qemu: memdev option must be specified for either "\n<86> \n<87> "all or no nodes");\n<88> \n<89> return;\n<90> \n<91> }\n<92> \n<93> \n<94> \n<95> if (node->has_mem) {\n<96> \n<97> uint64_t mem_size = node->mem;\n<98> \n<99> const char *mem_str = qemu_opt_get(opts, "mem");\n<100> \n<101> /* Fix up legacy suffix-less format */\n<102> \n<103> if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n<104> \n<105> mem_size <<= 20;\n<106> \n<107> }\n<108> \n<109> numa_info[nodenr].node_mem = mem_size;\n<110> \n<111> }\n<112> \n<113> if (node->has_memdev) {\n<114> \n<115> Object *o;\n<116> \n<117> o = object_resolve_path_type(node->memdev, TYPE_MEMORY_BACKEND, NULL);\n<118> \n<119> if (!o) {\n<120> \n<121> error_setg(errp, "memdev=%s is ambiguous", node->memdev);\n<122> \n<123> return;\n<124> \n<125> }\n<126> \n<127> \n<128> \n<129> object_ref(o);\n<130> \n<131> numa_info[nodenr].node_mem = object_property_get_int(o, "size", NULL);\n<132> \n<133> numa_info[nodenr].node_memdev = MEMORY_BACKEND(o);\n<134> \n<135> }\n<136> \n<137> numa_info[nodenr].present = true;\n<138> \n<139> max_numa_nodeid = MAX(max_numa_nodeid, nodenr + 1);\n<140> \n<141> }\n<142> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 0

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int check_host_key_knownhosts(BDRVSSHState *s,\n<2> \n<3> const char *host, int port)\n<4> \n<5> {\n<6> \n<7> const char *home;\n<8> \n<9> char *knh_file = NULL;\n<10> \n<11> LIBSSH2_KNOWNHOSTS *knh = NULL;\n<12> \n<13> struct libssh2_knownhost *found;\n<14> \n<15> int ret, r;\n<16> \n<17> const char *hostkey;\n<18> \n<19> size_t len;\n<20> \n<21> int type;\n<22> \n<23> \n<24> \n<25> hostkey = libssh2_session_hostkey(s->session, &len, &type);\n<26> \n<27> if (!hostkey) {\n<28> \n<29> ret = -EINVAL;\n<30> \n<31> session_error_report(s, "failed to read remote host key");\n<32> \n<33> goto out;\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> knh = libssh2_knownhost_init(s->session);\n<40> \n<41> if (!knh) {\n<42> \n<43> ret = -EINVAL;\n<44> \n<45> session_error_report(s, "failed to initialize known hosts support");\n<46> \n<47> goto out;\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> home = getenv("HOME");\n<54> \n<55> if (home) {\n<56> \n<57> knh_file = g_strdup_printf("%s/.ssh/known_hosts", home);\n<58> \n<59> } else {\n<60> \n<61> knh_file = g_strdup_printf("/root/.ssh/known_hosts");\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> /* Read all known hosts from OpenSSH-style known_hosts file. */\n<68> \n<69> libssh2_knownhost_readfile(knh, knh_file, LIBSSH2_KNOWNHOST_FILE_OPENSSH);\n<70> \n<71> \n<72> \n<73> r = libssh2_knownhost_checkp(knh, host, port, hostkey, len,\n<74> \n<75> LIBSSH2_KNOWNHOST_TYPE_PLAIN|\n<76> \n<77> LIBSSH2_KNOWNHOST_KEYENC_RAW,\n<78> \n<79> &found);\n<80> \n<81> switch (r) {\n<82> \n<83> case LIBSSH2_KNOWNHOST_CHECK_MATCH:\n<84> \n<85> /* OK */\n<86> \n<87> DPRINTF("host key OK: %s", found->key);\n<88> \n<89> break;\n<90> \n<91> case LIBSSH2_KNOWNHOST_CHECK_MISMATCH:\n<92> \n<93> ret = -EINVAL;\n<94> \n<95> session_error_report(s, "host key does not match the one in known_hosts (found key %s)",\n<96> \n<97> found->key);\n<98> \n<99> goto out;\n<100> \n<101> case LIBSSH2_KNOWNHOST_CHECK_NOTFOUND:\n<102> \n<103> ret = -EINVAL;\n<104> \n<105> session_error_report(s, "no host key was found in known_hosts");\n<106> \n<107> goto out;\n<108> \n<109> case LIBSSH2_KNOWNHOST_CHECK_FAILURE:\n<110> \n<111> ret = -EINVAL;\n<112> \n<113> session_error_report(s, "failure matching the host key with known_hosts");\n<114> \n<115> goto out;\n<116> \n<117> default:\n<118> \n<119> ret = -EINVAL;\n<120> \n<121> session_error_report(s, "unknown error matching the host key with known_hosts (%d)",\n<122> \n<123> r);\n<124> \n<125> goto out;\n<126> \n<127> }\n<128> \n<129> \n<130> \n<131> /* known_hosts checking successful. */\n<132> \n<133> ret = 0;\n<134> \n<135> \n<136> \n<137> out:\n<138> \n<139> if (knh != NULL) {\n<140> \n<141> libssh2_knownhost_free(knh);\n<142> \n<143> }\n<144> \n<145> g_free(knh_file);\n<146> \n<147> return ret;\n<148> \n<149> }\n<150> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void xps_parse_path ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n<2> fz_xml * node ;\n<3> char * fill_uri ;\n<4> char * stroke_uri ;\n<5> char * opacity_mask_uri ;\n<6> char * transform_att ;\n<7> char * clip_att ;\n<8> char * data_att ;\n<9> char * fill_att ;\n<10> char * stroke_att ;\n<11> char * opacity_att ;\n<12> char * opacity_mask_att ;\n<13> fz_xml * transform_tag = NULL ;\n<14> fz_xml * clip_tag = NULL ;\n<15> fz_xml * data_tag = NULL ;\n<16> fz_xml * fill_tag = NULL ;\n<17> fz_xml * stroke_tag = NULL ;\n<18> fz_xml * opacity_mask_tag = NULL ;\n<19> char * fill_opacity_att = NULL ;\n<20> char * stroke_opacity_att = NULL ;\n<21> char * stroke_dash_array_att ;\n<22> char * stroke_dash_cap_att ;\n<23> char * stroke_dash_offset_att ;\n<24> char * stroke_end_line_cap_att ;\n<25> char * stroke_start_line_cap_att ;\n<26> char * stroke_line_join_att ;\n<27> char * stroke_miter_limit_att ;\n<28> char * stroke_thickness_att ;\n<29> char * navigate_uri_att ;\n<30> fz_stroke_state * stroke = NULL ;\n<31> fz_matrix transform ;\n<32> float samples [ 32 ] ;\n<33> fz_colorspace * colorspace ;\n<34> fz_path * path = NULL ;\n<35> fz_path * stroke_path = NULL ;\n<36> fz_rect area ;\n<37> int fill_rule ;\n<38> int dash_len = 0 ;\n<39> fz_matrix local_ctm ;\n<40> transform_att = fz_xml_att ( root , "RenderTransform" ) ;\n<41> clip_att = fz_xml_att ( root , "Clip" ) ;\n<42> data_att = fz_xml_att ( root , "Data" ) ;\n<43> fill_att = fz_xml_att ( root , "Fill" ) ;\n<44> stroke_att = fz_xml_att ( root , "Stroke" ) ;\n<45> opacity_att = fz_xml_att ( root , "Opacity" ) ;\n<46> opacity_mask_att = fz_xml_att ( root , "OpacityMask" ) ;\n<47> stroke_dash_array_att = fz_xml_att ( root , "StrokeDashArray" ) ;\n<48> stroke_dash_cap_att = fz_xml_att ( root , "StrokeDashCap" ) ;\n<49> stroke_dash_offset_att = fz_xml_att ( root , "StrokeDashOffset" ) ;\n<50> stroke_end_line_cap_att = fz_xml_att ( root , "StrokeEndLineCap" ) ;\n<51> stroke_start_line_cap_att = fz_xml_att ( root , "StrokeStartLineCap" ) ;\n<52> stroke_line_join_att = fz_xml_att ( root , "StrokeLineJoin" ) ;\n<53> stroke_miter_limit_att = fz_xml_att ( root , "StrokeMiterLimit" ) ;\n<54> stroke_thickness_att = fz_xml_att ( root , "StrokeThickness" ) ;\n<55> navigate_uri_att = fz_xml_att ( root , "FixedPage.NavigateUri" ) ;\n<56> for ( node = fz_xml_down ( root ) ;\n<57> node ;\n<58> node = fz_xml_next ( node ) ) {\n<59> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.RenderTransform" ) ) transform_tag = fz_xml_down ( node ) ;\n<60> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.OpacityMask" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n<61> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Clip" ) ) clip_tag = fz_xml_down ( node ) ;\n<62> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Fill" ) ) fill_tag = fz_xml_down ( node ) ;\n<63> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Stroke" ) ) stroke_tag = fz_xml_down ( node ) ;\n<64> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Data" ) ) data_tag = fz_xml_down ( node ) ;\n<65> }\n<66> fill_uri = base_uri ;\n<67> stroke_uri = base_uri ;\n<68> opacity_mask_uri = base_uri ;\n<69> xps_resolve_resource_reference ( doc , dict , & data_att , & data_tag , NULL ) ;\n<70> xps_resolve_resource_reference ( doc , dict , & clip_att , & clip_tag , NULL ) ;\n<71> xps_resolve_resource_reference ( doc , dict , & transform_att , & transform_tag , NULL ) ;\n<72> xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n<73> xps_resolve_resource_reference ( doc , dict , & stroke_att , & stroke_tag , & stroke_uri ) ;\n<74> xps_resolve_resource_reference ( doc , dict , & opacity_mask_att , & opacity_mask_tag , & opacity_mask_uri ) ;\n<75> if ( ! data_att && ! data_tag ) return ;\n<76> if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , "SolidColorBrush" ) ) {\n<77> fill_opacity_att = fz_xml_att ( fill_tag , "Opacity" ) ;\n<78> fill_att = fz_xml_att ( fill_tag , "Color" ) ;\n<79> fill_tag = NULL ;\n<80> }\n<81> if ( stroke_tag && ! strcmp ( fz_xml_tag ( stroke_tag ) , "SolidColorBrush" ) ) {\n<82> stroke_opacity_att = fz_xml_att ( stroke_tag , "Opacity" ) ;\n<83> stroke_att = fz_xml_att ( stroke_tag , "Color" ) ;\n<84> stroke_tag = NULL ;\n<85> }\n<86> if ( stroke_att || stroke_tag ) {\n<87> if ( stroke_dash_array_att ) {\n<88> char * s = stroke_dash_array_att ;\n<89> while ( * s ) {\n<90> while ( * s == ' ' ) s ++ ;\n<91> if ( * s ) dash_len ++ ;\n<92> while ( * s && * s != ' ' ) s ++ ;\n<93> }\n<94> }\n<95> stroke = fz_new_stroke_state_with_dash_len ( doc -> ctx , dash_len ) ;\n<96> stroke -> start_cap = xps_parse_line_cap ( stroke_start_line_cap_att ) ;\n<97> stroke -> dash_cap = xps_parse_line_cap ( stroke_dash_cap_att ) ;\n<98> stroke -> end_cap = xps_parse_line_cap ( stroke_end_line_cap_att ) ;\n<99> stroke -> linejoin = FZ_LINEJOIN_MITER_XPS ;\n<100> if ( stroke_line_join_att ) {\n<101> if ( ! strcmp ( stroke_line_join_att , "Miter" ) ) stroke -> linejoin = FZ_LINEJOIN_MITER_XPS ;\n<102> if ( ! strcmp ( stroke_line_join_att , "Round" ) ) stroke -> linejoin = FZ_LINEJOIN_ROUND ;\n<103> if ( ! strcmp ( stroke_line_join_att , "Bevel" ) ) stroke -> linejoin = FZ_LINEJOIN_BEVEL ;\n<104> }\n<105> stroke -> miterlimit = 10 ;\n<106> if ( stroke_miter_limit_att ) stroke -> miterlimit = fz_atof ( stroke_miter_limit_att ) ;\n<107> stroke -> linewidth = 1 ;\n<108> if ( stroke_thickness_att ) stroke -> linewidth = fz_atof ( stroke_thickness_att ) ;\n<109> stroke -> dash_phase = 0 ;\n<110> stroke -> dash_len = 0 ;\n<111> if ( stroke_dash_array_att ) {\n<112> char * s = stroke_dash_array_att ;\n<113> if ( stroke_dash_offset_att ) stroke -> dash_phase = fz_atof ( stroke_dash_offset_att ) * stroke -> linewidth ;\n<114> while ( * s ) {\n<115> while ( * s == ' ' ) s ++ ;\n<116> if ( * s ) stroke -> dash_list [ stroke -> dash_len ++ ] = fz_atof ( s ) * stroke -> linewidth ;\n<117> while ( * s && * s != ' ' ) s ++ ;\n<118> }\n<119> stroke -> dash_len = dash_len ;\n<120> }\n<121> }\n<122> transform = fz_identity ;\n<123> if ( transform_att ) xps_parse_render_transform ( doc , transform_att , & transform ) ;\n<124> if ( transform_tag ) xps_parse_matrix_transform ( doc , transform_tag , & transform ) ;\n<125> fz_concat ( & local_ctm , & transform , ctm ) ;\n<126> if ( clip_att || clip_tag ) xps_clip ( doc , & local_ctm , dict , clip_att , clip_tag ) ;\n<127> fill_rule = 0 ;\n<128> if ( data_att ) path = xps_parse_abbreviated_geometry ( doc , data_att , & fill_rule ) ;\n<129> else if ( data_tag ) {\n<130> path = xps_parse_path_geometry ( doc , dict , data_tag , 0 , & fill_rule ) ;\n<131> if ( stroke_att || stroke_tag ) stroke_path = xps_parse_path_geometry ( doc , dict , data_tag , 1 , & fill_rule ) ;\n<132> }\n<133> if ( ! stroke_path ) stroke_path = path ;\n<134> if ( stroke_att || stroke_tag ) {\n<135> fz_bound_path ( doc -> ctx , stroke_path , stroke , & local_ctm , & area ) ;\n<136> if ( stroke_path != path && ( fill_att || fill_tag ) ) {\n<137> fz_rect bounds ;\n<138> fz_bound_path ( doc -> ctx , path , NULL , & local_ctm , & bounds ) ;\n<139> fz_union_rect ( & area , & bounds ) ;\n<140> }\n<141> }\n<142> else fz_bound_path ( doc -> ctx , path , NULL , & local_ctm , & area ) ;\n<143> if ( navigate_uri_att ) xps_add_link ( doc , & area , base_uri , navigate_uri_att ) ;\n<144> xps_begin_opacity ( doc , & local_ctm , & area , opacity_mask_uri , dict , opacity_att , opacity_mask_tag ) ;\n<145> if ( fill_att ) {\n<146> xps_parse_color ( doc , base_uri , fill_att , & colorspace , samples ) ;\n<147> if ( fill_opacity_att ) samples [ 0 ] *= fz_atof ( fill_opacity_att ) ;\n<148> xps_set_color ( doc , colorspace , samples ) ;\n<149> fz_fill_path ( doc -> dev , path , fill_rule == 0 , & local_ctm , doc -> colorspace , doc -> color , doc -> alpha ) ;\n<150> }\n<151> if ( fill_tag ) {\n<152> fz_clip_path ( doc -> dev , path , & area , fill_rule == 0 , & local_ctm ) ;\n<153> xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;\n<154> fz_pop_clip ( doc -> dev ) ;\n<155> }\n<156> if ( stroke_att ) {\n<157> xps_parse_color ( doc , base_uri , stroke_att , & colorspace , samples ) ;\n<158> if ( stroke_opacity_att ) samples [ 0 ] *= fz_atof ( stroke_opacity_att ) ;\n<159> xps_set_color ( doc , colorspace , samples ) ;\n<160> fz_stroke_path ( doc -> dev , stroke_path , stroke , & local_ctm , doc -> colorspace , doc -> color , doc -> alpha ) ;\n<161> }\n<162> if ( stroke_tag ) {\n<163> fz_clip_stroke_path ( doc -> dev , stroke_path , & area , stroke , & local_ctm ) ;\n<164> xps_parse_brush ( doc , & local_ctm , & area , stroke_uri , dict , stroke_tag ) ;\n<165> fz_pop_clip ( doc -> dev ) ;\n<166> }\n<167> xps_end_opacity ( doc , opacity_mask_uri , dict , opacity_att , opacity_mask_tag ) ;\n<168> if ( stroke_path != path ) fz_free_path ( doc -> ctx , stroke_path ) ;\n<169> fz_free_path ( doc -> ctx , path ) ;\n<170> path = NULL ;\n<171> fz_drop_stroke_state ( doc -> ctx , stroke ) ;\n<172> if ( clip_att || clip_tag ) fz_pop_clip ( doc -> dev ) ;\n<173> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int uuid_is_null(const uuid_t uu)\n<2> \n<3> {\n<4> \n<5> uuid_t null_uuid = { 0 };\n<6> \n<7> return memcmp(uu, null_uuid, sizeof(uuid_t)) == 0;\n<8> \n<9> }\n<10> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int load_uboot_image(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n<2> \n<3> int *is_linux, uint8_t image_type,\n<4> \n<5> uint64_t (*translate_fn)(void *, uint64_t),\n<6> \n<7> void *translate_opaque)\n<8> \n<9> {\n<10> \n<11> int fd;\n<12> \n<13> int size;\n<14> \n<15> hwaddr address;\n<16> \n<17> uboot_image_header_t h;\n<18> \n<19> uboot_image_header_t *hdr = &h;\n<20> \n<21> uint8_t *data = NULL;\n<22> \n<23> int ret = -1;\n<24> \n<25> int do_uncompress = 0;\n<26> \n<27> \n<28> \n<29> fd = open(filename, O_RDONLY | O_BINARY);\n<30> \n<31> if (fd < 0)\n<32> \n<33> return -1;\n<34> \n<35> \n<36> \n<37> size = read(fd, hdr, sizeof(uboot_image_header_t));\n<38> \n<39> if (size < 0)\n<40> \n<41> goto out;\n<42> \n<43> \n<44> \n<45> bswap_uboot_header(hdr);\n<46> \n<47> \n<48> \n<49> if (hdr->ih_magic != IH_MAGIC)\n<50> \n<51> goto out;\n<52> \n<53> \n<54> \n<55> if (hdr->ih_type != image_type) {\n<56> \n<57> fprintf(stderr, "Wrong image type %d, expected %d\n", hdr->ih_type,\n<58> \n<59> image_type);\n<60> \n<61> goto out;\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> /* TODO: Implement other image types.  */\n<68> \n<69> switch (hdr->ih_type) {\n<70> \n<71> case IH_TYPE_KERNEL:\n<72> \n<73> address = hdr->ih_load;\n<74> \n<75> if (translate_fn) {\n<76> \n<77> address = translate_fn(translate_opaque, address);\n<78> \n<79> }\n<80> \n<81> if (loadaddr) {\n<82> \n<83> *loadaddr = hdr->ih_load;\n<84> \n<85> }\n<86> \n<87> \n<88> \n<89> switch (hdr->ih_comp) {\n<90> \n<91> case IH_COMP_NONE:\n<92> \n<93> break;\n<94> \n<95> case IH_COMP_GZIP:\n<96> \n<97> do_uncompress = 1;\n<98> \n<99> break;\n<100> \n<101> default:\n<102> \n<103> fprintf(stderr,\n<104> \n<105> "Unable to load u-boot images with compression type %d\n",\n<106> \n<107> hdr->ih_comp);\n<108> \n<109> goto out;\n<110> \n<111> }\n<112> \n<113> \n<114> \n<115> if (ep) {\n<116> \n<117> *ep = hdr->ih_ep;\n<118> \n<119> }\n<120> \n<121> \n<122> \n<123> /* TODO: Check CPU type.  */\n<124> \n<125> if (is_linux) {\n<126> \n<127> if (hdr->ih_os == IH_OS_LINUX) {\n<128> \n<129> *is_linux = 1;\n<130> \n<131> } else {\n<132> \n<133> *is_linux = 0;\n<134> \n<135> }\n<136> \n<137> }\n<138> \n<139> \n<140> \n<141> break;\n<142> \n<143> case IH_TYPE_RAMDISK:\n<144> \n<145> address = *loadaddr;\n<146> \n<147> break;\n<148> \n<149> default:\n<150> \n<151> fprintf(stderr, "Unsupported u-boot image type %d\n", hdr->ih_type);\n<152> \n<153> goto out;\n<154> \n<155> }\n<156> \n<157> \n<158> \n<159> data = g_malloc(hdr->ih_size);\n<160> \n<161> \n<162> \n<163> if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n<164> \n<165> fprintf(stderr, "Error reading file\n");\n<166> \n<167> goto out;\n<168> \n<169> }\n<170> \n<171> \n<172> \n<173> if (do_uncompress) {\n<174> \n<175> uint8_t *compressed_data;\n<176> \n<177> size_t max_bytes;\n<178> \n<179> ssize_t bytes;\n<180> \n<181> \n<182> \n<183> compressed_data = data;\n<184> \n<185> max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n<186> \n<187> data = g_malloc(max_bytes);\n<188> \n<189> \n<190> \n<191> bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n<192> \n<193> g_free(compressed_data);\n<194> \n<195> if (bytes < 0) {\n<196> \n<197> fprintf(stderr, "Unable to decompress gzipped image!\n");\n<198> \n<199> goto out;\n<200> \n<201> }\n<202> \n<203> hdr->ih_size = bytes;\n<204> \n<205> }\n<206> \n<207> \n<208> \n<209> rom_add_blob_fixed(filename, data, hdr->ih_size, address);\n<210> \n<211> \n<212> \n<213> ret = hdr->ih_size;\n<214> \n<215> \n<216> \n<217> out:\n<218> \n<219> if (data)\n<220> \n<221> g_free(data);\n<222> \n<223> close(fd);\n<224> \n<225> return ret;\n<226> \n<227> }\n<228> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> build_rsdp(GArray *rsdp_table, GArray *linker, unsigned rsdt)\n<2> \n<3> {\n<4> \n<5> AcpiRsdpDescriptor *rsdp = acpi_data_push(rsdp_table, sizeof *rsdp);\n<6> \n<7> \n<8> \n<9> bios_linker_loader_alloc(linker, ACPI_BUILD_RSDP_FILE, 16,\n<10> \n<11> true /* fseg memory */);\n<12> \n<13> \n<14> \n<15> memcpy(&rsdp->signature, "RSD PTR ", sizeof(rsdp->signature));\n<16> \n<17> memcpy(rsdp->oem_id, ACPI_BUILD_APPNAME6, sizeof(rsdp->oem_id));\n<18> \n<19> rsdp->length = cpu_to_le32(sizeof(*rsdp));\n<20> \n<21> rsdp->revision = 0x02;\n<22> \n<23> \n<24> \n<25> /* Point to RSDT */\n<26> \n<27> rsdp->rsdt_physical_address = cpu_to_le32(rsdt);\n<28> \n<29> /* Address to be filled by Guest linker */\n<30> \n<31> bios_linker_loader_add_pointer(linker, ACPI_BUILD_RSDP_FILE,\n<32> \n<33> ACPI_BUILD_TABLE_FILE,\n<34> \n<35> rsdp_table, &rsdp->rsdt_physical_address,\n<36> \n<37> sizeof rsdp->rsdt_physical_address);\n<38> \n<39> rsdp->checksum = 0;\n<40> \n<41> /* Checksum to be filled by Guest linker */\n<42> \n<43> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,\n<44> \n<45> rsdp, rsdp, sizeof *rsdp, &rsdp->checksum);\n<46> \n<47> \n<48> \n<49> return rsdp_table;\n<50> \n<51> }\n<52> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> int ssl23_get_client_hello ( SSL * s ) {\n<2> char buf_space [ 11 ] ;\n<3> char * buf = & ( buf_space [ 0 ] ) ;\n<4> unsigned char * p , * d , * d_len , * dd ;\n<5> unsigned int i ;\n<6> unsigned int csl , sil , cl ;\n<7> int n = 0 , j ;\n<8> int type = 0 ;\n<9> int v [ 2 ] ;\n<10> if ( s -> state == SSL23_ST_SR_CLNT_HELLO_A ) {\n<11> v [ 0 ] = v [ 1 ] = 0 ;\n<12> if ( ! ssl3_setup_buffers ( s ) ) goto err ;\n<13> n = ssl23_read_bytes ( s , sizeof buf_space ) ;\n<14> if ( n != sizeof buf_space ) return ( n ) ;\n<15> p = s -> packet ;\n<16> memcpy ( buf , p , n ) ;\n<17> if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {\n<18> if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) ) {\n<19> v [ 0 ] = p [ 3 ] ;\n<20> v [ 1 ] = p [ 4 ] ;\n<21> if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) type = 1 ;\n<22> }\n<23> else if ( p [ 3 ] == SSL3_VERSION_MAJOR ) {\n<24> v [ 0 ] = p [ 3 ] ;\n<25> v [ 1 ] = p [ 4 ] ;\n<26> if ( p [ 4 ] >= TLS1_VERSION_MINOR ) {\n<27> if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n<28> s -> version = TLS1_2_VERSION ;\n<29> s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n<30> }\n<31> else if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n<32> s -> version = TLS1_1_VERSION ;\n<33> s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n<34> }\n<35> else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n<36> s -> version = TLS1_VERSION ;\n<37> s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n<38> }\n<39> else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n<40> s -> version = SSL3_VERSION ;\n<41> s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n<42> }\n<43> else if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) {\n<44> type = 1 ;\n<45> }\n<46> }\n<47> else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n<48> s -> version = SSL3_VERSION ;\n<49> s -> state = SSL23_ST_SR_CLNT_HELLO_B ;\n<50> }\n<51> else if ( ! ( s -> options & SSL_OP_NO_SSLv2 ) ) type = 1 ;\n<52> }\n<53> }\n<54> else if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) ) {\n<55> v [ 0 ] = p [ 1 ] ;\n<56> if ( p [ 3 ] == 0 && p [ 4 ] < 6 ) {\n<57> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_SMALL ) ;\n<58> goto err ;\n<59> }\n<60> if ( p [ 9 ] > SSL3_VERSION_MAJOR ) v [ 1 ] = 0xff ;\n<61> else v [ 1 ] = p [ 10 ] ;\n<62> if ( v [ 1 ] >= TLS1_VERSION_MINOR ) {\n<63> if ( v [ 1 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n<64> s -> version = TLS1_2_VERSION ;\n<65> type = 3 ;\n<66> }\n<67> else if ( v [ 1 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n<68> s -> version = TLS1_1_VERSION ;\n<69> type = 3 ;\n<70> }\n<71> else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n<72> s -> version = TLS1_VERSION ;\n<73> type = 3 ;\n<74> }\n<75> else if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n<76> s -> version = SSL3_VERSION ;\n<77> type = 3 ;\n<78> }\n<79> }\n<80> else {\n<81> if ( ! ( s -> options & SSL_OP_NO_SSLv3 ) ) {\n<82> s -> version = SSL3_VERSION ;\n<83> type = 3 ;\n<84> }\n<85> else if ( ! ( s -> options & SSL_OP_NO_TLSv1 ) ) {\n<86> s -> version = TLS1_VERSION ;\n<87> type = 3 ;\n<88> }\n<89> }\n<90> }\n<91> else if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) ) {\n<92> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_HTTP_REQUEST ) ;\n<93> goto err ;\n<94> }\n<95> else if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 ) {\n<96> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_HTTPS_PROXY_REQUEST ) ;\n<97> goto err ;\n<98> }\n<99> }\n<100> OPENSSL_assert ( s -> version <= TLS_MAX_VERSION ) ;\n<101> # ifdef OPENSSL_FIPS if ( FIPS_mode ( ) && ( s -> version < TLS1_VERSION ) ) {\n<102> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE ) ;\n<103> goto err ;\n<104> }\n<105> # endif if ( s -> state == SSL23_ST_SR_CLNT_HELLO_B ) {\n<106> type = 2 ;\n<107> p = s -> packet ;\n<108> v [ 0 ] = p [ 3 ] ;\n<109> v [ 1 ] = p [ 4 ] ;\n<110> n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;\n<111> if ( n > ( 1024 * 4 ) ) {\n<112> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_TOO_LARGE ) ;\n<113> goto err ;\n<114> }\n<115> if ( n < 9 ) {\n<116> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n<117> goto err ;\n<118> }\n<119> j = ssl23_read_bytes ( s , n + 2 ) ;\n<120> if ( j <= 0 ) return ( j ) ;\n<121> ssl3_finish_mac ( s , s -> packet + 2 , s -> packet_length - 2 ) ;\n<122> if ( s -> msg_callback ) s -> msg_callback ( 0 , SSL2_VERSION , 0 , s -> packet + 2 , s -> packet_length - 2 , s , s -> msg_callback_arg ) ;\n<123> p = s -> packet ;\n<124> p += 5 ;\n<125> n2s ( p , csl ) ;\n<126> n2s ( p , sil ) ;\n<127> n2s ( p , cl ) ;\n<128> d = ( unsigned char * ) s -> init_buf -> data ;\n<129> if ( ( csl + sil + cl + 11 ) != s -> packet_length ) {\n<130> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_RECORD_LENGTH_MISMATCH ) ;\n<131> goto err ;\n<132> }\n<133> * ( d ++ ) = SSL3_MT_CLIENT_HELLO ;\n<134> d_len = d ;\n<135> d += 3 ;\n<136> * ( d ++ ) = SSL3_VERSION_MAJOR ;\n<137> * ( d ++ ) = v [ 1 ] ;\n<138> i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl ;\n<139> memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n<140> memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n<141> d += SSL3_RANDOM_SIZE ;\n<142> * ( d ++ ) = 0 ;\n<143> j = 0 ;\n<144> dd = d ;\n<145> d += 2 ;\n<146> for ( i = 0 ;\n<147> i < csl ;\n<148> i += 3 ) {\n<149> if ( p [ i ] != 0 ) continue ;\n<150> * ( d ++ ) = p [ i + 1 ] ;\n<151> * ( d ++ ) = p [ i + 2 ] ;\n<152> j += 2 ;\n<153> }\n<154> s2n ( j , dd ) ;\n<155> * ( d ++ ) = 1 ;\n<156> * ( d ++ ) = 0 ;\n<157> # if 0 p = p + csl + sil + cl ;\n<158> while ( p < s -> packet + s -> packet_length ) {\n<159> * ( d ++ ) = * ( p ++ ) ;\n<160> }\n<161> # endif i = ( d - ( unsigned char * ) s -> init_buf -> data ) - 4 ;\n<162> l2n3 ( ( long ) i , d_len ) ;\n<163> s -> s3 -> tmp . reuse_message = 1 ;\n<164> s -> s3 -> tmp . message_type = SSL3_MT_CLIENT_HELLO ;\n<165> s -> s3 -> tmp . message_size = i ;\n<166> }\n<167> if ( type == 1 ) {\n<168> # ifdef OPENSSL_NO_SSL2 SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ;\n<169> goto err ;\n<170> # else if ( s -> s2 == NULL ) {\n<171> if ( ! ssl2_new ( s ) ) goto err ;\n<172> }\n<173> else ssl2_clear ( s ) ;\n<174> if ( s -> s3 != NULL ) ssl3_free ( s ) ;\n<175> if ( ! BUF_MEM_grow_clean ( s -> init_buf , SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER ) ) {\n<176> goto err ;\n<177> }\n<178> s -> state = SSL2_ST_GET_CLIENT_HELLO_A ;\n<179> if ( s -> options & SSL_OP_NO_TLSv1 && s -> options & SSL_OP_NO_SSLv3 ) s -> s2 -> ssl2_rollback = 0 ;\n<180> else s -> s2 -> ssl2_rollback = 1 ;\n<181> s -> rstate = SSL_ST_READ_HEADER ;\n<182> s -> packet_length = n ;\n<183> s -> packet = & ( s -> s2 -> rbuf [ 0 ] ) ;\n<184> memcpy ( s -> packet , buf , n ) ;\n<185> s -> s2 -> rbuf_left = n ;\n<186> s -> s2 -> rbuf_offs = 0 ;\n<187> s -> method = SSLv2_server_method ( ) ;\n<188> s -> handshake_func = s -> method -> ssl_accept ;\n<189> # endif }\n<190> if ( ( type == 2 ) || ( type == 3 ) ) {\n<191> s -> method = ssl23_get_server_method ( s -> version ) ;\n<192> if ( s -> method == NULL ) {\n<193> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNSUPPORTED_PROTOCOL ) ;\n<194> goto err ;\n<195> }\n<196> if ( ! ssl_init_wbio_buffer ( s , 1 ) ) goto err ;\n<197> s -> state = SSL3_ST_SR_CLNT_HELLO_A ;\n<198> if ( type == 3 ) {\n<199> s -> rstate = SSL_ST_READ_HEADER ;\n<200> s -> packet_length = n ;\n<201> if ( s -> s3 -> rbuf . buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) goto err ;\n<202> s -> packet = & ( s -> s3 -> rbuf . buf [ 0 ] ) ;\n<203> memcpy ( s -> packet , buf , n ) ;\n<204> s -> s3 -> rbuf . left = n ;\n<205> s -> s3 -> rbuf . offset = 0 ;\n<206> }\n<207> else {\n<208> s -> packet_length = 0 ;\n<209> s -> s3 -> rbuf . left = 0 ;\n<210> s -> s3 -> rbuf . offset = 0 ;\n<211> }\n<212> # if 0 s -> client_version = ( v [ 0 ] << 8 ) | v [ 1 ] ;\n<213> # endif s -> handshake_func = s -> method -> ssl_accept ;\n<214> }\n<215> if ( ( type < 1 ) || ( type > 3 ) ) {\n<216> SSLerr ( SSL_F_SSL23_GET_CLIENT_HELLO , SSL_R_UNKNOWN_PROTOCOL ) ;\n<217> goto err ;\n<218> }\n<219> s -> init_num = 0 ;\n<220> if ( buf != buf_space ) OPENSSL_free ( buf ) ;\n<221> return ( SSL_accept ( s ) ) ;\n<222> err : if ( buf != buf_space ) OPENSSL_free ( buf ) ;\n<223> return ( - 1 ) ;\n<224> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int usb_host_init(void)\n<2> \n<3> {\n<4> \n<5> const struct libusb_pollfd **poll;\n<6> \n<7> int i, rc;\n<8> \n<9> \n<10> \n<11> if (ctx) {\n<12> \n<13> return 0;\n<14> \n<15> }\n<16> \n<17> rc = libusb_init(&ctx);\n<18> \n<19> if (rc != 0) {\n<20> \n<21> return -1;\n<22> \n<23> }\n<24> \n<25> libusb_set_debug(ctx, loglevel);\n<26> \n<27> \n<28> \n<29> libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n<30> \n<31> usb_host_del_fd,\n<32> \n<33> ctx);\n<34> \n<35> poll = libusb_get_pollfds(ctx);\n<36> \n<37> if (poll) {\n<38> \n<39> for (i = 0; poll[i] != NULL; i++) {\n<40> \n<41> usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n<42> \n<43> }\n<44> \n<45> }\n<46> \n<47> free(poll);\n<48> \n<49> return 0;\n<50> \n<51> }\n<52> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int nbd_opt_go(QIOChannel *ioc, const char *wantname,\n<2> \n<3> NBDExportInfo *info, Error **errp)\n<4> \n<5> {\n<6> \n<7> nbd_opt_reply reply;\n<8> \n<9> uint32_t len = strlen(wantname);\n<10> \n<11> uint16_t type;\n<12> \n<13> int error;\n<14> \n<15> char *buf;\n<16> \n<17> \n<18> \n<19> /* The protocol requires that the server send NBD_INFO_EXPORT with\n<20> \n<21> * a non-zero flags (at least NBD_FLAG_HAS_FLAGS must be set); so\n<22> \n<23> * flags still 0 is a witness of a broken server. */\n<24> \n<25> info->flags = 0;\n<26> \n<27> \n<28> \n<29> trace_nbd_opt_go_start(wantname);\n<30> \n<31> buf = g_malloc(4 + len + 2 + 1);\n<32> \n<33> stl_be_p(buf, len);\n<34> \n<35> memcpy(buf + 4, wantname, len);\n<36> \n<37> /* No requests, live with whatever server sends */\n<38> \n<39> stw_be_p(buf + 4 + len, 0);\n<40> \n<41> if (nbd_send_option_request(ioc, NBD_OPT_GO, len + 6, buf, errp) < 0) {\n<42> \n<43> return -1;\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> while (1) {\n<50> \n<51> if (nbd_receive_option_reply(ioc, NBD_OPT_GO, &reply, errp) < 0) {\n<52> \n<53> return -1;\n<54> \n<55> }\n<56> \n<57> error = nbd_handle_reply_err(ioc, &reply, errp);\n<58> \n<59> if (error <= 0) {\n<60> \n<61> return error;\n<62> \n<63> }\n<64> \n<65> len = reply.length;\n<66> \n<67> \n<68> \n<69> if (reply.type == NBD_REP_ACK) {\n<70> \n<71> /* Server is done sending info and moved into transmission\n<72> \n<73> phase, but make sure it sent flags */\n<74> \n<75> if (len) {\n<76> \n<77> error_setg(errp, "server sent invalid NBD_REP_ACK");\n<78> \n<79> nbd_send_opt_abort(ioc);\n<80> \n<81> return -1;\n<82> \n<83> }\n<84> \n<85> if (!info->flags) {\n<86> \n<87> error_setg(errp, "broken server omitted NBD_INFO_EXPORT");\n<88> \n<89> nbd_send_opt_abort(ioc);\n<90> \n<91> return -1;\n<92> \n<93> }\n<94> \n<95> trace_nbd_opt_go_success();\n<96> \n<97> return 1;\n<98> \n<99> }\n<100> \n<101> if (reply.type != NBD_REP_INFO) {\n<102> \n<103> error_setg(errp, "unexpected reply type %" PRIx32 ", expected %x",\n<104> \n<105> reply.type, NBD_REP_INFO);\n<106> \n<107> nbd_send_opt_abort(ioc);\n<108> \n<109> return -1;\n<110> \n<111> }\n<112> \n<113> if (len < sizeof(type)) {\n<114> \n<115> error_setg(errp, "NBD_REP_INFO length %" PRIu32 " is too short",\n<116> \n<117> len);\n<118> \n<119> nbd_send_opt_abort(ioc);\n<120> \n<121> return -1;\n<122> \n<123> }\n<124> \n<125> if (nbd_read(ioc, &type, sizeof(type), errp) < 0) {\n<126> \n<127> error_prepend(errp, "failed to read info type");\n<128> \n<129> nbd_send_opt_abort(ioc);\n<130> \n<131> return -1;\n<132> \n<133> }\n<134> \n<135> len -= sizeof(type);\n<136> \n<137> be16_to_cpus(&type);\n<138> \n<139> switch (type) {\n<140> \n<141> case NBD_INFO_EXPORT:\n<142> \n<143> if (len != sizeof(info->size) + sizeof(info->flags)) {\n<144> \n<145> error_setg(errp, "remaining export info len %" PRIu32\n<146> \n<147> " is unexpected size", len);\n<148> \n<149> nbd_send_opt_abort(ioc);\n<150> \n<151> return -1;\n<152> \n<153> }\n<154> \n<155> if (nbd_read(ioc, &info->size, sizeof(info->size), errp) < 0) {\n<156> \n<157> error_prepend(errp, "failed to read info size");\n<158> \n<159> nbd_send_opt_abort(ioc);\n<160> \n<161> return -1;\n<162> \n<163> }\n<164> \n<165> be64_to_cpus(&info->size);\n<166> \n<167> if (nbd_read(ioc, &info->flags, sizeof(info->flags), errp) < 0) {\n<168> \n<169> error_prepend(errp, "failed to read info flags");\n<170> \n<171> nbd_send_opt_abort(ioc);\n<172> \n<173> return -1;\n<174> \n<175> }\n<176> \n<177> be16_to_cpus(&info->flags);\n<178> \n<179> trace_nbd_receive_negotiate_size_flags(info->size, info->flags);\n<180> \n<181> break;\n<182> \n<183> \n<184> \n<185> default:\n<186> \n<187> trace_nbd_opt_go_info_unknown(type, nbd_info_lookup(type));\n<188> \n<189> if (nbd_drop(ioc, len, errp) < 0) {\n<190> \n<191> error_prepend(errp, "Failed to read info payload");\n<192> \n<193> nbd_send_opt_abort(ioc);\n<194> \n<195> return -1;\n<196> \n<197> }\n<198> \n<199> break;\n<200> \n<201> }\n<202> \n<203> }\n<204> \n<205> }\n<206> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,\n<2> \n<3> enum dshowDeviceType devtype, IBaseFilter **pfilter)\n<4> \n<5> {\n<6> \n<7> struct dshow_ctx *ctx = avctx->priv_data;\n<8> \n<9> IBaseFilter *device_filter = NULL;\n<10> \n<11> IEnumMoniker *classenum = NULL;\n<12> \n<13> IMoniker *m = NULL;\n<14> \n<15> const char *device_name = ctx->device_name[devtype];\n<16> \n<17> int skip = (devtype == VideoDevice) ? ctx->video_device_number\n<18> \n<19> : ctx->audio_device_number;\n<20> \n<21> int r;\n<22> \n<23> \n<24> \n<25> const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory,\n<26> \n<27> &CLSID_AudioInputDeviceCategory };\n<28> \n<29> const char *devtypename = (devtype == VideoDevice) ? "video" : "audio";\n<30> \n<31> \n<32> \n<33> r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],\n<34> \n<35> (IEnumMoniker **) &classenum, 0);\n<36> \n<37> if (r != S_OK) {\n<38> \n<39> av_log(avctx, AV_LOG_ERROR, "Could not enumerate %s devices.\n",\n<40> \n<41> devtypename);\n<42> \n<43> return AVERROR(EIO);\n<44> \n<45> }\n<46> \n<47> \n<48> \n<49> while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) {\n<50> \n<51> IPropertyBag *bag = NULL;\n<52> \n<53> char *buf = NULL;\n<54> \n<55> VARIANT var;\n<56> \n<57> \n<58> \n<59> r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag);\n<60> \n<61> if (r != S_OK)\n<62> \n<63> goto fail1;\n<64> \n<65> \n<66> \n<67> var.vt = VT_BSTR;\n<68> \n<69> r = IPropertyBag_Read(bag, L"FriendlyName", &var, NULL);\n<70> \n<71> if (r != S_OK)\n<72> \n<73> goto fail1;\n<74> \n<75> \n<76> \n<77> buf = dup_wchar_to_utf8(var.bstrVal);\n<78> \n<79> \n<80> \n<81> if (pfilter) {\n<82> \n<83> if (strcmp(device_name, buf))\n<84> \n<85> goto fail1;\n<86> \n<87> \n<88> \n<89> if (!skip--)\n<90> \n<91> IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter);\n<92> \n<93> } else {\n<94> \n<95> av_log(avctx, AV_LOG_INFO, " \"%s\"\n", buf);\n<96> \n<97> }\n<98> \n<99> \n<100> \n<101> fail1:\n<102> \n<103> if (buf)\n<104> \n<105> av_free(buf);\n<106> \n<107> if (bag)\n<108> \n<109> IPropertyBag_Release(bag);\n<110> \n<111> IMoniker_Release(m);\n<112> \n<113> }\n<114> \n<115> \n<116> \n<117> IEnumMoniker_Release(classenum);\n<118> \n<119> \n<120> \n<121> if (pfilter) {\n<122> \n<123> if (!device_filter) {\n<124> \n<125> av_log(avctx, AV_LOG_ERROR, "Could not find %s device.\n",\n<126> \n<127> devtypename);\n<128> \n<129> return AVERROR(EIO);\n<130> \n<131> }\n<132> \n<133> *pfilter = device_filter;\n<134> \n<135> }\n<136> \n<137> \n<138> \n<139> return 0;\n<140> \n<141> }\n<142> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)\n<2> \n<3> {\n<4> \n<5> MpegEncContext *s = &ctx->m;\n<6> \n<7> char buf[256];\n<8> \n<9> int i;\n<10> \n<11> int e;\n<12> \n<13> int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n<14> \n<15> char last;\n<16> \n<17> \n<18> \n<19> for (i = 0; i < 255 && get_bits_count(gb) < gb->size_in_bits; i++) {\n<20> \n<21> if (show_bits(gb, 23) == 0)\n<22> \n<23> break;\n<24> \n<25> buf[i] = get_bits(gb, 8);\n<26> \n<27> }\n<28> \n<29> buf[i] = 0;\n<30> \n<31> \n<32> \n<33> /* divx detection */\n<34> \n<35> e = sscanf(buf, "DivX%dBuild%d%c", &ver, &build, &last);\n<36> \n<37> if (e < 2)\n<38> \n<39> e = sscanf(buf, "DivX%db%d%c", &ver, &build, &last);\n<40> \n<41> if (e >= 2) {\n<42> \n<43> ctx->divx_version = ver;\n<44> \n<45> ctx->divx_build   = build;\n<46> \n<47> s->divx_packed  = e == 3 && last == 'p';\n<48> \n<49> }\n<50> \n<51> \n<52> \n<53> /* libavcodec detection */\n<54> \n<55> e = sscanf(buf, "FFmpe%*[^b]b%d", &build) + 3;\n<56> \n<57> if (e != 4)\n<58> \n<59> e = sscanf(buf, "FFmpeg v%d.%d.%d / libavcodec build: %d", &ver, &ver2, &ver3, &build);\n<60> \n<61> if (e != 4) {\n<62> \n<63> e = sscanf(buf, "Lavc%d.%d.%d", &ver, &ver2, &ver3) + 1;\n<64> \n<65> if (e > 1) {\n<66> \n<67> if (ver > 0xFF || ver2 > 0xFF || ver3 > 0xFF) {\n<68> \n<69> av_log(s->avctx, AV_LOG_WARNING,\n<70> \n<71> "Unknown Lavc version string encountered, %d.%d.%d; "\n<72> \n<73> "clamping sub-version values to 8-bits.\n",\n<74> \n<75> ver, ver2, ver3);\n<76> \n<77> }\n<78> \n<79> build = ((ver & 0xFF) << 16) + ((ver2 & 0xFF) << 8) + (ver3 & 0xFF);\n<80> \n<81> }\n<82> \n<83> }\n<84> \n<85> if (e != 4) {\n<86> \n<87> if (strcmp(buf, "ffmpeg") == 0)\n<88> \n<89> ctx->lavc_build = 4600;\n<90> \n<91> }\n<92> \n<93> if (e == 4)\n<94> \n<95> ctx->lavc_build = build;\n<96> \n<97> \n<98> \n<99> /* Xvid detection */\n<100> \n<101> e = sscanf(buf, "XviD%d", &build);\n<102> \n<103> if (e == 1)\n<104> \n<105> ctx->xvid_build = build;\n<106> \n<107> \n<108> \n<109> return 0;\n<110> \n<111> }\n<112> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int sls_flags_filename_process(struct AVFormatContext *s, HLSContext *hls,\n<2> \n<3> VariantStream *vs, HLSSegment *en,\n<4> \n<5> double duration, int64_t pos, int64_t size)\n<6> \n<7> {\n<8> \n<9> if ((hls->flags & (HLS_SECOND_LEVEL_SEGMENT_SIZE | HLS_SECOND_LEVEL_SEGMENT_DURATION)) &&\n<10> \n<11> strlen(vs->current_segment_final_filename_fmt)) {\n<12> \n<13> av_strlcpy(vs->avf->filename, vs->current_segment_final_filename_fmt, sizeof(vs->avf->filename));\n<14> \n<15> if (hls->flags & HLS_SECOND_LEVEL_SEGMENT_SIZE) {\n<16> \n<17> char * filename = av_strdup(vs->avf->filename);  // %%s will be %s after strftime\n<18> \n<19> if (!filename) {\n<20> \n<21> av_free(en);\n<22> \n<23> return AVERROR(ENOMEM);\n<24> \n<25> }\n<26> \n<27> if (replace_int_data_in_filename(vs->avf->filename, sizeof(vs->avf->filename),\n<28> \n<29> filename, 's', pos + size) < 1) {\n<30> \n<31> av_log(hls, AV_LOG_ERROR,\n<32> \n<33> "Invalid second level segment filename template '%s', "\n<34> \n<35> "you can try to remove second_level_segment_size flag\n",\n<36> \n<37> filename);\n<38> \n<39> av_free(filename);\n<40> \n<41> av_free(en);\n<42> \n<43> return AVERROR(EINVAL);\n<44> \n<45> }\n<46> \n<47> av_free(filename);\n<48> \n<49> }\n<50> \n<51> if (hls->flags & HLS_SECOND_LEVEL_SEGMENT_DURATION) {\n<52> \n<53> char * filename = av_strdup(vs->avf->filename);  // %%t will be %t after strftime\n<54> \n<55> if (!filename) {\n<56> \n<57> av_free(en);\n<58> \n<59> return AVERROR(ENOMEM);\n<60> \n<61> }\n<62> \n<63> if (replace_int_data_in_filename(vs->avf->filename, sizeof(vs->avf->filename),\n<64> \n<65> filename, 't',  (int64_t)round(duration * HLS_MICROSECOND_UNIT)) < 1) {\n<66> \n<67> av_log(hls, AV_LOG_ERROR,\n<68> \n<69> "Invalid second level segment filename template '%s', "\n<70> \n<71> "you can try to remove second_level_segment_time flag\n",\n<72> \n<73> filename);\n<74> \n<75> av_free(filename);\n<76> \n<77> av_free(en);\n<78> \n<79> return AVERROR(EINVAL);\n<80> \n<81> }\n<82> \n<83> av_free(filename);\n<84> \n<85> }\n<86> \n<87> }\n<88> \n<89> return 0;\n<90> \n<91> }\n<92> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void smbios_build_type_1_fields(const char *t)\n<2> \n<3> {\n<4> \n<5> char buf[1024];\n<6> \n<7> \n<8> \n<9> if (get_param_value(buf, sizeof(buf), "manufacturer", t))\n<10> \n<11> smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),\n<12> \n<13> strlen(buf) + 1, buf);\n<14> \n<15> if (get_param_value(buf, sizeof(buf), "product", t))\n<16> \n<17> smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),\n<18> \n<19> strlen(buf) + 1, buf);\n<20> \n<21> if (get_param_value(buf, sizeof(buf), "version", t))\n<22> \n<23> smbios_add_field(1, offsetof(struct smbios_type_1, version_str),\n<24> \n<25> strlen(buf) + 1, buf);\n<26> \n<27> if (get_param_value(buf, sizeof(buf), "serial", t))\n<28> \n<29> smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),\n<30> \n<31> strlen(buf) + 1, buf);\n<32> \n<33> if (get_param_value(buf, sizeof(buf), "uuid", t)) {\n<34> \n<35> if (qemu_uuid_parse(buf, qemu_uuid) != 0) {\n<36> \n<37> fprintf(stderr, "Invalid SMBIOS UUID string\n");\n<38> \n<39> exit(1);\n<40> \n<41> }\n<42> \n<43> }\n<44> \n<45> if (get_param_value(buf, sizeof(buf), "sku", t))\n<46> \n<47> smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),\n<48> \n<49> strlen(buf) + 1, buf);\n<50> \n<51> if (get_param_value(buf, sizeof(buf), "family", t))\n<52> \n<53> smbios_add_field(1, offsetof(struct smbios_type_1, family_str),\n<54> \n<55> strlen(buf) + 1, buf);\n<56> \n<57> }\n<58> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void qmp_block_commit(const char *device,\n<2> \n<3> bool has_base, const char *base,\n<4> \n<5> bool has_top, const char *top,\n<6> \n<7> bool has_backing_file, const char *backing_file,\n<8> \n<9> bool has_speed, int64_t speed,\n<10> \n<11> Error **errp)\n<12> \n<13> {\n<14> \n<15> BlockDriverState *bs;\n<16> \n<17> BlockDriverState *base_bs, *top_bs;\n<18> \n<19> Error *local_err = NULL;\n<20> \n<21> /* This will be part of the QMP command, if/when the\n<22> \n<23> * BlockdevOnError change for blkmirror makes it in\n<24> \n<25> */\n<26> \n<27> BlockdevOnError on_error = BLOCKDEV_ON_ERROR_REPORT;\n<28> \n<29> \n<30> \n<31> if (!has_speed) {\n<32> \n<33> speed = 0;\n<34> \n<35> }\n<36> \n<37> \n<38> \n<39> /* drain all i/o before commits */\n<40> \n<41> bdrv_drain_all();\n<42> \n<43> \n<44> \n<45> /* Important Note:\n<46> \n<47> *  libvirt relies on the DeviceNotFound error class in order to probe for\n<48> \n<49> *  live commit feature versions; for this to work, we must make sure to\n<50> \n<51> *  perform the device lookup before any generic errors that may occur in a\n<52> \n<53> *  scenario in which all optional arguments are omitted. */\n<54> \n<55> bs = bdrv_find(device);\n<56> \n<57> if (!bs) {\n<58> \n<59> error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n<60> \n<61> return;\n<62> \n<63> }\n<64> \n<65> \n<66> \n<67> if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_COMMIT, errp)) {\n<68> \n<69> return;\n<70> \n<71> }\n<72> \n<73> \n<74> \n<75> /* default top_bs is the active layer */\n<76> \n<77> top_bs = bs;\n<78> \n<79> \n<80> \n<81> if (has_top && top) {\n<82> \n<83> if (strcmp(bs->filename, top) != 0) {\n<84> \n<85> top_bs = bdrv_find_backing_image(bs, top);\n<86> \n<87> }\n<88> \n<89> }\n<90> \n<91> \n<92> \n<93> if (top_bs == NULL) {\n<94> \n<95> error_setg(errp, "Top image file %s not found", top ? top : "NULL");\n<96> \n<97> return;\n<98> \n<99> }\n<100> \n<101> \n<102> \n<103> if (has_base && base) {\n<104> \n<105> base_bs = bdrv_find_backing_image(top_bs, base);\n<106> \n<107> } else {\n<108> \n<109> base_bs = bdrv_find_base(top_bs);\n<110> \n<111> }\n<112> \n<113> \n<114> \n<115> if (base_bs == NULL) {\n<116> \n<117> error_set(errp, QERR_BASE_NOT_FOUND, base ? base : "NULL");\n<118> \n<119> return;\n<120> \n<121> }\n<122> \n<123> \n<124> \n<125> /* Do not allow attempts to commit an image into itself */\n<126> \n<127> if (top_bs == base_bs) {\n<128> \n<129> error_setg(errp, "cannot commit an image into itself");\n<130> \n<131> return;\n<132> \n<133> }\n<134> \n<135> \n<136> \n<137> if (top_bs == bs) {\n<138> \n<139> if (has_backing_file) {\n<140> \n<141> error_setg(errp, "'backing-file' specified,"\n<142> \n<143> " but 'top' is the active layer");\n<144> \n<145> return;\n<146> \n<147> }\n<148> \n<149> commit_active_start(bs, base_bs, speed, on_error, block_job_cb,\n<150> \n<151> bs, &local_err);\n<152> \n<153> } else {\n<154> \n<155> commit_start(bs, base_bs, top_bs, speed, on_error, block_job_cb, bs,\n<156> \n<157> has_backing_file ? backing_file : NULL, &local_err);\n<158> \n<159> }\n<160> \n<161> if (local_err != NULL) {\n<162> \n<163> error_propagate(errp, local_err);\n<164> \n<165> return;\n<166> \n<167> }\n<168> \n<169> }\n<170> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int sbr_mapping ( AACContext * ac , SpectralBandReplication * sbr , SBRData * ch_data , int e_a [ 2 ] ) {\n<2> int e , i , m ;\n<3> memset ( ch_data -> s_indexmapped [ 1 ] , 0 , 7 * sizeof ( ch_data -> s_indexmapped [ 1 ] ) ) ;\n<4> for ( e = 0 ;\n<5> e < ch_data -> bs_num_env ;\n<6> e ++ ) {\n<7> const unsigned int ilim = sbr -> n [ ch_data -> bs_freq_res [ e + 1 ] ] ;\n<8> uint16_t * table = ch_data -> bs_freq_res [ e + 1 ] ? sbr -> f_tablehigh : sbr -> f_tablelow ;\n<9> int k ;\n<10> if ( sbr -> kx [ 1 ] != table [ 0 ] ) {\n<11> av_log ( ac -> avctx , AV_LOG_ERROR , "kx != f_table{\n<12> high,low}\n<13> [0]. " "Derived frequency tables were not regenerated.\n" ) ;\n<14> sbr_turnoff ( sbr ) ;\n<15> return AVERROR_BUG ;\n<16> }\n<17> for ( i = 0 ;\n<18> i < ilim ;\n<19> i ++ ) for ( m = table [ i ] ;\n<20> m < table [ i + 1 ] ;\n<21> m ++ ) sbr -> e_origmapped [ e ] [ m - sbr -> kx [ 1 ] ] = ch_data -> env_facs [ e + 1 ] [ i ] ;\n<22> k = ( ch_data -> bs_num_noise > 1 ) && ( ch_data -> t_env [ e ] >= ch_data -> t_q [ 1 ] ) ;\n<23> for ( i = 0 ;\n<24> i < sbr -> n_q ;\n<25> i ++ ) for ( m = sbr -> f_tablenoise [ i ] ;\n<26> m < sbr -> f_tablenoise [ i + 1 ] ;\n<27> m ++ ) sbr -> q_mapped [ e ] [ m - sbr -> kx [ 1 ] ] = ch_data -> noise_facs [ k + 1 ] [ i ] ;\n<28> for ( i = 0 ;\n<29> i < sbr -> n [ 1 ] ;\n<30> i ++ ) {\n<31> if ( ch_data -> bs_add_harmonic_flag ) {\n<32> const unsigned int m_midpoint = ( sbr -> f_tablehigh [ i ] + sbr -> f_tablehigh [ i + 1 ] ) >> 1 ;\n<33> ch_data -> s_indexmapped [ e + 1 ] [ m_midpoint - sbr -> kx [ 1 ] ] = ch_data -> bs_add_harmonic [ i ] * ( e >= e_a [ 1 ] || ( ch_data -> s_indexmapped [ 0 ] [ m_midpoint - sbr -> kx [ 1 ] ] == 1 ) ) ;\n<34> }\n<35> }\n<36> for ( i = 0 ;\n<37> i < ilim ;\n<38> i ++ ) {\n<39> int additional_sinusoid_present = 0 ;\n<40> for ( m = table [ i ] ;\n<41> m < table [ i + 1 ] ;\n<42> m ++ ) {\n<43> if ( ch_data -> s_indexmapped [ e + 1 ] [ m - sbr -> kx [ 1 ] ] ) {\n<44> additional_sinusoid_present = 1 ;\n<45> break ;\n<46> }\n<47> }\n<48> memset ( & sbr -> s_mapped [ e ] [ table [ i ] - sbr -> kx [ 1 ] ] , additional_sinusoid_present , ( table [ i + 1 ] - table [ i ] ) * sizeof ( sbr -> s_mapped [ e ] [ 0 ] ) ) ;\n<49> }\n<50> }\n<51> memcpy ( ch_data -> s_indexmapped [ 0 ] , ch_data -> s_indexmapped [ ch_data -> bs_num_env ] , sizeof ( ch_data -> s_indexmapped [ 0 ] ) ) ;\n<52> return 0 ;\n<53> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int ffm_read_data(AVFormatContext *s,\n<2> \n<3> uint8_t *buf, int size, int header)\n<4> \n<5> {\n<6> \n<7> FFMContext *ffm = s->priv_data;\n<8> \n<9> AVIOContext *pb = s->pb;\n<10> \n<11> int len, fill_size, size1, frame_offset, id;\n<12> \n<13> int64_t last_pos = -1;\n<14> \n<15> \n<16> \n<17> size1 = size;\n<18> \n<19> while (size > 0) {\n<20> \n<21> redo:\n<22> \n<23> len = ffm->packet_end - ffm->packet_ptr;\n<24> \n<25> if (len < 0)\n<26> \n<27> return -1;\n<28> \n<29> if (len > size)\n<30> \n<31> len = size;\n<32> \n<33> if (len == 0) {\n<34> \n<35> if (avio_tell(pb) == ffm->file_size)\n<36> \n<37> avio_seek(pb, ffm->packet_size, SEEK_SET);\n<38> \n<39> retry_read:\n<40> \n<41> if (pb->buffer_size != ffm->packet_size) {\n<42> \n<43> int64_t tell = avio_tell(pb);\n<44> \n<45> ffio_set_buf_size(pb, ffm->packet_size);\n<46> \n<47> avio_seek(pb, tell, SEEK_SET);\n<48> \n<49> }\n<50> \n<51> id = avio_rb16(pb); /* PACKET_ID */\n<52> \n<53> if (id != PACKET_ID) {\n<54> \n<55> if (ffm_resync(s, id) < 0)\n<56> \n<57> return -1;\n<58> \n<59> last_pos = avio_tell(pb);\n<60> \n<61> }\n<62> \n<63> fill_size = avio_rb16(pb);\n<64> \n<65> ffm->dts = avio_rb64(pb);\n<66> \n<67> frame_offset = avio_rb16(pb);\n<68> \n<69> avio_read(pb, ffm->packet, ffm->packet_size - FFM_HEADER_SIZE);\n<70> \n<71> ffm->packet_end = ffm->packet + (ffm->packet_size - FFM_HEADER_SIZE - fill_size);\n<72> \n<73> if (ffm->packet_end < ffm->packet || frame_offset < 0)\n<74> \n<75> return -1;\n<76> \n<77> /* if first packet or resynchronization packet, we must\n<78> \n<79> handle it specifically */\n<80> \n<81> if (ffm->first_packet || (frame_offset & 0x8000)) {\n<82> \n<83> if (!frame_offset) {\n<84> \n<85> /* This packet has no frame headers in it */\n<86> \n<87> if (avio_tell(pb) >= ffm->packet_size * 3LL) {\n<88> \n<89> int64_t seekback = FFMIN(ffm->packet_size * 2LL, avio_tell(pb) - last_pos);\n<90> \n<91> seekback = FFMAX(seekback, 0);\n<92> \n<93> avio_seek(pb, -seekback, SEEK_CUR);\n<94> \n<95> goto retry_read;\n<96> \n<97> }\n<98> \n<99> /* This is bad, we cannot find a valid frame header */\n<100> \n<101> return 0;\n<102> \n<103> }\n<104> \n<105> ffm->first_packet = 0;\n<106> \n<107> if ((frame_offset & 0x7fff) < FFM_HEADER_SIZE)\n<108> \n<109> return -1;\n<110> \n<111> ffm->packet_ptr = ffm->packet + (frame_offset & 0x7fff) - FFM_HEADER_SIZE;\n<112> \n<113> if (!header)\n<114> \n<115> break;\n<116> \n<117> } else {\n<118> \n<119> ffm->packet_ptr = ffm->packet;\n<120> \n<121> }\n<122> \n<123> goto redo;\n<124> \n<125> }\n<126> \n<127> memcpy(buf, ffm->packet_ptr, len);\n<128> \n<129> buf += len;\n<130> \n<131> ffm->packet_ptr += len;\n<132> \n<133> size -= len;\n<134> \n<135> header = 0;\n<136> \n<137> }\n<138> \n<139> return size1 - size;\n<140> \n<141> }\n<142> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int bink_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_chroma ) {\n<2> int blk , ret ;\n<3> int i , j , bx , by ;\n<4> uint8_t * dst , * prev , * ref , * ref_start , * ref_end ;\n<5> int v , col [ 2 ] ;\n<6> const uint8_t * scan ;\n<7> int xoff , yoff ;\n<8> LOCAL_ALIGNED_16 ( int16_t , block , [ 64 ] ) ;\n<9> LOCAL_ALIGNED_16 ( uint8_t , ublock , [ 64 ] ) ;\n<10> LOCAL_ALIGNED_16 ( int32_t , dctblock , [ 64 ] ) ;\n<11> int coordmap [ 64 ] ;\n<12> const int stride = c -> pic -> linesize [ plane_idx ] ;\n<13> int bw = is_chroma ? ( c -> avctx -> width + 15 ) >> 4 : ( c -> avctx -> width + 7 ) >> 3 ;\n<14> int bh = is_chroma ? ( c -> avctx -> height + 15 ) >> 4 : ( c -> avctx -> height + 7 ) >> 3 ;\n<15> int width = c -> avctx -> width >> is_chroma ;\n<16> init_lengths ( c , FFMAX ( width , 8 ) , bw ) ;\n<17> for ( i = 0 ;\n<18> i < BINK_NB_SRC ;\n<19> i ++ ) read_bundle ( gb , c , i ) ;\n<20> ref_start = c -> last -> data [ plane_idx ] ? c -> last -> data [ plane_idx ] : c -> pic -> data [ plane_idx ] ;\n<21> ref_end = ref_start + ( bw - 1 + c -> last -> linesize [ plane_idx ] * ( bh - 1 ) ) * 8 ;\n<22> for ( i = 0 ;\n<23> i < 64 ;\n<24> i ++ ) coordmap [ i ] = ( i & 7 ) + ( i >> 3 ) * stride ;\n<25> for ( by = 0 ;\n<26> by < bh ;\n<27> by ++ ) {\n<28> if ( ( ret = read_block_types ( c -> avctx , gb , & c -> bundle [ BINK_SRC_BLOCK_TYPES ] ) ) < 0 ) return ret ;\n<29> if ( ( ret = read_block_types ( c -> avctx , gb , & c -> bundle [ BINK_SRC_SUB_BLOCK_TYPES ] ) ) < 0 ) return ret ;\n<30> if ( ( ret = read_colors ( gb , & c -> bundle [ BINK_SRC_COLORS ] , c ) ) < 0 ) return ret ;\n<31> if ( ( ret = read_patterns ( c -> avctx , gb , & c -> bundle [ BINK_SRC_PATTERN ] ) ) < 0 ) return ret ;\n<32> if ( ( ret = read_motion_values ( c -> avctx , gb , & c -> bundle [ BINK_SRC_X_OFF ] ) ) < 0 ) return ret ;\n<33> if ( ( ret = read_motion_values ( c -> avctx , gb , & c -> bundle [ BINK_SRC_Y_OFF ] ) ) < 0 ) return ret ;\n<34> if ( ( ret = read_dcs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_INTRA_DC ] , DC_START_BITS , 0 ) ) < 0 ) return ret ;\n<35> if ( ( ret = read_dcs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_INTER_DC ] , DC_START_BITS , 1 ) ) < 0 ) return ret ;\n<36> if ( ( ret = read_runs ( c -> avctx , gb , & c -> bundle [ BINK_SRC_RUN ] ) ) < 0 ) return ret ;\n<37> if ( by == bh ) break ;\n<38> dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n<39> prev = ( c -> last -> data [ plane_idx ] ? c -> last -> data [ plane_idx ] : c -> pic -> data [ plane_idx ] ) + 8 * by * stride ;\n<40> for ( bx = 0 ;\n<41> bx < bw ;\n<42> bx ++ , dst += 8 , prev += 8 ) {\n<43> blk = get_value ( c , BINK_SRC_BLOCK_TYPES ) ;\n<44> if ( ( by & 1 ) && blk == SCALED_BLOCK ) {\n<45> bx ++ ;\n<46> dst += 8 ;\n<47> prev += 8 ;\n<48> continue ;\n<49> }\n<50> switch ( blk ) {\n<51> case SKIP_BLOCK : c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , prev , stride , 8 ) ;\n<52> break ;\n<53> case SCALED_BLOCK : blk = get_value ( c , BINK_SRC_SUB_BLOCK_TYPES ) ;\n<54> switch ( blk ) {\n<55> case RUN_BLOCK : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n<56> i = 0 ;\n<57> do {\n<58> int run = get_value ( c , BINK_SRC_RUN ) + 1 ;\n<59> i += run ;\n<60> if ( i > 64 ) {\n<61> av_log ( c -> avctx , AV_LOG_ERROR , "Run went out of bounds\n" ) ;\n<62> return AVERROR_INVALIDDATA ;\n<63> }\n<64> if ( get_bits1 ( gb ) ) {\n<65> v = get_value ( c , BINK_SRC_COLORS ) ;\n<66> for ( j = 0 ;\n<67> j < run ;\n<68> j ++ ) ublock [ * scan ++ ] = v ;\n<69> }\n<70> else {\n<71> for ( j = 0 ;\n<72> j < run ;\n<73> j ++ ) ublock [ * scan ++ ] = get_value ( c , BINK_SRC_COLORS ) ;\n<74> }\n<75> }\n<76> while ( i < 63 ) ;\n<77> if ( i == 63 ) ublock [ * scan ++ ] = get_value ( c , BINK_SRC_COLORS ) ;\n<78> break ;\n<79> case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<80> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n<81> read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n<82> c -> bdsp . idct_put ( ublock , 8 , dctblock ) ;\n<83> break ;\n<84> case FILL_BLOCK : v = get_value ( c , BINK_SRC_COLORS ) ;\n<85> c -> dsp . fill_block_tab [ 0 ] ( dst , v , stride , 16 ) ;\n<86> break ;\n<87> case PATTERN_BLOCK : for ( i = 0 ;\n<88> i < 2 ;\n<89> i ++ ) col [ i ] = get_value ( c , BINK_SRC_COLORS ) ;\n<90> for ( j = 0 ;\n<91> j < 8 ;\n<92> j ++ ) {\n<93> v = get_value ( c , BINK_SRC_PATTERN ) ;\n<94> for ( i = 0 ;\n<95> i < 8 ;\n<96> i ++ , v >>= 1 ) ublock [ i + j * 8 ] = col [ v & 1 ] ;\n<97> }\n<98> break ;\n<99> case RAW_BLOCK : for ( j = 0 ;\n<100> j < 8 ;\n<101> j ++ ) for ( i = 0 ;\n<102> i < 8 ;\n<103> i ++ ) ublock [ i + j * 8 ] = get_value ( c , BINK_SRC_COLORS ) ;\n<104> break ;\n<105> default : av_log ( c -> avctx , AV_LOG_ERROR , "Incorrect 16x16 block type %d\n" , blk ) ;\n<106> return AVERROR_INVALIDDATA ;\n<107> }\n<108> if ( blk != FILL_BLOCK ) c -> bdsp . scale_block ( ublock , dst , stride ) ;\n<109> bx ++ ;\n<110> dst += 8 ;\n<111> prev += 8 ;\n<112> break ;\n<113> case MOTION_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n<114> yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n<115> ref = prev + xoff + yoff * stride ;\n<116> if ( ref < ref_start || ref > ref_end ) {\n<117> av_log ( c -> avctx , AV_LOG_ERROR , "Copy out of bounds @%d, %d\n" , bx * 8 + xoff , by * 8 + yoff ) ;\n<118> return AVERROR_INVALIDDATA ;\n<119> }\n<120> c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n<121> break ;\n<122> case RUN_BLOCK : scan = bink_patterns [ get_bits ( gb , 4 ) ] ;\n<123> i = 0 ;\n<124> do {\n<125> int run = get_value ( c , BINK_SRC_RUN ) + 1 ;\n<126> i += run ;\n<127> if ( i > 64 ) {\n<128> av_log ( c -> avctx , AV_LOG_ERROR , "Run went out of bounds\n" ) ;\n<129> return AVERROR_INVALIDDATA ;\n<130> }\n<131> if ( get_bits1 ( gb ) ) {\n<132> v = get_value ( c , BINK_SRC_COLORS ) ;\n<133> for ( j = 0 ;\n<134> j < run ;\n<135> j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n<136> }\n<137> else {\n<138> for ( j = 0 ;\n<139> j < run ;\n<140> j ++ ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n<141> }\n<142> }\n<143> while ( i < 63 ) ;\n<144> if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n<145> break ;\n<146> case RESIDUE_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n<147> yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n<148> ref = prev + xoff + yoff * stride ;\n<149> if ( ref < ref_start || ref > ref_end ) {\n<150> av_log ( c -> avctx , AV_LOG_ERROR , "Copy out of bounds @%d, %d\n" , bx * 8 + xoff , by * 8 + yoff ) ;\n<151> return AVERROR_INVALIDDATA ;\n<152> }\n<153> c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n<154> c -> dsp . clear_block ( block ) ;\n<155> v = get_bits ( gb , 7 ) ;\n<156> read_residue ( gb , block , v ) ;\n<157> c -> dsp . add_pixels8 ( dst , block , stride ) ;\n<158> break ;\n<159> case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<160> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n<161> read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n<162> c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n<163> break ;\n<164> case FILL_BLOCK : v = get_value ( c , BINK_SRC_COLORS ) ;\n<165> c -> dsp . fill_block_tab [ 1 ] ( dst , v , stride , 8 ) ;\n<166> break ;\n<167> case INTER_BLOCK : xoff = get_value ( c , BINK_SRC_X_OFF ) ;\n<168> yoff = get_value ( c , BINK_SRC_Y_OFF ) ;\n<169> ref = prev + xoff + yoff * stride ;\n<170> c -> dsp . put_pixels_tab [ 1 ] [ 0 ] ( dst , ref , stride , 8 ) ;\n<171> memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<172> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTER_DC ) ;\n<173> read_dct_coeffs ( gb , dctblock , bink_scan , bink_inter_quant , - 1 ) ;\n<174> c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n<175> break ;\n<176> case PATTERN_BLOCK : for ( i = 0 ;\n<177> i < 2 ;\n<178> i ++ ) col [ i ] = get_value ( c , BINK_SRC_COLORS ) ;\n<179> for ( i = 0 ;\n<180> i < 8 ;\n<181> i ++ ) {\n<182> v = get_value ( c , BINK_SRC_PATTERN ) ;\n<183> for ( j = 0 ;\n<184> j < 8 ;\n<185> j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n<186> }\n<187> break ;\n<188> case RAW_BLOCK : for ( i = 0 ;\n<189> i < 8 ;\n<190> i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINK_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;\n<191> c -> bundle [ BINK_SRC_COLORS ] . cur_ptr += 64 ;\n<192> break ;\n<193> default : av_log ( c -> avctx , AV_LOG_ERROR , "Unknown block type %d\n" , blk ) ;\n<194> return AVERROR_INVALIDDATA ;\n<195> }\n<196> }\n<197> }\n<198> if ( get_bits_count ( gb ) & 0x1F ) / ext plane data starts at 32 - bit boundary skip_bits_long ( gb , 32 - ( get_bits_count ( gb ) & 0x1F ) ) ;\n<199> return 0 ;\n<200> }\n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

todo--
You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void fill_elf_header(struct elfhdr *elf, int segs, uint16_t machine,\n<2> \n<3> uint32_t flags)\n<4> \n<5> {\n<6> \n<7> (void) memset(elf, 0, sizeof(*elf));\n<8> \n<9> \n<10> \n<11> (void) memcpy(elf->e_ident, ELFMAG, SELFMAG);\n<12> \n<13> elf->e_ident[EI_CLASS] = ELF_CLASS;\n<14> \n<15> elf->e_ident[EI_DATA] = ELF_DATA;\n<16> \n<17> elf->e_ident[EI_VERSION] = EV_CURRENT;\n<18> \n<19> elf->e_ident[EI_OSABI] = ELF_OSABI;\n<20> \n<21> \n<22> \n<23> elf->e_type = ET_CORE;\n<24> \n<25> elf->e_machine = machine;\n<26> \n<27> elf->e_version = EV_CURRENT;\n<28> \n<29> elf->e_phoff = sizeof(struct elfhdr);\n<30> \n<31> elf->e_flags = flags;\n<32> \n<33> elf->e_ehsize = sizeof(struct elfhdr);\n<34> \n<35> elf->e_phentsize = sizeof(struct elf_phdr);\n<36> \n<37> elf->e_phnum = segs;\n<38> \n<39> \n<40> \n<41> #ifdef BSWAP_NEEDED\n<42> \n<43> bswap_ehdr(elf);\n<44> \n<45> #endif\n<46> \n<47> }\n<48> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void kvm_pit_put(PITCommonState *pit)\n<2> \n<3> {\n<4> \n<5> KVMPITState *s = KVM_PIT(pit);\n<6> \n<7> struct kvm_pit_state2 kpit;\n<8> \n<9> struct kvm_pit_channel_state *kchan;\n<10> \n<11> struct PITChannelState *sc;\n<12> \n<13> int i, ret;\n<14> \n<15> \n<16> \n<17> /* The offset keeps changing as long as the VM is stopped. */\n<18> \n<19> if (s->vm_stopped) {\n<20> \n<21> kvm_pit_update_clock_offset(s);\n<22> \n<23> }\n<24> \n<25> \n<26> \n<27> kpit.flags = pit->channels[0].irq_disabled ? KVM_PIT_FLAGS_HPET_LEGACY : 0;\n<28> \n<29> for (i = 0; i < 3; i++) {\n<30> \n<31> kchan = &kpit.channels[i];\n<32> \n<33> sc = &pit->channels[i];\n<34> \n<35> kchan->count = sc->count;\n<36> \n<37> kchan->latched_count = sc->latched_count;\n<38> \n<39> kchan->count_latched = sc->count_latched;\n<40> \n<41> kchan->status_latched = sc->status_latched;\n<42> \n<43> kchan->status = sc->status;\n<44> \n<45> kchan->read_state = sc->read_state;\n<46> \n<47> kchan->write_state = sc->write_state;\n<48> \n<49> kchan->write_latch = sc->write_latch;\n<50> \n<51> kchan->rw_mode = sc->rw_mode;\n<52> \n<53> kchan->mode = sc->mode;\n<54> \n<55> kchan->bcd = sc->bcd;\n<56> \n<57> kchan->gate = sc->gate;\n<58> \n<59> kchan->count_load_time = sc->count_load_time - s->kernel_clock_offset;\n<60> \n<61> }\n<62> \n<63> \n<64> \n<65> ret = kvm_vm_ioctl(kvm_state,\n<66> \n<67> kvm_has_pit_state2() ? KVM_SET_PIT2 : KVM_SET_PIT,\n<68> \n<69> &kpit);\n<70> \n<71> if (ret < 0) {\n<72> \n<73> fprintf(stderr, "%s failed: %s\n",\n<74> \n<75> kvm_has_pit_state2() ? "KVM_SET_PIT2" : "KVM_SET_PIT",\n<76> \n<77> strerror(ret));\n<78> \n<79> abort();\n<80> \n<81> }\n<82> \n<83> }\n<84> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int copy_stream_props(AVStream *st, AVStream *source_st)\n<2> \n<3> {\n<4> \n<5> int ret;\n<6> \n<7> \n<8> \n<9> if (st->codecpar->codec_id || !source_st->codecpar->codec_id) {\n<10> \n<11> if (st->codecpar->extradata_size < source_st->codecpar->extradata_size) {\n<12> \n<13> if (st->codecpar->extradata) {\n<14> \n<15> av_freep(&st->codecpar->extradata);\n<16> \n<17> st->codecpar->extradata_size = 0;\n<18> \n<19> }\n<20> \n<21> ret = ff_alloc_extradata(st->codecpar,\n<22> \n<23> source_st->codecpar->extradata_size);\n<24> \n<25> if (ret < 0)\n<26> \n<27> return ret;\n<28> \n<29> }\n<30> \n<31> memcpy(st->codecpar->extradata, source_st->codecpar->extradata,\n<32> \n<33> source_st->codecpar->extradata_size);\n<34> \n<35> return 0;\n<36> \n<37> }\n<38> \n<39> if ((ret = avcodec_parameters_copy(st->codecpar, source_st->codecpar)) < 0)\n<40> \n<41> return ret;\n<42> \n<43> st->r_frame_rate        = source_st->r_frame_rate;\n<44> \n<45> st->avg_frame_rate      = source_st->avg_frame_rate;\n<46> \n<47> st->time_base           = source_st->time_base;\n<48> \n<49> st->sample_aspect_ratio = source_st->sample_aspect_ratio;\n<50> \n<51> \n<52> \n<53> av_dict_copy(&st->metadata, source_st->metadata, 0);\n<54> \n<55> return 0;\n<56> \n<57> }\n<58> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n<2> \n<3> int legacy_format)\n<4> \n<5> {\n<6> \n<7> struct in_addr host_addr = { .s_addr = INADDR_ANY };\n<8> \n<9> struct in_addr guest_addr = { .s_addr = 0 };\n<10> \n<11> int host_port, guest_port;\n<12> \n<13> const char *p;\n<14> \n<15> char buf[256];\n<16> \n<17> int is_udp;\n<18> \n<19> char *end;\n<20> \n<21> \n<22> \n<23> p = redir_str;\n<24> \n<25> if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<26> \n<27> goto fail_syntax;\n<28> \n<29> }\n<30> \n<31> if (!strcmp(buf, "tcp") || buf[0] == '\0') {\n<32> \n<33> is_udp = 0;\n<34> \n<35> } else if (!strcmp(buf, "udp")) {\n<36> \n<37> is_udp = 1;\n<38> \n<39> } else {\n<40> \n<41> goto fail_syntax;\n<42> \n<43> }\n<44> \n<45> \n<46> \n<47> if (!legacy_format) {\n<48> \n<49> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<50> \n<51> goto fail_syntax;\n<52> \n<53> }\n<54> \n<55> if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) {\n<56> \n<57> goto fail_syntax;\n<58> \n<59> }\n<60> \n<61> }\n<62> \n<63> \n<64> \n<65> if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {\n<66> \n<67> goto fail_syntax;\n<68> \n<69> }\n<70> \n<71> host_port = strtol(buf, &end, 0);\n<72> \n<73> if (*end != '\0' || host_port < 1 || host_port > 65535) {\n<74> \n<75> goto fail_syntax;\n<76> \n<77> }\n<78> \n<79> \n<80> \n<81> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<82> \n<83> goto fail_syntax;\n<84> \n<85> }\n<86> \n<87> if (buf[0] != '\0' && !inet_aton(buf, &guest_addr)) {\n<88> \n<89> goto fail_syntax;\n<90> \n<91> }\n<92> \n<93> \n<94> \n<95> guest_port = strtol(p, &end, 0);\n<96> \n<97> if (*end != '\0' || guest_port < 1 || guest_port > 65535) {\n<98> \n<99> goto fail_syntax;\n<100> \n<101> }\n<102> \n<103> \n<104> \n<105> if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr,\n<106> \n<107> guest_port) < 0) {\n<108> \n<109> error_report("could not set up host forwarding rule '%s'",\n<110> \n<111> redir_str);\n<112> \n<113> return -1;\n<114> \n<115> }\n<116> \n<117> return 0;\n<118> \n<119> \n<120> \n<121> fail_syntax:\n<122> \n<123> error_report("invalid host forwarding rule '%s'", redir_str);\n<124> \n<125> return -1;\n<126> \n<127> }\n<128> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static void pxa2xx_pwrmode_write(CPUARMState *env, const ARMCPRegInfo *ri,\n<2> \n<3> uint64_t value)\n<4> \n<5> {\n<6> \n<7> PXA2xxState *s = (PXA2xxState *)ri->opaque;\n<8> \n<9> static const char *pwrmode[8] = {\n<10> \n<11> "Normal", "Idle", "Deep-idle", "Standby",\n<12> \n<13> "Sleep", "reserved (!)", "reserved (!)", "Deep-sleep",\n<14> \n<15> };\n<16> \n<17> \n<18> \n<19> if (value & 8) {\n<20> \n<21> printf("%s: CPU voltage change attempt\n", __func__);\n<22> \n<23> }\n<24> \n<25> switch (value & 7) {\n<26> \n<27> case 0:\n<28> \n<29> /* Do nothing */\n<30> \n<31> break;\n<32> \n<33> \n<34> \n<35> case 1:\n<36> \n<37> /* Idle */\n<38> \n<39> if (!(s->cm_regs[CCCR >> 2] & (1U << 31))) { /* CPDIS */\n<40> \n<41> cpu_interrupt(CPU(s->cpu), CPU_INTERRUPT_HALT);\n<42> \n<43> break;\n<44> \n<45> }\n<46> \n<47> /* Fall through.  */\n<48> \n<49> \n<50> \n<51> case 2:\n<52> \n<53> /* Deep-Idle */\n<54> \n<55> cpu_interrupt(CPU(s->cpu), CPU_INTERRUPT_HALT);\n<56> \n<57> s->pm_regs[RCSR >> 2] |= 0x8; /* Set GPR */\n<58> \n<59> goto message;\n<60> \n<61> \n<62> \n<63> case 3:\n<64> \n<65> s->cpu->env.uncached_cpsr = ARM_CPU_MODE_SVC;\n<66> \n<67> s->cpu->env.daif = PSTATE_A | PSTATE_F | PSTATE_I;\n<68> \n<69> s->cpu->env.cp15.sctlr_ns = 0;\n<70> \n<71> s->cpu->env.cp15.c1_coproc = 0;\n<72> \n<73> s->cpu->env.cp15.ttbr0_el[1] = 0;\n<74> \n<75> s->cpu->env.cp15.c3 = 0;\n<76> \n<77> s->pm_regs[PSSR >> 2] |= 0x8; /* Set STS */\n<78> \n<79> s->pm_regs[RCSR >> 2] |= 0x8; /* Set GPR */\n<80> \n<81> \n<82> \n<83> /*\n<84> \n<85> * The scratch-pad register is almost universally used\n<86> \n<87> * for storing the return address on suspend.  For the\n<88> \n<89> * lack of a resuming bootloader, perform a jump\n<90> \n<91> * directly to that address.\n<92> \n<93> */\n<94> \n<95> memset(s->cpu->env.regs, 0, 4 * 15);\n<96> \n<97> s->cpu->env.regs[15] = s->pm_regs[PSPR >> 2];\n<98> \n<99> \n<100> \n<101> #if 0\n<102> \n<103> buffer = 0xe59ff000; /* ldr     pc, [pc, #0] */\n<104> \n<105> cpu_physical_memory_write(0, &buffer, 4);\n<106> \n<107> buffer = s->pm_regs[PSPR >> 2];\n<108> \n<109> cpu_physical_memory_write(8, &buffer, 4);\n<110> \n<111> #endif\n<112> \n<113> \n<114> \n<115> /* Suspend */\n<116> \n<117> cpu_interrupt(current_cpu, CPU_INTERRUPT_HALT);\n<118> \n<119> \n<120> \n<121> goto message;\n<122> \n<123> \n<124> \n<125> default:\n<126> \n<127> message:\n<128> \n<129> printf("%s: machine entered %s mode\n", __func__,\n<130> \n<131> pwrmode[value & 7]);\n<132> \n<133> }\n<134> \n<135> }\n<136> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int http_read(URLContext *h, uint8_t *buf, int size)\n<2> \n<3> {\n<4> \n<5> HTTPContext *s = h->priv_data;\n<6> \n<7> int size1, len;\n<8> \n<9> \n<10> \n<11> size1 = size;\n<12> \n<13> while (size > 0) {\n<14> \n<15> /* read bytes from input buffer first */\n<16> \n<17> len = s->buf_end - s->buf_ptr;\n<18> \n<19> if (len > 0) {\n<20> \n<21> if (len > size)\n<22> \n<23> len = size;\n<24> \n<25> memcpy(buf, s->buf_ptr, len);\n<26> \n<27> s->buf_ptr += len;\n<28> \n<29> } else {\n<30> \n<31> len = url_read (s->hd, buf, size);\n<32> \n<33> if (len < 0) {\n<34> \n<35> return len;\n<36> \n<37> } else if (len == 0) {\n<38> \n<39> break;\n<40> \n<41> }\n<42> \n<43> }\n<44> \n<45> size -= len;\n<46> \n<47> buf += len;\n<48> \n<49> }\n<50> \n<51> return size1 - size;\n<52> \n<53> }\n<54> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> void disas(FILE *out, void *code, unsigned long size)\n<2> \n<3> {\n<4> \n<5> unsigned long pc;\n<6> \n<7> int count;\n<8> \n<9> struct disassemble_info disasm_info;\n<10> \n<11> int (*print_insn)(bfd_vma pc, disassemble_info *info);\n<12> \n<13> \n<14> \n<15> INIT_DISASSEMBLE_INFO(disasm_info, out, fprintf);\n<16> \n<17> \n<18> \n<19> disasm_info.buffer = code;\n<20> \n<21> disasm_info.buffer_vma = (unsigned long)code;\n<22> \n<23> disasm_info.buffer_length = size;\n<24> \n<25> \n<26> \n<27> #ifdef HOST_WORDS_BIGENDIAN\n<28> \n<29> disasm_info.endian = BFD_ENDIAN_BIG;\n<30> \n<31> #else\n<32> \n<33> disasm_info.endian = BFD_ENDIAN_LITTLE;\n<34> \n<35> #endif\n<36> \n<37> #if defined(__i386__)\n<38> \n<39> disasm_info.mach = bfd_mach_i386_i386;\n<40> \n<41> print_insn = print_insn_i386;\n<42> \n<43> #elif defined(__x86_64__)\n<44> \n<45> disasm_info.mach = bfd_mach_x86_64;\n<46> \n<47> print_insn = print_insn_i386;\n<48> \n<49> #elif defined(_ARCH_PPC)\n<50> \n<51> print_insn = print_insn_ppc;\n<52> \n<53> #elif defined(__alpha__)\n<54> \n<55> print_insn = print_insn_alpha;\n<56> \n<57> #elif defined(__sparc__)\n<58> \n<59> print_insn = print_insn_sparc;\n<60> \n<61> #if defined(__sparc_v8plus__) || defined(__sparc_v8plusa__) || defined(__sparc_v9__)\n<62> \n<63> disasm_info.mach = bfd_mach_sparc_v9b;\n<64> \n<65> #endif\n<66> \n<67> #elif defined(__arm__)\n<68> \n<69> print_insn = print_insn_arm;\n<70> \n<71> #elif defined(__MIPSEB__)\n<72> \n<73> print_insn = print_insn_big_mips;\n<74> \n<75> #elif defined(__MIPSEL__)\n<76> \n<77> print_insn = print_insn_little_mips;\n<78> \n<79> #elif defined(__m68k__)\n<80> \n<81> print_insn = print_insn_m68k;\n<82> \n<83> #elif defined(__s390__)\n<84> \n<85> print_insn = print_insn_s390;\n<86> \n<87> #elif defined(__hppa__)\n<88> \n<89> print_insn = print_insn_hppa;\n<90> \n<91> #elif defined(__ia64__)\n<92> \n<93> print_insn = print_insn_ia64;\n<94> \n<95> #else\n<96> \n<97> fprintf(out, "0x%lx: Asm output not supported on this arch\n",\n<98> \n<99> (long) code);\n<100> \n<101> return;\n<102> \n<103> #endif\n<104> \n<105> for (pc = (unsigned long)code; size > 0; pc += count, size -= count) {\n<106> \n<107> fprintf(out, "0x%08lx:  ", pc);\n<108> \n<109> #ifdef __arm__\n<110> \n<111> /* since data is included in the code, it is better to\n<112> \n<113> display code data too */\n<114> \n<115> fprintf(out, "%08x  ", (int)bfd_getl32((const bfd_byte *)pc));\n<116> \n<117> #endif\n<118> \n<119> count = print_insn(pc, &disasm_info);\n<120> \n<121> fprintf(out, "\n");\n<122> \n<123> if (count < 0)\n<124> \n<125> break;\n<126> \n<127> }\n<128> \n<129> }\n<130> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1

You are a code auditor tasked with reviewing the following C/C++ code. Your goal is to analyze the code and identify any vulnerabilities or security flaws.\n\n    ### Full source code:\n    ```\n    <1> static int parse_read_intervals(const char *intervals_spec)\n<2> \n<3> {\n<4> \n<5> int ret, n, i;\n<6> \n<7> char *p, *spec = av_strdup(intervals_spec);\n<8> \n<9> if (!spec)\n<10> \n<11> return AVERROR(ENOMEM);\n<12> \n<13> \n<14> \n<15> /* preparse specification, get number of intervals */\n<16> \n<17> for (n = 0, p = spec; *p; p++)\n<18> \n<19> if (*p == ',')\n<20> \n<21> n++;\n<22> \n<23> n++;\n<24> \n<25> \n<26> \n<27> read_intervals = av_malloc(n * sizeof(*read_intervals));\n<28> \n<29> if (!read_intervals) {\n<30> \n<31> ret = AVERROR(ENOMEM);\n<32> \n<33> goto end;\n<34> \n<35> }\n<36> \n<37> read_intervals_nb = n;\n<38> \n<39> \n<40> \n<41> /* parse intervals */\n<42> \n<43> p = spec;\n<44> \n<45> for (i = 0; i < n; i++) {\n<46> \n<47> char *next = strchr(p, ',');\n<48> \n<49> if (next)\n<50> \n<51> *next++ = 0;\n<52> \n<53> \n<54> \n<55> read_intervals[i].id = i;\n<56> \n<57> ret = parse_read_interval(p, &read_intervals[i]);\n<58> \n<59> if (ret < 0) {\n<60> \n<61> av_log(NULL, AV_LOG_ERROR, "Error parsing read interval #%d '%s'\n",\n<62> \n<63> i, p);\n<64> \n<65> goto end;\n<66> \n<67> }\n<68> \n<69> av_log(NULL, AV_LOG_VERBOSE, "Parsed log interval ");\n<70> \n<71> log_read_interval(&read_intervals[i], NULL, AV_LOG_VERBOSE);\n<72> \n<73> p = next;\n<74> \n<75> av_assert0(i <= read_intervals_nb);\n<76> \n<77> }\n<78> \n<79> av_assert0(i == read_intervals_nb);\n<80> \n<81> \n<82> \n<83> end:\n<84> \n<85> av_free(spec);\n<86> \n<87> return ret;\n<88> \n<89> }\n<90> \n    ```\n    \n    - If no vulnerabilities are found, output: `Label: 0`\n    - If vulnerabilities are found, output: `Label: 1`\n    
label: 1
gpt4 1
