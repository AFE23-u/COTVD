<1> static void test_hmac_speed(const void *opaque)\n<23> if (!qcrypto_hmac_supports(QCRYPTO_HASH_ALG_SHA256)) {\n<31> in = g_new0(uint8_t, chunk_size);\n<33> memset(in, g_test_rand_int(), chunk_size);\n<37> iov.iov_base = (char *)in;\n<39> iov.iov_len = chunk_size;\n<49> (const uint8_t *)KEY, strlen(KEY), &err);\n<69> total += chunk_size;\n<71> } while (g_test_timer_elapsed() < 5.0);\n<81> g_print("Testing chunk_size %ld bytes ", chunk_size);\n<91> g_free(in);
<1> static MagickBooleanType IsVIFF ( const unsigned char * magick , const size_t length ) {\n<2> if ( length < 2 ) return ( MagickFalse ) ;\n<3> if ( memcmp ( magick , "\253\001" , 2 ) == 0 ) return ( MagickTrue ) ;\n<4> return ( MagickFalse ) ;
<1> static int tablefilematch ( struct taboff * tab , FILE * ttc , struct alltabs * all , int pos ) {\n<9> if ( test == NULL || test -> data == ( void * ) ( intpt ) - 1 || test -> length != tab -> length ) continue ;\n<10> rewind ( tab -> data ) ;\n<11> fseek ( ttc , test -> offset , SEEK_SET ) ;\n<13> len < tab -> length && ( ch1 = getc ( tab -> data ) ) != EOF && ( ch2 = getc ( ttc ) ) != EOF ;\n<15> if ( ch1 != ch2 ) break ;\n<18> rewind ( tab -> data ) ;\n<19> fseek ( ttc , 0 , SEEK_END ) ;\n<23> rewind ( tab -> data ) ;\n<24> fseek ( ttc , 0 , SEEK_END ) ;
<1> bool hostname_requires_resolving ( const char * hostname ) {\n<3> if ( ! hostname ) return FALSE ;\n<4> size_t namelen = strlen ( hostname ) ;\n<5> size_t lhlen = strlen ( my_localhost ) ;\n<6> if ( ( namelen == lhlen ) && ! my_strnncoll ( system_charset_info , ( const uchar * ) hostname , namelen , ( const uchar * ) my_localhost , strlen ( my_localhost ) ) ) return FALSE ;\n<9> hostname ++ ) {
<1> void hid_reset(HIDState *hs)\n<5> switch (hs->kind) {\n<9> memset(hs->kbd.keycodes, 0, sizeof(hs->kbd.keycodes));\n<11> memset(hs->kbd.key, 0, sizeof(hs->kbd.key));\n<22> memset(hs->ptr.queue, 0, sizeof(hs->ptr.queue));
<1> static void switch_time_zone ( FILE * sql_file , const char * delimiter , const char * time_zone ) {\n<2> fprintf ( sql_file , "/*!50003 SET @saved_time_zone = @@time_zone */ %s\n" "/*!50003 SET time_zone = '%s' */ %s\n" , ( const char * ) delimiter , ( const char * ) time_zone , ( const char * ) delimiter ) ;
<1> static void numa_add(const char *optarg)\n<19> optarg = get_opt_name(option, 128, optarg, ',');\n<21> if (*optarg == ',') {\n<27> if (!strcmp(option, "node")) {\n<31> if (nb_numa_nodes >= MAX_NODES) {\n<33> fprintf(stderr, "qemu: too many NUMA nodes\n");\n<41> if (get_param_value(option, 128, "nodeid", optarg) == 0) {\n<53> if (nodenr >= MAX_NODES) {\n<55> fprintf(stderr, "qemu: invalid NUMA nodeid: %llu\n", nodenr);\n<63> if (get_param_value(option, 128, "mem", optarg) == 0) {\n<73> if (sval < 0 || *endptr) {\n<75> fprintf(stderr, "qemu: invalid numa mem size: %s\n", optarg);\n<85> if (get_param_value(option, 128, "cpus", optarg) != 0) {\n<101> if (!(endvalue < MAX_CPUMASK_BITS)) {\n<103> endvalue = MAX_CPUMASK_BITS - 1;\n<119> nb_numa_nodes++;\n<123> fprintf(stderr, "Invalid -numa option: %s\n", option);\n<125> exit(1);
<1> static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, AVStream *vstream, int64_t max_pos) {\n<7> char str_val[256];\n<17> AVDictionaryEntry *creator = av_dict_get(s->metadata, "metadatacreator",\n<23> if (creator && !strcmp(creator->value, "MEGA")) {\n<37> return 0;\n<43> while (avio_tell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) {\n<51> if (avio_r8(ioc) != AMF_DATA_TYPE_ARRAY)\n<67> if (!strcmp(KEYFRAMES_TIMESTAMP_TAG, str_val) && !times) {\n<69> if (!(times = av_mallocz(sizeof(*times) * arraylen))) {\n<81> } else if (!strcmp(KEYFRAMES_BYTEOFFSET_TAG, str_val) && !filepositions) {\n<83> if (!(filepositions = av_mallocz(sizeof(*filepositions) * arraylen))) {\n<129> if (timeslen == fileposlen)\n<143> av_freep(&times);\n<145> av_freep(&filepositions);\n<151> if (ret < 0 && avio_seek(ioc, initial_pos, SEEK_SET) > 0)
<1> int boot_sector_init(char *fname)\n<11> fd = mkstemp(fname);\n<13> if (fd < 0) {\n<15> fprintf(stderr, "Couldn't open \"%s\": %s", fname, strerror(errno));\n<25> if (strcmp(qtest_get_arch(), "ppc64") == 0) {\n<27> len = sprintf((char *)boot_sector, "\\ Bootscript\n%x %x c! %x %x c!\n",\n<29> LOW(SIGNATURE), BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET,\n<31> HIGH(SIGNATURE), BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1);\n<37> ret = write(fd, boot_sector, len);\n<43> if (ret != len) {\n<45> fprintf(stderr, "Could not write \"%s\"", fname);
<1> static inline void copy_context_before_encode ( MpegEncContext * d , MpegEncContext * s , int type ) {\n<3> memcpy ( d -> last_mv , s -> last_mv , 2 * 2 * 2 * sizeof ( int ) ) ;
<1> static void sbr_hf_assemble ( float Y1 [ 38 ] [ 64 ] [ 2 ] , const float X_high [ 64 ] [ 40 ] [ 2 ] , SpectralBandReplication * sbr , SBRData * ch_data , const int e_a [ 2 ] ) {\n<14> i < h_SL ;\n<16> memcpy ( g_temp [ i + 2 * ch_data -> t_env [ 0 ] ] , sbr -> gain [ 0 ] , m_max * sizeof ( sbr -> gain [ 0 ] [ 0 ] ) ) ;\n<17> memcpy ( q_temp [ i + 2 * ch_data -> t_env [ 0 ] ] , sbr -> q_m [ 0 ] , m_max * sizeof ( sbr -> q_m [ 0 ] [ 0 ] ) ) ;\n<22> i < 4 ;\n<24> memcpy ( g_temp [ i + 2 * ch_data -> t_env [ 0 ] ] , g_temp [ i + 2 * ch_data -> t_env_num_env_old ] , sizeof ( g_temp [ 0 ] ) ) ;\n<25> memcpy ( q_temp [ i + 2 * ch_data -> t_env [ 0 ] ] , q_temp [ i + 2 * ch_data -> t_env_num_env_old ] , sizeof ( q_temp [ 0 ] ) ) ;\n<32> i < 2 * ch_data -> t_env [ e + 1 ] ;\n<34> memcpy ( g_temp [ h_SL + i ] , sbr -> gain [ e ] , m_max * sizeof ( sbr -> gain [ 0 ] [ 0 ] ) ) ;\n<35> memcpy ( q_temp [ h_SL + i ] , sbr -> q_m [ e ] , m_max * sizeof ( sbr -> q_m [ 0 ] [ 0 ] ) ) ;
<1> static int init_input_threads(void)\n<21> if (f->ctx->pb ? !f->ctx->pb->seekable :\n<23> strcmp(f->ctx->iformat->name, "lavfi"))
<1> int ff_h263_decode_frame(AVCodecContext *avctx,\n<9> const uint8_t *buf = avpkt->data;\n<67> next= ff_mpeg4_find_frame_end(&s->parse_context, buf, buf_size);\n<71> next= ff_h263_find_frame_end(&s->parse_context, buf, buf_size);\n<103> init_get_bits(&s->gb, buf, buf_size*8);\n<569> ff_vdpau_mpeg4_decode_picture(s, s->gb.buffer, s->gb.buffer_end - s->gb.buffer);\n<615> ret = decode_slice(s);\n<629> if(ff_h263_resync(s)<0)\n<647> if (decode_slice(s) < 0) ret = AVERROR_INVALIDDATA;\n<655> if(!CONFIG_MSMPEG4_DECODER || ff_msmpeg4_decode_ext_header(s, buf_size) < 0){\n<683> if(buf[i]==0 && buf[i+1]==0 && buf[i+2]==1 && buf[i+3]==0xB6){\n<713> buf_size - current_pos + FF_INPUT_BUFFER_PADDING_SIZE);\n<715> if (!s->bitstream_buffer)\n<719> memcpy(s->bitstream_buffer, buf + current_pos, buf_size - current_pos);\n<731> ff_er_frame_end(s);\n<745> ff_MPV_frame_end(s);\n<769> ff_print_debug_info(s, pict);\n<783> return (ret && (avctx->err_recognition & AV_EF_EXPLODE))?ret:get_consumed_bytes(s, buf_size);
<1> static void taihu_405ep_init(ram_addr_t ram_size,\n<125> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<138> if (bios_size < 0 || bios_size > BIOS_SIZE) {\n<140> fprintf(stderr, "qemu: could not load PowerPC bios '%s'\n",\n<222> kernel_size = load_image_targphys(kernel_filename, kernel_base,\n<226> if (kernel_size < 0) {\n<228> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<242> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<246> if (initrd_size < 0) {
<1> static int colo_packet_compare_common(Packet *ppkt, Packet *spkt, int offset)\n<31> offset = ppkt->vnet_hdr_len + offset;\n<35> if (ppkt->size == spkt->size) {\n<41> spkt->size - offset);
<1> static void ctl_flushpkt ( u_char more ) {\n<8> dlen = datapt - rpkt . u . data ;\n<11> * datapt ++ = '\n' ;\n<16> * datapt ++ = '\0' ;\n<36> if ( res_authenticate && sys_authenticate ) {\n<39> * datapt ++ = '\0' ;\n<42> keyid = htonl ( res_keyid ) ;\n<43> memcpy ( datapt , & keyid , sizeof ( keyid ) ) ;
<5> struct ogg *ogg = s->priv_data;\n<15> if (!ost)\n<39> if ((err = av_reallocp_array(&ogg->streams, ogg->nstreams,\n<51> ost->nstreams * sizeof(*ogg->streams));\n<55> av_free(ost);
<1> m_free(struct mbuf *m)\n<19> remque(m);\n<25> if (m->m_flags & M_EXT)\n<27> free(m->m_ext);\n<37> if (m->m_flags & M_DOFREE) {\n<39> free(m);\n<45> insque(m,&m->slirp->m_freelist);
<1> static void kvm_s390_stattrib_synchronize(S390StAttribState *sa)\n<37> if (r) {\n<39> error_report("KVM_S390_SET_CMMA_BITS failed: %s", strerror(-r));\n<57> if (r) {\n<59> error_report("KVM_S390_SET_CMMA_BITS failed: %s", strerror(-r));
<1> static int qemu_rdma_exchange_get_response(RDMAContext *rdma,\n<3> RDMAControlHeader *head, int expecting, int idx)\n<9> int ret = qemu_rdma_block_for_wrid(rdma, RDMA_WRID_RECV_CONTROL + idx,\n<15> if (ret < 0) {\n<17> fprintf(stderr, "rdma migration: recv polling control error!\n");\n<27> memcpy(head, rdma->wr_data[idx].control, sizeof(RDMAControlHeader));\n<31> DDDPRINTF("CONTROL: %s receiving...\n", control_desc[expecting]);\n<41> } else if (head->type != expecting || head->type == RDMA_CONTROL_ERROR) {\n<43> fprintf(stderr, "Was expecting a %s (%d) control message"\n<55> if (head->len > RDMA_CONTROL_MAX_BUFFER - sizeof(*head)) {\n<57> fprintf(stderr, "too long length: %d\n", head->len);\n<63> if (sizeof(*head) + head->len != byte_len) {\n<65> fprintf(stderr, "Malformed length: %d byte_len %d\n",
<1> static afs_int32 getCPS2 ( struct rx_call * call , afs_int32 aid , afs_uint32 ahost , prlist * alist , afs_int32 * over , afs_int32 * cid ) {\n<34> if ( temp ) {\n<36> if ( code == PRSUCCESS ) host_list = 1 ;\n<37> else fprintf ( stderr , "pr_ReadEntry returned %d\n" , code ) ;\n<39> else fprintf ( stderr , "FindByID Failed -- Not found\n" ) ;
<1> int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<11> MJpegDecodeContext *s = avctx->priv_data;\n<25> AVFrame *picture = data;\n<91> mjpeg_decode_app(s);\n<97> mjpeg_decode_com(s);\n<115> ff_mjpeg_decode_dqt(s);\n<121> if ((ret = ff_mjpeg_decode_dht(s)) < 0) {\n<141> if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n<155> if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n<169> if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n<183> if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n<193> (ret = ff_jpegls_decode_lse(s)) < 0)\n<233> if (!s->lossless) {\n<243> picture->qscale_table = s->qscale_table;\n<245> memset(picture->qscale_table, picture->quality,\n<247> (s->width + 15) / 16);\n<255> picture->quality *= FF_QP2LAMBDA;\n<265> if ((ret = ff_mjpeg_decode_sos(s, NULL, NULL)) < 0 &&\n<275> mjpeg_decode_dri(s);\n<351> for (index = s->width - 1; index; index--)\n<363> uint8_t *dst = &((uint8_t *)s->picture_ptr->data[s->upscale_v])[(s->height - 1) * s->linesize[s->upscale_v]];\n<379> if (src1 == src2) {\n<381> memcpy(dst, src1, s->width);\n<385> for (index = 0; index < s->width; index++)\n<387> dst[index] = (src1[index] + src2[index]) >> 1;\n<391> dst -= s->linesize[s->upscale_v];\n<407> int w = s->width;
<1> static CURLcode glob_set ( URLGlob * glob , char * * patternp , size_t * posp , unsigned long * amount , int globindex ) {\n<12> pat -> content . Set . elements = NULL ;\n<23> if ( pat -> content . Set . elements ) {\n<24> char * * new_arr = realloc ( pat -> content . Set . elements , ( pat -> content . Set . size + 1 ) * sizeof ( char * ) ) ;\n<25> if ( ! new_arr ) return GLOBERROR ( "out of memory" , 0 , CURLE_OUT_OF_MEMORY ) ;\n<28> else pat -> content . Set . elements = malloc ( sizeof ( char * ) ) ;\n<29> if ( ! pat -> content . Set . elements ) return GLOBERROR ( "out of memory" , 0 , CURLE_OUT_OF_MEMORY ) ;\n<30> pat -> content . Set . elements [ pat -> content . Set . size ] = strdup ( glob -> glob_buffer ) ;\n<31> if ( ! pat -> content . Set . elements [ pat -> content . Set . size ] ) return GLOBERROR ( "out of memory" , 0 , CURLE_OUT_OF_MEMORY ) ;\n<39> buf = glob -> glob_buffer ;
<1> static void test_bug56976 ( ) {\n<5> const char * query = "SELECT LENGTH(?)" ;\n<12> check_stmt ( stmt ) ;\n<13> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<14> check_execute ( stmt , rc ) ;\n<15> memset ( bind , 0 , sizeof ( bind ) ) ;\n<17> rc = mysql_stmt_bind_param ( stmt , bind ) ;\n<19> long_buffer = ( char * ) my_malloc ( packet_len , MYF ( 0 ) ) ;\n<20> DIE_UNLESS ( long_buffer ) ;\n<21> memset ( long_buffer , 'a' , packet_len ) ;\n<23> i < dos_len / packet_len ;\n<25> rc = mysql_stmt_send_long_data ( stmt , 0 , long_buffer , packet_len ) ;\n<28> my_free ( long_buffer ) ;
<1> static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n<7> FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n<12> memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n<14> ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));
<1> PHP_FUNCTION ( locale_accept_from_http ) {\n<13> if ( http_accept_len > ULOC_FULLNAME_CAPACITY ) {\n<14> char * start = http_accept ;\n<18> end = strchr ( start , ',' ) ;\n<19> len = end ? end - start : http_accept_len - ( start - http_accept ) ;\n<25> start = end + 1 ;\n<28> while ( end != NULL ) ;
<1> void ppc40x_core_reset (CPUState *env)\n<9> printf("Reset PowerPC core\n");
<1> static void kadmin_modprinc_usage ( ) {\n<2> fprintf ( stderr , _ ( "usage: modify_principal [options] principal\n" ) ) ;\n<3> fprintf ( stderr , _ ( "\toptions are:\n" ) ) ;
<1> static u_long getkeyid ( const char * keyprompt ) {\n<9> fprintf ( stderr , "%s" , keyprompt ) ;\n<10> fflush ( stderr ) ;\n<12> i < ilim && ( c = getc ( fi ) ) != '\n' && c != EOF ;\n<13> ) pbuf [ i ++ ] = ( char ) c ;\n<15> if ( fi != stdin ) fclose ( fi ) ;
<1> static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n<12> if ( appheadsz > 0 ) {\n<14> char * start = ( char * ) apphead ;\n<18> memset ( parsed , 0 , sizeof ( parsed ) ) ;\n<19> while ( ( slash = strchr ( start , '/' ) ) != NULL && place < ( kMaxArgs - 1 ) ) {\n<20> * slash = 0 ;\n<21> parsed [ place ++ ] = start ;\n<22> start = slash + 1 ;\n<24> parsed [ place ++ ] = start ;\n<26> main_get_appheader_params ( output , parsed , 1 , "output" , ifile ) ;\n<29> main_get_appheader_params ( sfile , parsed + 2 , 0 , "source" , ifile ) ;
<1> static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) {\n<10> * p ;\n<11> p ++ ) {\n<12> char * s = strchr ( json_escape , * p ) ;\n<15> av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ;\n<17> else if ( ( unsigned char ) * p < 32 ) {\n<18> av_bprintf ( dst , "\\u00%02x" , * p & 0xff ) ;\n<21> av_bprint_chars ( dst , * p , 1 ) ;
<1> static int ogg_new_buf ( struct ogg * ogg , int idx ) {\n<2> struct ogg_stream * os = ogg -> streams + idx ;\n<4> int size = os -> bufpos - os -> pstart ;\n<5> if ( ! nb ) return AVERROR ( ENOMEM ) ;\n<6> if ( os -> buf ) {\n<7> memcpy ( nb , os -> buf + os -> pstart , size ) ;\n<10> os -> buf = nb ;\n<11> os -> bufpos = size ;
<1> static gcry_err_code_t sexp_to_key ( gcry_sexp_t sexp , int want_private , int use , const char * override_elems , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * r_is_ecc ) {\n<18> if ( ! name ) {\n<22> if ( ! strcmp ( name , "ecc" ) ) is_ecc = 2 ;\n<23> else if ( ! strcmp ( name , "ecdsa" ) || ! strcmp ( name , "ecdh" ) ) is_ecc = 1 ;\n<24> else is_ecc = 0 ;\n<28> else module = gcry_pk_lookup_name ( name ) ;\n<30> gcry_free ( name ) ;\n<31> if ( ! module ) {\n<39> if ( override_elems ) elems = override_elems ;\n<40> else if ( want_private ) elems = pubkey -> elements_skey ;\n<41> else elems = pubkey -> elements_pkey ;\n<42> array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n<43> if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n<45> if ( is_ecc ) err = sexp_elements_extract_ecc ( list , elems , array , extraspec , want_private ) ;\n<46> else err = sexp_elements_extract ( list , elems , array , pubkey -> name , 0 ) ;
<1> void read_embedded_server_arguments ( const char * name ) {\n<13> if ( ! ( file = my_fopen ( buff , O_RDONLY | FILE_BINARY , MYF ( MY_WME ) ) ) ) die ( "Failed to open file '%s'" , buff ) ;\n<14> while ( embedded_server_arg_count < MAX_EMBEDDED_SERVER_ARGS && ( str = fgets ( argument , sizeof ( argument ) , file ) ) ) {\n<15> * ( strend ( str ) - 1 ) = 0 ;\n<17> my_fclose ( file , MYF ( 0 ) ) ;\n<22> my_fclose ( file , MYF ( 0 ) ) ;
<1> static void initialize_encoder ( struct stream_state * stream , struct VpxEncoderConfig * global ) {\n<14> if ( vpx_codec_control_ ( & stream -> encoder , ctrl , value ) ) fprintf ( stderr , "Error: Tried to set control %d = %d\n" , ctrl , value ) ;
<1> static SERVER_REC * line_get_server ( const char * line ) {\n<5> if ( * line != '-' ) return NULL ;\n<6> tag = g_strdup ( line + 1 ) ;\n<7> ptr = strchr ( tag , ' ' ) ;\n<8> if ( ptr != NULL ) * ptr = '\0' ;\n<9> server = server_find_tag ( tag ) ;
<1> static uint32_t hpet_ram_readl(void *opaque, target_phys_addr_t addr)\n<21> if (timer_id > HPET_NUM_TIMERS - 1) {\n<23> printf("qemu: timer id out of range\n");
<1> static int net_tap_init(VLANState *vlan, const char *model,\n<27> if (fd < 0)\n<33> if (!setup_script || !strcmp(setup_script, "no"))\n<35> setup_script = "";\n<37> if (setup_script[0] != '\0') {\n<39> if (launch_script(setup_script, ifname, fd))\n<47> if (!s)\n<51> snprintf(s->vc->info_str, sizeof(s->vc->info_str),\n<57> if (down_script && strcmp(down_script, "no")) {\n<59> snprintf(s->down_script, sizeof(s->down_script), "%s", down_script);\n<61> snprintf(s->down_script_arg, sizeof(s->down_script_arg), "%s", ifname);
<1> udp_input(register struct mbuf *m, int iphlen)\n<109> if (uh->uh_sum) {\n<111> memset(&((struct ipovly *)ip)->ih_mbuf, 0, sizeof(struct mbuf_ptr));\n<237> if(udp_attach(so) == -1) {\n<241> errno,strerror(errno)));\n<301> if(sosendto(so,m) == -1) {\n<309> DEBUG_MISC((dfd,"udp tx errno = %d-%s\n",errno,strerror(errno)));\n<311> icmp_error(m, ICMP_UNREACH,ICMP_UNREACH_NET, 0,strerror(errno));
<1> int tls_construct_new_session_ticket ( SSL * s ) {\n<10> SSL_CTX * tctx = s -> initial_ctx ;\n<38> if ( ! i2d_SSL_SESSION ( sess , & p ) ) {\n<46> int ret = tctx -> tlsext_ticket_key_cb ( s , key_name , iv , ctx , hctx , 1 ) ;\n<56> if ( ret < 0 ) goto err ;\n<57> iv_len = EVP_CIPHER_CTX_iv_length ( ctx ) ;\n<62> if ( RAND_bytes ( iv , iv_len ) <= 0 ) goto err ;\n<63> if ( ! EVP_EncryptInit_ex ( ctx , cipher , NULL , tctx -> tlsext_tick_aes_key , iv ) ) goto err ;\n<64> if ( ! HMAC_Init_ex ( hctx , tctx -> tlsext_tick_hmac_key , sizeof ( tctx -> tlsext_tick_hmac_key ) , EVP_sha256 ( ) , NULL ) ) goto err ;\n<65> memcpy ( key_name , tctx -> tlsext_tick_key_name , sizeof ( tctx -> tlsext_tick_key_name ) ) ;\n<68> p += 2 ;\n<70> memcpy ( p , key_name , sizeof ( key_name ) ) ;\n<71> p += sizeof ( key_name ) ;\n<72> memcpy ( p , iv , iv_len ) ;\n<73> p += iv_len ;
<1> static void truemotion1_decode_24bit ( TrueMotion1Context * s ) {\n<16> memset ( s -> vert_pred , 0 , s -> avctx -> width * sizeof ( unsigned int ) ) ;\n<23> vert_pred = s -> vert_pred ;
<1> int ffio_rewind_with_probe_data(AVIOContext *s, unsigned char *buf, int buf_size)\n<19> buffer_size = s->buf_end - s->buffer;\n<33> new_size = buf_size + buffer_size - overlap;\n<41> if (!(buf = av_realloc_f(buf, 1, alloc_size)))\n<47> if (new_size > buf_size) {\n<49> memcpy(buf + buf_size, s->buffer + overlap, buffer_size - overlap);
<1> static char * cover_definer_clause ( const char * stmt_str , size_t stmt_length , const char * definer_version_str , uint definer_version_length , const char * stmt_version_str , uint stmt_version_length , const char * keyword_str , uint keyword_length ) {\n<6> if ( ! definer_begin ) return NULL ;\n<7> definer_end = my_case_str ( definer_begin , strlen ( definer_begin ) , keyword_str , keyword_length ) ;\n<10> query_ptr = strnmov ( query_str , stmt_str , definer_begin - stmt_str ) ;
<1> static int kadmin_parse_policy_args ( int argc , char * argv [ ] , kadm5_policy_ent_t policy , long * mask , char * caller ) {\n<8> i < argc - 1 ;\n<9> i ++ ) {\n<10> if ( ! strcmp ( argv [ i ] , "-maxlife" ) ) {\n<11> if ( ++ i > argc - 2 ) return - 1 ;\n<12> date = get_date ( argv [ i ] ) ;\n<13> if ( date == ( time_t ) - 1 ) {\n<14> fprintf ( stderr , _ ( "Invalid date specification \"%s\".\n" ) , argv [ i ] ) ;\n<21> else if ( ! strcmp ( argv [ i ] , "-minlife" ) ) {\n<22> if ( ++ i > argc - 2 ) return - 1 ;\n<23> date = get_date ( argv [ i ] ) ;\n<24> if ( date == ( time_t ) - 1 ) {\n<25> fprintf ( stderr , _ ( "Invalid date specification \"%s\".\n" ) , argv [ i ] ) ;\n<32> else if ( ! strcmp ( argv [ i ] , "-minlength" ) ) {\n<33> if ( ++ i > argc - 2 ) return - 1 ;\n<34> policy -> pw_min_length = atoi ( argv [ i ] ) ;\n<38> else if ( ! strcmp ( argv [ i ] , "-minclasses" ) ) {\n<39> if ( ++ i > argc - 2 ) return - 1 ;\n<40> policy -> pw_min_classes = atoi ( argv [ i ] ) ;\n<44> else if ( ! strcmp ( argv [ i ] , "-history" ) ) {\n<45> if ( ++ i > argc - 2 ) return - 1 ;\n<46> policy -> pw_history_num = atoi ( argv [ i ] ) ;\n<50> else if ( strlen ( argv [ i ] ) == 11 && ! strcmp ( argv [ i ] , "-maxfailure" ) ) {\n<51> if ( ++ i > argc - 2 ) return - 1 ;\n<52> policy -> pw_max_fail = atoi ( argv [ i ] ) ;\n<56> else if ( strlen ( argv [ i ] ) == 21 && ! strcmp ( argv [ i ] , "-failurecountinterval" ) ) {\n<57> if ( ++ i > argc - 2 ) return - 1 ;\n<58> date = get_date ( argv [ i ] ) ;\n<60> else if ( isdigit ( * argv [ i ] ) ) policy -> pw_failcnt_interval = atoi ( argv [ i ] ) ;\n<62> fprintf ( stderr , _ ( "Invalid date specification \"%s\".\n" ) , argv [ i ] ) ;\n<68> else if ( strlen ( argv [ i ] ) == 16 && ! strcmp ( argv [ i ] , "-lockoutduration" ) ) {\n<69> if ( ++ i > argc - 2 ) return - 1 ;\n<70> date = get_date ( argv [ i ] ) ;\n<72> else if ( isdigit ( * argv [ i ] ) ) policy -> pw_lockout_duration = atoi ( argv [ i ] ) ;\n<74> fprintf ( stderr , _ ( "Invalid date specification \"%s\".\n" ) , argv [ i ] ) ;\n<80> else if ( ! strcmp ( argv [ i ] , "-allowedkeysalts" ) ) {\n<81> krb5_key_salt_tuple * ks_tuple = NULL ;\n<82> int n_ks_tuple = 0 ;\n<83> if ( ++ i > argc - 2 ) return - 1 ;\n<84> if ( strcmp ( argv [ i ] , "-" ) ) {\n<85> retval = krb5_string_to_keysalts ( argv [ i ] , "," , ":.-" , 0 , & ks_tuple , & n_ks_tuple ) ;\n<86> if ( retval ) {\n<90> free ( ks_tuple ) ;\n<93> * mask |= KADM5_POLICY_ALLOWED_KEYSALTS ;\n<96> else return - 1 ;\n<98> if ( i != argc - 1 ) {\n<99> fprintf ( stderr , _ ( "%s: parser lost count!\n" ) , caller ) ;
<1> int do_done ( struct st_command * command ) {\n<13> if ( * cur_block -> delim ) {\n<14> strcpy ( delimiter , cur_block -> delim ) ;\n<15> delimiter_length = strlen ( delimiter ) ;
<1> int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n<15> } else if (ret > 0) {\n<27> fprintf(stderr, "qcow2: Preventing invalid write on metadata (overlaps "
<1> static int matroska_parse_wavpack ( MatroskaTrack * track , uint8_t * src , uint8_t * * pdst , int * size ) {\n<7> int ret , offset = 0 ;\n<19> src += 8 ;\n<28> src += 4 ;\n<32> if ( blocksize > srclen ) {\n<37> if ( ! tmp ) {\n<41> dst = tmp ;\n<52> memcpy ( dst + offset + 32 , src , blocksize ) ;\n<53> src += blocksize ;\n<54> srclen -= blocksize ;\n<55> offset += blocksize + 32 ;
<7> FDKAACDecContext *s = avctx->priv_data;\n<63> if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n<69> memcpy(frame->extended_data[0], s->decoder_buffer,
<1> static int evhttp_parse_request_line ( struct evhttp_request * req , char * line ) {\n<5> method = strsep ( & line , " " ) ;\n<7> uri = strsep ( & line , " " ) ;\n<9> version = strsep ( & line , " " ) ;\n<10> if ( line != NULL ) return ( - 1 ) ;\n<11> if ( strcmp ( method , "GET" ) == 0 ) {\n<12> req -> type = EVHTTP_REQ_GET ;\n<14> else if ( strcmp ( method , "POST" ) == 0 ) {\n<15> req -> type = EVHTTP_REQ_POST ;\n<17> else if ( strcmp ( method , "HEAD" ) == 0 ) {\n<18> req -> type = EVHTTP_REQ_HEAD ;\n<21> event_debug ( ( "%s: bad method %s on request %p from %s" , __func__ , method , req , req -> remote_host ) ) ;\n<22> return ( - 1 ) ;\n<24> if ( strcmp ( version , "HTTP/1.0" ) == 0 ) {\n<25> req -> major = 1 ;\n<26> req -> minor = 0 ;\n<28> else if ( strcmp ( version , "HTTP/1.1" ) == 0 ) {\n<29> req -> major = 1 ;\n<30> req -> minor = 1 ;\n<33> event_debug ( ( "%s: bad version %s on request %p from %s" , __func__ , version , req , req -> remote_host ) ) ;\n<34> return ( - 1 ) ;\n<36> if ( ( req -> uri = strdup ( uri ) ) == NULL ) {\n<37> event_debug ( ( "%s: strdup" , __func__ ) ) ;\n<38> return ( - 1 ) ;\n<40> if ( strlen ( req -> uri ) > 0 && req -> uri [ 0 ] != '/' ) req -> flags |= EVHTTP_PROXY_REQUEST ;\n<41> return ( 0 ) ;
<1> FpPort *fp_port_alloc(Rocker *r, char *sw_name,\n<3> MACAddr *start_mac, unsigned int index,\n<13> if (!port) {\n<37> memcpy(port->conf.macaddr.a, start_mac, sizeof(port->conf.macaddr.a));
<1> void evhttp_connection_set_local_address ( struct evhttp_connection * evcon , const char * address ) {\n<3> if ( evcon -> bind_address ) free ( evcon -> bind_address ) ;\n<4> if ( ( evcon -> bind_address = strdup ( address ) ) == NULL ) event_err ( 1 , "%s: strdup" , __func__ ) ;
<1> int min_heap_reserve ( min_heap_t * s , unsigned n ) {\n<2> if ( s -> a < n ) {\n<6> if ( ! ( p = ( struct event * * ) realloc ( s -> p , a * sizeof * p ) ) ) return - 1 ;\n<7> s -> p = p ;\n<8> s -> a = a ;\n<10> return 0 ;
<1> static void vnc_write_pixels_generic(VncState *vs, void *pixels1, int size)\n<41> } else if (vs->depth == 1) {\n<59> fprintf(stderr, "vnc_write_pixels_generic: VncState color depth not supported\n");
<1> static void virtio_net_device_realize(DeviceState *dev, Error **errp)\n<76> qemu_macaddr_default_if_unset(&n->nic_conf.macaddr);\n<78> memcpy(&n->mac[0], &n->nic_conf.macaddr, sizeof(n->mac));
<1> static char * get_pid_environ_val ( pid_t pid , char * val ) {\n<2> int temp_size = 500 ;\n<3> char * temp = malloc ( temp_size ) ;\n<7> sprintf ( temp , "/proc/%d/environ" , pid ) ;\n<8> fp = fopen ( temp , "r" ) ;\n<13> if ( i >= temp_size ) {\n<14> temp_size *= 2 ;\n<15> temp = realloc ( temp , temp_size ) ;\n<17> temp [ i ] = fgetc ( fp ) ;\n<18> if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\0' || temp [ i ] == EOF ) ) {\n<20> temp [ i ] = 0 ;\n<21> ret = malloc ( strlen ( temp ) + 10 ) ;\n<22> sprintf ( ret , "%s" , temp ) ;\n<24> return ret ;\n<26> switch ( temp [ i ] ) {\n<29> case '=' : temp [ i ] = 0 ;\n<30> if ( ! strcmp ( temp , val ) ) {\n<31> foundit = 1 ;
<1> static void new_subtitle_stream(AVFormatContext *oc)\n<15> if (!st) {\n<17> fprintf(stderr, "Could not alloc stream\n");
<1> static void new_audio_stream(AVFormatContext *oc, int file_idx)\n<19> if (!st) {\n<21> fprintf(stderr, "Could not alloc stream\n");
<1> static int mp_decode_layer3 ( MPADecodeContext * s ) {\n<70> ff_compute_band_indexes ( s , g ) ;\n<78> if ( ! s -> adu_mode ) {\n<80> const uint8_t * ptr = s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) ;\n<81> int extrasize = av_clip ( get_bits_left ( & s -> gb ) >> 3 , 0 , FFMAX ( 0 , LAST_BUF_SIZE - s -> last_buf_size ) ) ;\n<83> av_dlog ( s -> avctx , "seekback:%d, lastbuf:%d\n" , main_data_begin , s -> last_buf_size ) ;\n<84> memcpy ( s -> last_buf + s -> last_buf_size , ptr , extrasize ) ;\n<93> ch < s -> nb_channels ;\n<95> g = & s -> granules [ ch ] [ gr ] ;\n<97> memset ( g -> sb_hybrid , 0 , sizeof ( g -> sb_hybrid ) ) ;\n<98> compute_imdct ( s , g , & s -> sb_samples [ ch ] [ 18 * gr ] [ 0 ] , s -> mdct_buf [ ch ] ) ;\n<243> exponents_from_scale_factors ( s , g , exponents ) ;\n<244> huffman_decode ( s , g , exponents , bits_pos + g -> part2_3_length ) ;\n<251> reorder_block ( s , g ) ;\n<252> compute_antialias ( s , g ) ;\n<253> compute_imdct ( s , g , & s -> sb_samples [ ch ] [ 18 * gr ] [ 0 ] , s -> mdct_buf [ ch ] ) ;
<1> static int flic_decode_frame_8BPP(AVCodecContext *avctx,\n<9> FlicDecodeContext *s = avctx->priv_data;\n<77> if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n<83> pixels = s->frame->data[0];\n<141> switch (chunk_type) {\n<223> if (s->palette[palette_ptr] != entry)\n<227> s->palette[palette_ptr++] = entry;\n<277> pixels[pixel_ptr] = line_packets & 0xff;\n<319> pixels[pixel_ptr++] = palette_idx2;\n<333> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<411> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<425> pixels[pixel_ptr++] = palette_idx1;\n<453> s->frame->linesize[0] * s->avctx->height);\n<504> pixels[pixel_ptr++] = palette_idx1;\n<528> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<644> memcpy(s->frame->data[1], s->palette, AVPALETTE_SIZE);
<1> char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n<3> length = strlen ( filename ) ;\n<4> if ( length > 1 ) {\n<5> if ( ( filename [ 0 ] == '\"' ) && ( filename [ length - 1 ] == '\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n<7> return strdup ( filename ) ;
<1> static int dnxhd_write_header(AVCodecContext *avctx, uint8_t *buf)\n<4> const uint8_t header_prefix[5] = { 0x00,0x00,0x02,0x80,0x01 };\n<5> memcpy(buf, header_prefix, 5);\n<9> AV_WB16(buf + 0x18, avctx->height); // ALPF\n<10> AV_WB16(buf + 0x1a, avctx->width);  // SPL\n<11> AV_WB16(buf + 0x1d, avctx->height); // NAL\n<14> AV_WB32(buf + 0x28, ctx->cid); // CID\n<18> AV_WB16(buf + 0x16a, ctx->m.mb_height * 4 + 4); // MSIPS\n<21> ctx->msip = buf + 0x170;
<1> static enum nss_status getanswer_r ( const querybuf * answer , int anslen , const char * qname , int qtype , struct hostent * result , char * buffer , size_t buflen , int * errnop , int * h_errnop , int map , int32_t * ttlp , char * * canonp ) {\n<50> bp = ( char * ) & host_data -> h_addr_ptrs [ ancount + 1 ] ;\n<53> if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n<57> if ( n > 0 && bp [ 0 ] == '.' ) bp [ 0 ] = '\0' ;\n<58> if ( __builtin_expect ( n < 0 || ( ( * name_ok ) ( bp ) == 0 && ( errno = EBADMSG ) ) , 0 ) ) {\n<64> if ( qtype == T_A || qtype == T_AAAA ) {\n<65> n = strlen ( bp ) + 1 ;\n<66> if ( n >= MAXHOSTNAMELEN ) {\n<71> result -> h_name = bp ;\n<72> bp += n ;\n<75> qname = result -> h_name ;\n<88> if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n<92> if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( bp ) == 0 ) ) {\n<116> n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n<117> if ( __glibc_unlikely ( n < 0 || ( * name_ok ) ( tbuf ) == 0 ) ) {\n<122> * ap ++ = bp ;\n<123> n = strlen ( bp ) + 1 ;\n<124> if ( __builtin_expect ( n , 0 ) >= MAXHOSTNAMELEN ) {\n<128> bp += n ;\n<130> n = strlen ( tbuf ) + 1 ;\n<131> if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n<137> bp = __mempcpy ( bp , tbuf , n ) ;\n<142> n = dn_expand ( answer -> buf , end_of_message , cp , tbuf , sizeof tbuf ) ;\n<143> if ( __glibc_unlikely ( n < 0 || res_dnok ( tbuf ) == 0 ) ) {\n<148> n = strlen ( tbuf ) + 1 ;\n<149> if ( __glibc_unlikely ( n > linebuflen ) ) goto too_small ;\n<154> tname = bp ;\n<155> bp = __mempcpy ( bp , tbuf , n ) ;\n<161> if ( ( _res . options & RES_USE_DNSSEC ) == 0 ) syslog ( LOG_NOTICE | LOG_AUTH , "gethostby*.getanswer: asked for \"%s %s %s\", " "got type \"%s\"" , qname , p_class ( C_IN ) , p_type ( qtype ) , p_type ( type ) ) ;\n<166> case T_PTR : if ( __glibc_unlikely ( strcasecmp ( tname , bp ) != 0 ) ) {\n<167> syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , qname , bp ) ;\n<172> if ( n != - 1 && __ns_name_ntop ( packtmp , bp , linebuflen ) == - 1 ) {\n<176> if ( __glibc_unlikely ( n < 0 || res_hnok ( bp ) == 0 ) ) {\n<181> if ( have_to_map ) {\n<182> n = strlen ( bp ) + 1 ;\n<183> if ( __glibc_unlikely ( n >= MAXHOSTNAMELEN ) ) {\n<187> bp += n ;\n<193> case T_A : case T_AAAA : if ( __builtin_expect ( strcasecmp ( result -> h_name , bp ) , 0 ) != 0 ) {\n<194> syslog ( LOG_NOTICE | LOG_AUTH , AskedForGot , result -> h_name , bp ) ;\n<202> if ( ! haveanswer ) {\n<207> nn = strlen ( bp ) + 1 ;\n<208> bp += nn ;\n<209> linebuflen -= nn ;\n<214> bp = __mempcpy ( * hap ++ = bp , cp , n ) ;\n<222> if ( haveanswer > 0 ) {\n<227> n = strlen ( qname ) + 1 ;\n<228> if ( n > linebuflen ) goto too_small ;\n<230> result -> h_name = bp ;\n<231> bp = __mempcpy ( bp , qname , n ) ;\n<234> if ( have_to_map ) if ( map_v4v6_hostent ( result , & bp , & linebuflen ) ) goto too_small ;
<1> static int aac_parse_packet(AVFormatContext *ctx, PayloadContext *data,\n<19> buf += data->au_headers_length_bytes + 2;\n<29> if ((ret = av_new_packet(pkt, data->au_headers[0].size)) < 0)\n<33> memcpy(pkt->data, buf, data->au_headers[0].size);
<1> static int iscsi_create(const char *filename, QEMUOptionParameter *options)\n<17> memset(&bs, 0, sizeof(BlockDriverState));\n<23> while (options && options->name) {\n<25> if (!strcmp(options->name, "size")) {\n<27> total_size = options->value.n / BDRV_SECTOR_SIZE;\n<31> options++;\n<47> ret = iscsi_open(&bs, bs_options, 0);\n<75> if (bs.total_sectors < total_size) {\n<95> g_free(bs.opaque);
<1> void curl_free ( void * p ) {\n<2> free ( p ) ;
<1> static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n<9> uint8_t *ptr = (uint8_t *)buf;\n<15> if (n->promisc)\n<21> if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n<23> int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n<25> if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n<33> if (ptr[0] & 1) { // multicast\n<35> if (!memcmp(ptr, bcast, sizeof(bcast))) {\n<37> return 1;\n<39> } else if (n->allmulti) {\n<47> if (!memcmp(ptr, n->mac, ETH_ALEN)) {\n<49> return 1;\n<57> for (i = 0; i < n->mac_table.in_use; i++) {\n<59> if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n<61> return 1;
<1> static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n<21> if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {\n<31> av_log(s, AV_LOG_DEBUG, "%s\n", buf);\n<35> if (strlen(buf) < 4)\n<41> err = 0;\n<43> for (i = 0; i < 3; ++i) {\n<45> if (buf[i] < '0' || buf[i] > '9')\n<51> err += buf[i] - '0';\n<55> dash = !!(buf[3] == '-');\n<59> for (i = 0; response_codes[i]; ++i) {\n<65> av_bprintf(&line_buffer, "%s", buf);
<1> static int decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<93> bitmap = sub->rects[0]->data[0];\n<96> if (y == (h + 1) / 2) bitmap = sub->rects[0]->data[0] + w;\n<97> for (x = 0; x < w; ) {\n<100> int color = get_bits(&gb, 2);\n<103> if (!run) run = w - x;\n<104> memset(bitmap, color, run);\n<105> bitmap += run;\n<106> x += run;\n<109> bitmap += w;
<9> j < junk -> cnt ;\n<14> if ( junk -> entries [ j ] [ i ] . type == ps_string || junk -> entries [ j ] [ i ] . type == ps_instr || junk -> entries [ j ] [ i ] . type == ps_lit ) free ( junk -> entries [ j ] [ i ] . u . str ) ;\n<16> free ( junk -> entries [ j ] ) ;
<1> static void handle_remote_ls_ctx ( struct xml_ctx * ctx , int tag_closed ) {\n<2> struct remote_ls_ctx * ls = ( struct remote_ls_ctx * ) ctx -> userData ;\n<3> if ( tag_closed ) {\n<4> if ( ! strcmp ( ctx -> name , DAV_PROPFIND_RESP ) && ls -> dentry_name ) {\n<5> if ( ls -> dentry_flags & IS_DIR ) {\n<6> str_end_url_with_slash ( ls -> dentry_name , & ls -> dentry_name ) ;\n<8> ls -> userFunc ( ls ) ;\n<10> if ( strcmp ( ls -> dentry_name , ls -> path ) && ls -> flags & RECURSIVE ) {\n<11> remote_ls ( ls -> dentry_name , ls -> flags , ls -> userFunc , ls -> userData ) ;\n<15> ls -> userFunc ( ls ) ;\n<18> else if ( ! strcmp ( ctx -> name , DAV_PROPFIND_NAME ) && ctx -> cdata ) {\n<19> char * path = ctx -> cdata ;\n<20> if ( * ctx -> cdata == 'h' ) {\n<21> path = strstr ( path , "//" ) ;\n<22> if ( path ) {\n<23> path = strchr ( path + 2 , '/' ) ;\n<26> if ( path ) {\n<29> if ( strncmp ( path , url , repo -> path_len ) ) error ( "Parsed path '%s' does not match url: '%s'" , path , url ) ;\n<36> else if ( ! strcmp ( ctx -> name , DAV_PROPFIND_COLLECTION ) ) {\n<37> ls -> dentry_flags |= IS_DIR ;\n<40> else if ( ! strcmp ( ctx -> name , DAV_PROPFIND_RESP ) ) {\n<41> free ( ls -> dentry_name ) ;\n<42> ls -> dentry_name = NULL ;\n<43> ls -> dentry_flags = 0 ;
<1> static int output_packet(AVInputStream *ist, int ist_index,\n<401> ost = ost_table[i];\n<437> ret = avcodec_encode_audio(enc, bit_buffer, VIDEO_BUFFER_SIZE, NULL);\n<447> ret = avcodec_encode_video(enc, bit_buffer, VIDEO_BUFFER_SIZE, NULL);\n<455> if (ost->logfile && enc->stats_out) {\n<457> fprintf(ost->logfile, "%s", enc->stats_out);
<1> static void test_ivshmem_single(void)\n<51> data[i] = i;\n<67> memset(data, 0, sizeof(data));
<1> void kadmin_purgekeys ( int argc , char * argv [ ] ) {\n<4> char * pname = NULL , * canon = NULL ;\n<6> if ( argc == 4 && strcmp ( argv [ 1 ] , "-keepkvno" ) == 0 ) {\n<7> keepkvno = atoi ( argv [ 2 ] ) ;\n<8> pname = argv [ 3 ] ;\n<11> pname = argv [ 1 ] ;\n<13> if ( pname == NULL ) {\n<14> fprintf ( stderr , _ ( "usage: purgekeys [-keepkvno oldest_kvno_to_keep] " "principal\n" ) ) ;\n<18> if ( retval ) {\n<22> retval = krb5_unparse_name ( context , princ , & canon ) ;\n<28> if ( retval ) {\n<29> com_err ( "purgekeys" , retval , _ ( "while purging keys for principal \"%s\"" ) , canon ) ;\n<32> printf ( _ ( "Old keys for principal \"%s\" purged.\n" ) , canon ) ;\n<34> free ( canon ) ;
<1> static int nuv_header(AVFormatContext *s)\n<19> avio_read(pb, id_string, 12);\n<21> is_mythtv = !memcmp(id_string, "MythTVVideo", 12);\n<141> get_codec_data(pb, vst, ast, is_mythtv);
<1> int _WriteType42SFNTS ( FILE * type42 , SplineFont * sf , enum fontformat format , int flags , EncMap * map , int layer ) {\n<11> memset ( & at , '\0' , sizeof ( struct alltabs ) ) ;\n<12> ATinit ( & at , sf , map , flags , layer , format , bf_none , NULL ) ;\n<15> if ( initTables ( & at , sf , format , NULL , bf_none ) ) dumptype42 ( type42 , & at , format ) ;\n<16> free ( at . gi . loca ) ;\n<18> if ( at . error || ferror ( type42 ) ) return ( 0 ) ;
<1> static size_t q_encoder ( char * str , const char * buf , size_t buflen , const char * tocode ) {\n<4> memcpy ( str , "=?" , 2 ) ;\n<5> str += 2 ;\n<6> memcpy ( str , tocode , strlen ( tocode ) ) ;\n<7> str += strlen ( tocode ) ;\n<8> memcpy ( str , "?Q?" , 3 ) ;\n<9> str += 3 ;\n<12> if ( c == ' ' ) * str ++ = '_' ;\n<13> else if ( ( c >= 0x7f ) || ( c < 0x20 ) || ( c == '_' ) || strchr ( MimeSpecials , c ) ) {\n<15> * str ++ = hex [ ( c & 0xf0 ) >> 4 ] ;\n<16> * str ++ = hex [ c & 0x0f ] ;\n<18> else * str ++ = c ;\n<20> memcpy ( str , "?=" , 2 ) ;\n<21> str += 2 ;
<1> static int nb_add_number ( char * * ret_buffer , size_t * ret_buffer_len , uint16_t type , uint64_t value ) {\n<9> if ( * ret_buffer_len < packet_len ) return ( ENOMEM ) ;\n<10> pkg_type = htons ( type ) ;\n<11> pkg_length = htons ( ( uint16_t ) packet_len ) ;\n<12> pkg_value = htonll ( value ) ;\n<13> packet_ptr = * ret_buffer ;\n<14> offset = 0 ;\n<15> memcpy ( packet_ptr + offset , & pkg_type , sizeof ( pkg_type ) ) ;\n<16> offset += sizeof ( pkg_type ) ;\n<17> memcpy ( packet_ptr + offset , & pkg_length , sizeof ( pkg_length ) ) ;\n<18> offset += sizeof ( pkg_length ) ;\n<19> memcpy ( packet_ptr + offset , & pkg_value , sizeof ( pkg_value ) ) ;
<5> tl = tl_data ;\n<6> tl_new = * out ;\n<8> tl ;\n<9> tl = tl -> tl_data_next , tl_new = tl_new -> tl_data_next ) {\n<10> tl_new -> tl_data_contents = malloc ( tl -> tl_data_length ) ;\n<11> if ( tl_new -> tl_data_contents == NULL ) return ENOMEM ;\n<12> memcpy ( tl_new -> tl_data_contents , tl -> tl_data_contents , tl -> tl_data_length ) ;\n<14> tl_new -> tl_data_length = tl -> tl_data_length ;
<1> void ber_init2 ( BerElement * ber , struct berval * bv , int options ) {\n<2> assert ( ber != NULL ) ;\n<3> ( void ) memset ( ( char * ) ber , '\0' , sizeof ( BerElement ) ) ;
<1> static relpRetVal relpTcpSetRemHost ( relpTcp_t * pThis , struct sockaddr * pAddr ) {\n<5> unsigned char szHname [ NI_MAXHOST ] = "" ;\n<9> RELPOBJ_assert ( pThis , Tcp ) ;\n<12> error = getnameinfo ( pAddr , SALEN ( pAddr ) , ( char * ) szIP , sizeof ( szIP ) , NULL , 0 , NI_NUMERICHOST ) ;\n<20> error = getnameinfo ( pAddr , SALEN ( pAddr ) , ( char * ) szHname , sizeof ( szHname ) , NULL , 0 , NI_NAMEREQD ) ;\n<21> if ( error == 0 ) {\n<22> memset ( & hints , 0 , sizeof ( struct addrinfo ) ) ;\n<25> if ( getaddrinfo ( ( char * ) szHname , NULL , & hints , & res ) == 0 ) {\n<28> pEngine -> dbgprint ( "Malicious PTR record, IP = \"%s\" HOST = \"%s\"" , szIP , szHname ) ;\n<39> len = strlen ( ( char * ) szIP ) + 1 ;\n<40> if ( ( pThis -> pRemHostIP = malloc ( len ) ) == NULL ) ABORT_FINALIZE ( RELP_RET_OUT_OF_MEMORY ) ;\n<41> memcpy ( pThis -> pRemHostIP , szIP , len ) ;\n<42> len = strlen ( ( char * ) szHname ) + 1 ;\n<43> if ( ( pThis -> pRemHostName = malloc ( len ) ) == NULL ) {\n<44> free ( pThis -> pRemHostIP ) ;\n<45> pThis -> pRemHostIP = NULL ;\n<46> ABORT_FINALIZE ( RELP_RET_OUT_OF_MEMORY ) ;\n<48> memcpy ( pThis -> pRemHostName , szHname , len ) ;
<1> static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb,\n<3> void *dst, const int type)\n<111> if (last && count < s->samples) {\n<115> memset((uint8_t*)dst + count*size, 0, (s->samples-count)*size);
<1> av_cold int ff_h264_decode_init(AVCodecContext *avctx)\n<51> memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));\n<53> memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));
<1> static void test_blk_write(BlockBackend *blk, long pattern, int64_t offset,\n<15> pattern_buf = g_malloc(count);\n<17> if (pattern) {\n<19> memset(pattern_buf, pattern, count);\n<23> memset(pattern_buf, 0x00, count);\n<31> qemu_iovec_add(&qiov, pattern_buf, count);
<1> static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)\n<9> MOVTrack *trk = &mov->tracks[pkt->stream_index];\n<11> AVCodecContext *enc = trk->enc;\n<39> len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n<65> if (trk->vosLen == 0 && enc->extradata_size > 0) {\n<69> trk->vosData = av_malloc(trk->vosLen);\n<71> memcpy(trk->vosData, enc->extradata, trk->vosLen);\n<77> if (enc->codec_id == CODEC_ID_H264 && trk->vosLen > 0 && *(uint8_t *)trk->vosData != 1) {\n<93> } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {\n<99> trk->vosData = av_malloc(size);\n<103> memcpy(trk->vosData, pkt->data, size);\n<125> trk->cluster[trk->entry].size = size;\n<159> mov->mdat_size += size;\n<163> put_buffer(pb, pkt->data, size);
<1> static void test_fetch_date ( ) {\n<5> char date [ 25 ] , my_time [ 25 ] , ts [ 25 ] , ts_4 [ 25 ] , ts_6 [ 20 ] , dt [ 20 ] ;\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> i < array_elements ( my_bind ) ;\n<63> ts_4 [ 0 ] = '\0' ;\n<66> if ( ! opt_silent ) {\n<67> fprintf ( stdout , "\n date : %s(%lu)" , date , d_length ) ;\n<68> fprintf ( stdout , "\n time : %s(%lu)" , my_time , t_length ) ;\n<69> fprintf ( stdout , "\n ts : %s(%lu)" , ts , ts_length ) ;\n<70> fprintf ( stdout , "\n year : %d(%lu)" , year , y_length ) ;\n<71> fprintf ( stdout , "\n dt : %s(%lu)" , dt , dt_length ) ;\n<72> fprintf ( stdout , "\n ts(4) : %s(%lu)" , ts_4 , ts4_length ) ;\n<73> fprintf ( stdout , "\n ts(6) : %s(%lu)" , ts_6 , ts6_length ) ;\n<75> DIE_UNLESS ( strcmp ( date , "2002-01-02" ) == 0 ) ;\n<76> DIE_UNLESS ( d_length == 10 ) ;\n<77> DIE_UNLESS ( strcmp ( my_time , "12:49:00" ) == 0 ) ;\n<78> DIE_UNLESS ( t_length == 8 ) ;\n<79> DIE_UNLESS ( strcmp ( ts , "2002-01-02 17:46:59" ) == 0 ) ;\n<80> DIE_UNLESS ( ts_length == 19 ) ;\n<81> DIE_UNLESS ( year == 2010 ) ;\n<82> DIE_UNLESS ( y_length == 4 ) ;\n<83> DIE_UNLESS ( strcmp ( dt , "2010-07-10 00:00:00" ) == 0 ) ;\n<84> DIE_UNLESS ( dt_length == 19 ) ;\n<85> DIE_UNLESS ( strcmp ( ts_4 , "0000-00-00 00:00:00" ) == 0 ) ;\n<86> DIE_UNLESS ( ts4_length == strlen ( "0000-00-00 00:00:00" ) ) ;\n<87> DIE_UNLESS ( strcmp ( ts_6 , "1999-12-29 00:00:00" ) == 0 ) ;\n<88> DIE_UNLESS ( ts6_length == 19 ) ;
<1> static void translation_buf_decode ( struct message_decoder_context * ctx , const unsigned char * * data , size_t * size ) {\n<2> unsigned char trans_buf [ CHARSET_MAX_PENDING_BUF_SIZE + 1 ] ;\n<5> memcpy ( trans_buf , ctx -> translation_buf , ctx -> translation_size ) ;\n<6> data_wanted = sizeof ( trans_buf ) - ctx -> translation_size ;\n<7> if ( data_wanted > * size ) data_wanted = * size ;\n<8> memcpy ( trans_buf + ctx -> translation_size , * data , data_wanted ) ;\n<9> orig_size = trans_size = ctx -> translation_size + data_wanted ;\n<10> ( void ) charset_to_utf8 ( ctx -> charset_trans , trans_buf , & trans_size , ctx -> buf2 ) ;\n<11> if ( trans_size <= ctx -> translation_size ) {\n<12> i_assert ( orig_size < CHARSET_MAX_PENDING_BUF_SIZE ) ;\n<13> memcpy ( ctx -> translation_buf , trans_buf , orig_size ) ;\n<14> ctx -> translation_size = orig_size ;\n<15> * data += * size ;\n<21> * data += skip ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> JvContext * s = avctx -> priv_data ;\n<11> if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n<27> int v = * buf ++ ;\n<29> j < avctx -> height ;\n<30> j ++ ) memset ( s -> frame . data [ 0 ] + j * s -> frame . linesize [ 0 ] , v , avctx -> width ) ;\n<42> s -> palette [ i ] = AV_RB24 ( buf ) << 2 ;\n<47> if ( video_size ) {\n<52> memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;
<1> int av_fifo_generic_read(AVFifoBuffer *f, int buf_size, void (*func)(void*, void*, int), void* dest)\n<5> int size = av_fifo_size(f);\n<15> int len = FFMIN(f->end - f->rptr, buf_size);\n<17> if(func) func(dest, f->rptr, len);\n<21> memcpy(dest, f->rptr, len);\n<23> dest = (uint8_t*)dest + len;\n<27> av_fifo_drain(f, len);
<1> static struct xfrm_state * pfkey_msg2xfrm_state ( struct net * net , const struct sadb_msg * hdr , void * const * ext_hdrs ) {\n<19> if ( key != NULL && sa -> sadb_sa_auth != SADB_X_AALG_NULL && ( ( key -> sadb_key_bits + 7 ) / 8 == 0 || ( key -> sadb_key_bits + 7 ) / 8 > key -> sadb_key_len * sizeof ( uint64_t ) ) ) return ERR_PTR ( - EINVAL ) ;\n<21> if ( key != NULL && sa -> sadb_sa_encrypt != SADB_EALG_NULL && ( ( key -> sadb_key_bits + 7 ) / 8 == 0 || ( key -> sadb_key_bits + 7 ) / 8 > key -> sadb_key_len * sizeof ( uint64_t ) ) ) return ERR_PTR ( - EINVAL ) ;\n<52> key = ext_hdrs [ SADB_EXT_KEY_AUTH - 1 ] ;\n<54> int keysize = 0 ;\n<60> if ( key ) keysize = ( key -> sadb_key_bits + 7 ) / 8 ;\n<65> if ( key ) {\n<67> memcpy ( x -> aalg -> alg_key , key + 1 , keysize ) ;\n<85> int keysize = 0 ;\n<91> key = ( struct sadb_key * ) ext_hdrs [ SADB_EXT_KEY_ENCRYPT - 1 ] ;\n<92> if ( key ) keysize = ( key -> sadb_key_bits + 7 ) / 8 ;\n<97> if ( key ) {\n<99> memcpy ( x -> ealg -> alg_key , key + 1 , keysize ) ;\n<130> if ( ! x -> encap ) goto out ;\n<131> natt = x -> encap ;\n<142> memset ( & natt -> encap_oa , 0 , sizeof ( natt -> encap_oa ) ) ;
<1> static void rv34_idct_add_c(uint8_t *dst, ptrdiff_t stride, DCTELEM *block){\n<11> rv34_row_transform(temp, block);\n<13> memset(block, 0, 16*sizeof(DCTELEM));
<1> static void test_combined ( void ) {\n<4> memset ( & r1 , 0 , sizeof ( r1 ) ) ;\n<5> memset ( & r2 , 0 , sizeof ( r2 ) ) ;\n<6> memset ( & w1 , 0 , sizeof ( w1 ) ) ;\n<7> memset ( & w2 , 0 , sizeof ( w2 ) ) ;\n<10> event_set ( & r1 . ev , pair [ 0 ] , EV_READ , combined_read_cb , & r1 ) ;\n<11> event_set ( & w1 . ev , pair [ 0 ] , EV_WRITE , combined_write_cb , & w1 ) ;\n<12> event_set ( & r2 . ev , pair [ 1 ] , EV_READ , combined_read_cb , & r2 ) ;\n<13> event_set ( & w2 . ev , pair [ 1 ] , EV_WRITE , combined_write_cb , & w2 ) ;\n<14> if ( event_add ( & r1 . ev , NULL ) == - 1 ) exit ( 1 ) ;\n<15> if ( event_add ( & w1 . ev , NULL ) ) exit ( 1 ) ;\n<16> if ( event_add ( & r2 . ev , NULL ) ) exit ( 1 ) ;\n<17> if ( event_add ( & w2 . ev , NULL ) ) exit ( 1 ) ;\n<19> if ( r1 . nread == 8192 && r2 . nread == 4096 ) test_ok = 1 ;
<1> void PPC_init_hw ( uint32_t mem_size , uint32_t kernel_addr , uint32_t kernel_size , uint32_t stack_addr , int boot_device , const unsigned char * initrd_file ) {\n<2> CPUPPCState * env = global_env ;\n<12> printf ( "Start address: 0x%08x\n" , env -> nip ) ;
<1> int qcow2_pre_write_overlap_check(BlockDriverState *bs, int chk, int64_t offset,\n<15> } else if (ret > 0) {\n<29> fprintf(stderr, "qcow2: Preventing invalid write on metadata (overlaps "
<1> ram_addr_t qemu_ram_alloc_from_ptr(DeviceState *dev, const char *name,\n<13> new_block = qemu_mallocz(sizeof(*new_block));\n<29> pstrcat(new_block->idstr, sizeof(new_block->idstr), name);\n<37> fprintf(stderr, "RAMBlock \"%s\" already registered, abort!\n",\n<122> QLIST_INSERT_HEAD(&ram_list.blocks, new_block, next);\n<126> ram_list.phys_dirty = qemu_realloc(ram_list.phys_dirty,\n<130> memset(ram_list.phys_dirty + (new_block->offset >> TARGET_PAGE_BITS),\n<132> 0xff, size >> TARGET_PAGE_BITS);
<1> void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n<23> for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n<25> if (!strcmp(vc->name, device))\n<31> if (!vc) {\n<33> monitor_printf(mon, "can't find device %s\n", device);\n<39> qemu_del_vlan_client(vc);
<1> int sd_do_command(SDState *sd, SDRequest *req,\n<3> uint8_t *response) {\n<39> if (!cmd_valid_while_locked(sd, req)) {\n<43> fprintf(stderr, "SD: Card is locked\n");\n<55> rtype = sd_app_command(sd, *req);\n<61> rtype = sd_normal_command(sd, *req);\n<69> switch (rtype) {\n<85> memcpy(response, sd->cid, sizeof(sd->cid));\n<95> memcpy(response, sd->csd, sizeof(sd->csd));
<1> static void mux_chr_update_read_handler(CharDriverState *chr,\n<13> if (d->mux_cnt >= MAX_MUX) {\n<15> fprintf(stderr, "Cannot add I/O handlers, MUX array is full\n");
<1> static int vp3_decode_frame(AVCodecContext *avctx,\n<13> Vp3DecodeContext *s = avctx->priv_data;\n<95> if (!s->all_fragments) {\n<145> init_loop_filter(s);\n<157> init_dequantizer(s, i);\n<185> if (s->keyframe) {\n<221> if (!s->golden_frame.f->data[0]) {\n<253> memset(s->all_fragments, 0, s->fragment_count * sizeof(Vp3Fragment));\n<259> if (unpack_superblocks(s, &gb)) {\n<267> if (unpack_modes(s, &gb)) {\n<275> if (unpack_vectors(s, &gb)) {\n<283> if (unpack_block_qpis(s, &gb)) {\n<291> if (unpack_dct_coeffs(s, &gb)) {\n<321> render_slice(s, i);\n<331> apply_loop_filter(s, i, row, row + 1);\n<335> vp3_draw_horiz_band(s, s->height);
<1> static int rtsp_listen(AVFormatContext *s)\n<31> if (!rt->protocols) {\n<35> if (!rt->protocols)\n<53> ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,\n<59> if (!strcmp(proto, "rtsps")) {\n<61> lower_proto  = "tls";\n<63> default_port = RTSPS_DEFAULT_PORT;
<1> static void bind_fetch ( int row_count ) {\n<11> char s_data [ 10 ] ;\n<12> ulong length [ 10 ] ;\n<18> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<20> i < ( int ) array_elements ( my_bind ) ;\n<73> while ( row_count -- ) {\n<76> if ( ! opt_silent ) {\n<77> fprintf ( stdout , "\n" ) ;\n<78> fprintf ( stdout , "\n tiny : %ld(%lu)" , ( ulong ) i8_data , length [ 0 ] ) ;\n<79> fprintf ( stdout , "\n short : %ld(%lu)" , ( ulong ) i16_data , length [ 1 ] ) ;\n<80> fprintf ( stdout , "\n int : %ld(%lu)" , ( ulong ) i32_data , length [ 2 ] ) ;\n<81> fprintf ( stdout , "\n longlong : %ld(%lu)" , ( ulong ) i64_data , length [ 3 ] ) ;\n<82> fprintf ( stdout , "\n float : %f(%lu)" , f_data , length [ 4 ] ) ;\n<83> fprintf ( stdout , "\n double : %g(%lu)" , d_data , length [ 5 ] ) ;\n<84> fprintf ( stdout , "\n char : %s(%lu)" , s_data , length [ 6 ] ) ;\n<88> DIE_UNLESS ( length [ 0 ] == 1 ) ;\n<91> DIE_UNLESS ( length [ 1 ] == 2 ) ;\n<94> DIE_UNLESS ( length [ 2 ] == 4 ) ;\n<97> DIE_UNLESS ( length [ 3 ] == 8 ) ;\n<99> DIE_UNLESS ( ( int ) f_data == rc ) ;\n<100> DIE_UNLESS ( length [ 4 ] == 4 ) ;\n<102> DIE_UNLESS ( ( int ) d_data == rc ) ;\n<103> DIE_UNLESS ( length [ 5 ] == 8 ) ;\n<104> rc += 13 ;\n<106> char buff [ 20 ] ;\n<107> long len = sprintf ( buff , "%d" , rc ) ;\n<108> DIE_UNLESS ( strcmp ( s_data , buff ) == 0 ) ;\n<109> DIE_UNLESS ( length [ 6 ] == ( ulong ) len ) ;
<1> static struct curl_httppost * AddHttpPost ( char * name , size_t namelength , char * value , size_t contentslength , char * buffer , size_t bufferlength , char * contenttype , long flags , struct curl_slist * contentHeader , char * showfilename , char * userp , struct curl_httppost * parent_post , struct curl_httppost * * httppost , struct curl_httppost * * last_post ) {\n<3> post = calloc ( 1 , sizeof ( struct curl_httppost ) ) ;\n<4> if ( post ) {\n<6> post -> namelength = ( long ) ( name ? ( namelength ? namelength : strlen ( name ) ) : 0 ) ;\n<19> parent_post -> more = post ;\n<22> if ( * last_post ) ( * last_post ) -> next = post ;\n<23> else ( * httppost ) = post ;\n<24> ( * last_post ) = post ;\n<26> return post ;
<1> static int parse_playlist(AppleHTTPContext *c, const char *url,\n<25> if (!in) {\n<39> read_chomp_line(in, line, sizeof(line));\n<41> if (strcmp(line, "#EXTM3U")) {\n<43> ret = AVERROR_INVALIDDATA;\n<51> if (var) {\n<59> while (!in->eof_reached) {\n<69> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n<75> } else if (av_strstart(line, "#EXT-X-KEY:", &ptr)) {\n<77> struct key_info info = {{0}};\n<79> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n<87> if (!strcmp(info.method, "AES-128"))\n<89> key_type = KEY_AES_128;\n<93> ff_hex_to_data(iv, info.iv + 2);\n<191> if (!seg) {\n<203> if (has_iv) {\n<205> memcpy(seg->iv, iv, sizeof(iv));\n<211> memset(seg->iv, 0, sizeof(seg->iv));\n<213> AV_WB32(seg->iv + 12, seq);\n<221> dynarray_add(&var->segments, &var->n_segments, seg);
<1> void archive_wstring_free ( struct archive_wstring * as ) {\n<4> free ( as -> s ) ;
<1> tdata_t _TIFFrealloc ( tdata_t p , tsize_t s ) {\n<2> return ( realloc ( p , ( size_t ) s ) ) ;
<1> static int request_parse ( u8 * packet , int length , struct evdns_server_port * port , struct sockaddr * addr , socklen_t addrlen ) {\n<14> if ( flags & 0x8000 ) return - 1 ;\n<16> server_req = malloc ( sizeof ( struct server_request ) ) ;\n<17> if ( server_req == NULL ) return - 1 ;\n<18> memset ( server_req , 0 , sizeof ( struct server_request ) ) ;\n<19> server_req -> trans_id = trans_id ;\n<20> memcpy ( & server_req -> addr , addr , addrlen ) ;\n<21> server_req -> addrlen = addrlen ;\n<24> server_req -> base . questions = malloc ( sizeof ( struct evdns_server_question * ) * questions ) ;\n<25> if ( server_req -> base . questions == NULL ) goto err ;\n<32> if ( name_parse ( packet , length , & j , tmp_name , sizeof ( tmp_name ) ) < 0 ) goto err ;\n<35> namelen = strlen ( tmp_name ) ;\n<36> q = malloc ( sizeof ( struct evdns_server_question ) + namelen ) ;\n<37> if ( ! q ) goto err ;\n<40> memcpy ( q -> name , tmp_name , namelen + 1 ) ;\n<41> server_req -> base . questions [ server_req -> base . nquestions ++ ] = q ;\n<46> evdns_server_request_respond ( & ( server_req -> base ) , DNS_ERR_NOTIMPL ) ;\n<49> port -> user_callback ( & ( server_req -> base ) , port -> user_data ) ;\n<51> err : if ( server_req ) {\n<52> if ( server_req -> base . questions ) {\n<54> i < server_req -> base . nquestions ;\n<55> ++ i ) free ( server_req -> base . questions [ i ] ) ;\n<56> free ( server_req -> base . questions ) ;\n<58> free ( server_req ) ;
<1> static void rawprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) {\n<6> if ( ! quiet ) ( void ) fprintf ( fp , "status=0x%04x,\n" , status ) ;\n<9> if ( cp == ( cpend - 1 ) || * ( cp + 1 ) != '\n' ) makeascii ( 1 , cp , fp ) ;\n<11> else if ( isspace ( ( unsigned char ) * cp ) || isprint ( ( unsigned char ) * cp ) ) putc ( * cp , fp ) ;\n<12> else makeascii ( 1 , cp , fp ) ;
<1> static void CopySFNTAndFixup ( FILE * ttc , FILE * ttf ) {\n<13> val = getushort ( ttf ) ;\n<24> val = getlong ( ttf ) ;\n<27> while ( ( val = getc ( ttf ) ) != EOF ) putc ( val , ttc ) ;\n<28> fclose ( ttf ) ;
<1> long do_rt_sigreturn(CPUState *env)\n<5> fprintf(stderr, "do_rt_sigreturn: not implemented\n");
<1> static int pubkey_get_nenc ( int algorithm ) {\n<7> if ( pubkey ) {\n<8> nenc = strlen ( ( ( gcry_pk_spec_t * ) pubkey -> spec ) -> elements_enc ) ;\n<12> return nenc ;
<1> static void cluster_one_database ( const char * dbname , bool verbose , const char * table , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo ) {\n<7> if ( table ) appendPQExpBuffer ( & sql , " %s" , table ) ;\n<12> if ( table ) fprintf ( stderr , _ ( "%s: clustering of table \"%s\" in database \"%s\" failed: %s" ) , progname , table , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;\n<13> else fprintf ( stderr , _ ( "%s: clustering of database \"%s\" failed: %s" ) , progname , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;
<1> void open_file ( const char * name ) {\n<15> if ( in_overlay || in_suiteir ) {\n<18> dirname_part ( buf2 , curname , & length ) ;\n<19> strxnmov ( buff , sizeof ( buff ) , opt_overlay_dir , suffix , name , NullS ) ;\n<20> if ( strcmp ( buff , curname ) && open_and_set_current ( buff ) ) DBUG_VOID_RETURN ;
<1> int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n<49> } else if (ret < 0) {\n<197> switch (access_type) {\n<227> printf("DSI: invalid exception (%d)\n", ret);
<1> static int dissect_btatt ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n<15> memset ( & uuid , 0 , sizeof uuid ) ;\n<160> proto_item_append_text ( sub_item , ", Handle: 0x%04x, UUID: %s" , handle , print_uuid ( & uuid ) ) ;\n<161> save_handle ( pinfo , uuid , handle , ATTRIBUTE_TYPE_OTHER , bluetooth_data ) ;\n<174> proto_item_append_text ( sub_item , ", Handle: 0x%04x, UUID: %s" , handle , print_uuid ( & uuid ) ) ;\n<175> save_handle ( pinfo , uuid , handle , ATTRIBUTE_TYPE_OTHER , bluetooth_data ) ;\n<192> dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , 0 , uuid , & att_data ) ;\n<197> request_parameters . read_by_type . uuid = uuid ;\n<273> case 0x0a : offset = dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , HANDLE_TVB ) ;\n<282> offset = dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , handle , uuid , & att_data ) ;\n<285> dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , request_data -> parameters . read_write . handle ) ;\n<288> if ( is_long_attribute_value ( uuid ) && tvb_captured_length ( tvb ) >= mtu ) {\n<297> offset = dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , handle , uuid , & att_data ) ;\n<300> case 0x0c : offset = dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , HANDLE_TVB ) ;\n<306> dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , 0 , handle , uuid , & att_data ) ;\n<315> dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , request_data -> parameters . read_write . handle ) ;\n<317> if ( request_data -> parameters . read_write . offset == 0 && ! is_long_attribute_value ( uuid ) ) {\n<318> offset = dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , request_data -> parameters . read_write . handle , uuid , & att_data ) ;\n<333> dissect_attribute_value ( sub_tree , NULL , pinfo , next_tvb , 0 , tvb_captured_length ( next_tvb ) , request_data -> parameters . read_write . handle , uuid , & att_data ) ;\n<354> offset = dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , HANDLE_TVB ) ;\n<357> dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , 0 , handle , uuid , & att_data ) ;\n<371> dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , request_data -> parameters . read_multiple . handle [ i_handle ] ) ;\n<372> offset = dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , request_data -> parameters . read_multiple . handle [ i_handle ] , uuid , & att_data ) ;\n<408> case 0x12 : case 0x1d : case 0x52 : case 0x1b : offset = dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , HANDLE_TVB ) ;\n<411> offset = dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , tvb_captured_length_remaining ( tvb , offset ) , tvb_get_guint16 ( tvb , offset - 2 , ENC_LITTLE_ENDIAN ) , uuid , & att_data ) ;\n<420> dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , request_data -> parameters . read_write . handle ) ;\n<421> dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , 0 , request_data -> parameters . read_write . handle , uuid , & att_data ) ;\n<425> case 0x16 : case 0x17 : offset = dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , HANDLE_TVB ) ;\n<447> dissect_attribute_value ( sub_tree , NULL , pinfo , next_tvb , 0 , tvb_captured_length ( next_tvb ) , request_data -> parameters . read_write . handle , uuid , & att_data ) ;\n<466> dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , request_data -> parameters . read_write . handle ) ;\n<468> dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , 0 , request_data -> parameters . read_write . handle , uuid , & att_data ) ;\n<473> offset = dissect_handle ( main_tree , pinfo , hf_btatt_handle , tvb , offset , bluetooth_data , & uuid , HANDLE_TVB ) ;\n<477> dissect_attribute_value ( main_tree , NULL , pinfo , tvb , offset , ( length > 12 ) ? length - 12 : 0 , handle , uuid , & att_data ) ;
<1> static void test_want_only_once ( void ) {\n<5> write ( pair [ 0 ] , TEST1 , strlen ( TEST1 ) + 1 ) ;
<1> static void video_refresh_timer(void *opaque)\n<197> if (!last_time || (cur_time - last_time) >= 30000) {\n<203> sqsize = 0;\n<215> sqsize = is->subtitleq.size;\n<217> av_diff = 0;\n<221> av_diff = get_audio_clock(is) - get_video_clock(is);\n<223> printf("%7.2f A-V:%7.3f aq=%5dKB vq=%5dKB sq=%5dB f=%Ld/%Ld   \r",\n<225> get_master_clock(is), av_diff, aqsize / 1024, vqsize / 1024, sqsize, is->faulty_dts, is->faulty_pts);
<1> static int selinux_inode_setotherxattr ( struct dentry * dentry , const char * name ) {\n<3> if ( ! strncmp ( name , XATTR_SECURITY_PREFIX , sizeof XATTR_SECURITY_PREFIX - 1 ) ) {\n<4> if ( ! strcmp ( name , XATTR_NAME_CAPS ) ) {\n<5> if ( ! capable ( CAP_SETFCAP ) ) return - EPERM ;\n<7> else if ( ! capable ( CAP_SYS_ADMIN ) ) {
<1> static void reset_coders ( MSS3Context * ctx , int quality ) {\n<4> i < 3 ;\n<22> memset ( ctx -> dct_coder [ i ] . prev_dc , 0 , sizeof ( * ctx -> dct_coder [ i ] . prev_dc ) * ctx -> dct_coder [ i ] . prev_dc_stride * ctx -> dct_coder [ i ] . prev_dc_height ) ;
<1> static int apply_color_indexing_transform(WebPContext *s)\n<31> line = av_malloc(img->frame->linesize[0]);\n<33> if (!line)\n<39> for (y = 0; y < img->frame->height; y++) {\n<41> p = GET_PIXEL(img->frame, 0, y);\n<43> memcpy(line, p, img->frame->linesize[0]);\n<45> init_get_bits(&gb_g, line, img->frame->linesize[0] * 8);\n<55> p[2] = get_bits(&gb_g, pixel_bits);
<1> static int set_wpa_key ( char * string ) {\n<7> if ( ! strncasecmp ( string , "pwd" , 3 ) ) {\n<8> if ( ( p = strchr ( string + + strlen ( "pwd" ) + 1 , ':' ) ) != NULL ) {\n<9> * p = 0 ;\n<12> SEMIFATAL_ERROR ( "Invalid parsing of the WPA password (missing SSID)" ) ;\n<14> i = strlen ( string + strlen ( "pwd" ) + 1 ) ;\n<15> if ( i < 8 || i > 63 ) {\n<18> SAFE_STRDUP ( pass , string + strlen ( "pwd" ) + 1 ) ;\n<19> SAFE_STRDUP ( ssid , p + 1 ) ;\n<20> PKCS5_PBKDF2_HMAC_SHA1 ( pass , strlen ( pass ) , ( u_char * ) ssid , strlen ( ssid ) , 4096 , 32 , GBL_WIFI -> wkey ) ;\n<21> SAFE_FREE ( pass ) ;\n<22> SAFE_FREE ( ssid ) ;\n<24> if ( ! strncasecmp ( string , "psk" , 3 ) ) {\n<25> if ( strlen ( string + strlen ( "psk" ) + 1 ) != 64 ) {\n<26> SEMIFATAL_ERROR ( "Invalid parsing of the WPA-PSK password (must be 64 chars)" ) ;\n<28> str_hex_to_bytes ( string + strlen ( "psk" ) + 1 , GBL_WIFI -> wkey ) ;\n<30> USER_MSG ( "Using WPA key: %s\n" , str_tohex ( GBL_WIFI -> wkey , WPA_KEY_LEN , tmp , sizeof ( tmp ) ) ) ;
<1> static int read_gab2_sub(AVStream *st, AVPacket *pkt) {\n<3> if (!strcmp(pkt->data, "GAB2") && AV_RL16(pkt->data+5) == 2) {\n<5> uint8_t desc[256];\n<7> int score = AVPROBE_SCORE_MAX / 2, ret;\n<9> AVIStream *ast = st->priv_data;\n<15> AVIOContext *pb = avio_alloc_context( pkt->data + 7,\n<17> pkt->size - 7,\n<23> unsigned int desc_len = avio_rl32(pb);\n<27> if (desc_len > pb->buf_end - pb->buf_ptr)\n<57> if (!(ast->sub_ctx = avformat_alloc_context()))\n<79> ast->sub_buffer = pkt->data;\n<81> memset(pkt, 0, sizeof(*pkt));\n<91> return 0;
<1> static void preprocess_text_hangul ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , hb_font_t * font ) {\n<13> if ( ! is_zero_width_char ( font , u ) ) {\n<14> hb_glyph_info_t * info = buffer -> out_info ;\n<16> memmove ( & info [ start + 1 ] , & info [ start ] , ( end - start ) * sizeof ( hb_glyph_info_t ) ) ;\n<17> info [ start ] = tone ;
<1> static int hyperv_handle_properties ( CPUState * cs ) {\n<12> if ( kvm_check_extension ( cs -> kvm_state , KVM_CAP_HYPERV_TIME ) <= 0 ) {\n<13> fprintf ( stderr , "Hyper-V clocksources " "(requested by 'hv-time' cpu flag) " "are not supported by kernel\n" ) ;\n<21> if ( ! has_msr_hv_frequencies ) {\n<22> fprintf ( stderr , "Hyper-V frequency MSRs " "(requested by 'hv-frequencies' cpu flag) " "are not supported by kernel\n" ) ;\n<29> if ( ! has_msr_hv_crash ) {\n<30> fprintf ( stderr , "Hyper-V crash MSRs " "(requested by 'hv-crash' cpu flag) " "are not supported by kernel\n" ) ;\n<36> if ( ! has_msr_hv_reenlightenment ) {\n<37> fprintf ( stderr , "Hyper-V Reenlightenment MSRs " "(requested by 'hv-reenlightenment' cpu flag) " "are not supported by kernel\n" ) ;\n<44> if ( ! has_msr_hv_reset ) {\n<45> fprintf ( stderr , "Hyper-V reset MSR " "(requested by 'hv-reset' cpu flag) " "is not supported by kernel\n" ) ;\n<51> if ( ! has_msr_hv_vpindex ) {\n<52> fprintf ( stderr , "Hyper-V VP_INDEX MSR " "(requested by 'hv-vpindex' cpu flag) " "is not supported by kernel\n" ) ;\n<58> if ( ! has_msr_hv_runtime ) {\n<59> fprintf ( stderr , "Hyper-V VP_RUNTIME MSR " "(requested by 'hv-runtime' cpu flag) " "is not supported by kernel\n" ) ;\n<65> if ( ! has_msr_hv_synic || kvm_vcpu_enable_cap ( cs , KVM_CAP_HYPERV_SYNIC , 0 ) ) {\n<66> fprintf ( stderr , "Hyper-V SynIC is not supported by kernel\n" ) ;\n<72> if ( ! has_msr_hv_stimer ) {\n<73> fprintf ( stderr , "Hyper-V timers aren't supported by kernel\n" ) ;
<1> static void _fill_ctld_conf ( slurm_ctl_conf_t * conf_ptr ) {\n<7> memset ( conf_ptr , 0 , sizeof ( slurm_ctl_conf_t ) ) ;\n<49> ext_sensors_g_get_config ( & conf_ptr -> ext_sensors_conf ) ;\n<158> select_g_get_info_from_plugin ( SELECT_CONFIG_INFO , NULL , & conf_ptr -> select_conf_key_pairs ) ;
<1> static int write_directory_descriptors ( struct archive_write * a , struct vdd * vdd ) {\n<12> extr != NULL ;\n<15> wb = wb_buffptr ( a ) ;\n<16> memcpy ( wb , extr -> buf , extr -> offset ) ;\n<17> memset ( wb + extr -> offset , 0 , LOGICAL_BLOCK_SIZE - extr -> offset ) ;
<1> static char *json_escape_str(const char *s)\n<5> static const char json_escape[] = {'"', '\\', '\b', '\f', '\n', '\r', '\t', 0};\n<17> for (i = 0; s[i]; i++) {\n<19> if (strchr(json_escape, s[i]))     len += 2; // simple escape\n<21> else if ((unsigned char)s[i] < 32) len += 6; // handle non-printable chars\n<35> for (i = 0; s[i]; i++) {\n<37> char *q = strchr(json_escape, s[i]);\n<43> *p++ = json_subst[q - json_escape];\n<45> } else if ((unsigned char)s[i] < 32) {\n<47> snprintf(p, 7, "\\u00%02x", s[i] & 0xff);\n<53> *p++ = s[i];
<1> const char * get_ext_sys_var ( const char * tag ) {\n<6> c = strlen ( tag ) ;\n<7> for ( v = ext_sys_var ;\n<8> ! ( EOV & v -> flags ) ;\n<9> v ++ ) {\n<10> if ( NULL != v -> text && ! memcmp ( tag , v -> text , c ) ) {\n<11> if ( '=' == v -> text [ c ] ) {\n<12> val = v -> text + c + 1 ;\n<15> else if ( '\0' == v -> text [ c ] ) {
<1> static int rle_unpack(const unsigned char *src, unsigned char *dest,\n<19> pd = dest;\n<23> *pd++ = *ps++;\n<33> l = *ps++;\n<37> l = (l & 0x7F) * 2;\n<39> if (pd + l > dest_end)\n<43> memcpy(pd, ps, l);\n<45> ps += l;\n<47> pd += l;\n<59> *pd++ = ps[1];\n<67> i += l;
<1> static void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n<15> char *base_core_type = spapr_get_cpu_core_type(machine->cpu_model);\n<17> const char *type = object_get_typename(OBJECT(dev));\n<25> if (dev->hotplugged && !mc->has_hotpluggable_cpus) {\n<35> if (strcmp(base_core_type, type)) {\n<37> error_setg(&local_err, "CPU core type should be %s", base_core_type);\n<45> if (cc->core_id % smp_threads) {\n<107> g_free(base_core_type);\n<109> error_propagate(errp, local_err);
<1> static __inline__ int TLV_SET ( void * tlv , __u16 type , void * data , __u16 len ) {\n<8> if ( len && data ) {\n<9> memcpy ( TLV_DATA ( tlv_ptr ) , data , len ) ;\n<10> memset ( TLV_DATA ( tlv_ptr ) + len , 0 , TLV_SPACE ( len ) - tlv_len ) ;
<1> PGconn * connectToServer ( ClusterInfo * cluster , const char * db_name ) {\n<3> if ( conn == NULL || PQstatus ( conn ) != CONNECTION_OK ) {\n<6> printf ( "Failure, exiting\n" ) ;
<1> static void log_btmp ( struct passwd const * pw ) {\n<5> memset ( & ut , 0 , sizeof ( ut ) ) ;\n<6> strncpy ( ut . ut_user , pw && pw -> pw_name ? pw -> pw_name : "(unknown)" , sizeof ( ut . ut_user ) ) ;\n<15> updwtmpx ( _PATH_BTMP , & ut ) ;
<1> int test_mul ( BIO * bp ) {\n<35> if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) {\n<36> fprintf ( stderr , "Multiplication test failed!\n" ) ;
<1> static int decode_format80(VqaContext *s, int src_size,\n<3> unsigned char *dest, int dest_size, int check_size) {\n<71> } else if (opcode == 0xFE) {\n<79> av_dlog(s->avctx, "(2) set %X bytes to %02X\n", count, color);\n<83> memset(&dest[dest_index], color, count);\n<85> dest_index += count;\n<121> bytestream2_get_buffer(&s->gb, &dest[dest_index], count);
<1> static void printusage ( struct xcmd * xcp , FILE * fp ) {\n<3> ( void ) fprintf ( fp , "usage: %s" , xcp -> keyword ) ;\n<7> if ( xcp -> arg [ i ] & OPT ) ( void ) fprintf ( fp , " [ %s ]" , xcp -> desc [ i ] ) ;\n<8> else ( void ) fprintf ( fp , " %s" , xcp -> desc [ i ] ) ;\n<10> ( void ) fprintf ( fp , "\n" ) ;
<2> const struct message_header_line * hdr = block -> hdr ;\n<11> if ( ( ctx -> update_ctx -> backend -> flags & FTS_BACKEND_FLAG_TOKENIZED_INPUT ) != 0 ) fts_build_tokenized_hdr_update_lang ( ctx , hdr ) ;\n<29> if ( fts_backend_update_set_build_key ( ctx -> update_ctx , & key ) ) {\n<30> if ( fts_build_data ( ctx , ( const void * ) hdr -> name , strlen ( hdr -> name ) , TRUE ) < 0 ) ret = - 1 ;
<1> static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n<23> if ( ! name ) {\n<27> if ( ! strcmp ( name , "flags" ) ) {\n<30> * ret_modern = 1 ;\n<31> for ( i = gcry_sexp_length ( l2 ) - 1 ;\n<32> i > 0 ;\n<33> i -- ) {\n<35> if ( ! s ) ;\n<36> else if ( n == 3 && ! memcmp ( s , "raw" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_RAW ;\n<37> else if ( n == 5 && ! memcmp ( s , "pkcs1" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n<38> else if ( n == 4 && ! memcmp ( s , "oaep" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n<39> else if ( n == 3 && ! memcmp ( s , "pss" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n<40> err = GPG_ERR_CONFLICT ;\n<43> else if ( n == 11 && ! memcmp ( s , "no-blinding" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n<45> err = GPG_ERR_INV_FLAG ;\n<64> s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n<65> if ( ! s ) err = GPG_ERR_NO_OBJ ;\n<67> ctx -> label = gcry_malloc ( n ) ;\n<68> if ( ! ctx -> label ) err = gpg_err_code_from_syserror ( ) ;\n<70> memcpy ( ctx -> label , s , n ) ;\n<71> ctx -> labellen = n ;\n<79> ( l2 = gcry_sexp_nth ( list , i ) ) != NULL ;\n<80> i ++ ) {\n<81> s = gcry_sexp_nth_data ( l2 , 0 , & n ) ;\n<82> if ( ! ( n == 9 && ! memcmp ( s , "hash-algo" , 9 ) ) && ! ( n == 5 && ! memcmp ( s , "label" , 5 ) ) && ! ( n == 15 && ! memcmp ( s , "random-override" , 15 ) ) ) break ;\n<83> gcry_sexp_release ( l2 ) ;\n<89> gcry_free ( name ) ;\n<99> ath_mutex_lock ( & pubkeys_registered_lock ) ;\n<100> module = gcry_pk_lookup_name ( name ) ;\n<101> ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n<102> if ( ! module ) {\n<107> elems = pubkey -> elements_enc ;\n<108> array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n<109> if ( ! array ) {\n<113> err = sexp_elements_extract ( list , elems , array , NULL , 0 ) ;\n<116> gcry_free ( name ) ;\n<122> gcry_free ( ctx -> label ) ;
<1> void check_command_args ( struct st_command * command , const char * arguments , const struct command_arg * args , int num_args , const char delimiter_arg ) {\n<12> switch ( arg -> type ) {\n<13> case ARG_STRING : while ( * ptr && * ptr == ' ' ) ptr ++ ;\n<16> if ( * ptr && strchr ( "'`\"" , * ptr ) ) {\n<17> delimiter = * ptr ;\n<18> start = ++ ptr ;\n<20> while ( * ptr && * ptr != delimiter ) ptr ++ ;
<1> QTestState *qtest_init_without_qmp_handshake(const char *extra_args)\n<9> qemu_binary = getenv("QTEST_QEMU_BINARY");\n<10> g_assert(qemu_binary != NULL);\n<18> if (s->qemu_pid == 0) {\n<27> getenv("QTEST_LOG") ? "/dev/fd/2" : "/dev/null",\n<44> if (getenv("QTEST_STOP")) {\n<45> kill(s->qemu_pid, SIGSTOP);
<1> static void usage ( ) {\n<2> fprintf ( stderr , _ ( "Usage: %s [-r realm] [-p principal] [-q query] " "[clnt|local args]\n" "\tclnt args: [-s admin_server[:port]] " "[[-c ccache]|[-k [-t keytab]]]|[-n]\n" "\tlocal args: [-x db_args]* [-d dbname] " "[-e \"enc:salt ...\"] [-m]\n" "where,\n\t[-x db_args]* - any number of database specific " "arguments.\n" "\t\t\tLook at each database documentation for supported " "arguments\n" ) , whoami ) ;
<1> int ApplyBinaryPatch ( const wchar_t * old_file , const wchar_t * patch_file , const wchar_t * new_file ) {\n<5> unsigned char * buf = NULL ;\n<7> if ( pfd < 0 ) return READ_ERROR ;\n<10> if ( ( ret = MBS_ReadHeader ( pfd , & header ) ) ) break ;\n<21> if ( os . st_size != header . slen ) {\n<25> buf = ( unsigned char * ) malloc ( header . slen ) ;\n<26> if ( ! buf ) {\n<30> if ( read ( ofd , buf , header . slen ) != header . slen ) {\n<34> if ( CalculateCrc ( buf , header . slen ) != header . scrc32 ) {\n<43> ret = MBS_ApplyPatch ( & header , pfd , buf , nfd ) ;\n<46> free ( buf ) ;
<7> ogg_stream_t *os = ogg->streams + idx;\n<21> if (os->seq == 0) {\n<25> if (!os->private)\n<37> priv->packet[os->seq] = av_mallocz(os->psize);\n<39> memcpy(priv->packet[os->seq], os->buf + os->pstart, os->psize);\n<67> vorbis_comment (s, os->buf + os->pstart + 7, os->psize - 8);
<1> static void flush_change ( H264Context * h ) {\n<15> memset ( h -> ref_list [ 0 ] , 0 , sizeof ( h -> ref_list [ 0 ] ) ) ;\n<16> memset ( h -> ref_list [ 1 ] , 0 , sizeof ( h -> ref_list [ 1 ] ) ) ;\n<17> memset ( h -> default_ref_list [ 0 ] , 0 , sizeof ( h -> default_ref_list [ 0 ] ) ) ;\n<18> memset ( h -> default_ref_list [ 1 ] , 0 , sizeof ( h -> default_ref_list [ 1 ] ) ) ;
<1> static void virtio_net_flush_tx(VirtIONet *n, VirtQueue *vq)\n<47> if (out_num < 1 || out_sg->iov_len != hdr_len) {\n<49> fprintf(stderr, "virtio-net header not in first element\n");
<1> static void purple_ui_init ( ) {\n<11> if ( getenv ( "BITLBEE_DEBUG" ) ) {\n<12> purple_debug_set_ui_ops ( & bee_debug_uiops ) ;
<1> static void nfs_client_close(NFSClient *client)\n<9> nfs_close(client->context, client->fh);\n<13> aio_set_fd_handler(client->aio_context, nfs_get_fd(client->context),\n<17> nfs_destroy_context(client->context);\n<21> memset(client, 0, sizeof(NFSClient));
<1> int qtest_init(void)\n<29> if (qtest_log) {\n<31> if (strcmp(qtest_log, "none") != 0) {\n<33> qtest_log_fp = fopen(qtest_log, "w+");
<9> static void png_handle_row(PNGDecContext *s)\n<101> png_filter_row(&s->dsp, s->tmp_row, s->crow_buf[0], s->crow_buf + 1,\n<115> png_put_interlaced_row(ptr, s->cur_w, s->bits_per_pixel, s->pass,\n<123> if (s->y == s->cur_h) {\n<125> memset(s->last_row, 0, s->row_size);
<1> int _PyString_Eq ( PyObject * o1 , PyObject * o2 ) {\n<4> return Py_SIZE ( a ) == Py_SIZE ( b ) && memcmp ( a -> ob_sval , b -> ob_sval , Py_SIZE ( a ) ) == 0 ;
<1> static int dxa_read_packet(AVFormatContext *s, AVPacket *pkt)\n<11> uint8_t buf[DXA_EXTRA_SIZE], pal[768+4];\n<13> int pal_size = 0;\n<45> avio_read(s->pb, buf, 4);\n<47> switch(AV_RL32(buf)){\n<51> if(av_new_packet(pkt, 4 + pal_size) < 0)\n<57> if(pal_size) memcpy(pkt->data, pal, pal_size);\n<59> memcpy(pkt->data + pal_size, buf, 4);\n<71> pal_size = 768+4;\n<73> memcpy(pal, buf, 4);\n<75> avio_read(s->pb, pal + 4, 768);\n<81> avio_read(s->pb, buf + 4, DXA_EXTRA_SIZE - 4);\n<93> if(av_new_packet(pkt, size + DXA_EXTRA_SIZE + pal_size) < 0)\n<97> memcpy(pkt->data + pal_size, buf, DXA_EXTRA_SIZE);\n<99> ret = avio_read(s->pb, pkt->data + DXA_EXTRA_SIZE + pal_size, size);\n<109> if(pal_size) memcpy(pkt->data, pal, pal_size);
<9> frag = ( hm_fragment * ) item -> data ;\n<15> frag = NULL ;\n<24> if ( al == 0 ) {\n<25> unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n<26> memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n<28> dtls1_hm_fragment_free ( frag ) ;
<1> static void indent ( int32_t count , FILE * f ) {\n<2> char c [ BUF_SIZE ] ;\n<6> if ( count < BUF_SIZE ) {\n<7> memset ( c , ( int ) ' ' , count ) ;\n<8> fwrite ( c , sizeof ( char ) , count , f ) ;
<1> static void http_chunked_trickle_cb ( int fd , short events , void * arg ) {\n<3> struct chunk_req_state * state = arg ;\n<10> if ( ++ state -> i < sizeof ( CHUNKS ) / sizeof ( CHUNKS [ 0 ] ) ) {\n<14> evhttp_send_reply_end ( state -> req ) ;\n<15> free ( state ) ;
<1> static void isofile_free_hardlinks ( struct iso9660 * iso9660 ) {\n<4> n ;\n<6> next = __archive_rb_tree_iterate ( & ( iso9660 -> hardlink_rbtree ) , n , ARCHIVE_RB_DIR_RIGHT ) ;\n<7> free ( n ) ;
<1> static uint16_t * invert_lut ( uint16_t * table , int length , size_t out_length ) {\n<5> uint16_t * output = malloc ( sizeof ( uint16_t ) * out_length ) ;\n<6> if ( ! output ) return NULL ;
<1> int c_main ( UFILE * out ) {\n<17> printf ( "** C Case Mapping Sample\n" ) ;
<1> int nbd_receive_negotiate(QIOChannel *ioc, const char *name,\n<47> if (nbd_read(ioc, buf, 8, errp) < 0) {\n<57> buf[8] = '\0';\n<59> if (strlen(buf) == 0) {\n<61> error_setg(errp, "Server connection closed unexpectedly");\n<69> magic = ldq_be_p(buf);\n<71> trace_nbd_receive_negotiate_magic(magic);\n<75> if (memcmp(buf, "NBDMAGIC", 8) != 0) {\n<77> error_setg(errp, "Invalid magic received");\n<85> if (nbd_read(ioc, &magic, sizeof(magic), errp) < 0) {\n<369> return rc;
<1> static int flic_decode_frame_8BPP(AVCodecContext *avctx,\n<5> uint8_t *buf, int buf_size)\n<9> FlicDecodeContext *s = (FlicDecodeContext *)avctx->priv_data;\n<79> if (avctx->reget_buffer(avctx, &s->frame) < 0) {\n<89> pixels = s->frame.data[0];\n<95> frame_size = LE_32(&buf[stream_ptr]);\n<113> chunk_size = LE_32(&buf[stream_ptr]);\n<117> chunk_type = LE_16(&buf[stream_ptr]);\n<123> switch (chunk_type) {\n<201> if (s->palette[palette_ptr] != entry)\n<205> s->palette[palette_ptr++] = entry;\n<233> compressed_lines = LE_16(&buf[stream_ptr]);\n<239> line_packets = LE_16(&buf[stream_ptr]);\n<255> pixel_countdown = s->avctx->width;\n<283> pixels[pixel_ptr++] = palette_idx2;\n<295> pixels[pixel_ptr++] = palette_idx1;\n<319> starting_line = LE_16(&buf[stream_ptr]);\n<337> pixel_countdown = s->avctx->width;\n<363> pixels[pixel_ptr++] = palette_idx1;\n<377> pixels[pixel_ptr++] = palette_idx1;\n<405> s->frame.linesize[0] * s->avctx->height);\n<429> pixel_countdown = s->avctx->width;\n<443> pixels[pixel_ptr++] = palette_idx1;\n<465> pixels[pixel_ptr++] = palette_idx1;\n<495> if (chunk_size - 6 > s->avctx->width * s->avctx->height) {\n<505> for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;\n<513> stream_ptr += s->avctx->width;\n<565> memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);
<1> static void versatile_init(ram_addr_t ram_size,\n<41> if (!env) {\n<43> fprintf(stderr, "Unable to find CPU definition\n");\n<103> for(n = 0; n < nb_nics; n++) {\n<105> nd = &nd_table[n];\n<109> if ((!nd->model && !done_smc) || strcmp(nd->model, "smc91c111") == 0) {\n<111> smc91c111_init(nd, 0x10010000, sic[25]);\n<113> done_smc = 1;\n<117> pci_nic_init_nofail(nd, "rtl8139", NULL);
<1> int unix_start_incoming_migration(const char *path)\n<17> if (sock < 0) {\n<19> fprintf(stderr, "Could not open unix socket: %s\n", strerror(errno));\n<27> memset(&un, 0, sizeof(un));\n<37> if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n<39> fprintf(stderr, "bind(unix:%s): %s\n", un.sun_path, strerror(errno));\n<45> if (listen(sock, 1) < 0) {\n<47> fprintf(stderr, "listen(unix:%s): %s\n", un.sun_path, strerror(errno));
<1> static void xml_end_tag ( void * userData , const char * name ) {\n<3> const char * c = strchr ( name , ':' ) ;\n<5> ctx -> userFunc ( ctx , 1 ) ;\n<6> if ( c == NULL ) c = name ;\n<7> else c ++ ;\n<8> ep = ctx -> name + strlen ( ctx -> name ) - strlen ( c ) - 1 ;
<1> int ff_h264_alloc_tables ( H264Context * h ) {\n<5> FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> intra4x4_pred_mode , row_mb_num * 8 * sizeof ( uint8_t ) , fail ) FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> non_zero_count , big_mb_num * 48 * sizeof ( uint8_t ) , fail ) FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> slice_table_base , ( big_mb_num + h -> mb_stride ) * sizeof ( * h -> slice_table_base ) , fail ) FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> cbp_table , big_mb_num * sizeof ( uint16_t ) , fail ) FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> chroma_pred_mode_table , big_mb_num * sizeof ( uint8_t ) , fail ) FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> mvd_table [ 0 ] , * row_mb_num * sizeof ( uint8_t ) , fail ) ;\n<8> FF_ALLOCZ_OR_GOTO ( h -> avctx , h -> list_counts , big_mb_num * sizeof ( uint8_t ) , fail ) memset ( h -> slice_table_base , - 1 , ( big_mb_num + h -> mb_stride ) * sizeof ( * h -> slice_table_base ) ) ;\n<9> h -> slice_table = h -> slice_table_base + h -> mb_stride * 2 + 1 ;\n<22> if ( ! h -> dequant4_coeff [ 0 ] ) init_dequant_tables ( h ) ;
<1> static void http_chunked_request_done ( struct evhttp_request * req , void * arg ) {\n<2> if ( req -> response_code != HTTP_OK ) {\n<3> fprintf ( stderr , "FAILED\n" ) ;\n<6> if ( evhttp_find_header ( req -> input_headers , "Transfer-Encoding" ) == NULL ) {\n<7> fprintf ( stderr , "FAILED\n" ) ;\n<10> if ( EVBUFFER_LENGTH ( req -> input_buffer ) != 13 + 18 + 8 ) {\n<11> fprintf ( stderr , "FAILED\n" ) ;\n<14> if ( strncmp ( ( char * ) EVBUFFER_DATA ( req -> input_buffer ) , "This is funnybut not hilarious.bwv 1052" , + 18 + 8 ) ) {\n<15> fprintf ( stderr , "FAILED\n" ) ;
<1> static int net_vhost_chardev_opts(void *opaque,\n<3> const char *name, const char *value,\n<13> if (strcmp(name, "backend") == 0 && strcmp(value, "socket") == 0) {\n<15> props->is_socket = true;\n<17> } else if (strcmp(name, "path") == 0) {\n<19> props->is_unix = true;\n<21> } else if (strcmp(name, "server") == 0) {\n<31> return -1;\n<35> return 0;
<1> static int read_access_unit(AVCodecContext *avctx, void* data, int *data_size,\n<11> MLPDecodeContext *m = avctx->priv_data;\n<55> if (read_major_sync(m, &gb) < 0)\n<203> for (substr = 0; substr <= m->max_decoded_substream; substr++) {\n<213> memset(m->filter_changed, 0, sizeof(m->filter_changed));\n<227> if (read_restart_header(m, &gb, buf, substr) < 0)\n<241> if (read_decoding_params(m, &gb, substr) < 0)\n<255> if (read_block_data(m, &gb, substr) < 0)\n<359> rematrix_channels(m, m->max_decoded_substream);\n<363> if (output_data(m, m->max_decoded_substream, data, data_size) < 0)
<1> static void kq_dealloc ( struct event_base * base , void * arg ) {\n<2> struct kqop * kqop = arg ;\n<4> if ( kqop -> changes ) free ( kqop -> changes ) ;\n<5> if ( kqop -> events ) free ( kqop -> events ) ;\n<6> if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;\n<7> memset ( kqop , 0 , sizeof ( struct kqop ) ) ;\n<8> free ( kqop ) ;
<1> struct event_base * event_base_new ( void ) {\n<4> if ( ( base = calloc ( 1 , sizeof ( struct event_base ) ) ) == NULL ) event_err ( 1 , "%s: calloc" , __func__ ) ;\n<5> event_sigcb = NULL ;\n<7> gettime ( base , & base -> event_tv ) ;\n<12> base -> evbase = NULL ;\n<17> base -> evbase = base -> evsel -> init ( base ) ;\n<19> if ( base -> evbase == NULL ) event_errx ( 1 , "%s: no event mechanism available" , __func__ ) ;\n<21> event_base_priority_init ( base , 1 ) ;\n<22> return ( base ) ;
<1> static struct evhttp_cb * evhttp_dispatch_callback ( struct httpcbq * callbacks , struct evhttp_request * req ) {\n<4> char * p = strchr ( req -> uri , '?' ) ;\n<5> if ( p != NULL ) offset = ( size_t ) ( p - req -> uri ) ;\n<6> TAILQ_FOREACH ( cb , callbacks , next ) {\n<8> if ( p == NULL ) {\n<9> res = strcmp ( cb -> what , req -> uri ) == 0 ;\n<12> res = ( ( strncmp ( cb -> what , req -> uri , offset ) == 0 ) && ( cb -> what [ offset ] == '\0' ) ) ;\n<14> if ( res ) return ( cb ) ;
<1> static int vfio_initfn(PCIDevice *pdev)\n<5> VFIODevice *pvdev, *vdev = DO_UPCAST(VFIODevice, pdev, pdev);\n<9> char path[PATH_MAX], iommu_group_path[PATH_MAX], *group_name;\n<31> if (stat(path, &st) < 0) {\n<41> strncat(path, "iommu_group", sizeof(path) - strlen(path) - 1);\n<45> len = readlink(path, iommu_group_path, PATH_MAX);\n<47> if (len <= 0) {\n<59> group_name = basename(iommu_group_path);\n<63> if (sscanf(group_name, "%d", &groupid) != 1) {\n<65> error_report("vfio: error reading %s: %m", path);\n<67> return -errno;\n<73> DPRINTF("%s(%04x:%02x:%02x.%x) group %d\n", __func__, vdev->host.domain,\n<75> vdev->host.bus, vdev->host.slot, vdev->host.function, groupid);\n<79> group = vfio_get_group(groupid);\n<81> if (!group) {\n<83> error_report("vfio: failed to get group %d", groupid);\n<123> ret = vfio_get_device(group, path, vdev);\n<145> if (ret < (int)MIN(pci_config_size(&vdev->pdev), vdev->config_size)) {\n<159> vdev->emulated_config_bits = g_malloc0(vdev->config_size);\n<165> memset(vdev->emulated_config_bits + PCI_ROM_ADDRESS, 0xff, 4);\n<201> memset(&vdev->pdev.config[PCI_BASE_ADDRESS_0], 0, 24);\n<203> memset(&vdev->pdev.config[PCI_ROM_ADDRESS], 0, 4);\n<225> ret = vfio_add_capabilities(vdev);\n<237> if (pdev->cap_present & QEMU_PCI_CAP_MSIX) {\n<239> memset(vdev->emulated_config_bits + pdev->msix_cap, 0xff,\n<247> if (pdev->cap_present & QEMU_PCI_CAP_MSI) {\n<249> memset(vdev->emulated_config_bits + pdev->msi_cap, 0xff,\n<265> ret = vfio_enable_intx(vdev);\n<279> vfio_register_err_notifier(vdev);\n<291> vfio_teardown_msi(vdev);\n<293> vfio_unmap_bars(vdev);\n<299> vfio_put_device(vdev);
<1> static int decode_audio_block ( AC3DecodeContext * s , int blk ) {\n<120> if ( s -> eac3 ? s -> cpl_strategy_exists [ blk ] : get_bits1 ( gbc ) ) {\n<121> memset ( bit_alloc_stages , 3 , AC3_MAX_CHANNELS ) ;\n<234> if ( s -> exp_strategy [ blk ] [ ch ] != EXP_REUSE ) bit_alloc_stages [ ch ] = 3 ;\n<255> if ( blk > 0 && s -> end_freq [ ch ] != prev ) memset ( bit_alloc_stages , 3 , AC3_MAX_CHANNELS ) ;\n<282> ch ++ ) bit_alloc_stages [ ch ] = FFMAX ( bit_alloc_stages [ ch ] , 2 ) ;\n<299> bit_alloc_stages [ ch ] = FFMAX ( bit_alloc_stages [ ch ] , 1 ) ;\n<305> if ( blk && prev != s -> fast_gain [ ch ] ) bit_alloc_stages [ ch ] = FFMAX ( bit_alloc_stages [ ch ] , 2 ) ;\n<320> if ( blk && prev != s -> fast_gain [ ch ] ) bit_alloc_stages [ ch ] = FFMAX ( bit_alloc_stages [ ch ] , 2 ) ;\n<336> bit_alloc_stages [ CPL_CH ] = FFMAX ( bit_alloc_stages [ CPL_CH ] , 2 ) ;\n<356> bit_alloc_stages [ ch ] = FFMAX ( bit_alloc_stages [ ch ] , 2 ) ;\n<370> bit_alloc_stages [ ch ] = FFMAX ( bit_alloc_stages [ ch ] , 2 ) ;\n<384> if ( bit_alloc_stages [ ch ] > 2 ) {\n<387> if ( bit_alloc_stages [ ch ] > 1 ) {\n<393> if ( bit_alloc_stages [ ch ] > 0 ) {
<1> int _TIFFmemcmp ( const tdata_t p1 , const tdata_t p2 , tsize_t c ) {\n<2> return ( memcmp ( p1 , p2 , ( size_t ) c ) ) ;
<1> static unsigned int psk_server_cb ( SSL * ssl , const char * identity , unsigned char * psk , unsigned int max_psk_len ) {\n<6> if ( ! identity ) {\n<10> if ( s_debug ) BIO_printf ( bio_s_out , "identity_len=%d identity=%s\n" , ( int ) strlen ( identity ) , identity ) ;\n<11> if ( strcmp ( identity , psk_identity ) != 0 ) {\n<12> BIO_printf ( bio_s_out , "PSK error: client identity not found" " (got '%s' expected '%s')\n" , identity , psk_identity ) ;\n<15> if ( s_debug ) BIO_printf ( bio_s_out , "PSK client identity found\n" ) ;\n<16> ret = BN_hex2bn ( & bn , psk_key ) ;\n<17> if ( ! ret ) {\n<33> out_err : if ( s_debug ) BIO_printf ( bio_err , "Error in PSK server callback\n" ) ;\n<34> return 0 ;
<1> static void test_multi ( ) {\n<6> int32 param = 1 ;\n<9> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<38> rc = mysql_stmt_bind_param ( stmt_update , my_bind ) ;\n<42> if ( ! opt_silent ) fprintf ( stdout , "update %ld\n" , ( long ) param ) ;\n<45> if ( ! opt_silent ) fprintf ( stdout , "delete %ld\n" , ( long ) param ) ;\n<54> param ++ ;
<1> xmlHashTablePtr xmlHashCreate ( int size ) {\n<4> table = xmlMalloc ( sizeof ( xmlHashTable ) ) ;\n<9> table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n<10> if ( table -> table ) {\n<11> memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n<15> xmlFree ( table ) ;
<1> static int showspectrumpic_request_frame(AVFilterLink *outlink)\n<7> ShowSpectrumContext *s = ctx->priv;\n<65> for (ch = 0; ch < s->nb_display_channels; ch++) {\n<67> memset(fin->extended_data[ch] + ret * sizeof(float), 0,\n<69> (s->win_size - ret) * sizeof(float));\n<79> acalc_magnitudes(s);\n<91> scale_magnitudes(s, 1. / (consumed / spf));\n<99> for (ch = 0; ch < s->nb_display_channels; ch++)\n<101> memset(s->magnitudes[ch], 0, h * sizeof(float));\n<111> s->outpicref->pts = 0;\n<125> drawtext(s->outpicref, 2, outlink->h - 10, "CREATED BY LIBAVFILTER", 0);\n<145> dst[s->start_x - 1] = 200;\n<161> dst[s->start_x - 2] = 200;\n<171> dst[s->start_x - 3] = 200;\n<177> dst = s->outpicref->data[0] + (s->start_y - 2) * s->outpicref->linesize[0] + s->start_x;\n<221> if (!units)\n<227> drawtext(s->outpicref, s->start_x - 8 * strlen(units) - 4, h * (ch + 1) + s->start_y - y - 4, units, 0);\n<229> av_free(units);\n<237> for (x = 0; x < s->w; x+=80) {\n<245> if (x == 0)\n<261> if (!units)\n<267> drawtext(s->outpicref, s->start_x + x - 4 * strlen(units), s->h + s->start_y + 6, units, 0);\n<269> drawtext(s->outpicref, s->start_x + x - 4 * strlen(units), s->start_y - 12, units, 0);\n<277> drawtext(s->outpicref, outlink->w / 2 - 4 * 4, outlink->h - s->start_y / 2, "TIME", 0);\n<279> drawtext(s->outpicref, s->start_x / 7, outlink->h / 2 - 14 * 4, "FREQUENCY (Hz)", 1);\n<283> int w = s->mode == SEPARATE ? s->w / s->nb_display_channels : s->w;\n<289> dst[s->start_x - 2] = 200;\n<299> dst[s->start_x - 3] = 200;\n<307> dst = s->outpicref->data[0] + (s->start_y - 2) * s->outpicref->linesize[0] + s->start_x + w * ch;\n<337> float hertz = x * (inlink->sample_rate / 2) / (float)(1 << (int)ceil(log2(w)));\n<351> if (!units)\n<357> drawtext(s->outpicref, s->start_x - 4 * strlen(units) + x + w * ch, s->start_y - 12, units, 0);\n<359> drawtext(s->outpicref, s->start_x - 4 * strlen(units) + x + w * ch, s->h + s->start_y + 6, units, 0);\n<361> av_free(units);\n<391> if (!units)\n<397> drawtext(s->outpicref, s->start_x - 8 * strlen(units) - 4, s->start_y + y - 4, units, 0);\n<399> av_free(units);\n<403> drawtext(s->outpicref, s->start_x / 7, outlink->h / 2 - 4 * 4, "TIME", 1);\n<417> for (y = 0; y < h; y++) {\n<437> pick_color(s, yf, uf, vf, y / (float)h, lout);\n<447> memset(s->outpicref->data[0]+(s->start_y + h * (ch + 1) - y - 1) * s->outpicref->linesize[0] + s->w + s->start_x + 20, av_clip_uint8(out[0]), 10);\n<449> memset(s->outpicref->data[1]+(s->start_y + h * (ch + 1) - y - 1) * s->outpicref->linesize[1] + s->w + s->start_x + 20, av_clip_uint8(out[1]), 10);\n<451> memset(s->outpicref->data[2]+(s->start_y + h * (ch + 1) - y - 1) * s->outpicref->linesize[2] + s->w + s->start_x + 20, av_clip_uint8(out[2]), 10);
<1> static int t_fromb64 ( unsigned char * a , const char * src ) {\n<5> while ( * src && ( * src == ' ' || * src == '\t' || * src == '\n' ) ) ++ src ;\n<6> size = strlen ( src ) ;\n<8> while ( i < size ) {\n<9> loc = strchr ( b64table , src [ i ] ) ;\n<10> if ( loc == ( char * ) 0 ) break ;\n<11> else a [ i ] = loc - b64table ;
<1> static void imc_get_skip_coeff ( IMCContext * q , IMCChannel * chctx ) {\n<3> memset ( chctx -> skipFlagBits , 0 , sizeof ( chctx -> skipFlagBits ) ) ;\n<4> memset ( chctx -> skipFlagCount , 0 , sizeof ( chctx -> skipFlagCount ) ) ;
<1> int ppc_find_by_name (const unsigned char *name, ppc_def_t **def)\n<13> for (i = 0; strcmp(ppc_defs[i].name, "default") != 0; i++) {\n<15> if (strcasecmp(name, ppc_defs[i].name) == 0) {
<1> int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n<5> char *param, buffer[128], tmp[128];\n<7> int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n<9> SrtStack stack[16];\n<25> for (; !end && *in; in++) {\n<27> switch (*in) {\n<61> handle_open_brace(dst, &in, &an, &closing_brace_missing);\n<67> tag_close = in[1] == '/';\n<69> len = 0;\n<71> if (sscanf(in+tag_close+1, "%127[^>]>%n", buffer, &len) >= 1 && len > 0) {\n<73> const char *tagname = buffer;\n<75> while (*tagname == ' ')\n<77> tagname++;\n<79> if ((param = strchr(tagname, ' ')))\n<81> *param++ = 0;\n<83> if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack)) ||\n<85> ( tag_close && sptr > 0 && !av_strcasecmp(stack[sptr-1].tag, tagname))) {\n<87> int i, j, unknown = 0;\n<89> in += len + tag_close;\n<91> if (!tag_close)\n<93> memset(stack+sptr, 0, sizeof(*stack));\n<95> if (!av_strcasecmp(tagname, "font")) {\n<101> if (stack[sptr-1].param[i][0])\n<103> for (j=sptr-2; j>=0; j--)\n<115> while (param) {\n<117> if (!av_strncasecmp(param, "size=", 5)) {\n<121> param += 5 + (param[5] == '"');\n<123> if (sscanf(param, "%u", &font_size) == 1) {\n<125> snprintf(stack[sptr].param[PARAM_SIZE],\n<127> sizeof(stack[0].param[PARAM_SIZE]),\n<135> param += 6 + (param[6] == '"');\n<143> html_color_parse(log_ctx, param));\n<145> } else if (!av_strncasecmp(param, "face=", 5)) {\n<147> param += 5 + (param[5] == '"');\n<151> param[-1] == '"' ? "\"" :" ");\n<155> FFMIN(sizeof(tmp), len+1));\n<157> param += len;\n<167> if ((param = strchr(param, ' ')))\n<169> param++;\n<181> } else if (tagname[0] && !tagname[1] && av_stristr("bisu", tagname)) {\n<183> av_bprintf(dst, "{\\%c%d}", (char)av_tolower(tagname[0]), !tag_close);\n<191> unknown = 1;\n<193> snprintf(tmp, sizeof(tmp), "</%s>", tagname);\n<197> if (tag_close) {\n<199> sptr--;\n<201> } else if (unknown && !strstr(in, tmp)) {\n<203> in -= len + tag_close;\n<205> av_bprint_chars(dst, *in, 1);\n<209> av_strlcpy(stack[sptr++].tag, tagname,\n<211> sizeof(stack[0].tag));\n<221> av_bprint_chars(dst, *in, 1);
<1> static int hevc_frame_start(HEVCContext *s)\n<11> memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));\n<13> memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));\n<15> memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);\n<17> memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);\n<34> ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,\n<44> ret = ff_hevc_frame_rps(s);\n<56> ret = set_side_data(s);\n<66> ret = ff_hevc_output_frame(s, s->output_frame, 0);
<1> int hostbased_key_allowed ( struct passwd * pw , const char * cuser , char * chost , struct sshkey * key ) {\n<7> if ( auth_key_is_revoked ( key ) ) return 0 ;\n<10> debug2 ( "%s: chost %s resolvedname %s ipaddr %s" , __func__ , chost , resolvedname , ipaddr ) ;\n<11> if ( ( ( len = strlen ( chost ) ) > 0 ) && chost [ len - 1 ] == '.' ) {\n<12> debug2 ( "stripping trailing dot from chost %s" , chost ) ;\n<13> chost [ len - 1 ] = '\0' ;\n<16> if ( auth_rhosts2 ( pw , cuser , chost , chost ) == 0 ) {\n<23> if ( strcasecmp ( resolvedname , chost ) != 0 ) logit ( "userauth_hostbased mismatch: " "client sends %s, but we resolve %s to %s" , chost , ipaddr , resolvedname ) ;\n<40> if ( host_status == HOST_OK ) {\n<43> verbose ( "Accepted certificate ID \"%s\" signed by " "%s CA %s from %s@%s" , key -> cert -> key_id , sshkey_type ( key -> cert -> signature_key ) , fp , cuser , lookup ) ;\n<47> verbose ( "Accepted %s public key %s from %s@%s" , sshkey_type ( key ) , fp , cuser , lookup ) ;\n<49> free ( fp ) ;
<1> static void vmgenid_set_guid_test(void)\n<27> g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
<1> static int http_open_cnx(URLContext *h)\n<25> proxy_path = getenv("http_proxy");\n<27> use_proxy = (proxy_path != NULL) && !getenv("no_proxy") &&\n<29> av_strstart(proxy_path, "http://", NULL);\n<39> av_url_split(proto, sizeof(proto), auth, sizeof(auth),\n<49> if (!strcmp(proto, "https")) {\n<51> lower_proto = "tls";\n<53> use_proxy = 0;\n<55> if (port < 0)\n<83> ff_url_join(urlbuf, sizeof(urlbuf), proto, NULL, hostname, port, "%s",\n<121> if (cur_auth_type == HTTP_AUTH_NONE && s->auth_state.auth_type != HTTP_AUTH_NONE) {\n<157> if (redirects++ >= MAX_REDIRECTS)
<1> static void test_frm_bug ( ) {\n<7> char data_dir [ FN_REFLEN ] ;\n<20> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> my_bind [ 1 ] = my_bind [ 0 ] ;\n<25> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<29> if ( ! opt_silent ) fprintf ( stdout , "\n data directory: %s" , data_dir ) ;\n<32> strxmov ( test_frm , data_dir , "/" , current_db , "/" , "test_frm_bug.frm" , NullS ) ;\n<33> if ( ! opt_silent ) fprintf ( stdout , "\n test_frm: %s" , test_frm ) ;\n<34> if ( ! ( test_file = my_fopen ( test_frm , ( int ) ( O_RDWR | O_CREAT ) , MYF ( MY_WME ) ) ) ) {\n<35> fprintf ( stdout , "\n ERROR: my_fopen failed for '%s'" , test_frm ) ;\n<36> fprintf ( stdout , "\n test cancelled" ) ;\n<39> if ( ! opt_silent ) fprintf ( test_file , "this is a junk file for test" ) ;\n<48> mytest ( row ) ;\n<49> if ( ! opt_silent ) fprintf ( stdout , "\n Comment: %s" , row [ 17 ] ) ;\n<50> DIE_UNLESS ( row [ 17 ] != 0 ) ;\n<53> my_fclose ( test_file , MYF ( 0 ) ) ;
<1> static int parse_playlist(URLContext *h, const char *url)\n<27> read_chomp_line(in, line, sizeof(line));\n<29> if (strcmp(line, "#EXTM3U"))\n<31> return AVERROR_INVALIDDATA;\n<35> free_segment_list(s);\n<37> s->finished = 0;\n<39> while (!in->eof_reached) {\n<131> avio_close(in);\n<133> return ret;
<1> static int rtp_packetize_mpv ( sout_stream_id_sys_t * id , block_t * in ) {\n<4> uint8_t * p_data = in -> p_buffer ;\n<48> i < i_count ;\n<50> int i_payload = __MIN ( i_max , i_data ) ;\n<53> rtp_packetize_common ( id , out , ( i == i_count - 1 ) ? 1 : 0 , in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ;\n<54> SetDWBE ( out -> p_buffer + 12 , h ) ;\n<55> memcpy ( & out -> p_buffer [ 16 ] , p_data , i_payload ) ;\n<58> rtp_packetize_send ( id , out ) ;\n<59> p_data += i_payload ;\n<60> i_data -= i_payload ;
<1> static int sort_ft_key_write ( MI_SORT_PARAM * sort_param , const void * a ) {\n<7> val_len = HA_FT_WLEN + sort_info -> info -> s -> rec_reflength ;\n<9> if ( ! ft_buf ) {\n<11> if ( ! ft_buf ) {\n<18> get_key_full_length_rdonly ( val_off , ft_buf -> lastkey ) ;\n<19> if ( ha_compare_text ( sort_param -> seg -> charset , ( ( uchar * ) a ) + 1 , a_len - 1 , ft_buf -> lastkey + 1 , val_off - 1 , 0 , 0 ) == 0 ) {\n<20> if ( ! ft_buf -> buf ) {\n<24> memcpy ( ft_buf -> buf , ( char * ) a + a_len , val_len ) ;\n<25> ft_buf -> buf += val_len ;\n<31> ft_buf -> count = ( uint ) ( ft_buf -> buf - p ) / val_len ;\n<38> if ( ( error = sort_ft_buf_flush ( sort_param ) ) ) return error ;\n<39> word_init_ft_buf : a_len += val_len ;\n<40> memcpy ( ft_buf -> lastkey , a , a_len ) ;\n<41> ft_buf -> buf = ft_buf -> lastkey + a_len ;\n<42> ft_buf -> end = ft_buf -> lastkey + ( sort_param -> keyinfo -> block_length - 32 ) ;
<1> static bool gincost_scalararrayopexpr ( PlannerInfo * root , IndexOptInfo * index , IndexQualInfo * qinfo , double numIndexEntries , GinQualCounts * counts ) {\n<24> if ( ( ( Const * ) rightop ) -> constisnull ) return false ;\n<28> memset ( & arraycounts , 0 , sizeof ( arraycounts ) ) ;\n<33> if ( elemNulls [ i ] ) continue ;\n<34> memset ( & elemcounts , 0 , sizeof ( elemcounts ) ) ;\n<35> if ( gincost_pattern ( index , indexcol , clause_op , elemValues [ i ] , & elemcounts ) ) {\n<38> elemcounts . partialEntries = 0 ;\n<39> elemcounts . exactEntries = numIndexEntries ;\n<40> elemcounts . searchEntries = numIndexEntries ;\n<42> arraycounts . partialEntries += elemcounts . partialEntries ;\n<43> arraycounts . exactEntries += elemcounts . exactEntries ;\n<44> arraycounts . searchEntries += elemcounts . searchEntries ;
<1> static void note_change_n ( const char * p , struct branch * b , unsigned char * old_fanout ) {\n<38> else if ( ! get_sha1 ( p , commit_sha1 ) ) {\n<41> if ( ! buf || size < 46 ) die ( "Not a valid commit: %s" , p ) ;\n<42> free ( buf ) ;
<1> kadm5_ret_t krb5_copy_key_data_contents ( context , from , to ) krb5_context context ;\n<10> if ( from -> key_data_length [ i ] ) {\n<11> to -> key_data_contents [ i ] = malloc ( from -> key_data_length [ i ] ) ;\n<12> if ( to -> key_data_contents [ i ] == NULL ) {\n<16> if ( to -> key_data_contents [ i ] ) {\n<17> memset ( to -> key_data_contents [ i ] , 0 , to -> key_data_length [ i ] ) ;\n<18> free ( to -> key_data_contents [ i ] ) ;\n<23> memcpy ( to -> key_data_contents [ i ] , from -> key_data_contents [ i ] , from -> key_data_length [ i ] ) ;
<1> static int aes_ocb_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n<2> EVP_AES_OCB_CTX * octx = EVP_C_DATA ( EVP_AES_OCB_CTX , c ) ;\n<17> case EVP_CTRL_AEAD_SET_TAG : if ( ! ptr ) {\n<22> if ( arg != octx -> taglen || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n<23> memcpy ( octx -> tag , ptr , arg ) ;\n<25> case EVP_CTRL_AEAD_GET_TAG : if ( arg != octx -> taglen || ! EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n<26> memcpy ( ptr , octx -> tag , arg ) ;
<1> DriveInfo *drive_init(QemuOpts *opts, int default_to_scsi)\n<87> if ((buf = qemu_opt_get(opts, "if")) != NULL) {\n<89> pstrcpy(devname, sizeof(devname), buf);\n<91> for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n<97> error_report("unsupported bus type '%s'", buf);\n<147> if ((buf = qemu_opt_get(opts, "trans")) != NULL) {\n<149> if (!cyls) {\n<159> if (!strcmp(buf, "none"))\n<161> translation = BIOS_ATA_TRANSLATION_NONE;\n<163> else if (!strcmp(buf, "lba"))\n<165> translation = BIOS_ATA_TRANSLATION_LBA;\n<167> else if (!strcmp(buf, "auto"))\n<169> translation = BIOS_ATA_TRANSLATION_AUTO;\n<173> error_report("'%s' invalid translation type", buf);\n<175> return NULL;\n<183> if ((buf = qemu_opt_get(opts, "media")) != NULL) {\n<185> if (!strcmp(buf, "disk")) {\n<187> media = MEDIA_DISK;\n<189> } else if (!strcmp(buf, "cdrom")) {\n<191> if (cyls || secs || heads) {\n<193> error_report("CHS can't be set with media=%s", buf);\n<203> error_report("'%s' invalid media", buf);\n<205> return NULL;\n<213> if ((buf = qemu_opt_get(opts, "cache")) != NULL) {\n<253> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<255> if (strcmp(buf, "?") == 0) {\n<257> error_printf("Supported formats:");\n<259> bdrv_iterate_format(bdrv_format_print, NULL);\n<261> error_printf("\n");\n<263> return NULL;\n<267> drv = bdrv_find_whitelisted_format(buf);\n<269> if (!drv) {\n<679> if (ret < 0) {\n<681> error_report("could not open disk image %s: %s",\n<683> file, strerror(-ret));
<1> int file_is_y4m ( const char detect [ 4 ] ) {\n<2> if ( memcmp ( detect , "YUV4" , 4 ) == 0 ) {\n<3> return 1 ;\n<5> return 0 ;
<1> static int img_snapshot(int argc, char **argv)\n<145> switch(action) {\n<157> memset(&sn, 0, sizeof(sn));\n<171> ret = bdrv_snapshot_create(bs, &sn);\n<173> if (ret) {\n<175> error_report("Could not create snapshot '%s': %d (%s)",\n<177> snapshot_name, ret, strerror(-ret));\n<189> if (ret) {\n<191> error_report("Could not apply snapshot '%s': %d (%s)",\n<193> snapshot_name, ret, strerror(-ret));\n<205> if (ret) {\n<207> error_report("Could not delete snapshot '%s': %d (%s)",\n<209> snapshot_name, ret, strerror(-ret));
<1> static int libx265_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<93> dst = pkt->data;\n<97> for (i = 0; i < nnal; i++) {\n<99> memcpy(dst, nal[i].payload, nal[i].sizeBytes);\n<101> dst += nal[i].sizeBytes;
<89> av_freep(&st->codecpar->extradata);\n<97> if (!st->codecpar->extradata)\n<101> memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);
<1> static void hardware_memory_error ( void ) {\n<2> fprintf ( stderr , "Hardware memory error!\n" ) ;
<1> static int scsi_get_configuration(SCSIDiskState *s, uint8_t *outbuf)\n<9> if (s->qdev.type != TYPE_ROM) {\n<17> memset(outbuf, 0, 40);\n<19> stl_be_p(&outbuf[0], 36); /* Bytes after the data length field */\n<21> stw_be_p(&outbuf[6], current);\n<29> stw_be_p(&outbuf[12], MMC_PROFILE_DVD_ROM);\n<33> stw_be_p(&outbuf[16], MMC_PROFILE_CD_ROM);\n<39> stw_be_p(&outbuf[20], 1);\n<45> stl_be_p(&outbuf[24], 1); /* SCSI */\n<51> stw_be_p(&outbuf[32], 3);
<1> int main (int argc, char *argv[])\n<9> if (argv[0][0] != '/')\n<13> fnam = malloc (strlen (argv[0]) + 2);\n<15> if (fnam == NULL)\n<19> strcpy (fnam, "/");\n<21> strcat (fnam, argv[0]);\n<27> f = fopen (fnam, "rb");\n<45> printf ("pass\n");
<1> static void handle_arg_cpu(const char *arg)\n<5> cpu_model = strdup(arg);\n<7> if (cpu_model == NULL || strcmp(cpu_model, "?") == 0) {\n<21> exit(1);
<1> static int virtcon_parse(const char *devname)\n<15> if (strcmp(devname, "none") == 0)\n<17> return 0;\n<19> if (index == MAX_VIRTIO_CONSOLES) {\n<21> fprintf(stderr, "qemu: too many virtio consoles\n");\n<29> bus_opts = qemu_opts_create(device, NULL, 0);\n<31> if (arch_type == QEMU_ARCH_S390X) {\n<43> dev_opts = qemu_opts_create(device, NULL, 0);\n<45> qemu_opt_set(dev_opts, "driver", "virtconsole");\n<49> snprintf(label, sizeof(label), "virtcon%d", index);\n<51> virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n<53> if (!virtcon_hds[index]) {\n<55> fprintf(stderr, "qemu: could not open virtio console '%s': %s\n",\n<57> devname, strerror(errno));
<1> void target_disas(FILE *out, CPUState *cpu, target_ulong code,\n<17> INIT_DISASSEMBLE_INFO(s.info, out, fprintf);\n<49> cc->disas_set_info(cpu, &s.info);\n<115> for (pc = code; size > 0; pc += count, size -= count) {\n<119> count = s.info.print_insn(pc, &s.info);\n<145> fprintf(out, "\n");\n<151> if (size < count) {
<1> void addto_syslog ( int level , const char * msg ) {\n<15> if ( prog != NULL ) prog ++ ;\n<16> else prog = progname ;\n<25> if ( msyslog_include_timestamp ) human_time = humanlogtime ( ) ;\n<26> else human_time = NULL ;\n<27> if ( msyslog_term_pid || log_to_file ) pid = getpid ( ) ;\n<28> else pid = - 1 ;\n<29> if ( '\n' != msg [ strlen ( msg ) - 1 ] ) nl_or_empty = nl ;\n<30> else nl_or_empty = empty ;\n<31> if ( log_to_term ) {\n<32> term_file = ( level <= LOG_ERR ) ? stderr : stdout ;\n<33> if ( msyslog_include_timestamp ) fprintf ( term_file , "%s " , human_time ) ;\n<34> if ( msyslog_term_pid ) fprintf ( term_file , "%s[%d]: " , prog , pid ) ;\n<35> fprintf ( term_file , "%s%s" , msg , nl_or_empty ) ;\n<36> fflush ( term_file ) ;\n<38> if ( log_to_file ) {\n<39> if ( msyslog_include_timestamp ) fprintf ( syslog_file , "%s " , human_time ) ;\n<40> fprintf ( syslog_file , "%s[%d]: %s%s" , prog , pid , msg , nl_or_empty ) ;\n<41> fflush ( syslog_file ) ;
<9> ALSSpecificConfig *sconf = &ctx->sconf;\n<73> for (b = 0; b < ctx->num_blocks; b++) {\n<149> memmove(ctx->raw_samples[c] - sconf->max_order,\n<151> ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n<153> sizeof(*ctx->raw_samples[c]) * sconf->max_order);
<1> static void pflash_write (pflash_t *pfl, target_ulong offset, uint32_t value,\n<47> cpu_register_physical_memory(pfl->base, pfl->total_len, pfl->fl_mem);\n<307> switch (cmd) {\n<311> if (boff != 0x555) {\n<325> memset(pfl->storage, 0xFF, pfl->total_len);\n<329> pflash_update(pfl, 0, pfl->total_len);\n<343> p = pfl->storage;\n<345> offset &= ~(pfl->sector_len - 1);\n<351> memset(p + offset, 0xFF, pfl->sector_len);\n<353> pflash_update(pfl, offset, pfl->sector_len);
<1> static void aio_write_done(void *opaque, int ret)\n<17> if (ret < 0) {\n<19> printf("aio_write failed: %s\n", strerror(-ret));
<1> static void _printTocEntry ( ArchiveHandle * AH , TocEntry * te , bool isData , bool acl_pass ) {\n<2> RestoreOptions * ropt = AH -> public . ropt ;\n<4> if ( ! _tocEntryIsACL ( te ) ) return ;\n<7> if ( _tocEntryIsACL ( te ) ) return ;\n<9> if ( ! ( ropt -> dropSchema && ! ropt -> createDB ) ) {\n<10> if ( strcmp ( te -> desc , "SCHEMA" ) == 0 && strcmp ( te -> tag , "public" ) == 0 ) return ;\n<11> if ( strcmp ( te -> desc , "COMMENT" ) == 0 && strcmp ( te -> tag , "SCHEMA public" ) == 0 ) return ;\n<13> _becomeOwner ( AH , te ) ;\n<14> _selectOutputSchema ( AH , te -> namespace ) ;\n<15> _selectTablespace ( AH , te -> tablespace ) ;\n<16> if ( strcmp ( te -> desc , "TABLE" ) == 0 ) _setWithOids ( AH , te ) ;\n<17> if ( ! AH -> noTocComments ) {\n<36> sanitized_name = replace_line_endings ( te -> tag ) ;\n<37> if ( te -> namespace ) sanitized_schema = replace_line_endings ( te -> namespace ) ;\n<38> else sanitized_schema = pg_strdup ( "-" ) ;\n<39> if ( ! ropt -> noOwner ) sanitized_owner = replace_line_endings ( te -> owner ) ;\n<40> else sanitized_owner = pg_strdup ( "-" ) ;\n<46> free ( sanitized_schema ) ;\n<47> free ( sanitized_owner ) ;\n<48> if ( te -> tablespace && strlen ( te -> tablespace ) > 0 && ! ropt -> noTablespace ) {\n<50> sanitized_tablespace = replace_line_endings ( te -> tablespace ) ;\n<56> if ( AH -> PrintExtraTocPtr != NULL ) ( * AH -> PrintExtraTocPtr ) ( AH , te ) ;\n<57> ahprintf ( AH , "--\n\n" ) ;\n<59> if ( ropt -> noOwner && strcmp ( te -> desc , "SCHEMA" ) == 0 ) {\n<64> if ( strlen ( te -> defn ) > 0 ) ahprintf ( AH , "%s\n\n" , te -> defn ) ;\n<66> if ( ! ropt -> noOwner && ! ropt -> use_setsessauth && strlen ( te -> owner ) > 0 && strlen ( te -> dropStmt ) > 0 ) {\n<67> if ( strcmp ( te -> desc , "AGGREGATE" ) == 0 || strcmp ( te -> desc , "BLOB" ) == 0 || strcmp ( te -> desc , "COLLATION" ) == 0 || strcmp ( te -> desc , "CONVERSION" ) == 0 || strcmp ( te -> desc , "DATABASE" ) == 0 || strcmp ( te -> desc , "DOMAIN" ) == 0 || strcmp ( te -> desc , "FUNCTION" ) == 0 || strcmp ( te -> desc , "OPERATOR" ) == 0 || strcmp ( te -> desc , "OPERATOR CLASS" ) == 0 || strcmp ( te -> desc , "OPERATOR FAMILY" ) == 0 || strcmp ( te -> desc , "PROCEDURAL LANGUAGE" ) == 0 || strcmp ( te -> desc , "SCHEMA" ) == 0 || strcmp ( te -> desc , "TABLE" ) == 0 || strcmp ( te -> desc , "TYPE" ) == 0 || strcmp ( te -> desc , "VIEW" ) == 0 || strcmp ( te -> desc , "MATERIALIZED VIEW" ) == 0 || strcmp ( te -> desc , "SEQUENCE" ) == 0 || strcmp ( te -> desc , "FOREIGN TABLE" ) == 0 || strcmp ( te -> desc , "TEXT SEARCH DICTIONARY" ) == 0 || strcmp ( te -> desc , "TEXT SEARCH CONFIGURATION" ) == 0 || strcmp ( te -> desc , "FOREIGN DATA WRAPPER" ) == 0 || strcmp ( te -> desc , "SERVER" ) == 0 ) {\n<68> PQExpBuffer temp = createPQExpBuffer ( ) ;\n<69> appendPQExpBufferStr ( temp , "ALTER " ) ;\n<70> _getObjectDescription ( temp , te , AH ) ;\n<74> destroyPQExpBuffer ( temp ) ;\n<76> else if ( strcmp ( te -> desc , "CAST" ) == 0 || strcmp ( te -> desc , "CHECK CONSTRAINT" ) == 0 || strcmp ( te -> desc , "CONSTRAINT" ) == 0 || strcmp ( te -> desc , "DEFAULT" ) == 0 || strcmp ( te -> desc , "FK CONSTRAINT" ) == 0 || strcmp ( te -> desc , "INDEX" ) == 0 || strcmp ( te -> desc , "RULE" ) == 0 || strcmp ( te -> desc , "TRIGGER" ) == 0 || strcmp ( te -> desc , "ROW SECURITY" ) == 0 || strcmp ( te -> desc , "POLICY" ) == 0 || strcmp ( te -> desc , "USER MAPPING" ) == 0 ) {\n<79> write_msg ( modulename , "WARNING: don't know how to set owner for object type %s\n" , te -> desc ) ;\n<82> if ( acl_pass ) {\n<83> if ( AH -> currUser ) free ( AH -> currUser ) ;
<1> int qemuMonitorJSONHumanCommandWithFd ( qemuMonitorPtr mon , const char * cmd_str , int scm_fd , char * * reply_str ) {\n<15> if ( ( data = virJSONValueGetString ( obj ) ) ) * reply_str = strdup ( data ) ;\n<16> else * reply_str = strdup ( "" ) ;\n<17> if ( ! * reply_str ) {
<1> void http_hdr_init ( HdrHeap * heap , HTTPHdrImpl * hh , HTTPType polarity ) {\n<2> memset ( & ( hh -> u ) , 0 , sizeof ( hh -> u ) ) ;
<1> static int lag_decode_arith_plane ( LagarithContext * l , uint8_t * dst , int width , int height , int stride , const uint8_t * src , int src_size ) {\n<38> if ( src_size < width * height ) return AVERROR_INVALIDDATA ;\n<40> i < height ;\n<42> memcpy ( dst + ( i * stride ) , src , width ) ;\n<43> src += width ;\n<49> i < height ;\n<50> i ++ ) memset ( dst + i * stride , src [ 1 ] , width ) ;\n<61> lag_pred_line ( l , dst , width , stride , i ) ;\n<69> lag_pred_line_yuy2 ( l , dst , width , stride , i , width == l -> avctx -> width ) ;
<1> int av_packet_split_side_data(AVPacket *pkt){\n<55> if (!pkt->side_data[i].data)\n<59> memcpy(pkt->side_data[i].data, p-size, size);\n<61> pkt->size -= size + 5;\n<67> p-= size+5;
<1> static void vfio_map_bar(VFIOPCIDevice *vdev, int nr)\n<43> if (ret != sizeof(pci_bar)) {\n<91> strncat(name, " mmap", sizeof(name) - strlen(name) - 1);\n<93> if (vfio_mmap_region(OBJECT(vdev), &bar->region, &bar->region.mem,\n<105> if (vdev->msix && vdev->msix->table_bar == nr) {\n<119> strncat(name, " msix-hi", sizeof(name) - strlen(name) - 1);\n<123> if (vfio_mmap_region(OBJECT(vdev), &bar->region, &bar->region.mem,
<1> static int vmdaudio_decode_init(AVCodecContext *avctx)\n<5> VmdAudioContext *s = (VmdAudioContext *)avctx->priv_data;\n<11> s->channels = avctx->channels;\n<13> s->bits = avctx->bits_per_sample;\n<15> s->block_align = avctx->block_align;\n<19> printf ("  %d channels, %d bits/sample, block align = %d\n",
<1> static CURLcode http_output_basic ( struct connectdata * conn , bool proxy ) {\n<19> snprintf ( data -> state . buffer , sizeof ( data -> state . buffer ) , "%s:%s" , user , pwd ) ;\n<20> result = Curl_base64_encode ( data , data -> state . buffer , strlen ( data -> state . buffer ) , & authorization , & size ) ;\n<22> if ( ! authorization ) return CURLE_REMOTE_ACCESS_DENIED ;\n<23> free ( * userp ) ;\n<24> * userp = aprintf ( "%sAuthorization: Basic %s\r\n" , proxy ? "Proxy-" : "" , authorization ) ;\n<25> free ( authorization ) ;
<1> static void dissect_coap_opt_uri_host ( tvbuff_t * tvb , proto_item * head_item , proto_tree * subtree , gint offset , gint opt_length , coap_info * coinfo , int hf ) {\n<3> proto_tree_add_item_ret_string ( subtree , hf , tvb , offset , opt_length , ENC_ASCII , wmem_packet_scope ( ) , & str ) ;\n<4> proto_item_append_text ( head_item , ": %s" , str ) ;\n<5> if ( strchr ( str , ':' ) == NULL ) {\n<6> wmem_strbuf_append_printf ( coinfo -> uri_str_strbuf , "coap://%s" , str ) ;\n<9> wmem_strbuf_append_printf ( coinfo -> uri_str_strbuf , "coap://[%s]" , str ) ;
<1> static int qemu_rdma_registration_stop(QEMUFile *f, void *opaque,\n<39> RDMAControlHeader resp = {.type = RDMA_CONTROL_RAM_BLOCKS_RESULT };\n<69> ret = qemu_rdma_exchange_send(rdma, &head, NULL, &resp,\n<85> nb_remote_blocks = resp.len / sizeof(RDMARemoteBlock);\n<113> if (local->nb_blocks != nb_remote_blocks) {\n<127> qemu_rdma_move_header(rdma, reg_result_idx, &resp);\n<135> network_to_remote_block(&rdma->block[i]);\n<199> ret = qemu_rdma_exchange_send(rdma, &head, NULL, NULL, NULL, NULL);
<1> static void do_apply_filter(APEContext *ctx, int version, APEFilter *f,\n<91> if (f->delay == f->historybuffer + HISTORY_SIZE + (order * 2)) {\n<93> memmove(f->historybuffer, f->delay - (order * 2),\n<95> (order * 2) * sizeof(*f->historybuffer));\n<97> f->delay = f->historybuffer + order * 2;\n<99> f->adaptcoeffs = f->historybuffer + order;
<1> static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> XanContext * s = avctx -> priv_data ;\n<20> tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n<22> s -> palettes = tmpptr ;\n<54> if ( ( ret = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) ) {\n<59> memcpy ( frame -> data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;
<1> cl_program av_opencl_compile(const char *program_name, const char *build_opts)\n<31> ptr = av_stristr(opencl_ctx.kernel_code[i].kernel_string, program_name);\n<33> if (ptr && !opencl_ctx.kernel_code[i].is_compiled) {\n<37> kernel_code_len = strlen(opencl_ctx.kernel_code[i].kernel_string);\n<61> program = clCreateProgramWithSource(opencl_ctx.context, 1, &kernel_source, &kernel_code_len, &status);
<1> static void sx1_init(MachineState *machine, const int version)\n<107> if ((dinfo = drive_get(IF_PFLASH, 0, fl_idx)) != NULL) {\n<119> fprintf(stderr, "qemu: Error registering flash memory %d.\n",\n<125> fl_idx++;\n<133> (dinfo = drive_get(IF_PFLASH, 0, fl_idx)) != NULL) {\n<167> fprintf(stderr, "qemu: Error registering flash memory %d.\n",\n<173> fl_idx++;\n<189> if (!machine->kernel_filename && !fl_idx && !qtest_enabled()) {\n<191> fprintf(stderr, "Kernel or Flash image must be specified\n");
<1> static void close_detect_done ( struct evhttp_request * req , void * arg ) {\n<3> if ( req == NULL || req -> response_code != HTTP_OK ) {\n<4> fprintf ( stderr , "FAILED\n" ) ;
<1> static void http_basic_test ( void ) {\n<8> fprintf ( stdout , "Testing Basic HTTP Server: " ) ;\n<10> if ( evhttp_bind_socket ( http , "127.0.0.1" , port + 1 ) == - 1 ) {\n<11> fprintf ( stdout , "FAILED (bind)\n" ) ;\n<15> bev = bufferevent_new ( fd , http_readcb , http_writecb , http_errorcb , NULL ) ;\n<16> http_request = "GET /test HTTP/1.1\r\n" "Host: some" ;\n<17> bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n<20> event_once ( - 1 , EV_TIMEOUT , http_complete_write , bev , & tv ) ;\n<22> if ( test_ok != 3 ) {\n<23> fprintf ( stdout , "FAILED\n" ) ;\n<29> bev = bufferevent_new ( fd , http_readcb , http_writecb , http_errorcb , NULL ) ;\n<30> http_request = "GET /test HTTP/1.1\r\n" "Host: somehost\r\n" "Connection: close\r\n" "\r\n" ;\n<31> bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n<33> bufferevent_free ( bev ) ;\n<36> if ( test_ok != 5 ) {\n<37> fprintf ( stdout , "FAILED\n" ) ;\n<40> fprintf ( stdout , "OK\n" ) ;
<1> static int ogg_read_packet(AVFormatContext *s, AVPacket *pkt)\n<32> ret = ogg_packet(s, &idx, &pstart, &psize, &fpos);\n<44> os  = ogg->streams + idx;\n<52> ogg_validate_keyframe(s, idx, pstart, psize);\n<66> ret = av_new_packet(pkt, psize);\n<68> if (ret < 0)\n<74> memcpy(pkt->data, os->buf + pstart, psize);\n<123> memcpy(side_data, os->new_metadata, os->new_metadata_size);\n<125> av_freep(&os->new_metadata);\n<132> return psize;
<1> static void get_options ( register int * argc , register char * * * argv ) {\n<12> if ( ( check_param . testflag & T_UNPACK ) && ( check_param . testflag & ( T_QUICK | T_SORT_RECORDS ) ) ) {\n<13> ( void ) fprintf ( stderr , "%s: --unpack can't be used with --quick or --sort-records\n" , my_progname_short ) ;\n<16> if ( ( check_param . testflag & T_READONLY ) && ( check_param . testflag & ( T_REP_ANY | T_STATISTICS | T_AUTO_INC | T_SORT_RECORDS | T_SORT_INDEX | T_FORCE_CREATE ) ) ) {\n<17> ( void ) fprintf ( stderr , "%s: Can't use --readonly when repairing or sorting\n" , my_progname_short ) ;
<1> static int h264_handle_packet(AVFormatContext *ctx,\n<11> const uint8_t * buf,\n<13> int len, int flags)\n<35> assert(buf);\n<43> switch (type) {\n<49> av_new_packet(pkt, len+sizeof(start_sequence));\n<51> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<53> memcpy(pkt->data+sizeof(start_sequence), buf, len);\n<101> src += 2;\n<107> if (nal_size <= src_len) {\n<109> if(pass==0) {\n<119> assert(dst);\n<121> memcpy(dst, start_sequence, sizeof(start_sequence));\n<123> dst+= sizeof(start_sequence);\n<125> memcpy(dst, src, nal_size);\n<133> dst+= nal_size;\n<149> src += nal_size;\n<151> src_len -= nal_size;\n<241> buf++;\n<243> len--;\n<255> if(start_bit) {\n<259> av_new_packet(pkt, sizeof(start_sequence)+sizeof(nal)+len);\n<261> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<263> pkt->data[sizeof(start_sequence)]= reconstructed_nal;\n<265> memcpy(pkt->data+sizeof(start_sequence)+sizeof(nal), buf, len);\n<269> av_new_packet(pkt, len);\n<271> memcpy(pkt->data, buf, len);
<1> static void main_get_appheader_params ( main_file * file , char * * parsed , int output , const char * type , main_file * other ) {\n<2> if ( file -> filename == NULL && ! ( output && option_stdout ) && strcmp ( parsed [ 0 ] , "-" ) != 0 ) {\n<3> file -> filename = parsed [ 0 ] ;\n<6> if ( last_slash != NULL ) {\n<7> usize_t dlen = ( usize_t ) ( last_slash - other -> filename ) ;\n<9> file -> filename_copy = ( char * ) main_malloc ( dlen + 2 + ( usize_t ) strlen ( file -> filename ) ) ;\n<10> strncpy ( file -> filename_copy , other -> filename , dlen ) ;\n<12> strcpy ( file -> filename_copy + dlen + 1 , parsed [ 0 ] ) ;\n<13> file -> filename = file -> filename_copy ;
<1> static inline int msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block,\n<33> level = msmpeg4_decode_dc(s, n, &dc_pred_dir);\n<51> if (level < 0){\n<53> fprintf(stderr, "dc overflow- block: %d qscale: %d//\n", n, s->qscale);\n<61> if (n < 4) {\n<65> if(level > 256*s->y_dc_scale){\n<67> fprintf(stderr, "dc overflow+ L qscale: %d//\n", s->qscale);\n<77> if(level > 256*s->c_dc_scale){\n<79> fprintf(stderr, "dc overflow+ C qscale: %d//\n", s->qscale);\n<209> if(s->qscale<8){\n<215> if(SHOW_UBITS(re, &s->gb, 1)) printf("cool a new vlc code ,contact the ffmpeg developers and upload the file\n");\n<453> if(s->error_resilience<0){\n<455> fprintf(stderr, "ignoring overflow at %d %d\n", s->mb_x, s->mb_y);\n<461> fprintf(stderr, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);\n<491> mpeg4_pred_ac(s, block, n, dc_pred_dir);
<1> fork_exec(struct socket *so, const char *ex, int do_pty)\n<13> const char *argv[256];\n<51> if ((s = qemu_socket(AF_INET, SOCK_STREAM, 0)) < 0 ||\n<57> error_report("Error: inet socket: %s", strerror(errno));\n<73> switch(pid) {\n<77> error_report("Error: fork failed: %s", strerror(errno));\n<113> } while (ret < 0 && errno == EINTR);\n<141> argv[i++] = bptr;\n<159> argv[i++] = g_strdup(curarg);\n<165> argv[i] = NULL;\n<167> execvp(argv[0], (char **)argv);\n<173> fprintf(stderr, "Error: execvp of %s failed: %s\n",\n<175> argv[0], strerror(errno));\n<205> } while (so->s < 0 && errno == EINTR);
<1> int cache_insert(PageCache *cache, uint64_t addr, const uint8_t *pdata)\n<19> it = cache_get_by_addr(cache, addr);\n<25> if (!it->it_data) {\n<27> it->it_data = g_try_malloc(cache->page_size);\n<29> if (!it->it_data) {\n<43> memcpy(it->it_data, pdata, cache->page_size);
<1> static void usbredir_control_packet(void *priv, uint32_t id,\n<3> struct usb_redir_control_packet_header *control_packet,\n<5> uint8_t *data, int data_len)\n<17> DPRINTF("ctrl-in status %d len %d id %u\n", control_packet->status,\n<25> if (!aurb) {\n<27> free(data);\n<35> aurb->control_packet.status = control_packet->status;\n<37> aurb->control_packet.length = control_packet->length;\n<43> ERROR("return control packet mismatch, please report this!\n");\n<45> len = USB_RET_NAK;\n<53> len = usbredir_handle_status(dev, control_packet->status, len);\n<57> usbredir_log_data(dev, "ctrl data in:", data, data_len);\n<59> if (data_len <= sizeof(dev->dev.data_buf)) {\n<61> memcpy(dev->dev.data_buf, data, data_len);\n<77> usb_generic_async_ctrl_complete(&dev->dev, aurb->packet);\n<81> async_free(dev, aurb);\n<83> free(data);
<1> int evdns_resolve_reverse_ipv6 ( const struct in6_addr * in , int flags , evdns_callback_type callback , void * ptr ) {\n<7> cp = buf ;\n<15> * cp ++ = '.' ;\n<17> assert ( cp + strlen ( "ip6.arpa" ) < buf + sizeof ( buf ) ) ;\n<18> memcpy ( cp , "ip6.arpa" , strlen ( "ip6.arpa" ) + 1 ) ;
<1> static void print_blob_as_hex ( FILE * output_file , const char * str , ulong len ) {\n<4> ptr < end ;\n<5> ptr ++ ) fprintf ( output_file , "%02X" , * ( ( uchar * ) ptr ) ) ;\n<6> check_io ( output_file ) ;
<1> static void scan_sources ( GList * files , SourceInfo * source_info , CommonJob * job , OpKind kind ) {\n<5> memset ( source_info , 0 , sizeof ( SourceInfo ) ) ;\n<8> report_preparing_count_progress ( job , source_info ) ;
<1> static void inject_user ( void ) {\n<3> len = strescape ( ( char * ) injectbuf , ( char * ) injectbuf , strlen ( injectbuf ) + 1 ) ;\n<5> user_inject ( injectbuf , len , curr_conn , 1 ) ;\n<8> user_inject ( injectbuf , len , curr_conn , 2 ) ;
<1> static krb5_error_code tl_data2berval ( krb5_tl_data * in , struct berval * * out ) {\n<2> * out = ( struct berval * ) malloc ( sizeof ( struct berval ) ) ;\n<3> if ( * out == NULL ) return ENOMEM ;\n<4> ( * out ) -> bv_len = in -> tl_data_length + 2 ;\n<5> ( * out ) -> bv_val = ( char * ) malloc ( ( * out ) -> bv_len ) ;\n<6> if ( ( * out ) -> bv_val == NULL ) {\n<7> free ( * out ) ;\n<10> STORE16_INT ( ( * out ) -> bv_val , in -> tl_data_type ) ;\n<11> memcpy ( ( * out ) -> bv_val + 2 , in -> tl_data_contents , in -> tl_data_length ) ;
<1> static int qemuMonitorTextParseBlockJobOne ( const char * text , const char * device , virDomainBlockJobInfoPtr info , const char * * next ) {\n<8> if ( ( text = STRSKIP ( text , "Streaming device " ) ) == NULL ) return - EINVAL ;\n<9> if ( ! STREQLEN ( text , device , strlen ( device ) ) ) mismatch = 1 ;\n<10> if ( ( text = strstr ( text , ": Completed " ) ) == NULL ) return - EINVAL ;\n<11> text += 11 ;\n<12> if ( virStrToLong_ull ( text , & p , 10 , & tmp . cur ) ) return - EINVAL ;
<1> static int connect_to_sdog(const char *addr, const char *port)\n<23> memset(&hints, 0, sizeof(hints));\n<29> ret = getaddrinfo(addr, port, &hints, &res0);\n<31> if (ret) {\n<33> error_report("unable to get address info %s, %s",\n<35> addr, strerror(errno));\n<37> return -errno;
<1> static void hmp_migrate_status_cb(void *opaque)\n<11> info = qmp_query_migrate(NULL);\n<13> if (!info->has_status || strcmp(info->status, "active") == 0) {\n<15> if (info->has_disk) {\n<41> timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n<45> if (status->is_block_migration) {\n<51> monitor_resume(status->mon);\n<53> timer_del(status->timer);\n<55> g_free(status);\n<61> qapi_free_MigrationInfo(info);
<1> static int read_cpuinfo(const char *field, char *value, int len)\n<9> int field_len = strlen(field);\n<17> if (!f) {\n<27> if(!fgets(line, sizeof(line), f)) {\n<33> if (!strncmp(line, field, field_len)) {\n<35> strncpy(value, line, len);\n<43> } while(*line);\n<47> fclose(f);
<1> static void set_options(URLContext *h, const char *uri)\n<17> const char *p = strchr(uri, '?');\n<19> if (!p)
<1> static void decode ( RA288Context * ractx , float gain , int cb_coef ) {\n<6> float * gain_block = ractx -> gain_hist + 28 ;\n<7> memmove ( ractx -> sp_hist + 70 , ractx -> sp_hist + 75 , 36 * sizeof ( * block ) ) ;\n<11> i ++ ) sum -= gain_block [ 9 - i ] * ractx -> gain_lpc [ i ] ;\n<19> memmove ( gain_block , gain_block + 1 , 9 * sizeof ( * gain_block ) ) ;
<1> struct crypto_instance * crypto_init ( const unsigned char * private_key , unsigned int private_key_len , const char * crypto_cipher_type , const char * crypto_hash_type , void ( * log_printf_func ) ( int level , int subsys , const char * function , const char * file , int line , const char * format , ... ) __attribute__ ( ( format ( printf , 6 , 7 ) ) ) , int log_level_security , int log_level_notice , int log_level_error , int log_subsys_id ) {\n<3> instance = malloc ( sizeof ( * instance ) ) ;\n<4> if ( instance == NULL ) {\n<7> memset ( instance , 0 , sizeof ( struct crypto_instance ) ) ;\n<8> memcpy ( instance -> private_key , private_key , private_key_len ) ;\n<9> instance -> private_key_len = private_key_len ;\n<10> instance -> crypto_cipher_type = string_to_crypto_cipher_type ( crypto_cipher_type ) ;\n<11> instance -> crypto_hash_type = string_to_crypto_hash_type ( crypto_hash_type ) ;\n<12> instance -> crypto_header_size = crypto_sec_header_size ( crypto_cipher_type , crypto_hash_type ) ;\n<13> instance -> log_printf_func = log_printf_func ;\n<14> instance -> log_level_security = log_level_security ;\n<15> instance -> log_level_notice = log_level_notice ;\n<16> instance -> log_level_error = log_level_error ;\n<17> instance -> log_subsys_id = log_subsys_id ;\n<18> if ( init_nss ( instance , crypto_cipher_type , crypto_hash_type ) < 0 ) {\n<19> free ( instance ) ;\n<22> return ( instance ) ;
<1> static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)\n<43> AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL, 0);\n<125> put16(&q, 0xe000 | ts_st->pid);\n<135> switch (st->codec->codec_type) {\n<157> for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {\n<159> next = strchr(p, ',');\n<161> if (strlen(p) != 3 && (!next || next != p + 3))\n<167> *q++ = *p++;\n<169> *q++ = *p++;\n<171> *q++ = *p++;\n<175> if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)\n<193> *len_ptr += 4;\n<213> language = lang && strlen(lang->value) == 3 ? lang->value : "eng";\n<219> *q++ = language[0];\n<221> *q++ = language[1];\n<223> *q++ = language[2];\n<225> *q++ = 0x10; /* normal subtitles (0x20 = if hearing pb) */\n<227> if (st->codec->extradata_size == 4) {\n<229> memcpy(q, st->codec->extradata, 4);\n<231> q += 4;
<1> void *g_try_realloc(void *mem, size_t n_bytes)\n<7> return realloc(mem, n_bytes == 0 ? 1 : n_bytes);
<1> fixup_vorbis_headers(AVFormatContext * as, struct oggvorbis_private *priv,\n<17> ptr = *buf = av_realloc(NULL, buf_len);\n<21> memset(*buf, '\0', buf_len);\n<29> offset += av_xiphlacing(&ptr[offset], priv->len[0]);\n<31> offset += av_xiphlacing(&ptr[offset], priv->len[1]);\n<33> for (i = 0; i < 3; i++) {\n<35> memcpy(&ptr[offset], priv->packet[i], priv->len[i]);\n<37> offset += priv->len[i];\n<39> av_freep(&priv->packet[i]);\n<43> *buf = av_realloc(*buf, offset + FF_INPUT_BUFFER_PADDING_SIZE);
<1> ssize_t pcnet_receive(NetClientState *nc, const uint8_t *buf, size_t size_)\n<9> uint8_t buf1[60];\n<37> if (size < MIN_BUF_SIZE) {\n<39> memcpy(buf1, buf, size);\n<41> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<43> buf = buf1;
<1> static void setos2 ( struct os2 * os2 , struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n<92> if ( sf -> pfminfo . hasunicoderanges ) memcpy ( os2 -> unicoderange , sf -> pfminfo . unicoderanges , sizeof ( os2 -> unicoderange ) ) ;\n<94> if ( modformat == ff_ttfsym ) memset ( os2 -> unicoderange , 0 , sizeof ( os2 -> unicoderange ) ) ;\n<95> if ( sf -> pfminfo . pfmset ) strncpy ( os2 -> achVendID , sf -> pfminfo . os2_vendor , 4 ) ;\n<96> else if ( TTFFoundry != NULL ) strncpy ( os2 -> achVendID , TTFFoundry , 4 ) ;\n<97> else memcpy ( os2 -> achVendID , "PfEd" , 4 ) ;\n<98> for ( pt = os2 -> achVendID ;\n<99> pt < os2 -> achVendID && * pt != '\0' ;\n<106> memcpy ( os2 -> panose , sf -> pfminfo . panose , sizeof ( os2 -> panose ) ) ;\n<109> if ( sf -> pfminfo . hascodepages ) memcpy ( os2 -> ulCodePage , sf -> pfminfo . codepages , sizeof ( os2 -> ulCodePage ) ) ;\n<155> if ( sf -> pfminfo . hascodepages ) memcpy ( os2 -> ulCodePage , sf -> pfminfo . codepages , sizeof ( os2 -> ulCodePage ) ) ;
<1> static FILE * open_outfile ( const char * name ) {\n<2> if ( strcmp ( "-" , name ) == 0 ) {\n<3> set_binary_mode ( stdout ) ;\n<4> return stdout ;\n<7> FILE * file = fopen ( name , "wb" ) ;\n<8> if ( ! file ) fatal ( "Failed to output file %s" , name ) ;\n<9> return file ;
<1> kadm5_ret_t kadm5_create_policy_internal ( void * server_handle , kadm5_policy_ent_t entry , long mask ) {\n<7> if ( ( entry == ( kadm5_policy_ent_t ) NULL ) || ( entry -> policy == NULL ) ) return EINVAL ;\n<8> if ( strlen ( entry -> policy ) == 0 ) return KADM5_BAD_POLICY ;\n<9> if ( ! ( mask & KADM5_POLICY ) ) return KADM5_BAD_MASK ;\n<10> if ( ( mask & KADM5_POLICY_ALLOWED_KEYSALTS ) && entry -> allowed_keysalts != NULL ) {\n<12> if ( ret ) return ret ;\n<14> memset ( & pent , 0 , sizeof ( pent ) ) ;\n<15> pent . name = entry -> policy ;\n<16> p = entry -> policy ;\n<71> if ( ( ret = krb5_db_create_policy ( handle -> context , & pent ) ) ) return ret ;
<1> static int ppce500_load_device_tree(MachineState *machine,\n<81> const char *toplevel_compat = qemu_opt_get(machine_opts, "dt_compatible");\n<150> if (ret < 0) {\n<152> fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");\n<162> if (ret < 0) {\n<164> fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");\n<190> if (ret < 0)\n<192> fprintf(stderr, "couldn't set /chosen/bootargs\n");\n<542> if (toplevel_compat) {\n<544> qemu_fdt_setprop(fdt, "/", "compatible", toplevel_compat,\n<546> strlen(toplevel_compat) + 1);
<1> static void flat_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n<2> printf ( "%s%s=%lld\n" , wctx -> section_pbuf [ wctx -> level ] . str , key , value ) ;
<15> if (!c)\n<37> if (build_filter(c->filter_bank, factor, c->filter_length, phase_count, 1<<FILTER_SHIFT, WINDOW_TYPE))\n<41> memcpy(&c->filter_bank[c->filter_length*phase_count+1], c->filter_bank, (c->filter_length-1)*sizeof(FELEM));\n<61> return c;
<1> static void filter(MpegAudioContext *s, int ch, short *samples, int incr)\n<31> s->samples_buf[ch][offset + (31 - i)] = samples[0];\n<41> p = s->samples_buf[ch] + offset;\n<121> if (offset < 0) {\n<123> memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32),\n<125> s->samples_buf[ch], (512 - 32) * 2);
<1> void cpu_x86_dump_state(CPUX86State *env, FILE *f, int flags)\n<9> static const char *seg_name[6] = { "ES", "CS", "SS", "DS", "FS", "GS" };\n<15> fprintf(f, "EAX=%08x EBX=%08x ECX=%08x EDX=%08x\n"\n<39> eflags & CC_C ? 'C' : '-',\n<41> env->hflags & HF_CPL_MASK,\n<43> (env->hflags >> HF_INHIBIT_IRQ_SHIFT) & 1,\n<45> (env->a20_mask >> 20) & 1);\n<47> for(i = 0; i < 6; i++) {\n<49> SegmentCache *sc = &env->segs[i];\n<93> fprintf(f, "CR0=%08x CR2=%08x CR3=%08x CR4=%08x\n",\n<99> if (flags & X86_DUMP_CCOP) {\n<103> strcpy(cc_op_name, cc_op_str[env->cc_op]);\n<107> snprintf(cc_op_name, sizeof(cc_op_name), "[%d]", env->cc_op);\n<115> if (flags & X86_DUMP_FPU) {
<1> CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n<9> ulen = strlen ( userp ) ;\n<10> plen = strlen ( passwdp ) ;\n<11> if ( ( ulen > SIZE_T_MAX / 4 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;\n<12> plainlen = 2 * ulen + plen + 2 ;\n<13> plainauth = malloc ( plainlen ) ;\n<14> if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;\n<15> memcpy ( plainauth , userp , ulen ) ;\n<16> plainauth [ ulen ] = '\0' ;\n<17> memcpy ( plainauth + ulen + 1 , userp , ulen ) ;\n<18> plainauth [ 2 * ulen + 1 ] = '\0' ;\n<19> memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ;\n<20> result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;\n<21> free ( plainauth ) ;
<1> static void process_client(AVIOContext *client, const char *in_uri)\n<11> uint8_t *resource = NULL;\n<13> while ((ret = avio_handshake(client)) > 0) {\n<15> av_opt_get(client, "resource", AV_OPT_SEARCH_CHILDREN, &resource);\n<21> if (resource && strlen(resource))\n<28> if (ret < 0)\n<32> av_log(client, AV_LOG_TRACE, "resource=%p\n", resource);\n<34> if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {\n<36> reply_code = 200;\n<40> reply_code = AVERROR_HTTP_NOT_FOUND;\n<60> if (ret < 0)\n<66> fprintf(stderr, "Handshake performed.\n");\n<68> if (reply_code != 200)\n<72> fprintf(stderr, "Opening input file.\n");\n<74> if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {\n<110> fprintf(stderr, "Flushing client\n");\n<114> fprintf(stderr, "Closing client\n");\n<118> fprintf(stderr, "Closing input\n");
<1> static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n<15> argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n<16> thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n<19> big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n<20> memcpy(big_buf, buf_temp, target_size);\n<21> buf_temp = big_buf;\n<22> host_dm = big_buf;
<1> int vp56_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<43> res = s->parse_header(s, buf, remaining_buf_size, &golden_frame);\n<51> if (!is_alpha) {\n<65> if (res == 2)\n<67> if (vp56_size_changed(avctx)) {\n<83> s->default_models_init(s);\n<93> vp56_parse_mb_type_models(s);\n<95> s->parse_vector_models(s);\n<103> s->parse_coeff_models(s);\n<107> memset(s->prev_dc, 0, sizeof(s->prev_dc));\n<145> for (mb_row=0; mb_row<s->mb_height; mb_row++) {\n<167> memset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));\n<169> memset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));\n<203> vp56_decode_mb(s, mb_row, mb_col, is_alpha);
<1> static void powerpc_set_compat(Object *obj, Visitor *v, const char *name,\n<9> char *value = NULL;\n<17> visit_type_str(v, name, &value, &error);\n<19> if (error) {\n<29> if (strcmp(value, "power6") == 0) {\n<31> *max_compat = CPU_POWERPC_LOGICAL_2_05;\n<33> } else if (strcmp(value, "power7") == 0) {\n<35> *max_compat = CPU_POWERPC_LOGICAL_2_06;\n<37> } else if (strcmp(value, "power8") == 0) {\n<39> *max_compat = CPU_POWERPC_LOGICAL_2_07;\n<43> error_setg(errp, "Invalid compatibility mode \"%s\"", value);\n<49> g_free(value);
<1> static int mpegts_push_data(MpegTSFilter *filter,\n<9> PESContext *pes = filter->u.pes_filter.opaque;\n<29> new_pes_packet(pes, ts->pkt);\n<43> p = buf;\n<47> switch(pes->state) {\n<51> len = PES_START_SIZE - pes->data_index;\n<53> if (len > buf_size)\n<55> len = buf_size;\n<57> memcpy(pes->header + pes->data_index, p, len);\n<59> pes->data_index += len;\n<61> p += len;\n<63> buf_size -= len;\n<71> if (pes->header[0] == 0x00 && pes->header[1] == 0x00 &&\n<73> pes->header[2] == 0x01) {\n<77> code = pes->header[3] | 0x100;\n<101> mpegts_set_stream_info(pes->st, pes, 0, 0);\n<181> len = PES_HEADER_SIZE - pes->data_index;\n<183> if (len < 0)\n<187> if (len > buf_size)\n<189> len = buf_size;\n<191> memcpy(pes->header + pes->data_index, p, len);\n<193> pes->data_index += len;\n<195> p += len;\n<197> buf_size -= len;\n<211> len = pes->pes_header_size - pes->data_index;\n<213> if (len < 0)\n<217> if (len > buf_size)\n<219> len = buf_size;\n<221> memcpy(pes->header + pes->data_index, p, len);\n<223> pes->data_index += len;\n<225> p += len;\n<227> buf_size -= len;\n<305> if (buf_size > 0 && pes->buffer) {\n<307> if (pes->data_index > 0 && pes->data_index+buf_size > pes->total_size) {\n<309> new_pes_packet(pes, ts->pkt);\n<315> if (!pes->buffer)\n<321> } else if (pes->data_index == 0 && buf_size > pes->total_size) {\n<327> buf_size = pes->total_size;\n<333> memcpy(pes->buffer+pes->data_index, p, buf_size);\n<335> pes->data_index += buf_size;\n<357> new_pes_packet(pes, ts->pkt);
<1> static int stream_component_open(VideoState *is, int stream_index)\n<101> if (SDL_OpenAudio(&wanted_spec, &spec) < 0) {\n<103> fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError());\n<119> switch(enc->codec_type) {\n<147> memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));
<1> static void bochs_bios_write(void *opaque, uint32_t addr, uint32_t val)\n<11> switch(addr) {\n<67> fprintf(stderr, "VGA BIOS panic, line %d\n", val);
<1> static void mips_fulong2e_init(MachineState *machine)\n<57> if (cpu == NULL) {\n<59> fprintf(stderr, "Unable to find CPU definition\n");\n<189> if (!isa_bus) {\n<191> fprintf(stderr, "vt82c686b_init error\n");
<1> int main ( int argc , char * * argv ) {\n<5> int frame_count = 0 ;\n<45> printf ( "Using %s\n" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n<61> encode_frame ( & codec , & raw , frame_count ++ , flags , writer ) ;\n<66> printf ( "\n" ) ;\n<68> printf ( "Processed %d frames.\n" , frame_count ) ;
<1> static void ref405ep_init(MachineState *machine)\n<227> if (linux_boot) {\n<235> memset(&bd, 0, sizeof(bd));\n<285> bdloc = ppc405_set_bootinfo(env, &bd, 0x00000001);\n<293> kernel_size = load_image_targphys(kernel_filename, kernel_base,\n<297> if (kernel_size < 0) {\n<299> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<317> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<321> if (initrd_size < 0) {\n<323> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<343> if (kernel_cmdline != NULL) {\n<345> len = strlen(kernel_cmdline);\n<347> bdloc -= ((len + 255) & ~255);\n<349> cpu_physical_memory_write(bdloc, kernel_cmdline, len + 1);\n<353> env->gpr[7] = bdloc + len;
<1> struct evdns_server_port * evdns_add_server_port ( int socket , int is_tcp , evdns_request_callback_fn_type cb , void * user_data ) {\n<3> if ( ! ( port = malloc ( sizeof ( struct evdns_server_port ) ) ) ) return NULL ;\n<4> memset ( port , 0 , sizeof ( struct evdns_server_port ) ) ;\n<5> assert ( ! is_tcp ) ;\n<6> port -> socket = socket ;\n<7> port -> refcnt = 1 ;\n<8> port -> choked = 0 ;\n<9> port -> closing = 0 ;\n<10> port -> user_callback = cb ;\n<11> port -> user_data = user_data ;\n<12> port -> pending_replies = NULL ;\n<13> event_set ( & port -> event , port -> socket , EV_READ | EV_PERSIST , server_port_ready_callback , port ) ;\n<14> event_add ( & port -> event , NULL ) ;\n<15> return port ;
<1> TSReturnCode TSMimeHdrFieldValueStringSet ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , const char * value , int length ) {\n<9> if ( length == - 1 ) {\n<10> length = strlen ( value ) ;\n<12> TSMimeFieldValueSet ( bufp , field , idx , value , length ) ;
<1> int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes,\n<23> VLC dyn_vlc = *vlc;\n<27> if (vlc->table_size)\n<51> memcpy(vlc->table, dyn_vlc.table, dyn_vlc.table_size * sizeof(*vlc->table));\n<55> ff_free_vlc(&dyn_vlc);
<1> static FormInfo * AddFormInfo ( char * value , char * contenttype , FormInfo * parent_form_info ) {\n<3> form_info = calloc ( 1 , sizeof ( struct FormInfo ) ) ;\n<12> parent_form_info -> more = form_info ;\n<14> return form_info ;
<21> if ( spl_filesystem_file_open ( intern , use_include_path , 0 TSRMLS_CC ) == SUCCESS ) {\n<22> tmp_path_len = strlen ( intern -> u . file . stream -> orig_path ) ;\n<23> if ( tmp_path_len > 1 && IS_SLASH_AT ( intern -> u . file . stream -> orig_path , tmp_path_len - 1 ) ) {\n<26> tmp_path = estrndup ( intern -> u . file . stream -> orig_path , tmp_path_len ) ;
<1> int test_sqr ( BIO * bp , BN_CTX * ctx ) {\n<29> if ( ! BN_is_zero ( d ) || ! BN_is_zero ( e ) ) {\n<30> fprintf ( stderr , "Square test failed!\n" ) ;\n<47> if ( BN_cmp ( c , d ) ) {\n<48> fprintf ( stderr , "Square test failed: BN_sqr and BN_mul produce " "different results!\n" ) ;\n<64> if ( BN_cmp ( c , d ) ) {\n<65> fprintf ( stderr , "Square test failed: BN_sqr and BN_mul produce " "different results!\n" ) ;
<324> for (k = 0; k < cur_blk_height; k++)\n<326> memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,
<1> static SvcInternal * get_svc_internal ( SvcContext * svc_ctx ) {\n<3> if ( svc_ctx -> internal == NULL ) {\n<4> SvcInternal * const si = ( SvcInternal * ) malloc ( sizeof ( * si ) ) ;\n<5> if ( si != NULL ) {\n<6> memset ( si , 0 , sizeof ( * si ) ) ;\n<8> svc_ctx -> internal = si ;
<17> if (!vps_buf)\n<213> if (s->vps_list[vps_id] &&\n<215> !memcmp(s->vps_list[vps_id]->data, vps_buf->data, vps_buf->size)) {\n<217> av_buffer_unref(&vps_buf);\n<223> s->vps_list[vps_id] = vps_buf;
<1> static int encode_thread(AVCodecContext *c, void *arg){\n<3> MpegEncContext *s= *(void**)arg;\n<71> memset(s->last_mv, 0, sizeof(s->last_mv));\n<89> s->gob_index = ff_h263_get_gob_height(s);\n<97> ff_mpeg4_init_partitions(s);\n<121> ff_set_qscale(s, s->qscale);\n<123> ff_init_block_index(s);\n<169> ff_update_block_index(s);\n<175> ff_h261_reorder_mb_index(s);\n<235> write_slice_end(s);\n<241> ff_mpeg4_init_partitions(s);\n<283> update_mb_info(s, 1);\n<293> ff_mpeg4_encode_video_packet_header(s);\n<295> ff_mpeg4_clean_buffers(s);\n<307> ff_mpeg1_encode_slice_header(s);\n<309> ff_mpeg1_clean_buffers(s);\n<321> ff_h263_encode_gob_header(s, mb_y);\n<371> update_mb_info(s, 0);\n<383> copy_context_before_encode(&backup_s, s, -1);\n<387> best_s.data_partitioning= s->data_partitioning;\n<389> best_s.partitioned_frame= s->partitioned_frame;\n<413> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_INTER, pb, pb2, tex_pb,\n<437> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_INTER_I, pb, pb2, tex_pb,\n<455> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_SKIPPED, pb, pb2, tex_pb,\n<477> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_INTER4V, pb, pb2, tex_pb,\n<495> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_FORWARD, pb, pb2, tex_pb,\n<513> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_BACKWARD, pb, pb2, tex_pb,\n<535> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_BIDIR, pb, pb2, tex_pb,\n<559> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_FORWARD_I, pb, pb2, tex_pb,\n<583> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_BACKWARD_I, pb, pb2, tex_pb,\n<611> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_BIDIR_I, pb, pb2, tex_pb,\n<629> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_INTRA, pb, pb2, tex_pb,\n<641> ff_clean_intra_table_entries(s); //old mode?\n<651> if(best_s.mv_type==MV_TYPE_16X16){ //FIXME move 4mv after QPRD\n<657> int16_t ac[6][16];\n<659> const int mvdir= (best_s.mv_dir&MV_DIR_BACKWARD) ? 1 : 0;\n<671> s->mv_dir= best_s.mv_dir;\n<675> s->mb_intra= best_s.mb_intra;\n<703> for(i=0; i<6; i++){\n<707> memcpy(ac[i], s->ac_val[0][s->block_index[i]], sizeof(int16_t)*16);\n<715> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_INTER /* wrong but unused */, pb, pb2, tex_pb,\n<719> if(best_s.qscale != qp){\n<723> for(i=0; i<6; i++){\n<727> memcpy(s->ac_val[0][s->block_index[i]], ac[i], sizeof(int16_t)*16);\n<755> ff_mpeg4_set_direct_mv(s, mx, my);\n<757> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_DIRECT, pb, pb2, tex_pb,\n<771> ff_mpeg4_set_direct_mv(s, 0, 0);\n<773> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_DIRECT, pb, pb2, tex_pb,\n<779> if (!best_s.mb_intra && s->mpv_flags & FF_MPV_FLAG_SKIP_RD) {\n<787> if(coded){\n<791> memcpy(s->mv, best_s.mv, sizeof(s->mv));\n<793> if(CONFIG_MPEG4_ENCODER && best_s.mv_dir & MV_DIRECT){\n<797> ff_mpeg4_set_direct_mv(s, mx, my);\n<799> }else if(best_s.mv_dir&MV_DIR_BACKWARD){\n<815> s->mv_dir= best_s.mv_dir;\n<817> s->mv_type = best_s.mv_type;\n<833> encode_mb_hq(s, &backup_s, &best_s, CANDIDATE_MB_TYPE_INTER /* wrong but unused */, pb, pb2, tex_pb,\n<845> s->current_picture.qscale_table[xy] = best_s.qscale;\n<849> copy_context_after_encode(s, &best_s, -1);\n<893> ff_h263_update_motion_val(s);\n<911> ff_MPV_decode_mb(s, s->block);\n<999> ff_mpeg4_set_direct_mv(s, motion_x, motion_y);\n<1013> ff_mpeg4_set_direct_mv(s, 0, 0);\n<1131> encode_mb(s, motion_x, motion_y);\n<1145> ff_h263_update_motion_val(s);\n<1149> ff_MPV_decode_mb(s, s->block);\n<1205> ff_h263_loop_filter(s);\n<1223> ff_msmpeg4_encode_ext_header(s);\n<1227> write_slice_end(s);
<1> static int build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table,\n<13> memset(huff_size, 0, sizeof(huff_size));\n<15> build_huffman_codes(huff_size, huff_code, bits_table, val_table);
<1> static inline void json_print_item_str ( WriterContext * wctx , const char * key , const char * value ) {\n<4> printf ( "\"%s\":" , json_escape_str ( & buf , key , wctx ) ) ;\n<6> printf ( " \"%s\"" , json_escape_str ( & buf , value , wctx ) ) ;
<1> static int mapped_filename_equals ( const u_char * filename , size_t filename_len , ngx_str_t * str ) {\n<2> return ( str -> len == filename_len && memcmp ( str -> data , filename , filename_len ) == 0 ) || ( str -> len == filename_len - 1 && filename [ filename_len - 1 ] == '/' && memcmp ( str -> data , filename , filename_len - 1 ) == 0 ) ;
<1> static void buffer_append(Buffer *buffer, const void *data, size_t len)\n<5> memcpy(buffer->buffer + buffer->offset, data, len);\n<7> buffer->offset += len;
<1> void vnc_display_open(DisplayState *ds, const char *display, Error **errp)\n<37> if (!vnc_display) {\n<47> if (strcmp(display, "none") == 0)\n<49> return;\n<53> vs->display = g_strdup(display);\n<55> vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n<59> options = display;\n<61> while ((options = strchr(options, ','))) {\n<63> options++;\n<65> if (strncmp(options, "password", 8) == 0) {\n<67> if (fips_get_state()) {\n<83> } else if (strncmp(options, "reverse", 7) == 0) {\n<87> } else if (strncmp(options, "no-lock-key-sync", 16) == 0) {\n<225> } else if (strncmp(options, "lossy", 5) == 0) {\n<229> } else if (strncmp(options, "non-adaptive", 12) == 0) {\n<233> } else if (strncmp(options, "share=", 6) == 0) {\n<235> if (strncmp(options+6, "ignore", 6) == 0) {\n<239> } else if (strncmp(options+6, "allow-exclusive", 15) == 0) {\n<243> } else if (strncmp(options+6, "force-shared", 12) == 0) {\n<327> if (password) {\n<463> vs->lock_key_sync = lock_key_sync;\n<467> if (reverse) {
<1> static void check_lowpass_line(int depth){\n<11> int mref = WIDTH_PADDED * -1;\n<37> memset(src,     0, SRC_SIZE);\n<39> memset(dst_ref, 0, WIDTH_PADDED);\n<41> memset(dst_new, 0, WIDTH_PADDED);\n<43> randomize_buffers(src, SRC_SIZE);\n<53> for (i = 0; i < 32; i++) { /* simulate crop */\n<55> call_ref(dst_ref, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n<57> call_new(dst_new, w, src + WIDTH_PADDED, mref - i*depth_byte, pref, 0);\n<59> if (memcmp(dst_ref, dst_new, WIDTH - i))\n<61> fail();\n<65> bench_new(dst_new, w, src + WIDTH_PADDED, mref, pref, 0);
<1> int show_license(void *optctx, const char *opt, const char *arg)
<1> static uint32_t get_cmd(ESPState *s, uint8_t *buf)\n<15> DPRINTF("get_cmd: len %d target %d\n", dmalen, target);\n<17> if (s->dma) {\n<25> memcpy(&buf[1], s->ti_buf, dmalen);\n<27> dmalen++;\n<63> esp_raise_irq(s);
<1> static void dequant ( float * out , const int * idx , const float * cbs [ ] ) {\n<6> i < num_vec ;\n<7> i ++ ) memcpy ( out + stride * i , cbs [ i ] + stride * idx [ i ] , stride * sizeof ( float ) ) ;
<1> int WriteTTC ( const char * filename , struct sflist * sfs , enum fontformat format , enum bitmapformat bf , int flags , int layer , enum ttc_flags ttcflags ) {\n<3> int ok = 1 ;\n<9> if ( strstr ( filename , "://" ) != NULL ) {\n<10> if ( ( ttc = tmpfile ( ) ) == NULL ) return ( 0 ) ;\n<13> if ( ( ttc = fopen ( filename , "wb+" ) ) == NULL ) return ( 0 ) ;\n<17> if ( ( ttcflags & ttc_flag_trymerge ) && bf == bf_none ) {\n<20> if ( ret == NULL ) dobruteforce = true ;\n<21> else ttc_dump ( ttc , ret , format , flags , ttcflags ) ;\n<22> free ( ret ) ;\n<24> if ( dobruteforce ) {\n<68> else if ( strstr ( filename , "://" ) != NULL && ok ) ok = URLFromFile ( filename , ttc ) ;\n<71> if ( ! ok ) LogError ( _ ( "Something went wrong" ) ) ;
<1> void y4m_input_close ( y4m_input * _y4m ) {\n<2> free ( _y4m -> dst_buf ) ;\n<3> free ( _y4m -> aux_buf ) ;
<1> static TRBCCode xhci_reset_ep(XHCIState *xhci, unsigned int slotid,\n<21> if (epid < 1 || epid > 31) {\n<23> fprintf(stderr, "xhci: bad ep %d\n", epid);\n<45> epctx = slot->eps[epid-1];\n<49> if (epctx->state != EP_HALTED) {\n<51> fprintf(stderr, "xhci: reset EP while EP %d not halted (%d)\n",\n<61> if (xhci_ep_nuke_xfers(xhci, slotid, epid) > 0) {\n<63> fprintf(stderr, "xhci: FIXME: endpoint reset w/ xfers running, "
<23> if ( rc ) rc_free = rc -> next ;\n<25> rc = cmd_hist . next ;\n<28> free ( rc -> buf ) ;\n<30> rc -> buf = command_buf . buf ;
<1> static ngx_int_t create_request ( ngx_http_request_t * r ) {\n<27> if ( context == NULL ) {\n<30> app_type_string = ( const u_char * ) pp_get_app_type_name ( context -> app_type ) ;\n<31> app_type_string_len = strlen ( ( const char * ) app_type_string ) + 1 ;\n<54> if ( r -> headers_in . host != NULL ) {\n<55> tmp = memchr ( r -> headers_in . host -> value . data , ':' , r -> headers_in . host -> value . len ) ;\n<56> if ( tmp == NULL ) {\n<57> server_name_len = r -> headers_in . host -> value . len ;\n<60> server_name_len = ( int ) ( ( const u_char * ) tmp - r -> headers_in . host -> value . data ) ;\n<74> len += sizeof ( "PASSENGER_APP_TYPE" ) + app_type_string_len ;\n<171> b -> last = ngx_copy ( b -> last , r -> headers_in . host -> value . data , server_name_len ) ;\n<188> b -> last = ngx_copy ( b -> last , app_type_string , app_type_string_len ) ;
<1> static int elf_core_dump(int signr, const CPUArchState *env)\n<119> if (dump_write(fd, &phdr, sizeof (phdr)) != 0)\n<145> for (vma = vma_first(mm); vma != NULL; vma = vma_next(vma)) {\n<147> (void) memset(&phdr, 0, sizeof (phdr));\n<179> bswap_phdr(&phdr, 1);\n<181> dump_write(fd, &phdr, sizeof (phdr));
<1> static int setup_test ( const char * name ) {\n<2> fprintf ( stdout , "%s" , name ) ;\n<3> if ( evutil_socketpair ( AF_UNIX , SOCK_STREAM , 0 , pair ) == - 1 ) {\n<4> fprintf ( stderr , "%s: socketpair\n" , __func__ ) ;
<1> void gx_device_copy_params ( gx_device * dev , const gx_device * target ) {\n<4> COPY_ARRAY_PARAM ( MediaSize ) ;\n<5> COPY_ARRAY_PARAM ( ImagingBBox ) ;\n<7> COPY_ARRAY_PARAM ( HWResolution ) ;\n<8> COPY_ARRAY_PARAM ( Margins ) ;\n<9> COPY_ARRAY_PARAM ( HWMargins ) ;
<1> static void printMapping ( UCMapping * m , UChar32 * codePoints , uint8_t * bytes , FILE * f ) {\n<4> j < m -> uLen ;\n<6> fprintf ( f , "<U%04lX>" , ( long ) codePoints [ j ] ) ;\n<8> fputc ( ' ' , f ) ;\n<10> j < m -> bLen ;\n<12> fprintf ( f , "\\x%02X" , bytes [ j ] ) ;\n<14> if ( m -> f >= 0 ) {\n<15> fprintf ( f , " |%u\n" , m -> f ) ;\n<18> fputs ( "\n" , f ) ;
<1> int tm_spawn ( int argc , char * * argv , char * * envp , tm_node_id where , tm_task_id * tid , tm_event_t * event ) {\n<9> if ( ( argc <= 0 ) || ( argv == NULL ) || ( argv [ 0 ] == NULL ) || ( * argv [ 0 ] == '\0' ) ) {\n<13> if ( startcom ( TM_SPAWN , * event , & chan ) != DIS_SUCCESS ) {\n<20> if ( diswsi ( chan , argc ) != DIS_SUCCESS ) {\n<25> i < argc ;\n<26> i ++ ) {\n<27> cp = argv [ i ] ;\n<28> if ( diswcs ( chan , cp , strlen ( cp ) ) != DIS_SUCCESS ) {\n<29> rc = TM_ENOTCONNECTED ;\n<33> if ( getenv ( "PBSDEBUG" ) != NULL ) {\n<34> if ( diswcs ( chan , "PBSDEBUG=1" , strlen ( "PBSDEBUG=1" ) ) != DIS_SUCCESS ) {\n<35> rc = TM_ENOTCONNECTED ;\n<39> if ( envp != NULL ) {\n<41> ( cp = envp [ i ] ) != NULL ;\n<42> i ++ ) {\n<43> if ( diswcs ( chan , cp , strlen ( cp ) ) != DIS_SUCCESS ) {\n<44> rc = TM_ENOTCONNECTED ;\n<49> if ( diswcs ( chan , "" , 0 ) != DIS_SUCCESS ) {\n<55> tm_spawn_cleanup : if ( chan != NULL ) DIS_tcp_cleanup ( chan ) ;
<1> static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, int frame_off)\n<39> dst = frame;\n<47> dst = frame_end - 1;\n<77> if (src < source || src >= source_end)\n<103> if (src < source || src >= source_end)\n<111> if (*src & 0xC)\n<129> NEXT_BYTE(src);\n<159> NEXT_BYTE(src);\n<175> if (len <= 0 || FFABS(dst_end - dst) < len)\n<185> if (dst - frame + SCREEN_WIDE < frame_off ||\n<187> dst - frame + SCREEN_WIDE + frame_off < 0 ||\n<189> frame_end - dst < frame_off + len ||\n<191> frame_end - dst < len)\n<197> dst[i] = dst[frame_off + i];\n<205> if (dst - frame + SCREEN_WIDE < frame_off ||\n<207> dst - frame + SCREEN_WIDE + frame_off < 0 ||\n<209> frame_end - dst < frame_off + len ||\n<211> frame_end - dst < len)\n<217> dst[i] = dst[frame_off + i];\n<227> if (source + src_len - src < len)\n<231> memcpy(dst, src, len);\n<233> dst += len;\n<235> src += len;\n<239> if (src - source < len)\n<243> dst -= len;\n<245> src -= len;\n<247> memcpy(dst, src, len);\n<255> val = forward ? dst[-1] : dst[1];\n<257> if (forward) {\n<259> memset(dst, val, len);\n<261> dst += len;\n<265> dst -= len;\n<267> memset(dst, val, len);\n<275> if (dst == dst_end)
<1> static jas_image_cmpt_t * jas_image_cmpt_create0 ( ) {\n<3> if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) {\n<6> memset ( cmpt , 0 , sizeof ( jas_image_cmpt_t ) ) ;\n<8> return cmpt ;
<1> static int file_to_archive ( struct cpio * cpio , const char * srcpath ) {\n<8> archive_entry_copy_sourcepath ( entry , srcpath ) ;\n<25> if ( cpio -> destdir ) {\n<26> len = strlen ( cpio -> destdir ) + strlen ( srcpath ) + 8 ;\n<27> if ( len >= cpio -> pass_destpath_alloc ) {\n<28> while ( len >= cpio -> pass_destpath_alloc ) {\n<32> free ( cpio -> pass_destpath ) ;\n<33> cpio -> pass_destpath = malloc ( cpio -> pass_destpath_alloc ) ;\n<34> if ( cpio -> pass_destpath == NULL ) lafe_errc ( 1 , ENOMEM , "Can't allocate path buffer" ) ;\n<36> strcpy ( cpio -> pass_destpath , cpio -> destdir ) ;\n<37> strcat ( cpio -> pass_destpath , remove_leading_slash ( srcpath ) ) ;\n<38> destpath = cpio -> pass_destpath ;\n<48> r = entry_to_archive ( cpio , entry ) ;\n<51> if ( r == 0 ) r = entry_to_archive ( cpio , spare ) ;
<1> static void http_failure_readcb ( struct bufferevent * bev , void * arg ) {\n<2> const char * what = "400 Bad Request" ;\n<3> if ( evbuffer_find ( bev -> input , ( const unsigned char * ) what , strlen ( what ) ) != NULL ) {
<1> static QString *read_line(FILE *file, char *key)\n<5> char value[128];\n<9> if (fscanf(file, "%s%s", key, value) == EOF)\n<11> return NULL;\n<13> remove_dots(key);\n<15> return qstring_from_str(value);
<1> struct evhttp_request * evhttp_request_new ( void ( * cb ) ( struct evhttp_request * , void * ) , void * arg ) {\n<3> if ( ( req = calloc ( 1 , sizeof ( struct evhttp_request ) ) ) == NULL ) {\n<4> event_warn ( "%s: calloc" , __func__ ) ;\n<7> req -> kind = EVHTTP_RESPONSE ;\n<8> req -> input_headers = calloc ( 1 , sizeof ( struct evkeyvalq ) ) ;\n<9> if ( req -> input_headers == NULL ) {\n<10> event_warn ( "%s: calloc" , __func__ ) ;\n<13> TAILQ_INIT ( req -> input_headers ) ;\n<14> req -> output_headers = calloc ( 1 , sizeof ( struct evkeyvalq ) ) ;\n<15> if ( req -> output_headers == NULL ) {\n<16> event_warn ( "%s: calloc" , __func__ ) ;\n<19> TAILQ_INIT ( req -> output_headers ) ;\n<30> return ( req ) ;\n<31> error : if ( req != NULL ) evhttp_request_free ( req ) ;\n<32> return ( NULL ) ;
<1> static pid_t name2pid ( char * name ) {\n<5> struct das_proclist * proclist = get_proclist ( & num_procs ) ;\n<7> lokke < num_procs ;\n<8> lokke ++ ) {\n<10> glibtop_get_proc_state ( & state , proclist [ lokke ] . pid ) ;\n<11> if ( ! strcmp ( state . cmd , name ) ) {\n<12> pid = proclist [ lokke ] . pid ;\n<16> free ( proclist ) ;
<1> void rfbReleaseClientIterator ( rfbClientIteratorPtr iterator ) {\n<3> free ( iterator ) ;
<1> static void s390_init(ram_addr_t my_ram_size,\n<4> const char *kernel_cmdline,\n<55> if (lduw_be_phys(KERN_IMAGE_START) != 0x0dd0) {\n<56> fprintf(stderr, "Specified image is not an s390 boot image\n");\n<89> if (kernel_cmdline) {\n<90> cpu_physical_memory_write(KERN_PARM_AREA, kernel_cmdline,\n<91> strlen(kernel_cmdline) + 1);\n<94> for(i = 0; i < nb_nics; i++) {\n<95> NICInfo *nd = &nd_table[i];\n<97> if (!nd->model) {\n<98> nd->model = g_strdup("virtio");\n<100> if (strcmp(nd->model, "virtio")) {\n<101> fprintf(stderr, "S390 only supports VirtIO nics\n");\n<102> exit(1);\n<105> qdev_set_nic_properties(dev, nd);
<1> static int wavpack_decode_block(AVCodecContext *avctx, int block_no,\n<53> if(!s){\n<63> memset(s->decorr, 0, MAX_TERMS * sizeof(Decorr));\n<65> memset(s->ch, 0, sizeof(s->ch));\n<677> samplecount = wv_unpack_stereo(s, &s->gb, samples, AV_SAMPLE_FMT_S16);\n<681> samplecount = wv_unpack_stereo(s, &s->gb, samples, AV_SAMPLE_FMT_S32);\n<685> samplecount = wv_unpack_stereo(s, &s->gb, samples, AV_SAMPLE_FMT_FLT);\n<705> samplecount = wv_unpack_mono(s, &s->gb, samples, AV_SAMPLE_FMT_S16);\n<709> samplecount = wv_unpack_mono(s, &s->gb, samples, AV_SAMPLE_FMT_S32);\n<713> samplecount = wv_unpack_mono(s, &s->gb, samples, AV_SAMPLE_FMT_FLT);
<1> static void hmac_md5 ( const char * password , char * challenge , unsigned char * response ) {\n<9> unsigned char secret [ MD5_BLOCK_LEN + 1 ] ;\n<11> secret_len = strlen ( password ) ;\n<12> if ( secret_len > MD5_BLOCK_LEN ) {\n<14> mutt_md5_bytes ( password , secret_len , hash_passwd ) ;\n<16> secret_len = MD5_DIGEST_LEN ;\n<18> else mutt_str_strfcpy ( ( char * ) secret , password , sizeof ( secret ) ) ;\n<19> memcpy ( ipad , secret , secret_len ) ;\n<20> memcpy ( opad , secret , secret_len ) ;\n<24> ipad [ i ] ^= 0x36 ;\n<25> opad [ i ] ^= 0x5c ;\n<28> mutt_md5_process_bytes ( ipad , MD5_BLOCK_LEN , & ctx ) ;\n<32> mutt_md5_process_bytes ( opad , MD5_BLOCK_LEN , & ctx ) ;
<1> USBDevice *usb_msd_init(const char *filename)\n<31> p1 = strchr(filename, ':');\n<33> if (p1++) {\n<39> if (strstart(filename, "format=", &p2)) {\n<47> } else if (*filename != ':') {\n<49> printf("unrecognized USB mass-storage option %s\n", filename);\n<59> if (!*filename) {\n<61> printf("block device specification needed\n");\n<67> qemu_opt_set(opts, "file", filename);
<1> void *pci_assign_dev_load_option_rom(PCIDevice *dev, struct Object *owner,\n<71> if (fwrite(&val, 1, 1, fp) != 1) {\n<83> memory_region_init_ram(&dev->rom, owner, name, st.st_size, &error_abort);\n<87> ptr = memory_region_get_ram_ptr(&dev->rom);\n<89> memset(ptr, 0xff, st.st_size);\n<93> if (!fread(ptr, 1, st.st_size, fp)) {
<1> static int ftp_passive_mode(FTPContext *s)\n<5> char *res = NULL, *start, *end;\n<15> if (ftp_send_command(s, command, pasv_codes, &res) != 227 || !res)\n<23> for (i = 0; i < strlen(res); ++i) {\n<25> if (res[i] == '(') {\n<27> start = res + i + 1;\n<29> } else if (res[i] == ')') {\n<31> end = res + i;\n<77> av_free(res);\n<85> av_free(res);
<1> static void tgq_decode_mb(TgqContext *s, int mb_y, int mb_x, const uint8_t **bs, const uint8_t *buf_end){\n<7> int8_t dc[6];\n<13> if (mode>buf_end-*bs) {\n<37> if (mode==3) {\n<39> memset(dc, (*bs)[0], 4);\n<45> }else if (mode==6) {\n<47> memcpy(dc, *bs, 6);\n<61> tgq_idct_put_mb_dconly(s, mb_x, mb_y, dc);\n<65> *bs += mode;
<1> static int apply_window_and_mdct(vorbis_enc_context *venc,\n<27> for (channel = 0; channel < venc->channels; channel++)\n<29> memcpy(venc->samples + channel * window_len * 2,\n<31> venc->saved + channel * window_len, sizeof(float) * window_len);\n<35> for (channel = 0; channel < venc->channels; channel++)\n<37> memset(venc->samples + channel * window_len * 2, 0,\n<39> sizeof(float) * window_len);\n<61> for (channel = 0; channel < venc->channels; channel++)\n<63> memset(venc->samples + channel * window_len * 2 + window_len,\n<65> 0, sizeof(float) * window_len);
<1> static void adx_encode(unsigned char *adx,const short *wav,\n<53> if (max==0 && min==0) {\n<55> memset(adx,0,18);
<1> static int rtp_parse_packet_internal(RTPDemuxContext *s, AVPacket *pkt,\n<3> const uint8_t *buf, int len)\n<21> ext          = buf[0] & 0x10;\n<25> if (buf[1] & 0x80)\n<67> if (buf[0] & 0x20) {\n<83> buf   += 12;\n<111> buf += ext;\n<121> ret = ff_mpegts_parse_packet(s->ts, pkt, buf, len);\n<133> if (ret < len) {\n<135> s->read_buf_size = len - ret;\n<137> memcpy(s->buf, buf + ret, s->read_buf_size);\n<159> switch (st->codec->codec_id) {\n<167> if (len <= 4)\n<175> buf += 4;\n<177> av_new_packet(pkt, len);\n<179> memcpy(pkt->data, buf, len);\n<195> buf += 4;\n<199> if (h & (1 << 26)) {\n<203> if (len <= 4)\n<207> buf += 4;\n<213> av_new_packet(pkt, len);\n<215> memcpy(pkt->data, buf, len);\n<221> av_new_packet(pkt, len);\n<223> memcpy(pkt->data, buf, len);\n<239> finalize_packet(s, pkt, timestamp);
<1> static void test_bug14845 ( ) {\n<5> const char * query = "select count(*) from t1 where 1 = 0" ;\n<15> check_execute ( stmt , rc ) ;\n<16> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<17> check_execute ( stmt , rc ) ;
<1> AudioState *AUD_init (void)\n<75> drvname = audio_get_conf_str ("QEMU_AUDIO_DRV", NULL, &def);\n<87> for (i = 0; i < ARRAY_SIZE (drvtab); i++) {\n<89> if (!strcmp (drvname, drvtab[i]->name)) {\n<91> done = !audio_driver_init (s, drvtab[i]);\n<93> found = 1;\n<105> dolog ("Unknown audio driver `%s'\n", drvname);\n<121> done = !audio_driver_init (s, drvtab[i]);
<1> static int test_streaming ( xd3_stream * in_stream , uint8_t * encbuf , uint8_t * decbuf , uint8_t * delbuf , usize_t megs ) {\n<12> i < megs ;\n<13> i += 1 ) {\n<14> ( ( usize_t * ) encbuf ) [ 0 ] = i ;\n<18> if ( ( ret = xd3_process_stream ( 1 , & estream , xd3_encode_input , 0 , encbuf , 1 << 20 , delbuf , & delsize , 1 << 20 ) ) ) {\n<22> if ( ( ret = xd3_process_stream ( 0 , & dstream , xd3_decode_input , 0 , delbuf , delsize , decbuf , & decsize , 1 << 20 ) ) ) {\n<26> if ( decsize != 1 << 20 || memcmp ( encbuf , decbuf , 1 << 20 ) != 0 ) {\n<27> in_stream -> msg = "wrong result" ;\n<28> ret = XD3_INTERNAL ;
<1> void wpa_sess_del ( u_char * sta ) {\n<5> LIST_FOREACH_SAFE ( e , & wpa_sess_root , next , tmp ) {\n<6> if ( ! memcmp ( & e -> sta , sta , ETH_ADDR_LEN ) ) {\n<8> USER_MSG ( "WPA session deleted for [%s]\n" , mac_addr_ntoa ( e -> sta , tmac ) ) ;
<1> static uint8_t eepro100_read1(EEPRO100State * s, uint32_t addr)\n<7> if (addr <= sizeof(s->mem) - sizeof(val)) {\n<9> memcpy(&val, &s->mem[addr], sizeof(val));\n<21> TRACE(OTHER, logout("addr=%s val=0x%02x\n", regname(addr), val));\n<27> TRACE(OTHER, logout("addr=%s val=0x%02x\n", regname(addr), val));\n<39> TRACE(OTHER, logout("addr=%s val=0x%02x\n", regname(addr), val));\n<45> TRACE(OTHER, logout("addr=%s val=0x%02x\n", regname(addr), val));\n<59> TRACE(OTHER, logout("addr=%s val=0x%02x\n", regname(addr), val));\n<69> TRACE(OTHER, logout("addr=General Status val=%02x\n", val));\n<75> logout("addr=%s val=0x%02x\n", regname(addr), val);\n<81> return val;
<1> int ff_alloc_picture(MpegEncContext *s, Picture *pic, int shared){\n<17> if(shared){\n<31> if (alloc_frame_buffer(s, pic) < 0)\n<115> memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);
<1> void do_outgoing_connection ( connection_t * c ) {\n<9> if ( ! c -> outgoing -> cfg ) {\n<17> get_config_string ( c -> outgoing -> cfg , & address ) ;\n<18> space = strchr ( address , ' ' ) ;\n<20> port = xstrdup ( space + 1 ) ;\n<24> if ( ! get_config_string ( lookup_config ( c -> config_tree , "Port" ) , & port ) ) {\n<28> c -> outgoing -> ai = str2addrinfo ( address , port , SOCK_STREAM ) ;\n<29> if ( ! c -> outgoing -> ai && proxytype != PROXY_NONE && is_valid_host_port ( address , port ) ) {\n<30> memset ( & c -> address , 0 , sizeof ( c -> address ) ) ;\n<36> free ( address ) ;\n<37> free ( port ) ;\n<45> if ( ! c -> outgoing -> aip ) {\n<52> memcpy ( & c -> address , c -> outgoing -> aip -> ai_addr , c -> outgoing -> aip -> ai_addrlen ) ;\n<54> connect : if ( c -> hostname ) {\n<55> free ( c -> hostname ) ;\n<57> c -> hostname = sockaddr2hostname ( & c -> address ) ;\n<58> ifdebug ( CONNECTIONS ) logger ( LOG_INFO , "Trying to connect to %s (%s)" , c -> name , c -> hostname ) ;\n<64> do_outgoing_pipe ( c , proxyhost ) ;\n<75> ifdebug ( CONNECTIONS ) logger ( LOG_ERR , "Creating socket for %s failed: %s" , c -> hostname , sockstrerror ( sockerrno ) ) ;\n<79> configure_tcp ( c ) ;\n<110> if ( bind ( c -> socket , & sa . sa , SALEN ( sa . sa ) ) ) {\n<112> logger ( LOG_ERR , "Can't bind to %s/tcp: %s" , addrstr , sockstrerror ( sockerrno ) ) ;\n<113> free ( addrstr ) ;
<1> static inline abi_long host_to_target_cmsg(struct target_msghdr *target_msgh,\n<39> void *data = CMSG_DATA(cmsg);\n<41> void *target_data = TARGET_CMSG_DATA(target_cmsg);\n<143> switch (cmsg->cmsg_level) {\n<147> switch (cmsg->cmsg_type) {\n<237> switch (cmsg->cmsg_type) {\n<309> switch (cmsg->cmsg_type) {\n<387> memcpy(target_data, data, MIN(len, tgt_len));\n<389> if (tgt_len > len) {\n<391> memset(target_data + len, 0, tgt_len - len);
<1> static void test_oid_to_str ( void ) {\n<42> for ( tidx = 0 ;\n<43> tests [ tidx ] . bin ;\n<44> tidx ++ ) {\n<46> if ( ! str ) {\n<50> if ( strcmp ( tests [ tidx ] . str , str ) ) {\n<51> fprintf ( stderr , "ksba_oid_to_str test %d failed\n" , tidx ) ;\n<52> fprintf ( stderr , " got=%s\n" , str ) ;\n<53> fprintf ( stderr , " want=%s\n" , tests [ tidx ] . str ) ;\n<54> exit ( 1 ) ;
<1> static int vtd_interrupt_remap_msi(IntelIOMMUState *iommu,\n<19> assert(origin && translated);\n<23> if (!iommu || !iommu->intr_enabled) {\n<47> addr.data = origin->address & VTD_MSI_ADDR_LO_MASK;\n<63> if (addr.int_mode != VTD_IR_INT_FORMAT_REMAP) {\n<171> memcpy(translated, origin, sizeof(*origin));
<1> static void svq3_add_idct_c(uint8_t *dst, int16_t *block,\n<19> block[0] = 0;\n<37> block[0 + 4 * i] = z0 + z3;\n<39> block[1 + 4 * i] = z1 + z2;\n<41> block[2 + 4 * i] = z1 - z2;\n<43> block[3 + 4 * i] = z0 - z3;\n<53> const unsigned z1 = 13 * (block[i + 4 * 0] -      block[i + 4 * 2]);\n<57> const unsigned z3 = 17 *  block[i + 4 * 1] +  7 * block[i + 4 * 3];\n<75> memset(block, 0, 16 * sizeof(int16_t));
<1> static void http_chunked_test ( void ) {\n<11> fprintf ( stdout , "Testing Chunked HTTP Reply: " ) ;\n<14> bev = bufferevent_new ( fd , http_chunked_readcb , http_chunked_writecb , http_chunked_errorcb , NULL ) ;\n<15> http_request = "GET /chunked HTTP/1.1\r\n" "Host: somehost\r\n" "Connection: close\r\n" "\r\n" ;\n<16> bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n<21> if ( tv_end . tv_sec >= 1 ) {\n<22> fprintf ( stdout , "FAILED (time)\n" ) ;\n<25> if ( test_ok != 2 ) {\n<26> fprintf ( stdout , "FAILED\n" ) ;\n<30> if ( evcon == NULL ) {\n<31> fprintf ( stdout , "FAILED\n" ) ;\n<40> if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , "/chunked" ) == - 1 ) {\n<41> fprintf ( stdout , "FAILED\n" ) ;\n<45> if ( test_ok != 1 ) {\n<46> fprintf ( stdout , "FAILED\n" ) ;\n<52> fprintf ( stdout , "OK\n" ) ;
<1> static void vqa_decode_chunk(VqaContext *s)\n<251> decode_format80(&s->buf[cbfz_chunk], chunk_size,\n<269> if (chunk_size > MAX_CODEBOOK_SIZE) {\n<283> memcpy(s->codebook, &s->buf[cbf0_chunk], chunk_size);\n<445> if (cbp0_chunk != -1) {\n<449> chunk_size = AV_RB32(&s->buf[cbp0_chunk + 4]);\n<457> memcpy(&s->next_codebook_buffer[s->next_codebook_buffer_index],\n<461> s->next_codebook_buffer_index += chunk_size;\n<467> if (s->partial_countdown == 0) {\n<491> if (cbpz_chunk != -1) {\n<495> chunk_size = AV_RB32(&s->buf[cbpz_chunk + 4]);\n<503> memcpy(&s->next_codebook_buffer[s->next_codebook_buffer_index],\n<507> s->next_codebook_buffer_index += chunk_size;
<1> static int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv)\n<5> static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b};\n<79> if (size < 32 || size - 32 < orig_size)\n<85> avio_read(pb, tmpbuf, 16);\n<89> av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1);\n<91> if (memcmp(tmpbuf, checkv, 16))\n<93> av_log(s, AV_LOG_ERROR, "probably incorrect decryption key\n");
<1> static BusState * qbus_find_bus ( DeviceState * dev , char * elem ) {\n<3> QLIST_FOREACH ( child , & dev -> child_bus , sibling ) {\n<4> if ( strcmp ( child -> name , elem ) == 0 ) {\n<5> return child ;\n<8> return NULL ;
<1> static void print_pem_cert ( FILE * out , certificate_t * cert ) {\n<3> if ( cert -> get_encoding ( cert , CERT_PEM , & encoded ) ) {\n<4> fprintf ( out , "%.*s" , ( int ) encoded . len , encoded . ptr ) ;\n<5> free ( encoded . ptr ) ;
<1> static unsigned long free_unpacked ( struct unpacked * n ) {\n<5> if ( n -> data ) {\n<7> free ( n -> data ) ;
<1> static int check_refcounts_l2(BlockDriverState *bs, BdrvCheckResult *res,\n<29> if (ret < 0) {\n<31> fprintf(stderr, "ERROR: I/O error in check_refcounts_l2\n");
<1> void rfbSetServerVersionIdentity ( rfbScreenInfoPtr screen , char * fmt , ... ) {\n<4> va_start ( ap , fmt ) ;\n<5> vsnprintf ( buffer , sizeof ( buffer ) - 1 , fmt , ap ) ;\n<6> va_end ( ap ) ;\n<7> if ( screen -> versionString != NULL ) free ( screen -> versionString ) ;\n<8> screen -> versionString = strdup ( buffer ) ;
<1> static void ppc_prep_init(MachineState *machine)\n<75> if (cpu == NULL) {\n<77> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<189> if (ppc_boot_device == '\0') {\n<191> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<231> if (pci_bus == NULL) {\n<233> fprintf(stderr, "Couldn't create PCI host controller.\n");\n<289> for(i = 0; i < nb_nics1; i++) {\n<291> if (nd_table[i].model == NULL) {\n<293> nd_table[i].model = g_strdup("ne2k_isa");\n<297> if (strcmp(nd_table[i].model, "ne2k_isa") == 0) {\n<299> isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],\n<301> &nd_table[i]);\n<305> pci_nic_init_nofail(&nd_table[i], pci_bus, "ne2k_pci", NULL);
<1> static void bufp_alloc(USBRedirDevice *dev, uint8_t *data, uint16_t len,\n<33> free(data);
<1> static int update_remote ( unsigned char * sha1 , struct remote_lock * lock ) {\n<14> if ( start_active_slot ( slot ) ) {\n<17> if ( results . curl_result != CURLE_OK ) {\n<18> fprintf ( stderr , "PUT error: curl result=%d, HTTP code=%ld\n" , results . curl_result , results . http_code ) ;\n<24> fprintf ( stderr , "Unable to start PUT request\n" ) ;
<1> static void filter(AVFilterContext *ctx)\n<5> IDETContext *idet = ctx->priv;\n<79> memmove(idet->history+1, idet->history, HIST_SIZE-1);
<1> int jbig2_decode_halftone_mmr ( Jbig2Ctx * ctx , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image , size_t * consumed_bytes ) {\n<3> const uint32_t rowstride = image -> stride ;\n<4> byte * dst = image -> data ;\n<11> y < image -> height ;\n<13> memset ( dst , 0 , rowstride ) ;\n<14> code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n<17> dst += rowstride ;
<1> static void qpeg_decode_inter(uint8_t *src, uint8_t *dst, int size,\n<5> int delta, uint8_t *ctable, uint8_t *refdata)\n<21> for(i = 0; i < height; i++)\n<23> memcpy(refdata + (i * width), dst + (i * stride), width);\n<101> me_plane = refdata + (filled + me_x) + (height - me_y) * width;\n<143> if(filled >= width) {\n<165> if(filled >= width) {\n<205> while( filled >= width) {\n<227> if(filled >= width) {
<1> x11grab_read_header(AVFormatContext *s1)\n<15> int x_off = 0;\n<17> int y_off = 0;\n<33> if (!param)\n<39> offset = strchr(param, '+');\n<41> if (offset) {\n<43> sscanf(offset, "%d,%d", &x_off, &y_off);\n<45> x11grab->draw_mouse = !strstr(offset, "nomouse");\n<69> av_log(s1, AV_LOG_INFO, "device: %s -> display: %s x: %d y: %d width: %d height: %d\n",\n<119> XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &x_off, &y_off, &ret, &ret, &ret);\n<121> x_off -= x11grab->width / 2;\n<123> y_off -= x11grab->height / 2;\n<311> x11grab->x_off = x_off;\n<313> x11grab->y_off = y_off;
<1> int main ( int argc , char * argv [ ] ) {\n<9> while ( argc >= 1 ) {\n<10> if ( strcmp ( * argv , "-results" ) == 0 ) results = 1 ;\n<11> else if ( strcmp ( * argv , "-out" ) == 0 ) {\n<12> if ( -- argc < 1 ) break ;\n<13> outfile = * ( ++ argv ) ;\n<15> argc -- ;\n<16> argv ++ ;
<1> static int vnc_set_x509_credential(VncDisplay *vd,\n<3> const char *certdir,\n<5> const char *filename,\n<19> *cred = g_malloc(strlen(certdir) + strlen(filename) + 2);\n<23> strcpy(*cred, certdir);\n<25> strcat(*cred, "/");\n<27> strcat(*cred, filename);\n<31> VNC_DEBUG("Check %s\n", *cred);
<1> void auth_client_request_continue ( struct auth_client_request * request , const char * data_base64 ) {\n<4> prefix = t_strdup_printf ( "CONT\t%u\t" , request -> id ) ;\n<6> iov [ 0 ] . iov_len = strlen ( prefix ) ;\n<8> iov [ 1 ] . iov_len = strlen ( data_base64 ) ;
<1> static int is_single_file ( const char * outfile_pattern ) {\n<2> const char * p = outfile_pattern ;\n<4> p = strchr ( p , '%' ) ;\n<5> if ( p && p [ 1 ] >= '1' && p [ 1 ] <= '9' ) return 0 ;\n<6> if ( p ) p ++ ;
<1> static int speex_header(AVFormatContext *s, int idx) {\n<11> uint8_t *p = os->buf + os->pstart;\n<55> if (st->codec->channels < 1 || st->codec->channels > 2) {\n<81> memcpy(st->codec->extradata, p, st->codec->extradata_size);
<1> static int push_single_pic(AVFilterLink *outlink)\n<9> const int nb_channels = inlink->channels;\n<11> const int ch_height = showwaves->split_channels ? outlink->h / nb_channels : outlink->h;\n<14> int64_t *sum = showwaves->sum;\n<16> memset(sum, 0, nb_channels);\n<23> for (ch = 0; ch < nb_channels; ch++)\n<24> sum[ch] += abs(p[ch + i*nb_channels]) << 1;\n<27> int16_t sample = sum[ch] / max_samples;
<1> static int matroska_merge_packets ( AVPacket * out , AVPacket * in ) {\n<2> int old_size = out -> size ;\n<3> int ret = av_grow_packet ( out , in -> size ) ;\n<4> if ( ret < 0 ) return ret ;\n<5> memcpy ( out -> data + old_size , in -> data , in -> size ) ;\n<6> av_free_packet ( in ) ;\n<7> av_free ( in ) ;
<1> static int parallels_open(BlockDriverState *bs, int flags)\n<17> if (bdrv_pread(bs->file, 0, &ph, sizeof(ph)) != sizeof(ph))\n<23> if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n<25> (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n<33> bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n<37> s->tracks = le32_to_cpu(ph.tracks);\n<41> s->catalog_size = le32_to_cpu(ph.catalog_entries);\n<43> s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n<45> if (bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4) !=\n<47> s->catalog_size * 4)\n<63> if (s->catalog_bitmap)\n<67> return -1;
<1> gpg_error_t keydb_search_kid ( KEYDB_HANDLE hd , u32 * kid ) {\n<3> memset ( & desc , 0 , sizeof desc ) ;\n<7> return keydb_search ( hd , & desc , 1 , NULL ) ;
<1> static int select_reference_stream(AVFormatContext *s)\n<5> SegmentContext *seg = s->priv_data;\n<13> if (!strcmp(seg->reference_stream_specifier, "auto")) {\n<17> int type_index_map[AVMEDIA_TYPE_NB];\n<37> for (i = 0; i < AVMEDIA_TYPE_NB; i++)\n<45> for (i = 0; i < s->nb_streams; i++) {\n<61> for (i = 0; i < FF_ARRAY_ELEMS(type_priority_list); i++) {\n<73> for (i = 0; i < s->nb_streams; i++) {\n<75> ret = avformat_match_stream_specifier(s, s->streams[i],\n<99> av_log(s, AV_LOG_ERROR, "Could not select stream matching identifier '%s'\n",
<1> void slirp_init(int restricted, struct in_addr vnetwork,\n<51> if (get_dns_addr(&dns_addr) < 0) {\n<55> fprintf (stderr, "Warning: No DNS servers found\n");
<1> static int glyphmatches ( SplineChar * sc , SplineChar * sc2 , int layer ) {\n<6> if ( sc -> ttf_instrs_len != sc2 -> ttf_instrs_len ) return ( false ) ;\n<7> if ( sc -> ttf_instrs_len != 0 && memcmp ( sc -> ttf_instrs , sc2 -> ttf_instrs , sc -> ttf_instrs_len ) != 0 ) return ( false ) ;\n<8> for ( r = sc -> layers [ layer ] . refs , r2 = sc2 -> layers [ layer ] . refs ;\n<9> r != NULL && r2 != NULL ;\n<10> r = r -> next , r2 = r2 -> next ) {\n<12> if ( r -> sc -> unicodeenc != r2 -> sc -> unicodeenc ) return ( false ) ;\n<13> if ( r -> sc -> unicodeenc == - 1 && strcmp ( r -> sc -> name , r2 -> sc -> name ) != 0 ) return ( false ) ;
<1> void hb_shape_plan_destroy ( hb_shape_plan_t * shape_plan ) {\n<2> if ( ! hb_object_destroy ( shape_plan ) ) return ;\n<5> free ( shape_plan ) ;
<1> static int parsedate ( const char * date , time_t * output ) {\n<6> int hournum = - 1 ;\n<7> int minnum = - 1 ;\n<15> while ( * date && ( part < 6 ) ) {\n<17> skip ( & date ) ;\n<18> if ( ISALPHA ( * date ) ) {\n<19> char buf [ 32 ] = "" ;\n<21> if ( sscanf ( date , "%31[ABCDEFGHIJKLMNOPQRSTUVWXYZ" "abcdefghijklmnopqrstuvwxyz]" , buf ) ) len = strlen ( buf ) ;\n<22> else len = 0 ;\n<24> wdaynum = checkday ( buf , len ) ;\n<28> monnum = checkmonth ( buf ) ;\n<32> tzoff = checktz ( buf ) ;\n<36> date += len ;\n<38> else if ( ISDIGIT ( * date ) ) {\n<41> int len = 0 ;\n<42> if ( ( secnum == - 1 ) && ( 3 == sscanf ( date , "%02d:%02d:%02d%n" , & hournum , & minnum , & secnum , & len ) ) ) {\n<43> date += len ;\n<45> else if ( ( secnum == - 1 ) && ( 2 == sscanf ( date , "%02d:%02d%n" , & hournum , & minnum , & len ) ) ) {\n<46> date += len ;\n<47> secnum = 0 ;\n<53> old_errno = ERRNO ;\n<54> SET_ERRNO ( 0 ) ;\n<55> lval = strtol ( date , & end , 10 ) ;\n<56> error = ERRNO ;\n<57> if ( error != old_errno ) SET_ERRNO ( old_errno ) ;\n<58> if ( error ) return PARSEDATE_FAIL ;\n<61> if ( ( tzoff == - 1 ) && ( ( end - date ) == 4 ) && ( val <= 1400 ) && ( indate < date ) && ( ( date [ - 1 ] == '+' || date [ - 1 ] == '-' ) ) ) {\n<64> tzoff = date [ - 1 ] == '+' ? - tzoff : tzoff ;\n<89> date = end ;\n<92> part ++ ;\n<94> if ( - 1 == secnum ) secnum = minnum = hournum = 0 ;
<1> static void test_long_data_str ( ) {\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<33> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<36> strmov ( data , "MySQL AB" ) ;\n<43> rc = mysql_stmt_execute ( stmt ) ;\n<44> if ( ! opt_silent ) fprintf ( stdout , " mysql_stmt_execute() returned %d\n" , rc ) ;\n<45> check_execute ( stmt , rc ) ;\n<56> sprintf ( data , "%d" , i * 5 ) ;\n<57> verify_col_data ( "test_long_data_str" , "LENGTH(longstr)" , data ) ;
<1> int set_wep_key ( char * string ) {\n<5> char s [ strlen ( string ) + 1 ] ;\n<6> u_char tmp_wkey [ 512 ] ;\n<9> memset ( GBL_WIFI -> wkey , 0 , sizeof ( GBL_WIFI -> wkey ) ) ;\n<11> strcpy ( s , string ) ;\n<16> tmp_wkey_len = bit / 8 - WEP_IV_LEN ;\n<22> if ( p == NULL ) SEMIFATAL_ERROR ( "Invalid parsing of the WEP key" ) ;\n<23> if ( type == 's' ) {\n<24> if ( strescape ( ( char * ) tmp_wkey , p , strlen ( tmp_wkey ) + 1 ) != ( int ) tmp_wkey_len ) SEMIFATAL_ERROR ( "Specified WEP key length does not match the given string" ) ;\n<33> USER_MSG ( "Using WEP key: %s\n" , str_tohex ( tmp_wkey , tmp_wkey_len , tmp , sizeof ( tmp ) ) ) ;\n<34> memcpy ( GBL_WIFI -> wkey , tmp_wkey , sizeof ( GBL_WIFI -> wkey ) ) ;
<1> void PSFontInterpretPS ( FILE * ps , struct charprocs * cp , char * * encoding ) {\n<9> wrapper . top = NULL ;\n<10> wrapper . advance_width = UNDEFINED_WIDTH ;\n<11> pushio ( & wrapper , ps , NULL , 0 ) ;\n<12> while ( ( tok = nextpstoken ( & wrapper , & dval , tokbuf , sizeof ( tokbuf ) ) ) != pt_eof && tok != pt_end ) {\n<14> if ( cp -> next >= cp -> cnt ) {\n<16> cp -> keys = realloc ( cp -> keys , cp -> cnt * sizeof ( char * ) ) ;\n<17> cp -> values = realloc ( cp -> values , cp -> cnt * sizeof ( char * ) ) ;\n<19> if ( cp -> next < cp -> cnt ) {\n<21> cp -> keys [ cp -> next ] = copy ( tokbuf ) ;\n<22> cp -> values [ cp -> next ++ ] = sc ;\n<28> memset ( & dummy , 0 , sizeof ( dummy ) ) ;\n<29> dummy . fromtype3 = true ;\n<30> InterpretPS ( ps , NULL , & dummy , NULL ) ;\n<34> free ( wrapper . top ) ;\n<39> ref != NULL ;\n<41> char * refname = ( char * ) ( ref -> sc ) ;\n<43> if ( ref -> sc == NULL ) refname = encoding [ ref -> orig_pos ] ;\n<45> j < cp -> next ;\n<46> ++ j ) if ( strcmp ( cp -> keys [ j ] , refname ) == 0 ) break ;\n<47> free ( ref -> sc ) ;\n<51> ref -> adobe_enc = getAdobeEnc ( ref -> sc -> name ) ;\n<59> RefCharFree ( ref ) ;
<1> static void iterative_me(SnowContext *s){\n<65> if(!s->me_cache_generation)\n<67> memset(s->me_cache, 0, sizeof(s->me_cache));\n<75> check_block(s, mb_x, mb_y, (int[2]){block->mx, block->my}, 0, &best_rd);\n<77> check_block(s, mb_x, mb_y, (int[2]){0, 0}, 0, &best_rd);\n<79> check_block(s, mb_x, mb_y, (int[2]){tb->mx, tb->my}, 0, &best_rd);\n<81> check_block(s, mb_x, mb_y, (int[2]){lb->mx, lb->my}, 0, &best_rd);\n<83> check_block(s, mb_x, mb_y, (int[2]){rb->mx, rb->my}, 0, &best_rd);\n<85> check_block(s, mb_x, mb_y, (int[2]){bb->mx, bb->my}, 0, &best_rd);\n<101> dia_change |= check_block(s, mb_x, mb_y, (int[2]){block->mx+4*(i-j), block->my+(4*j)}, 0, &best_rd);\n<103> dia_change |= check_block(s, mb_x, mb_y, (int[2]){block->mx-4*(i-j), block->my-(4*j)}, 0, &best_rd);\n<105> dia_change |= check_block(s, mb_x, mb_y, (int[2]){block->mx+4*(i-j), block->my-(4*j)}, 0, &best_rd);\n<107> dia_change |= check_block(s, mb_x, mb_y, (int[2]){block->mx-4*(i-j), block->my+(4*j)}, 0, &best_rd);\n<125> dia_change |= check_block(s, mb_x, mb_y, (int[2]){block->mx+square[i][0], block->my+square[i][1]}, 0, &best_rd);\n<135> color[i]= get_dc(s, mb_x, mb_y, i);\n<139> check_block(s, mb_x, mb_y, color, 1, &best_rd);
<1> void ConnectDatabase ( Archive * AHX , const char * dbname , const char * pghost , const char * pgport , const char * username , trivalue prompt_password ) {\n<2> ArchiveHandle * AH = ( ArchiveHandle * ) AHX ;\n<6> password = AH -> savedPassword ? pg_strdup ( AH -> savedPassword ) : NULL ;\n<7> if ( prompt_password == TRI_YES && password == NULL ) {\n<9> if ( password == NULL ) exit_horribly ( modulename , "out of memory\n" ) ;\n<32> if ( PQstatus ( AH -> connection ) == CONNECTION_BAD && PQconnectionNeedsPassword ( AH -> connection ) && password == NULL && prompt_password != TRI_NO ) {\n<35> if ( password == NULL ) exit_horribly ( modulename , "out of memory\n" ) ;\n<42> if ( AH -> savedPassword ) free ( AH -> savedPassword ) ;\n<45> if ( password ) free ( password ) ;
<1> static void add_remote_info_ref ( struct remote_ls_ctx * ls ) {\n<5> ref = alloc_ref ( ls -> dentry_name ) ;\n<6> if ( http_fetch_ref ( repo -> url , ref ) != 0 ) {\n<7> fprintf ( stderr , "Unable to fetch ref %s from %s\n" , ls -> dentry_name , repo -> url ) ;\n<9> free ( ref ) ;\n<12> o = parse_object ( ref -> old_oid . hash ) ;\n<13> if ( ! o ) {\n<14> fprintf ( stderr , "Unable to parse object %s for remote ref %s\n" , oid_to_hex ( & ref -> old_oid ) , ls -> dentry_name ) ;\n<16> free ( ref ) ;
<1> static int cin_decode_huffman ( const unsigned char * src , int src_size , unsigned char * dst , int dst_size ) {\n<3> unsigned char huff_code_table [ 15 ] ;\n<7> memcpy ( huff_code_table , src , 15 ) ;\n<8> src += 15 ;\n<16> else * dst_cur ++ = huff_code_table [ huff_code >> 4 ] ;\n<22> else * dst_cur ++ = huff_code_table [ huff_code ] ;
<1> static int qemu_rdma_exchange_send(RDMAContext *rdma, RDMAControlHeader *head,\n<51> if (ret) {\n<53> fprintf(stderr, "rdma migration: error posting"\n<73> if (ret) {\n<75> fprintf(stderr, "rdma migration: error posting first control recv!");\n<93> if (ret < 0) {\n<95> fprintf(stderr, "Failed to send control buffer!\n");
<1> void ff_aac_update_ltp(AACEncContext *s, SingleChannelElement *sce)\n<11> float *pred_signal = &sce->ltp_state[0];\n<57> if (!lag) {\n<95> memset(&pred_signal[samples_num], 0, (2048 - samples_num)*sizeof(float));
<1> static void handle_control_message(VirtIOSerial *vser, void *buf)\n<27> if (!port && cpkt.event != VIRTIO_CONSOLE_DEVICE_READY)\n<93> send_control_event(port, VIRTIO_CONSOLE_CONSOLE_PORT, 1);\n<99> if (port->name) {\n<107> buffer_len = sizeof(cpkt) + strlen(port->name) + 1;\n<109> buffer = qemu_malloc(buffer_len);\n<113> memcpy(buffer, &cpkt, sizeof(cpkt));\n<115> memcpy(buffer + sizeof(cpkt), port->name, strlen(port->name));\n<121> send_control_msg(port, buffer, buffer_len);\n<131> send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN, 1);\n<151> port->info->guest_ready(port);
<1> static void pci_ivshmem_exit(PCIDevice *dev)\n<37> if (munmap(addr, s->ivshmem_size) == -1) {\n<39> error_report("Failed to munmap shared memory %s", strerror(errno));
<1> static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n<13> if (buflen < ext_len) {\n<25> .len    = cpu_to_be32(len),\n<29> memcpy(buf + sizeof(QCowExtension), s, len);
<1> static int sendrequest ( int opcode , associd_t associd , int auth , int qsize , const char * qdata ) {\n<7> if ( qsize > CTL_MAX_DATA_LEN ) {\n<8> fprintf ( stderr , "***Internal error! qsize (%d) too large\n" , qsize ) ;\n<19> if ( qsize > 0 ) {\n<20> memcpy ( & qpkt . u , qdata , ( size_t ) qsize ) ;\n<36> if ( key_id == 0 || key_id > NTP_MAXKEY ) {\n<37> fprintf ( stderr , "Invalid key identifier\n" ) ;\n<44> if ( '\0' == pass [ 0 ] ) {\n<45> fprintf ( stderr , "Invalid password\n" ) ;\n<52> if ( ! maclen ) {\n<53> fprintf ( stderr , "Key not found\n" ) ;\n<56> else if ( ( size_t ) maclen != ( info_auth_hashlen + sizeof ( keyid_t ) ) ) {\n<57> fprintf ( stderr , "%d octet MAC, %zu expected with %zu octet digest\n" , maclen , ( info_auth_hashlen + sizeof ( keyid_t ) ) , info_auth_hashlen ) ;
<1> static int ffserver_parse_config_stream(FFServerConfig *config, const char *cmd, const char **p,\n<29> if (!stream)\n<55> q = strrchr(stream->filename, '>');\n<63> for (s = config->first_stream; s; s = s->next) {\n<65> if (!strcmp(stream->filename, s->filename))\n<67> ERROR("Stream '%s' already registered\n", s->filename);\n<73> stream->fmt = ffserver_guess_format(NULL, stream->filename, NULL);\n<101> ffserver_get_arg(arg, sizeof(arg), p);\n<103> sfeed = config->first_feed;\n<105> while (sfeed) {\n<107> if (!strcmp(sfeed->filename, arg))\n<111> sfeed = sfeed->next_feed;\n<115> if (!sfeed)\n<117> ERROR("Feed with name '%s' for stream '%s' is not defined\n", arg,\n<123> stream->feed = sfeed;\n<125> } else if (!av_strcasecmp(cmd, "Format")) {\n<127> ffserver_get_arg(arg, sizeof(arg), p);\n<129> if (!strcmp(arg, "status")) {\n<131> stream->stream_type = STREAM_TYPE_STATUS;\n<133> stream->fmt = NULL;\n<137> stream->stream_type = STREAM_TYPE_LIVE;\n<141> if (!strcmp(arg, "jpeg"))\n<143> strcpy(arg, "mjpeg");\n<145> stream->fmt = ffserver_guess_format(arg, NULL, NULL);\n<147> if (!stream->fmt)\n<183> } else if (!av_strcasecmp(cmd, "Author")    ||\n<185> !av_strcasecmp(cmd, "Comment")   ||\n<187> !av_strcasecmp(cmd, "Copyright") ||\n<189> !av_strcasecmp(cmd, "Title")) {\n<197> for (i = 0; i < strlen(cmd); i++)\n<199> key[i] = av_tolower(cmd[i]);\n<203> WARNING("'%s' option in configuration file is deprecated, "\n<287> } else if (!av_strcasecmp(cmd, "VideoBitRateRange")) {\n<291> ffserver_get_arg(arg, sizeof(arg), p);\n<293> if (sscanf(arg, "%d-%d", &minrate, &maxrate) == 2) {\n<295> if (av_dict_set_int(&config->video_conf, "VideoBitRateRangeMin", minrate, 0) < 0 ||\n<297> av_dict_set_int(&config->video_conf, "VideoBitRateRangeMax", maxrate, 0) < 0)\n<303> ERROR("Incorrect format for VideoBitRateRange -- should be "\n<495> } else if (!av_strcasecmp(cmd, "VideoTag")) {\n<497> ffserver_get_arg(arg, sizeof(arg), p);\n<499> if (strlen(arg) == 4) {\n<501> if (av_dict_set(&config->video_conf, "VideoTag", "arg", 0) < 0)\n<655> } else if (!av_strcasecmp(cmd, "</Stream>")) {\n<657> if (stream->feed && stream->fmt && strcmp(stream->fmt->name, "ffm")) {\n<659> if (config->dummy_actx->codec_id == AV_CODEC_ID_NONE)\n<663> if (!config->no_audio && config->dummy_actx->codec_id != AV_CODEC_ID_NONE) {\n<673> if (config->dummy_vctx->codec_id == AV_CODEC_ID_NONE)\n<677> if (!config->no_video && config->dummy_vctx->codec_id != AV_CODEC_ID_NONE) {\n<715> return 0;
<1> static void add_input_streams(OptionsContext *o, AVFormatContext *ic)\n<83> MATCH_PER_STREAM_OPT(hwaccels, str, hwaccel, ic, st);\n<85> if (hwaccel) {\n<87> if (!strcmp(hwaccel, "none"))\n<89> ist->hwaccel_id = HWACCEL_NONE;\n<91> else if (!strcmp(hwaccel, "auto"))\n<93> ist->hwaccel_id = HWACCEL_AUTO;\n<99> for (i = 0; hwaccels[i].name; i++) {\n<101> if (!strcmp(hwaccels[i].name, hwaccel)) {\n<103> ist->hwaccel_id = hwaccels[i].id;\n<113> if (!ist->hwaccel_id) {\n<115> av_log(NULL, AV_LOG_FATAL, "Unrecognized hwaccel: %s.\n",
<1> static int comp_lines ( const char * * a , const char * * b ) {\n<2> return ( strcmp ( * a , * b ) ) ;
<1> static void executeCommand ( PGconn * conn , const char * query ) {\n<3> if ( verbose ) fprintf ( stderr , _ ( "%s: executing %s\n" ) , progname , query ) ;\n<4> res = PQexec ( conn , query ) ;\n<5> if ( ! res || PQresultStatus ( res ) != PGRES_COMMAND_OK ) {\n<6> fprintf ( stderr , _ ( "%s: query failed: %s" ) , progname , PQerrorMessage ( conn ) ) ;\n<7> fprintf ( stderr , _ ( "%s: query was: %s\n" ) , progname , query ) ;
<1> static inline void tgq_dconly ( TgqContext * s , unsigned char * dst , int dst_stride , int dc ) {\n<2> int level = av_clip_uint8 ( ( dc * s -> qtable [ 0 ] + 2056 ) >> 4 ) ;\n<5> j < 8 ;\n<6> j ++ ) memset ( dst + j * dst_stride , level , 8 ) ;
<1> int evhttp_accept_socket ( struct evhttp * http , int fd ) {\n<5> bound = malloc ( sizeof ( struct evhttp_bound_socket ) ) ;\n<6> if ( bound == NULL ) return ( - 1 ) ;\n<11> if ( res == - 1 ) {\n<12> free ( bound ) ;
<1> static size_t qemu_rdma_fill(RDMAContext *rdma, uint8_t *buf,\n<11> if (rdma->wr_data[idx].control_len) {\n<19> len = MIN(size, rdma->wr_data[idx].control_len);\n<21> memcpy(buf, rdma->wr_data[idx].control_curr, len);\n<23> rdma->wr_data[idx].control_curr += len;\n<25> rdma->wr_data[idx].control_len -= len;\n<31> return len;
<1> static int send_xmessage_using_XAUTHORITY ( struct proclistlist * pll , int lokke , char * message ) {\n<5> if ( xa_filename != NULL ) {\n<6> if ( send_xmessage ( xa_filename , message ) == 1 ) {\n<7> free ( xa_filename ) ;\n<11> free ( xa_filename ) ;
<1> void do_savevm(Monitor *mon, const QDict *qdict)\n<9> QEMUSnapshotInfo sn1, *sn = &sn1, old_sn1, *old_sn = &old_sn1;\n<35> if (!bs) {\n<57> memset(sn, 0, sizeof(*sn));\n<65> pstrcpy(sn->name, sizeof(sn->name), old_sn->name);\n<67> pstrcpy(sn->id_str, sizeof(sn->id_str), old_sn->id_str);\n<71> pstrcpy(sn->name, sizeof(sn->name), name);\n<155> ret = bdrv_snapshot_create(bs1, sn);
<1> int dtls1_retransmit_message ( SSL * s , unsigned short seq , unsigned long frag_off , int * found ) {\n<8> unsigned char save_write_sequence [ 8 ] ;\n<9> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<10> seq64be [ 6 ] = ( unsigned char ) ( seq >> 8 ) ;\n<12> item = pqueue_find ( s -> d1 -> sent_messages , seq64be ) ;\n<13> if ( item == NULL ) {\n<14> fprintf ( stderr , "retransmit: message %d non-existant\n" , seq ) ;\n<19> frag = ( hm_fragment * ) item -> data ;\n<20> if ( frag -> msg_header . is_ccs ) header_length = DTLS1_CCS_HEADER_LENGTH ;\n<21> else header_length = DTLS1_HM_HEADER_LENGTH ;\n<22> memcpy ( s -> init_buf -> data , frag -> fragment , frag -> msg_header . msg_len + header_length ) ;\n<37> if ( frag -> msg_header . saved_retransmit_state . epoch == saved_state . epoch - 1 ) {\n<38> memcpy ( save_write_sequence , s -> s3 -> write_sequence , sizeof ( s -> s3 -> write_sequence ) ) ;\n<39> memcpy ( s -> s3 -> write_sequence , s -> d1 -> last_write_sequence , sizeof ( s -> s3 -> write_sequence ) ) ;\n<47> if ( frag -> msg_header . saved_retransmit_state . epoch == saved_state . epoch - 1 ) {\n<48> memcpy ( s -> d1 -> last_write_sequence , s -> s3 -> write_sequence , sizeof ( s -> s3 -> write_sequence ) ) ;\n<49> memcpy ( s -> s3 -> write_sequence , save_write_sequence , sizeof ( s -> s3 -> write_sequence ) ) ;
<1> static int kvm_physical_sync_dirty_bitmap(MemoryRegionSection *section)\n<27> if (mem == NULL) {\n<63> if (!d.dirty_bitmap) {\n<65> d.dirty_bitmap = g_malloc(size);\n<67> } else if (size > allocated_size) {\n<69> d.dirty_bitmap = g_realloc(d.dirty_bitmap, size);\n<73> allocated_size = size;\n<75> memset(d.dirty_bitmap, 0, allocated_size);\n<79> d.slot = mem->slot;\n<83> if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n<95> kvm_get_dirty_pages_log_range(section, d.dirty_bitmap);\n<101> g_free(d.dirty_bitmap);
<1> static int dv_decode_video_segment ( AVCodecContext * avctx , void * arg ) {\n<21> memset ( sblock , 0 , 5 * DV_MAX_BPM * sizeof ( * sblock ) ) ;
<1> static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {\n<4> const char * readable = "" ;\n<5> protocol = strsep ( & line , " " ) ;\n<6> if ( line == NULL ) return ( - 1 ) ;\n<8> if ( line != NULL ) readable = line ;\n<9> if ( strcmp ( protocol , "HTTP/1.0" ) == 0 ) {\n<10> req -> major = 1 ;\n<11> req -> minor = 0 ;\n<13> else if ( strcmp ( protocol , "HTTP/1.1" ) == 0 ) {\n<14> req -> major = 1 ;\n<15> req -> minor = 1 ;\n<18> event_debug ( ( "%s: bad protocol \"%s\"" , __func__ , protocol ) ) ;\n<19> return ( - 1 ) ;\n<21> req -> response_code = atoi ( number ) ;\n<22> if ( ! evhttp_valid_response_code ( req -> response_code ) ) {\n<26> if ( ( req -> response_code_line = strdup ( readable ) ) == NULL ) event_err ( 1 , "%s: strdup" , __func__ ) ;
<1> int load_initrd ( const char * filename , uint8_t * addr ) {\n<3> printf ( "Load initrd\n" ) ;\n<7> if ( size < 0 ) goto fail ;\n<9> printf ( "Load initrd: %d\n" , size ) ;\n<10> return size ;\n<12> printf ( "Load initrd failed\n" ) ;
<1> static int ram_block_enable_notify(const char *block_name, void *host_addr,\n<27> error_report("%s userfault register: %s", __func__, strerror(errno));
<1> int tm_taskinfo ( tm_node_id node , tm_task_id * tid_list , int list_size , int * ntasks , tm_event_t * event ) {\n<8> if ( diswsi ( chan , node ) != DIS_SUCCESS ) {\n<14> thold = ( struct taskhold * ) calloc ( 1 , sizeof ( struct taskhold ) ) ;\n<15> assert ( thold != NULL ) ;
<1> static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data,\n<73> flags = *data++;\n<141> data += 1;\n<173> data += 1;\n<209> n = matroska_ebmlnum_uint(matroska, data, size, &num);\n<221> data += n;\n<233> r = matroska_ebmlnum_sint(matroska, data, size, &snum);\n<245> data += r;\n<299> for (x=0; x<h/2; x++)\n<301> memcpy(track->audio.buf+x*2*w+y*cfs,\n<303> data+x*cfs, cfs);\n<307> for (x=0; x<w/sps; x++)\n<309> memcpy(track->audio.buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n<323> while (track->audio.pkt_cnt) {\n<327> av_new_packet(pkt, a);\n<331> + a * (h*w / a - track->audio.pkt_cnt--), a);\n<337> dynarray_add(&matroska->packets,&matroska->num_packets,pkt);\n<345> int offset = 0, pkt_size = lace_size[n];\n<347> uint8_t *pkt_data = data;\n<353> offset = matroska_decode_buffer(&pkt_data,&pkt_size, track);\n<355> if (offset < 0)\n<367> if (av_new_packet(pkt, pkt_size+offset) < 0) {\n<369> av_free(pkt);\n<377> if (offset)\n<379> memcpy (pkt->data, encodings->compression.settings.data, offset);\n<381> memcpy (pkt->data+offset, pkt_data, pkt_size);\n<385> if (pkt_data != data)\n<415> matroska_fix_ass_packet(matroska, pkt, duration);\n<427> matroska_merge_packets(matroska->prev_pkt, pkt);\n<431> dynarray_add(&matroska->packets,&matroska->num_packets,pkt);\n<433> matroska->prev_pkt = pkt;\n<445> data += lace_size[n];
<1> gcry_sexp_t gcry_sexp_nth ( const gcry_sexp_t list , int number ) {\n<11> if ( * p == ST_DATA ) {\n<12> memcpy ( & n , ++ p , sizeof n ) ;\n<13> p += sizeof n + n ;\n<28> p ++ ;\n<29> if ( * p == ST_DATA ) {\n<30> memcpy ( & n , p , sizeof n ) ;\n<31> p += sizeof n ;\n<32> newlist = gcry_malloc ( sizeof * newlist + n + 1 ) ;\n<33> if ( ! newlist ) return NULL ;\n<34> d = newlist -> d ;\n<35> memcpy ( d , p , n ) ;\n<36> d += n ;\n<44> if ( * p == ST_DATA ) {\n<45> memcpy ( & n , ++ p , sizeof n ) ;\n<46> p += sizeof n + n ;\n<60> n = p + 1 - head ;\n<61> newlist = gcry_malloc ( sizeof * newlist + n ) ;\n<62> if ( ! newlist ) return NULL ;\n<63> d = newlist -> d ;\n<64> memcpy ( d , head , n ) ;\n<65> d += n ;
<1> void lxc_cgroup_process_info_free ( struct cgroup_process_info * info ) {\n<3> if ( ! info ) return ;\n<5> lxc_cgroup_put_meta ( info -> meta_ref ) ;\n<6> free ( info -> cgroup_path ) ;\n<7> free ( info -> cgroup_path_sub ) ;\n<9> free ( info ) ;
<1> int ff_mpv_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n<13> if (!ff_thread_can_start_frame(avctx)) {\n<255> for(i=0; i<avctx->height; i++)\n<257> memset(s->last_picture_ptr->f->data[0] + s->last_picture_ptr->f->linesize[0]*i,\n<261> for(i=0; i<FF_CEIL_RSHIFT(avctx->height, v_chroma_shift); i++) {\n<263> memset(s->last_picture_ptr->f->data[1] + s->last_picture_ptr->f->linesize[1]*i,\n<265> 0x80, FF_CEIL_RSHIFT(avctx->width, h_chroma_shift));\n<267> memset(s->last_picture_ptr->f->data[2] + s->last_picture_ptr->f->linesize[2]*i,\n<269> 0x80, FF_CEIL_RSHIFT(avctx->width, h_chroma_shift));\n<277> for(i=0; i<avctx->height; i++)\n<279> memset(s->last_picture_ptr->f->data[0] + s->last_picture_ptr->f->linesize[0]*i, 16, avctx->width);
<1> void mime_hdr_copy_onto ( MIMEHdrImpl * s_mh , HdrHeap * s_heap , MIMEHdrImpl * d_mh , HdrHeap * d_heap , bool inherit_strs ) {\n<10> int bytes_below_top = end - ( char * ) s_mh ;\n<11> memcpy ( d_mh , s_mh , bytes_below_top ) ;\n<13> d_mh -> m_fblock_list_tail = & ( d_mh -> m_first_fblock ) ;\n<17> prev_d_fblock = & ( d_mh -> m_first_fblock ) ;\n<32> mime_hdr_field_block_list_adjust ( block_count , & ( s_mh -> m_first_fblock ) , & ( d_mh -> m_first_fblock ) ) ;\n<33> MIME_HDR_SANITY_CHECK ( s_mh ) ;\n<34> MIME_HDR_SANITY_CHECK ( d_mh ) ;
<1> struct VP8_COMP * vp8_create_compressor ( VP8_CONFIG * oxcf ) {\n<9> if ( setjmp ( cm -> error . jmp ) ) {\n<17> init_config ( cpi , oxcf ) ;\n<18> memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ;\n<128> vp8_init_first_pass ( cpi ) ;
<1> static int matroska_probe(AVProbeData *p)\n<13> if (AV_RB32(p->buf) != EBML_ID_HEADER)\n<39> total = (total << 8) | p->buf[4 + n++];\n<59> for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++) {\n<61> int probelen = strlen(matroska_doctypes[i]);\n<65> for (n = 4+size; n <= 4+size+total-probelen; n++)\n<67> if (!memcmp(p->buf+n, matroska_doctypes[i], probelen))\n<69> return AVPROBE_SCORE_MAX;
<1> err_status_t srtp_stream_dealloc ( srtp_t session , srtp_stream_ctx_t * stream ) {\n<33> if ( status ) return status ;\n<34> memset ( stream -> salt , 0 , SRTP_AEAD_SALT_LEN ) ;\n<35> memset ( stream -> c_salt , 0 , SRTP_AEAD_SALT_LEN ) ;\n<36> crypto_free ( stream ) ;
<1> static void pdf_init_csi ( fz_context * ctx , pdf_csi * csi , pdf_document * doc , pdf_obj * rdb , pdf_lexbuf * buf , fz_cookie * cookie ) {\n<2> memset ( csi , 0 , sizeof * csi ) ;
<1> static void mspack_fmap_copy ( void * src , void * dst , size_t num ) {\n<2> memcpy ( dst , src , num ) ;
<1> relpRetVal relpTcpConnect ( relpTcp_t * pThis , int family , unsigned char * port , unsigned char * host , unsigned char * clientIP ) {\n<11> memset ( & hints , 0 , sizeof ( hints ) ) ;\n<14> if ( getaddrinfo ( ( char * ) host , ( char * ) port , & hints , & res ) != 0 ) {\n<22> if ( getaddrinfo ( ( char * ) clientIP , ( char * ) NULL , & hints , & reslocal ) != 0 ) {
<1> int av_image_fill_linesizes(int linesizes[4], enum PixelFormat pix_fmt, int width)\n<15> memset(linesizes, 0, 4*sizeof(linesizes[0]));
<1> void open_input_file ( struct VpxInputContext * input ) {\n<2> input -> file = strcmp ( input -> filename , "-" ) ? fopen ( input -> filename , "rb" ) : set_binary_mode ( stdin ) ;\n<3> if ( ! input -> file ) fatal ( "Failed to open input file" ) ;
<1> static int roq_read_packet(AVFormatContext *s,\n<39> if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=\n<47> chunk_type = AV_RL16(&preamble[0]);\n<49> chunk_size = AV_RL32(&preamble[2]);\n<121> if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=\n<127> chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +\n<147> ret= av_get_packet(pb, pkt, chunk_size);\n<229> if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))\n<235> memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);\n<259> ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,
<1> static int verify_md5(HEVCContext *s, AVFrame *frame)\n<49> for (i = 0; frame->data[i]; i++) {\n<87> av_md5_final(s->md5_ctx, md5);\n<91> if (!memcmp(md5, s->md5[i], 16)) {\n<93> av_log   (s->avctx, AV_LOG_DEBUG, "plane %d - correct ", i);\n<95> print_md5(s->avctx, AV_LOG_DEBUG, md5);\n<97> av_log   (s->avctx, AV_LOG_DEBUG, "; ");\n<101> av_log   (s->avctx, AV_LOG_ERROR, "mismatching checksum of plane %d - ", i);\n<103> print_md5(s->avctx, AV_LOG_ERROR, md5);\n<105> av_log   (s->avctx, AV_LOG_ERROR, " != ");\n<107> print_md5(s->avctx, AV_LOG_ERROR, s->md5[i]);\n<109> av_log   (s->avctx, AV_LOG_ERROR, "\n");\n<111> return AVERROR_INVALIDDATA;
<1> int boot_sector_init(const char *fname)\n<5> FILE *f = fopen(fname, "w");\n<11> if (!f) {\n<13> fprintf(stderr, "Couldn't open \"%s\": %s", fname, strerror(errno));\n<23> if (strcmp(qtest_get_arch(), "ppc64") == 0) {\n<25> len = sprintf((char *)boot_sector, "\\ Bootscript\n%x %x c! %x %x c!\n",\n<27> LOW(SIGNATURE), BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET,\n<29> HIGH(SIGNATURE), BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1);\n<35> fwrite(boot_sector, 1, len, f);
<1> int decodenetnum ( const char * num , sockaddr_u * netnum ) {\n<2> struct addrinfo hints , * ai = NULL ;\n<10> REQUIRE ( num != NULL ) ;\n<11> if ( strlen ( num ) >= sizeof ( name ) ) {\n<12> return 0 ;\n<14> port_str = NULL ;\n<15> if ( '[' != num [ 0 ] ) {\n<16> pp = strchr ( num , ':' ) ;\n<17> if ( NULL == pp ) cp = num ;\n<18> else if ( NULL != strchr ( pp + 1 , ':' ) ) cp = num ;\n<20> strlcpy ( name , num , sizeof ( name ) ) ;\n<21> cp = name ;\n<22> pp = strchr ( cp , ':' ) ;\n<23> * pp = '\0' ;\n<24> port_str = pp + 1 ;\n<28> cp = num + 1 ;\n<35> ZERO ( hints ) ;\n<36> hints . ai_flags = Z_AI_NUMERICHOST ;\n<37> err = getaddrinfo ( cp , "ntp" , & hints , & ai ) ;\n<38> if ( err != 0 ) return 0 ;\n<39> INSIST ( ai -> ai_addrlen <= sizeof ( * netnum ) ) ;\n<40> ZERO ( * netnum ) ;\n<41> memcpy ( netnum , ai -> ai_addr , ai -> ai_addrlen ) ;\n<42> freeaddrinfo ( ai ) ;\n<43> if ( NULL == port_str || 1 != sscanf ( port_str , "%hu" , & port ) ) port = NTP_PORT ;\n<44> SET_PORT ( netnum , port ) ;
<1> int kvm_cpu_exec(CPUState *cpu)\n<39> cpu->kvm_vcpu_dirty = false;\n<71> attrs = kvm_arch_post_run(cpu, run);\n<77> if (run_ret == -EINTR || run_ret == -EAGAIN) {\n<89> strerror(-run_ret));\n<115> trace_kvm_run_exit(cpu->cpu_index, run->exit_reason);\n<189> ret = kvm_handle_internal_error(cpu, run);\n<230> ret = kvm_arch_handle_exit(cpu, run);\n<242> ret = kvm_arch_handle_exit(cpu, run);\n<256> if (ret < 0) {\n<258> cpu_dump_state(cpu, stderr, fprintf, CPU_DUMP_CODE);
<1> int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name , my_bool no_copy_stat ) {\n<14> if ( ! ( param -> testflag & T_SILENT ) ) printf ( "- Sorting index for MyISAM-table '%s'\n" , name ) ;\n<15> fn_format ( param -> temp_filename , name , "" , MI_NAME_IEXT , 2 + 4 + 32 ) ;
<1> CFDataRef ff_videotoolbox_hvcc_extradata_create(AVCodecContext *avctx)\n<7> const HEVCVPS *vps = (const HEVCVPS *)h->ps.vps_list[0]->data;\n<9> const HEVCSPS *sps = (const HEVCSPS *)h->ps.sps_list[0]->data;\n<15> PTLCommon ptlc = vps->ptl.general_ptl;\n<49> if (!vt_extradata)\n<53> p = vt_extradata;\n<83> memcpy(p + 2, ptlc.profile_compatibility_flag, 4);\n<249> AV_WB16(p + 3, vps->data_size);\n<253> memcpy(p + 5, vps->data, vps->data_size);\n<255> p += 5 + vps->data_size;\n<267> AV_WB16(p + 3, sps->data_size);\n<269> memcpy(p + 5, sps->data, sps->data_size);\n<271> p += 5 + sps->data_size;\n<287> if (h->ps.pps_list[i]) {\n<289> const HEVCPPS *pps = (const HEVCPPS *)h->ps.pps_list[i]->data;\n<291> AV_WB16(p, pps->data_size);\n<293> memcpy(p + 2, pps->data, pps->data_size);\n<295> p += 2 + pps->data_size;
<1> void host_net_remove_completion(ReadLineState *rs, int nb_args, const char *str)\n<11> len = strlen(str);\n<13> readline_set_completion_index(rs, len);\n<39> if (!strncmp(str, name, len)) {\n<75> if (!strncmp(str, name, len)) {
<1> static gpgme_error_t gpgsm_import ( void * engine , gpgme_data_t keydata , gpgme_key_t * keyarray ) {\n<13> if ( err ) return gpg_error ( GPG_ERR_NOT_SUPPORTED ) ;\n<14> for ( idx = 0 , buflen = 0 ;\n<17> if ( keyarray [ idx ] -> protocol == GPGME_PROTOCOL_CMS && keyarray [ idx ] -> subkeys && keyarray [ idx ] -> subkeys -> fpr && * keyarray [ idx ] -> subkeys -> fpr ) buflen += strlen ( keyarray [ idx ] -> subkeys -> fpr ) + 1 ;\n<19> buffer = malloc ( buflen + 1 ) ;\n<20> if ( ! buffer ) return gpg_error_from_syserror ( ) ;\n<24> if ( keyarray [ idx ] -> protocol == GPGME_PROTOCOL_CMS && keyarray [ idx ] -> subkeys && keyarray [ idx ] -> subkeys -> fpr && * keyarray [ idx ] -> subkeys -> fpr ) p = stpcpy ( stpcpy ( p , keyarray [ idx ] -> subkeys -> fpr ) , "\n" ) ;\n<26> err = gpgme_data_new_from_mem ( & gpgsm -> input_helper_data , buffer , buflen , 0 ) ;\n<27> if ( err ) {\n<28> free ( buffer ) ;\n<31> gpgsm -> input_helper_memory = buffer ;\n<33> err = gpgsm_set_fd ( gpgsm , INPUT_FD , map_data_enc ( gpgsm -> input_cb . data ) ) ;\n<34> if ( err ) {\n<37> free ( gpgsm -> input_helper_memory ) ;
<1> static void opt_frame_aspect_ratio(const char *arg)\n<15> p = strchr(arg, ':');\n<19> x = strtol(arg, &end, 10);\n<21> if (end == p)\n<31> ar = strtod(arg, NULL);\n<35> if (!ar) {\n<37> fprintf(stderr, "Incorrect aspect ratio specification.\n");\n<47> x = vfilters ? strlen(vfilters) : 0;\n<49> vfilters = av_realloc(vfilters, x+100);\n<51> snprintf(vfilters+x, x+100, "%csetdar=%f\n", x?',':' ', ar);
<1> static void print_sdp(void)\n<23> av_sdp_create(avc, nb_output_files, sdp, sizeof(sdp));\n<25> printf("SDP:\n%s\n", sdp);
<1> static void free_history_entry ( krb5_context context , osa_pw_hist_ent * hist ) {\n<5> i ++ ) krb5_free_key_data_contents ( context , & hist -> key_data [ i ] ) ;\n<6> free ( hist -> key_data ) ;
<1> static void dump_ah_combs ( struct sk_buff * skb , const struct xfrm_tmpl * t ) {\n<4> p = ( struct sadb_prop * ) skb_put ( skb , sizeof ( struct sadb_prop ) ) ;\n<8> memset ( p -> sadb_prop_reserved , 0 , sizeof ( p -> sadb_prop_reserved ) ) ;\n<15> if ( aalg_tmpl_set ( t , aalg ) && aalg -> available ) {\n<17> c = ( struct sadb_comb * ) skb_put ( skb , sizeof ( struct sadb_comb ) ) ;\n<18> memset ( c , 0 , sizeof ( * c ) ) ;\n<20> c -> sadb_comb_auth = aalg -> desc . sadb_alg_id ;\n<21> c -> sadb_comb_auth_minbits = aalg -> desc . sadb_alg_minbits ;\n<22> c -> sadb_comb_auth_maxbits = aalg -> desc . sadb_alg_maxbits ;\n<23> c -> sadb_comb_hard_addtime = 24 * 60 * 60 ;\n<24> c -> sadb_comb_soft_addtime = 20 * 60 * 60 ;\n<25> c -> sadb_comb_hard_usetime = 8 * 60 * 60 ;\n<26> c -> sadb_comb_soft_usetime = 7 * 60 * 60 ;
<1> MSG_PROCESS_RETURN tls_process_finished ( SSL * s , PACKET * pkt ) {\n<15> if ( CRYPTO_memcmp ( PACKET_data ( pkt ) , s -> s3 -> tmp . peer_finish_md , i ) != 0 ) {\n<20> if ( s -> server ) {\n<21> OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n<22> memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . peer_finish_md , i ) ;\n<23> s -> s3 -> previous_client_finished_len = i ;\n<26> OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n<27> memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . peer_finish_md , i ) ;\n<28> s -> s3 -> previous_server_finished_len = i ;
<1> static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s,\n<13> if (!buffer)\n<39> if (s->last_dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n<43> memcpy(buffer, s->last_picture.f->data[0], s->image_linesize * s->height);\n<49> for (y = s->last_y_offset; y < s->last_y_offset + s->last_h; ++y)\n<51> memset(buffer + s->image_linesize * y + s->bpp * s->last_x_offset, 0, s->bpp * s->last_w);\n<55> memcpy(s->previous_picture.f->data[0], buffer, s->image_linesize * s->height);\n<63> memcpy(buffer, s->previous_picture.f->data[0], s->image_linesize * s->height);\n<73> for (y = s->y_offset; y < s->y_offset + s->cur_h; ++y) {\n<75> size_t row_start = s->image_linesize * y + s->bpp * s->x_offset;\n<77> memcpy(buffer + row_start, p->data[0] + row_start, s->bpp * s->cur_w);\n<85> uint8_t *foreground = p->data[0] + s->image_linesize * y + s->bpp * s->x_offset;\n<87> uint8_t *background = buffer + s->image_linesize * y + s->bpp * s->x_offset;\n<89> for (x = s->x_offset; x < s->x_offset + s->cur_w; ++x, foreground += s->bpp, background += s->bpp) {\n<95> uint8_t output[4];\n<147> if (foreground_alpha == 255) {\n<149> memcpy(background, foreground, s->bpp);\n<157> if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n<163> background[0] = foreground[0];\n<175> for (b = 0; b < s->bpp - 1; ++b) {\n<183> output[b] = FAST_DIV255(foreground_alpha * foreground[b] + (255 - foreground_alpha) * background[b]);\n<187> output[b] = (255 * foreground_alpha * foreground[b] + (255 - foreground_alpha) * background_alpha * background[b]) / (255 * output_alpha);\n<193> output[b] = output_alpha;\n<195> memcpy(background, output, s->bpp);\n<207> memcpy(p->data[0], buffer, s->image_linesize * s->height);\n<209> av_free(buffer);
<1> int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)\n<195> if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)\n<203> if(st->parser && st->parser->parser->split && !st->codec->extradata)\n<291> pkt = &pkt1;\n<299> if ((ret = av_dup_packet(pkt)) < 0)\n<397> && (   !strcmp(ic->iformat->name, "mpeg") // this breaks some flvs thus use only for mpegps/ts for now (for ts we have a sample that needs it)\n<399> || !strcmp(ic->iformat->name, "mpegts"))\n<493> if(st->parser && st->parser->parser->split && !st->codec->extradata){\n<495> int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);\n<497> if (i > 0 && i < FF_MAX_EXTRADATA_SIZE) {\n<499> st->codec->extradata_size= i;\n<501> st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<503> if (!st->codec->extradata)\n<507> memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);\n<509> memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<535> try_decode_frame(st, pkt, (options && i < orig_nb_streams ) ? &options[i] : NULL);\n<603> avcodec_close(st->codec);\n<681> if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)\n<687> && tb_unreliable(st->codec)) {\n<823> avcodec_string(buf, sizeof(buf), st->codec, 0);
<1> static FILE * Needs816Enc ( SplineFont * sf , int * tlen , EncMap * map , FILE * * apple , int * appletlen ) {\n<13> if ( ( strstrmatch ( encname , "big" ) != NULL && strchr ( encname , '5' ) != NULL ) || strstrmatch ( encname , "johab" ) != NULL || strstrmatch ( encname , "sjis" ) != NULL || strstrmatch ( encname , "cp932" ) != NULL || strstrmatch ( encname , "euc-kr" ) != NULL || strstrmatch ( encname , "euc-cn" ) != NULL ) ;\n<14> else if ( strstrmatch ( encname , "2022" ) != NULL && ( strstrmatch ( encname , "JP2" ) != NULL || strstrmatch ( encname , "JP-2" ) != NULL || strstrmatch ( encname , "JP-3" ) != NULL ) ) return ( NULL ) ;\n<23> if ( strstrmatch ( encname , "sjis" ) != NULL ) {
<1> void config_nic_rules ( config_tree * ptree ) {\n<19> prefixlen = - 1 ;\n<22> switch ( curr_node -> match_class ) {\n<26> case 0 : NTP_INSIST ( if_name != NULL ) ;\n<27> pchSlash = strchr ( if_name , '/' ) ;\n<28> if ( pchSlash != NULL ) * pchSlash = '\0' ;\n<29> if ( is_ip_address ( if_name , AF_UNSPEC , & addr ) ) {\n<31> if ( pchSlash != NULL ) {\n<32> sscanf ( pchSlash + 1 , "%d" , & prefixlen ) ;\n<34> prefixlen = max ( - 1 , prefixlen ) ;\n<35> prefixlen = min ( prefixlen , addrbits ) ;\n<40> if ( pchSlash != NULL ) * pchSlash = '/' ;\n<63> add_nic_rule ( match_type , if_name , prefixlen , action ) ;\n<65> if ( if_name != NULL ) free ( if_name ) ;
<1> static void get_cx_data ( struct stream_state * stream , struct VpxEncoderConfig * global , int * got_data ) {\n<13> if ( ! global -> quiet ) fprintf ( stderr , " %6luF" , ( unsigned long ) pkt -> data . frame . sz ) ;
<1> CURLcode Curl_http_setup_conn ( struct connectdata * conn ) {\n<4> http = calloc ( 1 , sizeof ( struct HTTP ) ) ;\n<5> if ( ! http ) return CURLE_OUT_OF_MEMORY ;
<1> static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt)\n<9> VBDecContext * const c = avctx->priv_data;\n<31> if(avctx->get_buffer(avctx, &c->pic) < 0){\n<55> offset = i + j * avctx->width;\n<73> vb_decode_framedata(c, c->stream, size, offset);\n<81> if(flags & VB_HAS_PALETTE){\n<85> if(size > rest){\n<93> vb_decode_palette(c, size);\n<101> memcpy(c->pic.data[1], c->pal, AVPALETTE_SIZE);\n<107> outptr = c->pic.data[0];\n<109> srcptr = c->frame;\n<113> for(i = 0; i < avctx->height; i++){\n<115> memcpy(outptr, srcptr, avctx->width);\n<117> srcptr += avctx->width;\n<119> outptr += c->pic.linesize[0];
<1> static void test_bug14210 ( ) {\n<20> mysql_stmt_attr_set ( stmt , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;\n<21> stmt_text = "select a from t1" ;\n<22> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<23> check_execute ( stmt , rc ) ;
<1> static int cpudef_setfield(const char *name, const char *str, void *opaque)\n<5> x86_def_t *def = opaque;\n<11> if (!strcmp(name, "name")) {\n<14> def->name = g_strdup(str);\n<16> } else if (!strcmp(name, "model_id")) {\n<18> strncpy(def->model_id, str, sizeof (def->model_id));\n<20> } else if (!strcmp(name, "level")) {\n<22> setscalar(&def->level, str, &err)\n<24> } else if (!strcmp(name, "vendor")) {\n<26> cpyid(&str[0], &def->vendor1);\n<28> cpyid(&str[4], &def->vendor2);\n<30> cpyid(&str[8], &def->vendor3);\n<32> } else if (!strcmp(name, "family")) {\n<34> setscalar(&def->family, str, &err)\n<36> } else if (!strcmp(name, "model")) {\n<38> setscalar(&def->model, str, &err)\n<40> } else if (!strcmp(name, "stepping")) {\n<42> setscalar(&def->stepping, str, &err)\n<44> } else if (!strcmp(name, "feature_edx")) {\n<46> setfeatures(&def->features, str, feature_name, &err);\n<48> } else if (!strcmp(name, "feature_ecx")) {\n<50> setfeatures(&def->ext_features, str, ext_feature_name, &err);\n<52> } else if (!strcmp(name, "extfeature_edx")) {\n<54> setfeatures(&def->ext2_features, str, ext2_feature_name, &err);\n<56> } else if (!strcmp(name, "extfeature_ecx")) {\n<58> setfeatures(&def->ext3_features, str, ext3_feature_name, &err);\n<60> } else if (!strcmp(name, "xlevel")) {\n<62> setscalar(&def->xlevel, str, &err)\n<66> fprintf(stderr, "error: unknown option [%s = %s]\n", name, str);\n<68> return (1);\n<72> if (err) {\n<74> fprintf(stderr, "error: bad option value [%s = %s]\n", name, str);
<1> static int vnc_update_stats(VncDisplay *vd,  struct timeval * tv)\n<51> VncRectStat *rect= vnc_stat_rect(vd, x, y);\n<53> int count = ARRAY_SIZE(rect->times);\n<59> if (!timerisset(&rect->times[count - 1])) {\n<73> if (timercmp(&res, &VNC_REFRESH_LOSSY, >)) {\n<79> memset(rect->times, 0, sizeof (rect->times));
<1> static CharDriverState *qemu_chr_open_pipe(QemuOpts *opts)\n<13> if (filename == NULL) {\n<15> fprintf(stderr, "chardev: pipe: no filename given\n");
<1> static void print_time ( const char * label , int64_t etl ) {\n<5> if ( etl >= 0 ) {\n<14> fprintf ( stderr , "[%3s unknown] " , label ) ;
<216> if (len < 0)\n<221> memset(buf, 0, 12);
<1> static void guest_suspend(const char *pmutils_bin, const char *sysfile_str,\n<19> if (pid == 0) {\n<55> if (!sysfile_str) {\n<65> if (fd < 0) {\n<73> if (write(fd, sysfile_str, strlen(sysfile_str)) < 0) {\n<75> _exit(EXIT_FAILURE);
<1> static int vb_decode_framedata ( VBDecContext * c , int offset ) {\n<12> prev = c -> prev_frame + offset ;\n<13> cur = c -> frame ;\n<25> y ++ ) if ( check_line ( prev + y * width , pstart , pend ) ) memcpy ( cur + y * width , prev + y * width , 4 ) ;\n<26> else memset ( cur + y * width , 0 , 4 ) ;\n<44> y ++ ) if ( check_line ( prev + t + y * width , pstart , pend ) ) memcpy ( cur + y * width , prev + t + y * width , 4 ) ;\n<45> else memset ( cur + y * width , 0 , 4 ) ;\n<48> case 0x80 : t = bytestream2_get_byte ( & g ) ;\n<50> y < 4 ;\n<51> y ++ ) memset ( cur + y * width , t , 4 ) ;\n<63> x ++ , pattern >>= 1 ) cur [ x + y * width ] = ( pattern & 1 ) ? b : a ;\n<71> x ++ , pattern >>= 1 ) if ( pattern & 1 && check_pixel ( prev + x + y * width , pstart , pend ) ) cur [ x + y * width ] = prev [ x + y * width ] ;\n<72> else cur [ x + y * width ] = a ;\n<80> cur += 4 ;\n<81> prev += 4 ;\n<85> cur += width * 3 ;\n<86> prev += width * 3 ;
<1> static void setup_BAT ( CPUPPCState * env , int BAT , uint32_t virtual , uint32_t physical , uint32_t size , int Vs , int Vp , int PP ) {\n<15> env -> DBAT [ 0 ] [ BAT ] = tmp ;\n<20> env -> DBAT [ 1 ] [ BAT ] = tmp ;\n<22> printf ( "Set BATU0 to 0x%08x BATL0 to 0x%08x\n" , env -> DBAT [ 0 ] [ BAT ] , env -> DBAT [ 1 ] [ BAT ] ) ;
<1> BlockDriverState *bdrv_find_backing_image(BlockDriverState *bs,\n<38> is_protocol = path_has_protocol(backing_file);\n<42> for (curr_bs = bs; curr_bs->backing; curr_bs = curr_bs->backing->bs) {\n<50> if (is_protocol || path_has_protocol(curr_bs->backing_file)) {\n<52> if (strcmp(backing_file, curr_bs->backing_file) == 0) {\n<54> retval = curr_bs->backing->bs;\n<62> bdrv_get_full_backing_filename(curr_bs, backing_file_full, PATH_MAX,\n<64> &local_error);\n<66> if (local_error == NULL) {\n<68> if (strcmp(backing_file, backing_file_full) == 0) {\n<70> retval = curr_bs->backing->bs;\n<90> path_combine(filename_tmp, PATH_MAX, curr_bs->filename,\n<98> if (!realpath(filename_tmp, filename_full)) {\n<110> path_combine(filename_tmp, PATH_MAX, curr_bs->filename,\n<116> if (!realpath(filename_tmp, backing_file_full)) {\n<124> if (strcmp(backing_file_full, filename_full) == 0) {\n<126> retval = curr_bs->backing->bs;\n<138> g_free(filename_full);\n<140> g_free(backing_file_full);
<1> static void report_progress ( const MYSQL * mysql , uint stage , uint max_stage , double progress , const char * proc_info , uint proc_info_length ) {\n<2> uint length = printf ( "Stage: %d of %d '%.*s' %6.3g%% of stage done" , stage , max_stage , proc_info_length , proc_info , progress ) ;\n<3> if ( length < last_progress_report_length ) printf ( "%*s" , last_progress_report_length - length , "" ) ;
<1> static void remove_short_at_index ( H264Context * h , int i ) {\n<3> h -> short_ref [ i ] = NULL ;\n<4> if ( -- h -> short_ref_count ) memmove ( & h -> short_ref [ i ] , & h -> short_ref [ i + 1 ] , ( h -> short_ref_count - i ) * sizeof ( Picture * ) ) ;
<1> static PGresult * executeQuery ( PGconn * conn , const char * query ) {\n<3> if ( verbose ) fprintf ( stderr , _ ( "%s: executing %s\n" ) , progname , query ) ;\n<4> res = PQexec ( conn , query ) ;\n<5> if ( ! res || PQresultStatus ( res ) != PGRES_TUPLES_OK ) {\n<6> fprintf ( stderr , _ ( "%s: query failed: %s" ) , progname , PQerrorMessage ( conn ) ) ;\n<7> fprintf ( stderr , _ ( "%s: query was: %s\n" ) , progname , query ) ;
<1> static int filter_frame(AVFilterLink *inlink, AVFrame *picref)\n<31> uint64_t intpic[32][32];\n<69> if (sc->curfinesig) {\n<73> if (!fs)\n<99> memset(intpic, 0, sizeof(uint64_t)*32*32);\n<243> blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n<263> blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);
<1> static void help ( void ) {\n<3> printf ( "Help\n" ) ;\n<4> printf ( " Usage:\n" " androiddump --extcap-interfaces [--adb-server-ip=<arg>] [--adb-server-tcp-port=<arg>]\n" " androiddump --extcap-interface=INTERFACE --extcap-dlts\n" " androiddump --extcap-interface=INTERFACE --extcap-config\n" " androiddump --extcap-interface=INTERFACE --fifo=PATH_FILENAME --capture \n" ) ;\n<5> printf ( "\n Parameters:\n" ) ;\n<7> i_opt < ( sizeof ( longopts ) / sizeof ( longopts [ 0 ] ) ) - 1 ;\n<9> printf ( " --%s%s\n" , longopts [ i_opt ] . name , ( longopts [ i_opt ] . has_arg == required_argument ) ? "=<arg>" : ( ( longopts [ i_opt ] . has_arg == optional_argument ) ? "[=arg]" : "" ) ) ;
<1> static void vmsvga_value_write ( void * opaque , uint32_t address , uint32_t value ) {\n<2> struct vmsvga_state_s * s = opaque ;\n<27> case SVGA_REG_WIDTH : if ( value <= SVGA_MAX_WIDTH ) {\n<32> printf ( "%s: Bad width: %i\n" , __func__ , value ) ;\n<35> case SVGA_REG_HEIGHT : if ( value <= SVGA_MAX_HEIGHT ) {\n<40> printf ( "%s: Bad height: %i\n" , __func__ , value ) ;\n<43> case SVGA_REG_BITS_PER_PIXEL : if ( value != 32 ) {\n<44> printf ( "%s: Bad bits per pixel: %i bits\n" , __func__ , value ) ;\n<88> default : if ( s -> index >= SVGA_SCRATCH_BASE && s -> index < SVGA_SCRATCH_BASE + s -> scratch_size ) {\n<92> printf ( "%s: Bad register %02x\n" , __func__ , s -> index ) ;
<1> static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n<85> if (version_id >= 7 && qemu_get_be32(f)) {
<1> int qemuMonitorTextRemovePCIDevice ( qemuMonitorPtr mon , virDomainDevicePCIAddress * guestAddr ) {\n<3> char * reply = NULL ;\n<6> try_command : if ( tryOldSyntax ) {\n<18> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<22> if ( ! tryOldSyntax && strstr ( reply , "extraneous characters" ) ) {\n<23> tryOldSyntax = 1 ;\n<24> VIR_FREE ( reply ) ;\n<25> VIR_FREE ( cmd ) ;\n<28> if ( strstr ( reply , "invalid slot" ) || strstr ( reply , "Invalid pci address" ) ) {\n<29> qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( "failed to detach PCI device, invalid address %.4x:%.2x:%.2x: %s" ) , guestAddr -> domain , guestAddr -> bus , guestAddr -> slot , reply ) ;\n<32> ret = 0 ;\n<34> VIR_FREE ( reply ) ;
<1> static void buildTocEntryArrays ( ArchiveHandle * AH ) {\n<7> te != AH -> toc ;\n<8> te = te -> next ) {\n<9> if ( te -> dumpId <= 0 || te -> dumpId > maxDumpId ) exit_horribly ( modulename , "bad dumpId\n" ) ;\n<10> AH -> tocsByDumpId [ te -> dumpId ] = te ;\n<11> if ( strcmp ( te -> desc , "TABLE DATA" ) == 0 && te -> nDeps > 0 ) {\n<12> DumpId tableId = te -> dependencies [ 0 ] ;\n<13> if ( tableId <= 0 || tableId > maxDumpId ) exit_horribly ( modulename , "bad table dumpId for TABLE DATA item\n" ) ;\n<14> AH -> tableDataId [ tableId ] = te -> dumpId ;
<1> void add_user_command(char *optarg)\n<7> cmdline = realloc(cmdline, ncmdline * sizeof(char *));\n<9> if (!cmdline) {\n<11> perror("realloc");
<1> void * _TIFFmalloc ( tmsize_t s ) {\n<2> if ( s == 0 ) return ( ( void * ) NULL ) ;\n<3> return ( malloc ( ( size_t ) s ) ) ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<33> if ( h -> is_avc && buf_size >= 9 && buf [ 0 ] == 1 && buf [ 2 ] == 0 && ( buf [ 4 ] & 0xFC ) == 0xFC && ( buf [ 5 ] & 0x1F ) && buf [ 8 ] == 0x67 ) {\n<34> int cnt = buf [ 5 ] & 0x1f ;\n<50> not_extra : buf_index = decode_nal_units ( h , buf , buf_size , 0 ) ;\n<57> if ( avctx -> skip_frame >= AVDISCARD_NONREF || buf_size >= 4 && ! memcmp ( "Q264" , buf , 4 ) ) return buf_size ;
<1> static int ivi_decode_blocks ( GetBitContext * gb , IVIBandDesc * band , IVITile * tile , AVCodecContext * avctx ) {\n<4> int32_t prev_dc , trvec [ 64 ] ;\n<65> if ( ! band -> scan ) {\n<70> memset ( trvec , 0 , num_coeffs * sizeof ( trvec [ 0 ] ) ) ;\n<71> memset ( col_flags , 0 , sizeof ( col_flags ) ) ;\n<95> trvec [ pos ] = val ;\n<96> col_flags [ pos & col_mask ] |= ! ! val ;\n<100> prev_dc += trvec [ 0 ] ;\n<102> col_flags [ 0 ] |= ! ! prev_dc ;\n<104> band -> inv_transform ( trvec , band -> buf + buf_offs , band -> pitch , col_flags ) ;
<1> static void test_store_result2 ( ) {\n<19> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<27> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<35> nData = 0 ;\n<40> if ( ! opt_silent ) fprintf ( stdout , "\n row 1: %d" , nData ) ;\n<41> DIE_UNLESS ( nData == 10 ) ;\n<47> nData = 0 ;\n<52> if ( ! opt_silent ) fprintf ( stdout , "\n row 1: %d" , nData ) ;\n<53> DIE_UNLESS ( nData == 20 ) ;
<1> static const void * hb_graphite2_get_table ( const void * data , unsigned int tag , size_t * len ) {\n<11> if ( unlikely ( ! blob ) ) {\n<13> hb_graphite2_tablelist_t * p = ( hb_graphite2_tablelist_t * ) calloc ( 1 , sizeof ( hb_graphite2_tablelist_t ) ) ;\n<14> if ( unlikely ( ! p ) ) {
<1> static int megasas_dcmd_cfg_read(MegasasState *s, MegasasCmd *cmd)\n<59> if (info->size > 4096) {\n<125> ld = (struct mfi_ld_config *)(data + ld_offset);\n<127> memset(ld, 0, sizeof(struct mfi_ld_config));
<1> static CharDriverState *qemu_chr_open_socket(QemuOpts *opts)\n<115> qemu_set_fd_handler2(s->listen_fd, NULL, tcp_chr_accept, NULL, chr);\n<131> tcp_chr_connect(chr);\n<169> if (is_listen && is_waitconnect) {\n<175> tcp_chr_accept(chr);\n<181> return chr;
<1> static void Win32WarningHandler ( const char * module , const char * fmt , va_list ap ) {\n<4> LPCTSTR szTitleText = "%s Warning" ;\n<6> LPCTSTR szTmpModule = ( module == NULL ) ? szDefaultModule : module ;\n<7> SIZE_T nBufSize = ( strlen ( szTmpModule ) + strlen ( szTitleText ) + strlen ( fmt ) + 256 ) * sizeof ( char ) ;\n<8> if ( ( szTitle = ( LPTSTR ) LocalAlloc ( LMEM_FIXED , nBufSize ) ) == NULL ) return ;\n<9> sprintf ( szTitle , szTitleText , szTmpModule ) ;\n<10> szTmp = szTitle + ( strlen ( szTitle ) + 2 ) * sizeof ( char ) ;\n<11> vsnprintf ( szTmp , nBufSize - ( strlen ( szTitle ) + 2 ) * sizeof ( char ) , fmt , ap ) ;\n<12> MessageBoxA ( GetFocus ( ) , szTmp , szTitle , MB_OK | MB_ICONINFORMATION ) ;
<1> static void destroy_string_fifo ( string_fifo * fifo ) {\n<3> if ( fifo != NULL ) {\n<5> UNLINK_FIFO ( sn , * fifo , link ) ;\n<6> if ( sn != NULL ) {\n<7> if ( sn -> s != NULL ) free ( sn -> s ) ;\n<8> free ( sn ) ;\n<11> while ( sn != NULL ) ;\n<12> free ( fifo ) ;
<1> static void virtio_balloon_get_config ( VirtIODevice * vdev , uint8_t * config_data ) {\n<4> config . num_pages = cpu_to_le32 ( dev -> num_pages ) ;\n<5> config . actual = cpu_to_le32 ( dev -> actual ) ;\n<6> memcpy ( config_data , & config , 8 ) ;
<1> int test_mod_exp_mont5 ( BIO * bp , BN_CTX * ctx ) {\n<14> if ( ! BN_is_one ( d ) ) {\n<15> fprintf ( stderr , "Modular exponentiation test failed!\n" ) ;\n<21> if ( ! BN_is_zero ( d ) ) {\n<22> fprintf ( stderr , "Modular exponentiation test failed!\n" ) ;\n<30> if ( BN_cmp ( a , d ) != 0 ) {\n<31> fprintf ( stderr , "Modular exponentiation test failed!\n" ) ;\n<37> if ( BN_cmp ( a , d ) != 0 ) {\n<38> fprintf ( stderr , "Modular exponentiation test failed!\n" ) ;
<1> static int vaapi_encode_issue(AVCodecContext *avctx,\n<3> VAAPIEncodePicture *pic)\n<7> VAAPIEncodeContext *ctx = avctx->priv_data;\n<125> pic->codec_picture_params = av_malloc(ctx->codec->picture_params_size);\n<127> if (!pic->codec_picture_params)\n<131> memcpy(pic->codec_picture_params, ctx->codec_picture_params,\n<193> err = ctx->codec->init_picture_params(avctx, pic);\n<263> err = ctx->codec->write_picture_header(avctx, pic, data, &bit_len);\n<297> err = ctx->codec->write_extra_buffer(avctx, pic, i, &type,\n<317> err = vaapi_encode_make_param_buffer(avctx, pic, type,\n<341> err = ctx->codec->write_extra_header(avctx, pic, i, &type,\n<361> err = vaapi_encode_make_packed_header(avctx, pic, type,\n<413> err = ctx->codec->init_slice_params(avctx, pic, slice);\n<435> err = ctx->codec->write_slice_header(avctx, pic, slice,\n<581> return vaapi_encode_wait(avctx, pic);\n<601> av_freep(&pic->codec_picture_params);
<1> static struct cvec * cclass ( struct vars * v , const chr * startp , const chr * endp , int cases ) {\n<12> len = endp - startp ;\n<15> * namePtr != NULL ;\n<16> namePtr ++ , i ++ ) {\n<17> if ( strlen ( * namePtr ) == len && pg_char_and_wchar_strncmp ( * namePtr , startp , len ) == 0 ) {\n<18> index = i ;
<1> static gpg_err_code_t octet_string_from_mpi ( unsigned char * * r_frame , void * space , gcry_mpi_t value , size_t nbytes ) {\n<10> noff = ( nframe < nbytes ) ? nbytes - nframe : 0 ;\n<12> if ( space ) frame = space ;\n<15> if ( ! frame ) {\n<20> if ( noff ) memset ( frame , 0 , noff ) ;\n<21> nframe += noff ;\n<22> rc = gcry_err_code ( gcry_mpi_print ( GCRYMPI_FMT_USG , frame + noff , nframe - noff , NULL , value ) ) ;\n<24> gcry_free ( frame ) ;\n<27> if ( r_frame ) * r_frame = frame ;
<1> void ff_aac_search_for_ltp(AACEncContext *s, SingleChannelElement *sce,\n<21> if (sce->ics.ltp.lag) {\n<23> memset(&sce->lcoeffs[0], 0.0f, 3072*sizeof(sce->lcoeffs[0]));\n<25> memset(&sce->ics.ltp, 0, sizeof(LongTermPrediction));
<1> static void apply_pitch_filters ( QCELPContext * q , float * cdn_vector ) {\n<4> if ( q -> bitrate >= RATE_HALF || q -> bitrate == SILENCE || ( q -> bitrate == I_F_Q && ( q -> prev_bitrate >= RATE_HALF ) ) ) {\n<5> if ( q -> bitrate >= RATE_HALF ) {\n<26> memset ( q -> frame . pfrac , 0 , sizeof ( q -> frame . pfrac ) ) ;\n<28> v_synthesis_filtered = do_pitchfilter ( q -> pitch_synthesis_filter_mem , cdn_vector , q -> pitch_gain , q -> pitch_lag , q -> frame . pfrac ) ;\n<36> memcpy ( q -> pitch_synthesis_filter_mem , cdn_vector + 17 , 143 * sizeof ( float ) ) ;\n<37> memcpy ( q -> pitch_pre_filter_mem , cdn_vector + 17 , 143 * sizeof ( float ) ) ;\n<38> memset ( q -> pitch_gain , 0 , sizeof ( q -> pitch_gain ) ) ;\n<39> memset ( q -> pitch_lag , 0 , sizeof ( q -> pitch_lag ) ) ;
<1> static void move_task_thread_func ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable ) {\n<31> if ( job_aborted ( common ) ) {\n<34> memset ( & transfer_info , 0 , sizeof ( transfer_info ) ) ;\n<35> move_files ( job , fallbacks , dest_fs_id , & dest_fs_type , & source_info , & transfer_info ) ;
<1> static inline void xan_wc3_copy_pixel_run(XanContext *s, AVFrame *frame,\n<45> curframe_index = y * stride + x;\n<49> prevframe_index = (y + motion_y) * stride + x + motion_x;\n<55> if (prev_palette_plane == palette_plane && FFABS(curframe_index - prevframe_index) < pixel_count) {\n<67> curframe_index  < s->frame_size &&\n<69> prevframe_index < s->frame_size) {\n<71> int count = FFMIN3(pixel_count, width - curframe_x,\n<81> pixel_count     -= count;\n<83> curframe_index  += count;\n<85> prevframe_index += count;\n<87> curframe_x      += count;\n<89> prevframe_x     += count;\n<95> curframe_index += line_inc;\n<105> prevframe_index += line_inc;
<1> static int output_configure(AACContext *ac,\n<3> uint8_t layout_map[MAX_ELEM_ID * 4][3], int tags,\n<23> memcpy(ac->oc[1].layout_map, layout_map, tags * sizeof(layout_map[0]));\n<47> layout = sniff_channel_order(layout_map, tags);
<1> static void fix_coding_method_array (int sb, int channels, sb_int8_array coding_method)\n<23> case_val = 8;\n<29> case 0: run = 10; case_val = 10; break;\n<31> case 1: run = 1; case_val = 16; break;\n<33> case 2: run = 5; case_val = 24; break;\n<35> case 3: run = 3; case_val = 30; break;\n<37> case 4: run = 1; case_val = 30; break;\n<39> case 5: run = 1; case_val = 8; break;\n<41> default: run = 1; case_val = 8; break;\n<53> if (k > 0) {\n<59> memset(&coding_method[ch][sb][j + k], case_val, k * sizeof(int8_t));\n<61> memset(&coding_method[ch][sb][j + k], case_val, 3 * sizeof(int8_t));
<1> static void test_bug12243 ( ) {\n<7> if ( ! have_innodb ) {\n<8> if ( ! opt_silent ) printf ( "This test requires InnoDB.\n" ) ;\n<19> mysql_stmt_attr_set ( stmt1 , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;\n<20> mysql_stmt_attr_set ( stmt2 , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;\n<21> stmt_text = "select a from t1" ;\n<22> rc = mysql_stmt_prepare ( stmt1 , stmt_text , strlen ( stmt_text ) ) ;\n<23> check_execute ( stmt1 , rc ) ;\n<28> rc = mysql_stmt_prepare ( stmt2 , stmt_text , strlen ( stmt_text ) ) ;\n<29> check_execute ( stmt2 , rc ) ;
<1> afs_int32 getHostCPS ( struct rx_call * call , afs_uint32 ahost , prlist * alist , afs_int32 * over ) {\n<23> if ( temp ) {\n<25> if ( code == PRSUCCESS ) {\n<29> else fprintf ( stderr , "pr_ReadEntry returned %d\n" , code ) ;\n<31> else fprintf ( stderr , "FindByID Failed -- Not found\n" ) ;
<1> static bluetooth_uuid_t get_service_uuid_from_handle ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data ) {\n<7> memset ( & uuid , 0 , sizeof uuid ) ;\n<22> return uuid ;\n<26> return uuid ;
<1> PGconn * GetConnection ( void ) {\n<11> char * err_msg = NULL ;\n<15> conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n<16> if ( conn_opts == NULL ) {\n<17> fprintf ( stderr , "%s: %s" , progname , err_msg ) ;\n<20> for ( conn_opt = conn_opts ;\n<21> conn_opt -> keyword != NULL ;\n<22> conn_opt ++ ) {\n<23> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' && strcmp ( conn_opt -> keyword , "dbname" ) != 0 ) argcount ++ ;\n<27> for ( conn_opt = conn_opts ;\n<28> conn_opt -> keyword != NULL ;\n<29> conn_opt ++ ) {\n<30> if ( conn_opt -> val != NULL && conn_opt -> val [ 0 ] != '\0' && strcmp ( conn_opt -> keyword , "dbname" ) != 0 ) {\n<31> keywords [ i ] = conn_opt -> keyword ;\n<48> values [ i ] = progname ;\n<65> need_password = ( dbgetpassword == 1 && dbpassword == NULL ) ;\n<68> if ( dbpassword ) free ( dbpassword ) ;\n<69> dbpassword = simple_prompt ( _ ( "Password: " ) , 100 , false ) ;\n<73> keywords [ i ] = "password" ;\n<74> values [ i ] = dbpassword ;\n<77> keywords [ i ] = NULL ;\n<78> values [ i ] = NULL ;\n<80> tmpconn = PQconnectdbParams ( keywords , values , true ) ;\n<81> if ( ! tmpconn ) {\n<82> fprintf ( stderr , _ ( "%s: could not connect to server\n" ) , progname ) ;\n<91> if ( PQstatus ( tmpconn ) != CONNECTION_OK ) {\n<92> fprintf ( stderr , _ ( "%s: could not connect to server: %s" ) , progname , PQerrorMessage ( tmpconn ) ) ;\n<94> free ( values ) ;\n<95> free ( keywords ) ;\n<99> free ( values ) ;\n<100> free ( keywords ) ;
<1> static int init_directories(BDRVVVFATState* s,\n<3> const char* dirname)\n<17> memset(&(s->first_sectors[0]),0,0x40*0x200);\n<75> s->cluster_count=sector2cluster(s, s->sector_count);\n<79> mapping = array_get_next(&(s->mapping));\n<89> mapping->path = strdup(dirname);\n<91> i = strlen(mapping->path);\n<93> if (i > 0 && mapping->path[i - 1] == '/')\n<95> mapping->path[i - 1] = '\0';\n<101> s->path = mapping->path;\n<105> for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n<115> mapping = array_get(&(s->mapping), i);\n<123> if(read_directory(s, i)) {\n<125> fprintf(stderr, "Could not read directory %s\n",\n<177> if(cluster > s->cluster_count) {\n<179> fprintf(stderr,"Directory does not fit in FAT%d (capacity %s)\n",\n<183> s->fat_type == 12 ? s->sector_count == 2880 ? "1.44 MB"\n<205> fat_set(s, mapping->end - 1, s->max_fat_value);\n<233> bootsector=(bootsector_t*)(s->first_sectors+(s->first_sectors_number-1)*0x200);\n<241> memcpy(bootsector->name,"QEMU    ",8);\n<283> memcpy(bootsector->u.fat16.volume_label,"QEMU VVFAT ",11);\n<285> memcpy(bootsector->fat_type,(s->fat_type==12?"FAT12   ":s->fat_type==16?"FAT16   ":"FAT32   "),8);
<1> static QemuOpts *opts_parse(QemuOptsList *list, const char *params,\n<23> if (strncmp(params, "id=", 3) == 0) {\n<29> } else if ((p = strstr(params, ",id=")) != NULL) {\n<31> get_opt_value(value, sizeof(value), p+4);\n<33> id = value;\n<41> opts = qemu_opts_find(list, NULL);\n<55> if (opts == NULL)\n<61> if (opts_do_parse(opts, params, firstname, defaults) != 0) {
<1> static void decode_b(AVCodecContext *ctx, int row, int col,\n<37> s->max_mv.x = 128 + (s->cols - col - w4) * 64;\n<39> s->max_mv.y = 128 + (s->rows - row - h4) * 64;\n<51> b->uvtx = b->tx - ((s->ss_h && w4 * 2 == (1 << b->tx)) ||\n<53> (s->ss_v && h4 * 2 == (1 << b->tx)));\n<73> if (!has_coeffs && b->bs <= BS_8x8 && !b->intra) {\n<77> memset(&s->above_skip_ctx[col], 1, w4);\n<79> memset(&s->left_skip_ctx[s->row7], 1, h4);\n<159> s->block += w4 * h4 * 64 * bytesperpixel;\n<187> emu[0] = (col + w4) * 8 > f->linesize[0] ||\n<189> (row + h4) > s->rows;\n<191> emu[1] = (col + w4) * 4 > f->linesize[1] ||\n<193> (row + h4) > s->rows;\n<255> int w = FFMIN(s->cols - col, w4) * 8, h = FFMIN(s->rows - row, h4) * 8, n, o = 0;\n<283> int w = FFMIN(s->cols - col, w4) * 8 >> s->ss_h;\n<285> int h = FFMIN(s->rows - row, h4) * 8 >> s->ss_v, n, o = 0;\n<325> int x_end = FFMIN(s->cols - col, w4), y_end = FFMIN(s->rows - row, h4);\n<381> s->block += w4 * h4 * 64 * bytesperpixel;
<1> static void help ( const char * progname ) {\n<2> printf ( _ ( "%s clusters all previously clustered tables in a database.\n\n" ) , progname ) ;\n<3> printf ( _ ( "Usage:\n" ) ) ;\n<4> printf ( _ ( " %s [OPTION]... [DBNAME]\n" ) , progname ) ;\n<5> printf ( _ ( "\nOptions:\n" ) ) ;\n<6> printf ( _ ( " -a, --all cluster all databases\n" ) ) ;\n<7> printf ( _ ( " -d, --dbname=DBNAME database to cluster\n" ) ) ;\n<8> printf ( _ ( " -e, --echo show the commands being sent to the server\n" ) ) ;\n<9> printf ( _ ( " -q, --quiet don't write any messages\n" ) ) ;\n<10> printf ( _ ( " -t, --table=TABLE cluster specific table(s) only\n" ) ) ;\n<11> printf ( _ ( " -v, --verbose write a lot of output\n" ) ) ;\n<12> printf ( _ ( " -V, --version output version information, then exit\n" ) ) ;\n<13> printf ( _ ( " -?, --help show this help, then exit\n" ) ) ;\n<14> printf ( _ ( "\nConnection options:\n" ) ) ;\n<15> printf ( _ ( " -h, --host=HOSTNAME database server host or socket directory\n" ) ) ;\n<16> printf ( _ ( " -p, --port=PORT database server port\n" ) ) ;\n<17> printf ( _ ( " -U, --username=USERNAME user name to connect as\n" ) ) ;\n<18> printf ( _ ( " -w, --no-password never prompt for password\n" ) ) ;\n<19> printf ( _ ( " -W, --password force password prompt\n" ) ) ;\n<20> printf ( _ ( " --maintenance-db=DBNAME alternate maintenance database\n" ) ) ;\n<21> printf ( _ ( "\nRead the description of the SQL command CLUSTER for details.\n" ) ) ;\n<22> printf ( _ ( "\nReport bugs to <pgsql-bugs@postgresql.org>.\n" ) ) ;
<1> static int rv10_decode_frame(AVCodecContext *avctx,\n<147> for(i=0;i<mb_count;i++) {\n<169> memset(block, 0, sizeof(block));\n<175> if (h263_decode_mb(s, block) < 0) {
<1> void kadmin_addprinc ( int argc , char * argv [ ] ) {\n<6> krb5_key_salt_tuple * ks_tuple = NULL ;\n<7> char * pass , * canon = NULL ;\n<11> memset ( & princ , 0 , sizeof ( princ ) ) ;\n<12> princ . attributes = 0 ;\n<13> if ( kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , "add_principal" ) ) {\n<17> retval = krb5_unparse_name ( context , princ . principal , & canon ) ;\n<23> if ( ! policy_exists ( princ . policy ) ) {\n<24> fprintf ( stderr , _ ( "WARNING: policy \"%s\" does not exist\n" ) , princ . policy ) ;\n<44> snprintf ( prompt2 , sizeof ( prompt2 ) , _ ( "Re-enter password for principal \"%s\"" ) , canon ) ;\n<47> com_err ( "add_principal" , retval , _ ( "while reading password for \"%s\"." ) , canon ) ;\n<53> retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n<56> princ . attributes |= KRB5_KDB_DISALLOW_ALL_TIX ;\n<59> retval = create_princ ( & princ , mask , n_ks_tuple , ks_tuple , pass ) ;\n<63> com_err ( "add_principal" , retval , "while creating \"%s\"." , canon ) ;\n<66> if ( old_style_randkey ) {\n<67> retval = randkey_princ ( princ . principal , FALSE , n_ks_tuple , ks_tuple ) ;\n<69> com_err ( "add_principal" , retval , _ ( "while randomizing key for \"%s\"." ) , canon ) ;\n<72> princ . attributes &= ~ KRB5_KDB_DISALLOW_ALL_TIX ;\n<74> retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n<75> if ( retval ) {\n<76> com_err ( "add_principal" , retval , _ ( "while clearing DISALLOW_ALL_TIX for \"%s\"." ) , canon ) ;\n<80> printf ( "Principal \"%s\" created.\n" , canon ) ;\n<81> cleanup : krb5_free_principal ( context , princ . principal ) ;\n<82> free ( ks_tuple ) ;\n<83> free ( canon ) ;\n<84> kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;
<1> static void idr_cleanup ( struct idr * idr ) {\n<2> free ( idr -> idrent_pool ) ;
<1> void axisdev88_init(MachineState *machine)\n<205> } else if (!qtest_enabled()) {\n<207> fprintf(stderr, "Kernel image must be specified\n");
<77> if (iterable_only) {\n<153> vmdesc_len = strlen(qjson_get_str(vmdesc));\n<161> qemu_put_be32(f, vmdesc_len);
<1> static DeviceState * qbus_find_dev ( BusState * bus , char * elem ) {\n<3> QLIST_FOREACH ( dev , & bus -> children , sibling ) {\n<4> if ( dev -> id && strcmp ( dev -> id , elem ) == 0 ) {\n<5> return dev ;\n<8> QLIST_FOREACH ( dev , & bus -> children , sibling ) {\n<9> if ( strcmp ( dev -> info -> name , elem ) == 0 ) {\n<10> return dev ;\n<13> QLIST_FOREACH ( dev , & bus -> children , sibling ) {\n<14> if ( dev -> info -> alias && strcmp ( dev -> info -> alias , elem ) == 0 ) {\n<15> return dev ;\n<18> return NULL ;
<1> static void idr_init ( struct iso9660 * iso9660 , struct vdd * vdd , struct idr * idr ) {\n<5> if ( iso9660 -> opt . iso_level <= 3 ) {\n<6> memcpy ( idr -> char_map , d_characters_map , sizeof ( idr -> char_map ) ) ;\n<9> memcpy ( idr -> char_map , d1_characters_map , sizeof ( idr -> char_map ) ) ;\n<10> idr_relaxed_filenames ( idr -> char_map ) ;
<1> static void new_video_stream(AVFormatContext *oc, int file_idx)\n<19> if (!st) {\n<21> fprintf(stderr, "Could not alloc stream\n");\n<177> p= video_rc_override_string;\n<179> for(i=0; p; i++){\n<183> int e=sscanf(p, "%d,%d,%d", &start, &end, &q);\n<185> if(e!=3){\n<187> fprintf(stderr, "error parsing rc_override\n");\n<199> video_enc->rc_override[i].start_frame= start;\n<201> video_enc->rc_override[i].end_frame  = end;\n<203> if(q>0){\n<205> video_enc->rc_override[i].qscale= q;\n<215> video_enc->rc_override[i].quality_factor= -q/100.0;\n<219> p= strchr(p, '/');\n<221> if(p) p++;
<1> static void test_qemu_strtol_max(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtol(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> static uint8_t usb_linux_get_alt_setting(USBHostDevice *s,\n<3> uint8_t configuration, uint8_t interface)\n<7> char device_name[64], line[1024];\n<13> sprintf(device_name, "%d-%s:%d.%d", s->bus_num, s->port,\n<19> if (!usb_host_read_file(line, sizeof(line), "bAlternateSetting",\n<29> if (sscanf(line, "%d", &alt_setting) != 1) {\n<33> return 0;\n<37> return alt_setting;
<1> static inline void vmsvga_copy_rect(struct vmsvga_state_s *s,\n<15> int width = bypp * w;\n<19> uint8_t *ptr[2];\n<25> ptr[0] = vram + bypp * x0 + bypl * (y0 + h - 1);\n<27> ptr[1] = vram + bypp * x1 + bypl * (y1 + h - 1);\n<29> for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl) {\n<31> memmove(ptr[1], ptr[0], width);\n<37> ptr[0] = vram + bypp * x0 + bypl * y0;\n<39> ptr[1] = vram + bypp * x1 + bypl * y1;\n<41> for (; line > 0; line --, ptr[0] += bypl, ptr[1] += bypl) {\n<43> memmove(ptr[1], ptr[0], width);
<1> static int do_show_slave_status ( MYSQL * mysql_con ) {\n<3> const char * comment_prefix = ( opt_slave_data == MYSQL_OPT_SLAVE_DATA_COMMENTED_SQL ) ? "-- " : "" ;\n<5> if ( ! ignore_errors ) {\n<6> fprintf ( stderr , "%s: Error: Slave not set up\n" , my_progname_short ) ;\n<13> if ( row && row [ 9 ] && row [ 21 ] ) {\n<14> if ( opt_comments ) fprintf ( md_result_file , "\n--\n-- Position to start replication or point-in-time " "recovery from (the master of this slave)\n--\n\n" ) ;\n<15> fprintf ( md_result_file , "%sCHANGE MASTER TO " , comment_prefix ) ;\n<17> if ( row [ 1 ] ) fprintf ( md_result_file , "MASTER_HOST='%s', " , row [ 1 ] ) ;\n<18> if ( row [ 3 ] ) fprintf ( md_result_file , "MASTER_PORT=%s, " , row [ 3 ] ) ;
<1> static void set_temporal_layer_pattern ( int layering_mode , vpx_codec_enc_cfg_t * cfg , int * layer_flags , int * flag_periodicity ) {\n<2> switch ( layering_mode ) {\n<11> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<24> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<40> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<55> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<71> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<87> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<103> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<121> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<138> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<159> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<179> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;\n<200> memcpy ( cfg -> ts_layer_id , ids , sizeof ( ids ) ) ;
<1> static int32_t u_printf_string_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n<7> const char * arg = ( const char * ) ( args [ 0 ] . ptrValue ) ;\n<8> if ( arg ) {\n<9> argSize = ( int32_t ) strlen ( arg ) + 1 ;\n<10> if ( argSize >= MAX_UCHAR_BUFFER_SIZE ( buffer ) ) {\n<11> s = ufmt_defaultCPToUnicode ( arg , argSize , ( UChar * ) uprv_malloc ( MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) , MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) ;\n<17> s = ufmt_defaultCPToUnicode ( arg , argSize , buffer , UPRV_LENGTHOF ( buffer ) ) ;
<1> static void log_syslog ( struct passwd const * pw , bool successful ) {\n<3> new_user = pw -> pw_name ;\n<5> if ( ! old_user ) {\n<7> old_user = pwd ? pwd -> pw_name : "" ;\n<9> if ( get_terminal_name ( NULL , & tty , NULL ) != 0 || ! tty ) tty = "none" ;\n<11> syslog ( LOG_NOTICE , "%s(to %s) %s on %s" , successful ? "" : su_mode == RUNUSER_MODE ? "FAILED RUNUSER " : "FAILED SU " , new_user , old_user , tty ) ;
<1> int upx_inflatelzma ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t upx0 , uint32_t upx1 , uint32_t ep ) {\n<7> memset ( & l , 0 , sizeof ( l ) ) ;\n<12> if ( cli_LzmaInit ( & l , * dsize ) != LZMA_RESULT_OK ) return 0 ;\n<17> if ( cli_LzmaDecode ( & l ) == LZMA_RESULT_DATA_ERROR ) {\n<18> cli_LzmaShutdown ( & l ) ;\n<21> cli_LzmaShutdown ( & l ) ;
<1> void qmp_block_set_io_throttle(const char *device, int64_t bps, int64_t bps_rd,\n<25> if (!bs) {\n<29> memset(&cfg, 0, sizeof(cfg));\n<57> if (!check_throttle_config(&cfg, errp)) {\n<62> if (!bs->io_limits_enabled && throttle_enabled(&cfg)) {\n<64> } else if (bs->io_limits_enabled && !throttle_enabled(&cfg)) {\n<68> bdrv_set_io_limits(bs, &cfg);
<1> static void matroska_fix_ass_packet ( MatroskaDemuxContext * matroska , AVPacket * pkt , uint64_t display_duration ) {\n<30> if ( ! ( line = av_buffer_alloc ( len ) ) ) return ;\n<31> snprintf ( line -> data , len , "Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\r\n" , layer , sh , sm , ss , sc , eh , em , es , ec , ptr ) ;\n<35> pkt -> size = strlen ( line -> data ) ;
<1> static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n<53> gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ;\n<59> if ( value_utf8 != NULL && * value_utf8 != '\0' ) {\n<60> GST_DEBUG ( "string value %s" , value_utf8 ) ;\n<61> value_utf8 [ out ] = '\0' ;\n<62> if ( gst_tag_name != NULL ) {\n<63> if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) {\n<64> guint year = atoi ( value_utf8 ) ;\n<65> if ( year > 0 ) {\n<70> else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) {\n<73> if ( sscanf ( value_utf8 , "(%u)" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) {\n<74> GST_DEBUG ( "Genre: %s -> %s" , value_utf8 , genre_str ) ;\n<75> g_free ( value_utf8 ) ;\n<76> value_utf8 = g_strdup ( genre_str ) ;\n<81> tag_type = gst_tag_get_type ( gst_tag_name ) ;\n<82> g_value_init ( & tag_value , tag_type ) ;\n<83> if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) {\n<101> if ( content3D ) {\n<103> if ( strncmp ( "StereoscopicLayout" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n<127> g_free ( value_utf8 ) ;\n<144> if ( value_len < 4 ) break ;\n<147> if ( ! strcmp ( name_utf8 , "WM/Track" ) ) ++ uint_val ;\n<153> if ( value_len < 4 ) break ;\n<155> if ( strncmp ( "Stereoscopic" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) {\n<156> if ( bool_val ) {\n<173> if ( gst_tag_name ) {\n<175> if ( strcmp ( name_utf8 , "WM/TrackNumber" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ;\n<176> gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ;\n<179> GST_DEBUG ( "Setting global metadata %s" , name_utf8 ) ;\n<187> g_free ( name_utf8 ) ;
<1> static void evbuffer_align ( struct evbuffer * buf ) {\n<2> memmove ( buf -> orig_buffer , buf -> buffer , buf -> off ) ;\n<3> buf -> buffer = buf -> orig_buffer ;
<1> static size_t encode_block ( char * str , char * buf , size_t buflen , const char * fromcode , const char * tocode , encoder_t encoder ) {\n<2> if ( ! fromcode ) {\n<5> const iconv_t cd = mutt_ch_iconv_open ( tocode , fromcode , 0 ) ;\n<11> size_t obl = sizeof ( tmp ) - strlen ( tocode ) ;\n<13> const size_t n2 = iconv ( cd , NULL , NULL , & ob , & obl ) ;\n<16> return ( * encoder ) ( str , tmp , ob - tmp , tocode ) ;
<1> static void ctl_putfs ( const char * tag , tstamp_t uval ) {\n<13> if ( NULL == tm ) return ;\n<15> snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , "%04d%02d%02d%02d%02d" , tm -> tm_year + 1900 , tm -> tm_mon + 1 , tm -> tm_mday , tm -> tm_hour , tm -> tm_min ) ;\n<16> cp += strlen ( cp ) ;\n<17> ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;
<1> static int decode_channel_transform ( WMAProDecodeCtx * s ) {\n<13> WMAProChannelGrp * chgroup = & s -> chgroup [ s -> num_chgroups ] ;\n<48> chgroup -> decorrelation_matrix [ 0 ] = 1.0 ;\n<49> chgroup -> decorrelation_matrix [ 1 ] = - 1.0 ;\n<50> chgroup -> decorrelation_matrix [ 2 ] = 1.0 ;\n<51> chgroup -> decorrelation_matrix [ 3 ] = 1.0 ;\n<54> chgroup -> decorrelation_matrix [ 0 ] = 0.70703125 ;\n<55> chgroup -> decorrelation_matrix [ 1 ] = - 0.70703125 ;\n<56> chgroup -> decorrelation_matrix [ 2 ] = 0.70703125 ;\n<57> chgroup -> decorrelation_matrix [ 3 ] = 0.70703125 ;\n<65> decode_decorrelation_matrix ( s , chgroup ) ;\n<68> if ( chgroup -> num_channels > 6 ) {\n<72> memcpy ( chgroup -> decorrelation_matrix , default_decorrelation [ chgroup -> num_channels ] , chgroup -> num_channels * chgroup -> num_channels * sizeof ( * chgroup -> decorrelation_matrix ) ) ;\n<78> if ( ! get_bits1 ( & s -> gb ) ) {\n<81> i < s -> num_bands ;\n<83> chgroup -> transform_band [ i ] = get_bits1 ( & s -> gb ) ;\n<87> memset ( chgroup -> transform_band , 1 , s -> num_bands ) ;
<1> static int init_context_frame ( MpegEncContext * s ) {\n<78> FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> mbintra_table , mb_array_size , fail ) ;\n<79> memset ( s -> mbintra_table , 1 , mb_array_size ) ;\n<80> FF_ALLOCZ_OR_GOTO ( s -> avctx , s -> mbskip_table , mb_array_size + 2 , fail ) ;\n<86> return init_er ( s ) ;
<1> krb5_error_code krb5_decode_krbsecretkey ( krb5_context context , krb5_db_entry * entries , struct berval * * bvalues , krb5_tl_data * userinfo_tl_data , krb5_kvno * mkvno ) {\n<2> char * user = NULL ;\n<4> krb5_key_data * key_data = NULL , * tmp ;\n<6> if ( ( st = krb5_unparse_name ( context , entries -> princ , & user ) ) != 0 ) goto cleanup ;\n<16> st = asn1_decode_sequence_of_keys ( & in , & kd , & n_kd , mkvno ) ;\n<17> if ( st != 0 ) {\n<25> key_data = realloc ( key_data , ( noofkeys + 1 ) * sizeof ( krb5_key_data ) ) ;\n<26> if ( key_data == NULL ) {\n<33> j ++ ) key_data [ noofkeys - n_kd + j ] = kd [ j ] ;\n<34> free ( kd ) ;\n<38> cleanup : free ( user ) ;
<1> opts_visitor_cleanup(OptsVisitor *ov)\n<5> if (ov->unprocessed_opts != NULL) {\n<7> g_hash_table_destroy(ov->unprocessed_opts);\n<11> g_free(ov->fake_id_opt);\n<13> memset(ov, '\0', sizeof *ov);
<1> BusState * qdev_get_child_bus ( DeviceState * dev , const char * name ) {\n<3> QLIST_FOREACH ( bus , & dev -> child_bus , sibling ) {\n<4> if ( strcmp ( name , bus -> name ) == 0 ) {\n<5> return bus ;\n<8> return NULL ;
<1> ISADevice *isa_create(const char *name)\n<9> if (!isabus) {\n<11> fprintf(stderr, "Tried to create isa device %s with no isa bus present.\n", name);
<16> if ( pickhost || pickproxy ) {\n<18> data -> req . newurl = strdup ( data -> change . url ) ;\n<19> if ( ! data -> req . newurl ) return CURLE_OUT_OF_MEMORY ;\n<26> if ( ( data -> set . httpreq != HTTPREQ_GET ) && ( data -> set . httpreq != HTTPREQ_HEAD ) ) {\n<27> data -> req . newurl = strdup ( data -> change . url ) ;\n<28> if ( ! data -> req . newurl ) return CURLE_OUT_OF_MEMORY ;
<1> static int get_cluster_offset(BlockDriverState *bs,\n<11> BDRVQcowState *s = bs->opaque;\n<109> l2_table = s->l2_cache + (min_index << s->l2_bits);\n<111> if (new_l2_table) {\n<113> memset(l2_table, 0, s->l2_size * sizeof(uint64_t));\n<115> ret = bdrv_pwrite_sync(bs->file, l2_offset, l2_table,\n<225> if (i < n_start || i >= n_end) {\n<227> memset(s->cluster_data, 0x00, 512);\n<229> if (qcrypto_block_encrypt(s->crypto, start_sect + i,
<1> static uint64_t pxa2xx_fir_read ( void * opaque , hwaddr addr , unsigned size ) {\n<10> if ( s -> rx_len ) {\n<17> printf ( "%s: Rx FIFO underrun.\n" , __FUNCTION__ ) ;
<1> int nntp_check_msgid ( struct Context * ctx , const char * msgid ) {\n<26> if ( nntp_query ( nntp_data , buf , sizeof ( buf ) ) < 0 ) {\n<30> sscanf ( buf + 4 , ANUM , & NHDR ( hdr ) -> article_num ) ;
<1> static int find_partition ( BlockBackend * blk , int partition , off_t * offset , off_t * size ) {\n<8> if ( ret < 0 ) {\n<9> error_report ( "error while reading: %s" , strerror ( - ret ) ) ;\n<27> if ( ret < 0 ) {\n<28> error_report ( "error while reading: %s" , strerror ( - ret ) ) ;
<1> static void add_mrange ( fz_context * ctx , pdf_cmap * cmap , unsigned int low , int * out , int len ) {\n<5> cmap -> dict = fz_resize_array ( ctx , cmap -> dict , new_cap , sizeof * cmap -> dict ) ;\n<10> memcpy ( & cmap -> dict [ out_pos + 1 ] , out , sizeof ( int ) * len ) ;
<1> void data_destroy_arabic ( void * data ) {\n<4> free ( data ) ;
<1> static int read_data(void *opaque, uint8_t *buf, int buf_size)\n<5> struct playlist *v = opaque;\n<156> ret = open_input(c, v, seg);\n<180> if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n<184> int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n<186> memcpy(buf, v->init_sec_buf, copy_size);\n<188> v->init_sec_buf_read_offset += copy_size;\n<190> return copy_size;\n<196> ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);
<1> static uint8_t file_byte_getter ( Gif_Reader * grr ) {\n<2> int i = getc ( grr -> f ) ;\n<3> if ( i != EOF ) {
<1> static int tscc2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> TSCC2Context * c = avctx -> priv_data ;\n<7> int i , val , len , pos = 0 ;\n<51> len = val & 0x3F ;\n<52> val >>= 6 ;\n<53> if ( pos + len > num_mb ) {\n<57> memset ( c -> slice_quants + pos , val , len ) ;\n<58> pos += len ;
<1> void qemu_send_packet(VLANClientState *vc, const uint8_t *buf, int size)\n<25> if (vlan->delivering) {\n<27> packet = qemu_malloc(sizeof(VLANPacket) + size);\n<35> memcpy(packet->data, buf, size);\n<37> vlan->send_queue = packet;
<1> static void usage(const char *cmd)
<1> static void dvbsub_parse_region_segment(AVCodecContext *avctx,\n<40> if (!region) {\n<42> region = av_mallocz(sizeof(DVBSubRegion));\n<48> region->id = region_id;\n<50> region->version = -1;\n<54> region->next = ctx->region_list;\n<78> if (region->width * region->height != region->buf_size) {\n<88> region->pbuf = av_malloc(region->buf_size);\n<116> region->bgcolor = *buf++;\n<128> region->bgcolor = (((*buf++) >> 4) & 15);\n<132> region->bgcolor = (((*buf++) >> 2) & 3);\n<142> if (fill) {\n<144> memset(region->pbuf, region->bgcolor, region->buf_size);\n<146> av_dlog(avctx, "Fill region (%d)\n", region->bgcolor);\n<152> delete_region_display_list(ctx, region);
<1> void pdf_process_annot ( fz_context * ctx , pdf_processor * proc , pdf_document * doc , pdf_page * page , pdf_annot * annot , fz_cookie * cookie ) {\n<5> if ( proc -> usage ) {\n<6> if ( ! strcmp ( proc -> usage , "Print" ) && ! ( flags & PDF_ANNOT_IS_PRINT ) ) return ;\n<7> if ( ! strcmp ( proc -> usage , "View" ) && ( flags & PDF_ANNOT_IS_NO_VIEW ) ) return ;\n<9> if ( pdf_is_hidden_ocg ( ctx , doc -> ocg , NULL , proc -> usage , pdf_dict_get ( ctx , annot -> obj , PDF_NAME_OC ) ) ) return ;
<1> static int ogg_new_buf(struct ogg *ogg, int idx)\n<5> struct ogg_stream *os = ogg->streams + idx;\n<7> uint8_t *nb = av_malloc(os->bufsize);\n<9> int size = os->bufpos - os->pstart;\n<11> if(os->buf){\n<13> memcpy(nb, os->buf + os->pstart, size);\n<19> os->buf = nb;\n<21> os->bufpos = size;
<1> static void x86_cpu_reset(CPUState *s)\n<5> CPUX86State *env = &cpu->env;\n<8> memset(env, 0, offsetof(CPUX86State, breakpoints));\n<9> tlb_flush(env, 1);\n<40> cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffff,\n<55> memset(env->dr, 0, sizeof(env->dr));\n<58> cpu_breakpoint_remove_all(env, BP_CPU);\n<59> cpu_watchpoint_remove_all(env, BP_CPU);
<1> static int tree_content_remove ( struct tree_entry * root , const char * p , struct tree_entry * backup_leaf , int allow_root ) {\n<10> e = root ;\n<17> e = t -> entries [ i ] ;\n<21> if ( ! e -> tree ) load_tree ( e ) ;\n<22> if ( tree_content_remove ( e , slash1 + 1 , backup_leaf , 0 ) ) {\n<31> backup_leaf = NULL ;\n<38> del_entry : if ( backup_leaf ) memcpy ( backup_leaf , e , sizeof ( * backup_leaf ) ) ;
<1> static void AddMacName ( NamTab * nt , struct macname * mn , int strid ) {\n<4> if ( nt -> cur == 0 ) nt -> entries = malloc ( ( nt -> max = 100 ) * sizeof ( NameEntry ) ) ;\n<5> else nt -> entries = realloc ( nt -> entries , ( nt -> max += 100 ) * sizeof ( NameEntry ) ) ;\n<7> ne = nt -> entries + nt -> cur ;\n<13> ne -> len = strlen ( mn -> name ) ;\n<14> dumpstr ( nt -> strings , mn -> name ) ;
<1> static int isoent_cmp_key ( const struct archive_rb_node * n , const void * key ) {\n<3> return ( strcmp ( e -> file -> basename . s , ( const char * ) key ) ) ;
<1> static void x86_cpu_parse_featurestr(CPUState *cs, char *features,\n<27> featurestr = features ? strtok(features, ",") : NULL;\n<35> if (featurestr[0] == '+') {\n<37> add_flagname_to_bitmaps(featurestr + 1, plus_features);\n<39> } else if (featurestr[0] == '-') {\n<41> add_flagname_to_bitmaps(featurestr + 1, minus_features);\n<43> } else if ((val = strchr(featurestr, '='))) {\n<45> *val = 0; val++;\n<47> feat2prop(featurestr);\n<49> if (!strcmp(featurestr, "xlevel")) {\n<53> char num[32];\n<57> numvalue = strtoul(val, &err, 0);\n<59> if (!*val || *err) {\n<79> object_property_parse(OBJECT(cpu), num, featurestr, &local_err);\n<81> } else if (!strcmp(featurestr, "tsc-freq")) {\n<87> char num[32];\n<91> tsc_freq = strtosz_suffix_unit(val, &err,\n<95> if (tsc_freq < 0 || *err) {\n<109> } else if (!strcmp(featurestr, "hv-spinlocks")) {\n<113> const int min = 0xFFF;\n<115> char num[32];\n<117> numvalue = strtoul(val, &err, 0);\n<119> if (!*val || *err) {\n<141> object_property_parse(OBJECT(cpu), num, featurestr, &local_err);\n<145> object_property_parse(OBJECT(cpu), val, featurestr, &local_err);\n<151> feat2prop(featurestr);\n<153> object_property_parse(OBJECT(cpu), "on", featurestr, &local_err);\n<157> if (local_err) {\n<165> featurestr = strtok(NULL, ",");
<1> static gboolean ga_channel_listen_accept(GIOChannel *channel,\n<27> if (client_fd == -1) {\n<29> g_warning("error converting fd to gsocket: %s", strerror(errno));
<1> void kadmin_getprinc ( int argc , char * argv [ ] ) {\n<6> char * canon = NULL , * princstr = NULL , * modprincstr = NULL ;\n<9> if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( "-terse" , argv [ 1 ] ) ) ) ) {\n<10> fprintf ( stderr , _ ( "usage: get_principal [-terse] principal\n" ) ) ;\n<11> return ;\n<13> memset ( & dprinc , 0 , sizeof ( dprinc ) ) ;\n<14> retval = kadmin_parse_name ( argv [ argc - 1 ] , & princ ) ;\n<15> if ( retval ) {\n<19> retval = krb5_unparse_name ( context , princ , & canon ) ;\n<24> retval = kadm5_get_principal ( handle , princ , & dprinc , KADM5_PRINCIPAL_NORMAL_MASK | KADM5_KEY_DATA ) ;\n<26> com_err ( "get_principal" , retval , _ ( "while retrieving \"%s\"." ) , canon ) ;\n<29> retval = krb5_unparse_name ( context , dprinc . principal , & princstr ) ;\n<34> retval = krb5_unparse_name ( context , dprinc . mod_name , & modprincstr ) ;\n<39> if ( argc == 2 ) {\n<40> printf ( _ ( "Principal: %s\n" ) , princstr ) ;\n<41> printf ( _ ( "Expiration date: %s\n" ) , dprinc . princ_expire_time ? strdate ( dprinc . princ_expire_time ) : _ ( "[never]" ) ) ;\n<42> printf ( _ ( "Last password change: %s\n" ) , dprinc . last_pwd_change ? strdate ( dprinc . last_pwd_change ) : _ ( "[never]" ) ) ;\n<43> printf ( _ ( "Password expiration date: %s\n" ) , dprinc . pw_expiration ? strdate ( dprinc . pw_expiration ) : _ ( "[none]" ) ) ;\n<44> printf ( _ ( "Maximum ticket life: %s\n" ) , strdur ( dprinc . max_life ) ) ;\n<45> printf ( _ ( "Maximum renewable life: %s\n" ) , strdur ( dprinc . max_renewable_life ) ) ;\n<46> printf ( _ ( "Last modified: %s (%s)\n" ) , strdate ( dprinc . mod_date ) , modprincstr ) ;\n<47> printf ( _ ( "Last successful authentication: %s\n" ) , dprinc . last_success ? strdate ( dprinc . last_success ) : _ ( "[never]" ) ) ;\n<48> printf ( "Last failed authentication: %s\n" , dprinc . last_failed ? strdate ( dprinc . last_failed ) : "[never]" ) ;\n<49> printf ( _ ( "Failed password attempts: %d\n" ) , dprinc . fail_auth_count ) ;\n<50> printf ( _ ( "Number of keys: %d\n" ) , dprinc . n_key_data ) ;\n<52> i < dprinc . n_key_data ;\n<54> krb5_key_data * key_data = & dprinc . key_data [ i ] ;\n<56> if ( krb5_enctype_to_name ( key_data -> key_data_type [ 0 ] , FALSE , enctype , sizeof ( enctype ) ) ) snprintf ( enctype , sizeof ( enctype ) , _ ( "<Encryption type 0x%x>" ) , key_data -> key_data_type [ 0 ] ) ;\n<57> printf ( "Key: vno %d, %s, " , key_data -> key_data_kvno , enctype ) ;\n<58> if ( key_data -> key_data_ver > 1 ) {\n<59> if ( krb5_salttype_to_string ( key_data -> key_data_type [ 1 ] , salttype , sizeof ( salttype ) ) ) snprintf ( salttype , sizeof ( salttype ) , _ ( "<Salt type 0x%x>" ) , key_data -> key_data_type [ 1 ] ) ;\n<60> printf ( "%s\n" , salttype ) ;\n<62> else printf ( _ ( "no salt\n" ) ) ;\n<64> printf ( _ ( "MKey: vno %d\n" ) , dprinc . mkvno ) ;\n<65> printf ( _ ( "Attributes:" ) ) ;\n<69> if ( dprinc . attributes & ( krb5_flags ) 1 << j ) printf ( " %s" , prflags [ j ] ) ;\n<71> printf ( "\n" ) ;\n<72> polname = ( dprinc . policy != NULL ) ? dprinc . policy : _ ( "[none]" ) ;\n<73> noexist = ( dprinc . policy != NULL && ! policy_exists ( dprinc . policy ) ) ? _ ( " [does not exist]" ) : "" ;\n<74> printf ( _ ( "Policy: %s%s\n" ) , polname , noexist ) ;\n<77> printf ( "\"%s\"\t%d\t%d\t%d\t%d\t\"%s\"\t%d\t%d\t%d\t%d\t\"%s\"" "\t%d\t%d\t%d\t%d\t%d" , princstr , dprinc . princ_expire_time , dprinc . last_pwd_change , dprinc . pw_expiration , dprinc . max_life , modprincstr , dprinc . mod_date , dprinc . attributes , dprinc . kvno , dprinc . mkvno , dprinc . policy ? dprinc . policy : "[none]" , dprinc . max_renewable_life , dprinc . last_success , dprinc . last_failed , dprinc . fail_auth_count , dprinc . n_key_data ) ;\n<79> i < dprinc . n_key_data ;\n<80> i ++ ) printf ( "\t%d\t%d\t%d\t%d" , dprinc . key_data [ i ] . key_data_ver , dprinc . key_data [ i ] . key_data_kvno , dprinc . key_data [ i ] . key_data_type [ 0 ] , dprinc . key_data [ i ] . key_data_type [ 1 ] ) ;\n<81> printf ( "\n" ) ;\n<84> kadm5_free_principal_ent ( handle , & dprinc ) ;\n<85> free ( canon ) ;\n<86> free ( princstr ) ;\n<87> free ( modprincstr ) ;
<1> static const main_extcomp * main_ident_compressor ( const char * ident ) {\n<4> i < SIZEOF_ARRAY ( extcomp_types ) ;\n<5> i += 1 ) {\n<6> if ( strcmp ( extcomp_types [ i ] . ident , ident ) == 0 ) {\n<7> return & extcomp_types [ i ] ;
<1> static void qemu_net_queue_append(NetQueue *queue,\n<7> const uint8_t *buf,\n<9> size_t size,\n<19> if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n<25> packet = g_malloc(sizeof(NetPacket) + size);\n<35> memcpy(packet->data, buf, size);\n<40> QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);
<1> static int kq_del ( void * arg , struct event * ev ) {\n<12> if ( TAILQ_EMPTY ( & kqop -> evsigevents [ nsignal ] ) ) {\n<13> memset ( & kev , 0 , sizeof ( kev ) ) ;\n<17> if ( kevent ( kqop -> kq , & kev , 1 , NULL , 0 , & timeout ) == - 1 ) return ( - 1 ) ;\n<23> if ( ev -> ev_events & EV_READ ) {\n<24> memset ( & kev , 0 , sizeof ( kev ) ) ;\n<25> kev . ident = ev -> ev_fd ;\n<26> kev . filter = EVFILT_READ ;\n<27> kev . flags = EV_DELETE ;\n<28> if ( kq_insert ( kqop , & kev ) == - 1 ) return ( - 1 ) ;\n<31> if ( ev -> ev_events & EV_WRITE ) {\n<32> memset ( & kev , 0 , sizeof ( kev ) ) ;\n<36> if ( kq_insert ( kqop , & kev ) == - 1 ) return ( - 1 ) ;
<1> static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n<17> avio_read(pb, type, 4);\n<19> if (strcmp(type, "qt  "))\n<21> c->isom = 1;\n<23> av_log(c->fc, AV_LOG_DEBUG, "ISO: File Type Major Brand: %.4s\n",(char *)&type);\n<25> av_dict_set(&c->fc->metadata, "major_brand", type, 0);
<1> static teReqs _tocEntryRequired ( TocEntry * te , teSection curSection , RestoreOptions * ropt ) {\n<3> if ( strcmp ( te -> desc , "ENCODING" ) == 0 || strcmp ( te -> desc , "STDSTRINGS" ) == 0 ) return REQ_SPECIAL ;\n<4> if ( ropt -> aclsSkip && _tocEntryIsACL ( te ) ) return 0 ;\n<5> if ( ropt -> no_security_labels && strcmp ( te -> desc , "SECURITY LABEL" ) == 0 ) return 0 ;\n<6> switch ( curSection ) {\n<19> if ( ropt -> selTypes ) {\n<20> if ( strcmp ( te -> desc , "TABLE" ) == 0 || strcmp ( te -> desc , "TABLE DATA" ) == 0 || strcmp ( te -> desc , "VIEW" ) == 0 || strcmp ( te -> desc , "FOREIGN TABLE" ) == 0 || strcmp ( te -> desc , "MATERIALIZED VIEW" ) == 0 || strcmp ( te -> desc , "MATERIALIZED VIEW DATA" ) == 0 || strcmp ( te -> desc , "SEQUENCE" ) == 0 || strcmp ( te -> desc , "SEQUENCE SET" ) == 0 ) {\n<21> if ( ! ropt -> selTable ) return 0 ;\n<22> if ( ropt -> tableNames . head != NULL && ( ! ( simple_string_list_member ( & ropt -> tableNames , te -> tag ) ) ) ) return 0 ;\n<24> else if ( strcmp ( te -> desc , "INDEX" ) == 0 ) {\n<25> if ( ! ropt -> selIndex ) return 0 ;\n<26> if ( ropt -> indexNames . head != NULL && ( ! ( simple_string_list_member ( & ropt -> indexNames , te -> tag ) ) ) ) return 0 ;\n<28> else if ( strcmp ( te -> desc , "FUNCTION" ) == 0 ) {\n<29> if ( ! ropt -> selFunction ) return 0 ;\n<30> if ( ropt -> functionNames . head != NULL && ( ! ( simple_string_list_member ( & ropt -> functionNames , te -> tag ) ) ) ) return 0 ;\n<32> else if ( strcmp ( te -> desc , "TRIGGER" ) == 0 ) {\n<33> if ( ! ropt -> selTrigger ) return 0 ;\n<34> if ( ropt -> triggerNames . head != NULL && ( ! ( simple_string_list_member ( & ropt -> triggerNames , te -> tag ) ) ) ) return 0 ;\n<36> else return 0 ;\n<38> if ( ! te -> hadDumper ) {\n<39> if ( strcmp ( te -> desc , "SEQUENCE SET" ) == 0 || strcmp ( te -> desc , "BLOB" ) == 0 || ( strcmp ( te -> desc , "ACL" ) == 0 && strncmp ( te -> tag , "LARGE OBJECT " , 13 ) == 0 ) || ( strcmp ( te -> desc , "COMMENT" ) == 0 && strncmp ( te -> tag , "LARGE OBJECT " , 13 ) == 0 ) || ( strcmp ( te -> desc , "SECURITY LABEL" ) == 0 && strncmp ( te -> tag , "LARGE OBJECT " , 13 ) == 0 ) ) res = res & REQ_DATA ;\n<40> else res = res & ~ REQ_DATA ;\n<42> if ( ( strcmp ( te -> desc , "<Init>" ) == 0 ) && ( strcmp ( te -> tag , "Max OID" ) == 0 ) ) return 0 ;\n<43> if ( ropt -> schemaOnly ) res = res & REQ_SCHEMA ;\n<44> if ( ropt -> dataOnly ) res = res & REQ_DATA ;\n<45> if ( ! te -> defn || strlen ( te -> defn ) == 0 ) res = res & ~ REQ_SCHEMA ;\n<46> if ( ropt -> idWanted && ! ropt -> idWanted [ te -> dumpId - 1 ] ) return 0 ;
<1> void prepare_grab(void)\n<5> fprintf(stderr, "Must supply at least one input file\n");
<1> static void show_error ( WriterContext * w , int err ) {\n<4> if ( av_strerror ( err , errbuf , sizeof ( errbuf ) ) < 0 ) errbuf_ptr = strerror ( AVUNERROR ( err ) ) ;\n<7> print_str ( "string" , errbuf_ptr ) ;
<1> static int msrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> MsrleContext * s = avctx -> priv_data ;\n<13> if ( avctx -> bits_per_coded_sample <= 8 ) {\n<14> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<15> if ( pal ) {\n<17> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<19> memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n<22> int linesize = avctx -> width * avctx -> bits_per_coded_sample / 8 ;\n<23> uint8_t * ptr = s -> frame . data [ 0 ] ;\n<24> uint8_t * buf = avpkt -> data + ( avctx -> height - 1 ) * istride ;\n<29> if ( avctx -> bits_per_coded_sample == 4 ) {\n<33> ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n<34> ptr [ j + 1 ] = buf [ j >> 1 ] & 0xF ;\n<36> if ( avctx -> width & 1 ) ptr [ j + 0 ] = buf [ j >> 1 ] >> 4 ;\n<39> memcpy ( ptr , buf , linesize ) ;\n<41> buf -= istride ;\n<42> ptr += s -> frame . linesize [ 0 ] ;
<1> static void * jbig2_default_realloc ( Jbig2Allocator * allocator , void * p , size_t size ) {\n<2> return realloc ( p , size ) ;
<1> static void test_fork ( void ) {\n<6> write ( pair [ 0 ] , TEST1 , strlen ( TEST1 ) + 1 ) ;\n<12> if ( event_reinit ( current_base ) == - 1 ) {\n<13> fprintf ( stderr , "FAILED (reinit)\n" ) ;\n<22> write ( pair [ 0 ] , TEST1 , strlen ( TEST1 ) + 1 ) ;\n<23> if ( waitpid ( pid , & status , 0 ) == - 1 ) {\n<24> fprintf ( stderr , "FAILED (fork)\n" ) ;\n<27> if ( WEXITSTATUS ( status ) != 76 ) {\n<28> fprintf ( stderr , "FAILED (exit): %d\n" , WEXITSTATUS ( status ) ) ;\n<31> write ( pair [ 0 ] , TEST1 , strlen ( TEST1 ) + 1 ) ;\n<32> shutdown ( pair [ 0 ] , SHUT_WR ) ;\n<34> if ( ! got_sigchld ) {\n<35> fprintf ( stdout , "FAILED (sigchld)\n" ) ;
<1> qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,\n<37> buf = qemu_blockalign(bs, s->cluster_size);\n<39> if (bytes != s->cluster_size) {\n<41> if (bytes > s->cluster_size ||\n<55> memset(buf + bytes, 0, s->cluster_size - bytes);\n<69> memset(&strm, 0, sizeof(strm));\n<97> ret = deflate(&strm, Z_FINISH);\n<101> deflateEnd(&strm);\n<109> out_len = strm.next_out - out_buf;\n<113> deflateEnd(&strm);
<1> static int enable_write_target(BDRVVVFATState *s)\n<11> int size = sector2cluster(s, s->sector_count);\n<13> s->used_clusters = calloc(size, 1);\n<67> if (ret < 0) {\n<83> s->bs->backing_hd = calloc(sizeof(BlockDriverState), 1);\n<89> *(void**)s->bs->backing_hd->opaque = s;
<1> static void versatile_init(MachineState *machine, int board_id)\n<23> fprintf(stderr, "Unable to find CPU definition\n");
<1> static celt element ( struct vars * v , const chr * startp , const chr * endp ) {\n<6> if ( len == 1 ) return * startp ;\n<8> for ( cn = cnames ;\n<9> cn -> name != NULL ;\n<10> cn ++ ) {\n<11> if ( strlen ( cn -> name ) == len && pg_char_and_wchar_strncmp ( cn -> name , startp , len ) == 0 ) {\n<15> if ( cn -> name != NULL ) return CHR ( cn -> code ) ;
<1> static int zmbv_decode_xor_32 ( ZmbvContext * c ) {\n<28> out = output + x ;\n<35> if ( my + j < 0 || my + j >= c -> height ) {\n<36> memset ( out , 0 , bw2 * 4 ) ;\n<42> if ( mx + i < 0 || mx + i >= c -> width ) out [ i ] = 0 ;\n<43> else out [ i ] = tprev [ i ] ;\n<46> out += c -> width ;\n<57> out [ i ] ^= * ( ( uint32_t * ) src ) ;
<1> static void mp_decode_frame_helper ( MotionPixelsContext * mp , GetBitContext * gb ) {\n<7> if ( mp -> changes_map [ y * mp -> avctx -> width ] != 0 ) {\n<8> memset ( mp -> gradient_scale , 1 , sizeof ( mp -> gradient_scale ) ) ;\n<9> p = mp_get_yuv_from_rgb ( mp , 0 , y ) ;\n<12> p . y += mp_gradient ( mp , 0 , mp_get_vlc ( mp , gb ) ) ;\n<15> p . v += mp_gradient ( mp , 1 , mp_get_vlc ( mp , gb ) ) ;\n<17> p . u += mp_gradient ( mp , 2 , mp_get_vlc ( mp , gb ) ) ;\n<21> mp_set_rgb_from_yuv ( mp , 0 , y , & p ) ;\n<28> y += 2 ) mp_decode_line ( mp , gb , y ) ;
<1> static void authenticate ( struct parse * pcmd , FILE * fp ) {\n<3> if ( always_auth ) {\n<4> ( void ) fprintf ( fp , "authenticated requests being sent\n" ) ;\n<6> else ( void ) fprintf ( fp , "unauthenticated requests being sent\n" ) ;\n<12> else if ( STREQ ( pcmd -> argval [ 0 ] . string , "no" ) ) {\n<15> else ( void ) fprintf ( stderr , "What?\n" ) ;
<1> int test_sub ( BIO * bp ) {\n<34> if ( ! BN_is_zero ( & c ) ) {\n<35> fprintf ( stderr , "Subtract test failed!\n" ) ;
<1> void *kqemu_vmalloc(size_t size)\n<19> if (phys_ram_fd < 0) {\n<21> tmpdir = getenv("QEMU_TMPDIR");\n<23> if (!tmpdir)\n<27> if (statfs(tmpdir, &stfs) == 0) {\n<39> if ((ram_size + 8192 * 1024) >= free_space) {\n<41> ram_mb = (ram_size / (1024 * 1024));\n<49> if (strcmp(tmpdir, "/dev/shm") == 0) {\n<51> fprintf(stderr, "To have more space available provided you have enough RAM and swap, do as root:\n"\n<57> ram_mb + 16);\n<71> fprintf(stderr, "Or disable the accelerator module with -no-kqemu\n");\n<79> snprintf(phys_ram_file, sizeof(phys_ram_file), "%s/qemuXXXXXX",\n<83> if (mkstemp(phys_ram_file) < 0) {\n<99> if (mkstemp(phys_ram_file) < 0) {\n<101> fprintf(stderr, "Could not create temporary memory file '%s'\n",\n<111> phys_ram_fd = open(phys_ram_file, O_CREAT | O_TRUNC | O_RDWR, 0600);\n<113> if (phys_ram_fd < 0) {\n<115> fprintf(stderr, "Could not open temporary memory file '%s'\n",\n<123> unlink(phys_ram_file);\n<139> if (ptr == MAP_FAILED) {\n<141> fprintf(stderr, "Could not map physical memory\n");
<1> static guint16 de_bcd_num ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , int header_field , const gchar * * extracted_address ) {\n<22> item = proto_tree_add_string ( tree , header_field , tvb , curr_offset , num_string_len , * extracted_address ) ;\n<23> if ( strchr ( * extracted_address , '?' ) ) {\n<24> expert_add_info ( pinfo , item , & ei_gsm_a_dtap_end_mark_unexpected ) ;
<1> static void lpc_prediction ( int32_t * error_buffer , int32_t * buffer_out , int nb_samples , int bps , int16_t * lpc_coefs , int lpc_order , int lpc_quant ) {\n<6> if ( ! lpc_order ) {\n<7> memcpy ( & buffer_out [ 1 ] , & error_buffer [ 1 ] , ( nb_samples - 1 ) * sizeof ( * buffer_out ) ) ;
<1> static void tokenize ( const char * line , char * * tokens , int * ntok ) {\n<15> if ( sp - tspace >= MAXLINE ) goto toobig ;\n<23> if ( sp - tspace >= MAXLINE ) goto toobig ;\n<30> if ( sp - tspace >= MAXLINE ) goto toobig ;\n<35> if ( sp - tspace >= MAXLINE ) goto toobig ;\n<40> fprintf ( stderr , "***Line `%s' is too big\n" , line ) ;
<1> int kvmppc_get_htab_fd(bool write)\n<15> if (!cap_htab_fd) {\n<17> fprintf(stderr, "KVM version doesn't support saving the hash table\n");
<1> AVFilterContext *avfilter_open(AVFilter *filter, char *inst_name)\n<5> AVFilterContext *ret = av_malloc(sizeof(AVFilterContext));\n<21> ret->input_count  = pad_count(filter->inputs);\n<23> ret->input_pads   = av_malloc(sizeof(AVFilterPad) * ret->input_count);\n<25> memcpy(ret->input_pads, filter->inputs, sizeof(AVFilterPad)*ret->input_count);\n<31> ret->output_count = pad_count(filter->outputs);\n<33> ret->output_pads  = av_malloc(sizeof(AVFilterPad) * ret->output_count);\n<35> memcpy(ret->output_pads, filter->outputs, sizeof(AVFilterPad)*ret->output_count);\n<41> return ret;
<1> static void config_unpeers ( config_tree * ptree ) {\n<12> if ( curr_unpeer -> assocID ) {\n<21> memset ( & peeraddr , 0 , sizeof ( peeraddr ) ) ;\n<22> AF ( & peeraddr ) = curr_unpeer -> addr -> type ;\n<24> rc = getnetnum ( name , & peeraddr , 0 , t_UNK ) ;\n<26> DPRINTF ( 1 , ( "unpeer: searching for %s\n" , stoa ( & peeraddr ) ) ) ;\n<27> p = findexistingpeer ( & peeraddr , NULL , NULL , - 1 ) ;\n<29> msyslog ( LOG_NOTICE , "unpeered %s" , stoa ( & peeraddr ) ) ;
<1> static bool gn_to_string ( identification_t * id , char * * uri ) {\n<9> free ( * uri ) ;
<1> static int get_channel_idx(char **map, int *ch, char delim, int max_ch)\n<5> char *next = split(*map, delim);\n<9> int n = 0;\n<11> if (!next && delim == '-')\n<16> len = strlen(*map);\n<18> sscanf(*map, "%d%n", ch, &n);\n<20> if (n != len)
<1> PHP_FUNCTION ( locale_lookup ) {\n<23> if ( result == NULL || result [ 0 ] == '\0' ) {\n<25> result = estrndup ( fallback_loc , fallback_loc_len ) ;\n<31> RETVAL_STRINGL ( result , strlen ( result ) , 0 ) ;
<1> static int read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> PAFDemuxContext *p = s->priv_data;\n<29> if (av_new_packet(pkt, p->audio_size) < 0)\n<35> memcpy(pkt->data, p->temp_audio_frame, p->audio_size);\n<37> pkt->duration     = PAF_SOUND_SAMPLES * (p->audio_size / PAF_SOUND_FRAME_SIZE);\n<65> if (offset > p->audio_size - p->buffer_size)\n<71> avio_read(pb, p->audio_frame + offset, p->buffer_size);\n<73> if (offset == (p->max_audio_blks - 2) * p->buffer_size) {\n<75> memcpy(p->temp_audio_frame, p->audio_frame, p->audio_size);\n<99> size = p->video_size - p->frames_offset_table[p->current_frame];\n<107> if (av_new_packet(pkt, size) < 0)\n<117> memcpy(pkt->data, p->video_frame + p->frames_offset_table[p->current_frame], size);
<1> static int wavpack_decode_block(AVCodecContext *avctx, int block_no,\n<53> if(!s){\n<63> if(!s->samples_left){\n<65> memset(s->decorr, 0, MAX_TERMS * sizeof(Decorr));\n<67> memset(s->ch, 0, sizeof(s->ch));\n<715> samplecount = wv_unpack_stereo(s, &s->gb, samples, AV_SAMPLE_FMT_S16);\n<719> samplecount = wv_unpack_stereo(s, &s->gb, samples, AV_SAMPLE_FMT_S32);\n<723> samplecount = wv_unpack_stereo(s, &s->gb, samples, AV_SAMPLE_FMT_FLT);\n<735> samplecount = wv_unpack_mono(s, &s->gb, samples, AV_SAMPLE_FMT_S16);\n<739> samplecount = wv_unpack_mono(s, &s->gb, samples, AV_SAMPLE_FMT_S32);\n<743> samplecount = wv_unpack_mono(s, &s->gb, samples, AV_SAMPLE_FMT_FLT);
<1> static int udp_socket_create(UDPContext *s, struct sockaddr_storage *addr,\n<27> for (res = res0; res; res=res->ai_next) {\n<39> if (udp_fd < 0)\n<45> memcpy(addr, res->ai_addr, res->ai_addrlen);\n<47> *addr_len = res->ai_addrlen;
<1> static int open_f(BlockBackend *blk, int argc, char **argv)\n<81> if (imageOpts) {\n<83> printf("--image-opts and 'open -o' are mutually exclusive\n");
<1> void xmlrpc_generic_error ( int code , const char * string ) {\n<4> mowgli_string_t * s = mowgli_string_create ( ) ;\n<8> snprintf ( buf , sizeof buf , "<?xml version=\"1.0\" encoding=\"%s\" ?>\r\n<methodResponse>\r\n" , xmlrpc . encode ) ;\n<11> snprintf ( buf , sizeof buf , "<?xml version=\"1.0\"?>\r\n<methodResponse>\r\n" ) ;\n<13> s -> append ( s , buf , strlen ( buf ) ) ;\n<14> ss = " <fault>\r\n <value>\r\n <struct>\r\n <member>\r\n <name>faultCode<ame>\r\n <value><int>" ;\n<15> s -> append ( s , ss , strlen ( ss ) ) ;\n<16> snprintf ( buf , sizeof buf , "%d" , code ) ;\n<17> s -> append ( s , buf , strlen ( buf ) ) ;\n<18> ss = "</int></value>\r\n </member>\r\n <member>\r\n <name>faultString<ame>\r\n <value><string>" ;\n<19> s -> append ( s , ss , strlen ( ss ) ) ;\n<20> xmlrpc_append_char_encode ( s , string ) ;\n<21> ss = "</string></value>\r\n </member>\r\n </struct>\r\n </value>\r\n </fault>\r\n</methodResponse>" , s -> append ( s , ss , strlen ( ss ) ) ;\n<22> len = s -> pos ;\n<23> if ( xmlrpc . httpheader ) {\n<24> char * header = xmlrpc_write_header ( len ) ;\n<25> s2 = smalloc ( strlen ( header ) + len + 1 ) ;\n<26> strcpy ( s2 , header ) ;\n<27> memcpy ( s2 + strlen ( header ) , s -> str , len ) ;\n<28> xmlrpc . setbuffer ( s2 , len + strlen ( header ) ) ;\n<29> free ( header ) ;\n<30> free ( s2 ) ;\n<32> else xmlrpc . setbuffer ( s -> str , len ) ;\n<33> s -> destroy ( s ) ;
<1> static int process_request ( http_message_t * req , enum resp_type * rtype , membuffer * headers , membuffer * filename , struct xml_alias_t * alias , struct SendInstruction * RespInstr ) {\n<19> memset ( & finfo , 0 , sizeof ( finfo ) ) ;\n<27> request_doc = malloc ( url -> pathquery . size + 1 ) ;\n<28> if ( request_doc == NULL ) {\n<31> memcpy ( request_doc , url -> pathquery . buff , url -> pathquery . size ) ;\n<32> request_doc [ url -> pathquery . size ] = '\0' ;\n<33> dummy = url -> pathquery . size ;\n<34> remove_escaped_chars ( request_doc , & dummy ) ;\n<35> code = remove_dots ( request_doc , url -> pathquery . size ) ;\n<40> if ( * request_doc != '/' ) {\n<44> if ( isFileInVirtualDir ( request_doc ) ) {\n<47> if ( membuffer_assign_str ( filename , request_doc ) != 0 ) {\n<55> using_alias = get_alias ( request_doc , alias , finfo ) ;\n<59> if ( UpnpFileInfo_get_ContentType ( finfo ) == NULL ) {\n<67> if ( virtualDirCallback . get_info ( filename -> buf , finfo ) != 0 ) {\n<71> if ( UpnpFileInfo_get_IsDirectory ( finfo ) ) {\n<81> if ( virtualDirCallback . get_info ( filename -> buf , finfo ) != UPNP_E_SUCCESS || UpnpFileInfo_get_IsDirectory ( finfo ) ) {\n<86> if ( ! UpnpFileInfo_get_IsReadable ( finfo ) ) {\n<96> if ( membuffer_assign_str ( filename , gDocumentRootDir . buf ) != 0 || membuffer_append_str ( filename , request_doc ) != 0 ) {\n<103> if ( get_file_info ( filename -> buf , finfo ) != 0 ) {\n<107> if ( UpnpFileInfo_get_IsDirectory ( finfo ) ) {\n<117> if ( get_file_info ( filename -> buf , finfo ) != 0 || UpnpFileInfo_get_IsDirectory ( finfo ) ) {\n<122> if ( ! UpnpFileInfo_get_IsReadable ( finfo ) ) {\n<128> RespInstr -> ReadSendSize = UpnpFileInfo_get_FileLength ( finfo ) ;\n<129> code = CheckOtherHTTPHeaders ( req , RespInstr , UpnpFileInfo_get_FileLength ( finfo ) ) ;\n<139> extra_headers = UpnpFileInfo_get_ExtraHeaders ( finfo ) ;\n<143> if ( using_virtual_dir && UpnpFileInfo_get_FileLength ( finfo ) == UPNP_USING_CHUNKED ) {\n<152> aux_LastModified = UpnpFileInfo_get_LastModified ( finfo ) ;\n<154> if ( http_MakeMessage ( headers , resp_major , resp_minor , "R" "T" "GKLD" "s" "tcS" "Xc" "sCc" , HTTP_PARTIAL_CONTENT , UpnpFileInfo_get_ContentType ( finfo ) , RespInstr , RespInstr , "LAST-MODIFIED: " , & aux_LastModified , X_USER_AGENT , extra_headers ) != 0 ) {\n<159> if ( http_MakeMessage ( headers , resp_major , resp_minor , "R" "N" "T" "GLD" "s" "tcS" "Xc" "sCc" , HTTP_PARTIAL_CONTENT , RespInstr -> ReadSendSize , UpnpFileInfo_get_ContentType ( finfo ) , RespInstr , RespInstr , "LAST-MODIFIED: " , & aux_LastModified , X_USER_AGENT , extra_headers ) != 0 ) {\n<164> if ( http_MakeMessage ( headers , resp_major , resp_minor , "RK" "TLD" "s" "tcS" "Xc" "sCc" , HTTP_OK , UpnpFileInfo_get_ContentType ( finfo ) , RespInstr , "LAST-MODIFIED: " , & aux_LastModified , X_USER_AGENT , extra_headers ) != 0 ) {\n<170> if ( http_MakeMessage ( headers , resp_major , resp_minor , "R" "N" "TLD" "s" "tcS" "Xc" "sCc" , HTTP_OK , RespInstr -> ReadSendSize , UpnpFileInfo_get_ContentType ( finfo ) , RespInstr , "LAST-MODIFIED: " , & aux_LastModified , X_USER_AGENT , extra_headers ) != 0 ) {\n<175> if ( http_MakeMessage ( headers , resp_major , resp_minor , "R" "TLD" "s" "tcS" "Xc" "sCc" , HTTP_OK , UpnpFileInfo_get_ContentType ( finfo ) , RespInstr , "LAST-MODIFIED: " , & aux_LastModified , X_USER_AGENT , extra_headers ) != 0 ) {\n<196> error_handler : free ( request_doc ) ;\n<197> UpnpFileInfo_delete ( finfo ) ;
<1> static int mxf_read_local_tags(MXFContext *mxf, KLVPacket *klv, int (*read_child)(), int ctx_size, enum MXFMetadataSetType type)\n<25> UID uid = {0};\n<47> if (local_tag == tag) {\n<49> memcpy(uid, mxf->local_tags+i*18+2, 16);\n<53> PRINT_KEY(mxf->fc, "uid", uid);
<1> void qemu_macaddr_default_if_unset(MACAddr *macaddr)\n<7> static const MACAddr zero = { .a = { 0,0,0,0,0,0 } };\n<11> if (memcmp(macaddr, &zero, sizeof(zero)) != 0)\n<13> return;\n<15> macaddr->a[0] = 0x52;\n<17> macaddr->a[1] = 0x54;\n<19> macaddr->a[2] = 0x00;\n<21> macaddr->a[3] = 0x12;\n<23> macaddr->a[4] = 0x34;\n<25> macaddr->a[5] = 0x56 + index++;
<1> static int pxa2xx_pwrmode_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n<6> if ( value & 8 ) {\n<7> printf ( "%s: CPU voltage change attempt\n" , __func__ ) ;\n<9> switch ( value & 7 ) {\n<11> case 1 : if ( ! ( s -> cm_regs [ CCCR >> 2 ] & ( 1 << 31 ) ) ) {\n<25> memset ( s -> cpu -> env . regs , 0 , 4 * 15 ) ;\n<33> default : message : printf ( "%s: machine entered %s mode\n" , __func__ , pwrmode [ value & 7 ] ) ;
<1> static int rsd_probe(AVProbeData *p)\n<5> if (!memcmp(p->buf, "RSD", 3) &&\n<7> p->buf[3] - '0' >= 2 && p->buf[3] - '0' <= 6)\n<9> return AVPROBE_SCORE_EXTENSION;\n<11> return 0;
<1> static void truespeech_update_filters ( TSContext * dec , int16_t * out , int quart ) {\n<3> memmove ( dec -> filtbuf , & dec -> filtbuf [ 60 ] , 86 * sizeof ( * dec -> filtbuf ) ) ;
<1> static int teletext_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *pkt)\n<57> if ((pesheader_size + left) < 184 || (pesheader_size + left) > 65504 || (pesheader_size + left) % 184 != 0)\n<63> memset(pesheader + 14, 0xff, pesheader_size - 14);
<1> static int kvm_get_sregs(CPUState *env)\n<13> ret = kvm_vcpu_ioctl(env, KVM_GET_SREGS, &sregs);\n<15> if (ret < 0)\n<69> cpu_set_apic_base(env, sregs.apic_base);
<1> void qemu_set_log_filename(const char *filename)\n<11> pidstr = strstr(filename, "%");\n<13> if (pidstr) {\n<17> if (pidstr[1] != 'd' || strchr(pidstr + 2, '%')) {\n<19> error_report("Bad logfile format: %s", filename);\n<21> logfilename = NULL;\n<25> logfilename = g_strdup_printf(filename, getpid());\n<31> logfilename = g_strdup(filename);
<1> static void qtrle_encode_line(QtrleEncContext *s, AVFrame *p, int line, uint8_t **buf)\n<47> uint8_t *this_line = p->               data[0] + line*p->               linesize[0] +\n<51> uint8_t *prev_line = s->previous_frame.data[0] + line*s->previous_frame.linesize[0] +\n<53> (width - 1)*s->pixel_size;\n<63> for (i = width - 1; i >= 0; i--) {\n<67> if (!s->frame.key_frame && !memcmp(this_line, prev_line, s->pixel_size))\n<69> skipcount = FFMIN(skipcount + 1, MAX_RLE_SKIP);\n<73> skipcount = 0;\n<85> if (i < width - 1 && !memcmp(this_line, this_line + s->pixel_size, s->pixel_size))\n<87> repeatcount = FFMIN(repeatcount + 1, MAX_RLE_REPEAT);\n<91> repeatcount = 1;\n<95> total_repeat_cost = s->length_table[i + repeatcount] + 1 + s->pixel_size;\n<177> this_line -= s->pixel_size;\n<179> prev_line -= s->pixel_size;
<1> static sd_rsp_type_t sd_normal_command(SDState *sd,\n<3> SDRequest req)\n<19> DPRINTF("CMD%d 0x%08x state %d\n", req.cmd, req.arg, sd->state);\n<21> switch (req.cmd) {\n<51> if (!sd->spi)\n<65> if (sd->spi)\n<69> switch (sd->state) {\n<91> if (sd->spi)\n<95> switch (sd->state) {\n<121> if (sd->spi)\n<153> if (sd->spi)\n<157> switch (sd->mode) {\n<185> if (sd->spi)\n<189> switch (sd->state) {\n<209> if (sd->rca == rca)\n<237> if (sd->rca == rca)\n<263> switch (sd->state) {\n<299> switch (sd->state) {\n<315> if (!sd->spi)\n<321> memcpy(sd->data, sd->csd, 16);\n<343> switch (sd->state) {\n<359> if (!sd->spi)\n<365> memcpy(sd->data, sd->cid, 16);\n<387> if (sd->spi)\n<391> switch (sd->state) {\n<423> switch (sd->state) {\n<457> switch (sd->mode) {\n<483> if (sd->spi)\n<487> switch (sd->mode) {\n<517> switch (sd->state) {\n<547> switch (sd->state) {\n<579> switch (sd->state) {\n<613> if (sd->spi)\n<617> switch (sd->state) {\n<623> if (sd->spi)\n<665> if (sd->spi)\n<669> switch (sd->state) {\n<675> if (sd->spi)\n<717> if (sd->spi)\n<721> switch (sd->state) {\n<747> if (sd->spi)\n<751> switch (sd->state) {\n<779> switch (sd->state) {\n<819> switch (sd->state) {\n<859> switch (sd->state) {\n<889> switch (sd->state) {\n<911> switch (sd->state) {\n<933> switch (sd->state) {\n<973> if (sd->spi)\n<977> switch (sd->state) {\n<1041> fprintf(stderr, "SD: GEN_CMD 0x%08x\n", req.arg);\n<1045> switch (sd->state) {\n<1051> if (req.arg & 1)\n<1081> fprintf(stderr, "SD: Unknown CMD%i\n", req.cmd);\n<1093> fprintf(stderr, "SD: CMD%i not implemented in SPI mode\n", req.cmd);\n<1103> fprintf(stderr, "SD: CMD%i in a wrong state\n", req.cmd);
<1> static int handle_secondary_tcp_pkt(NetFilterState *nf,\n<17> if (trace_event_get_state(TRACE_COLO_FILTER_REWRITER_DEBUG)) {\n<21> sdebug = strdup(inet_ntoa(pkt->ip->ip_src));\n<23> ddebug = strdup(inet_ntoa(pkt->ip->ip_dst));\n<25> trace_colo_filter_rewriter_pkt_info(__func__, sdebug, ddebug,
<1> void helper_discard_movcal_backup(CPUSH4State *env)\n<5> memory_content *current = env->movcal_backup;\n<9> while(current)\n<15> free (current);\n<19> if (current == NULL)
<1> void qbus_create_inplace ( BusState * bus , BusInfo * info , DeviceState * parent , const char * name ) {\n<9> else if ( parent && parent -> id ) {\n<10> len = strlen ( parent -> id ) + 16 ;\n<11> buf = qemu_malloc ( len ) ;\n<12> snprintf ( buf , len , "%s.%d" , parent -> id , parent -> num_child_bus ) ;\n<16> len = strlen ( info -> name ) + 16 ;\n<17> buf = qemu_malloc ( len ) ;\n<18> len = snprintf ( buf , len , "%s.%d" , info -> name , parent ? parent -> num_child_bus : 0 ) ;
<1> void qemu_coroutine_enter(Coroutine *co, void *opaque)\n<15> if (co->caller) {\n<17> fprintf(stderr, "Co-routine re-entered recursively\n");
<1> int ff_srtp_decrypt(struct SRTPContext *s, uint8_t *buf, int *lenptr)\n<23> if (len < s->hmac_size)\n<97> av_hmac_final(s->hmac, hmac, sizeof(hmac));\n<99> if (memcmp(hmac, buf + len - s->hmac_size, s->hmac_size)) {\n<101> av_log(NULL, AV_LOG_WARNING, "HMAC mismatch\n");\n<103> return AVERROR_INVALIDDATA;\n<109> len -= s->hmac_size;\n<111> *lenptr = len;\n<115> if (len < 12)
<1> int gx_device_delete_output_file ( const gx_device * dev , const char * fname ) {\n<6> if ( pfname == NULL ) {\n<10> code = gx_parse_output_file_name ( & parsed , & fmt , fname , strlen ( fname ) , dev -> memory ) ;\n<11> if ( code < 0 ) {\n<14> if ( parsed . iodev && ! strcmp ( parsed . iodev -> dname , "%stdout%" ) ) goto done ;\n<15> if ( fmt ) {\n<21> else if ( parsed . len && strchr ( parsed . fname , '%' ) ) gs_sprintf ( pfname , parsed . fname ) ;\n<22> else pfname [ 0 ] = 0 ;\n<23> if ( pfname [ 0 ] ) {\n<24> parsed . fname = pfname ;\n<25> parsed . len = strlen ( parsed . fname ) ;\n<27> if ( parsed . iodev ) code = parsed . iodev -> procs . delete_file ( ( gx_io_device * ) ( & parsed . iodev ) , ( const char * ) parsed . fname ) ;
<1> static int calc_slice_sizes ( VC2EncContext * s ) {\n<17> slice_x < s -> num_x ;\n<19> SliceArgs * args = & enc_args [ s -> num_x * slice_y + slice_x ] ;\n<25> memset ( args -> cache , 0 , s -> q_ceil * sizeof ( * args -> cache ) ) ;\n<39> top_loc [ j ] = args ;\n<56> bits = count_hq_slice ( args , new_idx ) ;
<1> static void test_long_data ( ) {\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<26> my_bind [ 2 ] = my_bind [ 1 ] ;\n<27> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<30> data = ( char * ) "Michael" ;\n<31> rc = mysql_stmt_send_long_data ( stmt , 1 , data , strlen ( data ) ) ;\n<32> data = ( char * ) " 'Monty' Widenius" ;\n<33> rc = mysql_stmt_send_long_data ( stmt , 1 , data , strlen ( data ) ) ;\n<37> rc = mysql_stmt_execute ( stmt ) ;\n<38> if ( ! opt_silent ) fprintf ( stdout , " mysql_stmt_execute() returned %d\n" , rc ) ;\n<39> check_execute ( stmt , rc ) ;
<1> static GstFlowReturn gst_asf_demux_process_language_list ( GstASFDemux * demux , guint8 * data , guint64 size ) {\n<19> if ( gst_asf_demux_get_bytes ( & lang_data , len , & data , & size ) ) {\n<21> utf8 = g_convert ( ( gchar * ) lang_data , len , "UTF-8" , "UTF-16LE" , NULL , NULL , NULL ) ;\n<22> if ( utf8 && strlen ( utf8 ) >= 5 && ( utf8 [ 2 ] == '-' || utf8 [ 2 ] == '_' ) ) {\n<23> utf8 [ 2 ] = '\0' ;\n<25> GST_DEBUG ( "[%u] %s" , i , GST_STR_NULL ( utf8 ) ) ;
<1> void helper_booke206_tlbwe(void)\n<24> fprintf(stderr, "cpu: don't support LRAT setting yet\n");
<1> int nbd_receive_reply(int csock, struct nbd_reply *reply)\n<11> memset(buf, 0xAA, sizeof(buf));
<1> static void do_video_out(AVFormatContext *s,\n<5> AVInputStream *ist,\n<51> vdelta = get_sync_ipts(ost) / av_q2d(enc->time_base) - ost->sync_opts;\n<67> ost->sync_opts= lrintf(get_sync_ipts(ost) / av_q2d(enc->time_base));\n<79> if (verbose>2)\n<81> fprintf(stderr, "*** drop!\n");\n<87> if (verbose>2)\n<89> fprintf(stderr, "*** %d dup!\n", nb_frames-1);\n<95> ost->sync_opts= lrintf(get_sync_ipts(ost) / av_q2d(enc->time_base));\n<109> if (av_picture_crop((AVPicture *)&picture_crop_temp, (AVPicture *)in_picture, dec->pix_fmt, ost->topBand, ost->leftBand) < 0) {\n<111> fprintf(stderr, "error cropping picture\n");\n<143> if (av_picture_crop((AVPicture *)&picture_pad_temp, (AVPicture *)final_picture, enc->pix_fmt, ost->padtop, ost->padleft) < 0) {\n<145> fprintf(stderr, "error padding picture\n");\n<169> if(  (ost->resample_height != (ist->st->codec->height - (ost->topBand  + ost->bottomBand)))\n<171> || (ost->resample_width  != (ist->st->codec->width  - (ost->leftBand + ost->rightBand)))\n<177> fprintf(stderr,"Input Stream #%d.%d frame size changed to %dx%d, %s\n", ist->file_index, ist->index, ist->st->codec->width, ist->st->codec->height,avcodec_get_pix_fmt_name(ist->st->codec->pix_fmt));\n<181> topBand    = ((int64_t)ist->st->codec->height * ost->original_topBand    / ost->original_height) & ~1;\n<183> bottomBand = ((int64_t)ist->st->codec->height * ost->original_bottomBand / ost->original_height) & ~1;\n<185> leftBand   = ((int64_t)ist->st->codec->width  * ost->original_leftBand   / ost->original_width)  & ~1;\n<187> rightBand  = ((int64_t)ist->st->codec->width  * ost->original_rightBand  / ost->original_width)  & ~1;\n<213> ost->resample_height = ist->st->codec->height - (ost->topBand  + ost->bottomBand);\n<215> ost->resample_width  = ist->st->codec->width  - (ost->leftBand + ost->rightBand);\n<243> if (ost->img_resample_ctx == NULL) {\n<245> fprintf(stderr, "Cannot get resampling context\n");\n<369> if (ret < 0) {\n<371> fprintf(stderr, "Video encoding failed\n");\n<413> if (ost->logfile && enc->stats_out) {\n<415> fprintf(ost->logfile, "%s", enc->stats_out);
<1> BlockDriverAIOCB *bdrv_aio_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors,\n<19> if (bdrv_rd_badreq_sectors(bs, sector_num, nb_sectors))\n<27> if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n<29> memcpy(buf, bs->boot_sector_data, 512);\n<35> buf += 512;\n<41> ret = drv->bdrv_aio_read(bs, sector_num, buf, nb_sectors, cb, opaque);
<1> int tap_open(char *ifname, int ifname_size, int *vnet_hdr,\n<17> if (fd < 0) {\n<25> memset(&ifr, 0, sizeof(ifr));\n<119> ret = ioctl(fd, TUNSETIFF, (void *) &ifr);\n<125> error_report("could not configure %s (%s): %m", PATH_NET_TUN, ifr.ifr_name);\n<139> pstrcpy(ifname, ifname_size, ifr.ifr_name);
<1> static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n<3> const char *filt_name, const char *args, AVClass *log_ctx)\n<21> filt = avfilter_get_by_name(filt_name);\n<51> if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {\n<61> if (!strcmp(filt_name, "scale") && !strstr(args, "flags")) {\n<63> snprintf(tmp_args, sizeof(tmp_args), "%s:%s",\n<65> args, ctx->scale_sws_opts);\n<67> args = tmp_args;\n<73> if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {
<1> static struct cgroup_meta_data * lxc_cgroup_load_meta2 ( const char * * subsystem_whitelist ) {\n<9> meta_data = calloc ( 1 , sizeof ( struct cgroup_meta_data ) ) ;\n<10> if ( ! meta_data ) return NULL ;
<1> static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n<9> assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n<15> memcpy(&scon->iov[scon->iov_bs], buf, size);\n<17> scon->iov_data_len += size;\n<19> scon->iov_sclp_rest += size;\n<21> scon->iov_bs += size;
<1> static int rtl8139_cplus_transmit_one(RTL8139State *s)\n<425> int hlen = 0;\n<433> uint8_t *eth_payload_data = NULL;\n<451> eth_payload_data = saved_buffer + ETH_HLEN;\n<477> ip_data_len = be16_to_cpu(ip->ip_len) - hlen;\n<497> if (hlen<sizeof(ip_header) || hlen>eth_payload_len) {/* min header length */\n<513> DPRINTF("+++ C+ mode IP header len=%d checksum=%04x\n",\n<523> if ((txdw0 & CP_TX_LGSEN) && ip_protocol == IP_PROTO_TCP)\n<547> uint8_t saved_ip_header[60];\n<553> memcpy(saved_ip_header, eth_payload_data, hlen);\n<559> uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;\n<567> tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);\n<571> int tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);\n<579> int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;\n<583> DPRINTF("+++ C+ mode TSO IP data len %d TCP hlen %d TCP "\n<601> for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)\n<605> uint16_t chunk_size = tcp_chunk_size;\n<617> chunk_size = tcp_data_len - tcp_send_offset;\n<625> be32_to_cpu(p_tcp_hdr->th_seq));\n<633> memcpy(data_to_checksum, saved_ip_header + 12, 8);\n<645> if (tcp_send_offset)\n<649> memcpy((uint8_t*)p_tcp_hdr + tcp_hlen, (uint8_t*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);\n<661> TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN);\n<669> ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;\n<675> p_tcpip_hdr->ip_payload = cpu_to_be16(tcp_hlen + chunk_size);\n<683> int tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + 12);\n<691> p_tcp_hdr->th_sum = tcp_checksum;\n<697> memcpy(eth_payload_data, saved_ip_header, hlen);\n<703> ip->ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);\n<715> ip->ip_sum = ip_checksum(eth_payload_data, hlen);\n<723> int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;\n<737> p_tcp_hdr->th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr->th_seq));\n<751> else if (txdw0 & (CP_TX_TCPCS|CP_TX_UDPCS))\n<761> uint8_t saved_ip_header[60];\n<763> memcpy(saved_ip_header, eth_payload_data, hlen);\n<767> uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;\n<777> memcpy(data_to_checksum, saved_ip_header + 12, 8);\n<791> ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;\n<801> tcp_header* p_tcp_hdr = (tcp_header *) (data_to_checksum+12);\n<809> int tcp_checksum = ip_checksum(data_to_checksum, ip_data_len + 12);\n<831> ip_pseudo_header *p_udpip_hdr = (ip_pseudo_header *)data_to_checksum;\n<841> udp_header *p_udp_hdr = (udp_header *) (data_to_checksum+12);\n<849> int udp_checksum = ip_checksum(data_to_checksum, ip_data_len + 12);\n<865> memcpy(eth_payload_data, saved_ip_header, hlen);
<1> static int isoent_alloc_path_table ( struct archive_write * a , struct vdd * vdd , int max_depth ) {\n<4> vdd -> pathtbl = malloc ( sizeof ( * vdd -> pathtbl ) * vdd -> max_depth ) ;\n<5> if ( vdd -> pathtbl == NULL ) {
<1> static void test_bug23383 ( ) {\n<17> rc = mysql_query ( mysql , insert_query ) ;\n<21> rc = mysql_query ( mysql , update_query ) ;\n<29> rc = mysql_stmt_prepare ( stmt , insert_query , strlen ( insert_query ) ) ;\n<39> rc = mysql_stmt_prepare ( stmt , update_query , strlen ( update_query ) ) ;
<1> void * jas_calloc ( size_t num_elements , size_t element_size ) {\n<4> if ( ! jas_safe_size_mul ( num_elements , element_size , & size ) ) {\n<7> if ( ! ( ptr = jas_malloc ( size ) ) ) {\n<10> memset ( ptr , 0 , size ) ;\n<11> return ptr ;
<1> int WriteCaffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) {\n<7> int num_channels = WavpackGetNumChannels ( wpc ) ;\n<14> unsigned char * channel_identities = malloc ( num_channels + 1 ) ;\n<16> if ( float_norm_exp && float_norm_exp != 127 ) {\n<18> free ( channel_identities ) ;\n<21> WavpackGetChannelIdentities ( wpc , channel_identities ) ;\n<24> ++ i ) if ( channel_identities [ i ] != 0xff ) num_identified_chans ++ ;\n<25> strncpy ( caf_file_header . mFileType , "caff" , sizeof ( caf_file_header . mFileType ) ) ;\n<28> WavpackNativeToBigEndian ( & caf_file_header , CAFFileHeaderFormat ) ;\n<29> if ( ! DoWriteFile ( outfile , & caf_file_header , sizeof ( caf_file_header ) , & bcount ) || bcount != sizeof ( caf_file_header ) ) return FALSE ;\n<30> strncpy ( caf_desc_chunk_header . mChunkType , "desc" , sizeof ( caf_desc_chunk_header . mChunkType ) ) ;\n<32> WavpackNativeToBigEndian ( & caf_desc_chunk_header , CAFChunkHeaderFormat ) ;\n<33> if ( ! DoWriteFile ( outfile , & caf_desc_chunk_header , sizeof ( caf_desc_chunk_header ) , & bcount ) || bcount != sizeof ( caf_desc_chunk_header ) ) return FALSE ;\n<35> strncpy ( caf_audio_format . mFormatID , "lpcm" , sizeof ( caf_audio_format . mFormatID ) ) ;\n<42> WavpackNativeToBigEndian ( & caf_audio_format , CAFAudioFormatFormat ) ;\n<43> if ( ! DoWriteFile ( outfile , & caf_audio_format , sizeof ( caf_audio_format ) , & bcount ) || bcount != sizeof ( caf_audio_format ) ) return FALSE ;\n<44> if ( channel_layout_tag || ( num_channels > 2 ? num_identified_chans : channel_mask != 5 - num_channels ) ) {\n<49> if ( ( channel_layout_tag & 0xff0000 ) || ( bits == num_channels && ! ( qmode & QMODE_REORDERED_CHANS ) ) ) {\n<50> strncpy ( caf_chan_chunk_header . mChunkType , "chan" , sizeof ( caf_chan_chunk_header . mChunkType ) ) ;\n<52> WavpackNativeToBigEndian ( & caf_chan_chunk_header , CAFChunkHeaderFormat ) ;\n<53> if ( ! DoWriteFile ( outfile , & caf_chan_chunk_header , sizeof ( caf_chan_chunk_header ) , & bcount ) || bcount != sizeof ( caf_chan_chunk_header ) ) return FALSE ;\n<66> if ( ! DoWriteFile ( outfile , & caf_channel_layout , sizeof ( caf_channel_layout ) , & bcount ) || bcount != sizeof ( caf_channel_layout ) ) return FALSE ;\n<70> unsigned char * new_channel_order = NULL ;\n<74> if ( ( int ) ( channel_layout_tag & 0xff ) <= num_channels ) {\n<75> new_channel_order = malloc ( num_channels ) ;\n<77> i < num_channels ;\n<78> ++ i ) new_channel_order [ i ] = i ;\n<79> WavpackGetChannelLayout ( wpc , new_channel_order ) ;\n<82> strncpy ( caf_chan_chunk_header . mChunkType , "chan" , sizeof ( caf_chan_chunk_header . mChunkType ) ) ;\n<84> WavpackNativeToBigEndian ( & caf_chan_chunk_header , CAFChunkHeaderFormat ) ;\n<85> if ( ! DoWriteFile ( outfile , & caf_chan_chunk_header , sizeof ( caf_chan_chunk_header ) , & bcount ) || bcount != sizeof ( caf_chan_chunk_header ) ) return FALSE ;\n<92> i < num_channels ;\n<102> if ( new_channel_order ) free ( new_channel_order ) ;\n<105> strncpy ( caf_data_chunk_header . mChunkType , "data" , sizeof ( caf_data_chunk_header . mChunkType ) ) ;\n<108> WavpackNativeToBigEndian ( & caf_data_chunk_header , CAFChunkHeaderFormat ) ;\n<109> if ( ! DoWriteFile ( outfile , & caf_data_chunk_header , sizeof ( caf_data_chunk_header ) , & bcount ) || bcount != sizeof ( caf_data_chunk_header ) ) return FALSE ;\n<112> if ( ! DoWriteFile ( outfile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || bcount != sizeof ( mEditCount ) ) return FALSE ;\n<113> free ( channel_identities ) ;
<1> static void vtd_realize(DeviceState *dev, Error **errp)\n<21> if (!vtd_decide_config(s, errp)) {\n<31> memset(s->vtd_as_by_bus_num, 0, sizeof(s->vtd_as_by_bus_num));\n<33> memory_region_init_io(&s->csrmem, OBJECT(s), &vtd_mem_ops, s,\n<37> sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->csrmem);\n<49> vtd_init(s);\n<51> sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, Q35_HOST_BRIDGE_IOMMU_ADDR);\n<57> pcms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
<1> static void test_bug4030 ( ) {\n<10> stmt = mysql_stmt_init ( mysql ) ;\n<11> stmt_text = "SELECT '23:59:59.123456', '2003-12-31', " "'2003-12-31 23:59:59.123456'" ;\n<12> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<13> check_execute ( stmt , rc ) ;\n<16> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<17> memset ( & time_canonical , 0 , sizeof ( time_canonical ) ) ;\n<18> memset ( & time_out , 0 , sizeof ( time_out ) ) ;\n<19> memset ( & date_canonical , 0 , sizeof ( date_canonical ) ) ;\n<20> memset ( & date_out , 0 , sizeof ( date_out ) ) ;\n<21> memset ( & datetime_canonical , 0 , sizeof ( datetime_canonical ) ) ;\n<22> memset ( & datetime_out , 0 , sizeof ( datetime_out ) ) ;\n<24> my_bind [ 0 ] . buffer = ( void * ) & time_out ;\n<26> my_bind [ 1 ] . buffer = ( void * ) & date_out ;\n<28> my_bind [ 2 ] . buffer = ( void * ) & datetime_out ;\n<29> time_canonical . hour = 23 ;\n<30> time_canonical . minute = 59 ;\n<31> time_canonical . second = 59 ;\n<32> time_canonical . second_part = 123456 ;\n<33> time_canonical . time_type = MYSQL_TIMESTAMP_TIME ;\n<34> date_canonical . year = 2003 ;\n<35> date_canonical . month = 12 ;\n<36> date_canonical . day = 31 ;\n<37> date_canonical . time_type = MYSQL_TIMESTAMP_DATE ;\n<38> datetime_canonical = time_canonical ;\n<39> datetime_canonical . year = 2003 ;\n<40> datetime_canonical . month = 12 ;\n<41> datetime_canonical . day = 31 ;\n<42> datetime_canonical . time_type = MYSQL_TIMESTAMP_DATETIME ;\n<43> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<46> if ( ! opt_silent ) {\n<47> printf ( "%d:%d:%d.%lu\n" , time_out . hour , time_out . minute , time_out . second , time_out . second_part ) ;\n<48> printf ( "%d-%d-%d\n" , date_out . year , date_out . month , date_out . day ) ;\n<49> printf ( "%d-%d-%d %d:%d:%d.%lu\n" , datetime_out . year , datetime_out . month , datetime_out . day , datetime_out . hour , datetime_out . minute , datetime_out . second , datetime_out . second_part ) ;\n<51> DIE_UNLESS ( memcmp ( & time_canonical , & time_out , sizeof ( time_out ) ) == 0 ) ;\n<52> DIE_UNLESS ( memcmp ( & date_canonical , & date_out , sizeof ( date_out ) ) == 0 ) ;\n<53> DIE_UNLESS ( memcmp ( & datetime_canonical , & datetime_out , sizeof ( datetime_out ) ) == 0 ) ;
<1> static int url_alloc_for_protocol(URLContext **puc, struct URLProtocol *up,\n<3> const char *filename, int flags,\n<23> if ((flags & AVIO_FLAG_READ) && !up->url_read) {\n<33> if ((flags & AVIO_FLAG_WRITE) && !up->url_write) {\n<43> uc = av_mallocz(sizeof(URLContext) + strlen(filename) + 1);\n<45> if (!uc) {\n<57> strcpy(uc->filename, filename);\n<79> if (up->priv_data_class) {\n<81> int proto_len= strlen(up->name);\n<83> char *start = strchr(uc->filename, ',');\n<89> if(!strncmp(up->name, uc->filename, proto_len) && uc->filename + proto_len == start){\n<93> char *p= start;\n<95> char sep= *++p;\n<99> p++;\n<101> while(ret >= 0 && (key= strchr(p, sep)) && p<key && (val = strchr(key+1, sep))){\n<103> *val= *key= 0;\n<105> ret= av_opt_set(uc->priv_data, p, key+1, 0);\n<107> if (ret == AVERROR_OPTION_NOT_FOUND)\n<111> *val= *key= sep;\n<113> p= val+1;\n<117> if(ret<0 || p!=key){\n<119> av_log(uc, AV_LOG_ERROR, "Error parsing options string %s\n", start);\n<131> memmove(start, key+1, strlen(key));
<1> void ff_subblock_synthesis(RA144Context *ractx, const int16_t *lpc_coefs,\n<17> cba_idx += BLOCKSIZE/2 - 1;\n<19> ff_copy_and_dup(ractx->buffer_a, ractx->adapt_cb, cba_idx);\n<33> memmove(ractx->adapt_cb, ractx->adapt_cb + BLOCKSIZE,\n<35> (BUFFERSIZE - BLOCKSIZE) * sizeof(*ractx->adapt_cb));\n<39> block = ractx->adapt_cb + BUFFERSIZE - BLOCKSIZE;\n<49> memcpy(ractx->curr_sblock, ractx->curr_sblock + BLOCKSIZE,\n<51> LPC_ORDER*sizeof(*ractx->curr_sblock));\n<55> if (ff_celp_lp_synthesis_filter(ractx->curr_sblock + LPC_ORDER, lpc_coefs,\n<59> memset(ractx->curr_sblock, 0, (LPC_ORDER+BLOCKSIZE)*sizeof(*ractx->curr_sblock));
<1> int i2c_ASN1_BIT_STRING ( ASN1_BIT_STRING * a , unsigned char * * pp ) {\n<6> if ( len > 0 ) {\n<16> j = a -> data [ len - 1 ] ;\n<30> if ( pp == NULL ) return ( ret ) ;\n<32> * ( p ++ ) = ( unsigned char ) bits ;\n<33> d = a -> data ;\n<34> memcpy ( p , d , len ) ;\n<35> p += len ;\n<36> if ( len > 0 ) p [ - 1 ] &= ( 0xff << bits ) ;
<1> struct evhttp * evhttp_start ( const char * address , u_short port ) {\n<3> if ( evhttp_bind_socket ( http , address , port ) == - 1 ) {\n<4> free ( http ) ;
<1> static uint8_t checkBaseExtBytes ( UCMStates * baseStates , UCMTable * base , UCMTable * ext , UBool moveToExt , UBool intersectBase ) {\n<50> if ( moveToExt ) {\n<55> fprintf ( stderr , "ucm error: the base table contains a mapping whose input sequence\n" " is a prefix of the input sequence of an extension mapping\n" ) ;\n<56> ucm_printMapping ( base , mb , stderr ) ;\n<57> ucm_printMapping ( ext , me , stderr ) ;\n<68> else if ( intersectBase ) {\n<73> fprintf ( stderr , "ucm error: the base table contains a mapping whose input sequence\n" " is the same as the input sequence of an extension mapping\n" " but it maps differently\n" ) ;\n<74> ucm_printMapping ( base , mb , stderr ) ;\n<75> ucm_printMapping ( ext , me , stderr ) ;
<1> int net_client_init(QemuOpts *opts, int is_netdev, Error **errp)\n<15> if (!type) {\n<25> if (is_netdev) {\n<27> if (strcmp(type, "tap") != 0 &&\n<47> strcmp(type, "socket") != 0) {\n<49> error_set(errp, QERR_INVALID_PARAMETER_VALUE, "type",\n<53> return -1;\n<59> if (qemu_opt_get(opts, "vlan")) {\n<99> if (net_client_types[i].type != NULL &&\n<101> !strcmp(net_client_types[i].type, type)) {\n<113> if (error_is_set(&local_err)) {\n<129> (strcmp(type, "nic") == 0 && qemu_opt_get(opts, "netdev")))) {\n<147> error_set(errp, QERR_DEVICE_INIT_FAILED, type);
<1> static int kvmppc_read_host_property(const char *node_path, const char *prop,\n<23> if (path == NULL) {\n<37> f = fopen(path, "rb");\n<67> free(path);
<8> if ( ! p_pic ) return NULL ;\n<18> p_free = malloc ( sizeof ( * p_free ) ) ;\n<21> schro_frame_set_free_callback ( p_schroframe , SchroFrameFree , p_free ) ;
<1> REGRESSION_TEST ( SDK_API_TSPluginDirGet ) ( RegressionTest * test , int , int * pstatus ) {\n<6> if ( ! plugin_dir ) {\n<11> if ( ! install_dir ) {\n<16> if ( ! runtime_dir ) {\n<21> if ( strstr ( plugin_dir , TS_BUILD_LIBEXECDIR ) == nullptr ) {\n<22> SDK_RPRINT ( test , "TSPluginDirGet" , "TestCase2" , TC_FAIL , "plugin dir(%s) is incorrect, expected (%s) in path." , plugin_dir , TS_BUILD_LIBEXECDIR ) ;\n<23> * pstatus = REGRESSION_TEST_FAILED ;\n<24> return ;\n<26> if ( strstr ( plugin_dir , install_dir ) == nullptr ) {\n<27> SDK_RPRINT ( test , "TSInstallDirGet" , "TestCase2" , TC_FAIL , "install dir is incorrect" ) ;\n<28> * pstatus = REGRESSION_TEST_FAILED ;\n<29> return ;\n<31> if ( strstr ( runtime_dir , TS_BUILD_RUNTIMEDIR ) == nullptr ) {\n<32> SDK_RPRINT ( test , "TSRuntimeDirGet" , "TestCase2" , TC_FAIL , "runtime dir is incorrect" ) ;\n<33> * pstatus = REGRESSION_TEST_FAILED ;\n<34> return ;\n<36> SDK_RPRINT ( test , "TSPluginDirGet" , "TestCase1" , TC_PASS , "ok" ) ;\n<37> SDK_RPRINT ( test , "TSInstallDirGet" , "TestCase1" , TC_PASS , "ok" ) ;\n<38> SDK_RPRINT ( test , "TSRuntimeDirGet" , "TestCase1" , TC_PASS , "ok" ) ;\n<39> * pstatus = REGRESSION_TEST_PASSED ;\n<40> return ;
<1> int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n<21> l = f->buf_size - f->buf_index;\n<23> if (l == 0) {\n<25> qemu_fill_buffer(f);\n<27> l = f->buf_size - f->buf_index;\n<29> if (l == 0) {\n<37> if (l > size) {\n<39> l = size;\n<43> memcpy(buf, f->buf + f->buf_index, l);\n<45> f->buf_index += l;\n<47> buf += l;\n<49> size -= l;
<1> static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) {\n<7> char prefix = descriptor [ 0 ] ;\n<8> log_frame_info ( cm , descriptor , file ) ;\n<11> mi_row < rows ;\n<13> fprintf ( file , "%c " , prefix ) ;\n<15> mi_col < cols ;\n<17> fprintf ( file , "%2d " , * ( ( int * ) ( ( char * ) ( & mi [ mi_index ] -> mbmi ) + member_offset ) ) ) ;\n<20> fprintf ( file , "\n" ) ;\n<23> fprintf ( file , "\n" ) ;
<1> static const Writer * writer_get_by_name ( const char * name ) {\n<4> registered_writers [ i ] ;\n<5> i ++ ) if ( ! strcmp ( registered_writers [ i ] -> name , name ) ) return registered_writers [ i ] ;
<1> relpRetVal relpTcpSetGnuTLSPriString ( relpTcp_t * pThis , char * pristr ) {\n<3> RELPOBJ_assert ( pThis , Tcp ) ;\n<4> free ( pThis -> pristring ) ;\n<5> if ( pristr == NULL ) {\n<9> if ( ( pThis -> pristring = strdup ( pristr ) ) == NULL ) ABORT_FINALIZE ( RELP_RET_OUT_OF_MEMORY ) ;
<1> int qemuMonitorTextSetCPU ( qemuMonitorPtr mon , int cpu , int online ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<15> if ( strstr ( reply , "unknown command:" ) ) {\n<16> ret = 0 ;\n<19> ret = 1 ;\n<21> VIR_FREE ( reply ) ;
<1> static int dump_ppc_insns (CPUPPCState *env)\n<11> printf("Instructions set:\n");\n<15> for (opc1 = 0x00; opc1 < 0x40; opc1++) {\n<21> if (is_indirect_opcode(handler)) {\n<25> for (opc2 = 0; opc2 < 0x20; opc2++) {\n<31> table = ind_table(handler);\n<35> if (is_indirect_opcode(handler)) {\n<37> table = ind_table(handler);\n<41> for (opc3 = 0; opc3 < 0x20; opc3++) {\n<43> handler = table[opc3];\n<45> if (handler->handler != &gen_invalid) {\n<47> printf("INSN: %02x %02x %02x (%02d %04d) : %s\n",\n<49> opc1, opc2, opc3, opc1, (opc3 << 5) | opc2,\n<59> if (handler->handler != &gen_invalid) {\n<61> printf("INSN: %02x %02x -- (%02d %04d) : %s\n",\n<73> if (handler->handler != &gen_invalid) {
<1> static void test_0 ( void ) {\n<12> err = ksba_dn_str2der ( good_strings [ i ] , & buf , & len ) ;\n<13> if ( err ) {\n<14> fprintf ( stderr , "%s:%d: ksba_dn_str2der failed for `%s': %s\n" , __FILE__ , __LINE__ , good_strings [ i ] , gpg_strerror ( err ) ) ;\n<17> err = ksba_dn_teststr ( good_strings [ i ] , 0 , & off , & len ) ;\n<18> if ( err ) {\n<19> fprintf ( stderr , "%s:%d: ksba_dn_teststr failed for `%s': %s\n" , __FILE__ , __LINE__ , good_strings [ i ] , gpg_strerror ( err ) ) ;
<1> static gpgme_error_t uiserver_new ( void * * engine , const char * file_name , const char * home_dir ) {\n<4> char * dft_display = NULL ;\n<6> char * dft_ttytype = NULL ;\n<8> uiserver = calloc ( 1 , sizeof * uiserver ) ;\n<9> if ( ! uiserver ) return gpg_error_from_syserror ( ) ;\n<47> err = _gpgme_getenv ( "DISPLAY" , & dft_display ) ;\n<49> if ( dft_display ) {\n<50> if ( asprintf ( & optstr , "OPTION display=%s" , dft_display ) < 0 ) {\n<52> free ( dft_display ) ;\n<55> free ( dft_display ) ;\n<56> err = assuan_transact ( uiserver -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n<57> free ( optstr ) ;\n<60> if ( isatty ( 1 ) ) {\n<62> rc = ttyname_r ( 1 , dft_ttyname , sizeof ( dft_ttyname ) ) ;\n<68> if ( asprintf ( & optstr , "OPTION ttyname=%s" , dft_ttyname ) < 0 ) {\n<72> err = assuan_transact ( uiserver -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n<73> free ( optstr ) ;\n<75> err = _gpgme_getenv ( "TERM" , & dft_ttytype ) ;\n<77> if ( dft_ttytype ) {\n<78> if ( asprintf ( & optstr , "OPTION ttytype=%s" , dft_ttytype ) < 0 ) {\n<80> free ( dft_ttytype ) ;\n<83> free ( dft_ttytype ) ;\n<84> err = assuan_transact ( uiserver -> assuan_ctx , optstr , NULL , NULL , NULL , NULL , NULL , NULL ) ;\n<85> free ( optstr ) ;
<1> static void pxa2xx_i2s_write ( void * opaque , hwaddr addr , uint64_t value , unsigned size ) {\n<13> if ( value & ( 1 << 4 ) ) printf ( "%s: Attempt to use special function\n" , __FUNCTION__ ) ;\n<18> if ( value & ( 1 << 5 ) ) printf ( "%s: Attempt to use loopback function\n" , __FUNCTION__ ) ;
<1> static int dnslabel_table_get_pos ( const struct dnslabel_table * table , const char * label ) {\n<4> i < table -> n_labels ;\n<5> ++ i ) {\n<6> if ( ! strcmp ( label , table -> labels [ i ] . v ) ) return table -> labels [ i ] . pos ;
<1> static int eightsvx_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<24> if ( ! ( esc -> data [ 0 ] = av_malloc ( chan_size ) ) ) return AVERROR ( ENOMEM ) ;\n<25> if ( avctx -> channels == 2 ) {\n<26> if ( ! ( esc -> data [ 1 ] = av_malloc ( chan_size ) ) ) {\n<31> memcpy ( esc -> data [ 0 ] , & avpkt -> data [ hdr_size ] , chan_size ) ;\n<32> if ( avctx -> channels == 2 ) memcpy ( esc -> data [ 1 ] , & avpkt -> data [ 2 * hdr_size + chan_size ] , chan_size ) ;\n<34> if ( ! esc -> data [ 0 ] ) {
<1> kadm5_ret_t kadm5_get_principal ( void * server_handle , krb5_principal principal , kadm5_principal_ent_t entry , long in_mask ) {\n<11> memset ( entry , 0 , sizeof ( * entry ) ) ;\n<12> if ( principal == NULL ) return EINVAL ;\n<14> if ( ( mask & KADM5_POLICY ) && adb . policy && ( adb . aux_attributes & KADM5_POLICY ) ) {\n<15> if ( ( entry -> policy = strdup ( adb . policy ) ) == NULL ) {\n<16> ret = ENOMEM ;\n<20> if ( mask & KADM5_AUX_ATTRIBUTES ) entry -> aux_attributes = adb . aux_attributes ;\n<21> if ( ( mask & KADM5_PRINCIPAL ) && ( ret = krb5_copy_principal ( handle -> context , kdb -> princ , & entry -> principal ) ) ) {\n<25> if ( ( mask & KADM5_LAST_PWD_CHANGE ) && ( ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & ( entry -> last_pwd_change ) ) ) ) {\n<31> ret = krb5_dbe_lookup_mod_princ_data ( handle -> context , kdb , & ( entry -> mod_date ) , & ( entry -> mod_name ) ) ;\n<37> krb5_free_principal ( handle -> context , entry -> mod_name ) ;\n<38> entry -> mod_name = NULL ;\n<44> i ++ ) if ( ( krb5_kvno ) kdb -> key_data [ i ] . key_data_kvno > entry -> kvno ) entry -> kvno = kdb -> key_data [ i ] . key_data_kvno ;\n<46> ret = krb5_dbe_get_mkvno ( handle -> context , kdb , & entry -> mkvno ) ;\n<55> entry -> tl_data = NULL ;\n<59> if ( ( tl2 = dup_tl_data ( tl ) ) == NULL ) {\n<63> tl2 -> tl_data_next = entry -> tl_data ;\n<65> entry -> n_tl_data ++ ;\n<73> entry -> key_data = k5calloc ( entry -> n_key_data , sizeof ( krb5_key_data ) , & ret ) ;\n<74> if ( entry -> key_data == NULL ) goto done ;\n<76> else entry -> key_data = NULL ;\n<78> i < entry -> n_key_data ;\n<83> done : if ( ret && entry -> principal ) {\n<84> krb5_free_principal ( handle -> context , entry -> principal ) ;\n<85> entry -> principal = NULL ;\n<87> kdb_free_entry ( handle , kdb , & adb ) ;
<1> void ff_h264_direct_ref_list_init ( H264Context * const h ) {\n<15> if ( h -> picture_structure == PICT_FRAME ) {\n<16> memcpy ( cur -> ref_count [ 1 ] , cur -> ref_count [ 0 ] , sizeof ( cur -> ref_count [ 0 ] ) ) ;\n<17> memcpy ( cur -> ref_poc [ 1 ] , cur -> ref_poc [ 0 ] , sizeof ( cur -> ref_poc [ 0 ] ) ) ;
<1> static int vp3_decode_frame(AVCodecContext *avctx,\n<9> Vp3DecodeContext *s = avctx->priv_data;\n<37> init_dequantizer(s);\n<53> avctx->release_buffer(avctx, &s->golden_frame);\n<57> avctx->release_buffer(avctx, &s->last_frame);\n<61> s->golden_frame.reference = 0;\n<63> if(avctx->get_buffer(avctx, &s->golden_frame) < 0) {\n<65> printf("vp3: get_buffer() failed\n");\n<75> memcpy(&s->current_frame, &s->golden_frame, sizeof(AVFrame));\n<93> s->current_frame.reference = 0;\n<95> if(avctx->get_buffer(avctx, &s->current_frame) < 0) {\n<97> printf("vp3: get_buffer() failed\n");\n<163> printf("  vp3: could not decode frame\n");\n<187> render_fragments(s, s->v_fragment_start, s->width / 2, s->height / 2, 2);\n<201> *(AVFrame*)data= s->current_frame;\n<213> avctx->release_buffer(avctx, &s->last_frame);\n<219> memcpy(&s->last_frame, &s->current_frame, sizeof(AVFrame));
<1> static timelib_sll timelib_get_nr ( char * * ptr , int max_length ) {\n<5> while ( ( * * ptr < '0' ) || ( * * ptr > '9' ) ) {\n<17> str = calloc ( 1 , end - begin + 1 ) ;\n<18> memcpy ( str , begin , end - begin ) ;\n<19> tmp_nr = strtoll ( str , NULL , 10 ) ;\n<20> free ( str ) ;
<1> static DeviceState * qdev_find_recursive ( BusState * bus , const char * id ) {\n<4> QLIST_FOREACH ( dev , & bus -> children , sibling ) {\n<5> if ( dev -> id && strcmp ( dev -> id , id ) == 0 ) return dev ;\n<6> QLIST_FOREACH ( child , & dev -> child_bus , sibling ) {\n<7> ret = qdev_find_recursive ( child , id ) ;\n<8> if ( ret ) {
<1> static int checkcmap ( int n , uint16 * r , uint16 * g , uint16 * b ) {\n<2> while ( n -- > 0 ) if ( * r ++ >= 256 || * g ++ >= 256 || * b ++ >= 256 ) return ( 16 ) ;\n<3> fprintf ( stderr , "Warning, assuming 8-bit colormap.\n" ) ;
<1> static int parse_cube(AVFilterContext *ctx, FILE *f)\n<15> while (fgets(line, sizeof(line), f)) {\n<17> if (!strncmp(line, "LUT_3D_SIZE ", 12)) {\n<39> for (i = 0; i < size; i++) {\n<41> struct rgbvec *vec = &lut3d->lut[k][j][i];\n<49> if (!strncmp(line, "DOMAIN_", 7)) {\n<57> if (!vals)\n<61> sscanf(line + 11, "%f %f %f", vals, vals + 1, vals + 2);\n<71> } while (skip_line(line));\n<73> if (sscanf(line, "%f %f %f", &vec->r, &vec->g, &vec->b) != 3)\n<75> return AVERROR_INVALIDDATA;\n<77> vec->r *= max[0] - min[0];\n<79> vec->g *= max[1] - min[1];\n<81> vec->b *= max[2] - min[2];\n<95> return 0;
<1> PCIDevice *pci_ne2000_init(PCIBus *bus, NICInfo *nd, int devfn)\n<39> s = &d->ne2000;\n<45> memcpy(s->macaddr, nd->macaddr, 6);\n<47> ne2000_reset(s);\n<49> s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<55> qemu_format_nic_info_str(s->vc, s->macaddr);
<1> static int vorbis_parse_audio_packet ( vorbis_context * vc , float * * floor_ptr ) {\n<10> float * ch_res_ptr = vc -> channel_residues ;\n<16> if ( get_bits1 ( gb ) ) {\n<35> memset ( ch_res_ptr , 0 , sizeof ( float ) * vc -> audio_channels * vlen ) ;\n<37> i < vc -> audio_channels ;\n<38> ++ i ) memset ( floor_ptr [ i ] , 0 , vlen * sizeof ( floor_ptr [ 0 ] [ 0 ] ) ) ;\n<50> ret = floor -> decode ( vc , & floor -> data , floor_ptr [ i ] ) ;\n<92> ret = vorbis_residue_decode ( vc , residue , ch , do_not_decode , ch_res_ptr , vlen , ch_left ) ;\n<95> ch_res_ptr += ch * vlen ;\n<117> j < vc -> audio_channels ;\n<122> float * saved = vc -> saved + j * bs1 / 4 ;\n<123> float * ret = floor_ptr [ j ] ;\n<127> vc -> fdsp . vector_fmul_window ( ret , saved , buf , win , blocksize / 4 ) ;\n<129> else if ( blockflag > previous_window ) {\n<130> vc -> fdsp . vector_fmul_window ( ret , saved , buf , win , bs0 / 4 ) ;\n<131> memcpy ( ret + bs0 / 2 , buf + bs0 / 4 , ( ( bs1 - bs0 ) / 4 ) * sizeof ( float ) ) ;\n<134> memcpy ( ret , saved , ( ( bs1 - bs0 ) / 4 ) * sizeof ( float ) ) ;\n<135> vc -> fdsp . vector_fmul_window ( ret + ( bs1 - bs0 ) / 4 , saved + ( bs1 - bs0 ) / 4 , buf , win , bs0 / 4 ) ;\n<137> memcpy ( saved , buf + blocksize / 4 , blocksize / 4 * sizeof ( float ) ) ;
<1> static int decode_coeffs ( WMAProDecodeCtx * s , int c ) {\n<60> AV_WN32A ( & ci -> coeffs [ cur_coeff ] , vals [ i ] ^ sign << 31 ) ;\n<64> ci -> coeffs [ cur_coeff ] = 0 ;\n<70> if ( cur_coeff < s -> subframe_len ) {\n<71> memset ( & ci -> coeffs [ cur_coeff ] , 0 , sizeof ( * ci -> coeffs ) * ( s -> subframe_len - cur_coeff ) ) ;
<1> static void init_sql_statement_names ( ) {\n<11> SHOW_VAR * var = & com_status_vars [ 0 ] ;\n<12> while ( var -> name != NULL ) {\n<14> if ( ( first_com <= ptr ) && ( ptr <= last_com ) ) {\n<18> sql_statement_names [ com_index ] . length = strlen ( var -> name ) ;\n<20> var ++ ;\n<22> DBUG_ASSERT ( strcmp ( sql_statement_names [ ( uint ) SQLCOM_SELECT ] . str , "select" ) == 0 ) ;\n<23> DBUG_ASSERT ( strcmp ( sql_statement_names [ ( uint ) SQLCOM_SIGNAL ] . str , "signal" ) == 0 ) ;
<1> int test_gf2m_mod_mul ( BIO * bp , BN_CTX * ctx ) {\n<48> if ( ! BN_is_zero ( f ) ) {\n<49> fprintf ( stderr , "GF(2^m) modular multiplication test failed!\n" ) ;
<1> ulong acl_get ( const char * host , const char * ip , const char * user , const char * db , my_bool db_is_pattern ) {\n<8> copy_length = ( size_t ) ( strlen ( ip ? ip : "" ) + strlen ( user ? user : "" ) + strlen ( db ? db : "" ) ) + 2 ;\n<9> if ( copy_length >= ACL_KEY_LENGTH ) DBUG_RETURN ( 0 ) ;\n<11> end = strmov ( ( tmp_db = strmov ( strmov ( key , ip ? ip : "" ) + 1 , user ) + 1 ) , db ) ;\n<16> key_length = ( size_t ) ( end - key ) ;\n<17> if ( ! db_is_pattern && ( entry = ( acl_entry * ) acl_cache -> search ( ( uchar * ) key , key_length ) ) ) {\n<24> i < acl_dbs . elements ;\n<25> i ++ ) {\n<27> if ( ! acl_db -> user || ! strcmp ( user , acl_db -> user ) ) {\n<28> if ( compare_hostname ( & acl_db -> host , host , ip ) ) {\n<50> exit : if ( ! db_is_pattern && ( entry = ( acl_entry * ) malloc ( sizeof ( acl_entry ) + key_length ) ) ) {\n<53> memcpy ( ( uchar * ) entry -> key , key , key_length ) ;\n<54> acl_cache -> add ( entry ) ;
<1> static int OpenDecoder ( vlc_object_t * p_this ) {\n<5> if ( p_dec -> fmt_in . i_codec != VLC_CODEC_DIRAC ) {\n<8> p_sys = malloc ( sizeof ( decoder_sys_t ) ) ;\n<9> if ( p_sys == NULL ) return VLC_ENOMEM ;\n<11> if ( ! ( p_schro = schro_decoder_new ( ) ) ) {\n<12> free ( p_sys ) ;
<1> static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)\n<41> if (TRB_TYPE(*trb_setup) != TR_SETUP) {\n<43> fprintf(stderr, "xhci: ep0 first TD not SETUP: %d\n",\n<45> TRB_TYPE(*trb_setup));\n<51> if (TRB_TYPE(*trb_status) != TR_STATUS) {\n<53> fprintf(stderr, "xhci: ep0 last TD not STATUS: %d\n",\n<55> TRB_TYPE(*trb_status));\n<61> if (!(trb_setup->control & TRB_TR_IDT)) {\n<63> fprintf(stderr, "xhci: Setup TRB doesn't have IDT set\n");\n<69> if ((trb_setup->status & 0x1ffff) != 8) {\n<71> fprintf(stderr, "xhci: Setup TRB has bad length (%d)\n",\n<73> (trb_setup->status & 0x1ffff));\n<117> port = &xhci->ports[xhci->slots[xfer->slotid-1].port-1];\n<121> if (!dev) {\n<123> fprintf(stderr, "xhci: slot %d port %d has no device\n", xfer->slotid,\n<125> xhci->slots[xfer->slotid-1].port);
<1> static int vvfat_open(BlockDriverState *bs, const char* dirname, int flags)\n<67> if (!strstart(dirname, "fat:", NULL))\n<73> if (strstr(dirname, ":floppy:")) {\n<75> floppy = 1;\n<77> s->fat_type = 12;\n<79> s->first_sectors_number = 1;\n<81> s->sectors_per_cluster=2;\n<83> bs->cyls = 80; bs->heads = 2; bs->secs = 36;\n<89> if (strstr(dirname, ":32:")) {\n<91> fprintf(stderr, "Big fat greek warning: FAT32 has not been tested. You are welcome to do so!\n");\n<93> s->fat_type = 32;\n<95> } else if (strstr(dirname, ":16:")) {\n<97> s->fat_type = 16;\n<99> } else if (strstr(dirname, ":12:")) {\n<101> s->fat_type = 12;\n<103> bs->secs = 18;\n<113> if (strstr(dirname, ":rw:")) {\n<115> if (enable_write_target(s))\n<125> i = strrchr(dirname, ':') - dirname;\n<127> assert(i >= 3);\n<129> if (dirname[i-2] == ':' && qemu_isalpha(dirname[i-1]))\n<141> bs->total_sectors=bs->cyls*bs->heads*bs->secs;\n<145> if(init_directories(s, dirname))
<1> void check_aligned_anonymous_unfixed_colliding_mmaps(void)\n<17> fprintf (stderr, "%s", __func__);\n<19> for (i = 0; i < 0x2fff; i++)\n<29> fail_unless (p1 != MAP_FAILED);\n<35> memcpy (dummybuf, p1, pagesize);\n<43> fail_unless (p2 != MAP_FAILED);\n<49> memcpy (dummybuf, p2, pagesize);\n<55> munmap (p1, pagesize);\n<57> nlen = pagesize * 8;\n<67> if (p3 < p2\n<75> memcpy (dummybuf, p3, pagesize);\n<83> fail_unless (p3 != MAP_FAILED);\n<89> munmap (p2, pagesize);\n<95> fprintf (stderr, " passed\n");
<1> strdup(str)\n<3> const char *str;\n<11> bptr = (char *)malloc(strlen(str)+1);\n<13> strcpy(bptr, str);
<1> static void fill_picture_parameters(AVCodecContext *avctx,\n<7> DXVA_PictureParameters *pp)\n<17> memset(pp, 0, sizeof(*pp));
<1> static void ntp_poll ( struct parse * pcmd , FILE * fp ) {\n<2> ( void ) fprintf ( fp , "poll not implemented yet\n" ) ;
<1> static const char * sexp_nth_data ( const gcry_sexp_t list , int number , size_t * datalen ) {\n<11> if ( * p == ST_DATA ) {\n<12> memcpy ( & n , ++ p , sizeof n ) ;\n<13> p += sizeof n + n ;\n<29> if ( * p == ST_DATA ) {\n<30> memcpy ( & n , ++ p , sizeof n ) ;\n<31> * datalen = n ;
<1> static struct subre * subre ( struct vars * v , int op , int flags , struct state * begin , struct state * end ) {\n<7> if ( ret != NULL ) v -> treefree = ret -> left ;\n<10> if ( ret == NULL ) {\n<17> assert ( strchr ( "=b|.*(" , op ) != NULL ) ;\n<18> ret -> op = op ;\n<23> ret -> left = NULL ;\n<24> ret -> right = NULL ;
<1> int server_run_command ( struct client * client , struct config * config , struct iovec * * argv ) {\n<2> char * command = NULL ;\n<3> char * subcommand = NULL ;\n<4> char * helpsubcommand = NULL ;\n<13> memset ( & process , 0 , sizeof ( process ) ) ;\n<21> argv [ i ] != NULL && i < 2 ;\n<22> i ++ ) {\n<23> if ( memchr ( argv [ i ] -> iov_base , '\0' , argv [ i ] -> iov_len ) ) {\n<24> notice ( "%s from user %s contains nul octet" , ( i == 0 ) ? "command" : "subcommand" , user ) ;\n<25> client -> error ( client , ERROR_BAD_COMMAND , "Invalid command token" ) ;\n<31> rule = find_config_line ( config , command , subcommand ) ;\n<32> if ( rule == NULL && strcmp ( command , "help" ) == 0 ) {\n<33> if ( argv [ 1 ] != NULL && argv [ 2 ] != NULL && argv [ 3 ] != NULL ) {\n<37> if ( subcommand == NULL ) {\n<44> rule = find_config_line ( config , subcommand , helpsubcommand ) ;\n<47> for ( i = 1 ;\n<48> argv [ i ] != NULL ;\n<49> i ++ ) {\n<50> if ( rule != NULL ) {\n<52> if ( argv [ i + 1 ] == NULL && rule -> stdin_arg == - 1 ) continue ;\n<54> if ( memchr ( argv [ i ] -> iov_base , '\0' , argv [ i ] -> iov_len ) ) {\n<55> notice ( "argument %lu from user %s contains nul octet" , ( unsigned long ) i , user ) ;\n<56> client -> error ( client , ERROR_BAD_COMMAND , "Invalid command token" ) ;\n<62> notice ( "unknown command %s%s%s from user %s" , command , ( subcommand == NULL ) ? "" : " " , ( subcommand == NULL ) ? "" : subcommand , user ) ;\n<67> notice ( "access denied: user %s, command %s%s%s" , user , command , ( subcommand == NULL ) ? "" : " " , ( subcommand == NULL ) ? "" : subcommand ) ;\n<72> if ( rule -> help == NULL ) {\n<73> notice ( "command %s from user %s has no defined help" , command , user ) ;\n<78> free ( subcommand ) ;\n<79> subcommand = xstrdup ( rule -> help ) ;\n<82> if ( help ) req_argv = create_argv_help ( rule -> program , subcommand , helpsubcommand ) ;\n<83> else req_argv = create_argv_command ( rule , & process , argv ) ;\n<84> process . command = command ;\n<87> ok = server_process_run ( & process ) ;\n<89> if ( WIFEXITED ( process . status ) ) process . status = ( signed int ) WEXITSTATUS ( process . status ) ;\n<91> client -> finish ( client , process . output , process . status ) ;\n<93> status = process . status ;\n<94> done : free ( command ) ;\n<95> free ( subcommand ) ;\n<96> free ( helpsubcommand ) ;\n<97> if ( req_argv != NULL ) {\n<99> req_argv [ i ] != NULL ;\n<100> i ++ ) free ( req_argv [ i ] ) ;\n<101> free ( req_argv ) ;\n<103> if ( process . input != NULL ) evbuffer_free ( process . input ) ;\n<104> if ( process . output != NULL ) evbuffer_free ( process . output ) ;
<1> enum nss_status _nss_dns_gethostbyname4_r ( const char * name , struct gaih_addrtuple * * pat , char * buffer , size_t buflen , int * errnop , int * herrnop , int32_t * ttlp ) {\n<2> if ( __res_maybe_init ( & _res , 0 ) == - 1 ) return NSS_STATUS_UNAVAIL ;\n<3> if ( strchr ( name , '.' ) == NULL ) {\n<4> char * tmp = alloca ( NS_MAXDNAME ) ;\n<5> const char * cp = res_hostalias ( & _res , name , tmp , NS_MAXDNAME ) ;\n<6> if ( cp != NULL ) name = cp ;\n<15> u_char * ans2p = NULL ;\n<21> int n = __libc_res_nsearch ( & _res , name , C_IN , T_UNSPEC , host_buffer . buf -> buf , 2048 , & host_buffer . ptr , & ans2p , & nans2p , & resplen2 , & ans2p_malloced ) ;\n<40> if ( ans2p_malloced ) free ( ans2p ) ;\n<41> if ( host_buffer . buf != orig_host_buffer ) free ( host_buffer . buf ) ;
<1> static int configure_input_video_filter(FilterGraph *fg, InputFilter *ifilter,\n<35> if (!par)\n<39> memset(par, 0, sizeof(*par));\n<119> ret = av_buffersrc_parameters_set(ifilter->filter, par);
<1> static bool restricted_shell ( const char * shellname ) {\n<4> while ( ( line = getusershell ( ) ) != NULL ) {\n<5> if ( ( '#' != * line ) && ( strcmp ( line , shellname ) == 0 ) ) {\n<6> endusershell ( ) ;\n<7> return false ;
<1> static void vhdx_parse_header(BlockDriverState *bs, BDRVVHDXState *s,\n<27> header1 = qemu_blockalign(bs, sizeof(VHDXHeader));\n<29> header2 = qemu_blockalign(bs, sizeof(VHDXHeader));\n<49> ret = bdrv_pread(bs->file, VHDX_HEADER1_OFFSET, buffer, VHDX_HEADER_SIZE);\n<51> if (ret < 0) {\n<59> memcpy(header1, buffer, sizeof(VHDXHeader));\n<61> vhdx_header_le_import(header1);\n<65> if (vhdx_checksum_is_valid(buffer, VHDX_HEADER_SIZE, 4) &&\n<67> !memcmp(&header1->signature, "head", 4)             &&\n<79> ret = bdrv_pread(bs->file, VHDX_HEADER2_OFFSET, buffer, VHDX_HEADER_SIZE);\n<81> if (ret < 0) {\n<89> memcpy(header2, buffer, sizeof(VHDXHeader));\n<91> vhdx_header_le_import(header2);\n<95> if (vhdx_checksum_is_valid(buffer, VHDX_HEADER_SIZE, 4) &&\n<97> !memcmp(&header2->signature, "head", 4)             &&
<1> static void encode_cblk(Jpeg2000EncoderContext *s, Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk, Jpeg2000Tile *tile,\n<13> memset(t1->flags, 0, t1->stride * (height + 2) * sizeof(*t1->flags));\n<65> case 0: encode_sigpass(t1, width, height, bandpos, &nmsedec, bpno);\n<69> case 1: encode_refpass(t1, width, height, &nmsedec, bpno);\n<73> case 2: encode_clnpass(t1, width, height, bandpos, &nmsedec, bpno);
<1> static int wv_get_value(WavpackFrameContext *ctx, GetBitContext *gb,\n<55> memset(ctx->ch[0].median, 0, sizeof(ctx->ch[0].median));\n<57> memset(ctx->ch[1].median, 0, sizeof(ctx->ch[1].median));
<1> static void dump_syscall(CPUState *env)\n<5> fprintf(logfile, "syscall r0=0x%08x r3=0x%08x r4=0x%08x "
<1> static int rebuild_refcount_structure(BlockDriverState *bs,\n<69> if (refblock_offset < 0) {\n<71> fprintf(stderr, "ERROR allocating refblock: %s\n",\n<73> strerror(-refblock_offset));\n<87> uint32_t old_reftable_size = reftable_size;\n<103> if (!new_on_disk_reftable) {\n<113> on_disk_reftable = new_on_disk_reftable;\n<117> memset(on_disk_reftable + old_reftable_size, 0,\n<119> (reftable_size - old_reftable_size) * sizeof(uint64_t));\n<133> on_disk_reftable[refblock_index] = refblock_offset;\n<157> if (reftable_offset < 0) {\n<159> fprintf(stderr, "ERROR allocating reftable: %s\n",\n<161> strerror(-reftable_offset));\n<179> if (ret < 0) {\n<181> fprintf(stderr, "ERROR writing refblock: %s\n", strerror(-ret));\n<203> if (ret < 0) {\n<205> fprintf(stderr, "ERROR writing refblock: %s\n", strerror(-ret));\n<247> if (reftable_offset < 0) {\n<249> fprintf(stderr, "ERROR allocating reftable: %s\n",\n<251> strerror(-reftable_offset));\n<285> if (ret < 0) {\n<287> fprintf(stderr, "ERROR writing reftable: %s\n", strerror(-ret));\n<301> if (ret < 0) {\n<303> fprintf(stderr, "ERROR writing reftable: %s\n", strerror(-ret));\n<327> if (ret < 0) {\n<329> fprintf(stderr, "ERROR setting reftable: %s\n", strerror(-ret));
<1> static gcry_err_code_t pkcs1_decode_for_encryption ( unsigned char * * r_result , size_t * r_resultlen , unsigned int nbits , gcry_mpi_t value ) {\n<8> err = gcry_mpi_print ( GCRYMPI_FMT_USG , frame , nframe , & n , value ) ;\n<19> if ( ! frame [ 0 ] ) n ++ ;\n<20> if ( frame [ n ++ ] != 0x02 ) {\n<25> n < nframe && frame [ n ] != 0x00 ;\n<27> if ( n + 1 >= nframe ) {\n<31> n ++ ;\n<32> memmove ( frame , frame + n , nframe - n ) ;\n<33> * r_result = frame ;
<1> static int dtext_prepare_text(AVFilterContext *ctx)\n<5> DrawTextContext *dtext = ctx->priv;\n<13> char *text = dtext->text;\n<81> if ((len = strlen(text)) > dtext->nb_positions) {\n<83> FT_Vector *p = av_realloc(dtext->positions,\n<85> len * sizeof(*dtext->positions));\n<87> if (!p) {\n<109> for (i = 0, p = text; *p; i++) {\n<145> for (i = 0, p = text; *p; i++) {
<1> e1000e_write_ps_rx_descr(E1000ECore *core, uint8_t *desc,\n<21> memset(d, 0, sizeof(*d));
<1> static int vp9_decode_frame(AVCodecContext *avctx, void *frame,\n<11> VP9Context *s = avctx->priv_data;\n<159> if (avctx->hwaccel) {\n<187> memset(s->above_partition_ctx, 0, s->cols);\n<189> memset(s->above_skip_ctx, 0, s->cols);\n<191> if (s->s.h.keyframe || s->s.h.intraonly) {\n<193> memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n<197> memset(s->above_mode_ctx, NEARESTMV, s->cols);\n<201> memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n<203> memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);\n<205> memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);\n<207> memset(s->above_segpred_ctx, 0, s->cols);\n<237> for (m = 0; m < 6; m++)\n<239> memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],\n<389> ff_vp9_adapt_probs(s);
<1> static void truemotion1_decode_16bit ( TrueMotion1Context * s ) {\n<16> memset ( s -> vert_pred , 0 , s -> avctx -> width * sizeof ( unsigned int ) ) ;\n<23> vert_pred = s -> vert_pred ;
<1> static void ra144_encode_subblock(RA144Context *ractx,\n<11> float data[BLOCKSIZE] = { 0 }, work[LPC_ORDER + BLOCKSIZE];\n<33> work[i] = ractx->curr_sblock[BLOCKSIZE + i];\n<73> memset(work, 0, LPC_ORDER * sizeof(*work));\n<77> cba_idx = adaptive_cb_search(ractx->adapt_cb, work + LPC_ORDER, coefs,\n<81> if (cba_idx) {\n<91> memcpy(cba, work + LPC_ORDER, sizeof(cba));\n<101> fixed_cb_search(work + LPC_ORDER, coefs, data, cba_idx, &cb1_idx, &cb2_idx);\n<105> cb1[i] = ff_cb1_vects[cb1_idx][i];\n<107> cb2[i] = ff_cb2_vects[cb2_idx][i];\n<111> ff_celp_lp_synthesis_filterf(work + LPC_ORDER, coefs, cb1, BLOCKSIZE,\n<115> memcpy(cb1, work + LPC_ORDER, sizeof(cb1));\n<119> ff_celp_lp_synthesis_filterf(work + LPC_ORDER, coefs, cb2, BLOCKSIZE,\n<123> memcpy(cb2, work + LPC_ORDER, sizeof(cb2));\n<151> data[i] = zero[i] + g[0] * cba[i] + g[1] * cb1[i] +\n<153> g[2] * cb2[i];\n<165> data[i] = zero[i] + g[1] * cb1[i] + g[2] * cb2[i];
<1> int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,\n<25> filters += strspn(filters, WHITESPACES);\n<29> if ((ret = parse_inputs(&filters, &curr_inputs, open_outputs, log_ctx)) < 0)\n<35> if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)\n<61> if ((ret = parse_outputs(&filters, &curr_inputs, open_inputs, open_outputs,\n<69> filters += strspn(filters, WHITESPACES);\n<71> chr = *filters++;\n<75> if (chr == ';' && curr_inputs) {\n<91> } while (chr == ',' || chr == ';');\n<95> if (chr) {\n<111> if (*open_inputs && !strcmp((*open_inputs)->name, "out") && curr_inputs) {\n<115> const char *tmp = "[out]";\n<117> if ((ret = parse_outputs(&tmp, &curr_inputs, open_inputs, open_outputs,\n<127> return 0;\n<139> avfilter_inout_free(open_inputs);\n<143> avfilter_inout_free(&curr_inputs);
<1> ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {\n<3> clone = ( ArchiveHandle * ) pg_malloc ( sizeof ( ArchiveHandle ) ) ;\n<4> memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;\n<5> memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;\n<12> if ( clone -> savedPassword ) clone -> savedPassword = pg_strdup ( clone -> savedPassword ) ;\n<14> if ( AH -> mode == archModeRead ) {\n<16> Assert ( AH -> connection == NULL ) ;\n<17> ConnectDatabase ( ( Archive * ) clone , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;\n<18> _doSetFixedOutputState ( clone ) ;\n<25> Assert ( AH -> connection != NULL ) ;\n<28> appendConnStrVal ( & connstr , PQdb ( AH -> connection ) ) ;\n<29> pghost = PQhost ( AH -> connection ) ;\n<30> pgport = PQport ( AH -> connection ) ;\n<31> username = PQuser ( AH -> connection ) ;\n<32> ConnectDatabase ( ( Archive * ) clone , connstr . data , pghost , pgport , username , TRI_NO ) ;\n<35> ( clone -> ClonePtr ) ( clone ) ;
<1> static void usb_host_auto_check(void *unused)\n<31> for (i = 0; i < n; i++) {\n<47> f = &s->match;\n<65> if (f->port != NULL) {\n<69> usb_host_get_port(devs[i], port, sizeof(port));\n<71> if (strcmp(f->port, port) != 0) {\n<79> if (f->vendor_id > 0 &&
<1> static int http_proxy_open(URLContext *h, const char *uri, int flags)\n<5> HTTPContext *s = h->priv_data;\n<45> ret = ffurl_open(&s->hd, lower_url, AVIO_FLAG_READ_WRITE,\n<49> if (ret < 0)\n<81> if ((ret = ffurl_write(s->hd, s->buffer, strlen(s->buffer))) < 0)\n<87> s->buf_ptr = s->buffer;\n<89> s->buf_end = s->buffer;\n<91> s->line_count = 0;\n<93> s->filesize = -1;\n<95> cur_auth_type = s->proxy_auth_state.auth_type;\n<119> if (http_get_line(s, line, sizeof(line)) < 0) {\n<151> ffurl_close(s->hd);\n<153> s->hd = NULL;\n<171> http_proxy_close(h);\n<173> return ret;
<1> void proto_register_fields_manual ( const int parent , header_field_info * * hfi , const int num_records ) {\n<8> if ( hfi [ i ] -> id != - 1 ) {\n<9> fprintf ( stderr , "Duplicate field detected in call to proto_register_fields: %s is already registered\n" , hfi [ i ] -> abbrev ) ;
<13> if (sub->needed(opaque)) {\n<15> const VMStateDescription *vmsd = sub->vmsd;\n<23> len = strlen(vmsd->name);\n<25> qemu_put_byte(f, len);\n<27> qemu_put_buffer(f, (uint8_t *)vmsd->name, len);\n<33> vmstate_save_state(f, vmsd, opaque);
<1> OM_uint32 kg_get_ccache_name ( OM_uint32 * minor_status , const char * * out_name ) {\n<6> if ( kg_ccache_name != NULL ) {\n<7> name = strdup ( kg_ccache_name ) ;\n<8> if ( name == NULL ) err = ENOMEM ;\n<15> name = krb5_cc_default_name ( context ) ;\n<16> if ( name ) {\n<17> name = strdup ( name ) ;\n<18> if ( name == NULL ) err = ENOMEM ;
<1> static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n<25> if (rc != 0) {\n<27> fprintf(stderr, "virtio-scsi: Failed to set host notifier (%d)\n",\n<47> if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n<49> fprintf(stderr, "virtio-scsi: VRing setup failed\n");
<1> static void decode_slice_plane ( ProresContext * ctx , ProresThreadData * td , const uint8_t * buf , int data_size , uint16_t * out_ptr , int linesize , int mbs_per_slice , int blocks_per_mb , int plane_size_factor , const int16_t * qmat , int is_chroma ) {\n<6> memset ( td -> blocks , 0 , 8 * 4 * 64 * sizeof ( * td -> blocks ) ) ;\n<8> decode_dc_coeffs ( & gb , td -> blocks , blocks_per_slice ) ;
<1> static char * get_icu_value_internal ( const char * loc_name , char * tag_name , int * result , int fromParseLocale ) {\n<9> if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) != 0 ) {\n<10> grOffset = findOffset ( LOC_GRANDFATHERED , loc_name ) ;\n<11> if ( grOffset >= 0 ) {\n<12> if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) {\n<13> return estrdup ( loc_name ) ;\n<16> return NULL ;\n<19> if ( fromParseLocale == 1 ) {\n<20> if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) {\n<21> if ( strlen ( loc_name ) > 1 && ( isIDPrefix ( loc_name ) == 1 ) ) {\n<22> return estrdup ( loc_name ) ;\n<25> singletonPos = getSingletonPos ( loc_name ) ;\n<26> if ( singletonPos == 0 ) {\n<34> if ( mod_loc_name == NULL ) {\n<38> tag_value = erealloc ( tag_value , buflen ) ;\n<39> tag_value_len = buflen ;\n<40> if ( strcmp ( tag_name , LOC_SCRIPT_TAG ) == 0 ) {\n<41> buflen = uloc_getScript ( mod_loc_name , tag_value , tag_value_len , & status ) ;\n<43> if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) {\n<44> buflen = uloc_getLanguage ( mod_loc_name , tag_value , tag_value_len , & status ) ;\n<46> if ( strcmp ( tag_name , LOC_REGION_TAG ) == 0 ) {\n<47> buflen = uloc_getCountry ( mod_loc_name , tag_value , tag_value_len , & status ) ;\n<49> if ( strcmp ( tag_name , LOC_VARIANT_TAG ) == 0 ) {\n<50> buflen = uloc_getVariant ( mod_loc_name , tag_value , tag_value_len , & status ) ;\n<52> if ( strcmp ( tag_name , LOC_CANONICALIZE_TAG ) == 0 ) {\n<53> buflen = uloc_canonicalize ( mod_loc_name , tag_value , tag_value_len , & status ) ;\n<55> if ( U_FAILURE ( status ) ) {\n<71> while ( buflen > tag_value_len ) ;
<1> static int rv20_decode_picture_header(MpegEncContext *s)\n<119> if(s->pp_time <=s->pb_time || s->pp_time <= s->pp_time - s->pb_time || s->pp_time<=0){\n<121> printf("messed up order, seeking?, skiping current b frame\n");
<1> int main ( int argc , char * * argv ) {\n<25> printf ( "Using %s\n" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n<35> stats = pass0 ( & raw , infile , encoder , & cfg ) ;\n<40> free ( stats . buf ) ;
<1> kadm5_ret_t kadm5_chpass_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) {\n<13> krb5_key_salt_tuple * new_ks_tuple = NULL ;\n<17> memset ( & hist , 0 , sizeof ( hist ) ) ;\n<20> if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ;\n<21> ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ;\n<30> ret = create_history_entry ( handle -> context , & hist_keyblocks [ 0 ] , kdb -> n_key_data , kdb -> key_data , & hist ) ;\n<36> ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , 0 , keepold , kdb ) ;\n<57> ret = add_to_history ( handle -> context , hist_kvno , & adb , & pol , & hist ) ;\n<93> ret = k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , password ) ;\n<96> ( void ) k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , password ) ;\n<98> done : free ( new_ks_tuple ) ;\n<99> if ( ! hist_added && hist . key_data ) free_history_entry ( handle -> context , & hist ) ;
<1> const char * trunc_left ( const char * src , size_t width ) {\n<4> sl = strlen ( src ) ;\n<5> if ( sl > width && LIB_BUFLENGTH - 1 > width && width > 1 ) {\n<6> LIB_GETBUF ( out ) ;\n<8> memcpy ( & out [ 1 ] , & src [ sl + 1 - width ] , width ) ;\n<11> return src ;
<1> void ahwrite ( const void * ptr , size_t size , size_t nmemb , ArchiveHandle * AH ) {\n<3> if ( AH -> writingBlob ) {\n<4> size_t remaining = size * nmemb ;\n<5> while ( AH -> lo_buf_used + remaining > AH -> lo_buf_size ) {\n<6> size_t avail = AH -> lo_buf_size - AH -> lo_buf_used ;\n<7> memcpy ( ( char * ) AH -> lo_buf + AH -> lo_buf_used , ptr , avail ) ;\n<8> ptr = ( const void * ) ( ( const char * ) ptr + avail ) ;\n<9> remaining -= avail ;\n<10> AH -> lo_buf_used += avail ;\n<11> dump_lo_buf ( AH ) ;\n<13> memcpy ( ( char * ) AH -> lo_buf + AH -> lo_buf_used , ptr , remaining ) ;\n<14> AH -> lo_buf_used += remaining ;
<1> int ExecuteSqlCommandBuf ( Archive * AHX , const char * buf , size_t bufLen ) {\n<10> if ( buf [ bufLen ] == '\0' ) ExecuteSqlCommand ( AH , buf , "could not execute query" ) ;\n<12> char * str = ( char * ) pg_malloc ( bufLen + 1 ) ;\n<13> memcpy ( str , buf , bufLen ) ;\n<14> str [ bufLen ] = '\0' ;\n<15> ExecuteSqlCommand ( AH , str , "could not execute query" ) ;\n<16> free ( str ) ;\n<19> return bufLen ;
<1> static int64_t alloc_block(BlockDriverState* bs, int64_t sector_num)\n<5> BDRVVPCState *s = bs->opaque;\n<13> uint8_t bitmap[s->bitmap_size];\n<29> if (s->pagetable[index] != 0xFFFFFFFF)\n<41> memset(bitmap, 0xff, s->bitmap_size);\n<43> bdrv_pwrite(bs->file, s->free_data_block_offset, bitmap, s->bitmap_size);
<1> static void xenstore_update_be(char *watch, char *type, int dom,\n<17> len = snprintf(path, sizeof(path), "%s/backend/%s/%d", dom0, type, dom);\n<19> free(dom0);\n<21> if (strncmp(path, watch, len) != 0) {\n<27> if (sscanf(watch+len, "/%u/%255s", &dev, path) != 2) {\n<29> strcpy(path, "");\n<31> if (sscanf(watch+len, "/%u", &dev) != 1) {\n<33> dev = -1;\n<39> if (dev == -1) {\n<47> xendev = xen_be_get_xendev(type, dom, dev, ops);\n<53> if (bepath == NULL) {\n<55> xen_be_del_xendev(dom, dev);\n<59> free(bepath);\n<61> xen_be_backend_changed(xendev, path);
<1> static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<9> SchroEncoderParams *p_schro_params = avctx->priv_data;\n<81> enc_buf = schro_encoder_pull(encoder, &presentation_frame);\n<83> if (enc_buf->length <= 0)\n<113> memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,\n<117> p_schro_params->enc_buf_size += enc_buf->length;\n<135> schro_buffer_unref(enc_buf);\n<153> p_frame_output->size     = p_schro_params->enc_buf_size;\n<155> p_frame_output->p_encbuf = p_schro_params->enc_buf;\n<169> p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);\n<177> p_schro_params->enc_buf_size = 0;\n<179> p_schro_params->enc_buf      = NULL;\n<183> schro_buffer_unref(enc_buf);\n<233> if (!p_frame_output)\n<241> if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)\n<245> if ((ret = ff_alloc_packet2(avctx, pkt, pkt_size, 0)) < 0)\n<251> memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);\n<275> enc_size = p_frame_output->size;\n<283> if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {\n<285> memcpy(pkt->data + enc_size, p_schro_params->enc_buf,\n<289> enc_size += p_schro_params->enc_buf_size;\n<291> av_freep(&p_schro_params->enc_buf);\n<311> libschroedinger_free_frame(p_frame_output);
<1> static void ini_print_str ( WriterContext * wctx , const char * key , const char * value ) {\n<4> printf ( "%s=" , ini_escape_str ( & buf , key ) ) ;\n<6> printf ( "%s\n" , ini_escape_str ( & buf , value ) ) ;
<1> int gs_main_run_string ( gs_main_instance * minst , const char * str , int user_errors , int * pexit_code , ref * perror_object ) {\n<2> return gs_main_run_string_with_length ( minst , str , ( uint ) strlen ( str ) , user_errors , pexit_code , perror_object ) ;
<1> void save_config ( struct recvbuf * rbufp , int restrict_mask ) {\n<13> snprintf ( reply , sizeof ( reply ) , "saveconfig prohibited by restrict ... nomodify" ) ;\n<14> ctl_putdata ( reply , strlen ( reply ) , 0 ) ;
<1> static int roq_dpcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<21> if (!in && context->input_frames >= 8)\n<29> memcpy(&context->frame_buffer[context->buffered_samples * avctx->channels],\n<31> in, avctx->frame_size * avctx->channels * sizeof(*in));
<1> int _zip_cdir_grow ( struct zip_cdir * cd , int nentry , struct zip_error * error ) {\n<3> if ( nentry < cd -> nentry ) {\n<7> if ( ( entry = ( ( struct zip_dirent * ) realloc ( cd -> entry , sizeof ( * ( cd -> entry ) ) * nentry ) ) ) == NULL ) {\n<8> _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n<9> return - 1 ;\n<11> cd -> nentry = nentry ;\n<12> cd -> entry = entry ;\n<13> return 0 ;
<1> static int scsi_disk_emulate_command(SCSIDiskReq *r)\n<41> r->buflen = MAX(4096, req->cmd.xfer);\n<49> outbuf = r->iov.iov_base;\n<51> switch (req->cmd.buf[0]) {\n<159> memset(outbuf, 0, 8);\n<277> if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n<281> memset(outbuf, 0, req->cmd.xfer);\n<351> buflen = req->cmd.xfer;\n<373> buflen = MIN(buflen, req->cmd.xfer);
<1> static GList * completion_nicks_nonstrict ( CHANNEL_REC * channel , const char * nick , const char * suffix , const int match_case ) {\n<8> len = strlen ( nick ) ;\n<13> tmp != NULL ;\n<15> NICK_REC * rec = tmp -> data ;\n<16> tmplen = strlen ( rec -> nick ) ;\n<17> if ( tmplen > str_len ) {\n<21> in = rec -> nick ;\n<28> if ( ( match_case ? strncmp ( str , nick , len ) : g_ascii_strncasecmp ( str , nick , len ) ) == 0 ) {\n<29> tnick = g_strconcat ( rec -> nick , suffix , NULL ) ;
<1> static void ppc_spapr_init(ram_addr_t ram_size,\n<97> if (!env) {\n<99> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<245> for (i = 0; i < nb_nics; i++) {\n<247> NICInfo *nd = &nd_table[i];\n<251> if (!nd->model) {\n<253> nd->model = g_strdup("ibmveth");\n<259> if (strcmp(nd->model, "ibmveth") == 0) {\n<261> spapr_vlan_create(spapr->vio_bus, 0x1000 + i, nd);\n<265> pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n<287> kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n<301> if (kernel_size < 0) {\n<303> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<319> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<323> if (initrd_size < 0) {\n<325> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<347> if (rma_size < (MIN_RMA_SLOF << 20)) {\n<349> fprintf(stderr, "qemu: pSeries SLOF firmware requires >= "
<1> static void usbredir_handle_destroy(USBDevice *udev)\n<24> usbredir_cleanup_device_queues(dev);\n<42> free(dev->filter_rules);
<1> static void multiple_write_cb ( int fd , short event , void * arg ) {\n<7> if ( len == - 1 ) {\n<8> fprintf ( stderr , "%s: write\n" , __func__ ) ;
<1> static void send_ifstats_entry ( endpt * la , u_int ifnum ) {\n<34> switch ( which ) {\n<35> case 0 : snprintf ( tag , sizeof ( tag ) , addr_fmtu , ifnum ) ;\n<36> pch = sptoa ( & la -> sin ) ;\n<37> ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;\n<39> case 1 : snprintf ( tag , sizeof ( tag ) , bcast_fmt , ifnum ) ;\n<40> if ( INT_BCASTOPEN & la -> flags ) pch = sptoa ( & la -> bcast ) ;\n<41> else pch = "" ;\n<42> ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;\n<47> case 3 : snprintf ( tag , sizeof ( tag ) , name_fmt , ifnum ) ;\n<48> ctl_putstr ( tag , la -> name , strlen ( la -> name ) ) ;
<1> static void test_insert_select ( ) {\n<22> i < 3 ;\n<23> i ++ ) {\n<26> if ( ! opt_silent ) fprintf ( stdout , "insert %u\n" , i ) ;\n<30> DIE_UNLESS ( rc == ( int ) ( i + 1 ) ) ;
<1> void ff_update_duplicate_context(MpegEncContext *dst, MpegEncContext *src)\n<13> backup_duplicate_context(&bak, dst);\n<15> memcpy(dst, src, sizeof(MpegEncContext));\n<17> backup_duplicate_context(dst, &bak);
<1> static int parse_read_intervals ( const char * intervals_spec ) {\n<7> p ++ ) if ( * p == ',' ) n ++ ;\n<15> p = spec ;\n<17> p ;\n<21> next = strchr ( p , ',' ) ;\n<22> if ( next ) * next ++ = 0 ;\n<24> ret = parse_read_interval ( p , & read_intervals [ i ] ) ;\n<31> p = next ;
<1> ParseResult mime_scanner_get ( MIMEScanner * S , const char * * raw_input_s , const char * raw_input_e , const char * * output_s , const char * * output_e , bool * output_shares_raw_input , bool raw_input_eof , int raw_input_scan_type ) {\n<6> ink_assert ( raw_input_e != nullptr ) ;\n<114> if ( zret != PARSE_RESULT_ERROR && memchr ( * raw_input_s , '\0' , raw_input_c - * raw_input_s ) != nullptr ) {\n<115> zret = PARSE_RESULT_ERROR ;
<1> int kvm_arch_handle_exit(CPUPPCState *env, struct kvm_run *run)\n<9> switch (run->exit_reason) {\n<55> fprintf(stderr, "KVM: unknown exit reason %d\n", run->exit_reason);
<1> static ssize_t qio_channel_websock_readv ( QIOChannel * ioc , const struct iovec * iov , size_t niov , int * * fds , size_t * nfds , Error * * errp ) {\n<17> i < niov ;\n<20> if ( want > ( wioc -> rawinput . offset - got ) ) {\n<21> want = ( wioc -> rawinput . offset - got ) ;\n<23> memcpy ( iov [ i ] . iov_base , wioc -> rawinput . buffer + got , want ) ;\n<24> got += want ;\n<25> if ( want < iov [ i ] . iov_len ) {
<1> void create_script_for_cluster_analyze ( char * * analyze_script_file_name ) {\n<5> initPQExpBuffer ( & user_specification ) ;\n<7> appendPQExpBufferStr ( & user_specification , "-U " ) ;\n<8> appendShellString ( & user_specification , os_info . user ) ;\n<12> if ( ( script = fopen_priv ( * analyze_script_file_name , "w" ) ) == NULL ) pg_fatal ( "Could not open file \"%s\": %s\n" , * analyze_script_file_name , getErrorText ( ) ) ;\n<16> fprintf ( script , "echo %sso your system is usable, and then gather statistics twice more%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<17> fprintf ( script , "echo %swith increasing accuracy. When it is done, your system will%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<18> fprintf ( script , "echo %shave the default level of optimizer statistics.%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<19> fprintf ( script , "echo%s\n\n" , ECHO_BLANK ) ;\n<20> fprintf ( script , "echo %sIf you have used ALTER TABLE to modify the statistics target for%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<21> fprintf ( script , "echo %sany tables, you might want to remove them and restore them after%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<22> fprintf ( script , "echo %srunning this script because they will delay fast statistics generation.%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<23> fprintf ( script , "echo%s\n\n" , ECHO_BLANK ) ;\n<24> fprintf ( script , "echo %sIf you would like default statistics as quickly as possible, cancel%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<25> fprintf ( script , "echo %sthis script and run:%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<26> fprintf ( script , "echo %s \"%s/vacuumdb\" %s--all %s%s\n" , ECHO_QUOTE , new_cluster . bindir , user_specification . data , ( GET_MAJOR_VERSION ( old_cluster . major_version ) >= 804 ) ? "--analyze-only" : "--analyze" , ECHO_QUOTE ) ;\n<27> fprintf ( script , "echo%s\n\n" , ECHO_BLANK ) ;\n<28> fprintf ( script , "\"%s/vacuumdb\" %s--all --analyze-in-stages\n" , new_cluster . bindir , user_specification . data ) ;\n<29> if ( GET_MAJOR_VERSION ( old_cluster . major_version ) < 804 ) fprintf ( script , "\"%s/vacuumdb\" %s--all\n" , new_cluster . bindir , user_specification . data ) ;\n<30> fprintf ( script , "echo%s\n\n" , ECHO_BLANK ) ;\n<31> fprintf ( script , "echo %sDone%s\n" , ECHO_QUOTE , ECHO_QUOTE ) ;\n<32> fclose ( script ) ;
<1> static int libkvazaar_encode(AVCodecContext *avctx,\n<67> uint8_t *dst = img_in->data[i];\n<69> uint8_t *src = frame->data[i];\n<71> int width = (i == 0) ? frame->width : (frame->width / 2);\n<77> for (y = 0; y < height; ++y) {\n<79> memcpy(dst, src, width);\n<81> src += frame->linesize[i];\n<83> dst += width;\n<115> uint64_t written = 0;\n<119> retval = ff_alloc_packet(avpkt, len_out);\n<131> for (chunk = data_out; chunk != NULL; chunk = chunk->next) {\n<133> av_assert0(written + chunk->len <= len_out);\n<135> memcpy(avpkt->data + written, chunk->data, chunk->len);\n<137> written += chunk->len;
<1> static void process_flags ( int argc , char * * argv ) {\n<18> while ( ( c = getopt_long ( argc , argv , "c:hlmps:" , long_options , NULL ) ) != - 1 ) {\n<33> if ( ( optind < argc ) && ( strcmp ( argv [ optind ] , "-" ) == 0 ) ) {\n<34> fakelogin = true ;\n<35> optind ++ ;\n<36> if ( ( optind < argc ) && ( strcmp ( argv [ optind ] , "--" ) == 0 ) ) {\n<37> optind ++ ;\n<40> if ( ( optind < argc ) && ( '-' != argv [ optind ] [ 0 ] ) ) {\n<42> if ( ( optind < argc ) && ( strcmp ( argv [ optind ] , "--" ) == 0 ) ) {\n<43> optind ++ ;
<1> static int parse_from ( struct branch * b ) {\n<21> if ( oe -> pack_id != MAX_PACK_ID ) {\n<24> parse_from_commit ( b , buf , size ) ;\n<25> free ( buf ) ;
<1> void xmlrpc_send ( int argc , ... ) {\n<7> mowgli_string_t * s = mowgli_string_create ( ) ;\n<11> snprintf ( buf , sizeof buf , "<?xml version=\"1.0\" encoding=\"%s\" ?>\r\n<methodResponse>\r\n<params>\r\n" , xmlrpc . encode ) ;\n<14> snprintf ( buf , sizeof buf , "<?xml version=\"1.0\"?>\r\n<methodResponse>\r\n<params>\r\n" ) ;\n<16> s -> append ( s , buf , strlen ( buf ) ) ;\n<19> idx < argc ;\n<21> ss = " <param>\r\n <value>\r\n " ;\n<22> s -> append ( s , ss , strlen ( ss ) ) ;\n<24> s -> append ( s , ss , strlen ( ss ) ) ;\n<25> ss = "\r\n </value>\r\n </param>\r\n" ;\n<26> s -> append ( s , ss , strlen ( ss ) ) ;\n<29> ss = "</params>\r\n</methodResponse>" ;\n<30> s -> append ( s , ss , strlen ( ss ) ) ;\n<31> len = s -> pos ;\n<32> if ( xmlrpc . httpheader ) {\n<33> header = xmlrpc_write_header ( len ) ;\n<34> s2 = smalloc ( strlen ( header ) + len + 1 ) ;\n<35> strcpy ( s2 , header ) ;\n<36> memcpy ( s2 + strlen ( header ) , s -> str , len ) ;\n<37> xmlrpc . setbuffer ( s2 , len + strlen ( header ) ) ;\n<38> free ( header ) ;\n<39> free ( s2 ) ;\n<43> xmlrpc . setbuffer ( s -> str , len ) ;\n<45> if ( xmlrpc . encode ) {\n<46> free ( xmlrpc . encode ) ;\n<49> s -> destroy ( s ) ;
<1> static void print_comment ( FILE * sql_file , my_bool is_error , const char * format , ... ) {\n<6> my_vsnprintf ( comment_buff , COMMENT_LENGTH , format , args ) ;\n<8> if ( ! opt_xml ) {\n<13> print_xml_comment ( sql_file , strlen ( comment_buff ) , comment_buff ) ;
<1> static gpgme_error_t uiserver_sign ( void * engine , gpgme_data_t in , gpgme_data_t out , gpgme_sig_mode_t mode , int use_armor , int use_textmode , int include_certs , gpgme_ctx_t ctx ) {\n<8> if ( uiserver -> protocol == GPGME_PROTOCOL_DEFAULT ) protocol = "" ;\n<9> else if ( uiserver -> protocol == GPGME_PROTOCOL_OpenPGP ) protocol = " --protocol=OpenPGP" ;\n<10> else if ( uiserver -> protocol == GPGME_PROTOCOL_CMS ) protocol = " --protocol=CMS" ;\n<12> if ( asprintf ( & cmd , "SIGN%s%s" , protocol , ( mode == GPGME_SIG_MODE_DETACH ) ? " --detached" : "" ) < 0 ) return gpg_error_from_syserror ( ) ;\n<13> key = gpgme_signers_enum ( ctx , 0 ) ;\n<14> if ( key ) {\n<15> const char * s = NULL ;\n<16> if ( key && key -> uids ) s = key -> uids -> email ;\n<17> if ( s && strlen ( s ) < 80 ) {\n<18> char buf [ 100 ] ;\n<19> strcpy ( stpcpy ( buf , "SENDER --info " ) , s ) ;\n<20> err = uiserver_assuan_simple_command ( uiserver -> assuan_ctx , buf , uiserver -> status . fnc , uiserver -> status . fnc_value ) ;\n<22> else err = gpg_error ( GPG_ERR_INV_VALUE ) ;\n<24> if ( err ) {\n<25> free ( cmd ) ;\n<31> if ( err ) {\n<32> free ( cmd ) ;\n<37> if ( err ) {\n<38> free ( cmd ) ;\n<42> err = start ( uiserver , cmd ) ;\n<43> free ( cmd ) ;
<1> int text_console_init(QemuOpts *opts, CharDriverState **_chr)\n<19> if (n_text_consoles == 128) {\n<21> fprintf(stderr, "Too many text consoles\n");
<1> static void filter(SPPContext *p, uint8_t *dst, uint8_t *src,\n<25> for (y = 0; y < height; y++) {\n<29> memcpy(p->src + index*sample_bytes, src + y*src_linesize, width*sample_bytes);\n<35> p->src[index         - x - 1] = p->src[index +         x    ];\n<37> p->src[index + width + x    ] = p->src[index + width - x - 1];\n<55> for (y = 0; y < 8; y++) {\n<57> memcpy(p->src + (       7-y)*linesize * sample_bytes, p->src + (       y+8)*linesize * sample_bytes, linesize * sample_bytes);\n<59> memcpy(p->src + (height+8+y)*linesize * sample_bytes, p->src + (height-y+7)*linesize * sample_bytes, linesize * sample_bytes);\n<65> for (y = 0; y < height + 8; y += 8) {\n<67> memset(p->temp + (8 + y) * linesize, 0, 8 * linesize * sizeof(*p->temp));
<1> static int qemu_rdma_post_send_control(RDMAContext *rdma, uint8_t *buf,\n<3> RDMAControlHeader *head)\n<9> RDMAWorkRequestData *wr = &rdma->wr_data[RDMA_WRID_CONTROL];\n<15> .addr = (uint64_t)(wr->control),\n<59> assert(head->len <= RDMA_CONTROL_MAX_BUFFER - sizeof(*head));\n<61> memcpy(wr->control, head, sizeof(RDMAControlHeader));\n<63> control_to_network((void *) wr->control);\n<67> if (buf) {\n<69> memcpy(wr->control + sizeof(RDMAControlHeader), buf, head->len);\n<81> if (ret > 0) {\n<83> fprintf(stderr, "Failed to use post IB SEND for control!\n");\n<93> if (ret < 0) {\n<95> fprintf(stderr, "rdma migration: send polling control error!\n");
<1> static int vmdaudio_decode_frame(AVCodecContext *avctx, void *data,\n<9> const uint8_t *buf = avpkt->data;\n<15> VmdAudioContext *s = avctx->priv_data;\n<91> audio_chunks = buf_size / s->chunk_size;\n<109> output_samples_u8  =            frame->data[0];\n<111> output_samples_s16 = (int16_t *)frame->data[0];\n<119> int silent_size = avctx->block_align * silent_chunks;\n<121> if (s->out_bps == 2) {\n<123> memset(output_samples_s16, 0x00, silent_size * 2);\n<125> output_samples_s16 += silent_size;\n<129> memset(output_samples_u8,  0x80, silent_size);\n<131> output_samples_u8 += silent_size;\n<145> while (buf < buf_end) {\n<147> if (s->out_bps == 2) {\n<149> decode_audio_s16(output_samples_s16, buf, s->chunk_size,\n<157> memcpy(output_samples_u8, buf, s->chunk_size);\n<159> output_samples_u8  += avctx->block_align;\n<163> buf += s->chunk_size;
<1> static decoder_t * CreateDecoder ( vlc_object_t * p_parent , input_thread_t * p_input , es_format_t * fmt , bool b_packetizer , input_resource_t * p_resource , sout_instance_t * p_sout ) {\n<6> if ( p_dec == NULL ) return NULL ;\n<13> memset ( & null_es_format , 0 , sizeof ( es_format_t ) ) ;\n<15> es_format_Copy ( & p_dec -> fmt_out , & null_es_format ) ;\n<17> p_dec -> p_owner = p_owner = malloc ( sizeof ( decoder_owner_sys_t ) ) ;\n<18> if ( unlikely ( p_owner == NULL ) ) {\n<19> vlc_object_release ( p_dec ) ;\n<22> p_owner -> i_preroll_end = VLC_TS_INVALID ;\n<23> p_owner -> i_last_rate = INPUT_RATE_DEFAULT ;\n<24> p_owner -> p_input = p_input ;\n<25> p_owner -> p_resource = p_resource ;\n<26> p_owner -> p_aout = NULL ;\n<27> p_owner -> p_vout = NULL ;\n<28> p_owner -> p_spu_vout = NULL ;\n<29> p_owner -> i_spu_channel = 0 ;\n<30> p_owner -> i_spu_order = 0 ;\n<31> p_owner -> p_sout = p_sout ;\n<32> p_owner -> p_sout_input = NULL ;\n<33> p_owner -> p_packetizer = NULL ;\n<34> p_owner -> b_packetizer = b_packetizer ;\n<36> if ( unlikely ( p_owner -> p_fifo == NULL ) ) {\n<37> free ( p_owner ) ;\n<38> vlc_object_release ( p_dec ) ;\n<51> if ( ! b_packetizer ) p_dec -> p_module = module_need ( p_dec , "decoder" , "$codec" , false ) ;\n<52> else p_dec -> p_module = module_need ( p_dec , "packetizer" , "$packetizer" , false ) ;\n<57> es_format_Copy ( & p_owner -> p_packetizer -> fmt_out , & null_es_format ) ;\n<106> return p_dec ;
<1> void audio_decode_example(const char *outfilename, const char *filename)\n<15> uint8_t inbuf[INBUF_SIZE + FF_INPUT_BUFFER_PADDING_SIZE], *inbuf_ptr;\n<19> printf("Audio decoding\n");\n<25> memset(inbuf + INBUF_SIZE, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<33> if (!codec) {\n<35> fprintf(stderr, "codec not found\n");\n<49> if (avcodec_open(c, codec) < 0) {\n<51> fprintf(stderr, "could not open codec\n");\n<59> outbuf = malloc(AVCODEC_MAX_AUDIO_FRAME_SIZE);\n<63> f = fopen(filename, "r");\n<65> if (!f) {\n<67> fprintf(stderr, "could not open %s\n", filename);\n<75> if (!outfile) {\n<77> free(c);\n<103> len = avcodec_decode_audio(c, (short *)outbuf, &out_size,\n<107> if (len < 0) {\n<109> fprintf(stderr, "Error while decoding\n");\n<119> fwrite(outbuf, 1, out_size, outfile);\n<137> free(outbuf);\n<141> avcodec_close(c);\n<143> free(c);
<1> static gboolean refresh_connections ( gpointer data ) {\n<7> char flags [ 2 ] , status [ 8 ] ;\n<11> memset ( & flags , 0 , sizeof ( flags ) ) ;\n<12> memset ( & status , 0 , sizeof ( status ) ) ;\n<54> conntrack_flagstr ( conn , flags , sizeof ( flags ) ) ;\n<55> conntrack_statusstr ( conn , status , sizeof ( status ) ) ;\n<58> gtk_list_store_set ( ls_conns , & iter , 0 , flags , 7 , status , 8 , tx , 9 , rx , - 1 ) ;
<1> static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , int features ) {\n<25> if ( ( skb_headroom ( skb ) < frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ;\n<29> unfrag_len = skb_network_header ( skb ) - skb_mac_header ( skb ) + unfrag_ip6hlen ;\n<31> memmove ( mac_start - frag_hdr_sz , mac_start , unfrag_len ) ;
<1> static int aes_gcm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n<2> EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n<20> case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n<21> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n<22> gctx -> taglen = arg ;\n<24> case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > 16 || ! EVP_CIPHER_CTX_encrypting ( c ) || gctx -> taglen < 0 ) return 0 ;\n<25> memcpy ( ptr , EVP_CIPHER_CTX_buf_noconst ( c ) , arg ) ;\n<27> case EVP_CTRL_GCM_SET_IV_FIXED : if ( arg == - 1 ) {\n<28> memcpy ( gctx -> iv , ptr , gctx -> ivlen ) ;\n<32> if ( ( arg < 4 ) || ( gctx -> ivlen - arg ) < 8 ) return 0 ;\n<33> if ( arg ) memcpy ( gctx -> iv , ptr , arg ) ;\n<34> if ( EVP_CIPHER_CTX_encrypting ( c ) && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 ) return 0 ;\n<37> case EVP_CTRL_GCM_IV_GEN : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 ) return 0 ;\n<40> memcpy ( ptr , gctx -> iv + gctx -> ivlen - arg , arg ) ;\n<44> case EVP_CTRL_GCM_SET_IV_INV : if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || EVP_CIPHER_CTX_encrypting ( c ) ) return 0 ;\n<45> memcpy ( gctx -> iv + gctx -> ivlen - arg , ptr , arg ) ;\n<49> case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n<50> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n<51> gctx -> tls_aad_len = arg ;\n<53> unsigned int len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n<66> EVP_AES_GCM_CTX * gctx_out = EVP_C_DATA ( EVP_AES_GCM_CTX , out ) ;\n<71> if ( gctx -> iv == EVP_CIPHER_CTX_iv_noconst ( c ) ) gctx_out -> iv = EVP_CIPHER_CTX_iv_noconst ( out ) ;\n<73> gctx_out -> iv = OPENSSL_malloc ( gctx -> ivlen ) ;\n<74> if ( gctx_out -> iv == NULL ) return 0 ;\n<75> memcpy ( gctx_out -> iv , gctx -> iv , gctx -> ivlen ) ;
<1> uchar * get_table_key ( const char * entry , size_t * length , my_bool not_used __attribute__ ( ( unused ) ) ) {\n<2> * length = strlen ( entry ) ;\n<3> return ( uchar * ) entry ;
<1> static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) {\n<2> size_t Data_Buf_Size = 1024 ;\n<3> char Buf [ 1024 ] ;\n<30> while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) {\n<31> num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ;\n<33> if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) {\n<49> UpnpPrintf ( UPNP_INFO , HTTP , __FILE__ , __LINE__ , "<<< (RECVD) <<<\n%s\n-----------------\n" , parser -> msg . msg . buf ) ;\n<65> Data_Buf_Size = parser -> msg . entity . length - entity_offset ;\n<67> memcpy ( Buf , & parser -> msg . msg . buf [ parser -> entity_start_position + entity_offset ] , Data_Buf_Size ) ;\n<68> entity_offset += Data_Buf_Size ;\n<70> int n = virtualDirCallback . write ( Fp , Buf , Data_Buf_Size ) ;\n<77> size_t n = fwrite ( Buf , 1 , Data_Buf_Size , Fp ) ;\n<78> if ( n != Data_Buf_Size ) {
<138> if ( ff_vc1_parse_frame_header ( v , & s -> gb ) == - 1 ) {\n<143> if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) == - 1 ) {\n<222> if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n<229> if ( ff_vc1_parse_frame_header_adv ( v , & s -> gb ) < 0 ) {\n<238> ff_vc1_decode_blocks ( v ) ;\n<243> if ( s -> pict_type == AV_PICTURE_TYPE_B ) {\n<244> memcpy ( v -> mv_f_base , v -> mv_f_next_base , 2 * ( s -> b8_stride * ( s -> mb_height * 2 + 1 ) + s -> mb_stride * ( s -> mb_height + 1 ) * 2 ) ) ;
<1> static int cmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> CmvContext * s = avctx -> priv_data ;\n<14> if ( ( ret = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) {\n<18> memcpy ( frame -> data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n<21> cmv_decode_inter ( s , frame , buf + 2 , buf_end ) ;\n<28> cmv_decode_intra ( s , frame , buf + 2 , buf_end ) ;
<1> int y4m_input_fetch_frame ( y4m_input * _y4m , FILE * _fin , vpx_image_t * _img ) {\n<8> if ( ! file_read ( frame , 6 , _fin ) ) return 0 ;\n<9> if ( memcmp ( frame , "FRAME" , 5 ) ) {\n<10> fprintf ( stderr , "Loss of framing in Y4M input data\n" ) ;\n<11> return - 1 ;\n<13> if ( frame [ 5 ] != '\n' ) {\n<20> if ( j == 79 ) {\n<21> fprintf ( stderr , "Error parsing Y4M frame header\n" ) ;\n<25> if ( ! file_read ( _y4m -> dst_buf , _y4m -> dst_buf_read_sz , _fin ) ) {\n<26> fprintf ( stderr , "Error reading Y4M frame data.\n" ) ;\n<29> if ( ! file_read ( _y4m -> aux_buf , _y4m -> aux_buf_read_sz , _fin ) ) {\n<30> fprintf ( stderr , "Error reading Y4M frame data.\n" ) ;\n<34> memset ( _img , 0 , sizeof ( * _img ) ) ;
<1> static bool cmd_smart(IDEState *s, uint8_t cmd)\n<25> switch (s->feature) {\n<91> memset(s->io_buffer, 0, 0x200);\n<121> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n<131> memset(s->io_buffer, 0, 0x200);\n<203> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n<213> switch (s->sector) {\n<217> memset(s->io_buffer, 0, 0x200);\n<241> memset(s->io_buffer, 0, 0x200);\n<281> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);
<1> static int isoent_cmp_node ( const struct archive_rb_node * n1 , const struct archive_rb_node * n2 ) {\n<4> return ( strcmp ( e1 -> file -> basename . s , e2 -> file -> basename . s ) ) ;
<1> static void evport_dealloc ( struct event_base * base , void * arg ) {\n<2> struct evport_data * evpd = arg ;\n<4> close ( evpd -> ed_port ) ;\n<5> if ( evpd -> ed_fds ) free ( evpd -> ed_fds ) ;\n<6> free ( evpd ) ;
<1> static void test_simplesignal ( void ) {\n<9> memset ( & itv , 0 , sizeof ( itv ) ) ;\n<11> if ( setitimer ( ITIMER_REAL , & itv , NULL ) == - 1 ) goto skip_simplesignal ;
<1> static void create_header64(DumpState *s, Error **errp)\n<14> dh = g_malloc0(size);\n<15> strncpy(dh->signature, KDUMP_SIGNATURE, strlen(KDUMP_SIGNATURE));\n<27> strncpy(dh->utsname.machine, ELF_MACHINE_UNAME, sizeof(dh->utsname.machine));
<1> static int cng_decode_frame(AVCodecContext *avctx, void *data,\n<9> CNGContext *p = avctx->priv_data;\n<23> if (avpkt->size) {\n<29> memset(p->target_refl_coef, 0, p->order * sizeof(*p->target_refl_coef));\n<33> p->target_refl_coef[i] = (avpkt->data[1 + i] - 127) / 128.0;\n<51> if (p->inited) {\n<63> memcpy(p->refl_coef, p->target_refl_coef, p->order * sizeof(*p->refl_coef));\n<69> make_lpc_coefs(p->lpc_coef, p->refl_coef, p->order);\n<97> if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n<103> for (i = 0; i < avctx->frame_size; i++)\n<107> memcpy(p->filter_out, p->filter_out + avctx->frame_size,\n<109> p->order * sizeof(*p->filter_out));
<1> void * concat_gen_fifos ( void * first , void * second ) {\n<7> else if ( NULL == pf2 ) return pf1 ;\n<8> CONCAT_FIFO ( * pf1 , * pf2 , link ) ;\n<9> free ( pf2 ) ;
<1> int ff_h264_decode_mb_cavlc(const H264Context *h, H264SliceContext *sl)\n<155> if (get_bits_left(&sl->gb) < mb_size) {\n<173> memset(h->non_zero_count[mb_xy], 16, 48);
<1> void mips_r4k_init(MachineState *machine)\n<69> if (cpu == NULL) {\n<71> fprintf(stderr, "Unable to find CPU definition\n");\n<93> if (ram_size > (256 << 20)) {\n<99> ((unsigned int)ram_size / (1 << 20)));\n<131> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<175> if (!pflash_cfi01_register(0x1fc00000, NULL, "mips_r4k.bios", mips_rom,\n<183> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<187> } else if (!qtest_enabled()) {\n<191> fprintf(stderr, "qemu: Warning, could not load MIPS bios '%s'\n",
<1> static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n<5> switch ( type ) {\n<11> memcpy ( & d , buffer + * position , 8 ) ;\n<12> value = PyFloat_FromDouble ( d ) ;\n<34> memcpy ( & size , buffer + * position , 4 ) ;\n<35> if ( max < size ) {\n<38> value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ;\n<39> if ( ! value ) {\n<42> if ( strcmp ( buffer + * position + 5 , "$ref" ) == 0 ) {\n<44> PyObject * collection = PyDict_GetItemString ( value , "$ref" ) ;\n<45> PyObject * id = PyDict_GetItemString ( value , "$id" ) ;\n<46> PyObject * database = PyDict_GetItemString ( value , "$db" ) ;\n<47> Py_INCREF ( collection ) ;\n<48> PyDict_DelItemString ( value , "$ref" ) ;\n<49> if ( id == NULL ) {\n<57> if ( database == NULL ) {\n<65> dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ;\n<66> Py_DECREF ( value ) ;\n<67> value = dbref ;\n<68> Py_DECREF ( id ) ;\n<69> Py_DECREF ( collection ) ;\n<70> Py_DECREF ( database ) ;\n<71> if ( ! value ) {\n<75> * position += size ;\n<80> memcpy ( & size , buffer + * position , 4 ) ;\n<81> if ( max < size ) {\n<84> end = * position + size - 1 ;\n<90> while ( * position < end ) {\n<92> int type = ( int ) buffer [ ( * position ) ++ ] ;\n<93> int key_size = strlen ( buffer + * position ) ;\n<94> * position += key_size + 1 ;\n<95> to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ;\n<110> memcpy ( & length , buffer + * position , 4 ) ;\n<111> if ( max < length ) {\n<127> data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ;\n<135> if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) {
<1> bool metakey_h ( connection_t * c ) {\n<2> char buffer [ MAX_STRING_SIZE ] ;\n<5> if ( sscanf ( c -> buffer , "%*d %d %d %d %d " MAX_STRING , & cipher , & digest , & maclength , & compression , buffer ) != 5 ) {\n<10> if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n<11> logger ( LOG_ERR , "Possible intruder %s (%s): %s" , c -> name , c -> hostname , "wrong keylength" ) ;\n<12> return false ;\n<14> c -> inkey = xrealloc ( c -> inkey , len ) ;\n<15> if ( ! c -> inctx ) {\n<21> if ( ! hex2bin ( buffer , buffer , len ) ) {
<1> static void http_dispatcher_test_done ( struct evhttp_request * req , void * arg ) {\n<2> const char * what = "DISPATCHER_TEST" ;\n<3> if ( req -> response_code != HTTP_OK ) {\n<4> fprintf ( stderr , "FAILED\n" ) ;\n<7> if ( evhttp_find_header ( req -> input_headers , "Content-Type" ) == NULL ) {\n<8> fprintf ( stderr , "FAILED (content type)\n" ) ;\n<11> if ( EVBUFFER_LENGTH ( req -> input_buffer ) != strlen ( what ) ) {\n<12> fprintf ( stderr , "FAILED (length %zu vs %zu)\n" , EVBUFFER_LENGTH ( req -> input_buffer ) , strlen ( what ) ) ;\n<15> if ( memcmp ( EVBUFFER_DATA ( req -> input_buffer ) , what , strlen ( what ) ) != 0 ) {\n<16> fprintf ( stderr , "FAILED (data)\n" ) ;\n<17> exit ( 1 ) ;
<1> static char * _zip_readstr ( unsigned char * * buf , int len , int nulp , struct zip_error * error ) {\n<3> r = ( char * ) malloc ( nulp ? len + 1 : len ) ;\n<4> if ( ! r ) {\n<8> memcpy ( r , * buf , len ) ;\n<9> * buf += len ;\n<12> for ( o = r ;\n<13> o < r + len ;\n<16> return r ;
<1> static kadm5_ret_t apply_keysalt_policy ( kadm5_server_handle_t handle , const char * policy , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , int * new_n_kstp , krb5_key_salt_tuple * * new_kstp ) {\n<7> krb5_key_salt_tuple * ak_ks_tuple = NULL ;\n<8> krb5_key_salt_tuple * new_ks_tuple = NULL ;\n<15> memset ( & polent , 0 , sizeof ( polent ) ) ;\n<16> ret = get_policy ( handle , policy , & polent , & have_polent ) ;\n<18> if ( polent . allowed_keysalts == NULL ) {\n<21> ks_tuple = handle -> params . keysalts ;\n<23> new_ks_tuple = malloc ( n_ks_tuple * sizeof ( * new_ks_tuple ) ) ;\n<24> if ( new_ks_tuple == NULL ) {\n<28> memcpy ( new_ks_tuple , ks_tuple , n_ks_tuple * sizeof ( * new_ks_tuple ) ) ;\n<33> ret = krb5_string_to_keysalts ( polent . allowed_keysalts , "," , NULL , 0 , & ak_ks_tuple , & ak_n_ks_tuple ) ;\n<38> if ( ! ks_tuple_present ( ak_n_ks_tuple , ak_ks_tuple , & ks_tuple [ i ] ) ) {\n<43> if ( n_ks_tuple == 0 ) {\n<45> new_ks_tuple = ak_ks_tuple ;\n<46> ak_ks_tuple = NULL ;\n<49> subset = calloc ( n_ks_tuple , sizeof ( * subset ) ) ;\n<50> if ( subset == NULL ) {\n<57> if ( ks_tuple_present ( n_ks_tuple , ks_tuple , & ak_ks_tuple [ i ] ) ) subset [ m ++ ] = ak_ks_tuple [ i ] ;\n<59> new_ks_tuple = subset ;\n<62> cleanup : if ( have_polent ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ;\n<63> free ( ak_ks_tuple ) ;\n<64> if ( new_n_kstp != NULL ) {\n<66> * new_kstp = new_ks_tuple ;\n<69> free ( new_ks_tuple ) ;
<1> static void init_fps(int bf, int audio_preroll, int fps)\n<51> if (!st->codec->extradata)\n<55> memcpy(st->codec->extradata, h264_extradata, sizeof(h264_extradata));\n<85> if (!st->codec->extradata)\n<89> memcpy(st->codec->extradata, aac_extradata, sizeof(aac_extradata));
<1> static void server_request_free_answers ( struct server_request * req ) {\n<10> victim = * list ;\n<11> while ( victim ) {\n<13> free ( victim -> name ) ;\n<14> if ( victim -> data ) free ( victim -> data ) ;\n<15> free ( victim ) ;\n<16> victim = next ;
<1> int cmp_bits ( REP_SET * set1 , REP_SET * set2 ) {\n<2> return memcmp ( set1 -> bits , set2 -> bits , sizeof ( uint ) * set1 -> size_of_bits ) ;
<1> static int s_aos_process ( stream_state * st , stream_cursor_read * ignore_pr , stream_cursor_write * pw , bool last ) {\n<5> uint max_count = pw -> limit - pw -> ptr ;\n<10> if ( pos >= ss -> file_sz ) return EOFC ;\n<16> data = blk_ref [ blk_i ] . value . bytes ;\n<17> if ( max_count > count - blk_off ) {\n<18> max_count = count - blk_off ;\n<21> memcpy ( pw -> ptr + 1 , data + blk_off , max_count ) ;\n<22> pw -> ptr += max_count ;
<1> static int log_test_handler ( TSCont contp , TSEvent event , void * ) {\n<7> LogTestData * data = ( LogTestData * ) TSContDataGet ( contp ) ;\n<9> if ( ( filep = TSfopen ( data -> fullpath_logname , "r" ) ) == nullptr ) {\n<16> while ( TSfgets ( filep , buf , 1024 ) != nullptr ) {\n<17> if ( strstr ( buf , LOG_TEST_PATTERN ) != nullptr ) {\n<18> str_found = true ;\n<24> SDK_RPRINT ( data -> test , "TSTextLogObject" , "TestCase1" , TC_FAIL , "can not find pattern %s in log file" , LOG_TEST_PATTERN ) ;\n<48> char * meta_filename = ( char * ) ats_malloc ( l + 7 ) ;\n<49> if ( i < 0 ) {\n<53> memcpy ( meta_filename , data -> fullpath_logname , i + 1 ) ;\n<54> ink_string_concatenate_strings ( & meta_filename [ i + 1 ] , "." , & data -> fullpath_logname [ i + 1 ] , ".meta" , NULL ) ;\n<56> unlink ( data -> fullpath_logname ) ;\n<57> unlink ( meta_filename ) ;\n<59> TSfree ( meta_filename ) ;\n<60> meta_filename = nullptr ;\n<63> data = nullptr ;
<1> static int open_pack_bitmap_1 ( struct packed_git * packfile ) {\n<5> if ( open_pack_index ( packfile ) ) return - 1 ;\n<7> fd = git_open_noatime ( idx_name ) ;\n<8> free ( idx_name ) ;
<1> static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n<47> if (le32_to_cpu(ph.version) != HEADER_VERSION) {\n<53> if (!memcmp(ph.magic, HEADER_MAGIC, 16)) {\n<55> s->off_multiplier = 1;\n<57> bs->total_sectors = 0xffffffff & bs->total_sectors;\n<59> } else if (!memcmp(ph.magic, HEADER_MAGIC2, 16)) {\n<61> s->off_multiplier = le32_to_cpu(ph.tracks);\n<71> s->tracks = le32_to_cpu(ph.tracks);\n<73> if (s->tracks == 0) {\n<277> error_setg(errp, "Image not in Parallels format");\n<279> ret = -EINVAL;\n<283> qemu_vfree(s->header);\n<285> return ret;
<1> static void vvfat_close(BlockDriverState *bs)\n<9> vvfat_close_current_file(s);\n<17> if(s->cluster_buffer)\n<19> free(s->cluster_buffer);
<1> static cmsBool WriteCLUT ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt8Number Precision , cmsStage * mpe ) {\n<5> if ( CLUT -> HasFloatValues ) {\n<9> memset ( gridPoints , 0 , sizeof ( gridPoints ) ) ;\n<13> if ( ! io -> Write ( io , cmsMAXCHANNELS * sizeof ( cmsUInt8Number ) , gridPoints ) ) return FALSE ;
<1> static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)\n<9> float *out   = sce->ret;\n<11> float *saved = sce->saved;\n<19> float *buf  = ac->buf_mdct;\n<45> ff_imdct_half(&ac->mdct, buf, in);\n<65> ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);\n<71> out[i] = saved[i] + bias;\n<75> if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n<85> ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);\n<87> memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));\n<91> ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);\n<105> if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n<109> saved[i] = temp[64 + i] - bias;\n<117> memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n<119> } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {\n<121> memcpy(                    saved,       buf + 512,        448 * sizeof(float));\n<123> memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n<127> memcpy(                    saved,       buf + 512,        512 * sizeof(float));
<1> static int setup_boot_information ( struct archive_write * a ) {\n<15> while ( size > 0 ) {\n<30> set_num_731 ( buff , SYSTEM_AREA_BLOCK ) ;\n<36> memset ( buff + 16 , 0 , 40 ) ;
<1> static void dumpcffnames ( SplineFont * sf , FILE * cfff ) {\n<5> putc ( '\1' , cfff ) ;\n<6> putc ( '\1' + strlen ( sf -> fontname ) , cfff ) ;\n<7> for ( pt = sf -> fontname ;\n<9> ++ pt ) putc ( * pt , cfff ) ;
<1> void cpu_reset(CPUX86State *env)\n<4> memset(env, 0, offsetof(CPUX86State, breakpoints));\n<5> tlb_flush(env, 1);\n<31> cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffff,\n<41> memset(env->dr, 0, sizeof(env->dr));\n<44> cpu_breakpoint_remove_all(env, BP_CPU);
<19> for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n<27> memcpy(s->dest[0], s->last_picture.f.data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);\n<29> memcpy(s->dest[1], s->last_picture.f.data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n<31> memcpy(s->dest[2], s->last_picture.f.data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);
<1> SRP_user_pwd * SRP_VBASE_get1_by_user ( SRP_VBASE * vb , char * username ) {\n<7> if ( ( user = find_user ( vb , username ) ) != NULL ) return srp_user_pwd_dup ( user ) ;\n<8> if ( ( vb -> seed_key == NULL ) || ( vb -> default_g == NULL ) || ( vb -> default_N == NULL ) ) return NULL ;\n<11> if ( ! SRP_user_pwd_set_ids ( user , username , NULL ) ) goto err ;\n<12> if ( RAND_pseudo_bytes ( digv , SHA_DIGEST_LENGTH ) < 0 ) goto err ;\n<13> EVP_MD_CTX_init ( & ctxt ) ;\n<14> EVP_DigestInit_ex ( & ctxt , EVP_sha1 ( ) , NULL ) ;\n<15> EVP_DigestUpdate ( & ctxt , vb -> seed_key , strlen ( vb -> seed_key ) ) ;\n<16> EVP_DigestUpdate ( & ctxt , username , strlen ( username ) ) ;\n<17> EVP_DigestFinal_ex ( & ctxt , digs , NULL ) ;\n<18> EVP_MD_CTX_cleanup ( & ctxt ) ;
<1> static struct mspack_file * mspack_fmap_open ( struct mspack_system * self , const char * filename , int mode ) {\n<7> if ( ! filename ) {\n<11> mspack_handle = malloc ( sizeof ( * mspack_handle ) ) ;\n<12> if ( ! mspack_handle ) {\n<16> switch ( mode ) {\n<32> mspack_handle -> type = FILETYPE_FILENAME ;\n<34> if ( ! mspack_handle -> f ) {\n<41> out_err : free ( mspack_handle ) ;
<1> static int gif_read_header1(GifState *s)\n<17> ret = get_buffer(f, sig, 6);\n<19> if (ret != 6)\n<23> if (memcmp(sig, gif87a_sig, 6) != 0 &&\n<25> memcmp(sig, gif89a_sig, 6) != 0)\n<27> return -1;\n<33> s->transparent_color_index = -1;\n<35> s->screen_width = get_le16(f);\n<37> s->screen_height = get_le16(f);\n<39> if(   (unsigned)s->screen_width  > 32767
<1> void init_rl(RLTable *rl)\n<5> int8_t max_level[MAX_RUN+1], max_run[MAX_LEVEL+1];\n<7> uint8_t index_run[MAX_RUN+1];\n<15> for(last=0;last<2;last++) {\n<27> end = rl->n;\n<33> memset(max_level, 0, MAX_RUN + 1);\n<35> memset(max_run, 0, MAX_LEVEL + 1);\n<37> memset(index_run, rl->n, MAX_RUN + 1);\n<45> if (index_run[run] == rl->n)\n<47> index_run[run] = i;\n<49> if (level > max_level[run])\n<51> max_level[run] = level;\n<53> if (run > max_run[level])\n<55> max_run[level] = run;\n<59> rl->max_level[last] = av_malloc(MAX_RUN + 1);\n<61> memcpy(rl->max_level[last], max_level, MAX_RUN + 1);\n<63> rl->max_run[last] = av_malloc(MAX_LEVEL + 1);\n<65> memcpy(rl->max_run[last], max_run, MAX_LEVEL + 1);\n<67> rl->index_run[last] = av_malloc(MAX_RUN + 1);\n<69> memcpy(rl->index_run[last], index_run, MAX_RUN + 1);
<1> static void set_environment ( struct passwd * pw ) {\n<3> if ( change_environment && fakelogin ) {\n<4> cp = getenv ( "TERM" ) ;\n<5> if ( NULL != cp ) {\n<8> cp = getenv ( "COLORTERM" ) ;\n<9> if ( NULL != cp ) {\n<14> addenv ( ( '/' == * cp ) ? tz ( cp ) : cp , NULL ) ;\n<24> cp = getenv ( "XAUTHORITY" ) ;\n<25> if ( NULL != cp ) {\n<37> if ( NULL == cp ) {\n<38> addenv ( ( pw -> pw_uid == 0 ) ? "PATH=/sbin:/bin:/usr/sbin:/usr/bin" : "PATH=/bin:/usr/bin" , NULL ) ;\n<40> else if ( strchr ( cp , '=' ) != NULL ) {\n<41> addenv ( cp , NULL ) ;\n<44> addenv ( "PATH" , cp ) ;\n<46> if ( getenv ( "IFS" ) != NULL ) {\n<47> addenv ( "IFS= \t\n" , NULL ) ;\n<62> if ( shellstr != pw -> pw_shell ) {\n<63> free ( pw -> pw_shell ) ;
<6> code = gs_main_init2aux ( minst ) ;\n<21> else if ( minst -> saved_pages_initial_arg != NULL ) {\n<22> if ( dev_proc ( pdev , dev_spec_op ) ( pdev , gxdso_supports_saved_pages , NULL , 0 ) <= 0 ) {\n<26> code = gx_saved_pages_param_process ( ppdev , ( byte * ) minst -> saved_pages_initial_arg , strlen ( minst -> saved_pages_initial_arg ) ) ;\n<30> if ( gs_debug_c ( ':' ) ) print_resource_usage ( minst , & gs_imemory , "Start" ) ;
<1> void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) {\n<7> * outbuffer = '\0' ;\n<8> if ( ( ! ( s1 ) || ( * ( s1 ) == '\0' ) ) ) {\n<40> s -> append_char ( s , 0 ) ;\n<41> strncpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;
<1> static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,\n<17> s->compute_mse(s, (const uint8_t **)main->data, main->linesize,\n<53> set_meta(metadata, "lavfi.psnr.psnr.", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));\n<63> if (s->stats_file) {\n<67> for (j = 0; j < s->nb_components; j++) {\n<71> fprintf(s->stats_file, "mse_%c:%0.2f ", s->comps[j], comp_mse[c]);\n<75> for (j = 0; j < s->nb_components; j++) {\n<79> fprintf(s->stats_file, "psnr_%c:%0.2f ", s->comps[j],\n<81> get_psnr(comp_mse[c], 1, s->max[c]));\n<85> fprintf(s->stats_file, "\n");
<1> static uint8_t checkBaseExtUnicode ( UCMStates * baseStates , UCMTable * base , UCMTable * ext , UBool moveToExt , UBool intersectBase ) {\n<43> if ( moveToExt ) {\n<48> fprintf ( stderr , "ucm error: the base table contains a mapping whose input sequence\n" " is a prefix of the input sequence of an extension mapping\n" ) ;\n<49> ucm_printMapping ( base , mb , stderr ) ;\n<50> ucm_printMapping ( ext , me , stderr ) ;\n<61> else if ( intersectBase ) {\n<66> fprintf ( stderr , "ucm error: the base table contains a mapping whose input sequence\n" " is the same as the input sequence of an extension mapping\n" " but it maps differently\n" ) ;\n<67> ucm_printMapping ( base , mb , stderr ) ;\n<68> ucm_printMapping ( ext , me , stderr ) ;
<1> void monitor_vprintf(Monitor *mon, const char *fmt, va_list ap)\n<15> if (monitor_ctrl_mode(mon)) {\n<23> vsnprintf(buf, sizeof(buf), fmt, ap);\n<25> monitor_puts(mon, buf);
<1> static void compact_print_str ( WriterContext * wctx , const char * key , const char * value ) {\n<2> CompactContext * compact = wctx -> priv ;\n<4> if ( wctx -> nb_item [ wctx -> level ] ) printf ( "%c" , compact -> item_sep ) ;\n<5> if ( ! compact -> nokey ) printf ( "%s%s=" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ;\n<7> printf ( "%s" , compact -> escape_str ( & buf , value , compact -> item_sep , wctx ) ) ;
<1> int keyring_register_filename ( const char * fname , int read_only , void * * ptr ) {\n<5> kr ;\n<7> if ( same_file_p ( kr -> fname , fname ) ) {\n<13> kr = xmalloc ( sizeof * kr + strlen ( fname ) ) ;\n<14> strcpy ( kr -> fname , fname ) ;\n<20> kr_names = kr ;\n<22> * ptr = kr ;
<1> static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n<5> if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n<6> return ENOMEM ;\n<8> memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n<9> for ( i = 0 ;\n<10> i < ( 2 << 20 ) ;\n<17> buf [ i + j ] = j + off ;\n<20> if ( SIZEOF_XOFF_T == 4 ) {\n<21> ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;\n<35> fail : free ( buf ) ;\n<36> return ret ;
<1> int ff_rate_control_init(MpegEncContext *s)\n<139> p= s->avctx->stats_in;\n<141> for(i=-1; p; i++){\n<143> p= strchr(p+1, ';');\n<165> rce->pict_type= rce->new_pict_type=FF_P_TYPE;\n<167> rce->qscale= rce->new_qscale=FF_QP2LAMBDA * 2;\n<169> rce->misc_bits= s->mb_num + 10;\n<171> rce->mb_var_sum= s->mb_num*100;\n<179> p= s->avctx->stats_in;\n<181> for(i=0; i<rcc->num_entries - s->max_b_frames; i++){\n<193> next= strchr(p, ';');\n<199> next++;\n<203> e= sscanf(p, " in:%d ", &picture_number);\n<207> assert(picture_number >= 0);\n<209> assert(picture_number < rcc->num_entries);\n<211> rce= &rcc->entry[picture_number];\n<215> e+=sscanf(p, " in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d",\n<221> if(e!=14){\n<231> p= next;\n<309> rce.new_pict_type= rce.pict_type;\n<347> rcc->i_cplx_sum [rce.pict_type] += rce.i_tex_bits*rce.qscale;\n<349> rcc->p_cplx_sum [rce.pict_type] += rce.p_tex_bits*rce.qscale;\n<361> q= get_qscale(s, &rce, rcc->pass1_wanted_bits/rcc->pass1_rc_eq_output_sum, i);
<1> void  pp_postprocess(const uint8_t * src[3], const int srcStride[3],\n<159> if (!(src[1] && src[2] && dst[1] && dst[2]))\n<165> width  = (width )>>c->hChromaSubSample;\n<193> for(y=0; y<height; y++){\n<195> memcpy(&(dst[1][y*dstStride[1]]), &(src[1][y*srcStride[1]]), width);\n<197> memcpy(&(dst[2][y*dstStride[2]]), &(src[2][y*srcStride[2]]), width);
<1> static void test_long_data_str1 ( ) {\n<23> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> my_bind [ 0 ] . buffer = data ;\n<25> my_bind [ 0 ] . buffer_length = sizeof ( data ) ;\n<26> my_bind [ 0 ] . length = & length1 ;\n<27> my_bind [ 0 ] . buffer_type = MYSQL_TYPE_STRING ;\n<29> my_bind [ 1 ] = my_bind [ 0 ] ;\n<31> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<33> length = sprintf ( data , "MySQL AB" ) ;\n<37> rc = mysql_stmt_send_long_data ( stmt , 0 , data , length ) ;\n<39> rc = mysql_stmt_send_long_data ( stmt , 1 , data , 2 ) ;\n<42> rc = mysql_stmt_execute ( stmt ) ;\n<43> if ( ! opt_silent ) fprintf ( stdout , " mysql_stmt_execute() returned %d\n" , rc ) ;\n<44> check_execute ( stmt , rc ) ;\n<58> sprintf ( data , "%ld" , ( long ) i * length ) ;\n<59> verify_col_data ( "test_long_data_str" , "length(longstr)" , data ) ;\n<60> sprintf ( data , "%d" , i * 2 ) ;\n<61> verify_col_data ( "test_long_data_str" , "length(blb)" , data ) ;\n<82> memset ( my_bind , 0 , sizeof ( * my_bind ) ) ;\n<88> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<89> data [ 16 ] = 0 ;\n<93> DIE_UNLESS ( strlen ( data ) == 16 ) ;\n<94> DIE_UNLESS ( blob_length == max_blob_length ) ;\n<95> memset ( ( my_bind + 1 ) , 0 , sizeof ( * my_bind ) ) ;\n<97> my_bind [ 1 ] . buffer = ( void * ) & data ;\n<100> memset ( data , 0 , sizeof ( data ) ) ;\n<101> mysql_stmt_fetch_column ( stmt , my_bind + 1 , 0 , 0 ) ;\n<102> DIE_UNLESS ( strlen ( data ) == max_blob_length ) ;
<1> int ssl3_send_finished ( SSL * s , int a , int b , const char * sender , int slen ) {\n<7> p = & ( d [ 4 ] ) ;\n<8> i = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . finish_md ) ;\n<9> if ( i == 0 ) return 0 ;\n<11> memcpy ( p , s -> s3 -> tmp . finish_md , i ) ;\n<12> p += i ;\n<13> l = i ;\n<14> if ( s -> type == SSL_ST_CONNECT ) {\n<15> OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n<16> memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . finish_md , i ) ;\n<17> s -> s3 -> previous_client_finished_len = i ;\n<20> OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n<21> memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . finish_md , i ) ;\n<22> s -> s3 -> previous_server_finished_len = i ;
<1> static int get_max_name_length ( GFile * file_dir ) {\n<14> max_path = pathconf ( dir , _PC_PATH_MAX ) ;\n<15> max_name = pathconf ( dir , _PC_NAME_MAX ) ;\n<16> if ( max_name == - 1 && max_path == - 1 ) {\n<19> else if ( max_name == - 1 && max_path != - 1 ) {\n<20> max_length = max_path - ( strlen ( dir ) + 1 ) ;\n<22> else if ( max_name != - 1 && max_path == - 1 ) {\n<27> leftover = max_path - ( strlen ( dir ) + 1 ) ;\n<28> max_length = MIN ( leftover , max_name ) ;\n<30> g_free ( dir ) ;\n<31> return max_length ;
<1> static uint dump_routines_for_db ( char * db ) {\n<15> DBUG_PRINT ( "enter" , ( "db: '%s'" , db ) ) ;\n<16> mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n<17> print_comment ( sql_file , 0 , "\n--\n-- Dumping routines for database '%s'\n--\n" , fix_for_comment ( db ) ) ;\n<21> if ( opt_xml ) fputs ( "\t<routines>\n" , sql_file ) ;\n<33> while ( ( row = mysql_fetch_row ( routine_res ) ) ) {\n<34> DBUG_PRINT ( "info" , ( "length of body for %s row[2] '%s' is %zu" , routine_name , row [ 2 ] ? row [ 2 ] : "(null)" , row [ 2 ] ? strlen ( row [ 2 ] ) : 0 ) ) ;\n<35> if ( row [ 2 ] == NULL ) {\n<36> print_comment ( sql_file , 1 , "\n-- insufficient privileges to %s\n" , query_buff ) ;\n<37> print_comment ( sql_file , 1 , "-- does %s have permissions on mysql.proc?\n\n" , current_user ) ;\n<40> else if ( strlen ( row [ 2 ] ) ) {\n<41> if ( opt_xml ) {\n<42> if ( i ) print_xml_row ( sql_file , "routine" , routine_res , & row , "Create Procedure" ) ;\n<43> else print_xml_row ( sql_file , "routine" , routine_res , & row , "Create Function" ) ;\n<57> fprintf ( sql_file , "--\n" "-- WARNING: old server version. " "The following dump may be incomplete.\n" "--\n" ) ;\n<63> \n" "%s ;
<1> static ssize_t mipsnet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n<5> MIPSnetState *s = qemu_get_nic_opaque(nc);\n<9> trace_mipsnet_receive(size);\n<29> memcpy(s->rx_buffer, buf, size);\n<33> s->rx_count = size;\n<43> mipsnet_update_irq(s);\n<47> return size;
<1> static int _warc_cleanup ( struct archive_read * a ) {\n<2> struct warc_s * w = a -> format -> data ;\n<3> if ( w -> pool . len > 0U ) {\n<4> free ( w -> pool . str ) ;\n<7> free ( w ) ;
<1> void av_image_copy_plane ( uint8_t * dst , int dst_linesize , const uint8_t * src , int src_linesize , int bytewidth , int height ) {\n<2> if ( ! dst || ! src ) return ;\n<4> height > 0 ;\n<6> memcpy ( dst , src , bytewidth ) ;\n<7> dst += dst_linesize ;\n<8> src += src_linesize ;
<1> int encode_offset ( char * string , struct filter_op * fop ) {\n<4> memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n<5> str = strdup ( string ) ;\n<6> p = ec_strtok ( str , "." , & tok ) ;
<1> static int32_t scsi_send_command(SCSIDevice *d, uint32_t tag,\n<45> outbuf = r->dma_buf;\n<133> switch (command) {\n<145> if (len < 4)\n<149> memset(outbuf, 0, 4);\n<193> switch (page_code) {\n<303> int id_len = strlen(bdrv_get_device_name(s->bdrv));\n<305> if (id_len > max_len)\n<307> id_len = max_len;\n<349> bdrv_get_device_name(s->bdrv), id_len);\n<351> r->buf_len += id_len;\n<391> if (len < 5) {\n<413> memset(outbuf, 0, 36);\n<421> } else if (bdrv_get_type_hint(s->bdrv) == BDRV_TYPE_CDROM) {\n<427> memcpy(&outbuf[16], "QEMU CD-ROM    ", 16);\n<433> memcpy(&outbuf[16], "QEMU HARDDISK  ", 16);\n<437> memcpy(&outbuf[8], "QEMU   ", 8);\n<439> memcpy(&outbuf[32], QEMU_VERSION, 4);\n<495> p = outbuf;\n<497> memset(p, 0, 4);\n<509> p += 4;\n<649> } else if ((page == 8 || page == 0x3f)) {\n<653> memset(p,0,20);\n<661> p += 20;\n<757> memset(outbuf, 0, 8);\n<847> switch(format) {\n<861> memset(outbuf, 0, 12);\n<907> memset(outbuf, 0, 8);\n<943> if (len < 16)\n<947> memset(outbuf, 0, 16);
<1> void process_incoming_migration(QEMUFile *f)\n<3> if (qemu_loadvm_state(f) < 0) {\n<4> fprintf(stderr, "load of migration failed\n");
<1> static int rd_strip(CinepakEncContext *s, int y, int h, int keyframe, AVPicture *last_pict, AVPicture *pict, AVPicture *scratch_pict, unsigned char *buf, int64_t *best_score)\n<19> calculate_skip_errors(s, h, last_pict, pict, &info);\n<29> quantize(s, h, pict, 0, v4_size, v4, &info);\n<43> quantize(s, h, pict, 1, v1_size, -1, &info);\n<71> score = calculate_mode_score(s, mode, h, v1_size, v4_size, v4, &info);\n<105> write_strip_header(s, y, h, keyframe, s->strip_buf, best_size);\n<161> best_size += STRIP_HEADER_SIZE;\n<163> memcpy(buf, s->strip_buf, best_size);\n<169> return best_size;
<1> static void test_bug6096 ( ) {\n<12> stmt_text = "drop table if exists t1" ;\n<13> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<15> mysql_query ( mysql , "set sql_mode=''" ) ;\n<16> stmt_text = "create table t1 (c_tinyint tinyint, c_smallint smallint, " " c_mediumint mediumint, c_int int, " " c_bigint bigint, c_float float, " " c_double double, c_varchar varchar(20), " " c_char char(20), c_time time, c_date date, " " c_datetime datetime)" ;\n<17> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<19> stmt_text = "insert into t1 values (-100, -20000, 30000000, 4, 8, 1.0, " "2.0, 'abc', 'def', now(), now(), now())" ;\n<20> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<22> stmt_text = "select * from t1" ;\n<23> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<25> query_result = mysql_store_result ( mysql ) ;\n<28> stmt = mysql_stmt_init ( mysql ) ;\n<29> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<30> check_execute ( stmt , rc ) ;\n<39> if ( ! opt_silent ) {\n<40> printf ( " ------------------------------------------------------------\n" ) ;\n<41> printf ( " | Metadata \n" ) ;\n<42> printf ( " ------------------------------------------------------------\n" ) ;\n<43> printf ( " | Query | Prepared statement \n" ) ;\n<44> printf ( " ------------------------------------------------------------\n" ) ;\n<45> printf ( " field name | length | max_length | length | max_length\n" ) ;\n<46> printf ( " ------------------------------------------------------------\n" ) ;\n<48> i < query_field_count ;\n<50> MYSQL_FIELD * f1 = & query_field_list [ i ] , * f2 = & stmt_field_list [ i ] ;\n<51> printf ( " %-11s | %9lu | %10lu | %9lu | %10lu \n" , f1 -> name , f1 -> length , f1 -> max_length , f2 -> length , f2 -> max_length ) ;\n<52> DIE_UNLESS ( f1 -> length == f2 -> length ) ;\n<54> printf ( " ---------------------------------------------------------------\n" ) ;\n<56> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<58> i < stmt_field_count ;\n<61> my_bind [ i ] . buffer_length = stmt_field_list [ i ] . max_length + 1 ;\n<62> my_bind [ i ] . buffer = malloc ( my_bind [ i ] . buffer_length ) ;\n<64> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<70> i < stmt_field_count ;\n<71> ++ i ) free ( my_bind [ i ] . buffer ) ;\n<75> stmt_text = "drop table t1" ;\n<76> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> relpRetVal relpTcpDestruct ( relpTcp_t * * ppThis ) {\n<8> RELPOBJ_assert ( pThis , Tcp ) ;\n<9> if ( pThis -> sock != - 1 ) {\n<11> pThis -> sock = - 1 ;\n<13> if ( pThis -> socks != NULL ) {\n<15> i <= pThis -> socks [ 0 ] ;\n<16> ++ i ) close ( pThis -> socks [ i ] ) ;\n<17> free ( pThis -> socks ) ;\n<28> free ( pThis -> pRemHostName ) ;\n<29> free ( pThis -> pristring ) ;\n<30> free ( pThis -> caCertFile ) ;\n<31> free ( pThis -> ownCertFile ) ;\n<32> free ( pThis -> privKeyFile ) ;\n<33> free ( pThis ) ;
<1> static int tunnel ( int tun_fd , int dns_fd , int bind_fd , int max_idle_time ) {\n<46> if ( last_action + max_idle_time < time ( NULL ) ) {\n<47> fprintf ( stderr , "Idling since too long, shutting down...\n" ) ;
<1> static krb5_error_code kadm5_copy_principal ( krb5_context context , krb5_const_principal inprinc , krb5_principal * outprinc ) {\n<19> if ( ( ( krb5_princ_component ( context , tempprinc , i ) -> data = krb5_db_alloc ( context , NULL , len ) ) == 0 ) && len ) {\n<25> if ( len ) memcpy ( krb5_princ_component ( context , tempprinc , i ) -> data , krb5_princ_component ( context , inprinc , i ) -> data , len ) ;\n<29> if ( ! tempprinc -> realm . data && tempprinc -> realm . length ) {\n<32> i ++ ) krb5_db_free ( context , krb5_princ_component ( context , tempprinc , i ) -> data ) ;\n<37> if ( tempprinc -> realm . length ) memcpy ( tempprinc -> realm . data , inprinc -> realm . data , inprinc -> realm . length ) ;
<1> static void test_acpi_q35_tcg_cphp(void)\n<9> memset(&data, 0, sizeof(data));\n<15> test_acpi_one(" -smp 2,cores=3,sockets=2,maxcpus=6",\n<19> free_test_data(&data);
<1> static int validate_header ( const struct evkeyvalq * headers , const char * key , const char * value ) {\n<3> if ( real_val == NULL ) return ( - 1 ) ;\n<4> if ( strcmp ( real_val , value ) != 0 ) return ( - 1 ) ;\n<5> return ( 0 ) ;
<1> static void passphrase_free ( char * ppbuff ) {\n<2> if ( ppbuff != NULL ) {\n<3> memset ( ppbuff , 0 , PPBUFF_SIZE ) ;\n<4> free ( ppbuff ) ;
<1> static void musicpal_init(ram_addr_t ram_size,\n<53> if (!env) {\n<55> fprintf(stderr, "Unable to find CPU definition\n");\n<123> if (flash_size != 8*1024*1024 && flash_size != 16*1024*1024 &&\n<127> fprintf(stderr, "Invalid flash image size\n");
<1> static int decode_subframe ( TAKDecContext * s , int32_t * decoded , int subframe_size , int prev_subframe_size ) {\n<6> memset ( filter , 0 , MAX_PREDICTORS * sizeof ( * filter ) ) ;\n<30> decode_filter_coeffs ( s , filter_order , size , filter_quant , filter ) ;\n<31> if ( ( ret = decode_residues ( s , & decoded [ filter_order ] , subframe_size - filter_order ) ) < 0 ) return ret ;\n<32> av_fast_malloc ( & s -> residues , & s -> residues_buf_size , FFALIGN ( subframe_size + 16 , 16 ) * sizeof ( * s -> residues ) ) ;\n<33> if ( ! s -> residues ) return AVERROR ( ENOMEM ) ;\n<34> memset ( s -> residues , 0 , s -> residues_buf_size ) ;\n<42> v += s -> dsp . scalarproduct_int16 ( & s -> residues [ i ] , filter , FFALIGN ( filter_order , 16 ) ) ;
<1> static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)\n<49> name = buf + 40;\n<51> if (name_size >= filename_size &&\n<53> !memcmp(name, filename, filename_size) &&\n<55> (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))
<1> static void *postcopy_ram_fault_thread(void *opaque)\n<55> if (poll(pfd, 2, -1 /* Wait forever */) == -1) {\n<57> error_report("%s: userfault poll: %s", __func__, strerror(errno));\n<79> if (errno == EAGAIN) {\n<93> if (ret < 0) {\n<95> error_report("%s: Failed to read full userfault message: %s",\n<97> __func__, strerror(errno));
<1> void simplestring_add ( simplestring * target , const char * source ) {\n<2> if ( target && source ) {\n<3> simplestring_addn ( target , source , strlen ( source ) ) ;
<1> PHP_FUNCTION ( locale_filter_matches ) {\n<2> char * lang_tag = NULL ;\n<4> const char * loc_range = NULL ;\n<21> loc_range = intl_locale_get_default ( TSRMLS_C ) ;\n<23> if ( strcmp ( loc_range , "*" ) == 0 ) {\n<26> if ( boolCanonical ) {\n<27> can_loc_range = get_icu_value_internal ( loc_range , LOC_CANONICALIZE_TAG , & result , 0 ) ;\n<32> can_lang_tag = get_icu_value_internal ( lang_tag , LOC_CANONICALIZE_TAG , & result , 0 ) ;\n<37> cur_lang_tag = ecalloc ( 1 , strlen ( can_lang_tag ) + 1 ) ;\n<38> result = strToMatch ( can_lang_tag , cur_lang_tag ) ;\n<40> efree ( cur_lang_tag ) ;\n<44> cur_loc_range = ecalloc ( 1 , strlen ( can_loc_range ) + 1 ) ;\n<45> result = strToMatch ( can_loc_range , cur_loc_range ) ;\n<47> efree ( cur_lang_tag ) ;\n<49> efree ( cur_loc_range ) ;\n<53> token = strstr ( cur_lang_tag , cur_loc_range ) ;\n<54> if ( token && ( token == cur_lang_tag ) ) {\n<55> chrcheck = token + ( strlen ( cur_loc_range ) ) ;\n<58> efree ( cur_lang_tag ) ;\n<61> efree ( cur_loc_range ) ;\n<73> efree ( cur_lang_tag ) ;\n<76> efree ( cur_loc_range ) ;\n<87> cur_lang_tag = ecalloc ( 1 , strlen ( lang_tag ) + 1 ) ;\n<88> result = strToMatch ( lang_tag , cur_lang_tag ) ;\n<90> efree ( cur_lang_tag ) ;\n<93> cur_loc_range = ecalloc ( 1 , strlen ( loc_range ) + 1 ) ;\n<94> result = strToMatch ( loc_range , cur_loc_range ) ;\n<96> efree ( cur_lang_tag ) ;\n<97> efree ( cur_loc_range ) ;\n<100> token = strstr ( cur_lang_tag , cur_loc_range ) ;\n<101> if ( token && ( token == cur_lang_tag ) ) {\n<102> chrcheck = token + ( strlen ( cur_loc_range ) ) ;\n<105> efree ( cur_lang_tag ) ;\n<108> efree ( cur_loc_range ) ;\n<114> efree ( cur_lang_tag ) ;\n<117> efree ( cur_loc_range ) ;
<1> static void omap_i2c_recv(I2CAdapter *i2c, uint8_t addr,\n<3> uint8_t *buf, uint16_t len)\n<53> memread(s->addr + OMAP_I2C_STAT, &data, 2);\n<55> g_assert((data & OMAP_I2C_STAT_RRDY) != 0);\n<57> g_assert((data & OMAP_I2C_STAT_ROVR) == 0);\n<61> memread(s->addr + OMAP_I2C_DATA, &data, 2);\n<67> if (unlikely(len == 1)) {\n<69> *buf = data & 0xf;\n<71> buf++;\n<77> memcpy(buf, &data, 2);\n<79> buf += 2;\n<89> memread(s->addr + OMAP_I2C_CON, &data, 2);\n<91> g_assert((data & OMAP_I2C_CON_STP) == 0);
<1> gcry_error_t gcry_sexp_create ( gcry_sexp_t * retsexp , void * buffer , size_t length , int autodetect , void ( * freefnc ) ( void * ) ) {\n<6> if ( autodetect < 0 || autodetect > 1 || ! buffer ) return gcry_error ( GPG_ERR_INV_ARG ) ;\n<11> else if ( ! length && autodetect ) {\n<12> length = strlen ( ( char * ) buffer ) ;\n<14> errcode = sexp_sscan ( & se , NULL , buffer , length , 0 , NULL ) ;
<1> int ffio_ensure_seekback(AVIOContext *s, int64_t buf_size)\n<17> buf_size += s->buf_ptr - s->buffer + max_buffer_size;\n<21> if (buf_size < filled || s->seekable || !s->read_packet)\n<31> if (!buffer)\n<37> memcpy(buffer, s->buffer, filled);\n<39> av_free(s->buffer);\n<41> s->buf_ptr = buffer + (s->buf_ptr - s->buffer);\n<43> s->buf_end = buffer + (s->buf_end - s->buffer);\n<45> s->buffer = buffer;
<1> static slurm_addr_t * _build_node_addr ( char * node_list , uint32_t node_cnt , uint32_t pack_job_id ) {\n<6> int error_code = SLURM_SUCCESS , node_inx = 0 ;\n<11> node_addr = xmalloc ( sizeof ( slurm_addr_t ) * node_cnt ) ;\n<12> while ( ( this_node_name = hostlist_shift ( host_list ) ) ) {\n<13> if ( ( node_ptr = find_node_record ( this_node_name ) ) ) {\n<14> memcpy ( node_addr + node_inx , & node_ptr -> slurm_addr , sizeof ( slurm_addr_t ) ) ;\n<15> node_inx ++ ;\n<18> error ( "%s: Invalid node %s in pack job %u" , __func__ , this_node_name , pack_job_id ) ;\n<21> free ( this_node_name ) ;
<1> static void draw_bar(TestSourceContext *test, const uint8_t color[4],\n<33> for (plane = 0; frame->data[plane]; plane++) {\n<35> const int c = color[plane];\n<47> pw = w >> desc->log2_chroma_w;\n<57> pw = w;\n<67> p0 = p = frame->data[plane] + py * linesize + px;\n<69> memset(p, c, pw);\n<71> p += linesize;\n<73> for (i = 1; i < ph; i++, p += linesize)\n<75> memcpy(p, p0, pw);
<1> av_cold void ff_dsputil_init(DSPContext* c, AVCodecContext *avctx)\n<485> memset(c->put_2tap_qpel_pixels_tab, 0, sizeof(c->put_2tap_qpel_pixels_tab));\n<487> memset(c->avg_2tap_qpel_pixels_tab, 0, sizeof(c->avg_2tap_qpel_pixels_tab));\n<671> if (HAVE_MMX)        ff_dsputil_init_mmx   (c, avctx);\n<673> if (ARCH_ARM)        ff_dsputil_init_arm   (c, avctx);\n<675> if (HAVE_VIS)        ff_dsputil_init_vis   (c, avctx);\n<677> if (ARCH_ALPHA)      ff_dsputil_init_alpha (c, avctx);\n<679> if (ARCH_PPC)        ff_dsputil_init_ppc   (c, avctx);\n<681> if (HAVE_MMI)        ff_dsputil_init_mmi   (c, avctx);\n<683> if (ARCH_SH4)        ff_dsputil_init_sh4   (c, avctx);\n<685> if (ARCH_BFIN)       ff_dsputil_init_bfin  (c, avctx);
<1> static char * prepare_word_match ( const byte * name ) {\n<4> p = pattern = xmalloc ( strlen ( name ) + 1 ) ;\n<6> while ( * name && ! word_match_chars [ * name ] ) name ++ ;\n<9> name ++ ) * p ++ = c ;\n<10> * p ++ = ' ' ;\n<14> return pattern ;
<1> static void compactToUnicodeHelper ( UCMStates * states , uint16_t * unicodeCodeUnits , _MBCSToUFallback * toUFallbacks , int32_t countToUFallbacks ) {\n<7> savings = findUnassigned ( states , unicodeCodeUnits , toUFallbacks , countToUFallbacks , state , 0 , 0 ) ;\n<8> if ( savings > 0 ) {\n<9> printf ( " all-unassigned sequences from initial state %ld use %ld bytes\n" , ( long ) state , ( long ) savings ) ;
<1> static void read_mru_list ( struct recvbuf * rbufp , int restrict_mask ) {\n<10> const char resaxx_fmt [ ] = "0x%hx" ;\n<43> in_parms = NULL ;\n<44> set_var ( & in_parms , nonce_text , sizeof ( nonce_text ) , 0 ) ;\n<45> set_var ( & in_parms , frags_text , sizeof ( frags_text ) , 0 ) ;\n<46> set_var ( & in_parms , limit_text , sizeof ( limit_text ) , 0 ) ;\n<47> set_var ( & in_parms , mincount_text , sizeof ( mincount_text ) , 0 ) ;\n<48> set_var ( & in_parms , resall_text , sizeof ( resall_text ) , 0 ) ;\n<49> set_var ( & in_parms , resany_text , sizeof ( resany_text ) , 0 ) ;\n<50> set_var ( & in_parms , maxlstint_text , sizeof ( maxlstint_text ) , 0 ) ;\n<51> set_var ( & in_parms , laddr_text , sizeof ( laddr_text ) , 0 ) ;\n<53> i < COUNTOF ( last ) ;\n<55> snprintf ( buf , sizeof ( buf ) , last_fmt , ( int ) i ) ;\n<56> set_var ( & in_parms , buf , strlen ( buf ) + 1 , 0 ) ;\n<57> snprintf ( buf , sizeof ( buf ) , addr_fmt , ( int ) i ) ;\n<58> set_var ( & in_parms , buf , strlen ( buf ) + 1 , 0 ) ;\n<61> frags = 0 ;\n<62> limit = 0 ;\n<63> mincount = 0 ;\n<64> resall = 0 ;\n<65> resany = 0 ;\n<66> maxlstint = 0 ;\n<71> while ( NULL != ( v = ctl_getitem ( in_parms , & val ) ) && ! ( EOV & v -> flags ) ) {\n<73> if ( ! strcmp ( nonce_text , v -> text ) ) {\n<74> if ( NULL != pnonce ) free ( pnonce ) ;\n<75> pnonce = estrdup ( val ) ;\n<77> else if ( ! strcmp ( frags_text , v -> text ) ) {\n<78> sscanf ( val , "%hu" , & frags ) ;\n<80> else if ( ! strcmp ( limit_text , v -> text ) ) {\n<81> sscanf ( val , "%u" , & limit ) ;\n<83> else if ( ! strcmp ( mincount_text , v -> text ) ) {\n<84> if ( 1 != sscanf ( val , "%d" , & mincount ) || mincount < 0 ) mincount = 0 ;\n<86> else if ( ! strcmp ( resall_text , v -> text ) ) {\n<87> sscanf ( val , resaxx_fmt , & resall ) ;\n<89> else if ( ! strcmp ( resany_text , v -> text ) ) {\n<90> sscanf ( val , resaxx_fmt , & resany ) ;\n<92> else if ( ! strcmp ( maxlstint_text , v -> text ) ) {\n<93> sscanf ( val , "%u" , & maxlstint ) ;\n<95> else if ( ! strcmp ( laddr_text , v -> text ) ) {\n<96> if ( decodenetnum ( val , & laddr ) ) lcladr = getinterface ( & laddr , 0 ) ;\n<98> else if ( 1 == sscanf ( v -> text , last_fmt , & si ) && ( size_t ) si < COUNTOF ( last ) ) {\n<99> if ( 2 == sscanf ( val , "0x%08x.%08x" , & ui , & uf ) ) {\n<100> last [ si ] . l_ui = ui ;\n<101> last [ si ] . l_uf = uf ;\n<102> if ( ! SOCK_UNSPEC ( & addr [ si ] ) && si == priors ) priors ++ ;\n<105> else if ( 1 == sscanf ( v -> text , addr_fmt , & si ) && ( size_t ) si < COUNTOF ( addr ) ) {\n<106> if ( decodenetnum ( val , & addr [ si ] ) && last [ si ] . l_ui && last [ si ] . l_uf && si == priors ) priors ++ ;\n<109> free_varlist ( in_parms ) ;\n<111> if ( NULL == pnonce ) return ;\n<112> nonce_valid = validate_nonce ( pnonce , rbufp ) ;\n<113> free ( pnonce ) ;\n<115> if ( ( 0 == frags && ! ( 0 < limit && limit <= MRU_ROW_LIMIT ) ) || frags > MRU_FRAGS_LIMIT ) {\n<119> if ( 0 != frags && 0 == limit ) limit = UINT_MAX ;\n<120> else if ( 0 != limit && 0 == frags ) frags = MRU_FRAGS_LIMIT ;\n<134> if ( priors ) {\n<135> if ( NULL == mon ) {\n<140> pch = sptoa ( & mon -> rmtadr ) ;\n<141> ctl_putunqstr ( "addr.older" , pch , strlen ( pch ) ) ;\n<142> if ( limit > 1 ) mon = PREV_DLIST ( mon_mru_list , mon , mru ) ;\n<148> generate_nonce ( rbufp , buf , sizeof ( buf ) ) ;\n<149> ctl_putunqstr ( "nonce" , buf , strlen ( buf ) ) ;\n<152> mon != NULL && res_frags < frags && count < limit ;\n<154> if ( mon -> count < mincount ) continue ;\n<155> if ( resall && resall != ( resall & mon -> flags ) ) continue ;\n<156> if ( resany && ! ( resany & mon -> flags ) ) continue ;\n<157> if ( maxlstint > 0 && now . l_ui - mon -> last . l_ui > maxlstint ) continue ;
<1> static int smacker_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> SmackerContext *smk = s->priv_data;\n<37> if(flags & SMACKER_PAL){\n<41> uint8_t *pal = smk->pal;\n<43> uint8_t oldpal[768];\n<47> memcpy(oldpal, pal, 768);\n<69> pal += ((t & 0x7F) + 1) * 3;\n<93> *pal++ = oldpal[off + 0];\n<95> *pal++ = oldpal[off + 1];\n<97> *pal++ = oldpal[off + 2];\n<107> *pal++ = smk_pal[t];\n<185> if (av_new_packet(pkt, frame_size + 769))\n<193> pkt->data[0] = palchange;\n<195> memcpy(pkt->data + 1, smk->pal, 768);\n<219> if (av_new_packet(pkt, smk->buf_sizes[smk->curstream]))\n<223> memcpy(pkt->data, smk->bufs[smk->curstream], smk->buf_sizes[smk->curstream]);\n<225> pkt->size = smk->buf_sizes[smk->curstream];\n<231> smk->aud_pts[smk->curstream] += AV_RL32(pkt->data);
<1> static int qcow_write_snapshots(BlockDriverState *bs)\n<25> for(i = 0; i < s->nb_snapshots; i++) {\n<27> sn = s->snapshots + i;\n<29> offset = align_offset(offset, 8);\n<31> offset += sizeof(h);\n<33> offset += strlen(sn->id_str);\n<35> offset += strlen(sn->name);\n<39> snapshots_size = offset;\n<55> for(i = 0; i < s->nb_snapshots; i++) {\n<57> sn = s->snapshots + i;\n<59> memset(&h, 0, sizeof(h));\n<75> id_str_size = strlen(sn->id_str);\n<77> name_size = strlen(sn->name);\n<79> h.id_str_size = cpu_to_be16(id_str_size);\n<81> h.name_size = cpu_to_be16(name_size);\n<85> if (bdrv_pwrite(bs->file, offset, &h, sizeof(h)) != sizeof(h))\n<91> if (bdrv_pwrite(bs->file, offset, sn->id_str, id_str_size) != id_str_size)\n<97> if (bdrv_pwrite(bs->file, offset, sn->name, name_size) != name_size)
<1> static int rtp_packetize_h263 ( sout_stream_id_sys_t * id , block_t * in ) {\n<16> if ( p_data [ 0 ] || p_data [ 1 ] ) {\n<20> p_data += 2 ;\n<24> i < i_count ;\n<26> int i_payload = __MIN ( i_max , i_data ) ;\n<30> rtp_packetize_common ( id , out , ( i == i_count - 1 ) ? 1 : 0 , in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ;\n<31> SetWBE ( out -> p_buffer + 12 , h ) ;\n<32> memcpy ( & out -> p_buffer [ RTP_H263_PAYLOAD_START ] , p_data , i_payload ) ;\n<35> rtp_packetize_send ( id , out ) ;\n<36> p_data += i_payload ;\n<37> i_data -= i_payload ;
<1> static int fetch_numbers ( char * line , void * data ) {\n<4> if ( ! line ) return 0 ;\n<5> if ( sscanf ( line , ANUM , & anum ) != 1 ) return 0 ;\n<6> if ( anum < fc -> first || anum > fc -> last ) return 0 ;\n<7> fc -> messages [ anum - fc -> first ] = 1 ;
<1> static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,\n<3> const uint8_t *sps_pps, uint32_t sps_pps_size,\n<5> const uint8_t *in,      uint32_t in_size) {\n<9> uint8_t nal_header_size = offset ? 3 : 4;\n<15> *poutbuf = av_realloc(*poutbuf, *poutbuf_size);\n<17> if (sps_pps)\n<19> memcpy(*poutbuf+offset, sps_pps, sps_pps_size);\n<21> memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);\n<25> AV_WB32(*poutbuf+sps_pps_size, 1);
<1> static int asf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n<5> ASFContext *asf = s->priv_data;\n<25> memset(dar, 0, sizeof(dar));\n<27> memset(bitrate, 0, sizeof(bitrate));\n<33> if (guidcmp(&g, &ff_asf_header))\n<45> memset(&asf->asfid2avid, -1, sizeof(asf->asfid2avid));\n<257> ff_get_wav_header(pb, st->codec, type_specific_size);\n<391> get_buffer(pb, st->codec->extradata, st->codec->extradata_size);\n<403> if (st->codec->extradata_size && (st->codec->bits_per_coded_sample <= 8)) {\n<415> memcpy(st->codec->palctrl->palette, st->codec->extradata,\n<417> FFMIN(st->codec->extradata_size, AVPALETTE_SIZE));\n<583> get_str16_nolen(pb, name_len, name, sizeof(name));\n<593> if(stream_num<128){\n<595> if     (!strcmp(name, "AspectRatioX")) dar[stream_num].num= value_num;\n<597> else if(!strcmp(name, "AspectRatioY")) dar[stream_num].den= value_num;\n<869> st->codec->bit_rate = bitrate[i];\n<885> if (asf->streams[i].stream_language_index < 128) {\n<887> const char *rfc1766 = asf->stream_languages[asf->streams[i].stream_language_index];\n<889> if (rfc1766 && strlen(rfc1766) > 1) {\n<891> const char primary_tag[3] = { rfc1766[0], rfc1766[1], '\0' }; // ignore country code if any\n<893> const char *iso6392 = av_convert_lang_to(primary_tag, AV_LANG_ISO639_2_BIBL);\n<895> if (iso6392)
<1> static int qcow2_set_key ( BlockDriverState * bs , const char * key ) {\n<3> uint8_t keybuf [ 16 ] ;\n<5> memset ( keybuf , 0 , 16 ) ;\n<6> len = strlen ( key ) ;\n<7> if ( len > 16 ) len = 16 ;\n<11> keybuf [ i ] = key [ i ] ;\n<14> if ( AES_set_encrypt_key ( keybuf , 128 , & s -> aes_encrypt_key ) != 0 ) return - 1 ;
<5> if ( read_len_table ( s -> len [ 0 ] , & gb ) < 0 ) return - 1 ;\n<7> if ( read_len_table ( s -> len [ 1 ] , & gb ) < 0 ) return - 1 ;\n<10> i ++ ) s -> bits [ 0 ] [ i ] = classic_add_luma [ i ] ;\n<13> i ++ ) s -> bits [ 1 ] [ i ] = classic_add_chroma [ i ] ;\n<14> if ( s -> bitstream_bpp >= 24 ) {\n<15> memcpy ( s -> bits [ 1 ] , s -> bits [ 0 ] , 256 * sizeof ( uint32_t ) ) ;\n<16> memcpy ( s -> len [ 1 ] , s -> len [ 0 ] , 256 * sizeof ( uint8_t ) ) ;\n<18> memcpy ( s -> bits [ 2 ] , s -> bits [ 1 ] , 256 * sizeof ( uint32_t ) ) ;\n<19> memcpy ( s -> len [ 2 ] , s -> len [ 1 ] , 256 * sizeof ( uint8_t ) ) ;
<1> void init_paths(const char *prefix)\n<9> if (prefix[0] == '\0' ||\n<11> !strcmp(prefix, "/"))\n<17> if (prefix[0] != '/') {\n<29> pstrcpy(pref_buf, sizeof(pref_buf), cwd);\n<33> pstrcat(pref_buf, pref_buf_len, prefix);\n<35> free(cwd);\n<39> pstrcpy(pref_buf, sizeof(pref_buf), prefix + 1);\n<45> base = add_dir_maybe(base);\n<47> if (base->num_entries == 0) {\n<49> g_free(base->pathname);\n<51> free(base->name);\n<53> free(base);
<1> int mdb_search ( Operation * op , SlapReply * rs ) {\n<402> pdn = base -> e_name ;\n<403> pndn = base -> e_nname ;\n<418> d = e -> e_name . bv_val ;\n<419> n = e -> e_nname . bv_val ;\n<422> i >= 0 ;\n<424> memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n<425> d += isc . rdns [ i ] . bv_len ;\n<426> * d ++ = ',' ;\n<427> memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n<428> n += isc . nrdns [ i ] . bv_len ;\n<429> * n ++ = ',' ;\n<434> i < isc . numrdns ;\n<436> memcpy ( d , isc . rdns [ i ] . bv_val , isc . rdns [ i ] . bv_len ) ;\n<437> d += isc . rdns [ i ] . bv_len ;\n<438> * d ++ = ',' ;\n<439> memcpy ( n , isc . nrdns [ i ] . bv_val , isc . nrdns [ i ] . bv_len ) ;\n<440> n += isc . nrdns [ i ] . bv_len ;\n<441> * n ++ = ',' ;\n<444> if ( pdn . bv_len ) {\n<445> memcpy ( d , pdn . bv_val , pdn . bv_len + 1 ) ;\n<446> memcpy ( n , pndn . bv_val , pndn . bv_len + 1 ) ;\n<454> if ( pndn . bv_val != base -> e_nname . bv_val ) {\n<456> op -> o_tmpfree ( pdn . bv_val , op -> o_tmpmemctx ) ;
<1> static int tls1_PRF ( long digest_mask , const void * seed1 , int seed1_len , const void * seed2 , int seed2_len , const void * seed3 , int seed3_len , const void * seed4 , int seed4_len , const void * seed5 , int seed5_len , const unsigned char * sec , int slen , unsigned char * out1 , unsigned char * out2 , int olen ) {\n<16> memset ( out1 , 0 , olen ) ;\n<25> if ( ! tls1_P_hash ( md , S1 , len + ( slen & 1 ) , seed1 , seed1_len , seed2 , seed2_len , seed3 , seed3_len , seed4 , seed4_len , seed5 , seed5_len , out2 , olen ) ) goto err ;\n<30> out1 [ i ] ^= out2 [ i ] ;
<1> static int set_segment_filename(AVFormatContext *s)\n<5> SegmentContext *seg = s->priv_data;\n<27> if (!strftime(oc->filename, sizeof(oc->filename), s->filename, tm)) {\n<35> } else if (av_get_frame_filename(oc->filename, sizeof(oc->filename),\n<49> size = strlen(av_basename(oc->filename)) + 1;\n<51> if (seg->entry_prefix)\n<53> size += strlen(seg->entry_prefix);\n<57> seg->cur_entry.filename = av_mallocz(size);\n<63> snprintf(seg->cur_entry.filename, size, "%s%s",\n<65> seg->entry_prefix ? seg->entry_prefix : "",
<1> static int pvf_read_header(AVFormatContext *s)\n<15> ff_get_line(s->pb, buffer, sizeof(buffer));\n<25> return AVERROR_INVALIDDATA;\n<29> if (channels <= 0 || bps <= 0 || sample_rate <= 0)\n<45> st->codecpar->channels    = channels;\n<47> st->codecpar->sample_rate = sample_rate;\n<49> st->codecpar->codec_id    = ff_get_pcm_codec_id(bps, 0, 1, 0xFFFF);\n<51> st->codecpar->bits_per_coded_sample = bps;\n<53> st->codecpar->block_align = bps * st->codecpar->channels / 8;
<1> static int do_readlink(struct iovec *iovec, struct iovec *out_iovec)\n<13> v9fs_string_init(&path);\n<15> retval = proxy_unmarshal(iovec, PROXY_HDR_SZ, "sd", &path, &size);\n<17> if (retval < 0) {\n<25> buffer = g_malloc(size);\n<29> retval = readlink(path.data, buffer, size);\n<31> if (retval > 0) {\n<35> v9fs_string_sprintf(&target, "%s", buffer);\n<45> g_free(buffer);\n<49> v9fs_string_free(&path);
<1> int cpu_x86_register(X86CPU *cpu, const char *cpu_model)\n<7> x86_def_t def1, *def = &def1;\n<17> memset(def, 0, sizeof(*def));\n<37> if (cpu_x86_find_by_name(def, name) < 0) {\n<109> if (error) {\n<111> fprintf(stderr, "%s\n", error_get_pretty(error));
<1> static int ztype ( i_ctx_t * i_ctx_p ) {\n<9> if ( ( r_has_type ( & op [ - 1 ] , t_struct ) || r_has_type ( & op [ - 1 ] , t_astruct ) ) && op [ - 1 ] . value . pstruct != 0x00 ) {\n<10> const char * sname = gs_struct_type_name_string ( gs_object_type ( imemory , op [ - 1 ] . value . pstruct ) ) ;\n<11> int code = name_ref ( imemory , ( const byte * ) sname , strlen ( sname ) , ( ref * ) ( op - 1 ) , 0 ) ;
<1> void audio_encode_example(const char *filename)\n<21> printf("Audio encoding\n");\n<29> if (!codec) {\n<31> fprintf(stderr, "codec not found\n");\n<45> c->bit_rate = 64000;\n<55> if (avcodec_open(c, codec) < 0) {\n<57> fprintf(stderr, "could not open codec\n");\n<69> samples = malloc(frame_size * 2 * c->channels);\n<71> outbuf_size = 10000;\n<73> outbuf = malloc(outbuf_size);\n<77> f = fopen(filename, "w");\n<79> if (!f) {\n<81> fprintf(stderr, "could not open %s\n", filename);\n<93> tincr = 2 * M_PI * 440.0 / c->sample_rate;\n<99> samples[2*j] = (int)(sin(t) * 10000);\n<101> samples[2*j+1] = samples[2*j];\n<109> out_size = avcodec_encode_audio(c, outbuf, outbuf_size, samples);\n<111> fwrite(outbuf, 1, out_size, f);\n<117> free(outbuf);\n<119> free(samples);\n<123> avcodec_close(c);\n<125> free(c);
<1> static int slirp_smb(SlirpState* s, const char *exported_dir,\n<9> passwd = getpwuid(geteuid());\n<16> snprintf(smb_conf, sizeof(smb_conf), "%s/%s", s->smb_dir, "smb.conf");\n<17> f = fopen(smb_conf, "w");\n<19> slirp_smb_cleanup(s);\n<46> fclose(f);\n<50> slirp_smb_cleanup(s);
<1> static int fz_cmp_link_key ( fz_context * ctx , void * k0_ , void * k1_ ) {\n<2> fz_link_key * k0 = ( fz_link_key * ) k0_ ;\n<3> fz_link_key * k1 = ( fz_link_key * ) k1_ ;\n<4> return k0 -> proof == k1 -> proof && k0 -> src_extras == k1 -> src_extras && k0 -> dst_extras == k1 -> dst_extras && k0 -> copy_spots == k1 -> copy_spots && k0 -> depth == k1 -> depth && k0 -> rend . bp == k1 -> rend . bp && k0 -> rend . ri == k1 -> rend . ri && memcmp ( k0 -> dst_md5 , k1 -> dst_md5 , 16 ) == 0 && memcmp ( k0 -> src_md5 , k1 -> src_md5 , 16 ) ;
<1> static int xps_parse_line_cap ( char * attr ) {\n<2> if ( attr ) {\n<3> if ( ! strcmp ( attr , "Flat" ) ) return 0 ;\n<4> if ( ! strcmp ( attr , "Round" ) ) return 1 ;\n<5> if ( ! strcmp ( attr , "Square" ) ) return 2 ;\n<6> if ( ! strcmp ( attr , "Triangle" ) ) return 3 ;\n<8> return 0 ;
<1> static inline void e1000e_write_ext_rx_descr ( E1000ECore * core , uint8_t * desc , struct NetRxPkt * pkt , const E1000E_RSSInfo * rss_info , uint16_t length ) {\n<2> union e1000_rx_desc_extended * d = ( union e1000_rx_desc_extended * ) desc ;\n<3> memset ( & d -> wb , 0 , sizeof ( d -> wb ) ) ;
<1> int main ( int argc , const char * * argv ) {\n<13> uint32_t frame_cnt = 0 ;\n<20> int frames_received = 0 ;\n<21> memset ( & svc_ctx , 0 , sizeof ( svc_ctx ) ) ;\n<24> parse_command_line ( argc , argv , & app_input , & svc_ctx , & enc_cfg ) ;\n<27> if ( vpx_svc_init ( & svc_ctx , & codec , vpx_codec_vp9_cx ( ) , & enc_cfg ) != VPX_CODEC_OK ) die ( "Failed to initialize encoder\n" ) ;\n<38> while ( ! end_of_stream ) {\n<41> if ( frame_cnt >= app_input . frames_to_code || ! vpx_img_read ( & raw , infile ) ) {\n<44> res = vpx_svc_encode ( & svc_ctx , & codec , ( end_of_stream ? NULL : & raw ) , pts , frame_duration , VPX_DL_GOOD_QUALITY ) ;\n<45> printf ( "%s" , vpx_svc_get_message ( & svc_ctx ) ) ;\n<50> switch ( cx_pkt -> kind ) {\n<52> if ( cx_pkt -> data . frame . sz > 0 ) vpx_video_writer_write_frame ( writer , cx_pkt -> data . frame . buf , cx_pkt -> data . frame . sz , cx_pkt -> data . frame . pts ) ;\n<53> printf ( "SVC frame: %d, kf: %d, size: %d, pts: %d\n" , frames_received , ! ! ( cx_pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) , ( int ) cx_pkt -> data . frame . sz , ( int ) cx_pkt -> data . frame . pts ) ;\n<54> ++ frames_received ;\n<67> ++ frame_cnt ;\n<71> printf ( "Processed %d frames\n" , frame_cnt ) ;\n<79> printf ( "%s" , vpx_svc_dump_statistics ( & svc_ctx ) ) ;\n<80> vpx_svc_release ( & svc_ctx ) ;
<1> static int xenstore_scan(const char *type, int dom, struct XenDevOps *ops)\n<21> snprintf(path, sizeof(path), "%s/backend/%s/%d", dom0, type, dom);\n<23> free(dom0);\n<39> if (!dev) {\n<47> xendev = xen_be_get_xendev(type, dom, atoi(dev[j]), ops);\n<59> free(dev);
<1> int str_hex_to_bytes ( char * string , u_char * bytes ) {\n<2> char value [ 3 ] ;\n<6> slen = strlen ( string ) ;\n<8> i < slen ;\n<9> i ++ ) {\n<10> strncpy ( value , string + i * 2 , 2 ) ;\n<11> if ( sscanf ( value , "%02X" , & value_bin ) != 1 ) return - E_INVALID ;\n<12> bytes [ i ] = value_bin & 0x000000FF ;
<1> static int open_input_stream(HTTPContext *c, const char *info)\n<101> if (buf_size > 0) {\n<105> if (ret < 0) {\n<121> if (strcmp(s->iformat->name, "ffm") &&\n<123> (ret = avformat_find_stream_info(c->fmt_in, NULL)) < 0) {\n<125> http_log("Could not find stream info for input '%s'\n", input_filename);\n<127> avformat_close_input(&s);\n<129> return ret;\n<139> c->pts_stream_index = 0;\n<141> for(i=0;i<c->stream->nb_streams;i++) {\n<155> if (c->fmt_in->iformat->read_seek)\n<161> c->start_time = cur_time;\n<163> c->first_pts = AV_NOPTS_VALUE;\n<165> return 0;
<1> static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> CinepakContext * s = avctx -> priv_data ;\n<12> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<13> if ( pal ) {\n<15> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<18> cinepak_decode ( s ) ;\n<19> if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;
<1> int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick , my_bool no_copy_stat ) {\n<25> if ( ! ( param -> testflag & T_SILENT ) ) {\n<26> printf ( "- parallel recovering (with sort) MyISAM-table '%s'\n" , name ) ;\n<27> printf ( "Data records: %s\n" , llstr ( start_records , llbuff ) ) ;\n<79> rec_per_key_part = param -> rec_per_key_part ;\n<84> rec_per_key_part += sort_param [ i ] . keyinfo -> keysegs , i += istep , key ++ ) {\n<88> if ( ! mi_is_key_active ( key_map , key ) ) {\n<89> memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param [ i ] . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n<94> if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( "- Fixing index %d\n" , key + 1 ) ;
<1> void configure_alarms(char const *opt)\n<19> if (!strcmp(opt, "?")) {\n<21> show_available_alarms();\n<23> exit(0);\n<29> arg = g_strdup(opt);\n<35> name = strtok(arg, ",");\n<37> while (name) {\n<39> for (i = 0; i < count && alarm_timers[i].name; i++) {\n<41> if (!strcmp(alarm_timers[i].name, name))\n<49> if (i == count) {\n<51> fprintf(stderr, "Unknown clock %s\n", name);\n<81> name = strtok(NULL, ",");\n<87> g_free(arg);\n<97> alarm_timers[i].name = NULL;
<1> static void cin_decode_rle(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)\n<15> code = *src++;\n<17> if (code & 0x80) {\n<21> memset(dst, *src++, FFMIN(len, dst_end - dst));\n<27> memcpy(dst, src, FFMIN(len, dst_end - dst));\n<29> src += len;\n<33> dst += len;
<1> struct omap_mpu_state_s *omap310_mpu_init(MemoryRegion *system_memory,\n<35> if (s->cpu == NULL) {\n<37> fprintf(stderr, "Unable to find CPU definition\n");\n<299> if (!dinfo) {\n<301> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> static void numa_node_parse(NumaNodeOptions *node, QemuOpts *opts, Error **errp)\n<91> if (node->has_mem) {\n<95> const char *mem_str = qemu_opt_get(opts, "mem");\n<99> if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n<101> mem_size <<= 20;
<1> static int nbd_send_negotiate(NBDClient *client)\n<7> char buf[8 + 8 + 8 + 128];\n<63> memcpy(buf, "NBDMAGIC", 8);\n<69> cpu_to_be64w((uint64_t*)(buf + 8), NBD_CLIENT_MAGIC);\n<71> cpu_to_be64w((uint64_t*)(buf + 16), client->exp->size);\n<73> cpu_to_be16w((uint16_t*)(buf + 26), client->exp->nbdflags | myflags);\n<77> cpu_to_be64w((uint64_t*)(buf + 8), NBD_OPTS_MAGIC);\n<81> memset(buf + 28, 0, 124);\n<97> if (write_sync(csock, buf, 18) != 18) {
<1> static void ppc_prep_init ( QEMUMachineInitArgs * args ) {\n<38> if ( cpu == NULL ) {\n<39> fprintf ( stderr , "Unable to find PowerPC CPU definition\n" ) ;\n<59> filename = qemu_find_file ( QEMU_FILE_TYPE_BIOS , bios_name ) ;\n<70> if ( bios_size > BIOS_SIZE ) {\n<71> fprintf ( stderr , "qemu: PReP bios '%s' is too large (0x%x)\n" , bios_name , bios_size ) ;\n<79> if ( bios_size < 0 && ! qtest_enabled ( ) ) {\n<80> fprintf ( stderr , "qemu: could not load PPC PReP bios '%s'\n" , bios_name ) ;\n<120> if ( ppc_boot_device == '\0' ) {\n<121> fprintf ( stderr , "No valid boot device for Mac99 machine\n" ) ;\n<133> if ( pci_bus == NULL ) {\n<134> fprintf ( stderr , "Couldn't create PCI host controller.\n" ) ;\n<156> i < nb_nics1 ;\n<158> if ( nd_table [ i ] . model == NULL ) {\n<159> nd_table [ i ] . model = g_strdup ( "ne2k_isa" ) ;\n<161> if ( strcmp ( nd_table [ i ] . model , "ne2k_isa" ) == 0 ) {\n<162> isa_ne2000_init ( isa_bus , ne2000_io [ i ] , ne2000_irq [ i ] , & nd_table [ i ] ) ;\n<165> pci_nic_init_nofail ( & nd_table [ i ] , pci_bus , "ne2k_pci" , NULL ) ;
<36> if ( ( i > 0 ) && ! ( frame_flags & 0x01 ) ) {\n<37> memcpy ( s -> strips [ i ] . v4_codebook , s -> strips [ i - 1 ] . v4_codebook , sizeof ( s -> strips [ i ] . v4_codebook ) ) ;\n<38> memcpy ( s -> strips [ i ] . v1_codebook , s -> strips [ i - 1 ] . v1_codebook , sizeof ( s -> strips [ i ] . v1_codebook ) ) ;\n<40> result = cinepak_decode_strip ( s , & s -> strips [ i ] , s -> data , strip_size ) ;
<1> static cmsBool GetVal ( cmsIT8 * it8 , char * Buffer , cmsUInt32Number max , const char * ErrorTitle ) {\n<2> switch ( it8 -> sy ) {\n<5> case SIDENT : strncpy ( Buffer , it8 -> id , max ) ;\n<6> Buffer [ max - 1 ] = 0 ;\n<12> case SSTRING : strncpy ( Buffer , it8 -> str , max ) ;\n<13> Buffer [ max - 1 ] = 0 ;
<1> static void flush_change(H264Context *h)\n<19> memset(h->ref_list[0], 0, sizeof(h->ref_list[0]));\n<21> memset(h->ref_list[1], 0, sizeof(h->ref_list[1]));\n<23> memset(h->default_ref_list[0], 0, sizeof(h->default_ref_list[0]));\n<25> memset(h->default_ref_list[1], 0, sizeof(h->default_ref_list[1]));
<1> static int read_ffserver_streams(AVFormatContext *s, const char *filename)\n<23> for(i=0;i<ic->nb_streams;i++) {\n<33> st = av_mallocz(sizeof(AVStream));\n<35> memcpy(st, ic->streams[i], sizeof(AVStream));\n<39> if (!st->codec) {\n<47> avcodec_copy_context(st->codec, ic->streams[i]->codec);\n<49> s->streams[i] = st;\n<59> st->stream_copy = 1;\n<63> choose_sample_fmt(st, codec);\n<69> st->stream_copy = 1;\n<73> choose_pixel_fmt(st, codec);\n<85> avcodec_thread_init(st->codec, st->codec->thread_count);
<1> static int tcp_open(URLContext *h, const char *uri, int flags)\n<23> if(!ff_network_init())\n<29> url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),\n<33> if (strcmp(proto,"tcp") || port <= 0 || port >= 65536)\n<35> return AVERROR(EINVAL);\n<37> if ((q = strchr(hostname,'@'))) { strcpy(tmp,q+1); strcpy(hostname,tmp); }\n<41> dest_addr.sin_family = AF_INET;\n<43> dest_addr.sin_port = htons(port);\n<45> if (resolve_host(&dest_addr.sin_addr, hostname) < 0)
<1> static int ape_decode_frame(AVCodecContext *avctx, void *data,\n<11> APEContext *s = avctx->priv_data;\n<71> av_fast_malloc(&s->data, &s->data_size, buf_size);\n<73> if (!s->data)\n<79> memset(s->data + (buf_size & ~3), 0, buf_size & 3);\n<145> if (init_frame_decoder(s) < 0) {\n<181> av_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n<185> if (!s->decoded_buffer)\n<189> memset(s->decoded_buffer, 0, s->decoded_size);\n<191> s->decoded[0] = s->decoded_buffer;\n<193> s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n<213> ape_unpack_mono(s, blockstodecode);\n<217> ape_unpack_stereo(s, blockstodecode);
<1> int lcc_network_buffer_initialize ( lcc_network_buffer_t * nb ) {\n<2> if ( nb == NULL ) return ( EINVAL ) ;\n<3> memset ( nb -> buffer , 0 , nb -> size ) ;\n<4> memset ( & nb -> state , 0 , sizeof ( nb -> state ) ) ;\n<5> nb -> ptr = nb -> buffer ;\n<6> nb -> free = nb -> size ;
<1> static int pnm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<9> s -> bytestream_start = s -> bytestream = buf ;\n<11> if ( ( ret = ff_pnm_decode_header ( avctx , s ) ) < 0 ) return ret ;\n<41> do_read : ptr = p -> data [ 0 ] ;\n<43> if ( s -> bytestream + n * avctx -> height > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n<72> if ( ! upgrade ) memcpy ( ptr , s -> bytestream , n ) ;\n<76> j < n ;\n<77> j ++ ) ptr [ j ] = ( s -> bytestream [ j ] * f + 64 ) >> 7 ;\n<82> j < n / 2 ;\n<88> s -> bytestream += n ;\n<89> ptr += linesize ;\n<96> ptr = p -> data [ 0 ] ;\n<99> if ( s -> bytestream + n * avctx -> height * 3 / 2 > s -> bytestream_end ) return AVERROR_INVALIDDATA ;\n<101> i < avctx -> height ;\n<103> memcpy ( ptr , s -> bytestream , n ) ;\n<104> s -> bytestream += n ;\n<105> ptr += linesize ;\n<107> ptr1 = p -> data [ 1 ] ;\n<108> ptr2 = p -> data [ 2 ] ;\n<109> n >>= 1 ;\n<112> i < h ;\n<114> memcpy ( ptr1 , s -> bytestream , n ) ;\n<115> s -> bytestream += n ;\n<116> memcpy ( ptr2 , s -> bytestream , n ) ;\n<117> s -> bytestream += n ;\n<118> ptr1 += p -> linesize [ 1 ] ;\n<119> ptr2 += p -> linesize [ 2 ] ;
<1> static int read_uncompressed_sgi(unsigned char* out_buf, uint8_t* out_end,\n<3> const uint8_t *in_buf, const uint8_t *in_end, SgiState* s)\n<11> unsigned int offset = s->height * s->width * s->bytes_per_channel;\n<27> out_end = out_buf + (y * s->linesize);\n<31> ptr = in_buf += s->bytes_per_channel;\n<33> for(z = 0; z < s->depth; z ++) {\n<35> memcpy(out_end, ptr, s->bytes_per_channel);\n<37> out_end += s->bytes_per_channel;\n<39> ptr += offset;
<1> void ff_mpeg1_clean_buffers ( MpegEncContext * s ) {\n<5> memset ( s -> last_mv , 0 , sizeof ( s -> last_mv ) ) ;
<1> static void copyarray ( struct pskeydict * to , struct pskeydict * from , struct garbage * tofrees ) {\n<5> to -> entries = calloc ( to -> cnt , sizeof ( struct pskeyval ) ) ;\n<13> collectgarbage ( tofrees , to ) ;
<1> static void print_http_error ( struct Curl_easy * data ) {\n<4> if ( ! strncmp ( beg , "HTTP" , 4 ) ) {\n<5> beg = strchr ( beg , ' ' ) ;\n<6> if ( beg && * ++ beg ) {\n<7> char end_char = '\r' ;\n<8> char * end = strchr ( beg , end_char ) ;\n<9> if ( ! end ) {\n<10> end_char = '\n' ;\n<11> end = strchr ( beg , end_char ) ;\n<15> failf ( data , "The requested URL returned error: %s" , beg ) ;\n<16> * end = end_char ;
<1> static void encode_frame ( struct stream_state * stream , struct VpxEncoderConfig * global , struct vpx_image * img , unsigned int frames_in ) {\n<23> if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) {\n<24> fprintf ( stderr , "%s can only scale 4:2:0 8bpp inputs\n" , exec_name ) ;
<1> static int standard_decode_i_mbs(VC9Context *v)\n<19> memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);\n<41> p_cbpcy = v->previous_line_cbpcy+4;
<1> static int v9fs_receive_response(V9fsProxy *proxy, int type,\n<3> int *status, void *response)\n<99> switch (type) {\n<177> v9fs_string_init(&xattr);\n<181> memcpy(response, xattr.data, xattr.size);\n<183> v9fs_string_free(&xattr);
<1> int qemuMonitorTextSetDrivePassphrase ( qemuMonitorPtr mon , const char * alias , const char * passphrase ) {\n<3> char * reply = NULL ;\n<15> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<19> if ( strstr ( reply , "unknown command:" ) ) {\n<20> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , _ ( "setting disk password is not supported" ) ) ;\n<23> else if ( strstr ( reply , "The entered password is invalid" ) ) {\n<24> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , _ ( "the disk password is incorrect" ) ) ;\n<27> ret = 0 ;\n<29> VIR_FREE ( reply ) ;
<1> altivec_yuv2packedX (SwsContext *c,\n<29> unsigned long scratch[16] __attribute__ ((aligned (16)));\n<313> switch(c->dstFormat) {\n<341> memcpy (&((uint32_t*)dest)[i], scratch, (dstW-i)/4);
<1> void xps_parse_element ( xps_document * doc , const fz_matrix * ctm , const fz_rect * area , char * base_uri , xps_resource * dict , fz_xml * node ) {\n<2> if ( doc -> cookie && doc -> cookie -> abort ) return ;\n<3> if ( ! strcmp ( fz_xml_tag ( node ) , "Path" ) ) xps_parse_path ( doc , ctm , base_uri , dict , node ) ;\n<4> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs" ) ) xps_parse_glyphs ( doc , ctm , base_uri , dict , node ) ;\n<5> if ( ! strcmp ( fz_xml_tag ( node ) , "Canvas" ) ) xps_parse_canvas ( doc , ctm , area , base_uri , dict , node ) ;\n<6> if ( ! strcmp ( fz_xml_tag ( node ) , "mc:AlternateContent" ) ) {\n<7> node = xps_lookup_alternate_content ( node ) ;\n<8> if ( node ) xps_parse_element ( doc , ctm , area , base_uri , dict , node ) ;
<1> static void compute_pkt_fields(AVFormatContext *s, AVStream *st,\n<139> if (    strcmp(s->iformat->name, "mov,mp4,m4a,3gp,3g2,mj2")\n<141> && strcmp(s->iformat->name, "flv")) // otherwise we discard correct timestamps for vc1-wmapro.ism\n<143> pkt->dts = AV_NOPTS_VALUE;
<1> bool gx_color_info_equal ( const gx_device_color_info * p1 , const gx_device_color_info * p2 ) {\n<4> if ( p1 -> black_component != p2 -> black_component ) return false ;\n<5> if ( strcmp ( p1 -> cm_name , p2 -> cm_name ) != 0 ) return false ;\n<6> if ( p1 -> depth != p2 -> depth ) return false ;
<1> static int idcin_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<10> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<14> idcin_decode_vlcs ( s , frame ) ;\n<15> if ( pal ) {\n<17> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<19> memcpy ( frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;
<1> static int matroska_parse_cluster_incremental(MatroskaDemuxContext *matroska)\n<17> if (res == 1) {\n<23> ebml_level_end(matroska);\n<25> ebml_free(matroska_cluster, &matroska->current_cluster);\n<27> memset(&matroska->current_cluster, 0, sizeof(MatroskaCluster));
<1> static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<131> if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n<151> ptr    = p->data[0];\n<211> for (y = 0; y < h; y++, ptr += stride) {\n<217> memcpy(ptr, scanline, w);\n<329> av_free(scanline);
<1> int qemu_egl_rendernode_open(void)\n<27> while ((e = readdir(dir))) {\n<37> if (strncmp(e->d_name, "renderD", 7)) {\n<45> r = asprintf(&p, "/dev/dri/%s", e->d_name);\n<47> if (r < 0) {\n<55> r = open(p, O_RDWR | O_CLOEXEC | O_NOCTTY | O_NONBLOCK);\n<57> if (r < 0) {\n<59> free(p);\n<67> free(p);
<1> static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)\n<57> d = av_rescale_q(ref->pts, tb, AV_TIME_BASE_Q);\n<93> if ((ret = av_new_packet(pkt, size)) < 0)\n<99> memcpy(pict.data,     ref->data,     4*sizeof(ref->data[0]));\n<101> memcpy(pict.linesize, ref->linesize, 4*sizeof(ref->linesize[0]));\n<105> avpicture_layout(&pict, ref->format, ref->video->w,\n<117> if ((ret = av_new_packet(pkt, size)) < 0)\n<121> memcpy(pkt->data, ref->data[0], size);\n<137> av_bprint_init(&meta_buf, 0, AV_BPRINT_SIZE_UNLIMITED);\n<141> av_bprintf(&meta_buf, "%s", e->key);\n<143> av_bprint_chars(&meta_buf, '\0', 1);\n<145> av_bprintf(&meta_buf, "%s", e->value);\n<147> av_bprint_chars(&meta_buf, '\0', 1);\n<153> !(metadata = av_packet_new_side_data(pkt, AV_PKT_DATA_STRINGS_METADATA,\n<163> memcpy(metadata, meta_buf.str, meta_buf.len);\n<165> av_bprint_finalize(&meta_buf, NULL);\n<177> pkt->size = size;\n<179> avfilter_unref_buffer(ref);\n<181> return size;
<1> static void test_field_names ( ) {\n<5> if ( ! opt_silent ) fprintf ( stdout , "\n %d, %d, %d" , MYSQL_TYPE_DECIMAL , MYSQL_TYPE_NEWDATE , MYSQL_TYPE_ENUM ) ;
<1> static void qcow2_invalidate_cache(BlockDriverState *bs)\n<3> BDRVQcowState *s = bs->opaque;\n<13> if (s->crypt_method) {\n<15> memcpy(&aes_encrypt_key, &s->aes_encrypt_key, sizeof(aes_encrypt_key));\n<16> memcpy(&aes_decrypt_key, &s->aes_decrypt_key, sizeof(aes_decrypt_key));\n<21> qbool_from_int(s->use_lazy_refcounts));\n<22> memset(s, 0, sizeof(BDRVQcowState));\n<25> if (crypt_method) {\n<27> memcpy(&s->aes_encrypt_key, &aes_encrypt_key, sizeof(aes_encrypt_key));\n<28> memcpy(&s->aes_decrypt_key, &aes_decrypt_key, sizeof(aes_decrypt_key));
<1> void do_savevm(const char *name)\n<7> QEMUSnapshotInfo sn1, *sn = &sn1, old_sn1, *old_sn = &old_sn1;\n<31> if (!bs) {\n<67> memset(sn, 0, sizeof(*sn));\n<71> pstrcpy(sn->name, sizeof(sn->name), old_sn->name);\n<73> pstrcpy(sn->id_str, sizeof(sn->id_str), old_sn->id_str);\n<79> pstrcpy(sn->name, sizeof(sn->name), name);\n<173> ret = bdrv_snapshot_create(bs1, sn);
<1> void do_sync_with_master2 ( struct st_command * command , long offset ) {\n<5> char query_buf [ FN_REFLEN + 128 ] ;\n<6> int timeout = 300 ;\n<7> if ( ! master_pos . file [ 0 ] ) die ( "Calling 'sync_with_master' without calling 'save_master_pos'" ) ;\n<8> sprintf ( query_buf , "select master_pos_wait('%s', %ld, %d)" , master_pos . file , master_pos . pos + offset , timeout ) ;\n<9> if ( mysql_query ( mysql , query_buf ) ) die ( "failed in '%s': %d: %s" , query_buf , mysql_errno ( mysql ) , mysql_error ( mysql ) ) ;\n<19> if ( ! result_str || result < 0 ) {\n<23> fprintf ( stderr , "analyze: sync_with_master\n" ) ;\n<27> if ( result == - 1 ) die ( "%.*s failed: '%s' returned -1 " "indicating timeout after %d seconds" , command -> first_word_len , command -> query , query_buf , timeout ) ;
<1> static void adpcm_compress_trellis(AVCodecContext *avctx,\n<21> TrellisNode **nodep_buf  = s->nodep_buf;\n<25> TrellisNode **nodes_next = nodep_buf + frontier;\n<29> uint8_t *hash = s->trellis_hash;\n<31> memset(hash, 0xff, 65536 * sizeof(*hash));\n<35> memset(nodep_buf, 0, 2 * frontier * sizeof(*nodep_buf));\n<37> nodes[0]          = node_buf + frontier;\n<81> for (i = 0; i < n; i++) {\n<91> memset(nodes_next, 0, frontier * sizeof(TrellisNode*));\n<93> for (j = 0; j < frontier && nodes[j]; j++) {\n<205> u  = nodes_next[pos];\\n<213> nodes_next[pos] = u;\\n<319> nodes = nodes_next;\n<321> nodes_next = u;\n<327> if (generation == 255) {\n<329> memset(hash, 0xff, 65536 * sizeof(*hash));\n<341> for (j = 1; j < frontier && nodes[j]; j++)\n<353> if (i == froze + FREEZE_INTERVAL) {\n<375> memset(nodes + 1, 0, (frontier - 1) * sizeof(TrellisNode*));
<1> void isa_ne2000_init(int base, qemu_irq irq, NICInfo *nd)\n<9> qemu_check_nic_model(nd, "ne2k_isa");\n<35> register_ioport_read(base + 0x1f, 1, 1, ne2000_reset_ioport_read, s);\n<39> memcpy(s->macaddr, nd->macaddr, 6);\n<43> ne2000_reset(s);\n<47> s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<53> qemu_format_nic_info_str(s->vc, s->macaddr);
<1> TSReturnCode TSStringPercentDecode ( const char * str , size_t str_len , char * dst , size_t dst_size , size_t * length ) {\n<4> if ( 0 == str_len ) {\n<5> str_len = strlen ( str ) ;\n<8> const char * src = str ;\n<10> unescape_str ( buffer , buffer + dst_size , src , src + str_len , s ) ;
<1> static int net_vhost_check_net(void *opaque, QemuOpts *opts, Error **errp)\n<5> const char *name = opaque;\n<9> const char virtio_name[] = "virtio-net-";\n<15> netdev = qemu_opt_get(opts, "netdev");\n<19> if (!driver || !netdev) {\n<27> if (strcmp(netdev, name) == 0 &&\n<29> strncmp(driver, virtio_name, strlen(virtio_name)) != 0) {\n<31> error_report("vhost-user requires frontend driver virtio-net-*");\n<33> return -1;\n<39> return 0;
<1> void check_pghost_envvar ( void ) {\n<6> for ( option = start ;\n<7> option -> keyword != NULL ;\n<8> option ++ ) {\n<9> if ( option -> envvar && ( strcmp ( option -> envvar , "PGHOST" ) == 0 || strcmp ( option -> envvar , "PGHOSTADDR" ) == 0 ) ) {\n<10> const char * value = getenv ( option -> envvar ) ;\n<11> if ( value && strlen ( value ) > 0 && ( strcmp ( value , "localhost" ) != 0 && strcmp ( value , "127.0.0.1" ) != 0 && strcmp ( value , "::1" ) != 0 && value [ 0 ] != '/' ) ) pg_fatal ( "libpq environment variable %s has a non-local server value: %s\n" , option -> envvar , value ) ;
<1> void bdrv_iterate_format(void (*it)(void *opaque, const char *name),\n<15> QLIST_FOREACH(drv, &bdrv_drivers, list) {\n<23> while (formats && i && !found) {\n<25> found = !strcmp(formats[--i], drv->format_name);\n<31> if (!found) {\n<33> formats = g_realloc(formats, (count + 1) * sizeof(char *));\n<35> formats[count++] = drv->format_name;\n<37> it(opaque, drv->format_name);\n<45> g_free(formats);
<1> static void ppc_spapr_reset(void)\n<7> memset(spapr->htab, 0, spapr->htab_size);\n<17> spapr_finalize_fdt(spapr, spapr->fdt_addr, spapr->rtas_addr,
<1> static void test_fetch_seek ( ) {\n<17> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<23> my_bind [ 2 ] = my_bind [ 1 ] ;\n<28> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<34> if ( ! opt_silent ) fprintf ( stdout , "\n row 0: %ld, %s, %s" , ( long ) c1 , c2 , c3 ) ;\n<39> if ( ! opt_silent ) fprintf ( stdout , "\n row 2: %ld, %s, %s" , ( long ) c1 , c2 , c3 ) ;\n<43> if ( ! opt_silent ) fprintf ( stdout , "\n row 2: %ld, %s, %s" , ( long ) c1 , c2 , c3 ) ;\n<47> if ( ! opt_silent ) fprintf ( stdout , "\n row 0: %ld, %s, %s" , ( long ) c1 , c2 , c3 ) ;
<1> static void test_bug11909 ( ) {\n<12> stmt_text = "drop table if exists t1" ;\n<13> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<15> stmt_text = "create table t1 (" " empno int(11) not null, firstname varchar(20) not null," " midinit varchar(20) not null, lastname varchar(20) not null," " workdept varchar(6) not null, salary double not null," " bonus float not null, primary key (empno)" ") default charset=latin1 collate=latin1_bin" ;\n<16> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<18> stmt_text = "insert into t1 values " "(10, 'CHRISTINE', 'I', 'HAAS', 'A00', 52750, 1000), " "(20, 'MICHAEL', 'L', 'THOMPSON', 'B01', 41250, 800)," "(30, 'SALLY', 'A', 'KWAN', 'C01', 38250, 800)," "(50, 'JOHN', 'B', 'GEYER', 'E01', 40175, 800), " "(60, 'IRVING', 'F', 'STERN', 'D11', 32250, 500)" ;\n<19> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<45> rc = mysql_stmt_bind_result ( stmt1 , my_bind ) ;\n<52> DIE_UNLESS ( strcmp ( firstname , "CHRISTINE" ) == 0 ) ;\n<53> DIE_UNLESS ( strcmp ( midinit , "I" ) == 0 ) ;\n<54> DIE_UNLESS ( strcmp ( lastname , "HAAS" ) == 0 ) ;\n<55> DIE_UNLESS ( strcmp ( workdept , "A00" ) == 0 ) ;\n<66> DIE_UNLESS ( strcmp ( firstname , "CHRISTINE" ) == 0 ) ;\n<73> rc = mysql_rollback ( mysql ) ;
<1> static UBool generateFromUTrie ( CnvExtData * extData , UCMTable * table , int32_t mapLength ) {\n<30> if ( subStart < subLimit && mappings [ map [ subStart ] ] . uLen == 1 ) {\n<31> fprintf ( stderr , "error: multiple mappings from same Unicode code points\n" ) ;\n<32> ucm_printMapping ( table , m , stderr ) ;
<1> static void Win32ErrorHandler ( const char * module , const char * fmt , va_list ap ) {\n<4> LPCTSTR szTitleText = "%s Error" ;\n<6> LPCTSTR szTmpModule = ( module == NULL ) ? szDefaultModule : module ;\n<7> SIZE_T nBufSize = ( strlen ( szTmpModule ) + strlen ( szTitleText ) + strlen ( fmt ) + 256 ) * sizeof ( char ) ;\n<8> if ( ( szTitle = ( LPTSTR ) LocalAlloc ( LMEM_FIXED , nBufSize ) ) == NULL ) return ;\n<9> sprintf ( szTitle , szTitleText , szTmpModule ) ;\n<10> szTmp = szTitle + ( strlen ( szTitle ) + 2 ) * sizeof ( char ) ;\n<11> vsnprintf ( szTmp , nBufSize - ( strlen ( szTitle ) + 2 ) * sizeof ( char ) , fmt , ap ) ;\n<12> MessageBoxA ( GetFocus ( ) , szTmp , szTitle , MB_OK | MB_ICONEXCLAMATION ) ;
<1> int c_main ( void ) {\n<6> printf ( "\n\n" "C Boundary Analysis\n" "-------------------\n\n" ) ;\n<7> printf ( "Examining: %s\n" , cStringToExamine ) ;\n<8> u_uastrcpy ( stringToExamine , cStringToExamine ) ;\n<10> if ( U_FAILURE ( status ) ) {\n<11> printf ( "ubrk_open error: %s\n" , u_errorName ( status ) ) ;\n<14> printf ( "\n----- Sentence Boundaries, forward: -----------\n" ) ;\n<16> printf ( "\n----- Sentence Boundaries, backward: ----------\n" ) ;\n<20> printf ( "\n----- Word Boundaries, forward: -----------\n" ) ;\n<22> printf ( "\n----- Word Boundaries, backward: ----------\n" ) ;\n<24> printf ( "\n----- first: -------------\n" ) ;\n<26> printf ( "\n----- last: --------------\n" ) ;\n<28> printf ( "\n----- at pos 10: ---------\n" ) ;\n<31> printf ( "\nEnd of C boundary analysis\n" ) ;
<1> static void psf_log_syserr ( SF_PRIVATE * psf , int error ) {\n<2> if ( psf -> error == 0 ) {\n<4> snprintf ( psf -> syserr , sizeof ( psf -> syserr ) , "System error : %s." , strerror ( error ) ) ;
<1> static int tipc_add_tlv ( struct sk_buff * skb , u16 type , void * data , u16 len ) {\n<7> if ( len && data ) memcpy ( TLV_DATA ( tlv ) , data , len ) ;
<1> static void g364fb_screen_dump(void *opaque, const char *filename)\n<3> G364State *s = opaque;\n<13> if (!f)\n<15> if (s->ctla & CTLA_FORCE_BLANK) {\n<19> for (y = 0; y < s->height; y++)\n<20> for (x = 0; x < s->width; x++)\n<21> fputc(0, f);\n<26> for (y = 0; y < s->height; y++)\n<27> for (x = 0; x < s->width; x++, data_buffer++) {\n<29> fputc(s->color_palette[index][0], f);\n<34> fclose(f);
<1> void mi_check_print_warning ( MI_CHECK * param , const char * fmt , ... ) {\n<6> if ( param -> testflag & T_SILENT ) fprintf ( stderr , "%s: MyISAM file %s\n" , my_progname_short , param -> isam_file_name ) ;\n<11> fprintf ( stderr , "%s: warning: " , my_progname_short ) ;\n<12> ( void ) vfprintf ( stderr , fmt , args ) ;
<1> static int add_file(AVFormatContext *avf, char *filename, ConcatFile **rfile,\n<17> if (cat->safe > 0 && !safe_filename(filename)) {\n<25> url_len = strlen(avf->filename) + strlen(filename) + 16;\n<27> if (!(url = av_malloc(url_len)))\n<31> ff_make_absolute_url(url, url_len, avf->filename, filename);\n<37> if (cat->nb_files >= *nb_files_alloc) {\n<43> if (n <= cat->nb_files || n > SIZE_MAX / sizeof(*cat->files) ||\n<57> file = &cat->files[cat->nb_files++];\n<59> memset(file, 0, sizeof(*file));\n<61> *rfile = file;
<1> static int joint_decode ( COOKContext * q , COOKSubpacket * p , float * mlt_buffer_left , float * mlt_buffer_right ) {\n<6> float * decode_buffer = q -> decode_buffer_0 ;\n<10> memset ( decode_buffer , 0 , sizeof ( q -> decode_buffer_0 ) ) ;\n<11> memset ( mlt_buffer_left , 0 , 1024 * sizeof ( * mlt_buffer_left ) ) ;\n<12> memset ( mlt_buffer_right , 0 , 1024 * sizeof ( * mlt_buffer_right ) ) ;\n<14> if ( ( res = mono_decode ( q , p , decode_buffer ) ) < 0 ) return res ;\n<34> q -> decouple ( q , p , i , f1 , f2 , decode_buffer , mlt_buffer_left , mlt_buffer_right ) ;
<1> void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n<17> TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n<25> TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));
<1> static int decode_segment ( GetBitContext * gb , int mode , int32_t * decoded , int len ) {\n<4> if ( ! mode ) {\n<5> memset ( decoded , 0 , len * sizeof ( * decoded ) ) ;
<1> int tap_win32_init(VLANState *vlan, const char *model,\n<17> if (tap_win32_open(&s->handle, ifname) < 0) {\n<19> printf("tap: Could not open '%s'\n", ifname);
<1> static void add_tl_data ( krb5_int16 * n_tl_datap , krb5_tl_data * * tl_datap , krb5_int16 tl_type , krb5_ui_2 len , krb5_octet * contents ) {\n<4> copy = malloc ( len ) ;\n<5> tl_data = calloc ( 1 , sizeof ( * tl_data ) ) ;\n<6> if ( copy == NULL || tl_data == NULL ) {\n<7> fprintf ( stderr , _ ( "Not enough memory\n" ) ) ;\n<10> memcpy ( copy , contents , len ) ;\n<12> tl_data -> tl_data_length = len ;\n<13> tl_data -> tl_data_contents = copy ;\n<18> * tl_datap = tl_data ;
<1> static int chacha20_poly1305_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * inkey , const unsigned char * iv , int enc ) {\n<2> EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n<9> if ( iv != NULL ) {\n<13> if ( actx -> nonce_len <= CHACHA_CTR_SIZE ) memcpy ( temp + CHACHA_CTR_SIZE - actx -> nonce_len , iv , actx -> nonce_len ) ;
<1> static inline int onenand_erase(OneNANDState *s, int sec, int num)\n<9> blankbuf = g_malloc(512);\n<13> memset(blankbuf, 0xff, 512);\n<21> if (blk_write(s->blk_cur, sec, blankbuf, 1) < 0) {\n<27> if (blk_read(s->blk_cur, erasesec, tmpbuf, 1) < 0) {\n<33> memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);\n<43> if (sec + 1 > s->secs_cur) {\n<49> memcpy(s->current + (sec << 9), blankbuf, 512);\n<51> memcpy(s->current + (s->secs_cur << 9) + (sec << 4),\n<53> blankbuf, 1 << 4);\n<63> g_free(blankbuf);\n<73> g_free(blankbuf);
<1> static int gdv_decode_frame(AVCodecContext *avctx, void *data,\n<7> GDVContext *gdv = avctx->priv_data;\n<31> if (pal && pal_size == AVPALETTE_SIZE)\n<33> memcpy(gdv->pal, pal, AVPALETTE_SIZE);\n<49> rescale(gdv, gdv->frame, avctx->width, avctx->height,\n<55> switch (compression) {\n<59> memset(gdv->frame + PREAMBLE_SIZE, 0, gdv->frame_size - PREAMBLE_SIZE);\n<63> if (bytestream2_get_bytes_left(gb) < 256*3)\n<75> gdv->pal[i] = 0xFFU << 24 | r << 18 | g << 10 | b << 2;\n<117> memcpy(frame->data[1], gdv->pal, AVPALETTE_SIZE);
<1> static int vp9_decode_frame(AVCodecContext *ctx, void *frame,\n<11> VP9Context *s = ctx->priv_data;\n<167> if (ctx->hwaccel) {\n<197> memset(s->above_partition_ctx, 0, s->cols);\n<199> memset(s->above_skip_ctx, 0, s->cols);\n<201> if (s->s.h.keyframe || s->s.h.intraonly) {\n<203> memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n<207> memset(s->above_mode_ctx, NEARESTMV, s->cols);\n<211> memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n<213> memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);\n<215> memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);\n<217> memset(s->above_segpred_ctx, 0, s->cols);\n<247> for (m = 0; m < 6; m++)\n<249> memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],\n<273> yoff = uvoff = 0;\n<329> ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);\n<331> if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) { // marker bit\n<351> row += 8, yoff += ls_y * 64, uvoff += ls_uv * 64 >> s->ss_v) {\n<353> struct VP9Filter *lflvl_ptr = s->lflvl;\n<367> if (s->pass != 2) {\n<369> memset(s->left_partition_ctx, 0, 8);\n<371> memset(s->left_skip_ctx, 0, 8);\n<373> if (s->s.h.keyframe || s->s.h.intraonly) {\n<375> memset(s->left_mode_ctx, DC_PRED, 16);\n<379> memset(s->left_mode_ctx, NEARESTMV, 8);\n<383> memset(s->left_y_nnz_ctx, 0, 16);\n<385> memset(s->left_uv_nnz_ctx, 0, 32);\n<387> memset(s->left_segpred_ctx, 0, 8);\n<391> memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));\n<403> uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n<409> if (s->pass != 1) {\n<411> memset(lflvl_ptr->mask, 0, sizeof(lflvl_ptr->mask));\n<433> if (s->pass != 2) {\n<435> memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));\n<455> if (row + 8 < s->rows) {\n<459> f->data[0] + yoff + 63 * ls_y,\n<461> 8 * s->cols * bytesperpixel);\n<465> f->data[1] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n<467> 8 * s->cols * bytesperpixel >> s->ss_h);\n<471> f->data[2] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n<473> 8 * s->cols * bytesperpixel >> s->ss_h);\n<489> for (col = 0; col < s->cols;\n<493> uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n<495> loopfilter_sb(ctx, lflvl_ptr, row, col, yoff2, uvoff2);\n<519> adapt_probs(s);
<1> static krb5_tl_data * dup_tl_data ( krb5_tl_data * tl ) {\n<3> n = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ;\n<4> if ( n == NULL ) return NULL ;\n<5> n -> tl_data_contents = malloc ( tl -> tl_data_length ) ;\n<6> if ( n -> tl_data_contents == NULL ) {\n<7> free ( n ) ;\n<10> memcpy ( n -> tl_data_contents , tl -> tl_data_contents , tl -> tl_data_length ) ;\n<12> n -> tl_data_length = tl -> tl_data_length ;\n<14> return n ;
<1> static int targa_decode_rle ( AVCodecContext * avctx , TargaContext * s , uint8_t * dst , int w , int h , int stride , int bpp ) {\n<20> if ( ! type ) {\n<23> bytestream2_get_buffer ( & s -> gb , dst , n * depth ) ;\n<25> dst += n * depth ;\n<30> dst += diff ;\n<37> bytestream2_get_buffer ( & s -> gb , tmp , depth ) ;\n<43> memcpy ( dst , tmp , depth ) ;\n<44> dst += depth ;\n<46> while ( -- n ) ;\n<50> dst += diff ;\n<53> while ( count > 0 ) ;
<1> static int bfi_decode_frame(AVCodecContext *avctx, void *data,\n<17> uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n<35> if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n<233> src = bfi->dst;\n<235> dst = bfi->frame.data[0];\n<237> while (height--) {\n<239> memcpy(dst, src, avctx->width);\n<241> src += avctx->width;\n<243> dst += bfi->frame.linesize[0];
<1> static void init_slot ( ParallelSlot * slot , PGconn * conn , const char * progname ) {\n<5> if ( slot -> sock < 0 ) {\n<6> fprintf ( stderr , _ ( "%s: invalid socket: %s" ) , progname , PQerrorMessage ( conn ) ) ;
<1> static void http_readcb ( struct bufferevent * bev , void * arg ) {\n<2> const char * what = "This is funny" ;\n<4> if ( evbuffer_find ( bev -> input , ( const unsigned char * ) what , strlen ( what ) ) != NULL ) {
<1> int ssl23_get_client_hello ( SSL * s ) {\n<3> char * buf = & ( buf_space [ 0 ] ) ;\n<14> if ( n != sizeof buf_space ) return ( n ) ;\n<15> p = s -> packet ;\n<16> memcpy ( buf , p , n ) ;\n<17> if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {\n<18> if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) ) {\n<19> v [ 0 ] = p [ 3 ] ;\n<20> v [ 1 ] = p [ 4 ] ;\n<23> else if ( p [ 3 ] == SSL3_VERSION_MAJOR ) {\n<24> v [ 0 ] = p [ 3 ] ;\n<25> v [ 1 ] = p [ 4 ] ;\n<26> if ( p [ 4 ] >= TLS1_VERSION_MINOR ) {\n<27> if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n<31> else if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n<54> else if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) ) {\n<55> v [ 0 ] = p [ 1 ] ;\n<56> if ( p [ 3 ] == 0 && p [ 4 ] < 6 ) {\n<60> if ( p [ 9 ] > SSL3_VERSION_MAJOR ) v [ 1 ] = 0xff ;\n<61> else v [ 1 ] = p [ 10 ] ;\n<91> else if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) ) {\n<95> else if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 ) {\n<108> v [ 0 ] = p [ 3 ] ;\n<109> v [ 1 ] = p [ 4 ] ;\n<110> n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;\n<120> if ( j <= 0 ) return ( j ) ;\n<124> p += 5 ;\n<125> n2s ( p , csl ) ;\n<126> n2s ( p , sil ) ;\n<127> n2s ( p , cl ) ;\n<137> * ( d ++ ) = v [ 1 ] ;\n<138> i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl ;\n<139> memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n<140> memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n<141> d += SSL3_RANDOM_SIZE ;\n<142> * ( d ++ ) = 0 ;\n<144> dd = d ;\n<145> d += 2 ;\n<150> * ( d ++ ) = p [ i + 1 ] ;\n<151> * ( d ++ ) = p [ i + 2 ] ;\n<155> * ( d ++ ) = 1 ;\n<156> * ( d ++ ) = 0 ;
<1> static void keyid ( struct parse * pcmd , FILE * fp ) {\n<3> if ( info_auth_keyid == 0 ) ( void ) fprintf ( fp , "no keyid defined\n" ) ;\n<4> else ( void ) fprintf ( fp , "keyid is %lu\n" , ( u_long ) info_auth_keyid ) ;\n<7> if ( pcmd -> argval [ 0 ] . uval > NTP_MAXKEY ) ( void ) fprintf ( fp , "Invalid key identifier\n" ) ;
<1> int qemu_show_nic_models(const char *arg, const char *const *models)\n<9> if (!arg || strcmp(arg, "?"))\n<11> return 0;\n<15> fprintf(stderr, "qemu: Supported NIC models: ");\n<17> for (i = 0 ; models[i]; i++)\n<19> fprintf(stderr, "%s%c", models[i], models[i+1] ? ',' : '\n');\n<21> return 1;
<1> static gboolean ga_channel_open(GAChannel *c, const gchar *path, GAChannelMethod method)\n<11> switch (c->method) {\n<25> if (fd == -1) {\n<27> g_critical("error opening channel: %s", strerror(errno));\n<70> if (fd == -1) {\n<72> g_critical("error opening channel: %s", strerror(errno));\n<124> Error *local_err = NULL;\n<126> int fd = unix_listen(path, NULL, strlen(path), &local_err);\n<128> if (local_err != NULL) {\n<130> g_critical("%s", error_get_pretty(local_err));\n<132> error_free(local_err);\n<138> ga_channel_listen_add(c, fd, true);
<1> static int diffie_hellman_sha256 ( LIBSSH2_SESSION * session , _libssh2_bn * g , _libssh2_bn * p , int group_order , unsigned char packet_type_init , unsigned char packet_type_reply , unsigned char * midhash , unsigned long midhash_len , kmdhgGPshakex_state_t * exchange_state ) {\n<5> if ( exchange_state -> state == libssh2_NB_state_idle ) {\n<14> memset ( & exchange_state -> req_state , 0 , sizeof ( packet_require_state_t ) ) ;
<1> static int check_user_and_ip ( int userid , struct query * q ) {\n<12> if ( ! check_ip ) {\n<15> tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n<16> return memcmp ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;
<1> static int qio_channel_websock_handshake_process(QIOChannelWebsock *ioc,\n<47> if (!key) {\n<69> if (!g_str_equal(version, QIO_CHANNEL_WEBSOCK_SUPPORTED_VERSION)) {\n<81> if (strlen(key) != QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN) {\n<83> error_setg(errp, "Key length '%zu' was not as expected '%d'",\n<85> strlen(key), QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN);\n<93> ret = qio_channel_websock_handshake_send_response(ioc, key, errp);\n<103> g_free(key);
<1> static struct hash_list * parse_merge ( unsigned int * count ) {\n<16> else if ( ! get_sha1 ( from , n -> sha1 ) ) {\n<19> if ( ! buf || size < 46 ) die ( "Not a valid commit: %s" , from ) ;\n<20> free ( buf ) ;
<1> e1000e_write_ext_rx_descr(E1000ECore *core, uint8_t *desc,\n<11> union e1000_rx_desc_extended *d = (union e1000_rx_desc_extended *) desc;\n<15> memset(d, 0, sizeof(*d));
<1> static void update_state ( AMRContext * p ) {\n<2> memcpy ( p -> prev_lsp_sub4 , p -> lsp [ 3 ] , LP_FILTER_ORDER * sizeof ( p -> lsp [ 3 ] [ 0 ] ) ) ;\n<3> memmove ( & p -> excitation_buf [ 0 ] , & p -> excitation_buf [ AMR_SUBFRAME_SIZE ] , ( PITCH_DELAY_MAX + LP_FILTER_ORDER + 1 ) * sizeof ( float ) ) ;\n<4> memmove ( & p -> pitch_gain [ 0 ] , & p -> pitch_gain [ 1 ] , 4 * sizeof ( float ) ) ;\n<5> memmove ( & p -> fixed_gain [ 0 ] , & p -> fixed_gain [ 1 ] , 4 * sizeof ( float ) ) ;\n<6> memmove ( & p -> samples_in [ 0 ] , & p -> samples_in [ AMR_SUBFRAME_SIZE ] , LP_FILTER_ORDER * sizeof ( float ) ) ;
<1> static debugCBContext * debugCB_clone ( debugCBContext * ctx ) {\n<3> newCtx = malloc ( sizeof ( debugCBContext ) ) ;
<1> static void h245_setup_channels ( packet_info * pinfo , channel_info_t * upcoming_channel_lcl ) {\n<4> if ( ! upcoming_channel_lcl ) return ;\n<5> if ( ! strcmp ( upcoming_channel_lcl -> data_type_str , "t38fax" ) ) {\n<6> if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n<9> return ;\n<11> if ( upcoming_channel_lcl -> rfc2198 > 0 ) {\n<15> if ( upcoming_channel_lcl -> srtp_flag ) {\n<18> if ( upcoming_channel_lcl -> media_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_addr . port != 0 ) {\n<21> if ( upcoming_channel_lcl -> media_control_addr . addr . type != AT_NONE && upcoming_channel_lcl -> media_control_addr . port != 0 && rtcp_handle ) {
<1> PHP_MINIT_FUNCTION ( spl_dllist ) {\n<3> memcpy ( & spl_handler_SplDoublyLinkedList , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ;
<1> int main ( int argc , char * argv [ ] ) {\n<11> yyin = fopen ( EF_GBL_OPTIONS -> source_file , "r" ) ;\n<18> setbuf ( stdout , NULL ) ;\n<22> fprintf ( stdout , "\n Parsing source file \'%s\' " , EF_GBL_OPTIONS -> source_file ) ;\n<23> fflush ( stdout ) ;\n<25> if ( yyparse ( ) == 0 ) fprintf ( stdout , " done.\n\n" ) ;\n<26> else fprintf ( stdout , "\n\nThe script contains errors...\n\n" ) ;
<1> static int mss4_decode_dct ( GetBitContext * gb , VLC * dc_vlc , VLC * ac_vlc , int * block , int * dc_cache , int bx , int by , uint16_t * quant_mat ) {\n<3> memset ( block , 0 , sizeof ( * block ) * 64 ) ;
<1> static void test_bug6058 ( ) {\n<7> char buffer [ 30 ] ;\n<11> rc = mysql_query ( mysql , "SET SQL_MODE=''" ) ;\n<13> stmt_text = "SELECT CAST('0000-00-00' AS DATE)" ;\n<14> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<16> res = mysql_store_result ( mysql ) ;\n<17> row = mysql_fetch_row ( res ) ;\n<18> stmt = mysql_stmt_init ( mysql ) ;\n<19> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<20> check_execute ( stmt , rc ) ;\n<23> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<28> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<31> if ( ! opt_silent ) {\n<32> printf ( "Result from query: %s\n" , row [ 0 ] ) ;\n<33> printf ( "Result from prepared statement: %s\n" , buffer ) ;\n<35> DIE_UNLESS ( strcmp ( row [ 0 ] , buffer ) == 0 ) ;
<1> static void test_free_result ( ) {\n<4> char c2 [ 5 ] ;\n<16> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<22> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<26> c2 [ 0 ] = '\0' ;\n<27> l2 = 0 ;\n<35> if ( ! opt_silent ) fprintf ( stdout , "\n col 0: %s(%ld)" , c2 , l2 ) ;\n<36> DIE_UNLESS ( strncmp ( c2 , "1" , 1 ) == 0 && l2 == 1 ) ;\n<39> c1 = 0 , l2 = 0 ;\n<47> if ( ! opt_silent ) fprintf ( stdout , "\n col 0: %d(%ld)" , c1 , l2 ) ;\n<48> DIE_UNLESS ( c1 == 2 && l2 == 4 ) ;
<1> static int ogg_read_packet ( AVFormatContext * s , AVPacket * pkt ) {\n<12> ret = ogg_packet ( s , & idx , & pstart , & psize , & fpos ) ;\n<17> os = ogg -> streams + idx ;\n<19> ogg_validate_keyframe ( s , idx , pstart , psize ) ;\n<22> ret = av_new_packet ( pkt , psize ) ;\n<23> if ( ret < 0 ) return ret ;\n<25> memcpy ( pkt -> data , os -> buf + pstart , psize ) ;\n<32> uint8_t * side_data = av_packet_new_side_data ( pkt , AV_PKT_DATA_SKIP_SAMPLES , 10 ) ;\n<38> uint8_t * side_data = av_packet_new_side_data ( pkt , AV_PKT_DATA_METADATA_UPDATE , os -> new_metadata_size ) ;\n<39> if ( ! side_data ) goto fail ;\n<40> memcpy ( side_data , os -> new_metadata , os -> new_metadata_size ) ;\n<41> av_freep ( & os -> new_metadata ) ;\n<44> return psize ;\n<45> fail : av_packet_unref ( pkt ) ;
<1> void virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n<77> } else if (type & VIRTIO_BLK_T_GET_ID) {\n<95> MIN(req->elem->in_sg[0].iov_len, VIRTIO_BLK_ID_BYTES));
<1> void vp9_remove_compressor ( VP9_COMP * cpi ) {\n<4> if ( cpi && ( cpi -> common . current_video_frame > 0 ) ) {\n<26> printf ( "\n_pick_loop_filter_level:%d\n" , cpi -> time_pick_lpf / 1000 ) ;\n<27> printf ( "\n_frames recive_data encod_mb_row compress_frame Total\n" ) ;\n<28> printf ( "%6d %10ld %10ld %10ld %10ld\n" , cpi -> common . current_video_frame , cpi -> time_receive_data / 1000 , cpi -> time_encode_sb_row / 1000 , cpi -> time_compress_data / 1000 , ( cpi -> time_receive_data + cpi -> time_compress_data ) / 1000 ) ;
<1> static gboolean connfilter ( GtkTreeModel * model , GtkTreeIter * iter , gpointer * data ) {\n<7> if ( filter . host && strlen ( filter . host ) ) {\n<8> if ( src_host && ! strcasestr ( src_host , filter . host ) && dst_host && ! strcasestr ( dst_host , filter . host ) ) {
<1> void memory_region_add_eventfd(MemoryRegion *mr,\n<39> if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n<53> memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n<55> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
<1> TSReturnCode TSHttpArgIndexReserve ( const char * name , const char * description , int * arg_idx ) {\n<4> if ( ix < HTTP_SSN_TXN_MAX_USER_ARG ) {\n<5> state_arg_table [ ix ] . name = ats_strdup ( name ) ;\n<6> state_arg_table [ ix ] . name_len = strlen ( state_arg_table [ ix ] . name ) ;
<1> int ff_MPV_common_frame_size_change(MpegEncContext *s)\n<9> if (s->slice_context_count > 1) {\n<17> for (i = 1; i < s->slice_context_count; i++) {\n<19> av_freep(&s->thread_context[i]);\n<49> s->current_picture_ptr      = NULL;\n<55> if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n<57> s->mb_height = (s->height + 31) / 32 * 2;\n<61> s->mb_height = (s->height + 15) / 16;\n<65> if ((s->width || s->height) &&\n<67> av_image_check_size(s->width, s->height, 0, s->avctx))\n<73> if ((err = init_context_frame(s)))\n<83> if (s->width && s->height) {\n<89> for (i = 1; i < nb_slices; i++) {\n<91> s->thread_context[i] = av_malloc(sizeof(MpegEncContext));\n<93> memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n<101> if (init_duplicate_context(s->thread_context[i]) < 0)\n<107> (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n<111> (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n<137> ff_MPV_common_end(s);
<1> static int aasc_decode_frame(AVCodecContext *avctx,\n<14> buf      += 4;\n<20> for (i = avctx->height - 1; i >= 0; i--) {\n<21> memcpy(s->frame->data[0] + i * s->frame->linesize[0], buf, avctx->width * 3);\n<22> buf += stride;
<1> static void test_ivshmem_server(void)\n<19> memset(tmpshmem, 0x42, TMPSHMSIZE);\n<21> ret = ivshmem_server_init(&server, tmpserver, tmpshm,
<1> CharDriverState *qemu_chr_new_from_opts(QemuOpts *opts,\n<15> if (qemu_opts_id(opts) == NULL) {\n<17> fprintf(stderr, "chardev: no id specified\n");\n<25> if (qemu_opt_get(opts, "backend") == NULL) {\n<27> fprintf(stderr, "chardev: \"%s\" missing backend\n",\n<29> qemu_opts_id(opts));\n<35> for (i = 0; i < ARRAY_SIZE(backend_table); i++) {\n<37> if (strcmp(backend_table[i].name, qemu_opt_get(opts, "backend")) == 0)\n<43> if (i == ARRAY_SIZE(backend_table)) {\n<45> fprintf(stderr, "chardev: backend \"%s\" not found\n",\n<47> qemu_opt_get(opts, "backend"));\n<57> if (ret < 0) {\n<59> fprintf(stderr, "chardev: opening backend \"%s\" failed: %s\n",\n<61> qemu_opt_get(opts, "backend"), strerror(-ret));\n<79> if (qemu_opt_get_bool(opts, "mux", 0)) {\n<83> int len = strlen(qemu_opts_id(opts)) + 6;\n<85> base->label = g_malloc(len);
<1> void irc_ctcp_recv ( struct t_irc_server * server , time_t date , const char * command , struct t_irc_channel * channel , const char * address , const char * nick , const char * remote_nick , char * arguments , char * message ) {\n<8> while ( arguments && arguments [ 0 ] ) {\n<12> pos_space = strchr ( arguments + 1 , ' ' ) ;\n<15> pos_args = pos_space + 1 ;\n<20> if ( strcmp ( arguments + 1 , "ACTION" ) == 0 ) {\n<21> nick_is_me = ( irc_server_strcasecmp ( server , server -> nick , nick ) == 0 ) ;\n<22> if ( channel ) {\n<44> else if ( strcmp ( arguments + 1 , "PING" ) == 0 ) {\n<45> reply = irc_ctcp_get_reply ( server , arguments + 1 ) ;\n<46> irc_ctcp_display_request ( server , date , command , channel , nick , address , arguments + 1 , pos_args , reply ) ;\n<47> if ( ! reply || reply [ 0 ] ) {\n<51> else if ( strcmp ( arguments + 1 , "DCC" ) == 0 ) {\n<52> irc_ctcp_recv_dcc ( server , nick , pos_args , message ) ;\n<55> reply = irc_ctcp_get_reply ( server , arguments + 1 ) ;\n<56> if ( reply ) {\n<60> if ( decoded_reply ) {\n<61> irc_ctcp_reply_to_nick ( server , command , channel , nick , arguments + 1 , decoded_reply ) ;\n<62> free ( decoded_reply ) ;
<1> vreader_xfr_bytes(VReader *reader,\n<5> unsigned char *receive_buf, int *receive_buf_len)\n<11> VCardResponse *response = NULL;\n<33> response = vcard_make_response(status);\n<61> if (card_status == VCARD_DONE) {\n<63> int size = MIN(*receive_buf_len, response->b_total_len);\n<65> memcpy(receive_buf, response->b_data, size);\n<67> *receive_buf_len = size;\n<71> vcard_response_delete(response);
<1> static void auth_server_connection_input ( struct auth_server_connection * conn ) {\n<5> switch ( i_stream_read ( conn -> input ) ) {\n<7> case - 1 : error = conn -> input -> stream_errno != 0 ? strerror ( conn -> input -> stream_errno ) : "EOF" ;
<1> static void vp8_decode_flush_impl(AVCodecContext *avctx, int force, int is_close)\n<5> VP8Context *s = avctx->priv_data;\n<17> vp8_release_frame(s, &s->frames[i], is_close);\n<21> memset(s->framep, 0, sizeof(s->framep));\n<25> free_buffers(s);
<1> static int64_t realloc_refcount_block(BlockDriverState *bs, int reftable_index,\n<21> if (new_offset < 0) {\n<23> fprintf(stderr, "Could not allocate new cluster: %s\n",\n<25> strerror(-new_offset));\n<39> if (ret < 0) {\n<41> fprintf(stderr, "Could not fetch refcount block: %s\n", strerror(-ret));\n<55> if (ret < 0) {\n<57> fprintf(stderr, "Could not write refcount block; metadata overlap "\n<59> "check failed: %s\n", strerror(-ret));\n<79> if (ret < 0) {\n<81> fprintf(stderr, "Could not write refcount block: %s\n", strerror(-ret));\n<97> if (ret < 0) {\n<99> fprintf(stderr, "Could not update refcount table: %s\n",\n<101> strerror(-ret));
<1> int main_loop(void *opaque)\n<123> n = read(net_fd, buf, MAX_ETH_FRAME_SIZE);\n<127> if (n < 60) {\n<129> memset(buf + n, 0, 60 - n);
<1> static void vc1_decode_p_blocks ( VC1Context * v ) {\n<22> memset ( v -> cbp_base , 0 , sizeof ( v -> cbp_base [ 0 ] ) * 2 * s -> mb_stride ) ;\n<29> s -> mb_x < s -> mb_width ;\n<32> if ( v -> fcm == ILACE_FIELD ) vc1_decode_p_mb_intfi ( v ) ;\n<33> else if ( v -> fcm == ILACE_FRAME ) vc1_decode_p_mb_intfr ( v ) ;\n<34> else vc1_decode_p_mb ( v ) ;\n<35> if ( s -> mb_y != s -> start_mb_y && apply_loop_filter && v -> fcm == PROGRESSIVE ) vc1_apply_p_loop_filter ( v ) ;\n<42> memmove ( v -> cbp_base , v -> cbp , sizeof ( v -> cbp_base [ 0 ] ) * s -> mb_stride ) ;\n<43> memmove ( v -> ttblk_base , v -> ttblk , sizeof ( v -> ttblk_base [ 0 ] ) * s -> mb_stride ) ;\n<44> memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;\n<45> memmove ( v -> luma_mv_base , v -> luma_mv , sizeof ( v -> luma_mv_base [ 0 ] ) * s -> mb_stride ) ;\n<56> vc1_apply_p_loop_filter ( v ) ;
<1> int encode_msg ( struct sip_msg * msg , char * payload , int len ) {\n<9> if ( len < MAX_ENCODED_MSG + MAX_MESSAGE_LEN ) return - 1 ;\n<10> if ( parse_headers ( msg , HDR_EOH_F , 0 ) < 0 ) {\n<14> memset ( payload , 0 , len ) ;\n<30> if ( h == 32 ) {\n<34> h = htons ( h ) ;\n<35> memcpy ( payload , & h , 2 ) ;\n<36> h = htons ( ( unsigned short int ) msg -> len ) ;\n<37> memcpy ( & payload [ MSG_LEN_IDX ] , & h , 2 ) ;\n<38> if ( 0 > ( diff = ( get_body ( msg ) - ( msg -> buf ) ) ) ) {\n<42> else h = htons ( ( unsigned short int ) diff ) ;\n<43> memcpy ( payload + CONTENT_IDX , & h , 2 ) ;\n<44> payload [ METHOD_CODE_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . method . s - msg -> buf ) : ( ms -> u . reply . status . s - msg -> buf ) ) ;\n<45> payload [ METHOD_CODE_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . method . len ) : ( ms -> u . reply . status . len ) ) ;\n<46> payload [ URI_REASON_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . s - msg -> buf ) : ( ms -> u . reply . reason . s - msg -> buf ) ) ;\n<47> payload [ URI_REASON_IDX + 1 ] = ( unsigned char ) ( request ? ( ms -> u . request . uri . len ) : ( ms -> u . reply . reason . len ) ) ;\n<48> payload [ VERSION_IDX ] = ( unsigned char ) ( request ? ( ms -> u . request . version . s - msg -> buf ) : ( ms -> u . reply . version . s - msg -> buf ) ) ;\n<55> if ( 0 > ( j = encode_uri2 ( msg -> buf , ms -> u . request . method . s - msg -> buf + ms -> len , ms -> u . request . uri , & miuri , ( unsigned char * ) & payload [ REQUEST_URI_IDX + 1 ] ) ) ) {\n<59> payload [ REQUEST_URI_IDX ] = ( unsigned char ) j ;\n<71> hf ;\n<73> payload [ k ] = ( unsigned char ) ( hf -> type & 0xFF ) ;\n<74> h = htons ( j ) ;\n<75> memcpy ( & payload [ k + 1 ] , & h , 2 ) ;\n<76> if ( 0 > ( i = encode_header ( msg , hf , ( unsigned char * ) ( payload + j ) , MAX_ENCODED_MSG + MAX_MESSAGE_LEN - j ) ) ) {\n<85> j = htons ( j ) ;\n<86> memcpy ( & payload [ k + 1 ] , & j , 2 ) ;\n<88> j = ntohs ( j ) ;\n<89> if ( len < j + msg -> len + 1 ) {\n<93> memcpy ( & payload [ j ] , msg -> buf , msg -> len ) ;\n<94> LM_DBG ( "msglen = %d,msg starts at %d\n" , msg -> len , j ) ;\n<95> j = htons ( j ) ;\n<96> memcpy ( & payload [ MSG_START_IDX ] , & j , 2 ) ;\n<97> return GET_PAY_SIZE ( payload ) ;
<1> static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,\n<93> for (i = 4; *ptr1 == 0xF8; i++, ptr1++) {\n<115> memmove(q->weighting_delay[js_pair], &q->weighting_delay[js_pair][2],\n<117> 4 * sizeof(*q->weighting_delay[js_pair]));\n<119> q->weighting_delay[js_pair][4] = get_bits1(&q->gb);\n<121> q->weighting_delay[js_pair][5] = get_bits(&q->gb, 3);\n<159> channel_weighting(out_samples[ch], out_samples[ch+1], q->weighting_delay[js_pair]);
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<48> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> static int m25p80_init(SSISlave *ss)\n<9> M25P80Class *mc = M25P80_GET_CLASS(s);\n<21> s->storage = blk_blockalign(s->blk, s->size);\n<31> if (dinfo) {\n<47> fprintf(stderr, "Failed to initialize SPI flash!\n");\n<57> memset(s->storage, 0xFF, s->size);
<10> if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;\n<21> if ( base -> sig . sh_old ) {\n<22> free ( base -> sig . sh_old ) ;
<1> static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n<5> union viosrp_iu *iu = &req->iu;\n<23> memset(iu, 0, sizeof(struct srp_login_rsp));
<1> static int g723_1_decode_frame(AVCodecContext *avctx, void *data,\n<7> G723_1_Context *p  = avctx->priv_data;\n<15> int dec_mode       = buf[0] & 3;\n<53> if (unpack_bitstream(p, buf, buf_size) < 0) {\n<71> if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n<81> if (p->cur_frame_type == ACTIVE_FRAME) {\n<95> ff_g723_1_lsp_interpolate(lpc, cur_lsp, p->prev_lsp);\n<101> memcpy(p->prev_lsp, cur_lsp, LPC_ORDER * sizeof(*p->prev_lsp));\n<109> PITCH_MAX * sizeof(*p->excitation));\n<111> if (!p->erased_frames) {\n<113> int16_t *vector_ptr = p->excitation + PITCH_MAX;\n<153> vector_ptr = p->excitation + PITCH_MAX;\n<201> memcpy(p->prev_excitation, p->excitation + FRAME_LEN,\n<203> PITCH_MAX * sizeof(*p->excitation));\n<209> if (p->erased_frames == 3) {\n<215> (FRAME_LEN + PITCH_MAX) * sizeof(*p->excitation));\n<219> PITCH_MAX * sizeof(*p->excitation));\n<223> (FRAME_LEN + LPC_ORDER) * sizeof(int16_t));\n<233> residual_interp(p->excitation, buf, p->interp_index,\n<241> memcpy(p->prev_excitation, buf + (FRAME_LEN - PITCH_MAX),\n<243> PITCH_MAX * sizeof(*p->excitation));\n<275> generate_noise(p);\n<277> ff_g723_1_lsp_interpolate(lpc, p->sid_lsp, p->prev_lsp);\n<281> memcpy(p->prev_lsp, p->sid_lsp, LPC_ORDER * sizeof(*p->prev_lsp));\n<291> memcpy(p->audio, p->synth_mem, LPC_ORDER * sizeof(*p->audio));\n<295> ff_celp_lp_synthesis_filter(p->audio + i, &lpc[j * LPC_ORDER],\n<301> memcpy(p->synth_mem, p->audio + FRAME_LEN, LPC_ORDER * sizeof(*p->audio));\n<307> formant_postfilter(p, lpc, p->audio, out);
<1> static void handle_ns_request ( int dns_fd , struct query * q ) {\n<4> if ( ns_ip != INADDR_ANY ) {\n<5> memcpy ( & q -> destination . s_addr , & ns_ip , sizeof ( in_addr_t ) ) ;\n<7> len = dns_encode_ns_response ( buf , sizeof ( buf ) , q , topdomain ) ;\n<8> if ( len < 1 ) {\n<12> if ( debug >= 2 ) {\n<13> fprintf ( stderr , "TX: client %s, type %d, name %s, %d bytes NS reply\n" , format_addr ( & q -> from , q -> fromlen ) , q -> type , q -> name , len ) ;\n<15> if ( sendto ( dns_fd , buf , len , 0 , ( struct sockaddr * ) & q -> from , q -> fromlen ) <= 0 ) {
<1> static int ogg_save(AVFormatContext *s)\n<5> struct ogg *ogg = s->priv_data;\n<21> memcpy(ost->streams, ogg->streams, ogg->nstreams * sizeof(*ogg->streams));\n<25> for (i = 0; i < ogg->nstreams; i++){\n<27> struct ogg_stream *os = ogg->streams + i;\n<29> os->buf = av_malloc (os->bufsize);\n<31> memset (os->buf, 0, os->bufsize);\n<33> memcpy (os->buf, ost->streams[i].buf, os->bufpos);\n<39> ogg->state = ost;
<1> void print_version ( void ) {\n<2> printf ( "%s Ver %s Distrib %s, for %s (%s)\n" , my_progname , MTEST_VERSION , MYSQL_SERVER_VERSION , SYSTEM_TYPE , MACHINE_TYPE ) ;
<1> void ff_rtp_send_h263(AVFormatContext *s1, const uint8_t *buf1, int size)\n<17> while (size > 0) {\n<21> if ((buf1[0] == 0) && (buf1[1] == 0)) {\n<25> buf1 += 2;\n<35> *q++ = 0;\n<45> if (len < size) {\n<49> len = end - buf1;\n<55> memcpy(q, buf1, len);\n<57> q += len;\n<65> ff_rtp_send_data(s1, s->buf, q - s->buf, (len == size));\n<69> buf1 += len;
<4> i < table -> n_labels ;\n<5> ++ i ) free ( table -> labels [ i ] . v ) ;
<1> static void msvideo1_decode_8bit ( Msvideo1Context * s ) {\n<13> unsigned char colors [ 8 ] ;\n<47> colors [ 0 ] = s -> buf [ stream_ptr ++ ] ;\n<48> colors [ 1 ] = s -> buf [ stream_ptr ++ ] ;\n<54> pixel_x ++ , flags >>= 1 ) pixels [ pixel_ptr ++ ] = colors [ ( flags & 0x1 ) ^ 1 ] ;\n<58> else if ( byte_b >= 0x90 ) {\n<61> memcpy ( colors , & s -> buf [ stream_ptr ] , 8 ) ;\n<68> pixel_x ++ , flags >>= 1 ) pixels [ pixel_ptr ++ ] = colors [ ( ( pixel_y & 0x2 ) << 1 ) + ( pixel_x & 0x2 ) + ( ( flags & 0x1 ) ^ 1 ) ] ;\n<73> colors [ 0 ] = byte_a ;\n<79> pixel_x ++ ) pixels [ pixel_ptr ++ ] = colors [ 0 ] ;\n<87> if ( s -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;
<1> static void pbase_tree_put ( struct pbase_tree_cache * cache ) {\n<2> if ( ! cache -> temporary ) {\n<6> free ( cache -> tree_data ) ;\n<7> free ( cache ) ;
<1> static int slirp_guestfwd ( SlirpState * s , const char * config_str , int legacy_format ) {\n<10> p = config_str ;\n<12> if ( get_str_sep ( buf , sizeof ( buf ) , & p , ':' ) < 0 ) {\n<17> if ( get_str_sep ( buf , sizeof ( buf ) , & p , ':' ) < 0 ) {\n<20> if ( strcmp ( buf , "tcp" ) && buf [ 0 ] != '\0' ) {\n<23> if ( get_str_sep ( buf , sizeof ( buf ) , & p , ':' ) < 0 ) {\n<29> if ( get_str_sep ( buf , sizeof ( buf ) , & p , '-' ) < 0 ) {\n<34> if ( * end != '\0' || port < 1 || port > 65535 ) {\n<38> if ( ( strlen ( p ) > 4 ) && ! strncmp ( p , "cmd:" , 4 ) ) {\n<39> if ( slirp_add_exec ( s -> slirp , 0 , & p [ 4 ] , & server , port ) < 0 ) {\n<46> fwd -> hd = qemu_chr_new ( buf , p , NULL ) ;\n<47> if ( ! fwd -> hd ) {\n<64> fail_syntax : error_report ( "invalid guest forwarding rule '%s'" , config_str ) ;\n<65> return - 1 ;
<1> static uint64_t mpc8544_guts_read ( void * opaque , hwaddr addr , unsigned size ) {\n<5> addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;\n<6> switch ( addr ) {\n<11> default : fprintf ( stderr , "guts: Unknown register read: %x\n" , ( int ) addr ) ;
<1> static int sap_write_header(AVFormatContext *s)\n<261> if (!sap->ann) {\n<269> sap->ann[pos] = (1 << 5);\n<283> AV_WB16(&sap->ann[pos], av_get_random_seed());\n<287> if (localaddr.ss_family == AF_INET) {\n<289> memcpy(&sap->ann[pos], &((struct sockaddr_in*)&localaddr)->sin_addr,\n<311> av_strlcpy(&sap->ann[pos], "application/sdp", sap->ann_size - pos);\n<313> pos += strlen(&sap->ann[pos]) + 1;\n<317> if (av_sdp_create(contexts, s->nb_streams, &sap->ann[pos],\n<319> sap->ann_size - pos)) {\n<329> av_log(s, AV_LOG_VERBOSE, "SDP:\n%s\n", &sap->ann[pos]);\n<331> pos += strlen(&sap->ann[pos]);\n<333> sap->ann_size = pos;
<1> static void simpleCopy(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,\n<9> uint8_t *src[3];\n<11> uint8_t *dst[3];\n<17> src[0]= srcParam[0];\n<33> src[0]= srcParam[0];\n<49> src[0]= srcParam[0];\n<67> dst[0]= dstParam[0];\n<77> dst[0]= dstParam[0];\n<91> if(dstStride[0]==srcStride[0])\n<93> memcpy(dst[0] + dstStride[0]*srcSliceY, src[0], srcSliceH*dstStride[0]);\n<101> uint8_t *srcPtr= src[0];\n<103> uint8_t *dstPtr= dst[0] + dstStride[0]*srcSliceY;\n<115> ASSERT(length!=0);\n<119> for(i=0; i<srcSliceH; i++)\n<123> memcpy(dstPtr, srcPtr, length);\n<125> srcPtr+= srcStride[0];\n<127> dstPtr+= dstStride[0];\n<145> int length= plane==0 ? c->srcW  : ((c->srcW+1)>>1);\n<153> if(dstStride[plane]==srcStride[plane])\n<155> memcpy(dst[plane] + dstStride[plane]*y, src[plane], height*dstStride[plane]);\n<163> uint8_t *srcPtr= src[plane];\n<165> uint8_t *dstPtr= dst[plane] + dstStride[plane]*y;\n<167> for(i=0; i<height; i++)\n<171> memcpy(dstPtr, srcPtr, length);\n<173> srcPtr+= srcStride[plane];\n<175> dstPtr+= dstStride[plane];
<1> static struct branch * new_branch ( const char * name ) {\n<2> unsigned int hc = hc_str ( name , strlen ( name ) ) % branch_table_sz ;\n<3> struct branch * b = lookup_branch ( name ) ;
<1> static void write_pack_file ( void ) {\n<9> written_list = xmalloc ( to_pack . nr_objects * sizeof ( * written_list ) ) ;\n<10> write_order = compute_write_order ( ) ;\n<15> else f = create_tmp_packfile ( & pack_tmp_name ) ;\n<43> if ( ! pack_to_stdout ) {\n<46> if ( stat ( pack_tmp_name , & st ) < 0 ) {\n<47> warning ( "failed to stat %s: %s" , pack_tmp_name , strerror ( errno ) ) ;\n<56> if ( utime ( pack_tmp_name , & utb ) < 0 ) warning ( "failed utime() on %s: %s" , pack_tmp_name , strerror ( errno ) ) ;\n<63> finish_tmp_packfile ( & tmpname , pack_tmp_name , written_list , nr_written , & pack_idx_opts , sha1 ) ;\n<71> bitmap_writer_finish ( written_list , nr_written , tmpname . buf , write_bitmap_options ) ;\n<75> free ( pack_tmp_name ) ;\n<86> free ( written_list ) ;\n<87> free ( write_order ) ;
<1> int net_init_tap(QemuOpts *opts, Monitor *mon, const char *name, VLANState *vlan)\n<95> if (qemu_opt_get(opts, "fd")) {\n<113> snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n<121> if (strcmp(downscript, "no") != 0) {\n<123> snprintf(s->down_script, sizeof(s->down_script), "%s", downscript);\n<125> snprintf(s->down_script_arg, sizeof(s->down_script_arg), "%s", ifname);
<257> if ( FIELD_PICTURE ( h ) ) {\n<259> i < h -> mb_height ;\n<260> i ++ ) memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ) ;\n<263> memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ) ;\n<267> if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 ) return ret ;\n<276> if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num ) {\n<281> h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ) ;\n<301> ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ) ;\n<303> ret = ff_set_ref_count ( h ) ;\n<305> if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) ) {\n<306> ff_h264_fill_default_ref_list ( h ) ;\n<309> ret = ff_h264_decode_ref_pic_list_reordering ( h ) ;\n<315> if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) ) ff_pred_weight_table ( h ) ;\n<317> implicit_weight_table ( h , - 1 ) ;\n<329> ret = ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) ;\n<332> if ( FRAME_MBAFF ( h ) ) {\n<333> ff_h264_fill_mbaff_ref_list ( h ) ;\n<335> implicit_weight_table ( h , 0 ) ;\n<336> implicit_weight_table ( h , 1 ) ;\n<339> if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred ) ff_h264_direct_dist_scale_factor ( h ) ;\n<340> ff_h264_direct_ref_list_init ( h ) ;\n<356> h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ;\n<357> h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ;\n<381> if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 ) {\n<382> if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST ) {\n<391> if ( h != h0 ) {\n<399> memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ) ;
<1> static void construct_path_with_fanout ( const char * hex_sha1 , unsigned char fanout , char * path ) {\n<2> unsigned int i = 0 , j = 0 ;\n<6> path [ i ++ ] = hex_sha1 [ j ++ ] ;\n<7> path [ i ++ ] = '/' ;\n<10> memcpy ( path + i , hex_sha1 + j , 40 - j ) ;
<1> void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n<11> while (list) {\n<12> if (strcmp(list->value->type, "stream") == 0) {
<1> static void test_ivshmem_pair(void)\n<23> data = g_malloc0(TMPSHMSIZE);\n<29> memset(tmpshmem, 0x42, TMPSHMSIZE);\n<31> qtest_memread(s1->qtest, (uintptr_t)s1->mem_base, data, TMPSHMSIZE);\n<39> qtest_memread(s2->qtest, (uintptr_t)s2->mem_base, data, TMPSHMSIZE);\n<41> for (i = 0; i < TMPSHMSIZE; i++) {\n<51> memset(data, 0x43, TMPSHMSIZE);\n<53> qtest_memwrite(s1->qtest, (uintptr_t)s1->mem_base, data, TMPSHMSIZE);\n<55> memset(data, 0, TMPSHMSIZE);\n<57> qtest_memread(s2->qtest, (uintptr_t)s2->mem_base, data, TMPSHMSIZE);\n<59> for (i = 0; i < TMPSHMSIZE; i++) {\n<69> memset(data, 0x44, TMPSHMSIZE);\n<71> qtest_memwrite(s2->qtest, (uintptr_t)s2->mem_base, data, TMPSHMSIZE);\n<73> memset(data, 0, TMPSHMSIZE);\n<75> qtest_memread(s1->qtest, (uintptr_t)s2->mem_base, data, TMPSHMSIZE);
<1> static int qcow_create(const char *filename, QemuOpts *opts, Error **errp)\n<51> backing_file = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n<113> if (ret < 0) {\n<121> memset(&header, 0, sizeof(header));\n<133> if (backing_file) {\n<135> if (strcmp(backing_file, "fat:")) {\n<137> header.backing_file_offset = cpu_to_be64(header_size);\n<139> backing_filename_len = strlen(backing_file);\n<141> header.backing_file_size = cpu_to_be32(backing_filename_len);\n<143> header_size += backing_filename_len;\n<149> g_free(backing_file);\n<151> backing_file = NULL;\n<241> ret = blk_pwrite(qcow_blk, 0, &header, sizeof(header), 0);\n<305> g_free(backing_file);
<1> static PyObject * string_richcompare ( PyStringObject * a , PyStringObject * b , int op ) {\n<19> if ( Py_SIZE ( a ) == Py_SIZE ( b ) && ( a -> ob_sval [ 0 ] == b -> ob_sval [ 0 ] && memcmp ( a -> ob_sval , b -> ob_sval , Py_SIZE ( a ) ) == 0 ) ) {\n<27> len_a = Py_SIZE ( a ) ;\n<28> len_b = Py_SIZE ( b ) ;\n<30> if ( min_len > 0 ) {\n<31> c = Py_CHARMASK ( * a -> ob_sval ) - Py_CHARMASK ( * b -> ob_sval ) ;\n<32> if ( c == 0 ) c = memcmp ( a -> ob_sval , b -> ob_sval , min_len ) ;\n<35> if ( c == 0 ) c = ( len_a < len_b ) ? - 1 : ( len_a > len_b ) ? 1 : 0 ;
<1> static void *spapr_create_fdt_skel(const char *cpu_model,\n<259> modelname = g_strdup(cpu_model);\n<263> for (i = 0; i < strlen(modelname); i++) {\n<265> modelname[i] = toupper(modelname[i]);\n<273> spapr->cpu_model = g_strdup(modelname);\n<297> if ((index % smt) != 0) {\n<305> if (asprintf(&nodename, "%s@%x", modelname, index) < 0) {\n<307> fprintf(stderr, "Allocation failure\n");\n<309> exit(1);\n<319> free(nodename);\n<359> servers_prop[i] = cpu_to_be32(index + i);\n<429> g_free(modelname);
<1> int remoteDispatchClientRequest ( struct qemud_server * server , struct qemud_client * client , struct qemud_client_message * msg ) {\n<6> memset ( & rerr , 0 , sizeof rerr ) ;\n<10> remoteDispatchFormatError ( & rerr , _ ( "program mismatch (actual %x, expected %x or %x)" ) , msg -> hdr . prog , REMOTE_PROGRAM , QEMU_PROGRAM ) ;\n<14> remoteDispatchFormatError ( & rerr , _ ( "version mismatch (actual %x, expected %x)" ) , msg -> hdr . vers , REMOTE_PROTOCOL_VERSION ) ;\n<18> remoteDispatchFormatError ( & rerr , _ ( "version mismatch (actual %x, expected %x)" ) , msg -> hdr . vers , QEMU_PROTOCOL_VERSION ) ;\n<26> default : remoteDispatchFormatError ( & rerr , _ ( "type (%d) != REMOTE_CALL" ) , ( int ) msg -> hdr . type ) ;\n<30> error : ret = remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
<1> static void opt_frame_pix_fmt(const char *arg)\n<5> if (strcmp(arg, "list"))\n<7> frame_pix_fmt = avcodec_get_pix_fmt(arg);\n<11> list_fmts(avcodec_pix_fmt_string, PIX_FMT_NB);\n<13> av_exit(0);
<1> int configure_filtergraph(FilterGraph *fg)\n<23> if (simple) {\n<35> fg->graph->scale_sws_opts = av_strdup(args);\n<39> args[0] = '\0';\n<45> av_strlcatf(args, sizeof(args), "%s=%s:", e->key, e->value);\n<49> if (strlen(args))\n<51> args[strlen(args) - 1] = '\0';\n<53> fg->graph->resample_lavr_opts = av_strdup(args);
<1> static gpgme_error_t status_handler ( void * opaque , int fd ) {\n<8> err = assuan_read_line ( gpgsm -> assuan_ctx , & line , & linelen ) ;\n<12> else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\0' || line [ 3 ] == ' ' ) ) {\n<13> if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n<17> else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\0' || line [ 2 ] == ' ' ) ) {\n<27> else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> colon . fnc ) {\n<33> if ( gpgsm -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n<34> char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n<35> if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n<37> * aline = newline ;\n<42> dst = * aline + * alinelen ;\n<58> err = gpgsm -> colon . fnc ( gpgsm -> colon . fnc_value , * aline ) ;\n<70> else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && gpgsm -> inline_data ) {\n<98> else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n<101> rest = strchr ( line + 2 , ' ' ) ;\n<102> if ( ! rest ) rest = line + linelen ;\n<103> else * ( rest ++ ) = 0 ;\n<105> if ( r >= 0 ) {\n<108> else fprintf ( stderr , "[UNKNOWN STATUS]%s %s" , line + 2 , rest ) ;\n<111> else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\0' || line [ 7 ] == ' ' ) ) {
<1> static void tlb_flush_by_mmuidx_async_work(CPUState *cpu, run_on_cpu_data data)\n<13> assert_cpu_is_self(cpu);\n<29> if (test_bit(mmu_idx, &mmu_idx_bitmask)) {\n<35> memset(env->tlb_table[mmu_idx], -1, sizeof(env->tlb_table[0]));\n<37> memset(env->tlb_v_table[mmu_idx], -1, sizeof(env->tlb_v_table[0]));\n<45> memset(cpu->tb_jmp_cache, 0, sizeof(cpu->tb_jmp_cache));
<1> static int matroska_parse_frame ( MatroskaDemuxContext * matroska , MatroskaTrack * track , AVStream * st , uint8_t * data , int pkt_size , uint64_t timecode , uint64_t duration , int64_t pos , int is_keyframe ) {\n<3> uint8_t * pkt_data = data ;\n<4> int offset = 0 , res ;\n<7> res = matroska_decode_buffer ( & pkt_data , & pkt_size , track ) ;\n<12> res = matroska_parse_wavpack ( track , pkt_data , & wv_data , & pkt_size ) ;\n<17> if ( pkt_data != data ) av_freep ( & pkt_data ) ;\n<18> pkt_data = wv_data ;\n<20> if ( st -> codec -> codec_id == AV_CODEC_ID_PRORES ) offset = 8 ;\n<22> if ( av_new_packet ( pkt , pkt_size + offset ) < 0 ) {\n<29> bytestream_put_be32 ( & buf , pkt_size ) ;\n<32> memcpy ( pkt -> data + offset , pkt_data , pkt_size ) ;\n<33> if ( pkt_data != data ) av_free ( pkt_data ) ;
<2> if ( dcfg == NULL ) return ;\n<64> if ( dcfg -> crypto_key == NOT_SET_P ) dcfg -> crypto_key = getkey ( dcfg -> mp ) ;\n<65> if ( dcfg -> crypto_key_len == NOT_SET ) dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ;
<1> static int cdg_decode_frame(AVCodecContext *avctx,\n<45> if (!avctx->frame_number) {\n<47> memset(cc->frame->data[0], 0, cc->frame->linesize[0] * avctx->height);\n<49> memset(cc->frame->data[1], 0, AVPALETTE_SIZE);\n<77> if (!(cdg_data[1] & 0x0F))\n<79> memset(cc->frame->data[0], cdg_data[0] & 0x0F,\n<81> cc->frame->linesize[0] * CDG_FULL_HEIGHT);
<1> static void ne2000_receive(void *opaque, const uint8_t *buf, int size)\n<11> uint8_t buf1[60];\n<27> if (!ne2000_can_receive(s))\n<35> if (s->rxcr & 0x10) {\n<41> if (!memcmp(buf,  broadcast_macaddr, 6)) {\n<45> if (!(s->rxcr & 0x04))\n<49> } else if (buf[0] & 0x01) {\n<57> mcast_idx = compute_mcast_idx(buf);\n<63> } else if (s->mem[0] == buf[0] &&\n<65> s->mem[2] == buf[1] &&\n<67> s->mem[4] == buf[2] &&\n<69> s->mem[6] == buf[3] &&\n<71> s->mem[8] == buf[4] &&\n<73> s->mem[10] == buf[5]) {\n<91> if (size < MIN_BUF_SIZE) {\n<93> memcpy(buf1, buf, size);\n<95> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<97> buf = buf1;\n<127> if (buf[0] & 0x01)\n<145> while (size > 0) {\n<147> avail = s->stop - index;\n<151> if (len > avail)\n<153> len = avail;\n<155> memcpy(s->mem + index, buf, len);\n<157> buf += len;\n<159> index += len;\n<165> size -= len;
<1> void write_video_frame(AVFormatContext *oc, AVStream *st)\n<57> if (av_write_frame(oc, st->index, video_outbuf, out_size) != 0) {\n<59> fprintf(stderr, "Error while writing video frame\n");
<1> static void vnc_update_client(void *opaque)\n<55> ptr = row;\n<57> old_ptr = (char*)old_row;\n<61> for (x = 0; x < ds_get_width(vs->ds); x += 16) {\n<63> if (memcmp(old_ptr, ptr, 16 * ds_get_bytes_per_pixel(vs->ds)) == 0) {\n<65> vnc_clear_bit(vs->dirty_row[y], (x / 16));\n<69> has_dirty = 1;\n<71> memcpy(old_ptr, ptr, 16 * ds_get_bytes_per_pixel(vs->ds));\n<77> ptr += 16 * ds_get_bytes_per_pixel(vs->ds);\n<79> old_ptr += 16 * ds_get_bytes_per_pixel(vs->ds);
<1> void cpu_loop(CPUARMState *env)\n<19> trapnr = cpu_arm_exec(env);\n<21> cpu_exec_end(env);\n<173> env->eabi = 1;\n<177> if (trapnr == EXCP_BKPT) {\n<237> || (env->thumb && n == ARM_THUMB_SYSCALL)) {\n<381> if (do_kernel_trap(env))\n<403> fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n",\n<407> cpu_dump_state(env, stderr, fprintf, 0);\n<413> process_pending_signals(env);
<109> if ((i > 0) && !(frame_flags & 0x01)) {\n<111> memcpy (s->strips[i].v4_codebook, s->strips[i-1].v4_codebook,\n<115> memcpy (s->strips[i].v1_codebook, s->strips[i-1].v1_codebook,\n<123> result = cinepak_decode_strip (s, &s->strips[i], s->data, strip_size);
<3> if ( ! xmlrpc . inttagstart || ! xmlrpc . inttagend ) {\n<7> snprintf ( buf , XMLRPC_BUFSIZE , "%s%d%s" , xmlrpc . inttagstart , value , xmlrpc . inttagend ) ;\n<8> free ( xmlrpc . inttagstart ) ;\n<9> if ( xmlrpc . inttagend ) {\n<10> free ( xmlrpc . inttagend ) ;
<1> static int decode_segment(TAKDecContext *s, int8_t mode, int32_t *decoded, int len)\n<13> if (!mode) {\n<15> memset(decoded, 0, len * sizeof(*decoded));
<1> static void vfio_pci_load_rom(VFIODevice *vdev)\n<49> if (!vdev->rom_size) {\n<72> vdev->rom = g_malloc(size);\n<74> memset(vdev->rom, 0xff, size);\n<80> bytes = pread(vdev->fd, vdev->rom + off, size, vdev->rom_offset + off);
<1> enum message_read_status evhttp_parse_headers ( struct evhttp_request * req , struct evbuffer * buffer ) {\n<5> while ( ( line = evbuffer_readline ( buffer ) ) != NULL ) {\n<7> if ( * line == '\0' ) {\n<9> free ( line ) ;\n<12> if ( * line == ' ' || * line == '\t' ) {\n<13> if ( evhttp_append_to_last_header ( headers , line ) == - 1 ) goto error ;\n<14> free ( line ) ;\n<18> skey = strsep ( & svalue , ":" ) ;\n<19> if ( svalue == NULL ) goto error ;\n<20> svalue += strspn ( svalue , " " ) ;\n<21> if ( evhttp_add_header ( headers , skey , svalue ) == - 1 ) goto error ;\n<22> free ( line ) ;\n<25> error : free ( line ) ;
<1> static void test_sqlmode ( ) {\n<12> strmov ( query , "SET SQL_MODE= \"PIPES_AS_CONCAT\"" ) ;\n<13> if ( ! opt_silent ) fprintf ( stdout , "\n With %s" , query ) ;\n<14> rc = mysql_query ( mysql , query ) ;\n<16> strmov ( query , "INSERT INTO test_piping VALUES(?||?)" ) ;\n<17> if ( ! opt_silent ) fprintf ( stdout , "\n query: %s" , query ) ;\n<18> stmt = mysql_simple_prepare ( mysql , query ) ;\n<20> if ( ! opt_silent ) fprintf ( stdout , "\n total parameters: %ld" , mysql_stmt_param_count ( stmt ) ) ;\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<28> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<38> strmov ( query , "SELECT connection_id ()" ) ;\n<39> if ( ! opt_silent ) fprintf ( stdout , "\n query: %s" , query ) ;\n<40> stmt = mysql_simple_prepare ( mysql , query ) ;\n<43> strmov ( query , "SET SQL_MODE= \"ANSI\"" ) ;\n<44> if ( ! opt_silent ) fprintf ( stdout , "\n With %s" , query ) ;\n<45> rc = mysql_query ( mysql , query ) ;\n<47> strmov ( query , "INSERT INTO test_piping VALUES(?||?)" ) ;\n<48> if ( ! opt_silent ) fprintf ( stdout , "\n query: %s" , query ) ;\n<49> stmt = mysql_simple_prepare ( mysql , query ) ;\n<51> if ( ! opt_silent ) fprintf ( stdout , "\n total parameters: %ld" , mysql_stmt_param_count ( stmt ) ) ;\n<60> strmov ( query , "SELECT connection_id ()" ) ;\n<61> if ( ! opt_silent ) fprintf ( stdout , "\n query: %s" , query ) ;\n<62> stmt = mysql_simple_prepare ( mysql , query ) ;\n<70> if ( ! opt_silent ) fprintf ( stdout , "\n returned 1 row\n" ) ;\n<72> strmov ( query , "SET SQL_MODE= \"IGNORE_SPACE\"" ) ;\n<73> if ( ! opt_silent ) fprintf ( stdout , "\n With %s" , query ) ;\n<74> rc = mysql_query ( mysql , query ) ;\n<76> strmov ( query , "SELECT connection_id ()" ) ;\n<77> if ( ! opt_silent ) fprintf ( stdout , "\n query: %s" , query ) ;\n<78> stmt = mysql_simple_prepare ( mysql , query ) ;\n<86> if ( ! opt_silent ) fprintf ( stdout , "\n returned 1 row" ) ;
<1> void mime_field_init ( MIMEField * field ) {\n<2> memset ( field , 0 , sizeof ( MIMEField ) ) ;
<1> static int parse_strk(AVFormatContext *s,\n<3> FourxmDemuxContext *fourxm, uint8_t *buf, int size,\n<35> if (av_reallocp_array(&fourxm->tracks, track + 1, sizeof(AudioTrack)))\n<39> memset(&fourxm->tracks[fourxm->track_count], 0,\n<41> sizeof(AudioTrack) * (track + 1 - fourxm->track_count));
<1> static int get_real_id(const char *devpath, const char *idname, uint16_t *val)\n<17> if (f == NULL) {\n<25> if (fscanf(f, "%li\n", &id) == 1) {\n<27> *val = id;\n<32> return -1;\n<39> return 0;
<1> static int raw_open_common(BlockDriverState *bs, QDict *options,\n<95> switch (locking) {
<1> static int decode_subframe(WMAProDecodeCtx *s)\n<357> sizeof(*s->channel[c].coeffs) * subframe_len);\n<387> if (c == s->lfe_channel)\n<389> memset(&s->tmp[cur_subwoofer_cutoff], 0, sizeof(*s->tmp) *\n<411> s->fdsp.vector_fmul_scalar(s->tmp + start,\n<423> mdct->imdct_half(mdct, s->channel[c].coeffs, s->tmp);
<1> Tuplestorestate * ExecMakeTableFunctionResult ( ExprState * funcexpr , ExprContext * econtext , MemoryContext argContext , TupleDesc expectedDesc , bool randomAccess ) {\n<85> if ( ! fcinfo . isnull ) {\n<103> nullflags = ( bool * ) palloc ( natts * sizeof ( bool ) ) ;\n<104> memset ( nullflags , true , natts * sizeof ( bool ) ) ;\n<105> tuplestore_putvalues ( tupstore , expectedDesc , NULL , nullflags ) ;\n<124> if ( ! returnsSet ) {\n<128> nullflags = ( bool * ) palloc ( natts * sizeof ( bool ) ) ;\n<129> memset ( nullflags , true , natts * sizeof ( bool ) ) ;\n<130> tuplestore_putvalues ( tupstore , expectedDesc , NULL , nullflags ) ;
<1> static void srec_bad_byte ( bfd * abfd , unsigned int lineno , int c , bfd_boolean error ) {\n<6> char buf [ 10 ] ;\n<7> if ( ! ISPRINT ( c ) ) sprintf ( buf , "\\%03o" , ( unsigned int ) c ) ;\n<12> ( * _bfd_error_handler ) ( _ ( "%B:%d: Unexpected character `%s' in S-record file\n" ) , abfd , lineno , buf ) ;
<1> static void *nbd_client_thread(void *arg)\n<43> fd = open(device, O_RDWR);\n<45> if (fd < 0) {\n<49> fprintf(stderr, "Failed to open %s: %m", device);\n<69> pthread_create(&show_parts_thread, NULL, show_parts, device);\n<73> if (verbose) {\n<75> fprintf(stderr, "NBD device %s is now connected to %s\n",
<1> int main ( int argc , char * argv [ ] ) {\n<60> progname = get_progname ( argv [ 0 ] ) ;\n<63> while ( ( c = getopt_long ( argc , argv , "h:p:U:wWeqS:d:ast:i:v" , long_options , & optindex ) ) != - 1 ) {\n<64> switch ( c ) {\n<95> default : fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<103> if ( optind < argc ) {\n<104> fprintf ( stderr , _ ( "%s: too many command-line arguments (first is \"%s\")\n" ) , progname , argv [ optind ] ) ;\n<105> fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<110> if ( dbname ) {\n<111> fprintf ( stderr , _ ( "%s: cannot reindex all databases and a specific one at the same time\n" ) , progname ) ;\n<114> if ( syscatalog ) {\n<115> fprintf ( stderr , _ ( "%s: cannot reindex all databases and system catalogs at the same time\n" ) , progname ) ;\n<118> if ( schemas . head != NULL ) {\n<119> fprintf ( stderr , _ ( "%s: cannot reindex specific schema(s) in all databases\n" ) , progname ) ;\n<122> if ( tables . head != NULL ) {\n<123> fprintf ( stderr , _ ( "%s: cannot reindex specific table(s) in all databases\n" ) , progname ) ;\n<126> if ( indexes . head != NULL ) {\n<127> fprintf ( stderr , _ ( "%s: cannot reindex specific index(es) in all databases\n" ) , progname ) ;\n<130> reindex_all_databases ( maintenance_db , host , port , username , prompt_password , progname , echo , quiet , verbose ) ;\n<133> if ( schemas . head != NULL ) {\n<134> fprintf ( stderr , _ ( "%s: cannot reindex specific schema(s) and system catalogs at the same time\n" ) , progname ) ;\n<137> if ( tables . head != NULL ) {\n<138> fprintf ( stderr , _ ( "%s: cannot reindex specific table(s) and system catalogs at the same time\n" ) , progname ) ;\n<141> if ( indexes . head != NULL ) {\n<142> fprintf ( stderr , _ ( "%s: cannot reindex specific index(es) and system catalogs at the same time\n" ) , progname ) ;\n<145> if ( dbname == NULL ) {\n<146> if ( getenv ( "PGDATABASE" ) ) dbname = getenv ( "PGDATABASE" ) ;\n<147> else if ( getenv ( "PGUSER" ) ) dbname = getenv ( "PGUSER" ) ;\n<148> else dbname = get_user_name_or_exit ( progname ) ;\n<150> reindex_system_catalogs ( dbname , host , port , username , prompt_password , progname , echo , verbose ) ;\n<153> if ( dbname == NULL ) {\n<154> if ( getenv ( "PGDATABASE" ) ) dbname = getenv ( "PGDATABASE" ) ;\n<155> else if ( getenv ( "PGUSER" ) ) dbname = getenv ( "PGUSER" ) ;\n<156> else dbname = get_user_name_or_exit ( progname ) ;\n<163> reindex_one_database ( cell -> val , dbname , "SCHEMA" , host , port , username , prompt_password , progname , echo , verbose ) ;\n<171> reindex_one_database ( cell -> val , dbname , "INDEX" , host , port , username , prompt_password , progname , echo , verbose ) ;\n<179> reindex_one_database ( cell -> val , dbname , "TABLE" , host , port , username , prompt_password , progname , echo , verbose ) ;\n<182> if ( indexes . head == NULL && tables . head == NULL && schemas . head == NULL ) reindex_one_database ( NULL , dbname , "DATABASE" , host , port , username , prompt_password , progname , echo , verbose ) ;
<1> static int get_segment (CPUState *env, mmu_ctx_t *ctx,\n<295> if (logfile) {\n<297> fprintf(logfile, "ERROR: instruction should not need "
<1> static struct sk_buff * __pfkey_xfrm_state2msg ( const struct xfrm_state * x , int add_keys , int hsc ) {\n<20> size = sizeof ( struct sadb_msg ) + sizeof ( struct sadb_sa ) + sizeof ( struct sadb_lifetime ) + ( ( hsc & 1 ) ? sizeof ( struct sadb_lifetime ) : 0 ) + ( ( hsc & 2 ) ? sizeof ( struct sadb_lifetime ) : 0 ) + sizeof ( struct sadb_address ) * 2 + sockaddr_size * 2 + sizeof ( struct sadb_x_sa2 ) ;\n<21> if ( ( xfrm_ctx = x -> security ) ) {\n<22> ctx_size = PFKEY_ALIGN8 ( xfrm_ctx -> ctx_len ) ;\n<23> size += sizeof ( struct sadb_x_sec_ctx ) + ctx_size ;\n<25> if ( ! xfrm_addr_equal ( & x -> sel . saddr , & x -> props . saddr , x -> props . family ) ) size += sizeof ( struct sadb_address ) + sockaddr_size ;\n<29> size += sizeof ( struct sadb_key ) + auth_key_size ;\n<33> size += sizeof ( struct sadb_key ) + encrypt_key_size ;\n<40> size += sizeof ( struct sadb_x_nat_t_port ) ;\n<43> if ( skb == NULL ) return ERR_PTR ( - ENOBUFS ) ;\n<44> hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ;\n<45> memset ( hdr , 0 , size ) ;\n<46> hdr -> sadb_msg_len = size / sizeof ( uint64_t ) ;\n<127> if ( add_keys && auth_key_size ) {\n<128> key = ( struct sadb_key * ) skb_put ( skb , sizeof ( struct sadb_key ) + auth_key_size ) ;\n<129> key -> sadb_key_len = ( sizeof ( struct sadb_key ) + auth_key_size ) / sizeof ( uint64_t ) ;\n<130> key -> sadb_key_exttype = SADB_EXT_KEY_AUTH ;\n<131> key -> sadb_key_bits = x -> aalg -> alg_key_len ;\n<132> key -> sadb_key_reserved = 0 ;\n<133> memcpy ( key + 1 , x -> aalg -> alg_key , ( x -> aalg -> alg_key_len + 7 ) / 8 ) ;\n<135> if ( add_keys && encrypt_key_size ) {\n<136> key = ( struct sadb_key * ) skb_put ( skb , sizeof ( struct sadb_key ) + encrypt_key_size ) ;\n<137> key -> sadb_key_len = ( sizeof ( struct sadb_key ) + encrypt_key_size ) / sizeof ( uint64_t ) ;\n<138> key -> sadb_key_exttype = SADB_EXT_KEY_ENCRYPT ;\n<139> key -> sadb_key_bits = x -> ealg -> alg_key_len ;\n<140> key -> sadb_key_reserved = 0 ;\n<141> memcpy ( key + 1 , x -> ealg -> alg_key , ( x -> ealg -> alg_key_len + 7 ) / 8 ) ;\n<176> if ( xfrm_ctx ) {\n<177> sec_ctx = ( struct sadb_x_sec_ctx * ) skb_put ( skb , sizeof ( struct sadb_x_sec_ctx ) + ctx_size ) ;\n<178> sec_ctx -> sadb_x_sec_len = ( sizeof ( struct sadb_x_sec_ctx ) + ctx_size ) / sizeof ( uint64_t ) ;\n<179> sec_ctx -> sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX ;\n<180> sec_ctx -> sadb_x_ctx_doi = xfrm_ctx -> ctx_doi ;\n<181> sec_ctx -> sadb_x_ctx_alg = xfrm_ctx -> ctx_alg ;\n<182> sec_ctx -> sadb_x_ctx_len = xfrm_ctx -> ctx_len ;\n<183> memcpy ( sec_ctx + 1 , xfrm_ctx -> ctx_str , xfrm_ctx -> ctx_len ) ;
<1> static void print_warnings ( ) {\n<7> query = "show warnings" ;\n<8> mysql_real_query_for_lazy ( query , strlen ( query ) ) ;
<1> static int tls_open(URLContext *h, const char *uri, int flags)\n<35> if (!getaddrinfo(host, NULL, &hints, &ai)) {\n<45> proxy_path = getenv("http_proxy");\n<47> use_proxy = !ff_http_match_no_proxy(getenv("no_proxy"), host) &&\n<49> proxy_path != NULL && av_strstart(proxy_path, "http://", NULL);\n<59> av_url_split(NULL, 0, proxy_auth, sizeof(proxy_auth),\n<65> ff_url_join(dest, sizeof(dest), NULL, NULL, host, port, NULL);
<1> static int ivi_huff_desc_cmp ( const IVIHuffDesc * desc1 , const IVIHuffDesc * desc2 ) {\n<2> return desc1 -> num_rows != desc2 -> num_rows || memcmp ( desc1 -> xbits , desc2 -> xbits , desc1 -> num_rows ) ;
<17> ret = h264_init_ps(h, sl, first_slice);\n<377> if (!FIELD_PICTURE(h) || h->first_field) {\n<379> if (h264_frame_start(h) < 0) {\n<397> if (FIELD_PICTURE(h)) {\n<399> for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)\n<401> memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));\n<405> memset(h->slice_table, -1,\n<407> (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));\n<419> memcpy(h->mmco, sl->mmco, sl->nb_mmco * sizeof(*h->mmco));\n<501> if (!FIELD_PICTURE(h) || !h->first_field || h->missing_fields > 1) {\n<503> ret = h264_export_frame_props(h);\n<511> ret = h264_select_output_frame(h);
<1> void ppc_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n<9> for (i = 0; ; i++) {\n<15> if (strcmp(ppc_defs[i].name, "default") == 0)
<1> static int parse_global_var ( AVFormatContext * avctx , AVStream * st , const char * name , int size ) {\n<4> if ( ! strcmp ( name , "__NUM_I_TRACKS" ) ) {\n<5> mv -> nb_video_tracks = var_read_int ( pb , size ) ;\n<7> else if ( ! strcmp ( name , "__NUM_A_TRACKS" ) ) {\n<8> mv -> nb_audio_tracks = var_read_int ( pb , size ) ;\n<10> else if ( ! strcmp ( name , "COMMENT" ) || ! strcmp ( name , "TITLE" ) ) {\n<11> var_read_metadata ( avctx , name , size ) ;\n<13> else if ( ! strcmp ( name , "LOOP_MODE" ) || ! strcmp ( name , "NUM_LOOPS" ) || ! strcmp ( name , "OPTIMIZED" ) ) {\n<14> avio_skip ( pb , size ) ;\n<16> else return AVERROR_INVALIDDATA ;\n<17> return 0 ;
<1> static int string_to_crypto_hash_type ( const char * crypto_hash_type ) {\n<2> if ( strcmp ( crypto_hash_type , "none" ) == 0 ) {\n<3> return CRYPTO_HASH_TYPE_NONE ;\n<5> else if ( strcmp ( crypto_hash_type , "md5" ) == 0 ) {\n<6> return CRYPTO_HASH_TYPE_MD5 ;\n<8> else if ( strcmp ( crypto_hash_type , "sha1" ) == 0 ) {\n<9> return CRYPTO_HASH_TYPE_SHA1 ;\n<11> else if ( strcmp ( crypto_hash_type , "sha256" ) == 0 ) {\n<12> return CRYPTO_HASH_TYPE_SHA256 ;\n<14> else if ( strcmp ( crypto_hash_type , "sha384" ) == 0 ) {\n<15> return CRYPTO_HASH_TYPE_SHA384 ;\n<17> else if ( strcmp ( crypto_hash_type , "sha512" ) == 0 ) {\n<18> return CRYPTO_HASH_TYPE_SHA512 ;\n<20> return CRYPTO_HASH_TYPE_SHA1 ;
<1> static void test_fetch_offset ( ) {\n<4> char data [ 11 ] ;\n<17> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<25> rc = mysql_stmt_fetch_column ( stmt , my_bind , 0 , 0 ) ;\n<35> data [ 0 ] = '\0' ;\n<38> if ( ! opt_silent ) fprintf ( stdout , "\n col 1: %s (%ld)" , data , length ) ;\n<39> DIE_UNLESS ( strncmp ( data , "abcd" , 4 ) == 0 && length == 10 ) ;\n<42> if ( ! opt_silent ) fprintf ( stdout , "\n col 1: %s (%ld)" , data , length ) ;\n<43> DIE_UNLESS ( strncmp ( data , "fg" , 2 ) == 0 && length == 10 ) ;\n<46> if ( ! opt_silent ) fprintf ( stdout , "\n col 0: %s (%ld)" , data , length ) ;\n<47> DIE_UNLESS ( strncmp ( data , "j" , 1 ) == 0 && length == 10 ) ;
<1> static void nal_send(AVFormatContext *ctx, const uint8_t *buf, int len, int last_packet_of_frame)\n<5> RTPMuxContext *rtp_ctx = ctx->priv_data;\n<9> int nal_type           = (buf[0] >> 1) & 0x3F;\n<15> if (len <= rtp_ctx->max_payload_size) {\n<35> if (buffered_size + 4 + len <= rtp_ctx->max_payload_size) {\n<45> AV_WB16(rtp_ctx->buf_ptr, len);\n<47> rtp_ctx->buf_ptr += 2;\n<49> memcpy(rtp_ctx->buf_ptr, buf, len);\n<51> rtp_ctx->buf_ptr += len;\n<135> buf += 2;\n<141> while (len > rtp_payload_size) {\n<145> memcpy(&rtp_ctx->buf[RTP_HEVC_HEADERS_SIZE], buf, rtp_payload_size);\n<147> ff_rtp_send_data(ctx, rtp_ctx->buf, rtp_ctx->max_payload_size, 0);\n<151> buf += rtp_payload_size;\n<153> len -= rtp_payload_size;\n<173> memcpy(&rtp_ctx->buf[RTP_HEVC_HEADERS_SIZE], buf, len);\n<175> ff_rtp_send_data(ctx, rtp_ctx->buf, len + 2, last_packet_of_frame);
<1> void ff_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n<55> for (i = 0; i < planes; i++)\n<57> memcpy(link->cur_buf->extended_data[i], samplesref->extended_data[i], samplesref->linesize[0]);
<1> int qemuMonitorTextExpirePassword ( qemuMonitorPtr mon , const char * protocol , const char * expire_time ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<13> if ( strstr ( reply , "unknown command:" ) ) {\n<14> ret = - 2 ;\n<17> ret = 0 ;\n<18> cleanup : VIR_FREE ( reply ) ;
<1> static int checkHttpTxnClientProtocolStackGet ( SocketTest * test , void * data ) {\n<5> TSHttpTxnClientProtocolStackGet ( txnp , 10 , results , & count ) ;\n<7> if ( count != 3 ) {\n<11> else if ( strcmp ( results [ 0 ] , "http/1.0" ) != 0 ) {\n<12> test -> test_client_protocol_stack_get = false ;\n<13> SDK_RPRINT ( test -> regtest , "TSHttpTxnClientProtocolStackGet" , "TestCase1" , TC_FAIL , "results[0] should be http/1.0 is %s" , results [ 0 ] ) ;\n<15> else if ( strcmp ( results [ 1 ] , "tcp" ) != 0 ) {\n<16> test -> test_client_protocol_stack_get = false ;\n<17> SDK_RPRINT ( test -> regtest , "TSHttpTxnClientProtocolStackGet" , "TestCase1" , TC_FAIL , "results[1] should be tcp is %s" , results [ 1 ] ) ;\n<19> else if ( strcmp ( results [ 2 ] , "ipv4" ) != 0 ) {\n<20> test -> test_client_protocol_stack_get = false ;\n<21> SDK_RPRINT ( test -> regtest , "TSHttpTxnClientProtocolStackGet" , "TestCase1" , TC_FAIL , "results[2] should be ipv4 is %s" , results [ 2 ] ) ;\n<24> SDK_RPRINT ( test -> regtest , "TSHttpTxnClientProtocolStackGet" , "TestCase1" , TC_PASS , "ok stack_size=%d" , count ) ;
<1> int ff_get_wav_header(AVIOContext *pb, AVCodecContext *codec, int size)\n<49> if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */\n<57> ff_get_guid(pb, &subformat);\n<59> if (!memcmp(subformat + 4, (const uint8_t[]){FF_MEDIASUBTYPE_BASE_GUID}, 12)) {\n<61> codec->codec_tag = AV_RL32(subformat);\n<63> codec->codec_id = ff_wav_codec_get_id(codec->codec_tag, codec->bits_per_coded_sample);\n<67> codec->codec_id = ff_codec_guid_get_id(ff_codec_wav_guids, subformat);
<1> static void ntpversion ( struct parse * pcmd , FILE * fp ) {\n<2> if ( pcmd -> nargs == 0 ) {\n<3> ( void ) fprintf ( fp , "NTP version being claimed is %d\n" , pktversion ) ;\n<6> if ( pcmd -> argval [ 0 ] . uval < NTP_OLDVERSION || pcmd -> argval [ 0 ] . uval > NTP_VERSION ) {\n<7> ( void ) fprintf ( stderr , "versions %d to %d, please\n" , NTP_OLDVERSION , NTP_VERSION ) ;
<1> static int ipvideo_decode_block_opcode_0xA ( IpvideoContext * s , AVFrame * frame ) {\n<5> bytestream2_get_buffer ( & s -> stream_ptr , P , 4 ) ;\n<6> if ( P [ 0 ] <= P [ 1 ] ) {\n<25> vert = P [ 4 ] <= P [ 5 ] ;\n<31> x ++ , flags >>= 2 ) * s -> pixel_ptr ++ = P [ flags & 0x03 ] ;\n<37> if ( y == 7 ) {\n<38> memcpy ( P , P + 4 , 4 ) ;
<1> static void dumppstr ( FILE * file , const char * str ) {\n<2> putc ( strlen ( str ) , file ) ;\n<3> fwrite ( str , sizeof ( char ) , strlen ( str ) , file ) ;
<1> static int64_t run_opencl_bench(AVOpenCLExternalEnv *ext_opencl_env)\n<35> if (!(inbuf = av_malloc(buf_size)) || !(mask = av_malloc(mask_size))) {\n<59> kernel_len = strlen(ocl_bench_source);\n<61> program = clCreateProgramWithSource(ext_opencl_env->context, 1, &ocl_bench_source,
<1> void show_help_default ( const char * opt , const char * arg ) {\n<5> printf ( "\n" ) ;
<1> static int GetNextRange ( char * * SrcRangeStr , off_t * FirstByte , off_t * LastByte ) {\n<8> if ( * SrcRangeStr == NULL ) return - 1 ;\n<9> Tok = StrTok ( SrcRangeStr , "," ) ;\n<10> if ( ( Ptr = strstr ( Tok , "-" ) ) == NULL ) return - 1 ;\n<11> * Ptr = ' ' ;\n<13> if ( F == - 1 || L == - 1 ) {\n<15> for ( i = 0 ;\n<16> i < ( int ) strlen ( Tok ) ;\n<17> i ++ ) {\n<18> if ( Tok [ i ] == '-' ) {\n<21> else if ( isdigit ( Tok [ i ] ) ) {
<1> void lcc_network_buffer_destroy ( lcc_network_buffer_t * nb ) {\n<2> if ( nb == NULL ) return ;\n<3> free ( nb -> buffer ) ;\n<4> free ( nb ) ;
<1> static int vmdk_open(BlockDriverState *bs, const char *filename, int flags)\n<17> flags = BDRV_O_RDONLY;\n<19> fprintf(stderr, "(VMDK) image open: flags=0x%x filename=%s\n", flags, bs->filename);\n<23> ret = bdrv_file_open(&s->hd, filename, flags | BDRV_O_AUTOGROW);\n<105> if (vmdk_parent_open(bs, filename) != 0)\n<111> s->parent_cid = vmdk_read_cid(bs,1);
<1> int ff_xvid_rate_control_init(MpegEncContext *s){\n<15> if (fd == -1) {\n<25> for(i=0; i<s->rc_context.num_entries; i++){\n<39> snprintf(tmp, sizeof(tmp), "%c %d %d %d %d %d %d\n",\n<47> if (write(fd, tmp, strlen(tmp)) < 0) {\n<49> av_log(NULL, AV_LOG_ERROR, "Error %s writing 2pass logfile\n", strerror(errno));\n<53> return AVERROR(errno);
<1> static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)\n<17> switch (req->cmd.buf[0]) {\n<29> if (req->cmd.xfer < 4)\n<33> memset(outbuf, 0, 4);\n<37> if (s->sense.key == NOT_READY && req->cmd.xfer >= 18) {\n<39> memset(outbuf, 0, 18);\n<149> memset(outbuf, 0, 8);\n<211> memset(outbuf, 0, 8);\n<227> if ((req->cmd.buf[1] & 31) == 0x10) {\n<231> memset(outbuf, 0, req->cmd.xfer);\n<291> buflen = req->cmd.xfer;\n<303> if (req->cmd.xfer < 16)\n<307> memset(outbuf, 0, 16);
<1> static int ws_snd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<3> const uint8_t * buf = avpkt -> data ;\n<6> int sample = 128 ;\n<16> buf += 4 ;\n<26> samples = frame -> data [ 0 ] ;\n<28> if ( in_size == out_size ) {\n<29> memcpy ( samples , buf , out_size ) ;\n<37> count = * buf & 0x3F ;\n<49> if ( samples_end - samples < smp ) break ;\n<51> if ( ( buf - avpkt -> data ) + size > buf_size ) break ;\n<52> switch ( code ) {\n<57> sample += ( code & 0x3 ) - 2 ;\n<67> sample = av_clip_uint8 ( sample ) ;\n<75> sample += ws_adpcm_4bit [ code & 0xF ] ;\n<79> sample = av_clip_uint8 ( sample ) ;\n<83> case 2 : if ( count & 0x20 ) {\n<87> sample += t >> 3 ;\n<88> sample = av_clip_uint8 ( sample ) ;\n<92> memcpy ( samples , buf , smp ) ;\n<93> samples += smp ;\n<94> buf += smp ;\n<95> sample = buf [ - 1 ] ;\n<98> default : memset ( samples , sample , smp ) ;\n<99> samples += smp ;
<1> static void label_mark_truncated ( char * label_str , gsize name_pos ) {\n<5> if ( name_pos < ITEM_LABEL_LENGTH - trunc_len ) {\n<6> memmove ( label_str + name_pos + trunc_len , label_str + name_pos , ITEM_LABEL_LENGTH - name_pos - trunc_len ) ;\n<7> memcpy ( label_str + name_pos , trunc_str , trunc_len ) ;
<1> int rtp_get_fmt ( vlc_object_t * obj , es_format_t * p_fmt , const char * mux , rtp_format_t * rtp_fmt ) {\n<20> switch ( p_fmt -> i_codec ) {\n<80> if ( p_fmt -> i_extra > 0 ) {\n<81> uint8_t * p_buffer = p_fmt -> p_extra ;\n<83> char * p_64_sps = NULL ;\n<84> char * p_64_pps = NULL ;\n<86> while ( i_buffer > 4 ) {\n<89> while ( p_buffer [ 0 ] != 0 || p_buffer [ 1 ] != 0 || p_buffer [ 2 ] != 1 ) {\n<90> p_buffer ++ ;\n<94> if ( i_buffer < 4 || memcmp ( p_buffer , "\x00\x00\x01" , 3 ) ) {\n<95> msg_Dbg ( obj , "No startcode found.." ) ;\n<98> p_buffer += 3 ;\n<99> i_buffer -= 3 ;\n<100> const int i_nal_type = p_buffer [ 0 ] & 0x1f ;\n<101> msg_Dbg ( obj , "we found a startcode for NAL with TYPE:%d" , i_nal_type ) ;\n<102> i_size = i_buffer ;\n<103> for ( i_offset = 0 ;\n<104> i_offset + 2 < i_buffer ;\n<105> i_offset ++ ) {\n<106> if ( ! memcmp ( p_buffer + i_offset , "\x00\x00\x01" , 3 ) ) {\n<107> while ( i_offset > 0 && 0 == p_buffer [ i_offset - 1 ] ) i_offset -- ;\n<108> i_size = i_offset ;\n<112> if ( i_size == 0 ) {\n<116> if ( i_nal_type == 7 ) {\n<117> free ( p_64_sps ) ;\n<118> p_64_sps = vlc_b64_encode_binary ( p_buffer , i_size ) ;\n<119> sprintf_hexa ( hexa , & p_buffer [ 1 ] , 3 ) ;\n<121> else if ( i_nal_type == 8 ) {\n<122> free ( p_64_pps ) ;\n<123> p_64_pps = vlc_b64_encode_binary ( p_buffer , i_size ) ;\n<126> p_buffer += i_size ;\n<132> free ( p_64_sps ) ;\n<133> free ( p_64_pps ) ;\n<135> if ( rtp_fmt -> fmtp == NULL ) rtp_fmt -> fmtp = strdup ( "packetization-mode=1" ) ;\n<192> rtp_fmt -> fmtp = strdup ( "octet-align=1" ) ;\n<196> rtp_fmt -> fmtp = strdup ( "octet-align=1" ) ;\n<219> if ( config == NULL ) break ;\n<220> if ( pixel_fmt == 1 ) {\n<221> free ( config ) ;\n<241> free ( config ) ;\n<260> if ( p_fmt -> audio . i_channels == 2 ) rtp_fmt -> fmtp = strdup ( "sprop-stereo=1" ) ;
<1> static void term_down_char(void)\n<5> if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n<21> term_print_cmdline(term_cmd_buf);\n<23> term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
<1> void RECORD_LAYER_clear ( RECORD_LAYER * rl ) {\n<7> memset ( rl -> alert_fragment , 0 , sizeof ( rl -> alert_fragment ) ) ;\n<9> memset ( rl -> handshake_fragment , 0 , sizeof ( rl -> handshake_fragment ) ) ;\n<22> RECORD_LAYER_reset_read_sequence ( rl ) ;\n<23> RECORD_LAYER_reset_write_sequence ( rl ) ;\n<24> if ( rl -> d ) DTLS_RECORD_LAYER_clear ( rl ) ;
<1> static void vm_completion(ReadLineState *rs, const char *str)\n<13> len = strlen(str);\n<15> readline_set_completion_index(rs, len);\n<53> if (!strncmp(str, completion, len)) {
<7> ColorSpaceContext *s = ctx->priv;\n<89> if (!s->in_primaries) {\n<105> if (!s->out_primaries) {\n<135> s->lrgb2lrgb_passthrough = !memcmp(s->in_primaries, s->out_primaries,\n<139> if (!s->lrgb2lrgb_passthrough) {\n<145> fill_rgb2xyz_table(s->out_primaries, rgb2xyz);\n<149> fill_rgb2xyz_table(s->in_primaries, rgb2xyz);\n<195> if (!s->in_txchr) {\n<203> if (!s->in_txchr) {\n<219> if (!s->out_txchr) {\n<227> if (!s->out_txchr) {\n<263> s->rgb2rgb_passthrough = s->fast_mode || (s->lrgb2lrgb_passthrough &&\n<265> !memcmp(s->in_txchr, s->out_txchr, sizeof(*s->in_txchr)));\n<269> res = fill_gamma_table(s);\n<281> if (!s->in_lumacoef) {\n<289> if (!s->in_lumacoef) {\n<307> if (!s->out_lumacoef) {\n<315> if (!s->out_lumacoef) {\n<359> s->yuv2yuv_passthrough = s->yuv2yuv_fastmode && s->in_rng == s->out_rng &&\n<395> fill_rgb2yuv_table(s->in_lumacoef, rgb2yuv);\n<461> fill_rgb2yuv_table(s->out_lumacoef, rgb2yuv);
<1> void virtio_scsi_dataplane_start(VirtIOSCSI *s)\n<39> if (rc != 0) {\n<41> fprintf(stderr, "virtio-scsi: Failed to set guest notifiers (%d), "
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> VmncContext * const c = avctx -> priv_data ;\n<31> outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n<33> i < h ;\n<35> memcpy ( outptr , c -> screendta + i * c -> cur_w * c -> bpp2 , w * c -> bpp2 ) ;\n<36> outptr += c -> pic . linesize [ 0 ] ;\n<72> c -> screendta = av_realloc ( c -> screendta , c -> cur_w * c -> cur_h * c -> bpp2 ) ;\n<73> load_cursor ( c , src ) ;\n<116> res = decode_hextile ( c , outptr , src , size_left , w , h , c -> pic . linesize [ 0 ] ) ;\n<141> outptr = c -> pic . data [ 0 ] + dx * c -> bpp2 + dy * c -> pic . linesize [ 0 ] ;\n<143> i < h ;\n<145> memcpy ( c -> screendta + i * c -> cur_w * c -> bpp2 , outptr , w * c -> bpp2 ) ;\n<146> outptr += c -> pic . linesize [ 0 ] ;
<11> for (i = 0; i < source->niov; i++) {\n<13> assert(dest->iov[i].iov_len == source->iov[i].iov_len);
<1> static int pcm_decode_frame(AVCodecContext *avctx,\n<31> samples = data;\n<33> src = buf;\n<93> switch(avctx->codec->id) {\n<255> memcpy(samples, src, n*sample_size);\n<257> src += n*sample_size;
<1> rdt_parse_packet (AVFormatContext *ctx, PayloadContext *rdt, AVStream *st,\n<27> ffio_init_context(&pb, buf, len, 0, NULL, NULL, NULL, NULL);\n<35> pos = avio_tell(&pb);\n<43> if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n<45> memcpy (rdt->buffer, buf + pos, len - pos);
<1> static void dequant_lsps ( double * lsps , int num , const uint16_t * values , const uint16_t * sizes , int n_stages , const uint8_t * table , const double * mul_q , const double * base_q ) {\n<3> memset ( lsps , 0 , num * sizeof ( * lsps ) ) ;\n<11> m ++ ) lsps [ m ] += base + mul * t_off [ m ] ;
<1> static int decode_13 ( AVCodecContext * avctx , DxaDecContext * c , uint8_t * dst , int stride , uint8_t * src , uint8_t * ref ) {\n<7> data = code + ( ( avctx -> width * avctx -> height ) >> 4 ) ;\n<16> tmp = dst + i ;\n<17> tmp2 = ref + i ;\n<24> tmp2 += x + y * stride ;\n<26> y < 4 ;\n<28> memcpy ( tmp , tmp2 , 4 ) ;\n<29> tmp += stride ;\n<30> tmp2 += stride ;\n<48> tmp [ x ] = ( mask & 0x8000 ) ? * data ++ : tmp2 [ x ] ;\n<52> tmp2 += stride ;\n<56> y < 4 ;\n<58> memset ( tmp , data [ 0 ] , 4 ) ;\n<59> tmp += stride ;\n<61> data ++ ;\n<64> y < 4 ;\n<66> memcpy ( tmp , data , 4 ) ;\n<67> data += 4 ;\n<68> tmp += stride ;\n<77> tmp2 = ref + i + d2 ;\n<83> tmp2 += x + y * stride ;\n<84> case 0x00 : tmp [ d + 0 ] = tmp2 [ 0 ] ;\n<85> tmp [ d + 1 ] = tmp2 [ 1 ] ;\n<86> tmp [ d + 0 + stride ] = tmp2 [ 0 + stride ] ;\n<87> tmp [ d + 1 + stride ] = tmp2 [ 1 + stride ] ;\n<89> case 0x40 : tmp [ d + 0 ] = data [ 0 ] ;\n<90> tmp [ d + 1 ] = data [ 0 ] ;\n<91> tmp [ d + 0 + stride ] = data [ 0 ] ;\n<92> tmp [ d + 1 + stride ] = data [ 0 ] ;\n<93> data ++ ;\n<95> case 0xC0 : tmp [ d + 0 ] = * data ++ ;\n<96> tmp [ d + 1 ] = * data ++ ;\n<97> tmp [ d + 0 + stride ] = * data ++ ;\n<98> tmp [ d + 1 + stride ] = * data ++ ;\n<112> tmp [ x ] = data [ mask & 1 ] ;\n<118> data += 2 ;\n<128> tmp [ x ] = data [ mask & 3 ] ;\n<134> data += type - 30 ;
<1> static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n<9> if (min_size < *size)\n<15> av_freep(ptr);\n<17> val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n<19> memcpy(ptr, &val, sizeof(val));\n<21> if (!val)
<1> static void mpegts_write_section(MpegTSSection *s, uint8_t *buf, int len)\n<37> while (len > 0) {\n<39> first = buf == buf_ptr;\n<69> len1 = TS_PACKET_SIZE - (q - packet);\n<71> if (len1 > len)\n<73> len1 = len;\n<75> memcpy(q, buf_ptr, len1);\n<77> q += len1;\n<81> left = TS_PACKET_SIZE - (q - packet);\n<83> if (left > 0)\n<85> memset(q, 0xff, left);\n<93> buf_ptr += len1;
<1> static gboolean fat_str_replace ( char * str , char replacement ) {\n<6> str [ i ] != '\0' ;\n<8> if ( strchr ( FAT_FORBIDDEN_CHARACTERS , str [ i ] ) || str [ i ] < 32 ) {\n<9> success = TRUE ;\n<10> str [ i ] = replacement ;
<1> int parse_args ( int argc , char * * argv ) {\n<13> if ( global_subst != NULL ) {\n<14> char * comma = strstr ( global_subst , "," ) ;\n<15> if ( comma == NULL ) die ( "wrong --global-subst, must be X,Y" ) ;\n<16> memcpy ( global_subst_from , global_subst , ( comma - global_subst ) ) ;\n<17> global_subst_from [ comma - global_subst ] = 0 ;\n<18> memcpy ( global_subst_to , comma + 1 , strlen ( comma ) ) ;\n<20> if ( ! opt_suite_dir ) opt_suite_dir = "./" ;\n<21> suite_dir_len = strlen ( opt_suite_dir ) ;\n<22> overlay_dir_len = opt_overlay_dir ? strlen ( opt_overlay_dir ) : 0 ;
<1> void gdb_register_coprocessor(CPUState * env,\n<5> int num_regs, const char *xml, int g_pos)\n<17> s = (GDBRegisterState *)g_malloc0(sizeof(GDBRegisterState));\n<19> s->base_reg = last_reg;\n<21> s->num_regs = num_regs;\n<23> s->get_reg = get_reg;\n<25> s->set_reg = set_reg;\n<27> s->xml = xml;\n<31> while (*p) {\n<35> if (strcmp((*p)->xml, xml) == 0)\n<37> return;\n<39> p = &(*p)->next;\n<51> if (g_pos != s->base_reg) {\n<53> fprintf(stderr, "Error: Bad gdb register numbering for '%s'\n"
<1> static struct tree_content * grow_tree_content ( struct tree_content * t , int amt ) {\n<2> struct tree_content * r = new_tree_content ( t -> entry_count + amt ) ;\n<5> memcpy ( r -> entries , t -> entries , t -> entry_count * sizeof ( t -> entries [ 0 ] ) ) ;\n<6> release_tree_content ( t ) ;\n<7> return r ;
<1> bool Curl_compareheader ( const char * headerline , const char * header , const char * content ) {\n<2> size_t hlen = strlen ( header ) ;\n<7> if ( ! Curl_raw_nequal ( headerline , header , hlen ) ) return FALSE ;\n<8> start = & headerline [ hlen ] ;\n<9> while ( * start && ISSPACE ( * start ) ) start ++ ;\n<10> end = strchr ( start , '\r' ) ;\n<11> if ( ! end ) {\n<12> end = strchr ( start , '\n' ) ;\n<13> if ( ! end ) end = strchr ( start , '\0' ) ;\n<15> len = end - start ;\n<16> clen = strlen ( content ) ;\n<18> len >= clen ;\n<20> if ( Curl_raw_nequal ( start , content , clen ) ) return TRUE ;
<1> void c_main ( ) {\n<19> i < 30 ;\n<21> printf ( "year: %d, month: %d (%d in the implementation), day: %d\n" , ucal_get ( cal , UCAL_YEAR , & status ) , ucal_get ( cal , UCAL_MONTH , & status ) + 1 , ucal_get ( cal , UCAL_MONTH , & status ) , ucal_get ( cal , UCAL_DATE , & status ) ) ;
<1> int evdns_server_request_get_requesting_addr ( struct evdns_server_request * _req , struct sockaddr * sa , int addr_len ) {\n<2> struct server_request * req = TO_SERVER_REQUEST ( _req ) ;\n<3> if ( addr_len < ( int ) req -> addrlen ) return - 1 ;\n<4> memcpy ( sa , & ( req -> addr ) , req -> addrlen ) ;
<1> int evdns_resolv_conf_parse ( int flags , const char * const filename ) {\n<22> if ( st . st_size > 65535 ) {\n<26> resolv = ( u8 * ) malloc ( ( size_t ) st . st_size + 1 ) ;\n<27> if ( ! resolv ) {\n<37> if ( r < 0 ) {\n<41> resolv [ n ] = 0 ;\n<42> start = ( char * ) resolv ;\n<46> char * const newline = strchr ( start , '\n' ) ;\n<47> if ( ! newline ) {\n<48> resolv_conf_parse_line ( start , flags ) ;\n<53> resolv_conf_parse_line ( start , flags ) ;\n<54> start = newline + 1 ;\n<64> out2 : free ( resolv ) ;
<1> static block_t * DecoderBlockFlushNew ( ) {\n<3> if ( ! p_null ) return NULL ;\n<5> memset ( p_null -> p_buffer , 0 , p_null -> i_buffer ) ;\n<6> return p_null ;
<1> static void check_loopfilter(void)\n<53> memcpy(buf1 - midoff, buf0 - midoff,\n<55> 16 * 8 * SIZEOF_PIXEL);\n<61> if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 8 * SIZEOF_PIXEL))\n<63> fail();\n<97> memcpy(buf1 - midoff, buf0 - midoff, 16 * 16 * SIZEOF_PIXEL);\n<103> if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 16 * SIZEOF_PIXEL))\n<105> fail();\n<129> memcpy(buf1 - midoff, buf0 - midoff, 16 * 16 * SIZEOF_PIXEL);\n<137> if (memcmp(buf0 - midoff, buf1 - midoff, 16 * 16 * SIZEOF_PIXEL))\n<139> fail();
<1> void vp8_remove_compressor ( VP8_COMP * * ptr ) {\n<3> if ( ! cpi ) return ;\n<12> FILE * f = fopen ( "opsnr.stt" , "a" ) ;\n<14> double total_encode_time = ( cpi -> time_receive_data + cpi -> time_compress_data ) / 1000.000 ;\n<15> double dr = ( double ) cpi -> bytes * 8.0 / 1000.0 / time_encoded ;\n<18> if ( cpi -> oxcf . number_of_layers > 1 ) {\n<20> fprintf ( f , "Layer\tBitrate\tAVGPsnr\tGLBPsnr\tAVPsnrP\t" "GLPsnrP\tVPXSSIM\t\n" ) ;\n<22> i < ( int ) cpi -> oxcf . number_of_layers ;\n<23> i ++ ) {\n<24> double dr = ( double ) cpi -> bytes_in_layer [ i ] * 8.0 / 1000.0 / time_encoded ;\n<26> double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_error2 [ i ] ) ;\n<27> double total_psnr2 = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_error2_p [ i ] ) ;\n<28> double total_ssim = 100 * pow ( cpi -> sum_ssim [ i ] / cpi -> sum_weights [ i ] , 8.0 ) ;\n<29> fprintf ( f , "%5d\t%7.3f\t%7.3f\t%7.3f\t%7.3f\t" "%7.3f\t%7.3f\n" , i , dr , cpi -> sum_psnr [ i ] / cpi -> frames_in_layer [ i ] , total_psnr , cpi -> sum_psnr_p [ i ] / cpi -> frames_in_layer [ i ] , total_psnr2 , total_ssim ) ;\n<34> double total_psnr = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_sq_error ) ;\n<35> double total_psnr2 = vpx_sse_to_psnr ( samples , 255.0 , cpi -> total_sq_error2 ) ;\n<36> double total_ssim = 100 * pow ( cpi -> summed_quality / cpi -> summed_weights , 8.0 ) ;\n<37> fprintf ( f , "Bitrate\tAVGPsnr\tGLBPsnr\tAVPsnrP\t" "GLPsnrP\tVPXSSIM\t Time(us)\n" ) ;\n<38> fprintf ( f , "%7.3f\t%7.3f\t%7.3f\t%7.3f\t%7.3f\t" "%7.3f\t%8.0f\n" , dr , cpi -> total / cpi -> count , total_psnr , cpi -> totalp / cpi -> count , total_psnr2 , total_ssim , total_encode_time ) ;\n<42> if ( cpi -> oxcf . number_of_layers > 1 ) {\n<44> fprintf ( f , "Layer\tBitRate\tSSIM_Y\tSSIM_U\tSSIM_V\tSSIM_A\t" "Time(us)\n" ) ;\n<46> i < ( int ) cpi -> oxcf . number_of_layers ;\n<47> i ++ ) {\n<48> double dr = ( double ) cpi -> bytes_in_layer [ i ] * 8.0 / 1000.0 / time_encoded ;\n<49> fprintf ( f , "%5d\t%7.3f\t%6.4f\t" "%6.4f\t%6.4f\t%6.4f\t%8.0f\n" , i , dr , cpi -> total_ssimg_y_in_layer [ i ] / cpi -> frames_in_layer [ i ] , cpi -> total_ssimg_u_in_layer [ i ] / cpi -> frames_in_layer [ i ] , cpi -> total_ssimg_v_in_layer [ i ] / cpi -> frames_in_layer [ i ] , cpi -> total_ssimg_all_in_layer [ i ] / cpi -> frames_in_layer [ i ] , total_encode_time ) ;\n<53> fprintf ( f , "BitRate\tSSIM_Y\tSSIM_U\tSSIM_V\tSSIM_A\t" "Time(us)\n" ) ;\n<54> fprintf ( f , "%7.3f\t%6.4f\t%6.4f\t%6.4f\t%6.4f\t%8.0f\n" , dr , cpi -> total_ssimg_y / cpi -> count , cpi -> total_ssimg_u / cpi -> count , cpi -> total_ssimg_v / cpi -> count , cpi -> total_ssimg_all / cpi -> count , total_encode_time ) ;\n<57> fclose ( f ) ;\n<64> FILE * f = fopen ( "cxspeed.stt" , "a" ) ;\n<67> i < 16 ;\n<68> i ++ ) fprintf ( f , "%5d" , frames_at_speed [ i ] ) ;\n<69> fprintf ( f , "\n" ) ;\n<70> fclose ( f ) ;
<1> static int arm_cpu_env_mask ( void ) {\n<3> env = getenv ( "VPX_SIMD_CAPS_MASK" ) ;\n<4> return env && * env ? ( int ) strtol ( env , NULL , 0 ) : ~ 0 ;
<1> static int matroska_deliver_packet(MatroskaDemuxContext *matroska,\n<3> AVPacket *pkt)\n<7> if (matroska->num_packets > 0) {\n<9> memcpy(pkt, matroska->packets[0], sizeof(AVPacket));\n<11> av_free(matroska->packets[0]);\n<13> if (matroska->num_packets > 1) {\n<15> memmove(&matroska->packets[0], &matroska->packets[1],\n<17> (matroska->num_packets - 1) * sizeof(AVPacket *));\n<21> av_realloc(matroska->packets, (matroska->num_packets - 1) *
<1> static int flic_decode_frame_15_16BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n<26> pixels = s -> frame . data [ 0 ] ;\n<36> switch ( chunk_type ) {\n<88> case FLI_BLACK : memset ( pixels , 0x0000 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n<105> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<117> pixels [ pixel_ptr ++ ] = palette_idx1 ;
<1> static long heap_available ( ) {\n<3> void * probes [ max_malloc_probes ] ;\n<6> n < max_malloc_probes ;\n<7> n ++ ) {\n<8> if ( ( probes [ n ] = malloc ( malloc_probe_size ) ) == 0 ) break ;\n<9> if_debug2 ( 'a' , "[a]heap_available probe[%d]=0x%lx\n" , n , ( ulong ) probes [ n ] ) ;\n<10> avail += malloc_probe_size ;\n<12> while ( n ) free ( probes [ -- n ] ) ;
<1> static void cpu_devinit(const char *cpu_model, unsigned int id,\n<17> if (cpu == NULL) {\n<19> fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n");
<1> static ssize_t sdp_attr_get(struct bt_l2cap_sdp_state_s *sdp,\n<3> uint8_t *rsp, const uint8_t *req, ssize_t len)\n<21> if (len < 7)\n<25> memcpy(&handle, req, 4);\n<27> req += 4;\n<33> if (handle < 0 || handle > sdp->services)\n<47> max = (req[0] << 8) | req[1];\n<49> req += 2;\n<59> if ((*req & ~SDP_DSIZE_MASK) == SDP_DTYPE_SEQ) {\n<61> seqlen = sdp_datalen(&req, &len);\n<73> if (sdp_attr_match(record, &req, &seqlen))\n<77> } else if (sdp_attr_match(record, &req, &seqlen))\n<91> if (len <= sizeof(int))\n<97> memcpy(&start, req + 1, sizeof(int));\n<113> lst = rsp + 2;\n<117> len = 3 - start;\n<125> if (len >= 0 && len + record->attribute_list[i].len < max) {\n<127> memcpy(lst + len, record->attribute_list[i].pair,\n<131> end = len + record->attribute_list[i].len;\n<135> len += record->attribute_list[i].len;\n<139> if (0 >= start) {\n<141> lst[0] = SDP_DTYPE_SEQ | SDP_DSIZE_NEXT2;\n<143> lst[1] = (len + start - 3) >> 8;\n<145> lst[2] = (len + start - 3) & 0xff;\n<157> if (end < len) {\n<159> len = end + start;\n<161> lst[end ++] = sizeof(int);\n<163> memcpy(lst + end, &len, sizeof(int));
<1> USBDevice *usbdevice_create(const char *cmdline)\n<13> params = strchr(cmdline,':');\n<22> pstrcpy(driver, sizeof(driver), cmdline);
<1> static void do_sdl_resize(int new_width, int new_height, int bpp)\n<29> real_screen = SDL_SetVideoMode(width, height, bpp, flags);\n<31> if (!real_screen) {\n<33> fprintf(stderr, "Could not open SDL display (%dx%dx%d): %s\n", width,
<1> static struct pathelem *add_entry(struct pathelem *root, const char *name,\n<17> + sizeof(root->entries[0])*root->num_entries);\n<19> e = &root->entries[root->num_entries-1];\n<23> *e = new_entry(root->pathname, root, name);
<1> static int webm_dash_manifest_cues(AVFormatContext *s)\n<103> strcpy(buf, "");\n<111> if (i != s->streams[0]->nb_index_entries - 1)\n<113> strncat(buf, ",", sizeof(char));\n<117> av_dict_set(&s->streams[0]->metadata, CUE_TIMESTAMPS, buf, 0);
<1> int quit ( ) {\n<12> if ( ccache_name != NULL ) {\n<13> fprintf ( stderr , "\n\a\a\a%s" , _ ( "Administration credentials NOT DESTROYED.\n" ) ) ;
<1> static void ioreq_release(struct ioreq *ioreq, bool finish)\n<9> QLIST_REMOVE(ioreq, list);\n<11> memset(ioreq, 0, sizeof(*ioreq));\n<15> QLIST_INSERT_HEAD(&blkdev->freelist, ioreq, list);
<1> struct st_connection * find_connection_by_name ( const char * name ) {\n<4> con < next_con ;\n<5> con ++ ) {\n<6> if ( ! strcmp ( con -> name , name ) ) {\n<7> return con ;
<1> void replace_dynstr_append ( DYNAMIC_STRING * ds , const char * val ) {\n<2> replace_dynstr_append_mem ( ds , val , strlen ( val ) ) ;
<1> static void process_envvars ( enum mode * modep ) {\n<10> if ( envline [ len ] != '=' ) continue ;\n<12> case 4 : if ( memcmp ( envline , "WARN" , 4 ) == 0 ) GLRO ( dl_verbose ) = envline [ 5 ] != '\0' ;
<1> static void http_write_packet(void *opaque,\n<3> unsigned char *buf, int size)\n<7> HTTPContext *c = opaque;\n<17> if (c->buffer_end - c->buffer + size > IOBUFFER_MAX_SIZE)\n<23> memcpy(c->buffer_end, buf, size);\n<25> c->buffer_end += size;
<1> int av_buffersink_poll_frame(AVFilterContext *ctx)\n<11> av_assert0(!strcmp(ctx->filter->name, "buffersink") || !strcmp(ctx->filter->name, "abuffersink"));
<1> static void test_tco_second_timeout_reset(void)\n<37> g_assert(!strcmp(qdict_get_str(ad, "action"), "reset"));
<1> void globfree ( pglob ) register glob_t * pglob ;\n<3> if ( pglob -> gl_pathv != NULL ) {\n<6> i < pglob -> gl_pathc ;\n<7> ++ i ) free ( pglob -> gl_pathv [ pglob -> gl_offs + i ] ) ;\n<8> free ( pglob -> gl_pathv ) ;
<1> static void unfold_blk ( struct block * * blk ) {\n<6> switch ( ( * blk ) -> type ) {\n<7> case BLK_INSTR : SAFE_CALLOC ( ue , 1 , sizeof ( struct unfold_elm ) ) ;\n<8> memcpy ( & ue -> fop , ( * blk ) -> un . ins , sizeof ( struct filter_op ) ) ;\n<9> TAILQ_INSERT_TAIL ( & unfolded_tree , ue , next ) ;
<1> static int usb_msd_handle_data(USBDevice *dev, USBPacket *p)\n<5> MSDState *s = (MSDState *)dev;\n<13> uint8_t *data = p->data;\n<33> if (len != 31) {\n<35> fprintf(stderr, "usb-msd: Bad CBW size");\n<41> memcpy(&cbw, data, 31);\n<43> if (le32_to_cpu(cbw.sig) != 0x43425355) {\n<45> fprintf(stderr, "usb-msd: Bad signature %08x\n",\n<47> le32_to_cpu(cbw.sig));\n<55> if (cbw.lun != 0) {\n<57> fprintf(stderr, "usb-msd: Bad LUN %d\n", cbw.lun);\n<227> s->usb_buf = data;\n<233> usb_msd_copy_data(s);\n<237> if (s->residue && s->usb_len) {\n<241> memset(s->usb_buf, 0, s->usb_len);
<1> static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) {\n<4> if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ;\n<5> if ( strlen ( client_p -> id ) == 3 ) {\n<6> exit_client ( client_p , client_p , client_p , "Mixing client and server protocol" ) ;\n<7> return 0 ;\n<9> if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , ' ' ) ) {\n<10> exit_client ( client_p , client_p , client_p , "Malformed AUTHENTICATE" ) ;\n<11> return 0 ;\n<13> saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ;\n<14> if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) {\n<22> if ( strlen ( parv [ 1 ] ) > 400 ) {\n<23> sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? "*" : source_p -> name ) ;\n<24> return 0 ;\n<26> if ( ! * source_p -> id ) {\n<30> if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ;\n<31> if ( agent_p == NULL ) {\n<33> if ( ! strcmp ( parv [ 1 ] , "EXTERNAL" ) && source_p -> certfp != NULL ) sendto_one ( saslserv_p , ":%s ENCAP %s SASL %s %s S %s %s" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] , source_p -> certfp ) ;\n<34> else sendto_one ( saslserv_p , ":%s ENCAP %s SASL %s %s S %s" , me . id , saslserv_p -> servptr -> name , source_p -> id , saslserv_p -> id , parv [ 1 ] ) ;\n<37> else sendto_one ( agent_p , ":%s ENCAP %s SASL %s %s C %s" , me . id , agent_p -> servptr -> name , source_p -> id , agent_p -> id , parv [ 1 ] ) ;\n<38> source_p -> localClient -> sasl_out ++ ;\n<39> return 0 ;
<1> int test_gf2m_add ( BIO * bp ) {\n<26> fprintf ( stderr , "GF(2^m) addition test (a) failed!\n" ) ;\n<31> fprintf ( stderr , "GF(2^m) addition test (b) failed!\n" ) ;
<1> static void lx_init(const LxBoardDesc *board, MachineState *machine)\n<33> const char *kernel_cmdline = qemu_opt_get(machine_opts, "append");\n<165> size_t bp_size = 3 * get_tag_size(0); /* first/last and memory tags */\n<201> if (kernel_cmdline) {\n<203> bp_size += get_tag_size(strlen(kernel_cmdline) + 1);\n<209> bp_size += get_tag_size(sizeof(uint32_t));\n<215> bp_size += get_tag_size(sizeof(BpMemInfo));\n<223> tagptr = (tagptr - bp_size) & ~0xff;\n<233> if (kernel_cmdline) {\n<237> strlen(kernel_cmdline) + 1, kernel_cmdline);
<1> static inline void code_gen_alloc(size_t tb_size)\n<9> if (tcg_ctx.code_gen_buffer == NULL) {\n<11> fprintf(stderr, "Could not allocate dynamic translator buffer\n");
<1> static int matroska_deliver_packet ( MatroskaDemuxContext * matroska , AVPacket * pkt ) {\n<2> if ( matroska -> num_packets > 0 ) {\n<3> memcpy ( pkt , matroska -> packets [ 0 ] , sizeof ( AVPacket ) ) ;\n<4> av_free ( matroska -> packets [ 0 ] ) ;\n<5> if ( matroska -> num_packets > 1 ) {\n<7> memmove ( & matroska -> packets [ 0 ] , & matroska -> packets [ 1 ] , ( matroska -> num_packets - 1 ) * sizeof ( AVPacket * ) ) ;\n<8> newpackets = av_realloc ( matroska -> packets , ( matroska -> num_packets - 1 ) * sizeof ( AVPacket * ) ) ;
<1> static void build_file_streams(void)\n<31> if (!strcmp(stream->fmt->name, "rtp")) {\n<37> stream->ap_in->mpeg2ts_raw = 1;\n<39> stream->ap_in->mpeg2ts_compute_pcr = 1;
<1> static void test_prepare ( ) {\n<5> char str_data [ 50 ] , data [ 50 ] ;\n<11> ulong length [ 7 ] , len ;\n<27> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<44> i < ( int ) array_elements ( my_bind ) ;\n<52> int_data = 320 ;\n<53> small_data = 1867 ;\n<55> real_data = 2 ;\n<56> double_data = 6578.001 ;\n<58> tiny_data < 100 ;\n<60> length [ 1 ] = sprintf ( str_data , "MySQL%d" , int_data ) ;\n<63> int_data += 25 ;\n<64> small_data += 10 ;\n<66> real_data += 1 ;\n<67> double_data += 10.09 ;\n<73> DIE_UNLESS ( tiny_data == ( char ) rc ) ;\n<80> o_int_data = 320 ;\n<86> o_tiny_data < 100 ;\n<88> len = sprintf ( data , "MySQL%d" , o_int_data ) ;\n<91> if ( ! opt_silent ) {\n<92> fprintf ( stdout , "\n" ) ;\n<93> fprintf ( stdout , "\n\t tiny : %d (%lu)" , tiny_data , length [ 0 ] ) ;\n<94> fprintf ( stdout , "\n\t short : %d (%lu)" , small_data , length [ 3 ] ) ;\n<95> fprintf ( stdout , "\n\t int : %d (%lu)" , int_data , length [ 2 ] ) ;\n<96> fprintf ( stdout , "\n\t big : %s (%lu)" , llstr ( big_data , llbuf ) , length [ 4 ] ) ;\n<97> fprintf ( stdout , "\n\t float : %f (%lu)" , real_data , length [ 5 ] ) ;\n<98> fprintf ( stdout , "\n\t double : %f (%lu)" , double_data , length [ 6 ] ) ;\n<99> fprintf ( stdout , "\n\t str : %s (%lu)" , str_data , length [ 1 ] ) ;\n<101> DIE_UNLESS ( tiny_data == o_tiny_data ) ;\n<103> DIE_UNLESS ( length [ 0 ] == 1 ) ;\n<104> DIE_UNLESS ( int_data == o_int_data ) ;\n<105> DIE_UNLESS ( length [ 2 ] == 4 ) ;\n<106> DIE_UNLESS ( small_data == o_small_data ) ;\n<107> DIE_UNLESS ( length [ 3 ] == 2 ) ;\n<109> DIE_UNLESS ( length [ 4 ] == 8 ) ;\n<110> DIE_UNLESS ( real_data == o_real_data ) ;\n<111> DIE_UNLESS ( length [ 5 ] == 4 ) ;\n<112> DIE_UNLESS ( cmp_double ( & double_data , & o_double_data ) ) ;\n<113> DIE_UNLESS ( length [ 6 ] == 8 ) ;\n<114> DIE_UNLESS ( strcmp ( data , str_data ) == 0 ) ;\n<115> DIE_UNLESS ( length [ 1 ] == len ) ;\n<116> o_int_data += 25 ;
<1> bool parsePGArray ( const char * atext , char * * * itemarray , int * nitems ) {\n<8> inputlen = strlen ( atext ) ;\n<15> strings = ( char * ) ( items + inputlen ) ;\n<16> atext ++ ;
<1> static void postfilter ( WMAVoiceContext * s , const float * synth , float * samples , int size , const float * lpcs , float * zero_exc_pf , int fcb_type , int pitch ) {\n<6> ff_celp_lp_synthesis_filterf ( synth_pf , lpcs , synth_filter_in , size , s -> lsps ) ;\n<7> memcpy ( & synth_pf [ - s -> lsps ] , & synth_pf [ size - s -> lsps ] , sizeof ( synth_pf [ 0 ] ) * s -> lsps ) ;
<1> static int jbig2_default_error ( void * data , const char * msg , Jbig2Severity severity , int32_t seg_idx ) {\n<2> if ( severity == JBIG2_SEVERITY_FATAL ) {\n<3> fprintf ( stderr , "jbig2 decoder FATAL ERROR: %s" , msg ) ;\n<4> if ( seg_idx != - 1 ) fprintf ( stderr , " (segment 0x%02x)" , seg_idx ) ;\n<5> fprintf ( stderr , "\n" ) ;\n<6> fflush ( stderr ) ;
<1> static const LIBSSH2_COMMON_METHOD * kex_get_method_by_name ( const char * name , size_t name_len , const LIBSSH2_COMMON_METHOD * * methodlist ) {\n<2> while ( * methodlist ) {\n<3> if ( ( strlen ( ( * methodlist ) -> name ) == name_len ) && ( strncmp ( ( * methodlist ) -> name , name , name_len ) == 0 ) ) {\n<4> return * methodlist ;\n<6> methodlist ++ ;
<1> static int sdp_parse_fmtp_config_h264(AVStream *stream,\n<5> char *attr, char *value)\n<9> AVCodecContext *codec = stream->codec;\n<17> if (!strcmp(attr, "packetization-mode")) {\n<19> av_log(codec, AV_LOG_DEBUG, "RTP Packetization Mode: %d\n", atoi(value));\n<21> h264_data->packetization_mode = atoi(value);\n<37> if (h264_data->packetization_mode > 1)\n<43> } else if (!strcmp(attr, "profile-level-id")) {\n<45> if (strlen(value) == 6) {\n<47> char buffer[3];\n<59> buffer[0]   = value[0];\n<61> buffer[1]   = value[1];\n<63> buffer[2]   = '\0';\n<65> profile_idc = strtol(buffer, NULL, 16);\n<67> buffer[0]   = value[2];\n<69> buffer[1]   = value[3];\n<71> profile_iop = strtol(buffer, NULL, 16);\n<73> buffer[0]   = value[4];\n<75> buffer[1]   = value[5];\n<77> level_idc   = strtol(buffer, NULL, 16);\n<87> h264_data->profile_idc = profile_idc;\n<89> h264_data->profile_iop = profile_iop;\n<91> h264_data->level_idc   = level_idc;\n<95> } else if (!strcmp(attr, "sprop-parameter-sets")) {\n<97> codec->extradata_size = 0;\n<99> codec->extradata      = NULL;\n<103> while (*value) {\n<137> if (packet_size > 0) {\n<139> uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n<145> if (!dest) {\n<155> if (codec->extradata_size) {\n<157> memcpy(dest, codec->extradata, codec->extradata_size);\n<159> av_free(codec->extradata);\n<165> memcpy(dest + codec->extradata_size, start_sequence,\n<169> memcpy(dest + codec->extradata_size + sizeof(start_sequence),\n<173> memset(dest + codec->extradata_size + sizeof(start_sequence) +\n<179> codec->extradata       = dest;\n<181> codec->extradata_size += sizeof(start_sequence) + packet_size;\n<193> return 0;
<1> static int bink_decode_plane(BinkContext *c, GetBitContext *gb, int plane_idx,\n<105> dst  = c->pic.data[plane_idx]  + 8*by*stride;\n<109> for (bx = 0; bx < bw; bx++, dst += 8, prev += 8) {\n<127> switch (blk) {\n<139> switch (blk) {\n<189> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<191> dctblock[0] = get_value(c, BINK_SRC_INTRA_DC);\n<193> read_dct_coeffs(gb, dctblock, bink_scan, bink_intra_quant, -1);\n<195> c->bdsp.idct_put(ublock, 8, dctblock);\n<305> dst[coordmap[*scan++]] = v;\n<311> dst[coordmap[*scan++]] = get_value(c, BINK_SRC_COLORS);\n<319> dst[coordmap[*scan++]] = get_value(c, BINK_SRC_COLORS);\n<355> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<357> dctblock[0] = get_value(c, BINK_SRC_INTRA_DC);\n<359> read_dct_coeffs(gb, dctblock, bink_scan, bink_intra_quant, -1);\n<361> c->bdsp.idct_put(dst, stride, dctblock);\n<383> memset(dctblock, 0, sizeof(*dctblock) * 64);\n<385> dctblock[0] = get_value(c, BINK_SRC_INTER_DC);\n<387> read_dct_coeffs(gb, dctblock, bink_scan, bink_inter_quant, -1);\n<389> c->bdsp.idct_add(dst, stride, dctblock);\n<405> dst[i*stride + j] = col[v & 1];\n<413> for (i = 0; i < 8; i++)\n<415> memcpy(dst + i*stride, c->bundle[BINK_SRC_COLORS].cur_ptr + i*8, 8);
<1> static int check_pbase_path ( unsigned hash ) {\n<5> ALLOC_GROW ( done_pbase_paths , done_pbase_paths_num + 1 , done_pbase_paths_alloc ) ;\n<7> if ( pos < done_pbase_paths_num ) memmove ( done_pbase_paths + pos + 1 , done_pbase_paths + pos , ( done_pbase_paths_num - pos - 1 ) * sizeof ( unsigned ) ) ;
<1> static int decode_i_frame(FourXContext *f, AVFrame *frame, const uint8_t *buf, int length)\n<55> prestream = read_huffman_tables(f, prestream, prestream_size);\n<75> av_fast_malloc(&f->bitstream_buffer, &f->bitstream_buffer_size,\n<79> if (!f->bitstream_buffer)\n<83> f->dsp.bswap_buf(f->bitstream_buffer, (const uint32_t*)prestream,\n<85> prestream_size / 4);\n<87> memset((uint8_t*)f->bitstream_buffer + prestream_size,
<1> void bareetraxfs_init (ram_addr_t ram_size,\n<5> const char *kernel_filename, const char *kernel_cmdline,\n<55> cpu_register_physical_memory(0x40000000, ram_size, phys_ram | IO_MEM_RAM);\n<87> cpu_irq = cris_pic_init_cpu(env);\n<173> if (kernel_filename) {\n<195> kernel_size = load_image_targphys(kernel_filename, 0x40004000,\n<209> if (kernel_cmdline && (kcmdline_len = strlen(kernel_cmdline))) {\n<211> if (kcmdline_len > 256) {\n<213> fprintf(stderr, "Too long CRIS kernel cmdline (max 256)\n");\n<221> env->regs[10] = 0x87109563;\n<223> env->regs[11] = 0x40000000;\n<225> pstrcpy_targphys(env->regs[11], 256, kernel_cmdline);\n<231> env->pc = bootstrap_pc;\n<235> printf ("pc =%x\n", env->pc);\n<237> printf ("ram size =%ld\n", ram_size);
<1> void hb_face_destroy ( hb_face_t * face ) {\n<2> if ( ! hb_object_destroy ( face ) ) return ;\n<13> free ( face ) ;
<1> static void cmv_decode_inter ( CmvContext * s , AVFrame * frame , const uint8_t * buf , const uint8_t * buf_end ) {\n<11> unsigned char * dst = frame -> data [ 0 ] + ( y * 4 ) * frame -> linesize [ 0 ] + x * 4 ;\n<12> if ( raw + 16 < buf_end && * raw == 0xFF ) {\n<13> raw ++ ;\n<14> memcpy ( dst , raw , 4 ) ;\n<15> memcpy ( dst + frame -> linesize [ 0 ] , raw + 4 , 4 ) ;\n<16> memcpy ( dst + 2 * frame -> linesize [ 0 ] , raw + 8 , 4 ) ;\n<17> memcpy ( dst + 3 * frame -> linesize [ 0 ] , raw + 12 , 4 ) ;\n<18> raw += 16 ;\n<22> int yoffset = ( ( * raw >> 4 ) ) - 7 ;
<1> static int usbdev_mmap ( struct file * file , struct vm_area_struct * vma ) {\n<16> mem = usb_alloc_coherent ( ps -> dev , size , GFP_USER , & dma_handle ) ;\n<17> if ( ! mem ) {\n<21> memset ( mem , 0 , size ) ;\n<22> usbm -> mem = mem ;\n<24> usbm -> size = size ;\n<29> if ( remap_pfn_range ( vma , vma -> vm_start , virt_to_phys ( usbm -> mem ) >> PAGE_SHIFT , size , vma -> vm_page_prot ) < 0 ) {
<1> static int do_start_slave_sql ( MYSQL * mysql_con ) {\n<6> if ( row && row [ 11 ] ) {\n<7> if ( ! strcmp ( row [ 11 ] , "Yes" ) ) {\n<8> mysql_free_result ( slave ) ;\n<9> return ( 0 ) ;\n<13> mysql_free_result ( slave ) ;\n<14> if ( mysql_query_with_error_report ( mysql_con , 0 , "START SLAVE" ) ) {\n<15> fprintf ( stderr , "%s: Error: Unable to start slave\n" , my_progname_short ) ;
<1> static int get_blocksize(BlockDriverState *bdrv)\n<17> memset(cmd, 0, sizeof(cmd));\n<19> memset(buf, 0, sizeof(buf));\n<25> memset(&io_header, 0, sizeof(io_header));\n<35> io_header.cmdp = cmd;\n<47> ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
<7> const AVCodec *codec = avctx->codec;\n<9> AVCodecContext *src = avctx;\n<102> p->avctx  = copy;\n<106> if (!copy) {\n<140> src = copy;\n<146> err = codec->init(copy);\n<150> update_context_from_thread(avctx, copy, 1);\n<154> copy->priv_data = av_malloc(codec->priv_data_size);\n<156> if (!copy->priv_data) {\n<164> memcpy(copy->priv_data, src->priv_data, codec->priv_data_size);\n<172> err = codec->init_thread_copy(copy);
<1> int qemuMonitorTextAddPCIDisk ( qemuMonitorPtr mon , const char * path , const char * bus , virDomainDevicePCIAddress * guestAddr ) {\n<12> try_command : if ( virAsprintf ( & cmd , "pci_add %s storage file=%s,if=%s" , ( tryOldSyntax ? "0" : "pci_addr=auto" ) , safe_path , bus ) < 0 ) {\n<16> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<20> if ( qemuMonitorTextParsePciAddReply ( mon , reply , guestAddr ) < 0 ) {\n<21> if ( ! tryOldSyntax && strstr ( reply , "invalid char in expression" ) ) {\n<22> VIR_FREE ( reply ) ;\n<23> VIR_FREE ( cmd ) ;\n<24> tryOldSyntax = 1 ;\n<27> qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( "adding %s disk failed %s: %s" ) , bus , path , reply ) ;
<1> DriveInfo *drive_init(QemuOpts *all_opts, BlockInterfaceType block_default_type)\n<157> if (qemu_opt_get(legacy_opts, "boot") != NULL) {\n<159> fprintf(stderr, "qemu-kvm: boot=on|off is deprecated and will be "\n<171> value = qemu_opt_get(legacy_opts, "media");\n<173> if (value) {\n<175> if (!strcmp(value, "disk")) {\n<177> media = MEDIA_DISK;\n<179> } else if (!strcmp(value, "cdrom")) {\n<181> media = MEDIA_CDROM;\n<183> read_only = true;\n<187> error_report("'%s' invalid media", value);\n<199> read_only |= qemu_opt_get_bool(legacy_opts, "read-only", false);\n<201> copy_on_read = qemu_opt_get_bool(legacy_opts, "copy-on-read", false);\n<205> if (read_only && copy_on_read) {\n<217> qstring_from_str(read_only ? "on" : "off"));\n<221> qstring_from_str(copy_on_read ? "on" :"off"));\n<227> value = qemu_opt_get(legacy_opts, "if");\n<229> if (value) {\n<233> type < IF_COUNT && strcmp(value, if_name[type]);\n<235> type++) {\n<241> error_report("unsupported bus type '%s'", value);\n<299> if (value != NULL) {\n<301> if (!cyls) {\n<311> if (!strcmp(value, "none")) {\n<313> translation = BIOS_ATA_TRANSLATION_NONE;\n<315> } else if (!strcmp(value, "lba")) {\n<317> translation = BIOS_ATA_TRANSLATION_LBA;\n<319> } else if (!strcmp(value, "large")) {\n<321> translation = BIOS_ATA_TRANSLATION_LARGE;\n<323> } else if (!strcmp(value, "rechs")) {\n<325> translation = BIOS_ATA_TRANSLATION_RECHS;\n<327> } else if (!strcmp(value, "auto")) {\n<329> translation = BIOS_ATA_TRANSLATION_AUTO;\n<333> error_report("'%s' invalid translation type", value);\n<343> if (media == MEDIA_CDROM) {\n<451> new_id = g_strdup_printf("%s%i%s%i", if_name[type], bus_id,
<1> static int cfhd_decode(AVCodecContext *avctx, void *data, int *got_frame,\n<457> coeff_data = s->plane[s->channel_num].subband[s->subband_num_actual];\n<511> coeff_data += lowpass_width;\n<525> if (lowpass_height & 1) {\n<527> memcpy(&coeff_data[lowpass_height * lowpass_width],\n<531> lowpass_width * sizeof(*coeff_data));\n<633> *coeff_data++ = coeff;\n<671> *coeff_data++ = coeff;\n<719> if (highpass_height & 1) {\n<721> memcpy(&coeff_data[highpass_height * highpass_stride],\n<725> highpass_stride * sizeof(*coeff_data));
<1> static char * convert_string_datum ( Datum value , Oid typid ) {\n<4> case CHAROID : val = ( char * ) palloc ( 2 ) ;\n<5> val [ 0 ] = DatumGetChar ( value ) ;\n<6> val [ 1 ] = '\0' ;\n<8> case BPCHAROID : case VARCHAROID : case TEXTOID : val = TextDatumGetCString ( value ) ;\n<12> val = pstrdup ( NameStr ( * nm ) ) ;\n<18> if ( ! lc_collate_is_c ( DEFAULT_COLLATION_OID ) ) {\n<29> xfrmlen2 = strxfrm ( xfrmstr , val , xfrmlen + 1 ) ;\n<30> Assert ( xfrmlen2 <= xfrmlen ) ;\n<31> pfree ( val ) ;\n<32> val = xfrmstr ;
<1> static void completion_msg_server ( GSList * * list , SERVER_REC * server , const char * nick , const char * prefix ) {\n<5> g_return_if_fail ( nick != NULL ) ;\n<6> len = strlen ( nick ) ;\n<12> if ( len != 0 && g_ascii_strncasecmp ( rec -> nick , nick , len ) != 0 ) continue ;
<1> static FILE * NeedsVariationSequenceTable ( SplineFont * sf , int * vslen ) {\n<23> ++ i ) if ( vses [ i ] == altuni -> vs ) break ;\n<26> if ( vses == vsbuf ) {\n<27> vses = malloc ( ( vs_max *= 2 ) * sizeof ( uint32 ) ) ;\n<28> memcpy ( vses , vsbuf , sizeof ( vsbuf ) ) ;\n<30> else vses = realloc ( vses , ( vs_max += 512 ) * sizeof ( uint32 ) ) ;\n<32> vses [ vs_cnt ++ ] = altuni -> vs ;\n<39> if ( vs_cnt == 0 ) {\n<48> if ( vses [ i ] > vses [ j ] ) {\n<49> int temp = vses [ i ] ;\n<50> vses [ i ] = vses [ j ] ;\n<51> vses [ j ] = temp ;\n<54> avail = malloc ( unicode4_size * sizeof ( uint32 ) ) ;\n<62> putu24 ( format14 , vses [ i ] ) ;\n<67> i < vs_cnt ;\n<69> memset ( avail , 0 , unicode4_size * sizeof ( uint32 ) ) ;\n<77> if ( altuni -> unienc != - 1 && altuni -> unienc < ( int ) unicode4_size && altuni -> vs == vses [ i ] && altuni -> fid == 0 ) {\n<82> avail [ altuni -> unienc ] = gid | vs_default ;\n<86> avail [ altuni -> unienc ] = gid | vs_nondefault ;\n<100> ++ j ) if ( avail [ j ] & vs_default ) {\n<102> ( unsigned ) k < unicode4_size && ( avail [ k ] & vs_default ) ;\n<111> ++ j ) if ( avail [ j ] & vs_default ) {\n<113> ( unsigned ) k < unicode4_size && ( avail [ k ] & vs_default ) ;\n<129> ++ j ) if ( avail [ j ] & vs_nondefault ) ++ cnt ;\n<133> ++ j ) if ( avail [ j ] & vs_nondefault ) {\n<135> putshort ( format14 , sf -> glyphs [ avail [ j ] & 0xffff ] -> ttf_glyph ) ;\n<152> free ( avail ) ;\n<153> if ( vses != vsbuf ) free ( vses ) ;
<1> static void new_pes_packet(PESContext *pes, AVPacket *pkt)\n<5> av_init_packet(pkt);\n<11> pkt->data = pes->buffer;\n<13> pkt->size = pes->data_index;\n<15> memset(pkt->data+pkt->size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
<1> static void add_preferred_base ( unsigned char * sha1 ) {\n<8> if ( ! data ) return ;\n<12> if ( ! hashcmp ( it -> pcache . sha1 , tree_sha1 ) ) {\n<13> free ( data ) ;
<1> static int hls_window(AVFormatContext *s, int last)\n<23> const char *proto = avio_find_protocol_name(s->filename);\n<25> int use_rename = proto && !strcmp(proto, "file");\n<59> if (!use_rename && !warned_non_file++)\n<109> for (en = hls->segments; en; en = en->next) {\n<111> if ((hls->encrypt || hls->key_info_file) && (!key_uri || strcmp(en->key_uri, key_uri) ||\n<113> av_strcasecmp(en->iv_string, iv_string))) {\n<115> avio_printf(out, "#EXT-X-KEY:METHOD=AES-128,URI=\"%s\"", en->key_uri);\n<139> if ((hls->segment_type == SEGMENT_TYPE_FMP4) && (en == hls->segments)) {\n<217> if (!((hls->segment_type == SEGMENT_TYPE_FMP4) && (en == hls->segments))) {
<1> static int huffman_decode ( MPADecodeContext * s , GranuleDef * g , int16_t * exponents , int end_pos2 ) {\n<18> if ( ! l ) {\n<19> memset ( & g -> sb_hybrid [ s_index ] , 0 , sizeof ( * g -> sb_hybrid ) * 2 * j ) ;\n<35> g -> sb_hybrid [ s_index ] = g -> sb_hybrid [ s_index + 1 ] = 0 ;\n<45> READ_FLIP_SIGN ( g -> sb_hybrid + s_index , RENAME ( expval_table ) [ exponent ] + x ) }\n<50> g -> sb_hybrid [ s_index ] = v ;\n<53> READ_FLIP_SIGN ( g -> sb_hybrid + s_index + 1 , RENAME ( expval_table ) [ exponent ] + y ) }\n<58> g -> sb_hybrid [ s_index + 1 ] = v ;\n<66> READ_FLIP_SIGN ( g -> sb_hybrid + s_index + ! ! y , RENAME ( expval_table ) [ exponent ] + x ) }\n<71> g -> sb_hybrid [ s_index + ! ! y ] = v ;\n<73> g -> sb_hybrid [ s_index + ! y ] = 0 ;\n<97> g -> sb_hybrid [ s_index + 0 ] = g -> sb_hybrid [ s_index + 1 ] = g -> sb_hybrid [ s_index + 2 ] = g -> sb_hybrid [ s_index + 3 ] = 0 ;\n<105> READ_FLIP_SIGN ( g -> sb_hybrid + pos , RENAME ( exp_table ) + exponents [ pos ] ) }\n<117> memset ( & g -> sb_hybrid [ s_index ] , 0 , sizeof ( * g -> sb_hybrid ) * ( 576 - s_index ) ) ;
<1> static int svq3_decode_frame (AVCodecContext *avctx,\n<47> if (MPV_common_init (s) < 0)\n<63> extradata = (unsigned char *)avctx->extradata;\n<65> for (m = 0; m < avctx->extradata_size; m++) {\n<67> if (!memcmp (extradata, "SEQH", 4))\n<71> extradata++;\n<79> if (!memcmp (extradata, "SEQH", 4)) {\n<87> size = BE_32(&extradata[4]);\n<89> init_get_bits (&gb, extradata + 8, size);\n<95> if (get_bits (&gb, 3) == 7) {\n<105> h->halfpel_flag = get_bits1 (&gb);\n<107> h->thirdpel_flag = get_bits1 (&gb);\n<113> get_bits1 (&gb);\n<115> get_bits1 (&gb);\n<117> get_bits1 (&gb);\n<119> get_bits1 (&gb);\n<123> s->low_delay = get_bits1 (&gb);\n<129> get_bits1 (&gb);\n<133> while (get_bits1 (&gb)) {\n<141> h->unknown_svq3_flag = get_bits1 (&gb);\n<143> avctx->has_b_frames = !s->low_delay;
<1> void mips_malta_init (ram_addr_t ram_size, int vga_ram_size,\n<70> fprintf(stderr, "Unable to find CPU definition\n");\n<247> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static void async_complete(void *opaque)\n<25> if (urbs > 2) {\n<27> fprintf(stderr, "husb: %d iso urbs finished at once\n", urbs);\n<79> if (inflight == 0 && is_iso_started(s, aurb->urb.endpoint & 0xf)) {\n<81> fprintf(stderr, "husb: out of buffers for iso stream\n");
<1> int evbuffer_remove ( struct evbuffer * buf , void * data , size_t datlen ) {\n<3> if ( nread >= buf -> off ) nread = buf -> off ;\n<4> memcpy ( data , buf -> buffer , nread ) ;\n<5> evbuffer_drain ( buf , nread ) ;
<1> krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) {\n<7> char * * subtreelist = NULL ;\n<8> char * user = NULL , * subtree = NULL , * principal_dn = NULL ;\n<12> char * filtuser = NULL ;\n<13> struct berval * * bersecretkey = NULL ;\n<17> char * standalone_principal_dn = NULL ;\n<19> krb5_key_data * * keys = NULL ;\n<34> if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ;\n<41> if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ;\n<42> filtuser = ldap_filter_correct ( user ) ;\n<43> if ( filtuser == NULL ) {\n<49> if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ;\n<51> if ( entry -> mask & KADM5_LOAD ) {\n<54> char * filter = NULL ;\n<55> if ( asprintf ( & filter , FILTER "%s))" , filtuser ) < 0 ) {\n<56> filter = NULL ;\n<57> st = ENOMEM ;\n<60> if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ;\n<63> found_entry == FALSE && tree < ntrees ;\n<65> if ( principal_dn == NULL ) {\n<66> LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ;\n<69> LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ;\n<73> if ( numlentries > 1 ) {\n<74> free ( filter ) ;\n<76> k5_setmsg ( context , st , _ ( "operation can not continue, more than one " "entry with principal name \"%s\" found" ) , user ) ;\n<81> if ( principal_dn == NULL ) {\n<84> if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) {\n<87> free ( filter ) ;\n<94> else if ( st != LDAP_NO_SUCH_OBJECT ) {\n<96> free ( filter ) ;\n<102> free ( filter ) ;\n<103> if ( found_entry == FALSE && principal_dn != NULL ) {\n<105> standalone_principal_dn = strdup ( principal_dn ) ;\n<106> CHECK_NULL ( standalone_principal_dn ) ;\n<109> if ( principal_dn == NULL && xargs . dn == NULL ) {\n<110> if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( "krbtgt" ) && strncmp ( entry -> princ -> data [ 0 ] . data , "krbtgt" , entry -> princ -> data [ 0 ] . length ) == 0 ) {\n<111> subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;\n<113> else if ( xargs . containerdn ) {\n<114> if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) {\n<123> subtree = strdup ( xargs . containerdn ) ;\n<125> else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) {\n<126> subtree = strdup ( ldap_context -> lrparams -> containerref ) ;\n<129> subtree = strdup ( ldap_context -> lrparams -> realmdn ) ;\n<131> CHECK_NULL ( subtree ) ;\n<132> if ( asprintf ( & standalone_principal_dn , "krbprincipalname=%s,%s" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ;\n<133> CHECK_NULL ( standalone_principal_dn ) ;\n<135> free ( subtree ) ;\n<136> subtree = NULL ;\n<140> char * dn = NULL ;\n<143> dn = xargs . dn ;\n<146> dn = xargs . linkdn ;\n<148> else if ( standalone_principal_dn != NULL ) {\n<149> dn = standalone_principal_dn ;\n<151> if ( subtreelist == NULL ) {\n<152> st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ;\n<156> tre < ntrees ;\n<158> if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) {\n<159> outofsubtree = FALSE ;\n<163> dnlen = strlen ( dn ) ;\n<164> subtreelen = strlen ( subtreelist [ tre ] ) ;\n<165> if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) {\n<176> if ( standalone_principal_dn == NULL ) {\n<182> LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ;\n<217> if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) {\n<222> if ( linkdns != NULL ) {\n<227> linkdns [ j ] != NULL ;\n<228> ++ j ) free ( linkdns [ j ] ) ;\n<229> free ( linkdns ) ;\n<235> if ( entry -> mask & KADM5_LAST_SUCCESS ) {\n<236> memset ( strval , 0 , sizeof ( strval ) ) ;\n<237> if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ;\n<238> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastSuccessfulAuth" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {\n<239> free ( strval [ 0 ] ) ;\n<242> free ( strval [ 0 ] ) ;\n<244> if ( entry -> mask & KADM5_LAST_FAILED ) {\n<245> memset ( strval , 0 , sizeof ( strval ) ) ;\n<246> if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ;\n<247> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastFailedAuth" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {\n<248> free ( strval [ 0 ] ) ;\n<251> free ( strval [ 0 ] ) ;\n<291> if ( entry -> mask & KADM5_PRINCIPAL ) {\n<292> memset ( strval , 0 , sizeof ( strval ) ) ;\n<293> strval [ 0 ] = user ;\n<294> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbprincipalname" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;\n<296> if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) {\n<297> memset ( strval , 0 , sizeof ( strval ) ) ;\n<298> if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ;\n<299> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbprincipalexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {\n<300> free ( strval [ 0 ] ) ;\n<303> free ( strval [ 0 ] ) ;\n<305> if ( entry -> mask & KADM5_PW_EXPIRATION ) {\n<306> memset ( strval , 0 , sizeof ( strval ) ) ;\n<307> if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ;\n<308> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpasswordexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {\n<309> free ( strval [ 0 ] ) ;\n<312> free ( strval [ 0 ] ) ;\n<314> if ( entry -> mask & KADM5_POLICY ) {\n<315> memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ;\n<320> if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) {\n<326> if ( princ_ent . aux_attributes & KADM5_POLICY ) {\n<327> memset ( strval , 0 , sizeof ( strval ) ) ;\n<328> if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ;\n<329> strval [ 0 ] = polname ;\n<330> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;\n<348> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , "krbprincipalkey" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) goto cleanup ;\n<349> if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) {\n<350> memset ( strval , 0 , sizeof ( strval ) ) ;\n<351> if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ;\n<352> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpasswordexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {\n<353> free ( strval [ 0 ] ) ;\n<356> free ( strval [ 0 ] ) ;\n<360> if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ;\n<361> memset ( strval , 0 , sizeof ( strval ) ) ;\n<362> if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ;\n<363> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastPwdChange" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {\n<364> free ( strval [ 0 ] ) ;\n<367> free ( strval [ 0 ] ) ;\n<381> if ( count != 0 ) {\n<383> ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ;\n<384> if ( ber_tl_data == NULL ) {\n<392> if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ;\n<396> ber_tl_data [ count ] = NULL ;\n<397> st = krb5_add_ber_mem_ldap_mod ( & mods , "krbExtraData" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ;\n<400> ber_tl_data [ j ] != NULL ;\n<402> free ( ber_tl_data [ j ] -> bv_val ) ;\n<403> free ( ber_tl_data [ j ] ) ;\n<405> free ( ber_tl_data ) ;\n<409> if ( unlock_time != 0 ) {\n<410> memset ( strval , 0 , sizeof ( strval ) ) ;\n<411> if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ;\n<412> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastAdminUnlock" , LDAP_MOD_REPLACE , strval ) ) != 0 ) {\n<413> free ( strval [ 0 ] ) ;\n<416> free ( strval [ 0 ] ) ;\n<419> if ( xargs . tktpolicydn != NULL ) {\n<421> if ( strlen ( xargs . tktpolicydn ) != 0 ) {\n<422> st = checkattributevalue ( ld , xargs . tktpolicydn , "objectclass" , policyclass , & tmask ) ;\n<423> CHECK_CLASS_VALIDITY ( st , tmask , _ ( "ticket policy object value: " ) ) ;\n<424> strval [ 0 ] = xargs . tktpolicydn ;\n<425> strval [ 1 ] = NULL ;\n<426> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbticketpolicyreference" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;\n<429> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbticketpolicyreference" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ;\n<432> if ( establish_links == TRUE ) {\n<433> memset ( strval , 0 , sizeof ( strval ) ) ;\n<434> strval [ 0 ] = xargs . linkdn ;\n<435> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbObjectReferences" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ;\n<438> if ( create_standalone_prinicipal == TRUE ) {\n<439> memset ( strval , 0 , sizeof ( strval ) ) ;\n<443> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "objectclass" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ;\n<444> st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ;\n<446> st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ;\n<454> st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ;\n<470> if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , "objectclass" , attrvalues , & amask ) ) != 0 ) goto cleanup ;\n<471> memset ( strval , 0 , sizeof ( strval ) ) ;\n<478> if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "objectclass" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ;\n<482> else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ;\n<491> cleanup : if ( user ) free ( user ) ;\n<492> if ( filtuser ) free ( filtuser ) ;\n<493> free_xargs ( xargs ) ;\n<494> if ( standalone_principal_dn ) free ( standalone_principal_dn ) ;\n<495> if ( principal_dn ) free ( principal_dn ) ;\n<496> if ( polname != NULL ) free ( polname ) ;\n<498> tre < ntrees ;\n<499> tre ++ ) free ( subtreelist [ tre ] ) ;\n<500> free ( subtreelist ) ;\n<501> if ( subtree ) free ( subtree ) ;\n<502> if ( bersecretkey ) {\n<504> bersecretkey [ l ] ;\n<506> if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ;\n<507> free ( bersecretkey [ l ] ) ;\n<509> free ( bersecretkey ) ;\n<511> if ( keys ) free ( keys ) ;\n<513> ldap_osa_free_princ_ent ( & princ_ent ) ;
<1> static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) {\n<3> stream = calloc ( 1 , sizeof ( * stream ) ) ;\n<4> if ( stream == NULL ) {\n<7> if ( prev ) {\n<8> memcpy ( stream , prev , sizeof ( * stream ) ) ;\n<9> stream -> index ++ ;\n<10> prev -> next = stream ;\n<29> return stream ;
<1> unsigned char * gcry_pk_get_keygrip ( gcry_sexp_t key , unsigned char * array ) {\n<10> gcry_md_hd_t md = NULL ;\n<32> if ( gcry_md_open ( & md , GCRY_MD_SHA1 , 0 ) ) goto fail ;\n<46> if ( ! data ) goto fail ;\n<47> snprintf ( buf , sizeof buf , "(1:%c%u:" , * s , ( unsigned int ) datalen ) ;\n<48> gcry_md_write ( md , buf , strlen ( buf ) ) ;\n<49> gcry_md_write ( md , data , datalen ) ;\n<52> gcry_md_write ( md , ")" , 1 ) ;\n<55> if ( ! array ) {\n<57> if ( ! array ) goto fail ;\n<59> memcpy ( array , gcry_md_read ( md , GCRY_MD_SHA1 ) , 20 ) ;\n<65> return okay ? array : NULL ;
<1> void vnc_client_read(void *opaque)\n<5> VncState *vs = opaque;\n<39> ret = recv(vs->csock, buffer_end(&vs->input), 4096, 0);\n<41> ret = vnc_client_io_error(vs, ret, socket_error());\n<61> ret = vs->read_handler(vs, vs->input.buffer, len);\n<63> if (vs->csock == -1)\n<69> if (!ret) {\n<71> memmove(vs->input.buffer, vs->input.buffer + len, (vs->input.offset - len));
<1> static void sun4m_hw_init ( const struct sun4m_hwdef * hwdef , ram_addr_t RAM_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n<49> if ( graphic_depth != 8 && graphic_depth != 24 ) {\n<50> fprintf ( stderr , "qemu: Unsupported depth: %d\n" , graphic_depth ) ;\n<55> tcx_init ( hwdef -> tcx_base , 0x00100000 , graphic_width , graphic_height , graphic_depth ) ;\n<76> if ( hwdef -> fd_base ) {\n<77> memset ( fd , 0 , sizeof ( fd ) ) ;\n<79> sun4m_fdctrl_init ( slavio_irq [ 22 ] , hwdef -> fd_base , fd , & fdc_tc ) ;\n<85> if ( drive_get_max_bus ( IF_SCSI ) > 0 ) {\n<86> fprintf ( stderr , "qemu: too many SCSI bus\n" ) ;\n<103> nvram_init ( nvram , ( uint8_t * ) & nd_table [ 0 ] . macaddr , kernel_cmdline , boot_device , RAM_size , kernel_size , graphic_width , graphic_height , graphic_depth , hwdef -> nvram_machine_id , "Sun4m" ) ;\n<113> if ( kernel_cmdline ) {\n<116> fw_cfg_add_string ( fw_cfg , FW_CFG_CMDLINE_DATA , kernel_cmdline ) ;\n<117> fw_cfg_add_i32 ( fw_cfg , FW_CFG_CMDLINE_SIZE , strlen ( kernel_cmdline ) + 1 ) ;
<1> static int y4m_parse_tags ( y4m_input * _y4m , char * _tags ) {\n<13> p = q ) {\n<14> while ( * p == ' ' ) p ++ ;\n<15> if ( p [ 0 ] == '\0' ) break ;\n<19> switch ( p [ 0 ] ) {\n<21> if ( sscanf ( p + 1 , "%d" , & _y4m -> pic_w ) != 1 ) return - 1 ;\n<22> got_w = 1 ;\n<26> if ( sscanf ( p + 1 , "%d" , & _y4m -> pic_h ) != 1 ) return - 1 ;\n<27> got_h = 1 ;\n<31> if ( sscanf ( p + 1 , "%d:%d" , & _y4m -> fps_n , & _y4m -> fps_d ) != 2 ) {\n<32> return - 1 ;\n<34> got_fps = 1 ;\n<43> if ( sscanf ( p + 1 , "%d:%d" , & _y4m -> par_n , & _y4m -> par_d ) != 2 ) {\n<44> return - 1 ;\n<46> got_par = 1 ;\n<50> if ( q - p > 16 ) return - 1 ;\n<51> memcpy ( _y4m -> chroma_type , p + 1 , q - p - 1 ) ;\n<52> _y4m -> chroma_type [ q - p - 1 ] = '\0' ;\n<61> if ( ! got_chroma ) strcpy ( _y4m -> chroma_type , "420" ) ;
<1> static void *sigwait_compat(void *opaque)\n<27> if (err == -1 && errno == EINTR) {\n<37> if (err > 0) {\n<39> char buffer[128];\n<45> memcpy(buffer, &err, sizeof(err));\n<79> } while (err >= 0);
<1> static int get_qcd(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q,\n<6> if ((ret = get_qcx(s, n, &tmp)) < 0)\n<8> for (compno = 0; compno < s->ncomponents; compno++)\n<9> if (!(properties[compno] & HAD_QCC))\n<10> memcpy(q + compno, &tmp, sizeof(tmp));
<1> static xsltAttrVTPtr xsltNewAttrVT ( xsltStylesheetPtr style ) {\n<4> if ( cur == NULL ) {\n<9> memset ( cur , 0 , sizeof ( xsltAttrVT ) ) ;\n<14> style -> attVTs = ( xsltAttrVTPtr ) cur ;\n<15> return ( cur ) ;
<1> static void test_prepare_insert_update ( ) {\n<11> * cur_query ;\n<14> printf ( "\nRunning query: %s" , * cur_query ) ;\n<15> strmov ( query , * cur_query ) ;\n<23> i < 3 ;\n<25> printf ( "\nExecuting last statement again" ) ;
<1> static void test_bug32265 ( ) {\n<21> DIE_UNLESS ( field ) ;\n<22> DIE_UNLESS ( strcmp ( field -> table , "t1" ) == 0 ) ;\n<23> DIE_UNLESS ( strcmp ( field -> org_table , "t1" ) == 0 ) ;\n<24> DIE_UNLESS ( strcmp ( field -> db , "client_test_db" ) == 0 ) ;\n<31> field = mysql_fetch_field ( metadata ) ;\n<32> DIE_UNLESS ( strcmp ( field -> table , "" ) == 0 ) ;\n<33> DIE_UNLESS ( strcmp ( field -> org_table , "t1" ) == 0 ) ;\n<34> DIE_UNLESS ( strcmp ( field -> db , "client_test_db" ) == 0 ) ;\n<41> field = mysql_fetch_field ( metadata ) ;\n<42> DIE_UNLESS ( strcmp ( field -> table , "" ) == 0 ) ;\n<43> DIE_UNLESS ( strcmp ( field -> org_table , "t1" ) == 0 ) ;\n<44> DIE_UNLESS ( strcmp ( field -> db , "client_test_db" ) == 0 ) ;\n<51> field = mysql_fetch_field ( metadata ) ;\n<52> DIE_UNLESS ( strcmp ( field -> table , "v1" ) == 0 ) ;\n<53> DIE_UNLESS ( strcmp ( field -> org_table , "v1" ) == 0 ) ;\n<54> DIE_UNLESS ( strcmp ( field -> db , "client_test_db" ) == 0 ) ;\n<61> field = mysql_fetch_field ( metadata ) ;\n<62> DIE_UNLESS ( strcmp ( field -> table , "v1" ) == 0 ) ;\n<63> DIE_UNLESS ( strcmp ( field -> org_table , "v1" ) == 0 ) ;\n<64> DIE_UNLESS ( strcmp ( field -> db , "client_test_db" ) == 0 ) ;
<1> int qcow2_grow_l1_table(BlockDriverState *bs, int min_size, bool exact_size)\n<5> BDRVQcowState *s = bs->opaque;\n<17> if (min_size <= s->l1_size)\n<59> new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n<61> memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n<73> g_free(new_l1_table);\n<95> new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n<97> ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n<125> g_free(s->l1_table);\n<139> g_free(new_l1_table);
<1> void smc91c111_init(NICInfo *nd, uint32_t base, qemu_irq irq)\n<11> qemu_check_nic_model(nd, "smc91c111");\n<25> memcpy(s->macaddr, nd->macaddr, 6);\n<29> smc91c111_reset(s);\n<33> s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<37> qemu_format_nic_info_str(s->vc, s->macaddr);
<1> int bdrv_write(BlockDriverState *bs, int64_t sector_num,\n<14> if (ret < 0) {\n<15> printf("bdrv_write ret=%d\n", ret);\n<16> return ret;
<1> int net_client_init(Monitor *mon, QemuOpts *opts, int is_netdev)\n<15> if (!type) {\n<25> if (is_netdev) {\n<27> if (strcmp(type, "tap") != 0 &&\n<41> strcmp(type, "socket") != 0) {\n<43> qerror_report(QERR_INVALID_PARAMETER_VALUE, "type",\n<47> return -1;\n<53> if (qemu_opt_get(opts, "vlan")) {\n<93> if (net_client_types[i].type != NULL &&\n<95> !strcmp(net_client_types[i].type, type)) {\n<103> if (qemu_opts_validate(opts, &net_client_types[i].desc[0]) == -1) {\n<117> (strcmp(type, "nic") == 0 && qemu_opt_get(opts, "netdev")))) {\n<135> qerror_report(QERR_DEVICE_INIT_FAILED, type);
<50> tf = ( rtmpt_frag_t * ) wmem_tree_lookup32_le ( rconv -> frags [ cdir ] , seq + offset - 1 ) ;\n<52> RTMPT_DEBUG ( " tf seq=%d lseq=%d h=%d l=%d\n" , tf -> seq , tf -> lastseq , tf -> have , tf -> len ) ;\n<53> if ( tf -> have >= tf -> len || seq + offset < tf -> seq || seq + offset > tf -> lastseq + tf -> len - tf -> have ) {\n<84> if ( tf -> have < tf -> len ) {\n<90> if ( ! tf ) {\n<133> message_hlen = tf -> len - basic_hlen ;\n<215> if ( ! tf && body_len <= chunk_size && tp -> want <= remain ) {\n<229> tp -> data . p = ( guint8 * ) wmem_alloc ( wmem_file_scope ( ) , tp -> bhlen + tp -> mhlen + tp -> len ) ;\n<230> if ( tf && tf -> ishdr ) {\n<231> memcpy ( tp -> data . p , tf -> saved . d , tf -> len ) ;\n<262> tvb_memcpy ( tvb , tp -> data . p + tp -> have , offset , want ) ;
<1> static int aac_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<195> if ((ret = ff_alloc_packet2(avctx, avpkt, 8192 * s->channels, 0)) < 0)\n<219> memset(chan_el_counter, 0, sizeof(chan_el_counter));\n<221> for (i = 0; i < s->chan_map[0]; i++) {\n<231> cpe      = &s->cpe[i];\n<235> memset(cpe->is_mask, 0, sizeof(cpe->is_mask));\n<237> memset(cpe->ms_mask, 0, sizeof(cpe->ms_mask));\n<241> put_bits(&s->pb, 4, chan_el_counter[tag]++);\n<243> for (ch = 0; ch < chans; ch++) {\n<245> sce = &cpe->ch[ch];\n<251> memset(&sce->ics.prediction_used, 0, sizeof(sce->ics.prediction_used));\n<253> memset(&sce->tns, 0, sizeof(TemporalNoiseShaping));\n<321> s->coder->search_for_pns(s, avctx, sce);\n<325> s->coder->search_for_tns(s, sce);\n<329> s->coder->apply_tns_filt(s, sce);\n<343> s->coder->search_for_is(s, avctx, cpe);\n<347> apply_intensity_stereo(cpe);\n<361> s->coder->search_for_pred(s, sce);\n<369> s->coder->adjust_common_prediction(s, cpe);\n<379> s->coder->apply_main_pred(s, sce);\n<391> s->coder->search_for_ms(s, cpe);\n<393> else if (cpe->common_window)\n<395> memset(cpe->ms_mask, 1, sizeof(cpe->ms_mask));\n<399> cpe->ms_mask[w] = cpe->is_mask[w] ? 0 : cpe->ms_mask[w];\n<401> apply_mid_side_stereo(cpe);\n<405> adjust_frame_information(cpe, chans);\n<419> encode_ms_info(&s->pb, cpe);\n<521> if (s->lambda < 300.f || ratio > 0.9f) {\n<537> for (ch = 0; ch < chans; ch++)\n<539> memcpy(cpe->ch[ch].coeffs, cpe->ch[ch].pcoeffs, sizeof(cpe->ch[ch].coeffs));
<1> static void runstate_init(void)\n<9> memset(&runstate_valid_transitions, 0, sizeof(runstate_valid_transitions));
<1> static int decode_i2_frame(FourXContext *f, const uint8_t *buf, int length){\n<17> for(x=0; x<width; x+=16){\n<21> memset(color, 0, sizeof(color));\n<31> if(color[0]&0x8000) av_log(NULL, AV_LOG_ERROR, "unk bit 1\n");\n<33> if(color[1]&0x8000) av_log(NULL, AV_LOG_ERROR, "unk bit 2\n");\n<37> color[2]= mix(color[0], color[1]);\n<39> color[3]= mix(color[1], color[0]);\n<51> dst[y2*stride+x2]= color[(bits>>index)&3];
<1> static void create_watching_parent ( void ) {\n<13> memset ( oldact , 0 , sizeof ( oldact ) ) ;\n<38> if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) {\n<42> if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) {\n<60> if ( WIFSIGNALED ( status ) ) {\n<61> fprintf ( stderr , "%s%s\n" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( " (core dumped)" ) : "" ) ;\n<71> if ( caught_signal && child != ( pid_t ) - 1 ) {\n<72> fprintf ( stderr , _ ( "\nSession terminated, killing shell..." ) ) ;\n<77> if ( child != ( pid_t ) - 1 ) {\n<80> fprintf ( stderr , _ ( " ...killed.\n" ) ) ;\n<83> case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ;\n<85> case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ;\n<87> case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ;
<1> static inline int op(uint8_t **dst, const uint8_t *dst_end,\n<15> int striplen = FFMIN(count, remaining);\n<19> striplen = FFMIN(striplen, buf_end - *buf);\n<21> if (*buf >= buf_end)\n<25> memcpy(*dst, *buf, striplen);\n<27> *buf += striplen;\n<29> } else if (pixel >= 0)\n<31> memset(*dst, pixel, striplen);\n<33> *dst      += striplen;\n<35> remaining -= striplen;\n<37> count     -= striplen;\n<49> if (*dst >= dst_end) goto exhausted;\n<53> if (*dst <= dst_end) goto exhausted;
<1> static int msf_probe(AVProbeData *p)\n<3> if (memcmp(p->buf, "MSF", 3))\n<4> return 0;\n<5> if (AV_RB32(p->buf+8) <= 0)\n<7> if (AV_RB32(p->buf+16) <= 0)
<1> char * evhttp_htmlescape ( const char * html ) {\n<2> int i , new_size = 0 , old_size = strlen ( html ) ;\n<6> i < old_size ;\n<7> ++ i ) new_size += strlen ( html_replace ( html [ i ] , scratch_space ) ) ;\n<8> p = escaped_html = malloc ( new_size + 1 ) ;\n<9> if ( escaped_html == NULL ) event_err ( 1 , "%s: malloc(%d)" , __func__ , new_size + 1 ) ;\n<11> i < old_size ;\n<13> const char * replaced = html_replace ( html [ i ] , scratch_space ) ;\n<14> strcpy ( p , replaced ) ;\n<15> p += strlen ( replaced ) ;
<1> static int OpenEncoder ( vlc_object_t * p_this ) {\n<10> if ( ! p_enc -> fmt_in . video . i_frame_rate || ! p_enc -> fmt_in . video . i_frame_rate_base || ! p_enc -> fmt_in . video . i_visible_height || ! p_enc -> fmt_in . video . i_visible_width ) {\n<14> if ( ( p_sys = calloc ( 1 , sizeof ( * p_sys ) ) ) == NULL ) return VLC_ENOMEM ;\n<15> p_enc -> p_sys = p_sys ;\n<16> p_enc -> pf_encode_video = Encode ;\n<17> p_enc -> fmt_out . i_codec = VLC_CODEC_DIRAC ;\n<18> p_enc -> fmt_out . i_cat = VIDEO_ES ;\n<19> if ( ( p_sys -> p_dts_fifo = block_FifoNew ( ) ) == NULL ) {\n<41> if ( ! p_sys -> p_schro ) {\n<45> schro_encoder_set_packet_assembly ( p_sys -> p_schro , true ) ;\n<46> if ( ! ( p_sys -> p_format = schro_encoder_get_video_format ( p_sys -> p_schro ) ) ) {\n<48> schro_encoder_free ( p_sys -> p_schro ) ;\n<51> schro_video_format_set_std_video_format ( p_sys -> p_format , guessed_video_fmt ) ;\n<62> if ( ! psz_tmp ) goto error ;\n<65> if ( ! strcmp ( psz_tmp , "420" ) ) {\n<66> i_codec = VLC_CODEC_I420 ;\n<68> else if ( ! strcmp ( psz_tmp , "422" ) ) {\n<69> i_codec = VLC_CODEC_I422 ;\n<71> else if ( ! strcmp ( psz_tmp , "444" ) ) {\n<72> i_codec = VLC_CODEC_I444 ;\n<75> msg_Err ( p_enc , "Invalid chroma format: %s" , psz_tmp ) ;\n<76> free ( psz_tmp ) ;\n<79> SetEncChromaFormat ( p_enc , i_codec ) ;\n<81> free ( psz_tmp ) ;\n<82> SCHRO_SET_FLOAT ( ENC_QUALITY , "quality" ) SCHRO_SET_FLOAT ( ENC_NOISE_THRESHOLD , "noise_threshold" ) i_tmp = var_GetInteger ( p_enc , ENC_CFG_PREFIX ENC_BITRATE ) ;\n<83> if ( i_tmp > - 1 ) schro_encoder_setting_set_double ( p_sys -> p_schro , "bitrate" , i_tmp * 1000 ) ;\n<84> else schro_encoder_setting_set_double ( p_sys -> p_schro , "bitrate" , p_enc -> fmt_out . i_bitrate ) ;\n<85> p_enc -> fmt_out . i_bitrate = schro_encoder_setting_get_double ( p_sys -> p_schro , "bitrate" ) ;\n<87> if ( i_tmp > - 1 ) schro_encoder_setting_set_double ( p_sys -> p_schro , "min_bitrate" , i_tmp * 1000 ) ;\n<89> if ( i_tmp > - 1 ) schro_encoder_setting_set_double ( p_sys -> p_schro , "max_bitrate" , i_tmp * 1000 ) ;\n<90> SCHRO_SET_INTEGER ( ENC_AU_DISTANCE , "au_distance" , - 1 ) SCHRO_SET_ENUM ( enc_filtering_list , ENC_PREFILTER , ENC_PREFILTER_TEXT , "filtering" ) SCHRO_SET_FLOAT ( ENC_PREFILTER_STRENGTH , "filter_value" ) psz_tmp = var_GetString ( p_enc , ENC_CFG_PREFIX ENC_CODINGMODE ) ;\n<91> if ( ! psz_tmp ) goto error ;\n<92> else if ( ! strcmp ( psz_tmp , "auto" ) ) {\n<93> p_sys -> b_auto_field_coding = true ;\n<95> else if ( ! strcmp ( psz_tmp , "progressive" ) ) {\n<96> p_sys -> b_auto_field_coding = false ;\n<97> schro_encoder_setting_set_double ( p_sys -> p_schro , "interlaced_coding" , false ) ;\n<99> else if ( ! strcmp ( psz_tmp , "field" ) ) {\n<100> p_sys -> b_auto_field_coding = false ;\n<101> schro_encoder_setting_set_double ( p_sys -> p_schro , "interlaced_coding" , true ) ;\n<104> msg_Err ( p_enc , "Invalid codingmode: %s" , psz_tmp ) ;\n<105> free ( psz_tmp ) ;\n<108> free ( psz_tmp ) ;\n<109> SCHRO_SET_ENUM ( enc_block_size_list , ENC_MCBLK_SIZE , ENC_MCBLK_SIZE_TEXT , "motion_block_size" ) SCHRO_SET_ENUM ( enc_block_overlap_list , ENC_MCBLK_OVERLAP , ENC_MCBLK_OVERLAP_TEXT , "motion_block_overlap" ) psz_tmp = var_GetString ( p_enc , ENC_CFG_PREFIX ENC_MVPREC ) ;\n<110> if ( ! psz_tmp ) goto error ;\n<111> else if ( * psz_tmp != '\0' ) {\n<112> if ( ! strcmp ( psz_tmp , "1" ) ) {\n<113> schro_encoder_setting_set_double ( p_sys -> p_schro , "mv_precision" , 0 ) ;\n<115> else if ( ! strcmp ( psz_tmp , "1/2" ) ) {\n<116> schro_encoder_setting_set_double ( p_sys -> p_schro , "mv_precision" , 1 ) ;\n<118> else if ( ! strcmp ( psz_tmp , "1/4" ) ) {\n<119> schro_encoder_setting_set_double ( p_sys -> p_schro , "mv_precision" , 2 ) ;\n<121> else if ( ! strcmp ( psz_tmp , "1/8" ) ) {\n<122> schro_encoder_setting_set_double ( p_sys -> p_schro , "mv_precision" , 3 ) ;\n<125> msg_Err ( p_enc , "Invalid mv_precision: %s" , psz_tmp ) ;\n<126> free ( psz_tmp ) ;\n<130> free ( psz_tmp ) ;\n<131> SCHRO_SET_INTEGER ( ENC_ME_COMBINED , "enable_chroma_me" , - 1 ) SCHRO_SET_ENUM ( enc_wavelet_list , ENC_DWTINTRA , ENC_DWTINTRA_TEXT , "intra_wavelet" ) SCHRO_SET_ENUM ( enc_wavelet_list , ENC_DWTINTER , ENC_DWTINTER_TEXT , "inter_wavelet" ) SCHRO_SET_INTEGER ( ENC_DWTDEPTH , "transform_depth" , - 1 ) SCHRO_SET_INTEGER ( ENC_MULTIQUANT , "enable_multiquant" , - 1 ) SCHRO_SET_INTEGER ( ENC_NOAC , "enable_noarith" , - 1 ) SCHRO_SET_ENUM ( enc_perceptual_weighting_list , ENC_PWT , ENC_PWT_TEXT , "perceptual_weighting" ) SCHRO_SET_FLOAT ( ENC_PDIST , "perceptual_distance" ) SCHRO_SET_INTEGER ( ENC_HSLICES , "horiz_slices" , - 1 ) SCHRO_SET_INTEGER ( ENC_VSLICES , "vert_slices" , - 1 ) SCHRO_SET_ENUM ( enc_codeblock_size_list , ENC_SCBLK_SIZE , ENC_SCBLK_SIZE_TEXT , "codeblock_size" ) SCHRO_SET_INTEGER ( ENC_ME_HIERARCHICAL , "enable_hierarchical_estimation" , - 1 ) SCHRO_SET_INTEGER ( ENC_ME_DOWNSAMPLE_LEVELS , "downsample_levels" , 1 ) SCHRO_SET_INTEGER ( ENC_ME_GLOBAL_MOTION , "enable_global_motion" , - 1 ) SCHRO_SET_INTEGER ( ENC_ME_PHASECORR , "enable_phasecorr_estimation" , - 1 ) SCHRO_SET_INTEGER ( ENC_SCD , "enable_scene_change_detection" , - 1 ) SCHRO_SET_ENUM ( enc_profile_list , ENC_FORCE_PROFILE , ENC_FORCE_PROFILE_TEXT , "force_profile" ) p_sys -> started = 0 ;\n<132> return VLC_SUCCESS ;\n<133> error : CloseEncoder ( p_this ) ;\n<134> return VLC_EGENERIC ;
<1> static void check_new_cluster_is_empty ( void ) {\n<9> relnum < rel_arr -> nrels ;\n<11> if ( strcmp ( rel_arr -> rels [ relnum ] . nspname , "pg_catalog" ) != 0 ) pg_fatal ( "New cluster database \"%s\" is not empty\n" , new_cluster . dbarr . dbs [ dbnum ] . db_name ) ;
<1> static inline int64_t get_sector_offset(BlockDriverState *bs,\n<7> BDRVVPCState *s = bs->opaque;\n<45> if (write && (s->last_bitmap_offset != bitmap_offset)) {\n<47> uint8_t bitmap[s->bitmap_size];\n<53> memset(bitmap, 0xff, s->bitmap_size);\n<55> bdrv_pwrite(bs->file, bitmap_offset, bitmap, s->bitmap_size);
<1> static inline int64_t get_image_offset(BlockDriverState *bs, uint64_t offset,\n<7> BDRVVPCState *s = bs->opaque;\n<43> if (write && (s->last_bitmap_offset != bitmap_offset)) {\n<45> uint8_t bitmap[s->bitmap_size];\n<51> memset(bitmap, 0xff, s->bitmap_size);\n<53> bdrv_pwrite_sync(bs->file, bitmap_offset, bitmap, s->bitmap_size);
<1> static int write_VD ( struct archive_write * a , struct vdd * vdd ) {\n<34> set_unused_field_bp ( bp , 73 , 80 ) ;\n<36> if ( vdd -> vdd_type == VDD_JOLIET ) {\n<37> bp [ 89 ] = 0x25 ;\n<38> bp [ 90 ] = 0x2F ;\n<39> bp [ 91 ] = 0x45 ;\n<40> memset ( bp + 92 , 0 , 120 - 92 + 1 ) ;\n<66> r = set_file_identifier ( bp , 777 , 813 , vdc , a , vdd , & ( iso9660 -> bibliographic_file_identifier ) , "Bibliongraphic File" , 0 , D_CHAR ) ;\n<67> if ( r != ARCHIVE_OK ) return ( r ) ;\n<72> bp [ 882 ] = fst_ver ;\n<73> bp [ 883 ] = 0 ;\n<74> memset ( bp + 884 , 0x20 , 1395 - 884 + 1 ) ;
<1> static AVFilterContext *create_filter_with_args(const char *filt, void *opaque)\n<4> char *filter = av_strdup(filt); /* copy - don't mangle the input string */\n<7> if((args = strchr(filter, '='))) {\n<9> if(args == filter)\n<13> av_log(NULL, AV_LOG_INFO, "creating filter \"%s\" with args \"%s\"\n",\n<14> name, args ? args : "(none)");\n<15> if((ret = avfilter_create_by_name(name, NULL))) {\n<16> if(avfilter_init_filter(ret, args, opaque)) {
<1> static void network_init ( PCIBus * pci_bus ) {\n<4> i < nb_nics ;\n<6> NICInfo * nd = & nd_table [ i ] ;\n<8> if ( i == 0 && ( ! nd -> model || strcmp ( nd -> model , "pcnet" ) == 0 ) ) default_devaddr = "0b" ;\n<9> pci_nic_init_nofail ( nd , pci_bus , "pcnet" , default_devaddr ) ;
<1> static int vfio_ccw_handle_request(ORB *orb, SCSW *scsw, void *data)\n<9> struct ccw_io_region *region = vcdev->io_region;\n<23> memset(region, 0, sizeof(*region));\n<27> memcpy(region->orb_area, orb, sizeof(ORB));\n<29> memcpy(region->scsw_area, scsw, sizeof(SCSW));
<1> static void modify_environment ( const struct passwd * pw , const char * shell ) {\n<2> if ( simulate_login ) {\n<3> char * term = getenv ( "TERM" ) ;\n<4> if ( term ) term = xstrdup ( term ) ;\n<5> environ = xmalloc ( ( 6 + ! ! term ) * sizeof ( char * ) ) ;\n<7> if ( term ) {\n<8> xsetenv ( "TERM" , term , 1 ) ;\n<9> free ( term ) ;
<1> static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n<31> if (!xhci->slots[slotid-1].enabled) {\n<33> fprintf(stderr, "xhci: xhci_kick_ep for disabled slot %d\n", slotid);\n<39> epctx = xhci->slots[slotid-1].eps[epid-1];\n<41> if (!epctx) {\n<43> fprintf(stderr, "xhci: xhci_kick_ep for disabled endpoint %d,%d\n",\n<225> if (xhci_fire_ctl_transfer(xhci, xfer) >= 0) {\n<233> fprintf(stderr, "xhci: error firing CTL transfer\n");\n<247> if (!xfer->iso_xfer) {\n<249> fprintf(stderr, "xhci: error firing data transfer\n");
<1> static void realview_init(ram_addr_t ram_size,\n<35> if (!cpu_model)\n<37> cpu_model = "arm926";\n<41> if (strcmp(cpu_model, "arm11mpcore") == 0) {\n<43> ncpu = 4;\n<47> ncpu = 1;\n<55> env = cpu_init(cpu_model);\n<57> if (!env) {\n<59> fprintf(stderr, "Unable to find CPU definition\n");\n<189> for(n = 0; n < nb_nics; n++) {\n<191> nd = &nd_table[n];\n<195> if ((!nd->model && !done_smc) || strcmp(nd->model, "smc91c111") == 0) {\n<197> smc91c111_init(nd, 0x4e000000, pic[28]);\n<199> done_smc = 1;\n<203> pci_nic_init(nd, "rtl8139", NULL);
<1> static int32_t sumUpStates ( UCMStates * states ) {\n<53> if ( ! allStatesReady ) {\n<54> fprintf ( stderr , "ucm error: the state table contains loops\n" ) ;
<1> static char * unescape_word ( struct Curl_easy * data , const char * inputbuff ) {\n<8> CURLcode result = Curl_urldecode ( data , inputbuff , 0 , & newp , & len , FALSE ) ;\n<9> if ( ! newp || result ) return NULL ;\n<10> dictp = malloc ( ( ( size_t ) len ) * 2 + 1 ) ;\n<22> free ( newp ) ;\n<23> return dictp ;
<1> static int selinux_getprocattr ( struct task_struct * p , char * name , char * * value ) {\n<6> if ( current != p ) {\n<8> if ( error ) return error ;\n<12> if ( ! strcmp ( name , "current" ) ) sid = __tsec -> sid ;\n<13> else if ( ! strcmp ( name , "prev" ) ) sid = __tsec -> osid ;\n<14> else if ( ! strcmp ( name , "exec" ) ) sid = __tsec -> exec_sid ;\n<15> else if ( ! strcmp ( name , "fscreate" ) ) sid = __tsec -> create_sid ;\n<16> else if ( ! strcmp ( name , "keycreate" ) ) sid = __tsec -> keycreate_sid ;\n<17> else if ( ! strcmp ( name , "sockcreate" ) ) sid = __tsec -> sockcreate_sid ;\n<19> rcu_read_unlock ( ) ;\n<20> if ( ! sid ) return 0 ;\n<24> invalid : rcu_read_unlock ( ) ;\n<25> return - EINVAL ;
<1> int av_image_fill_black(uint8_t *dst_data[4], const ptrdiff_t dst_linesize[4],\n<43> ptrdiff_t bytewidth = av_image_get_linesize(pix_fmt, width, 0);\n<49> int fill = pix_fmt == AV_PIX_FMT_MONOWHITE ? 0xFF : 0;\n<51> if (nb_planes != 1 || !(rgb || mono) || bytewidth < 1)\n<63> data = dst_data[0];\n<69> for (;height > 0; height--) {\n<71> memset(data, fill, bytewidth);\n<73> data += dst_linesize[0];
<1> kadm5_ret_t kadm5_delete_policy ( void * server_handle , kadm5_policy_t name ) {\n<7> if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n<8> if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n<9> ret = krb5_db_get_policy ( handle -> context , name , & entry ) ;\n<10> if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;
<1> static void init_scan_tables ( H264Context * h ) {\n<7> h -> field_scan [ i ] = T ( field_scan [ i ] ) ;\n<13> h -> zigzag_scan8x8_cavlc [ i ] = T ( zigzag_scan8x8_cavlc [ i ] ) ;\n<14> h -> field_scan8x8 [ i ] = T ( field_scan8x8 [ i ] ) ;\n<15> h -> field_scan8x8_cavlc [ i ] = T ( field_scan8x8_cavlc [ i ] ) ;\n<17> if ( h -> sps . transform_bypass ) {\n<18> memcpy ( h -> zigzag_scan_q0 , zigzag_scan , sizeof ( h -> zigzag_scan_q0 ) ) ;\n<19> memcpy ( h -> zigzag_scan8x8_q0 , ff_zigzag_direct , sizeof ( h -> zigzag_scan8x8_q0 ) ) ;\n<20> memcpy ( h -> zigzag_scan8x8_cavlc_q0 , zigzag_scan8x8_cavlc , sizeof ( h -> zigzag_scan8x8_cavlc_q0 ) ) ;\n<21> memcpy ( h -> field_scan_q0 , field_scan , sizeof ( h -> field_scan_q0 ) ) ;\n<22> memcpy ( h -> field_scan8x8_q0 , field_scan8x8 , sizeof ( h -> field_scan8x8_q0 ) ) ;\n<23> memcpy ( h -> field_scan8x8_cavlc_q0 , field_scan8x8_cavlc , sizeof ( h -> field_scan8x8_cavlc_q0 ) ) ;\n<26> memcpy ( h -> zigzag_scan_q0 , h -> zigzag_scan , sizeof ( h -> zigzag_scan_q0 ) ) ;\n<27> memcpy ( h -> zigzag_scan8x8_q0 , h -> zigzag_scan8x8 , sizeof ( h -> zigzag_scan8x8_q0 ) ) ;\n<28> memcpy ( h -> zigzag_scan8x8_cavlc_q0 , h -> zigzag_scan8x8_cavlc , sizeof ( h -> zigzag_scan8x8_cavlc_q0 ) ) ;\n<29> memcpy ( h -> field_scan_q0 , h -> field_scan , sizeof ( h -> field_scan_q0 ) ) ;\n<30> memcpy ( h -> field_scan8x8_q0 , h -> field_scan8x8 , sizeof ( h -> field_scan8x8_q0 ) ) ;\n<31> memcpy ( h -> field_scan8x8_cavlc_q0 , h -> field_scan8x8_cavlc , sizeof ( h -> field_scan8x8_cavlc_q0 ) ) ;
<1> static void destroy_int_fifo ( int_fifo * fifo ) {\n<3> if ( fifo != NULL ) {\n<5> UNLINK_FIFO ( i_n , * fifo , link ) ;\n<6> if ( i_n != NULL ) free ( i_n ) ;\n<8> while ( i_n != NULL ) ;\n<9> free ( fifo ) ;
<1> static void test_bug16143 ( ) {\n<5> DIE_UNLESS ( strcmp ( mysql_stmt_sqlstate ( stmt ) , "00000" ) == 0 ) ;
<1> picture_t * DecodeVideo ( decoder_t * p_dec , block_t * * pp_block ) {\n<66> p_sys -> b_flush = ( p_block -> i_flags & BLOCK_FLAG_END_OF_SEQUENCE ) != 0 ;\n<68> if ( ! p_block ) return NULL ;\n<69> p_block -> i_buffer -= FF_INPUT_BUFFER_PADDING_SIZE ;\n<71> memset ( p_block -> p_buffer + p_block -> i_buffer , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;
<13> static const void * hb_graphite2_get_table ( const void * data , unsigned int tag , size_t * len ) {\n<23> if ( unlikely ( ! blob ) ) {\n<25> hb_graphite2_tablelist_t * p = ( hb_graphite2_tablelist_t * ) calloc ( 1 , sizeof ( hb_graphite2_tablelist_t ) ) ;\n<26> if ( unlikely ( ! p ) ) {\n<40> hb_graphite2_shaper_face_data_t * _hb_graphite2_shaper_face_data_create ( hb_face_t * face ) {\n<49> data -> face = face ;\n<50> data -> grface = gr_make_face ( data , & hb_graphite2_get_table , gr_face_preloadAll ) ;\n<51> if ( unlikely ( ! data -> grface ) ) {\n<52> free ( data ) ;
<1> static void pc_init1(MachineState *machine)\n<125> if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n<129> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> static int transform_hook_handler ( TSCont contp , TSEvent event , void * edata ) {\n<71> case TS_EVENT_IMMEDIATE : case TS_EVENT_TIMEOUT : switch ( data -> req_no ) {\n<99> case 4 : if ( data -> browser4 -> status == REQUEST_INPROGRESS ) {\n<113> if ( ( strstr ( data -> browser1 -> response , TRANSFORM_APPEND_STRING ) != nullptr ) && ( strstr ( data -> browser3 -> response , TRANSFORM_APPEND_STRING ) == nullptr ) ) {\n<114> SDK_RPRINT ( data -> test , "TSHttpTxnUntransformedResponseCache" , "TestCase1" , TC_PASS , "ok" ) ;\n<115> data -> test_passed_txn_untransformed_resp_cache = true ;\n<118> SDK_RPRINT ( data -> test , "TSHttpTxnUntransformedResponseCache" , "TestCase1" , TC_FAIL , "Value's Mismatch" ) ;\n<120> if ( ( strstr ( data -> browser2 -> response , TRANSFORM_APPEND_STRING ) != nullptr ) && ( strstr ( data -> browser4 -> response , TRANSFORM_APPEND_STRING ) != nullptr ) ) {\n<121> SDK_RPRINT ( data -> test , "TSHttpTxnTransformedResponseCache" , "TestCase1" , TC_PASS , "ok" ) ;\n<122> data -> test_passed_txn_transformed_resp_cache = true ;\n<125> SDK_RPRINT ( data -> test , "TSHttpTxnTransformedResponseCache" , "TestCase1" , TC_FAIL , "Value's Mismatch" ) ;\n<160> synclient_txn_delete ( data -> browser1 ) ;\n<161> synclient_txn_delete ( data -> browser2 ) ;\n<162> synclient_txn_delete ( data -> browser3 ) ;\n<163> synclient_txn_delete ( data -> browser4 ) ;\n<164> TSContDataSet ( contp , nullptr ) ;
<1> static sd_rsp_type_t sd_normal_command(SDState *sd,\n<2> SDRequest req)\n<8> DPRINTF("CMD%d 0x%08x state %d\n", req.cmd, req.arg, sd->state);\n<9> switch (req.cmd) {\n<22> if (!sd->spi)\n<27> if (sd->spi)\n<29> switch (sd->state) {\n<38> if (sd->spi)\n<40> switch (sd->state) {\n<51> if (sd->spi)\n<62> if (sd->spi)\n<64> switch (sd->mode) {\n<76> if (sd->spi)\n<78> switch (sd->state) {\n<85> if (sd->rca == rca)\n<94> if (sd->rca == rca)\n<104> switch (sd->state) {\n<118> switch (sd->state) {\n<123> if (!sd->spi)\n<126> memcpy(sd->data, sd->csd, 16);\n<135> switch (sd->state) {\n<140> if (!sd->spi)\n<143> memcpy(sd->data, sd->cid, 16);\n<152> if (sd->spi)\n<166> switch (sd->state) {\n<180> switch (sd->mode) {\n<182> if (sd->rca != rca)\n<189> if (sd->spi)\n<201> switch (sd->state) {\n<213> switch (sd->state) {\n<226> switch (sd->state) {\n<240> if (sd->spi)\n<242> switch (sd->state) {\n<245> if (sd->spi)\n<263> if (sd->spi)\n<265> switch (sd->state) {\n<268> if (sd->spi)\n<286> if (sd->spi)\n<288> switch (sd->state) {\n<299> if (sd->spi)\n<301> switch (sd->state) {\n<313> switch (sd->state) {\n<330> switch (sd->state) {\n<347> switch (sd->state) {\n<360> switch (sd->state) {\n<369> switch (sd->state) {\n<378> switch (sd->state) {\n<395> if (sd->spi)\n<397> switch (sd->state) {\n<413> fprintf(stderr, "SD: GEN_CMD 0x%08x\n", req.arg);\n<414> switch (sd->state) {\n<417> if (req.arg & 1)\n<428> fprintf(stderr, "SD: Unknown CMD%i\n", req.cmd);\n<431> fprintf(stderr, "SD: CMD%i not implemented in SPI mode\n", req.cmd);\n<433> fprintf(stderr, "SD: CMD%i in a wrong state\n", req.cmd);
<3> if ( ! TRC ) return NULL ;\n<4> gamma_table = malloc ( sizeof ( float ) * 256 ) ;\n<7> compute_curve_gamma_table_type_parametric ( gamma_table , TRC -> parameter , TRC -> count ) ;\n<11> compute_curve_gamma_table_type0 ( gamma_table ) ;\n<14> compute_curve_gamma_table_type1 ( gamma_table , TRC -> data [ 0 ] ) ;\n<17> compute_curve_gamma_table_type2 ( gamma_table , TRC -> data , TRC -> count ) ;\n<21> validate_gamma_table ( gamma_table ) ;
<1> static void ppc_prep_init(QEMUMachineInitArgs *args)\n<83> if (cpu == NULL) {\n<85> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<197> if (ppc_boot_device == '\0') {\n<199> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<237> if (pci_bus == NULL) {\n<239> fprintf(stderr, "Couldn't create PCI host controller.\n");\n<315> for(i = 0; i < nb_nics1; i++) {\n<317> if (nd_table[i].model == NULL) {\n<319> nd_table[i].model = g_strdup("ne2k_isa");\n<323> if (strcmp(nd_table[i].model, "ne2k_isa") == 0) {\n<325> isa_ne2000_init(isa_bus, ne2000_io[i], ne2000_irq[i],\n<327> &nd_table[i]);\n<331> pci_nic_init_nofail(&nd_table[i], pci_bus, "ne2k_pci", NULL);
<1> int sort_write_record ( MI_SORT_PARAM * sort_param ) {\n<63> if ( ( param -> testflag & T_WRITE_LOOP ) && ( info -> state -> records % WRITE_COUNT ) == 0 ) {\n<65> printf ( "%s\r" , llstr ( info -> state -> records , llbuff ) ) ;
<30> if(pps == NULL)\n<130> if(pps->ref_count[0]-1 > 32-1 || pps->ref_count[1]-1 > 32-1){\n<162> memcpy(pps->scaling_matrix4, h->sps_buffers[pps->sps_id]->scaling_matrix4, sizeof(pps->scaling_matrix4));\n<164> memcpy(pps->scaling_matrix8, h->sps_buffers[pps->sps_id]->scaling_matrix8, sizeof(pps->scaling_matrix8));\n<176> decode_scaling_matrices(h, h->sps_buffers[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8);\n<188> build_qp_table(pps, 0, pps->chroma_qp_index_offset[0], h->sps.bit_depth_luma);\n<190> build_qp_table(pps, 1, pps->chroma_qp_index_offset[1], h->sps.bit_depth_luma);\n<230> h->pps_buffers[pps_id]= pps;
<1> static int ohci_service_td(OHCIState *ohci, struct ohci_ed *ed)\n<51> if (!ohci_read_td(ohci, addr, &td)) {\n<53> fprintf(stderr, "usb-ohci: TD read error at %x\n", addr);\n<83> switch (dir) {\n<123> fprintf(stderr, "usb-ohci: Bad direction\n");\n<325> if (ret >= 0) {\n<333> switch (ret) {\n<363> fprintf(stderr, "usb-ohci: Bad device response %d\n", ret);
<1> static int qemu_gluster_create(const char *filename,\n<33> while (options && options->name) {\n<35> if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n<37> total_size = options->value.n / BDRV_SECTOR_SIZE;\n<39> } else if (!strcmp(options->name, BLOCK_OPT_PREALLOC)) {\n<41> if (!options->value.s || !strcmp(options->value.s, "off")) {\n<43> prealloc = 0;\n<45> } else if (!strcmp(options->value.s, "full") &&\n<47> gluster_supports_zerofill()) {\n<49> prealloc = 1;\n<53> error_setg(errp, "Invalid preallocation mode: '%s'"\n<57> options->value.s);\n<59> ret = -EINVAL;\n<67> options++;
<1> static int xvid_strip_vol_header(AVCodecContext *avctx, AVPacket *pkt,\n<15> if (pkt->data[i]     == 0x00 &&\n<17> pkt->data[i + 1] == 0x00 &&\n<19> pkt->data[i + 2] == 0x01 &&\n<21> pkt->data[i + 3] == 0xB6) {\n<33> if (vo_len > 0) {\n<37> if (!avctx->extradata) {\n<39> avctx->extradata = av_malloc(vo_len);\n<43> memcpy(avctx->extradata, pkt->data, vo_len);\n<45> avctx->extradata_size = vo_len;\n<53> memmove(pkt->data, &pkt->data[vo_len], frame_len - vo_len);
<1> void aes_setkey_dec ( aes_context * ctx , const unsigned char * key , int keysize ) {\n<6> switch ( keysize ) {\n<18> SK = cty . rk + cty . nr * 4 ;\n<36> memset ( & cty , 0 , sizeof ( aes_context ) ) ;
<1> static afs_int32 put_prentries ( struct prentry * tentry , prentries * bulkentries ) {\n<3> if ( bulkentries -> prentries_val == 0 ) {\n<5> bulkentries -> prentries_val = ( struct prlistentries * ) malloc ( PR_MAXENTRIES * sizeof ( struct prentry ) ) ;\n<10> if ( bulkentries -> prentries_len >= PR_MAXENTRIES ) {\n<14> entry += bulkentries -> prentries_len ;\n<25> strncpy ( entry -> name , tentry -> name , PR_MAXNAMELEN ) ;\n<26> memset ( entry -> reserved , 0 , sizeof ( entry -> reserved ) ) ;
<1> void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)\n<9> static char line[1024], prev[1024];\n<15> if(level>av_log_level)\n<19> line[0]=0;\n<23> if(print_prefix && avc) {\n<31> snprintf(line, sizeof(line), "[%s @ %p] ", (*parent)->item_name(parent), parent);\n<37> snprintf(line + strlen(line), sizeof(line) - strlen(line), "[%s @ %p] ", avc->item_name(ptr), ptr);\n<43> vsnprintf(line + strlen(line), sizeof(line) - strlen(line), fmt, vl);\n<47> print_prefix= line[strlen(line)-1] == '\n';\n<59> if(print_prefix && (flags & AV_LOG_SKIP_REPEATED) && !strcmp(line, prev)){\n<61> count++;\n<63> if(is_atty==1)\n<65> fprintf(stderr, "    Last message repeated %d times\r", count);\n<71> if(count>0){\n<73> fprintf(stderr, "    Last message repeated %d times\n", count);\n<79> colored_fputs(av_clip(level>>3, 0, 6), line);\n<81> strcpy(prev, line);
<1> static int save_subtitle_set(AVCodecContext *avctx, AVSubtitle *sub, int *got_output)\n<117> if (!region)\n<161> clut_table = clut->clut4;\n<167> clut_table = clut->clut256;\n<175> clut_table = clut->clut16;\n<185> if (!rect->data[1]) {\n<193> memcpy(rect->data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n<197> rect->data[0] = av_malloc(region->buf_size);\n<199> if (!rect->data[0]) {\n<209> memcpy(rect->data[0], region->pbuf, region->buf_size);\n<263> av_freep(&rect->data[0]);\n<265> av_freep(&rect->data[1]);
<1> static int onenand_initfn(SysBusDevice *sbd)\n<33> if (!s->blk) {\n<35> s->image = memset(g_malloc(size + (size >> 5)),\n<37> 0xff, size + (size >> 5));\n<41> if (blk_is_read_only(s->blk)) {\n<53> s->otp = memset(g_malloc((64 + 2) << PAGE_SHIFT),\n<55> 0xff, (64 + 2) << PAGE_SHIFT);\n<57> memory_region_init_ram(&s->ram, OBJECT(s), "onenand.ram",\n<77> onenand_mem_setup(s);
<1> static void filter_channel ( MLPDecodeContext * m , unsigned int substr , unsigned int channel ) {\n<5> int32_t * firbuf = state_buffer [ FIR ] + MAX_BLOCKSIZE ;\n<6> int32_t * iirbuf = state_buffer [ IIR ] + MAX_BLOCKSIZE ;\n<7> FilterParams * fir = & s -> channel_params [ channel ] . filter_params [ FIR ] ;\n<8> FilterParams * iir = & s -> channel_params [ channel ] . filter_params [ IIR ] ;\n<11> memcpy ( firbuf , fir -> state , MAX_FIR_ORDER * sizeof ( int32_t ) ) ;\n<12> memcpy ( iirbuf , iir -> state , MAX_IIR_ORDER * sizeof ( int32_t ) ) ;\n<13> m -> dsp . mlp_filter_channel ( firbuf , fircoeff , fir -> order , iir -> order , filter_shift , mask , s -> blocksize , & m -> sample_buffer [ s -> blockpos ] [ channel ] ) ;\n<14> memcpy ( fir -> state , firbuf - s -> blocksize , MAX_FIR_ORDER * sizeof ( int32_t ) ) ;\n<15> memcpy ( iir -> state , iirbuf - s -> blocksize , MAX_IIR_ORDER * sizeof ( int32_t ) ) ;
<1> static void mps2_common_init(MachineState *machine)\n<7> MPS2MachineClass *mmc = MPS2_MACHINE_GET_CLASS(machine);\n<15> if (!machine->cpu_model) {\n<17> machine->cpu_model = mmc->cpu_model;\n<23> if (strcmp(machine->cpu_model, mmc->cpu_model) != 0) {\n<25> error_report("This board can only be used with CPU %s", mmc->cpu_model);\n<27> exit(1);\n<173> qdev_prop_set_string(armv7m, "cpu-model", machine->cpu_model);
<9> int ret = av_new_packet ( pkt , st -> codecpar -> block_align ) ;\n<10> if ( ret < 0 ) return ret ;\n<11> memcpy ( pkt -> data , ast -> pkt . data + st -> codecpar -> block_align * ( ast -> sub_packet_h * ast -> audio_framesize / st -> codecpar -> block_align - rm -> audio_pkt_cnt ) , st -> codecpar -> block_align ) ;
<1> static const char * create_index ( void ) {\n<15> tmpfile = write_idx_file ( NULL , idx , object_count , & pack_idx_opts , pack_data -> sha1 ) ;\n<16> free ( idx ) ;
<1> void *qemu_realloc(void *ptr, size_t size)\n<5> if (!size && !allow_zero_malloc()) {\n<11> return oom_check(realloc(ptr, size ? size : 1));
<1> static const unsigned char *seq_decode_op2(SeqVideoContext *seq, const unsigned char *src, unsigned char *dst)\n<9> for (i = 0; i < 8; i++) {\n<11> memcpy(dst, src, 8);\n<13> src += 8;\n<15> dst += seq->frame.linesize[0];
<1> static void test_bug12337762 ( ) {\n<22> while ( ( field = mysql_fetch_field ( result ) ) ) {\n<23> printf ( "field name %s\n" , field -> name ) ;\n<24> printf ( "field table %s\n" , field -> table ) ;
<1> static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,\n<11> while (**buf == '[') {\n<13> char *name = parse_link_name(buf, log_ctx);\n<19> if (!name)\n<53> *buf += strspn(*buf, WHITESPACES);
<1> static int convert_to_string ( const unsigned char * s , size_t len , char * dest ) {\n<4> * p ++ = '\"' ;\n<7> len -- , s ++ ) {\n<10> * p ++ = 'b' ;\n<13> * p ++ = 't' ;\n<16> * p ++ = 'v' ;\n<19> * p ++ = 'n' ;\n<22> * p ++ = 'f' ;\n<25> * p ++ = 'r' ;\n<28> * p ++ = '\"' ;\n<31> * p ++ = '\'' ;\n<34> * p ++ = '\\' ;\n<36> default : if ( ( * s < 0x20 || ( * s >= 0x7f && * s <= 0xa0 ) ) ) {\n<37> sprintf ( p , "\\x%02x" , * s ) ;\n<38> p += 4 ;\n<40> else * p ++ = * s ;
<1> void *postcopy_get_tmp_page(MigrationIncomingState *mis)\n<13> if (!mis->postcopy_tmp_page) {\n<15> error_report("%s: %s", __func__, strerror(errno));
<1> static void virtio_net_reset ( VirtIODevice * vdev ) {\n<2> VirtIONet * n = to_virtio_net ( vdev ) ;\n<13> memset ( n -> mac_table . macs , 0 , MAC_TABLE_ENTRIES * ETH_ALEN ) ;\n<14> memset ( n -> vlans , 0 , MAX_VLAN >> 3 ) ;
<1> VirtIODevice *virtio_net_init(DeviceState *dev, NICConf *conf,\n<39> qemu_macaddr_default_if_unset(&conf->macaddr);\n<41> memcpy(&n->mac[0], &conf->macaddr, sizeof(n->mac));
<109> if(inter && get_bits1(gb)){\n<124> memcpy(s->qr_size[inter][plane], s->qr_size[qtj][plj], sizeof(s->qr_size[0][0]));\n<126> memcpy(s->qr_base[inter][plane], s->qr_base[qtj][plj], sizeof(s->qr_base[0][0]));
<1> static int rm_write_header(AVFormatContext *s)\n<10> stream = &rm->streams[n];\n<11> memset(stream, 0, sizeof(StreamInfo));\n<17> rm->audio_stream = stream;\n<22> stream->total_frames = stream->nb_packets;
<1> static void sig_complete_word ( GList * * list , WINDOW_REC * window , const char * word , const char * linestart , int * want_space ) {\n<8> g_return_if_fail ( word != NULL ) ;\n<12> if ( server != NULL && server_ischannel ( server , word ) ) {\n<19> if ( * linestart == '\0' && * word == '\0' ) {\n<30> if ( channel == NULL && query != NULL && g_ascii_strncasecmp ( word , query -> name , strlen ( word ) ) == 0 ) {
<1> char * convert_http_hdr_to_string ( TSMBuffer bufp , TSMLoc hdr_loc ) {\n<17> output_string = ( char * ) TSmalloc ( total_avail + 1 ) ;\n<18> output_len = 0 ;\n<21> block_start = TSIOBufferBlockReadStart ( block , reader , & block_avail ) ;\n<22> if ( block_avail == 0 ) {\n<25> memcpy ( output_string + output_len , block_start , block_avail ) ;\n<26> output_len += block_avail ;\n<27> TSIOBufferReaderConsume ( reader , block_avail ) ;
<1> static void usage ( void ) {\n<7> printf ( "Usage: %s [OPTIONS] tables[.MYI]\n" , my_progname_short ) ;\n<8> printf ( "\nGlobal options:\n" ) ;
<1> static void setup_rt_frame_v1(int usig, struct target_sigaction *ka,\n<21> if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0))\n<45> memset(&stack, 0, sizeof(stack));\n<53> memcpy(&frame->uc.tuc_stack, &stack, sizeof(stack));
<1> static int oma_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> OMAContext *oc  = s->priv_data;\n<57> if (ret == packet_size)\n<65> memset(oc->iv, 0, 8);
<1> int evbuffer_add ( struct evbuffer * buf , const void * data , size_t datlen ) {\n<4> if ( buf -> totallen - used < datlen ) {\n<5> if ( evbuffer_expand ( buf , datlen ) == - 1 ) return ( - 1 ) ;\n<7> memcpy ( buf -> buffer + buf -> off , data , datlen ) ;\n<8> buf -> off += datlen ;\n<9> if ( datlen && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;
<1> static int vmdk_create_extent(const char *filename, int64_t filesize,\n<49> if (flat) {\n<65> memset(&header, 0, sizeof(header));\n<159> ret = bdrv_pwrite(bs, sizeof(magic), &header, sizeof(header));
<1> static int bochs_open(BlockDriverState *bs, int flags)\n<19> if (bdrv_pread(bs->file, 0, &bochs, sizeof(bochs)) != sizeof(bochs)) {\n<27> if (strcmp(bochs.magic, HEADER_MAGIC) ||\n<29> strcmp(bochs.type, REDOLOG_TYPE) ||\n<31> strcmp(bochs.subtype, GROWING_TYPE) ||\n<33> ((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n<37> return -EMEDIUMTYPE;\n<43> if (le32_to_cpu(bochs.version) == HEADER_V1) {\n<45> memcpy(&header_v1, &bochs, sizeof(bochs));\n<57> s->catalog_size = le32_to_cpu(bochs.extra.redolog.catalog);\n<59> s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n<61> if (bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n<63> s->catalog_size * 4) != s->catalog_size * 4)
<1> int qemuMonitorTextSendFileHandle ( qemuMonitorPtr mon , const char * fdname , int fd ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommandWithFd ( mon , cmd , fd , & reply ) < 0 ) {\n<13> if ( strstr ( reply , "unknown command:" ) ) {\n<14> qemuReportError ( VIR_ERR_OPERATION_INVALID , _ ( "qemu does not support sending of file handles: %s" ) , reply ) ;\n<17> if ( STRNEQ ( reply , "" ) ) {
<1> strong_alias ( _nss_nis_setaliasent , _nss_nis_endaliasent ) static enum nss_status internal_nis_getaliasent_r ( struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n<12> if ( new_start ) yperr = yp_first ( domain , "mail.aliases" , & outkey , & keylen , & result , & len ) ;\n<13> else yperr = yp_next ( domain , "mail.aliases" , oldkey , oldkeylen , & outkey , & keylen , & result , & len ) ;\n<19> if ( __builtin_expect ( ( size_t ) ( len + 1 ) > buflen , 0 ) ) {\n<20> free ( result ) ;\n<24> char * p = strncpy ( buffer , result , len ) ;\n<25> buffer [ len ] = '\0' ;\n<26> while ( isspace ( * p ) ) ++ p ;\n<27> free ( result ) ;\n<28> parse_res = _nss_nis_parse_aliasent ( outkey , p , alias , buffer , buflen , errnop ) ;\n<29> if ( __builtin_expect ( parse_res == - 1 , 0 ) ) {\n<30> free ( outkey ) ;\n<34> free ( oldkey ) ;\n<35> oldkey = outkey ;
<1> static void printarray ( struct pskeydict * dict ) {\n<3> printf ( "[" ) ;\n<5> i < dict -> cnt ;\n<7> switch ( dict -> entries [ i ] . type ) {\n<8> case ps_num : printf ( "%g" , ( double ) dict -> entries [ i ] . u . val ) ;\n<10> case ps_bool : printf ( "%s" , dict -> entries [ i ] . u . tf ? "true" : "false" ) ;\n<20> case ps_void : printf ( "-- void --" ) ;\n<22> default : printf ( "-- nostringval --" ) ;\n<25> printf ( " " ) ;\n<27> printf ( "]" ) ;
<1> int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic){\n<27> buf= &((InternalBuffer*)s->internal_buffer)[s->internal_buffer_count];\n<30> if(buf->base[0]){\n<35> int pixel_size, size[3];\n<59> memset(buf->base, 0, sizeof(buf->base));\n<60> memset(buf->data, 0, sizeof(buf->data));\n<61> for(i=0; i<3 && size[i]; i++){\n<66> if(buf->base[i]==NULL) return -1;\n<67> memset(buf->base[i], 128, size[i]);\n<70> buf->data[i] = buf->base[i];\n<72> buf->data[i] = buf->base[i] + ALIGN((buf->linesize[i]*EDGE_WIDTH>>v_shift) + (EDGE_WIDTH>>h_shift), STRIDE_ALIGN);\n<78> pic->base[i]= buf->base[i];
<1> static int qemuAgentCommand ( qemuAgentPtr mon , virJSONValuePtr cmd , virJSONValuePtr * reply , bool needReply , int seconds ) {\n<11> if ( qemuAgentGuestSync ( mon ) < 0 ) return - 1 ;\n<12> memset ( & msg , 0 , sizeof ( msg ) ) ;\n<14> if ( virAsprintf ( & msg . txBuffer , "%s" LINE_ENDING , cmdstr ) < 0 ) goto cleanup ;\n<15> msg . txLength = strlen ( msg . txBuffer ) ;\n<17> ret = qemuAgentSend ( mon , & msg , seconds ) ;\n<18> VIR_DEBUG ( "Receive command reply ret=%d rxObject=%p" , ret , msg . rxObject ) ;\n<20> if ( ! msg . rxObject ) {\n<31> * reply = msg . rxObject ;\n<36> VIR_FREE ( msg . txBuffer ) ;
<1> int reg_replace ( char * * buf_p , int * buf_len_p , char * pattern , char * replace , char * string , int icase ) {\n<12> len = strlen ( string ) ;\n<13> str_end = string + len ;\n<14> need_buf_len = len * 2 + 1 ;\n<17> if ( ( err_code = my_regcomp ( & r , pattern , cflags , & my_charset_latin1 ) ) ) {\n<22> * res_p = 0 ;\n<23> str_p = string ;\n<24> replace_end = replace + strlen ( replace ) ;\n<26> err_code = my_regexec ( & r , str_p , r . re_nsub + 1 , subs , ( str_p == string ) ? REG_NOTBOL : 0 ) ;\n<33> char * expr_p = replace ;\n<35> need_buf_len = ( res_p - buf ) + ( int ) subs [ 0 ] . rm_so ;\n<36> while ( expr_p < replace_end ) {\n<55> SECURE_REG_BUF if ( subs [ 0 ] . rm_so ) {\n<56> memcpy ( res_p , str_p , ( size_t ) subs [ 0 ] . rm_so ) ;\n<57> res_p += subs [ 0 ] . rm_so ;\n<68> if ( ( start_off = subs [ back_ref_num ] . rm_so ) > - 1 && ( end_off = subs [ back_ref_num ] . rm_eo ) > - 1 ) {\n<69> int block_len = ( int ) ( end_off - start_off ) ;\n<70> memcpy ( res_p , str_p + start_off , block_len ) ;\n<71> res_p += block_len ;\n<76> * res_p ++ = * expr_p ++ ;\n<80> if ( str_p + subs [ 0 ] . rm_so >= str_end ) break ;\n<81> str_p += subs [ 0 ] . rm_eo ;\n<85> str_p += subs [ 0 ] . rm_eo ;
<1> static unsigned char * extra_get_record ( struct isoent * isoent , int * space , int * off , int * loc ) {\n<10> if ( rec == NULL || DR_SAFETY > LOGICAL_BLOCK_SIZE - rec -> offset ) {\n<11> rec = malloc ( sizeof ( * rec ) ) ;\n<12> if ( rec == NULL ) return ( NULL ) ;
<1> static void json_print_section_footer ( WriterContext * wctx ) {\n<2> JSONContext * json = wctx -> priv ;\n<9> else if ( section -> flags & SECTION_FLAG_IS_ARRAY ) {\n<10> printf ( "\n" ) ;\n<13> printf ( "]" ) ;\n<16> printf ( "%s" , json -> item_start_end ) ;
<1> static void CloseEncoder ( vlc_object_t * p_this ) {\n<3> encoder_sys_t * p_sys = p_enc -> p_sys ;\n<4> if ( p_sys -> p_schro ) schro_encoder_free ( p_sys -> p_schro ) ;\n<5> free ( p_sys -> p_format ) ;\n<6> if ( p_sys -> p_dts_fifo ) block_FifoRelease ( p_sys -> p_dts_fifo ) ;\n<7> block_ChainRelease ( p_sys -> p_chain ) ;\n<8> free ( p_sys ) ;
<1> static void start_put ( struct transfer_request * request ) {\n<12> unpacked = read_sha1_file ( request -> obj -> oid . hash , & type , & len ) ;\n<27> free ( unpacked ) ;\n<31> request -> dest = strbuf_detach ( & buf , NULL ) ;\n<34> request -> url = strbuf_detach ( & buf , NULL ) ;\n<38> curl_setup_http ( slot -> curl , request -> url , DAV_PUT , & request -> buffer , fwrite_null ) ;\n<39> if ( start_active_slot ( slot ) ) {\n<45> free ( request -> url ) ;
<2> if ( RestoringToDB ( AH ) ) ReconnectToServer ( AH , dbname , NULL ) ;\n<8> ahprintf ( AH , "%s\n" , connectbuf . data ) ;\n<11> else ahprintf ( AH , "%s\n" , "\\connect -\n" ) ;\n<13> if ( AH -> currUser ) free ( AH -> currUser ) ;\n<15> if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n<17> if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;
<1> static int archive_read_format_cpio_cleanup ( struct archive_read * a ) {\n<3> cpio = ( struct cpio * ) ( a -> format -> data ) ;\n<4> while ( cpio -> links_head != NULL ) {\n<6> if ( cpio -> links_head -> name ) free ( cpio -> links_head -> name ) ;\n<7> free ( cpio -> links_head ) ;\n<10> free ( cpio ) ;
<1> static kbd_layout_t *parse_keyboard_layout(const name2keysym_t *table,\n<13> char line[1024];\n<19> filename = qemu_find_file(QEMU_FILE_TYPE_KEYMAP, language);\n<27> if (!(filename && (f = fopen(filename, "r")))) {\n<41> if (fgets(line, 1024, f) == NULL)\n<45> len = strlen(line);\n<47> if (len > 0 && line[len - 1] == '\n')\n<49> line[len - 1] = '\0';\n<51> if (line[0] == '#')\n<55> if (!strncmp(line, "map ", 4))\n<59> if (!strncmp(line, "include ", 8)) {\n<77> keysym = get_keysym(table, line);\n<79> if (keysym == 0) {\n<89> int keycode = strtol(rest, &rest2, 0);\n<93> if (rest && strstr(rest, "numlock")) {\n<95> add_to_key_range(&k->keypad_range, keycode);\n<97> add_to_key_range(&k->numlock_range, keysym);\n<105> if (rest && strstr(rest, "shift"))\n<107> keycode |= SCANCODE_SHIFT;\n<109> if (rest && strstr(rest, "altgr"))\n<111> keycode |= SCANCODE_ALTGR;\n<113> if (rest && strstr(rest, "ctrl"))\n<115> keycode |= SCANCODE_CTRL;\n<119> add_keysym(line, keysym, keycode, k);\n<123> if (rest && strstr(rest, "addupper")) {\n<127> for (c = line; *c; c++)\n<131> keysym = get_keysym(table, line);\n<133> if (keysym)\n<135> add_keysym(line, keysym, keycode | SCANCODE_SHIFT, k);\n<147> fclose(f);
<1> static int encode_hq_slice ( AVCodecContext * avctx , void * arg ) {\n<3> VC2EncContext * s = slice_dat -> ctx ;\n<11> memset ( put_bits_ptr ( pb ) , 0 , s -> prefix_bytes ) ;\n<12> skip_put_bytes ( pb , s -> prefix_bytes ) ;\n<20> p < 3 ;\n<39> pad_c = ( pad_s * s -> size_scaler ) - bytes_len ;\n<43> pad_c = ( pad_s * s -> size_scaler ) - bytes_len ;\n<47> memset ( put_bits_ptr ( pb ) , 0xFF , pad_c ) ;\n<48> skip_put_bytes ( pb , pad_c ) ;
<1> void netdev_del_completion(ReadLineState *rs, int nb_args, const char *str)\n<11> if (nb_args != 2) {\n<19> len = strlen(str);\n<21> readline_set_completion_index(rs, len);\n<33> if (strncmp(str, name, len)) {
<1> static struct scoop_info_s *spitz_scoop_init(struct pxa2xx_state_s *cpu,\n<15> memset(s, 0, sizeof(struct scoop_info_s) * count);\n<37> register_savevm("scoop", 0, 0, scoop_save, scoop_load, &s[0]);\n<43> return s;\n<53> register_savevm("scoop", 1, 0, scoop_save, scoop_load, &s[1]);\n<57> return s;
<1> void prepare_play(void)\n<9> if (!ofmt) {\n<11> fprintf(stderr, "Could not find audio device\n");
<1> static int disas_vfp_insn(CPUState * env, DisasContext *s, uint32_t insn)\n<444> rn = ((insn >> 15) & 0x1e) | ((insn >> 7) & 1);\n<450> VFP_DREG_N(rn, insn);\n<456> if (op == 15 && (rn == 15 || rn > 17)) {\n<470> if (op == 15 && (rn == 16 || rn == 17)) {\n<484> rn = VFP_SREG_N(insn);\n<486> if (op == 15 && rn == 15) {\n<506> if (op == 15 && rn > 3)\n<576> if (op == 15) {\n<650> gen_mov_F0_vreg(dp, rn);\n<662> switch (op) {\n<786> switch (rn) {\n<968> printf ("rn:%d\n", rn);\n<978> printf ("op:%d\n", op);\n<988> if (op == 15 && (rn >= 8 && rn <= 11))\n<992> else if (op == 15 && rn > 17)\n<998> else if (op == 15 && rn == 15)\n<1046> if (op == 15) {\n<1064> gen_mov_F0_vreg(dp, rn);
<1> static void win32_rearm_timer(struct qemu_alarm_timer *t,\n<33> if (!success) {\n<35> fprintf(stderr, "Failed to rearm win32 alarm timer: %ld\n",
<1> static void mpeg_decode_picture_coding_extension(Mpeg1Context *s1)\n<5> MpegEncContext *s = &s1->mpeg_enc_ctx;\n<103> if (s->picture_structure == PICT_FRAME) {\n<115> memset(s->mbskip_table, 0, s->mb_stride * s->mb_height);
<1> static void svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane, unsigned char *ref_plane, unsigned char *decoded_plane,\n<3> int width, int height, int src_stride, int stride)\n<123> s->m.new_picture.data[0]= src - y*16*stride; //ugly\n<129> for(i=0; i<16 && i + 16*y<height; i++){\n<131> memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n<133> for(x=width; x<16*block_width; x++)\n<139> for(; i<16 && i + 16*y<16*block_height; i++)\n<141> memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n<177> uint8_t src[stride*16];\n<181> for(i=0; i<16 && i + 16*y<height; i++){\n<183> memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n<185> for(x=width; x<16*block_width; x++)\n<191> for(; i<16 && i + 16*y<16*block_height; i++)\n<193> memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n<243> score[0]+= encode_block(s, src+16*x, NULL, temp, stride, 5, 64, lambda, 1);\n<319> score[1]+= encode_block(s, src+16*x, temp+16, decoded, stride, 5, 64, lambda, 0);\n<327> score[2]= s->dsp.sse[0](NULL, src+16*x, ref, stride, 16);
<1> static void copy_prev_row ( Jbig2Image * image , int row ) {\n<2> if ( ! row ) {\n<3> memset ( image -> data , 0 , image -> stride ) ;\n<6> uint8_t * src = image -> data + ( row - 1 ) * image -> stride ;\n<7> memcpy ( src + image -> stride , src , image -> stride ) ;
<1> int dtls1_send_hello_verify_request ( SSL * s ) {\n<9> if ( s -> ctx -> app_gen_cookie_cb == NULL || s -> ctx -> app_gen_cookie_cb ( s , s -> d1 -> cookie , & ( s -> d1 -> cookie_len ) ) == 0 ) {\n<13> * ( p ++ ) = ( unsigned char ) s -> d1 -> cookie_len ;\n<14> memcpy ( p , s -> d1 -> cookie , s -> d1 -> cookie_len ) ;\n<15> p += s -> d1 -> cookie_len ;
<1> AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)\n<15> if (!st) {\n<17> fprintf(stderr, "Could not alloc stream\n");\n<29> if (!codec) {\n<31> fprintf(stderr, "codec not found\n");\n<55> if (avcodec_open(c, codec) < 0) {\n<57> fprintf(stderr, "could not open codec\n");\n<73> audio_outbuf_size = 10000;\n<75> audio_outbuf = malloc(audio_outbuf_size);\n<85> audio_input_frame_size = audio_outbuf_size / c->channels;\n<113> samples = malloc(audio_input_frame_size * 2 * c->channels);
<1> struct st_replace_regex * init_replace_regex ( char * expr ) {\n<6> uint expr_len = strlen ( expr ) ;\n<9> res = ( struct st_replace_regex * ) my_malloc ( sizeof ( * res ) + expr_len , MYF ( MY_FAE + MY_WME ) ) ;\n<12> expr_end = expr + expr_len ;\n<13> p = expr ;\n<39> die ( "Error parsing replace_regex \"%s\"" , expr ) ;
<1> static int64_t get_pts(const char *buf, int *duration)\n<11> for (i=0; i<2; i++) {\n<15> if (sscanf(buf, "%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d",\n<19> min += 60*hour;\n<21> sec += 60*min;\n<23> start = sec*1000+hsec;\n<25> me += 60*he;\n<27> se += 60*me;\n<29> end = se*1000+mse;\n<31> *duration = end - start;\n<33> return start;\n<37> buf += strcspn(buf, "\n") + 1;
<1> void record_loop_stats ( double offset , double freq , double jitter , double wander , int spoll ) {\n<7> day = now . l_ui / 86400 + MJD_1900 ;\n<9> if ( loopstats . fp != NULL ) {\n<10> fprintf ( loopstats . fp , "%lu %s %.9f %.3f %.9f %.6f %d\n" , day , ulfptoa ( & now , 3 ) , offset , freq * 1e6 , jitter , wander * 1e6 , spoll ) ;\n<11> fflush ( loopstats . fp ) ;
<1> DEFINE_TEST ( test_read_format_mtree_nonexistent_contents_file ) {\n<11> assert ( strlen ( archive_error_string ( a ) ) > 0 ) ;
<1> bool mysql_show_grants ( THD * thd , LEX_USER * lex_user ) {\n<18> if ( ! acl_user ) {\n<56> global . append ( lex_user -> user . str , lex_user -> user . length , system_charset_info ) ;\n<77> if ( acl_user -> x509_issuer ) {\n<80> global . append ( acl_user -> x509_issuer , strlen ( acl_user -> x509_issuer ) ) ;\n<83> if ( acl_user -> x509_subject ) {\n<86> global . append ( acl_user -> x509_subject , strlen ( acl_user -> x509_subject ) , system_charset_info ) ;\n<89> if ( acl_user -> ssl_cipher ) {\n<92> global . append ( acl_user -> ssl_cipher , strlen ( acl_user -> ssl_cipher ) , system_charset_info ) ;\n<112> counter < acl_dbs . elements ;\n<113> counter ++ ) {\n<116> if ( ! ( user = acl_db -> user ) ) user = "" ;\n<117> if ( ! ( host = acl_db -> host . hostname ) ) host = "" ;\n<118> if ( ! strcmp ( lex_user -> user . str , user ) && ! my_strcasecmp ( system_charset_info , lex_user -> host . str , host ) ) {\n<119> want_access = acl_db -> access ;\n<120> if ( want_access ) {\n<121> String db ( buff , sizeof ( buff ) , system_charset_info ) ;\n<140> append_identifier ( thd , & db , acl_db -> db , strlen ( acl_db -> db ) ) ;\n<142> db . append ( lex_user -> user . str , lex_user -> user . length , system_charset_info ) ;\n<144> db . append ( host , strlen ( host ) , system_charset_info ) ;\n<157> index < column_priv_hash . records ;\n<158> index ++ ) {\n<160> GRANT_TABLE * grant_table = ( GRANT_TABLE * ) hash_element ( & column_priv_hash , index ) ;\n<161> if ( ! ( user = grant_table -> user ) ) user = "" ;\n<162> if ( ! ( host = grant_table -> host . hostname ) ) host = "" ;\n<163> if ( ! strcmp ( lex_user -> user . str , user ) && ! my_strcasecmp ( system_charset_info , lex_user -> host . str , host ) ) {\n<164> ulong table_access = grant_table -> privs ;\n<165> if ( ( table_access | grant_table -> cols ) != 0 ) {\n<166> String global ( buff , sizeof ( buff ) , system_charset_info ) ;\n<207> append_identifier ( thd , & global , grant_table -> db , strlen ( grant_table -> db ) ) ;\n<209> append_identifier ( thd , & global , grant_table -> tname , strlen ( grant_table -> tname ) ) ;\n<211> global . append ( lex_user -> user . str , lex_user -> user . length , system_charset_info ) ;\n<213> global . append ( host , strlen ( host ) , system_charset_info ) ;
<1> static void ini_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n<2> printf ( "%s=%lld\n" , key , value ) ;
<1> static int record_hardlink ( struct archive_read * a , struct cpio * cpio , struct archive_entry * entry ) {\n<8> for ( le = cpio -> links_head ;\n<9> le ;\n<10> le = le -> next ) {\n<11> if ( le -> dev == dev && le -> ino == ino ) {\n<12> archive_entry_copy_hardlink ( entry , le -> name ) ;\n<13> if ( -- le -> links <= 0 ) {\n<14> if ( le -> previous != NULL ) le -> previous -> next = le -> next ;\n<15> if ( le -> next != NULL ) le -> next -> previous = le -> previous ;\n<16> if ( cpio -> links_head == le ) cpio -> links_head = le -> next ;\n<17> free ( le -> name ) ;\n<18> free ( le ) ;\n<23> le = ( struct links_entry * ) malloc ( sizeof ( struct links_entry ) ) ;\n<24> if ( le == NULL ) {\n<35> le -> name = strdup ( archive_entry_pathname ( entry ) ) ;\n<36> if ( le -> name == NULL ) {
<59> if (av_new_packet(pkt, size + nut->header_len[header_idx]) < 0)\n<63> memcpy(pkt->data, nut->header[header_idx], nut->header_len[header_idx]);\n<71> if (read_sm_data(s, bc, pkt, 0, pkt->pos + size) < 0)\n<75> if (read_sm_data(s, bc, pkt, 1, pkt->pos + size) < 0)\n<89> avio_read(bc, pkt->data + nut->header_len[header_idx], size);
<1> static inline void vmsvga_update_rect(struct vmsvga_state_s *s,\n<23> if (x < 0) {\n<25> fprintf(stderr, "%s: update x was < 0 (%d)\n", __func__, x);\n<27> w += x;\n<29> x = 0;\n<33> if (w < 0) {\n<35> fprintf(stderr, "%s: update w was < 0 (%d)\n", __func__, w);\n<37> w = 0;\n<41> if (x + w > surface_width(surface)) {\n<43> fprintf(stderr, "%s: update width too large x: %d, w: %d\n",\n<47> x = MIN(x, surface_width(surface));\n<55> if (y < 0) {\n<57> fprintf(stderr, "%s: update y was < 0 (%d)\n",  __func__, y);\n<59> h += y;\n<61> y = 0;\n<65> if (h < 0) {\n<67> fprintf(stderr, "%s: update h was < 0 (%d)\n",  __func__, h);\n<69> h = 0;\n<73> if (y + h > surface_height(surface)) {\n<75> fprintf(stderr, "%s: update height too large y: %d, h: %d\n",\n<79> y = MIN(y, surface_height(surface));\n<89> width = surface_bytes_per_pixel(surface) * w;\n<93> src = s->vga.vram_ptr + start;\n<95> dst = surface_data(surface) + start;\n<99> for (line = h; line > 0; line--, src += bypl, dst += bypl) {\n<101> memcpy(dst, src, width);
<1> static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n<11> switch (opc) {\n<597> fprintf(stderr, "unknown opcode 0x%x\n", opc);
<1> static int con_init(struct XenDevice *xendev)\n<15> snprintf(con->console, sizeof(con->console), "%s/console", dom);\n<17> free(dom);\n<23> if (!type || strcmp(type, "ioemu") != 0) {\n<25> xen_be_printf(xendev, 1, "not for me (type=%s)\n", type);\n<27> return -1;\n<33> if (!serial_hds[con->xendev.dev])\n<45> return 0;
<1> static void io_mem_init(void)\n<21> phys_ram_dirty = qemu_vmalloc(phys_ram_size >> TARGET_PAGE_BITS);\n<23> memset(phys_ram_dirty, 0xff, phys_ram_size >> TARGET_PAGE_BITS);
<1> void getauthkeys ( const char * keyfile ) {\n<3> len = strlen ( keyfile ) ;\n<4> if ( ! len ) return ;\n<6> memcpy ( key_file_name , keyfile , len + 1 ) ;
<1> static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n<11> switch (data[0]) {\n<49> for (i = 0; i < limit; i++) {\n<51> int32_t val = read_s32(data, 4 + (i * 4));\n<53> memcpy(data + 4 + (i * 4), &val, sizeof(val));\n<135> switch (read_u8(data, 1)) {\n<159> switch (read_u16 (data, 2)) {\n<179> switch (read_u8(data, 4)) {\n<195> printf("Invalid audio format %d\n", read_u8(data, 4));\n<205> if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n<209> read_u8(data, 5));\n<223> printf ("Invalid audio message %d\n", read_u8(data, 4));\n<237> printf("Msg: %d\n", read_u16(data, 0));\n<249> printf("Msg: %d\n", data[0]);
<1> static inline void * ruby_zalloc ( size_t n ) {\n<2> void * p = ruby_xmalloc ( n ) ;\n<3> memset ( p , 0 , n ) ;\n<4> return p ;
<1> void ppce500_init(MachineState *machine, PPCE500Params *params)\n<85> if (cpu == NULL) {\n<87> fprintf(stderr, "Unable to initialize CPU!\n");\n<263> if (!pci_bus)\n<265> printf("couldn't create PCI controller!\n");\n<379> if (kernel_size < 0) {\n<381> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<403> initrd_size = load_image_targphys(machine->initrd_filename, initrd_base,\n<409> if (initrd_size < 0) {\n<411> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<461> bios_name = machine->kernel_filename;\n<489> kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL,\n<493> if (kernel_size < 0) {\n<495> fprintf(stderr, "qemu: could not load firmware '%s'\n", filename);\n<511> dt_size = ppce500_prep_device_tree(machine, params, dt_base,\n<517> if (dt_size < 0) {\n<519> fprintf(stderr, "couldn't load device tree\n");
<1> static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n<5> char local[13];\n<9> memcpy(local, version, 12);\n<11> local[12] = 0;\n<15> if (sscanf(local, "RFB %03d.%03d\n", &vs->major, &vs->minor) != 2) {\n<17> VNC_DEBUG("Malformed protocol version %s\n", local);\n<19> vnc_client_error(vs);\n<21> return 0;\n<25> VNC_DEBUG("Client request protocol version %d.%d\n", vs->major, vs->minor);\n<27> if (vs->major != 3 ||\n<29> (vs->minor != 3 &&\n<31> vs->minor != 4 &&\n<33> vs->minor != 5 &&\n<35> vs->minor != 7 &&\n<37> vs->minor != 8)) {\n<57> if (vs->minor == 4 || vs->minor == 5)\n<63> if (vs->minor == 3) {
<1> void mime_field_value_append ( HdrHeap * heap , MIMEHdrImpl * mh , MIMEField * field , const char * value , int length , bool prepend_comma , const char separator ) {\n<6> char * new_str = heap -> expand_str ( field -> m_ptr_value , field -> m_len_value , new_length ) ;\n<7> if ( new_str == nullptr ) {\n<8> new_str = heap -> allocate_str ( new_length ) ;\n<9> memcpy ( new_str , field -> m_ptr_value , field -> m_len_value ) ;\n<11> char * ptr = new_str + field -> m_len_value ;\n<12> if ( prepend_comma && field -> m_len_value ) {\n<14> * ptr ++ = ' ' ;\n<16> memcpy ( ptr , value , length ) ;\n<17> field -> m_ptr_value = new_str ;
<1> int authreadkeys ( const char * file ) {\n<13> if ( fp == NULL ) {\n<20> while ( ( line = fgets ( buf , sizeof buf , fp ) ) != NULL ) {\n<21> if ( nerr > nerr_maxlimit ) break ;\n<22> token = nexttok ( & line ) ;\n<23> if ( token == NULL ) continue ;\n<33> token = nexttok ( & line ) ;\n<34> if ( token == NULL ) {\n<53> if ( token == NULL ) {\n<57> len = strlen ( token ) ;\n<58> if ( len <= 20 ) {\n<59> MD5auth_setkey ( keyno , keytype , ( u_char * ) token , len ) ;\n<62> char hex [ ] = "0123456789abcdef" ;\n<68> j < jlim ;\n<70> ptr = strchr ( hex , tolower ( ( unsigned char ) token [ j ] ) ) ;\n<71> if ( ptr == NULL ) break ;\n<72> temp = ( u_char ) ( ptr - hex ) ;
<1> static void test_field_flags ( ) {\n<16> if ( ! opt_silent ) fputc ( '\n' , stdout ) ;\n<18> i < mysql_num_fields ( result ) ;\n<19> i ++ ) {\n<21> if ( ! opt_silent ) {\n<22> fprintf ( stdout , "\n field:%d" , i ) ;\n<23> if ( field -> flags & NOT_NULL_FLAG ) fprintf ( stdout , "\n NOT_NULL_FLAG" ) ;\n<24> if ( field -> flags & PRI_KEY_FLAG ) fprintf ( stdout , "\n PRI_KEY_FLAG" ) ;\n<25> if ( field -> flags & UNIQUE_KEY_FLAG ) fprintf ( stdout , "\n UNIQUE_KEY_FLAG" ) ;\n<26> if ( field -> flags & MULTIPLE_KEY_FLAG ) fprintf ( stdout , "\n MULTIPLE_KEY_FLAG" ) ;\n<27> if ( field -> flags & AUTO_INCREMENT_FLAG ) fprintf ( stdout , "\n AUTO_INCREMENT_FLAG" ) ;
<1> static void pk_transaction_search_files ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n<16> ret = pk_transaction_search_check ( values , & error ) ;\n<22> values [ i ] != NULL ;\n<23> i ++ ) {\n<24> if ( values [ i ] [ 0 ] != '/' && strstr ( values [ i ] , "/" ) != NULL ) {\n<25> g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_SEARCH_PATH_INVALID , "Invalid search path" ) ;\n<26> pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;
<1> static int webvtt_event_to_ass(AVBPrint *buf, const char *p)\n<13> for (i = 0; i < FF_ARRAY_ELEMS(webvtt_tag_replace); i++) {\n<15> const char *from = webvtt_tag_replace[i].from;\n<17> const size_t len = strlen(from);\n<19> if (!strncmp(p, from, len)) {
<1> void axisdev88_init (ram_addr_t ram_size,\n<5> const char *kernel_filename, const char *kernel_cmdline,\n<55> cpu_register_physical_memory(0x40000000, ram_size, phys_ram | IO_MEM_RAM);\n<93> cpu_irq = cris_pic_init_cpu(env);\n<179> if (kernel_filename) {\n<201> kernel_size = load_image_targphys(kernel_filename, 0x40004000,\n<215> if (kernel_cmdline && (kcmdline_len = strlen(kernel_cmdline))) {\n<217> if (kcmdline_len > 256) {\n<219> fprintf(stderr, "Too long CRIS kernel cmdline (max 256)\n");\n<227> env->regs[10] = 0x87109563;\n<229> env->regs[11] = 0x40000000;\n<231> pstrcpy_targphys(env->regs[11], 256, kernel_cmdline);\n<237> env->pc = bootstrap_pc;\n<241> printf ("pc =%x\n", env->pc);\n<243> printf ("ram size =%ld\n", ram_size);
<1> struct evbuffer * evbuffer_new ( void ) {\n<3> buffer = calloc ( 1 , sizeof ( struct evbuffer ) ) ;\n<4> return ( buffer ) ;
<1> static int chk_index ( MI_CHECK * param , MI_INFO * info , MI_KEYDEF * keyinfo , my_off_t page , uchar * buff , ha_rows * keys , ha_checksum * key_checksum , uint level ) {\n<3> uint used_length , comp_flag , nod_flag , key_length = 0 ;\n<4> uchar key [ HA_MAX_POSSIBLE_KEY_BUFF ] , * temp_buff , * keypos , * old_keypos , * endpos ;\n<32> if ( * killed_ptr ( param ) ) goto err ;\n<33> memcpy ( ( char * ) info -> lastkey , ( char * ) key , key_length ) ;\n<34> info -> lastkey_length = key_length ;\n<40> if ( keypos >= endpos || ( key_length = ( * keyinfo -> get_key ) ( keyinfo , nod_flag , & keypos , key ) ) == 0 ) break ;\n<45> if ( ( * keys ) ++ && ( flag = ha_key_cmp ( keyinfo -> seg , info -> lastkey , key , key_length , comp_flag , diff_pos ) ) >= 0 ) {\n<47> DBUG_DUMP ( "new" , ( uchar * ) key , key_length ) ;\n<55> if ( param -> stats_method == MI_STATS_METHOD_NULLS_NOT_EQUAL ) ha_key_cmp ( keyinfo -> seg , info -> lastkey , key , USE_WHOLE_KEY , SEARCH_FIND | SEARCH_NULL_ARE_NOT_EQUAL , diff_pos ) ;\n<57> diff_pos [ 0 ] = mi_collect_stats_nonulls_next ( keyinfo -> seg , param -> notnull_count , info -> lastkey , key ) ;\n<62> if ( param -> stats_method == MI_STATS_METHOD_IGNORE_NULLS ) mi_collect_stats_nonulls_first ( keyinfo -> seg , param -> notnull_count , key ) ;\n<65> ( * key_checksum ) += mi_byte_checksum ( ( uchar * ) key , key_length - info -> s -> rec_reflength ) ;\n<66> record = _mi_dpos ( info , 0 , key + key_length ) ;\n<70> get_key_full_length_rdonly ( off , key ) ;\n<74> if ( chk_index_down ( param , info , & info -> s -> ft2_keyinfo , record , temp_buff , & tmp_keys , key_checksum , 1 ) ) goto err ;
<1> static TRBCCode xhci_address_slot(XHCIState *xhci, unsigned int slotid,\n<22> xhci_dma_read_u32s(xhci, ictx, ictl_ctx, sizeof(ictl_ctx));\n<23> if (ictl_ctx[0] != 0x0 || ictl_ctx[1] != 0x3) {\n<24> fprintf(stderr, "xhci: invalid input context control %08x %08x\n",\n<35> if (uport == NULL) {\n<36> fprintf(stderr, "xhci: port not found\n");\n<40> if (!dev) {\n<41> fprintf(stderr, "xhci: port %s not connected\n", uport->path);\n<45> if (i == slotid-1) {\n<48> if (xhci->slots[i].uport == uport) {\n<49> fprintf(stderr, "xhci: port %s already assigned to slot %d\n",
<1> static void test_bug21206 ( ) {\n<2> const size_t cursor_count = 1025 ;\n<7> Stmt_fetch * fetch_array = ( Stmt_fetch * ) calloc ( cursor_count , sizeof ( Stmt_fetch ) ) ;\n<12> for ( fetch = fetch_array ;\n<13> fetch < fetch_array + cursor_count ;\n<15> stmt_fetch_init ( fetch , fetch - fetch_array , query ) ;\n<17> for ( fetch = fetch_array ;\n<18> fetch < fetch_array + cursor_count ;\n<20> free ( fetch_array ) ;
<1> VAR * var_from_env ( const char * name , const char * def_val ) {\n<4> if ( ! ( tmp = getenv ( name ) ) ) tmp = def_val ;\n<5> v = var_init ( 0 , name , strlen ( name ) , tmp , strlen ( tmp ) ) ;\n<6> my_hash_insert ( & var_hash , ( uchar * ) v ) ;\n<7> return v ;
<13> AVFrame *picture = data;\n<191> if(!s->lossless){\n<193> picture->quality= FFMAX(FFMAX(s->qscale[0], s->qscale[1]), s->qscale[2]);\n<197> picture->qscale_table= s->qscale_table;\n<199> memset(picture->qscale_table, picture->quality, (s->width+15)/16);\n<203> av_log(avctx, AV_LOG_DEBUG, "QP: %d\n", picture->quality);\n<205> picture->quality*= FF_QP2LAMBDA;
<1> static TRBCCode xhci_address_slot(XHCIState *xhci, unsigned int slotid,\n<49> xhci_dma_read_u32s(xhci, ictx, ictl_ctx, sizeof(ictl_ctx));\n<53> if (ictl_ctx[0] != 0x0 || ictl_ctx[1] != 0x3) {\n<55> fprintf(stderr, "xhci: invalid input context control %08x %08x\n",\n<85> if (uport == NULL) {\n<87> fprintf(stderr, "xhci: port not found\n");\n<93> trace_usb_xhci_slot_address(slotid, uport->path);\n<99> if (!dev) {\n<101> fprintf(stderr, "xhci: port %s not connected\n", uport->path);\n<111> if (i == slotid-1) {\n<117> if (xhci->slots[i].uport == uport) {\n<119> fprintf(stderr, "xhci: port %s already assigned to slot %d\n",\n<139> if (bsr) {\n<155> memset(&p, 0, sizeof(p));\n<157> usb_packet_addbuf(&p, buf, sizeof(buf));\n<171> assert(p.status != USB_RET_ASYNC);
<1> static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s , AVFrame * frame ) {\n<3> unsigned char P [ 2 ] ;\n<5> y < 8 ;\n<8> P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n<9> P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n<11> memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ;\n<12> memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ;\n<13> s -> pixel_ptr += s -> stride ;
<1> static gboolean process_packet_data ( struct wtap_pkthdr * phdr , Buffer * target , guint8 * buffer , guint record_len , k12_t * k12 , int * err , gchar * * err_info ) {\n<17> if ( length > record_len - buffer_offset ) {\n<28> ws_buffer_assure_space ( target , length ) ;\n<29> memcpy ( ws_buffer_start_ptr ( target ) , buffer + buffer_offset , length ) ;\n<30> extra_len = record_len - buffer_offset - length ;\n<31> ws_buffer_assure_space ( & ( k12 -> extra_info ) , extra_len ) ;\n<32> memcpy ( ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) , buffer + buffer_offset + length , extra_len ) ;\n<33> phdr -> pseudo_header . k12 . extra_info = ( guint8 * ) ws_buffer_start_ptr ( & ( k12 -> extra_info ) ) ;\n<34> phdr -> pseudo_header . k12 . extra_length = extra_len ;\n<37> phdr -> pseudo_header . k12 . input = src_id ;\n<38> if ( ! ( src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id ) ) ) ) {\n<39> src_desc = ( k12_src_desc_t * ) g_hash_table_lookup ( k12 -> src_by_id , GUINT_TO_POINTER ( src_id & K12_RECORD_SRC_ID_MASK ) ) ;\n<41> if ( src_desc ) {\n<46> switch ( src_desc -> input_type ) {\n<47> case K12_PORT_ATMPVC : if ( ( long ) ( buffer_offset + length + K12_PACKET_OFFSET_CID ) < record_len ) {\n<53> default : memcpy ( & ( phdr -> pseudo_header . k12 . input_info ) , & ( src_desc -> input_info ) , sizeof ( src_desc -> input_info ) ) ;\n<59> memset ( & ( phdr -> pseudo_header . k12 ) , 0 , sizeof ( phdr -> pseudo_header . k12 ) ) ;
<1> static int yop_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<16> if ( ! avctx -> frame_number ) memset ( frame -> data [ 1 ] , 0 , AVPALETTE_SIZE ) ;\n<24> palette = ( uint32_t * ) frame -> data [ 1 ] ;
<1> static void test_smbios_ep_address(test_data *data)\n<11> for (off = 0xf0000; off < 0x100000; off += 0x10) {\n<21> sig[i] = readb(off + i);\n<27> if (!memcmp(sig, "_SM_", sizeof sig)) {
<1> void replay_configure(QemuOpts *opts)\n<31> if (!rr) {\n<37> } else if (!strcmp(rr, "record")) {\n<39> mode = REPLAY_MODE_RECORD;\n<41> } else if (!strcmp(rr, "replay")) {\n<43> mode = REPLAY_MODE_PLAY;\n<47> error_report("Invalid icount rr option: %s", rr);\n<49> exit(1);
<1> void kadmin_getpol ( int argc , char * argv [ ] ) {\n<4> if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( "-terse" , argv [ 1 ] ) ) ) ) {\n<5> fprintf ( stderr , _ ( "usage: get_policy [-terse] policy\n" ) ) ;\n<6> return ;\n<8> retval = kadm5_get_policy ( handle , argv [ argc - 1 ] , & policy ) ;\n<9> if ( retval ) {\n<13> if ( argc == 2 ) {\n<14> printf ( _ ( "Policy: %s\n" ) , policy . policy ) ;\n<15> printf ( _ ( "Maximum password life: %ld\n" ) , policy . pw_max_life ) ;\n<16> printf ( _ ( "Minimum password life: %ld\n" ) , policy . pw_min_life ) ;\n<17> printf ( _ ( "Minimum password length: %ld\n" ) , policy . pw_min_length ) ;\n<18> printf ( _ ( "Minimum number of password character classes: %ld\n" ) , policy . pw_min_classes ) ;\n<19> printf ( _ ( "Number of old keys kept: %ld\n" ) , policy . pw_history_num ) ;\n<20> printf ( _ ( "Maximum password failures before lockout: %lu\n" ) , ( unsigned long ) policy . pw_max_fail ) ;\n<21> printf ( _ ( "Password failure count reset interval: %s\n" ) , strdur ( policy . pw_failcnt_interval ) ) ;\n<22> printf ( _ ( "Password lockout duration: %s\n" ) , strdur ( policy . pw_lockout_duration ) ) ;\n<23> if ( policy . allowed_keysalts != NULL ) printf ( _ ( "Allowed key/salt types: %s\n" ) , policy . allowed_keysalts ) ;\n<26> printf ( "\"%s\"\t%ld\t%ld\t%ld\t%ld\t%ld\t%ld\t%lu\t%ld\t%ld\t%s\n" , policy . policy , policy . pw_max_life , policy . pw_min_life , policy . pw_min_length , policy . pw_min_classes , policy . pw_history_num , 0 , ( unsigned long ) policy . pw_max_fail , ( long ) policy . pw_failcnt_interval , ( long ) policy . pw_lockout_duration , ( policy . allowed_keysalts == NULL ) ? "-" : policy . allowed_keysalts ) ;\n<28> kadm5_free_policy_ent ( handle , & policy ) ;
<1> static int remoteStreamHandleFinish ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n<5> memset ( & rerr , 0 , sizeof rerr ) ;\n<10> remoteDispatchError ( & rerr ) ;\n<11> return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
<1> static int test_identical_behavior ( xd3_stream * stream , int ignore ) {\n<4> uint8_t del [ IDB_DELSZ ] ;\n<9> usize_t delpos = 0 , recsize ;\n<11> memset ( & source , 0 , sizeof ( source ) ) ;\n<18> source . blksize = IDB_BLKSZ ;\n<19> source . name = "" ;\n<20> source . curblk = NULL ;\n<21> source . curblkno = 0 ;\n<22> if ( ( ret = xd3_set_source ( stream , & source ) ) ) {\n<28> ret = xd3_encode_input ( stream ) ;\n<30> xd3_avail_input ( stream , buf + ( IDB_WINSZ * nextencwin ) , IDB_WINSZ ) ;\n<35> source . curblkno = source . getblkno ;\n<36> source . onblk = IDB_BLKSZ ;\n<37> source . curblk = buf + source . getblkno * IDB_BLKSZ ;\n<46> if ( winfinishes == IDB_WINCNT ) {\n<51> if ( ret != XD3_OUTPUT ) {\n<54> CHECK ( delpos + stream -> avail_out <= IDB_DELSZ ) ;\n<55> memcpy ( del + delpos , stream -> next_out , stream -> avail_out ) ;\n<56> delpos += stream -> avail_out ;\n<57> xd3_consume_output ( stream ) ;\n<62> memset ( & source , 0 , sizeof ( source ) ) ;\n<67> if ( ( ret = xd3_close_stream ( stream ) ) ) {\n<70> xd3_free_stream ( stream ) ;\n<72> if ( ( ret = xd3_config_stream ( stream , & config ) ) ) {
<1> int cmd_rev_list ( int argc , const char * * argv , const char * prefix ) {\n<10> init_revisions ( & revs , prefix ) ;\n<11> revs . abbrev = DEFAULT_ABBREV ;\n<12> revs . commit_format = CMIT_FMT_UNSPECIFIED ;\n<13> argc = setup_revisions ( argc , argv , & revs , NULL ) ;\n<14> memset ( & info , 0 , sizeof ( info ) ) ;\n<19> i < argc ;\n<20> i ++ ) {\n<21> const char * arg = argv [ i ] ;\n<22> if ( ! strcmp ( arg , "--header" ) ) {\n<23> revs . verbose_header = 1 ;\n<26> if ( ! strcmp ( arg , "--timestamp" ) ) {\n<27> info . show_timestamp = 1 ;\n<30> if ( ! strcmp ( arg , "--bisect" ) ) {\n<31> bisect_list = 1 ;\n<34> if ( ! strcmp ( arg , "--bisect-all" ) ) {\n<35> bisect_list = 1 ;\n<36> bisect_find_all = 1 ;\n<37> info . flags |= BISECT_SHOW_ALL ;\n<38> revs . show_decorations = 1 ;\n<41> if ( ! strcmp ( arg , "--bisect-vars" ) ) {\n<42> bisect_list = 1 ;\n<43> bisect_show_vars = 1 ;\n<46> if ( ! strcmp ( arg , "--use-bitmap-index" ) ) {\n<47> use_bitmap_index = 1 ;\n<50> if ( ! strcmp ( arg , "--test-bitmap" ) ) {\n<51> test_bitmap_walk ( & revs ) ;\n<52> return 0 ;\n<54> usage ( rev_list_usage ) ;\n<56> if ( revs . commit_format != CMIT_FMT_UNSPECIFIED ) {\n<58> if ( revs . commit_format == CMIT_FMT_ONELINE ) info . header_prefix = "" ;\n<61> else if ( revs . verbose_header ) revs . commit_format = CMIT_FMT_RAW ;\n<62> if ( ( ! revs . commits && ( ! ( revs . tag_objects || revs . tree_objects || revs . blob_objects ) && ! revs . pending . nr ) ) || revs . diff ) usage ( rev_list_usage ) ;\n<64> save_commit_buffer = ( revs . verbose_header || revs . grep_filter . pattern_list || revs . grep_filter . header_list ) ;\n<65> if ( bisect_list ) revs . limited = 1 ;\n<66> if ( use_bitmap_index && ! revs . prune ) {\n<67> if ( revs . count && ! revs . left_right && ! revs . cherry_mark ) {\n<69> if ( ! prepare_bitmap_walk ( & revs ) ) {\n<70> count_bitmap_commit_list ( & commit_count , NULL , NULL , NULL ) ;\n<71> printf ( "%d\n" , commit_count ) ;\n<75> else if ( revs . tag_objects && revs . tree_objects && revs . blob_objects ) {\n<76> if ( ! prepare_bitmap_walk ( & revs ) ) {\n<82> if ( prepare_revision_walk ( & revs ) ) die ( "revision walk setup failed" ) ;\n<83> if ( revs . tree_objects ) mark_edges_uninteresting ( & revs , show_edge ) ;\n<86> revs . commits = find_bisection ( revs . commits , & reaches , & all , bisect_find_all ) ;\n<87> if ( bisect_show_vars ) return show_bisect_vars ( & info , reaches , all ) ;\n<89> traverse_commit_list ( & revs , show_commit , show_object , & info ) ;\n<91> if ( revs . left_right && revs . cherry_mark ) printf ( "%d\t%d\t%d\n" , revs . count_left , revs . count_right , revs . count_same ) ;\n<92> else if ( revs . left_right ) printf ( "%d\t%d\n" , revs . count_left , revs . count_right ) ;\n<93> else if ( revs . cherry_mark ) printf ( "%d\t%d\n" , revs . count_left + revs . count_right , revs . count_same ) ;\n<94> else printf ( "%d\n" , revs . count_left + revs . count_right ) ;
<1> static void ivi_process_empty_tile(AVCodecContext *avctx, IVIBandDesc *band,\n<167> src = band->ref_buf + tile->ypos * band->pitch + tile->xpos;\n<169> dst = band->buf     + tile->ypos * band->pitch + tile->xpos;\n<171> for (y = 0; y < tile->height; y++) {\n<173> memcpy(dst, src, tile->width*sizeof(band->buf[0]));\n<175> src += band->pitch;\n<177> dst += band->pitch;
<1> void irc_ctcp_display_reply_from_nick ( struct t_irc_server * server , time_t date , const char * command , const char * nick , const char * address , char * arguments ) {\n<5> while ( arguments && arguments [ 0 ] ) {\n<8> pos_space = strchr ( arguments + 1 , ' ' ) ;\n<9> if ( pos_space ) {\n<11> pos_args = pos_space + 1 ;\n<12> while ( pos_args [ 0 ] == ' ' ) {\n<13> pos_args ++ ;\n<15> if ( strcmp ( arguments + 1 , "PING" ) == 0 ) {\n<16> pos_usec = strchr ( pos_args , ' ' ) ;\n<17> if ( pos_usec ) {\n<20> sec1 = atol ( pos_args ) ;\n<21> usec1 = atol ( pos_usec + 1 ) ;\n<30> weechat_printf_date_tags ( irc_msgbuffer_get_target_buffer ( server , nick , NULL , "ctcp" , NULL ) , date , irc_protocol_tags ( command , "irc_ctcp" , NULL , address ) , _ ( "%sCTCP reply from %s%s%s: %s%s%s%s%s" ) , weechat_prefix ( "network" ) , irc_nick_color_for_msg ( server , 0 , NULL , nick ) , nick , IRC_COLOR_RESET , IRC_COLOR_CHAT_CHANNEL , arguments + 1 , IRC_COLOR_RESET , " " , pos_args ) ;
<1> static void pci_hotplug(void)\n<9> const char *arch = qtest_get_arch();\n<37> if (strcmp(arch, "i386") == 0 || strcmp(arch, "x86_64") == 0) {\n<39> qpci_unplug_acpi_device_test("drv1", PCI_SLOT_HP);
<1> static int create_tmp_file ( const char * template , char * * r_bakfname , char * * r_tmpfname , IOBUF * r_fp ) {\n<21> strcpy ( stpcpy ( bakfname , template ) , "~" ) ;\n<22> tmpfname = xmalloc ( strlen ( template ) + 5 ) ;\n<25> if ( is_secured_filename ( tmpfname ) ) {\n<31> if ( ! * r_fp ) {\n<33> log_error ( _ ( "can't create '%s': %s\n" ) , tmpfname , strerror ( errno ) ) ;\n<100> int keyring_rebuild_cache ( void * token , int noisy ) {\n<111> memset ( & desc , 0 , sizeof desc ) ;\n<118> rc = keyring_search ( hd , & desc , 1 , NULL ) ;
<1> REGRESSION_TEST ( SDK_API_UUID ) ( RegressionTest * test , int , int * pstatus ) {\n<14> else if ( ! ( ( ATSUuid * ) machine ) -> valid ( ) ) {\n<24> if ( ! str1 || ( TS_UUID_STRING_LEN != strlen ( str1 ) ) ) {\n<25> SDK_RPRINT ( test , "TSUuidStringGet" , "TestCase1" , TC_FAIL , "Did not return a valid UUID string representation" ) ;\n<26> * pstatus = REGRESSION_TEST_FAILED ;\n<27> return ;\n<30> SDK_RPRINT ( test , "TSUuidStringGet" , "TestCase1" , TC_PASS , "ok" ) ;\n<32> if ( ! ( uuid = TSUuidCreate ( ) ) ) {\n<56> if ( TS_SUCCESS != TSUuidCopy ( uuid , machine ) ) {\n<64> if ( ! str2 || ( TS_UUID_STRING_LEN != strlen ( str2 ) ) || strcmp ( str1 , str2 ) ) {\n<65> SDK_RPRINT ( test , "TSUuidCopy" , "TestCase2" , TC_FAIL , "The copied UUID strings are not identical" ) ;\n<66> * pstatus = REGRESSION_TEST_FAILED ;\n<70> SDK_RPRINT ( test , "TSUuidCopy" , "TestCase2" , TC_PASS , "ok" ) ;\n<73> if ( TS_SUCCESS != TSUuidInitialize ( uuid , TS_UUID_V4 ) ) {\n<81> if ( ! str2 || ( TS_UUID_STRING_LEN != strlen ( str2 ) ) || ! strcmp ( str1 , str2 ) ) {\n<82> SDK_RPRINT ( test , "TSUuidInitialize" , "TestCase3" , TC_FAIL , "The re-initialized string is the same as before" ) ;\n<83> * pstatus = REGRESSION_TEST_FAILED ;\n<87> SDK_RPRINT ( test , "TSUuidInitialize" , "TestCase3" , TC_PASS , "ok" ) ;\n<90> if ( ( TS_SUCCESS != TSUuidStringParse ( uuid , uuid_v1 ) ) || ( TS_UUID_V1 != TSUuidVersionGet ( uuid ) ) ) {\n<98> if ( ! str1 || ( TS_UUID_STRING_LEN != strlen ( str1 ) ) || strcmp ( str1 , uuid_v1 ) ) {\n<99> SDK_RPRINT ( test , "TSUuidStringString" , "TestCase2" , TC_FAIL , "The parse UUID v1 string does not match the original" ) ;\n<100> * pstatus = REGRESSION_TEST_FAILED ;\n<104> SDK_RPRINT ( test , "TSUuidStringParse" , "TestCase2" , TC_PASS , "ok" ) ;\n<107> if ( ( TS_SUCCESS != TSUuidStringParse ( uuid , uuid_v4 ) ) || ( TS_UUID_V4 != TSUuidVersionGet ( uuid ) ) ) {\n<115> if ( ! str1 || ( TS_UUID_STRING_LEN != strlen ( str1 ) ) || strcmp ( str1 , uuid_v4 ) ) {\n<116> SDK_RPRINT ( test , "TSUuidStringParse" , "TestCase4" , TC_FAIL , "The parse UUID v4 string does not match the original" ) ;\n<117> * pstatus = REGRESSION_TEST_FAILED ;\n<121> SDK_RPRINT ( test , "TSUuidStringParse" , "TestCase4" , TC_PASS , "ok" ) ;\n<124> * pstatus = REGRESSION_TEST_PASSED ;
<1> fz_path * xps_parse_path_geometry ( xps_document * doc , xps_resource * dict , fz_xml * root , int stroking , int * fill_rule ) {\n<11> fill_rule_att = fz_xml_att ( root , "FillRule" ) ;\n<14> node ;\n<16> if ( ! strcmp ( fz_xml_tag ( node ) , "PathGeometry.Transform" ) ) transform_tag = fz_xml_down ( node ) ;\n<20> if ( fill_rule_att ) {\n<21> if ( ! strcmp ( fill_rule_att , "NonZero" ) ) * fill_rule = 1 ;\n<22> if ( ! strcmp ( fill_rule_att , "EvenOdd" ) ) * fill_rule = 0 ;\n<31> node ;\n<33> if ( ! strcmp ( fz_xml_tag ( node ) , "PathFigure" ) ) xps_parse_path_figure ( doc -> ctx , path , node , stroking ) ;
<1> static void msix_mmio_writel(void *opaque, target_phys_addr_t addr,\n<3> uint32_t val)\n<7> PCIDevice *dev = opaque;\n<11> int vector = offset / MSIX_ENTRY_SIZE;\n<13> memcpy(dev->msix_table_page + offset, &val, 4);
<1> static void hpet_ram_writel(void *opaque, target_phys_addr_t addr,\n<63> if (new_val & HPET_TIMER_TYPE_LEVEL) {\n<65> printf("qemu: level-triggered hpet not supported\n");\n<249> if (hpet_enabled())\n<251> printf("qemu: Writing counter while HPET enabled!\n");\n<265> if (hpet_enabled())\n<267> printf("qemu: Writing counter while HPET enabled!\n");
<1> static void get_icu_disp_value_src_php ( char * tag_name , INTERNAL_FUNCTION_PARAMETERS ) {\n<18> spprintf ( & msg , 0 , "locale_get_display_%s : unable to parse input params" , tag_name ) ;\n<24> spprintf ( & msg , 0 , "locale_get_display_%s : name too long" , tag_name ) ;\n<32> if ( strcmp ( tag_name , DISP_NAME ) != 0 ) {\n<33> grOffset = findOffset ( LOC_GRANDFATHERED , loc_name ) ;\n<34> if ( grOffset >= 0 ) {\n<35> if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) {\n<36> mod_loc_name = getPreferredTag ( loc_name ) ;\n<53> if ( strcmp ( tag_name , LOC_LANG_TAG ) == 0 ) {\n<54> buflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , & status ) ;\n<56> else if ( strcmp ( tag_name , LOC_SCRIPT_TAG ) == 0 ) {\n<57> buflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , & status ) ;\n<59> else if ( strcmp ( tag_name , LOC_REGION_TAG ) == 0 ) {\n<60> buflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , & status ) ;\n<62> else if ( strcmp ( tag_name , LOC_VARIANT_TAG ) == 0 ) {\n<63> buflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , & status ) ;\n<65> else if ( strcmp ( tag_name , DISP_NAME ) == 0 ) {\n<66> buflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , & status ) ;\n<73> spprintf ( & msg , 0 , "locale_get_display_%s : unable to get locale %s" , tag_name , tag_name ) ;\n<89> while ( buflen > disp_name_len ) ;\n<100> spprintf ( & msg , 0 , "locale_get_display_%s :error converting display name for %s to UTF-8" , tag_name , tag_name ) ;
<39> if (build_filter(c, (void*)c->filter_bank, factor, c->filter_length, c->filter_alloc, phase_count, 1<<c->filter_shift, filter_type, kaiser_beta))\n<40> memcpy(c->filter_bank + (c->filter_alloc*phase_count+1)*c->felem_size, c->filter_bank, (c->filter_alloc-1)*c->felem_size);
<1> static xsltAttrVTPtr xsltSetAttrVTsegment ( xsltAttrVTPtr avt , void * val ) {\n<4> if ( avt == NULL ) {\n<7> memset ( & avt -> segments [ avt -> nb_seg ] , 0 , MAX_AVT_SEG * sizeof ( void * ) ) ;
<1> int crypto_authenticate_and_decrypt ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n<4> if ( * buf_len <= sizeof ( struct crypto_config_header ) ) {\n<39> if ( decrypt_nss_2_3 ( instance , buf , buf_len ) != 0 ) {\n<43> memmove ( buf , buf + sizeof ( struct crypto_config_header ) , * buf_len ) ;
<1> static int vc1_decode_p_mb_intfi ( VC1Context * v ) {\n<20> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n<42> vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n<51> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n<62> vc1_mc_1mv ( v , 0 ) ;\n<77> vc1_mc_4mv_luma ( v , i , 0 ) ;\n<79> else if ( i == 4 ) vc1_mc_4mv_chroma ( v , 0 ) ;\n<101> pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : s -> linesize , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n<108> if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;
<1> static void start_move ( struct transfer_request * request ) {\n<7> curl_setup_http_get ( slot -> curl , request -> url , DAV_MOVE ) ;\n<11> if ( start_active_slot ( slot ) ) {\n<17> free ( request -> url ) ;
<1> static int check_authkeys_file ( struct ssh * ssh , struct passwd * pw , FILE * f , char * file , struct sshkey * key , struct sshauthopt * * authoptsp ) {\n<2> char * cp , * line = NULL , loc [ 256 ] ;\n<7> while ( getline ( & line , & linesize , f ) != - 1 ) {\n<16> free ( line ) ;
<1> static int parse_iplconvkernel(IplConvKernel **kernel, char *buf, void *log_ctx)\n<5> char shape_filename[128] = "", shape_str[32] = "rect";\n<7> int cols = 0, rows = 0, anchor_x = 0, anchor_y = 0, shape = CV_SHAPE_RECT;\n<13> sscanf(buf, "%dx%d+%dx%d/%32[^=]=%127s", &cols, &rows, &anchor_x, &anchor_y, shape_str, shape_filename);\n<17> if      (!strcmp(shape_str, "rect"   )) shape = CV_SHAPE_RECT;\n<19> else if (!strcmp(shape_str, "cross"  )) shape = CV_SHAPE_CROSS;\n<21> else if (!strcmp(shape_str, "ellipse")) shape = CV_SHAPE_ELLIPSE;\n<23> else if (!strcmp(shape_str, "custom" )) {\n<25> shape = CV_SHAPE_CUSTOM;\n<27> if ((ret = read_shape_from_file(&cols, &rows, &values, shape_filename, log_ctx)) < 0)\n<37> return AVERROR(EINVAL);\n<43> if (rows <= 0 || cols <= 0) {\n<55> if (anchor_x < 0 || anchor_y < 0 || anchor_x >= cols || anchor_y >= rows) {\n<69> *kernel = cvCreateStructuringElementEx(cols, rows, anchor_x, anchor_y, shape, values);\n<79> av_log(log_ctx, AV_LOG_VERBOSE, "Structuring element: w:%d h:%d x:%d y:%d shape:%s\n",
<1> int ntpqmain ( int argc , char * argv [ ] ) {\n<15> list = list_digest_names ( ) ;\n<17> icmd < sizeof ( builtins ) / sizeof ( builtins [ 0 ] ) ;\n<18> icmd ++ ) {\n<19> if ( strcmp ( "keytype" , builtins [ icmd ] . keyword ) == 0 ) break ;\n<25> fmt = "set key type to use for authenticated requests (%s)" ;\n<27> sprintf ( msg , fmt , list ) ;\n<28> builtins [ icmd ] . comment = msg ;\n<29> free ( list ) ;
<1> static void decode_frame ( SiprContext * ctx , SiprParameters * params , float * out_data ) {\n<4> int frame_size = subframe_count * SUBFR_SIZE ;\n<7> float ir_buf [ SUBFR_SIZE + LP_FILTER_ORDER ] ;\n<13> memset ( ir_buf , 0 , LP_FILTER_ORDER * sizeof ( float ) ) ;\n<15> sipr_decode_lp ( lsf_new , ctx -> lsp_history , Az , subframe_count ) ;\n<16> memcpy ( ctx -> lsp_history , lsf_new , LP_FILTER_ORDER * sizeof ( float ) ) ;\n<44> postfilter_5k0 ( ctx , pAz , fixed_vector ) ;\n<50> memcpy ( synth - LP_FILTER_ORDER , synth + frame_size - LP_FILTER_ORDER , LP_FILTER_ORDER * sizeof ( float ) ) ;\n<51> if ( ctx -> mode == MODE_5k0 ) {\n<58> memcpy ( ctx -> postfilter_syn5k0 , ctx -> postfilter_syn5k0 + frame_size , LP_FILTER_ORDER * sizeof ( float ) ) ;\n<60> memmove ( ctx -> excitation , excitation - PITCH_DELAY_MAX - L_INTERPOL , ( PITCH_DELAY_MAX + L_INTERPOL ) * sizeof ( float ) ) ;
<1> static int vp8_encode(AVCodecContext *avctx, AVPacket *pkt,\n<37> if (ctx->is_alpha) {\n<45> u_plane = av_malloc(frame->linesize[1] * frame->height);\n<47> memset(u_plane, 0x80, frame->linesize[1] * frame->height);\n<49> rawimg_alpha->planes[VPX_PLANE_U] = u_plane;\n<51> v_plane = av_malloc(frame->linesize[2] * frame->height);\n<53> memset(v_plane, 0x80, frame->linesize[2] * frame->height);\n<55> rawimg_alpha->planes[VPX_PLANE_V] = v_plane;
<1> static my_bool get_view_structure ( char * table , char * db ) {\n<23> field = mysql_fetch_field_direct ( table_res , 0 ) ;\n<24> if ( strcmp ( field -> name , "View" ) != 0 ) {\n<25> mysql_free_result ( table_res ) ;\n<26> switch_character_set_results ( mysql , default_charset ) ;\n<27> verbose_msg ( "-- It's base table, skipped\n" ) ;\n<28> DBUG_RETURN ( 0 ) ;\n<46> if ( mysql_query ( mysql , query ) ) {\n<59> row = mysql_fetch_row ( table_res ) ;\n<63> if ( ! ( table_res = mysql_store_result ( mysql ) ) || ! ( row = mysql_fetch_row ( table_res ) ) ) {\n<70> if ( strcmp ( row [ 0 ] , "NONE" ) ) {\n<71> ptr = search_buf ;\n<72> search_len = ( ulong ) ( strxmov ( ptr , "WITH " , row [ 0 ] , " CHECK OPTION" , NullS ) - ptr ) ;\n<73> ptr = replace_buf ;\n<74> replace_len = ( ulong ) ( strxmov ( ptr , "*/\n/*!50002 WITH " , row [ 0 ] , " CHECK OPTION" , NullS ) - ptr ) ;\n<75> replace ( & ds_view , search_buf , search_len , replace_buf , replace_len ) ;
<1> static void build_completion_hash ( bool rehash , bool write_info ) {\n<8> char buf [ NAME_LEN * 2 + 2 ] ;\n<36> while ( ( table_row = mysql_fetch_row ( tables ) ) ) {\n<37> char * str = strdup_root ( & hash_mem_root , ( char * ) table_row [ 0 ] ) ;\n<38> if ( str && ! completion_hash_exists ( & ht , ( char * ) str , ( uint ) strlen ( str ) ) ) add_word ( & ht , str ) ;\n<51> while ( ( table_row = mysql_fetch_row ( tables ) ) ) {\n<52> if ( ( fields = mysql_list_fields ( & mysql , ( const char * ) table_row [ 0 ] , NullS ) ) ) {\n<60> while ( ( sql_field = mysql_fetch_field ( fields ) ) ) {\n<61> sprintf ( buf , "%.64s.%.64s" , table_row [ 0 ] , sql_field -> name ) ;\n<62> field_names [ i ] [ j ] = strdup_root ( & hash_mem_root , buf ) ;\n<64> field_names [ i ] [ num_fields + j ] = strdup_root ( & hash_mem_root , sql_field -> name ) ;\n<65> if ( ! completion_hash_exists ( & ht , field_names [ i ] [ num_fields + j ] , ( uint ) strlen ( field_names [ i ] [ num_fields + j ] ) ) ) add_word ( & ht , field_names [ i ] [ num_fields + j ] ) ;
<1> void cpu_inject_x86_mce(CPUState *cenv, int bank, uint64_t status,\n<65> fprintf(stderr, "injects mce exception while previous "
<1> ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,\n<5> const char *file, int line,\n<7> const char *func)\n<11> ObjectClass *ret = object_class_dynamic_cast(class, typename);\n<15> if (!ret && class) {\n<17> fprintf(stderr, "%s:%d:%s: Object %p is not an instance of type %s\n",
<1> static int mysql_init_variables ( void ) {\n<64> if ( ! ( dflt_key_cache = get_or_create_key_cache ( default_key_cache_base . str , default_key_cache_base . length ) ) ) {\n<109> my_path ( prg_dev , executing_path_name , NULL ) ;\n<111> else my_path ( prg_dev , my_progname , "mysql/bin" ) ;\n<112> strcat ( prg_dev , "/../" ) ;\n<113> cleanup_dirname ( mysql_home , prg_dev ) ;
<1> static uint32_t file_block_getter ( uint8_t * p , uint32_t s , Gif_Reader * grr ) {\n<2> size_t nread = fread ( p , 1 , s , grr -> f ) ;\n<3> if ( nread < s ) memset ( p + nread , 0 , s - nread ) ;
<1> void _zip_cdir_free ( struct zip_cdir * cd ) {\n<3> if ( ! cd ) return ;\n<5> i < cd -> nentry ;\n<7> free ( cd -> comment ) ;\n<8> free ( cd -> entry ) ;\n<9> free ( cd ) ;
<1> static void prplcb_debug_print ( PurpleDebugLevel level , const char * category , const char * arg_s ) {\n<2> fprintf ( stderr , "DEBUG %s: %s" , category , arg_s ) ;
<1> static void srtp_calc_aead_iv ( srtp_stream_ctx_t * stream , v128_t * iv , xtd_seq_num_t * seq , srtp_hdr_t * hdr ) {\n<9> memset ( & salt , 0 , sizeof ( v128_t ) ) ;\n<11> local_roc = htonl ( local_roc ) ;\n<12> memcpy ( & in . v16 [ 3 ] , & local_roc , sizeof ( local_roc ) ) ;\n<13> memcpy ( & in . v8 [ 2 ] , & hdr -> ssrc , 4 ) ;\n<15> memcpy ( salt . v8 , stream -> salt , SRTP_AEAD_SALT_LEN ) ;\n<16> debug_print ( mod_srtp , "RTP SALT = %s\n" , v128_hex_string ( & salt ) ) ;\n<17> v128_xor ( iv , & in , & salt ) ;
<1> DriveInfo *drive_init(QemuOpts *opts, void *opaque,\n<107> if ((buf = qemu_opt_get(opts, "if")) != NULL) {\n<109> pstrcpy(devname, sizeof(devname), buf);\n<111> if (!strcmp(buf, "ide")) {\n<113> type = IF_IDE;\n<115> max_devs = MAX_IDE_DEVS;\n<117> } else if (!strcmp(buf, "scsi")) {\n<119> type = IF_SCSI;\n<121> max_devs = MAX_SCSI_DEVS;\n<123> } else if (!strcmp(buf, "floppy")) {\n<125> type = IF_FLOPPY;\n<127> max_devs = 0;\n<129> } else if (!strcmp(buf, "pflash")) {\n<131> type = IF_PFLASH;\n<133> max_devs = 0;\n<135> } else if (!strcmp(buf, "mtd")) {\n<137> type = IF_MTD;\n<139> max_devs = 0;\n<141> } else if (!strcmp(buf, "sd")) {\n<143> type = IF_SD;\n<145> max_devs = 0;\n<147> } else if (!strcmp(buf, "virtio")) {\n<149> type = IF_VIRTIO;\n<151> max_devs = 0;\n<153> } else if (!strcmp(buf, "xen")) {\n<155> type = IF_XEN;\n<157> max_devs = 0;\n<159> } else if (!strcmp(buf, "none")) {\n<161> type = IF_NONE;\n<163> max_devs = 0;\n<167> fprintf(stderr, "qemu: unsupported bus type '%s'\n", buf);\n<169> return NULL;\n<177> if (cyls || heads || secs) {\n<179> if (cyls < 1 || (type == IF_IDE && cyls > 16383)) {\n<181> fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", buf);\n<187> if (heads < 1 || (type == IF_IDE && heads > 16)) {\n<189> fprintf(stderr, "qemu: '%s' invalid physical heads number\n", buf);\n<195> if (secs < 1 || (type == IF_IDE && secs > 63)) {\n<197> fprintf(stderr, "qemu: '%s' invalid physical secs number\n", buf);\n<207> if ((buf = qemu_opt_get(opts, "trans")) != NULL) {\n<209> if (!cyls) {\n<221> if (!strcmp(buf, "none"))\n<223> translation = BIOS_ATA_TRANSLATION_NONE;\n<225> else if (!strcmp(buf, "lba"))\n<227> translation = BIOS_ATA_TRANSLATION_LBA;\n<229> else if (!strcmp(buf, "auto"))\n<231> translation = BIOS_ATA_TRANSLATION_AUTO;\n<235> fprintf(stderr, "qemu: '%s' invalid translation type\n", buf);\n<237> return NULL;\n<245> if ((buf = qemu_opt_get(opts, "media")) != NULL) {\n<247> if (!strcmp(buf, "disk")) {\n<249> media = MEDIA_DISK;\n<251> } else if (!strcmp(buf, "cdrom")) {\n<253> if (cyls || secs || heads) {\n<267> fprintf(stderr, "qemu: '%s' invalid media\n", buf);\n<269> return NULL;\n<277> if ((buf = qemu_opt_get(opts, "cache")) != NULL) {\n<279> if (!strcmp(buf, "off") || !strcmp(buf, "none")) {\n<281> bdrv_flags |= BDRV_O_NOCACHE;\n<283> } else if (!strcmp(buf, "writeback")) {\n<289> } else if (!strcmp(buf, "writethrough")) {\n<295> fprintf(stderr, "qemu: invalid cache option\n");\n<297> return NULL;\n<331> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<333> if (strcmp(buf, "?") == 0) {\n<335> fprintf(stderr, "qemu: Supported formats:");\n<337> bdrv_iterate_format(bdrv_format_print, NULL);\n<339> fprintf(stderr, "\n");\n<341> return NULL;\n<345> drv = bdrv_find_whitelisted_format(buf);\n<347> if (!drv) {\n<349> fprintf(stderr, "qemu: '%s' invalid format\n", buf);\n<363> if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n<365> fprintf(stderr, "werror is no supported by this format\n");\n<389> if (type != IF_IDE && type != IF_VIRTIO) {\n<391> fprintf(stderr, "rerror is no supported by this format\n");\n<413> if (type != IF_VIRTIO) {\n<415> fprintf(stderr, "addr is not supported\n");\n<431> if (bus_id != 0 || unit_id != -1) {\n<469> if (unit_id == -1) {\n<473> while (drive_get(type, bus_id, unit_id) != NULL) {\n<495> if (max_devs && unit_id >= max_devs) {\n<497> fprintf(stderr, "qemu: unit %d too big (max is %d)\n",\n<499> unit_id, max_devs - 1);\n<529> dinfo = qemu_mallocz(sizeof(*dinfo));\n<575> if (serial)\n<577> strncpy(dinfo->serial, serial, sizeof(serial));\n<579> QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n<685> if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY) {\n<687> fprintf(stderr, "qemu: readonly flag not supported for drive with this interface\n");\n<701> if (bdrv_open(dinfo->bdrv, file, bdrv_flags, drv) < 0) {\n<703> fprintf(stderr, "qemu: could not open disk image %s: %s\n",\n<705> file, strerror(errno));\n<719> return dinfo;
<1> static int decode_bdlt(uint8_t *frame, int width, int height,\n<47> if (line_ptr >= frame)\n<63> count = -count;\n<65> if (line_ptr + count > frame || src >= src_end)\n<69> memset(line_ptr, *src++, count);\n<73> line_ptr += count;
<1> static void *spapr_create_fdt_skel(const char *cpu_model,\n<141> modelname = g_strdup(cpu_model);\n<145> for (i = 0; i < strlen(modelname); i++) {\n<147> modelname[i] = toupper(modelname[i]);\n<155> spapr->cpu_model = g_strdup(modelname);\n<185> if ((index % smt) != 0) {\n<193> if (asprintf(&nodename, "%s@%x", modelname, index) < 0) {\n<195> fprintf(stderr, "Allocation failure\n");\n<197> exit(1);\n<203> _FDT((fdt_begin_node(fdt, nodename)));\n<207> free(nodename);\n<211> _FDT((fdt_property_cell(fdt, "reg", index)));\n<327> g_free(modelname);
<1> static void build_fs_mount_list(FsMountList *mounts, Error **errp)\n<11> char *line = NULL, *dash;\n<25> if (!fp) {\n<35> while (getline(&line, &n, fp) != -1) {\n<37> ret = sscanf(line, "%*u %*u %u:%u %*s %n%*s%n%c",\n<41> if (ret < 3) {\n<47> dash = strstr(line + dir_e, " - ");\n<49> if (!dash) {\n<59> if (ret < 1) {\n<65> line[dir_e] = 0;\n<67> dash[type_e] = 0;\n<69> dash[dev_e] = 0;\n<71> decode_mntname(line + dir_s, dir_e - dir_s);\n<73> decode_mntname(dash + dev_s, dev_e - dev_s);\n<75> if (devmajor == 0) {\n<79> if (strcmp("btrfs", dash + type_s) != 0 ||\n<81> dev_major_minor(dash + dev_s, &devmajor, &devminor) < 0) {\n<91> mount = g_malloc0(sizeof(FsMount));\n<93> mount->dirname = g_strdup(line + dir_s);\n<95> mount->devtype = g_strdup(dash + type_s);\n<97> mount->devmajor = devmajor;\n<99> mount->devminor = devminor;\n<103> QTAILQ_INSERT_TAIL(mounts, mount, next);\n<107> free(line);
<1> static void check_for_isn_and_int8_passing_mismatch ( ClusterInfo * cluster ) {\n<20> DbInfo * active_db = & cluster -> dbarr . dbs [ dbnum ] ;\n<21> PGconn * conn = connectToServer ( cluster , active_db -> db_name ) ;\n<27> rowno < ntups ;\n<30> if ( script == NULL && ( script = fopen_priv ( output_path , "w" ) ) == NULL ) pg_fatal ( "Could not open file \"%s\": %s\n" , output_path , getErrorText ( ) ) ;\n<31> if ( ! db_used ) {\n<32> fprintf ( script , "Database: %s\n" , active_db -> db_name ) ;\n<35> fprintf ( script , " %s.%s\n" , PQgetvalue ( res , rowno , i_nspname ) , PQgetvalue ( res , rowno , i_proname ) ) ;\n<40> if ( script ) fclose ( script ) ;
<1> static char *get_content_url(xmlNodePtr *baseurl_nodes,\n<25> memset(tmp_str, 0, sizeof(tmp_str));\n<39> if (text) {\n<41> memset(tmp_str, 0, sizeof(tmp_str));\n<43> memset(tmp_str_2, 0, sizeof(tmp_str_2));\n<45> ff_make_absolute_url(tmp_str_2, MAX_URL_SIZE, tmp_str, text);\n<67> url = av_strireplace(tmp_str, "$RepresentationID$", (const char*)rep_id_val);\n<81> if (rep_bandwidth_val && tmp_str[0] != '\0') {\n<83> url = av_strireplace(tmp_str, "$Bandwidth$", (const char*)rep_bandwidth_val);
<1> static int rm_assemble_video_frame(AVFormatContext *s, ByteIOContext *pb,\n<5> AVPacket *pkt, int len)\n<135> if(vst->slices != vst->cur_slice) //FIXME find out how to set slices correct from the begin\n<137> memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices,\n<139> vst->videobufpos - 1 - 8*vst->slices);
<11> if ( dstcmptno < dstimage -> numcmpts_ ) {\n<12> memmove ( & dstimage -> cmpts_ [ dstcmptno + 1 ] , & dstimage -> cmpts_ [ dstcmptno ] , ( dstimage -> numcmpts_ - dstcmptno ) * sizeof ( jas_image_cmpt_t * ) ) ;
<13> if (!build_state || build_state->patched) {\n<31> assert(acpi_data_len(tables.table_data) == build_state->table_size);\n<33> memcpy(build_state->table_ram, tables.table_data->data,
<1> bool id_h ( connection_t * c ) {\n<3> if ( sscanf ( c -> buffer , "%*d " MAX_STRING " %d" , name , & c -> protocol_version ) != 2 ) {\n<7> if ( ! check_id ( name ) || ! strcmp ( name , myself -> name ) ) {\n<8> logger ( LOG_ERR , "Got bad %s from %s (%s): %s" , "ID" , c -> name , c -> hostname , "invalid name" ) ;\n<9> return false ;\n<11> if ( c -> outgoing ) {\n<12> if ( strcmp ( c -> name , name ) ) {\n<13> logger ( LOG_ERR , "Peer %s is %s instead of %s" , c -> hostname , name , c -> name ) ;\n<14> return false ;\n<18> if ( c -> name ) {\n<19> free ( c -> name ) ;\n<21> c -> name = xstrdup ( name ) ;\n<23> if ( c -> protocol_version != myself -> connection -> protocol_version ) {\n<24> logger ( LOG_ERR , "Peer %s (%s) uses incompatible version %d" , c -> name , c -> hostname , c -> protocol_version ) ;\n<33> send_id ( c ) ;\n<35> return send_ack ( c ) ;\n<39> if ( ! read_connection_config ( c ) ) {\n<40> logger ( LOG_ERR , "Peer %s had unknown identity (%s)" , c -> hostname , c -> name ) ;\n<44> if ( ! read_rsa_public_key ( c ) ) {\n<49> send_id ( c ) ;\n<51> return send_metakey ( c ) ;
<1> static int rsd_read_header(AVFormatContext *s)\n<91> ff_alloc_extradata(par, 34);\n<93> if (!par->extradata)\n<97> memset(par->extradata, 0, 34);
<1> static void die ( int error_num , const char * fmt_reason , ... ) {\n<5> my_vsnprintf ( buffer , sizeof ( buffer ) , fmt_reason , args ) ;\n<7> fprintf ( stderr , "%s: %s\n" , my_progname_short , buffer ) ;\n<8> fflush ( stderr ) ;
<1> static int doTest(uint8_t *ref[4], int refStride[4], int w, int h,\n<77> if (!srcContext) {\n<145> dstContext = sws_getContext(srcW, srcH, srcFormat, dstW, dstH, dstFormat,\n<149> if (!dstContext) {\n<177> sws_scale(dstContext, src, srcStride, 0, srcH, dst, dstStride);\n<185> dstStride[i] * dstH);\n<227> if (!outContext) {
<1> static void read_object_list_from_stdin ( void ) {\n<7> if ( ! fgets ( line , sizeof ( line ) , stdin ) ) {\n<8> if ( feof ( stdin ) ) break ;\n<9> if ( ! ferror ( stdin ) ) die ( "fgets returned NULL, not EOF, not error!" ) ;\n<10> if ( errno != EINTR ) die_errno ( "fgets" ) ;\n<11> clearerr ( stdin ) ;\n<14> if ( line [ 0 ] == '-' ) {\n<15> if ( get_sha1_hex ( line + 1 , sha1 ) ) die ( "expected edge sha1, got garbage:\n %s" , line ) ;\n<19> if ( get_sha1_hex ( line , sha1 ) ) die ( "expected sha1, got garbage:\n %s" , line ) ;
<1> static uint32_t vmsvga_value_read ( void * opaque , uint32_t address ) {\n<90> printf ( "%s: Bad register %02x\n" , __func__ , s -> index ) ;
<1> static void sum_usage ( FILE * out , int count , size_t bytes , int whitelisted ) {\n<2> fprintf ( out , "Total memory usage: %zu\n" , bytes ) ;
<1> int dtls1_buffer_message ( SSL * s , int is_ccs ) {\n<6> frag = dtls1_hm_fragment_new ( s -> init_num , 0 ) ;\n<7> memcpy ( frag -> fragment , s -> init_buf -> data , s -> init_num ) ;\n<9> OPENSSL_assert ( s -> d1 -> w_msg_hdr . msg_len + ( ( s -> version == DTLS1_VERSION ) ? DTLS1_CCS_HEADER_LENGTH : 3 ) == ( unsigned int ) s -> init_num ) ;\n<12> OPENSSL_assert ( s -> d1 -> w_msg_hdr . msg_len + DTLS1_HM_HEADER_LENGTH == ( unsigned int ) s -> init_num ) ;\n<25> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<28> item = pitem_new ( seq64be , frag ) ;\n<30> dtls1_hm_fragment_free ( frag ) ;
<1> static void vtd_init(IntelIOMMUState *s)\n<5> X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n<9> memset(s->csr, 0, DMAR_REG_SIZE);\n<11> memset(s->wmask, 0, DMAR_REG_SIZE);\n<13> memset(s->w1cmask, 0, DMAR_REG_SIZE);\n<15> memset(s->womask, 0, DMAR_REG_SIZE);\n<59> vtd_reset_context_cache(s);\n<61> vtd_reset_iotlb(s);\n<67> vtd_define_long(s, DMAR_VER_REG, 0x10UL, 0, 0);\n<69> vtd_define_quad(s, DMAR_CAP_REG, s->cap, 0, 0);\n<71> vtd_define_quad(s, DMAR_ECAP_REG, s->ecap, 0, 0);\n<73> vtd_define_long(s, DMAR_GCMD_REG, 0, 0xff800000UL, 0);\n<75> vtd_define_long_wo(s, DMAR_GCMD_REG, 0xff800000UL);\n<77> vtd_define_long(s, DMAR_GSTS_REG, 0, 0, 0);\n<79> vtd_define_quad(s, DMAR_RTADDR_REG, 0, 0xfffffffffffff000ULL, 0);\n<81> vtd_define_quad(s, DMAR_CCMD_REG, 0, 0xe0000003ffffffffULL, 0);\n<83> vtd_define_quad_wo(s, DMAR_CCMD_REG, 0x3ffff0000ULL);\n<89> vtd_define_long(s, DMAR_FSTS_REG, 0, 0, 0x11UL);\n<91> vtd_define_long(s, DMAR_FECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n<93> vtd_define_long(s, DMAR_FEDATA_REG, 0, 0x0000ffffUL, 0);\n<95> vtd_define_long(s, DMAR_FEADDR_REG, 0, 0xfffffffcUL, 0);\n<105> vtd_define_long(s, DMAR_FEUADDR_REG, 0, 0, 0);\n<117> vtd_define_long(s, DMAR_PMEN_REG, 0, 0, 0);\n<121> vtd_define_quad(s, DMAR_IQH_REG, 0, 0, 0);\n<123> vtd_define_quad(s, DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n<125> vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n<127> vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n<129> vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n<131> vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n<133> vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n<137> vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n<143> vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n<145> vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n<147> vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n<153> vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n<155> vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n<165> vtd_define_quad(s, DMAR_IRTA_REG, 0, 0xfffffffffffff80fULL, 0);
<1> static uint32_t record_block_getter ( uint8_t * p , uint32_t s , Gif_Reader * grr ) {\n<2> uint32_t ncopy = ( grr -> pos + s <= grr -> length ? s : grr -> length - grr -> pos ) ;\n<3> memcpy ( p , & grr -> v [ grr -> pos ] , ncopy ) ;\n<4> grr -> pos += ncopy ;\n<5> if ( ncopy < s ) memset ( p + ncopy , 0 , s - ncopy ) ;
<14> if ( f -> fTranslit -> length > f -> fTranslit -> pos ) {\n<15> memmove ( f -> fTranslit -> buffer , f -> fTranslit -> buffer + f -> fTranslit -> pos , ( f -> fTranslit -> length - f -> fTranslit -> pos ) * sizeof ( UChar ) ) ;\n<21> if ( f -> fTranslit -> buffer == NULL ) {\n<32> u_strncpy ( f -> fTranslit -> buffer + f -> fTranslit -> length , src , * count ) ;\n<40> utrans_transIncrementalUChars ( f -> fTranslit -> translit , f -> fTranslit -> buffer , & textLength , f -> fTranslit -> capacity , & pos , & status ) ;\n<49> utrans_transUChars ( f -> fTranslit -> translit , f -> fTranslit -> buffer , & textLength , f -> fTranslit -> capacity , 0 , & textLimit , & status ) ;
<1> static void set_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) {\n<8> map . active_map = ( uint8_t * ) malloc ( map . rows * map . cols ) ;\n<10> i < map . rows * map . cols ;\n<11> ++ i ) map . active_map [ i ] = i % 2 ;\n<12> if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , "Failed to set active map" ) ;\n<13> free ( map . active_map ) ;
<1> static void vexpress_common_init(MachineState *machine)\n<225> if (!pflash0) {\n<227> fprintf(stderr, "vexpress: error registering flash 0.\n");\n<253> if (!ve_pflash_cfi01_register(map[VE_NORFLASH1], "vexpress.flash1",\n<257> fprintf(stderr, "vexpress: error registering flash 1.\n");
<1> static int parseMemoryStat ( char * * text , unsigned int tag , const char * search , virDomainMemoryStatPtr stat ) {\n<4> if ( STRPREFIX ( * text , search ) ) {\n<5> * text += strlen ( search ) ;\n<6> if ( virStrToLong_ull ( * text , & dummy , 10 , & value ) ) {\n<7> VIR_DEBUG ( "error reading %s: %s" , search , * text ) ;
<1> static gchar * rtmpt_get_amf_param ( tvbuff_t * tvb , gint offset , gint param , const gchar * prop ) {\n<19> if ( prop && iObjType == AMF0_OBJECT ) {\n<22> while ( remain > 2 ) {\n<23> guint32 iPropLength = tvb_get_ntohs ( tvb , offset ) ;\n<24> if ( remain < 2 + iPropLength + 3 ) break ;\n<25> if ( tvb_strneql ( tvb , offset + 2 , prop , strlen ( prop ) ) == 0 ) {\n<26> if ( tvb_get_guint8 ( tvb , offset + 2 + iPropLength ) != AMF0_STRING ) break ;\n<31> itemlen = rtmpt_get_amf_length ( tvb , offset + 2 + iPropLength ) ;\n<32> offset += 2 + iPropLength + itemlen ;\n<33> remain -= 2 + iPropLength + itemlen ;
<1> void cpu_loop(CPUMBState *env)\n<13> trapnr = cpu_mb_exec (env);\n<15> switch (trapnr) {\n<93> switch (env->sregs[SR_ESR] & 31) {\n<137> env->sregs[SR_ESR] & ESR_EC_MASK);\n<179> printf ("Unhandled trap: 0x%x\n", trapnr);
<1> static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,\n<43> uint64_t total_size = 0;\n<45> uint8_t *out = NULL, unit_nb, sps_done = 0;\n<49> static const uint8_t nalu_header[4] = {0, 0, 0, 1};\n<75> while (unit_nb--) {\n<81> unit_size = AV_RB16(extradata);\n<85> if (total_size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE ||\n<97> if (!tmp) {\n<105> out = tmp;\n<107> memcpy(out+total_size-unit_size-4, nalu_header, 4);\n<109> memcpy(out+total_size-unit_size,   extradata+2, unit_size);\n<111> extradata += 2+unit_size;\n<123> memset(out + total_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
<1> static void PREP_io_800_writeb ( void * opaque , uint32_t addr , uint32_t val ) {\n<4> case 0x0092 : if ( val & 0x80 ) {\n<5> printf ( "Soft reset asked... Stop emulation\n" ) ;\n<8> if ( val & 0x40 ) {\n<9> printf ( "Little Endian mode isn't supported (yet ?)\n" ) ;\n<21> case 0x0850 : if ( val & 0x80 ) {\n<22> printf ( "No support for non-continuous I/O map mode\n" ) ;
<1> static int dump_tablespaces_for_tables ( char * db , char * * table_names , int tables ) {\n<6> mysql_real_escape_string ( mysql , name_buff , db , ( ulong ) strlen ( db ) ) ;\n<11> i < tables ;\n<13> mysql_real_escape_string ( mysql , name_buff , table_names [ i ] , ( ulong ) strlen ( table_names [ i ] ) ) ;
<1> static int write_option(void *optctx, const OptionDef *po, const char *opt,\n<19> if (po->flags & OPT_SPEC) {\n<23> char *p = strchr(opt, ':');\n<31> (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : "");\n<51> *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n<55> *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n<59> *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n<63> *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n<67> *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n<71> int ret = po->u.func_arg(optctx, opt, arg);
<1> static int nb_add_values ( char * * ret_buffer , size_t * ret_buffer_len , const lcc_value_list_t * vl ) {\n<13> pkg_type = htons ( TYPE_VALUES ) ;\n<14> pkg_length = htons ( ( uint16_t ) packet_len ) ;\n<15> pkg_num_values = htons ( ( uint16_t ) vl -> values_len ) ;\n<17> i < vl -> values_len ;\n<19> pkg_values_types [ i ] = ( uint8_t ) vl -> values_types [ i ] ;\n<32> packet_ptr = * ret_buffer ;\n<33> offset = 0 ;\n<34> memcpy ( packet_ptr + offset , & pkg_type , sizeof ( pkg_type ) ) ;\n<35> offset += sizeof ( pkg_type ) ;\n<36> memcpy ( packet_ptr + offset , & pkg_length , sizeof ( pkg_length ) ) ;\n<37> offset += sizeof ( pkg_length ) ;\n<38> memcpy ( packet_ptr + offset , & pkg_num_values , sizeof ( pkg_num_values ) ) ;\n<39> offset += sizeof ( pkg_num_values ) ;\n<40> memcpy ( packet_ptr + offset , pkg_values_types , sizeof ( pkg_values_types ) ) ;\n<41> offset += sizeof ( pkg_values_types ) ;\n<42> memcpy ( packet_ptr + offset , pkg_values , sizeof ( pkg_values ) ) ;
<1> int select_watchdog(const char *p)\n<9> if (watchdog) {\n<23> if (strcmp(p, "?") == 0) {\n<25> LIST_FOREACH(model, &watchdog_list, entry) {\n<29> model->wdt_name, model->wdt_description);\n<33> return 2;\n<39> LIST_FOREACH(model, &watchdog_list, entry) {\n<41> if (strcasecmp(model->wdt_name, p) == 0) {\n<53> fprintf(stderr, "Unknown -watchdog device. Supported devices are:\n");\n<55> LIST_FOREACH(model, &watchdog_list, entry) {
<1> kadm5_ret_t kadm5_get_policy ( void * server_handle , kadm5_policy_t name , kadm5_policy_ent_t entry ) {\n<5> memset ( entry , 0 , sizeof ( * entry ) ) ;\n<8> if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n<9> if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n<10> ret = krb5_db_get_policy ( handle -> context , name , & t ) ;\n<11> if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n<12> else if ( ret ) return ret ;\n<13> if ( ( entry -> policy = strdup ( t -> name ) ) == NULL ) {\n<14> ret = ENOMEM ;\n<17> entry -> pw_min_life = t -> pw_min_life ;\n<18> entry -> pw_max_life = t -> pw_max_life ;\n<19> entry -> pw_min_length = t -> pw_min_length ;\n<20> entry -> pw_min_classes = t -> pw_min_classes ;\n<21> entry -> pw_history_num = t -> pw_history_num ;\n<22> if ( handle -> api_version >= KADM5_API_VERSION_3 ) {\n<27> if ( handle -> api_version >= KADM5_API_VERSION_4 ) {\n<31> if ( t -> allowed_keysalts ) {\n<32> entry -> allowed_keysalts = strdup ( t -> allowed_keysalts ) ;\n<33> if ( ! entry -> allowed_keysalts ) {\n<38> ret = copy_tl_data ( t -> n_tl_data , t -> tl_data , & entry -> tl_data ) ;\n<43> cleanup : if ( ret ) kadm5_free_policy_ent ( handle , entry ) ;\n<44> krb5_db_free_policy ( handle -> context , t ) ;
<1> static const uint8_t *pcx_rle_decode(const uint8_t *src,\n<5> uint8_t *dst,\n<7> unsigned int bytes_per_scanline,\n<19> if (compressed) {\n<43> memcpy(dst, src, bytes_per_scanline);\n<45> src += bytes_per_scanline;
<1> int ff_h264_build_ref_list(H264Context *h, H264SliceContext *sl)\n<155> if (i < 0) {\n<161> memset(&sl->ref_list[list][index], 0, sizeof(sl->ref_list[0][0])); // FIXME\n<183> ref_from_h264pic(&sl->ref_list[list][index], ref);\n<187> pic_as_field(&sl->ref_list[list][index], pic_structure);
<1> void hb_set_destroy ( hb_set_t * set ) {\n<2> if ( ! hb_object_destroy ( set ) ) return ;\n<4> free ( set ) ;
<1> static int blkdebug_debug_resume(BlockDriverState *bs, const char *tag)\n<11> QLIST_FOREACH(r, &s->suspended_reqs, next) {\n<13> if (!strcmp(r->tag, tag)) {\n<15> qemu_coroutine_enter(r->co, NULL);\n<17> return 0;\n<23> return -ENOENT;
<1> static int validate_nonce ( const char * pnonce , struct recvbuf * rbufp ) {\n<8> if ( 3 != sscanf ( pnonce , "%08x%08x%08x" , & ts_i , & ts_f , & supposed ) ) return FALSE ;\n<9> ts . l_ui = ( u_int32 ) ts_i ;\n<10> ts . l_uf = ( u_int32 ) ts_f ;\n<11> derived = derive_nonce ( & rbufp -> recv_srcadr , ts . l_ui , ts . l_uf ) ;\n<12> get_systime ( & now_delta ) ;\n<13> L_SUB ( & now_delta , & ts ) ;\n<14> return ( supposed == derived && now_delta . l_ui < 16 ) ;
<1> static int handle_intercept(S390CPU *cpu)\n<15> DPRINTF("intercept: 0x%x (at 0x%lx)\n", icpt_code,\n<19> switch (icpt_code) {\n<73> fprintf(stderr, "KVM unimplemented icpt SOFT\n");\n<81> fprintf(stderr, "KVM unimplemented icpt IO\n");\n<89> fprintf(stderr, "Unknown intercept code: %d\n", icpt_code);
<1> static int decode_frame_header ( ProresContext * ctx , const uint8_t * buf , const int data_size , AVCodecContext * avctx ) {\n<56> if ( flags & 2 ) {\n<57> if ( ptr - buf > hdr_size - 64 ) {\n<61> if ( memcmp ( ctx -> qmat_luma , ptr , 64 ) ) {\n<62> memcpy ( ctx -> qmat_luma , ptr , 64 ) ;\n<63> ctx -> qmat_changed = 1 ;\n<65> ptr += 64 ;\n<68> memset ( ctx -> qmat_luma , 4 , 64 ) ;\n<71> if ( flags & 1 ) {\n<72> if ( ptr - buf > hdr_size - 64 ) {\n<76> if ( memcmp ( ctx -> qmat_chroma , ptr , 64 ) ) {\n<77> memcpy ( ctx -> qmat_chroma , ptr , 64 ) ;\n<78> ctx -> qmat_changed = 1 ;\n<82> memset ( ctx -> qmat_chroma , 4 , 64 ) ;
<1> static int rv34_decode_inter_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n<11> memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n<12> fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n<19> cbp = cbp2 = rv34_decode_inter_mb_header ( r , intra_types ) ;\n<22> r -> deblock_coefs [ mb_pos ] = rv34_set_deblock_coef ( r ) | r -> cbp_luma [ mb_pos ] ;\n<26> if ( r -> is16 ) rv34_output_i16x16 ( r , intra_types , cbp ) ;\n<27> else rv34_output_intra ( r , intra_types , cbp ) ;\n<30> if ( r -> is16 ) {\n<32> memset ( block16 , 0 , 16 * sizeof ( * block16 ) ) ;\n<35> if ( rv34_decode_block ( block16 , gb , r -> cur_vlcs , 3 , 0 , q_dc , q_dc , q_ac ) ) r -> rdsp . rv34_inv_transform ( block16 ) ;\n<68> rv34_process_block ( r , dst + 4 * i , s -> linesize , r -> luma_vlc , 0 , q_ac , q_ac ) ;\n<85> rv34_process_block ( r , pdst , s -> uvlinesize , r -> chroma_vlc , 1 , q_dc , q_ac ) ;
<1> int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n<3> const uint8_t *name, uint8_t *dst, int dst_size)\n<7> int namelen = strlen(name);\n<39> if (data + size >= data_end || data + size < data)\n<45> if (size == namelen && !memcmp(data-size, name, namelen)) {\n<47> switch (*data++) {\n<79> len = ff_amf_tag_size(data, data_end);\n<81> if (len < 0 || data + len >= data_end || data + len < data)
<1> void mips_cpu_do_interrupt(CPUState *cs)\n<7> MIPSCPU *cpu = MIPS_CPU(cs);\n<9> CPUMIPSState *env = &cpu->env;\n<49> switch (cs->exception_index) {\n<129> memset(env->CP0_WatchLo, 0, sizeof(*env->CP0_WatchLo));\n<139> env->CP0_ErrorEPC = exception_resume_pc(env);\n<155> set_hflags_for_handler(env);\n<465> qemu_log("Invalid MIPS exception %d. Exiting\n", cs->exception_index);\n<467> printf("Invalid MIPS exception %d. Exiting\n", cs->exception_index);\n<473> if (qemu_log_enabled() && cs->exception_index != EXCP_EXT_INTERRUPT) {
<1> int rom_add_file(const char *file, const char *fw_dir,\n<9> rom = g_malloc0(sizeof(*rom));\n<14> fd = open(rom->path, O_RDONLY | O_BINARY);\n<16> fprintf(stderr, "Could not open option rom '%s': %s\n",\n<17> rom->path, strerror(errno));
<1> static void generate_preamble ( void ) {\n<4> char preamble [ ] = "/*\n" " * ntp_keyword.h\n" " * \n" " * NOTE: edit this file with caution, it is generated by keyword-gen.c\n" " *\t Generated %s UTC diff_ignore_line\n" " *\n" " */\n" "#include \"ntp_scanner.h\"\n" "#include \"ntp_parser.h\"\n" "\n" ;\n<6> if ( ! strftime ( timestamp , sizeof ( timestamp ) , "%Y-%m-%d %H:%M:%S" , gmtime ( & now ) ) ) timestamp [ 0 ] = '\0' ;\n<7> printf ( preamble , timestamp ) ;
<1> static char * _zip_readfpstr ( FILE * fp , unsigned int len , int nulp , struct zip_error * error ) {\n<3> r = ( char * ) malloc ( nulp ? len + 1 : len ) ;\n<4> if ( ! r ) {\n<8> if ( fread ( r , 1 , len , fp ) < len ) {\n<9> free ( r ) ;
<4> pnso -- != named_options ;\n<6> if ( ! bytes_compare ( ( const byte * ) pnso -> pname , strlen ( pnso -> pname ) , psref -> value . const_bytes , r_size ( psref ) ) ) {\n<7> * pname = pnso -> pname ;
<1> static int append_key_value ( smart_str * loc_name , HashTable * hash_arr , char * key_name ) {\n<2> zval * * ele_value = NULL ;\n<3> if ( zend_hash_find ( hash_arr , key_name , strlen ( key_name ) + 1 , ( void * * ) & ele_value ) == SUCCESS ) {\n<4> if ( Z_TYPE_PP ( ele_value ) != IS_STRING ) {\n<7> if ( strcmp ( key_name , LOC_LANG_TAG ) != 0 && strcmp ( key_name , LOC_GRANDFATHERED_LANG_TAG ) != 0 ) {\n<8> smart_str_appendl ( loc_name , SEPARATOR , sizeof ( SEPARATOR ) - 1 ) ;\n<11> return SUCCESS ;\n<13> return LOC_NOT_FOUND ;
<1> static void mspack_fmap_close ( struct mspack_file * file ) {\n<3> if ( ! mspack_handle ) return ;\n<4> if ( mspack_handle -> type == FILETYPE_FILENAME ) fclose ( mspack_handle -> f ) ;\n<5> free ( mspack_handle ) ;
<1> static int receive_header ( VirtIONet * n , struct iovec * iov , int iovcnt , const void * buf , size_t size , size_t hdr_len ) {\n<2> struct virtio_net_hdr * hdr = ( struct virtio_net_hdr * ) iov [ 0 ] . iov_base ;\n<4> hdr -> flags = 0 ;\n<5> hdr -> gso_type = VIRTIO_NET_HDR_GSO_NONE ;\n<6> if ( n -> has_vnet_hdr ) {\n<7> memcpy ( hdr , buf , sizeof ( * hdr ) ) ;\n<9> work_around_broken_dhclient ( hdr , buf + offset , size - offset ) ;
<1> static void test_truncation_option ( ) {\n<10> stmt_text = "select -1" ;\n<11> stmt = mysql_stmt_init ( mysql ) ;\n<12> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<13> check_execute ( stmt , rc ) ;\n<16> memset ( & my_bind , 0 , sizeof ( my_bind ) ) ;\n<21> rc = mysql_stmt_bind_result ( stmt , & my_bind ) ;\n<28> rc = mysql_stmt_bind_result ( stmt , & my_bind ) ;
<1> static int print_device_sinks(AVOutputFormat *fmt, AVDictionary *opts)\n<15> if (!fmt || !fmt->priv_class  || !AV_IS_OUTPUT_DEVICE(fmt->priv_class->category))\n<21> printf("Audo-detected sinks for %s:\n", fmt->name);\n<23> if (!fmt->get_device_list) {\n<27> printf("Cannot list sinks. Not implemented.\n");\n<35> if ((ret = avformat_alloc_output_context2(&dev, fmt, NULL, NULL)) < 0) {\n<37> printf("Cannot open device: %s.\n", fmt->name);\n<49> if ((ret = avdevice_list_devices(dev, &device_list)) < 0) {\n<51> printf("Cannot list sinks.\n");\n<59> for (i = 0; i < device_list->nb_devices; i++) {\n<61> printf("%s %s [%s]\n", device_list->default_device == i ? "*" : " ",
<1> static void start_new_outpacket ( int userid , char * data , int datalen ) {\n<2> datalen = MIN ( datalen , sizeof ( users [ userid ] . outpacket . data ) ) ;\n<3> memcpy ( users [ userid ] . outpacket . data , data , datalen ) ;\n<4> users [ userid ] . outpacket . len = datalen ;
<1> uint start_at_word ( char * pos ) {\n<2> return ( ( ( ! memcmp ( pos , "\\b" , 2 ) && pos [ 2 ] ) || ! memcmp ( pos , "\\^" , 2 ) ) ? 1 : 0 ) ;
<1> static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)\n<5> SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n<81> if (req->cmd.xfer > 65536) {\n<87> r->buflen = MAX(4096, req->cmd.xfer);\n<93> r->iov.iov_base = qemu_blockalign(s->qdev.conf.bs, r->buflen);\n<101> outbuf = r->iov.iov_base;\n<103> memset(outbuf, 0, r->buflen);\n<105> switch (req->cmd.buf[0]) {\n<115> buflen = scsi_disk_emulate_inquiry(req, outbuf);\n<129> buflen = scsi_disk_emulate_mode_sense(r, outbuf);\n<141> buflen = scsi_disk_emulate_read_toc(req, outbuf);\n<193> if (scsi_disk_emulate_start_stop(r) < 0) {\n<213> memset(outbuf, 0, 8);\n<219> scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n<285> buflen = scsi_emulate_mechanism_status(s, outbuf);\n<297> buflen = scsi_get_configuration(s, outbuf);\n<309> buflen = scsi_get_event_status_notification(s, r, outbuf);\n<321> buflen = scsi_read_disc_information(s, r, outbuf);\n<333> buflen = scsi_read_dvd_structure(s, r, outbuf);\n<347> if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) {\n<351> memset(outbuf, 0, req->cmd.xfer);\n<357> scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n<437> r->req.aiocb = bdrv_aio_flush(s->qdev.conf.bs, scsi_aio_complete, r);\n<479> scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));\n<525> scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n<533> r->iov.iov_len = MIN(r->buflen, req->cmd.xfer);\n<559> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n<569> scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));
<1> static int mov_read_custom(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n<7> uint8_t *key = NULL, *val = NULL, *mean = NULL;\n<103> if (mean && key && val) {\n<105> if (strcmp(key, "iTunSMPB") == 0) {\n<109> if(sscanf(val, "%*X %X %X %X", &priming, &remainder, &samples) == 3){\n<111> if(priming>0 && priming<16384)\n<113> sc->start_pad = priming;\n<119> if (strcmp(key, "cdec") != 0) {\n<121> av_dict_set(&c->fc->metadata, key, val,\n<123> AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);\n<125> key = val = NULL;\n<141> av_freep(&key);\n<143> av_freep(&val);
<1> static gpgme_error_t gpgsm_export ( void * engine , const char * pattern , gpgme_export_mode_t mode , gpgme_data_t keydata , int use_armor ) {\n<6> if ( mode ) return gpg_error ( GPG_ERR_NOT_SUPPORTED ) ;\n<7> if ( ! pattern ) pattern = "" ;\n<8> cmd = malloc ( 7 + strlen ( pattern ) + 1 ) ;\n<9> if ( ! cmd ) return gpg_error_from_syserror ( ) ;\n<10> strcpy ( cmd , "EXPORT " ) ;\n<11> strcpy ( & cmd [ 7 ] , pattern ) ;\n<14> if ( err ) return err ;\n<18> err = start ( gpgsm , cmd ) ;\n<19> free ( cmd ) ;
<1> static struct kvm_cpuid2 * try_get_cpuid ( KVMState * s , int max ) {\n<12> if ( r == - E2BIG ) {\n<17> fprintf ( stderr , "KVM_GET_SUPPORTED_CPUID failed: %s\n" , strerror ( - r ) ) ;
<1> e1000_receive(VLANClientState *nc, const uint8_t *buf, size_t size)\n<37> if (size < sizeof(min_buf)) {\n<39> memcpy(min_buf, buf, size);\n<41> memset(&min_buf[size], 0, sizeof(min_buf) - size);\n<43> buf = min_buf;\n<51> if (!receive_filter(s, buf, size))\n<57> if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n<61> memmove((uint8_t *)buf + 4, buf, 12);\n<123> cpu_physical_memory_write(le64_to_cpu(desc.buffer_addr),\n<125> (void *)(buf + desc_offset + vlan_offset),
<1> static ssize_t sdp_svc_search(struct bt_l2cap_sdp_state_s *sdp,\n<3> uint8_t *rsp, const uint8_t *req, ssize_t len)\n<27> if ((*req & ~SDP_DSIZE_MASK) == SDP_DTYPE_SEQ) {\n<29> seqlen = sdp_datalen(&req, &len);\n<41> if (sdp_svc_match(sdp, &req, &seqlen))\n<45> } else if (sdp_svc_match(sdp, &req, &seqlen))\n<55> max = (req[0] << 8) | req[1];\n<57> req += 2;\n<65> if (len <= sizeof(int))\n<71> memcpy(&start, req + 1, sizeof(int));\n<87> len = 4;\n<91> end = start;\n<97> if (count >= start && count < max && len + 4 < MAX_RSP_PARAM_SIZE) {\n<99> handle = i;\n<101> memcpy(rsp + len, &handle, 4);\n<103> len += 4;\n<117> rsp[0] = count >> 8;\n<119> rsp[1] = count & 0xff;\n<121> rsp[2] = (end - start) >> 8;\n<123> rsp[3] = (end - start) & 0xff;\n<127> if (end < count) {\n<129> rsp[len ++] = sizeof(int);\n<131> memcpy(rsp + len, &end, sizeof(int));
<1> static void dumphex ( struct hexout * hexout , FILE * temp , int length ) {\n<5> dumphex ( hexout , temp , 65534 ) ;\n<8> fprintf ( hexout -> type42 , " <\n " ) ;\n<11> i < length ;\n<13> ch = getc ( temp ) ;\n<14> if ( ch == EOF ) break ;\n<15> if ( hexout -> bytesout >= 31 ) {\n<16> fprintf ( hexout -> type42 , "\n " ) ;\n<22> putc ( ch1 , hexout -> type42 ) ;\n<26> putc ( ch1 , hexout -> type42 ) ;\n<29> fprintf ( hexout -> type42 , "\n 00\n >\n" ) ;
<1> static void test_bug2247 ( ) {\n<16> if ( ! opt_silent ) fprintf ( stdout , "\nChecking if stmt_affected_rows is not affected by\n" "mysql_query ... " ) ;\n<56> if ( ! opt_silent ) fprintf ( stdout , "OK" ) ;
<1> static void read_once_cb ( int fd , short event , void * arg ) {\n<8> else if ( len ) {\n<9> write ( pair [ 0 ] , TEST1 , strlen ( TEST1 ) + 1 ) ;
<1> int qemuMonitorTextGetPtyPaths ( qemuMonitorPtr mon , virHashTablePtr paths ) {\n<2> char * reply = NULL ;\n<4> if ( qemuMonitorHMPCommand ( mon , "info chardev" , & reply ) < 0 ) {\n<11> char * end = reply + strlen ( reply ) ;\n<12> while ( next ) {\n<14> eol = memchr ( pos , '\n' , end - pos ) ;\n<15> if ( eol == NULL ) {\n<22> while ( eol > pos && c_isspace ( * ( eol - 1 ) ) ) eol -= 1 ;\n<24> if ( ! needle ) continue ;\n<25> char * colon = memchr ( pos , ':' , needle - pos ) ;\n<26> if ( colon == NULL ) continue ;\n<28> char * id = pos ;\n<30> char * path = strdup ( needle + strlen ( NEEDLE ) ) ;\n<42> cleanup : VIR_FREE ( reply ) ;
<1> int main ( int argc , char * argv [ ] ) {\n<92> progname = get_progname ( argv [ 0 ] ) ;\n<93> if ( argc > 1 ) {\n<94> if ( strcmp ( argv [ 1 ] , "--help" ) == 0 || strcmp ( argv [ 1 ] , "-?" ) == 0 ) {\n<95> help ( ) ;\n<96> exit_nicely ( 0 ) ;\n<98> if ( strcmp ( argv [ 1 ] , "--version" ) == 0 || strcmp ( argv [ 1 ] , "-V" ) == 0 ) {\n<100> exit_nicely ( 0 ) ;\n<105> if ( find_my_exec ( argv [ 0 ] , full_path ) < 0 ) strlcpy ( full_path , progname , sizeof ( full_path ) ) ;\n<106> if ( ret == - 1 ) fprintf ( stderr , _ ( "The program \"pg_dump\" is needed by %s " "but was not found in the\n" "same directory as \"%s\".\n" "Check your installation.\n" ) , progname , full_path ) ;\n<107> else fprintf ( stderr , _ ( "The program \"pg_dump\" was found by \"%s\"\n" "but was not the same version as %s.\n" "Check your installation.\n" ) , full_path , progname ) ;\n<111> while ( ( c = getopt_long ( argc , argv , "acd:f:gh:l:oOp:rsS:tU:vwWx" , long_options , & optindex ) ) != - 1 ) {\n<112> switch ( c ) {\n<167> default : fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<171> if ( optind < argc ) {\n<172> fprintf ( stderr , _ ( "%s: too many command-line arguments (first is \"%s\")\n" ) , progname , argv [ optind ] ) ;\n<173> fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<176> if ( globals_only && roles_only ) {\n<177> fprintf ( stderr , _ ( "%s: options -g/--globals-only and -r/--roles-only cannot be used together\n" ) , progname ) ;\n<178> fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<181> if ( globals_only && tablespaces_only ) {\n<182> fprintf ( stderr , _ ( "%s: options -g/--globals-only and -t/--tablespaces-only cannot be used together\n" ) , progname ) ;\n<183> fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<186> if ( if_exists && ! output_clean ) {\n<187> fprintf ( stderr , _ ( "%s: option --if-exists requires option -c/--clean\n" ) , progname ) ;\n<190> if ( roles_only && tablespaces_only ) {\n<191> fprintf ( stderr , _ ( "%s: options -r/--roles-only and -t/--tablespaces-only cannot be used together\n" ) , progname ) ;\n<192> fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<206> conn = connectDatabase ( pgdb , connstr , pghost , pgport , pguser , prompt_password , false ) ;\n<207> if ( ! conn ) {\n<208> fprintf ( stderr , _ ( "%s: could not connect to database \"%s\"\n" ) , progname , pgdb ) ;\n<215> if ( ! conn ) {\n<216> fprintf ( stderr , _ ( "%s: could not connect to databases \"postgres\" or \"template1\"\n" "Please specify an alternative database.\n" ) , progname ) ;\n<217> fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<222> OPF = fopen ( filename , PG_BINARY_W ) ;\n<223> if ( ! OPF ) {\n<224> fprintf ( stderr , _ ( "%s: could not open the output file \"%s\": %s\n" ) , progname , filename , strerror ( errno ) ) ;\n<228> else OPF = stdout ;\n<239> fprintf ( OPF , "--\n-- PostgreSQL database cluster dump\n--\n\n" ) ;\n<274> fprintf ( OPF , "--\n-- PostgreSQL database cluster dump complete\n--\n\n" ) ;\n<275> if ( filename ) fclose ( OPF ) ;
<1> static int transcode(AVFormatContext **output_files,\n<25> char error[1024];\n<57> if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n<59> av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n<61> fprintf(stderr, "Output file #%d does not contain any stream\n", i);\n<73> if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n<75> fprintf(stderr, "Number of stream maps must match number of output streams\n");\n<91> int si = stream_maps[i].stream_index;\n<95> if (fi < 0 || fi > nb_input_files - 1 ||\n<97> si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n<99> fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si);\n<109> si = stream_maps[i].sync_stream_index;\n<111> if (fi < 0 || fi > nb_input_files - 1 ||\n<113> si < 0 || si > input_files[fi].ctx->nb_streams - 1) {\n<115> fprintf(stderr,"Could not find sync stream #%d.%d\n", fi, si);\n<217> ost = ost_table[n] = output_streams_for_file[k][i];\n<229> if (input_streams[ost->source_index].st->codec->codec_type != ost->st->codec->codec_type) {\n<231> int i= ost->file_index;\n<235> fprintf(stderr, "Codec type mismatch for mapping #%d.%d -> #%d.%d\n",\n<327> if (!found) {\n<329> int i= ost->file_index;\n<333> fprintf(stderr, "Could not find input stream matching output stream #%d.%d\n",\n<373> codec = ost->st->codec;\n<375> icodec = ist->st->codec;\n<397> uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n<437> if (!codec->extradata)\n<441> memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n<443> codec->extradata_size= icodec->extradata_size;\n<449> if(!strcmp(os->oformat->name, "avi")) {\n<451> if(!copy_tb && av_q2d(icodec->time_base)*icodec->ticks_per_frame > 2*av_q2d(ist->st->time_base) && av_q2d(ist->st->time_base) < 1.0/500){\n<461> } else if(!(os->oformat->flags & AVFMT_VARIABLE_FPS)) {\n<483> if(audio_volume != 256) {\n<485> fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");\n<629> if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n<631> fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");\n<751> f = fopen(logfilename, "wb");\n<753> if (!f) {\n<755> fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));\n<769> if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n<771> fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);\n<791> bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n<801> bit_buffer = av_malloc(bit_buffer_size);\n<803> if (!bit_buffer) {\n<805> fprintf(stderr, "Cannot allocate %d bytes output buffer\n",\n<827> AVCodecContext *dec = input_streams[ost->source_index].st->codec;\n<829> if (!codec) {\n<831> snprintf(error, sizeof(error), "Encoder (codec id %d) not found for output stream #%d.%d",\n<843> ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n<845> if (!ost->st->codec->subtitle_header) {\n<853> memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<855> ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n<859> if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n<861> snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",\n<871> assert_codec_experimental(ost->st->codec, 1);\n<899> if (!codec)\n<903> if (!codec) {\n<905> snprintf(error, sizeof(error), "Decoder (codec id %d) not found for input stream #%d.%d",\n<915> if (avcodec_open2(ist->st->codec, codec, &ist->opts) < 0) {\n<917> snprintf(error, sizeof(error), "Error while opening decoder for input stream #%d.%d",\n<977> snprintf(error, sizeof(error), "Invalid %s index %d while processing metadata maps\n",\\n<1091> snprintf(error, sizeof(error), "Invalid input file index %d in chapter mapping.\n", infile);\n<1101> snprintf(error, sizeof(error), "Invalid output file index %d in chapter mapping.\n",outfile);\n<1145> if (avformat_write_header(os, &output_opts[i]) < 0) {\n<1147> snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);\n<1157> if (strcmp(output_files[i]->oformat->name, "rtp")) {\n<1159> want_sdp = 0;\n<1183> if (verbose >= 0) {\n<1185> fprintf(stderr, "Stream mapping:\n");\n<1187> for(i=0;i<nb_ostreams;i++) {\n<1189> ost = ost_table[i];\n<1201> if (ost->sync_ist != &input_streams[ost->source_index])\n<1209> fprintf(stderr, "\n");\n<1217> if (ret) {\n<1219> fprintf(stderr, "%s\n", error);\n<1237> if(verbose >= 0)\n<1239> fprintf(stderr, "Press [q] to stop, [?] for help\n");\n<1311> if (key == 'd' || key == 'D'){\n<1313> int debug=0;\n<1315> if(key == 'D') {\n<1319> if(!debug) debug = 1;\n<1321> while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n<1323> debug += debug;\n<1327> scanf("%d", &debug);\n<1331> input_streams[i].st->codec->debug = debug;\n<1339> ost->st->codec->debug = debug;\n<1345> fprintf(stderr,"debug=%d\n", debug);\n<1349> if (key == '?'){\n<1389> ist = &input_streams[ost->source_index];\n<1391> if(ist->is_past_recording_time || no_packet[ist->file_index])\n<1405> if(input_sync ) file_index = ist->file_index;\n<1413> if(!input_sync) file_index = ist->file_index;\n<1433> if(no_packet_count){\n<1437> memset(no_packet, 0, sizeof(no_packet));\n<1467> no_packet[file_index]=1;\n<1475> if (ret < 0) {\n<1493> memset(no_packet, 0, sizeof(no_packet));\n<1603> if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n<1607> if (verbose >= 0)\n<1609> fprintf(stderr, "Error while decoding stream #%d.%d\n",\n<1647> output_packet(ist, i, ost_table, nb_ostreams, NULL);\n<1687> avcodec_close(ost->st->codec);\n<1753> av_freep(&ost->st->codec->subtitle_header);\n<1773> av_free(ost);
<1> void clean_comment_data ( char * buffer ) {\n<4> y = ( int ) strlen ( buffer ) ;\n<6> x < y ;
<1> static int parse_frame_header ( AC3DecodeContext * s ) {\n<29> if ( hdr . bitstream_id <= 10 ) {\n<39> memset ( s -> channel_uses_aht , 0 , sizeof ( s -> channel_uses_aht ) ) ;\n<40> return ac3_parse_header ( s ) ;
<1> static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n<23> if (av_strstart(url, "crypto", NULL)) {\n<25> if (url[6] == '+' || url[6] == ':')\n<35> proto_name = avio_find_protocol_name(url);\n<47> if (!av_strstart(proto_name, "http", NULL) && !av_strstart(proto_name, "file", NULL))\n<51> if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n<55> else if (av_strstart(url, "crypto", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n<59> else if (strcmp(proto_name, "file") || !strncmp(url, "file,", 5))\n<61> return AVERROR_INVALIDDATA;\n<65> ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n<67> if (ret >= 0) {\n<97> av_dict_free(&tmp);\n<101> if (is_http)\n<103> *is_http = av_strstart(proto_name, "http", NULL);\n<107> return ret;
<1> static int ioescapestopped ( IO * wrapper , struct psstack * stack , int sp , const size_t bsize ) {\n<2> _IO * io = wrapper -> top , * iop ;\n<4> while ( io -> prev != NULL ) {\n<7> if ( io -> start != NULL ) free ( io -> start ) ;\n<8> io -> start = NULL ;\n<9> free ( io ) ;\n<18> io = iop ;
<1> static void json_print_str ( WriterContext * wctx , const char * key , const char * value ) {\n<2> JSONContext * json = wctx -> priv ;\n<3> if ( wctx -> nb_item [ wctx -> level ] ) printf ( "%s" , json -> item_sep ) ;
<1> static void test_bug3796 ( ) {\n<4> const char * concat_arg0 = "concat_with_" ;\n<8> char out_buff [ OUT_BUFF_SIZE ] ;\n<14> stmt_text = "DROP TABLE IF EXISTS t1" ;\n<15> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<17> stmt_text = "CREATE TABLE t1 (a INT, b VARCHAR(30))" ;\n<18> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<20> stmt_text = "INSERT INTO t1 VALUES(1, 'ONE'), (2, 'TWO')" ;\n<21> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<23> stmt = mysql_stmt_init ( mysql ) ;\n<24> stmt_text = "SELECT concat(?, b) FROM t1" ;\n<25> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<26> check_execute ( stmt , rc ) ;\n<27> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<30> my_bind [ 0 ] . buffer_length = strlen ( concat_arg0 ) ;\n<31> mysql_stmt_bind_param ( stmt , my_bind ) ;\n<39> if ( ! opt_silent ) printf ( "Concat result: '%s'\n" , out_buff ) ;\n<41> strmov ( canonical_buff , concat_arg0 ) ;\n<42> strcat ( canonical_buff , "ONE" ) ;\n<43> DIE_UNLESS ( strlen ( canonical_buff ) == out_length && strncmp ( out_buff , canonical_buff , out_length ) == 0 ) ;\n<46> strmov ( canonical_buff + strlen ( concat_arg0 ) , "TWO" ) ;\n<47> DIE_UNLESS ( strlen ( canonical_buff ) == out_length && strncmp ( out_buff , canonical_buff , out_length ) == 0 ) ;\n<48> if ( ! opt_silent ) printf ( "Concat result: '%s'\n" , out_buff ) ;\n<52> stmt_text = "DROP TABLE IF EXISTS t1" ;\n<53> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static int vmstate_subsection_load(QEMUFile *f, const VMStateDescription *vmsd,\n<7> while (qemu_peek_byte(f, 0) == QEMU_VM_SUBSECTION) {\n<9> char idstr[256];\n<19> len = qemu_peek_byte(f, 1);\n<21> if (len < strlen(vmsd->name) + 1) {\n<25> return 0;\n<29> size = qemu_peek_buffer(f, (uint8_t *)idstr, len, 2);\n<31> if (size != len) {\n<37> idstr[size] = 0;\n<41> if (strncmp(vmsd->name, idstr, strlen(vmsd->name)) != 0) {\n<45> return 0;\n<49> sub_vmsd = vmstate_get_subsection(vmsd->subsections, idstr);\n<51> if (sub_vmsd == NULL) {
<1> static int init_image(TiffContext *s)\n<105> if (s->palette_is_set) {\n<107> memcpy(s->picture.data[1], s->palette, sizeof(s->palette));
<1> int test_exp ( BIO * bp , BN_CTX * ctx ) {\n<31> if ( ! BN_is_zero ( e ) ) {\n<32> fprintf ( stderr , "Exponentiation test failed!\n" ) ;
<1> static int32_t u_printf_hex_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n<8> ufmt_64tou ( result , & len , num , 16 , ( UBool ) ( info -> fSpec == 0x0078 ) , ( info -> fPrecision == - 1 && info -> fZero ) ? info -> fWidth : info -> fPrecision ) ;\n<9> if ( num != 0 && info -> fAlt && len < UPRINTF_BUFFER_SIZE - 2 ) {\n<10> memmove ( result + 2 , result , len * sizeof ( UChar ) ) ;\n<15> return handler -> pad_and_justify ( context , info , result , len ) ;
<1> GList * completion_get_channels ( SERVER_REC * server , const char * word ) {\n<5> g_return_val_if_fail ( word != NULL , NULL ) ;\n<6> len = strlen ( word ) ;\n<13> if ( g_ascii_strncasecmp ( rec -> visible_name , word , len ) == 0 ) list = g_list_append ( list , g_strdup ( rec -> visible_name ) ) ;\n<20> if ( g_ascii_strncasecmp ( rec -> name , word , len ) == 0 && glist_find_icase_string ( list , rec -> name ) == NULL ) list = g_list_append ( list , g_strdup ( rec -> name ) ) ;
<1> static int targa_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<27> if ((ret = ff_alloc_packet(pkt, picsize + 45)) < 0) {\n<39> memset(pkt->data, 0, 12);\n<41> AV_WL16(pkt->data+12, avctx->width);\n<43> AV_WL16(pkt->data+14, avctx->height);\n<51> switch(avctx->pix_fmt) {\n<99> out = pkt->data + 18;  /* skip past the header we just output */\n<139> out += datasize;\n<149> memcpy(out, "\0\0\0\0\0\0\0\0TRUEVISION-XFILE.", 26);\n<153> pkt->size   = out + 26 - pkt->data;
<1> static void bamboo_init(ram_addr_t ram_size,\n<65> success = load_uimage(kernel_filename, &entry, &loadaddr, NULL);\n<69> success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<81> if (success < 0) {\n<83> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<99> initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n<105> if (initrd_size < 0) {\n<107> fprintf(stderr, "qemu: could not load ram disk '%s' at %x\n",\n<123> if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n<127> fprintf(stderr, "couldn't load device tree\n");
<1> static ssize_t usbnet_receive(VLANClientState *nc, const uint8_t *buf, size_t size)\n<11> if (is_rndis(s)) {\n<13> msg = (struct rndis_packet_msg_type *) s->in_buf;\n<19> if (size + sizeof(struct rndis_packet_msg_type) > sizeof(s->in_buf))\n<25> memset(msg, 0, sizeof(struct rndis_packet_msg_type));\n<27> msg->MessageType = cpu_to_le32(RNDIS_PACKET_MSG);\n<29> msg->MessageLength = cpu_to_le32(size + sizeof(struct rndis_packet_msg_type));\n<31> msg->DataOffset = cpu_to_le32(sizeof(struct rndis_packet_msg_type) - 8);\n<33> msg->DataLength = cpu_to_le32(size);\n<51> memcpy(msg + 1, buf, size);\n<53> s->in_len = size + sizeof(struct rndis_packet_msg_type);\n<57> if (size > sizeof(s->in_buf))\n<61> memcpy(s->in_buf, buf, size);\n<63> s->in_len = size;\n<69> return size;
<1> callback(void *priv_data, int index, uint8_t *buf, int buf_size, int64_t time)\n<35> if(av_new_packet(&pktl_next->pkt, buf_size) < 0) {\n<49> memcpy(pktl_next->pkt.data, buf, buf_size);\n<57> ctx->curbufsize[index] += buf_size;
<1> static void opt_output_file(const char *filename)\n<11> AVFormatParameters params, *ap = &params;\n<17> if (!strcmp(filename, "-"))\n<19> filename = "pipe:";\n<27> print_error(filename, AVERROR(ENOMEM));\n<37> file_oformat = av_guess_format(last_asked_format, NULL, NULL);\n<39> if (!file_oformat) {\n<41> fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format);\n<51> file_oformat = av_guess_format(NULL, filename, NULL);\n<53> if (!file_oformat) {\n<55> fprintf(stderr, "Unable to find a suitable output format for '%s'\n",\n<69> av_strlcpy(oc->filename, filename, sizeof(oc->filename));\n<73> if (!strcmp(file_oformat->name, "ffm") &&\n<75> av_strstart(filename, "http:", NULL)) {\n<81> int err = read_ffserver_streams(oc, filename);\n<83> if (err < 0) {\n<85> print_error(filename, err);\n<93> use_video = file_oformat->video_codec != CODEC_ID_NONE || video_stream_copy || video_codec_name;\n<95> use_audio = file_oformat->audio_codec != CODEC_ID_NONE || audio_stream_copy || audio_codec_name;\n<97> use_subtitle = file_oformat->subtitle_codec != CODEC_ID_NONE || subtitle_stream_copy || subtitle_codec_name;\n<105> if (nb_input_files > 0) {\n<129> if (audio_disable) {\n<135> if (video_disable) {\n<141> if (subtitle_disable) {\n<149> if (use_video) {\n<157> if (use_audio) {\n<165> if (use_subtitle) {\n<173> oc->timestamp = recording_timestamp;\n<177> for(; metadata_count>0; metadata_count--){\n<185> av_metadata_conv(oc, oc->oformat->metadata_conv, NULL);\n<199> if (!av_filename_number_test(oc->filename)) {\n<201> print_error(oc->filename, AVERROR_NUMEXPECTED);\n<215> if (!file_overwrite &&\n<217> (strchr(filename, ':') == NULL ||\n<219> filename[1] == ':' ||\n<221> av_strstart(filename, "file:", NULL))) {\n<223> if (url_exist(filename)) {\n<225> if (!using_stdin) {\n<227> fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", filename);\n<229> fflush(stderr);\n<231> if (!read_yesno()) {\n<233> fprintf(stderr, "Not overwriting - exiting\n");\n<243> fprintf(stderr,"File '%s' already exists. Exiting.\n", filename);\n<257> if ((err = url_fopen(&oc->pb, filename, URL_WRONLY)) < 0) {\n<269> memset(ap, 0, sizeof(*ap));\n<271> if (av_set_parameters(oc, ap) < 0) {\n<273> fprintf(stderr, "%s: Invalid encoding parameters\n",\n<293> set_context_opts(oc, avformat_opts, AV_OPT_FLAG_ENCODING_PARAM, NULL);
<1> static int tcp_set_msgfds(CharDriverState *chr, int *fds, int num)\n<5> TCPCharDriver *s = chr->opaque;\n<15> if (num) {\n<17> s->write_msgfds = g_malloc(num * sizeof(int));\n<19> memcpy(s->write_msgfds, fds, num * sizeof(int));
<1> static int load_bitmap_header ( struct bitmap_index * index ) {\n<2> struct bitmap_disk_header * header = ( void * ) index -> map ;\n<3> if ( index -> map_size < sizeof ( * header ) + 20 ) return error ( "Corrupted bitmap index (missing header data)" ) ;\n<4> if ( memcmp ( header -> magic , BITMAP_IDX_SIGNATURE , sizeof ( BITMAP_IDX_SIGNATURE ) ) != 0 ) return error ( "Corrupted bitmap index file (wrong header)" ) ;\n<5> index -> version = ntohs ( header -> version ) ;\n<6> if ( index -> version != 1 ) return error ( "Unsupported version for bitmap index file (%d)" , index -> version ) ;
<7> VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n<29> if (s->cmd_vrings) {\n<31> for (i = 0; i < vs->conf.num_queues && s->cmd_vrings[i]; i++) {\n<39> free(s->cmd_vrings);
<1> static void test_decode ( struct stream_state * stream , enum TestDecodeFatality fatal , const VpxInterface * codec ) {\n<3> if ( stream -> mismatch_seen ) return ;\n<4> if ( strcmp ( codec -> name , "vp8" ) == 0 ) {\n<7> width = ( stream -> config . cfg . g_w + 15 ) & ~ 15 ;\n<8> height = ( stream -> config . cfg . g_h + 15 ) & ~ 15 ;\n<9> vpx_img_alloc ( & ref_enc . img , VPX_IMG_FMT_I420 , width , height , 1 ) ;\n<10> enc_img = ref_enc . img ;\n<11> vpx_img_alloc ( & ref_dec . img , VPX_IMG_FMT_I420 , width , height , 1 ) ;\n<12> dec_img = ref_dec . img ;\n<13> ref_enc . frame_type = VP8_LAST_FRAME ;\n<14> ref_dec . frame_type = VP8_LAST_FRAME ;\n<15> vpx_codec_control ( & stream -> encoder , VP8_COPY_REFERENCE , & ref_enc ) ;\n<16> vpx_codec_control ( & stream -> decoder , VP8_COPY_REFERENCE , & ref_dec ) ;\n<20> ref_enc . idx = 0 ;\n<21> ref_dec . idx = 0 ;\n<22> vpx_codec_control ( & stream -> encoder , VP9_GET_REFERENCE , & ref_enc ) ;\n<23> enc_img = ref_enc . img ;\n<24> vpx_codec_control ( & stream -> decoder , VP9_GET_REFERENCE , & ref_dec ) ;\n<25> dec_img = ref_dec . img ;\n<37> ctx_exit_on_error ( & stream -> encoder , "Failed to get encoder reference frame" ) ;\n<38> ctx_exit_on_error ( & stream -> decoder , "Failed to get decoder reference frame" ) ;\n<39> if ( ! compare_img ( & enc_img , & dec_img ) ) {\n<56> stream -> mismatch_seen = stream -> frames_out ;
<1> static int mdb_get_nextid ( MDB_cursor * mci , ID * cursor ) {\n<6> key . mv_data = & id ;\n<7> key . mv_size = sizeof ( ID ) ;\n<9> if ( rc ) return rc ;\n<10> memcpy ( cursor , key . mv_data , sizeof ( ID ) ) ;
<1> static uint16_t eepro100_read2(EEPRO100State * s, uint32_t addr)\n<7> if (addr <= sizeof(s->mem) - sizeof(val)) {\n<9> memcpy(&val, &s->mem[addr], sizeof(val));\n<21> TRACE(OTHER, logout("addr=%s val=0x%04x\n", regname(addr), val));\n<29> TRACE(OTHER, logout("addr=%s val=0x%04x\n", regname(addr), val));\n<35> logout("addr=%s val=0x%04x\n", regname(addr), val);\n<41> return val;
<1> static int check_k_link ( MI_CHECK * param , register MI_INFO * info , uint nr ) {\n<8> DBUG_PRINT ( "enter" , ( "block_size: %u" , block_size ) ) ;\n<9> if ( param -> testflag & T_VERBOSE ) printf ( "block_size %4u:" , block_size ) ;\n<11> records = ( ha_rows ) ( info -> state -> key_file_length / block_size ) ;\n<14> if ( param -> testflag & T_VERBOSE ) printf ( "%16s" , llstr ( next_link , llbuff ) ) ;\n<32> if ( next_link != HA_OFFSET_ERROR ) printf ( "%16s\n" , llstr ( next_link , llbuff ) ) ;
<1> static void http_badreq_readcb ( struct bufferevent * bev , void * arg ) {\n<2> const char * what = "Hello, 127.0.0.1" ;\n<3> const char * bad_request = "400 Bad Request" ;\n<5> if ( evbuffer_find ( bev -> input , ( const unsigned char * ) bad_request , strlen ( bad_request ) ) != NULL ) {\n<12> if ( evbuffer_find ( bev -> input , ( const unsigned char * ) what , strlen ( what ) ) != NULL ) {
<1> static void auth_delay ( struct parse * pcmd , FILE * fp ) {\n<4> if ( pcmd -> nargs == 0 ) {\n<5> val = delay_time . l_ui * 1000 + delay_time . l_uf / 4294967 ;\n<6> ( void ) fprintf ( fp , "delay %lu ms\n" , val ) ;
<1> void qtest_qmpv_discard_response(QTestState *s, const char *fmt, va_list ap)\n<37> if (len == -1 || len == 0) {\n<39> fprintf(stderr, "Broken pipe\n");
<1> static int isofile_hd_cmp_node ( const struct archive_rb_node * n1 , const struct archive_rb_node * n2 ) {\n<4> return ( strcmp ( archive_entry_pathname ( h1 -> file_list . first -> entry ) , archive_entry_pathname ( h2 -> file_list . first -> entry ) ) ) ;
<1> static int ass_get_duration(const uint8_t *p)\n<11> if (sscanf(p, "%*[^,],%d:%d:%d%*c%d,%d:%d:%d%*c%d",\n<15> return 0;\n<17> start = 3600000*sh + 60000*sm + 1000*ss + 10*sc;\n<19> end   = 3600000*eh + 60000*em + 1000*es + 10*ec;\n<21> return end - start;
<1> rfbClientIteratorPtr rfbGetClientIteratorWithClosed ( rfbScreenInfoPtr rfbScreen ) {\n<2> rfbClientIteratorPtr i = ( rfbClientIteratorPtr ) malloc ( sizeof ( struct rfbClientIterator ) ) ;\n<6> return i ;
<1> static int usbredir_handle_interrupt_data(USBRedirDevice *dev,\n<3> USBPacket *p, uint8_t ep)\n<45> if (intp == NULL) {\n<79> if (len > p->len) {\n<89> memcpy(p->data, intp->data, len);\n<91> bufp_free(dev, intp, ep);\n<93> return len;
<1> static void usbredir_buffered_bulk_packet(void *priv, uint64_t id,\n<5> uint8_t *data, int data_len)\n<9> USBRedirDevice *dev = priv;\n<25> if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_BULK) {\n<29> free(data);\n<37> if (dev->endpoint[EP2I(ep)].bulk_receiving_started == 0) {\n<41> free(data);\n<51> len = dev->endpoint[EP2I(ep)].max_packet_size;\n<53> status = usb_redir_success;\n<55> free_on_destroy = NULL;\n<57> for (i = 0; i < data_len; i += len) {\n<59> if (len >= (data_len - i)) {\n<61> len = data_len - i;\n<63> status = buffered_bulk_packet->status;\n<65> free_on_destroy = data;\n<71> bufp_alloc(dev, data + i, len, status, ep, free_on_destroy);\n<77> if (dev->endpoint[EP2I(ep)].pending_async_packet) {\n<83> usbredir_buffered_bulk_in_complete(dev, p, ep);
<1> static int create_dynamic_disk(BlockBackend *blk, uint8_t *buf,\n<41> ret = blk_pwrite(blk, offset, buf, HEADER_SIZE);\n<43> if (ret < 0) {\n<57> memset(buf, 0xFF, 512);\n<59> for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {\n<61> ret = blk_pwrite(blk, offset, buf, 512);\n<77> memset(buf, 0, 1024);\n<81> memcpy(dyndisk_header->magic, "cxsparse", 8);\n<105> dyndisk_header->checksum = cpu_to_be32(vpc_checksum(buf, 1024));
<1> static int qemu_rdma_connect(RDMAContext *rdma, Error **errp)\n<41> cap.flags |= RDMA_CAPABILITY_PIN_ALL;\n<47> caps_to_network(&cap);\n<81> if (cm_event->event != RDMA_CM_EVENT_ESTABLISHED) {\n<97> memcpy(&cap, cm_event->param.conn.private_data, sizeof(cap));\n<99> network_to_caps(&cap);\n<111> if (rdma->pin_all && !(cap.flags & RDMA_CAPABILITY_PIN_ALL)) {
<52> if (av_new_packet(pkt, length + MM_PREAMBLE_SIZE))\n<56> memcpy(pkt->data, preamble, MM_PREAMBLE_SIZE);
<1> static int isofile_register_hardlink ( struct archive_write * a , struct isofile * file ) {\n<7> if ( pathname == NULL ) {\n<8> hl = malloc ( sizeof ( * hl ) ) ;\n<9> if ( hl == NULL ) {
<1> static int ram_save_setup(QEMUFile *f, void *opaque)\n<23> if (migrate_use_xbzrle()) {\n<65> if (!XBZRLE.current_buf) {\n<103> qemu_put_be64(f, ram_bytes_total() | RAM_SAVE_FLAG_MEM_SIZE);\n<107> QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n<109> qemu_put_byte(f, strlen(block->idstr));\n<111> qemu_put_buffer(f, (uint8_t *)block->idstr, strlen(block->idstr));
<1> static const char *srt_to_ass(AVCodecContext *avctx, char *out, char *out_end,\n<3> const char *in, int x1, int y1, int x2, int y2)\n<7> char c, *param, buffer[128], tmp[128];\n<9> int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n<11> SrtStack stack[16];\n<41> for (; out < out_end && !end && *in; in++) {\n<43> switch (*in) {\n<81> an += sscanf(in, "{\\an%*1u}%c", &c) == 1;\n<83> if ((an != 1 && sscanf(in, "{\\%*[^}]}%n%c", &len, &c) > 0) ||\n<85> sscanf(in, "{%*1[CcFfoPSsYy]:%*[^}]}%n%c", &len, &c) > 0) {\n<87> in += len - 1;\n<91> *out++ = *in;\n<97> tag_close = in[1] == '/';\n<99> if (sscanf(in+tag_close+1, "%127[^>]>%n%c", buffer, &len,&c) >= 2) {\n<101> if ((param = strchr(buffer, ' ')))\n<103> *param++ = 0;\n<105> if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack)) ||\n<107> ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, buffer))) {\n<109> int i, j, unknown = 0;\n<111> in += len + tag_close;\n<113> if (!tag_close)\n<115> memset(stack+sptr, 0, sizeof(*stack));\n<117> if (!strcmp(buffer, "font")) {\n<119> if (tag_close) {\n<123> if (stack[sptr-1].param[i][0])\n<125> for (j=sptr-2; j>=0; j--)\n<139> while (param) {\n<141> if (!strncmp(param, "size=", 5)) {\n<145> param += 5 + (param[5] == '"');\n<147> if (sscanf(param, "%u", &font_size) == 1) {\n<149> snprintf(stack[sptr].param[PARAM_SIZE],\n<151> sizeof(stack[0].param[PARAM_SIZE]),\n<159> param += 6 + (param[6] == '"');\n<167> html_color_parse(avctx, param));\n<169> } else if (!strncmp(param, "face=", 5)) {\n<171> param += 5 + (param[5] == '"');\n<175> param[-1] == '"' ? "\"" :" ");\n<179> FFMIN(sizeof(tmp), len+1));\n<181> param += len;\n<191> if ((param = strchr(param, ' ')))\n<193> param++;\n<207> } else if (!buffer[1] && strspn(buffer, "bisu") == 1) {\n<209> out += snprintf(out, out_end-out,\n<211> "{\\%c%d}", buffer[0], !tag_close);\n<215> unknown = 1;\n<217> snprintf(tmp, sizeof(tmp), "</%s>", buffer);\n<221> if (tag_close) {\n<223> sptr--;\n<225> } else if (unknown && !strstr(in, tmp)) {\n<227> in -= len + tag_close;\n<229> *out++ = *in;\n<233> av_strlcpy(stack[sptr++].tag, buffer,\n<235> sizeof(stack[0].tag));\n<245> *out++ = *in;
<1> void xmlrpc_process ( char * buffer , void * userdata ) {\n<7> char * * av = NULL ;\n<8> char * name = NULL ;\n<10> if ( ! buffer ) {\n<14> tmp = xmlrpc_parse ( buffer ) ;\n<16> name = xmlrpc_method ( tmp ) ;\n<18> xml = mowgli_patricia_retrieve ( XMLRPCCMD , name ) ;\n<20> ac = xmlrpc_split_buf ( tmp , & av ) ;\n<22> retVal = xml -> func ( userdata , ac , av ) ;\n<26> retVal = current -> func ( userdata , ac , av ) ;\n<54> free ( av ) ;\n<55> free ( tmp ) ;\n<56> free ( name ) ;
<1> int qemu_peek_buffer(QEMUFile *f, uint8_t *buf, int size, size_t offset)\n<11> assert(!qemu_file_is_writable(f));\n<17> pending = f->buf_size - index;\n<21> qemu_fill_buffer(f);\n<25> pending = f->buf_size - index;\n<31> if (pending <= 0) {\n<37> if (size > pending) {\n<39> size = pending;\n<45> memcpy(buf, f->buf + index, size);\n<47> return size;
<1> static void _slurm_rpc_persist_init ( slurm_msg_t * msg , connection_arg_t * arg ) {\n<13> if ( ! validate_slurm_user ( uid ) ) {\n<14> memset ( & p_tmp , 0 , sizeof ( slurm_persist_conn_t ) ) ;\n<23> persist_conn = xmalloc ( sizeof ( slurm_persist_conn_t ) ) ;\n<24> persist_conn -> auth_cred = msg -> auth_cred ;\n<26> persist_conn -> cluster_name = persist_init -> cluster_name ;\n<28> persist_conn -> fd = arg -> newsockfd ;\n<30> persist_conn -> callback_proc = _process_persist_conn ;\n<31> persist_conn -> persist_type = persist_init -> persist_type ;\n<32> persist_conn -> rem_port = persist_init -> port ;\n<34> slurm_get_ip_str ( & arg -> cli_addr , & port , persist_conn -> rem_host , sizeof ( char ) * 16 ) ;\n<35> persist_conn -> shutdown = & slurmctld_config . shutdown_time ;\n<36> persist_conn -> version = persist_init -> version ;\n<37> memcpy ( & p_tmp , persist_conn , sizeof ( slurm_persist_conn_t ) ) ;\n<38> if ( persist_init -> persist_type == PERSIST_TYPE_FED ) rc = fed_mgr_add_sibling_conn ( persist_conn , & comment ) ;\n<40> end_it : ret_buf = slurm_persist_make_rc_msg ( & p_tmp , rc , comment , p_tmp . version ) ;\n<41> if ( slurm_persist_send_msg ( & p_tmp , ret_buf ) != SLURM_SUCCESS ) {\n<42> debug ( "Problem sending response to connection %d uid(%d)" , p_tmp . fd , uid ) ;\n<44> if ( rc && persist_conn ) {
<1> static int sofalizer_convolute(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)\n<23> float *temp_src = td->temp_src[jobnr];\n<85> const float *const bptr = buffer[l];\n<111> read = (wr - *(delay + l) - (n_samples - 1) + buffer_length) & modulo;\n<115> if (read + n_samples < buffer_length) {\n<117> memcpy(temp_src, bptr + read, n_samples * sizeof(*temp_src));\n<121> int len = FFMIN(n_samples - (read % n_samples), buffer_length - read);\n<125> memcpy(temp_src, bptr + read, len * sizeof(*temp_src));\n<127> memcpy(temp_src + len, bptr, (n_samples - len) * sizeof(*temp_src));\n<135> dst[0] += s->fdsp->scalarproduct_float(temp_ir, temp_src, n_samples);
<1> static MachineClass *machine_parse(const char *name)\n<24> if (name && !is_help_option(name)) {\n<32> printf("Supported machines are:\n");\n<36> for (el = machines; el; el = el->next) {\n<38> MachineClass *mc = el->data;\n<40> if (mc->alias) {\n<42> printf("%-20s %s (alias of %s)\n", mc->alias, mc->desc, mc->name);
<1> static void prom_init ( hwaddr addr , const char * bios_name ) {\n<13> filename = qemu_find_file ( QEMU_FILE_TYPE_BIOS , bios_name ) ;\n<24> if ( ret < 0 || ret > PROM_SIZE_MAX ) {\n<25> fprintf ( stderr , "qemu: could not load prom '%s'\n" , bios_name ) ;
<1> static int vdi_check(BlockDriverState *bs, BdrvCheckResult *res,\n<29> bmap = g_try_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n<31> if (s->header.blocks_in_image && bmap == NULL) {\n<41> memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n<57> if (!VDI_IS_ALLOCATED(bmap[bmap_entry])) {\n<99> g_free(bmap);
<1> static int load_textfile(AVFilterContext *ctx)\n<5> DrawTextContext *s = ctx->priv;\n<15> if ((err = av_file_map(s->textfile, &textbuf, &textbuf_size, 0, ctx)) < 0) {\n<29> if (!(s->text = av_realloc(s->text, textbuf_size + 1)))\n<33> memcpy(s->text, textbuf, textbuf_size);\n<37> av_file_unmap(textbuf, textbuf_size);
<1> Const * make_greater_string ( const Const * str_const , FmgrInfo * ltproc , Oid collation ) {\n<8> if ( datatype == NAMEOID ) {\n<9> workstr = DatumGetCString ( DirectFunctionCall1 ( nameout , str_const -> constvalue ) ) ;\n<10> len = strlen ( workstr ) ;\n<13> else if ( datatype == BYTEAOID ) {\n<16> workstr = ( char * ) palloc ( len ) ;\n<17> memcpy ( workstr , VARDATA ( bstr ) , len ) ;\n<22> workstr = TextDatumGetCString ( str_const -> constvalue ) ;\n<23> len = strlen ( workstr ) ;\n<24> if ( lc_collate_is_c ( collation ) || len == 0 ) cmpstr = str_const -> constvalue ;\n<37> cmptxt = ( text * ) palloc ( VARHDRSZ + len + 1 ) ;\n<38> SET_VARSIZE ( cmptxt , VARHDRSZ + len + 1 ) ;\n<39> memcpy ( VARDATA ( cmptxt ) , workstr , len ) ;\n<40> * ( VARDATA ( cmptxt ) + len ) = suffixchar ;\n<46> while ( len > 0 ) {\n<50> else charlen = len - pg_mbcliplen ( workstr , len , len - 1 ) ;\n<51> lastchar = ( unsigned char * ) ( workstr + len - charlen ) ;\n<54> if ( datatype == BYTEAOID ) workstr_const = string_to_bytea_const ( workstr , len ) ;\n<55> else workstr_const = string_to_const ( workstr , datatype ) ;\n<68> pfree ( workstr ) ;
<1> static BlockDriverAIOCB *iscsi_aio_ioctl(BlockDriverState *bs,\n<23> acb = qemu_aio_get(&iscsi_aiocb_info, bs, cb, opaque);\n<41> acb->task = malloc(sizeof(struct scsi_task));\n<43> if (acb->task == NULL) {\n<55> memset(acb->task, 0, sizeof(struct scsi_task));\n<85> memcpy(&acb->task->cdb[0], acb->ioh->cmdp, acb->ioh->cmd_len);\n<133> if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,
<1> static int flic_read_packet(AVFormatContext *s,\n<27> if ((ret = get_buffer(pb, preamble, FLIC_PREAMBLE_SIZE)) !=\n<39> size = LE_32(&preamble[0]);\n<41> magic = LE_16(&preamble[4]);\n<47> if (av_new_packet(pkt, size)) {\n<59> memcpy(pkt->data, preamble, FLIC_PREAMBLE_SIZE);\n<61> ret = get_buffer(pb, pkt->data + FLIC_PREAMBLE_SIZE,\n<63> size - FLIC_PREAMBLE_SIZE);\n<67> av_free_packet(pkt);
<1> x509_cert_t * x509_cert_gen ( certificate_type_t type , va_list args ) {\n<53> while ( enumerator -> enumerate ( enumerator , & uri ) ) {\n<54> cert -> ocsp_uris -> insert_last ( cert -> ocsp_uris , strdup ( uri ) ) ;
<1> static uint16_t * build_pow_table ( float gamma , int length ) {\n<3> uint16_t * output = malloc ( sizeof ( uint16_t ) * length ) ;\n<4> if ( ! output ) return NULL ;
<1> int http_hdr_print ( HdrHeap * heap , HTTPHdrImpl * hdr , char * buf , int bufsize , int * bufindex , int * dumpoffset ) {\n<7> if ( hdr -> u . req . m_ptr_method == nullptr ) {\n<10> if ( ( buf != nullptr ) && ( * dumpoffset == 0 ) && ( bufsize - * bufindex >= hdr -> u . req . m_len_method + 1 ) ) {\n<11> p = buf + * bufindex ;\n<12> memcpy ( p , hdr -> u . req . m_ptr_method , hdr -> u . req . m_len_method ) ;\n<13> p += hdr -> u . req . m_len_method ;\n<15> * bufindex += hdr -> u . req . m_len_method + 1 ;
<1> int qemu_global_option(const char *str)\n<5> char driver[64], property[64];\n<13> rc = sscanf(str, "%63[^.].%63[^=]%n", driver, property, &offset);\n<15> if (rc < 2 || str[offset] != '=') {\n<17> error_report("can't parse: \"%s\"", str);\n<27> qemu_opt_set(opts, "driver", driver);\n<29> qemu_opt_set(opts, "property", property);\n<31> qemu_opt_set(opts, "value", str+offset+1);
<1> QEMUFile *qemu_popen_cmd(const char *command, const char *mode)\n<11> if (mode == NULL || (mode[0] != 'r' && mode[0] != 'w') || mode[1] != 0) {\n<13> fprintf(stderr, "qemu_popen: Argument validity check failed\n");
<1> static void *file_ram_alloc(RAMBlock *block,\n<41> if (kvm_enabled() && !kvm_has_sync_mmu()) {\n<43> fprintf(stderr, "host lacks kvm mmu notifiers, -mem-path unsupported\n");\n<115> if (area == MAP_FAILED) {\n<127> if (mem_prealloc) {\n<137> memset(&act, 0, sizeof(act));\n<145> ret = sigaction(SIGBUS, &act, &oldact);\n<167> if (sigsetjmp(sigjump, 1)) {\n<169> fprintf(stderr, "file_ram_alloc: failed to preallocate pages\n");\n<179> for (i = 0; i < (memory/hpagesize)-1; i++) {\n<181> memset(area + (hpagesize*i), 0, 1);
<1> static void rfbProcessClientProtocolVersion ( rfbClientPtr cl ) {\n<4> if ( ( n = rfbReadExact ( cl , pv , sz_rfbProtocolVersionMsg ) ) <= 0 ) {\n<10> pv [ sz_rfbProtocolVersionMsg ] = 0 ;\n<11> if ( sscanf ( pv , rfbProtocolVersionFormat , & major_ , & minor_ ) != 2 ) {\n<12> rfbErr ( "rfbProcessClientProtocolVersion: not a valid RFB client: %s\n" , pv ) ;\n<13> rfbCloseClient ( cl ) ;\n<14> return ;\n<16> rfbLog ( "Client Protocol Version %d.%d\n" , major_ , minor_ ) ;\n<17> if ( major_ != rfbProtocolMajorVersion ) {\n<18> rfbErr ( "RFB protocol version mismatch - server %d.%d, client %d.%d" , cl -> screen -> protocolMajorVersion , cl -> screen -> protocolMinorVersion , major_ , minor_ ) ;\n<22> cl -> protocolMajorVersion = major_ ;\n<23> cl -> protocolMinorVersion = minor_ ;\n<24> rfbLog ( "Protocol version sent %d.%d, using %d.%d\n" , major_ , minor_ , rfbProtocolMajorVersion , cl -> protocolMinorVersion ) ;
<1> static unsigned long ulong_arg ( const char * option , const char * arg ) {\n<3> unsigned long rv = strtoul ( arg , & endptr , 0 ) ;\n<4> if ( strchr ( arg , '-' ) || endptr == arg || * endptr ) die ( "%s: argument must be a non-negative integer" , option ) ;
<1> static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n<49> MOVDref *dref = &sc->drefs[i];\n<159> avio_read(pb, dref->path, len);\n<161> if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {\n<163> len -= volume_len;\n<165> memmove(dref->path, dref->path+volume_len, len);\n<167> dref->path[len] = 0;\n<171> for (j = 0; j < len; j++)\n<173> if (dref->path[j] == ':')\n<175> dref->path[j] = '/';\n<177> av_log(c->fc, AV_LOG_DEBUG, "path %s\n", dref->path);
<1> static void start_packfile ( void ) {\n<7> pack_fd = odb_mkstemp ( tmp_file , sizeof ( tmp_file ) , "pack/tmp_pack_XXXXXX" ) ;\n<8> namelen = strlen ( tmp_file ) + 2 ;\n<9> p = xcalloc ( 1 , sizeof ( * p ) + namelen ) ;\n<10> xsnprintf ( p -> pack_name , namelen , "%s" , tmp_file ) ;
<1> static void std_conv_pixmap ( fz_context * ctx , fz_pixmap * dst , fz_pixmap * src , fz_colorspace * prf , const fz_default_colorspaces * default_cs , const fz_color_params * color_params , int copy_spots ) {\n<14> unsigned char * s = src -> samples ;\n<15> unsigned char * d = dst -> samples ;\n<19> dstn = ds -> n ;\n<100> unsigned char dummy = s [ 0 ] ^ 255 ;\n<101> unsigned char * sold = & dummy ;\n<104> lookup = fz_new_hash_table ( ctx , 509 , srcn , - 1 , NULL ) ;\n<109> while ( ww -- ) {\n<110> if ( * s == * sold && memcmp ( sold , s , srcn ) == 0 ) {\n<111> sold = s ;\n<112> memcpy ( d , dold , dstn ) ;\n<113> d += dstn ;\n<114> s += srcn ;\n<115> if ( da ) * d ++ = ( sa ? * s : 255 ) ;\n<116> s += sa ;\n<119> sold = s ;\n<120> dold = d ;\n<121> color = fz_hash_find ( ctx , lookup , s ) ;\n<122> if ( color ) {\n<123> memcpy ( d , color , dstn ) ;\n<124> s += srcn ;\n<125> d += dstn ;\n<126> if ( da ) * d ++ = ( sa ? * s : 255 ) ;\n<127> s += sa ;\n<131> k < srcn ;\n<135> k < dstn ;\n<137> fz_hash_insert ( ctx , lookup , s - srcn , d - dstn ) ;\n<138> if ( da ) * d ++ = ( sa ? * s : 255 ) ;\n<139> s += sa ;\n<143> d += d_line_inc ;\n<144> s += s_line_inc ;
<1> ssize_t pcnet_receive ( NetClientState * nc , const uint8_t * buf , size_t size_ ) {\n<4> uint8_t buf1 [ 60 ] ;\n<7> size_t size = size_ ;\n<8> if ( CSR_DRX ( s ) || CSR_STOP ( s ) || CSR_SPND ( s ) || ! size || ( CSR_LOOP ( s ) && ! s -> looptest ) ) {\n<13> memcpy ( buf1 , buf , size ) ;\n<14> memset ( buf1 + size , 0 , MIN_BUF_SIZE - size ) ;\n<15> buf = buf1 ;
<1> static int create_vorbis_context(vorbis_enc_context *venc,\n<43> vorbis_enc_codebook *cb = &venc->codebooks[book];\n<65> if (!cb->lens || !cb->codewords)\n<69> memcpy(cb->lens, cvectors[book].clens, cvectors[book].len);\n<71> memset(cb->lens + cvectors[book].len, 0, cb->nentries - cvectors[book].len);\n<95> if ((ret = ready_codebook(cb)) < 0)\n<129> static const int a[] = {0, 1, 2, 2, 3, 3, 4, 4};\n<229> rc = &venc->residues[0];\n<245> if (!rc->books)\n<275> memcpy(rc->books, a, sizeof a);\n<279> if ((ret = ready_residue(rc, venc)) < 0)
<1> static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n<31> for (ent = qdict_first(dict); ent;\n<35> arg_name = qdict_entry_key(ent);\n<41> if (!strcmp(arg_name, "execute")) {\n<43> if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n<55> } else if (!strcmp(arg_name, "arguments")) {\n<57> if (qobject_type(arg_obj) != QTYPE_QDICT) {\n<69> error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n<71> return NULL;
<1> int acl_getroot ( THD * thd , USER_RESOURCES * mqh , const char * passwd , uint passwd_len ) {\n<5> Security_context * sctx = thd -> security_ctx ;\n<14> i < acl_users . elements ;\n<15> i ++ ) {\n<17> if ( ! acl_user_tmp -> user || ! strcmp ( sctx -> user , acl_user_tmp -> user ) ) {\n<18> if ( compare_hostname ( & acl_user_tmp -> host , sctx -> host , sctx -> ip ) ) {\n<21> acl_user = acl_user_tmp ;
<1> static void test_sshort_bug ( ) {\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<36> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<40> if ( ! opt_silent ) {\n<41> fprintf ( stdout , "\n sshort : %d (%ld)" , short_value , s_length ) ;\n<42> fprintf ( stdout , "\n slong : %ld (%ld)" , ( long ) long_value , l_length ) ;\n<43> fprintf ( stdout , "\n longlong : %s (%ld)" , llstr ( longlong_value , llbuf ) , ll_length ) ;\n<44> fprintf ( stdout , "\n tinyint : %d (%ld)" , tiny_value , t_length ) ;\n<46> DIE_UNLESS ( short_value == - 5999 ) ;\n<47> DIE_UNLESS ( s_length == 2 ) ;\n<49> DIE_UNLESS ( l_length == 4 ) ;\n<51> DIE_UNLESS ( ll_length == 8 ) ;\n<52> DIE_UNLESS ( tiny_value == 200 ) ;\n<53> DIE_UNLESS ( t_length == 1 ) ;
<1> static void r2d_init(ram_addr_t ram_size, int vga_ram_size,\n<33> if (!env) {\n<35> fprintf(stderr, "Unable to find CPU definition\n");\n<99> kernel_size = load_image(kernel_filename, phys_ram_base);\n<103> if (kernel_size < 0) {\n<105> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> hb_shape_plan_t * hb_shape_plan_create ( hb_face_t * face , const hb_segment_properties_t * props , const hb_feature_t * user_features , unsigned int num_user_features , const char * const * shaper_list ) {\n<4> hb_feature_t * features = NULL ;\n<6> if ( unlikely ( ! props ) ) return hb_shape_plan_get_empty ( ) ;\n<7> if ( num_user_features && ! ( features = ( hb_feature_t * ) malloc ( num_user_features * sizeof ( hb_feature_t ) ) ) ) return hb_shape_plan_get_empty ( ) ;\n<8> if ( ! ( shape_plan = hb_object_create < hb_shape_plan_t > ( ) ) ) {\n<9> free ( features ) ;\n<18> shape_plan -> user_features = features ;\n<19> if ( num_user_features ) memcpy ( features , user_features , num_user_features * sizeof ( hb_feature_t ) ) ;\n<20> hb_shape_plan_plan ( shape_plan , user_features , num_user_features , shaper_list ) ;
<1> PCIBus *pci_get_bus_devfn(int *devfnp, PCIBus *root, const char *devaddr)\n<15> if (!root) {\n<17> fprintf(stderr, "No primary PCI bus\n");\n<43> if (dom != 0) {\n<45> fprintf(stderr, "No support for non-zero PCI domains\n");
<1> static void generate_noise(G723_1_Context *p)\n<85> vector_ptr = p->audio + LPC_ORDER;\n<89> PITCH_MAX * sizeof(*p->excitation));\n<91> for (i = 0; i < SUBFRAMES; i += 2) {\n<93> ff_g723_1_gen_acb_excitation(vector_ptr, vector_ptr,\n<113> t |= FFABS(vector_ptr[j]);\n<137> t      = vector_ptr[j] << -shift;\n<149> t      = vector_ptr[j] >> shift;\n<223> vector_ptr[pos[idx]] = av_clip_int16(vector_ptr[pos[idx]] +\n<235> sizeof(*vector_ptr) * SUBFRAME_LEN * 2);\n<237> vector_ptr += SUBFRAME_LEN * 2;\n<243> memcpy(p->prev_excitation, p->audio + LPC_ORDER + FRAME_LEN,\n<245> PITCH_MAX * sizeof(*p->excitation));
<1> static void DoMatTransform ( int tok , int sp , struct psstack * stack ) {\n<6> t [ 5 ] = stack [ sp ] . u . dict . entries [ 5 ] . u . val ;\n<7> t [ 4 ] = stack [ sp ] . u . dict . entries [ 4 ] . u . val ;\n<8> t [ 3 ] = stack [ sp ] . u . dict . entries [ 3 ] . u . val ;\n<9> t [ 2 ] = stack [ sp ] . u . dict . entries [ 2 ] . u . val ;\n<10> t [ 1 ] = stack [ sp ] . u . dict . entries [ 1 ] . u . val ;\n<11> t [ 0 ] = stack [ sp ] . u . dict . entries [ 0 ] . u . val ;\n<13> if ( tok == pt_itransform || tok == pt_idtransform ) {\n<14> MatInverse ( invt , t ) ;\n<15> memcpy ( t , invt , sizeof ( t ) ) ;\n<17> stack [ sp - 2 ] . u . val = t [ 0 ] * x + t [ 1 ] * y ;\n<18> stack [ sp - 1 ] . u . val = t [ 2 ] * x + t [ 3 ] * y ;\n<20> stack [ sp - 2 ] . u . val += t [ 4 ] ;\n<21> stack [ sp - 1 ] . u . val += t [ 5 ] ;
<1> static void virtio_crypto_get_config(VirtIODevice *vdev, uint8_t *config)\n<5> VirtIOCrypto *c = VIRTIO_CRYPTO(vdev);\n<45> memcpy(config, &crypto_cfg, c->config_size);
<1> static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n<9> !strcmp(pkt->data, "GAB2") && AV_RL16(pkt->data + 5) == 2) {\n<23> AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n<25> pkt->size - 7,\n<53> avio_rl32(pb);   /* data size */\n<57> size = pb->buf_end - pb->buf_ptr;\n<59> pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n<63> if (!pd.buf)\n<67> memcpy(pd.buf, pb->buf_ptr, size);\n<69> sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n<71> av_freep(&pd.buf);\n<79> if (!(ast->sub_ctx = avformat_alloc_context()))\n<85> ast->sub_ctx->pb = pb;\n<111> ast->sub_buffer = pkt->data;\n<113> memset(pkt, 0, sizeof(*pkt));\n<121> av_freep(&pb);
<1> static int parse_audio_var ( AVFormatContext * avctx , AVStream * st , const char * name , int size ) {\n<4> if ( ! strcmp ( name , "__DIR_COUNT" ) ) {\n<5> st -> nb_frames = var_read_int ( pb , size ) ;\n<7> else if ( ! strcmp ( name , "AUDIO_FORMAT" ) ) {\n<8> mv -> aformat = var_read_int ( pb , size ) ;\n<10> else if ( ! strcmp ( name , "COMPRESSION" ) ) {\n<11> mv -> acompression = var_read_int ( pb , size ) ;\n<13> else if ( ! strcmp ( name , "DEFAULT_VOL" ) ) {\n<14> var_read_metadata ( avctx , name , size ) ;\n<16> else if ( ! strcmp ( name , "NUM_CHANNELS" ) ) {\n<17> return set_channels ( avctx , st , var_read_int ( pb , size ) ) ;\n<19> else if ( ! strcmp ( name , "SAMPLE_RATE" ) ) {\n<20> st -> codecpar -> sample_rate = var_read_int ( pb , size ) ;\n<21> avpriv_set_pts_info ( st , 33 , 1 , st -> codecpar -> sample_rate ) ;\n<23> else if ( ! strcmp ( name , "SAMPLE_WIDTH" ) ) {\n<24> st -> codecpar -> bits_per_coded_sample = var_read_int ( pb , size ) * 8 ;\n<26> else return AVERROR_INVALIDDATA ;\n<27> return 0 ;
<1> void kadmin_renameprinc ( int argc , char * argv [ ] ) {\n<4> char * ocanon = NULL , * ncanon = NULL ;\n<6> if ( ! ( argc == 3 || ( argc == 4 && ! strcmp ( "-force" , argv [ 1 ] ) ) ) ) {\n<7> fprintf ( stderr , _ ( "usage: rename_principal [-force] old_principal " "new_principal\n" ) ) ;\n<8> return ;\n<10> retval = kadmin_parse_name ( argv [ argc - 2 ] , & oprinc ) ;\n<11> if ( retval ) {\n<20> retval = krb5_unparse_name ( context , oprinc , & ocanon ) ;\n<25> retval = krb5_unparse_name ( context , nprinc , & ncanon ) ;\n<30> if ( argc == 3 ) {\n<31> printf ( _ ( "Are you sure you want to rename the principal \"%s\" " "to \"%s\"? (yeso): " ) , ocanon , ncanon ) ;\n<32> fgets ( reply , sizeof ( reply ) , stdin ) ;\n<33> if ( strcmp ( "yes\n" , reply ) ) {\n<34> fprintf ( stderr , _ ( "Principal \"%s\" not renamed\n" ) , ocanon ) ;\n<38> retval = kadm5_rename_principal ( handle , oprinc , nprinc ) ;\n<39> if ( retval ) {\n<40> com_err ( "rename_principal" , retval , _ ( "while renaming principal \"%s\" to \"%s\"" ) , ocanon , ncanon ) ;\n<43> printf ( _ ( "Principal \"%s\" renamed to \"%s\".\n" ) , ocanon , ncanon ) ;\n<44> printf ( _ ( "Make sure that you have removed the old principal from all ACLs " "before reusing.\n" ) ) ;\n<45> cleanup : krb5_free_principal ( context , nprinc ) ;\n<46> krb5_free_principal ( context , oprinc ) ;\n<47> free ( ncanon ) ;\n<48> free ( ocanon ) ;
<1> static int arm_cpu_env_flags ( int * flags ) {\n<3> env = getenv ( "VPX_SIMD_CAPS" ) ;\n<4> if ( env && * env ) {
<1> static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n<5> const uint8_t *buf, int len, uint16_t seq,\n<19> if (!len) {\n<35> assert(buf);\n<47> switch (type) {\n<53> av_new_packet(pkt, len + sizeof(start_sequence));\n<55> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<57> memcpy(pkt->data + sizeof(start_sequence), buf, len);\n<101> src     += 2;\n<107> if (nal_size <= src_len) {\n<109> if (pass == 0) {\n<119> assert(dst);\n<121> memcpy(dst, start_sequence, sizeof(start_sequence));\n<123> dst += sizeof(start_sequence);\n<125> memcpy(dst, src, nal_size);\n<127> COUNT_NAL_TYPE(data, *src);\n<129> dst += nal_size;\n<145> src     += nal_size;\n<147> src_len -= nal_size;\n<243> buf++;\n<245> len--;\n<253> if (start_bit) {\n<257> av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);\n<259> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<261> pkt->data[sizeof(start_sequence)] = reconstructed_nal;\n<263> memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);\n<267> av_new_packet(pkt, len);\n<269> memcpy(pkt->data, buf, len);
<1> static void pc_init1(MachineState *machine,\n<129> if (xen_enabled() && xen_hvm_init(&below_4g_mem_size, &above_4g_mem_size,\n<133> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> static void check_native_list(QObject *qobj,\n<105> for (i = 0; i < 32; i++) {\n<111> gchar str[8];\n<119> sprintf(str, "%d", i);
<1> int net_client_init(const char *device, const char *p)\n<17> char *name = NULL;\n<33> if (get_param_value(buf, sizeof(buf), "name", p)) {\n<35> name = strdup(buf);\n<39> if (!strcmp(device, "nic")) {\n<51> int idx = nic_get_free_idx();\n<55> if (check_params(nic_params, p) < 0) {\n<57> fprintf(stderr, "qemu: invalid parameter in '%s'\n", p);\n<63> if (idx == -1 || nb_nics >= MAX_NICS) {\n<65> fprintf(stderr, "Too Many NICs\n");\n<93> if (parse_macaddr(macaddr, buf) < 0) {\n<95> fprintf(stderr, "invalid syntax for ethernet address\n");\n<105> if (get_param_value(buf, sizeof(buf), "model", p)) {\n<107> nd->model = strdup(buf);\n<113> nd->name = name;\n<117> name = NULL;\n<127> if (!strcmp(device, "none")) {\n<129> if (*p != '\0') {\n<131> fprintf(stderr, "qemu: 'none' takes no parameters\n");\n<283> if (!strcmp(device, "tap")) {\n<285> char ifname[64];\n<287> char setup_script[1024], down_script[1024];\n<291> vlan->nb_host_devs++;\n<293> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<295> if (check_params(fd_params, p) < 0) {\n<297> fprintf(stderr, "qemu: invalid parameter in '%s'\n", p);\n<307> net_tap_fd_init(vlan, device, name, fd);\n<319> if (check_params(tap_params, p) < 0) {\n<321> fprintf(stderr, "qemu: invalid parameter in '%s'\n", p);\n<345> ret = net_tap_init(vlan, device, name, ifname, setup_script, down_script);\n<353> if (!strcmp(device, "socket")) {\n<355> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<359> if (check_params(fd_params, p) < 0) {\n<361> fprintf(stderr, "qemu: invalid parameter in '%s'\n", p);\n<371> if (net_socket_fd_init(vlan, device, name, fd, 1))\n<383> if (check_params(listen_params, p) < 0) {\n<385> fprintf(stderr, "qemu: invalid parameter in '%s'\n", p);\n<391> ret = net_socket_listen_init(vlan, device, name, buf);\n<401> if (check_params(connect_params, p) < 0) {\n<403> fprintf(stderr, "qemu: invalid parameter in '%s'\n", p);\n<409> ret = net_socket_connect_init(vlan, device, name, buf);\n<411> } else if (get_param_value(buf, sizeof(buf), "mcast", p) > 0) {\n<419> if (check_params(mcast_params, p) < 0) {\n<421> fprintf(stderr, "qemu: invalid parameter in '%s'\n", p);\n<427> ret = net_socket_mcast_init(vlan, device, name, buf);\n<431> fprintf(stderr, "Unknown socket options: %s\n", p);\n<507> if (!strcmp(device, "dump")) {\n<509> int len = 65536;\n<513> if (get_param_value(buf, sizeof(buf), "len", p) > 0) {\n<519> if (!get_param_value(buf, sizeof(buf), "file", p)) {\n<525> ret = net_dump_init(vlan, device, name, buf, len);\n<529> fprintf(stderr, "Unknown network device: %s\n", device);\n<531> ret = -1;\n<537> if (ret < 0) {\n<539> fprintf(stderr, "Could not initialize device '%s'\n", device);\n<545> if (name)\n<547> free(name);\n<549> return ret;
<1> static char *qemu_rbd_array_opts(QDict *options, const char *prefix, int type,\n<85> host = qemu_opt_get(opts, "host");\n<93> if (port) {\n<97> if (strchr(host, ':')) {\n<99> strbuf = g_strdup_printf("[%s]:%s", host, port);\n<103> strbuf = g_strdup_printf("%s:%s", host, port);\n<109> } else if (strchr(host, ':')) {\n<111> strbuf = g_strdup_printf("[%s]", host);\n<113> value = strbuf;
<1> static sig_handler signal_handler ( int sig ) {\n<4> fprintf ( stderr , "Writing a core file...\n" ) ;\n<5> fflush ( stderr ) ;
<1> static int userauth_hostbased ( struct ssh * ssh ) {\n<9> if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( "%s: packet parsing: %s" , __func__ , ssh_err ( r ) ) ;\n<10> debug ( "%s: cuser %s chost %s pkalg %s slen %zu" , __func__ , cuser , chost , pkalg , slen ) ;\n<15> logit ( "%s: unsupported public key algorithm: %s" , __func__ , pkalg ) ;\n<18> if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n<23> error ( "%s: cannot decode key: %s" , __func__ , pkalg ) ;\n<34> if ( match_pattern_list ( pkalg , options . hostbased_key_types , 0 ) != 1 ) {\n<43> if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 || ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> user ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , "hostbased" ) ) != 0 || ( r = sshbuf_put_string ( b , pkalg , alen ) ) != 0 || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 || ( r = sshbuf_put_cstring ( b , chost ) ) != 0 || ( r = sshbuf_put_cstring ( b , cuser ) ) != 0 ) fatal ( "%s: buffer error: %s" , __func__ , ssh_err ( r ) ) ;\n<47> if ( PRIVSEP ( hostbased_key_allowed ( authctxt -> pw , cuser , chost , key ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , pkalg , ssh -> compat ) ) == 0 ) authenticated = 1 ;\n<52> free ( pkalg ) ;\n<53> free ( pkblob ) ;\n<54> free ( cuser ) ;\n<55> free ( chost ) ;\n<56> free ( sig ) ;
<1> static int curl_open(BlockDriverState *bs, QDict *options, int flags)\n<5> BDRVCURLState *s = bs->opaque;\n<53> if ((s->readahead_size & 0x1ff) != 0) {\n<55> fprintf(stderr, "HTTP_READAHEAD_SIZE %zd is not a multiple of 512\n",\n<95> if (!state)\n<109> if (curl_easy_perform(state->curl))\n<119> else if(!s->len)\n<159> fprintf(stderr, "CURL: Error opening file: %s\n", state->errmsg);
<1> void RECORD_LAYER_reset_write_sequence ( RECORD_LAYER * rl ) {\n<2> memset ( rl -> write_sequence , 0 , sizeof ( rl -> write_sequence ) ) ;
<1> void *qemu_malloc(size_t size)\n<5> if (!size && !allow_zero_malloc()) {\n<11> return oom_check(malloc(size ? size : 1));
<1> static void test_multiplesignal ( void ) {\n<9> memset ( & itv , 0 , sizeof ( itv ) ) ;\n<11> if ( setitimer ( ITIMER_REAL , & itv , NULL ) == - 1 ) goto skip_simplesignal ;
<1> static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,\n<7> PNGEncContext *s = avctx->priv_data;\n<93> ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);\n<95> if (ret < 0)\n<101> memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);\n<103> pkt->size = s->last_frame_packet_size;\n<115> s->bytestream       = s->last_frame_packet;\n<155> uint8_t* last_fctl_chunk_start = pkt->data;\n<201> if (!s->prev_frame) {\n<217> if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)\n<227> memcpy(s->prev_frame->data[0], s->last_frame->data[0],\n<229> s->last_frame->linesize[0] * s->last_frame->height);\n<237> for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {\n<239> size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;\n<241> memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);
<1> static void monitor_find_completion(const char *cmdline)\n<19> parse_cmdline(cmdline, &nb_args, args);\n<37> len = strlen(cmdline);\n<39> if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n<49> if (nb_args <= 1) {\n<55> cmdname = "";\n<59> cmdname = args[0];\n<61> readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n<65> cmd_completion(cmdname, cmd->name);\n<73> for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n<75> if (compare_cmd(args[0], cmd->name))\n<101> str = args[nb_args - 1];\n<109> switch(*ptype) {\n<115> readline_set_completion_index(cur_mon->rs, strlen(str));\n<117> file_completion(str);\n<125> readline_set_completion_index(cur_mon->rs, strlen(str));\n<127> bdrv_iterate(block_completion_it, (void *)str);\n<135> if (!strcmp(cmd->name, "info")) {\n<137> readline_set_completion_index(cur_mon->rs, strlen(str));\n<139> for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n<141> cmd_completion(str, cmd->name);\n<145> } else if (!strcmp(cmd->name, "sendkey")) {\n<147> char *sep = strrchr(str, '-');\n<149> if (sep)\n<151> str = sep + 1;\n<153> readline_set_completion_index(cur_mon->rs, strlen(str));\n<155> for(key = key_defs; key->name != NULL; key++) {\n<157> cmd_completion(str, key->name);\n<161> } else if (!strcmp(cmd->name, "help|?")) {\n<163> readline_set_completion_index(cur_mon->rs, strlen(str));\n<165> for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n<167> cmd_completion(str, cmd->name);
<1> static gboolean is_all_button_text ( const char * button_text ) {\n<2> g_assert ( button_text != NULL ) ;\n<3> return ! strcmp ( button_text , SKIP_ALL ) || ! strcmp ( button_text , REPLACE_ALL ) || ! strcmp ( button_text , DELETE_ALL ) || ! strcmp ( button_text , MERGE_ALL ) ;
<57> i < avctx -> channels ;\n<58> i ++ ) memcpy ( frame -> extended_data [ i ] , s -> channel [ i ] . out , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) ) ;\n<60> i < avctx -> channels ;\n<62> memcpy ( & s -> channel [ i ] . out [ 0 ] , & s -> channel [ i ] . out [ s -> samples_per_frame ] , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) >> 1 ) ;
<1> static void qemu_add_data_dir(const char *path)\n<9> if (path == NULL) {\n<15> if (data_dir_idx == ARRAY_SIZE(data_dir)) {\n<21> for (i = 0; i < data_dir_idx; i++) {\n<23> if (strcmp(data_dir[i], path) == 0) {\n<25> return; /* duplicate */\n<31> data_dir[data_dir_idx++] = path;
<1> static void mips_jazz_init(MachineState *machine,\n<69> if (cpu == NULL) {\n<71> fprintf(stderr, "Unable to find CPU definition\n");\n<283> for (n = 0; n < nb_nics; n++) {\n<285> nd = &nd_table[n];\n<287> if (!nd->model)\n<289> nd->model = g_strdup("dp83932");\n<291> if (strcmp(nd->model, "dp83932") == 0) {\n<293> qemu_check_nic_model(nd, "dp83932");\n<297> dev = qdev_create(NULL, "dp8393x");\n<299> qdev_set_nic_properties(dev, nd);\n<301> qdev_prop_set_uint8(dev, "it_shift", 2);\n<303> qdev_prop_set_ptr(dev, "dma_mr", rc4030_dma_mr);\n<305> qdev_init_nofail(dev);\n<307> sysbus = SYS_BUS_DEVICE(dev);\n<309> sysbus_mmio_map(sysbus, 0, 0x80001000);\n<311> sysbus_mmio_map(sysbus, 1, 0x8000b000);\n<313> sysbus_connect_irq(sysbus, 0, qdev_get_gpio_in(rc4030, 4));\n<317> } else if (is_help_option(nd->model)) {\n<319> fprintf(stderr, "qemu: Supported NICs: dp83932\n");\n<325> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd->model);\n<347> if (drive_get_max_bus(IF_FLOPPY) >= MAX_FD) {\n<349> fprintf(stderr, "qemu: too many floppy drives\n");
<1> static int gdb_get_spe_reg(CPUState *env, uint8_t *mem_buf, int n)\n<29> if (n == 34) {\n<33> memset(mem_buf, 0, 4);
<5> USBDevice *usb_host_device_open(const char *devname)\n<25> if (strstr(devname, "auto:")) {\n<27> if (parse_filter(devname+5, &filter) < 0)\n<33> if ((p = strchr(devname, '.'))) {\n<35> filter.bus_num = strtoul(devname, NULL, 0);\n<37> filter.addr    = strtoul(devname, NULL, 0);\n<39> } else if ((p = strchr(devname, ':'))) {\n<41> filter.vendor_id  = strtoul(devname, NULL, 16);\n<43> filter.product_id = strtoul(devname, NULL, 16);\n<55> qdev_prop_set_uint32(&dev->qdev, "bus",       filter.bus_num);\n<57> qdev_prop_set_uint32(&dev->qdev, "addr",      filter.addr);\n<59> qdev_prop_set_uint32(&dev->qdev, "vendorid",  filter.vendor_id);\n<61> qdev_prop_set_uint32(&dev->qdev, "productid", filter.product_id);\n<63> qdev_init(&dev->qdev);\n<65> return dev;\n<71> qdev_free(&dev->qdev);\n<73> return NULL;
<1> static afs_int32 addWildCards ( struct ubik_trans * tt , prlist * alist , afs_uint32 host ) {\n<24> wlist . prlist_len = 0 ;\n<25> wlist . prlist_val = NULL ;\n<26> code = GetList ( tt , & tentry , & wlist , 0 ) ;\n<32> if ( ! inCPS ( * alist , wlist . prlist_val [ i ] ) ) if ( ( code = AddToPRList ( alist , & size , wlist . prlist_val [ i ] ) ) ) {\n<33> free ( wlist . prlist_val ) ;\n<37> if ( wlist . prlist_val ) free ( wlist . prlist_val ) ;
<1> static gboolean ng_read_bytes_or_eof ( wtap * wth , void * buffer , unsigned int nbytes , gboolean is_random , int * err , gchar * * err_info ) {\n<5> unsigned char * outbuffer = ( unsigned char * ) buffer ;\n<24> if ( comp_stream -> buf == NULL ) {\n<25> comp_stream -> buf = ( unsigned char * ) g_malloc ( OUTBUF_SIZE ) ;\n<43> if ( bytes_left == 0 ) {\n<59> if ( ! read_blob ( infile , comp_stream , err , err_info ) ) return FALSE ;\n<63> if ( bytes_to_copy > bytes_left ) bytes_to_copy = bytes_left ;\n<64> memcpy ( outbuffer , & comp_stream -> buf [ comp_stream -> nextout ] , bytes_to_copy ) ;\n<65> nbytes -= bytes_to_copy ;\n<66> outbuffer += bytes_to_copy ;\n<67> comp_stream -> nextout += bytes_to_copy ;\n<68> comp_stream -> uncomp_offset += bytes_to_copy ;
<1> static int convert_to_hex ( const unsigned char * src , size_t len , char * dest ) {\n<4> * dest ++ = '#' ;\n<6> i < len ;\n<7> i ++ , dest += 2 ) sprintf ( dest , "%02X" , src [ i ] ) ;
<1> static void print_version ( void ) {\n<2> printf ( "%s Ver %s Distrib %s, for %s (%s)\n" , my_progname_short , DUMP_VERSION , MYSQL_SERVER_VERSION , SYSTEM_TYPE , MACHINE_TYPE ) ;
<1> static void nntp_parse_xref ( struct Context * ctx , struct Header * hdr ) {\n<4> char * p = buf ;\n<5> while ( p ) {\n<7> p += strspn ( p , " \t" ) ;\n<8> char * grp = p ;\n<9> p = strpbrk ( p , " \t" ) ;\n<10> if ( p ) * p ++ = '\0' ;\n<11> char * colon = strchr ( grp , ':' ) ;\n<12> if ( ! colon ) continue ;\n<13> * colon ++ = '\0' ;\n<14> if ( sscanf ( colon , ANUM , & anum ) != 1 ) continue ;\n<15> nntp_article_status ( ctx , hdr , grp , anum ) ;\n<16> if ( ! NHDR ( hdr ) -> article_num && ( mutt_str_strcmp ( nntp_data -> group , grp ) == 0 ) ) NHDR ( hdr ) -> article_num = anum ;
<1> int InitVideoDec ( decoder_t * p_dec , AVCodecContext * p_context , AVCodec * p_codec , int i_codec_id , const char * psz_namecodec ) {\n<4> if ( ( p_dec -> p_sys = p_sys = calloc ( 1 , sizeof ( decoder_sys_t ) ) ) == NULL ) return VLC_ENOMEM ;\n<5> p_codec -> type = AVMEDIA_TYPE_VIDEO ;\n<6> p_context -> codec_type = AVMEDIA_TYPE_VIDEO ;\n<7> p_context -> codec_id = i_codec_id ;\n<8> p_sys -> p_context = p_context ;\n<9> p_sys -> p_codec = p_codec ;\n<10> p_sys -> i_codec_id = i_codec_id ;\n<11> p_sys -> psz_namecodec = psz_namecodec ;\n<12> p_sys -> p_ff_pic = avcodec_alloc_frame ( ) ;\n<13> p_sys -> b_delayed_open = true ;\n<14> p_sys -> p_va = NULL ;\n<15> vlc_sem_init ( & p_sys -> sem_mt , 0 ) ;\n<16> p_sys -> p_context -> codec_tag = ffmpeg_CodecTag ( p_dec -> fmt_in . i_original_fourcc ? : p_dec -> fmt_in . i_codec ) ;\n<17> p_sys -> p_context -> workaround_bugs = var_InheritInteger ( p_dec , "avcodec-workaround-bugs" ) ;\n<18> p_sys -> p_context -> err_recognition = var_InheritInteger ( p_dec , "avcodec-error-resilience" ) ;\n<19> if ( var_CreateGetBool ( p_dec , "grayscale" ) ) p_sys -> p_context -> flags |= CODEC_FLAG_GRAY ;\n<22> if ( i_val ) p_sys -> p_context -> debug_mv = i_val ;\n<23> i_val = var_CreateGetInteger ( p_dec , "avcodec-skiploopfilter" ) ;\n<24> if ( i_val >= 4 ) p_sys -> p_context -> skip_loop_filter = AVDISCARD_ALL ;\n<28> if ( var_CreateGetBool ( p_dec , "avcodec-fast" ) ) p_sys -> p_context -> flags2 |= CODEC_FLAG2_FAST ;\n<29> p_sys -> b_hurry_up = var_CreateGetBool ( p_dec , "avcodec-hurry-up" ) ;\n<30> i_val = var_CreateGetInteger ( p_dec , "avcodec-skip-frame" ) ;\n<31> if ( i_val >= 4 ) p_sys -> p_context -> skip_frame = AVDISCARD_ALL ;\n<37> p_sys -> i_skip_frame = p_sys -> p_context -> skip_frame ;\n<38> i_val = var_CreateGetInteger ( p_dec , "avcodec-skip-idct" ) ;\n<39> if ( i_val >= 4 ) p_sys -> p_context -> skip_idct = AVDISCARD_ALL ;\n<45> p_sys -> i_skip_idct = p_sys -> p_context -> skip_idct ;\n<46> p_sys -> b_direct_rendering = false ;\n<47> p_sys -> i_direct_rendering_used = - 1 ;\n<48> if ( var_CreateGetBool ( p_dec , "avcodec-dr" ) && ( p_sys -> p_codec -> capabilities & CODEC_CAP_DR1 ) && p_sys -> i_codec_id != AV_CODEC_ID_TSCC && p_sys -> i_codec_id != AV_CODEC_ID_CSCD && p_sys -> i_codec_id != AV_CODEC_ID_CINEPAK && ! p_sys -> p_context -> debug_mv ) {\n<49> p_sys -> b_direct_rendering = true ;\n<51> if ( p_sys -> b_direct_rendering ) {\n<52> msg_Dbg ( p_dec , "trying to use direct rendering" ) ;\n<56> msg_Dbg ( p_dec , "direct rendering is disabled" ) ;\n<58> p_sys -> p_context -> get_format = ffmpeg_GetFormat ;\n<61> p_sys -> p_context -> reget_buffer = avcodec_default_reget_buffer ;\n<62> p_sys -> p_context -> release_buffer = ffmpeg_ReleaseFrameBuf ;\n<88> p_sys -> b_has_b_frames = false ;\n<89> p_sys -> b_first_frame = true ;\n<90> p_sys -> b_flush = false ;\n<91> p_sys -> i_late_frames = 0 ;\n<92> p_dec -> fmt_out . i_cat = VIDEO_ES ;\n<93> if ( GetVlcChroma ( & p_dec -> fmt_out . video , p_context -> pix_fmt ) != VLC_SUCCESS ) {\n<96> p_dec -> fmt_out . i_codec = p_dec -> fmt_out . video . i_chroma ;\n<97> p_dec -> fmt_out . video . orientation = p_dec -> fmt_in . video . orientation ;\n<99> if ( p_dec -> fmt_in . video . p_palette ) {\n<100> p_sys -> palette . palette_changed = 1 ;\n<115> p_sys -> p_context -> palctrl = & p_sys -> palette ;\n<116> p_dec -> fmt_out . video . p_palette = malloc ( sizeof ( video_palette_t ) ) ;\n<119> else if ( p_sys -> i_codec_id != CODEC_ID_MSVIDEO1 && p_sys -> i_codec_id != CODEC_ID_CINEPAK ) {\n<120> p_sys -> p_context -> palctrl = & p_sys -> palette ;\n<129> if ( ffmpeg_OpenCodec ( p_dec ) < 0 ) {\n<130> msg_Err ( p_dec , "cannot open codec (%s)" , p_sys -> psz_namecodec ) ;\n<131> avcodec_free_frame ( & p_sys -> p_ff_pic ) ;\n<132> vlc_sem_destroy ( & p_sys -> sem_mt ) ;\n<133> free ( p_sys ) ;
<1> static int mpeg_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) {\n<3> MpegEncContext * s = & ctx -> mpeg_enc_ctx , * s1 = & ctx_from -> mpeg_enc_ctx ;\n<5> if ( avctx == avctx_from || ! ctx_from -> mpeg_enc_ctx_allocated || ! s1 -> context_initialized ) return 0 ;\n<8> if ( ! ctx -> mpeg_enc_ctx_allocated ) memcpy ( s + 1 , s1 + 1 , sizeof ( Mpeg1Context ) - sizeof ( MpegEncContext ) ) ;
<1> int qemuDomainDeviceAliasIndex ( const virDomainDeviceInfo * info , const char * prefix ) {\n<4> if ( ! STRPREFIX ( info -> alias , prefix ) ) return - 1 ;\n<5> if ( virStrToLong_i ( info -> alias + strlen ( prefix ) , NULL , 10 , & idx ) < 0 ) return - 1 ;\n<6> return idx ;
<11> MXGContext *mxg = s->priv_data;\n<97> pkt->size = mxg->buffer_ptr - mxg->soi_ptr;\n<103> if (mxg->soi_ptr - mxg->buffer > mxg->cache_size) {\n<105> if (mxg->cache_size > 0) {\n<107> memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);\n<113> mxg->buffer_ptr = mxg->buffer;\n<159> mxg->buffer_ptr += size;\n<189> if (startmarker_ptr - mxg->buffer > mxg->cache_size) {\n<191> if (mxg->cache_size > 0) {\n<193> memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);\n<197> mxg->buffer_ptr = mxg->buffer;
<1> static void openpic_set_irq ( void * opaque , int n_IRQ , int level ) {\n<4> if ( n_IRQ >= OPENPIC_MAX_IRQ ) {\n<5> fprintf ( stderr , "%s: IRQ %d out of range\n" , __func__ , n_IRQ ) ;\n<9> DPRINTF ( "openpic: set irq %d = %d ivpr=0x%08x\n" , n_IRQ , level , src -> ivpr ) ;
<1> static inline void powerpc_excp(CPUPPCState *env, int excp_model, int excp)\n<113> if (qemu_log_enabled()) {\n<121> fprintf(stderr, "Machine check while not allowed. "
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> KmvcContext * const ctx = avctx -> priv_data ;\n<8> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<10> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<20> ctx -> pal [ i + ( header & 0x81 ) ] = bytestream2_get_be24 ( & ctx -> g ) ;\n<38> ctx -> pal [ i ] = bytestream2_get_be24 ( & ctx -> g ) ;\n<41> if ( pal ) {\n<43> memcpy ( ctx -> pal , pal , AVPALETTE_SIZE ) ;\n<49> memcpy ( frame -> data [ 1 ] , ctx -> pal , 1024 ) ;\n<51> if ( blocksize != 8 && blocksize != 127 ) {\n<55> memset ( ctx -> cur , 0 , 320 * 200 ) ;\n<56> switch ( header & KMVC_METHOD ) {\n<57> case 0 : case 1 : memcpy ( ctx -> cur , ctx -> prev , 320 * 200 ) ;\n<59> case 3 : kmvc_decode_intra_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n<61> case 4 : kmvc_decode_inter_8x8 ( ctx , avctx -> width , avctx -> height ) ;\n<66> out = frame -> data [ 0 ] ;\n<67> src = ctx -> cur ;\n<69> i < avctx -> height ;\n<71> memcpy ( out , src , avctx -> width ) ;\n<72> src += 320 ;\n<73> out += frame -> linesize [ 0 ] ;\n<75> if ( ctx -> cur == ctx -> frm0 ) {
<1> vu_message_read(VuDev *dev, int conn_fd, VhostUserMsg *vmsg)\n<39> } while (rc < 0 && (errno == EINTR || errno == EAGAIN));\n<43> if (rc <= 0) {\n<45> vu_panic(dev, "Error while recvmsg: %s", strerror(errno));\n<63> if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS) {\n<67> vmsg->fd_num = fd_size / sizeof(int);\n<69> memcpy(vmsg->fds, CMSG_DATA(cmsg), fd_size);\n<101> } while (rc < 0 && (errno == EINTR || errno == EAGAIN));\n<105> if (rc <= 0) {\n<107> vu_panic(dev, "Error while reading: %s", strerror(errno));\n<127> vmsg_close_fds(vmsg);
<1> static int get_cod(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n<21> tmp.log2_prec_height = 15;\n<25> tmp.csty = bytestream_get_byte(&s->buf);\n<31> tmp.prog_order = bytestream_get_byte(&s->buf);\n<35> tmp.nlayers = bytestream_get_be16(&s->buf);\n<37> tmp.mct     = bytestream_get_byte(&s->buf); // multiple component transformation\n<41> get_cox(s, &tmp);\n<43> for (compno = 0; compno < s->ncomponents; compno++)\n<45> if (!(properties[compno] & HAD_COC))\n<47> memcpy(c + compno, &tmp, sizeof(tmp));
<1> int qemuMonitorTextSetPassword ( qemuMonitorPtr mon , const char * protocol , const char * password , const char * action_if_connected ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<13> if ( strstr ( reply , "unknown command:" ) ) {\n<14> ret = - 2 ;\n<17> ret = 0 ;\n<18> cleanup : VIR_FREE ( reply ) ;
<1> __org_qemu_x_Union1 *qmp___org_qemu_x_command(__org_qemu_x_EnumList *a,\n<19> ret->u.__org_qemu_x_branch = strdup("blah1");
<1> static int decode_p_frame ( FourXContext * f , AVFrame * frame , const uint8_t * buf , int length ) {\n<25> av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<26> if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n<27> f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) ( buf + extra ) , bitstream_size / 4 ) ;\n<28> memset ( ( uint8_t * ) f -> bitstream_buffer + bitstream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;
<1> int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n<3> const char *default_model)\n<11> if (!nd->model)\n<13> nd->model = strdup(default_model);\n<17> if (strcmp(nd->model, "?") != 0) {\n<19> for (i = 0 ; models[i]; i++)\n<21> if (strcmp(nd->model, models[i]) == 0)\n<23> return i;\n<27> fprintf(stderr, "qemu: Unsupported NIC model: %s\n", nd->model);\n<35> fprintf(stderr, "qemu: Supported NIC models: ");\n<37> for (i = 0 ; models[i]; i++)\n<39> fprintf(stderr, "%s%c", models[i], models[i+1] ? ',' : '\n');\n<43> exit(exit_status);
<1> char * str_tohex ( u_char * bin , size_t len , char * dst , size_t dst_len ) {\n<3> memset ( dst , 0 , dst_len ) ;\n<5> i < len ;\n<6> i ++ ) sprintf ( dst + i * 2 , "%02X" , bin [ i ] ) ;\n<7> return dst ;
<1> static void update_unicast_addr ( unicast_addr_t * req_addr , unicast_addr_t * ack_addr ) {\n<2> if ( ack_addr -> addr . type != AT_NONE && ack_addr -> port != 0 ) {\n<3> memcpy ( req_addr -> addr_buf , ack_addr -> addr_buf , sizeof ( req_addr -> addr_buf ) ) ;\n<4> SET_ADDRESS ( & req_addr -> addr , ack_addr -> addr . type , ack_addr -> addr . len , req_addr -> addr_buf ) ;
<1> static int slirp_guestfwd(SlirpState *s, const char *config_str,\n<21> p = config_str;\n<25> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<33> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<39> if (strcmp(buf, "tcp") && buf[0] != '\0') {\n<45> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<57> if (get_str_sep(buf, sizeof(buf), &p, '-') < 0) {\n<67> if (*end != '\0' || port < 1 || port > 65535) {\n<81> if ((strlen(p) > 4) && !strncmp(p, "cmd:", 4)) {\n<83> if (slirp_add_exec(s->slirp, 0, &p[4], &server, port) < 0) {\n<97> fwd->hd = qemu_chr_new(buf, p, NULL);\n<99> if (!fwd->hd) {\n<145> error_report("invalid guest forwarding rule '%s'", config_str);\n<147> return -1;
<1> void ff_riff_write_info_tag(AVIOContext *pb, const char *tag, const char *str)\n<5> int len = strlen(str);\n<7> if (len > 0) {\n<15> avio_put_str(pb, str);
<1> void *av_realloc(void *ptr, unsigned int size)\n<10> return realloc(ptr, size);
<1> static void switch_cs_variables ( FILE * sql_file , const char * delimiter , const char * character_set_client , const char * character_set_results , const char * collation_connection ) {\n<2> fprintf ( sql_file , "/*!50003 SET @saved_cs_client = @@character_set_client */ %s\n" "/*!50003 SET @saved_cs_results = @@character_set_results */ %s\n" "/*!50003 SET @saved_col_connection = @@collation_connection */ %s\n" "/*!50003 SET character_set_client = %s */ %s\n" "/*!50003 SET character_set_results = %s */ %s\n" "/*!50003 SET collation_connection = %s */ %s\n" , ( const char * ) delimiter , ( const char * ) delimiter , ( const char * ) delimiter , ( const char * ) character_set_client , ( const char * ) delimiter , ( const char * ) character_set_results , ( const char * ) delimiter , ( const char * ) collation_connection , ( const char * ) delimiter ) ;
<1> static int avi_sync(AVFormatContext *s, int exit_early)\n<10> memset(d, -1, sizeof(d));\n<14> d[j]= d[j+1];\n<16> size= d[4] + (d[5]<<8) + (d[6]<<16) + (d[7]<<24);\n<17> n= get_stream_idx(d+2);
<1> int ffurl_register_protocol(URLProtocol *protocol, int size)\n<7> if (size < sizeof(URLProtocol)) {\n<9> URLProtocol *temp = av_mallocz(sizeof(URLProtocol));\n<11> memcpy(temp, protocol, size);\n<13> protocol = temp;
<1> static void mm_rearm_timer(struct qemu_alarm_timer *t, int64_t delta)\n<29> if (!mm_timer) {\n<31> fprintf(stderr, "Failed to re-arm win32 alarm timer %ld\n",
<1> struct proclistlist * pll_create ( void ) {\n<2> struct proclistlist * pll = calloc ( 1 , sizeof ( struct proclistlist ) ) ;\n<3> pll -> proclist = get_proclist ( & pll -> length ) ;\n<4> return pll ;
<1> static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out,\n<29> if (ret < 0) {\n<31> fprintf(stderr, "ibv_poll_cq return %d!\n", ret);\n<33> return ret;\n<43> if (wc.status != IBV_WC_SUCCESS) {\n<45> fprintf(stderr, "ibv_poll_cq wc.status=%d %s!\n",\n<47> wc.status, ibv_wc_status_str(wc.status));\n<49> fprintf(stderr, "ibv_poll_cq wrid=%s!\n", wrid_desc[wr_id]);
<1> static void ctl_putarray ( const char * tag , double * arr , int start ) {\n<14> INSIST ( ( cp - buffer ) < ( int ) sizeof ( buffer ) ) ;\n<15> snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , " %.2f" , arr [ i ] * 1e3 ) ;\n<16> cp += strlen ( cp ) ;\n<18> while ( i != start ) ;\n<19> ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;
<1> static void spapr_tce_reset(DeviceState *dev)\n<5> sPAPRTCETable *tcet = SPAPR_TCE_TABLE(dev);\n<7> size_t table_size = tcet->nb_table * sizeof(uint64_t);\n<11> memset(tcet->table, 0, table_size);
<1> static void * pool_calloc ( size_t count , size_t size ) {\n<3> void * r = pool_alloc ( len ) ;\n<4> memset ( r , 0 , len ) ;\n<5> return r ;
<1> static void inject_file ( const char * path , char * file ) {\n<6> DEBUG_MSG ( "inject_file %s/%s" , path , file ) ;\n<7> SAFE_CALLOC ( filename , strlen ( path ) + strlen ( file ) + 2 , sizeof ( char ) ) ;\n<8> snprintf ( filename , strlen ( path ) + strlen ( file ) + 2 , "%s/%s" , path , file ) ;\n<9> if ( ( fd = open ( filename , O_RDONLY | O_BINARY ) ) == - 1 ) {
<1> static char * search_make_new ( const struct search_state * const state , int n , const char * const base_name ) {\n<2> const int base_len = strlen ( base_name ) ;\n<3> const char need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ;\n<8> if ( ! n -- ) {\n<9> const u8 * const postfix = ( ( u8 * ) dom ) + sizeof ( struct search_domain ) ;\n<10> const int postfix_len = dom -> len ;\n<11> char * const newname = ( char * ) malloc ( base_len + need_to_append_dot + postfix_len + 1 ) ;\n<12> if ( ! newname ) return NULL ;\n<13> memcpy ( newname , base_name , base_len ) ;\n<14> if ( need_to_append_dot ) newname [ base_len ] = '.' ;\n<15> memcpy ( newname + base_len + need_to_append_dot , postfix , postfix_len ) ;\n<16> newname [ base_len + need_to_append_dot + postfix_len ] = 0 ;\n<17> return newname ;
<8> frag = ( hm_fragment * ) item -> data ;\n<14> if ( al == 0 ) {\n<15> unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n<16> memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n<18> dtls1_hm_fragment_free ( frag ) ;
<1> static const unsigned char *seq_decode_op1(SeqVideoContext *seq, const unsigned char *src, unsigned char *dst)\n<23> src = seq_unpack_rle_block(src, block, sizeof(block));\n<25> for (b = 0; b < 8; b++) {\n<27> memcpy(dst, &block[b * 8], 8);\n<29> dst += seq->frame.linesize[0];
<1> static int mpegts_raw_read_packet(AVFormatContext *s,\n<7> MpegTSContext *ts = s->priv_data;\n<21> if (av_new_packet(pkt, TS_PACKET_SIZE) < 0)\n<27> ret = read_packet(s, pkt->data, ts->raw_packet_size, &data);\n<37> if (data != pkt->data)\n<39> memcpy(pkt->data, data, ts->raw_packet_size);\n<41> finished_reading_packet(s, ts->raw_packet_size);\n<47> if (parse_pcr(&pcr_h, &pcr_l, pkt->data) == 0) {
<1> int ff_dca_lbr_parse(DCALbrDecoder *s, uint8_t *data, DCAExssAsset *asset)\n<67> if ((ret = parse_decoder_init(s, &gb)) < 0) {\n<113> switch (chunk_id & 0x7f) {\n<117> if (s->avctx->err_recognition & (AV_EF_CRCCHECK | AV_EF_CAREFUL)) {\n<131> if (checksum != res) {\n<135> if (s->avctx->err_recognition & AV_EF_EXPLODE)\n<165> memset(s->quant_levels, 0, sizeof(s->quant_levels));\n<167> memset(s->sb_indices, 0xff, sizeof(s->sb_indices));\n<169> memset(s->sec_ch_sbms, 0, sizeof(s->sec_ch_sbms));\n<171> memset(s->sec_ch_lrms, 0, sizeof(s->sec_ch_lrms));\n<173> memset(s->ch_pres, 0, sizeof(s->ch_pres));\n<175> memset(s->grid_1_scf, 0, sizeof(s->grid_1_scf));\n<177> memset(s->grid_2_scf, 0, sizeof(s->grid_2_scf));\n<179> memset(s->grid_3_avg, 0, sizeof(s->grid_3_avg));\n<181> memset(s->grid_3_scf, 0, sizeof(s->grid_3_scf));\n<183> memset(s->grid_3_pres, 0, sizeof(s->grid_3_pres));\n<185> memset(s->tonal_scf, 0, sizeof(s->tonal_scf));\n<187> memset(s->lfe_data, 0, sizeof(s->lfe_data));\n<209> memset(s->lpc_coeff[s->framenum & 1], 0, sizeof(s->lpc_coeff[0]));\n<401> ret = parse_lfe_chunk(s, &chunk.lfe);\n<405> ret |= parse_tonal_chunk(s, &chunk.tonal);\n<411> ret |= parse_tonal_group(s, &chunk.tonal_grp[i]);\n<423> if (parse_grid_1_chunk (s, &chunk.grid1  [i], ch1, ch2) < 0 ||\n<425> parse_high_res_grid(s, &chunk.hr_grid[i], ch1, ch2) < 0) {\n<443> if (parse_ts1_chunk(s, &chunk.ts1[i], ch1, ch2) < 0 ||\n<445> parse_ts2_chunk(s, &chunk.ts2[i], ch1, ch2) < 0) {
<1> int rds_recvmsg ( struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) {\n<53> if ( sin ) {\n<57> memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;
<1> static int run_test(AVCodec *enc, AVCodec *dec, AVCodecContext *enc_ctx,\n<13> int in_offset = 0, out_offset = 0;\n<67> if (!raw_in) {\n<77> raw_out = av_malloc(in_frame->linesize[0] * NUMBER_OF_FRAMES);\n<79> if (!raw_out) {\n<89> for (i = 0; i < NUMBER_OF_FRAMES; i++) {\n<99> generate_raw_frame((uint16_t*)(in_frame->data[0]), i, enc_ctx->sample_rate,\n<103> memcpy(raw_in + in_offset, in_frame->data[0], in_frame->linesize[0]);\n<105> in_offset += in_frame->linesize[0];\n<167> if (in_frame->format != out_frame->format) {\n<175> memcpy(raw_out + out_offset, out_frame->data[0], out_frame->linesize[0]);\n<177> out_offset += out_frame->linesize[0];\n<189> if (memcmp(raw_in, raw_out, frame_data_size * NUMBER_OF_FRAMES) != 0) {\n<191> av_log(NULL, AV_LOG_ERROR, "Output differs\n");\n<193> return 1;\n<199> av_log(NULL, AV_LOG_INFO, "OK\n");\n<203> av_freep(&raw_in);\n<205> av_freep(&raw_out);\n<207> av_frame_free(&in_frame);\n<209> av_frame_free(&out_frame);\n<211> return 0;
<1> static void start_fetch_packed ( struct transfer_request * request ) {\n<3> struct transfer_request * check_request = request_queue_head ;\n<6> if ( ! target ) {\n<7> fprintf ( stderr , "Unable to fetch %s, will not be able to update server info refs\n" , oid_to_hex ( & request -> obj -> oid ) ) ;\n<12> fprintf ( stderr , "Fetching pack %s\n" , sha1_to_hex ( target -> sha1 ) ) ;\n<13> fprintf ( stderr , " which contains %s\n" , oid_to_hex ( & request -> obj -> oid ) ) ;\n<15> if ( preq == NULL ) {\n<21> if ( check_request -> state == RUN_FETCH_PACKED && ! strcmp ( check_request -> url , preq -> url ) ) {\n<22> release_http_pack_request ( preq ) ;\n<26> check_request = check_request -> next ;\n<31> request -> userData = preq ;\n<33> if ( ! start_active_slot ( preq -> slot ) ) {\n<34> fprintf ( stderr , "Unable to start GET request\n" ) ;\n<35> release_http_pack_request ( preq ) ;
<1> static void qxl_reset_state(PCIQXLDevice *d)\n<27> memset(&d->ssd.dirty, 0, sizeof(d->ssd.dirty));
<1> static int decrypt_key_data ( krb5_context context , int n_key_data , krb5_key_data * key_data , krb5_keyblock * * keyblocks , int * n_keys ) {\n<4> keys = ( krb5_keyblock * ) malloc ( n_key_data * sizeof ( krb5_keyblock ) ) ;\n<5> if ( keys == NULL ) return ENOMEM ;\n<6> memset ( keys , 0 , n_key_data * sizeof ( krb5_keyblock ) ) ;\n<10> ret = krb5_dbe_decrypt_key_data ( context , NULL , & key_data [ i ] , & keys [ i ] , NULL ) ;\n<11> if ( ret ) {\n<15> if ( keys [ i ] . contents ) {\n<16> memset ( keys [ i ] . contents , 0 , keys [ i ] . length ) ;\n<17> free ( keys [ i ] . contents ) ;\n<20> memset ( keys , 0 , n_key_data * sizeof ( krb5_keyblock ) ) ;\n<21> free ( keys ) ;\n<25> * keyblocks = keys ;
<1> static gpgme_error_t gpgsm_export_ext ( void * engine , const char * pattern [ ] , gpgme_export_mode_t mode , gpgme_data_t keydata , int use_armor ) {\n<5> int length = 7 + 1 ;\n<8> if ( mode ) return gpg_error ( GPG_ERR_NOT_SUPPORTED ) ;\n<19> length ++ ;\n<22> line = malloc ( length ) ;\n<23> if ( ! line ) return gpg_error_from_syserror ( ) ;\n<24> strcpy ( line , "EXPORT " ) ;\n<55> if ( err ) return err ;\n<59> err = start ( gpgsm , line ) ;\n<60> free ( line ) ;
<1> static int ipvideo_decode_block_opcode_0xA_16 ( IpvideoContext * s , AVFrame * frame ) {\n<3> uint16_t P [ 8 ] ;\n<8> x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n<9> if ( ! ( P [ 0 ] & 0x8000 ) ) {\n<31> x ++ ) P [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n<32> vert = ! ( P [ 4 ] & 0x8000 ) ;\n<38> x ++ , flags >>= 2 ) * pixel_ptr ++ = P [ flags & 0x03 ] ;\n<44> if ( y == 7 ) {\n<45> memcpy ( P , P + 4 , 8 ) ;
<1> static void gpgsm_release ( void * engine ) {\n<3> if ( ! gpgsm ) return ;\n<5> free ( gpgsm -> colon . attic . line ) ;\n<6> free ( gpgsm ) ;
<1> static int gx_parse_output_format ( gs_parsed_file_name_t * pfn , const char * * pfmt ) {\n<8> ++ i ) if ( pfn -> fname [ i ] == '%' ) {\n<21> case - 1 : if ( strchr ( " #+-" , pfn -> fname [ i ] ) ) continue ;\n<23> default : if ( strchr ( "0123456789" , pfn -> fname [ i ] ) ) {\n<24> width [ field ] = width [ field ] * 10 + pfn -> fname [ i ] - '0' ;\n<27> else if ( 0 == field && '.' == pfn -> fname [ i ] ) {\n<33> if ( 'l' == pfn -> fname [ i ] ) {\n<37> case 3 : if ( strchr ( "diuoxX" , pfn -> fname [ i ] ) ) {\n<38> * pfmt = & pfn -> fname [ i ] ;
<1> static int mp3info(void *data, int *byteSize, int *samplesPerFrame, int *sampleRate, int *isMono )\n<31> if ( !isPadded ) {\n<33> printf("Fatal error: mp3 data is not padded!\n");
<1> static void _slurm_rpc_get_shares ( slurm_msg_t * msg ) {\n<9> memset ( & resp_msg , 0 , sizeof ( shares_response_msg_t ) ) ;\n<10> assoc_mgr_get_shares ( acct_db_conn , uid , req_msg , & resp_msg ) ;\n<17> response_msg . data = & resp_msg ;\n<19> FREE_NULL_LIST ( resp_msg . assoc_shares_list ) ;
<1> REPLACE * init_replace ( char * * from , char * * to , uint count , char * word_end_chars ) {\n<15> for ( i = result_len = max_length = 0 , states = 2 ;\n<16> i < count ;\n<24> result_len += ( uint ) strlen ( to [ i ] ) + 1 ;\n<156> if ( ( replace = ( REPLACE * ) my_malloc ( sizeof ( REPLACE ) * ( sets . count ) + sizeof ( REPLACE_STRING ) * ( found_sets + 1 ) + sizeof ( char * ) * count + result_len , MYF ( MY_WME | MY_ZEROFILL ) ) ) ) {\n<164> to_pos = strmov ( to_pos , to [ i ] ) + 1 ;\n<169> i <= found_sets ;\n<171> pos = from [ found_set [ i - 1 ] . table_offset ] ;\n<172> rep_str [ i ] . found = ! memcmp ( pos , "\\^" , 3 ) ? 2 : 1 ;\n<174> rep_str [ i ] . to_offset = found_set [ i - 1 ] . found_offset - start_at_word ( pos ) ;
<1> char * gcry_sexp_nth_string ( const gcry_sexp_t list , int number ) {\n<5> s = sexp_nth_data ( list , number , & n ) ;\n<6> if ( ! s || n < 1 || ( n + 1 ) < 1 ) return NULL ;\n<8> if ( ! buf ) return NULL ;\n<9> memcpy ( buf , s , n ) ;\n<11> return buf ;
<1> static fz_icclink * fz_get_icc_link ( fz_context * ctx , const fz_colorspace * dst , int dst_extras , const fz_colorspace * src , int src_extras , const fz_colorspace * prf , const fz_color_params * rend , int num_bytes , int copy_spots , int * src_n ) {\n<4> fz_iccprofile * dst_icc = dst -> data ;\n<34> if ( src_icc == NULL ) fz_throw ( ctx , FZ_ERROR_GENERIC , "Profile missing during link creation" ) ;\n<40> key = fz_malloc_struct ( ctx , fz_link_key ) ;\n<42> memcpy ( & key -> dst_md5 , dst_icc -> md5 , 16 ) ;\n<43> memcpy ( & key -> src_md5 , src_icc -> md5 , 16 ) ;\n<53> link = fz_new_icc_link ( ctx , dst_icc , dst_extras , src_icc , src_extras , prf_icc , rend , num_bytes , copy_spots ) ;
<1> char check_if_ignore_table ( const char * table_name , char * table_type ) {\n<8> my_snprintf ( buff , sizeof ( buff ) , "show table status like %s" , quote_for_like ( table_name , show_name_buff ) ) ;\n<11> verbose_msg ( "-- Warning: Couldn't get status information for " "table %s (%s)\n" , table_name , mysql_error ( mysql ) ) ;\n<15> if ( ! ( row = mysql_fetch_row ( res ) ) ) {\n<16> fprintf ( stderr , "Error: Couldn't read status information for table %s (%s)\n" , table_name , mysql_error ( mysql ) ) ;\n<22> strmake ( table_type , row [ 1 ] , NAME_LEN - 1 ) ;\n<23> if ( opt_delayed ) {\n<24> if ( strcmp ( table_type , "MyISAM" ) && strcmp ( table_type , "ISAM" ) && strcmp ( table_type , "ARCHIVE" ) && strcmp ( table_type , "HEAP" ) && strcmp ( table_type , "MEMORY" ) ) result = IGNORE_INSERT_DELAYED ;\n<26> if ( ! opt_no_data && ( ! my_strcasecmp ( & my_charset_latin1 , table_type , "MRG_MyISAM" ) || ! strcmp ( table_type , "MRG_ISAM" ) || ! strcmp ( table_type , "FEDERATED" ) ) ) result = IGNORE_DATA ;
<1> static void setup_environment ( int argc , char * * argv , int * argc_out , char * * * argv_out , char * * * argv_free , char * * env_free ) {\n<3> char * p , * v = getenv ( "XDELTA" ) ;\n<4> if ( v == NULL ) {\n<11> ( * env_free ) = ( char * ) main_malloc ( ( usize_t ) strlen ( v ) + 1 ) ;\n<12> strcpy ( * env_free , v ) ;
<1> static uintmax_t do_change_note_fanout ( struct tree_entry * orig_root , struct tree_entry * root , char * hex_sha1 , unsigned int hex_sha1_len , char * fullpath , unsigned int fullpath_len , unsigned char fanout ) {\n<12> tmp_hex_sha1_len = hex_sha1_len + e -> name -> str_len ;\n<13> tmp_fullpath_len = fullpath_len ;\n<14> if ( ! e -> versions [ 1 ] . mode || tmp_hex_sha1_len > 40 || e -> name -> str_len % 2 ) continue ;\n<15> memcpy ( hex_sha1 + hex_sha1_len , e -> name -> str_dat , e -> name -> str_len ) ;\n<16> if ( tmp_fullpath_len ) fullpath [ tmp_fullpath_len ++ ] = '/' ;\n<17> memcpy ( fullpath + tmp_fullpath_len , e -> name -> str_dat , e -> name -> str_len ) ;\n<18> tmp_fullpath_len += e -> name -> str_len ;\n<19> fullpath [ tmp_fullpath_len ] = '\0' ;\n<20> if ( tmp_hex_sha1_len == 40 && ! get_sha1_hex ( hex_sha1 , sha1 ) ) {\n<21> if ( fanout == 0xff ) {\n<25> construct_path_with_fanout ( hex_sha1 , fanout , realpath ) ;\n<26> if ( ! strcmp ( fullpath , realpath ) ) {\n<27> num_notes ++ ;\n<30> if ( ! tree_content_remove ( orig_root , fullpath , & leaf , 0 ) ) die ( "Failed to remove path %s" , fullpath ) ;\n<31> tree_content_set ( orig_root , realpath , leaf . versions [ 1 ] . sha1 , leaf . versions [ 1 ] . mode , leaf . tree ) ;\n<35> num_notes += do_change_note_fanout ( orig_root , e , hex_sha1 , tmp_hex_sha1_len , fullpath , tmp_fullpath_len , fanout ) ;\n<37> t = root -> tree ;
<1> int dtls1_read_failed ( SSL * s , int code ) {\n<2> if ( code > 0 ) {\n<3> fprintf ( stderr , "invalid state reached %s:%d" , __FILE__ , __LINE__ ) ;
<1> static CURLcode formdata_add_filename ( const struct curl_httppost * file , struct FormData * * form , curl_off_t * size ) {\n<6> if ( ! filename ) {\n<8> if ( ! filebasename ) return CURLE_OUT_OF_MEMORY ;\n<9> filename = filebasename ;\n<11> if ( strchr ( filename , '\\' ) || strchr ( filename , '"' ) ) {\n<13> filename_escaped = malloc ( strlen ( filename ) * 2 + 1 ) ;\n<14> if ( ! filename_escaped ) {\n<19> p1 = filename ;\n<29> Curl_safefree ( filename_escaped ) ;\n<30> Curl_safefree ( filebasename ) ;\n<31> return result ;
<1> static int get_packet(URLContext *s, int for_header)\n<27> RTMPPacket rpkt = { 0 };\n<59> ret = rtmp_parse_result(s, rt, &rpkt);\n<87> ff_rtmp_packet_destroy(&rpkt);\n<93> if (rpkt.type == RTMP_PT_VIDEO || rpkt.type == RTMP_PT_AUDIO ||\n<95> (rpkt.type == RTMP_PT_NOTIFY && !memcmp("\002\000\012onMetaData", rpkt.data, 13))) {\n<119> bytestream_put_buffer(&p, rpkt.data, rpkt.data_size);\n<127> } else if (rpkt.type == RTMP_PT_METADATA) {\n<135> rt->flv_data = av_realloc(rt->flv_data, rt->flv_size);\n<139> next = rpkt.data;\n<143> while (next - rpkt.data < rpkt.data_size - 11) {\n<171> memcpy(rt->flv_data, rpkt.data, rpkt.data_size);\n<173> ff_rtmp_packet_destroy(&rpkt);\n<179> ff_rtmp_packet_destroy(&rpkt);
<1> static void gs_heap_free_all ( gs_memory_t * mem , uint free_mask , client_name_t cname ) {\n<10> bp != 0 ;\n<13> if_debug3m ( 'a' , mem , "[a]gs_heap_free_all(%s) 0x%lx(%u)\n" , client_name_string ( bp -> cname ) , ( ulong ) ( bp + 1 ) , bp -> size ) ;\n<14> gs_alloc_fill ( bp + 1 , gs_alloc_fill_free , bp -> size ) ;\n<15> free ( bp ) ;
<1> int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)\n<7> uint8_t tk[8][4];\n<63> if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n<73> memcpy(tk, key, KC * 4);\n<77> for (t = 0; t < (rounds + 1) * 16;) {\n<79> memcpy(a->round_key[0].u8 + t, tk, KC * 4);
<1> static void test_multiple ( void ) {\n<5> memset ( rbuf , 0 , sizeof ( rbuf ) ) ;\n<8> i ++ ) wbuf [ i ] = i ;\n<16> if ( roff == woff ) test_ok = memcmp ( rbuf , wbuf , sizeof ( wbuf ) ) == 0 ;
<1> static int synth_frame ( AVCodecContext * ctx , GetBitContext * gb , int frame_idx , float * samples , const double * lsps , const double * prev_lsps , float * excitation , float * synth ) {\n<69> synth_block ( s , gb , n , block_nsamples , bl_pitch_sh2 , lsps , prev_lsps , & frame_descs [ bd_idx ] , & excitation [ n * block_nsamples ] , & synth [ n * block_nsamples ] ) ;\n<71> if ( s -> do_apf ) {\n<85> else memcpy ( samples , synth , 160 * sizeof ( synth [ 0 ] ) ) ;
<1> static void smp_parse(QemuOpts *opts)\n<45> } else if (sockets * cores * threads < cpus) {\n<65> smp_cpus = cpus;\n<67> smp_cores = cores > 0 ? cores : 1;\n<69> smp_threads = threads > 0 ? threads : 1;\n<85> if (max_cpus > MAX_CPUMASK_BITS) {\n<87> fprintf(stderr, "Unsupported number of maxcpus\n");\n<93> if (max_cpus < smp_cpus) {\n<95> fprintf(stderr, "maxcpus must be equal to or greater than smp\n");
<1> int process_cgivars ( void ) {\n<9> variables = getcgivars ( ) ;\n<11> variables [ x ] != NULL ;\n<12> x ++ ) {\n<13> if ( strlen ( variables [ x ] ) >= MAX_INPUT_BUFFER - 1 ) continue ;\n<14> else if ( ! strcmp ( variables [ x ] , "cmd_typ" ) ) {\n<15> x ++ ;\n<16> if ( variables [ x ] == NULL ) {\n<22> else if ( ! strcmp ( variables [ x ] , "attr" ) ) {\n<23> x ++ ;\n<24> if ( variables [ x ] == NULL ) {\n<30> else if ( ! strcmp ( variables [ x ] , "cmd_mod" ) ) {\n<31> x ++ ;\n<32> if ( variables [ x ] == NULL ) {\n<38> else if ( ! strcmp ( variables [ x ] , "com_id" ) || ! strcmp ( variables [ x ] , "down_id" ) ) {\n<39> x ++ ;\n<40> if ( variables [ x ] == NULL ) {\n<47> else if ( ! strcmp ( variables [ x ] , "not_dly" ) ) {\n<48> x ++ ;\n<49> if ( variables [ x ] == NULL ) {\n<55> else if ( ! strcmp ( variables [ x ] , "sched_dly" ) ) {\n<56> x ++ ;\n<57> if ( variables [ x ] == NULL ) {\n<63> else if ( ! strcmp ( variables [ x ] , "com_author" ) ) {\n<64> x ++ ;\n<65> if ( variables [ x ] == NULL ) {\n<69> if ( ( comment_author = ( char * ) strdup ( variables [ x ] ) ) == NULL ) comment_author = "" ;\n<70> strip_html_brackets ( comment_author ) ;\n<72> else if ( ! strcmp ( variables [ x ] , "com_data" ) ) {\n<73> x ++ ;\n<74> if ( variables [ x ] == NULL ) {\n<78> if ( ( comment_data = ( char * ) strdup ( variables [ x ] ) ) == NULL ) comment_data = "" ;\n<79> strip_html_brackets ( comment_data ) ;\n<81> else if ( ! strcmp ( variables [ x ] , "host" ) ) {\n<82> x ++ ;\n<83> if ( variables [ x ] == NULL ) {\n<87> if ( ( host_name = ( char * ) strdup ( variables [ x ] ) ) == NULL ) host_name = "" ;\n<89> strip_html_brackets ( host_name ) ;\n<90> commands [ x ] . host_name = host_name ;\n<93> else if ( ! strcmp ( variables [ x ] , "hostgroup" ) ) {\n<94> x ++ ;\n<95> if ( variables [ x ] == NULL ) {\n<99> if ( ( hostgroup_name = ( char * ) strdup ( variables [ x ] ) ) == NULL ) hostgroup_name = "" ;\n<100> strip_html_brackets ( hostgroup_name ) ;\n<102> else if ( ! strcmp ( variables [ x ] , "service" ) ) {\n<103> x ++ ;\n<104> if ( variables [ x ] == NULL ) {\n<108> if ( ( service_desc = ( char * ) strdup ( variables [ x ] ) ) == NULL ) service_desc = "" ;\n<110> strip_html_brackets ( service_desc ) ;\n<111> commands [ ( x - 2 ) ] . description = service_desc ;\n<114> else if ( ! strcmp ( variables [ x ] , "hostservice" ) ) {\n<115> x ++ ;\n<116> if ( variables [ x ] == NULL ) {\n<120> temp_buffer = strtok ( variables [ x ] , "^" ) ;\n<121> if ( ( host_name = ( char * ) strdup ( temp_buffer ) ) == NULL ) host_name = "" ;\n<123> strip_html_brackets ( host_name ) ;\n<124> commands [ x ] . host_name = host_name ;\n<126> temp_buffer = strtok ( NULL , "" ) ;\n<127> if ( ( service_desc = ( char * ) strdup ( temp_buffer ) ) == NULL ) service_desc = "" ;\n<129> strip_html_brackets ( service_desc ) ;\n<130> commands [ x ] . description = service_desc ;\n<133> else if ( ! strcmp ( variables [ x ] , "servicegroup" ) ) {\n<134> x ++ ;\n<135> if ( variables [ x ] == NULL ) {\n<139> if ( ( servicegroup_name = ( char * ) strdup ( variables [ x ] ) ) == NULL ) servicegroup_name = "" ;\n<140> strip_html_brackets ( servicegroup_name ) ;\n<142> else if ( ! strcmp ( variables [ x ] , "persistent" ) ) persistent_comment = TRUE ;\n<143> else if ( ! strcmp ( variables [ x ] , "send_notification" ) ) send_notification_set = TRUE ;\n<144> else if ( ! strcmp ( variables [ x ] , "sticky_ack" ) ) sticky_ack_set = TRUE ;\n<145> else if ( ! strcmp ( variables [ x ] , "use_ack_end_time" ) ) use_ack_end_time = TRUE ;\n<146> else if ( ! strcmp ( variables [ x ] , "use_disabled_notif_end_time" ) ) use_disabled_notif_end_time = TRUE ;\n<147> else if ( ! strcmp ( variables [ x ] , "force_check" ) ) force_check = TRUE ;\n<148> else if ( ! strcmp ( variables [ x ] , "ahas" ) ) affect_host_and_services = TRUE ;\n<149> else if ( ! strcmp ( variables [ x ] , "ptc" ) ) propagate_to_children = TRUE ;\n<150> else if ( ! strcmp ( variables [ x ] , "fixed" ) ) {\n<151> x ++ ;\n<152> if ( variables [ x ] == NULL ) {\n<158> else if ( ! strcmp ( variables [ x ] , "trigger" ) ) {\n<159> x ++ ;\n<160> if ( variables [ x ] == NULL ) {\n<166> else if ( ! strcmp ( variables [ x ] , "childoptions" ) ) {\n<167> x ++ ;\n<168> if ( variables [ x ] == NULL ) {\n<174> else if ( ! strcmp ( variables [ x ] , "plugin_output" ) ) {\n<175> x ++ ;\n<176> if ( variables [ x ] == NULL ) {\n<180> if ( strlen ( variables [ x ] ) >= MAX_INPUT_BUFFER - 1 ) {\n<181> error = TRUE ;\n<184> else strcpy ( plugin_output , variables [ x ] ) ;\n<186> else if ( ! strcmp ( variables [ x ] , "performance_data" ) ) {\n<187> x ++ ;\n<188> if ( variables [ x ] == NULL ) {\n<192> if ( strlen ( variables [ x ] ) >= MAX_INPUT_BUFFER - 1 ) {\n<193> error = TRUE ;\n<196> else strcpy ( performance_data , variables [ x ] ) ;\n<198> else if ( ! strcmp ( variables [ x ] , "plugin_state" ) ) {\n<199> x ++ ;\n<200> if ( variables [ x ] == NULL ) {\n<206> else if ( ! strcmp ( variables [ x ] , "hours" ) ) {\n<207> x ++ ;\n<208> if ( variables [ x ] == NULL ) {\n<218> else if ( ! strcmp ( variables [ x ] , "minutes" ) ) {\n<219> x ++ ;\n<220> if ( variables [ x ] == NULL ) {\n<230> else if ( ! strcmp ( variables [ x ] , "start_time" ) ) {\n<231> x ++ ;\n<232> if ( variables [ x ] == NULL ) {\n<236> start_time_string = ( char * ) malloc ( strlen ( variables [ x ] ) + 1 ) ;\n<237> if ( start_time_string == NULL ) start_time_string = "" ;\n<238> else strcpy ( start_time_string , variables [ x ] ) ;\n<240> else if ( ! strcmp ( variables [ x ] , "end_time" ) ) {\n<241> x ++ ;\n<242> if ( variables [ x ] == NULL ) {\n<246> end_time_string = ( char * ) malloc ( strlen ( variables [ x ] ) + 1 ) ;\n<247> if ( end_time_string == NULL ) end_time_string = "" ;\n<248> else strcpy ( end_time_string , variables [ x ] ) ;\n<250> else if ( ! strcmp ( variables [ x ] , "force_notification" ) ) force_notification = NOTIFICATION_OPTION_FORCED ;\n<251> else if ( ! strcmp ( variables [ x ] , "broadcast_notification" ) ) broadcast_notification = NOTIFICATION_OPTION_BROADCAST ;\n<252> else if ( ! strcmp ( variables [ x ] , "nodaemoncheck" ) ) daemon_check = FALSE ;\n<258> free_cgivars ( variables ) ;
<1> char getchar_buffer ( char * * buf ) {\n<3> DEBUG_MSG ( "getchar_buffer: %s" , * buf ) ;\n<4> if ( * * buf == 0 ) return 0 ;\n<5> if ( * ( * buf + 0 ) == 's' && * ( * buf + 1 ) == '(' ) {\n<8> p = strchr ( * buf , ')' ) ;\n<9> if ( p != NULL ) {\n<11> time = atoi ( * buf + 2 ) ;\n<18> * buf = * buf + 1 ;
<79> put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);\n<81> tag = av_dict_get(st->metadata, "language", NULL, 0);\n<83> put_ebml_string(pb, MATROSKA_ID_TRACKLANGUAGE, tag ? tag->value:"und");\n<185> if ((tag = av_dict_get(st->metadata, "stereo_mode", NULL, 0)) ||\n<187> (tag = av_dict_get( s->metadata, "stereo_mode", NULL, 0))) {\n<195> for (j=0; j<MATROSKA_VIDEO_STEREO_MODE_COUNT; j++)\n<197> if (!strcmp(tag->value, ff_matroska_video_stereo_mode[j])){\n<199> st_mode = j;
<1> static int svq3_decode_slice_header ( AVCodecContext * avctx ) {\n<3> H264Context * h = & s -> h ;\n<25> if ( length > 0 ) {\n<26> memcpy ( ( uint8_t * ) & h -> gb . buffer [ get_bits_count ( & h -> gb ) >> 3 ] , & h -> gb . buffer [ h -> gb . size_in_bits >> 3 ] , length - 1 ) ;\n<51> if ( h -> mb_x > 0 ) {\n<52> memset ( h -> intra4x4_pred_mode + h -> mb2br_xy [ mb_xy - 1 ] + 3 , - 1 , 4 * sizeof ( int8_t ) ) ;\n<53> memset ( h -> intra4x4_pred_mode + h -> mb2br_xy [ mb_xy - h -> mb_x ] , - 1 , 8 * sizeof ( int8_t ) * h -> mb_x ) ;\n<55> if ( h -> mb_y > 0 ) {\n<56> memset ( h -> intra4x4_pred_mode + h -> mb2br_xy [ mb_xy - h -> mb_stride ] , - 1 , 8 * sizeof ( int8_t ) * ( h -> mb_width - h -> mb_x ) ) ;
<1> static void test_subselect ( ) {\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<28> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<51> id = 7 ;\n<56> if ( ! opt_silent ) fprintf ( stdout , "\n row 1: %d" , id ) ;\n<57> DIE_UNLESS ( id == 1 ) ;\n<60> id = 8 ;\n<65> if ( ! opt_silent ) fprintf ( stdout , "\n row 1: %d" , id ) ;\n<66> DIE_UNLESS ( id == 0 ) ;
<1> void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,\n<21> char *base_core_type = spapr_get_cpu_core_type(machine->cpu_model);\n<23> const char *type = object_get_typename(OBJECT(dev));\n<27> if (strcmp(base_core_type, type)) {\n<29> error_setg(&local_err, "CPU core type should be %s", base_core_type);\n<37> if (!smc->dr_cpu_enabled && dev->hotplugged) {\n<91> g_free(base_core_type);
<1> fz_colorspace * fz_new_icc_colorspace ( fz_context * ctx , const char * name , int num , fz_buffer * buf ) {\n<10> if ( buf == NULL ) {\n<13> data = fz_lookup_icc ( ctx , name , & size ) ;\n<15> is_lab = ( strcmp ( name , FZ_ICC_PROFILE_LAB ) == 0 ) ;\n<16> profile -> bgr = ( strcmp ( name , FZ_ICC_PROFILE_BGR ) == 0 ) ;\n<22> fz_cmm_init_profile ( ctx , profile ) ;\n<25> fz_cmm_fin_profile ( ctx , profile ) ;\n<26> fz_free ( ctx , profile ) ;\n<29> fz_md5_icc ( ctx , profile ) ;\n<42> cs = fz_new_colorspace ( ctx , name , type , flags , profile -> num_devcomp , NULL , NULL , NULL , is_lab ? clamp_lab_icc : clamp_default_icc , free_icc , profile , sizeof ( profile ) ) ;\n<66> fz_cmm_fin_profile ( ctx , profile ) ;\n<67> fz_free ( ctx , profile ) ;
<1> static void dump_trigger_old ( FILE * sql_file , MYSQL_RES * show_triggers_rs , MYSQL_ROW * show_trigger_row , const char * table_name ) {\n<5> const char * xml_msg = "\nWarning! mysqldump being run against old server " "that does not\nsupport 'SHOW CREATE TRIGGERS' " "statement. Skipping..\n" ;\n<7> if ( opt_xml ) {\n<8> print_xml_comment ( sql_file , strlen ( xml_msg ) , xml_msg ) ;\n<9> check_io ( sql_file ) ;\n<12> fprintf ( sql_file , "--\n" "-- WARNING: old server version. " "The following dump may be incomplete.\n" "--\n" ) ;\n<20> if ( mysql_num_fields ( show_triggers_rs ) > 7 ) {\n<27> parse_user ( ( * show_trigger_row ) [ 7 ] , strlen ( ( * show_trigger_row ) [ 7 ] ) , user_name_str , & user_name_len , host_name_str , & host_name_len ) ;\n<28> fprintf ( sql_file , "/*!50017 DEFINER=%s@%s */ " , quote_name ( user_name_str , quoted_user_name_str , FALSE ) , quote_name ( host_name_str , quoted_host_name_str , FALSE ) ) ;
<1> bool trace_backend_init(const char *events, const char *file)\n<30> if (!thread) {\n<32> fprintf(stderr, "warning: unable to initialize simple trace backend\n");
<1> static void slirp_hostfwd(SlirpState *s, Monitor *mon, const char *redir_str,\n<15> char buf[256];\n<25> if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<31> if (!strcmp(buf, "tcp") || buf[0] == '\0') {\n<33> is_udp = 0;\n<35> } else if (!strcmp(buf, "udp")) {\n<37> is_udp = 1;\n<47> if (!legacy_format) {\n<121> config_error(mon, "invalid host forwarding rule '%s'\n", redir_str);
<1> int mime_field_print ( MIMEField * field , char * buf_start , int buf_length , int * buf_index_inout , int * buf_chars_to_skip_inout ) {\n<3> if ( field -> m_ptr_name [ 0 ] == '@' ) {\n<7> total_len = field -> m_len_name + field -> m_len_value + field -> m_n_v_raw_printable_pad ;\n<8> if ( ( buf_start != nullptr ) && ( * buf_chars_to_skip_inout == 0 ) && ( total_len <= ( buf_length - * buf_index_inout ) ) ) {\n<9> buf_start += * buf_index_inout ;\n<10> memcpy ( buf_start , field -> m_ptr_name , total_len ) ;\n<11> * buf_index_inout += total_len ;\n<19> if ( ( buf_start != nullptr ) && ( * buf_chars_to_skip_inout == 0 ) && ( total_len <= ( buf_length - * buf_index_inout ) ) ) {\n<20> buf_start += * buf_index_inout ;\n<21> memcpy ( buf_start , field -> m_ptr_name , field -> m_len_name ) ;\n<22> buf_start += field -> m_len_name ;\n<23> buf_start [ 0 ] = ':' ;\n<24> buf_start [ 1 ] = ' ' ;\n<25> buf_start += 2 ;\n<26> memcpy ( buf_start , field -> m_ptr_value , field -> m_len_value ) ;\n<27> buf_start += field -> m_len_value ;
<1> static int matroska_read_header ( AVFormatContext * s ) {\n<20> i < FF_ARRAY_ELEMS ( matroska_doctypes ) ;\n<21> i ++ ) if ( ! strcmp ( ebml . doctype , matroska_doctypes [ i ] ) ) break ;\n<22> if ( i >= FF_ARRAY_ELEMS ( matroska_doctypes ) ) {\n<23> av_log ( s , AV_LOG_WARNING , "Unknown EBML doctype '%s'\n" , ebml . doctype ) ;\n<29> ebml_free ( ebml_syntax , & ebml ) ;\n<48> if ( ! ( attachments [ j ] . filename && attachments [ j ] . mime && attachments [ j ] . bin . data && attachments [ j ] . bin . size > 0 ) ) {\n<58> st -> codec -> extradata = av_malloc ( attachments [ j ] . bin . size ) ;\n<59> if ( ! st -> codec -> extradata ) break ;\n<61> memcpy ( st -> codec -> extradata , attachments [ j ] . bin . data , attachments [ j ] . bin . size ) ;\n<63> ff_mkv_mime_tags [ i ] . id != AV_CODEC_ID_NONE ;\n<65> if ( ! strncmp ( ff_mkv_mime_tags [ i ] . str , attachments [ j ] . mime , strlen ( ff_mkv_mime_tags [ i ] . str ) ) ) {
<1> int archprintf ( Archive * AH , const char * fmt , ... ) {\n<11> cnt = pvsnprintf ( p , len , fmt , args ) ;\n<13> if ( cnt < len ) break ;\n<14> free ( p ) ;\n<17> WriteData ( AH , p , cnt ) ;\n<18> free ( p ) ;
<1> int gdev_pdf_put_params ( gx_device * dev , gs_param_list * plist ) {\n<3> gx_device_pdf * pdev = ( gx_device_pdf * ) dev ;\n<4> gs_memory_t * mem = gs_memory_stable ( pdev -> memory ) ;\n<6> if ( ! save_dev ) return_error ( gs_error_VMerror ) ;\n<7> memcpy ( save_dev , pdev , sizeof ( gx_device_pdf ) ) ;\n<8> code = gdev_pdf_put_params_impl ( dev , save_dev , plist ) ;
<1> matroska_probe (AVProbeData *p)\n<69> for (n = 4 + size; n < 4 + size + total - sizeof(probe_data); n++)\n<71> if (!memcmp (&p->buf[n], probe_data, sizeof(probe_data)))\n<73> return AVPROBE_SCORE_MAX;
<9> Hnm4VideoContext *hnm = avctx->priv_data;\n<70> if (hnm->version == 0x4a) {\n<74> memcpy(hnm->processed, hnm->current, hnm->width * hnm->height);\n<89> memcpy(frame->data[1], hnm->palette, 256 * 4);\n<93> hnm_flip_buffers(hnm);
<1> static int do_sd_create(char *filename, int64_t vdi_size,\n<17> char buf[SD_MAX_VDI_LEN];\n<23> if (fd < 0) {\n<31> memset(buf, 0, sizeof(buf));\n<33> strncpy(buf, filename, SD_MAX_VDI_LEN);\n<37> memset(&hdr, 0, sizeof(hdr));\n<45> wlen = SD_MAX_VDI_LEN;\n<61> ret = do_req(fd, (SheepdogReq *)&hdr, buf, &wlen, &rlen);\n<79> error_report("%s, %s", sd_strerror(rsp->result), filename);
<1> int zfor_samples ( i_ctx_t * i_ctx_p ) {\n<12> memcpy ( ep - 4 , op - 3 , 3 * sizeof ( ref ) ) ;
<1> static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,\n<9> MpegEncContext *s = opaque;\n<25> memcpy(s->mv, mv, sizeof(*mv));\n<29> ff_init_block_index(s);\n<31> ff_update_block_index(s);\n<49> ff_MPV_decode_mb(s, s->block);
<1> static int decode_dct ( RangeCoder * c , DCTBlockCoder * bc , int * block , int bx , int by ) {\n<4> memset ( block , 0 , sizeof ( * block ) * 64 ) ;
<1> static void dump_search_desc ( KEYDB_HANDLE hd , const char * text , KEYDB_SEARCH_DESC * desc , size_t ndesc ) {\n<8> case KEYDB_SEARCH_MODE_NONE : s = "none" ;\n<10> case KEYDB_SEARCH_MODE_EXACT : s = "exact" ;\n<12> case KEYDB_SEARCH_MODE_SUBSTR : s = "substr" ;\n<14> case KEYDB_SEARCH_MODE_MAIL : s = "mail" ;\n<16> case KEYDB_SEARCH_MODE_MAILSUB : s = "mailsub" ;\n<18> case KEYDB_SEARCH_MODE_MAILEND : s = "mailend" ;\n<20> case KEYDB_SEARCH_MODE_WORDS : s = "words" ;\n<22> case KEYDB_SEARCH_MODE_SHORT_KID : s = "short_kid" ;\n<24> case KEYDB_SEARCH_MODE_LONG_KID : s = "long_kid" ;\n<26> case KEYDB_SEARCH_MODE_FPR16 : s = "fpr16" ;\n<28> case KEYDB_SEARCH_MODE_FPR20 : s = "fpr20" ;\n<30> case KEYDB_SEARCH_MODE_FPR : s = "fpr" ;\n<32> case KEYDB_SEARCH_MODE_ISSUER : s = "issuer" ;\n<34> case KEYDB_SEARCH_MODE_ISSUER_SN : s = "issuer_sn" ;\n<36> case KEYDB_SEARCH_MODE_SN : s = "sn" ;\n<38> case KEYDB_SEARCH_MODE_SUBJECT : s = "subject" ;\n<40> case KEYDB_SEARCH_MODE_KEYGRIP : s = "keygrip" ;\n<42> case KEYDB_SEARCH_MODE_FIRST : s = "first" ;\n<44> case KEYDB_SEARCH_MODE_NEXT : s = "next" ;\n<46> default : s = "?" ;\n<49> if ( ! n ) log_debug ( "%s: mode=%s (hd=%p)" , text , s , hd ) ;\n<50> else log_debug ( "%*s mode=%s" , ( int ) strlen ( text ) , "" , s ) ;
<1> static void test_client_character_set ( ) {\n<10> DIE_UNLESS ( ! strcmp ( cs . csname , "utf8" ) ) ;\n<11> DIE_UNLESS ( ! strcmp ( cs . name , "utf8_general_ci" ) ) ;
<1> static float * anti_sparseness ( AMRWBContext * ctx , float * fixed_vector , float * buf ) {\n<24> if ( ir_filter_nr < 2 ) {\n<27> memset ( buf , 0 , sizeof ( float ) * AMRWB_SFR_SIZE ) ;\n<30> i ++ ) if ( fixed_vector [ i ] ) ff_celp_circ_addf ( buf , buf , coef , i , fixed_vector [ i ] , AMRWB_SFR_SIZE ) ;\n<31> fixed_vector = buf ;
<1> static int selinux_is_sblabel_mnt ( struct super_block * sb ) {\n<3> return sbsec -> behavior == SECURITY_FS_USE_XATTR || sbsec -> behavior == SECURITY_FS_USE_TRANS || sbsec -> behavior == SECURITY_FS_USE_TASK || sbsec -> behavior == SECURITY_FS_USE_NATIVE || ! strcmp ( sb -> s_type -> name , "sysfs" ) || ! strcmp ( sb -> s_type -> name , "pstore" ) || ! strcmp ( sb -> s_type -> name , "debugfs" ) || ! strcmp ( sb -> s_type -> name , "rootfs" ) ;
<1> static uint32_t vmsvga_bios_read ( void * opaque , uint32_t address ) {\n<2> printf ( "%s: what are we supposed to return?\n" , __func__ ) ;
<1> int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<329> AVBufferRef *qp_table_buf = av_buffer_alloc(qpw);\n<331> if (qp_table_buf) {\n<333> memset(qp_table_buf->data, qp, qpw);\n<335> av_frame_set_qp_table(data, qp_table_buf, 0, FF_QSCALE_TYPE_MPEG1);\n<343> av_log(avctx, AV_LOG_DEBUG, "QP: %d\n", qp);\n<597> int w = s->width;\n<607> w = AV_CEIL_RSHIFT(w, hshift);\n<613> dst = &((uint8_t *)s->picture_ptr->data[p])[(h - 1) * s->linesize[p]];\n<621> if (src1 == src2 || i == h - 1) {\n<623> memcpy(dst, src1, w);\n<627> for (index = 0; index < w; index++)\n<629> dst[index] = (src1[index] + src2[index]) >> 1;\n<633> dst -= s->linesize[p];
<1> static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) {\n<3> char * r = NULL ;\n<7> char * component = NULL ;\n<8> data = malloc ( size * sizeof ( krb5_data ) ) ;\n<9> if ( ! data ) {\n<12> if ( ! retval ) r = k5memdup0 ( realm , rlen , & retval ) ;\n<14> if ( count == size ) {\n<17> new_data = realloc ( data , size * sizeof ( krb5_data ) ) ;\n<19> data = new_data ;\n<25> if ( ! retval ) {\n<26> data [ count ] . length = strlen ( component ) ;\n<27> data [ count ] . data = strdup ( component ) ;\n<28> if ( ! data [ count ] . data ) {\n<38> princ -> data = data ;\n<40> r = NULL ;\n<41> data = NULL ;\n<43> if ( data ) {\n<44> while ( -- count >= 0 ) {\n<45> free ( data [ count ] . data ) ;\n<47> free ( data ) ;\n<49> free ( r ) ;
<1> static Picture * remove_short(H264Context *h, int frame_num){\n<23> if(pic->frame_num == frame_num){\n<25> h->short_ref[i]= NULL;\n<27> memmove(&h->short_ref[i], &h->short_ref[i+1], (h->short_ref_count - i - 1)*sizeof(Picture*));
<1> void qemu_put_buffer(QEMUFile *f, const uint8_t *buf, int size)\n<17> while (size > 0) {\n<19> l = IO_BUF_SIZE - f->buf_index;\n<21> if (l > size) {\n<23> l = size;\n<27> memcpy(f->buf + f->buf_index, buf, l);\n<29> f->bytes_xfer += l;\n<33> add_to_iovec(f, f->buf + f->buf_index, l);\n<37> f->buf_index += l;\n<45> if (qemu_file_get_error(f)) {\n<51> buf += l;\n<53> size -= l;
<1> static int AssignTTFBitGlyph ( struct glyphinfo * gi , SplineFont * sf , EncMap * map , int32 * bsizes ) {\n<4> int * bygid = malloc ( ( sf -> glyphcnt + 3 ) * sizeof ( int ) ) ;\n<5> memset ( bygid , 0xff , ( sf -> glyphcnt + 3 ) * sizeof ( int ) ) ;\n<6> AssignNotdefNull ( sf , bygid , false ) ;
<1> bool is_secure_file_path ( char * path ) {\n<2> char buff1 [ FN_REFLEN ] , buff2 [ FN_REFLEN ] ;\n<4> if ( ! opt_secure_file_priv ) return TRUE ;\n<5> opt_secure_file_priv_len = strlen ( opt_secure_file_priv ) ;\n<6> if ( strlen ( path ) >= FN_REFLEN ) return FALSE ;\n<7> if ( my_realpath ( buff1 , path , 0 ) ) {\n<8> size_t length = dirname_length ( path ) ;\n<9> memcpy ( buff2 , path , length ) ;\n<10> buff2 [ length ] = '\0' ;\n<11> if ( length == 0 || my_realpath ( buff1 , buff2 , 0 ) ) return FALSE ;\n<13> convert_dirname ( buff2 , buff1 , NullS ) ;\n<14> if ( ! lower_case_file_system ) {\n<15> if ( strncmp ( opt_secure_file_priv , buff2 , opt_secure_file_priv_len ) ) return FALSE ;\n<18> if ( files_charset_info -> coll -> strnncoll ( files_charset_info , ( uchar * ) buff2 , strlen ( buff2 ) , ( uchar * ) opt_secure_file_priv , opt_secure_file_priv_len , TRUE ) ) return FALSE ;
<1> static int read_thread(void *arg)\n<33> if (!wait_mutex) {\n<45> memset(st_index, -1, sizeof(st_index));\n<163> seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT) && strcmp("ogg", ic->iformat->name);\n<225> if (wanted_stream_spec[type] && st_index[type] == -1)\n<235> if (wanted_stream_spec[i] && st_index[i] == -1) {\n<275> (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n<287> if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n<305> if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n<307> stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n<315> if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n<317> ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);\n<327> if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {\n<329> stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);
<1> void kvmppc_set_papr(CPUPPCState *env)\n<51> if (ret) {\n<53> fprintf(stderr, "Couldn't set HIOR. Maybe you're running an old \n"
<1> void report_event ( int err , struct peer * peer , const char * str ) {\n<10> snprintf ( statstr , sizeof ( statstr ) , "0.0.0.0 %04x %02x %s" , ctlsysstatus ( ) , err , eventstr ( err ) ) ;\n<11> if ( str != NULL ) {\n<12> len = strlen ( statstr ) ;\n<13> snprintf ( statstr + len , sizeof ( statstr ) - len , " %s" , str ) ;\n<27> snprintf ( statstr , sizeof ( statstr ) , "%s %04x %02x %s" , src , ctlpeerstatus ( peer ) , err , eventstr ( err ) ) ;\n<28> if ( str != NULL ) {\n<29> len = strlen ( statstr ) ;\n<30> snprintf ( statstr + len , sizeof ( statstr ) - len , " %s" , str ) ;
<1> int test_gf2m_mod_exp ( BIO * bp , BN_CTX * ctx ) {\n<51> if ( ! BN_is_zero ( f ) ) {\n<52> fprintf ( stderr , "GF(2^m) modular exponentiation test failed!\n" ) ;
<1> static inline int padr_match ( PCNetState * s , const uint8_t * buf , int size ) {\n<2> struct qemu_ether_header * hdr = ( void * ) buf ;\n<6> int result = ( ! CSR_DRCVPA ( s ) ) && ! memcmp ( hdr -> ether_dhost , padr , 6 ) ;
<1> static void buffer_reserve(Buffer *buffer, size_t len)\n<11> if (buffer->buffer == NULL) {\n<13> fprintf(stderr, "vnc: out of memory\n");
<1> static int mpegts_write_packet_internal(AVFormatContext *s, AVPacket *pkt)\n<7> int size = pkt->size;\n<9> uint8_t *buf = pkt->data;\n<15> MpegTSWriteStream *ts_st = st->priv_data;\n<83> int ret = ff_check_h264_startcode(s, st, pkt);\n<91> if (extradd && AV_RB24(st->codec->extradata) > 1)\n<93> extradd = 0;\n<105> extradd = 0;\n<115> extradd = 0;\n<121> if (!data)\n<125> memcpy(data + 6, st->codec->extradata, extradd);\n<127> memcpy(data + 6 + extradd, pkt->data, pkt->size);\n<135> buf     = data;\n<137> size    = pkt->size + 6 + extradd;\n<201> size            = avio_close_dyn_buf(ts_st->amux->pb, &data);\n<205> buf             = data;\n<259> mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_size,\n<271> if (st->codec->codec_type != AVMEDIA_TYPE_AUDIO || size > ts->pes_payload_size) {\n<289> if (!ts_st->payload_size) {\n<301> memcpy(ts_st->payload + ts_st->payload_size, buf, size);\n<303> ts_st->payload_size += size;
<1> int ff_h264_alloc_tables(H264Context *h){\n<19> FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)\n<37> memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n<39> h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n<73> init_dequant_tables(h);
<1> static bool _tocEntryIsACL ( TocEntry * te ) {\n<2> if ( strcmp ( te -> desc , "ACL" ) == 0 || strcmp ( te -> desc , "ACL LANGUAGE" ) == 0 || strcmp ( te -> desc , "DEFAULT ACL" ) == 0 ) return true ;\n<3> return false ;
<1> static int mxf_parse_structural_metadata(MXFContext *mxf)\n<87> if (!component)\n<93> for (k = 0; k < mxf->packages_count; k++) {\n<97> if (!temp_package)\n<101> if (!memcmp(temp_package->package_uid, component->source_package_uid, 16)) {\n<103> source_package = temp_package;
<1> void ufile_fill_uchar_buffer ( UFILE * f ) {\n<11> char charBuffer [ UFILE_CHARBUFFER_SIZE ] ;\n<13> if ( f -> fFile == NULL ) {\n<26> if ( f -> fFileno == 0 ) {\n<27> char * retStr = fgets ( charBuffer , ufmt_min ( maxCPBytes , UFILE_CHARBUFFER_SIZE ) , f -> fFile ) ;\n<28> bytesRead = ( int32_t ) ( retStr ? uprv_strlen ( charBuffer ) : 0 ) ;\n<34> mySource = charBuffer ;\n<35> mySourceEnd = charBuffer + bytesRead ;\n<39> ucnv_toUnicode ( f -> fConverter , & myTarget , f -> fUCBuffer + bufferSize , & mySource , mySourceEnd , NULL , ( UBool ) ( feof ( f -> fFile ) != 0 ) , & status ) ;
<1> char **breakline(char *input, int *count)\n<9> char **rval = calloc(sizeof(char *), 1);\n<13> while (rval && (p = qemu_strsep(&input, " ")) != NULL) {\n<15> if (!*p) {\n<23> rval = realloc(rval, sizeof(*rval) * (c + 1));\n<25> if (!rval) {\n<33> rval[c - 1] = p;\n<35> rval[c] = NULL;
<1> static int isoent_tree ( struct archive_write * a , struct isoent * * isoentpp ) {\n<12> if ( isoent -> file -> parentdir . length > 0 ) fn = p = isoent -> file -> parentdir . s ;\n<13> else fn = p = "" ;\n<14> if ( archive_strlen ( & ( iso9660 -> cur_dirstr ) ) == archive_strlen ( & ( isoent -> file -> parentdir ) ) && strcmp ( iso9660 -> cur_dirstr . s , fn ) == 0 ) {\n<24> l = get_path_component ( name , sizeof ( name ) , fn ) ;\n<81> archive_string_empty ( & ( iso9660 -> cur_dirstr ) ) ;\n<82> archive_string_ensure ( & ( iso9660 -> cur_dirstr ) , archive_strlen ( & ( dent -> file -> parentdir ) ) + archive_strlen ( & ( dent -> file -> basename ) ) + 2 ) ;\n<86> archive_string_copy ( & ( iso9660 -> cur_dirstr ) , & ( dent -> file -> parentdir ) ) ;\n<87> archive_strappend_char ( & ( iso9660 -> cur_dirstr ) , '/' ) ;\n<89> archive_string_concat ( & ( iso9660 -> cur_dirstr ) , & ( dent -> file -> basename ) ) ;
<1> int qemuMonitorTextLoadSnapshot ( qemuMonitorPtr mon , const char * name ) {\n<3> char * reply = NULL ;\n<10> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) ) {\n<14> if ( strstr ( reply , "No block device supports snapshots" ) != NULL ) {\n<15> qemuReportError ( VIR_ERR_OPERATION_INVALID , "%s" , _ ( "this domain does not have a device to load snapshots" ) ) ;\n<18> else if ( strstr ( reply , "Could not find snapshot" ) != NULL ) {\n<19> qemuReportError ( VIR_ERR_OPERATION_INVALID , _ ( "the snapshot '%s' does not exist, and was not loaded" ) , name ) ;\n<22> else if ( strstr ( reply , "Snapshots not supported on device" ) != NULL ) {\n<23> qemuReportError ( VIR_ERR_OPERATION_INVALID , "%s" , reply ) ;\n<26> else if ( strstr ( reply , "Could not open VM state file" ) != NULL ) {\n<27> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , reply ) ;\n<30> else if ( strstr ( reply , "Error" ) != NULL && strstr ( reply , "while loading VM state" ) != NULL ) {\n<31> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , reply ) ;\n<34> else if ( strstr ( reply , "Error" ) != NULL && strstr ( reply , "while activating snapshot on" ) != NULL ) {\n<35> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , reply ) ;\n<38> ret = 0 ;\n<41> VIR_FREE ( reply ) ;
<1> ulong get_column_grant ( THD * thd , GRANT_INFO * grant , const char * db_name , const char * table_name , const char * field_name ) {\n<11> if ( ! ( grant_table = grant -> grant_table ) ) priv = grant -> privilege ;\n<13> grant_column = column_hash_search ( grant_table , field_name , ( uint ) strlen ( field_name ) ) ;
<1> static void mode_pass ( struct cpio * cpio , const char * destdir ) {\n<5> cpio -> destdir = malloc ( strlen ( destdir ) + 8 ) ;\n<6> strcpy ( cpio -> destdir , destdir ) ;\n<7> if ( destdir [ strlen ( destdir ) - 1 ] != '/' ) strcat ( cpio -> destdir , "/" ) ;\n<20> while ( ( p = lafe_line_reader_next ( lr ) ) != NULL ) file_to_archive ( cpio , p ) ;\n<24> if ( cpio -> dot ) fprintf ( stderr , "\n" ) ;\n<26> if ( ! cpio -> quiet ) {\n<27> int64_t blocks = ( archive_filter_bytes ( cpio -> archive , 0 ) + 511 ) / 512 ;\n<28> fprintf ( stderr , "%lu %s\n" , ( unsigned long ) blocks , blocks == 1 ? "block" : "blocks" ) ;
<1> rfbBool rfbSendCopyRegion ( rfbClientPtr cl , sraRegionPtr reg , int dx , int dy ) {\n<10> while ( sraRgnIteratorNext ( i , & rect1 ) ) {\n<20> rect . encoding = Swap32IfLE ( rfbEncodingCopyRect ) ;\n<21> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ;\n<22> cl -> ublen += sz_rfbFramebufferUpdateRectHeader ;\n<23> cr . srcX = Swap16IfLE ( x - dx ) ;\n<24> cr . srcY = Swap16IfLE ( y - dy ) ;\n<25> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & cr , sz_rfbCopyRect ) ;\n<26> cl -> ublen += sz_rfbCopyRect ;\n<27> rfbStatRecordEncodingSent ( cl , rfbEncodingCopyRect , sz_rfbFramebufferUpdateRectHeader + sz_rfbCopyRect , w * h * ( cl -> scaledScreen -> bitsPerPixel / 8 ) ) ;
<1> static int dnslabel_table_add ( struct dnslabel_table * table , const char * label , off_t pos ) {\n<4> if ( table -> n_labels == MAX_LABELS ) return ( - 1 ) ;\n<5> v = strdup ( label ) ;\n<6> if ( v == NULL ) return ( - 1 ) ;
<1> static void dissect_q931_pdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean is_over_ip ) {\n<19> reset_q931_packet_info ( q931_pi ) ;\n<42> if ( call_ref_len != 0 ) {\n<43> tvb_memcpy ( tvb , call_ref , offset , call_ref_len ) ;\n<46> call_ref [ 0 ] &= 0x7F ;\n<47> proto_tree_add_bytes ( q931_tree , hf_q931_call_ref , tvb , offset , call_ref_len , call_ref ) ;\n<50> call_ref [ 0 ] &= 0x7F ;\n<52> memcpy ( & ( q931_pi -> crv ) , call_ref , call_ref_len > sizeof ( q931_pi -> crv ) ? sizeof ( q931_pi -> crv ) : call_ref_len ) ;
<1> int ttfcopyfile ( FILE * ttf , FILE * other , int pos , const char * tab_name ) {\n<10> rewind ( other ) ;\n<11> while ( ( ch = getc ( other ) ) != EOF ) putc ( ch , ttf ) ;\n<12> if ( ferror ( other ) ) ret = 0 ;
<13> ret = gif_parse_next_image(s);\n<23> if (av_new_packet(pkt, s->screen_width * s->screen_height * 3)) {\n<31> memcpy(pkt->data, s->image_buf, s->screen_width * s->screen_height * 3);
<1> static int read_sm_data(AVFormatContext *s, AVIOContext *bc, AVPacket *pkt, int is_meta, int64_t maxpos)\n<35> ret = get_str(bc, name, sizeof(name));\n<67> if (avio_tell(bc) + value_len >= maxpos)\n<71> if (!strcmp(name, "Palette")) {\n<73> dst = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, value_len);\n<75> } else if (!strcmp(name, "Extradata")) {\n<77> dst = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, value_len);\n<79> } else if (sscanf(name, "CodecSpecificSide%"SCNd64"", &v64) == 1) {\n<91> } else if (!strcmp(name, "ChannelLayout") && value_len == 8) {\n<93> channel_layout = avio_rl64(bc);\n<99> av_log(s, AV_LOG_WARNING, "Unknown data %s / %s\n", name, type_str);\n<101> avio_skip(bc, value_len);\n<107> if(!dst)\n<121> } else if (value < -4) {\n<127> if (!strcmp(name, "SkipStart")) {\n<129> skip_start = value;\n<131> } else if (!strcmp(name, "SkipEnd")) {\n<133> skip_end = value;\n<135> } else if (!strcmp(name, "Channels")) {\n<137> channels = value;\n<139> } else if (!strcmp(name, "SampleRate")) {\n<141> sample_rate = value;\n<143> } else if (!strcmp(name, "Width")) {\n<145> width = value;\n<147> } else if (!strcmp(name, "Height")) {\n<149> height = value;\n<153> av_log(s, AV_LOG_WARNING, "Unknown integer %s\n", name);
<1> static int qemu_loadvm_state(QEMUFile *f)\n<47> qemu_get_buffer(f, (uint8_t *)idstr, len);\n<49> idstr[len] = '\0';\n<67> se = find_se(idstr, instance_id);\n<69> if (!se) {\n<71> fprintf(stderr, "qemu: warning: instance 0x%x of device '%s' not present in current VM\n",\n<79> if (ret < 0) {\n<81> fprintf(stderr, "qemu: warning: error while loading state for instance 0x%x of device '%s'\n",
<1> static void send_mru_entry ( mon_entry * mon , int count ) {\n<19> switch ( which ) {\n<20> case 0 : snprintf ( tag , sizeof ( tag ) , addr_fmt , count ) ;\n<21> pch = sptoa ( & mon -> rmtadr ) ;\n<22> ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;
<1> static const char *ass_split_section(ASSSplitContext *ctx, const char *buf)\n<5> const ASSSection *section = &ass_sections[ctx->current_section];\n<29> } else if (section->format_header && !order) {\n<31> len = strlen(section->format_header);\n<33> if (strncmp(buf, section->format_header, len) || buf[len] != ':')\n<71> } else if (section->fields_header) {\n<73> len = strlen(section->fields_header);\n<75> if (!strncmp(buf, section->fields_header, len) && buf[len] == ':') {
<1> static int ehci_execute(EHCIQueue *q)\n<19> if ( !(q->qh.token & QTD_TOKEN_ACTIVE)) {\n<21> fprintf(stderr, "Attempting to execute inactive QH\n");\n<31> if (q->tbytes > BUFF_SIZE) {\n<33> fprintf(stderr, "Request for more bytes than allowed\n");\n<43> switch(q->pid) {\n<51> default: fprintf(stderr, "bad token\n"); break;\n<133> if (ret > BUFF_SIZE) {\n<135> fprintf(stderr, "ret from usb_handle_packet > BUFF_SIZE\n");
<1> static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,\n<7> IscsiLun *iscsilun = bs->opaque;\n<67> if (iscsi_url == NULL) {\n<79> memset(iscsilun, 0, sizeof(IscsiLun));\n<197> iscsilun->aio_context = bdrv_get_aio_context(bs);\n<201> iscsilun->has_write_same = true;\n<205> task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 0, 0,\n<227> if (iscsilun->type == TYPE_DISK && (flags & BDRV_O_RDWR) &&\n<229> iscsi_is_write_protected(iscsilun)) {\n<241> iscsi_readcapacity_sync(iscsilun, &local_err);\n<253> bs->total_sectors = sector_lun2qemu(iscsilun->num_blocks, iscsilun);\n<267> if (iscsilun->type != TYPE_DISK && iscsilun->type != TYPE_ROM) {\n<275> task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n<301> inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n<307> if (inq_task == NULL) {\n<325> inq_task = iscsi_do_inquiry(iscsilun->iscsi, iscsilun->lun, 1,\n<331> if (inq_task == NULL) {\n<361> iscsi_attach_aio_context(bs, iscsilun->aio_context);\n<371> if (iscsilun->bl.opt_unmap_gran * iscsilun->block_size >= 4 * 1024 &&\n<373> iscsilun->bl.opt_unmap_gran * iscsilun->block_size <= 16 * 1024 * 1024) {\n<375> iscsilun->cluster_sectors = (iscsilun->bl.opt_unmap_gran *\n<379> if (iscsilun->lbprz && !(bs->open_flags & BDRV_O_NOCACHE)) {\n<381> iscsilun->allocationmap = iscsi_allocationmap_init(iscsilun);\n<383> if (iscsilun->allocationmap == NULL) {\n<415> if (ret) {\n<423> memset(iscsilun, 0, sizeof(IscsiLun));
<1> static inline void array_free(array_t* array)\n<5> if(array->pointer)\n<7> free(array->pointer);
<1> static bool scsi_target_emulate_report_luns(SCSITargetReq *r)\n<65> if (len > sizeof(r->buf)) {\n<75> memset(r->buf, 0, len);\n<77> stl_be_p(&r->buf, n);\n<91> store_lun(&r->buf[i], dev->lun);\n<101> r->len = len;
<1> static void guess_palette(DVDSubContext* ctx,\n<25> uint8_t color_used[16] = { 0 };\n<57> if (alpha[i] != 0 && !color_used[colormap[i]]) {\n<59> color_used[colormap[i]] = 1;\n<69> if (nb_opaque_colors == 0)\n<77> memset(color_used, 0, 16);\n<83> if (!color_used[colormap[i]])  {\n<101> rgba_palette[i] = (rgba_palette[color_used[colormap[i]] - 1] & 0x00ffffff) |
<1> static void test_bug30472 ( ) {\n<21> bug30472_retrieve_charset_info ( & con , character_set_name_1 , character_set_client_1 , character_set_results_1 , collation_connnection_1 ) ;\n<23> bug30472_retrieve_charset_info ( & con , character_set_name_2 , character_set_client_2 , character_set_results_2 , collation_connnection_2 ) ;\n<24> DIE_UNLESS ( strcmp ( character_set_name_2 , "utf8" ) == 0 ) ;\n<25> DIE_UNLESS ( strcmp ( character_set_client_2 , "utf8" ) == 0 ) ;\n<26> DIE_UNLESS ( strcmp ( character_set_results_2 , "utf8" ) == 0 ) ;\n<27> DIE_UNLESS ( strcmp ( collation_connnection_2 , "utf8_general_ci" ) == 0 ) ;\n<28> DIE_UNLESS ( strcmp ( character_set_name_1 , character_set_name_2 ) != 0 ) ;\n<29> DIE_UNLESS ( strcmp ( character_set_client_1 , character_set_client_2 ) != 0 ) ;\n<30> DIE_UNLESS ( strcmp ( character_set_results_1 , character_set_results_2 ) != 0 ) ;\n<31> DIE_UNLESS ( strcmp ( collation_connnection_1 , collation_connnection_2 ) != 0 ) ;\n<33> bug30472_retrieve_charset_info ( & con , character_set_name_3 , character_set_client_3 , character_set_results_3 , collation_connnection_3 ) ;\n<34> DIE_UNLESS ( strcmp ( character_set_name_1 , character_set_name_3 ) == 0 ) ;\n<35> DIE_UNLESS ( strcmp ( character_set_client_1 , character_set_client_3 ) == 0 ) ;\n<36> DIE_UNLESS ( strcmp ( character_set_results_1 , character_set_results_3 ) == 0 ) ;\n<37> DIE_UNLESS ( strcmp ( collation_connnection_1 , collation_connnection_3 ) == 0 ) ;\n<40> bug30472_retrieve_charset_info ( & con , character_set_name_4 , character_set_client_4 , character_set_results_4 , collation_connnection_4 ) ;\n<41> DIE_UNLESS ( strcmp ( character_set_name_4 , "utf8" ) == 0 ) ;\n<42> DIE_UNLESS ( strcmp ( character_set_client_4 , "utf8" ) == 0 ) ;\n<43> DIE_UNLESS ( strcmp ( character_set_results_4 , "utf8" ) == 0 ) ;\n<44> DIE_UNLESS ( strcmp ( collation_connnection_4 , "utf8_general_ci" ) == 0 ) ;
<1> int dtls1_send_newsession_ticket ( SSL * s ) {\n<8> SSL_CTX * tctx = s -> initial_ctx ;\n<10> unsigned char key_name [ 16 ] ;\n<17> i2d_SSL_SESSION ( s -> session , & p ) ;\n<21> if ( tctx -> tlsext_ticket_key_cb ) {\n<22> if ( tctx -> tlsext_ticket_key_cb ( s , key_name , iv , & ctx , & hctx , 1 ) < 0 ) {\n<29> EVP_EncryptInit_ex ( & ctx , EVP_aes_128_cbc ( ) , NULL , tctx -> tlsext_tick_aes_key , iv ) ;\n<31> memcpy ( key_name , tctx -> tlsext_tick_key_name , 16 ) ;\n<34> p += 2 ;\n<36> memcpy ( p , key_name , 16 ) ;\n<37> p += 16 ;\n<38> memcpy ( p , iv , EVP_CIPHER_CTX_iv_length ( & ctx ) ) ;\n<39> p += EVP_CIPHER_CTX_iv_length ( & ctx ) ;
<1> static int l2_allocate(BlockDriverState *bs, int l1_index, uint64_t **table)\n<3> BDRVQcow2State *s = bs->opaque;\n<20> l2_table = *table;\n<32> memcpy(l2_table, old_table, s->cluster_size);\n<33> qcow2_cache_put(bs, s->l2_table_cache, (void **) &old_table);\n<37> qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);
<1> static int main_input ( xd3_cmd cmd , main_file * ifile , main_file * ofile , main_file * sfile ) {\n<15> memset ( & stream , 0 , sizeof ( stream ) ) ;\n<16> memset ( & source , 0 , sizeof ( source ) ) ;\n<17> memset ( & config , 0 , sizeof ( config ) ) ;
<1> static int64_t archipelago_volume_info(BDRVArchipelagoState *s)\n<17> const char *volname = s->volname;\n<19> targetlen = strlen(volname);\n<45> if (!target) {\n<53> memcpy(target, volname, targetlen);\n<65> reqdata->volname = volname;
<1> int bdrv_open(BlockDriverState *bs, const char *filename, int snapshot)\n<43> fd = open(filename, O_RDWR | O_LARGEFILE);\n<57> fd = open(filename, O_RDONLY | O_LARGEFILE);\n<81> if (read(fd, &cow_header, sizeof(cow_header)) != sizeof(cow_header)) {\n<83> fprintf(stderr, "%s: could not read header\n", filename);\n<113> if (cow_header.backing_file[0] != '\0') {\n<115> if (stat(cow_header.backing_file, &st) != 0) {\n<117> fprintf(stderr, "%s: could not find original disk image '%s'\n", filename, cow_header.backing_file);\n<123> if (st.st_mtime != be32_to_cpu(cow_header.mtime)) {\n<125> fprintf(stderr, "%s: original raw disk image '%s' does not match saved timestamp\n", filename, cow_header.backing_file);
<1> static void create_vorbis_context(vorbis_enc_context *venc,\n<37> for (book = 0; book < venc->ncodebooks; book++) {\n<39> vorbis_enc_codebook *cb = &venc->codebooks[book];\n<57> cb->lens      = av_malloc(sizeof(uint8_t)  * cb->nentries);\n<61> memcpy(cb->lens, cvectors[book].clens, cvectors[book].len);\n<63> memset(cb->lens + cvectors[book].len, 0, cb->nentries - cvectors[book].len);\n<83> ready_codebook(cb);\n<107> static const int a[] = {0, 1, 2, 2, 3, 3, 4, 4};\n<189> rc = &venc->residues[0];\n<203> rc->books           = av_malloc(sizeof(*rc->books) * rc->classifications);\n<231> memcpy(rc->books, a, sizeof a);\n<235> ready_residue(rc, venc);
<1> static void steamdiscover_dissect_body_status ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n<19> switch ( tag . field_number ) {\n<35> hostname = tvb_get_string_enc ( wmem_packet_scope ( ) , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n<36> if ( hostname && strlen ( hostname ) ) {\n<37> col_add_fstr ( pinfo -> cinfo , COL_INFO , "%s from %s" , hf_steam_ihs_discovery_header_msgtype_strings [ STEAMDISCOVER_MSGTYPE_CLIENTBROADCASTMSGSTATUS ] . strptr , hostname ) ;
<1> void ff_mpeg_unref_picture(MpegEncContext *s, Picture *pic)\n<5> int off = offsetof(Picture, mb_mean) + sizeof(pic->mb_mean);\n<9> pic->tf.f = &pic->f;\n<35> ff_free_picture_tables(pic);\n<39> memset((uint8_t*)pic + off, 0, sizeof(*pic) - off);
<1> static void test_set_option ( ) {\n<15> if ( ! opt_silent ) fprintf ( stdout , "\n with SQL_SELECT_LIMIT= 2 (direct)" ) ;\n<23> if ( ! opt_silent ) fprintf ( stdout , "\n with SQL_SELECT_LIMIT=2 (prepare)" ) ;\n<31> if ( ! opt_silent ) fprintf ( stdout , "\n with SQL_SELECT_LIMIT=DEFAULT (prepare)" ) ;
<1> static void test_bug1180 ( ) {\n<19> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<27> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static int ra288_decode_frame(AVCodecContext * avctx, void *data,\n<45> out = (float *)frame->data[0];\n<53> for (i=0; i < RA288_BLOCKS_PER_FRAME; i++) {\n<65> memcpy(out, &ractx->sp_hist[70 + 36], RA288_BLOCK_SIZE * sizeof(*out));\n<67> out += RA288_BLOCK_SIZE;\n<73> backward_filter(ractx, ractx->sp_hist, ractx->sp_rec, syn_window,
<1> static void png_filter_row ( PNGDSPContext * dsp , uint8_t * dst , int filter_type , uint8_t * src , uint8_t * last , int size , int bpp ) {\n<3> switch ( filter_type ) {\n<4> case PNG_FILTER_VALUE_NONE : memcpy ( dst , src , size ) ;
<1> static void ppc_core99_init (ram_addr_t ram_size,\n<75> if (!env) {\n<77> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<257> if (ppc_boot_device == '\0') {\n<259> fprintf(stderr, "No valid boot device for Mac99 machine\n");
<1> static uint32_t _get_wckeyid ( mysql_conn_t * mysql_conn , char * * name , uid_t uid , char * cluster , uint32_t associd ) {\n<10> if ( ! * name ) {\n<12> memset ( & user_rec , 0 , sizeof ( slurmdb_user_rec_t ) ) ;\n<15> if ( assoc_mgr_fill_in_user ( mysql_conn , & user_rec , 1 , NULL ) != SLURM_SUCCESS ) {\n<20> if ( user_rec . default_wckey ) * name = xstrdup_printf ( "*%s" , user_rec . default_wckey ) ;\n<23> memset ( & wckey_rec , 0 , sizeof ( slurmdb_wckey_rec_t ) ) ;\n<28> if ( assoc_mgr_fill_in_wckey ( mysql_conn , & wckey_rec , ACCOUNTING_ENFORCE_WCKEYS , NULL ) != SLURM_SUCCESS ) {\n<39> if ( assoc_mgr_fill_in_wckey ( mysql_conn , & wckey_rec , ACCOUNTING_ENFORCE_WCKEYS , NULL ) != SLURM_SUCCESS ) {\n<41> wckey_ptr -> name = xstrdup ( wckey_rec . name ) ;\n<49> assoc_mgr_fill_in_wckey ( mysql_conn , & wckey_rec , ACCOUNTING_ENFORCE_WCKEYS , NULL ) ;\n<53> wckeyid = wckey_rec . id ;
<1> static int multiwrite_f(int argc, char **argv)\n<33> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<81> for (i = optind; i < argc; i++) {\n<83> if (!strcmp(argv[i], ";")) {\n<85> nr_reqs++;\n<109> offset = cvtnum(argv[optind]);\n<111> if (offset < 0) {\n<113> printf("non-numeric offset argument -- %s\n", argv[optind]);\n<123> if (offset & 0x1ff) {\n<145> for (j = optind; j < argc; j++) {\n<147> if (!strcmp(argv[j], ";")) {\n<163> buf[i] = create_iovec(&qiovs[i], &argv[optind], nr_iov, pattern);\n<199> if (cnt < 0) {\n<201> printf("aio_multiwrite failed: %s\n", strerror(-cnt));
<1> static ssize_t qemu_fill_buffer(QEMUFile *f)\n<11> assert(!qemu_file_is_writable(f));\n<15> pending = f->buf_size - f->buf_index;\n<17> if (pending > 0) {\n<19> memmove(f->buf, f->buf + f->buf_index, pending);\n<25> f->buf_size = pending;\n<29> len = f->ops->get_buffer(f->opaque, f->buf + pending, f->pos,\n<31> IO_BUF_SIZE - pending);\n<41> qemu_file_set_error(f, -EIO);\n<45> qemu_file_set_error(f, len);
<1> static void pushio ( IO * wrapper , FILE * ps , char * macro , int cnt ) {\n<2> _IO * io = calloc ( 1 , sizeof ( _IO ) ) ;\n<19> wrapper -> top = io ;
<1> static int pnm_decode_frame(AVCodecContext *avctx, void *data,\n<27> s->bytestream       = buf;\n<33> if (ff_pnm_decode_header(avctx, s) < 0)\n<129> ptr      = p->data[0];\n<133> if (s->bytestream + n * avctx->height > s->bytestream_end)\n<181> if (!upgrade)\n<183> memcpy(ptr, s->bytestream, n);\n<189> for (j = 0; j < n; j++)\n<191> ptr[j] = (s->bytestream[j] * f + 64) >> 7;\n<197> for (j = 0; j < n / 2; j++) {\n<207> s->bytestream += n;\n<209> ptr           += linesize;\n<227> ptr      = p->data[0];\n<231> if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end)\n<235> for (i = 0; i < avctx->height; i++) {\n<237> memcpy(ptr, s->bytestream, n);\n<239> s->bytestream += n;\n<241> ptr           += linesize;\n<245> ptr1 = p->data[1];\n<247> ptr2 = p->data[2];\n<249> n >>= 1;\n<253> for (i = 0; i < h; i++) {\n<255> memcpy(ptr1, s->bytestream, n);\n<257> s->bytestream += n;\n<259> memcpy(ptr2, s->bytestream, n);\n<261> s->bytestream += n;\n<263> ptr1 += p->linesize[1];\n<265> ptr2 += p->linesize[2];
<1> static void mpeg_er_decode_mb ( void * opaque , int ref , int mv_dir , int mv_type , int ( * mv ) [ 2 ] [ 4 ] [ 2 ] , int mb_x , int mb_y , int mb_intra , int mb_skipped ) {\n<2> MpegEncContext * s = opaque ;\n<9> memcpy ( s -> mv , mv , sizeof ( * mv ) ) ;\n<10> ff_init_block_index ( s ) ;\n<11> ff_update_block_index ( s ) ;\n<17> ff_MPV_decode_mb ( s , s -> block ) ;
<1> static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n<9> MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n<21> memset(&info, 0x0, cmd->iov_size);\n<23> if (cmd->iov_size < dcmd_size) {\n<95> memcpy(info.product_name, base_class->product_name, 24);\n<101> memcpy(info.image_component[0].name, "APP", 3);\n<107> memcpy(info.image_component[0].build_date, "Apr  1 2014", 11);\n<109> memcpy(info.image_component[0].build_time, "12:34:56", 8);\n<113> if (pci_dev->has_rom) {\n<115> uint8_t biosver[32];\n<121> ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n<123> memcpy(biosver, ptr + 0x41, 31);\n<125> memcpy(info.image_component[1].name, "BIOS", 4);\n<127> memcpy(info.image_component[1].version, biosver,\n<129> strlen((const char *)biosver));\n<237> cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
<1> static int setup_common(char *argv[], int argv_sz)\n<5> memset(cur_ide, 0, sizeof(cur_ide));
<1> static void build_config ( char * prefix , struct manager_ctx * manager , struct server * server ) {\n<3> int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;\n<4> path = ss_malloc ( path_size ) ;\n<5> snprintf ( path , path_size , "%s/.shadowsocks_%s.conf" , prefix , server -> port ) ;\n<7> if ( f == NULL ) {\n<17> fprintf ( f , "\"password\":\"%s\"" , server -> password ) ;\n<18> if ( server -> method ) fprintf ( f , ",\n\"method\":\"%s\"" , server -> method ) ;\n<19> else if ( manager -> method ) fprintf ( f , ",\n\"method\":\"%s\"" , manager -> method ) ;\n<20> if ( server -> fast_open [ 0 ] ) fprintf ( f , ",\n\"fast_open\": %s" , server -> fast_open ) ;\n<21> if ( server -> mode ) fprintf ( f , ",\n\"mode\":\"%s\"" , server -> mode ) ;\n<22> if ( server -> plugin ) fprintf ( f , ",\n\"plugin\":\"%s\"" , server -> plugin ) ;\n<23> if ( server -> plugin_opts ) fprintf ( f , ",\n\"plugin_opts\":\"%s\"" , server -> plugin_opts ) ;
<1> struct key * key_alloc ( struct key_type * type , const char * desc , kuid_t uid , kgid_t gid , const struct cred * cred , key_perm_t perm , unsigned long flags , int ( * restrict_link ) ( struct key * , const struct key_type * , const union key_payload * ) ) {\n<7> if ( ! desc || ! * desc ) goto error ;\n<8> if ( type -> vet_description ) {\n<9> ret = type -> vet_description ( desc ) ;\n<10> if ( ret < 0 ) {\n<15> desclen = strlen ( desc ) ;\n<16> quotalen = desclen + 1 + type -> def_datalen ;\n<32> key -> index_key . desc_len = desclen ;\n<33> key -> index_key . description = kmemdup ( desc , desclen + 1 , GFP_KERNEL ) ;
<1> static void _slurm_rpc_submit_batch_pack_job ( slurm_msg_t * msg ) {\n<156> hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n<157> if ( tmp_str [ 0 ] == '[' ) {\n<158> tmp_offset = strchr ( tmp_str , ']' ) ;\n<160> tmp_offset = tmp_str + 1 ;\n<171> xfree ( tmp_str ) ;
<1> static int aasc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<11> buf += 4 ;\n<16> i >= 0 ;\n<18> memcpy ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , buf , avctx -> width * 3 ) ;\n<19> buf += stride ;
<1> bool CreateReplicationSlot ( PGconn * conn , const char * slot_name , const char * plugin , bool is_physical , bool slot_exists_ok ) {\n<7> if ( is_physical ) appendPQExpBuffer ( query , "CREATE_REPLICATION_SLOT \"%s\" PHYSICAL" , slot_name ) ;\n<8> else appendPQExpBuffer ( query , "CREATE_REPLICATION_SLOT \"%s\" LOGICAL \"%s\"" , slot_name , plugin ) ;\n<9> res = PQexec ( conn , query -> data ) ;\n<10> if ( PQresultStatus ( res ) != PGRES_TUPLES_OK ) {\n<12> if ( slot_exists_ok && sqlstate && strcmp ( sqlstate , ERRCODE_DUPLICATE_OBJECT ) == 0 ) {\n<13> destroyPQExpBuffer ( query ) ;\n<14> PQclear ( res ) ;\n<15> return true ;\n<18> fprintf ( stderr , _ ( "%s: could not send replication command \"%s\": %s" ) , progname , query -> data , PQerrorMessage ( conn ) ) ;\n<19> destroyPQExpBuffer ( query ) ;\n<20> PQclear ( res ) ;\n<21> return false ;\n<24> if ( PQntuples ( res ) != 1 || PQnfields ( res ) != 4 ) {\n<25> fprintf ( stderr , _ ( "%s: could not create replication slot \"%s\": got %d rows and %d fields, expected %d rows and %d fields\n" ) , progname , slot_name , PQntuples ( res ) , PQnfields ( res ) , 1 , 4 ) ;
<1> static void mdb_rtxn_snap ( Operation * op , ww_ctx * ww ) {\n<2> if ( ww -> mcd ) {\n<5> memcpy ( & ww -> key , key . mv_data , sizeof ( ID ) ) ;\n<7> ww -> data . mv_data = op -> o_tmpalloc ( data . mv_size , op -> o_tmpmemctx ) ;\n<8> memcpy ( ww -> data . mv_data , data . mv_data , data . mv_size ) ;
<1> static int rtp_packetize_split ( sout_stream_id_sys_t * id , block_t * in ) {\n<4> uint8_t * p_data = in -> p_buffer ;\n<8> i < i_count ;\n<10> int i_payload = __MIN ( i_max , i_data ) ;\n<13> memcpy ( & out -> p_buffer [ 12 ] , p_data , i_payload ) ;\n<17> p_data += i_payload ;\n<18> i_data -= i_payload ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n<2> BMVDecContext * const c = avctx -> priv_data ;\n<32> i ++ ) c -> pal [ i ] = bytestream_get_be24 ( & c -> stream ) ;\n<47> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<51> if ( decode_bmv_frame ( c -> stream , pkt -> size - ( c -> stream - pkt -> data ) , c -> frame , scr_off ) ) {\n<55> memcpy ( frame -> data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n<57> outptr = frame -> data [ 0 ] ;\n<58> srcptr = c -> frame ;\n<60> i < avctx -> height ;\n<62> memcpy ( outptr , srcptr , avctx -> width ) ;\n<63> srcptr += avctx -> width ;\n<64> outptr += frame -> linesize [ 0 ] ;
<1> PXA2xxState * pxa255_init ( MemoryRegion * address_space , unsigned int sdram_size ) {\n<7> if ( s -> cpu == NULL ) {\n<8> fprintf ( stderr , "Unable to find CPU definition\n" ) ;\n<23> if ( ! dinfo ) {\n<24> fprintf ( stderr , "qemu: missing SecureDigital device\n" ) ;
<1> main(\n<25> char *cert_names[MAX_CERTS];\n<35> if (socket_init() != 0)\n<47> if (cert_count >= MAX_CERTS) {\n<49> printf("too many certificates (max = %d)\n", MAX_CERTS);\n<95> if (cert_count > 0) {\n<107> if (emul_args == NULL) {\n<109> emul_args = (char *)"db=\"/etc/pki/nssdb\"";\n<117> len = strlen(emul_args) + strlen(SOFT_STRING) + 2;\n<119> for (i = 0; i < cert_count; i++) {\n<121> len += strlen(cert_names[i])+1; /* 1 == comma */\n<125> new_args = g_malloc(len);\n<127> strcpy(new_args, emul_args);\n<129> strcat(new_args, SOFT_STRING);\n<131> for (i = 0; i < cert_count; i++) {\n<133> strcat(new_args, cert_names[i]);\n<135> strcat(new_args, ",");\n<139> strcat(new_args, ")");\n<141> emul_args = new_args;\n<159> if (sock == -1) {\n<161> fprintf(stderr, "error opening socket, exiting.\n");\n<187> printf("> ");
<1> static void select_delta_tables ( TrueMotion1Context * s , int delta_table_index ) {\n<3> if ( delta_table_index > 3 ) return ;\n<4> memcpy ( s -> ydt , ydts [ delta_table_index ] , 8 * sizeof ( int16_t ) ) ;\n<5> memcpy ( s -> cdt , cdts [ delta_table_index ] , 8 * sizeof ( int16_t ) ) ;\n<6> memcpy ( s -> fat_ydt , fat_ydts [ delta_table_index ] , 8 * sizeof ( int16_t ) ) ;\n<7> memcpy ( s -> fat_cdt , fat_cdts [ delta_table_index ] , 8 * sizeof ( int16_t ) ) ;
<1> static int xan_decode_chroma ( AVCodecContext * avctx , unsigned chroma_off ) {\n<2> XanContext * s = avctx -> priv_data ;\n<20> if ( offset >= bytestream2_get_bytes_left ( & s -> gb ) ) {\n<25> memset ( s -> scratch_buffer , 0 , s -> buffer_size ) ;\n<26> dec_size = xan_unpack ( s , s -> scratch_buffer , s -> buffer_size ) ;\n<47> U [ i ] = uval | ( uval >> 5 ) ;\n<48> V [ i ] = vval | ( vval >> 5 ) ;\n<55> if ( avctx -> height & 1 ) {\n<56> memcpy ( U , U - s -> pic . linesize [ 1 ] , avctx -> width >> 1 ) ;\n<57> memcpy ( V , V - s -> pic . linesize [ 2 ] , avctx -> width >> 1 ) ;\n<74> U [ i ] = U [ i + 1 ] = U2 [ i ] = U2 [ i + 1 ] = uval | ( uval >> 5 ) ;\n<75> V [ i ] = V [ i + 1 ] = V2 [ i ] = V2 [ i + 1 ] = vval | ( vval >> 5 ) ;\n<83> if ( avctx -> height & 3 ) {\n<85> memcpy ( U , U - lines * s -> pic . linesize [ 1 ] , lines * s -> pic . linesize [ 1 ] ) ;\n<86> memcpy ( V , V - lines * s -> pic . linesize [ 2 ] , lines * s -> pic . linesize [ 2 ] ) ;
<1> int load_uimage(const char *filename, target_ulong *ep, target_ulong *loadaddr,\n<37> bswap_uboot_header(hdr);\n<49> if (hdr->ih_type == IH_TYPE_MULTI) {\n<51> fprintf(stderr, "Unable to load multi-file u-boot images\n");\n<59> switch (hdr->ih_comp) {\n<107> if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n<109> fprintf(stderr, "Error reading file\n");\n<139> if (bytes < 0) {\n<141> fprintf(stderr, "Unable to decompress gzipped image!\n");
<1> PHP_NAMED_FUNCTION ( zif_locale_set_default ) {\n<8> if ( len == 0 ) {\n<9> locale_name = ( char * ) uloc_getDefault ( ) ;\n<10> len = strlen ( locale_name ) ;\n<12> zend_alter_ini_entry ( LOCALE_INI_NAME , sizeof ( LOCALE_INI_NAME ) , locale_name , len , PHP_INI_USER , PHP_INI_STAGE_RUNTIME ) ;
<1> static int siff_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> SIFFContext *c = s->priv_data;\n<27> avio_read(s->pb, c->gmc, c->gmcsize);\n<39> size = c->pktsize - c->sndsize - c->gmcsize - 2;\n<47> if (av_new_packet(pkt, size + c->gmcsize + 2) < 0)\n<51> AV_WL16(pkt->data, c->flags);\n<53> if (c->gmcsize)\n<55> memcpy(pkt->data + 2, c->gmc, c->gmcsize);\n<57> avio_read(s->pb, pkt->data + 2 + c->gmcsize, size);
<1> gcry_sexp_t gcry_sexp_cdr ( const gcry_sexp_t list ) {\n<13> if ( * p == ST_DATA ) {\n<14> memcpy ( & n , ++ p , sizeof n ) ;\n<15> p += sizeof n + n ;\n<34> if ( * p == ST_DATA ) {\n<35> memcpy ( & n , ++ p , sizeof n ) ;\n<36> p += sizeof n + n ;\n<51> n = p - head ;\n<52> newlist = gcry_malloc ( sizeof * newlist + n + 2 ) ;\n<53> if ( ! newlist ) return NULL ;\n<55> * d ++ = ST_OPEN ;\n<56> memcpy ( d , head , n ) ;\n<57> d += n ;
<1> static int svq3_decode_slice_header(AVCodecContext *avctx)\n<7> H264Context *h    = &svq3->h;\n<69> if (length > 0) {\n<71> memcpy((uint8_t *) &s->gb.buffer[get_bits_count(&s->gb) >> 3],\n<73> &s->gb.buffer[s->gb.size_in_bits >> 3], length - 1);\n<149> if (s->mb_x > 0) {\n<151> memset(h->intra4x4_pred_mode + h->mb2br_xy[mb_xy - 1] + 3,\n<153> -1, 4 * sizeof(int8_t));\n<155> memset(h->intra4x4_pred_mode + h->mb2br_xy[mb_xy - s->mb_x],\n<157> -1, 8 * sizeof(int8_t) * s->mb_x);\n<161> if (s->mb_y > 0) {\n<163> memset(h->intra4x4_pred_mode + h->mb2br_xy[mb_xy - s->mb_stride],\n<165> -1, 8 * sizeof(int8_t) * (s->mb_width - s->mb_x));
<1> static int doTest(uint8_t *ref[3], int refStride[3], int w, int h, int srcFormat, int dstFormat,\n<5> uint8_t *src[3];\n<7> uint8_t *dst[3];\n<9> uint8_t *out[3];\n<25> for(i=0; i<3; i++){\n<49> src[i]= (uint8_t*) malloc(srcStride[i]*srcH);\n<51> dst[i]= (uint8_t*) malloc(dstStride[i]*dstH);\n<53> out[i]= (uint8_t*) malloc(refStride[i]*h);\n<55> if ((src[i] == NULL) || (dst[i] == NULL) || (out[i] == NULL)) {\n<75> if (srcContext == NULL) {\n<79> sws_format_name(PIX_FMT_YUV420P),\n<81> sws_format_name(srcFormat));\n<91> dstContext= sws_getContext(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, NULL, NULL, NULL);\n<93> if (dstContext == NULL) {\n<97> sws_format_name(srcFormat),\n<99> sws_format_name(dstFormat));\n<109> outContext= sws_getContext(dstW, dstH, dstFormat, w, h, PIX_FMT_YUV420P, flags, NULL, NULL, NULL);\n<111> if (outContext == NULL) {\n<115> sws_format_name(dstFormat),\n<117> sws_format_name(PIX_FMT_YUV420P));\n<135> sws_scale(dstContext, src, srcStride, 0, srcH, dst, dstStride);\n<137> sws_scale(outContext, dst, dstStride, 0, dstH, out, refStride);\n<163> ssdU/= w*h/4;\n<165> ssdV/= w*h/4;\n<169> if(ssdY>100 || ssdU>100 || ssdV>100){\n<171> printf(" %s %dx%d -> %s %4dx%4d flags=%2d SSD=%5lld,%5lld,%5lld\n",\n<173> sws_format_name(srcFormat), srcW, srcH,\n<175> sws_format_name(dstFormat), dstW, dstH,\n<197> for(i=0; i<3; i++){\n<199> free(src[i]);\n<201> free(dst[i]);\n<203> free(out[i]);
<1> static void pdf_run_BDC ( fz_context * ctx , pdf_processor * proc , const char * tag , pdf_obj * raw , pdf_obj * cooked ) {\n<4> if ( ! tag || strcmp ( tag , "OC" ) ) return ;\n<5> str = pdf_to_str_buf ( ctx , pdf_dict_get ( ctx , cooked , PDF_NAME_Name ) ) ;\n<6> if ( str == NULL ) str = "UnnamedLayer" ;\n<7> fz_begin_layer ( ctx , pr -> dev , str ) ;
<1> const char * evutil_getenv ( const char * varname ) {\n<2> if ( evutil_issetugid ( ) ) return NULL ;\n<3> return getenv ( varname ) ;
<1> static int mov_write_video_tag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)\n<65> avio_wb16(pb, 1); /* Frame count (= 1) */\n<71> find_compressor(compressor_name, 32, track);\n<73> avio_w8(pb, strlen(compressor_name));\n<75> avio_write(pb, compressor_name, 31);
<1> static void test_bind_result_ext1 ( ) {\n<14> ulong length [ 8 ] ;\n<25> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<59> i < array_elements ( my_bind ) ;\n<70> rc = mysql_stmt_fetch ( stmt ) ;\n<71> printf ( "rc=%d\n" , rc ) ;\n<72> DIE_UNLESS ( rc == 0 ) ;\n<73> if ( ! opt_silent ) {\n<74> fprintf ( stdout , "\n data (tiny) : %s(%lu)" , t_data , length [ 0 ] ) ;\n<75> fprintf ( stdout , "\n data (short) : %f(%lu)" , s_data , length [ 1 ] ) ;\n<76> fprintf ( stdout , "\n data (int) : %d(%lu)" , i_data , length [ 2 ] ) ;\n<77> fprintf ( stdout , "\n data (big) : %d(%lu)" , b_data , length [ 3 ] ) ;\n<78> fprintf ( stdout , "\n data (float) : %d(%lu)" , f_data , length [ 4 ] ) ;\n<79> fprintf ( stdout , "\n data (double) : %s(%lu)" , d_data , length [ 5 ] ) ;\n<80> fprintf ( stdout , "\n data (bin) : %ld(%lu)" , bData , length [ 6 ] ) ;\n<81> fprintf ( stdout , "\n data (str) : %g(%lu)" , szData , length [ 7 ] ) ;\n<83> DIE_UNLESS ( strcmp ( t_data , "120" ) == 0 ) ;\n<84> DIE_UNLESS ( i_data == 3999 ) ;\n<85> DIE_UNLESS ( f_data == 2 ) ;\n<86> DIE_UNLESS ( strcmp ( d_data , "58.89" ) == 0 ) ;\n<87> DIE_UNLESS ( b_data == 54 ) ;\n<88> DIE_UNLESS ( length [ 0 ] == 3 ) ;\n<89> DIE_UNLESS ( length [ 1 ] == 4 ) ;\n<90> DIE_UNLESS ( length [ 2 ] == 2 ) ;\n<91> DIE_UNLESS ( length [ 3 ] == 1 ) ;\n<92> DIE_UNLESS ( length [ 4 ] == 4 ) ;\n<93> DIE_UNLESS ( length [ 5 ] == 5 ) ;\n<94> DIE_UNLESS ( length [ 6 ] == 4 ) ;\n<95> DIE_UNLESS ( length [ 7 ] == 8 ) ;
<1> TSReturnCode TSCacheUrlSet ( TSHttpTxn txnp , const char * url , int length ) {\n<6> Debug ( "cache_url" , "[TSCacheUrlSet] changing the cache url to: %s" , url ) ;\n<7> if ( length == - 1 ) {\n<8> length = strlen ( url ) ;\n<12> sm -> t_state . cache_info . lookup_url -> parse ( url , length ) ;
<1> int dtls1_send_finished ( SSL * s , int a , int b , const char * sender , int slen ) {\n<5> if ( s -> state == a ) {\n<7> p = & ( d [ DTLS1_HM_HEADER_LENGTH ] ) ;\n<8> i = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . finish_md ) ;\n<10> memcpy ( p , s -> s3 -> tmp . finish_md , i ) ;\n<11> p += i ;\n<12> l = i ;\n<13> if ( s -> type == SSL_ST_CONNECT ) {\n<14> OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n<15> memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . finish_md , i ) ;\n<16> s -> s3 -> previous_client_finished_len = i ;\n<19> OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n<20> memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . finish_md , i ) ;\n<21> s -> s3 -> previous_server_finished_len = i ;
<1> static int set_str_utf16be ( struct archive_write * a , unsigned char * p , const char * s , size_t l , uint16_t uf , enum vdc vdc ) {\n<4> if ( s == NULL ) s = "" ;\n<10> if ( vdc == VDC_UCS2 ) {\n<12> if ( archive_strncpy_l ( & iso9660 -> utf16be , s , strlen ( s ) , iso9660 -> sconv_to_utf16be ) != 0 && errno == ENOMEM ) {\n<17> if ( size > l ) size = l ;\n<18> memcpy ( p , iso9660 -> utf16be . s , size ) ;\n<24> if ( size > l ) size = l ;\n<25> memcpy ( p , s , size ) ;\n<28> i < size ;\n<29> i += 2 , p += 2 ) {\n<30> if ( ! joliet_allowed_char ( p [ 0 ] , p [ 1 ] ) ) archive_be16enc ( p , 0x005F ) ;\n<34> archive_be16enc ( p , uf ) ;
<1> static int sd_snapshot_list(BlockDriverState *bs, QEMUSnapshotInfo **psn_tab)\n<35> fd = connect_to_sdog(s, &local_err);\n<37> if (fd < 0) {\n<57> memset(&req, 0, sizeof(req));\n<67> ret = do_req(fd, s->aio_context, (SheepdogReq *)&req,\n<75> if (ret) {\n<89> hval = fnv_64a_buf(s->name, strlen(s->name), FNV1A_64_INIT);\n<91> start_nr = hval & (SD_NR_VDIS - 1);\n<95> fd = connect_to_sdog(s, &local_err);\n<123> ret = read_object(fd, s->aio_context, (char *)&inode,\n<133> if (ret) {\n<141> if (!strcmp(inode.name, s->name) && is_snapshot(&inode)) {\n<143> sn_tab[found].date_sec = inode.snap_ctime >> 32;\n<145> sn_tab[found].date_nsec = inode.snap_ctime & 0xffffffff;\n<147> sn_tab[found].vm_state_size = inode.vm_state_size;\n<149> sn_tab[found].vm_clock_nsec = inode.vm_clock_nsec;\n<157> pstrcpy(sn_tab[found].name,\n<159> MIN(sizeof(sn_tab[found].name), sizeof(inode.tag)),\n<161> inode.tag);\n<163> found++;
<1> abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n<2049> p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n<2051> if (!p || !p2)\n<2057> if (strncmp((const char *)p, "/proc/self/exe", 14) == 0) {\n<2061> temp = realpath(exec_path,real);\n<2063> ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n<2065> snprintf((char *)p2, arg3, "%s", real);\n<2071> ret = get_errno(readlink(path(p), p2, arg3));\n<2075> unlock_user(p2, arg2, ret);
<1> void do_wait_for_slave_to_stop ( struct st_command * c __attribute__ ( ( unused ) ) ) {\n<11> if ( ! ( row = mysql_fetch_row ( res ) ) || ! row [ 1 ] ) {\n<15> done = ! strcmp ( row [ 1 ] , "OFF" ) ;\n<17> if ( done ) break ;
<1> static inline void code_gen_alloc ( size_t tb_size ) {\n<4> if ( tcg_ctx . code_gen_buffer == NULL ) {\n<5> fprintf ( stderr , "Could not allocate dynamic translator buffer\n" ) ;
<1> static int dtls1_reassemble_fragment ( SSL * s , const struct hm_header_st * msg_hdr , int * ok ) {\n<8> if ( frag_len == 0 ) return DTLS1_HM_FRAGMENT_RETRY ;\n<9> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<10> seq64be [ 6 ] = ( unsigned char ) ( msg_hdr -> seq >> 8 ) ;\n<12> item = pqueue_find ( s -> d1 -> buffered_messages , seq64be ) ;\n<14> frag = dtls1_hm_fragment_new ( msg_hdr -> msg_len , 1 ) ;\n<15> if ( frag == NULL ) goto err ;\n<16> memcpy ( & ( frag -> msg_header ) , msg_hdr , sizeof ( * msg_hdr ) ) ;\n<37> i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , NULL , frag -> fragment + msg_hdr -> frag_off , frag_len , 0 ) ;\n<40> RSMBLY_BITMASK_MARK ( frag -> reassembly , ( long ) msg_hdr -> frag_off , ( long ) ( msg_hdr -> frag_off + frag_len ) ) ;\n<41> RSMBLY_BITMASK_IS_COMPLETE ( frag -> reassembly , ( long ) msg_hdr -> msg_len , is_complete ) ;
<1> static void test_bug12744 ( ) {\n<8> if ( ! mysql_real_connect ( lmysql , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , 0 ) ) {\n<9> fprintf ( stderr , "Failed to connect to the database\n" ) ;
<1> static USBDevice *usb_host_device_open_addr(int bus_num, int addr, const char *prod_name)\n<17> printf("husb: open device %d.%d\n", bus_num, addr);\n<29> snprintf(buf, sizeof(buf), "%s/%03d/%03d", usb_host_device_path,\n<117> if (ret < 0) {\n<127> printf("husb: grabbed usb device %d.%d\n", bus_num, addr);\n<151> snprintf(dev->dev.devname, sizeof(dev->dev.devname),
<1> static uint64_t kvmppc_read_int_cpu_dt(const char *propname)\n<21> if (kvmppc_find_cpu_dt(buf, sizeof(buf))) {\n<29> strncat(buf, "/", sizeof(buf) - strlen(buf));\n<31> strncat(buf, propname, sizeof(buf) - strlen(buf));\n<35> f = fopen(buf, "rb");
<5> Hnm4VideoContext *hnm = avctx->priv_data;\n<27> if (hnm->version == 0x4a) {\n<29> memcpy(hnm->processed, hnm->current, hnm->width * hnm->height);\n<36> memcpy(frame->data[1], hnm->palette, 256 * 4);\n<38> hnm_flip_buffers(hnm);
<1> static int decode_header(SnowContext *s){\n<9> memset(kstate, MID_STATE, sizeof(kstate));\n<13> s->keyframe= get_rac(&s->c, kstate);\n<121> for(plane_index=0; plane_index<FFMIN(s->nb_planes, 2); plane_index++){\n<153> memcpy(s->plane[2].hcoeff, s->plane[1].hcoeff, sizeof(s->plane[1].hcoeff));
<1> static int sd_open(BlockDriverState *bs, QDict *options, int flags,\n<37> if (local_err) {\n<49> filename = qemu_opt_get(opts, "filename");\n<63> memset(vdi, 0, sizeof(vdi));\n<65> memset(tag, 0, sizeof(tag));\n<69> if (strstr(filename, "://")) {\n<71> ret = sd_parse_uri(s, filename, vdi, &snapid, tag);\n<75> ret = parse_vdiname(s, filename, vdi, &snapid, tag);\n<139> fd = connect_to_sdog(s, errp);\n<153> ret = read_object(fd, s->bs, buf, vid_to_vdi_oid(vid),\n<163> if (ret) {\n<173> memcpy(&s->inode, buf, sizeof(s->inode));\n<187> g_free(buf);
<1> static void test_bug14169 ( ) {\n<16> stmt = mysql_stmt_init ( mysql ) ;\n<17> stmt_text = "select f2,group_concat(f1) from t1 group by f2" ;\n<18> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<20> res = mysql_stmt_result_metadata ( stmt ) ;\n<22> if ( ! opt_silent ) printf ( "GROUP_CONCAT() result type %i" , field [ 1 ] . type ) ;\n<23> DIE_UNLESS ( field [ 1 ] . type == MYSQL_TYPE_BLOB ) ;
<1> static int tipc_nl_compat_name_table_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) {\n<2> char port_str [ 27 ] ;\n<28> if ( depth == 2 ) goto out ;\n<30> sprintf ( port_str , "<%u.%u.%u:%u>" , tipc_zone ( node ) , tipc_cluster ( node ) , tipc_node ( node ) , nla_get_u32 ( publ [ TIPC_NLA_PUBL_REF ] ) ) ;\n<31> tipc_tlv_sprintf ( msg -> rep , "%-26s " , port_str ) ;
<1> void qmp_guest_shutdown(bool has_mode, const char *mode, Error **err)\n<9> slog("guest-shutdown called, mode: %s", mode);\n<13> if (!has_mode || strcmp(mode, "powerdown") == 0) {\n<15> shutdown_flag |= EWX_POWEROFF;\n<17> } else if (strcmp(mode, "halt") == 0) {\n<19> shutdown_flag |= EWX_SHUTDOWN;\n<21> } else if (strcmp(mode, "reboot") == 0) {\n<23> shutdown_flag |= EWX_REBOOT;\n<27> error_set(err, QERR_INVALID_PARAMETER_VALUE, "mode",\n<31> return;\n<41> acquire_privilege(SE_SHUTDOWN_NAME, err);\n<43> if (error_is_set(err)) {
<1> static void ppc_heathrow_init(MachineState *machine)\n<79> if (cpu == NULL) {\n<81> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<103> if (ram_size > (2047 << 20)) {\n<109> ((unsigned int)ram_size / (1 << 20)));\n<301> if (ppc_boot_device == '\0') {\n<303> fprintf(stderr, "No valid boot device for G3 Beige machine\n");
<1> int doqueryex ( int opcode , associd_t associd , int auth , int qsize , const char * qdata , u_short * rstatus , int * rsize , const char * * rdata , int quiet ) {\n<4> if ( ! havehost ) {\n<5> fprintf ( stderr , "***No host open, use `host' command\n" ) ;
<1> int jbig2_immediate_generic_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n<4> int8_t gbat [ 8 ] ;\n<6> uint32_t gbat_bytes = 0 ;\n<14> jbig2_get_region_segment_info ( & rsi , segment_data ) ;\n<19> if ( ! ( seg_flags & 1 ) ) {\n<20> gbat_bytes = ( seg_flags & 6 ) ? 2 : 8 ;\n<21> if ( 18 + gbat_bytes > segment -> data_length ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Segment too short" ) ;\n<22> memcpy ( gbat , segment_data + 18 , gbat_bytes ) ;\n<23> jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , "gbat: %d, %d" , gbat [ 0 ] , gbat [ 1 ] ) ;\n<25> offset = 18 + gbat_bytes ;\n<30> memcpy ( params . gbat , gbat , gbat_bytes ) ;\n<35> code = jbig2_decode_generic_mmr ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , image ) ;\n<39> GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n<40> if ( GB_stats == NULL ) {\n<44> memset ( GB_stats , 0 , stats_size ) ;\n<55> code = jbig2_decode_generic_region ( ctx , segment , & params , as , image , GB_stats ) ;\n<61> jbig2_free ( ctx -> allocator , GB_stats ) ;
<1> static void test_bug27592 ( ) {\n<14> memset ( bind , 0 , sizeof ( bind ) ) ;\n<29> rc = mysql_stmt_bind_param ( stmt , bind ) ;
<1> static struct evhttp * evhttp_new_object ( void ) {\n<3> if ( ( http = calloc ( 1 , sizeof ( struct evhttp ) ) ) == NULL ) {\n<4> event_warn ( "%s: calloc" , __func__ ) ;\n<5> return ( NULL ) ;\n<7> http -> timeout = - 1 ;\n<8> TAILQ_INIT ( & http -> sockets ) ;\n<9> TAILQ_INIT ( & http -> callbacks ) ;\n<10> TAILQ_INIT ( & http -> connections ) ;\n<11> return ( http ) ;
<1> static void help ( ) {\n<3> fprintf ( stderr , "iodine IP over DNS tunneling server\n" ) ;\n<4> fprintf ( stderr , "Usage: %s [-v] [-h] [-c] [-s] [-f] [-D] [-u user] " "[-t chrootdir] [-d device] [-m mtu] [-z context] " "[-l ip address to listen on] [-p port] [-n external ip] [-b dnsport] [-P password] " "[-F pidfile] tunnel_ip[etmask] topdomain\n" , __progname ) ;\n<5> fprintf ( stderr , " -v to print version info and exit\n" ) ;\n<6> fprintf ( stderr , " -h to print this help and exit\n" ) ;\n<7> fprintf ( stderr , " -c to disable check of client IP/port on each request\n" ) ;\n<8> fprintf ( stderr , " -s to skip creating and configuring the tun device, " "which then has to be created manually\n" ) ;\n<9> fprintf ( stderr , " -f to keep running in foreground\n" ) ;\n<10> fprintf ( stderr , " -D to increase debug level\n" ) ;\n<11> fprintf ( stderr , " (using -DD in UTF-8 terminal: \"LC_ALL=C luit iodined -DD ...\")\n" ) ;\n<12> fprintf ( stderr , " -u name to drop privileges and run as user 'name'\n" ) ;\n<13> fprintf ( stderr , " -t dir to chroot to directory dir\n" ) ;\n<14> fprintf ( stderr , " -d device to set tunnel device name\n" ) ;\n<15> fprintf ( stderr , " -m mtu to set tunnel device mtu\n" ) ;\n<16> fprintf ( stderr , " -z context to apply SELinux context after initialization\n" ) ;\n<17> fprintf ( stderr , " -l ip address to listen on for incoming dns traffic " "(default 0.0.0.0)\n" ) ;\n<18> fprintf ( stderr , " -p port to listen on for incoming dns traffic (default 53)\n" ) ;\n<19> fprintf ( stderr , " -n ip to respond with to NS queries\n" ) ;\n<20> fprintf ( stderr , " -b port to forward normal DNS queries to (on localhost)\n" ) ;\n<21> fprintf ( stderr , " -P password used for authentication (max 32 chars will be used)\n" ) ;\n<22> fprintf ( stderr , " -F pidfile to write pid to a file\n" ) ;\n<23> fprintf ( stderr , " -i maximum idle time before shutting down\n" ) ;\n<24> fprintf ( stderr , "tunnel_ip is the IP number of the local tunnel interface.\n" ) ;\n<25> fprintf ( stderr , " etmask sets the size of the tunnel network.\n" ) ;\n<26> fprintf ( stderr , "topdomain is the FQDN that is delegated to this server.\n" ) ;
<1> int ec_strsplit_ipport ( char * input , char * ip , u_int16 * port ) {\n<2> static char ip_tmp [ MAX_ASCII_ADDR_LEN ] ;\n<3> if ( sscanf ( input , "%20[0-9.]:%hu" , ip_tmp , port ) == 2 ) {\n<4> strncpy ( ip , ip_tmp , strlen ( ip_tmp ) + 1 ) ;\n<5> return E_SUCCESS ;\n<7> if ( sscanf ( input , "[%40[0-9a-fA-F:.]]:%hu" , ip_tmp , port ) == 2 ) {\n<8> strncpy ( ip , ip_tmp , strlen ( ip_tmp ) + 1 ) ;\n<9> return E_SUCCESS ;\n<11> DEBUG_MSG ( "ec_strsplit_ipport(): error splitting ip:port: '%s'\n" , input ) ;\n<12> return - E_INVALID ;
<1> static void gen_test_cc(int cc, int label)\n<13> switch (cc) {\n<185> fprintf(stderr, "Bad condition code 0x%x\n", cc);
<1> static void e1000_reset(void *opaque)\n<5> E1000State *d = opaque;\n<13> memset(d->phy_reg, 0, sizeof d->phy_reg);\n<15> memmove(d->phy_reg, phy_reg_init, sizeof phy_reg_init);\n<17> memset(d->mac_reg, 0, sizeof d->mac_reg);\n<19> memmove(d->mac_reg, mac_reg_init, sizeof mac_reg_init);\n<23> memset(&d->tx, 0, sizeof d->tx);\n<29> e1000_link_down(d);
<1> static void spapr_phb_realize(DeviceState *dev, Error **errp)\n<9> sPAPRPHBState *sphb = SPAPR_PCI_HOST_BRIDGE(s);\n<117> if (spapr_pci_find_phb(spapr, sphb->buid)) {\n<131> namebuf = alloca(strlen(sphb->dtbusname) + 32);\n<137> sprintf(namebuf, "%s.mmio", sphb->dtbusname);\n<139> memory_region_init(&sphb->memspace, OBJECT(sphb), namebuf, UINT64_MAX);\n<143> sprintf(namebuf, "%s.mmio-alias", sphb->dtbusname);\n<145> memory_region_init_alias(&sphb->memwindow, OBJECT(sphb),\n<159> sprintf(namebuf, "%s.io", sphb->dtbusname);\n<161> memory_region_init(&sphb->iospace, OBJECT(sphb),\n<167> sprintf(namebuf, "%s.io-alias", sphb->dtbusname);\n<169> memory_region_init_alias(&sphb->iowindow, OBJECT(sphb), namebuf,\n<189> qbus_set_hotplug_handler(BUS(phb->bus), DEVICE(sphb), NULL);\n<207> sprintf(namebuf, "%s.iommu-root", sphb->dtbusname);\n<211> memory_region_init(&sphb->iommu_root, OBJECT(sphb),\n<215> address_space_init(&sphb->iommu_as, &sphb->iommu_root,
<1> static void help ( const char * progname ) {\n<2> printf ( _ ( "%s reindexes a PostgreSQL database.\n\n" ) , progname ) ;\n<3> printf ( _ ( "Usage:\n" ) ) ;\n<4> printf ( _ ( " %s [OPTION]... [DBNAME]\n" ) , progname ) ;\n<5> printf ( _ ( "\nOptions:\n" ) ) ;\n<6> printf ( _ ( " -a, --all reindex all databases\n" ) ) ;\n<7> printf ( _ ( " -d, --dbname=DBNAME database to reindex\n" ) ) ;\n<8> printf ( _ ( " -e, --echo show the commands being sent to the server\n" ) ) ;\n<9> printf ( _ ( " -i, --index=INDEX recreate specific index(es) only\n" ) ) ;\n<10> printf ( _ ( " -q, --quiet don't write any messages\n" ) ) ;\n<11> printf ( _ ( " -s, --system reindex system catalogs\n" ) ) ;\n<12> printf ( _ ( " -S, --schema=SCHEMA reindex specific schema(s) only\n" ) ) ;\n<13> printf ( _ ( " -t, --table=TABLE reindex specific table(s) only\n" ) ) ;\n<14> printf ( _ ( " -v, --verbose write a lot of output\n" ) ) ;\n<15> printf ( _ ( " -V, --version output version information, then exit\n" ) ) ;\n<16> printf ( _ ( " -?, --help show this help, then exit\n" ) ) ;\n<17> printf ( _ ( "\nConnection options:\n" ) ) ;\n<18> printf ( _ ( " -h, --host=HOSTNAME database server host or socket directory\n" ) ) ;\n<19> printf ( _ ( " -p, --port=PORT database server port\n" ) ) ;\n<20> printf ( _ ( " -U, --username=USERNAME user name to connect as\n" ) ) ;\n<21> printf ( _ ( " -w, --no-password never prompt for password\n" ) ) ;\n<22> printf ( _ ( " -W, --password force password prompt\n" ) ) ;\n<23> printf ( _ ( " --maintenance-db=DBNAME alternate maintenance database\n" ) ) ;\n<24> printf ( _ ( "\nRead the description of the SQL command REINDEX for details.\n" ) ) ;\n<25> printf ( _ ( "\nReport bugs to <pgsql-bugs@postgresql.org>.\n" ) ) ;
<1> static int fill_default_ref_list(H264Context *h){\n<151> if(index < h->ref_count[ list ])\n<153> memset(&h->default_ref_list[list][index], 0, sizeof(Picture)*(h->ref_count[ list ] - index));\n<183> if(index < h->ref_count[0])\n<185> memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));
<1> int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) {\n<17> if ( buffer [ i ] == '\n' ) break ;\n<19> if ( _nskip > 0 ) return - 1 ;\n<25> buffer [ i ] = '\0' ;\n<26> if ( memcmp ( buffer , "YUV4MPEG" , 8 ) ) {\n<27> fprintf ( stderr , "Incomplete magic for YUV4MPEG file.\n" ) ;\n<28> return - 1 ;\n<30> if ( buffer [ 8 ] != '2' ) {\n<34> ret = y4m_parse_tags ( _y4m , buffer + 5 ) ;\n<35> if ( ret < 0 ) {\n<36> fprintf ( stderr , "Error parsing YUV4MPEG2 header.\n" ) ;\n<51> if ( strcmp ( _y4m -> chroma_type , "420" ) == 0 || strcmp ( _y4m -> chroma_type , "420jpeg" ) == 0 ) {\n<52> _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;\n<53> _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;\n<54> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n<55> _y4m -> convert = y4m_convert_null ;\n<57> else if ( strcmp ( _y4m -> chroma_type , "420p10" ) == 0 ) {\n<58> _y4m -> src_c_dec_h = 2 ;\n<59> _y4m -> dst_c_dec_h = 2 ;\n<60> _y4m -> src_c_dec_v = 2 ;\n<61> _y4m -> dst_c_dec_v = 2 ;\n<62> _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ;\n<63> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n<64> _y4m -> convert = y4m_convert_null ;\n<65> _y4m -> bit_depth = 10 ;\n<66> _y4m -> bps = 15 ;\n<67> _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ;\n<68> if ( only_420 ) {\n<69> fprintf ( stderr , "Unsupported conversion from 420p10 to 420jpeg\n" ) ;\n<73> else if ( strcmp ( _y4m -> chroma_type , "420p12" ) == 0 ) {\n<74> _y4m -> src_c_dec_h = 2 ;\n<75> _y4m -> dst_c_dec_h = 2 ;\n<76> _y4m -> src_c_dec_v = 2 ;\n<77> _y4m -> dst_c_dec_v = 2 ;\n<78> _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ) ;\n<79> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n<80> _y4m -> convert = y4m_convert_null ;\n<81> _y4m -> bit_depth = 12 ;\n<82> _y4m -> bps = 18 ;\n<83> _y4m -> vpx_fmt = VPX_IMG_FMT_I42016 ;\n<84> if ( only_420 ) {\n<85> fprintf ( stderr , "Unsupported conversion from 420p12 to 420jpeg\n" ) ;\n<89> else if ( strcmp ( _y4m -> chroma_type , "420mpeg2" ) == 0 ) {\n<90> _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;\n<91> _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n<92> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;\n<93> _y4m -> convert = y4m_convert_42xmpeg2_42xjpeg ;\n<95> else if ( strcmp ( _y4m -> chroma_type , "420paldv" ) == 0 ) {\n<96> _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = _y4m -> src_c_dec_v = _y4m -> dst_c_dec_v = 2 ;\n<97> _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n<98> _y4m -> aux_buf_sz = 3 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;\n<99> _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * ( ( _y4m -> pic_h + 1 ) / 2 ) ;\n<100> _y4m -> convert = y4m_convert_42xpaldv_42xjpeg ;\n<102> else if ( strcmp ( _y4m -> chroma_type , "422jpeg" ) == 0 ) {\n<103> _y4m -> src_c_dec_h = _y4m -> dst_c_dec_h = 2 ;\n<104> _y4m -> src_c_dec_v = 1 ;\n<105> _y4m -> dst_c_dec_v = 2 ;\n<106> _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n<107> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;\n<108> _y4m -> convert = y4m_convert_422jpeg_420jpeg ;\n<110> else if ( strcmp ( _y4m -> chroma_type , "422" ) == 0 ) {\n<111> _y4m -> src_c_dec_h = 2 ;\n<112> _y4m -> src_c_dec_v = 1 ;\n<113> if ( only_420 ) {\n<131> else if ( strcmp ( _y4m -> chroma_type , "422p10" ) == 0 ) {\n<132> _y4m -> src_c_dec_h = 2 ;\n<133> _y4m -> src_c_dec_v = 1 ;\n<134> _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ;\n<135> _y4m -> bps = 20 ;\n<136> _y4m -> bit_depth = 10 ;\n<137> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n<138> _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n<139> _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ;\n<140> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n<141> _y4m -> convert = y4m_convert_null ;\n<142> if ( only_420 ) {\n<143> fprintf ( stderr , "Unsupported conversion from 422p10 to 420jpeg\n" ) ;\n<147> else if ( strcmp ( _y4m -> chroma_type , "422p12" ) == 0 ) {\n<148> _y4m -> src_c_dec_h = 2 ;\n<149> _y4m -> src_c_dec_v = 1 ;\n<150> _y4m -> vpx_fmt = VPX_IMG_FMT_I42216 ;\n<151> _y4m -> bps = 24 ;\n<152> _y4m -> bit_depth = 12 ;\n<153> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n<154> _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n<155> _y4m -> dst_buf_read_sz = 2 * ( _y4m -> pic_w * _y4m -> pic_h + * ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ) ;\n<156> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n<157> _y4m -> convert = y4m_convert_null ;\n<158> if ( only_420 ) {\n<159> fprintf ( stderr , "Unsupported conversion from 422p12 to 420jpeg\n" ) ;\n<163> else if ( strcmp ( _y4m -> chroma_type , "411" ) == 0 ) {\n<164> _y4m -> src_c_dec_h = 4 ;\n<165> _y4m -> dst_c_dec_h = 2 ;\n<166> _y4m -> src_c_dec_v = 1 ;\n<167> _y4m -> dst_c_dec_v = 2 ;\n<168> _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n<169> _y4m -> aux_buf_read_sz = 2 * ( ( _y4m -> pic_w + 3 ) / 4 ) * _y4m -> pic_h ;\n<170> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz + ( ( _y4m -> pic_w + 1 ) / 2 ) * _y4m -> pic_h ;\n<171> _y4m -> convert = y4m_convert_411_420jpeg ;\n<173> else if ( strcmp ( _y4m -> chroma_type , "444" ) == 0 ) {\n<174> _y4m -> src_c_dec_h = 1 ;\n<175> _y4m -> src_c_dec_v = 1 ;\n<176> if ( only_420 ) {\n<194> else if ( strcmp ( _y4m -> chroma_type , "444p10" ) == 0 ) {\n<195> _y4m -> src_c_dec_h = 1 ;\n<196> _y4m -> src_c_dec_v = 1 ;\n<197> _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ;\n<198> _y4m -> bps = 30 ;\n<199> _y4m -> bit_depth = 10 ;\n<200> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n<201> _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n<202> _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ;\n<203> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n<204> _y4m -> convert = y4m_convert_null ;\n<205> if ( only_420 ) {\n<206> fprintf ( stderr , "Unsupported conversion from 444p10 to 420jpeg\n" ) ;\n<210> else if ( strcmp ( _y4m -> chroma_type , "444p12" ) == 0 ) {\n<211> _y4m -> src_c_dec_h = 1 ;\n<212> _y4m -> src_c_dec_v = 1 ;\n<213> _y4m -> vpx_fmt = VPX_IMG_FMT_I44416 ;\n<214> _y4m -> bps = 36 ;\n<215> _y4m -> bit_depth = 12 ;\n<216> _y4m -> dst_c_dec_h = _y4m -> src_c_dec_h ;\n<217> _y4m -> dst_c_dec_v = _y4m -> src_c_dec_v ;\n<218> _y4m -> dst_buf_read_sz = 2 * 3 * _y4m -> pic_w * _y4m -> pic_h ;\n<219> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n<220> _y4m -> convert = y4m_convert_null ;\n<221> if ( only_420 ) {\n<222> fprintf ( stderr , "Unsupported conversion from 444p12 to 420jpeg\n" ) ;\n<226> else if ( strcmp ( _y4m -> chroma_type , "444alpha" ) == 0 ) {\n<227> _y4m -> src_c_dec_h = 1 ;\n<228> _y4m -> src_c_dec_v = 1 ;\n<229> if ( only_420 ) {\n<246> else if ( strcmp ( _y4m -> chroma_type , "mono" ) == 0 ) {\n<247> _y4m -> src_c_dec_h = _y4m -> src_c_dec_v = 0 ;\n<248> _y4m -> dst_c_dec_h = _y4m -> dst_c_dec_v = 2 ;\n<249> _y4m -> dst_buf_read_sz = _y4m -> pic_w * _y4m -> pic_h ;\n<250> _y4m -> aux_buf_sz = _y4m -> aux_buf_read_sz = 0 ;\n<251> _y4m -> convert = y4m_convert_mono_420jpeg ;\n<254> fprintf ( stderr , "Unknown chroma sampling type: %s\n" , _y4m -> chroma_type ) ;\n<255> return - 1 ;\n<257> _y4m -> dst_buf_sz = _y4m -> pic_w * _y4m -> pic_h + 2 * ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;\n<258> if ( _y4m -> bit_depth == 8 ) _y4m -> dst_buf = ( unsigned char * ) malloc ( _y4m -> dst_buf_sz ) ;\n<259> else _y4m -> dst_buf = ( unsigned char * ) malloc ( 2 * _y4m -> dst_buf_sz ) ;\n<260> if ( _y4m -> aux_buf_sz > 0 ) _y4m -> aux_buf = ( unsigned char * ) malloc ( _y4m -> aux_buf_sz ) ;\n<261> return 0 ;
<1> static int draw_text(AVFilterContext *ctx, AVFilterBufferRef *picref,\n<7> DrawTextContext *dtext = ctx->priv;\n<49> if (!buf) {\n<51> buf_size = 2*strlen(dtext->text)+1;\n<53> buf = av_malloc(buf_size);\n<65> if(strchr(dtext->text, '%'))\n<67> ltime= *localtime(&now);\n<77> if (strftime(buf, buf_size, dtext->text, &ltime) != 0 || *buf == 0)\n<100> if (!buf)\n<104> text = dtext->expanded_text = buf;\n<108> if ((len = strlen(text)) > dtext->nb_positions) {\n<110> if (!(dtext->positions =\n<112> av_realloc(dtext->positions, len*sizeof(*dtext->positions))))\n<122> x = 0;\n<124> y = 0;\n<130> for (i = 0, p = text; *p; i++) {\n<160> dtext->max_glyph_h = y_max - y_min;\n<162> dtext->max_glyph_w = x_max - x_min;\n<168> glyph = NULL;\n<170> for (i = 0, p = text; *p; i++) {\n<238> max_text_line_w = FFMAX(x, max_text_line_w);\n<242> dtext->var_values[VAR_TW] = dtext->var_values[VAR_TEXT_W] = max_text_line_w;\n<244> dtext->var_values[VAR_TH] = dtext->var_values[VAR_TEXT_H] = y + dtext->max_glyph_h;\n<248> dtext->var_values[VAR_MAX_GLYPH_W] = dtext->max_glyph_w;\n<250> dtext->var_values[VAR_MAX_GLYPH_H] = dtext->max_glyph_h;\n<252> dtext->var_values[VAR_MAX_GLYPH_A] = dtext->var_values[VAR_ASCENT ] = y_max;\n<254> dtext->var_values[VAR_MAX_GLYPH_D] = dtext->var_values[VAR_DESCENT] = y_min;\n<258> dtext->var_values[VAR_LINE_H] = dtext->var_values[VAR_LH] = dtext->max_glyph_h;\n<262> dtext->x = dtext->var_values[VAR_X] = av_expr_eval(dtext->x_pexpr, dtext->var_values, &dtext->prng);\n<264> dtext->y = dtext->var_values[VAR_Y] = av_expr_eval(dtext->y_pexpr, dtext->var_values, &dtext->prng);\n<266> dtext->x = dtext->var_values[VAR_X] = av_expr_eval(dtext->x_pexpr, dtext->var_values, &dtext->prng);\n<268> dtext->draw = av_expr_eval(dtext->draw_pexpr, dtext->var_values, &dtext->prng);\n<272> if(!dtext->draw)\n<298> if ((ret = draw_glyphs(dtext, picref, width, height, dtext->shadowcolor.rgba,\n<308> if ((ret = draw_glyphs(dtext, picref, width, height, dtext->fontcolor.rgba,
<1> static int window(venc_context_t * venc, signed short * audio, int samples) {\n<21> for (channel = 0; channel < venc->channels; channel++) {\n<23> memcpy(venc->samples + channel*window_len*2, venc->saved + channel*window_len, sizeof(float)*window_len);\n<29> for (channel = 0; channel < venc->channels; channel++) {\n<31> memset(venc->samples + channel*window_len*2, 0, sizeof(float)*window_len);\n<55> for (channel = 0; channel < venc->channels; channel++) {\n<57> memset(venc->samples + channel*window_len*2 + window_len, 0, sizeof(float)*window_len);
<1> void appendStringLiteralDQ ( PQExpBuffer buf , const char * str , const char * dqprefix ) {\n<5> appendPQExpBufferChar ( delimBuf , '$' ) ;\n<6> if ( dqprefix ) appendPQExpBufferStr ( delimBuf , dqprefix ) ;\n<7> while ( strstr ( str , delimBuf -> data ) != NULL ) {\n<8> appendPQExpBufferChar ( delimBuf , suffixes [ nextchar ++ ] ) ;\n<9> nextchar %= sizeof ( suffixes ) - 1 ;\n<11> appendPQExpBufferChar ( delimBuf , '$' ) ;\n<12> appendPQExpBufferStr ( buf , delimBuf -> data ) ;\n<13> appendPQExpBufferStr ( buf , str ) ;
<1> static void print_report(AVFormatContext **output_files,\n<9> char buf[1024];\n<23> static int64_t last_time = -1;\n<37> if (last_time == -1) {\n<69> buf[0] = '\0';\n<83> if (vid && enc->codec_type == CODEC_TYPE_VIDEO) {\n<85> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ",\n<87> enc->coded_frame->quality/(float)FF_QP2LAMBDA);\n<91> if (!vid && enc->codec_type == CODEC_TYPE_VIDEO) {\n<97> frame_number = ost->frame_number;\n<99> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ",\n<101> frame_number, (t>1)?(int)(frame_number/t+0.5) : 0,\n<103> enc->coded_frame ? enc->coded_frame->quality/(float)FF_QP2LAMBDA : -1);\n<105> if(is_last_report)\n<107> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L");\n<113> int qp= lrintf(enc->coded_frame->quality/(float)FF_QP2LAMBDA);\n<119> for(j=0; j<32; j++)\n<121> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log(qp_histogram[j]+1)/log(2)));\n<125> if (enc->flags&CODEC_FLAG_PSNR){\n<133> char type[3]= {'Y','U','V'};\n<135> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR=");\n<137> for(j=0; j<3; j++){\n<143> scale= enc->width*enc->height*255.0*255.0*frame_number;\n<159> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[j], psnr(error/scale));\n<163> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum/scale_sum));\n<187> if (verbose || is_last_report) {\n<189> bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n<193> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<197> (double)total_size / 1024, ti1, bitrate);\n<201> if (verbose > 1)\n<203> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d",\n<209> if (verbose >= 0)\n<211> fprintf(stderr, "%s    \r", buf);\n<215> fflush(stderr);\n<221> if (is_last_report && verbose >= 0){\n<225> fprintf(stderr, "\n");\n<227> fprintf(stderr, "video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n",\n<229> video_size/1024.0,\n<231> audio_size/1024.0,\n<233> extra_size/1024.0,\n<235> 100.0*(total_size - raw)/raw
<1> void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)\n<11> char line[1024];\n<25> if (level > av_log_level)\n<29> line[0] = 0;\n<31> if (print_prefix && avc) {\n<49> snprintf(line + strlen(line), sizeof(line) - strlen(line), "[%s @ %p] ",\n<51> avc->item_name(avcl), avcl);\n<57> vsnprintf(line + strlen(line), sizeof(line) - strlen(line), fmt, vl);\n<61> print_prefix = strlen(line) && line[strlen(line) - 1] == '\n';\n<75> if (print_prefix && (flags & AV_LOG_SKIP_REPEATED) &&\n<77> !strncmp(line, prev, sizeof line)) {\n<79> count++;\n<81> if (is_atty == 1)\n<83> fprintf(stderr, "    Last message repeated %d times\r", count);\n<89> if (count > 0) {\n<91> fprintf(stderr, "    Last message repeated %d times\n", count);\n<97> colored_fputs(av_clip(level >> 3, 0, 6), tint, line);\n<99> av_strlcpy(prev, line, sizeof line);
<1> static void img_buf_free ( void * memblk ) {\n<2> if ( memblk ) {\n<3> void * addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ;\n<4> free ( addr ) ;
<1> static int adb_forward ( char * serial_number , const char * adb_server_ip , unsigned short * adb_server_tcp_port , unsigned short local_tcp_port , unsigned short server_tcp_port ) {\n<8> if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_5 ;\n<9> result = g_snprintf ( helpful_packet , PACKET_LENGTH , adb_forward_template , ( serial_number ) ? 5 + 7 + strlen ( serial_number ) + 28 : 4 + 28 , ( serial_number ) ? "host-serial:" : "host" , ( serial_number ) ? serial_number : "" , local_tcp_port , server_tcp_port ) ;
<1> static int pxa2xx_clkcfg_write ( CPUARMState * env , const ARMCPRegInfo * ri , uint64_t value ) {\n<4> if ( value & 2 ) {\n<5> printf ( "%s: CPU frequency change attempt\n" , __func__ ) ;
<1> int dwarf_elf_object_access_init ( dwarf_elf_handle elf , int libdwarf_owns_elf , Dwarf_Obj_Access_Interface * * ret_obj , int * err ) {\n<5> internals = malloc ( sizeof ( dwarf_elf_object_access_internals_t ) ) ;\n<6> if ( ! internals ) {\n<10> memset ( internals , 0 , sizeof ( * internals ) ) ;\n<11> res = dwarf_elf_object_access_internals_init ( internals , elf , err ) ;\n<12> if ( res != DW_DLV_OK ) {\n<13> free ( internals ) ;\n<16> internals -> libdwarf_owns_elf = libdwarf_owns_elf ;\n<17> intfc = malloc ( sizeof ( Dwarf_Obj_Access_Interface ) ) ;\n<18> if ( ! intfc ) {\n<20> free ( internals ) ;
<1> static void object_set_link_property(Object *obj, Visitor *v, void *opaque,\n<21> visit_type_str(v, &path, name, errp);\n<33> if (strcmp(path, "") != 0) {\n<39> target = object_resolve_path(path, &ambiguous);\n<41> if (target) {\n<47> target_type = g_strdup(&type[5]);\n<49> target_type[strlen(target_type) - 2] = 0;\n<53> if (object_dynamic_cast(target, target_type)) {\n<67> g_free(target_type);\n<77> *child = NULL;\n<83> g_free(path);
<1> static void show_warnings_before_error ( MYSQL * mysql ) {\n<13> if ( mysql_num_rows ( res ) <= 1 ) {\n<19> fprintf ( stderr , "\nWarnings from just before the error:\n" ) ;\n<20> while ( ( row = mysql_fetch_row ( res ) ) ) {\n<22> unsigned long * lengths = mysql_fetch_lengths ( res ) ;\n<23> if ( ++ row_num >= mysql_num_rows ( res ) ) {\n<27> i < num_fields ;\n<29> fprintf ( stderr , "%.*s " , ( int ) lengths [ i ] , row [ i ] ? row [ i ] : "NULL" ) ;\n<31> fprintf ( stderr , "\n" ) ;
<1> static void mp_decode_frame_helper(MotionPixelsContext *mp, GetBitContext *gb)\n<6> if (mp->changes_map[y * mp->avctx->width] != 0) {\n<7> memset(mp->gradient_scale, 1, sizeof(mp->gradient_scale));\n<8> p = mp_get_yuv_from_rgb(mp, 0, y);\n<10> p.y += mp_gradient(mp, 0, mp_get_vlc(mp, gb));\n<13> p.v += mp_gradient(mp, 1, mp_get_vlc(mp, gb));\n<15> p.u += mp_gradient(mp, 2, mp_get_vlc(mp, gb));\n<19> mp_set_rgb_from_yuv(mp, 0, y, &p);\n<24> mp_decode_line(mp, gb, y);
<1> int ff_fill_line_with_color(uint8_t *line[4], int pixel_step[4], int w, uint8_t dst_color[4],\n<5> int *is_packed_rgba, uint8_t rgba_map_ptr[4])\n<19> *is_packed_rgba = ff_fill_rgba_map(rgba_map, pix_fmt) >= 0;\n<29> dst_color[rgba_map[i]] = rgba_color[i];\n<33> line[0] = av_malloc_array(w, pixel_step[0]);\n<37> for (i = 0; i < w; i++)\n<39> memcpy(line[0] + i * pixel_step[0], dst_color, pixel_step[0]);\n<41> if (rgba_map_ptr)\n<43> memcpy(rgba_map_ptr, rgba_map, sizeof(rgba_map[0]) * 4);\n<61> for (plane = 0; plane < 4; plane++) {\n<73> line[plane] = av_malloc(line_size);\n<75> if (!line[plane]) {\n<84> memset(line[plane], dst_color[plane], line_size);
<1> static int mi_sort_records ( MI_CHECK * param , register MI_INFO * info , char * name , uint sort_key , my_bool write_info , my_bool update_index ) {\n<28> mi_check_print_warning ( param , "Can't sort table '%s' on FULLTEXT key %d" , name , sort_key + 1 ) ;\n<33> mi_check_print_warning ( param , "Can't sort read-only table '%s'" , name ) ;\n<37> if ( ! ( param -> testflag & T_SILENT ) ) {\n<38> printf ( "- Sorting records for MyISAM-table '%s'\n" , name ) ;\n<39> if ( write_info ) printf ( "Data records: %9s Deleted: %9s\n" , llstr ( info -> state -> records , llbuff ) , llstr ( info -> state -> del , llbuff2 ) ) ;\n<53> fn_format ( param -> temp_filename , name , "" , MI_NAME_DEXT , 2 + 4 + 32 ) ;
<1> static void crl_uri_destroy ( x509_cdp_t * this ) {\n<2> free ( this -> uri ) ;\n<3> DESTROY_IF ( this -> issuer ) ;\n<4> free ( this ) ;
<1> int ff_dirac_golomb_read_32bit(DiracGolombLUT *lut_ctx, const uint8_t *buf,\n<5> int32_t *dst = (int32_t *)_dst;\n<6> DiracGolombLUT *future[4], *l = &lut_ctx[2*LUT_SIZE + buf[0]];\n<13> if ((c_idx + 1) > coeffs)\n<25> memcpy(&dst[c_idx], l->ready, LUT_BITS*sizeof(int32_t));\n<28> l = future[l->need_s ? 3 : !res_bits ? 2 : res_bits & 1];
<1> static int read_dialogue(ASSContext *ass, AVBPrint *dst, const uint8_t *p,\n<17> if (sscanf(p, "Dialogue: %*[^,],%d:%d:%d%*c%d,%d:%d:%d%*c%d,%n",\n<33> const int layer = atoi(p + 10);\n<37> end    = (hh2*3600LL + mm2*60LL + ss2) * 100LL + ms2;\n<39> *start = (hh1*3600LL + mm1*60LL + ss1) * 100LL + ms1;\n<41> *duration = end - *start;\n<45> av_bprint_clear(dst);\n<47> av_bprintf(dst, "%u,%d,%s", ass->readorder++, layer, p + pos);\n<53> while (dst->len > 0 &&\n<61> return 0;\n<65> return -1;
<1> int tls1_mac ( SSL * ssl , unsigned char * md , int send ) {\n<8> unsigned char header [ 13 ] ;\n<13> seq = & ( ssl -> s3 -> write_sequence [ 0 ] ) ;\n<18> seq = & ( ssl -> s3 -> read_sequence [ 0 ] ) ;\n<31> if ( ssl -> version == DTLS1_VERSION || ssl -> version == DTLS1_BAD_VER ) {\n<32> unsigned char dtlsseq [ 8 ] , * p = dtlsseq ;\n<33> s2n ( send ? ssl -> d1 -> w_epoch : ssl -> d1 -> r_epoch , p ) ;\n<34> memcpy ( p , & seq [ 2 ] , 6 ) ;\n<35> memcpy ( header , dtlsseq , 8 ) ;\n<37> else memcpy ( header , seq , 8 ) ;\n<46> ssl3_cbc_digest_record ( mac_ctx , md , & md_size , header , rec -> input , rec -> length + md_size , orig_len , ssl -> s3 -> read_mac_secret , ssl -> s3 -> read_mac_secret_size , 0 ) ;\n<92> ++ seq [ i ] ;\n<93> if ( seq [ i ] != 0 ) break ;
<1> static int kq_add ( void * arg , struct event * ev ) {\n<7> if ( TAILQ_EMPTY ( & kqop -> evsigevents [ nsignal ] ) ) {\n<11> memset ( & kev , 0 , sizeof ( kev ) ) ;\n<16> if ( kevent ( kqop -> kq , & kev , 1 , NULL , 0 , & timeout ) == - 1 ) return ( - 1 ) ;\n<23> if ( ev -> ev_events & EV_READ ) {\n<24> memset ( & kev , 0 , sizeof ( kev ) ) ;\n<25> kev . ident = ev -> ev_fd ;\n<26> kev . filter = EVFILT_READ ;\n<29> if ( ! ( ev -> ev_events & EV_PERSIST ) ) kev . flags |= EV_ONESHOT ;\n<30> kev . udata = PTR_TO_UDATA ( ev ) ;\n<31> if ( kq_insert ( kqop , & kev ) == - 1 ) return ( - 1 ) ;\n<34> if ( ev -> ev_events & EV_WRITE ) {\n<35> memset ( & kev , 0 , sizeof ( kev ) ) ;\n<41> if ( kq_insert ( kqop , & kev ) == - 1 ) return ( - 1 ) ;
<1> static inline int parse_nal_units(AVCodecParserContext *s, const uint8_t *buf,\n<17> HEVCPacket   *pkt = &ctx->pkt;\n<67> if (!tmp)\n<71> pkt->nals = tmp;\n<73> memset(pkt->nals, 0, sizeof(*tmp));\n<81> nal = &pkt->nals[0];
<1> int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)\n<39> len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n<43> len += build_def_list(h->default_ref_list[list] + len,\n<53> if (len < sl->ref_count[list])\n<55> memset(&h->default_ref_list[list][len], 0, sizeof(H264Ref) * (sl->ref_count[list] - len));\n<87> FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n<95> if (len < sl->ref_count[0])\n<97> memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));
<1> static void remoteDispatchCopyError ( remote_error * rerr , virErrorPtr verr ) {\n<4> rerr -> message = verr -> message ? malloc ( sizeof ( char * ) ) : NULL ;\n<5> if ( rerr -> message ) * rerr -> message = strdup ( verr -> message ) ;\n<7> rerr -> str1 = verr -> str1 ? malloc ( sizeof ( char * ) ) : NULL ;\n<8> if ( rerr -> str1 ) * rerr -> str1 = strdup ( verr -> str1 ) ;\n<9> rerr -> str2 = verr -> str2 ? malloc ( sizeof ( char * ) ) : NULL ;\n<10> if ( rerr -> str2 ) * rerr -> str2 = strdup ( verr -> str2 ) ;\n<11> rerr -> str3 = verr -> str3 ? malloc ( sizeof ( char * ) ) : NULL ;\n<12> if ( rerr -> str3 ) * rerr -> str3 = strdup ( verr -> str3 ) ;
<1> int archive_read_support_format_cpio ( struct archive * _a ) {\n<6> cpio = ( struct cpio * ) calloc ( 1 , sizeof ( * cpio ) ) ;\n<7> if ( cpio == NULL ) {\n<11> cpio -> magic = CPIO_MAGIC ;\n<12> r = __archive_read_register_format ( a , cpio , "cpio" , archive_read_format_cpio_bid , archive_read_format_cpio_options , archive_read_format_cpio_read_header , archive_read_format_cpio_read_data , archive_read_format_cpio_skip , NULL , archive_read_format_cpio_cleanup , NULL , NULL ) ;\n<13> if ( r != ARCHIVE_OK ) free ( cpio ) ;
<1> int chk_del ( MI_CHECK * param , register MI_INFO * info , uint test_flag ) {\n<17> if ( test_flag & T_VERBOSE ) printf ( "Recordlinks: " ) ;\n<23> if ( test_flag & T_VERBOSE ) printf ( " %9s" , llstr ( next_link , buff ) ) ;
<1> static int parse_ffconfig(const char *filename)\n<29> if (!f) {\n<51> stream = NULL;\n<67> if (fgets(line, sizeof(line), f) == NULL)\n<71> line_num++;\n<73> p = line;\n<75> while (av_isspace(*p))\n<79> if (*p == '\0' || *p == '#')\n<177> llval = strtoll(arg, NULL, 10);\n<201> if (stream || feed) {\n<207> feed = av_mallocz(sizeof(FFStream));\n<211> q = strrchr(feed->filename, '>');\n<219> for (s = first_feed; s; s = s->next) {\n<221> if (!strcmp(feed->filename, s->filename)) {\n<223> ERROR("Feed '%s' already registered\n", s->filename);\n<231> feed->fmt = av_guess_format("ffm", NULL, NULL);\n<235> snprintf(feed->feed_filename, sizeof(feed->feed_filename),\n<277> if (!arg[0])\n<309> get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n<321> get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n<329> feed->truncate = strtod(arg, NULL);\n<389> feed = NULL;\n<399> if (stream || feed) {\n<405> FFStream *s;\n<407> stream = av_mallocz(sizeof(FFStream));\n<411> q = strrchr(stream->filename, '>');\n<419> for (s = first_stream; s; s = s->next) {\n<421> if (!strcmp(stream->filename, s->filename)) {\n<423> ERROR("Stream '%s' already registered\n", s->filename);\n<431> stream->fmt = ffserver_guess_format(NULL, stream->filename, NULL);\n<435> avcodec_get_context_defaults3(&audio_enc, NULL);\n<461> get_arg(arg, sizeof(arg), &p);\n<471> while (sfeed != NULL) {\n<473> if (!strcmp(sfeed->filename, arg))\n<477> sfeed = sfeed->next_feed;\n<481> if (!sfeed)\n<483> ERROR("feed '%s' not defined\n", arg);\n<487> stream->feed = sfeed;\n<493> get_arg(arg, sizeof(arg), &p);\n<495> if (stream) {\n<497> if (!strcmp(arg, "status")) {\n<499> stream->stream_type = STREAM_TYPE_STATUS;\n<501> stream->fmt = NULL;\n<505> stream->stream_type = STREAM_TYPE_LIVE;\n<509> if (!strcmp(arg, "jpeg"))\n<511> strcpy(arg, "mjpeg");\n<513> stream->fmt = ffserver_guess_format(arg, NULL, NULL);\n<515> if (!stream->fmt) {\n<541> if (!stream->ifmt) {\n<551> if (stream && stream->stream_type == STREAM_TYPE_STATUS) {\n<553> get_arg(stream->feed_filename, sizeof(stream->feed_filename), &p);\n<565> get_arg(stream->author, sizeof(stream->author), &p);\n<571> get_arg(stream->comment, sizeof(stream->comment), &p);\n<577> get_arg(stream->copyright, sizeof(stream->copyright), &p);\n<583> get_arg(stream->title, sizeof(stream->title), &p);\n<591> stream->prebuffer = atof(arg) * 1000;\n<597> stream->send_on_key = 1;\n<629> stream->max_time = atof(arg) * 1000;\n<667> if (stream) {\n<673> get_arg(arg, sizeof(arg), &p);\n<677> if (sscanf(arg, "%d-%d", &minrate, &maxrate) == 2) {\n<679> video_enc.rc_min_rate = minrate * 1000;\n<681> video_enc.rc_max_rate = maxrate * 1000;\n<685> ERROR("Incorrect format for VideoBitRateRange -- should be <min>-<max>: %s\n", arg);\n<895> } else if (!av_strcasecmp(cmd, "VideoTag")) {\n<897> get_arg(arg, sizeof(arg), &p);\n<899> if ((strlen(arg) == 4) && stream)\n<901> video_enc.codec_tag = MKTAG(arg[0], arg[1], arg[2], arg[3]);\n<1007> parse_acl_row(stream, feed, NULL, p, filename, line_num);\n<1013> get_arg(stream->dynamic_acl, sizeof(stream->dynamic_acl), &p);\n<1023> av_freep(&stream->rtsp_option);\n<1025> stream->rtsp_option = av_strdup(arg);\n<1035> if (resolve_host(&stream->multicast_ip, arg) != 0) {\n<1041> stream->is_multicast = 1;\n<1043> stream->loop = 1; /* default is looping */\n<1053> stream->multicast_port = atoi(arg);\n<1061> stream->multicast_ttl = atoi(arg);\n<1067> stream->loop = 0;\n<1071> if (!stream) {\n<1077> if (stream->feed && stream->fmt && strcmp(stream->fmt->name, "ffm") != 0) {\n<1079> if (audio_id != AV_CODEC_ID_NONE) {\n<1085> add_codec(stream, &audio_enc);\n<1089> if (video_id != AV_CODEC_ID_NONE) {\n<1095> add_codec(stream, &video_enc);\n<1101> stream = NULL;\n<1111> if (stream || feed || redirect) {\n<1157> redirect = NULL;\n<1177> fclose(f);
<1> static int ram_decompress_open(RamDecompressState *s, QEMUFile *f)\n<7> memset(s, 0, sizeof(*s));\n<11> ret = inflateInit(&s->zstream);
<1> void mcf_fec_init(NICInfo *nd, target_phys_addr_t base, qemu_irq *irq)\n<9> qemu_check_nic_model(nd, "mcf_fec");\n<25> s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<31> memcpy(s->macaddr, nd->macaddr, 6);\n<33> qemu_format_nic_info_str(s->vc, s->macaddr);
<1> static int slirp_smb(SlirpState* s, const char *exported_dir,\n<35> if (!f) {\n<85> fclose(f);
<1> int main ( int argc , char * * argv ) {\n<2> if ( argc < 2 ) {\n<3> fprintf ( stderr , "Usage:\n%s t_header.h\n" , argv [ 0 ] ) ;
<1> static int v4l2_set_parameters(AVFormatContext *s1, AVFormatParameters *ap)\n<35> memset (&input, 0, sizeof (input));\n<39> if (ioctl(s->fd, VIDIOC_ENUMINPUT, &input) < 0) {\n<49> av_log(s1, AV_LOG_DEBUG, "The V4L2 driver set input_id: %d, input: %s\n",\n<53> if (ioctl(s->fd, VIDIOC_S_INPUT, &input.index) < 0) {\n<79> if (s->standard) {\n<87> memset (&standard, 0, sizeof (standard));\n<93> if (ioctl(s->fd, VIDIOC_ENUMSTD, &standard) < 0) {\n<105> if (!strcasecmp(standard.name, s->standard)) {\n<119> if (ioctl(s->fd, VIDIOC_S_STD, &standard.id) < 0) {\n<177> if (ioctl(s->fd, VIDIOC_G_PARM, &streamparm) != 0) {\n<179> av_log(s1, AV_LOG_ERROR, "ioctl(VIDIOC_G_PARM): %s\n", strerror(errno));\n<181> return AVERROR(errno);
<1> static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n<9> struct qht_bucket *b = head;\n<41> b = b->next;\n<47> b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n<49> memset(b, 0, sizeof(*b));\n<51> new = b;\n<73> atomic_rcu_set(&prev->next, b);
<1> static gboolean read_blob ( FILE_T infile , ngsniffer_comp_stream_t * comp_stream , int * err , gchar * * err_info ) {\n<20> if ( ! wtap_read_bytes ( infile , file_inbuf , in_len , err , err_info ) ) {\n<25> if ( uncompressed ) {\n<26> memcpy ( comp_stream -> buf , file_inbuf , in_len ) ;\n<27> out_len = in_len ;\n<36> g_free ( file_inbuf ) ;
<1> static int answer_from_qmem ( int dns_fd , struct query * q , unsigned char * qmem_cmc , unsigned short * qmem_type , int qmem_len , unsigned char * cmc_to_check ) {\n<4> i < qmem_len ;\n<5> i ++ ) {\n<7> if ( qmem_type [ i ] != q -> type ) continue ;\n<8> if ( memcmp ( qmem_cmc + i * 4 , cmc_to_check , 4 ) ) continue ;\n<9> if ( debug >= 1 ) fprintf ( stderr , "OUT from qmem for %s == duplicate, sending illegal reply\n" , q -> name ) ;\n<10> write_dns ( dns_fd , q , "x" , 1 , 'T' ) ;\n<11> q -> id = 0 ;\n<12> return 1 ;
<1> static void free_xargs ( xargs_t xargs ) {\n<2> if ( xargs . dn ) free ( xargs . dn ) ;\n<3> if ( xargs . linkdn ) free ( xargs . linkdn ) ;\n<4> if ( xargs . containerdn ) free ( xargs . containerdn ) ;\n<5> if ( xargs . tktpolicydn ) free ( xargs . tktpolicydn ) ;
<1> my_bool mysqld_get_one_option ( int optid , const struct my_option * opt __attribute__ ( ( unused ) ) , char * argument ) {\n<2> switch ( optid ) {\n<29> case 'u' : if ( ! mysqld_user || ! strcmp ( mysqld_user , argument ) ) mysqld_user = argument ;\n<30> else sql_print_warning ( "Ignoring user change to '%s' because the user was set to '%s' earlier on the command line\n" , argument , mysqld_user ) ;\n<54> if ( opt_log_basename [ 0 ] == 0 || strchr ( opt_log_basename , FN_EXTCHAR ) || strchr ( opt_log_basename , FN_LIBCHAR ) ) {\n<56> return 1 ;\n<58> if ( log_error_file_ptr != disabled_my_option ) log_error_file_ptr = opt_log_basename ;\n<59> make_default_log_name ( & opt_logname , ".log" , false ) ;\n<60> make_default_log_name ( & opt_slow_logname , "-slow.log" , false ) ;\n<61> make_default_log_name ( & opt_bin_logname , "-bin" , true ) ;\n<62> make_default_log_name ( & opt_binlog_index_name , "-bin.index" , true ) ;\n<63> make_default_log_name ( & opt_relay_logname , "-relay-bin" , true ) ;\n<64> make_default_log_name ( & opt_relaylog_index_name , "-relay-bin.index" , true ) ;\n<65> pidfile_name_ptr = pidfile_name ;\n<66> strmake ( pidfile_name , argument , sizeof ( pidfile_name ) - 5 ) ;\n<67> strmov ( fn_ext ( pidfile_name ) , ".pid" ) ;\n<68> if ( ! opt_bin_logname || ! opt_relaylog_index_name || ! opt_logname || ! opt_slow_logname || ! pidfile_name_ptr ) return 1 ;
<1> gpg_error_t _ksba_oid_from_buf ( const void * buffer , size_t buflen , unsigned char * * rbuf , size_t * rlength ) {\n<5> if ( ! string ) {\n<10> memcpy ( string , buffer , buflen ) ;\n<12> err = ksba_oid_from_str ( string , rbuf , rlength ) ;
<1> static void multiple_read_cb ( int fd , short event , void * arg ) {\n<5> if ( len == - 1 ) fprintf ( stderr , "%s: read\n" , __func__ ) ;
<1> TSReturnCode TSHttpHdrReasonSet ( TSMBuffer bufp , TSMLoc obj , const char * value , int length ) {\n<10> if ( length < 0 ) {\n<11> length = strlen ( value ) ;\n<13> h . reason_set ( value , length ) ;
<1> static int mkv_field_order(MatroskaDemuxContext *matroska, int64_t field_order)\n<13> if (sscanf(matroska->muxingapp, "Lavf%d.%d.%d", &major, &minor, &micro) == 3)\n<15> bttb = (major == 57 && minor >= 36 && minor <= 51 && micro >= 100);
<1> static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,\n<7> EightSvxContext *esc = avctx->priv_data;\n<27> if (!(esc->samples = av_malloc(esc->samples_size)))\n<55> if (!(deinterleaved_samples = av_mallocz(n)))\n<79> deinterleaved_samples = avpkt->data;\n<85> if (avctx->channels == 2)\n<91> memcpy(esc->samples, deinterleaved_samples, esc->samples_size);\n<101> av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));\n<123> src = esc->samples + esc->samples_idx;
<1> static void * Type_ColorantOrderType_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n<8> if ( ColorantOrder == NULL ) return NULL ;\n<9> memset ( ColorantOrder , 0xFF , cmsMAXCHANNELS * sizeof ( cmsUInt8Number ) ) ;\n<10> if ( io -> Read ( io , ColorantOrder , sizeof ( cmsUInt8Number ) , Count ) != Count ) {
<1> void omap_clk_init(struct omap_mpu_state_s *mpu)\n<47> for (i = onchip_clks, j = mpu->clks; *i; i ++)\n<49> if ((*i)->flags & flag) {\n<51> memcpy(j, *i, sizeof(struct clk));\n<53> for (k = mpu->clks; k < j; k ++)\n<55> if (j->parent && !strcmp(j->parent->name, k->name)) {\n<57> j->parent = k;\n<59> j->sibling = k->child1;\n<61> k->child1 = j;\n<63> } else if (k->parent && !strcmp(k->parent->name, j->name)) {\n<65> k->parent = j;\n<67> k->sibling = j->child1;\n<69> j->child1 = k;\n<73> j->divisor = j->divisor ?: 1;\n<75> j->multiplier = j->multiplier ?: 1;\n<77> j ++;\n<81> for (j = mpu->clks; count --; j ++) {\n<83> omap_clk_update(j);\n<85> omap_clk_rate_update(j);
<1> static SplineChar * hashglyphfound ( SplineChar * sc , UHash * uhash , NHash * nhash , int layer ) {\n<6> hash = hashname ( sc -> name ) ;\n<8> test != NULL ;\n<9> test = test -> next ) if ( strcmp ( test -> sc -> name , sc -> name ) == 0 && glyphmatches ( sc , test -> sc , layer ) ) return ( test -> sc ) ;\n<23> test = test -> next ) if ( glyphmatches ( sc , test -> sc , layer ) ) return ( test -> sc ) ;
<1> static int rv30_parse_slice_header ( RV34DecContext * r , GetBitContext * gb , SliceInfo * si ) {\n<6> memset ( si , 0 , sizeof ( SliceInfo ) ) ;\n<9> if ( si -> type == 1 ) si -> type = 0 ;
<1> static int nntp_date ( struct NntpServer * nserv , time_t * now ) {\n<2> if ( nserv -> hasDATE ) {\n<6> memset ( & tm , 0 , sizeof ( tm ) ) ;\n<10> if ( nntp_query ( & nntp_data , buf , sizeof ( buf ) ) < 0 ) return - 1 ;\n<11> if ( sscanf ( buf , "111 %4d%2d%2d%2d%2d%2d%*s" , & tm . tm_year , & tm . tm_mon , & tm . tm_mday , & tm . tm_hour , & tm . tm_min , & tm . tm_sec ) == 6 ) {\n<12> tm . tm_year -= 1900 ;\n<13> tm . tm_mon -- ;\n<14> * now = timegm ( & tm ) ;\n<15> if ( * now >= 0 ) {\n<21> time ( now ) ;\n<22> return 0 ;
<1> int scsi_build_sense(uint8_t *in_buf, int in_len,\n<3> uint8_t *buf, int len, bool fixed)\n<11> if (!fixed && len < 8) {\n<19> if (in_len == 0) {\n<29> fixed_in = (in_buf[0] & 2) == 0;\n<33> if (fixed == fixed_in) {\n<35> memcpy(buf, in_buf, MIN(len, in_len));\n<65> memset(buf, 0, len);\n<81> return MIN(len, 18);
<1> static void test_wl4166_3 ( ) {\n<14> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<17> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static void mgcpCallerID ( gchar * signalStr , gchar * * callerId ) {\n<4> arrayStr = g_strsplit ( signalStr , "\"" , 10 ) ;\n<5> if ( arrayStr [ 0 ] == NULL ) return ;\n<6> if ( strstr ( arrayStr [ 0 ] , "ci(" ) && ( arrayStr [ 1 ] != NULL ) ) {\n<7> g_free ( * callerId ) ;\n<8> * callerId = g_strdup ( arrayStr [ 1 ] ) ;\n<10> g_strfreev ( arrayStr ) ;
<1> static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n<25> switch (format) {\n<39> memset(outbuf, 0, 12);
<1> static void omap2_inth_write(void *opaque, target_phys_addr_t addr,\n<84> if (value & 1)\n<86> fprintf(stderr, "%s: protection mode enable attempt\n",
<1> static int vvfat_open(BlockDriverState *bs, QDict *options, int flags)\n<59> if (!dirname) {\n<87> secs = 36;\n<93> secs = s->fat_type == 12 ? 18 : 36;\n<101> cyls = 80;\n<103> heads = 2;\n<115> cyls = s->fat_type == 12 ? 64 : 1024;\n<117> heads = 16;\n<119> secs = 63;\n<125> switch (s->fat_type) {\n<129> fprintf(stderr, "Big fat greek warning: FAT32 has not been tested. "\n<193> s->sector_count = cyls * heads * secs - (s->first_sectors_number - 1);\n<217> if (init_directories(s, dirname, heads, secs)) {
<1> gpg_err_code_t _gcry_ecc_fill_in_curve ( unsigned int nbits , const char * name , elliptic_curve_t * curve , unsigned int * r_nbits ) {\n<6> domain_parms [ idx ] . desc ;\n<7> idx ++ ) if ( ! strcmp ( name , domain_parms [ idx ] . desc ) ) {\n<8> resname = domain_parms [ idx ] . desc ;\n<11> if ( ! domain_parms [ idx ] . desc ) {\n<13> curve_aliases [ aliasno ] . name ;\n<14> aliasno ++ ) if ( ! strcmp ( name , curve_aliases [ aliasno ] . other ) ) break ;\n<17> domain_parms [ idx ] . desc ;\n<18> idx ++ ) if ( ! strcmp ( curve_aliases [ aliasno ] . name , domain_parms [ idx ] . desc ) ) {\n<19> resname = domain_parms [ idx ] . desc ;\n<30> if ( ! domain_parms [ idx ] . desc ) return GPG_ERR_UNKNOWN_CURVE ;
<1> static int nntp_auth ( struct NntpServer * nserv ) {\n<28> if ( ! a ) {\n<33> a = strchr ( a , ':' ) ;\n<34> if ( a ) * a ++ = '\0' ;\n<35> if ( nserv -> hasCAPABILITIES ) {\n<38> m = strcasestr ( nserv -> authenticators , method ) ;\n<40> if ( m > nserv -> authenticators && * ( m - 1 ) != ' ' ) continue ;\n<41> m += strlen ( method ) ;\n<42> if ( * m != '\0' && * m != ' ' ) continue ;\n<44> mutt_debug ( 1 , "trying method %s\n" , method ) ;\n<45> if ( strcmp ( method , "USER" ) == 0 ) {\n<46> mutt_message ( _ ( "Authenticating (%s)..." ) , method ) ;\n<47> snprintf ( buf , sizeof ( buf ) , "AUTHINFO USER %s\r\n" , conn -> account . user ) ;\n<48> if ( mutt_socket_send ( conn , buf ) < 0 || mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) {\n<163> mutt_error ( _ ( "%s authentication failed." ) , method ) ;\n<168> nserv -> status = NNTP_BYE ;\n<169> conn -> account . flags = flags ;\n<170> if ( conn -> fd < 0 ) {\n<174> return - 1 ;
<1> static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)\n<5> struct vmsvga_state_s *s = opaque;\n<61> if (value <= SVGA_MAX_WIDTH) {\n<69> printf("%s: Bad width: %i\n", __func__, value);\n<79> if (value <= SVGA_MAX_HEIGHT) {\n<87> printf("%s: Bad height: %i\n", __func__, value);\n<97> if (value != 32) {\n<99> printf("%s: Bad bits per pixel: %i bits\n", __func__, value);\n<245> if (s->index >= SVGA_SCRATCH_BASE &&\n<247> s->index < SVGA_SCRATCH_BASE + s->scratch_size) {\n<255> printf("%s: Bad register %02x\n", __func__, s->index);
<1> static void readline_completion(ReadLineState *rs)\n<17> cmdline = g_malloc(rs->cmd_buf_index + 1);\n<19> memcpy(cmdline, rs->cmd_buf, rs->cmd_buf_index);\n<23> rs->completion_finder(cmdline);\n<31> if (rs->nb_completions <= 0)\n<37> len = strlen(rs->completions[0]);\n<39> for(i = rs->completion_index; i < len; i++) {\n<41> readline_insert_char(rs, rs->completions[0][i]);\n<48> readline_insert_char(rs, ' ');
<1> static void ipvideo_decode_opcodes ( IpvideoContext * s , AVFrame * frame ) {\n<7> if ( ! s -> is_16bpp ) {\n<8> memcpy ( frame -> data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n<29> ret = ipvideo_decode_block [ opcode ] ( s , frame ) ;\n<33> ret = ipvideo_decode_block16 [ opcode ] ( s , frame ) ;
<1> rfbBool rfbSendServerIdentity ( rfbClientPtr cl ) {\n<4> snprintf ( buffer , sizeof ( buffer ) - 1 , "%s (%s)" , ( cl -> screen -> versionString == NULL ? "unknown" : cl -> screen -> versionString ) , LIBVNCSERVER_PACKAGE_STRING ) ;\n<5> if ( cl -> ublen + sz_rfbFramebufferUpdateRectHeader + ( strlen ( buffer ) + 1 ) > UPDATE_BUF_SIZE ) {\n<6> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n<8> rect . encoding = Swap32IfLE ( rfbEncodingServerIdentity ) ;\n<11> rect . r . w = Swap16IfLE ( strlen ( buffer ) + 1 ) ;\n<13> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ;\n<14> cl -> ublen += sz_rfbFramebufferUpdateRectHeader ;\n<15> memcpy ( & cl -> updateBuf [ cl -> ublen ] , buffer , strlen ( buffer ) + 1 ) ;\n<16> cl -> ublen += strlen ( buffer ) + 1 ;\n<17> rfbStatRecordEncodingSent ( cl , rfbEncodingServerIdentity , sz_rfbFramebufferUpdateRectHeader + strlen ( buffer ) + 1 , sz_rfbFramebufferUpdateRectHeader + strlen ( buffer ) + 1 ) ;\n<18> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;
<1> static int nprobe(AVFormatContext *s, uint8_t *enc_header, int size,\n<15> if (!enc_header || !n_val)\n<23> if (!memcmp(&enc_header[pos], "EKB ", 4))\n<25> pos += 32;\n<29> if (AV_RB32(&enc_header[pos]) != oc->rid)\n<55> av_des_crypt(&av_des, oc->r_val, &enc_header[pos], 2, NULL, 1);\n<59> if (!rprobe(s, enc_header, oc->r_val))
<1> static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n<24> if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)\n<33> memset(block, 0, 64 * sizeof(DCTELEM));
<1> static int curl_open(BlockDriverState *bs, QDict *options, int flags,\n<38> s->url = g_strdup(file);\n<47> curl_easy_setopt(state->curl, CURLOPT_HEADERDATA, s);\n<51> if (d)\n<53> else if(!s->len)\n<55> if ((!strncasecmp(s->url, "http://", strlen("http://"))\n<56> || !strncasecmp(s->url, "https://", strlen("https://")))\n<57> && !s->accept_range) {\n<58> pstrcpy(state->errmsg, CURL_ERROR_SIZE,\n<62> DPRINTF("CURL: Size = %zd\n", s->len);\n<63> curl_clean_state(state);\n<64> curl_easy_cleanup(state->curl);\n<65> state->curl = NULL;\n<66> aio_timer_init(bdrv_get_aio_context(bs), &s->timer,\n<71> s->multi = curl_multi_init();\n<72> curl_multi_setopt(s->multi, CURLMOPT_SOCKETFUNCTION, curl_sock_cb);\n<77> qemu_opts_del(opts);\n<78> return 0;\n<80> error_setg(errp, "CURL: Error opening file: %s", state->errmsg);\n<81> curl_easy_cleanup(state->curl);\n<82> state->curl = NULL;\n<84> g_free(s->url);\n<85> qemu_opts_del(opts);\n<86> return -EINVAL;
<1> int MBS_ApplyPatch ( const MBSPatchHeader * header , int patchfd , unsigned char * fbuffer , int filefd ) {\n<4> unsigned char * buf = ( unsigned char * ) malloc ( header -> cblen + header -> difflen + header -> extralen ) ;\n<5> if ( ! buf ) return MEM_ERROR ;
<1> const gx_device * gs_getdefaultlibdevice ( gs_memory_t * mem ) {\n<6> if ( mem && mem -> gs_lib_ctx && mem -> gs_lib_ctx -> default_device_list ) {\n<7> name = mem -> gs_lib_ctx -> default_device_list ;\n<8> fin = name + strlen ( name ) ;\n<11> name = gs_dev_defaults ;\n<12> fin = name + strlen ( name ) ;\n<14> while ( name < fin ) {\n<15> while ( ( name < fin ) && ( * name == ' ' || * name == '\t' ) ) name ++ ;\n<19> i < count ;\n<20> i ++ ) if ( ( end - name ) == strlen ( list [ i ] -> dname ) ) if ( ! memcmp ( name , list [ i ] -> dname , end - name ) ) return gs_getdevice ( i ) ;
<1> void arp_table_add(Slirp *slirp, uint32_t ip_addr, uint8_t ethaddr[ETH_ALEN])\n<19> DEBUG_ARGS((dfd, " hw addr = %02x:%02x:%02x:%02x:%02x:%02x\n",\n<45> for (i = 0; i < ARP_TABLE_SIZE; i++) {\n<47> if (arptbl->table[i].ar_sip == ip_addr) {\n<51> memcpy(arptbl->table[i].ar_sha, ethaddr, ETH_ALEN);\n<65> memcpy(arptbl->table[arptbl->next_victim].ar_sha,  ethaddr, ETH_ALEN);
<1> static int selinux_set_mnt_opts ( struct super_block * sb , struct security_mnt_opts * opts , unsigned long kern_flags , unsigned long * set_kern_flags ) {\n<59> if ( sbsec -> flags & SE_SBINITIALIZED ) {\n<64> if ( strcmp ( sb -> s_type -> name , "proc" ) == 0 ) sbsec -> flags |= SE_SBPROC | SE_SBGENFS ;\n<65> if ( ! strcmp ( sb -> s_type -> name , "debugfs" ) || ! strcmp ( sb -> s_type -> name , "sysfs" ) || ! strcmp ( sb -> s_type -> name , "pstore" ) ) sbsec -> flags |= SE_SBGENFS ;
<1> static void ehci_advance_periodic_state(EHCIState *ehci)\n<17> switch(ehci_get_state(ehci, async)) {\n<89> fprintf(stderr, "ehci: Bad periodic state %d. "
<3> CodedBitstreamUnit *unit)\n<13> err = bitstream_init(&bc, unit->data, 8 * unit->data_size);\n<177> if (!slice)\n<197> if (!unit->data[len - 1]) {\n<201> for (z = 0; z < len && !unit->data[len - z - 1]; z++);\n<215> slice->data = av_malloc(slice->data_size);\n<217> if (!slice->data) {\n<227> unit->data + pos / 8, slice->data_size);\n<233> unit->content = slice;
<1> void ff_mpeg4_clean_buffers ( MpegEncContext * s ) {\n<6> c_xy = ( s -> mb_y - 1 ) * c_wrap + s -> mb_x - 1 ;\n<11> memset ( s -> ac_val [ 1 ] + c_xy , 0 , ( c_wrap + 1 ) * 16 * sizeof ( int16_t ) ) ;\n<12> memset ( s -> ac_val [ 2 ] + c_xy , 0 , ( c_wrap + 1 ) * 16 * sizeof ( int16_t ) ) ;
<1> static size_t b_encoder ( char * str , const char * buf , size_t buflen , const char * tocode ) {\n<3> memcpy ( str , "=?" , 2 ) ;\n<4> str += 2 ;\n<5> memcpy ( str , tocode , strlen ( tocode ) ) ;\n<6> str += strlen ( tocode ) ;\n<7> memcpy ( str , "?B?" , 3 ) ;\n<8> str += 3 ;\n<16> i ++ ) * str ++ = encoded [ i ] ;\n<20> memcpy ( str , "?=" , 2 ) ;\n<21> str += 2 ;
<1> TSReturnCode TSMimeHdrFieldValueAppend ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , const char * value , int length ) {\n<12> if ( length == - 1 ) {\n<13> length = strlen ( value ) ;\n<15> mime_field_value_extend_comma_val ( heap , handle -> mh , handle -> field_ptr , idx , value , length ) ;
<1> static void TestLenient8Iterator ( ) {\n<30> c2 = iter2 . next ( & iter2 ) ;\n<31> if ( c1 < 0 && c2 < 0 ) {\n<34> if ( c1 < 0 ) {\n<35> printf ( "\t%04x\n" , c2 ) ;\n<37> else if ( c2 < 0 ) {\n<38> printf ( "%04x\n" , c1 ) ;\n<41> printf ( "%04x\t%04x\n" , c1 , c2 ) ;
<1> static const char *keyval_parse_one(QDict *qdict, const char *params,\n<29> if (implied_key && len && key[len] != '=') {\n<35> len = strlen(implied_key);\n<39> key_end = key + len;\n<63> if (!len || (s + len < key_end && s[len] != '.')) {\n<65> assert(key != implied_key);\n<75> if (len >= sizeof(key_in_cur)) {\n<77> assert(key != implied_key);\n<91> if (s != key) {\n<95> key, s - 1, errp);\n<97> if (!next) {\n<111> memcpy(key_in_cur, s, len);\n<113> key_in_cur[len] = 0;\n<115> s += len;\n<119> if (*s != '.') {\n<131> if (key == implied_key) {\n<181> if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {
<1> static void handle_control_message(VirtIOSerial *vser, void *buf, size_t len)\n<37> if (!port && cpkt.event != VIRTIO_CONSOLE_DEVICE_READY)\n<103> send_control_event(port, VIRTIO_CONSOLE_CONSOLE_PORT, 1);\n<109> if (port->name) {\n<117> buffer_len = sizeof(cpkt) + strlen(port->name) + 1;\n<119> buffer = qemu_malloc(buffer_len);\n<123> memcpy(buffer, &cpkt, sizeof(cpkt));\n<125> memcpy(buffer + sizeof(cpkt), port->name, strlen(port->name));\n<131> send_control_msg(port, buffer, buffer_len);\n<141> send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN, 1);\n<161> port->info->guest_ready(port);
<1> PHP_MINIT_FUNCTION ( uwsgi_php_minit ) {\n<3> struct uwsgi_string_list * usl = uphp . constants ;\n<4> while ( usl ) {\n<5> char * equal = strchr ( usl -> value , '=' ) ;\n<7> size_t name_len = equal - usl -> value ;\n<14> usl = usl -> next ;
<1> static void configure ( struct recvbuf * rbufp , int restrict_mask ) {\n<8> if ( RES_NOMODIFY & restrict_mask ) {\n<9> snprintf ( remote_config . err_msg , sizeof ( remote_config . err_msg ) , "runtime configuration prohibited by restrict ... nomodify" ) ;\n<10> ctl_putdata ( remote_config . err_msg , strlen ( remote_config . err_msg ) , 0 ) ;\n<17> if ( data_count > sizeof ( remote_config . buffer ) - 2 ) {\n<18> snprintf ( remote_config . err_msg , sizeof ( remote_config . err_msg ) , "runtime configuration failed: request too long" ) ;\n<19> ctl_putdata ( remote_config . err_msg , strlen ( remote_config . err_msg ) , 0 ) ;\n<24> if ( data_count != ( size_t ) ( reqend - reqpt ) ) {\n<25> snprintf ( remote_config . err_msg , sizeof ( remote_config . err_msg ) , "runtime configuration failed: request contains an unprintable character" ) ;\n<26> ctl_putdata ( remote_config . err_msg , strlen ( remote_config . err_msg ) , 0 ) ;\n<31> memcpy ( remote_config . buffer , reqpt , data_count ) ;\n<33> DPRINTF ( 1 , ( "Got Remote Configuration Command: %s\n" , remote_config . buffer ) ) ;\n<35> remote_config . buffer [ data_count ++ ] = '\n' ;
<1> static int dca_subframe_header ( DCAContext * s , int base_channel , int block_index ) {\n<61> j < s -> prim_channels ;\n<65> memset ( s -> scale_factor [ j ] , 0 , s -> subband_activity [ j ] * sizeof ( s -> scale_factor [ 0 ] [ 0 ] [ 0 ] ) * 2 ) ;
<1> static struct passwd * check_perms ( void ) {\n<5> if ( NULL == pw ) {\n<6> ( void ) fprintf ( stderr , _ ( "No passwd entry for user '%s'\n" ) , name ) ;\n<7> SYSLOG ( ( LOG_NOTICE , "No passwd entry for user '%s'" , name ) ) ;
<1> static void dumpRoleMembership ( PGconn * conn ) {\n<5> if ( PQntuples ( res ) > 0 ) fprintf ( OPF , "--\n-- Role memberships\n--\n\n" ) ;\n<7> i < PQntuples ( res ) ;\n<12> fprintf ( OPF , "GRANT %s" , fmtId ( roleid ) ) ;\n<13> fprintf ( OPF , " TO %s" , fmtId ( member ) ) ;\n<14> if ( * option == 't' ) fprintf ( OPF , " WITH ADMIN OPTION" ) ;\n<15> if ( ! PQgetisnull ( res , i , 3 ) ) {\n<17> fprintf ( OPF , " GRANTED BY %s" , fmtId ( grantor ) ) ;\n<23> fprintf ( OPF , "\n\n" ) ;
<1> static inline int array_roll(array_t* array,int index_to,int index_from,int count)\n<25> if(index_to==index_from)\n<33> from=array->pointer+index_from*is;\n<35> to=array->pointer+index_to*is;\n<37> buf=g_malloc(is*count);\n<39> memcpy(buf,from,is*count);\n<43> if(index_to<index_from)\n<45> memmove(to+is*count,to,from-to);\n<49> memmove(from,from+is*count,to-from);\n<53> memcpy(to,buf,is*count);\n<57> free(buf);
<1> static int ogg_build_flac_headers(AVCodecContext *avctx,\n<7> const char *vendor = bitexact ? "ffmpeg" : LIBAVFORMAT_IDENT;\n<15> if (!ff_flac_is_extradata_valid(avctx, &format, &streaminfo))\n<43> bytestream_put_buffer(&p, streaminfo, FLAC_STREAMINFO_SIZE);\n<45> oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;\n<47> oggstream->header[1] = av_mallocz(oggstream->header_len[1]);\n<49> p = oggstream->header[1];\n<53> bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment\n<55> bytestream_put_be24(&p, oggstream->header_len[1] - 4);\n<57> bytestream_put_le32(&p, strlen(vendor));\n<59> bytestream_put_buffer(&p, vendor, strlen(vendor));\n<61> bytestream_put_le32(&p, 0); // user comment list length
<1> int remoteSendStreamData ( struct qemud_client * client , struct qemud_client_stream * stream , const char * data , unsigned int len ) {\n<14> if ( remoteEncodeClientMessageHeader ( msg ) < 0 ) goto fatal_error ;\n<15> if ( data && len ) {\n<16> if ( ( msg -> bufferLength - msg -> bufferOffset ) < len ) goto fatal_error ;\n<17> xdrmem_create ( & xdr , msg -> buffer , msg -> bufferLength , XDR_ENCODE ) ;\n<18> if ( xdr_setpos ( & xdr , msg -> bufferOffset ) == 0 ) goto xdr_error ;\n<19> memcpy ( msg -> buffer + msg -> bufferOffset , data , len ) ;\n<20> msg -> bufferOffset += len ;
<1> static void request_finished ( struct request * const req , struct request * * head ) {\n<3> if ( req -> next == req ) {\n<7> req -> next -> prev = req -> prev ;\n<9> if ( * head == req ) * head = req -> next ;\n<14> search_request_finished ( req ) ;\n<16> if ( ! req -> request_appended ) {\n<17> free ( req -> request ) ;\n<21> free ( req ) ;
<1> static int img_bench(int argc, char **argv)\n<23> int pattern = 0;\n<259> pattern = res;\n<325> if (flush_interval && flush_interval < depth) {\n<351> if (image_size < 0) {\n<379> .flush_interval = flush_interval,\n<393> if (flush_interval) {\n<395> printf("Sending flush every %d requests\n", flush_interval);\n<401> data.buf = blk_blockalign(blk, data.nrreq * data.bufsize);\n<403> memset(data.buf, pattern, data.nrreq * data.bufsize);\n<415> data.buf + i * data.bufsize, data.bufsize);\n<423> bench_cb(&data, 0);\n<427> while (data.n > 0) {\n<439> (t2.tv_sec - t1.tv_sec)\n<441> + ((double)(t2.tv_usec - t1.tv_usec) / 1000000));\n<447> qemu_vfree(data.buf);
<1> static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n<27> if (s->is_snapshot) {\n<41> DPRINTF("%s %s\n", sn_info->name, sn_info->id_str);\n<55> strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n<65> fd = connect_to_sdog(s, &local_err);\n<95> ret = do_sd_create(s, &new_vid, 1, &local_err);\n<97> if (ret < 0) {\n<103> error_report("failed to create inode for snapshot. %s",\n<105> strerror(errno));\n<113> inode = (SheepdogInode *)g_malloc(datalen);\n<117> ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n<123> if (ret < 0) {\n<125> error_report("failed to read new inode info. %s", strerror(errno));\n<133> memcpy(&s->inode, inode, datalen);
<1> static char * timelib_string ( Scanner * s ) {\n<2> char * tmp = calloc ( 1 , s -> cur - s -> tok + 1 ) ;\n<3> memcpy ( tmp , s -> tok , s -> cur - s -> tok ) ;\n<4> return tmp ;
<1> struct pxa2xx_gpio_info_s *pxa2xx_gpio_init(target_phys_addr_t base,\n<17> memset(s, 0, sizeof(struct pxa2xx_gpio_info_s));
<1> static void run_shell ( char const * shell , char const * command , char * * additional_args , size_t n_additional_args ) {\n<3> char const * * args = xcalloc ( n_args , sizeof * args ) ;\n<4> size_t argno = 1 ;\n<5> if ( simulate_login ) {\n<8> shell_basename = basename ( shell ) ;\n<9> arg0 = xmalloc ( strlen ( shell_basename ) + 2 ) ;\n<11> strcpy ( arg0 + 1 , shell_basename ) ;\n<12> args [ 0 ] = arg0 ;\n<14> else args [ 0 ] = basename ( shell ) ;\n<15> if ( fast_startup ) args [ argno ++ ] = "-f" ;\n<18> args [ argno ++ ] = command ;\n<20> memcpy ( args + argno , additional_args , n_additional_args * sizeof * args ) ;
<1> void record_raw_stats ( sockaddr_u * srcadr , sockaddr_u * dstadr , l_fp * t1 , l_fp * t2 , l_fp * t3 , l_fp * t4 ) {\n<7> day = now . l_ui / 86400 + MJD_1900 ;\n<9> if ( rawstats . fp != NULL ) {\n<10> fprintf ( rawstats . fp , "%lu %s %s %s %s %s %s %s\n" , day , ulfptoa ( & now , 3 ) , stoa ( srcadr ) , dstadr ? stoa ( dstadr ) : "-" , ulfptoa ( t1 , 9 ) , ulfptoa ( t2 , 9 ) , ulfptoa ( t3 , 9 ) , ulfptoa ( t4 , 9 ) ) ;\n<11> fflush ( rawstats . fp ) ;
<1> static UBool generateFromUTable ( CnvExtData * extData , UCMTable * table , int32_t start , int32_t limit , int32_t unitIndex , uint32_t defaultValue ) {\n<57> if ( subStart < subLimit && mappings [ map [ subStart ] ] . uLen == unitIndex + 1 ) {\n<58> fprintf ( stderr , "error: multiple mappings from same Unicode code points\n" ) ;\n<59> ucm_printMapping ( table , m , stderr ) ;
<1> static UBool generateToUTable ( CnvExtData * extData , UCMTable * table , int32_t start , int32_t limit , int32_t unitIndex , uint32_t defaultValue ) {\n<32> if ( count >= 0x100 ) {\n<33> fprintf ( stderr , "error: toUnicode extension table section overflow: %ld section entries\n" , ( long ) count ) ;\n<72> if ( subStart < subLimit && mappings [ map [ subStart ] ] . bLen == unitIndex + 1 ) {\n<73> fprintf ( stderr , "error: multiple mappings from same bytes\n" ) ;\n<74> ucm_printMapping ( table , m , stderr ) ;
<1> static void show_edge ( struct commit * commit ) {\n<2> printf ( "-%s\n" , oid_to_hex ( & commit -> object . oid ) ) ;
<1> static void qed_aio_write_inplace(QEDAIOCB *acb, uint64_t offset, size_t len)\n<9> struct iovec *iov = acb->qiov->iov;\n<13> if (!iov->iov_base) {\n<15> iov->iov_base = qemu_blockalign(acb->common.bs, iov->iov_len);\n<17> memset(iov->iov_base, 0, iov->iov_len);
<1> static gpgme_error_t gpgsm_new ( void * * engine , const char * file_name , const char * home_dir ) {\n<13> gpgsm = calloc ( 1 , sizeof * gpgsm ) ;\n<14> if ( ! gpgsm ) return gpg_error_from_syserror ( ) ;
<1> static int check_consistent_binlog_pos ( char * binlog_pos_file , char * binlog_pos_offset ) {\n<7> while ( ( row = mysql_fetch_row ( res ) ) ) {\n<8> if ( 0 == strcmp ( row [ 0 ] , "Binlog_snapshot_file" ) ) {\n<9> if ( binlog_pos_file ) strmake ( binlog_pos_file , row [ 1 ] , FN_REFLEN - 1 ) ;\n<10> found ++ ;\n<12> else if ( 0 == strcmp ( row [ 0 ] , "Binlog_snapshot_position" ) ) {\n<13> if ( binlog_pos_offset ) strmake ( binlog_pos_offset , row [ 1 ] , LONGLONG_LEN ) ;\n<14> found ++ ;
<1> static void ClosePacketizer ( vlc_object_t * p_this ) {\n<2> decoder_t * p_dec = ( decoder_t * ) p_this ;\n<5> free ( p_dec -> p_sys ) ;
<1> void appendStringLiteralConn ( PQExpBuffer buf , const char * str , PGconn * conn ) {\n<2> size_t length = strlen ( str ) ;\n<3> if ( strchr ( str , '\\' ) != NULL && PQserverVersion ( conn ) >= 80100 ) {\n<4> if ( buf -> len > 0 && buf -> data [ buf -> len - 1 ] != ' ' ) appendPQExpBufferChar ( buf , ' ' ) ;\n<5> appendPQExpBufferChar ( buf , ESCAPE_STRING_SYNTAX ) ;\n<6> appendStringLiteral ( buf , str , PQclientEncoding ( conn ) , false ) ;\n<7> return ;\n<9> if ( ! enlargePQExpBuffer ( buf , 2 * length + 2 ) ) return ;\n<11> buf -> len += PQescapeStringConn ( conn , buf -> data + buf -> len , str , length , NULL ) ;
<1> static int ac3_eac3_probe(AVProbeData *p, enum AVCodecID expected_codec_id)\n<37> for(frames = 0; buf2 < end; frames++) {\n<43> if(!memcmp(buf2, "\x1\x10\0\0\0\0\0\0", 8))\n<45> buf2+=16;\n<61> init_get_bits(&gbc, buf2, 54);\n<67> if(buf2 + hdr.frame_size > end)\n<93> buf2 += hdr.frame_size;
<1> static int load_input_picture(MpegEncContext *s, AVFrame *pic_arg){\n<105> int w= s->width >>h_shift;\n<109> uint8_t *src= pic_arg->data[i];\n<111> uint8_t *dst= pic->data[i];\n<115> if(src_stride==dst_stride)\n<117> memcpy(dst, src, src_stride*h);\n<121> while(h--){\n<123> memcpy(dst, src, w);\n<125> dst += dst_stride;\n<127> src += src_stride;
<1> static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx,\n<5> const uint8_t *buf, int len, uint16_t seq,\n<65> lid  = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f);\n<67> tid  =   buf[1] & 0x07;\n<133> if (len < 1) {\n<149> if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0)\n<155> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<159> memcpy(pkt->data + sizeof(start_sequence), buf, len);
<1> static int decode_idat_chunk(AVCodecContext *avctx, PNGDecContext *s,\n<225> if (avctx->pix_fmt == AV_PIX_FMT_PAL8)\n<227> memcpy(p->data[1], s->palette, 256 * sizeof(uint32_t));\n<283> ret = png_decode_idat(s, length);
<1> static time_t _zip_d2u_time ( int dtime , int ddate ) {\n<3> memset ( & tm , 0 , sizeof ( tm ) ) ;\n<11> return mktime ( & tm ) ;
<1> int gx_parse_output_file_name ( gs_parsed_file_name_t * pfn , const char * * pfmt , const char * fname , uint fnlen , gs_memory_t * memory ) {\n<7> pfn -> len = 0 ;\n<12> pfn -> len = fnlen ;\n<19> if ( ( pfn -> len == 1 ) && ( pfn -> fname [ 0 ] == '-' ) ) {\n<25> pfn -> fname ++ , pfn -> len -- ;\n<31> code = gx_parse_output_format ( pfn , pfmt ) ;\n<32> if ( code < 0 ) return code ;\n<33> if ( strlen ( pfn -> iodev -> dname ) + pfn -> len + code >= gp_file_name_sizeof ) return_error ( gs_error_undefinedfilename ) ;
<1> int css_do_tsch(SubchDev *sch, IRB *target_irb)\n<5> SCSW *s = &sch->curr_status.scsw;\n<21> if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n<35> actl = s->ctrl & SCSW_CTRL_MASK_ACTL;\n<41> memset(&irb, 0, sizeof(IRB));\n<47> memcpy(&irb.scsw, s, sizeof(SCSW));\n<69> if ((s->dstat & SCSW_DSTAT_UNIT_CHECK) &&\n<75> memcpy(irb.ecw, sch->sense_data, sizeof(sch->sense_data));\n<85> copy_irb_to_guest(target_irb, &irb);\n<93> s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n<101> s->ctrl &= ~SCSW_CTRL_MASK_FCTL;\n<107> s->flags &= ~SCSW_FLAGS_MASK_PNO;\n<125> s->flags &= ~SCSW_FLAGS_MASK_PNO;\n<141> s->ctrl &= ~SCSW_ACTL_RESUME_PEND;\n<151> if (p->chars & PMCW_CHARS_MASK_CSENSE) {\n<153> memset(sch->sense_data, 0 , sizeof(sch->sense_data));
<1> static void destroy_setvar_fifo ( setvar_fifo * fifo ) {\n<3> if ( fifo != NULL ) {\n<5> UNLINK_FIFO ( sv , * fifo , link ) ;\n<6> if ( sv != NULL ) {\n<7> free ( sv -> var ) ;\n<8> free ( sv -> val ) ;\n<9> free ( sv ) ;\n<12> while ( sv != NULL ) ;\n<13> free ( fifo ) ;
<1> static void addFromUTrieEntry ( CnvExtData * extData , UChar32 c , uint32_t value ) {\n<10> nextOffset = ( c >> 4 ) & 0x3f ;\n<19> if ( extData -> stage2Top > UPRV_LENGTHOF ( extData -> stage2 ) ) {\n<20> fprintf ( stderr , "error: too many stage 2 entries at U+%04x\n" , ( int ) c ) ;\n<25> nextOffset = c & 0xf ;\n<35> if ( extData -> stage3Top > UPRV_LENGTHOF ( extData -> stage3 ) ) {\n<36> fprintf ( stderr , "error: too many stage 3 entries at U+%04x\n" , ( int ) c ) ;\n<61> if ( ( i3b = extData -> stage3bTop ++ ) >= UPRV_LENGTHOF ( extData -> stage3b ) ) {\n<62> fprintf ( stderr , "error: too many stage 3b entries at U+%04x\n" , ( int ) c ) ;
<1> static void an5206_init(MachineState *machine)\n<85> if (qtest_enabled()) {\n<91> fprintf(stderr, "Kernel image must be specified\n");\n<99> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<107> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n<115> kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR,\n<123> if (kernel_size < 0) {\n<125> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> int ga_install_service(const char *path, const char *logfile,\n<79> if (service == NULL) {\n<91> fprintf(stderr, "Service was installed successfully.\n");
<1> static int fic_decode_frame(AVCodecContext *avctx, void *data,\n<7> FICContext *ctx = avctx->priv_data;\n<9> uint8_t *src = avpkt->data;\n<35> if (avpkt->size < FIC_HEADER_SIZE + 4) {\n<47> if (memcmp(src, fic_header, 7))\n<49> av_log(avctx, AV_LOG_WARNING, "Invalid FIC Header.\n");\n<71> nslices = src[13];\n<91> tsize = AV_RB24(src + 24);\n<107> if (!tsize || !AV_RL16(src + 37) || !AV_RL16(src + 39))\n<127> cur_x = AV_RL16(src + 33);\n<129> cur_y = AV_RL16(src + 35);\n<145> if (!skip_cursor && (AV_RL16(src + 37) != 32 || AV_RL16(src + 39) != 32)) {\n<169> sdata = src + tsize + FIC_HEADER_SIZE + 4 * nslices;\n<205> av_fast_malloc(&ctx->slice_data, &ctx->slice_data_size,\n<209> if (!ctx->slice_data_size) {\n<217> memset(ctx->slice_data, 0, nslices * sizeof(ctx->slice_data[0]));\n<223> unsigned slice_off = AV_RB32(src + tsize + FIC_HEADER_SIZE + slice * 4);\n<249> slice_size = AV_RB32(src + tsize + FIC_HEADER_SIZE + slice * 4 + 4);\n<277> if ((ret = avctx->execute(avctx, fic_decode_slice, ctx->slice_data,\n<313> if (!skip_cursor) {\n<315> memcpy(ctx->cursor_buf, src + 59, 32 * 32 * 4);
<13> if ((a & ~0x1F) == (address & ~0x1F))\n<19> cpu_stl_data(env, a, (*current)->value);\n<33> free (*current);
<1> static int decode_audio_block(AC3DecodeContext *s, int blk)\n<19> uint8_t bit_alloc_stages[AC3_MAX_CHANNELS] = { 0 };\n<135> if ((ret = coupling_strategy(s, blk, bit_alloc_stages)) < 0)\n<219> bit_alloc_stages[ch] = 3;\n<265> if (blk > 0 && s->end_freq[ch] != prev)\n<267> memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);\n<329> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<369> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 1);\n<389> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<421> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<463> bit_alloc_stages[CPL_CH] = FFMAX(bit_alloc_stages[CPL_CH], 2);\n<505> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<529> bit_alloc_stages[ch] = FFMAX(bit_alloc_stages[ch], 2);\n<551> if (bit_alloc_stages[ch] > 2) {\n<563> if (bit_alloc_stages[ch] > 1) {\n<589> if (bit_alloc_stages[ch] > 0) {
<1> static struct request * request_new ( int type , const char * name , int flags , evdns_callback_type callback , void * user_ptr ) {\n<3> const int name_len = strlen ( name ) ;\n<4> const int request_max_len = evdns_request_len ( name_len ) ;\n<6> struct request * const req = ( struct request * ) malloc ( sizeof ( struct request ) + request_max_len ) ;\n<9> if ( ! req ) return NULL ;\n<10> memset ( req , 0 , sizeof ( struct request ) ) ;\n<11> evtimer_set ( & req -> timeout_event , evdns_request_timeout_callback , req ) ;\n<12> req -> request = ( ( u8 * ) req ) + sizeof ( struct request ) ;\n<13> req -> request_appended = 1 ;\n<14> rlen = evdns_request_data_build ( name , name_len , trans_id , type , CLASS_INET , req -> request , request_max_len ) ;\n<15> if ( rlen < 0 ) goto err1 ;\n<24> return req ;\n<25> err1 : free ( req ) ;
<20> switch (msg.request) {\n<54> memcpy(&s->memory, &msg.payload.memory, sizeof(msg.payload.memory));
<1> static int pfkey_xfrm_policy2msg ( struct sk_buff * skb , const struct xfrm_policy * xp , int dir ) {\n<12> size = pfkey_xfrm_policy2msg_size ( xp ) ;\n<13> hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ;\n<14> memset ( hdr , 0 , size ) ;\n<62> i < xp -> xfrm_nr ;\n<74> size -= 2 * socklen ;\n<76> rq = ( void * ) skb_put ( skb , req_size ) ;\n<78> memset ( rq , 0 , sizeof ( * rq ) ) ;\n<79> rq -> sadb_x_ipsecrequest_len = req_size ;\n<80> rq -> sadb_x_ipsecrequest_proto = t -> id . proto ;\n<82> rq -> sadb_x_ipsecrequest_mode = mode ;\n<83> rq -> sadb_x_ipsecrequest_level = IPSEC_LEVEL_REQUIRE ;\n<84> if ( t -> reqid ) rq -> sadb_x_ipsecrequest_level = IPSEC_LEVEL_UNIQUE ;\n<85> if ( t -> optional ) rq -> sadb_x_ipsecrequest_level = IPSEC_LEVEL_USE ;\n<86> rq -> sadb_x_ipsecrequest_reqid = t -> reqid ;\n<88> u8 * sa = ( void * ) ( rq + 1 ) ;\n<93> if ( ( xfrm_ctx = xp -> security ) ) {\n<95> sec_ctx = ( struct sadb_x_sec_ctx * ) skb_put ( skb , ctx_size ) ;\n<96> sec_ctx -> sadb_x_sec_len = ctx_size / sizeof ( uint64_t ) ;\n<97> sec_ctx -> sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX ;\n<98> sec_ctx -> sadb_x_ctx_doi = xfrm_ctx -> ctx_doi ;\n<99> sec_ctx -> sadb_x_ctx_alg = xfrm_ctx -> ctx_alg ;\n<100> sec_ctx -> sadb_x_ctx_len = xfrm_ctx -> ctx_len ;\n<101> memcpy ( sec_ctx + 1 , xfrm_ctx -> ctx_str , xfrm_ctx -> ctx_len ) ;\n<103> hdr -> sadb_msg_len = size / sizeof ( uint64_t ) ;
<1> static void virtio_net_add_queue(VirtIONet *n, int index)\n<11> if (n->net_conf.tx && !strcmp(n->net_conf.tx, "timer")) {\n<13> n->vqs[index].tx_vq =\n<15> virtio_add_queue(vdev, 256, virtio_net_handle_tx_timer);\n<17> n->vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n<21> &n->vqs[index]);\n<25> n->vqs[index].tx_vq =\n<27> virtio_add_queue(vdev, 256, virtio_net_handle_tx_bh);\n<29> n->vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[index]);
<1> static bool config_filter_match_service ( const struct config_filter * mask , const struct config_filter * filter ) {\n<2> if ( mask -> service != NULL ) {\n<3> if ( filter -> service == NULL ) return FALSE ;\n<4> if ( mask -> service [ 0 ] == '!' ) {\n<5> if ( strcmp ( filter -> service , mask -> service + 1 ) == 0 ) return FALSE ;\n<8> if ( strcmp ( filter -> service , mask -> service ) != 0 ) return FALSE ;\n<11> return TRUE ;
<1> static void test_long_data_bin ( ) {\n<20> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<26> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<39> rc = mysql_stmt_execute ( stmt ) ;\n<40> if ( ! opt_silent ) fprintf ( stdout , " mysql_stmt_execute() returned %d\n" , rc ) ;\n<41> check_execute ( stmt , rc ) ;
<1> static void init_username ( ) {\n<6> if ( ! mysql_query ( & mysql , "select USER()" ) && ( result = mysql_use_result ( & mysql ) ) ) {\n<7> MYSQL_ROW cur = mysql_fetch_row ( result ) ;\n<8> full_username = my_strdup ( cur [ 0 ] , MYF ( MY_WME ) ) ;\n<9> part_username = my_strdup ( strtok ( cur [ 0 ] , "@" ) , MYF ( MY_WME ) ) ;
<1> static void test_signal_assert ( void ) {\n<5> printf ( "Signal handler assert: " ) ;
<1> int avfilter_copy_frame_props(AVFilterBufferRef *dst, const AVFrame *src)\n<7> dst->pos    = av_frame_get_pkt_pos(src);\n<31> av_freep(&dst->video->qp_table);\n<39> dst->video->qp_table        = av_malloc(qsize);\n<41> if(!dst->video->qp_table)\n<48> memcpy(dst->video->qp_table, src->qscale_table, qsize);
<1> static int archive_read_format_ar_cleanup ( struct archive_read * a ) {\n<3> ar = ( struct ar * ) ( a -> format -> data ) ;\n<4> if ( ar -> strtab ) free ( ar -> strtab ) ;\n<5> free ( ar ) ;
<1> static void decode_fixed_vector ( float * fixed_vector , const uint16_t * pulse_hi , const uint16_t * pulse_lo , const enum Mode mode ) {\n<45> memset ( fixed_vector , 0 , sizeof ( float ) * AMRWB_SFR_SIZE ) ;\n<52> fixed_vector [ pos ] += sig_pos [ i ] [ j ] < 0 ? - 1.0 : 1.0 ;
<1> static int dyn_buf_write(void *opaque, uint8_t *buf, int buf_size)\n<5> DynBuffer *d = opaque;\n<17> if(new_size < d->pos || new_size > INT_MAX/2)\n<35> if (new_allocated_size > d->allocated_size) {\n<39> if(d->buffer == NULL)\n<47> memcpy(d->buffer + d->pos, buf, buf_size);\n<55> return buf_size;
<1> static QemuOpts *opts_parse(QemuOptsList *list, const char *params,\n<11> if (strncmp(params, "id=", 3) == 0) {\n<14> } else if ((p = strstr(params, ",id=")) != NULL) {\n<15> get_opt_value(value, sizeof(value), p+4);\n<16> id = value;\n<19> if (opts == NULL) {\n<26> if (opts_do_parse(opts, params, firstname, defaults) != 0) {
<1> void _TIFFmemset ( tdata_t p , int v , tsize_t c ) {\n<2> memset ( p , v , ( size_t ) c ) ;
<1> CURLcode Curl_add_bufferf ( Curl_send_buffer * in , const char * fmt , ... ) {\n<5> s = vaprintf ( fmt , ap ) ;\n<7> if ( s ) {\n<8> CURLcode result = Curl_add_buffer ( in , s , strlen ( s ) ) ;\n<9> free ( s ) ;\n<10> return result ;\n<12> free ( in -> buffer ) ;\n<13> free ( in ) ;
<1> int test_mod_exp ( BIO * bp , BN_CTX * ctx ) {\n<31> if ( ! BN_is_zero ( b ) ) {\n<32> fprintf ( stderr , "Modulo exponentiation test failed!\n" ) ;
<1> static int convert_coeffs(AVFilterContext *ctx, AVFilterLink *inlink)\n<15> FFTComplex *data_hrtf_l = NULL;\n<17> FFTComplex *data_hrtf_r = NULL;\n<19> FFTComplex *fft_in_l = NULL;\n<21> FFTComplex *fft_in_r = NULL;\n<23> float *data_ir_l = NULL;\n<25> float *data_ir_r = NULL;\n<45> fft_in_r = av_calloc(n_fft, sizeof(*fft_in_r));\n<47> if (!fft_in_l || !fft_in_r) {\n<87> s->data_ir[1] = av_calloc(FFALIGN(s->ir_len, 16), sizeof(float) * s->nb_irs);\n<119> if (!s->data_ir[0] || !s->data_ir[1] ||\n<153> data_ir_l = av_calloc(nb_irs * FFALIGN(ir_len, 16), sizeof(*data_ir_l));\n<157> if (!data_ir_r || !data_ir_l || !s->temp_src[0] || !s->temp_src[1]) {\n<169> data_hrtf_l = av_malloc_array(n_fft, sizeof(*data_hrtf_l) * nb_irs);\n<173> if (!data_hrtf_r || !data_hrtf_l) {\n<233> if (s->type == TIME_DOMAIN) {\n<239> data_ir_l[offset + j] = ptr[len * 2 - j * 2 - 2] * gain_lin;\n<241> data_ir_r[offset + j] = ptr[len * 2 - j * 2 - 1] * gain_lin;\n<247> memset(fft_in_l, 0, n_fft * sizeof(*fft_in_l));\n<249> memset(fft_in_r, 0, n_fft * sizeof(*fft_in_r));\n<253> offset = idx * n_fft;\n<265> av_fft_permute(s->fft[0], fft_in_l);\n<267> av_fft_calc(s->fft[0], fft_in_l);\n<269> memcpy(data_hrtf_l + offset, fft_in_l, n_fft * sizeof(*fft_in_l));\n<271> av_fft_permute(s->fft[0], fft_in_r);\n<273> av_fft_calc(s->fft[0], fft_in_r);\n<275> memcpy(data_hrtf_r + offset, fft_in_r, n_fft * sizeof(*fft_in_r));\n<283> if (s->type == TIME_DOMAIN) {\n<285> memcpy(s->data_ir[0], data_ir_l, sizeof(float) * nb_irs * FFALIGN(ir_len, 16));\n<287> memcpy(s->data_ir[1], data_ir_r, sizeof(float) * nb_irs * FFALIGN(ir_len, 16));\n<291> av_freep(&data_ir_l);\n<293> av_freep(&data_ir_r);\n<299> s->data_hrtf[1] = av_malloc_array(n_fft * s->nb_irs, sizeof(FFTComplex));\n<301> if (!s->data_hrtf[0] || !s->data_hrtf[1]) {\n<307> av_freep(&fft_in_l);\n<309> av_freep(&fft_in_r);\n<319> sizeof(FFTComplex) * nb_irs * n_fft);\n<323> sizeof(FFTComplex) * nb_irs * n_fft);\n<327> av_freep(&data_hrtf_l);\n<329> av_freep(&data_hrtf_r);\n<333> av_freep(&fft_in_l);\n<335> av_freep(&fft_in_r);
<1> ivshmem_client_parse_args(IvshmemClientArgs *args, int argc, char *argv[])\n<21> switch (c) {\n<41> args->unix_sock_path = strdup(optarg);
<1> static void _slurm_rpc_complete_batch_script ( slurm_msg_t * msg , bool * run_scheduler , bool running_composite ) {\n<38> if ( association_based_accounting && job_ptr && ( job_ptr -> job_state != JOB_PENDING ) ) {\n<40> memset ( & batch_step , 0 , sizeof ( struct step_record ) ) ;\n<54> step_set_alloc_tres ( & batch_step , 1 , false , false ) ;\n<55> jobacct_storage_g_step_start ( acct_db_conn , & batch_step ) ;\n<56> jobacct_storage_g_step_complete ( acct_db_conn , & batch_step ) ;\n<57> FREE_NULL_BITMAP ( batch_step . step_node_bitmap ) ;\n<58> xfree ( batch_step . tres_alloc_str ) ;
<1> static int printHelp ( int argc , char * argv [ ] ) {\n<3> fprintf ( stderr , "Options:\n" "\t-h or -? or --help print this usage text\n" "\t-v or --verbose verbose output\n" "\t-c or --copyright include a copyright notice\n" ) ;\n<4> fprintf ( stderr , "\t-d or --destdir destination directory, followed by the path\n" "\t-s or --sourcedir source directory of ICU data, followed by the path\n" "\t-b or --bundle-name generate the ouput data file with the name specified\n" "\t-i or --icudatadir directory for locating any needed intermediate data files,\n" "\t followed by path, defaults to %s\n" , u_getDataDirectory ( ) ) ;\n<5> fprintf ( stderr , "\t-n or --normalize turn on the option for normalization and include mappings\n" "\t from NormalizationCorrections.txt from the given path,\n" "\t e.g: /test/icu/source/data/unidata\n" ) ;\n<6> fprintf ( stderr , "\t-m or --norm-correction use NormalizationCorrections.txt from the given path\n" "\t when the input file contains a normalization directive.\n" "\t unlike -n/--normalize, this option does not force the\n" "\t normalization.\n" ) ;\n<7> fprintf ( stderr , "\t-k or --check-bidi turn on the option for checking for BiDi in the profile\n" "\t-u or --unicode version of Unicode to be used with this profile followed by the version\n" ) ;
<1> MigrationState *migrate_init(const MigrationParams *params)\n<5> MigrationState *s = migrate_get_current();\n<33> memcpy(enabled_capabilities, s->enabled_capabilities,\n<39> memset(s, 0, sizeof(*s));\n<43> memcpy(s->enabled_capabilities, enabled_capabilities,\n<71> migrate_set_state(s, MIGRATION_STATUS_NONE, MIGRATION_STATUS_SETUP);\n<81> return s;
<1> struct das_proclist * get_proclist ( int * num_procs ) {\n<7> struct das_proclist * ret = calloc ( sizeof ( struct das_proclist ) , proclist_def . number ) ;
<1> static int remote_exists ( const char * path ) {\n<4> switch ( http_get_strbuf ( url , NULL , NULL ) ) {\n<9> case HTTP_ERROR : error ( "unable to access '%s': %s" , url , curl_errorstr ) ;\n<12> free ( url ) ;
<1> static inline int op ( uint8_t * * dst , const uint8_t * dst_end , GetByteContext * gb , int pixel , int count , int * x , int width , int linesize ) {\n<4> int striplen = FFMIN ( count , remaining ) ;\n<9> else if ( pixel >= 0 ) memset ( * dst , pixel , striplen ) ;\n<10> * dst += striplen ;\n<11> remaining -= striplen ;\n<12> count -= striplen ;\n<18> if ( * dst >= dst_end ) goto exhausted ;\n<21> if ( * dst <= dst_end ) goto exhausted ;
<1> static int writer_open ( WriterContext * * wctx , const Writer * writer , const char * args , const struct section * sections , int nb_sections ) {\n<22> if ( args ) {\n<30> while ( ( opt = av_dict_get ( opts , "" , opt , AV_DICT_IGNORE_SUFFIX ) ) ) {\n<40> const uint8_t * p = ( * wctx ) -> string_validation_replacement ;\n<41> const uint8_t * endp = p + strlen ( p ) ;\n<43> const uint8_t * p0 = p ;\n<45> ret = av_utf8_decode ( & code , & p , endp , ( * wctx ) -> string_validation_utf8_flags ) ;\n<49> bprint_bytes ( & bp , p0 , p - p0 ) , av_log ( wctx , AV_LOG_ERROR , "Invalid UTF8 sequence %s found in string validation replace '%s'\n" , bp . str , ( * wctx ) -> string_validation_replacement ) ;
<1> static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n<5> MXFContext *mxf = s->priv_data;\n<17> if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n<39> if (klv_read_packet(&klv, s->pb) < 0) {\n<43> if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n<55> PRINT_KEY(s, "read header", klv.key);\n<59> if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n<61> IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n<63> IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n<65> IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n<67> if (!mxf->current_partition->essence_offset) {\n<69> compute_partition_essence_offset(s, mxf, &klv);\n<83> if (mxf_parse_handle_essence(mxf) <= 0)\n<89> } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n<91> klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n<95> if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n<103> for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n<105> if (IS_KLV_KEY(klv.key, metadata->key)) {\n<109> if (klv.key[5] == 0x53) {\n<111> res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n<115> uint64_t next = avio_tell(s->pb) + klv.length;\n<117> res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n<139> avio_skip(s->pb, klv.length);\n<157> mxf_compute_essence_containers(mxf);\n<161> return mxf_parse_structural_metadata(mxf);
<1> static void test_bug10736 ( ) {\n<17> check_execute ( stmt , rc ) ;\n<18> stmt_text = "select name from t1 where name=(select name from t1 where id=2)" ;\n<19> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<20> check_execute ( stmt , rc ) ;\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<25> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<29> int row_no = 0 ;\n<33> if ( ! opt_silent ) printf ( "%d: %s\n" , row_no , a ) ;\n<34> ++ row_no ;
<1> static void bdrv_qed_invalidate_cache(BlockDriverState *bs)\n<3> BDRVQEDState *s = bs->opaque;\n<5> memset(s, 0, sizeof(BDRVQEDState));
<1> static int do_getfd(Monitor *mon, const QDict *qdict, QObject **ret_data)\n<5> const char *fdname = qdict_get_str(qdict, "fdname");\n<25> if (qemu_isdigit(fdname[0])) {\n<39> if (fd == -1) {\n<55> QLIST_FOREACH(monfd, &mon->fds, next) {\n<57> if (strcmp(monfd->name, fdname) != 0) {
<1> static int decode_mb_cabac(H264Context *h) {\n<167> if(IS_INTRA_PCM(mb_type)) {\n<257> memset(h->non_zero_count[mb_xy], 16, 16);
<1> REGRESSION_TEST ( SDK_API_TSMimeHdrField ) ( RegressionTest * test , int , int * pstatus ) {\n<156> field1NameGet = TSMimeHdrFieldNameGet ( bufp1 , mime_loc1 , field_loc11 , & field1NameGetLength ) ;\n<157> field2NameGet = TSMimeHdrFieldNameGet ( bufp1 , mime_loc1 , field_loc12 , & field2NameGetLength ) ;\n<158> field3NameGet = TSMimeHdrFieldNameGet ( bufp1 , mime_loc1 , field_loc13 , & field3NameGetLength ) ;\n<159> field4NameGet = TSMimeHdrFieldNameGet ( bufp1 , mime_loc1 , field_loc14 , & field4NameGetLength ) ;\n<160> field5NameGet = TSMimeHdrFieldNameGet ( bufp1 , mime_loc1 , field_loc15 , & field5NameGetLength ) ;\n<161> if ( ( ( strncmp ( field1NameGet , field1Name , field1NameGetLength ) == 0 ) && ( field1NameGetLength == ( int ) strlen ( field1Name ) ) ) && ( ( strncmp ( field2NameGet , field2Name , field2NameGetLength ) == 0 ) && ( field2NameGetLength == ( int ) strlen ( field2Name ) ) ) && ( ( strncmp ( field3NameGet , field3Name , field3NameGetLength ) == 0 ) && ( field3NameGetLength == ( int ) strlen ( field3Name ) ) ) && ( ( strncmp ( field4NameGet , field4Name , field4NameGetLength ) == 0 ) && ( field4NameGetLength == ( int ) strlen ( field4Name ) ) ) && ( ( strncmp ( field5NameGet , field5Name , field5NameGetLength ) == 0 ) && field5NameGetLength == ( int ) strlen ( field5Name ) ) ) {\n<307> field1Value1Get = TSMimeHdrFieldValueStringGet ( bufp1 , mime_loc1 , field_loc11 , 0 , & lengthField1Value1 ) ;\n<308> field1Value2Get = TSMimeHdrFieldValueStringGet ( bufp1 , mime_loc1 , field_loc11 , 1 , & lengthField1Value2 ) ;\n<309> field1Value3Get = TSMimeHdrFieldValueStringGet ( bufp1 , mime_loc1 , field_loc11 , 2 , & lengthField1Value3 ) ;\n<310> field1Value4Get = TSMimeHdrFieldValueStringGet ( bufp1 , mime_loc1 , field_loc11 , 3 , & lengthField1Value4 ) ;\n<311> field1Value5Get = TSMimeHdrFieldValueStringGet ( bufp1 , mime_loc1 , field_loc11 , 4 , & lengthField1Value5 ) ;\n<312> field1ValueAllGet = TSMimeHdrFieldValueStringGet ( bufp1 , mime_loc1 , field_loc11 , - 1 , & lengthField1ValueAll ) ;\n<313> if ( ( ( strncmp ( field1Value1Get , field1Value1 , lengthField1Value1 ) == 0 ) && lengthField1Value1 == ( int ) strlen ( field1Value1 ) ) && ( ( strncmp ( field1Value2Get , field1Value2 , lengthField1Value2 ) == 0 ) && lengthField1Value2 == ( int ) strlen ( field1Value2 ) ) && ( ( strncmp ( field1Value3Get , field1Value3 , lengthField1Value3 ) == 0 ) && lengthField1Value3 == ( int ) strlen ( field1Value3 ) ) && ( ( strncmp ( field1Value4Get , field1Value4 , lengthField1Value4 ) == 0 ) && lengthField1Value4 == ( int ) strlen ( field1Value4 ) ) && ( ( strncmp ( field1Value5Get , field1Value5 , lengthField1Value5 ) == 0 ) && lengthField1Value5 == ( int ) strlen ( field1Value5 ) ) && ( strstr ( field1ValueAllGet , field1Value1Get ) == field1Value1Get ) && ( strstr ( field1ValueAllGet , field1Value2Get ) == field1Value2Get ) && ( strstr ( field1ValueAllGet , field1Value3Get ) == field1Value3Get ) && ( strstr ( field1ValueAllGet , field1Value4Get ) == field1Value4Get ) && ( strstr ( field1ValueAllGet , field1Value5Get ) == field1Value5Get ) ) {\n<323> field1ValueNewGet = TSMimeHdrFieldValueStringGet ( bufp1 , mime_loc1 , field_loc11 , 3 , & lengthField1ValueNew ) ;\n<324> if ( ( strncmp ( field1ValueNewGet , field1ValueNew , lengthField1ValueNew ) == 0 ) && ( lengthField1ValueNew == ( int ) strlen ( field1ValueNew ) ) ) {\n<476> if ( ( TSMimeHdrFieldValueStringInsert ( bufp1 , mime_loc1 , field_loc15 , - 1 , field5Value1 , - 1 ) == TS_ERROR ) || ( TSMimeHdrFieldValueIntInsert ( bufp1 , mime_loc1 , field_loc15 , - 1 , field5Value2 ) == TS_ERROR ) || ( TSMimeHdrFieldValueStringInsert ( bufp1 , mime_loc1 , field_loc15 , - 1 , field5Value3 , - 1 ) == TS_ERROR ) || ( TSMimeHdrFieldValueUintInsert ( bufp1 , mime_loc1 , field_loc15 , - 1 , field5Value4 ) == TS_ERROR ) ) {\n<483> if ( TSMimeHdrFieldValueAppend ( bufp1 , mime_loc1 , field_loc15 , 0 , field5Value1Append , - 1 ) == TS_ERROR ) {\n<489> size_t len = strlen ( field5Value1 ) + strlen ( field5Value1Append ) + 1 ;\n<490> expected_value = ( char * ) TSmalloc ( len ) ;\n<491> memset ( expected_value , 0 , len ) ;\n<492> ink_strlcpy ( expected_value , field5Value1 , len ) ;\n<493> ink_strlcat ( expected_value , field5Value1Append , len ) ;\n<494> if ( ( strncmp ( fieldValueAppendGet , expected_value , lengthFieldValueAppended ) == 0 ) && ( lengthFieldValueAppended = strlen ( expected_value ) ) ) {\n<501> TSfree ( expected_value ) ;\n<515> fieldValueDeleteGet = TSMimeHdrFieldValueStringGet ( bufp1 , mime_loc1 , field_loc15 , 2 , & lengthFieldValueDeleteGet ) ;\n<516> if ( ( strncmp ( fieldValueDeleteGet , field5Value3 , lengthFieldValueDeleteGet ) == 0 ) && ( lengthFieldValueDeleteGet == ( int ) strlen ( field5Value3 ) ) ) {\n<542> if ( ( test_field_loc15 = TSMimeHdrFieldFind ( bufp1 , mime_loc1 , field5Name , - 1 ) ) == TS_NULL_MLOC ) {
<1> static int libx265_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<4> libx265Context *ctx = avctx->priv_data;\n<34> dst = pkt->data;\n<35> if (ctx->header) {\n<36> memcpy(dst, ctx->header, ctx->header_size);\n<37> dst += ctx->header_size;\n<38> av_freep(&ctx->header);\n<41> for (i = 0; i < nnal; i++) {\n<42> memcpy(dst, nal[i].payload, nal[i].sizeBytes);\n<43> dst += nal[i].sizeBytes;
<1> static int add_recent_loose ( const unsigned char * sha1 , const char * path , void * data ) {\n<6> if ( errno == ENOENT ) return 0 ;\n<7> return error ( "unable to stat %s: %s" , sha1_to_hex ( sha1 ) , strerror ( errno ) ) ;
<1> int MDC2_Final ( unsigned char * md , MDC2_CTX * c ) {\n<6> if ( ( i > 0 ) || ( j == 2 ) ) {\n<8> memset ( & ( c -> data [ i ] ) , 0 , MDC2_BLOCK - i ) ;\n<9> mdc2_body ( c , c -> data , MDC2_BLOCK ) ;\n<11> memcpy ( md , ( char * ) c -> h , MDC2_BLOCK ) ;\n<12> memcpy ( & ( md [ MDC2_BLOCK ] ) , ( char * ) c -> hh , MDC2_BLOCK ) ;
<1> void ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n<5> if (av_strstart(p, "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &p)) {\n<11> int len = strlen(p) * 6 / 8;\n<13> char *buf = av_mallocz(len);\n<15> av_base64_decode(buf, p, len);
<1> static int nntp_mbox_open ( struct Context * ctx ) {\n<12> if ( url_parse ( & url , buf ) < 0 || ! url . host || ! url . path || ! ( url . scheme == U_NNTP || url . scheme == U_NNTPS ) ) {\n<18> url . path = strchr ( url . path , '\0' ) ;\n<19> url_tostring ( & url , server , sizeof ( server ) , 0 ) ;\n<21> url_free ( & url ) ;
<1> static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n<45> if (!ohci_read_iso_td(ohci, addr, &iso_td)) {\n<47> printf("usb-ohci: ISO_TD read error at %x\n", addr);\n<137> dir = OHCI_BM(ed->flags, ED_D);\n<139> switch (dir) {\n<179> printf("usb-ohci: Bad direction %d\n", dir);\n<187> if (!iso_td.bp || !iso_td.be) {\n<189> printf("usb-ohci: ISO_TD bp 0x%.8x be 0x%.8x\n", iso_td.bp, iso_td.be);\n<199> next_offset = iso_td.offset[relative_frame_number + 1];\n<203> if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) ||\n<207> !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n<209> printf("usb-ohci: ISO_TD cc != not accessed 0x%.8x 0x%.8x\n",\n<219> if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n<221> printf("usb-ohci: ISO_TD start_offset=0x%.8x > next_offset=0x%.8x\n",\n<289> if (len && dir != OHCI_TD_DIR_IN) {\n<291> ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len, 0);\n<355> if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n<367> } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n<379> if (ret > (ssize_t) len) {\n<381> printf("usb-ohci: DataOverrun %d > %zu\n", ret, len);\n<387> OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n<391> } else if (ret >= 0) {\n<393> printf("usb-ohci: DataUnderrun %d\n", ret);\n<401> switch (ret) {\n<419> printf("usb-ohci: got NAK/STALL %d\n", ret);\n<433> printf("usb-ohci: Bad device response %d\n", ret);
<1> int ff_h264_fill_default_ref_list ( H264Context * h ) {\n<15> len = build_def_list ( h -> default_ref_list [ list ] , sorted , len , 0 , h -> picture_structure ) ;\n<16> len += build_def_list ( h -> default_ref_list [ list ] + len , h -> long_ref , 16 , 1 , h -> picture_structure ) ;\n<18> if ( len < h -> ref_count [ list ] ) memset ( & h -> default_ref_list [ list ] [ len ] , 0 , sizeof ( Picture ) * ( h -> ref_count [ list ] - len ) ) ;\n<34> len = build_def_list ( h -> default_ref_list [ 0 ] , h -> short_ref , h -> short_ref_count , 0 , h -> picture_structure ) ;\n<37> if ( len < h -> ref_count [ 0 ] ) memset ( & h -> default_ref_list [ 0 ] [ len ] , 0 , sizeof ( Picture ) * ( h -> ref_count [ 0 ] - len ) ) ;
<1> static int dwt_plane ( AVCodecContext * avctx , void * arg ) {\n<9> dwtcoef * buf = p -> coef_buf ;\n<33> buf [ x ] = pix [ x ] - s -> diff_offset ;\n<35> buf += p -> coef_stride ;\n<47> buf [ x ] = pix [ x ] - s -> diff_offset ;\n<49> buf += p -> coef_stride ;\n<53> memset ( buf , 0 , p -> coef_stride * ( p -> dwt_height - p -> height ) * sizeof ( dwtcoef ) ) ;
<1> static int mpegts_audio_write(void *opaque, uint8_t *buf, int size)\n<5> MpegTSWriteStream *ts_st = (MpegTSWriteStream *)opaque;\n<7> if (ts_st->adata_pos + size > ts_st->adata_size)\n<13> memcpy(ts_st->adata + ts_st->adata_pos, buf, size);\n<15> ts_st->adata_pos += size;
<1> enum ImapAuthRes imap_auth_gss ( struct ImapData * idata , const char * method ) {\n<15> if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n<16> snprintf ( buf1 , sizeof ( buf1 ) , "imap@%s" , idata -> conn -> account . host ) ;\n<18> request_buf . length = strlen ( buf1 ) ;\n<19> maj_stat = gss_import_name ( & min_stat , & request_buf , gss_nt_service_name , & target_name ) ;\n<21> mutt_debug ( 2 , "Couldn't get service name for [%s]\n" , buf1 ) ;\n<25> gss_display_name ( & min_stat , target_name , & request_buf , & mech_name ) ;\n<26> mutt_debug ( 2 , "Using service name [%s]\n" , ( char * ) request_buf . value ) ;\n<27> gss_release_buffer ( & min_stat , & request_buf ) ;\n<43> mutt_debug ( 2 , "Invalid response from server: %s\n" , buf1 ) ;\n<51> mutt_socket_send ( idata -> conn , buf1 ) ;\n<62> sec_token = & request_buf ;\n<73> mutt_socket_send ( idata -> conn , buf1 ) ;\n<84> maj_stat = gss_unwrap ( & min_stat , context , & request_buf , & send_token , & cflags , & quality ) ;\n<93> if ( ! ( ( ( char * ) send_token . value ) [ 0 ] & GSS_AUTH_P_NONE ) ) {\n<103> buf_size = htonl ( buf_size ) ;\n<104> memcpy ( buf1 , & buf_size , 4 ) ;\n<105> buf1 [ 0 ] = GSS_AUTH_P_NONE ;\n<106> strncpy ( buf1 + 4 , idata -> conn -> account . user , sizeof ( buf1 ) - 4 ) ;\n<108> request_buf . length = 4 + strlen ( idata -> conn -> account . user ) ;\n<109> maj_stat = gss_wrap ( & min_stat , context , 0 , GSS_C_QOP_DEFAULT , & request_buf , & cflags , & send_token ) ;\n<115> mutt_debug ( 2 , "Requesting authorisation as %s\n" , idata -> conn -> account . user ) ;
<1> static void test_bug15518 ( ) {\n<7> if ( ! mysql_real_connect ( mysql1 , opt_host , opt_user , opt_password , opt_db ? opt_db : "test" , opt_port , opt_unix_socket , CLIENT_MULTI_STATEMENTS ) ) {\n<8> fprintf ( stderr , "Failed to connect to the database\n" ) ;\n<12> rc = mysql_stmt_prepare ( stmt , "foo" , 3 ) ;\n<13> if ( ! opt_silent ) fprintf ( stdout , "rc: %d, mysql_stmt_errno: %d, mysql_errno: %d\n" , rc , mysql_stmt_errno ( stmt ) , mysql_errno ( mysql1 ) ) ;\n<14> DIE_UNLESS ( rc && mysql_stmt_errno ( stmt ) && mysql_errno ( mysql1 ) ) ;\n<15> rc = mysql_stmt_prepare ( stmt , "SHOW STATUS" , 12 ) ;\n<16> if ( ! opt_silent ) fprintf ( stdout , "rc: %d, mysql_stmt_errno: %d, mysql_errno: %d\n" , rc , mysql_stmt_errno ( stmt ) , mysql_errno ( mysql1 ) ) ;\n<17> DIE_UNLESS ( ! rc || mysql_stmt_errno ( stmt ) || mysql_errno ( mysql1 ) ) ;\n<21> rc = mysql_stmt_prepare ( stmt , "foo" , 3 ) ;\n<22> if ( ! opt_silent ) fprintf ( stdout , "rc: %d, mysql_stmt_errno: %d, mysql_errno: %d\n" , rc , mysql_stmt_errno ( stmt ) , mysql_errno ( mysql1 ) ) ;\n<23> DIE_UNLESS ( rc && mysql_stmt_errno ( stmt ) && mysql_errno ( mysql1 ) ) ;\n<25> rc = mysql_stmt_prepare ( stmt , "SHOW STATUS" , 12 ) ;\n<26> if ( ! opt_silent ) fprintf ( stdout , "rc: %d, mysql_stmt_errno: %d\n" , rc , mysql_stmt_errno ( stmt ) ) ;\n<27> DIE_UNLESS ( rc && mysql_stmt_errno ( stmt ) ) ;
<1> void ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n<5> char *param, buffer[128], tmp[128];\n<7> int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;\n<9> SrtStack stack[16];\n<23> for (; !end && *in; in++) {\n<25> switch (*in) {\n<61> len = 0;\n<63> an += sscanf(in, "{\\an%*1u}%n", &len) >= 0 && len > 0;\n<65> if ((an != 1 && (len = 0, sscanf(in, "{\\%*[^}]}%n", &len) >= 0 && len > 0)) ||\n<67> (len = 0, sscanf(in, "{%*1[CcFfoPSsYy]:%*[^}]}%n", &len) >= 0 && len > 0)) {\n<69> in += len - 1;\n<73> av_bprint_chars(dst, *in, 1);\n<79> tag_close = in[1] == '/';\n<81> len = 0;\n<83> if (sscanf(in+tag_close+1, "%127[^>]>%n", buffer, &len) >= 1 && len > 0) {\n<85> const char *tagname = buffer;\n<87> while (*tagname == ' ')\n<89> tagname++;\n<91> if ((param = strchr(tagname, ' ')))\n<93> *param++ = 0;\n<95> if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack)) ||\n<97> ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) {\n<99> int i, j, unknown = 0;\n<101> in += len + tag_close;\n<103> if (!tag_close)\n<105> memset(stack+sptr, 0, sizeof(*stack));\n<107> if (!strcmp(tagname, "font")) {\n<109> if (tag_close) {\n<113> if (stack[sptr-1].param[i][0])\n<115> for (j=sptr-2; j>=0; j--)\n<127> while (param) {\n<129> if (!strncmp(param, "size=", 5)) {\n<133> param += 5 + (param[5] == '"');\n<135> if (sscanf(param, "%u", &font_size) == 1) {\n<137> snprintf(stack[sptr].param[PARAM_SIZE],\n<139> sizeof(stack[0].param[PARAM_SIZE]),\n<147> param += 6 + (param[6] == '"');\n<155> html_color_parse(log_ctx, param));\n<157> } else if (!strncmp(param, "face=", 5)) {\n<159> param += 5 + (param[5] == '"');\n<163> param[-1] == '"' ? "\"" :" ");\n<167> FFMIN(sizeof(tmp), len+1));\n<169> param += len;\n<179> if ((param = strchr(param, ' ')))\n<181> param++;\n<193> } else if (tagname[0] && !tagname[1] && strspn(tagname, "bisu") == 1) {\n<195> av_bprintf(dst, "{\\%c%d}", tagname[0], !tag_close);\n<199> unknown = 1;\n<201> snprintf(tmp, sizeof(tmp), "</%s>", tagname);\n<205> if (tag_close) {\n<207> sptr--;\n<209> } else if (unknown && !strstr(in, tmp)) {\n<211> in -= len + tag_close;\n<213> av_bprint_chars(dst, *in, 1);\n<217> av_strlcpy(stack[sptr++].tag, tagname,\n<219> sizeof(stack[0].tag));\n<229> av_bprint_chars(dst, *in, 1);
<1> static void fifo_read ( int fd , short event , void * arg ) {\n<7> fprintf ( stderr , "fifo_read called with fd: %d, event: %d, arg: %p\n" , fd , event , arg ) ;\n<20> else if ( len == 0 ) {\n<21> fprintf ( stderr , "Connection closed\n" ) ;
<1> static void old_pc_system_rom_init(MemoryRegion *rom_memory, bool isapc_ram_fw)\n<23> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<55> ret = rom_add_file_fixed(bios_name, (uint32_t)(-bios_size), -1);\n<57> if (ret != 0) {\n<61> fprintf(stderr, "qemu: could not load PC BIOS '%s'\n", bios_name);
<1> static int sunrast_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<57> if ( buf_end - buf < maplength ) return AVERROR_INVALIDDATA ;\n<70> x ++ , ptr += 4 ) * ( uint32_t * ) ptr = ( buf [ x ] << 16 ) + ( buf [ len + x ] << 8 ) + buf [ len + len + x ] ;\n<73> ptr = p -> data [ 0 ] ;\n<102> if ( buf_end - buf < len ) break ;\n<103> memcpy ( ptr , buf , len ) ;\n<104> ptr += stride ;\n<105> buf += alen ;
<1> static int celt_header(AVFormatContext *s, int idx)\n<13> uint8_t *p = os->buf + os->pstart;\n<17> if (os->psize == 60 &&\n<19> !memcmp(p, ff_celt_codec.magic, ff_celt_codec.magicsize)) {\n<45> version          = AV_RL32(p + 28);\n<49> sample_rate      = AV_RL32(p + 36);\n<51> nb_channels      = AV_RL32(p + 40);\n<53> overlap          = AV_RL32(p + 48);\n<57> extra_headers    = AV_RL32(p + 56);\n<89> ff_vorbis_stream_comment(s, st, p, os->psize);
<1> static int parse_interval(Interval *interval, int interval_count,\n<13> *buf += strspn(*buf, SPACES);\n<15> if (!**buf)\n<23> memset(interval, 0, sizeof(Interval));\n<35> intervalstr = av_get_token(buf, DELIMS);\n<103> ret = parse_commands(&interval->commands, &interval->nb_commands,
<1> static void cmv_decode_inter(CmvContext * s, const uint8_t *buf, const uint8_t *buf_end){\n<17> unsigned char *dst = s->frame.data[0] + (y*4)*s->frame.linesize[0] + x*4;\n<19> if (raw+16<buf_end && *raw==0xFF) { /* intra */\n<21> raw++;\n<23> memcpy(dst, raw, 4);\n<25> memcpy(dst+s->frame.linesize[0], raw+4, 4);\n<27> memcpy(dst+2*s->frame.linesize[0], raw+8, 4);\n<29> memcpy(dst+3*s->frame.linesize[0], raw+12, 4);\n<31> raw+=16;\n<37> int yoffset = ((*raw >> 4)) - 7;
<1> static void cpu_x86_register(X86CPU *cpu, const char *name, Error **errp)\n<7> x86_def_t def1, *def = &def1;\n<11> memset(def, 0, sizeof(*def));\n<15> if (cpu_x86_find_by_name(cpu, def, name) < 0) {
<1> static int store_object ( enum object_type type , struct strbuf * dat , struct last_object * last , unsigned char * sha1out , uintmax_t mark ) {\n<21> else if ( find_sha1_pack ( sha1 , packed_git ) ) {\n<30> delta = diff_delta ( last -> data . buf , last -> data . len , dat -> buf , dat -> len , & deltalen , dat -> len - 20 ) ;\n<32> else delta = NULL ;\n<49> if ( delta ) {\n<50> free ( delta ) ;\n<51> delta = NULL ;\n<86> sha1write ( pack_file , out , s . total_out ) ;\n<89> free ( out ) ;\n<90> free ( delta ) ;
<1> static void qemu_kvm_init_cpu_signals ( CPUState * cpu ) {\n<5> memset ( & sigact , 0 , sizeof ( sigact ) ) ;\n<7> sigaction ( SIG_IPI , & sigact , NULL ) ;\n<12> if ( r ) {\n<13> fprintf ( stderr , "kvm_set_signal_mask: %s\n" , strerror ( - r ) ) ;
<1> void xps_begin_opacity ( xps_document * doc , const fz_matrix * ctm , const fz_rect * area , char * base_uri , xps_resource * dict , char * opacity_att , fz_xml * opacity_mask_tag ) {\n<3> if ( ! opacity_att && ! opacity_mask_tag ) return ;\n<6> if ( opacity_mask_tag && ! strcmp ( fz_xml_tag ( opacity_mask_tag ) , "SolidColorBrush" ) ) {\n<7> char * scb_opacity_att = fz_xml_att ( opacity_mask_tag , "Opacity" ) ;\n<8> char * scb_color_att = fz_xml_att ( opacity_mask_tag , "Color" ) ;\n<9> if ( scb_opacity_att ) opacity = opacity * fz_atof ( scb_opacity_att ) ;\n<10> if ( scb_color_att ) {\n<16> opacity_mask_tag = NULL ;\n<24> xps_parse_brush ( doc , ctm , area , base_uri , dict , opacity_mask_tag ) ;
<1> inline static bool is_localhost ( const char * name , int len ) {\n<3> return ( len == ( sizeof ( local ) - 1 ) ) && ( memcmp ( name , local , len ) == 0 ) ;
<1> static int gdb_handle_packet(GDBState *s, CPUState *env, const char *line_buf)\n<9> char buf[4096];\n<27> ch = *p++;\n<29> switch(ch) {\n<159> ret = strtoull(p, (char **)&p, 16);\n<161> if (*p == ',') {\n<163> p++;\n<165> err = strtoull(p, (char **)&p, 16);\n<173> if (*p == ',')\n<175> p++;\n<201> put_packet(s, buf);\n<208> len = strlen(p) / 2;\n<210> hextomem((uint8_t *)registers, p, len);\n<220> if (*p == ',')\n<224> len = strtoull(p, NULL, 16);\n<234> put_packet(s, buf);\n<241> addr = strtoull(p, (char **)&p, 16);\n<243> if (*p == ',')\n<245> p++;\n<249> if (*p == ':')\n<253> hextomem(mem_buf, p, len);\n<265> type = strtoul(p, (char **)&p, 16);\n<267> if (*p == ',')\n<269> p++;\n<271> addr = strtoull(p, (char **)&p, 16);\n<273> if (*p == ',')\n<275> p++;\n<308> type = strtoul(p, (char **)&p, 16);\n<310> if (*p == ',')\n<312> p++;\n<314> addr = strtoull(p, (char **)&p, 16);\n<316> if (*p == ',')\n<318> p++;\n<320> len = strtoull(p, (char **)&p, 16);\n<349> if (!strcmp(p,"qemu.sstepbits")) {\n<361> put_packet(s, buf);\n<364> } else if (strncmp(p,"qemu.sstep",10) == 0) {\n<370> if (*p != '=') {\n<374> sprintf(buf,"0x%x", sstep_flags);\n<376> put_packet(s, buf);
<1> static struct archive_string_conv * create_sconv_object ( const char * fc , const char * tc , unsigned current_codepage , int flag ) {\n<3> sc = calloc ( 1 , sizeof ( * sc ) ) ;\n<4> if ( sc == NULL ) return ( NULL ) ;\n<5> sc -> next = NULL ;\n<6> sc -> from_charset = strdup ( fc ) ;\n<7> if ( sc -> from_charset == NULL ) {\n<8> free ( sc ) ;\n<11> sc -> to_charset = strdup ( tc ) ;\n<12> if ( sc -> to_charset == NULL ) {\n<13> free ( sc -> from_charset ) ;\n<14> free ( sc ) ;\n<20> sc -> to_cp = make_codepage_from_charset ( tc ) ;
<1> int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref)\n<29> if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {\n<49> if (!scale || strcmp(scale->filter->name, "scale")) {\n<51> AVFilter *f = avfilter_get_by_name("scale");\n<55> av_log(buffer_filter, AV_LOG_INFO, "Inserting scaler filter\n");\n<57> if ((ret = avfilter_open(&scale, f, "Input equalizer")) < 0)\n<89> } else if (!strcmp(scale->filter->name, "scale")) {\n<91> snprintf(scale_param, sizeof(scale_param)-1, "%d:%d:%s",\n<93> scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n<95> scale->filter->init(scale, scale_param, NULL);\n<101> c->pix_fmt = scale->inputs[0]->format = picref->format;\n<103> c->w       = scale->inputs[0]->w      = picref->video->w;\n<105> c->h       = scale->inputs[0]->h      = picref->video->h;\n<109> link = scale->outputs[0];\n<111> if ((ret =  link->srcpad->config_props(link)) < 0)
<1> void jas_image_dump ( jas_image_t * image , FILE * out ) {\n<10> cmptno < image -> numcmpts_ ;\n<12> cmpt = image -> cmpts_ [ cmptno ] ;\n<13> fprintf ( out , "prec=%d, sgnd=%d, cmpttype=%d\n" , cmpt -> prec_ , cmpt -> sgnd_ , cmpt -> type_ ) ;\n<17> if ( jas_image_readcmpt2 ( image , cmptno , 0 , 0 , n , 1 , buf ) ) {\n<21> i < n ;\n<22> ++ i ) {\n<23> fprintf ( out , " f(%d,%d)=%ld" , i , 0 , buf [ i ] ) ;\n<25> fprintf ( out , "\n" ) ;\n<26> if ( jas_image_readcmpt2 ( image , cmptno , width - n , height - 1 , n , 1 , buf ) ) {\n<30> i < n ;\n<32> fprintf ( out , " f(%d,%d)=%ld" , width - n + i , height - 1 , buf [ i ] ) ;\n<34> fprintf ( out , "\n" ) ;
<1> static hb_face_for_data_closure_t * _hb_face_for_data_closure_create ( hb_blob_t * blob , unsigned int index ) {\n<3> closure = ( hb_face_for_data_closure_t * ) malloc ( sizeof ( hb_face_for_data_closure_t ) ) ;
<1> static BusState * qbus_find ( const char * path ) {\n<4> char elem [ 128 ] , msg [ 256 ] ;\n<6> if ( path [ 0 ] == '/' ) {\n<8> pos = 0 ;\n<11> if ( sscanf ( path , "%127[^/]%n" , elem , & len ) != 1 ) {\n<12> qemu_error ( "path parse error (\"%s\")\n" , path ) ;\n<13> return NULL ;\n<15> bus = qbus_find_recursive ( main_system_bus , elem , NULL ) ;\n<16> if ( ! bus ) {\n<20> pos = len ;\n<25> if ( path [ pos ] == '\0' ) {\n<28> if ( sscanf ( path + pos , "/%127[^/]%n" , elem , & len ) != 1 ) {\n<29> qemu_error ( "path parse error (\"%s\" pos %d)\n" , path , pos ) ;\n<30> return NULL ;\n<32> pos += len ;\n<33> dev = qbus_find_dev ( bus , elem ) ;\n<34> if ( ! dev ) {\n<39> if ( path [ pos ] == '\0' ) {\n<41> case 0 : qemu_error ( "device has no child bus (%s)\n" , path ) ;\n<45> qemu_error ( "device has multiple child busses (%s)\n%s\n" , path , msg ) ;\n<49> if ( sscanf ( path + pos , "/%127[^/]%n" , elem , & len ) != 1 ) {\n<50> qemu_error ( "path parse error (\"%s\" pos %d)\n" , path , pos ) ;\n<51> return NULL ;\n<53> pos += len ;\n<54> bus = qbus_find_bus ( dev , elem ) ;\n<55> if ( ! bus ) {
<3> RELPOBJ_assert ( pThis , Tcp ) ;\n<4> free ( pThis -> privKeyFile ) ;
<1> static int authenticate_nss_2_3 ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n<5> if ( * buf_len <= hash_len [ instance -> crypto_hash_type ] ) {\n<9> if ( calculate_nss_hash ( instance , buf , datalen , tmp_hash ) < 0 ) {\n<12> if ( memcmp ( tmp_hash , buf + datalen , hash_len [ instance -> crypto_hash_type ] ) != 0 ) {\n<13> log_printf ( instance -> log_level_error , "Digest does not match" ) ;\n<14> return - 1 ;\n<16> * buf_len = datalen ;\n<18> return 0 ;
<1> int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,\n<83> for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n<85> int len = strlen(rt->rtsp_streams[rtx]->control_url);\n<87> if (len >= 4 &&\n<89> !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n<101> rtsp_st = rt->rtsp_streams[rtx];
<1> RTPDemuxContext *rtp_parse_open(AVFormatContext *s1, AVStream *st, URLContext *rtpc, int payload_type, RTPPayloadData *rtp_payload_data)\n<11> if (!s)\n<29> if (!strcmp(ff_rtp_enc_name(payload_type), "MP2T")) {\n<31> s->ts = ff_mpegts_parse_open(s->ic);\n<33> if (s->ts == NULL) {\n<43> av_set_pts_info(st, 32, 1, 90000);\n<45> switch(st->codec->codec_id) {\n<81> s->rtp_ctx = rtpc;\n<83> gethostname(s->hostname, sizeof(s->hostname));\n<85> return s;
<1> static int qemu_rdma_drain_cq(QEMUFile *f, RDMAContext *rdma)\n<21> if (ret < 0) {\n<23> fprintf(stderr, "rdma migration: complete polling error!\n");
<1> static int unicast_flush_resp ( struct sock * sk , const struct sadb_msg * ihdr ) {\n<5> if ( ! skb ) return - ENOBUFS ;\n<6> hdr = ( struct sadb_msg * ) skb_put ( skb , sizeof ( struct sadb_msg ) ) ;\n<7> memcpy ( hdr , ihdr , sizeof ( struct sadb_msg ) ) ;
<1> void proto_register_iax2 ( void ) {\n<564> memset ( hf_iax2_ies , 0xff , sizeof ( hf_iax2_ies ) ) ;
<1> static int qio_channel_websock_handshake_read ( QIOChannelWebsock * ioc , Error * * errp ) {\n<11> handshake_end = g_strstr_len ( ( char * ) ioc -> encinput . buffer , ioc -> encinput . offset , QIO_CHANNEL_WEBSOCK_HANDSHAKE_END ) ;\n<12> if ( ! handshake_end ) {\n<24> buffer_advance ( & ioc -> encinput , handshake_end - ( char * ) ioc -> encinput . buffer + strlen ( QIO_CHANNEL_WEBSOCK_HANDSHAKE_END ) ) ;
<29> if (!is_multiboot)\n<32> memset(bootinfo, 0, sizeof(bootinfo));\n<33> memset(&mbs, 0, sizeof(mbs));\n<35> fprintf(stderr, "qemu: multiboot knows VBE. we don't.\n");\n<42> fprintf(stderr, "Cannot load x86-64 image, give a 32bit one.\n");\n<47> fprintf(stderr, "Error while loading elf kernel\n");\n<85> fprintf(stderr, "fread() failed\n");\n<86> memset(mbs.mb_buf + mb_load_size, 0, mb_kernel_size - mb_load_size);\n<92> cmdline_len = strlen(kernel_filename) + 1;\n<93> cmdline_len += strlen(kernel_cmdline) + 1;\n<96> cmdline_len += strlen(r) + 1;\n<103> mbs.mb_buf_size += strlen(bootloader_name) + 1;\n<111> char not_last, tmpbuf[strlen(initrd_filename) + 1];\n<122> if ((next_space = strchr(tmpbuf, ' ')))\n<123> *next_space = '\0';\n<126> if (mb_mod_length < 0) {\n<127> fprintf(stderr, "Failed to open file '%s'\n", tmpbuf);\n<139> char kcmdline[strlen(kernel_filename) + strlen(kernel_cmdline) + 2];
<1> void set_property ( st_command * command , enum_prop prop , my_bool val ) {\n<2> char * p = command -> first_argument ;\n<3> if ( p && ! strcmp ( p , "ONCE" ) ) {\n<4> command -> last_argument = p + 4 ;\n<5> set_once_property ( prop , val ) ;\n<6> return ;\n<8> property & pr = prop_list [ prop ] ;\n<9> * pr . var = val ;\n<10> pr . set = 0 ;\n<11> var_set_int ( pr . env_name , ( val != pr . reverse ) ) ;
<1> static void dump_table ( char * table , char * db ) {\n<14> num_fields = get_table_structure ( table , db , table_type , & ignore_flag ) ;\n<15> if ( strcmp ( table_type , "VIEW" ) == 0 ) DBUG_VOID_RETURN ;\n<22> verbose_msg ( "-- Warning: Skipping data for table '%s' because " "it's of type %s\n" , table , table_type ) ;\n<75> dynstr_append_checked ( & query_string , result_table ) ;\n<101> if ( mysql_num_fields ( res ) != num_fields ) {\n<102> fprintf ( stderr , "%s: Error in field count for table: %s ! Aborting.\n" , my_progname_short , result_table ) ;
<1> const char * mime_field_value_str_from_strlist ( HdrHeap * heap , int * new_str_len_return , StrList * list ) {\n<7> cell = list -> head ;\n<12> cell = cell -> next ;\n<18> dest = new_value ;\n<19> cell = list -> head ;\n<21> i < list -> count ;\n<25> * dest ++ = ' ' ;\n<27> memcpy ( dest , cell -> str , cell -> len ) ;\n<28> dest += cell -> len ;\n<29> cell = cell -> next ;
<1> static unsigned int mszh_decomp ( const unsigned char * srcptr , int srclen , unsigned char * destptr , unsigned int destsize ) {\n<7> while ( srcptr < srcptr_end && destptr < destptr_end ) {\n<8> if ( ! ( mask & maskbit ) ) {\n<9> memcpy ( destptr , srcptr , 4 ) ;\n<10> destptr += 4 ;\n<11> srcptr += 4 ;\n<14> unsigned ofs = bytestream_get_le16 ( & srcptr ) ;\n<21> destptr += cnt ;\n<25> mask = * srcptr ++ ;\n<27> if ( destptr_end - destptr < 32 || srcptr_end - srcptr < 32 ) break ;\n<28> memcpy ( destptr , srcptr , 32 ) ;\n<29> destptr += 32 ;\n<30> srcptr += 32 ;\n<31> mask = * srcptr ++ ;
<1> static int vhdx_open(BlockDriverState *bs, QDict *options, int flags,\n<35> ret = bdrv_pread(bs->file, 0, &signature, sizeof(uint64_t));\n<37> if (ret < 0) {\n<43> if (memcmp(&signature, "vhdxfile", 8)) {\n<45> ret = -EINVAL;\n<59> vhdx_guid_generate(&s->session_guid);\n<63> ret = vhdx_parse_header(bs, s);\n<65> if (ret < 0) {\n<229> vhdx_close(bs);\n<231> return ret;
<1> int ff_ps_read_data(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)\n<101> if (read_iid_data(avctx, gb, ps, ps->iid_par, huff_iid[2*dt+ps->iid_quant], e, dt))\n<118> if (read_icc_data(avctx, gb, ps, ps->icc_par, dt ? huff_icc_dt : huff_icc_df, e, dt))\n<145> cnt -= 2 + ps_read_extension_data(gb, ps, ps_extension_id);\n<175> if (source >= 0 && source != ps->num_env) {\n<177> if (ps->enable_iid) {\n<179> memcpy(ps->iid_par+ps->num_env, ps->iid_par+source, sizeof(ps->iid_par[0]));\n<183> if (ps->enable_icc) {\n<185> memcpy(ps->icc_par+ps->num_env, ps->icc_par+source, sizeof(ps->icc_par[0]));\n<189> if (ps->enable_ipdopd) {\n<191> memcpy(ps->ipd_par+ps->num_env, ps->ipd_par+source, sizeof(ps->ipd_par[0]));\n<193> memcpy(ps->opd_par+ps->num_env, ps->opd_par+source, sizeof(ps->opd_par[0]));
<1> static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, enum AVMediaType type)\n<81> buf = get_line(s);\n<83> if (!buf[0] || buf[0] == '#') {\n<91> if (!(arg = strchr(buf, '='))) {\n<93> av_log(NULL, AV_LOG_FATAL, "Invalid line found in the preset file.\n");\n<95> exit(1);\n<99> *arg++ = 0;\n<101> av_dict_set(&ost->opts, buf, arg, AV_DICT_DONT_OVERWRITE);\n<131> MATCH_PER_STREAM_OPT(bitstream_filters, str, bsf, oc, st);\n<133> while (bsf) {\n<135> if (next = strchr(bsf, ','))\n<137> *next++ = 0;\n<139> if (!(bsfc = av_bitstream_filter_init(bsf))) {\n<159> bsf       = next;\n<169> uint32_t tag = strtol(codec_tag, &next, 0);
<1> static void AddEncodedName ( NamTab * nt , char * utf8name , uint16 lang , uint16 strid ) {\n<7> if ( nt -> cur == 0 ) nt -> entries = malloc ( ( nt -> max = 100 ) * sizeof ( NameEntry ) ) ;\n<8> else nt -> entries = realloc ( nt -> entries , ( nt -> max += 100 ) * sizeof ( NameEntry ) ) ;\n<10> ne = nt -> entries + nt -> cur ;\n<36> if ( macname != NULL ) {\n<42> ne -> len = strlen ( macname ) ;\n<43> dumpstr ( nt -> strings , macname ) ;\n<44> ++ ne ;\n<45> free ( macname ) ;\n<54> if ( macname != NULL && ( ( specific == 2 && macenc == 1 ) || ( specific == 3 && macenc == 25 ) || ( specific == 4 && macenc == 2 ) || ( specific == 5 && macenc == 3 ) ) ) {\n<67> if ( enc == NULL ) -- ne ;\n<69> unichar_t * uin = utf82u_copy ( utf8name ) ;\n<70> outlen = 3 * strlen ( utf8name ) + 10 ;\n<71> out = space = malloc ( outlen + 2 ) ;\n<73> inlen = 2 * u_strlen ( uin ) ;\n<75> iconv ( enc -> fromunicode , & in , & inlen , & out , & outlen ) ;\n<79> ne -> len = strlen ( space ) ;\n<80> dumpstr ( nt -> strings , space ) ;\n<81> free ( space ) ;\n<82> free ( uin ) ;\n<85> ++ ne ;\n<87> nt -> cur = ne - nt -> entries ;
<1> void net_slirp_hostfwd_remove(Monitor *mon, const QDict *qdict)\n<49> if (!src_str || !src_str[0])\n<57> get_str_sep(buf, sizeof(buf), &p, ':');\n<61> if (!strcmp(buf, "tcp") || buf[0] == '\0') {\n<63> is_udp = 0;\n<65> } else if (!strcmp(buf, "udp")) {\n<67> is_udp = 1;\n<77> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<111> monitor_printf(mon, "invalid format\n");
<1> static int cng_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<3> CNGContext * p = avctx -> priv_data ;\n<9> if ( avpkt -> size ) {\n<12> memset ( p -> target_refl_coef , 0 , p -> order * sizeof ( * p -> target_refl_coef ) ) ;\n<16> p -> target_refl_coef [ i ] = ( avpkt -> data [ 1 + i ] - 127 ) / 128.0 ;\n<19> if ( p -> inited ) {\n<27> memcpy ( p -> refl_coef , p -> target_refl_coef , p -> order * sizeof ( * p -> refl_coef ) ) ;\n<30> make_lpc_coefs ( p -> lpc_coef , p -> refl_coef , p -> order ) ;\n<43> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<49> i < avctx -> frame_size ;\n<51> memcpy ( p -> filter_out , p -> filter_out + avctx -> frame_size , p -> order * sizeof ( * p -> filter_out ) ) ;
<1> static void *spapr_create_fdt_skel(const char *cpu_model,\n<277> modelname = g_strdup(cpu_model);\n<281> for (i = 0; i < strlen(modelname); i++) {\n<283> modelname[i] = toupper(modelname[i]);\n<291> spapr->cpu_model = g_strdup(modelname);\n<319> if ((index % smt) != 0) {\n<327> if (asprintf(&nodename, "%s@%x", modelname, index) < 0) {\n<329> fprintf(stderr, "Allocation failure\n");\n<331> exit(1);\n<341> free(nodename);\n<381> servers_prop[i] = cpu_to_be32(index + i);\n<465> g_free(modelname);
<1> static void * mspack_fmap_alloc ( struct mspack_system * self , size_t num ) {\n<2> return malloc ( num ) ;
<1> static int aac_adtstoasc_filter(AVBitStreamFilterContext *bsfc,\n<3> AVCodecContext *avctx, const char *args,\n<73> int            pce_size = 0;\n<75> uint8_t        pce_data[MAX_PCE_SIZE];\n<95> init_put_bits(&pb, pce_data, MAX_PCE_SIZE);\n<97> pce_size = avpriv_copy_pce_data(&pb, &gb)/8;\n<114> init_put_bits(&pb, avctx->extradata, avctx->extradata_size);\n<130> if (pce_size) {\n<132> memcpy(avctx->extradata + 2, pce_data, pce_size);
<1> static void integratorcp_init(ram_addr_t ram_size,\n<31> if (!env) {\n<33> fprintf(stderr, "Unable to find CPU definition\n");
<1> struct pxa2xx_state_s *pxa270_init(unsigned int sdram_size,\n<17> if (revision && strncmp(revision, "pxa27", 5)) {\n<19> fprintf(stderr, "Machine requires a PXA27x processor.\n");
<1> int spapr_populate_pci_devices(sPAPRPHBState *phb,\n<79> bus_off = fdt_add_subnode(fdt, 0, nodename);\n<95> if (ret < 0) {                                             \\n<147> devid = dev->devfn >> 3;\n<149> fn = dev->devfn & 7;\n<153> sprintf(nodename, "pci@%u,%u", devid, fn);\n<159> if (devid > bus->nirq)  {\n<161> printf("Unexpected behaviour in spapr_populate_pci_devices,"\n<169> irqmap[0] = cpu_to_be32(b_ddddd(devid)|b_fff(fn));\n<187> node_off = fdt_add_subnode(fdt, bus_off, nodename);
<1> int qemuMonitorTextDriveDel ( qemuMonitorPtr mon , const char * drivestr ) {\n<3> char * reply = NULL ;\n<15> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<19> if ( strstr ( reply , "unknown command:" ) ) {\n<20> VIR_ERROR ( _ ( "deleting drive is not supported. " "This may leak data if disk is reassigned" ) ) ;\n<21> ret = 1 ;\n<24> else if ( STRPREFIX ( reply , "Device '" ) && ( strstr ( reply , "not found" ) ) ) {\n<26> else if ( STRNEQ ( reply , "" ) ) {\n<30> ret = 0 ;\n<32> VIR_FREE ( reply ) ;
<1> static int vorbis_parse_audio_packet(vorbis_context *vc)\n<21> float *ch_res_ptr   = vc->channel_residues;\n<23> float *ch_floor_ptr = vc->channel_floors;\n<35> if (get_bits1(gb)) {\n<77> memset(ch_res_ptr,   0, sizeof(float) * vc->audio_channels * blocksize / 2); //FIXME can this be removed ?\n<79> memset(ch_floor_ptr, 0, sizeof(float) * vc->audio_channels * blocksize / 2); //FIXME can this be removed ?\n<105> ret = floor->decode(vc, &floor->data, ch_floor_ptr);\n<189> vorbis_residue_decode(vc, residue, ch, do_not_decode, ch_res_ptr, blocksize/2);\n<249> for (j = 0; j < vc->audio_channels; j++) {\n<257> float *saved      = vc->saved + j * bs1 / 4;\n<259> float *ret        = vc->channel_floors + j * retlen;\n<269> vc->dsp.vector_fmul_window(ret, saved, buf, win, blocksize / 4);\n<271> } else if (blockflag > previous_window) {\n<273> vc->dsp.vector_fmul_window(ret, saved, buf, win, bs0 / 4);\n<275> memcpy(ret+bs0/2, buf+bs0/4, ((bs1-bs0)/4) * sizeof(float));\n<279> memcpy(ret, saved, ((bs1 - bs0) / 4) * sizeof(float));\n<281> vc->dsp.vector_fmul_window(ret + (bs1 - bs0) / 4, saved + (bs1 - bs0) / 4, buf, win, bs0 / 4);\n<285> memcpy(saved, buf + blocksize / 4, blocksize / 4 * sizeof(float));
<1> static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size,\n<17> if ((uint64_t)RAM_size > max_mem) {\n<23> (unsigned int)(RAM_size / (1024 * 1024)),\n<25> (unsigned int)(max_mem / (1024 * 1024)));
<1> static int ogg_read_page ( AVFormatContext * s , int * sid ) {\n<12> ret = avio_read ( bc , sync , 4 ) ;\n<16> if ( sync [ sp & 3 ] == 'O' && sync [ ( sp + 1 ) & 3 ] == 'g' && sync [ ( sp + 2 ) & 3 ] == 'g' && sync [ ( sp + 3 ) & 3 ] == 'S' ) break ;\n<17> if ( ! i && bc -> seekable && ogg -> page_pos > 0 ) {\n<18> memset ( sync , 0 , 4 ) ;\n<24> sync [ sp ++ & 3 ] = c ;\n<49> os = ogg -> streams + idx ;\n<78> if ( os -> bufsize - os -> bufpos < size ) {\n<80> if ( ! nb ) return AVERROR ( ENOMEM ) ;\n<81> memcpy ( nb , os -> buf , os -> bufpos ) ;\n<82> av_free ( os -> buf ) ;\n<83> os -> buf = nb ;\n<85> ret = avio_read ( bc , os -> buf + os -> bufpos , size ) ;\n<86> if ( ret < size ) return ret < 0 ? ret : AVERROR_EOF ;\n<87> os -> bufpos += size ;\n<90> memset ( os -> buf + os -> bufpos , 0 , AV_INPUT_BUFFER_PADDING_SIZE ) ;
<1> static int decode_frame(AVCodecContext * avctx, void *data, int *data_size, AVPacket *avpkt)\n<9> KmvcContext *const ctx = avctx->priv_data;\n<19> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<33> if (avctx->get_buffer(avctx, &ctx->pic) < 0) {\n<55> ctx->pal[i + (header & 0x81)] = AV_RB24(buf);\n<91> ctx->pal[i] = bytestream_get_be24(&buf);\n<99> if (pal) {\n<103> memcpy(ctx->pal, pal, AVPALETTE_SIZE);\n<121> memcpy(ctx->pic.data[1], ctx->pal, 1024);\n<129> if (blocksize != 8 && blocksize != 127) {\n<137> memset(ctx->cur, 0, 320 * 200);\n<139> switch (header & KMVC_METHOD) {\n<145> memcpy(ctx->cur, ctx->prev, 320 * 200);\n<151> kmvc_decode_intra_8x8(ctx, buf, buf_size, avctx->width, avctx->height);\n<157> kmvc_decode_inter_8x8(ctx, buf, buf_size, avctx->width, avctx->height);\n<171> out = ctx->pic.data[0];\n<173> src = ctx->cur;\n<175> for (i = 0; i < avctx->height; i++) {\n<177> memcpy(out, src, avctx->width);\n<179> src += 320;\n<181> out += ctx->pic.linesize[0];\n<189> if (ctx->cur == ctx->frm0) {
<1> static void vhost_dev_unassign_memory(struct vhost_dev *dev,\n<17> for (from = 0, to = 0; from < n; ++from, ++to) {\n<19> struct vhost_memory_region *reg = dev->mem->regions + to;\n<31> if (to != from) {\n<33> memcpy(reg, dev->mem->regions + from, sizeof *reg);\n<41> if (!ranges_overlap(reg->guest_phys_addr, reg->memory_size,\n<61> reglast = range_get_last(reg->guest_phys_addr, reg->memory_size);\n<69> if (start_addr <= reg->guest_phys_addr && memlast >= reglast) {\n<89> reg->memory_size = start_addr - reg->guest_phys_addr;\n<91> assert(reg->memory_size);\n<105> if (start_addr <= reg->guest_phys_addr) {\n<107> change = memlast + 1 - reg->guest_phys_addr;\n<109> reg->memory_size -= change;\n<111> reg->guest_phys_addr += change;\n<113> reg->userspace_addr += change;\n<115> assert(reg->memory_size);\n<141> memcpy(dev->mem->regions + n, reg, sizeof *reg);\n<143> reg->memory_size = start_addr - reg->guest_phys_addr;\n<145> assert(reg->memory_size);\n<147> change = memlast + 1 - reg->guest_phys_addr;\n<153> assert(reg->memory_size);\n<155> reg->guest_phys_addr += change;\n<157> reg->userspace_addr += change;
<891> if (FIELD_PICTURE(h)) {\n<893> for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)\n<895> memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));\n<899> memset(h->slice_table, -1,\n<901> (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));\n<909> if (h != h0 && (ret = clone_slice(h, h0)) < 0)\n<939> if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n<953> FIELD_OR_MBAFF_PICTURE(h);\n<1013> ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);\n<1023> ret = ff_set_ref_count(h);\n<1037> memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {\n<1041> ff_h264_fill_default_ref_list(h);\n<1049> ret = ff_h264_decode_ref_pic_list_reordering(h);\n<1069> ff_pred_weight_table(h);\n<1075> implicit_weight_table(h, -1);\n<1119> if (FRAME_MBAFF(h)) {\n<1121> ff_h264_fill_mbaff_ref_list(h);\n<1127> implicit_weight_table(h, 0);\n<1129> implicit_weight_table(h, 1);\n<1139> ff_h264_direct_dist_scale_factor(h);\n<1141> ff_h264_direct_ref_list_init(h);\n<1177> h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);\n<1179> h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);\n<1275> if (h->deblocking_filter == 1 && h0->max_contexts > 1) {\n<1277> if (h->avctx->flags2 & CODEC_FLAG2_FAST) {\n<1305> if (h != h0) {\n<1335> memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));
<1> static void test_rfc2231_parser ( void ) {\n<2> const char * input = ";\n<18> rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;\n<21> output [ i ] != NULL && result [ i ] != NULL ;\n<22> i ++ ) test_assert ( strcmp ( output [ i ] , result [ i ] ) == 0 ) ;\n<24> test_assert ( output [ i ] == NULL && result [ i ] == NULL ) ;
<7> if ( pt -> cnt == 0 ) {\n<11> enttbl = malloc ( pt -> cnt * sizeof ( struct isoent * ) ) ;\n<12> if ( enttbl == NULL ) {
<1> static void read_sysvars ( void ) {\n<14> wants = emalloc_zero ( wants_count ) ;\n<16> while ( NULL != ( v = ctl_getitem ( sys_var , & valuep ) ) ) {\n<19> wants [ v -> code ] = 1 ;\n<25> if ( EOV & v -> flags ) {\n<27> free ( wants ) ;\n<32> wants [ n ] = 1 ;\n<42> n ++ ) if ( wants [ n + CS_MAXCODE + 1 ] ) {\n<43> pch = ext_sys_var [ n ] . text ;\n<44> ctl_putdata ( pch , strlen ( pch ) , 0 ) ;\n<52> kv && ! ( EOV & kv -> flags ) ;\n<53> kv ++ ) if ( DEF & kv -> flags ) ctl_putdata ( kv -> text , strlen ( kv -> text ) , 0 ) ;\n<55> free ( wants ) ;
<1> static unsigned int mszh_decomp(const unsigned char * srcptr, int srclen, unsigned char * destptr, unsigned int destsize)\n<17> while (srcptr < srcptr_end && destptr < destptr_end) {\n<19> if (!(mask & maskbit)) {\n<21> memcpy(destptr, srcptr, 4);\n<23> destptr += 4;\n<25> srcptr += 4;\n<29> unsigned ofs = bytestream_get_le16(&srcptr);\n<43> destptr += cnt;\n<51> mask = *srcptr++;\n<55> if (destptr_end - destptr < 32 || srcptr_end - srcptr < 32) break;\n<57> memcpy(destptr, srcptr, 32);\n<59> destptr += 32;\n<61> srcptr += 32;\n<63> mask = *srcptr++;
<1> static KeydbResourceType rt_from_file ( const char * filename , int * r_found , int * r_openpgp ) {\n<10> if ( fread ( & magic , 4 , 1 , fp ) == 1 ) {\n<11> if ( magic == 0x13579ace || magic == 0xce9a5713 ) ;\n<12> else if ( fread ( & verbuf , 4 , 1 , fp ) == 1 && verbuf [ 0 ] == 1 && fread ( & magic , 4 , 1 , fp ) == 1 && ! memcmp ( & magic , "KBXf" , 4 ) ) {
<1> bool send_add_edge ( connection_t * c , const edge_t * e ) {\n<4> sockaddr2str ( & e -> address , & address , & port ) ;\n<5> x = send_request ( c , "%d %x %s %s %s %s %x %d" , ADD_EDGE , rand ( ) , e -> from -> name , e -> to -> name , address , port , e -> options , e -> weight ) ;\n<6> free ( address ) ;\n<7> free ( port ) ;
<1> int scsi_convert_sense(uint8_t *in_buf, int in_len,\n<3> uint8_t *buf, int len, bool fixed)\n<13> fixed_in = (in_buf[0] & 2) == 0;\n<15> if (in_len && fixed == fixed_in) {\n<17> memcpy(buf, in_buf, MIN(len, in_len));
<1> static inline void dv_decode_video_segment(DVVideoContext *s,\n<47> memset(sblock, 0, sizeof(sblock));
<1> static void wiener_denoise(WMAVoiceContext *s, int fcb_type,\n<3> float *synth_pf, int size,\n<5> const float *lpcs)\n<13> if (fcb_type != FCB_TYPE_SILENCE) {\n<15> float *tilted_lpcs = s->tilted_lpcs_pf,\n<23> memcpy(&tilted_lpcs[1], lpcs, sizeof(lpcs[0]) * s->lsps);\n<27> sizeof(tilted_lpcs[0]) * (128 - s->lsps - 1));\n<29> ff_tilt_compensation(&tilt_mem, 0.7 * tilt_factor(lpcs, s->lsps),\n<45> calc_input_response(s, tilted_lpcs, fcb_type, coeffs, remainder);\n<53> memset(&synth_pf[size], 0, sizeof(synth_pf[0]) * (128 - size));\n<73> ff_rdft_calc(&s->irdft, synth_pf);\n<81> if (s->denoise_filter_cache_size) {\n<91> memmove(s->denoise_filter_cache, &s->denoise_filter_cache[size],\n<93> sizeof(s->denoise_filter_cache[0]) * s->denoise_filter_cache_size);\n<109> if (lim < remainder) {\n<111> memcpy(&s->denoise_filter_cache[lim], &synth_pf[size + lim],\n<113> sizeof(s->denoise_filter_cache[0]) * (remainder - lim));
<1> static void print_md5 ( unsigned char digest [ 16 ] , const char * filename ) {\n<4> i < 16 ;\n<5> ++ i ) printf ( "%02x" , digest [ i ] ) ;\n<6> printf ( " %s\n" , filename ) ;
<1> bool qemu_file_mode_is_not_valid(const char *mode)\n<11> fprintf(stderr, "qemu_fopen: Argument validity check failed\n");
<1> static int decrypt_init(AVFormatContext *s, ID3v2ExtraMeta *em, uint8_t *header)\n<5> OMAContext *oc = s->priv_data;\n<7> ID3v2ExtraMetaGEOB *geob = NULL;\n<21> while (em) {\n<23> if (!strcmp(em->tag, "GEOB") &&\n<25> (geob = em->data) &&\n<27> (!strcmp(geob->description, "OMG_LSI") ||\n<29> !strcmp(geob->description, "OMG_BKLSI"))) {\n<35> em = em->next;\n<39> if (!em) {\n<49> if (geob->datasize < 64) {\n<65> if (AV_RB16(gdata) != 1)\n<81> if (memcmp(&gdata[OMA_ENC_HEADER_SIZE], "KEYRING     ", 12)) {\n<83> av_log(s, AV_LOG_ERROR, "Invalid encryption header\n");\n<85> return AVERROR_INVALIDDATA;\n<89> oc->rid = AV_RB32(&gdata[OMA_ENC_HEADER_SIZE + 28]);\n<91> av_log(s, AV_LOG_DEBUG, "RID: %.8x\n", oc->rid);\n<95> memcpy(oc->iv, &header[0x58], 8);\n<97> hex_log(s, AV_LOG_DEBUG, "IV", oc->iv, 8);\n<103> &gdata[OMA_ENC_HEADER_SIZE + oc->k_size + oc->e_size + oc->i_size],\n<109> if (s->keylen > 0) {\n<115> if (!memcmp(oc->r_val, (const uint8_t[8]){0}, 8) ||\n<117> rprobe(s, gdata, oc->r_val) < 0 &&\n<123> for (i = 0; i < FF_ARRAY_ELEMS(leaf_table); i += 2) {\n<133> if (!rprobe(s, gdata, oc->r_val) ||\n<141> if (i >= sizeof(leaf_table)) {\n<155> av_des_init(&oc->av_des, oc->m_val, 64, 0);\n<157> av_des_crypt(&oc->av_des, oc->e_val,\n<159> &gdata[OMA_ENC_HEADER_SIZE + 40], 1, NULL, 0);\n<161> hex_log(s, AV_LOG_DEBUG, "EK", oc->e_val, 8);\n<167> av_des_init(&oc->av_des, oc->e_val, 64, 1);\n<171> return 0;
<1> static int parse_filter(const char *spec, struct USBAutoFilter *f)\n<7> const char *p = spec;\n<23> for (i = BUS; i < DONE; i++) {\n<25> p = strpbrk(p, ":.");\n<27> if (!p) break;\n<29> p++;\n<33> if (*p == '*')\n<41> case BUS: f->bus_num = strtol(p, NULL, 10);    break;\n<43> case DEV: f->addr    = strtol(p, NULL, 10);    break;\n<45> case VID: f->vendor_id  = strtol(p, NULL, 16); break;\n<47> case PID: f->product_id = strtol(p, NULL, 16); break;\n<55> if (i < DEV) {\n<57> fprintf(stderr, "husb: invalid auto filter spec %s\n", spec);
<1> static void search_request_finished ( struct request * const req ) {\n<6> if ( req -> search_origname ) {\n<7> free ( req -> search_origname ) ;
<1> static int bmp_decode_frame(AVCodecContext *avctx,\n<169> depth = bytestream_get_le16(&buf);\n<175> comp = bytestream_get_le32(&buf);\n<203> rgb[2] = bytestream_get_le32(&buf);\n<207> alpha = bytestream_get_le32(&buf);\n<367> buf   = buf0 + hsize;\n<379> if (n * avctx->height > dsize && comp != BMP_RLE4 && comp != BMP_RLE8) {\n<383> if (n * avctx->height > dsize) {\n<401> if (comp == BMP_RLE4 || comp == BMP_RLE8)\n<403> memset(p->data[0], 0, avctx->height * p->linesize[0]);\n<409> ptr      = p->data[0] + (avctx->height - 1) * p->linesize[0];\n<415> ptr      = p->data[0];\n<423> if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n<429> memset(p->data[1], 0, 1024);\n<439> t   = bytestream_get_le32(&buf);\n<477> ((uint32_t*)p->data[1])[i] = (0xFFU<<24) | bytestream_get_le24(&buf);\n<483> ((uint32_t*)p->data[1])[i] = 0xFFU << 24 | bytestream_get_le32(&buf);\n<487> buf = buf0 + hsize;\n<495> p->data[0]    +=  p->linesize[0] * (avctx->height - 1);\n<507> p->data[0]    +=  p->linesize[0] * (avctx->height - 1);\n<557> for (i = 0; i < avctx->height; i++) {\n<559> memcpy(ptr, buf, n);\n<561> buf += n;\n<563> ptr += linesize;\n<631> uint8_t *ptr = p->data[0] + p->linesize[0]*i + 3;
<238> result = Curl_convert_from_network ( data , k -> p , strlen ( k -> p ) ) ;
<1> static int msrle_decode_frame(AVCodecContext *avctx,\n<13> MsrleContext *s = avctx->priv_data;\n<29> if (avctx->reget_buffer(avctx, &s->frame)) {\n<41> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<45> if (pal) {\n<49> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<59> memcpy(s->frame.data[1], s->pal, AVPALETTE_SIZE);\n<67> int linesize = (avctx->width * avctx->bits_per_coded_sample + 7) / 8;\n<69> uint8_t *ptr = s->frame.data[0];\n<71> uint8_t *buf = avpkt->data + (avctx->height-1)*istride;\n<79> if (avctx->bits_per_coded_sample == 4) {\n<83> ptr[j+0] = buf[j>>1] >> 4;\n<85> ptr[j+1] = buf[j>>1] & 0xF;\n<91> ptr[j+0] = buf[j>>1] >> 4;\n<95> memcpy(ptr, buf, linesize);\n<99> buf -= istride;\n<101> ptr += s->frame.linesize[0];
<1> static void eepro100_cu_command(EEPRO100State * s, uint8_t val)\n<9> switch (val) {\n<391> dump_statistics(s);\n<393> memset(&s->statistics, 0, sizeof(s->statistics));
<1> static int parse_pci_devfn(DeviceState *dev, Property *prop, const char *str)\n<11> if (sscanf(str, "%x.%x%n", &slot, &fn, &n) != 2) {\n<13> fn = 0;\n<15> if (sscanf(str, "%x%n", &slot, &n) != 1) {\n<17> return -EINVAL;\n<23> if (str[n] != '\0')\n<27> if (fn > 7)\n<31> if (slot > 31)\n<35> *ptr = slot << 3 | fn;
<1> void ff_ivi_inverse_haar_4x4(const int32_t *in, int16_t *out, ptrdiff_t pitch,\n<69> if (!src[0] && !src[1] && !src[2] && !src[3]) {\n<71> memset(out, 0, 4 * sizeof(out[0]));\n<85> out += pitch;
<1> static int svc_log ( SvcContext * svc_ctx , SVC_LOG_LEVEL level , const char * fmt , ... ) {\n<5> SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n<6> if ( level > svc_ctx -> log_level ) {\n<9> va_start ( ap , fmt ) ;\n<10> retval = vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ;\n<11> va_end ( ap ) ;\n<12> if ( svc_ctx -> log_print ) {\n<13> printf ( "%s" , buf ) ;\n<16> strncat ( si -> message_buffer , buf , sizeof ( si -> message_buffer ) - strlen ( si -> message_buffer ) - 1 ) ;\n<19> si -> codec_ctx -> err_detail = si -> message_buffer ;\n<21> return retval ;
<1> static void makeAlterConfigCommand ( PGconn * conn , const char * arrayitem , const char * type , const char * name , const char * type2 , const char * name2 ) {\n<5> mine = pg_strdup ( arrayitem ) ;\n<6> pos = strchr ( mine , '=' ) ;\n<7> if ( pos == NULL ) {\n<8> free ( mine ) ;\n<15> appendPQExpBuffer ( buf , "SET %s TO " , fmtId ( mine ) ) ;\n<16> if ( pg_strcasecmp ( mine , "DateStyle" ) == 0 || pg_strcasecmp ( mine , "search_path" ) == 0 ) appendPQExpBufferStr ( buf , pos + 1 ) ;\n<22> free ( mine ) ;
<1> static int mss4_decode_image_block ( MSS4Context * ctx , GetBitContext * gb , uint8_t * picdst [ 3 ] , int mb_x , int mb_y ) {\n<117> j < 16 ;\n<118> j ++ ) memcpy ( picdst [ i ] + mb_x * 16 + j * ctx -> pic . linesize [ i ] , ctx -> imgbuf [ i ] + j * 16 , 16 ) ;
<1> static void init_t38_info_conv ( packet_info * pinfo ) {\n<26> if ( ! p_t38_conv ) {\n<48> conversation_add_proto_data ( p_conv , proto_t38 , p_t38_conv ) ;\n<50> if ( ! p_t38_packet_conv ) {\n<51> p_t38_packet_conv = wmem_new ( wmem_file_scope ( ) , t38_conv ) ;\n<54> memcpy ( & ( p_t38_packet_conv -> src_t38_info ) , & ( p_t38_conv -> src_t38_info ) , sizeof ( t38_conv_info ) ) ;\n<55> memcpy ( & ( p_t38_packet_conv -> dst_t38_info ) , & ( p_t38_conv -> dst_t38_info ) , sizeof ( t38_conv_info ) ) ;\n<59> p_t38_conv_info = & ( p_t38_conv -> src_t38_info ) ;\n<60> p_t38_packet_conv_info = & ( p_t38_packet_conv -> src_t38_info ) ;\n<63> p_t38_conv_info = & ( p_t38_conv -> dst_t38_info ) ;\n<64> p_t38_packet_conv_info = & ( p_t38_packet_conv -> dst_t38_info ) ;
<1> PyObject * PyString_FromString ( const char * str ) {\n<4> assert ( str != NULL ) ;\n<5> size = strlen ( str ) ;\n<6> if ( size > PY_SSIZE_T_MAX - PyStringObject_SIZE ) {\n<25> Py_MEMCPY ( op -> ob_sval , str , size + 1 ) ;
<1> static int load_dtb(hwaddr addr, const struct arm_boot_info *binfo,\n<19> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, binfo->dtb_filename);\n<21> if (!filename) {\n<23> fprintf(stderr, "Couldn't open dtb file %s\n", binfo->dtb_filename);\n<31> fdt = load_device_tree(filename, &size);\n<33> if (!fdt) {\n<35> fprintf(stderr, "Couldn't open dtb file %s\n", filename);\n<37> g_free(filename);\n<49> if (!fdt) {\n<51> fprintf(stderr, "Board was unable to create a dtb blob\n");\n<83> if (acells == 0 || scells == 0) {\n<85> fprintf(stderr, "dtb file invalid (#address-cells or #size-cells 0)\n");\n<93> if (scells < 2 && binfo->ram_size >= (1ULL << 32)) {\n<101> fprintf(stderr, "qemu: dtb file not compatible with "\n<117> if (rc < 0) {\n<119> fprintf(stderr, "couldn't set /memory/reg\n");\n<133> if (rc < 0) {\n<135> fprintf(stderr, "couldn't set /chosen/bootargs\n");\n<151> if (rc < 0) {\n<153> fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");\n<165> if (rc < 0) {\n<167> fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");
<1> void ff_ivi_inverse_haar_8x8(const int32_t *in, int16_t *out, ptrdiff_t pitch,\n<83> memset(out, 0, 8 * sizeof(out[0]));\n<101> out += pitch;
<1> static int flic_decode_frame_15_16BPP(AVCodecContext *avctx,\n<73> pixels = s->frame->data[0];\n<129> switch (chunk_type) {\n<265> s->frame->linesize[0] * s->avctx->height);\n<305> pixels[pixel_ptr++] = palette_idx1;\n<331> pixels[pixel_ptr++] = palette_idx1;
<1> static int vhdx_parse_metadata(BlockDriverState *bs, BDRVVHDXState *s)\n<21> ret = bdrv_pread(bs->file, s->metadata_rt.file_offset, buffer,\n<25> if (ret < 0) {\n<31> memcpy(&s->metadata_hdr, buffer, sizeof(s->metadata_hdr));\n<37> vhdx_metadata_header_le_import(&s->metadata_hdr);\n<41> if (memcmp(&s->metadata_hdr.signature, "metadata", 8)) {\n<43> ret = -EINVAL;\n<51> s->metadata_entries.present = 0;\n<55> if ((s->metadata_hdr.entry_count * sizeof(md_entry)) >\n<57> (VHDX_METADATA_TABLE_MAX_SIZE - offset)) {\n<67> for (i = 0; i < s->metadata_hdr.entry_count; i++) {\n<69> memcpy(&md_entry, buffer + offset, sizeof(md_entry));\n<71> offset += sizeof(md_entry);\n<75> vhdx_metadata_entry_le_import(&md_entry);\n<79> if (guid_eq(md_entry.item_id, file_param_guid)) {\n<89> s->metadata_entries.file_parameters_entry = md_entry;\n<99> if (guid_eq(md_entry.item_id, virtual_size_guid)) {\n<109> s->metadata_entries.virtual_disk_size_entry = md_entry;\n<119> if (guid_eq(md_entry.item_id, page83_guid)) {\n<129> s->metadata_entries.page83_data_entry = md_entry;\n<139> if (guid_eq(md_entry.item_id, logical_sector_guid)) {\n<151> s->metadata_entries.logical_sector_size_entry = md_entry;\n<161> if (guid_eq(md_entry.item_id, phys_sector_guid)) {\n<171> s->metadata_entries.phys_sector_size_entry = md_entry;\n<181> if (guid_eq(md_entry.item_id, parent_locator_guid)) {\n<191> s->metadata_entries.parent_locator_entry = md_entry;\n<201> if (md_entry.data_bits & VHDX_META_FLAGS_IS_REQUIRED) {\n<421> vhdx_set_shift_bits(s);\n<431> qemu_vfree(buffer);
<1> static int flashsv_decode_block(AVCodecContext *avctx, AVPacket *avpkt,\n<13> uint8_t *line = s->tmpblock;\n<91> for (k = 1; k <= s->diff_height; k++) {\n<93> memcpy(s->frame->data[0] + x_pos * 3 +\n<95> (s->image_height - y_pos - k) * s->frame->linesize[0],\n<97> line, width * 3);\n<101> line += width * 3;
<1> static int sendpkt ( void * xdata , size_t xdatalen ) {\n<2> if ( debug >= 3 ) printf ( "Sending %zu octets\n" , xdatalen ) ;\n<3> if ( send ( sockfd , xdata , ( size_t ) xdatalen , 0 ) == - 1 ) {\n<7> if ( debug >= 4 ) {\n<8> printf ( "Request packet:\n" ) ;\n<9> dump_hex_printable ( xdata , xdatalen ) ;
<1> int recreate_table ( MI_CHECK * param , MI_INFO * * org_info , char * filename ) {\n<19> share = * ( * org_info ) -> s ;\n<21> if ( ! ( keyinfo = ( MI_KEYDEF * ) my_alloca ( sizeof ( MI_KEYDEF ) * share . base . keys ) ) ) DBUG_RETURN ( 0 ) ;\n<22> memcpy ( ( uchar * ) keyinfo , ( uchar * ) share . keyinfo , ( size_t ) ( sizeof ( MI_KEYDEF ) * share . base . keys ) ) ;\n<24> if ( ! ( keysegs = ( HA_KEYSEG * ) my_alloca ( sizeof ( HA_KEYSEG ) * ( key_parts + share . base . keys ) ) ) ) {\n<28> if ( ! ( recdef = ( MI_COLUMNDEF * ) my_alloca ( sizeof ( MI_COLUMNDEF ) * ( share . base . fields + 1 ) ) ) ) {\n<33> if ( ! ( uniquedef = ( MI_UNIQUEDEF * ) my_alloca ( sizeof ( MI_UNIQUEDEF ) * ( share . state . header . uniques + 1 ) ) ) ) {\n<39> memcpy ( ( uchar * ) recdef , ( uchar * ) share . rec , ( size_t ) ( sizeof ( MI_COLUMNDEF ) * ( share . base . fields + 1 ) ) ) ;\n<45> memcpy ( ( uchar * ) keysegs , ( uchar * ) share . keyparts , ( size_t ) ( sizeof ( HA_KEYSEG ) * ( key_parts + share . base . keys + share . state . header . uniques ) ) ) ;\n<58> memcpy ( ( uchar * ) uniquedef , ( uchar * ) share . uniqueinfo , ( size_t ) ( sizeof ( MI_UNIQUEDEF ) * ( share . state . header . uniques ) ) ) ;
<1> void * data_create_arabic ( const hb_ot_shape_plan_t * plan ) {\n<2> arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) calloc ( 1 , sizeof ( arabic_shape_plan_t ) ) ;
<1> abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n<190> int total_size = 0;\n<212> if (!(*q = lock_user_string(addr)))\n<214> total_size += strlen(*q) + 1;\n<215> *q = NULL;\n<221> if (!(*q = lock_user_string(addr)))\n<223> total_size += strlen(*q) + 1;
<1> static void _slurm_rpc_epilog_complete ( slurm_msg_t * msg , bool * run_scheduler , bool running_composite ) {\n<20> if ( config_update != slurmctld_conf . last_update ) {\n<21> char * sched_params = slurm_get_sched_params ( ) ;\n<22> defer_sched = ( sched_params && strstr ( sched_params , "defer" ) ) ;\n<23> xfree ( sched_params ) ;\n<40> if ( ! LOTS_OF_AGENTS && ! defer_sched ) ( void ) schedule ( 0 ) ;
<1> static void rtcp_send_sr(AVFormatContext *s1, int64_t ntp_time, int bye)\n<5> RTPMuxContext *s = s1->priv_data;\n<39> if (s->cname) {\n<41> int len = FFMIN(strlen(s->cname), 255);\n<47> avio_wb16(s1->pb, (7 + len + 3) / 4); /* length in words - 1 */\n<55> avio_w8(s1->pb, len);\n<57> avio_write(s1->pb, s->cname, len);
<1> int ff_h264_decode_ref_pic_list_reordering(H264Context *h){\n<153> if (i < 0) {\n<157> memset(&h->ref_list[list][index], 0, sizeof(Picture)); //FIXME\n<175> COPY_PICTURE(&h->ref_list[list][index], ref);\n<179> pic_as_field(&h->ref_list[list][index], pic_structure);\n<215> COPY_PICTURE(&h->ref_list[list][index], &h->default_ref_list[list][0]);
<1> static int kex_agree_kex_hostkey ( LIBSSH2_SESSION * session , unsigned char * kex , unsigned long kex_len , unsigned char * hostkey , unsigned long hostkey_len ) {\n<6> while ( s && * s ) {\n<7> unsigned char * q , * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n<8> size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n<26> while ( * kexp && ( * kexp ) -> name ) {\n<27> s = kex_agree_instr ( kex , kex_len , ( unsigned char * ) ( * kexp ) -> name , strlen ( ( * kexp ) -> name ) ) ;\n<30> session -> kex = * kexp ;
<1> static void test_insert ( ) {\n<19> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<27> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<30> tiny_data < 3 ;\n<31> tiny_data ++ ) {\n<32> length = sprintf ( str_data , "MySQL%d" , tiny_data ) ;
<1> static int alloc_refcount_block(BlockDriverState *bs,\n<31> s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n<111> *refcount_block = NULL;\n<129> int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n<151> if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n<159> if (ret < 0) {\n<167> memset(*refcount_block, 0, s->cluster_size);\n<177> s->set_refcount(*refcount_block, block_index, 1);\n<185> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n<215> if (ret < 0) {\n<223> memset(*refcount_block, 0, s->cluster_size);\n<233> qcow2_cache_entry_mark_dirty(bs, s->refcount_block_cache, *refcount_block);\n<351> uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n<361> size_to_clusters(s, table_size * sizeof(uint64_t));\n<413> if (new_table == NULL || new_blocks == NULL) {\n<427> s->refcount_table_size * sizeof(uint64_t));\n<445> uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n<481> cpu_to_be64s(&new_table[i]);\n<489> ret = bdrv_pwrite_sync(bs->file->bs, table_offset, new_table,\n<503> be64_to_cpus(&new_table[i]);\n<541> g_free(s->refcount_table);\n<543> s->refcount_table = new_table;\n<583> g_free(new_table);
<1> static void * Type_ParametricCurve_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n<11> if ( Type > 4 ) {\n<15> memset ( Params , 0 , sizeof ( Params ) ) ;\n<20> if ( ! _cmsRead15Fixed16Number ( io , & Params [ i ] ) ) return NULL ;\n<22> NewGamma = cmsBuildParametricToneCurve ( self -> ContextID , Type + 1 , Params ) ;
<1> static int _evdns_nameserver_add_impl ( unsigned long int address , int port ) {\n<5> if ( server ) {\n<10> while ( server != started_at ) ;\n<12> ns = ( struct nameserver * ) malloc ( sizeof ( struct nameserver ) ) ;\n<13> if ( ! ns ) return - 1 ;\n<14> memset ( ns , 0 , sizeof ( struct nameserver ) ) ;\n<15> evtimer_set ( & ns -> timeout_event , nameserver_prod_callback , ns ) ;\n<17> if ( ns -> socket < 0 ) {\n<23> ns -> address = address ;\n<24> ns -> port = htons ( port ) ;\n<25> ns -> state = 1 ;\n<26> event_set ( & ns -> event , ns -> socket , EV_READ | EV_PERSIST , nameserver_ready_callback , ns ) ;\n<27> if ( event_add ( & ns -> event , NULL ) < 0 ) {\n<33> ns -> next = ns -> prev = ns ;\n<34> server_head = ns ;\n<39> server_head -> next = ns ;\n<41> server_head -> prev = ns ;\n<46> out2 : CLOSE_SOCKET ( ns -> socket ) ;\n<47> out1 : free ( ns ) ;
<1> static int init_resampler(AVCodecContext *input_codec_context,\n<55> if (!*resample_context) {\n<57> fprintf(stderr, "Could not allocate resample context\n");\n<79> if ((error = swr_init(*resample_context)) < 0) {\n<81> fprintf(stderr, "Could not open resample context\n");
<1> static Datum ExecEvalRow ( RowExprState * rstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n<12> isnull = ( bool * ) palloc ( natts * sizeof ( bool ) ) ;\n<13> memset ( isnull , true , natts * sizeof ( bool ) ) ;\n<17> values [ i ] = ExecEvalExpr ( e , econtext , & isnull [ i ] , NULL ) ;\n<20> tuple = heap_form_tuple ( rstate -> tupdesc , values , isnull ) ;\n<22> pfree ( isnull ) ;
<1> static void close_detect_cb ( struct evhttp_request * req , void * arg ) {\n<4> if ( req != NULL && req -> response_code != HTTP_OK ) {\n<5> fprintf ( stderr , "FAILED\n" ) ;
<1> int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick , my_bool no_copy_stat ) {\n<18> if ( ! ( param -> testflag & T_SILENT ) ) {\n<19> printf ( "- recovering (with keycache) MyISAM-table '%s'\n" , name ) ;\n<20> printf ( "Data records: %s\n" , llstr ( info -> state -> records , llbuff ) ) ;\n<61> info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n<62> info -> state -> empty = 0 ;\n<67> mi_drop_all_indexes ( param , info , TRUE ) ;\n<75> ( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ;\n<93> if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) {\n<97> if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n<115> info -> state -> data_file_length = sort_param . filepos ;\n<119> info -> state -> data_file_length = sort_param . max_pos ;\n<121> if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n<123> if ( start_records != info -> state -> records ) printf ( "Data records: %s\n" , llstr ( info -> state -> records , llbuff ) ) ;\n<127> if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n<139> if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n<150> mi_mark_crashed_on_repair ( info ) ;\n<152> my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n<153> my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;
<1> static void read_ordlist ( struct recvbuf * rbufp , int restrict_mask ) {\n<3> const size_t ifstats_chars = COUNTOF ( ifstats_s ) - 1 ;\n<5> const size_t a_r_chars = COUNTOF ( addr_rst_s ) - 1 ;\n<10> if ( 0 == qdata_octets || ( ifstats_chars == qdata_octets && ! memcmp ( ifstats_s , cpkt -> u . data , ifstats_chars ) ) ) {\n<14> if ( a_r_chars == qdata_octets && ! memcmp ( addr_rst_s , cpkt -> u . data , a_r_chars ) ) {\n<15> read_addr_restrictions ( rbufp ) ;\n<16> return ;\n<18> ctl_error ( CERR_UNKNOWNVAR ) ;
<1> static inline void powerpc_excp(PowerPCCPU *cpu, int excp_model, int excp)\n<155> if (msr_me == 0) {\n<163> fprintf(stderr, "Machine check while not allowed. "
<1> static void handle_child_exit(int sig)\n<11> while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n<17> for (feed = config.first_feed; feed; feed = feed->next) {\n<19> if (feed->pid == pid) {\n<21> int uptime = time(0) - feed->pid_start;\n<27> fprintf(stderr, "%s: Pid %d exited with status %d after %d seconds\n", feed->filename, pid, status, uptime);\n<31> if (uptime < 30)
<1> static void pdf_process_BDC ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi ) {\n<2> if ( proc -> op_BDC ) proc -> op_BDC ( ctx , proc , csi -> name , csi -> obj , resolve_properties ( ctx , csi , csi -> obj ) ) ;\n<3> if ( proc -> hidden > 0 ) {\n<7> if ( strcmp ( csi -> name , "OC" ) ) return ;\n<8> if ( pdf_is_hidden_ocg ( ctx , csi -> doc -> ocg , csi -> rdb , proc -> usage , csi -> obj ) ) ++ proc -> hidden ;
<1> static int pcm_decode_frame(AVCodecContext *avctx, void *data,\n<7> const uint8_t *src = avpkt->data;\n<107> samples = frame->data[0];\n<111> switch (avctx->codec->id) {\n<175> for (c = 0; c < avctx->channels; c++) {\n<177> samples = frame->extended_data[c];\n<187> memcpy(samples, src, n * 2);\n<189> src += n * 2;\n<283> memcpy(samples, src, n * sample_size);
<1> static void png_put_interlaced_row ( uint8_t * dst , int width , int bits_per_pixel , int pass , int color_type , const uint8_t * src ) {\n<8> case 1 : if ( pass == 0 ) memset ( dst , 0 , ( width + 7 ) >> 3 ) ;\n<16> dst [ x >> 3 ] |= b << ( 7 - j ) ;\n<21> default : bpp = bits_per_pixel >> 3 ;\n<22> d = dst ;\n<23> s = src ;\n<41> if ( ( dsp_mask << j ) & 0x80 ) {\n<42> memcpy ( d , s , bpp ) ;\n<44> d += bpp ;\n<45> if ( ( mask << j ) & 0x80 ) s += bpp ;
<1> void gen_intermediate_code(CPUState *cs, TranslationBlock * tb)\n<9> DisasContext dc1, *dc = &dc1;\n<19> memset(dc, 0, sizeof(DisasContext));\n<27> last_pc = dc->pc;\n<87> if (dc->npc & JUMP_PC) {\n<89> assert(dc->jump_pc[1] == dc->pc + 4);\n<91> tcg_gen_insn_start(dc->pc, dc->jump_pc[0] | JUMP_PC);\n<95> tcg_gen_insn_start(dc->pc, dc->npc);\n<101> last_pc = dc->pc;\n<105> if (unlikely(cpu_breakpoint_test(cs, dc->pc, BP_ANY))) {\n<107> if (dc->pc != pc_start) {\n<109> save_state(dc);\n<133> insn = cpu_ldl_code(env, dc->pc);\n<137> disas_sparc_insn(dc, insn);\n<185> if (!dc->is_br) {\n<187> if (dc->pc != DYNAMIC_PC &&\n<189> (dc->npc != DYNAMIC_PC && dc->npc != JUMP_PC)) {\n<193> gen_goto_tb(dc, 0, dc->pc, dc->npc);\n<197> if (dc->pc != DYNAMIC_PC) {\n<199> tcg_gen_movi_tl(cpu_pc, dc->pc);\n<203> save_npc(dc);
<1> static char * normal_dtoa ( double d ) {\n<6> snprintf ( buf , LIB_BUFLENGTH , "%g" , d ) ;\n<7> pch_e = strchr ( buf , 'e' ) ;\n<8> if ( NULL == pch_e ) {\n<9> pch_e = strchr ( buf , 'E' ) ;\n<10> if ( NULL == pch_e ) return buf ;\n<14> if ( '-' == * pch_e ) pch_e ++ ;\n<16> while ( '0' == * pch_nz ) pch_nz ++ ;\n<17> if ( pch_nz == pch_e ) return buf ;\n<18> strncpy ( pch_e , pch_nz , LIB_BUFLENGTH - ( pch_e - buf ) ) ;
<1> static void roq_encode_video ( RoqContext * enc ) {\n<2> RoqTempdata * tempData = enc -> tmpData ;\n<4> memset ( tempData , 0 , sizeof ( * tempData ) ) ;\n<5> create_cel_evals ( enc , tempData ) ;\n<6> generate_new_codebooks ( enc , tempData ) ;\n<13> i ++ ) gather_data_for_cel ( tempData -> cel_evals + i , enc , tempData ) ;\n<14> if ( tempData -> mainChunkSize / 8 > 65535 ) {\n<18> memset ( tempData -> used_option , 0 , sizeof ( tempData -> used_option ) ) ;\n<19> memset ( tempData -> codebooks . usedCB4 , 0 , sizeof ( tempData -> codebooks . usedCB4 ) ) ;\n<20> memset ( tempData -> codebooks . usedCB2 , 0 , sizeof ( tempData -> codebooks . usedCB2 ) ) ;\n<23> remap_codebooks ( enc , tempData ) ;\n<24> write_codebooks ( enc , tempData ) ;\n<25> reconstruct_and_encode_image ( enc , tempData , enc -> width , enc -> height , enc -> width * enc -> height / 64 ) ;
<1> hb_tag_t hb_ot_tag_from_language ( hb_language_t language ) {\n<3> if ( language == HB_LANGUAGE_INVALID ) return HB_OT_TAG_DEFAULT_LANGUAGE ;\n<4> lang_str = hb_language_to_string ( language ) ;\n<5> s = strstr ( lang_str , "x-hbot" ) ;\n<9> s += 6 ;\n<22> lang_tag = ( LangTag * ) bsearch ( lang_str , ot_languages , ARRAY_LENGTH ( ot_languages ) , sizeof ( LangTag ) , ( hb_compare_func_t ) lang_compare_first_component ) ;\n<25> if ( 0 == lang_compare_first_component ( lang_str , "zh" ) ) {\n<36> s = strchr ( lang_str , '-' ) ;\n<37> if ( ! s ) s = lang_str + strlen ( lang_str ) ;\n<38> if ( s - lang_str == 3 ) {
<1> static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)\n<25> src += (get_bits_count(&gb) + 7) / 8;\n<35> if (len < 0) {\n<39> memset(dst, *src++, FFMIN(len, dst_size));\n<43> memcpy(dst, src, FFMIN(len, dst_size));\n<45> src += len;\n<49> dst += len;
<1> static void prepare_pack ( int window , int depth ) {\n<7> if ( ! to_pack . nr_objects || ! window || ! depth ) return ;\n<8> delta_list = xmalloc ( to_pack . nr_objects * sizeof ( * delta_list ) ) ;\n<26> delta_list [ n ++ ] = entry ;\n<32> ll_find_deltas ( delta_list , n , window + 1 , depth , & nr_done ) ;\n<36> free ( delta_list ) ;
<1> static void ehci_advance_state(EHCIState *ehci,\n<47> switch(ehci_get_state(ehci, async)) {\n<147> fprintf(stderr, "Bad state!\n");\n<159> if (again < 0) {\n<161> fprintf(stderr, "processing error - resetting ehci HC\n");
<1> int ff_vc1_parse_frame_header_adv(VC1Context *v, GetBitContext* gb)\n<283> rotate_luts(v);\n<395> status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n<593> memset(v->mv_type_mb_plane, 0, v->s.mb_stride * v->s.mb_height);\n<597> status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n<663> vop_dquant_decoding(v);\n<965> vop_dquant_decoding(v);
<1> int tm_nodeinfo ( tm_node_id * * list , int * nnodes ) {\n<4> int n = 0 ;\n<8> if ( node_table == NULL ) {\n<13> np ++ ) n ++ ;\n<14> if ( ( np = ( tm_node_id * ) calloc ( n , sizeof ( tm_node_id ) ) ) == NULL ) {\n<15> return ( TM_ERROR ) ;\n<17> for ( i = 0 ;\n<18> i < n ;\n<20> * list = np ;\n<21> * nnodes = i ;\n<22> return ( TM_SUCCESS ) ;
<1> static void purple_login ( account_t * acc ) {\n<4> if ( ( local_bee != NULL && local_bee != acc -> bee ) || ( global . conf -> runmode == RUNMODE_DAEMON && ! getenv ( "BITLBEE_DEBUG" ) ) ) {
<1> static void slirp_guestfwd(SlirpState *s, Monitor *mon, const char *config_str,\n<33> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<39> if (strcmp(buf, "tcp") && buf[0] != '\0') {\n<45> if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<125> config_error(mon, "invalid guest forwarding rule '%s'\n", config_str);
<1> int archive_mstring_copy_mbs ( struct archive_mstring * aes , const char * mbs ) {\n<2> if ( mbs == NULL ) {\n<6> return ( archive_mstring_copy_mbs_len ( aes , mbs , strlen ( mbs ) ) ) ;
<1> static int fmtstr ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , const char * value , int flags , int min , int max ) {\n<5> if ( value == 0 ) value = "<NULL>" ;\n<6> strln = strlen ( value ) ;\n<7> if ( strln > INT_MAX ) strln = INT_MAX ;\n<17> if ( ! doapr_outch ( sbuffer , buffer , currlen , maxlen , * value ++ ) ) return 0 ;
<1> void kvm_arch_on_sigbus_vcpu ( CPUState * c , int code , void * addr ) {\n<9> if ( ram_addr != RAM_ADDR_INVALID && kvm_physical_memory_addr_from_host ( c -> kvm_state , addr , & paddr ) ) {\n<14> fprintf ( stderr , "Hardware memory error for memory used by " "QEMU itself instead of guest system!\n" ) ;
<1> static int raw_decode ( char * packet , int len , struct query * q , int dns_fd , int tun_fd ) {\n<3> if ( len < RAW_HDR_LEN ) return 0 ;\n<4> if ( memcmp ( packet , raw_header , RAW_HDR_IDENT_LEN ) ) return 0 ;\n<5> raw_user = RAW_HDR_GET_USR ( packet ) ;\n<6> switch ( RAW_HDR_GET_CMD ( packet ) ) {\n<16> return 1 ;
<1> static void gtkui_inject_user ( int side ) {\n<3> len = strescape ( injectbuf , injectbuf , strlen ( injectbuf ) + 1 ) ;\n<5> user_inject ( injectbuf , len , curr_conn , side ) ;
<1> static void test_qemu_strtoll_max(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoll(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> static void create_cpu_without_cps(const char *cpu_model,\n<19> if (cpu == NULL) {\n<21> fprintf(stderr, "Unable to find CPU definition\n");
<1> static void mspack_fmap_free ( void * mem ) {\n<2> if ( mem ) {\n<3> free ( mem ) ;
<1> static inline void t_gen_mov_TN_preg(TCGv tn, int r)\n<5> if (r < 0 || r > 15) {\n<7> fprintf(stderr, "wrong register read $p%d\n", r);\n<11> if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {
<1> void xps_parse_glyphs ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n<22> fz_xml * fill_tag = NULL ;\n<43> is_sideways_att = fz_xml_att ( root , "IsSideways" ) ;\n<46> style_att = fz_xml_att ( root , "StyleSimulations" ) ;\n<53> node ;\n<55> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs.RenderTransform" ) ) transform_tag = fz_xml_down ( node ) ;\n<56> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs.OpacityMask" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n<57> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs.Clip" ) ) clip_tag = fz_xml_down ( node ) ;\n<58> if ( ! strcmp ( fz_xml_tag ( node ) , "Glyphs.Fill" ) ) fill_tag = fz_xml_down ( node ) ;\n<64> xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n<71> if ( is_sideways_att ) is_sideways = ! strcmp ( is_sideways_att , "true" ) ;\n<80> if ( style_att ) {\n<81> if ( ! strcmp ( style_att , "BoldSimulation" ) ) fz_strlcat ( fakename , "#Bold" , sizeof fakename ) ;\n<82> else if ( ! strcmp ( style_att , "ItalicSimulation" ) ) fz_strlcat ( fakename , "#Italic" , sizeof fakename ) ;\n<83> else if ( ! strcmp ( style_att , "BoldItalicSimulation" ) ) fz_strlcat ( fakename , "#BoldItalic" , sizeof fakename ) ;\n<86> if ( ! font ) {\n<95> if ( strstr ( part -> name , ".odttf" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n<96> if ( strstr ( part -> name , ".ODTTF" ) ) xps_deobfuscate_font_resource ( doc , part ) ;\n<108> if ( style_att ) {\n<109> font -> ft_bold = ! ! strstr ( style_att , "Bold" ) ;\n<110> font -> ft_italic = ! ! strstr ( style_att , "Italic" ) ;\n<125> text = xps_parse_glyphs_imp ( doc , & local_ctm , font , font_size , fz_atof ( origin_x_att ) , fz_atof ( origin_y_att ) , is_sideways , bidi_level , indices_att , unicode_att ) ;\n<129> if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , "SolidColorBrush" ) ) {\n<130> fill_opacity_att = fz_xml_att ( fill_tag , "Opacity" ) ;\n<131> fill_att = fz_xml_att ( fill_tag , "Color" ) ;\n<132> fill_tag = NULL ;\n<144> xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;
<1> static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)\n<27> if ((p[1] & 0xF) == 8) {\n<31> if (p[3] < 20 || memcmp(&p[4], "naa.", 4)) {\n<33> return -EINVAL;\n<37> if (p[3] > 20 && p[24] != ',') {
<1> void eval_expr ( VAR * v , const char * p , const char * * p_end , bool open_end , bool do_eval ) {\n<3> DBUG_PRINT ( "enter" , ( "p: '%s'" , p ) ) ;\n<4> if ( ! do_eval ) goto NO_EVAL ;\n<8> if ( ( vp = var_get ( p , p_end , 0 , 0 ) ) ) var_copy ( v , vp ) ;\n<9> v -> str_val [ v -> str_val_len ] = 0 ;\n<14> if ( * p == '`' ) {\n<15> var_query_set ( v , p , p_end ) ;\n<19> const char * get_value_str = "query_get_value" ;\n<20> const size_t len = strlen ( get_value_str ) ;\n<21> if ( strncmp ( p , get_value_str , len ) == 0 ) {\n<23> memset ( & command , 0 , sizeof ( command ) ) ;\n<29> var_set_query_get_value ( & command , v ) ;\n<34> int new_val_len = ( p_end && * p_end ) ? ( int ) ( * p_end - p ) : ( int ) strlen ( p ) ;\n<37> v -> alloced_len = ( new_val_len < MIN_VAR_ALLOC - 1 ) ? MIN_VAR_ALLOC : new_val_len + 1 ;\n<38> if ( ! ( v -> str_val = v -> str_val ? ( char * ) my_realloc ( v -> str_val , v -> alloced_len + 1 , MYF ( MY_WME ) ) : ( char * ) my_malloc ( v -> alloced_len + 1 , MYF ( MY_WME ) ) ) ) die ( "Out of memory" ) ;\n<41> memcpy ( v -> str_val , p , new_val_len ) ;\n<43> var_check_int ( v ) ;
<1> int test_div_word ( BIO * bp ) {\n<39> if ( ! BN_is_zero ( & b ) ) {\n<40> fprintf ( stderr , "Division (word) test failed!\n" ) ;
<1> int check_change_password ( THD * thd , const char * host , const char * user , char * new_password , uint new_password_len ) {\n<2> if ( ! initialized ) {\n<6> if ( ! thd -> slave_thread && ( strcmp ( thd -> security_ctx -> user , user ) || my_strcasecmp ( system_charset_info , host , thd -> security_ctx -> priv_host ) ) ) {\n<7> if ( check_access ( thd , UPDATE_ACL , "mysql" , 0 , 1 , 0 , 0 ) ) return ( 1 ) ;\n<9> if ( ! thd -> slave_thread && ! thd -> security_ctx -> user [ 0 ] ) {\n<13> size_t len = strlen ( new_password ) ;\n<14> if ( len && len != SCRAMBLED_PASSWORD_CHAR_LENGTH && len != SCRAMBLED_PASSWORD_CHAR_LENGTH_323 ) {
<1> static int wavpack_encode_block(WavPackEncodeContext *s,\n<3> int32_t *samples_l, int32_t *samples_r,\n<31> diff |= samples_l[i] - samples_r[i];\n<85> shift_mono(samples_l, nb_samples, shift);\n<89> shift_stereo(samples_l, samples_r, nb_samples, shift);\n<105> if ((s->flags & WV_FLOAT_DATA) || (s->flags & MAG_MASK) >> MAG_LSB >= 24) {\n<107> av_fast_padded_malloc(&s->orig_l, &s->orig_l_size, sizeof(int32_t) * nb_samples);\n<109> memcpy(s->orig_l, samples_l, sizeof(int32_t) * nb_samples);\n<111> if (!(s->flags & WV_MONO_DATA)) {\n<113> av_fast_padded_malloc(&s->orig_r, &s->orig_r_size, sizeof(int32_t) * nb_samples);\n<115> memcpy(s->orig_r, samples_r, sizeof(int32_t) * nb_samples);\n<123> got_extra = scan_float(s, samples_l, samples_r, nb_samples);\n<127> got_extra = scan_int32(s, samples_l, samples_r, nb_samples);\n<155> ret = wv_mono(s, samples_l, 1, 0);\n<159> ret = wv_stereo(s, samples_l, samples_r, 1, 0);\n<177> ret = wv_mono(s, samples_l, !s->num_terms, 1);\n<189> ret = wv_stereo(s, samples_l, samples_r, !s->num_terms, 1);
<1> static void test_bug15752 ( ) {\n<5> const char * query = "CALL p1()" ;\n<12> if ( ! mysql_real_connect ( & mysql_local , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , CLIENT_MULTI_STATEMENTS ) ) {\n<13> printf ( "Unable connect to MySQL server: %s\n" , mysql_error ( & mysql_local ) ) ;\n<16> rc = mysql_real_query ( & mysql_local , query , strlen ( query ) ) ;\n<19> rc = mysql_real_query ( & mysql_local , query , strlen ( query ) ) ;\n<21> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( & mysql_local ) ) ;\n<26> i < ITERATION_COUNT ;\n<28> if ( mysql_real_query ( & mysql_local , query , strlen ( query ) ) ) {\n<29> printf ( "\ni=%d %s failed: %s\n" , i , query , mysql_error ( & mysql_local ) ) ;
<1> static void pc_init1(ram_addr_t ram_size, int vga_ram_size,\n<81> if (!env) {\n<83> fprintf(stderr, "Unable to find x86 CPU definition\n");\n<177> bios_size = get_image_size(buf);\n<189> ret = load_image(buf, phys_ram_base + bios_offset);\n<191> if (ret != bios_size) {\n<195> fprintf(stderr, "qemu: could not load PC BIOS '%s'\n", buf);\n<217> vga_bios_size = get_image_size(buf);\n<219> if (vga_bios_size <= 0 || vga_bios_size > 65536)\n<227> ret = load_image(buf, phys_ram_base + vga_bios_offset);\n<229> if (ret != vga_bios_size) {\n<233> fprintf(stderr, "qemu: could not load VGA BIOS '%s'\n", buf);\n<297> size = get_image_size(option_rom[i]);\n<299> if (size < 0) {\n<301> fprintf(stderr, "Could not load option rom '%s'\n",\n<309> if (size > (0x10000 - offset))\n<315> ret = load_image(option_rom[i], phys_ram_base + option_rom_offset);\n<317> if (ret != size) {\n<321> fprintf(stderr, "Too many option ROMS\n");\n<405> if (pci_enabled)\n<413> fprintf(stderr, "%s: vmware_vga: no PCI bus\n", __FUNCTION__);\n<501> for(i = 0; i < nb_nics; i++) {\n<503> NICInfo *nd = &nd_table[i];\n<507> if (!pci_enabled || (nd->model && strcmp(nd->model, "ne2k_isa") == 0))\n<509> pc_init_ne2k_isa(nd, i8259);\n<513> pci_nic_init(pci_bus, nd, -1, "ne2k_pci");\n<519> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<521> fprintf(stderr, "qemu: too many IDE bus\n");
<42> if ( ! data -> state . this_is_a_follow ) {\n<43> free ( data -> state . first_host ) ;\n<44> data -> state . first_host = strdup ( conn -> host . name ) ;\n<45> if ( ! data -> state . first_host ) return CURLE_OUT_OF_MEMORY ;\n<69> if ( Curl_checkheaders ( conn , "User-Agent:" ) ) {\n<70> free ( conn -> allocptr . uagent ) ;
<1> static void test_identify(void)\n<7> uint16_t buf[256];\n<69> string_cpu_to_be16(&buf[10], 20);\n<71> ret = memcmp(&buf[10], "testdisk            ", 20);\n<73> g_assert(ret == 0);\n<77> string_cpu_to_be16(&buf[23], 8);\n<79> ret = memcmp(&buf[23], "version ", 8);\n<81> g_assert(ret == 0);
<2> struct xml_ctx * ctx = ( struct xml_ctx * ) userData ;\n<3> free ( ctx -> cdata ) ;
<1> static void lsi_soft_reset(LSIState *s)\n<29> memset(s->scratch, 0, sizeof(s->scratch));
<1> static void kvmclock_pre_save(void *opaque)\n<21> if (ret < 0) {\n<23> fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret));
<1> static int parse_channel_name(char **arg, int *rchannel, int *rnamed)\n<5> char buf[8];\n<7> int len, i, channel_id = 0;\n<15> if (sscanf(*arg, " %7[A-Z] %n", buf, &len)) {\n<17> layout0 = layout = av_get_channel_layout(buf);\n<21> for (i = 32; i > 0; i >>= 1) {\n<35> if (channel_id >= MAX_CHANNELS || layout0 != (int64_t)1 << channel_id)\n<43> *arg += len;\n<51> if (sscanf(*arg, " c%d %n", &channel_id, &len) &&\n<53> channel_id >= 0 && channel_id < MAX_CHANNELS) {\n<55> *rchannel = channel_id;\n<57> *rnamed = 0;\n<59> *arg += len;\n<61> return 0;\n<65> return AVERROR(EINVAL);
<1> ParseResult mime_parser_parse ( MIMEParser * parser , HdrHeap * heap , MIMEHdrImpl * mh , const char * * real_s , const char * real_e , bool must_copy_strings , bool eof ) {\n<31> if ( ( ! ParseRules : : is_token ( * field_name_first ) ) && ( * field_name_first != '@' ) ) {\n<34> colon = ( char * ) memchr ( line_c , ':' , ( line_e - line_c ) ) ;\n<35> if ( ! colon ) {
<1> int setenv(const char *name, const char *value, int overwrite)\n<4> if (overwrite || !getenv(name)) {\n<5> size_t length = strlen(name) + strlen(value) + 2;\n<6> char *string = g_malloc(length);\n<7> snprintf(string, length, "%s=%s", name, value);\n<8> result = putenv(string);
<1> static int ffm_read_data(AVFormatContext *s,\n<3> uint8_t *buf, int size, int header)\n<7> FFMContext *ffm = s->priv_data;\n<25> len = ffm->packet_end - ffm->packet_ptr;\n<35> if (len == 0) {\n<147> memcpy(buf, ffm->packet_ptr, len);\n<149> buf += len;\n<151> ffm->packet_ptr += len;\n<153> size -= len;
<1> vpx_codec_err_t vpx_svc_set_options ( SvcContext * svc_ctx , const char * options ) {\n<2> SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n<3> if ( svc_ctx == NULL || options == NULL || si == NULL ) {\n<6> strncpy ( si -> options , options , sizeof ( si -> options ) ) ;
<1> static void print_xml_row ( FILE * xml_file , const char * row_name , MYSQL_RES * tableRes , MYSQL_ROW * row , const char * str_create ) {\n<8> fprintf ( xml_file , "\t\t<%s" , row_name ) ;\n<9> check_io ( xml_file ) ;\n<12> ( field = mysql_fetch_field ( tableRes ) ) ;\n<14> if ( ( * row ) [ i ] ) {\n<15> if ( ( str_create ) && ( strcmp ( str_create , field -> name ) == 0 ) ) {\n<16> create_stmt_ptr = ( * row ) [ i ] ;\n<17> create_stmt_len = lengths [ i ] ;\n<30> if ( create_stmt_len ) {\n<33> print_xml_cdata ( xml_file , create_stmt_ptr , create_stmt_len ) ;\n<34> fprintf ( xml_file , "\t\t</%s>\n" , row_name ) ;\n<37> check_io ( xml_file ) ;
<1> static void decode_fill_block ( RangeCoder * c , FillBlockCoder * fc , uint8_t * dst , int stride , int block_size ) {\n<3> fc -> fill_val += decode_coeff ( c , & fc -> coef_model ) ;\n<5> i < block_size ;\n<6> i ++ , dst += stride ) memset ( dst , fc -> fill_val , block_size ) ;
<1> int av_find_stream_info(AVFormatContext *ic)\n<79> if (!has_codec_parameters(st->codec))\n<91> if(st->parser && st->parser->parser->split && !st->codec->extradata)\n<145> if (!has_codec_parameters(st->codec)){\n<149> avcodec_string(buf, sizeof(buf), st->codec, 0);\n<195> if (av_dup_packet(pkt) < 0) {\n<241> if(duration_count[index] < 2)\n<243> memset(duration_error, 0, sizeof(duration_error));\n<273> if(st->parser && st->parser->parser->split && !st->codec->extradata){\n<275> int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);\n<277> if(i){\n<279> st->codec->extradata_size= i;\n<281> st->codec->extradata= av_malloc(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<283> memcpy(st->codec->extradata, pkt->data, st->codec->extradata_size);\n<285> memset(st->codec->extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<301> if (!has_codec_parameters(st->codec) /*&&\n<331> try_decode_frame(st, pkt->data, pkt->size);\n<355> avcodec_close(st->codec);
<1> static void do_video_out(AVFormatContext *s,\n<3> AVOutputStream *ost,\n<187> fprintf(stderr, "pixel format conversion not handled\n");\n<257> if (s->oformat->flags & AVFMT_RAWPICTURE) {\n<275> memset(&big_picture, 0, sizeof(AVFrame));\n<277> *(AVPicture*)&big_picture= *final_picture;\n<287> big_picture.quality = ist->st->quality;\n<291> big_picture.quality = ost->st->quality;\n<315> if (ost->logfile && enc->stats_out) {\n<317> fprintf(ost->logfile, "%s", enc->stats_out);
<1> void ff_rtp_send_aac(AVFormatContext *s1, const uint8_t *buff, int size)\n<5> RTPMuxContext *s = s1->priv_data;\n<23> buff += 7;\n<33> len = (s->buf_ptr - s->buf);\n<41> p = s->buf + max_au_headers_size - au_size - 2;\n<43> if (p != s->buf) {\n<45> memmove(p + 2, s->buf + 2, au_size);\n<51> p[0] = ((au_size * 8) & 0xFF) >> 8;\n<57> ff_rtp_send_data(s1, p, s->buf_ptr - p, 1);\n<67> s->buf_ptr = s->buf + max_au_headers_size;\n<75> if (size <= max_packet_size) {\n<81> *p = (size & 0x1F) << 3;\n<83> memcpy(s->buf_ptr, buff, size);\n<85> s->buf_ptr += size;\n<95> p = s->buf;\n<97> p[0] = 0;\n<99> p[1] = 16;\n<101> while (size > 0) {\n<103> len = FFMIN(size, max_packet_size);\n<105> p[2] = au_size >> 5;\n<107> p[3] = (au_size & 0x1F) << 3;\n<109> memcpy(p + 4, buff, len);\n<111> ff_rtp_send_data(s1, p, len + 4, len == size);\n<115> buff += len;
<1> bool check_grant_db ( THD * thd , const char * db ) {\n<2> Security_context * sctx = thd -> security_ctx ;\n<7> copy_length = ( size_t ) ( strlen ( sctx -> priv_user ? sctx -> priv_user : "" ) + strlen ( db ? db : "" ) ) + 1 ;\n<8> if ( copy_length >= ( NAME_LEN + USERNAME_LENGTH + 2 ) ) return 1 ;\n<9> len = ( uint ) ( strmov ( strmov ( helping , sctx -> priv_user ) + 1 , db ) - helping ) + 1 ;\n<12> idx < column_priv_hash . records ;\n<13> idx ++ ) {\n<14> GRANT_TABLE * grant_table = ( GRANT_TABLE * ) hash_element ( & column_priv_hash , idx ) ;\n<15> if ( len < grant_table -> key_length && ! memcmp ( grant_table -> hash_key , helping , len ) && compare_hostname ( & grant_table -> host , sctx -> host , sctx -> ip ) ) {\n<16> error = FALSE ;
<1> static int64_t load_kernel (void)\n<35> if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n<41> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<97> initrd_size = get_image_size (loaderparams.initrd_filename);\n<103> if (initrd_offset + initrd_size > ram_size) {\n<115> initrd_size = load_image_targphys(loaderparams.initrd_filename,\n<123> if (initrd_size == (target_ulong) -1) {\n<125> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<145> prom_set(prom_buf, prom_index++, "%s", loaderparams.kernel_filename);
<1> static void nand_command(NANDFlashState *s)\n<7> switch (s->cmd) {\n<147> printf("%s: Unknown NAND command 0x%02x\n", __FUNCTION__, s->cmd);
<1> int gdbserver_start(const char *device)\n<15> if (!device)\n<19> if (strcmp(device, "none") != 0) {\n<21> if (strstart(device, "tcp:", NULL)) {\n<35> else if (strcmp(device, "stdio") == 0) {\n<41> memset(&act, 0, sizeof(act));\n<43> act.sa_handler = gdb_sigterm_handler;\n<45> sigaction(SIGINT, &act, NULL);\n<51> chr = qemu_chr_new("gdb", device, NULL);\n<53> if (!chr)\n<68> s = gdbserver_state;\n<70> if (!s) {\n<94> qemu_chr_delete(s->chr);\n<98> memset(s, 0, sizeof(GDBState));\n<102> s->c_cpu = first_cpu;\n<104> s->g_cpu = first_cpu;\n<106> s->chr = chr;\n<108> s->state = chr ? RS_IDLE : RS_INACTIVE;\n<110> s->mon_chr = mon_chr;\n<112> s->current_syscall_cb = NULL;\n<116> return 0;
<1> int jbig2_error ( Jbig2Ctx * ctx , Jbig2Severity severity , int32_t segment_number , const char * fmt , ... ) {\n<6> va_start ( ap , fmt ) ;\n<7> n = vsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ;\n<8> va_end ( ap ) ;\n<9> if ( n < 0 || n == sizeof ( buf ) ) strncpy ( buf , "jbig2_error: error in generating error string" , sizeof ( buf ) ) ;\n<10> code = ctx -> error_callback ( ctx -> error_callback_data , buf , severity , segment_number ) ;
<1> static rfbClientPtr rfbNewTCPOrUDPClient ( rfbScreenInfoPtr rfbScreen , int sock , rfbBool isUDP ) {\n<9> cl = ( rfbClientPtr ) calloc ( sizeof ( rfbClientRec ) , 1 ) ;\n<15> rfbResetStats ( cl ) ;
<1> static void formant_postfilter ( G723_1_Context * p , int16_t * lpc , int16_t * buf , int16_t * dst ) {\n<3> int filter_signal [ LPC_ORDER + FRAME_LEN ] , * signal_ptr ;\n<5> memcpy ( buf , p -> fir_mem , LPC_ORDER * sizeof ( * buf ) ) ;\n<6> memcpy ( filter_signal , p -> iir_mem , LPC_ORDER * sizeof ( * filter_signal ) ) ;\n<16> iir_filter ( filter_coef [ 0 ] , filter_coef [ 1 ] , buf + i , filter_signal + i ) ;\n<19> memcpy ( p -> fir_mem , buf + FRAME_LEN , LPC_ORDER * sizeof ( * p -> fir_mem ) ) ;\n<20> memcpy ( p -> iir_mem , filter_signal + FRAME_LEN , LPC_ORDER * sizeof ( * p -> iir_mem ) ) ;\n<21> buf += LPC_ORDER ;\n<22> signal_ptr = filter_signal + LPC_ORDER ;\n<48> gain_scale ( p , dst , energy ) ;
<1> readv_f(int argc, char **argv)\n<21> int pattern = 0;\n<27> while ((c = getopt(argc, argv, "CP:qv")) != EOF) {\n<41> pattern = atoi(optarg);\n<75> offset = cvtnum(argv[optind]);\n<77> if (offset < 0) {\n<79> printf("non-numeric length argument -- %s\n", argv[optind]);\n<89> if (offset & 0x1ff) {\n<103> buf = create_iovec(&qiov, &argv[optind], nr_iov, 0xab);\n<109> cnt = do_aio_readv(&qiov, offset, &total);\n<115> if (cnt < 0) {\n<117> printf("readv failed: %s\n", strerror(-cnt));\n<125> if (Pflag) {\n<127> void* cmp_buf = malloc(qiov.size);\n<129> memset(cmp_buf, pattern, qiov.size);\n<131> if (memcmp(buf, cmp_buf, qiov.size)) {\n<133> printf("Pattern verification failed at offset %lld, "\n<137> (long long) offset, qiov.size);\n<141> free(cmp_buf);\n<155> dump_buffer(buf, offset, qiov.size);\n<163> print_report("read", &t2, offset, qiov.size, total, cnt, Cflag);\n<167> qemu_io_free(buf);
<1> int parse_host_src_port(struct sockaddr_in *haddr,\n<5> const char *input_str)\n<9> char *str = strdup(input_str);\n<11> char *host_str = str;\n<31> if ((ptr = strchr(str,',')))\n<33> *ptr = '\0';\n<37> if ((src_str = strchr(input_str,'@'))) {\n<39> *src_str = '\0';\n<41> src_str++;\n<47> if (parse_host_port(haddr, host_str) < 0)\n<53> src_str2 = src_str;\n<55> if (!src_str || *src_str == '\0')\n<61> if (parse_host_port(saddr, src_str2) < 0)\n<67> free(str);\n<75> free(str);
<1> static void sdp_parse_fmtp_config(AVCodecContext *codec, char *attr, char *value)\n<5> switch (codec->codec_id) {\n<11> if (!strcmp(attr, "config")) {\n<15> int len = hex_to_data(NULL, value);\n<19> codec->extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);\n<21> if (!codec->extradata)\n<39> return;
<1> do_command(GIOChannel *source,\n<41> if (strncmp(string, "exit", 4) == 0) {\n<49> printf("Active Readers:\n");\n<91> reader = vreader_get_reader_by_id(reader_id);\n<93> if (reader != NULL) {\n<95> error = vcard_emul_force_card_insert(reader);\n<99> vreader_get_name(reader), error);\n<103> printf("no reader by id %u found\n", reader_id);\n<115> reader = vreader_get_reader_by_id(reader_id);\n<117> if (reader != NULL) {\n<119> error = vcard_emul_force_card_remove(reader);\n<123> vreader_get_name(reader), error);\n<127> printf("no reader by id %u found\n", reader_id);\n<141> if (reader_id != VSCARD_UNDEFINED_READER_ID) {\n<143> reader = vreader_get_reader_by_id(reader_id);\n<147> if (reader) {\n<151> vreader_get_name(reader));\n<153> default_reader_id = reader_id;\n<157> printf("Reader with id %u not found\n", reader_id);\n<161> } else if (strncmp(string, "debug", 5) == 0) {\n<165> verbose = get_id_from_string(&string[6], 0);\n<169> printf("debug level = %d\n", verbose);\n<171> } else if (strncmp(string, "list", 4) == 0) {\n<177> printf("Active Readers:\n");\n<189> if (reader_id == -1) {\n<201> vreader_get_name(reader));\n<205> printf("Inactive Readers:\n");\n<217> if (reader_id != -1) {\n<231> vreader_get_name(reader));\n<236> } else if (*string != 0) {\n<238> printf("valid commands:\n");\n<240> printf("insert [reader_id]\n");\n<242> printf("remove [reader_id]\n");\n<244> printf("select reader_id\n");\n<246> printf("list\n");\n<248> printf("debug [level]\n");\n<250> printf("exit\n");\n<258> printf("> ");
<1> static void make_dirty(uint8_t device)\n<25> buf = g_malloc(len);\n<27> memset(buf, rand() % 255 + 1, len);\n<31> g_assert(buf);\n<35> memwrite(guest_buf, buf, len);
<1> static int open_f(BlockDriverState *bs, int argc, char **argv)\n<49> if (!qemu_opts_parse(&empty_opts, optarg, 0)) {\n<51> printf("could not parse option list -- %s\n", optarg);
<1> static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) {\n<6> res = validate_img ( ctx , img ) ;\n<7> if ( res == VPX_CODEC_OK && cpi != NULL && ctx -> cx_data == NULL ) {\n<9> if ( ctx -> cx_data_sz < 4096 ) ctx -> cx_data_sz = 4096 ;\n<10> ctx -> cx_data = ( unsigned char * ) malloc ( ctx -> cx_data_sz ) ;\n<11> if ( ctx -> cx_data == NULL ) {\n<16> pick_quickcompress_mode ( ctx , duration , deadline ) ;\n<40> res = update_error_state ( ctx , & cpi -> common . error ) ;\n<43> cx_data = ctx -> cx_data ;\n<44> cx_data_sz = ctx -> cx_data_sz ;\n<45> if ( ctx -> pending_cx_data ) {\n<46> memmove ( cx_data , ctx -> pending_cx_data , ctx -> pending_cx_data_sz ) ;\n<47> ctx -> pending_cx_data = cx_data ;\n<48> cx_data += ctx -> pending_cx_data_sz ;\n<49> cx_data_sz -= ctx -> pending_cx_data_sz ;\n<50> if ( cx_data_sz < ctx -> cx_data_sz / 2 ) {\n<55> while ( cx_data_sz >= ctx -> cx_data_sz / 2 && - 1 != vp9_get_compressed_data ( cpi , & lib_flags , & size , cx_data , & dst_time_stamp , & dst_end_time_stamp , ! img ) ) {\n<61> ctx -> pending_cx_data_sz += size ;\n<75> ctx -> pending_cx_data_sz += size ;
<1> static int mp_decode_frame ( MPADecodeContext * s , OUT_INT * * samples , const uint8_t * buf , int buf_size ) {\n<14> default : nb_frames = mp_decode_layer3 ( s ) ;\n<15> if ( nb_frames < 0 ) return nb_frames ;\n<16> s -> last_buf_size = 0 ;\n<20> if ( i >= 0 && i <= BACKSTEP_SIZE ) {\n<21> memmove ( s -> last_buf , s -> gb . buffer + ( get_bits_count ( & s -> gb ) >> 3 ) , i ) ;\n<22> s -> last_buf_size = i ;\n<36> memcpy ( s -> last_buf + s -> last_buf_size , s -> gb . buffer + buf_size - HEADER_SIZE - i , i ) ;\n<37> s -> last_buf_size += i ;
<1> static int write_VD_boot_record ( struct archive_write * a ) {\n<6> set_VD_bp ( bp , VDT_BOOT_RECORD , 1 ) ;\n<7> memcpy ( bp + 8 , "EL TORITO SPECIFICATION" , 23 ) ;
<1> static int isoent_gen_joliet_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) {\n<22> np != NULL ;\n<27> if ( ( l = np -> file -> basename_utf16 . length ) > ffmax ) l = ffmax ;\n<28> p = malloc ( ( l + 1 ) * 2 ) ;\n<29> if ( p == NULL ) {\n<33> memcpy ( p , np -> file -> basename_utf16 . s , l ) ;\n<34> p [ l ] = 0 ;\n<35> p [ l + 1 ] = 0 ;\n<36> np -> identifier = ( char * ) p ;\n<37> lt = l ;\n<38> dot = p + l ;\n<41> if ( ! joliet_allowed_char ( p [ 0 ] , p [ 1 ] ) ) archive_be16enc ( p , 0x005F ) ;\n<42> else if ( p [ 0 ] == 0 && p [ 1 ] == 0x2E ) dot = p ;\n<43> p += 2 ;\n<48> np -> ext_len = ( int ) l - ext_off ;\n<49> np -> id_len = ( int ) l ;\n<51> if ( archive_strncpy_l ( & iso9660 -> mbs , ( const char * ) np -> identifier , l , iso9660 -> sconv_from_utf16be ) != 0 && errno == ENOMEM ) {\n<64> if ( l == ffmax ) noff = ext_off - 6 ;
<1> static void complete_from_nicklist ( GList * * outlist , CHANNEL_REC * channel , const char * nick , const char * suffix , const int match_case ) {\n<8> len = strlen ( nick ) ;\n<14> if ( ( match_case ? strncmp ( rec -> nick , nick , len ) : g_ascii_strncasecmp ( rec -> nick , nick , len ) ) == 0 && ( match_case ? glist_find_string ( * outlist , rec -> nick ) : glist_find_icase_string ( * outlist , rec -> nick ) ) == NULL ) {
<7> static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,\n<17> const uint8_t *buf             = avpkt->data;\n<19> int buf_size                   = avpkt->size;\n<109> frame->buf[0] = av_buffer_alloc(FFMAX(context->frame_size, buf_size));\n<289> } else if (need_copy) {\n<291> memcpy(frame->buf[0]->data, buf, buf_size);\n<293> buf = frame->buf[0]->data;\n<303> buf += buf_size - context->frame_size;\n<309> if (buf_size < len && ((avctx->codec_tag & 0xFFFFFF) != MKTAG('B','I','T', 0) || !need_copy)) {\n<313> av_buffer_unref(&frame->buf[0]);\n<327> av_buffer_unref(&frame->buf[0]);\n<337> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE,\n<347> context->palette = av_buffer_alloc(AVPALETTE_SIZE);\n<349> if (!context->palette) {\n<351> av_buffer_unref(&frame->buf[0]);\n<357> memcpy(context->palette->data, pal, AVPALETTE_SIZE);\n<409> frame->buf[1]  = av_buffer_ref(context->palette);\n<413> av_buffer_unref(&frame->buf[0]);
<1> static int string_num_dots ( const char * s ) {\n<3> while ( ( s = strchr ( s , '.' ) ) ) {\n<4> s ++ ;\n<5> count ++ ;
<1> static void decode_rowskip(uint8_t* plane, int width, int height, int stride, VC9Context *v){\n<11> if (!get_bits(gb, 1)) //rowskip\n<13> memset(plane, 0, width);\n<17> for (x=0; x<width; x++)\n<19> plane[x] = get_bits(gb, 1);\n<21> plane += stride;
<1> void usage_exit ( ) {\n<2> fprintf ( stderr , "Usage: %s <infile> <outfile> <N-M|N/M>\n" , exec_name ) ;
<1> static void test_tco_second_timeout_pause(void)\n<37> g_assert(!strcmp(qdict_get_str(ad, "action"), "pause"));
<1> static bfd_boolean srec_read_section ( bfd * abfd , asection * section , bfd_byte * contents ) {\n<19> if ( buf != NULL ) free ( buf ) ;\n<29> if ( buf != NULL ) free ( buf ) ;\n<44> if ( buf != NULL ) free ( buf ) ;\n<58> if ( buf != NULL ) free ( buf ) ;\n<60> error_return : if ( buf != NULL ) free ( buf ) ;
<1> static int read_application_extension ( Gif_Context * gfc , Gif_Reader * grr ) {\n<5> gifgetblock ( buffer , len , grr ) ;\n<6> if ( len == 11 && ( memcmp ( buffer , "NETSCAPE2.0" , 11 ) == 0 || memcmp ( buffer , "ANIMEXTS1.0" , 11 ) == 0 ) ) {\n<7> len = gifgetbyte ( grr ) ;\n<8> if ( len == 3 ) {\n<15> while ( len > 0 ) {\n<16> gifgetblock ( buffer , len , grr ) ;\n<19> return 1 ;\n<21> else return read_unknown_extension ( gfc , grr , 0xFF , ( char * ) buffer , len ) ;
<1> static void check_databases_are_compatible ( void ) {\n<9> newdbinfo = & new_cluster . dbarr . dbs [ newdbnum ] ;\n<11> olddbnum < old_cluster . dbarr . ndbs ;\n<12> olddbnum ++ ) {\n<13> olddbinfo = & old_cluster . dbarr . dbs [ olddbnum ] ;\n<14> if ( strcmp ( newdbinfo -> db_name , olddbinfo -> db_name ) == 0 ) {\n<15> check_locale_and_encoding ( olddbinfo , newdbinfo ) ;
<1> void TSMimeFieldValueInsert ( TSMBuffer bufp , TSMLoc field_obj , const char * value , int length , int idx ) {\n<4> if ( length == - 1 ) {\n<5> length = strlen ( value ) ;\n<7> mime_field_value_insert_comma_val ( heap , handle -> mh , handle -> field_ptr , idx , value , length ) ;
<1> void http_postrequest_done ( struct evhttp_request * req , void * arg ) {\n<2> const char * what = "This is funny" ;\n<3> if ( req == NULL ) {\n<4> fprintf ( stderr , "FAILED (timeout)\n" ) ;\n<7> if ( req -> response_code != HTTP_OK ) {\n<8> fprintf ( stderr , "FAILED (response code)\n" ) ;\n<11> if ( evhttp_find_header ( req -> input_headers , "Content-Type" ) == NULL ) {\n<12> fprintf ( stderr , "FAILED (content type)\n" ) ;\n<15> if ( EVBUFFER_LENGTH ( req -> input_buffer ) != strlen ( what ) ) {\n<16> fprintf ( stderr , "FAILED (length %zu vs %zu)\n" , EVBUFFER_LENGTH ( req -> input_buffer ) , strlen ( what ) ) ;\n<19> if ( memcmp ( EVBUFFER_DATA ( req -> input_buffer ) , what , strlen ( what ) ) != 0 ) {\n<20> fprintf ( stderr , "FAILED (data)\n" ) ;\n<21> exit ( 1 ) ;
<1> static inline unsigned update_map_generation ( MotionEstContext * c ) {\n<3> if ( c -> map_generation == 0 ) {\n<5> memset ( c -> map , 0 , sizeof ( uint32_t ) * ME_MAP_SIZE ) ;
<1> static int adx_decode_frame(AVCodecContext *avctx,\n<9> ADXContext *c = avctx->priv_data;\n<13> const uint8_t *buf = buf0;\n<27> buf  += hdrsize;\n<35> if (c->in_temp) {\n<37> int copysize = 18*avctx->channels - c->in_temp;\n<39> memcpy(c->dec_temp+c->in_temp,buf,copysize);\n<41> rest -= copysize;\n<43> buf  += copysize;\n<47> adx_decode(samples,c->dec_temp,c->prev);\n<53> adx_decode_stereo(samples,c->dec_temp,c->prev);\n<65> while(rest>=18) {\n<71> buf+=18;\n<79> while(rest>=18*2) {\n<85> buf+=18*2;\n<97> if (rest) {\n<99> memcpy(c->dec_temp,buf,rest);\n<101> buf+=rest;
<1> static void postfilter_5k0 ( SiprContext * ctx , const float * lpc , float * samples ) {\n<14> memcpy ( pole_out - LP_FILTER_ORDER , ctx -> postfilter_mem , LP_FILTER_ORDER * sizeof ( float ) ) ;\n<16> memcpy ( ctx -> postfilter_mem , pole_out + SUBFR_SIZE - LP_FILTER_ORDER , LP_FILTER_ORDER * sizeof ( float ) ) ;\n<18> memcpy ( pole_out - LP_FILTER_ORDER , ctx -> postfilter_mem5k0 , LP_FILTER_ORDER * sizeof ( * pole_out ) ) ;\n<19> memcpy ( ctx -> postfilter_mem5k0 , pole_out + SUBFR_SIZE - LP_FILTER_ORDER , LP_FILTER_ORDER * sizeof ( * pole_out ) ) ;
<1> static int fz_make_hash_link_key ( fz_context * ctx , fz_store_hash * hash , void * key_ ) {\n<2> fz_link_key * key = ( fz_link_key * ) key_ ;\n<3> memcpy ( hash -> u . link . dst_md5 , key -> dst_md5 , 16 ) ;\n<4> memcpy ( hash -> u . link . src_md5 , key -> src_md5 , 16 ) ;
<1> static void gen_dirac_train ( int16_t * buf , int pitch_lag ) {\n<2> int16_t vector [ SUBFRAME_LEN ] ;\n<4> memcpy ( vector , buf , SUBFRAME_LEN * sizeof ( * vector ) ) ;\n<10> j ++ ) buf [ i + j ] += vector [ j ] ;
<1> int kvm_arch_handle_exit ( CPUState * cs , struct kvm_run * run ) {\n<5> switch ( run -> exit_reason ) {\n<19> if ( host_supports_vmx ( ) && code == VMX_INVALID_GUEST_STATE ) {\n<20> fprintf ( stderr , "\nIf you're running a guest on an Intel machine without " "unrestricted mode\n" "support, the failure can be most likely due to the guest " "entering an invalid\n" "state for Intel VT. For example, the guest maybe running " "in big real mode\n" "which is not supported on less recent Intel processors." "\n\n" ) ;\n<24> case KVM_EXIT_EXCEPTION : fprintf ( stderr , "KVM: exception %d exit (error code 0x%x)\n" , run -> ex . exception , run -> ex . error_code ) ;\n<37> default : fprintf ( stderr , "KVM: unknown exit reason %d\n" , run -> exit_reason ) ;
<1> static int kadmin_parse_princ_args ( int argc , char * argv [ ] , kadm5_principal_ent_t oprinc , long * mask , char * * pass , krb5_boolean * randkey , krb5_key_salt_tuple * * ks_tuple , int * n_ks_tuple , char * caller ) {\n<14> i < argc - 1 ;\n<15> i ++ ) {\n<17> if ( ! strcmp ( "-x" , argv [ i ] ) ) {\n<18> if ( ++ i > argc - 2 ) return - 1 ;\n<19> add_tl_data ( & oprinc -> n_tl_data , & oprinc -> tl_data , KRB5_TL_DB_ARGS , strlen ( argv [ i ] ) + 1 , ( krb5_octet * ) argv [ i ] ) ;\n<23> if ( ! strcmp ( "-expire" , argv [ i ] ) ) {\n<24> if ( ++ i > argc - 2 ) return - 1 ;\n<25> date = get_date ( argv [ i ] ) ;\n<26> if ( date == ( time_t ) - 1 ) {\n<27> fprintf ( stderr , _ ( "Invalid date specification \"%s\".\n" ) , argv [ i ] ) ;\n<34> if ( ! strcmp ( "-pwexpire" , argv [ i ] ) ) {\n<35> if ( ++ i > argc - 2 ) return - 1 ;\n<36> date = get_date ( argv [ i ] ) ;\n<37> if ( date == ( time_t ) - 1 ) {\n<38> fprintf ( stderr , _ ( "Invalid date specification \"%s\".\n" ) , argv [ i ] ) ;\n<45> if ( ! strcmp ( "-maxlife" , argv [ i ] ) ) {\n<46> if ( ++ i > argc - 2 ) return - 1 ;\n<47> date = get_date ( argv [ i ] ) ;\n<48> if ( date == ( time_t ) - 1 ) {\n<49> fprintf ( stderr , _ ( "Invalid date specification \"%s\".\n" ) , argv [ i ] ) ;\n<56> if ( ! strcmp ( "-maxrenewlife" , argv [ i ] ) ) {\n<57> if ( ++ i > argc - 2 ) return - 1 ;\n<58> date = get_date ( argv [ i ] ) ;\n<59> if ( date == ( time_t ) - 1 ) {\n<60> fprintf ( stderr , _ ( "Invalid date specification \"%s\".\n" ) , argv [ i ] ) ;\n<67> if ( ! strcmp ( "-kvno" , argv [ i ] ) ) {\n<68> if ( ++ i > argc - 2 ) return - 1 ;\n<69> oprinc -> kvno = atoi ( argv [ i ] ) ;\n<73> if ( ! strcmp ( "-policy" , argv [ i ] ) ) {\n<74> if ( ++ i > argc - 2 ) return - 1 ;\n<75> oprinc -> policy = argv [ i ] ;\n<79> if ( ! strcmp ( "-clearpolicy" , argv [ i ] ) ) {\n<80> oprinc -> policy = NULL ;\n<81> * mask |= KADM5_POLICY_CLR ;\n<84> if ( ! strcmp ( "-pw" , argv [ i ] ) ) {\n<85> if ( ++ i > argc - 2 ) return - 1 ;\n<86> * pass = argv [ i ] ;\n<89> if ( ! strcmp ( "-randkey" , argv [ i ] ) ) {\n<90> * randkey = TRUE ;\n<93> if ( ! strcmp ( "-unlock" , argv [ i ] ) ) {\n<94> unlock_princ ( oprinc , mask , caller ) ;\n<97> if ( ! strcmp ( "-e" , argv [ i ] ) ) {\n<98> if ( ++ i > argc - 2 ) return - 1 ;\n<99> retval = krb5_string_to_keysalts ( argv [ i ] , ", \t" , ":.-" , 0 , ks_tuple , n_ks_tuple ) ;\n<101> com_err ( caller , retval , _ ( "while parsing keysalts %s" ) , argv [ i ] ) ;\n<106> for ( j = 0 ;\n<107> j < sizeof ( flags ) / sizeof ( struct pflag ) ;\n<108> j ++ ) {\n<109> if ( strlen ( argv [ i ] ) == flags [ j ] . flaglen + 1 && ! strcmp ( flags [ j ] . flagname , & argv [ i ] [ 1 ] ) ) {\n<110> if ( ( flags [ j ] . set && argv [ i ] [ 0 ] == '-' ) || ( ! flags [ j ] . set && argv [ i ] [ 0 ] == '+' ) ) {\n<116> else if ( ( flags [ j ] . set && argv [ i ] [ 0 ] == '+' ) || ( ! flags [ j ] . set && argv [ i ] [ 0 ] == '-' ) ) {\n<130> retval = kadmin_parse_name ( argv [ i ] , & oprinc -> principal ) ;
<29> ( field = mysql_fetch_field ( result ) ) ;\n<31> uint name_length = ( uint ) strlen ( field -> name ) ;\n<32> uint numcells = charset_info -> cset -> numcells ( charset_info , field -> name , field -> name + name_length ) ;\n<33> uint display_length = field -> max_length + name_length - numcells ;\n<34> tee_fprintf ( PAGER , " %-*s |" , ( int ) min ( display_length , MAX_COLUMN_LENGTH ) , field -> name ) ;
<1> static void col_append_info_by_handle ( packet_info * pinfo , guint16 handle , bluetooth_data_t * bluetooth_data ) {\n<5> service_uuid = get_service_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n<6> characteristic_uuid = get_characteristic_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n<7> uuid = get_uuid_from_handle ( pinfo , handle , bluetooth_data ) ;\n<8> if ( ! memcmp ( & service_uuid , & uuid , sizeof ( uuid ) ) ) {\n<9> col_append_fstr ( pinfo -> cinfo , COL_INFO , ", Handle: 0x%04x (%s)" , handle , print_uuid ( & uuid ) ) ;\n<11> else if ( ! memcmp ( & characteristic_uuid , & uuid , sizeof ( uuid ) ) ) {\n<12> col_append_fstr ( pinfo -> cinfo , COL_INFO , ", Handle: 0x%04x (%s: %s)" , handle , print_uuid ( & service_uuid ) , print_uuid ( & uuid ) ) ;\n<15> col_append_fstr ( pinfo -> cinfo , COL_INFO , ", Handle: 0x%04x (%s: %s: %s)" , handle , print_uuid ( & service_uuid ) , print_uuid ( & characteristic_uuid ) , print_uuid ( & uuid ) ) ;
<37> if (end - dst < count) {\n<47> memset(dst, 0, count);\n<75> if (zero_run) {\n<81> memcpy(dst, src, i);\n<95> memcpy(dst, src, i);
<1> void ff_xvmc_decode_mb(MpegEncContext *s)\n<265> for (i = 4; i < blocks_per_mb; i++) {\n<267> memset(s->pblocks[i], 0, sizeof(*s->pblocks[i]));  // so we need to clear them\n<319> if (s->avctx->xvmc_acceleration == 1) {\n<321> memcpy(&render->data_blocks[render->next_free_data_block_num*64],
<1> static const uint8_t *read_huffman_tables(FourXContext *f, const uint8_t * const buf){\n<21> memset(frequency, 0, sizeof(frequency));\n<23> memset(up, -1, sizeof(up));\n<71> if(frequency[i] == 0) continue;\n<73> if(frequency[i] < min_freq[1]){\n<75> if(frequency[i] < min_freq[0]){\n<79> min_freq[0]= frequency[i];smallest[0]= i;\n<83> min_freq[1]= frequency[i];smallest[1]= i;\n<121> for(node= j; up[node] != -1; node= up[node]){
<1> void hw_error ( const char * fmt , ... ) {\n<6> fprintf ( stderr , "qemu: hardware error: " ) ;\n<7> vfprintf ( stderr , fmt , ap ) ;\n<8> fprintf ( stderr , "\n" ) ;\n<10> env != NULL ;\n<12> cpu = ENV_GET_CPU ( env ) ;\n<13> fprintf ( stderr , "CPU #%d:\n" , cpu -> cpu_index ) ;\n<14> cpu_dump_state ( cpu , stderr , fprintf , CPU_DUMP_FPU ) ;
<1> void proto_report_dissector_bug ( const char * message ) {\n<2> if ( getenv ( "WIRESHARK_ABORT_ON_DISSECTOR_BUG" ) != NULL ) abort ( ) ;\n<3> else THROW_MESSAGE ( DissectorError , message ) ;
<1> static void clear_commits(BDRVVVFATState* s)\n<7> DLOG(fprintf(stderr, "clear_commits (%d commits)\n", s->commits.next));\n<9> for (i = 0; i < s->commits.next; i++) {\n<11> commit_t* commit = array_get(&(s->commits), i);\n<13> assert(commit->path || commit->action == ACTION_WRITEOUT);\n<15> if (commit->action != ACTION_WRITEOUT) {\n<17> assert(commit->path);\n<19> free(commit->path);
<1> void signal_init(void)\n<29> memset(sigact_table, 0, sizeof(sigact_table));
<1> static void long_help ( void ) {\n<4> prog = lafe_getprogname ( ) ;\n<6> p = ( strcmp ( prog , "bsdcpio" ) != 0 ) ? "(bsdcpio)" : "" ;\n<7> printf ( "%s%s: manipulate archive files\n" , prog , p ) ;\n<13> fputs ( prog , stdout ) ;
<1> int ASN1_BIT_STRING_set_bit ( ASN1_BIT_STRING * a , int n , int value ) {\n<8> if ( a == NULL ) return 0 ;\n<14> if ( c == NULL ) {\n<18> if ( w + 1 - a -> length > 0 ) memset ( c + a -> length , 0 , w + 1 - a -> length ) ;
<1> static void dropRoles ( PGconn * conn ) {\n<9> if ( PQntuples ( res ) > 0 ) fprintf ( OPF , "--\n-- Drop roles\n--\n\n" ) ;\n<19> fprintf ( OPF , "\n\n" ) ;
<1> static int com_help ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) ) {\n<3> char * help_arg = strchr ( line , ' ' ) , buff [ 32 ] , * end ;\n<5> while ( my_isspace ( charset_info , * help_arg ) ) help_arg ++ ;\n<6> if ( * help_arg ) return com_server_help ( buffer , line , help_arg ) ;
<1> int main ( int argc , char * argv [ ] ) {\n<47> progname = get_progname ( argv [ 0 ] ) ;\n<50> while ( ( c = getopt_long ( argc , argv , "h:p:U:wWeqd:at:v" , long_options , & optindex ) ) != - 1 ) {\n<51> switch ( c ) {\n<76> default : fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<84> if ( optind < argc ) {\n<85> fprintf ( stderr , _ ( "%s: too many command-line arguments (first is \"%s\")\n" ) , progname , argv [ optind ] ) ;\n<86> fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<91> if ( dbname ) {\n<92> fprintf ( stderr , _ ( "%s: cannot cluster all databases and a specific one at the same time\n" ) , progname ) ;\n<95> if ( tables . head != NULL ) {\n<96> fprintf ( stderr , _ ( "%s: cannot cluster specific table(s) in all databases\n" ) , progname ) ;\n<99> cluster_all_databases ( verbose , maintenance_db , host , port , username , prompt_password , progname , echo , quiet ) ;\n<102> if ( dbname == NULL ) {\n<103> if ( getenv ( "PGDATABASE" ) ) dbname = getenv ( "PGDATABASE" ) ;\n<104> else if ( getenv ( "PGUSER" ) ) dbname = getenv ( "PGUSER" ) ;\n<105> else dbname = get_user_name_or_exit ( progname ) ;\n<112> cluster_one_database ( dbname , verbose , cell -> val , host , port , username , prompt_password , progname , echo ) ;\n<115> else cluster_one_database ( dbname , verbose , NULL , host , port , username , prompt_password , progname , echo ) ;
<1> int qemuMonitorTextGetCPUInfo ( qemuMonitorPtr mon , int * * pids ) {\n<7> if ( qemuMonitorHMPCommand ( mon , "info cpus" , & qemucpus ) < 0 ) {\n<11> line = qemucpus ;\n<13> char * offset = strchr ( line , '#' ) ;\n<15> int vcpu = 0 , tid = 0 ;\n<16> if ( offset == NULL ) break ;\n<17> if ( virStrToLong_i ( offset + 1 , & end , 10 , & vcpu ) < 0 ) goto error ;\n<18> if ( end == NULL || * end != ':' ) goto error ;\n<19> if ( ( offset = strstr ( line , "thread_id=" ) ) == NULL ) goto error ;\n<20> if ( virStrToLong_i ( offset + strlen ( "thread_id=" ) , & end , 10 , & tid ) < 0 ) goto error ;\n<21> if ( end == NULL || ! c_isspace ( * end ) ) goto error ;\n<23> if ( VIR_REALLOC_N ( cpupids , ncpupids + 1 ) < 0 ) goto error ;\n<24> VIR_DEBUG ( "vcpu=%d pid=%d" , vcpu , tid ) ;\n<25> cpupids [ ncpupids ++ ] = tid ;\n<27> line = strchr ( offset , '\r' ) ;\n<28> if ( line == NULL ) line = strchr ( offset , '\n' ) ;\n<30> while ( line != NULL ) ;\n<34> error : VIR_FREE ( qemucpus ) ;\n<35> VIR_FREE ( cpupids ) ;\n<36> return 0 ;
<1> static char * construct_command_line ( struct manager_ctx * manager , struct server * server ) {\n<2> static char cmd [ BUF_SIZE ] ;\n<7> memset ( cmd , 0 , BUF_SIZE ) ;\n<8> snprintf ( cmd , BUF_SIZE , "%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf" , executable , manager -> manager_address , working_dir , port , working_dir , port ) ;\n<9> if ( manager -> acl != NULL ) {\n<10> int len = strlen ( cmd ) ;\n<11> snprintf ( cmd + len , BUF_SIZE - len , " --acl %s" , manager -> acl ) ;\n<13> if ( manager -> timeout != NULL ) {\n<14> int len = strlen ( cmd ) ;\n<15> snprintf ( cmd + len , BUF_SIZE - len , " -t %s" , manager -> timeout ) ;\n<22> int len = strlen ( cmd ) ;\n<23> snprintf ( cmd + len , BUF_SIZE - len , " -a %s" , manager -> user ) ;
<1> static KeyValue *copy_key_value(KeyValue *src)\n<5> KeyValue *dst = g_new(KeyValue, 1);\n<7> memcpy(dst, src, sizeof(*src));\n<14> return dst;
<1> int rtp_packetize_xiph_config ( sout_stream_id_sys_t * id , const char * fmtp , int64_t i_pts ) {\n<2> if ( fmtp == NULL ) return VLC_EGENERIC ;\n<3> char * start = strstr ( fmtp , "configuration=" ) ;\n<4> assert ( start != NULL ) ;\n<9> size_t len = end - start ;\n<10> char * b64 = malloc ( len + 1 ) ;\n<11> if ( ! b64 ) return VLC_EGENERIC ;\n<12> memcpy ( b64 , start , len ) ;\n<13> b64 [ len ] = '\0' ;\n<17> i_data = vlc_b64_decode_binary ( & p_orig , b64 ) ;\n<18> free ( b64 ) ;\n<19> if ( i_data <= 9 ) {\n<20> free ( p_orig ) ;\n<23> p_data = p_orig + 9 ;\n<27> i < i_count ;\n<43> rtp_packetize_common ( id , out , 0 , i_pts ) ;\n<44> SetDWBE ( out -> p_buffer + 12 , header ) ;\n<45> SetWBE ( out -> p_buffer + 16 , i_payload ) ;\n<46> memcpy ( & out -> p_buffer [ 18 ] , p_data , i_payload ) ;\n<48> rtp_packetize_send ( id , out ) ;\n<49> p_data += i_payload ;\n<50> i_data -= i_payload ;\n<52> free ( p_orig ) ;
<1> static int test_iopt_flush_instructions ( xd3_stream * stream , int ignore ) {\n<29> target [ tpos ++ ] = 0 ;\n<34> target [ tpos ++ ] = i ;\n<36> if ( ( ret = xd3_encode_stream ( stream , target , tpos , delta , & delta_size , sizeof ( delta ) ) ) ) {\n<43> if ( ( ret = xd3_decode_stream ( stream , delta , delta_size , recon , & recon_size , sizeof ( recon ) ) ) ) {\n<46> CHECK ( tpos == recon_size ) ;\n<47> CHECK ( memcmp ( target , recon , recon_size ) == 0 ) ;
<1> static int doTest(uint8_t *ref[3], int refStride[3], int w, int h, int srcFormat, int dstFormat,\n<5> uint8_t *src[3];\n<7> uint8_t *dst[3];\n<9> uint8_t *out[3];\n<25> for (i=0; i<3; i++){\n<49> src[i]= (uint8_t*) malloc(srcStride[i]*srcH);\n<51> dst[i]= (uint8_t*) malloc(dstStride[i]*dstH);\n<53> out[i]= (uint8_t*) malloc(refStride[i]*h);\n<55> if (!src[i] || !dst[i] || !out[i]) {\n<75> if (!srcContext) {\n<79> sws_format_name(PIX_FMT_YUV420P),\n<81> sws_format_name(srcFormat));\n<91> dstContext= sws_getContext(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, NULL, NULL, NULL);\n<93> if (!dstContext) {\n<97> sws_format_name(srcFormat),\n<99> sws_format_name(dstFormat));\n<109> outContext= sws_getContext(dstW, dstH, dstFormat, w, h, PIX_FMT_YUV420P, flags, NULL, NULL, NULL);\n<111> if (!outContext) {\n<115> sws_format_name(dstFormat),\n<117> sws_format_name(PIX_FMT_YUV420P));\n<135> sws_scale(dstContext, src, srcStride, 0, srcH, dst, dstStride);\n<137> sws_scale(outContext, dst, dstStride, 0, dstH, out, refStride);\n<153> ssdY/= w*h;\n<155> ssdU/= w*h/4;\n<157> ssdV/= w*h/4;\n<161> printf(" %s %dx%d -> %s %4dx%4d flags=%2d SSD=%5lld,%5lld,%5lld\n",\n<163> sws_format_name(srcFormat), srcW, srcH,\n<165> sws_format_name(dstFormat), dstW, dstH,\n<185> for (i=0; i<3; i++){\n<187> free(src[i]);\n<189> free(dst[i]);\n<191> free(out[i]);
<1> static void destroy_restrict_fifo ( restrict_fifo * fifo ) {\n<3> if ( fifo != NULL ) {\n<5> UNLINK_FIFO ( rn , * fifo , link ) ;\n<9> free ( fifo ) ;
<1> static int tgv_decode_frame(AVCodecContext *avctx,\n<13> TgvContext *s = avctx->priv_data;\n<69> s->palette[i] = 0xFF << 24 | AV_RB24(buf);\n<89> if (!s->frame.data[0]) {\n<107> s->frame.data[1] = av_malloc(AVPALETTE_SIZE);\n<109> if (!s->frame.data[1]) {\n<119> memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n<151> if (tgv_decode_inter(s, buf, buf_end)<0) {
<1> static inline struct xfrm_user_sec_ctx * pfkey_sadb2xfrm_user_sec_ctx ( const struct sadb_x_sec_ctx * sec_ctx ) {\n<5> if ( ! uctx ) return NULL ;\n<6> uctx -> len = pfkey_sec_ctx_len ( sec_ctx ) ;\n<7> uctx -> exttype = sec_ctx -> sadb_x_sec_exttype ;\n<8> uctx -> ctx_doi = sec_ctx -> sadb_x_ctx_doi ;\n<9> uctx -> ctx_alg = sec_ctx -> sadb_x_ctx_alg ;\n<10> uctx -> ctx_len = sec_ctx -> sadb_x_ctx_len ;\n<11> memcpy ( uctx + 1 , sec_ctx + 1 , uctx -> ctx_len ) ;\n<12> return uctx ;
<1> void update_auto_increment_key ( MI_CHECK * param , MI_INFO * info , my_bool repair_only ) {\n<5> if ( ! ( param -> testflag & T_VERY_SILENT ) ) mi_check_print_info ( param , "Table: %s doesn't have an auto increment key\n" , param -> isam_file_name ) ;\n<8> if ( ! ( param -> testflag & T_SILENT ) && ! ( param -> testflag & T_REP ) ) printf ( "Updating MyISAM file: %s\n" , param -> isam_file_name ) ;\n<10> mi_check_print_error ( param , "Not enough memory for extra record" ) ;\n<18> mi_check_print_error ( param , "%d when reading last record" , my_errno ) ;\n<30> update_state_info ( param , info , UPDATE_AUTO_INC ) ;
<1> static int matroska_parse_rm_audio(MatroskaDemuxContext *matroska,\n<7> uint8_t *data, int size,\n<49> for (x=0; x<h/2; x++)\n<51> memcpy(track->audio.buf+x*2*w+y*cfs,\n<53> data+x*cfs, cfs);\n<57> if (size < w) {\n<67> memcpy(track->audio.buf + y*w, data, w);\n<81> for (x=0; x<w/sps; x++)\n<83> memcpy(track->audio.buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n<93> ff_rm_reorder_sipr_data(track->audio.buf, h, w);\n<97> track->audio.pkt_cnt = h*w / a;\n<109> if (!(pkt = av_mallocz(sizeof(AVPacket))) || av_new_packet(pkt, a) < 0){\n<111> av_free(pkt);\n<119> + a * (h*w / a - track->audio.pkt_cnt--), a);\n<129> dynarray_add(&matroska->packets,&matroska->num_packets,pkt);
<13> if(read_len_table(s->len[0], &gb)<0)\n<19> if(read_len_table(s->len[1], &gb)<0)\n<25> for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];\n<27> for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];\n<31> if(s->bitstream_bpp >= 24){\n<33> memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));\n<35> memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));\n<39> memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));\n<41> memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));
<1> static gboolean pk_transaction_authorize_actions ( PkTransaction * transaction , PkRoleEnum role , GPtrArray * actions ) {\n<6> PkTransactionPrivate * priv = transaction -> priv ;\n<9> if ( actions -> len <= 0 ) {\n<14> action_id = g_ptr_array_index ( actions , 0 ) ;\n<15> syslog ( LOG_AUTH | LOG_INFO , "uid %i is trying to obtain %s auth (only_trusted:%i)" , priv -> uid , action_id , pk_bitfield_contain ( priv -> cached_transaction_flags , PK_TRANSACTION_FLAG_ENUM_ONLY_TRUSTED ) ) ;\n<45> g_debug ( "authorizing action %s" , action_id ) ;
<1> static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)\n<115> res = av_new_packet(pkt, buf.bytesused);\n<117> if (res < 0) {\n<127> memcpy(pkt->data, s->buf_start[buf.index], buf.bytesused);\n<131> res = enqueue_buffer(s, &buf);\n<135> av_packet_unref(pkt);
<1> void pdo_stmt_init ( TSRMLS_D ) {\n<9> memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ;
<1> int loader_exec(const char * filename, char ** argv, char ** envp,\n<5> struct linux_binprm *bprm)\n<17> memset(bprm->page, 0, sizeof(bprm->page));\n<39> retval = prepare_binprm(bprm);\n<53> retval = load_elf_binary(bprm, regs, infop);\n<71> fprintf(stderr, "Unknown binary format\n");\n<95> for (i=0 ; i<MAX_ARG_PAGES ; i++) {\n<97> free(bprm->page[i]);
<1> static off_t dnsname_to_labels ( u8 * const buf , size_t buf_len , off_t j , const char * name , const int name_len , struct dnslabel_table * table ) {\n<7> _t = htons ( x ) ;\n<8> memcpy ( buf + j , & _t , 2 ) ;
<1> static int rebuild_refcount_structure(BlockDriverState *bs,\n<69> if (refblock_offset < 0) {\n<71> fprintf(stderr, "ERROR allocating refblock: %s\n",\n<73> strerror(-refblock_offset));\n<87> uint32_t old_reftable_size = reftable_size;\n<103> if (!new_on_disk_reftable) {\n<113> on_disk_reftable = new_on_disk_reftable;\n<117> memset(on_disk_reftable + old_reftable_size, 0,\n<119> (reftable_size - old_reftable_size) * sizeof(uint64_t));\n<133> on_disk_reftable[refblock_index] = refblock_offset;\n<157> if (reftable_offset < 0) {\n<159> fprintf(stderr, "ERROR allocating reftable: %s\n",\n<161> strerror(-reftable_offset));\n<179> if (ret < 0) {\n<181> fprintf(stderr, "ERROR writing refblock: %s\n", strerror(-ret));\n<211> if (ret < 0) {\n<213> fprintf(stderr, "ERROR writing refblock: %s\n", strerror(-ret));\n<255> if (reftable_offset < 0) {\n<257> fprintf(stderr, "ERROR allocating reftable: %s\n",\n<259> strerror(-reftable_offset));\n<293> if (ret < 0) {\n<295> fprintf(stderr, "ERROR writing reftable: %s\n", strerror(-ret));\n<309> if (ret < 0) {\n<311> fprintf(stderr, "ERROR writing reftable: %s\n", strerror(-ret));\n<337> if (ret < 0) {\n<339> fprintf(stderr, "ERROR setting reftable: %s\n", strerror(-ret));
<1> static ssize_t handle_aiocb_rw(RawPosixAIOData *aiocb)\n<83> char *p = buf;\n<89> for (i = 0; i < aiocb->aio_niov; ++i) {\n<91> memcpy(p, aiocb->aio_iov[i].iov_base, aiocb->aio_iov[i].iov_len);\n<93> p += aiocb->aio_iov[i].iov_len;\n<107> char *p = buf;\n<115> for (i = 0; i < aiocb->aio_niov && count; ++i) {\n<119> if (copy > aiocb->aio_iov[i].iov_len) {\n<121> copy = aiocb->aio_iov[i].iov_len;\n<125> memcpy(aiocb->aio_iov[i].iov_base, p, copy);\n<127> assert(count >= copy);\n<129> p     += copy;
<1> int TS_ASN1_INTEGER_print_bio ( BIO * bio , const ASN1_INTEGER * num ) {\n<8> if ( ( hex = BN_bn2hex ( num_bn ) ) ) {\n<9> result = BIO_write ( bio , "0x" , 2 ) > 0 ;\n<10> result = result && BIO_write ( bio , hex , strlen ( hex ) ) > 0 ;\n<11> OPENSSL_free ( hex ) ;
<1> static krb5_error_code kadmin_parse_name ( char * name , krb5_principal * principal ) {\n<5> cp = strchr ( name , '@' ) ;\n<7> if ( cp - name && * ( cp - 1 ) != '\\' ) break ;\n<8> else cp = strchr ( cp + 1 , '@' ) ;\n<10> if ( cp == NULL ) result = asprintf ( & fullname , "%s@%s" , name , def_realm ) ;\n<11> else result = asprintf ( & fullname , "%s" , name ) ;\n<12> if ( result < 0 ) return ENOMEM ;\n<13> retval = krb5_parse_name ( context , fullname , principal ) ;\n<14> free ( fullname ) ;
<1> static int lang_compare_first_component ( const char * a , const char * b ) {\n<4> p = strchr ( a , '-' ) ;\n<5> da = p ? ( unsigned int ) ( p - a ) : strlen ( a ) ;\n<6> p = strchr ( b , '-' ) ;\n<7> db = p ? ( unsigned int ) ( p - b ) : strlen ( b ) ;\n<8> return strncmp ( a , b , MAX ( da , db ) ) ;
<1> void api_init ( ) {\n<3> if ( init ) {\n<253> memset ( state_arg_table , 0 , sizeof ( state_arg_table ) ) ;\n<254> ink_strlcpy ( traffic_server_version , appVersionInfo . VersionStr , sizeof ( traffic_server_version ) ) ;\n<255> if ( sscanf ( traffic_server_version , "%d.%d.%d" , & ts_major_version , & ts_minor_version , & ts_patch_version ) != 3 ) {\n<256> Warning ( "Unable to parse traffic server version string '%s'\n" , traffic_server_version ) ;
<1> static int mxf_parse_physical_source_package(MXFContext *mxf, MXFTrack *source_track, AVStream *st)\n<33> if (!component)\n<39> for (j = 0; j < mxf->packages_count; j++) {\n<43> if (!temp_package)\n<47> if (!memcmp(temp_package->package_uid, component->source_package_uid, 16)){\n<49> physical_package = temp_package;\n<51> sourceclip = component;\n<105> if (!component){\n<111> if (!component)\n<115> mxf_pulldown = (MXFPulldownComponent*)component;\n<119> if (!component)\n<127> mxf_tc = (MXFTimecodeComponent*)component;
<1> static int compare_codec_desc(const void *a, const void *b)\n<11> return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :\n<13> strcmp((*da)->name, (*db)->name);
<1> int mjpeg_init(MpegEncContext *s)\n<4> m = malloc(sizeof(MJpegContext));\n<5> if (!m)
<1> int test_lshift1 ( BIO * bp ) {\n<24> if ( ! BN_is_zero ( a ) ) {\n<25> fprintf ( stderr , "Left shift one test failed!\n" ) ;
<1> static void print_xml_tag ( FILE * xml_file , const char * sbeg , const char * line_end , const char * tag_name , const char * first_attribute_name , ... ) {\n<9> while ( attribute_name != NullS ) {\n<11> DBUG_ASSERT ( attribute_value != NullS ) ;\n<15> print_quoted_xml ( xml_file , attribute_value , strlen ( attribute_value ) , 0 ) ;
<1> static int h264_slice_header_init(H264Context *h, int reinit)\n<121> for (i = 1; i < s->slice_context_count; i++) {\n<125> c = h->thread_context[i] = av_malloc(sizeof(H264Context));\n<127> memcpy(c, h->s.thread_context[i], sizeof(MpegEncContext));\n<129> memset(&c->s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext));\n<131> c->h264dsp     = h->h264dsp;\n<133> c->sps         = h->sps;\n<135> c->pps         = h->pps;\n<137> c->pixel_shift = h->pixel_shift;\n<139> c->cur_chroma_format_idc = h->cur_chroma_format_idc;\n<141> init_scan_tables(c);\n<143> clone_tables(c, h, i);
<1> static kbd_layout_t *parse_keyboard_layout(const name2keysym_t *table,\n<13> char line[1024];\n<19> filename = qemu_find_file(QEMU_FILE_TYPE_KEYMAP, language);\n<25> if (!f) {\n<27> fprintf(stderr, "Could not read keymap file: '%s'\n", language);\n<45> if (fgets(line, 1024, f) == NULL) {\n<51> len = strlen(line);\n<53> if (len > 0 && line[len - 1] == '\n') {\n<55> line[len - 1] = '\0';\n<59> if (line[0] == '#') {\n<65> if (!strncmp(line, "map ", 4)) {\n<71> if (!strncmp(line, "include ", 8)) {\n<91> keysym = get_keysym(table, line);\n<93> if (keysym == 0) {\n<101> int keycode = strtol(rest, NULL, 0);\n<105> if (strstr(rest, "numlock")) {\n<107> add_to_key_range(&k->keypad_range, keycode);\n<109> add_to_key_range(&k->numlock_range, keysym);\n<119> if (strstr(rest, "shift")) {\n<121> keycode |= SCANCODE_SHIFT;\n<125> if (strstr(rest, "altgr")) {\n<127> keycode |= SCANCODE_ALTGR;\n<131> if (strstr(rest, "ctrl")) {\n<133> keycode |= SCANCODE_CTRL;\n<139> add_keysym(line, keysym, keycode, k);\n<143> if (strstr(rest, "addupper")) {\n<147> for (c = line; *c; c++) {\n<153> keysym = get_keysym(table, line);\n<155> if (keysym) {\n<173> fclose(f);
<1> static void curses_connection_inject ( void ) {\n<4> SAFE_REALLOC ( injectbuf , 501 * sizeof ( char ) ) ;\n<5> memset ( injectbuf , 0 , 501 ) ;\n<12> wdg_input_add ( in , 1 , 1 , "Chars to be injected :" , ( char * ) injectbuf , 50 , 10 ) ;
<1> static PCIDevice *do_pci_register_device(PCIDevice *pci_dev, PCIBus *bus,\n<17> if (!bus->devices[devfn])\n<27> } else if (bus->devices[devfn]) {\n<39> memset(pci_dev->irq_state, 0, sizeof(pci_dev->irq_state));\n<41> pci_config_alloc(pci_dev);\n<49> pci_set_default_subsystem_id(pci_dev);\n<53> pci_init_cmask(pci_dev);\n<55> pci_init_wmask(pci_dev);\n<59> pci_init_wmask_bridge(pci_dev);\n<77> bus->devices[devfn] = pci_dev;\n<79> pci_dev->irq = qemu_allocate_irqs(pci_set_irq, pci_dev, PCI_NUM_PINS);\n<83> return pci_dev;
<1> int net_slirp_parse_legacy ( QemuOptsList * opts_list , const char * optarg , int * ret ) {\n<2> if ( strcmp ( opts_list -> name , "net" ) != 0 || strncmp ( optarg , "channel," , strlen ( "channel," ) ) != 0 ) {\n<3> return 0 ;\n<5> optarg += strlen ( "channel," ) ;\n<6> if ( QTAILQ_EMPTY ( & slirp_stacks ) ) {\n<9> pstrcpy ( config -> str , sizeof ( config -> str ) , optarg ) ;\n<16> * ret = slirp_guestfwd ( QTAILQ_FIRST ( & slirp_stacks ) , optarg , 1 ) ;\n<18> return 1 ;
<1> static void reindex_one_database ( const char * name , const char * dbname , const char * type , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool verbose ) {\n<8> if ( strcmp ( type , "TABLE" ) == 0 ) appendPQExpBuffer ( & sql , " TABLE %s" , name ) ;\n<9> else if ( strcmp ( type , "INDEX" ) == 0 ) appendPQExpBuffer ( & sql , " INDEX %s" , name ) ;\n<10> else if ( strcmp ( type , "SCHEMA" ) == 0 ) appendPQExpBuffer ( & sql , " SCHEMA %s" , name ) ;\n<11> else if ( strcmp ( type , "DATABASE" ) == 0 ) appendPQExpBuffer ( & sql , " DATABASE %s" , fmtId ( PQdb ( conn ) ) ) ;
<441> get_buffer(pb, st->codec.extradata, st->codec.extradata_size);\n<459> if (st->codec.extradata_size && (st->codec.bits_per_sample <= 8)) {\n<471> memcpy(st->codec.palctrl->palette, st->codec.extradata,\n<473> FFMIN(st->codec.extradata_size, AVPALETTE_SIZE));
<1> m_get(Slirp *slirp)\n<15> if (slirp->m_freelist.m_next == &slirp->m_freelist) {\n<17> m = (struct mbuf *)malloc(SLIRP_MSIZE);\n<19> if (m == NULL) goto end_error;\n<49> m->m_size = SLIRP_MSIZE - sizeof(struct m_hdr);
<1> static char * constructConnStr ( const char * * keywords , const char * * values ) {\n<7> keywords [ i ] != NULL ;\n<9> if ( strcmp ( keywords [ i ] , "dbname" ) == 0 || strcmp ( keywords [ i ] , "password" ) == 0 || strcmp ( keywords [ i ] , "fallback_application_name" ) == 0 ) continue ;\n<10> if ( ! firstkeyword ) appendPQExpBufferChar ( buf , ' ' ) ;\n<11> firstkeyword = false ;\n<12> appendPQExpBuffer ( buf , "%s=" , keywords [ i ] ) ;\n<13> appendConnStrVal ( buf , values [ i ] ) ;
<1> static int load_xbzrle(QEMUFile *f, ram_addr_t addr, void *host)\n<29> if (xh_flags != ENCODING_FLAG_XBZRLE) {\n<31> fprintf(stderr, "Failed to load XBZRLE page - wrong compression!\n");\n<39> if (xh_len > TARGET_PAGE_SIZE) {\n<41> fprintf(stderr, "Failed to load XBZRLE page - len overflow!\n");\n<59> if (ret == -1) {\n<61> fprintf(stderr, "Failed to load XBZRLE page - decode error!\n");\n<65> } else  if (ret > TARGET_PAGE_SIZE) {\n<67> fprintf(stderr, "Failed to load XBZRLE page - size %d exceeds %d!\n",
<1> static int dprintf_formatf ( void * data , int ( * stream ) ( int , FILE * ) , const char * format , va_list ap_save ) {\n<61> switch ( p -> type ) {\n<130> if ( str == NULL ) {\n<141> else if ( prec != - 1 ) len = ( size_t ) prec ;\n<142> else len = strlen ( str ) ;\n<143> width -= ( len > LONG_MAX ) ? LONG_MAX : ( long ) len ;\n<146> while ( ( len -- > 0 ) && * str ) OUTCHAR ( * str ++ ) ;\n<175> char formatbuf [ 32 ] = "%" ;\n<177> size_t left = sizeof ( formatbuf ) - strlen ( formatbuf ) ;\n<191> len = curl_msnprintf ( fptr , left , "%ld" , width ) ;\n<196> len = curl_msnprintf ( fptr , left , ".%ld" , prec ) ;\n<204> ( sprintf ) ( work , formatbuf , p -> data . dnum ) ;
<1> AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,\n<11> AVFilterBufferRef *ref = NULL;\n<19> if (!samples || !(ref = av_mallocz(sizeof(AVFilterBufferRef))))\n<33> if (!ref->audio)\n<81> samples->linesize[i] = planar > 0 ? per_channel_size : sample_size;\n<83> memset(&samples->linesize[chans_nb], 0, (8-chans_nb) * sizeof(samples->linesize[0]));\n<93> if (!buf)\n<113> samples->data[i] = buf + step_size;\n<121> samples->data[i] = buf;\n<127> memset(&samples->data[chans_nb], 0, (8-chans_nb) * sizeof(samples->data[0]));\n<131> memcpy(ref->data,     samples->data,     sizeof(ref->data));\n<133> memcpy(ref->linesize, samples->linesize, sizeof(ref->linesize));\n<137> return ref;
<1> static void unpack_roq_cell ( roq_cell * cell , uint8_t u [ 4 * 3 ] ) {\n<2> memcpy ( u , cell -> y , 4 ) ;\n<3> memset ( u + 4 , cell -> u , 4 ) ;\n<4> memset ( u + 8 , cell -> v , 4 ) ;
<1> static void ioescapeloop ( IO * wrapper ) {\n<2> _IO * io = wrapper -> top , * iop ;\n<4> while ( io -> prev != NULL && ! io -> isstopped ) {\n<7> if ( io -> start != NULL ) free ( io -> start ) ;\n<8> io -> start = NULL ;\n<9> free ( io ) ;\n<14> io = iop ;
<1> int tls_construct_server_hello ( SSL * s ) {\n<10> * ( p ++ ) = s -> version & 0xff ;\n<11> memcpy ( p , s -> s3 -> server_random , SSL3_RANDOM_SIZE ) ;\n<12> p += SSL3_RANDOM_SIZE ;\n<15> if ( sl > ( int ) sizeof ( s -> session -> session_id ) ) {\n<20> * ( p ++ ) = sl ;\n<21> memcpy ( p , s -> session -> session_id , sl ) ;\n<22> p += sl ;
<1> void evhttp_set_cb ( struct evhttp * http , const char * uri , void ( * cb ) ( struct evhttp_request * , void * ) , void * cbarg ) {\n<3> if ( ( http_cb = calloc ( 1 , sizeof ( struct evhttp_cb ) ) ) == NULL ) event_err ( 1 , "%s: calloc" , __func__ ) ;\n<4> http_cb -> what = strdup ( uri ) ;\n<7> TAILQ_INSERT_TAIL ( & http -> callbacks , http_cb , next ) ;
<1> static void help ( const char * progname ) {\n<2> printf ( _ ( "%s cleans and analyzes a PostgreSQL database.\n\n" ) , progname ) ;\n<3> printf ( _ ( "Usage:\n" ) ) ;\n<4> printf ( _ ( " %s [OPTION]... [DBNAME]\n" ) , progname ) ;\n<5> printf ( _ ( "\nOptions:\n" ) ) ;\n<6> printf ( _ ( " -a, --all vacuum all databases\n" ) ) ;\n<7> printf ( _ ( " -d, --dbname=DBNAME database to vacuum\n" ) ) ;\n<8> printf ( _ ( " -e, --echo show the commands being sent to the server\n" ) ) ;\n<9> printf ( _ ( " -f, --full do full vacuuming\n" ) ) ;\n<10> printf ( _ ( " -F, --freeze freeze row transaction information\n" ) ) ;\n<11> printf ( _ ( " -j, --jobs=NUM use this many concurrent connections to vacuum\n" ) ) ;\n<12> printf ( _ ( " -q, --quiet don't write any messages\n" ) ) ;\n<13> printf ( _ ( " -t, --table='TABLE[(COLUMNS)]' vacuum specific table(s) only\n" ) ) ;\n<14> printf ( _ ( " -v, --verbose write a lot of output\n" ) ) ;\n<15> printf ( _ ( " -V, --version output version information, then exit\n" ) ) ;\n<16> printf ( _ ( " -z, --analyze update optimizer statistics\n" ) ) ;\n<22> printf ( _ ( "\nConnection options:\n" ) ) ;\n<23> printf ( _ ( " -h, --host=HOSTNAME database server host or socket directory\n" ) ) ;\n<24> printf ( _ ( " -p, --port=PORT database server port\n" ) ) ;\n<25> printf ( _ ( " -U, --username=USERNAME user name to connect as\n" ) ) ;\n<26> printf ( _ ( " -w, --no-password never prompt for password\n" ) ) ;\n<27> printf ( _ ( " -W, --password force password prompt\n" ) ) ;\n<28> printf ( _ ( " --maintenance-db=DBNAME alternate maintenance database\n" ) ) ;\n<29> printf ( _ ( "\nRead the description of the SQL command VACUUM for details.\n" ) ) ;\n<30> printf ( _ ( "\nReport bugs to <pgsql-bugs@postgresql.org>.\n" ) ) ;
<1> int spapr_vio_send_crq(VIOsPAPRDevice *dev, uint8_t *crq)\n<11> if (!dev->crq.qsize) {\n<13> fprintf(stderr, "spapr_vio_send_creq on uninitialized queue\n");
<1> ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n<9> if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n<11> fprintf(stderr, "Bad ram pointer %p\n", ptr);
<1> int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n<55> for (i = 0; i < 3; i++) {\n<65> av_log(s1, AV_LOG_ERROR, "Could not open file : %s\n",\n<77> if (!s->split_planes)\n<81> filename[strlen(filename) - 1] = 'U' + i;\n<114> pd.filename = filename;\n<166> if (stat(filename, &img_stat))
<1> static void lz_unpack(const unsigned char *src, int src_len,\n<15> unsigned char queue[QUEUE_SIZE];\n<43> if (s_end - s < 8)\n<51> memset(queue, 0x20, QUEUE_SIZE);\n<139> *d = queue[chainofs++ & QUEUE_MASK];
<1> static int qemuMonitorJSONCommandWithFd ( qemuMonitorPtr mon , virJSONValuePtr cmd , int scm_fd , virJSONValuePtr * reply ) {\n<8> memset ( & msg , 0 , sizeof msg ) ;\n<21> if ( virAsprintf ( & msg . txBuffer , "%s\r\n" , cmdstr ) < 0 ) {\n<25> msg . txLength = strlen ( msg . txBuffer ) ;\n<28> ret = qemuMonitorSend ( mon , & msg ) ;\n<29> VIR_DEBUG ( "Receive command reply ret=%d rxObject=%p" , ret , msg . rxObject ) ;\n<31> if ( ! msg . rxObject ) {\n<36> * reply = msg . rxObject ;\n<41> VIR_FREE ( msg . txBuffer ) ;
<1> static void list_curves ( void ) {\n<6> ( name = gcry_pk_get_curve ( NULL , idx , & nbits ) ) ;\n<8> if ( verbose ) printf ( "%s - %u bits\n" , name , nbits ) ;
<5> PNGDecContext *psrc = src->priv_data;\n<7> PNGDecContext *pdst = dst->priv_data;\n<27> if (CONFIG_APNG_DECODER && dst->codec_id == AV_CODEC_ID_APNG) {\n<53> memcpy(pdst->transparent_color_be, psrc->transparent_color_be, sizeof(pdst->transparent_color_be));\n<61> memcpy(pdst->palette, psrc->palette, sizeof(pdst->palette));
<1> int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n<31> ctx.tb = tb;\n<35> ctx.spr_cb = env->spr_cb;\n<43> ctx.supervisor = 1 - msr_pr;\n<45> ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;\n<49> ctx.fpu_enabled = msr_fp;\n<51> ctx.singlestep_enabled = env->singlestep_enabled;\n<63> while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {\n<69> if (env->breakpoints[j] == ctx.nip) {\n<71> gen_op_update_nip(ctx.nip);\n<95> gen_opc_pc[lj] = ctx.nip;\n<117> ctx.opcode = ldl_code(ctx.nip);\n<121> ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) |\n<123> ((ctx.opcode & 0x00FF0000) >> 8) |\n<125> ((ctx.opcode & 0x0000FF00) << 8) |\n<127> ((ctx.opcode & 0x000000FF) << 24);\n<145> ctx.nip += 4;\n<149> handler = table[opc1(ctx.opcode)];\n<155> handler = table[opc2(ctx.opcode)];\n<161> handler = table[opc3(ctx.opcode)];\n<171> if (loglevel > 0) {\n<173> fprintf(logfile, "invalid/unsupported opcode: "\n<177> opc1(ctx.opcode), opc2(ctx.opcode),\n<179> opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n<187> opc1(ctx.opcode), opc2(ctx.opcode),\n<189> opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msr_ir);\n<195> if (unlikely((ctx.opcode & handler->inval) != 0)) {\n<197> if (loglevel > 0) {\n<199> fprintf(logfile, "invalid bits: %08x for opcode: "\n<203> ctx.opcode & handler->inval, opc1(ctx.opcode),\n<205> opc2(ctx.opcode), opc3(ctx.opcode),\n<207> ctx.opcode, ctx.nip - 4);\n<215> ctx.opcode & handler->inval, opc1(ctx.opcode),\n<217> opc2(ctx.opcode), opc3(ctx.opcode),\n<219> ctx.opcode, ctx.nip - 4);\n<231> (*(handler->handler))(&ctx);\n<241> if (unlikely((msr_be && ctx.exception == EXCP_BRANCH) ||\n<253> (msr_se && (ctx.nip < 0x100 ||\n<255> ctx.nip > 0xF00 ||\n<257> (ctx.nip & 0xFC) != 0x04) &&\n<259> ctx.exception != EXCP_SYSCALL &&\n<261> ctx.exception != EXCP_SYSCALL_USER &&\n<263> ctx.exception != EXCP_TRAP))) {\n<275> if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n<291> if (ctx.exception == EXCP_NONE) {\n<293> gen_goto_tb(&ctx, 0, ctx.nip);\n<295> } else if (ctx.exception != EXCP_BRANCH) {\n<321> tb->size = ctx.nip - pc_start;
<1> static void mips_jazz_init(MemoryRegion *address_space,\n<77> if (cpu == NULL) {\n<79> fprintf(stderr, "Unable to find CPU definition\n");\n<123> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<139> if (bios_size < 0 || bios_size > MAGNUM_BIOS_SIZE) {\n<141> fprintf(stderr, "qemu: Could not load MIPS bios '%s'\n",\n<253> for (n = 0; n < nb_nics; n++) {\n<255> nd = &nd_table[n];\n<257> if (!nd->model)\n<259> nd->model = g_strdup("dp83932");\n<261> if (strcmp(nd->model, "dp83932") == 0) {\n<263> dp83932_init(nd, 0x80001000, 2, get_system_memory(), rc4030[4],\n<269> } else if (strcmp(nd->model, "?") == 0) {\n<271> fprintf(stderr, "qemu: Supported NICs: dp83932\n");\n<273> exit(1);\n<277> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd->model);\n<279> exit(1);\n<299> if (drive_get_max_bus(IF_FLOPPY) >= MAX_FD) {\n<301> fprintf(stderr, "qemu: too many floppy drives\n");
<1> void mct_log ( const char * format , ... ) {\n<3> va_start ( args , format ) ;\n<4> vprintf ( format , args ) ;\n<5> va_end ( args ) ;\n<8> va_start ( args , format ) ;
<1> static int vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *src)\n<23> copy_fields(s, s1, golden_frame, current_frame);\n<43> if (err)\n<51> memcpy(s->motion_val[0], s1->motion_val[0], y_fragment_count * sizeof(*s->motion_val[0]));\n<53> memcpy(s->motion_val[1], s1->motion_val[1], c_fragment_count * sizeof(*s->motion_val[1]));\n<61> copy_fields(s, s1, golden_frame, dsp);\n<69> if (s->qps[i] != s1->qps[1]) {\n<73> memcpy(&s->qmat[i], &s1->qmat[i], sizeof(s->qmat[i]));\n<81> if (s->qps[0] != s1->qps[0])\n<83> memcpy(&s->bounding_values_array, &s1->bounding_values_array, sizeof(s->bounding_values_array));\n<89> copy_fields(s, s1, qps, superblock_count);
<1> void jas_free ( void * ptr ) {\n<2> JAS_DBGLOG ( 100 , ( "jas_free(%p)\n" , ptr ) ) ;\n<3> free ( ptr ) ;
<1> static void dump(unsigned char *buf,size_t len)\n<7> for(i=0;i<len;i++) {\n<9> if ((i&15)==0) printf("%04x  ",i);\n<11> printf("%02x ",buf[i]);\n<13> if ((i&15)==15) printf("\n");\n<17> printf("\n");
<1> static int evhttp_append_to_last_header ( struct evkeyvalq * headers , const char * line ) {\n<5> if ( header == NULL ) return ( - 1 ) ;\n<6> old_len = strlen ( header -> value ) ;\n<7> line_len = strlen ( line ) ;\n<8> newval = realloc ( header -> value , old_len + line_len + 1 ) ;\n<9> if ( newval == NULL ) return ( - 1 ) ;\n<10> memcpy ( newval + old_len , line , line_len + 1 ) ;
<1> int test_gf2m_mod_inv ( BIO * bp , BN_CTX * ctx ) {\n<37> fprintf ( stderr , "GF(2^m) modular inversion test failed!\n" ) ;
<1> static void check_perms_nopam ( const struct passwd * pw ) {\n<8> if ( ( 0 == pw -> pw_uid ) && getdef_bool ( "SU_WHEEL_ONLY" ) && ! iswheel ( caller_name ) ) {\n<9> fprintf ( stderr , _ ( "You are not authorized to su %s\n" ) , name ) ;\n<12> spwd = getspnam ( name ) ;\n<30> if ( pw_auth ( password , name , PW_SU , ( char * ) 0 ) != 0 ) {\n<32> fprintf ( stderr , _ ( "%s: Authentication failure\n" ) , Prog ) ;\n<39> if ( ! isttytime ( name , "SU" , time ( ( time_t * ) 0 ) ) ) {\n<41> fprintf ( stderr , _ ( "%s: You are not authorized to su at that time\n" ) , Prog ) ;
<1> static void test_fetch_nobuffs ( ) {\n<3> MYSQL_BIND my_bind [ 4 ] ;\n<4> char str [ 4 ] [ 50 ] ;\n<11> rc = 0 ;\n<12> while ( mysql_stmt_fetch ( stmt ) != MYSQL_NO_DATA ) rc ++ ;\n<13> if ( ! opt_silent ) fprintf ( stdout , "\n total rows : %d" , rc ) ;\n<14> DIE_UNLESS ( rc == 1 ) ;\n<15> memset ( my_bind , 0 , sizeof ( MYSQL_BIND ) ) ;\n<19> my_bind [ 1 ] = my_bind [ 2 ] = my_bind [ 3 ] = my_bind [ 0 ] ;\n<23> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<27> rc = 0 ;\n<29> rc ++ ;\n<30> if ( ! opt_silent ) {\n<31> fprintf ( stdout , "\n CURRENT_DATABASE(): %s" , str [ 0 ] ) ;\n<32> fprintf ( stdout , "\n CURRENT_USER() : %s" , str [ 1 ] ) ;\n<33> fprintf ( stdout , "\n CURRENT_DATE() : %s" , str [ 2 ] ) ;\n<34> fprintf ( stdout , "\n CURRENT_TIME() : %s" , str [ 3 ] ) ;\n<37> if ( ! opt_silent ) fprintf ( stdout , "\n total rows : %d" , rc ) ;\n<38> DIE_UNLESS ( rc == 1 ) ;
<1> static int grab_read_header(AVFormatContext *s1, AVFormatParameters *ap)\n<5> VideoData *s = s1->priv_data;\n<67> st = av_new_stream(s1, 0);\n<87> video_fd = open(s1->filename, O_RDWR);\n<89> if (video_fd < 0) {\n<91> av_log(s1, AV_LOG_ERROR, "%s: %s\n", s1->filename, strerror(errno));\n<99> if (ioctl(video_fd,VIDIOCGCAP, &s->video_cap) < 0) {\n<101> av_log(s1, AV_LOG_ERROR, "VIDIOCGCAP: %s\n", strerror(errno));\n<109> if (!(s->video_cap.type & VID_TYPE_CAPTURE)) {\n<163> audio.audio = 0;\n<165> ioctl(video_fd, VIDIOCGAUDIO, &audio);\n<167> memcpy(&s->audio_saved, &audio, sizeof(audio));\n<171> ioctl(video_fd, VIDIOCSAUDIO, &audio);\n<273> if ((unsigned char*)-1 == s->video_buf) {\n<275> av_log(s1, AV_LOG_ERROR, "mmap: %s\n", strerror(errno));
<1> static int check_refcounts_l2(BlockDriverState *bs,\n<12> if (bdrv_pread(s->hd, l2_offset, l2_table, l2_size) != l2_size)\n<49> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> static void rice_decompress ( ALACContext * alac , int32_t * output_buffer , int nb_samples , int bps , int rice_history_mult ) {\n<23> if ( block_size > 0 ) {\n<28> memset ( & output_buffer [ i + 1 ] , 0 , block_size * sizeof ( * output_buffer ) ) ;
<1> static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, enum AVMediaType type, int source_index)\n<115> buf = get_line(s);\n<117> if (!buf[0] || buf[0] == '#') {\n<125> if (!(arg = strchr(buf, '='))) {\n<127> av_log(NULL, AV_LOG_FATAL, "Invalid line found in the preset file.\n");\n<129> exit_program(1);\n<133> *arg++ = 0;\n<135> av_dict_set(&ost->encoder_opts, buf, arg, AV_DICT_DONT_OVERWRITE);\n<191> MATCH_PER_STREAM_OPT(bitstream_filters, str, bsf, oc, st);\n<193> while (bsf) {\n<197> if (next = strchr(bsf, ','))\n<199> *next++ = 0;\n<201> if (arg = strchr(bsf, '='))\n<203> *arg++ = 0;\n<205> if (!(bsfc = av_bitstream_filter_init(bsf))) {\n<223> if (!(bsfc->args = av_strdup(arg))) {\n<235> bsf       = next;\n<245> uint32_t tag = strtol(codec_tag, &next, 0);
<1> int main ( int argc , const char * * argv_ ) {\n<6> argv = argv_dup ( argc - 1 , argv_ + 1 ) ;\n<8> ( * argj = * argi ) ;\n<9> argi += arg . argv_step ) {\n<10> memset ( & arg , 0 , sizeof ( arg ) ) ;\n<11> arg . argv_step = 1 ;\n<12> if ( arg_match ( & arg , & looparg , argi ) ) {\n<13> loops = arg_parse_uint ( & arg ) ;\n<17> free ( argv ) ;
<1> static void test_simple_update ( ) {\n<26> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<32> length [ 0 ] = sprintf ( szData , "updated-data" ) ;\n<35> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> size_t gcry_sexp_sprint ( const gcry_sexp_t list , int mode , void * buffer , size_t maxlength ) {\n<8> char numbuf [ 20 ] ;\n<9> size_t len = 0 ;\n<13> while ( * s != ST_STOP ) {\n<14> switch ( * s ) {\n<17> if ( indent ) len ++ ;\n<18> len += indent ;\n<20> len ++ ;\n<22> if ( len >= maxlength ) return 0 ;\n<34> len ++ ;\n<36> if ( len >= maxlength ) return 0 ;\n<42> len += indent ;\n<44> if ( len >= maxlength ) return 0 ;\n<52> case ST_DATA : s ++ ;\n<53> memcpy ( & n , s , sizeof n ) ;\n<54> s += sizeof n ;\n<55> if ( mode == GCRYSEXP_FMT_ADVANCED ) {\n<58> switch ( ( type = suitable_encoding ( s , n ) ) ) {\n<59> case 1 : nn = convert_to_string ( s , n , NULL ) ;\n<61> case 2 : nn = convert_to_token ( s , n , NULL ) ;\n<63> default : nn = convert_to_hex ( s , n , NULL ) ;\n<66> len += nn ;\n<68> if ( len >= maxlength ) return 0 ;\n<70> case 1 : convert_to_string ( s , n , d ) ;\n<72> case 2 : convert_to_token ( s , n , d ) ;\n<74> default : convert_to_hex ( s , n , d ) ;\n<79> if ( s [ n ] != ST_CLOSE ) {\n<80> len ++ ;\n<82> if ( len >= maxlength ) return 0 ;\n<88> sprintf ( numbuf , "%u:" , ( unsigned int ) n ) ;\n<89> len += strlen ( numbuf ) + n ;\n<91> if ( len >= maxlength ) return 0 ;\n<92> d = stpcpy ( d , numbuf ) ;\n<93> memcpy ( d , s , n ) ;\n<94> d += n ;\n<97> s += n ;\n<103> len ++ ;\n<110> if ( len >= maxlength ) return 0 ;\n<113> else len ++ ;
<1> static int announce_self_create(uint8_t *buf,\n<3> uint8_t *mac_addr)\n<7> uint32_t magic = EXPERIMENTAL_MAGIC;\n<9> uint16_t proto = htons(ETH_P_EXPERIMENTAL);\n<17> memset(buf, 0, 64);\n<19> memset(buf, 0xff, 6);         /* h_dst */\n<21> memcpy(buf + 6, mac_addr, 6); /* h_src */\n<23> memcpy(buf + 12, &proto, 2);  /* h_proto */\n<25> memcpy(buf + 14, &magic, 4);  /* magic */
<1> int key_instantiate_and_link ( struct key * key , const void * data , size_t datalen , struct key * keyring , struct key * authkey ) {\n<5> memset ( & prep , 0 , sizeof ( prep ) ) ;\n<11> ret = key -> type -> preparse ( & prep ) ;\n<16> ret = keyring -> restrict_link ( keyring , key -> type , & prep . payload ) ;\n<22> ret = __key_instantiate_and_link ( key , & prep , keyring , authkey , & edit ) ;\n<24> error : if ( key -> type -> preparse ) key -> type -> free_preparse ( & prep ) ;
<1> void mutt_rfc2047_encode ( char * * pd , const char * specials , int col , const char * charsets ) {\n<2> char * e = NULL ;\n<4> if ( ! Charset || ! * pd ) return ;\n<5> if ( ! charsets || ! * charsets ) charsets = "utf-8" ;\n<6> rfc2047_encode ( * pd , strlen ( * pd ) , col , Charset , charsets , & e , & elen , specials ) ;\n<7> FREE ( pd ) ;\n<8> * pd = e ;
<1> static void test_stiny_bug ( ) {\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<35> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<39> if ( ! opt_silent ) {\n<40> fprintf ( stdout , "\n sshort : %d (%ld)" , short_value , s_length ) ;\n<41> fprintf ( stdout , "\n slong : %ld (%ld)" , ( long ) long_value , l_length ) ;\n<42> fprintf ( stdout , "\n longlong : %s (%ld)" , llstr ( longlong_value , llbuf ) , ll_length ) ;\n<43> fprintf ( stdout , "\n tinyint : %d (%ld)" , tiny_value , t_length ) ;\n<45> DIE_UNLESS ( short_value == - 128 ) ;\n<46> DIE_UNLESS ( s_length == 2 ) ;\n<48> DIE_UNLESS ( l_length == 4 ) ;\n<50> DIE_UNLESS ( ll_length == 8 ) ;\n<51> DIE_UNLESS ( tiny_value == 0 ) ;\n<52> DIE_UNLESS ( t_length == 1 ) ;
<1> static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)\n<17> for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n<25> for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n<35> s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);\n<41> s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];\n<45> s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];\n<65> s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;\n<67> s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;\n<73> if (s->cdlms[ich][ilms].recent == 0) {\n<79> memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,\n<83> bps * s->cdlms[ich][ilms].order);\n<85> memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,\n<89> bps * s->cdlms[ich][ilms].order);
<1> static bool is_valid_cgroup ( const char * name ) {\n<4> * p ;\n<8> return strcmp ( name , "." ) != 0 && strcmp ( name , ".." ) != 0 ;
<1> static int cmp ( const chr * x , const chr * y , size_t len ) {\n<2> return memcmp ( VS ( x ) , VS ( y ) , len * sizeof ( chr ) ) ;
<1> void _zip_dirent_torrent_normalize ( struct zip_dirent * de ) {\n<31> free ( de -> extrafield ) ;\n<34> free ( de -> comment ) ;
<1> static void test_bind_nagative ( ) {\n<19> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> rc = mysql_stmt_bind_param ( stmt_insert , my_bind ) ;
<1> static vpx_codec_err_t parse_layer_options_from_string ( SvcContext * svc_ctx , LAYER_OPTION_TYPE type , const char * input , int * option0 , int * option1 ) {\n<8> if ( input == NULL || option0 == NULL || ( option1 == NULL && type == SCALE_FACTOR ) ) return VPX_CODEC_INVALID_PARAM ;\n<9> input_string = strdup ( input ) ;\n<10> token = strtok_r ( input_string , delim , & save_ptr ) ;\n<27> free ( input_string ) ;
<1> static const unsigned char * seq_decode_op2 ( SeqVideoContext * seq , const unsigned char * src , const unsigned char * src_end , unsigned char * dst ) {\n<3> if ( src_end - src < 8 * 8 ) return NULL ;\n<5> i < 8 ;\n<7> memcpy ( dst , src , 8 ) ;\n<8> src += 8 ;\n<9> dst += seq -> frame . linesize [ 0 ] ;
<1> static VALUE ossl_asn1data_to_der ( VALUE self ) {\n<20> p = ( unsigned char * ) RSTRING_PTR ( der ) ;\n<21> ASN1_put_object ( & p , is_cons , RSTRING_LENINT ( value ) , tag , tag_class ) ;\n<22> memcpy ( p , RSTRING_PTR ( value ) , RSTRING_LEN ( value ) ) ;\n<23> p += RSTRING_LEN ( value ) ;
<1> static int pcm_decode_frame(AVCodecContext *avctx,\n<35> samples = data;\n<37> src = buf;\n<121> switch(avctx->codec->id) {\n<283> memcpy(samples, src, n*sample_size);\n<285> src += n*sample_size;
<1> static void truespeech_apply_twopoint_filter ( TSContext * dec , int quart ) {\n<6> if ( t == 127 ) {\n<7> memset ( dec -> newvec , 0 , 60 * sizeof ( * dec -> newvec ) ) ;
<4> CinVideoContext * cin = avctx -> priv_data ;\n<17> cin -> palette [ i ] = bytestream_get_le24 ( & buf ) ;\n<25> cin -> palette [ buf [ 0 ] ] = AV_RL24 ( buf + 1 ) ;\n<31> case 9 : cin_decode_rle ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<34> cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<37> cin_decode_rle ( cin -> bitmap_table [ CIN_INT_BMP ] , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<41> cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<43> case 37 : cin_decode_huffman ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<45> case 38 : res = cin_decode_lzss ( buf , bitmap_frame_size , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<50> cin_apply_delta_data ( cin -> bitmap_table [ CIN_PRE_BMP ] , cin -> bitmap_table [ CIN_CUR_BMP ] , cin -> bitmap_size ) ;\n<53> if ( ( res = ff_reget_buffer ( avctx , & cin -> frame ) ) < 0 ) {\n<57> memcpy ( cin -> frame . data [ 1 ] , cin -> palette , sizeof ( cin -> palette ) ) ;\n<60> y < cin -> avctx -> height ;\n<61> ++ y ) memcpy ( cin -> frame . data [ 0 ] + ( cin -> avctx -> height - 1 - y ) * cin -> frame . linesize [ 0 ] , cin -> bitmap_table [ CIN_CUR_BMP ] + y * cin -> avctx -> width , cin -> avctx -> width ) ;
<1> static int decode_rle ( GetBitContext * gb , uint8_t * pal_dst , int pal_stride , uint8_t * rgb_dst , int rgb_stride , uint32_t * pal , int keyframe , int kf_slipt , int slice , int w , int h ) {\n<93> else if ( last_symbol == - 1 && prev_avail ) {\n<95> memcpy ( rp , rp - rgb_stride , 3 ) ;\n<97> rp += 3 ;
<1> FILE * __setmntent ( const char * file , const char * mode ) {\n<2> size_t modelen = strlen ( mode ) ;\n<3> char newmode [ modelen + 2 ] ;\n<4> memcpy ( mempcpy ( newmode , mode , modelen ) , "c" , 2 ) ;
<1> static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)\n<9> memset(params.name, 0, sizeof(params.name));\n<11> if (hci->device.lmp_name)\n<13> strncpy(params.name, hci->device.lmp_name, sizeof(params.name));\n<17> bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);
<1> bool send_ans_key ( node_t * to ) {\n<18> if ( replaywin ) {\n<19> memset ( to -> late , 0 , replaywin ) ;
<1> static int decorrelate ( TAKDecContext * s , int c1 , int c2 , int length ) {\n<7> switch ( s -> dmode ) {\n<51> memset ( filter , 0 , MAX_PREDICTORS * sizeof ( * filter ) ) ;\n<83> av_fast_malloc ( & s -> residues , & s -> residues_buf_size , FFALIGN ( length + 16 , 16 ) * sizeof ( * s -> residues ) ) ;\n<84> if ( ! s -> residues ) return AVERROR ( ENOMEM ) ;\n<85> memset ( s -> residues , 0 , s -> residues_buf_size ) ;\n<94> v += s -> dsp . scalarproduct_int16 ( & s -> residues [ i ] , filter , FFALIGN ( filter_order , 16 ) ) ;
<1> static int find_snapshot_by_id_or_name(BlockDriverState *bs, const char *name)\n<11> ret = find_snapshot_by_id(bs, name);\n<17> for(i = 0; i < s->nb_snapshots; i++) {\n<19> if (!strcmp(s->snapshots[i].name, name))\n<21> return i;
<1> static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n<15> char buf[256];\n<25> if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<31> if (!strcmp(buf, "tcp") || buf[0] == '\0') {\n<33> is_udp = 0;\n<35> } else if (!strcmp(buf, "udp")) {\n<37> is_udp = 1;\n<47> if (!legacy_format) {\n<123> error_setg(errp, "Invalid host forwarding rule '%s'", redir_str);\n<125> return -1;
<1> ACL_USER * check_acl_user ( LEX_USER * user_name , uint * acl_acl_userdx ) {\n<6> counter < acl_users . elements ;\n<7> counter ++ ) {\n<10> if ( ! ( user = acl_user -> user ) ) user = "" ;\n<12> if ( ! strcmp ( user_name -> user . str , user ) && ! my_strcasecmp ( system_charset_info , user_name -> host . str , host ) ) break ;
<1> REGRESSION_TEST ( SDK_API_TSUrl ) ( RegressionTest * test , int , int * pstatus ) {\n<17> char port_char [ 10 ] ;\n<58> memset ( port_char , 0 , 10 ) ;\n<63> url_expected_string = ( char * ) TSmalloc ( len * sizeof ( char ) ) ;\n<64> memset ( url_expected_string , 0 , url_expected_length + 1 ) ;\n<68> if ( TSUrlCreate ( bufp1 , & url_loc1 ) != TS_SUCCESS ) {\n<197> url_string_from_1 = TSUrlStringGet ( bufp1 , url_loc1 , & tmp_len ) ;\n<198> if ( strcmp ( url_string_from_1 , url_expected_string ) == 0 ) {\n<199> SDK_RPRINT ( test , "TSUrlStringGet" , "TestCase1" , TC_PASS , "ok" ) ;\n<200> test_passed_string1 = true ;\n<203> SDK_RPRINT ( test , "TSUrlStringGet" , "TestCase1" , TC_FAIL , "Values don't match" ) ;\n<210> if ( TSUrlCopy ( bufp2 , url_loc2 , bufp1 , url_loc1 ) == TS_ERROR ) {\n<222> url_string_from_2 = TSUrlStringGet ( bufp2 , url_loc2 , & tmp_len ) ;\n<223> if ( strcmp ( url_string_from_2 , url_expected_string ) == 0 ) {\n<224> SDK_RPRINT ( test , "TSUrlStringGet" , "TestCase2" , TC_PASS , "ok" ) ;\n<225> test_passed_string2 = true ;\n<228> SDK_RPRINT ( test , "TSUrlStringGet" , "TestCase2" , TC_FAIL , "Values don't match" ) ;\n<230> if ( strcmp ( url_string_from_1 , url_string_from_2 ) == 0 ) {\n<231> SDK_RPRINT ( test , "TSUrlCopy" , "TestCase1" , TC_PASS , "ok" ) ;\n<232> test_passed_copy = true ;\n<235> SDK_RPRINT ( test , "TSUrlCopy" , "TestCase1" , TC_FAIL , "Values Don't Match" ) ;\n<239> if ( TSUrlClone ( bufp3 , bufp1 , url_loc1 , & url_loc3 ) != TS_SUCCESS ) {\n<243> url_string_from_3 = TSUrlStringGet ( bufp3 , url_loc3 , & tmp_len ) ;\n<244> if ( strcmp ( url_string_from_1 , url_string_from_3 ) == 0 ) {\n<245> SDK_RPRINT ( test , "TSUrlClone" , "TestCase1" , TC_PASS , "ok" ) ;\n<246> test_passed_clone = true ;\n<249> SDK_RPRINT ( test , "TSUrlClone" , "TestCase1" , TC_FAIL , "Values Don't Match" ) ;\n<253> if ( url_string_from_print == nullptr ) {\n<257> if ( strcmp ( url_string_from_print , url_expected_string ) == 0 ) {\n<258> SDK_RPRINT ( test , "TSUrlPrint" , "TestCase1" , TC_PASS , "ok" ) ;\n<259> test_passed_print = true ;\n<262> SDK_RPRINT ( test , "TSUrlPrint" , "TestCase1" , TC_FAIL , "TSUrlPrint doesn't return TS_SUCCESS" ) ;\n<264> TSfree ( url_string_from_print ) ;\n<284> print_results : TSfree ( url_expected_string ) ;\n<285> if ( url_string_from_1 != nullptr ) {\n<288> if ( url_string_from_2 != nullptr ) {\n<291> if ( url_string_from_3 != nullptr ) {
<1> static void print_error ( FILE * where , char * fmt , ... ) {\n<2> char temp [ 10000 ] ;\n<4> va_start ( ap , fmt ) ;\n<6> vsnprintf ( temp , 9998 , fmt , ap ) ;\n<8> va_end ( ap ) ;\n<9> syslog ( LOG_INFO , temp ) ;\n<10> if ( where != NULL ) fprintf ( where , "Das_Watchdog: %s\n" , temp ) ;
<43> static void default_print_section_header ( WriterContext * wctx ) {\n<54> if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "[%s]\n" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;\n<475> static const char * json_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) {\n<484> * p ;\n<485> p ++ ) {\n<486> char * s = strchr ( json_escape , * p ) ;\n<489> av_bprint_chars ( dst , json_subst [ s - json_escape ] , 1 ) ;\n<491> else if ( ( unsigned char ) * p < 32 ) {\n<492> av_bprintf ( dst , "\\u00%02x" , * p & 0xff ) ;\n<495> av_bprint_chars ( dst , * p , 1 ) ;
<1> static bool update_schema_privilege ( THD * thd , TABLE * table , char * buff , const char * db , const char * t_name , const char * column , uint col_length , const char * priv , uint priv_length , const char * is_grantable ) {\n<5> table -> field [ 0 ] -> store ( buff , ( uint ) strlen ( buff ) , cs ) ;\n<6> if ( db ) table -> field [ i ++ ] -> store ( db , ( uint ) strlen ( db ) , cs ) ;\n<7> if ( t_name ) table -> field [ i ++ ] -> store ( t_name , ( uint ) strlen ( t_name ) , cs ) ;\n<10> table -> field [ i ] -> store ( is_grantable , strlen ( is_grantable ) , cs ) ;
<1> int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n<34> qemu_get_be32s(f, &features);\n<36> if (features & ~supported_features) {\n<38> fprintf(stderr, "Features 0x%x unsupported. Allowed features: 0x%x\n",\n<62> for (i = 0; i < num; i++) {\n<68> qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n<78> num_heads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n<82> if (num_heads > vdev->vq[i].vring.num) {\n<84> fprintf(stderr, "VQ %d size 0x%x Guest index 0x%x "\n<90> vring_avail_idx(&vdev->vq[i]),
<1> enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) {\n<18> if ( len == - 1 ) {\n<22> obuf [ len ] = '\0' ;\n<27> mutt_debug ( 2 , "CRAM response: %s\n" , obuf ) ;\n<28> mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ;
<1> int unix_listen_opts(QemuOpts *opts)\n<7> const char *path = qemu_opt_get(opts, "path");\n<15> if (sock < 0) {\n<25> memset(&un, 0, sizeof(un));\n<29> if (path && strlen(path)) {\n<31> snprintf(un.sun_path, sizeof(un.sun_path), "%s", path);\n<35> char *tmpdir = getenv("TMPDIR");\n<37> snprintf(un.sun_path, sizeof(un.sun_path), "%s/qemu-socket-XXXXXX",\n<39> tmpdir ? tmpdir : "/tmp");\n<55> fd = mkstemp(un.sun_path); close(fd);\n<57> qemu_opt_set(opts, "path", un.sun_path);\n<65> if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n<67> fprintf(stderr, "bind(unix:%s): %s\n", un.sun_path, strerror(errno));\n<73> if (listen(sock, 1) < 0) {\n<75> fprintf(stderr, "listen(unix:%s): %s\n", un.sun_path, strerror(errno));\n<83> if (sockets_debug)\n<85> fprintf(stderr, "bind(unix:%s): OK\n", un.sun_path);
<1> static int test_forward_match ( xd3_stream * stream , int unused ) {\n<3> uint8_t buf1 [ 256 ] , buf2 [ 256 ] ;\n<4> memset ( buf1 , 0 , 256 ) ;\n<5> memset ( buf2 , 0 , 256 ) ;\n<9> CHECK ( xd3_forward_match ( buf1 , buf2 , i ) == ( int ) i ) ;\n<15> CHECK ( xd3_forward_match ( buf1 , buf2 , 256 ) == ( int ) i ) ;
<1> static void spapr_finalize_fdt(sPAPREnvironment *spapr,\n<31> if (ret < 0) {\n<33> fprintf(stderr, "couldn't setup vio devices in fdt\n");\n<49> if (ret < 0) {\n<51> fprintf(stderr, "couldn't setup PCI devices in fdt\n");\n<63> if (ret < 0) {\n<65> fprintf(stderr, "Couldn't set up RTAS device tree properties\n");\n<77> if (ret < 0) {\n<79> fprintf(stderr, "Couldn't set up NUMA device tree properties\n");
<1> static void InSymbol ( cmsIT8 * it8 ) {\n<25> NextCh ( it8 ) ;\n<30> NextCh ( it8 ) ;\n<71> NextCh ( it8 ) ;\n<80> if ( isidchar ( it8 -> ch ) ) {\n<82> snprintf ( it8 -> id , 127 , "%d" , it8 -> inum ) ;\n<85> snprintf ( it8 -> id , 127 , it8 -> DoubleFormatter , it8 -> dnum ) ;\n<87> k = ( int ) strlen ( it8 -> id ) ;\n<88> idptr = it8 -> id + k ;\n<90> if ( ++ k < MAXID ) * idptr ++ = ( char ) it8 -> ch ;\n<91> NextCh ( it8 ) ;
<1> static void do_video_out(AVFormatContext *s,\n<135> ret = avcodec_encode_video2(enc, &pkt, in_picture, &got_packet);\n<159> write_frame(s, &pkt, ost);\n<169> if (ost->logfile && enc->stats_out) {\n<171> fprintf(ost->logfile, "%s", enc->stats_out);
<1> static void handle_null_request ( int tun_fd , int dns_fd , struct query * q , int domain_len ) {\n<11> if ( domain_len < 2 ) return ;\n<12> memcpy ( in , q -> name , MIN ( domain_len , sizeof ( in ) ) ) ;\n<13> if ( in [ 0 ] == 'V' || in [ 0 ] == 'v' ) {\n<15> read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n<19> if ( version == VERSION ) {\n<21> if ( userid >= 0 ) {\n<25> tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n<26> memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n<27> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<30> send_version_response ( dns_fd , VERSION_ACK , users [ userid ] . seed , userid , q ) ;\n<31> syslog ( LOG_INFO , "accepted version for user #%d from %s" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n<71> send_version_response ( dns_fd , VERSION_FULL , created_users , 0 , q ) ;\n<72> syslog ( LOG_INFO , "dropped user from %s, server full" , format_addr ( & q -> from , q -> fromlen ) ) ;\n<76> send_version_response ( dns_fd , VERSION_NACK , VERSION , 0 , q ) ;\n<77> syslog ( LOG_INFO , "dropped user from %s, sent bad version %08X" , format_addr ( & q -> from , q -> fromlen ) , version ) ;
<1> int main ( int argc , char * * argv ) {\n<37> printf ( "Using %s\n" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n<54> if ( res ) {\n<55> printf ( "Failed to get config: %s\n" , vpx_codec_err_to_string ( res ) ) ;\n<174> printf ( "\n" ) ;\n<175> printf ( "Frame cnt and encoding time/FPS stats for encoding: %d %f %f \n" , frame_cnt , * ( float ) cx_time / ( double ) ( frame_cnt * 1000000 ) , * ( double ) frame_cnt / ( double ) cx_time ) ;
<1> static int * get_userlist ( struct proclistlist * pll , int * num_users ) {\n<2> int * ret = calloc ( sizeof ( int ) , pll -> length ) ;\n<10> if ( ! is_a_member ( uid . uid , ret , * num_users ) ) {\n<15> return ret ;
<1> void avpriv_do_elbg(int *points, int dim, int numpoints, int *codebook,\n<13> elbg_data *elbg = &elbg_d;\n<19> int *size_part = av_malloc(numCB*sizeof(int));\n<35> elbg->codebook = codebook;\n<37> elbg->cells = av_malloc(numCB*sizeof(cell *));\n<39> elbg->utility = av_malloc(numCB*sizeof(int));\n<63> memset(elbg->utility, 0, numCB*sizeof(int));\n<65> memset(elbg->cells, 0, numCB*sizeof(cell *));\n<79> best_dist = distance_limited(elbg->points + i*elbg->dim, elbg->codebook + best_idx*elbg->dim, dim, INT_MAX);\n<101> elbg->utility[elbg->nearest_cb[i]] += dist_cb[i];\n<107> elbg->cells[elbg->nearest_cb[i]] = free_cells;\n<115> do_shiftings(elbg);\n<119> memset(size_part, 0, numCB*sizeof(int));\n<123> memset(elbg->codebook, 0, elbg->numCB*dim*sizeof(int));\n<129> size_part[elbg->nearest_cb[i]]++;\n<133> elbg->codebook[elbg->nearest_cb[i]*elbg->dim + j] +=\n<143> vect_division(elbg->codebook + i*elbg->dim,\n<145> elbg->codebook + i*elbg->dim, size_part[i], elbg->dim);\n<149> } while(((last_error - elbg->error) > DELTA_ERR_MAX*elbg->error) &&\n<157> av_free(size_part);\n<159> av_free(elbg->utility);\n<163> av_free(elbg->cells);
<1> static void *qemu_rdma_data_init(const char *host_port, Error **errp)\n<11> if (host_port) {\n<13> rdma = g_malloc0(sizeof(RDMAContext));\n<15> memset(rdma, 0, sizeof(RDMAContext));\n<35> g_free(rdma);\n<49> return rdma;
<1> int inet_dgram_opts(QemuOpts *opts)\n<5> struct addrinfo ai, *peer = NULL, *local = NULL;\n<21> memset(&ai,0, sizeof(ai));\n<23> ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n<25> ai.ai_family = PF_UNSPEC;\n<27> ai.ai_socktype = SOCK_DGRAM;\n<35> if (addr == NULL || strlen(addr) == 0) {\n<37> addr = "localhost";\n<41> if (port == NULL || strlen(port) == 0) {\n<43> fprintf(stderr, "inet_dgram: port not specified\n");\n<45> return -1;\n<51> if (qemu_opt_get_bool(opts, "ipv4", 0))\n<53> ai.ai_family = PF_INET;\n<55> if (qemu_opt_get_bool(opts, "ipv6", 0))\n<57> ai.ai_family = PF_INET6;\n<61> if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n<63> fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port,\n<65> gai_strerror(rc));\n<71> if (sockets_debug) {\n<73> fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, addr, port);\n<75> inet_print_addrinfo(__FUNCTION__, peer);\n<83> memset(&ai,0, sizeof(ai));\n<97> if (addr == NULL || strlen(addr) == 0) {\n<99> addr = NULL;\n<103> if (!port || strlen(port) == 0)\n<105> port = "0";\n<109> if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {\n<111> fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port,\n<113> gai_strerror(rc));\n<119> if (sockets_debug) {\n<121> fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, addr, port);\n<123> inet_print_addrinfo(__FUNCTION__, local);\n<133> if (sock < 0) {\n<135> fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__,\n<137> inet_strfamily(peer->ai_family), strerror(errno));\n<149> if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n<155> fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__);\n<161> if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n<163> fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__,\n<165> inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n<175> if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n<181> fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__);\n<187> if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n<189> fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__,\n<191> inet_strfamily(peer->ai_family),\n<193> peer->ai_canonname, uaddr, uport, strerror(errno));\n<221> freeaddrinfo(peer);
<1> static int do_token_in(USBDevice *s, USBPacket *p)\n<61> if (s->setup_buf[0] & USB_DIR_IN) {\n<63> int len = s->setup_len - s->setup_index;\n<65> if (len > p->len)\n<67> len = p->len;\n<69> memcpy(p->data, s->data_buf + s->setup_index, len);\n<71> s->setup_index += len;\n<77> return len;
<1> static void __attribute__ ( ( __noreturn__ ) ) usage ( int status ) {\n<2> if ( su_mode == RUNUSER_MODE ) {\n<4> printf ( _ ( " %s [options] -u <user> [[--] <command>]\n" ) , program_invocation_short_name ) ;\n<5> printf ( _ ( " %s [options] [-] [<user> [<argument>...]]\n" ) , program_invocation_short_name ) ;\n<12> printf ( _ ( " %s [options] [-] [<user> [<argument>...]]\n" ) , program_invocation_short_name ) ;\n<27> printf ( USAGE_MAN_TAIL ( su_mode == SU_MODE ? "su(1)" : "runuser(1)" ) ) ;
<1> static void ehci_mem_writeb(void *ptr, target_phys_addr_t addr, uint32_t val)\n<5> fprintf(stderr, "EHCI doesn't handle byte writes to MMIO\n");
<1> static int decode_spectrum_and_dequant(AACContext * ac, float coef[1024], GetBitContext * gb, float sf[120],\n<9> const uint16_t * offsets = ics->swb_offset;\n<15> for (g = 0; g < ics->num_windows; g++)\n<17> memset(coef + g * 128 + offsets[ics->max_sfb], 0, sizeof(float)*(c - offsets[ics->max_sfb]));\n<35> for (group = 0; group < ics->group_len[g]; group++) {\n<37> memset(coef + group * 128 + offsets[i], 0, (offsets[i+1] - offsets[i])*sizeof(float));\n<43> const float scale = sf[idx] / ((offsets[i+1] - offsets[i]) * PNS_MEAN_ENERGY);\n<51> coef[group*128+k] = ac->random_state * scale;\n<91> coef[coef_tmp_idx + j] = 1 - 2*(int)get_bits1(gb);\n<97> coef[coef_tmp_idx + j] = 1.0f;\n<125> coef[coef_tmp_idx + j] *= cbrtf(fabsf(n)) * n;\n<129> coef[coef_tmp_idx + j] *= vq_ptr[j];\n<137> coef[coef_tmp_idx + j] *= vq_ptr[j];\n<141> coef[coef_tmp_idx + j] *= sf[idx];\n<151> coef += ics->group_len[g]<<7;
<1> static int paf_video_decode(AVCodecContext *avctx, void *data,\n<7> PAFVideoDecContext *c = avctx->priv_data;\n<43> if (code & 0x20) {  // frame is keyframe\n<45> for (i = 0; i < 4; i++)\n<47> memset(c->frame[i], 0, c->frame_size);\n<51> memset(c->pic->data[1], 0, AVPALETTE_SIZE);\n<71> uint32_t *out = (uint32_t *)c->pic->data[1];\n<131> if ((ret = decode_0(c, pkt->data, code)) < 0)\n<171> if (frame != c->current_frame)\n<173> memcpy(c->frame[c->current_frame], c->frame[frame], c->frame_size);\n<191> while (dst < end) {\n<207> count = FFABS(code) + 1;\n<215> if (code < 0)\n<217> memset(dst, bytestream2_get_byteu(&c->gb), count);\n<223> dst += count;\n<237> av_image_copy_plane(c->pic->data[0], c->pic->linesize[0],
<1> int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,\n<9> AVProbeData pd = { filename ? filename : "", NULL, -offset };\n<63> buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n<75> if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n<79> if (ret != AVERROR_EOF) {\n<93> pd.buf_size += ret;\n<95> pd.buf = &buf[offset];\n<99> memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n<105> *fmt = av_probe_input_format2(&pd, 1, &score);
<1> static int decode_frame_header(ProresContext *ctx, const uint8_t *buf,\n<100> memset(ctx->qmat_luma, 4, 64);\n<115> memset(ctx->qmat_chroma, 4, 64);
<1> static void fz_cached_color_convert ( fz_context * ctx , fz_color_converter * cc_ , float * ds , const float * ss ) {\n<3> void * val = fz_hash_find ( ctx , cc -> hash , ss ) ;\n<4> int n = cc -> base . ds -> n * sizeof ( float ) ;\n<6> if ( val ) {\n<7> memcpy ( ds , val , n ) ;\n<10> base_cc -> convert ( ctx , base_cc , ds , ss ) ;\n<11> val = fz_malloc ( ctx , n ) ;\n<12> memcpy ( val , ds , n ) ;\n<14> fz_hash_insert ( ctx , cc -> hash , ss , val ) ;
<1> int decode_msg ( struct sip_msg * msg , char * code , unsigned int len ) {\n<4> memcpy ( & h , & code [ 2 ] , 2 ) ;\n<5> h = ntohs ( h ) ;\n<7> memcpy ( & h , & code [ 4 ] , 2 ) ;\n<8> h = ntohs ( h ) ;\n<9> msg -> len = h ;
<1> static int transcode_init(void)\n<85> codec  = ost->st->codec;\n<91> icodec = ist->st->codec;\n<115> extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n<159> if (!codec->extradata) {\n<165> memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n<167> codec->extradata_size = icodec->extradata_size;\n<259> if (!ost->enc) {\n<307> choose_sample_rate(ost->st, ost->enc);\n<317> choose_sample_fmt(ost->st, ost->enc);\n<395> if (ost->enc && ost->enc->supported_framerates && !ost->force_fps) {\n<467> if ((codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n<481> if (!strcmp(ost->enc->name, "libx264")) {\n<483> av_dict_set(&ost->opts, "stats", logfilename, AV_DICT_DONT_OVERWRITE);\n<487> if (codec->flags & CODEC_FLAG_PASS1) {\n<491> if (!f) {\n<493> av_log(NULL, AV_LOG_FATAL, "Cannot write log file '%s' for pass-1 encoding: %s\n",\n<495> logfilename, strerror(errno));\n<541> AVCodec      *codec = ost->enc;\n<547> if ((ist = get_input_stream(ost)))\n<551> if (dec && dec->subtitle_header) {\n<553> ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n<555> if (!ost->st->codec->subtitle_header) {\n<563> memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<565> ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n<573> if (avcodec_open2(ost->st->codec, codec, &ost->opts) < 0) {\n<585> assert_codec_experimental(ost->st->codec, 1);\n<659> if (avformat_write_header(oc, &output_files[i]->opts) < 0) {\n<671> if (strcmp(oc->oformat->name, "rtp")) {\n<673> want_sdp = 0;\n<773> av_log(NULL, AV_LOG_INFO, " -> Stream #%d:%d (%s)\n", ost->file_index,\n<775> ost->index, ost->enc ? ost->enc->name : "?");\n<807> av_log(NULL, AV_LOG_INFO, " (%s -> %s)", input_streams[ost->source_index]->dec ?\n<811> ost->enc ? ost->enc->name : "?");
<1> static int parse_picture_segment ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) {\n<8> picture_id = bytestream_get_be16 ( & buf ) ;\n<9> buf ++ ;\n<10> sequence_desc = bytestream_get_byte ( & buf ) ;\n<12> if ( buf_size > ctx -> pictures [ picture_id ] . rle_remaining_len ) return - 1 ;\n<13> memcpy ( ctx -> pictures [ picture_id ] . rle + ctx -> pictures [ picture_id ] . rle_data_len , buf , buf_size ) ;\n<14> ctx -> pictures [ picture_id ] . rle_data_len += buf_size ;\n<15> ctx -> pictures [ picture_id ] . rle_remaining_len -= buf_size ;\n<20> rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2 ;\n<21> width = bytestream_get_be16 ( & buf ) ;\n<22> height = bytestream_get_be16 ( & buf ) ;\n<27> if ( buf_size > rle_bitmap_len ) {\n<33> av_fast_malloc ( & ctx -> pictures [ picture_id ] . rle , & ctx -> pictures [ picture_id ] . rle_buffer_size , rle_bitmap_len ) ;\n<34> if ( ! ctx -> pictures [ picture_id ] . rle ) return - 1 ;\n<35> memcpy ( ctx -> pictures [ picture_id ] . rle , buf , buf_size ) ;\n<36> ctx -> pictures [ picture_id ] . rle_data_len = buf_size ;\n<37> ctx -> pictures [ picture_id ] . rle_remaining_len = rle_bitmap_len - buf_size ;
<1> static gboolean isSignal ( const gchar * signal_str_p , const gchar * signalStr ) {\n<5> if ( ( * signal_str_p == '\0' ) && ( * signalStr == '\0' ) ) return TRUE ;\n<6> resultArray = g_strsplit ( signalStr , "," , 10 ) ;\n<8> resultArray [ i ] ;\n<9> i ++ ) {\n<10> g_strstrip ( resultArray [ i ] ) ;\n<11> if ( strcmp ( resultArray [ i ] , signal_str_p ) == 0 ) return TRUE ;\n<13> g_strfreev ( resultArray ) ;
<1> int qemuMonitorJSONGetBlockStatsInfo ( qemuMonitorPtr mon , const char * dev_name , long long * rd_req , long long * rd_bytes , long long * rd_total_times , long long * wr_req , long long * wr_bytes , long long * wr_total_times , long long * flush_req , long long * flush_total_times , long long * errs ) {\n<38> if ( STRPREFIX ( thisdev , QEMU_DRIVE_HOST_PREFIX ) ) thisdev += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n<39> if ( STRNEQ ( thisdev , dev_name ) ) continue ;
<1> static void short_usage ( FILE * f ) {\n<2> short_usage_sub ( f ) ;\n<3> fprintf ( f , "For more options, use %s --help\n" , my_progname_short ) ;
<1> static int wm8750_tx(I2CSlave *i2c, uint8_t data)\n<5> WM8750State *s = (WM8750State *) i2c;\n<13> if (s->i2c_len >= 2) {\n<15> printf("%s: long message (%i bytes)\n", __FUNCTION__, s->i2c_len);\n<25> s->i2c_data[s->i2c_len ++] = data;
<72> if ( aborted ) {\n<85> ttf_fftm_dump ( sf , at ) ;\n<87> initATTables ( at , sf , format ) ;\n<94> at -> cvtf = dumpstoredtable ( sf , CHR ( 'c' , 'v' , 't' , ' ' ) , & at -> cvtlen ) ;\n<103> tex_dump ( at , sf ) ;\n<105> if ( sf -> subfonts != NULL ) {\n<106> free ( sf -> glyphs ) ;\n<110> free ( at -> gi . bygid ) ;
<1> static void xen_init_pv(QEMUMachineInitArgs *args)\n<49> if (xen_be_init() != 0) {\n<51> fprintf(stderr, "%s: xen backend core setup failed\n", __FUNCTION__);\n<59> switch (xen_mode) {\n<69> if (xen_domain_build_pv(kernel_filename, initrd_filename,\n<73> fprintf(stderr, "xen pv domain creation failed\n");\n<83> fprintf(stderr, "xen emulation not implemented (yet)\n");\n<135> for (i = 0; i < nb_nics; i++) {\n<137> if (!nd_table[i].model || 0 != strcmp(nd_table[i].model, "xen"))\n<141> xen_config_dev_nic(nd_table + i);
<1> static void test_dealloc_partial(void)\n<27> qdict_put_obj(ud2_dict, "string0", QOBJECT(qstring_from_str(text)));\n<45> assert(ud2 != NULL);\n<47> assert(ud2->string0 != NULL);\n<49> assert(strcmp(ud2->string0, text) == 0);\n<65> qapi_free_UserDefTwo(ud2);
<1> static int decode_header(EXRContext *s)\n<131> bytestream2_init(&ch_gb, s->gb.buffer, var_size);\n<135> while (bytestream2_get_bytes_left(&ch_gb) >= 19) {\n<147> if (strcmp(s->layer, "") != 0) {\n<149> if (strncmp(ch_gb.buffer, s->layer, strlen(s->layer)) == 0) {\n<151> layer_match = 1;\n<153> av_log(s->avctx, AV_LOG_INFO,\n<155> "Channel match layer : %s.\n", ch_gb.buffer);\n<157> ch_gb.buffer += strlen(s->layer);\n<159> if (*ch_gb.buffer == '.')\n<161> ch_gb.buffer++;         /* skip dot if not given */\n<165> av_log(s->avctx, AV_LOG_INFO,\n<167> "Channel doesn't match layer : %s.\n", ch_gb.buffer);\n<173> layer_match = 1;\n<179> if (layer_match) { /* only search channel if the layer match is valid */\n<181> if (!strcmp(ch_gb.buffer, "R") ||\n<183> !strcmp(ch_gb.buffer, "X") ||\n<185> !strcmp(ch_gb.buffer, "U")) {\n<187> channel_index = 0;\n<189> s->is_luma = 0;\n<191> } else if (!strcmp(ch_gb.buffer, "G") ||\n<193> !strcmp(ch_gb.buffer, "V")) {\n<195> channel_index = 1;\n<197> s->is_luma = 0;\n<199> } else if (!strcmp(ch_gb.buffer, "Y")) {\n<201> channel_index = 1;\n<203> s->is_luma = 1;\n<205> } else if (!strcmp(ch_gb.buffer, "B") ||\n<207> !strcmp(ch_gb.buffer, "Z") ||\n<209> !strcmp(ch_gb.buffer, "W")){\n<211> channel_index = 2;\n<213> s->is_luma = 0;\n<215> } else if (!strcmp(ch_gb.buffer, "A")) {\n<217> channel_index = 3;\n<221> av_log(s->avctx, AV_LOG_WARNING,\n<223> "Unsupported channel %.256s.\n", ch_gb.buffer);\n<233> while (bytestream2_get_bytes_left(&ch_gb) > 0 &&\n<235> bytestream2_get_byte(&ch_gb))\n<241> if (bytestream2_get_bytes_left(&ch_gb) < 4) {\n<251> current_pixel_type = bytestream2_get_le32(&ch_gb);\n<265> bytestream2_skip(&ch_gb, 4);\n<267> xsub = bytestream2_get_le32(&ch_gb);\n<269> ysub = bytestream2_get_le32(&ch_gb);\n<371> s->gb.buffer = ch_gb.buffer + 1;\n<375> } else if ((var_size = check_header_variable(s, "dataWindow", "box2i",
<1> AVStream *add_video_stream(AVFormatContext *oc, int codec_id)\n<19> if (!st) {\n<21> fprintf(stderr, "Could not alloc stream\n");\n<33> if (!codec) {\n<35> fprintf(stderr, "codec not found\n");\n<71> if (avcodec_open(c, codec) < 0) {\n<73> fprintf(stderr, "could not open codec\n");\n<85> video_outbuf_size = 100000;\n<87> video_outbuf = malloc(video_outbuf_size);\n<93> picture_buf = malloc((size * 3) / 2); /* size for YUV 420 */\n<97> picture->data[0] = picture_buf;
<1> int jbig2_decode_generic_mmr ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image ) {\n<3> const uint32_t rowstride = image -> stride ;\n<4> byte * dst = image -> data ;\n<10> y < image -> height ;\n<12> memset ( dst , 0 , rowstride ) ;\n<13> code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n<16> dst += rowstride ;
<1> TSReturnCode TSHttpHdrMethodSet ( TSMBuffer bufp , TSMLoc obj , const char * value , int length ) {\n<10> if ( length < 0 ) {\n<11> length = strlen ( value ) ;\n<13> h . method_set ( value , length ) ;
<1> static void timer_enable(struct xlx_timer *xt)\n<11> xt->nr, xt->regs[R_TCSR] & TCSR_UDT));
<1> static void vmxnet3_activate_device(VMXNET3State *s)\n<131> for (i = 0; i < s->txq_num; i++) {\n<225> for (i = 0; i < s->rxq_num; i++) {
<1> e1000_receive_iov(NetClientState *nc, const struct iovec *iov, int iovcnt)\n<61> if (size < sizeof(min_buf)) {\n<63> iov_to_buf(iov, iovcnt, 0, min_buf, size);\n<65> memset(&min_buf[size], 0, sizeof(min_buf) - size);\n<123> if (filter_buf == iov->iov_base) {\n<125> memmove(filter_buf + 4, filter_buf, 12);
<1> enum message_read_status evhttp_parse_firstline ( struct evhttp_request * req , struct evbuffer * buffer ) {\n<5> if ( line == NULL ) return ( MORE_DATA_EXPECTED ) ;\n<7> case EVHTTP_REQUEST : if ( evhttp_parse_request_line ( req , line ) == - 1 ) status = DATA_CORRUPTED ;\n<9> case EVHTTP_RESPONSE : if ( evhttp_parse_response_line ( req , line ) == - 1 ) status = DATA_CORRUPTED ;\n<13> free ( line ) ;
<1> static inline int parse_nal_units(AVCodecParserContext *s, const uint8_t *buf,\n<9> H2645Packet   *pkt = &ctx->pkt;\n<28> if (!tmp)\n<30> pkt->nals = tmp;\n<31> memset(pkt->nals, 0, sizeof(*tmp));\n<34> nal = &pkt->nals[0];
<1> void help(void)
<1> static void iv_Decode_Chunk(Indeo3DecodeContext *s,\n<62> strip->ypos = strip->xpos = 0;\n<64> for(strip->width = min_width_160; width > strip->width; strip->width *= 2);\n<66> strip->height = height;\n<68> strip->split_direction = 0;\n<70> strip->split_flag = 0;\n<72> strip->usl7 = 0;\n<84> while(strip >= strip_tbl) {\n<106> if(strip >= strip_tbl + FF_ARRAY_ELEMS(strip_tbl)) {\n<114> memcpy(strip, strip-1, sizeof(*strip));\n<116> strip->split_flag = 1;\n<118> strip->split_direction = 0;\n<120> strip->height = (strip->height > 8 ? ((strip->height+8)>>4)<<3 : 4);\n<128> if(strip >= strip_tbl + FF_ARRAY_ELEMS(strip_tbl)) {\n<136> memcpy(strip, strip-1, sizeof(*strip));\n<138> strip->split_flag = 1;\n<140> strip->split_direction = 1;\n<142> strip->width = (strip->width > 8 ? ((strip->width+8)>>4)<<3 : 4);\n<148> if(strip->usl7 == 0) {\n<150> strip->usl7 = 1;\n<160> if(strip->usl7 == 0) {\n<162> strip->usl7 = 1;\n<176> cur_frm_pos = cur + width * strip->ypos + strip->xpos;\n<532> if(lp2 > 0 || flag1 == 0 || strip->ypos != 0)\n<558> if(lp2 > 0 || flag1 == 0 || strip->ypos != 0)\n<792> if(lp2 > 0 || strip->ypos != 0 || flag1 == 0) {\n<818> if(lp2 > 0 || strip->ypos != 0 || flag1 == 0) {\n<1482> if(strip->split_flag != 0) {\n<1484> strip->split_flag = 0;\n<1486> strip->usl7 = (strip-1)->usl7;\n<1494> strip->width = (strip-1)->width - strip->width;\n<1496> if(region_160_width <= strip->xpos && width < strip->width + strip->xpos)\n<1498> strip->width = width - strip->xpos;\n<1502> strip->ypos += strip->height;\n<1504> strip->height = (strip-1)->height - strip->height;
<1> static void test_free_store_result ( ) {\n<4> char c2 [ 5 ] ;\n<16> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<30> c2 [ 0 ] = '\0' ;\n<31> l2 = 0 ;\n<39> if ( ! opt_silent ) fprintf ( stdout , "\n col 1: %s(%ld)" , c2 , l2 ) ;\n<40> DIE_UNLESS ( strncmp ( c2 , "1" , 1 ) == 0 && l2 == 1 ) ;\n<43> c1 = 0 , l2 = 0 ;\n<51> if ( ! opt_silent ) fprintf ( stdout , "\n col 0: %d(%ld)" , c1 , l2 ) ;\n<52> DIE_UNLESS ( c1 == 2 && l2 == 4 ) ;
<1> static int auth_server_input_mech ( struct auth_server_connection * conn , const char * const * args ) {\n<7> if ( args [ 0 ] == NULL ) {\n<12> mech_desc . name = p_strdup ( conn -> pool , args [ 0 ] ) ;\n<13> if ( strcmp ( mech_desc . name , "PLAIN" ) == 0 ) conn -> has_plain_mech = TRUE ;\n<15> * args != NULL ;\n<16> args ++ ) {\n<17> if ( strcmp ( * args , "private" ) == 0 ) mech_desc . flags |= MECH_SEC_PRIVATE ;\n<18> else if ( strcmp ( * args , "anonymous" ) == 0 ) mech_desc . flags |= MECH_SEC_ANONYMOUS ;\n<19> else if ( strcmp ( * args , "plaintext" ) == 0 ) mech_desc . flags |= MECH_SEC_PLAINTEXT ;\n<20> else if ( strcmp ( * args , "dictionary" ) == 0 ) mech_desc . flags |= MECH_SEC_DICTIONARY ;\n<21> else if ( strcmp ( * args , "active" ) == 0 ) mech_desc . flags |= MECH_SEC_ACTIVE ;\n<22> else if ( strcmp ( * args , "forward-secrecy" ) == 0 ) mech_desc . flags |= MECH_SEC_FORWARD_SECRECY ;\n<23> else if ( strcmp ( * args , "mutual-auth" ) == 0 ) mech_desc . flags |= MECH_SEC_MUTUAL_AUTH ;\n<25> array_append ( & conn -> available_auth_mechs , & mech_desc , 1 ) ;
<1> static int ogg_read_page(AVFormatContext *s, int *str)\n<131> os = ogg->streams + idx;\n<195> if (os->bufsize - os->bufpos < size){\n<197> uint8_t *nb = av_malloc (os->bufsize *= 2);\n<199> memcpy (nb, os->buf, os->bufpos);\n<201> av_free (os->buf);\n<203> os->buf = nb;\n<209> ret = avio_read(bc, os->buf + os->bufpos, size);\n<217> os->bufpos += size;
<1> static void die ( const char * format , ... ) {\n<4> fprintf ( stderr , "%s: " , PGM ) ;\n<5> if ( wherestr ) fprintf ( stderr , "%s: " , wherestr ) ;\n<7> vfprintf ( stderr , format , arg_ptr ) ;
<1> static inline void decode_subband_slice_buffered(SnowContext *s, SubBand *b, slice_buffer * sb, int start_y, int h, int save_state[1]){\n<37> for(y=start_y; y<h; y++){\n<43> IDWTELEM * line = slice_buffer_get_line(sb, y * b->stride_line + b->buf_y_offset) + b->buf_x_offset;\n<45> memset(line, 0, b->width*sizeof(IDWTELEM));\n<57> line[x] = (t^u) - u;
<1> static int bfi_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<8> uint8_t * frame_end = bfi -> dst + avctx -> width * avctx -> height ;\n<11> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<90> src = bfi -> dst ;\n<91> dst = frame -> data [ 0 ] ;\n<92> while ( height -- ) {\n<93> memcpy ( dst , src , avctx -> width ) ;\n<94> src += avctx -> width ;\n<95> dst += frame -> linesize [ 0 ] ;
<1> int ff_eac3_parse_header(AC3DecodeContext *s)\n<357> if (!s->block_switch_syntax)\n<359> memset(s->block_switch, 0, sizeof(s->block_switch));\n<411> if (s->channel_mode > 1) {\n<433> memset(s->cpl_in_use, 0, sizeof(s->cpl_in_use));\n<499> if (parse_aht_info) {\n<535> memset(s->channel_uses_aht, 0, sizeof(s->channel_uses_aht));
<5> struct ogg *ogg = s->priv_data;\n<15> if (!ost)\n<25> if (!discard){\n<41> ost->nstreams * sizeof(*ogg->streams));\n<47> av_free (ost);
<1> static bool find_cgroup_subsystems ( char * * * kernel_subsystems ) {\n<4> char * line = NULL ;\n<10> if ( ! proc_cgroups ) return false ;\n<11> while ( getline ( & line , & sz , proc_cgroups ) != - 1 ) {\n<15> if ( line [ 0 ] == '#' ) continue ;\n<16> if ( ! line [ 0 ] ) continue ;\n<17> tab1 = strchr ( line , '\t' ) ;\n<18> if ( ! tab1 ) continue ;\n<19> * tab1 ++ = '\0' ;\n<20> tab2 = strchr ( tab1 , '\t' ) ;\n<21> if ( ! tab2 ) continue ;\n<24> hierarchy_number = strtoul ( tab1 , & tab2 , 10 ) ;\n<28> if ( r < 0 ) goto out ;\n<29> ( * kernel_subsystems ) [ kernel_subsystems_count ] = strdup ( line ) ;\n<35> free ( line ) ;
<1> static int mp_decode_layer3(MPADecodeContext *s)\n<147> ff_compute_band_indexes(s, g);\n<171> if (!s->adu_mode) {\n<173> const uint8_t *ptr = s->gb.buffer + (get_bits_count(&s->gb)>>3);\n<185> memcpy(s->last_buf + s->last_buf_size, ptr, EXTRABYTES);\n<193> s->gb.size_in_bits_plus8 += EXTRABYTES * 8;\n<201> for (; ch < s->nb_channels && (s->last_buf_size >> 3) < main_data_begin; ch++) {\n<203> g = &s->granules[ch][gr];\n<207> memset(g->sb_hybrid, 0, sizeof(g->sb_hybrid));\n<455> exponents_from_scale_factors(s, g, exponents);\n<461> huffman_decode(s, g, exponents, bits_pos + g->part2_3_length);\n<479> reorder_block(s, g);\n<481> compute_antialias(s, g);\n<483> compute_imdct(s, g, &s->sb_samples[ch][18 * gr][0], s->mdct_buf[ch]);
<1> static void RemapHintMask ( HintMask * hm , int mapping [ 96 ] , int max ) {\n<4> if ( hm == NULL ) return ;\n<6> mb = ( max + 7 ) >> 3 ;\n<7> memset ( & rpl , 0 , mb ) ;\n<10> ++ i ) if ( ( * hm ) [ i >> 3 ] & ( 0x80 >> ( i & 0x7 ) ) ) rpl [ mapping [ i ] >> 3 ] |= ( 0x80 >> ( mapping [ i ] & 0x7 ) ) ;\n<11> memcpy ( hm , & rpl , mb ) ;
<1> static int match_section ( const char * section_name , int show_all_entries , AVDictionary * entries ) {\n<4> i < FF_ARRAY_ELEMS ( sections ) ;\n<6> const struct section * section = & sections [ i ] ;\n<7> if ( ! strcmp ( section_name , section -> name ) || ( section -> unique_name && ! strcmp ( section_name , section -> unique_name ) ) ) {\n<8> av_log ( NULL , AV_LOG_DEBUG , "'%s' matches section with unique name '%s'\n" , section_name , ( char * ) av_x_if_null ( section -> unique_name , section -> name ) ) ;\n<9> ret ++ ;\n<10> mark_section_show_entries ( section -> id , show_all_entries , entries ) ;
<1> static size_t qemu_rdma_save_page(QEMUFile *f, void *opaque,\n<39> if (ret < 0) {\n<41> fprintf(stderr, "rdma migration: write error! %d\n", ret);\n<105> if (ret) {\n<107> fprintf(stderr, "ram block search failed\n");\n<159> if (ret < 0) {\n<161> fprintf(stderr, "rdma migration: polling error! %d\n", ret);\n<187> rdma->error_state = ret;\n<189> return ret;
<1> abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n<362> int total_size = 0;\n<412> gp += sizeof(abi_ulong), q++) {\n<422> if (!(*q = lock_user_string(addr)))\n<426> total_size += strlen(*q) + 1;\n<436> gp += sizeof(abi_ulong), q++) {\n<446> if (!(*q = lock_user_string(addr)))\n<450> total_size += strlen(*q) + 1;\n<462> if (total_size > MAX_ARG_PAGES * TARGET_PAGE_SIZE) {\n<502> unlock_user(*q, addr, 0);\n<516> unlock_user(*q, addr, 0);\n<2463> p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n<2465> if (!p || !p2) {\n<2469> } else if (is_proc_myself((const char *)p, "exe")) {\n<2473> temp = realpath(exec_path, real);\n<2475> ret = temp == NULL ? get_errno(-1) : strlen(real) ;\n<2477> snprintf((char *)p2, arg3, "%s", real);\n<2481> ret = get_errno(readlink(path(p), p2, arg3));\n<2485> unlock_user(p2, arg2, ret);\n<2877> if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n<2903> memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));\n<2905> unlock_user_struct(target_stfs, arg2, 1);\n<3329> if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n<3333> memset(target_st, 0, sizeof(*target_st));\n<3335> __put_user(st.st_dev, &target_st->st_dev);\n<3337> __put_user(st.st_ino, &target_st->st_ino);\n<3339> __put_user(st.st_mode, &target_st->st_mode);\n<3341> __put_user(st.st_uid, &target_st->st_uid);\n<3343> __put_user(st.st_gid, &target_st->st_gid);\n<3345> __put_user(st.st_nlink, &target_st->st_nlink);\n<3347> __put_user(st.st_rdev, &target_st->st_rdev);\n<3349> __put_user(st.st_size, &target_st->st_size);\n<3351> __put_user(st.st_blksize, &target_st->st_blksize);\n<3353> __put_user(st.st_blocks, &target_st->st_blocks);\n<3355> __put_user(st.st_atime, &target_st->target_st_atime);\n<3357> __put_user(st.st_mtime, &target_st->target_st_mtime);\n<3359> __put_user(st.st_ctime, &target_st->target_st_ctime);\n<3361> unlock_user_struct(target_st, arg2, 1);\n<4078> de = dirp;\n<4080> tde = (struct target_dirent *)dirp;\n<4082> while (len > 0) {\n<4096> namelen = strlen(de->d_name);\n<4106> memmove(tde->d_name, de->d_name, namelen + 1);\n<4120> *(((char *)tde) + treclen - 1) = type;\n<4124> de = (struct linux_dirent64 *)((char *)de + reclen);\n<4126> tde = (struct target_dirent *)((char *)tde + treclen);\n<4502> if (arg2 & (sizeof(abi_ulong) - 1)) {\n<4514> mask = alloca(mask_size);\n<4516> if (!lock_user_struct(VERIFY_READ, p, arg3, 1)) {\n<4522> memcpy(mask, p, arg2);\n<4524> unlock_user_struct(p, arg2, 0);\n<4528> ret = get_errno(sys_sched_setaffinity(arg1, mask_size, mask));
<1> static void mp_decode_line ( MotionPixelsContext * mp , GetBitContext * gb , int y ) {\n<6> if ( mp -> changes_map [ y0 + x ] == 0 ) {\n<7> memset ( mp -> gradient_scale , 1 , sizeof ( mp -> gradient_scale ) ) ;\n<12> if ( w != 0 ) {\n<18> mp -> hpt [ ( ( y / 4 ) * mp -> avctx -> width + i ) / 4 ] = mp_get_yuv_from_rgb ( mp , i , y ) ;\n<23> memset ( mp -> gradient_scale , 1 , sizeof ( mp -> gradient_scale ) ) ;\n<24> p = mp_get_yuv_from_rgb ( mp , x - 1 , y ) ;\n<27> p . y += mp_gradient ( mp , 0 , mp_get_vlc ( mp , gb ) ) ;\n<31> p . v += mp_gradient ( mp , 1 , mp_get_vlc ( mp , gb ) ) ;\n<33> p . u += mp_gradient ( mp , 2 , mp_get_vlc ( mp , gb ) ) ;\n<42> mp_set_rgb_from_yuv ( mp , x , y , & p ) ;
<1> static CharDriverState *qemu_chr_open_stdio(const char *id,\n<49> memset(&act, 0, sizeof(act));\n<53> sigaction(SIGCONT, &act, NULL);
<1> static int rv34_decode_mv ( RV34DecContext * r , int block_type ) {\n<7> memset ( r -> dmv , 0 , sizeof ( r -> dmv ) ) ;\n<19> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n<36> l ++ ) s -> current_picture_ptr -> motion_val [ l ] [ mv_pos + i + j * s -> b8_stride ] [ k ] = calc_add_mv ( r , l , s -> next_picture_ptr -> motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ k ] ) ;\n<37> if ( ! ( IS_16X8 ( next_bt ) || IS_8X16 ( next_bt ) || IS_8X8 ( next_bt ) ) ) rv34_mc_2mv ( r , block_type ) ;\n<38> else rv34_mc_2mv_skip ( r ) ;\n<41> case RV34_MB_P_16x16 : case RV34_MB_P_MIX16x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n<42> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n<46> if ( r -> rv30 ) rv34_pred_mv_rv3 ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n<47> else rv34_pred_mv_b ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n<48> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , block_type == RV34_MB_B_BACKWARD ) ;\n<50> case RV34_MB_P_16x8 : case RV34_MB_P_8x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n<51> rv34_pred_mv ( r , block_type , 1 + ( block_type == RV34_MB_P_16x8 ) , 1 ) ;\n<53> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 1 , 0 ) ;\n<54> rv34_mc_1mv ( r , block_type , 0 , 8 , s -> b8_stride , 2 , 1 , 0 ) ;\n<57> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 1 , 2 , 0 ) ;\n<58> rv34_mc_1mv ( r , block_type , 8 , 0 , 1 , 1 , 2 , 0 ) ;\n<61> case RV34_MB_B_BIDIR : rv34_pred_mv_b ( r , block_type , 0 ) ;\n<62> rv34_pred_mv_b ( r , block_type , 1 ) ;\n<63> rv34_mc_2mv ( r , block_type ) ;\n<68> rv34_pred_mv ( r , block_type , i , i ) ;\n<69> rv34_mc_1mv ( r , block_type , ( i & 1 ) << 3 , ( i & 2 ) << 2 , ( i & 1 ) + ( i >> 1 ) * s -> b8_stride , 1 , 1 , 0 ) ;
<1> REGRESSION_TEST ( SDK_API_TSTrafficServerVersionGet ) ( RegressionTest * test , int , int * pstatus ) {\n<4> if ( ! ts_version ) {\n<9> int major_ts_version = 0 ;\n<10> int minor_ts_version = 0 ;\n<11> int patch_ts_version = 0 ;\n<12> if ( sscanf ( ts_version , "%d.%d.%d" , & major_ts_version , & minor_ts_version , & patch_ts_version ) != 3 ) {\n<13> SDK_RPRINT ( test , "TSTrafficServerVersionGet" , "TestCase2" , TC_FAIL , "traffic server version format is incorrect" ) ;\n<14> * pstatus = REGRESSION_TEST_FAILED ;\n<15> return ;\n<17> if ( major_ts_version < 2 ) {
<1> setvar_node * create_setvar_node ( char * var , char * val , int isdefault ) {\n<4> pch = strchr ( var , '=' ) ;\n<5> if ( NULL != pch ) * pch = '\0' ;\n<7> my_node -> var = var ;
<1> static void compact_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n<2> CompactContext * compact = wctx -> priv ;\n<3> if ( wctx -> nb_item [ wctx -> level ] ) printf ( "%c" , compact -> item_sep ) ;\n<4> if ( ! compact -> nokey ) printf ( "%s%s=" , wctx -> section_pbuf [ wctx -> level ] . str , key ) ;\n<5> printf ( "%lld" , value ) ;
<1> void qemu_cond_init(QemuCond *cond)\n<5> memset(cond, 0, sizeof(*cond));\n<11> if (!cond->sema) {\n<25> if (!cond->continue_event) {
<1> void pc_system_firmware_init(MemoryRegion *rom_memory)\n<59> if (pflash_drv != NULL) {\n<61> fprintf(stderr, "qemu: pflash cannot be used with kvm enabled\n");\n<93> if (pflash_drv != NULL) {\n<99> fprintf(stderr, "qemu: PC system firmware (pflash) not available\n");
<1> static void fill_colmap ( H264Context * h , int map [ 2 ] [ 16 + 32 ] , int list , int field , int colfield , int mbafi ) {\n<7> memset ( map [ list ] , 0 , sizeof ( map [ list ] ) ) ;
<1> static TRBCCode xhci_address_slot ( XHCIState * xhci , unsigned int slotid , uint64_t pictx , bool bsr ) {\n<54> if ( bsr ) {\n<61> memset ( & p , 0 , sizeof ( p ) ) ;\n<62> usb_packet_addbuf ( & p , buf , sizeof ( buf ) ) ;\n<63> usb_packet_setup ( & p , USB_TOKEN_OUT , usb_ep_get ( dev , USB_TOKEN_OUT , 0 ) , 0 , 0 , false , false ) ;\n<64> usb_device_handle_control ( dev , & p , DeviceOutRequest | USB_REQ_SET_ADDRESS , slotid , 0 , 0 , NULL ) ;\n<65> assert ( p . status != USB_RET_ASYNC ) ;
<1> static void test_bug3117 ( ) {\n<19> memset ( & buffer , 0 , sizeof ( buffer ) ) ;\n<25> rc = mysql_stmt_bind_result ( stmt , & buffer ) ;\n<32> if ( ! opt_silent ) fprintf ( stdout , "\n\tLAST_INSERT_ID()= 1 ok\n" ) ;\n<40> if ( ! opt_silent ) fprintf ( stdout , "\tLAST_INSERT_ID()= 2 ok\n" ) ;
<1> int tmx_init_pretran_table ( void ) {\n<14> if ( _tmx_ptran_table == NULL ) {\n<18> memset ( _tmx_ptran_table , 0 , _tmx_ptran_size * sizeof ( pretran_slot_t ) ) ;\n<29> shm_free ( _tmx_ptran_table ) ;
<1> static void openrisc_sim_init(MachineState *machine)\n<31> if (cpu == NULL) {\n<33> fprintf(stderr, "Unable to find CPU definition!\n");
<1> static void gtkui_connection_inject ( void ) {\n<36> if ( response == GTK_RESPONSE_OK ) {\n<38> SAFE_REALLOC ( injectbuf , 501 * sizeof ( char ) ) ;\n<39> memset ( injectbuf , 0 , 501 ) ;\n<44> strncpy ( injectbuf , gtk_text_buffer_get_text ( buf , & start , & end , FALSE ) , 501 ) ;
<1> static int alloc_refcount_block(BlockDriverState *bs,\n<31> s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n<111> *refcount_block = NULL;\n<129> int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n<151> if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n<159> if (ret < 0) {\n<167> memset(*refcount_block, 0, s->cluster_size);\n<185> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n<215> if (ret < 0) {\n<223> memset(*refcount_block, 0, s->cluster_size);\n<233> qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n<333> uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n<343> size_to_clusters(s, table_size * sizeof(uint64_t));\n<395> if (new_table == NULL || new_blocks == NULL) {\n<409> s->refcount_table_size * sizeof(uint64_t));\n<427> uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n<463> cpu_to_be64s(&new_table[i]);\n<471> ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n<485> be64_to_cpus(&new_table[i]);\n<521> g_free(s->refcount_table);\n<523> s->refcount_table = new_table;\n<563> g_free(new_table);
<1> static int a64_write_packet(struct AVFormatContext *s, AVPacket *pkt)\n<123> if(pkt->data) {\n<125> av_new_packet(&c->prev_pkt, pkt->size);\n<127> memcpy(c->prev_pkt.data, pkt->data, pkt->size);
<1> static void test_prepare_field_result ( ) {\n<18> if ( ! opt_silent ) fprintf ( stdout , "\n\n field attributes:\n" ) ;
<1> static void test_priorities ( int npriorities ) {\n<8> memset ( & one , 0 , sizeof ( one ) ) ;\n<9> memset ( & two , 0 , sizeof ( two ) ) ;\n<10> timeout_set ( & one . ev , test_priorities_cb , & one ) ;\n<11> if ( event_priority_set ( & one . ev , 0 ) == - 1 ) {\n<12> fprintf ( stderr , "%s: failed to set priority" , __func__ ) ;\n<15> timeout_set ( & two . ev , test_priorities_cb , & two ) ;\n<16> if ( event_priority_set ( & two . ev , npriorities - 1 ) == - 1 ) {\n<17> fprintf ( stderr , "%s: failed to set priority" , __func__ ) ;\n<21> if ( event_add ( & one . ev , & tv ) == - 1 ) exit ( 1 ) ;\n<22> if ( event_add ( & two . ev , & tv ) == - 1 ) exit ( 1 ) ;\n<24> event_del ( & one . ev ) ;\n<25> event_del ( & two . ev ) ;\n<27> if ( one . count == 3 && two . count == 3 ) test_ok = 1 ;\n<30> if ( one . count == 3 && two . count == 1 ) test_ok = 1 ;\n<33> if ( one . count == 3 && two . count == 0 ) test_ok = 1 ;
<1> bool ans_key_h ( connection_t * c ) {\n<4> char key [ MAX_STRING_SIZE ] ;\n<18> if ( ! from ) {\n<27> if ( to != myself ) {\n<35> if ( ! * address && from -> address . sa . sa_family != AF_UNSPEC && to -> minmtu ) {\n<38> sockaddr2str ( & from -> address , & address , & port ) ;\n<39> send_request ( to -> nexthop -> connection , "%s %s %s" , c -> buffer , address , port ) ;\n<40> free ( address ) ;\n<41> free ( port ) ;\n<47> from -> outkey = xrealloc ( from -> outkey , strlen ( key ) / 2 ) ;\n<48> from -> outkeylength = strlen ( key ) / 2 ;\n<49> if ( ! hex2bin ( key , from -> outkey , from -> outkeylength ) ) {
<1> static void cirrus_vga_write_palette ( CirrusVGAState * s , int reg_value ) {\n<2> s -> vga . dac_cache [ s -> vga . dac_sub_index ] = reg_value ;\n<4> if ( ( s -> vga . sr [ 0x12 ] & CIRRUS_CURSOR_HIDDENPEL ) ) {\n<5> memcpy ( & s -> cirrus_hidden_palette [ ( s -> vga . dac_write_index & 0x0f ) * 3 ] , s -> vga . dac_cache , 3 ) ;\n<8> memcpy ( & s -> vga . palette [ s -> vga . dac_write_index * 3 ] , s -> vga . dac_cache , 3 ) ;
<1> static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n<25> blkcfg.heads = heads;\n<27> blkcfg.sectors = secs;\n<30> memcpy(config, &blkcfg, sizeof(blkcfg));
<1> int fw_cfg_add_file(FWCfgState *s,  const char *filename, uint8_t *data,\n<25> if (index == FW_CFG_FILE_SLOTS) {\n<27> fprintf(stderr, "fw_cfg: out of file slots\n");\n<43> for (i = 0; i < index; i++) {\n<45> if (strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {\n<47> trace_fw_cfg_add_file_dupe(s, s->files->f[index].name);\n<49> return 1;
<1> void * xcalloc ( size_t num , size_t size ) {\n<3> if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ;\n<5> ptr = malloc ( res ) ;\n<6> if ( ptr ) {\n<7> memset ( ptr , '\0' , ( res ) ) ;\n<9> return ptr ;
<1> static int qemu_rdma_init_ram_blocks(RDMAContext *rdma)\n<5> RDMALocalBlocks *local = &rdma->local_ram_blocks;\n<13> memset(local, 0, sizeof *local);\n<17> DPRINTF("Allocated %d local ram block structures\n", local->nb_blocks);
<1> static struct matrix build_lut_matrix ( struct lutType * lut ) {\n<3> if ( lut ) {\n<16> memset ( & result , 0 , sizeof ( struct matrix ) ) ;\n<19> return result ;
<1> static int dnxhd_decode_header(DNXHDContext *ctx, const uint8_t *buf, int buf_size, int first_field)\n<5> static const uint8_t header_prefix[] = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n<11> if (buf_size < 0x280)\n<17> if (memcmp(buf, header_prefix, 5)) {\n<19> av_log(ctx->avctx, AV_LOG_ERROR, "error in header\n");\n<21> return -1;\n<25> if (buf[5] & 2) { /* interlaced */\n<27> ctx->cur_field = buf[5] & 1;\n<33> av_log(ctx->avctx, AV_LOG_DEBUG, "interlaced %d, cur field %d\n", buf[5] & 3, ctx->cur_field);\n<39> ctx->height = AV_RB16(buf + 0x18);\n<41> ctx->width  = AV_RB16(buf + 0x1a);\n<45> av_dlog(ctx->avctx, "width %d, height %d\n", ctx->width, ctx->height);\n<49> if (buf[0x21] & 0x40) {\n<85> cid = AV_RB32(buf + 0x28);\n<87> av_dlog(ctx->avctx, "compression id %d\n", cid);\n<91> if (dnxhd_init_vlc(ctx, cid) < 0)\n<109> ctx->mb_height = buf[0x16d];\n<137> ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i<<2));
<1> int tap_open(char *ifname, int ifname_size, int *vnet_hdr,\n<13> if( (fd = tap_alloc(dev, sizeof(dev))) < 0 ){\n<15> fprintf(stderr, "Cannot allocate TAP device\n");
<1> static int binkb_decode_plane ( BinkContext * c , AVFrame * frame , GetBitContext * gb , int plane_idx , int is_key , int is_chroma ) {\n<30> dst = frame -> data [ plane_idx ] + 8 * by * stride ;\n<33> bx ++ , dst += 8 ) {\n<35> switch ( blk ) {\n<52> j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n<57> j ++ ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n<61> if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = binkb_get_value ( c , BINKB_SRC_COLORS ) ;\n<63> case 2 : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<64> dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTRA_DC ) ;\n<66> read_dct_coeffs ( gb , dctblock , bink_scan , binkb_intra_quant , qp ) ;\n<67> c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n<98> memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<99> dctblock [ 0 ] = binkb_get_value ( c , BINKB_SRC_INTER_DC ) ;\n<101> read_dct_coeffs ( gb , dctblock , bink_scan , binkb_inter_quant , qp ) ;\n<102> c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n<116> j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n<133> i < 8 ;\n<134> i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINKB_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;
<1> static void test_signal_pipeloss ( void ) {\n<5> printf ( "Signal pipeloss: " ) ;\n<11> if ( close ( pipe1 ) != - 1 || errno != EBADF ) {\n<12> printf ( "signal pipe not closed. " ) ;
<1> static SchroBuffer *find_next_parse_unit(SchroParseUnitContext *parse_ctx)\n<15> parse_ctx->buf[0] != 'B' ||\n<17> parse_ctx->buf[1] != 'B' ||\n<19> parse_ctx->buf[2] != 'C' ||\n<21> parse_ctx->buf[3] != 'D')\n<27> next_pu_offset = (parse_ctx->buf[5] << 24) +\n<29> (parse_ctx->buf[6] << 16) +\n<31> (parse_ctx->buf[7] <<  8) +\n<39> SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE(parse_ctx->buf[4]))\n<51> in_buf = av_malloc(next_pu_offset);\n<53> if (!in_buf) {\n<63> memcpy(in_buf, parse_ctx->buf, next_pu_offset);\n<65> enc_buf       = schro_buffer_new_with_data(in_buf, next_pu_offset);\n<73> parse_ctx->buf      += next_pu_offset;
<1> static int scaling_list_data(HEVCContext *s, ScalingList *sl)\n<33> if (matrix_id - delta < 0) {\n<99> sl->sl[size_id][matrix_id][pos] = next_coef;
<1> static int nfs_parse_uri(const char *filename, QDict *options, Error **errp)\n<15> if (!uri) {\n<23> if (strcmp(uri->scheme, "nfs") != 0) {\n<25> error_setg(errp, "URI scheme must be 'nfs'");\n<33> if (!uri->server) {\n<73> for (i = 0; i < qp->n; i++) {\n<85> if (parse_uint_full(qp->p[i].value, NULL, 0)) {\n<95> if (!strcmp(qp->p[i].name, "uid")) {\n<99> qstring_from_str(qp->p[i].value));\n<101> } else if (!strcmp(qp->p[i].name, "gid")) {\n<105> qstring_from_str(qp->p[i].value));\n<107> } else if (!strcmp(qp->p[i].name, "tcp-syncnt")) {\n<111> qstring_from_str(qp->p[i].value));\n<113> } else if (!strcmp(qp->p[i].name, "readahead")) {\n<117> qstring_from_str(qp->p[i].value));\n<119> } else if (!strcmp(qp->p[i].name, "pagecache")) {\n<123> qstring_from_str(qp->p[i].value));\n<125> } else if (!strcmp(qp->p[i].name, "debug")) {\n<129> qstring_from_str(qp->p[i].value));\n<133> error_setg(errp, "Unknown NFS parameter name: %s",\n<135> qp->p[i].name);\n<155> uri_free(uri);
<1> int _WriteTTFFont ( FILE * ttf , SplineFont * sf , enum fontformat format , int32 * bsizes , enum bitmapformat bf , int flags , EncMap * map , int layer ) {\n<43> memset ( & at , '\0' , sizeof ( struct alltabs ) ) ;\n<44> ATinit ( & at , sf , map , flags , layer , format , bf , bsizes ) ;\n<46> dumpcff ( & at , sf , format , ttf ) ;\n<49> if ( initTables ( & at , sf , format , bsizes , bf ) ) dumpttf ( ttf , & at ) ;\n<52> if ( at . error || ferror ( ttf ) ) return ( 0 ) ;
<1> int chk_data_link ( MI_CHECK * param , MI_INFO * info , int extend ) {\n<183> if ( param -> testflag & T_WRITE_LOOP && records % WRITE_COUNT == 0 ) {\n<184> printf ( "%s\r" , llstr ( records , llbuff ) ) ;\n<251> if ( param -> testflag & T_INFO ) {\n<253> if ( used != 0 && ! param -> error_printed ) {\n<254> printf ( "Records:%18s M.recordlength:%9lu Packed:%14.0f%%\n" , llstr ( records , llbuff ) , ( long ) ( ( used - link_used ) / records ) , ( info -> s -> base . blobs ? 0.0 : ( ulonglong2double ( ( ulonglong ) info -> s -> base . reclength * records ) - my_off_t2double ( used ) ) / ulonglong2double ( ( ulonglong ) info -> s -> base . reclength * records ) * 100.0 ) ) ;\n<255> printf ( "Recordspace used:%9.0f%% Empty space:%12d%% Blocks/Record: %6.2f\n" , ( ulonglong2double ( used - link_used ) / ulonglong2double ( used - link_used + empty ) * 100.0 ) , ( ! records ? 100 : ( int ) ( ulonglong2double ( del_length + empty ) / my_off_t2double ( used ) * 100.0 ) ) , ulonglong2double ( splits - del_blocks ) / records ) ;\n<257> printf ( "Record blocks:%12s Delete blocks:%10s\n" , llstr ( splits - del_blocks , llbuff ) , llstr ( del_blocks , llbuff2 ) ) ;\n<258> printf ( "Record data: %12s Deleted data: %10s\n" , llstr ( used - link_used , llbuff ) , llstr ( del_length , llbuff2 ) ) ;\n<259> printf ( "Lost space: %12s Linkdata: %10s\n" , llstr ( empty , llbuff ) , llstr ( link_used , llbuff2 ) ) ;
<1> static afs_int32 removeFromGroup ( struct rx_call * call , afs_int32 aid , afs_int32 gid , afs_int32 * cid ) {\n<11> if ( code ) return code ;\n<22> memset ( & uentry , 0 , sizeof ( uentry ) ) ;\n<23> memset ( & gentry , 0 , sizeof ( gentry ) ) ;\n<24> code = pr_ReadEntry ( tt , 0 , tempu , & uentry ) ;\n<26> code = pr_ReadEntry ( tt , 0 , tempg , & gentry ) ;\n<28> if ( ! ( gentry . flags & PRGRP ) ) ABORT_WITH ( tt , PRNOTGROUP ) ;
<1> static void test_bug4172 ( ) {\n<14> stmt = mysql_stmt_init ( mysql ) ;\n<15> stmt_text = "SELECT f, d, e FROM t1" ;\n<16> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<17> check_execute ( stmt , rc ) ;\n<20> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<33> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<37> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<39> res = mysql_store_result ( mysql ) ;\n<40> row = mysql_fetch_row ( res ) ;\n<41> if ( ! opt_silent ) {\n<42> printf ( "Binary protocol: float=%s, double=%s, decimal(10,4)=%s\n" , f , d , e ) ;\n<43> printf ( "Text protocol: float=%s, double=%s, decimal(10,4)=%s\n" , row [ 0 ] , row [ 1 ] , row [ 2 ] ) ;\n<45> DIE_UNLESS ( ! strcmp ( f , row [ 0 ] ) && ! strcmp ( d , row [ 1 ] ) && ! strcmp ( e , row [ 2 ] ) ) ;
<1> static int ivi_process_empty_tile ( AVCodecContext * avctx , IVIBandDesc * band , IVITile * tile , int32_t mv_scale ) {\n<77> src = band -> ref_buf + tile -> ypos * band -> pitch + tile -> xpos ;\n<78> dst = band -> buf + tile -> ypos * band -> pitch + tile -> xpos ;\n<80> y < tile -> height ;\n<82> memcpy ( dst , src , tile -> width * sizeof ( band -> buf [ 0 ] ) ) ;\n<83> src += band -> pitch ;\n<84> dst += band -> pitch ;
<1> static bool equivalent_locale ( int category , const char * loca , const char * locb ) {\n<8> if ( pg_strcasecmp ( loca , locb ) == 0 ) return true ;\n<10> chara = strrchr ( canona , '.' ) ;\n<11> lena = chara ? ( chara - canona ) : strlen ( canona ) ;\n<13> charb = strrchr ( canonb , '.' ) ;\n<14> lenb = charb ? ( charb - canonb ) : strlen ( canonb ) ;\n<15> if ( lena == lenb && pg_strncasecmp ( canona , canonb , lena ) == 0 ) {\n<16> pg_free ( canona ) ;\n<17> pg_free ( canonb ) ;\n<20> pg_free ( canona ) ;\n<21> pg_free ( canonb ) ;
<1> void free_sums ( struct sum_struct * s ) {\n<2> if ( s -> sums ) free ( s -> sums ) ;\n<3> free ( s ) ;
<1> int cpu_ppc_register_internal (CPUPPCState *env, const ppc_def_t *def)\n<18> fprintf(stderr, "Unable to emulate selected CPU with TCG\n");
<1> static subpicture_t * ParseText ( decoder_t * p_dec , block_t * p_block ) {\n<9> if ( p_block -> i_buffer < 1 ) {\n<13> psz_subtitle = malloc ( p_block -> i_buffer + 1 ) ;\n<14> if ( psz_subtitle == NULL ) return NULL ;\n<15> memcpy ( psz_subtitle , p_block -> p_buffer , p_block -> i_buffer ) ;\n<16> psz_subtitle [ p_block -> i_buffer ] = '\0' ;\n<18> if ( EnsureUTF8 ( psz_subtitle ) == NULL ) {\n<24> if ( IsUTF8 ( psz_subtitle ) == NULL ) {\n<29> if ( ! p_sys -> b_autodetect_utf8 ) {\n<30> size_t inbytes_left = strlen ( psz_subtitle ) ;\n<31> size_t outbytes_left = 6 * inbytes_left ;\n<32> char * psz_new_subtitle = xmalloc ( outbytes_left + 1 ) ;\n<34> const char * psz_convert_buffer_in = psz_subtitle ;\n<37> free ( psz_subtitle ) ;\n<38> if ( ( ret == ( size_t ) ( - 1 ) ) || inbytes_left ) {\n<39> free ( psz_new_subtitle ) ;\n<43> psz_subtitle = realloc ( psz_new_subtitle , psz_convert_buffer_out - psz_new_subtitle ) ;\n<44> if ( ! psz_subtitle ) psz_subtitle = psz_new_subtitle ;\n<48> if ( ! p_spu ) {\n<49> free ( psz_subtitle ) ;\n<58> p_spu_sys -> text = StripTags ( psz_subtitle ) ;\n<59> if ( var_InheritBool ( p_dec , "subsdec-formatted" ) ) p_spu_sys -> html = CreateHtmlSubtitle ( & p_spu_sys -> align , psz_subtitle ) ;\n<60> free ( psz_subtitle ) ;
<1> void *rom_add_blob(const char *name, const void *blob, size_t len,\n<15> rom           = g_malloc0(sizeof(*rom));\n<25> rom->data     = g_malloc0(rom->datasize);\n<27> memcpy(rom->data, blob, len);\n<29> rom_insert(rom);\n<43> data = rom_set_mr(rom, OBJECT(fw_cfg), devpath);\n<47> data = rom->data;
<1> static void pk_transaction_authorize_actions_finished_cb ( GObject * source_object , GAsyncResult * res , struct AuthorizeActionsData * data ) {\n<3> PkTransactionPrivate * priv = data -> transaction -> priv ;\n<7> action_id = g_ptr_array_index ( data -> actions , 0 ) ;\n<26> if ( ! polkit_authorization_result_get_is_authorized ( result ) ) {\n<31> syslog ( LOG_AUTH | LOG_NOTICE , "uid %i failed to obtain auth" , priv -> uid ) ;\n<34> if ( data -> actions -> len <= 1 ) {\n<37> syslog ( LOG_AUTH | LOG_INFO , "uid %i obtained auth for %s" , priv -> uid , action_id ) ;
<1> static int rtp_packetize_t140 ( sout_stream_id_sys_t * id , block_t * in ) {\n<3> const uint8_t * p_data = in -> p_buffer ;\n<8> size_t i_payload = i_data ;\n<10> i_payload = i_max ;\n<11> while ( ( p_data [ i_payload ] & 0xC0 ) == 0x80 ) {\n<16> i_payload -- ;\n<20> if ( out == NULL ) {\n<24> rtp_packetize_common ( id , out , 0 , in -> i_pts + i_packet ) ;\n<25> memcpy ( out -> p_buffer + 12 , p_data , i_payload ) ;\n<29> p_data += i_payload ;\n<30> i_data -= i_payload ;
<1> static struct cgroup_process_info * lxc_cgroupfs_create ( const char * name , const char * path_pattern , struct cgroup_meta_data * meta_data , const char * sub_pattern ) {\n<4> char * path_so_far = NULL ;\n<13> unsigned suffix = 0 ;\n<16> if ( ! is_valid_cgroup ( name ) ) {\n<21> if ( ! strstr ( path_pattern , "%n" ) ) {\n<25> return NULL ;\n<27> base_info = ( path_pattern [ 0 ] == '/' ) ? lxc_cgroup_process_info_get_init ( meta_data ) : lxc_cgroup_process_info_get_self ( meta_data ) ;\n<28> if ( ! base_info ) return NULL ;\n<29> new_cgroup_paths = calloc ( meta_data -> maximum_hierarchy + 1 , sizeof ( char * ) ) ;\n<30> if ( ! new_cgroup_paths ) goto out_initial_error ;\n<31> new_cgroup_paths_sub = calloc ( meta_data -> maximum_hierarchy + 1 , sizeof ( char * ) ) ;\n<32> if ( ! new_cgroup_paths_sub ) goto out_initial_error ;\n<37> mp = lxc_cgroup_find_mount_point ( h , info_ptr -> cgroup_path , true ) ;\n<38> if ( ! mp ) {\n<44> if ( handle_cgroup_settings ( mp , info_ptr -> cgroup_path ) < 0 ) {\n<49> cgroup_path_components = lxc_normalize_path ( path_pattern ) ;\n<50> if ( ! cgroup_path_components ) goto out_initial_error ;\n<52> * p || ( sub_pattern && ! had_sub_pattern ) ;\n<54> char * p_eff = * p ? * p : ( char * ) sub_pattern ;\n<55> bool contains_name = strstr ( p_eff , "%n" ) ;\n<58> char * current_entire_path = NULL ;\n<68> j < i && info_ptr ;\n<70> r = remove_cgroup ( info_ptr -> designated_mount_point , info_ptr -> created_paths [ info_ptr -> created_paths_count - 1 ] , false ) ;\n<72> free ( info_ptr -> created_paths [ info_ptr -> created_paths_count - 1 ] ) ;\n<75> if ( current_component != current_subpath ) free ( current_subpath ) ;\n<76> if ( current_component != p_eff ) free ( current_component ) ;\n<78> ++ suffix ;\n<79> find_name_on_this_level : if ( contains_name && suffix > 0 ) {\n<80> char * buf = calloc ( strlen ( name ) + 32 , 1 ) ;\n<81> if ( ! buf ) goto out_initial_error ;\n<82> snprintf ( buf , strlen ( name ) + 32 , "%s-%u" , name , suffix ) ;\n<83> current_component = lxc_string_replace ( "%n" , buf , p_eff ) ;\n<84> free ( buf ) ;\n<87> current_component = contains_name ? lxc_string_replace ( "%n" , name , p_eff ) : p_eff ;\n<92> current_subpath = path_so_far ? lxc_string_join ( "/" , ( const char * * ) parts , false ) : current_component ;\n<93> for ( i = 0 , info_ptr = base_info ;\n<94> info_ptr ;\n<95> info_ptr = info_ptr -> next , i ++ ) {\n<97> if ( lxc_string_in_array ( "ns" , ( const char * * ) info_ptr -> hierarchy -> subsystems ) ) continue ;\n<99> parts2 [ 0 ] = ! strcmp ( info_ptr -> cgroup_path , "/" ) ? "" : info_ptr -> cgroup_path ;\n<102> current_entire_path = lxc_string_join ( "/" , ( const char * * ) parts2 , false ) ;\n<103> if ( ! * p ) {\n<104> free ( new_cgroup_paths_sub [ i ] ) ;\n<105> new_cgroup_paths_sub [ i ] = strdup ( current_entire_path ) ;\n<106> if ( ! new_cgroup_paths_sub [ i ] ) goto cleanup_from_error ;\n<109> free ( new_cgroup_paths [ i ] ) ;\n<110> new_cgroup_paths [ i ] = strdup ( current_entire_path ) ;\n<111> if ( ! new_cgroup_paths [ i ] ) goto cleanup_from_error ;\n<113> r = create_cgroup ( info_ptr -> designated_mount_point , current_entire_path ) ;\n<114> if ( r < 0 && errno == EEXIST && contains_name ) {\n<115> free ( current_entire_path ) ;\n<116> current_entire_path = NULL ;\n<119> else if ( r < 0 && errno != EEXIST ) {\n<120> SYSERROR ( "Could not create cgroup '%s' in '%s'." , current_entire_path , info_ptr -> designated_mount_point -> mount_point ) ;\n<125> if ( r < 0 ) goto cleanup_from_error ;\n<126> if ( ! init_cpuset_if_needed ( info_ptr -> designated_mount_point , current_entire_path ) ) {\n<127> ERROR ( "Failed to initialize cpuset for '%s' in '%s'." , current_entire_path , info_ptr -> designated_mount_point -> mount_point ) ;\n<133> if ( handle_cgroup_settings ( info_ptr -> designated_mount_point , info_ptr -> cgroup_path ) < 0 ) {\n<137> if ( ! init_cpuset_if_needed ( info_ptr -> designated_mount_point , info_ptr -> cgroup_path ) ) {\n<141> free ( current_entire_path ) ;\n<142> current_entire_path = NULL ;\n<145> free ( path_so_far ) ;\n<146> path_so_far = strdup ( current_subpath ) ;\n<147> if ( ! path_so_far ) goto cleanup_from_error ;\n<148> if ( current_component != current_subpath ) free ( current_subpath ) ;\n<149> if ( current_component != p_eff ) free ( current_component ) ;\n<153> if ( current_component != current_subpath ) free ( current_subpath ) ;\n<154> if ( current_component != p_eff ) free ( current_component ) ;\n<155> free ( current_entire_path ) ;\n<159> for ( i = 0 , info_ptr = base_info ;\n<161> info_ptr = info_ptr -> next , i ++ ) {\n<162> if ( lxc_string_in_array ( "ns" , ( const char * * ) info_ptr -> hierarchy -> subsystems ) ) continue ;\n<163> free ( info_ptr -> cgroup_path ) ;\n<164> info_ptr -> cgroup_path = new_cgroup_paths [ i ] ;\n<167> free ( new_cgroup_paths ) ;\n<168> free ( new_cgroup_paths_sub ) ;\n<169> free ( path_so_far ) ;\n<173> free ( path_so_far ) ;
<1> static void req_nonce ( struct recvbuf * rbufp , int restrict_mask ) {\n<3> generate_nonce ( rbufp , buf , sizeof ( buf ) ) ;\n<4> ctl_putunqstr ( "nonce" , buf , strlen ( buf ) ) ;
<11> G2MContext *c = avctx->priv_data;\n<225> if (g2m_init_buffers(c)) {\n<343> g2m_load_cursor(avctx, c, &tbc);\n<375> if (c->width && c->height && c->framebuf) {\n<389> for (i = 0; i < avctx->height; i++)\n<391> memcpy(pic->data[0] + i * pic->linesize[0],\n<393> c->framebuf + i * c->framebuf_stride,\n<395> c->width * 3);
<1> static void parse_new_commit ( const char * arg ) {\n<4> char * author = NULL ;\n<15> author = parse_ident ( v ) ;\n<26> merge_list = parse_merge ( & merge_count ) ;\n<33> if ( skip_prefix ( command_buf . buf , "M " , & v ) ) file_change_m ( v , b ) ;\n<37> else if ( skip_prefix ( command_buf . buf , "N " , & v ) ) note_change_n ( v , b , & prev_fanout ) ;\n<38> else if ( ! strcmp ( "deleteall" , command_buf . buf ) ) file_change_deleteall ( b ) ;\n<39> else if ( skip_prefix ( command_buf . buf , "ls " , & v ) ) parse_ls ( v , b ) ;\n<44> if ( read_next_command ( ) == EOF ) break ;\n<53> while ( merge_list ) {\n<55> strbuf_addf ( & new_data , "parent %s\n" , sha1_to_hex ( merge_list -> sha1 ) ) ;\n<56> free ( merge_list ) ;\n<57> merge_list = next ;\n<59> strbuf_addf ( & new_data , "author %s\n" "committer %s\n" "\n" , author ? author : committer , committer ) ;\n<61> free ( author ) ;\n<62> free ( committer ) ;
<1> static void decode_pitch_vector ( AMRContext * p , const AMRNBSubframe * amr_subframe , const int subframe ) {\n<11> ff_acelp_interpolatef ( p -> excitation , p -> excitation + 1 - pitch_lag_int , ff_b60_sinc , 6 , pitch_lag_frac + 6 - 6 * ( pitch_lag_frac > 0 ) , 10 , AMR_SUBFRAME_SIZE ) ;\n<12> memcpy ( p -> pitch_vector , p -> excitation , AMR_SUBFRAME_SIZE * sizeof ( float ) ) ;
<1> int avfilter_graph_queue_command(AVFilterGraph *graph, const char *target, const char *command, const char *arg, int flags, double ts)\n<6> for (i = 0; i < graph->nb_filters; i++) {\n<7> AVFilterContext *filter = graph->filters[i];\n<8> if(filter && (!strcmp(target, "all") || !strcmp(target, filter->name) || !strcmp(target, filter->filter->name))){\n<9> AVFilterCommand **queue = &filter->command_queue, *next;\n<10> while (*queue && (*queue)->time <= ts)\n<12> next = *queue;\n<13> *queue = av_mallocz(sizeof(AVFilterCommand));\n<14> (*queue)->command = av_strdup(command);\n<15> (*queue)->arg     = av_strdup(arg);\n<16> (*queue)->time    = ts;\n<17> (*queue)->flags   = flags;\n<18> (*queue)->next    = next;\n<19> if(flags & AVFILTER_CMD_FLAG_ONE)
<1> static DriveInfo *blockdev_init(const char *file, QDict *bs_opts,\n<157> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<175> if (!drv) {\n<189> memset(&cfg, 0, sizeof(cfg));\n<247> if (!check_throttle_config(&cfg, &error)) {\n<369> if (throttle_enabled(&cfg)) {\n<373> bdrv_set_io_limits(dinfo->bdrv, &cfg);
<1> static int multiwrite_f(BlockDriverState *bs, int argc, char **argv)\n<33> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<81> for (i = optind; i < argc; i++) {\n<83> if (!strcmp(argv[i], ";")) {\n<85> nr_reqs++;\n<109> offset = cvtnum(argv[optind]);\n<111> if (offset < 0) {\n<113> printf("non-numeric offset argument -- %s\n", argv[optind]);\n<123> if (offset & 0x1ff) {\n<145> for (j = optind; j < argc; j++) {\n<147> if (!strcmp(argv[j], ";")) {\n<163> buf[i] = create_iovec(bs, &qiovs[i], &argv[optind], nr_iov, pattern);\n<205> if (cnt < 0) {\n<207> printf("aio_multiwrite failed: %s\n", strerror(-cnt));
<1> static void ehci_execute_complete(EHCIQueue *q)\n<9> assert(p != NULL);\n<25> if (p->usb_status < 0) {\n<27> switch (p->usb_status) {\n<67> fprintf(stderr, "USB invalid response %d\n", p->usb_status);\n<107> ehci_finish_transfer(q, p->usb_status);
<1> static int findcmd ( const char * str , struct xcmd * clist1 , struct xcmd * clist2 , struct xcmd * * cmd ) {\n<7> clen = strlen ( str ) ;\n<16> if ( strncmp ( str , cl -> keyword , ( unsigned ) clen ) == 0 ) {
<1> static CURLcode dict_do ( struct connectdata * conn , bool * done ) {\n<16> if ( Curl_raw_nequal ( path , DICT_MATCH , sizeof ( DICT_MATCH ) - 1 ) || Curl_raw_nequal ( path , DICT_MATCH2 , sizeof ( DICT_MATCH2 ) - 1 ) || Curl_raw_nequal ( path , DICT_MATCH3 , sizeof ( DICT_MATCH3 ) - 1 ) ) {\n<17> word = strchr ( path , ':' ) ;\n<18> if ( word ) {\n<19> word ++ ;\n<20> database = strchr ( word , ':' ) ;\n<21> if ( database ) {\n<22> * database ++ = ( char ) 0 ;\n<23> strategy = strchr ( database , ':' ) ;\n<24> if ( strategy ) {\n<25> * strategy ++ = ( char ) 0 ;\n<26> nthdef = strchr ( strategy , ':' ) ;\n<33> if ( ( word == NULL ) || ( * word == ( char ) 0 ) ) {\n<37> if ( ( database == NULL ) || ( * database == ( char ) 0 ) ) {\n<40> if ( ( strategy == NULL ) || ( * strategy == ( char ) 0 ) ) {\n<44> if ( ! eword ) return CURLE_OUT_OF_MEMORY ;\n<46> free ( eword ) ;\n<53> else if ( Curl_raw_nequal ( path , DICT_DEFINE , sizeof ( DICT_DEFINE ) - 1 ) || Curl_raw_nequal ( path , DICT_DEFINE2 , sizeof ( DICT_DEFINE2 ) - 1 ) || Curl_raw_nequal ( path , DICT_DEFINE3 , sizeof ( DICT_DEFINE3 ) - 1 ) ) {\n<54> word = strchr ( path , ':' ) ;\n<55> if ( word ) {\n<56> word ++ ;\n<57> database = strchr ( word , ':' ) ;\n<58> if ( database ) {\n<59> * database ++ = ( char ) 0 ;\n<60> nthdef = strchr ( database , ':' ) ;\n<66> if ( ( word == NULL ) || ( * word == ( char ) 0 ) ) {\n<70> if ( ( database == NULL ) || ( * database == ( char ) 0 ) ) {\n<74> if ( ! eword ) return CURLE_OUT_OF_MEMORY ;\n<76> free ( eword ) ;\n<84> ppath = strchr ( path , '/' ) ;\n<87> ppath ++ ;
<1> static int http_connect(URLContext *h, const char *path, const char *hoststr,\n<3> const char *auth, int *new_location)\n<7> HTTPContext *s = h->priv_data;\n<15> int auth_b64_len = strlen(auth)* 4 / 3 + 12;\n<25> post = h->flags & URL_WRONLY;\n<27> auth_b64 = av_malloc(auth_b64_len);\n<29> av_base64_encode(auth_b64, auth_b64_len, auth, strlen(auth));\n<65> if (http_write(h, s->buffer, strlen(s->buffer)) < 0)\n<67> return AVERROR(EIO);\n<73> s->buf_ptr = s->buffer;\n<75> s->buf_end = s->buffer;\n<77> s->line_count = 0;\n<79> s->off = 0;\n<81> s->filesize = -1;\n<83> if (post) {\n<97> ch = http_getc(s);\n<119> err = process_line(h, line, s->line_count, new_location);
<1> void ArchiveEntry ( Archive * AHX , CatalogId catalogId , DumpId dumpId , const char * tag , const char * namespace , const char * tablespace , const char * owner , bool withOids , const char * desc , teSection section , const char * defn , const char * dropStmt , const char * copyStmt , const DumpId * deps , int nDeps , DataDumperPtr dumpFn , void * dumpArg ) {\n<4> newToc = ( TocEntry * ) pg_malloc0 ( sizeof ( TocEntry ) ) ;\n<7> newToc -> prev = AH -> toc -> prev ;\n<8> newToc -> next = AH -> toc ;\n<23> if ( nDeps > 0 ) {\n<24> newToc -> dependencies = ( DumpId * ) pg_malloc ( nDeps * sizeof ( DumpId ) ) ;\n<25> memcpy ( newToc -> dependencies , deps , nDeps * sizeof ( DumpId ) ) ;\n<36> if ( AH -> ArchiveEntryPtr != NULL ) ( * AH -> ArchiveEntryPtr ) ( AH , newToc ) ;
<1> tm_task_id new_task ( char * jobid , tm_node_id node , tm_task_id task ) {\n<3> TM_DBPRT ( ( "%s: jobid=%s node=%d task=%lu\n" , __func__ , jobid , node , ( unsigned long ) task ) ) if ( jobid != tm_jobid && strcmp ( jobid , tm_jobid ) != 0 ) {\n<4> TM_DBPRT ( ( "%s: task job %s not my job %s\n" , __func__ , jobid , tm_jobid ) ) return TM_NULL_TASK ;\n<6> if ( node == TM_ERROR_NODE ) {\n<9> if ( ( tp = find_task ( task ) ) != NULL ) {\n<12> if ( ( tp = ( task_info * ) calloc ( 1 , sizeof ( task_info ) ) ) == NULL ) return TM_NULL_TASK ;\n<13> head = & task_hash [ task % TASK_HASH ] ;\n<14> tp -> t_jobid = tm_jobid ;\n<15> tp -> t_task = task ;\n<16> tp -> t_node = node ;\n<17> tp -> t_next = * head ;\n<18> * head = tp ;\n<19> return task ;
<1> static int connect_namedsocket(const char *path)\n<13> if (sockfd < 0) {\n<15> fprintf(stderr, "socket %s\n", strerror(errno));\n<21> strcpy(helper.sun_path, path);\n<25> size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n<27> if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n<29> fprintf(stderr, "socket error\n");
<1> int qemuMonitorTextDiskSnapshot ( qemuMonitorPtr mon , const char * device , const char * file ) {\n<3> char * reply = NULL ;\n<10> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) ) {\n<14> if ( strstr ( reply , "error while creating qcow2" ) != NULL || strstr ( reply , "unknown command:" ) != NULL ) {\n<15> qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( "Failed to take snapshot: %s" ) , reply ) ;\n<18> ret = 0 ;\n<21> VIR_FREE ( reply ) ;
<1> static void virtio_net_get_config ( VirtIODevice * vdev , uint8_t * config ) {\n<2> VirtIONet * n = to_virtio_net ( vdev ) ;\n<5> memcpy ( netcfg . mac , n -> mac , ETH_ALEN ) ;\n<6> memcpy ( config , & netcfg , sizeof ( netcfg ) ) ;
<1> PXA2xxLCDState *pxa2xx_lcdc_init(MemoryRegion *sysmem,\n<41> switch (ds_get_bits_per_pixel(s->ds)) {\n<101> fprintf(stderr, "%s: Bad color depth\n", __FUNCTION__);
<1> static void test_bug54041_impl ( ) {\n<14> memset ( & bind , 0 , sizeof ( bind ) ) ;\n<16> rc = mysql_stmt_bind_param ( stmt , & bind ) ;
<1> static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)\n<5> const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n<23> descr = "VideoHandler";\n<29> descr = "SoundHandler";\n<37> descr = "SubtitleHandler";\n<43> descr = "HintHandler";\n<69> avio_wb32(pb ,0); /* reserved */\n<71> if (!track || track->mode == MODE_MOV)\n<73> avio_w8(pb, strlen(descr)); /* pascal string */\n<75> avio_write(pb, descr, strlen(descr)); /* handler description */\n<79> avio_w8(pb, 0); /* c string */\n<81> return update_size(pb, pos);
<1> static int reply_parse ( u8 * packet , int length ) {\n<21> if ( ! req ) return - 1 ;\n<22> memset ( & reply , 0 , sizeof ( reply ) ) ;
<1> static void test_evbuffer ( void ) {\n<5> if ( EVBUFFER_LENGTH ( evb ) == 7 && strcmp ( ( char * ) EVBUFFER_DATA ( evb ) , "hello/1" ) == 0 ) test_ok = 1 ;
<1> static void csrhci_reset(struct csrhci_s *s)\n<29> memset(&s->bd_addr, 0, sizeof(bdaddr_t));
<1> static int processCompressOptions ( char * opt ) {\n<4> else if ( strneq ( opt , "jpeg" , 4 ) ) {\n<5> char * cp = strchr ( opt , ':' ) ;\n<7> while ( cp ) {\n<8> if ( isdigit ( ( int ) cp [ 1 ] ) ) quality = atoi ( cp + 1 ) ;\n<9> else if ( cp [ 1 ] == 'r' ) jpegcolormode = JPEGCOLORMODE_RAW ;\n<11> cp = strchr ( cp + 1 , ':' ) ;\n<14> else if ( strneq ( opt , "lzw" , 3 ) ) {\n<15> char * cp = strchr ( opt , ':' ) ;\n<16> if ( cp ) predictor = atoi ( cp + 1 ) ;\n<19> else if ( strneq ( opt , "zip" , 3 ) ) {\n<20> char * cp = strchr ( opt , ':' ) ;\n<21> if ( cp ) predictor = atoi ( cp + 1 ) ;
<1> static int http_prepare_data(HTTPContext *c)\n<9> switch(c->state) {\n<13> memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));\n<27> st = av_mallocz(sizeof(AVStream));\n<31> if (c->stream->feed == c->stream)\n<33> memcpy(st, c->stream->streams[i], sizeof(AVStream));\n<37> memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream));\n<57> for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n<61> st = av_mallocz(sizeof(AVStream));\n<65> memcpy(st, c->fmt_in->streams[i], sizeof(AVStream));\n<85> av_write_header(&c->fmt_ctx);
<1> int unix_listen_opts(QemuOpts *opts, Error **errp)\n<7> const char *path = qemu_opt_get(opts, "path");\n<15> if (sock < 0) {\n<25> memset(&un, 0, sizeof(un));\n<29> if (path && strlen(path)) {\n<31> snprintf(un.sun_path, sizeof(un.sun_path), "%s", path);\n<35> const char *tmpdir = getenv("TMPDIR");\n<37> tmpdir = tmpdir ? tmpdir : "/tmp";\n<39> if (snprintf(un.sun_path, sizeof(un.sun_path), "%s/qemu-socket-XXXXXX",\n<41> tmpdir) >= sizeof(un.sun_path)) {\n<87> if ((access(un.sun_path, F_OK) == 0) &&\n<99> if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {
<1> static void test_registerfds ( void ) {\n<7> fprintf ( stdout , "Testing register fds: " ) ;\n<34> fprintf ( stdout , "OK\n" ) ;
<1> static void usb_serial_read(void *opaque, const uint8_t *buf, int size)\n<5> USBSerialState *s = opaque;\n<7> int first_size = RECV_BUF - s->recv_ptr;\n<9> if (first_size > size)\n<11> first_size = size;\n<13> memcpy(s->recv_buf + s->recv_ptr + s->recv_used, buf, first_size);\n<15> if (size > first_size)\n<17> memcpy(s->recv_buf, buf + first_size, size - first_size);
<1> void try_outgoing_connections ( void ) {\n<9> get_config_string ( cfg , & name ) ;\n<10> if ( ! check_id ( name ) ) {\n<12> free ( name ) ;
<1> static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) {\n<2> if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , "GAB2" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) {\n<9> AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ;\n<17> avio_rl32 ( pb ) ;\n<18> size = pb -> buf_end - pb -> buf_ptr ;\n<22> if ( ! pd . buf ) goto error ;\n<23> memcpy ( pd . buf , pb -> buf_ptr , size ) ;\n<24> sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ;\n<25> av_freep ( & pd . buf ) ;\n<26> if ( ! sub_demuxer ) goto error ;\n<27> if ( strcmp ( sub_demuxer -> name , "srt" ) && strcmp ( sub_demuxer -> name , "ass" ) ) goto error ;\n<28> if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) goto error ;\n<29> ast -> sub_ctx -> pb = pb ;\n<31> if ( ! avformat_open_input ( & ast -> sub_ctx , "" , sub_demuxer , NULL ) ) {\n<32> if ( ast -> sub_ctx -> nb_streams != 1 ) goto error ;\n<38> ast -> sub_buffer = pkt -> data ;\n<39> memset ( pkt , 0 , sizeof ( * pkt ) ) ;\n<41> error : av_freep ( & ast -> sub_ctx ) ;\n<42> av_freep ( & pb ) ;\n<44> return 0 ;
<1> int alloc_picture(MpegEncContext *s, Picture *pic, int shared){\n<15> if(shared){\n<57> if(pic->linesize[1] != pic->linesize[2]){\n<145> memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);
<1> static int qemu_rdma_resolve_host(RDMAContext *rdma, Error **errp)\n<19> if (rdma->host == NULL || !strcmp(rdma->host, "")) {\n<21> ERROR(errp, "RDMA hostname has not been set");\n<23> return -1;\n<31> rdma->channel = rdma_create_event_channel();\n<33> if (!rdma->channel) {\n<63> ret = getaddrinfo(rdma->host, port_str, NULL, &res);
<1> static void test_bug11183 ( ) {\n<4> char bug_statement [ ] = "insert into t1 values (1)" ;\n<10> rc = mysql_stmt_prepare ( stmt , bug_statement , strlen ( bug_statement ) ) ;
<1> int jbig2_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n<16> if ( segment -> data_length < 17 ) goto too_short ;\n<22> memset ( & params , 0 , sizeof ( Jbig2TextRegionParams ) ) ;\n<247> GR_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n<248> if ( GR_stats == NULL ) {\n<252> memset ( GR_stats , 0 , stats_size ) ;\n<300> code = jbig2_decode_text_region ( ctx , segment , & params , ( const Jbig2SymbolDict * const * ) dicts , n_dicts , image , segment_data + offset , segment -> data_length - offset , GR_stats , as , ws ) ;\n<312> cleanup4 : if ( ! params . SBHUFF ) {\n<313> jbig2_arith_iaid_ctx_free ( ctx , params . IAID ) ;\n<314> jbig2_arith_int_ctx_free ( ctx , params . IARI ) ;\n<315> jbig2_arith_int_ctx_free ( ctx , params . IARDW ) ;\n<316> jbig2_arith_int_ctx_free ( ctx , params . IARDH ) ;\n<317> jbig2_arith_int_ctx_free ( ctx , params . IARDX ) ;\n<318> jbig2_arith_int_ctx_free ( ctx , params . IARDY ) ;\n<320> cleanup3 : if ( ! params . SBHUFF ) {\n<321> jbig2_arith_int_ctx_free ( ctx , params . IADT ) ;\n<322> jbig2_arith_int_ctx_free ( ctx , params . IAFS ) ;\n<323> jbig2_arith_int_ctx_free ( ctx , params . IADS ) ;\n<324> jbig2_arith_int_ctx_free ( ctx , params . IAIT ) ;\n<328> cleanup2 : jbig2_free ( ctx -> allocator , GR_stats ) ;\n<331> jbig2_release_huffman_table ( ctx , params . SBHUFFFS ) ;\n<332> jbig2_release_huffman_table ( ctx , params . SBHUFFDS ) ;\n<333> jbig2_release_huffman_table ( ctx , params . SBHUFFDT ) ;\n<334> jbig2_release_huffman_table ( ctx , params . SBHUFFRDX ) ;\n<335> jbig2_release_huffman_table ( ctx , params . SBHUFFRDY ) ;\n<336> jbig2_release_huffman_table ( ctx , params . SBHUFFRDW ) ;\n<337> jbig2_release_huffman_table ( ctx , params . SBHUFFRDH ) ;\n<338> jbig2_release_huffman_table ( ctx , params . SBHUFFRSIZE ) ;
<1> static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],\n<19> int w = width  >> (is_chroma ? p->hsub : 0);\n<29> if (!src[i] || !dst[i])\n<33> for (y = 0; y < h; y++) {\n<35> int index = block + block * stride + y * stride;\n<39> memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );\n<43> p->src[i][index     - x - 1] = p->src[i][index +     x    ];\n<45> p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];\n<51> for (y = 0; y < block; y++) {\n<53> memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);\n<55> memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);\n<61> p->frame->linesize[i] = stride;\n<63> memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));
<1> static void tpm_display_backend_drivers(void)\n<9> fprintf(stderr, "Supported TPM types (choose only one):\n");\n<13> for (i = 0; i < TPM_MAX_DRIVERS && be_drivers[i] != NULL; i++) {\n<21> fprintf(stderr, "\n");
<1> static void test_bug10794 ( ) {\n<4> char a [ 21 ] ;\n<14> stmt = mysql_stmt_init ( mysql ) ;\n<15> stmt_text = "insert into t1 (id, name) values (?, ?)" ;\n<16> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<17> check_execute ( stmt , rc ) ;\n<18> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<25> check_execute ( stmt , rc ) ;\n<27> i < 42 ;\n<28> i ++ ) {\n<30> sprintf ( a , "a%d" , i ) ;\n<31> a_len = strlen ( a ) ;\n<33> check_execute ( stmt , rc ) ;\n<35> stmt_text = "select name from t1" ;\n<36> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<38> mysql_stmt_attr_set ( stmt , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;\n<40> mysql_stmt_attr_set ( stmt1 , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;\n<41> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<43> my_bind [ 0 ] . buffer = ( void * ) a ;\n<45> my_bind [ 0 ] . length = & a_len ;\n<46> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<52> if ( ! opt_silent ) printf ( "Fetched row from stmt: %s\n" , a ) ;\n<55> stmt_text = "select name from t1 where id=10" ;\n<56> rc = mysql_stmt_prepare ( stmt1 , stmt_text , strlen ( stmt_text ) ) ;\n<57> check_execute ( stmt1 , rc ) ;\n<64> if ( ! opt_silent ) printf ( "End of data in stmt1\n" ) ;\n<68> if ( ! opt_silent ) printf ( "Fetched row from stmt1: %s\n" , a ) ;
<1> static void dumpRoles ( PGconn * conn ) {\n<12> res = executeQuery ( conn , buf -> data ) ;\n<27> if ( PQntuples ( res ) > 0 ) fprintf ( OPF , "--\n-- Roles\n--\n\n" ) ;\n<35> if ( strncmp ( rolename , "pg_" , 3 ) == 0 ) {\n<36> fprintf ( stderr , _ ( "%s: role name starting with \"pg_\" skipped (%s)\n" ) , progname , rolename ) ;\n<39> resetPQExpBuffer ( buf ) ;\n<41> appendPQExpBufferStr ( buf , "\n-- For binary upgrade, must preserve pg_authid.oid\n" ) ;\n<48> if ( strcmp ( PQgetvalue ( res , i , i_rolsuper ) , "t" ) == 0 ) appendPQExpBufferStr ( buf , " SUPERUSER" ) ;\n<49> else appendPQExpBufferStr ( buf , " NOSUPERUSER" ) ;\n<50> if ( strcmp ( PQgetvalue ( res , i , i_rolinherit ) , "t" ) == 0 ) appendPQExpBufferStr ( buf , " INHERIT" ) ;\n<51> else appendPQExpBufferStr ( buf , " NOINHERIT" ) ;\n<52> if ( strcmp ( PQgetvalue ( res , i , i_rolcreaterole ) , "t" ) == 0 ) appendPQExpBufferStr ( buf , " CREATEROLE" ) ;\n<53> else appendPQExpBufferStr ( buf , " NOCREATEROLE" ) ;\n<54> if ( strcmp ( PQgetvalue ( res , i , i_rolcreatedb ) , "t" ) == 0 ) appendPQExpBufferStr ( buf , " CREATEDB" ) ;\n<55> else appendPQExpBufferStr ( buf , " NOCREATEDB" ) ;\n<56> if ( strcmp ( PQgetvalue ( res , i , i_rolcanlogin ) , "t" ) == 0 ) appendPQExpBufferStr ( buf , " LOGIN" ) ;\n<57> else appendPQExpBufferStr ( buf , " NOLOGIN" ) ;\n<58> if ( strcmp ( PQgetvalue ( res , i , i_rolreplication ) , "t" ) == 0 ) appendPQExpBufferStr ( buf , " REPLICATION" ) ;\n<59> else appendPQExpBufferStr ( buf , " NOREPLICATION" ) ;\n<60> if ( strcmp ( PQgetvalue ( res , i , i_rolbypassrls ) , "t" ) == 0 ) appendPQExpBufferStr ( buf , " BYPASSRLS" ) ;\n<61> else appendPQExpBufferStr ( buf , " NOBYPASSRLS" ) ;\n<62> if ( strcmp ( PQgetvalue ( res , i , i_rolconnlimit ) , "-1" ) != 0 ) appendPQExpBuffer ( buf , " CONNECTION LIMIT %s" , PQgetvalue ( res , i , i_rolconnlimit ) ) ;\n<64> appendPQExpBufferStr ( buf , " PASSWORD " ) ;\n<65> appendStringLiteralConn ( buf , PQgetvalue ( res , i , i_rolpassword ) , conn ) ;\n<67> if ( ! PQgetisnull ( res , i , i_rolvaliduntil ) ) appendPQExpBuffer ( buf , " VALID UNTIL '%s'" , PQgetvalue ( res , i , i_rolvaliduntil ) ) ;\n<76> if ( ! no_security_labels && server_version >= 90200 ) buildShSecLabels ( conn , "pg_authid" , auth_oid , buf , "ROLE" , rolename ) ;\n<77> fprintf ( OPF , "%s" , buf -> data ) ;\n<83> fprintf ( OPF , "\n\n" ) ;\n<84> destroyPQExpBuffer ( buf ) ;
<1> int setup_vpn_in_socket ( const sockaddr_t * sa ) {\n<13> if ( fcntl ( nfd , F_SETFL , flags | O_NONBLOCK ) < 0 ) {\n<15> logger ( LOG_ERR , "System call `%s' failed: %s" , "fcntl" , strerror ( errno ) ) ;
<1> static abi_ulong create_elf_tables(abi_ulong p, int argc, int envc,\n<65> k_platform = ELF_PLATFORM;\n<67> if (k_platform) {\n<69> size_t len = strlen(k_platform) + 1;\n<73> sp -= (len + n - 1) & ~(n - 1);\n<79> memcpy_to_target(sp, k_platform, len);\n<83> memcpy_to_target(sp, k_platform, len);
<1> static void test_derived ( ) {\n<18> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> int petite_inflate2x_1to9 ( char * buf , uint32_t minrva , uint32_t bufsz , struct cli_exe_section * sections , unsigned int sectcount , uint32_t Imagebase , uint32_t pep , int desc , int version , uint32_t ResRva , uint32_t ResSize ) {\n<2> char * adjbuf = buf - minrva ;\n<6> struct cli_exe_section * usects = NULL ;\n<20> if ( usects ) free ( usects ) ;\n<101> usects [ t ] . raw = ( t > 0 ) ? ( usects [ t - 1 ] . raw + usects [ t - 1 ] . rsz ) : 0 ;\n<103> if ( CLI_ISCONTAINED ( buf , bufsz , buf + usects [ t ] . raw , usects [ t ] . rsz ) ) {\n<104> memmove ( buf + usects [ t ] . raw , adjbuf + usects [ t ] . rva , usects [ t ] . rsz ) ;\n<117> if ( ! cli_rebuildpe ( buf , usects , j , Imagebase , enc_ep , ResRva , ResSize , desc ) ) {\n<119> free ( usects ) ;\n<122> free ( usects ) ;\n<129> if ( usects ) free ( usects ) ;\n<134> ddst = adjbuf + cli_readint32 ( packed + 8 ) - ( size - 1 ) * 4 ;\n<135> if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , size * 4 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , size * 4 ) ) {\n<136> if ( usects ) free ( usects ) ;\n<139> memmove ( ddst , ssrc , size * 4 ) ;\n<148> if ( usects ) free ( usects ) ;\n<154> if ( j >= 96 ) {\n<156> free ( usects ) ;\n<159> if ( ! ( tmpsct = cli_realloc ( usects , sizeof ( struct cli_exe_section ) * ( j + 1 ) ) ) ) {\n<160> if ( usects ) free ( usects ) ;\n<163> usects = ( struct cli_exe_section * ) tmpsct ;\n<185> if ( q == sectcount ) {\n<186> free ( usects ) ;\n<205> if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n<206> free ( usects ) ;\n<214> oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ;\n<215> if ( oob == - 1 ) {\n<216> free ( usects ) ;\n<220> if ( ! CLI_ISCONTAINED ( buf , bufsz , ssrc , 1 ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst , 1 ) ) {\n<221> free ( usects ) ;\n<231> if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n<232> free ( usects ) ;\n<236> if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n<237> free ( usects ) ;\n<246> if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n<247> free ( usects ) ;\n<262> if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n<263> free ( usects ) ;\n<267> if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n<268> free ( usects ) ;\n<275> if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n<276> free ( usects ) ;\n<280> if ( ( oob = doubledl ( & ssrc , & mydl , buf , bufsz ) ) == - 1 ) {\n<281> free ( usects ) ;\n<290> if ( ! CLI_ISCONTAINED ( buf , bufsz , ddst , backsize ) || ! CLI_ISCONTAINED ( buf , bufsz , ddst + backbytes , backsize ) ) {\n<291> free ( usects ) ;\n<295> * ddst = * ( ddst + backbytes ) ;
<1> static void add_warning ( Scanner * s , char * error ) {\n<3> s -> errors -> warning_messages = realloc ( s -> errors -> warning_messages , s -> errors -> warning_count * sizeof ( timelib_error_message ) ) ;\n<6> s -> errors -> warning_messages [ s -> errors -> warning_count - 1 ] . message = strdup ( error ) ;
<1> static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n<13> DPRINTF("CURL: Just reading %zd bytes\n", realsize);\n<17> if (!s || !s->orig_buf)\n<28> memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n<30> s->buf_off += realsize;\n<64> return realsize;
<1> static gpgme_error_t uiserver_verify ( void * engine , gpgme_data_t sig , gpgme_data_t signed_text , gpgme_data_t plaintext ) {\n<7> if ( uiserver -> protocol == GPGME_PROTOCOL_DEFAULT ) protocol = "" ;\n<8> else if ( uiserver -> protocol == GPGME_PROTOCOL_OpenPGP ) protocol = " --protocol=OpenPGP" ;\n<9> else if ( uiserver -> protocol == GPGME_PROTOCOL_CMS ) protocol = " --protocol=CMS" ;\n<11> if ( asprintf ( & cmd , "VERIFY%s" , protocol ) < 0 ) return gpg_error_from_syserror ( ) ;\n<12> uiserver -> input_cb . data = sig ;\n<13> err = uiserver_set_fd ( uiserver , INPUT_FD , map_data_enc ( uiserver -> input_cb . data ) ) ;\n<14> if ( err ) {\n<15> free ( cmd ) ;\n<27> if ( ! err ) err = start ( uiserver , cmd ) ;\n<28> free ( cmd ) ;
<1> static int handle_cgroup_settings ( struct cgroup_mount_point * mp , char * cgroup_path ) {\n<7> if ( cc_path ) {\n<8> r = lxc_read_from_file ( cc_path , buf , 1 ) ;\n<10> r = lxc_write_to_file ( cc_path , "1" , 1 , false ) ;\n<14> free ( cc_path ) ;\n<21> if ( stat ( cc_path , & sb ) != 0 && errno == ENOENT ) {\n<23> free ( cc_path ) ;\n<26> r = lxc_read_from_file ( cc_path , buf , 1 ) ;\n<27> if ( r == 1 && buf [ 0 ] == '1' ) {\n<28> free ( cc_path ) ;\n<31> r = lxc_write_to_file ( cc_path , "1" , 1 , false ) ;\n<33> free ( cc_path ) ;
<1> static int cdxl_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> CDXLDemuxContext *cdxl = s->priv_data;\n<29> avio_read(pb, cdxl->header, CDXL_HEADER_SIZE) != CDXL_HEADER_SIZE)\n<33> if (cdxl->header[0] != 1) {\n<43> current_size = AV_RB32(&cdxl->header[2]);\n<45> width        = AV_RB16(&cdxl->header[14]);\n<47> height       = AV_RB16(&cdxl->header[16]);\n<49> palette_size = AV_RB16(&cdxl->header[20]);\n<51> audio_size   = AV_RB16(&cdxl->header[22]);\n<53> image_size   = FFALIGN(width, 16) * height * cdxl->header[19] / 8;\n<153> if (av_new_packet(pkt, video_size + CDXL_HEADER_SIZE) < 0)\n<157> memcpy(pkt->data, cdxl->header, CDXL_HEADER_SIZE);\n<159> ret = avio_read(pb, pkt->data + CDXL_HEADER_SIZE, video_size);\n<163> av_free_packet(pkt);\n<186> avio_skip(pb, current_size - audio_size - video_size - CDXL_HEADER_SIZE);
<1> int EVP_DecryptUpdate ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n<19> OPENSSL_assert ( b <= sizeof ctx -> final ) ;\n<20> if ( ctx -> final_used ) {\n<21> memcpy ( out , ctx -> final , b ) ;\n<22> out += b ;\n<26> if ( ! EVP_EncryptUpdate ( ctx , out , outl , in , inl ) ) return 0 ;\n<27> if ( b > 1 && ! ctx -> buf_len ) {\n<30> memcpy ( ctx -> final , & out [ * outl ] , b ) ;\n<33> if ( fix_len ) * outl += b ;
<1> static inline void qemu_assert(int cond, const char *msg)\n<5> if (!cond) {\n<7> fprintf (stderr, "badness: %s\n", msg);
<1> extern int main ( int argc , const char * argv [ ] ) {\n<7> uint16_t intValue = 2000 ;\n<13> if ( currdir != NULL ) {\n<14> free ( currdir ) ;\n<16> if ( U_FAILURE ( errorCode ) ) {\n<17> fprintf ( stderr , "Error: unable to create data memory, error %d\n" , errorCode ) ;\n<18> exit ( errorCode ) ;\n<20> printf ( "Writing uint16_t value of %d\n" , intValue ) ;\n<21> udata_write16 ( pData , intValue ) ;\n<22> printf ( "Writing string value of %s\n" , stringValue ) ;\n<24> dataLength = udata_finish ( pData , & errorCode ) ;\n<25> if ( U_FAILURE ( errorCode ) ) {\n<26> fprintf ( stderr , "Error: error %d writing the output file\n" , errorCode ) ;\n<27> exit ( errorCode ) ;\n<29> size = sizeof ( stringValue ) + sizeof ( intValue ) ;\n<30> if ( dataLength != ( long ) size ) {\n<31> fprintf ( stderr , "Error: data length %ld != calculated size %lu\n" , dataLength , size ) ;
<1> static int __tipc_nl_compat_doit ( struct tipc_nl_compat_cmd_doit * cmd , struct tipc_nl_compat_msg * msg ) {\n<19> if ( ! doit_buf ) {\n<24> memset ( & info , 0 , sizeof ( info ) ) ;\n<26> err = ( * cmd -> doit ) ( doit_buf , & info ) ;
<1> static void test_bug11901 ( ) {\n<5> stmt_text = "drop table if exists t1, t2" ;\n<6> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<8> stmt_text = "create table t1 (" " empno int(11) not null, firstname varchar(20) not null," " midinit varchar(20) not null, lastname varchar(20) not null," " workdept varchar(6) not null, salary double not null," " bonus float not null, primary key (empno), " " unique key (workdept, empno) " ") default charset=latin1 collate=latin1_bin" ;\n<9> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<11> stmt_text = "insert into t1 values " "(10, 'CHRISTINE', 'I', 'HAAS', 'A00', 52750, 1000)," "(20, 'MICHAEL', 'L', 'THOMPSON', 'B01', 41250, 800), " "(30, 'SALLY', 'A', 'KWAN', 'C01', 38250, 800), " "(50, 'JOHN', 'B', 'GEYER', 'E01', 40175, 800), " "(60, 'IRVING', 'F', 'STERN', 'D11', 32250, 500), " "(70, 'EVA', 'D', 'PULASKI', 'D21', 36170, 700), " "(90, 'EILEEN', 'W', 'HENDERSON', 'E11', 29750, 600), " "(100, 'THEODORE', 'Q', 'SPENSER', 'E21', 26150, 500), " "(110, 'VINCENZO', 'G', 'LUCCHESSI', 'A00', 46500, 900), " "(120, 'SEAN', '', 'O\\'CONNELL', 'A00', 29250, 600), " "(130, 'DOLORES', 'M', 'QUINTANA', 'C01', 23800, 500), " "(140, 'HEATHER', 'A', 'NICHOLLS', 'C01', 28420, 600), " "(150, 'BRUCE', '', 'ADAMSON', 'D11', 25280, 500), " "(160, 'ELIZABETH', 'R', 'PIANKA', 'D11', 22250, 400), " "(170, 'MASATOSHI', 'J', 'YOSHIMURA', 'D11', 24680, 500), " "(180, 'MARILYN', 'S', 'SCOUTTEN', 'D11', 21340, 500), " "(190, 'JAMES', 'H', 'WALKER', 'D11', 20450, 400), " "(200, 'DAVID', '', 'BROWN', 'D11', 27740, 600), " "(210, 'WILLIAM', 'T', 'JONES', 'D11', 18270, 400), " "(220, 'JENNIFER', 'K', 'LUTZ', 'D11', 29840, 600), " "(230, 'JAMES', 'J', 'JEFFERSON', 'D21', 22180, 400), " "(240, 'SALVATORE', 'M', 'MARINO', 'D21', 28760, 600), " "(250, 'DANIEL', 'S', 'SMITH', 'D21', 19180, 400), " "(260, 'SYBIL', 'P', 'JOHNSON', 'D21', 17250, 300), " "(270, 'MARIA', 'L', 'PEREZ', 'D21', 27380, 500), " "(280, 'ETHEL', 'R', 'SCHNEIDER', 'E11', 26250, 500), " "(290, 'JOHN', 'R', 'PARKER', 'E11', 15340, 300), " "(300, 'PHILIP', 'X', 'SMITH', 'E11', 17750, 400), " "(310, 'MAUDE', 'F', 'SETRIGHT', 'E11', 15900, 300), " "(320, 'RAMLAL', 'V', 'MEHTA', 'E21', 19950, 400), " "(330, 'WING', '', 'LEE', 'E21', 25370, 500), " "(340, 'JASON', 'R', 'GOUNOT', 'E21', 23840, 500)" ;\n<12> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<14> stmt_text = "create table t2 (" " deptno varchar(6) not null, deptname varchar(20) not null," " mgrno int(11) not null, location varchar(20) not null," " admrdept varchar(6) not null, refcntd int(11) not null," " refcntu int(11) not null, primary key (deptno)" ") default charset=latin1 collate=latin1_bin" ;\n<15> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<17> stmt_text = "insert into t2 values " "('A00', 'SPIFFY COMPUTER SERV', 10, '', 'A00', 0, 0), " "('B01', 'PLANNING', 20, '', 'A00', 0, 0), " "('C01', 'INFORMATION CENTER', 30, '', 'A00', 0, 0), " "('D01', 'DEVELOPMENT CENTER', 0, '', 'A00', 0, 0)," "('D11', 'MANUFACTURING SYSTEM', 60, '', 'D01', 0, 0), " "('D21', 'ADMINISTRATION SYSTE', 70, '', 'D01', 0, 0), " "('E01', 'SUPPORT SERVICES', 50, '', 'A00', 0, 0), " "('E11', 'OPERATIONS', 90, '', 'E01', 0, 0), " "('E21', 'SOFTWARE SUPPORT', 100,'', 'E01', 0, 0)" ;\n<18> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static int _setup_resv_limits ( slurmdb_reservation_rec_t * resv , char * * cols , char * * vals , char * * extra ) {\n<2> if ( resv -> assocs ) {\n<4> int len = strlen ( resv -> assocs ) - 1 ;\n<5> if ( strchr ( resv -> assocs , '-' ) ) {\n<6> int i = 0 , i2 = 0 ;\n<7> char * assocs = xmalloc ( sizeof ( char ) * len ) ;\n<8> while ( i < len ) {\n<19> xfree ( resv -> assocs ) ;\n<20> len = i2 - 1 ;\n<21> resv -> assocs = assocs ;\n<22> assocs = NULL ;\n<27> xstrfmtcat ( * vals , ", '%s'" , resv -> assocs + start ) ;\n<28> xstrfmtcat ( * extra , ", assoclist='%s'" , resv -> assocs + start ) ;
<1> static void usbredir_iso_packet(void *priv, uint64_t id,\n<5> uint8_t *data, int data_len)\n<21> if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_ISOC) {\n<25> free(data);\n<33> if (dev->endpoint[EP2I(ep)].iso_started == 0) {\n<37> free(data);
<1> int dtls1_retransmit_buffered_messages ( SSL * s ) {\n<12> if ( dtls1_retransmit_message ( s , ( unsigned short ) dtls1_get_queue_priority ( frag -> msg_header . seq , frag -> msg_header . is_ccs ) , 0 , & found ) <= 0 && found ) {\n<13> fprintf ( stderr , "dtls1_retransmit_message() failed\n" ) ;
<1> USBDevice *usb_host_device_open(USBBus *bus, const char *devname)\n<17> if (strstr(devname, "auto:")) {\n<19> if (parse_filter(devname, &filter) < 0) {\n<27> p = strchr(devname, '.');\n<29> if (p) {\n<31> filter.bus_num    = strtoul(devname, NULL, 0);\n<33> filter.addr       = strtoul(p + 1, NULL, 0);\n<41> p = strchr(devname, ':');\n<49> filter.vendor_id  = strtoul(devname, NULL, 16);\n<51> filter.product_id = strtoul(p + 1, NULL, 16);
<1> static inline void vmsvga_update_rect ( struct vmsvga_state_s * s , int x , int y , int w , int h ) {\n<9> if ( x < 0 ) {\n<10> fprintf ( stderr , "%s: update x was < 0 (%d)\n" , __func__ , x ) ;\n<11> w += x ;\n<12> x = 0 ;\n<14> if ( w < 0 ) {\n<15> fprintf ( stderr , "%s: update w was < 0 (%d)\n" , __func__ , w ) ;\n<16> w = 0 ;\n<18> if ( x + w > surface_width ( surface ) ) {\n<19> fprintf ( stderr , "%s: update width too large x: %d, w: %d\n" , __func__ , x , w ) ;\n<20> x = MIN ( x , surface_width ( surface ) ) ;\n<23> if ( y < 0 ) {\n<24> fprintf ( stderr , "%s: update y was < 0 (%d)\n" , __func__ , y ) ;\n<25> h += y ;\n<26> y = 0 ;\n<28> if ( h < 0 ) {\n<29> fprintf ( stderr , "%s: update h was < 0 (%d)\n" , __func__ , h ) ;\n<30> h = 0 ;\n<32> if ( y + h > surface_height ( surface ) ) {\n<33> fprintf ( stderr , "%s: update height too large y: %d, h: %d\n" , __func__ , y , h ) ;\n<34> y = MIN ( y , surface_height ( surface ) ) ;\n<38> width = surface_bytes_per_pixel ( surface ) * w ;\n<40> src = s -> vga . vram_ptr + start ;\n<41> dst = surface_data ( surface ) + start ;\n<43> line > 0 ;\n<44> line -- , src += bypl , dst += bypl ) {\n<45> memcpy ( dst , src , width ) ;
<1> void event_base_free ( struct event_base * base ) {\n<6> assert ( base ) ;\n<7> for ( ev = TAILQ_FIRST ( & base -> eventqueue ) ;\n<17> while ( ( ev = min_heap_top ( & base -> timeheap ) ) != NULL ) {\n<24> for ( ev = TAILQ_FIRST ( base -> activequeues [ i ] ) ;\n<36> if ( base -> evsel -> dealloc != NULL ) base -> evsel -> dealloc ( base , base -> evbase ) ;\n<39> ++ i ) assert ( TAILQ_EMPTY ( base -> activequeues [ i ] ) ) ;\n<40> assert ( min_heap_empty ( & base -> timeheap ) ) ;\n<43> i < base -> nactivequeues ;\n<44> ++ i ) free ( base -> activequeues [ i ] ) ;\n<45> free ( base -> activequeues ) ;\n<47> free ( base ) ;
<1> int qcow2_update_header(BlockDriverState *bs)\n<5> BDRVQcowState *s = bs->opaque;\n<25> buf = qemu_blockalign(bs, buflen);\n<103> switch (s->qcow_version) {\n<125> buf += ret;\n<127> buflen -= ret;\n<129> memset(buf, 0, buflen);\n<137> if (buflen < s->unknown_header_fields_size) {\n<147> memcpy(buf, s->unknown_header_fields, s->unknown_header_fields_size);\n<149> buf += s->unknown_header_fields_size;\n<151> buflen -= s->unknown_header_fields_size;\n<159> if (*bs->backing_format) {\n<161> ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT,\n<163> bs->backing_format, strlen(bs->backing_format),\n<193> ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n<243> buf += ret;\n<251> if (*bs->backing_file) {\n<253> size_t backing_file_len = strlen(bs->backing_file);\n<257> if (buflen < backing_file_len) {\n<267> strncpy(buf, bs->backing_file, buflen);\n<271> header->backing_file_offset = cpu_to_be64(buf - ((char*) header));
<1> static int mss2_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> MSS12Context * c = & ctx -> c ;\n<86> if ( ( i = decode_pal_v2 ( c , buf , buf_size ) ) < 0 ) return AVERROR_INVALIDDATA ;\n<144> else if ( ! implicit_rect || wmv9_mask != - 1 ) {\n<161> else memset ( c -> pal_pic , 0 , c -> pal_stride * avctx -> height ) ;\n<179> uint8_t * dst = c -> rgb_pic + y * c -> rgb_stride + x * 3 ;\n<180> if ( wmv9_mask != - 1 ) {\n<181> ctx -> dsp . mss2_gray_fill_masked ( dst , c -> rgb_stride , wmv9_mask , c -> pal_pic + y * c -> pal_stride + x , c -> pal_stride , w , h ) ;\n<185> memset ( dst , 0x80 , w * 3 ) ;\n<186> dst += c -> rgb_stride ;\n<188> while ( -- h ) ;
<1> void var_set_string ( const char * name , const char * value ) {\n<2> var_set ( name , name + strlen ( name ) , value , value + strlen ( value ) ) ;
<1> static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n<9> RDMALocalBlocks *local = &rdma->local_ram_blocks;\n<13> RDMALocalBlock *old = local->block;\n<17> local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n<21> if (local->nb_blocks) {\n<45> memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n<47> g_free(old);\n<53> block = &local->block[local->nb_blocks];
<1> static void blk_send(QEMUFile *f, BlkMigBlock * blk)\n<31> len = strlen(bdrv_get_device_name(blk->bmds->bs));\n<33> qemu_put_byte(f, len);
<1> static struct alltabs * ttc_prep ( struct sflist * sfs , enum fontformat format , enum bitmapformat bf , int flags , int layer , SplineFont * dummysf ) {\n<3> int fcnt , cnt , gcnt = 3 ;\n<24> gcnt += sf -> glyphcnt ;\n<26> if ( cnt == 0 ) return ( NULL ) ;\n<27> fcnt = cnt ;\n<28> uhash = calloc ( 1 , sizeof ( UHash ) ) ;\n<29> nhash = calloc ( 1 , sizeof ( NHash ) ) ;\n<32> dummysf -> glyphs = calloc ( gcnt , sizeof ( SplineChar * ) ) ;\n<35> bygid = malloc ( ( gcnt + 3 ) * sizeof ( int ) ) ;\n<36> memset ( bygid , 0xff , ( gcnt + 3 ) * sizeof ( int ) ) ;\n<40> AssignNotdefNull ( sfitem -> sf , bygid , false ) ;\n<41> if ( bygid [ 0 ] != - 1 && dummysf -> glyphs [ 0 ] == NULL ) {\n<42> dummysf -> glyphs [ 0 ] = sfitem -> sf -> glyphs [ bygid [ 0 ] ] ;\n<46> if ( bygid [ 1 ] != - 1 && dummysf -> glyphs [ 1 ] == NULL ) {\n<47> dummysf -> glyphs [ 1 ] = sfitem -> sf -> glyphs [ bygid [ 1 ] ] ;\n<48> bygid [ 1 ] = 1 ;\n<50> if ( bygid [ 2 ] != - 1 && dummysf -> glyphs [ 2 ] == NULL ) {\n<51> dummysf -> glyphs [ 2 ] = sfitem -> sf -> glyphs [ bygid [ 2 ] ] ;\n<52> bygid [ 2 ] = 2 ;\n<54> if ( bygid [ 0 ] != - 1 && bygid [ 1 ] != - 1 && bygid [ 2 ] != - 1 ) break ;\n<57> if ( bygid [ 0 ] != - 1 ) break ;\n<61> ret = calloc ( fcnt + 2 , sizeof ( struct alltabs ) ) ;\n<62> ATinit ( & ret [ fcnt ] , dummysf , sfs -> map , flags & ~ ttf_flag_dummyDSIG , layer , format , bf , NULL ) ;\n<64> ATmaxpInit ( & ret [ fcnt ] , dummysf , format ) ;\n<66> sfitem != NULL ;\n<69> ATinit ( & ret [ cnt ] , sf , sfitem -> map , flags & ~ ttf_flag_dummyDSIG , layer , format , bf , sfitem -> sizes ) ;\n<70> ret [ cnt ] . gi . bygid = malloc ( ( gcnt + 3 ) * sizeof ( int ) ) ;\n<71> memset ( ret [ cnt ] . gi . bygid , - 1 , ( gcnt + 3 ) * sizeof ( int ) ) ;\n<75> if ( SCWorthOutputting ( sc = sf -> glyphs [ i ] ) ) {\n<76> if ( sc -> ttf_glyph == - 1 ) {\n<77> if ( strcmp ( sc -> name , ".notdef" ) == 0 ) sc -> ttf_glyph = bygid [ 0 ] ;\n<78> else if ( format == ff_ttf && ( strcmp ( sf -> glyphs [ i ] -> name , ".null" ) == 0 || strcmp ( sf -> glyphs [ i ] -> name , "uni0000" ) == 0 || ( i == 1 && strcmp ( sf -> glyphs [ 1 ] -> name , "glyph1" ) == 0 ) ) ) sc -> ttf_glyph = bygid [ 1 ] ;\n<79> else if ( format == ff_ttf && ( strcmp ( sf -> glyphs [ i ] -> name , "nonmarkingreturn" ) == 0 || strcmp ( sf -> glyphs [ i ] -> name , "uni000D" ) == 0 || ( i == 2 && strcmp ( sf -> glyphs [ 2 ] -> name , "glyph2" ) == 0 ) ) ) sc -> ttf_glyph = bygid [ 2 ] ;\n<81> test = hashglyphfound ( sc , uhash , nhash , layer ) ;\n<82> if ( test != NULL ) sc -> ttf_glyph = test -> ttf_glyph ;\n<85> bygid [ sc -> ttf_glyph ] = sc -> ttf_glyph ;\n<86> dummysf -> glyphs [ sc -> ttf_glyph ] = sc ;\n<87> hashglyphadd ( sc , uhash , nhash ) ;\n<92> ret [ cnt ] . gi . bygid [ sc -> ttf_glyph ] = i ;\n<96> if ( sc != NULL ) sc -> lsidebearing = 0x7fff ;\n<98> MaxpFromTable ( & ret [ cnt ] , sf ) ;\n<106> free ( uhash ) ;\n<107> free ( nhash ) ;\n<108> if ( dummysf -> glyphcnt > 0xffff ) {\n<109> free ( dummysf -> glyphs ) ;\n<110> free ( bygid ) ;\n<112> sfitem != NULL ;\n<113> sfitem = sfitem -> next , ++ cnt ) free ( ret [ cnt ] . gi . bygid ) ;\n<114> free ( ret ) ;\n<118> ret [ fcnt ] . gi . bygid = bygid ;\n<120> if ( format == ff_ttf ) aborted = ! dumpglyphs ( dummysf , & ret [ cnt ] . gi ) ;\n<121> else aborted = ! dumptype2glyphs ( dummysf , & ret [ cnt ] ) ;\n<122> if ( aborted ) {\n<123> free ( dummysf -> glyphs ) ;\n<124> free ( bygid ) ;\n<126> sfitem != NULL ;\n<127> sfitem = sfitem -> next , ++ cnt ) free ( ret [ cnt ] . gi . bygid ) ;\n<128> free ( ret ) ;\n<131> sethhead ( & ret [ fcnt ] . hhead , & ret [ fcnt ] . vhead , & ret [ fcnt ] , dummysf ) ;\n<135> sethead ( & ret [ fcnt ] . head , dummysf , & ret [ fcnt ] , format , NULL ) ;\n<136> if ( format == ff_ttf ) redoloca ( & ret [ fcnt ] ) ;\n<137> redohhead ( & ret [ fcnt ] , false ) ;\n<138> if ( dummysf -> hasvmetrics ) redohhead ( & ret [ fcnt ] , true ) ;\n<139> ttf_fftm_dump ( dummysf , & ret [ fcnt ] ) ;\n<140> return ( ret ) ;
<1> static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,\n<35> memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n<337> switch (op) {\n<619> memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
<1> REGRESSION_TEST ( SDK_API_ENCODING ) ( RegressionTest * test , int , int * pstatus ) {\n<10> const char * url3 = "https://www.thisisoneexampleofastringoflengtheightyasciilowercasecharacters.com/" ;\n<66> const size_t buf_len = strlen ( url3 ) + 1 ;
<1> static int zmbv_decode_xor_8 ( ZmbvContext * c ) {\n<32> bw2 = ( ( c -> width - x ) > c -> bw ) ? c -> bw : ( c -> width - x ) ;\n<33> out = output + x ;\n<40> if ( my + j < 0 || my + j >= c -> height ) {\n<41> memset ( out , 0 , bw2 ) ;\n<45> i < bw2 ;\n<47> if ( mx + i < 0 || mx + i >= c -> width ) out [ i ] = 0 ;\n<48> else out [ i ] = tprev [ i ] ;\n<51> out += c -> width ;\n<60> i < bw2 ;\n<61> i ++ ) out [ i ] ^= * src ++ ;
<1> static int init_prec(Jpeg2000Band *band,\n<133> for (cblkno = 0; cblkno < nb_codeblocks; cblkno++) {\n<135> Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n<211> memset(cblk->lengthinc, 0, sizeof(cblk->lengthinc));
<1> int av_new_packet(AVPacket *pkt, int size)\n<13> if (!data)\n<17> memset(data + size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
<1> int tcp_start_incoming_migration(const char *host_port)\n<13> if (parse_host_port(&addr, host_port) < 0) {\n<15> fprintf(stderr, "invalid host/port combination: %s\n", host_port);
<1> void hmp_info_block(Monitor *mon, const QDict *qdict)\n<9> const char *device = qdict_get_try_str(qdict, "device");\n<19> for (info = block_list; info; info = info->next) {\n<21> if (device && strcmp(device, info->value->device)) {\n<29> if (info != block_list) {\n<37> monitor_printf(mon, "%s", info->value->device);\n<39> if (info->value->has_inserted) {\n<59> if (info->value->has_io_status && info->value->io_status != BLOCK_DEVICE_IO_STATUS_OK) {\n<69> if (info->value->removable) {\n<83> if (!info->value->has_inserted) {
<1> CURLcode glob_url ( URLGlob * * glob , char * url , unsigned long * urlnum , FILE * error ) {\n<7> glob_buffer = malloc ( strlen ( url ) + 1 ) ;\n<8> if ( ! glob_buffer ) return CURLE_OUT_OF_MEMORY ;\n<9> glob_expand = calloc ( 1 , sizeof ( URLGlob ) ) ;\n<10> if ( ! glob_expand ) {\n<14> glob_expand -> urllen = strlen ( url ) ;\n<16> res = glob_parse ( glob_expand , url , 1 , & amount ) ;\n<17> if ( ! res ) * urlnum = amount ;\n<19> if ( error && glob_expand -> error ) {\n<24> t = text ;\n<26> else t = glob_expand -> error ;\n<27> fprintf ( error , "curl: (%d) [globbing] %s\n" , res , t ) ;\n<29> glob_cleanup ( glob_expand ) ;\n<31> return res ;\n<33> * glob = glob_expand ;
<1> static int rtp_asf_fix_header(uint8_t *buf, int len)\n<5> uint8_t *p = buf, *end = buf + len;\n<9> if (len < sizeof(ff_asf_guid) * 2 + 22 ||\n<11> memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {\n<17> p += sizeof(ff_asf_guid) + 14;\n<23> if (memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {\n<25> if (chunksize > end - p)\n<39> p += 6 * 8 + 3 * 4 + sizeof(ff_asf_guid) * 2;\n<41> if (p + 8 <= end && AV_RL32(p) == AV_RL32(p + 4)) {\n<53> } while (end - p >= sizeof(ff_asf_guid) + 8);
<1> static void network_init ( PCIBus * pci_bus ) {\n<4> i < nb_nics ;\n<6> NICInfo * nd = & nd_table [ i ] ;\n<8> if ( i == 0 && ( ! nd -> model || strcmp ( nd -> model , "rtl8139" ) == 0 ) ) {\n<9> default_devaddr = "07" ;\n<11> pci_nic_init_nofail ( nd , pci_bus , "rtl8139" , default_devaddr ) ;
<25> switch ( * buf ) {\n<32> case DUL_TYPETRANSFERSYNTAX : subItem = ( DUL_SUBITEM * ) malloc ( sizeof ( DUL_SUBITEM ) ) ;\n<33> if ( subItem == NULL ) return EC_MemoryExhausted ;
<1> static int aac_decode_frame(AVCodecContext *avctx, void *data,\n<19> if (new_extradata && 0) {\n<23> if (!avctx->extradata)\n<26> memcpy(avctx->extradata, new_extradata, new_extradata_size);\n<28> if (decode_audio_specific_config(ac, ac->avctx, &ac->oc[1].m4ac,
<1> static bool on_accept ( private_stroke_socket_t * this , stream_t * stream ) {\n<5> if ( ! stream -> read_all ( stream , & len , sizeof ( len ) ) ) {\n<6> if ( errno != EWOULDBLOCK ) {\n<7> DBG1 ( DBG_CFG , "reading length of stroke message failed: %s" , strerror ( errno ) ) ;\n<11> if ( len < offsetof ( stroke_msg_t , buffer ) ) {\n<15> msg = malloc ( len + 1 ) ;\n<16> msg -> length = len ;\n<17> if ( ! stream -> read_all ( stream , ( char * ) msg + sizeof ( len ) , len - sizeof ( len ) ) ) {\n<18> if ( errno != EWOULDBLOCK ) {\n<19> DBG1 ( DBG_CFG , "reading stroke message failed: %s" , strerror ( errno ) ) ;\n<21> free ( msg ) ;\n<24> ( ( char * ) msg ) [ len ] = '\0' ;\n<25> DBG3 ( DBG_CFG , "stroke message %b" , ( void * ) msg , len ) ;\n<27> if ( ! out ) {\n<29> free ( msg ) ;\n<33> case STR_INITIATE : stroke_initiate ( this , msg , out ) ;\n<35> case STR_ROUTE : stroke_route ( this , msg , out ) ;\n<37> case STR_UNROUTE : stroke_unroute ( this , msg , out ) ;\n<39> case STR_TERMINATE : stroke_terminate ( this , msg , out ) ;\n<41> case STR_TERMINATE_SRCIP : stroke_terminate_srcip ( this , msg , out ) ;\n<43> case STR_REKEY : stroke_rekey ( this , msg , out ) ;\n<45> case STR_STATUS : stroke_status ( this , msg , out , FALSE , TRUE ) ;\n<47> case STR_STATUS_ALL : stroke_status ( this , msg , out , TRUE , TRUE ) ;\n<49> case STR_STATUS_ALL_NOBLK : stroke_status ( this , msg , out , TRUE , FALSE ) ;\n<51> case STR_ADD_CONN : stroke_add_conn ( this , msg ) ;\n<53> case STR_DEL_CONN : stroke_del_conn ( this , msg ) ;\n<55> case STR_ADD_CA : stroke_add_ca ( this , msg , out ) ;\n<57> case STR_DEL_CA : stroke_del_ca ( this , msg , out ) ;\n<59> case STR_LOGLEVEL : stroke_loglevel ( this , msg , out ) ;\n<61> case STR_CONFIG : stroke_config ( this , msg , out ) ;\n<63> case STR_LIST : stroke_list ( this , msg , out ) ;\n<65> case STR_REREAD : stroke_reread ( this , msg , out ) ;\n<67> case STR_PURGE : stroke_purge ( this , msg , out ) ;\n<69> case STR_EXPORT : stroke_export ( this , msg , out ) ;\n<71> case STR_LEASES : stroke_leases ( this , msg , out ) ;\n<73> case STR_MEMUSAGE : stroke_memusage ( this , msg , out ) ;\n<75> case STR_USER_CREDS : stroke_user_creds ( this , msg , out ) ;\n<77> case STR_COUNTERS : stroke_counters ( this , msg , out ) ;\n<82> free ( msg ) ;
<1> bool arp_table_search(Slirp *slirp, uint32_t ip_addr,\n<3> uint8_t out_ethaddr[ETH_ALEN])\n<31> if (ip_addr == 0xffffffff || ip_addr == broadcast_addr) {\n<35> memset(out_ethaddr, 0xff, ETH_ALEN);\n<45> if (arptbl->table[i].ar_sip == ip_addr) {\n<47> memcpy(out_ethaddr, arptbl->table[i].ar_sha,  ETH_ALEN);\n<49> DEBUG_ARGS((dfd, " found hw addr = %02x:%02x:%02x:%02x:%02x:%02x\n",
<1> static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) {\n<4> unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ;\n<12> if ( NIL_P ( init_v ) ) memcpy ( iv , "OpenSSL for Ruby rulez!" , sizeof ( iv ) ) ;\n<15> if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) {\n<16> memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ;\n<17> memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ;\n<19> else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ;\n<21> EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ;
<1> static void test_bug5126 ( ) {\n<8> stmt_text = "DROP TABLE IF EXISTS t1" ;\n<9> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<11> stmt_text = "CREATE TABLE t1 (a mediumint, b int)" ;\n<12> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<14> stmt_text = "INSERT INTO t1 VALUES (8386608, 1)" ;\n<15> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<17> stmt = mysql_stmt_init ( mysql ) ;\n<18> stmt_text = "SELECT a, b FROM t1" ;\n<19> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<20> check_execute ( stmt , rc ) ;\n<23> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<28> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<31> DIE_UNLESS ( c1 == 8386608 && c2 == 1 ) ;\n<32> if ( ! opt_silent ) printf ( "%ld, %ld\n" , ( long ) c1 , ( long ) c2 ) ;
<1> int MPV_encode_init(AVCodecContext *avctx)\n<551> if(!done){\n<559> default_mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );\n<561> memset(default_mv_penalty, 0, sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1));\n<563> memset(default_fcode_tab , 0, sizeof(uint8_t)*(2*MAX_MV+1));\n<577> s->me.mv_penalty= default_mv_penalty;\n<579> s->fcode_tab= default_fcode_tab;\n<587> if (s->me_method < ME_EPZS) s->me.mv_penalty = default_mv_penalty;
<1> static const uint8_t *pcx_rle_decode(const uint8_t *src, uint8_t *dst,\n<3> unsigned int bytes_per_scanline,\n<15> if (compressed) {\n<39> memcpy(dst, src, bytes_per_scanline);\n<41> src += bytes_per_scanline;
<1> static int load_data(AVFilterContext *ctx, int azim, int elev, float radius)\n<13> int delay_l[16]; /* broadband delay for each IR */\n<15> int delay_r[16];\n<21> FFTComplex *data_hrtf_l = NULL;\n<23> FFTComplex *data_hrtf_r = NULL;\n<29> float *data_ir_l = NULL;\n<31> float *data_ir_r = NULL;\n<61> data_ir_l = av_malloc_array(n_conv * n_samples, sizeof(*data_ir_l));\n<65> if (!data_ir_r || !data_ir_l || !s->temp_src[0] || !s->temp_src[1]) {\n<79> data_hrtf_l = av_malloc_array(n_fft, sizeof(*data_hrtf_l) * n_conv);\n<83> if (!data_hrtf_r || !data_hrtf_l) {\n<145> if (!fft_in_l || !fft_in_r) {\n<161> offset = i * n_fft; /* no. samples already written */\n<189> av_fft_calc(s->fft[0], fft_in_l);\n<191> memcpy(data_hrtf_l + offset, fft_in_l, n_fft * sizeof(*fft_in_l));\n<195> av_fft_calc(s->fft[0], fft_in_r);\n<197> memcpy(data_hrtf_r + offset, fft_in_r, n_fft * sizeof(*fft_in_r));\n<211> if (s->type == TIME_DOMAIN) {\n<215> memcpy(s->data_ir[0], data_ir_l, sizeof(float) * n_conv * n_samples);\n<217> memcpy(s->data_ir[1], data_ir_r, sizeof(float) * n_conv * n_samples);\n<221> av_freep(&data_ir_l); /* free temporary IR memory */\n<223> av_freep(&data_ir_r);\n<229> s->data_hrtf[1] = av_malloc_array(n_fft * s->n_conv, sizeof(FFTComplex));\n<231> if (!s->data_hrtf[0] || !s->data_hrtf[1]) {\n<237> av_freep(&fft_in_l);\n<239> av_freep(&fft_in_r);\n<247> memcpy(s->data_hrtf[0], data_hrtf_l, /* copy HRTF data to */\n<249> sizeof(FFTComplex) * n_conv * n_fft); /* filter struct */\n<253> sizeof(FFTComplex) * n_conv * n_fft);\n<257> av_freep(&data_hrtf_l); /* free temporary HRTF memory */\n<259> av_freep(&data_hrtf_r);\n<263> av_freep(&fft_in_l); /* free temporary FFT memory */\n<265> av_freep(&fft_in_r);\n<271> memcpy(s->delay[0], &delay_l[0], sizeof(int) * s->n_conv);\n<273> memcpy(s->delay[1], &delay_r[0], sizeof(int) * s->n_conv);
<1> static int _make_step_cred ( struct step_record * step_ptr , slurm_cred_t * * slurm_cred , uint16_t protocol_version ) {\n<6> memset ( & cred_arg , 0 , sizeof ( slurm_cred_arg_t ) ) ;\n<35> * slurm_cred = slurm_cred_create ( slurmctld_config . cred_ctx , & cred_arg , protocol_version ) ;
<1> static void do_change(const char *device, const char *target)\n<5> if (strcmp(device, "vnc") == 0) {\n<7> do_change_vnc(target);\n<11> do_change_block(device, target);
<1> static int rndis_query_response(USBNetState *s,\n<43> if (!resp)\n<49> resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n<51> resp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n<53> resp->MessageLength = cpu_to_le32(resplen);\n<57> if (infobuflen < 0) {\n<73> resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n<79> resp->InformationBufferLength = cpu_to_le32(infobuflen);\n<81> memcpy(resp + 1, infobuf, infobuflen);
<1> static void test_temporal_param ( ) {\n<11> memset ( & my_bind , 0 , sizeof ( my_bind ) ) ;\n<12> memset ( & my_bind2 , 0 , sizeof ( my_bind2 ) ) ;\n<13> memset ( & length , 0 , sizeof ( length ) ) ;\n<14> memset ( & length2 , 0 , sizeof ( length2 ) ) ;\n<15> memset ( & is_null , 0 , sizeof ( is_null ) ) ;\n<16> memset ( & is_null2 , 0 , sizeof ( is_null2 ) ) ;\n<19> my_bind [ 0 ] . is_null = & is_null [ 0 ] ;\n<20> my_bind [ 0 ] . length = & length [ 0 ] ;\n<24> my_bind2 [ 0 ] . length = & length2 [ 0 ] ;\n<25> my_bind2 [ 0 ] . is_null = & is_null2 [ 0 ] ;\n<29> my_bind2 [ 1 ] . length = & length2 [ 1 ] ;\n<30> my_bind2 [ 1 ] . is_null = & is_null2 [ 1 ] ;\n<34> my_bind2 [ 2 ] . length = & length2 [ 2 ] ;\n<35> my_bind2 [ 2 ] . is_null = & is_null2 [ 2 ] ;\n<41> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<43> rc = mysql_stmt_bind_result ( stmt , my_bind2 ) ;\n<60> if ( ! opt_silent ) printf ( "\n%lld %f '%s'\n" , bigint , real , dec ) ;\n<61> DIE_UNLESS ( bigint == 20011020101100LL ) ;\n<62> DIE_UNLESS ( real == 20011020101059.5 ) ;\n<63> DIE_UNLESS ( ! strcmp ( dec , "20011020101059.5" ) ) ;\n<69> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<71> rc = mysql_stmt_bind_result ( stmt , my_bind2 ) ;\n<86> if ( ! opt_silent ) printf ( "\n%lld %f '%s'\n" , bigint , real , dec ) ;\n<87> DIE_UNLESS ( bigint == 101100 ) ;\n<88> DIE_UNLESS ( real == 101059.5 ) ;\n<89> DIE_UNLESS ( ! strcmp ( dec , "101059.5" ) ) ;
<1> static int unpack_superblocks ( Vp3DecodeContext * s , GetBitContext * gb ) {\n<12> if ( s -> keyframe ) {\n<13> memset ( s -> superblock_coding , SB_FULLY_CODED , s -> superblock_count ) ;\n<18> while ( current_superblock < s -> superblock_count && get_bits_left ( gb ) > 0 ) {\n<19> if ( s -> theora && current_run == MAXIMUM_LONG_BIT_RUN ) bit = get_bits1 ( gb ) ;\n<20> else bit ^= 1 ;\n<22> if ( current_run == 34 ) current_run += get_bits ( gb , 12 ) ;\n<23> if ( current_superblock + current_run > s -> superblock_count ) {\n<27> memset ( s -> superblock_coding + current_superblock , bit , current_run ) ;\n<28> current_superblock += current_run ;\n<29> if ( bit ) num_partial_superblocks += current_run ;\n<31> if ( num_partial_superblocks < s -> superblock_count ) {\n<36> while ( superblocks_decoded < s -> superblock_count - num_partial_superblocks && get_bits_left ( gb ) > 0 ) {\n<63> memset ( s -> macroblock_coding , MODE_COPY , s -> macroblock_count ) ;\n<80> if ( current_run -- == 0 ) {\n<81> bit ^= 1 ;\n<84> coded = bit ;\n<91> s -> all_fragments [ current_fragment ] . coding_method = MODE_COPY ;
<1> static int pci_add_option_rom(PCIDevice *pdev, bool is_default_rom)\n<15> if (!pdev->romfile)\n<19> if (strlen(pdev->romfile) == 0)\n<21> return 0;\n<25> if (!pdev->rom_bar) {\n<39> rom_add_vga(pdev->romfile);\n<43> rom_add_option(pdev->romfile, -1);\n<53> path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);
<1> static int pdf_dsc_process ( gx_device_pdf * pdev , const gs_param_string_array * pma ) {\n<9> gs_param_string * pvalue = ( gs_param_string * ) & pma -> data [ i + 1 ] ;\n<14> newsize = unescape_octals ( pdev , ( char * ) pvalue -> data , pvalue -> size ) ;\n<15> code = cos_dict_put_c_key_string ( pdev -> Info , key , pvalue -> data , newsize ) ;\n<20> newsize = unescape_octals ( pdev , ( char * ) pvalue -> data , pvalue -> size ) ;\n<21> code = cos_dict_put_c_key_string ( pdev -> Info , key , pvalue -> data , newsize ) ;\n<26> newsize = unescape_octals ( pdev , ( char * ) pvalue -> data , pvalue -> size ) ;\n<27> code = cos_dict_put_c_key_string ( pdev -> Info , key , pvalue -> data , newsize ) ;\n<34> if ( pvalue -> size == 1 && pvalue -> data [ 0 ] >= '0' && pvalue -> data [ 0 ] <= '3' ) ppdi -> orientation = pvalue -> data [ 0 ] - '0' ;\n<40> if ( pvalue -> size >= sizeof ( scan_buf ) - 1 ) continue ;\n<41> memcpy ( scan_buf , pvalue -> data , pvalue -> size ) ;\n<42> scan_buf [ pvalue -> size ] = 0 ;\n<43> if ( sscanf ( scan_buf , "[%g %g %g %g]" , & mat . xx , & mat . xy , & mat . yx , & mat . yy ) != 4 ) continue ;\n<44> for ( orient = 0 ;\n<45> orient < 4 ;\n<47> if ( mat . xx == 1 && mat . xy == 0 && mat . yx == 0 && mat . yy == 1 ) break ;\n<48> gs_matrix_rotate ( & mat , - 90.0 , & mat ) ;\n<50> if ( orient == 4 ) orient = - 1 ;\n<51> ppdi -> viewing_orientation = orient ;\n<56> pdev -> is_EPS = ( pvalue -> size >= 1 && pvalue -> data [ 0 ] != '0' ) ;\n<62> if ( pvalue -> size >= sizeof ( scan_buf ) - 1 ) continue ;\n<63> memcpy ( scan_buf , pvalue -> data , pvalue -> size ) ;\n<64> scan_buf [ pvalue -> size ] = 0 ;\n<65> if ( sscanf ( scan_buf , "[%lg %lg %lg %lg]" , & box . p . x , & box . p . y , & box . q . x , & box . q . y ) != 4 ) continue ;\n<66> ppdi -> bounding_box = box ;
<1> static int header_newc ( struct archive_read * a , struct cpio * cpio , struct archive_entry * entry , size_t * namelength , size_t * name_pad ) {\n<8> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<9> header = ( const char * ) h ;\n<10> if ( memcmp ( header + newc_magic_offset , "070701" , 6 ) == 0 ) {\n<11> a -> archive . archive_format = ARCHIVE_FORMAT_CPIO_SVR4_NOCRC ;\n<12> a -> archive . archive_format_name = "ASCII cpio (SVR4 with no CRC)" ;\n<14> else if ( memcmp ( header + newc_magic_offset , "070702" , 6 ) == 0 ) {\n<15> a -> archive . archive_format = ARCHIVE_FORMAT_CPIO_SVR4_CRC ;\n<16> a -> archive . archive_format_name = "ASCII cpio (SVR4 with CRC)" ;
<1> int ff_h264_execute_ref_pic_marking ( H264Context * h , MMCO * mmco , int mmco_count ) {\n<58> remove_short ( h , h -> short_ref [ 0 ] -> frame_num , 0 ) ;\n<73> if ( h -> short_ref_count && h -> short_ref [ 0 ] == h -> cur_pic_ptr ) {\n<86> if ( h -> short_ref_count ) memmove ( & h -> short_ref [ 1 ] , & h -> short_ref [ 0 ] , h -> short_ref_count * sizeof ( Picture * ) ) ;\n<92> if ( h -> long_ref_count + h -> short_ref_count - ( h -> short_ref [ 0 ] == h -> cur_pic_ptr ) > h -> sps . ref_frame_count ) {
<1> static void test_bug6046 ( ) {\n<8> stmt_text = "DROP TABLE IF EXISTS t1" ;\n<9> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<11> stmt_text = "CREATE TABLE t1 (a int, b int)" ;\n<12> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<14> stmt_text = "INSERT INTO t1 VALUES (1,1),(2,2),(3,1),(4,2)" ;\n<15> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<17> stmt = mysql_stmt_init ( mysql ) ;\n<18> stmt_text = "SELECT t1.a FROM t1 NATURAL JOIN t1 as X1 " "WHERE t1.b > ? ORDER BY t1.a" ;\n<19> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<20> check_execute ( stmt , rc ) ;\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<25> mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static int main_secondary_decompress_check ( main_file * file , uint8_t * input_buf , size_t input_size , size_t * nread ) {\n<8> if ( ( ret = main_file_read ( file , check_buf , try_read , & check_nread , "input read failed" ) ) ) {\n<16> i < SIZEOF_ARRAY ( extcomp_types ) ;\n<17> i += 1 ) {\n<18> const main_extcomp * decomp = & extcomp_types [ i ] ;\n<19> if ( check_nread > decomp -> magic_size ) {\n<21> if ( skip_this_type ) {\n<24> if ( memcmp ( check_buf , decomp -> magic , decomp -> magic_size ) == 0 ) {\n<25> decompressor = decomp ;\n<31> if ( decompressor != NULL ) {\n<50> return main_input_decompress_setup ( decompressor , file , input_buf , input_size , check_buf , XD3_ALLOCSIZE , check_nread , nread ) ;\n<53> if ( check_nread == try_read ) {\n<56> memcpy ( input_buf , check_buf , check_nread ) ;\n<57> ( * nread ) += check_nread ;
<1> static void kvm_add_routing_entry(KVMState *s,\n<35> new = &s->irq_routes->entries[n];\n<37> memset(new, 0, sizeof(*new));
<1> static void tcp_accept_incoming_migration(void *opaque)\n<33> if (c == -1) {\n<35> fprintf(stderr, "could not accept migration connection\n");\n<45> if (f == NULL) {\n<47> fprintf(stderr, "could not qemu_fopen socket\n");
<1> void ff_init_rl ( RLTable * rl , uint8_t static_store [ 2 ] [ 2 * MAX_RUN + MAX_LEVEL + 3 ] ) {\n<2> int8_t max_level [ MAX_RUN + 1 ] , max_run [ MAX_LEVEL + 1 ] ;\n<3> uint8_t index_run [ MAX_RUN + 1 ] ;\n<7> last < 2 ;\n<15> end = rl -> n ;\n<17> memset ( max_level , 0 , MAX_RUN + 1 ) ;\n<18> memset ( max_run , 0 , MAX_LEVEL + 1 ) ;\n<19> memset ( index_run , rl -> n , MAX_RUN + 1 ) ;\n<25> if ( index_run [ run ] == rl -> n ) index_run [ run ] = i ;\n<26> if ( level > max_level [ run ] ) max_level [ run ] = level ;\n<27> if ( run > max_run [ level ] ) max_run [ level ] = run ;\n<29> if ( static_store ) rl -> max_level [ last ] = static_store [ last ] ;\n<30> else rl -> max_level [ last ] = av_malloc ( MAX_RUN + 1 ) ;\n<31> memcpy ( rl -> max_level [ last ] , max_level , MAX_RUN + 1 ) ;\n<32> if ( static_store ) rl -> max_run [ last ] = static_store [ last ] + MAX_RUN + 1 ;\n<33> else rl -> max_run [ last ] = av_malloc ( MAX_LEVEL + 1 ) ;\n<34> memcpy ( rl -> max_run [ last ] , max_run , MAX_LEVEL + 1 ) ;\n<35> if ( static_store ) rl -> index_run [ last ] = static_store [ last ] + MAX_RUN + MAX_LEVEL + 2 ;\n<36> else rl -> index_run [ last ] = av_malloc ( MAX_RUN + 1 ) ;\n<37> memcpy ( rl -> index_run [ last ] , index_run , MAX_RUN + 1 ) ;
<1> static void test_change_user ( ) {\n<2> char buff [ 256 ] ;\n<3> const char * user_pw = "mysqltest_pw" ;\n<4> const char * user_no_pw = "mysqltest_no_pw" ;\n<5> const char * pw = "password" ;\n<6> const char * db = "mysqltest_user_test_database" ;\n<15> sprintf ( buff , "drop database if exists %s" , db ) ;\n<16> rc = mysql_query ( l_mysql , buff ) ;\n<18> sprintf ( buff , "create database %s" , db ) ;\n<19> rc = mysql_query ( l_mysql , buff ) ;\n<21> sprintf ( buff , "grant select on %s.* to %s@'%%' identified by '%s'" , db , user_pw , pw ) ;\n<22> rc = mysql_query ( l_mysql , buff ) ;\n<24> sprintf ( buff , "grant select on %s.* to %s@'localhost' identified by '%s'" , db , user_pw , pw ) ;\n<25> rc = mysql_query ( l_mysql , buff ) ;\n<27> sprintf ( buff , "grant select on %s.* to %s@'%%'" , db , user_no_pw ) ;\n<28> rc = mysql_query ( l_mysql , buff ) ;\n<30> sprintf ( buff , "grant select on %s.* to %s@'localhost'" , db , user_no_pw ) ;\n<31> rc = mysql_query ( l_mysql , buff ) ;\n<35> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<39> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<43> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<47> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<51> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<55> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<59> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<61> rc = mysql_change_user ( l_mysql , user_pw , NULL , "" ) ;\n<63> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<67> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<71> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<75> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<77> rc = mysql_change_user ( l_mysql , user_pw , "" , db ) ;\n<79> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<83> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<85> rc = mysql_change_user ( l_mysql , user_pw , pw , db ) ;\n<89> rc = mysql_change_user ( l_mysql , user_pw , pw , "" ) ;\n<91> rc = mysql_change_user ( l_mysql , user_no_pw , pw , db ) ;\n<93> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<96> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<100> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<108> rc = mysql_change_user ( l_mysql , user_no_pw , NULL , db ) ;\n<112> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<116> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<120> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<123> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<127> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<131> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<133> rc = mysql_change_user ( l_mysql , "" , "" , db ) ;\n<135> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( l_mysql ) ) ;\n<138> sprintf ( buff , "drop database %s" , db ) ;\n<139> rc = mysql_query ( mysql , buff ) ;\n<141> sprintf ( buff , "drop user %s@'%%'" , user_pw ) ;\n<142> rc = mysql_query ( mysql , buff ) ;\n<144> sprintf ( buff , "drop user %s@'%%'" , user_no_pw ) ;\n<145> rc = mysql_query ( mysql , buff ) ;\n<147> sprintf ( buff , "drop user %s@'localhost'" , user_pw ) ;\n<148> rc = mysql_query ( mysql , buff ) ;\n<150> sprintf ( buff , "drop user %s@'localhost'" , user_no_pw ) ;\n<151> rc = mysql_query ( mysql , buff ) ;
<1> static kadm5_ret_t make_ks_from_keys ( krb5_context context , int n_keys , krb5_keyblock * keyblocks , krb5_key_salt_tuple * * ks_tuple ) {\n<3> * ks_tuple = calloc ( n_keys , sizeof ( * * ks_tuple ) ) ;\n<4> if ( * ks_tuple == NULL ) return ENOMEM ;
<1> rfbBool rfbSendSetColourMapEntries ( rfbClientPtr cl , int firstColour , int nColours ) {\n<3> char * wbuf = buf ;\n<8> if ( nColours > 256 ) {\n<9> wbuf = ( char * ) malloc ( sz_rfbSetColourMapEntriesMsg + nColours * 3 * 2 ) ;\n<11> scme = ( rfbSetColourMapEntriesMsg * ) wbuf ;\n<12> rgb = ( uint16_t * ) ( & wbuf [ sz_rfbSetColourMapEntriesMsg ] ) ;\n<35> if ( rfbWriteExact ( cl , wbuf , len ) < 0 ) {\n<38> if ( wbuf != buf ) free ( wbuf ) ;\n<44> if ( wbuf != buf ) free ( wbuf ) ;
<1> static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n<3> uint8_t *dst, int stride, int16_t *block)\n<13> if (get_bits1(gb)) {\n<29> memset(block, 0, sizeof(*block) * 64);\n<49> fic_idct_put(dst, stride, block);
<1> static int qemu_chr_open_socket(QemuOpts *opts, CharDriverState **_chr)\n<119> qemu_set_fd_handler2(s->listen_fd, NULL, tcp_chr_accept, NULL, chr);\n<135> tcp_chr_connect(chr);\n<173> if (is_listen && is_waitconnect) {\n<179> tcp_chr_accept(chr);\n<187> *_chr = chr;
<1> static void fill_scaling_lists ( struct dxva_context * ctx , const H264Context * h , DXVA_Qmatrix_H264 * qm ) {\n<3> memset ( qm , 0 , sizeof ( * qm ) ) ;
<1> void configure_icount ( const char * option ) {\n<3> if ( ! option ) {\n<7> if ( strcmp ( option , "auto" ) != 0 ) {\n<8> icount_time_shift = strtol ( option , NULL , 0 ) ;\n<9> use_icount = 1 ;\n<10> return ;\n<12> use_icount = 2 ;\n<13> icount_time_shift = 3 ;\n<14> icount_rt_timer = qemu_new_timer_ms ( rt_clock , icount_adjust_rt , NULL ) ;\n<15> qemu_mod_timer ( icount_rt_timer , qemu_get_clock_ms ( rt_clock ) + 1000 ) ;\n<16> icount_vm_timer = qemu_new_timer_ns ( vm_clock , icount_adjust_vm , NULL ) ;\n<17> qemu_mod_timer ( icount_vm_timer , qemu_get_clock_ns ( vm_clock ) + get_ticks_per_sec ( ) / 10 ) ;
<1> static int latm_decode_audio_specific_config(struct LATMContext *latmctx,\n<25> asclen         = FFMIN(asclen, get_bits_left(gb));\n<29> asclen         = get_bits_left(gb);\n<63> av_log(avctx, AV_LOG_INFO, "audio config changed\n");\n<73> if (avctx->extradata_size < esize) {\n<79> if (!avctx->extradata)\n<89> memcpy(avctx->extradata, gb->buffer + (config_start_bit/8), esize);\n<91> memset(avctx->extradata+esize, 0, FF_INPUT_BUFFER_PADDING_SIZE);
<1> static afs_int32 WhoIsThisWithName ( struct rx_call * acall , struct ubik_trans * at , afs_int32 * aid , char * aname ) {\n<18> if ( ( code = rxkad_GetServerInfo ( acall -> conn , NULL , 0 , name , inst , tcell , NULL ) ) ) goto done ;\n<19> strncpy ( vname , name , sizeof ( vname ) ) ;\n<20> if ( ( ilen = strlen ( inst ) ) ) {\n<21> if ( strlen ( vname ) + 1 + ilen >= sizeof ( vname ) ) goto done ;\n<22> strcat ( vname , "." ) ;\n<23> strcat ( vname , inst ) ;\n<25> if ( ( clen = strlen ( tcell ) ) ) {\n<26> int foreign = afs_is_foreign_ticket_name ( name , inst , tcell , pr_realmName ) ;\n<27> if ( foreign ) {\n<28> if ( strlen ( vname ) + 1 + clen >= sizeof ( vname ) ) goto done ;\n<29> strcat ( vname , "@" ) ;\n<30> strcat ( vname , tcell ) ;\n<31> lcstring ( vname , vname , sizeof ( vname ) ) ;\n<32> code = NameToID ( at , vname , aid ) ;\n<33> strcpy ( aname , vname ) ;\n<34> return 2 ;\n<37> if ( strcmp ( AUTH_SUPERUSER , vname ) == 0 ) * aid = SYSADMINID ;\n<39> lcstring ( vname , vname , sizeof ( vname ) ) ;\n<40> code = NameToID ( at , vname , aid ) ;\n<43> done : if ( code && ! pr_noAuth ) return - 1 ;
<1> static void ac3_upmix_delay ( AC3DecodeContext * s ) {\n<2> int channel_data_size = sizeof ( s -> delay [ 0 ] ) ;\n<3> switch ( s -> channel_mode ) {\n<4> case AC3_CHMODE_DUALMONO : case AC3_CHMODE_STEREO : memcpy ( s -> delay [ 1 ] , s -> delay [ 0 ] , channel_data_size ) ;\n<6> case AC3_CHMODE_2F2R : memset ( s -> delay [ 3 ] , 0 , channel_data_size ) ;\n<7> case AC3_CHMODE_2F1R : memset ( s -> delay [ 2 ] , 0 , channel_data_size ) ;\n<9> case AC3_CHMODE_3F2R : memset ( s -> delay [ 4 ] , 0 , channel_data_size ) ;\n<10> case AC3_CHMODE_3F1R : memset ( s -> delay [ 3 ] , 0 , channel_data_size ) ;\n<11> case AC3_CHMODE_3F : memcpy ( s -> delay [ 2 ] , s -> delay [ 1 ] , channel_data_size ) ;\n<12> memset ( s -> delay [ 1 ] , 0 , channel_data_size ) ;
<1> void *g_try_malloc0(size_t n_bytes)\n<7> return calloc(1, n_bytes == 0 ? 1 : n_bytes);
<1> static void output_client_manifest(struct VideoFiles *files,\n<25> if (!out) {\n<33> fprintf(out, "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");\n<39> if (files->video_file >= 0) {\n<41> struct VideoFile *vf = files->files[files->video_file];\n<43> int index = 0;\n<57> vf = files->files[i];\n<59> if (!vf->is_video)\n<73> for (j = 0; j < vf->codec_private_size; j++)\n<75> fprintf(out, "%02X", vf->codec_private[j]);\n<77> fprintf(out, "\" />\n");\n<79> index++;\n<85> for (i = 0; i < vf->chunks; i++)\n<87> fprintf(out, "\t\t<c n=\"%d\" d=\"%d\" />\n", i,\n<91> fprintf(out, "\t</StreamIndex>\n");\n<95> if (files->audio_file >= 0) {\n<97> struct VideoFile *vf = files->files[files->audio_file];\n<99> int index = 0;\n<113> vf = files->files[i];\n<115> if (!vf->is_audio)\n<133> for (j = 0; j < vf->codec_private_size; j++)\n<135> fprintf(out, "%02X", vf->codec_private[j]);\n<137> fprintf(out, "\" />\n");\n<139> index++;\n<145> for (i = 0; i < vf->chunks; i++)\n<151> fprintf(out, "\t</StreamIndex>\n");\n<155> fprintf(out, "</SmoothStreamingMedia>\n");\n<157> fclose(out);
<1> static int bamboo_load_device_tree(hwaddr addr,\n<57> if (ret < 0)\n<59> fprintf(stderr, "couldn't set /memory/reg\n");\n<67> if (ret < 0)\n<69> fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");\n<77> if (ret < 0)\n<79> fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");\n<87> if (ret < 0)\n<89> fprintf(stderr, "couldn't set /chosen/bootargs\n");
<1> qcow_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,\n<23> buf = qemu_blockalign(bs, s->cluster_size);\n<25> if (bytes != s->cluster_size) {\n<27> if (bytes > s->cluster_size ||\n<41> memset(buf + bytes, 0, s->cluster_size - bytes);\n<55> memset(&strm, 0, sizeof(strm));\n<83> ret = deflate(&strm, Z_FINISH);\n<87> deflateEnd(&strm);\n<95> out_len = strm.next_out - out_buf;\n<99> deflateEnd(&strm);
<1> static int openhost ( const char * hname , int fam ) {\n<11> if ( * cp == '[' ) {\n<16> if ( * cp == ']' ) {\n<41> fprintf ( stderr , "%s\n" , gai_strerror ( a_info ) ) ;
<1> int get_file_params_count_resume ( char * * params , int paramcount ) {\n<5> pos < paramcount - 2 ;\n<6> pos ++ ) {\n<7> if ( strlen ( params [ pos ] ) == 0 ) continue ;\n<8> if ( params [ pos ] [ strlen ( params [ pos ] ) - 1 ] == '"' && get_params_match_resume ( params , pos + 1 ) ) return pos + 1 ;\n<15> if ( get_params_match_resume ( params , pos ) ) best = pos ;
<1> static int vdi_create(const char *filename, QEMUOptionParameter *options,\n<33> while (options && options->name) {\n<35> if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n<37> bytes = options->value.n;\n<67> options++;\n<79> if (fd < 0) {\n<101> memset(&header, 0, sizeof(header));\n<143> vdi_header_to_le(&header);\n<145> if (write(fd, &header, sizeof(header)) < 0) {
<1> static void clear_codec_buffers ( WmallDecodeCtx * s ) {\n<3> memset ( s -> acfilter_coeffs , 0 , sizeof ( s -> acfilter_coeffs ) ) ;\n<4> memset ( s -> acfilter_prevvalues , 0 , sizeof ( s -> acfilter_prevvalues ) ) ;\n<5> memset ( s -> lpc_coefs , 0 , sizeof ( s -> lpc_coefs ) ) ;\n<6> memset ( s -> mclms_coeffs , 0 , sizeof ( s -> mclms_coeffs ) ) ;\n<7> memset ( s -> mclms_coeffs_cur , 0 , sizeof ( s -> mclms_coeffs_cur ) ) ;\n<8> memset ( s -> mclms_prevvalues , 0 , sizeof ( s -> mclms_prevvalues ) ) ;\n<9> memset ( s -> mclms_updates , 0 , sizeof ( s -> mclms_updates ) ) ;\n<14> ilms < s -> cdlms_ttl [ ich ] ;\n<16> memset ( s -> cdlms [ ich ] [ ilms ] . coefs , 0 , sizeof ( s -> cdlms [ ich ] [ ilms ] . coefs ) ) ;\n<17> memset ( s -> cdlms [ ich ] [ ilms ] . lms_prevvalues , 0 , sizeof ( s -> cdlms [ ich ] [ ilms ] . lms_prevvalues ) ) ;\n<18> memset ( s -> cdlms [ ich ] [ ilms ] . lms_updates , 0 , sizeof ( s -> cdlms [ ich ] [ ilms ] . lms_updates ) ) ;
<1> int tm_subscribe ( tm_task_id tid , char * name , void * info , int len , int * info_len , tm_event_t * event ) {\n<27> if ( diswst ( chan , name ) != DIS_SUCCESS ) {\n<32> ihold = ( struct infohold * ) calloc ( 1 , sizeof ( struct infohold ) ) ;\n<33> assert ( ihold != NULL ) ;
<1> START_TEST(escaped_string)\n<37> for (i = 0; test_cases[i].encoded; i++) {\n<45> obj = qobject_from_json(test_cases[i].encoded);\n<57> fail_unless(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n<61> if (test_cases[i].skip == 0) {\n<65> fail_unless(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
<1> static int find_odc_header ( struct archive_read * a ) {\n<10> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<11> p = h ;\n<13> if ( memcmp ( "070707" , p , 6 ) == 0 && is_octal ( p , odc_header_size ) ) return ( ARCHIVE_OK ) ;\n<14> if ( memcmp ( "070727" , p , 6 ) == 0 && is_afio_large ( p , bytes ) ) {\n<15> a -> archive . archive_format = ARCHIVE_FORMAT_CPIO_AFIO_LARGE ;\n<16> return ( ARCHIVE_OK ) ;\n<18> while ( p + odc_header_size <= q ) {\n<19> switch ( p [ 5 ] ) {\n<20> case '7' : if ( ( memcmp ( "070707" , p , 6 ) == 0 && is_octal ( p , odc_header_size ) ) || ( memcmp ( "070727" , p , 6 ) == 0 && is_afio_large ( p , q - p ) ) ) {\n<21> skip = p - ( const char * ) h ;\n<22> __archive_read_consume ( a , skip ) ;\n<23> skipped += skip ;\n<24> if ( p [ 4 ] == '2' ) a -> archive . archive_format = ARCHIVE_FORMAT_CPIO_AFIO_LARGE ;\n<25> if ( skipped > 0 ) {\n<31> p += 2 ;\n<33> case '0' : p ++ ;\n<35> default : p += 6 ;\n<39> skip = p - ( const char * ) h ;
<1> static void esp_mem_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n<33> } else if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n<41> fprintf(stderr, "esp: PIO data write not implemented\n");
<1> av_cold int MPV_common_init(MpegEncContext *s)\n<9> if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n<39> if((s->width || s->height) && avcodec_check_dimensions(s->avctx, s->width, s->height))\n<47> ff_dct_common_init(s);\n<51> s->flags= s->avctx->flags;\n<53> s->flags2= s->avctx->flags2;\n<63> s->b4_stride = s->mb_width*4 + 1;\n<81> s->h_edge_pos= s->mb_width*16;\n<83> s->v_edge_pos= s->mb_height*16;\n<87> s->mb_num = s->mb_width * s->mb_height;\n<105> y_size = s->b8_stride * (2 * s->mb_height + 1);\n<115> s->codec_tag = ff_toupper4(s->avctx->codec_tag);\n<119> s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag);\n<127> FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) //error ressilience code looks cleaner with this\n<139> s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; //FIXME really needed?\n<147> FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base            , mv_table_size * 2 * sizeof(int16_t), fail)\n<149> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n<151> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n<153> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n<155> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n<157> FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base     , mv_table_size * 2 * sizeof(int16_t), fail)\n<159> s->p_mv_table           = s->p_mv_table_base            + s->mb_stride + 1;\n<161> s->b_forw_mv_table      = s->b_forw_mv_table_base       + s->mb_stride + 1;\n<163> s->b_back_mv_table      = s->b_back_mv_table_base       + s->mb_stride + 1;\n<165> s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n<167> s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n<169> s->b_direct_mv_table    = s->b_direct_mv_table_base     + s->mb_stride + 1;\n<175> FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail);\n<185> FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type  , mb_array_size * sizeof(uint16_t), fail) //needed for encoding\n<189> FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)\n<193> FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix  , 64*32   * sizeof(int), fail)\n<195> FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix  , 64*32   * sizeof(int), fail)\n<197> FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n<199> FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n<201> FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n<203> FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n<209> FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail)\n<215> FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, MAX_PICTURE_COUNT * sizeof(Picture), fail)\n<225> FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail)\n<229> if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){\n<261> if (s->out_format == FMT_H263) {\n<265> FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_val_base, yc_size * sizeof(int16_t) * 16, fail);\n<277> FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size, fail);\n<279> s->coded_block= s->coded_block_base + s->b8_stride + 1;\n<285> FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail)\n<287> FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail)\n<293> if (s->h263_pred || s->h263_plus || !s->encoding) {\n<299> FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);\n<317> FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n<319> memset(s->mbintra_table, 1, mb_array_size);\n<325> FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail);\n<329> FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);\n<341> s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n<347> s->context_initialized = 1;\n<351> s->thread_context[0]= s;\n<357> for(i=1; i<threads; i++){\n<359> s->thread_context[i]= av_malloc(sizeof(MpegEncContext));\n<361> memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n<369> if(init_duplicate_context(s->thread_context[i], s) < 0)\n<385> MPV_common_end(s);
<1> int do_ssl3_write ( SSL * s , int type , const unsigned char * buf , unsigned int * pipelens , unsigned int numpipes , int create_empty_fragment ) {\n<31> if ( ! clear && ! create_empty_fragment && ! s -> s3 -> empty_fragment_done ) {\n<32> if ( s -> s3 -> need_empty_fragments && type == SSL3_RT_APPLICATION_DATA ) {\n<36> if ( prefix_len > ( SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD ) ) {\n<77> memset ( wr , 0 , sizeof wr ) ;\n<82> SSL3_RECORD_set_type ( & wr [ j ] , type ) ;\n<88> SSL3_RECORD_set_data ( & wr [ j ] , outbuf [ j ] + eivlen ) ;\n<89> SSL3_RECORD_set_length ( & wr [ j ] , ( int ) pipelens [ j ] ) ;\n<90> SSL3_RECORD_set_input ( & wr [ j ] , ( unsigned char * ) & buf [ totlen ] ) ;\n<92> if ( s -> compress != NULL ) {\n<93> if ( ! ssl3_do_compress ( s , & wr [ j ] ) ) {\n<99> memcpy ( wr [ j ] . data , wr [ j ] . input , wr [ j ] . length ) ;\n<100> SSL3_RECORD_reset_input ( & wr [ j ] ) ;\n<103> if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , & ( outbuf [ j ] [ wr [ j ] . length + eivlen ] ) , 1 ) < 0 ) goto err ;\n<104> SSL3_RECORD_add_length ( & wr [ j ] , mac_size ) ;\n<106> SSL3_RECORD_set_data ( & wr [ j ] , outbuf [ j ] ) ;\n<107> SSL3_RECORD_reset_input ( & wr [ j ] ) ;\n<109> SSL3_RECORD_add_length ( & wr [ j ] , eivlen ) ;\n<112> if ( s -> method -> ssl3_enc -> enc ( s , wr , numpipes , 1 ) < 1 ) goto err ;\n<117> if ( s -> method -> ssl3_enc -> mac ( s , & wr [ j ] , outbuf [ j ] + wr [ j ] . length , 1 ) < 0 ) goto err ;\n<118> SSL3_RECORD_add_length ( & wr [ j ] , mac_size ) ;\n<120> s2n ( SSL3_RECORD_get_length ( & wr [ j ] ) , plen [ j ] ) ;\n<122> SSL3_RECORD_set_type ( & wr [ j ] , type ) ;\n<123> SSL3_RECORD_add_length ( & wr [ j ] , SSL3_RT_HEADER_LENGTH ) ;\n<129> return SSL3_RECORD_get_length ( wr ) ;\n<131> SSL3_BUFFER_set_left ( & s -> rlayer . wbuf [ j ] , prefix_len + SSL3_RECORD_get_length ( & wr [ j ] ) ) ;
<1> SplinePointList * SplinePointListInterpretPS ( FILE * ps , int flags , int is_stroked , int * width ) {\n<4> memset ( & ec , '\0' , sizeof ( ec ) ) ;\n<6> memset ( & sc , 0 , sizeof ( sc ) ) ;\n<8> ec . sc = & sc ;\n<9> InterpretPS ( ps , NULL , & ec , NULL ) ;\n<10> if ( width != NULL ) * width = ec . width ;\n<11> return ( SplinesFromEntityChar ( & ec , & flags , is_stroked ) ) ;
<1> REGRESSION_TEST ( SDK_API_TSHttpHdr ) ( RegressionTest * test , int , int * pstatus ) {\n<31> const char * expected_iobuf = "GET http://www.example.com:2345/abcd/efg/hij.htm HTTP/2.1\r\n\r\n" ;\n<88> methodGet = TSHttpHdrMethodGet ( bufp1 , hdr_loc1 , & length ) ;\n<89> if ( ( strncmp ( methodGet , TS_HTTP_METHOD_GET , length ) == 0 ) && ( length == ( int ) strlen ( TS_HTTP_METHOD_GET ) ) ) {\n<155> response_reason_get = TSHttpHdrReasonGet ( bufp2 , hdr_loc2 , & length ) ;\n<156> if ( ( strncmp ( response_reason_get , response_reason , length ) == 0 ) && ( length == ( int ) strlen ( response_reason ) ) ) {\n<220> if ( strcmp ( "None" , TSHttpHdrReasonLookup ( TS_HTTP_STATUS_NONE ) ) != 0 ) {\n<221> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase1" , TC_FAIL , "TSHttpHdrReasonLookup returns Value's mismatch" ) ;\n<224> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase1" , TC_PASS , "ok" ) ;\n<225> test_passed_Http_Hdr_Reason_Lookup = true ;\n<227> if ( strcmp ( "OK" , TSHttpHdrReasonLookup ( TS_HTTP_STATUS_OK ) ) != 0 ) {\n<228> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase2" , TC_FAIL , "TSHttpHdrReasonLookup returns Value's mismatch" ) ;\n<229> if ( test_passed_Http_Hdr_Reason_Lookup == true ) {\n<234> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase2" , TC_PASS , "ok" ) ;\n<236> if ( strcmp ( "Continue" , TSHttpHdrReasonLookup ( TS_HTTP_STATUS_CONTINUE ) ) != 0 ) {\n<237> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase3" , TC_FAIL , "TSHttpHdrReasonLookup returns Value's mismatch" ) ;\n<238> if ( test_passed_Http_Hdr_Reason_Lookup == true ) {\n<243> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase3" , TC_PASS , "ok" ) ;\n<245> if ( strcmp ( "Not Modified" , TSHttpHdrReasonLookup ( TS_HTTP_STATUS_NOT_MODIFIED ) ) != 0 ) {\n<246> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase4" , TC_FAIL , "TSHttpHdrReasonLookup returns Value's mismatch" ) ;\n<247> if ( test_passed_Http_Hdr_Reason_Lookup == true ) {\n<252> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase4" , TC_PASS , "ok" ) ;\n<254> if ( strcmp ( "Early Hints" , TSHttpHdrReasonLookup ( TS_HTTP_STATUS_EARLY_HINTS ) ) != 0 ) {\n<255> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase5" , TC_FAIL , "TSHttpHdrReasonLookup returns Value's mismatch" ) ;\n<256> if ( test_passed_Http_Hdr_Reason_Lookup == true ) {\n<261> SDK_RPRINT ( test , "TSHttpHdrReasonLookup" , "TestCase5" , TC_PASS , "ok" ) ;\n<469> if ( actual_iobuf == nullptr ) {\n<475> memset ( actual_iobuf , 0 , ( actual_length + 1 ) * sizeof ( char ) ) ;\n<476> bytes_read = 0 ;\n<481> block_start = TSIOBufferBlockReadStart ( iobufblock , iobufreader , & block_size ) ;\n<482> if ( block_size <= 0 ) {\n<485> memcpy ( actual_iobuf + bytes_read , block_start , block_size ) ;\n<486> bytes_read += block_size ;\n<487> TSIOBufferReaderConsume ( iobufreader , block_size ) ;\n<490> if ( strcmp ( actual_iobuf , expected_iobuf ) == 0 ) {\n<491> SDK_RPRINT ( test , "TSHttpHdrPrint" , "TestCase1" , TC_PASS , "ok" ) ;\n<492> test_passed_Http_Hdr_Print = true ;\n<495> SDK_RPRINT ( test , "TSHttpHdrPrint" , "TestCase1" , TC_FAIL , "Value's mismatch" ) ;\n<497> TSfree ( actual_iobuf ) ;
<1> static int qcow_make_empty(BlockDriverState *bs)\n<5> BDRVQcowState *s = bs->opaque;\n<7> uint32_t l1_length = s->l1_size * sizeof(uint64_t);\n<13> memset(s->l1_table, 0, l1_length);\n<15> if (bdrv_pwrite(bs->file, s->l1_table_offset, s->l1_table, l1_length) < 0)\n<21> if (ret < 0)\n<27> memset(s->l2_cache, 0, s->l2_size * L2_CACHE_SIZE * sizeof(uint64_t));\n<29> memset(s->l2_cache_offsets, 0, L2_CACHE_SIZE * sizeof(uint64_t));\n<31> memset(s->l2_cache_counts, 0, L2_CACHE_SIZE * sizeof(uint32_t));
<1> static int sunrast_decode_frame(AVCodecContext *avctx, void *data,\n<71> buf += 32;\n<167> *(uint32_t *)ptr = (buf[x]<<16) + (buf[len+x]<<8) + buf[len+len+x];\n<173> buf += maplength;\n<177> ptr    = p->data[0];\n<187> alen = len + (len&1);\n<239> for (y=0; y<h; y++) {\n<241> memcpy(ptr, buf, len);\n<243> ptr += stride;\n<245> buf += alen;
<1> static void wmv2_add_block(Wmv2Context *w, DCTELEM *block1, uint8_t *dst, int stride, int n){\n<7> switch(w->abt_type_table[n]){\n<23> simple_idct84_add(dst + 4*stride, stride, w->abt_block2[n]);\n<25> memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));\n<33> simple_idct48_add(dst + 4       , stride, w->abt_block2[n]);\n<35> memset(w->abt_block2[n], 0, 64*sizeof(DCTELEM));
<1> int qemuAgentSetUserPassword ( qemuAgentPtr mon , const char * user , const char * password , bool crypted ) {\n<6> if ( ! ( password64 = virStringEncodeBase64 ( ( unsigned char * ) password , strlen ( password ) ) ) ) goto cleanup ;
<1> static void ffmpeg_CopyPicture ( decoder_t * p_dec , picture_t * p_pic , AVFrame * p_ff_pic ) {\n<13> p_src = p_ff_pic -> data [ i_plane ] ;\n<14> p_dst = p_pic -> p [ i_plane ] . p_pixels ;\n<17> i_size = __MIN ( i_src_stride , i_dst_stride ) ;\n<19> i_line < p_pic -> p [ i_plane ] . i_visible_lines ;\n<21> memcpy ( p_dst , p_src , i_size ) ;\n<22> p_src += i_src_stride ;\n<23> p_dst += i_dst_stride ;
<1> void ff_insert_pad(unsigned idx, unsigned *count, size_t padidx_off,\n<5> AVFilterPad *newpad)\n<13> idx = FFMIN(idx, *count);\n<17> *pads  = av_realloc(*pads,  sizeof(AVFilterPad)   * (*count + 1));\n<19> *links = av_realloc(*links, sizeof(AVFilterLink*) * (*count + 1));\n<21> memmove(*pads  + idx + 1, *pads  + idx, sizeof(AVFilterPad)   * (*count - idx));\n<23> memmove(*links + idx + 1, *links + idx, sizeof(AVFilterLink*) * (*count - idx));\n<25> memcpy(*pads + idx, newpad, sizeof(AVFilterPad));
<1> vcard_emul_options(const char *args)\n<13> memcpy(&options, &default_options, sizeof(options));\n<15> opts = &options;\n<59> if (*args != '(') {\n<75> type_params_length = MIN(type_params_length, sizeof(type_str)-1);\n<77> memcpy(type_str, type_params, type_params_length);\n<79> type_str[type_params_length] = '\0';\n<81> type = vcard_emul_type_from_string(type_str);\n<89> if (*args == 0) {\n<119> g_strndup(type_params, type_params_length);\n<121> count = count_tokens(args, ',', ')') + 1;\n<127> for (i = 0; i < count; i++) {\n<131> args = strpbrk(args, ",)");\n<133> vreaderOpt->cert_name[i] = g_strndup(cert, args - cert);\n<135> args = strip(args+1);\n<197> if (*args != '"') {\n<203> args++;\n<207> args = strpbrk(args, "\"\n");\n<209> opts->nss_db = g_strndup(db, args-db);
<1> static void debugCB_print_log ( debugCBContext * q , const char * name ) {\n<2> if ( q == NULL ) {\n<3> printf ( "debugCBontext: %s is NULL!!\n" , name ) ;\n<6> if ( q -> magic != 0xC0FFEE ) {\n<7> fprintf ( stderr , "debugCBContext: %p:%d's magic is %x, supposed to be 0xC0FFEE\n" , q , q -> serial , q -> magic ) ;\n<9> printf ( "debugCBContext %p:%d=%s - magic %x\n" , q , q -> serial , name , q -> magic ) ;
<1> static int qemudParseDriveAddReply ( const char * reply , virDomainDeviceDriveAddressPtr addr ) {\n<3> if ( ! ( s = strstr ( reply , "OK " ) ) ) return - 1 ;\n<4> s += 3 ;\n<5> if ( STRPREFIX ( s , "bus " ) ) {\n<6> s += strlen ( "bus " ) ;\n<7> if ( virStrToLong_ui ( s , & e , 10 , & addr -> bus ) == - 1 ) {\n<17> if ( ! STRPREFIX ( s , "unit " ) ) {\n<21> s += strlen ( "bus " ) ;\n<22> if ( virStrToLong_ui ( s , & e , 10 , & addr -> unit ) == - 1 ) {
<1> static int pefromupx ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 , uint32_t * magic , uint32_t dend ) {\n<6> if ( ( dst == NULL ) || ( src == NULL ) ) return 0 ;\n<23> realstuffsz = imports - dst ;\n<31> while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) {\n<39> if ( ! ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) pehdr = NULL ;\n<49> if ( ! ( realstuffsz = pehdr - dst ) ) pehdr = NULL ;\n<51> if ( ! pehdr ) {\n<52> uint32_t rebsz = PESALIGN ( dend , 0x1000 ) ;\n<54> if ( ! ( newbuf = ( char * ) cli_calloc ( rebsz + 0x200 , sizeof ( char ) ) ) ) {\n<58> memcpy ( newbuf , HEADERS , 0xd0 ) ;\n<59> memcpy ( newbuf + 0xd0 , FAKEPE , 0x120 ) ;\n<60> memcpy ( newbuf + 0x200 , dst , dend ) ;\n<61> memcpy ( dst , newbuf , dend + 0x200 ) ;\n<62> free ( newbuf ) ;\n<63> cli_writeint32 ( dst + 0xd0 + 0x50 , rebsz + 0x1000 ) ;\n<64> cli_writeint32 ( dst + 0xd0 + 0x100 , rebsz ) ;\n<65> cli_writeint32 ( dst + 0xd0 + 0x108 , rebsz ) ;\n<93> if ( ! ( newbuf = ( char * ) cli_calloc ( foffset , sizeof ( char ) ) ) ) {\n<97> memcpy ( newbuf , HEADERS , 0xd0 ) ;\n<98> memcpy ( newbuf + 0xd0 , pehdr , 0xf8 + 0x28 * sectcnt ) ;\n<99> sections = pehdr + 0xf8 ;\n<105> offset2 = ( uint32_t ) cli_readint32 ( sections + 16 ) ;\n<106> if ( offset1 > foffset || offset2 > foffset || offset1 + offset2 > foffset ) {\n<107> free ( newbuf ) ;\n<111> if ( offset3 - upx0 > * dsize ) {\n<112> free ( newbuf ) ;\n<115> memcpy ( newbuf + offset1 , dst + offset3 - upx0 , offset2 ) ;\n<118> if ( foffset > * dsize + 8192 ) {\n<120> free ( newbuf ) ;\n<123> memcpy ( dst , newbuf , foffset ) ;\n<124> * dsize = foffset ;\n<125> free ( newbuf ) ;
<1> static int svq1_encode_plane(SVQ1Context *s, int plane, unsigned char *src_plane, unsigned char *ref_plane, unsigned char *decoded_plane,\n<3> int width, int height, int src_stride, int stride)\n<137> s->m.new_picture.data[0]= src - y*16*stride; //ugly\n<143> for(i=0; i<16 && i + 16*y<height; i++){\n<145> memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n<147> for(x=width; x<16*block_width; x++)\n<153> for(; i<16 && i + 16*y<16*block_height; i++)\n<155> memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n<191> uint8_t src[stride*16];\n<195> for(i=0; i<16 && i + 16*y<height; i++){\n<197> memcpy(&src[i*stride], &src_plane[(i+16*y)*src_stride], width);\n<199> for(x=width; x<16*block_width; x++)\n<205> for(; i<16 && i + 16*y<16*block_height; i++)\n<207> memcpy(&src[i*stride], &src[(i-1)*stride], 16*block_width);\n<267> score[0]+= encode_block(s, src+16*x, NULL, temp, stride, 5, 64, lambda, 1);\n<343> score[1]+= encode_block(s, src+16*x, temp+16, decoded, stride, 5, 64, lambda, 0);\n<351> score[2]= s->dsp.sse[0](NULL, src+16*x, ref, stride, 16);
<1> static inline void copy_context_after_encode ( MpegEncContext * d , MpegEncContext * s , int type ) {\n<3> memcpy ( d -> mv , s -> mv , 2 * 4 * 2 * sizeof ( int ) ) ;\n<4> memcpy ( d -> last_mv , s -> last_mv , 2 * 2 * 2 * sizeof ( int ) ) ;
<1> static void sbr_qmf_synthesis(DSPContext *dsp, FFTContext *mdct,\n<7> float *v0, int *v_off, const unsigned int div)\n<19> if (*v_off == 0) {\n<23> memcpy(&v0[SBR_SYNTHESIS_BUF_SIZE - saved_samples], v0, saved_samples * sizeof(float));\n<33> v = v0 + *v_off;
<1> void evbuffer_free ( struct evbuffer * buffer ) {\n<2> if ( buffer -> orig_buffer != NULL ) free ( buffer -> orig_buffer ) ;\n<3> free ( buffer ) ;
<1> void fe_sendint64 ( int64 i , char * buf ) {\n<4> n32 = htonl ( n32 ) ;\n<5> memcpy ( & buf [ 0 ] , & n32 , 4 ) ;\n<7> n32 = htonl ( n32 ) ;\n<8> memcpy ( & buf [ 4 ] , & n32 , 4 ) ;
<1> static int vnc_zlib_stop(VncState *vs)\n<49> if (err != Z_OK) {\n<51> fprintf(stderr, "VNC: error initializing zlib\n");\n<107> if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n<109> fprintf(stderr, "VNC: error during zlib compression\n");
<1> int test ( char * URL ) {\n<4> for ( i = 0 ;\n<5> dates [ i ] ;\n<6> i ++ ) {\n<7> printf ( "%d: %s => %ld\n" , i , dates [ i ] , ( long ) curl_getdate ( dates [ i ] , NULL ) ) ;
<1> uint32_t pci_default_read_config(PCIDevice *d,\n<7> uint32_t val = 0;\n<11> len = MIN(len, pci_config_size(d) - address);\n<13> memcpy(&val, d->config + address, len);\n<15> return le32_to_cpu(val);
<1> ASN1_BIT_STRING * c2i_ASN1_BIT_STRING ( ASN1_BIT_STRING * * a , const unsigned char * * pp , long len ) {\n<15> i = * ( p ++ ) ;\n<22> if ( len -- > 1 ) {\n<24> if ( s == NULL ) {\n<28> memcpy ( s , p , ( int ) len ) ;\n<29> s [ len - 1 ] &= ( 0xff << i ) ;\n<30> p += len ;\n<35> ret -> data = s ;
<1> static int proc_ioctl ( struct usb_dev_state * ps , struct usbdevfs_ioctl * ctl ) {\n<10> buf = kmalloc ( size , GFP_KERNEL ) ;\n<11> if ( buf == NULL ) return - ENOMEM ;\n<12> if ( ( _IOC_DIR ( ctl -> ioctl_code ) & _IOC_WRITE ) ) {\n<19> memset ( buf , 0 , size ) ;\n<23> kfree ( buf ) ;\n<44> retval = driver -> unlocked_ioctl ( intf , ctl -> ioctl_code , buf ) ;\n<48> if ( retval >= 0 && ( _IOC_DIR ( ctl -> ioctl_code ) & _IOC_READ ) != 0 && size > 0 && copy_to_user ( ctl -> data , buf , size ) != 0 ) retval = - EFAULT ;\n<49> kfree ( buf ) ;
<1> static void _build_alloc_msg ( struct job_record * job_ptr , resource_allocation_response_msg_t * alloc_msg , int error_code , char * job_submit_user_msg ) {\n<3> memset ( alloc_msg , 0 , sizeof ( resource_allocation_response_msg_t ) ) ;\n<4> if ( job_ptr -> job_resrcs && job_ptr -> job_resrcs -> cpu_array_cnt ) {\n<6> alloc_msg -> cpu_count_reps = xmalloc ( sizeof ( uint32_t ) * job_ptr -> job_resrcs -> cpu_array_cnt ) ;\n<7> memcpy ( alloc_msg -> cpu_count_reps , job_ptr -> job_resrcs -> cpu_array_reps , ( sizeof ( uint32_t ) * job_ptr -> job_resrcs -> cpu_array_cnt ) ) ;\n<8> alloc_msg -> cpus_per_node = xmalloc ( sizeof ( uint16_t ) * job_ptr -> job_resrcs -> cpu_array_cnt ) ;\n<9> memcpy ( alloc_msg -> cpus_per_node , job_ptr -> job_resrcs -> cpu_array_value , ( sizeof ( uint16_t ) * job_ptr -> job_resrcs -> cpu_array_cnt ) ) ;\n<28> alloc_msg -> environment = xmalloc ( sizeof ( char * ) * alloc_msg -> env_size ) ;\n<30> i < alloc_msg -> env_size ;\n<49> set_remote_working_response ( alloc_msg , job_ptr , job_ptr -> origin_cluster ) ;
<1> static int adb_send ( socket_handle_t sock , const char * adb_service ) {\n<2> char buffer [ 4 ] ;\n<6> adb_service_length = strlen ( adb_service ) ;\n<7> result = send ( sock , adb_service , ( int ) adb_service_length , 0 ) ;\n<8> if ( result != ( gssize ) adb_service_length ) {\n<13> while ( used_buffer_length < 4 ) {\n<14> result = recv ( sock , buffer + used_buffer_length , ( int ) ( sizeof ( buffer ) - used_buffer_length ) , 0 ) ;\n<15> if ( result <= 0 ) {\n<21> if ( memcmp ( buffer , "OKAY" , 4 ) ) {\n<22> errmsg_print ( "ERROR: Error while receiving by ADB for <%s>" , adb_service ) ;\n<23> return EXIT_CODE_ERROR_WHILE_RECEIVING_ADB_PACKET_DATA ;\n<25> return EXIT_CODE_SUCCESS ;
<1> SCSIDevice *scsi_disk_init(BlockDriverState *bdrv, int tcq,\n<14> s = (SCSIDeviceState *)qemu_mallocz(sizeof(SCSIDeviceState));\n<44> strncpy(s->drive_serial_str, drive_get_serial(s->bdrv),\n<48> if (strlen(s->drive_serial_str) == 0)\n<50> pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), "0");\n<52> qemu_add_vm_change_state_handler(scsi_dma_restart_cb, s);\n<56> d->state = s;
<1> static int mpeg_decode_mb(MpegEncContext *s, int16_t block[12][64])\n<173> s->qscale = get_qscale(s);\n<177> if (s->concealment_motion_vectors) {\n<211> memset(s->last_mv, 0, sizeof(s->last_mv));\n<221> ff_xvmc_pack_pblocks(s, -1); // inter are always full blocks\n<231> mpeg2_fast_decode_block_intra(s, *s->pblocks[i], i);\n<237> if ((ret = mpeg2_decode_block_intra(s, *s->pblocks[i], i)) < 0)
<1> static gpgme_error_t status_handler ( void * opaque , int fd ) {\n<8> err = assuan_read_line ( uiserver -> assuan_ctx , & line , & linelen ) ;\n<12> else if ( linelen >= 3 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && ( line [ 3 ] == '\0' || line [ 3 ] == ' ' ) ) {\n<13> if ( line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n<17> else if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\0' || line [ 2 ] == ' ' ) ) {\n<27> else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> colon . fnc ) {\n<33> if ( uiserver -> colon . attic . linesize < * alinelen + linelen + 1 ) {\n<34> char * newline = realloc ( * aline , * alinelen + linelen + 1 ) ;\n<35> if ( ! newline ) err = gpg_error_from_syserror ( ) ;\n<37> * aline = newline ;\n<42> dst = * aline + * alinelen ;\n<58> err = uiserver -> colon . fnc ( uiserver -> colon . fnc_value , * aline ) ;\n<70> else if ( linelen > 2 && line [ 0 ] == 'D' && line [ 1 ] == ' ' && uiserver -> inline_data ) {\n<98> else if ( linelen > 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n<101> rest = strchr ( line + 2 , ' ' ) ;\n<102> if ( ! rest ) rest = line + linelen ;\n<103> else * ( rest ++ ) = 0 ;\n<105> if ( r >= 0 ) {\n<108> else fprintf ( stderr , "[UNKNOWN STATUS]%s %s" , line + 2 , rest ) ;\n<111> else if ( linelen >= 7 && line [ 0 ] == 'I' && line [ 1 ] == 'N' && line [ 2 ] == 'Q' && line [ 3 ] == 'U' && line [ 4 ] == 'I' && line [ 5 ] == 'R' && line [ 6 ] == 'E' && ( line [ 7 ] == '\0' || line [ 7 ] == ' ' ) ) {
<1> static void pass1 ( vpx_image_t * raw , FILE * infile , const char * outfile_name , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n<9> int frame_count = 0 ;\n<15> encode_frame ( & codec , raw , frame_count , 1 , 0 , VPX_DL_GOOD_QUALITY , writer ) ;\n<19> printf ( "\n" ) ;\n<22> printf ( "Pass 1 complete. Processed %d frames.\n" , frame_count ) ;
<1> int qemuMonitorTextSetBalloon ( qemuMonitorPtr mon , unsigned long newmem ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<15> if ( strstr ( reply , "unknown command:" ) ) {\n<16> ret = 0 ;\n<19> ret = 1 ;\n<21> VIR_FREE ( reply ) ;
<1> static fz_path * xps_parse_abbreviated_geometry ( xps_document * doc , char * geom , int * fill_rule ) {\n<12> path = fz_new_path ( doc -> ctx ) ;\n<13> args = fz_malloc_array ( doc -> ctx , strlen ( geom ) + 1 , sizeof ( char * ) ) ;\n<14> pargs = args ;\n<28> n = pargs - args ;\n<49> fz_moveto ( doc -> ctx , path , fz_atof ( args [ i ] ) , fz_atof ( args [ i + 1 ] ) ) ;\n<53> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<58> fz_lineto ( doc -> ctx , path , fz_atof ( args [ i ] ) , fz_atof ( args [ i + 1 ] ) ) ;\n<62> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<67> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<72> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<77> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<82> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<93> fz_curveto ( doc -> ctx , path , x1 , y1 , x2 , y2 , x3 , y3 ) ;\n<100> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<114> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<126> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<138> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<147> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<156> xps_draw_arc ( doc -> ctx , path , fz_atof ( args [ i + 0 ] ) , fz_atof ( args [ i + 1 ] ) , fz_atof ( args [ i + 2 ] ) , atoi ( args [ i + 3 ] ) , atoi ( args [ i + 4 ] ) , fz_atof ( args [ i + 5 ] ) , fz_atof ( args [ i + 6 ] ) ) ;\n<160> pt = fz_currentpoint ( doc -> ctx , path ) ;\n<164> case 'Z' : case 'z' : fz_closepath ( doc -> ctx , path ) ;\n<166> default : fz_warn ( doc -> ctx , "ignoring invalid command '%c'" , cmd ) ;\n<172> fz_free ( doc -> ctx , args ) ;
<1> static void test_bug21635 ( ) {\n<16> ++ i ) query_end = strxmov ( query_end , expr [ i * 2 ] , ", " , NullS ) ;\n<34> i < field_count ;\n<36> field = mysql_fetch_field_direct ( result , i ) ;\n<37> if ( ! opt_silent ) if ( ! opt_silent ) printf ( "%s -> %s ... " , expr [ i * 2 ] , field -> name ) ;\n<40> DIE_UNLESS ( strcmp ( field -> name , expr [ i * 2 + 1 ] ) == 0 ) ;
<1> static DeviceInfo * qdev_find_info ( BusInfo * bus_info , const char * name ) {\n<4> info != NULL ;\n<5> info = info -> next ) {\n<6> if ( bus_info && info -> bus_info != bus_info ) continue ;\n<7> if ( strcmp ( info -> name , name ) != 0 ) continue ;\n<8> return info ;\n<11> info != NULL ;\n<12> info = info -> next ) {\n<14> if ( ! info -> alias ) continue ;\n<15> if ( strcmp ( info -> alias , name ) != 0 ) continue ;\n<16> return info ;
<1> static int dirac_decode_frame_internal(DiracContext *s)\n<17> for (comp = 0; comp < 3; comp++) {\n<19> Plane *p = &s->plane[comp];\n<21> memset(p->idwt_buf, 0, p->idwt_stride * p->idwt_height * sizeof(IDWTELEM));\n<39> Plane *p       = &s->plane[comp];\n<53> if (!s->zero_res && !s->low_delay)\n<57> memset(p->idwt_buf, 0, p->idwt_stride * p->idwt_height * sizeof(IDWTELEM));\n<59> decode_component(s, comp); /* [DIRAC_STD] 13.4.1 core_transform_data() */\n<63> ret = ff_spatial_idwt_init2(&d, p->idwt_buf, p->idwt_width, p->idwt_height, p->idwt_stride,\n<73> if (!s->num_refs) { /* intra */\n<91> select_dsp_funcs(s, p->width, p->height, p->xblen, p->yblen);\n<97> interpolate_refplane(s, s->ref_pics[i], comp, p->width, p->height);\n<101> memset(s->mctmp, 0, 4*p->yoffset*p->stride);\n<113> uint16_t *mctmp    = s->mctmp + y*rowheight;\n<119> init_obmc_weights(s, p, y);\n<131> if (h < 0)\n<137> memset(mctmp+2*p->yoffset*p->stride, 0, 2*rowheight);\n<139> mc_row(s, blocks, mctmp, comp, dsty);
<1> static void xps_parse_poly_quadratic_bezier_segment ( fz_context * doc , fz_path * path , fz_xml * root , int stroking , int * skipped_stroke ) {\n<3> char * is_stroked_att = fz_xml_att ( root , "IsStroked" ) ;\n<9> if ( ! points_att ) {\n<14> if ( is_stroked_att && ! strcmp ( is_stroked_att , "false" ) ) is_stroked = 0 ;
<1> bool appendReloptionsArray ( PQExpBuffer buffer , const char * reloptions , const char * prefix , int encoding , bool std_strings ) {\n<5> if ( ! parsePGArray ( reloptions , & options , & noptions ) ) {\n<6> if ( options ) free ( options ) ;\n<10> i < noptions ;\n<12> char * option = options [ i ] ;\n<17> separator = strchr ( option , '=' ) ;\n<20> value = separator + 1 ;\n<25> if ( strcmp ( fmtId ( value ) , value ) == 0 ) appendPQExpBufferStr ( buffer , value ) ;\n<26> else appendStringLiteral ( buffer , value , encoding , std_strings ) ;\n<28> if ( options ) free ( options ) ;
<1> static inline void decode2x2 ( GetBitContext * gb , uint8_t * dst , int linesize ) {\n<2> int i , j , v [ 2 ] ;\n<4> case 1 : v [ 0 ] = get_bits ( gb , 8 ) ;\n<6> j < 2 ;\n<7> j ++ ) memset ( dst + j * linesize , v [ 0 ] , 2 ) ;
<1> static int rdma_delete_block(RDMAContext *rdma, RDMALocalBlock *block)\n<5> RDMALocalBlocks *local = &rdma->local_ram_blocks;\n<7> RDMALocalBlock *old = local->block;\n<101> local->block = g_malloc0(sizeof(RDMALocalBlock) *\n<107> if (block->index) {\n<109> memcpy(local->block, old, sizeof(RDMALocalBlock) * block->index);\n<115> if (block->index < (local->nb_blocks - 1)) {\n<117> memcpy(local->block + block->index, old + (block->index + 1),\n<147> g_free(old);
<1> static void test_event_base_new ( void ) {\n<5> write ( pair [ 0 ] , TEST1 , strlen ( TEST1 ) + 1 ) ;\n<6> shutdown ( pair [ 0 ] , SHUT_WR ) ;
<1> static int jacosub_read_header(AVFormatContext *s)\n<47> const char *p = line;\n<51> int len = ff_get_line(pb, line, sizeof(line));\n<61> if (merge_line || timed_line(p)) {\n<67> sub = ff_subtitles_queue_insert(&jacosub->q, line, len, merge_line);\n<69> if (!sub)\n<75> merge_line = len > 1 && !strcmp(&line[len - 2], "\\\n");\n<93> if (i == -1)\n<101> cmd_len = strlen(cmds[i]);\n<103> if (av_strncasecmp(p, cmds[i], cmd_len) == 0)
<1> static void channel_out_run(struct fs_dma_ctrl *ctrl, int c)\n<13> if (ctrl->channels[c].eol == 1)\n<19> saved_data_buf = channel_reg(ctrl, c, RW_SAVED_DATA_BUF);\n<23> D(fprintf(logfile, "ch=%d buf=%x after=%x saved_data_buf=%x\n",\n<37> len -= saved_data_buf;\n<45> cpu_physical_memory_read (saved_data_buf, buf, len);\n<49> D(printf("channel %d pushes %x %u bytes\n", c,\n<55> if (ctrl->channels[c].client->client.push)\n<63> printf("WARNING: DMA ch%d dataloss, no attached client.\n", c);\n<67> saved_data_buf += len;\n<77> if (ctrl->channels[c].current_d.out_eop) {\n<81> D(printf("signal eop\n"));\n<85> if (ctrl->channels[c].current_d.intr) {\n<91> D(printf("signal intr\n"));\n<95> channel_update_irq(ctrl, c);\n<99> if (ctrl->channels[c].current_d.eol) {\n<101> D(printf("channel %d EOL\n", c));\n<111> channel_store_c(ctrl, c);\n<125> channel_load_d(ctrl, c);
<1> void _TIFFmemcpy ( tdata_t d , const tdata_t s , tsize_t c ) {\n<2> memcpy ( d , s , ( size_t ) c ) ;
<1> char * FLTGetExpressionForValuesRanges ( layerObj * lp , const char * item , const char * value , int forcecharcter ) {\n<6> if ( lp && item && value ) {\n<7> if ( strstr ( value , "/" ) == NULL ) {\n<8> paszElements = msStringSplit ( value , ',' , & numelements ) ;\n<9> if ( paszElements && numelements > 0 ) {\n<38> pszEscapedStr = NULL ;\n<39> if ( pszExpression != NULL ) pszExpression = msStringConcatenate ( pszExpression , " OR " ) ;\n<46> msFreeCharArray ( paszElements , numelements ) ;\n<49> paszElements = msStringSplit ( value , ',' , & numelements ) ;\n<50> if ( paszElements && numelements > 0 ) {\n<69> pszEscapedStr = NULL ;\n<81> pszEscapedStr = NULL ;\n<96> pszEscapedStr = NULL ;\n<99> if ( pszExpression != NULL ) pszExpression = msStringConcatenate ( pszExpression , " OR " ) ;\n<108> msFreeCharArray ( paszElements , numelements ) ;
<1> static CURLcode AddFormData ( struct FormData * * formp , enum formtype type , const void * line , size_t length , curl_off_t * size ) {\n<2> struct FormData * newform = malloc ( sizeof ( struct FormData ) ) ;\n<3> if ( ! newform ) return CURLE_OUT_OF_MEMORY ;\n<4> newform -> next = NULL ;\n<5> if ( type <= FORM_CONTENT ) {\n<6> if ( ! length ) length = strlen ( ( char * ) line ) ;\n<7> newform -> line = malloc ( length + 1 ) ;\n<8> if ( ! newform -> line ) {\n<9> free ( newform ) ;\n<12> memcpy ( newform -> line , line , length ) ;\n<13> newform -> length = length ;\n<19> ( * formp ) -> next = newform ;\n<20> * formp = newform ;\n<22> else * formp = newform ;\n<24> if ( type != FORM_FILE ) * size += length ;\n<26> if ( ! strequal ( "-" , newform -> line ) ) {\n<28> if ( ! stat ( newform -> line , & file ) && ! S_ISDIR ( file . st_mode ) ) * size += filesize ( newform -> line , file ) ;
<1> static void test_1 ( void ) {\n<10> empty_elements [ i ] ;\n<12> err = ksba_dn_str2der ( empty_elements [ i ] , & buf , & len ) ;\n<14> err = ksba_dn_teststr ( empty_elements [ i ] , 0 , & off , & len ) ;\n<16> printf ( "string ->%s<- error at %lu.%lu (%.*s)\n" , empty_elements [ i ] , ( unsigned long ) off , ( unsigned long ) len , ( int ) len , empty_elements [ i ] + off ) ;
<1> static int xan_decode_chroma(AVCodecContext *avctx, AVPacket *avpkt)\n<7> XanContext *s = avctx->priv_data;\n<49> if (src - avpkt->data >= avpkt->size - offset) {\n<59> memset(s->scratch_buffer, 0, s->buffer_size);\n<61> dec_size = xan_unpack(s->scratch_buffer, s->buffer_size, src + offset,
<1> static inline void put_pixels8x8_overlapped ( uint8_t * dst , uint8_t * src , int stride ) {\n<2> uint8_t tmp [ 64 ] ;\n<5> i < 8 ;\n<6> i ++ ) memcpy ( tmp + i * 8 , src + i * stride , 8 ) ;\n<8> i < 8 ;\n<9> i ++ ) memcpy ( dst + i * stride , tmp + i * 8 , 8 ) ;
<1> static int bfi_decode_frame(AVCodecContext * avctx, void *data,\n<17> uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n<35> if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n<213> src = bfi->dst;\n<215> dst = bfi->frame.data[0];\n<217> while (height--) {\n<219> memcpy(dst, src, avctx->width);\n<221> src += avctx->width;\n<223> dst += bfi->frame.linesize[0];
<1> static void compact_print_section_header ( WriterContext * wctx ) {\n<2> CompactContext * compact = wctx -> priv ;\n<3> const struct section * section = wctx -> section [ wctx -> level ] ;\n<15> if ( parent_section && compact -> has_nested_elems [ wctx -> level - 1 ] && ( section -> flags & SECTION_FLAG_IS_ARRAY ) ) {\n<17> printf ( "\n" ) ;\n<19> if ( compact -> print_section && ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "%s%c" , section -> name , compact -> item_sep ) ;
<1> static void pdf_gsave ( fz_context * ctx , pdf_run_processor * pr ) {\n<3> pr -> gstate = fz_resize_array ( ctx , pr -> gstate , pr -> gcap * 2 , sizeof ( pdf_gstate ) ) ;\n<6> memcpy ( & pr -> gstate [ pr -> gtop + 1 ] , & pr -> gstate [ pr -> gtop ] , sizeof ( pdf_gstate ) ) ;\n<8> pdf_keep_gstate ( ctx , & pr -> gstate [ pr -> gtop ] ) ;
<1> static byte * i_resize_string ( gs_memory_t * mem , byte * data , uint old_num , uint new_num , client_name_t cname ) {\n<5> data -= HDR_ID_OFFSET ;\n<8> if ( imem -> cc && data == imem -> cc -> ctop && ( new_num < old_num || imem -> cc -> ctop - imem -> cc -> cbot > new_num - old_num ) ) {\n<9> ptr = data + old_num - new_num ;\n<12> memmove ( ptr , data , min ( old_num , new_num ) ) ;\n<16> ASSIGN_HDR_ID ( ptr ) ;\n<27> data += HDR_ID_OFFSET ;\n<31> if ( ptr == 0 ) return 0 ;\n<32> memcpy ( ptr , data , min ( old_num , new_num ) ) ;\n<33> gs_free_string ( mem , data , old_num , cname ) ;\n<35> return ptr ;
<1> static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<34> ptr    = p->data[0];\n<37> if (buf_end - buf < w * bytes_per_pixel)\n<44> memcpy(ptr, buf, w*bytes_per_pixel);\n<46> ptr += stride;\n<47> buf += w*bytes_per_pixel;
<1> static int dirac_unpack_prediction_parameters(DiracContext *s)\n<115> if (s->globalmc_flag) {\n<117> memset(s->globalmc, 0, sizeof(s->globalmc));
<1> static void ctl_putts ( const char * tag , l_fp * ts ) {\n<10> snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , "0x%08x.%08x" , ( u_int ) ts -> l_ui , ( u_int ) ts -> l_uf ) ;\n<11> cp += strlen ( cp ) ;\n<12> ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;
<1> static void vnc_dpy_resize(DisplayChangeListener *dcl,\n<47> memset(vd->guest.dirty, 0xFF, sizeof(vd->guest.dirty));\n<55> vnc_desktop_resize(vs);\n<59> vnc_cursor_define(vs);\n<63> memset(vs->dirty, 0xFF, sizeof(vs->dirty));
<1> static void ctl_putadr ( const char * tag , u_int32 addr32 , sockaddr_u * addr ) {\n<12> snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , "%s" , cq ) ;\n<13> cp += strlen ( cp ) ;\n<14> ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;
<1> static int ehci_process_itd(EHCIState *ehci,\n<118> ehci->ipacket.status = USB_RET_NAK;\n<127> switch (ehci->ipacket.status) {\n<135> fprintf(stderr, "Unexpected iso usb result: %d\n",
<1> static int qemu_savevm_state(QEMUFile *f)\n<23> for(se = first_se; se != NULL; se = se->next) {\n<25> if (se->save_state == NULL)\n<35> len = strlen(se->idstr);\n<37> qemu_put_byte(f, len);\n<39> qemu_put_buffer(f, (uint8_t *)se->idstr, len);
<1> static int rtp_read_header(AVFormatContext *s)\n<109> if (ff_rtp_get_codec_info(&codec, payload_type)) {\n<133> av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &port,\n<151> av_log(s, AV_LOG_VERBOSE, "SDP:\n%s\n", sdp);\n<155> ffio_init_context(&pb, sdp, strlen(sdp), 0, NULL, NULL, NULL, NULL);\n<157> s->pb = &pb;\n<173> s->pb = NULL;
<1> void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,\n<43> if (mc->legacy_fw_cfg_order) {\n<67> index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0;\n<69> index--);\n<105> memset(&s->files->f[index], 0, sizeof(FWCfgFile));\n<107> memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));\n<111> pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);\n<115> if (i != index &&\n<117> strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {
<1> debugCBContext * debugCB_openContext ( ) {\n<3> ctx = malloc ( sizeof ( debugCBContext ) ) ;
<1> static int curl_open(BlockDriverState *bs, QDict *options, int flags,\n<215> s->url = g_strdup(file);\n<251> curl_easy_setopt(state->curl, CURLOPT_HEADERDATA, s);\n<283> if (d <= 0) {\n<301> if ((!strncasecmp(s->url, "http://", strlen("http://"))\n<303> || !strncasecmp(s->url, "https://", strlen("https://")))\n<305> && !s->accept_range) {\n<307> pstrcpy(state->errmsg, CURL_ERROR_SIZE,\n<319> qemu_mutex_lock(&s->mutex);\n<321> curl_clean_state(state);\n<323> qemu_mutex_unlock(&s->mutex);\n<325> curl_easy_cleanup(state->curl);\n<327> state->curl = NULL;\n<331> curl_attach_aio_context(bs, bdrv_get_aio_context(bs));\n<335> qemu_opts_del(opts);\n<337> return 0;\n<343> error_setg(errp, "CURL: Error opening file: %s", state->errmsg);\n<345> curl_easy_cleanup(state->curl);\n<347> state->curl = NULL;\n<351> qemu_mutex_destroy(&s->mutex);\n<353> g_free(s->cookie);\n<355> g_free(s->url);\n<357> qemu_opts_del(opts);\n<359> return -EINVAL;
<1> static void set_date_time_null ( unsigned char * p ) {\n<2> memset ( p , '0' , 16 ) ;
<1> static int capture_android_wifi_tcpdump ( char * interface , char * fifo , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n<3> static char data [ PACKET_LENGTH ] ;\n<6> gssize used_buffer_length = 0 ;\n<15> static char filter_buffer [ PACKET_LENGTH ] ;\n<21> if ( is_specified_interface ( interface , INTERFACE_ANDROID_WIFI_TCPDUMP ) && strlen ( interface ) > strlen ( INTERFACE_ANDROID_WIFI_TCPDUMP ) + 1 ) {\n<22> serial_number = interface + strlen ( INTERFACE_ANDROID_WIFI_TCPDUMP ) + 1 ;\n<24> if ( ! serial_number ) {\n<35> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + strlen ( serial_number ) , serial_number ) ;\n<48> result = adb_send ( sock , adb_shell_tcpdump ) ;\n<55> while ( endless_loop ) {\n<58> length = recv ( sock , data + used_buffer_length , ( int ) ( PACKET_LENGTH - used_buffer_length ) , 0 ) ;\n<62> else if ( errno != 0 ) {\n<63> errmsg_print ( "ERROR capture: %s" , strerror ( errno ) ) ;\n<66> if ( length <= 0 ) {\n<68> closesocket ( sock ) ;\n<72> if ( used_buffer_length > 4 ) {\n<74> magic_number = ( guint * ) data ;\n<75> if ( * magic_number == 0xd4c3b2a1 || * magic_number == 0xa1b2c3d4 ) {\n<76> if ( data [ 0 ] == ( char ) 0xd4 ) {\n<85> i_position = ( char * ) memchr ( data , '\n' , used_buffer_length ) ;\n<86> if ( i_position && i_position < data + used_buffer_length ) {\n<87> memmove ( data , i_position + 1 , used_buffer_length - ( i_position + 1 - data ) ) ;\n<88> used_buffer_length = used_buffer_length - ( gssize ) ( i_position + 1 - data ) ;\n<95> i < ( used_buffer_length - 1 ) ;\n<97> if ( data [ i ] == 0x0d && data [ i + 1 ] == 0x0a ) {\n<100> filter_buffer [ filter_buffer_length ++ ] = data [ i ] ;\n<105> data [ j ] = data [ i ] ;\n<107> used_buffer_length = j ;\n<108> if ( global_header_skipped == FALSE && filter_buffer_length >= PCAP_GLOBAL_HEADER_LENGTH ) {\n<109> filter_buffer_length -= PCAP_GLOBAL_HEADER_LENGTH ;\n<110> memmove ( filter_buffer , filter_buffer + PCAP_GLOBAL_HEADER_LENGTH , filter_buffer_length ) ;\n<113> else if ( global_header_skipped && filter_buffer_length > PCAP_RECORD_HEADER_LENGTH ) {\n<115> while ( filter_buffer_length > PCAP_RECORD_HEADER_LENGTH ) {\n<117> packet = filter_buffer + read_offset ;\n<127> if ( ( gssize ) ( p_header . incl_len + PCAP_RECORD_HEADER_LENGTH ) <= filter_buffer_length ) {\n<139> if ( read_offset != 0 ) {\n<140> memmove ( filter_buffer , filter_buffer + read_offset , filter_buffer_length ) ;\n<143> while ( endless_loop ) {\n<145> length = recv ( sock , data + used_buffer_length , ( int ) ( PACKET_LENGTH - ( used_buffer_length + filter_buffer_length ) ) , 0 ) ;\n<149> else if ( errno != 0 ) {\n<150> errmsg_print ( "ERROR capture: %s" , strerror ( errno ) ) ;\n<153> if ( length <= 0 ) {\n<155> closesocket ( sock ) ;\n<158> if ( used_buffer_length += length > 1 ) {\n<163> closesocket ( sock ) ;
<1> static int chacha_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * inp , size_t len ) {\n<2> EVP_CHACHA_KEY * key = data ( ctx ) ;\n<6> * out ++ = * inp ++ ^ key -> buf [ n ++ ] ;\n<36> if ( rem ) {\n<37> memset ( key -> buf , 0 , sizeof ( key -> buf ) ) ;\n<38> ChaCha20_ctr32 ( key -> buf , key -> buf , CHACHA_BLK_SIZE , key -> key . d , key -> counter ) ;
<1> static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n<2> gx_ttfReader * r = ( gx_ttfReader * ) self ;\n<6> q = r -> glyph_data . bits . data + r -> pos ;\n<7> r -> error = ( ( r -> pos >= r -> glyph_data . bits . size || r -> glyph_data . bits . size - r -> pos < n ) ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n<8> if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n<14> cnt += r -> error ) {\n<15> r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;\n<17> else if ( r -> error == 0 ) {\n<18> memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n<22> memcpy ( ( char * ) p + cnt , q , r -> error ) ;\n<27> if ( r -> error ) {\n<28> memset ( p , 0 , n ) ;\n<31> r -> pos += n ;
<1> rfbBool rfbSendLastRectMarker ( rfbClientPtr cl ) {\n<3> if ( cl -> ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE ) {\n<4> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n<6> rect . encoding = Swap32IfLE ( rfbEncodingLastRect ) ;\n<11> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ;\n<12> cl -> ublen += sz_rfbFramebufferUpdateRectHeader ;\n<13> rfbStatRecordEncodingSent ( cl , rfbEncodingLastRect , sz_rfbFramebufferUpdateRectHeader , sz_rfbFramebufferUpdateRectHeader ) ;
<1> void debugCB_fromU ( const void * context , UConverterFromUnicodeArgs * fromUArgs , const UChar * codeUnits , int32_t length , UChar32 codePoint , UConverterCallbackReason reason , UErrorCode * err ) {\n<2> debugCBContext * ctx = ( debugCBContext * ) context ;\n<5> fprintf ( stderr , "debugCB_fromU: Context %p:%d magic is 0x%x should be 0xC0FFEE.\n" , ctx , ctx -> serial , ctx -> magic ) ;
<1> unpeer_node * create_unpeer_node ( address_node * addr ) {\n<8> if ( ! * pch && 1 == sscanf ( addr -> address , "%u" , & u ) && u <= ASSOCID_MAX ) {\n<9> my_node -> assocID = ( associd_t ) u ;\n<10> destroy_address_node ( addr ) ;\n<11> my_node -> addr = NULL ;\n<14> my_node -> assocID = 0 ;\n<15> my_node -> addr = addr ;
<1> static void xps_parse_path_figure ( fz_context * doc , fz_path * path , fz_xml * root , int stroking ) {\n<11> is_closed_att = fz_xml_att ( root , "IsClosed" ) ;\n<13> is_filled_att = fz_xml_att ( root , "IsFilled" ) ;\n<14> if ( is_closed_att ) is_closed = ! strcmp ( is_closed_att , "true" ) ;\n<15> if ( is_filled_att ) is_filled = ! strcmp ( is_filled_att , "true" ) ;\n<17> if ( ! stroking && ! is_filled ) return ;\n<20> node ;\n<22> if ( ! strcmp ( fz_xml_tag ( node ) , "ArcSegment" ) ) xps_parse_arc_segment ( doc , path , node , stroking , & skipped_stroke ) ;\n<23> if ( ! strcmp ( fz_xml_tag ( node ) , "PolyBezierSegment" ) ) xps_parse_poly_bezier_segment ( doc , path , node , stroking , & skipped_stroke ) ;\n<24> if ( ! strcmp ( fz_xml_tag ( node ) , "PolyLineSegment" ) ) xps_parse_poly_line_segment ( doc , path , node , stroking , & skipped_stroke ) ;\n<25> if ( ! strcmp ( fz_xml_tag ( node ) , "PolyQuadraticBezierSegment" ) ) xps_parse_poly_quadratic_bezier_segment ( doc , path , node , stroking , & skipped_stroke ) ;
<1> int swri_dither_init(SwrContext *s, enum AVSampleFormat out_fmt, enum AVSampleFormat in_fmt)\n<11> if (s->dither.method > SWR_DITHER_TRIANGULAR_HIGHPASS && s->dither.method <= SWR_DITHER_NS)\n<53> memset(s->dither.ns_errors, 0, sizeof(s->dither.ns_errors));
<1> static void lm32_uclinux_init(MachineState *machine)\n<9> const char *kernel_cmdline = machine->kernel_cmdline;\n<81> cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));\n<83> if (cpu == NULL) {\n<85> fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model);\n<165> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<185> if (kernel_size < 0) {\n<187> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<229> if (kernel_cmdline && strlen(kernel_cmdline)) {\n<231> pstrcpy_targphys("cmdline", cmdline_base, TARGET_PAGE_SIZE,\n<235> reset_info->cmdline_base = cmdline_base;
<1> relpRetVal relpTcpLstnInit ( relpTcp_t * pThis , unsigned char * pLstnPort , int ai_family ) {\n<11> memset ( & hints , 0 , sizeof ( hints ) ) ;\n<15> error = getaddrinfo ( NULL , ( char * ) pLstnPt , & hints , & res ) ;\n<23> pThis -> socks = malloc ( ( maxs + 1 ) * sizeof ( int ) ) ;\n<24> if ( pThis -> socks == NULL ) {
<1> bool chal_reply_h ( connection_t * c ) {\n<2> char hishash [ MAX_STRING_SIZE ] ;\n<3> char myhash [ EVP_MAX_MD_SIZE ] ;\n<5> if ( sscanf ( c -> buffer , "%*d " MAX_STRING , hishash ) != 1 ) {\n<9> if ( strlen ( hishash ) != ( size_t ) EVP_MD_size ( c -> outdigest ) * 2 ) {\n<10> logger ( LOG_ERR , "Possible intruder %s (%s): %s" , c -> name , c -> hostname , "wrong challenge reply length" ) ;\n<11> return false ;\n<13> if ( ! hex2bin ( hishash , hishash , EVP_MD_size ( c -> outdigest ) ) ) {\n<21> if ( ! EVP_DigestInit ( ctx , c -> outdigest ) || ! EVP_DigestUpdate ( ctx , c -> hischallenge , RSA_size ( c -> rsa_key ) ) || ! EVP_DigestFinal ( ctx , ( unsigned char * ) myhash , NULL ) ) {\n<27> if ( memcmp ( hishash , myhash , EVP_MD_size ( c -> outdigest ) ) ) {\n<28> logger ( LOG_ERR , "Possible intruder %s (%s): %s" , c -> name , c -> hostname , "wrong challenge reply" ) ;\n<29> ifdebug ( SCARY_THINGS ) {\n<30> bin2hex ( myhash , hishash , SHA_DIGEST_LENGTH ) ;\n<31> hishash [ SHA_DIGEST_LENGTH * 2 ] = '\0' ;\n<32> logger ( LOG_DEBUG , "Expected challenge reply: %s" , hishash ) ;\n<34> return false ;\n<36> c -> allow_request = ACK ;\n<37> if ( ! c -> outgoing ) {\n<40> return send_ack ( c ) ;
<1> int net_slirp_smb(const char *exported_dir)\n<9> if (legacy_smb_export) {\n<11> fprintf(stderr, "-smb given twice\n");
<1> rfbClientIteratorPtr rfbGetClientIterator ( rfbScreenInfoPtr rfbScreen ) {\n<2> rfbClientIteratorPtr i = ( rfbClientIteratorPtr ) malloc ( sizeof ( struct rfbClientIterator ) ) ;\n<6> return i ;
<1> SwsContext *getSwsContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags,\n<41> if(!isSupportedIn(srcFormat))\n<45> fprintf(stderr, "swScaler: %s is not supported as input format\n", vo_format_name(srcFormat));\n<51> if(!isSupportedOut(dstFormat))\n<55> fprintf(stderr, "swScaler: %s is not supported as output format\n", vo_format_name(dstFormat));\n<65> if(srcW<4 || srcH<1 || dstW<8 || dstH<1) //FIXME check if these are enough and try to lowwer them after fixing the relevant parts of the code\n<69> fprintf(stderr, "swScaler: %dx%d -> %dx%d is invalid scaling dimension\n",\n<85> c= memalign(64, sizeof(SwsContext));\n<87> memset(c, 0, sizeof(SwsContext));\n<91> c->srcW= srcW;\n<93> c->srcH= srcH;\n<95> c->dstW= dstW;\n<97> c->dstH= dstH;\n<165> if(flags&SWS_PRINT_INFO)\n<167> printf("SwScaler: using unscaled %s -> %s special converter\n",\n<169> vo_format_name(srcFormat), vo_format_name(dstFormat));\n<171> return c;\n<187> if(flags&SWS_PRINT_INFO)\n<189> printf("SwScaler: using unscaled %s -> %s special converter\n",\n<191> vo_format_name(srcFormat), vo_format_name(dstFormat));\n<193> return c;\n<211> if(flags&SWS_PRINT_INFO)\n<213> printf("SwScaler: using unscaled %s -> %s special converter\n",\n<215> vo_format_name(srcFormat), vo_format_name(dstFormat));\n<217> return c;\n<235> if(flags&SWS_PRINT_INFO)\n<237> printf("SwScaler: using unscaled %s -> %s special converter\n",\n<239> vo_format_name(srcFormat), vo_format_name(dstFormat));\n<241> return c;\n<257> if(flags&SWS_PRINT_INFO)\n<259> printf("SwScaler: using unscaled %s -> %s special converter\n",\n<261> vo_format_name(srcFormat), vo_format_name(dstFormat));\n<263> return c;\n<279> if(flags&SWS_PRINT_INFO)\n<281> printf("SwScaler: using unscaled %s -> %s special converter\n",\n<283> vo_format_name(srcFormat), vo_format_name(dstFormat));\n<285> return c;\n<299> if(!c->canMMX2BeUsed && dstW >=srcW && (srcW&15)==0 && (flags&SWS_FAST_BILINEAR))\n<303> if(flags&SWS_PRINT_INFO)\n<305> fprintf(stderr, "SwScaler: output Width is not a multiple of 32 -> no MMX2 scaler\n");\n<357> c->chrXInc= ((c->chrSrcW<<16) + (c->chrDstW>>1))/c->chrDstW;\n<359> c->chrYInc= ((c->chrSrcH<<16) + (c->chrDstH>>1))/c->chrDstH;\n<385> c->lumXInc+= 20;\n<387> c->chrXInc+= 20;\n<399> c->chrXInc = ((c->chrSrcW-2)<<16)/(c->chrDstW-2) - 20;\n<415> initFilter(&c->hLumFilter, &c->hLumFilterPos, &c->hLumFilterSize, c->lumXInc,\n<421> initFilter(&c->hChrFilter, &c->hChrFilterPos, &c->hChrFilterSize, c->chrXInc,\n<455> initFilter(&c->vLumFilter, &c->vLumFilterPos, &c->vLumFilterSize, c->lumYInc,\n<461> initFilter(&c->vChrFilter, &c->vChrFilterPos, &c->vChrFilterSize, c->chrYInc,\n<471> c->vLumBufSize= c->vLumFilterSize;\n<473> c->vChrBufSize= c->vChrFilterSize;\n<479> int chrI= i*c->chrDstH / dstH;\n<481> int nextSlice= MAX(c->vLumFilterPos[i   ] + c->vLumFilterSize - 1,\n<483> ((c->vChrFilterPos[chrI] + c->vChrFilterSize - 1)<<1));\n<487> if(c->vLumFilterPos[i   ] + c->vLumBufSize < nextSlice)\n<491> if(c->vChrFilterPos[chrI] + c->vChrBufSize < (nextSlice>>1))\n<501> c->lumPixBuf= (int16_t**)memalign(4, c->vLumBufSize*2*sizeof(int16_t*));\n<503> c->chrPixBuf= (int16_t**)memalign(4, c->vChrBufSize*2*sizeof(int16_t*));\n<507> for(i=0; i<c->vLumBufSize; i++)\n<509> c->lumPixBuf[i]= c->lumPixBuf[i+c->vLumBufSize]= (uint16_t*)memalign(8, 4000);\n<511> for(i=0; i<c->vChrBufSize; i++)\n<513> c->chrPixBuf[i]= c->chrPixBuf[i+c->vChrBufSize]= (uint16_t*)memalign(8, 8000);\n<519> for(i=0; i<c->vLumBufSize; i++) memset(c->lumPixBuf[i], 0, 4000);\n<521> for(i=0; i<c->vChrBufSize; i++) memset(c->chrPixBuf[i], 64, 8000);\n<525> ASSERT(c->chrDstH <= dstH)\n<535> c->lumMmxFilter= (int16_t*)memalign(8, c->vLumFilterSize*      dstH*4*sizeof(int16_t));\n<537> c->chrMmxFilter= (int16_t*)memalign(8, c->vChrFilterSize*c->chrDstH*4*sizeof(int16_t));\n<539> for(i=0; i<c->vLumFilterSize*dstH; i++)\n<545> for(i=0; i<c->vChrFilterSize*c->chrDstH; i++)\n<565> char *dither= "";\n<569> if(flags&SWS_FAST_BILINEAR)\n<571> fprintf(stderr, "\nSwScaler: FAST_BILINEAR scaler, ");\n<573> else if(flags&SWS_BILINEAR)\n<575> fprintf(stderr, "\nSwScaler: BILINEAR scaler, ");\n<577> else if(flags&SWS_BICUBIC)\n<579> fprintf(stderr, "\nSwScaler: BICUBIC scaler, ");\n<581> else if(flags&SWS_X)\n<583> fprintf(stderr, "\nSwScaler: Experimental scaler, ");\n<585> else if(flags&SWS_POINT)\n<587> fprintf(stderr, "\nSwScaler: Nearest Neighbor / POINT scaler, ");\n<589> else if(flags&SWS_AREA)\n<591> fprintf(stderr, "\nSwScaler: Area Averageing scaler, ");\n<595> fprintf(stderr, "\nSwScaler: ehh flags invalid?! ");\n<599> if(dstFormat==IMGFMT_BGR15 || dstFormat==IMGFMT_BGR16)\n<603> vo_format_name(srcFormat), dither, vo_format_name(dstFormat));\n<609> vo_format_name(srcFormat), vo_format_name(dstFormat));\n<613> if(cpuCaps.hasMMX2)\n<615> fprintf(stderr, "using MMX2\n");\n<617> else if(cpuCaps.has3DNow)\n<619> fprintf(stderr, "using 3DNOW\n");\n<621> else if(cpuCaps.hasMMX)\n<623> fprintf(stderr, "using MMX\n");\n<627> fprintf(stderr, "using C\n");\n<633> if((flags & SWS_PRINT_INFO) && verbose)\n<641> if(c->canMMX2BeUsed && (flags&SWS_FAST_BILINEAR))\n<643> printf("SwScaler: using FAST_BILINEAR MMX2 scaler for horizontal scaling\n");\n<649> if(c->hLumFilterSize==4)\n<651> printf("SwScaler: using 4-tap MMX scaler for horizontal luminance scaling\n");\n<653> else if(c->hLumFilterSize==8)\n<655> printf("SwScaler: using 8-tap MMX scaler for horizontal luminance scaling\n");\n<659> printf("SwScaler: using n-tap MMX scaler for horizontal luminance scaling\n");\n<663> if(c->hChrFilterSize==4)\n<665> printf("SwScaler: using 4-tap MMX scaler for horizontal chrominance scaling\n");\n<667> else if(c->hChrFilterSize==8)\n<669> printf("SwScaler: using 8-tap MMX scaler for horizontal chrominance scaling\n");\n<673> printf("SwScaler: using n-tap MMX scaler for horizontal chrominance scaling\n");\n<689> if(flags & SWS_FAST_BILINEAR)\n<691> printf("SwScaler: using FAST_BILINEAR C scaler for horizontal scaling\n");\n<695> printf("SwScaler: using C scaler for horizontal scaling\n");\n<705> if(c->vLumFilterSize==1)\n<707> printf("SwScaler: using 1-tap %s \"scaler\" for vertical scaling (YV12 like)\n", cpuCaps.hasMMX ? "MMX" : "C");\n<711> printf("SwScaler: using n-tap %s scaler for vertical scaling (YV12 like)\n", cpuCaps.hasMMX ? "MMX" : "C");\n<719> if(c->vLumFilterSize==1 && c->vChrFilterSize==2)\n<721> printf("SwScaler: using 1-tap %s \"scaler\" for vertical luminance scaling (BGR)\n"\n<725> else if(c->vLumFilterSize==2 && c->vChrFilterSize==2)\n<727> printf("SwScaler: using 2-tap linear %s scaler for vertical scaling (BGR)\n", cpuCaps.hasMMX ? "MMX" : "C");\n<731> printf("SwScaler: using n-tap %s scaler for vertical scaling (BGR)\n", cpuCaps.hasMMX ? "MMX" : "C");\n<737> if(dstFormat==IMGFMT_BGR24)\n<739> printf("SwScaler: using %s YV12->BGR24 Converter\n",\n<741> cpuCaps.hasMMX2 ? "MMX2" : (cpuCaps.hasMMX ? "MMX" : "C"));\n<743> else if(dstFormat==IMGFMT_BGR32)\n<745> printf("SwScaler: using %s YV12->BGR32 Converter\n", cpuCaps.hasMMX ? "MMX" : "C");\n<747> else if(dstFormat==IMGFMT_BGR16)\n<749> printf("SwScaler: using %s YV12->BGR16 Converter\n", cpuCaps.hasMMX ? "MMX" : "C");\n<751> else if(dstFormat==IMGFMT_BGR15)\n<753> printf("SwScaler: using %s YV12->BGR15 Converter\n", cpuCaps.hasMMX ? "MMX" : "C");\n<757> printf("SwScaler: %dx%d -> %dx%d\n", srcW, srcH, dstW, dstH);\n<761> if((flags & SWS_PRINT_INFO) && verbose>1)\n<765> printf("SwScaler:Lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n",\n<769> printf("SwScaler:Chr srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n",\n<779> return c;
<1> static int create_and_bind ( const char * host , const char * port , int protocol ) {\n<5> memset ( & hints , 0 , sizeof ( struct addrinfo ) ) ;\n<10> s = getaddrinfo ( host , port , & hints , & result ) ;
<1> static int mp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> const uint8_t * buf = avpkt -> data ;\n<4> MotionPixelsContext * mp = avctx -> priv_data ;\n<11> av_fast_malloc ( & mp -> bswapbuf , & mp -> bswapbuf_size , buf_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<12> if ( ! mp -> bswapbuf ) return AVERROR ( ENOMEM ) ;\n<14> if ( buf_size & 3 ) memcpy ( mp -> bswapbuf + ( buf_size & ~ 3 ) , buf + ( buf_size & ~ 3 ) , buf_size & 3 ) ;\n<15> memset ( mp -> bswapbuf + buf_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<17> memset ( mp -> changes_map , 0 , avctx -> width * avctx -> height ) ;\n<23> mp_read_changes_map ( mp , & gb , count1 , 8 , i ) ;\n<24> mp_read_changes_map ( mp , & gb , count2 , 4 , i ) ;\n<32> mp_read_codes_table ( mp , & gb ) ;\n<38> mp_decode_frame_helper ( mp , & gb ) ;
<1> static int get_pci_config_device(QEMUFile *f, void *pv, size_t size)\n<5> PCIDevice *s = container_of(pv, PCIDevice, config);\n<13> qemu_get_buffer(f, config, size);\n<15> for (i = 0; i < size; ++i)\n<17> if ((config[i] ^ s->config[i]) & s->cmask[i] & ~s->wmask[i])\n<21> memcpy(s->config, config, size);\n<25> pci_update_mappings(s);
<1> static int mp_decode_frame(MPADecodeContext *s, OUT_INT **samples,\n<49> nb_frames = mp_decode_layer3(s);\n<53> if (nb_frames < 0)\n<59> s->last_buf_size=0;\n<67> if (i >= 0 && i <= BACKSTEP_SIZE) {\n<69> memmove(s->last_buf, s->gb.buffer + (get_bits_count(&s->gb)>>3), i);\n<71> s->last_buf_size=i;\n<105> memcpy(s->last_buf + s->last_buf_size, s->gb.buffer + buf_size - HEADER_SIZE - i, i);\n<107> s->last_buf_size += i;
<1> static const uint8_t *pcx_rle_decode(const uint8_t *src, uint8_t *dst,\n<3> unsigned int bytes_per_scanline, int compressed) {\n<11> if (compressed) {\n<35> memcpy(dst, src, bytes_per_scanline);\n<37> src += bytes_per_scanline;
<101> if (ret < 0) {\n<107> error_report("load of migration failed: %s", strerror(-ret));
<1> qemu_irq *armv7m_init(MemoryRegion *system_memory, int mem_size, int num_irq,\n<37> if (cpu == NULL) {\n<39> fprintf(stderr, "Unable to find CPU definition\n");\n<85> if (!kernel_filename && !qtest_enabled()) {\n<87> fprintf(stderr, "Guest image must be specified (using -kernel)\n");
<1> static void decode_vectors ( COOKContext * q , COOKSubpacket * p , int * category , int * quant_index_table , float * mlt_buffer ) {\n<18> if ( index >= 7 ) {\n<19> memset ( subband_coef_index , 0 , sizeof ( subband_coef_index ) ) ;\n<20> memset ( subband_coef_sign , 0 , sizeof ( subband_coef_sign ) ) ;\n<22> q -> scalar_dequant ( q , index , quant_index_table [ band ] , subband_coef_index , subband_coef_sign , & mlt_buffer [ band * SUBBAND_SIZE ] ) ;
<1> Curl_send_buffer * Curl_add_buffer_init ( void ) {\n<2> return calloc ( 1 , sizeof ( Curl_send_buffer ) ) ;
<1> int DTLSv1_listen ( SSL * s , BIO_ADDR * client ) {\n<4> unsigned char seq [ SEQ_NUM_SIZE ] ;\n<70> if ( ! PACKET_forward ( & pkt , 1 ) || ! PACKET_copy_bytes ( & pkt , seq , SEQ_NUM_SIZE ) || ! PACKET_get_length_prefixed_2 ( & pkt , & msgpkt ) ) {\n<74> if ( seq [ 0 ] != 0 || seq [ 1 ] != 0 ) {\n<127> if ( s -> ctx -> app_gen_cookie_cb == NULL || s -> ctx -> app_gen_cookie_cb ( s , cookie , & cookielen ) == 0 || cookielen > 255 ) {\n<143> * ( p ++ ) = DTLS1_VERSION & 0xff ;\n<147> * ( p ++ ) = s -> version & 0xff ;\n<149> memcpy ( p , seq , SEQ_NUM_SIZE ) ;\n<150> p += SEQ_NUM_SIZE ;\n<181> DTLS_RECORD_LAYER_set_write_sequence ( & s -> rlayer , seq ) ;
<1> static int vp3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> Vp3DecodeContext * s = avctx -> priv_data ;\n<27> if ( s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_loop_filter ( s ) ;\n<30> i ++ ) if ( s -> qps [ i ] != s -> last_qps [ i ] || s -> qps [ 0 ] != s -> last_qps [ 0 ] ) init_dequantizer ( s , i ) ;\n<38> if ( s -> keyframe ) {\n<53> if ( ! s -> golden_frame . f -> data [ 0 ] ) {\n<61> if ( ( ret = ff_thread_ref_frame ( & s -> last_frame , & s -> golden_frame ) ) < 0 ) goto error ;\n<65> memset ( s -> all_fragments , 0 , s -> fragment_count * sizeof ( Vp3Fragment ) ) ;\n<67> if ( unpack_superblocks ( s , & gb ) ) {\n<71> if ( unpack_modes ( s , & gb ) ) {\n<75> if ( unpack_vectors ( s , & gb ) ) {\n<79> if ( unpack_block_qpis ( s , & gb ) ) {\n<83> if ( unpack_dct_coeffs ( s , & gb ) ) {\n<97> i ++ ) render_slice ( s , i ) ;\n<102> apply_loop_filter ( s , i , row , row + 1 ) ;\n<104> vp3_draw_horiz_band ( s , s -> avctx -> height ) ;
<1> static krb5_error_code process_db_args ( krb5_context context , char * * db_args , xargs_t * xargs , OPERATION optype ) {\n<9> db_args [ i ] ;\n<11> arg = strtok_r ( db_args [ i ] , "=" , & arg_val ) ;\n<12> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {\n<13> dptr = & xargs -> tktpolicydn ;\n<16> if ( strcmp ( arg , USERDN_ARG ) == 0 ) {\n<17> if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL || xargs -> linkdn != NULL ) {\n<19> k5_setmsg ( context , st , _ ( "%s option not supported" ) , arg ) ;\n<24> else if ( strcmp ( arg , CONTAINERDN_ARG ) == 0 ) {\n<25> if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL ) {\n<27> k5_setmsg ( context , st , _ ( "%s option not supported" ) , arg ) ;\n<32> else if ( strcmp ( arg , LINKDN_ARG ) == 0 ) {\n<33> if ( xargs -> dn != NULL || xargs -> linkdn != NULL ) {\n<35> k5_setmsg ( context , st , _ ( "%s option not supported" ) , arg ) ;\n<41> st = EINVAL ;\n<42> k5_setmsg ( context , st , _ ( "unknown option: %s" ) , arg ) ;\n<46> if ( arg_val == NULL || strlen ( arg_val ) == 0 ) {\n<47> st = EINVAL ;\n<48> k5_setmsg ( context , st , _ ( "%s option value missing" ) , arg ) ;\n<52> if ( arg_val == NULL ) {\n<54> k5_setmsg ( context , st , _ ( "%s option value missing" ) , arg ) ;\n<57> arg_val_len = strlen ( arg_val ) + 1 ;\n<58> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) {\n<59> if ( ( st = krb5_ldap_name_to_policydn ( context , arg_val , dptr ) ) != 0 ) goto cleanup ;\n<62> * dptr = k5memdup ( arg_val , arg_val_len , & st ) ;\n<63> if ( * dptr == NULL ) goto cleanup ;
<1> void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,\n<37> if (!req) {\n<65> evt = &req->resp.event;\n<67> memset(evt, 0, sizeof(VirtIOSCSIEvent));
<1> int qemu_fsdev_add(QemuOpts *opts)\n<11> const char *fsdriver = qemu_opt_get(opts, "fsdriver");\n<13> const char *writeout = qemu_opt_get(opts, "writeout");\n<19> if (!fsdev_id) {\n<21> fprintf(stderr, "fsdev: No id specified\n");\n<29> if (fsdriver) {\n<31> for (i = 0; i < ARRAY_SIZE(FsDrivers); i++) {\n<33> if (strcmp(FsDrivers[i].name, fsdriver) == 0) {\n<43> if (i == ARRAY_SIZE(FsDrivers)) {\n<45> fprintf(stderr, "fsdev: fsdriver %s not found\n", fsdriver);\n<53> fprintf(stderr, "fsdev: No fsdriver specified\n");\n<67> if (writeout) {\n<69> if (!strcmp(writeout, "immediate")) {\n<71> fsle->fse.export_flags |= V9FS_IMMEDIATE_WRITEOUT;
<1> int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags)\n<17> r=avfilter_graph_send_command(graph, target, cmd, arg, res, res_len, flags | AVFILTER_CMD_FLAG_FAST);\n<33> for (i = 0; i < graph->filter_count; i++) {\n<35> AVFilterContext *filter = graph->filters[i];\n<37> if(!strcmp(target, "all") || !strcmp(target, filter->name) || !strcmp(target, filter->filter->name)){\n<39> r = avfilter_process_command(filter, cmd, arg, res, res_len, flags);\n<41> if(r != AVERROR(ENOSYS)) {
<1> static int emulated_initfn(CCIDCardState *base)\n<37> if (card->backend == 0) {\n<39> printf("unknown backend, must be one of:\n");\n<41> for (ptable = backend_enum_table; ptable->name != NULL; ++ptable) {\n<43> printf("%s\n", ptable->name);\n<57> if (card->cert1 != NULL && card->cert2 != NULL && card->cert3 != NULL) {\n<63> printf("%s: you must provide all three certs for"\n<73> if (card->backend != BACKEND_NSS_EMULATED) {\n<75> printf("%s: bad backend specified. The options are:\n%s (default),"\n<85> if (card->cert1 != NULL || card->cert2 != NULL || card->cert3 != NULL) {\n<87> printf("%s: unexpected cert parameters to nss emulated backend\n",\n<101> if (ret != VCARD_EMUL_OK) {\n<103> printf("%s: failed to initialize vcard\n", EMULATED_DEV_NAME);
<1> static int setenv ( const char * name , const char * value , int overwrite ) {\n<2> size_t buflen = strlen ( name ) + strlen ( value ) + 2 ;\n<3> char * envvar = ( char * ) malloc ( buflen ) ;\n<4> if ( ! envvar ) return ENOMEM ;\n<5> strcpy ( envvar , name ) ;\n<6> strcat ( envvar , "=" ) ;\n<7> strcat ( envvar , value ) ;\n<8> putenv ( envvar ) ;
<1> void mct_start_logging ( const char * test_case_name ) {\n<2> const char * tmp_dir = getenv ( "MYSQL_TMP_DIR" ) ;\n<3> if ( ! tmp_dir ) {\n<4> printf ( "Warning: MYSQL_TMP_DIR is not set. Logging is disabled.\n" ) ;\n<7> if ( mct_log_file ) {\n<8> printf ( "Warning: can not start logging for test case '%s' " "because log is already open\n" , ( const char * ) test_case_name ) ;\n<11> if ( strlen ( tmp_dir ) + strlen ( test_case_name ) + 10 > FILE_PATH_SIZE ) {\n<12> printf ( "Warning: MYSQL_TMP_DIR is too long. Logging is disabled.\n" ) ;\n<13> return ;\n<15> my_snprintf ( mct_log_file_path , FILE_PATH_SIZE , "%s/%s.out.log" , ( const char * ) tmp_dir , ( const char * ) test_case_name ) ;\n<16> mct_log_file = my_fopen ( mct_log_file_path , O_WRONLY | O_BINARY , MYF ( MY_WME ) ) ;\n<17> if ( ! mct_log_file ) {\n<18> printf ( "Warning: can not open log file (%s): %s. Logging is disabled.\n" , ( const char * ) mct_log_file_path , ( const char * ) strerror ( errno ) ) ;
<1> static gpgme_error_t set_recipients ( engine_gpgsm_t gpgsm , gpgme_key_t recp [ ] ) {\n<9> line = malloc ( 10 + 40 + 1 ) ;\n<10> if ( ! line ) return gpg_error_from_syserror ( ) ;\n<11> strcpy ( line , "RECIPIENT " ) ;\n<13> ! err && recp [ i ] ;\n<17> if ( ! recp [ i ] -> subkeys || ! recp [ i ] -> subkeys -> fpr ) {\n<21> fpr = recp [ i ] -> subkeys -> fpr ;\n<22> newlen = 11 + strlen ( fpr ) ;\n<23> if ( linelen < newlen ) {\n<24> char * newline = realloc ( line , newlen ) ;\n<25> if ( ! newline ) {\n<27> free ( line ) ;\n<30> line = newline ;\n<31> linelen = newlen ;\n<33> strcpy ( & line [ 10 ] , fpr ) ;\n<34> err = gpgsm_assuan_simple_command ( ctx , line , gpgsm -> status . fnc , gpgsm -> status . fnc_value ) ;\n<36> else if ( err ) {\n<37> free ( line ) ;\n<41> free ( line ) ;
<1> static int net_dump_init(VLANState *vlan, const char *device,\n<49> if (write(s->fd, &hdr, sizeof(hdr)) < sizeof(hdr)) {\n<51> qemu_error("-net dump write error: %s\n", strerror(errno));
<1> static int rprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *r_val)\n<5> OMAContext *oc = s->priv_data;\n<13> if (!enc_header || !r_val)\n<41> av_des_mac(&av_des, oc->sm_val, &enc_header[pos], (oc->i_size >> 3));\n<49> return memcmp(&enc_header[pos], oc->sm_val, 8) ? -1 : 0;
<1> static void help ( void ) {\n<2> printf ( _ ( "%s extracts a PostgreSQL database cluster into an SQL script file.\n\n" ) , progname ) ;\n<3> printf ( _ ( "Usage:\n" ) ) ;\n<4> printf ( _ ( " %s [OPTION]...\n" ) , progname ) ;\n<5> printf ( _ ( "\nGeneral options:\n" ) ) ;\n<6> printf ( _ ( " -f, --file=FILENAME output file name\n" ) ) ;\n<7> printf ( _ ( " -V, --version output version information, then exit\n" ) ) ;\n<8> printf ( _ ( " --lock-wait-timeout=TIMEOUT fail after waiting TIMEOUT for a table lock\n" ) ) ;\n<9> printf ( _ ( " -?, --help show this help, then exit\n" ) ) ;\n<10> printf ( _ ( "\nOptions controlling the output content:\n" ) ) ;\n<11> printf ( _ ( " -a, --data-only dump only the data, not the schema\n" ) ) ;\n<12> printf ( _ ( " -c, --clean clean (drop) databases before recreating\n" ) ) ;\n<13> printf ( _ ( " -g, --globals-only dump only global objects, no databases\n" ) ) ;\n<14> printf ( _ ( " -o, --oids include OIDs in dump\n" ) ) ;\n<15> printf ( _ ( " -O, --no-owner skip restoration of object ownership\n" ) ) ;\n<16> printf ( _ ( " -r, --roles-only dump only roles, no databases or tablespaces\n" ) ) ;\n<17> printf ( _ ( " -s, --schema-only dump only the schema, no data\n" ) ) ;\n<18> printf ( _ ( " -S, --superuser=NAME superuser user name to use in the dump\n" ) ) ;\n<19> printf ( _ ( " -t, --tablespaces-only dump only tablespaces, no databases or roles\n" ) ) ;\n<20> printf ( _ ( " -x, --no-privileges do not dump privileges (grant/revoke)\n" ) ) ;\n<21> printf ( _ ( " --binary-upgrade for use by upgrade utilities only\n" ) ) ;\n<22> printf ( _ ( " --column-inserts dump data as INSERT commands with column names\n" ) ) ;\n<23> printf ( _ ( " --disable-dollar-quoting disable dollar quoting, use SQL standard quoting\n" ) ) ;\n<24> printf ( _ ( " --disable-triggers disable triggers during data-only restore\n" ) ) ;\n<25> printf ( _ ( " --if-exists use IF EXISTS when dropping objects\n" ) ) ;\n<26> printf ( _ ( " --inserts dump data as INSERT commands, rather than COPY\n" ) ) ;\n<27> printf ( _ ( " --no-security-labels do not dump security label assignments\n" ) ) ;\n<28> printf ( _ ( " --no-tablespaces do not dump tablespace assignments\n" ) ) ;\n<29> printf ( _ ( " --no-unlogged-table-data do not dump unlogged table data\n" ) ) ;\n<30> printf ( _ ( " --quote-all-identifiers quote all identifiers, even if not key words\n" ) ) ;\n<31> printf ( _ ( " --use-set-session-authorization\n" " use SET SESSION AUTHORIZATION commands instead of\n" " ALTER OWNER commands to set ownership\n" ) ) ;\n<32> printf ( _ ( "\nConnection options:\n" ) ) ;\n<33> printf ( _ ( " -d, --dbname=CONNSTR connect using connection string\n" ) ) ;\n<34> printf ( _ ( " -h, --host=HOSTNAME database server host or socket directory\n" ) ) ;\n<35> printf ( _ ( " -l, --database=DBNAME alternative default database\n" ) ) ;\n<36> printf ( _ ( " -p, --port=PORT database server port number\n" ) ) ;\n<37> printf ( _ ( " -U, --username=NAME connect as specified database user\n" ) ) ;\n<38> printf ( _ ( " -w, --no-password never prompt for password\n" ) ) ;\n<39> printf ( _ ( " -W, --password force password prompt (should happen automatically)\n" ) ) ;\n<40> printf ( _ ( " --role=ROLENAME do SET ROLE before dump\n" ) ) ;\n<41> printf ( _ ( "\nIf -f/--file is not used, then the SQL script will be written to the standard\n" "output.\n\n" ) ) ;\n<42> printf ( _ ( "Report bugs to <pgsql-bugs@postgresql.org>.\n" ) ) ;
<10> if ( ! finfo ) return FALSE ;\n<12> DISSECTOR_ASSERT ( hfinfo ) ;\n<13> abbrev_len = ( int ) strlen ( hfinfo -> abbrev ) ;\n<17> case FT_INT8 : case FT_INT16 : case FT_INT24 : case FT_INT32 : str = hf_try_val_to_str ( fvalue_get_sinteger ( & finfo -> value ) , hfinfo ) ;\n<19> case FT_UINT8 : case FT_UINT16 : case FT_UINT24 : case FT_UINT32 : str = hf_try_val_to_str ( fvalue_get_uinteger ( & finfo -> value ) , hfinfo ) ;\n<24> * filter = wmem_strdup_printf ( NULL , "%s == \"%s\"" , hfinfo -> abbrev , str ) ;\n<36> out = hfinfo_numeric_value_format ( hfinfo , buf , number ) ;\n<37> * filter = wmem_strdup_printf ( NULL , "%s == %s" , hfinfo -> abbrev , out ) ;\n<47> out = hfinfo_numeric_value_format64 ( hfinfo , buf , number ) ;\n<48> * filter = wmem_strdup_printf ( NULL , "%s == %s" , hfinfo -> abbrev , out ) ;\n<89> dfilter_len += abbrev_len + 4 + 1 ;\n<92> g_snprintf ( * filter , dfilter_len , "%s == %s" , hfinfo -> abbrev , str ) ;
<1> static char * allocString ( uint32_t length ) {\n<4> if ( top > STRING_STORE_SIZE ) {\n<5> fprintf ( stderr , "gencmn: out of memory\n" ) ;
<1> static int proxy_init(FsContext *ctx)\n<19> if (sock_id < 0) {\n<21> fprintf(stderr, "socket descriptor not initialized\n");
<1> static void dvbsub_parse_clut_segment(AVCodecContext *avctx,\n<61> if (!clut) {\n<63> clut = av_malloc(sizeof(DVBSubCLUT));\n<67> memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n<79> ctx->clut_list = clut;\n<85> if (clut->version != version) {
<1> int MBS_ReadHeader ( int fd , MBSPatchHeader * header ) {\n<2> int s = read ( fd , header , sizeof ( MBSPatchHeader ) ) ;\n<12> if ( s != 0 ) return READ_ERROR ;\n<13> if ( memcmp ( header -> tag , "MBDIFF10" , 8 ) != 0 ) return UNEXPECTED_ERROR ;\n<14> if ( hs . st_size > INT_MAX ) return UNEXPECTED_ERROR ;
<1> static void test_bug38486 ( void ) {\n<8> mysql_stmt_attr_set ( stmt , STMT_ATTR_CURSOR_TYPE , ( void * ) & type ) ;\n<9> stmt_text = "CREATE TABLE t1 (a INT)" ;\n<10> mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<11> mysql_stmt_execute ( stmt ) ;\n<14> mysql_stmt_attr_set ( stmt , STMT_ATTR_CURSOR_TYPE , ( void * ) & type ) ;\n<15> stmt_text = "INSERT INTO t1 VALUES (1)" ;\n<16> mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<17> mysql_stmt_execute ( stmt ) ;
<1> PCIDevice *virtio_net_init(PCIBus *bus, NICInfo *nd, int devfn)\n<27> if (!n)\n<51> memcpy(n->mac, nd->macaddr, ETH_ALEN);\n<55> n->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<63> qemu_format_nic_info_str(n->vc, n->mac);\n<77> n->mac_table.macs = qemu_mallocz(MAC_TABLE_ENTRIES * ETH_ALEN);
<1> static int txd_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<41> cur            += 92;\n<61> cur += 1024;\n<87> if (w != avctx->width || h != avctx->height)\n<89> avcodec_set_dimensions(avctx, w, h);\n<105> ptr    = p->data[0];\n<123> for (y=0; y<h; y++) {\n<125> memcpy(ptr, cur, w);\n<127> ptr += stride;\n<129> cur += w;\n<169> for (y=0; y<h; y++) {\n<171> memcpy(ptr, cur, w*4);\n<173> ptr += stride;\n<175> cur += w*4;
<1> tdata_t _TIFFmalloc ( tsize_t s ) {\n<2> if ( s == 0 ) return ( ( void * ) NULL ) ;\n<3> return ( malloc ( ( size_t ) s ) ) ;
<1> static Entity * EntityCreate ( SplinePointList * head , int linecap , int linejoin , real linewidth , real * transform , SplineSet * clippath ) {\n<2> Entity * ent = calloc ( 1 , sizeof ( Entity ) ) ;\n<13> memcpy ( ent -> u . splines . transform , transform , 6 * sizeof ( real ) ) ;\n<14> return ( ent ) ;
<1> gboolean proto_is_frame_protocol ( const wmem_list_t * layers , const char * proto_name ) {\n<5> while ( protos != NULL ) {\n<7> name = proto_get_protocol_filter_name ( proto_id ) ;\n<8> if ( ! strcmp ( name , proto_name ) ) {\n<9> return TRUE ;\n<11> protos = wmem_list_frame_next ( protos ) ;
<1> static int nntp_capabilities ( struct NntpServer * nserv ) {\n<38> else if ( mutt_str_strncmp ( "LIST " , buf , 5 ) == 0 ) {\n<39> char * p = strstr ( buf , " NEWSGROUPS" ) ;\n<41> p += 11 ;\n<46> while ( mutt_str_strcmp ( "." , buf ) != 0 ) ;
<1> static void qcow2_invalidate_cache(BlockDriverState *bs, Error **errp)\n<5> BDRVQcowState *s = bs->opaque;\n<33> if (s->crypt_method) {\n<37> memcpy(&aes_encrypt_key, &s->aes_encrypt_key, sizeof(aes_encrypt_key));\n<39> memcpy(&aes_decrypt_key, &s->aes_decrypt_key, sizeof(aes_decrypt_key));\n<51> if (local_err) {\n<61> memset(s, 0, sizeof(BDRVQcowState));\n<91> if (crypt_method) {\n<95> memcpy(&s->aes_encrypt_key, &aes_encrypt_key, sizeof(aes_encrypt_key));\n<97> memcpy(&s->aes_decrypt_key, &aes_decrypt_key, sizeof(aes_decrypt_key));
<1> static double convert_one_string_to_scalar ( char * value , int rangelo , int rangehi ) {\n<2> int slen = strlen ( value ) ;\n<4> if ( slen <= 0 ) return 0.0 ;\n<10> int ch = ( unsigned char ) * value ++ ;
<1> static int qemu_rdma_alloc_pd_cq(RDMAContext *rdma)\n<9> if (!rdma->pd) {\n<11> fprintf(stderr, "failed to allocate protection domain\n");\n<23> if (!rdma->comp_channel) {\n<25> fprintf(stderr, "failed to allocate completion channel\n");\n<45> if (!rdma->cq) {\n<47> fprintf(stderr, "failed to allocate completion queue\n");
<1> static void vc1_draw_sprites(VC1Context *v, SpriteData* sd)\n<43> int width = v->output_width>>!!plane;\n<95> v->vc1dsp.sprite_h(v->sr_rows[sprite][0], iplane + yline * iline, xoff[sprite], xadv[sprite], width);\n<105> v->vc1dsp.sprite_h(v->sr_rows[sprite][1], iplane + (yline + 1) * iline, xoff[sprite], xadv[sprite], width);\n<123> if (ysub[0]) {\n<125> v->vc1dsp.sprite_v_single(dst, src_h[0][0], src_h[0][1], ysub[0], width);\n<129> memcpy(dst, src_h[0][0], width);\n<137> v->vc1dsp.sprite_v_double_twoscale(dst, src_h[0][0], src_h[0][1], ysub[0],\n<143> v->vc1dsp.sprite_v_double_onescale(dst, src_h[0][0], src_h[0][1], ysub[0],\n<149> v->vc1dsp.sprite_v_double_onescale(dst, src_h[1][0], src_h[1][1], ysub[1],\n<155> v->vc1dsp.sprite_v_double_noscale(dst, src_h[0][0], src_h[1][0], alpha, width);
<1> static int mov_write_hdlr_tag(ByteIOContext *pb, MOVTrack *track)\n<17> descr = "DataHandler";\n<27> descr = "VideoHandler";\n<33> descr = "SoundHandler";\n<41> descr = "SubtitleHandler";\n<63> put_be32(pb ,0); /* reserved */\n<65> put_byte(pb, strlen(descr)); /* string counter */\n<67> put_buffer(pb, descr, strlen(descr)); /* handler description */\n<69> return updateSize(pb, pos);
<1> static bool _try_writable ( hb_blob_t * blob ) {\n<5> if ( blob -> mode == HB_MEMORY_MODE_WRITABLE ) return true ;\n<6> DEBUG_MSG_FUNC ( BLOB , blob , "current data is -> %p\n" , blob -> data ) ;\n<8> new_data = ( char * ) malloc ( blob -> length ) ;\n<9> if ( unlikely ( ! new_data ) ) return false ;\n<10> DEBUG_MSG_FUNC ( BLOB , blob , "dupped successfully -> %p\n" , blob -> data ) ;\n<11> memcpy ( new_data , blob -> data , blob -> length ) ;\n<12> _hb_blob_destroy_user_data ( blob ) ;\n<14> blob -> data = new_data ;\n<15> blob -> user_data = new_data ;
<1> static int read_runs ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b ) {\n<4> CHECK_READ_VAL ( gb , b , t ) ;\n<10> if ( get_bits1 ( gb ) ) {\n<11> v = get_bits ( gb , 4 ) ;\n<12> memset ( b -> cur_dec , v , t ) ;\n<13> b -> cur_dec += t ;
<1> static int qemuAgentIOProcess ( qemuAgentPtr mon ) {\n<13> if ( len < mon -> bufferOffset ) {\n<14> memmove ( mon -> buffer , mon -> buffer + len , mon -> bufferOffset - len ) ;
<1> int lcc_network_buffer_get ( lcc_network_buffer_t * nb , void * buffer , size_t * buffer_size ) {\n<4> if ( ( nb == NULL ) || ( buffer_size == NULL ) ) return ( EINVAL ) ;\n<9> if ( buffer != NULL ) memcpy ( buffer , nb -> buffer , ( sz_available < sz_required ) ? sz_available : sz_required ) ;
<1> static unsigned long get_pfxmatch ( char * * s , struct masks * m ) {\n<2> while ( m -> name ) {\n<3> if ( strncmp ( * s , m -> name , strlen ( m -> name ) ) == 0 ) {\n<4> * s += strlen ( m -> name ) ;\n<5> return m -> mask ;\n<8> m ++ ;
<1> process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n<17> struct e1000_tx *tp = &s->tx;\n<123> if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n<125> memmove(tp->header, tp->data, hdr);\n<131> if (sz == msh) {\n<135> memmove(tp->data, tp->header, hdr);\n<137> tp->size = hdr;\n<164> if (!(tp->tse && tp->cptse && tp->size < hdr))
<1> static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,\n<67> if (guid_eq(header->log_guid, zero_guid)) {\n<99> sector_offset = offset % VHDX_LOG_SECTOR_SIZE;\n<113> leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);\n<167> new_hdr.log_guid = header->log_guid;\n<171> desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);\n<177> new_hdr.entry_length = total_length;\n<181> vhdx_log_entry_hdr_le_export(&new_hdr);\n<185> buffer = qemu_blockalign(bs, total_length);\n<187> memcpy(buffer, &new_hdr, sizeof(new_hdr));\n<191> new_desc = buffer + sizeof(new_hdr);\n<193> data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);\n<195> data_tmp = data;\n<205> merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);\n<219> if (i == 0 && leading_length) {\n<223> ret = bdrv_pread(bs->file, file_offset, merged_sector,\n<227> if (ret < 0) {\n<233> memcpy(merged_sector + sector_offset, data_tmp, leading_length);\n<235> bytes_written = leading_length;\n<239> } else if (i == sectors - 1 && trailing_length) {\n<247> merged_sector + trailing_length,\n<249> VHDX_LOG_SECTOR_SIZE - trailing_length);\n<251> if (ret < 0) {\n<257> memcpy(merged_sector, data_tmp, trailing_length);\n<259> bytes_written = trailing_length;\n<261> sector_write = merged_sector;\n<285> data_tmp += bytes_written;\n<343> qemu_vfree(buffer);\n<345> qemu_vfree(merged_sector);
<1> static int synth_superframe ( AVCodecContext * ctx , AVFrame * frame , int * got_frame_ptr ) {\n<2> WMAVoiceContext * s = ctx -> priv_data ;\n<5> double lsps [ MAX_FRAMES ] [ MAX_LSPS ] ;\n<7> float excitation [ MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12 ] ;\n<8> float synth [ MAX_LSPS + MAX_SFRAMESIZE ] ;\n<10> memcpy ( synth , s -> synth_history , s -> lsps * sizeof ( * synth ) ) ;\n<11> memcpy ( excitation , s -> excitation_history , s -> history_nsamples * sizeof ( * excitation ) ) ;\n<17> if ( ( res = check_bits_for_superframe ( gb , s ) ) == 1 ) {\n<35> n ++ ) prev_lsps [ n ] = s -> prev_lsps [ n ] - mean_lsf [ n ] ;\n<37> dequant_lsp10r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n<39> else dequant_lsp16r ( gb , lsps [ 2 ] , prev_lsps , a1 , a2 , s -> lsp_q_mode ) ;\n<45> lsps [ 2 ] [ n ] += mean_lsf [ n ] ;\n<59> n < 3 ;\n<72> if ( ( res = synth_frame ( ctx , gb , n , & samples [ n * MAX_FRAMESIZE ] , lsps [ n ] , n == 0 ? s -> prev_lsps : lsps [ n - 1 ] , & excitation [ s -> history_nsamples + n * MAX_FRAMESIZE ] , & synth [ s -> lsps + n * MAX_FRAMESIZE ] ) ) ) {\n<82> memcpy ( s -> prev_lsps , lsps [ 2 ] , s -> lsps * sizeof ( * s -> prev_lsps ) ) ;\n<83> memcpy ( s -> synth_history , & synth [ MAX_SFRAMESIZE ] , s -> lsps * sizeof ( * synth ) ) ;\n<84> memcpy ( s -> excitation_history , & excitation [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * excitation ) ) ;\n<85> if ( s -> do_apf ) memmove ( s -> zero_exc_pf , & s -> zero_exc_pf [ MAX_SFRAMESIZE ] , s -> history_nsamples * sizeof ( * s -> zero_exc_pf ) ) ;
<1> static int show_routine_grants ( THD * thd , LEX_USER * lex_user , HASH * hash , const char * type , int typelen , char * buff , int buffsize ) {\n<6> index < hash -> records ;\n<7> index ++ ) {\n<9> GRANT_NAME * grant_proc = ( GRANT_NAME * ) hash_element ( hash , index ) ;\n<10> if ( ! ( user = grant_proc -> user ) ) user = "" ;\n<11> if ( ! ( host = grant_proc -> host . hostname ) ) host = "" ;\n<12> if ( ! strcmp ( lex_user -> user . str , user ) && ! my_strcasecmp ( system_charset_info , lex_user -> host . str , host ) ) {\n<13> ulong proc_access = grant_proc -> privs ;\n<14> if ( proc_access != 0 ) {\n<36> append_identifier ( thd , & global , grant_proc -> db , strlen ( grant_proc -> db ) ) ;\n<38> append_identifier ( thd , & global , grant_proc -> tname , strlen ( grant_proc -> tname ) ) ;\n<40> global . append ( lex_user -> user . str , lex_user -> user . length , system_charset_info ) ;\n<42> global . append ( host , strlen ( host ) , system_charset_info ) ;
<1> static int32_t parse_gain(const char *gain)\n<17> if (!gain)\n<23> gain += strspn(gain, " \t");\n<33> db = strtol(gain, &fraction, 0);
<1> static void dumpustr ( FILE * file , char * utf8_str ) {\n<2> unichar_t * ustr = utf82u_copy ( utf8_str ) , * pt = ustr ;\n<8> free ( ustr ) ;
<1> static void test_bug58036 ( ) {\n<8> if ( ! opt_silent ) printf ( "mysql_real_connect() succeeded (failure expected)\n" ) ;\n<12> if ( ! opt_silent ) printf ( "Got mysql_real_connect() error (expected): %s (%d)\n" , mysql_error ( conn ) , mysql_errno ( conn ) ) ;\n<18> if ( ! opt_silent ) printf ( "mysql_real_connect() failed: %s (%d)\n" , mysql_error ( conn ) , mysql_errno ( conn ) ) ;\n<24> if ( ! opt_silent ) printf ( "mysql_change_user() succedded, error expected!" ) ;\n<28> if ( ! opt_silent ) printf ( "Got mysql_change_user() error (expected): %s (%d)\n" , mysql_error ( conn ) , mysql_errno ( conn ) ) ;
<1> static void test_bug5194 ( ) {\n<17> const char * query_template = "insert into t1 values %s" ;\n<22> stmt_text = "drop table if exists t1" ;\n<23> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<24> stmt_text = "create table if not exists t1" "(c1 float, c2 float, c3 float, c4 float, c5 float, c6 float, " "c7 float, c8 float, c9 float, c10 float, c11 float, c12 float, " "c13 float, c14 float, c15 float, c16 float, c17 float, c18 float, " "c19 float, c20 float, c21 float, c22 float, c23 float, c24 float, " "c25 float, c26 float, c27 float, c28 float, c29 float, c30 float, " "c31 float, c32 float, c33 float, c34 float, c35 float, c36 float, " "c37 float, c38 float, c39 float, c40 float, c41 float, c42 float, " "c43 float, c44 float, c45 float, c46 float, c47 float, c48 float, " "c49 float, c50 float, c51 float, c52 float, c53 float, c54 float, " "c55 float, c56 float, c57 float, c58 float, c59 float, c60 float, " "c61 float, c62 float, c63 float, c64 float, c65 float, c66 float, " "c67 float, c68 float, c69 float, c70 float, c71 float, c72 float, " "c73 float, c74 float, c75 float, c76 float, c77 float, c78 float, " "c79 float, c80 float, c81 float, c82 float, c83 float, c84 float, " "c85 float, c86 float, c87 float, c88 float, c89 float, c90 float, " "c91 float, c92 float, c93 float, c94 float, c95 float, c96 float, " "c97 float, c98 float, c99 float, c100 float, c101 float, c102 float, " "c103 float, c104 float, c105 float, c106 float, c107 float, c108 float, " "c109 float, c110 float, c111 float, c112 float, c113 float, c114 float, " "c115 float, c116 float, c117 float, c118 float, c119 float, c120 float, " "c121 float, c122 float, c123 float, c124 float, c125 float, c126 float, " "c127 float, c128 float, c129 float, c130 float, c131 float, c132 float, " "c133 float, c134 float, c135 float, c136 float, c137 float, c138 float, " "c139 float, c140 float, c141 float, c142 float, c143 float, c144 float, " "c145 float, c146 float, c147 float, c148 float, c149 float, c150 float, " "c151 float, c152 float, c153 float, c154 float, c155 float, c156 float, " "c157 float, c158 float, c159 float, c160 float, c161 float, c162 float, " "c163 float, c164 float, c165 float, c166 float, c167 float, c168 float, " "c169 float, c170 float, c171 float, c172 float, c173 float, c174 float, " "c175 float, c176 float, c177 float, c178 float, c179 float, c180 float, " "c181 float, c182 float, c183 float, c184 float, c185 float, c186 float, " "c187 float, c188 float, c189 float, c190 float, c191 float, c192 float, " "c193 float, c194 float, c195 float, c196 float, c197 float, c198 float, " "c199 float, c200 float, c201 float, c202 float, c203 float, c204 float, " "c205 float, c206 float, c207 float, c208 float, c209 float, c210 float, " "c211 float, c212 float, c213 float, c214 float, c215 float, c216 float, " "c217 float, c218 float, c219 float, c220 float, c221 float, c222 float, " "c223 float, c224 float, c225 float, c226 float, c227 float, c228 float, " "c229 float, c230 float, c231 float, c232 float, c233 float, c234 float, " "c235 float, c236 float, c237 float, c238 float, c239 float, c240 float, " "c241 float, c242 float, c243 float, c244 float, c245 float, c246 float, " "c247 float, c248 float, c249 float, c250 float)" ;\n<25> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<27> my_bind = ( MYSQL_BIND * ) malloc ( MAX_PARAM_COUNT * sizeof ( MYSQL_BIND ) ) ;\n<28> query = ( char * ) malloc ( strlen ( query_template ) + MAX_PARAM_COUNT * CHARS_PER_PARAM + 1 ) ;\n<29> param_str = ( char * ) malloc ( COLUMN_COUNT * CHARS_PER_PARAM ) ;\n<30> if ( my_bind == 0 || query == 0 || param_str == 0 ) {\n<31> fprintf ( stderr , "Can't allocate enough memory for query structs\n" ) ;\n<32> if ( my_bind ) free ( my_bind ) ;\n<33> if ( query ) free ( query ) ;\n<34> if ( param_str ) free ( param_str ) ;\n<37> stmt = mysql_stmt_init ( mysql ) ;\n<38> sprintf ( param_str , "(" ) ;\n<40> i < COLUMN_COUNT ;\n<41> ++ i ) strcat ( param_str , "?, " ) ;\n<42> strcat ( param_str , "?)" ) ;\n<43> param_str_length = strlen ( param_str ) ;\n<44> memset ( my_bind , 0 , MAX_PARAM_COUNT * sizeof ( MYSQL_BIND ) ) ;\n<53> nrows <= MAX_ROWS_PER_INSERT ;\n<54> ++ nrows ) {\n<56> sprintf ( query , query_template , param_str ) ;\n<57> query_ptr = query + strlen ( query ) ;\n<59> i < nrows ;\n<61> memcpy ( query_ptr , ", " , 2 ) ;\n<62> query_ptr += 2 ;\n<63> memcpy ( query_ptr , param_str , param_str_length ) ;\n<64> query_ptr += param_str_length ;\n<66> * query_ptr = '\0' ;\n<67> rc = mysql_stmt_prepare ( stmt , query , query_ptr - query ) ;\n<68> if ( rc && nrows * COLUMN_COUNT > uint16_max ) {\n<69> if ( ! opt_silent ) printf ( "Failed to prepare a statement with %d placeholders " "(as expected).\n" , nrows * COLUMN_COUNT ) ;\n<73> if ( ! opt_silent ) printf ( "Insert: query length= %d, row count= %d, param count= %lu\n" , ( int ) strlen ( query ) , nrows , mysql_stmt_param_count ( stmt ) ) ;\n<74> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<81> free ( my_bind ) ;\n<82> free ( query ) ;\n<83> free ( param_str ) ;\n<84> stmt_text = "drop table t1" ;\n<85> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static void qemu_kvm_eat_signal(CPUState *env, int timeout)\n<31> e = errno;\n<37> if (r == -1 && !(e == EAGAIN || e == EINTR)) {\n<39> fprintf(stderr, "sigtimedwait: %s\n", strerror(e));
<1> void ppc40x_chip_reset (CPUState *env)\n<9> printf("Reset PowerPC chip\n");
<1> struct condition * compiler_create_condition ( struct filter_op * fop ) {\n<3> SAFE_CALLOC ( cnd , 1 , sizeof ( struct condition ) ) ;\n<4> memcpy ( & cnd -> fop , fop , sizeof ( struct filter_op ) ) ;
<1> extern List as_mysql_remove_clusters ( mysql_conn_t * mysql_conn , uint32_t uid , slurmdb_cluster_cond_t * cluster_cond ) {\n<78> if ( rc != SLURM_SUCCESS ) {\n<83> memset ( & wckey_cond , 0 , sizeof ( slurmdb_wckey_cond_t ) ) ;\n<85> tmp_list = as_mysql_remove_wckeys ( mysql_conn , uid , & wckey_cond ) ;
<1> static int xen_host_pci_get_resource(XenHostPCIDevice *d)\n<29> if (fd == -1) {\n<31> XEN_HOST_PCI_LOG("Error: Can't open %s: %s\n", path, strerror(errno));\n<33> return -errno;
<1> static bfd_boolean srec_scan ( bfd * abfd ) {\n<57> if ( symname == NULL ) goto error_return ;\n<58> strcpy ( symname , symbuf ) ;\n<59> free ( symbuf ) ;\n<117> if ( buf != NULL ) free ( buf ) ;\n<144> if ( sec != NULL && sec -> vma + sec -> size == address ) {\n<148> char secbuf [ 20 ] ;\n<152> sprintf ( secbuf , ".sec%d" , bfd_count_sections ( abfd ) + 1 ) ;\n<153> amt = strlen ( secbuf ) + 1 ;\n<154> secname = ( char * ) bfd_alloc ( abfd , amt ) ;\n<155> strcpy ( secname , secbuf ) ;\n<195> if ( buf != NULL ) free ( buf ) ;\n<203> if ( buf != NULL ) free ( buf ) ;\n<205> error_return : if ( symbuf != NULL ) free ( symbuf ) ;\n<206> if ( buf != NULL ) free ( buf ) ;
<1> static void pci_device_reset(PCIDevice *dev)\n<9> memset(dev->irq_state, 0, sizeof dev->irq_state);\n<27> pci_set_long(dev->config + pci_bar(dev, r), dev->io_regions[r].type);\n<31> pci_update_mappings(dev);
<29> if (avctx->get_buffer(avctx, &s->frame)) {\n<39> vqa_decode_chunk(s);\n<45> memcpy(s->frame.data[1], s->palette, PALETTE_COUNT * 4);
<1> static void config_vars ( config_tree * ptree ) {\n<8> switch ( curr_var -> attr ) {\n<13> case T_Driftfile : if ( '\0' == curr_var -> value . s [ 0 ] ) {\n<29> case T_Saveconfigdir : if ( saveconfigdir != NULL ) free ( saveconfigdir ) ;\n<30> len = strlen ( curr_var -> value . s ) ;\n<31> if ( 0 == len ) {\n<37> snprintf ( saveconfigdir , len + 1 , "%s%c" , curr_var -> value . s , DIR_SEP ) ;\n<40> saveconfigdir = estrdup ( curr_var -> value . s ) ;
<1> static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n<55> if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n<57> fprintf(stderr, "VNC: error during tight compression\n");
<1> int test_gf2m_mod ( BIO * bp ) {\n<38> if ( ! BN_is_zero ( e ) ) {\n<39> fprintf ( stderr , "GF(2^m) modulo test failed!\n" ) ;
<1> static void pcnet_bcr_writew ( PCNetState * s , uint32_t rap , uint32_t val ) {\n<14> default : printf ( "Bad SWSTYLE=0x%02x\n" , val & 0xff ) ;
<1> static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags,\n<29> opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n<65> clientname = qemu_rbd_parse_clientname(conf, clientname_buf);\n<69> if (r < 0) {\n<115> if (strstr(conf, "conf=") == NULL) {\n<119> rados_conf_read_file(s->cluster, NULL);\n<125> if (conf[0] != '\0') {\n<127> r = qemu_rbd_set_conf(s->cluster, conf, errp);\n<175> bs->read_only = (s->snap != NULL);
<1> static void integratorcm_init(int memsz, uint32_t flash_offset)\n<23> integrator_spd[31] = 64;\n<29> integrator_spd[31] = 32;\n<35> integrator_spd[31] = 16;\n<41> integrator_spd[31] = 4;\n<47> integrator_spd[31] = 2;\n<51> memcpy(integrator_spd + 73, "QEMU-MEMORY", 11);
<1> static int decode_user_data ( MpegEncContext * s , GetBitContext * gb ) {\n<2> char buf [ 256 ] ;\n<5> int ver = 0 , build = 0 , ver2 = 0 , ver3 = 0 ;\n<13> buf [ i ] = 0 ;\n<14> e = sscanf ( buf , "DivX%dBuild%d%c" , & ver , & build , & last ) ;\n<15> if ( e < 2 ) e = sscanf ( buf , "DivX%db%d%c" , & ver , & build , & last ) ;\n<16> if ( e >= 2 ) {\n<17> s -> divx_version = ver ;\n<18> s -> divx_build = build ;\n<19> s -> divx_packed = e == 3 && last == 'p' ;\n<25> e = sscanf ( buf , "FFmpe%*[^b]b%d" , & build ) + 3 ;\n<26> if ( e != 4 ) e = sscanf ( buf , "FFmpeg v%d.%d.%d / libavcodec build: %d" , & ver , & ver2 , & ver3 , & build ) ;\n<27> if ( e != 4 ) {\n<28> e = sscanf ( buf , "Lavc%d.%d.%d" , & ver , & ver2 , & ver3 ) + 1 ;\n<29> if ( e > 1 ) build = ( ver << 16 ) + ( ver2 << 8 ) + ver3 ;\n<31> if ( e != 4 ) {\n<32> if ( strcmp ( buf , "ffmpeg" ) == 0 ) {\n<33> s -> lavc_build = 4600 ;\n<37> s -> lavc_build = build ;\n<39> e = sscanf ( buf , "XviD%d" , & build ) ;\n<40> if ( e == 1 ) {\n<41> s -> xvid_build = build ;
<1> PHP_MINIT_FUNCTION ( spl_directory ) {\n<3> memcpy ( & spl_filesystem_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ;\n<4> spl_filesystem_object_handlers . clone_obj = spl_filesystem_object_clone ;\n<5> spl_filesystem_object_handlers . cast_object = spl_filesystem_object_cast ;\n<6> spl_filesystem_object_handlers . get_debug_info = spl_filesystem_object_get_debug_info ;\n<29> memcpy ( & spl_filesystem_object_check_handlers , & spl_filesystem_object_handlers , sizeof ( zend_object_handlers ) ) ;
<1> static int get_external_ip ( struct in_addr * ip ) {\n<5> const char * getstr = "GET /ip/ HTTP/1.0\r\n" "Host: api.externalip.net\r\n\r\n" ;\n<16> res = connect ( sock , addr -> ai_addr , addr -> ai_addrlen ) ;\n<18> if ( res < 0 ) return 3 ;\n<19> res = write ( sock , getstr , strlen ( getstr ) ) ;\n<20> if ( res != strlen ( getstr ) ) return 4 ;\n<21> memset ( buf , 0 , sizeof ( buf ) ) ;\n<22> res = read ( sock , buf , sizeof ( buf ) - 1 ) ;\n<23> if ( res < 0 ) return 5 ;
<1> static abi_ulong setup_arg_pages(abi_ulong p, struct linux_binprm *bprm,\n<57> if (bprm->page[i]) {\n<63> memcpy_to_target(stack_base, bprm->page[i], TARGET_PAGE_SIZE);\n<65> free(bprm->page[i]);
<1> static int init_directories(BDRVVVFATState* s,\n<19> memset(&(s->first_sectors[0]),0,0x40*0x200);\n<65> direntry_t* entry=array_get_next(&(s->directory));\n<69> memcpy(entry->name, s->volume_label, sizeof(entry->name));\n<77> init_fat(s);\n<81> s->cluster_count=sector2cluster(s, s->sector_count);\n<85> mapping = array_get_next(&(s->mapping));\n<95> mapping->path = g_strdup(dirname);\n<97> i = strlen(mapping->path);\n<99> if (i > 0 && mapping->path[i - 1] == '/')\n<107> s->path = mapping->path;\n<111> for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n<129> if(read_directory(s, i)) {\n<131> error_setg(errp, "Could not read directory %s",\n<205> fat_set(s, j, j+1);\n<207> fat_set(s, mapping->end - 1, s->max_fat_value);\n<225> fat_set(s,0,s->max_fat_value);\n<227> fat_set(s,1,s->max_fat_value);\n<245> memcpy(bootsector->name,"QEMU    ",8);\n<289> memcpy(bootsector->u.fat16.volume_label, s->volume_label,
<1> static void dissect_diameter_other_vendor_exp_res ( tvbuff_t * tvb , proto_tree * tree , diam_sub_dis_t * diam_sub_dis ) {\n<3> if ( tree ) {\n<6> proto_item_fill_label ( PITEM_FINFO ( pi ) , diam_sub_dis -> avp_str ) ;\n<7> diam_sub_dis -> avp_str = strstr ( diam_sub_dis -> avp_str , ": " ) + 2 ;
<1> void show_help(void)\n<23> if (!do_play) {\n<25> printf("usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\n"\n<31> printf("usage: ffplay [options] input_file...\n"\n<45> if (i == 1)\n<47> printf("\nAdvanced options are:\n");\n<49> for(po = options; po->name != NULL; po++) {\n<55> if (expert == i) {\n<57> strcpy(buf, po->name);\n<59> if (po->flags & HAS_ARG) {\n<61> strcat(buf, " ");\n<63> strcat(buf, po->argname);\n<67> printf("-%-17s  %s\n", buf, po->help);
<1> static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) {\n<4> assert ( buf ) ;\n<7> cnt = JAS_MIN ( n , cnt ) ;\n<8> memcpy ( buf , & m -> buf_ [ m -> pos_ ] , cnt ) ;\n<9> m -> pos_ += cnt ;\n<10> return cnt ;
<1> void *grow_array(void *array, int elem_size, int *size, int new_size)\n<13> if (*size < new_size) {\n<17> if (!tmp) {\n<25> memset(tmp + *size*elem_size, 0, (new_size-*size) * elem_size);
<1> static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)\n<5> if (buf_size < 13)\n<9> if (memcmp(buf, "FLV", 3))\n<11> return AVERROR_INVALIDDATA;\n<13> buf      += 13;\n<15> buf_size -= 13;\n<17> while (buf_size >= 11 + 4) {\n<21> int size = AV_RB24(&buf[1]) + 11 + 4;\n<29> if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))\n<35> os->extra_packets[os->nb_extra_packets] = av_malloc(size);\n<37> if (!os->extra_packets[os->nb_extra_packets])\n<41> memcpy(os->extra_packets[os->nb_extra_packets], buf, size);\n<53> os->metadata      = av_malloc(os->metadata_size);\n<55> if (!os->metadata)\n<59> memcpy(os->metadata, buf + 11, os->metadata_size);\n<63> buf      += size;\n<65> buf_size -= size;\n<69> if (!os->metadata)
<1> static void ppc_spapr_init(MachineState *machine)\n<189> if (cpu == NULL) {\n<191> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<347> for (i = 0; i < nb_nics; i++) {\n<349> NICInfo *nd = &nd_table[i];\n<353> if (!nd->model) {\n<355> nd->model = g_strdup("ibmveth");\n<361> if (strcmp(nd->model, "ibmveth") == 0) {\n<363> spapr_vlan_create(spapr->vio_bus, nd);\n<367> pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n<409> if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n<411> fprintf(stderr, "qemu: pSeries SLOF firmware requires >= "\n<427> kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n<443> if (kernel_size < 0) {\n<445> fprintf(stderr, "qemu: error loading %s: %s\n",\n<447> kernel_filename, load_elf_strerror(kernel_size));\n<467> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<471> if (initrd_size < 0) {\n<473> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",
<1> PGresult * executeQueryOrDie ( PGconn * conn , const char * fmt , ... ) {\n<6> va_start ( args , fmt ) ;\n<7> vsnprintf ( query , sizeof ( query ) , fmt , args ) ;\n<8> va_end ( args ) ;\n<9> pg_log ( PG_VERBOSE , "executing: %s\n" , query ) ;\n<12> if ( ( status != PGRES_TUPLES_OK ) && ( status != PGRES_COMMAND_OK ) ) {\n<16> printf ( "Failure, exiting\n" ) ;
<1> static int join_request_frame(AVFilterLink *outlink)\n<7> JoinContext *s       = ctx->priv;\n<31> if (!s->input_frames[i] &&\n<97> if (!(priv->in_buffers = av_mallocz(sizeof(*priv->in_buffers) * ctx->nb_inputs)))\n<117> memset(s->input_frames, 0, sizeof(*s->input_frames) * ctx->nb_inputs);
<1> static const char *local_mapped_attr_path(FsContext *ctx,\n<3> const char *path, char *buffer)\n<9> char *tmp_path = strdup(path);\n<11> char *base_name = basename(tmp_path);\n<27> free(tmp_path);
<1> static int img_create(int argc, char **argv)\n<17> char *options = NULL;\n<77> options = optarg;\n<101> if (optind < argc) {\n<109> if (sval < 0 || *end) {\n<129> if (options && !strcmp(options, "?")) {\n<131> ret = print_block_option_help(filename, fmt);\n<139> ret = bdrv_img_create(filename, fmt, base_filename, base_fmt,
<1> rfbBool rfbFilenameTranslate2UNIX ( rfbClientPtr cl , char * path , char * unixPath , size_t unixPathMaxLen ) {\n<5> if ( strlen ( path ) >= unixPathMaxLen ) return FALSE ;\n<6> if ( path [ 0 ] == 'C' && path [ 1 ] == ':' ) strcpy ( unixPath , & path [ 2 ] ) ;\n<8> home = getenv ( "HOME" ) ;\n<9> if ( home != NULL ) {\n<10> if ( ( strlen ( path ) + strlen ( home ) + 1 ) >= unixPathMaxLen ) return FALSE ;\n<11> strcpy ( unixPath , home ) ;\n<12> strcat ( unixPath , "/" ) ;\n<13> strcat ( unixPath , path ) ;\n<15> else strcpy ( unixPath , path ) ;\n<17> for ( x = 0 ;\n<18> x < strlen ( unixPath ) ;\n<19> x ++ ) if ( unixPath [ x ] == '\\' ) unixPath [ x ] = '/' ;\n<20> return TRUE ;
<1> static bool line_matches ( struct rule * rule , const char * command , const char * subcommand ) {\n<3> if ( strcmp ( rule -> command , "ALL" ) == 0 ) okay = true ;\n<4> if ( command != NULL && strcmp ( rule -> command , command ) == 0 ) okay = true ;\n<5> if ( command == NULL && strcmp ( rule -> command , "EMPTY" ) == 0 ) okay = true ;\n<6> if ( okay ) {\n<7> if ( strcmp ( rule -> subcommand , "ALL" ) == 0 ) return true ;\n<8> if ( subcommand != NULL && strcmp ( rule -> subcommand , subcommand ) == 0 ) return true ;\n<9> if ( subcommand == NULL && strcmp ( rule -> subcommand , "EMPTY" ) == 0 ) return true ;\n<11> return false ;
<1> void bios_linker_loader_alloc(GArray *linker,\n<3> const char *file,\n<19> memset(&entry, 0, sizeof entry);\n<21> strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n<37> g_array_prepend_vals(linker, &entry, sizeof entry);
<1> char * test_url_print ( TSMBuffer bufp , TSMLoc hdr_loc ) {\n<17> output_string = ( char * ) TSmalloc ( total_avail + 1 ) ;\n<18> output_len = 0 ;\n<21> block_start = TSIOBufferBlockReadStart ( block , reader , & block_avail ) ;\n<22> if ( block_avail == 0 ) {\n<25> memcpy ( output_string + output_len , block_start , block_avail ) ;\n<26> output_len += block_avail ;\n<27> TSIOBufferReaderConsume ( reader , block_avail ) ;
<1> static void * data_create_hangul ( const hb_ot_shape_plan_t * plan ) {\n<2> hangul_shape_plan_t * hangul_plan = ( hangul_shape_plan_t * ) calloc ( 1 , sizeof ( hangul_shape_plan_t ) ) ;
<1> int test_sqrt ( BIO * bp , BN_CTX * ctx ) {\n<24> putc ( '\n' , stderr ) ;\n<41> if ( BN_cmp ( a , r ) != 0 ) {\n<42> fprintf ( stderr , "BN_mod_sqrt failed: a = " ) ;\n<43> BN_print_fp ( stderr , a ) ;\n<44> fprintf ( stderr , ", r = " ) ;\n<45> BN_print_fp ( stderr , r ) ;\n<46> fprintf ( stderr , ", p = " ) ;\n<47> BN_print_fp ( stderr , p ) ;\n<48> fprintf ( stderr , "\n" ) ;\n<52> fflush ( stderr ) ;\n<55> fflush ( stderr ) ;
<1> static void erase_line ( AVCodecContext * avctx , int xoffset , int xlength ) {\n<5> i < s -> font_height ;\n<6> i ++ ) memset ( s -> frame -> data [ 0 ] + ( s -> y + i ) * s -> frame -> linesize [ 0 ] + xoffset , DEFAULT_BG_COLOR , xlength ) ;
<1> static void read_marks ( void ) {\n<3> FILE * f = fopen ( import_marks_file , "r" ) ;\n<4> if ( f ) ;\n<5> else if ( import_marks_file_ignore_missing && errno == ENOENT ) return ;\n<7> while ( fgets ( line , sizeof ( line ) , f ) ) {\n<10> unsigned char sha1 [ 20 ] ;\n<12> end = strchr ( line , '\n' ) ;\n<13> if ( line [ 0 ] != ':' || ! end ) die ( "corrupt mark line: %s" , line ) ;\n<14> * end = 0 ;\n<15> mark = strtoumax ( line + 1 , & end , 10 ) ;\n<16> if ( ! mark || end == line + 1 || * end != ' ' || get_sha1_hex ( end + 1 , sha1 ) ) die ( "corrupt mark line: %s" , line ) ;\n<17> e = find_object ( sha1 ) ;\n<18> if ( ! e ) {\n<26> insert_mark ( mark , e ) ;\n<28> fclose ( f ) ;
<1> static void moresubs ( struct vars * v , int wanted ) {\n<8> if ( p != NULL ) memcpy ( VS ( p ) , VS ( v -> subs ) , v -> nsubs * sizeof ( struct subre * ) ) ;
<1> void video_decode_example(const char *outfilename, const char *filename)\n<15> uint8_t inbuf[INBUF_SIZE + FF_INPUT_BUFFER_PADDING_SIZE], *inbuf_ptr;\n<23> memset(inbuf + INBUF_SIZE, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<27> printf("Video decoding\n");\n<35> if (!codec) {\n<37> fprintf(stderr, "codec not found\n");\n<53> c->flags|= CODEC_FLAG_TRUNCATED; /* we dont send complete frames */\n<67> if (avcodec_open(c, codec) < 0) {\n<69> fprintf(stderr, "could not open codec\n");\n<81> f = fopen(filename, "r");\n<83> if (!f) {\n<85> fprintf(stderr, "could not open %s\n", filename);\n<93> frame = 0;\n<143> if (len < 0) {\n<145> fprintf(stderr, "Error while decoding frame %d\n", frame);\n<151> if (got_picture) {\n<153> printf("saving frame %3d\n", frame);\n<163> snprintf(buf, sizeof(buf), outfilename, frame);\n<165> pgm_save(picture->data[0], picture->linesize[0],\n<169> frame++;\n<189> len = avcodec_decode_video(c, picture, &got_picture,\n<193> if (got_picture) {\n<195> printf("saving last frame %3d\n", frame);\n<205> snprintf(buf, sizeof(buf), outfilename, frame);\n<207> pgm_save(picture->data[0], picture->linesize[0],\n<221> avcodec_close(c);\n<223> free(c);\n<225> free(picture);\n<227> printf("\n");
<1> static int decode_frame_header(AVCodecContext *ctx,\n<7> VP9Context *s = ctx->priv_data;\n<257> if (s->filter.sharpness != sharp)\n<259> memset(s->filter.lim_lut, 0, sizeof(s->filter.lim_lut));\n<263> if ((s->lf_delta.enabled = get_bits1(&s->gb))) {\n<283> memset(&s->lf_delta, 0, sizeof(s->lf_delta));\n<519> if (s->keyframe || s->errorres || s->intraonly) {\n<525> memcpy(s->prob_ctx[0].coef, vp9_default_coef_probs,\n<529> memcpy(s->prob_ctx[1].coef, vp9_default_coef_probs,\n<533> memcpy(s->prob_ctx[2].coef, vp9_default_coef_probs,\n<537> memcpy(s->prob_ctx[3].coef, vp9_default_coef_probs,\n<571> if (s->keyframe || s->intraonly) {\n<573> memset(s->counts.coef, 0, sizeof(s->counts.coef) + sizeof(s->counts.eob));\n<577> memset(&s->counts, 0, sizeof(s->counts));\n<659> uint8_t *r = ref[j][k][l][m];\n<669> p[n] = update_prob(&s->c, r[n]);\n<673> p[n] = r[n];\n<679> p[3] = 0;\n<693> uint8_t *p = s->prob.coef[i][j][k][l][m];\n<695> uint8_t *r = ref[j][k][l][m];\n<697> if (m > 3 && l == 0) // dc only has 3 pt\n<701> memcpy(p, r, 3);\n<703> p[3] = 0;
<1> create_iovec(BlockBackend *blk, QEMUIOVector *qiov, char **argv, int nr_iov,\n<27> len = cvtnum(arg);\n<39> if (len > SIZE_MAX) {\n<41> printf("Argument '%s' exceeds maximum size %llu\n", arg,
<1> static void load_symbols(struct elfhdr *hdr, int fd)\n<33> symtab = sechdr;\n<65> s = malloc(sizeof(*s));\n<67> syms = malloc(symtab.sh_size);\n<69> if (!syms)\n<73> s->disas_strtab = strings = malloc(strtab.sh_size);\n<75> if (!s->disas_strtab)\n<83> if (read(fd, syms, symtab.sh_size) != symtab.sh_size)\n<115> syms[i] = syms[nsyms];\n<135> syms = realloc(syms, nsyms * sizeof(*syms));\n<139> qsort(syms, nsyms, sizeof(*syms), symcmp);\n<145> if (read(fd, strings, strtab.sh_size) != strtab.sh_size)\n<167> syminfos = s;
<1> void qemu_coroutine_enter(Coroutine *co)\n<15> if (co->caller) {\n<17> fprintf(stderr, "Co-routine re-entered recursively\n");
<1> QEMUFile *qemu_fdopen(int fd, const char *mode)\n<15> fprintf(stderr, "qemu_fdopen: Argument validity check failed\n");
<1> static void check_locks ( void ) {\n<8> if ( ! refresh_lock ( lock ) ) {\n<9> fprintf ( stderr , "Unable to refresh lock for %s\n" , lock -> url ) ;
<116> for (x=0; x<h/2; x++)\n<120> for (x=0; x<w/sps; x++)\n<121> memcpy(track->audio.buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n<125> while (track->audio.pkt_cnt) {
<1> static struct archive_string_conv * find_sconv_object ( struct archive * a , const char * fc , const char * tc ) {\n<5> sc != NULL ;\n<6> sc = sc -> next ) {\n<7> if ( strcmp ( sc -> from_charset , fc ) == 0 && strcmp ( sc -> to_charset , tc ) == 0 ) break ;\n<9> return ( sc ) ;
<1> static int decode_ref_pic_list_reordering(H264Context *h){\n<17> for(list=0; list<2; list++){\n<19> memcpy(h->ref_list[list], h->default_ref_list[list], sizeof(Picture)*h->ref_count[list]);\n<127> if (i < 0) {\n<131> memset(&h->ref_list[list][index], 0, sizeof(Picture)); //FIXME\n<145> h->ref_list[list][i]= h->ref_list[list][i-1];\n<149> h->ref_list[list][index]= *ref;
<1> static int ac3_decode_frame(AVCodecContext * avctx, void *data,\n<7> const uint8_t *buf = avpkt->data;\n<11> AC3DecodeContext *s = avctx->priv_data;\n<17> const float *output[AC3_MAX_CHANNELS];\n<25> if (buf_size >= 2 && AV_RB16(buf) == 0x770B) {\n<35> memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));\n<37> buf = s->input_buffer;\n<47> err = parse_frame_header(s);\n<193> set_downmix_coeffs(s);\n<249> s->outptr[channel_map[ch]] = (float *)s->frame.data[ch];\n<255> output[ch] = s->output[ch];\n<261> if (!err && decode_audio_block(s, blk)) {\n<271> for (ch = 0; ch < s->out_channels; ch++)\n<273> memcpy(s->outptr[channel_map[ch]], output[ch], 1024);\n<277> output[ch] = s->outptr[channel_map[ch]];\n<279> s->outptr[channel_map[ch]] += AC3_BLOCK_SIZE;\n<293> for (ch = 0; ch < s->out_channels; ch++)\n<295> memcpy(s->output[ch], output[ch], 1024);
<1> static void http_bad_request ( void ) {\n<8> fprintf ( stdout , "Testing \"Bad Request\" on connection close: " ) ;\n<10> if ( evhttp_bind_socket ( http , "127.0.0.1" , port + 1 ) == - 1 ) {\n<11> fprintf ( stdout , "FAILED (bind)\n" ) ;\n<25> if ( test_ok != 0 ) {\n<26> fprintf ( stdout , "FAILED\n" ) ;\n<31> bufferevent_enable ( bev , EV_READ ) ;\n<32> http_request = "GET /badrequest HTTP/1.0\r\n" "Connection: Keep-Alive\r\n" "\r\n" ;\n<33> bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n<36> event_once ( - 1 , EV_TIMEOUT , http_badreq_successcb , bev , & tv ) ;\n<39> if ( test_ok != 2 ) {\n<40> fprintf ( stdout , "FAILED\n" ) ;\n<43> fprintf ( stdout , "OK\n" ) ;
<1> static void _slurm_rpc_comp_msg_list ( composite_msg_t * comp_msg , bool * run_scheduler , List msg_list_in , struct timeval * start_tv , int timeout ) {\n<25> case MESSAGE_COMPOSITE : comp_resp_msg = xmalloc ( sizeof ( composite_msg_t ) ) ;\n<29> _slurm_rpc_comp_msg_list ( ncomp_msg , run_scheduler , comp_resp_msg -> msg_list , start_tv , timeout ) ;\n<30> if ( list_count ( comp_resp_msg -> msg_list ) ) {\n<37> memcpy ( & comp_resp_msg -> sender , & ncomp_msg -> sender , sizeof ( slurm_addr_t ) ) ;\n<38> resp_msg -> data = comp_resp_msg ;\n<41> else slurm_free_composite_msg ( comp_resp_msg ) ;
<1> int qemuMonitorTextGetVirtType ( qemuMonitorPtr mon , int * virtType ) {\n<2> char * reply = NULL ;\n<4> if ( qemuMonitorHMPCommand ( mon , "info kvm" , & reply ) < 0 ) {\n<8> if ( strstr ( reply , "enabled" ) ) * virtType = VIR_DOMAIN_VIRT_KVM ;\n<9> VIR_FREE ( reply ) ;
<1> static int rfc2231_parameter_cmp ( const struct rfc2231_parameter * r1 , const struct rfc2231_parameter * r2 ) {\n<3> ret = strcmp ( r1 -> key , r2 -> key ) ;\n<4> if ( ret != 0 ) return ret ;
<1> static int init_server_components ( ) {\n<49> if ( opt_bin_log ) {\n<50> if ( opt_bin_logname [ 0 ] && opt_bin_logname [ strlen ( opt_bin_logname ) - 1 ] == FN_LIBCHAR ) {\n<51> sql_print_error ( "Path '%s' is a directory name, please specify \ a file name for --log-bin option" , opt_bin_logname ) ;\n<54> if ( opt_binlog_index_name && opt_binlog_index_name [ strlen ( opt_binlog_index_name ) - 1 ] == FN_LIBCHAR ) {\n<55> sql_print_error ( "Path '%s' is a directory name, please specify \ a file name for --log-bin-index option" , opt_binlog_index_name ) ;\n<60> ln = mysql_bin_log . generate_name ( opt_bin_logname , "-bin" , 1 , buf ) ;\n<61> if ( ! opt_bin_logname [ 0 ] && ! opt_binlog_index_name ) {\n<68> if ( mysql_bin_log . open_index_file ( opt_binlog_index_name , ln , TRUE ) ) {\n<95> remaining_argv -- ;\n<97> if ( remaining_argc > 1 ) {\n<98> fprintf ( stderr , "%s: Too many arguments (first extra is '%s').\n" , my_progname , remaining_argv [ 1 ] ) ;\n<125> default_storage_engine , strlen ( default_storage_engine ) }\n<156> if ( tc_log -> open ( opt_bin_log ? opt_bin_logname : opt_tc_log_file ) ) {
<1> static void omap_rtc_write(void *opaque, hwaddr addr,\n<7> struct omap_rtc_s *s = (struct omap_rtc_s *) opaque;\n<25> switch (offset) {\n<107> memcpy(&new_tm, &s->current_tm, sizeof(new_tm));\n<111> ti[0] = mktimegm(&s->current_tm);\n<113> ti[1] = mktimegm(&new_tm);\n<145> memcpy(&new_tm, &s->current_tm, sizeof(new_tm));\n<149> ti[0] = mktimegm(&s->current_tm);\n<151> ti[1] = mktimegm(&new_tm);
<1> static struct isoent * isoent_new ( struct isofile * file ) {\n<6> isoent = calloc ( 1 , sizeof ( * isoent ) ) ;\n<7> if ( isoent == NULL ) return ( NULL ) ;
<1> struct key_type * key_type_lookup ( const char * type ) {\n<4> list_for_each_entry ( ktype , & key_types_list , link ) {\n<5> if ( strcmp ( ktype -> name , type ) == 0 ) goto found_kernel_type ;\n<7> up_read ( & key_types_sem ) ;\n<8> ktype = ERR_PTR ( - ENOKEY ) ;\n<9> found_kernel_type : return ktype ;
<1> char *qemu_find_file(int type, const char *name)\n<15> if (access(name, R_OK) == 0) {\n<25> subdir = "";\n<31> subdir = "keymaps/";\n<41> len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n<43> buf = g_malloc0(len);\n<45> snprintf(buf, len, "%s/%s%s", data_dir, subdir, name);
<1> static void dumppost ( struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n<22> if ( at -> gi . bygid [ i ] != - 1 && sf -> glyphs [ at -> gi . bygid [ i ] ] != NULL ) {\n<23> SplineChar * sc = sf -> glyphs [ at -> gi . bygid [ i ] ] ;\n<31> if ( strcmp ( sc -> name , ".notdef" ) == 0 ) putshort ( at -> post , 0 ) ;\n<33> for ( j = 0 ;\n<34> j < 258 ;\n<35> ++ j ) if ( strcmp ( sc -> name , ttfstandardnames [ j ] ) == 0 ) break ;\n<36> if ( j != 258 ) putshort ( at -> post , j ) ;\n<53> ++ i ) if ( at -> gi . bygid [ i ] != - 1 ) {\n<54> SplineChar * sc = sf -> glyphs [ at -> gi . bygid [ i ] ] ;\n<55> if ( strcmp ( sc -> name , ".notdef" ) == 0 ) ;\n<57> for ( j = 0 ;\n<58> j < 258 ;\n<59> ++ j ) if ( strcmp ( sc -> name , ttfstandardnames [ j ] ) == 0 ) break ;\n<60> if ( j != 258 ) ;\n<61> else dumppstr ( at -> post , sc -> name ) ;
<1> jas_image_t * jas_image_chclrspc ( jas_image_t * image , jas_cmprof_t * outprof , int intent ) {\n<93> if ( ! ( xform = jas_cmxform_create ( inprof , outprof , 0 , JAS_CMXFORM_OP_FWD , intent , 0 ) ) ) goto error ;\n<95> incmptfmts = malloc ( numinclrchans * sizeof ( jas_cmcmptfmt_t ) ) ;\n<96> assert ( incmptfmts ) ;\n<99> i < numinclrchans ;\n<100> ++ i ) {\n<103> if ( ! ( incmptfmts [ i ] . buf = malloc ( width * sizeof ( long ) ) ) ) goto error ;\n<104> incmptfmts [ i ] . prec = jas_image_cmptprec ( inimage , j ) ;\n<105> incmptfmts [ i ] . sgnd = jas_image_cmptsgnd ( inimage , j ) ;\n<106> incmptfmts [ i ] . width = width ;\n<107> incmptfmts [ i ] . height = 1 ;\n<110> outcmptfmts = malloc ( numoutclrchans * sizeof ( jas_cmcmptfmt_t ) ) ;\n<111> assert ( outcmptfmts ) ;\n<114> i < numoutclrchans ;\n<115> ++ i ) {\n<118> if ( ! ( outcmptfmts [ i ] . buf = malloc ( width * sizeof ( long ) ) ) ) goto error ;\n<119> outcmptfmts [ i ] . prec = jas_image_cmptprec ( outimage , j ) ;\n<120> outcmptfmts [ i ] . sgnd = jas_image_cmptsgnd ( outimage , j ) ;\n<121> outcmptfmts [ i ] . width = width ;\n<122> outcmptfmts [ i ] . height = 1 ;
<1> static int kex_agree_comp ( LIBSSH2_SESSION * session , libssh2_endpoint_data * endpoint , unsigned char * comp , unsigned long comp_len ) {\n<7> while ( s && * s ) {\n<8> unsigned char * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n<9> size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n<22> while ( * compp && ( * compp ) -> name ) {\n<23> s = kex_agree_instr ( comp , comp_len , ( unsigned char * ) ( * compp ) -> name , strlen ( ( * compp ) -> name ) ) ;\n<25> endpoint -> comp = * compp ;
<1> int load_elf_binary(struct linux_binprm * bprm, struct target_pt_regs * regs,\n<71> if ((elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) ||\n<97> elf_phdata = (struct elf_phdr *)malloc(elf_ex.e_phentsize*elf_ex.e_phnum);\n<99> if (elf_phdata == NULL) {\n<119> if (retval < 0) {\n<125> free (elf_phdata);\n<145> elf_ppnt = elf_phdata;\n<159> elf_interpreter = NULL;\n<176> if ( elf_interpreter != NULL )\n<180> free (elf_phdata);\n<182> free(elf_interpreter);\n<202> elf_interpreter = (char *)malloc(elf_ppnt->p_filesz);\n<206> if (elf_interpreter == NULL) {\n<208> free (elf_phdata);\n<222> retval = read(bprm->fd, elf_interpreter, elf_ppnt->p_filesz);\n<248> if (strcmp(elf_interpreter,"/usr/lib/libc.so.1") == 0 ||\n<250> strcmp(elf_interpreter,"/usr/lib/ld.so.1") == 0) {\n<252> ibcs2_interpreter = 1;\n<266> retval = open(path(elf_interpreter), O_RDONLY);\n<276> perror(elf_interpreter);\n<308> if (retval < 0) {\n<314> free (elf_phdata);\n<316> free(elf_interpreter);\n<326> elf_ppnt++;\n<362> if (!interpreter_type) {\n<364> free(elf_interpreter);\n<366> free(elf_phdata);\n<408> if (!bprm->p) {\n<410> if (elf_interpreter) {\n<412> free(elf_interpreter);\n<416> free (elf_phdata);\n<466> for(i = 0, elf_ppnt = elf_phdata; i < elf_ex.e_phnum; i++, elf_ppnt++) {\n<526> error = target_mmap(TARGET_ELF_PAGESTART(load_bias + elf_ppnt->p_vaddr),\n<592> k = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n<630> if (elf_interpreter) {\n<652> free(elf_interpreter);\n<656> if (elf_entry == ~((abi_ulong)0UL)) {\n<658> printf("Unable to load interpreter\n");\n<660> free(elf_phdata);\n<672> free(elf_phdata);
<1> static void get_object_details ( void ) {\n<7> i ++ ) sorted_by_offset [ i ] = to_pack . objects + i ;\n<8> qsort ( sorted_by_offset , to_pack . nr_objects , sizeof ( * sorted_by_offset ) , pack_offset_sort ) ;\n<16> free ( sorted_by_offset ) ;
<1> static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n<13> uint8_t tag = ncq_fis->tag >> 3;\n<19> if (ncq_tfs->used) {\n<23> fprintf(stderr, "%s: tag %d already used\n", __FUNCTION__, tag);
<1> void http_request_done ( struct evhttp_request * req , void * arg ) {\n<2> const char * what = "This is funny" ;\n<3> if ( req -> response_code != HTTP_OK ) {\n<4> fprintf ( stderr , "FAILED\n" ) ;\n<7> if ( evhttp_find_header ( req -> input_headers , "Content-Type" ) == NULL ) {\n<8> fprintf ( stderr , "FAILED\n" ) ;\n<11> if ( EVBUFFER_LENGTH ( req -> input_buffer ) != strlen ( what ) ) {\n<12> fprintf ( stderr , "FAILED\n" ) ;\n<15> if ( memcmp ( EVBUFFER_DATA ( req -> input_buffer ) , what , strlen ( what ) ) != 0 ) {\n<16> fprintf ( stderr , "FAILED\n" ) ;\n<17> exit ( 1 ) ;
<1> QTestState *qtest_init(const char *extra_args)\n<21> qemu_binary = getenv("QTEST_QEMU_BINARY");\n<23> g_assert(qemu_binary != NULL);\n<121> if (getenv("QTEST_STOP")) {\n<123> kill(s->qemu_pid, SIGSTOP);
<1> static void purple_init ( account_t * acc ) {\n<30> g_string_printf ( help , "BitlBee libpurple module %s (%s).\n\nSupported settings:" , ( char * ) acc -> prpl -> name , prpl -> info -> name ) ;\n<72> io ;\n<74> PurpleKeyValuePair * kv = io -> data ;\n<75> opts = g_slist_append ( opts , kv -> value ) ;\n<76> if ( strcmp ( kv -> value , kv -> key ) != 0 ) {\n<77> g_string_append_printf ( help , "%s (%s), " , ( char * ) kv -> value , kv -> key ) ;\n<80> g_string_append_printf ( help , "%s, " , ( char * ) kv -> value ) ;\n<108> if ( strcmp ( prpl -> info -> name , "Gadu-Gadu" ) == 0 ) {\n<109> s = set_add ( & acc -> set , "gg_sync_contacts" , "true" , set_eval_bool , acc ) ;
<1> int ff_h264_handle_aggregated_packet ( AVFormatContext * ctx , PayloadContext * data , AVPacket * pkt , const uint8_t * buf , int len , int skip_between , int * nal_counters , int nal_mask ) {\n<4> uint8_t * dst = NULL ;\n<13> src += 2 ;\n<15> if ( nal_size <= src_len ) {\n<16> if ( pass == 0 ) {\n<20> memcpy ( dst , start_sequence , sizeof ( start_sequence ) ) ;\n<21> dst += sizeof ( start_sequence ) ;\n<22> memcpy ( dst , src , nal_size ) ;\n<23> if ( nal_counters ) nal_counters [ ( * src ) & nal_mask ] ++ ;\n<24> dst += nal_size ;\n<31> src += nal_size + skip_between ;\n<32> src_len -= nal_size + skip_between ;\n<36> dst = pkt -> data ;
<1> REGRESSION_TEST ( SDK_API_TSIOBufferCopy ) ( RegressionTest * test , int , int * pstatus ) {\n<4> char input_buf [ ] = "This is the test for TSIOBufferCopy, TSIOBufferWrite, TSIOBufferReaderCopy" ;\n<7> TSIOBuffer bufp2 = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;\n<8> TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;\n<9> TSIOBufferWrite ( bufp , input_buf , ( strlen ( input_buf ) + 1 ) ) ;\n<10> TSIOBufferCopy ( bufp2 , readerp , ( strlen ( input_buf ) + 1 ) , 0 ) ;\n<11> TSIOBufferReaderCopy ( readerp , output_buf , ( strlen ( input_buf ) + 1 ) ) ;\n<12> if ( strcmp ( input_buf , output_buf ) == 0 ) {\n<13> SDK_RPRINT ( test , "TSIOBufferWrite" , "TestCase1" , TC_PASS , "ok" ) ;\n<14> SDK_RPRINT ( test , "TSIOBufferCopy" , "TestCase1" , TC_PASS , "ok" ) ;\n<15> SDK_RPRINT ( test , "TSIOBufferReaderCopy" , "TestCase1" , TC_PASS , "ok" ) ;\n<16> test_passed = true ;\n<19> SDK_RPRINT ( test , "TSIOBufferWrite" , "TestCase1" , TC_FAIL , "failed" ) ;\n<20> SDK_RPRINT ( test , "TSIOBufferCopy" , "TestCase1" , TC_FAIL , "failed" ) ;\n<21> SDK_RPRINT ( test , "TSIOBufferReaderCopy" , "TestCase1" , TC_FAIL , "failed" ) ;
<1> static int opus_decode_packet(AVCodecContext *avctx, void *data,\n<179> if (map->copy) {\n<187> } else if (map->silence) {\n<189> memset(frame->extended_data[i], 0, frame->linesize[0]);\n<197> c->fdsp->vector_fmul_scalar((float*)frame->extended_data[i],\n<199> (float*)frame->extended_data[i],
<1> static int opt_map(OptionsContext *o, const char *opt, const char *arg)\n<25> map = av_strdup(arg);\n<31> if (sync = strchr(map, ',')) {\n<33> *sync = 0;\n<35> sync_file_idx = strtol(sync + 1, &sync, 0);\n<37> if (sync_file_idx >= nb_input_files || sync_file_idx < 0) {\n<45> if (*sync)\n<47> sync++;\n<49> for (i = 0; i < input_files[sync_file_idx].nb_streams; i++)\n<51> if (check_stream_specifier(input_files[sync_file_idx].ctx,\n<61> if (i == input_files[sync_file_idx].nb_streams) {\n<77> file_idx = strtol(map, &p, 0);
<1> static int check_bind(const char *hostname, bool *has_proto)\n<15> memset(&ai, 0, sizeof(ai));\n<27> rc = getaddrinfo(hostname, NULL, &ai, &res);
<1> int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,\n<21> src_size = max_size;\n<25> mrk = AV_RB32(src);\n<27> switch (mrk) {\n<31> memcpy(dst, src, src_size);\n<33> return src_size;
<637> if (pal_src - st->codecpar->extradata >= 9 &&\n<639> !memcmp(st->codecpar->extradata + st->codecpar->extradata_size - 9, "BottomUp", 9))
<1> static gpgme_error_t _uiserver_decrypt ( void * engine , int verify , gpgme_data_t ciph , gpgme_data_t plain ) {\n<7> if ( uiserver -> protocol == GPGME_PROTOCOL_DEFAULT ) protocol = "" ;\n<8> else if ( uiserver -> protocol == GPGME_PROTOCOL_OpenPGP ) protocol = " --protocol=OpenPGP" ;\n<9> else if ( uiserver -> protocol == GPGME_PROTOCOL_CMS ) protocol = " --protocol=CMS" ;\n<11> if ( asprintf ( & cmd , "DECRYPT%s%s" , protocol , verify ? "" : " --no-verify" ) < 0 ) return gpg_error_from_syserror ( ) ;\n<12> uiserver -> input_cb . data = ciph ;\n<13> err = uiserver_set_fd ( uiserver , INPUT_FD , map_data_enc ( uiserver -> input_cb . data ) ) ;\n<14> if ( err ) {\n<15> free ( cmd ) ;\n<20> if ( err ) {\n<21> free ( cmd ) ;\n<25> err = start ( engine , cmd ) ;\n<26> free ( cmd ) ;
<1> ssize_t ne2000_receive(NetClientState *nc, const uint8_t *buf, size_t size_)\n<5> NE2000State *s = qemu_get_nic_opaque(nc);\n<13> uint8_t buf1[60];\n<29> if (s->cmd & E8390_STOP || ne2000_buffer_full(s))\n<37> if (s->rxcr & 0x10) {\n<43> if (!memcmp(buf,  broadcast_macaddr, 6)) {\n<47> if (!(s->rxcr & 0x04))\n<51> } else if (buf[0] & 0x01) {\n<59> mcast_idx = compute_mcast_idx(buf);\n<65> } else if (s->mem[0] == buf[0] &&\n<67> s->mem[2] == buf[1] &&\n<69> s->mem[4] == buf[2] &&\n<71> s->mem[6] == buf[3] &&\n<73> s->mem[8] == buf[4] &&\n<75> s->mem[10] == buf[5]) {\n<93> if (size < MIN_BUF_SIZE) {\n<95> memcpy(buf1, buf, size);\n<97> memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n<99> buf = buf1;\n<135> if (buf[0] & 0x01)\n<153> while (size > 0) {\n<155> if (index <= s->stop)\n<157> avail = s->stop - index;\n<165> if (len > avail)\n<167> len = avail;\n<169> memcpy(s->mem + index, buf, len);\n<171> buf += len;\n<173> index += len;\n<179> size -= len;
<1> void start_auth_sasl(VncState *vs)\n<63> if (err != SASL_OK) {\n<133> memset (&secprops, 0, sizeof secprops);\n<183> err = sasl_setprop(vs->sasl.conn, SASL_SEC_PROPS, &secprops);\n<217> if (err != SASL_OK) {\n<235> vs->sasl.mechlist = g_strdup(mechlist);\n<237> mechlistlen = strlen(mechlist);\n<239> vnc_write_u32(vs, mechlistlen);\n<241> vnc_write(vs, mechlist, mechlistlen);
<1> static const unsigned char * seq_decode_op1 ( SeqVideoContext * seq , const unsigned char * src , const unsigned char * src_end , unsigned char * dst ) {\n<10> case 1 : src = seq_unpack_rle_block ( src , src_end , block , sizeof ( block ) ) ;\n<12> b < 8 ;\n<14> memcpy ( dst , & block [ b * 8 ] , 8 ) ;\n<15> dst += seq -> frame . linesize [ 0 ] ;
<1> static int aout_update_format ( decoder_t * p_dec ) {\n<2> decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n<3> if ( p_owner -> p_aout && ( ! AOUT_FMTS_IDENTICAL ( & p_dec -> fmt_out . audio , & p_owner -> audio ) || p_dec -> fmt_out . i_codec != p_dec -> fmt_out . audio . i_format ) ) {\n<11> if ( p_owner -> p_aout == NULL ) {\n<17> p_owner -> audio = p_dec -> fmt_out . audio ;\n<18> aout_FormatPrepare ( & p_owner -> audio ) ;\n<19> memcpy ( & format , & p_owner -> audio , sizeof ( audio_sample_format_t ) ) ;\n<33> if ( aout_DecNew ( p_aout , & format , & p_dec -> fmt_out . audio_replay_gain , & request_vout ) ) {
<1> static int plot_cqt(AVFilterContext *ctx)\n<7> ShowCQTContext *s = ctx->priv;\n<13> memcpy(s->fft_result, s->fft_data, s->fft_len * sizeof(*s->fft_data));\n<15> av_fft_permute(s->fft_ctx, s->fft_result);\n<23> process_cqt(s);
<15> while (pre_entry != cur->next) {\n<17> if (!strcmp(pre_entry->value->name, cur->next->value->name)) {\n<19> del_entry = cur->next;\n<21> cur->next = cur->next->next;\n<23> g_free(del_entry);\n<29> pre_entry = pre_entry->next;
<1> static void test_view ( ) {\n<8> const char * query = "SELECT COUNT(*) FROM v1 WHERE SERVERNAME=?" ;\n<22> stmt = mysql_stmt_init ( mysql ) ;\n<23> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<24> check_execute ( stmt , rc ) ;\n<26> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<33> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static const char * NoMeta ( const char * str ) {\n<2> if ( strchr ( str , '%' ) != NULL ) return "**** CORRUPTED FORMAT STRING ***" ;\n<3> return str ;
<1> int ff_h264_decode_ref_pic_list_reordering ( H264Context * h ) {\n<66> if ( i < 0 ) {\n<68> memset ( & h -> ref_list [ list ] [ index ] , 0 , sizeof ( Picture ) ) ;\n<81> COPY_PICTURE ( & h -> ref_list [ list ] [ index ] , ref ) ;\n<83> pic_as_field ( & h -> ref_list [ list ] [ index ] , pic_structure ) ;\n<102> if ( h -> default_ref_list [ list ] [ 0 ] . f . data [ 0 ] ) COPY_PICTURE ( & h -> ref_list [ list ] [ index ] , & h -> default_ref_list [ list ] [ 0 ] ) ;
<1> static int search_try_next ( struct request * const req ) {\n<18> if ( ! new_name ) return 1 ;\n<20> newreq = request_new ( req -> request_type , new_name , req -> search_flags , req -> user_callback , req -> user_pointer ) ;\n<21> free ( new_name ) ;
<1> void do_commit(Monitor *mon, const QDict *qdict)\n<5> const char *device = qdict_get_str(qdict, "device");\n<11> if (!strcmp(device, "all")) {\n<13> bdrv_commit_all();\n<21> bs = bdrv_find(device);\n<23> if (!bs) {
<1> static void add_user_option ( String * grant , ulong value , const char * name ) {\n<2> if ( value ) {\n<5> grant -> append ( name , strlen ( name ) ) ;
<1> static void kadmin_addprinc_usage ( ) {\n<2> fprintf ( stderr , _ ( "usage: add_principal [options] principal\n" ) ) ;\n<3> fprintf ( stderr , _ ( "\toptions are:\n" ) ) ;
<1> static void pxa2xx_ssp_write ( void * opaque , hwaddr addr , uint64_t value64 , unsigned size ) {\n<7> if ( value & SSCR0_MOD ) printf ( "%s: Attempt to use network mode\n" , __FUNCTION__ ) ;\n<8> if ( s -> enable && SSCR0_DSS ( value ) < 4 ) printf ( "%s: Wrong data size: %i bits\n" , __FUNCTION__ , SSCR0_DSS ( value ) ) ;\n<17> if ( value & ( SSCR1_LBM | SSCR1_EFWR ) ) printf ( "%s: Attempt to use SSP test mode\n" , __FUNCTION__ ) ;
<1> VAR * var_get ( const char * var_name , const char * * var_name_end , my_bool raw , my_bool ignore_not_existing ) {\n<19> if ( ! ( v = ( VAR * ) my_hash_search ( & var_hash , ( const uchar * ) save_var_name , length ) ) ) {\n<22> v = var_from_env ( buff , "" ) ;\n<26> else v = var_reg + digit ;\n<27> if ( ! raw && v -> int_dirty ) {\n<28> sprintf ( v -> str_val , "%d" , v -> int_val ) ;\n<30> v -> str_val_len = strlen ( v -> str_val ) ;\n<33> DBUG_RETURN ( v ) ;
<1> void OS2FigureUnicodeRanges ( SplineFont * sf , uint32 Ranges [ 4 ] ) {\n<6> memset ( Ranges , 0 , 4 * sizeof ( uint32 ) ) ;\n<14> if ( sc -> unicodeenc > 0xffff ) Ranges [ 57 >> 5 ] |= ( 1 << ( 57 & 31 ) ) ;\n<19> Ranges [ bit >> 5 ] |= ( 1 << ( bit & 31 ) ) ;
<1> QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n<5> char host[65], port[33], width[8], height[8];\n<19> if (error_is_set(&local_err)) {\n<31> if (strstart(filename, "mon:", &p)) {\n<33> filename = p;\n<37> if (strcmp(filename, "stdio") == 0) {\n<49> qemu_opt_set(opts, "signal", "off");\n<57> if (strcmp(filename, "null")    == 0 ||\n<59> strcmp(filename, "pty")     == 0 ||\n<61> strcmp(filename, "msmouse") == 0 ||\n<63> strcmp(filename, "braille") == 0 ||\n<65> strcmp(filename, "stdio")   == 0) {\n<67> qemu_opt_set(opts, "backend", filename);\n<69> return opts;\n<73> if (strstart(filename, "vc", &p)) {\n<77> if (*p == ':') {\n<79> if (sscanf(p+1, "%8[0-9]x%8[0-9]", width, height) == 2) {\n<83> qemu_opt_set(opts, "width", width);\n<85> qemu_opt_set(opts, "height", height);\n<87> } else if (sscanf(p+1, "%8[0-9]Cx%8[0-9]C", width, height) == 2) {\n<91> qemu_opt_set(opts, "cols", width);\n<93> qemu_opt_set(opts, "rows", height);\n<103> return opts;\n<107> if (strcmp(filename, "con:") == 0) {\n<109> qemu_opt_set(opts, "backend", "console");\n<111> return opts;\n<115> if (strstart(filename, "COM", NULL)) {\n<125> if (strstart(filename, "file:", &p)) {\n<135> if (strstart(filename, "pipe:", &p)) {\n<145> if (strstart(filename, "tcp:", &p) ||\n<147> strstart(filename, "telnet:", &p)) {\n<149> if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) {\n<151> host[0] = 0;\n<153> if (sscanf(p, ":%32[^,]%n", port, &pos) < 1)\n<159> qemu_opt_set(opts, "backend", "socket");\n<161> qemu_opt_set(opts, "host", host);\n<163> qemu_opt_set(opts, "port", port);\n<165> if (p[pos] == ',') {\n<167> if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n<173> if (strstart(filename, "telnet:", &p))\n<181> if (strstart(filename, "udp:", &p)) {\n<185> if (sscanf(p, "%64[^:]:%32[^@,]%n", host, port, &pos) < 2) {\n<187> host[0] = 0;\n<189> if (sscanf(p, ":%32[^@,]%n", port, &pos) < 1) {\n<197> qemu_opt_set(opts, "host", host);\n<199> qemu_opt_set(opts, "port", port);\n<201> if (p[pos] == '@') {\n<203> p += pos + 1;\n<205> if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) {\n<207> host[0] = 0;\n<209> if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) {\n<217> qemu_opt_set(opts, "localaddr", host);\n<219> qemu_opt_set(opts, "localport", port);\n<223> return opts;\n<265> qemu_opts_del(opts);\n<267> return NULL;
<1> static void dropDBs ( PGconn * conn ) {\n<6> if ( PQntuples ( res ) > 0 ) fprintf ( OPF , "--\n-- Drop databases\n--\n\n" ) ;\n<8> i < PQntuples ( res ) ;\n<10> char * dbname = PQgetvalue ( res , i , 0 ) ;\n<11> if ( strcmp ( dbname , "template1" ) != 0 && strcmp ( dbname , "postgres" ) != 0 ) {\n<17> fprintf ( OPF , "\n\n" ) ;
<54> if (avctx->skip_frame >= AVDISCARD_NONREF ||\n<55> buf_size >= 4 && !memcmp("Q264", buf, 4))
<1> static int vc1_decode_p_mb_intfr ( VC1Context * v ) {\n<53> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 1 ;\n<76> vc1_decode_intra_block ( v , s -> block [ i ] , i , val , mquant , ( i & 4 ) ? v -> codingset2 : v -> codingset ) ;\n<101> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n<119> vc1_mc_4mv_luma ( v , i , 0 ) ;\n<122> vc1_mc_4mv_chroma4 ( v ) ;\n<142> vc1_mc_4mv_chroma4 ( v ) ;\n<151> vc1_mc_1mv ( v , 0 ) ;\n<165> pat = vc1_decode_p_block ( v , s -> block [ i ] , i , mquant , ttmb , first_block , s -> dest [ dst_idx ] + off , ( i & 4 ) ? s -> uvlinesize : ( s -> linesize << fieldtx ) , ( i & 4 ) && ( s -> flags & CODEC_FLAG_GRAY ) , & block_tt ) ;\n<174> s -> mb_intra = v -> is_intra [ s -> mb_x ] = 0 ;\n<188> vc1_mc_1mv ( v , 0 ) ;\n<190> if ( s -> mb_x == s -> mb_width - 1 ) memmove ( v -> is_intra_base , v -> is_intra , sizeof ( v -> is_intra_base [ 0 ] ) * s -> mb_stride ) ;
<1> static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)\n<15> memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_epel_pixels_tab, sizeof(s->put_pixels_tab));\n<28> vp78_reset_probability_tables(s);\n<29> memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter, sizeof(s->prob->pred16x16));\n<30> memcpy(s->prob->pred8x8c , vp8_pred8x8c_prob_inter , sizeof(s->prob->pred8x8c));\n<31> for (i = 0; i < 2; i++)\n<32> memcpy(s->prob->mvc[i], vp7_mv_default_prob[i], sizeof(vp7_mv_default_prob[i]));\n<33> memset(&s->segmentation, 0, sizeof(s->segmentation));\n<34> memset(&s->lf_delta, 0, sizeof(s->lf_delta));\n<35> memcpy(s->prob[0].scan, zigzag_scan, sizeof(s->prob[0].scan));\n<36> if (s->keyframe || s->profile > 0)\n<37> memset(s->inter_dc_pred, 0 , sizeof(s->inter_dc_pred));\n<55> if ((ret = update_dimensions(s, width, height)) < 0)\n<58> vp7_get_quants(s);\n<99> s->prob[0].scan[i] = zigzag_scan[vp8_rac_get_uint(c, 4)];\n<106> vp78_update_probability_tables(s);\n<112> vp78_update_pred16x16_pred8x8_mvc_probabilities(s);
<1> static void test_store_result ( ) {\n<20> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<31> length1 = 0 ;\n<34> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<42> if ( ! opt_silent ) fprintf ( stdout , "\n row 1: %ld, %s(%lu)" , ( long ) nData , szData , length1 ) ;\n<43> DIE_UNLESS ( nData == 10 ) ;\n<44> DIE_UNLESS ( strcmp ( szData , "venu" ) == 0 ) ;\n<45> DIE_UNLESS ( length1 == 4 ) ;\n<48> if ( ! opt_silent ) fprintf ( stdout , "\n row 2: %ld, %s(%lu)" , ( long ) nData , szData , length1 ) ;\n<49> DIE_UNLESS ( nData == 20 ) ;\n<50> DIE_UNLESS ( strcmp ( szData , "mysql" ) == 0 ) ;\n<51> DIE_UNLESS ( length1 == 5 ) ;\n<55> if ( ! opt_silent && is_null [ 0 ] ) fprintf ( stdout , "\n row 3: NULL, %s(%lu)" , szData , length1 ) ;\n<57> DIE_UNLESS ( strcmp ( szData , "monty" ) == 0 ) ;\n<58> DIE_UNLESS ( length1 == 5 ) ;\n<67> if ( ! opt_silent ) fprintf ( stdout , "\n row 1: %ld, %s(%lu)" , ( long ) nData , szData , length1 ) ;\n<68> DIE_UNLESS ( nData == 10 ) ;\n<69> DIE_UNLESS ( strcmp ( szData , "venu" ) == 0 ) ;\n<70> DIE_UNLESS ( length1 == 4 ) ;\n<73> if ( ! opt_silent ) fprintf ( stdout , "\n row 2: %ld, %s(%lu)" , ( long ) nData , szData , length1 ) ;\n<75> DIE_UNLESS ( strcmp ( szData , "mysql" ) == 0 ) ;\n<76> DIE_UNLESS ( length1 == 5 ) ;\n<80> if ( ! opt_silent && is_null [ 0 ] ) fprintf ( stdout , "\n row 3: NULL, %s(%lu)" , szData , length1 ) ;\n<82> DIE_UNLESS ( strcmp ( szData , "monty" ) == 0 ) ;\n<83> DIE_UNLESS ( length1 == 5 ) ;
<1> static void _hb_face_for_data_closure_destroy ( hb_face_for_data_closure_t * closure ) {\n<2> hb_blob_destroy ( closure -> blob ) ;\n<3> free ( closure ) ;
<1> static enum message_read_status evhttp_handle_chunked_read ( struct evhttp_request * req , struct evbuffer * buf ) {\n<3> while ( ( len = EVBUFFER_LENGTH ( buf ) ) > 0 ) {\n<9> if ( p == NULL ) break ;\n<10> if ( strlen ( p ) == 0 ) {\n<11> free ( p ) ;\n<14> ntoread = evutil_strtoll ( p , & endp , 16 ) ;\n<15> error = ( * p == '\0' || ( * endp != '\0' && * endp != ' ' ) || ntoread < 0 ) ;\n<16> free ( p ) ;\n<17> if ( error ) {
<1> static int hls_write_header(AVFormatContext *s)\n<11> const char *pattern = "%d.ts";\n<13> int basename_size = strlen(s->filename) + strlen(pattern);\n<59> hls->basename = av_malloc(basename_size);\n<73> strcpy(hls->basename, s->filename);
<1> static void spapr_finalize_fdt(sPAPREnvironment *spapr,\n<35> if (ret < 0) {\n<37> fprintf(stderr, "couldn't setup memory nodes in fdt\n");\n<47> if (ret < 0) {\n<49> fprintf(stderr, "couldn't setup vio devices in fdt\n");\n<65> if (ret < 0) {\n<67> fprintf(stderr, "couldn't setup PCI devices in fdt\n");\n<79> if (ret < 0) {\n<81> fprintf(stderr, "Couldn't set up RTAS device tree properties\n");\n<91> if (ret < 0) {\n<93> fprintf(stderr, "Couldn't finalize CPU device tree properties\n");
<1> static FILE * NeedsUCS2Table ( SplineFont * sf , int * ucs2len , EncMap * map , int issymbol ) {\n<2> uint32 * avail = malloc ( 65536 * sizeof ( uint32 ) ) ;\n<14> memset ( avail , 0xff , 65536 * sizeof ( uint32 ) ) ;\n<20> avail [ i ] = gid ;\n<31> avail [ sc -> unicodeenc ] = i ;\n<38> avail [ altuni -> unienc ] = i ;\n<45> if ( issymbol ) {\n<46> memset ( avail , 0xff , 0xf020 * sizeof ( uint32 ) ) ;\n<47> memset ( avail + 0xf100 , 0xff , 0x0eff * sizeof ( uint32 ) ) ;\n<50> for ( i = segcnt = 0 ;\n<53> if ( avail [ i ] != 0xffffffff && j == - 1 ) {\n<55> ++ segcnt ;\n<57> else if ( j != - 1 && avail [ i ] == 0xffffffff ) j = - 1 ;\n<59> cmapseg = calloc ( segcnt + 1 , sizeof ( struct cmapseg ) ) ;\n<60> ranges = malloc ( cnt * sizeof ( int16 ) ) ;\n<65> if ( avail [ i ] != 0xffffffff && j == - 1 ) {\n<70> else if ( j != - 1 && avail [ i ] == 0xffffffff ) {\n<82> l = avail [ cmapseg [ i ] . start ] ;\n<88> l = avail [ j ] ;\n<98> l = avail [ j ] ;\n<100> ranges [ rpos ++ ] = sc -> ttf_glyph ;\n<104> free ( avail ) ;\n<130> ++ i ) putshort ( format4 , ranges [ i ] ) ;\n<131> free ( ranges ) ;\n<132> free ( cmapseg ) ;
<1> void commit_command_data ( int cmd ) {\n<2> char error_string [ MAX_INPUT_BUFFER ] ;\n<22> switch ( cmd ) {\n<57> if ( multi_ids [ x ] == 0 ) {\n<58> error [ e ++ ] . message = strdup ( "Comment id cannot be 0" ) ;\n<85> if ( multi_ids [ x ] == 0 ) {\n<86> error [ e ++ ] . message = strdup ( "Downtime id cannot be 0" ) ;\n<118> if ( cmd == CMD_PROCESS_SERVICE_CHECK_RESULT && ! strcmp ( plugin_output , "" ) ) error [ e ++ ] . message = strdup ( "Check output cannot be blank" ) ;\n<119> if ( cmd == CMD_DELAY_SVC_NOTIFICATION && notification_delay <= 0 ) error [ e ++ ] . message = strdup ( "Notification delay must be greater than 0" ) ;\n<120> if ( cmd == CMD_SCHEDULE_SVC_CHECK && start_time == ( time_t ) 0 ) error [ e ++ ] . message = strdup ( "Start time must be non-zero or bad format has been submitted" ) ;\n<150> if ( cmd == CMD_DELAY_HOST_NOTIFICATION && notification_delay <= 0 ) error [ e ++ ] . message = strdup ( "Notification delay must be greater than 0" ) ;\n<151> if ( ( cmd == CMD_SCHEDULE_HOST_CHECK || cmd == CMD_SCHEDULE_HOST_SVC_CHECKS ) && start_time == ( time_t ) 0 ) error [ e ++ ] . message = strdup ( "Start time must be non-zero or bad format has been submitted" ) ;\n<152> if ( cmd == CMD_PROCESS_HOST_CHECK_RESULT && ! strcmp ( plugin_output , "" ) ) error [ e ++ ] . message = strdup ( "Check output cannot be blank" ) ;\n<189> if ( attr != MODATTR_NONE ) {\n<190> error [ e ++ ] . message = strdup ( "You cannot change modified attributes other than reset them!" ) ;\n<200> if ( commands [ x ] . host_name == NULL ) continue ;\n<205> error [ e ++ ] . message = ( char * ) strdup ( error_string ) ;\n<211> error [ e ++ ] . message = strdup ( error_string ) ;
<1> static void test_bug20152 ( ) {\n<6> const char * query = "INSERT INTO t1 (f1) VALUES (?)" ;\n<8> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<15> tm . minute = 9 ;\n<16> tm . second = 42 ;\n<21> stmt = mysql_stmt_init ( mysql ) ;\n<22> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<23> check_execute ( stmt , rc ) ;\n<24> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<32> if ( tm . hour == 14 && tm . minute == 9 && tm . second == 42 ) {\n<33> if ( ! opt_silent ) printf ( "OK!" ) ;\n<36> printf ( "[14:09:42] != [%02d:%02d:%02d]\n" , tm . hour , tm . minute , tm . second ) ;
<1> static MigrationState *migrate_init(const MigrationParams *params)\n<5> MigrationState *s = migrate_get_current();\n<15> memcpy(enabled_capabilities, s->enabled_capabilities,\n<21> memset(s, 0, sizeof(*s));\n<25> memcpy(s->enabled_capabilities, enabled_capabilities,\n<43> return s;
<1> static int capture_android_bluetooth_external_parser ( char * interface , char * fifo , const char * adb_server_ip , unsigned short * adb_server_tcp_port , unsigned short * bt_server_tcp_port , unsigned int bt_forward_socket , const char * bt_local_ip , unsigned short * bt_local_tcp_port ) {\n<12> gssize used_buffer_length = 0 ;\n<19> SET_DATA ( timestamp , value_u64 , buffer ) ;\n<22> if ( is_specified_interface ( interface , INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER ) && strlen ( interface ) > strlen ( INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER ) + 1 ) {\n<23> serial_number = interface + strlen ( INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER ) + 1 ;\n<24> serial_number_length = strlen ( serial_number ) ;\n<27> if ( ( sock = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ) == INVALID_SOCKET ) {\n<28> errmsg_print ( "ERROR: Cannot open system TCP socket: %s" , strerror ( errno ) ) ;\n<34> result = adb_forward ( serial_number , adb_server_ip , adb_server_tcp_port , * bt_local_tcp_port , * bt_server_tcp_port ) ;\n<37> memset ( & server , 0 , sizeof ( server ) ) ;\n<42> if ( connect ( sock , ( struct sockaddr * ) & server , sizeof ( server ) ) == SOCKET_ERROR ) {\n<43> errmsg_print ( "ERROR: <%s> Please check that adb daemon is running." , strerror ( errno ) ) ;\n<49> length = sizeof ( client ) ;\n<50> if ( getsockname ( sock , ( struct sockaddr * ) & client , ( socklen_t * ) & length ) ) {\n<51> errmsg_print ( "ERROR getsockname: %s" , strerror ( errno ) ) ;\n<67> if ( ! serial_number ) {\n<76> result = g_snprintf ( ( char * ) buffer , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<95> result = adb_send ( sock , buffer ) ;\n<102> while ( endless_loop ) {\n<104> length = recv ( sock , buffer + used_buffer_length , ( int ) ( PACKET_LENGTH - used_buffer_length ) , 0 ) ;\n<108> else if ( errno != 0 ) {\n<109> errmsg_print ( "ERROR capture: %s" , strerror ( errno ) ) ;\n<110> closesocket ( sock ) ;\n<113> if ( length <= 0 ) {\n<116> closesocket ( sock ) ;\n<117> if ( ( sock = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ) == INVALID_SOCKET ) {\n<118> errmsg_print ( "ERROR: %s" , strerror ( errno ) ) ;\n<125> if ( connect ( sock , ( struct sockaddr * ) & server , sizeof ( server ) ) == SOCKET_ERROR ) {\n<126> errmsg_print ( "ERROR reconnect: <%s> Please check that adb daemon is running." , strerror ( errno ) ) ;\n<133> closesocket ( sock ) ;\n<138> used_buffer_length += length ;\n<140> while ( ( ( payload [ BLUEDROID_H4_PACKET_TYPE ] == BLUEDROID_H4_PACKET_TYPE_HCI_CMD || payload [ BLUEDROID_H4_PACKET_TYPE ] == BLUEDROID_H4_PACKET_TYPE_SCO ) && used_buffer_length >= BLUEDROID_TIMESTAMP_SIZE + BLUEDROID_H4_SIZE + 2 + 1 && BLUEDROID_TIMESTAMP_SIZE + BLUEDROID_H4_SIZE + 2 + payload [ BLUEDROID_H4_SIZE + 2 ] + 1 <= used_buffer_length ) || ( payload [ BLUEDROID_H4_PACKET_TYPE ] == BLUEDROID_H4_PACKET_TYPE_ACL && used_buffer_length >= BLUEDROID_TIMESTAMP_SIZE + BLUEDROID_H4_SIZE + 2 + 2 && BLUEDROID_TIMESTAMP_SIZE + BLUEDROID_H4_SIZE + 2 + payload [ BLUEDROID_H4_SIZE + 2 ] + ( payload [ BLUEDROID_H4_SIZE + 2 + 1 ] << 8 ) + 2 <= used_buffer_length ) || ( payload [ BLUEDROID_H4_PACKET_TYPE ] == BLUEDROID_H4_PACKET_TYPE_SCO && used_buffer_length >= BLUEDROID_TIMESTAMP_SIZE + BLUEDROID_H4_SIZE + 2 + 1 && BLUEDROID_TIMESTAMP_SIZE + BLUEDROID_H4_SIZE + 2 + payload [ BLUEDROID_H4_SIZE + 2 ] + 1 <= used_buffer_length ) || ( payload [ BLUEDROID_H4_PACKET_TYPE ] == BLUEDROID_H4_PACKET_TYPE_HCI_EVT && used_buffer_length >= BLUEDROID_TIMESTAMP_SIZE + BLUEDROID_H4_SIZE + 1 + 1 && BLUEDROID_TIMESTAMP_SIZE + BLUEDROID_H4_SIZE + 1 + payload [ BLUEDROID_H4_SIZE + 1 ] + 1 <= used_buffer_length ) ) {\n<160> closesocket ( sock ) ;\n<170> endless_loop = extcap_dumper_dump ( extcap_dumper , packet , captured_length , captured_length , ( uint32_t ) ( ts / 1000000 ) , ( ( uint32_t ) ( ts % 1000000 ) ) * 1000 ) ;\n<171> used_buffer_length -= length - sizeof ( own_pcap_bluetooth_h4_header ) + BLUEDROID_TIMESTAMP_SIZE ;\n<172> if ( used_buffer_length < 0 ) {\n<174> closesocket ( sock ) ;\n<177> memmove ( buffer , packet + length , used_buffer_length ) ;\n<180> closesocket ( sock ) ;
<1> static int make_boot_catalog ( struct archive_write * a ) {\n<6> block = wb_buffptr ( a ) ;\n<7> memset ( block , 0 , LOGICAL_BLOCK_SIZE ) ;\n<8> p = block ;\n<9> p [ 0 ] = 1 ;\n<10> p [ 1 ] = iso9660 -> el_torito . platform_id ;\n<11> p [ 2 ] = p [ 3 ] = 0 ;\n<12> if ( archive_strlen ( & ( iso9660 -> el_torito . id ) ) > 0 ) strncpy ( ( char * ) p + 4 , iso9660 -> el_torito . id . s , 23 ) ;\n<18> wp = ( uint16_t * ) block ;\n<19> while ( wp < ( uint16_t * ) & block [ 32 ] ) sum += archive_le16dec ( wp ++ ) ;\n<20> set_num_721 ( & block [ 28 ] , ( ~ sum ) + 1 ) ;\n<21> p = & block [ 32 ] ;\n<24> if ( iso9660 -> el_torito . media_type == BOOT_MEDIA_NO_EMULATION ) set_num_721 ( & p [ 2 ] , iso9660 -> el_torito . boot_load_seg ) ;\n<25> else set_num_721 ( & p [ 2 ] , 0 ) ;\n<28> if ( iso9660 -> el_torito . media_type == BOOT_MEDIA_NO_EMULATION ) set_num_721 ( & p [ 6 ] , iso9660 -> el_torito . boot_load_size ) ;\n<29> else set_num_721 ( & p [ 6 ] , 1 ) ;\n<30> set_num_731 ( & p [ 8 ] , iso9660 -> el_torito . boot -> file -> content . location ) ;\n<31> memset ( & p [ 12 ] , 0 , 20 ) ;\n<32> return ( wb_consume ( a , LOGICAL_BLOCK_SIZE ) ) ;
<1> static void pdf_process_stream ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi , fz_stream * stm ) {\n<8> pdf_clear_stack ( ctx , csi ) ;\n<25> tok = pdf_lex ( ctx , stm , buf ) ;\n<34> case PDF_TOK_STRING : pdf_array_push_drop ( ctx , csi -> obj , pdf_new_string ( ctx , doc , buf -> scratch , buf -> len ) ) ;\n<37> case PDF_TOK_KEYWORD : if ( buf -> scratch [ 0 ] == 'T' && ( buf -> scratch [ 1 ] == 'w' || buf -> scratch [ 1 ] == 'c' ) && buf -> scratch [ 2 ] == 0 ) {\n<44> pdf_process_keyword ( ctx , proc , csi , stm , buf -> scratch ) ;\n<63> csi -> obj = pdf_parse_array ( ctx , doc , stm , buf ) ;\n<70> csi -> obj = pdf_parse_dict ( ctx , doc , stm , buf ) ;\n<75> csi -> obj = pdf_new_name ( ctx , doc , buf -> scratch ) ;\n<77> else fz_strlcpy ( csi -> name , buf -> scratch , sizeof ( csi -> name ) ) ;\n<91> case PDF_TOK_STRING : if ( buf -> len <= sizeof ( csi -> string ) ) {\n<92> memcpy ( csi -> string , buf -> scratch , buf -> len ) ;\n<93> csi -> string_len = buf -> len ;\n<100> csi -> obj = pdf_new_string ( ctx , doc , buf -> scratch , buf -> len ) ;\n<103> case PDF_TOK_KEYWORD : pdf_process_keyword ( ctx , proc , csi , stm , buf -> scratch ) ;\n<104> pdf_clear_stack ( ctx , csi ) ;\n<112> pdf_clear_stack ( ctx , csi ) ;
<1> static int svq3_decode_mb ( SVQ3Context * s , unsigned int mb_type ) {\n<2> H264Context * h = & s -> h ;\n<32> if ( h -> mb_x > 0 && h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - 1 ] + 6 ] != - 1 ) {\n<42> if ( h -> mb_y > 0 ) {\n<43> memcpy ( h -> mv_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , h -> cur_pic . motion_val [ m ] [ b_xy - h -> b_stride ] , 4 * 2 * sizeof ( int16_t ) ) ;\n<44> memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 ] , ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 , 4 ) ;\n<47> h -> ref_cache [ m ] [ scan8 [ 0 ] + 4 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride + 1 ] + 6 ] == - 1 || h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride ] ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n<52> h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 - 1 * 8 ] = ( h -> intra4x4_pred_mode [ h -> mb2br_xy [ mb_xy - h -> mb_stride - 1 ] + 3 ] == - 1 ) ? PART_NOT_AVAILABLE : 1 ;\n<56> else memset ( & h -> ref_cache [ m ] [ scan8 [ 0 ] - 1 * 8 - 1 ] , PART_NOT_AVAILABLE , 8 ) ;\n<68> i < 4 ;\n<69> i ++ ) memset ( h -> cur_pic . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n<76> i < 4 ;\n<77> i ++ ) memset ( h -> cur_pic . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n<82> else if ( mb_type == 8 || mb_type == 33 ) {\n<83> memset ( h -> intra4x4_pred_mode_cache , - 1 , 8 * 5 * sizeof ( int8_t ) ) ;\n<106> left = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 1 ] ;\n<107> top = & h -> intra4x4_pred_mode_cache [ scan8 [ i ] - 8 ] ;\n<118> i < 4 ;\n<119> i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_PRED , 4 ) ;\n<121> write_back_intra_pred_mode ( h ) ;\n<123> ff_h264_check_intra4x4_pred_mode ( h ) ;\n<129> i < 4 ;\n<130> i ++ ) memset ( & h -> intra4x4_pred_mode_cache [ scan8 [ 0 ] + 8 * i ] , DC_128_PRED , 4 ) ;\n<139> if ( ( h -> intra16x16_pred_mode = ff_h264_check_intra_pred_mode ( h , dir , 0 ) ) == - 1 ) {\n<148> i < 4 ;\n<149> i ++ ) memset ( h -> cur_pic . motion_val [ 0 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n<152> i < 4 ;\n<153> i ++ ) memset ( h -> cur_pic . motion_val [ 1 ] [ b_xy + i * h -> b_stride ] , 0 , 4 * 2 * sizeof ( int16_t ) ) ;\n<156> if ( ! IS_INTRA4x4 ( mb_type ) ) {\n<157> memset ( h -> intra4x4_pred_mode + h -> mb2br_xy [ mb_xy ] , DC_PRED , 8 ) ;\n<159> if ( ! IS_SKIP ( mb_type ) || h -> pict_type == AV_PICTURE_TYPE_B ) {\n<160> memset ( h -> non_zero_count_cache + 8 , 0 , 14 * 8 * sizeof ( uint8_t ) ) ;\n<230> if ( IS_INTRA ( mb_type ) ) h -> chroma_pred_mode = ff_h264_check_intra_pred_mode ( h , DC_PRED8x8 , 1 ) ;
<43> static void default_print_section_header ( WriterContext * wctx ) {\n<54> if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "[%s]\n" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;
<1> static DisplaySurface* sdl_create_displaysurface(int width, int height)\n<7> if (surface == NULL) {\n<9> fprintf(stderr, "sdl_create_displaysurface: malloc failed\n");
<1> char * curl_mvaprintf ( const char * format , va_list ap_save ) {\n<4> info . buffer = NULL ;\n<5> info . len = 0 ;\n<6> info . alloc = 0 ;\n<7> info . fail = 0 ;\n<10> if ( info . alloc ) free ( info . buffer ) ;\n<13> if ( info . alloc ) {\n<17> else return strdup ( "" ) ;
<1> static void pcx_palette(const uint8_t **src, uint32_t *dst,\n<13> *dst++ = bytestream_get_be24(src);\n<15> if (pallen < 256)\n<17> memset(dst, 0, (256 - pallen) * sizeof(*dst));
<1> static bool script_support_content ( struct mail_user * user , const char * * content_type , const char * filename ) {\n<10> if ( array_count ( & suser -> content ) == 0 ) {\n<11> if ( script_contents_read ( user ) < 0 ) return FALSE ;\n<13> if ( strcmp ( * content_type , "application/octet-stream" ) == 0 ) {\n<14> if ( filename == NULL ) return FALSE ;\n<26> array_foreach ( & suser -> content , content ) {\n<27> if ( strcmp ( content -> content_type , * content_type ) == 0 ) return TRUE ;\n<30> return FALSE ;
<1> static void processEncodingEntry ( ArchiveHandle * AH , TocEntry * te ) {\n<2> char * defn = pg_strdup ( te -> defn ) ;\n<6> ptr1 = strchr ( defn , '\'' ) ;\n<7> if ( ptr1 ) ptr2 = strchr ( ++ ptr1 , '\'' ) ;\n<10> encoding = pg_char_to_encoding ( ptr1 ) ;\n<15> free ( defn ) ;
<1> static void framebuffer_update_request(VncState *vs, int incremental,\n<33> char *old_row = vs->old_data + y_position * ds_get_linesize(vs->ds);\n<37> for (i = 0; i < h; i++) {\n<43> memset(old_row, 42, ds_get_width(vs->ds) * vs->depth);\n<45> old_row += ds_get_linesize(vs->ds);
<21> if ( at -> charstrings == NULL ) return ( false ) ;\n<24> finishup ( sf , at ) ;\n<31> if ( at -> format != ff_cff ) dumpcffhmtx ( at , sf , false ) ;\n<32> free ( at -> gn_sid ) ;
<1> static int show_object_fast ( const unsigned char * sha1 , enum object_type type , int exclude , uint32_t name_hash , struct packed_git * found_pack , off_t found_offset ) {\n<2> fprintf ( stdout , "%s\n" , sha1_to_hex ( sha1 ) ) ;
<1> void EVP_EncodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n<7> if ( ctx -> length - ctx -> num > inl ) {\n<8> memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , inl ) ;\n<9> ctx -> num += inl ;\n<12> if ( ctx -> num != 0 ) {\n<13> i = ctx -> length - ctx -> num ;\n<14> memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , i ) ;\n<15> in += i ;\n<16> inl -= i ;\n<17> j = EVP_EncodeBlock ( out , ctx -> enc_data , ctx -> length ) ;\n<26> in += ctx -> length ;\n<33> if ( inl != 0 ) memcpy ( & ( ctx -> enc_data [ 0 ] ) , in , inl ) ;\n<34> ctx -> num = inl ;
<1> static void sdp_parse_line(AVFormatContext *s, SDPParseState *s1,\n<39> switch (letter) {\n<43> get_word(buf1, sizeof(buf1), &p);\n<45> if (strcmp(buf1, "IN") != 0)\n<47> return;\n<49> get_word(buf1, sizeof(buf1), &p);\n<51> if (strcmp(buf1, "IP4") && strcmp(buf1, "IP6"))\n<53> return;\n<55> get_word_sep(buf1, sizeof(buf1), "/", &p);\n<57> if (get_sockaddr(buf1, &sdp_ip))\n<121> get_word(st_type, sizeof(st_type), &p);\n<123> if (!strcmp(st_type, "audio")) {\n<125> codec_type = AVMEDIA_TYPE_AUDIO;\n<127> } else if (!strcmp(st_type, "video")) {\n<129> codec_type = AVMEDIA_TYPE_VIDEO;\n<131> } else if (!strcmp(st_type, "application")) {\n<133> codec_type = AVMEDIA_TYPE_DATA;\n<147> if (!rtsp_st)\n<187> get_word(buf1, sizeof(buf1), &p); /* protocol */\n<189> if (!strcmp(buf1, "udp"))\n<191> rt->transport = RTSP_TRANSPORT_RAW;\n<193> else if (strstr(buf1, "/AVPF") || strstr(buf1, "/SAVPF"))\n<195> rtsp_st->feedback = 1;\n<207> if (!strcmp(ff_rtp_enc_name(rtsp_st->sdp_payload_type), "MP2T")) {\n<211> if (rt->transport == RTSP_TRANSPORT_RAW) {\n<233> } else if (rt->server_type == RTSP_SERVER_WMS &&\n<289> av_strlcpy(rtsp_st->control_url, rt->control_uri,\n<291> sizeof(rtsp_st->control_url));\n<313> rtsp_st = rt->rtsp_streams[rt->nb_rtsp_streams - 1];\n<323> if (proto[0] == '\0') {\n<327> if (rtsp_st->control_url[strlen(rtsp_st->control_url)-1]!='/')\n<329> av_strlcat(rtsp_st->control_url, "/",\n<331> sizeof(rtsp_st->control_url));\n<425> } else if (av_strstart(p, "crypto:", &p) && s->nb_streams > 0) {\n<431> get_word(buf1, sizeof(buf1), &p); // ignore tag\n<433> get_word(rtsp_st->crypto_suite, sizeof(rtsp_st->crypto_suite), &p);\n<435> p += strspn(p, SPACE_CHARS);\n<437> if (av_strstart(p, "inline:", &p))\n<441> } else if (av_strstart(p, "source-filter:", &p)) {\n<445> get_word(buf1, sizeof(buf1), &p);\n<447> if (strcmp(buf1, "incl") && strcmp(buf1, "excl"))\n<449> return;\n<451> exclude = !strcmp(buf1, "excl");\n<455> get_word(buf1, sizeof(buf1), &p);\n<457> if (strcmp(buf1, "IN") != 0)\n<459> return;\n<461> get_word(buf1, sizeof(buf1), &p);\n<463> if (strcmp(buf1, "IP4") && strcmp(buf1, "IP6") && strcmp(buf1, "*"))\n<465> return;\n<469> get_word(buf1, sizeof(buf1), &p);\n<473> while (*p != '\0') {
<1> static void restore_cs_variables ( FILE * sql_file , const char * delimiter ) {\n<2> fprintf ( sql_file , "/*!50003 SET character_set_client = @saved_cs_client */ %s\n" "/*!50003 SET character_set_results = @saved_cs_results */ %s\n" "/*!50003 SET collation_connection = @saved_col_connection */ %s\n" , ( const char * ) delimiter , ( const char * ) delimiter , ( const char * ) delimiter ) ;
<1> static void write_dns ( int fd , struct query * q , char * data , int datalen , char downenc ) {\n<4> if ( q -> type == T_CNAME || q -> type == T_A ) {\n<6> write_dns_nameenc ( cnamebuf , sizeof ( cnamebuf ) , data , datalen , downenc ) ;\n<7> len = dns_encode ( buf , sizeof ( buf ) , q , QR_ANSWER , cnamebuf , sizeof ( cnamebuf ) ) ;\n<9> else if ( q -> type == T_MX || q -> type == T_SRV ) {\n<15> res = write_dns_nameenc ( b , sizeof ( mxbuf ) - ( b - mxbuf ) , data + offset , datalen - offset , downenc ) ;\n<16> if ( res < 1 ) {\n<20> b = b + strlen ( b ) + 1 ;\n<22> if ( offset >= datalen ) break ;\n<25> len = dns_encode ( buf , sizeof ( buf ) , q , QR_ANSWER , mxbuf , sizeof ( mxbuf ) ) ;\n<27> else if ( q -> type == T_TXT ) {\n<31> memset ( txtbuf , 0 , sizeof ( txtbuf ) ) ;\n<34> len = b64 -> encode ( txtbuf + 1 , & space , data , datalen ) ;\n<38> len = b64u -> encode ( txtbuf + 1 , & space , data , datalen ) ;\n<42> len = b128 -> encode ( txtbuf + 1 , & space , data , datalen ) ;\n<44> else if ( downenc == 'R' ) {\n<45> txtbuf [ 0 ] = 'r' ;\n<46> len = MIN ( datalen , sizeof ( txtbuf ) - 1 ) ;\n<47> memcpy ( txtbuf + 1 , data , len ) ;\n<51> len = b32 -> encode ( txtbuf + 1 , & space , data , datalen ) ;\n<53> len = dns_encode ( buf , sizeof ( buf ) , q , QR_ANSWER , txtbuf , len + 1 ) ;\n<56> len = dns_encode ( buf , sizeof ( buf ) , q , QR_ANSWER , data , datalen ) ;\n<62> if ( debug >= 2 ) {\n<63> fprintf ( stderr , "TX: client %s, type %d, name %s, %d bytes data\n" , format_addr ( & q -> from , q -> fromlen ) , q -> type , q -> name , datalen ) ;
<1> static int dss_read_metadata_date(AVFormatContext *s, unsigned int offset,\n<21> ret = avio_read(s->pb, string, DSS_TIME_SIZE);\n<23> if (ret < DSS_TIME_SIZE)\n<29> sscanf(string, "%2d%2d%2d%2d%2d%2d", &y, &month, &d, &h, &minute, &sec);\n<35> snprintf(datetime, sizeof(datetime), "%.4d-%.2d-%.2dT%.2d:%.2d:%.2d",\n<37> y + 2000, month, d, h, minute, sec);
<1> static void config_auth ( config_tree * ptree ) {\n<29> if ( keysdir != default_keysdir ) free ( keysdir ) ;
<1> static void bdrv_move_feature_fields(BlockDriverState *bs_dest,\n<3> BlockDriverState *bs_src)
<1> static void test_left_join_view ( ) {\n<4> const char * query = "select t1.a, v1.x from t1 left join v1 on (t1.a= v1.x);\n<17> stmt = mysql_stmt_init ( mysql ) ;\n<18> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<19> check_execute ( stmt , rc ) ;
<1> static int vbf_objiterator ( void * priv , int flush , const void * ptr , ssize_t len ) {\n<4> const uint8_t * ps = ptr ;\n<10> if ( VFP_GetStorage ( bo -> vfc , & l , & pd ) != VFP_OK ) return ( 1 ) ;\n<11> if ( len < l ) l = len ;\n<12> memcpy ( pd , ps , l ) ;\n<13> VFP_Extend ( bo -> vfc , l ) ;\n<14> ps += l ;
<1> static void truespeech_correlate_filter ( TSContext * dec ) {\n<2> int16_t tmp [ 8 ] ;\n<7> if ( i > 0 ) {\n<8> memcpy ( tmp , dec -> cvector , i * sizeof ( * tmp ) ) ;\n<11> j ++ ) dec -> cvector [ j ] = ( ( tmp [ i - j - 1 ] * dec -> vector [ i ] ) + ( dec -> cvector [ j ] << 15 ) + 0x4000 ) >> 15 ;\n<13> dec -> cvector [ i ] = ( 8 - dec -> vector [ i ] ) >> 3 ;
<1> static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) {\n<48> if ( ! img ) {\n<49> img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ;\n<50> if ( ! img ) goto fail ;\n<54> memset ( img , 0 , sizeof ( vpx_image_t ) ) ;\n<63> if ( ! img -> img_data ) goto fail ;\n<73> if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ;\n<74> fail : vpx_img_free ( img ) ;
<1> static abi_ulong copy_elf_strings(int argc,char ** argv, void **page,\n<23> if (!tmp) {\n<25> fprintf(stderr, "VFS: argc is wrong");\n<51> pag = (char *)page[p/TARGET_PAGE_SIZE];\n<53> if (!pag) {\n<55> pag = (char *)malloc(TARGET_PAGE_SIZE);\n<57> memset(pag, 0, TARGET_PAGE_SIZE);\n<59> page[p/TARGET_PAGE_SIZE] = pag;\n<61> if (!pag)
<1> int fill_schema_user_privileges ( THD * thd , TABLE_LIST * tables , COND * cond ) {\n<8> bool no_global_access = check_access ( thd , SELECT_ACL , "mysql" , 0 , 1 , 1 , 0 ) ;\n<14> counter < acl_users . elements ;\n<15> counter ++ ) {\n<18> if ( ! ( user = acl_user -> user ) ) user = "" ;\n<20> if ( no_global_access && ( strcmp ( thd -> security_ctx -> priv_user , user ) || my_strcasecmp ( system_charset_info , curr_host , host ) ) ) continue ;\n<21> want_access = acl_user -> access ;\n<22> if ( ! ( want_access & GRANT_ACL ) ) is_grantable = "NO" ;\n<23> strxmov ( buff , "'" , user , "'@'" , host , "'" , NullS ) ;\n<24> if ( ! ( want_access & ~ GRANT_ACL ) ) {
<1> static int jpc_enc_encodemainhdr ( jpc_enc_t * enc ) {\n<22> char buf [ 1024 ] ;\n<65> if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_COM ) ) ) {\n<68> sprintf ( buf , "Creator: JasPer Version %s" , jas_getversion ( ) ) ;\n<70> com -> len = JAS_CAST ( uint_fast16_t , strlen ( buf ) ) ;
<1> static int write_information_block ( struct archive_write * a ) {\n<13> archive_string_init ( & info ) ;\n<14> if ( archive_string_ensure ( & info , info_size ) == NULL ) {\n<18> memset ( info . s , 0 , info_size ) ;\n<25> if ( iso9660 -> opt . abstract_file != OPT_ABSTRACT_FILE_DEFAULT ) set_option_info ( & info , & opt , "abstract-file" , KEY_STR , iso9660 -> abstract_file_identifier . s ) ;\n<26> if ( iso9660 -> opt . application_id != OPT_APPLICATION_ID_DEFAULT ) set_option_info ( & info , & opt , "application-id" , KEY_STR , iso9660 -> application_identifier . s ) ;\n<27> if ( iso9660 -> opt . allow_vernum != OPT_ALLOW_VERNUM_DEFAULT ) set_option_info ( & info , & opt , "allow-vernum" , KEY_FLG , iso9660 -> opt . allow_vernum ) ;\n<28> if ( iso9660 -> opt . biblio_file != OPT_BIBLIO_FILE_DEFAULT ) set_option_info ( & info , & opt , "biblio-file" , KEY_STR , iso9660 -> bibliographic_file_identifier . s ) ;\n<29> if ( iso9660 -> opt . boot != OPT_BOOT_DEFAULT ) set_option_info ( & info , & opt , "boot" , KEY_STR , iso9660 -> el_torito . boot_filename . s ) ;\n<30> if ( iso9660 -> opt . boot_catalog != OPT_BOOT_CATALOG_DEFAULT ) set_option_info ( & info , & opt , "boot-catalog" , KEY_STR , iso9660 -> el_torito . catalog_filename . s ) ;\n<31> if ( iso9660 -> opt . boot_info_table != OPT_BOOT_INFO_TABLE_DEFAULT ) set_option_info ( & info , & opt , "boot-info-table" , KEY_FLG , iso9660 -> opt . boot_info_table ) ;\n<32> if ( iso9660 -> opt . boot_load_seg != OPT_BOOT_LOAD_SEG_DEFAULT ) set_option_info ( & info , & opt , "boot-load-seg" , KEY_HEX , iso9660 -> el_torito . boot_load_seg ) ;\n<33> if ( iso9660 -> opt . boot_load_size != OPT_BOOT_LOAD_SIZE_DEFAULT ) set_option_info ( & info , & opt , "boot-load-size" , KEY_INT , iso9660 -> el_torito . boot_load_size ) ;\n<38> set_option_info ( & info , & opt , "boot-type" , KEY_STR , v ) ;\n<42> if ( iso9660 -> opt . iso_level != OPT_ISO_LEVEL_DEFAULT ) set_option_info ( & info , & opt , "iso-level" , KEY_INT , iso9660 -> opt . iso_level ) ;\n<44> if ( iso9660 -> opt . joliet == OPT_JOLIET_LONGNAME ) set_option_info ( & info , & opt , "joliet" , KEY_STR , "long" ) ;\n<45> else set_option_info ( & info , & opt , "joliet" , KEY_FLG , iso9660 -> opt . joliet ) ;\n<47> if ( iso9660 -> opt . limit_depth != OPT_LIMIT_DEPTH_DEFAULT ) set_option_info ( & info , & opt , "limit-depth" , KEY_FLG , iso9660 -> opt . limit_depth ) ;\n<48> if ( iso9660 -> opt . limit_dirs != OPT_LIMIT_DIRS_DEFAULT ) set_option_info ( & info , & opt , "limit-dirs" , KEY_FLG , iso9660 -> opt . limit_dirs ) ;\n<49> if ( iso9660 -> opt . pad != OPT_PAD_DEFAULT ) set_option_info ( & info , & opt , "pad" , KEY_FLG , iso9660 -> opt . pad ) ;\n<50> if ( iso9660 -> opt . publisher != OPT_PUBLISHER_DEFAULT ) set_option_info ( & info , & opt , "publisher" , KEY_STR , iso9660 -> publisher_identifier . s ) ;\n<52> if ( iso9660 -> opt . rr == OPT_RR_DISABLED ) set_option_info ( & info , & opt , "rockridge" , KEY_FLG , iso9660 -> opt . rr ) ;\n<53> else if ( iso9660 -> opt . rr == OPT_RR_STRICT ) set_option_info ( & info , & opt , "rockridge" , KEY_STR , "strict" ) ;\n<54> else if ( iso9660 -> opt . rr == OPT_RR_USEFUL ) set_option_info ( & info , & opt , "rockridge" , KEY_STR , "useful" ) ;\n<56> if ( iso9660 -> opt . volume_id != OPT_VOLUME_ID_DEFAULT ) set_option_info ( & info , & opt , "volume-id" , KEY_STR , iso9660 -> volume_identifier . s ) ;\n<57> if ( iso9660 -> opt . zisofs != OPT_ZISOFS_DEFAULT ) set_option_info ( & info , & opt , "zisofs" , KEY_FLG , iso9660 -> opt . zisofs ) ;\n<58> memcpy ( wb_buffptr ( a ) , info . s , info_size ) ;\n<59> archive_string_free ( & info ) ;\n<60> return ( wb_consume ( a , info_size ) ) ;
<1> void usb_test_hotplug(const char *hcd_id, const int port,\n<62> g_assert(!strcmp(qdict_get_str(response, "event"), "DEVICE_DELETED"));
<1> static void vc1_decode_i_blocks_adv(VC1Context *v)\n<83> if (s->start_mb_y) {\n<89> memset(&s->coded_block[s->block_index[0]-s->b8_stride], 0,\n<91> s->b8_stride * sizeof(*s->coded_block));
<1> int encode_function ( char * string , struct filter_op * fop ) {\n<2> char * str = strdup ( string ) ;\n<8> memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n<9> name = ec_strtok ( string , "(" , & tok ) ;\n<10> args = name + strlen ( name ) + 1 ;\n<11> dec_args = decode_args ( args , & nargs ) ;
<1> void format_errmsg ( char * nfmt , size_t lennfmt , const char * fmt , int errval ) {\n<7> n = nfmt ;\n<9> while ( ( c = * f ++ ) != '\0' && n < ( nfmt + lennfmt - 1 ) ) {\n<11> * n ++ = c ;\n<14> if ( ( c = * f ++ ) != 'm' ) {\n<17> * n ++ = c ;\n<20> errno_to_str ( errval , errmsg , sizeof ( errmsg ) ) ;\n<21> len = strlen ( errmsg ) ;\n<22> if ( ( n + len ) < ( nfmt + lennfmt - 1 ) ) {\n<23> memcpy ( n , errmsg , len ) ;\n<24> n += len ;
<1> static int extend_path_list_container ( gs_main_instance * minst , gs_file_path * pfp ) {\n<3> ref * paths , * opaths = minst -> lib_path . container . value . refs ;\n<8> make_array ( & minst -> lib_path . container , avm_foreign , len + LIB_PATH_EXTEND , paths ) ;\n<10> memcpy ( paths , opaths , len * sizeof ( ref ) ) ;\n<12> gs_free_object ( minst -> heap , opaths , "extend_path_list_container" ) ;
<3> if ( ! is_valid_alias ( alias ) ) {\n<9> if ( * alias -> ct <= 0 ) {\n<12> free ( alias -> ct ) ;
<1> static int old_codec47(SANMVideoContext *ctx, int top,\n<7> uint8_t *prev1 = (uint8_t*)ctx->frm1;\n<8> uint8_t *prev2 = (uint8_t*)ctx->frm2;\n<22> memset(prev1, 0, ctx->height * stride);\n<23> memset(prev2, 0, ctx->height * stride);
<1> static void gtkui_connection_inject_file ( void ) {\n<38> if ( response == GTK_RESPONSE_OK ) {\n<40> filename = gtk_entry_get_text ( GTK_ENTRY ( entry ) ) ;\n<41> if ( filename && strlen ( filename ) > 0 ) {\n<42> if ( gtk_toggle_button_get_active ( GTK_TOGGLE_BUTTON ( button1 ) ) ) gtkui_inject_file ( filename , 1 ) ;\n<43> else if ( gtk_toggle_button_get_active ( GTK_TOGGLE_BUTTON ( button2 ) ) ) gtkui_inject_file ( filename , 2 ) ;
<1> static int svq3_decode_mb(SVQ3Context *svq3, unsigned int mb_type)\n<5> H264Context *h = &svq3->h;\n<57> if (svq3_mc_dir(h, mb_type, PREDICT_MODE, 1, 1) < 0)\n<105> if (s->mb_x > 0 && h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - 1]+6] != -1) {\n<123> if (s->mb_y > 0) {\n<125> memcpy(h->mv_cache[m][scan8[0] - 1*8], s->current_picture.f.motion_val[m][b_xy - h->b_stride], 4*2*sizeof(int16_t));\n<127> memset(&h->ref_cache[m][scan8[0] - 1*8], (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - s->mb_stride]] == -1) ? PART_NOT_AVAILABLE : 1, 4);\n<137> (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - s->mb_stride + 1]+6] == -1 ||\n<139> h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - s->mb_stride    ]  ] == -1) ? PART_NOT_AVAILABLE : 1;\n<149> h->ref_cache[m][scan8[0] - 1 - 1*8] = (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - s->mb_stride - 1]+3] == -1) ? PART_NOT_AVAILABLE : 1;\n<157> memset(&h->ref_cache[m][scan8[0] - 1*8 - 1], PART_NOT_AVAILABLE, 8);\n<173> if (svq3_mc_dir(h, (mb_type - 1), mode, 0, 0) < 0)\n<181> if (svq3_mc_dir(h, 0, mode, 0, 0) < 0)\n<187> for (i = 0; i < 4; i++) {\n<189> memset(s->current_picture.f.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<197> if (svq3_mc_dir(h, 0, mode, 1, (mb_type == 3)) < 0)\n<203> for (i = 0; i < 4; i++) {\n<205> memset(s->current_picture.f.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<217> } else if (mb_type == 8 || mb_type == 33) {   /* INTRA4x4 */\n<219> memset(h->intra4x4_pred_mode_cache, -1, 8*5*sizeof(int8_t));\n<281> left    = &h->intra4x4_pred_mode_cache[scan8[i] - 1];\n<283> top     = &h->intra4x4_pred_mode_cache[scan8[i] - 8];\n<305> for (i = 0; i < 4; i++) {\n<307> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8*i], DC_PRED, 4);\n<315> write_back_intra_pred_mode(h);\n<321> ff_h264_check_intra4x4_pred_mode(h);\n<331> for (i = 0; i < 4; i++) {\n<333> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8*i], DC_128_PRED, 4);\n<357> if ((h->intra16x16_pred_mode = ff_h264_check_intra_pred_mode(h, dir)) == -1){\n<377> for (i = 0; i < 4; i++) {\n<379> memset(s->current_picture.f.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<385> for (i = 0; i < 4; i++) {\n<387> memset(s->current_picture.f.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));\n<395> if (!IS_INTRA4x4(mb_type)) {\n<397> memset(h->intra4x4_pred_mode+h->mb2br_xy[mb_xy], DC_PRED, 8);\n<401> if (!IS_SKIP(mb_type) || s->pict_type == AV_PICTURE_TYPE_B) {\n<403> memset(h->non_zero_count_cache + 8, 0, 14*8*sizeof(uint8_t));\n<555> h->chroma_pred_mode = ff_h264_check_intra_pred_mode(h, DC_PRED8x8);
<1> void irc_ctcp_reply_to_nick ( struct t_irc_server * server , const char * command , struct t_irc_channel * channel , const char * nick , const char * ctcp , const char * arguments ) {\n<16> if ( ! str_args_color ) break ;\n<17> weechat_printf_date_tags ( irc_msgbuffer_get_target_buffer ( server , nick , NULL , "ctcp" , ( channel ) ? channel -> buffer : NULL ) , 0 , irc_protocol_tags ( command , "irc_ctcp,irc_ctcp_reply,self_msg,notify_none," "no_highlight" , NULL , NULL ) , _ ( "%sCTCP reply to %s%s%s: %s%s%s%s%s" ) , weechat_prefix ( "network" ) , irc_nick_color_for_msg ( server , 0 , NULL , nick ) , nick , IRC_COLOR_RESET , IRC_COLOR_CHAT_CHANNEL , ctcp , ( str_args_color [ 0 ] ) ? IRC_COLOR_RESET : "" , ( str_args_color [ 0 ] ) ? " " : "" , str_args_color ) ;\n<18> free ( str_args_color ) ;
<1> static int htab_load(QEMUFile *f, void *opaque, int version_id)\n<59> if (fd < 0) {\n<61> error_report("Unable to open fd to restore KVM hash table: %s",\n<63> strerror(errno));\n<125> if (n_invalid) {\n<127> memset(HPTE(spapr->htab, index + n_valid), 0,\n<129> HASH_PTE_SIZE_64 * n_invalid);
<1> static int commit_one_file(BDRVVVFATState* s,\n<13> mapping_t* mapping = find_mapping_for_cluster(s, c);\n<37> fd = open(mapping->path, O_RDWR | O_CREAT | O_BINARY, 0666);\n<39> if (fd < 0) {\n<41> fprintf(stderr, "Could not open %s... (%s, %d)\n", mapping->path,\n<43> strerror(errno), errno);
<1> static char * tstflags ( u_long val ) {\n<10> snprintf ( cp , cb , "%02lx" , val ) ;\n<11> cp += strlen ( cp ) ;\n<12> cb -= strlen ( cp ) ;\n<13> if ( ! val ) {\n<14> strlcat ( cp , " ok" , cb ) ;\n<15> cp += strlen ( cp ) ;\n<16> cb -= strlen ( cp ) ;\n<20> * cp ++ = ' ' ;\n<21> cb -- ;\n<26> if ( val & 0x1 ) {\n<27> snprintf ( cp , cb , "%s%s" , sep , tstflagnames [ i ] ) ;\n<29> cp += strlen ( cp ) ;\n<30> cb -= strlen ( cp ) ;
<1> static int ebml_parse_elem(MatroskaDemuxContext *matroska,\n<3> EbmlSyntax *syntax, void *data)\n<39> if (syntax->list_elem_size) {\n<45> data = (char*)list->elem + list->nb_elem*syntax->list_elem_size;\n<47> memset(data, 0, syntax->list_elem_size);\n<81> case EBML_UINT:  res = ebml_read_uint  (pb, length, data);  break;\n<83> case EBML_FLOAT: res = ebml_read_float (pb, length, data);  break;\n<87> case EBML_UTF8:  res = ebml_read_ascii (pb, length, data);  break;\n<89> case EBML_BIN:   res = ebml_read_binary(pb, length, data);  break;\n<99> return ebml_parse_nest(matroska, syntax->def.n, data);\n<101> case EBML_PASS:  return ebml_parse_id(matroska, syntax->def.n, id, data);
<1> static void set_frozenxids ( bool minmxid_only ) {\n<18> dbnum < ntups ;\n<21> char * datallowconn = PQgetvalue ( dbres , dbnum , i_datallowconn ) ;\n<22> if ( strcmp ( datallowconn , "f" ) == 0 ) PQclear ( executeQueryOrDie ( conn_template1 , "ALTER DATABASE %s ALLOW_CONNECTIONS = true" , quote_identifier ( datname ) ) ) ;\n<27> if ( strcmp ( datallowconn , "f" ) == 0 ) PQclear ( executeQueryOrDie ( conn_template1 , "ALTER DATABASE %s ALLOW_CONNECTIONS = false" , quote_identifier ( datname ) ) ) ;
<1> static void generate_noise ( G723_1_Context * p ) {\n<47> vector_ptr = p -> audio + LPC_ORDER ;\n<48> memcpy ( vector_ptr , p -> prev_excitation , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<50> i < SUBFRAMES ;\n<52> gen_acb_excitation ( vector_ptr , vector_ptr , p -> pitch_lag [ i >> 1 ] , & p -> subframe [ i ] , p -> cur_rate ) ;\n<57> j ++ ) t |= FFABS ( vector_ptr [ j ] ) ;\n<71> t = vector_ptr [ j ] << - shift ;\n<80> t = vector_ptr [ j ] >> shift ;\n<112> vector_ptr [ pos [ idx ] ] = av_clip_int16 ( vector_ptr [ pos [ idx ] ] + ( x * signs [ idx ] >> 15 ) ) ;\n<114> memcpy ( vector_ptr + PITCH_MAX , vector_ptr , sizeof ( * vector_ptr ) * SUBFRAME_LEN * 2 ) ;\n<115> vector_ptr += SUBFRAME_LEN * 2 ;\n<117> memcpy ( p -> prev_excitation , p -> audio + LPC_ORDER + FRAME_LEN , PITCH_MAX * sizeof ( * p -> excitation ) ) ;
<1> static TRBCCode xhci_get_port_bandwidth ( XHCIState * xhci , uint64_t pctx ) {\n<3> uint8_t bw_ctx [ xhci -> numports + 1 ] ;\n<8> memset ( & bw_ctx [ 1 ] , 80 , xhci -> numports ) ;\n<9> pci_dma_write ( PCI_DEVICE ( xhci ) , ctx , bw_ctx , sizeof ( bw_ctx ) ) ;
<1> static int lag_decode_line ( LagarithContext * l , lag_rac * rac , uint8_t * dst , int width , int stride , int esc_count ) {\n<5> handle_zeros : if ( l -> zeros_rem ) {\n<6> int count = FFMIN ( l -> zeros_rem , width - i ) ;\n<7> memset ( dst + i , 0 , count ) ;\n<8> i += count ;\n<9> l -> zeros_rem -= count ;\n<12> dst [ i ] = lag_get_rac ( rac ) ;
<1> envlist_to_environ(const envlist_t *envlist, size_t *count)\n<11> penv = env = malloc((envlist->el_count + 1) * sizeof (char *));\n<13> if (env == NULL)\n<19> for (entry = envlist->el_entries.lh_first; entry != NULL;\n<23> *(penv++) = strdup(entry->ev_var);
<13> if ( ! ( rep_str = ( ( REPLACE_STRING * ) rep_pos ) ) -> replace_string ) {\n<18> DBUG_PRINT ( "info" , ( "found: %d, to_offset: %u, from_offset: %d, string: %s" , rep_str -> found , rep_str -> to_offset , rep_str -> from_offset , rep_str -> replace_string ) ) ;\n<20> dynstr_append_mem ( ds , rep_str -> replace_string , strlen ( rep_str -> replace_string ) ) ;
<1> void _TIFFmemcpy ( void * d , const void * s , tmsize_t c ) {\n<2> memcpy ( d , s , ( size_t ) c ) ;
<1> static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n<3> const uint8_t *buf, int buf_size,\n<9> static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n<11> static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n<13> static const uint8_t header_prefixhr1[] = { 0x00, 0x00, 0x02, 0x80, 0x03 };\n<15> static const uint8_t header_prefixhr2[] = { 0x00, 0x00, 0x03, 0x8C, 0x03 };\n<25> if (buf_size < 0x280) {\n<37> if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5) &&\n<39> memcmp(buf, header_prefixhr1, 5) && memcmp(buf, header_prefixhr2, 5)) {\n<41> av_log(ctx->avctx, AV_LOG_ERROR,\n<45> buf[0], buf[1], buf[2], buf[3], buf[4]);\n<47> return AVERROR_INVALIDDATA;\n<51> if (buf[5] & 2) { /* interlaced */\n<53> ctx->cur_field = buf[5] & 1;\n<61> "interlaced %d, cur field %d\n", buf[5] & 3, ctx->cur_field);\n<69> ctx->mbaff = (buf[0x6] >> 5) & 1;\n<73> ctx->height = AV_RB16(buf + 0x18);\n<75> ctx->width  = AV_RB16(buf + 0x1a);\n<79> switch(buf[0x21] >> 5) {\n<91> "Unknown bitdepth indicator (%d)\n", buf[0x21] >> 5);\n<99> cid = AV_RB32(buf + 0x28);\n<113> ctx->act = buf[0x2C] & 7;\n<123> ctx->is_444 = (buf[0x2C] >> 6) & 1;\n<209> if (buf_size < ctx->cid_table->coding_unit_size) {\n<223> ctx->mb_height = buf[0x16d];\n<243> if (!memcmp(buf, header_prefixhr2, 5)) {\n<245> ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n<249> if (ctx->mb_height > 68 ||\n<267> if (buf_size < ctx->data_offset) {\n<297> ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));
<1> static int wavpack_decode_block(AVCodecContext *avctx, int block_no,\n<15> void *samples_l = NULL, *samples_r = NULL;\n<43> if (!s) {\n<55> memset(s->decorr, 0, MAX_TERMS * sizeof(Decorr));\n<57> memset(s->ch, 0, sizeof(s->ch));\n<785> samples_r = frame->extended_data[wc->ch_offset + 1];\n<795> ret = wv_unpack_stereo(s, &s->gb, samples_l, samples_r, avctx->sample_fmt);\n<803> ret = wv_unpack_mono(s, &s->gb, samples_l, avctx->sample_fmt);\n<811> if (s->stereo)\n<813> memcpy(samples_r, samples_l, bpp * s->samples);
<1> int main ( int argc , char * * argv ) {\n<18> repo = xcalloc ( 1 , sizeof ( * repo ) ) ;\n<23> char * arg = * argv ;\n<24> if ( * arg == '-' ) {\n<25> if ( ! strcmp ( arg , "--all" ) ) {\n<29> if ( ! strcmp ( arg , "--force" ) ) {\n<33> if ( ! strcmp ( arg , "--dry-run" ) ) {\n<37> if ( ! strcmp ( arg , "--helper-status" ) ) {\n<41> if ( ! strcmp ( arg , "--verbose" ) ) {\n<46> if ( ! strcmp ( arg , "-d" ) ) {\n<50> if ( ! strcmp ( arg , "-D" ) ) {\n<55> if ( ! strcmp ( arg , "-h" ) ) usage ( http_push_usage ) ;\n<57> if ( ! repo -> url ) {\n<58> char * path = strstr ( arg , "//" ) ;\n<59> str_end_url_with_slash ( arg , & repo -> url ) ;\n<60> repo -> path_len = strlen ( repo -> url ) ;\n<62> repo -> path = strchr ( path + 2 , '/' ) ;\n<63> if ( repo -> path ) repo -> path_len = strlen ( repo -> path ) ;\n<75> memset ( remote_dir_exists , - 1 , 256 ) ;\n<76> http_init ( NULL , repo -> url , 1 ) ;
<1> static gboolean make_file_name_valid_for_dest_fs ( char * filename , const char * dest_fs_type ) {\n<2> if ( dest_fs_type != NULL && filename != NULL ) {\n<3> if ( ! strcmp ( dest_fs_type , "fat" ) || ! strcmp ( dest_fs_type , "vfat" ) || ! strcmp ( dest_fs_type , "msdos" ) || ! strcmp ( dest_fs_type , "msdosfs" ) ) {\n<6> ret = fat_str_replace ( filename , '_' ) ;\n<7> old_len = strlen ( filename ) ;\n<8> for ( i = 0 ;\n<9> i < old_len ;\n<11> if ( filename [ i ] != ' ' ) {\n<12> g_strchomp ( filename ) ;\n<13> ret |= ( old_len != strlen ( filename ) ) ;\n<17> return ret ;\n<20> return FALSE ;
<1> static void imlt_gain ( COOKContext * q , float * inbuffer , cook_gains * gains_ptr , float * previous_buffer ) {\n<2> float * buffer0 = q -> mono_mdct_output ;\n<6> q -> imlt_window ( q , buffer1 , gains_ptr , previous_buffer ) ;\n<10> memcpy ( previous_buffer , buffer0 , q -> samples_per_channel * sizeof ( * previous_buffer ) ) ;
<1> static void cookedprint ( int datatype , int length , const char * data , int status , int quiet , FILE * fp ) {\n<16> if ( ! quiet ) fprintf ( fp , "status=%04x %s,\n" , status , statustoa ( datatype , status ) ) ;\n<18> while ( nextvar ( & length , & data , & name , & value ) ) {\n<19> fmt = varfmt ( name ) ;\n<21> switch ( fmt ) {\n<24> case TS : if ( ! decodets ( value , & lfp ) ) output_raw = '?' ;\n<25> else output ( fp , name , prettydate ( & lfp ) ) ;\n<27> case HA : case NA : if ( ! decodenetnum ( value , & hval ) ) {\n<31> output ( fp , name , nntohost ( & hval ) ) ;\n<34> output ( fp , name , stoa ( & hval ) ) ;\n<37> case RF : if ( decodenetnum ( value , & hval ) ) {\n<38> if ( ISREFCLOCKADR ( & hval ) ) output ( fp , name , refnumtoa ( & hval ) ) ;\n<39> else output ( fp , name , stoa ( & hval ) ) ;\n<41> else if ( strlen ( value ) <= 4 ) {\n<42> output ( fp , name , value ) ;\n<45> output_raw = '?' ;\n<48> case LP : if ( ! decodeuint ( value , & uval ) || uval > 3 ) {\n<55> output ( fp , name , b ) ;\n<58> case OC : if ( ! decodeuint ( value , & uval ) ) {\n<63> output ( fp , name , b ) ;\n<66> case AR : if ( ! decodearr ( value , & narr , lfparr ) ) output_raw = '?' ;\n<67> else outputarr ( fp , name , narr , lfparr ) ;\n<69> case FX : if ( ! decodeuint ( value , & uval ) ) output_raw = '?' ;\n<70> else output ( fp , name , tstflags ( uval ) ) ;\n<72> default : fprintf ( stderr , "Internal error in cookedprint, %s=%s, fmt %d\n" , name , value , fmt ) ;\n<77> atoascii ( name , MAXVARLEN , bn , sizeof ( bn ) ) ;\n<78> if ( output_raw != '*' ) {\n<79> atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) - 1 ) ;\n<80> len = strlen ( bv ) ;\n<81> bv [ len ] = output_raw ;\n<82> bv [ len + 1 ] = '\0' ;\n<85> atoascii ( value , MAXVALLEN , bv , sizeof ( bv ) ) ;\n<87> output ( fp , bn , bv ) ;\n<90> endoutput ( fp ) ;
<1> static int aio_write_f(BlockBackend *blk, int argc, char **argv)\n<70> if (ctx->zflag && optind != argc - 2) {\n<72> printf("-z supports only a single length parameter\n");\n<81> if (ctx->zflag && ctx->Pflag) {\n<83> printf("-z and -P cannot be specified at the same time\n");
<1> static void simple_string(void)\n<27> for (i = 0; test_cases[i].encoded; i++) {\n<35> obj = qobject_from_json(test_cases[i].encoded, NULL);\n<41> g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n<47> g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
<1> static int open_url(HLSContext *c, URLContext **uc, const char *url, AVDictionary *opts)\n<9> const char *proto_name = avio_find_protocol_name(url);\n<13> if (!av_strstart(proto_name, "http", NULL) && !av_strstart(proto_name, "file", NULL))\n<17> if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n<21> else if (strcmp(proto_name, "file") || !strcmp(url, "file,"))\n<23> return AVERROR_INVALIDDATA;\n<27> av_dict_copy(&tmp, c->avio_opts, 0);\n<29> av_dict_copy(&tmp, opts, 0);\n<33> ret = ffurl_open(uc, url, AVIO_FLAG_READ, c->interrupt_callback, &tmp);\n<35> if( ret >= 0) {\n<49> av_dict_free(&tmp);\n<53> return ret;
<1> int ff_rm_read_mdpr_codecdata ( AVFormatContext * s , AVIOContext * pb , AVStream * st , RMStream * rst , unsigned int codec_data_size , const uint8_t * mime ) {\n<14> else if ( v == MKBETAG ( 'L' , 'S' , 'D' , ':' ) ) {\n<21> else if ( mime && ! strcmp ( mime , "logical-fileinfo" ) ) {\n<23> ff_free_stream ( s , st ) ;\n<24> if ( avio_rb16 ( pb ) != 0 ) {\n<53> if ( avio_rl32 ( pb ) != MKTAG ( 'V' , 'I' , 'D' , 'O' ) ) {
<1> void verbose_msg ( const char * fmt , ... ) {\n<8> fprintf ( stderr , "mysqltest: " ) ;\n<9> if ( cur_file && cur_file != file_stack ) fprintf ( stderr , "In included file \"%s\": " , cur_file -> file_name ) ;\n<10> if ( start_lineno != 0 ) fprintf ( stderr , "At line %u: " , start_lineno ) ;\n<11> vfprintf ( stderr , fmt , args ) ;\n<12> fprintf ( stderr , "\n" ) ;\n<14> fflush ( stderr ) ;
<1> static void test_rfc822_parse_quoted_string ( void ) {\n<30> i < N_ELEMENTS ( tests ) ;\n<32> rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;\n<34> test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;
<1> static void json_message_process_token(JSONLexer *lexer, GString *input,\n<47> token = g_malloc(sizeof(JSONToken) + input->len + 1);\n<51> memcpy(token->str, input->str, input->len);\n<61> parser->token_size += input->len;\n<65> g_queue_push_tail(parser->tokens, token);
<1> static void test_logs ( ) {\n<14> stmt = mysql_simple_prepare ( mysql , data ) ;\n<16> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<23> id = 9876 ;\n<25> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<40> length = ( ulong ) ( strmov ( ( char * ) data , "my\"sql\"" ) - data ) ;\n<53> stmt = mysql_simple_prepare ( mysql , data ) ;\n<64> if ( ! opt_silent ) {\n<65> fprintf ( stdout , "id : %d\n" , id ) ;\n<66> fprintf ( stdout , "name : %s(%ld)\n" , data , length ) ;\n<68> DIE_UNLESS ( id == 9876 ) ;\n<69> DIE_UNLESS ( length == 19 || length == 20 ) ;\n<70> DIE_UNLESS ( is_prefix ( data , "MySQL - Open Source" ) == 1 ) ;\n<73> if ( ! opt_silent ) fprintf ( stdout , "\n name : %s(%ld)" , data , length ) ;\n<74> DIE_UNLESS ( length == 1 ) ;\n<75> DIE_UNLESS ( strcmp ( data , "'" ) == 0 ) ;\n<78> if ( ! opt_silent ) fprintf ( stdout , "\n name : %s(%ld)" , data , length ) ;\n<79> DIE_UNLESS ( length == 1 ) ;\n<80> DIE_UNLESS ( strcmp ( data , "\"" ) == 0 ) ;\n<83> if ( ! opt_silent ) fprintf ( stdout , "\n name : %s(%ld)" , data , length ) ;\n<84> DIE_UNLESS ( length == 7 ) ;\n<85> DIE_UNLESS ( strcmp ( data , "my\'sql\'" ) == 0 ) ;\n<88> if ( ! opt_silent ) fprintf ( stdout , "\n name : %s(%ld)" , data , length ) ;\n<89> DIE_UNLESS ( length == 7 ) ;
<1> static void parse_previous_duplicate_name ( const char * name , char * * name_base , const char * * suffix , int * count ) {\n<3> g_assert ( name [ 0 ] != '\0' ) ;\n<4> * suffix = eel_filename_get_extension_offset ( name ) ;\n<8> tag = strstr ( name , COPY_DUPLICATE_TAG ) ;\n<9> if ( tag != NULL ) {\n<13> * name_base = extract_string_until ( name , tag ) ;\n<17> tag = strstr ( name , ANOTHER_COPY_DUPLICATE_TAG ) ;\n<18> if ( tag != NULL ) {\n<22> * name_base = extract_string_until ( name , tag ) ;\n<26> tag = strstr ( name , X11TH_COPY_DUPLICATE_TAG ) ;\n<27> if ( tag == NULL ) {\n<28> tag = strstr ( name , X12TH_COPY_DUPLICATE_TAG ) ;\n<30> if ( tag == NULL ) {\n<31> tag = strstr ( name , X13TH_COPY_DUPLICATE_TAG ) ;\n<33> if ( tag == NULL ) {\n<34> tag = strstr ( name , ST_COPY_DUPLICATE_TAG ) ;\n<36> if ( tag == NULL ) {\n<37> tag = strstr ( name , ND_COPY_DUPLICATE_TAG ) ;\n<39> if ( tag == NULL ) {\n<40> tag = strstr ( name , RD_COPY_DUPLICATE_TAG ) ;\n<42> if ( tag == NULL ) {\n<43> tag = strstr ( name , TH_COPY_DUPLICATE_TAG ) ;\n<45> if ( tag != NULL ) {\n<46> tag = strstr ( name , _ ( " (" ) ) ;\n<47> if ( tag != NULL ) {\n<51> * name_base = extract_string_until ( name , tag ) ;\n<52> if ( sscanf ( tag , _ ( " (%'d" ) , count ) == 1 ) {\n<53> if ( * count < 1 || * count > 1000000 ) {\n<56> return ;\n<58> * count = 0 ;\n<59> return ;\n<64> * name_base = extract_string_until ( name , * suffix ) ;\n<67> * name_base = g_strdup ( name ) ;
<1> static int check_refcounts_l2(BlockDriverState *bs,\n<27> if (bdrv_pread(bs->file, l2_offset, l2_table, l2_size) != l2_size)\n<149> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<7> res = r -> parse_slice_header ( r , gb , & r -> si ) ;\n<13> if ( slice_type != s -> pict_type ) {\n<27> memset ( r -> intra_types_hist , - 1 , r -> intra_types_stride * 4 * 2 * sizeof ( * r -> intra_types_hist ) ) ;\n<32> while ( ! check_slice_end ( r , s ) ) {\n<34> if ( r -> si . type ) res = rv34_decode_inter_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n<35> else res = rv34_decode_intra_macroblock ( r , r -> intra_types + s -> mb_x * 4 + 4 ) ;\n<40> if ( ++ s -> mb_x == s -> mb_width ) {\n<44> memmove ( r -> intra_types_hist , r -> intra_types , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n<45> memset ( r -> intra_types , - 1 , r -> intra_types_stride * 4 * sizeof ( * r -> intra_types_hist ) ) ;\n<46> if ( r -> loop_filter && s -> mb_y >= 2 ) r -> loop_filter ( r , s -> mb_y - 2 ) ;
<1> static void rpc_test ( void ) {\n<9> fprintf ( stdout , "Testing RPC: " ) ;\n<13> if ( EVTAG_GET ( msg , attack , & attack ) == - 1 ) {\n<14> fprintf ( stderr , "Failed to set kill message.\n" ) ;\n<24> if ( run == NULL ) {\n<25> fprintf ( stderr , "Failed to add run message.\n" ) ;\n<31> if ( msg_complete ( msg ) == - 1 ) {\n<32> fprintf ( stderr , "Failed to make complete message.\n" ) ;\n<36> if ( evtag_peek ( tmp , & tag ) == - 1 ) {\n<37> fprintf ( stderr , "Failed to peak tag.\n" ) ;\n<40> if ( tag != 0xdeaf ) {\n<41> fprintf ( stderr , "Got incorrect tag: %0x.\n" , tag ) ;\n<45> if ( evtag_unmarshal_msg ( tmp , 0xdeaf , msg2 ) == - 1 ) {\n<46> fprintf ( stderr , "Failed to unmarshal message.\n" ) ;\n<51> fprintf ( stderr , "(%.1f us/add) " , ( float ) tv_end . tv_sec / ( float ) i * 1000000.0 + tv_end . tv_usec / ( float ) i ) ;\n<52> if ( ! EVTAG_HAS ( msg2 , from_name ) || ! EVTAG_HAS ( msg2 , to_name ) || ! EVTAG_HAS ( msg2 , attack ) ) {\n<53> fprintf ( stderr , "Missing data structures.\n" ) ;\n<56> if ( EVTAG_LEN ( msg2 , run ) != i ) {\n<57> fprintf ( stderr , "Wrong number of run messages.\n" ) ;\n<63> fprintf ( stdout , "OK\n" ) ;
<1> static void create_task_thread_func ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable ) {\n<152> if ( count == 1 ) {\n<156> filename_base = eel_filename_strip_extension ( filename ) ;\n<157> offset = strlen ( filename_base ) ;\n<158> suffix = g_strdup ( filename + offset ) ;\n<159> filename2 = g_strdup_printf ( "%s %d%s" , filename_base , count , suffix ) ;\n<161> if ( max_length > 0 && strlen ( filename2 ) > max_length ) {\n<162> new_filename = shorten_utf8_string ( filename2 , strlen ( filename2 ) - max_length ) ;\n<165> new_filename = g_strdup ( filename2 ) ;\n<167> g_free ( filename2 ) ;\n<184> if ( IS_IO_ERROR ( error , EXISTS ) ) {\n<187> filename_base = eel_filename_strip_extension ( filename ) ;\n<188> offset = strlen ( filename_base ) ;\n<189> suffix = g_strdup ( filename + offset ) ;\n<190> filename2 = g_strdup_printf ( "%s %d%s" , filename_base , ++ count , suffix ) ;\n<191> if ( max_length > 0 && strlen ( filename2 ) > max_length ) {\n<192> new_filename = shorten_utf8_string ( filename2 , strlen ( filename2 ) - max_length ) ;\n<193> if ( new_filename != NULL ) {\n<194> g_free ( filename2 ) ;\n<198> make_file_name_valid_for_dest_fs ( filename2 , dest_fs_type ) ;
<1> static int bmp_decode_frame(AVCodecContext *avctx,\n<167> depth = bytestream_get_le16(&buf);\n<173> comp = bytestream_get_le32(&buf);\n<201> alpha = bytestream_get_le32(&buf);\n<365> buf = buf0 + hsize;\n<377> if(n * avctx->height > dsize && comp != BMP_RLE4 && comp != BMP_RLE8){\n<391> if(comp == BMP_RLE4 || comp == BMP_RLE8)\n<393> memset(p->data[0], 0, avctx->height * p->linesize[0]);\n<399> ptr = p->data[0] + (avctx->height - 1) * p->linesize[0];\n<405> ptr = p->data[0];\n<413> if(avctx->pix_fmt == AV_PIX_FMT_PAL8){\n<419> memset(p->data[1], 0, 1024);\n<429> t = bytestream_get_le32(&buf);\n<449> ((uint32_t*)p->data[1])[i] = (0xff<<24) | bytestream_get_le24(&buf);\n<455> ((uint32_t*)p->data[1])[i] = 0xFFU << 24 | bytestream_get_le32(&buf);\n<459> buf = buf0 + hsize;\n<467> p->data[0] += p->linesize[0] * (avctx->height - 1);\n<479> p->data[0] += p->linesize[0] * (avctx->height - 1);\n<529> for(i = 0; i < avctx->height; i++){\n<531> memcpy(ptr, buf, n);\n<533> buf += n;\n<535> ptr += linesize;
<1> static void test_wl4166_4 ( ) {\n<6> const char * koi8 = "\xee\xd5\x2c\x20\xda\xc1\x20\xd2\xd9\xc2\xc1\xcc\xcb\xd5" ;\n<7> const char * cp1251 = "\xcd\xf3\x2c\x20\xe7\xe0\x20\xf0\xfb\xe1\xe0\xeb\xea\xf3" ;\n<17> memset ( bind_array , 0 , sizeof ( bind_array ) ) ;\n<21> bind_array [ 1 ] . buffer_length = strlen ( koi8 ) ;\n<23> check_stmt ( stmt ) ;\n<24> stmt_text = "insert into t1 (c1, c2) values (?, ?)" ;\n<25> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<26> check_execute ( stmt , rc ) ;\n<27> mysql_stmt_bind_param ( stmt , bind_array ) ;\n<28> mysql_stmt_send_long_data ( stmt , 0 , koi8 , strlen ( koi8 ) ) ;\n<32> check_execute ( stmt , rc ) ;\n<33> stmt_text = "select c1, c2 from t1" ;\n<34> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<35> check_execute ( stmt , rc ) ;\n<47> DIE_UNLESS ( buf1_len == strlen ( cp1251 ) ) ;\n<48> DIE_UNLESS ( buf2_len == strlen ( cp1251 ) ) ;\n<49> DIE_UNLESS ( ! memcmp ( buf1 , cp1251 , buf1_len ) ) ;\n<50> DIE_UNLESS ( ! memcmp ( buf2 , cp1251 , buf1_len ) ) ;
<1> static int init_image(TiffContext *s, ThreadFrame *frame)\n<177> if (s->avctx->pix_fmt == AV_PIX_FMT_PAL8) {\n<179> memcpy(frame->f->data[1], s->palette, sizeof(s->palette));
<8> apr_pool_cleanup_register ( msr -> mp , msr , modsecurity_tx_cleanup , apr_pool_cleanup_null ) ;\n<52> if ( msr -> query_string != NULL ) {\n<54> if ( parse_arguments ( msr , msr -> query_string , strlen ( msr -> query_string ) , msr -> txcfg -> argument_separator , "QUERY_STRING" , msr -> arguments , & invalid_count ) < 0 ) {
<1> static int srt_probe(AVProbeData *p)\n<11> if (AV_RB24(ptr) == 0xEFBBBF)\n<13> ptr += 3;  /* skip UTF-8 BOM */\n<17> while (*ptr == '\r' || *ptr == '\n')\n<19> ptr++;\n<23> if ((num == i || num + 1 == i)\n<25> && sscanf(ptr, "%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d", &v) == 1)\n<29> num = atoi(ptr);\n<31> ptr += strcspn(ptr, "\n") + 1;
<1> void fifo_realloc(FifoBuffer *f, int new_size){\n<23> if(f->wptr < f->rptr){\n<25> memmove(f->rptr + new_size - old_size, f->rptr, f->buffer + old_size - f->rptr);\n<27> f->rptr += new_size - old_size;
<1> static int vmdk_create(const char *filename, QEMUOptionParameter *options,\n<101> while (options && options->name) {\n<103> if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n<105> total_size = options->value.n;\n<107> } else if (!strcmp(options->name, BLOCK_OPT_ADAPTER_TYPE)) {\n<109> adapter_type = options->value.s;\n<111> } else if (!strcmp(options->name, BLOCK_OPT_BACKING_FILE)) {\n<113> backing_file = options->value.s;\n<115> } else if (!strcmp(options->name, BLOCK_OPT_COMPAT6)) {\n<117> flags |= options->value.n ? BLOCK_FLAG_COMPAT6 : 0;\n<119> } else if (!strcmp(options->name, BLOCK_OPT_SUBFMT)) {\n<121> fmt = options->value.s;\n<123> } else if (!strcmp(options->name, BLOCK_OPT_ZEROED_GRAIN)) {\n<125> zeroed_grain |= options->value.n;\n<129> options++;\n<133> if (!adapter_type) {\n<135> adapter_type = "ide";\n<137> } else if (strcmp(adapter_type, "ide") &&\n<139> strcmp(adapter_type, "buslogic") &&\n<141> strcmp(adapter_type, "lsilogic") &&\n<143> strcmp(adapter_type, "legacyESX")) {\n<145> error_setg(errp, "Unknown adapter type: '%s'", adapter_type);\n<147> ret = -EINVAL;\n<153> if (strcmp(adapter_type, "ide") != 0) {\n<159> number_heads = 255;\n<163> if (!fmt) {\n<167> fmt = "monolithicSparse";\n<169> } else if (strcmp(fmt, "monolithicFlat") &&\n<171> strcmp(fmt, "monolithicSparse") &&\n<173> strcmp(fmt, "twoGbMaxExtentSparse") &&\n<175> strcmp(fmt, "twoGbMaxExtentFlat") &&\n<177> strcmp(fmt, "streamOptimized")) {\n<179> error_setg(errp, "Unknown subformat: '%s'", fmt);\n<181> ret = -EINVAL;\n<187> split = !(strcmp(fmt, "twoGbMaxExtentFlat") &&\n<189> strcmp(fmt, "twoGbMaxExtentSparse"));\n<191> flat = !(strcmp(fmt, "monolithicFlat") &&\n<193> strcmp(fmt, "twoGbMaxExtentFlat"));\n<195> compress = !strcmp(fmt, "streamOptimized");\n<197> if (flat) {\n<207> if (flat && backing_file) {\n<235> if (ret != 0) {\n<241> if (strcmp(bs->drv->format_name, "vmdk")) {\n<243> bdrv_unref(bs);\n<245> ret = -EINVAL;\n<251> parent_cid = vmdk_read_cid(bs, 0);\n<253> bdrv_unref(bs);\n<255> snprintf(parent_desc_line, sizeof(parent_desc_line),\n<265> filesize = total_size;\n<267> while (filesize > 0) {\n<279> if (split && size > split_size) {\n<359> desc_len = strlen(desc);\n<363> if (!split && !flat) {\n<395> ret = bdrv_pwrite(new_bs, desc_offset, desc, desc_len);\n<429> g_free(desc);
<115> const AVPacketSideData *sd_src = &ist->st->side_data[i];\n<117> AVPacketSideData *sd_dst = &ost->st->side_data[ost->st->nb_side_data];\n<127> sd_dst->data = av_malloc(sd_src->size);\n<129> if (!sd_dst->data)\n<133> memcpy(sd_dst->data, sd_src->data, sd_src->size);\n<135> sd_dst->size = sd_src->size;
<1> static char * getstringtime ( krb5_timestamp epochtime ) {\n<5> strtime = calloc ( 50 , 1 ) ;\n<6> if ( strtime == NULL ) return NULL ;
<7> VP9Context *s = dst->priv_data, *ssrc = src->priv_data;\n<31> for (i = 0; i < 8; i++) {\n<55> memcpy(&s->prob_ctx, &ssrc->prob_ctx, sizeof(s->prob_ctx));\n<57> memcpy(&s->lf_delta, &ssrc->lf_delta, sizeof(s->lf_delta));\n<59> if (ssrc->segmentation.enabled) {\n<61> memcpy(&s->segmentation.feat, &ssrc->segmentation.feat,
<1> static void print_sexp ( const char * prefix , gcry_sexp_t a ) {\n<4> if ( prefix ) fputs ( prefix , stderr ) ;\n<7> gcry_sexp_sprint ( a , GCRYSEXP_FMT_ADVANCED , buf , size ) ;\n<8> fprintf ( stderr , "%.*s" , ( int ) size , buf ) ;\n<9> gcry_free ( buf ) ;
<1> void *g_try_malloc(size_t n_bytes)\n<7> return malloc(n_bytes == 0 ? 1 : n_bytes);
<1> static int net_socket_mcast_create(struct sockaddr_in *mcastaddr)\n<11> if (!IN_MULTICAST(ntohl(mcastaddr->sin_addr.s_addr))) {\n<13> fprintf(stderr, "qemu: error: specified mcastaddr \"%s\" (0x%08x) does not contain a multicast address\n",\n<15> inet_ntoa(mcastaddr->sin_addr),\n<17> (int)ntohl(mcastaddr->sin_addr.s_addr));
<1> static int send_extradata(APNGDemuxContext *ctx, AVPacket *pkt)\n<7> uint8_t *side_data = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, ctx->extra_data_size);\n<9> if (!side_data)\n<13> memcpy(side_data, ctx->extra_data, ctx->extra_data_size);
<1> void xps_parse_brush ( xps_document * doc , const fz_matrix * ctm , const fz_rect * area , char * base_uri , xps_resource * dict , fz_xml * node ) {\n<2> if ( doc -> cookie && doc -> cookie -> abort ) return ;\n<3> if ( ! strcmp ( fz_xml_tag ( node ) , "ImageBrush" ) ) xps_parse_image_brush ( doc , ctm , area , base_uri , dict , node ) ;\n<4> else if ( ! strcmp ( fz_xml_tag ( node ) , "VisualBrush" ) ) xps_parse_visual_brush ( doc , ctm , area , base_uri , dict , node ) ;\n<5> else if ( ! strcmp ( fz_xml_tag ( node ) , "LinearGradientBrush" ) ) xps_parse_linear_gradient_brush ( doc , ctm , area , base_uri , dict , node ) ;\n<6> else if ( ! strcmp ( fz_xml_tag ( node ) , "RadialGradientBrush" ) ) xps_parse_radial_gradient_brush ( doc , ctm , area , base_uri , dict , node ) ;\n<7> else fz_warn ( doc -> ctx , "unknown brush tag: %s" , fz_xml_tag ( node ) ) ;
<2> ssize_t __vstrfmon_l ( char * s , size_t maxsize , __locale_t loc , const char * format , va_list ap ) {\n<137> char int_symbol [ 4 ] ;\n<138> switch ( * fmt ++ ) {\n<141> int_curr_symbol = _NL_CURRENT ( LC_MONETARY , INT_CURR_SYMBOL ) ;\n<142> strncpy ( int_symbol , int_curr_symbol , 3 ) ;\n<143> int_symbol [ 3 ] = '\0' ;\n<145> currency_symbol = & int_symbol [ 0 ] ;\n<146> space_char = int_curr_symbol [ 3 ] ;\n<150> case 'n' : currency_symbol = _NL_CURRENT ( LC_MONETARY , CURRENCY_SYMBOL ) ;\n<151> currency_symbol_len = strlen ( currency_symbol ) ;\n<176> sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n<177> if ( * sign_string == '\0' ) sign_string = ( const char * ) "-" ;\n<181> other_sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n<187> sign_string = _NL_CURRENT ( LC_MONETARY , POSITIVE_SIGN ) ;\n<191> other_sign_string = _NL_CURRENT ( LC_MONETARY , NEGATIVE_SIGN ) ;\n<192> if ( * other_sign_string == '\0' ) other_sign_string = ( const char * ) "-" ;\n<214> int left_bytes = 0 ;\n<215> int other_left_bytes = 0 ;\n<217> left_bytes += currency_symbol_len ;\n<218> if ( sep_by_space != 0 ) ++ left_bytes ;\n<221> other_left_bytes += currency_symbol_len ;\n<222> if ( other_sep_by_space != 0 ) ++ other_left_bytes ;\n<225> else if ( sign_posn == 1 ) left_bytes += strlen ( sign_string ) ;\n<226> else if ( cs_precedes && ( sign_posn == 3 || sign_posn == 4 ) ) left_bytes += strlen ( sign_string ) ;\n<228> else if ( other_sign_posn == 1 ) other_left_bytes += strlen ( other_sign_string ) ;\n<229> else if ( other_cs_precedes && ( other_sign_posn == 3 || other_sign_posn == 4 ) ) other_left_bytes += strlen ( other_sign_string ) ;\n<230> if ( other_left_bytes > left_bytes ) left_pad = other_left_bytes - left_bytes ;\n<238> out_string ( sign_string ) ;\n<241> if ( print_curr_symbol ) out_string ( currency_symbol ) ;\n<244> out_string ( sign_string ) ;\n<249> else if ( sign_posn != 0 && sign_posn != 2 && sign_posn != 3 && sign_posn != 4 && sign_posn != 5 ) out_string ( sign_string ) ;\n<255> memset ( & info , '\0' , sizeof ( info ) ) ;\n<256> info . prec = right_prec ;\n<257> info . width = left_prec + ( right_prec ? ( right_prec + 1 ) : 0 ) ;\n<258> info . spec = 'f' ;\n<259> info . is_long_double = is_long_double ;\n<260> info . group = group ;\n<261> info . pad = pad ;\n<262> info . extra = 1 ;\n<264> done = __printf_fp ( ( FILE * ) & f , & info , & ptr ) ;\n<274> out_string ( sign_string ) ;\n<278> out_nstring ( currency_symbol , currency_symbol_len ) ;\n<282> out_string ( sign_string ) ;\n<287> out_string ( sign_string ) ;
<1> static int rtsp_parse_request(HTTPContext *c)\n<17> RTSPMessageHeader header1, *header = &header1;\n<23> p = c->buffer;\n<27> get_word(cmd, sizeof(cmd), &p);\n<29> get_word(url, sizeof(url), &p);\n<31> get_word(protocol, sizeof(protocol), &p);\n<35> av_strlcpy(c->method, cmd, sizeof(c->method));\n<39> av_strlcpy(c->protocol, protocol, sizeof(c->protocol));\n<43> if (url_open_dyn_buf(&c->pb) < 0) {\n<57> if (strcmp(protocol, "RTSP/1.0") != 0) {\n<59> rtsp_reply_error(c, RTSP_STATUS_VERSION);\n<69> memset(header, 0, sizeof(*header));\n<73> while (*p != '\n' && *p != '\0')\n<75> p++;\n<77> if (*p == '\n')\n<79> p++;\n<81> while (*p != '\0') {\n<83> p1 = strchr(p, '\n');\n<85> if (!p1)\n<91> if (p2 > p && p2[-1] == '\r')\n<97> if (p2 == p)\n<101> len = p2 - p;\n<103> if (len > sizeof(line) - 1)\n<105> len = sizeof(line) - 1;\n<107> memcpy(line, p, len);\n<109> line[len] = '\0';\n<111> ff_rtsp_parse_line(header, line, NULL);\n<113> p = p1 + 1;\n<121> c->seq = header->seq;\n<125> if (!strcmp(cmd, "DESCRIBE"))\n<127> rtsp_cmd_describe(c, url);\n<129> else if (!strcmp(cmd, "OPTIONS"))\n<131> rtsp_cmd_options(c, url);\n<133> else if (!strcmp(cmd, "SETUP"))\n<135> rtsp_cmd_setup(c, url, header);\n<137> else if (!strcmp(cmd, "PLAY"))\n<139> rtsp_cmd_play(c, url, header);\n<141> else if (!strcmp(cmd, "PAUSE"))\n<143> rtsp_cmd_pause(c, url, header);\n<145> else if (!strcmp(cmd, "TEARDOWN"))\n<147> rtsp_cmd_teardown(c, url, header);\n<151> rtsp_reply_error(c, RTSP_STATUS_METHOD);
<1> static void mpc8544_guts_write ( void * opaque , hwaddr addr , uint64_t value , unsigned size ) {\n<2> addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;\n<3> switch ( addr ) {\n<8> default : fprintf ( stderr , "guts: Unknown register write: %x = %x\n" , ( int ) addr , ( unsigned ) value ) ;
<1> krb5_error_code berval2tl_data ( struct berval * in , krb5_tl_data * * out ) {\n<2> * out = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ;\n<3> if ( * out == NULL ) return ENOMEM ;\n<5> ( * out ) -> tl_data_contents = ( krb5_octet * ) malloc ( ( * out ) -> tl_data_length * sizeof ( krb5_octet ) ) ;\n<6> if ( ( * out ) -> tl_data_contents == NULL ) {\n<7> free ( * out ) ;\n<10> UNSTORE16_INT ( in -> bv_val , ( * out ) -> tl_data_type ) ;\n<11> memcpy ( ( * out ) -> tl_data_contents , in -> bv_val + 2 , ( * out ) -> tl_data_length ) ;
<1> void DefaultTTFEnglishNames ( struct ttflangname * dummy , SplineFont * sf ) {\n<4> char buffer [ 200 ] ;\n<7> if ( dummy -> names [ ttf_subfamily ] == NULL || * dummy -> names [ ttf_subfamily ] == '\0' ) dummy -> names [ ttf_subfamily ] = utf8_verify_copy ( SFGetModifiers ( sf ) ) ;\n<12> dummy -> names [ ttf_uniqueid ] = copy ( buffer ) ;\n<16> if ( sf -> subfontcnt != 0 ) sprintf ( buffer , "Version %f " , ( double ) sf -> cidversion ) ;\n<17> else if ( sf -> version != NULL ) sprintf ( buffer , "Version %.20s " , sf -> version ) ;\n<19> dummy -> names [ ttf_version ] = copy ( buffer ) ;
<1> static gboolean has_fs_id ( GFile * file , const char * fs_id ) {\n<7> if ( info ) {\n<8> id = g_file_info_get_attribute_string ( info , G_FILE_ATTRIBUTE_ID_FILESYSTEM ) ;\n<9> if ( id && strcmp ( id , fs_id ) == 0 ) {\n<10> res = TRUE ;
<1> static void cmv_decode_intra ( CmvContext * s , AVFrame * frame , const uint8_t * buf , const uint8_t * buf_end ) {\n<2> unsigned char * dst = frame -> data [ 0 ] ;\n<5> i < s -> avctx -> height && buf_end - buf >= s -> avctx -> width ;\n<7> memcpy ( dst , buf , s -> avctx -> width ) ;\n<8> dst += frame -> linesize [ 0 ] ;\n<9> buf += s -> avctx -> width ;
<1> static int parse_uint32(DeviceState *dev, Property *prop, const char *str)\n<5> uint32_t *ptr = qdev_get_prop_ptr(dev, prop);\n<15> if (sscanf(str, fmt, ptr) != 1)\n<17> return -EINVAL;\n<19> return 0;
<1> static void destroy_addr_opts_fifo ( addr_opts_fifo * fifo ) {\n<3> if ( fifo != NULL ) {\n<5> UNLINK_FIFO ( aon , * fifo , link ) ;\n<6> if ( aon != NULL ) {\n<7> destroy_address_node ( aon -> addr ) ;\n<8> destroy_attr_val_fifo ( aon -> options ) ;\n<9> free ( aon ) ;\n<12> while ( aon != NULL ) ;\n<13> free ( fifo ) ;
<1> static int parse_read_interval ( const char * interval_spec , ReadInterval * interval ) {\n<4> if ( ! spec ) return AVERROR ( ENOMEM ) ;\n<5> if ( ! * spec ) {\n<11> next = strchr ( spec , '%' ) ;\n<12> if ( next ) * next ++ = 0 ;\n<31> p = next ;\n<67> end : av_free ( spec ) ;
<1> static void ExecuteSqlCommand ( ArchiveHandle * AH , const char * qry , const char * desc ) {\n<4> char errStmt [ DB_MAX_ERR_STMT ] ;\n<7> switch ( PQresultStatus ( res ) ) {\n<11> default : strncpy ( errStmt , qry , DB_MAX_ERR_STMT ) ;\n<12> if ( errStmt [ DB_MAX_ERR_STMT - 1 ] != '\0' ) {\n<18> warn_or_exit_horribly ( AH , modulename , "%s: %s Command was: %s\n" , desc , PQerrorMessage ( conn ) , errStmt ) ;
<1> static inline int onenand_load_spare(OneNANDState *s, int sec, int secn,\n<3> void *dest)\n<13> if (blk_read(s->blk_cur, s->secs_cur + (sec >> 5), buf, 1) < 0) {\n<19> memcpy(dest, buf + ((sec & 31) << 4), secn << 4);\n<21> } else if (sec + secn > s->secs_cur) {\n<27> memcpy(dest, s->current + (s->secs_cur << 9) + (sec << 4), secn << 4);
<1> static gpgme_error_t uiserver_assuan_simple_command ( assuan_context_t ctx , char * cmd , engine_status_handler_t status_fnc , void * status_fnc_value ) {\n<8> err = assuan_read_line ( ctx , & line , & linelen ) ;\n<10> if ( * line == '#' || ! linelen ) continue ;\n<11> if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\0' || line [ 2 ] == ' ' ) ) return 0 ;\n<12> else if ( linelen >= 4 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n<13> else if ( linelen >= 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n<16> rest = strchr ( line + 2 , ' ' ) ;\n<17> if ( ! rest ) rest = line + linelen ;
<1> static int context_init ( H264Context * h ) {\n<2> ERContext * er = & h -> er ;\n<9> if ( CONFIG_ERROR_RESILIENCE ) {\n<28> FF_ALLOC_OR_GOTO ( h -> avctx , er -> mbintra_table , mb_array_size , fail ) ;\n<29> memset ( er -> mbintra_table , 1 , mb_array_size ) ;\n<30> FF_ALLOCZ_OR_GOTO ( h -> avctx , er -> mbskip_table , mb_array_size + 2 , fail ) ;
<1> static const char * cpio_rename ( const char * name ) {\n<16> if ( t == NULL ) return ( name ) ;\n<17> fprintf ( t , "%s (Enter/./(new name))? " , name ) ;\n<18> fflush ( t ) ;\n<24> if ( * p == '.' && p [ 1 ] == '\n' ) return ( name ) ;
<1> bool change_password ( THD * thd , const char * host , const char * user , char * new_password ) {\n<4> char buff [ 512 ] ;\n<7> uint new_password_len = ( uint ) strlen ( new_password ) ;\n<10> DBUG_PRINT ( "enter" , ( "host: '%s' user: '%s' new_password: '%s'" , host , user , new_password ) ) ;\n<12> if ( check_change_password ( thd , host , user , new_password , new_password_len ) ) DBUG_RETURN ( 1 ) ;\n<29> set_user_salt ( acl_user , new_password , new_password_len ) ;\n<30> if ( update_user_table ( thd , table , acl_user -> host . hostname ? acl_user -> host . hostname : "" , acl_user -> user ? acl_user -> user : "" , new_password , new_password_len ) ) {\n<37> if ( mysql_bin_log . is_open ( ) ) {\n<38> query_length = sprintf ( buff , "SET PASSWORD FOR '%-.120s'@'%-.120s'='%-.120s'" , acl_user -> user ? acl_user -> user : "" , acl_user -> host . hostname ? acl_user -> host . hostname : "" , new_password ) ;
<1> void usage ( ) {\n<4> printf ( "Runs a test against the mysql server and compares output with a results file.\n\n" ) ;\n<5> printf ( "Usage: %s [OPTIONS] [database] < test_file\n" , my_progname ) ;
<1> int ram_load(QEMUFile *f, void *opaque, int version_id)\n<65> id[len] = 0;\n<73> if (!strncmp(id, block->idstr, sizeof(id))) {\n<87> if (!block) {\n<89> fprintf(stderr, "Unknown ramblock \"%s\", cannot "\n<109> if (flags & RAM_SAVE_FLAG_COMPRESS) {\n<119> host = qemu_get_ram_ptr(addr);\n<123> host = host_from_stream_offset(f, addr, flags);\n<127> ch = qemu_get_byte(f);\n<129> memset(host, ch, TARGET_PAGE_SIZE);\n<133> if (ch == 0 &&\n<137> madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n<159> qemu_get_buffer(f, host, TARGET_PAGE_SIZE);
<1> static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,\n<15> memset(&ai, 0, sizeof(ai));\n<49> rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);
<1> static void realview_init(MachineState *machine,\n<95> if (!cpu_oc) {\n<97> fprintf(stderr, "Unable to find CPU definition\n");\n<427> nd = &nd_table[n];\n<431> if (!done_nic && (!nd->model ||\n<433> strcmp(nd->model, is_pb ? "lan9118" : "smc91c111") == 0)) {\n<437> lan9118_init(nd, 0x4e000000, pic[28]);\n<441> smc91c111_init(nd, 0x4e000000, pic[28]);\n<451> pci_nic_init_nofail(nd, pci_bus, "rtl8139", NULL);
<1> static void ppc_prep_init (ram_addr_t ram_size,\n<61> if (!env) {\n<63> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<227> if (ppc_boot_device == '\0') {\n<229> fprintf(stderr, "No valid boot device for Mac99 machine\n");\n<291> for(i = 0; i < nb_nics1; i++) {\n<293> if (nd_table[i].model == NULL) {\n<295> nd_table[i].model = "ne2k_isa";\n<299> if (strcmp(nd_table[i].model, "ne2k_isa") == 0) {\n<301> isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);\n<305> pci_nic_init(&nd_table[i], "ne2k_pci", NULL);\n<313> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<315> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static void vnc_dpy_resize(DisplayState *ds)\n<7> VncState *vs = ds->opaque;\n<15> if (vs->old_data == NULL) {\n<17> fprintf(stderr, "vnc: memory allocation failed\n");\n<49> vnc_flush(vs);\n<57> memset(vs->dirty_row, 0xFF, sizeof(vs->dirty_row));\n<59> memset(vs->old_data, 42, ds_get_linesize(vs->ds) * ds_get_height(vs->ds));
<1> static void monitor_parse(const char *optarg, const char *mode)\n<33> opts = qemu_chr_parse_compat(label, optarg);\n<35> if (!opts) {\n<37> fprintf(stderr, "parse error: %s\n", optarg);\n<47> opts = qemu_opts_create(qemu_find_opts("mon"), label, 1);\n<49> if (!opts) {\n<51> fprintf(stderr, "duplicate chardev: %s\n", label);\n<59> qemu_opt_set(opts, "chardev", label);
<1> static void flush_packet(AVFormatContext *ctx, int stream_index,\n<9> StreamInfo *stream = ctx->streams[stream_index]->priv_data;\n<211> put_buffer(&ctx->pb, stream->buffer, payload_size - stuffing_size);\n<225> memmove(stream->buffer, stream->buffer + stream->buffer_ptr - len, len);\n<227> stream->buffer_ptr = len;
<1> static void aio_read_done(void *opaque, int ret)\n<5> struct aio_ctx *ctx = opaque;\n<15> if (ret < 0) {\n<17> printf("readv failed: %s\n", strerror(-ret));\n<25> if (ctx->Pflag) {\n<27> void *cmp_buf = g_malloc(ctx->qiov.size);\n<31> memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n<33> if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n<41> g_free(cmp_buf);\n<57> dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n<67> print_report("read", &t2, ctx->offset, ctx->qiov.size,\n<73> qemu_io_free(ctx->buf);\n<76> g_free(ctx);
<1> void proto_register_fields_section ( const int parent , header_field_info * hfi , const int num_records ) {\n<8> if ( hfi [ i ] . id != - 1 ) {\n<9> fprintf ( stderr , "Duplicate field detected in call to proto_register_fields: %s is already registered\n" , hfi [ i ] . abbrev ) ;
<1> rfbBool rfbFilenameTranslate2DOS ( rfbClientPtr cl , char * unixPath , char * path ) {\n<4> sprintf ( path , "C:%s" , unixPath ) ;\n<5> for ( x = 2 ;\n<6> x < strlen ( path ) ;\n<7> x ++ ) if ( path [ x ] == '/' ) path [ x ] = '\\' ;
<1> uint32_t do_arm_semihosting(CPUARMState *env)\n<27> nr = env->regs[0];\n<31> switch (nr) {\n<35> if (!(s = lock_user_string(ARG(0))))\n<41> if (ARG(1) >= 12)\n<45> if (strcmp(s, ":tt") == 0) {\n<47> if (ARG(1) < 4)\n<57> if (use_gdb_syscalls()) {\n<67> ret = set_swi_errno(ts, open(s, open_modeflags[ARG(1)], 0644));\n<121> if (!(s = lock_user_string(args)))\n<127> len = strlen(s);\n<131> gdb_do_syscall(arm_semi_cb, "write,2,%x,%x\n", args, len);\n<137> ret = write(STDERR_FILENO, s, len);\n<141> unlock_user(s, args, 0);\n<437> output_size = strlen(ts->boot_info->kernel_filename)\n<441> + strlen(ts->boot_info->kernel_cmdline)\n<467> if (output_size > input_size) {\n<499> pstrcpy(output_buffer, output_size, ts->boot_info->kernel_filename);\n<503> pstrcat(output_buffer, output_size, ts->boot_info->kernel_cmdline);\n<651> gdb_exit(env, 0);\n<657> fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr);\n<659> cpu_dump_state(env, stderr, fprintf, 0);
<1> static NetSocketState *net_socket_fd_init(NetClientState *peer,\n<13> if(getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&so_type,\n<17> fprintf(stderr, "qemu: error: getsockopt(SO_TYPE) for fd=%d failed\n",\n<21> closesocket(fd);\n<27> switch(so_type) {\n<41> fprintf(stderr, "qemu: warning: socket type=%d for fd=%d is not SOCK_DGRAM or SOCK_STREAM\n", so_type, fd);\n<43> return net_socket_fd_init_stream(peer, model, name, fd, is_connected);
<1> int qemuMonitorTextBlockResize ( qemuMonitorPtr mon , const char * device , unsigned long long size ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<13> if ( strstr ( reply , "unknown command:" ) ) {\n<14> ret = - 2 ;\n<17> ret = 0 ;\n<19> VIR_FREE ( reply ) ;
<1> static void test_bug9643 ( ) {\n<19> if ( ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_stmt_error ( stmt ) ) ;\n<24> check_execute ( stmt , rc ) ;\n<25> stmt_text = "select * from t1" ;\n<26> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<27> check_execute ( stmt , rc ) ;\n<28> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<32> mysql_stmt_bind_result ( stmt , my_bind ) ;
<1> static uint32_t get_cluster_count_for_direntry(BDRVVVFATState* s,\n<57> const char* basename2 = NULL;\n<77> basename2 = get_basename(path);\n<81> mapping = find_mapping_for_cluster(s, cluster_num);\n<85> if (mapping) {\n<97> basename = get_basename(mapping->path);\n<107> if (strcmp(basename, basename2))\n<109> schedule_rename(s, cluster_num, strdup(path));\n<111> } else if (is_file(direntry))\n<115> schedule_new_file(s, strdup(path), cluster_num);\n<133> if (!copy_it && cluster_was_modified(s, cluster_num)) {\n<137> mapping->begin > cluster_num ||\n<139> mapping->end <= cluster_num)\n<141> mapping = find_mapping_for_cluster(s, cluster_num);\n<157> * (cluster_num - mapping->begin)) {\n<165> } else if (offset == 0) {\n<167> const char* basename = get_basename(mapping->path);\n<171> if (strcmp(basename, basename2))\n<173> copy_it = 1;\n<175> first_mapping_index = array_index(&(s->mapping), mapping);\n<199> schedule_writeout(s, mapping->dir_index, offset);\n<221> int64_t offset = cluster2sector(s, cluster_num);\n<225> vvfat_close_current_file(s);\n<263> cluster_num = modified_fat_get(s, cluster_num);\n<267> if (fat_eof(s, cluster_num))
<1> static void print_xml_null_tag ( FILE * xml_file , const char * sbeg , const char * stag_atr , const char * sval , const char * line_end ) {\n<5> fputs ( "\"" , xml_file ) ;\n<6> print_quoted_xml ( xml_file , sval , strlen ( sval ) , 0 ) ;\n<7> fputs ( "\" xsi:nil=\"true\" />" , xml_file ) ;
<1> int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,\n<3> uint8_t *dst, int dlen)\n<107> nzrun_start = new_buf + i;\n<175> d += uleb128_encode_small(dst + d, nzrun_len);\n<179> if (d + nzrun_len > dlen) {\n<185> memcpy(dst + d, nzrun_start, nzrun_len);\n<187> d += nzrun_len;
<1> static void mpc8544ds_init(ram_addr_t ram_size,\n<51> if (!env) {\n<53> fprintf(stderr, "Unable to initialize CPU!\n");\n<121> if (!pci_bus)\n<123> printf("couldn't create PCI controller!\n");\n<149> kernel_size = load_uimage(kernel_filename, &entry, &loadaddr, NULL);\n<153> kernel_size = load_elf(kernel_filename, 0, &elf_entry, &elf_lowaddr,\n<165> if (kernel_size < 0) {\n<167> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<183> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<189> if (initrd_size < 0) {\n<191> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<211> if (fdt == NULL) {\n<213> fprintf(stderr, "couldn't load device tree\n");
<1> static void unixErrorHandler ( const char * module , const char * fmt , va_list ap ) {\n<2> if ( module != NULL ) fprintf ( stderr , "%s: " , module ) ;\n<3> vfprintf ( stderr , fmt , ap ) ;\n<4> fprintf ( stderr , ".\n" ) ;
<1> static void rocker_test_dma_ctrl(Rocker *r, uint32_t val)\n<5> PCIDevice *dev = PCI_DEVICE(r);\n<13> buf = g_malloc(r->test_dma_size);\n<17> if (!buf) {\n<27> switch (val) {\n<31> memset(buf, 0, r->test_dma_size);\n<37> memset(buf, 0x96, r->test_dma_size);\n<61> pci_dma_write(dev, r->test_dma_addr, buf, r->test_dma_size);
<1> static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) {\n<56> o = 0 ;\n<59> if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ;\n<60> if ( l > ll ) l = ll ;\n<61> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ;\n<62> VFP_Extend ( bo -> vfc , l ) ;\n<64> o += l ;
<1> SplinePointList * SplinesFromEntityChar ( EntityChar * ec , int * flags , int is_stroked ) {\n<12> ent != NULL ;\n<26> ent != NULL ;\n<29> if ( ent -> type == et_splines && is_stroked ) {\n<37> else if ( ent -> type == et_splines ) {\n<38> if ( ent -> u . splines . stroke . col != 0xffffffff && ( ent -> u . splines . fill . col == 0xffffffff || ent -> u . splines . stroke_width != 0 ) ) {\n<39> memset ( & si , '\0' , sizeof ( si ) ) ;\n<42> si . radius = ent -> u . splines . stroke_width / 2 ;\n<43> if ( ent -> u . splines . stroke_width == WIDTH_INHERITED ) si . radius = .5 ;\n<44> if ( si . cap == lc_inherited ) si . cap = lc_butt ;\n<45> if ( si . join == lj_inherited ) si . join = lj_miter ;\n<52> temp = SplineSetStroke ( each , & si , false ) ;\n<93> SplinePointListsFree ( ent -> clippath ) ;\n<94> free ( ent ) ;
<1> int av_copy_packet_side_data(AVPacket *pkt, AVPacket *src)\n<5> if (src->side_data_elems) {\n<15> src->side_data_elems * sizeof(*src->side_data));
<1> static void ppp_hdlc ( netdissect_options * ndo , const u_char * p , int length ) {\n<6> if ( length <= 0 ) return ;\n<7> b = ( u_char * ) malloc ( length ) ;\n<8> if ( b == NULL ) return ;\n<9> for ( s = p , t = b , i = length ;\n<22> length = t - b ;\n<23> if ( length < 1 ) goto trunc ;\n<25> switch ( proto ) {\n<32> if ( length < 2 ) goto trunc ;\n<33> proto = EXTRACT_16BITS ( b ) ;\n<34> switch ( proto ) {\n<35> case ( PPP_ADDRESS << 8 | PPP_CONTROL ) : if ( length < 4 ) goto trunc ;\n<43> free ( b ) ;\n<46> free ( b ) ;
<1> hb_graphite2_shaper_face_data_t * _hb_graphite2_shaper_face_data_create ( hb_face_t * face ) {\n<3> if ( ! hb_blob_get_length ( silf_blob ) ) {\n<8> hb_graphite2_shaper_face_data_t * data = ( hb_graphite2_shaper_face_data_t * ) calloc ( 1 , sizeof ( hb_graphite2_shaper_face_data_t ) ) ;\n<10> data -> face = face ;\n<11> data -> grface = gr_make_face ( data , & hb_graphite2_get_table , gr_face_preloadAll ) ;\n<12> if ( unlikely ( ! data -> grface ) ) {\n<13> free ( data ) ;
<1> static int put_info ( const char * str , INFO_TYPE info_type , uint error , const char * sqlstate ) {\n<5> if ( info_type == INFO_ERROR ) {\n<6> ( void ) fflush ( file ) ;\n<7> fprintf ( file , "ERROR" ) ;\n<9> if ( sqlstate ) ( void ) fprintf ( file , " %d (%s)" , error , sqlstate ) ;\n<10> else ( void ) fprintf ( file , " %d" , error ) ;\n<12> if ( status . query_start_line && line_numbers ) {\n<13> ( void ) fprintf ( file , " at line %lu" , status . query_start_line ) ;\n<14> if ( status . file_name ) ( void ) fprintf ( file , " in file: '%s'" , status . file_name ) ;\n<16> ( void ) fprintf ( file , ": %s\n" , str ) ;\n<17> ( void ) fflush ( file ) ;
<1> static size_t write_dns_nameenc ( char * buf , size_t buflen , char * data , int datalen , char downenc ) {\n<10> space = MIN ( 0xFF , buflen ) - 4 - 2 ;\n<11> memset ( buf , 0 , buflen ) ;\n<13> buf [ 0 ] = 'i' ;\n<15> b64 -> encode ( buf + 1 , & space , data , datalen ) ;\n<16> if ( ! b64 -> places_dots ( ) ) inline_dotify ( buf , buflen ) ;\n<19> buf [ 0 ] = 'j' ;\n<21> b64u -> encode ( buf + 1 , & space , data , datalen ) ;\n<22> if ( ! b64u -> places_dots ( ) ) inline_dotify ( buf , buflen ) ;\n<25> buf [ 0 ] = 'k' ;\n<27> b128 -> encode ( buf + 1 , & space , data , datalen ) ;\n<28> if ( ! b128 -> places_dots ( ) ) inline_dotify ( buf , buflen ) ;\n<31> buf [ 0 ] = 'h' ;\n<33> b32 -> encode ( buf + 1 , & space , data , datalen ) ;\n<34> if ( ! b32 -> places_dots ( ) ) inline_dotify ( buf , buflen ) ;\n<36> b = buf ;\n<37> b += strlen ( buf ) - 1 ;\n<38> if ( * b != '.' ) * ++ b = '.' ;\n<39> b ++ ;
<1> static my_bool acl_load ( THD * thd , TABLE_LIST * tables ) {\n<21> if ( lower_case_table_names && host . db ) {\n<22> ( void ) strmov ( tmp_name , host . db ) ;\n<23> my_casedn_str ( files_charset_info , host . db ) ;\n<24> if ( strcmp ( host . db , tmp_name ) != 0 ) sql_print_warning ( "'host' entry '%s|%s' had database in mixed " "case that has been forced to lowercase because " "lower_case_table_names is set. It will not be " "possible to remove this privilege using REVOKE." , host . host . hostname ? host . host . hostname : "" , host . db ? host . db : "" ) ;\n<28> host . sort = get_sort ( 2 , host . host . hostname , host . db ) ;
<1> static void test_stmt_close ( ) {\n<10> if ( ! opt_silent ) fprintf ( stdout , "\n Establishing a test connection ..." ) ;\n<20> if ( ! opt_silent ) fprintf ( stdout , "OK" ) ;\n<44> rc = mysql_stmt_close ( stmt1 ) ;\n<45> if ( ! opt_silent ) fprintf ( stdout , "\n mysql_close_stmt(1) returned: %d" , rc ) ;\n<46> DIE_UNLESS ( rc == 0 ) ;\n<50> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<54> rc = mysql_stmt_bind_param ( stmt_x , my_bind ) ;\n<59> rc = mysql_stmt_close ( stmt_x ) ;\n<60> if ( ! opt_silent ) fprintf ( stdout , "\n mysql_close_stmt(x) returned: %d" , rc ) ;\n<61> DIE_UNLESS ( rc == 0 ) ;
<1> static unsigned long get_match ( char * s , struct masks * m ) {\n<2> while ( m -> name ) {\n<3> if ( strcmp ( s , m -> name ) == 0 ) return m -> mask ;\n<4> else m ++ ;
<1> static void encode_rgb_frame(FFV1Context *s, uint8_t *src[3], int w, int h, int stride[3]){\n<19> memset(s->sample_buffer, 0, ring_size*4*(w+6)*sizeof(*s->sample_buffer));\n<29> sample[p][i]= s->sample_buffer + p*ring_size*(w+6) + ((h+i-y)%ring_size)*(w+6) + 3;\n<95> encode_line(s, w, sample[p], (p+1)/2, 9);\n<99> encode_line(s, w, sample[p], (p+1)/2, bits+1);
<1> u_char * evbuffer_find ( struct evbuffer * buffer , const u_char * what , size_t len ) {\n<4> while ( search < end && ( p = memchr ( search , * what , end - search ) ) != NULL ) {\n<5> if ( p + len > end ) break ;\n<6> if ( memcmp ( p , what , len ) == 0 ) return ( p ) ;\n<7> search = p + 1 ;\n<9> return ( NULL ) ;
<1> static void mainstone_common_init(MemoryRegion *address_space_mem,\n<69> if (qtest_enabled()) {\n<75> fprintf(stderr, "Two flash images must be given with the "\n<85> if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n<97> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> static uint32_t esp_mem_readb(void *opaque, target_phys_addr_t addr)\n<23> if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n<27> fprintf(stderr, "esp: PIO data read not implemented\n");
<1> static int inet_connect_addr(struct addrinfo *addr, bool block,\n<21> if (sock < 0) {\n<23> fprintf(stderr, "%s: socket(%s): %s\n", __func__,\n<25> inet_strfamily(addr->ai_family), strerror(errno));
<1> static struct server * get_server ( char * buf , int len ) {\n<3> char error_buf [ 512 ] ;\n<4> if ( data == NULL ) {\n<11> json_value * obj = json_parse_ex ( & settings , data , strlen ( data ) , error_buf ) ;\n<12> if ( obj == NULL ) {\n<13> LOGE ( "%s" , error_buf ) ;\n<16> struct server * server = ss_malloc ( sizeof ( struct server ) ) ;\n<17> memset ( server , 0 , sizeof ( struct server ) ) ;\n<21> i < obj -> u . object . length ;\n<22> i ++ ) {\n<23> char * name = obj -> u . object . values [ i ] . name ;\n<25> if ( strcmp ( name , "server_port" ) == 0 ) {\n<26> if ( value -> type == json_string ) {\n<27> strncpy ( server -> port , value -> u . string . ptr , 8 ) ;\n<33> else if ( strcmp ( name , "password" ) == 0 ) {\n<34> if ( value -> type == json_string ) {\n<35> strncpy ( server -> password , value -> u . string . ptr , 128 ) ;\n<38> else if ( strcmp ( name , "method" ) == 0 ) {\n<39> if ( value -> type == json_string ) {\n<40> server -> method = strdup ( value -> u . string . ptr ) ;\n<43> else if ( strcmp ( name , "fast_open" ) == 0 ) {\n<44> if ( value -> type == json_boolean ) {\n<45> strncpy ( server -> fast_open , ( value -> u . boolean ? "true" : "false" ) , 8 ) ;\n<48> else if ( strcmp ( name , "plugin" ) == 0 ) {\n<49> if ( value -> type == json_string ) {\n<50> server -> plugin = strdup ( value -> u . string . ptr ) ;\n<53> else if ( strcmp ( name , "plugin_opts" ) == 0 ) {\n<54> if ( value -> type == json_string ) {\n<55> server -> plugin_opts = strdup ( value -> u . string . ptr ) ;\n<58> else if ( strcmp ( name , "mode" ) == 0 ) {\n<59> if ( value -> type == json_string ) {\n<60> server -> mode = strdup ( value -> u . string . ptr ) ;\n<64> LOGE ( "invalid data: %s" , data ) ;\n<70> return server ;
<1> static int parse_playlist(HLSContext *c, const char *url,\n<27> if (!in) {\n<53> if (ret < 0)\n<61> read_chomp_line(in, line, sizeof(line));\n<63> if (strcmp(line, "#EXTM3U")) {\n<65> ret = AVERROR_INVALIDDATA;\n<73> if (var) {\n<81> while (!url_feof(in)) {\n<91> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n<97> } else if (av_strstart(line, "#EXT-X-KEY:", &ptr)) {\n<99> struct key_info info = {{0}};\n<101> ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n<109> if (!strcmp(info.method, "AES-128"))\n<111> key_type = KEY_AES_128;\n<115> ff_hex_to_data(iv, info.iv + 2);\n<213> if (!seg) {\n<225> if (has_iv) {\n<227> memcpy(seg->iv, iv, sizeof(iv));\n<233> memset(seg->iv, 0, sizeof(seg->iv));\n<235> AV_WB32(seg->iv + 12, seq);\n<243> dynarray_add(&var->segments, &var->n_segments, seg);
<1> int dtls1_send_server_key_exchange ( SSL * s ) {\n<9> unsigned char * encodedPoint = NULL ;\n<10> int encodedlen = 0 ;\n<195> * p = encodedlen ;\n<196> p += 1 ;\n<197> memcpy ( ( unsigned char * ) p , ( unsigned char * ) encodedPoint , encodedlen ) ;\n<200> p += encodedlen ;
<1> static inline int validate_string ( WriterContext * wctx , char * * dstp , const char * src ) {\n<6> endp = src + strlen ( src ) ;\n<7> for ( p = ( uint8_t * ) src ;\n<13> if ( av_utf8_decode ( & code , & p , endp , wctx -> string_validation_utf8_flags ) < 0 ) {\n<17> av_log ( wctx , AV_LOG_DEBUG , "Invalid UTF-8 sequence %s found in string '%s'\n" , bp . str , src ) ;\n<23> case WRITER_STRING_VALIDATION_FAIL : av_log ( wctx , AV_LOG_ERROR , "Invalid UTF-8 sequence found in string '%s'\n" , src ) ;\n<34> av_log ( wctx , AV_LOG_WARNING , "%d invalid UTF-8 sequence(s) found in string '%s', replaced with '%s'\n" , invalid_chars_nb , src , wctx -> string_validation_replacement ) ;
<1> static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n<81> if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n<89> if ((ret = decode_phys_chunk(avctx, s)) < 0)\n<101> if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n<135> if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n<143> if (decode_plte_chunk(avctx, s, length) < 0)\n<151> if (decode_trns_chunk(avctx, s, length) < 0)\n<159> if (decode_text_chunk(s, length, 0, &metadata) < 0)\n<169> if (decode_text_chunk(s, length, 1, &metadata) < 0)\n<215> handle_small_bpp(s, p);\n<225> size_t raw_bpp = s->bpp - byte_depth;\n<233> uint8_t *row = &s->image_buf[s->image_linesize * y];\n<239> for (x = s->width; x > 0; --x) {\n<241> uint8_t *pixel = &row[s->bpp * (x - 1)];\n<243> memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n<247> if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n<249> memset(&pixel[raw_bpp], 0, byte_depth);\n<253> memset(&pixel[raw_bpp], 0xff, byte_depth);\n<281> handle_p_frame_png(s, p);\n<287> (ret = handle_p_frame_apng(avctx, s, p)) < 0)
<1> static void test_bug15613 ( ) {\n<13> stmt = mysql_stmt_init ( mysql ) ;\n<14> stmt_text = ( "select t, tt, mt, lt, vl, vb, vu from t1" ) ;\n<15> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<16> metadata = mysql_stmt_result_metadata ( stmt ) ;\n<18> if ( ! opt_silent ) {\n<19> printf ( "Field lengths (client character set is latin1):\n" "text character set utf8:\t\t%lu\n" "tinytext character set utf8:\t\t%lu\n" "mediumtext character set utf8:\t\t%lu\n" "longtext character set utf8:\t\t%lu\n" "varchar(255) character set latin1:\t%lu\n" "varchar(255) character set binary:\t%lu\n" "varchar(255) character set utf8:\t%lu\n" , field [ 0 ] . length , field [ 1 ] . length , field [ 2 ] . length , field [ 3 ] . length , field [ 4 ] . length , field [ 5 ] . length , field [ 6 ] . length ) ;\n<21> DIE_UNLESS ( field [ 0 ] . length == 65535 ) ;\n<22> DIE_UNLESS ( field [ 1 ] . length == 255 ) ;\n<23> DIE_UNLESS ( field [ 2 ] . length == 16777215 ) ;\n<24> DIE_UNLESS ( field [ 3 ] . length == 4294967295UL ) ;\n<25> DIE_UNLESS ( field [ 4 ] . length == 255 ) ;\n<26> DIE_UNLESS ( field [ 5 ] . length == 255 ) ;\n<27> DIE_UNLESS ( field [ 6 ] . length == 255 ) ;
<1> static int decode_init_thread_copy ( AVCodecContext * avctx ) {\n<2> H264Context * h = avctx -> priv_data ;\n<3> if ( ! avctx -> internal -> is_copy ) return 0 ;\n<4> memset ( h -> sps_buffers , 0 , sizeof ( h -> sps_buffers ) ) ;\n<5> memset ( h -> pps_buffers , 0 , sizeof ( h -> pps_buffers ) ) ;
<1> static void remove_locks ( void ) {\n<3> fprintf ( stderr , "Removing remote locks...\n" ) ;
<1> static int qcow2_update_options(BlockDriverState *bs, QDict *options,\n<169> if (opt_overlap_check_template && opt_overlap_check &&\n<171> strcmp(opt_overlap_check_template, opt_overlap_check))\n<187> if (!opt_overlap_check) {\n<189> opt_overlap_check = opt_overlap_check_template ?: "cached";\n<195> if (!strcmp(opt_overlap_check, "none")) {\n<197> overlap_check_template = 0;\n<199> } else if (!strcmp(opt_overlap_check, "constant")) {\n<201> overlap_check_template = QCOW2_OL_CONSTANT;\n<203> } else if (!strcmp(opt_overlap_check, "cached")) {\n<205> overlap_check_template = QCOW2_OL_CACHED;\n<207> } else if (!strcmp(opt_overlap_check, "all")) {\n<209> overlap_check_template = QCOW2_OL_ALL;\n<213> error_setg(errp, "Unsupported value '%s' for qcow2 option "\n<219> ret = -EINVAL;\n<235> s->overlap_check = 0;\n<237> for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n<253> s->l2_table_cache = l2_table_cache;\n<255> s->refcount_block_cache = refcount_block_cache;\n<259> s->use_lazy_refcounts = use_lazy_refcounts;\n<263> s->discard_passthrough[QCOW2_DISCARD_NEVER] = false;\n<265> s->discard_passthrough[QCOW2_DISCARD_ALWAYS] = true;\n<267> s->discard_passthrough[QCOW2_DISCARD_REQUEST] =\n<269> qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_REQUEST,\n<271> flags & BDRV_O_UNMAP);\n<273> s->discard_passthrough[QCOW2_DISCARD_SNAPSHOT] =\n<275> qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_SNAPSHOT, true);\n<277> s->discard_passthrough[QCOW2_DISCARD_OTHER] =\n<279> qemu_opt_get_bool(opts, QCOW2_OPT_DISCARD_OTHER, false);\n<283> s->cache_clean_interval = cache_clean_interval;\n<285> cache_clean_timer_init(bs, bdrv_get_aio_context(bs));\n<289> ret = 0;
<1> static void command_line_test ( const char * words ) {\n<4> int retval = wordexp ( words , & we , 0 ) ;\n<5> printf ( "wordexp returned %d\n" , retval ) ;\n<7> i < we . we_wordc ;\n<8> i ++ ) printf ( "we_wordv[%d] = \"%s\"\n" , i , we . we_wordv [ i ] ) ;
<1> static void vmsvga_bios_write ( void * opaque , uint32_t address , uint32_t data ) {\n<2> printf ( "%s: what are we supposed to do with (%08x)?\n" , __func__ , data ) ;
<1> static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)\n<5> const char *protocol  = qdict_get_str(qdict, "protocol");\n<13> if (strcmp(protocol, "spice") == 0) {\n<15> int fd = monitor_get_fd(mon, fdname, NULL);\n<17> int skipauth = qdict_get_try_bool(qdict, "skipauth", 0);\n<19> int tls = qdict_get_try_bool(qdict, "tls", 0);\n<21> if (!using_spice) {\n<53> } else if ((s = qemu_chr_find(protocol)) != NULL) {
<1> static void encode_window_bands_info(AACEncContext *s, SingleChannelElement *sce,\n<183> start = 0;\n<185> for (i = stack_len - 1; i >= 0; i--) {\n<191> count = stackrun[i];\n<193> memset(sce->zeroes + win*16 + start, !cb, count);\n<197> for (j = 0; j < count; j++) {\n<201> start++;
<1> static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n<9> char access[11];\n<11> char type[11];\n<29> while (*p) {\n<47> if (ret < 4 || strcmp(access, "RW")) {\n<51> } else if (!strcmp(type, "FLAT")) {\n<53> if (ret != 5 || flat_offset < 0) {\n<59> } else if (ret != 4) {\n<67> if (sectors <= 0 ||\n<69> (strcmp(type, "FLAT") && strcmp(type, "SPARSE") &&\n<71> strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) ||\n<73> (strcmp(access, "RW"))) {\n<89> if (ret) {\n<103> if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) {\n<111> ret = vmdk_add_extent(bs, extent_file, true, sectors,\n<113> 0, 0, 0, 0, sectors, &extent);\n<115> if (ret < 0) {\n<123> } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) {\n<127> ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n<129> if (ret) {\n<143> return -ENOTSUP;\n<151> while (*p && *p != '\n') {\n<157> p++;
<1> static int dictionary_load ( void ) {\n<8> gboolean do_debug_parser = getenv ( "WIRESHARK_DEBUG_DIAM_DICT_PARSER" ) ? TRUE : FALSE ;\n<9> gboolean do_dump_dict = getenv ( "WIRESHARK_DUMP_DIAM_DICT" ) ? TRUE : FALSE ;\n<36> d = ddict_scan ( dir , "dictionary.xml" , do_debug_parser ) ;
<1> static void make_lpc_coefs ( float * lpc , const float * refl , int order ) {\n<6> cur = lpc ;\n<13> i ++ ) next [ i ] = cur [ i ] + refl [ m ] * cur [ m - i - 1 ] ;\n<16> if ( cur != lpc ) memcpy ( lpc , cur , sizeof ( * lpc ) * order ) ;
<1> int opt_default(void *optctx, const char *opt, const char *arg)\n<21> if (!strcmp(opt, "debug") || !strcmp(opt, "fdebug"))\n<23> av_log_set_level(AV_LOG_DEBUG);\n<27> if (!(p = strchr(opt, ':')))\n<29> p = opt + strlen(opt);\n<31> av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));
<1> TEST_F ( NativeBackendLibsecretTest , ReadDuplicateForms ) {\n<3> const char unique_string [ ] = "unique_unique_string" ;\n<4> const char unique_string_replacement [ ] = "uniKue_unique_string" ;\n<13> ASSERT_TRUE ( substr ) ;\n<14> ASSERT_EQ ( strlen ( unique_string ) , strlen ( unique_string_replacement ) ) ;\n<15> strncpy ( substr , unique_string_replacement , strlen ( unique_string ) ) ;
<1> static unsigned long write_no_reuse_object ( struct sha1file * f , struct object_entry * entry , unsigned long limit , int usable_delta ) {\n<8> if ( ! usable_delta ) {\n<9> if ( entry -> type == OBJ_BLOB && entry -> size > big_file_threshold && ( st = open_istream ( entry -> idx . sha1 , & type , & size , NULL ) ) != NULL ) buf = NULL ;\n<12> if ( ! buf ) die ( _ ( "unable to read %s" ) , sha1_to_hex ( entry -> idx . sha1 ) ) ;\n<14> free ( entry -> delta_data ) ;\n<20> buf = entry -> delta_data ;\n<25> buf = get_delta ( entry ) ;\n<31> else datalen = do_compress ( & buf , size ) ;\n<38> if ( limit && hdrlen + sizeof ( dheader ) - pos + datalen + 20 >= limit ) {\n<40> free ( buf ) ;\n<48> if ( limit && hdrlen + 20 + datalen + 20 >= limit ) {\n<50> free ( buf ) ;\n<58> if ( limit && hdrlen + datalen + 20 >= limit ) {\n<60> free ( buf ) ;\n<65> if ( st ) {\n<70> sha1write ( f , buf , datalen ) ;\n<71> free ( buf ) ;
<1> static int sdp_parse_fmtp_config_h264(AVStream * stream,\n<5> char *attr, char *value)\n<9> AVCodecContext *codec = stream->codec;\n<17> if (!strcmp(attr, "packetization-mode")) {\n<19> av_log(codec, AV_LOG_DEBUG, "RTP Packetization Mode: %d\n", atoi(value));\n<21> h264_data->packetization_mode = atoi(value);\n<35> if (h264_data->packetization_mode > 1)\n<41> } else if (!strcmp(attr, "profile-level-id")) {\n<43> if (strlen(value) == 6) {\n<45> char buffer[3];\n<57> buffer[0] = value[0]; buffer[1] = value[1]; buffer[2] = '\0';\n<59> profile_idc = strtol(buffer, NULL, 16);\n<61> buffer[0] = value[2]; buffer[1] = value[3];\n<63> profile_iop = strtol(buffer, NULL, 16);\n<65> buffer[0] = value[4]; buffer[1] = value[5];\n<67> level_idc = strtol(buffer, NULL, 16);\n<79> h264_data->profile_idc = profile_idc;\n<81> h264_data->profile_iop = profile_iop;\n<83> h264_data->level_idc = level_idc;\n<87> } else  if (!strcmp(attr, "sprop-parameter-sets")) {\n<89> uint8_t start_sequence[]= { 0, 0, 1 };\n<91> codec->extradata_size= 0;\n<93> codec->extradata= NULL;\n<97> while (*value) {\n<127> packet_size= av_base64_decode(decoded_packet, base64packet, sizeof(decoded_packet));\n<131> uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n<137> if(dest)\n<141> if(codec->extradata_size)\n<147> memcpy(dest, codec->extradata, codec->extradata_size);\n<149> av_free(codec->extradata);\n<155> memcpy(dest+codec->extradata_size, start_sequence, sizeof(start_sequence));\n<157> memcpy(dest+codec->extradata_size+sizeof(start_sequence), decoded_packet, packet_size);\n<159> memset(dest+codec->extradata_size+sizeof(start_sequence)+\n<165> codec->extradata= dest;\n<167> codec->extradata_size+= sizeof(start_sequence)+packet_size;\n<185> return 0;
<1> void kadmin_getprivs ( int argc , char * argv [ ] ) {\n<8> if ( argc != 1 ) {\n<9> fprintf ( stderr , _ ( "usage: get_privs\n" ) ) ;\n<13> if ( retval ) {\n<17> printf ( _ ( "current privileges:" ) ) ;\n<21> if ( plist & 1 << i ) printf ( " %s" , privs [ i ] ) ;\n<23> printf ( "\n" ) ;
<1> static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n<5> unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n<19> if (!vs->vd->password) {\n<27> if (vs->vd->expires < now) {\n<37> memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n<43> pwlen = strlen(vs->vd->password);\n<47> key[i] = i<pwlen ? vs->vd->password[i] : 0;\n<99> if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n<101> VNC_DEBUG("Client challenge response did not match\n");\n<107> VNC_DEBUG("Accepting VNC challenge response\n");\n<109> vnc_write_u32(vs, 0); /* Accept auth */\n<111> vnc_flush(vs);\n<115> start_client_init(vs);\n<121> qcrypto_cipher_free(cipher);\n<123> return 0;\n<129> vnc_write_u32(vs, 1); /* Reject auth */\n<131> if (vs->minor >= 8) {\n<135> vnc_write_u32(vs, sizeof(err));\n<137> vnc_write(vs, err, sizeof(err));\n<141> vnc_flush(vs);\n<143> vnc_client_error(vs);\n<145> qcrypto_cipher_free(cipher);\n<147> return 0;
<1> static void test_bug17667 ( ) {\n<39> master_log_filename = ( char * ) malloc ( strlen ( opt_vardir ) + strlen ( "/log/master.log" ) + 1 ) ;\n<40> strxmov ( master_log_filename , opt_vardir , "/log/master.log" , NullS ) ;\n<41> if ( ! opt_silent ) printf ( "Opening '%s'\n" , master_log_filename ) ;\n<42> log_file = my_fopen ( master_log_filename , ( int ) ( O_RDONLY | O_BINARY ) , MYF ( 0 ) ) ;\n<43> free ( master_log_filename ) ;\n<44> if ( log_file == NULL ) {\n<45> if ( ! opt_silent ) {\n<46> printf ( "Could not find the log file, VARDIR/log/master.log, so " "test_bug17667 is not run.\n" "Run test from the mysql-test/mysql-test-run* program to set up " "correct environment for this test.\n\n" ) ;\n<72> for ( statement_cursor = statements ;\n<73> statement_cursor -> buffer != NULL ;\n<74> statement_cursor ++ ) {\n<76> char line_buffer [ MAX_TEST_QUERY_LENGTH * 2 ] ;\n<80> memset ( line_buffer , '/' , MAX_TEST_QUERY_LENGTH * 2 ) ;\n<81> if ( fgets ( line_buffer , MAX_TEST_QUERY_LENGTH * 2 , log_file ) == NULL ) {\n<82> if ( feof ( log_file ) ) DIE ( "Found EOF before all statements where found" ) ;\n<83> fprintf ( stderr , "Got error %d while reading from file\n" , ferror ( log_file ) ) ;\n<84> DIE ( "Read error" ) ;\n<87> while ( my_memmem ( line_buffer , MAX_TEST_QUERY_LENGTH * 2 , statement_cursor -> buffer , statement_cursor -> length ) == NULL ) ;\n<90> while ( hits < expected_hits ) ;\n<91> if ( ! opt_silent ) printf ( "Found statement starting with \"%s\"\n" , statement_cursor -> buffer ) ;\n<94> if ( ! opt_silent ) printf ( "success. All queries found intact in the log.\n" ) ;\n<95> my_fclose ( log_file , MYF ( 0 ) ) ;
<1> static void read_tree(GetBitContext *gb, Tree *tree)\n<5> uint8_t tmp1[16], tmp2[16], *in = tmp1, *out = tmp2;\n<23> if (get_bits1(gb)) {\n<27> memset(tmp1, 0, sizeof(tmp1));\n<39> if (!tmp1[i])\n<49> in[i] = i;\n<63> memcpy(tree->syms, in, 16);
<1> qio_channel_websock_extract_headers(char *buffer,\n<37> nl = strstr(buffer, QIO_CHANNEL_WEBSOCK_HANDSHAKE_DELIM);\n<39> if (!nl) {\n<47> *nl = '\0';\n<51> tmp = strchr(buffer, ' ');\n<53> if (!tmp) {\n<65> if (!g_str_equal(buffer, QIO_CHANNEL_WEBSOCK_HTTP_METHOD)) {\n<75> buffer = tmp + 1;\n<77> tmp = strchr(buffer, ' ');\n<79> if (!tmp) {\n<91> if (!g_str_equal(buffer, QIO_CHANNEL_WEBSOCK_HTTP_PATH)) {\n<105> if (!g_str_equal(buffer, QIO_CHANNEL_WEBSOCK_HTTP_VERSION)) {\n<115> buffer = nl + strlen(QIO_CHANNEL_WEBSOCK_HANDSHAKE_DELIM);\n<143> nl = strstr(buffer, QIO_CHANNEL_WEBSOCK_HANDSHAKE_DELIM);\n<147> *nl = '\0';\n<153> sep = strchr(buffer, ':');\n<155> if (!sep) {\n<187> hdr->name = buffer;\n<203> if (nl) {\n<205> buffer = nl + strlen(QIO_CHANNEL_WEBSOCK_HANDSHAKE_DELIM);\n<209> } while (nl != NULL);
<1> static void test_datetime_ranges ( ) {\n<8> stmt_text = "drop table if exists t1" ;\n<9> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<11> stmt_text = "create table t1 (year datetime, month datetime, day datetime, " "hour datetime, min datetime, sec datetime)" ;\n<12> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<14> stmt = mysql_simple_prepare ( mysql , "INSERT INTO t1 VALUES (?, ?, ?, ?, ?, ?)" ) ;\n<17> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<43> my_process_warnings ( mysql , 12 ) ;\n<51> stmt_text = "delete from t1" ;\n<52> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<54> stmt = mysql_simple_prepare ( mysql , "INSERT INTO t1 (year, month, day) " "VALUES (?, ?, ?)" ) ;\n<64> my_process_warnings ( mysql , 6 ) ;\n<69> stmt_text = "drop table t1" ;\n<70> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<72> stmt_text = "create table t1 (day_ovfl time, day time, hour time, min time, sec time)" ;\n<73> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<75> stmt = mysql_simple_prepare ( mysql , "INSERT INTO t1 VALUES (?, ?, ?, ?, ?)" ) ;\n<99> my_process_warnings ( mysql , 2 ) ;\n<106> stmt_text = "drop table t1" ;\n<107> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static const char * cmd_hash_key ( cmd_parms * cmd , void * _dcfg , const char * _p1 , const char * _p2 ) {\n<4> if ( dcfg == NULL ) return NULL ;\n<6> if ( strcasecmp ( _p1 , "Rand" ) == 0 ) {\n<8> dcfg -> crypto_key = p1 ;\n<9> dcfg -> crypto_key_len = strlen ( dcfg -> crypto_key ) ;\n<12> p1 = apr_pstrdup ( cmd -> pool , _p1 ) ;\n<14> dcfg -> crypto_key_len = strlen ( p1 ) ;
<1> int main ( int argc , char * argv [ ] ) {\n<46> printf ( "Using %s\n" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n<53> i < kNumEncoders ;\n<56> if ( res != VPX_CODEC_OK ) {\n<57> printf ( "Failed to get config: %s\n" , vpx_codec_err_to_string ( res ) ) ;\n<141> while ( ( pkt [ i ] = vpx_codec_get_cx_data ( & codec [ i ] , & iter [ i ] ) ) ) {\n<158> printf ( pkt [ i ] -> kind == VPX_CODEC_CX_FRAME_PKT && ( pkt [ i ] -> data . frame . flags & VPX_FRAME_IS_KEY ) ? "K" : "." ) ;\n<164> printf ( "\n" ) ;\n<166> printf ( "Processed %d frames.\n" , frame_cnt - 1 ) ;\n<168> i < kNumEncoders ;\n<169> ++ i ) {\n<170> if ( show_psnr && psnr_count [ i ] > 0 ) {\n<172> double ovpsnr = sse_to_psnr ( psnr_samples_total [ i ] , 255.0 , psnr_sse_total [ i ] ) ;\n<173> fprintf ( stderr , "\n ENC%d PSNR (Overall/Avg/Y/U/V)" , i ) ;\n<174> fprintf ( stderr , " %.3lf" , ovpsnr ) ;\n<176> j < 4 ;\n<177> j ++ ) fprintf ( stderr , " %.3lf" , psnr_totals [ i ] [ j ] / psnr_count [ i ] ) ;\n<183> printf ( "\n" ) ;
<1> static int evdns_server_request_format_response ( struct server_request * req , int err ) {\n<21> i < req -> base . nquestions ;\n<23> const char * s = req -> base . questions [ i ] -> name ;\n<24> j = dnsname_to_labels ( buf , buf_len , j , s , strlen ( s ) , & table ) ;\n<36> if ( i == 0 ) item = req -> answer ;\n<37> else if ( i == 1 ) item = req -> authority ;\n<38> else item = req -> additional ;\n<39> while ( item ) {\n<40> r = dnsname_to_labels ( buf , buf_len , j , item -> name , strlen ( item -> name ) , & table ) ;\n<42> j = r ;\n<46> if ( item -> is_name ) {\n<47> off_t len_idx = j , name_start ;\n<50> r = dnsname_to_labels ( buf , buf_len , j , item -> data , strlen ( item -> data ) , & table ) ;\n<51> if ( r < 0 ) goto overflow ;\n<53> _t = htons ( ( short ) ( j - name_start ) ) ;\n<54> memcpy ( buf + len_idx , & _t , 2 ) ;\n<57> APPEND16 ( item -> datalen ) ;\n<58> if ( j + item -> datalen > ( off_t ) buf_len ) goto overflow ;\n<59> memcpy ( buf + j , item -> data , item -> datalen ) ;\n<60> j += item -> datalen ;\n<62> item = item -> next ;\n<67> buf [ 2 ] |= 0x02 ;\n<69> req -> response_len = j ;\n<70> if ( ! ( req -> response = malloc ( req -> response_len ) ) ) {\n<71> server_request_free_answers ( req ) ;\n<72> dnslabel_clear ( & table ) ;\n<73> return ( - 1 ) ;\n<75> memcpy ( req -> response , buf , req -> response_len ) ;\n<76> server_request_free_answers ( req ) ;\n<77> dnslabel_clear ( & table ) ;\n<78> return ( 0 ) ;
<1> static void AssignNotdefNull ( SplineFont * sf , int * bygid , int iscff ) {\n<5> ++ i ) if ( sf -> glyphs [ i ] != NULL ) {\n<6> if ( bygid [ 0 ] == - 1 && strcmp ( sf -> glyphs [ i ] -> name , ".notdef" ) == 0 ) {\n<7> sf -> glyphs [ i ] -> ttf_glyph = 0 ;\n<8> bygid [ 0 ] = i ;\n<10> else if ( ! iscff && bygid [ 1 ] == - 1 && ( strcmp ( sf -> glyphs [ i ] -> name , ".null" ) == 0 || strcmp ( sf -> glyphs [ i ] -> name , "uni0000" ) == 0 || ( i == 1 && strcmp ( sf -> glyphs [ 1 ] -> name , "glyph1" ) == 0 ) ) ) {\n<11> sf -> glyphs [ i ] -> ttf_glyph = 1 ;\n<12> bygid [ 1 ] = i ;\n<14> else if ( ! iscff && bygid [ 2 ] == - 1 && ( strcmp ( sf -> glyphs [ i ] -> name , "nonmarkingreturn" ) == 0 || strcmp ( sf -> glyphs [ i ] -> name , "uni000D" ) == 0 || ( i == 2 && strcmp ( sf -> glyphs [ 2 ] -> name , "glyph2" ) == 0 ) ) ) {\n<15> sf -> glyphs [ i ] -> ttf_glyph = 2 ;\n<16> bygid [ 2 ] = i ;
<1> static int ra288_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<18> out = ( float * ) frame -> data [ 0 ] ;\n<21> i < RA288_BLOCKS_PER_FRAME ;\n<26> memcpy ( out , & ractx -> sp_hist [ 70 + 36 ] , RA288_BLOCK_SIZE * sizeof ( * out ) ) ;\n<27> out += RA288_BLOCK_SIZE ;\n<29> backward_filter ( ractx , ractx -> sp_hist , ractx -> sp_rec , syn_window , ractx -> sp_lpc , syn_bw_tab , 36 , 40 , 35 , 70 ) ;
<1> static CharDriverState *qmp_chardev_open_socket(const char *id,\n<81> chr->filename = SocketAddress_to_str("disconnected:",\n<105> socket_try_connect(chr);\n<107> } else if (!qemu_chr_open_socket_fd(chr, errp)) {\n<119> if (is_listen && is_waitconnect) {\n<121> fprintf(stderr, "QEMU waiting for connection on: %s\n",\n<125> tcp_chr_accept(QIO_CHANNEL(s->listen_ioc), G_IO_IN, chr);\n<133> return chr;
<1> static int cow_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<29> if (bs->backing_hd) {\n<41> memset(buf, 0, n * 512);\n<51> buf += n * 512;
<1> static int g723_1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<2> G723_1_Context * p = avctx -> priv_data ;\n<6> int dec_mode = buf [ 0 ] & 3 ;\n<19> if ( unpack_bitstream ( p , buf , buf_size ) < 0 ) {\n<25> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<30> if ( p -> cur_frame_type == ACTIVE_FRAME ) {\n<34> lsp_interpolate ( lpc , cur_lsp , p -> prev_lsp ) ;\n<35> memcpy ( p -> prev_lsp , cur_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n<36> memcpy ( p -> excitation , p -> prev_excitation , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<37> if ( ! p -> erased_frames ) {\n<38> int16_t * vector_ptr = p -> excitation + PITCH_MAX ;\n<44> gen_acb_excitation ( acb_vector , & p -> excitation [ SUBFRAME_LEN * i ] , p -> pitch_lag [ i >> 1 ] , & p -> subframe [ i ] , p -> cur_rate ) ;\n<53> vector_ptr = p -> excitation + PITCH_MAX ;\n<54> p -> interp_index = comp_interp_index ( p , p -> pitch_lag [ 1 ] , & p -> sid_gain , & p -> cur_gain ) ;\n<59> i += SUBFRAME_LEN , j ++ ) comp_ppf_coeff ( p , i , p -> pitch_lag [ j >> 1 ] , ppf + j , p -> cur_rate ) ;\n<67> memcpy ( p -> prev_excitation , p -> excitation + FRAME_LEN , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<71> if ( p -> erased_frames == 3 ) {\n<72> memset ( p -> excitation , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * p -> excitation ) ) ;\n<73> memset ( p -> prev_excitation , 0 , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<74> memset ( frame -> data [ 0 ] , 0 , ( FRAME_LEN + LPC_ORDER ) * sizeof ( int16_t ) ) ;\n<78> residual_interp ( p -> excitation , buf , p -> interp_index , p -> interp_gain , & p -> random_seed ) ;\n<79> memcpy ( p -> prev_excitation , buf + ( FRAME_LEN - PITCH_MAX ) , PITCH_MAX * sizeof ( * p -> excitation ) ) ;\n<94> generate_noise ( p ) ;\n<95> lsp_interpolate ( lpc , p -> sid_lsp , p -> prev_lsp ) ;\n<96> memcpy ( p -> prev_lsp , p -> sid_lsp , LPC_ORDER * sizeof ( * p -> prev_lsp ) ) ;\n<99> memcpy ( p -> audio , p -> synth_mem , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n<102> i += SUBFRAME_LEN , j ++ ) ff_celp_lp_synthesis_filter ( p -> audio + i , & lpc [ j * LPC_ORDER ] , audio + i , SUBFRAME_LEN , LPC_ORDER , 0 , 1 , 1 << 12 ) ;\n<103> memcpy ( p -> synth_mem , p -> audio + FRAME_LEN , LPC_ORDER * sizeof ( * p -> audio ) ) ;\n<105> formant_postfilter ( p , lpc , p -> audio , out ) ;
<1> static int blk_send_response_one(struct ioreq *ioreq)\n<17> resp.id        = ioreq->req.id;\n<19> resp.operation = ioreq->req.operation;\n<21> resp.status    = ioreq->status;\n<31> dst = RING_GET_RESPONSE(&blkdev->rings.native, blkdev->rings.native.rsp_prod_pvt);\n<37> dst = RING_GET_RESPONSE(&blkdev->rings.x86_32_part,\n<45> dst = RING_GET_RESPONSE(&blkdev->rings.x86_64_part,\n<53> dst = NULL;\n<58> memcpy(dst, &resp, sizeof(resp));
<1> static void xmessage_fork ( struct proclistlist * pll ) {\n<2> char message [ 5000 ] ;\n<5> if ( ! xmessage_found ) sprintf ( message , "xmessage \"WARNING! das_watchdog pauses realtime operations for %d seconds.\"" , waittime ) ;\n<6> else sprintf ( message , "%s \"WARNING! das_watchdog pauses realtime operations for %d seconds.\"" , WHICH_XMESSAGE , waittime ) ;\n<7> if ( send_xmessage_using_uids ( pll , message ) == 0 ) {
<1> void create_script_for_old_cluster_deletion ( char * * deletion_script_file_name ) {\n<32> if ( ( script = fopen_priv ( * deletion_script_file_name , "w" ) ) == NULL ) pg_fatal ( "Could not open file \"%s\": %s\n" , * deletion_script_file_name , getErrorText ( ) ) ;\n<36> tblnum < os_info . num_old_tablespaces ;\n<38> if ( strlen ( old_cluster . tablespace_suffix ) == 0 ) {\n<40> fprintf ( script , "\n" ) ;\n<47> char * suffix_path = pg_strdup ( old_cluster . tablespace_suffix ) ;\n<49> pfree ( suffix_path ) ;\n<52> fclose ( script ) ;
<1> static int dynticks_start_timer(struct qemu_alarm_timer *t)\n<38> if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n<46> fprintf(stderr, "Dynamic Ticks disabled\n");
<1> static int mss1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> MSS12Context * c = & ctx -> ctx ;\n<22> pal_changed = decode_pal ( c , & acoder ) ;\n<32> if ( c -> corrupted ) return AVERROR_INVALIDDATA ;\n<33> memcpy ( ctx -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;
<1> void cvt_unix_to_1904 ( long long time , int32 result [ 2 ] ) {\n<9> memset ( date1970 , 0 , sizeof ( date1970 ) ) ;\n<15> date1970 [ 0 ] += year [ 0 ] ;\n<16> date1970 [ 1 ] += year [ 1 ] ;\n<17> if ( ( i & 3 ) == 0 && ( i % 100 != 0 || i % 400 == 0 ) ) date1970 [ 0 ] += 24 * 60 * 60L ;\n<18> date1970 [ 1 ] += ( date1970 [ 0 ] >> 16 ) ;\n<19> date1970 [ 0 ] &= 0xffff ;\n<20> date1970 [ 2 ] += date1970 [ 1 ] >> 16 ;\n<21> date1970 [ 1 ] &= 0xffff ;\n<22> date1970 [ 3 ] += date1970 [ 2 ] >> 16 ;\n<23> date1970 [ 2 ] &= 0xffff ;\n<28> tm [ i ] += date1970 [ i ] ;\n<32> tm [ 3 ] -= date1970 [ 3 ] ;
<1> static int mp3_read_packet(AVFormatContext *s, AVPacket *pkt)\n<34> if (ret > ID3v1_TAG_SIZE &&\n<36> memcmp(&pkt->data[ret - ID3v1_TAG_SIZE], "TAG", 3) == 0)
<1> static int evhttp_add_header_internal ( struct evkeyvalq * headers , const char * key , const char * value ) {\n<2> struct evkeyval * header = calloc ( 1 , sizeof ( struct evkeyval ) ) ;\n<3> if ( header == NULL ) {\n<4> event_warn ( "%s: calloc" , __func__ ) ;\n<7> if ( ( header -> key = strdup ( key ) ) == NULL ) {\n<8> free ( header ) ;\n<9> event_warn ( "%s: strdup" , __func__ ) ;\n<10> return ( - 1 ) ;\n<12> if ( ( header -> value = strdup ( value ) ) == NULL ) {\n<13> free ( header -> key ) ;\n<14> free ( header ) ;\n<15> event_warn ( "%s: strdup" , __func__ ) ;\n<16> return ( - 1 ) ;\n<18> TAILQ_INSERT_TAIL ( headers , header , next ) ;\n<19> return ( 0 ) ;
<1> static unsigned int _warc_rdtyp ( const char * buf , size_t bsz ) {\n<11> while ( val < eol && ( * val == ' ' || * val == '\t' ) ) ++ val ;\n<12> if ( val + 8U == eol ) {\n<13> if ( memcmp ( val , "resource" , 8U ) == 0 ) return WT_RSRC ;\n<14> else if ( memcmp ( val , "response" , 8U ) == 0 ) return WT_RSP ;\n<16> return WT_NONE ;
<1> static int vdi_check(BlockDriverState *bs)\n<21> bmap = qemu_malloc(s->header.blocks_in_image * sizeof(uint32_t));\n<23> memset(bmap, 0xff, s->header.blocks_in_image * sizeof(uint32_t));\n<39> if (bmap[bmap_entry] == VDI_UNALLOCATED) {\n<79> qemu_free(bmap);
<1> int ff_MPV_common_frame_size_change ( MpegEncContext * s ) {\n<3> if ( s -> slice_context_count > 1 ) {\n<10> i < s -> slice_context_count ;\n<12> av_freep ( & s -> thread_context [ i ] ) ;\n<22> s -> last_picture_ptr = s -> next_picture_ptr = s -> current_picture_ptr = NULL ;\n<23> if ( s -> codec_id == AV_CODEC_ID_MPEG2VIDEO && ! s -> progressive_sequence ) s -> mb_height = ( s -> height + 31 ) / 32 * 2 ;\n<24> else if ( s -> codec_id != AV_CODEC_ID_H264 ) s -> mb_height = ( s -> height + 15 ) / 16 ;\n<25> if ( ( s -> width || s -> height ) && av_image_check_size ( s -> width , s -> height , 0 , s -> avctx ) ) return AVERROR_INVALIDDATA ;\n<26> if ( ( err = init_context_frame ( s ) ) ) goto fail ;\n<28> if ( s -> width && s -> height ) {\n<32> i < nb_slices ;\n<34> s -> thread_context [ i ] = av_malloc ( sizeof ( MpegEncContext ) ) ;\n<35> memcpy ( s -> thread_context [ i ] , s , sizeof ( MpegEncContext ) ) ;\n<40> if ( init_duplicate_context ( s -> thread_context [ i ] ) < 0 ) goto fail ;\n<41> s -> thread_context [ i ] -> start_mb_y = ( s -> mb_height * ( i ) + nb_slices / 2 ) / nb_slices ;\n<42> s -> thread_context [ i ] -> end_mb_y = ( s -> mb_height * ( i + 1 ) + nb_slices / 2 ) / nb_slices ;\n<53> fail : ff_MPV_common_end ( s ) ;
<1> static int vqf_probe(AVProbeData *probe_packet)\n<3> if (AV_RL32(probe_packet->buf) != MKTAG('T','W','I','N'))\n<5> if (!memcmp(probe_packet->buf + 4, "97012000", 8))\n<6> return AVPROBE_SCORE_MAX;\n<7> if (!memcmp(probe_packet->buf + 4, "00052200", 8))\n<8> return AVPROBE_SCORE_MAX;\n<9> return AVPROBE_SCORE_EXTENSION;
<1> static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,\n<3> SingleChannelElement *sce,\n<49> if (!qcnt) {\n<51> memset(sce->sf_idx, 0, sizeof(sce->sf_idx));\n<53> memset(sce->zeroes, 1, sizeof(sce->zeroes));
<1> void run_query ( struct st_connection * cn , struct st_command * command , int flags ) {\n<17> if ( command -> type == Q_EVAL || command -> type == Q_SEND_EVAL ) {\n<25> query = command -> query ;\n<26> query_len = strlen ( query ) ;\n<34> replace_dynstr_append_mem ( ds , query , query_len ) ;\n<41> if ( view_protocol_enabled && complete_query && match_re ( & view_re , query ) ) {\n<43> init_dynamic_string ( & query_str , "CREATE OR REPLACE VIEW mysqltest_tmp_v AS " , query_len + 64 , 256 ) ;\n<44> dynstr_append_mem ( & query_str , query , query_len ) ;\n<45> if ( util_query ( mysql , query_str . str ) ) {\n<51> query = ( char * ) "SELECT * FROM mysqltest_tmp_v" ;\n<52> query_len = strlen ( query ) ;\n<57> if ( sp_protocol_enabled && complete_query && match_re ( & sp_re , query ) ) {\n<63> dynstr_append_mem ( & query_str , query , query_len ) ;\n<64> if ( util_query ( mysql , query_str . str ) ) {\n<70> query = ( char * ) "CALL mysqltest_tmp_sp()" ;\n<71> query_len = strlen ( query ) ;\n<80> if ( ps_protocol_enabled && complete_query && match_re ( & ps_re , query ) ) run_query_stmt ( cn , command , query , query_len , ds , & ds_warnings ) ;\n<81> else run_query_normal ( cn , command , flags , query , query_len , ds , & ds_warnings ) ;
<1> uint32 get_major_server_version ( ClusterInfo * cluster ) {\n<4> int integer_version = 0 ;\n<5> int fractional_version = 0 ;\n<7> if ( ( version_fd = fopen ( ver_filename , "r" ) ) == NULL ) pg_fatal ( "could not open version file: %s\n" , ver_filename ) ;\n<8> if ( fscanf ( version_fd , "%63s" , cluster -> major_version_str ) == 0 || sscanf ( cluster -> major_version_str , "%d.%d" , & integer_version , & fractional_version ) != 2 ) pg_fatal ( "could not get version from %s\n" , cluster -> pgdata ) ;\n<9> fclose ( version_fd ) ;\n<10> return ( 100 * integer_version + fractional_version ) * 100 ;
<1> static int matroska_aac_profile ( char * codec_id ) {\n<7> profile < FF_ARRAY_ELEMS ( aac_profiles ) ;\n<8> profile ++ ) if ( strstr ( codec_id , aac_profiles [ profile ] ) ) break ;
<1> g_malloc0(size_t n_bytes)\n<9> mem = calloc(1, n_bytes == 0 ? 1 : n_bytes);\n<11> if (!mem) __coverity_panic__();
<1> static int xiph_parse_sdp_line(AVFormatContext *s, int st_index,\n<3> PayloadContext *data, const char *line)\n<13> int value_size = strlen(line), attr_size = sizeof(attr), res = 0;\n<25> if (!(value = av_malloc(value_size))) {\n<35> if (av_strstart(line, "fmtp:", &p)) {
<1> int avpriv_adx_decode_header(AVCodecContext *avctx, const uint8_t *buf,\n<17> if (AV_RB16(buf) != 0x8000)\n<27> if (bufsize >= offset && memcmp(buf + offset - 6, "(c)CRI", 6))\n<29> return AVERROR_INVALIDDATA;\n<35> if (buf[4] != 3 || buf[5] != 18 || buf[6] != 4) {
<79> if (oldpic->data[1])\n<81> memcpy(newpic->data[1], oldpic->data[1], 256 * 4);
<1> static int capture_android_bluetooth_hcidump ( char * interface , char * fifo , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n<3> static char data [ PACKET_LENGTH ] ;\n<7> gssize used_buffer_length = 0 ;\n<24> int ms = 0 ;\n<32> if ( is_specified_interface ( interface , INTERFACE_ANDROID_BLUETOOTH_HCIDUMP ) && strlen ( interface ) > strlen ( INTERFACE_ANDROID_BLUETOOTH_HCIDUMP ) + 1 ) {\n<33> serial_number = interface + strlen ( INTERFACE_ANDROID_BLUETOOTH_HCIDUMP ) + 1 ;\n<34> serial_number_length = strlen ( serial_number ) ;\n<36> if ( ! serial_number ) {\n<45> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<58> result = adb_send ( sock , adb_shell_hcidump ) ;\n<64> while ( endless_loop ) {\n<67> length = recv ( sock , data + used_buffer_length , ( int ) ( PACKET_LENGTH - used_buffer_length ) , 0 ) ;\n<71> else if ( errno != 0 ) {\n<72> errmsg_print ( "ERROR capture: %s" , strerror ( errno ) ) ;\n<73> closesocket ( sock ) ;\n<76> if ( length <= 0 ) {\n<78> closesocket ( sock ) ;\n<81> used_buffer_length += length ;\n<82> i_position = ( char * ) memchr ( data , '\n' , used_buffer_length ) ;\n<83> if ( i_position && i_position < data + used_buffer_length ) {\n<85> if ( ! strncmp ( data , "/system/bin/sh: hcidump: not found" , 34 ) ) {\n<87> closesocket ( sock ) ;\n<90> i_position = ( char * ) memchr ( i_position + 1 , '\n' , used_buffer_length ) ;\n<92> i_position += 1 ;\n<93> if ( ! strncmp ( state_line_position , "Can't access device: Permission denied" , 38 ) ) {\n<95> used_buffer_length = 0 ;\n<99> memmove ( data , i_position , used_buffer_length - ( i_position - data ) ) ;\n<100> used_buffer_length = used_buffer_length - ( gssize ) ( i_position - data ) ;\n<108> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<120> result = adb_send ( sock , adb_shell_su_hcidump ) ;\n<126> used_buffer_length = 0 ;\n<127> while ( endless_loop ) {\n<130> length = recv ( sock , data + used_buffer_length , ( int ) ( PACKET_LENGTH - used_buffer_length ) , 0 ) ;\n<134> else if ( errno != 0 ) {\n<135> errmsg_print ( "ERROR capture: %s" , strerror ( errno ) ) ;\n<136> closesocket ( sock ) ;\n<139> if ( length <= 0 ) {\n<141> closesocket ( sock ) ;\n<144> used_buffer_length += length ;\n<145> i_position = ( char * ) memchr ( data , '\n' , used_buffer_length ) ;\n<146> if ( i_position && i_position < data + used_buffer_length ) {\n<147> if ( ! strncmp ( data , "/system/bin/sh: su: not found" , 29 ) ) {\n<149> closesocket ( sock ) ;\n<152> i_position = ( char * ) memchr ( i_position + 1 , '\n' , used_buffer_length ) ;\n<153> if ( i_position ) {\n<154> i_position += 1 ;\n<155> memmove ( data , i_position , used_buffer_length - ( i_position - data ) ) ;\n<156> used_buffer_length = used_buffer_length - ( gssize ) ( i_position - data ) ;\n<162> while ( endless_loop ) {\n<164> length = recv ( sock , data + used_buffer_length , ( int ) ( PACKET_LENGTH - used_buffer_length ) , 0 ) ;\n<168> else if ( errno != 0 ) {\n<169> errmsg_print ( "ERROR capture: %s" , strerror ( errno ) ) ;\n<170> closesocket ( sock ) ;\n<173> if ( length <= 0 ) {\n<175> closesocket ( sock ) ;\n<180> hex_data = data + 29 ;\n<186> if ( hex < 0 || hex >= 256 || hex_data == new_hex_data ) {\n<187> errmsg_print ( "ERROR: data format error: %s" , strerror ( errno ) ) ;\n<188> closesocket ( sock ) ;\n<193> if ( hex < 0 || hex >= 256 || hex_data == new_hex_data ) {\n<194> errmsg_print ( "ERROR: data format error: %s" , strerror ( errno ) ) ;\n<195> closesocket ( sock ) ;\n<205> if ( hex < 0 || hex >= 256 || hex_data == new_hex_data ) {\n<206> errmsg_print ( "ERROR: data format error: %s" , strerror ( errno ) ) ;\n<207> closesocket ( sock ) ;\n<217> if ( hex < 0 || hex >= 256 || hex_data == new_hex_data ) {\n<218> errmsg_print ( "ERROR: data format error: %s" , strerror ( errno ) ) ;\n<219> closesocket ( sock ) ;\n<224> if ( hex < 0 || hex >= 256 || hex_data == new_hex_data ) {\n<225> errmsg_print ( "ERROR: data format error: %s" , strerror ( errno ) ) ;\n<226> closesocket ( sock ) ;\n<239> closesocket ( sock ) ;\n<244> used_buffer_length += length ;\n<248> if ( used_buffer_length + length < frame_length ) {\n<249> used_buffer_length += length ;\n<252> if ( 8 == sscanf ( data , "%04d-%02d-%02d %02d:%02d:%02d.%06d %c" , & date . tm_year , & date . tm_mon , & date . tm_mday , & date . tm_hour , & date . tm_min , & date . tm_sec , & ms , & direction_character ) ) {\n<253> verbose_print ( "time %04d-%02d-%02d %02d:%02d:%02d.%06d %c\n" , date . tm_year , date . tm_mon , date . tm_mday , date . tm_hour , date . tm_min , date . tm_sec , ms , direction_character ) ;\n<254> date . tm_mon -= 1 ;\n<255> date . tm_year -= 1900 ;\n<256> ts = mktime ( & date ) ;\n<257> new_hex_data = data + 29 ;\n<260> while ( ( long ) ( new_hex_data - data + sizeof ( own_pcap_bluetooth_h4_header ) ) < frame_length ) {\n<266> h4_header -> direction = GINT32_TO_BE ( direction_character == '>' ) ;\n<267> endless_loop = extcap_dumper_dump ( extcap_dumper , packet , captured_length + sizeof ( own_pcap_bluetooth_h4_header ) , captured_length + sizeof ( own_pcap_bluetooth_h4_header ) , ts , ms * 1000 ) ;\n<268> if ( used_buffer_length + length >= frame_length ) {\n<269> memmove ( data , data + frame_length , ( size_t ) ( used_buffer_length + length - frame_length ) ) ;\n<270> used_buffer_length = ( gssize ) ( used_buffer_length + length - frame_length ) ;\n<277> closesocket ( sock ) ;
<1> static void lan9118_eeprom_cmd(lan9118_state *s, int cmd, int addr)\n<34> s->eeprom[addr] &= s->e2p_data;\n<51> s->eeprom[addr] &= s->e2p_data;\n<68> s->eeprom[addr] = 0xff;\n<81> if (s->eeprom_writable) {\n<83> memset(s->eeprom, 0xff, 128);\n<96> lan9118_reload_eeprom(s);
<23> ti->class = g_malloc0(ti->class_size);\n<27> parent = type_get_parent(ti);\n<29> if (parent) {\n<31> type_initialize(parent);\n<39> g_assert(parent->class_size <= ti->class_size);\n<41> memcpy(ti->class, parent->class, parent->class_size);\n<51> type_initialize_interface(ti, object_class_get_name(iface));\n<85> type_initialize_interface(ti, ti->interfaces[i].typename);\n<93> ti->class->type = ti;\n<101> parent->class_base_init(ti->class, ti->class_data);\n<105> parent = type_get_parent(parent);\n<113> ti->class_init(ti->class, ti->class_data);
<1> static struct passwd * check_user ( const char * user ) {\n<11> if ( ! user ) {\n<18> if ( ! strcmp ( user , "root" ) ) return NULL ;\n<19> if ( ! ( tmp_user_info = getpwnam ( user ) ) ) {\n<27> return tmp_user_info ;
<1> int evdns_clear_nameservers_and_suspend ( void ) {\n<4> if ( ! server ) return 0 ;\n<7> ( void ) event_del ( & server -> event ) ;\n<8> if ( evtimer_initialized ( & server -> timeout_event ) ) ( void ) evtimer_del ( & server -> timeout_event ) ;\n<9> if ( server -> socket >= 0 ) CLOSE_SOCKET ( server -> socket ) ;\n<10> free ( server ) ;\n<11> if ( next == started_at ) break ;\n<12> server = next ;
<1> void pcnet_common_init ( DeviceState * dev , PCNetState * s , NetClientInfo * info ) {\n<6> s -> nic = qemu_new_nic ( info , & s -> conf , object_get_typename ( OBJECT ( dev ) ) , dev -> id , s ) ;\n<7> qemu_format_nic_info_str ( qemu_get_queue ( s -> nic ) , s -> conf . macaddr . a ) ;\n<8> memcpy ( s -> prom , s -> conf . macaddr . a , 6 ) ;\n<20> * ( uint16_t * ) & s -> prom [ 12 ] = cpu_to_le16 ( checksum ) ;
<1> static void sbr_hf_assemble(int Y1[38][64][2],\n<43> for (i = 0; i < h_SL; i++) {\n<45> memcpy(g_temp[i + 2*ch_data->t_env[0]], sbr->gain[0], m_max * sizeof(sbr->gain[0][0]));\n<47> memcpy(q_temp[i + 2*ch_data->t_env[0]], sbr->q_m[0],  m_max * sizeof(sbr->q_m[0][0]));\n<53> for (i = 0; i < 4; i++) {\n<75> for (i = 2 * ch_data->t_env[e]; i < 2 * ch_data->t_env[e + 1]; i++) {\n<77> memcpy(g_temp[h_SL + i], sbr->gain[e], m_max * sizeof(sbr->gain[0][0]));\n<79> memcpy(q_temp[h_SL + i], sbr->q_m[e],  m_max * sizeof(sbr->q_m[0][0]));
<1> static int tm2_decode_blocks ( TM2Context * ctx , AVFrame * p ) {\n<11> if ( ctx -> tok_lens [ TM2_TYPE ] < bw * bh ) {\n<15> memset ( ctx -> last , 0 , 4 * bw * sizeof ( int ) ) ;\n<16> memset ( ctx -> clast , 0 , 4 * bw * sizeof ( int ) ) ;\n<18> j < bh ;\n<20> memset ( ctx -> D , 0 , 4 * sizeof ( int ) ) ;\n<21> memset ( ctx -> CD , 0 , 4 * sizeof ( int ) ) ;\n<25> type = GET_TOK ( ctx , TM2_TYPE ) ;\n<27> case TM2_HI_RES : tm2_hi_res_block ( ctx , p , i , j ) ;\n<29> case TM2_MED_RES : tm2_med_res_block ( ctx , p , i , j ) ;\n<31> case TM2_LOW_RES : tm2_low_res_block ( ctx , p , i , j ) ;\n<33> case TM2_NULL_RES : tm2_null_res_block ( ctx , p , i , j ) ;\n<35> case TM2_UPDATE : tm2_update_block ( ctx , p , i , j ) ;\n<38> case TM2_STILL : tm2_still_block ( ctx , p , i , j ) ;\n<41> case TM2_MOTION : tm2_motion_block ( ctx , p , i , j ) ;\n<65> if ( j == 0 ) {\n<66> memcpy ( Y - 4 - 1 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n<67> memcpy ( Y - 4 - 2 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n<68> memcpy ( Y - 4 - 3 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n<69> memcpy ( Y - 4 - 4 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n<71> else if ( j == h - 1 ) {\n<72> memcpy ( Y - 4 + 1 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n<73> memcpy ( Y - 4 + 2 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n<74> memcpy ( Y - 4 + 3 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n<75> memcpy ( Y - 4 + 4 * ctx -> y_stride , Y - 4 , ctx -> y_stride ) ;\n<77> Y += ctx -> y_stride ;\n<83> if ( j == 1 ) {\n<84> memcpy ( U - 2 - 1 * ctx -> uv_stride , U - 2 , ctx -> uv_stride ) ;\n<85> memcpy ( V - 2 - 1 * ctx -> uv_stride , V - 2 , ctx -> uv_stride ) ;\n<86> memcpy ( U - 2 - 2 * ctx -> uv_stride , U - 2 , ctx -> uv_stride ) ;\n<87> memcpy ( V - 2 - 2 * ctx -> uv_stride , V - 2 , ctx -> uv_stride ) ;\n<89> else if ( j == h - 1 ) {\n<90> memcpy ( U - 2 + 1 * ctx -> uv_stride , U - 2 , ctx -> uv_stride ) ;\n<91> memcpy ( V - 2 + 1 * ctx -> uv_stride , V - 2 , ctx -> uv_stride ) ;\n<92> memcpy ( U - 2 + 2 * ctx -> uv_stride , U - 2 , ctx -> uv_stride ) ;\n<93> memcpy ( V - 2 + 2 * ctx -> uv_stride , V - 2 , ctx -> uv_stride ) ;\n<95> U += ctx -> uv_stride ;\n<96> V += ctx -> uv_stride ;
<1> int cpu_ppc_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n<47> } else if (ret < 0) {\n<363> switch (access_type) {\n<419> printf("DSI: invalid exception (%d)\n", ret);
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<131> if (ret < 0) {\n<151> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> void write_stats ( void ) {\n<26> if ( ( fp = fopen ( stats_temp_file , "w" ) ) == NULL ) {\n<30> fprintf ( fp , "%.3f\n" , drift_comp * 1e6 ) ;\n<31> ( void ) fclose ( fp ) ;
<1> char * evbuffer_readln ( struct evbuffer * buffer , size_t * n_read_out , enum evbuffer_eol_style eol_style ) {\n<2> u_char * data = EVBUFFER_DATA ( buffer ) ;\n<4> size_t len = EVBUFFER_LENGTH ( buffer ) ;\n<8> switch ( eol_style ) {\n<12> if ( data [ i ] == '\r' || data [ i ] == '\n' ) break ;\n<14> if ( i == len ) return ( NULL ) ;\n<20> if ( data [ i ] != '\r' && data [ i ] != '\n' ) break ;\n<24> case EVBUFFER_EOL_CRLF : end_of_eol = memchr ( data , '\n' , len ) ;\n<25> if ( ! end_of_eol ) return ( NULL ) ;\n<26> if ( end_of_eol > data && * ( end_of_eol - 1 ) == '\r' ) start_of_eol = end_of_eol - 1 ;\n<32> while ( ( cp = memchr ( cp , '\r' , len - ( cp - data ) ) ) ) {\n<33> if ( cp < data + len - 1 && * ( cp + 1 ) == '\n' ) break ;\n<34> if ( ++ cp >= data + len ) {\n<39> if ( ! cp ) return ( NULL ) ;\n<44> case EVBUFFER_EOL_LF : start_of_eol = memchr ( data , '\n' , len ) ;\n<45> if ( ! start_of_eol ) return ( NULL ) ;\n<50> n_to_copy = start_of_eol - data ;\n<51> n_to_drain = end_of_eol - data ;\n<52> if ( ( line = malloc ( n_to_copy + 1 ) ) == NULL ) {\n<53> event_warn ( "%s: out of memory\n" , __func__ ) ;\n<54> return ( NULL ) ;\n<56> memcpy ( line , data , n_to_copy ) ;\n<57> line [ n_to_copy ] = '\0' ;\n<58> evbuffer_drain ( buffer , n_to_drain ) ;\n<59> if ( n_read_out ) * n_read_out = ( size_t ) n_to_copy ;\n<60> return ( line ) ;
<1> static bluetooth_uuid_t get_characteristic_uuid_from_handle ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data ) {\n<7> memset ( & uuid , 0 , sizeof uuid ) ;\n<20> if ( handle_data && handle_data -> type == ATTRIBUTE_TYPE_SERVICE ) return uuid ;\n<23> return uuid ;\n<27> return uuid ;
<1> static void unfold_conds ( struct condition * cnd , u_int32 a , u_int32 b ) {\n<5> SAFE_CALLOC ( ue , 1 , sizeof ( struct unfold_elm ) ) ;\n<6> memcpy ( & ue -> fop , & cnd -> fop , sizeof ( struct filter_op ) ) ;\n<7> TAILQ_INSERT_TAIL ( & unfolded_tree , ue , next ) ;\n<8> SAFE_CALLOC ( ue , 1 , sizeof ( struct unfold_elm ) ) ;\n<17> TAILQ_INSERT_TAIL ( & unfolded_tree , ue , next ) ;\n<19> while ( ( cnd = cnd -> next ) ) ;
<1> kadm5_ret_t kadm5_setv4key_principal ( void * server_handle , krb5_principal principal , krb5_keyblock * keyblock ) {\n<13> memset ( & tmp_key_data , 0 , sizeof ( tmp_key_data ) ) ;\n<25> if ( kdb -> key_data == NULL ) return ENOMEM ;\n<26> memset ( kdb -> key_data , 0 , sizeof ( krb5_key_data ) ) ;\n<33> ret = krb5_dbe_encrypt_key_data ( handle -> context , act_mkey , keyblock , & keysalt , kvno + 1 , & tmp_key_data ) ;\n<38> k < tmp_key_data . key_data_ver ;\n<41> kdb -> key_data -> key_data_length [ k ] = tmp_key_data . key_data_length [ k ] ;\n<43> kdb -> key_data -> key_data_contents [ k ] = krb5_db_alloc ( handle -> context , NULL , tmp_key_data . key_data_length [ k ] ) ;\n<44> if ( kdb -> key_data -> key_data_contents [ k ] == NULL ) {\n<45> cleanup_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data ) ;\n<51> memcpy ( kdb -> key_data -> key_data_contents [ k ] , tmp_key_data . key_data_contents [ k ] , tmp_key_data . key_data_length [ k ] ) ;\n<52> memset ( tmp_key_data . key_data_contents [ k ] , 0 , tmp_key_data . key_data_length [ k ] ) ;\n<53> free ( tmp_key_data . key_data_contents [ k ] ) ;\n<54> tmp_key_data . key_data_contents [ k ] = NULL ;\n<76> ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ;\n<79> if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ;\n<82> i < tmp_key_data . key_data_ver ;\n<84> if ( tmp_key_data . key_data_contents [ i ] ) {\n<85> memset ( tmp_key_data . key_data_contents [ i ] , 0 , tmp_key_data . key_data_length [ i ] ) ;\n<86> free ( tmp_key_data . key_data_contents [ i ] ) ;\n<89> kdb_free_entry ( handle , kdb , & adb ) ;
<1> static PK11SymKey * import_symmetric_key ( struct crypto_instance * instance , enum sym_key_type key_type ) {\n<16> memset ( & key_item , 0 , sizeof ( key_item ) ) ;\n<48> if ( wrap_key == NULL ) {\n<52> memset ( & tmp_sec_item , 0 , sizeof ( tmp_sec_item ) ) ;\n<53> wrap_key_crypt_context = PK11_CreateContextBySymKey ( wrap_mechanism , CKA_ENCRYPT , wrap_key , & tmp_sec_item ) ;\n<63> if ( PK11_Finalize ( wrap_key_crypt_context ) != SECSuccess ) {\n<67> memset ( & tmp_sec_item , 0 , sizeof ( tmp_sec_item ) ) ;\n<70> res_key = PK11_UnwrapSymKey ( wrap_key , wrap_mechanism , & tmp_sec_item , & wrapped_key , cipher , operation , key_item . len ) ;
<1> void qmp_block_commit(const char *device,\n<3> bool has_base, const char *base, const char *top,\n<45> base_bs = bdrv_find_backing_image(bs, base);\n<49> base_bs = bdrv_find_base(bs);\n<71> if (top) {\n<73> if (strcmp(bs->filename, top) != 0) {\n<75> top_bs = bdrv_find_backing_image(bs, top);\n<85> error_setg(errp, "Top image file %s not found", top ? top : "NULL");\n<93> commit_start(bs, base_bs, top_bs, speed, on_error, block_job_cb, bs,\n<111> drive_get_ref(drive_get_by_blockdev(bs));
<1> int qemuMonitorTextDeleteSnapshot ( qemuMonitorPtr mon , const char * name ) {\n<3> char * reply = NULL ;\n<10> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) ) {\n<14> if ( strstr ( reply , "No block device supports snapshots" ) != NULL ) {\n<15> qemuReportError ( VIR_ERR_OPERATION_INVALID , "%s" , _ ( "this domain does not have a device to delete snapshots" ) ) ;\n<18> else if ( strstr ( reply , "Snapshots not supported on device" ) != NULL ) {\n<19> qemuReportError ( VIR_ERR_OPERATION_INVALID , "%s" , reply ) ;\n<22> else if ( strstr ( reply , "Error" ) != NULL && strstr ( reply , "while deleting snapshot" ) != NULL ) {\n<23> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , reply ) ;\n<26> ret = 0 ;\n<29> VIR_FREE ( reply ) ;
<1> int main (int argc, char **argv)\n<9> if (argc != 4) {\n<11> fprintf(stderr, "usage: %s input_file video_output_file audio_output_file\n"\n<29> video_dst_filename = argv[2];\n<31> audio_dst_filename = argv[3];\n<43> if (avformat_open_input(&fmt_ctx, src_filename, NULL, NULL) < 0) {\n<45> fprintf(stderr, "Could not open source file %s\n", src_filename);\n<55> if (avformat_find_stream_info(fmt_ctx, NULL) < 0) {\n<57> fprintf(stderr, "Could not find stream information\n");\n<69> video_dec_ctx = video_stream->codec;\n<73> video_dst_file = fopen(video_dst_filename, "wb");\n<75> if (!video_dst_file) {\n<77> fprintf(stderr, "Could not open destination file %s\n", video_dst_filename);\n<89> ret = av_image_alloc(video_dst_data, video_dst_linesize,\n<95> if (ret < 0) {\n<97> fprintf(stderr, "Could not allocate raw video buffer\n");\n<117> audio_dec_ctx = audio_stream->codec;\n<119> audio_dst_file = fopen(audio_dst_filename, "wb");\n<121> if (!audio_dst_file) {\n<123> fprintf(stderr, "Could not open destination file %s\n", video_dst_filename);\n<139> if (!audio_dst_data) {\n<141> fprintf(stderr, "Could not allocate audio data buffers\n");\n<155> av_dump_format(fmt_ctx, 0, src_filename, 0);\n<159> if (!audio_stream && !video_stream) {\n<161> fprintf(stderr, "Could not find audio or video stream in the input, aborting\n");\n<173> if (!frame) {\n<175> fprintf(stderr, "Could not allocate frame\n");\n<195> if (video_stream)\n<197> printf("Demuxing video from file '%s' into '%s'\n", src_filename, video_dst_filename);\n<199> if (audio_stream)\n<201> printf("Demuxing audio from file '%s' into '%s'\n", src_filename, audio_dst_filename);\n<227> printf("Demuxing succeeded.\n");\n<231> if (video_stream) {\n<233> printf("Play the output video file with the command:\n"\n<237> av_get_pix_fmt_name(video_dec_ctx->pix_fmt), video_dec_ctx->width, video_dec_ctx->height,\n<251> if ((ret = get_format_from_sample_fmt(&fmt, audio_dec_ctx->sample_fmt)) < 0)\n<255> printf("Play the output audio file with the command:\n"\n<271> avcodec_close(video_dec_ctx);\n<275> avcodec_close(audio_dec_ctx);
<1> static void test_evbuffer_find ( void ) {\n<3> const char * test1 = "1234567890\r\n" ;\n<4> const char * test2 = "1234567890\r" ;\n<8> fprintf ( stdout , "Testing evbuffer_find 1: " ) ;\n<9> evbuffer_add ( buf , ( u_char * ) test1 , strlen ( test1 ) ) ;\n<10> evbuffer_drain ( buf , strlen ( test1 ) ) ;\n<11> evbuffer_add ( buf , ( u_char * ) test2 , strlen ( test2 ) ) ;\n<12> p = evbuffer_find ( buf , ( u_char * ) "\r\n" , 2 ) ;\n<13> if ( p == NULL ) {\n<14> fprintf ( stdout , "OK\n" ) ;\n<17> fprintf ( stdout , "FAILED\n" ) ;\n<20> fprintf ( stdout , "Testing evbuffer_find 2: " ) ;\n<21> evbuffer_drain ( buf , strlen ( test2 ) ) ;\n<27> p = evbuffer_find ( buf , ( u_char * ) "xy" , 2 ) ;\n<28> if ( p == NULL ) {\n<29> printf ( "OK\n" ) ;\n<32> fprintf ( stdout , "FAILED\n" ) ;\n<35> fprintf ( stdout , "Testing evbuffer_find 3: " ) ;\n<37> if ( p != NULL && strncmp ( ( char * ) p , "ax" , 2 ) == 0 ) {\n<38> printf ( "OK\n" ) ;\n<41> fprintf ( stdout , "FAILED\n" ) ;
<1> REGRESSION_TEST ( SDK_API_DEBUG_NAME_LOOKUPS ) ( RegressionTest * test , int , int * pstatus ) {\n<3> const char state_name [ ] = "INACTIVE_TIMEOUT" ;\n<4> const char hook_name [ ] = "TS_HTTP_READ_RESPONSE_HDR_HOOK" ;\n<5> const char event_name [ ] = "VC_EVENT_IMMEDIATE" ;\n<8> str = TSHttpServerStateNameLookup ( TS_SRVSTATE_INACTIVE_TIMEOUT ) ;\n<9> if ( ( strlen ( str ) != strlen ( state_name ) || strcmp ( str , state_name ) ) ) {\n<10> SDK_RPRINT ( test , "TSHttpServerStateNameLookup" , "TestCase1" , TC_FAIL , "Failed on %d, expected %s, got %s" , TS_SRVSTATE_INACTIVE_TIMEOUT , state_name , str ) ;\n<11> success = false ;\n<14> SDK_RPRINT ( test , "TSHttpServerStateNameLookup" , "TestCase1" , TC_PASS , "ok" ) ;\n<16> str = TSHttpHookNameLookup ( TS_HTTP_READ_RESPONSE_HDR_HOOK ) ;\n<17> if ( ( strlen ( str ) != strlen ( hook_name ) || strcmp ( str , hook_name ) ) ) {\n<18> SDK_RPRINT ( test , "TSHttpHookNameLookup" , "TestCase1" , TC_FAIL , "Failed on %d, expected %s, got %s" , TS_HTTP_READ_RESPONSE_HDR_HOOK , hook_name , str ) ;\n<19> success = false ;\n<22> SDK_RPRINT ( test , "TSHttpHookNameLookup" , "TestCase1" , TC_PASS , "ok" ) ;\n<24> str = TSHttpEventNameLookup ( TS_EVENT_IMMEDIATE ) ;\n<25> if ( ( strlen ( str ) != strlen ( event_name ) || strcmp ( str , event_name ) ) ) {\n<26> SDK_RPRINT ( test , "TSHttpEventNameLookup" , "TestCase1" , TC_FAIL , "Failed on %d, expected %s, got %s" , TS_EVENT_IMMEDIATE , hook_name , str ) ;\n<27> success = false ;\n<30> SDK_RPRINT ( test , "TSHttpEventNameLookup" , "TestCase1" , TC_PASS , "ok" ) ;
<1> static int mov_text_tx3g(AVCodecContext *avctx, MovTextContext *m)\n<163> if (!m->ftab_temp) {\n<175> font_length = *tx3g_ptr++;\n<193> if (!m->ftab_temp->font) {\n<201> memcpy(m->ftab_temp->font, tx3g_ptr, font_length);\n<203> m->ftab_temp->font[font_length] = '\0';\n<205> av_dynarray_add(&m->ftab, &m->count_f, m->ftab_temp);\n<215> tx3g_ptr = tx3g_ptr + font_length;
<1> static int aes_ccm_init_key ( EVP_CIPHER_CTX * ctx , const unsigned char * key , const unsigned char * iv , int enc ) {\n<3> if ( ! iv && ! key ) return 1 ;\n<25> if ( iv ) {\n<26> memcpy ( EVP_CIPHER_CTX_iv_noconst ( ctx ) , iv , 15 - cctx -> L ) ;
<1> static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n<15> uint8_t pal[768], transp[3];\n<25> uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n<42> hdr = *src++;\n<46> if (sub_type == 0) {\n<50> memcpy(transp, src, 3);\n<52> src += 3;\n<54> for (j = 0; j < height; j++, dst += c->framebuf_stride)\n<56> for (i = 0; i < width; i++)\n<58> memcpy(dst + i * 3, transp, 3);\n<62> } else if (sub_type == 1) {\n<72> if (sub_type != 2) {\n<74> memcpy(transp, src, 3);\n<76> src += 3;\n<80> npal = *src++ + 1;\n<84> memcpy(pal, src, npal * 3); src += npal * 3;\n<88> for (i = 0; i < npal; i++) {\n<90> if (!memcmp(pal + i * 3, transp, 3)) {\n<92> tidx = i;\n<126> if (sub_type == 2) {\n<128> kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n<182> memset(c->jpeg_tile, 0, c->tile_stride * height);\n<184> jpg_decode_data(&c->jc, width, height, src, src_end - src,\n<192> kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,
<1> int user_key_allowed ( struct ssh * ssh , struct passwd * pw , struct sshkey * key , int auth_attempt , struct sshauthopt * * authoptsp ) {\n<17> if ( strcasecmp ( options . authorized_keys_files [ i ] , "none" ) == 0 ) continue ;\n<19> success = user_key_allowed2 ( ssh , pw , key , file , & opts ) ;\n<20> free ( file ) ;
<1> int qemu_acl_remove(qemu_acl *acl,\n<3> const char *match)\n<13> QTAILQ_FOREACH(entry, &acl->entries, next) {\n<17> if (strcmp(entry->match, match) == 0) {\n<19> QTAILQ_REMOVE(&acl->entries, entry, next);\n<24> return i;\n<30> return -1;
<1> static void test_bug40365 ( void ) {\n<17> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<21> i < ( int ) array_elements ( my_bind ) ;\n<55> if ( ! opt_silent ) fprintf ( stdout , "\n" ) ;\n<57> i < array_elements ( my_bind ) ;\n<58> i ++ ) {\n<59> if ( ! opt_silent ) fprintf ( stdout , "\ntime[%d]: %02d-%02d-%02d " , i , tm [ i ] . year , tm [ i ] . month , tm [ i ] . day ) ;\n<60> DIE_UNLESS ( tm [ i ] . year == 0 ) ;\n<61> DIE_UNLESS ( tm [ i ] . month == 0 ) ;\n<62> DIE_UNLESS ( tm [ i ] . day == 0 ) ;
<1> static int cgroup_rmdir ( char * dirname ) {\n<12> while ( ! readdir_r ( dir , & dirent , & direntp ) ) {\n<15> if ( ! direntp ) break ;\n<16> if ( ! strcmp ( direntp -> d_name , "." ) || ! strcmp ( direntp -> d_name , ".." ) ) continue ;\n<17> rc = snprintf ( pathname , MAXPATHLEN , "%s/%s" , dirname , direntp -> d_name ) ;\n<18> if ( rc < 0 || rc >= MAXPATHLEN ) {
<1> int evsignal_init ( struct event_base * base ) {\n<13> memset ( & base -> sig . evsigcaught , 0 , sizeof ( sig_atomic_t ) * NSIG ) ;
<1> static int vmdk_snapshot_create(const char *filename, const char *backing_file)\n<101> if (write(snp_fd, hdr, HEADER_SIZE) == -1) {\n<111> memset(&header, 0, sizeof(header));\n<113> memcpy(&header,&hdr[4], sizeof(header)); // skip the VMDK4_MAGIC\n<135> if (read(p_fd, p_desc, DESC_SIZE) != DESC_SIZE) {\n<145> if ((p_name = strstr(p_desc,"CID")) != NULL) {\n<147> p_name += sizeof("CID");\n<149> sscanf(p_name,"%x",&p_cid);\n<157> if ((temp_str = strrchr(real_filename, '\\')) != NULL)\n<171> snprintf(s_desc, sizeof(s_desc), desc_template, p_cid, p_cid, backing_file,\n<179> if (lseek(snp_fd, 0x200, SEEK_SET) == -1) {\n<187> if (write(snp_fd, s_desc, strlen(s_desc)) == -1) {\n<189> ret = -errno;\n<197> gd_offset = header.gd_offset * SECTOR_SIZE;     // offset of GD table\n<199> rgd_offset = header.rgd_offset * SECTOR_SIZE;   // offset of RGD table\n<201> capacity = header.capacity * SECTOR_SIZE;       // Extent size\n<211> gt_size = (int64_t)header.num_gtes_per_gte * header.granularity * SECTOR_SIZE;\n<213> if (!gt_size) {\n<247> if (lseek(snp_fd, rgd_offset, SEEK_SET) == -1) {\n<325> close(p_fd);\n<327> close(snp_fd);\n<329> return ret;
<1> void mips_malta_init(QEMUMachineInitArgs *args)\n<53> if (cpu == NULL) {\n<54> fprintf(stderr, "Unable to find CPU definition\n");\n<66> if (ram_size > (256 << 20)) {\n<69> ((unsigned int)ram_size / (1 << 20)));\n<155> if (!rom_copy(memory_region_get_ram_ptr(bios_copy),\n<157> memcpy(memory_region_get_ram_ptr(bios_copy),\n<158> memory_region_get_ram_ptr(bios), BIOS_SIZE);
<1> static void net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n<37> } else if (tap->has_helper) {\n<45> snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n<53> if (strcmp(downscript, "no") != 0) {\n<55> snprintf(s->down_script, sizeof(s->down_script), "%s", downscript);\n<57> snprintf(s->down_script_arg, sizeof(s->down_script_arg),
<1> static void erase_screen ( AVCodecContext * avctx ) {\n<5> i < avctx -> height ;\n<6> i ++ ) memset ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;
<1> static void test_view_star ( ) {\n<5> char parms [ 8 ] [ 100 ] ;\n<7> const char * query = "SELECT * FROM vt1 WHERE a IN (?,?)" ;\n<17> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<19> i < 2 ;\n<20> i ++ ) {\n<21> sprintf ( ( char * ) & parms [ i ] , "%d" , i ) ;\n<29> stmt = mysql_stmt_init ( mysql ) ;\n<30> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<31> check_execute ( stmt , rc ) ;\n<32> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static void do_audio_out(AVFormatContext *s,\n<7> unsigned char *buf, int size)\n<23> AVCodecContext *enc= ost->st->codec;\n<25> AVCodecContext *dec= ist->st->codec;\n<53> ost->resample = audio_resample_init(enc->channels,    dec->channels,\n<57> if (!ost->resample) {\n<59> fprintf(stderr, "Can not resample %d channels @ %d Hz to %d channels @ %d Hz\n",\n<75> double delta = get_sync_ipts(ost) * enc->sample_rate - ost->sync_opts\n<79> double idelta= delta*ist->st->codec->sample_rate / enc->sample_rate;\n<89> if(ist->is_start || fabs(delta) > audio_drift_threshold*enc->sample_rate){\n<91> if(byte_delta < 0){\n<99> if(verbose > 2)\n<101> fprintf(stderr, "discarding %d audio samples\n", (int)-delta);\n<113> input_tmp= av_realloc(input_tmp, byte_delta + size);\n<123> byte_delta= MAX_AUDIO_PACKET_SIZE - size;\n<127> memset(input_tmp, 0, byte_delta);\n<129> memcpy(input_tmp + byte_delta, buf, size);\n<131> buf= input_tmp;\n<133> size += byte_delta;\n<135> if(verbose > 2)\n<137> fprintf(stderr, "adding %d audio samples of silence\n", (int)delta);\n<143> int comp= av_clip(delta, -audio_sync_method, audio_sync_method);\n<147> if(verbose > 2)\n<149> fprintf(stderr, "compensating audio timestamp drift:%f compensation:%d in:%d\n", delta, comp, enc->sample_rate);\n<153> av_resample_compensate(*(struct AVResampleContext**)ost->resample, comp, enc->sample_rate);\n<161> ost->sync_opts= lrintf(get_sync_ipts(ost) * enc->sample_rate)\n<177> size_out = size_out * enc->channels * 2;\n<201> frame_bytes = enc->frame_size * 2 * enc->channels;\n<251> ost->sync_opts += size_out / (2 * enc->channels);
<1> void video_encode_example(const char *filename)\n<19> printf("Video encoding\n");\n<27> if (!codec) {\n<29> fprintf(stderr, "codec not found\n");\n<39> picture= avcodec_alloc_frame();\n<45> c->bit_rate = 400000;\n<55> c->frame_rate = 25;\n<57> c->frame_rate_base= 1;\n<59> c->gop_size = 10; /* emit one intra frame every ten frames */\n<61> c->max_b_frames=1;\n<67> if (avcodec_open(c, codec) < 0) {\n<69> fprintf(stderr, "could not open codec\n");\n<81> f = fopen(filename, "w");\n<83> if (!f) {\n<85> fprintf(stderr, "could not open %s\n", filename);\n<95> outbuf_size = 100000;\n<97> outbuf = malloc(outbuf_size);\n<99> size = c->width * c->height;\n<101> picture_buf = malloc((size * 3) / 2); /* size for YUV 420 */\n<105> picture->data[0] = picture_buf;\n<115> picture->linesize[2] = c->width / 2;\n<121> for(i=0;i<25;i++) {\n<131> for(x=0;x<c->width;x++) {\n<133> picture->data[0][y * picture->linesize[0] + x] = x + y + i * 3;\n<143> for(y=0;y<c->height/2;y++) {\n<145> for(x=0;x<c->width/2;x++) {\n<149> picture->data[2][y * picture->linesize[2] + x] = 64 + x + i * 5;\n<159> out_size = avcodec_encode_video(c, outbuf, outbuf_size, picture);\n<161> printf("encoding frame %3d (size=%5d)\n", i, out_size);\n<163> fwrite(outbuf, 1, out_size, f);\n<171> for(; out_size; i++) {\n<177> out_size = avcodec_encode_video(c, outbuf, outbuf_size, NULL);\n<179> printf("write frame %3d (size=%5d)\n", i, out_size);\n<181> fwrite(outbuf, 1, out_size, f);\n<189> outbuf[0] = 0x00;\n<191> outbuf[1] = 0x00;\n<193> outbuf[2] = 0x01;\n<195> outbuf[3] = 0xb7;\n<197> fwrite(outbuf, 1, 4, f);\n<201> free(picture_buf);\n<203> free(outbuf);\n<207> avcodec_close(c);\n<209> free(c);\n<211> free(picture);\n<213> printf("\n");
<1> static char * strsep ( char * * s , const char * del ) {\n<3> assert ( strlen ( del ) == 1 ) ;\n<4> if ( ! s || ! * s ) return NULL ;\n<5> tok = * s ;\n<6> d = strstr ( tok , del ) ;\n<9> * s = d + 1 ;\n<12> return tok ;
<1> BlockDriverAIOCB *laio_submit(BlockDriverState *bs, void *aio_ctx, int fd,\n<5> BlockDriverCompletionFunc *cb, void *opaque, int type)\n<37> switch (type) {\n<55> fprintf(stderr, "%s: invalid AIO request type 0x%x.\n",
<1> static int raw_pread(BlockDriverState *bs, int64_t offset,\n<3> uint8_t *buf, int count)\n<7> BDRVRawState *s = bs->opaque;\n<35> ret = raw_pread_aligned(bs, offset - shift, s->aligned_buf, size);\n<37> if (ret < 0)\n<43> size = 512 - shift;\n<45> if (size > count)\n<47> size = count;\n<49> memcpy(buf, s->aligned_buf + shift, size);\n<53> buf += size;\n<55> offset += size;\n<57> count -= size;\n<59> sum += size;\n<89> ret = raw_pread_aligned(bs, offset, s->aligned_buf, size);\n<91> if (ret < 0)\n<99> if (size > count)\n<101> size = count;\n<105> memcpy(buf, s->aligned_buf, size);\n<109> buf += size;\n<111> offset += size;\n<113> count -= size;\n<115> sum += size;
<1> void watchdog_perform_action(void)\n<5> switch (watchdog_action) {\n<49> fprintf(stderr, "watchdog: timer fired\n");
<1> void _TIFFfree ( void * p ) {\n<2> free ( p ) ;
<1> kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) {\n<13> krb5_key_salt_tuple * new_ks_tuple = NULL ;\n<23> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ;\n<31> if ( kdb == NULL ) return ENOMEM ;\n<32> memset ( kdb , 0 , sizeof ( * kdb ) ) ;\n<33> memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ;\n<62> if ( ( ret = kadm5_copy_principal ( handle -> context , entry -> principal , & ( kdb -> princ ) ) ) ) goto cleanup ;\n<63> if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ;\n<68> ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ;\n<72> ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ;\n<80> ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ;\n<83> ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ;\n<86> ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ;\n<88> ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n<96> ret = kdb_put_entry ( handle , kdb , & adb ) ;\n<97> ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ;\n<98> cleanup : free ( new_ks_tuple ) ;\n<99> krb5_db_free_principal ( handle -> context , kdb ) ;
<1> aio_read_done(void *opaque, int ret)\n<5> struct aio_ctx *ctx = opaque;\n<15> if (ret < 0) {\n<17> printf("readv failed: %s\n", strerror(-ret));\n<25> if (ctx->Pflag) {\n<27> void *cmp_buf = malloc(ctx->qiov.size);\n<31> memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n<33> if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n<35> printf("Pattern verification failed at offset %lld, "\n<39> (long long) ctx->offset, ctx->qiov.size);\n<43> free(cmp_buf);\n<49> if (ctx->qflag) {\n<59> dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n<67> t2 = tsub(t2, ctx->t1);\n<69> print_report("read", &t2, ctx->offset, ctx->qiov.size,\n<75> qemu_io_free(ctx->buf);\n<77> free(ctx);
<1> static void generate ( ELG_secret_key * sk , unsigned int nbits , MPI * * ret_factors ) {\n<22> rndbuf = NULL ;\n<26> if ( xbits < 16 ) {\n<31> char * r = get_random_bits ( 16 , 2 , 1 ) ;\n<32> memcpy ( rndbuf , r , 16 / 8 ) ;\n<33> xfree ( r ) ;\n<37> mpi_set_buffer ( x , rndbuf , ( xbits + 7 ) / 8 , 0 ) ;
<1> static void test_ts ( ) {\n<10> char query [ MAX_TEST_QUERY_LENGTH ] ;\n<29> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<33> my_bind [ 2 ] = my_bind [ 1 ] = my_bind [ 0 ] ;\n<38> my_bind [ 5 ] = my_bind [ 4 ] = my_bind [ 3 ] ;\n<39> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<58> for ( name = 'a' ;\n<59> field_count -- ;\n<60> name ++ ) {\n<61> int row_count = 0 ;\n<62> sprintf ( query , queries [ field_count ] , name ) ;\n<63> if ( ! opt_silent ) fprintf ( stdout , "\n %s" , query ) ;\n<64> stmt = mysql_simple_prepare ( mysql , query ) ;\n<66> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<70> while ( mysql_stmt_fetch ( stmt ) == 0 ) row_count ++ ;\n<71> if ( ! opt_silent ) fprintf ( stdout , "\n returned '%d' rows" , row_count ) ;\n<72> DIE_UNLESS ( row_count == 2 ) ;
<1> char * xmlrpc_array ( int argc , ... ) {\n<13> if ( ! s ) {\n<18> snprintf ( buf , XMLRPC_BUFSIZE , "%s\r\n <value>%s</value>" , s , a ) ;\n<19> free ( s ) ;\n<24> snprintf ( buf , XMLRPC_BUFSIZE , "<array>\r\n <data>\r\n %s\r\n </data>\r\n </array>" , s ) ;\n<25> len = strlen ( buf ) ;\n<26> free ( s ) ;\n<27> return sstrdup ( buf ) ;
<1> static int vhost_user_migration_done(struct vhost_dev *dev, char* mac_addr)\n<5> VhostUserMsg msg = { 0 };\n<35> memcpy((char *)&msg.u64, mac_addr, 6);
<1> int opt_opencl_bench(void *optctx, const char *opt, const char *arg)\n<33> if (!(devices = av_malloc_array(nb_devices, sizeof(OpenCLDeviceBenchmark)))) {\n<75> fprintf(stderr, "platform_idx\tdevice_idx\tdevice_name\truntime\n");
<1> static void dhcp_decode(const struct bootp_t *bp, int *pmsg_type,\n<19> p = bp->bp_vend;\n<23> if (memcmp(p, rfc1533_cookie, 4) != 0)\n<25> return;\n<27> p += 4;\n<31> tag = p[0];\n<42> p++;\n<44> if (p >= p_end)\n<52> DPRINTF("dhcp: tag=%d len=%d\n", tag, len);\n<56> switch(tag) {
<1> static double htond ( double val ) {\n<13> if ( config == 0 ) {\n<14> double d = 8.642135e130 ;\n<15> uint8_t c [ 8 ] ;\n<16> memcpy ( c , & d , 8 ) ;\n<17> if ( ( c [ 0 ] == 0x2f ) && ( c [ 1 ] == 0x25 ) && ( c [ 2 ] == 0xc0 ) && ( c [ 3 ] == 0xc7 ) && ( c [ 4 ] == 0x43 ) && ( c [ 5 ] == 0x2b ) && ( c [ 6 ] == 0x1f ) && ( c [ 7 ] == 0x5b ) ) config = 1 ;\n<18> else if ( ( c [ 7 ] == 0x2f ) && ( c [ 6 ] == 0x25 ) && ( c [ 5 ] == 0xc0 ) && ( c [ 4 ] == 0xc7 ) && ( c [ 3 ] == 0x43 ) && ( c [ 2 ] == 0x2b ) && ( c [ 1 ] == 0x1f ) && ( c [ 0 ] == 0x5b ) ) config = 2 ;\n<19> else if ( ( c [ 4 ] == 0x2f ) && ( c [ 5 ] == 0x25 ) && ( c [ 6 ] == 0xc0 ) && ( c [ 7 ] == 0xc7 ) && ( c [ 0 ] == 0x43 ) && ( c [ 1 ] == 0x2b ) && ( c [ 2 ] == 0x1f ) && ( c [ 3 ] == 0x5b ) ) config = 3 ;
<1> int avcodec_copy_context(AVCodecContext *dest, const AVCodecContext *src)\n<11> if (avcodec_is_open(dest)) { // check that the dest context is uninitialized\n<25> copy_context_reset(dest);\n<29> memcpy(dest, src, sizeof(*dest));\n<31> av_opt_copy(dest, src);\n<92> if (src->obj && size > 0) { \\n<96> if (!dest->obj) \\n<100> memcpy(dest->obj, src->obj, size); \\n<102> if (pad) \\n<104> memset(((uint8_t *) dest->obj) + size, 0, pad); \\n<146> copy_context_reset(dest);
<1> static int readv_f(int argc, char **argv)\n<23> int pattern = 0;\n<29> while ((c = getopt(argc, argv, "CP:qv")) != EOF) {\n<45> if (pattern < 0) {\n<85> offset = cvtnum(argv[optind]);\n<87> if (offset < 0) {\n<89> printf("non-numeric length argument -- %s\n", argv[optind]);\n<113> buf = create_iovec(&qiov, &argv[optind], nr_iov, 0xab);\n<115> if (buf == NULL) {\n<131> if (cnt < 0) {\n<133> printf("readv failed: %s\n", strerror(-cnt));\n<141> if (Pflag) {\n<143> void *cmp_buf = g_malloc(qiov.size);\n<145> memset(cmp_buf, pattern, qiov.size);\n<147> if (memcmp(buf, cmp_buf, qiov.size)) {\n<155> g_free(cmp_buf);\n<171> dump_buffer(buf, offset, qiov.size);\n<181> print_report("read", &t2, offset, qiov.size, total, cnt, Cflag);\n<188> qemu_io_free(buf);
<1> static void copy_task_thread_func ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable ) {\n<24> if ( job_aborted ( common ) ) {\n<28> memset ( & transfer_info , 0 , sizeof ( transfer_info ) ) ;\n<29> copy_files ( job , dest_fs_id , & source_info , & transfer_info ) ;
<1> long dtls1_get_message ( SSL * s , int st1 , int stn , int mt , long max , int * ok ) {\n<6> if ( s -> s3 -> tmp . reuse_message ) {\n<18> msg_hdr = & s -> d1 -> r_msg_hdr ;\n<19> memset ( msg_hdr , 0x00 , sizeof ( struct hm_header_st ) ) ;\n<22> else if ( i <= 0 && ! * ok ) return i ;\n<24> msg_len = msg_hdr -> msg_len ;\n<25> * ( p ++ ) = msg_hdr -> type ;\n<27> s2n ( msg_hdr -> seq , p ) ;\n<36> memset ( msg_hdr , 0x00 , sizeof ( struct hm_header_st ) ) ;
<1> static void test_acpi_piix4_tcg_cphp(void)\n<9> memset(&data, 0, sizeof(data));\n<15> test_acpi_one("-smp 2,cores=3,sockets=2,maxcpus=6",\n<19> free_test_data(&data);
<1> static void get_tag(AVFormatContext *s, AVIOContext *pb, const char *key, int type, int length)\n<19> } else if (type == 1) {\n<21> avio_get_str16le(pb, length, buf, buf_size);\n<23> if (!strlen(buf)) {\n<25> av_free(buf);\n<27> return;\n<67> } else if (type == 6 && length == 16) {\n<75> } else if (type == 2 && !strcmp(key, "WM/Picture")) {\n<77> get_attachment(s, pb, length);\n<79> av_freep(&buf);\n<81> return;\n<85> av_freep(&buf);\n<87> av_log(s, AV_LOG_WARNING, "unsupported metadata entry; key:%s, type:%d, length:0x%x\n", key, type, length);\n<89> avio_skip(pb, length);\n<91> return;\n<97> av_metadata_set2(&s->metadata, key, buf, 0);\n<99> av_freep(&buf);
<1> ASSStyle *ff_ass_style_get(ASSSplitContext *ctx, const char *style)\n<11> if (!style || !*style)\n<13> style = "Default";\n<15> for (i=0; i<ass->styles_count; i++)\n<17> if (!strcmp(ass->styles[i].name, style))\n<19> return ass->styles + i;
<1> static krb5_error_code process_chpw_request ( krb5_context context , void * server_handle , char * realm , krb5_keytab keytab , const krb5_fulladdr * local_faddr , const krb5_fulladdr * remote_faddr , krb5_data * req , krb5_data * rep ) {\n<5> krb5_data ap_req , ap_rep = empty_data ( ) ;\n<6> krb5_data cipher = empty_data ( ) , clear = empty_data ( ) ;\n<15> char * clientstr = NULL , * targetstr = NULL ;\n<22> krb5_address * addr = remote_faddr -> address ;\n<49> if ( ptr + ap_req . length >= req -> data + req -> length ) {\n<60> strlcpy ( strresult , "Failed initializing auth context" , sizeof ( strresult ) ) ;\n<64> if ( ret ) {\n<66> strlcpy ( strresult , "Failed initializing auth context" , sizeof ( strresult ) ) ;\n<69> ret = krb5_build_principal ( context , & changepw , strlen ( realm ) , realm , "kadmin" , "changepw" , NULL ) ;\n<72> strlcpy ( strresult , "Failed building kadmin/changepw principal" , sizeof ( strresult ) ) ;\n<78> strlcpy ( strresult , "Failed reading application request" , sizeof ( strresult ) ) ;\n<84> strlcpy ( strresult , "Failed replying to application request" , sizeof ( strresult ) ) ;\n<89> ret = krb5_rd_priv ( context , auth_context , & cipher , & clear , & replay ) ;\n<92> strlcpy ( strresult , "Failed decrypting request" , sizeof ( strresult ) ) ;\n<98> ret = decode_krb5_setpw_req ( & clear , & clear_data , & target ) ;\n<99> if ( ret != 0 ) {\n<101> strlcpy ( strresult , "Failed decoding ChangePasswdData" , sizeof ( strresult ) ) ;\n<105> clear = * clear_data ;\n<106> free ( clear_data ) ;\n<108> ret = krb5_unparse_name ( context , target , & targetstr ) ;\n<111> strlcpy ( strresult , "Failed unparsing target name for log" , sizeof ( strresult ) ) ;\n<116> ret = krb5_unparse_name ( context , client , & clientstr ) ;\n<119> strlcpy ( strresult , "Failed unparsing client name for log" , sizeof ( strresult ) ) ;\n<122> if ( vno == 1 && ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) == 0 ) {\n<124> strlcpy ( strresult , "Ticket must be derived from a password" , sizeof ( strresult ) ) ;\n<128> ret = schpw_util_wrapper ( server_handle , client , target , ( ticket -> enc_part2 -> flags & TKT_FLG_INITIAL ) != 0 , ptr , NULL , strresult , sizeof ( strresult ) ) ;\n<132> clear = empty_data ( ) ;\n<133> clen = strlen ( clientstr ) ;\n<134> trunc_name ( & clen , & cdots ) ;\n<135> switch ( addr -> addrtype ) {\n<137> struct sockaddr_in * sin = ss2sin ( & ss ) ;\n<139> memcpy ( & sin -> sin_addr , addr -> contents , addr -> length ) ;\n<145> struct sockaddr_in6 * sin6 = ss2sin6 ( & ss ) ;\n<147> memcpy ( & sin6 -> sin6_addr , addr -> contents , addr -> length ) ;\n<164> if ( target == NULL ) {\n<165> tlen = clen ;\n<170> tlen = strlen ( targetstr ) ;\n<171> trunc_name ( & tlen , & tdots ) ;\n<172> targetp = clientstr ;\n<174> krb5_klog_syslog ( LOG_NOTICE , _ ( "setpw request from %s by %.*s%s for " "%.*s%s: %s" ) , addrbuf , ( int ) clen , clientstr , cdots , ( int ) tlen , targetp , tdots , errmsg ? errmsg : "success" ) ;\n<177> krb5_klog_syslog ( LOG_NOTICE , _ ( "chpw request from %s for %.*s%s: %s" ) , addrbuf , ( int ) clen , clientstr , cdots , errmsg ? errmsg : "success" ) ;\n<185> strlcpy ( strresult , "" , sizeof ( strresult ) ) ;\n<190> chpwfail : clear . length = 2 + strlen ( strresult ) ;\n<191> clear . data = ( char * ) malloc ( clear . length ) ;\n<192> ptr = clear . data ;\n<194> * ptr ++ = numresult & 0xff ;\n<195> memcpy ( ptr , strresult , strlen ( strresult ) ) ;\n<196> cipher = empty_data ( ) ;\n<204> ret = krb5_mk_priv ( context , auth_context , & clear , & cipher , & replay ) ;\n<211> if ( cipher . length == 0 ) {\n<212> if ( ap_rep . length ) {\n<213> free ( ap_rep . data ) ;\n<214> ap_rep = empty_data ( ) ;\n<220> if ( ret ) goto bailout ;\n<225> ret = krb5_build_principal ( context , & krberror . server , strlen ( realm ) , realm , "kadmin" , "changepw" , NULL ) ;\n<228> krberror . e_data = clear ;\n<234> if ( ret ) goto bailout ;\n<241> * ptr ++ = ap_rep . length & 0xff ;\n<242> if ( ap_rep . length ) {\n<243> memcpy ( ptr , ap_rep . data , ap_rep . length ) ;\n<244> ptr += ap_rep . length ;\n<246> memcpy ( ptr , cipher . data , cipher . length ) ;\n<250> free ( ap_rep . data ) ;\n<251> free ( clear . data ) ;\n<252> free ( cipher . data ) ;\n<254> krb5_free_unparsed_name ( context , targetstr ) ;
<1> static int asf_read_metadata_obj(AVFormatContext *s, const GUIDParseTable *g)\n<17> for (i = 0; i < nb_recs; i++) {\n<43> if (!name)\n<53> if (!strcmp(name, "AspectRatioX") || !strcmp(name, "AspectRatioY")) {\n<55> asf_store_aspect_ratio(s, st_num, name);\n<59> if (st_num < ASF_MAX_STREAMS) {\n<61> if ((ret = process_metadata(s, name, name_len, val_len, type,\n<69> av_freep(&name);
<1> void Process(void *ctx, AVPicture *picture, enum PixelFormat pix_fmt, int width, int height, int64_t pts)\n<25> FILE *out = rwpipe_writer( ci->rw );\n<31> if ( in == NULL || out == NULL )\n<43> int size = avpicture_get_size(PIX_FMT_RGB24, width, height);\n<115> if ( !err )\n<121> fprintf( out, "P6\n%d %d\n255\n", width, height );\n<123> for ( i = 0; !err && i < height; i ++ )\n<127> err = !fwrite( ptr, width * 3, 1, out );\n<135> err = fflush( out );
<1> static void test_ps_null_param ( ) {\n<22> memset ( & in_bind , 0 , sizeof ( in_bind ) ) ;\n<23> memset ( & out_bind , 0 , sizeof ( out_bind ) ) ;\n<43> rc = mysql_stmt_bind_param ( stmt , & in_bind ) ;\n<45> rc = mysql_stmt_bind_result ( stmt , & out_bind ) ;
<1> static int tgv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> TgvContext * s = avctx -> priv_data ;\n<20> av_freep ( & s -> frame_buffer ) ;\n<28> s -> palette [ i ] = AV_RB24 ( buf ) ;\n<33> if ( ( ret = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) return ret ;\n<34> memcpy ( frame -> data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;\n<40> if ( unpack ( buf , buf_end , s -> frame_buffer , s -> avctx -> width , s -> avctx -> height ) < 0 ) {\n<45> y < s -> height ;\n<46> y ++ ) memcpy ( frame -> data [ 0 ] + y * frame -> linesize [ 0 ] , s -> frame_buffer + y * s -> width , s -> width ) ;\n<55> if ( tgv_decode_inter ( s , frame , buf , buf_end ) < 0 ) {
<1> int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)\n<11> if (s->direct_msi) {\n<21> memset(msi.pad, 0, sizeof(msi.pad));\n<25> return kvm_vm_ioctl(s, KVM_SIGNAL_MSI, &msi);
<1> static int flush_packet(AVFormatContext *ctx, int stream_index,\n<101> if (stream->bytes_to_iframe == 0 || s->packet_number == 0) {\n<109> put_buffer(ctx->pb, buffer, size);\n<137> memset(buffer, 0, 128);\n<139> buf_ptr = buffer;\n<177> size = buf_ptr - buffer;
<1> static int vmdk_write_cid(BlockDriverState *bs, uint32_t cid)\n<13> if (bdrv_pread(bs->file, 0x200, desc, DESC_SIZE) != DESC_SIZE)\n<19> tmp_str = strstr(desc,"parentCID");\n<21> pstrcpy(tmp_desc, sizeof(tmp_desc), tmp_str);\n<23> if ((p_name = strstr(desc,"CID")) != NULL) {\n<25> p_name += sizeof("CID");\n<27> snprintf(p_name, sizeof(desc) - (p_name - desc), "%x\n", cid);\n<29> pstrcat(desc, sizeof(desc), tmp_desc);\n<35> if (bdrv_pwrite(bs->file, 0x200, desc, DESC_SIZE) != DESC_SIZE)
<1> static void do_video_out(AVFormatContext *s,\n<2> OutputStream *ost,\n<42> if (format_video_sync == VSYNC_AUTO) {\n<43> if(!strcmp(s->oformat->name, "avi")) {\n<44> format_video_sync = VSYNC_VFR;\n<46> format_video_sync = (s->oformat->flags & AVFMT_VARIABLE_FPS) ? ((s->oformat->flags & AVFMT_NOTIMESTAMPS) ? VSYNC_PASSTHROUGH : VSYNC_VFR) : VSYNC_CFR;\n<108> sizeof(ost->last_nb0_frames[0]) * (FF_ARRAY_ELEMS(ost->last_nb0_frames) - 1));\n<137> if (!check_recording_time(ost))\n<154> write_frame(s, &pkt, ost);\n<210> ret = avcodec_encode_video2(enc, &pkt, in_picture, &got_packet);\n<233> write_frame(s, &pkt, ost);\n<235> if (ost->logfile && enc->stats_out) {\n<236> fprintf(ost->logfile, "%s", enc->stats_out);\n<248> do_video_stats(ost, frame_size);
<1> int ratestrtosize ( char * s , uint_fast32_t rawsize , uint_fast32_t * size ) {\n<3> if ( strchr ( s , 'B' ) ) {\n<4> * size = atoi ( s ) ;\n<7> f = atof ( s ) ;\n<8> if ( f < 0 ) {
<6> if ( dict -> entries [ i ] . type == ps_string || dict -> entries [ i ] . type == ps_instr || dict -> entries [ i ] . type == ps_lit ) free ( dict -> entries [ i ] . u . str ) ;
<1> static void combined_write_cb ( int fd , short event , void * arg ) {\n<8> if ( len == - 1 ) fprintf ( stderr , "%s: write\n" , __func__ ) ;
<1> static int qemu_rdma_exchange_recv(RDMAContext *rdma, RDMAControlHeader *head,\n<31> if (ret < 0) {\n<33> fprintf(stderr, "Failed to send control buffer!\n");\n<73> if (ret) {\n<75> fprintf(stderr, "rdma migration: error posting second control recv!");
<1> static afs_int32 listEntries ( struct rx_call * call , afs_int32 flag , afs_int32 startindex , prentries * bulkentries , afs_int32 * nextstartindex , afs_int32 * cid ) {\n<8> bulkentries -> prentries_val = 0 ;\n<36> code = put_prentries ( & tentry , bulkentries ) ;\n<44> if ( bulkentries -> prentries_val ) free ( bulkentries -> prentries_val ) ;
<1> static ssize_t nic_receive(VLANClientState *vc, const uint8_t * buf, size_t size)\n<13> EEPRO100State *s = vc->opaque;\n<49> } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & 8)) {\n<59> } else if (memcmp(buf, s->macaddr, 6) == 0) {       // !!!\n<65> TRACE(RXTX, logout("%p received frame for me, len=%zu\n", s, size));\n<67> } else if (memcmp(buf, broadcast_macaddr, 6) == 0) {\n<71> TRACE(RXTX, logout("%p received broadcast, len=%zu\n", s, size));\n<73> rfd_status |= 0x0002;\n<75> } else if (buf[0] & 0x01) { // !!!\n<79> TRACE(RXTX, logout("%p received multicast, len=%zu\n", s, size));\n<85> int mcast_idx = compute_mcast_idx(buf);\n<99> TRACE(RXTX, logout("%p received frame in promiscuous mode, len=%zu\n", s, size));\n<105> TRACE(RXTX, logout("%p received frame, ignored, len=%zu,%s\n", s, size,\n<107> nic_dump(buf, size)));\n<115> if (get_ru_state(s) != ru_ready) {\n<119> logout("no resources, state=%u\n", get_ru_state(s));\n<173> cpu_physical_memory_write(s->ru_base + s->ru_offset +\n<179> eepro100_fr_interrupt(s);\n<195> set_ru_state(s, ru_suspended);
<1> static void nal_send(AVFormatContext *s1, const uint8_t *buf, int size, int last)\n<5> RTPMuxContext *s = s1->priv_data;\n<9> av_log(s1, AV_LOG_DEBUG, "Sending NAL %x of len %d M=%d\n", buf[0] & 0x1F, size, last);\n<33> if (buffered_size + 3 + size <= s->max_payload_size &&\n<41> AV_WB16(s->buf_ptr, size);\n<43> s->buf_ptr += 2;\n<45> memcpy(s->buf_ptr, buf, size);\n<47> s->buf_ptr += size;\n<63> uint8_t nri = buf[0] & 0x60;\n<69> if (s->flags & FF_RTP_FLAG_H264_MODE0) {\n<91> buf += 1;\n<93> size -= 1;\n<95> while (size + 2 > s->max_payload_size) {\n<97> memcpy(&s->buf[2], buf, s->max_payload_size - 2);\n<99> ff_rtp_send_data(s1, s->buf, s->max_payload_size, 0);\n<101> buf += s->max_payload_size - 2;\n<103> size -= s->max_payload_size - 2;\n<111> memcpy(&s->buf[2], buf, size);\n<113> ff_rtp_send_data(s1, s->buf, size + 2, last);
<1> int vhost_dev_enable_notifiers(struct vhost_dev *hdev, VirtIODevice *vdev)\n<13> if (!k->set_host_notifier) {\n<15> fprintf(stderr, "binding does not support host notifiers\n");\n<25> for (i = 0; i < hdev->nvqs; ++i) {\n<29> if (r < 0) {\n<31> fprintf(stderr, "vhost VQ %d notifier binding failed: %d\n", i, -r);\n<45> while (--i >= 0) {\n<49> if (r < 0) {\n<51> fprintf(stderr, "vhost VQ %d notifier cleanup error: %d\n", i, -r);\n<53> fflush(stderr);
<1> static void pc_init1(QEMUMachineInitArgs *args,\n<57> if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {\n<59> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> int ffv1_allocate_initial_states ( FFV1Context * f ) {\n<7> if ( ! f -> initial_states [ i ] ) return AVERROR ( ENOMEM ) ;\n<8> memset ( f -> initial_states [ i ] , 128 , f -> context_count [ i ] * sizeof ( * f -> initial_states [ i ] ) ) ;
<1> static int device_open(AVFormatContext *ctx)\n<31> if (fd < 0) {\n<33> err = errno;\n<37> av_log(ctx, AV_LOG_ERROR, "Cannot open video device %s : %s\n",\n<39> ctx->filename, strerror(err));\n<43> return AVERROR(err);\n<71> if (res < 0) {\n<73> err = errno;\n<75> av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_QUERYCAP): %s\n",\n<77> strerror(err));\n<131> return AVERROR(err);
<1> static void finish_request ( struct transfer_request * request ) {\n<5> request -> http_code = request -> slot -> http_code ;\n<9> if ( request -> state != RUN_PUT ) {\n<10> free ( request -> url ) ;\n<11> request -> url = NULL ;\n<14> if ( request -> curl_result == CURLE_OK || request -> http_code == 405 ) {\n<19> fprintf ( stderr , "MKCOL %s failed, aborting (%d/%ld)\n" , oid_to_hex ( & request -> obj -> oid ) , request -> curl_result , request -> http_code ) ;\n<25> if ( request -> curl_result == CURLE_OK ) {\n<29> fprintf ( stderr , "PUT %s failed, aborting (%d/%ld)\n" , oid_to_hex ( & request -> obj -> oid ) , request -> curl_result , request -> http_code ) ;\n<35> if ( request -> curl_result == CURLE_OK ) {\n<36> if ( push_verbosely ) fprintf ( stderr , " sent %s\n" , oid_to_hex ( & request -> obj -> oid ) ) ;\n<41> fprintf ( stderr , "MOVE %s failed, aborting (%d/%ld)\n" , oid_to_hex ( & request -> obj -> oid ) , request -> curl_result , request -> http_code ) ;\n<57> if ( request -> curl_result != CURLE_OK ) {\n<58> fprintf ( stderr , "Unable to get pack file %s\n%s" , request -> url , curl_errorstr ) ;\n<68> release_request ( request ) ;
<1> relpRetVal relpTcpSetOwnCert ( relpTcp_t * pThis , char * cert ) {\n<3> RELPOBJ_assert ( pThis , Tcp ) ;\n<4> free ( pThis -> ownCertFile ) ;\n<5> if ( cert == NULL ) {\n<9> if ( ( pThis -> ownCertFile = strdup ( cert ) ) == NULL ) ABORT_FINALIZE ( RELP_RET_OUT_OF_MEMORY ) ;
<1> static void ERROR(const char *str)\n<5> fprintf(stderr, "%s\n", str);
<1> static void test_wl4166_1 ( ) {\n<4> char str_data [ 50 ] ;\n<23> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<40> i < ( int ) array_elements ( my_bind ) ;\n<48> int_data = 320 ;\n<54> tiny_data < 10 ;\n<56> length [ 1 ] = sprintf ( str_data , "MySQL%d" , int_data ) ;\n<59> int_data += 25 ;\n<68> tiny_data < 60 ;\n<70> length [ 1 ] = sprintf ( str_data , "MySQL%d" , int_data ) ;\n<73> int_data += 25 ;
<1> static void ibm_40p_init(MachineState *machine)\n<275> if (machine->kernel_cmdline && *machine->kernel_cmdline) {\n<289> strlen(machine->kernel_cmdline) + 1);\n<357> PPC_NVRAM_set_params(m48t59, NVRAM_SIZE, "PREP", ram_size,
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> AnmContext * s = avctx -> priv_data ;\n<42> if ( type == 0 ) break ;\n<54> while ( bytestream2_get_bytes_left ( & s -> gb ) > 0 ) ;\n<55> memcpy ( s -> frame -> data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;
<1> static void spapr_vio_quiesce_one(VIOsPAPRDevice *dev)\n<9> if (dev->rtce_table) {\n<11> size_t size = (dev->rtce_window_size >> SPAPR_VIO_TCE_PAGE_SHIFT)\n<15> memset(dev->rtce_table, 0, size);
<1> int archive_read_support_format_warc ( struct archive * _a ) {\n<6> if ( ( w = calloc ( 1 , sizeof ( * w ) ) ) == NULL ) {\n<7> archive_set_error ( & a -> archive , ENOMEM , "Can't allocate warc data" ) ;\n<8> return ( ARCHIVE_FATAL ) ;\n<10> r = __archive_read_register_format ( a , w , "warc" , _warc_bid , NULL , _warc_rdhdr , _warc_read , _warc_skip , NULL , _warc_cleanup , NULL , NULL ) ;\n<11> if ( r != ARCHIVE_OK ) {\n<12> free ( w ) ;
<1> static int pfkey_spddelete ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) {\n<13> if ( ! pol -> sadb_x_policy_dir || pol -> sadb_x_policy_dir >= IPSEC_DIR_MAX ) return - EINVAL ;\n<14> memset ( & sel , 0 , sizeof ( sel ) ) ;\n<33> xp = xfrm_policy_bysel_ctx ( net , DUMMY_MARK , XFRM_POLICY_TYPE_MAIN , pol -> sadb_x_policy_dir - 1 , & sel , pol_ctx , 1 , & err ) ;
<1> void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n<27> if (l > len)\n<29> l = len;\n<47> if ((pd & ~TARGET_PAGE_MASK) != IO_MEM_RAM) {\n<99> ptr = phys_ram_base + addr1;\n<101> memcpy(ptr, buf, l);\n<107> tb_invalidate_phys_page_range(addr1, addr1 + l, 0);\n<169> ptr = phys_ram_base + (pd & TARGET_PAGE_MASK) +\n<173> memcpy(buf, ptr, l);\n<179> len -= l;\n<181> buf += l;\n<183> addr += l;
<1> static int encode_frame ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , VpxVideoWriter * writer ) {\n<9> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {\n<12> printf ( keyframe ? "K" : "." ) ;
<1> static void cpu_openrisc_load_kernel(ram_addr_t ram_size,\n<47> if (kernel_size < 0) {\n<49> fprintf(stderr, "QEMU: couldn't load the kernel '%s'\n",
<1> static int dtls1_reassemble_fragment ( SSL * s , struct hm_header_st * msg_hdr , int * ok ) {\n<10> if ( ( msg_hdr -> frag_off + frag_len ) > max_len ) goto err ;\n<11> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<12> seq64be [ 6 ] = ( unsigned char ) ( msg_hdr -> seq >> 8 ) ;\n<13> seq64be [ 7 ] = ( unsigned char ) msg_hdr -> seq ;\n<14> item = pqueue_find ( s -> d1 -> buffered_messages , seq64be ) ;\n<16> frag = dtls1_hm_fragment_new ( msg_hdr -> msg_len , 1 ) ;\n<17> if ( frag == NULL ) goto err ;\n<18> memcpy ( & ( frag -> msg_header ) , msg_hdr , sizeof ( * msg_hdr ) ) ;\n<32> i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , frag -> fragment + msg_hdr -> frag_off , frag_len , 0 ) ;\n<34> RSMBLY_BITMASK_MARK ( frag -> reassembly , ( long ) msg_hdr -> frag_off , ( long ) ( msg_hdr -> frag_off + frag_len ) ) ;\n<35> RSMBLY_BITMASK_IS_COMPLETE ( frag -> reassembly , ( long ) msg_hdr -> msg_len , is_complete ) ;\n<40> if ( item == NULL ) {\n<41> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<42> seq64be [ 6 ] = ( unsigned char ) ( msg_hdr -> seq >> 8 ) ;\n<43> seq64be [ 7 ] = ( unsigned char ) ( msg_hdr -> seq ) ;\n<44> item = pitem_new ( seq64be , frag ) ;
<1> void cpu_reset (CPUCRISState *env)\n<3> memset(env, 0, offsetof(CPUCRISState, breakpoints));\n<4> tlb_flush(env, 1);
<1> static int net_init_nic(const NetClientOptions *opts, const char *name,\n<25> if (idx == -1 || nb_nics >= MAX_NICS) {\n<35> nd = &nd_table[idx];\n<39> memset(nd, 0, sizeof(*nd));\n<47> if (!nd->netdev) {\n<99> qemu_macaddr_default_if_unset(&nd->macaddr);
<1> static int dissect_handle ( proto_tree * tree , packet_info * pinfo , gint hf , tvbuff_t * tvb , gint offset , bluetooth_data_t * bluetooth_data , bluetooth_uuid_t * uuid , gint32 handle ) {\n<19> service_uuid = get_service_uuid_from_handle ( pinfo , ( guint16 ) handle , bluetooth_data ) ;\n<20> characteristic_uuid = get_characteristic_uuid_from_handle ( pinfo , ( guint16 ) handle , bluetooth_data ) ;\n<21> attribute_uuid = get_uuid_from_handle ( pinfo , ( guint16 ) handle , bluetooth_data ) ;\n<23> if ( memcmp ( & service_uuid , & attribute_uuid , sizeof ( attribute_uuid ) ) ) {\n<24> if ( service_uuid . size == 2 || service_uuid . size == 16 ) {\n<25> proto_item_append_text ( handle_item , "%s: " , print_uuid ( & service_uuid ) ) ;\n<27> if ( service_uuid . size == 2 ) sub_item = proto_tree_add_uint ( sub_tree , hf_btatt_service_uuid16 , tvb , 0 , 0 , service_uuid . bt_uuid ) ;\n<28> else sub_item = proto_tree_add_bytes_with_length ( sub_tree , hf_btatt_service_uuid128 , tvb , 0 , 0 , service_uuid . data , 16 ) ;\n<32> if ( memcmp ( & characteristic_uuid , & attribute_uuid , sizeof ( attribute_uuid ) ) ) {\n<33> if ( characteristic_uuid . size == 2 || characteristic_uuid . size == 16 ) {\n<34> proto_item_append_text ( handle_item , "%s: " , print_uuid ( & characteristic_uuid ) ) ;\n<36> if ( characteristic_uuid . size == 2 ) sub_item = proto_tree_add_uint ( sub_tree , hf_btatt_characteristic_uuid16 , tvb , 0 , 0 , characteristic_uuid . bt_uuid ) ;\n<37> else sub_item = proto_tree_add_bytes_with_length ( sub_tree , hf_btatt_characteristic_uuid128 , tvb , 0 , 0 , characteristic_uuid . data , 16 ) ;\n<41> proto_item_append_text ( handle_item , "%s)" , print_uuid ( & attribute_uuid ) ) ;\n<42> if ( attribute_uuid . size == 2 || attribute_uuid . size == 16 ) {\n<44> if ( attribute_uuid . size == 2 ) sub_item = proto_tree_add_uint ( sub_tree , hf_btatt_uuid16 , tvb , 0 , 0 , attribute_uuid . bt_uuid ) ;\n<45> else sub_item = proto_tree_add_bytes_with_length ( sub_tree , hf_btatt_uuid128 , tvb , 0 , 0 , attribute_uuid . data , 16 ) ;\n<48> if ( uuid ) * uuid = attribute_uuid ;
<1> static int cpu_sparc_find_by_name(sparc_def_t *cpu_def, const char *cpu_model)\n<9> char *s = strdup(cpu_model);\n<11> char *featurestr, *name = strtok(s, ",");\n<25> if (strcasecmp(name, sparc_defs[i].name) == 0) {\n<33> if (!def) {\n<39> memcpy(cpu_def, def, sizeof(*def));\n<43> featurestr = strtok(NULL, ",");\n<45> while (featurestr) {\n<51> if (featurestr[0] == '+') {\n<53> add_flagname_to_bitmaps(featurestr + 1, &plus_features);\n<55> } else if (featurestr[0] == '-') {\n<57> add_flagname_to_bitmaps(featurestr + 1, &minus_features);\n<59> } else if ((val = strchr(featurestr, '='))) {\n<61> *val = 0; val++;\n<63> if (!strcmp(featurestr, "iu_version")) {\n<69> iu_version = strtoll(val, &err, 0);\n<71> if (!*val || *err) {\n<73> fprintf(stderr, "bad numerical value %s\n", val);\n<87> } else if (!strcmp(featurestr, "fpu_version")) {\n<93> fpu_version = strtol(val, &err, 0);\n<95> if (!*val || *err) {\n<97> fprintf(stderr, "bad numerical value %s\n", val);\n<111> } else if (!strcmp(featurestr, "mmu_version")) {\n<117> mmu_version = strtol(val, &err, 0);\n<119> if (!*val || *err) {\n<121> fprintf(stderr, "bad numerical value %s\n", val);\n<135> } else if (!strcmp(featurestr, "nwindows")) {\n<141> nwindows = strtol(val, &err, 0);\n<143> if (!*val || *err || nwindows > MAX_NWINDOWS ||\n<147> fprintf(stderr, "bad numerical value %s\n", val);\n<163> fprintf(stderr, "unrecognized feature %s\n", featurestr);\n<171> fprintf(stderr, "feature string `%s' not in format "\n<179> featurestr = strtok(NULL, ",");\n<183> cpu_def->features |= plus_features;\n<185> cpu_def->features &= ~minus_features;\n<193> free(s);\n<201> free(s);\n<203> return -1;
<1> static int do_fork(CPUArchState *env, unsigned int flags, abi_ulong newsp,\n<31> if (flags & CLONE_VM) {\n<87> memset(&info, 0, sizeof(info));\n<127> ret = pthread_create(&info.thread, &attr, clone_func, &info);\n<133> sigprocmask(SIG_SETMASK, &info.sigmask, NULL);\n<141> pthread_cond_wait(&info.cond, &info.mutex);\n<143> ret = info.tid;\n<151> pthread_mutex_unlock(&info.mutex);\n<153> pthread_cond_destroy(&info.cond);\n<155> pthread_mutex_destroy(&info.mutex);
<1> rfbBool rfbSendKeyboardLedState ( rfbClientPtr cl ) {\n<3> if ( cl -> ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE ) {\n<4> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n<6> rect . encoding = Swap32IfLE ( rfbEncodingKeyboardLedState ) ;\n<11> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ;\n<12> cl -> ublen += sz_rfbFramebufferUpdateRectHeader ;\n<13> rfbStatRecordEncodingSent ( cl , rfbEncodingKeyboardLedState , sz_rfbFramebufferUpdateRectHeader , sz_rfbFramebufferUpdateRectHeader ) ;
<436> if (is_dvb_subtitle && payload_size == len) {\n<438> memcpy(buf + TS_PACKET_SIZE - len, payload, len - 1);\n<444> memcpy(buf + TS_PACKET_SIZE - len, payload, len);
<1> static void test_bind_result ( ) {\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<33> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<39> if ( ! opt_silent ) fprintf ( stdout , "\n row 1: %d, %s(%lu)" , nData , szData , length1 ) ;\n<40> DIE_UNLESS ( nData == 10 ) ;\n<41> DIE_UNLESS ( strcmp ( szData , "venu" ) == 0 ) ;\n<42> DIE_UNLESS ( length1 == 4 ) ;\n<45> if ( ! opt_silent ) fprintf ( stdout , "\n row 2: %d, %s(%lu)" , nData , szData , length1 ) ;\n<46> DIE_UNLESS ( nData == 20 ) ;\n<47> DIE_UNLESS ( strcmp ( szData , "MySQL" ) == 0 ) ;\n<48> DIE_UNLESS ( length1 == 5 ) ;\n<51> if ( ! opt_silent && is_null [ 0 ] ) fprintf ( stdout , "\n row 3: NULL, %s(%lu)" , szData , length1 ) ;\n<53> DIE_UNLESS ( strcmp ( szData , "monty" ) == 0 ) ;\n<54> DIE_UNLESS ( length1 == 5 ) ;
<1> void ff_h264_direct_ref_list_init(const H264Context *const h, H264SliceContext *sl)\n<31> if (h->picture_structure == PICT_FRAME) {\n<33> memcpy(cur->ref_count[1], cur->ref_count[0], sizeof(cur->ref_count[0]));\n<35> memcpy(cur->ref_poc[1],   cur->ref_poc[0],   sizeof(cur->ref_poc[0]));
<1> static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {\n<6> conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n<14> char * dbname = PQgetvalue ( result , i , 0 ) ;\n<15> if ( ! quiet ) {\n<16> printf ( _ ( "%s: reindexing database \"%s\"\n" ) , progname , dbname ) ;\n<21> appendConnStrVal ( & connstr , dbname ) ;\n<22> reindex_one_database ( NULL , connstr . data , "DATABASE" , host , port , username , prompt_password , progname , echo , verbose ) ;
<1> static int amf_parse_object(AVFormatContext *s, AVStream *astream,\n<3> AVStream *vstream, const char *key,\n<55> if ((vstream || astream) && key &&\n<59> !strcmp(KEYFRAMES_TAG, key) && depth == 1)\n<157> if (depth == 1) {\n<159> acodec = astream ? astream->codec : NULL;\n<161> vcodec = vstream ? vstream->codec : NULL;\n<169> if (!strcmp(key, "duration"))\n<171> s->duration = num_val * AV_TIME_BASE;\n<173> else if (!strcmp(key, "videodatarate") && vcodec &&\n<175> 0 <= (int)(num_val * 1024.0))\n<177> vcodec->bit_rate = num_val * 1024.0;\n<179> else if (!strcmp(key, "audiodatarate") && acodec &&\n<181> 0 <= (int)(num_val * 1024.0))\n<183> acodec->bit_rate = num_val * 1024.0;\n<185> else if (!strcmp(key, "datastream")) {\n<187> AVStream *st = create_stream(s, AVMEDIA_TYPE_DATA);\n<189> if (!st)\n<195> } else if (flv->trust_metadata) {\n<197> if (!strcmp(key, "videocodecid") && vcodec) {\n<199> flv_set_video_codec(s, vstream, num_val, 0);\n<201> } else if (!strcmp(key, "audiocodecid") && acodec) {\n<203> int id = ((int)num_val) << FLV_AUDIO_CODECID_OFFSET;\n<205> flv_set_audio_codec(s, astream, acodec, id);\n<207> } else if (!strcmp(key, "audiosamplerate") && acodec) {\n<209> acodec->sample_rate = num_val;\n<211> } else if (!strcmp(key, "audiosamplesize") && acodec) {\n<213> acodec->bits_per_coded_sample = num_val;\n<215> } else if (!strcmp(key, "stereo") && acodec) {\n<217> acodec->channels       = num_val + 1;\n<219> acodec->channel_layout = acodec->channels == 2 ?\n<225> } else if (!strcmp(key, "width") && vcodec) {\n<227> vcodec->width = num_val;\n<229> } else if (!strcmp(key, "height") && vcodec) {\n<231> vcodec->height = num_val;\n<243> if (amf_type == AMF_DATA_TYPE_OBJECT && s->nb_streams == 1 &&\n<245> ((!acodec && !strcmp(key, "audiocodecid")) ||\n<247> (!vcodec && !strcmp(key, "videocodecid"))))\n<253> if (!strcmp(key, "duration")        ||\n<255> !strcmp(key, "filesize")        ||\n<257> !strcmp(key, "width")           ||\n<259> !strcmp(key, "height")          ||\n<261> !strcmp(key, "videodatarate")   ||\n<263> !strcmp(key, "framerate")       ||\n<265> !strcmp(key, "videocodecid")    ||\n<267> !strcmp(key, "audiodatarate")   ||\n<269> !strcmp(key, "audiosamplerate") ||\n<271> !strcmp(key, "audiosamplesize") ||\n<273> !strcmp(key, "stereo")          ||\n<275> !strcmp(key, "audiocodecid")    ||\n<277> !strcmp(key, "datastream"))\n<279> return 0;\n<283> s->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n<285> if (amf_type == AMF_DATA_TYPE_BOOL) {\n<291> av_dict_set(&s->metadata, key, str_val, 0);\n<297> av_dict_set(&s->metadata, key, str_val, 0);\n<301> av_dict_set(&s->metadata, key, str_val, 0);\n<307> return 0;
<1> static int parse_one_feature ( const char * feature , int from_stream ) {\n<12> else if ( skip_prefix ( feature , "export-marks=" , & arg ) ) {\n<15> else if ( ! strcmp ( feature , "get-mark" ) ) {\n<18> else if ( ! strcmp ( feature , "cat-blob" ) ) {\n<21> else if ( ! strcmp ( feature , "relative-marks" ) ) {\n<22> relative_marks_paths = 1 ;\n<24> else if ( ! strcmp ( feature , "no-relative-marks" ) ) {\n<25> relative_marks_paths = 0 ;\n<27> else if ( ! strcmp ( feature , "done" ) ) {\n<28> require_explicit_termination = 1 ;\n<30> else if ( ! strcmp ( feature , "force" ) ) {\n<31> force_update = 1 ;\n<33> else if ( ! strcmp ( feature , "notes" ) || ! strcmp ( feature , "ls" ) ) {\n<37> return 0 ;\n<39> return 1 ;
<1> void populate_symb ( char * header_file ) {\n<4> char name [ 2 * MAX_TOK_LEN ] ;\n<7> if ( NULL == yh ) {\n<11> while ( NULL != fgets ( line , sizeof ( line ) , yh ) ) if ( 2 == sscanf ( line , "#define %s %d" , name , & token ) && 'T' == name [ 0 ] && '_' == name [ 1 ] && token >= 0 && token < COUNTOF ( symb ) ) {\n<12> symb [ token ] = estrdup ( name ) ;\n<13> if ( strlen ( name ) > MAX_TOK_LEN ) {\n<14> fprintf ( stderr , "MAX_TOK_LEN %d too small for '%s'\n" "Edit keyword-gen.c to raise.\n" , MAX_TOK_LEN , name ) ;\n<15> exit ( 10 ) ;\n<18> fclose ( yh ) ;
<1> void cpu_reset(CPUM68KState *env)\n<3> memset(env, 0, offsetof(CPUM68KState, breakpoints));\n<7> m68k_switch_sp(env);
<1> void syscall_init(void)\n<19> ie = ioctl_entries;\n<21> if (((ie->target_cmd >> TARGET_IOC_SIZESHIFT) & TARGET_IOC_SIZEMASK) ==\n<24> if (arg_type[0] != TYPE_PTR) {\n<25> fprintf(stderr, "cannot patch size for ioctl 0x%x\n",\n<43> ie++;
<1> static void decode_mb(MpegEncContext *s, int ref)\n<25> H264Context *h = (void*)s;\n<29> memset(h->non_zero_count_cache, 0, sizeof(h->non_zero_count_cache));\n<70> ff_h264_hl_decode_mb(h);
<55> if (s->invalidated || dirty) {\n<59> memcpy(surface_data(surface), s->vga.vram_ptr,\n<61> surface_stride(surface) * surface_height(surface));
<1> int ff_h264_fill_default_ref_list(H264Context *h)\n<37> len  = build_def_list(h->default_ref_list[list],       sorted,      len, 0, h->picture_structure);\n<39> len += build_def_list(h->default_ref_list[list] + len, h->long_ref, 16,  1, h->picture_structure);\n<45> if (len < h->ref_count[list])\n<47> memset(&h->default_ref_list[list][len], 0, sizeof(Picture) * (h->ref_count[list] - len));\n<79> len  = build_def_list(h->default_ref_list[0],       h->short_ref, h->short_ref_count, 0, h->picture_structure);\n<85> if (len < h->ref_count[0])\n<87> memset(&h->default_ref_list[0][len], 0, sizeof(Picture) * (h->ref_count[0] - len));
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> PNGDecContext * const s = avctx -> priv_data ;\n<3> const uint8_t * buf = avpkt -> data ;\n<9> if ( buf_size < 8 || memcmp ( buf , ff_pngsig , 8 ) != 0 && memcmp ( buf , ff_mngsig , 8 ) != 0 ) return - 1 ;\n<10> bytestream2_init ( & s -> gb , buf + 8 , buf_size - 8 ) ;\n<11> s -> y = s -> state = 0 ;\n<12> s -> zstream . zalloc = ff_png_zalloc ;\n<13> s -> zstream . zfree = ff_png_zfree ;\n<14> s -> zstream . opaque = NULL ;\n<15> ret = inflateInit ( & s -> zstream ) ;\n<16> if ( ret != Z_OK ) return - 1 ;\n<95> if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) memcpy ( p -> data [ 1 ] , s -> palette , 256 * sizeof ( uint32_t ) ) ;\n<109> if ( png_decode_idat ( s , length ) < 0 ) goto fail ;\n<122> s -> palette [ i ] = ( 0xff << 24 ) | ( r << 16 ) | ( g << 8 ) | b ;\n<127> s -> palette [ i ] = ( 0xff << 24 ) ;\n<140> s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ;
<1> static int rtc_start_timer(struct qemu_alarm_timer *t)\n<23> fprintf(stderr, "Could not configure '/dev/rtc' to have a 1024 Hz timer. This is not a fatal\n"
<1> static void synth_block_fcb_acb(WMAVoiceContext *s, GetBitContext *gb,\n<19> float pulses[MAX_FRAMESIZE / 2], pred_err, acb_gain, fcb_gain;\n<29> memset(pulses, 0, sizeof(*pulses) * size);\n<51> aw_pulse_set2(s, gb, block_idx, &fcb);\n<95> ff_set_fixed_vector(pulses, &fcb, 1.0, size);\n<123> memmove(&s->gain_pred_err[gain_weight], s->gain_pred_err,\n<125> sizeof(*s->gain_pred_err) * (6 - gain_weight));
<43> static void default_print_section_header ( WriterContext * wctx ) {\n<54> if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "[%s]\n" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;
<1> int test_rshift ( BIO * bp , BN_CTX * ctx ) {\n<29> if ( ! BN_is_zero ( d ) ) {\n<30> fprintf ( stderr , "Right shift test failed!\n" ) ;
<1> gpg_error_t keydb_search ( KEYDB_HANDLE hd , KEYDB_SEARCH_DESC * desc , size_t ndesc , size_t * descindex ) {\n<7> if ( ! hd -> no_caching && ndesc == 1 && ( desc [ 0 ] . mode == KEYDB_SEARCH_MODE_FPR20 || desc [ 0 ] . mode == KEYDB_SEARCH_MODE_FPR ) && keyblock_cache . state == KEYBLOCK_CACHE_FILLED && ! memcmp ( keyblock_cache . fpr , desc [ 0 ] . u . fpr , 20 ) ) {\n<28> if ( ! hd -> no_caching && ! rc && ndesc == 1 && ( desc [ 0 ] . mode == KEYDB_SEARCH_MODE_FPR20 || desc [ 0 ] . mode == KEYDB_SEARCH_MODE_FPR ) ) {\n<30> memcpy ( keyblock_cache . fpr , desc [ 0 ] . u . fpr , 20 ) ;
<1> static uint32_t msix_mmio_readl(void *opaque, target_phys_addr_t addr)\n<7> unsigned int offset = addr & (MSIX_PAGE_SIZE - 1);\n<9> void *page = dev->msix_table_page;\n<11> uint32_t val = 0;\n<15> memcpy(&val, (void *)((char *)page + offset), 4);\n<19> return val;
<1> static void xen_read_physmap(XenIOState *state)\n<21> if (entries == NULL)\n<29> physmap = g_malloc(sizeof (XenPhysmap));\n<31> physmap->phys_offset = strtoull(entries[i], NULL, 16);\n<41> if (value == NULL) {\n<43> free(physmap);\n<49> physmap->start_addr = strtoull(value, NULL, 16);\n<51> free(value);\n<63> if (value == NULL) {\n<65> free(physmap);\n<71> physmap->size = strtoull(value, NULL, 16);\n<73> free(value);\n<83> physmap->name = xs_read(state->xenstore, 0, path, &len);\n<91> free(entries);
<1> void xps_end_opacity ( xps_document * doc , char * base_uri , xps_resource * dict , char * opacity_att , fz_xml * opacity_mask_tag ) {\n<4> if ( opacity_mask_tag ) {\n<5> if ( strcmp ( fz_xml_tag ( opacity_mask_tag ) , "SolidColorBrush" ) ) fz_pop_clip ( doc -> dev ) ;
<1> int loader_exec(const char * filename, char ** argv, char ** envp,\n<19> bprm.page[i] = NULL;\n<59> fprintf(stderr, "Unknown binary format\n");\n<83> for (i=0 ; i<MAX_ARG_PAGES ; i++) {\n<85> free(bprm.page[i]);
<1> static int bmp_decode_frame(AVCodecContext *avctx,\n<121> depth = bytestream_get_le16(&buf);\n<127> comp = bytestream_get_le32(&buf);\n<153> rgb[2] = bytestream_get_le32(&buf);\n<265> buf = buf0 + hsize;\n<277> if(n * avctx->height > dsize){\n<291> ptr = p->data[0] + (avctx->height - 1) * p->linesize[0];\n<297> ptr = p->data[0];\n<309> for(i = 0; i < avctx->height; i++){\n<311> memcpy(ptr, buf, n);\n<313> buf += n;\n<315> ptr += linesize;
<1> static GRANT_NAME * name_hash_search ( HASH * name_hash , const char * host , const char * ip , const char * db , const char * user , const char * tname , bool exact , bool name_tolower ) {\n<13> if ( ! grant_name -> host . hostname || ( host && ! my_strcasecmp ( system_charset_info , host , grant_name -> host . hostname ) ) || ( ip && ! strcmp ( ip , grant_name -> host . hostname ) ) ) return grant_name ;\n<16> if ( compare_hostname ( & grant_name -> host , host , ip ) && ( ! found || found -> sort < grant_name -> sort ) ) found = grant_name ;
<1> void vpx_img_free ( vpx_image_t * img ) {\n<3> if ( img -> img_data && img -> img_data_owner ) img_buf_free ( img -> img_data ) ;\n<4> if ( img -> self_allocd ) free ( img ) ;
<1> int test_gf2m_mod_div ( BIO * bp , BN_CTX * ctx ) {\n<43> fprintf ( stderr , "GF(2^m) modular division test failed!\n" ) ;
<1> static void syborg_init(ram_addr_t ram_size,\n<31> if (!env) {\n<33> fprintf(stderr, "Unable to find CPU definition\n");
<1> static PGconn * _connectDB ( ArchiveHandle * AH , const char * reqdb , const char * requser ) {\n<10> if ( ! requser || strlen ( requser ) == 0 ) newuser = PQuser ( AH -> connection ) ;\n<11> else newuser = requser ;\n<12> ahlog ( AH , 1 , "connecting to database \"%s\" as user \"%s\"\n" , newdb , newuser ) ;\n<13> password = AH -> savedPassword ? pg_strdup ( AH -> savedPassword ) : NULL ;\n<14> if ( AH -> promptPassword == TRI_YES && password == NULL ) {\n<16> if ( password == NULL ) exit_horribly ( modulename , "out of memory\n" ) ;\n<20> appendConnStrVal ( & connstr , newdb ) ;\n<29> values [ 2 ] = newuser ;\n<41> if ( PQstatus ( newConn ) == CONNECTION_BAD ) {\n<44> if ( password ) fprintf ( stderr , "Password incorrect\n" ) ;\n<45> fprintf ( stderr , "Connecting to %s as %s\n" , newdb , newuser ) ;\n<46> if ( password ) free ( password ) ;\n<49> if ( password == NULL ) exit_horribly ( modulename , "out of memory\n" ) ;\n<55> if ( AH -> savedPassword ) free ( AH -> savedPassword ) ;\n<58> if ( password ) free ( password ) ;
<1> static int do_stop_slave_sql ( MYSQL * mysql_con ) {\n<6> if ( row && row [ 11 ] ) {\n<7> if ( ! strcmp ( row [ 11 ] , "No" ) ) {\n<8> mysql_free_result ( slave ) ;\n<9> return ( 0 ) ;\n<13> mysql_free_result ( slave ) ;\n<14> if ( mysql_query_with_error_report ( mysql_con , 0 , "STOP SLAVE SQL_THREAD" ) ) return ( 1 ) ;
<1> static void xhci_via_challenge ( XHCIState * xhci , uint64_t addr ) {\n<3> uint32_t buf [ 8 ] ;\n<6> pci_dma_read ( pci_dev , paddr , & buf , 32 ) ;\n<7> memcpy ( obuf , buf , sizeof ( obuf ) ) ;\n<8> if ( ( buf [ 0 ] & 0xff ) == 2 ) {\n<9> obuf [ 0 ] = 0x49932000 + 0x54dc200 * buf [ 2 ] + 0x7429b578 * buf [ 3 ] ;\n<10> obuf [ 0 ] |= ( buf [ 2 ] * buf [ 3 ] ) & 0xff ;\n<11> obuf [ 1 ] = 0x0132bb37 + 0xe89 * buf [ 2 ] + 0xf09 * buf [ 3 ] ;\n<12> obuf [ 2 ] = 0x0066c2e9 + 0x2091 * buf [ 2 ] + 0x19bd * buf [ 3 ] ;\n<13> obuf [ 3 ] = 0xd5281342 + 0x2cc9691 * buf [ 2 ] + 0x2367662 * buf [ 3 ] ;\n<14> obuf [ 4 ] = 0x0123c75c + 0x1595 * buf [ 2 ] + 0x19ec * buf [ 3 ] ;\n<15> obuf [ 5 ] = 0x00f695de + 0x26fd * buf [ 2 ] + 0x3e9 * buf [ 3 ] ;\n<16> obuf [ 6 ] = obuf [ 2 ] ^ obuf [ 3 ] ^ 0x29472956 ;\n<17> obuf [ 7 ] = obuf [ 2 ] ^ obuf [ 3 ] ^ 0x65866593 ;\n<19> pci_dma_write ( pci_dev , paddr , & obuf , 32 ) ;
<1> void evhttp_response_code ( struct evhttp_request * req , int code , const char * reason ) {\n<4> if ( req -> response_code_line != NULL ) free ( req -> response_code_line ) ;\n<5> req -> response_code_line = strdup ( reason ) ;
<1> void curses_display_init(DisplayState *ds, int full_screen)\n<7> if (!isatty(1)) {\n<9> fprintf(stderr, "We need a terminal output\n");
<46> if (avctx->pix_fmt == AV_PIX_FMT_PAL8)\n<47> memcpy(s->frame.data[1], s->palette, s->palette_size);
<1> static int evhttp_header_is_valid_value ( const char * value ) {\n<2> const char * p = value ;\n<3> while ( ( p = strpbrk ( p , "\r\n" ) ) != NULL ) {\n<4> p += strspn ( p , "\r\n" ) ;\n<5> if ( * p != ' ' && * p != '\t' ) return ( 0 ) ;\n<7> return ( 1 ) ;
<1> static void test_prepare_multi_statements ( ) {\n<6> if ( ! ( mysql_local = mysql_client_init ( NULL ) ) ) {\n<7> fprintf ( stderr , "\n mysql_client_init() failed" ) ;\n<10> if ( ! ( mysql_real_connect ( mysql_local , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , CLIENT_MULTI_STATEMENTS ) ) ) {\n<11> fprintf ( stderr , "\n connection failed(%s)" , mysql_error ( mysql_local ) ) ;
<1> void qtest_init(const char *qtest_chrdev, const char *qtest_log)\n<23> if (qtest_log) {\n<25> if (strcmp(qtest_log, "none") != 0) {\n<27> qtest_log_fp = fopen(qtest_log, "w+");
<1> relpRetVal relpTcpConstruct ( relpTcp_t * * ppThis , relpEngine_t * pEngine , int connType , void * pParent ) {\n<4> assert ( ppThis != NULL ) ;\n<5> if ( ( pThis = calloc ( 1 , sizeof ( relpTcp_t ) ) ) == NULL ) {\n<6> ABORT_FINALIZE ( RELP_RET_OUT_OF_MEMORY ) ;\n<8> RELP_CORE_CONSTRUCTOR ( pThis , Tcp ) ;\n<20> pThis -> pristring = NULL ;\n<22> pThis -> caCertFile = NULL ;\n<23> pThis -> ownCertFile = NULL ;\n<24> pThis -> privKeyFile = NULL ;\n<25> pThis -> pUsr = NULL ;
<1> static void assign_failed_examine(AssignedDevice *dev)\n<21> snprintf(name, sizeof(name), "%sdriver", dir);\n<25> r = readlink(name, driver, sizeof(driver));\n<27> if ((r <= 0) || r >= sizeof(driver)) {\n<36> ns = strrchr(driver, '/');
<1> static void fill_slice_long ( AVCodecContext * avctx , DXVA_Slice_H264_Long * slice , unsigned position , unsigned size ) {\n<5> memset ( slice , 0 , sizeof ( * slice ) ) ;\n<13> if ( h -> slice_type_fixed ) slice -> slice_type += 5 ;
<1> static int flic_decode_frame_8BPP(AVCodecContext *avctx,\n<5> FlicDecodeContext *s = avctx->priv_data;\n<31> if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n<33> pixels = s->frame->data[0];\n<55> switch (chunk_type) {\n<90> if (s->palette[palette_ptr] != entry)\n<92> s->palette[palette_ptr++] = entry;\n<113> pixels[pixel_ptr] = line_packets & 0xff;\n<134> pixels[pixel_ptr++] = palette_idx2;\n<141> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<176> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<183> pixels[pixel_ptr++] = palette_idx1;\n<195> s->frame->linesize[0] * s->avctx->height);\n<218> pixels[pixel_ptr++] = palette_idx1;\n<230> pixels[pixel_ptr++] = bytestream2_get_byte(&g2);\n<280> memcpy(s->frame->data[1], s->palette, AVPALETTE_SIZE);
<1> static void cpw_usage ( const char * str ) {\n<2> if ( str ) fprintf ( stderr , "%s\n" , str ) ;\n<3> fprintf ( stderr , _ ( "usage: change_password [-randkey] [-keepold] " "[-e keysaltlist] [-pw password] principal\n" ) ) ;
<1> static int decode_block(AVCodecContext *avctx, void *tdata,\n<31> int axmax = (avctx->width - (s->xmax + 1)) * 2 * s->desc->nb_components; /* nb pixel to add at the right of the datawindow */\n<33> int bxmin = s->xmin * 2 * s->desc->nb_components; /* nb pixel to add at the left of the datawindow */\n<123> bxmin = 0; /* doesn't add pixel at the left of the datawindow */\n<131> axmax = 0; /* doesn't add pixel at the right of the datawindow */\n<305> i < td->ysize; i++, ptr += p->linesize[0]) {\n<329> ptr_x = (uint16_t *) ptr;\n<335> memset(ptr_x, 0, bxmin);\n<337> ptr_x += s->xmin * s->desc->nb_components;\n<359> *ptr_x++ = exr_flt2uint(t.i);\n<365> *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n<387> *ptr_x++ = exr_flt2uint(t.i);\n<395> *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n<411> *ptr_x++ = s->gamma_table[bytestream_get_le16(&rgb[c])];\n<419> *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a));\n<429> *ptr_x++ = bytestream_get_le32(&rgb[c]) >> 16;\n<437> *ptr_x++ = bytestream_get_le32(&a) >> 16;\n<447> memset(ptr_x, 0, axmax);
<1> static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,\n<9> const uint8_t *buf = avpkt->data;\n<17> int sample = 128;\n<45> buf += 4;\n<71> samples     = s->frame.data[0];\n<77> if (in_size == out_size) {\n<79> memcpy(samples, buf, out_size);\n<99> count = *buf & 0x3F;\n<119> if (samples_end - samples < smp)\n<129> if ((buf - avpkt->data) + size > buf_size)\n<135> switch (code) {\n<143> sample += ( code       & 0x3) - 2;\n<163> sample = av_clip_uint8(sample);\n<177> sample += ws_adpcm_4bit[code & 0xF];\n<185> sample = av_clip_uint8(sample);\n<195> if (count & 0x20) { /* big delta */\n<203> sample += t >> 3;\n<205> sample = av_clip_uint8(sample);\n<211> memcpy(samples, buf, smp);\n<213> samples += smp;\n<215> buf     += smp;\n<217> sample = buf[-1];\n<225> memset(samples, sample, smp);\n<227> samples += smp;
<1> static void clone_slice(H264Context *dst, H264Context *src)\n<5> memcpy(dst->block_offset, src->block_offset, sizeof(dst->block_offset));\n<31> memcpy(dst->short_ref,        src->short_ref,        sizeof(dst->short_ref));\n<33> memcpy(dst->long_ref,         src->long_ref,         sizeof(dst->long_ref));\n<35> memcpy(dst->default_ref_list, src->default_ref_list, sizeof(dst->default_ref_list));\n<37> memcpy(dst->ref_list,         src->ref_list,         sizeof(dst->ref_list));\n<41> memcpy(dst->dequant4_coeff,   src->dequant4_coeff,   sizeof(src->dequant4_coeff));\n<43> memcpy(dst->dequant8_coeff,   src->dequant8_coeff,   sizeof(src->dequant8_coeff));
<1> tcp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n<43> if ((so->so_tcpcb = tcp_newtcpcb(so)) == NULL) {\n<45> free(so);
<1> static struct addrinfo *inet_parse_connect_opts(QemuOpts *opts, Error **errp)\n<15> memset(&ai, 0, sizeof(ai));\n<57> rc = getaddrinfo(addr, port, &ai, &res);
<1> static int usbredir_get_bufpq(QEMUFile *f, void *priv, size_t unused)\n<17> for (i = 0; i < endp->bufpq_size; i++) {\n<19> bufp = g_malloc(sizeof(struct buf_packet));\n<21> bufp->len = qemu_get_be32(f);\n<27> bufp->data = qemu_oom_check(malloc(bufp->len)); /* regular malloc! */\n<29> bufp->free_on_destroy = bufp->data;\n<31> qemu_get_buffer(f, bufp->data, bufp->len);
<1> static Datum ExecEvalArray ( ArrayExprState * astate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n<7> int dims [ MAXDIM ] ;\n<8> int lbs [ MAXDIM ] ;\n<35> int * elem_dims = NULL ;\n<36> int * elem_lbs = NULL ;\n<49> subdata = ( char * * ) palloc ( i * sizeof ( char * ) ) ;\n<51> subbytes = ( int * ) palloc ( i * sizeof ( int ) ) ;\n<71> if ( firstone ) {\n<75> elem_dims = ( int * ) palloc ( elem_ndims * sizeof ( int ) ) ;\n<76> memcpy ( elem_dims , ARR_DIMS ( array ) , elem_ndims * sizeof ( int ) ) ;\n<77> elem_lbs = ( int * ) palloc ( elem_ndims * sizeof ( int ) ) ;\n<78> memcpy ( elem_lbs , ARR_LBOUND ( array ) , elem_ndims * sizeof ( int ) ) ;\n<82> if ( elem_ndims != this_ndims || memcmp ( elem_dims , ARR_DIMS ( array ) , elem_ndims * sizeof ( int ) ) != 0 || memcmp ( elem_lbs , ARR_LBOUND ( array ) , elem_ndims * sizeof ( int ) ) != 0 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "multidimensional arrays must have array " "expressions with matching dimensions" ) ) ) ;\n<93> if ( haveempty ) {\n<94> if ( ndims == 0 ) return PointerGetDatum ( construct_empty_array ( element_type ) ) ;\n<97> dims [ 0 ] = outer_nelems ;\n<98> lbs [ 0 ] = 1 ;\n<102> dims [ i ] = elem_dims [ i - 1 ] ;\n<103> lbs [ i ] = elem_lbs [ i - 1 ] ;\n<118> memcpy ( ARR_DIMS ( result ) , dims , ndims * sizeof ( int ) ) ;\n<119> memcpy ( ARR_LBOUND ( result ) , lbs , ndims * sizeof ( int ) ) ;\n<120> dat = ARR_DATA_PTR ( result ) ;\n<123> i < outer_nelems ;\n<125> memcpy ( dat , subdata [ i ] , subbytes [ i ] ) ;\n<126> dat += subbytes [ i ] ;
<1> static test_speed(int step)\n<5> const struct pix_func* pix = pix_func;\n<15> int sum = 0;\n<33> if (!(pix->mm_flags & mm_flags))\n<39> printf("%30s... ", pix->name);\n<61> printf("% 9d\n", (int)(te - ts));\n<63> sum += (te - ts) / 100000;\n<69> pix++;\n<75> printf("Total sum: %d\n", sum);
<1> int ssl3_enc ( SSL * s , SSL3_RECORD * inrecs , unsigned int n_recs , int send ) {\n<7> rec = inrecs ;\n<19> if ( ( s -> session == NULL ) || ( ds == NULL ) || ( enc == NULL ) ) {\n<20> memmove ( rec -> data , rec -> input , rec -> length ) ;\n<21> rec -> input = rec -> data ;\n<26> if ( ( bs != 1 ) && send ) {\n<27> i = bs - ( ( int ) l % bs ) ;\n<29> memset ( & rec -> input [ rec -> length ] , 0 , i ) ;\n<30> rec -> length += i ;\n<31> rec -> input [ l - 1 ] = ( i - 1 ) ;
<1> static int set_property ( const char * name , const char * value , void * opaque ) {\n<3> if ( strcmp ( name , "driver" ) == 0 ) return 0 ;\n<4> if ( strcmp ( name , "bus" ) == 0 ) return 0 ;\n<5> if ( qdev_prop_parse ( dev , name , value ) == - 1 ) {
<1> int event_base_priority_init ( struct event_base * base , int npriorities ) {\n<4> if ( npriorities == base -> nactivequeues ) return ( 0 ) ;\n<5> if ( base -> nactivequeues ) {\n<7> i < base -> nactivequeues ;\n<9> free ( base -> activequeues [ i ] ) ;\n<11> free ( base -> activequeues ) ;\n<13> base -> nactivequeues = npriorities ;\n<14> base -> activequeues = ( struct event_list * * ) calloc ( base -> nactivequeues , sizeof ( struct event_list * ) ) ;\n<15> if ( base -> activequeues == NULL ) event_err ( 1 , "%s: calloc" , __func__ ) ;\n<17> i < base -> nactivequeues ;\n<19> base -> activequeues [ i ] = malloc ( sizeof ( struct event_list ) ) ;\n<20> if ( base -> activequeues [ i ] == NULL ) event_err ( 1 , "%s: malloc" , __func__ ) ;
<1> static int make_setup_request(AVFormatContext *s, const char *host, int port,\n<69> for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n<71> int len = strlen(rt->rtsp_streams[rtx]->control_url);\n<73> if (len >= 4 &&\n<75> !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n<87> rtsp_st = rt->rtsp_streams[rtx];
<1> char * evhttp_decode_uri ( const char * uri ) {\n<3> if ( ( ret = malloc ( strlen ( uri ) + 1 ) ) == NULL ) event_err ( 1 , "%s: malloc(%lu)" , __func__ , ( unsigned long ) ( strlen ( uri ) + 1 ) ) ;\n<4> evhttp_decode_uri_internal ( uri , strlen ( uri ) , ret , 0 ) ;\n<5> return ( ret ) ;
<1> static void selfTest(uint8_t *src[3], int stride[3], int w, int h){\n<13> for(dstFormat = 0; dstFormat < PIX_FMT_NB; dstFormat++) {\n<17> sws_format_name(srcFormat),\n<19> sws_format_name(dstFormat));
<1> static gpgme_error_t gpgsm_delete ( void * engine , gpgme_key_t key , int allow_secret ) {\n<8> if ( ! fpr ) return gpg_error ( GPG_ERR_INV_VALUE ) ;\n<14> length ++ ;\n<15> line = malloc ( length ) ;\n<16> if ( ! line ) return gpg_error_from_syserror ( ) ;\n<17> strcpy ( line , "DELKEYS " ) ;\n<43> err = start ( gpgsm , line ) ;\n<44> free ( line ) ;
<1> static void mode_out ( struct cpio * cpio ) {\n<68> if ( cpio -> dot ) fprintf ( stderr , "\n" ) ;\n<70> if ( ! cpio -> quiet ) {\n<71> int64_t blocks = ( archive_filter_bytes ( cpio -> archive , 0 ) + 511 ) / 512 ;\n<72> fprintf ( stderr , "%lu %s\n" , ( unsigned long ) blocks , blocks == 1 ? "block" : "blocks" ) ;
<1> static int vmd_read_packet(AVFormatContext *s,\n<23> frame = &vmd->frame_table[vmd->current_frame];\n<31> if (av_new_packet(pkt, frame->frame_size + BYTES_PER_FRAME_RECORD))\n<35> memcpy(pkt->data, frame->frame_record, BYTES_PER_FRAME_RECORD);\n<37> ret = get_buffer(pb, pkt->data + BYTES_PER_FRAME_RECORD,
<1> static void nbd_parse_filename(const char *filename, QDict *options,\n<35> if (strstr(filename, "://")) {\n<37> int ret = nbd_parse_uri(filename, options);\n<39> if (ret < 0) {\n<45> return;\n<51> file = g_strdup(filename);\n<55> export_name = strstr(file, EN_OPTSTR);\n<57> if (export_name) {\n<59> if (export_name[strlen(EN_OPTSTR)] == 0) {\n<65> export_name[0] = 0; /* truncate 'file' */\n<67> export_name += strlen(EN_OPTSTR);\n<71> qdict_put(options, "export", qstring_from_str(export_name));\n<79> if (!strstart(file, "nbd:", &host_spec)) {\n<131> g_free(file);
<1> static cmsBool BuildAbsolutePath ( const char * relPath , const char * basePath , char * buffer , cmsUInt32Number MaxLen ) {\n<4> if ( isabsolutepath ( relPath ) ) {\n<5> strncpy ( buffer , relPath , MaxLen ) ;\n<6> buffer [ MaxLen - 1 ] = 0 ;\n<9> strncpy ( buffer , basePath , MaxLen ) ;\n<10> buffer [ MaxLen - 1 ] = 0 ;\n<11> tail = strrchr ( buffer , DIR_CHAR ) ;\n<13> len = ( cmsUInt32Number ) ( tail - buffer ) ;\n<14> if ( len >= MaxLen ) return FALSE ;\n<15> strncpy ( tail + 1 , relPath , MaxLen - len ) ;
<1> int MPV_common_init(MpegEncContext *s)\n<23> if((s->width || s->height) && avcodec_check_dimensions(s->avctx, s->width, s->height))\n<29> dsputil_init(&s->dsp, s->avctx);\n<31> ff_dct_common_init(s);\n<35> s->flags= s->avctx->flags;\n<37> s->flags2= s->avctx->flags2;\n<47> s->b4_stride = s->mb_width*4 + 1;\n<65> s->h_edge_pos= s->mb_width*16;\n<67> s->v_edge_pos= s->mb_height*16;\n<71> s->mb_num = s->mb_width * s->mb_height;\n<89> y_size = s->b8_stride * (2 * s->mb_height + 1);\n<99> s->codec_tag=          toupper( s->avctx->codec_tag     &0xFF)\n<109> s->stream_codec_tag=          toupper( s->avctx->stream_codec_tag     &0xFF)\n<123> CHECKED_ALLOCZ(s->mb_index2xy, (s->mb_num+1)*sizeof(int)) //error ressilience code looks cleaner with this\n<135> s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; //FIXME really needed?\n<143> CHECKED_ALLOCZ(s->p_mv_table_base            , mv_table_size * 2 * sizeof(int16_t))\n<145> CHECKED_ALLOCZ(s->b_forw_mv_table_base       , mv_table_size * 2 * sizeof(int16_t))\n<147> CHECKED_ALLOCZ(s->b_back_mv_table_base       , mv_table_size * 2 * sizeof(int16_t))\n<149> CHECKED_ALLOCZ(s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t))\n<151> CHECKED_ALLOCZ(s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t))\n<153> CHECKED_ALLOCZ(s->b_direct_mv_table_base     , mv_table_size * 2 * sizeof(int16_t))\n<155> s->p_mv_table           = s->p_mv_table_base            + s->mb_stride + 1;\n<157> s->b_forw_mv_table      = s->b_forw_mv_table_base       + s->mb_stride + 1;\n<159> s->b_back_mv_table      = s->b_back_mv_table_base       + s->mb_stride + 1;\n<161> s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n<163> s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n<165> s->b_direct_mv_table    = s->b_direct_mv_table_base     + s->mb_stride + 1;\n<171> CHECKED_ALLOCZ(s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int));\n<181> CHECKED_ALLOCZ(s->mb_type  , mb_array_size * sizeof(uint16_t)) //needed for encoding\n<185> CHECKED_ALLOCZ(s->lambda_table, mb_array_size * sizeof(int))\n<189> CHECKED_ALLOCZ(s->q_intra_matrix, 64*32 * sizeof(int))\n<191> CHECKED_ALLOCZ(s->q_inter_matrix, 64*32 * sizeof(int))\n<193> CHECKED_ALLOCZ(s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t))\n<195> CHECKED_ALLOCZ(s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t))\n<197> CHECKED_ALLOCZ(s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*))\n<199> CHECKED_ALLOCZ(s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*))\n<205> CHECKED_ALLOCZ(s->dct_offset, 2 * 64 * sizeof(uint16_t))\n<211> CHECKED_ALLOCZ(s->picture, MAX_PICTURE_COUNT * sizeof(Picture))\n<215> CHECKED_ALLOCZ(s->error_status_table, mb_array_size*sizeof(uint8_t))\n<219> if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){\n<251> if (s->out_format == FMT_H263) {\n<255> CHECKED_ALLOCZ(s->ac_val_base, yc_size * sizeof(int16_t) * 16);\n<267> CHECKED_ALLOCZ(s->coded_block_base, y_size);\n<269> s->coded_block= s->coded_block_base + s->b8_stride + 1;\n<275> CHECKED_ALLOCZ(s->cbp_table  , mb_array_size * sizeof(uint8_t))\n<277> CHECKED_ALLOCZ(s->pred_dir_table, mb_array_size * sizeof(uint8_t))\n<283> if (s->h263_pred || s->h263_plus || !s->encoding) {\n<289> CHECKED_ALLOCZ(s->dc_val_base, yc_size * sizeof(int16_t));\n<307> CHECKED_ALLOCZ(s->mbintra_table, mb_array_size);\n<309> memset(s->mbintra_table, 1, mb_array_size);\n<315> CHECKED_ALLOCZ(s->mbskip_table, mb_array_size+2);\n<319> CHECKED_ALLOCZ(s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE);\n<331> s->visualization_buffer[2] = av_malloc((s->mb_width*8 + EDGE_WIDTH) * s->mb_height*8 + EDGE_WIDTH);\n<337> s->context_initialized = 1;\n<341> s->thread_context[0]= s;\n<347> threads = s->codec_id == CODEC_ID_H264 ? 1 : s->avctx->thread_count;\n<351> for(i=1; i<threads; i++){\n<353> s->thread_context[i]= av_malloc(sizeof(MpegEncContext));\n<355> memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n<363> if(init_duplicate_context(s->thread_context[i], s) < 0)\n<379> MPV_common_end(s);
<1> static void qpeg_decode_inter(QpegContext *qctx, uint8_t *dst,\n<7> uint8_t *refdata)\n<23> for(i = 0; i < height; i++)\n<25> memcpy(refdata + (i * width), dst + (i * stride), width);\n<99> if ((me_x + filled < 0) || (me_x + me_w + filled > width) ||\n<103> (filled + me_w > width) || (height - me_h < 0))\n<113> me_plane = refdata + (filled + me_x) + (height - me_y) * width;\n<153> if(filled >= width) {\n<179> if(filled >= width) {\n<221> while( filled >= width) {\n<249> if(filled >= width) {
<1> void evhttp_connection_free ( struct evhttp_connection * evcon ) {\n<4> if ( evhttp_connected ( evcon ) && evcon -> closecb != NULL ) ( * evcon -> closecb ) ( evcon , evcon -> closecb_arg ) ;\n<6> while ( ( req = TAILQ_FIRST ( & evcon -> requests ) ) != NULL ) {\n<7> TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n<10> if ( evcon -> http_server != NULL ) {\n<12> TAILQ_REMOVE ( & http -> connections , evcon , next ) ;\n<14> if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;\n<15> if ( event_initialized ( & evcon -> ev ) ) event_del ( & evcon -> ev ) ;\n<16> if ( evcon -> fd != - 1 ) EVUTIL_CLOSESOCKET ( evcon -> fd ) ;\n<17> if ( evcon -> bind_address != NULL ) free ( evcon -> bind_address ) ;\n<18> if ( evcon -> address != NULL ) free ( evcon -> address ) ;\n<19> if ( evcon -> input_buffer != NULL ) evbuffer_free ( evcon -> input_buffer ) ;\n<20> if ( evcon -> output_buffer != NULL ) evbuffer_free ( evcon -> output_buffer ) ;\n<21> free ( evcon ) ;
<2> G722Context * c = avctx -> priv_data ;\n<30> c -> prev_samples [ c -> prev_samples_pos ++ ] = rlow - rhigh ;\n<31> ff_g722_apply_qmf ( c -> prev_samples + c -> prev_samples_pos - 24 , & xout1 , & xout2 ) ;\n<34> if ( c -> prev_samples_pos >= PREV_SAMPLES_BUF_SIZE ) {\n<35> memmove ( c -> prev_samples , c -> prev_samples + c -> prev_samples_pos - 22 , 22 * sizeof ( c -> prev_samples [ 0 ] ) ) ;
<1> static void restore_time_zone ( FILE * sql_file , const char * delimiter ) {\n<2> fprintf ( sql_file , "/*!50003 SET time_zone = @saved_time_zone */ %s\n" , ( const char * ) delimiter ) ;
<1> static void handle_lockprop_ctx ( struct xml_ctx * ctx , int tag_closed ) {\n<3> if ( tag_closed ) {\n<4> if ( ! strcmp ( ctx -> name , DAV_CTX_LOCKENTRY ) ) {\n<5> if ( ( * lock_flags & DAV_PROP_LOCKEX ) && ( * lock_flags & DAV_PROP_LOCKWR ) ) {\n<8> * lock_flags &= DAV_LOCK_OK ;\n<10> else if ( ! strcmp ( ctx -> name , DAV_CTX_LOCKTYPE_WRITE ) ) {\n<11> * lock_flags |= DAV_PROP_LOCKWR ;\n<13> else if ( ! strcmp ( ctx -> name , DAV_CTX_LOCKTYPE_EXCLUSIVE ) ) {\n<14> * lock_flags |= DAV_PROP_LOCKEX ;
<1> static uint32_t get_cmd(ESPState *s, uint8_t *buf, uint8_t buflen)\n<29> dmalen = s->ti_size;\n<34> memcpy(buf, s->ti_buf, dmalen);\n<36> buf[0] = buf[2] >> 5;\n<39> trace_esp_get_cmd(dmalen, target);\n<74> esp_raise_irq(s);
<1> bool ftrace_init(void)\n<17> if (debugfs_found) {\n<71> fprintf(stderr, "debugfs is not mounted\n");
<1> static void dumpdbl ( FILE * cfff , double d ) {\n<2> if ( d - rint ( d ) > - .00001 && d - rint ( d ) < .00001 ) dumpint ( cfff , ( int ) d ) ;\n<4> char buffer [ 20 ] , * pt ;\n<6> sprintf ( buffer , "%g" , d ) ;\n<10> for ( pt = buffer ;
<1> void kvm_set_phys_mem(target_phys_addr_t start_addr,\n<17> if (start_addr & ~TARGET_PAGE_MASK) {\n<19> fprintf(stderr, "Only page-aligned memory slots supported\n");\n<33> mem = kvm_lookup_slot(s, start_addr);\n<67> if ((phys_offset - (start_addr - mem->start_addr)) ==\n<77> memcpy(&slot, mem, sizeof(slot));\n<81> kvm_set_user_memory_region(s, mem);\n<123> printf("Registering overlapping slot\n");
<1> void free_varlist ( struct ctl_var * kv ) {\n<3> if ( kv ) {\n<4> for ( k = kv ;\n<5> ! ( k -> flags & EOV ) ;\n<6> k ++ ) free ( ( void * ) ( intptr_t ) k -> text ) ;\n<7> free ( ( void * ) kv ) ;
<1> static void test_bug5315 ( ) {\n<6> stmt_text = "SELECT 1" ;\n<7> stmt = mysql_stmt_init ( mysql ) ;\n<8> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<10> if ( ! opt_silent ) printf ( "Excuting mysql_change_user\n" ) ;\n<12> if ( ! opt_silent ) printf ( "Excuting mysql_stmt_execute\n" ) ;\n<13> rc = mysql_stmt_execute ( stmt ) ;\n<16> if ( ! opt_silent ) printf ( "Got error (as expected): '%s'\n" , mysql_stmt_error ( stmt ) ) ;\n<18> if ( ! opt_silent ) printf ( "Excuting mysql_stmt_close\n" ) ;\n<20> if ( ! opt_silent ) printf ( "Excuting mysql_stmt_init\n" ) ;\n<21> stmt = mysql_stmt_init ( mysql ) ;\n<22> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<24> rc = mysql_stmt_execute ( stmt ) ;
<1> static void make_key_128 ( u_char * string , u_char * key ) {\n<14> MD5_Final ( digest , & ctx ) ;\n<15> memset ( key , 0 , MAX_WKEY_LEN ) ;\n<16> memcpy ( key , digest , 13 ) ;
<1> static void DumpGlyphToNameMap ( char * fontname , SplineFont * sf ) {\n<3> char * newname = malloc ( strlen ( fontname ) + 10 ) ;\n<7> strcpy ( newname , fontname ) ;\n<8> d = strrchr ( newname , '/' ) ;\n<11> if ( e == NULL ) e = newname + strlen ( newname ) ;\n<12> strcpy ( e , ".g2n" ) ;\n<13> file = fopen ( newname , "wb" ) ;\n<14> if ( file == NULL ) {\n<15> LogError ( _ ( "Failed to open glyph to name map file for writing: %s\n" ) , newname ) ;\n<16> free ( newname ) ;\n<35> if ( sc != NULL && sc -> ttf_glyph != - 1 ) {\n<36> fprintf ( file , "GLYPHID %d\tPSNAME %s" , sc -> ttf_glyph , sc -> name ) ;\n<37> if ( sc -> unicodeenc != - 1 ) fprintf ( file , "\tUNICODE %04X" , sc -> unicodeenc ) ;\n<38> putc ( '\n' , file ) ;\n<42> free ( newname ) ;
<1> CURLcode Curl_urldecode ( struct Curl_easy * data , const char * string , size_t length , char * * ostring , size_t * olen , bool reject_ctrl ) {\n<2> size_t alloc = ( length ? length : strlen ( string ) ) + 1 ;\n<3> char * ns = malloc ( alloc ) ;\n<8> if ( ! ns ) return CURLE_OUT_OF_MEMORY ;\n<9> while ( -- alloc > 0 ) {\n<11> if ( ( '%' == in ) && ( alloc > 2 ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) {\n<14> hexstr [ 0 ] = string [ 1 ] ;\n<15> hexstr [ 1 ] = string [ 2 ] ;\n<20> if ( result ) {\n<21> free ( ns ) ;\n<24> string += 2 ;\n<27> if ( reject_ctrl && ( in < 0x20 ) ) {\n<28> free ( ns ) ;\n<31> ns [ strindex ++ ] = in ;\n<32> string ++ ;
<1> static int img_convert(int argc, char **argv)\n<29> char *options = NULL;\n<53> if (c == -1) {\n<111> options = optarg;\n<185> if (options && !strcmp(options, "?")) {\n<187> ret = print_block_option_help(out_filename, out_fmt);\n<195> if (bs_n > 1 && out_baseimg) {\n<309> param = parse_option_parameters(options, create_options, param);\n<393> if (preallocation && preallocation->value.s\n<395> && strcmp(preallocation->value.s, "off"))\n<425> } else if (ret == -EFBIG) {\n<433> error_report("%s: error while converting %s: %s",\n<435> out_filename, out_fmt, strerror(-ret));\n<477> buf = qemu_blockalign(out_bs, IO_BUF_SIZE);\n<613> if (n < cluster_sectors) {\n<615> memset(buf + n * 512, 0, cluster_size - n * 512);\n<619> if (!buffer_is_zero(buf, cluster_size)) {\n<821> qemu_progress_end();\n<823> free_option_parameters(create_options);\n<825> free_option_parameters(param);\n<827> qemu_vfree(buf);\n<829> if (out_bs) {\n<835> if (bs) {\n<851> if (ret) {
<1> Object *object_dynamic_cast_assert(Object *obj, const char *typename)\n<9> inst = object_dynamic_cast(obj, typename);\n<13> if (!inst) {\n<15> fprintf(stderr, "Object %p is not an instance of type %s\n",
<1> static int64_t load_kernel (CPUMIPSState *env)\n<19> if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n<25> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<43> initrd_size = get_image_size (loaderparams.initrd_filename);\n<49> if (initrd_offset + initrd_size > ram_size) {\n<61> initrd_size = load_image_targphys(loaderparams.initrd_filename,\n<67> if (initrd_size == (target_ulong) -1) {\n<69> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<89> prom_set(prom_buf, index++, "%s", loaderparams.kernel_filename);
<1> static void maybe_die ( int error_num , const char * fmt_reason , ... ) {\n<5> my_vsnprintf ( buffer , sizeof ( buffer ) , fmt_reason , args ) ;\n<7> fprintf ( stderr , "%s: %s\n" , my_progname_short , buffer ) ;\n<8> fflush ( stderr ) ;
<1> static int execute_code ( AVCodecContext * avctx , int c ) {\n<50> if ( ret < 0 ) {\n<56> memcpy ( s -> frame -> data [ 1 ] , ff_cga_palette , 16 * 4 ) ;\n<65> if ( s -> y < avctx -> height - s -> font_height ) memset ( s -> frame -> data [ 0 ] + ( s -> y + s -> font_height ) * s -> frame -> linesize [ 0 ] , DEFAULT_BG_COLOR , ( avctx -> height - s -> y - s -> font_height ) * s -> frame -> linesize [ 0 ] ) ;\n<68> if ( s -> y > 0 ) memset ( s -> frame -> data [ 0 ] , DEFAULT_BG_COLOR , s -> y * s -> frame -> linesize [ 0 ] ) ;
<1> static void test_ps_i18n ( ) {\n<6> const char * koi8 = "\xee\xd5\x2c\x20\xda\xc1\x20\xd2\xd9\xc2\xc1\xcc\xcb\xd5" ;\n<7> const char * cp1251 = "\xcd\xf3\x2c\x20\xe7\xe0\x20\xf0\xfb\xe1\xe0\xeb\xea\xf3" ;\n<11> stmt_text = "DROP TABLE IF EXISTS t1" ;\n<12> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<14> stmt_text = "CREATE TABLE t1 (c1 VARBINARY(255), c2 VARBINARY(255))" ;\n<15> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<17> stmt_text = "SET CHARACTER_SET_CLIENT=koi8r, " "CHARACTER_SET_CONNECTION=cp1251, " "CHARACTER_SET_RESULTS=koi8r" ;\n<18> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<20> memset ( bind_array , 0 , sizeof ( bind_array ) ) ;\n<23> bind_array [ 0 ] . buffer_length = strlen ( koi8 ) ;\n<25> bind_array [ 1 ] . buffer = ( void * ) koi8 ;\n<26> bind_array [ 1 ] . buffer_length = strlen ( koi8 ) ;\n<27> stmt = mysql_stmt_init ( mysql ) ;\n<28> check_stmt ( stmt ) ;\n<29> stmt_text = "INSERT INTO t1 (c1, c2) VALUES (?, ?)" ;\n<30> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<31> check_execute ( stmt , rc ) ;\n<32> mysql_stmt_bind_param ( stmt , bind_array ) ;\n<33> mysql_stmt_send_long_data ( stmt , 0 , koi8 , strlen ( koi8 ) ) ;\n<35> check_execute ( stmt , rc ) ;\n<36> stmt_text = "SELECT c1, c2 FROM t1" ;\n<37> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<38> check_execute ( stmt , rc ) ;\n<50> DIE_UNLESS ( buf1_len == strlen ( cp1251 ) ) ;\n<51> DIE_UNLESS ( buf2_len == strlen ( cp1251 ) ) ;\n<52> DIE_UNLESS ( ! memcmp ( buf1 , cp1251 , buf1_len ) ) ;\n<53> DIE_UNLESS ( ! memcmp ( buf2 , cp1251 , buf1_len ) ) ;\n<54> rc = mysql_stmt_fetch ( stmt ) ;\n<56> stmt_text = "DROP TABLE IF EXISTS t1" ;\n<57> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<59> stmt_text = "CREATE TABLE t1 (c1 VARCHAR(255) CHARACTER SET cp1251, " "c2 VARCHAR(255) CHARACTER SET cp1251)" ;\n<60> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<62> stmt_text = "INSERT INTO t1 (c1, c2) VALUES (?, ?)" ;\n<63> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<64> check_execute ( stmt , rc ) ;\n<67> bind_array [ 0 ] . buffer_length = strlen ( koi8 ) ;\n<69> bind_array [ 1 ] . buffer = ( void * ) koi8 ;\n<70> bind_array [ 1 ] . buffer_length = strlen ( koi8 ) ;\n<72> mysql_stmt_send_long_data ( stmt , 0 , koi8 , strlen ( koi8 ) ) ;\n<76> bind_array [ 0 ] . buffer = ( void * ) cp1251 ;\n<77> bind_array [ 0 ] . buffer_length = strlen ( cp1251 ) ;\n<79> bind_array [ 1 ] . buffer = ( void * ) cp1251 ;\n<80> bind_array [ 1 ] . buffer_length = strlen ( cp1251 ) ;\n<82> mysql_stmt_send_long_data ( stmt , 0 , cp1251 , strlen ( cp1251 ) ) ;\n<84> check_execute ( stmt , rc ) ;\n<85> stmt_text = "SELECT c1, c2 FROM t1" ;\n<86> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<87> check_execute ( stmt , rc ) ;\n<90> bind_array [ 0 ] . buffer = buf1 ;\n<92> bind_array [ 0 ] . length = & buf1_len ;\n<93> bind_array [ 1 ] . buffer = buf2 ;\n<95> bind_array [ 1 ] . length = & buf2_len ;\n<97> while ( ( rc = mysql_stmt_fetch ( stmt ) ) == 0 ) {\n<98> DIE_UNLESS ( buf1_len == strlen ( koi8 ) ) ;\n<99> DIE_UNLESS ( buf2_len == strlen ( koi8 ) ) ;\n<100> DIE_UNLESS ( ! memcmp ( buf1 , koi8 , buf1_len ) ) ;\n<101> DIE_UNLESS ( ! memcmp ( buf2 , koi8 , buf1_len ) ) ;\n<105> stmt_text = "DROP TABLE t1" ;\n<106> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<108> stmt_text = "SET NAMES DEFAULT" ;\n<109> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb,\n<9> uint16_t *use_mask = use_mask_mem + 2;\n<73> memset(&use_mask[-2], 0, 2 * sizeof(use_mask[0]));\n<75> memset( use_mask,   -1, 5 * sizeof(use_mask[0]));\n<77> memset(&use_mask[5], 0, 2 * sizeof(use_mask[0]));\n<85> uint16_t *use_mask_ptr = &use_mask[idx >> 4];\n<129> idx -= av_log2_16bit(use_mask[idx >> 4]);\n<133> if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) {\n<135> use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15));
<1> void usage_exit ( ) {\n<2> fprintf ( stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
<1> static int sp5x_decode_frame(AVCodecContext *avctx,\n<37> if (!recoded)\n<47> recoded[j++] = 0xD8;\n<51> memcpy(recoded+j, &sp5x_data_dqt[0], sizeof(sp5x_data_dqt));\n<53> memcpy(recoded+j+5, &sp5x_quant_table[qscale * 2], 64);\n<55> memcpy(recoded+j+70, &sp5x_quant_table[(qscale * 2) + 1], 64);\n<57> j += sizeof(sp5x_data_dqt);\n<61> memcpy(recoded+j, &sp5x_data_dht[0], sizeof(sp5x_data_dht));\n<63> j += sizeof(sp5x_data_dht);\n<67> memcpy(recoded+j, &sp5x_data_sof[0], sizeof(sp5x_data_sof));\n<73> j += sizeof(sp5x_data_sof);\n<77> memcpy(recoded+j, &sp5x_data_sos[0], sizeof(sp5x_data_sos));
<1> static void spapr_alloc_htab(sPAPRMachineState *spapr)\n<23> if (shift > 0) {\n<43> spapr->htab = qemu_memalign(HTAB_SIZE(spapr), HTAB_SIZE(spapr));\n<49> memset(spapr->htab, 0, HTAB_SIZE(spapr));\n<53> for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n<55> DIRTY_HPTE(HPTE(spapr->htab, index));
<1> static int tpm_passthrough_open_sysfs_cancel(TPMPassthruState *tpm_pt)\n<17> if (fd < 0) {\n<19> error_report("Could not open TPM cancel path : %s",\n<21> strerror(errno));\n<43> if (fd >= 0) {\n<49> error_report("tpm_passthrough: Could not open TPM cancel "\n<51> "path %s : %s", path, strerror(errno));
<1> static int expand_zero_clusters_in_l1(BlockDriverState *bs, uint64_t *l1_table,\n<219> if (cluster_index >= *nb_clusters) {\n<237> *expanded_clusters = g_realloc(*expanded_clusters,\n<243> memset(&(*expanded_clusters)[old_bitmap_size], 0,\n<245> new_bitmap_size - old_bitmap_size);
<1> static const char * cmd_cookie_format ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n<3> if ( strcmp ( p1 , "0" ) == 0 ) dcfg -> cookie_format = COOKIES_V0 ;\n<4> else if ( strcmp ( p1 , "1" ) == 0 ) dcfg -> cookie_format = COOKIES_V1 ;\n<6> return apr_psprintf ( cmd -> pool , "ModSecurity: Invalid cookie format: %s" , p1 ) ;\n<8> return NULL ;
<1> int ff_insert_pad(unsigned idx, unsigned *count, size_t padidx_off,\n<5> AVFilterPad *newpad)\n<17> idx = FFMIN(idx, *count);\n<21> newpads  = av_realloc_array(*pads,  *count + 1, sizeof(AVFilterPad));\n<23> newlinks = av_realloc_array(*links, *count + 1, sizeof(AVFilterLink*));\n<27> *pads  = newpads;\n<31> *links = newlinks;\n<33> if (!newpads || !newlinks)\n<39> memmove(*pads  + idx + 1, *pads  + idx, sizeof(AVFilterPad)   * (*count - idx));\n<41> memmove(*links + idx + 1, *links + idx, sizeof(AVFilterLink*) * (*count - idx));\n<43> memcpy(*pads + idx, newpad, sizeof(AVFilterPad));
<1> struct archive_string * archive_string_ensure ( struct archive_string * as , size_t s ) {\n<4> if ( as -> s && ( s <= as -> buffer_length ) ) return ( as ) ;\n<5> if ( as -> buffer_length < 32 ) new_length = 32 ;\n<6> else if ( as -> buffer_length < 8192 ) new_length = as -> buffer_length + as -> buffer_length ;\n<9> if ( new_length < as -> buffer_length ) {\n<15> if ( new_length < s ) new_length = s ;\n<16> p = ( char * ) realloc ( as -> s , new_length ) ;\n<17> if ( p == NULL ) {\n<18> archive_string_free ( as ) ;\n<23> as -> buffer_length = new_length ;
<1> SDState *sd_init(BlockDriverState *bs, bool is_spi)\n<9> if (bdrv_is_read_only(bs)) {\n<11> fprintf(stderr, "sd_init: Cannot use read-only drive\n");
<1> static void test_simple_delete ( ) {\n<28> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<38> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static int img_compare(int argc, char **argv)\n<237> if (total_sectors1 < 0) {\n<241> filename1, strerror(-total_sectors1));\n<251> if (total_sectors2 < 0) {\n<255> filename2, strerror(-total_sectors2));
<1> void check_time_sanity ( int * e ) {\n<2> if ( start_time == ( time_t ) 0 ) error [ ( * e ) ++ ] . message = strdup ( "Start time can't be zero or date format couldn't be recognized correctly" ) ;\n<3> if ( end_time == ( time_t ) 0 ) error [ ( * e ) ++ ] . message = strdup ( "End time can't be zero or date format couldn't be recognized correctly" ) ;\n<4> if ( end_time < start_time ) error [ ( * e ) ++ ] . message = strdup ( "End date before start date" ) ;
<1> static int read_colors ( GetBitContext * gb , Bundle * b , BinkContext * c ) {\n<4> CHECK_READ_VAL ( gb , b , t ) ;\n<10> if ( get_bits1 ( gb ) ) {\n<13> v = ( c -> col_lastval << 4 ) | v ;\n<17> v += 0x80 ;\n<19> memset ( b -> cur_dec , v , t ) ;\n<20> b -> cur_dec += t ;
<1> static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,\n<11> const uint8_t *buf             = avpkt->data;\n<117> } else if (need_copy) {\n<119> memcpy(frame->buf[0]->data, buf, FFMIN(buf_size, context->frame_size));\n<121> buf = frame->buf[0]->data;\n<141> av_buffer_unref(&frame->buf[0]);\n<153> av_buffer_unref(&frame->buf[0]);\n<163> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE,\n<173> context->palette = av_buffer_alloc(AVPALETTE_SIZE);\n<175> if (!context->palette) {\n<177> av_buffer_unref(&frame->buf[0]);\n<183> memcpy(context->palette->data, pal, AVPALETTE_SIZE);\n<235> frame->buf[1]  = av_buffer_ref(context->palette);\n<239> av_buffer_unref(&frame->buf[0]);
<1> void _decode_opc(DisasContext * ctx)\n<1845> switch (ctx->opcode & 0xf0ff) {\n<2335> if (ctx->opcode & 0x0100)\n<2369> if (ctx->opcode & 0x0100)\n<2419> if (ctx->opcode & 0x0100)\n<2453> if (ctx->opcode & 0x0100)\n<2489> if (!(ctx->fpscr & FPSCR_PR)) {\n<2505> if (!(ctx->fpscr & FPSCR_PR)) {\n<2555> fprintf(stderr, "unknown instruction 0x%04x at pc 0x%08x\n",
<1> REGRESSION_TEST ( SDK_API_TSUrlParse ) ( RegressionTest * test , int , int * pstatus ) {\n<28> const char * url = urls [ idx ] ;\n<30> if ( TSUrlCreate ( bufp , & url_loc ) != TS_SUCCESS ) {\n<38> end = url + strlen ( url ) ;\n<39> if ( ( retval = TSUrlParse ( bufp , url_loc , & start , end ) ) == TS_PARSE_ERROR ) {\n<40> SDK_RPRINT ( test , "TSUrlParse" , url , TC_FAIL , "TSUrlParse returns TS_PARSE_ERROR" ) ;\n<45> if ( strncmp ( url , temp , length ) == 0 ) {\n<55> SDK_RPRINT ( test , "TSUrlParse" , url , TC_FAIL , "Parsing Error" ) ;
<1> static int vpc_create(const char *filename, QEMUOptionParameter *options)\n<5> uint8_t buf[1024];\n<7> struct vhd_footer* footer = (struct vhd_footer*) buf;\n<29> while (options && options->name) {\n<31> if (!strcmp(options->name, "size")) {\n<33> total_sectors = options->value.n / 512;\n<37> options++;\n<55> if (calculate_geometry(total_sectors, &cyls, &heads, &secs_per_cyl))\n<65> memset(buf, 0, 1024);\n<69> memcpy(footer->creator, "conectix", 8);\n<73> memcpy(footer->creator_app, "qemu", 4);\n<75> memcpy(footer->creator_os, "Wi2k", 4);\n<119> footer->checksum = be32_to_cpu(vpc_checksum(buf, HEADER_SIZE));\n<141> if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE)\n<149> if (lseek(fd, 3 * 512, SEEK_SET) < 0)\n<155> memset(buf, 0xFF, 512);\n<157> for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++)\n<159> if (write(fd, buf, 512) != 512)\n<169> memset(buf, 0, 1024);\n<173> memcpy(dyndisk_header->magic, "cxsparse", 8);\n<189> dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));
<1> static void usbredir_interrupt_packet(void *priv, uint64_t id,\n<5> uint8_t *data, int data_len)\n<21> if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n<25> free(data);\n<35> if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n<39> free(data);
<1> static int zrsdparams ( i_ctx_t * i_ctx_p ) {\n<33> i < r_size ( pFilter ) ;\n<39> if ( r_size ( & fname ) < 6 || memcmp ( fname . value . bytes + r_size ( & fname ) - 6 , "Decode" , 6 ) ) return_error ( gs_error_rangecheck ) ;
<1> static void add_cdps ( linked_list_t * list , linked_list_t * uris , linked_list_t * issuers ) {\n<7> if ( gn_to_string ( id , & uri ) ) {\n<8> if ( issuers -> get_count ( issuers ) ) {\n<15> free ( uri ) ;
<1> void parse_options(int argc, char **argv, const OptionDef *options,\n<25> if (handleoptions && opt[0] == '-' && opt[1] != '\0') {\n<29> if (opt[1] == '-' && opt[2] == '\0') {\n<39> po= find_option(options, opt);\n<41> if (!po->name && opt[0] == 'n' && opt[1] == 'o') {\n<47> if (!(po->name && (po->flags & OPT_BOOL)))\n<59> if (!po->name) {\n<63> fprintf(stderr, "%s: unrecognized option '%s'\n", argv[0], opt);\n<75> if (!arg) {\n<77> fprintf(stderr, "%s: missing argument for option '%s'\n", argv[0], opt);\n<99> *po->u.int_arg = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n<103> *po->u.int64_arg = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n<107> *po->u.float_arg = parse_number_or_die(opt, arg, OPT_FLOAT, -1.0/0.0, 1.0/0.0);\n<111> if (po->u.func2_arg(opt, arg) < 0) {\n<113> fprintf(stderr, "%s: invalid value '%s' for option '%s'\n", argv[0], arg, opt);
<1> void kvm_arch_pre_run ( CPUState * cpu , struct kvm_run * run ) {\n<12> if ( ret < 0 ) {\n<13> fprintf ( stderr , "KVM: injection failed, NMI lost (%s)\n" , strerror ( - ret ) ) ;\n<22> if ( ret < 0 ) {\n<23> fprintf ( stderr , "KVM: injection failed, SMI lost (%s)\n" , strerror ( - ret ) ) ;\n<48> if ( ret < 0 ) {\n<49> fprintf ( stderr , "KVM: injection failed, interrupt lost (%s)\n" , strerror ( - ret ) ) ;
<1> static ArchiveHandle * _allocAH ( const char * FileSpec , const ArchiveFormat fmt , const int compression , ArchiveMode mode , SetupWorkerPtr setupWorkerPtr ) {\n<30> memset ( & ( AH -> sqlparse ) , 0 , sizeof ( AH -> sqlparse ) ) ;
<1> static void timeout ( struct parse * pcmd , FILE * fp ) {\n<3> if ( pcmd -> nargs == 0 ) {\n<4> val = ( int ) tvout . tv_sec * 1000 + tvout . tv_usec / 1000 ;\n<5> ( void ) fprintf ( fp , "primary timeout %d ms\n" , val ) ;
<1> static void vc1_decode_skip_blocks ( VC1Context * v ) {\n<6> s -> mb_y < s -> end_mb_y ;\n<11> memcpy ( s -> dest [ 0 ] , s -> last_picture . f . data [ 0 ] + s -> mb_y * 16 * s -> linesize , s -> linesize * 16 ) ;\n<12> memcpy ( s -> dest [ 1 ] , s -> last_picture . f . data [ 1 ] + s -> mb_y * 8 * s -> uvlinesize , s -> uvlinesize * 8 ) ;\n<13> memcpy ( s -> dest [ 2 ] , s -> last_picture . f . data [ 2 ] + s -> mb_y * 8 * s -> uvlinesize , s -> uvlinesize * 8 ) ;
<1> static ssize_t rtl8139_do_receive(NetClientState *nc, const uint8_t *buf, size_t size_, int do_interrupt)\n<21> uint8_t buf1[MIN_BUF_SIZE + VLAN_HLEN];\n<65> if (s->RxConfig & AcceptAllPhys) {\n<75> if (!memcmp(buf,  broadcast_macaddr, 6)) {\n<79> if (!(s->RxConfig & AcceptBroadcast))\n<113> } else if (buf[0] & 0x01) {\n<137> int mcast_idx = compute_mcast_idx(buf);\n<175> } else if (s->phys[0] == buf[0] &&\n<177> s->phys[1] == buf[1] &&\n<179> s->phys[2] == buf[2] &&\n<181> s->phys[3] == buf[3] &&\n<183> s->phys[4] == buf[4] &&\n<185> s->phys[5] == buf[5]) {\n<249> if (size < MIN_BUF_SIZE + VLAN_HLEN) {\n<251> memcpy(buf1, buf, size);\n<253> memset(buf1 + size, 0, MIN_BUF_SIZE + VLAN_HLEN - size);\n<255> buf = buf1;\n<403> dot1q_buf = &buf[ETH_ALEN * 2];\n<485> pci_dma_write(d, rx_addr, buf, 2 * ETH_ALEN);\n<489> buf + 2 * ETH_ALEN + VLAN_HLEN,\n<495> pci_dma_write(d, rx_addr, buf, size);\n<513> val = cpu_to_le32(crc32(0, buf, size_));\n<711> rtl8139_write_buffer(s, buf, size);
<1> void _zip_dirent_finalize ( struct zip_dirent * zde ) {\n<2> if ( zde -> filename_len > 0 ) {\n<3> free ( zde -> filename ) ;\n<6> if ( zde -> extrafield_len > 0 ) {\n<7> free ( zde -> extrafield ) ;\n<10> if ( zde -> comment_len > 0 ) {\n<11> free ( zde -> comment ) ;
<1> static char * create_delimiter ( char * query , char * delimiter_buff , int delimiter_max_size ) {\n<4> delimiter_buff [ 0 ] = ';\n<7> proposed_length < delimiter_max_size ;\n<9> delimiter_buff [ proposed_length - 1 ] = ';\n<11> delimiter_buff [ proposed_length ] = '\0' ;\n<12> presence = strstr ( query , delimiter_buff ) ;\n<13> if ( presence == NULL ) {\n<14> return delimiter_buff ;
<1> int fourcc_is_ivf ( const char detect [ 4 ] ) {\n<2> if ( memcmp ( detect , "DKIF" , 4 ) == 0 ) {\n<3> return 1 ;\n<5> return 0 ;
<1> void dtls1_get_message_header ( unsigned char * data , struct hm_header_st * msg_hdr ) {\n<2> memset ( msg_hdr , 0 , sizeof ( * msg_hdr ) ) ;\n<4> n2l3 ( data , msg_hdr -> msg_len ) ;\n<5> n2s ( data , msg_hdr -> seq ) ;\n<6> n2l3 ( data , msg_hdr -> frag_off ) ;\n<7> n2l3 ( data , msg_hdr -> frag_len ) ;
<1> static int unpack(const uint8_t *src, const uint8_t *src_end, unsigned char *dst, int width, int height) {\n<27> src += 3;\n<31> while(size>0 && src<src_end) {\n<45> if ( src[0] < 0xFC )  // !(111111)\n<47> size1 = (((src[0] & 31) + 1) << 2);\n<55> offset = ((src[0] & 0x10) << 12) + AV_RB16(&src[1]) + 1;\n<57> size2 = ((src[0] & 0xC) << 6) + src[3] + 5;\n<65> size1 = ( ( src[1] & 0xC0) >> 6 );\n<67> offset = (AV_RB16(&src[1]) & 0x3FFF) + 1;\n<69> size2 = (src[0] & 0x3F) + 4;\n<79> size2 = ((src[0] & 0x1C) >> 2) + 3;\n<91> if (size1>src_end-src)\n<97> if (size1>0) {\n<101> run = FFMIN(size1, dst_end-dst);\n<103> memcpy(dst, src, run);\n<105> dst += run;\n<107> src += run;
<1> static struct search_state * search_state_new ( void ) {\n<2> struct search_state * state = ( struct search_state * ) malloc ( sizeof ( struct search_state ) ) ;\n<3> if ( ! state ) return NULL ;\n<4> memset ( state , 0 , sizeof ( struct search_state ) ) ;\n<7> return state ;
<1> static int posix_aio_init(void)\n<39> if (s->fd == -1) {\n<41> fprintf(stderr, "failed to create signalfd\n");
<1> static void compute_stats(HTTPContext *c)\n<71> if (stream->feed != stream) {\n<73> av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);\n<75> eosf = sfilename + strlen(sfilename);\n<77> if (eosf - sfilename >= 4) {\n<79> if (strcmp(eosf - 4, ".asf") == 0)\n<81> strcpy(eosf - 4, ".asx");\n<83> else if (strcmp(eosf - 3, ".rm") == 0)\n<85> strcpy(eosf - 3, ".ram");\n<87> else if (!strcmp(stream->fmt->name, "rtp")) {\n<95> eosf = strrchr(sfilename, '.');\n<97> if (!eosf)\n<99> eosf = sfilename + strlen(sfilename);\n<101> if (stream->is_multicast)\n<103> strcpy(eosf, ".sdp");\n<107> strcpy(eosf, ".rtsp");\n<115> url_fprintf(pb, "<TR><TD><A HREF=\"/%s\">%s</A> ",\n<199> url_fprintf(pb, "<TD align=center> %s <TD align=right> %d <TD align=right> %d <TD> %s %s <TD align=right> %d <TD> %s %s",
<1> static int blk_get_request(struct XenBlkDev *blkdev, struct ioreq *ioreq, RING_IDX rc)\n<5> switch (blkdev->protocol) {\n<9> memcpy(&ioreq->req, RING_GET_REQUEST(&blkdev->rings.native, rc),
<1> static int matroska_parse_frame(MatroskaDemuxContext *matroska,\n<5> uint8_t *data, int pkt_size,\n<15> uint8_t *pkt_data = data;\n<17> int offset = 0, res;\n<25> res = matroska_decode_buffer(&pkt_data, &pkt_size, track);\n<39> res = matroska_parse_wavpack(track, pkt_data, &wv_data, &pkt_size);\n<51> if (pkt_data != data)\n<54> pkt_data = wv_data;\n<62> offset = 8;\n<70> if (av_new_packet(pkt, pkt_size + offset) < 0) {\n<85> bytestream_put_be32(&buf, pkt_size);\n<93> memcpy(pkt->data + offset, pkt_data, pkt_size);\n<97> if (pkt_data != data)
<1> static inline int usb_bt_fifo_dequeue(struct usb_hci_in_fifo_s *fifo,\n<3> USBPacket *p)\n<11> if (likely(!fifo->len))\n<17> len = MIN(p->len, fifo->fifo[fifo->start].len);\n<19> memcpy(p->data, fifo->fifo[fifo->start].data, len);\n<21> if (len == p->len) {\n<25> fifo->fifo[fifo->start].data += len;
<1> int main ( int argc , char * argv [ ] ) {\n<62> memset ( & vacopts , 0 , sizeof ( vacopts ) ) ;\n<63> progname = get_progname ( argv [ 0 ] ) ;\n<66> while ( ( c = getopt_long ( argc , argv , "h:p:U:wWeqd:zZFat:fvj:" , long_options , & optindex ) ) != - 1 ) {\n<67> switch ( c ) {\n<102> if ( concurrentCons <= 0 ) {\n<103> fprintf ( stderr , _ ( "%s: number of parallel jobs must be at least 1\n" ) , progname ) ;\n<106> if ( concurrentCons > FD_SETSIZE - 1 ) {\n<107> fprintf ( stderr , _ ( "%s: too many parallel jobs requested (maximum: %d)\n" ) , progname , FD_SETSIZE - 1 ) ;\n<115> default : fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<123> if ( optind < argc ) {\n<124> fprintf ( stderr , _ ( "%s: too many command-line arguments (first is \"%s\")\n" ) , progname , argv [ optind ] ) ;\n<125> fprintf ( stderr , _ ( "Try \"%s --help\" for more information.\n" ) , progname ) ;\n<129> if ( vacopts . full ) {\n<130> fprintf ( stderr , _ ( "%s: cannot use the \"%s\" option when performing only analyze\n" ) , progname , "full" ) ;\n<133> if ( vacopts . freeze ) {\n<134> fprintf ( stderr , _ ( "%s: cannot use the \"%s\" option when performing only analyze\n" ) , progname , "freeze" ) ;\n<141> if ( dbname ) {\n<142> fprintf ( stderr , _ ( "%s: cannot vacuum all databases and a specific one at the same time\n" ) , progname ) ;\n<145> if ( tables . head != NULL ) {\n<146> fprintf ( stderr , _ ( "%s: cannot vacuum specific table(s) in all databases\n" ) , progname ) ;\n<149> vacuum_all_databases ( & vacopts , analyze_in_stages , maintenance_db , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;\n<152> if ( dbname == NULL ) {\n<153> if ( getenv ( "PGDATABASE" ) ) dbname = getenv ( "PGDATABASE" ) ;\n<154> else if ( getenv ( "PGUSER" ) ) dbname = getenv ( "PGUSER" ) ;\n<155> else dbname = get_user_name_or_exit ( progname ) ;\n<162> vacuum_one_database ( dbname , & vacopts , stage , & tables , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;\n<165> else vacuum_one_database ( dbname , & vacopts , ANALYZE_NO_STAGE , & tables , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;
<1> int tls1_mac ( SSL * ssl , SSL3_RECORD * rec , unsigned char * md , int send ) {\n<7> unsigned char header [ 13 ] ;\n<11> seq = RECORD_LAYER_get_write_sequence ( & ssl -> rlayer ) ;\n<15> seq = RECORD_LAYER_get_read_sequence ( & ssl -> rlayer ) ;\n<29> if ( SSL_IS_DTLS ( ssl ) ) {\n<30> unsigned char dtlsseq [ 8 ] , * p = dtlsseq ;\n<31> s2n ( send ? DTLS_RECORD_LAYER_get_w_epoch ( & ssl -> rlayer ) : DTLS_RECORD_LAYER_get_r_epoch ( & ssl -> rlayer ) , p ) ;\n<32> memcpy ( p , & seq [ 2 ] , 6 ) ;\n<33> memcpy ( header , dtlsseq , 8 ) ;\n<35> else memcpy ( header , seq , 8 ) ;\n<42> if ( ssl3_cbc_digest_record ( mac_ctx , md , & md_size , header , rec -> input , rec -> length + md_size , rec -> orig_len , ssl -> s3 -> read_mac_secret , ssl -> s3 -> read_mac_secret_size , 0 ) <= 0 ) {\n<78> ++ seq [ i ] ;\n<79> if ( seq [ i ] != 0 ) break ;
<1> static int decode_subframe(WmallDecodeCtx *s)\n<237> if (s->is_channel_coded[i]) {\n<253> memset(s->channel_residues[i], 0, sizeof(**s->channel_residues) * subframe_len);
<1> int msmpeg4_decode_picture_header(MpegEncContext * s)\n<37> fprintf(stderr, "invalid startcode\n");\n<54> fprintf(stderr, "invalid picture type\n");\n<81> code = get_bits(&s->gb, 5);\n<101> fprintf(stderr, "error, slice code was %X\n", code);\n<107> s->slice_height = s->mb_height / (code - 0x16);
<1> bool add_edge_h ( connection_t * c ) {\n<5> char to_name [ MAX_STRING_SIZE ] ;\n<15> if ( ! check_id ( from_name ) || ! check_id ( to_name ) || ! strcmp ( from_name , to_name ) ) {\n<22> from = lookup_node ( from_name ) ;\n<23> to = lookup_node ( to_name ) ;
<1> static int mon_init_func(QemuOpts *opts, void *opaque)\n<17> if (mode == NULL) {\n<19> mode = "readline";\n<23> if (strcmp(mode, "readline") == 0) {\n<25> flags = MONITOR_USE_READLINE;\n<27> } else if (strcmp(mode, "control") == 0) {\n<29> flags = MONITOR_USE_CONTROL;\n<33> fprintf(stderr, "unknown monitor mode \"%s\"\n", mode);\n<35> exit(1);\n<55> chr = qemu_chr_find(chardev);\n<57> if (chr == NULL) {\n<59> fprintf(stderr, "chardev \"%s\" not found\n", chardev);
<1> static int usb_bt_handle_control(USBDevice *dev, USBPacket *p,\n<13> ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n<95> if ((index & ~1) || length != 0 ||\n<97> (index == 1 && (value < 0 || value > 4)) ||\n<99> (index == 0 && value != 0)) {\n<101> printf("%s: Wrong SET_INTERFACE request (%i, %i)\n",
<1> static int wavpack_encode_block(WavPackEncodeContext *s,\n<2> int32_t *samples_l, int32_t *samples_r,\n<14> diff |= samples_l[i] - samples_r[i];\n<36> shift_mono(samples_l, nb_samples, shift);\n<38> shift_stereo(samples_l, samples_r, nb_samples, shift);\n<44> if ((s->flags & WV_FLOAT_DATA) || (s->flags & MAG_MASK) >> MAG_LSB >= 24) {\n<45> av_fast_padded_malloc(&s->orig_l, &s->orig_l_size, sizeof(int32_t) * nb_samples);\n<46> memcpy(s->orig_l, samples_l, sizeof(int32_t) * nb_samples);\n<47> if (!(s->flags & WV_MONO_DATA)) {\n<48> av_fast_padded_malloc(&s->orig_r, &s->orig_r_size, sizeof(int32_t) * nb_samples);\n<49> memcpy(s->orig_r, samples_r, sizeof(int32_t) * nb_samples);\n<52> got_extra = scan_float(s, samples_l, samples_r, nb_samples);\n<54> got_extra = scan_int32(s, samples_l, samples_r, nb_samples);\n<66> ret = wv_mono(s, samples_l, 1, 0);\n<68> ret = wv_stereo(s, samples_l, samples_r, 1, 0);\n<75> ret = wv_mono(s, samples_l, !s->num_terms, 1);\n<80> ret = wv_stereo(s, samples_l, samples_r, !s->num_terms, 1);\n<161> WRITE_DECSAMPLE(dpp->samplesA[0]);\n<162> WRITE_DECSAMPLE(dpp->samplesA[1]);\n<164> WRITE_DECSAMPLE(dpp->samplesB[0]);\n<165> WRITE_DECSAMPLE(dpp->samplesB[1]);\n<168> WRITE_DECSAMPLE(dpp->samplesA[0]);\n<169> WRITE_DECSAMPLE(dpp->samplesB[0]);\n<172> WRITE_DECSAMPLE(dpp->samplesA[j]);\n<174> WRITE_DECSAMPLE(dpp->samplesB[j]);\n<219> dpp->samplesA[1] = dpp->samplesA[0];\n<220> dpp->samplesA[0] = code;\n<223> dpp->samplesA[(m + dpp->value) & (MAX_TERM - 1)] = code;\n<232> for (tcount = s->num_terms, dpp = s->decorr_passes; tcount--; dpp++)\n<233> if (dpp->value > 0 && dpp->value <= MAX_TERM) {\n<234> int32_t temp_A[MAX_TERM], temp_B[MAX_TERM];\n<236> memcpy(temp_A, dpp->samplesA, sizeof(dpp->samplesA));\n<237> memcpy(temp_B, dpp->samplesB, sizeof(dpp->samplesB));\n<239> dpp->samplesA[k] = temp_A[m];\n<240> dpp->samplesB[k] = temp_B[m];\n<262> wavpack_encode_sample(s, &s->w.c[0], s->samples[0][i]);\n<265> wavpack_encode_sample(s, &s->w.c[0], s->samples[0][i]);\n<266> wavpack_encode_sample(s, &s->w.c[1], s->samples[1][i]);\n<269> encode_flush(s);\n<280> pack_float(s, s->orig_l, s->orig_r, nb_samples);\n<282> pack_int32(s, s->orig_l, s->orig_r, nb_samples);
<1> static int s_aes_process ( stream_state * ss , stream_cursor_read * pr , stream_cursor_write * pw , bool last ) {\n<2> stream_aes_state * const state = ( stream_aes_state * ) ss ;\n<4> const long in_size = pr -> limit - pr -> ptr ;\n<5> const long out_size = pw -> limit - pw -> ptr ;\n<18> if ( state -> ctx == NULL ) {\n<22> memset ( state -> ctx , 0x00 , sizeof ( aes_context ) ) ;\n<27> aes_setkey_dec ( state -> ctx , state -> key , state -> keylength * 8 ) ;\n<30> if ( in_size < 16 ) return 0 ;\n<31> memcpy ( state -> iv , pr -> ptr + 1 , 16 ) ;\n<36> aes_crypt_cbc ( state -> ctx , AES_DECRYPT , 16 , state -> iv , pr -> ptr + 1 , temp ) ;\n<38> if ( last && pr -> ptr == pr -> limit ) {\n<50> memcpy ( pw -> ptr + 1 , temp , 16 - pad ) ;\n<54> memcpy ( pw -> ptr + 1 , temp , 16 ) ;\n<55> pw -> ptr += 16 ;
<1> void tb_flush_jmp_cache ( CPUArchState * env , target_ulong addr ) {\n<4> memset ( & env -> tb_jmp_cache [ i ] , 0 , TB_JMP_PAGE_SIZE * sizeof ( TranslationBlock * ) ) ;\n<6> memset ( & env -> tb_jmp_cache [ i ] , 0 , TB_JMP_PAGE_SIZE * sizeof ( TranslationBlock * ) ) ;
<1> static int pubkey_get_npkey ( int algorithm ) {\n<7> if ( pubkey ) {\n<8> npkey = strlen ( ( ( gcry_pk_spec_t * ) pubkey -> spec ) -> elements_pkey ) ;\n<12> return npkey ;
<1> aio_write_done(void *opaque, int ret)\n<5> struct aio_ctx *ctx = opaque;\n<17> if (ret < 0) {\n<19> printf("aio_write failed: %s\n", strerror(-ret));\n<27> if (ctx->qflag) {\n<37> t2 = tsub(t2, ctx->t1);\n<39> print_report("wrote", &t2, ctx->offset, ctx->qiov.size,\n<45> qemu_io_free(ctx->buf);\n<47> free(ctx);
<1> char *target_strerror(int err)\n<8> return strerror(target_to_host_errno(err));
<1> static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n<55> uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n<139> if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n<145> if (s != mac_data.entries * ETH_ALEN) {\n<169> memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n<171> g_free(macs);
<1> void dtls1_clear ( SSL * s ) {\n<7> if ( s -> d1 ) {\n<12> dtls1_clear_queues ( s ) ;\n<13> memset ( s -> d1 , 0 , sizeof ( * s -> d1 ) ) ;\n<17> if ( SSL_get_options ( s ) & SSL_OP_NO_QUERY_MTU ) {\n<24> ssl3_clear ( s ) ;
<1> CURLcode glob_match_url ( char * * result , char * filename , URLGlob * glob ) {\n<5> char * appendthis = NULL ;\n<6> size_t appendlen = 0 ;\n<9> allocsize = strlen ( filename ) + 1 ;\n<10> target = malloc ( allocsize ) ;\n<11> if ( ! target ) return CURLE_OUT_OF_MEMORY ;\n<13> if ( * filename == '#' && ISDIGIT ( filename [ 1 ] ) ) {\n<15> char * ptr = filename ;\n<17> URLPattern * pat = NULL ;\n<24> pat = & glob -> pattern [ i ] ;\n<30> switch ( pat -> type ) {\n<31> case UPTSet : if ( pat -> content . Set . elements ) {\n<32> appendthis = pat -> content . Set . elements [ pat -> content . Set . ptr_s ] ;\n<33> appendlen = strlen ( pat -> content . Set . elements [ pat -> content . Set . ptr_s ] ) ;\n<36> case UPTCharRange : numbuf [ 0 ] = pat -> content . CharRange . ptr_c ;\n<37> numbuf [ 1 ] = 0 ;\n<38> appendthis = numbuf ;\n<39> appendlen = 1 ;\n<41> case UPTNumRange : snprintf ( numbuf , sizeof ( numbuf ) , "%0*d" , pat -> content . NumRange . padlength , pat -> content . NumRange . ptr_n ) ;\n<42> appendthis = numbuf ;\n<43> appendlen = strlen ( numbuf ) ;\n<45> default : fprintf ( stderr , "internal error: invalid pattern type (%d)\n" , ( int ) pat -> type ) ;\n<46> Curl_safefree ( target ) ;\n<52> appendthis = filename ++ ;\n<53> appendlen = 1 ;\n<57> appendthis = filename ++ ;\n<58> appendlen = 1 ;\n<60> if ( appendlen + stringlen >= allocsize ) {\n<62> allocsize = ( appendlen + stringlen ) * 2 ;\n<63> newstr = realloc ( target , allocsize + 1 ) ;\n<64> if ( ! newstr ) {\n<65> Curl_safefree ( target ) ;\n<68> target = newstr ;\n<70> memcpy ( & target [ stringlen ] , appendthis , appendlen ) ;\n<71> stringlen += appendlen ;
<1> static pid_t qtest_qemu_pid(QTestState *s)\n<13> f = fopen(s->pid_file, "r");\n<15> if (f) {\n<17> if (fgets(buffer, sizeof(buffer), f)) {\n<19> pid = atoi(buffer);\n<23> fclose(f);
<1> static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)\n<11> const char *boot_cpu = s->boot_cpu ? s->boot_cpu : "apu-cpu[0]";\n<105> for (i = 0; i < XLNX_ZYNQMP_NUM_APU_CPUS; i++) {\n<119> name = object_get_canonical_path_component(OBJECT(&s->apu_cpu[i]));\n<121> if (strcmp(name, boot_cpu)) {\n<125> object_property_set_bool(OBJECT(&s->apu_cpu[i]), true,\n<127> "start-powered-off", &error_abort);\n<131> s->boot_cpu_ptr = &s->apu_cpu[i];\n<135> g_free(name);\n<179> for (i = 0; i < XLNX_ZYNQMP_NUM_RPU_CPUS; i++) {\n<185> name = object_get_canonical_path_component(OBJECT(&s->rpu_cpu[i]));\n<187> if (strcmp(name, boot_cpu)) {\n<191> object_property_set_bool(OBJECT(&s->rpu_cpu[i]), true,\n<193> "start-powered-off", &error_abort);\n<197> s->boot_cpu_ptr = &s->rpu_cpu[i];\n<201> g_free(name);\n<227> error_setg(errp, "ZynqMP Boot cpu %s not found\n", boot_cpu);
<1> static void imdct_output ( TwinContext * tctx , enum FrameType ftype , int wtype , float * * out ) {\n<4> float * prev_buf = tctx -> prev_frame + tctx -> last_block_pos [ 0 ] ;\n<9> imdct_and_window ( tctx , ftype , wtype , tctx -> spectrum + i * mtab -> size , prev_buf + 2 * i * mtab -> size , i ) ;\n<11> if ( ! out ) return ;\n<14> memcpy ( & out [ 0 ] [ 0 ] , prev_buf , size1 * sizeof ( out [ 0 ] [ 0 ] ) ) ;\n<15> memcpy ( & out [ 0 ] [ size1 ] , tctx -> curr_frame , size2 * sizeof ( out [ 0 ] [ 0 ] ) ) ;\n<16> if ( tctx -> avctx -> channels == 2 ) {\n<17> memcpy ( & out [ 1 ] [ 0 ] , & prev_buf [ 2 * mtab -> size ] , size1 * sizeof ( out [ 1 ] [ 0 ] ) ) ;\n<18> memcpy ( & out [ 1 ] [ size1 ] , & tctx -> curr_frame [ 2 * mtab -> size ] , size2 * sizeof ( out [ 1 ] [ 0 ] ) ) ;\n<19> tctx -> fdsp . butterflies_float ( out [ 0 ] , out [ 1 ] , mtab -> size ) ;
<1> static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , const uint8_t * src , const uint8_t * src_end , int width , int esc_count ) {\n<10> count = FFMIN ( l -> zeros_rem , width - i ) ;\n<11> if ( end - dst < count ) {\n<15> memset ( dst , 0 , count ) ;\n<16> l -> zeros_rem -= count ;\n<17> dst += count ;\n<19> while ( dst < end ) {\n<20> i = 0 ;\n<22> i ++ ;\n<24> zero_run = ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ;\n<26> if ( zero_run ) {\n<28> i += esc_count ;\n<29> memcpy ( dst , src , i ) ;\n<30> dst += i ;\n<31> l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ;\n<32> src += i + 1 ;\n<36> memcpy ( dst , src , i ) ;\n<37> src += i ;\n<38> dst += i ;
<1> static int parallels_create(const char *filename, QemuOpts *opts, Error **errp)\n<80> memcpy(header.magic, HEADER_MAGIC2, sizeof(header.magic));
<1> static int ape_decode_frame(AVCodecContext *avctx,\n<13> APEContext *s = avctx->priv_data;\n<79> if (s->samples <= 0) {\n<89> memset(s->decoded0,  0, sizeof(s->decoded0));\n<91> memset(s->decoded1,  0, sizeof(s->decoded1));\n<97> init_frame_decoder(s);\n<125> ape_unpack_mono(s, blockstodecode);\n<129> ape_unpack_stereo(s, blockstodecode);
<1> static void http_terminate_chunked_test ( void ) {\n<8> fprintf ( stdout , "Testing Terminated Chunked Connection: " ) ;\n<13> bev = bufferevent_new ( fd , terminate_readcb , http_writecb , http_errorcb , NULL ) ;\n<16> http_request = "GET /test HTTP/1.1\r\n" "Host: some\r\n\r\n" ;\n<17> bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n<22> if ( test_ok != 1 ) {\n<23> fprintf ( stdout , "FAILED\n" ) ;\n<26> fprintf ( stdout , "OK\n" ) ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<6> unsigned char * encoded = ( unsigned char * ) buf ;\n<22> outptr = frame -> data [ 0 ] ;\n<40> encoded = c -> decomp_buf ;\n<49> encoded = c -> decomp_buf ;\n<113> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<128> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<129> encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n<130> encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n<131> encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n<132> encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n<133> encoded [ pixel_ptr + 5 ] = uq -= encoded [ pixel_ptr + 5 ] ;\n<134> encoded [ pixel_ptr + 6 ] = vq -= encoded [ pixel_ptr + 6 ] ;\n<135> encoded [ pixel_ptr + 7 ] = vq -= encoded [ pixel_ptr + 7 ] ;\n<148> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<149> encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n<150> encoded [ pixel_ptr + 2 ] = yq -= encoded [ pixel_ptr + 2 ] ;\n<151> encoded [ pixel_ptr + 3 ] = yq -= encoded [ pixel_ptr + 3 ] ;\n<152> encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n<153> encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n<166> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<167> encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n<168> encoded [ pixel_ptr + 2 ] = uq -= encoded [ pixel_ptr + 2 ] ;\n<169> encoded [ pixel_ptr + 3 ] = vq -= encoded [ pixel_ptr + 3 ] ;\n<182> encoded [ pixel_ptr ] = yq -= encoded [ pixel_ptr ] ;\n<183> encoded [ pixel_ptr + 1 ] = yq -= encoded [ pixel_ptr + 1 ] ;\n<184> encoded [ pixel_ptr + 2 ] = y1q -= encoded [ pixel_ptr + 2 ] ;\n<185> encoded [ pixel_ptr + 3 ] = y1q -= encoded [ pixel_ptr + 3 ] ;\n<186> encoded [ pixel_ptr + 4 ] = uq -= encoded [ pixel_ptr + 4 ] ;\n<187> encoded [ pixel_ptr + 5 ] = vq -= encoded [ pixel_ptr + 5 ] ;\n<196> y_out = frame -> data [ 0 ] + ( height - 1 ) * frame -> linesize [ 0 ] ;\n<219> col < width - 3 ;\n<221> memcpy ( y_out + col , encoded , 4 ) ;\n<222> encoded += 4 ;\n<226> v_out [ ( col >> 1 ) + 1 ] = * encoded ++ + 128 ;\n<228> y_out -= frame -> linesize [ 0 ] ;\n<234> row >= 0 ;\n<236> pixel_ptr = row * frame -> linesize [ 0 ] ;\n<237> memcpy ( outptr + pixel_ptr , encoded , 3 * width ) ;\n<238> encoded += 3 * width ;\n<245> col < width - 3 ;\n<247> memcpy ( y_out + col , encoded , 4 ) ;\n<248> encoded += 4 ;\n<250> v_out [ col >> 2 ] = * encoded ++ + 128 ;\n<252> y_out -= frame -> linesize [ 0 ] ;\n<261> col < width - 1 ;\n<263> memcpy ( y_out + col , encoded , 2 ) ;\n<264> encoded += 2 ;\n<266> v_out [ col >> 1 ] = * encoded ++ + 128 ;\n<268> y_out -= frame -> linesize [ 0 ] ;\n<279> col < width - 1 ;\n<281> memcpy ( y_out + col , encoded , 2 ) ;\n<282> encoded += 2 ;\n<283> memcpy ( y_out + col - frame -> linesize [ 0 ] , encoded , 2 ) ;\n<284> encoded += 2 ;\n<286> v_out [ col >> 1 ] = * encoded ++ + 128 ;\n<288> y_out -= frame -> linesize [ 0 ] << 1 ;
<1> static void *spapr_create_fdt_skel(const char *cpu_model,\n<39> _FDT((fdt_create(fdt, FDT_MAX_SIZE)));\n<41> _FDT((fdt_add_reservemap_entry(fdt, KERNEL_LOAD_ADDR, kernel_size)));\n<43> _FDT((fdt_add_reservemap_entry(fdt, initrd_base, initrd_size)));\n<44> _FDT((fdt_finish_reservemap(fdt)));\n<46> _FDT((fdt_begin_node(fdt, "")));\n<47> _FDT((fdt_property_string(fdt, "device_type", "chrp")));\n<48> _FDT((fdt_property_string(fdt, "model", "IBM pSeries (emulated by qemu)")));\n<49> _FDT((fdt_property_cell(fdt, "#address-cells", 0x2)));\n<50> _FDT((fdt_property_cell(fdt, "#size-cells", 0x2)));\n<52> _FDT((fdt_begin_node(fdt, "chosen")));\n<54> _FDT((fdt_property(fdt, "ibm,architecture-vec-5", vec5, sizeof(vec5))));\n<55> _FDT((fdt_property_string(fdt, "bootargs", kernel_cmdline)));\n<56> _FDT((fdt_property(fdt, "linux,initrd-start",\n<58> _FDT((fdt_property(fdt, "linux,initrd-end",\n<63> _FDT((fdt_property(fdt, "qemu,boot-kernel", &kprop, sizeof(kprop))));\n<64> _FDT((fdt_property_string(fdt, "qemu,boot-device", boot_device)));\n<65> _FDT((fdt_end_node(fdt)));\n<73> _FDT((fdt_begin_node(fdt, "memory@0")));\n<74> _FDT((fdt_property_string(fdt, "device_type", "memory")));\n<75> _FDT((fdt_property(fdt, "reg", mem_reg_property,\n<77> _FDT((fdt_property(fdt, "ibm,associativity", associativity,\n<79> _FDT((fdt_end_node(fdt)));\n<85> _FDT((fdt_begin_node(fdt, mem_name)));\n<86> _FDT((fdt_property_string(fdt, "device_type", "memory")));\n<87> _FDT((fdt_property(fdt, "reg", mem_reg_property,\n<89> _FDT((fdt_property(fdt, "ibm,associativity", associativity,\n<91> _FDT((fdt_end_node(fdt)));\n<99> _FDT((fdt_begin_node(fdt, mem_name)));\n<100> _FDT((fdt_property_string(fdt, "device_type", "memory")));\n<101> _FDT((fdt_property(fdt, "reg", mem_reg_property,\n<103> _FDT((fdt_property(fdt, "ibm,associativity", associativity,\n<105> _FDT((fdt_end_node(fdt)));\n<108> _FDT((fdt_begin_node(fdt, "cpus")));\n<109> _FDT((fdt_property_cell(fdt, "#address-cells", 0x1)));\n<110> _FDT((fdt_property_cell(fdt, "#size-cells", 0x0)));\n<132> _FDT((fdt_begin_node(fdt, nodename)));\n<134> _FDT((fdt_property_cell(fdt, "reg", index)));\n<135> _FDT((fdt_property_string(fdt, "device_type", "cpu")));\n<136> _FDT((fdt_property_cell(fdt, "cpu-version", env->spr[SPR_PVR])));\n<137> _FDT((fdt_property_cell(fdt, "dcache-block-size",\n<139> _FDT((fdt_property_cell(fdt, "icache-block-size",\n<141> _FDT((fdt_property_cell(fdt, "timebase-frequency", tbfreq)));\n<142> _FDT((fdt_property_cell(fdt, "clock-frequency", cpufreq)));\n<143> _FDT((fdt_property_cell(fdt, "ibm,slb-size", env->slb_nr)));\n<144> _FDT((fdt_property(fdt, "ibm,pft-size",\n<146> _FDT((fdt_property_string(fdt, "status", "okay")));\n<147> _FDT((fdt_property(fdt, "64-bit", NULL, 0)));\n<154> _FDT((fdt_property(fdt, "ibm,ppc-interrupt-server#s",\n<156> _FDT((fdt_property(fdt, "ibm,ppc-interrupt-gserver#s",\n<159> _FDT((fdt_property(fdt, "ibm,processor-segment-sizes",\n<167> _FDT((fdt_property_cell(fdt, "ibm,vmx", vmx)));\n<172> _FDT((fdt_property_cell(fdt, "ibm,dfp", 1)));\n<173> _FDT((fdt_end_node(fdt)));\n<175> _FDT((fdt_end_node(fdt)));\n<177> _FDT((fdt_begin_node(fdt, "rtas")));\n<178> _FDT((fdt_property(fdt, "ibm,hypertas-functions", hypertas_prop,\n<180> _FDT((fdt_property(fdt, "ibm,associativity-reference-points",\n<182> _FDT((fdt_end_node(fdt)));\n<184> _FDT((fdt_begin_node(fdt, "interrupt-controller")));\n<185> _FDT((fdt_property_string(fdt, "device_type",\n<187> _FDT((fdt_property_string(fdt, "compatible", "IBM,ppc-xicp")));\n<188> _FDT((fdt_property(fdt, "interrupt-controller", NULL, 0)));\n<189> _FDT((fdt_property(fdt, "ibm,interrupt-server-ranges",\n<192> _FDT((fdt_property_cell(fdt, "#interrupt-cells", 2)));\n<193> _FDT((fdt_property_cell(fdt, "linux,phandle", PHANDLE_XICP)));\n<194> _FDT((fdt_property_cell(fdt, "phandle", PHANDLE_XICP)));\n<195> _FDT((fdt_end_node(fdt)));\n<197> _FDT((fdt_begin_node(fdt, "vdevice")));\n<198> _FDT((fdt_property_string(fdt, "device_type", "vdevice")));\n<199> _FDT((fdt_property_string(fdt, "compatible", "IBM,vdevice")));\n<200> _FDT((fdt_property_cell(fdt, "#address-cells", 0x1)));\n<201> _FDT((fdt_property_cell(fdt, "#size-cells", 0x0)));\n<202> _FDT((fdt_property_cell(fdt, "#interrupt-cells", 0x2)));\n<203> _FDT((fdt_property(fdt, "interrupt-controller", NULL, 0)));\n<204> _FDT((fdt_end_node(fdt)));\n<205> _FDT((fdt_end_node(fdt))); /* close root node */\n<206> _FDT((fdt_finish(fdt)));
<1> AVBitStreamFilterContext *av_bitstream_filter_init(const char *name){\n<3> AVBitStreamFilter *bsf= first_bitstream_filter;\n<7> while(bsf){\n<9> if(!strcmp(name, bsf->name)){\n<11> AVBitStreamFilterContext *bsfc= av_mallocz(sizeof(AVBitStreamFilterContext));\n<13> bsfc->filter= bsf;\n<15> bsfc->priv_data= av_mallocz(bsf->priv_data_size);\n<17> return bsfc;\n<21> bsf= bsf->next;
<1> int ff_mpv_common_frame_size_change(MpegEncContext *s)\n<9> if (!s->context_initialized)\n<15> if (s->slice_context_count > 1) {\n<19> free_duplicate_context(s->thread_context[i]);\n<23> for (i = 1; i < s->slice_context_count; i++) {\n<25> av_freep(&s->thread_context[i]);\n<53> s->current_picture_ptr      = NULL;\n<59> if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n<61> s->mb_height = (s->height + 31) / 32 * 2;\n<65> s->mb_height = (s->height + 15) / 16;\n<69> if ((s->width || s->height) &&\n<71> (err = av_image_check_size(s->width, s->height, 0, s->avctx)) < 0)\n<77> if ((err = init_context_frame(s)))\n<83> memset(s->thread_context, 0, sizeof(s->thread_context));\n<85> s->thread_context[0]   = s;\n<89> if (s->width && s->height) {\n<91> int nb_slices = s->slice_context_count;\n<97> if (i) {\n<99> s->thread_context[i] = av_malloc(sizeof(MpegEncContext));\n<101> memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n<105> if ((err = init_duplicate_context(s->thread_context[i])) < 0)\n<111> (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n<115> (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n<121> err = init_duplicate_context(s);\n<143> ff_mpv_common_end(s);
<1> static int receive_filter ( VirtIONet * n , const uint8_t * buf , int size ) {\n<8> uint8_t * ptr = ( uint8_t * ) buf ;\n<10> if ( n -> promisc ) return 1 ;\n<12> ptr += sizeof ( struct virtio_net_hdr ) ;\n<14> if ( ! memcmp ( & ptr [ 12 ] , vlan , sizeof ( vlan ) ) ) {\n<15> int vid = be16_to_cpup ( ( uint16_t * ) ( ptr + 14 ) ) & 0xfff ;\n<16> if ( ! ( n -> vlans [ vid >> 5 ] & ( 1U << ( vid & 0x1f ) ) ) ) return 0 ;\n<18> if ( ptr [ 0 ] & 1 ) {\n<19> if ( ! memcmp ( ptr , bcast , sizeof ( bcast ) ) ) {\n<20> return ! n -> nobcast ;\n<22> else if ( n -> nomulti ) {\n<29> i < n -> mac_table . in_use ;\n<30> i ++ ) {\n<31> if ( ! memcmp ( ptr , & n -> mac_table . macs [ i * ETH_ALEN ] , ETH_ALEN ) ) {\n<32> return 1 ;\n<40> else if ( n -> alluni || n -> mac_table . uni_overflow ) {\n<43> else if ( ! memcmp ( ptr , n -> mac , ETH_ALEN ) ) {\n<44> return 1 ;\n<46> for ( i = 0 ;\n<47> i < n -> mac_table . first_multi ;\n<48> i ++ ) {\n<49> if ( ! memcmp ( ptr , & n -> mac_table . macs [ i * ETH_ALEN ] , ETH_ALEN ) ) {\n<50> return 1 ;
<1> static void message ( BIO * out , char * m ) {\n<2> fprintf ( stderr , "test %s\n" , m ) ;\n<4> BIO_puts ( out , m ) ;
<1> static int avi_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> int n, d[8], size;\n<53> if(avi->stream_index >= 0){\n<55> AVIStream *ast= st->priv_data;\n<70> if(pkt->data)\n<71> memcpy(pkt->data + pkt->size - 4*256, ast->pal, 4*256);\n<112> memset(d, -1, sizeof(int)*8);\n<116> d[j]= d[j+1];\n<118> size= d[4] + (d[5]<<8) + (d[6]<<16) + (d[7]<<24);\n<119> if(    d[2] >= '0' && d[2] <= '9'\n<120> && d[3] >= '0' && d[3] <= '9'){\n<121> n= (d[2] - '0') * 10 + (d[3] - '0');\n<126> if(i + size > avi->fsize || d[0]<0)\n<129> if(  (d[0] == 'i' && d[1] == 'x' && n < s->nb_streams)\n<131> ||(d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K')\n<132> ||(d[0] == 'i' && d[1] == 'd' && d[2] == 'x' && d[3] == '1')){\n<137> if(    d[0] >= '0' && d[0] <= '9'\n<138> && d[1] >= '0' && d[1] <= '9'){\n<139> n= (d[0] - '0') * 10 + (d[1] - '0');\n<153> if(   d[2] == 'w' && d[3] == 'b'\n<158> && (d[2]*256+d[3] == ast1->prefix || !ast1->prefix_count)\n<174> if (d[2] == 'p' && d[3] == 'c' && size<=4*256+4) {\n<179> ast->pal[k] = get_be32(pb)>>8;// b + (g << 8) + (r << 16);\n<182> } else if(   ((ast->prefix_count<5 || sync+9 > i) && d[2]<128 && d[3]<128) ||\n<183> d[2]*256+d[3] == ast->prefix /*||\n<187> if(d[2]*256+d[3] == ast->prefix)\n<190> ast->prefix= d[2]*256+d[3];
<1> static void xps_parse_gradient_brush ( xps_document * doc , const fz_matrix * ctm , const fz_rect * area , char * base_uri , xps_resource * dict , fz_xml * root , void ( * draw ) ( xps_document * , const fz_matrix * , const fz_rect * , struct stop * , int , fz_xml * , int ) ) {\n<13> spread_att = fz_xml_att ( root , "SpreadMethod" ) ;\n<16> node ;\n<18> if ( ! strcmp ( fz_xml_tag ( node ) , "LinearGradientBrush.Transform" ) ) transform_tag = fz_xml_down ( node ) ;\n<19> if ( ! strcmp ( fz_xml_tag ( node ) , "RadialGradientBrush.Transform" ) ) transform_tag = fz_xml_down ( node ) ;\n<20> if ( ! strcmp ( fz_xml_tag ( node ) , "LinearGradientBrush.GradientStops" ) ) stop_tag = fz_xml_down ( node ) ;\n<21> if ( ! strcmp ( fz_xml_tag ( node ) , "RadialGradientBrush.GradientStops" ) ) stop_tag = fz_xml_down ( node ) ;\n<25> if ( spread_att ) {\n<26> if ( ! strcmp ( spread_att , "Pad" ) ) spread_method = SPREAD_PAD ;\n<27> if ( ! strcmp ( spread_att , "Reflect" ) ) spread_method = SPREAD_REFLECT ;\n<28> if ( ! strcmp ( spread_att , "Repeat" ) ) spread_method = SPREAD_REPEAT ;
<1> static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n<5> uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n<15> if (sscanf(str, fmt, ptr) != 1)\n<17> return -EINVAL;\n<19> return 0;
<1> static void test_parse_error_and_bad_length ( ) {\n<7> if ( ! opt_silent ) fprintf ( stdout , "Got error (as expected): '%s'\n" , mysql_error ( mysql ) ) ;\n<10> if ( ! opt_silent ) fprintf ( stdout , "Got error (as expected): '%s'\n" , mysql_error ( mysql ) ) ;\n<13> if ( ! opt_silent ) fprintf ( stdout , "Got error (as expected): '%s'\n" , mysql_error ( mysql ) ) ;\n<18> if ( ! opt_silent ) fprintf ( stdout , "Got error (as expected): '%s'\n" , mysql_stmt_error ( stmt ) ) ;
<1> static int selinux_inode_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) {\n<8> if ( strcmp ( name , XATTR_NAME_SELINUX ) ) return selinux_inode_setotherxattr ( dentry , name ) ;\n<9> sbsec = inode -> i_sb -> s_security ;\n<10> if ( ! ( sbsec -> flags & SBLABEL_MNT ) ) return - EOPNOTSUPP ;
<1> static int isoent_cmp_iso9660_identifier ( const struct isoent * p1 , const struct isoent * p2 ) {\n<5> s1 = p1 -> identifier ;\n<6> s2 = p2 -> identifier ;\n<8> if ( l > p2 -> ext_off ) l = p2 -> ext_off ;\n<9> cmp = memcmp ( s1 , s2 , l ) ;\n<10> if ( cmp != 0 ) return ( cmp ) ;\n<12> s2 += l ;\n<17> s1 += l ;\n<27> s1 = p1 -> identifier + p1 -> ext_off ;\n<28> s2 = p2 -> identifier + p2 -> ext_off ;\n<29> if ( l > 1 ) {\n<30> cmp = memcmp ( s1 , s2 , l ) ;\n<31> if ( cmp != 0 ) return ( cmp ) ;\n<34> s2 += l ;\n<39> s1 += l ;
<1> static void dissect_cip_s_validator_data ( proto_tree * item_tree , tvbuff_t * tvb , int offset , int item_length , packet_info * pinfo ) {\n<15> if ( ( preq_info != NULL ) && ( preq_info -> ciaData != NULL ) ) {\n<16> memcpy ( & req_data , preq_info -> ciaData , sizeof ( cip_simple_request_info_t ) ) ;\n<31> dissect_cip_get_attribute_all_rsp ( tvb , pinfo , cmd_data_tree , offset + 4 + add_stat_size , & req_data ) ;
<1> ivshmem_server_handle_new_conn(IvshmemServer *server)\n<27> if (newfd < 0) {\n<29> IVSHMEM_SERVER_DEBUG(server, "cannot accept() %s\n", strerror(errno));
<1> static uint32_t fdctrl_read_data(FDCtrl *fdctrl)\n<13> cur_drv = get_cur_drv(fdctrl);\n<35> if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {\n<45> if (blk_read(cur_drv->blk, fd_sector(cur_drv), fdctrl->fifo, 1)\n<55> memset(fdctrl->fifo, 0, FD_SECTOR_LEN);\n<77> fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);\n<81> fdctrl_reset_fifo(fdctrl);\n<83> fdctrl_reset_irq(fdctrl);
<1> static void matroska_merge_packets(AVPacket *out, AVPacket *in)\n<5> out->data = av_realloc(out->data, out->size+in->size);\n<7> memcpy(out->data+out->size, in->data, in->size);\n<9> out->size += in->size;\n<11> av_destruct_packet(in);\n<13> av_free(in);
<1> xmit_seg(E1000State *s)\n<9> struct e1000_tx *tp = &s->tx;\n<53> tp->data[css + 13] &= ~9;		// PSH, FIN\n<77> putsum(tp->data, tp->size, tp->tucso, tp->tucss, tp->tucse);\n<81> putsum(tp->data, tp->size, tp->ipcso, tp->ipcss, tp->ipcse);\n<83> if (tp->vlan_needed) {\n<85> memmove(tp->vlan, tp->data, 4);\n<87> memmove(tp->data, tp->data + 4, 8);\n<89> memcpy(tp->data + 8, tp->vlan_header, 4);\n<91> qemu_send_packet(&s->nic->nc, tp->vlan, tp->size + 4);
<1> static int rd_frame(CinepakEncContext *s, AVFrame *frame, unsigned char *buf, int buf_size)\n<15> for(num_strips = MIN_STRIPS; num_strips <= MAX_STRIPS && num_strips <= s->h / MB_SIZE; num_strips++) {\n<39> get_sub_picture(s, 0, y, (AVPicture*)&s->scratch_frame, &scratch_pict);\n<43> if((temp_size = rd_strip(s, y, FFMIN(h, s->h - y), frame->key_frame, &last_pict, &pict, &scratch_pict, s->frame_buf + CVID_HEADER_SIZE, &score_temp)) < 0)\n<61> best_size = size + write_cvid_header(s, s->frame_buf, num_strips, size);\n<63> av_log(s->avctx, AV_LOG_INFO, "best number of strips so far: %2i, %12li, %i B\n", num_strips, score, best_size);\n<75> memcpy(buf, s->frame_buf, best_size);\n<79> return best_size;
<1> static CharDriverState* create_eventfd_chr_device(void * opaque, EventNotifier *n,\n<17> chr = qemu_chr_open_eventfd(eventfd);\n<21> if (chr == NULL) {\n<23> fprintf(stderr, "creating eventfd for eventfd %d failed\n", eventfd);
<1> extern int main ( int argc , const char * argv [ ] ) {\n<12> result = udata_openChoice ( curPathBuffer , DATA_TYPE , DATA_NAME , isAcceptable , NULL , & status ) ;\n<13> if ( currdir != NULL ) {\n<14> free ( currdir ) ;\n<16> if ( U_FAILURE ( status ) ) {\n<17> printf ( "Failed to open data file example.dat in %s with error number %d\n" , curPathBuffer , status ) ;\n<22> printf ( "Read value %d from data file\n" , * intPointer ) ;\n<23> string = ( char * ) ( intPointer + 1 ) ;\n<24> printf ( "Read string %s from data file\n" , string ) ;
<1> int ff_h264_update_thread_context(AVCodecContext *dst,\n<7> H264Context *h = dst->priv_data, *h1 = src->priv_data;\n<25> (h->width                 != h1->width                 ||\n<27> h->height                != h1->height                ||\n<29> h->mb_width              != h1->mb_width              ||\n<31> h->mb_height             != h1->mb_height             ||\n<33> h->sps.bit_depth_luma    != h1->sps.bit_depth_luma    ||\n<35> h->sps.chroma_format_idc != h1->sps.chroma_format_idc ||\n<37> h->sps.colorspace        != h1->sps.colorspace)) {\n<51> h->width     = h1->width;\n<53> h->height    = h1->height;\n<55> h->mb_height = h1->mb_height;\n<57> h->mb_width  = h1->mb_width;\n<59> h->mb_num    = h1->mb_num;\n<61> h->mb_stride = h1->mb_stride;\n<63> h->b_stride  = h1->b_stride;\n<75> h->sps = h1->sps;\n<85> h->pps = h1->pps;\n<89> if ((err = h264_slice_header_init(h, 1)) < 0) {\n<117> memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));\n<121> if (!inited) {\n<139> ff_h264_unref_picture(h, &h->last_pic_for_ec);\n<141> memcpy(h, h1, sizeof(H264Context));\n<145> memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n<147> memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n<151> memset(&h->cur_pic, 0, sizeof(h->cur_pic));\n<153> memset(&h->last_pic_for_ec, 0, sizeof(h->last_pic_for_ec));\n<161> memset(&h->slice_ctx[0].er,         0, sizeof(h->slice_ctx[0].er));\n<163> memset(&h->slice_ctx[0].mb,         0, sizeof(h->slice_ctx[0].mb));\n<165> memset(&h->slice_ctx[0].mb_luma_dc, 0, sizeof(h->slice_ctx[0].mb_luma_dc));\n<167> memset(&h->slice_ctx[0].mb_padding, 0, sizeof(h->slice_ctx[0].mb_padding));\n<195> memset(h->mvd_table, 0, sizeof(h->mvd_table));\n<207> if (h1->context_initialized) {\n<213> memset(&h->cur_pic, 0, sizeof(h->cur_pic));\n<221> ret = ff_h264_alloc_tables(h);\n<231> ret = ff_h264_slice_context_init(h, &h->slice_ctx[0]);\n<245> h->context_initialized = h1->context_initialized;\n<259> h->coded_picture_number = h1->coded_picture_number;\n<261> h->first_field          = h1->first_field;\n<263> h->picture_structure    = h1->picture_structure;\n<265> h->droppable            = h1->droppable;\n<267> h->low_delay            = h1->low_delay;\n<271> for (i = 0; h->DPB && i < H264_MAX_PICTURE_COUNT; i++) {\n<273> ff_h264_unref_picture(h, &h->DPB[i]);\n<275> if (h1->DPB && h1->DPB[i].f.buf[0] &&\n<277> (ret = ff_h264_ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0)\n<285> h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1);\n<287> ff_h264_unref_picture(h, &h->cur_pic);\n<291> ret = ff_h264_ref_picture(h, &h->cur_pic, &h1->cur_pic);\n<303> h->low_delay       = h1->low_delay;\n<305> h->droppable       = h1->droppable;\n<317> if ((ret = copy_parameter_set((void **)h->sps_buffers,\n<327> if ((ret = copy_parameter_set((void **)h->pps_buffers,\n<343> copy_fields(h, h1, dequant4_buffer, dequant4_coeff);\n<369> copy_fields(h, h1, poc_lsb, default_ref_list);\n<375> copy_fields(h, h1, short_ref, current_slice);\n<379> copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1);\n<381> copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1);\n<383> copy_picture_range(h->delayed_pic, h1->delayed_pic,\n<395> ff_h264_set_parameter_from_sps(h);\n<407> err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
<1> static void write_section_data(AVFormatContext *s, MpegTSFilter *tss1,\n<3> const uint8_t *buf, int buf_size, int is_start)\n<9> MpegTSSectionFilter *tss = &tss1->u.section_filter;\n<15> if (is_start) {\n<17> memcpy(tss->section_buf, buf, buf_size);\n<19> tss->section_index = buf_size;\n<27> if (tss->end_of_section_reached)\n<31> len = 4096 - tss->section_index;\n<33> if (buf_size < len)\n<35> len = buf_size;\n<37> memcpy(tss->section_buf + tss->section_index, buf, len);\n<39> tss->section_index += len;\n<49> len = (AV_RB16(tss->section_buf + 1) & 0xfff) + 3;\n<73> crc_valid = !av_crc(av_crc_get_table(AV_CRC_32_IEEE), -1, tss->section_buf, tss->section_h_size);\n<91> tss->section_cb(tss1, tss->section_buf, tss->section_h_size);
<1> static void http_request_bad ( struct evhttp_request * req , void * arg ) {\n<2> if ( req != NULL ) {\n<3> fprintf ( stderr , "FAILED\n" ) ;
<1> static inline int ipv6_addr_cmp ( const struct in6_addr * a1 , const struct in6_addr * a2 ) {\n<2> return memcmp ( a1 , a2 , sizeof ( struct in6_addr ) ) ;
<1> static void process_iax_pdu ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean video , iax_packet_data * iax_packet ) {\n<8> if ( iax_packet -> call_data == NULL ) {\n<9> memset ( & dissector_info , 0 , sizeof ( dissector_info ) ) ;\n<15> call_dissector_with_data ( iax_call -> subdissector , tvb , pinfo , tree , & dissector_info ) ;
<1> int xmlrpc_about ( void * userdata , int ac , char * * av ) {\n<13> xmlrpc_send ( 1 , arraydata ) ;\n<14> free ( arraydata ) ;
<1> int main ( int argc , char * * argv ) {\n<7> int32_t month = - 1 , year = - 1 ;\n<10> optInd < argc ;\n<11> ++ optInd ) {\n<12> arg = argv [ optInd ] ;\n<13> if ( strcmp ( arg , "-v" ) == 0 || strcmp ( arg , "--version" ) == 0 ) {\n<14> printVersion = 1 ;\n<16> else if ( strcmp ( arg , "-h" ) == 0 || strcmp ( arg , "--help" ) == 0 ) {\n<17> printUsage = 1 ;\n<19> else if ( strcmp ( arg , "-l" ) == 0 || strcmp ( arg , "--long" ) == 0 ) {\n<20> useLongNames = 1 ;\n<22> else if ( strcmp ( arg , "--" ) == 0 ) {\n<23> ++ optInd ;\n<26> else if ( strncmp ( arg , "-" , strlen ( "-" ) ) == 0 ) {\n<27> printf ( "cal: invalid option -- %s\n" , arg + 1 ) ;\n<28> printUsage = 1 ;\n<35> if ( argc - optInd == 2 ) {\n<36> sscanf ( argv [ optInd ] , "%d" , ( int * ) & month ) ;\n<37> sscanf ( argv [ optInd + 1 ] , "%d" , ( int * ) & year ) ;\n<38> if ( month < 0 || month > 12 ) {\n<39> printf ( "icucal: Bad value for month -- %d\n" , ( int ) month ) ;\n<45> sscanf ( argv [ optInd ] , "%d" , ( int * ) & year ) ;
<1> void *av_malloc(size_t size)\n<17> if(size > (INT_MAX-32) )\n<97> ptr = malloc(size);\n<101> return ptr;
<1> TSReturnCode TSHttpArgIndexNameLookup ( const char * name , int * arg_idx , const char * * description ) {\n<3> size_t len = strlen ( name ) ;\n<7> if ( ( len == state_arg_table [ ix ] . name_len ) && ( 0 == strcmp ( name , state_arg_table [ ix ] . name ) ) ) {
<1> static void qdev_prop_set_globals_for_type(DeviceState *dev,\n<3> const char *typename)\n<11> QTAILQ_FOREACH(prop, &global_props, next) {\n<17> if (strcmp(typename, prop->driver) != 0) {\n<31> error_reportf_err(err, "Warning: global %s.%s=%s ignored: ",
<1> static AVStream *add_stream(AVFormatContext *oc, AVCodec **codec,\n<17> if (!(*codec)) {\n<19> fprintf(stderr, "Could not find encoder for '%s'\n",\n<21> avcodec_get_name(codec_id));\n<31> if (!st) {\n<33> fprintf(stderr, "Could not allocate stream\n");
<1> size_t qcms_profile_get_parametric_curve ( qcms_profile * profile , qcms_trc_channel channel , float data [ 7 ] ) {\n<17> if ( ! curve || curve -> type != PARAMETRIC_CURVE_TYPE ) return 0 ;\n<19> if ( data ) memcpy ( data , curve -> parameter , size * sizeof ( float ) ) ;
<1> static int set_file_identifier ( unsigned char * bp , int from , int to , enum vdc vdc , struct archive_write * a , struct vdd * vdd , struct archive_string * id , const char * label , int leading_under , enum char_type char_type ) {\n<15> if ( isoent == NULL ) {\n<21> if ( len > sizeof ( identifier ) - 2 ) len = sizeof ( identifier ) - 2 ;\n<24> if ( len > sizeof ( identifier ) - 1 ) len = sizeof ( identifier ) - 1 ;\n<26> memcpy ( identifier , isoent -> identifier , len ) ;\n<29> identifier [ len + 1 ] = 0 ;\n<32> if ( char_type == A_CHAR ) r = set_str_a_characters_bp ( a , bp , from , to , identifier , vdc ) ;\n<33> else r = set_str_d_characters_bp ( a , bp , from , to , identifier , vdc ) ;
<1> static void update_cursor_data_virgl(VirtIOGPU *g,\n<17> if (!data) {\n<38> memcpy(s->current_cursor->data, data, pixels * sizeof(uint32_t));
<1> static void test_rewind ( void ) {\n<6> long unsigned int length = 4 , Data = 0 ;\n<9> stmt_text = "CREATE TABLE t1 (a int)" ;\n<10> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<12> stmt_text = "INSERT INTO t1 VALUES(2),(3),(4)" ;\n<13> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<15> stmt = mysql_stmt_init ( mysql ) ;\n<16> stmt_text = "SELECT * FROM t1" ;\n<17> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<18> check_execute ( stmt , rc ) ;\n<19> memset ( & my_bind , 0 , sizeof ( MYSQL_BIND ) ) ;\n<28> rc = mysql_stmt_bind_result ( stmt , & my_bind ) ;\n<30> while ( ! mysql_stmt_fetch ( stmt ) ) if ( ! opt_silent ) printf ( "fetched result:%ld\n" , Data ) ;\n<33> while ( ! ( rc = mysql_stmt_fetch ( stmt ) ) ) if ( ! opt_silent ) printf ( "fetched result after seek:%ld\n" , Data ) ;\n<35> stmt_text = "DROP TABLE t1" ;\n<36> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static char * StrStr ( char * s1 , const char * s2 ) {\n<6> Str1 = strdup ( s1 ) ;\n<7> if ( ! Str1 ) goto error1 ;\n<8> Str2 = strdup ( s2 ) ;\n<9> if ( ! Str2 ) goto error2 ;\n<10> ToUpperCase ( Str1 ) ;\n<11> ToUpperCase ( Str2 ) ;\n<12> Ptr = strstr ( Str1 , Str2 ) ;\n<13> if ( ! Ptr ) ret = NULL ;\n<14> else ret = s1 + ( Ptr - Str1 ) ;\n<15> free ( Str2 ) ;\n<16> error2 : free ( Str1 ) ;
<1> static void fill_slice_short ( DXVA_Slice_H264_Short * slice , unsigned position , unsigned size ) {\n<2> memset ( slice , 0 , sizeof ( * slice ) ) ;
<1> static void test_bug47485 ( ) {\n<6> const char * sql_select = "SELECT 1, 'a'" ;\n<15> check_stmt ( stmt ) ;\n<16> rc = mysql_stmt_prepare ( stmt , sql_select , strlen ( sql_select ) ) ;\n<17> check_execute ( stmt , rc ) ;\n<28> memset ( bind , 0 , sizeof ( bind ) ) ;\n<40> rc = mysql_stmt_bind_result ( stmt , bind ) ;\n<49> memset ( bind , 0 , sizeof ( bind ) ) ;\n<61> rc = mysql_stmt_bind_result ( stmt , bind ) ;
<1> static int dvvideo_init(AVCodecContext *avctx)\n<263> if(avctx->lowres){\n<275> memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);
<1> static int read_diff_float_data(ALSDecContext *ctx, unsigned int ra_frame) {\n<11> int *last_shift_value   = ctx->last_shift_value;\n<13> int *last_acf_mantissa  = ctx->last_acf_mantissa;\n<63> if (ra_frame) {\n<65> memset(last_acf_mantissa, 0, avctx->channels * sizeof(*last_acf_mantissa));\n<67> memset(last_shift_value,  0, avctx->channels * sizeof(*last_shift_value) );\n<89> tmp_32 = last_acf_mantissa[c];\n<119> shift_value[c] = last_shift_value[c];
<1> static int old_codec47(SANMVideoContext *ctx, int top,\n<13> uint8_t *prev1 = (uint8_t*)ctx->frm1;\n<15> uint8_t *prev2 = (uint8_t*)ctx->frm2;\n<53> if (!seq) {\n<57> memset(prev1, 0, ctx->height * stride);\n<59> memset(prev2, 0, ctx->height * stride);\n<65> switch (compr) {\n<113> if (process_block(ctx, dst + i, prev1 + i, prev2 + i, stride,\n<123> prev1 += stride * 8;\n<125> prev2 += stride * 8;\n<135> memcpy(ctx->frm0, ctx->frm2, ctx->pitch * ctx->height);\n<141> memcpy(ctx->frm0, ctx->frm1, ctx->pitch * ctx->height);
<74> if ( ff_get_buffer ( avctx , avframe , 0 ) < 0 ) {\n<78> memcpy ( avframe -> data [ 0 ] , framewithpts -> frame -> components [ 0 ] . data , framewithpts -> frame -> components [ 0 ] . length ) ;\n<79> memcpy ( avframe -> data [ 1 ] , framewithpts -> frame -> components [ 1 ] . data , framewithpts -> frame -> components [ 1 ] . length ) ;\n<80> memcpy ( avframe -> data [ 2 ] , framewithpts -> frame -> components [ 2 ] . data , framewithpts -> frame -> components [ 2 ] . length ) ;
<1> static void query_facilities(void)\n<15> memset(&sa_new, 0, sizeof(sa_new));\n<19> sigaction(SIGILL, &sa_new, &sa_old);\n<137> if ((facilities & FACILITY_ZARCH_ACTIVE) == 0) {\n<139> fprintf(stderr, "TCG: z/Arch facility is required.\n");\n<141> fprintf(stderr, "TCG: Boot with a 64-bit enabled kernel.\n");\n<147> if ((facilities & FACILITY_LONG_DISP) == 0) {\n<149> fprintf(stderr, "TCG: long-displacement facility is required.\n");\n<161> if (sizeof(void *) != 8) {\n<163> fprintf(stderr, "TCG: 31-bit mode is not supported.\n");
<1> static void decode_band_structure(GetBitContext *gbc, int blk, int eac3,\n<5> const uint8_t *default_band_struct,\n<7> uint8_t *band_struct, int *num_subbands,\n<15> uint8_t bnd_sz[22];\n<33> } else if (!blk) {\n<39> n_subbands-1);\n<53> if (num_bands || band_sizes ) {\n<55> n_bands = n_subbands;\n<57> bnd_sz[0] = ecpl ? 6 : 12;\n<65> n_bands--;\n<67> bnd_sz[bnd] += subbnd_size;\n<71> bnd_sz[++bnd] = subbnd_size;\n<91> if (band_sizes)\n<93> memcpy(band_sizes, bnd_sz, n_bands);
<1> static void finishupcid ( SplineFont * sf , struct alltabs * at ) {\n<5> storesid ( at , NULL ) ;\n<53> free ( at -> fds ) ;
<1> static Datum ExecEvalFieldStore ( FieldStoreState * fstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n<15> isnull = ( bool * ) palloc ( tupDesc -> natts * sizeof ( bool ) ) ;\n<16> if ( ! * isNull ) {\n<27> memset ( isnull , true , tupDesc -> natts * sizeof ( bool ) ) ;\n<37> econtext -> caseValue_isNull = isnull [ fieldnum - 1 ] ;\n<38> values [ fieldnum - 1 ] = ExecEvalExpr ( newval , econtext , & isnull [ fieldnum - 1 ] , NULL ) ;\n<42> tuple = heap_form_tuple ( tupDesc , values , isnull ) ;\n<44> pfree ( isnull ) ;
<1> static CURLcode header_append ( struct Curl_easy * data , struct SingleRequest * k , size_t length ) {\n<2> if ( k -> hbuflen + length >= data -> state . headersize ) {\n<6> if ( k -> hbuflen + length > CURL_MAX_HTTP_HEADER ) {\n<7> failf ( data , "Avoided giant realloc for header (max is %d)!" , CURL_MAX_HTTP_HEADER ) ;\n<10> newsize = CURLMAX ( ( k -> hbuflen + length ) * 3 / 2 , data -> state . headersize * 2 ) ;\n<11> hbufp_index = k -> hbufp - data -> state . headerbuff ;\n<12> newbuff = realloc ( data -> state . headerbuff , newsize ) ;\n<13> if ( ! newbuff ) {\n<17> data -> state . headersize = newsize ;\n<19> k -> hbufp = data -> state . headerbuff + hbufp_index ;\n<21> memcpy ( k -> hbufp , k -> str_start , length ) ;\n<22> k -> hbufp += length ;\n<23> k -> hbuflen += length ;
<1> void uwsgi_php_append_config ( char * filename ) {\n<2> size_t file_size = 0 ;\n<3> char * file_content = uwsgi_open_and_read ( filename , & file_size , 1 , NULL ) ;\n<4> uwsgi_sapi_module . ini_entries = realloc ( uwsgi_sapi_module . ini_entries , uphp . ini_size + file_size ) ;\n<5> memcpy ( uwsgi_sapi_module . ini_entries + uphp . ini_size , file_content , file_size ) ;\n<6> uphp . ini_size += file_size - 1 ;\n<7> free ( file_content ) ;
<1> static int rawv6_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) {\n<19> if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ;\n<20> memset ( & fl , 0 , sizeof ( fl ) ) ;\n<48> if ( msg -> msg_controllen ) {\n<49> opt = & opt_space ;\n<50> memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ;\n<52> err = datagram_send_ctl ( sock_net ( sk ) , msg , & fl , opt , & hlimit , & tclass , & dontfrag ) ;\n<57> if ( ( fl . fl6_flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) {\n<58> flowlabel = fl6_sock_lookup ( sk , fl . fl6_flowlabel ) ;\n<67> err = rawv6_probe_proto_opt ( & fl , msg ) ;\n<69> if ( ! ipv6_addr_any ( daddr ) ) ipv6_addr_copy ( & fl . fl6_dst , daddr ) ;\n<71> if ( ipv6_addr_any ( & fl . fl6_src ) && ! ipv6_addr_any ( & np -> saddr ) ) ipv6_addr_copy ( & fl . fl6_src , & np -> saddr ) ;\n<74> ipv6_addr_copy ( & final , & fl . fl6_dst ) ;\n<75> ipv6_addr_copy ( & fl . fl6_dst , rt0 -> addr ) ;\n<78> if ( ! fl . oif && ipv6_addr_is_multicast ( & fl . fl6_dst ) ) fl . oif = np -> mcast_oif ;\n<79> security_sk_classify_flow ( sk , & fl ) ;\n<80> err = ip6_dst_lookup ( sk , & dst , & fl ) ;\n<82> if ( final_p ) ipv6_addr_copy ( & fl . fl6_dst , final_p ) ;\n<83> err = __xfrm_lookup ( sock_net ( sk ) , & dst , & fl , sk , XFRM_LOOKUP_WAIT ) ;\n<85> if ( err == - EREMOTE ) err = ip6_dst_blackhole ( sk , & dst , & fl ) ;\n<89> if ( ipv6_addr_is_multicast ( & fl . fl6_dst ) ) hlimit = np -> mcast_hops ;\n<97> err = rawv6_send_hdrinc ( sk , msg -> msg_iov , len , & fl , ( struct rt6_info * ) dst , msg -> msg_flags ) ;\n<101> err = ip6_append_data ( sk , ip_generic_getfrag , msg -> msg_iov , len , 0 , hlimit , tclass , opt , & fl , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ;\n<103> else if ( ! ( msg -> msg_flags & MSG_MORE ) ) err = rawv6_push_pending_frames ( sk , & fl , rp ) ;
<1> static int csrhci_write(struct CharDriverState *chr,\n<3> const uint8_t *buf, int len)\n<7> struct csrhci_s *s = (struct csrhci_s *) chr->opaque;\n<9> int plen = s->in_len;\n<13> if (!s->enable)\n<21> memcpy(s->inpkt + plen, buf, len);\n<29> s->in_hdr = csrhci_header_len(s->inpkt) + 1;\n<35> s->in_data = csrhci_data_len(s->inpkt) + s->in_hdr;\n<39> if (s->in_len >= s->in_data) {\n<41> csrhci_in_packet(s, s->inpkt);\n<45> memmove(s->inpkt, s->inpkt + s->in_len, s->in_len - s->in_data);\n<63> return len;
<1> int fill_schema_table_privileges ( THD * thd , TABLE_LIST * tables , COND * cond ) {\n<6> bool no_global_access = check_access ( thd , SELECT_ACL , "mysql" , 0 , 1 , 1 , 0 ) ;\n<11> index < column_priv_hash . records ;\n<12> index ++ ) {\n<15> if ( ! ( user = grant_table -> user ) ) user = "" ;\n<17> if ( no_global_access && ( strcmp ( thd -> security_ctx -> priv_user , user ) || my_strcasecmp ( system_charset_info , curr_host , host ) ) ) continue ;\n<18> ulong table_access = grant_table -> privs ;\n<19> if ( table_access ) {\n<23> strxmov ( buff , "'" , user , "'@'" , host , "'" , NullS ) ;
<1> static void qemu_rdma_signal_unregister(RDMAContext *rdma, uint64_t index,\n<7> if (rdma->unregistrations[rdma->unregister_next] != 0) {\n<9> fprintf(stderr, "rdma migration: queue is full!\n");
<1> static int blkdebug_debug_remove_breakpoint(BlockDriverState *bs,\n<3> const char *tag)\n<21> if (rule->action == ACTION_SUSPEND &&\n<23> !strcmp(rule->options.suspend.tag, tag)) {\n<35> QLIST_FOREACH_SAFE(r, &s->suspended_reqs, next, r_next) {\n<37> if (!strcmp(r->tag, tag)) {\n<39> qemu_coroutine_enter(r->co, NULL);\n<41> ret = 0;
<1> ParseResult validate_hdr_content_length ( HdrHeap * heap , HTTPHdrImpl * hh ) {\n<10> const char * content_length_val = content_length_field -> value_get ( & content_length_len ) ;\n<13> const char * content_length_val_2 = content_length_field -> m_next_dup -> value_get ( & content_length_len_2 ) ;\n<14> if ( ( content_length_len != content_length_len_2 ) || ( memcmp ( content_length_val , content_length_val_2 , content_length_len ) != 0 ) ) {
<1> const uint8_t *ff_h264_decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){\n<15> h->nal_unit_type= src[0]&0x1F;\n<19> src++; length--;\n<57> if(i>0 && src[i-1]==0) i--;\n<61> if(i+2<length && src[i+1]==0 && src[i+2]<=3){\n<63> if(src[i+2]!=3){\n<81> if(i>=length-1){ //no escaped 0\n<101> if (dst == NULL){\n<111> memcpy(dst, src, i);\n<113> si=di=i;\n<119> if(src[si+2]>3){\n<121> dst[di++]= src[si++];\n<123> dst[di++]= src[si++];\n<125> }else if(src[si]==0 && src[si+1]==0){\n<127> if(src[si+2]==3){ //escape\n<131> dst[di++]= 0;\n<145> dst[di++]= src[si++];\n<151> dst[di++]= src[si++];\n<157> memset(dst+di, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<167> return dst;
<2> const struct _LocaleLMBCSGrpMap * pTable = LocaleLMBCSGrpMap ;\n<7> if ( * pTable -> LocaleID == * LocaleID ) {\n<8> if ( uprv_strncmp ( pTable -> LocaleID , LocaleID , strlen ( pTable -> LocaleID ) ) == 0 ) return pTable -> OptGroup ;\n<11> pTable ++ ;
<1> static void test_multi_stmt ( ) {\n<7> ulong length [ 2 ] ;\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<27> length [ 0 ] = 0 ;\n<33> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<40> id = 999 ;\n<43> if ( ! opt_silent ) {\n<44> fprintf ( stdout , "\n int_data: %lu(%lu)" , ( ulong ) id , length [ 0 ] ) ;\n<45> fprintf ( stdout , "\n str_data: %s(%lu)" , name , length [ 1 ] ) ;\n<47> DIE_UNLESS ( id == 10 ) ;\n<48> DIE_UNLESS ( strcmp ( name , "mysql" ) == 0 ) ;\n<63> if ( ! opt_silent ) {\n<64> fprintf ( stdout , "\n int_data: %lu(%lu)" , ( ulong ) id , length [ 0 ] ) ;\n<65> fprintf ( stdout , "\n str_data: %s(%lu)" , name , length [ 1 ] ) ;\n<68> DIE_UNLESS ( strcmp ( name , "updated" ) == 0 ) ;
<1> void smc91c111_init(NICInfo *nd, uint32_t base, void *pic, int irq)\n<25> memcpy(s->macaddr, nd->macaddr, 6);\n<29> smc91c111_reset(s);\n<33> s->vc = qemu_new_vlan_client(nd->vlan, smc91c111_receive, s);
<1> int tls_construct_cert_status ( SSL * s ) {\n<3> if ( ! BUF_MEM_grow ( s -> init_buf , 8 + s -> tlsext_ocsp_resplen ) ) {\n<11> l2n3 ( s -> tlsext_ocsp_resplen , p ) ;\n<12> memcpy ( p , s -> tlsext_ocsp_resp , s -> tlsext_ocsp_resplen ) ;\n<13> s -> init_num = 8 + s -> tlsext_ocsp_resplen ;
<1> void kvm_setup_guest_memory(void *start, size_t size)\n<5> if (!kvm_has_sync_mmu()) {
<1> static void config_parse(GAConfig *config, int argc, char **argv)\n<57> switch (ch) {\n<121> printf("QEMU Guest Agent %s\n", QEMU_VERSION);
<1> void kadmin_modprinc ( int argc , char * argv [ ] ) {\n<6> char * pass , * canon = NULL ;\n<9> krb5_key_salt_tuple * ks_tuple = NULL ;\n<10> if ( argc < 2 ) {\n<14> memset ( & oldprinc , 0 , sizeof ( oldprinc ) ) ;\n<15> memset ( & princ , 0 , sizeof ( princ ) ) ;\n<17> if ( retval ) {\n<21> retval = krb5_unparse_name ( context , kprinc , & canon ) ;\n<26> retval = kadm5_get_principal ( handle , kprinc , & oldprinc , KADM5_PRINCIPAL_NORMAL_MASK ) ;\n<28> com_err ( "modify_principal" , retval , _ ( "while getting \"%s\"." ) , canon ) ;\n<31> princ . attributes = oldprinc . attributes ;\n<32> kadm5_free_principal_ent ( handle , & oldprinc ) ;\n<33> retval = kadmin_parse_princ_args ( argc , argv , & princ , & mask , & pass , & randkey , & ks_tuple , & n_ks_tuple , "modify_principal" ) ;\n<34> if ( retval || ks_tuple != NULL || randkey || pass ) {\n<39> if ( ! policy_exists ( princ . policy ) ) {\n<40> fprintf ( stderr , _ ( "WARNING: policy \"%s\" does not exist\n" ) , princ . policy ) ;\n<44> retval = kadm5_modify_principal ( handle , & princ , mask ) ;\n<46> if ( retval ) {\n<47> com_err ( "modify_principal" , retval , _ ( "while modifying \"%s\"." ) , canon ) ;\n<50> printf ( _ ( "Principal \"%s\" modified.\n" ) , canon ) ;\n<52> krb5_free_principal ( context , princ . principal ) ;\n<53> kadmin_free_tl_data ( & princ . n_tl_data , & princ . tl_data ) ;\n<54> free ( canon ) ;\n<55> free ( ks_tuple ) ;
<1> void avcodec_get_context_defaults2(AVCodecContext *s, enum CodecType codec_type){\n<5> memset(s, 0, sizeof(AVCodecContext));\n<27> av_opt_set_defaults2(s, flags, flags);
<1> int inet_listen_opts(QemuOpts *opts, int port_offset, Error **errp)\n<19> memset(&ai,0, sizeof(ai));\n<21> ai.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n<23> ai.ai_family = PF_UNSPEC;\n<25> ai.ai_socktype = SOCK_STREAM;\n<29> if ((qemu_opt_get(opts, "host") == NULL) ||\n<31> (qemu_opt_get(opts, "port") == NULL)) {\n<39> pstrcpy(port, sizeof(port), qemu_opt_get(opts, "port"));\n<41> addr = qemu_opt_get(opts, "host");\n<49> ai.ai_family = PF_INET;\n<53> ai.ai_family = PF_INET6;\n<59> if (port_offset) {\n<81> snprintf(port, sizeof(port), "%d", (int)baseport + port_offset);\n<85> rc = getaddrinfo(strlen(addr) ? addr : NULL, port, &ai, &res);\n<87> if (rc != 0) {\n<89> error_setg(errp, "address resolution failed for %s:%s: %s", addr, port,\n<101> for (e = res; e != NULL; e = e->ai_next) {\n<175> freeaddrinfo(res);\n<189> freeaddrinfo(res);\n<209> freeaddrinfo(res);
<1> static int enable_write_target(BlockDriverState *bs, Error **errp)\n<15> int size = sector2cluster(s, s->sector_count);\n<21> s->used_clusters = calloc(size, 1);\n<119> *(void**)s->bs->backing->bs->opaque = s;
<1> static int dumpglyphs ( SplineFont * sf , struct glyphinfo * gi ) {\n<13> if ( SCWorthOutputting ( sc ) ) if ( ! SCPointsNumberedProperly ( sc , gi -> layer ) ) {\n<26> if ( answer == 0 ) {\n<27> free ( sc -> ttf_instrs ) ;\n<28> sc -> ttf_instrs = NULL ;\n<37> gi -> loca = malloc ( ( gi -> maxp -> numGlyphs + 1 ) * sizeof ( uint32 ) ) ;\n<38> gi -> pointcounts = malloc ( ( gi -> maxp -> numGlyphs + 1 ) * sizeof ( int32 ) ) ;\n<39> memset ( gi -> pointcounts , - 1 , ( gi -> maxp -> numGlyphs + 1 ) * sizeof ( int32 ) ) ;\n<44> FigureFullMetricsEnd ( sf , gi , true ) ;\n<50> i < gi -> gcnt ;\n<53> if ( gi -> bygid [ 0 ] != - 1 && ( fixed <= 0 || sf -> glyphs [ gi -> bygid [ 0 ] ] -> width == fixed ) ) dumpglyph ( sf -> glyphs [ gi -> bygid [ 0 ] ] , gi ) ;\n<54> else dumpmissingglyph ( sf , gi , fixed ) ;\n<56> else if ( i <= 2 && gi -> bygid [ i ] == - 1 ) dumpblankglyph ( gi , sf , fixed ) ;\n<58> if ( gi -> bygid [ i ] != - 1 && sf -> glyphs [ gi -> bygid [ i ] ] -> ttf_glyph > 0 ) dumpspace ( sf -> glyphs [ gi -> bygid [ i ] ] , gi ) ;\n<62> if ( IsTTFRefable ( sf -> glyphs [ gi -> bygid [ i ] ] , gi -> layer ) ) dumpcomposite ( sf -> glyphs [ gi -> bygid [ i ] ] , gi ) ;\n<63> else dumpglyph ( sf -> glyphs [ gi -> bygid [ i ] ] , gi ) ;\n<85> if ( ! sf -> layers [ gi -> layer ] . order2 ) RefigureCompositeMaxPts ( sf , gi ) ;\n<86> free ( gi -> pointcounts ) ;
<1> OM_uint32 kg_set_ccache_name ( OM_uint32 * minor_status , const char * name ) {\n<6> if ( name ) {\n<7> new_name = strdup ( name ) ;\n<8> if ( new_name == NULL ) {\n<16> new_name = swap ;\n<17> kerr = k5_setspecific ( K5_KEY_GSS_KRB5_CCACHE_NAME , kg_ccache_name ) ;\n<18> if ( kerr != 0 ) {\n<19> free ( kg_ccache_name ) ;\n<23> free ( new_name ) ;
<1> static int grow_refcount_table(BlockDriverState *bs, int min_size)\n<21> if (min_size <= s->refcount_table_size)\n<27> new_table_size = next_refcount_table_size(s, min_size);\n<41> new_table = qemu_mallocz(new_table_size2);\n<45> s->refcount_table_size * sizeof(uint64_t));\n<49> cpu_to_be64s(&new_table[i]);\n<55> ret = bdrv_pwrite(s->hd, table_offset, new_table, new_table_size2);\n<63> be64_to_cpus(&new_table[i]);\n<83> qemu_free(s->refcount_table);\n<89> s->refcount_table = new_table;\n<105> qemu_free(new_table);
<1> static int nbd_opt_go(QIOChannel *ioc, const char *wantname,\n<9> uint32_t len = strlen(wantname);\n<29> trace_nbd_opt_go_start(wantname);\n<31> buf = g_malloc(4 + len + 2 + 2 * info->request_sizes + 1);\n<33> stl_be_p(buf, len);\n<35> memcpy(buf + 4, wantname, len);\n<39> stw_be_p(buf + 4 + len, info->request_sizes);\n<43> stw_be_p(buf + 4 + len + 2, NBD_INFO_BLOCK_SIZE);\n<49> 4 + len + 2 + 2 * info->request_sizes, buf,
<1> void vp9_print_modes_and_motion_vectors ( VP9_COMMON * cm , const char * file ) {\n<15> log_frame_info ( cm , "Vectors " , mvs ) ;\n<17> mi_row < rows ;\n<19> fprintf ( mvs , "V " ) ;\n<21> mi_col < cols ;\n<23> fprintf ( mvs , "%4d:%4d " , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . row , mi [ mi_index ] -> mbmi . mv [ 0 ] . as_mv . col ) ;\n<26> fprintf ( mvs , "\n" ) ;\n<29> fprintf ( mvs , "\n" ) ;\n<30> fclose ( mvs ) ;
<1> int MDC2_Init ( MDC2_CTX * c ) {\n<4> memset ( & ( c -> h [ 0 ] ) , 0x52 , MDC2_BLOCK ) ;\n<5> memset ( & ( c -> hh [ 0 ] ) , 0x25 , MDC2_BLOCK ) ;
<1> static void test_bug10729 ( ) {\n<20> check_execute ( stmt , rc ) ;\n<21> stmt_text = "select name from t1" ;\n<22> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<23> check_execute ( stmt , rc ) ;\n<24> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<28> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<32> int row_no = 0 ;\n<35> while ( ( rc = mysql_stmt_fetch ( stmt ) ) == 0 ) {\n<36> DIE_UNLESS ( strcmp ( a , name_array [ row_no ] ) == 0 ) ;\n<37> if ( ! opt_silent ) printf ( "%d: %s\n" , row_no , a ) ;\n<38> ++ row_no ;
<1> static int virtio_blk_device_init(VirtIODevice *vdev)\n<7> VirtIOBlock *s = VIRTIO_BLK(vdev);\n<9> VirtIOBlkConf *blk = &(s->blk);\n<23> if (!bdrv_is_inserted(blk->conf.bs)) {\n<33> blkconf_serial(&blk->conf, &blk->serial);\n<35> if (blkconf_geometry(&blk->conf, NULL, 65535, 255, 255) < 0) {\n<63> memcpy(&(s->blk), blk, sizeof(struct VirtIOBlkConf));
<1> static hb_bool_t lang_matches ( const char * lang_str , const char * spec ) {\n<2> unsigned int len = strlen ( spec ) ;\n<3> return strncmp ( lang_str , spec , len ) == 0 && ( lang_str [ len ] == '\0' || lang_str [ len ] == '-' ) ;
<1> int qcow2_snapshot_delete(BlockDriverState *bs,\n<11> BDRVQcowState *s = bs->opaque;\n<23> if (snapshot_index < 0) {\n<41> (s->nb_snapshots - snapshot_index - 1) * sizeof(sn));
<1> static int com_shell ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) ) {\n<3> while ( my_isspace ( charset_info , * line ) ) line ++ ;\n<4> if ( ! ( shell_cmd = strchr ( line , ' ' ) ) ) {\n<5> put_info ( "Usage: \\! shell-command" , INFO_ERROR ) ;\n<6> return - 1 ;\n<8> if ( system ( shell_cmd ) == - 1 ) {\n<9> put_info ( strerror ( errno ) , INFO_ERROR , errno ) ;
<1> static int cgroup_recursive_task_count ( const char * cgroup_path ) {\n<10> if ( ! dent_buf ) return - 1 ;\n<12> if ( ! d ) {\n<13> free ( dent_buf ) ;\n<16> while ( readdir_r ( d , dent_buf , & dent ) == 0 && dent ) {\n<22> if ( ! strcmp ( dent -> d_name , "." ) || ! strcmp ( dent -> d_name , ".." ) ) continue ;\n<23> sub_path = lxc_string_join ( "/" , parts , false ) ;\n<24> if ( ! sub_path ) {\n<26> free ( dent_buf ) ;\n<29> r = stat ( sub_path , & st ) ;\n<30> if ( r < 0 ) {\n<32> free ( dent_buf ) ;\n<33> free ( sub_path ) ;\n<36> if ( S_ISDIR ( st . st_mode ) ) {\n<37> r = cgroup_recursive_task_count ( sub_path ) ;\n<40> else if ( ! strcmp ( dent -> d_name , "tasks" ) ) {\n<41> r = count_lines ( sub_path ) ;\n<42> if ( r >= 0 ) n += r ;\n<44> free ( sub_path ) ;\n<47> free ( dent_buf ) ;
<1> static int at1_unpack_dequant ( GetBitContext * gb , AT1SUCtx * su , float spec [ AT1_SU_SAMPLES ] ) {\n<29> if ( word_len ) {\n<38> memset ( & spec [ pos ] , 0 , num_specs * sizeof ( float ) ) ;
<1> static int net_dump_init(NetClientState *peer, const char *device,\n<47> if (write(fd, &hdr, sizeof(hdr)) < sizeof(hdr)) {\n<49> error_report("-net dump write error: %s", strerror(errno));
<1> static void main_free1 ( void * opaque , void * ptr ) {\n<2> free ( ptr ) ;
<1> static int lxc_cgroupfs_set ( const char * filename , const char * value , const char * name , const char * lxcpath ) {\n<4> subsystem = alloca ( strlen ( filename ) + 1 ) ;\n<5> strcpy ( subsystem , filename ) ;\n<6> if ( ( p = strchr ( subsystem , '.' ) ) != NULL ) * p = '\0' ;\n<7> path = lxc_cgroup_get_hierarchy_abs_path ( subsystem , name , lxcpath ) ;\n<8> if ( path ) {\n<9> ret = do_cgroup_set ( path , filename , value ) ;\n<10> free ( path ) ;
<1> void ReadToc ( ArchiveHandle * AH ) {\n<11> i < AH -> tocCount ;\n<13> te = ( TocEntry * ) pg_malloc0 ( sizeof ( TocEntry ) ) ;\n<17> te -> hadDumper = ReadInt ( AH ) ;\n<18> if ( AH -> version >= K_VERS_1_8 ) {\n<19> tmp = ReadStr ( AH ) ;\n<20> sscanf ( tmp , "%u" , & te -> catalogId . tableoid ) ;\n<21> free ( tmp ) ;\n<24> tmp = ReadStr ( AH ) ;\n<25> sscanf ( tmp , "%u" , & te -> catalogId . oid ) ;\n<26> free ( tmp ) ;\n<28> te -> desc = ReadStr ( AH ) ;\n<29> if ( AH -> version >= K_VERS_1_11 ) {\n<30> te -> section = ReadInt ( AH ) ;\n<33> if ( strcmp ( te -> desc , "COMMENT" ) == 0 || strcmp ( te -> desc , "ACL" ) == 0 || strcmp ( te -> desc , "ACL LANGUAGE" ) == 0 ) te -> section = SECTION_NONE ;\n<34> else if ( strcmp ( te -> desc , "TABLE DATA" ) == 0 || strcmp ( te -> desc , "BLOBS" ) == 0 || strcmp ( te -> desc , "BLOB COMMENTS" ) == 0 ) te -> section = SECTION_DATA ;\n<35> else if ( strcmp ( te -> desc , "CONSTRAINT" ) == 0 || strcmp ( te -> desc , "CHECK CONSTRAINT" ) == 0 || strcmp ( te -> desc , "FK CONSTRAINT" ) == 0 || strcmp ( te -> desc , "INDEX" ) == 0 || strcmp ( te -> desc , "RULE" ) == 0 || strcmp ( te -> desc , "TRIGGER" ) == 0 ) te -> section = SECTION_POST_DATA ;\n<36> else te -> section = SECTION_PRE_DATA ;\n<38> te -> defn = ReadStr ( AH ) ;\n<39> te -> dropStmt = ReadStr ( AH ) ;\n<40> if ( AH -> version >= K_VERS_1_3 ) te -> copyStmt = ReadStr ( AH ) ;\n<41> if ( AH -> version >= K_VERS_1_6 ) te -> namespace = ReadStr ( AH ) ;\n<42> if ( AH -> version >= K_VERS_1_10 ) te -> tablespace = ReadStr ( AH ) ;\n<43> te -> owner = ReadStr ( AH ) ;\n<44> if ( AH -> version >= K_VERS_1_9 ) {\n<45> if ( strcmp ( ReadStr ( AH ) , "true" ) == 0 ) te -> withOids = true ;\n<46> else te -> withOids = false ;\n<48> else te -> withOids = true ;\n<51> deps = ( DumpId * ) pg_malloc ( sizeof ( DumpId ) * depSize ) ;\n<57> if ( ! tmp ) break ;\n<60> deps = ( DumpId * ) pg_realloc ( deps , sizeof ( DumpId ) * depSize ) ;\n<62> sscanf ( tmp , "%d" , & deps [ depIdx ] ) ;\n<63> free ( tmp ) ;\n<66> if ( depIdx > 0 ) {\n<67> deps = ( DumpId * ) pg_realloc ( deps , sizeof ( DumpId ) * depIdx ) ;\n<68> te -> dependencies = deps ;\n<69> te -> nDeps = depIdx ;\n<72> free ( deps ) ;\n<73> te -> dependencies = NULL ;\n<74> te -> nDeps = 0 ;\n<78> te -> dependencies = NULL ;\n<79> te -> nDeps = 0 ;\n<81> if ( AH -> ReadExtraTocPtr ) ( * AH -> ReadExtraTocPtr ) ( AH , te ) ;\n<82> ahlog ( AH , 3 , "read TOC entry %d (ID %d) for %s %s\n" , i , te -> dumpId , te -> desc , te -> tag ) ;\n<83> te -> prev = AH -> toc -> prev ;\n<86> te -> next = AH -> toc ;\n<87> if ( strcmp ( te -> desc , "ENCODING" ) == 0 ) processEncodingEntry ( AH , te ) ;\n<88> else if ( strcmp ( te -> desc , "STDSTRINGS" ) == 0 ) processStdStringsEntry ( AH , te ) ;
<1> static int ehci_execute(EHCIPacket *p, const char *action)\n<13> if (!(p->qtd.token & QTD_TOKEN_ACTIVE)) {\n<15> fprintf(stderr, "Attempting to execute inactive qtd\n");\n<39> switch (p->pid) {\n<61> fprintf(stderr, "bad token\n");\n<103> if (ret > BUFF_SIZE) {\n<105> fprintf(stderr, "ret from usb_handle_packet > BUFF_SIZE\n");
<1> static int parse_add_fd(QemuOpts *opts, void *opaque)\n<95> if (dupfd == -1) {\n<99> "Error duplicating fd: %s", strerror(errno));
<1> static int vdpau_h264_start_frame ( AVCodecContext * avctx , const uint8_t * buffer , uint32_t size ) {\n<4> VdpPictureInfoH264 * info = & hwctx -> info . h264 ;\n<34> memcpy ( info -> scaling_lists_4x4 , h -> pps . scaling_matrix4 , sizeof ( info -> scaling_lists_4x4 ) ) ;\n<35> memcpy ( info -> scaling_lists_8x8 [ 0 ] , h -> pps . scaling_matrix8 [ 0 ] , sizeof ( info -> scaling_lists_8x8 [ 0 ] ) ) ;\n<36> memcpy ( info -> scaling_lists_8x8 [ 1 ] , h -> pps . scaling_matrix8 [ 3 ] , sizeof ( info -> scaling_lists_8x8 [ 1 ] ) ) ;
<1> static void test_func_fields ( ) {\n<19> mytest ( field ) ;\n<20> if ( ! opt_silent ) fprintf ( stdout , "\n table name: `%s` (expected: `%s`)" , field -> table , "test_dateformat" ) ;\n<21> DIE_UNLESS ( strcmp ( field -> table , "test_dateformat" ) == 0 ) ;\n<23> mytest_r ( field ) ;\n<30> mytest ( field ) ;\n<31> if ( ! opt_silent ) fprintf ( stdout , "\n table name: `%s` (expected: `%s`)" , field -> table , "" ) ;\n<34> mytest_r ( field ) ;\n<41> mytest ( field ) ;\n<42> if ( ! opt_silent ) {\n<43> printf ( "\n field name: `%s` (expected: `%s`)" , field -> name , "YEAR" ) ;\n<44> printf ( "\n field org name: `%s` (expected: `%s`)" , field -> org_name , "" ) ;\n<46> DIE_UNLESS ( strcmp ( field -> name , "YEAR" ) == 0 ) ;\n<49> mytest_r ( field ) ;
<1> static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,\n<37> ip1 = ip0 + s->frame->linesize[0];\n<41> ip2 = ip1 + s->frame->linesize[0];\n<45> ip3 = ip2 + s->frame->linesize[0];\n<113> p = strip->v1_codebook[*data++];\n<115> if (s->palette_video) {\n<117> ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6];\n<119> ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9];\n<121> ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0];\n<123> ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3];\n<127> p += 6;\n<129> memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3);\n<131> memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3);\n<133> p += 3; /* ... + 9 */\n<135> memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3);\n<137> memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3);\n<139> p -= 9; /* ... + 0 */\n<141> memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3);\n<143> memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3);\n<145> p += 3; /* ... + 3 */\n<147> memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3);\n<149> memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3);\n<163> cb0 = strip->v4_codebook[*data++];\n<165> cb1 = strip->v4_codebook[*data++];\n<167> cb2 = strip->v4_codebook[*data++];\n<169> cb3 = strip->v4_codebook[*data++];\n<171> if (s->palette_video) {\n<213> *p   = cb1[3];\n<217> memcpy(ip3 + 0, cb2 + 6, 6);\n<219> memcpy(ip3 + 6, cb3 + 6, 6);\n<221> memcpy(ip2 + 0, cb2 + 0, 6);\n<223> memcpy(ip2 + 6, cb3 + 0, 6);\n<225> memcpy(ip1 + 0, cb0 + 6, 6);\n<227> memcpy(ip1 + 6, cb1 + 6, 6);\n<229> memcpy(ip0 + 0, cb0 + 0, 6);\n<231> memcpy(ip0 + 6, cb1 + 0, 6);\n<245> ip0 += 4;  ip1 += 4;\n<247> ip2 += 4;  ip3 += 4;\n<251> ip0 += 12;  ip1 += 12;\n<253> ip2 += 12;  ip3 += 12;
<2> struct ogg * ogg = s -> priv_data ;\n<6> if ( ! ost ) return 0 ;\n<16> if ( ( err = av_reallocp_array ( & ogg -> streams , ogg -> nstreams , sizeof ( * ogg -> streams ) ) ) < 0 ) {\n<20> else memcpy ( ogg -> streams , ost -> streams , ost -> nstreams * sizeof ( * ogg -> streams ) ) ;\n<22> av_free ( ost ) ;
<1> static int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n<7> char key2[32], language[4] = {0};\n<269> ff_mov_lang_to_iso639(langcode, language);\n<321> if (!raw && (data_type == 3 || (data_type == 0 && (langcode < 0x400 || langcode == 0x7fff)))) { // MAC Encoded\n<329> if (snprintf(str, str_size_alloc, "%f", val) >= str_size_alloc) {\n<344> if (ret < 0) {\n<359> if (*language && strcmp(language, "und")) {\n<361> snprintf(key2, sizeof(key2), "%s-%s", key, language);\n<363> av_dict_set(&c->fc->metadata, key2, str, 0);\n<369> av_log(c->fc, AV_LOG_TRACE, "lang \"%3s\" ", language);
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> EightBpsContext * const c = avctx -> priv_data ;\n<58> if ( avctx -> bits_per_coded_sample <= 8 ) {\n<59> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<60> if ( pal ) {\n<62> memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n<64> memcpy ( frame -> data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;
<1> static void json_print_int(WriterContext *wctx, const char *key, int value)\n<9> if (wctx->nb_item) printf(",\n");
<1> static struct pbase_tree_cache * pbase_tree_get ( const unsigned char * sha1 ) {\n<22> if ( ! data ) return NULL ;\n<23> if ( type != OBJ_TREE ) {\n<24> free ( data ) ;\n<32> if ( ! ent ) {\n<37> free ( ent -> tree_data ) ;\n<38> nent = ent ;
<1> static int ram_load_dead(QEMUFile *f, void *opaque)\n<19> if (ram_decompress_buf(s, buf, 1) < 0) {\n<21> fprintf(stderr, "Error while reading ram block header\n");\n<27> if (buf[0] == 0) {\n<43> printf("Error block header\n");
<1> void net_check_clients(void)\n<13> QTAILQ_FOREACH(vlan, &vlans, next) {\n<43> if (has_host_dev && !has_nic)\n<45> fprintf(stderr, "Warning: vlan %d with no nics\n", vlan->id);\n<47> if (has_nic && !has_host_dev)\n<57> QTAILQ_FOREACH(vc, &non_vlan_clients, next) {\n<59> if (!vc->peer) {\n<61> fprintf(stderr, "Warning: %s %s has no peer\n",
<1> static int qemu_rdma_write(QEMUFile *f, RDMAContext *rdma,\n<41> if (ret) {\n<43> fprintf(stderr, "ram block search failed\n");
<1> static void opt_input_file ( void * optctx , const char * arg ) {\n<3> av_log ( NULL , AV_LOG_ERROR , "Argument '%s' provided as input filename, but '%s' was already specified.\n" , arg , input_filename ) ;\n<6> if ( ! strcmp ( arg , "-" ) ) arg = "pipe:" ;\n<7> input_filename = arg ;
<1> void qemu_init_vcpu(void *_env)\n<21> if (r < 0) {\n<23> fprintf(stderr, "kvm_init_vcpu failed: %s\n", strerror(-r));
<1> static unsigned long copy_elf_strings(int argc,char ** argv, void **page,\n<23> if (!tmp) {\n<25> fprintf(stderr, "VFS: argc is wrong");\n<51> pag = (char *)page[p/TARGET_PAGE_SIZE];\n<53> if (!pag) {\n<55> pag = (char *)malloc(TARGET_PAGE_SIZE);\n<57> page[p/TARGET_PAGE_SIZE] = pag;\n<59> if (!pag)
<1> static int lxc_cgroupfs_enter ( struct cgroup_process_info * info , pid_t pid , bool enter_sub ) {\n<6> snprintf ( pid_buf , 32 , "%lu" , ( unsigned long ) pid ) ;\n<19> if ( ! cgroup_tasks_fn ) {\n<23> r = lxc_write_to_file ( cgroup_tasks_fn , pid_buf , strlen ( pid_buf ) , false ) ;\n<24> free ( cgroup_tasks_fn ) ;
<1> static void *circular_buffer_task( void *_URLContext)\n<7> UDPContext *s = h->priv_data;\n<37> FD_SET(s->udp_fd, &rfds);\n<59> if (!(ret > 0 && FD_ISSET(s->udp_fd, &rfds)))\n<75> if(left < UDP_MAX_PKT_SIZE + 4) {\n<85> len = recv(s->udp_fd, s->tmp+4, sizeof(s->tmp)-4, 0);\n<87> if (len < 0) {\n<105> av_fifo_generic_write(s->fifo, s->tmp, len+4, NULL);
<1> static int script_contents_read ( struct mail_user * user ) {\n<10> if ( fd == - 1 ) return - 1 ;\n<12> if ( write_full ( fd , cmd , strlen ( cmd ) ) < 0 ) {\n<13> i_error ( "write(%s) failed: %m" , path ) ;\n<14> i_close_fd ( & fd ) ;\n<15> return - 1 ;\n<17> input = i_stream_create_fd_autoclose ( & fd , 1024 ) ;\n<18> while ( ( line = i_stream_read_next_line ( input ) ) != NULL ) {\n<32> if ( input -> stream_errno != 0 ) {\n<40> i_stream_destroy ( & input ) ;\n<41> return ret ;
<1> void record_clock_stats ( sockaddr_u * addr , const char * text ) {\n<7> day = now . l_ui / 86400 + MJD_1900 ;\n<9> if ( clockstats . fp != NULL ) {\n<10> fprintf ( clockstats . fp , "%lu %s %s %s\n" , day , ulfptoa ( & now , 3 ) , stoa ( addr ) , text ) ;\n<11> fflush ( clockstats . fp ) ;
<1> static int kvm_get_vcpu_events ( X86CPU * cpu ) {\n<5> if ( ! kvm_has_vcpu_events ( ) ) {\n<8> memset ( & events , 0 , sizeof ( events ) ) ;\n<9> ret = kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_GET_VCPU_EVENTS , & events ) ;\n<26> if ( events . flags & KVM_VCPUEVENT_VALID_SMM ) {\n<52> env -> sipi_vector = events . sipi_vector ;
<1> key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) {\n<18> if ( ! index_key . type -> instantiate || ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ;\n<24> if ( keyring -> type != & key_type_keyring ) goto error_put_type ;\n<25> memset ( & prep , 0 , sizeof ( prep ) ) ;\n<30> if ( index_key . type -> preparse ) {\n<31> ret = index_key . type -> preparse ( & prep ) ;\n<36> if ( ! index_key . description ) index_key . description = prep . description ;\n<38> if ( ! index_key . description ) goto error_free_prep ;\n<40> index_key . desc_len = strlen ( index_key . description ) ;\n<42> ret = restrict_link ( keyring , index_key . type , & prep . payload ) ;\n<48> ret = __key_link_begin ( keyring , & index_key , & edit ) ;\n<59> key_ref = find_key_to_update ( keyring_ref , & index_key ) ;\n<66> if ( index_key . type == & key_type_keyring || index_key . type -> update ) perm |= KEY_POS_WRITE ;\n<68> key = key_alloc ( index_key . type , index_key . description , cred -> fsuid , cred -> fsgid , cred , perm , flags , NULL ) ;\n<73> ret = __key_instantiate_and_link ( key , & prep , keyring , NULL , & edit ) ;\n<80> error_link_end : __key_link_end ( keyring , & index_key , edit ) ;\n<81> error_free_prep : if ( index_key . type -> preparse ) index_key . type -> free_preparse ( & prep ) ;\n<82> error_put_type : key_type_put ( index_key . type ) ;\n<84> found_matching_key : __key_link_end ( keyring , & index_key , edit ) ;\n<85> key_ref = __key_update ( key_ref , & prep ) ;
<1> static void mac_is_copy ( mac_is_sdu * sdu , mac_is_fragment * frag , guint total_length , gboolean reverse ) {\n<3> if ( reverse ) {\n<4> memcpy ( sdu -> data + total_length - frag -> length - sdu -> length , frag -> data , frag -> length ) ;\n<7> memcpy ( sdu -> data + sdu -> length , frag -> data , frag -> length ) ;\n<9> sdu -> length += frag -> length ;\n<10> g_free ( frag -> data ) ;
<1> static int hls_slice_data_wpp(HEVCContext *s, const uint8_t *nal, int length)\n<10> ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);\n<12> s->sList[i] = av_malloc(sizeof(HEVCContext));\n<13> memcpy(s->sList[i], s, sizeof(HEVCContext));\n<15> s->sList[i]->HEVClc = s->HEVClcList[i];\n<34> s->data = nal;\n<38> memcpy(s->sList[i], s, sizeof(HEVCContext));\n<40> avpriv_atomic_int_set(&s->wpp_err, 0);\n<41> ff_reset_entries(s->avctx);\n<46> s->avctx->execute2(s->avctx, (void *) hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);
<1> static int avi_read_packet ( AVFormatContext * s , AVPacket * pkt ) {\n<16> AVIStream * ast = st -> priv_data ;\n<29> pal = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE ) ;\n<30> if ( ! pal ) {\n<34> memcpy ( pal , ast -> pal , AVPALETTE_SIZE ) ;\n<82> ast -> frame_offset += get_duration ( ast , pkt -> size ) ;
<1> PHP_FUNCTION ( locale_get_all_variants ) {\n<21> if ( result > 0 && variant ) {\n<22> token = php_strtok_r ( variant , DELIMITER , & saved_ptr ) ;\n<23> add_next_index_stringl ( return_value , token , strlen ( token ) , TRUE ) ;\n<24> while ( ( token = php_strtok_r ( NULL , DELIMITER , & saved_ptr ) ) && ( strlen ( token ) > 1 ) ) {\n<25> add_next_index_stringl ( return_value , token , strlen ( token ) , TRUE ) ;
<1> static int vnc_refresh_server_surface(VncDisplay *vd)\n<101> server_ptr = server_row0 + y * server_stride + x * cmp_bytes;\n<117> guest_ptr += x * cmp_bytes;\n<123> x++, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n<125> int _cmp_bytes = cmp_bytes;\n<127> if (!test_and_clear_bit(x, vd->guest.dirty[y])) {\n<135> _cmp_bytes = min_stride - x * cmp_bytes;\n<139> if (memcmp(server_ptr, guest_ptr, _cmp_bytes) == 0) {\n<145> memcpy(server_ptr, guest_ptr, _cmp_bytes);\n<147> if (!vd->non_adaptive) {\n<155> QTAILQ_FOREACH(vs, &vd->clients, next) {\n<157> set_bit(x, vs->dirty[y]);\n<161> has_dirty++;
<1> int main ( int argc , char * argv [ ] ) {\n<14> while ( ( c = getopt ( argc , argv , "C:c:p:r:" ) ) != - 1 ) switch ( c ) {\n<28> in = TIFFOpen ( argv [ optind ] , "r" ) ;\n<30> if ( ! TIFFGetField ( in , TIFFTAG_PHOTOMETRIC , & shortv ) || shortv != PHOTOMETRIC_PALETTE ) {\n<31> fprintf ( stderr , "%s: Expecting a palette image.\n" , argv [ optind ] ) ;\n<34> if ( ! TIFFGetField ( in , TIFFTAG_COLORMAP , & rmap , & gmap , & bmap ) ) {\n<35> fprintf ( stderr , "%s: No colormap (not a valid palette image).\n" , argv [ optind ] ) ;\n<40> if ( bitspersample != 8 ) {\n<41> fprintf ( stderr , "%s: Sorry, can only handle 8-bit images.\n" , argv [ optind ] ) ;
<1> int kvm_cpu_exec(CPUState *env)\n<69> if (ret < 0) {\n<71> dprintf("kvm run failed %s\n", strerror(-ret));
<1> static int OpenDecoder ( vlc_object_t * p_this ) {\n<4> switch ( p_dec -> fmt_in . i_codec ) {\n<11> p_dec -> p_sys = p_sys = calloc ( 1 , sizeof ( * p_sys ) ) ;\n<12> if ( p_sys == NULL ) return VLC_ENOMEM ;\n<17> char * var = NULL ;\n<21> msg_Dbg ( p_dec , "trying demuxer-specified character encoding: %s" , encoding ) ;\n<24> if ( ( var = var_InheritString ( p_dec , "subsdec-encoding" ) ) != NULL ) {\n<25> msg_Dbg ( p_dec , "trying configured character encoding: %s" , var ) ;\n<26> if ( ! strcmp ( var , "system" ) ) {\n<27> free ( var ) ;\n<28> var = NULL ;\n<29> encoding = "" ;\n<31> else encoding = var ;\n<35> msg_Dbg ( p_dec , "trying default character encoding: %s" , encoding ) ;\n<37> if ( var_InheritBool ( p_dec , "subsdec-autodetect-utf8" ) ) {\n<38> msg_Dbg ( p_dec , "using automatic UTF-8 detection" ) ;\n<44> if ( p_sys -> iconv_handle == ( vlc_iconv_t ) ( - 1 ) ) msg_Err ( p_dec , "cannot convert from %s: %s" , encoding , vlc_strerror_c ( errno ) ) ;\n<46> free ( var ) ;\n<47> p_sys -> i_align = var_InheritInteger ( p_dec , "subsdec-align" ) ;
<1> void sdl_display_init(DisplayState *ds, int full_screen, int no_frame)\n<85> if (SDL_Init (flags)) {\n<87> fprintf(stderr, "Could not initialize SDL(%s) - exiting\n",
<1> bool check_grant_all_columns ( THD * thd , ulong want_access_arg , Field_iterator_table_ref * fields ) {\n<13> const char * field_name = fields -> name ( ) ;\n<28> if ( want_access ) {\n<29> GRANT_COLUMN * grant_column = column_hash_search ( grant_table , field_name , ( uint ) strlen ( field_name ) ) ;
<1> static int virtio_9p_device_init(VirtIODevice *vdev)\n<41> fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n<45> if (!fse) {\n<49> fprintf(stderr, "Virtio-9p device couldn't find fsdev with the "\n<61> if (!s->fsconf.tag) {\n<65> fprintf(stderr, "fsdev with id %s needs mount_tag arguments\n",\n<77> s->ctx.fs_root = g_strdup(fse->path);\n<81> len = strlen(s->fsconf.tag);\n<83> if (len > MAX_TAG_LEN - 1) {\n<85> fprintf(stderr, "mount tag '%s' (%d bytes) is longer than "\n<87> "maximum (%d bytes)", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n<95> s->tag = g_strdup(s->fsconf.tag);\n<111> if (s->ops->init(&s->ctx) < 0) {\n<113> fprintf(stderr, "Virtio-9p Failed to initialize fs-driver with id:%s"\n<121> if (v9fs_init_worker_threads() < 0) {\n<123> fprintf(stderr, "worker thread initialization failed\n");\n<143> if (s->ops->name_to_path(&s->ctx, NULL, "/", &path) < 0) {\n<147> "error in converting name to path %s", strerror(errno));\n<153> if (s->ops->lstat(&s->ctx, &path, &stat)) {\n<155> fprintf(stderr, "share path %s does not exist\n", fse->path);\n<159> } else if (!S_ISDIR(stat.st_mode)) {\n<161> fprintf(stderr, "share path %s is not a directory\n", fse->path);\n<175> g_free(s->ctx.fs_root);
<1> static void blkverify_err(BlkverifyAIOCB *acb, const char *fmt, ...)\n<11> fprintf(stderr, "blkverify: %s sector_num=%ld nb_sectors=%d ",\n<17> vfprintf(stderr, fmt, ap);\n<19> fprintf(stderr, "\n");
<1> static void vmsWarningHandler ( const char * module , const char * fmt , va_list ap ) {\n<2> if ( module != NULL ) fprintf ( stderr , "%s: " , module ) ;\n<3> fprintf ( stderr , "Warning, " ) ;\n<4> vfprintf ( stderr , fmt , ap ) ;\n<5> fprintf ( stderr , ".\n" ) ;
<1> static void mclms_update ( WmallDecodeCtx * s , int icoef , int * pred ) {\n<37> s -> mclms_prevvalues [ s -> mclms_recent ] = s -> channel_residues [ ich ] [ icoef ] ;\n<38> if ( s -> channel_residues [ ich ] [ icoef ] > range - 1 ) s -> mclms_prevvalues [ s -> mclms_recent ] = range - 1 ;\n<39> else if ( s -> channel_residues [ ich ] [ icoef ] < - range ) s -> mclms_prevvalues [ s -> mclms_recent ] = - range ;\n<40> s -> mclms_updates [ s -> mclms_recent ] = 0 ;\n<41> if ( s -> channel_residues [ ich ] [ icoef ] > 0 ) s -> mclms_updates [ s -> mclms_recent ] = 1 ;\n<42> else if ( s -> channel_residues [ ich ] [ icoef ] < 0 ) s -> mclms_updates [ s -> mclms_recent ] = - 1 ;\n<44> if ( s -> mclms_recent == 0 ) {\n<45> memcpy ( & s -> mclms_prevvalues [ order * num_channels ] , s -> mclms_prevvalues , 2 * order * num_channels ) ;\n<46> memcpy ( & s -> mclms_updates [ order * num_channels ] , s -> mclms_updates , 2 * order * num_channels ) ;
<1> int ff_h264_handle_frag_packet ( AVPacket * pkt , const uint8_t * buf , int len , int start_bit , const uint8_t * nal_header , int nal_header_len ) {\n<4> int pos = 0 ;\n<6> if ( ( ret = av_new_packet ( pkt , tot_len ) ) < 0 ) return ret ;\n<7> if ( start_bit ) {\n<8> memcpy ( pkt -> data + pos , start_sequence , sizeof ( start_sequence ) ) ;\n<9> pos += sizeof ( start_sequence ) ;\n<10> memcpy ( pkt -> data + pos , nal_header , nal_header_len ) ;\n<11> pos += nal_header_len ;\n<13> memcpy ( pkt -> data + pos , buf , len ) ;
<1> static int usage(int ret)\n<5> fprintf(stderr, "dump (up to maxpkts) AVPackets as they are demuxed by libavformat.\n");\n<7> fprintf(stderr, "each packet is dumped in its own file named like `basename file.ext`_$PKTNUM_$STREAMINDEX_$STAMP_$SIZE_$FLAGS.bin\n");\n<9> fprintf(stderr, "pktdumper file [maxpkts]\n");
<1> static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,\n<53> if (irqchip_required && !dev) {\n<55> fprintf(stderr, "%s: irqchip requested but unavailable\n",
<1> struct zip_cdir * _zip_cdir_new ( int nentry , struct zip_error * error ) {\n<3> if ( ( cd = ( struct zip_cdir * ) malloc ( sizeof ( * cd ) ) ) == NULL ) {\n<4> _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n<5> return NULL ;\n<7> if ( nentry > ( ( size_t ) - 1 ) / sizeof ( * ( cd -> entry ) ) || ( cd -> entry = ( struct zip_dirent * ) malloc ( sizeof ( * ( cd -> entry ) ) * ( size_t ) nentry ) ) == NULL ) {\n<9> free ( cd ) ;\n<10> return NULL ;\n<14> cd -> comment = NULL ;\n<16> return cd ;
<1> static void xml_print_section_footer ( WriterContext * wctx ) {\n<3> const struct section * section = wctx -> section [ wctx -> level ] ;\n<4> if ( wctx -> level == 0 ) {\n<5> printf ( "</%sffprobe>\n" , xml -> fully_qualified ? "ffprobe:" : "" ) ;\n<7> else if ( xml -> within_tag ) {\n<9> printf ( "/>\n" ) ;\n<12> else if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) {\n<17> printf ( "</%s>\n" , section -> name ) ;
<1> static int avui_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<29> if ((ret = ff_alloc_packet2(avctx, pkt, size)) < 0)\n<35> if (!(avctx->extradata = av_mallocz(24 + FF_INPUT_BUFFER_PADDING_SIZE)))\n<41> memcpy(avctx->extradata, "\0\0\0\x18""APRGAPRG0001", 16);\n<69> src = pic->data[0] + (1 - i) * pic->linesize[0];\n<73> src = pic->data[0] + i * pic->linesize[0];\n<77> dst += avctx->width * skip + 4 * i;\n<79> for (j = 0; j < avctx->height; j += interlaced + 1) {\n<81> memcpy(dst, src, avctx->width * 2);\n<83> src += (interlaced + 1) * pic->linesize[0];\n<85> dst += avctx->width * 2;
<1> static int net_vde_init(VLANState *vlan, const char *model,\n<3> const char *name, const char *sock,\n<5> int port, const char *group, int mode)\n<11> char *init_group = strlen(group) ? (char *)group : NULL;\n<13> char *init_sock = strlen(sock) ? (char *)sock : NULL;\n<21> .group = init_group,\n<29> s = qemu_mallocz(sizeof(VDEState));\n<31> s->vde = vde_open(init_sock, "QEMU", &args);\n<33> if (!s->vde){\n<35> free(s);\n<45> snprintf(s->vc->info_str, sizeof(s->vc->info_str), "sock=%s,fd=%d",
<1> static void stream_add_data ( struct attachment_istream * astream , const void * data , size_t size ) {\n<2> if ( size > 0 ) {\n<3> memcpy ( i_stream_alloc ( & astream -> istream , size ) , data , size ) ;\n<4> astream -> istream . pos += size ;
<1> int vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<27> if (ret < 0)\n<51> if (avctx->skip_frame >= skip_thresh) {\n<55> memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);\n<109> if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n<133> if ((ret = vp8_alloc_frame(s, curframe, referenced)) < 0)\n<187> memset(s->top_nnz, 0, s->mb_width * sizeof(*s->top_nnz));\n<193> if (!s->mb_layout)\n<195> memset(s->macroblocks + s->mb_height * 2 - 1, 0,\n<197> (s->mb_width + 1) * sizeof(*s->macroblocks));\n<199> if (!s->mb_layout && s->keyframe)\n<201> memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width * 4);\n<205> memset(s->ref_count, 0, sizeof(s->ref_count));\n<277> memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);\n<309> memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);
<1> static int send_invoke_response(URLContext *s, RTMPPacket *pkt)\n<31> if (ff_amf_read_string(&gbc, command, sizeof(command),\n<51> if (ret)\n<55> if (!strcmp(command, "FCPublish") ||\n<57> !strcmp(command, "publish")) {\n<59> ret = ff_amf_read_string(&gbc, filename,\n<61> sizeof(filename), &stringlen);\n<63> if (ret) {\n<79> if (s->filename) {\n<95> pchar++;\n<97> if (strcmp(pchar, filename))\n<99> av_log(s, AV_LOG_WARNING, "Unexpected stream %s, expecting"\n<111> if (!strcmp(command, "FCPublish")) {\n<113> if ((ret = ff_rtmp_packet_create(&spkt, RTMP_SYSTEM_CHANNEL,\n<129> } else if (!strcmp(command, "publish")) {\n<131> ret = write_begin(s);\n<133> if (ret < 0)\n<141> return write_status(s, pkt, "NetStream.Publish.Start",\n<145> } else if (!strcmp(command, "play")) {\n<147> ret = write_begin(s);\n<149> if (ret < 0)\n<161> if ((ret = ff_rtmp_packet_create(&spkt, RTMP_SYSTEM_CHANNEL,\n<181> if (!strcmp(command, "createStream")) {\n<183> rt->nb_streamid++;\n<185> if (rt->nb_streamid == 0 || rt->nb_streamid == 2)\n<189> ff_amf_write_number(&pp, rt->nb_streamid);
<1> static int svq1_decode_frame(AVCodecContext *avctx,\n<104> if (!pmv)\n<154> if (s->pict_type == AV_PICTURE_TYPE_I) {\n<184> memset (pmv, 0, ((width / 8) + 3) * sizeof(svq1_pmv));\n<192> result = svq1_decode_delta_block (s, &s->gb, &current[x], previous,\n<242> av_free(pmv);
<1> static int tmv_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<13> if ( avpkt -> size < 2 * char_rows * char_cols ) {\n<22> memcpy ( frame -> data [ 1 ] , ff_cga_palette , 16 * 4 ) ;
<1> static void float_number(void)\n<39> obj = qobject_from_json(test_cases[i].encoded, NULL);\n<49> if (test_cases[i].skip == 0) {\n<57> g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
<1> int net_init_l2tpv3(const NetClientOptions *opts,\n<23> struct addrinfo *result = NULL;\n<33> s = DO_UPCAST(NetL2TPV3State, nc, nc);\n<105> if (l2tpv3->has_udp && l2tpv3->udp) {\n<109> if (!(l2tpv3->has_srcport && l2tpv3->has_dstport)) {\n<189> memset(&hints, 0, sizeof(hints));\n<195> hints.ai_family = AF_INET6;\n<199> hints.ai_family = AF_INET;\n<205> hints.ai_socktype = SOCK_DGRAM;\n<207> hints.ai_protocol = 0;\n<219> hints.ai_socktype = SOCK_RAW;\n<221> hints.ai_protocol = IPPROTO_L2TP;\n<227> gairet = getaddrinfo(l2tpv3->src, srcport, &hints, &result);\n<231> if ((gairet != 0) || (result == NULL)) {\n<245> fd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);\n<257> if (bind(fd, (struct sockaddr *) result->ai_addr, result->ai_addrlen)) {\n<273> memset(&hints, 0, sizeof(hints));\n<303> result = NULL;\n<305> gairet = getaddrinfo(l2tpv3->dst, dstport, &hints, &result);\n<307> if ((gairet != 0) || (result == NULL)) {\n<323> s->dgram_dst = g_malloc(sizeof(struct sockaddr_storage));\n<325> memset(s->dgram_dst, '\0' , sizeof(struct sockaddr_storage));\n<327> memcpy(s->dgram_dst, result->ai_addr, result->ai_addrlen);\n<329> s->dst_size = result->ai_addrlen;\n<335> freeaddrinfo(result);\n<391> s->msgvec = build_l2tpv3_vector(s, MAX_L2TPV3_MSGCNT);\n<409> l2tpv3_read_poll(s, true);
<1> int main ( int argc , char * * argv ) {\n<12> timerpids = malloc ( sizeof ( int ) * num_cpus ) ;\n<30> OPTARG ( "--version" , "-ve" ) printf ( "Das Version die Uhr Hund %s nach sein bist.\n" , VERSION ) ;\n<36> syslog ( LOG_INFO , "started" ) ;
<1> void evhttp_free ( struct evhttp * http ) {\n<6> while ( ( bound = TAILQ_FIRST ( & http -> sockets ) ) != NULL ) {\n<7> TAILQ_REMOVE ( & http -> sockets , bound , next ) ;\n<11> free ( bound ) ;\n<13> while ( ( evcon = TAILQ_FIRST ( & http -> connections ) ) != NULL ) {\n<16> while ( ( http_cb = TAILQ_FIRST ( & http -> callbacks ) ) != NULL ) {\n<17> TAILQ_REMOVE ( & http -> callbacks , http_cb , next ) ;\n<18> free ( http_cb -> what ) ;\n<19> free ( http_cb ) ;\n<21> free ( http ) ;
<1> void usage_exit ( ) {\n<2> fprintf ( stderr , "Usage: %s <options> input_filename output_filename\n" , exec_name ) ;\n<3> fprintf ( stderr , "Options:\n" ) ;\n<4> arg_show_usage ( stderr , svc_args ) ;
<1> static void test_buffers ( ) {\n<19> memset ( buffer , 0 , sizeof ( buffer ) ) ;\n<20> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<25> my_bind [ 0 ] . buffer = ( void * ) buffer ;\n<27> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<31> buffer [ 1 ] = 'X' ;\n<35> if ( ! opt_silent ) fprintf ( stdout , "\n data: %s (%lu)" , buffer , length ) ;\n<36> DIE_UNLESS ( buffer [ 0 ] == 'M' ) ;\n<37> DIE_UNLESS ( buffer [ 1 ] == 'X' ) ;\n<38> DIE_UNLESS ( length == 5 ) ;\n<44> if ( ! opt_silent ) fprintf ( stdout , "\n data: %s (%lu)" , buffer , length ) ;\n<45> DIE_UNLESS ( strncmp ( buffer , "Database" , 8 ) == 0 ) ;\n<46> DIE_UNLESS ( length == 8 ) ;\n<52> if ( ! opt_silent ) fprintf ( stdout , "\n data: %s (%lu)" , buffer , length ) ;\n<53> DIE_UNLESS ( strcmp ( buffer , "Open-Source" ) == 0 ) ;\n<54> DIE_UNLESS ( length == 11 ) ;\n<61> if ( ! opt_silent ) fprintf ( stdout , "\n data: %s (%lu)" , buffer , length ) ;\n<62> DIE_UNLESS ( strncmp ( buffer , "Popula" , 6 ) == 0 ) ;\n<63> DIE_UNLESS ( length == 7 ) ;
<1> gpg_error_t ksba_oid_from_str ( const char * string , unsigned char * * rbuf , size_t * rlength ) {\n<10> if ( ! strncmp ( string , "oid." , 4 ) || ! strncmp ( string , "OID." , 4 ) ) string += 4 ;\n<11> if ( ! * string ) return gpg_error ( GPG_ERR_INV_VALUE ) ;\n<12> buf = xtrymalloc ( strlen ( string ) + 2 ) ;\n<13> if ( ! buf ) return gpg_error ( GPG_ERR_ENOMEM ) ;\n<19> val = strtoul ( string , ( char * * ) & endp , 10 ) ;
<1> static SchroBuffer * find_next_parse_unit ( SchroParseUnitContext * parse_ctx ) {\n<5> if ( parse_ctx -> buf_size < 13 || parse_ctx -> buf [ 0 ] != 'B' || parse_ctx -> buf [ 1 ] != 'B' || parse_ctx -> buf [ 2 ] != 'C' || parse_ctx -> buf [ 3 ] != 'D' ) return NULL ;\n<6> next_pu_offset = ( parse_ctx -> buf [ 5 ] << 24 ) + ( parse_ctx -> buf [ 6 ] << 16 ) + ( parse_ctx -> buf [ 7 ] << 8 ) + parse_ctx -> buf [ 8 ] ;\n<7> if ( next_pu_offset == 0 && SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE ( parse_ctx -> buf [ 4 ] ) ) next_pu_offset = 13 ;\n<9> in_buf = av_malloc ( next_pu_offset ) ;\n<10> if ( ! in_buf ) {\n<14> memcpy ( in_buf , parse_ctx -> buf , next_pu_offset ) ;\n<15> enc_buf = schro_buffer_new_with_data ( in_buf , next_pu_offset ) ;\n<18> parse_ctx -> buf += next_pu_offset ;
<1> static int qpel_motion_search(MpegEncContext * s,\n<97> int best[8];\n<103> memset(best, 64, sizeof(int)*8);\n<151> if(score < best[i]){\n<153> memmove(&best[i+1], &best[i], sizeof(int)*(7-i));\n<155> memmove(&best_pos[i+1][0], &best_pos[i][0], sizeof(int)*2*(7-i));\n<159> best_pos[i][0]= nx + 4*mx;\n<241> if(score < best[i]){\n<243> memmove(&best[i+1], &best[i], sizeof(int)*(7-i));\n<245> memmove(&best_pos[i+1][0], &best_pos[i][0], sizeof(int)*2*(7-i));\n<249> best_pos[i][0]= nx + 4*mx;\n<267> nx= best_pos[i][0];
<1> static void decode_postinit(H264Context *h, int setup_finished)\n<79> if (FIELD_OR_MBAFF_PICTURE(h))\n<131> cur->f->interlaced_frame = FIELD_OR_MBAFF_PICTURE(h);\n<267> if (!rotation)\n<363> cnt     += out->poc < h->last_pocs[i];\n<385> h->last_pocs[i] = INT_MIN;\n<475> sizeof(*h->last_pocs) * (MAX_DELAYED_PIC_COUNT - 1));
<1> static void HandleType3Reference ( IO * wrapper , EntityChar * ec , real transform [ 6 ] , char * tokbuf , int toksize ) {\n<6> tok = nextpstoken ( wrapper , & dval , tokbuf , toksize ) ;\n<7> if ( strcmp ( tokbuf , "get" ) != 0 ) return ;\n<8> tok = nextpstoken ( wrapper , & dval , tokbuf , toksize ) ;\n<9> if ( tok != pt_namelit ) return ;\n<10> glyphname = copy ( tokbuf ) ;\n<11> tok = nextpstoken ( wrapper , & dval , tokbuf , toksize ) ;\n<12> if ( strcmp ( tokbuf , "get" ) != 0 ) {\n<13> free ( glyphname ) ;\n<14> return ;\n<16> tok = nextpstoken ( wrapper , & dval , tokbuf , toksize ) ;\n<17> if ( strcmp ( tokbuf , "exec" ) != 0 ) {\n<18> free ( glyphname ) ;\n<19> return ;\n<21> ref = RefCharCreate ( ) ;\n<22> memcpy ( ref -> transform , transform , sizeof ( ref -> transform ) ) ;\n<23> ref -> sc = ( SplineChar * ) glyphname ;\n<24> ref -> next = ec -> refs ;\n<25> ec -> refs = ref ;
<1> read_help(void)
<1> char * evhttp_encode_uri ( const char * uri ) {\n<15> p = strdup ( ( char * ) EVBUFFER_DATA ( buf ) ) ;\n<17> return ( p ) ;
<1> static int decode_byterun(uint8_t *dst, int dst_size,\n<11> for (x = 0; x < dst_size && buf < buf_end;) {\n<17> if (value >= 0) {\n<21> memcpy(dst + x, buf, FFMIN3(length, dst_size - x, buf_end - buf));\n<23> buf += length;\n<25> } else if (value > -128) {\n<29> memset(dst + x, *buf++, FFMIN(length, dst_size - x));\n<41> if (x < dst_size) {\n<45> memset(dst+x, 0, dst_size - x);
<1> static int getfoghex ( _IO * io ) {\n<3> while ( isspace ( ch = getc ( io -> fog ) ) ) ;\n<4> if ( isdigit ( ch ) ) val = ch - '0' ;\n<5> else if ( ch >= 'A' && ch <= 'F' ) val = ch - 'A' + 10 ;\n<6> else if ( ch >= 'a' && ch <= 'f' ) val = ch - 'a' + 10 ;\n<9> while ( isspace ( ch = getc ( io -> fog ) ) ) ;\n<10> if ( isdigit ( ch ) ) val |= ch - '0' ;
<1> static void freestuff ( struct psstack * stack , int sp , struct pskeydict * dict , GrowBuf * gb , struct garbage * tofrees ) {\n<3> free ( gb -> base ) ;\n<5> i < dict -> cnt ;\n<7> if ( dict -> entries [ i ] . type == ps_string || dict -> entries [ i ] . type == ps_instr || dict -> entries [ i ] . type == ps_lit ) free ( dict -> entries [ i ] . u . str ) ;\n<8> free ( dict -> entries [ i ] . key ) ;\n<10> free ( dict -> entries ) ;\n<14> if ( stack [ i ] . type == ps_string || stack [ i ] . type == ps_instr || stack [ i ] . type == ps_lit ) free ( stack [ i ] . u . str ) ;
<1> static int mov_read_custom_2plus(MOVContext *c, AVIOContext *pb, int size)\n<7> uint8_t *key = NULL, *val = NULL;\n<89> if (key && val) {\n<91> if (strcmp(key, "iTunSMPB") == 0) {\n<95> if(sscanf(val, "%*X %X %X %X", &priming, &remainder, &samples) == 3){\n<97> if(priming>0 && priming<16384)\n<99> sc->start_pad = priming;\n<105> if (strcmp(key, "cdec") != 0) {\n<107> av_dict_set(&c->fc->metadata, key, val,\n<109> AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);\n<111> key = val = NULL;\n<121> av_freep(&key);\n<123> av_freep(&val);
<1> static void show_query ( MYSQL * mysql , const char * query ) {\n<5> if ( mysql_query ( mysql , query ) ) {\n<6> log_msg ( "Error running query '%s': %d %s" , query , mysql_errno ( mysql ) , mysql_error ( mysql ) ) ;\n<18> fprintf ( stderr , "=== %s ===\n" , query ) ;\n<19> while ( ( row = mysql_fetch_row ( res ) ) ) {\n<20> unsigned long * lengths = mysql_fetch_lengths ( res ) ;\n<21> row_num ++ ;\n<22> fprintf ( stderr , "---- %d. ----\n" , row_num ) ;\n<24> i < num_fields ;\n<26> fprintf ( stderr , "%s\t%.*s\n" , fields [ i ] . name , ( int ) lengths [ i ] , row [ i ] ? row [ i ] : "NULL" ) ;\n<29> for ( i = 0 ;\n<30> i < strlen ( query ) + 8 ;\n<31> i ++ ) fprintf ( stderr , "=" ) ;\n<32> fprintf ( stderr , "\n\n" ) ;
<1> static void mcf5208evb_init(MachineState *machine)\n<39> if (!cpu) {\n<41> fprintf(stderr, "Unable to find m68k CPU definition\n");\n<93> if (nb_nics > 1) {\n<95> fprintf(stderr, "Too many NICs\n");\n<159> if (qtest_enabled()) {\n<165> fprintf(stderr, "Kernel image must be specified\n");\n<173> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<181> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n<189> kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n<197> if (kernel_size < 0) {\n<199> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> static void do_video_stats(AVOutputStream *ost,\n<5> int frame_size)\n<17> char filename[40];\n<29> if (!fvstats) {\n<33> today = localtime(&today2);\n<35> sprintf(filename, "vstats_%02d%02d%02d.log", today->tm_hour,\n<41> fvstats = fopen(filename,"w");\n<43> if (!fvstats) {\n<57> enc = &ost->st->codec;\n<61> if (enc->codec_type == CODEC_TYPE_VIDEO) {\n<63> frame_number = ist->frame_number;\n<65> fprintf(fvstats, "frame= %5d q= %2d ", frame_number, enc->quality);\n<67> if (do_psnr)\n<69> fprintf(fvstats, "PSNR= %6.2f ", enc->psnr_y);\n<73> fprintf(fvstats,"f_size= %6d ", frame_size);\n<91> bitrate = (double)(frame_size * 8) * enc->frame_rate / FRAME_RATE_BASE / 1000.0;\n<93> avg_bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n<95> fprintf(fvstats, "s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s ",\n<97> (double)total_size / 1024, ti1, bitrate, avg_bitrate);\n<99> fprintf(fvstats,"type= %s\n", enc->key_frame == 1 ? "I" : "P");
<1> int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,\n<29> if (buf_size == 0) {\n<33> memset(dummy_buf, 0, sizeof(dummy_buf));\n<35> buf = dummy_buf;
<1> WORK_STATE tls_post_process_client_key_exchange ( SSL * s , WORK_STATE wst ) {\n<3> if ( SSL_IS_DTLS ( s ) ) {\n<5> char labelbuffer [ sizeof ( DTLS1_SCTP_AUTH_LABEL ) ] ;\n<6> memcpy ( labelbuffer , DTLS1_SCTP_AUTH_LABEL , sizeof ( DTLS1_SCTP_AUTH_LABEL ) ) ;
<1> static int _ar_read_header ( struct archive_read * a , struct archive_entry * entry , struct ar * ar , const char * h , size_t * unconsumed ) {\n<2> char filename [ AR_name_size + 1 ] ;\n<8> if ( strncmp ( h + AR_fmag_offset , "`\n" , 2 ) != 0 ) {\n<12> strncpy ( filename , h + AR_name_offset , AR_name_size ) ;\n<13> filename [ AR_name_size ] = '\0' ;\n<15> if ( strncmp ( filename , "#1/" , 3 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n<16> else if ( strchr ( filename , '/' ) != NULL ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_GNU ;\n<17> else if ( strncmp ( filename , "__.SYMDEF" , 9 ) == 0 ) a -> archive . archive_format = ARCHIVE_FORMAT_AR_BSD ;\n<22> p = filename + AR_name_size - 1 ;\n<23> while ( p >= filename && * p == ' ' ) {\n<24> * p = '\0' ;\n<27> if ( filename [ 0 ] != '/' && p > filename && * p == '/' ) {\n<28> * p = '\0' ;\n<30> if ( p < filename ) {\n<34> if ( strcmp ( filename , "//" ) == 0 ) {\n<35> ar_parse_common_header ( ar , entry , h ) ;\n<36> archive_entry_copy_pathname ( entry , filename ) ;\n<37> archive_entry_set_filetype ( entry , AE_IFREG ) ;\n<38> number = ar_atol10 ( h + AR_size_offset , AR_size_size ) ;\n<39> if ( number > SIZE_MAX ) {\n<44> if ( entry_size == 0 ) {\n<48> if ( ar -> strtab != NULL ) {\n<52> st = malloc ( entry_size ) ;\n<53> if ( st == NULL ) {\n<58> ar -> strtab_size = entry_size ;\n<63> if ( ( b = __archive_read_ahead ( a , entry_size , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ;\n<64> memcpy ( st , b , entry_size ) ;\n<65> __archive_read_consume ( a , entry_size ) ;\n<70> if ( filename [ 0 ] == '/' && filename [ 1 ] >= '0' && filename [ 1 ] <= '9' ) {\n<71> number = ar_atol10 ( h + AR_name_offset + 1 , AR_name_size - 1 ) ;\n<72> if ( ar -> strtab == NULL || number > ar -> strtab_size ) {\n<74> archive_entry_copy_pathname ( entry , filename ) ;\n<81> if ( strncmp ( filename , "#1/" , 3 ) == 0 ) {\n<83> number = ar_atol10 ( h + AR_name_offset + 3 , AR_name_size - 3 ) ;\n<95> if ( ( b = __archive_read_ahead ( a , bsd_name_length , NULL ) ) == NULL ) {\n<99> p = ( char * ) malloc ( bsd_name_length + 1 ) ;\n<100> if ( p == NULL ) {\n<104> strncpy ( p , b , bsd_name_length ) ;\n<105> p [ bsd_name_length ] = '\0' ;\n<106> __archive_read_consume ( a , bsd_name_length ) ;\n<107> archive_entry_copy_pathname ( entry , p ) ;\n<108> free ( p ) ;\n<111> if ( strcmp ( filename , "/" ) == 0 ) {\n<112> archive_entry_copy_pathname ( entry , "/" ) ;\n<113> r = ar_parse_common_header ( ar , entry , h ) ;\n<114> archive_entry_set_filetype ( entry , AE_IFREG ) ;\n<115> return ( r ) ;\n<117> if ( strcmp ( filename , "__.SYMDEF" ) == 0 ) {\n<118> archive_entry_copy_pathname ( entry , filename ) ;\n<119> return ( ar_parse_common_header ( ar , entry , h ) ) ;\n<121> archive_entry_copy_pathname ( entry , filename ) ;\n<122> return ( ar_parse_common_header ( ar , entry , h ) ) ;
<1> int ff_rv34_decode_update_thread_context(AVCodecContext *dst, const AVCodecContext *src)\n<5> RV34DecContext *r = dst->priv_data, *r1 = src->priv_data;\n<31> if ((err = rv34_decoder_realloc(r)) < 0)\n<39> if ((err = ff_mpeg_update_thread_context(dst, src)))\n<53> memset(&r->si, 0, sizeof(r->si));
<1> static int get_device_guid(\n<7> char *actual_name,\n<155> if (actual_name) {\n<157> if (strcmp(actual_name, "") != 0) {\n<159> if (strcmp(name_data, actual_name) != 0) {\n<161> RegCloseKey (connection_key);\n<163> ++i;\n<173> snprintf(actual_name, actual_name_size, "%s", name_data);\n<179> stop = 1;\n<187> RegCloseKey (connection_key);\n<191> ++i;
<1> static void vscsi_got_payload(VSCSIState *s, vscsi_crq *crq)\n<13> if (req == NULL) {\n<15> fprintf(stderr, "VSCSI: Failed to get a request !\n");\n<33> if (crq->s.IU_length > sizeof(union viosrp_iu)) {\n<35> fprintf(stderr, "VSCSI: SRP IU too long (%d bytes) !\n",\n<47> if (spapr_tce_dma_read(&s->vdev, crq->s.IU_data_ptr, &req->iu,\n<51> fprintf(stderr, "vscsi_got_payload: DMA read failure !\n");\n<53> g_free(req);\n<57> memcpy(&req->crq, crq, sizeof(vscsi_crq));
<1> void ff_xvmc_decode_mb ( MpegEncContext * s ) {\n<96> i < blocks_per_mb ;\n<98> memset ( s -> pblocks [ i ] , 0 , sizeof ( * s -> pblocks [ i ] ) ) ;\n<117> if ( s -> avctx -> xvmc_acceleration == 1 ) {\n<118> memcpy ( & render -> data_blocks [ render -> next_free_data_block_num * 64 ] , s -> pblocks [ i ] , sizeof ( * s -> pblocks [ i ] ) ) ;
<1> int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res)\n<5> if (bs->drv->bdrv_check == NULL) {\n<13> memset(res, 0, sizeof(*res));\n<17> return res->corruptions < 0 ? res->corruptions : 0;
<1> static int drive_init(struct drive_opt *arg, int snapshot,\n<53> if (check_params(buf, sizeof(buf), params, str) < 0) {\n<55> fprintf(stderr, "qemu: unknown parameter '%s' in '%s'\n",\n<107> if (get_param_value(buf, sizeof(buf), "bus", str)) {\n<111> if (bus_id < 0) {\n<113> fprintf(stderr, "qemu: '%s' invalid bus id\n", str);\n<123> if (get_param_value(buf, sizeof(buf), "unit", str)) {\n<127> if (unit_id < 0) {\n<129> fprintf(stderr, "qemu: '%s' invalid unit id\n", str);\n<139> if (get_param_value(buf, sizeof(buf), "if", str)) {\n<141> pstrcpy(devname, sizeof(devname), buf);\n<143> if (!strcmp(buf, "ide")) {\n<145> type = IF_IDE;\n<147> max_devs = MAX_IDE_DEVS;\n<149> } else if (!strcmp(buf, "scsi")) {\n<151> type = IF_SCSI;\n<153> max_devs = MAX_SCSI_DEVS;\n<155> } else if (!strcmp(buf, "floppy")) {\n<157> type = IF_FLOPPY;\n<159> max_devs = 0;\n<161> } else if (!strcmp(buf, "pflash")) {\n<163> type = IF_PFLASH;\n<165> max_devs = 0;\n<167> } else if (!strcmp(buf, "mtd")) {\n<169> type = IF_MTD;\n<171> max_devs = 0;\n<173> } else if (!strcmp(buf, "sd")) {\n<175> type = IF_SD;\n<177> max_devs = 0;\n<179> } else if (!strcmp(buf, "virtio")) {\n<181> type = IF_VIRTIO;\n<183> max_devs = 0;\n<187> fprintf(stderr, "qemu: '%s' unsupported bus type '%s'\n", str, buf);\n<189> return -1;\n<197> if (get_param_value(buf, sizeof(buf), "index", str)) {\n<201> if (index < 0) {\n<203> fprintf(stderr, "qemu: '%s' invalid index\n", str);\n<229> if (get_param_value(buf, sizeof(buf), "secs", str)) {\n<239> if (cyls < 1 || cyls > 16383) {\n<241> fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", str);\n<247> if (heads < 1 || heads > 16) {\n<249> fprintf(stderr, "qemu: '%s' invalid physical heads number\n", str);\n<255> if (secs < 1 || secs > 63) {\n<257> fprintf(stderr, "qemu: '%s' invalid physical secs number\n", str);\n<267> if (get_param_value(buf, sizeof(buf), "trans", str)) {\n<269> if (!cyls) {\n<281> if (!strcmp(buf, "none"))\n<283> translation = BIOS_ATA_TRANSLATION_NONE;\n<285> else if (!strcmp(buf, "lba"))\n<287> translation = BIOS_ATA_TRANSLATION_LBA;\n<289> else if (!strcmp(buf, "auto"))\n<291> translation = BIOS_ATA_TRANSLATION_AUTO;\n<295> fprintf(stderr, "qemu: '%s' invalid translation type\n", str);\n<297> return -1;\n<305> if (get_param_value(buf, sizeof(buf), "media", str)) {\n<307> if (!strcmp(buf, "disk")) {\n<309> media = MEDIA_DISK;\n<311> } else if (!strcmp(buf, "cdrom")) {\n<313> if (cyls || secs || heads) {\n<327> fprintf(stderr, "qemu: '%s' invalid media\n", str);\n<329> return -1;\n<337> if (get_param_value(buf, sizeof(buf), "snapshot", str)) {\n<339> if (!strcmp(buf, "on"))\n<341> snapshot = 1;\n<343> else if (!strcmp(buf, "off"))\n<345> snapshot = 0;\n<349> fprintf(stderr, "qemu: '%s' invalid snapshot option\n", str);\n<351> return -1;\n<359> if (get_param_value(buf, sizeof(buf), "cache", str)) {\n<361> if (!strcmp(buf, "off") || !strcmp(buf, "none"))\n<363> cache = 0;\n<365> else if (!strcmp(buf, "writethrough"))\n<367> cache = 1;\n<369> else if (!strcmp(buf, "writeback"))\n<371> cache = 2;\n<375> fprintf(stderr, "qemu: invalid cache option\n");\n<377> return -1;\n<385> if (get_param_value(buf, sizeof(buf), "format", str)) {\n<387> if (strcmp(buf, "?") == 0) {\n<389> fprintf(stderr, "qemu: Supported formats:");\n<391> bdrv_iterate_format(bdrv_format_print, NULL);\n<393> fprintf(stderr, "\n");\n<395> return -1;\n<399> drv = bdrv_find_format(buf);\n<401> if (!drv) {\n<403> fprintf(stderr, "qemu: '%s' invalid format\n", buf);\n<423> if (!get_param_value(serial, sizeof(serial), "serial", str))\n<425> memset(serial, 0,  sizeof(serial));\n<431> if (get_param_value(buf, sizeof(serial), "werror", str)) {\n<433> if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n<435> fprintf(stderr, "werror is no supported by this format\n");\n<441> if (!strcmp(buf, "ignore"))\n<443> onerror = BLOCK_ERR_IGNORE;\n<445> else if (!strcmp(buf, "enospc"))\n<447> onerror = BLOCK_ERR_STOP_ENOSPC;\n<449> else if (!strcmp(buf, "stop"))\n<451> onerror = BLOCK_ERR_STOP_ANY;\n<453> else if (!strcmp(buf, "report"))\n<455> onerror = BLOCK_ERR_REPORT;\n<459> fprintf(stderr, "qemu: '%s' invalid write error action\n", buf);\n<461> return -1;\n<473> if (index != -1) {\n<475> if (bus_id != 0 || unit_id != -1) {\n<513> if (unit_id == -1) {\n<517> while (drive_get_index(type, bus_id, unit_id) != -1) {\n<539> if (max_devs && unit_id >= max_devs) {\n<541> fprintf(stderr, "qemu: '%s' unit %d too big (max is %d)\n",\n<543> str, unit_id, max_devs - 1);\n<559> if (drive_get_index(type, bus_id, unit_id) != -1)\n<601> strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n<659> if (!file[0])\n<685> if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0 || qemu_key_check(bdrv, file)) {\n<687> fprintf(stderr, "qemu: could not open disk image %s\n",
<57> header_size      = decode_mime_header(ctx, buf);\n<89> if (ctx->fr_cur_mode >= MODE_SID)\n<121> stab_fac = stability_factor(ctx->isf_cur, ctx->isf_past_final);\n<125> ctx->isf_cur[LP_ORDER - 1] *= 2.0;\n<127> ff_acelp_lsf2lspd(ctx->isp[3], ctx->isf_cur, LP_ORDER);\n<133> if (ctx->first_frame) {\n<137> memcpy(ctx->isp_sub4_past, ctx->isp[3], LP_ORDER * sizeof(double));\n<141> interpolate_isp(ctx->isp, ctx->isp_sub4_past);\n<285> hb_synthesis(ctx, sub, &ctx->samples_hb[LP_ORDER_16k],\n<317> update_sub_state(ctx);\n<325> memcpy(ctx->isp_sub4_past, ctx->isp[3], LP_ORDER * sizeof(ctx->isp[3][0]));\n<327> memcpy(ctx->isf_past_final, ctx->isf_cur, LP_ORDER * sizeof(float));
<3> Mpeg1Context * s1 = ( Mpeg1Context * ) s ;\n<19> if ( ! pan_scan ) return AVERROR ( ENOMEM ) ;\n<20> memcpy ( pan_scan -> data , & s1 -> pan_scan , sizeof ( s1 -> pan_scan ) ) ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<2> BinkAudioContext * s = avctx -> priv_data ;\n<12> if ( avpkt -> size < 4 ) {\n<17> if ( ! buf ) return AVERROR ( ENOMEM ) ;\n<18> s -> packet_buffer = buf ;\n<19> memcpy ( s -> packet_buffer , avpkt -> data , avpkt -> size ) ;\n<20> init_get_bits ( gb , s -> packet_buffer , avpkt -> size * 8 ) ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<57> out = outdata ;\n<65> if ( code & 0x80 ) {\n<66> pix = * buf ++ ;\n<67> if ( ( out + ( 257 - code ) ) > ( outdata + p -> linesize [ 0 ] ) ) break ;\n<68> memset ( out , pix , 257 - code ) ;\n<69> out += 257 - code ;\n<75> if ( buf_end - buf < code + 1 ) return AVERROR_INVALIDDATA ;\n<76> memcpy ( out , buf , code + 1 ) ;\n<77> out += code + 1 ;\n<78> buf += code + 1 ;
<1> static int raw_decode(AVCodecContext *avctx,\n<115> frame->data[1]= context->palette;\n<121> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<125> if (pal) {\n<127> memcpy(frame->data[1], pal, AVPALETTE_SIZE);
<1> int opt_default(const char *opt, const char *arg)\n<15> if (!(p = strchr(opt, ':')))\n<17> p = opt + strlen(opt);\n<19> av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));
<1> static void process_ncq_command(AHCIState *s, int port, uint8_t *cmd_fis,\n<13> uint8_t tag = ncq_fis->tag >> 3;\n<23> if (ncq_tfs->used) {\n<27> fprintf(stderr, "%s: tag %d already used\n", __FUNCTION__, tag);
<1> writev_f(int argc, char **argv)\n<25> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<63> offset = cvtnum(argv[optind]);\n<65> if (offset < 0) {\n<67> printf("non-numeric length argument -- %s\n", argv[optind]);\n<77> if (offset & 0x1ff) {\n<103> if (cnt < 0) {\n<105> printf("writev failed: %s\n", strerror(-cnt));
<1> static int inttgt_to_output ( int inttgt ) {\n<4> i < ARRAY_SIZE ( inttgt_output ) ;\n<6> if ( inttgt_output [ i ] [ 0 ] == inttgt ) {\n<10> fprintf ( stderr , "%s: unsupported inttgt %d\n" , __func__ , inttgt ) ;
<1> static void compute_svector ( QCELPContext * q , const float * gain , float * cdn_vector ) {\n<5> switch ( q -> bitrate ) {\n<46> memcpy ( q -> rnd_fir_filter_mem , q -> rnd_fir_filter_mem + 160 , 20 * sizeof ( float ) ) ;\n<71> case SILENCE : memset ( cdn_vector , 0 , 160 * sizeof ( float ) ) ;
<1> void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)\n<13> for (i = 0; i < memory / pagesize; i++) {\n<15> memset(area + pagesize * i, 0, 1);
<1> static void setdebug ( struct parse * pcmd , FILE * fp ) {\n<2> if ( pcmd -> nargs == 0 ) {\n<3> ( void ) fprintf ( fp , "debug level is %d\n" , debug ) ;\n<6> else if ( STREQ ( pcmd -> argval [ 0 ] . string , "no" ) ) {\n<7> debug = 0 ;\n<9> else if ( STREQ ( pcmd -> argval [ 0 ] . string , "more" ) ) {\n<10> debug ++ ;\n<12> else if ( STREQ ( pcmd -> argval [ 0 ] . string , "less" ) ) {\n<13> debug -- ;\n<16> ( void ) fprintf ( fp , "What?\n" ) ;\n<19> ( void ) fprintf ( fp , "debug level set to %d\n" , debug ) ;
<1> static void xan_unpack(unsigned char *dest, const unsigned char *src, int dest_len)\n<13> while (dest < dest_end) {\n<15> opcode = *src++;\n<19> if (opcode < 0xe0) {\n<23> if ( (opcode & 0x80) == 0 ) {\n<27> size = opcode & 3;\n<31> back  = ((opcode & 0x60) << 3) + *src++ + 1;\n<37> } else if ( (opcode & 0x40) == 0 ) {\n<41> size = *src >> 6;\n<45> back  = (bytestream_get_be16(&src) & 0x3fff) + 1;\n<55> size = opcode & 3;\n<59> back  = ((opcode & 0x10) << 12) + bytestream_get_be16(&src) + 1;\n<61> size2 = ((opcode & 0x0c) <<  6) + *src++ + 5;\n<63> if (size + size2 > dest_end - dest)\n<69> memcpy(dest, src, size);  dest += size;  src += size;\n<79> size = finish ? opcode & 3 : ((opcode & 0x1f) << 2) + 4;\n<83> memcpy(dest, src, size);  dest += size;  src += size;
<1> static int mxf_read_partition_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid)\n<23> if (!mxf->partitions)\n<29> if (mxf->parsing_backward) {\n<35> memmove(&mxf->partitions[mxf->last_forward_partition+1],\n<39> (mxf->partitions_count - mxf->last_forward_partition)*sizeof(*mxf->partitions));\n<41> partition = mxf->current_partition = &mxf->partitions[mxf->last_forward_partition];\n<47> partition = mxf->current_partition = &mxf->partitions[mxf->partitions_count];\n<53> memset(partition, 0, sizeof(*partition));\n<91> partition->closed = partition->type == Footer || !(uid[14] & 1);\n<135> av_dlog(mxf->fc, "PartitionPack: ThisPartition = 0x%lx, PreviousPartition = 0x%lx, "
<1> int bdrv_aio_multiwrite(BlockDriverState *bs, BlockRequest *reqs, int num_reqs)\n<27> mcb->num_callbacks = num_reqs;\n<51> acb = bdrv_aio_writev(bs, reqs[i].sector, reqs[i].qiov,\n<65> if (mcb->num_requests == 0) {\n<95> free(mcb);
<1> int main ( int argc , char * argv [ ] ) {\n<9> default_prompt = my_strdup ( getenv ( "MYSQL_PS1" ) ? getenv ( "MYSQL_PS1" ) : "\\N [\\d]> " , MYF ( MY_WME ) ) ;\n<10> current_prompt = my_strdup ( default_prompt , MYF ( MY_WME ) ) ;\n<16> char * tmp = getenv ( "PAGER" ) ;\n<17> if ( tmp && strlen ( tmp ) ) {\n<18> default_pager_set = 1 ;\n<19> strmov ( default_pager , tmp ) ;
<1> int create_server_socket ( const char * host , const char * port ) {\n<5> memset ( & hints , 0 , sizeof ( struct addrinfo ) ) ;\n<10> s = getaddrinfo ( host , port , & hints , & result ) ;
<1> static int encode_mode(CinepakEncContext *s, int h, AVPicture *scratch_pict, AVPicture *last_pict, strip_info *info, unsigned char *buf)\n<9> unsigned char temp[64]; //32/2 = 16 V4 blocks at 4 B each -> 64 B\n<153> flags = bits = temp_size = 0;\n<185> AV_WB32(&buf[ret], flags);\n<193> if(mb->best_encoding == ENC_SKIP || needs_extra_bit) {\n<195> memcpy(&buf[ret], temp, temp_size);\n<197> ret += temp_size;\n<199> temp_size = 0;\n<221> temp[temp_size++] = mb->v1_vector;\n<227> temp[temp_size++] = mb->v4_vector[z];\n<231> if(should_write_temp) {\n<233> memcpy(&buf[ret], temp, temp_size);\n<235> ret += temp_size;\n<237> temp_size = 0;\n<245> if(bits > 0) {\n<247> AV_WB32(&buf[ret], flags);\n<251> memcpy(&buf[ret], temp, temp_size);\n<253> ret += temp_size;\n<259> write_chunk_header(buf + header_ofs, 0x31, ret - header_ofs - CHUNK_HEADER_SIZE);
<1> int main ( int argc , char * * argv ) {\n<3> git_extract_argv0_path ( argv [ 0 ] ) ;\n<5> if ( argc == 2 && ! strcmp ( argv [ 1 ] , "-h" ) ) usage ( fast_import_usage ) ;\n<17> global_argv = argv ;\n<27> while ( read_next_command ( ) != EOF ) {\n<29> if ( ! strcmp ( "blob" , command_buf . buf ) ) parse_new_blob ( ) ;\n<30> else if ( skip_prefix ( command_buf . buf , "ls " , & v ) ) parse_ls ( v , NULL ) ;\n<31> else if ( skip_prefix ( command_buf . buf , "commit " , & v ) ) parse_new_commit ( v ) ;\n<32> else if ( skip_prefix ( command_buf . buf , "tag " , & v ) ) parse_new_tag ( v ) ;\n<33> else if ( skip_prefix ( command_buf . buf , "reset " , & v ) ) parse_reset_branch ( v ) ;\n<34> else if ( ! strcmp ( "checkpoint" , command_buf . buf ) ) parse_checkpoint ( ) ;\n<35> else if ( ! strcmp ( "done" , command_buf . buf ) ) break ;\n<36> else if ( starts_with ( command_buf . buf , "progress " ) ) parse_progress ( ) ;\n<37> else if ( skip_prefix ( command_buf . buf , "feature " , & v ) ) parse_feature ( v ) ;\n<38> else if ( skip_prefix ( command_buf . buf , "option git " , & v ) ) parse_option ( v ) ;\n<39> else if ( starts_with ( command_buf . buf , "option " ) ) ;\n<40> else die ( "Unsupported command: %s" , command_buf . buf ) ;\n<41> if ( checkpoint_requested ) checkpoint ( ) ;\n<51> if ( show_stats ) {\n<59> fprintf ( stderr , "%s statistics:\n" , argv [ 0 ] ) ;\n<60> fprintf ( stderr , "---------------------------------------------------------------------\n" ) ;\n<67> fprintf ( stderr , "Total branches: %10lu (%10lu loads )\n" , branch_count , branch_load_count ) ;\n<69> fprintf ( stderr , " atoms: %10u\n" , atom_cnt ) ;\n<71> fprintf ( stderr , " pools: %10lu KiB\n" , ( unsigned long ) ( total_allocd / 1024 ) ) ;\n<73> fprintf ( stderr , "---------------------------------------------------------------------\n" ) ;\n<75> fprintf ( stderr , "---------------------------------------------------------------------\n" ) ;\n<76> fprintf ( stderr , "\n" ) ;
<1> static unsigned int _warc_rdver ( const char * buf , size_t bsz ) {\n<6> if ( bsz < 12 || memcmp ( buf , magic , sizeof ( magic ) - 1U ) != 0 ) {\n<7> return ver ;\n<9> buf += sizeof ( magic ) - 1U ;\n<10> if ( isdigit ( ( unsigned char ) buf [ 0U ] ) && ( buf [ 1U ] == '.' ) && isdigit ( ( unsigned char ) buf [ 2U ] ) ) {\n<18> c = buf + 3U + end ;\n<19> if ( ver >= 1200U ) {\n<20> if ( memcmp ( c , "\r\n" , 2U ) != 0 ) ver = 0U ;\n<26> return ver ;
<1> static int isoent_gen_iso9660_identifier ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) {\n<40> np != NULL ;\n<44> l = ( int ) np -> file -> basename . length ;\n<45> p = malloc ( l + 31 + 2 + 1 ) ;\n<46> if ( p == NULL ) {\n<50> memcpy ( p , np -> file -> basename . s , l ) ;\n<51> p [ l ] = '\0' ;\n<52> np -> identifier = p ;\n<55> if ( * p == '.' ) * p ++ = '_' ;\n<59> p ++ ) {\n<61> * p = '_' ;\n<65> if ( * p == '.' ) {\n<67> dot = p ;\n<72> * p -= 'a' - 'A' ;\n<75> if ( * p == '.' ) {\n<77> dot = p ;\n<80> * p = '_' ;\n<84> if ( dot == NULL ) {\n<88> if ( l > nammax ) {\n<96> * dot = '.' ;\n<97> ext_off = ( int ) ( dot - p ) ;\n<99> if ( dot - p <= 8 ) {\n<100> if ( strlen ( dot ) > 4 ) {\n<101> dot [ 4 ] = '\0' ;\n<102> weight = 0 ;\n<116> if ( l > dnmax ) {\n<122> else if ( l > ffmax ) {\n<123> int extlen = ( int ) strlen ( dot ) ;\n<125> if ( xdot != NULL ) xdoff = ( int ) ( xdot - p ) ;\n<127> if ( extlen > 1 && xdoff < fnmax - 1 ) {\n<130> off = ffmax - extlen ;\n<131> if ( off == 0 ) {\n<132> off ++ ;\n<133> extlen -- ;\n<135> memmove ( p + off , dot , extlen ) ;\n<153> np -> ext_len = ( int ) strlen ( & p [ ext_off ] ) ;\n<154> np -> id_len = l = ext_off + np -> ext_len ;\n<165> idr_register ( idr , np , weight , noff ) ;\n<169> np != NULL ;\n<172> p = np -> identifier + np -> ext_off + np -> ext_len ;\n<173> if ( np -> ext_len == 0 && allow_period ) {\n<190> else np -> id_len = np -> ext_off + np -> ext_len ;
<1> static void ivi_huff_desc_copy ( IVIHuffDesc * dst , const IVIHuffDesc * src ) {\n<3> memcpy ( dst -> xbits , src -> xbits , src -> num_rows ) ;
<1> void print_help_box ( char * content ) {\n<2> printf ( "<img src='%s%s' onMouseOver=\"return tooltip('<table border=0 width=100%% height=100%%>" , url_images_path , CONTEXT_HELP_ICON ) ;\n<3> printf ( "<tr><td>%s</td></tr>" , content ) ;\n<9> printf ( " BORDER=0>" ) ;
<1> static int decode_info_header(NUTContext *nut)\n<89> get_str(bc, name, sizeof(name));\n<95> type = "UTF-8";\n<103> type = type_str;\n<109> type  = "s";\n<115> type  = "t";\n<121> type = "r";\n<127> type = "v";\n<133> if (stream_id_plus1 > s->nb_streams) {\n<143> if (!strcmp(type, "UTF-8")) {\n<145> if (chapter_id == 0 && !strcmp(name, "Disposition")) {\n<147> set_disposition_bits(s, str_value, stream_id_plus1 - 1);\n<153> if (metadata && av_strcasecmp(name, "Uses") &&\n<155> av_strcasecmp(name, "Depends") && av_strcasecmp(name, "Replaces")) {\n<159> av_dict_set(metadata, name, str_value, 0);
<1> ssize_t qsb_get_buffer(const QEMUSizedBuffer *qsb, off_t start,\n<3> size_t count, uint8_t *buffer)\n<53> while (all_copy > 0) {\n<59> s = iov->iov_base;\n<65> if (to_copy > all_copy) {\n<67> to_copy = all_copy;\n<71> memcpy(&buffer[d_off], &s[s_off], to_copy);\n<75> d_off += to_copy;\n<77> all_copy -= to_copy;
<1> void Curl_formclean ( struct FormData * * form_ptr ) {\n<4> if ( ! form ) return ;\n<7> if ( form -> type <= FORM_CONTENT ) free ( form -> line ) ;\n<8> free ( form ) ;\n<10> while ( ( form = next ) != NULL ) ;
<1> static void read_image_data ( Gif_Context * gfc , Gif_Reader * grr ) {\n<79> long delta = ( long ) ( gfc -> maximage - gfc -> image ) - ( long ) gfc -> decodepos ;\n<80> char buf [ BUFSIZ ] ;\n<81> if ( delta > 0 ) {\n<82> sprintf ( buf , "missing %ld %s of image data" , delta , delta == 1 ? "pixel" : "pixels" ) ;\n<83> gif_read_error ( gfc , 1 , buf ) ;\n<84> memset ( & gfc -> image [ gfc -> decodepos ] , 0 , delta ) ;\n<86> else if ( delta < - 1 ) {\n<87> sprintf ( buf , "%ld superfluous pixels of image data" , - delta ) ;\n<88> gif_read_error ( gfc , 0 , buf ) ;
<1> rfbBool rfbSendSupportedMessages ( rfbClientPtr cl ) {\n<4> if ( cl -> ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbSupportedMessages > UPDATE_BUF_SIZE ) {\n<5> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n<7> rect . encoding = Swap32IfLE ( rfbEncodingSupportedMessages ) ;\n<10> rect . r . w = Swap16IfLE ( sz_rfbSupportedMessages ) ;\n<12> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ;\n<13> cl -> ublen += sz_rfbFramebufferUpdateRectHeader ;\n<14> memset ( ( char * ) & msgs , 0 , sz_rfbSupportedMessages ) ;\n<24> rfbSetBit ( msgs . client2server , rfbPalmVNCSetScaleFactor ) ;\n<30> rfbSetBit ( msgs . server2client , rfbPalmVNCReSizeFrameBuffer ) ;\n<32> rfbSetBit ( msgs . client2server , rfbXvp ) ;\n<33> rfbSetBit ( msgs . server2client , rfbXvp ) ;\n<35> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & msgs , sz_rfbSupportedMessages ) ;\n<36> cl -> ublen += sz_rfbSupportedMessages ;\n<37> rfbStatRecordEncodingSent ( cl , rfbEncodingSupportedMessages , sz_rfbFramebufferUpdateRectHeader + sz_rfbSupportedMessages , sz_rfbFramebufferUpdateRectHeader + sz_rfbSupportedMessages ) ;
<1> static void print_var_int ( const char * var , int val ) {\n<2> printf ( "%s=%d\n" , var , val ) ;
<1> static void sig_complete_window ( GList * * list , WINDOW_REC * window , const char * word , const char * linestart , int * want_space ) {\n<7> g_return_if_fail ( word != NULL ) ;\n<8> len = strlen ( word ) ;\n<14> if ( win -> name != NULL && g_ascii_strncasecmp ( win -> name , word , len ) == 0 ) * list = g_list_append ( * list , g_strdup ( win -> name ) ) ;\n<15> if ( item != NULL && g_ascii_strncasecmp ( item -> visible_name , word , len ) == 0 ) * list = g_list_append ( * list , g_strdup ( item -> visible_name ) ) ;
<1> static void _selectOutputSchema ( ArchiveHandle * AH , const char * schemaName ) {\n<3> if ( ! schemaName || * schemaName == '\0' || ( AH -> currSchema && strcmp ( AH -> currSchema , schemaName ) == 0 ) ) return ;\n<5> appendPQExpBuffer ( qry , "SET search_path = %s" , fmtId ( schemaName ) ) ;\n<6> if ( strcmp ( schemaName , "pg_catalog" ) != 0 ) appendPQExpBufferStr ( qry , ", pg_catalog" ) ;\n<16> AH -> currSchema = pg_strdup ( schemaName ) ;
<1> static int decode_rle(uint8_t *bitmap, int linesize, int w, int h,\n<13> d = bitmap;\n<17> len = decode_run_8bit(&gb, &color);\n<19> len = decode_run_2bit(&gb, &color);\n<20> len = FFMIN(len, w - x);\n<21> memset(d + x, color, len);\n<22> x += len;\n<23> if (x >= w) {\n<25> if (y >= h)\n<27> d += linesize;
<1> static void WarnPatented ( gs_font_type42 * pfont , ttfFont * ttf , const char * txt ) {\n<7> if ( ! base_font -> data . warning_patented ) {\n<8> l = min ( sizeof ( buf ) - 1 , base_font -> font_name . size ) ;\n<9> memcpy ( buf , base_font -> font_name . chars , l ) ;\n<11> emprintf2 ( pfont -> memory , "%s %s requires a patented True Type interpreter.\n" , txt , buf ) ;
<1> static int gif_video_probe(AVProbeData * pd)\n<13> if (pd->buf_size < 24 ||\n<15> memcmp(pd->buf, gif89a_sig, 6) != 0)\n<19> p_end = pd->buf + pd->buf_size;\n<21> p = pd->buf + 6;
<1> static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags)\n<65> clientname = qemu_rbd_parse_clientname(conf, clientname_buf);\n<69> if (r < 0) {\n<115> if (strstr(conf, "conf=") == NULL) {\n<119> rados_conf_read_file(s->cluster, NULL);\n<125> if (conf[0] != '\0') {\n<127> r = qemu_rbd_set_conf(s->cluster, conf);\n<177> bs->read_only = (s->snap != NULL);
<1> static void dumpcffcharset ( SplineFont * sf , struct alltabs * at ) {\n<3> at -> gn_sid = calloc ( at -> gi . gcnt , sizeof ( uint32 ) ) ;\n<8> at -> gn_sid [ i ] = storesid ( at , sf -> glyphs [ at -> gi . bygid [ i ] ] -> name ) ;
<1> static void test_blk_read(BlockBackend *blk, long pattern,\n<3> int64_t pattern_offset, int64_t pattern_count,\n<15> void *cmp_buf = NULL;\n<21> if (pattern) {\n<23> cmp_buf = g_malloc(pattern_count);\n<25> memset(cmp_buf, pattern, pattern_count);\n<31> pattern_buf = g_malloc(count);\n<33> if (pattern) {\n<35> memset(pattern_buf, pattern, count);\n<39> memset(pattern_buf, 0x00, count);\n<47> qemu_iovec_add(&qiov, pattern_buf, count);\n<69> if (pattern) {
<1> gcry_error_t gcry_pk_encrypt ( gcry_sexp_t * r_ciph , gcry_sexp_t s_data , gcry_sexp_t s_pkey ) {\n<15> if ( ! algo_name || ! * algo_name ) algo_name = pubkey -> name ;\n<16> algo_elems = pubkey -> elements_enc ;\n<19> if ( rc ) goto leave ;\n<20> ciph = gcry_calloc ( strlen ( algo_elems ) + 1 , sizeof ( * ciph ) ) ;\n<21> if ( ! ciph ) {\n<29> if ( ctx . encoding == PUBKEY_ENC_OAEP || ctx . encoding == PUBKEY_ENC_PKCS1 ) {\n<41> size_t nelem = strlen ( algo_elems ) ;\n<42> size_t needed = 19 + strlen ( algo_name ) + ( nelem * 5 ) ;\n<44> string = p = gcry_malloc ( needed ) ;\n<45> if ( ! string ) {\n<50> p = stpcpy ( p , algo_name ) ;\n<55> * p ++ = algo_elems [ i ] ;\n<59> arg_list = malloc ( nelem * sizeof * arg_list ) ;\n<60> if ( ! arg_list ) {\n<66> i ++ ) arg_list [ i ] = ciph + i ;\n<67> rc = gcry_sexp_build_array ( r_ciph , NULL , string , arg_list ) ;\n<68> free ( arg_list ) ;
<1> static int kex_agree_mac ( LIBSSH2_SESSION * session , libssh2_endpoint_data * endpoint , unsigned char * mac , unsigned long mac_len ) {\n<7> while ( s && * s ) {\n<8> unsigned char * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n<9> size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n<22> while ( * macp && ( * macp ) -> name ) {\n<23> s = kex_agree_instr ( mac , mac_len , ( unsigned char * ) ( * macp ) -> name , strlen ( ( * macp ) -> name ) ) ;\n<25> endpoint -> mac = * macp ;
<1> static int libshine_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<7> SHINEContext *s = avctx->priv_data;\n<21> data = shine_encode_buffer(s->shine, (int16_t **)frame->data, &written);\n<25> data = shine_flush(s->shine, &written);\n<31> if (written > 0) {\n<33> if (s->buffer_index + written > BUFFER_SIZE) {\n<41> memcpy(s->buffer + s->buffer_index, data, written);\n<43> s->buffer_index += written;\n<61> if (avpriv_mpegaudio_decode_header(&hdr, AV_RB32(s->buffer))) {\n<75> if ((ret = ff_alloc_packet2(avctx, avpkt, len)))\n<79> memcpy(avpkt->data, s->buffer, len);\n<81> s->buffer_index -= len;\n<83> memmove(s->buffer, s->buffer + len, s->buffer_index);\n<93> avpkt->size = len;
<1> static inline void json_print_item_str(WriterContext *wctx,\n<5> const char *indent)\n<9> char *key_esc = json_escape_str(key);\n<11> char *value_esc = json_escape_str(value);
<1> int cli_scanmscab ( cli_ctx * ctx , off_t sfx_offset ) {\n<12> memset ( & ops_ex , 0 , sizeof ( struct mspack_system_ex ) ) ;\n<60> ret = cli_scanfile ( tmp_fname , ctx ) ;\n<62> if ( ! ctx -> engine -> keeptmp ) {\n<63> if ( ! access ( tmp_fname , R_OK ) && cli_unlink ( tmp_fname ) ) {\n<64> free ( tmp_fname ) ;\n<69> free ( tmp_fname ) ;
<1> static int decode_13(AVCodecContext *avctx, DxaDecContext *c, uint8_t* dst,\n<19> data = code + ((avctx->width * avctx->height) >> 4);\n<31> tmp  = dst + i;\n<33> tmp2 = ref + i;\n<55> tmp2 += x + y*stride;\n<61> for(y = 0; y < 4; y++){\n<63> memcpy(tmp, tmp2, 4);\n<65> tmp  += stride;\n<67> tmp2 += stride;\n<107> tmp[x] = (mask & 0x8000) ? *data++ : tmp2[x];\n<115> tmp2 += stride;\n<123> for(y = 0; y < 4; y++){\n<125> memset(tmp, data[0], 4);\n<127> tmp += stride;\n<131> data++;\n<137> for(y = 0; y < 4; y++){\n<139> memcpy(tmp, data, 4);\n<141> data += 4;\n<143> tmp  += stride;\n<159> tmp2 = ref + i + d2;\n<179> tmp2 += x + y*stride;\n<183> tmp[d + 0         ] = tmp2[0];\n<185> tmp[d + 1         ] = tmp2[1];\n<187> tmp[d + 0 + stride] = tmp2[0 + stride];\n<189> tmp[d + 1 + stride] = tmp2[1 + stride];\n<195> tmp[d + 0         ] = data[0];\n<197> tmp[d + 1         ] = data[0];\n<199> tmp[d + 0 + stride] = data[0];\n<201> tmp[d + 1 + stride] = data[0];\n<203> data++;\n<209> tmp[d + 0         ] = *data++;\n<211> tmp[d + 1         ] = *data++;\n<213> tmp[d + 0 + stride] = *data++;\n<215> tmp[d + 1 + stride] = *data++;\n<237> tmp[x] = data[mask & 1];\n<249> data += 2;\n<265> tmp[x] = data[mask & 3];\n<277> data += type - 30;
<1> static int parse_overview_line ( char * line , void * data ) {\n<9> if ( ! line ) return 0 ;\n<10> field = strchr ( line , '\t' ) ;\n<11> if ( field ) * field ++ = '\0' ;\n<12> if ( sscanf ( line , ANUM , & anum ) != 1 ) return 0 ;\n<14> if ( anum < fc -> first || anum > fc -> last ) return 0 ;\n<15> if ( ! fc -> messages [ anum - fc -> first ] ) {\n<16> if ( ! ctx -> quiet ) mutt_progress_update ( & fc -> progress , anum - fc -> first + 1 , - 1 ) ;\n<21> header = nntp_data -> nserv -> overview_fmt ;\n<23> char * b = field ;\n<24> if ( * header ) {\n<25> if ( strstr ( header , ":full" ) == NULL && fputs ( header , fp ) == EOF ) {\n<26> mutt_file_fclose ( & fp ) ;\n<27> return - 1 ;\n<29> header = strchr ( header , '\0' ) + 1 ;\n<31> field = strchr ( field , '\t' ) ;\n<32> if ( field ) * field ++ = '\0' ;\n<33> if ( fputs ( b , fp ) == EOF || fputc ( '\n' , fp ) == EOF ) {\n<76> NHDR ( hdr ) -> article_num = anum ;\n<79> nntp_article_status ( ctx , hdr , NULL , anum ) ;\n<82> if ( anum > nntp_data -> last_loaded ) nntp_data -> last_loaded = anum ;
<1> static MPI gen_k ( MPI p , int small_k ) {\n<20> if ( ! rndbuf || nbits < 32 ) {\n<25> char * pp = get_random_bits ( 32 , 1 , 1 ) ;\n<26> memcpy ( rndbuf , pp , 4 ) ;\n<27> xfree ( pp ) ;\n<29> mpi_set_buffer ( k , rndbuf , nbytes , 0 ) ;
<1> static size_t qio_channel_websock_extract_headers ( QIOChannelWebsock * ioc , char * buffer , QIOChannelWebsockHTTPHeader * hdrs , size_t nhdrsalloc , Error * * errp ) {\n<4> nl = strstr ( buffer , QIO_CHANNEL_WEBSOCK_HANDSHAKE_DELIM ) ;\n<5> if ( ! nl ) {\n<9> * nl = '\0' ;\n<10> tmp = strchr ( buffer , ' ' ) ;\n<11> if ( ! tmp ) {\n<16> if ( ! g_str_equal ( buffer , QIO_CHANNEL_WEBSOCK_HTTP_METHOD ) ) {\n<20> buffer = tmp + 1 ;\n<21> tmp = strchr ( buffer , ' ' ) ;\n<22> if ( ! tmp ) {\n<27> if ( ! g_str_equal ( buffer , QIO_CHANNEL_WEBSOCK_HTTP_PATH ) ) {\n<33> if ( ! g_str_equal ( buffer , QIO_CHANNEL_WEBSOCK_HTTP_VERSION ) ) {\n<37> buffer = nl + strlen ( QIO_CHANNEL_WEBSOCK_HANDSHAKE_DELIM ) ;\n<40> nl = strstr ( buffer , QIO_CHANNEL_WEBSOCK_HANDSHAKE_DELIM ) ;\n<42> * nl = '\0' ;\n<44> sep = strchr ( buffer , ':' ) ;\n<45> if ( ! sep ) {\n<59> hdr -> name = buffer ;\n<66> if ( nl ) {\n<67> buffer = nl + strlen ( QIO_CHANNEL_WEBSOCK_HANDSHAKE_DELIM ) ;\n<70> while ( nl != NULL ) ;
<1> static void test_bug1664 ( ) {\n<5> const char * str_data = "Simple string" ;\n<7> const char * query = "INSERT INTO test_long_data(col2, col1) VALUES(?, ?)" ;\n<14> check_stmt ( stmt ) ;\n<15> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<16> check_execute ( stmt , rc ) ;\n<18> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<21> my_bind [ 0 ] . buffer_length = strlen ( str_data ) ;\n<24> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<27> data = "" ;\n<28> rc = mysql_stmt_send_long_data ( stmt , 0 , data , strlen ( data ) ) ;\n<36> data = ( char * ) "Data" ;\n<37> rc = mysql_stmt_send_long_data ( stmt , 0 , data , strlen ( data ) ) ;\n<49> verify_col_data ( "test_long_data" , "col2" , str_data ) ;\n<52> data = ( char * ) "SomeOtherData" ;\n<53> rc = mysql_stmt_send_long_data ( stmt , 0 , data , strlen ( data ) ) ;\n<63> check_stmt ( stmt ) ;\n<64> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<65> check_execute ( stmt , rc ) ;\n<68> data = ( char * ) "SomeData" ;\n<69> rc = mysql_stmt_send_long_data ( stmt , 0 , data , strlen ( data ) ) ;
<1> int evhttp_hostportfile ( char * url , char * * phost , u_short * pport , char * * pfile ) {\n<8> len = strlen ( HTTP_PREFIX ) ;\n<9> if ( strncasecmp ( url , HTTP_PREFIX , len ) ) return ( - 1 ) ;\n<11> if ( strlcpy ( host , url , sizeof ( host ) ) >= sizeof ( host ) ) return ( - 1 ) ;\n<12> p = strchr ( host , '/' ) ;\n<13> if ( p != NULL ) {\n<22> p = strchr ( host , ':' ) ;\n<23> if ( p != NULL ) {\n<29> if ( phost != NULL ) * phost = host ;
<1> matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n<97> flags = *data++;\n<147> data += 1;\n<179> data += 1;\n<215> n = matroska_ebmlnum_uint(data, size, &num);\n<227> data += n;\n<239> r = matroska_ebmlnum_sint (data, size, &snum);\n<251> data += r;\n<297> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n<319> for (x=0; x<h/2; x++)\n<321> memcpy(audiotrack->buf+x*2*w+y*cfs,\n<323> data+x*cfs, cfs);\n<327> for (x=0; x<w/sps; x++)\n<329> memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n<343> while (audiotrack->pkt_cnt) {\n<347> av_new_packet(pkt, a);\n<351> + a * (h*w / a - audiotrack->pkt_cnt--), a);\n<357> matroska_queue_packet(matroska, pkt);\n<363> int result, offset = 0, ilen, olen, pkt_size = lace_size[n];\n<365> uint8_t *pkt_data = data;\n<375> offset = matroska->tracks[track]->encoding_settings_len;\n<393> result = lzo1x_decode(pkt_data, &olen, data, &ilen);\n<405> pkt_size -= olen;\n<515> if (av_new_packet(pkt, pkt_size+offset) < 0) {\n<526> if (offset)\n<528> memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);\n<530> memcpy (pkt->data+offset, pkt_data, pkt_size);\n<550> matroska_queue_packet(matroska, pkt);\n<560> data += lace_size[n];
<1> static void ttc_dump ( FILE * ttc , struct alltabs * all , enum fontformat format , int flags , enum ttc_flags ttc_flags ) {\n<80> free ( all [ cnt ] . sf -> glyphs ) ;\n<113> rewind ( all [ cnt ] . maxpf ) ;\n<114> while ( ( ch = getc ( all [ cnt ] . maxpf ) ) != EOF ) putc ( ch , ttc ) ;
<1> static QDict *qmp_check_input_obj(QObject *input_obj)\n<27> for (ent = qdict_first(input_dict); ent; ent = qdict_next(input_dict, ent)){\n<29> const char *arg_name = qdict_entry_key(ent);\n<35> if (!strcmp(arg_name, "execute")) {\n<37> if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n<49> } else if (!strcmp(arg_name, "arguments")) {\n<51> if (qobject_type(arg_obj) != QTYPE_QDICT) {\n<61> } else if (!strcmp(arg_name, "id")) {\n<67> qerror_report(QERR_QMP_EXTRA_MEMBER, arg_name);\n<69> return NULL;
<1> int qemuMonitorTextGetBalloonInfo ( qemuMonitorPtr mon , unsigned long * currmem ) {\n<2> char * reply = NULL ;\n<5> if ( qemuMonitorHMPCommand ( mon , "info balloon" , & reply ) < 0 ) {\n<9> if ( ( offset = strstr ( reply , BALLOON_PREFIX ) ) != NULL ) {\n<10> offset += strlen ( BALLOON_PREFIX ) ;\n<11> struct _virDomainMemoryStat stats [ 1 ] ;\n<12> if ( qemuMonitorParseBalloonInfo ( offset , stats , 1 ) == 0 ) {\n<13> qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( "unexpected balloon information '%s'" ) , reply ) ;\n<17> qemuReportError ( VIR_ERR_INTERNAL_ERROR , _ ( "unexpected balloon information '%s'" ) , reply ) ;\n<24> ret = 0 ;\n<26> cleanup : VIR_FREE ( reply ) ;
<1> static void parse_new_tag ( const char * arg ) {\n<11> t = pool_alloc ( sizeof ( struct tag ) ) ;\n<12> memset ( t , 0 , sizeof ( struct tag ) ) ;\n<14> if ( last_tag ) last_tag -> next_tag = t ;\n<15> else first_tag = t ;\n<16> last_tag = t ;\n<43> tagger = parse_ident ( v ) ;\n<46> else tagger = NULL ;\n<49> strbuf_addf ( & new_data , "object %s\n" "type %s\n" "tag %s\n" , sha1_to_hex ( sha1 ) , typename ( type ) , t -> name ) ;\n<50> if ( tagger ) strbuf_addf ( & new_data , "tagger %s\n" , tagger ) ;\n<53> free ( tagger ) ;\n<54> if ( store_object ( OBJ_TAG , & new_data , NULL , t -> sha1 , 0 ) ) t -> pack_id = MAX_PACK_ID ;
<1> static size_t add_data_segment ( u_char * * data , size_t base , u_char * * string , size_t slen ) {\n<2> SAFE_REALLOC ( * data , base + slen + 1 ) ;\n<3> memcpy ( * data + base , * string , slen + 1 ) ;
<1> static int get_sha1_hex_from_objpath ( const char * path , unsigned char * sha1 ) {\n<2> char hex [ 40 ] ;\n<3> if ( strlen ( path ) != 41 ) return - 1 ;\n<4> memcpy ( hex , path , 2 ) ;\n<5> path += 2 ;\n<6> path ++ ;\n<7> memcpy ( hex , path , 38 ) ;\n<8> return get_sha1_hex ( hex , sha1 ) ;
<1> USBDevice *usb_net_init(NICInfo *nd)\n<9> s = qemu_mallocz(sizeof(USBNetState));\n<43> memcpy(s->mac, nd->macaddr, 6);\n<53> s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<59> qemu_format_nic_info_str(s->vc, s->mac);\n<63> snprintf(s->usbstring_mac, sizeof(s->usbstring_mac),\n<71> fprintf(stderr, "usbnet: initialized mac %02x:%02x:%02x:%02x:%02x:%02x\n",
<1> static int mov_open_dref(ByteIOContext **pb, char *src, MOVDref *ref)\n<7> if (!url_fopen(pb, ref->path, URL_RDONLY))\n<15> if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n<17> char filename[1024];\n<41> for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n<59> if (i == ref->nlvl_to - 1) {\n<61> memcpy(filename, src, src_path - src);\n<63> filename[src_path - src] = 0;\n<69> av_strlcat(filename, "../", 1024);\n<73> av_strlcat(filename, ref->path + l + 1, 1024);
<1> SplinePointList * SplinesFromEntities ( Entity * ent , int * flags , int is_stroked ) {\n<3> memset ( & ec , '\0' , sizeof ( ec ) ) ;\n<5> return ( SplinesFromEntityChar ( & ec , flags , is_stroked ) ) ;
<1> gs_malloc_memory_t * gs_malloc_memory_init ( void ) {\n<2> gs_malloc_memory_t * mem = ( gs_malloc_memory_t * ) Memento_label ( malloc ( sizeof ( gs_malloc_memory_t ) ) , "gs_malloc_memory_t" ) ;
<1> uint end_of_word ( char * pos ) {\n<3> return ( ( end > pos + 2 && ! memcmp ( end - 2 , "\\b" , 2 ) ) || ( end >= pos + 2 && ! memcmp ( end - 2 , "\\$" , 2 ) ) ) ? 1 : 0 ;
<1> static void CloseDecoder ( vlc_object_t * p_this ) {\n<3> decoder_sys_t * p_sys = p_dec -> p_sys ;\n<4> schro_decoder_free ( p_sys -> p_schro ) ;\n<5> free ( p_sys ) ;
<1> GuestNetworkInterfaceList *qmp_guest_network_get_interfaces(Error **errp)\n<83> if (sock == -1) {\n<93> memset(&ifr, 0, sizeof(ifr));\n<95> pstrcpy(ifr.ifr_name, IF_NAMESIZE, info->value->name);\n<97> if (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1) {
<1> static void shix_init(MachineState *machine)\n<29> if (cpu == NULL) {\n<31> fprintf(stderr, "Unable to find CPU definition\n");
<1> static void end_packfile ( void ) {\n<3> if ( running || ! pack_data ) return ;\n<6> if ( object_count ) {\n<13> close_pack_windows ( pack_data ) ;\n<15> fixup_pack_header_footer ( pack_data -> pack_fd , pack_data -> sha1 , pack_data -> pack_name , object_count , cur_pack_sha1 , pack_size ) ;\n<16> close ( pack_data -> pack_fd ) ;\n<17> idx_name = keep_pack ( create_index ( ) ) ;\n<18> new_p = add_packed_git ( idx_name , strlen ( idx_name ) , 1 ) ;\n<19> if ( ! new_p ) die ( "core git rejected index %s" , idx_name ) ;\n<21> install_packed_git ( new_p ) ;\n<22> if ( pack_edges ) {\n<23> fprintf ( pack_edges , "%s:" , new_p -> pack_name ) ;\n<30> if ( b -> pack_id == pack_id ) fprintf ( pack_edges , " %s" , sha1_to_hex ( b -> sha1 ) ) ;\n<36> if ( t -> pack_id == pack_id ) fprintf ( pack_edges , " %s" , sha1_to_hex ( t -> sha1 ) ) ;\n<38> fputc ( '\n' , pack_edges ) ;\n<44> close ( pack_data -> pack_fd ) ;\n<45> unlink_or_warn ( pack_data -> pack_name ) ;\n<47> free ( pack_data ) ;
<1> static int convert_sub_to_old_ass_form(AVSubtitle *sub, const AVPacket *pkt, AVRational tb)\n<21> AVSubtitleRect *rect = sub->rects[i];\n<29> if (rect->type != SUBTITLE_ASS || !strncmp(rect->ass, "Dialogue ", 10))\n<41> dialog = strchr(rect->ass, ',');\n<43> if (!dialog)\n<99> av_freep(&rect->ass);\n<101> rect->ass = final_dialog;
<1> static void cluster_all_databases ( bool verbose , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet ) {\n<6> conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n<14> char * dbname = PQgetvalue ( result , i , 0 ) ;\n<15> if ( ! quiet ) {\n<16> printf ( _ ( "%s: clustering database \"%s\"\n" ) , progname , dbname ) ;\n<21> appendConnStrVal ( & connstr , dbname ) ;\n<22> cluster_one_database ( connstr . data , verbose , NULL , host , port , username , prompt_password , progname , echo ) ;
<13> if ( ! other -> get_encoding ( other , CERT_ASN1_DER , & encoding ) ) {\n<16> equal = chunk_equals ( this -> encoding , encoding ) ;\n<17> free ( encoding . ptr ) ;
<1> static void update_sub_state ( AMRWBContext * ctx ) {\n<2> memmove ( & ctx -> excitation_buf [ 0 ] , & ctx -> excitation_buf [ AMRWB_SFR_SIZE ] , ( AMRWB_P_DELAY_MAX + LP_ORDER + 1 ) * sizeof ( float ) ) ;\n<3> memmove ( & ctx -> pitch_gain [ 1 ] , & ctx -> pitch_gain [ 0 ] , 5 * sizeof ( float ) ) ;\n<4> memmove ( & ctx -> fixed_gain [ 1 ] , & ctx -> fixed_gain [ 0 ] , 1 * sizeof ( float ) ) ;\n<5> memmove ( & ctx -> samples_az [ 0 ] , & ctx -> samples_az [ AMRWB_SFR_SIZE ] , LP_ORDER * sizeof ( float ) ) ;\n<6> memmove ( & ctx -> samples_up [ 0 ] , & ctx -> samples_up [ AMRWB_SFR_SIZE ] , UPS_MEM_SIZE * sizeof ( float ) ) ;\n<7> memmove ( & ctx -> samples_hb [ 0 ] , & ctx -> samples_hb [ AMRWB_SFR_SIZE_16k ] , LP_ORDER_16k * sizeof ( float ) ) ;
<1> int scsi_req_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf)\n<11> cmd->len = scsi_cdb_length(buf);\n<19> rc = scsi_req_stream_xfer(cmd, dev, buf);\n<25> rc = scsi_req_medium_changer_xfer(cmd, dev, buf);\n<31> rc = scsi_req_xfer(cmd, dev, buf);\n<39> if (rc != 0)\n<45> memcpy(cmd->buf, buf, cmd->len);\n<47> scsi_cmd_xfer_mode(cmd);\n<49> cmd->lba = scsi_cmd_lba(cmd);
<1> static int read_password(char *buf, int buf_size)\n<7> printf("Password: ");\n<15> c = getchar();\n<17> if (c == '\n')
<1> static void realview_init(ram_addr_t ram_size,\n<83> if (!env) {\n<85> fprintf(stderr, "Unable to find CPU definition\n");\n<335> nd = &nd_table[n];\n<339> if ((!nd->model && !done_nic)\n<341> || strcmp(nd->model, is_pb ? "lan9118" : "smc91c111") == 0) {\n<345> lan9118_init(nd, 0x4e000000, pic[28]);\n<349> smc91c111_init(nd, 0x4e000000, pic[28]);\n<357> pci_nic_init_nofail(nd, "rtl8139", NULL);
<1> static void version ( void ) {\n<2> fprintf ( stdout , "bsdcpio %s -- %s\n" , BSDCPIO_VERSION_STRING , archive_version_details ( ) ) ;
<1> static inline CopyRet copy_frame(AVCodecContext *avctx,\n<45> uint8_t *src = output->Ybuff;\n<167> bwidth = av_image_get_linesize(avctx->pix_fmt, width, 0);\n<199> dst     = priv->pic.data[0];\n<233> for (sY = 0; sY < height; dY++, sY++) {\n<235> memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);
<1> static int unpack_vectors(Vp3DecodeContext *s, GetBitContext *gb)\n<9> int motion_x[6];\n<11> int motion_y[6];\n<29> if (s->keyframe) {\n<41> memset(motion_x, 0, 6 * sizeof(int));\n<43> memset(motion_y, 0, 6 * sizeof(int));\n<99> switch (s->macroblock_coding[current_macroblock]) {\n<111> motion_x[0] = motion_vector_table[get_vlc2(gb, s->motion_vector_vlc.table, 6, 2)];\n<113> motion_y[0] = motion_vector_table[get_vlc2(gb, s->motion_vector_vlc.table, 6, 2)];\n<117> motion_x[0] = fixed_motion_vector_table[get_bits(gb, 6)];\n<119> motion_y[0] = fixed_motion_vector_table[get_bits(gb, 6)];\n<127> motion_x[k] = motion_x[0];\n<129> motion_y[k] = motion_y[0];\n<145> last_motion_x = motion_x[0];\n<147> last_motion_y = motion_y[0];\n<175> motion_x[k] = motion_vector_table[get_vlc2(gb, s->motion_vector_vlc.table, 6, 2)];\n<177> motion_y[k] = motion_vector_table[get_vlc2(gb, s->motion_vector_vlc.table, 6, 2)];\n<181> motion_x[k] = fixed_motion_vector_table[get_bits(gb, 6)];\n<183> motion_y[k] = fixed_motion_vector_table[get_bits(gb, 6)];\n<187> last_motion_x = motion_x[k];\n<189> last_motion_y = motion_y[k];\n<191> motion_x[4] += motion_x[k];\n<193> motion_y[4] += motion_y[k];\n<201> motion_x[4]= RSHIFT(motion_x[4], 2);\n<205> motion_y[4]= RSHIFT(motion_y[4], 2);\n<215> motion_x[0] = last_motion_x;\n<217> motion_y[0] = last_motion_y;\n<221> motion_x[k] = motion_x[0];\n<223> motion_y[k] = motion_y[0];\n<243> motion_x[0] = prior_last_motion_x;\n<245> motion_y[0] = prior_last_motion_y;\n<249> motion_x[k] = motion_x[0];\n<251> motion_y[k] = motion_y[0];\n<263> last_motion_x = motion_x[0];\n<265> last_motion_y = motion_y[0];\n<275> memset(motion_x, 0, 6 * sizeof(int));\n<277> memset(motion_y, 0, 6 * sizeof(int));\n<317> s->all_fragments[current_fragment].motion_x = motion_x[k];\n<319> s->all_fragments[current_fragment].motion_y = motion_y[k];\n<321> debug_vectors("    vector %d: fragment %d = (%d, %d)\n",
<1> static void spapr_machine_init(MachineState *machine)\n<194> for (i = 0; i < nb_nics; i++) {\n<195> NICInfo *nd = &nd_table[i];\n<196> if (!nd->model) {\n<197> nd->model = g_strdup("ibmveth");\n<199> if (strcmp(nd->model, "ibmveth") == 0) {\n<200> spapr_vlan_create(spapr->vio_bus, nd);\n<202> pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);
<1> static void test_bind_result_ext ( ) {\n<10> char szData [ 20 ] , bData [ 20 ] ;\n<25> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<27> i < ( int ) array_elements ( my_bind ) ;\n<60> if ( ! opt_silent ) {\n<61> fprintf ( stdout , "\n data (tiny) : %d" , t_data ) ;\n<62> fprintf ( stdout , "\n data (short) : %d" , s_data ) ;\n<63> fprintf ( stdout , "\n data (int) : %d" , i_data ) ;\n<64> fprintf ( stdout , "\n data (big) : %s" , llstr ( b_data , llbuf ) ) ;\n<65> fprintf ( stdout , "\n data (float) : %f" , f_data ) ;\n<66> fprintf ( stdout , "\n data (double) : %f" , d_data ) ;\n<67> fprintf ( stdout , "\n data (str) : %s(%lu)" , szData , szLength ) ;\n<68> bData [ bLength ] = '\0' ;\n<69> fprintf ( stdout , "\n data (bin) : %s(%lu)" , bData , bLength ) ;\n<71> DIE_UNLESS ( t_data == 19 ) ;\n<72> DIE_UNLESS ( s_data == 2999 ) ;\n<73> DIE_UNLESS ( i_data == 3999 ) ;\n<75> DIE_UNLESS ( strcmp ( szData , "venu" ) == 0 ) ;\n<76> DIE_UNLESS ( strncmp ( bData , "mysql" , 5 ) == 0 ) ;\n<77> DIE_UNLESS ( szLength == 4 ) ;\n<78> DIE_UNLESS ( bLength == 5 ) ;
<1> static void truespeech_place_pulses ( TSContext * dec , int16_t * out , int quart ) {\n<7> memset ( out , 0 , 60 * sizeof ( * out ) ) ;
<1> static int decode_block ( BinkAudioContext * s , float * * out , int use_dct ) {\n<10> FFTSample * coeffs = out [ ch ] ;\n<13> coeffs [ 0 ] = av_int2float ( get_bits_long ( gb , 32 ) ) * s -> root ;\n<14> coeffs [ 1 ] = av_int2float ( get_bits_long ( gb , 32 ) ) * s -> root ;\n<18> coeffs [ 0 ] = get_float ( gb ) * s -> root ;\n<19> coeffs [ 1 ] = get_float ( gb ) * s -> root ;\n<31> while ( i < s -> frame_len ) {\n<47> if ( width == 0 ) {\n<48> memset ( coeffs + i , 0 , ( j - i ) * sizeof ( * coeffs ) ) ;\n<59> if ( v ) coeffs [ i ] = - q * coeff ;\n<60> else coeffs [ i ] = q * coeff ;\n<63> coeffs [ i ] = 0.0f ;\n<76> ch < s -> channels ;\n<84> i ++ , j += s -> channels ) out [ ch ] [ i ] = ( s -> previous [ ch ] [ i ] * ( count - j ) + out [ ch ] [ i ] * j ) / count ;\n<86> memcpy ( s -> previous [ ch ] , & out [ ch ] [ s -> frame_len - s -> overlap_len ] , s -> overlap_len * sizeof ( * s -> previous [ ch ] ) ) ;
<1> static int ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile,\n<13> int32_t     prev_dc, trvec[64];\n<153> if (!band->scan) {\n<165> memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */\n<167> memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */\n<233> trvec[pos] = val;\n<235> col_flags[pos & col_mask] |= !!val; /* track columns containing non-zero coeffs */\n<251> prev_dc      += trvec[0];\n<255> col_flags[0] |= !!prev_dc;\n<269> band->inv_transform(trvec, band->buf + buf_offs,
<1> static void r2d_init(ram_addr_t ram_size,\n<35> if (!env) {\n<37> fprintf(stderr, "Unable to find CPU definition\n");\n<111> kernel_size = load_image_targphys(kernel_filename, SDRAM_BASE, SDRAM_SIZE);\n<119> if (kernel_size < 0) {\n<121> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> static int ipvideo_decode_frame(AVCodecContext *avctx,\n<13> IpvideoContext *s = avctx->priv_data;\n<73> if (pal && size == AVPALETTE_SIZE) {\n<77> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<89> ipvideo_decode_opcodes(s, frame);
<1> void IGDendelt ( void * d , const char * name , int l ) {\n<2> struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n<4> if ( ( l == 7 ) && ! memcmp ( name , "service" , l ) ) {\n<5> if ( COMPARE ( datas -> tmp . servicetype , "urn:schemas-upnp-org:service:WANCommonInterfaceConfig:" ) ) {\n<6> memcpy ( & datas -> CIF , & datas -> tmp , sizeof ( struct IGDdatas_service ) ) ;\n<8> else if ( COMPARE ( datas -> tmp . servicetype , "urn:schemas-upnp-org:service:WANIPv6FirewallControl:" ) ) {\n<9> memcpy ( & datas -> IPv6FC , & datas -> tmp , sizeof ( struct IGDdatas_service ) ) ;\n<11> else if ( COMPARE ( datas -> tmp . servicetype , "urn:schemas-upnp-org:service:WANIPConnection:" ) || COMPARE ( datas -> tmp . servicetype , "urn:schemas-upnp-org:service:WANPPPConnection:" ) ) {\n<12> if ( datas -> first . servicetype [ 0 ] == '\0' ) {\n<13> memcpy ( & datas -> first , & datas -> tmp , sizeof ( struct IGDdatas_service ) ) ;\n<16> memcpy ( & datas -> second , & datas -> tmp , sizeof ( struct IGDdatas_service ) ) ;
<1> static int dtls_get_reassembled_message ( SSL * s , long * len ) {\n<12> i = s -> method -> ssl_read_bytes ( s , SSL3_RT_HANDSHAKE , & recvd_type , wire , DTLS1_HM_HEADER_LENGTH , 0 ) ;\n<13> if ( i <= 0 ) {\n<19> if ( wire [ 0 ] != SSL3_MT_CCS ) {\n<24> memcpy ( s -> init_buf -> data , wire , i ) ;\n<25> s -> init_num = i - 1 ;\n<26> s -> init_msg = s -> init_buf -> data + 1 ;\n<55> if ( wire [ 1 ] == 0 && wire [ 2 ] == 0 && wire [ 3 ] == 0 ) {
<1> print_insn_sparc (bfd_vma memaddr, disassemble_info *info)\n<39> if (!opcodes_initialized)\n<43> malloc (sparc_num_opcodes * sizeof (sparc_opcode *));\n<121> const sparc_opcode *opcode = op->opcode;\n<177> if (X_RS1 (insn) != X_RD (insn)\n<179> && strchr (opcode->args, 'r') != NULL)\n<185> if (X_RS2 (insn) != X_RD (insn)\n<187> && strchr (opcode->args, 'O') != NULL)\n<211> for (s = opcode->args; *s != '\0'; ++s)
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<36> buf += 20 ;\n<38> buf += 3 ;\n<42> avctx -> sample_aspect_ratio . den = read32 ( & buf , endian ) ;\n<84> ptr = p -> data [ 0 ] ;\n<86> if ( source_packet_size * avctx -> width * avctx -> height > buf_end - buf ) {\n<106> case 8 : case 12 : case 16 : if ( source_packet_size == target_packet_size ) {\n<108> x < avctx -> height ;\n<110> memcpy ( ptr , buf , target_packet_size * avctx -> width ) ;\n<111> ptr += stride ;\n<112> buf += source_packet_size * avctx -> width ;\n<119> uint8_t * dst = ptr ;\n<121> y < avctx -> width ;\n<123> memcpy ( dst , buf , target_packet_size ) ;\n<124> dst += target_packet_size ;\n<125> buf += source_packet_size ;
<1> static int clone_slice ( H264Context * dst , H264Context * src ) {\n<2> memcpy ( dst -> block_offset , src -> block_offset , sizeof ( dst -> block_offset ) ) ;\n<13> memcpy ( dst -> short_ref , src -> short_ref , sizeof ( dst -> short_ref ) ) ;\n<14> memcpy ( dst -> long_ref , src -> long_ref , sizeof ( dst -> long_ref ) ) ;\n<15> memcpy ( dst -> default_ref_list , src -> default_ref_list , sizeof ( dst -> default_ref_list ) ) ;\n<16> memcpy ( dst -> dequant4_coeff , src -> dequant4_coeff , sizeof ( src -> dequant4_coeff ) ) ;\n<17> memcpy ( dst -> dequant8_coeff , src -> dequant8_coeff , sizeof ( src -> dequant8_coeff ) ) ;
<1> int main(int argc, char **argv, char **envp)\n<5> struct target_pt_regs regs1, *regs = &regs1;\n<7> struct image_info info1, *info = &info1;\n<41> if ((envlist = envlist_create()) == NULL) {\n<43> (void) fprintf(stderr, "Unable to allocate envlist\n");\n<53> for (wrk = environ; *wrk != NULL; wrk++) {\n<95> optind = parse_args(argc, argv);\n<111> memset(regs, 0, sizeof(struct target_pt_regs));\n<117> memset(info, 0, sizeof(struct image_info));\n<121> memset(&bprm, 0, sizeof (bprm));\n<225> if (!cpu) {\n<227> fprintf(stderr, "Unable to find CPU definition\n");\n<243> if (getenv("QEMU_STRACE")) {\n<245> do_strace = 1;\n<251> if (getenv("QEMU_RAND_SEED")) {\n<253> handle_arg_randseed(getenv("QEMU_RAND_SEED"));\n<283> if (guest_base == (unsigned long)-1) {\n<285> fprintf(stderr, "Unable to reserve 0x%lx bytes of virtual address "\n<301> mmap_next_start = reserved_va;\n<325> if ((fp = fopen("/proc/sys/vm/mmap_min_addr", "r")) != NULL) {\n<329> if (fscanf(fp, "%lu", &tmp) == 1) {\n<331> mmap_min_addr = tmp;\n<333> qemu_log_mask(CPU_LOG_PAGE, "host mmap_min_addr=0x%lx\n", mmap_min_addr);\n<337> fclose(fp);\n<351> target_argc = argc - optind;\n<353> target_argv = calloc(target_argc + 1, sizeof (char *));\n<355> if (target_argv == NULL) {\n<357> (void) fprintf(stderr, "Unable to allocate memory for target_argv\n");\n<375> if (argv0 != NULL) {\n<377> target_argv[i++] = strdup(argv0);\n<381> for (; i < target_argc; i++) {\n<383> target_argv[i] = strdup(argv[optind + i]);\n<397> ts->info = info;\n<399> ts->bprm = &bprm;\n<411> execfd = open(filename, O_RDONLY);\n<413> if (execfd < 0) {\n<415> printf("Error while loading %s: %s\n", filename, strerror(errno));\n<425> ret = loader_exec(execfd, filename, target_argv, target_environ, regs,\n<429> if (ret != 0) {\n<431> printf("Error while loading %s: %s\n", filename, strerror(-ret));\n<439> for (wrk = target_environ; *wrk; wrk++) {\n<441> free(*wrk);\n<447> free(target_environ);\n<1283> if (gdbserver_start(gdbstub_port) < 0) {\n<1285> fprintf(stderr, "qemu: could not open gdbserver on port %d\n",
<1> static COMMANDS * find_command ( char * name ) {\n<6> DBUG_PRINT ( "enter" , ( "name: '%s'" , name ) ) ;\n<7> while ( my_isspace ( charset_info , * name ) ) name ++ ;\n<8> if ( ( ! real_binary_mode && strstr ( name , "\\g" ) ) || ( strstr ( name , delimiter ) && ! is_delimiter_command ( name , DELIMITER_NAME_LEN ) ) ) DBUG_RETURN ( ( COMMANDS * ) 0 ) ;\n<9> if ( ( end = strcont ( name , " \t" ) ) ) {\n<14> else len = ( uint ) strlen ( name ) ;\n<17> if ( is_delimiter_command ( name , len ) ) index = delimiter_index ;\n<23> if ( ! my_strnncoll ( & my_charset_latin1 , ( uchar * ) name , len , ( uchar * ) commands [ i ] . name , len ) && ( commands [ i ] . name [ len ] == '\0' ) && ( ! end || ( commands [ i ] . takes_params && get_arg ( name , CHECK ) ) ) ) {
<1> int ff_dxva2_commit_buffer(AVCodecContext *avctx,\n<7> unsigned type, const void *data, unsigned size,\n<57> if (size <= dxva_size) {\n<59> memcpy(dxva_data, data, size);
<1> static int compare_img ( const vpx_image_t * const img1 , const vpx_image_t * const img2 ) {\n<3> uint32_t c_w = ( img1 -> d_w + img1 -> x_chroma_shift ) >> img1 -> x_chroma_shift ;\n<9> match &= ( img1 -> d_h == img2 -> d_h ) ;\n<18> i < c_h ;\n<19> ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_U ] + i * img1 -> stride [ VPX_PLANE_U ] , img2 -> planes [ VPX_PLANE_U ] + i * img2 -> stride [ VPX_PLANE_U ] , c_w ) == 0 ) ;\n<21> i < c_h ;\n<22> ++ i ) match &= ( memcmp ( img1 -> planes [ VPX_PLANE_V ] + i * img1 -> stride [ VPX_PLANE_V ] , img2 -> planes [ VPX_PLANE_V ] + i * img2 -> stride [ VPX_PLANE_V ] , c_w ) == 0 ) ;\n<23> return match ;
<1> static int loop_through_relocations ( Dwarf_Debug dbg , dwarf_elf_object_access_internals_t * obj , struct Dwarf_Section_s * relocatablesec , int * error ) {\n<10> struct Dwarf_Elf_Rela * relas = 0 ;\n<13> ret = get_relocation_entries ( obj -> is_64bit , obj -> endianness , obj -> machine , relocation_section , relocation_section_size , relocation_section_entrysize , & relas , & nrelas , error ) ;\n<14> if ( ret != DW_DLV_OK ) {\n<15> free ( relas ) ;\n<18> if ( ! relocatablesec -> dss_data_was_malloc ) {\n<19> mspace = malloc ( relocatablesec -> dss_size ) ;\n<20> if ( ! mspace ) {\n<24> memcpy ( mspace , relocatablesec -> dss_data , relocatablesec -> dss_size ) ;\n<25> relocatablesec -> dss_data = mspace ;\n<30> ret = apply_rela_entries ( dbg , obj -> is_64bit , obj -> endianness , obj -> machine , target_section , symtab_section , symtab_section_size , symtab_section_entrysize , relas , nrelas , error ) ;\n<31> free ( relas ) ;
<1> static int dca_convert_bitstream(uint8_t * src, int src_size, uint8_t * dst,\n<8> mrk = AV_RB32(src);\n<9> switch (mrk) {\n<11> memcpy(dst, src, FFMIN(src_size, max_size));
<1> void cpu_physical_memory_write_rom(target_phys_addr_t addr,\n<3> const uint8_t *buf, int len)\n<23> if (l > len)\n<25> l = len;\n<47> ptr = qemu_get_ram_ptr(addr1);\n<49> memcpy(ptr, buf, l);\n<58> qemu_put_ram_ptr(ptr);\n<61> len -= l;\n<63> buf += l;
<1> static void test_bug10760 ( ) {\n<15> i < 42 ;\n<17> char buf [ 100 ] ;\n<18> sprintf ( buf , "insert into t1 (id) values (%d)" , i + 1 ) ;\n<19> rc = mysql_query ( mysql , buf ) ;\n<25> mysql_stmt_attr_set ( stmt , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;\n<26> stmt_text = "select id from t1 order by 1" ;\n<27> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<28> check_execute ( stmt , rc ) ;\n<32> if ( rc && ! opt_silent ) printf ( "Got error (as expected): %s\n" , mysql_error ( mysql ) ) ;\n<36> check_execute ( stmt , rc ) ;\n<37> if ( ! have_innodb ) {\n<38> if ( ! opt_silent ) printf ( "Testing that cursors are closed at COMMIT/ROLLBACK requires " "InnoDB.\n" ) ;\n<41> stmt_text = "select id from t1 order by 1" ;\n<42> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<43> check_execute ( stmt , rc ) ;\n<46> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<52> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<56> if ( ! opt_silent ) printf ( "Fetched row %s\n" , id_buf ) ;
<1> static int mjpeg_decode_frame(AVCodecContext *avctx,\n<9> MJpegDecodeContext *s = avctx->priv_data;\n<47> len = buf_ptr - buf_start;\n<49> if (len + (s->buf_ptr - s->buffer) > s->buffer_size) {\n<61> memcpy(s->buf_ptr, buf_start, len);\n<63> s->buf_ptr += len;\n<97> mjpeg_decode_dqt(s, s->buffer, input_size);\n<103> mjpeg_decode_dht(s, s->buffer, input_size);\n<109> mjpeg_decode_sof0(s, s->buffer, input_size);\n<115> mjpeg_decode_sos(s, s->buffer, input_size);
<1> int ssl3_read_n ( SSL * s , int n , int max , int extend , int clearold ) {\n<7> rb = & s -> rlayer . rbuf ;\n<8> if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ;\n<13> if ( left == 0 ) rb -> offset = align ;\n<14> else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) {\n<15> pkt = rb -> buf + rb -> offset ;\n<16> if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) {\n<17> memmove ( rb -> buf + align , pkt , left ) ;
<1> static void test_signal_restore ( void ) {\n<6> printf ( "Signal handler restore: " ) ;
<1> static QEMUMachine *machine_parse(const char *name)\n<15> if (machine) {\n<21> printf("Supported machines are:\n");\n<23> for (m = first_machine; m != NULL; m = m->next) {\n<25> if (m->alias) {\n<27> printf("%-20s %s (alias of %s)\n", m->alias, m->desc, m->name);
<1> static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n<9> for (i = 0; i < s->nb_streams; i++) {\n<11> MXFTrack *track = s->streams[i]->priv_data;\n<15> if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n<17> return i;
<1> static int h264_handle_packet(AVFormatContext *ctx,\n<6> const uint8_t * buf,\n<7> int len, int flags)\n<17> assert(buf);\n<20> switch (type) {\n<25> av_new_packet(pkt, len+sizeof(start_sequence));\n<26> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<27> memcpy(pkt->data+sizeof(start_sequence), buf, len);\n<47> src += 2;\n<49> if (nal_size <= src_len) {\n<50> if(pass==0) {\n<55> assert(dst);\n<56> memcpy(dst, start_sequence, sizeof(start_sequence));\n<57> dst+= sizeof(start_sequence);\n<58> memcpy(dst, src, nal_size);\n<62> dst+= nal_size;\n<69> src += nal_size;\n<70> src_len -= nal_size;\n<109> buf++;\n<110> len--;\n<115> if(start_bit) {\n<117> av_new_packet(pkt, sizeof(start_sequence)+sizeof(nal)+len);\n<118> memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n<119> pkt->data[sizeof(start_sequence)]= reconstructed_nal;\n<120> memcpy(pkt->data+sizeof(start_sequence)+sizeof(nal), buf, len);\n<122> av_new_packet(pkt, len);\n<123> memcpy(pkt->data, buf, len);
<1> static int parse_data ( struct strbuf * sb , uintmax_t limit , uintmax_t * len_res ) {\n<5> if ( skip_prefix ( data , "<<" , & data ) ) {\n<6> char * term = xstrdup ( data ) ;\n<7> size_t term_len = command_buf . len - ( data - command_buf . buf ) ;\n<8> strbuf_detach ( & command_buf , NULL ) ;\n<12> if ( strbuf_getline ( & command_buf , stdin , '\n' ) == EOF ) die ( "EOF in data (terminator '%s' not found)" , term ) ;\n<13> if ( term_len == command_buf . len && ! strcmp ( term , command_buf . buf ) ) break ;\n<14> strbuf_addbuf ( sb , & command_buf ) ;\n<15> strbuf_addch ( sb , '\n' ) ;\n<17> free ( term ) ;
<1> static int readfull ( AVFormatContext * s , AVIOContext * pb , uint8_t * dst , int n ) {\n<2> int ret = avio_read ( pb , dst , n ) ;\n<3> if ( ret != n ) {\n<4> if ( ret >= 0 ) memset ( dst + ret , 0 , n - ret ) ;\n<5> else memset ( dst , 0 , n ) ;
<1> static int spapr_vio_busdev_init(DeviceState *qdev)\n<13> if (dev->reg != -1) {\n<27> VIOsPAPRDevice *other = reg_conflict(dev);\n<31> if (other) {\n<33> fprintf(stderr, "vio: %s and %s devices conflict at address %#x\n",\n<35> object_get_typename(OBJECT(qdev)),\n<37> object_get_typename(OBJECT(&other->qdev)),
<1> static struct row_pairs * gtkui_connections_add ( struct conn_object * co , void * conn , struct row_pairs * * list ) {\n<3> char flags [ 2 ] , src [ MAX_ASCII_ADDR_LEN ] , dst [ MAX_ASCII_ADDR_LEN ] ;\n<4> char proto [ 4 ] , status [ 8 ] , ccodes [ 8 ] ;\n<7> if ( ! list ) return ( NULL ) ;\n<8> memset ( & flags , 0 , sizeof ( flags ) ) ;\n<9> memset ( & proto , 0 , sizeof ( proto ) ) ;\n<10> memset ( & src , 0 , sizeof ( src ) ) ;\n<11> memset ( & dst , 0 , sizeof ( dst ) ) ;\n<12> memset ( & status , 0 , sizeof ( status ) ) ;\n<13> memset ( & ccodes , 0 , sizeof ( ccodes ) ) ;\n<14> conntrack_flagstr ( co , flags , sizeof ( flags ) ) ;\n<15> conntrack_statusstr ( co , status , sizeof ( status ) ) ;\n<16> conntrack_protostr ( co , proto , sizeof ( proto ) ) ;\n<17> conntrack_countrystr ( co , ccodes , sizeof ( ccodes ) ) ;\n<18> ip_addr_ntoa ( & co -> L3_addr1 , src ) ;\n<19> ip_addr_ntoa ( & co -> L3_addr2 , dst ) ;\n<25> gtk_list_store_set ( ls_conns , & iter , 0 , flags , 1 , src , 2 , src_port , 3 , "-" , 4 , dst , 5 , dst_port , 6 , proto , 7 , status , 8 , tx , 9 , rx , 10 , ccodes , 11 , conn , - 1 ) ;\n<26> if ( ! * list ) {\n<27> row = malloc ( sizeof ( struct row_pairs ) ) ;\n<28> if ( row == NULL ) {\n<38> row -> next = malloc ( sizeof ( struct row_pairs ) ) ;\n<39> if ( row -> next == NULL ) {
<1> void min_heap_dtor ( min_heap_t * s ) {\n<2> if ( s -> p ) free ( s -> p ) ;
<1> void av_image_fill_max_pixsteps ( int max_pixsteps [ 4 ] , int max_pixstep_comps [ 4 ] , const AVPixFmtDescriptor * pixdesc ) {\n<3> memset ( max_pixsteps , 0 , 4 * sizeof ( max_pixsteps [ 0 ] ) ) ;\n<4> if ( max_pixstep_comps ) memset ( max_pixstep_comps , 0 , 4 * sizeof ( max_pixstep_comps [ 0 ] ) ) ;\n<9> if ( ( comp -> step_minus1 + 1 ) > max_pixsteps [ comp -> plane ] ) {
<1> static int encode_residual_ch(FlacEncodeContext *s, int ch)\n<25> res   = sub->residual;\n<27> smp   = sub->samples;\n<37> if(smp[i] != smp[0])\n<55> if (frame->verbatim_only || n < 5) {\n<59> memcpy(res, smp, n * sizeof(int32_t));\n<203> } else if (omethod == ORDER_METHOD_LOG) {\n<213> memset(bits, -1, sizeof(bits));\n<223> if (i < min_order-1 || i >= max_order || bits[i] < UINT32_MAX)\n<231> if (bits[i] < bits[opt_order])
<1> static void vga_update_text(void *opaque, console_ch_t *chardata)\n<46> if (!full_update)\n<48> snprintf(msg_buffer, sizeof(msg_buffer), "%i x %i Text mode",\n<112> if (!full_update)\n<115> snprintf(msg_buffer, sizeof(msg_buffer), "%i x %i Graphic mode",\n<120> if (!full_update)\n<122> snprintf(msg_buffer, sizeof(msg_buffer), "VGA Blank mode");\n<134> size = strlen(msg_buffer);\n<135> width = (s->last_width - size) / 2;\n<138> console_write_ch(dst ++, 0x00200100 | msg_buffer[i]);
<1> static void test_bug6049 ( ) {\n<7> char buffer [ 30 ] ;\n<11> stmt_text = "SELECT MAKETIME(-25, 12, 12)" ;\n<12> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<14> res = mysql_store_result ( mysql ) ;\n<15> row = mysql_fetch_row ( res ) ;\n<16> stmt = mysql_stmt_init ( mysql ) ;\n<17> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<18> check_execute ( stmt , rc ) ;\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<26> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<29> if ( ! opt_silent ) {\n<30> printf ( "Result from query: %s\n" , row [ 0 ] ) ;\n<31> printf ( "Result from prepared statement: %s\n" , ( char * ) buffer ) ;\n<33> DIE_UNLESS ( strcmp ( row [ 0 ] , ( char * ) buffer ) == 0 ) ;
<1> static void parse_forced_key_frames(char *kf, OutputStream *ost,\n<17> if (*p == ',')\n<35> p = kf;\n<37> for (i = 0; i < n; i++) {\n<39> char *next = strchr(p, ',');\n<45> *next++ = 0;\n<49> t = parse_time_or_die("force_key_frames", p, 1);\n<55> p = next;
<1> static int nextpstoken ( IO * wrapper , real * val , char * tokbuf , int tbsize ) {\n<9> if ( ch != '%' ) break ;\n<12> if ( sscanf ( tokbuf , " MF2PT1: bbox %*g %*g %g %*g" , & mf2pt_advance_width ) == 1 ) wrapper -> advance_width = mf2pt_advance_width ;\n<13> else if ( sscanf ( tokbuf , " MF2PT1: glyph_dimensions %*g %*g %g %*g" , & mf2pt_advance_width ) == 1 ) wrapper -> advance_width = mf2pt_advance_width ;\n<14> pt = tokbuf ;\n<17> pt = tokbuf ;
<1> int cpu_ppc_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,\n<43> } else if (ret < 0) {\n<439> switch (access_type) {\n<499> printf("DSI: invalid exception (%d)\n", ret);
<1> gcry_error_t gcry_sexp_build_array ( gcry_sexp_t * retsexp , size_t * erroff , const char * format , void * * arg_list ) {\n<2> return sexp_sscan ( retsexp , erroff , format , strlen ( format ) , 1 , arg_list ) ;
<1> static CURLFORMcode FormAdd ( struct curl_httppost * * httppost , struct curl_httppost * * last_post , va_list params ) {\n<10> first_form = calloc ( 1 , sizeof ( struct FormInfo ) ) ;\n<11> if ( ! first_form ) return CURL_FORMADD_MEMORY ;\n<60> if ( filename ) {\n<61> current_form -> value = strdup ( filename ) ;\n<62> if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n<75> if ( filename ) {\n<76> char * fname = strdup ( filename ) ;\n<77> if ( ! fname ) return_value = CURL_FORMADD_MEMORY ;\n<96> if ( filename ) {\n<97> current_form -> value = strdup ( filename ) ;\n<98> if ( ! current_form -> value ) return_value = CURL_FORMADD_MEMORY ;\n<137> if ( contenttype ) {\n<138> char * type = strdup ( contenttype ) ;\n<139> if ( ! type ) return_value = CURL_FORMADD_MEMORY ;\n<158> if ( contenttype ) {\n<159> current_form -> contenttype = strdup ( contenttype ) ;\n<160> if ( ! current_form -> contenttype ) return_value = CURL_FORMADD_MEMORY ;\n<175> if ( current_form -> showfilename ) return_value = CURL_FORMADD_OPTION_TWICE ;\n<177> current_form -> showfilename = strdup ( filename ) ;\n<178> if ( ! current_form -> showfilename ) return_value = CURL_FORMADD_MEMORY ;\n<213> form != NULL ;\n<215> if ( ( ( ! form -> name || ! form -> value ) && ! post ) || ( ( form -> contentslength ) && ( form -> flags & HTTPPOST_FILENAME ) ) || ( ( form -> flags & HTTPPOST_FILENAME ) && ( form -> flags & HTTPPOST_PTRCONTENTS ) ) || ( ( ! form -> buffer ) && ( form -> flags & HTTPPOST_BUFFER ) && ( form -> flags & HTTPPOST_PTRBUFFER ) ) || ( ( form -> flags & HTTPPOST_READFILE ) && ( form -> flags & HTTPPOST_PTRCONTENTS ) ) ) {\n<220> if ( ( ( form -> flags & HTTPPOST_FILENAME ) || ( form -> flags & HTTPPOST_BUFFER ) ) && ! form -> contenttype ) {\n<222> form -> contenttype = strdup ( ContentTypeForFilename ( f , prevtype ) ) ;\n<223> if ( ! form -> contenttype ) {\n<229> if ( ! ( form -> flags & HTTPPOST_PTRNAME ) && ( form == first_form ) ) {\n<231> form -> name = Curl_memdup ( form -> name , form -> namelength ? form -> namelength : strlen ( form -> name ) + 1 ) ;\n<239> if ( ! ( form -> flags & ( HTTPPOST_FILENAME | HTTPPOST_READFILE | HTTPPOST_PTRCONTENTS | HTTPPOST_PTRBUFFER | HTTPPOST_CALLBACK ) ) && form -> value ) {\n<240> form -> value = Curl_memdup ( form -> value , form -> contentslength ? form -> contentslength : strlen ( form -> value ) + 1 ) ;
<1> static void write_branch_report ( FILE * rpt , struct branch * b ) {\n<2> fprintf ( rpt , "%s:\n" , b -> name ) ;\n<3> fprintf ( rpt , " status :" ) ;\n<4> if ( b -> active ) fputs ( " active" , rpt ) ;\n<5> if ( b -> branch_tree . tree ) fputs ( " loaded" , rpt ) ;\n<6> if ( is_null_sha1 ( b -> branch_tree . versions [ 1 ] . sha1 ) ) fputs ( " dirty" , rpt ) ;\n<7> fputc ( '\n' , rpt ) ;\n<8> fprintf ( rpt , " tip commit : %s\n" , sha1_to_hex ( b -> sha1 ) ) ;\n<9> fprintf ( rpt , " old tree : %s\n" , sha1_to_hex ( b -> branch_tree . versions [ 0 ] . sha1 ) ) ;\n<10> fprintf ( rpt , " cur tree : %s\n" , sha1_to_hex ( b -> branch_tree . versions [ 1 ] . sha1 ) ) ;\n<12> fputs ( " last pack : " , rpt ) ;\n<13> if ( b -> pack_id < MAX_PACK_ID ) fprintf ( rpt , "%u" , b -> pack_id ) ;\n<14> fputc ( '\n' , rpt ) ;
<1> static int realloc_refcount_array(BDRVQcowState *s, uint16_t **array,\n<41> if (!new_ptr) {\n<49> if (new_byte_size > old_byte_size) {\n<51> memset((void *)((uintptr_t)new_ptr + old_byte_size), 0,\n<53> new_byte_size - old_byte_size);
<1> static void bamboo_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n<26> kernel_size = load_uimage ( kernel_filename , & entry , & loadaddr , NULL ) ;\n<28> kernel_size = load_elf ( kernel_filename , 0 , & elf_entry , & elf_lowaddr , NULL , 1 , ELF_MACHINE , 0 ) ;\n<32> if ( kernel_size < 0 ) {\n<33> fprintf ( stderr , "qemu: could not load kernel '%s'\n" , kernel_filename ) ;\n<39> initrd_size = load_image_targphys ( initrd_filename , initrd_base , ram_size - initrd_base ) ;\n<40> if ( initrd_size < 0 ) {\n<41> fprintf ( stderr , "qemu: could not load initial ram disk '%s'\n" , initrd_filename ) ;\n<49> if ( fdt == NULL ) {\n<50> fprintf ( stderr , "couldn't load device tree\n" ) ;
<1> static char * * subsystems_from_mount_options ( const char * mount_options , char * * kernel_list ) {\n<8> str = alloca ( strlen ( mount_options ) + 1 ) ;\n<9> strcpy ( str , mount_options ) ;\n<13> if ( ! strncmp ( token , "name=" , 5 ) || lxc_string_in_array ( token , ( const char * * ) kernel_list ) ) {\n<15> if ( r < 0 ) goto out_free ;\n<17> result [ result_count ] = strdup ( token ) ;\n<18> if ( ! result [ result_count ] ) goto out_free ;
<1> TIFF * TIFFOpen ( const char * name , const char * mode ) {\n<9> if ( fd < 0 ) {\n<10> if ( errno > 0 && strerror ( errno ) != NULL ) {\n<11> TIFFErrorExt ( 0 , module , "%s: %s" , name , strerror ( errno ) ) ;\n<14> TIFFErrorExt ( 0 , module , "%s: Cannot open" , name ) ;
<1> static void openpic_reset (void *opaque)\n<41> for (i = 0; i < MAX_CPU; i++) {\n<47> memset(&opp->dst[i].raised, 0, sizeof(IRQ_queue_t));\n<50> memset(&opp->dst[i].servicing, 0, sizeof(IRQ_queue_t));
<1> static Asn1Generic * Asn1GenericNew ( void ) {\n<4> if ( obj != NULL ) memset ( obj , 0 , sizeof ( Asn1Generic ) ) ;\n<5> return obj ;
<1> void copy_bits ( REP_SET * to , REP_SET * from ) {\n<2> memcpy ( ( uchar * ) to -> bits , ( uchar * ) from -> bits , ( size_t ) ( sizeof ( uint ) * to -> size_of_bits ) ) ;
<1> static cmsBool Read16bitTables ( cmsContext ContextID , cmsIOHANDLER * io , cmsPipeline * lut , int nChannels , int nEntries ) {\n<6> if ( nChannels > cmsMAXCHANNELS ) return FALSE ;\n<7> memset ( Tables , 0 , sizeof ( Tables ) ) ;\n<12> if ( Tables [ i ] == NULL ) goto Error ;\n<15> if ( ! cmsPipelineInsertStage ( lut , cmsAT_END , cmsStageAllocToneCurves ( ContextID , nChannels , Tables ) ) ) goto Error ;\n<23> if ( Tables [ i ] ) cmsFreeToneCurve ( Tables [ i ] ) ;
<1> create_iovec(QEMUIOVector *qiov, char **argv, int nr_iov, int pattern)\n<5> size_t *sizes = calloc(nr_iov, sizeof(size_t));\n<15> for (i = 0; i < nr_iov; i++) {\n<23> len = cvtnum(arg);\n<25> if (len < 0) {\n<27> printf("non-numeric length argument -- %s\n", arg);\n<37> if (len > UINT_MAX) {\n<39> printf("too large length argument -- %s\n", arg);\n<47> if (len & 0x1ff) {\n<49> printf("length argument %lld is not sector aligned\n",\n<59> sizes[i] = len;\n<77> qemu_iovec_add(qiov, p, sizes[i]);\n<79> p += sizes[i];\n<85> free(sizes);
<1> static int process_principals ( struct ssh * ssh , FILE * f , const char * file , const struct sshkey_cert * cert , struct sshauthopt * * authoptsp ) {\n<2> char loc [ 256 ] , * line = NULL , * cp , * ep ;\n<6> if ( authoptsp != NULL ) * authoptsp = NULL ;\n<7> while ( getline ( & line , & linesize , f ) != - 1 ) {\n<9> if ( found_principal ) continue ;\n<10> for ( cp = line ;\n<11> * cp == ' ' || * cp == '\t' ;\n<12> cp ++ ) ;\n<13> if ( ( ep = strchr ( cp , '#' ) ) != NULL ) * ep = '\0' ;\n<16> if ( check_principals_line ( ssh , cp , cert , loc , authoptsp ) == 0 ) found_principal = 1 ;\n<18> free ( line ) ;
<1> vmxnet3_indicate_packet(VMXNET3State *s)\n<63> if (!vmxnet3_get_next_rx_descr(s, is_head, &rxd, &rxd_idx, &rx_ridx)) {\n<89> cpu_physical_memory_write(ready_rxcd_pa, &rxcd, sizeof(rxcd));\n<95> memset(&rxcd, 0, sizeof(struct Vmxnet3_RxCompDesc));\n<97> rxcd.rxdIdx = rxd_idx;\n<99> rxcd.len = chunk_size;\n<101> rxcd.sop = is_head;\n<103> rxcd.gen = new_rxcd_gen;\n<105> rxcd.rqID = RXQ_IDX + rx_ridx * s->rxq_num;\n<111> vmxnet3_rx_update_descr(s->rx_pkt, &rxcd);\n<117> VMW_RIPRN("RX Completion descriptor: rxRing: %lu rxIdx %lu len %lu "\n<123> (unsigned long) rxcd.rxdIdx,\n<125> (unsigned long) rxcd.len,\n<127> (int) rxcd.sop,\n<149> cpu_physical_memory_write(ready_rxcd_pa, &rxcd, sizeof(rxcd));
<1> void av_image_copy ( uint8_t * dst_data [ 4 ] , int dst_linesizes [ 4 ] , const uint8_t * src_data [ 4 ] , const int src_linesizes [ 4 ] , enum PixelFormat pix_fmt , int width , int height ) {\n<4> if ( desc -> flags & PIX_FMT_PAL ) {\n<6> memcpy ( dst_data [ 1 ] , src_data [ 1 ] , 4 * 256 ) ;
<1> int add_av_stream(FFStream *feed,\n<15> av = &st->codec;\n<23> if (av1->codec_id == av->codec_id &&\n<25> av1->codec_type == av->codec_type &&\n<27> av1->bit_rate == av->bit_rate) {\n<35> if (av1->channels == av->channels &&\n<37> av1->sample_rate == av->sample_rate)\n<45> if (av1->width == av->width &&\n<47> av1->height == av->height &&\n<49> av1->frame_rate == av->frame_rate &&\n<51> av1->gop_size == av->gop_size)\n<71> if (!fst)\n<77> memcpy(&fst->codec, av, sizeof(AVCodecContext));
<1> static int compare_name ( int mode , const char * name , const char * uid , size_t uidlen ) {\n<24> i = se - s ;\n<25> if ( mode == KEYDB_SEARCH_MODE_MAIL ) {\n<26> if ( strlen ( name ) - 2 == i && ! ascii_memcasecmp ( s , name + 1 , i ) ) return 0 ;\n<38> return - 1 ;
<1> int test_mod ( BIO * bp , BN_CTX * ctx ) {\n<29> if ( ! BN_is_zero ( e ) ) {\n<30> fprintf ( stderr , "Modulo test failed!\n" ) ;
<1> static void vga_screen_dump_common(VGAState *s, const char *filename,\n<7> DisplayState *saved_ds, ds1, *ds = &ds1;\n<21> memset(ds, 0, sizeof(DisplayState));\n<23> memset(&dcl, 0, sizeof(DisplayChangeListener));\n<31> register_displaychangelistener(ds, &dcl);
<1> Encoding * PSSlurpEncodings ( FILE * file ) {\n<3> int32 encs [ 1024 ] ;\n<24> encs [ i ] = - 1 ;\n<25> names [ i ] = NULL ;\n<31> ( tok = nextpstoken ( & wrapper , & dval , tokbuf , sizeof ( tokbuf ) ) ) != pt_eof && tok != pt_closearray && tok != pt_closecurly ;\n<33> if ( tok == pt_namelit && i < sizeof ( names ) / sizeof ( names [ 0 ] ) ) {\n<35> if ( strcmp ( tokbuf , ".notdef" ) == 0 ) {\n<36> encs [ i ] = - 1 ;\n<38> else if ( ( enc = UniFromName ( tokbuf , ui_none , & custom ) ) != - 1 ) {\n<39> encs [ i ] = enc ;\n<40> names [ i ] = copy ( tokbuf ) ;\n<44> names [ i ] = copy ( tokbuf ) ;\n<56> if ( max != - 1 ) {\n<58> item = calloc ( 1 , sizeof ( Encoding ) ) ;\n<61> item -> unicode = malloc ( max * sizeof ( int32 ) ) ;\n<62> memcpy ( item -> unicode , encs , max * sizeof ( int32 ) ) ;\n<63> if ( any && ! codepointsonly ) {\n<64> item -> psnames = calloc ( max , sizeof ( char * ) ) ;\n<65> memcpy ( item -> psnames , names , max * sizeof ( char * ) ) ;\n<69> i < max ;\n<70> ++ i ) free ( names [ i ] ) ;\n<72> if ( head == NULL ) head = item ;\n<73> else last -> next = item ;\n<74> last = item ;
<1> int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n<7> BDRVQcowState *s = bs->opaque;\n<67> if (new_l1_size > INT_MAX / sizeof(uint64_t)) {\n<87> new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n<89> memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n<101> g_free(new_l1_table);\n<139> new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n<141> ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n<169> g_free(s->l1_table);\n<189> g_free(new_l1_table);
<1> static void assert_file_overwrite(const char *filename)\n<5> if (file_overwrite && no_file_overwrite) {\n<7> fprintf(stderr, "Error, both -y and -n supplied. Exiting.\n");\n<15> if (!file_overwrite &&\n<17> (strchr(filename, ':') == NULL || filename[1] == ':' ||\n<19> av_strstart(filename, "file:", NULL))) {\n<21> if (avio_check(filename, 0) == 0) {\n<23> if (stdin_interaction && !no_file_overwrite) {\n<25> fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", filename);\n<27> fflush(stderr);\n<35> av_log(NULL, AV_LOG_FATAL, "Not overwriting - exiting\n");\n<47> av_log(NULL, AV_LOG_FATAL, "File '%s' already exists. Exiting.\n", filename);
<1> static USBDevice *usb_msd_init(const char *filename)\n<31> p1 = strchr(filename, ':');
<1> static void ppc_spapr_init(ram_addr_t ram_size,\n<39> load_limit = spapr->fdt_addr - FW_OVERHEAD;\n<46> if (cpu == NULL) {\n<47> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<85> spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\n<112> for (i = 0; i < nb_nics; i++) {\n<113> NICInfo *nd = &nd_table[i];\n<114> if (!nd->model) {\n<115> nd->model = g_strdup("ibmveth");\n<117> if (strcmp(nd->model, "ibmveth") == 0) {\n<118> spapr_vlan_create(spapr->vio_bus, nd);\n<120> pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n<126> if (rma_size < (MIN_RMA_SLOF << 20)) {\n<127> fprintf(stderr, "qemu: pSeries SLOF firmware requires >= "\n<131> fprintf(stderr, "sPAPR memory map:\n");\n<132> fprintf(stderr, "RTAS                 : 0x%08lx..%08lx\n",\n<134> (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1));\n<135> fprintf(stderr, "FDT                  : 0x%08lx..%08lx\n",\n<137> (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1));\n<138> if (kernel_filename) {\n<140> kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n<145> load_limit - KERNEL_LOAD_ADDR);\n<147> if (kernel_size < 0) {\n<148> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<152> fprintf(stderr, "Kernel               : 0x%08x..%08lx\n",\n<153> KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1);\n<155> if (initrd_filename) {\n<159> initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n<160> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<161> load_limit - initrd_base);\n<162> if (initrd_size < 0) {\n<163> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",\n<167> fprintf(stderr, "Ramdisk              : 0x%08lx..%08lx\n",\n<168> (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n<176> if (fw_size < 0) {\n<181> fprintf(stderr, "Firmware load        : 0x%08x..%08lx\n",\n<183> fprintf(stderr, "Firmware runtime     : 0x%08lx..%08lx\n",
<1> ram_addr_t qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,\n<29> if (mem_path) {\n<45> fprintf(stderr, "-mem-path option unsupported\n");
<1> static int iec61883_read_header(AVFormatContext *context)\n<5> struct iec61883_data *dv = context->priv_data;\n<23> uint64_t guid = 0;\n<61> if (endptr != context->filename && *endptr == '\0') {\n<69> } else if (strcmp(context->filename, "auto")) {\n<71> av_log(context, AV_LOG_ERROR, "Invalid input \"%s\", you should specify "\n<73> "\"auto\" for auto-detection, or the port number.\n", context->filename);\n<81> if (dv->device_guid) {\n<83> if (sscanf(dv->device_guid, "%llx", (long long unsigned int *)&guid) != 1) {\n<85> av_log(context, AV_LOG_INFO, "Invalid dvguid parameter: %s\n",\n<87> dv->device_guid);\n<97> for (; j < nb_ports && port==-1; ++j) {\n<105> av_log(context, AV_LOG_ERROR, "Failed setting IEEE1394 port.\n");\n<173> av_log(context, AV_LOG_ERROR, "No AV/C devices found.\n");\n<249> avformat_new_stream(context, NULL);\n<253> dv->mpeg_demux = avpriv_mpegts_parse_open(context);\n<283> dv->dv_demux = avpriv_dv_init_demux(context);\n<295> dv->iec61883_dv = iec61883_dv_fb_init(dv->raw1394, iec61883_callback, dv);\n<341> raw1394_destroy_handle(dv->raw1394);\n<343> return AVERROR(EIO);
<1> BlockDriverAIOCB *bdrv_aio_write(BlockDriverState *bs, int64_t sector_num,\n<3> const uint8_t *buf, int nb_sectors,\n<23> if (bdrv_wr_badreq_sectors(bs, sector_num, nb_sectors))\n<27> if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n<29> memcpy(bs->boot_sector_data, buf, 512);\n<35> ret = drv->bdrv_aio_write(bs, sector_num, buf, nb_sectors, cb, opaque);
<1> static void evhttp_handle_request ( struct evhttp_request * req , void * arg ) {\n<20> if ( http -> gencb ) {\n<29> free ( escaped_html ) ;
<1> static int decode_frame(AVCodecContext *avctx,\n<127> while (buf < buf_end && buf[0]) {\n<133> if (check_header_variable(avctx, &buf, buf_end, "channels", "chlist", 38, &variable_buffer_data_size) >= 0) {\n<145> while (channel_list_end - buf >= 19) {\n<153> if (!strcmp(buf, "R"))\n<155> channel_index = 0;\n<157> else if (!strcmp(buf, "G"))\n<159> channel_index = 1;\n<161> else if (!strcmp(buf, "B"))\n<163> channel_index = 2;\n<165> else if (!strcmp(buf, "A"))\n<167> channel_index = 3;\n<171> av_log(avctx, AV_LOG_WARNING, "Unsupported channel %.256s\n", buf);\n<175> while (bytestream_get_byte(&buf) && buf < channel_list_end)\n<181> if (channel_list_end - * &buf < 4) {\n<191> current_bits_per_color_id = bytestream_get_le32(&buf);\n<223> buf += 12;\n<535> bxmin = xmin * 2 * desc->nb_components;\n<537> axmax = (avctx->width - (xmax + 1)) * 2 * desc->nb_components;\n<539> out_line_size = avctx->width * 2 * desc->nb_components;\n<571> ptr    = p->data[0];\n<579> for (y = 0; y < ymin; y++) {\n<581> memset(ptr, 0, out_line_size);\n<583> ptr += stride;\n<619> for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n<621> ptr_x = (uint16_t *)ptr;\n<623> memset(ptr_x, 0, out_line_size);\n<701> for (i = 0; i < scan_lines_per_block && y + i <= ymax; i++, ptr += stride) {\n<719> ptr_x = (uint16_t *)ptr;\n<725> memset(ptr_x, 0, bxmin);\n<727> ptr_x += xmin * desc->nb_components;\n<739> *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b));\n<743> *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n<757> *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b));\n<761> *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a));\n<771> memset(ptr_x, 0, axmax);\n<797> for (y = ymax + 1; y < avctx->height; y++) {\n<799> memset(ptr, 0, out_line_size);\n<801> ptr += stride;
<1> static int qtrle_decode_frame(AVCodecContext *avctx,\n<13> QtrleContext *s = avctx->priv_data;\n<101> qtrle_decode_1bpp(s, stream_ptr, row_ptr, height);\n<111> qtrle_decode_2n4bpp(s, stream_ptr, row_ptr, height, 2);\n<123> qtrle_decode_2n4bpp(s, stream_ptr, row_ptr, height, 4);\n<135> qtrle_decode_8bpp(s, stream_ptr, row_ptr, height);\n<145> qtrle_decode_16bpp(s, stream_ptr, row_ptr, height);\n<153> qtrle_decode_24bpp(s, stream_ptr, row_ptr, height);\n<161> qtrle_decode_32bpp(s, stream_ptr, row_ptr, height);\n<179> if(has_palette) {\n<181> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<185> if (pal) {\n<189> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<197> memcpy(s->frame.data[1], s->pal, AVPALETTE_SIZE);
<1> int ff_pnm_decode_header ( AVCodecContext * avctx , PNMContext * const s ) {\n<5> s -> type = buf1 [ 1 ] - '0' ;\n<6> if ( buf1 [ 0 ] != 'P' ) return AVERROR_INVALIDDATA ;\n<17> else if ( s -> type == 7 ) {\n<26> pnm_get ( s , buf1 , sizeof ( buf1 ) ) ;\n<27> if ( ! strcmp ( buf1 , "WIDTH" ) ) {\n<28> pnm_get ( s , buf1 , sizeof ( buf1 ) ) ;\n<29> w = strtol ( buf1 , NULL , 10 ) ;\n<31> else if ( ! strcmp ( buf1 , "HEIGHT" ) ) {\n<32> pnm_get ( s , buf1 , sizeof ( buf1 ) ) ;\n<33> h = strtol ( buf1 , NULL , 10 ) ;\n<35> else if ( ! strcmp ( buf1 , "DEPTH" ) ) {\n<36> pnm_get ( s , buf1 , sizeof ( buf1 ) ) ;\n<37> depth = strtol ( buf1 , NULL , 10 ) ;\n<39> else if ( ! strcmp ( buf1 , "MAXVAL" ) ) {\n<40> pnm_get ( s , buf1 , sizeof ( buf1 ) ) ;\n<41> maxval = strtol ( buf1 , NULL , 10 ) ;\n<43> else if ( ! strcmp ( buf1 , "TUPLTYPE" ) || ! strcmp ( buf1 , "TUPLETYPE" ) ) {\n<44> pnm_get ( s , tuple_type , sizeof ( tuple_type ) ) ;\n<46> else if ( ! strcmp ( buf1 , "ENDHDR" ) ) {\n<50> return AVERROR_INVALIDDATA ;\n<53> if ( w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type [ 0 ] == '\0' || av_image_check_size ( w , h , 0 , avctx ) ) return AVERROR_INVALIDDATA ;
<1> static int quorum_open(BlockDriverState *bs, QDict *options, int flags,\n<105> } else if (qemu_opt_get_bool(opts, QUORUM_OPT_BLKVERIFY, false)) {\n<107> fprintf(stderr, "blkverify mode is set by setting blkverify=on "
<1> static void labels_to_offsets ( void ) {\n<5> fprintf ( stdout , " Converting labels to real offsets " ) ;\n<6> fflush ( stdout ) ;\n<27> fprintf ( stdout , " done.\n\n" ) ;
<1> static uint32_t acpi_find_vgia(void)\n<83> if (!strncmp((char *)ssdt_table.oem_table_id, "VMGENID", 7)) {\n<95> ACPI_READ_ARRAY(vgid_table.vgia, tables[i]);\n<97> g_assert(memcmp(vgid_table.vgia, "VGIA", 4) == 0);
<1> static int userauth_pubkey ( struct ssh * ssh ) {\n<6> char * pkalg = NULL , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ;\n<7> u_char * pkblob = NULL , * sig = NULL , have_sig ;\n<12> if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( "%s: parse request failed: %s" , __func__ , ssh_err ( r ) ) ;\n<18> if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) {\n<45> debug3 ( "%s: have %s signature for %s%s%s" , __func__ , pkalg , key_s , ca_s == NULL ? "" : " CA " , ca_s == NULL ? "" : ca_s ) ;\n<46> if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( "%s: %s" , __func__ , ssh_err ( r ) ) ;\n<58> xasprintf ( & userstyle , "%s%s%s" , authctxt -> user , authctxt -> style ? ":" : "" , authctxt -> style ? authctxt -> style : "" ) ;\n<59> if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , "publickey" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( "%s: build packet failed: %s" , __func__ , ssh_err ( r ) ) ;\n<62> if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) {\n<69> debug ( "%s: test pkalg %s pkblob %s%s%s" , __func__ , pkalg , key_s , ca_s == NULL ? "" : " CA " , ca_s == NULL ? "" : ca_s ) ;\n<76> if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( "%s: %s" , __func__ , ssh_err ( r ) ) ;\n<84> debug2 ( "%s: authenticated %d pkalg %s" , __func__ , authenticated , pkalg ) ;\n<87> free ( userstyle ) ;\n<88> free ( pkalg ) ;\n<89> free ( pkblob ) ;\n<90> free ( key_s ) ;\n<91> free ( ca_s ) ;\n<92> free ( sig ) ;
<1> static void usb_msd_send_status(MSDState *s, USBPacket *p)\n<21> len = MIN(sizeof(csw), p->len);\n<23> memcpy(p->data, &csw, len);
<1> my_bool get_one_option ( int optid , const struct my_option * opt __attribute__ ( ( unused ) ) , char * argument ) {\n<6> case OPT_DELIMITER : if ( argument == disabled_my_option ) {\n<7> strmov ( delimiter , DEFAULT_DELIMITER ) ;\n<10> if ( ! strstr ( argument , "\\" ) ) {\n<11> strmake_buf ( delimiter , argument ) ;\n<14> put_info ( "DELIMITER cannot contain a backslash character" , INFO_ERROR ) ;\n<15> return 0 ;\n<18> delimiter_length = ( uint ) strlen ( delimiter ) ;\n<19> delimiter_str = delimiter ;\n<28> case OPT_PAGER : if ( argument == disabled_my_option ) opt_nopager = 1 ;\n<31> if ( argument && strlen ( argument ) ) {\n<32> default_pager_set = 1 ;\n<33> strmake_buf ( pager , argument ) ;\n<34> strmov ( default_pager , pager ) ;\n<36> else if ( default_pager_set ) strmov ( pager , default_pager ) ;\n<99> return 0 ;
<1> static void h264_er_decode_mb ( void * opaque , int ref , int mv_dir , int mv_type , int ( * mv ) [ 2 ] [ 4 ] [ 2 ] , int mb_x , int mb_y , int mb_intra , int mb_skipped ) {\n<2> H264Context * h = opaque ;\n<6> memset ( h -> non_zero_count_cache , 0 , sizeof ( h -> non_zero_count_cache ) ) ;\n<21> ff_h264_hl_decode_mb ( h ) ;
<1> static void uninit(struct vf_instance *vf)\n<5> free(vf->priv);
<1> int av_image_fill_pointers(uint8_t *data[4], enum PixelFormat pix_fmt, int height,\n<13> memset(data     , 0, sizeof(data[0])*4);\n<15> memset(size     , 0, sizeof(size));\n<17> memset(has_plane, 0, sizeof(has_plane));\n<39> size[0] = (size[0] + 3) & ~3;\n<41> data[1] = ptr + size[0]; /* palette is stored here as 256 32 bits words */\n<43> return size[0] + 256 * 4;\n<55> total_size = size[0];\n<57> for (i = 1; i < 4 && has_plane[i]; i++) {\n<61> data[i] = data[i-1] + size[i-1];\n<71> if (total_size > INT_MAX - size[i])\n<75> total_size += size[i];
<1> static void do_video_out(AVFormatContext *s,\n<3> OutputStream *ost,\n<97> if (format_video_sync == VSYNC_AUTO) {\n<99> if(!strcmp(s->oformat->name, "avi")) {\n<101> format_video_sync = VSYNC_VFR;\n<105> format_video_sync = (s->oformat->flags & AVFMT_VARIABLE_FPS) ? ((s->oformat->flags & AVFMT_NOTIMESTAMPS) ? VSYNC_PASSTHROUGH : VSYNC_VFR) : VSYNC_CFR;\n<237> sizeof(ost->last_nb0_frames[0]) * (FF_ARRAY_ELEMS(ost->last_nb0_frames) - 1));\n<313> if (!check_recording_time(ost))\n<353> write_frame(s, &pkt, ost);\n<491> ret = avcodec_encode_video2(enc, &pkt, in_picture, &got_packet);\n<547> write_frame(s, &pkt, ost);\n<553> if (ost->logfile && enc->stats_out) {\n<555> fprintf(ost->logfile, "%s", enc->stats_out);\n<581> do_video_stats(ost, frame_size);
<11> i < arrayLength ;\n<15> array [ idx ] = ( UChar * ) malloc ( sizeof ( UChar ) * size ) ;\n<17> udat_getSymbols ( fmt , type , idx + lowestIndex , array [ idx ] , size , status ) ;
<1> static int parse_traffic ( char * buf , int len , char * port , uint64_t * traffic ) {\n<3> char error_buf [ 512 ] ;\n<7> if ( data == NULL ) {\n<11> json_value * obj = json_parse_ex ( & settings , data , strlen ( data ) , error_buf ) ;\n<13> LOGE ( "%s" , error_buf ) ;\n<21> char * name = obj -> u . object . values [ i ] . name ;\n<23> if ( value -> type == json_integer ) {\n<24> strncpy ( port , name , 8 ) ;
<1> static int vmdk_create(const char *filename, QemuOpts *opts, Error **errp)\n<117> hw_version = qemu_opt_get_del(opts, BLOCK_OPT_HWVERSION);\n<119> if (qemu_opt_get_bool_del(opts, BLOCK_OPT_COMPAT6, false)) {\n<121> if (strcmp(hw_version, "undefined")) {\n<127> ret = -EINVAL;\n<133> g_free(hw_version);\n<135> hw_version = g_strdup("6");\n<139> if (strcmp(hw_version, "undefined") == 0) {\n<141> g_free(hw_version);\n<143> hw_version = g_strdup("4");\n<147> fmt = qemu_opt_get_del(opts, BLOCK_OPT_SUBFMT);\n<149> if (qemu_opt_get_bool_del(opts, BLOCK_OPT_ZEROED_GRAIN, false)) {\n<157> if (!adapter_type) {\n<159> adapter_type = g_strdup("ide");\n<161> } else if (strcmp(adapter_type, "ide") &&\n<163> strcmp(adapter_type, "buslogic") &&\n<165> strcmp(adapter_type, "lsilogic") &&\n<167> strcmp(adapter_type, "legacyESX")) {\n<169> error_setg(errp, "Unknown adapter type: '%s'", adapter_type);\n<171> ret = -EINVAL;\n<177> if (strcmp(adapter_type, "ide") != 0) {\n<183> number_heads = 255;\n<187> if (!fmt) {\n<191> fmt = g_strdup("monolithicSparse");\n<193> } else if (strcmp(fmt, "monolithicFlat") &&\n<195> strcmp(fmt, "monolithicSparse") &&\n<197> strcmp(fmt, "twoGbMaxExtentSparse") &&\n<199> strcmp(fmt, "twoGbMaxExtentFlat") &&\n<201> strcmp(fmt, "streamOptimized")) {\n<203> error_setg(errp, "Unknown subformat: '%s'", fmt);\n<205> ret = -EINVAL;\n<211> split = !(strcmp(fmt, "twoGbMaxExtentFlat") &&\n<213> strcmp(fmt, "twoGbMaxExtentSparse"));\n<215> flat = !(strcmp(fmt, "monolithicFlat") &&\n<217> strcmp(fmt, "twoGbMaxExtentFlat"));\n<219> compress = !strcmp(fmt, "streamOptimized");\n<221> if (flat) {\n<231> if (flat && backing_file) {\n<283> if (blk == NULL) {\n<291> if (strcmp(blk_bs(blk)->drv->format_name, "vmdk")) {\n<293> blk_unref(blk);\n<295> ret = -EINVAL;\n<301> parent_cid = vmdk_read_cid(blk_bs(blk), 0);\n<303> blk_unref(blk);\n<315> filesize = total_size;\n<317> while (filesize > 0) {\n<323> if (split && size > split_size) {\n<397> desc_len = strlen(desc);\n<401> if (!split && !flat) {\n<443> ret = blk_pwrite(new_blk, desc_offset, desc, desc_len, 0);\n<471> g_free(adapter_type);\n<475> g_free(hw_version);\n<477> g_free(fmt);\n<479> g_free(desc);
<1> static int mpegts_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n<61> ret = ff_mpegts_parse_packet(data->ts, pkt, buf, len);\n<73> if (ret < len) {\n<75> data->read_buf_size = FFMIN(len - ret, sizeof(data->buf));\n<77> memcpy(data->buf, buf + ret, data->read_buf_size);
<1> int SFFigureDefWidth ( SplineFont * sf , int * _nomwid ) {\n<13> if ( allsame ) {\n<18> if ( maxw > 65535 ) maxw = 3 * ( sf -> ascent + sf -> descent ) ;\n<19> widths = calloc ( maxw , sizeof ( uint16 ) ) ;\n<20> cumwid = calloc ( maxw , sizeof ( uint32 ) ) ;\n<25> ++ i ) if ( SCWorthOutputting ( sf -> glyphs [ i ] ) && sf -> glyphs [ i ] -> width >= 0 && sf -> glyphs [ i ] -> width < maxw ) if ( ++ widths [ sf -> glyphs [ i ] -> width ] > cnt ) {\n<27> cnt = widths [ defwid ] ;\n<29> widths [ defwid ] = 0 ;\n<34> ++ j ) if ( i + j >= 0 && i + j < maxw ) cumwid [ i ] += widths [ i + j ] ;\n<39> ++ i ) if ( cnt < cumwid [ i ] ) {\n<40> cnt = cumwid [ i ] ;\n<43> free ( widths ) ;\n<44> free ( cumwid ) ;
<1> static char * keep_pack ( const char * curr_index_name ) {\n<3> static const char * keep_msg = "fast-import" ;\n<6> if ( keep_fd < 0 ) die_errno ( "cannot create keep file" ) ;\n<7> write_or_die ( keep_fd , keep_msg , strlen ( keep_msg ) ) ;\n<8> if ( close ( keep_fd ) ) die_errno ( "failed to write keep file" ) ;\n<12> if ( finalize_object_file ( curr_index_name , name ) ) die ( "cannot store index file" ) ;\n<13> free ( ( void * ) curr_index_name ) ;
<1> static void hscroll ( AVCodecContext * avctx ) {\n<10> i < avctx -> height - s -> font_height ;\n<11> i ++ ) memcpy ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , s -> frame -> data [ 0 ] + ( i + s -> font_height ) * s -> frame -> linesize [ 0 ] , avctx -> width ) ;\n<13> i < avctx -> height ;\n<14> i ++ ) memset ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;
<1> static void vmsvga_fifo_run(struct vmsvga_state_s *s)\n<27> switch (cmd = vmsvga_fifo_read(s)) {\n<313> if (len < 0) {\n<325> printf("%s: Unknown command 0x%02x in SVGA command FIFO\n",
<1> static void test_view_where ( ) {\n<4> const char * query = "select v1.c,v2.c from v1, v2" ;\n<18> stmt = mysql_stmt_init ( mysql ) ;\n<19> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<20> check_execute ( stmt , rc ) ;
<1> static int remoteDispatchClientCall ( struct qemud_server * server , struct qemud_client * client , struct qemud_client_message * msg , bool qemu_protocol ) {\n<10> memset ( & args , 0 , sizeof args ) ;\n<11> memset ( & ret , 0 , sizeof ret ) ;\n<12> memset ( & rerr , 0 , sizeof rerr ) ;\n<14> remoteDispatchFormatError ( & rerr , _ ( "status (%d) != REMOTE_OK" ) , ( int ) msg -> hdr . status ) ;\n<19> remoteDispatchFormatError ( & rerr , "%s" , _ ( "authentication required" ) ) ;\n<26> remoteDispatchFormatError ( & rerr , _ ( "unknown procedure: %d" ) , msg -> hdr . proc ) ;\n<30> if ( ! ( ( data -> args_filter ) ( & xdr , & args ) ) ) {\n<32> remoteDispatchFormatError ( & rerr , "%s" , _ ( "parse args failed" ) ) ;\n<38> rv = ( data -> fn ) ( server , client , conn , & msg -> hdr , & rerr , & args , & ret ) ;\n<42> xdr_free ( data -> args_filter , ( char * ) & args ) ;\n<47> xdr_free ( data -> ret_filter , ( char * ) & ret ) ;\n<48> remoteDispatchFormatError ( & rerr , "%s" , _ ( "failed to serialize reply header" ) ) ;\n<53> remoteDispatchFormatError ( & rerr , "%s" , _ ( "failed to change XDR reply offset" ) ) ;\n<56> if ( ! ( ( data -> ret_filter ) ( & xdr , & ret ) ) ) {\n<57> remoteDispatchFormatError ( & rerr , "%s" , _ ( "failed to serialize reply payload (probable message size limit)" ) ) ;\n<63> remoteDispatchFormatError ( & rerr , "%s" , _ ( "failed to change XDR reply offset" ) ) ;\n<67> remoteDispatchFormatError ( & rerr , "%s" , _ ( "failed to update reply length header" ) ) ;\n<71> xdr_free ( data -> ret_filter , ( char * ) & ret ) ;\n<77> xdr_error : xdr_free ( data -> ret_filter , ( char * ) & ret ) ;\n<80> rpc_error : rv = remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
<1> static int vc1_decode_i_block_adv(VC1Context *v, DCTELEM block[64], int n, int coded, int codingset, int mquant)\n<135> ac_val2 = ac_val;\n<145> ac_val -= 16;\n<149> ac_val -= 16 * s->block_wrap[n];\n<163> if(coded) {\n<289> memset(ac_val2, 0, 16 * 2);\n<293> if(use_pred) {\n<295> memcpy(ac_val2, ac_val, 8 * 2);\n<305> ac_val2[k] = (ac_val2[k] * q2 * vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<313> if(use_pred) {\n<315> memcpy(ac_val2 + 8, ac_val + 8, 8 * 2);\n<325> ac_val2[k + 8] = (ac_val2[k + 8] * q2 * vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<343> block[k << 3] = ac_val2[k] * scale;\n<355> block[k] = ac_val2[k + 8] * scale;
<1> static void cin_decode_rle ( const unsigned char * src , int src_size , unsigned char * dst , int dst_size ) {\n<6> code = * src ++ ;\n<7> if ( code & 0x80 ) {\n<9> memset ( dst , * src ++ , FFMIN ( len , dst_end - dst ) ) ;\n<13> memcpy ( dst , src , FFMIN ( len , dst_end - dst ) ) ;\n<14> src += len ;\n<16> dst += len ;
<1> static void vhost_scsi_realize(DeviceState *dev, Error **errp)\n<43> if (vhostfd < 0) {\n<45> error_setg(errp, "vhost-scsi: open vhost char device failed: %s",\n<47> strerror(errno));\n<88> if (ret < 0) {\n<90> error_setg(errp, "vhost-scsi: vhost initialization failed: %s",\n<92> strerror(-ret));
<1> static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<139> if (w != avctx->width || h != avctx->height)\n<141> avcodec_set_dimensions(avctx, w, h);\n<157> ptr    = p->data[0];\n<203> for (y=0; y<h; y++, ptr+=stride) {\n<205> buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n<207> memcpy(ptr, scanline, w);\n<325> av_free(scanline);
<1> static void nameserver_read ( struct nameserver * ns ) {\n<4> socklen_t addrlen = sizeof ( ss ) ;\n<8> const int r = recvfrom ( ns -> socket , packet , sizeof ( packet ) , 0 , ( struct sockaddr * ) & ss , & addrlen ) ;\n<9> if ( r < 0 ) {\n<10> int err = last_error ( ns -> socket ) ;\n<11> if ( error_is_eagain ( err ) ) return ;\n<12> nameserver_failed ( ns , strerror ( err ) ) ;\n<15> if ( ! address_is_correct ( ns , ( struct sockaddr * ) & ss , addrlen ) ) {\n<19> ns -> timedout = 0 ;\n<20> reply_parse ( packet , r ) ;
<1> static inline void set_unused_field_bp ( unsigned char * bp , int from , int to ) {\n<2> memset ( bp + from , 0 , to - from + 1 ) ;
<1> int EvaluatePS ( char * str , real * stack , int size ) {\n<4> memset ( & ec , '\0' , sizeof ( ec ) ) ;\n<5> memset ( & rs , '\0' , sizeof ( rs ) ) ;\n<8> InterpretPS ( NULL , str , & ec , & rs ) ;
<1> static char * parse_ident ( const char * buf ) {\n<8> if ( ltgt != buf && ltgt [ - 1 ] != ' ' ) die ( "Missing space before < in ident string: %s" , buf ) ;\n<12> if ( * ltgt != ' ' ) die ( "Missing space after > in ident string: %s" , buf ) ;\n<14> name_len = ltgt - buf ;\n<16> switch ( whenspec ) {\n<21> case WHENSPEC_NOW : if ( strcmp ( "now" , ltgt ) ) die ( "Date in ident must be 'now': %s" , buf ) ;
<1> static void http_bad_header_test ( void ) {\n<3> fprintf ( stdout , "Testing HTTP Header filtering: " ) ;\n<5> if ( evhttp_add_header ( & headers , "One" , "Two" ) != 0 ) goto fail ;\n<6> if ( evhttp_add_header ( & headers , "One\r" , "Two" ) != - 1 ) goto fail ;\n<7> if ( evhttp_add_header ( & headers , "One" , "Two" ) != 0 ) goto fail ;\n<8> if ( evhttp_add_header ( & headers , "One" , "Two\r\n Three" ) != 0 ) goto fail ;\n<9> if ( evhttp_add_header ( & headers , "One\r" , "Two" ) != - 1 ) goto fail ;\n<10> if ( evhttp_add_header ( & headers , "One\n" , "Two" ) != - 1 ) goto fail ;\n<11> if ( evhttp_add_header ( & headers , "One" , "Two\r" ) != - 1 ) goto fail ;\n<12> if ( evhttp_add_header ( & headers , "One" , "Two\n" ) != - 1 ) goto fail ;\n<14> fprintf ( stdout , "OK\n" ) ;\n<16> fail : fprintf ( stdout , "FAILED\n" ) ;
<1> gpg_error_t keydb_search_next ( KEYDB_HANDLE hd ) {\n<5> memset ( & desc , 0 , sizeof desc ) ;\n<7> err = keydb_search ( hd , & desc , 1 , NULL ) ;\n<9> while ( gpg_err_code ( err ) == GPG_ERR_LEGACY_KEY ) ;
<1> int qemuMonitorTextGetStatus ( qemuMonitorPtr mon , bool * running , virDomainPausedReason * reason ) {\n<5> if ( qemuMonitorHMPCommand ( mon , "info status" , & reply ) < 0 ) {\n<9> if ( strstr ( reply , "running" ) ) {\n<10> * running = true ;\n<12> else if ( strstr ( reply , "paused" ) ) {\n<14> if ( ( status = strchr ( reply , '(' ) ) ) {\n<15> char * end = strchr ( status , ')' ) ;\n<16> if ( end ) * end = '\0' ;\n<19> if ( ! status ) VIR_DEBUG ( "info status was missing status details" ) ;\n<21> * running = false ;\n<24> qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( "unexpected reply from info status: %s" ) , reply ) ;\n<27> ret = 0 ;\n<28> cleanup : VIR_FREE ( reply ) ;
<1> const char * trunc_right ( const char * src , size_t width ) {\n<4> sl = strlen ( src ) ;\n<5> if ( sl > width && LIB_BUFLENGTH - 1 > width && width > 0 ) {\n<6> LIB_GETBUF ( out ) ;\n<7> memcpy ( out , src , width ) ;\n<9> return out ;\n<11> return src ;
<1> static void qpeg_decode_inter(const uint8_t *src, uint8_t *dst, int size,\n<3> int stride, int width, int height,\n<19> if(!refdata)\n<21> refdata= dst;\n<27> for(i = 0; i < height; i++)\n<29> memcpy(dst + (i * stride), refdata + (i * stride), width);\n<107> if ((me_x + filled < 0) || (me_x + me_w + filled > width) ||\n<111> (filled + me_w > width) || (height - me_h < 0))\n<165> if(filled >= width) {\n<191> if(filled >= width) {\n<235> while( filled >= width) {\n<261> if(filled >= width) {
<1> int ff_snow_frame_start(SnowContext *s){\n<47> memmove(s->halfpel_plane+1, s->halfpel_plane, (s->max_ref_frames-1)*sizeof(void*)*4*4);\n<51> halfpel_interpol(s, s->halfpel_plane[0], &s->current_picture);
<1> static int com_tee ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) ) {\n<3> if ( status . batch ) return 0 ;\n<4> while ( my_isspace ( charset_info , * line ) ) line ++ ;\n<5> if ( ! ( param = strchr ( line , ' ' ) ) ) {\n<6> if ( ! strlen ( outfile ) ) {\n<7> printf ( "No previous outfile available, you must give a filename!\n" ) ;\n<8> return 0 ;\n<10> else if ( opt_outfile ) {\n<11> tee_fprintf ( stdout , "Currently logging to file '%s'\n" , outfile ) ;\n<14> else param = outfile ;\n<16> while ( my_isspace ( charset_info , * param ) ) param ++ ;\n<17> end = strmake_buf ( file_name , param ) ;\n<18> while ( end > file_name && ( my_isspace ( charset_info , end [ - 1 ] ) || my_iscntrl ( charset_info , end [ - 1 ] ) ) ) end -- ;\n<19> end [ 0 ] = 0 ;\n<20> if ( end == file_name ) {\n<21> printf ( "No outfile specified!\n" ) ;
<1> static ssize_t local_readlink(FsContext *fs_ctx, const char *path,\n<3> char *buf, size_t bufsz)\n<31> } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n<33> tsize = readlink(rpath(fs_ctx, path), buf, bufsz);\n<37> return tsize;
<1> static int tipc_nl_compat_handle ( struct tipc_nl_compat_msg * msg ) {\n<4> memset ( & dump , 0 , sizeof ( dump ) ) ;\n<5> memset ( & doit , 0 , sizeof ( doit ) ) ;\n<13> return tipc_nl_compat_dumpit ( & dump , msg ) ;\n<17> return tipc_nl_compat_doit ( & doit , msg ) ;\n<21> return tipc_nl_compat_doit ( & doit , msg ) ;\n<27> return tipc_nl_compat_dumpit ( & dump , msg ) ;\n<32> return tipc_nl_compat_dumpit ( & dump , msg ) ;\n<36> return tipc_nl_compat_doit ( & doit , msg ) ;\n<40> return tipc_nl_compat_doit ( & doit , msg ) ;\n<47> return tipc_nl_compat_dumpit ( & dump , msg ) ;\n<52> return tipc_nl_compat_dumpit ( & dump , msg ) ;\n<56> return tipc_nl_compat_dumpit ( & dump , msg ) ;\n<60> return tipc_nl_compat_dumpit ( & dump , msg ) ;\n<64> return tipc_nl_compat_doit ( & doit , msg ) ;\n<68> return tipc_nl_compat_doit ( & doit , msg ) ;\n<72> return tipc_nl_compat_dumpit ( & dump , msg ) ;
<1> static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s , AVFrame * frame ) {\n<4> pix = bytestream2_get_byte ( & s -> stream_ptr ) ;\n<6> y < 8 ;\n<8> memset ( s -> pixel_ptr , pix , 8 ) ;\n<9> s -> pixel_ptr += s -> stride ;
<1> static int main_set_secondary_flags ( xd3_config * config ) {\n<4> if ( option_secondary == NULL ) {\n<10> if ( strcmp ( option_secondary , "fgk" ) == 0 && SECONDARY_FGK ) {\n<11> config -> flags |= XD3_SEC_FGK ;\n<13> else if ( strcmp ( option_secondary , "lzma" ) == 0 && SECONDARY_LZMA ) {\n<14> config -> flags |= XD3_SEC_LZMA ;\n<16> else if ( strncmp ( option_secondary , "djw" , 3 ) == 0 && SECONDARY_DJW ) {\n<19> if ( strlen ( option_secondary ) > 3 && ( ret = main_atou ( option_secondary + 3 , & level , 0 , 9 , 'S' ) ) != 0 && ! option_quiet ) {\n<20> return XD3_INVALID ;\n<22> if ( level < 1 ) {\n<25> if ( level < 7 ) {\n<31> if ( level < 3 ) {\n<34> if ( level < 8 ) {\n<40> if ( level < 5 ) {\n<43> if ( level < 9 ) {\n<50> else if ( strcmp ( option_secondary , "none" ) == 0 && SECONDARY_DJW ) {\n<53> if ( ! option_quiet ) {\n<60> return 0 ;
<1> static inline void take_option ( char * * to , char * from , int * first , int len ) {\n<3> * * to = ',' ;\n<4> * to += 1 ;\n<7> memcpy ( * to , from , len ) ;\n<8> * to += len ;
<1> static void final_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n<3> hb_glyph_info_t * info = buffer -> info ;\n<40> if ( is_halant_or_coeng ( info [ new_pos ] ) && info [ new_pos ] . indic_position ( ) != POS_PRE_M ) {\n<41> if ( new_pos + 1 < end && is_joiner ( info [ new_pos + 1 ] ) ) new_pos ++ ;\n<48> i -- ) if ( info [ i - 1 ] . indic_position ( ) == POS_PRE_M ) {\n<50> hb_glyph_info_t tmp = info [ old_pos ] ;\n<51> memmove ( & info [ old_pos ] , & info [ old_pos + 1 ] , ( new_pos - old_pos ) * sizeof ( info [ 0 ] ) ) ;\n<52> info [ new_pos ] = tmp ;\n<67> if ( start + 1 < end && info [ start ] . indic_position ( ) == POS_RA_TO_BECOME_REPH && ( ( info [ start ] . indic_category ( ) == OT_Repha ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ start ] ) ) ) {\n<115> memmove ( & info [ start ] , & info [ start + 1 ] , ( new_reph_pos - start ) * sizeof ( info [ 0 ] ) ) ;\n<125> if ( _hb_glyph_info_substituted ( & info [ i ] ) && ( ( pref_len == 1 ) ^ _hb_glyph_info_ligated_and_didnt_multiply ( & info [ i ] ) ) ) {\n<140> if ( new_pos < end && is_joiner ( info [ new_pos ] ) ) new_pos ++ ;\n<145> hb_glyph_info_t tmp = info [ old_pos ] ;\n<146> memmove ( & info [ new_pos + 1 ] , & info [ new_pos ] , ( old_pos - new_pos ) * sizeof ( info [ 0 ] ) ) ;
<1> static int scsi_disk_emulate_inquiry(SCSIRequest *req, uint8_t *outbuf)\n<5> SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n<27> outbuf[buflen++] = 0x00;\n<33> switch (page_code) {\n<73> if (!s->serial) {\n<83> l = strlen(s->serial);\n<85> if (l > 20) {\n<87> l = 20;\n<97> memcpy(outbuf+buflen, s->serial, l);\n<99> buflen += l;\n<111> const char *str = s->serial ?: bdrv_get_device_name(s->qdev.conf.bs);\n<115> int id_len = strlen(str);\n<119> if (id_len > max_len) {\n<121> id_len = max_len;\n<137> outbuf[buflen++] = id_len; // length of data following\n<139> memcpy(outbuf+buflen, str, id_len);\n<141> buflen += id_len;\n<183> if (s->qdev.type == TYPE_ROM) {\n<197> memset(outbuf + 4, 0, buflen - 4);\n<273> if (req->cmd.buf[2] != 0) {\n<285> if (buflen > SCSI_MAX_INQUIRY_LEN) {\n<287> buflen = SCSI_MAX_INQUIRY_LEN;\n<291> memset(outbuf, 0, buflen);\n<301> strpadcpy((char *) &outbuf[16], 16, s->product, ' ');\n<303> strpadcpy((char *) &outbuf[8], 8, s->vendor, ' ');\n<307> memset(&outbuf[32], 0, 4);\n<309> memcpy(&outbuf[32], s->version, MIN(4, strlen(s->version)));\n<329> if (buflen > 36) {
<1> static int parse_picture_segment(AVCodecContext *avctx,\n<27> picture_id = bytestream_get_be16(&buf);\n<33> buf++;\n<39> sequence_desc = bytestream_get_byte(&buf);\n<47> if (buf_size > ctx->pictures[picture_id].rle_remaining_len)\n<53> memcpy(ctx->pictures[picture_id].rle + ctx->pictures[picture_id].rle_data_len, buf, buf_size);\n<55> ctx->pictures[picture_id].rle_data_len += buf_size;\n<57> ctx->pictures[picture_id].rle_remaining_len -= buf_size;\n<77> rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n<83> width  = bytestream_get_be16(&buf);\n<85> height = bytestream_get_be16(&buf);\n<101> if (buf_size > rle_bitmap_len) {\n<117> av_fast_malloc(&ctx->pictures[picture_id].rle, &ctx->pictures[picture_id].rle_buffer_size, rle_bitmap_len);\n<121> if (!ctx->pictures[picture_id].rle)\n<127> memcpy(ctx->pictures[picture_id].rle, buf, buf_size);\n<129> ctx->pictures[picture_id].rle_data_len      = buf_size;\n<131> ctx->pictures[picture_id].rle_remaining_len = rle_bitmap_len - buf_size;
<1> static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) {\n<2> size_t bufsz = strlen ( root ) + sizeof ( "/sys/fs/cgroup" ) ;\n<4> char * * parts = NULL ;\n<5> char * dirname = NULL ;\n<6> char * abs_path = NULL ;\n<7> char * abs_path2 = NULL ;\n<16> if ( type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED ) {\n<21> path = calloc ( 1 , bufsz ) ;\n<22> if ( ! path ) return false ;\n<23> snprintf ( path , bufsz , "%s/sys/fs/cgroup" , root ) ;\n<24> r = safe_mount ( "cgroup_root" , path , "tmpfs" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , "size=10240k,mode=755" , root ) ;\n<30> info ;\n<34> if ( ! mp ) mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ;\n<35> if ( ! mp ) {\n<39> subsystem_count = lxc_array_len ( ( void * * ) info -> hierarchy -> subsystems ) ;\n<40> parts = calloc ( subsystem_count + 1 , sizeof ( char * ) ) ;\n<41> if ( ! parts ) goto out_error ;\n<45> if ( ! strncmp ( info -> hierarchy -> subsystems [ i ] , "name=" , 5 ) ) parts [ i ] = info -> hierarchy -> subsystems [ i ] + 5 ;\n<46> else parts [ i ] = info -> hierarchy -> subsystems [ i ] ;\n<49> if ( ! dirname ) goto out_error ;\n<50> abs_path = lxc_append_paths ( path , dirname ) ;\n<51> if ( ! abs_path ) goto out_error ;\n<52> r = mkdir_p ( abs_path , 0755 ) ;\n<53> if ( r < 0 && errno != EEXIST ) {\n<54> SYSERROR ( "could not create cgroup subsystem directory /sys/fs/cgroup/%s" , dirname ) ;\n<57> abs_path2 = lxc_append_paths ( abs_path , info -> cgroup_path ) ;\n<58> if ( ! abs_path2 ) goto out_error ;\n<59> if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n<60> if ( strcmp ( mp -> mount_prefix , "/" ) != 0 ) {\n<61> ERROR ( "could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup" , dirname ) ;\n<64> r = mount ( mp -> mount_point , abs_path , "none" , MS_BIND , 0 ) ;\n<65> if ( r < 0 ) {\n<66> SYSERROR ( "error bind-mounting %s to %s" , mp -> mount_point , abs_path ) ;\n<70> r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n<71> if ( r < 0 ) {\n<72> SYSERROR ( "error re-mounting %s readonly" , abs_path ) ;\n<76> if ( type == LXC_AUTO_CGROUP_FULL_MIXED ) {\n<78> if ( r < 0 ) {\n<79> SYSERROR ( "error bind-mounting %s onto itself" , abs_path2 ) ;\n<82> r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND , NULL ) ;\n<83> if ( r < 0 ) {\n<84> SYSERROR ( "error re-mounting %s readwrite" , abs_path2 ) ;\n<90> r = mkdir_p ( abs_path2 , 0755 ) ;\n<91> if ( r < 0 && errno != EEXIST ) {\n<92> SYSERROR ( "could not create cgroup directory /sys/fs/cgroup/%s%s" , dirname , info -> cgroup_path ) ;\n<95> if ( type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO ) {\n<97> if ( r < 0 ) {\n<98> SYSERROR ( "error bind-mounting %s onto itself" , abs_path ) ;\n<101> r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n<102> if ( r < 0 ) {\n<103> SYSERROR ( "error re-mounting %s readonly" , abs_path ) ;\n<107> free ( abs_path ) ;\n<109> abs_path = cgroup_to_absolute_path ( mp , info -> cgroup_path , NULL ) ;\n<110> if ( ! abs_path ) goto out_error ;\n<111> r = mount ( abs_path , abs_path2 , "none" , MS_BIND , 0 ) ;\n<112> if ( r < 0 ) {\n<113> SYSERROR ( "error bind-mounting %s to %s" , abs_path , abs_path2 ) ;\n<116> if ( type == LXC_AUTO_CGROUP_RO ) {\n<117> r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ;\n<118> if ( r < 0 ) {\n<119> SYSERROR ( "error re-mounting %s readonly" , abs_path2 ) ;\n<124> free ( abs_path ) ;\n<125> free ( abs_path2 ) ;\n<126> abs_path = NULL ;\n<127> abs_path2 = NULL ;\n<128> if ( subsystem_count > 1 ) {\n<130> i < subsystem_count ;\n<132> abs_path = lxc_append_paths ( path , parts [ i ] ) ;\n<133> if ( ! abs_path ) goto out_error ;\n<134> r = symlink ( dirname , abs_path ) ;\n<135> if ( r < 0 ) WARN ( "could not create symlink %s -> %s in /sys/fs/cgroup of container" , parts [ i ] , dirname ) ;\n<136> free ( abs_path ) ;\n<137> abs_path = NULL ;\n<140> free ( dirname ) ;\n<141> free ( parts ) ;\n<142> dirname = NULL ;\n<143> parts = NULL ;\n<145> free ( path ) ;\n<147> out_error : saved_errno = errno ;\n<148> free ( path ) ;\n<149> free ( dirname ) ;\n<150> free ( parts ) ;\n<151> free ( abs_path ) ;\n<152> free ( abs_path2 ) ;\n<153> errno = saved_errno ;\n<154> return false ;
<1> static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n<25> if (mem == NULL) {\n<35> if (!d.dirty_bitmap) {\n<37> d.dirty_bitmap = qemu_malloc(size);\n<39> } else if (size > allocated_size) {\n<41> d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n<45> allocated_size = size;\n<47> memset(d.dirty_bitmap, 0, allocated_size);\n<51> d.slot = mem->slot;\n<55> if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n<67> kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n<75> qemu_free(d.dirty_bitmap);
<1> int main ( int argc , char * * argv ) {\n<2> int frame_cnt = 0 ;\n<12> if ( ! ( outfile = fopen ( argv [ 2 ] , "wb" ) ) ) die ( "Failed to open %s for writing." , argv [ 2 ] ) ;\n<13> info = vpx_video_reader_get_info ( reader ) ;\n<16> printf ( "Using %s\n" , vpx_codec_iface_name ( decoder -> codec_interface ( ) ) ) ;\n<26> ++ frame_cnt ;\n<29> printf ( "Processed %d frames.\n" , frame_cnt ) ;\n<31> printf ( "Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\n" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ;
<1> static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<7> NellyMoserEncodeContext *s = avctx->priv_data;\n<13> if (s->last_frame)\n<19> memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));\n<21> if (frame) {\n<23> memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],\n<25> frame->nb_samples * sizeof(*s->buf));\n<27> if (frame->nb_samples < NELLY_SAMPLES) {\n<29> memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,\n<31> (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));\n<45> memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));\n<61> encode_block(s, avpkt->data, avpkt->size);
<1> static const char * ContentTypeForFilename ( const char * filename , const char * prevtype ) {\n<28> i < sizeof ( ctts ) / sizeof ( ctts [ 0 ] ) ;\n<29> i ++ ) {\n<30> if ( strlen ( filename ) >= strlen ( ctts [ i ] . extension ) ) {\n<31> if ( strequal ( filename + strlen ( filename ) - strlen ( ctts [ i ] . extension ) , ctts [ i ] . extension ) ) {\n<32> contenttype = ctts [ i ] . type ;
<1> void hmp_pci_add(Monitor *mon, const QDict *qdict)\n<9> const char *type = qdict_get_str(qdict, "type");\n<17> if (!strncmp(pci_addr, "pci_addr=", 9)) {\n<19> pci_addr += 9;\n<33> if (!strcmp(pci_addr, "auto"))\n<35> pci_addr = NULL;\n<39> if (strcmp(type, "nic") == 0) {\n<41> dev = qemu_pci_hot_add_nic(mon, pci_addr, opts);\n<43> } else if (strcmp(type, "storage") == 0) {\n<45> dev = qemu_pci_hot_add_storage(mon, pci_addr, opts);\n<49> monitor_printf(mon, "invalid type: %s\n", type);
<1> static const char * cmd_rule_update_action_by_id ( cmd_parms * cmd , void * _dcfg , const char * p1 , const char * p2 ) {\n<2> int offset = 0 , rule_id = atoi ( p1 ) ;\n<3> char * opt = strchr ( p1 , ':' ) ;\n<5> char * param = apr_pstrdup ( cmd -> pool , p1 ) ;\n<9> if ( opt != NULL ) {
<1> static void test_evbuffer_readln ( void ) {\n<8> fprintf ( stdout , "FAILED\n" ) ;
<1> static int kvm_put_fpu ( X86CPU * cpu ) {\n<2> CPUX86State * env = & cpu -> env ;\n<5> memset ( & fpu , 0 , sizeof fpu ) ;\n<17> memcpy ( fpu . fpr , env -> fpregs , sizeof env -> fpregs ) ;\n<25> return kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_SET_FPU , & fpu ) ;
<1> int tm_init ( void * info , struct tm_roots * roots ) {\n<7> if ( init_done ) {\n<10> if ( ( tm_jobid = getenv ( "PBS_JOBID" ) ) == NULL ) {\n<11> return ( TM_EBADENVIRONMENT ) ;\n<13> tm_jobid_len = strlen ( tm_jobid ) ;\n<14> if ( ( tm_jobcookie = getenv ( "PBS_JOBCOOKIE" ) ) == NULL ) return TM_EBADENVIRONMENT ;\n<15> tm_jobcookie_len = strlen ( tm_jobcookie ) ;\n<16> if ( ( env = getenv ( "PBS_NODENUM" ) ) == NULL ) return TM_EBADENVIRONMENT ;\n<17> tm_jobndid = ( tm_node_id ) strtol ( env , & hold , 10 ) ;\n<18> if ( env == hold ) return TM_EBADENVIRONMENT ;\n<19> if ( ( env = getenv ( "PBS_TASKNUM" ) ) == NULL ) return TM_EBADENVIRONMENT ;\n<20> if ( ( tm_jobtid = atoi ( env ) ) == 0 ) return TM_EBADENVIRONMENT ;\n<21> if ( ( env = getenv ( "PBS_MOMPORT" ) ) == NULL ) return TM_EBADENVIRONMENT ;\n<22> if ( ( tm_momport = atoi ( env ) ) == 0 ) return TM_EBADENVIRONMENT ;
<5> MimicContext *dst = avctx->priv_data, *src = avctx_from->priv_data;\n<11> if (avctx == avctx_from)\n<23> memcpy(dst->flipped_ptrs, src->flipped_ptrs, sizeof(src->flipped_ptrs));
<1> static int theora_header(AVFormatContext *s, int idx)\n<4> struct ogg_stream *os = ogg->streams + idx;\n<10> if (!(os->buf[os->pstart] & 0x80))\n<83> *cdp++ = os->psize & 0xff;\n<84> memcpy(cdp, os->buf + os->pstart, os->psize);
<1> static int rd_frame(CinepakEncContext *s, const AVFrame *frame, int isakeyframe, unsigned char *buf, int buf_size)\n<157> get_sub_picture(s, 0, y, (AVPicture*)s->input_frame,    &pict);\n<161> get_sub_picture(s, 0, y, (AVPicture*)frame,              &pict);\n<163> get_sub_picture(s, 0, y, (AVPicture*)s->last_frame,    &last_pict);\n<165> get_sub_picture(s, 0, y, (AVPicture*)s->scratch_frame, &scratch_pict);\n<169> if((temp_size = rd_strip(s, y, strip_height, isakeyframe, &last_pict, &pict, &scratch_pict, s->frame_buf + size + CVID_HEADER_SIZE, &score_temp\n<201> if(best_score == 0 || score < best_score) {\n<211> best_size = size + write_cvid_header(s, s->frame_buf, num_strips, size, isakeyframe);\n<225> memcpy(buf, s->frame_buf, best_size);\n<289> return best_size;
<1> static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,\n<33> buf = av_buffer_alloc(avpkt->size);\n<35> if (buf) {\n<37> memcpy(buf->data, avpkt->data, avpkt->size);\n<41> data = buf->data;\n<47> if (!buf) {\n<143> buffer->ref = av_buffer_ref(buf);\n<177> av_buffer_unref(&buf);
<1> static void icc_conv_pixmap ( fz_context * ctx , fz_pixmap * dst , fz_pixmap * src , fz_colorspace * prf , const fz_default_colorspaces * default_cs , const fz_color_params * color_params , int copy_spots ) {\n<23> inputpos = src -> samples ;\n<24> outputpos = dst -> samples ;\n<28> i < src -> h ;\n<30> memcpy ( outputpos , inputpos , src -> stride ) ;\n<31> inputpos = inputpos + src -> stride ;\n<32> outputpos = outputpos + dst -> stride ;
<1> static int test_in_memory ( xd3_stream * stream , int ignore ) {\n<2> uint8_t ibuf [ sizeof ( test_text ) ] ;\n<5> usize_t size = sizeof ( test_text ) ;\n<9> memcpy ( ibuf , test_text , size ) ;\n<10> memset ( ibuf + 128 , 0 , 16 ) ;\n<11> r1 = xd3_encode_memory ( ibuf , size , test_text , size , dbuf , & dsize , size , eflags ) ;\n<12> r2 = xd3_decode_memory ( dbuf , dsize , test_text , size , obuf , & osize , size , 0 ) ;\n<13> if ( r1 != 0 || r2 != 0 || dsize >= ( size / 2 ) || dsize < 1 || osize != size ) {\n<17> if ( memcmp ( obuf , ibuf , size ) != 0 ) {\n<18> stream -> msg = "encode/decode data error" ;\n<19> return XD3_INTERNAL ;\n<21> return 0 ;
<1> static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,\n<3> const uint8_t *buf, int size, int64_t pts)\n<11> StreamInfo *stream = st->priv_data;\n<55> while (size > 0) {\n<57> len = s->packet_data_max_size - stream->buffer_ptr;\n<59> if (len > size)\n<61> len = size;\n<63> memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n<65> stream->buffer_ptr += len;\n<67> buf += len;\n<69> size -= len;
<1> static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) {\n<2> size_t width = ( 79 - strlen ( prefix ) ) ;\n<8> if ( ! print_buffer ) return ;\n<9> len = strlen ( print_buffer ) ;\n<10> ptr = print_buffer ;\n<11> while ( len > 0 ) {\n<12> fputs ( prefix , config -> errors ) ;\n<13> if ( len > width ) {\n<29> curl_free ( print_buffer ) ;
<1> static int dvbsub_parse(AVCodecParserContext *s,\n<7> const uint8_t *buf, int buf_size)\n<11> DVBSubParseContext *pc = s->priv_data;\n<29> av_dlog(avctx, "%02x ", buf[i]);\n<73> pc->packet_index = 0;\n<77> if (buf_size < 2 || buf[0] != 0x20 || buf[1] != 0x00) {\n<99> if (pc->packet_index != pc->packet_start)\n<103> memmove(pc->packet_buf, pc->packet_buf + pc->packet_start,\n<105> pc->packet_index - pc->packet_start);\n<109> pc->packet_index -= pc->packet_start;\n<117> pc->packet_index = 0;\n<127> if (buf_size - buf_pos + pc->packet_index > PARSE_BUF_SIZE)\n<135> if (pc->in_packet == 0)\n<141> memcpy(pc->packet_buf + pc->packet_index, buf + buf_pos, buf_size - buf_pos);\n<147> p = pc->packet_buf;\n<149> p_end = pc->packet_buf + pc->packet_index;\n<197> pc->packet_index = p - pc->packet_buf;\n<209> pc->packet_index = p - pc->packet_buf;\n<225> *poutbuf = pc->packet_buf;
<1> void usage_exit ( ) {\n<2> fprintf ( stderr , "Usage: %s <width> <height> <infile> <outfile> <frame>\n" , exec_name ) ;
<1> void generate_filename ( const char * pattern , char * out , size_t q_len , unsigned int d_w , unsigned int d_h , unsigned int frame_in ) {\n<2> const char * p = pattern ;\n<3> char * q = out ;\n<5> char * next_pat = strchr ( p , '%' ) ;\n<6> if ( p == next_pat ) {\n<8> q [ q_len - 1 ] = '\0' ;\n<10> case 'w' : snprintf ( q , q_len - 1 , "%d" , d_w ) ;\n<12> case 'h' : snprintf ( q , q_len - 1 , "%d" , d_h ) ;\n<14> case '1' : snprintf ( q , q_len - 1 , "%d" , frame_in ) ;\n<16> case '2' : snprintf ( q , q_len - 1 , "%02d" , frame_in ) ;\n<18> case '3' : snprintf ( q , q_len - 1 , "%03d" , frame_in ) ;\n<20> case '4' : snprintf ( q , q_len - 1 , "%04d" , frame_in ) ;\n<22> case '5' : snprintf ( q , q_len - 1 , "%05d" , frame_in ) ;\n<24> case '6' : snprintf ( q , q_len - 1 , "%06d" , frame_in ) ;\n<26> case '7' : snprintf ( q , q_len - 1 , "%07d" , frame_in ) ;\n<28> case '8' : snprintf ( q , q_len - 1 , "%08d" , frame_in ) ;\n<30> case '9' : snprintf ( q , q_len - 1 , "%09d" , frame_in ) ;\n<32> default : die ( "Unrecognized pattern %%%c\n" , p [ 1 ] ) ;\n<35> pat_len = strlen ( q ) ;\n<36> if ( pat_len >= q_len - 1 ) die ( "Output filename too long.\n" ) ;\n<37> q += pat_len ;\n<38> p += 2 ;\n<43> if ( ! next_pat ) copy_len = strlen ( p ) ;\n<44> else copy_len = next_pat - p ;\n<45> if ( copy_len >= q_len - 1 ) die ( "Output filename too long.\n" ) ;\n<46> memcpy ( q , p , copy_len ) ;\n<47> q [ copy_len ] = '\0' ;\n<48> q += copy_len ;\n<49> p += copy_len ;\n<50> q_len -= copy_len ;\n<53> while ( * p ) ;
<1> static void usb_mtp_handle_data(USBDevice *dev, USBPacket *p)\n<45> MTPData *d = s->data_in;\n<95> rc = read(d->fd, d->data, dlen);\n<97> if (rc != dlen) {\n<99> memset(d->data, 0, dlen);\n<105> usb_packet_copy(p, d->data, dlen);
<1> static void _getObjectDescription ( PQExpBuffer buf , TocEntry * te , ArchiveHandle * AH ) {\n<2> const char * type = te -> desc ;\n<3> if ( strcmp ( type , "VIEW" ) == 0 || strcmp ( type , "SEQUENCE" ) == 0 || strcmp ( type , "MATERIALIZED VIEW" ) == 0 ) type = "TABLE" ;\n<4> if ( strcmp ( type , "COLLATION" ) == 0 || strcmp ( type , "CONVERSION" ) == 0 || strcmp ( type , "DOMAIN" ) == 0 || strcmp ( type , "TABLE" ) == 0 || strcmp ( type , "TYPE" ) == 0 || strcmp ( type , "FOREIGN TABLE" ) == 0 || strcmp ( type , "TEXT SEARCH DICTIONARY" ) == 0 || strcmp ( type , "TEXT SEARCH CONFIGURATION" ) == 0 || strcmp ( type , "DATABASE" ) == 0 || strcmp ( type , "PROCEDURAL LANGUAGE" ) == 0 || strcmp ( type , "SCHEMA" ) == 0 || strcmp ( type , "FOREIGN DATA WRAPPER" ) == 0 || strcmp ( type , "SERVER" ) == 0 || strcmp ( type , "USER MAPPING" ) == 0 ) {\n<5> appendPQExpBuffer ( buf , "%s %s" , type , fmtId ( te -> tag ) ) ;\n<6> return ;\n<8> if ( strcmp ( type , "BLOB" ) == 0 ) {\n<9> appendPQExpBuffer ( buf , "LARGE OBJECT %s" , te -> tag ) ;\n<10> return ;\n<12> if ( strcmp ( type , "AGGREGATE" ) == 0 || strcmp ( type , "FUNCTION" ) == 0 || strcmp ( type , "OPERATOR" ) == 0 || strcmp ( type , "OPERATOR CLASS" ) == 0 || strcmp ( type , "OPERATOR FAMILY" ) == 0 ) {\n<13> char * first = pg_strdup ( te -> dropStmt + 5 ) ;\n<15> last = first + strlen ( first ) - 1 ;\n<19> appendPQExpBufferStr ( buf , first ) ;\n<20> free ( first ) ;\n<21> return ;\n<23> write_msg ( modulename , "WARNING: don't know how to set owner for object type %s\n" , type ) ;
<1> void append_salt_to_key ( uint8_t * key , unsigned int bytes_in_key , uint8_t * salt , unsigned int bytes_in_salt ) {\n<2> memcpy ( key + bytes_in_key , salt , bytes_in_salt ) ;
<1> static void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,\n<27> if (!req) {\n<65> evt = req->resp.event;\n<67> memset(evt, 0, sizeof(VirtIOSCSIEvent));
<1> static int openfile(char *name, int flags, int growable, QDict *opts)\n<9> if (qemuio_bs) {\n<11> fprintf(stderr, "file open already, try 'help close'\n");\n<22> if (bdrv_open(&qemuio_bs, name, NULL, opts, flags | BDRV_O_PROTOCOL,\n<28> fprintf(stderr, "%s: can't open device %s: %s\n", progname, name,\n<30> error_get_pretty(local_err));\n<44> if (bdrv_open(&qemuio_bs, name, NULL, opts, flags, NULL, &local_err)\n<50> fprintf(stderr, "%s: can't open device %s: %s\n", progname, name,\n<52> error_get_pretty(local_err));
<1> static int kvm_ppc_register_host_cpu_type(void)\n<67> dc = DEVICE_CLASS(ppc_cpu_get_family_class(pvr_pcc));\n<69> for (i = 0; ppc_cpu_aliases[i].alias != NULL; i++) {\n<71> if (strcmp(ppc_cpu_aliases[i].alias, dc->desc) == 0) {\n<73> ObjectClass *oc = OBJECT_CLASS(pvr_pcc);\n<79> ppc_cpu_aliases[i].model = g_strdup(object_class_get_name(oc));\n<83> if (suffix) {\n<89> ppc_cpu_aliases[i].oc = oc;
<1> envlist_free(envlist_t *envlist)\n<9> assert(envlist != NULL);\n<13> while (envlist->el_entries.lh_first != NULL) {\n<17> QLIST_REMOVE(entry, ev_link);\n<21> free((char *)entry->ev_var);\n<23> free(entry);\n<27> free(envlist);
<1> static void test_bug27876 ( ) {\n<10> char query [ 500 ] ;\n<20> sprintf ( query , "DROP FUNCTION IF EXISTS %s" , ( char * ) utf8_func ) ;\n<21> rc = mysql_query ( mysql , query ) ;\n<23> sprintf ( query , "CREATE FUNCTION %s( %s VARCHAR(25))" " RETURNS VARCHAR(25) DETERMINISTIC RETURN %s" , ( char * ) utf8_func , ( char * ) utf8_param , ( char * ) utf8_param ) ;\n<24> rc = mysql_query ( mysql , query ) ;\n<26> sprintf ( query , "SELECT %s(VERSION())" , ( char * ) utf8_func ) ;\n<27> rc = mysql_query ( mysql , query ) ;\n<32> sprintf ( query , "DROP FUNCTION %s" , ( char * ) utf8_func ) ;\n<33> rc = mysql_query ( mysql , query ) ;
<1> static void get_object_list ( int ac , const char * * av ) {\n<7> setup_revisions ( ac , av , & revs , NULL ) ;\n<9> while ( fgets ( line , sizeof ( line ) , stdin ) != NULL ) {\n<10> int len = strlen ( line ) ;\n<11> if ( len && line [ len - 1 ] == '\n' ) line [ -- len ] = 0 ;\n<12> if ( ! len ) break ;\n<13> if ( * line == '-' ) {\n<14> if ( ! strcmp ( line , "--not" ) ) {\n<15> flags ^= UNINTERESTING ;\n<16> write_bitmap_index = 0 ;\n<19> if ( starts_with ( line , "--shallow " ) ) {\n<28> if ( handle_revision_arg ( line , & revs , flags , REVARG_CANNOT_BE_FILENAME ) ) die ( "bad revision '%s'" , line ) ;\n<33> traverse_commit_list ( & revs , show_commit , show_object , NULL ) ;
<1> static int string_to_crypto_cipher_type ( const char * crypto_cipher_type ) {\n<2> if ( strcmp ( crypto_cipher_type , "none" ) == 0 ) {\n<3> return CRYPTO_CIPHER_TYPE_NONE ;\n<5> else if ( strcmp ( crypto_cipher_type , "aes256" ) == 0 ) {\n<6> return CRYPTO_CIPHER_TYPE_AES256 ;\n<8> else if ( strcmp ( crypto_cipher_type , "aes192" ) == 0 ) {\n<9> return CRYPTO_CIPHER_TYPE_AES192 ;\n<11> else if ( strcmp ( crypto_cipher_type , "aes128" ) == 0 ) {\n<12> return CRYPTO_CIPHER_TYPE_AES128 ;\n<14> else if ( strcmp ( crypto_cipher_type , "3des" ) == 0 ) {\n<15> return CRYPTO_CIPHER_TYPE_3DES ;\n<17> return CRYPTO_CIPHER_TYPE_AES256 ;
<1> static void virtio_net_set_config ( VirtIODevice * vdev , const uint8_t * config ) {\n<2> VirtIONet * n = to_virtio_net ( vdev ) ;\n<4> memcpy ( & netcfg , config , sizeof ( netcfg ) ) ;\n<5> if ( memcmp ( netcfg . mac , n -> mac , ETH_ALEN ) ) {\n<6> memcpy ( n -> mac , netcfg . mac , ETH_ALEN ) ;\n<7> qemu_format_nic_info_str ( & n -> nic -> nc , n -> mac ) ;
<1> void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,\n<23> memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list));\n<47> derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,
<1> static const float * do_pitchfilter ( float memory [ 303 ] , const float v_in [ 160 ] , const float gain [ 4 ] , const uint8_t * lag , const uint8_t pfrac [ 4 ] ) {\n<5> v_out = memory + 143 ;\n<9> if ( gain [ i ] ) {\n<12> v_in < v_len ;\n<20> * v_out = * v_in + gain [ i ] * * v_out ;\n<22> v_out ++ ;\n<26> memcpy ( v_out , v_in , 40 * sizeof ( float ) ) ;\n<27> v_in += 40 ;\n<28> v_out += 40 ;\n<31> memmove ( memory , memory + 160 , 143 * sizeof ( float ) ) ;\n<32> return memory + 143 ;
<1> static int rv40_parse_slice_header ( RV34DecContext * r , GetBitContext * gb , SliceInfo * si ) {\n<5> memset ( si , 0 , sizeof ( SliceInfo ) ) ;\n<8> if ( si -> type == 1 ) si -> type = 0 ;\n<14> if ( ! si -> type || ! get_bits1 ( gb ) ) rv40_parse_picture_size ( gb , & w , & h ) ;
<1> static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<87> ptr    = p->data[0];\n<95> if (buf_end - buf < w * bytes_per_pixel)\n<109> memcpy(ptr, buf, w*bytes_per_pixel);\n<113> ptr += stride;\n<115> buf += w*bytes_per_pixel;
<1> void proto_register_packetbb ( void ) {\n<247> static gint * ett [ array_length ( ett_base ) + 2 * PACKETBB_MSG_TLV_LENGTH ] ;\n<251> memcpy ( ett , ett_base , sizeof ( ett_base ) ) ;\n<252> j = array_length ( ett_base ) ;\n<263> proto_register_subtree_array ( ett , array_length ( ett ) ) ;
<1> static uint64_t get_channel_layout_single(const char *name, int name_len)\n<13> for (i = 0; i < FF_ARRAY_ELEMS(channel_layout_map); i++) {\n<15> if (strlen(channel_layout_map[i].name) == name_len &&\n<17> !memcmp(channel_layout_map[i].name, name, name_len))\n<19> return channel_layout_map[i].layout;\n<25> if (channel_names[i].name &&\n<27> strlen(channel_names[i].name) == name_len &&\n<29> !memcmp(channel_names[i].name, name, name_len))\n<33> i = strtol(name, &end, 10);\n<37> if ((end + 1 - name == name_len && *end  == 'c'))
<1> void configure_icount(const char *option)\n<7> if (!option)\n<21> if (strcmp(option, "auto") != 0) {\n<23> icount_time_shift = strtol(option, NULL, 0);\n<25> use_icount = 1;\n<27> return;\n<33> use_icount = 2;\n<41> icount_time_shift = 3;\n<55> icount_rt_timer = qemu_new_timer_ms(rt_clock, icount_adjust_rt, NULL);\n<59> qemu_get_clock_ms(rt_clock) + 1000);\n<61> icount_vm_timer = qemu_new_timer_ns(vm_clock, icount_adjust_vm, NULL);\n<65> qemu_get_clock_ns(vm_clock) + get_ticks_per_sec() / 10);
<1> int test_div_recp ( BIO * bp , BN_CTX * ctx ) {\n<46> if ( ! BN_is_zero ( & d ) ) {\n<47> fprintf ( stderr , "Reciprocal division test failed!\n" ) ;\n<48> fprintf ( stderr , "a=" ) ;\n<49> BN_print_fp ( stderr , & a ) ;\n<50> fprintf ( stderr , "\nb=" ) ;\n<51> BN_print_fp ( stderr , & b ) ;\n<52> fprintf ( stderr , "\n" ) ;
<1> static int decode_frame_byterun1(AVCodecContext *avctx,\n<9> IffContext *s = avctx->priv_data;\n<27> if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n<35> } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n<43> if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n<57> for(y = 0; y < avctx->height ; y++ ) {\n<59> uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n<61> memset(row, 0, avctx->width);\n<67> decodeplane8(row, s->planebuf, s->planesize, plane);\n<75> for (y = 0; y < avctx->height ; y++) {\n<79> memset(s->ham_buf, 0, avctx->width);\n<85> decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);\n<89> decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n<95> for(y = 0; y < avctx->height ; y++ ) {\n<97> uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n<99> memset(row, 0, avctx->width << 2);\n<105> decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);
<1> static int fetch_db_collation ( const char * db_name , char * db_cl_name , int db_cl_size ) {\n<15> if ( ! ( db_cl_row = mysql_fetch_row ( db_cl_res ) ) ) {\n<19> strncpy ( db_cl_name , db_cl_row [ 0 ] , db_cl_size - 1 ) ;\n<20> db_cl_name [ db_cl_size - 1 ] = 0 ;
<1> static int av_encode(AVFormatContext **output_files,\n<53> fprintf(stderr, "Number of stream maps must match number of output streams\n");\n<56> int fi = stream_maps[i].file_index;\n<57> int si = stream_maps[i].stream_index;\n<60> fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si);
<1> static int set_directory_record_rr ( unsigned char * bp , int dr_len , struct isoent * isoent , struct iso9660 * iso9660 , enum dir_rec_type t ) {\n<34> bp [ 1 ] = 'S' ;\n<35> bp [ 2 ] = 'P' ;\n<37> bp [ 4 ] = 1 ;\n<39> bp [ 6 ] = 0xEF ;\n<40> bp [ 7 ] = 0 ;\n<48> bp [ 1 ] = 'R' ;\n<49> bp [ 2 ] = 'R' ;\n<51> bp [ 4 ] = 1 ;\n<57> size_t nmlen = file -> basename . length ;\n<58> const char * nm = file -> basename . s ;\n<62> bp [ 1 ] = 'N' ;\n<63> bp [ 2 ] = 'M' ;\n<64> bp [ 4 ] = 1 ;\n<70> if ( bp != NULL ) {\n<71> bp [ 3 ] = length ;\n<72> bp [ 5 ] = 0x01 ;\n<73> memcpy ( bp + 6 , nm , length - 5 ) ;\n<76> nmlen -= length - 5 ;\n<77> nm += length - 5 ;\n<85> bp [ 1 ] = 'N' ;\n<86> bp [ 2 ] = 'M' ;\n<87> bp [ 4 ] = 1 ;\n<91> if ( bp != NULL ) {\n<92> bp [ 3 ] = length ;\n<93> bp [ 5 ] = 0 ;\n<94> memcpy ( bp + 6 , nm , nmlen ) ;
<1> static int set_hwframe_ctx(AVCodecContext *ctx, AVBufferRef *hw_device_ctx)\n<13> if (!(hw_frames_ref = av_hwframe_ctx_alloc(hw_device_ctx))) {\n<15> fprintf(stderr, "Failed to create VAAPI frame context.\n");\n<33> if ((err = av_hwframe_ctx_init(hw_frames_ref)) < 0) {\n<35> fprintf(stderr, "Failed to initialize VAAPI frame context."\n<37> "Error code: %s\n",av_err2str(err));
<1> iscsi_aio_readv(BlockDriverState *bs, int64_t sector_num,\n<33> trace_iscsi_aio_readv(iscsi, sector_num, nb_sectors, opaque, acb);\n<85> acb->task = malloc(sizeof(struct scsi_task));\n<87> if (acb->task == NULL) {\n<99> memset(acb->task, 0, sizeof(struct scsi_task));\n<143> if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,
<1> static struct matrix build_mAB_matrix ( struct lutmABType * lut ) {\n<3> if ( lut ) {\n<16> memset ( & result , 0 , sizeof ( struct matrix ) ) ;\n<19> return result ;
<1> void sample_dump(int fnum, INT32 *tab, int n)\n<7> char buf[512];\n<13> if (!f) {\n<15> sprintf(buf, "/tmp/out%d.pcm", fnum);\n<17> f = fopen(buf, "w");\n<29> if (fnum == 0) {\n<33> static int pos = 0;\n<35> printf("pos=%d\n", pos);\n<37> for(i=0;i<n;i++) {\n<39> printf(" %f", (double)tab[i] / 32768.0);\n<41> if ((i % 18) == 17)\n<43> printf("\n");\n<47> pos += n;
<1> aio_read_f(int argc, char **argv)\n<7> struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n<13> while ((c = getopt(argc, argv, "CP:qv")) != EOF) {\n<15> switch (c) {\n<19> ctx->Cflag = 1;\n<25> ctx->Pflag = 1;\n<29> if (ctx->pattern < 0)\n<37> ctx->qflag = 1;\n<43> ctx->vflag = 1;\n<49> free(ctx);\n<59> if (optind > argc - 2) {\n<61> free(ctx);\n<69> ctx->offset = cvtnum(argv[optind]);\n<71> if (ctx->offset < 0) {\n<73> printf("non-numeric length argument -- %s\n", argv[optind]);\n<75> free(ctx);\n<85> if (ctx->offset & 0x1ff) {\n<91> free(ctx);\n<101> ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, 0xab);\n<105> gettimeofday(&ctx->t1, NULL);\n<107> acb = bdrv_aio_readv(bs, ctx->offset >> 9, &ctx->qiov,\n<111> if (!acb) {\n<113> free(ctx->buf);\n<115> free(ctx);
<1> ssize_t qsb_write_at(QEMUSizedBuffer *qsb, const uint8_t *source,\n<49> while (all_copy > 0) {\n<55> dest = iov->iov_base;\n<61> if (to_copy > all_copy) {\n<63> to_copy = all_copy;\n<69> memcpy(&dest[d_off], &source[s_off], to_copy);\n<73> s_off += to_copy;\n<75> all_copy -= to_copy;
<1> bool desc_ring_set_size(DescRing *ring, uint32_t size)\n<37> if (!ring->info) {\n<45> memset(ring->info, 0, size * sizeof(DescInfo));\n<51> ring->info[i].ring = ring;
<1> static int sort_get_next_record ( MI_SORT_PARAM * sort_param ) {\n<40> case DYNAMIC_RECORD : LINT_INIT ( to ) ;\n<84> i += MI_DYN_ALIGN_SIZE ) if ( block_info . header [ i ] >= 1 && block_info . header [ i ] <= MI_MAX_DYN_HEADER_BYTE ) break ;\n<145> if ( ! ( to = mi_alloc_rec_buff ( info , block_info . rec_len , & ( sort_param -> rec_buff ) ) ) ) {\n<157> else to = sort_param -> rec_buff ;\n<170> uint prefetch_len = ( MI_BLOCK_INFO_HEADER_LENGTH - header_len ) ;\n<171> if ( prefetch_len > block_info . data_len ) prefetch_len = block_info . data_len ;\n<173> memcpy ( to , block_info . header + header_len , prefetch_len ) ;\n<174> block_info . filepos += prefetch_len ;\n<175> block_info . data_len -= prefetch_len ;\n<176> left_length -= prefetch_len ;\n<177> to += prefetch_len ;\n<186> to += block_info . data_len ;
<1> bool sp_revoke_privileges ( THD * thd , const char * sp_db , const char * sp_name , bool is_proc ) {\n<19> GRANT_NAME * grant_proc = ( GRANT_NAME * ) hash_element ( hash , counter ) ;\n<20> if ( ! my_strcasecmp ( & my_charset_utf8_bin , grant_proc -> db , sp_db ) && ! my_strcasecmp ( system_charset_info , grant_proc -> tname , sp_name ) ) {\n<22> lex_user . user . str = grant_proc -> user ;\n<23> lex_user . user . length = strlen ( grant_proc -> user ) ;\n<25> lex_user . host . length = grant_proc -> host . hostname ? strlen ( grant_proc -> host . hostname ) : 0 ;\n<26> if ( replace_routine_table ( thd , grant_proc , tables [ 4 ] . table , lex_user , grant_proc -> db , grant_proc -> tname , is_proc , ~ ( ulong ) 0 , 1 ) == 0 ) {
<1> static void load_tree ( struct tree_entry * root ) {\n<9> if ( is_null_sha1 ( sha1 ) ) return ;\n<15> if ( ! buf ) die ( "Can't load tree %s" , sha1_to_hex ( sha1 ) ) ;\n<20> if ( ! buf || type != OBJ_TREE ) die ( "Can't load tree %s" , sha1_to_hex ( sha1 ) ) ;\n<23> while ( c != ( buf + size ) ) {\n<26> t -> entries [ t -> entry_count ++ ] = e ;\n<29> if ( ! c ) die ( "Corrupt mode in %s" , sha1_to_hex ( sha1 ) ) ;\n<31> e -> name = to_atom ( c , strlen ( c ) ) ;\n<32> c += e -> name -> str_len + 1 ;\n<37> free ( buf ) ;
<1> void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)\n<17> offset = addr - block->offset;\n<31> munmap(vaddr, length);\n<89> if (area != vaddr) {\n<91> fprintf(stderr, "Could not remap addr: %lx@%lx\n",\n<99> qemu_madvise(vaddr, length, QEMU_MADV_MERGEABLE);
<1> int kvm_arch_init_vcpu(CPUState *cs)\n<23> uint32_t signature[3];\n<35> c = &cpuid_data.entries[cpuid_i++];\n<37> memset(c, 0, sizeof(*c));\n<39> c->function = KVM_CPUID_SIGNATURE;\n<41> if (!hyperv_enabled(cpu)) {\n<43> memcpy(signature, "KVMKVMKVM\0\0\0", 12);\n<45> c->eax = 0;\n<49> memcpy(signature, "Microsoft Hv", 12);\n<51> c->eax = HYPERV_CPUID_MIN;\n<55> c->ebx = signature[0];\n<57> c->ecx = signature[1];\n<59> c->edx = signature[2];\n<63> c = &cpuid_data.entries[cpuid_i++];\n<65> memset(c, 0, sizeof(*c));\n<67> c->function = KVM_CPUID_FEATURES;\n<73> if (hyperv_enabled(cpu)) {\n<75> memcpy(signature, "Hv#1\0\0\0\0\0\0\0\0", 12);\n<77> c->eax = signature[0];\n<81> c = &cpuid_data.entries[cpuid_i++];\n<83> memset(c, 0, sizeof(*c));\n<85> c->function = HYPERV_CPUID_VERSION;\n<87> c->eax = 0x00001bbc;\n<89> c->ebx = 0x00060001;\n<93> c = &cpuid_data.entries[cpuid_i++];\n<95> memset(c, 0, sizeof(*c));\n<97> c->function = HYPERV_CPUID_FEATURES;\n<101> c->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n<107> c->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n<109> c->eax |= HV_X64_MSR_APIC_ACCESS_AVAILABLE;\n<115> c = &cpuid_data.entries[cpuid_i++];\n<117> memset(c, 0, sizeof(*c));\n<119> c->function = HYPERV_CPUID_ENLIGHTMENT_INFO;\n<123> c->eax |= HV_X64_RELAXED_TIMING_RECOMMENDED;\n<129> c->eax |= HV_X64_APIC_ACCESS_RECOMMENDED;\n<133> c->ebx = cpu->hyperv_spinlock_attempts;\n<137> c = &cpuid_data.entries[cpuid_i++];\n<139> memset(c, 0, sizeof(*c));\n<141> c->function = HYPERV_CPUID_IMPLEMENT_LIMITS;\n<143> c->eax = 0x40;\n<145> c->ebx = 0x40;\n<149> c = &cpuid_data.entries[cpuid_i++];\n<151> memset(c, 0, sizeof(*c));\n<155> memcpy(signature, "KVMKVMKVM\0\0\0", 12);\n<159> c->ebx = signature[0];\n<161> c->ecx = signature[1];\n<163> c->edx = signature[2];\n<169> has_msr_async_pf_en = c->eax & (1 << KVM_FEATURE_ASYNC_PF);\n<173> has_msr_pv_eoi_en = c->eax & (1 << KVM_FEATURE_PV_EOI);\n<177> has_msr_kvm_steal_time = c->eax & (1 << KVM_FEATURE_STEAL_TIME);\n<181> cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);\n<185> for (i = 0; i <= limit; i++) {\n<187> if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n<189> fprintf(stderr, "unsupported level value: 0x%x\n", limit);\n<221> for (j = 1; j < times; ++j) {\n<223> if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n<225> fprintf(stderr, "cpuid_data is full, no space for "\n<253> for (j = 0; ; j++) {\n<255> if (i == 0xd && j == 64) {\n<267> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);\n<283> if (i == 0xd && c->eax == 0) {\n<289> if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n<291> fprintf(stderr, "cpuid_data is full, no space for "\n<357> cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);\n<361> for (i = 0x80000000; i <= limit; i++) {\n<363> if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n<365> fprintf(stderr, "unsupported xlevel value: 0x%x\n", limit);\n<389> cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);\n<393> for (i = 0xC0000000; i <= limit; i++) {\n<395> if (cpuid_i == KVM_MAX_CPUID_ENTRIES) {\n<397> fprintf(stderr, "unsupported xlevel2 value: 0x%x\n", limit);\n<441> if (ret < 0) {\n<443> fprintf(stderr, "kvm_get_mce_cap_supported: %s", strerror(-ret));\n<463> if (ret < 0) {\n<465> fprintf(stderr, "KVM_X86_SETUP_MCE: %s", strerror(-ret));\n<513> if (r < 0) {\n<515> fprintf(stderr, "KVM_SET_TSC_KHZ failed\n");
<1> static struct pskeyval * lookup ( struct pskeydict * dict , char * tokbuf ) {\n<4> i < dict -> cnt ;\n<5> ++ i ) if ( strcmp ( dict -> entries [ i ] . key , tokbuf ) == 0 ) return ( & dict -> entries [ i ] ) ;
<1> static void keyword_literal(void)\n<27> g_assert(strcmp(qstring_get_str(str), "true") == 0);\n<49> g_assert(strcmp(qstring_get_str(str), "false") == 0);
<1> static void virtio_balloon_set_config ( VirtIODevice * vdev , const uint8_t * config_data ) {\n<4> memcpy ( & config , config_data , 8 ) ;
<1> static int sbr_make_f_master(AACContext *ac, SpectralBandReplication *sbr,\n<211> int16_t vk0[49];\n<245> vk0[0] = 0;\n<259> vk0[0] = sbr->k[0];\n<271> vk0[k] += vk0[k-1];\n<279> int16_t vk1[49];\n<307> vk1[1]           += change;\n<309> vk1[num_bands_1] -= change;\n<319> vk1[0] = sbr->k[1];\n<331> vk1[k] += vk1[k-1];\n<339> if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))\n<345> (num_bands_0 + 1) * sizeof(sbr->f_master[0]));\n<347> memcpy(&sbr->f_master[num_bands_0 + 1], vk1 + 1,\n<349> num_bands_1      * sizeof(sbr->f_master[0]));\n<357> if (check_n_master(ac->avctx, sbr->n_master, sbr->spectrum_params.bs_xover_band))\n<361> memcpy(sbr->f_master, vk0, (num_bands_0 + 1) * sizeof(sbr->f_master[0]));
<1> static void debug_check_frame_counts ( const VP9_COMMON * const cm ) {\n<3> vp9_zero ( zero_counts ) ;\n<5> assert ( ! memcmp ( cm -> counts . y_mode , zero_counts . y_mode , sizeof ( cm -> counts . y_mode ) ) ) ;\n<6> assert ( ! memcmp ( cm -> counts . uv_mode , zero_counts . uv_mode , sizeof ( cm -> counts . uv_mode ) ) ) ;\n<7> assert ( ! memcmp ( cm -> counts . partition , zero_counts . partition , sizeof ( cm -> counts . partition ) ) ) ;\n<8> assert ( ! memcmp ( cm -> counts . coef , zero_counts . coef , sizeof ( cm -> counts . coef ) ) ) ;\n<9> assert ( ! memcmp ( cm -> counts . eob_branch , zero_counts . eob_branch , sizeof ( cm -> counts . eob_branch ) ) ) ;\n<10> assert ( ! memcmp ( cm -> counts . switchable_interp , zero_counts . switchable_interp , sizeof ( cm -> counts . switchable_interp ) ) ) ;\n<11> assert ( ! memcmp ( cm -> counts . inter_mode , zero_counts . inter_mode , sizeof ( cm -> counts . inter_mode ) ) ) ;\n<12> assert ( ! memcmp ( cm -> counts . intra_inter , zero_counts . intra_inter , sizeof ( cm -> counts . intra_inter ) ) ) ;\n<13> assert ( ! memcmp ( cm -> counts . comp_inter , zero_counts . comp_inter , sizeof ( cm -> counts . comp_inter ) ) ) ;\n<14> assert ( ! memcmp ( cm -> counts . single_ref , zero_counts . single_ref , sizeof ( cm -> counts . single_ref ) ) ) ;\n<15> assert ( ! memcmp ( cm -> counts . comp_ref , zero_counts . comp_ref , sizeof ( cm -> counts . comp_ref ) ) ) ;\n<16> assert ( ! memcmp ( & cm -> counts . tx , & zero_counts . tx , sizeof ( cm -> counts . tx ) ) ) ;\n<17> assert ( ! memcmp ( cm -> counts . skip , zero_counts . skip , sizeof ( cm -> counts . skip ) ) ) ;\n<18> assert ( ! memcmp ( & cm -> counts . mv , & zero_counts . mv , sizeof ( cm -> counts . mv ) ) ) ;
<1> static int vmdk_add_extent(BlockDriverState *bs,\n<31> if (l1_size > 512 * 1024 * 1024) {\n<53> extent = &s->extents[s->num_extents];\n<59> memset(extent, 0, sizeof(VmdkExtent));\n<83> extent->end_sector = (*(extent - 1)).end_sector + extent->sectors;\n<87> extent->end_sector = extent->sectors;\n<91> bs->total_sectors = extent->end_sector;\n<95> *new_extent = extent;
<1> static NetSocketState *net_socket_fd_init_dgram(VLANState *vlan, int fd,\n<29> if (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n<33> if (saddr.sin_addr.s_addr==0) {\n<35> fprintf(stderr, "qemu: error: init_dgram: fd=%d unbound, cannot setup multicast dst addr\n",\n<67> fprintf(stderr, "qemu: error: init_dgram: fd=%d failed getsockname(): %s\n",\n<69> fd, strerror(errno));
<1> int unix_listen(const char *str, char *ostr, int olen)\n<17> optstr = strchr(str, ',');\n<21> len = optstr - str;\n<37> qemu_opt_set(opts, "path", str);\n<49> snprintf(ostr, olen, "%s%s", qemu_opt_get(opts, "path"), optstr ? optstr : "");
<1> static GList * completion_channel_nicks ( CHANNEL_REC * channel , const char * nick , const char * suffix ) {\n<8> if ( * nick == '\0' ) return NULL ;\n<12> complete_from_nicklist ( & list , channel , nick , suffix , match_case ) ;\n<13> len = strlen ( nick ) ;\n<19> if ( ( match_case ? strncmp ( rec -> nick , nick , len ) : g_ascii_strncasecmp ( rec -> nick , nick , len ) ) == 0 && rec != channel -> ownnick ) {\n<27> if ( ! completion_strict ) list = g_list_concat ( list , completion_nicks_nonstrict ( channel , nick , suffix , match_case ) ) ;
<1> static int iso9660_free ( struct archive_write * a ) {\n<5> if ( iso9660 -> temp_fd >= 0 ) close ( iso9660 -> temp_fd ) ;\n<9> i < iso9660 -> primary . max_depth ;\n<10> i ++ ) free ( iso9660 -> primary . pathtbl [ i ] . sorted ) ;\n<12> if ( iso9660 -> opt . joliet ) {\n<15> i < iso9660 -> joliet . max_depth ;\n<16> i ++ ) free ( iso9660 -> joliet . pathtbl [ i ] . sorted ) ;\n<17> free ( iso9660 -> joliet . pathtbl ) ;\n<20> isofile_free_hardlinks ( iso9660 ) ;\n<34> free ( iso9660 ) ;
<1> static int matroska_probe ( AVProbeData * p ) {\n<4> if ( AV_RB32 ( p -> buf ) != EBML_ID_HEADER ) return 0 ;\n<12> while ( n < size ) total = ( total << 8 ) | p -> buf [ 4 + n ++ ] ;\n<15> i < FF_ARRAY_ELEMS ( matroska_doctypes ) ;\n<17> int probelen = strlen ( matroska_doctypes [ i ] ) ;\n<18> if ( total < probelen ) continue ;\n<20> n <= 4 + size + total - probelen ;\n<21> n ++ ) if ( ! memcmp ( p -> buf + n , matroska_doctypes [ i ] , probelen ) ) return AVPROBE_SCORE_MAX ;
<1> static int rtp_packetize_g726 ( sout_stream_id_sys_t * id , block_t * in , int i_pad ) {\n<4> uint8_t * p_data = in -> p_buffer ;\n<7> while ( i_data > 0 ) {\n<8> int i_payload = __MIN ( i_max , i_data ) ;\n<11> memcpy ( & out -> p_buffer [ 12 ] , p_data , i_payload ) ;\n<15> p_data += i_payload ;\n<16> i_data -= i_payload ;
<1> void dwarf_elf_object_access_finish ( Dwarf_Obj_Access_Interface * obj ) {\n<2> if ( ! obj ) {\n<11> free ( obj -> object ) ;\n<12> free ( obj ) ;
<1> void timelib_strtointerval ( char * s , int len , timelib_time * * begin , timelib_time * * end , timelib_rel_time * * period , int * recurrences , struct timelib_error_container * * errors ) {\n<5> memset ( & in , 0 , sizeof ( in ) ) ;\n<6> in . errors = malloc ( sizeof ( struct timelib_error_container ) ) ;\n<12> while ( isspace ( * s ) && s < e ) {\n<19> if ( e - s < 0 ) {\n<20> add_error ( & in , "Empty string" ) ;\n<22> * errors = in . errors ;\n<25> timelib_error_container_dtor ( in . errors ) ;\n<30> in . str = malloc ( ( e - s ) + YYMAXFILL ) ;\n<31> memset ( in . str , 0 , ( e - s ) + YYMAXFILL ) ;\n<32> memcpy ( in . str , s , ( e - s ) ) ;\n<33> in . lim = in . str + ( e - s ) + YYMAXFILL ;\n<34> in . cur = in . str ;
<1> static void fail ( const char * format , ... ) {\n<4> fprintf ( stderr , "%s: " , PGM ) ;\n<5> if ( wherestr ) fprintf ( stderr , "%s: " , wherestr ) ;\n<7> vfprintf ( stderr , format , arg_ptr ) ;
<1> static int do_setup_cgroup_limits ( struct cgfs_data * d , struct lxc_list * cgroup_settings , bool do_devices ) {\n<7> if ( ! sorted_cgroup_settings ) {\n<10> lxc_list_for_each ( iterator , sorted_cgroup_settings ) {\n<11> cg = iterator -> elem ;\n<12> if ( do_devices == ! strncmp ( "devices" , cg -> subsystem , 7 ) ) {\n<13> if ( strcmp ( cg -> subsystem , "devices.deny" ) == 0 && cgroup_devices_has_allow_or_deny ( d , cg -> value , false ) ) continue ;\n<14> if ( strcmp ( cg -> subsystem , "devices.allow" ) == 0 && cgroup_devices_has_allow_or_deny ( d , cg -> value , true ) ) continue ;\n<15> if ( lxc_cgroup_set_data ( cg -> subsystem , cg -> value , d ) ) {\n<24> out : lxc_list_for_each_safe ( iterator , sorted_cgroup_settings , next ) {\n<25> lxc_list_del ( iterator ) ;\n<26> free ( iterator ) ;\n<28> free ( sorted_cgroup_settings ) ;
<1> int cache_handler ( TSCont contp , TSEvent event , void * data ) {\n<16> ndone = 0 ;\n<17> while ( ntodo > 0 ) {\n<19> ptr_block = TSIOBufferBlockWriteStart ( blockp , & avail ) ;\n<20> towrite = ( ( ntodo < avail ) ? ntodo : avail ) ;\n<21> memcpy ( ptr_block , content + ndone , towrite ) ;\n<22> TSIOBufferProduce ( cache_vconn -> bufp , towrite ) ;\n<24> ndone += towrite ;
<1> static void print_table_data_xml ( MYSQL_RES * result ) {\n<6> xmlencode_print ( glob_buffer . ptr ( ) , ( int ) strlen ( glob_buffer . ptr ( ) ) ) ;\n<14> i < mysql_num_fields ( result ) ;\n<17> xmlencode_print ( fields [ i ] . name , ( uint ) strlen ( fields [ i ] . name ) ) ;
<1> static void http_failure_test ( void ) {\n<7> fprintf ( stdout , "Testing Bad HTTP Request: " ) ;\n<10> bev = bufferevent_new ( fd , http_failure_readcb , http_writecb , http_errorcb , NULL ) ;\n<11> http_request = "illegal request\r\n" ;\n<12> bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n<14> bufferevent_free ( bev ) ;\n<17> if ( test_ok != 2 ) {\n<18> fprintf ( stdout , "FAILED\n" ) ;\n<21> fprintf ( stdout , "OK\n" ) ;
<1> static int mpeg_decode_slice(AVCodecContext *avctx,\n<13> MpegEncContext *s = &s1->mpeg_enc_ctx;\n<21> if (start_code >= s->mb_height)\n<31> memset(s->last_mv, 0, sizeof(s->last_mv));\n<47> MPV_frame_start(s);\n<57> s->qscale = get_qscale(s);\n<75> ret = mpeg_decode_mb(s, s->block);\n<87> MPV_decode_mb(s, s->block);\n<107> MPV_frame_end(s);
<1> static int encode_mode(CinepakEncContext *s, CinepakMode mode, int h, int v1_size, int v4_size, int v4, AVPicture *scratch_pict, strip_info *info, unsigned char *buf)\n<9> unsigned char temp[64]; //32/2 = 16 V4 blocks at 4 B each -> 64 B\n<147> flags = bits = temp_size = 0;\n<179> AV_WB32(&buf[ret], flags);\n<187> if(mb->best_encoding == ENC_SKIP || needs_extra_bit) {\n<189> memcpy(&buf[ret], temp, temp_size);\n<191> ret += temp_size;\n<193> temp_size = 0;\n<215> temp[temp_size++] = mb->v1_vector;\n<221> temp[temp_size++] = mb->v4_vector[v4][z];\n<225> if(should_write_temp) {\n<227> memcpy(&buf[ret], temp, temp_size);\n<229> ret += temp_size;\n<231> temp_size = 0;\n<239> if(bits > 0) {\n<241> AV_WB32(&buf[ret], flags);\n<245> memcpy(&buf[ret], temp, temp_size);\n<247> ret += temp_size;\n<253> write_chunk_header(buf + header_ofs, 0x31, ret - header_ofs - CHUNK_HEADER_SIZE);
<1> static int idcin_decode_frame(AVCodecContext *avctx,\n<15> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<31> if (avctx->get_buffer(avctx, &s->frame)) {\n<41> idcin_decode_vlcs(s);\n<45> if (pal) {\n<49> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<55> memcpy(s->frame.data[1], s->pal, AVPALETTE_SIZE);
<1> static void gsm_flush ( AVCodecContext * avctx ) {\n<2> GSMContext * s = avctx -> priv_data ;\n<3> memset ( s , 0 , sizeof ( * s ) ) ;
<1> char * curl_easy_escape ( struct Curl_easy * data , const char * string , int inlength ) {\n<10> if ( inlength < 0 ) return NULL ;\n<11> alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ;\n<13> ns = malloc ( alloc ) ;\n<14> if ( ! ns ) return NULL ;\n<15> length = alloc - 1 ;\n<18> if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ;\n<21> if ( newlen > alloc ) {\n<22> alloc *= 2 ;\n<23> testing_ptr = realloc ( ns , alloc ) ;\n<24> if ( ! testing_ptr ) {\n<25> free ( ns ) ;\n<29> ns = testing_ptr ;\n<33> if ( result ) {\n<34> free ( ns ) ;\n<37> snprintf ( & ns [ strindex ] , 4 , "%%%02X" , in ) ;\n<40> string ++ ;
<1> static int hls_delete_old_segments(HLSContext *hls) {\n<11> char *dirname = NULL, *p, *sub_path;\n<51> if (segment && !hls->use_localtime_mkdir) {\n<71> p = (char *)av_basename(dirname);\n<79> while (segment) {\n<81> av_log(hls, AV_LOG_DEBUG, "deleting old segment %s\n",\n<85> path_size =  (hls->use_localtime_mkdir ? 0 : strlen(dirname)) + strlen(segment->filename) + 1;\n<101> av_strlcpy(path, segment->filename, path_size);\n<105> av_strlcpy(path, dirname, path_size);\n<107> av_strlcat(path, segment->filename, path_size);\n<113> if (unlink(path) < 0) {\n<115> av_log(hls, AV_LOG_ERROR, "failed to delete old segment %s: %s\n",\n<117> path, strerror(errno));\n<123> if (segment->sub_filename[0] != '\0') {\n<125> sub_path_size = strlen(dirname) + strlen(segment->sub_filename) + 1;\n<127> sub_path = av_malloc(sub_path_size);\n<139> av_strlcpy(sub_path, dirname, sub_path_size);\n<141> av_strlcat(sub_path, segment->sub_filename, sub_path_size);\n<143> if (unlink(sub_path) < 0) {\n<145> av_log(hls, AV_LOG_ERROR, "failed to delete old segment %s: %s\n",\n<147> sub_path, strerror(errno));\n<159> segment = previous_segment->next;\n<171> av_free(dirname);
<1> char * xmlrpc_normalizeBuffer ( const char * buf ) {\n<4> len = strlen ( buf ) ;\n<5> newbuf = ( char * ) smalloc ( sizeof ( char ) * len + 1 ) ;\n<12> case 3 : if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {\n<14> if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {\n<17> if ( buf [ i + 1 ] == ',' ) {\n<19> if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {\n<22> if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {\n<33> default : if ( buf [ i ] > 31 ) {\n<34> newbuf [ j ] = buf [ i ] ;
<1> static afs_int32 nameToID ( struct rx_call * call , namelist * aname , idlist * aid ) {\n<11> if ( size < 0 ) return PRTOOMANY ;\n<12> aid -> idlist_val = ( afs_int32 * ) malloc ( size * sizeof ( afs_int32 ) ) ;\n<13> if ( ! aid -> idlist_val ) return PRNOMEM ;\n<23> i < aname -> namelist_len ;\n<27> strncpy ( vname , aname -> namelist_val [ i ] , sizeof ( vname ) ) ;\n<28> vname [ sizeof ( vname ) - 1 ] = '\0' ;\n<30> cell = strchr ( vname , '@' ) ;\n<33> cell ++ ;\n<35> if ( cell && afs_is_foreign_ticket_name ( nameinst , NULL , cell , pr_realmName ) ) code = NameToID ( tt , aname -> namelist_val [ i ] , & aid -> idlist_val [ i ] ) ;\n<38> osi_audit ( PTS_NmToIdEvent , code , AUD_STR , aname -> namelist_val [ i ] , AUD_ID , aid -> idlist_val [ i ] , AUD_END ) ;\n<39> ViceLog ( 125 , ( "PTS_NameToID: code %d aname %s aid %d\n" , code , aname -> namelist_val [ i ] , aid -> idlist_val [ i ] ) ) ;
<1> static void xml_print_section_header ( WriterContext * wctx ) {\n<3> const struct section * section = wctx -> section [ wctx -> level ] ;\n<5> if ( wctx -> level == 0 ) {\n<6> const char * qual = " xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' " "xmlns:ffprobe='http://www.ffmpeg.org/schema/ffprobe' " "xsi:schemaLocation='http://www.ffmpeg.org/schema/ffprobe ffprobe.xsd'" ;\n<7> printf ( "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ) ;\n<8> printf ( "<%sffprobe%s>\n" , xml -> fully_qualified ? "ffprobe:" : "" , xml -> fully_qualified ? qual : "" ) ;\n<11> if ( xml -> within_tag ) {\n<13> printf ( ">\n" ) ;\n<19> if ( parent_section && ( parent_section -> flags & SECTION_FLAG_IS_WRAPPER ) && wctx -> level && wctx -> nb_item [ wctx -> level - 1 ] ) printf ( "\n" ) ;\n<21> if ( section -> flags & SECTION_FLAG_IS_ARRAY ) {\n<23> printf ( "<%s>\n" , section -> name ) ;\n<27> printf ( "<%s " , section -> name ) ;
<1> int ff_probe_input_buffer(ByteIOContext **pb, AVInputFormat **fmt,\n<9> AVProbeData pd = { filename ? filename : "", NULL, -offset };\n<59> buf = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n<61> if ((ret = get_buffer(*pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n<69> pd.buf_size += ret;\n<71> pd.buf = &buf[offset];\n<75> memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n<81> *fmt = av_probe_input_format2(&pd, 1, &score);
<1> bool del_edge_h ( connection_t * c ) {\n<4> char to_name [ MAX_STRING_SIZE ] ;\n<10> if ( ! check_id ( from_name ) || ! check_id ( to_name ) || ! strcmp ( from_name , to_name ) ) {\n<17> from = lookup_node ( from_name ) ;\n<18> to = lookup_node ( to_name ) ;
<1> int ff_tls_open_underlying(TLSShared *c, URLContext *parent, const char *uri, AVDictionary **options)\n<19> set_options(c, uri);\n<29> av_url_split(NULL, 0, NULL, 0, c->host, sizeof(c->host), &port, NULL, 0, uri);\n<33> p = strchr(uri, '?');\n<37> if (!p) {\n<57> if (!getaddrinfo(c->host, NULL, &hints, &ai)) {\n<67> proxy_path = getenv("http_proxy");\n<69> use_proxy = !ff_http_match_no_proxy(getenv("no_proxy"), c->host) &&\n<71> proxy_path && av_strstart(proxy_path, "http://", NULL);\n<81> av_url_split(NULL, 0, proxy_auth, sizeof(proxy_auth),\n<87> ff_url_join(dest, sizeof(dest), NULL, NULL, c->host, port, NULL);
<1> static struct dirent *local_readdir(FsContext *ctx, V9fsFidOpenState *fs)\n<11> entry = readdir(fs->dir.stream);\n<13> if (!entry) {\n<25> } else if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n<27> if (!strcmp(entry->d_name, VIRTFS_META_DIR)) {\n<35> entry->d_type = DT_UNKNOWN;\n<41> return entry;
<1> static int selinux_inode_listsecurity ( struct inode * inode , char * buffer , size_t buffer_size ) {\n<2> const int len = sizeof ( XATTR_NAME_SELINUX ) ;\n<3> if ( buffer && len <= buffer_size ) memcpy ( buffer , XATTR_NAME_SELINUX , len ) ;\n<4> return len ;
<37> if ( numbers ) {\n<43> * numbers = ( float4 * ) palloc ( narrayelem * sizeof ( float4 ) ) ;\n<44> memcpy ( * numbers , ARR_DATA_PTR ( statarray ) , narrayelem * sizeof ( float4 ) ) ;
<1> static gpgme_error_t set_recipients ( engine_uiserver_t uiserver , gpgme_key_t recp [ ] ) {\n<9> line = malloc ( 10 + 40 + 1 ) ;\n<10> if ( ! line ) return gpg_error_from_syserror ( ) ;\n<11> strcpy ( line , "RECIPIENT " ) ;\n<13> ! err && recp [ i ] ;\n<17> if ( ! recp [ i ] -> uids || ! ( uid = recp [ i ] -> uids -> uid ) || ! * uid ) {\n<21> newlen = 11 + strlen ( uid ) ;\n<22> if ( linelen < newlen ) {\n<23> char * newline = realloc ( line , newlen ) ;\n<24> if ( ! newline ) {\n<26> free ( line ) ;\n<29> line = newline ;\n<30> linelen = newlen ;\n<32> strcpy ( & line [ 10 ] , uid ) ;\n<33> err = uiserver_assuan_simple_command ( ctx , line , uiserver -> status . fnc , uiserver -> status . fnc_value ) ;\n<35> else if ( err ) {\n<36> free ( line ) ;\n<40> free ( line ) ;
<1> static int decode_blck(uint8_t *frame, int width, int height,\n<7> memset(frame, 0, width * height);
<1> int ff_mpeg_update_thread_context(AVCodecContext *dst,\n<8> MpegEncContext *s = dst->priv_data, *s1 = src->priv_data;\n<12> if (dst == src || !s1->context_initialized)\n<22> if (!s->context_initialized) {\n<24> memcpy(s, s1, sizeof(MpegEncContext));\n<30> s->picture_range_start  += MAX_PICTURE_COUNT;\n<32> s->picture_range_end    += MAX_PICTURE_COUNT;\n<34> s->bitstream_buffer      = NULL;\n<40> ff_MPV_common_init(s);\n<46> if (s->height != s1->height || s->width != s1->width || s->context_reinit) {\n<52> s->height = s1->height;\n<54> s->width  = s1->width;\n<56> if ((err = ff_MPV_common_frame_size_change(s)) < 0)\n<74> s->coded_picture_number = s1->coded_picture_number;\n<76> s->picture_number       = s1->picture_number;\n<78> s->input_picture_number = s1->input_picture_number;\n<82> memcpy(s->picture, s1->picture, s1->picture_count * sizeof(Picture));\n<86> (char *) &s1->last_picture_ptr - (char *) &s1->last_picture);\n<98> s->last_picture_ptr    = REBASE_PICTURE(s1->last_picture_ptr,    s, s1);\n<100> s->current_picture_ptr = REBASE_PICTURE(s1->current_picture_ptr, s, s1);\n<102> s->next_picture_ptr    = REBASE_PICTURE(s1->next_picture_ptr,    s, s1);\n<116> memcpy(&s->time_increment_bits, &s1->time_increment_bits,\n<118> (char *) &s1->shape - (char *) &s1->time_increment_bits);\n<138> if (s1->bitstream_buffer) {\n<150> s->bitstream_buffer_size = s1->bitstream_buffer_size;\n<152> memcpy(s->bitstream_buffer, s1->bitstream_buffer,\n<156> memset(s->bitstream_buffer + s->bitstream_buffer_size, 0,\n<166> memcpy(&s->progressive_sequence, &s1->progressive_sequence,\n<168> (char *) &s1->rtp_mode - (char *) &s1->progressive_sequence);
<1> static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)\n<69> if (ret < 0) {\n<79> memset(&cupkt, 0, sizeof(cupkt));\n<113> ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt));\n<133> if (av_fifo_size(ctx->frame_queue)) {\n<151> memset(&params, 0, sizeof(params));\n<161> ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params));
<1> static struct archive_wstring * archive_wstring_append ( struct archive_wstring * as , const wchar_t * p , size_t s ) {\n<2> if ( archive_wstring_ensure ( as , as -> length + s + 1 ) == NULL ) return ( NULL ) ;\n<3> wmemmove ( as -> s + as -> length , p , s ) ;\n<4> as -> length += s ;
<1> void ntpd_set_tod_using ( const char * which ) {\n<3> snprintf ( line , sizeof ( line ) , "settimeofday=\"%s\"" , which ) ;\n<4> set_sys_var ( line , strlen ( line ) + 1 , RO ) ;
<1> static UBool CnvExtAddTable ( NewConverter * cnvData , UCMTable * table , UConverterStaticData * staticData ) {\n<3> if ( table -> unicodeMask & UCNV_HAS_SURROGATES ) {\n<4> fprintf ( stderr , "error: contains mappings for surrogate code points\n" ) ;
<1> static int parse_outputs(const char **buf, AVFilterInOut **curr_inputs,\n<69> *buf += strspn(*buf, WHITESPACES);
<1> static int chacha20_poly1305_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n<7> if ( ! actx -> mac_inited ) {\n<9> memset ( actx -> key . buf , 0 , sizeof ( actx -> key . buf ) ) ;\n<10> ChaCha20_ctr32 ( actx -> key . buf , actx -> key . buf , CHACHA_BLK_SIZE , actx -> key . key . d , actx -> key . counter ) ;\n<36> out += plen ;\n<43> out += plen ;\n<63> Poly1305_Update ( POLY1305_ctx ( actx ) , ( unsigned char * ) & actx -> len , POLY1305_BLOCK_SIZE ) ;\n<82> Poly1305_Update ( POLY1305_ctx ( actx ) , temp , POLY1305_BLOCK_SIZE ) ;\n<84> Poly1305_Final ( POLY1305_ctx ( actx ) , ctx -> encrypt ? actx -> tag : temp ) ;\n<87> if ( ctx -> encrypt ) {\n<88> memcpy ( out , actx -> tag , POLY1305_BLOCK_SIZE ) ;\n<91> if ( CRYPTO_memcmp ( temp , in , POLY1305_BLOCK_SIZE ) ) {\n<92> memset ( out - plen , 0 , plen ) ;
<1> void cpu_loop (CPUSPARCState *env)\n<13> trapnr = cpu_sparc_exec (env);\n<17> switch (trapnr) {\n<233> printf ("Unhandled trap: 0x%x\n", trapnr);
<1> static int decode_frame(AVCodecContext *avctx, void *data,\n<95> if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n<97> int cnt= buf[5]&0x1f;\n<141> buf_index = decode_nal_units(h, buf, buf_size, 0);\n<161> if (avctx->skip_frame >= AVDISCARD_NONREF ||\n<163> buf_size >= 4 && !memcmp("Q264", buf, 4))
<1> static int ccid_handle_bulk_out(USBCCIDState *s, USBPacket *p)\n<9> if (p->len + s->bulk_out_pos > BULK_OUT_DATA_SIZE) {\n<17> memcpy(s->bulk_out_data + s->bulk_out_pos, p->data, p->len);\n<19> s->bulk_out_pos += p->len;\n<21> if (p->len == CCID_MAX_PACKET_SIZE) {
<1> static void uiserver_release ( void * engine ) {\n<3> if ( ! uiserver ) return ;\n<5> free ( uiserver -> colon . attic . line ) ;\n<6> free ( uiserver ) ;
<1> int opt_loglevel(void *optctx, const char *opt, const char *arg)\n<33> for (i = 0; i < FF_ARRAY_ELEMS(log_levels); i++) {\n<35> if (!strcmp(log_levels[i].name, arg)) {\n<37> av_log_set_level(log_levels[i].level);\n<39> return 0;\n<47> level = strtol(arg, &tail, 10);
<1> e1000e_write_lgcy_rx_descr(E1000ECore *core, uint8_t *desc,\n<17> struct e1000_rx_desc *d = (struct e1000_rx_desc *) desc;\n<21> memset(d, 0, sizeof(*d));\n<33> e1000e_build_rx_metadata(core, pkt, pkt != NULL,
<1> static int do_show_master_status ( MYSQL * mysql_con , int consistent_binlog_pos ) {\n<22> if ( ! ignore_errors ) {\n<23> fprintf ( stderr , "%s: Error: Binlogging on server not active\n" , my_progname_short ) ;
<1> static gcry_err_code_t sexp_to_sig ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int opaque ) {\n<17> if ( ! name ) {\n<22> else if ( ! strcmp ( name , "flags" ) ) {\n<23> gcry_free ( name ) ;\n<24> gcry_sexp_release ( l2 ) ;\n<25> l2 = gcry_sexp_nth ( list , 2 ) ;\n<26> if ( ! l2 ) {\n<32> ath_mutex_lock ( & pubkeys_registered_lock ) ;\n<33> module = gcry_pk_lookup_name ( name ) ;\n<34> ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n<35> gcry_free ( name ) ;\n<36> name = NULL ;\n<37> if ( ! module ) {\n<43> elems = pubkey -> elements_sig ;\n<44> array = gcry_calloc ( strlen ( elems ) + 1 , sizeof * array ) ;\n<45> if ( ! array ) err = gpg_err_code_from_syserror ( ) ;\n<46> if ( ! err ) err = sexp_elements_extract ( list , elems , array , NULL , opaque ) ;
<1> static void host ( struct parse * pcmd , FILE * fp ) {\n<4> if ( havehost ) ( void ) fprintf ( fp , "current host is %s\n" , currenthost ) ;\n<5> else ( void ) fprintf ( fp , "no current host\n" ) ;\n<10> if ( pcmd -> nargs == 2 ) {\n<11> if ( ! strcmp ( "-4" , pcmd -> argval [ i ] . string ) ) ai_fam_templ = AF_INET ;\n<12> else if ( ! strcmp ( "-6" , pcmd -> argval [ i ] . string ) ) ai_fam_templ = AF_INET6 ;\n<14> i = 1 ;\n<16> if ( openhost ( pcmd -> argval [ i ] . string , ai_fam_templ ) ) {\n<17> fprintf ( fp , "current host set to %s\n" , currenthost ) ;\n<20> no_change : if ( havehost ) fprintf ( fp , "current host remains %s\n" , currenthost ) ;\n<21> else fprintf ( fp , "still no current host\n" ) ;
<1> static void test_null ( ) {\n<20> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> my_bind [ 1 ] = my_bind [ 0 ] ;\n<25> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<35> my_bind [ 1 ] = my_bind [ 0 ] ;\n<36> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<54> my_bind [ 1 ] = my_bind [ 0 ] ;\n<61> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;
<1> static int hpet_start_timer(struct qemu_alarm_timer *t)\n<23> if (r < 0) {\n<25> fprintf(stderr, "Could not configure '/dev/hpet' to have a 1024Hz timer. This is not a fatal\n"
<1> static void quant_matrix_rebuild ( uint16_t * matrix , const uint8_t * old_perm , const uint8_t * new_perm ) {\n<2> uint16_t temp_matrix [ 64 ] ;\n<4> memcpy ( temp_matrix , matrix , 64 * sizeof ( uint16_t ) ) ;\n<8> matrix [ new_perm [ i ] ] = temp_matrix [ old_perm [ i ] ] ;
<1> static int save_xbzrle_page(RAMState *rs, uint8_t **current_data,\n<15> if (!cache_is_cached(XBZRLE.cache, current_addr, rs->bitmap_sync_count)) {\n<51> memcpy(XBZRLE.current_buf, *current_data, TARGET_PAGE_SIZE);\n<57> encoded_len = xbzrle_encode_buffer(prev_cached_page, XBZRLE.current_buf,\n<77> if (!last_stage) {\n<79> memcpy(prev_cached_page, *current_data, TARGET_PAGE_SIZE);\n<81> *current_data = prev_cached_page;\n<93> if (!last_stage) {\n<95> memcpy(prev_cached_page, XBZRLE.current_buf, TARGET_PAGE_SIZE);
<1> static bool do_init_cpuset_file ( struct cgroup_mount_point * mp , const char * path , const char * name ) {\n<3> char * childfile , * parentfile = NULL , * tmp ;\n<6> childfile = cgroup_to_absolute_path ( mp , path , name ) ;\n<7> if ( ! childfile ) return false ;\n<8> ret = cgroup_read_from_file ( childfile , value , sizeof ( value ) ) ;\n<10> if ( value [ 0 ] != '\0' && value [ 0 ] != '\n' ) {\n<14> parentfile = strdup ( path ) ;\n<15> if ( ! parentfile ) goto out ;\n<16> tmp = strrchr ( parentfile , '/' ) ;\n<17> if ( ! tmp ) goto out ;\n<19> * tmp = '\0' ;\n<21> parentfile = cgroup_to_absolute_path ( mp , tmp , name ) ;\n<22> free ( tmp ) ;\n<23> if ( ! parentfile ) goto out ;\n<24> ret = cgroup_read_from_file ( parentfile , value , sizeof ( value ) ) ;\n<26> if ( ret == sizeof ( value ) ) {\n<30> ok = ( lxc_write_to_file ( childfile , value , strlen ( value ) , false ) >= 0 ) ;\n<31> if ( ! ok ) SYSERROR ( "failed writing %s" , childfile ) ;\n<32> out : free ( parentfile ) ;\n<33> free ( childfile ) ;
<1> CharDriverState *qemu_chr_open_opts(QemuOpts *opts,\n<15> fprintf(stderr, "chardev: no id specified\n");\n<28> if (strcmp(backend_table[i].name, qemu_opt_get(opts, "backend")) == 0)\n<35> fprintf(stderr, "chardev: backend \"%s\" not found\n",\n<37> qemu_opt_get(opts, "backend"));\n<47> fprintf(stderr, "chardev: opening backend \"%s\" failed\n",\n<49> qemu_opt_get(opts, "backend"));\n<69> int len = strlen(qemu_opts_id(opts)) + 6;\n<71> base->label = qemu_malloc(len);
<1> static int read_packet(AVFormatContext *s1, AVPacket *pkt)\n<39> for(i=0; i<3; i++){\n<49> av_log(s1, AV_LOG_ERROR, "Could not open file : %s\n",filename);\n<59> if(codec->codec_id != AV_CODEC_ID_RAWVIDEO)\n<63> filename[ strlen(filename) - 1 ]= 'U' + i;
<1> static void save_layer_context ( VP8_COMP * cpi ) {\n<2> LAYER_CONTEXT * lc = & cpi -> layer_context [ cpi -> current_layer ] ;\n<29> memcpy ( lc -> count_mb_ref_frame_usage , cpi -> mb . count_mb_ref_frame_usage , sizeof ( cpi -> mb . count_mb_ref_frame_usage ) ) ;
<1> int dump_msg_test ( char * code , FILE * fd , char header , char segregationLevel ) {\n<6> payload = ( unsigned char * ) code ;\n<7> memcpy ( & i , code , 2 ) ;\n<8> memcpy ( & j , & code [ MSG_START_IDX ] , 2 ) ;\n<9> memcpy ( & msglen , & code [ MSG_LEN_IDX ] , 2 ) ;\n<10> i = ntohs ( i ) ;\n<11> j = ntohs ( j ) ;\n<12> msglen = ntohs ( msglen ) ;\n<14> fwrite ( code , 1 , j + msglen , fd ) ;\n<19> r = ( i < 100 ) ? 1 : 0 ;\n<39> i ++ ;\n<40> for ( k = i ;\n<41> k < i + ( j * 3 ) ;\n<43> memcpy ( & l , & payload [ k + 1 ] , 2 ) ;\n<44> memcpy ( & m , & payload [ k + 4 ] , 2 ) ;\n<45> l = ntohs ( l ) ;\n<46> m = ntohs ( m ) ;\n<47> if ( header == ( char ) payload [ k ] || ( header == 'U' && ( payload [ k ] == 'f' || payload [ k ] == 't' || payload [ k ] == 'm' || payload [ k ] == 'o' || payload [ k ] == 'p' ) ) ) dump_headers_test ( msg , msglen , & payload [ i + ( j * 3 ) + l + 3 ] , m - l , payload [ k ] , fd , segregationLevel ) ;
<1> void ff_er_frame_end(MpegEncContext *s){\n<38> pic->ref_index[i]= av_mallocz(size * sizeof(uint8_t));\n<56> if(pic->ref_index[i])\n<58> memset(pic->ref_index[i], 0, size * sizeof(uint8_t));
<1> ATF_TC_BODY ( pretty_print_option , tc ) {\n<11> memset ( bad_data , 0x1f , sizeof ( bad_data ) ) ;\n<22> if ( ! output_buf || strcmp ( output_buf , "1:2:3:4:5:6" ) ) {\n<23> atf_tc_fail ( "pretty_print_option did not return \"<error>\"" ) ;\n<26> if ( ! output_buf || strcmp ( output_buf , "<error>" ) ) {\n<27> atf_tc_fail ( "pretty_print_option did not return \"<error>\"" ) ;
<1> extern int main ( int argc , char * argv [ ] ) {\n<5> argc = u_parseArgs ( argc , argv , UPRV_LENGTHOF ( options ) , options ) ;\n<6> if ( argc < 0 ) {\n<7> fprintf ( stderr , "error in command line argument \"%s\"\n" , argv [ - argc ] ) ;\n<12> if ( argc < 0 || options [ 0 ] . doesOccur || options [ 1 ] . doesOccur ) {\n<13> FILE * where = argc < 0 ? stderr : stdout ;\n<14> fprintf ( where , "%csage: %s [ -h, -?, --help ] [ -v, --verbose ] [ -c, --copyright ] [ -C, --comment comment ] [ -d, --destdir dir ] [ -n, --name filename ] [ -t, --type filetype ] [ -S, --source tocfile ] [ -e, --entrypoint name ] maxsize listfile\n" , argc < 0 ? 'u' : 'U' , * argv ) ;\n<15> if ( options [ 0 ] . doesOccur || options [ 1 ] . doesOccur ) {\n<16> fprintf ( where , "\n" "Read the list file (default: standard input) and create a common data\n" "file from specified files. Omit any files larger than maxsize, if maxsize > 0.\n" ) ;\n<17> fprintf ( where , "\n" "Options:\n" "\t-h, -?, --help this usage text\n" "\t-v, --verbose verbose output\n" "\t-c, --copyright include the ICU copyright notice\n" "\t-C, --comment comment include a comment string\n" "\t-d, --destdir dir destination directory\n" ) ;
<1> static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)\n<7> while (ff_id3v2_extra_meta_funcs[i].tag3) {\n<19> return &ff_id3v2_extra_meta_funcs[i];\n<21> i++;
<1> static void extended_com_err_fn ( const char * myprog , errcode_t code , const char * fmt , va_list args ) {\n<3> if ( code ) {\n<4> emsg = krb5_get_error_message ( context , code ) ;\n<5> fprintf ( stderr , "%s: %s " , myprog , emsg ) ;\n<6> krb5_free_error_message ( context , emsg ) ;\n<9> fprintf ( stderr , "%s: " , myprog ) ;\n<11> vfprintf ( stderr , fmt , args ) ;\n<12> fprintf ( stderr , "\n" ) ;
<1> static void * cgfs_init ( const char * name ) {\n<3> d = malloc ( sizeof ( * d ) ) ;\n<4> if ( ! d ) return NULL ;\n<5> memset ( d , 0 , sizeof ( * d ) ) ;\n<6> d -> name = strdup ( name ) ;\n<7> if ( ! d -> name ) goto err1 ;\n<8> d -> cgroup_pattern = lxc_global_config_value ( "lxc.cgroup.pattern" ) ;\n<10> if ( ! d -> meta ) {\n<14> return d ;\n<15> err2 : free ( d -> name ) ;\n<16> err1 : free ( d ) ;
<1> static void test_qemu_strtoull_max(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoull(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> static int ff_asf_parse_packet(AVFormatContext *s, ByteIOContext *pb, AVPacket *pkt)\n<83> asf_st = asf->asf_st;\n<239> for(i=0; i<asf_st->pkt.size && !asf_st->pkt.data[i]; i++);\n<261> if(asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span){\n<269> uint8_t *newdata = av_malloc(asf_st->pkt.size + FF_INPUT_BUFFER_PADDING_SIZE);\n<271> if (newdata) {\n<275> memset(newdata + asf_st->pkt.size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<277> while (offset < asf_st->pkt.size) {\n<279> int off = offset / asf_st->ds_chunk_size;\n<297> asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n<301> offset += asf_st->ds_chunk_size;
<1> static void mpic_reset (void *opaque)\n<43> for (i = 0; i < MAX_CPU; i++) {\n<49> memset(&mpp->dst[i].raised, 0, sizeof(IRQ_queue_t));\n<53> memset(&mpp->dst[i].servicing, 0, sizeof(IRQ_queue_t));
<1> static int http_prepare_data(HTTPContext *c, long cur_time)\n<9> switch(c->state) {\n<13> memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));\n<37> st = av_mallocz(sizeof(AVStream));\n<41> if (c->stream->feed == c->stream)\n<43> memcpy(st, c->stream->streams[i], sizeof(AVStream));\n<47> memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream));\n<67> for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n<71> st = av_mallocz(sizeof(AVStream));\n<75> memcpy(st, c->fmt_in->streams[i], sizeof(AVStream));\n<95> av_write_header(&c->fmt_ctx);
<1> static void await_references ( H264Context * h ) {\n<9> memset ( refs , - 1 , sizeof ( refs ) ) ;\n<11> get_lowest_part_y ( h , refs , 0 , 16 , 0 , IS_DIR ( mb_type , 0 , 0 ) , IS_DIR ( mb_type , 0 , 1 ) , nrefs ) ;\n<14> get_lowest_part_y ( h , refs , 0 , 8 , 0 , IS_DIR ( mb_type , 0 , 0 ) , IS_DIR ( mb_type , 0 , 1 ) , nrefs ) ;\n<18> get_lowest_part_y ( h , refs , 0 , 16 , 0 , IS_DIR ( mb_type , 0 , 0 ) , IS_DIR ( mb_type , 0 , 1 ) , nrefs ) ;\n<31> get_lowest_part_y ( h , refs , n , 8 , y_offset , IS_DIR ( sub_mb_type , 0 , 0 ) , IS_DIR ( sub_mb_type , 0 , 1 ) , nrefs ) ;\n<34> get_lowest_part_y ( h , refs , n , 4 , y_offset , IS_DIR ( sub_mb_type , 0 , 0 ) , IS_DIR ( sub_mb_type , 0 , 1 ) , nrefs ) ;\n<38> get_lowest_part_y ( h , refs , n , 8 , y_offset , IS_DIR ( sub_mb_type , 0 , 0 ) , IS_DIR ( sub_mb_type , 0 , 1 ) , nrefs ) ;\n<48> get_lowest_part_y ( h , refs , n + j , 4 , sub_y_offset , IS_DIR ( sub_mb_type , 0 , 0 ) , IS_DIR ( sub_mb_type , 0 , 1 ) , nrefs ) ;
<1> static void cirrus_bitblt_cputovideo_next(CirrusVGAState * s)\n<29> (*s->cirrus_rop)(s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n<33> cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,\n<41> if (s->cirrus_srccounter <= 0)\n<53> copy_count = s->cirrus_srcptr_end - end_ptr;\n<55> memmove(s->cirrus_bltbuf, end_ptr, copy_count);\n<57> s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;\n<59> s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;
<1> soread(so)\n<3> struct socket *so;\n<39> iov[0].iov_base = sb->sb_wptr;\n<53> if (iov[0].iov_len > mss)\n<55> iov[0].iov_len -= iov[0].iov_len%mss;\n<65> if (iov[0].iov_len > len) iov[0].iov_len = len;\n<71> iov[1].iov_base = sb->sb_data;\n<75> if(iov[1].iov_len > len)\n<77> iov[1].iov_len = len;\n<85> if (iov[1].iov_len > lss) {\n<87> iov[1].iov_len -= lss;\n<95> iov[0].iov_len -= lss;\n<107> if (iov[0].iov_len > mss)\n<109> iov[0].iov_len -= iov[0].iov_len%mss;\n<127> nn = recv(so->s, iov[0].iov_base, iov[0].iov_len,0);\n<131> if (nn <= 0) {\n<133> if (nn < 0 && (errno == EINTR || errno == EAGAIN))\n<139> DEBUG_MISC((dfd, " --- soread() disconnected, nn = %d, errno = %d-%s\n", nn, errno,strerror(errno)));\n<141> sofcantrcvmore(so);\n<143> tcp_sockclosed(sototcpcb(so));\n<173> if (n == 2 && nn == iov[0].iov_len) {\n<177> ret = recv(so->s, iov[1].iov_base, iov[1].iov_len,0);\n<179> if (ret > 0)
<1> static int sd_open(BlockDriverState *bs, const char *filename, int flags)\n<31> memset(vdi, 0, sizeof(vdi));\n<33> memset(tag, 0, sizeof(tag));\n<35> if (parse_vdiname(s, filename, vdi, &snapid, tag) < 0) {\n<55> ret = find_vdi_name(s, vdi, snapid, tag, &vid, 0);\n<107> ret = read_object(fd, buf, vid_to_vdi_oid(vid), 0, SD_INODE_SIZE, 0,\n<117> if (ret) {\n<125> memcpy(&s->inode, buf, sizeof(s->inode));\n<135> strncpy(s->name, vdi, sizeof(s->name));\n<139> g_free(buf);
<1> static USBPort * xhci_lookup_uport ( XHCIState * xhci , uint32_t * slot_ctx ) {\n<6> if ( port < 1 || port > xhci -> numports ) {\n<10> pos = snprintf ( path , sizeof ( path ) , "%d" , port ) ;\n<20> QTAILQ_FOREACH ( uport , & xhci -> bus . used , next ) {\n<21> if ( strcmp ( uport -> path , path ) == 0 ) {\n<22> return uport ;\n<25> return NULL ;
<9> if ( * buffer == NULL ) return 0 ;\n<10> if ( * currlen > 0 ) {\n<11> assert ( * sbuffer != NULL ) ;\n<12> memcpy ( * buffer , * sbuffer , * currlen ) ;\n<23> if ( * currlen < * maxlen ) {
<1> static int raw_decode ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> const uint8_t * buf = avpkt -> data ;\n<42> else if ( need_copy ) {\n<43> memcpy ( frame -> buf [ 0 ] -> data , buf , FFMIN ( buf_size , context -> frame_size ) ) ;\n<44> buf = frame -> buf [ 0 ] -> data ;\n<49> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<52> context -> palette = av_buffer_alloc ( AVPALETTE_SIZE ) ;\n<53> if ( ! context -> palette ) return AVERROR ( ENOMEM ) ;\n<54> memcpy ( context -> palette -> data , pal , AVPALETTE_SIZE ) ;\n<59> frame -> buf [ 1 ] = av_buffer_ref ( context -> palette ) ;
<1> static int matroska_parse_cluster_incremental ( MatroskaDemuxContext * matroska ) {\n<5> res = ebml_parse ( matroska , matroska_cluster_incremental_parsing , & matroska -> current_cluster ) ;\n<6> if ( res == 1 ) {\n<7> if ( matroska -> current_cluster_pos ) ebml_level_end ( matroska ) ;\n<8> ebml_free ( matroska_cluster , & matroska -> current_cluster ) ;\n<9> memset ( & matroska -> current_cluster , 0 , sizeof ( MatroskaCluster ) ) ;\n<14> res = ebml_parse ( matroska , matroska_clusters_incremental , & matroska -> current_cluster ) ;\n<15> if ( res == 1 ) res = ebml_parse ( matroska , matroska_cluster_incremental_parsing , & matroska -> current_cluster ) ;\n<25> res = matroska_parse_block ( matroska , blocks [ i ] . bin . data , blocks [ i ] . bin . size , blocks [ i ] . bin . pos , matroska -> current_cluster . timecode , blocks [ i ] . duration , is_keyframe , matroska -> current_cluster_pos ) ;
<1> static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) {\n<2> EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n<34> case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ;\n<35> if ( ptr != NULL ) {\n<36> memcpy ( actx -> tag , ptr , arg ) ;\n<37> actx -> tag_len = arg ;\n<40> case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ;\n<41> memcpy ( ptr , actx -> tag , arg ) ;\n<46> unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ;\n<47> len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ;\n<49> if ( len < POLY1305_BLOCK_SIZE ) return 0 ;\n<51> memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;\n<52> aad = temp ;
<1> int inet_listen_opts(QemuOpts *opts, int port_offset)\n<19> memset(&ai,0, sizeof(ai));\n<21> ai.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n<23> ai.ai_family = PF_UNSPEC;\n<25> ai.ai_socktype = SOCK_STREAM;\n<29> if (qemu_opt_get(opts, "port") == NULL) {\n<31> fprintf(stderr, "%s: host and/or port not specified\n", __FUNCTION__);\n<37> pstrcpy(port, sizeof(port), qemu_opt_get(opts, "port"));\n<39> addr = qemu_opt_get(opts, "host");\n<47> ai.ai_family = PF_INET;\n<51> ai.ai_family = PF_INET6;\n<59> snprintf(port, sizeof(port), "%d", atoi(port) + port_offset);\n<61> rc = getaddrinfo(strlen(addr) ? addr : NULL, port, &ai, &res);\n<63> if (rc != 0) {\n<65> fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port,\n<67> gai_strerror(rc));\n<75> inet_print_addrinfo(__FUNCTION__, res);\n<81> for (e = res; e != NULL; e = e->ai_next) {\n<83> getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n<91> if (slisten < 0) {\n<93> fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__,\n<95> inet_strfamily(e->ai_family), strerror(errno));\n<125> if (sockets_debug)\n<127> fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__,\n<129> inet_strfamily(e->ai_family), uaddr, inet_getport(e));\n<137> if (!try_next || sockets_debug)\n<139> fprintf(stderr,"%s: bind(%s,%s,%d): %s\n", __FUNCTION__,\n<141> inet_strfamily(e->ai_family), uaddr, inet_getport(e),\n<143> strerror(errno));\n<161> fprintf(stderr, "%s: FAILED\n", __FUNCTION__);\n<163> freeaddrinfo(res);\n<177> freeaddrinfo(res);\n<185> qemu_opt_set(opts, "host", uaddr);\n<193> freeaddrinfo(res);
<1> static void print_value ( FILE * file , MYSQL_RES * result , MYSQL_ROW row , const char * prefix , const char * name , int string_value ) {\n<5> ( field = mysql_fetch_field ( result ) ) ;\n<6> row ++ ) {\n<7> if ( ! strcmp ( field -> name , name ) ) {\n<8> if ( row [ 0 ] && row [ 0 ] [ 0 ] && strcmp ( row [ 0 ] , "0" ) ) {\n<9> fputc ( ' ' , file ) ;\n<10> fputs ( prefix , file ) ;\n<11> if ( string_value ) unescape ( file , row [ 0 ] , strlen ( row [ 0 ] ) ) ;\n<12> else fputs ( row [ 0 ] , file ) ;\n<13> check_io ( file ) ;\n<14> return ;
<1> static int smka_decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)\n<7> HuffContext h[4];\n<9> VLC vlc[4];\n<47> if ((unp_size << !bits) > *data_size) {\n<57> memset(vlc, 0, sizeof(VLC) * 4);\n<59> memset(h, 0, sizeof(HuffContext) * 4);\n<79> smacker_decode_tree(&gb, &h[i], 0, 0);\n<225> free_vlc(&vlc[i]);
<1> ssize_t e1000e_receive_iov ( E1000ECore * core , const struct iovec * iov , int iovcnt ) {\n<26> if ( size < sizeof ( min_buf ) ) {\n<27> iov_to_buf ( iov , iovcnt , iov_ofs , min_buf , size ) ;\n<28> memset ( & min_buf [ size ] , 0 , sizeof ( min_buf ) - size ) ;
<1> static int process_line(URLContext *h, char *line, int line_count,\n<33> s->http_code = strtol(p, &end, 10);\n<45> if (s->http_code >= 400 && s->http_code < 600 && s->http_code != 401) {\n<47> end += strspn(end, SPACE_CHARS);\n<49> av_log(h, AV_LOG_WARNING, "HTTP error %d %s\n",\n<73> p++;\n<75> while (isspace(*p))\n<77> p++;\n<95> if (!strncmp (p, "bytes ", 6)) {\n<99> s->off = atoll(p);\n<101> if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n<103> s->filesize = atoll(slash+1);\n<109> } else if (!av_strcasecmp(tag, "Accept-Ranges") && !strncmp(p, "bytes", 5)) {\n<113> } else if (!av_strcasecmp (tag, "Transfer-Encoding") && !av_strncasecmp(p, "chunked", 7)) {\n<127> } else if (!av_strcasecmp (tag, "Connection")) {\n<129> if (!strcmp(p, "close"))\n<131> s->willclose = 1;
<1> static int dissect_pbb_addressblock ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , guint offset , guint maxoffset , guint8 addressType , guint8 addressSize ) {\n<2> guint8 addr [ MAX_ADDR_SIZE ] ;\n<15> if ( maxoffset - offset < 2 ) {\n<19> DISSECTOR_ASSERT ( addressSize <= MAX_ADDR_SIZE ) ;\n<20> memset ( addr , 0 , addressSize ) ;\n<23> midSize = addressSize ;\n<33> if ( head_length > addressSize - 1 ) {\n<41> tvb_memcpy ( tvb , addr , offset , head_length ) ;\n<53> if ( tail_length > addressSize - 1 - head_length ) {\n<67> if ( tail_length > addressSize - 1 - head_length ) {\n<75> tvb_memcpy ( tvb , & addr [ addressSize - tail_length ] , offset , tail_length ) ;\n<119> guint8 prefix = addressSize * 8 ;\n<120> tvb_memcpy ( tvb , & addr [ head_length ] , mid_index + midSize * i , midSize ) ;\n<121> ipv4 = ( addr [ 3 ] << 24 ) + ( addr [ 2 ] << 16 ) + ( addr [ 1 ] << 8 ) + addr [ 0 ] ;\n<125> case 1 : addrValue_item = proto_tree_add_ipv6 ( addr_tree , hf_packetbb_addr_value [ addressType ] , tvb , mid_index , block_index + block_length - mid_index , ( struct e_in6_addr * ) addr ) ;\n<127> case 2 : addrValue_item = proto_tree_add_ether ( addr_tree , hf_packetbb_addr_value [ addressType ] , tvb , mid_index , block_index + block_length - mid_index , addr ) ;\n<129> case 3 : addrValue_item = proto_tree_add_bytes ( addr_tree , hf_packetbb_addr_value [ addressType ] , tvb , mid_index , block_index + block_length - mid_index , addr ) ;
<1> void *kvmppc_create_spapr_tce(uint32_t liobn, uint32_t window_size, int *pfd)\n<7> .liobn = liobn,\n<39> if (fd < 0) {\n<41> fprintf(stderr, "KVM: Failed to create TCE table for liobn 0x%x\n",\n<59> if (table == MAP_FAILED) {\n<61> fprintf(stderr, "KVM: Failed to map TCE table for liobn 0x%x\n",
<1> static void set_upstream_server_address ( ngx_http_upstream_t * upstream , ngx_http_upstream_conf_t * upstream_config ) {\n<7> if ( address -> name . data == pp_placeholder_upstream_address . data ) {\n<8> sockaddr = ( struct sockaddr_un * ) address -> sockaddr ;\n<9> request_socket_filename = pp_agents_starter_get_request_socket_filename ( pp_agents_starter , & request_socket_filename_len ) ;\n<12> strncpy ( sockaddr -> sun_path , request_socket_filename , sizeof ( sockaddr -> sun_path ) ) ;
<1> gcry_error_t gcry_pk_sign ( gcry_sexp_t * r_sig , gcry_sexp_t s_hash , gcry_sexp_t s_skey ) {\n<17> if ( ! algo_name || ! * algo_name ) algo_name = pubkey -> name ;\n<18> algo_elems = pubkey -> elements_sig ;\n<21> if ( rc ) goto leave ;\n<22> result = gcry_calloc ( strlen ( algo_elems ) + 1 , sizeof ( * result ) ) ;\n<23> if ( ! result ) {\n<29> if ( ctx . encoding == PUBKEY_ENC_PSS || ctx . encoding == PUBKEY_ENC_PKCS1 ) {\n<40> size_t nelem , needed = strlen ( algo_name ) + 20 ;\n<42> nelem = strlen ( algo_elems ) ;\n<43> needed += 10 * nelem ;\n<45> if ( ! string ) {\n<50> p = stpcpy ( p , algo_name ) ;\n<55> * p ++ = algo_elems [ i ] ;\n<59> arg_list = malloc ( nelem * sizeof * arg_list ) ;\n<60> if ( ! arg_list ) {\n<66> i ++ ) arg_list [ i ] = result + i ;\n<67> rc = gcry_sexp_build_array ( r_sig , NULL , string , arg_list ) ;\n<68> free ( arg_list ) ;
<1> static void setup_rt_frame(int sig, struct target_sigaction *ka,\n<9> fprintf(stderr, "setup_rt_frame: not implemented\n");
<1> static int io_write_data_type(void *opaque, uint8_t *buf, int size,\n<7> char timebuf[30], content[5] = { 0 };\n<13> case AVIO_DATA_MARKER_HEADER:         str = "header";   break;\n<15> case AVIO_DATA_MARKER_SYNC_POINT:     str = "sync";     break;\n<17> case AVIO_DATA_MARKER_BOUNDARY_POINT: str = "boundary"; break;\n<19> case AVIO_DATA_MARKER_UNKNOWN:        str = "unknown";  break;\n<21> case AVIO_DATA_MARKER_TRAILER:        str = "trailer";  break;\n<44> size >= 8)\n<46> memcpy(content, &buf[4], 4);\n<50> snprintf(content, sizeof(content), "-");\n<52> printf("write_data len %d, time %s, type %s atom %s\n", size, timebuf, str, content);\n<54> return io_write(opaque, buf, size);
<1> static void print_report(int is_last_report, int64_t timer_start)\n<5> char buf[1024];\n<31> if (!is_last_report) {\n<47> if ((cur_time - last_time) < 500000)\n<85> buf[0] = '\0';\n<93> float q = -1;\n<101> q = enc->coded_frame->quality / (float)FF_QP2LAMBDA;\n<103> if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<105> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q);\n<109> if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<115> frame_number = ost->frame_number;\n<117> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ",\n<119> frame_number, (t > 1) ? (int)(frame_number / t + 0.5) : 0, q);\n<121> if (is_last_report)\n<123> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L");\n<129> int qp = lrintf(q);\n<135> for (j = 0; j < 32; j++)\n<137> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log2(qp_histogram[j] + 1)));\n<141> if (enc->flags&CODEC_FLAG_PSNR) {\n<149> char type[3] = { 'Y','U','V' };\n<151> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR=");\n<153> for (j = 0; j < 3; j++) {\n<159> scale = enc->width * enc->height * 255.0 * 255.0 * frame_number;\n<177> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[j], psnr(error / scale));\n<181> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum / scale_sum));\n<205> bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n<209> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<213> (double)total_size / 1024, ti1, bitrate);\n<217> if (nb_frames_dup || nb_frames_drop)\n<219> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d",\n<225> av_log(NULL, AV_LOG_INFO, "%s    \r", buf);
<2> MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ;\n<4> if ( avctx == avctx_from ) return 0 ;\n<7> memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ;
<1> void ffv1_clear_slice_state ( FFV1Context * f , FFV1Context * fs ) {\n<6> PlaneContext * p = & fs -> plane [ i ] ;\n<10> if ( f -> initial_states [ p -> quant_table_index ] ) {\n<11> memcpy ( p -> state , f -> initial_states [ p -> quant_table_index ] , CONTEXT_SIZE * p -> context_count ) ;\n<13> else memset ( p -> state , 128 , CONTEXT_SIZE * p -> context_count ) ;
<1> int main ( int argc , char * argv [ ] ) {\n<8> cpio = & _cpio ;\n<9> memset ( cpio , 0 , sizeof ( * cpio ) ) ;\n<29> cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ;\n<30> cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ;\n<31> cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ;\n<32> cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ;\n<33> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ;\n<34> cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ;\n<35> cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ;\n<40> if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , "Out of memory" ) ;\n<41> while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) {\n<158> mode_out ( cpio ) ;\n<165> if ( cpio -> option_list ) mode_list ( cpio ) ;\n<166> else mode_in ( cpio ) ;\n<169> mode_pass ( cpio , * cpio -> argv ) ;\n<176> free ( cpio -> destdir ) ;
<1> static void test_bug28934 ( ) {\n<3> MYSQL_BIND bind [ 5 ] ;\n<11> memset ( & bind , 0 , sizeof ( bind ) ) ;\n<19> myquery ( mysql_stmt_bind_param ( stmt , bind ) ) ;
<1> int ff_oss_audio_open(AVFormatContext *s1, int is_output,\n<13> char *flip = getenv("AUDIO_FLIP_LEFT");\n<25> if (audio_fd < 0) {\n<27> av_log(s1, AV_LOG_ERROR, "%s: %s\n", audio_device, strerror(errno));\n<35> if (flip && *flip == '1') {\n<123> if (err < 0) {\n<125> av_log(s1, AV_LOG_ERROR, "SNDCTL_DSP_SETFMT: %s\n", strerror(errno));\n<137> if (err < 0) {\n<139> av_log(s1, AV_LOG_ERROR, "SNDCTL_DSP_STEREO: %s\n", strerror(errno));\n<151> if (err < 0) {\n<153> av_log(s1, AV_LOG_ERROR, "SNDCTL_DSP_SPEED: %s\n", strerror(errno));
<1> static int lag_decode_arith_plane(LagarithContext *l, uint8_t *dst,\n<3> int width, int height, int stride,\n<5> const uint8_t *src, int src_size)\n<93> for (i = 0; i < height; i++) {\n<95> memcpy(dst + (i * stride), src, width);\n<97> src += width;\n<107> for (i = 0; i < height; i++)\n<109> memset(dst + i * stride, src[1], width);\n<133> lag_pred_line(l, dst, width, stride, i);
<3> int *got_frame, AVPacket *avpkt)\n<9> FlashSVContext *s  = avctx->priv_data;\n<29> init_get_bits(&gb, avpkt->data, buf_size * 8);\n<163> if (s->is_keyframe) {\n<165> s->keyframedata = av_realloc(s->keyframedata, avpkt->size);\n<167> memcpy(s->keyframedata, avpkt->data, avpkt->size);\n<361> for (k = 0; k < cur_blk_height; k++)\n<363> memcpy(s->frame.data[0] + off - k*s->frame.linesize[0] + x_pos*3,\n<365> s->keyframe + off - k*s->frame.linesize[0] + x_pos*3,\n<367> cur_blk_width * 3);\n<397> if (!s->keyframe) {\n<401> if (!s->keyframe) {\n<411> memcpy(s->keyframe, s->frame.data[0], s->frame.linesize[0] * avctx->height);
<1> void test_bitmap_walk ( struct rev_info * revs ) {\n<9> fprintf ( stderr , "Bitmap v%d test (%d entries loaded)\n" , bitmap_git . version , bitmap_git . entry_count ) ;\n<12> if ( pos < kh_end ( bitmap_git . bitmaps ) ) {\n<14> struct ewah_bitmap * bm = lookup_stored_bitmap ( st ) ;\n<15> fprintf ( stderr , "Found bitmap for %s. %d bits / %08x checksum\n" , oid_to_hex ( & root -> oid ) , ( int ) bm -> bit_size , ewah_checksum ( bm ) ) ;\n<29> if ( bitmap_equals ( result , tdata . base ) ) fprintf ( stderr , "OK!\n" ) ;\n<30> else fprintf ( stderr , "Mismatch!\n" ) ;
<1> static void _slurm_rpc_job_sbcast_cred ( slurm_msg_t * msg ) {\n<81> node_addr = xmalloc ( sizeof ( slurm_addr_t ) * node_cnt ) ;\n<82> while ( ( this_node_name = hostlist_shift ( host_list ) ) ) {\n<83> if ( ( node_ptr = find_node_record ( this_node_name ) ) ) {\n<84> memcpy ( & node_addr [ node_inx ++ ] , & node_ptr -> slurm_addr , sizeof ( slurm_addr_t ) ) ;\n<87> error ( "Invalid node %s in Step=%u.%u" , this_node_name , job_ptr -> job_id , step_ptr -> step_id ) ;\n<89> free ( this_node_name ) ;\n<94> if ( ( error_code == SLURM_SUCCESS ) && job_ptr && ! node_addr ) {\n<98> node_addr = xmalloc ( sizeof ( slurm_addr_t ) * node_cnt ) ;\n<99> memcpy ( node_addr , job_ptr -> node_addr , ( sizeof ( slurm_addr_t ) * node_cnt ) ) ;\n<102> if ( error_code || ( job_ptr == NULL ) ) {\n<107> xfree ( node_addr ) ;\n<110> memset ( & sbcast_arg , 0 , sizeof ( sbcast_cred_arg_t ) ) ;\n<123> if ( ( sbcast_cred = create_sbcast_cred ( slurmctld_config . cred_ctx , & sbcast_arg , msg -> protocol_version ) ) == NULL ) {\n<129> if ( job_ptr && ( job_info_msg -> step_id != NO_VAL ) ) {\n<136> job_info_resp_msg . node_addr = node_addr ;
<1> static struct atom_str * to_atom ( const char * s , unsigned short len ) {\n<2> unsigned int hc = hc_str ( s , len ) % atom_table_sz ;\n<5> c ;\n<6> c = c -> next_atom ) if ( c -> str_len == len && ! strncmp ( s , c -> str_dat , len ) ) return c ;\n<7> c = pool_alloc ( sizeof ( struct atom_str ) + len + 1 ) ;\n<9> strncpy ( c -> str_dat , s , len ) ;\n<12> atom_table [ hc ] = c ;\n<14> return c ;
<1> static int vc1_decode_b_mb_intfr(VC1Context *v)\n<175> s->mb_intra = v->is_intra[s->mb_x] = 1;\n<225> vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n<255> s->mb_intra = v->is_intra[s->mb_x] = 0;\n<343> vc1_mc_4mv_chroma4(v, 1, 1, 1);\n<349> vc1_interp_mc(v);\n<383> vc1_mc_4mv_chroma4(v, 1, 1, 1);\n<413> vc1_interp_mc(v);\n<479> vc1_mc_4mv_chroma4(v, dir, dir2, 0);\n<517> vc1_mc_1mv(v, dir);\n<551> pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n<661> vc1_mc_1mv(v, dir);\n<665> vc1_interp_mc(v);\n<673> if (s->mb_x == s->mb_width - 1)\n<675> memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride);
<1> static int decode_frame(AVCodecContext *avctx, void *data,\n<7> SANMVideoContext *ctx = avctx->priv_data;\n<51> switch (sig) {\n<67> ctx->pal[i] = 0xFF << 24 | bytestream2_get_be24u(&ctx->gb);\n<77> if (ret = process_frame_obj(ctx))\n<103> ctx->pal[i] = 0xFF << 24 | AV_RB24(tmp);\n<125> if (size >= 768 * 5 + 4) {\n<129> ctx->pal[i] = 0xFF << 24 | bytestream2_get_be24u(&ctx->gb);\n<133> memset(ctx->pal, 0, sizeof(ctx->pal));\n<149> memcpy(ctx->frm0, ctx->stored_frame, ctx->buf_size);\n<173> if (to_store)\n<175> memcpy(ctx->stored_frame, ctx->frm0, ctx->buf_size);\n<177> if ((ret = copy_output(ctx, NULL)))\n<181> memcpy(ctx->output->data[1], ctx->pal, 1024);\n<245> rotate_bufs(ctx, ctx->rotate_code);
<1> static void http_negative_content_length_test ( void ) {\n<6> fprintf ( stdout , "Testing HTTP Negative Content Length: " ) ;\n<9> if ( evcon == NULL ) {\n<10> fprintf ( stdout , "FAILED\n" ) ;\n<15> if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , "/test" ) == - 1 ) {\n<16> fprintf ( stdout , "FAILED\n" ) ;\n<21> if ( test_ok != 1 ) {\n<22> fprintf ( stdout , "FAILED\n" ) ;\n<25> fprintf ( stdout , "OK\n" ) ;
<1> static int read_access_unit ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<4> MLPDecodeContext * m = avctx -> priv_data ;\n<20> if ( read_major_sync ( m , & gb ) < 0 ) goto error ;\n<74> substr <= m -> max_decoded_substream ;\n<79> memset ( m -> filter_changed , 0 , sizeof ( m -> filter_changed ) ) ;\n<84> if ( read_restart_header ( m , & gb , buf , substr ) < 0 ) goto next_substr ;\n<88> if ( read_decoding_params ( m , & gb , substr ) < 0 ) goto next_substr ;\n<91> if ( ( ret = read_block_data ( m , & gb , substr ) ) < 0 ) return ret ;\n<116> rematrix_channels ( m , m -> max_decoded_substream ) ;\n<117> if ( ( ret = output_data ( m , m -> max_decoded_substream , data , got_frame_ptr ) ) < 0 ) return ret ;
<1> static void json_print_chapter_header(WriterContext *wctx, const char *chapter)\n<11> if (wctx->nb_chapter)\n<13> printf(",");\n<15> json->multiple_entries = !strcmp(chapter, "packets") || !strcmp(chapter, "streams");\n<17> chapter_esc = json_escape_str(chapter);\n<19> printf("\n  \"%s\":%s", chapter_esc ? chapter_esc : "",
<1> int av_grow_packet(AVPacket *pkt, int grow_by)\n<7> av_assert0((unsigned)pkt->size <= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE);\n<29> pkt->data = pkt->buf->data;\n<33> data_offset = pkt->data - pkt->buf->data;\n<43> if (new_size + data_offset > pkt->buf->size) {\n<47> if (ret < 0) {\n<55> pkt->data = pkt->buf->data + data_offset;\n<63> if (!pkt->buf)\n<67> memcpy(pkt->buf->data, pkt->data, pkt->size);\n<69> pkt->data = pkt->buf->data;\n<73> pkt->size += grow_by;\n<75> memset(pkt->data + pkt->size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
<1> static QDict *qmp_check_input_obj(QObject *input_obj, Error **errp)\n<27> for (ent = qdict_first(input_dict); ent; ent = qdict_next(input_dict, ent)){\n<29> const char *arg_name = qdict_entry_key(ent);\n<35> if (!strcmp(arg_name, "execute")) {\n<37> if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n<49> } else if (!strcmp(arg_name, "arguments")) {\n<51> if (qobject_type(arg_obj) != QTYPE_QDICT) {\n<65> error_set(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n<67> return NULL;
<1> void mips_r4k_init (ram_addr_t ram_size, int vga_ram_size,\n<50> fprintf(stderr, "Unable to find CPU definition\n");\n<119> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> void print_object_list ( int list_type ) {\n<11> printf ( "<tr><td colspan=\"2\">\n" ) ;
<1> static NetSocketState *net_socket_fd_init_dgram(VLANState *vlan,\n<35> if (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n<39> if (saddr.sin_addr.s_addr == 0) {\n<41> fprintf(stderr, "qemu: error: init_dgram: fd=%d unbound, "\n<77> fd, strerror(errno));
<1> static int rm_assemble_video_frame(AVFormatContext *s, AVIOContext *pb,\n<5> AVPacket *pkt, int len, int *pseq,\n<143> if(vst->slices != vst->cur_slice) //FIXME find out how to set slices correct from the begin\n<145> memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices,\n<147> vst->videobufpos - 1 - 8*vst->slices);
<1> int tls1_enc ( SSL * s , int send ) {\n<7> if ( send ) {\n<13> rec = & ( s -> s3 -> wrec ) ;\n<14> if ( s -> enc_write_ctx == NULL ) enc = NULL ;\n<20> if ( ivlen > 1 ) {\n<21> if ( rec -> data != rec -> input ) fprintf ( stderr , "%s:%d: rec->data != rec->input\n" , __FILE__ , __LINE__ ) ;\n<22> else if ( RAND_bytes ( rec -> input , ivlen ) <= 0 ) return - 1 ;\n<32> rec = & ( s -> s3 -> rrec ) ;\n<38> memmove ( rec -> data , rec -> input , rec -> length ) ;\n<39> rec -> input = rec -> data ;
<1> void xps_parse_path ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n<16> fz_xml * fill_tag = NULL ;\n<17> fz_xml * stroke_tag = NULL ;\n<52> stroke_line_join_att = fz_xml_att ( root , "StrokeLineJoin" ) ;\n<57> node ;\n<59> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.RenderTransform" ) ) transform_tag = fz_xml_down ( node ) ;\n<60> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.OpacityMask" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n<61> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Clip" ) ) clip_tag = fz_xml_down ( node ) ;\n<62> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Fill" ) ) fill_tag = fz_xml_down ( node ) ;\n<63> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Stroke" ) ) stroke_tag = fz_xml_down ( node ) ;\n<64> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Data" ) ) data_tag = fz_xml_down ( node ) ;\n<72> xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n<73> xps_resolve_resource_reference ( doc , dict , & stroke_att , & stroke_tag , & stroke_uri ) ;\n<75> if ( ! data_att && ! data_tag ) return ;\n<76> if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , "SolidColorBrush" ) ) {\n<77> fill_opacity_att = fz_xml_att ( fill_tag , "Opacity" ) ;\n<78> fill_att = fz_xml_att ( fill_tag , "Color" ) ;\n<79> fill_tag = NULL ;\n<81> if ( stroke_tag && ! strcmp ( fz_xml_tag ( stroke_tag ) , "SolidColorBrush" ) ) {\n<82> stroke_opacity_att = fz_xml_att ( stroke_tag , "Opacity" ) ;\n<83> stroke_att = fz_xml_att ( stroke_tag , "Color" ) ;\n<84> stroke_tag = NULL ;\n<86> if ( stroke_att || stroke_tag ) {\n<100> if ( stroke_line_join_att ) {\n<101> if ( ! strcmp ( stroke_line_join_att , "Miter" ) ) stroke -> linejoin = FZ_LINEJOIN_MITER_XPS ;\n<102> if ( ! strcmp ( stroke_line_join_att , "Round" ) ) stroke -> linejoin = FZ_LINEJOIN_ROUND ;\n<103> if ( ! strcmp ( stroke_line_join_att , "Bevel" ) ) stroke -> linejoin = FZ_LINEJOIN_BEVEL ;\n<136> if ( stroke_path != path && ( fill_att || fill_tag ) ) {\n<153> xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;
<1> static void qio_channel_websock_write_close ( QIOChannelWebsock * ioc , uint16_t code , const char * reason ) {\n<2> buffer_reserve ( & ioc -> rawoutput , 2 + ( reason ? strlen ( reason ) : 0 ) ) ;\n<5> if ( reason ) {\n<6> buffer_append ( & ioc -> rawoutput , reason , strlen ( reason ) ) ;
<1> static void mdct512(AC3MDCTContext *mdct, int32_t *out, int16_t *in)\n<7> int16_t *rot = mdct->rot_tmp;\n<27> memcpy(&rot[n4], &in[0], 3*n4*sizeof(*in));
<1> void av_image_copy_plane(uint8_t       *dst, int dst_linesize,\n<3> const uint8_t *src, int src_linesize,\n<5> int bytewidth, int height)\n<9> if (!dst || !src)\n<15> for (;height > 0; height--) {\n<17> memcpy(dst, src, bytewidth);\n<19> dst += dst_linesize;\n<21> src += src_linesize;
<1> static void selinux_write_opts ( struct seq_file * m , struct security_mnt_opts * opts ) {\n<8> if ( opts -> mnt_opts [ i ] ) has_comma = strchr ( opts -> mnt_opts [ i ] , ',' ) ;\n<29> seq_escape ( m , opts -> mnt_opts [ i ] , "\"\n\\" ) ;
<1> static void test_smbios_ep_table(test_data *data)\n<5> struct smbios_entry_point *ep_table = &data->smbios_ep_table;\n<11> ACPI_READ_ARRAY(ep_table->anchor_string, addr);\n<13> g_assert(!memcmp(ep_table->anchor_string, "_SM_", 4));\n<29> ACPI_READ_ARRAY(ep_table->intermediate_anchor_string, addr);\n<31> g_assert(!memcmp(ep_table->intermediate_anchor_string, "_DMI_", 5));\n<47> g_assert(!acpi_checksum((uint8_t *)ep_table, sizeof *ep_table));\n<49> g_assert(!acpi_checksum((uint8_t *)ep_table + 0x10,
<1> int evhttp_remove_header ( struct evkeyvalq * headers , const char * key ) {\n<4> if ( strcasecmp ( header -> key , key ) == 0 ) break ;\n<6> if ( header == NULL ) return ( - 1 ) ;\n<7> TAILQ_REMOVE ( headers , header , next ) ;\n<8> free ( header -> key ) ;\n<9> free ( header -> value ) ;\n<10> free ( header ) ;
<1> static void virLogSourceUpdate ( virLogSourcePtr source ) {\n<8> i < virLogNbFilters ;\n<9> i ++ ) {\n<10> if ( strstr ( source -> name , virLogFilters [ i ] -> match ) ) {\n<11> priority = virLogFilters [ i ] -> priority ;\n<12> flags = virLogFilters [ i ] -> flags ;
<1> static int ref_picture ( H264Context * h , Picture * dst , Picture * src ) {\n<23> if ( src -> hwaccel_picture_private ) {\n<25> if ( ! dst -> hwaccel_priv_buf ) goto fail ;\n<31> memcpy ( dst -> ref_poc , src -> ref_poc , sizeof ( src -> ref_poc ) ) ;\n<32> memcpy ( dst -> ref_count , src -> ref_count , sizeof ( src -> ref_count ) ) ;
<1> static int read_and_execute ( bool interactive ) {\n<13> if ( ! interactive ) {\n<14> line = batch_readline ( status . line_buff , real_binary_mode ) ;\n<15> if ( line ) {\n<16> line_length = status . line_buff -> read_length ;\n<17> if ( ! real_binary_mode && strlen ( line ) != line_length ) {\n<18> status . exit_status = 1 ;\n<20> msg . append ( "ASCII '\\0' appeared in the statement, but this is not " "allowed unless option --binary-mode is enabled and mysql is " "run in non-interactive mode. Set --binary-mode to 1 if ASCII " "'\\0' is expected. Query: '" ) ;\n<21> msg . append ( glob_buffer ) ;\n<22> msg . append ( line ) ;\n<23> msg . append ( "'." ) ;\n<24> put_info ( msg . c_ptr ( ) , INFO_ERROR ) ;\n<27> if ( ! line_number && ( uchar ) line [ 0 ] == 0xEF && ( uchar ) line [ 1 ] == 0xBB && ( uchar ) line [ 2 ] == 0xBF ) {\n<28> line += 3 ;\n<29> line_length -= 3 ;\n<32> line_number ++ ;\n<33> if ( ! glob_buffer . length ( ) ) status . query_start_line = line_number ;\n<50> if ( line ) free ( line ) ;\n<51> line = readline ( prompt ) ;\n<53> line_length = line ? strlen ( line ) : 0 ;\n<55> if ( ! line ) {\n<60> if ( ( named_cmds || glob_buffer . is_empty ( ) ) && ! ml_comment && ! in_string && ( com = find_command ( line ) ) ) {\n<61> if ( ( * com -> func ) ( & glob_buffer , line ) > 0 ) break ;\n<66> if ( add_line ( glob_buffer , line , line_length , & in_string , & ml_comment , status . line_buff ? status . line_buff -> truncated : 0 ) ) break ;\n<72> if ( com_go ( & glob_buffer , line ) <= 0 ) status . exit_status = 0 ;
<1> int ff_pnm_decode_header(AVCodecContext *avctx, PNMContext * const s)\n<13> s->type= buf1[1]-'0';\n<15> if(buf1[0] != 'P')\n<39> } else if (s->type==7) {\n<53> pnm_get(s, buf1, sizeof(buf1));\n<55> if (!strcmp(buf1, "WIDTH")) {\n<57> pnm_get(s, buf1, sizeof(buf1));\n<59> w = strtol(buf1, NULL, 10);\n<61> } else if (!strcmp(buf1, "HEIGHT")) {\n<63> pnm_get(s, buf1, sizeof(buf1));\n<65> h = strtol(buf1, NULL, 10);\n<67> } else if (!strcmp(buf1, "DEPTH")) {\n<69> pnm_get(s, buf1, sizeof(buf1));\n<71> depth = strtol(buf1, NULL, 10);\n<73> } else if (!strcmp(buf1, "MAXVAL")) {\n<75> pnm_get(s, buf1, sizeof(buf1));\n<77> maxval = strtol(buf1, NULL, 10);\n<79> } else if (!strcmp(buf1, "TUPLTYPE") ||\n<83> !strcmp(buf1, "TUPLETYPE")) {\n<85> pnm_get(s, tuple_type, sizeof(tuple_type));\n<87> } else if (!strcmp(buf1, "ENDHDR")) {\n<93> return -1;\n<101> if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\0' || av_image_check_size(w, h, 0, avctx))
<1> CPUArchState *cpu_copy(CPUArchState *env)\n<5> CPUState *cpu = ENV_GET_CPU(env);\n<9> CPUArchState *new_env = cpu->env_ptr;\n<23> memcpy(new_env, env, sizeof(CPUArchState));\n<51> return new_env;
<1> static void evtag_test ( void ) {\n<2> fprintf ( stdout , "Testing Tagging:\n" ) ;\n<7> fprintf ( stdout , "OK\n" ) ;
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<59> if (ret < 0) {\n<61> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> static void dissect_applemidi_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , guint16 command ) {\n<28> if ( len > 0 ) {\n<29> name = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , offset , len , ENC_UTF_8 | ENC_NA ) ;\n<30> string_size = ( gint ) ( strlen ( name ) + 1 ) ;\n<31> proto_tree_add_item ( applemidi_tree , hf_applemidi_name , tvb , offset , string_size , ENC_UTF_8 | ENC_NA ) ;\n<32> col_append_fstr ( pinfo -> cinfo , COL_INFO , ": peer = \"%s\"" , name ) ;
<1> static int xan_decode_chroma(AVCodecContext *avctx, unsigned chroma_off)\n<5> XanContext *s = avctx->priv_data;\n<43> if (offset >= bytestream2_get_bytes_left(&s->gb)) {\n<55> memset(s->scratch_buffer, 0, s->buffer_size);\n<57> dec_size = xan_unpack(s, s->scratch_buffer, s->buffer_size);
<1> static int mxf_read_header(AVFormatContext *s)\n<5> MXFContext *mxf = s->priv_data;\n<21> if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n<43> if (klv_read_packet(&klv, s->pb) < 0) {\n<47> if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n<59> PRINT_KEY(s, "read header", klv.key);\n<63> if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n<65> IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n<67> IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n<69> IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n<73> if (!mxf->current_partition) {\n<83> if (!mxf->current_partition->essence_offset) {\n<101> round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n<103> round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n<115> mxf->current_partition->essence_offset = avio_tell(s->pb);\n<117> mxf->current_partition->essence_length = klv.length;\n<123> mxf->current_partition->essence_offset = op1a_essence_offset;\n<139> if (mxf_parse_handle_essence(mxf) <= 0)\n<145> } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n<147> klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n<151> if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n<165> for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n<167> if (IS_KLV_KEY(klv.key, metadata->key)) {\n<171> if (klv.key[5] == 0x53) {\n<173> res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n<177> uint64_t next = avio_tell(s->pb) + klv.length;\n<179> res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n<217> avio_skip(s->pb, klv.length);\n<235> mxf_compute_essence_containers(mxf);\n<243> if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n<249> if ((ret = mxf_compute_index_tables(mxf)) < 0)
<1> void tcg_func_start(TCGContext *s)\n<5> tcg_pool_reset(s);\n<13> memset(s->free_temps, 0, sizeof(s->free_temps));
<1> chunk_t x509_build_crlDistributionPoints ( linked_list_t * list , int extn ) {\n<9> while ( enumerator -> enumerate ( enumerator , & cdp ) ) {\n<12> crlIssuer = asn1_wrap ( ASN1_CONTEXT_C_2 , "m" , build_generalName ( cdp -> issuer ) ) ;\n<14> distributionPoint = asn1_wrap ( ASN1_SEQUENCE , "mm" , asn1_wrap ( ASN1_CONTEXT_C_0 , "m" , asn1_wrap ( ASN1_CONTEXT_C_0 , "m" , asn1_wrap ( ASN1_CONTEXT_S_6 , "c" , chunk_create ( cdp -> uri , strlen ( cdp -> uri ) ) ) ) ) , crlIssuer ) ;
<1> void kvm_init_cpu_signals(CPUState *cpu)\n<13> memset(&sigact, 0, sizeof(sigact));\n<17> sigaction(SIG_IPI, &sigact, NULL);\n<35> if (r) {\n<37> fprintf(stderr, "kvm_set_signal_mask: %s\n", strerror(-r));
<55> while ( ( tok = nextpstoken ( wrapper , & dval , tokbuf , tokbufsize ) ) != pt_eof ) {\n<94> if ( tok == pt_unknown ) {\n<95> if ( strcmp ( tokbuf , "Cache" ) == 0 ) tok = pt_setcachedevice ;\n<96> else if ( strcmp ( tokbuf , "SetWid" ) == 0 ) {\n<97> tok = pt_setcharwidth ;\n<98> if ( sp < sizeof ( stack ) / sizeof ( stack [ 0 ] ) ) {\n<103> else if ( strcmp ( tokbuf , "rrcurveto" ) == 0 ) {\n<104> if ( sp >= 6 ) {\n<112> else if ( strcmp ( tokbuf , "FillStroke" ) == 0 ) {\n<113> if ( sp > 0 ) -- sp ;\n<114> tok = linewidth != WIDTH_INHERITED ? pt_stroke : pt_fill ;\n<115> if ( wrapper -> top != NULL && wrapper -> top -> ps != NULL && linewidth != WIDTH_INHERITED ) linewidth /= 10.0 ;\n<117> else if ( strcmp ( tokbuf , "SG" ) == 0 ) {\n<118> if ( linewidth != WIDTH_INHERITED && sp > 1 ) stack [ sp - 2 ] . u . val = stack [ sp - 1 ] . u . val ;\n<119> if ( sp > 0 ) -- sp ;\n<120> if ( sp > 0 ) stack [ sp - 1 ] . u . val = ( stack [ sp - 1 ] . u . val + 99 ) / 198.0 ;\n<121> tok = pt_setgray ;\n<123> else if ( strcmp ( tokbuf , "ShowInt" ) == 0 ) {\n<124> if ( ( ! wrapper -> top -> fogns && sp > 0 && stack [ sp - 1 ] . type == ps_num && stack [ sp - 1 ] . u . val >= 0 && stack [ sp - 1 ] . u . val <= 255 ) || ( wrapper -> top -> fogns && sp > 6 && stack [ sp - 7 ] . type == ps_num && stack [ sp - 7 ] . u . val >= 0 && stack [ sp - 7 ] . u . val <= 255 ) ) {\n<126> memcpy ( ref -> transform , transform , sizeof ( ref -> transform ) ) ;\n<144> else if ( strcmp ( tokbuf , "togNS_" ) == 0 ) {\n<145> wrapper -> top -> fogns = ! wrapper -> top -> fogns ;\n<149> switch ( tok ) {\n<155> case pt_string : if ( sp < sizeof ( stack ) / sizeof ( stack [ 0 ] ) ) {\n<157> stack [ sp ++ ] . u . str = copyn ( tokbuf + 1 , strlen ( tokbuf ) - 2 ) ;\n<180> if ( stack [ sp ] . type == ps_string || stack [ sp ] . type == ps_instr || stack [ sp ] . type == ps_lit ) free ( stack [ sp ] . u . str ) ;\n<186> if ( stack [ sp ] . type == ps_string || stack [ sp ] . type == ps_instr || stack [ sp ] . type == ps_lit ) free ( stack [ sp ] . u . str ) ;\n<304> else if ( stack [ sp - 2 ] . type == ps_bool ) stack [ sp - 2 ] . u . tf = ( stack [ sp - 2 ] . u . tf == stack [ sp - 1 ] . u . tf ) ;\n<305> else stack [ sp - 2 ] . u . tf = strcmp ( stack [ sp - 2 ] . u . str , stack [ sp - 1 ] . u . str ) == 0 ;\n<317> else if ( stack [ sp - 2 ] . type == ps_bool ) cmp = ( stack [ sp - 2 ] . u . tf - stack [ sp - 1 ] . u . tf ) ;\n<318> else cmp = strcmp ( stack [ sp - 2 ] . u . str , stack [ sp - 1 ] . u . str ) ;\n<381> if ( ( ( stack [ sp - 2 ] . type == ps_bool && stack [ sp - 2 ] . u . tf ) || ( stack [ sp - 2 ] . type == ps_num && strstr ( stack [ sp - 1 ] . u . str , "setcachedevice" ) != NULL ) ) && stack [ sp - 1 ] . type == ps_instr ) pushio ( wrapper , NULL , stack [ sp - 1 ] . u . str , 0 ) ;\n<382> if ( stack [ sp - 1 ] . type == ps_string || stack [ sp - 1 ] . type == ps_instr || stack [ sp - 1 ] . type == ps_lit ) free ( stack [ sp - 1 ] . u . str ) ;\n<385> else if ( sp == 1 && stack [ sp - 1 ] . type == ps_instr ) {\n<386> if ( strstr ( stack [ sp - 1 ] . u . str , "setcachedevice" ) != NULL || strstr ( stack [ sp - 1 ] . u . str , "setcharwidth" ) != NULL ) pushio ( wrapper , NULL , stack [ sp - 1 ] . u . str , 0 ) ;\n<387> free ( stack [ sp - 1 ] . u . str ) ;\n<398> if ( stack [ sp - 1 ] . type == ps_string || stack [ sp - 1 ] . type == ps_instr || stack [ sp - 1 ] . type == ps_lit ) free ( stack [ sp - 1 ] . u . str ) ;\n<399> if ( stack [ sp - 2 ] . type == ps_string || stack [ sp - 2 ] . type == ps_instr || stack [ sp - 2 ] . type == ps_lit ) free ( stack [ sp - 2 ] . u . str ) ;\n<407> if ( stack [ sp - 4 ] . type == ps_num && stack [ sp - 3 ] . type == ps_num && stack [ sp - 2 ] . type == ps_num && stack [ sp - 1 ] . type == ps_instr ) {\n<427> free ( func ) ;\n<434> if ( stack [ sp - 1 ] . type == ps_instr ) {\n<439> free ( func ) ;\n<446> if ( stack [ sp - 2 ] . type == ps_num && stack [ sp - 1 ] . type == ps_instr ) {\n<451> free ( func ) ;\n<459> if ( stack [ sp - 1 ] . type == ps_instr ) {\n<463> free ( func ) ;\n<471> if ( kv != NULL ) {\n<472> free ( stack [ sp - 1 ] . u . str ) ;\n<583> case pt_namelit : if ( strcmp ( tokbuf , "CharProcs" ) == 0 && ec != NULL ) {\n<584> HandleType3Reference ( wrapper , ec , transform , tokbuf , tokbufsize ) ;\n<586> else if ( sp < sizeof ( stack ) / sizeof ( stack [ 0 ] ) ) {\n<591> case pt_exec : if ( sp > 0 && stack [ sp - 1 ] . type == ps_lit ) {\n<594> memcpy ( ref -> transform , transform , sizeof ( transform ) ) ;\n<824> case pt_currentdash : if ( sp + 1 < sizeof ( stack ) / sizeof ( stack [ 0 ] ) ) {\n<830> dict . entries = calloc ( i , sizeof ( struct pskeyval ) ) ;\n<979> if ( tok == pt_stroke ) {\n<983> memcpy ( ent -> u . splines . transform , transform , sizeof ( transform ) ) ;\n<1006> if ( stack [ sp ] . type == ps_string || stack [ sp ] . type == ps_instr || stack [ sp ] . type == ps_lit ) free ( stack [ sp ] . u . str ) ;\n<1015> case pt_gsave : if ( gsp < 30 ) {\n<1016> memcpy ( gsaves [ gsp ] . transform , transform , sizeof ( transform ) ) ;\n<1028> case pt_grestore : if ( gsp > 0 ) {\n<1030> memcpy ( transform , gsaves [ gsp ] . transform , sizeof ( transform ) ) ;\n<1121> if ( stack [ sp ] . type == ps_string || stack [ sp ] . type == ps_instr || stack [ sp ] . type == ps_lit ) free ( stack [ sp ] . u . str ) ;\n<1129> if ( ( unsigned ) i == sp ) LogError ( _ ( "No mark in ] (close array)\n" ) ) ;\n<1133> dict . entries = calloc ( i , sizeof ( struct pskeyval ) ) ;\n<1147> case pt_array : if ( sp >= 1 && stack [ sp - 1 ] . type == ps_num ) {\n<1150> dict . entries = calloc ( dict . cnt , sizeof ( struct pskeyval ) ) ;\n<1178> switch ( stack [ sp ] . type ) {\n<1179> case ps_num : printf ( "%g" , ( double ) stack [ sp ] . u . val ) ;\n<1181> case ps_bool : printf ( "%s" , stack [ sp ] . u . tf ? "true" : "false" ) ;\n<1190> case ps_void : printf ( "-- void --" ) ;\n<1192> case ps_array : if ( tok == pt_outputd ) {\n<1198> default : printf ( "-- nostringval --" ) ;\n<1201> if ( tok == pt_output || tok == pt_outputd ) printf ( "\n" ) ;\n<1205> case pt_cvi : case pt_cvr : if ( sp >= 1 && stack [ sp - 1 ] . type == ps_string ) {\n<1207> free ( stack [ sp - 1 ] . u . str ) ;\n<1223> if ( stack [ sp - 2 ] . u . val == 8 ) sprintf ( stack [ sp - 1 ] . u . str , "%o" , ( int ) stack [ sp - 3 ] . u . val ) ;\n<1224> else if ( stack [ sp - 2 ] . u . val == 16 ) sprintf ( stack [ sp - 1 ] . u . str , "%X" , ( int ) stack [ sp - 3 ] . u . val ) ;\n<1225> else sprintf ( stack [ sp - 1 ] . u . str , "%g" , ( double ) stack [ sp - 3 ] . u . val ) ;\n<1231> switch ( stack [ sp ] . type ) {\n<1232> case ps_num : sprintf ( stack [ sp - 1 ] . u . str , "%g" , ( double ) stack [ sp - 2 ] . u . val ) ;\n<1234> case ps_bool : sprintf ( stack [ sp - 1 ] . u . str , "%s" , stack [ sp - 2 ] . u . tf ? "true" : "false" ) ;\n<1236> case ps_string : case ps_instr : case ps_lit : sprintf ( stack [ sp - 1 ] . u . str , "%s" , stack [ sp - 2 ] . u . str ) ;\n<1237> free ( stack [ sp ] . u . str ) ;\n<1239> case ps_void : printf ( "-- void --" ) ;\n<1242> default : sprintf ( stack [ sp - 1 ] . u . str , "-- nostringval --" ) ;\n<1249> case pt_stringop : if ( sp >= 1 && stack [ sp - 1 ] . type == ps_num ) {\n<1251> stack [ sp - 1 ] . u . str = calloc ( stack [ sp - 1 ] . u . val + 1 , 1 ) ;
<1> static int transcode(void)\n<21> if (!(no_packet = av_mallocz(nb_input_files)))\n<113> if (ist->discard || no_packet[ist->file_index])\n<135> if (no_packet_count) {\n<139> memset(no_packet, 0, nb_input_files);\n<161> no_packet[file_index] = 1;\n<169> if (ret < 0) {\n<201> memset(no_packet, 0, nb_input_files);\n<407> av_freep(&no_packet);
<1> static void http_base_test ( void ) {\n<7> fprintf ( stdout , "Testing HTTP Server Event Base: " ) ;\n<13> bufferevent_base_set ( base , bev ) ;\n<14> http_request = "GET /test HTTP/1.1\r\n" "Host: somehost\r\n" "Connection: close\r\n" "\r\n" ;\n<15> bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;\n<17> bufferevent_free ( bev ) ;\n<22> if ( test_ok != 2 ) {\n<23> fprintf ( stdout , "FAILED\n" ) ;\n<26> fprintf ( stdout , "OK\n" ) ;
<1> static int mmap_read_frame(struct video_data *s, void *frame, int64_t *ts)\n<11> memset(&buf, 0, sizeof(struct v4l2_buffer));\n<13> buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n<15> buf.memory = V4L2_MEMORY_MMAP;\n<21> while ((res = ioctl(s->fd, VIDIOC_DQBUF, &buf)) < 0 &&\n<23> ((errno == EAGAIN) || (errno == EINTR)));\n<25> if (res < 0) {\n<27> av_log(NULL, AV_LOG_ERROR, "ioctl(VIDIOC_DQBUF): %s\n", strerror(errno));\n<35> assert (buf.index < s->buffers);\n<37> assert(buf.bytesused == s->frame_size);\n<41> memcpy(frame, s->buf_start[buf.index], buf.bytesused);\n<47> res = ioctl (s->fd, VIDIOC_QBUF, &buf);
<1> static void mpc7_decode_flush ( AVCodecContext * avctx ) {\n<2> MPCContext * c = avctx -> priv_data ;\n<3> memset ( c -> oldDSCF , 0 , sizeof ( c -> oldDSCF ) ) ;
<1> void record_proto_stats ( char * str ) {\n<7> day = now . l_ui / 86400 + MJD_1900 ;\n<9> if ( protostats . fp != NULL ) {\n<10> fprintf ( protostats . fp , "%lu %s %s\n" , day , ulfptoa ( & now , 3 ) , str ) ;\n<11> fflush ( protostats . fp ) ;
<1> void vpx_svc_release ( SvcContext * svc_ctx ) {\n<5> if ( si != NULL ) {\n<6> free ( si ) ;
<1> static void raw ( struct parse * pcmd , FILE * fp ) {\n<3> ( void ) fprintf ( fp , "Output set to raw\n" ) ;
<1> static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)\n<7> SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);\n<93> if (r->req.cmd.xfer == 0) {\n<117> if (r->buflen != r->req.cmd.xfer) {\n<123> r->buf = qemu_malloc(r->req.cmd.xfer);\n<125> r->buflen = r->req.cmd.xfer;\n<131> memset(r->buf, 0, r->buflen);
<1> static int update_rom_mapping ( VAPICROMState * s , CPUX86State * env , target_ulong ip ) {\n<17> if ( paddr != s -> rom_state_paddr ) {\n<21> if ( memcmp ( s -> rom_state . signature , "kvm aPiC" , 8 ) != 0 ) {\n<22> return - 1 ;\n<24> s -> rom_state_vaddr = rom_state_vaddr ;\n<25> if ( rom_state_vaddr == le32_to_cpu ( s -> rom_state . vaddr ) ) {
<1> static int CheckOtherHTTPHeaders ( http_message_t * Req , struct SendInstruction * RespInstr , off_t FileSize ) {\n<6> size_t TmpBufSize = LINE_SIZE ;\n<7> TmpBuf = ( char * ) malloc ( TmpBufSize ) ;\n<8> if ( ! TmpBuf ) return HTTP_INTERNAL_SERVER_ERROR ;\n<10> while ( node != NULL ) {\n<13> if ( header -> value . length >= TmpBufSize ) {\n<14> free ( TmpBuf ) ;\n<15> TmpBufSize = header -> value . length + 1 ;\n<16> TmpBuf = ( char * ) malloc ( TmpBufSize ) ;\n<17> if ( ! TmpBuf ) return HTTP_INTERNAL_SERVER_ERROR ;\n<19> memcpy ( TmpBuf , header -> value . buf , header -> value . length ) ;\n<20> TmpBuf [ header -> value . length ] = '\0' ;\n<22> switch ( Http_Header_Names [ index ] . id ) {\n<25> if ( strlen ( TmpBuf ) > strlen ( "gzip" ) ) {\n<26> if ( StrStr ( TmpBuf , "trailers" ) != NULL ) {\n<32> case HDR_CONTENT_LENGTH : RespInstr -> RecvWriteSize = atoi ( TmpBuf ) ;\n<34> case HDR_RANGE : RetCode = CreateHTTPRangeResponseHeader ( TmpBuf , FileSize , RespInstr ) ;\n<35> if ( RetCode != HTTP_OK ) {\n<36> free ( TmpBuf ) ;\n<40> case HDR_ACCEPT_LANGUAGE : if ( header -> value . length + 1 > sizeof ( RespInstr -> AcceptLanguageHeader ) ) {\n<41> size_t length = sizeof ( RespInstr -> AcceptLanguageHeader ) - 1 ;\n<42> memcpy ( RespInstr -> AcceptLanguageHeader , TmpBuf , length ) ;\n<43> RespInstr -> AcceptLanguageHeader [ length ] = '\0' ;\n<46> memcpy ( RespInstr -> AcceptLanguageHeader , TmpBuf , header -> value . length + 1 ) ;\n<54> free ( TmpBuf ) ;
<1> static void vscsi_send_request_sense(VSCSIState *s, vscsi_req *req)\n<31> if (n < 0) {\n<33> fprintf(stderr, "VSCSI: REQUEST_SENSE wants write data !?!?!?\n");
<1> CURLcode Curl_auth_create_login_message ( struct Curl_easy * data , const char * valuep , char * * outptr , size_t * outlen ) {\n<2> size_t vlen = strlen ( valuep ) ;\n<3> if ( ! vlen ) {\n<4> * outptr = strdup ( "=" ) ;\n<12> return Curl_base64_encode ( data , valuep , vlen , outptr , outlen ) ;
<1> static void flush_packet ( AVFormatContext * s ) {\n<2> ASFContext * asf = s -> priv_data ;\n<7> packet_filled_size = PACKET_SIZE - asf -> packet_size_left ;\n<8> av_assert0 ( packet_hdr_size <= asf -> packet_size_left ) ;\n<9> memset ( asf -> packet_buf + packet_filled_size , 0 , asf -> packet_size_left ) ;
<1> static gboolean register_signal_handlers(void)\n<11> memset(&sigact, 0, sizeof(struct sigaction));\n<17> ret = sigaction(SIGINT, &sigact, NULL);\n<19> if (ret == -1) {\n<21> g_error("error configuring signal handler: %s", strerror(errno));\n<27> ret = sigaction(SIGTERM, &sigact, NULL);\n<29> if (ret == -1) {\n<31> g_error("error configuring signal handler: %s", strerror(errno));\n<39> memset(&sigact_chld, 0, sizeof(struct sigaction));\n<45> ret = sigaction(SIGCHLD, &sigact_chld, NULL);\n<47> if (ret == -1) {\n<49> g_error("error configuring signal handler: %s", strerror(errno));
<1> int ff_hevc_decode_nal_sps(HEVCContext *s)\n<27> if (!sps_buf)\n<31> sps = (HEVCSPS*)sps_buf->data;\n<143> sps->pic_conf_win.left_offset   = get_ue_golomb_long(gb) * 2;\n<145> sps->pic_conf_win.right_offset  = get_ue_golomb_long(gb) * 2;\n<147> sps->pic_conf_win.top_offset    = get_ue_golomb_long(gb) * 2;\n<149> sps->pic_conf_win.bottom_offset = get_ue_golomb_long(gb) * 2;\n<177> sps->pic_conf_win.bottom_offset = 0;\n<181> sps->output_window = sps->pic_conf_win;\n<417> ret = scaling_list_data(s, &sps->scaling_list, sps);\n<487> if ((ret = ff_hevc_decode_short_term_rps(s, &sps->st_rps[i],\n<535> decode_vui(s, sps);\n<613> sps->output_window.right_offset  += sps->vui.def_disp_win.right_offset;\n<615> sps->output_window.top_offset    += sps->vui.def_disp_win.top_offset;\n<617> sps->output_window.bottom_offset += sps->vui.def_disp_win.bottom_offset;\n<621> if (sps->output_window.left_offset & (0x1F >> (sps->pixel_shift)) &&\n<627> av_log(s->avctx, AV_LOG_WARNING, "Reducing left output window to %d "\n<649> if (s->avctx->err_recognition & AV_EF_EXPLODE) {\n<661> memset(&sps->pic_conf_win, 0, sizeof(sps->pic_conf_win));\n<663> memset(&sps->output_window, 0, sizeof(sps->output_window));\n<801> if (s->sps_list[sps_id] &&\n<803> !memcmp(s->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n<805> av_buffer_unref(&sps_buf);\n<817> if (s->sps_list[sps_id] && s->sps == (HEVCSPS*)s->sps_list[sps_id]->data) {\n<821> s->current_sps = av_buffer_ref(s->sps_list[sps_id]);\n<829> av_buffer_unref(&s->sps_list[sps_id]);\n<831> s->sps_list[sps_id] = sps_buf;
<1> bool challenge_h ( connection_t * c ) {\n<2> char buffer [ MAX_STRING_SIZE ] ;\n<4> if ( sscanf ( c -> buffer , "%*d " MAX_STRING , buffer ) != 1 ) {\n<9> if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n<10> logger ( LOG_ERR , "Possible intruder %s (%s): %s" , c -> name , c -> hostname , "wrong challenge length" ) ;\n<11> return false ;\n<13> c -> mychallenge = xrealloc ( c -> mychallenge , len ) ;\n<14> if ( ! hex2bin ( buffer , c -> mychallenge , len ) ) {
<1> static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> Msvideo1Context * s = avctx -> priv_data ;\n<13> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<14> if ( pal ) {\n<15> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<19> if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;\n<20> else msvideo1_decode_16bit ( s ) ;
<1> static void test_pure_coverage ( ) {\n<24> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<29> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,\n<49> response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept);\n<51> responselen = strlen(response);\n<53> buffer_reserve(&ioc->encoutput, responselen);\n<55> buffer_append(&ioc->encoutput, response, responselen);
<21> else if ( data -> set . postfields ) expectsend = ( curl_off_t ) strlen ( data -> set . postfields ) ;\n<31> if ( ( expectsend == - 1 ) || ( expectsend > bytessent ) ) {
<1> static void http_multi_line_header_test ( void ) {\n<7> fprintf ( stdout , "Testing HTTP Server with multi line: " ) ;\n<11> http_start_request = "GET /test HTTP/1.1\r\n" "Host: somehost\r\n" "Connection: close\r\n" "X-Multi: aaaaaaaa\r\n" " a\r\n" "\tEND\r\n" "X-Last: last\r\n" "\r\n" ;\n<12> bufferevent_write ( bev , http_start_request , strlen ( http_start_request ) ) ;\n<17> if ( test_ok != 4 ) {\n<18> fprintf ( stdout , "FAILED\n" ) ;\n<21> fprintf ( stdout , "OK\n" ) ;
<1> lcc_network_buffer_t * lcc_network_buffer_create ( size_t size ) {\n<4> if ( size < 128 ) {\n<8> nb = malloc ( sizeof ( * nb ) ) ;\n<9> if ( nb == NULL ) return ( NULL ) ;\n<10> memset ( nb , 0 , sizeof ( * nb ) ) ;\n<11> nb -> size = size ;\n<12> nb -> buffer = malloc ( nb -> size ) ;\n<13> if ( nb -> buffer == NULL ) {\n<14> free ( nb ) ;\n<17> memset ( nb -> buffer , 0 , nb -> size ) ;\n<18> nb -> ptr = nb -> buffer ;\n<19> nb -> free = nb -> size ;\n<23> return ( nb ) ;
<1> int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,\n<3> const char *buf)\n<9> char new_line[2];\n<15> while (*buf) {\n<17> if (text && callbacks->text &&\n<19> (sscanf(buf, "\\%1[nN]", new_line) == 1 ||\n<21> !strncmp(buf, "{\\", 2))) {\n<29> if (sscanf(buf, "\\%1[nN]", new_line) == 1) {\n<31> if (callbacks->new_line)\n<33> callbacks->new_line(priv, new_line[0] == 'N');\n<35> buf += 2;\n<37> } else if (!strncmp(buf, "{\\", 2)) {\n<39> buf++;\n<41> while (*buf == '\\') {\n<43> char style[2], c[2], sep[2], c_num[2] = "0", tmp[128] = {0};\n<45> unsigned int color = 0xFFFFFFFF;\n<47> int len, size = -1, an = -1, alpha = -1;\n<49> int x1, y1, x2, y2, t1 = -1, t2 = -1;\n<51> if (sscanf(buf, "\\%1[bisu]%1[01\\}]%n", style, c, &len) > 1) {\n<53> int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;\n<55> len += close != -1;\n<57> if (callbacks->style)\n<59> callbacks->style(priv, style[0], close);\n<61> } else if (sscanf(buf, "\\c%1[\\}]%n", sep, &len) > 0 ||\n<63> sscanf(buf, "\\c&H%X&%1[\\}]%n", &color, sep, &len) > 1 ||\n<65> sscanf(buf, "\\%1[1234]c%1[\\}]%n", c_num, sep, &len) > 1 ||\n<67> sscanf(buf, "\\%1[1234]c&H%X&%1[\\}]%n", c_num, &color, sep, &len) > 2) {\n<69> if (callbacks->color)\n<71> callbacks->color(priv, color, c_num[0] - '0');\n<73> } else if (sscanf(buf, "\\alpha%1[\\}]%n", sep, &len) > 0 ||\n<75> sscanf(buf, "\\alpha&H%2X&%1[\\}]%n", &alpha, sep, &len) > 1 ||\n<77> sscanf(buf, "\\%1[1234]a%1[\\}]%n", c_num, sep, &len) > 1 ||\n<79> sscanf(buf, "\\%1[1234]a&H%2X&%1[\\}]%n", c_num, &alpha, sep, &len) > 2) {\n<81> if (callbacks->alpha)\n<83> callbacks->alpha(priv, alpha, c_num[0] - '0');\n<85> } else if (sscanf(buf, "\\fn%1[\\}]%n", sep, &len) > 0 ||\n<87> sscanf(buf, "\\fn%127[^\\}]%1[\\}]%n", tmp, sep, &len) > 1) {\n<89> if (callbacks->font_name)\n<91> callbacks->font_name(priv, tmp[0] ? tmp : NULL);\n<93> } else if (sscanf(buf, "\\fs%1[\\}]%n", sep, &len) > 0 ||\n<95> sscanf(buf, "\\fs%u%1[\\}]%n", &size, sep, &len) > 1) {\n<97> if (callbacks->font_size)\n<99> callbacks->font_size(priv, size);\n<101> } else if (sscanf(buf, "\\a%1[\\}]%n", sep, &len) > 0 ||\n<103> sscanf(buf, "\\a%2u%1[\\}]%n", &an, sep, &len) > 1 ||\n<105> sscanf(buf, "\\an%1[\\}]%n", sep, &len) > 0 ||\n<107> sscanf(buf, "\\an%1u%1[\\}]%n", &an, sep, &len) > 1) {\n<109> if (an != -1 && buf[2] != 'n')\n<111> an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);\n<113> if (callbacks->alignment)\n<115> callbacks->alignment(priv, an);\n<117> } else if (sscanf(buf, "\\r%1[\\}]%n", sep, &len) > 0 ||\n<119> sscanf(buf, "\\r%127[^\\}]%1[\\}]%n", tmp, sep, &len) > 1) {\n<121> if (callbacks->cancel_overrides)\n<123> callbacks->cancel_overrides(priv, tmp);\n<125> } else if (sscanf(buf, "\\move(%d,%d,%d,%d)%1[\\}]%n", &x1, &y1, &x2, &y2, sep, &len) > 4 ||\n<127> sscanf(buf, "\\move(%d,%d,%d,%d,%d,%d)%1[\\}]%n", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {\n<129> if (callbacks->move)\n<131> callbacks->move(priv, x1, y1, x2, y2, t1, t2);\n<133> } else if (sscanf(buf, "\\pos(%d,%d)%1[\\}]%n", &x1, &y1, sep, &len) > 2) {\n<135> if (callbacks->move)\n<137> callbacks->move(priv, x1, y1, x1, y1, -1, -1);\n<139> } else if (sscanf(buf, "\\org(%d,%d)%1[\\}]%n", &x1, &y1, sep, &len) > 2) {\n<141> if (callbacks->origin)\n<143> callbacks->origin(priv, x1, y1);\n<147> len = strcspn(buf+1, "\\}") + 2;  /* skip unknown code */\n<151> buf += len - 1;\n<155> if (*buf++ != '}')\n<171> buf++;
<1> static inline abi_long do_msgrcv(int msqid, abi_long msgp,\n<3> unsigned int msgsz, abi_long msgtyp,\n<19> if (!lock_user_struct(VERIFY_WRITE, target_mb, msgp, 0))\n<25> host_mb = malloc(msgsz+sizeof(long));\n<27> ret = get_errno(msgrcv(msqid, host_mb, msgsz, tswapal(msgtyp), msgflg));\n<31> if (ret > 0) {\n<35> target_mtext = lock_user(VERIFY_WRITE, target_mtext_addr, ret, 0);\n<37> if (!target_mtext) {\n<45> memcpy(target_mb->mtext, host_mb->mtext, ret);\n<47> unlock_user(target_mtext, target_mtext_addr, ret);\n<53> target_mb->mtype = tswapal(host_mb->mtype);\n<55> free(host_mb);\n<63> unlock_user_struct(target_mb, msgp, 1);
<1> int key_update ( key_ref_t key_ref , const void * payload , size_t plen ) {\n<9> if ( ! key -> type -> update ) goto error ;\n<10> memset ( & prep , 0 , sizeof ( prep ) ) ;\n<16> ret = key -> type -> preparse ( & prep ) ;\n<20> ret = key -> type -> update ( key , & prep ) ;\n<23> error : if ( key -> type -> preparse ) key -> type -> free_preparse ( & prep ) ;
<1> static int nntp_attempt_features ( struct NntpServer * nserv ) {\n<43> size_t buflen = 2 * LONG_STRING , off = 0 , b = 0 ;\n<44> if ( nserv -> overview_fmt ) FREE ( & nserv -> overview_fmt ) ;\n<47> if ( buflen - off < LONG_STRING ) {\n<49> mutt_mem_realloc ( & nserv -> overview_fmt , buflen ) ;\n<56> if ( ! cont && ( mutt_str_strcmp ( "." , nserv -> overview_fmt + off ) == 0 ) ) break ;\n<57> cont = chunk >= buflen - off ? 1 : 0 ;\n<58> off += strlen ( nserv -> overview_fmt + off ) ;\n<59> if ( ! cont ) {\n<61> if ( nserv -> overview_fmt [ b ] == ':' ) {\n<62> memmove ( nserv -> overview_fmt + b , nserv -> overview_fmt + b + 1 , off - b - 1 ) ;\n<63> nserv -> overview_fmt [ off - 1 ] = ':' ;\n<65> colon = strchr ( nserv -> overview_fmt + b , ':' ) ;\n<66> if ( ! colon ) nserv -> overview_fmt [ off ++ ] = ':' ;\n<67> else if ( strcmp ( colon + 1 , "full" ) != 0 ) off = colon + 1 - nserv -> overview_fmt ;\n<68> if ( strcasecmp ( nserv -> overview_fmt + b , "Bytes:" ) == 0 ) {\n<69> size_t len = strlen ( nserv -> overview_fmt + b ) ;\n<70> mutt_str_strfcpy ( nserv -> overview_fmt + b , "Content-Length:" , len + 1 ) ;\n<71> off = b + len ;\n<73> nserv -> overview_fmt [ off ++ ] = '\0' ;\n<74> b = off ;\n<77> nserv -> overview_fmt [ off ++ ] = '\0' ;
<1> int qemuMonitorTextCloseFileHandle ( qemuMonitorPtr mon , const char * fdname ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<13> if ( strstr ( reply , "unknown command:" ) ) {\n<14> qemuReportError ( VIR_ERR_OPERATION_INVALID , _ ( "qemu does not support closing of file handles: %s" ) , reply ) ;\n<17> ret = 0 ;\n<19> VIR_FREE ( reply ) ;
<1> static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)\n<21> DPRINTF("Mode Sense (page %d, len %zd)\n", page, req->cmd.xfer);\n<23> memset(outbuf, 0, req->cmd.xfer);\n<25> p = outbuf;\n<135> buflen = p - outbuf;\n<159> if (buflen > req->cmd.xfer)
<1> static void search_for_quantizers_faac(AVCodecContext *avctx, AACEncContext *s,\n<3> SingleChannelElement *sce,\n<85> if (avg_energy == 0.0f) {\n<101> float *coefs   = sce->coeffs + start;\n<117> for (w2 = 0; w2 < sce->ics.group_len[w]; w2++)\n<119> memset(coefs + w2*128, 0, sizeof(coefs[0])*size);\n<129> float t = coefs[w2*128+i]*coefs[w2*128+i];\n<131> maxq[w*16+g] = FFMAX(maxq[w*16+g], fabsf(coefs[w2*128 + i]));\n<173> memset(sce->sf_idx, 0, sizeof(sce->sf_idx));
<1> void ide_exec_cmd(IDEBus *bus, uint32_t val)\n<39> if (!ide_cmd_permitted(s, val)) {\n<89> switch(val) {\n<657> memset(s->io_buffer, 0, 0x200);\n<667> s->io_buffer[0x04] = ide_get_sector(s) >> 16;	/* LBA MSB */\n<669> s->io_buffer[0x05] = ide_get_sector(s) >> 8;	/* LBA */\n<671> s->io_buffer[0x06] = ide_get_sector(s) >> 0;	/* LBA LSB */\n<681> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n<757> switch (s->feature) {\n<831> memset(s->io_buffer, 0, 0x200);\n<851> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n<859> memset(s->io_buffer, 0, 0x200);\n<923> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);\n<931> switch (s->sector) {\n<935> memset(s->io_buffer, 0, 0x200);\n<957> memset(s->io_buffer, 0, 0x200);\n<991> ide_transfer_start(s, s->io_buffer, 0x200, ide_transfer_stop);
<1> static int restore_toc_entry ( ArchiveHandle * AH , TocEntry * te , bool is_parallel ) {\n<7> if ( _tocEntryIsACL ( te ) ) reqs = 0 ;\n<9> if ( ! ropt -> createDB && strcmp ( te -> desc , "DATABASE" ) == 0 ) reqs = 0 ;\n<10> if ( ! ropt -> suppressDumpWarnings && strcmp ( te -> desc , "WARNING" ) == 0 ) {\n<11> if ( ! ropt -> dataOnly && te -> defn != NULL && strlen ( te -> defn ) != 0 ) write_msg ( modulename , "warning from original dump file: %s\n" , te -> defn ) ;\n<12> else if ( te -> copyStmt != NULL && strlen ( te -> copyStmt ) != 0 ) write_msg ( modulename , "warning from original dump file: %s\n" , te -> copyStmt ) ;\n<15> if ( ( reqs & REQ_SCHEMA ) != 0 ) {\n<16> if ( te -> namespace ) ahlog ( AH , 1 , "creating %s \"%s.%s\"\n" , te -> desc , te -> namespace , te -> tag ) ;\n<17> else ahlog ( AH , 1 , "creating %s \"%s\"\n" , te -> desc , te -> tag ) ;\n<18> _printTocEntry ( AH , te , false , false ) ;\n<20> if ( strcmp ( te -> desc , "TABLE" ) == 0 ) {\n<21> if ( AH -> lastErrorTE == te ) {\n<24> else inhibit_data_for_failed_table ( AH , te ) ;\n<29> else mark_create_done ( AH , te ) ;\n<32> if ( strcmp ( te -> desc , "DATABASE" ) == 0 ) {\n<34> initPQExpBuffer ( & connstr ) ;\n<35> appendPQExpBufferStr ( & connstr , "dbname=" ) ;\n<36> appendConnStrVal ( & connstr , te -> tag ) ;\n<37> ahlog ( AH , 1 , "connecting to new database \"%s\"\n" , te -> tag ) ;\n<38> _reconnectToDB ( AH , te -> tag ) ;\n<39> ropt -> dbname = connstr . data ;\n<44> if ( AH -> PrintTocDataPtr != NULL ) {\n<45> _printTocEntry ( AH , te , true , false ) ;\n<46> if ( strcmp ( te -> desc , "BLOBS" ) == 0 || strcmp ( te -> desc , "BLOB COMMENTS" ) == 0 ) {\n<47> ahlog ( AH , 1 , "processing %s\n" , te -> desc ) ;\n<48> _selectOutputSchema ( AH , "pg_catalog" ) ;\n<49> if ( strcmp ( te -> desc , "BLOB COMMENTS" ) == 0 ) AH -> outputKind = OUTPUT_OTHERDATA ;\n<50> ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n<51> AH -> outputKind = OUTPUT_SQLCMDS ;\n<54> _disableTriggersIfNecessary ( AH , te ) ;\n<55> _becomeOwner ( AH , te ) ;\n<56> _selectOutputSchema ( AH , te -> namespace ) ;\n<57> ahlog ( AH , 1 , "processing data for table \"%s.%s\"\n" , te -> namespace , te -> tag ) ;\n<58> if ( is_parallel && te -> created ) {\n<63> if ( te -> copyStmt && strlen ( te -> copyStmt ) > 0 ) {\n<64> ahprintf ( AH , "%s" , te -> copyStmt ) ;\n<65> AH -> outputKind = OUTPUT_COPYDATA ;\n<67> else AH -> outputKind = OUTPUT_OTHERDATA ;\n<68> ( * AH -> PrintTocDataPtr ) ( AH , te ) ;\n<69> if ( AH -> outputKind == OUTPUT_COPYDATA && RestoringToDB ( AH ) ) EndDBCopyMode ( & AH -> public , te -> tag ) ;\n<70> AH -> outputKind = OUTPUT_SQLCMDS ;\n<71> if ( is_parallel && te -> created ) CommitTransaction ( & AH -> public ) ;\n<72> _enableTriggersIfNecessary ( AH , te ) ;\n<77> ahlog ( AH , 1 , "executing %s %s\n" , te -> desc , te -> tag ) ;\n<78> _printTocEntry ( AH , te , false , false ) ;
<1> void server_free_command ( struct iovec * * command ) {\n<4> * arg != NULL ;\n<5> arg ++ ) {\n<6> if ( ( * arg ) -> iov_base != NULL ) free ( ( * arg ) -> iov_base ) ;\n<7> free ( * arg ) ;\n<9> free ( command ) ;
<1> void show_error_msg ( int m6resp , associd_t associd ) {\n<2> if ( numhosts > 1 ) fprintf ( stderr , "server=%s " , currenthost ) ;\n<3> switch ( m6resp ) {\n<4> case CERR_BADFMT : fprintf ( stderr , "***Server reports a bad format request packet\n" ) ;\n<6> case CERR_PERMISSION : fprintf ( stderr , "***Server disallowed request (authentication?)\n" ) ;\n<8> case CERR_BADOP : fprintf ( stderr , "***Server reports a bad opcode in request\n" ) ;\n<10> case CERR_BADASSOC : fprintf ( stderr , "***Association ID %d unknown to server\n" , associd ) ;\n<12> case CERR_UNKNOWNVAR : fprintf ( stderr , "***A request variable unknown to the server\n" ) ;\n<14> case CERR_BADVALUE : fprintf ( stderr , "***Server indicates a request variable was bad\n" ) ;\n<16> case ERR_UNSPEC : fprintf ( stderr , "***Server returned an unspecified error\n" ) ;\n<18> case ERR_TIMEOUT : fprintf ( stderr , "***Request timed out\n" ) ;\n<20> case ERR_INCOMPLETE : fprintf ( stderr , "***Response from server was incomplete\n" ) ;\n<22> case ERR_TOOMUCH : fprintf ( stderr , "***Buffer size exceeded for returned data\n" ) ;\n<24> default : fprintf ( stderr , "***Server returns unknown error code %d\n" , m6resp ) ;
<1> static void load_module(const char *filename)\n<9> dll = dlopen(filename, RTLD_NOW);\n<11> if (!dll) {\n<13> fprintf(stderr, "Could not load module '%s' - %s\n",\n<24> if (!init_func) {
<1> void TSHttpTxnParentProxySet ( TSHttpTxn txnp , const char * hostname , int port ) {\n<6> sm -> t_state . api_info . parent_proxy_name = sm -> t_state . arena . str_store ( hostname , strlen ( hostname ) ) ;
<1> static bool find_cgroup_hierarchies ( struct cgroup_meta_data * meta_data , bool all_kernel_subsystems , bool all_named_subsystems , const char * * subsystem_whitelist ) {\n<3> char * line = NULL ;\n<10> if ( ! proc_self_cgroup ) return false ;\n<11> while ( getline ( & line , & sz , proc_self_cgroup ) != - 1 ) {\n<17> if ( ! line [ 0 ] ) continue ;\n<18> colon1 = strchr ( line , ':' ) ;\n<19> if ( ! colon1 ) continue ;\n<20> * colon1 ++ = '\0' ;\n<21> colon2 = strchr ( colon1 , ':' ) ;\n<22> if ( ! colon2 ) continue ;\n<25> hierarchy_number = strtoul ( line , & colon2 , 10 ) ;\n<32> if ( meta_data -> hierarchies [ hierarchy_number ] ) goto out ;\n<33> h = calloc ( 1 , sizeof ( struct cgroup_hierarchy ) ) ;\n<34> if ( ! h ) goto out ;\n<37> h -> subsystems = lxc_string_split_and_trim ( colon1 , ',' ) ;\n<63> free ( line ) ;
<1> static int qemu_chr_open_pty(QemuOpts *opts, CharDriverState **_chr)\n<35> if (openpty(&s->fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n<55> len = strlen(q_ptsname(s->fd)) + 5;\n<57> chr->filename = g_malloc(len);\n<63> fprintf(stderr, "char device redirected to %s\n", q_ptsname(s->fd));
<1> static void reorder_block ( MPADecodeContext * s , GranuleDef * g ) {\n<4> INTFLOAT tmp [ 576 ] ;\n<14> i < 13 ;\n<17> ptr1 = ptr ;\n<18> dst = tmp ;\n<28> memcpy ( ptr1 , tmp , len * 3 * sizeof ( * ptr1 ) ) ;
<1> static char * pool_strdup ( const char * s ) {\n<2> size_t len = strlen ( s ) + 1 ;\n<3> char * r = pool_alloc ( len ) ;\n<4> memcpy ( r , s , len ) ;\n<5> return r ;
<1> void archive_string_free ( struct archive_string * as ) {\n<4> free ( as -> s ) ;
<1> static int start_transaction ( MYSQL * mysql_con ) {\n<3> if ( ( mysql_get_server_version ( mysql_con ) < 40100 ) && opt_master_data ) {\n<4> fprintf ( stderr , "-- %s: the combination of --single-transaction and " "--master-data requires a MySQL server version of at least 4.1 " "(current server's version is %s). %s\n" , ignore_errors ? "Warning" : "Error" , mysql_con -> server_version ? mysql_con -> server_version : "unknown" , ignore_errors ? "Continuing due to --force, backup may not be consistent across all tables!" : "Aborting." ) ;
<1> static void * Type_Measurement_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n<3> memset ( & mc , 0 , sizeof ( mc ) ) ;\n<10> return _cmsDupMem ( self -> ContextID , & mc , sizeof ( cmsICCMeasurementConditions ) ) ;
<1> static void ohci_td_pkt(const char *msg, const uint8_t *buf, size_t len)\n<15> char *p = tmp;\n<41> p = tmp;\n<43> *p = 0;\n<47> if (i == len) {\n<55> p += sprintf(p, " %.2x", buf[i]);
<1> static struct evhttp_connection * evhttp_get_request_connection ( struct evhttp * http , int fd , struct sockaddr * sa , socklen_t salen ) {\n<3> char * hostname = NULL , * portname = NULL ;\n<4> name_from_addr ( sa , salen , & hostname , & portname ) ;\n<5> if ( hostname == NULL || portname == NULL ) {\n<6> if ( hostname ) free ( hostname ) ;\n<7> if ( portname ) free ( portname ) ;\n<11> evcon = evhttp_connection_new ( hostname , atoi ( portname ) ) ;\n<12> free ( hostname ) ;\n<13> free ( portname ) ;
<1> static int dca_subframe_header(DCAContext *s, int base_channel, int block_index)\n<135> for (j = base_channel; j < s->prim_channels; j++) {\n<145> s->subband_activity[j] * sizeof(s->scale_factor[0][0][0]) * 2);
<1> static int com_edit ( String * buffer , char * line __attribute__ ( ( unused ) ) ) {\n<6> if ( ( fd = create_temp_file ( filename , NullS , "sql" , O_CREAT | O_WRONLY , MYF ( MY_WME ) ) ) < 0 ) goto err ;\n<10> if ( ! ( editor = ( char * ) getenv ( "EDITOR" ) ) && ! ( editor = ( char * ) getenv ( "VISUAL" ) ) ) editor = "vi" ;\n<11> strxmov ( buff , editor , " " , filename , NullS ) ;\n<12> if ( ( error = system ( buff ) ) ) {\n<13> char errmsg [ 100 ] ;\n<14> sprintf ( errmsg , "Command '%.40s' failed" , buff ) ;\n<15> put_info ( errmsg , INFO_ERROR , 0 , NullS ) ;
<1> int wpa_check_MIC ( struct eapol_header * eapol , struct eapol_key_header * eapol_key , size_t eapol_len , u_char * kck , int algo ) {\n<2> u_char mic [ WPA_MICKEY_LEN ] ;\n<5> memcpy ( mic , eapol_key -> key_MIC , WPA_MICKEY_LEN ) ;\n<6> memset ( eapol_key -> key_MIC , 0 , WPA_MICKEY_LEN ) ;\n<7> if ( algo == WPA_KEY_TKIP ) {\n<8> HMAC ( EVP_md5 ( ) , kck , WPA_KCK_LEN , ( u_char * ) eapol , eapol_len , hmac_mic , & len ) ;\n<10> else if ( algo == WPA_KEY_CCMP ) {\n<11> HMAC ( EVP_sha1 ( ) , kck , WPA_KCK_LEN , ( u_char * ) eapol , eapol_len , hmac_mic , & len ) ;\n<14> memcpy ( eapol_key -> key_MIC , mic , WPA_MICKEY_LEN ) ;\n<15> return memcmp ( mic , hmac_mic , WPA_MICKEY_LEN ) ;
<1> void pcnet_h_reset(void *opaque)\n<5> PCNetState *s = opaque;\n<21> memcpy(s->prom, s->conf.macaddr.a, 6);\n<45> *(uint16_t *)&s->prom[12] = cpu_to_le16(checksum);\n<77> pcnet_s_reset(s);\n<79> pcnet_update_irq(s);\n<81> pcnet_poll_timer(s);
<1> static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n<13> if (!dev->conf.bs) {\n<15> fprintf(stderr, "%s: no drive specified\n", qdev->info->name);\n<31> if (bus->master) {\n<33> fprintf(stderr, "ide: tried to assign master twice\n");\n<45> if (bus->slave) {\n<47> fprintf(stderr, "ide: tried to assign slave twice\n");
<1> static int parse_dsd_prop(AVFormatContext *s, AVStream *st, uint64_t eof)\n<63> if (st->codecpar->channels > FF_ARRAY_ELEMS(dsd_layout)) {\n<73> dsd_layout[i] = avio_rl32(pb);\n<77> const DSDLayoutDesc * d = &dsd_channel_layout[i];\n<79> if (av_get_channel_layout_nb_channels(d->layout) == st->codecpar->channels &&\n<81> !memcmp(d->dsd_layout, dsd_layout, st->codecpar->channels * sizeof(uint32_t))) {
<1> static void lsf2lsp_3 ( AMRContext * p ) {\n<3> int16_t lsf_r [ LP_FILTER_ORDER ] ;\n<7> lsf_quantizer = ( p -> cur_frame_mode == MODE_7k95 ? lsf_3_1_MODE_7k95 : lsf_3_1 ) [ lsf_param [ 0 ] ] ;\n<8> memcpy ( lsf_r , lsf_quantizer , 3 * sizeof ( * lsf_r ) ) ;\n<9> lsf_quantizer = lsf_3_2 [ lsf_param [ 1 ] << ( p -> cur_frame_mode <= MODE_5k15 ) ] ;\n<10> memcpy ( lsf_r + 3 , lsf_quantizer , 3 * sizeof ( * lsf_r ) ) ;\n<11> lsf_quantizer = ( p -> cur_frame_mode <= MODE_5k15 ? lsf_3_3_MODE_5k15 : lsf_3_3 ) [ lsf_param [ 2 ] ] ;\n<12> memcpy ( lsf_r + 6 , lsf_quantizer , 4 * sizeof ( * lsf_r ) ) ;\n<15> i ++ ) lsf_q [ i ] = ( lsf_r [ i ] + p -> prev_lsf_r [ i ] * pred_fac [ i ] ) * ( LSF_R_FAC / 8000.0 ) + lsf_3_mean [ i ] * ( 1.0 / 8000.0 ) ;\n<18> memcpy ( p -> prev_lsf_r , lsf_r , LP_FILTER_ORDER * sizeof ( * lsf_r ) ) ;
<1> static int test_decompress_text ( xd3_stream * stream , uint8_t * enc , usize_t enc_size , usize_t test_desize ) {\n<3> char decoded [ sizeof ( test_text ) ] ;\n<15> again : ret = xd3_decode_input ( stream ) ;\n<28> if ( stream -> avail_out != sizeof ( test_text ) ) {\n<34> memcpy ( decoded , stream -> next_out , stream -> avail_out ) ;\n<35> xd3_consume_output ( stream ) ;\n<36> if ( ( ret = xd3_get_appheader ( stream , & apphead , & apphead_size ) ) ) {\n<39> if ( apphead_size != strlen ( ( char * ) test_apphead ) || memcmp ( apphead , test_apphead , strlen ( ( char * ) test_apphead ) ) != 0 ) {\n<40> stream -> msg = "incorrect appheader" ;\n<41> ret = XD3_INTERNAL ;\n<44> if ( ( ret = xd3_decode_input ( stream ) ) != XD3_WINFINISH || ( ret = xd3_close_stream ( stream ) ) != 0 ) {\n<47> if ( decoded_size != sizeof ( test_text ) || memcmp ( decoded , test_text , sizeof ( test_text ) ) != 0 ) {\n<48> stream -> msg = "incorrect output text" ;\n<49> ret = EIO ;\n<52> xd3_free_stream ( stream ) ;\n<54> xd3_config_stream ( stream , & cfg ) ;
<1> static int set_string_binary(void *obj, const AVOption *o, const char *val, uint8_t **dst)\n<9> int len = strlen(val);\n<19> if (len & 1)\n<31> int a = hexchar2int(*val++);
<1> static int vp8_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)\n<15> if (!s->profile)\n<16> memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_epel_pixels_tab,\n<19> memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_bilinear_pixels_tab,\n<36> vp78_reset_probability_tables(s);\n<37> memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter,\n<39> memcpy(s->prob->pred8x8c, vp8_pred8x8c_prob_inter,\n<43> memset(&s->segmentation, 0, sizeof(s->segmentation));\n<44> memset(&s->lf_delta, 0, sizeof(s->lf_delta));\n<54> parse_segment_info(s);\n<62> update_lf_deltas(s);\n<68> if ((ret = vp8_update_dimensions(s, width, height)) < 0)\n<70> vp8_get_quants(s);\n<72> update_refs(s);\n<80> vp78_update_probability_tables(s);\n<87> vp78_update_pred16x16_pred8x8_mvc_probabilities(s, VP8_MVC_SIZE);
<1> int evhttp_make_request ( struct evhttp_connection * evcon , struct evhttp_request * req , enum evhttp_cmd_type type , const char * uri ) {\n<4> if ( req -> uri != NULL ) free ( req -> uri ) ;\n<5> if ( ( req -> uri = strdup ( uri ) ) == NULL ) event_err ( 1 , "%s: strdup" , __func__ ) ;\n<10> assert ( req -> evcon == NULL ) ;\n<13> TAILQ_INSERT_TAIL ( & evcon -> requests , req , next ) ;\n<15> if ( TAILQ_FIRST ( & evcon -> requests ) == req ) evhttp_request_dispatch ( evcon ) ;
<1> static int vobsub_read_header(AVFormatContext *s)\n<5> int i, ret = 0, header_parsed = 0, langidx = 0;\n<23> sub_name = av_strdup(s->filename);\n<25> fname_len = strlen(sub_name);\n<27> ext = sub_name - 3 + fname_len;\n<29> if (fname_len < 4 || *(ext - 1) != '.') {\n<41> memcpy(ext, !strncmp(ext, "IDX", 3) ? "SUB" : "sub", 3);\n<73> line[strcspn(line, "\r\n")] = 0;\n<77> if (!strncmp(line, "id:", 3)) {\n<79> int n, stream_id = 0;\n<81> char id[64] = {0};\n<85> n = sscanf(line, "id: %63[^,], index: %u", id, &stream_id);\n<87> if (n != 2) {\n<89> av_log(s, AV_LOG_WARNING, "Unable to parse index line '%s', "\n<93> strcpy(id, "und");\n<101> if (stream_id >= FF_ARRAY_ELEMS(vobsub->q)) {\n<123> st->id = stream_id;\n<131> av_dict_set(&st->metadata, "language", id, 0);\n<133> av_log(s, AV_LOG_DEBUG, "IDX stream[%d] id=%s\n", stream_id, id);\n<151> if (!s->nb_streams) {\n<163> if (sscanf(p, "%02d:%02d:%02d:%03d, filepos: %"SCNx64,\n<167> av_log(s, AV_LOG_ERROR, "Unable to parse timestamp line '%s', "\n<175> timestamp = (hh*3600LL + mm*60LL + ss) * 1000LL + ms + delay;\n<177> timestamp = av_rescale_q(timestamp, av_make_q(1, 1000), st->time_base);\n<181> sub = ff_subtitles_queue_insert(&vobsub->q[s->nb_streams - 1], "", 0, 0);\n<183> if (!sub) {\n<205> while (*p == ' ')\n<217> } else if (!strncmp(line, "delay:", 6)) {\n<219> int sign = 1, hh = 0, mm = 0, ss = 0, ms = 0;\n<221> const char *p = line + 6;\n<227> p++;\n<229> if (*p == '-' || *p == '+') {\n<231> sign = *p == '-' ? -1 : 1;\n<233> p++;\n<237> sscanf(p, "%d:%d:%d:%d", &hh, &mm, &ss, &ms);\n<239> delay = ((hh*3600LL + mm*60LL + ss) * 1000LL + ms) * sign;\n<243> } else if (!strncmp(line, "langidx:", 8)) {\n<245> const char *p = line + 8;\n<249> if (sscanf(p, "%d", &langidx) != 1)\n<251> av_log(s, AV_LOG_ERROR, "Invalid langidx specified\n");\n<257> if (line[0] && line[0] != '#')\n<267> if (langidx < s->nb_streams)\n<273> for (i = 0; i < s->nb_streams; i++) {\n<283> if (!av_bprint_is_complete(&header)) {
<1> static void cat_blob ( struct object_entry * oe , unsigned char sha1 [ 20 ] ) {\n<7> buf = read_sha1_file ( sha1 , & type , & size ) ;\n<11> buf = gfi_unpack_entry ( oe , & size ) ;\n<13> if ( type <= 0 ) {\n<18> free ( buf ) ;\n<27> cat_blob_write ( buf , size ) ;\n<29> if ( oe && oe -> pack_id == pack_id ) {\n<34> else free ( buf ) ;
<1> void tb_flush(CPUState *cpu)\n<33> CPU_FOREACH(cpu) {\n<35> memset(cpu->tb_jmp_cache, 0, sizeof(cpu->tb_jmp_cache));
<1> static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,\n<31> snprintf(smb_conf, sizeof(smb_conf), "%s/%s", s->smb_dir, "smb.conf");\n<37> if (!f) {\n<91> fclose(f);\n<103> slirp_smb_cleanup(s);
<1> int str_replace ( char * * text , const char * s , const char * d ) {\n<2> size_t slen = strlen ( s ) ;\n<3> size_t dlen = strlen ( d ) ;\n<4> int diff = dlen - slen ;\n<5> char * p , * q = * text ;\n<7> if ( strstr ( * text , s ) == NULL ) return - E_NOTFOUND ;\n<8> while ( ( p = strstr ( q , s ) ) != NULL ) {\n<9> if ( diff > 0 ) size = strlen ( q ) + diff + 1 ;\n<10> else size = strlen ( q ) + 1 ;\n<11> SAFE_REALLOC ( * text , size ) ;\n<12> q = * text ;\n<13> p = strstr ( q , s ) ;\n<14> if ( p == NULL ) continue ;\n<15> memmove ( p + dlen , p + slen , strlen ( p + slen ) + 1 ) ;\n<16> memcpy ( p , d , dlen ) ;\n<17> q = p + dlen ;\n<19> return E_SUCCESS ;
<1> static void set_data_file_type ( SORT_INFO * sort_info , MYISAM_SHARE * share ) {\n<2> if ( ( sort_info -> new_data_file_type = share -> data_file_type ) == COMPRESSED_RECORD && sort_info -> param -> testflag & T_UNPACK ) {\n<4> if ( share -> options & HA_OPTION_PACK_RECORD ) sort_info -> new_data_file_type = DYNAMIC_RECORD ;\n<6> memcpy ( ( char * ) & tmp , share , sizeof ( * share ) ) ;
<1> int main ( int argc , char * argv [ ] ) {\n<4> if ( argc <= 1 ) {\n<5> printf ( "Usage: %s [filename]...\n" , argv [ 0 ] ) ;\n<17> if ( arg > 1 ) {\n<18> printf ( "\n" ) ;\n<20> file = fopen ( filename , "rb" ) ;\n<21> if ( file == NULL ) {\n<22> printf ( "Cannot open file \"%s\"\n\n" , filename ) ;\n<25> printf ( "%s:\n" , filename ) ;\n<32> match < matchCount ;\n<34> const char * name = ucsdet_getName ( csm [ match ] , & status ) ;\n<36> int32_t confidence = ucsdet_getConfidence ( csm [ match ] , & status ) ;\n<37> if ( lang == NULL || strlen ( lang ) == 0 ) {\n<38> lang = "**" ;\n<40> printf ( "%s (%s) %d\n" , name , lang , confidence ) ;
<1> void append_field ( DYNAMIC_STRING * ds , uint col_idx , MYSQL_FIELD * field , char * val , ulonglong len , my_bool is_null ) {\n<3> if ( col_idx < max_replace_column && replace_column [ col_idx ] ) {\n<4> val = replace_column [ col_idx ] ;\n<5> len = strlen ( val ) ;\n<27> replace_dynstr_append_mem ( ds , val , ( int ) len ) ;
<1> static void parse_from_existing ( struct branch * b ) {\n<2> if ( is_null_sha1 ( b -> sha1 ) ) {\n<10> parse_from_commit ( b , buf , size ) ;\n<11> free ( buf ) ;
<1> static int matroska_read_header(AVFormatContext *s)\n<21> Ebml ebml = { 0 };\n<65> for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)\n<67> if (!strcmp(ebml.doctype, matroska_doctypes[i]))\n<71> if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {\n<73> av_log(s, AV_LOG_WARNING, "Unknown EBML doctype '%s'\n", ebml.doctype);\n<77> ebml_free(ebml_syntax, &ebml);\n<131> MatroskaTrack *track = &tracks[i];\n<143> int extradata_offset = 0;\n<169> if (track->codec_id == NULL)\n<235> uint8_t *codec_priv = track->codec_priv.data;\n<237> int offset = matroska_decode_buffer(&track->codec_priv.data,\n<253> } else if (offset > 0) {\n<255> track->codec_priv.data = av_malloc(track->codec_priv.size + offset);\n<261> memcpy(track->codec_priv.data+offset, codec_priv,\n<265> track->codec_priv.size += offset;\n<269> if (codec_priv != track->codec_priv.data)\n<279> for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n<281> if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n<283> strlen(ff_mkv_codec_tags[j].str))){\n<297> if (st == NULL)\n<303> if (!strcmp(track->codec_id, "V_MS/VFW/FOURCC")\n<305> && track->codec_priv.size >= 40\n<307> && track->codec_priv.data != NULL) {\n<309> track->ms_compat = 1;\n<311> fourcc = AV_RL32(track->codec_priv.data + 16);\n<313> codec_id = ff_codec_get_id(ff_codec_bmp_tags, fourcc);\n<315> extradata_offset = 40;\n<317> } else if (!strcmp(track->codec_id, "A_MS/ACM")\n<319> && track->codec_priv.size >= 14\n<321> && track->codec_priv.data != NULL) {\n<325> ffio_init_context(&b, track->codec_priv.data, track->codec_priv.size,\n<329> ret = ff_get_wav_header(&b, st->codec, track->codec_priv.size);\n<331> if (ret < 0)\n<337> extradata_offset = FFMIN(track->codec_priv.size, 18);\n<339> } else if (!strcmp(track->codec_id, "V_QUICKTIME")\n<341> && (track->codec_priv.size >= 86)\n<343> && (track->codec_priv.data != NULL)) {\n<345> fourcc = AV_RL32(track->codec_priv.data);\n<347> codec_id = ff_codec_get_id(ff_codec_movvideo_tags, fourcc);\n<349> } else if (codec_id == CODEC_ID_PCM_S16BE) {\n<361> } else if (codec_id == CODEC_ID_PCM_S16LE) {\n<373> } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {\n<379> int profile = matroska_aac_profile(track->codec_id);\n<385> if (extradata == NULL)\n<393> if (strstr(track->codec_id, "SBR")) {\n<395> sri = matroska_aac_sri(track->audio.out_samplerate);\n<397> extradata[2] = 0x56;\n<399> extradata[3] = 0xE5;\n<401> extradata[4] = 0x80 | (sri<<3);\n<403> extradata_size = 5;\n<407> extradata_size = 2;\n<409> } else if (codec_id == CODEC_ID_TTA) {\n<415> if (extradata == NULL)\n<439> extradata_offset = 26;\n<493> extradata_offset = 78;\n<499> track->codec_priv.size -= extradata_offset;\n<503> if (codec_id == CODEC_ID_NONE)\n<511> if (track->time_scale < 0.01)\n<515> avpriv_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n<519> st->codec->codec_id = codec_id;\n<521> st->start_time = 0;\n<523> if (strcmp(track->language, "und"))\n<525> av_dict_set(&st->metadata, "language", track->language, 0);\n<527> av_dict_set(&st->metadata, "title", track->name, 0);\n<531> if (track->flag_default)\n<535> if (track->flag_forced)\n<541> if (!st->codec->extradata) {\n<549> } else if(track->codec_priv.data && track->codec_priv.size > 0){\n<555> if(st->codec->extradata == NULL)\n<667> if (!(attachements[j].filename && attachements[j].mime &&\n<669> attachements[j].bin.data && attachements[j].bin.size > 0)) {\n<691> if(st->codec->extradata == NULL)\n<697> memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);\n<701> for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {\n<703> if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n<705> strlen(ff_mkv_mime_tags[i].str))) {
<1> void trace_init_file(const char *file)\n<25> if (file) {
<1> void CloseArchive ( Archive * AHX ) {\n<7> if ( res != 0 ) exit_horribly ( modulename , "could not close output file: %s\n" , strerror ( errno ) ) ;
<1> static void qemu_rbd_complete_aio(RADOSCB *rcb)\n<31> if (r < 0) {\n<33> memset(rcb->buf, 0, rcb->size);\n<39> } else if (r < rcb->size) {\n<41> memset(rcb->buf + r, 0, rcb->size - r);\n<63> g_free(rcb);
<1> static void display_sorted_nicks ( CHANNEL_REC * channel , GSList * nicklist ) {\n<13> max_width = window -> width ;\n<15> stripped = strip_codes ( format ) ;\n<16> item_extra = strlen ( stripped ) ;\n<17> g_free ( stripped ) ;\n<19> if ( settings_get_int ( "names_max_width" ) > 0 && settings_get_int ( "names_max_width" ) < max_width ) max_width = settings_get_int ( "names_max_width" ) ;\n<22> if ( format != NULL ) {\n<23> stripped = strip_codes ( format ) ;\n<24> max_width -= strlen ( stripped ) ;\n<25> g_free ( stripped ) ;\n<29> if ( prefix_format != NULL ) {\n<30> stripped = strip_codes ( prefix_format ) ;\n<31> max_width -= strlen ( stripped ) ;\n<32> g_free ( stripped ) ;\n<34> if ( max_width <= 0 ) {\n<37> cols = get_max_column_count ( nicklist , get_nick_length , max_width , settings_get_int ( "names_max_columns" ) , item_extra , 3 , & columns , & rows ) ;\n<41> str = g_string_new ( prefix_format ) ;\n<53> g_string_append ( str , format ) ;\n<58> g_string_truncate ( str , 0 ) ;\n<59> if ( prefix_format != NULL ) g_string_assign ( str , prefix_format ) ;\n<65> if ( prefix_format != NULL && str -> len > strlen ( prefix_format ) ) {\n<66> printtext ( channel -> server , channel -> visible_name , MSGLEVEL_CLIENTCRAP , "%s" , str -> str ) ;\n<69> g_string_free ( str , TRUE ) ;\n<71> g_free_not_null ( prefix_format ) ;
<1> static char * safeGetICUDataDirectory ( ) {\n<4> if ( dataDir != NULL ) {\n<5> retStr = ( char * ) malloc ( strlen ( dataDir ) + 1 ) ;\n<6> strcpy ( retStr , dataDir ) ;
<1> static gcry_err_code_t sexp_data_to_mpi ( gcry_sexp_t input , gcry_mpi_t * ret_mpi , struct pk_encoding_ctx * ctx ) {\n<23> if ( ! s ) ;\n<24> else if ( n == 7 && ! memcmp ( s , "rfc6979" , 7 ) ) parsed_flags |= PUBKEY_FLAG_RFC6979 ;\n<25> else if ( n == 5 && ! memcmp ( s , "eddsa" , 5 ) ) {\n<26> ctx -> encoding = PUBKEY_ENC_RAW ;\n<27> parsed_flags |= PUBKEY_FLAG_EDDSA ;\n<29> else if ( n == 3 && ! memcmp ( s , "raw" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n<30> ctx -> encoding = PUBKEY_ENC_RAW ;\n<31> explicit_raw = 1 ;\n<33> else if ( n == 5 && ! memcmp ( s , "pkcs1" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n<34> else if ( n == 4 && ! memcmp ( s , "oaep" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n<35> else if ( n == 3 && ! memcmp ( s , "pss" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PSS ;\n<36> else if ( n == 11 && ! memcmp ( s , "no-blinding" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n<37> else unknown_flag = 1 ;\n<114> s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n<115> if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n<117> random_override = gcry_malloc ( n ) ;\n<118> if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n<120> memcpy ( random_override , s , n ) ;\n<121> random_override_len = n ;\n<127> rc = pkcs1_encode_for_encryption ( ret_mpi , ctx -> nbits , value , valuelen , random_override , random_override_len ) ;\n<164> s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n<165> if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n<167> ctx -> label = gcry_malloc ( n ) ;\n<168> if ( ! ctx -> label ) rc = gpg_err_code_from_syserror ( ) ;\n<170> memcpy ( ctx -> label , s , n ) ;\n<171> ctx -> labellen = n ;\n<179> s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n<180> if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n<181> else if ( n > 0 ) {\n<182> random_override = gcry_malloc ( n ) ;\n<183> if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n<185> memcpy ( random_override , s , n ) ;\n<186> random_override_len = n ;\n<192> rc = oaep_encode ( ret_mpi , ctx -> nbits , ctx -> hash_algo , value , valuelen , ctx -> label , ctx -> labellen , random_override , random_override_len ) ;\n<221> s = gcry_sexp_nth_data ( list , 1 , & n ) ;\n<222> if ( ! s ) rc = GPG_ERR_NO_OBJ ;\n<224> random_override = gcry_malloc ( n ) ;\n<225> if ( ! random_override ) rc = gpg_err_code_from_syserror ( ) ;\n<227> memcpy ( random_override , s , n ) ;\n<228> random_override_len = n ;\n<234> rc = pss_encode ( ret_mpi , ctx -> nbits - 1 , ctx -> hash_algo , value , valuelen , ctx -> saltlen , random_override , random_override_len ) ;\n<259> gcry_free ( ctx -> label ) ;
<1> static int parse_cookie(HTTPContext *s, const char *p, AVDictionary **cookies)\n<15> if (parse_set_cookie(p, &new_params))\n<36> if ((e = av_dict_get(new_params, "expires", NULL, 0)) && e->value) {\n<40> if (!parse_set_cookie_expiry_time(e->value, &new_tm)) {\n<61> if (e2 && e2->value) {\n<65> if (!parse_set_cookie(p, &old_params)) {\n<69> if (e2 && e2->value) {\n<73> if (!parse_set_cookie_expiry_time(e->value, &old_tm)) {\n<75> if (av_timegm(&new_tm) < av_timegm(&old_tm)) {\n<103> if (!(eql = strchr(p, '='))) return AVERROR(EINVAL);\n<105> if (!(name = av_strndup(p, eql - p))) return AVERROR(ENOMEM);
<1> int kvm_init(int smp_cpus)\n<15> if (s->fd == -1) {\n<16> fprintf(stderr, "Could not access KVM kernel module: %m\n");\n<21> if (ret < KVM_API_VERSION) {\n<23> fprintf(stderr, "kvm version too old\n");\n<26> if (ret > KVM_API_VERSION) {\n<28> fprintf(stderr, "kvm version not supported\n");\n<40> if (ret <= 0) {\n<43> fprintf(stderr, "kvm does not support KVM_CAP_USER_MEMORY\n");\n<51> if (ret <= 0) {
<1> static int vc1_decode_i_block_adv ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int codingset , int mquant ) {\n<47> ac_val2 = ac_val ;\n<49> if ( dc_pred_dir ) ac_val -= 16 ;\n<50> else ac_val -= 16 * s -> block_wrap [ n ] ;\n<57> if ( coded ) {\n<125> memset ( ac_val2 , 0 , 16 * 2 ) ;\n<127> if ( use_pred ) {\n<128> memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n<135> k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n<140> if ( use_pred ) {\n<141> memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n<148> k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n<157> block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n<165> block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;
<1> int lcc_network_buffer_set_security_level ( lcc_network_buffer_t * nb , lcc_security_level_t level , const char * username , const char * password ) {\n<4> if ( level == NONE ) {\n<5> free ( nb -> username ) ;\n<6> free ( nb -> password ) ;\n<13> if ( ! have_gcrypt ( ) ) return ( ENOTSUP ) ;\n<14> username_copy = strdup ( username ) ;\n<15> password_copy = strdup ( password ) ;\n<16> if ( ( username_copy == NULL ) || ( password_copy == NULL ) ) {\n<17> free ( username_copy ) ;\n<18> free ( password_copy ) ;\n<21> free ( nb -> username ) ;\n<22> free ( nb -> password ) ;\n<24> nb -> password = password_copy ;
<1> void cpu_loop(CPUAlphaState *env)\n<15> trapnr = cpu_alpha_exec (env);\n<25> env->intr_flag = 0;\n<29> switch (trapnr) {\n<33> fprintf(stderr, "Reset requested. Exit\n");\n<41> fprintf(stderr, "Machine check exception. Exit\n");\n<53> fprintf(stderr, "External interrupt. Exit\n");\n<355> printf ("Unhandled trap: 0x%x\n", trapnr);\n<357> cpu_dump_state(env, stderr, fprintf, 0);\n<363> process_pending_signals (env);
<1> static void flush_encoders(void)\n<11> OutputStream   *ost = output_streams[i];\n<99> finish_output_stream(ost);\n<105> ret = init_output_stream(ost, error, sizeof(error));\n<141> avcodec_send_frame(enc, NULL);\n<187> ret = avcodec_receive_packet(enc, &pkt);\n<203> if (ost->logfile && enc->stats_out) {\n<205> fprintf(ost->logfile, "%s", enc->stats_out);\n<227> output_packet(of, &pkt, ost);\n<231> do_video_stats(ost, pkt_size);
<1> void vbe_ioport_write_data(void *opaque, uint32_t addr, uint32_t val)\n<93> vbe_fixup_regs(s);\n<99> if (!(val & VBE_DISPI_NOCLEARMEM)) {\n<103> s->vbe_regs[VBE_DISPI_INDEX_YRES] * s->vbe_line_offset);\n<183> vga_update_memory_access(s);
<1> static void * get_delta ( struct object_entry * entry ) {\n<9> delta_buf = diff_delta ( base_buf , base_size , buf , size , & delta_size , 0 ) ;\n<11> free ( buf ) ;\n<12> free ( base_buf ) ;
<1> static void *do_touch_pages(void *arg)\n<7> char *addr = memset_args->addr;\n<35> for (i = 0; i < numpages; i++) {\n<37> memset(addr, 0, 1);\n<39> addr += hpagesize;
<1> static void rtsp_cmd_setup(HTTPContext *c, const char *url,\n<31> path = path1;\n<33> if (*path == '/')\n<35> path++;\n<41> for(stream = first_stream; stream != NULL; stream = stream->next) {\n<43> if (!stream->is_feed && !strcmp(stream->fmt->name, "rtp")) {\n<47> if (!strcmp(path, stream->filename)) {\n<49> if (stream->nb_streams != 1) {\n<65> for(stream_index = 0; stream_index < stream->nb_streams;\n<67> stream_index++) {\n<73> if (!strcmp(path, buf))\n<95> if (h->session_id[0] == '\0')\n<105> rtp_c = find_rtp_session(h->session_id);\n<107> if (!rtp_c) {\n<129> rtp_c = rtp_new_connection(&c->from_addr, stream, h->session_id,\n<161> if (rtp_c->stream != stream) {
<1> static void warn_or_exit_on_errorv ( vpx_codec_ctx_t * ctx , int fatal , const char * s , va_list ap ) {\n<2> if ( ctx -> err ) {\n<3> const char * detail = vpx_codec_error_detail ( ctx ) ;\n<4> vfprintf ( stderr , s , ap ) ;\n<5> fprintf ( stderr , ": %s\n" , vpx_codec_error ( ctx ) ) ;\n<6> if ( detail ) fprintf ( stderr , " %s\n" , detail ) ;
<1> int tls_construct_server_key_exchange ( SSL * s ) {\n<27> n += 2 ;\n<28> if ( s -> cert -> psk_identity_hint ) n += strlen ( s -> cert -> psk_identity_hint ) ;
<1> static int _write_path_table ( struct archive_write * a , int type_m , int depth , struct vdd * vdd ) {\n<10> bp = wb - 1 ;\n<17> np = ptbl [ i ] ;\n<18> if ( np -> identifier == NULL ) len = 1 ;\n<19> else len = np -> id_len ;\n<21> r = wb_consume ( a , ( bp + 1 ) - wb ) ;\n<25> bp = wb - 1 ;\n<33> if ( np -> identifier == NULL ) bp [ 9 ] = 0 ;\n<34> else memcpy ( & bp [ 9 ] , np -> identifier , len ) ;\n<35> if ( len & 0x01 ) {\n<36> bp [ 9 + len ] = 0 ;\n<40> bp += 8 + len ;\n<42> if ( ( bp + 1 ) > wb ) {\n<43> r = wb_consume ( a , ( bp + 1 ) - wb ) ;
<1> static int vpc_open(BlockDriverState *bs, QDict *options, int flags,\n<89> if (vpc_checksum(s->footer_buf, HEADER_SIZE) != checksum)\n<91> fprintf(stderr, "block-vpc: The header checksum of '%s' is "
<1> static void ivshmem_read(void *opaque, const uint8_t *buf, int size)\n<15> if (fifo8_is_empty(&s->incoming_fifo) && size == sizeof(incoming_posn)) {\n<17> memcpy(&incoming_posn, buf, size);\n<33> if (fifo8_num_used(&s->incoming_fifo) < sizeof(incoming_posn)) {\n<43> p = fifo8_pop_buf(&s->incoming_fifo, sizeof(incoming_posn), &num);\n<47> memcpy(&incoming_posn, p, sizeof(incoming_posn));\n<59> if (incoming_posn < -1) {\n<61> IVSHMEM_DPRINTF("invalid incoming_posn %ld\n", incoming_posn);\n<73> IVSHMEM_DPRINTF("posn is %ld, fd is %d\n", incoming_posn, tmp_fd);\n<79> if (incoming_posn >= s->nb_peers) {\n<81> if (increase_dynamic_storage(s, incoming_posn) < 0) {\n<102> if ((incoming_posn >= 0) &&\n<108> s->vm_id = incoming_posn;\n<116> IVSHMEM_DPRINTF("posn %ld has gone away\n", incoming_posn);\n<118> close_guest_eventfds(s, incoming_posn);\n<134> if (incoming_fd == -1) {\n<136> fprintf(stderr, "could not allocate file descriptor %s\n",\n<138> strerror(errno));\n<149> if (incoming_posn == -1) {\n<225> IVSHMEM_DPRINTF("eventfds[%ld][%d] = %d\n", incoming_posn,\n<243> if (incoming_posn > s->max_peer) {\n<245> s->max_peer = incoming_posn;\n<251> if (incoming_posn == s->vm_id) {\n<265> ivshmem_add_eventfd(s, incoming_posn, guest_max_eventfd);
<1> static bool init_global_datetime_format ( timestamp_type format_type , DATE_TIME_FORMAT * format ) {\n<2> format -> format . length = strlen ( format -> format . str ) ;\n<3> if ( parse_date_time_format ( format_type , format ) ) {\n<4> fprintf ( stderr , "Wrong date/time format specifier: %s\n" , format -> format . str ) ;
<1> void usage_exit ( ) {\n<3> fprintf ( stderr , "Usage: %s <options> -o dst_filename src_filename \n" , exec_name ) ;\n<4> fprintf ( stderr , "\nOptions:\n" ) ;\n<5> arg_show_usage ( stderr , main_args ) ;\n<6> fprintf ( stderr , "\nEncoder Global Options:\n" ) ;\n<7> arg_show_usage ( stderr , global_args ) ;\n<8> fprintf ( stderr , "\nRate Control Options:\n" ) ;\n<9> arg_show_usage ( stderr , rc_args ) ;\n<10> fprintf ( stderr , "\nTwopass Rate Control Options:\n" ) ;\n<11> arg_show_usage ( stderr , rc_twopass_args ) ;\n<12> fprintf ( stderr , "\nKeyframe Placement Options:\n" ) ;\n<13> arg_show_usage ( stderr , kf_args ) ;\n<17> arg_show_usage ( stderr , vp9_args ) ;\n<19> fprintf ( stderr , "\nIncluded encoders:\n\n" ) ;\n<21> i < get_vpx_encoder_count ( ) ;\n<23> const VpxInterface * const encoder = get_vpx_encoder_by_index ( i ) ;\n<24> fprintf ( stderr , " %-6s - %s\n" , encoder -> name , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;
<1> static int img_amend(int argc, char **argv)\n<243> if (ret < 0) {\n<245> error_report("Error while amending options: %s", strerror(-ret));
<1> static int disas_cp14_write(CPUState * env, DisasContext *s, uint32_t insn)\n<5> int crn = (insn >> 16) & 0xf;\n<7> int crm = insn & 0xf;\n<9> int op1 = (insn >> 21) & 7;\n<11> int op2 = (insn >> 5) & 7;\n<19> if (arm_feature(env, ARM_FEATURE_THUMB2EE)) {\n<21> if (op1 == 6 && crn == 0 && crm == 0 && op2 == 0) {\n<39> if (op1 == 6 && crn == 1 && crm == 0 && op2 == 0) {\n<57> fprintf(stderr, "Unknown cp14 write op1:%d crn:%d crm:%d op2:%d\n",
<1> static void validate_stream_config ( const struct stream_state * stream , const struct VpxEncoderConfig * global ) {\n<14> if ( streami != stream ) {\n<15> const char * a = stream -> config . out_fn ;\n<16> const char * b = streami -> config . out_fn ;\n<17> if ( ! strcmp ( a , b ) && strcmp ( a , "/devull" ) && strcmp ( a , ":nul" ) ) fatal ( "Stream %d: duplicate output file (from stream %d)" , streami -> index , stream -> index ) ;\n<19> if ( streami != stream ) {\n<22> if ( a && b && ! strcmp ( a , b ) ) fatal ( "Stream %d: duplicate stats file (from stream %d)" , streami -> index , stream -> index ) ;
<3> int *got_frame_ptr, AVPacket *avpkt)\n<7> BinkAudioContext *s = avctx->priv_data;\n<31> if (avpkt->size < 4) {\n<41> if (!buf)\n<46> s->packet_buffer = buf;\n<48> memcpy(s->packet_buffer, avpkt->data, avpkt->size);\n<50> if ((ret = init_get_bits8(gb, s->packet_buffer, avpkt->size)) < 0)
<9> j < i ;\n<10> j ++ ) if ( ! memcmp ( h -> pps . scaling_matrix4 [ j ] , h -> pps . scaling_matrix4 [ i ] , * sizeof ( uint8_t ) ) ) {\n<11> h -> dequant4_coeff [ i ] = h -> dequant4_buffer [ j ] ;\n<22> x ++ ) h -> dequant4_coeff [ i ] [ q ] [ ( x >> 2 ) | ( ( x << 2 ) & 0xF ) ] = ( ( uint32_t ) dequant4_coeff_init [ idx ] [ ( x & 1 ) + ( ( x >> 2 ) & 1 ) ] * h -> pps . scaling_matrix4 [ i ] [ x ] ) << shift ;
<1> void kadmin_getprincs ( int argc , char * argv [ ] ) {\n<6> if ( ! ( argc == 1 || ( argc == 2 && ( expr = argv [ 1 ] ) ) ) ) {\n<7> fprintf ( stderr , _ ( "usage: get_principals [expression]\n" ) ) ;\n<16> i < count ;\n<17> i ++ ) printf ( "%s\n" , names [ i ] ) ;\n<18> kadm5_free_name_list ( handle , names , count ) ;
<1> void qcow2_free_clusters(BlockDriverState *bs,\n<15> if (ret < 0) {\n<17> fprintf(stderr, "qcow2_free_clusters failed: %s\n", strerror(-ret));
<1> void ff_h264_remove_all_refs(H264Context *h)\n<11> remove_long(h, i, 0);\n<21> ff_h264_unref_picture(h, &h->last_pic_for_ec);\n<25> ff_h264_ref_picture(h, &h->last_pic_for_ec, h->short_ref[0]);\n<33> unreference_pic(h, h->short_ref[i], 0);\n<43> memset(h->default_ref, 0, sizeof(h->default_ref));
<1> VALUE asn1time_to_time ( const ASN1_TIME * time ) {\n<5> if ( ! time || ! time -> data ) return Qnil ;\n<6> memset ( & tm , 0 , sizeof ( struct tm ) ) ;\n<7> switch ( time -> type ) {\n<8> case V_ASN1_UTCTIME : count = sscanf ( ( const char * ) time -> data , "%2d%2d%2d%2d%2d%2dZ" , & tm . tm_year , & tm . tm_mon , & tm . tm_mday , & tm . tm_hour , & tm . tm_min , & tm . tm_sec ) ;\n<9> if ( count == 5 ) {\n<15> if ( tm . tm_year < 69 ) {\n<16> tm . tm_year += 2000 ;\n<19> tm . tm_year += 1900 ;\n<22> case V_ASN1_GENERALIZEDTIME : if ( sscanf ( ( const char * ) time -> data , "%4d%2d%2d%2d%2d%2dZ" , & tm . tm_year , & tm . tm_mon , & tm . tm_mday , & tm . tm_hour , & tm . tm_min , & tm . tm_sec ) != 6 ) {\n<23> ossl_raise ( rb_eTypeError , "bad GENERALIZEDTIME format" ) ;\n<29> argv [ 0 ] = INT2NUM ( tm . tm_year ) ;\n<30> argv [ 1 ] = INT2NUM ( tm . tm_mon ) ;\n<31> argv [ 2 ] = INT2NUM ( tm . tm_mday ) ;\n<32> argv [ 3 ] = INT2NUM ( tm . tm_hour ) ;\n<33> argv [ 4 ] = INT2NUM ( tm . tm_min ) ;\n<34> argv [ 5 ] = INT2NUM ( tm . tm_sec ) ;
<1> static int init_report(const char *env)\n<31> if ((ret = av_opt_get_key_value(&env, "=", ":", 0, &key, &val)) < 0) {\n<51> if (!strcmp(key, "file")) {\n<53> filename_template = val;\n<55> val = NULL;\n<59> av_log(NULL, AV_LOG_ERROR, "Unknown key '%s' in FFREPORT\n", key);\n<65> av_free(key);\n<87> if (!report_file) {\n<89> av_log(NULL, AV_LOG_ERROR, "Failed to open report \"%s\": %s\n",\n<91> filename.str, strerror(errno));\n<93> return AVERROR(errno);
<23> if (!c)\n<87> if (!c->filter_bank)\n<91> if (build_filter(c, (void*)c->filter_bank, factor, c->filter_length, c->filter_alloc, phase_count, 1<<c->filter_shift, filter_type, kaiser_beta))\n<95> memcpy(c->filter_bank + (c->filter_alloc*phase_count+1)*c->felem_size, c->filter_bank, (c->filter_alloc-1)*c->felem_size);\n<97> memcpy(c->filter_bank + (c->filter_alloc*phase_count  )*c->felem_size, c->filter_bank + (c->filter_alloc - 1)*c->felem_size, c->felem_size);\n<119> return c;\n<123> av_free(c->filter_bank);\n<125> av_free(c);
<1> int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,\n<5> unsigned int codec_data_size, const uint8_t *mime)\n<69> } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n<87> } else if(mime && !strcmp(mime, "logical-fileinfo")){\n<91> ff_free_stream(s, st);\n<93> if (avio_rb16(pb) != 0) {\n<145> if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n<217> size = avio_tell(pb) - codec_pos;\n<219> avio_skip(pb, codec_data_size - size);\n<223> return 0;
<1> int jbig2_data_in ( Jbig2Ctx * ctx , const unsigned char * data , size_t size ) {\n<3> if ( ctx -> buf == NULL ) {\n<6> while ( buf_size < size ) ;\n<7> ctx -> buf = jbig2_new ( ctx , byte , buf_size ) ;\n<8> if ( ctx -> buf == NULL ) {\n<13> ctx -> buf_wr_ix = 0 ;\n<15> else if ( ctx -> buf_wr_ix + size > ctx -> buf_size ) {\n<16> if ( ctx -> buf_rd_ix <= ( ctx -> buf_size >> 1 ) && ctx -> buf_wr_ix - ctx -> buf_rd_ix + size <= ctx -> buf_size ) {\n<17> memmove ( ctx -> buf , ctx -> buf + ctx -> buf_rd_ix , ctx -> buf_wr_ix - ctx -> buf_rd_ix ) ;\n<23> while ( buf_size < ctx -> buf_wr_ix - ctx -> buf_rd_ix + size ) ;\n<24> buf = jbig2_new ( ctx , byte , buf_size ) ;\n<25> if ( buf == NULL ) {\n<28> memcpy ( buf , ctx -> buf + ctx -> buf_rd_ix , ctx -> buf_wr_ix - ctx -> buf_rd_ix ) ;\n<30> ctx -> buf = buf ;\n<33> ctx -> buf_wr_ix -= ctx -> buf_rd_ix ;\n<36> memcpy ( ctx -> buf + ctx -> buf_wr_ix , data , size ) ;\n<37> ctx -> buf_wr_ix += size ;\n<48> case JBIG2_FILE_HEADER : if ( ctx -> buf_wr_ix - ctx -> buf_rd_ix < 9 ) return 0 ;\n<49> if ( memcmp ( ctx -> buf + ctx -> buf_rd_ix , jbig2_id_string , 8 ) ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , - 1 , "Not a JBIG2 file header" ) ;\n<50> ctx -> file_header_flags = ctx -> buf [ ctx -> buf_rd_ix + 8 ] ;\n<51> if ( ctx -> file_header_flags & 0xFC ) {\n<52> jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , - 1 , "reserved bits (2-7) of file header flags are not zero (0x%02x)" , ctx -> file_header_flags ) ;\n<54> if ( ! ( ctx -> file_header_flags & 2 ) ) {\n<67> jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , "file header indicates sequential organization" ) ;\n<71> jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , "file header indicates random-access organization" ) ;\n<74> case JBIG2_FILE_SEQUENTIAL_HEADER : case JBIG2_FILE_RANDOM_HEADERS : segment = jbig2_parse_segment_header ( ctx , ctx -> buf + ctx -> buf_rd_ix , ctx -> buf_wr_ix - ctx -> buf_rd_ix , & header_size ) ;\n<86> code = jbig2_parse_segment ( ctx , segment , ctx -> buf + ctx -> buf_rd_ix ) ;\n<101> return jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , - 1 , "Garbage beyond end of file" ) ;
<1> static void ppc_heathrow_init (ram_addr_t ram_size,\n<65> if (!env) {\n<67> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<89> if (ram_size > (2047 << 20)) {\n<95> ((unsigned int)ram_size / (1 << 20)));\n<155> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n<169> if (vga_bios_size < 0) {\n<173> fprintf(stderr, "qemu: warning: could not load VGA bios '%s'\n",\n<349> if (ppc_boot_device == '\0') {\n<351> fprintf(stderr, "No valid boot device for G3 Beige machine\n");\n<435> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<437> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static void test_prepare_alter ( ) {\n<16> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<21> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static int enable_write_target(BDRVVVFATState *s, Error **errp)\n<11> int size = sector2cluster(s, s->sector_count);\n<13> s->used_clusters = calloc(size, 1);\n<86> *(void**)s->bs->backing_hd->opaque = s;
<1> static sd_rsp_type_t sd_app_command(SDState *sd,\n<3> SDRequest req)\n<7> DPRINTF("ACMD%d 0x%08x\n", req.cmd, req.arg);\n<13> switch (sd->state) {\n<37> switch (sd->state) {\n<63> switch (sd->state) {\n<93> switch (sd->state) {\n<123> switch (sd->state) {\n<151> switch (sd->state) {\n<173> switch (sd->state) {\n<209> fprintf(stderr, "SD: ACMD%i in a wrong state\n", req.cmd);
<1> static struct isofile * isofile_new ( struct archive_write * a , struct archive_entry * entry ) {\n<3> file = calloc ( 1 , sizeof ( * file ) ) ;\n<4> if ( file == NULL ) return ( NULL ) ;\n<7> if ( file -> entry == NULL ) {\n<8> free ( file ) ;
<1> int ff_h264_decode_ref_pic_list_reordering(H264Context *h, H264SliceContext *sl)\n<177> if (i < 0) {\n<183> memset(&sl->ref_list[list][index], 0, sizeof(sl->ref_list[0][0])); // FIXME\n<205> ref_from_h264pic(&sl->ref_list[list][index], ref);\n<209> pic_as_field(&sl->ref_list[list][index], pic_structure);
<1> static int rtp_packetize_vp8 ( sout_stream_id_sys_t * id , block_t * in ) {\n<4> uint8_t * p_data = in -> p_buffer ;\n<13> int i_payload = __MIN ( i_max , i_data ) ;\n<15> if ( out == NULL ) {\n<22> memcpy ( & out -> p_buffer [ RTP_VP8_PAYLOAD_START ] , p_data , i_payload ) ;\n<26> p_data += i_payload ;\n<27> i_data -= i_payload ;
<1> static void residual_interp(int16_t *buf, int16_t *out, int lag,\n<9> if (lag) { /* Voiced */\n<33> memset(buf, 0, (FRAME_LEN + PITCH_MAX) * sizeof(*buf));
<1> static void test_prepare_grant ( ) {\n<18> if ( ! opt_silent ) fprintf ( stdout , "\n Establishing a test connection ..." ) ;\n<29> if ( ! opt_silent ) fprintf ( stdout , "OK" ) ;
<1> int gs_main_set_lib_paths ( gs_main_instance * minst ) {\n<2> ref * paths = minst -> lib_path . container . value . refs ;\n<8> if ( ! ( first_is_here || ( r_size ( & minst -> lib_path . list ) != 0 && ! bytes_compare ( ( const byte * ) gp_current_directory_name , strlen ( gp_current_directory_name ) , paths [ 0 ] . value . bytes , r_size ( & paths [ 0 ] ) ) ) ) ) {\n<9> memmove ( paths + 1 , paths , count * sizeof ( * paths ) ) ;\n<10> make_const_string ( paths , avm_foreign | a_readonly , strlen ( gp_current_directory_name ) , ( const byte * ) gp_current_directory_name ) ;\n<14> if ( first_is_here ) memmove ( paths , paths + 1 , count * sizeof ( * paths ) ) ;\n<19> i < gx_io_device_table_count ;\n<20> i ++ ) {\n<22> const char * dname = iodev -> dname ;\n<23> if ( dname && strlen ( dname ) == 5 && ! memcmp ( "%rom%" , dname , 5 ) ) {\n<25> int code = iodev -> procs . file_status ( ( gx_io_device * ) iodev , dname , & pstat ) ;\n<26> if ( code != gs_error_unregistered ) {
<1> relpRetVal relpTcpSetCACert ( relpTcp_t * pThis , char * cert ) {\n<3> RELPOBJ_assert ( pThis , Tcp ) ;\n<4> free ( pThis -> caCertFile ) ;\n<5> if ( cert == NULL ) {\n<9> if ( ( pThis -> caCertFile = strdup ( cert ) ) == NULL ) ABORT_FINALIZE ( RELP_RET_OUT_OF_MEMORY ) ;
<1> void cpu_reset (CPUMIPSState *env)\n<3> memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n<4> tlb_flush(env, 1);
<1> static void ctl_putunqstr ( const char * tag , const char * data , size_t len ) {\n<2> char buffer [ 512 ] ;\n<5> tl = strlen ( tag ) ;\n<6> memcpy ( buffer , tag , tl ) ;\n<7> cp = buffer + tl ;\n<8> if ( len > 0 ) {\n<9> INSIST ( tl + 1 + len <= sizeof ( buffer ) ) ;\n<10> * cp ++ = '=' ;\n<11> memcpy ( cp , data , len ) ;\n<12> cp += len ;\n<14> ctl_putdata ( buffer , ( u_int ) ( cp - buffer ) , 0 ) ;
<1> static void copy_video_props(AVFilterBufferRefVideoProps *dst, AVFilterBufferRefVideoProps *src) {\n<5> if (src->qp_table) {\n<9> dst->qp_table = av_malloc(qsize);\n<11> memcpy(dst->qp_table, src->qp_table, qsize);
<1> static int decode_init_thread_copy(AVCodecContext *avctx)\n<5> H264Context *h = avctx->priv_data;\n<9> if (!avctx->internal->is_copy)\n<13> memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n<15> memset(h->pps_buffers, 0, sizeof(h->pps_buffers));
<1> static void apply_channel_coupling(AC3EncodeContext *s)\n<25> memset(cpl_coords,       0, AC3_MAX_BLOCKS * sizeof(*cpl_coords));\n<53> CoefType *cpl_coef = &block->mdct_coef[CPL_CH][cpl_start];\n<55> if (!block->cpl_in_use)\n<59> memset(cpl_coef, 0, num_cpl_coefs * sizeof(*cpl_coef));\n<71> cpl_coef[i] += ch_coef[i];\n<79> clip_coefficients(&s->dsp, cpl_coef, num_cpl_coefs);\n<159> for (blk = 0; blk < s->num_blocks; blk++) {\n<161> AC3Block *block  = &s->blocks[blk];\n<167> memset(block->new_cpl_coords, 0, sizeof(block->new_cpl_coords));\n<187> block->new_cpl_coords[ch] = 1;\n<199> block->new_cpl_coords[ch] = 1;\n<217> block->new_cpl_coords[ch] = 1;
<1> static int mss4_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> MSS4Context * c = avctx -> priv_data ;\n<43> if ( frame_type == SKIP_FRAME ) {\n<60> memset ( c -> prev_vec , 0 , sizeof ( c -> prev_vec ) ) ;\n<62> y < mb_height ;\n<64> memset ( c -> dc_cache , 0 , sizeof ( c -> dc_cache ) ) ;\n<70> case DCT_BLOCK : if ( mss4_decode_dct_block ( c , & gb , dst , x , y ) < 0 ) {\n<75> case IMAGE_BLOCK : if ( mss4_decode_image_block ( c , & gb , dst , x , y ) < 0 ) {\n<86> if ( blk_type != DCT_BLOCK ) mss4_update_dc_cache ( c , x ) ;
<1> static void default_print_section_footer ( WriterContext * wctx ) {\n<6> if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "[/%s]\n" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;
<1> static char * * decode_args ( char * args , int * nargs ) {\n<6> if ( ( p = strrchr ( args , ')' ) ) != NULL ) * p = '\0' ;\n<8> * args == ' ' ;\n<9> args ++ ) ;\n<10> for ( q = args + strlen ( args ) - 1 ;\n<12> q -- ) * q = '\0' ;\n<13> if ( ! strchr ( args , ',' ) && strlen ( args ) == 0 ) return NULL ;\n<14> SAFE_CALLOC ( parsed , 1 , sizeof ( char * ) ) ;\n<15> for ( p = strsep_quotes ( & args , ',' ) , i = 1 ;\n<16> p != NULL ;\n<17> p = strsep_quotes ( & args , ',' ) , i ++ ) {\n<18> SAFE_REALLOC ( parsed , ( i + 1 ) * sizeof ( char * ) ) ;\n<19> for ( arg = p ;\n<20> * arg == ' ' ;\n<21> arg ++ ) ;\n<22> for ( q = arg + strlen ( arg ) - 1 ;\n<24> q -- ) * q = '\0' ;\n<25> if ( * arg == '\"' && arg [ strlen ( arg ) - 1 ] == '\"' ) {\n<26> arg [ strlen ( arg ) - 1 ] = '\0' ;\n<27> arg ++ ;\n<29> parsed [ i - 1 ] = strdup ( arg ) ;\n<30> ef_debug ( 5 , "ARGUMENT: %s\n" , arg ) ;\n<32> * nargs = i - 1 ;\n<33> return parsed ;
<1> static int fourxm_read_packet(AVFormatContext *s,\n<33> if ((ret = get_buffer(&s->pb, header, 8)) < 0)\n<37> fourcc_tag = LE_32(&header[0]);\n<39> size = LE_32(&header[4]);\n<77> if (av_new_packet(pkt, size + 8))\n<85> memcpy(pkt->data, header, 8);\n<87> ret = get_buffer(&s->pb, &pkt->data[8], size);\n<93> av_free_packet(pkt);\n<117> if (av_new_packet(pkt, size))\n<127> ret = get_buffer(&s->pb, pkt->data, size);
<1> void IGDdata ( void * d , const char * data , int l ) {\n<2> struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n<3> char * dstmember = 0 ;\n<4> if ( ! strcmp ( datas -> cureltname , "URLBase" ) ) dstmember = datas -> urlbase ;\n<5> else if ( ! strcmp ( datas -> cureltname , "presentationURL" ) ) dstmember = datas -> presentationurl ;\n<6> else if ( ! strcmp ( datas -> cureltname , "serviceType" ) ) dstmember = datas -> tmp . servicetype ;\n<7> else if ( ! strcmp ( datas -> cureltname , "controlURL" ) ) dstmember = datas -> tmp . controlurl ;\n<8> else if ( ! strcmp ( datas -> cureltname , "eventSubURL" ) ) dstmember = datas -> tmp . eventsuburl ;\n<9> else if ( ! strcmp ( datas -> cureltname , "SCPDURL" ) ) dstmember = datas -> tmp . scpdurl ;\n<10> if ( dstmember ) {\n<11> if ( l >= MINIUPNPC_URL_MAXSIZE ) l = MINIUPNPC_URL_MAXSIZE - 1 ;\n<12> memcpy ( dstmember , data , l ) ;
<1> int write_output ( void ) {\n<9> if ( ninst == 0 ) return - E_INVALID ;\n<11> ON_ERROR ( fd , - 1 , "Can't create file %s" , EF_GBL_OPTIONS -> output_file ) ;\n<12> fprintf ( stdout , " Writing output to \'%s\' " , EF_GBL_OPTIONS -> output_file ) ;\n<13> fflush ( stdout ) ;\n<15> strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;\n<27> fprintf ( stdout , " done.\n\n" ) ;\n<28> fprintf ( stdout , " -> Script encoded into %d instructions.\n\n" , ( int ) ( i - 1 ) ) ;
<1> static void process_tns_coeffs(TemporalNoiseShaping *tns, double *coef_raw,\n<11> float *lpc = tns->coef[w][filt];\n<13> float temp[TNS_MAX_ORDER] = {0.0f}, out[TNS_MAX_ORDER] = {0.0f};\n<17> if (!order)\n<29> lpc[i] = tns_tmp2_map_0_4[idx[i]];\n<41> if (lpc[i] != 0.0 ) {\n<55> out[0] = 1.0f;\n<61> temp[j] = out[j] + lpc[i]*out[i-j];\n<67> out[j] = temp[j];\n<71> out[i] = lpc[i-1];\n<77> memcpy(lpc, out, TNS_MAX_ORDER*sizeof(float));
<1> static const char * canonical_charset_name ( const char * charset ) {\n<2> char cs [ 16 ] ;\n<5> if ( charset == NULL || charset [ 0 ] == '\0' || strlen ( charset ) > 15 ) return ( charset ) ;\n<7> s = charset ;\n<14> if ( strcmp ( cs , "UTF-8" ) == 0 || strcmp ( cs , "UTF8" ) == 0 ) return ( "UTF-8" ) ;\n<15> if ( strcmp ( cs , "UTF-16BE" ) == 0 || strcmp ( cs , "UTF16BE" ) == 0 ) return ( "UTF-16BE" ) ;\n<16> if ( strcmp ( cs , "UTF-16LE" ) == 0 || strcmp ( cs , "UTF16LE" ) == 0 ) return ( "UTF-16LE" ) ;\n<17> if ( strcmp ( cs , "CP932" ) == 0 ) return ( "CP932" ) ;\n<18> return ( charset ) ;
<1> CURLcode Curl_add_buffer_send ( Curl_send_buffer * in , struct connectdata * conn , long * bytes_written , size_t included_body_bytes , int socketindex ) {\n<16> result = Curl_convert_to_network ( conn -> data , ptr , headersize ) ;\n<21> if ( ( conn -> handler -> flags & PROTOPT_SSL ) && conn -> httpversion != 20 ) {\n<22> sendsize = ( size > CURL_MAX_WRITE_SIZE ) ? CURL_MAX_WRITE_SIZE : size ;\n<23> memcpy ( conn -> data -> state . uploadbuffer , ptr , sendsize ) ;\n<24> ptr = conn -> data -> state . uploadbuffer ;\n<27> result = Curl_write ( conn , sockfd , ptr , sendsize , & amount ) ;
<1> void av_free(void *ptr)\n<17> free(ptr);
<1> TSReturnCode TSMimeHdrFieldCreateNamed ( TSMBuffer bufp , TSMLoc mh_mloc , const char * name , int name_len , TSMLoc * locp ) {\n<9> if ( name_len == - 1 ) {\n<10> name_len = strlen ( name ) ;\n<15> h -> field_ptr = mime_field_create_named ( heap , mh , name , name_len ) ;
<1> static void * DefaultAllocFunc ( void * opaque , size_t size ) {\n<3> return malloc ( size ) ;
<1> static void test_multiple_events_for_same_fd ( void ) {\n<10> write ( pair [ 1 ] , TEST1 , strlen ( TEST1 ) + 1 ) ;
<1> int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,\n<15> if (color_string[0] == '#') {\n<19> } else if (!strncmp(color_string, "0x", 2))\n<25> if (slen < 0)\n<27> slen = strlen(color_string);\n<29> av_strlcpy(color_string2, color_string + hex_offset,\n<31> FFMIN(slen-hex_offset+1, sizeof(color_string2)));\n<33> if ((tail = strchr(color_string2, ALPHA_SEP)))\n<35> *tail++ = 0;\n<37> len = strlen(color_string2);\n<39> rgba_color[3] = 255;\n<43> if (!av_strcasecmp(color_string2, "random") || !av_strcasecmp(color_string2, "bikeshed")) {\n<57> strspn(color_string2, "0123456789ABCDEFabcdef") == len) {\n<61> unsigned int rgba = strtoul(color_string2, &tail, 16);\n<65> if (*tail || (len != 6 && len != 8)) {\n<73> if (len == 8) {\n<99> if (!entry) {\n<107> memcpy(rgba_color, entry->rgb_color, 3);\n<117> const char *alpha_string = tail;\n<121> alpha = strtoul(alpha_string, &tail, 16);\n<125> alpha = 255 * strtod(alpha_string, &tail);\n<131> if (tail == alpha_string || *tail || alpha > 255) {\n<133> av_log(log_ctx, AV_LOG_ERROR, "Invalid alpha value specifier '%s' in '%s'\n",
<1> static int com_pager ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) ) {\n<3> if ( status . batch ) return 0 ;\n<4> while ( my_isspace ( charset_info , * line ) ) line ++ ;\n<5> param = strchr ( line , ' ' ) ;\n<6> while ( param && my_isspace ( charset_info , * param ) ) param ++ ;\n<7> if ( ! param || ! strlen ( param ) ) {\n<8> if ( ! default_pager_set ) {\n<18> end = strmake_buf ( pager_name , param ) ;\n<19> while ( end > pager_name && ( my_isspace ( charset_info , end [ - 1 ] ) || my_iscntrl ( charset_info , end [ - 1 ] ) ) ) end -- ;\n<20> end [ 0 ] = 0 ;\n<21> strmov ( pager , pager_name ) ;\n<22> strmov ( default_pager , pager_name ) ;\n<24> opt_nopager = 0 ;\n<25> tee_fprintf ( stdout , "PAGER set to '%s'\n" , pager ) ;\n<26> return 0 ;
<1> static USBDevice *usb_msd_init(USBBus *bus, const char *filename)\n<29> p1 = strchr(filename, ':');\n<31> if (p1++) {\n<37> if (strstart(filename, "format=", &p2)) {\n<45> } else if (*filename != ':') {\n<47> printf("unrecognized USB mass-storage option %s\n", filename);\n<57> if (!*filename) {\n<59> printf("block device specification needed\n");\n<65> qemu_opt_set(opts, "file", filename);
<1> static ssize_t mcf_fec_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n<67> if ((bd.flags & FEC_BD_E) == 0) {\n<77> fprintf(stderr, "mcf_fec: Lost end of frame\n");
<1> static int decode_frame(AVCodecContext *avctx,\n<99> if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n<103> memset(frame->data[0], 0, s->height * frame->linesize[0]);\n<113> palette = (uint32_t*)frame->data[1];\n<121> for (i = 0; i < npal; i++)\n<123> palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];\n<129> for (i = 0; i < npal; i++) {\n<133> palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];\n<141> for (i = 0; i < npal; i++) {\n<145> palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];\n<153> for (i = 0; i < npal; i++) {\n<157> palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;\n<165> npal = 2;\n<167> palette[0] = 0xFF000000;\n<169> palette[1] = 0xFFFFFFFF;\n<171> } else if (bpp == 2) {\n<175> for (i = 0; i < npal; i++)\n<177> palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];\n<183> memcpy(palette, ff_cga_palette, npal * 4);\n<191> memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);\n<291> while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {\n<293> memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));\n<295> bytestream2_skip(&s->g, avctx->width);
<1> static char * new_command_generator ( const char * text , int state ) {\n<7> if ( ! state ) textlen = ( uint ) strlen ( text ) ;\n<8> if ( textlen > 0 ) {\n<9> if ( ! state ) {\n<11> b = find_all_matches ( & ht , text , ( uint ) strlen ( text ) , & len ) ;\n<13> e = b -> pData ;\n<15> if ( e ) {\n<16> ptr = strdup ( e -> str ) ;\n<18> return ptr ;\n<27> b = ht . arBuckets [ i ] ;\n<34> while ( e && ! ptr ) {\n<35> if ( ( uint ) strlen ( e -> str ) == b -> nKeyLength ) ptr = strdup ( e -> str ) ;\n<37> if ( ! e ) {\n<39> if ( ! b ) {\n<44> b = ht . arBuckets [ i ] ;\n<53> if ( ptr ) return ptr ;
<1> static void sethead ( struct head * head , SplineFont * sf , struct alltabs * at , enum fontformat format , int32 * bsizes ) {\n<33> if ( useng != NULL && useng -> names [ ttf_version ] != NULL && sscanf ( useng -> names [ ttf_version ] , "Version %f" , & vn ) == 1 ) {\n<34> head -> revision = vn * 65536 ;
<1> int ff_ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile)\n<11> int32_t     prev_dc, trvec[64];\n<123> if (cbp & 1) { /* block coded ? */\n<127> memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */\n<129> memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */\n<195> trvec[pos] = val;\n<197> col_flags[pos & col_mask] |= !!val; /* track columns containing non-zero coeffs */\n<213> prev_dc      += trvec[0];\n<217> col_flags[0] |= !!prev_dc;\n<225> band->inv_transform(trvec, band->buf + buf_offs,
<1> static void hostnames ( struct parse * pcmd , FILE * fp ) {\n<3> if ( showhostnames ) ( void ) fprintf ( fp , "hostnames being shown\n" ) ;\n<4> else ( void ) fprintf ( fp , "hostnames not being shown\n" ) ;\n<8> else if ( STREQ ( pcmd -> argval [ 0 ] . string , "no" ) ) showhostnames = 0 ;\n<9> else ( void ) fprintf ( stderr , "What?\n" ) ;
<1> init_disasm (struct disassemble_info *info)\n<11> memset (opc_index, 0, sizeof (opc_index));
<1> static int decode_frame(AVCodecContext * avctx,\n<9> MPADecodeContext *s = avctx->priv_data;\n<23> buf_ptr = buf;\n<27> len = s->inbuf_ptr - s->inbuf;\n<37> s->inbuf[0] = s->free_format_next_header >> 24;\n<39> s->inbuf[1] = s->free_format_next_header >> 16;\n<41> s->inbuf[2] = s->free_format_next_header >> 8;\n<43> s->inbuf[3] = s->free_format_next_header;\n<63> else if (len > 0) {\n<65> memcpy(s->inbuf_ptr, buf_ptr, len);\n<67> buf_ptr += len;\n<69> buf_size -= len;\n<71> s->inbuf_ptr += len;\n<75> if ((s->inbuf_ptr - s->inbuf) >= HEADER_SIZE) {\n<79> header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n<81> (s->inbuf[2] << 8) | s->inbuf[3];\n<83> if (check_header(header) < 0) {\n<87> memcpy(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf);\n<101> if (decode_header(s, header) == 1) {\n<107> memcpy(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf);\n<137> if (len == 0) {\n<153> memcpy(s->inbuf_ptr, buf_ptr, len);\n<157> p = s->inbuf_ptr - 3;\n<159> pend = s->inbuf_ptr + len - 4;\n<183> buf_ptr += len;\n<221> buf_ptr += len;\n<223> s->inbuf_ptr += len;\n<225> buf_size -= len;\n<241> else if (len > 0)\n<245> memcpy(s->inbuf_ptr, buf_ptr, len);\n<247> buf_ptr += len;\n<249> s->inbuf_ptr += len;\n<251> buf_size -= len;
<1> static int restore_db_collation ( FILE * sql_file , const char * db_name , const char * delimiter , const char * db_cl_name ) {\n<3> char * quoted_db_name = quote_name ( db_name , quoted_db_buf , FALSE ) ;\n<5> if ( ! db_cl ) return 1 ;\n<6> fprintf ( sql_file , "ALTER DATABASE %s CHARACTER SET %s COLLATE %s %s\n" , ( const char * ) quoted_db_name , ( const char * ) db_cl -> csname , ( const char * ) db_cl -> name , ( const char * ) delimiter ) ;
<1> uart_write(void *opaque, hwaddr addr,\n<9> uint32_t value = val64;\n<15> addr >>= 2;\n<17> switch (addr)\n<67> DUART(printf("%s addr=%x v=%x\n", __func__, addr, value));\n<69> if (addr < ARRAY_SIZE(s->regs))\n<71> s->regs[addr] = value;
<1> void proto_register_field_array ( const int parent , hf_register_info * hf , const int num_records ) {\n<9> if ( * ptr -> p_id != - 1 && * ptr -> p_id != 0 ) {\n<10> fprintf ( stderr , "Duplicate field detected in call to proto_register_field_array: %s is already registered\n" , ptr -> hfinfo . abbrev ) ;
<1> static const uint8_t *read_huffman_tables(FourXContext *f,\n<25> memset(up, -1, sizeof(up));\n<131> for (node = j; up[node] != -1; node = up[node]) {
<1> static void vmgenid_query_monitor_test(void)\n<27> g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
<1> static int audio_open(AVFormatContext *s1, int is_output, const char *audio_device)\n<11> char *flip = getenv("AUDIO_FLIP_LEFT");\n<23> if (audio_fd < 0) {\n<25> av_log(s1, AV_LOG_ERROR, "%s: %s\n", audio_device, strerror(errno));\n<33> if (flip && *flip == '1') {\n<45> if (fcntl(audio_fd, F_SETFL, O_NONBLOCK) < 0) {\n<47> av_log(s1, AV_LOG_WARNING, "%s: Could not enable non block mode (%s)\n", audio_device, strerror(errno));\n<127> if (err < 0) {\n<129> av_log(s1, AV_LOG_ERROR, "SNDCTL_DSP_SETFMT: %s\n", strerror(errno));\n<141> if (err < 0) {\n<143> av_log(s1, AV_LOG_ERROR, "SNDCTL_DSP_STEREO: %s\n", strerror(errno));\n<155> if (err < 0) {\n<157> av_log(s1, AV_LOG_ERROR, "SNDCTL_DSP_SPEED: %s\n", strerror(errno));
<1> static uint8_t get_sot(J2kDecoderContext *s)\n<27> if (!bytestream_get_byte(&s->buf)){ ///< TPsot\n<29> J2kTile *tile = s->tile + s->curtileno;\n<35> memcpy(tile->codsty, s->codsty, s->ncomponents * sizeof(J2kCodingStyle));\n<37> memcpy(tile->qntsty, s->qntsty, s->ncomponents * sizeof(J2kQuantStyle));
<1> static void dumpTablespaces ( PGconn * conn ) {\n<9> if ( PQntuples ( res ) > 0 ) fprintf ( OPF , "--\n-- Tablespaces\n--\n\n" ) ;\n<11> i < PQntuples ( res ) ;\n<21> char * spccomment = PQgetvalue ( res , i , 7 ) ;\n<24> appendPQExpBuffer ( buf , "CREATE TABLESPACE %s" , fspcname ) ;\n<25> appendPQExpBuffer ( buf , " OWNER %s" , fmtId ( spcowner ) ) ;\n<26> appendPQExpBufferStr ( buf , " LOCATION " ) ;\n<27> appendStringLiteralConn ( buf , spclocation , conn ) ;\n<37> if ( spccomment && strlen ( spccomment ) ) {\n<38> appendPQExpBuffer ( buf , "COMMENT ON TABLESPACE %s IS " , fspcname ) ;\n<39> appendStringLiteralConn ( buf , spccomment , conn ) ;\n<43> if ( ! no_security_labels && server_version >= 90200 ) buildShSecLabels ( conn , "pg_tablespace" , spcoid , buf , "TABLESPACE" , fspcname ) ;\n<44> fprintf ( OPF , "%s" , buf -> data ) ;\n<45> free ( fspcname ) ;\n<46> destroyPQExpBuffer ( buf ) ;\n<49> fprintf ( OPF , "\n\n" ) ;
<1> static void vnc_dpy_copy(DisplayChangeListener *dcl,\n<47> src_row = vnc_server_fb_ptr(vd, src_x, src_y);\n<49> dst_row = vnc_server_fb_ptr(vd, dst_x, dst_y);\n<59> src_row += pitch * (h-1);\n<61> dst_row += pitch * (h-1);\n<85> x += s, src_row += cmp_bytes, dst_row += cmp_bytes) {\n<87> if (x == w_lim) {\n<89> if ((s = w - w_lim) == 0)\n<105> cmp_bytes = s * VNC_SERVER_FB_BYTES;\n<107> if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n<111> memmove(dst_row, src_row, cmp_bytes);\n<113> QTAILQ_FOREACH(vs, &vd->clients, next) {\n<115> if (!vnc_has_feature(vs, VNC_FEATURE_COPYRECT)) {\n<125> src_row += pitch - w * VNC_SERVER_FB_BYTES;\n<127> dst_row += pitch - w * VNC_SERVER_FB_BYTES;
<1> static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)\n<33> if ((y ^ td->parity) & 1) {\n<41> uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];\n<65> memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],\n<67> &s->cur->data[td->plane][y * refs], td->w * df);
<1> int nextvar ( int * datalen , const char * * datap , char * * vname , char * * vvalue ) {\n<7> static char name [ MAXVARLEN ] ;\n<8> static char value [ MAXVALLEN ] ;\n<11> while ( cp < cpend && ( * cp == ',' || isspace ( ( int ) * cp ) ) ) cp ++ ;\n<14> srclen = min ( srclen , ( size_t ) ( cpend - cp ) ) ;\n<17> if ( len > 0 ) memcpy ( name , cp , len ) ;\n<19> * vname = name ;\n<20> cp += srclen ;\n<21> if ( cp >= cpend || * cp == ',' || * cp == '\r' || * cp == '\n' ) {\n<29> while ( cp < cpend && ( isspace ( ( unsigned char ) * cp ) && * cp != '\r' && * cp != '\n' ) ) cp ++ ;\n<41> len = np - cp ;\n<42> if ( np > cpend || len >= sizeof ( value ) || ( np < cpend && ',' != * np && '\r' != * np ) ) return 0 ;\n<43> memcpy ( value , cp , len ) ;\n<44> while ( len > 0 && isspace ( ( unsigned char ) value [ len - 1 ] ) ) len -- ;\n<49> * vvalue = value ;
<1> struct groupchat * purple_chat_join ( struct im_connection * ic , const char * room , const char * nick , const char * password , set_t * * sets ) {\n<18> l ;\n<20> struct proto_chat_entry * pce = l -> data ;\n<21> if ( strcmp ( pce -> identifier , "handle" ) == 0 ) {\n<22> g_hash_table_replace ( chat_hash , "handle" , g_strdup ( nick ) ) ;\n<24> else if ( strcmp ( pce -> identifier , "password" ) == 0 ) {\n<25> g_hash_table_replace ( chat_hash , "password" , g_strdup ( password ) ) ;\n<27> else if ( strcmp ( pce -> identifier , "passwd" ) == 0 ) {\n<28> g_hash_table_replace ( chat_hash , "passwd" , g_strdup ( password ) ) ;\n<30> g_free ( pce ) ;
<1> static int mov_write_udta_tag(ByteIOContext *pb, MOVContext* mov,\n<21> mov_write_meta_tag(pb, mov, s);\n<83> if( s->title[0] )\n<91> put_tag(pb, "\251nam");\n<93> put_be16(pb, strlen(s->title)); /* string length */\n<95> put_be16(pb, 0);\n<97> put_buffer(pb, s->title, strlen(s->title));\n<99> updateSize(pb, pos);\n<105> if( s->author[0] )\n<113> put_tag(pb, /*"\251aut"*/ "\251day" );\n<115> put_be16(pb, strlen(s->author)); /* string length */\n<117> put_be16(pb, 0);\n<119> put_buffer(pb, s->author, strlen(s->author));\n<121> updateSize(pb, pos);\n<127> if( s->comment[0] )\n<135> put_tag(pb, "\251des");\n<137> put_be16(pb, strlen(s->comment)); /* string length */\n<139> put_be16(pb, 0);\n<141> put_buffer(pb, s->comment, strlen(s->comment));\n<143> updateSize(pb, pos);
<1> static void send_framebuffer_update_hextile(VncState *vs, int x, int y, int w, int h)\n<13> vnc_framebuffer_update(vs, x, y, w, h, 5);\n<17> last_fg = (uint8_t *) malloc(vs->depth);\n<19> last_bg = (uint8_t *) malloc(vs->depth);\n<37> free(last_fg);\n<39> free(last_bg);
<1> static inline int set_options(AVFilterContext *ctx, const char *args)\n<5> HueContext *hue = ctx->priv;\n<9> char c1 = 0, c2 = 0;\n<17> if (args) {\n<21> if (strchr(args, '=')) {\n<23> old_hue_expr        = hue->hue_expr;\n<25> old_hue_deg_expr    = hue->hue_deg_expr;\n<27> old_saturation_expr = hue->saturation_expr;\n<31> old_hue_pexpr        = hue->hue_pexpr;\n<33> old_hue_deg_pexpr    = hue->hue_deg_pexpr;\n<35> old_saturation_pexpr = hue->saturation_pexpr;\n<39> hue->hue_expr     = NULL;\n<41> hue->hue_deg_expr = NULL;\n<43> hue->saturation_expr = NULL;\n<47> if ((ret = av_set_options_string(hue, args, "=", ":")) < 0)\n<119> n = sscanf(args, "%f%c%f%c", &hue->hue_deg, &c1, &hue->saturation, &c2);\n<121> if (n != 1 && (n != 3 || c1 != ':')) {\n<135> if (hue->saturation < SAT_MIN_VAL || hue->saturation > SAT_MAX_VAL) {\n<151> hue->hue = hue->hue_deg * M_PI / 180;
<1> static int rtsp_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> RTSPState *rt = s->priv_data;\n<19> enum AVDiscard cache[MAX_STREAMS];\n<25> cache[i] = s->streams[i]->discard;\n<29> if (!rt->need_subscription) {\n<33> sizeof(enum AVDiscard) * s->nb_streams)) {\n<35> av_strlcatf(cmd, sizeof(cmd),\n<41> s->filename, rt->last_subscription);\n<43> rtsp_send_cmd(s, cmd, reply, NULL);\n<45> if (reply->status_code != RTSP_STATUS_OK)\n<57> if (rt->need_subscription) {\n<65> sizeof(enum AVDiscard) * s->nb_streams);
<1> static void readline_hist_add(ReadLineState *rs, const char *cmdline)\n<11> if (cmdline[0] == '\0')\n<17> if (rs->hist_entry != -1) {\n<21> hist_entry = rs->history[rs->hist_entry];\n<25> if (strcmp(hist_entry, cmdline) == 0) {\n<35> for (idx = 0; idx < READLINE_MAX_CMDS; idx++) {\n<39> if (hist_entry == NULL)\n<43> if (strcmp(hist_entry, cmdline) == 0) {\n<47> new_entry = hist_entry;\n<51> memmove(&rs->history[idx], &rs->history[idx + 1],\n<53> (READLINE_MAX_CMDS - idx + 1) * sizeof(char *));\n<55> rs->history[READLINE_MAX_CMDS - 1] = NULL;\n<57> for (; idx < READLINE_MAX_CMDS; idx++) {\n<59> if (rs->history[idx] == NULL)\n<71> if (idx == READLINE_MAX_CMDS) {\n<75> free(rs->history[0]);\n<79> (READLINE_MAX_CMDS - 1) * sizeof(char *));\n<87> if (new_entry == NULL)\n<89> new_entry = strdup(cmdline);\n<91> rs->history[idx] = new_entry;
<1> char * evbuffer_readline ( struct evbuffer * buffer ) {\n<2> u_char * data = EVBUFFER_DATA ( buffer ) ;\n<9> if ( data [ i ] == '\r' || data [ i ] == '\n' ) break ;\n<11> if ( i == len ) return ( NULL ) ;\n<12> if ( ( line = malloc ( i + 1 ) ) == NULL ) {\n<13> fprintf ( stderr , "%s: out of memory\n" , __func__ ) ;\n<14> return ( NULL ) ;\n<16> memcpy ( line , data , i ) ;\n<17> line [ i ] = '\0' ;\n<18> if ( i < len - 1 ) {\n<19> char fch = data [ i ] , sch = data [ i + 1 ] ;\n<22> evbuffer_drain ( buffer , i + 1 ) ;\n<23> return ( line ) ;
<1> void usage_exit ( ) {\n<2> fprintf ( stderr , "Usage: %s <infile> <outfile>\n" , exec_name ) ;
<1> static void ioport_write(void *opaque, uint32_t addr, uint32_t val)\n<7> uint32_t io_port = addr - d->io_base;\n<39> switch (io_port) {\n<111> if (d->guestdebug) {\n<113> fprintf(stderr, "qxl/guest: %s", d->ram->log_buf);\n<181> fprintf(stderr, "%s: ioport=0x%x, abort()\n", __FUNCTION__, io_port);
<1> static void test_bug1500 ( ) {\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> my_bind [ 2 ] = my_bind [ 1 ] = my_bind [ 0 ] ;\n<27> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<45> data = "Dogs" ;\n<48> my_bind [ 0 ] . buffer_length = strlen ( data ) ;\n<51> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<61> data = "Grave" ;\n<64> my_bind [ 0 ] . buffer_length = strlen ( data ) ;\n<65> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static char * shorten_utf8_string ( const char * base , int reduce_by_num_bytes ) {\n<5> len = strlen ( base ) ;\n<6> len -= reduce_by_num_bytes ;\n<11> p = base ;\n<21> if ( p - base == 0 ) {\n<26> memcpy ( ret , base , p - base ) ;\n<27> ret [ p - base ] = '\0' ;\n<28> return ret ;
<1> static int open_input(HLSContext *c, struct playlist *pls, struct segment *seg)\n<49> } else if (seg->key_type == KEY_AES_128) {\n<55> if (strcmp(seg->key, pls->key_url)) {\n<59> if (open_url(pls->parent, &pb, seg->key, c->avio_opts, opts) == 0) {\n<81> av_strlcpy(pls->key_url, seg->key, sizeof(pls->key_url));\n<91> if (strstr(seg->url, "://"))\n<93> snprintf(url, sizeof(url), "crypto+%s", seg->url);\n<97> snprintf(url, sizeof(url), "crypto:%s", seg->url);
<1> static bool update_user_table ( THD * thd , TABLE * table , const char * host , const char * user , const char * new_password , uint new_password_len ) {\n<5> DBUG_PRINT ( "enter" , ( "user: %s host: %s" , user , host ) ) ;\n<7> table -> field [ 0 ] -> store ( host , ( uint ) strlen ( host ) , system_charset_info ) ;\n<8> table -> field [ 1 ] -> store ( user , ( uint ) strlen ( user ) , system_charset_info ) ;
<1> static void local_mapped_file_attr(int dirfd, const char *name,\n<9> char buf[ATTR_MAX];\n<31> if (!fp) {\n<37> memset(buf, 0, ATTR_MAX);\n<39> while (fgets(buf, ATTR_MAX, fp)) {\n<41> if (!strncmp(buf, "virtfs.uid", 10)) {\n<45> } else if (!strncmp(buf, "virtfs.gid", 10)) {\n<49> } else if (!strncmp(buf, "virtfs.mode", 11)) {\n<53> } else if (!strncmp(buf, "virtfs.rdev", 11)) {\n<59> memset(buf, 0, ATTR_MAX);\n<63> fclose(fp);
<1> static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n<11> for (i = 0; i < dev->nvqs; ++i) {\n<31> if (!p || l != vq->ring_size) {\n<33> fprintf(stderr, "Unable to map ring buffer for ring %d\n", i);\n<39> if (p != vq->ring) {\n<41> fprintf(stderr, "Ring buffer relocated for ring %d\n", i);
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<97> if (ret < 0) {\n<115> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> static void xps_parse_poly_bezier_segment ( fz_context * doc , fz_path * path , fz_xml * root , int stroking , int * skipped_stroke ) {\n<3> char * is_stroked_att = fz_xml_att ( root , "IsStroked" ) ;\n<8> if ( ! points_att ) {\n<13> if ( is_stroked_att && ! strcmp ( is_stroked_att , "false" ) ) is_stroked = 0 ;
<1> static int unpack ( const uint8_t * src , const uint8_t * src_end , uint8_t * dst , int width , int height ) {\n<9> src += 3 ;\n<10> while ( size > 0 && src < src_end ) {\n<15> if ( src [ 0 ] < 0xFC ) size1 = ( ( ( src [ 0 ] & 31 ) + 1 ) << 2 ) ;\n<20> offset = ( ( src [ 0 ] & 0x10 ) << 12 ) + AV_RB16 ( & src [ 1 ] ) + 1 ;\n<21> size2 = ( ( src [ 0 ] & 0xC ) << 6 ) + src [ 3 ] + 5 ;\n<26> size1 = ( ( src [ 1 ] & 0xC0 ) >> 6 ) ;\n<27> offset = ( AV_RB16 ( & src [ 1 ] ) & 0x3FFF ) + 1 ;\n<28> size2 = ( src [ 0 ] & 0x3F ) + 4 ;\n<34> size2 = ( ( src [ 0 ] & 0x1C ) >> 2 ) + 3 ;\n<37> if ( size1 > src_end - src ) break ;\n<38> if ( size1 > 0 ) {\n<40> run = FFMIN ( size1 , dst_end - dst ) ;\n<41> memcpy ( dst , src , run ) ;\n<42> dst += run ;\n<43> src += run ;
<363> if (ff_vc1_parse_frame_header(v, &s->gb) == -1) {\n<371> if (ff_vc1_parse_frame_header_adv(v, &s->gb) == -1) {\n<575> if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n<587> if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n<609> ff_vc1_decode_blocks(v);\n<621> if (s->pict_type == AV_PICTURE_TYPE_B) {\n<625> 2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2));
<1> static void audio_pp_nb_voices (const char *typ, int nb)\n<5> switch (nb) {\n<9> printf ("Does not support %s\n", typ);\n<15> printf ("One %s voice\n", typ);\n<21> printf ("Theoretically supports many %s voices\n", typ);\n<27> printf ("Theoretically supports upto %d %s voices\n", nb, typ);
<1> static void curses_refresh(DisplayChangeListener *dcl)\n<39> if (nextchr == ERR)\n<41> chr = getch();\n<53> if (chr == ERR)\n<89> if (keycode == 1) {\n<91> nextchr = getch();\n<95> if (nextchr != ERR) {
<1> static void decode_decorrelation_matrix ( WMAProDecodeCtx * s , WMAProChannelGrp * chgroup ) {\n<5> memset ( chgroup -> decorrelation_matrix , 0 , s -> avctx -> channels * s -> avctx -> channels * sizeof ( * chgroup -> decorrelation_matrix ) ) ;
<1> extern int main ( int argc , char * argv [ ] ) {\n<14> argc = u_parseArgs ( argc , argv , UPRV_LENGTHOF ( options ) , options ) ;\n<15> if ( argc < 0 ) {\n<16> fprintf ( stderr , "error in command line argument \"%s\"\n" , argv [ - argc ] ) ;\n<19> return printHelp ( argc , argv ) ;\n<33> return printHelp ( argc , argv ) ;\n<39> return printHelp ( argc , argv ) ;\n<49> filename [ 0 ] = '.' ;\n<50> filename [ 1 ] = U_FILE_SEP_CHAR ;\n<62> parseMappings ( filename , FALSE , & errorCode ) ;\n<63> if ( U_FAILURE ( errorCode ) ) {\n<64> fprintf ( stderr , "Could not open file %s for reading. Error: %s \n" , filename , u_errorName ( errorCode ) ) ;\n<75> parseNormalizationCorrections ( filename , & errorCode ) ;\n<76> if ( U_FAILURE ( errorCode ) ) {\n<77> fprintf ( stderr , "Could not open file %s for reading \n" , filename ) ;
<1> int qemu_read_password(char *buf, int buf_size)\n<11> printf("password: ");\n<67> printf("\n");
<1> void MPV_common_end(MpegEncContext *s)\n<9> if (s->motion_val)\n<11> free(s->motion_val);\n<13> if (s->h263_pred) {\n<15> free(s->dc_val[0]);\n<17> free(s->ac_val[0]);\n<19> free(s->coded_block);\n<21> free(s->mbintra_table);\n<25> if (s->mbskip_table)\n<27> free(s->mbskip_table);\n<29> for(i=0;i<3;i++) {\n<31> free(s->last_picture_base[i]);\n<33> free(s->next_picture_base[i]);\n<35> if (s->has_b_frames)\n<37> free(s->aux_picture_base[i]);
<1> static void log_frame_info ( VP9_COMMON * cm , const char * str , FILE * f ) {\n<2> fprintf ( f , "%s" , str ) ;\n<3> fprintf ( f , "(Frame %d, Show:%d, Q:%d): \n" , cm -> current_video_frame , cm -> show_frame , cm -> base_qindex ) ;
<1> int kvm_init(MachineClass *mc)\n<25> }, *nc = num_cpus;\n<73> if (s->fd == -1) {\n<75> fprintf(stderr, "Could not access KVM kernel module: %m\n");\n<87> if (ret < KVM_API_VERSION) {\n<95> fprintf(stderr, "kvm version too old\n");\n<103> if (ret > KVM_API_VERSION) {\n<107> fprintf(stderr, "kvm version not supported\n");\n<151> if (nc->num > soft_vcpus_limit) {\n<163> if (nc->num > hard_vcpus_limit) {\n<165> fprintf(stderr, "Number of %s cpus requested (%d) exceeds "\n<177> nc++;\n<183> kvm_type = qemu_opt_get(qemu_get_machine_opts(), "kvm-type");\n<189> } else if (kvm_type) {\n<191> fprintf(stderr, "Invalid argument kvm-type=%s\n", kvm_type);\n<207> if (ret < 0) {\n<209> fprintf(stderr, "ioctl(KVM_CREATE_VM) failed: %d %s\n", -ret,\n<211> strerror(-ret));\n<233> if (!missing_cap) {\n<241> if (missing_cap) {
<1> int compare_key_tok_text ( const void * a1 , const void * a2 ) {\n<2> const struct key_tok * p1 = a1 ;\n<3> const struct key_tok * p2 = a2 ;\n<4> return strcmp ( p1 -> key , p2 -> key ) ;
<3> CodedBitstreamUnit *unit)\n<13> err = bitstream_init(&bc, unit->data, 8 * unit->data_size);\n<31> if (!slice)\n<55> slice->data = av_malloc(slice->data_size);\n<57> if (!slice->data) {\n<69> unit->data + pos / 8, slice->data_size);\n<75> unit->content = slice;
<1> static char * get_private_subtags ( const char * loc_name ) {\n<6> if ( loc_name && ( len = strlen ( loc_name ) > 0 ) ) {\n<7> mod_loc_name = loc_name ;\n<8> len = strlen ( mod_loc_name ) ;\n<9> while ( ( singletonPos = getSingletonPos ( mod_loc_name ) ) != - 1 ) {\n<12> if ( singletonPos + 2 == len ) {\n<20> if ( singletonPos + 1 >= len ) {\n<24> mod_loc_name = mod_loc_name + singletonPos + 1 ;\n<25> len = strlen ( mod_loc_name ) ;
<1> static void _check_database_version ( ArchiveHandle * AH ) {\n<16> if ( remoteversion >= 90000 ) {\n<18> AH -> public . isStandby = ( strcmp ( PQgetvalue ( res , 0 , 0 ) , "t" ) == 0 ) ;
<31> if (ret < 0)\n<39> memcpy(pal, sc->palette, AVPALETTE_SIZE);
<1> static int tcp_get_msgfds(CharDriverState *chr, int *fds, int num)\n<3> TCPCharDriver *s = chr->opaque;\n<6> memcpy(fds, s->read_msgfds, to_copy * sizeof(int));\n<7> g_free(s->read_msgfds);
<7> Mpeg1Context *s1      = (Mpeg1Context *) s;\n<61> if (!pan_scan)\n<65> memcpy(pan_scan->data, &s1->pan_scan, sizeof(s1->pan_scan));\n<77> if (sd)\n<79> memcpy(sd->data, s1->a53_caption, s1->a53_caption_size);\n<81> av_freep(&s1->a53_caption);
<1> int qemuMonitorJSONGetBlockInfo ( qemuMonitorPtr mon , const char * devname , struct qemuDomainDiskInfo * info ) {\n<31> if ( STRPREFIX ( thisdev , QEMU_DRIVE_HOST_PREFIX ) ) thisdev += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n<32> if ( STRNEQ ( thisdev , devname ) ) continue ;
<1> void DeCloneArchive ( ArchiveHandle * AH ) {\n<2> Assert ( AH -> connection == NULL ) ;\n<3> ( AH -> DeClonePtr ) ( AH ) ;\n<5> if ( AH -> currUser ) free ( AH -> currUser ) ;\n<6> if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n<7> if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;\n<8> if ( AH -> savedPassword ) free ( AH -> savedPassword ) ;\n<9> free ( AH ) ;
<1> static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n<515> if (local_err) {\n<553> opt_overlap_check = qemu_opt_get(opts, "overlap-check") ?: "cached";\n<555> if (!strcmp(opt_overlap_check, "none")) {\n<557> overlap_check_template = 0;\n<559> } else if (!strcmp(opt_overlap_check, "constant")) {\n<561> overlap_check_template = QCOW2_OL_CONSTANT;\n<563> } else if (!strcmp(opt_overlap_check, "cached")) {\n<565> overlap_check_template = QCOW2_OL_CACHED;\n<567> } else if (!strcmp(opt_overlap_check, "all")) {\n<569> overlap_check_template = QCOW2_OL_ALL;\n<573> error_setg(errp, "Unsupported value '%s' for qcow2 option "\n<579> qemu_opts_del(opts);\n<581> ret = -EINVAL;\n<589> s->overlap_check = 0;\n<591> for (i = 0; i < QCOW2_OL_MAX_BITNR; i++) {\n<607> qemu_opts_del(opts);\n<611> if (s->use_lazy_refcounts && s->qcow_version < 3) {\n<643> g_free(s->unknown_header_fields);\n<645> cleanup_unknown_header_ext(bs);\n<647> qcow2_free_snapshots(bs);\n<649> qcow2_refcount_close(bs);\n<651> g_free(s->l1_table);\n<655> s->l1_table = NULL;\n<657> if (s->l2_table_cache) {\n<663> if (s->refcount_block_cache) {\n<669> g_free(s->cluster_cache);\n<671> qemu_vfree(s->cluster_data);\n<673> return ret;
<1> static int vc1_decode_intra_block ( VC1Context * v , int16_t block [ 64 ] , int n , int coded , int mquant , int codingset ) {\n<53> ac_val2 = ac_val ;\n<55> if ( dc_pred_dir ) ac_val -= 16 ;\n<56> else ac_val -= 16 * s -> block_wrap [ n ] ;\n<63> if ( coded ) {\n<126> memset ( ac_val2 , 0 , 16 * 2 ) ;\n<128> if ( use_pred ) {\n<129> memcpy ( ac_val2 , ac_val , 8 * 2 ) ;\n<136> k ++ ) ac_val2 [ k ] = ( ac_val2 [ k ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n<141> if ( use_pred ) {\n<142> memcpy ( ac_val2 + 8 , ac_val + 8 , 8 * 2 ) ;\n<149> k ++ ) ac_val2 [ k + 8 ] = ( ac_val2 [ k + 8 ] * q2 * ff_vc1_dqscale [ q1 - 1 ] + 0x20000 ) >> 18 ;\n<158> block [ k << v -> left_blk_sh ] = ac_val2 [ k ] * scale ;\n<166> block [ k << v -> top_blk_sh ] = ac_val2 [ k + 8 ] * scale ;
<1> int qemuMonitorTextAddDrive ( qemuMonitorPtr mon , const char * drivestr ) {\n<3> char * reply = NULL ;\n<15> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<19> if ( strstr ( reply , "unknown command:" ) ) {\n<20> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , _ ( "drive hotplug is not supported" ) ) ;\n<23> if ( strstr ( reply , "could not open disk image" ) ) {\n<24> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , _ ( "open disk image file failed" ) ) ;\n<27> ret = 0 ;\n<29> VIR_FREE ( reply ) ;
<1> static void leon3_generic_hw_init(MachineState *machine)\n<47> if (cpu == NULL) {\n<49> fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n");\n<87> if ((uint64_t)ram_size > (1UL << 30)) {\n<93> (unsigned int)(ram_size / (1024 * 1024)));\n<135> bios_size = get_image_size(filename);\n<139> if (bios_size > prom_size) {\n<141> fprintf(stderr, "qemu: could not load prom '%s': file too big\n",\n<153> ret = load_image_targphys(filename, 0x00000000, bios_size);\n<155> if (ret < 0 || ret > prom_size) {\n<157> fprintf(stderr, "qemu: could not load prom '%s'\n", filename);\n<163> } else if (kernel_filename == NULL && !qtest_enabled()) {\n<165> fprintf(stderr, "Can't read bios image %s\n", filename);\n<184> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<188> if (kernel_size < 0) {\n<190> fprintf(stderr, "qemu: could not load kernel '%s'\n",
<1> static void * img_buf_memalign ( size_t align , size_t size ) {\n<3> addr = malloc ( size + align - 1 + ADDRESS_STORAGE_SIZE ) ;\n<5> x = align_addr ( ( unsigned char * ) addr + ADDRESS_STORAGE_SIZE , ( int ) align ) ;\n<6> ( ( size_t * ) x ) [ - 1 ] = ( size_t ) addr ;
<1> static void remoteStreamEvent ( virStreamPtr st , int events , void * opaque ) {\n<27> if ( ! stream -> closed && ( events & ( VIR_STREAM_EVENT_ERROR | VIR_STREAM_EVENT_HANGUP ) ) ) {\n<30> memset ( & rerr , 0 , sizeof rerr ) ;\n<34> if ( events & VIR_STREAM_EVENT_HANGUP ) remoteDispatchFormatError ( & rerr , "%s" , _ ( "stream had unexpected termination" ) ) ;\n<35> else remoteDispatchFormatError ( & rerr , "%s" , _ ( "stream had I/O failure" ) ) ;\n<36> ret = remoteSerializeStreamError ( client , & rerr , stream -> procedure , stream -> serial ) ;
<1> static void extract_mpeg4_header(AVFormatContext *infile)\n<31> if (!mpeg4_count)\n<37> printf("MPEG4 without extra data: trying to find header\n");\n<41> if (av_read_packet(infile, &pkt) < 0)\n<51> av_freep(&st->codec.extradata);\n<57> p = pkt.data;\n<59> while (p < pkt.data + pkt.size - 4) {\n<67> size = p - pkt.data;\n<71> st->codec.extradata = av_malloc(size);\n<75> memcpy(st->codec.extradata, pkt.data, size);\n<89> av_free_packet(&pkt);
<1> static void bamboo_init(MachineState *machine)\n<63> if (cpu == NULL) {\n<65> fprintf(stderr, "Unable to initialize CPU!\n");\n<71> env = &cpu->env;\n<75> if (env->mmu_model != POWERPC_MMU_BOOKE) {\n<77> fprintf(stderr, "MMU model %i not supported by this machine.\n",\n<91> ppc_dcr_init(env, NULL, NULL);\n<103> pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n<109> memset(ram_bases, 0, sizeof(ram_bases));\n<111> memset(ram_sizes, 0, sizeof(ram_sizes));\n<113> ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,\n<123> ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n<143> if (!pcibus) {\n<145> fprintf(stderr, "couldn't create PCI controller!\n");\n<205> success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,\n<211> success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<225> if (success < 0) {\n<227> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<243> initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n<249> if (initrd_size < 0) {\n<251> fprintf(stderr, "qemu: could not load ram disk '%s' at %x\n",\n<267> if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n<271> fprintf(stderr, "couldn't load device tree\n");
<1> static void decode_format80(const unsigned char *src, int src_size,\n<3> unsigned char *dest, int dest_size, int check_size) {\n<25> av_dlog(NULL, "      opcode %02X: ", src[src_index]);\n<31> if (src[src_index] == 0x80)\n<47> if (src[src_index] == 0xFF) {\n<53> count = AV_RL16(&src[src_index]);\n<57> src_pos = AV_RL16(&src[src_index]);\n<76> } else if (src[src_index] == 0xFE) {\n<82> count = AV_RL16(&src[src_index]);\n<88> av_dlog(NULL, "(2) set %X bytes to %02X\n", count, color);\n<92> memset(&dest[dest_index], color, count);\n<94> dest_index += count;\n<98> } else if ((src[src_index] & 0xC0) == 0xC0) {\n<104> src_pos = AV_RL16(&src[src_index]);\n<123> } else if (src[src_index] > 0x80) {\n<129> av_dlog(NULL, "(4) copy %X bytes from source to dest\n", count);\n<133> memcpy(&dest[dest_index], &src[src_index], count);\n<135> src_index += count;\n<137> dest_index += count;\n<145> count = ((src[src_index] & 0x70) >> 4) + 3;\n<147> src_pos = AV_RB16(&src[src_index]) & 0x0FFF;
<1> static int isFileInVirtualDir ( char * filePath ) {\n<5> while ( pCurVirtualDir != NULL ) {\n<6> webDirLen = strlen ( pCurVirtualDir -> dirName ) ;\n<8> if ( pCurVirtualDir -> dirName [ webDirLen - 1 ] == '/' ) {\n<9> if ( strncmp ( pCurVirtualDir -> dirName , filePath , webDirLen ) == 0 ) return ! 0 ;\n<12> if ( strncmp ( pCurVirtualDir -> dirName , filePath , webDirLen ) == 0 && ( filePath [ webDirLen ] == '/' || filePath [ webDirLen ] == '\0' || filePath [ webDirLen ] == '?' ) ) return ! 0 ;
<1> static void apply_ir_filter ( float * out , const AMRFixed * in , const float * filter ) {\n<10> memset ( out , 0 , sizeof ( float ) * AMR_SUBFRAME_SIZE ) ;\n<24> ff_celp_circ_addf ( out , out , filterp , x , y , AMR_SUBFRAME_SIZE ) ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<2> RALFContext * ctx = avctx -> priv_data ;\n<14> table_bytes = ( AV_RB16 ( avpkt -> data ) + 7 ) >> 3 ;\n<15> if ( table_bytes + 3 > avpkt -> size || avpkt -> size > RALF_MAX_PKT_SIZE ) {\n<19> if ( memcmp ( ctx -> pkt , avpkt -> data , 2 + table_bytes ) ) {\n<20> av_log ( avctx , AV_LOG_ERROR , "Wrong packet tails are wrong!\n" ) ;\n<21> return AVERROR_INVALIDDATA ;\n<23> src = ctx -> pkt ;\n<24> src_size = RALF_MAX_PKT_SIZE + avpkt -> size ;\n<25> memcpy ( ctx -> pkt + RALF_MAX_PKT_SIZE , avpkt -> data + 2 + table_bytes , avpkt -> size - 2 - table_bytes ) ;\n<28> if ( avpkt -> size == RALF_MAX_PKT_SIZE ) {\n<29> memcpy ( ctx -> pkt , avpkt -> data , avpkt -> size ) ;\n<37> frame -> nb_samples = ctx -> max_frame_size ;\n<38> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {
<1> static int test_make_inputs ( xd3_stream * stream , xoff_t * ss_out , xoff_t * ts_out ) {\n<2> usize_t ts = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n<3> usize_t ss = ( mt_random ( & static_mtrand ) % TEST_FILE_MEAN ) + TEST_FILE_MEAN / 2 ;\n<4> uint8_t * buf = ( uint8_t * ) malloc ( ts + ss ) , * sbuf = buf , * tbuf = buf + ss ;\n<9> if ( buf == NULL ) {\n<75> failure : free ( buf ) ;
<1> gcry_error_t gcry_sexp_build ( gcry_sexp_t * retsexp , size_t * erroff , const char * format , ... ) {\n<4> va_start ( arg_ptr , format ) ;\n<5> rc = vsexp_sscan ( retsexp , erroff , format , strlen ( format ) , 1 , NULL , arg_ptr ) ;
<1> static void * Type_NamedColor_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n<26> i < count ;\n<31> memset ( Colorant , 0 , sizeof ( Colorant ) ) ;\n<35> if ( ! _cmsReadUInt16Array ( io , nDeviceCoords , Colorant ) ) goto Error ;
<1> int ff_mpeg4_frame_end(AVCodecContext *avctx, const uint8_t *buf, int buf_size)\n<7> MpegEncContext    *s = &ctx->m;\n<35> if (buf[i]     == 0 &&\n<37> buf[i + 1] == 0 &&\n<39> buf[i + 2] == 1 &&\n<41> buf[i + 3] == 0xB6) {\n<43> startcode_found = !(buf[i + 4] & 0x40);\n<59> buf_size - current_pos +\n<63> if (!s->bitstream_buffer)\n<69> buf_size - current_pos);
<1> static int virtio_net_handle_mac ( VirtIONet * n , uint8_t cmd , VirtQueueElement * elem ) {\n<3> if ( cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET || elem -> out_num != 3 || elem -> out_sg [ 1 ] . iov_len < sizeof ( mac_data ) || elem -> out_sg [ 2 ] . iov_len < sizeof ( mac_data ) ) return VIRTIO_NET_ERR ;\n<8> memset ( n -> mac_table . macs , 0 , MAC_TABLE_ENTRIES * ETH_ALEN ) ;\n<9> mac_data . entries = ldl_p ( elem -> out_sg [ 1 ] . iov_base ) ;\n<11> if ( mac_data . entries <= MAC_TABLE_ENTRIES ) {\n<12> memcpy ( n -> mac_table . macs , elem -> out_sg [ 1 ] . iov_base + sizeof ( mac_data ) , mac_data . entries * ETH_ALEN ) ;\n<19> mac_data . entries = ldl_p ( elem -> out_sg [ 2 ] . iov_base ) ;\n<22> if ( n -> mac_table . in_use + mac_data . entries <= MAC_TABLE_ENTRIES ) {\n<23> memcpy ( n -> mac_table . macs + ( n -> mac_table . in_use * ETH_ALEN ) , elem -> out_sg [ 2 ] . iov_base + sizeof ( mac_data ) , mac_data . entries * ETH_ALEN ) ;
<1> void request_command_data ( int cmd ) {\n<11> printf ( "<BR>" ) ;\n<12> switch ( cmd ) {\n<150> printf ( "<script language=\"JavaScript\">\n" ) ;
<1> static void parse_header_digest(struct iscsi_context *iscsi, const char *target)\n<41> if (!digest) {\n<49> if (!strcmp(digest, "CRC32C")) {\n<51> iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_CRC32C);\n<53> } else if (!strcmp(digest, "NONE")) {\n<55> iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE);\n<57> } else if (!strcmp(digest, "CRC32C-NONE")) {\n<59> iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_CRC32C_NONE);\n<61> } else if (!strcmp(digest, "NONE-CRC32C")) {\n<63> iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n<67> error_report("Invalid header-digest setting : %s", digest);
<1> static const char * cgfs_canonical_path ( void * hdata ) {\n<6> for ( info_ptr = d -> info ;\n<7> info_ptr ;\n<8> info_ptr = info_ptr -> next ) {\n<9> if ( ! path ) path = info_ptr -> cgroup_path ;\n<10> else if ( strcmp ( path , info_ptr -> cgroup_path ) != 0 ) {\n<11> ERROR ( "not all paths match %s, %s has path %s" , path , info_ptr -> hierarchy -> subsystems [ 0 ] , info_ptr -> cgroup_path ) ;\n<12> return NULL ;\n<15> return path ;
<1> int qemuMonitorTextAttachPCIDiskController ( qemuMonitorPtr mon , const char * bus , virDomainDevicePCIAddress * guestAddr ) {\n<6> try_command : if ( virAsprintf ( & cmd , "pci_add %s storage if=%s" , ( tryOldSyntax ? "0" : "pci_addr=auto" ) , bus ) < 0 ) {\n<10> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<14> if ( qemuMonitorTextParsePciAddReply ( mon , reply , guestAddr ) < 0 ) {\n<15> if ( ! tryOldSyntax && strstr ( reply , "invalid char in expression" ) ) {\n<16> VIR_FREE ( reply ) ;\n<17> VIR_FREE ( cmd ) ;\n<18> tryOldSyntax = 1 ;\n<21> qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( "adding %s disk controller failed: %s" ) , bus , reply ) ;
<1> static int mov_write_single_packet(AVFormatContext *s, AVPacket *pkt)\n<5> AVCodecParameters *par = trk->par;\n<23> int side_size = 0;\n<24> uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size);\n<25> if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) {\n<26> void *newextra = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE);\n<27> if (!newextra)\n<29> av_free(par->extradata);\n<30> par->extradata = newextra;\n<31> memcpy(par->extradata, side, side_size);\n<32> par->extradata_size = side_size;
<1> static void test_manual_sample ( ) {\n<14> if ( mysql_query ( mysql , "DROP TABLE IF EXISTS test_table" ) ) {\n<15> fprintf ( stderr , "\n drop table failed" ) ;\n<16> fprintf ( stderr , "\n %s" , mysql_error ( mysql ) ) ;\n<19> if ( mysql_query ( mysql , "CREATE TABLE test_table(col1 int, col2 varchar(50), \ col3 smallint, \ col4 timestamp)" ) ) {\n<20> fprintf ( stderr , "\n create table failed" ) ;\n<21> fprintf ( stderr , "\n %s" , mysql_error ( mysql ) ) ;\n<25> if ( ! ( stmt = mysql_simple_prepare ( mysql , query ) ) ) {\n<26> fprintf ( stderr , "\n prepare, insert failed" ) ;\n<27> fprintf ( stderr , "\n %s" , mysql_error ( mysql ) ) ;\n<30> if ( ! opt_silent ) fprintf ( stdout , "\n prepare, insert successful" ) ;\n<31> param_count = mysql_stmt_param_count ( stmt ) ;\n<32> if ( ! opt_silent ) fprintf ( stdout , "\n total parameters in insert: %d" , param_count ) ;\n<33> if ( param_count != 3 ) {\n<34> fprintf ( stderr , "\n invalid parameter count returned by MySQL" ) ;\n<37> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<47> if ( mysql_stmt_bind_param ( stmt , my_bind ) ) {\n<48> fprintf ( stderr , "\n param bind failed" ) ;\n<49> fprintf ( stderr , "\n %s" , mysql_stmt_error ( stmt ) ) ;\n<55> if ( mysql_stmt_execute ( stmt ) ) {\n<56> fprintf ( stderr , "\n execute 1 failed" ) ;\n<57> fprintf ( stderr , "\n %s" , mysql_stmt_error ( stmt ) ) ;\n<60> affected_rows = mysql_stmt_affected_rows ( stmt ) ;\n<61> if ( ! opt_silent ) fprintf ( stdout , "\n total affected rows: %ld" , ( ulong ) affected_rows ) ;\n<62> if ( affected_rows != 1 ) {\n<63> fprintf ( stderr , "\n invalid affected rows by MySQL" ) ;\n<70> if ( mysql_stmt_execute ( stmt ) ) {\n<71> fprintf ( stderr , "\n execute 2 failed" ) ;\n<72> fprintf ( stderr , "\n %s" , mysql_stmt_error ( stmt ) ) ;\n<75> affected_rows = mysql_stmt_affected_rows ( stmt ) ;\n<76> if ( ! opt_silent ) fprintf ( stdout , "\n total affected rows: %ld" , ( ulong ) affected_rows ) ;\n<77> if ( affected_rows != 1 ) {\n<78> fprintf ( stderr , "\n invalid affected rows by MySQL" ) ;\n<81> if ( mysql_stmt_close ( stmt ) ) {\n<82> fprintf ( stderr , "\n failed while closing the statement" ) ;\n<83> fprintf ( stderr , "\n %s" , mysql_stmt_error ( stmt ) ) ;\n<88> if ( mysql_query ( mysql , "DROP TABLE test_table" ) ) {\n<89> fprintf ( stderr , "\n drop table failed" ) ;\n<90> fprintf ( stderr , "\n %s" , mysql_error ( mysql ) ) ;\n<93> if ( ! opt_silent ) fprintf ( stdout , "Success !!!" ) ;
<1> static int test_choose_instruction ( xd3_stream * stream , int ignore ) {\n<5> i < 256 ;\n<10> memset ( & prev , 0 , sizeof ( prev ) ) ;\n<11> memset ( & inst , 0 , sizeof ( inst ) ) ;\n<13> inst . type = d -> type1 ;\n<14> if ( ( inst . size = d -> size1 ) == 0 ) {\n<15> inst . size = TESTBUFSIZE ;\n<17> XD3_CHOOSE_INSTRUCTION ( stream , NULL , & inst ) ;\n<18> if ( inst . code2 != 0 || inst . code1 != i ) {\n<24> prev . type = d -> type1 ;\n<25> prev . size = d -> size1 ;\n<26> inst . type = d -> type2 ;\n<27> inst . size = d -> size2 ;\n<28> XD3_CHOOSE_INSTRUCTION ( stream , & prev , & inst ) ;\n<29> if ( prev . code2 != i ) {
<1> static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n<29> if (err) {\n<31> fprintf(stderr, "unable to open FDT\n");\n<45> if (err < 0) {\n<47> fprintf(stderr, "couldn't set /chosen/bootargs\n");
<1> int vnc_display_open(DisplayState *ds, const char *display)\n<5> VncDisplay *vs = ds ? (VncDisplay *)ds->opaque : vnc_display;\n<23> if (!vnc_display)\n<29> if (strcmp(display, "none") == 0)\n<31> return 0;\n<35> if (!(vs->display = strdup(display)))\n<37> return -1;\n<41> options = display;\n<43> while ((options = strchr(options, ','))) {\n<45> options++;\n<47> if (strncmp(options, "password", 8) == 0) {\n<51> } else if (strncmp(options, "reverse", 7) == 0) {\n<55> } else if (strncmp(options, "to=", 3) == 0) {\n<131> if (password) {\n<211> if (reverse) {\n<215> if (strncmp(display, "unix:", 5) == 0)\n<223> if (-1 == vs->lsock) {\n<225> free(vs->display);\n<237> vnc_connect(vs, csock);\n<253> if (strncmp(display, "unix:", 5) == 0) {\n<255> pstrcpy(dpy, 256, "unix:");\n<261> vs->lsock = inet_listen(display, dpy, 256, SOCK_STREAM, 5900);\n<265> if (-1 == vs->lsock) {\n<267> free(dpy);\n<273> free(vs->display);
<1> static void postfilter ( AMRContext * p , float * lpc , float * buf_out ) {\n<5> float pole_out [ AMR_SUBFRAME_SIZE + LP_FILTER_ORDER ] ;\n<22> memcpy ( pole_out , p -> postfilter_mem , sizeof ( float ) * LP_FILTER_ORDER ) ;\n<23> ff_celp_lp_synthesis_filterf ( pole_out + LP_FILTER_ORDER , lpc_d , samples , AMR_SUBFRAME_SIZE , LP_FILTER_ORDER ) ;\n<24> memcpy ( p -> postfilter_mem , pole_out + AMR_SUBFRAME_SIZE , sizeof ( float ) * LP_FILTER_ORDER ) ;\n<25> ff_celp_lp_zero_synthesis_filterf ( buf_out , lpc_n , pole_out + LP_FILTER_ORDER , AMR_SUBFRAME_SIZE , LP_FILTER_ORDER ) ;
<1> int archive_write_set_format_iso9660 ( struct archive * _a ) {\n<6> iso9660 = calloc ( 1 , sizeof ( * iso9660 ) ) ;\n<7> if ( iso9660 == NULL ) {\n<11> iso9660 -> birth_time = 0 ;\n<12> iso9660 -> temp_fd = - 1 ;\n<13> iso9660 -> cur_file = NULL ;\n<23> isofile_init_hardlinks ( iso9660 ) ;\n<24> iso9660 -> directories_too_deep = NULL ;\n<25> iso9660 -> dircnt_max = 1 ;\n<26> iso9660 -> wbuff_remaining = wb_buffmax ( ) ;\n<27> iso9660 -> wbuff_type = WB_TO_TEMP ;\n<28> iso9660 -> wbuff_offset = 0 ;\n<29> iso9660 -> wbuff_written = 0 ;\n<30> iso9660 -> wbuff_tail = 0 ;\n<33> archive_string_init ( & ( iso9660 -> volume_identifier ) ) ;\n<37> archive_string_init ( & ( iso9660 -> application_identifier ) ) ;\n<77> iso9660 -> primary . rootent = isoent_create_virtual_dir ( a , iso9660 , "" ) ;\n<78> if ( iso9660 -> primary . rootent == NULL ) {\n<79> free ( iso9660 ) ;
<1> int rebuild_existing_bitmaps ( struct packing_data * mapping , khash_sha1 * reused_bitmaps , int show_progress ) {\n<9> if ( prepare_bitmap_git ( ) < 0 ) return - 1 ;\n<11> reposition = xcalloc ( num_objects , sizeof ( uint32_t ) ) ;\n<21> if ( oe ) reposition [ i ] = oe -> in_pack_pos + 1 ;\n<38> free ( reposition ) ;
<1> static void final(const short *i1, const short *i2,\n<3> void *out, int *statbuf, int len)\n<9> unsigned short int work[50];\n<15> memcpy(work, statbuf,20);\n<17> memcpy(work + 10, i2, len * 2);\n<21> for (i=0; i<len; i++) {\n<37> if (ptr[10] - sum < -32768 || ptr[10] - sum > 32767) {\n<39> memset(out, 0, len * 2);\n<41> memset(statbuf, 0, 20);\n<57> memcpy(out, work+10, len * 2);\n<59> memcpy(statbuf, work + 40, 20);
<1> void uwsgi_php_set ( char * opt ) {\n<2> uwsgi_sapi_module . ini_entries = realloc ( uwsgi_sapi_module . ini_entries , uphp . ini_size + strlen ( opt ) + 2 ) ;\n<3> memcpy ( uwsgi_sapi_module . ini_entries + uphp . ini_size , opt , strlen ( opt ) ) ;\n<4> uphp . ini_size += strlen ( opt ) + 1 ;\n<5> uwsgi_sapi_module . ini_entries [ uphp . ini_size - 1 ] = '\n' ;
<1> int change_logfile ( const char * fname , int leave_crumbs ) {\n<9> log_fname = fname ;\n<10> if ( syslog_file != NULL && syslog_fname != NULL && == strcmp ( syslog_fname , log_fname ) ) return 0 ;\n<11> if ( 0 == strcmp ( log_fname , "stderr" ) ) {\n<12> new_file = stderr ;\n<13> abs_fname = estrdup ( log_fname ) ;\n<15> else if ( 0 == strcmp ( log_fname , "stdout" ) ) {\n<16> new_file = stdout ;\n<17> abs_fname = estrdup ( log_fname ) ;\n<20> if ( syslog_fname != NULL && == strcmp ( log_fname , syslog_fname ) ) log_fname = syslog_abs_fname ;\n<22> cd_octets = strlen ( curdir ) ;\n<23> if ( cd_octets > 1 && DIR_SEP == curdir [ cd_octets - 1 ] ) cd_octets -- ;\n<24> octets = cd_octets ;\n<25> octets += 1 ;\n<26> octets += strlen ( log_fname ) ;\n<27> octets += 1 ;\n<28> abs_fname = emalloc ( octets ) ;\n<29> snprintf ( abs_fname , octets , "%.*s%c%s" , ( int ) cd_octets , curdir , DIR_SEP , log_fname ) ;
<1> static int decode_update_thread_context(AVCodecContext *dst,\n<7> H264Context *h = dst->priv_data, *h1 = src->priv_data;\n<25> (h->width                 != h1->width                 ||\n<27> h->height                != h1->height                ||\n<29> h->mb_width              != h1->mb_width              ||\n<31> h->mb_height             != h1->mb_height             ||\n<33> h->sps.bit_depth_luma    != h1->sps.bit_depth_luma    ||\n<35> h->sps.chroma_format_idc != h1->sps.chroma_format_idc ||\n<37> h->sps.colorspace        != h1->sps.colorspace)) {\n<55> h->width     = h1->width;\n<57> h->height    = h1->height;\n<59> h->mb_height = h1->mb_height;\n<61> h->mb_width  = h1->mb_width;\n<63> h->mb_num    = h1->mb_num;\n<65> h->mb_stride = h1->mb_stride;\n<67> h->b_stride  = h1->b_stride;\n<75> h->sps = h1->sps;\n<81> h->pps = h1->pps;\n<85> if ((err = h264_slice_header_init(h, 1)) < 0) {\n<113> h->linesize   = h1->linesize;\n<115> h->uvlinesize = h1->uvlinesize;\n<121> memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset));\n<125> if (!inited) {\n<139> memcpy(h, h1, offsetof(H264Context, intra_pcm_ptr));\n<143> sizeof(H264Context) - offsetof(H264Context, cabac));\n<145> av_assert0((void*)&h->cabac == &h->mb_padding + 1);\n<149> memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n<151> memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n<155> memset(&h->er, 0, sizeof(h->er));\n<157> memset(&h->me, 0, sizeof(h->me));\n<159> memset(&h->mb, 0, sizeof(h->mb));\n<161> memset(&h->mb_luma_dc, 0, sizeof(h->mb_luma_dc));\n<163> memset(&h->mb_padding, 0, sizeof(h->mb_padding));\n<181> if (h1->context_initialized) {\n<187> memset(&h->cur_pic, 0, sizeof(h->cur_pic));\n<195> ret = ff_h264_alloc_tables(h);\n<205> ret = context_init(h);\n<233> h->thread_context[0] = h;\n<235> h->context_initialized = h1->context_initialized;\n<249> h->coded_picture_number = h1->coded_picture_number;\n<251> h->first_field          = h1->first_field;\n<253> h->picture_structure    = h1->picture_structure;\n<255> h->qscale               = h1->qscale;\n<257> h->droppable            = h1->droppable;\n<259> h->data_partitioning    = h1->data_partitioning;\n<261> h->low_delay            = h1->low_delay;\n<265> for (i = 0; h->DPB && i < MAX_PICTURE_COUNT; i++) {\n<267> unref_picture(h, &h->DPB[i]);\n<271> (ret = ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0)\n<279> h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1);\n<281> unref_picture(h, &h->cur_pic);\n<283> if (h1->cur_pic.f.buf[0] && (ret = ref_picture(h, &h->cur_pic, &h1->cur_pic)) < 0)\n<291> h->low_delay       = h1->low_delay;\n<293> h->droppable       = h1->droppable;\n<305> copy_parameter_set((void **)h->sps_buffers, (void **)h1->sps_buffers,\n<311> copy_parameter_set((void **)h->pps_buffers, (void **)h1->pps_buffers,\n<323> copy_fields(h, h1, dequant4_buffer, dequant4_coeff);\n<349> copy_fields(h, h1, poc_lsb, redundant_pic_count);\n<355> copy_fields(h, h1, short_ref, cabac_init_idc);\n<359> copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1);\n<361> copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1);\n<363> copy_picture_range(h->delayed_pic, h1->delayed_pic,\n<375> h264_set_parameter_from_sps(h);\n<387> err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
<1> static void set_pci_devfn(Object *obj, Visitor *v, void *opaque,\n<17> char *str = (char *)"";\n<31> visit_type_str(v, &str, name, &local_err);\n<33> if (local_err) {\n<43> if (sscanf(str, "%x.%x%n", &slot, &fn, &n) != 2) {\n<45> fn = 0;\n<47> if (sscanf(str, "%x%n", &slot, &n) != 1) {\n<55> if (str[n] != '\0' || fn > 7 || slot > 31) {\n<61> *ptr = slot << 3 | fn;\n<69> error_set_from_qdev_prop_error(errp, EINVAL, dev, prop, str);
<1> static void xps_parse_poly_line_segment ( fz_context * doc , fz_path * path , fz_xml * root , int stroking , int * skipped_stroke ) {\n<3> char * is_stroked_att = fz_xml_att ( root , "IsStroked" ) ;\n<7> if ( ! points_att ) {\n<12> if ( is_stroked_att && ! strcmp ( is_stroked_att , "false" ) ) is_stroked = 0 ;
<1> static void test_bug6059 ( ) {\n<5> stmt_text = "SELECT 'foo' INTO OUTFILE 'x.3'" ;\n<6> stmt = mysql_stmt_init ( mysql ) ;\n<7> ( void ) mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<8> DIE_UNLESS ( mysql_stmt_field_count ( stmt ) == 0 ) ;
<1> int chk_key ( MI_CHECK * param , register MI_INFO * info ) {\n<25> rec_per_key_part = param -> rec_per_key_part ;\n<28> rec_per_key_part += keyinfo -> keysegs , key ++ , keyinfo ++ ) {\n<30> if ( ! mi_is_key_active ( share -> state . key_map , key ) ) {\n<31> memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n<38> if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( "- check data record references index: %d\n" , key + 1 ) ;\n<42> mi_check_print_error ( param , "Can't read indexpage from filepos: %s" , llstr ( share -> state . key_root [ key ] , buff ) ) ;\n<51> param -> max_level = 0 ;\n<52> if ( chk_index ( param , info , keyinfo , share -> state . key_root [ key ] , info -> buff , & keys , param -> key_crc + key , 1 ) ) DBUG_RETURN ( - 1 ) ;\n<69> if ( ( uint ) share -> base . auto_key - 1 == key ) {\n<75> mi_check_print_warning ( param , "Auto-increment value: %s is smaller " "than max used value: %s" , llstr ( info -> s -> state . auto_increment , buff2 ) , llstr ( auto_increment , buff ) ) ;\n<83> if ( ! mi_rkey ( info , info -> rec_buff , key , ( const uchar * ) info -> lastkey , ( key_part_map ) 1 , HA_READ_KEY_EXACT ) ) {\n<85> mi_check_print_warning ( param , "Found row where the auto_increment " "column has the value 0" ) ;\n<91> if ( param -> testflag & T_INFO && param -> totaldata != 0L && keys != 0L ) printf ( "Key: %2d: Keyblocks used: %3d%% Packed: %4d%% Max levels: %2d\n" , key + 1 , ( int ) ( my_off_t2double ( param -> keydata ) * 100.0 / my_off_t2double ( param -> totaldata ) ) , ( int ) ( ( my_off_t2double ( length ) - my_off_t2double ( param -> keydata ) ) * 100.0 / my_off_t2double ( length ) ) , param -> max_level ) ;\n<98> if ( all_totaldata != 0L && found_keys > 0 ) printf ( "Total: Keyblocks used: %3d%% Packed: %4d%%\n\n" , ( int ) ( my_off_t2double ( all_keydata ) * 100.0 / my_off_t2double ( all_totaldata ) ) , ( int ) ( ( my_off_t2double ( key_totlength ) - my_off_t2double ( all_keydata ) ) * 100.0 / my_off_t2double ( key_totlength ) ) ) ;\n<101> if ( param -> key_file_blocks != info -> state -> key_file_length && param -> keys_in_use != ~ ( ulonglong ) 0 ) mi_check_print_warning ( param , "Some data are unreferenced in keyfile" ) ;
<1> static int alloc_tl_data ( krb5_int16 n_tl_data , krb5_tl_data * * tldp ) {\n<5> i < n_tl_data ;\n<7> * tlp = calloc ( 1 , sizeof ( krb5_tl_data ) ) ;\n<8> if ( * tlp == NULL ) return ENOMEM ;\n<9> memset ( * tlp , 0 , sizeof ( krb5_tl_data ) ) ;
<1> static void init_mbr(BDRVVVFATState* s)\n<15> memset(s->first_sectors,0,512);
<13> if ( cmptno < image -> numcmpts_ ) {\n<14> memmove ( & image -> cmpts_ [ cmptno + 1 ] , & image -> cmpts_ [ cmptno ] , ( image -> numcmpts_ - cmptno ) * sizeof ( jas_image_cmpt_t * ) ) ;
<1> void fw_cfg_add_string(FWCfgState *s, uint16_t key, const char *value)\n<5> size_t sz = strlen(value) + 1;\n<9> return fw_cfg_add_bytes(s, key, (uint8_t *)g_memdup(value, sz), sz);
<1> static int get_cod(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n<7> tmp.csty = bytestream2_get_byteu(&s->g);\n<9> tmp.prog_order = bytestream2_get_byteu(&s->g);\n<10> tmp.nlayers    = bytestream2_get_be16u(&s->g);\n<11> tmp.mct        = bytestream2_get_byteu(&s->g); // multiple component transformation\n<12> if ((ret = get_cox(s, &tmp)) < 0)\n<14> for (compno = 0; compno < s->ncomponents; compno++)\n<15> if (!(properties[compno] & HAD_COC))\n<16> memcpy(c + compno, &tmp, sizeof(tmp));
<1> static PyObject * elements_to_dict ( PyObject * self , const char * string , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) {\n<7> while ( position < max ) {\n<10> int type = ( int ) string [ position ++ ] ;\n<11> int name_length = strlen ( string + position ) ;\n<12> if ( position + name_length >= max ) {\n<19> name = PyUnicode_DecodeUTF8 ( string + position , name_length , "strict" ) ;\n<25> value = get_value ( self , string , & position , type , max - position , as_class , tz_aware , uuid_subtype ) ;
<1> static void server_port_read ( struct evdns_server_port * s ) {\n<9> addrlen = sizeof ( struct sockaddr_storage ) ;\n<10> r = recvfrom ( s -> socket , packet , sizeof ( packet ) , 0 , ( struct sockaddr * ) & addr , & addrlen ) ;\n<11> if ( r < 0 ) {\n<12> int err = last_error ( s -> socket ) ;\n<13> if ( error_is_eagain ( err ) ) return ;\n<14> log ( EVDNS_LOG_WARN , "Error %s (%d) while reading request." , strerror ( err ) , err ) ;\n<17> request_parse ( packet , r , s , ( struct sockaddr * ) & addr , addrlen ) ;
<1> static int qemu_rdma_accept(RDMAContext *rdma)\n<37> if (cm_event->event != RDMA_CM_EVENT_CONNECT_REQUEST) {\n<47> memcpy(&cap, cm_event->param.conn.private_data, sizeof(cap));\n<51> network_to_caps(&cap);\n<55> if (cap.version < 1 || cap.version > RDMA_CONTROL_VERSION_CURRENT) {\n<57> fprintf(stderr, "Unknown source RDMA version: %d, bailing...\n",\n<75> cap.flags &= known_capabilities;\n<87> if (cap.flags & RDMA_CAPABILITY_PIN_ALL) {\n<109> caps_to_network(&cap);\n<121> } else if (rdma->verbs != verbs) {\n<123> fprintf(stderr, "ibv context not matching %p, %p!\n",\n<139> if (ret) {\n<141> fprintf(stderr, "rdma migration: error allocating pd and cq!\n");\n<151> if (ret) {\n<153> fprintf(stderr, "rdma migration: error allocating qp!\n");\n<163> if (ret) {\n<165> fprintf(stderr, "rdma migration: error initializing ram blocks!\n");\n<175> ret = qemu_rdma_reg_control(rdma, idx);\n<177> if (ret) {\n<179> fprintf(stderr, "rdma: error registering %d control!\n", idx);\n<193> ret = rdma_accept(rdma->cm_id, &conn_param);\n<195> if (ret) {\n<197> fprintf(stderr, "rdma_accept returns %d!\n", ret);\n<205> ret = rdma_get_cm_event(rdma->channel, &cm_event);\n<207> if (ret) {\n<209> fprintf(stderr, "rdma_accept get_cm_event failed %d!\n", ret);\n<217> if (cm_event->event != RDMA_CM_EVENT_ESTABLISHED) {\n<219> fprintf(stderr, "rdma_accept not event established!\n");\n<237> if (ret) {\n<239> fprintf(stderr, "rdma migration: error posting second control recv!\n");\n<257> rdma->error_state = ret;\n<259> qemu_rdma_cleanup(rdma);\n<261> return ret;
<1> static int mpc7_decode_frame(AVCodecContext * avctx,\n<9> MPCContext *c = avctx->priv_data;\n<31> memset(bands, 0, sizeof(bands));\n<151> memset(Q, 0, sizeof(Q));\n<159> idx_to_quant(c, &gb, bands[i].res[ch], Q[ch] + off);\n<163> memset(c->sb_samples, 0, sizeof(c->sb_samples));\n<219> mpc_synth(c, data);
<1> static void kadmin_free_tl_data ( krb5_int16 * n_tl_datap , krb5_tl_data * * tl_datap ) {\n<8> tl_data && ( i < n_tl_data ) ;\n<11> free ( tl_data -> tl_data_contents ) ;\n<12> free ( tl_data ) ;
<1> int wep_decrypt ( u_char * buf , size_t len , u_char * wkey , size_t wlen ) {\n<3> u_char seed [ 32 ] ;\n<8> wep = ( struct wep_header * ) buf ;\n<9> len -= sizeof ( struct wep_header ) ;\n<11> if ( wep -> key * 5 > ( int ) ( MAX_WKEY_LEN - wlen ) ) {\n<15> memcpy ( seed , wep -> init_vector , WEP_IV_LEN ) ;\n<16> memcpy ( seed + WEP_IV_LEN , & wkey [ wep -> key * 5 ] , wlen ) ;\n<17> RC4_set_key ( & key , WEP_IV_LEN + wlen , seed ) ;\n<19> if ( CRC_checksum ( decbuf , len + WEP_CRC_LEN , CRC_INIT ) != CRC_RESULT ) {\n<22> memcpy ( buf , decbuf , len ) ;\n<23> memset ( buf + len , 0 , WEP_CRC_LEN ) ;
<1> int jas_stream_printf ( jas_stream_t * stream , const char * fmt , ... ) {\n<5> va_start ( ap , fmt ) ;\n<6> ret = vsnprintf ( buf , sizeof buf , fmt , ap ) ;\n<7> jas_stream_puts ( stream , buf ) ;\n<8> va_end ( ap ) ;\n<9> return ret ;
<1> static void calc_diffs(const DecimateContext *dm, struct qitem *q,\n<9> int64_t *bdiffs = dm->bdiffs;\n<15> memset(bdiffs, 0, dm->bdiffsize * sizeof(*bdiffs));\n<73> bdiffs[ydest * dm->nxblocks + xdest] += acc;        \\n<123> q->totdiff += bdiffs[i];
<1> int test_mont ( BIO * bp , BN_CTX * ctx ) {\n<45> if ( ! BN_is_zero ( & d ) ) {\n<46> fprintf ( stderr , "Montgomery multiplication test failed!\n" ) ;
<1> int print_encoded_msg ( FILE * fd , char * code , char * prefix ) {\n<5> payload = ( unsigned char * ) code ;\n<6> memcpy ( & i , code , 2 ) ;\n<7> memcpy ( & j , & code [ MSG_START_IDX ] , 2 ) ;\n<8> memcpy ( & msglen , & code [ MSG_LEN_IDX ] , 2 ) ;\n<9> i = ntohs ( i ) ;\n<10> j = ntohs ( j ) ;\n<11> msglen = ntohs ( msglen ) ;\n<13> k < j ;\n<14> k ++ ) fprintf ( fd , "%s%d%s" , k == 0 ? "ENCODED-MSG:[" : ":" , payload [ k ] , k == j - 1 ? "]\n" : "" ) ;\n<15> msg = ( char * ) & payload [ j ] ;\n<16> fprintf ( fd , "MESSAGE:\n[%.*s]\n" , msglen , msg ) ;\n<17> r = ( i < 100 ) ? 1 : 0 ;\n<18> if ( r ) {\n<19> fprintf ( fd , "%sREQUEST CODE=%d==%.*s,URI=%.*s,VERSION=%*.s\n" , prefix , i , payload [ METHOD_CODE_IDX + 1 ] , & msg [ payload [ METHOD_CODE_IDX ] ] , payload [ URI_REASON_IDX + 1 ] , & msg [ payload [ URI_REASON_IDX ] ] , payload [ VERSION_IDX + 1 ] , & msg [ payload [ VERSION_IDX ] ] ) ;\n<20> print_encoded_uri ( fd , & payload [ REQUEST_URI_IDX + 1 ] , payload [ REQUEST_URI_IDX ] , msg , 50 , strcat ( prefix , " " ) ) ;\n<21> prefix [ strlen ( prefix ) - 2 ] = 0 ;\n<25> fprintf ( fd , "%sRESPONSE CODE=%d==%.*s,REASON=%.*s,VERSION=%.*s\n" , prefix , i , payload [ METHOD_CODE_IDX + 1 ] , & msg [ payload [ METHOD_CODE_IDX ] ] , payload [ URI_REASON_IDX + 1 ] , & msg [ payload [ URI_REASON_IDX ] ] , payload [ VERSION_IDX + 1 ] , & msg [ payload [ VERSION_IDX ] ] ) ;\n<29> j = msglen - k ;\n<30> fprintf ( fd , "%sMESSAGE CONTENT:%.*s\n" , prefix , j , & msg [ k ] ) ;\n<31> j = payload [ i ] ;\n<32> fprintf ( fd , "%sHEADERS PRESENT(%d):" , prefix , j ) ;\n<33> i ++ ;\n<34> for ( k = i ;\n<35> k < i + ( j * 3 ) ;\n<36> k += 3 ) fprintf ( fd , "%c%d%c" , k == i ? '[' : ',' , payload [ k ] , k == ( i + 3 * j - 3 ) ? ']' : ' ' ) ;\n<37> fprintf ( fd , "\n" ) ;\n<38> for ( k = i ;\n<39> k < i + ( j * 3 ) ;\n<41> memcpy ( & l , & payload [ k + 1 ] , 2 ) ;\n<42> memcpy ( & m , & payload [ k + 4 ] , 2 ) ;\n<43> l = ntohs ( l ) ;\n<44> m = ntohs ( m ) ;\n<45> print_encoded_header ( fd , msg , msglen , & payload [ l ] , m - l , payload [ k ] , prefix ) ;
<1> static void lm32_evr_init(MachineState *machine)\n<63> cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));\n<65> if (cpu == NULL) {\n<67> fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model);\n<145> kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n<165> if (kernel_size < 0) {\n<167> fprintf(stderr, "qemu: could not load kernel '%s'\n",
<1> static void test_fetch_null ( ) {\n<18> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<20> i < ( int ) array_elements ( my_bind ) ;\n<40> i < 10 ;\n<41> i ++ ) {\n<42> if ( ! opt_silent ) fprintf ( stdout , "\n data[%d] : %s" , i , is_null [ i ] ? "NULL" : "NOT NULL" ) ;\n<45> if ( ! opt_silent ) fprintf ( stdout , "\n data[%d]: %d" , i , nData ) ;\n<46> DIE_UNLESS ( nData == 1000 || nData == 88 || nData == 389789 ) ;
<1> static void test_cuted_rows ( ) {\n<13> count = mysql_warning_count ( mysql ) ;\n<14> if ( ! opt_silent ) fprintf ( stdout , "\n total warnings: %d" , count ) ;\n<15> DIE_UNLESS ( count == 0 ) ;\n<18> count = mysql_warning_count ( mysql ) ;\n<19> if ( ! opt_silent ) fprintf ( stdout , "\n total warnings: %d" , count ) ;\n<20> DIE_UNLESS ( count == 2 ) ;\n<30> count = mysql_warning_count ( mysql ) ;\n<31> if ( ! opt_silent ) fprintf ( stdout , "\n total warnings: %d" , count ) ;\n<32> DIE_UNLESS ( count == 2 ) ;
<1> static void ehci_reset(void *opaque)\n<39> memset(&s->mmio[OPREGBASE], 0x00, MMIO_SIZE - OPREGBASE);
<1> int main ( int argc , char * * argv ) {\n<5> myisamchk_init ( & check_param ) ;\n<6> check_param . opt_lock_memory = 1 ;\n<7> check_param . using_global_keycache = 0 ;\n<12> int new_error = myisamchk ( & check_param , * ( argv ++ ) ) ;\n<13> if ( ( check_param . testflag & T_REP_ANY ) != T_REP ) check_param . testflag &= ~ T_REP ;\n<16> if ( ( check_param . error_printed | check_param . warning_printed ) && ( check_param . testflag & T_FORCE_CREATE ) && ( ! ( check_param . testflag & ( T_REP | T_REP_BY_SORT | T_SORT_RECORDS | T_SORT_INDEX ) ) ) ) {\n<19> check_param . testflag &= ~ T_EXTEND ;\n<20> error |= myisamchk ( & check_param , argv [ - 1 ] ) ;\n<21> check_param . testflag = old_testflag ;\n<26> if ( argc && ( ! ( check_param . testflag & T_SILENT ) || check_param . testflag & T_INFO ) ) {\n<31> if ( check_param . total_files > 1 ) {\n<34> printf ( "\nTotal of all %d MyISAM-files:\nData records: %9s Deleted blocks: %9s\n" , check_param . total_files , llstr ( check_param . total_records , buff ) , llstr ( check_param . total_deleted , buff2 ) ) ;
<1> static void ivshmem_check_version(void *opaque, const uint8_t * buf, int size)\n<23> if (tmp != -1 || version != IVSHMEM_PROTOCOL_VERSION) {\n<25> fprintf(stderr, "incompatible version, you are connecting to a ivshmem-"
<1> static char * xmlrpc_parse ( char * buffer ) {\n<3> tmp = strstr ( buffer , "<?xml" ) ;\n<5> return xmlrpc_normalizeBuffer ( tmp ) ;
<1> static void init_syntax_tree ( config_tree * ptree ) {\n<2> memset ( ptree , 0 , sizeof ( * ptree ) ) ;
<1> static int prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,\n<17> if (avc == NULL) {\n<55> avf_sdp_create(&avc, 1, *pbuffer, 2048);\n<62> return strlen(*pbuffer);
<1> static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) {\n<4> int num_versions = 1 ;\n<8> if ( n_key_data <= 0 ) return NULL ;\n<9> key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ;\n<10> if ( key_data_in == NULL ) goto cleanup ;\n<11> memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ;\n<24> i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ;\n<25> ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ;\n<26> if ( ret == NULL ) {\n<36> if ( ret [ j ] == NULL ) goto cleanup ;\n<37> err = asn1_encode_sequence_of_keys ( key_data + last , ( krb5_int16 ) i - last + 1 , mkvno , & code ) ;\n<38> if ( err ) goto cleanup ;\n<39> ret [ j ] -> bv_len = code -> length ;\n<40> ret [ j ] -> bv_val = code -> data ;\n<41> free ( code ) ;\n<47> ret [ num_versions ] = NULL ;\n<48> cleanup : free ( key_data ) ;\n<50> if ( ret != NULL ) {\n<53> i ++ ) if ( ret [ i ] != NULL ) free ( ret [ i ] ) ;\n<54> free ( ret ) ;\n<58> return ret ;
<1> static CharDriverState *net_vhost_parse_chardev(const NetdevVhostUserOptions *opts)\n<11> if (chr == NULL) {\n<23> memset(&props, 0, sizeof(props));\n<25> if (qemu_opt_foreach(chr->opts, net_vhost_chardev_opts, &props, NULL)) {\n<33> if (!props.is_socket || !props.is_unix) {
<1> static int get_cookies(HTTPContext *s, char **cookies, const char *path,\n<3> const char *domain)\n<27> char *param, *next_param, *cdomain = NULL, *cpath = NULL, *cvalue = NULL;\n<40> cpath = av_strdup(&param[5]);\n<61> cvalue = av_strdup(param);\n<71> if (!cdomain || !cpath || !cvalue) {\n<85> if (av_strncasecmp(path, cpath, strlen(cpath)))\n<93> domain_offset = strlen(domain) - strlen(cdomain);\n<95> if (domain_offset < 0)\n<103> if (av_strcasecmp(&domain[domain_offset], cdomain))\n<111> if (!*cookies) {\n<125> size_t str_size = strlen(cvalue) + strlen(*cookies) + 3;\n<127> if (!(*cookies = av_malloc(str_size))) {\n<135> snprintf(*cookies, str_size, "%s; %s", tmp, cvalue);\n<147> av_free(cvalue);
<1> static char * gs_main_tempnames ( gs_main_instance * minst ) {\n<6> char * tempnames = NULL ;\n<10> const byte * data = NULL ;\n<16> if ( obj_string_data ( minst -> heap , & keyval [ 0 ] , & data , & size ) >= 0 ) len += size + 1 ;\n<18> if ( len != 0 ) tempnames = ( char * ) malloc ( len + 1 ) ;\n<19> if ( tempnames ) {\n<20> memset ( tempnames , 0 , len + 1 ) ;\n<22> i = 0 ;\n<24> if ( obj_string_data ( minst -> heap , & keyval [ 0 ] , & data , & size ) >= 0 ) {\n<25> memcpy ( tempnames + i , ( const char * ) data , size ) ;\n<26> i += size ;\n<27> tempnames [ i ++ ] = '\0' ;\n<32> return tempnames ;
<1> int add_exec(struct ex_list **ex_ptr, int do_pty, char *exec,\n<13> for (tmp_ptr = *ex_ptr; tmp_ptr; tmp_ptr = tmp_ptr->ex_next) {\n<27> *ex_ptr = (struct ex_list *)malloc(sizeof(struct ex_list));\n<35> (*ex_ptr)->ex_exec = (do_pty == 3) ? exec : strdup(exec);
<1> static gcry_err_code_t oaep_encode ( gcry_mpi_t * r_result , unsigned int nbits , int algo , const unsigned char * value , size_t valuelen , const unsigned char * label , size_t labellen , const void * random_override , size_t random_override_len ) {\n<19> if ( ! frame ) return gpg_err_code_from_syserror ( ) ;\n<21> n = nframe - valuelen - 1 ;\n<22> frame [ n ] = 0x01 ;\n<23> memcpy ( frame + n + 1 , value , valuelen ) ;\n<25> if ( random_override_len != hlen ) {\n<29> memcpy ( frame + 1 , random_override , hlen ) ;\n<34> dmask = gcry_malloc_secure ( nframe - hlen - 1 ) ;
<1> void ff_h264_direct_ref_list_init(H264Context * const h){\n<29> if(s->picture_structure == PICT_FRAME){\n<31> memcpy(cur->ref_count[1], cur->ref_count[0], sizeof(cur->ref_count[0]));\n<33> memcpy(cur->ref_poc  [1], cur->ref_poc  [0], sizeof(cur->ref_poc  [0]));
<1> CURLcode Curl_add_buffer ( Curl_send_buffer * in , const void * inptr , size_t size ) {\n<4> if ( ~ size < in -> size_used ) {\n<5> Curl_safefree ( in -> buffer ) ;\n<6> free ( in ) ;\n<9> if ( ! in -> buffer || ( ( in -> size_used + size ) > ( in -> size_max - 1 ) ) ) {\n<10> if ( ( size > ( size_t ) - 1 / 2 ) || ( in -> size_used > ( size_t ) - 1 / 2 ) || ( ~ ( size * 2 ) < ( in -> size_used * 2 ) ) ) new_size = ( size_t ) - 1 ;\n<11> else new_size = ( in -> size_used + size ) * 2 ;\n<12> if ( in -> buffer ) new_rb = realloc ( in -> buffer , new_size ) ;\n<13> else new_rb = malloc ( new_size ) ;\n<14> if ( ! new_rb ) {\n<15> Curl_safefree ( in -> buffer ) ;\n<16> free ( in ) ;\n<19> in -> buffer = new_rb ;\n<20> in -> size_max = new_size ;\n<22> memcpy ( & in -> buffer [ in -> size_used ] , inptr , size ) ;\n<23> in -> size_used += size ;
<1> static void new_subtitle_stream(AVFormatContext *oc, int file_idx)\n<19> if (!st) {\n<21> fprintf(stderr, "Could not alloc stream\n");
<1> void var_copy ( VAR * dest , VAR * src ) {\n<5> if ( dest -> alloced_len < src -> alloced_len && ! ( dest -> str_val = dest -> str_val ? ( char * ) my_realloc ( dest -> str_val , src -> alloced_len , MYF ( MY_WME ) ) : ( char * ) my_malloc ( src -> alloced_len , MYF ( MY_WME ) ) ) ) die ( "Out of memory" ) ;\n<8> if ( src -> str_val_len ) memcpy ( dest -> str_val , src -> str_val , src -> str_val_len ) ;
<1> static int getSingletonPos ( const char * str ) {\n<5> if ( str && ( ( len = strlen ( str ) ) > 0 ) ) {\n<6> for ( i = 0 ;\n<7> i < len ;\n<9> if ( isIDSeparator ( * ( str + i ) ) ) {
<1> static int xen_pt_config_reg_init(XenPCIPassthroughState *s,\n<15> reg_entry = g_new0(XenPTReg, 1);\n<29> if (rc < 0) {\n<31> free(reg_entry);\n<37> if (data == XEN_PT_INVALID_REG) {\n<41> free(reg_entry);
<1> static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n<65> H2645NAL *nal = &h2645_pkt.nals[i];\n<141> H2645NAL *nal = &h2645_pkt.nals[i];\n<143> if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n<147> AV_WB24(extradata, 1); // startcode\n<149> memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n<151> extradata += 3 + nal->raw_size;\n<153> } else if (s->remove) {\n<155> AV_WB24(filtered_data, 1); // startcode\n<157> memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n<159> filtered_data += 3 + nal->raw_size;
<1> static int tgv_decode_frame(AVCodecContext *avctx,\n<13> TgvContext *s          = avctx->priv_data;\n<55> av_freep(&s->frame_buffer);\n<73> s->palette[i] = 0xFFU << 24 | AV_RB24(buf);\n<83> if ((ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n<89> memcpy(frame->data[1], s->palette, AVPALETTE_SIZE);\n<111> if (unpack(buf, buf_end, s->frame_buffer, s->avctx->width, s->avctx->height) < 0) {\n<119> for (y = 0; y < s->height; y++)\n<121> memcpy(frame->data[0]  + y * frame->linesize[0],\n<123> s->frame_buffer + y * s->width,\n<141> if (tgv_decode_inter(s, frame, buf, buf_end) < 0) {
<1> static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<451> if (!(avctx->flags & CODEC_FLAG_BITEXACT))\n<455> strlen(LIBAVCODEC_IDENT) + 1, LIBAVCODEC_IDENT);
<1> int dtls_get_message ( SSL * s , int * mt , unsigned long * len ) {\n<7> msg_hdr = & s -> d1 -> r_msg_hdr ;\n<8> memset ( msg_hdr , 0 , sizeof ( * msg_hdr ) ) ;\n<25> msg_len = msg_hdr -> msg_len ;\n<26> * ( p ++ ) = msg_hdr -> type ;\n<28> s2n ( msg_hdr -> seq , p ) ;\n<35> if ( ! ssl3_finish_mac ( s , p , msg_len ) ) return 0 ;\n<37> memset ( msg_hdr , 0 , sizeof ( * msg_hdr ) ) ;
<1> static void test_bug43560 ( void ) {\n<8> const uint BUFSIZE = sizeof ( buffer ) ;\n<12> const char insert_str [ ] = "INSERT INTO t1 (c2) VALUES (?)" ;\n<17> if ( ! strstr ( mysql -> server_version , "debug" ) ) {\n<18> fprintf ( stdout , "Skipping test_bug43560: server not DEBUG version\n" ) ;\n<27> check_stmt ( stmt ) ;\n<28> rc = mysql_stmt_prepare ( stmt , insert_str , strlen ( insert_str ) ) ;\n<29> check_execute ( stmt , rc ) ;\n<30> memset ( & bind , 0 , sizeof ( bind ) ) ;\n<36> rc = mysql_stmt_bind_param ( stmt , & bind ) ;\n<38> strncpy ( buffer , values [ 0 ] , BUFSIZE ) ;\n<39> length = strlen ( buffer ) ;\n<44> strncpy ( buffer , values [ 1 ] , BUFSIZE ) ;\n<45> length = strlen ( buffer ) ;\n<48> strncpy ( buffer , values [ 2 ] , BUFSIZE ) ;\n<49> length = strlen ( buffer ) ;\n<55> rc = mysql_query ( mysql , "DROP TABLE t1" ) ;
<23> if (!feed)\n<29> q = strrchr(feed->filename, '>');\n<37> for (s = config->first_feed; s; s = s->next) {\n<39> if (!strcmp(feed->filename, s->filename))\n<41> ERROR("Feed '%s' already registered\n", s->filename);\n<51> snprintf(feed->feed_filename, sizeof(feed->feed_filename),
<1> static void bios_supports_mode(const char *pmutils_bin, const char *pmutils_arg,\n<33> if (!pid) {\n<39> memset(&act, 0, sizeof(act));\n<43> sigaction(SIGCHLD, &act, NULL);\n<61> if (!pid) {\n<87> if (!sysfile_str) {\n<105> ret = read(fd, buf, sizeof(buf)-1);\n<113> buf[ret] = '\0';\n<117> if (strstr(buf, sysfile_str)) {\n<119> _exit(SUSPEND_SUPPORTED);
<1> static void vncws_send_handshake_response(VncState *vs, const char* key)\n<37> if (accept == NULL) {\n<49> response = g_strdup_printf(WS_HANDSHAKE, accept);\n<51> vnc_write(vs, response, strlen(response));\n<53> vnc_flush(vs);\n<59> g_free(response);
<1> static int rollstack ( struct psstack * stack , int sp ) {\n<8> if ( sp >= n && n > 0 ) {\n<11> temp = malloc ( n * sizeof ( struct psstack ) ) ;\n<14> ++ i ) temp [ i ] = stack [ sp - n + i ] ;\n<17> ++ i ) stack [ sp - n + ( i + j ) % n ] = temp [ i ] ;\n<18> free ( temp ) ;
<1> static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) {\n<39> get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ;\n<40> qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ;\n<43> while ( group_start < tile_cols ) {\n<46> memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ;\n<47> tile_buffers [ 0 ] [ group_end ] = largest ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<7> frame_4cc = AV_RL32 ( buf ) ;\n<11> const int data_size = buf_size - 20 ;\n<28> cfrm = & f -> cfrm [ i ] ;\n<30> if ( ! cfrm -> data ) {\n<34> memcpy ( cfrm -> data + cfrm -> size , buf + 20 , data_size ) ;\n<35> cfrm -> size += data_size ;\n<63> if ( ! f -> last_picture -> data [ 0 ] ) {\n<64> if ( ( ret = ff_get_buffer ( avctx , f -> last_picture , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) {\n<68> memset ( f -> last_picture -> data [ 0 ] , 0 , avctx -> height * FFABS ( f -> last_picture -> linesize [ 0 ] ) ) ;
<1> static int aac_decode_frame(AVCodecContext *avccontext, void *data,\n<74> switch (elem_type) {\n<120> enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];\n<122> memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));\n<124> if ((err = decode_pce(ac, new_che_pos, &gb)))
<1> int main ( int argc , char * * argv ) {\n<29> extcap_base_set_util_info ( extcap_conf , ANDROIDDUMP_VERSION_MAJOR , ANDROIDDUMP_VERSION_MINOR , ANDROIDDUMP_VERSION_RELEASE , NULL ) ;\n<30> while ( ( result = getopt_long ( argc , argv , "" , longopts , & option_idx ) ) != - 1 ) {\n<31> switch ( result ) {\n<32> case OPT_VERSION : printf ( "%s.%s.%s\n" , ANDROIDDUMP_VERSION_MAJOR , ANDROIDDUMP_VERSION_MINOR , ANDROIDDUMP_VERSION_RELEASE ) ;\n<77> default : if ( ! extcap_base_parse_options ( extcap_conf , result - EXTCAP_OPT_LIST_INTERFACES , optarg ) ) {\n<78> printf ( "Invalid argument <%s>. Try --help.\n" , argv [ optind - 1 ] ) ;
<1> static void generate_token_text ( void ) {\n<10> id_count = highest_id - lowest_id + 1 ;\n<11> printf ( "#define LOWEST_KEYWORD_ID %d\n\n" , lowest_id ) ;\n<16> while ( i < COUNTOF ( ntp_keywords ) ) {\n<17> while ( id < ntp_keywords [ i ] . token ) {\n<18> printf ( ",\n\t/* %-5d %5d %20s */\tNULL" , id - lowest_id , id , symbname ( id ) ) ;\n<19> id ++ ;\n<21> if ( i > 0 ) printf ( "," ) ;\n<22> printf ( "\n\t/* %-5d %5d %20s */\t\"%s\"" , id - lowest_id , id , symbname ( id ) , ntp_keywords [ i ] . key ) ;\n<24> id ++ ;
<1> static int hq_decode_block(HQContext *c, GetBitContext *gb, int16_t block[64],\n<13> memset(block, 0, 64 * sizeof(*block));
<1> static int match_version ( const char * string , struct link_map * map ) {\n<2> const char * strtab = ( const void * ) D_PTR ( map , l_info [ DT_STRTAB ] ) ;\n<8> if ( strcmp ( string , strtab + aux -> vda_name ) == 0 ) return 1 ;\n<9> if ( def -> vd_next == 0 ) break ;
<1> static int decompress_p(AVCodecContext *avctx,\n<39> ret |= decode_value(s, s->range_model, 256, 1, &temp);\n<41> if (ret < 0)\n<49> memset(s->blocks, 0, sizeof(*s->blocks) * s->nbcount);\n<59> ret  = decode_value(s, s->fill_model,  5,   10, &fill);\n<61> ret |= decode_value(s, s->count_model, 256, 20, &count);\n<95> ret  = decode_value(s, s->sxy_model[0], 16, 100, &sx1);\n<97> ret |= decode_value(s, s->sxy_model[1], 16, 100, &sy1);\n<99> ret |= decode_value(s, s->sxy_model[2], 16, 100, &sx2);\n<101> ret |= decode_value(s, s->sxy_model[3], 16, 100, &sy2);\n<123> ret  = decode_value(s, s->mv_model[0], 512, 100, &mvx);\n<125> ret |= decode_value(s, s->mv_model[1], 512, 100, &mvy);\n<167> ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype);\n<171> ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r);\n<183> ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g);\n<195> ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b);\n<211> ret = decode_value(s, s->run_model[ptype], 256, 400, &run);
<1> static void ccid_card_vscard_handle_message(PassthruState *card,\n<3> VSCMsgHeader *scr_msg_header)\n<7> uint8_t *data = (uint8_t *)&scr_msg_header[1];\n<11> switch (scr_msg_header->type) {\n<15> DPRINTF(card, D_INFO, "VSC_ATR %d\n", scr_msg_header->length);\n<17> if (scr_msg_header->length > MAX_ATR_SIZE) {\n<21> ccid_card_vscard_send_error(card, scr_msg_header->reader_id,\n<28> memcpy(card->atr, data, scr_msg_header->length);\n<30> card->atr_length = scr_msg_header->length;\n<34> ccid_card_vscard_send_error(card, scr_msg_header->reader_id,\n<48> DPRINTF(card, D_INFO, "VSC_CardRemove\n");\n<73> ccid_card_vscard_send_error(card, VSCARD_UNDEFINED_READER_ID,\n<79> ccid_card_vscard_send_error(card, VSCARD_MINIMAL_READER_ID,\n<97> printf("usb-ccid: chardev: unexpected message of type %X\n",\n<101> ccid_card_vscard_send_error(card, scr_msg_header->reader_id,
<1> static int ogg_probe ( AVProbeData * p ) {\n<2> if ( ! memcmp ( "OggS" , p -> buf , 5 ) && p -> buf [ 5 ] <= 0x7 ) return AVPROBE_SCORE_MAX ;\n<3> return 0 ;
<1> static bool message_decode_body ( struct message_decoder_context * ctx , struct message_block * input , struct message_block * output ) {\n<51> if ( ctx -> translation_size != 0 ) translation_buf_decode ( ctx , & data , & size ) ;\n<53> ( void ) charset_to_utf8 ( ctx -> charset_trans , data , & pos , ctx -> buf2 ) ;\n<54> if ( pos != size ) {\n<55> ctx -> translation_size = size - pos ;\n<56> i_assert ( ctx -> translation_size <= sizeof ( ctx -> translation_buf ) ) ;\n<57> memcpy ( ctx -> translation_buf , data + pos , ctx -> translation_size ) ;
<1> static int grid_fit ( gx_device_spot_analyzer * padev , gx_path * path , gs_font_type42 * pfont , const gs_log2_scale_point * pscale , gx_ttfExport * e , ttfOutliner * o ) {\n<40> if ( code < 0 ) return code ;\n<41> memset ( & gs_stub , 0 , sizeof ( gs_stub ) ) ;\n<53> code = dev_proc ( padev , fill_path ) ( ( gx_device * ) padev , & gs_stub , path , & params , & devc_stub , NULL ) ;
<1> print_insn (bfd_vma pc, disassemble_info *info)\n<69> for (p = info->disassembler_options; p != NULL; )\n<73> if (strncmp (p, "x86-64", 6) == 0)\n<83> else if (strncmp (p, "i386", 4) == 0)\n<93> else if (strncmp (p, "i8086", 5) == 0)\n<103> else if (strncmp (p, "intel", 5) == 0)\n<111> else if (strncmp (p, "att", 3) == 0)\n<119> else if (strncmp (p, "addr", 4) == 0)\n<127> if (p[4] == '3' && p[5] == '2')\n<131> else if (p[4] == '6' && p[5] == '4')\n<141> if (p[4] == '1' && p[5] == '6')\n<145> else if (p[4] == '3' && p[5] == '2')\n<153> else if (strncmp (p, "data", 4) == 0)\n<157> if (p[4] == '1' && p[5] == '6')\n<161> else if (p[4] == '3' && p[5] == '2')\n<167> else if (strncmp (p, "suffix", 6) == 0)\n<173> p = strchr (p, ',');\n<175> if (p != NULL)\n<257> obuf[0] = 0;\n<743> if ((prefixes & ~used_prefixes) != 0)\n<781> obufp = obuf + strlen (obuf);\n<783> for (i = strlen (obuf); i < 6; i++)\n<789> (*info->fprintf_func) (info->stream, "%s", obuf);
<1> void appendStringLiteral ( PQExpBuffer buf , const char * str , int encoding , bool std_strings ) {\n<2> size_t length = strlen ( str ) ;\n<3> const char * source = str ;\n<5> if ( ! enlargePQExpBuffer ( buf , 2 * length + 2 ) ) return ;
<1> static void s390_init(ram_addr_t my_ram_size,\n<7> const char *kernel_cmdline,\n<79> virtio_region_len = my_ram_size - ram_size;\n<83> virtio_region = cpu_physical_memory_map(virtio_region_start,\n<87> memset(virtio_region, 0, virtio_region_len);\n<89> cpu_physical_memory_unmap(virtio_region, virtio_region_len, 1,\n<153> if (lduw_be_phys(KERN_IMAGE_START) != 0x0dd0) {\n<155> fprintf(stderr, "Specified image is not an s390 boot image\n");\n<239> if (kernel_cmdline) {\n<241> cpu_physical_memory_write(KERN_PARM_AREA, kernel_cmdline,\n<243> strlen(kernel_cmdline) + 1);\n<251> for(i = 0; i < nb_nics; i++) {\n<253> NICInfo *nd = &nd_table[i];\n<259> if (!nd->model) {\n<261> nd->model = g_strdup("virtio");\n<267> if (strcmp(nd->model, "virtio")) {\n<269> fprintf(stderr, "S390 only supports VirtIO nics\n");\n<271> exit(1);\n<279> qdev_set_nic_properties(dev, nd);
<1> static kadm5_ret_t validate_allowed_keysalts ( const char * allowed_keysalts ) {\n<3> krb5_key_salt_tuple * ks_tuple = NULL ;\n<5> if ( strchr ( allowed_keysalts , '\t' ) != NULL ) return KADM5_BAD_KEYSALTS ;\n<6> ret = krb5_string_to_keysalts ( allowed_keysalts , "," , ":.-" , 0 , & ks_tuple , & n_ks_tuple ) ;\n<7> free ( ks_tuple ) ;\n<8> if ( ret == EINVAL ) return KADM5_BAD_KEYSALTS ;
<1> static char *qio_channel_websock_handshake_entry(const char *handshake,\n<17> begin = g_strstr_len(handshake, handshake_len, line);\n<19> if (begin != NULL) {\n<21> begin += strlen(line);\n<23> end = g_strstr_len(begin, handshake_len - (begin - handshake),\n<35> g_free(line);
<1> static int svq1_decode_block_intra(GetBitContext *bitbuf, uint8_t *pixels,\n<45> dst    = (uint32_t *)list[i];\n<47> width  = 1 << ((4 + level) / 2);\n<61> for (y = 0; y < height; y++)\n<63> memset(&dst[y * (pitch / 4)], 0, width);\n<87> mean = get_vlc2(bitbuf, svq1_intra_mean.table, 8, 3);\n<93> for (y = 0; y < height; y++)\n<95> memset(&dst[y * (pitch / 4)], mean, width);\n<119> dst += pitch / 4;
<1> static int open_self_cmdline(void *cpu_env, int fd)\n<47> if (!word_skipped) {\n<53> cp_buf = memchr(buf, 0, sizeof(buf));\n<59> cp_buf++;\n<61> nb_read -= cp_buf - buf;\n<73> if (write(fd, cp_buf, nb_read) != nb_read) {
<1> ff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb,\n<15> if (st->codec->codec_id == CODEC_ID_AAC)\n<21> av_new_packet(pkt, st->codec->block_align);\n<23> memcpy(pkt->data, ast->pkt.data + st->codec->block_align * //FIXME avoid this
<1> static DisplayType select_display(const char *p)\n<11> if (strstart(p, "sdl", &opts)) {\n<107> fprintf(stderr, "SDL support is disabled\n");\n<113> } else if (strstart(p, "vnc", &opts)) {\n<145> fprintf(stderr, "VNC support is disabled\n");\n<151> } else if (strstart(p, "curses", &opts)) {\n<159> fprintf(stderr, "Curses support is disabled\n");\n<165> } else if (strstart(p, "none", &opts)) {\n<173> fprintf(stderr, "Unknown display type: %s\n", p);
<1> static void test_bug4026 ( ) {\n<9> stmt = mysql_stmt_init ( mysql ) ;\n<10> stmt_text = "SELECT ?, ?" ;\n<11> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<12> check_execute ( stmt , rc ) ;\n<13> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<14> memset ( & time_in , 0 , sizeof ( time_in ) ) ;\n<15> memset ( & time_out , 0 , sizeof ( time_out ) ) ;\n<16> memset ( & datetime_in , 0 , sizeof ( datetime_in ) ) ;\n<17> memset ( & datetime_out , 0 , sizeof ( datetime_out ) ) ;\n<19> my_bind [ 0 ] . buffer = ( void * ) & time_in ;\n<21> my_bind [ 1 ] . buffer = ( void * ) & datetime_in ;\n<22> time_in . hour = 23 ;\n<23> time_in . minute = 59 ;\n<24> time_in . second = 59 ;\n<25> time_in . second_part = 123456 ;\n<26> time_in . time_type = MYSQL_TIMESTAMP_TIME ;\n<27> datetime_in = time_in ;\n<28> datetime_in . year = 2003 ;\n<29> datetime_in . month = 12 ;\n<30> datetime_in . day = 31 ;\n<31> datetime_in . time_type = MYSQL_TIMESTAMP_DATETIME ;\n<32> mysql_stmt_bind_param ( stmt , my_bind ) ;\n<35> my_bind [ 0 ] . buffer = ( void * ) & time_out ;\n<36> my_bind [ 1 ] . buffer = ( void * ) & datetime_out ;\n<40> if ( ! opt_silent ) {\n<41> printf ( "%d:%d:%d.%lu\n" , time_out . hour , time_out . minute , time_out . second , time_out . second_part ) ;\n<42> printf ( "%d-%d-%d %d:%d:%d.%lu\n" , datetime_out . year , datetime_out . month , datetime_out . day , datetime_out . hour , datetime_out . minute , datetime_out . second , datetime_out . second_part ) ;\n<44> DIE_UNLESS ( memcmp ( & time_in , & time_out , sizeof ( time_in ) ) == 0 ) ;\n<45> DIE_UNLESS ( memcmp ( & datetime_in , & datetime_out , sizeof ( datetime_in ) ) == 0 ) ;
<1> static void evtag_tag_encoding ( void ) {\n<9> i < TEST_MAX_INT ;\n<13> evtag_encode_tag ( tmp , integers [ i ] ) ;\n<15> fprintf ( stdout , "\t\tencoded 0x%08x with %d bytes\n" , integers [ i ] , newlen - oldlen ) ;\n<18> i < TEST_MAX_INT ;\n<19> i ++ ) {\n<20> if ( evtag_decode_tag ( & integer , tmp ) == - 1 ) {\n<21> fprintf ( stderr , "decode %d failed" , i ) ;\n<24> if ( integer != integers [ i ] ) {\n<25> fprintf ( stderr , "got %x, wanted %x" , integer , integers [ i ] ) ;\n<29> if ( EVBUFFER_LENGTH ( tmp ) != 0 ) {\n<30> fprintf ( stderr , "trailing data" ) ;\n<34> fprintf ( stdout , "\t%s: OK\n" , __func__ ) ;
<1> static void r2d_init(MachineState *machine)\n<9> const char *kernel_cmdline = machine->kernel_cmdline;\n<49> if (cpu == NULL) {\n<51> fprintf(stderr, "Unable to find CPU definition\n");\n<171> memset(&boot_params, 0, sizeof(boot_params));\n<187> if (kernel_size < 0) {\n<189> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);\n<227> if (initrd_size < 0) {\n<229> fprintf(stderr, "qemu: could not load initrd '%s'\n", initrd_filename);\n<249> if (kernel_cmdline) {\n<255> strncpy(boot_params.kernel_cmdline, kernel_cmdline,\n<263> rom_add_blob_fixed("boot_params", &boot_params, sizeof(boot_params),
<1> int su_main ( int argc , char * * argv , int mode ) {\n<49> while ( ( optc = getopt_long ( argc , argv , "c:fg:G:lmps:u:hV" , longopts , NULL ) ) != - 1 ) {\n<74> case 'V' : printf ( UTIL_LINUX_VERSION ) ;\n<80> if ( optind < argc && ! strcmp ( argv [ optind ] , "-" ) ) {
<1> static int vc1_decode_p_mb_intfr(VC1Context *v)\n<131> s->mb_intra = v->is_intra[s->mb_x] = 1;\n<181> vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n<235> s->mb_intra = v->is_intra[s->mb_x] = 0;\n<266> vc1_mc_4mv_luma(v, i, 0);\n<270> vc1_mc_4mv_chroma4(v);\n<306> vc1_mc_4mv_chroma4(v);\n<321> vc1_mc_1mv(v, 0);\n<353> pat = vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n<377> s->mb_intra = v->is_intra[s->mb_x] = 0;\n<401> vc1_mc_1mv(v, 0);\n<405> if (s->mb_x == s->mb_width - 1)\n<407> memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0])*s->mb_stride);
<1> static void usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n<37> if (!is_rndis(s)) {\n<53> if (s->out_ptr < 8 || s->out_ptr < len) {\n<71> s->out_ptr -= len;\n<73> memmove(s->out_buf, &s->out_buf[len], s->out_ptr);
<22> if ( a == NULL ) return NULL ;\n<29> snprintf ( a -> str , MAX_OID_LENGTH , "%d.%d" , ( d_ptr [ 0 ] / 40 ) , ( d_ptr [ 0 ] % 40 ) ) ;\n<32> i < oid_length ;\n<34> int s = strlen ( a -> str ) ;\n<46> snprintf ( a -> str + s , MAX_OID_LENGTH - s , ".%d" , oid_value ) ;\n<49> return a ;
<1> static bool check_grant_db_routine ( THD * thd , const char * db , HASH * hash ) {\n<2> Security_context * sctx = thd -> security_ctx ;\n<4> idx < hash -> records ;\n<5> ++ idx ) {\n<6> GRANT_NAME * item = ( GRANT_NAME * ) hash_element ( hash , idx ) ;\n<7> if ( strcmp ( item -> user , sctx -> priv_user ) == 0 && strcmp ( item -> db , db ) == 0 && compare_hostname ( & item -> host , sctx -> host , sctx -> ip ) ) {\n<8> return FALSE ;
<1> int phar_is_tar ( char * buf , char * fname ) {\n<2> tar_header * header = ( tar_header * ) buf ;\n<5> char save [ sizeof ( header -> checksum ) ] ;\n<6> if ( ! strncmp ( buf , "<?php" , sizeof ( "<?php" ) - 1 ) ) {\n<9> memcpy ( save , header -> checksum , sizeof ( header -> checksum ) ) ;\n<10> memset ( header -> checksum , ' ' , sizeof ( header -> checksum ) ) ;\n<12> memcpy ( header -> checksum , save , sizeof ( header -> checksum ) ) ;\n<13> if ( ! ret && strstr ( fname , ".tar" ) ) {\n<14> return 1 ;\n<16> return ret ;
<1> METHOD ( asn1_parser_t , destroy , void , private_asn1_parser_t * this ) {\n<2> free ( this ) ;
<1> static char * xmemmem ( const char * hay , const size_t haysize , const char * needle , const size_t needlesize ) {\n<10> if ( needlesize == 0UL ) {\n<13> else if ( ( hay = memchr ( hay , * needle , haysize ) ) == NULL ) {\n<14> return NULL ;\n<16> for ( hp = hay + 1U , np = needle + 1U , hsum = * hay , nsum = * hay , eqp = 1U ;\n<17> hp < eoh && np < eon ;\n<19> if ( np < eon ) {\n<20> return NULL ;\n<23> return deconst ( hay ) ;\n<25> for ( cand = hay ;\n<26> hp < eoh ;\n<27> hp ++ ) {\n<28> hsum ^= * cand ++ ;\n<30> if ( hsum == nsum && memcmp ( cand , needle , needlesize - 1U ) == 0 ) {\n<31> return deconst ( cand ) ;\n<34> return NULL ;
<1> static void sh_serial_ioport_write(void *opaque, uint32_t offs, uint32_t val)\n<85> if (s->feat & SH_SERIAL_FEAT_SCIF) {\n<87> switch(offs) {\n<215> fprintf(stderr, "sh_serial: unsupported write to 0x%02x\n", offs);
<1> static int vmdk_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<31> if (s->hd->backing_hd) {\n<45> memset(buf, 0, 512 * n);\n<61> buf += n * 512;
<1> static int kex_agree_hostkey ( LIBSSH2_SESSION * session , unsigned long kex_flags , unsigned char * hostkey , unsigned long hostkey_len ) {\n<6> while ( s && * s ) {\n<7> unsigned char * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n<8> size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n<25> while ( hostkeyp && ( * hostkeyp ) && ( * hostkeyp ) -> name ) {\n<26> s = kex_agree_instr ( hostkey , hostkey_len , ( unsigned char * ) ( * hostkeyp ) -> name , strlen ( ( * hostkeyp ) -> name ) ) ;\n<30> session -> hostkey = * hostkeyp ;
<1> static int get_riff(AVFormatContext *s, AVIOContext *pb)\n<15> avio_read(pb, header, 4);\n<25> for (i = 0; avi_headers[i][0]; i++)\n<27> if (!memcmp(header, avi_headers[i], 8))\n<37> if (header[7] == 0x19)
<1> static gpgme_error_t gpgsm_sign ( void * engine , gpgme_data_t in , gpgme_data_t out , gpgme_sig_mode_t mode , int use_armor , int use_textmode , int include_certs , gpgme_ctx_t ctx ) {\n<8> if ( include_certs != GPGME_INCLUDE_CERTS_DEFAULT ) {\n<9> if ( asprintf ( & assuan_cmd , "OPTION include-certs %i" , include_certs ) < 0 ) return gpg_error_from_syserror ( ) ;\n<10> err = gpgsm_assuan_simple_command ( gpgsm -> assuan_ctx , assuan_cmd , NULL , NULL ) ;\n<11> free ( assuan_cmd ) ;\n<12> if ( err ) return err ;\n<15> ( key = gpgme_signers_enum ( ctx , i ) ) ;\n<17> const char * s = key -> subkeys ? key -> subkeys -> fpr : NULL ;\n<18> if ( s && strlen ( s ) < 80 ) {\n<19> char buf [ 100 ] ;\n<20> strcpy ( stpcpy ( buf , "SIGNER " ) , s ) ;\n<21> err = gpgsm_assuan_simple_command ( gpgsm -> assuan_ctx , buf , gpgsm -> status . fnc , gpgsm -> status . fnc_value ) ;\n<23> else err = gpg_error ( GPG_ERR_INV_VALUE ) ;
<1> iscsi_aio_writev(BlockDriverState *bs, int64_t sector_num,\n<29> trace_iscsi_aio_writev(iscsi, sector_num, nb_sectors, opaque, acb);\n<77> acb->task = malloc(sizeof(struct scsi_task));\n<79> if (acb->task == NULL) {\n<91> memset(acb->task, 0, sizeof(struct scsi_task));\n<115> if (iscsi_scsi_command_async(iscsi, iscsilun->lun, acb->task,
<1> static int qemu_gluster_create(const char *filename,\n<25> if (!glfs) {\n<43> if (!tmp || !strcmp(tmp, "off")) {\n<45> prealloc = 0;\n<47> } else if (!strcmp(tmp, "full") &&\n<49> gluster_supports_zerofill()) {\n<51> prealloc = 1;\n<55> error_setg(errp, "Invalid preallocation mode: '%s'"\n<61> ret = -EINVAL;\n<69> fd = glfs_creat(glfs, gconf->image,\n<71> O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, S_IRUSR | S_IWUSR);\n<73> if (!fd) {\n<107> g_free(tmp);
<1> int ff_rv34_decode_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) {\n<2> RV34DecContext * r = dst -> priv_data , * r1 = src -> priv_data ;\n<10> if ( ( err = rv34_decoder_realloc ( r ) ) < 0 ) return err ;\n<12> if ( ( err = ff_mpeg_update_thread_context ( dst , src ) ) ) return err ;\n<16> memset ( & r -> si , 0 , sizeof ( r -> si ) ) ;
<1> static void acl_update_db ( const char * user , const char * host , const char * db , ulong privileges ) {\n<7> if ( ( ! acl_db -> user && ! user [ 0 ] ) || ( acl_db -> user && ! strcmp ( user , acl_db -> user ) ) ) {\n<8> if ( ( ! acl_db -> host . hostname && ! host [ 0 ] ) || ( acl_db -> host . hostname && ! strcmp ( host , acl_db -> host . hostname ) ) ) {\n<9> if ( ( ! acl_db -> db && ! db [ 0 ] ) || ( acl_db -> db && ! strcmp ( db , acl_db -> db ) ) ) {
<1> static int com_prompt ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n<2> char * ptr = strchr ( line , ' ' ) ;\n<5> current_prompt = my_strdup ( ptr ? ptr + 1 : default_prompt , MYF ( MY_WME ) ) ;
<1> static struct sk_buff * tipc_get_err_tlv ( char * str ) {\n<2> int str_len = strlen ( str ) + 1 ;\n<4> buf = tipc_tlv_alloc ( TLV_SPACE ( str_len ) ) ;\n<5> if ( buf ) tipc_add_tlv ( buf , TIPC_TLV_ERROR_STRING , str , str_len ) ;
<1> static void notify_guest_bh(void *opaque)\n<5> VirtIOBlockDataPlane *s = opaque;\n<15> memcpy(bitmap, s->batch_notify_vqs, sizeof(bitmap));\n<17> memset(s->batch_notify_vqs, 0, sizeof(bitmap));
<1> static void sdl_audio_callback(void *opaque, Uint8 *stream, int len)\n<5> VideoState *is = opaque;\n<19> audio_size = audio_decode_frame(is);\n<33> update_sample_display(is, (int16_t *)is->audio_buf, audio_size);\n<43> len1 = is->audio_buf_size - is->audio_buf_index;\n<45> if (len1 > len)\n<47> len1 = len;\n<49> if (!is->muted && !silence && is->audio_volume == SDL_MIX_MAXVOLUME)\n<51> memcpy(stream, (uint8_t *)is->audio_buf + is->audio_buf_index, len1);\n<55> memset(stream, 0, len1);\n<59> SDL_MixAudio(stream, (uint8_t *)is->audio_buf + is->audio_buf_index, len1, is->audio_volume);\n<63> len -= len1;\n<65> stream += len1;\n<67> is->audio_buf_index += len1;
<1> dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,\n<15> const char *device_name = ctx->device_name[devtype];\n<73> buf = dup_wchar_to_utf8(var.bstrVal);\n<77> if (pfilter) {\n<79> if (strcmp(device_name, buf))\n<85> IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter);\n<99> av_free(buf);
<1> static int write_null ( struct archive_write * a , size_t size ) {\n<6> p = wb_buffptr ( a ) ;\n<7> if ( size <= remaining ) {\n<8> memset ( p , 0 , size ) ;\n<9> return ( wb_consume ( a , size ) ) ;\n<11> memset ( p , 0 , remaining ) ;\n<12> r = wb_consume ( a , remaining ) ;\n<13> if ( r != ARCHIVE_OK ) return ( r ) ;\n<15> old = p ;\n<17> memset ( p , 0 , old - p ) ;
<1> static int read_kuki_chunk(AVFormatContext *s, int64_t size)\n<69> avio_read(pb, preamble, ALAC_PREAMBLE);\n<75> if (!st->codec->extradata)\n<89> if (!memcmp(&preamble[4], "frmaalac", 8)) {\n<91> if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n<107> AV_WB32(st->codec->extradata, 36);\n<109> memcpy(&st->codec->extradata[4], "alac", 4);\n<111> AV_WB32(&st->codec->extradata[8], 0);\n<113> memcpy(&st->codec->extradata[12], preamble, 12);\n<115> avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n<117> avio_skip(pb, size - ALAC_NEW_KUKI);\n<121> st->codec->extradata_size = ALAC_HEADER;\n<139> return 0;
<1> static void rc4030_dma_tt_write(void *opaque, hwaddr addr, uint64_t data,\n<3> unsigned int size)\n<13> memcpy(memory_region_get_ram_ptr(&s->dma_tt) + addr, &data, size);\n<25> rc4030_dma_as_update_one(s, index, (uint32_t)data);
<1> struct timeval * dtls1_get_timeout ( SSL * s , struct timeval * timeleft ) {\n<3> if ( s -> d1 -> next_timeout . tv_sec == 0 && s -> d1 -> next_timeout . tv_usec == 0 ) {\n<7> if ( s -> d1 -> next_timeout . tv_sec < timenow . tv_sec || ( s -> d1 -> next_timeout . tv_sec == timenow . tv_sec && s -> d1 -> next_timeout . tv_usec <= timenow . tv_usec ) ) {\n<8> memset ( timeleft , 0 , sizeof ( * timeleft ) ) ;\n<9> return timeleft ;\n<11> memcpy ( timeleft , & ( s -> d1 -> next_timeout ) , sizeof ( struct timeval ) ) ;\n<12> timeleft -> tv_sec -= timenow . tv_sec ;\n<13> timeleft -> tv_usec -= timenow . tv_usec ;\n<14> if ( timeleft -> tv_usec < 0 ) {\n<15> timeleft -> tv_sec -- ;\n<16> timeleft -> tv_usec += 1000000 ;\n<18> if ( timeleft -> tv_sec == 0 && timeleft -> tv_usec < 15000 ) {\n<19> memset ( timeleft , 0 , sizeof ( * timeleft ) ) ;\n<21> return timeleft ;
<1> static int yuv4_read_packet(AVFormatContext *s, AVPacket *pkt)\n<7> char header[MAX_FRAME_HEADER+1];\n<19> if (header[i] == '\n') {\n<21> header[i + 1] = 0;\n<37> else if (i == MAX_FRAME_HEADER)\n<43> if (strncmp(header, Y4M_FRAME_MAGIC, strlen(Y4M_FRAME_MAGIC)))\n<45> return AVERROR_INVALIDDATA;\n<49> ret = av_get_packet(s->pb, pkt, s->packet_size - Y4M_FRAME_MAGIC_LEN);\n<51> if (ret < 0)
<1> static void test_ps_conj_select ( ) {\n<20> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<27> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<30> strmov ( str_data , "hh" ) ;\n<31> str_length = strlen ( str_data ) ;
<1> static void test_mem_overun ( ) {\n<2> char buffer [ 10000 ] , field [ 10 ] ;\n<9> strxmov ( buffer , "create table t_mem_overun(" , NullS ) ;\n<11> i < 1000 ;\n<12> i ++ ) {\n<13> sprintf ( field , "c%d int" , i ) ;\n<14> strxmov ( buffer , buffer , field , ", " , NullS ) ;\n<16> length = strlen ( buffer ) ;\n<17> buffer [ length - 2 ] = ')' ;\n<18> buffer [ -- length ] = '\0' ;\n<19> rc = mysql_real_query ( mysql , buffer , length ) ;\n<21> strxmov ( buffer , "insert into t_mem_overun values(" , NullS ) ;\n<25> strxmov ( buffer , buffer , "1, " , NullS ) ;\n<27> length = strlen ( buffer ) ;\n<28> buffer [ length - 2 ] = ')' ;\n<30> rc = mysql_real_query ( mysql , buffer , length ) ;\n<42> if ( ! opt_silent ) fprintf ( stdout , "\n total fields : %d" , mysql_num_fields ( field_res ) ) ;
<1> static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,\n<4> PNGEncContext *s = avctx->priv_data;\n<40> ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);\n<41> if (ret < 0)\n<43> memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);\n<44> pkt->size = s->last_frame_packet_size;\n<49> s->bytestream       = s->last_frame_packet;\n<65> uint8_t* last_fctl_chunk_start = pkt->data;\n<85> if (!s->prev_frame) {\n<92> if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)\n<96> memcpy(s->prev_frame->data[0], s->last_frame->data[0],\n<97> s->last_frame->linesize[0] * s->last_frame->height);\n<101> for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {\n<102> size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;\n<103> memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);
<48> if (ret < 0)\n<64> memset(frame->extended_data[i], 0, frame->linesize[0]);
<1> static int img_info(int argc, char **argv)\n<21> output = NULL;\n<49> if (c == -1) {\n<73> output = optarg;\n<119> if (output && !strcmp(output, "json")) {\n<121> output_format = OFORMAT_JSON;\n<123> } else if (output && !strcmp(output, "human")) {\n<125> output_format = OFORMAT_HUMAN;\n<127> } else if (output) {\n<137> if (qemu_opts_foreach(&qemu_object_opts,
<1> static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) {\n<3> int j = * idx ;\n<7> memcpy ( & _t32 , packet + j , 4 ) ;\n<9> x = ntohl ( _t32 ) ;
<1> AVFilterBufferRef *avfilter_ref_buffer(AVFilterBufferRef *ref, int pmask)\n<4> if (!ret)\n<22> if (ref->extended_data && ref->extended_data != ref->data) {\n<24> if (!(ret->extended_data = av_malloc(sizeof(*ret->extended_data) *\n<31> sizeof(*ret->extended_data) * nb_channels);\n<37> return ret;
<1> static void file_completion(const char *input)\n<9> char path[1024];\n<11> char file[1024], file_prefix[1024];\n<21> if (!p) {\n<23> input_path_len = 0;\n<25> pstrcpy(file_prefix, sizeof(file_prefix), input);\n<31> input_path_len = p - input + 1;\n<33> memcpy(path, input, input_path_len);\n<35> if (input_path_len > sizeof(path) - 1)\n<37> input_path_len = sizeof(path) - 1;\n<65> if (!d)\n<71> if (strcmp(d->d_name, ".") == 0 || strcmp(d->d_name, "..") == 0) {\n<79> if (strstart(d->d_name, file_prefix, NULL)) {\n<81> memcpy(file, input, input_path_len);\n<83> if (input_path_len < sizeof(file))\n<85> pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n<101> readline_add_completion(cur_mon->rs, file);
<1> static int decode_i_frame(FourXContext *f, const uint8_t *buf, int length){\n<37> prestream= read_huffman_tables(f, prestream);\n<49> av_fast_malloc(&f->bitstream_buffer, &f->bitstream_buffer_size, prestream_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<51> if (!f->bitstream_buffer)\n<55> f->dsp.bswap_buf(f->bitstream_buffer, (const uint32_t*)prestream, prestream_size/4);\n<57> memset((uint8_t*)f->bitstream_buffer + prestream_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);
<1> void var_query_set ( VAR * var , const char * query , const char * * query_end ) {\n<2> char * end = ( char * ) ( ( query_end && * query_end ) ? * query_end : query + strlen ( query ) ) ;\n<9> if ( ! mysql ) {\n<11> memset ( & command , 0 , sizeof ( command ) ) ;\n<12> command . query = ( char * ) query ;\n<13> command . first_word_len = ( * query_end - query ) ;\n<17> handle_no_active_connection ( & command , cur_con , & ds_res ) ;\n<20> while ( end > query && * end != '`' ) {\n<54> if ( ! multi_reg_replace ( glob_replace_regex , ( char * ) val ) ) {\n<55> val = glob_replace_regex -> buf ;\n<56> len = strlen ( val ) ;\n<59> if ( glob_replace ) replace_strings_append ( glob_replace , & result , val , len ) ;\n<60> else dynstr_append_mem ( & result , val , len ) ;
<1> int ff_img_read_header(AVFormatContext *s1)\n<291> probe_buffer_size = avio_read(s1->pb, probe_buffer, probe_buffer_size);\n<293> if (probe_buffer_size < 0) {\n<301> memset(probe_buffer + probe_buffer_size, 0, AVPROBE_PADDING_SIZE);
<1> static int qemuMonitorTextCommandWithHandler ( qemuMonitorPtr mon , const char * cmd , qemuMonitorPasswordHandler passwordHandler , void * passwordOpaque , int scm_fd , char * * reply ) {\n<5> memset ( & msg , 0 , sizeof msg ) ;\n<6> if ( virAsprintf ( & msg . txBuffer , "%s\r" , cmd ) < 0 ) {\n<10> msg . txLength = strlen ( msg . txBuffer ) ;\n<11> msg . txFD = scm_fd ;\n<12> msg . passwordHandler = passwordHandler ;\n<13> msg . passwordOpaque = passwordOpaque ;\n<15> ret = qemuMonitorSend ( mon , & msg ) ;\n<16> VIR_DEBUG ( "Receive command reply ret=%d rxLength=%d rxBuffer='%s'" , ret , msg . rxLength , msg . rxBuffer ) ;\n<17> memset ( msg . txBuffer , 0 , msg . txLength ) ;\n<18> VIR_FREE ( msg . txBuffer ) ;\n<20> if ( msg . rxBuffer ) {\n<21> * reply = msg . rxBuffer ;\n<24> * reply = strdup ( "" ) ;\n<25> if ( ! * reply ) {
<1> struct evhttp_connection * evhttp_connection_new ( const char * address , unsigned short port ) {\n<3> event_debug ( ( "Attempting connection to %s:%d\n" , address , port ) ) ;\n<4> if ( ( evcon = calloc ( 1 , sizeof ( struct evhttp_connection ) ) ) == NULL ) {\n<5> event_warn ( "%s: calloc failed" , __func__ ) ;\n<8> evcon -> fd = - 1 ;\n<9> evcon -> port = port ;\n<10> evcon -> timeout = - 1 ;\n<11> evcon -> retry_cnt = evcon -> retry_max = 0 ;\n<12> if ( ( evcon -> address = strdup ( address ) ) == NULL ) {\n<13> event_warn ( "%s: strdup failed" , __func__ ) ;\n<16> if ( ( evcon -> input_buffer = evbuffer_new ( ) ) == NULL ) {\n<25> TAILQ_INIT ( & evcon -> requests ) ;\n<26> return ( evcon ) ;\n<27> error : if ( evcon != NULL ) evhttp_connection_free ( evcon ) ;\n<28> return ( NULL ) ;
<7> AVCodec *codec = avctx->codec;\n<9> AVCodecContext *src = avctx;\n<61> p->avctx  = copy;\n<65> if (!copy) {\n<85> src = copy;\n<91> err = codec->init(copy);\n<95> update_context_from_thread(avctx, copy, 1);\n<99> copy->priv_data = av_malloc(codec->priv_data_size);\n<101> if (!copy->priv_data) {\n<109> memcpy(copy->priv_data, src->priv_data, codec->priv_data_size);\n<129> err = codec->init_thread_copy(copy);
<1> static int cpu_x86_find_by_name(x86_def_t *x86_cpu_def, const char *cpu_model)\n<11> char *s = g_strdup(cpu_model);\n<13> char *featurestr, *name = strtok(s, ",");\n<35> for (def = x86_defs; def; def = def->next)\n<37> if (!strcmp(name, def->name))\n<41> if (kvm_enabled() && strcmp(name, "host") == 0) {\n<43> cpu_x86_fill_host(x86_cpu_def);\n<45> } else if (!def) {\n<51> memcpy(x86_cpu_def, def, sizeof(*def));\n<57> plus_kvm_features = ~0; /* not supported bits will be filtered out later */\n<61> add_flagname_to_bitmaps("hypervisor", &plus_features,\n<63> &plus_ext_features, &plus_ext2_features, &plus_ext3_features,\n<65> &plus_kvm_features, &plus_svm_features);\n<69> featurestr = strtok(NULL, ",");\n<73> while (featurestr) {\n<77> if (featurestr[0] == '+') {\n<79> add_flagname_to_bitmaps(featurestr + 1, &plus_features,\n<87> } else if (featurestr[0] == '-') {\n<89> add_flagname_to_bitmaps(featurestr + 1, &minus_features,\n<97> } else if ((val = strchr(featurestr, '='))) {\n<99> *val = 0; val++;\n<101> if (!strcmp(featurestr, "family")) {\n<105> numvalue = strtoul(val, &err, 0);\n<107> if (!*val || *err) {\n<109> fprintf(stderr, "bad numerical value %s\n", val);\n<117> } else if (!strcmp(featurestr, "model")) {\n<121> numvalue = strtoul(val, &err, 0);\n<123> if (!*val || *err || numvalue > 0xff) {\n<125> fprintf(stderr, "bad numerical value %s\n", val);\n<133> } else if (!strcmp(featurestr, "stepping")) {\n<137> numvalue = strtoul(val, &err, 0);\n<139> if (!*val || *err || numvalue > 0xf) {\n<141> fprintf(stderr, "bad numerical value %s\n", val);\n<149> } else if (!strcmp(featurestr, "level")) {\n<153> numvalue = strtoul(val, &err, 0);\n<155> if (!*val || *err) {\n<157> fprintf(stderr, "bad numerical value %s\n", val);\n<165> } else if (!strcmp(featurestr, "xlevel")) {\n<169> numvalue = strtoul(val, &err, 0);\n<171> if (!*val || *err) {\n<173> fprintf(stderr, "bad numerical value %s\n", val);\n<187> } else if (!strcmp(featurestr, "vendor")) {\n<189> if (strlen(val) != 12) {\n<191> fprintf(stderr, "vendor string must be 12 chars long\n");\n<197> x86_cpu_def->vendor1 = 0;\n<199> x86_cpu_def->vendor2 = 0;\n<201> x86_cpu_def->vendor3 = 0;\n<203> for(i = 0; i < 4; i++) {\n<205> x86_cpu_def->vendor1 |= ((uint8_t)val[i    ]) << (8 * i);\n<207> x86_cpu_def->vendor2 |= ((uint8_t)val[i + 4]) << (8 * i);\n<209> x86_cpu_def->vendor3 |= ((uint8_t)val[i + 8]) << (8 * i);\n<213> x86_cpu_def->vendor_override = 1;\n<215> } else if (!strcmp(featurestr, "model_id")) {\n<217> pstrcpy(x86_cpu_def->model_id, sizeof(x86_cpu_def->model_id),\n<221> } else if (!strcmp(featurestr, "tsc_freq")) {\n<229> tsc_freq = strtosz_suffix_unit(val, &err,\n<233> if (!*val || *err) {\n<235> fprintf(stderr, "bad numerical value %s\n", val);\n<245> fprintf(stderr, "unrecognized feature %s\n", featurestr);\n<251> } else if (!strcmp(featurestr, "check")) {\n<253> check_cpuid = 1;\n<255> } else if (!strcmp(featurestr, "enforce")) {\n<257> check_cpuid = enforce_cpuid = 1;\n<261> fprintf(stderr, "feature string `%s' not in format (+feature|-feature|feature=xyz)\n", featurestr);\n<267> featurestr = strtok(NULL, ",");\n<271> x86_cpu_def->features |= plus_features;\n<273> x86_cpu_def->ext_features |= plus_ext_features;\n<275> x86_cpu_def->ext2_features |= plus_ext2_features;\n<277> x86_cpu_def->ext3_features |= plus_ext3_features;\n<279> x86_cpu_def->kvm_features |= plus_kvm_features;\n<281> x86_cpu_def->svm_features |= plus_svm_features;\n<283> x86_cpu_def->features &= ~minus_features;\n<285> x86_cpu_def->ext_features &= ~minus_ext_features;\n<287> x86_cpu_def->ext2_features &= ~minus_ext2_features;\n<289> x86_cpu_def->ext3_features &= ~minus_ext3_features;\n<291> x86_cpu_def->kvm_features &= ~minus_kvm_features;\n<293> x86_cpu_def->svm_features &= ~minus_svm_features;\n<297> if (check_features_against_host(x86_cpu_def) && enforce_cpuid)\n<303> g_free(s);\n<311> g_free(s);\n<313> return -1;
<1> static void forward_query ( int bind_fd , struct query * q ) {\n<7> len = dns_encode ( buf , sizeof ( buf ) , q , QR_QUERY , q -> name , strlen ( q -> name ) ) ;\n<8> if ( len < 1 ) {\n<12> memcpy ( & ( fwq . addr ) , & ( q -> from ) , q -> fromlen ) ;\n<13> fwq . addrlen = q -> fromlen ;\n<16> newaddr = inet_addr ( "127.0.0.1" ) ;\n<17> myaddr = ( struct sockaddr_in * ) & ( q -> from ) ;\n<18> memcpy ( & ( myaddr -> sin_addr ) , & newaddr , sizeof ( in_addr_t ) ) ;\n<20> if ( debug >= 2 ) {\n<21> fprintf ( stderr , "TX: NS reply \n" ) ;\n<23> if ( sendto ( bind_fd , buf , len , 0 , ( struct sockaddr * ) & q -> from , q -> fromlen ) <= 0 ) {
<1> static void eval_ir ( const float * Az , int pitch_lag , float * freq , float pitch_sharp_factor ) {\n<2> float tmp1 [ SUBFR_SIZE + 1 ] , tmp2 [ LP_FILTER_ORDER + 1 ] ;\n<4> tmp1 [ 0 ] = 1. ;\n<8> tmp1 [ i + 1 ] = Az [ i ] * ff_pow_0_55 [ i ] ;\n<11> memset ( tmp1 + 11 , 0 , 37 * sizeof ( float ) ) ;
<1> static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n<5> const uint8_t *buf,\n<9> hwaddr l, MemoryRegion *mr)\n<25> if (!memory_access_is_direct(mr, true)) {\n<95> ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n<97> memcpy(ptr, buf, l);\n<99> invalidate_and_set_dirty(mr, addr1, l);\n<117> buf += l;\n<131> l = len;\n<133> mr = address_space_translate(as, addr, &addr1, &l, true);
<1> static void search_state_decref ( struct search_state * const state ) {\n<2> if ( ! state ) return ;\n<4> if ( ! state -> refcount ) {\n<6> for ( dom = state -> head ;\n<7> dom ;\n<8> dom = next ) {\n<10> free ( dom ) ;\n<12> free ( state ) ;
<1> static void mp_decode_line(MotionPixelsContext *mp, GetBitContext *gb, int y)\n<15> if (mp->changes_map[y0 + x] == 0) {\n<17> memset(mp->gradient_scale, 1, sizeof(mp->gradient_scale));\n<27> if (w != 0) {\n<39> mp->hpt[((y / 4) * mp->avctx->width + i) / 4] = mp_get_yuv_from_rgb(mp, i, y);\n<49> memset(mp->gradient_scale, 1, sizeof(mp->gradient_scale));\n<51> p = mp_get_yuv_from_rgb(mp, x - 1, y);\n<55> p.y += mp_gradient(mp, 0, mp_get_vlc(mp, gb));\n<62> p.v += mp_gradient(mp, 1, mp_get_vlc(mp, gb));\n<65> p.u += mp_gradient(mp, 2, mp_get_vlc(mp, gb));\n<80> mp_set_rgb_from_yuv(mp, x, y, &p);
<1> static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n<2> FlicDecodeContext * s = avctx -> priv_data ;\n<33> pixels = s -> frame . data [ 0 ] ;\n<40> while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n<43> switch ( chunk_type ) {\n<64> if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ;\n<65> s -> palette [ palette_ptr ++ ] = entry ;\n<84> pixels [ pixel_ptr ] = line_packets & 0xff ;\n<107> pixels [ pixel_ptr ++ ] = palette_idx2 ;\n<115> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<145> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<155> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<164> case FLI_BLACK : memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n<185> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<196> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<213> bytestream2_get_buffer ( & g2 , & pixels [ y_ptr ] , s -> avctx -> width ) ;\n<226> memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;
<1> static inline int copy_block ( AVCodecContext * avctx , uint8_t * to , uint8_t * from , int offset , int height , int stride ) {\n<3> int width = height ;\n<7> if ( ! from ) {\n<14> if ( overflow > 0 ) {\n<15> width -= overflow ;\n<17> i < height ;\n<19> memcpy ( & to [ i * stride + width ] , & from [ ( from_y + i ) * stride ] , overflow ) ;\n<23> i < height ;\n<25> memcpy ( & to [ i * stride ] , & from [ ( from_y + i ) * stride + from_x ] , width ) ;
<1> int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n<5> char buf[128];\n<53> if (check_params(params, str) < 0) {\n<55> fprintf(stderr, "qemu: unknown parameter '%s' in '%s'\n",\n<107> if (get_param_value(buf, sizeof(buf), "bus", str)) {\n<111> if (bus_id < 0) {\n<113> fprintf(stderr, "qemu: '%s' invalid bus id\n", str);\n<123> if (get_param_value(buf, sizeof(buf), "unit", str)) {\n<127> if (unit_id < 0) {\n<129> fprintf(stderr, "qemu: '%s' invalid unit id\n", str);\n<139> if (get_param_value(buf, sizeof(buf), "if", str)) {\n<141> pstrcpy(devname, sizeof(devname), buf);\n<143> if (!strcmp(buf, "ide")) {\n<145> type = IF_IDE;\n<147> max_devs = MAX_IDE_DEVS;\n<149> } else if (!strcmp(buf, "scsi")) {\n<151> type = IF_SCSI;\n<153> max_devs = MAX_SCSI_DEVS;\n<155> } else if (!strcmp(buf, "floppy")) {\n<157> type = IF_FLOPPY;\n<159> max_devs = 0;\n<161> } else if (!strcmp(buf, "pflash")) {\n<163> type = IF_PFLASH;\n<165> max_devs = 0;\n<167> } else if (!strcmp(buf, "mtd")) {\n<169> type = IF_MTD;\n<171> max_devs = 0;\n<173> } else if (!strcmp(buf, "sd")) {\n<175> type = IF_SD;\n<177> max_devs = 0;\n<179> } else if (!strcmp(buf, "virtio")) {\n<181> type = IF_VIRTIO;\n<183> max_devs = 0;\n<185> } else if (!strcmp(buf, "xen")) {\n<187> type = IF_XEN;\n<189> max_devs = 0;\n<193> fprintf(stderr, "qemu: '%s' unsupported bus type '%s'\n", str, buf);\n<195> return -1;\n<203> if (get_param_value(buf, sizeof(buf), "index", str)) {\n<207> if (index < 0) {\n<209> fprintf(stderr, "qemu: '%s' invalid index\n", str);\n<235> if (get_param_value(buf, sizeof(buf), "secs", str)) {\n<245> if (cyls < 1 || cyls > 16383) {\n<247> fprintf(stderr, "qemu: '%s' invalid physical cyls number\n", str);\n<253> if (heads < 1 || heads > 16) {\n<255> fprintf(stderr, "qemu: '%s' invalid physical heads number\n", str);\n<261> if (secs < 1 || secs > 63) {\n<263> fprintf(stderr, "qemu: '%s' invalid physical secs number\n", str);\n<273> if (get_param_value(buf, sizeof(buf), "trans", str)) {\n<275> if (!cyls) {\n<287> if (!strcmp(buf, "none"))\n<289> translation = BIOS_ATA_TRANSLATION_NONE;\n<291> else if (!strcmp(buf, "lba"))\n<293> translation = BIOS_ATA_TRANSLATION_LBA;\n<295> else if (!strcmp(buf, "auto"))\n<297> translation = BIOS_ATA_TRANSLATION_AUTO;\n<301> fprintf(stderr, "qemu: '%s' invalid translation type\n", str);\n<303> return -1;\n<311> if (get_param_value(buf, sizeof(buf), "media", str)) {\n<313> if (!strcmp(buf, "disk")) {\n<315> media = MEDIA_DISK;\n<317> } else if (!strcmp(buf, "cdrom")) {\n<319> if (cyls || secs || heads) {\n<333> fprintf(stderr, "qemu: '%s' invalid media\n", str);\n<335> return -1;\n<343> if (get_param_value(buf, sizeof(buf), "snapshot", str)) {\n<345> if (!strcmp(buf, "on"))\n<347> snapshot = 1;\n<349> else if (!strcmp(buf, "off"))\n<351> snapshot = 0;\n<355> fprintf(stderr, "qemu: '%s' invalid snapshot option\n", str);\n<357> return -1;\n<365> if (get_param_value(buf, sizeof(buf), "cache", str)) {\n<367> if (!strcmp(buf, "off") || !strcmp(buf, "none"))\n<369> cache = 0;\n<371> else if (!strcmp(buf, "writethrough"))\n<373> cache = 1;\n<375> else if (!strcmp(buf, "writeback"))\n<377> cache = 2;\n<381> fprintf(stderr, "qemu: invalid cache option\n");\n<383> return -1;\n<391> if (get_param_value(buf, sizeof(buf), "format", str)) {\n<393> if (strcmp(buf, "?") == 0) {\n<395> fprintf(stderr, "qemu: Supported formats:");\n<397> bdrv_iterate_format(bdrv_format_print, NULL);\n<399> fprintf(stderr, "\n");\n<401> return -1;\n<405> drv = bdrv_find_format(buf);\n<407> if (!drv) {\n<409> fprintf(stderr, "qemu: '%s' invalid format\n", buf);\n<429> if (!get_param_value(serial, sizeof(serial), "serial", str))\n<431> memset(serial, 0,  sizeof(serial));\n<437> if (get_param_value(buf, sizeof(serial), "werror", str)) {\n<439> if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n<441> fprintf(stderr, "werror is no supported by this format\n");\n<447> if (!strcmp(buf, "ignore"))\n<449> onerror = BLOCK_ERR_IGNORE;\n<451> else if (!strcmp(buf, "enospc"))\n<453> onerror = BLOCK_ERR_STOP_ENOSPC;\n<455> else if (!strcmp(buf, "stop"))\n<457> onerror = BLOCK_ERR_STOP_ANY;\n<459> else if (!strcmp(buf, "report"))\n<461> onerror = BLOCK_ERR_REPORT;\n<465> fprintf(stderr, "qemu: '%s' invalid write error action\n", buf);\n<467> return -1;\n<479> if (index != -1) {\n<481> if (bus_id != 0 || unit_id != -1) {\n<519> if (unit_id == -1) {\n<523> while (drive_get_index(type, bus_id, unit_id) != -1) {\n<545> if (max_devs && unit_id >= max_devs) {\n<547> fprintf(stderr, "qemu: '%s' unit %d too big (max is %d)\n",\n<549> str, unit_id, max_devs - 1);\n<565> if (drive_get_index(type, bus_id, unit_id) != -1)\n<607> strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial));\n<671> if (!file[0])\n<697> if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n<699> fprintf(stderr, "qemu: could not open disk image %s\n",
<1> static int mxf_read_local_tags(MXFContext *mxf, KLVPacket *klv, MXFMetadataReadFunc *read_child, int ctx_size, enum MXFMetadataSetType type)\n<29> UID uid = {0};\n<51> if (local_tag == tag) {\n<53> memcpy(uid, mxf->local_tags+i*18+2, 16);\n<57> PRINT_KEY(mxf->fc, "uid", uid);
<1> static void switch_sql_mode ( FILE * sql_file , const char * delimiter , const char * sql_mode ) {\n<2> fprintf ( sql_file , "/*!50003 SET @saved_sql_mode = @@sql_mode */ %s\n" "/*!50003 SET sql_mode = '%s' */ %s\n" , ( const char * ) delimiter , ( const char * ) sql_mode , ( const char * ) delimiter ) ;
<1> static int storesid ( struct alltabs * at , const char * str ) {\n<6> if ( str != NULL ) {\n<8> cffnames [ i ] != NULL ;\n<9> ++ i ) {\n<10> if ( strcmp ( cffnames [ i ] , str ) == 0 ) return ( i ) ;\n<26> if ( str != NULL ) {
<1> int sort_ft_buf_flush ( MI_SORT_PARAM * sort_param ) {\n<9> val_len = share -> ft2_keyinfo . keylength ;\n<11> to = ft_buf -> lastkey + val_off ;\n<14> for ( from = to + val_len ;\n<15> ! error && from < ft_buf -> buf ;\n<16> from += val_len ) {\n<17> memcpy ( to , from , val_len ) ;
<1> static void test_bug1115 ( ) {\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<28> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> TEST ( BuildTime , DateLooksValid ) {\n<2> char build_date [ ] = BUILD_DATE ;\n<3> EXPECT_EQ ( 11u , strlen ( build_date ) ) ;\n<4> EXPECT_EQ ( ' ' , build_date [ 3 ] ) ;\n<5> EXPECT_EQ ( ' ' , build_date [ 6 ] ) ;
<1> void pxa27x_register_keypad(struct pxa2xx_keypad_s *kp, struct keymap *map,\n<11> if(!map || size < 0x80) {\n<13> fprintf(stderr, "%s - No PXA keypad map defined\n", __FUNCTION__);
<1> void sh4_translate_init(void)\n<53> memcpy(cpu_gregs + 24, cpu_gregs + 8, 8 * sizeof(TCGv));
<1> int dtls1_retransmit_message ( SSL * s , unsigned short seq , int * found ) {\n<8> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<11> item = pqueue_find ( s -> d1 -> sent_messages , seq64be ) ;\n<12> if ( item == NULL ) {\n<18> frag = ( hm_fragment * ) item -> data ;\n<19> if ( frag -> msg_header . is_ccs ) header_length = DTLS1_CCS_HEADER_LENGTH ;\n<20> else header_length = DTLS1_HM_HEADER_LENGTH ;\n<21> memcpy ( s -> init_buf -> data , frag -> fragment , frag -> msg_header . msg_len + header_length ) ;
<1> static int blk_connect(struct XenDevice *xendev)\n<25> if (strcmp(blkdev->mode, "w") == 0) {\n<27> qflags |= BDRV_O_RDWR;\n<29> readonly = false;\n<121> bdrv_attach_dev_nofail(blkdev->bs, blkdev);\n<125> if (blkdev->file_size < 0) {\n<127> xen_be_printf(&blkdev->xendev, 1, "bdrv_getlength: %d (%s) | drv %s\n",\n<129> (int)blkdev->file_size, strerror(-blkdev->file_size),\n<187> if (blkdev->xendev.protocol) {\n<189> if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_32) == 0) {\n<191> blkdev->protocol = BLKIF_PROTOCOL_X86_32;\n<195> if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_64) == 0) {\n<197> blkdev->protocol = BLKIF_PROTOCOL_X86_64;\n<287> xen_be_bind_evtchn(&blkdev->xendev);\n<291> xen_be_printf(&blkdev->xendev, 1, "ok: proto %s, ring-ref %d, "
<1> void TSMimeFieldValueSet ( TSMBuffer bufp , TSMLoc field_obj , int idx , const char * value , int length ) {\n<4> if ( length == - 1 ) {\n<5> length = strlen ( value ) ;\n<8> mime_field_value_set_comma_val ( heap , handle -> mh , handle -> field_ptr , idx , value , length ) ;\n<11> mime_field_value_set ( heap , handle -> mh , handle -> field_ptr , value , length , true ) ;
<1> static void trash_files ( CommonJob * job , GList * files , int * files_skipped ) {\n<12> if ( job_aborted ( job ) ) {\n<16> memset ( & transfer_info , 0 , sizeof ( transfer_info ) ) ;\n<17> report_trash_progress ( job , & source_info , & transfer_info ) ;\n<24> trash_file ( job , file , & skipped_file , & source_info , & transfer_info , TRUE , & to_delete ) ;\n<27> transfer_add_file_to_count ( file , job , & transfer_info ) ;\n<28> report_trash_progress ( job , & source_info , & transfer_info ) ;
<1> static void matroska_convert_tag ( AVFormatContext * s , EbmlList * list , AVDictionary * * metadata , char * prefix ) {\n<6> i < list -> nb_elem ;\n<8> const char * lang = tags [ i ] . lang && strcmp ( tags [ i ] . lang , "und" ) ? tags [ i ] . lang : NULL ;\n<15> if ( tags [ i ] . def || ! lang ) {\n<21> av_strlcat ( key , lang , sizeof ( key ) ) ;
<1> static struct cgroup_process_info * lxc_cgroup_get_container_info ( const char * name , const char * lxcpath , struct cgroup_meta_data * meta_data ) {\n<14> if ( ! path ) {\n<19> entry = calloc ( 1 , sizeof ( struct cgroup_process_info ) ) ;\n<20> if ( ! entry ) goto out_error ;\n<32> free ( path ) ;
<1> static int qemu_rdma_registration_handle(QEMUFile *f, void *opaque,\n<67> ret = qemu_rdma_exchange_recv(rdma, &head, RDMA_CONTROL_NONE);\n<79> if (head.repeat > RDMA_CONTROL_MAX_COMMANDS_PER_MESSAGE) {\n<81> fprintf(stderr, "rdma: Too many requests in this message (%d)."\n<93> switch (head.type) {\n<143> if (ret) {\n<211> if (ret < 0) {\n<213> fprintf(stderr, "rdma migration: error sending remote info!\n");\n<235> for (count = 0; count < head.repeat; count++) {\n<293> fprintf(stderr, "cannot get rkey!\n");\n<325> if (ret < 0) {\n<327> fprintf(stderr, "Failed to send control buffer!\n");\n<345> for (count = 0; count < head.repeat; count++) {\n<399> if (ret < 0) {\n<401> fprintf(stderr, "Failed to send control buffer!\n");\n<411> fprintf(stderr, "Invalid RESULT message at dest.\n");\n<419> fprintf(stderr, "Unknown control message %s\n",
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> CamtasiaContext * const c = avctx -> priv_data ;\n<31> if ( c -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) {\n<32> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<33> if ( pal ) {\n<35> memcpy ( c -> pal , pal , AVPALETTE_SIZE ) ;\n<37> memcpy ( frame -> data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;
<1> static void test_bug49972 ( ) {\n<20> memset ( & in_param_bind , 0 , sizeof ( in_param_bind ) ) ;\n<25> rc = mysql_stmt_bind_param ( stmt , & in_param_bind ) ;\n<29> memset ( & out_param_bind , 0 , sizeof ( out_param_bind ) ) ;\n<30> out_param_bind . buffer_type = MYSQL_TYPE_LONG ;\n<31> out_param_bind . is_null = & is_null ;\n<32> out_param_bind . buffer = & int_data ;\n<33> out_param_bind . buffer_length = sizeof ( int_data ) ;\n<34> rc = mysql_stmt_bind_result ( stmt , & out_param_bind ) ;\n<49> memset ( & out_param_bind , 0 , sizeof ( out_param_bind ) ) ;\n<54> rc = mysql_stmt_bind_result ( stmt , & out_param_bind ) ;
<1> static int xan_decode_frame(AVCodecContext *avctx,\n<7> XanContext *s = avctx->priv_data;\n<23> tmpptr = av_realloc(s->palettes, (s->palettes_count + 1) * AVPALETTE_SIZE);\n<26> s->palettes = tmpptr;\n<59> if ((ret = avctx->get_buffer(avctx, &s->current_frame))) {\n<66> memcpy(s->current_frame.data[1], s->palettes + s->cur_palette * AVPALETTE_COUNT, AVPALETTE_SIZE);
<1> static void config_connection_input ( struct config_connection * conn ) {\n<20> while ( ( args = config_connection_next_line ( conn ) ) != NULL ) {\n<21> if ( args [ 0 ] == NULL ) continue ;\n<22> if ( strcmp ( args [ 0 ] , "REQ" ) == 0 ) {\n<23> if ( config_connection_request ( conn , args + 1 ) < 0 ) break ;\n<25> if ( strcmp ( args [ 0 ] , "FILTERS" ) == 0 ) {\n<26> if ( config_filters_request ( conn ) < 0 ) break ;
<1> void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n<25> def = &tcg_op_defs[op];\n<39> for(i = 0; i < nb_args; i++) {\n<45> assert(ct_str != NULL);\n<51> if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n<79> if (*ct_str == '\0')\n<89> ct_str++;\n<95> if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n<97> fprintf(stderr, "Invalid constraint '%s' for arg %d of operation '%s'\n",\n<123> sort_constraints(def, 0, def->nb_oargs);\n<125> sort_constraints(def, def->nb_oargs, def->nb_iargs);
<1> static int mkv_write_header(AVFormatContext *s)\n<19> if (!strcmp(s->oformat->name, "webm"))\n<21> mkv->mode = MODE_WEBM;\n<25> mkv->mode = MODE_MATROSKAv2;\n<95> put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);
<1> static int create_vorbis_context(vorbis_enc_context *venc,\n<43> vorbis_enc_codebook *cb = &venc->codebooks[book];\n<65> if (!cb->lens || !cb->codewords)\n<69> memcpy(cb->lens, cvectors[book].clens, cvectors[book].len);\n<71> memset(cb->lens + cvectors[book].len, 0, cb->nentries - cvectors[book].len);\n<95> if ((ret = ready_codebook(cb)) < 0)\n<129> static const int a[] = {0, 1, 2, 2, 3, 3, 4, 4};\n<227> rc = &venc->residues[0];\n<243> if (!rc->books)\n<273> memcpy(rc->books, a, sizeof a);\n<277> if ((ret = ready_residue(rc, venc)) < 0)
<1> static int matroska_decode_buffer ( uint8_t * * buf , int * buf_size , MatroskaTrack * track ) {\n<3> uint8_t * data = * buf ;\n<4> int isize = * buf_size ;\n<14> uint8_t * header = encodings [ 0 ] . compression . settings . data ;\n<15> if ( ! header_size ) return 0 ;\n<18> if ( ! pkt_data ) return AVERROR ( ENOMEM ) ;\n<19> memcpy ( pkt_data , header , header_size ) ;\n<20> memcpy ( pkt_data + header_size , data , isize ) ;\n<74> bzstream . next_in = data ;\n<75> bzstream . avail_in = isize ;\n<78> newpktdata = av_realloc ( pkt_data , pkt_size ) ;
<1> static void bufp_free(USBRedirDevice *dev, struct buf_packet *bufp,\n<7> QTAILQ_REMOVE(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n<11> free(bufp->data);\n<13> g_free(bufp);
<1> static u_short create_scan_states ( char * text , u_short token , follby followedby , u_short prev_state ) {\n<15> if ( '\0' == text [ 1 ] ) {\n<16> fprintf ( stderr , "Duplicate entries for keyword '%s' in" " keyword_gen.c ntp_keywords[].\n" , current_keyword ) ;\n<23> if ( my_state >= COUNTOF ( sst ) ) {\n<24> fprintf ( stderr , "fatal, keyword scanner state array " "sst[%d] is too small, modify\n" "keyword-gen.c to increase.\n" , ( int ) COUNTOF ( sst ) ) ;\n<36> if ( sst [ token ] . finishes_token != ( u_short ) token ) {\n<37> fprintf ( stderr , "fatal, sst[%d] not reserved for %s.\n" , token , symbname ( token ) ) ;\n<40> if ( my_state != token ) {
<1> static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb,\n<83> if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size))\n<95> pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n<101> memcpy(pal, s->palette, AVPALETTE_SIZE);
<1> MSG_PROCESS_RETURN tls_process_client_hello ( SSL * s , PACKET * pkt ) {\n<61> if ( is_v2_record ) {\n<79> challenge_len = challenge_len > SSL3_RANDOM_SIZE ? SSL3_RANDOM_SIZE : challenge_len ;\n<80> memset ( s -> s3 -> client_random , 0 , SSL3_RANDOM_SIZE ) ;\n<81> if ( ! PACKET_copy_bytes ( & challenge , s -> s3 -> client_random + SSL3_RANDOM_SIZE - challenge_len , challenge_len ) || ! PACKET_buf_init ( & compression , & null_compression , 1 ) ) {
<1> int _zip_dirent_read ( struct zip_dirent * zde , FILE * fp , unsigned char * * bufp , zip_uint32_t * leftp , int local , struct zip_error * error ) {\n<12> if ( bufp ) {\n<13> cur = * bufp ;\n<16> if ( ( fread ( buf , 1 , size , fp ) < size ) ) {\n<20> cur = buf ;\n<22> if ( memcmp ( cur , ( local ? LOCAL_MAGIC : CENTRAL_MAGIC ) , 4 ) != 0 ) {\n<23> _zip_error_set ( error , ZIP_ER_NOZIP , 0 ) ;\n<24> return - 1 ;\n<26> cur += 4 ;\n<27> if ( ! local ) zde -> version_madeby = _zip_read2 ( & cur ) ;\n<29> zde -> version_needed = _zip_read2 ( & cur ) ;\n<30> zde -> bitflags = _zip_read2 ( & cur ) ;\n<31> zde -> comp_method = _zip_read2 ( & cur ) ;\n<32> dostime = _zip_read2 ( & cur ) ;\n<33> dosdate = _zip_read2 ( & cur ) ;\n<34> zde -> last_mod = _zip_d2u_time ( dostime , dosdate ) ;\n<35> zde -> crc = _zip_read4 ( & cur ) ;\n<36> zde -> comp_size = _zip_read4 ( & cur ) ;\n<37> zde -> uncomp_size = _zip_read4 ( & cur ) ;\n<38> zde -> filename_len = _zip_read2 ( & cur ) ;\n<39> zde -> extrafield_len = _zip_read2 ( & cur ) ;\n<40> if ( local ) {\n<54> zde -> filename = NULL ;\n<55> zde -> extrafield = NULL ;\n<56> zde -> comment = NULL ;\n<57> size += zde -> filename_len + zde -> extrafield_len + zde -> comment_len ;\n<58> if ( leftp && ( * leftp < size ) ) {
<1> static void test_bug11037 ( ) {\n<11> stmt_text = "select id FROM t1" ;\n<12> stmt = mysql_stmt_init ( mysql ) ;\n<13> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<14> rc = mysql_stmt_fetch ( stmt ) ;\n<16> if ( ! opt_silent ) fprintf ( stdout , "Got error, as expected:\n [%d] %s\n" , mysql_stmt_errno ( stmt ) , mysql_stmt_error ( stmt ) ) ;
<1> static void test_dispatch_cmd_io(void)\n<45> assert(!strcmp(qdict_get_str(ret, "string"), "blah1"));\n<49> assert(!strcmp(qdict_get_str(ret_dict, "string"), "blah2"));\n<57> assert(!strcmp(qdict_get_str(ret_dict_dict_userdef, "string"), "hello"));\n<59> assert(!strcmp(qdict_get_str(ret_dict_dict, "string"), "blah3"));\n<67> assert(!strcmp(qdict_get_str(ret_dict_dict2_userdef, "string"), "hello2"));\n<69> assert(!strcmp(qdict_get_str(ret_dict_dict2, "string"), "blah4"));
<1> err_status_t srtp_stream_clone ( const srtp_stream_ctx_t * stream_template , uint32_t ssrc , srtp_stream_ctx_t * * str_ptr ) {\n<6> if ( str == NULL ) return err_status_alloc_fail ;\n<19> if ( status ) {\n<31> memcpy ( str -> salt , stream_template -> salt , SRTP_AEAD_SALT_LEN ) ;\n<32> memcpy ( str -> c_salt , stream_template -> c_salt , SRTP_AEAD_SALT_LEN ) ;
<1> static int __qemu_rdma_add_block(RDMAContext *rdma, void *host_addr,\n<7> RDMALocalBlocks *local = &rdma->local_ram_blocks;\n<13> RDMALocalBlock *old = local->block;\n<21> local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n<25> if (local->nb_blocks) {\n<35> g_hash_table_insert(rdma->blockmap, (void *)old[x].offset,\n<41> memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n<43> g_free(old);\n<49> block = &local->block[local->nb_blocks];
<1> static int aac_decode_frame(AVCodecContext *avctx, void *data,\n<39> if (new_extradata && 0) {\n<47> if (!avctx->extradata)\n<53> memcpy(avctx->extradata, new_extradata, new_extradata_size);\n<57> if (decode_audio_specific_config(ac, ac->avctx, &ac->oc[1].m4ac,
<1> int get_filtered_video_frame(AVFilterContext *ctx, AVFrame *frame,\n<18> if (!(picref = ctx->inputs[0]->cur_buf))\n<30> memcpy(frame->data,     picref->data,     sizeof(frame->data));\n<32> memcpy(frame->linesize, picref->linesize, sizeof(frame->linesize));
<1> static int dissect_btgatt ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n<8> if ( strlen ( pinfo -> current_proto ) > 7 ) {\n<9> uuid . size = 2 ;\n<10> uuid . bt_uuid = ( guint16 ) g_ascii_strtoull ( pinfo -> current_proto + strlen ( pinfo -> current_proto ) - 7 , NULL , 16 ) ;\n<11> uuid . data [ 1 ] = uuid . bt_uuid & 0xFF ;\n<12> uuid . data [ 0 ] = ( uuid . bt_uuid >> 8 ) & 0xFF ;\n<15> uuid . size = 2 ;\n<16> uuid . bt_uuid = 0 ;\n<18> return dissect_attribute_value ( main_tree , patron_item , pinfo , tvb , 0 , tvb_captured_length ( tvb ) , 0 , uuid , ( btatt_data_t * ) data ) ;
<1> static int dump_trigger ( FILE * sql_file , MYSQL_RES * show_create_trigger_rs , const char * db_name , const char * db_cl_name ) {\n<6> while ( ( row = mysql_fetch_row ( show_create_trigger_rs ) ) ) {\n<7> if ( opt_xml ) {\n<8> print_xml_row ( sql_file , "trigger" , show_create_trigger_rs , & row , "SQL Original Statement" ) ;\n<12> query_str = cover_definer_clause ( row [ 2 ] , strlen ( row [ 2 ] ) , C_STRING_WITH_LEN ( "50017" ) , C_STRING_WITH_LEN ( "50003" ) , C_STRING_WITH_LEN ( " TRIGGER" ) ) ;
<1> static TypeImpl *type_register_internal(const TypeInfo *info)\n<15> if (type_table_lookup(info->name) != NULL) {\n<17> fprintf(stderr, "Registering `%s' which already exists\n", info->name);\n<25> ti->name = g_strdup(info->name);
<1> static const struct URLProtocol *url_find_protocol(const char *filename)\n<9> size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n<15> if (filename[proto_len] != ':' &&\n<17> (strncmp(filename, "subfile,", 8) || !strchr(filename + proto_len + 1, ':')) ||\n<19> is_dos_path(filename))\n<21> strcpy(proto_str, "file");\n<27> FFMIN(proto_len + 1, sizeof(proto_str)));\n<31> if ((ptr = strchr(proto_str, ',')))\n<33> *ptr = '\0';\n<35> av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n<37> if ((ptr = strchr(proto_nested, '+')))\n<39> *ptr = '\0';\n<47> for (i = 0; protocols[i]; i++) {\n<49> const URLProtocol *up = protocols[i];\n<51> if (!strcmp(proto_str, up->name)) {\n<53> av_freep(&protocols);\n<55> return up;\n<59> if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n<61> !strcmp(proto_nested, up->name)) {\n<65> return up;
<1> static int protocol_client_auth_sasl_mechname(VncState *vs, uint8_t *data, size_t len)\n<5> char *mechname = malloc(len + 1);\n<7> if (!mechname) {\n<15> strncpy(mechname, (char*)data, len);\n<17> mechname[len] = '\0';\n<19> VNC_DEBUG("Got client mechname '%s' check against '%s'\n",\n<25> if (strncmp(vs->sasl.mechlist, mechname, len) == 0) {\n<27> if (vs->sasl.mechlist[len] != '\0' &&\n<29> vs->sasl.mechlist[len] != ',') {\n<41> char *offset = strstr(vs->sasl.mechlist, mechname);\n<43> VNC_DEBUG("Two %p\n", offset);\n<71> free(vs->sasl.mechlist);\n<73> vs->sasl.mechlist = mechname;\n<77> VNC_DEBUG("Validated mechname '%s'\n", mechname);
<1> static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n<21> draw_info -> text = ConstantString ( label ) ;\n<25> if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) {\n<29> else if ( ( strlen ( label ) > 0 ) && ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) ) {\n<33> draw_info -> pointsize *= 2.0 ) {\n<44> high = draw_info -> pointsize ;\n<45> for ( low = 1.0 ;\n<46> ( high - low ) > 0.5 ;\n<61> draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ;
<1> static int checkHttpTxnParentProxy ( ContData * data , TSHttpTxn txnp ) {\n<2> const char * hostname = "txnpp.example.com" ;\n<4> const char * hostnameget = nullptr ;\n<7> if ( TSHttpTxnParentProxyGet ( txnp , & hostnameget , & portget ) != TS_SUCCESS ) {\n<12> if ( ( strcmp ( hostname , hostnameget ) == 0 ) && ( port == portget ) ) {\n<13> SDK_RPRINT ( data -> test , "TSHttpTxnParentProxySet" , "TestCase1" , TC_PASS , "ok" ) ;\n<14> SDK_RPRINT ( data -> test , "TSHttpTxnParentProxyGet" , "TestCase1" , TC_PASS , "ok" ) ;\n<15> data -> test_passed_Parent_Proxy = true ;\n<18> SDK_RPRINT ( data -> test , "TSHttpTxnParentProxySet" , "TestCase1" , TC_FAIL , "Value's Mismatch" ) ;\n<19> SDK_RPRINT ( data -> test , "TSHttpTxnParentProxyGet" , "TestCase1" , TC_FAIL , "Value's Mismatch" ) ;
<1> int main ( int argc , char * * argv ) {\n<13> memset ( & saved_expected_errors , 0 , sizeof ( saved_expected_errors ) ) ;\n<19> memset ( block_stack , 0 , sizeof ( block_stack ) ) ;\n<35> memset ( & master_pos , 0 , sizeof ( master_pos ) ) ;\n<37> memset ( & var_reg , 0 , sizeof ( var_reg ) ) ;\n<379> if ( command -> type != Q_ERROR && command -> type != Q_COMMENT ) {\n<380> memset ( & saved_expected_errors , 0 , sizeof ( saved_expected_errors ) ) ;
<1> int bdrv_commit(BlockDriverState *bs)\n<33> if (bdrv_in_use(bs) || bdrv_in_use(bs->backing_hd)) {\n<43> strncpy(filename, bs->backing_hd->filename, sizeof(filename));\n<51> if (bdrv_reopen(bs->backing_hd, open_flags | BDRV_O_RDWR, NULL)) {\n<83> if (bdrv_write(bs->backing_hd, sector, buf, n) != 0) {\n<117> bdrv_flush(bs->backing_hd);\n<131> bdrv_reopen(bs->backing_hd, open_flags & ~BDRV_O_RDWR, NULL);
<1> int main ( int argc , char * * argv ) {\n<43> debug = 0 ;\n<70> case 'D' : debug ++ ;\n<72> case 'u' : username = optarg ;\n<74> case 't' : newroot = optarg ;\n<76> case 'd' : device = optarg ;\n<78> case 'm' : mtu = atoi ( optarg ) ;\n<80> case 'l' : listen_ip = optarg ;\n<82> case 'p' : port = atoi ( optarg ) ;\n<84> case 'n' : if ( optarg && strcmp ( "auto" , optarg ) == 0 ) {\n<88> ns_ip = inet_addr ( optarg ) ;\n<92> bind_port = atoi ( optarg ) ;\n<94> case 'F' : pidfile = optarg ;\n<96> case 'i' : max_idle_time = atoi ( optarg ) ;\n<98> case 'P' : strncpy ( password , optarg , sizeof ( password ) ) ;\n<99> password [ sizeof ( password ) - 1 ] = 0 ;\n<100> memset ( optarg , 0 , strlen ( optarg ) ) ;\n<102> case 'z' : context = optarg ;\n<109> argv += optind ;\n<112> netsize = strchr ( argv [ 0 ] , '/' ) ;\n<115> netsize ++ ;\n<118> my_ip = inet_addr ( argv [ 0 ] ) ;\n<123> topdomain = strdup ( argv [ 1 ] ) ;\n<124> if ( check_topdomain ( topdomain , & errormsg ) ) {\n<128> if ( username != NULL ) {\n<142> if ( port != 53 ) {\n<143> fprintf ( stderr , "ALERT! Other dns servers expect you to run on port 53.\n" ) ;\n<144> fprintf ( stderr , "You must manually forward port 53 to port %d for things to work.\n" , port ) ;\n<147> fprintf ( stderr , "Debug level %d enabled, will stay in foreground.\n" , debug ) ;\n<148> fprintf ( stderr , "Add more -D switches to set higher debug level.\n" ) ;\n<151> dnsaddr_len = get_addr ( listen_ip , port , AF_INET , AI_PASSIVE | AI_NUMERICHOST , & dnsaddr ) ;\n<162> if ( bind_port == port && ( dns_ip == INADDR_ANY || dns_ip == htonl ( 0x7f000001L ) ) ) {\n<163> warnx ( "Forward port is same as listen port (%d), will create a loop!" , bind_port ) ;\n<164> fprintf ( stderr , "Use -l to set listen ip to avoid this.\n" ) ;\n<167> fprintf ( stderr , "Requests for domains outside of %s will be forwarded to port %d\n" , topdomain , bind_port ) ;\n<173> fprintf ( stderr , "Failed to get external IP via web service.\n" ) ;\n<177> fprintf ( stderr , "Using %s as external IP.\n" , inet_ntoa ( extip ) ) ;\n<187> if ( strlen ( password ) == 0 ) {\n<188> if ( NULL != getenv ( PASSWORD_ENV_VAR ) ) snprintf ( password , sizeof ( password ) , "%s" , getenv ( PASSWORD_ENV_VAR ) ) ;\n<198> if ( tun_setip ( argv [ 0 ] , other_ip , netmask ) != 0 || tun_setmtu ( mtu ) != 0 ) {\n<200> free ( ( void * ) other_ip ) ;\n<203> free ( ( void * ) other_ip ) ;
<1> static void parse_argv ( void ) {\n<4> i < global_argc ;\n<5> i ++ ) {\n<6> const char * a = global_argv [ i ] ;\n<7> if ( * a != '-' || ! strcmp ( a , "--" ) ) break ;\n<8> if ( ! skip_prefix ( a , "--" , & a ) ) die ( "unknown option %s" , a ) ;\n<9> if ( parse_one_option ( a ) ) continue ;\n<11> if ( skip_prefix ( a , "cat-blob-fd=" , & a ) ) {
<1> static int udp_open(URLContext *h, const char *uri, int flags)\n<49> p = strchr(uri, '?');\n<53> if (av_find_info_tag(buf, sizeof(buf), "reuse", p)) {\n<138> if (include || av_find_info_tag(buf, sizeof(buf), "block", p)) {\n<144> source_start = buf;\n<148> char *next = strchr(source_start, ',');\n<154> sources[num_sources] = av_strdup(source_start);\n<160> source_start = next + 1;\n<164> if (num_sources >= FF_ARRAY_ELEMS(sources) || !next)\n<178> av_url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, NULL, 0, uri);
<1> void MatInverse ( real into [ 6 ] , real orig [ 6 ] ) {\n<3> if ( det == 0 ) {\n<5> memset ( into , 0 , sizeof ( * into ) ) ;
<1> static inline int match_prefix ( char * prefix , int plen , char * option , int olen ) {\n<2> if ( plen > olen ) return 0 ;\n<3> return ! memcmp ( prefix , option , plen ) ;
<1> static void test_bug11718 ( ) {\n<19> if ( ! opt_silent ) printf ( "return type: %s" , ( res -> fields [ 0 ] . type == MYSQL_TYPE_DATE ) ? "DATE" : "not DATE" ) ;
<1> int av_image_fill_pointers ( uint8_t * data [ 4 ] , enum PixelFormat pix_fmt , int height , uint8_t * ptr , const int linesizes [ 4 ] ) {\n<4> memset ( data , 0 , sizeof ( data [ 0 ] ) * 4 ) ;\n<5> memset ( size , 0 , sizeof ( size ) ) ;\n<6> memset ( has_plane , 0 , sizeof ( has_plane ) ) ;\n<12> size [ 0 ] = ( size [ 0 ] + 3 ) & ~ 3 ;\n<13> data [ 1 ] = ptr + size [ 0 ] ;\n<14> return size [ 0 ] + 256 * 4 ;\n<19> total_size = size [ 0 ] ;\n<21> i < 4 && has_plane [ i ] ;\n<24> data [ i ] = data [ i - 1 ] + size [ i - 1 ] ;\n<28> if ( total_size > INT_MAX - size [ i ] ) return AVERROR ( EINVAL ) ;\n<29> total_size += size [ i ] ;
<1> static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) {\n<2> char format [ MagickPathExtent ] , keyword [ MagickPathExtent ] , tag [ MagickPathExtent ] , value [ MagickPathExtent ] ;\n<39> comment != ( char * ) NULL ;\n<40> p ++ ) {\n<47> if ( comment == ( char * ) NULL ) break ;\n<48> p = comment + strlen ( comment ) ;\n<61> p = keyword ;\n<63> if ( ( size_t ) ( p - keyword ) < ( MagickPathExtent - 1 ) ) * p ++ = c ;\n<73> if ( LocaleCompare ( keyword , "Y" ) == 0 ) value_expected = MagickTrue ;\n<75> p = value ;\n<77> if ( ( size_t ) ( p - value ) < ( MagickPathExtent - 1 ) ) * p ++ = c ;\n<81> switch ( * keyword ) {\n<84> ( void ) CopyMagickString ( format , value , MagickPathExtent ) ;\n<88> ( void ) SetImageProperty ( image , tag , value , exception ) ;\n<93> image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ;\n<97> ( void ) SetImageProperty ( image , tag , value , exception ) ;\n<101> if ( LocaleCompare ( keyword , "primaries" ) == 0 ) {\n<102> float chromaticity [ 6 ] , white_point [ 2 ] ;\n<104> count = sscanf ( value , "%g %g %g %g %g %g %g %g" , & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , & white_point [ 0 ] , & white_point [ 1 ] ) ;\n<105> if ( count == 8 ) {\n<106> image -> chromaticity . red_primary . x = chromaticity [ 0 ] ;\n<107> image -> chromaticity . red_primary . y = chromaticity [ 1 ] ;\n<108> image -> chromaticity . green_primary . x = chromaticity [ 2 ] ;\n<109> image -> chromaticity . green_primary . y = chromaticity [ 3 ] ;\n<110> image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ;\n<111> image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ;\n<112> image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ;\n<117> ( void ) SetImageProperty ( image , tag , value , exception ) ;\n<121> char target [ ] = "Y" ;\n<122> if ( strcmp ( keyword , target ) == 0 ) {\n<124> if ( sscanf ( value , "%d +X %d" , & height , & width ) == 2 ) {\n<125> image -> columns = ( size_t ) width ;\n<126> image -> rows = ( size_t ) height ;\n<130> ( void ) FormatLocaleString ( tag , MagickPathExtent , "hdr:%s" , keyword ) ;\n<131> ( void ) SetImageProperty ( image , tag , value , exception ) ;\n<136> ( void ) SetImageProperty ( image , tag , value , exception ) ;\n<155> if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ;\n<160> count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ;\n<164> count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ;\n<166> if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) {\n<167> ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ;\n<168> count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ;\n<172> p = pixels ;\n<178> count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ;\n<180> if ( pixel [ 0 ] > 128 ) {\n<206> pixel [ 0 ] = pixels [ x ] ;\n<207> pixel [ 1 ] = pixels [ x + image -> columns ] ;\n<208> pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ;\n<212> pixel [ 0 ] = pixels [ i ++ ] ;\n<213> pixel [ 1 ] = pixels [ i ++ ] ;\n<214> pixel [ 2 ] = pixels [ i ++ ] ;\n<220> if ( pixel [ 3 ] != 0 ) {\n<221> gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ;\n<222> SetPixelRed ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) , q ) ;\n<223> SetPixelGreen ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) , q ) ;\n<224> SetPixelBlue ( image , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) , q ) ;\n<232> pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ;
<1> static void do_video_out(AVFormatContext *s,\n<29> sync_ipts = get_sync_ipts(ost) / av_q2d(enc->time_base);\n<73> if (verbose>2)\n<75> fprintf(stderr, "*** drop!\n");\n<81> if (verbose>2)\n<83> fprintf(stderr, "*** %d dup!\n", nb_frames-1);\n<159> if (avpicture_alloc((AVPicture *)&ost->resample_frame, enc->pix_fmt,\n<163> fprintf(stderr, "Cannot allocate temp picture, check pix fmt\n");\n<181> if (ost->img_resample_ctx == NULL) {\n<183> fprintf(stderr, "Cannot get resampling context\n");\n<327> if (ret < 0) {\n<329> fprintf(stderr, "Video encoding failed\n");\n<371> if (ost->logfile && enc->stats_out) {\n<373> fprintf(ost->logfile, "%s", enc->stats_out);
<1> static int ff_asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt)\n<5> ASFContext *asf = s->priv_data;\n<85> asf_st = asf->asf_st;\n<169> if (asf_st->pkt.data && asf_st->palette_changed) {\n<173> pal = av_packet_new_side_data(&asf_st->pkt, AV_PKT_DATA_PALETTE,\n<177> if (!pal) {\n<183> memcpy(pal, asf_st->palette, AVPALETTE_SIZE);\n<225> if(   asf->packet_frag_offset >= asf_st->pkt.size\n<227> || asf->packet_frag_size > asf_st->pkt.size - asf->packet_frag_offset){\n<245> if (ret < 0 || asf->packet_frag_offset + ret == 0)\n<249> if (asf_st->ds_span > 1) {\n<257> memset(asf_st->pkt.data + asf->packet_frag_offset + ret, 0,\n<259> asf->packet_frag_size - ret);\n<291> for(i=0; i<asf_st->pkt.size && !asf_st->pkt.data[i]; i++);\n<313> if(asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span){\n<321> uint8_t *newdata = av_malloc(asf_st->pkt.size + FF_INPUT_BUFFER_PADDING_SIZE);\n<323> if (newdata) {\n<327> memset(newdata + asf_st->pkt.size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n<329> while (offset < asf_st->pkt.size) {\n<331> int off = offset / asf_st->ds_chunk_size;\n<349> asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n<353> offset += asf_st->ds_chunk_size;
<11> if ( ! PyArg_ParseTupleAndKeywords ( args , keywds , "s|zl" , kwlist , & service , & principal , & gss_flags ) ) return NULL ;\n<12> state = ( gss_client_state * ) malloc ( sizeof ( gss_client_state ) ) ;
<1> static int a64multi_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<41> int charset_size = 0x800 * (INTERLACED + 1);\n<133> if ((ret = ff_alloc_packet(pkt, req_size)) < 0) {\n<141> buf = pkt->data;\n<155> render_charset(avctx, charset, colram);\n<161> memcpy(buf, charset, charset_size);\n<167> buf      += charset_size;\n<169> charset  += charset_size;\n<225> AV_WB32(avctx->extradata + 8,  charset_size);
<1> static gboolean logcat_read_packet ( struct logcat_phdr * logcat , FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n<8> bytes_read = file_read ( & tmp , 2 , fh ) ;\n<14> payload_length = pletoh16 ( tmp ) ;\n<15> if ( logcat -> version == 1 ) {\n<18> else if ( logcat -> version == 2 ) {\n<25> pd = buffer_start_ptr ( buf ) ;\n<27> memcpy ( pd , tmp , 2 ) ;\n<28> bytes_read = file_read ( pd + 2 , packet_size - 2 , fh ) ;
<1> void dtls1_stop_timer ( SSL * s ) {\n<2> memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;\n<3> memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;\n<5> BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;
<1> static int get_str_opt ( struct archive_write * a , struct archive_string * s , size_t maxsize , const char * key , const char * value ) {\n<2> if ( strlen ( value ) > maxsize ) {\n<3> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Value is longer than %zu characters " "for option ``%s''" , maxsize , key ) ;\n<4> return ( ARCHIVE_FATAL ) ;\n<6> archive_strcpy ( s , value ) ;\n<7> return ( ARCHIVE_OK ) ;
<1> bool RunIdentifySystem ( PGconn * conn , char * * sysid , TimeLineID * starttli , XLogRecPtr * startpos , char * * db_name ) {\n<6> if ( PQresultStatus ( res ) != PGRES_TUPLES_OK ) {\n<7> fprintf ( stderr , _ ( "%s: could not send replication command \"%s\": %s" ) , progname , "IDENTIFY_SYSTEM" , PQerrorMessage ( conn ) ) ;\n<11> if ( PQntuples ( res ) != 1 || PQnfields ( res ) < 3 ) {\n<12> fprintf ( stderr , _ ( "%s: could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields\n" ) , progname , PQntuples ( res ) , PQnfields ( res ) , 1 , 3 ) ;\n<18> if ( startpos != NULL ) {\n<19> if ( sscanf ( PQgetvalue ( res , 0 , 2 ) , "%X/%X" , & hi , & lo ) != 2 ) {\n<20> fprintf ( stderr , _ ( "%s: could not parse transaction log location \"%s\"\n" ) , progname , PQgetvalue ( res , 0 , 2 ) ) ;\n<21> PQclear ( res ) ;\n<22> return false ;\n<24> * startpos = ( ( uint64 ) hi ) << 32 | lo ;\n<26> if ( db_name != NULL ) {\n<29> if ( PQnfields ( res ) < 4 ) {\n<30> fprintf ( stderr , _ ( "%s: could not identify system: got %d rows and %d fields, expected %d rows and %d or more fields\n" ) , progname , PQntuples ( res ) , PQnfields ( res ) , 1 , 4 ) ;
<1> static int selinux_inode_removexattr ( struct dentry * dentry , const char * name ) {\n<2> if ( strcmp ( name , XATTR_NAME_SELINUX ) ) return selinux_inode_setotherxattr ( dentry , name ) ;\n<3> return - EACCES ;
<1> static int decode_hq_slice(DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf)\n<79> coef_par = ff_dirac_golomb_read_32bit(s->reader_ctx, addr,\n<85> coef_par = ff_dirac_golomb_read_16bit(s->reader_ctx, addr,\n<91> if (coef_num > coef_par) {\n<97> memset(&tmp_buf[start_b], 0, end_b - start_b);
<1> static int vp9_decode_frame(AVCodecContext *avctx, AVFrame *frame,\n<7> VP9Context *s = avctx->priv_data;\n<11> ptrdiff_t yoff = 0, uvoff = 0;\n<75> memset(s->above_partition_ctx, 0, s->cols);\n<77> memset(s->above_skip_ctx, 0, s->cols);\n<79> if (s->keyframe || s->intraonly)\n<81> memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n<85> memset(s->above_mode_ctx, NEARESTMV, s->cols);\n<87> memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n<89> memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 8);\n<91> memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 8);\n<93> memset(s->above_segpred_ctx, 0, s->cols);\n<127> ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);\n<129> if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) // marker bit\n<145> row += 8, yoff += s->cur_frame->linesize[0] * 64,\n<147> uvoff += s->cur_frame->linesize[1] * 32) {\n<149> VP9Filter *lflvl = s->lflvl;\n<155> for (tile_col = 0; tile_col < s->tiling.tile_cols; tile_col++) {\n<165> memset(s->left_partition_ctx, 0, 8);\n<167> memset(s->left_skip_ctx, 0, 8);\n<169> if (s->keyframe || s->intraonly)\n<171> memset(s->left_mode_ctx, DC_PRED, 16);\n<175> memset(s->left_mode_ctx, NEARESTMV, 8);\n<177> memset(s->left_y_nnz_ctx, 0, 16);\n<179> memset(s->left_uv_nnz_ctx, 0, 16);\n<181> memset(s->left_segpred_ctx, 0, 8);\n<185> memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));\n<189> col < s->tiling.tile_col_end;\n<191> col += 8, yoff2 += 64, uvoff2 += 32, lflvl++) {\n<197> memset(lflvl->mask, 0, sizeof(lflvl->mask));\n<209> memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));\n<219> if (row + 8 < s->rows) {\n<225> 63 * s->cur_frame->linesize[0],\n<227> 8 * s->cols);\n<233> 31 * s->cur_frame->linesize[1],\n<235> 4 * s->cols);\n<241> 31 * s->cur_frame->linesize[2],\n<243> 4 * s->cols);\n<259> for (col = 0; col < s->cols;\n<261> col += 8, yoff2 += 64, uvoff2 += 32, lflvl++)\n<263> loopfilter_subblock(avctx, lflvl, row, col, yoff2, uvoff2);\n<279> if (s->parallelmode) {\n<281> memcpy(s->prob_ctx[s->framectxid].coef, s->prob.coef,\n<289> ff_vp9_adapt_probs(s);
<1> static int find_snapshot_by_id(BlockDriverState *bs, const char *id_str)\n<11> for(i = 0; i < s->nb_snapshots; i++) {\n<13> if (!strcmp(s->snapshots[i].id_str, id_str))\n<15> return i;
<1> static int fts_build_add_tokens_with_filter ( struct fts_mail_build_context * ctx , const unsigned char * data , size_t size ) {\n<7> ret = ret2 = fts_tokenizer_next ( tokenizer , data , size , & token , & error ) ;\n<8> if ( ret2 > 0 && filter != NULL ) ret2 = fts_filter_filter ( filter , & token , & error ) ;\n<10> if ( ret2 > 0 ) {\n<11> if ( fts_backend_update_build_more ( ctx -> update_ctx , ( const void * ) token , strlen ( token ) ) < 0 ) ret = - 1 ;
<1> static void select_vgahw (const char *p)\n<26> fprintf(stderr, "Unknown vga type: %s\n", p);\n<29> if (strstart(opts, ",retrace=", &nextopt)) {\n<32> else if (strstart(opts, "precise", &nextopt))
<1> char * irc_ctcp_replace_variables ( struct t_irc_server * server , const char * format ) {\n<9> if ( ! temp ) return NULL ;\n<12> temp = weechat_string_replace ( res , "$git" , info ) ;\n<13> free ( res ) ;\n<14> if ( ! temp ) return NULL ;\n<18> temp = weechat_string_replace ( res , "$versiongit" , buf ) ;\n<19> free ( res ) ;\n<20> if ( ! temp ) return NULL ;\n<23> temp = weechat_string_replace ( res , "$version" , info ) ;\n<24> free ( res ) ;\n<25> if ( ! temp ) return NULL ;\n<28> temp = weechat_string_replace ( res , "$compilation" , info ) ;\n<29> free ( res ) ;\n<30> if ( ! temp ) return NULL ;\n<32> buf_uname = ( struct utsname * ) malloc ( sizeof ( struct utsname ) ) ;\n<33> if ( buf_uname ) {\n<34> if ( uname ( buf_uname ) >= 0 ) {\n<35> snprintf ( buf , sizeof ( buf ) , "%s %s / %s" , buf_uname -> sysname , buf_uname -> release , buf_uname -> machine ) ;\n<36> temp = weechat_string_replace ( res , "$osinfo" , buf ) ;\n<37> free ( res ) ;\n<38> if ( ! temp ) {\n<39> free ( buf_uname ) ;\n<44> free ( buf_uname ) ;\n<47> temp = weechat_string_replace ( res , "$site" , info ) ;\n<48> free ( res ) ;\n<49> if ( ! temp ) return NULL ;\n<52> temp = weechat_string_replace ( res , "$download" , info ) ;\n<53> free ( res ) ;\n<54> if ( ! temp ) return NULL ;\n<61> temp = weechat_string_replace ( res , "$time" , buf ) ;\n<62> free ( res ) ;\n<66> if ( username ) {\n<67> temp = weechat_string_replace ( res , "$username" , username ) ;\n<68> free ( res ) ;\n<69> if ( ! temp ) return NULL ;\n<71> free ( username ) ;\n<74> if ( realname ) {\n<75> temp = weechat_string_replace ( res , "$realname" , realname ) ;\n<76> free ( res ) ;\n<77> if ( ! temp ) return NULL ;\n<79> free ( realname ) ;
<1> static struct cgroup_process_info * lxc_cgroup_process_info_getx ( const char * proc_pid_cgroup_str , struct cgroup_meta_data * meta ) {\n<4> char * line = NULL ;\n<11> while ( getline ( & line , & sz , proc_pid_cgroup ) != - 1 ) {\n<17> if ( ! line [ 0 ] ) continue ;\n<18> if ( line [ strlen ( line ) - 1 ] == '\n' ) line [ strlen ( line ) - 1 ] = '\0' ;\n<19> colon1 = strchr ( line , ':' ) ;\n<20> if ( ! colon1 ) continue ;\n<21> * colon1 ++ = '\0' ;\n<22> colon2 = strchr ( colon1 , ':' ) ;\n<23> if ( ! colon2 ) continue ;\n<24> * colon2 ++ = '\0' ;\n<26> hierarchy_number = strtoul ( line , & endptr , 10 ) ;\n<28> if ( hierarchy_number > meta -> maximum_hierarchy ) {\n<33> if ( ! h ) {\n<37> if ( ! h -> used ) continue ;\n<38> entry = calloc ( 1 , sizeof ( struct cgroup_process_info ) ) ;\n<39> if ( ! entry ) goto out_error ;\n<42> entry -> cgroup_path = strdup ( colon2 ) ;\n<43> if ( ! entry -> cgroup_path ) goto out_error ;\n<49> free ( line ) ;\n<55> free ( line ) ;
<1> static void file_change_cr ( const char * s , struct branch * b , int rename ) {\n<8> if ( ! unquote_c_style ( & s_uq , s , & endp ) ) {\n<12> endp = strchr ( s , ' ' ) ;\n<13> if ( ! endp ) die ( "Missing space after source: %s" , command_buf . buf ) ;\n<14> strbuf_add ( & s_uq , s , endp - s ) ;\n<25> memset ( & leaf , 0 , sizeof ( leaf ) ) ;\n<26> if ( rename ) tree_content_remove ( & b -> branch_tree , s , & leaf , 1 ) ;\n<27> else tree_content_get ( & b -> branch_tree , s , & leaf , 1 ) ;\n<30> tree_content_replace ( & b -> branch_tree , leaf . versions [ 1 ] . sha1 , leaf . versions [ 1 ] . mode , leaf . tree ) ;\n<33> tree_content_set ( & b -> branch_tree , d , leaf . versions [ 1 ] . sha1 , leaf . versions [ 1 ] . mode , leaf . tree ) ;
<9> ret = av_packet_copy_props(dst, src);\n<19> ret = packet_alloc(&dst->buf, src->size);\n<21> if (ret < 0)\n<25> memcpy(dst->buf->data, src->data, src->size);\n<29> dst->data = dst->buf->data;\n<49> dst->size = src->size;
<1> static struct qcms_modular_transform * qcms_modular_transform_create_lut ( struct lutType * lut ) {\n<10> transform -> matrix = build_lut_matrix ( lut ) ;\n<14> if ( ! transform ) goto fail ;\n<16> in_curve_len = sizeof ( float ) * lut -> num_input_table_entries * 3 ;\n<17> in_curves = malloc ( in_curve_len ) ;\n<18> if ( ! in_curves ) goto fail ;\n<19> memcpy ( in_curves , lut -> input_table , in_curve_len ) ;\n<20> transform -> input_clut_table_r = in_curves + lut -> num_input_table_entries * 0 ;\n<21> transform -> input_clut_table_g = in_curves + lut -> num_input_table_entries * 1 ;\n<22> transform -> input_clut_table_b = in_curves + lut -> num_input_table_entries * 2 ;\n<24> clut_length = sizeof ( float ) * pow ( lut -> num_clut_grid_points , 3 ) * 3 ;\n<25> clut = malloc ( clut_length ) ;\n<26> if ( ! clut ) goto fail ;\n<27> memcpy ( clut , lut -> clut_table , clut_length ) ;\n<28> transform -> r_clut = clut + 0 ;\n<29> transform -> g_clut = clut + 1 ;\n<30> transform -> b_clut = clut + 2 ;\n<32> out_curve_len = sizeof ( float ) * lut -> num_output_table_entries * 3 ;\n<33> out_curves = malloc ( out_curve_len ) ;\n<34> if ( ! out_curves ) goto fail ;\n<35> memcpy ( out_curves , lut -> output_table , out_curve_len ) ;\n<36> transform -> output_clut_table_r = out_curves + lut -> num_output_table_entries * 0 ;\n<37> transform -> output_clut_table_g = out_curves + lut -> num_output_table_entries * 1 ;\n<38> transform -> output_clut_table_b = out_curves + lut -> num_output_table_entries * 2 ;
<1> static void gst_asf_demux_release_old_pads ( GstASFDemux * demux ) {\n<2> GST_DEBUG_OBJECT ( demux , "Releasing old pads" ) ;\n<4> gst_pad_push_event ( demux -> old_stream [ demux -> old_num_streams - 1 ] . pad , gst_event_new_eos ( ) ) ;\n<5> gst_asf_demux_free_stream ( demux , & demux -> old_stream [ demux -> old_num_streams - 1 ] ) ;\n<8> memset ( demux -> old_stream , 0 , sizeof ( demux -> old_stream ) ) ;
<1> static int rtmp_open(URLContext *s, const char *uri, int flags)\n<5> RTMPContext *rt = s->priv_data;\n<23> rt->listen = 1;\n<31> av_url_split(proto, sizeof(proto), auth, sizeof(auth),\n<39> if (strchr(path, ' ')) {\n<53> if (auth[0]) {\n<55> char *ptr = strchr(auth, ':');\n<61> av_strlcpy(rt->username, auth, sizeof(rt->username));\n<63> av_strlcpy(rt->password, ptr + 1, sizeof(rt->password));\n<71> if (rt->listen && strcmp(proto, "rtmp")) {\n<73> av_log(s, AV_LOG_ERROR, "rtmp_listen not available for %s\n",\n<77> return AVERROR(EINVAL);\n<81> if (!strcmp(proto, "rtmpt") || !strcmp(proto, "rtmpts")) {\n<83> if (!strcmp(proto, "rtmpts"))\n<85> av_dict_set(&opts, "ffrtmphttp_tls", "1", 1);\n<91> ff_url_join(buf, sizeof(buf), "ffrtmphttp", NULL, hostname, port, NULL);\n<93> } else if (!strcmp(proto, "rtmps")) {\n<97> if (port < 0)\n<101> ff_url_join(buf, sizeof(buf), "tls", NULL, hostname, port, NULL);\n<103> } else if (!strcmp(proto, "rtmpe") || (!strcmp(proto, "rtmpte"))) {\n<105> if (!strcmp(proto, "rtmpte"))\n<107> av_dict_set(&opts, "ffrtmpcrypt_tunneling", "1", 1);\n<113> ff_url_join(buf, sizeof(buf), "ffrtmpcrypt", NULL, hostname, port, NULL);\n<115> rt->encrypted = 1;\n<121> if (port < 0)\n<125> if (rt->listen)\n<143> if ((ret = ffurl_open(&rt->stream, buf, AVIO_FLAG_READ_WRITE,\n<145> &s->interrupt_callback, &opts)) < 0) {\n<167> if (!rt->listen && (ret = rtmp_handshake(s, rt)) < 0)\n<171> if (rt->listen && (ret = rtmp_server_handshake(s, rt)) < 0)\n<187> old_app = rt->app;\n<191> rt->app = av_malloc(APP_MAX_LENGTH);\n<193> if (!rt->app) {\n<205> qmark = strchr(path, '?');\n<207> if (qmark && strstr(qmark, "slist=")) {\n<213> av_strlcpy(rt->app, path + 1, FFMIN(qmark - path, APP_MAX_LENGTH));\n<215> fname = strstr(path, "slist=") + 6;\n<219> amp = strchr(fname, '&');\n<221> if (amp) {\n<223> av_strlcpy(fname_buffer, fname, FFMIN(amp - fname + 1,\n<227> fname = fname_buffer;\n<231> } else if (!strncmp(path, "/ondemand/", 10)) {\n<233> fname = path + 10;\n<235> memcpy(rt->app, "ondemand", 9);\n<239> char *next = *path ? path + 1 : path;\n<241> char *p = strchr(next, '/');\n<243> if (!p) {\n<245> fname = next;\n<247> rt->app[0] = '\0';\n<253> char *c = strchr(p + 1, ':');\n<255> fname = strchr(p + 1, '/');\n<257> if (!fname || (c && c < fname)) {\n<259> fname = p + 1;\n<261> av_strlcpy(rt->app, path + 1, FFMIN(p - path, APP_MAX_LENGTH));\n<267> av_strlcpy(rt->app, path + 1, FFMIN(fname - path - 1, APP_MAX_LENGTH));\n<277> if (old_app) {\n<281> if (strlen(old_app) >= APP_MAX_LENGTH) {\n<283> ret = AVERROR(EINVAL);\n<289> av_free(rt->app);\n<291> rt->app = old_app;\n<297> if (!rt->playpath) {\n<299> int len = strlen(fname);\n<305> if (!rt->playpath) {\n<315> if (!strchr(fname, ':') && len >= 4 &&\n<317> (!strcmp(fname + len - 4, ".f4v") ||\n<319> !strcmp(fname + len - 4, ".mp4"))) {\n<321> memcpy(rt->playpath, "mp4:", 5);\n<325> if (len >= 4 && !strcmp(fname + len - 4, ".flv"))\n<327> fname[len - 4] = '\0';\n<329> rt->playpath[0] = 0;\n<333> av_strlcat(rt->playpath, fname, PLAYPATH_MAX_LENGTH);\n<351> ff_url_join(rt->tcurl, TCURL_MAX_LENGTH, proto, NULL, hostname,\n<407> av_log(s, AV_LOG_DEBUG, "Proto = %s, path = %s, app = %s, fname = %s\n",\n<413> if ((ret = gen_connect(s, rt)) < 0)\n<451> for (i = 0; i < 2; i++)\n<455> sizeof(**rt->prev_pkt) * rt->nb_prev_pkt[i]);\n<457> free_tracked_methods(rt);\n<473> if ((err = av_reallocp(&rt->flv_data, rt->flv_size)) < 0)\n<479> memcpy(rt->flv_data, "FLV\1\0\0\0\0\011\0\0\0\0", rt->flv_size);\n<545> av_dict_free(&opts);\n<547> rtmp_close(s);\n<549> return ret;
<1> static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n<11> if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET || elem->out_num != 3 ||\n<23> memset(n->mac_table.macs, 0, MAC_TABLE_ENTRIES * ETH_ALEN);\n<27> mac_data.entries = ldl_le_p(elem->out_sg[1].iov_base);\n<39> if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n<41> memcpy(n->mac_table.macs, elem->out_sg[1].iov_base + sizeof(mac_data),\n<43> mac_data.entries * ETH_ALEN);\n<57> mac_data.entries = ldl_le_p(elem->out_sg[2].iov_base);\n<71> if (n->mac_table.in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n<73> memcpy(n->mac_table.macs + (n->mac_table.in_use * ETH_ALEN),\n<77> mac_data.entries * ETH_ALEN);
<1> static int string_print ( PyStringObject * op , FILE * fp , int flags ) {\n<5> if ( ! PyString_CheckExact ( op ) ) {\n<27> if ( memchr ( op -> ob_sval , '\'' , Py_SIZE ( op ) ) && ! memchr ( op -> ob_sval , '"' , Py_SIZE ( op ) ) ) quote = '"' ;\n<28> str_len = Py_SIZE ( op ) ;\n<34> if ( c == quote || c == '\\' ) fprintf ( fp , "\\%c" , c ) ;\n<35> else if ( c == '\t' ) fprintf ( fp , "\\t" ) ;\n<36> else if ( c == '\n' ) fprintf ( fp , "\\n" ) ;\n<37> else if ( c == '\r' ) fprintf ( fp , "\\r" ) ;\n<38> else if ( c < ' ' || c >= 0x7f ) fprintf ( fp , "\\x%02x" , c & 0xff ) ;\n<39> else fputc ( c , fp ) ;\n<41> fputc ( quote , fp ) ;
<1> av_cold int ff_psy_init(FFPsyContext *ctx, AVCodecContext *avctx, int num_lens,\n<3> const uint8_t **bands, const int* num_bands,\n<19> ctx->bands     = av_malloc_array (sizeof(ctx->bands[0]),      num_lens);\n<21> ctx->num_bands = av_malloc_array (sizeof(ctx->num_bands[0]),  num_lens);\n<26> if (!ctx->ch || !ctx->group || !ctx->bands || !ctx->num_bands) {\n<36> memcpy(ctx->bands,     bands,     sizeof(ctx->bands[0])     *  num_lens);\n<38> memcpy(ctx->num_bands, num_bands, sizeof(ctx->num_bands[0]) *  num_lens);\n<76> return ctx->model->init(ctx);
<1> static int fetch_description ( char * line , void * data ) {\n<5> if ( ! line ) return 0 ;\n<6> desc = strpbrk ( line , " \t" ) ;\n<7> if ( desc ) {\n<8> * desc ++ = '\0' ;\n<9> desc += strspn ( desc , " \t" ) ;\n<11> else desc = strchr ( line , '\0' ) ;\n<12> nntp_data = mutt_hash_find ( nserv -> groups_hash , line ) ;\n<13> if ( nntp_data && ( mutt_str_strcmp ( desc , nntp_data -> desc ) != 0 ) ) {\n<14> mutt_str_replace ( & nntp_data -> desc , desc ) ;
<1> static int read_motion_values ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b ) {\n<4> CHECK_READ_VAL ( gb , b , t ) ;\n<10> if ( get_bits1 ( gb ) ) {\n<11> v = get_bits ( gb , 4 ) ;\n<14> v = ( v ^ sign ) - sign ;\n<16> memset ( b -> cur_dec , v , t ) ;\n<17> b -> cur_dec += t ;
<1> static Int decUnitCompare ( const Unit * a , Int alength , const Unit * b , Int blength , Int exp ) {\n<27> if ( need * sizeof ( Unit ) > sizeof ( accbuff ) ) {\n<28> allocacc = ( Unit * ) malloc ( need * sizeof ( Unit ) ) ;\n<29> if ( allocacc == NULL ) return BADINT ;\n<42> if ( allocacc != NULL ) free ( allocacc ) ;
<1> VAR * var_init ( VAR * v , const char * name , int name_len , const char * val , int val_len ) {\n<4> if ( ! name_len && name ) name_len = strlen ( name ) ;\n<5> if ( ! val_len && val ) val_len = strlen ( val ) ;\n<6> if ( ! val ) val_len = 0 ;\n<7> val_alloc_len = val_len + 16 ;\n<8> if ( ! ( tmp_var = v ) && ! ( tmp_var = ( VAR * ) my_malloc ( sizeof ( * tmp_var ) + name_len + 2 , MYF ( MY_WME ) ) ) ) die ( "Out of memory" ) ;\n<9> if ( name != NULL ) {\n<11> memcpy ( tmp_var -> name , name , name_len ) ;\n<16> if ( ! ( tmp_var -> str_val = ( char * ) my_malloc ( val_alloc_len + 1 , MYF ( MY_WME ) ) ) ) die ( "Out of memory" ) ;\n<17> if ( val ) memcpy ( tmp_var -> str_val , val , val_len ) ;\n<19> var_check_int ( tmp_var ) ;\n<20> tmp_var -> name_len = name_len ;\n<21> tmp_var -> str_val_len = val_len ;\n<23> return tmp_var ;
<1> static ssize_t gem_receive(VLANClientState *nc, const uint8_t *buf, size_t size)\n<15> uint8_t    rxbuf[2048];\n<37> if (gem_mac_address_filter(s, buf) == GEM_RX_REJECT) {\n<55> type_len = buf[12] << 8 | buf[13];\n<61> if (size < type_len) {\n<103> if (s->regs[GEM_NWCFG] & GEM_NWCFG_STRIP_FCS) {\n<123> memcpy(rxbuf, buf, size);\n<125> memset(rxbuf + size, 0, sizeof(rxbuf - size));\n<129> crc_val = cpu_to_le32(crc32(0, rxbuf, MAX(size, 60)));\n<133> crc_offset = 60;\n<137> crc_offset = size;\n<141> memcpy(rxbuf + crc_offset, &crc_val, sizeof(crc_val));\n<301> gem_receive_updatestats(s, buf, size);
<1> fz_xml * xps_lookup_alternate_content ( fz_xml * node ) {\n<3> node ;\n<4> node = fz_xml_next ( node ) ) {\n<5> if ( ! strcmp ( fz_xml_tag ( node ) , "mc:Choice" ) && fz_xml_att ( node , "Requires" ) ) {\n<6> char list [ 64 ] ;\n<7> char * next = list , * item ;\n<8> fz_strlcpy ( list , fz_xml_att ( node , "Requires" ) , sizeof ( list ) ) ;\n<9> while ( ( item = fz_strsep ( & next , " \t\r\n" ) ) != NULL && ( ! * item || ! strcmp ( item , "xps" ) ) ) ;\n<10> if ( ! item ) return fz_xml_down ( node ) ;\n<12> else if ( ! strcmp ( fz_xml_tag ( node ) , "mc:Fallback" ) ) return fz_xml_down ( node ) ;
<1> static int decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)\n<35> if (!s->profile)\n<37> memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_epel_pixels_tab, sizeof(s->put_pixels_tab));\n<41> memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_bilinear_pixels_tab, sizeof(s->put_pixels_tab));\n<57> if (AV_RL24(buf) != 0x2a019d) {\n<89> for (j = 0; j < 16; j++)\n<91> memcpy(s->prob->token[i][j], vp8_token_default_probs[i][vp8_coeff_band[j]],\n<95> memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter, sizeof(s->prob->pred16x16));\n<97> memcpy(s->prob->pred8x8c , vp8_pred8x8c_prob_inter , sizeof(s->prob->pred8x8c));\n<99> memcpy(s->prob->mvc      , vp8_mv_default_prob     , sizeof(s->prob->mvc));\n<101> memset(&s->segmentation, 0, sizeof(s->segmentation));\n<111> if ((ret = update_dimensions(s, width, height)) < 0)\n<141> parse_segment_info(s);\n<161> update_lf_deltas(s);\n<165> if (setup_partitions(s, buf, buf_size)) {\n<175> get_quants(s);\n<181> update_refs(s);
<1> static int aac_encode_frame(AVCodecContext *avctx,\n<3> uint8_t *frame, int buf_size, void *data)\n<7> AACEncContext *s = avctx->priv_data;\n<29> if (!s->psypp) {\n<31> memcpy(s->samples + 1024 * avctx->channels, data,\n<33> 1024 * avctx->channels * sizeof(s->samples[0]));\n<59> if (!avctx->frame_number) {\n<61> memcpy(s->samples, s->samples + 1024 * avctx->channels,\n<63> 1024 * avctx->channels * sizeof(s->samples[0]));\n<87> if (!data)\n<121> apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2, j);\n<133> put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);\n<137> memset(chan_el_counter, 0, sizeof(chan_el_counter));\n<185> adjust_frame_information(s, cpe, chans);\n<189> put_bits(&s->pb, 4, chan_el_counter[tag]++);\n<197> put_ics_info(s, &cpe->ch[0].ics);\n<211> encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window);\n<251> if (!data)\n<255> memcpy(s->samples, s->samples + 1024 * avctx->channels,\n<257> 1024 * avctx->channels * sizeof(s->samples[0]));
<1> static int integratorcm_init(SysBusDevice *dev)\n<19> integrator_spd[31] = 64;\n<25> integrator_spd[31] = 32;\n<31> integrator_spd[31] = 16;\n<37> integrator_spd[31] = 4;\n<43> integrator_spd[31] = 2;\n<47> memcpy(integrator_spd + 73, "QEMU-MEMORY", 11);
<1> static int matroska_parse_rm_audio ( MatroskaDemuxContext * matroska , MatroskaTrack * track , AVStream * st , uint8_t * data , int size , uint64_t timecode , uint64_t duration , int64_t pos ) {\n<17> x < h / 2 ;\n<18> x ++ ) memcpy ( track -> audio . buf + x * 2 * w + y * cfs , data + x * cfs , cfs ) ;\n<21> if ( size < w ) {\n<25> memcpy ( track -> audio . buf + y * w , data , w ) ;\n<33> x < w / sps ;\n<34> x ++ ) memcpy ( track -> audio . buf + sps * ( h * x + ( ( h + 1 ) / 2 ) * ( y & 1 ) + ( y >> 1 ) ) , data + x * sps , sps ) ;\n<37> if ( st -> codec -> codec_id == AV_CODEC_ID_SIPR ) ff_rm_reorder_sipr_data ( track -> audio . buf , h , w ) ;\n<39> track -> audio . pkt_cnt = h * w / a ;\n<45> if ( ! pkt ) return AVERROR ( ENOMEM ) ;\n<46> ret = av_new_packet ( pkt , a ) ;\n<47> if ( ret < 0 ) {\n<48> av_free ( pkt ) ;\n<51> memcpy ( pkt -> data , track -> audio . buf + a * ( h * w / a - track -> audio . pkt_cnt -- ) , a ) ;\n<56> dynarray_add ( & matroska -> packets , & matroska -> num_packets , pkt ) ;
<1> static void monitor_find_completion(Monitor *mon,\n<21> parse_cmdline(cmdline, &nb_args, args);\n<39> len = strlen(cmdline);\n<41> if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n<53> if (nb_args <= 1) {\n<59> cmdname = "";\n<63> cmdname = args[0];\n<65> readline_set_completion_index(mon->rs, strlen(cmdname));\n<69> cmd_completion(mon, cmdname, cmd->name);\n<77> for (cmd = mon->cmd_table; cmd->name != NULL; cmd++) {\n<87> if (!cmd->name) {\n<111> str = args[nb_args - 1];\n<119> switch(*ptype) {\n<125> readline_set_completion_index(mon->rs, strlen(str));\n<127> file_completion(mon, str);\n<139> readline_set_completion_index(mon->rs, strlen(str));\n<149> if (!strcmp(cmd->name, "info")) {\n<151> readline_set_completion_index(mon->rs, strlen(str));\n<153> for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n<155> cmd_completion(mon, str, cmd->name);\n<159> } else if (!strcmp(cmd->name, "sendkey")) {\n<161> char *sep = strrchr(str, '-');\n<163> if (sep)\n<165> str = sep + 1;\n<167> readline_set_completion_index(mon->rs, strlen(str));\n<169> for (i = 0; i < Q_KEY_CODE_MAX; i++) {\n<171> cmd_completion(mon, str, QKeyCode_lookup[i]);\n<175> } else if (!strcmp(cmd->name, "help|?")) {\n<177> readline_set_completion_index(mon->rs, strlen(str));\n<179> for (cmd = mon->cmd_table; cmd->name != NULL; cmd++) {\n<181> cmd_completion(mon, str, cmd->name);
<1> void hmp_sendkey(Monitor *mon, const QDict *qdict)\n<5> const char *keys = qdict_get_str(qdict, "keys");\n<25> separator = strchr(keys, '-');\n<27> keyname_len = separator ? separator - keys : strlen(keys);\n<29> pstrcpy(keyname_buf, sizeof(keyname_buf), keys);\n<103> if (!separator) {\n<109> keys = separator + 1;
<1> static bool GetQueryResult ( PGconn * conn , const char * progname ) {\n<4> while ( ( result = PQgetResult ( conn ) ) != NULL ) {\n<5> if ( PQresultStatus ( result ) != PGRES_COMMAND_OK ) {\n<6> char * sqlState = PQresultErrorField ( result , PG_DIAG_SQLSTATE ) ;\n<7> fprintf ( stderr , _ ( "%s: vacuuming of database \"%s\" failed: %s" ) , progname , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;\n<8> if ( sqlState && strcmp ( sqlState , ERRCODE_UNDEFINED_TABLE ) != 0 ) {\n<9> PQclear ( result ) ;\n<10> return false ;\n<13> PQclear ( result ) ;
<1> static cmsBool Type_Text_Description_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n<8> memset ( Filler , 0 , sizeof ( Filler ) ) ;\n<10> if ( len <= 0 ) {\n<11> Text = ( char * ) _cmsDupMem ( self -> ContextID , "" , sizeof ( char ) ) ;\n<18> if ( Wide == NULL ) goto Error ;\n<19> cmsMLUgetASCII ( mlu , cmsNoLanguage , cmsNoCountry , Text , len * sizeof ( char ) ) ;\n<22> len_text = ( cmsUInt32Number ) strlen ( Text ) + 1 ;\n<23> len_tag_requirement = ( 8 + 4 + len_text + 4 + 4 + 2 * len_text + 2 + 1 + 67 ) ;\n<26> if ( ! io -> Write ( io , len_text , Text ) ) goto Error ;\n<32> if ( ! io -> Write ( io , 67 , Filler ) ) goto Error ;\n<35> Error : if ( Text ) _cmsFree ( self -> ContextID , Text ) ;
<1> static gcry_err_code_t sexp_elements_extract ( gcry_sexp_t key_sexp , const char * element_names , gcry_mpi_t * elements , const char * algo_name , int opaque ) {\n<26> if ( * name ) {\n<28> if ( algo_name && ! strcmp ( algo_name , "RSA" ) && ! strcmp ( element_names , "nedpqu" ) ) {\n<29> if ( elements [ 0 ] && elements [ 1 ] && elements [ 2 ] && ! elements [ 3 ] && ! elements [ 4 ] && ! elements [ 5 ] ) err = 0 ;
<1> static void EncSchroFrameFree ( SchroFrame * frame , void * priv ) {\n<3> if ( ! p_free ) return ;\n<4> picture_Release ( p_free -> p_pic ) ;\n<5> free ( p_free ) ;
<1> static int qemuAgentGuestSync ( qemuAgentPtr mon ) {\n<6> memset ( & sync_msg , 0 , sizeof ( sync_msg ) ) ;\n<7> sync_msg . first = true ;\n<16> sync_msg . id = id ;\n<18> send_ret = qemuAgentSend ( mon , & sync_msg , VIR_DOMAIN_QEMU_AGENT_COMMAND_DEFAULT ) ;\n<21> if ( ! sync_msg . rxObject ) {\n<22> if ( sync_msg . first ) {\n<23> VIR_FREE ( sync_msg . txBuffer ) ;\n<24> memset ( & sync_msg , 0 , sizeof ( sync_msg ) ) ;\n<34> cleanup : virJSONValueFree ( sync_msg . rxObject ) ;\n<35> VIR_FREE ( sync_msg . txBuffer ) ;
<1> static void ppc_spapr_init(QEMUMachineInitArgs *args)\n<161> if (cpu == NULL) {\n<163> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<317> for (i = 0; i < nb_nics; i++) {\n<319> NICInfo *nd = &nd_table[i];\n<323> if (!nd->model) {\n<325> nd->model = g_strdup("ibmveth");\n<331> if (strcmp(nd->model, "ibmveth") == 0) {\n<333> spapr_vlan_create(spapr->vio_bus, nd);\n<337> pci_nic_init_nofail(&nd_table[i], nd->model, NULL);\n<379> if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n<381> fprintf(stderr, "qemu: pSeries SLOF firmware requires >= "\n<397> kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n<411> if (kernel_size < 0) {\n<413> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<435> initrd_size = load_image_targphys(initrd_filename, initrd_base,\n<439> if (initrd_size < 0) {\n<441> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",
<1> static void pk_transaction_search_groups ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n<16> ret = pk_transaction_search_check ( values , & error ) ;\n<22> values [ i ] != NULL ;\n<23> i ++ ) {\n<24> if ( strstr ( values [ i ] , " " ) != NULL ) {\n<25> g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_SEARCH_INVALID , "Invalid search containing spaces" ) ;\n<26> pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;
<1> static int wb_write_to_temp ( struct archive_write * a , const void * buff , size_t s ) {\n<2> const char * xp = buff ;\n<10> xp += s - xs ;\n<12> while ( xs ) {\n<14> if ( size > wb_remaining ( a ) ) size = wb_remaining ( a ) ;\n<15> memcpy ( wb_buffptr ( a ) , xp , size ) ;\n<16> if ( wb_consume ( a , size ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n<18> xp += size ;
<1> int evdns_server_request_add_reply ( struct evdns_server_request * _req , int section , const char * name , int type , int class , int ttl , int datalen , int is_name , const char * data ) {\n<6> switch ( section ) {\n<21> item = malloc ( sizeof ( struct server_reply_item ) ) ;\n<22> if ( ! item ) return - 1 ;\n<23> item -> next = NULL ;\n<24> if ( ! ( item -> name = strdup ( name ) ) ) {\n<25> free ( item ) ;\n<26> return - 1 ;\n<28> item -> type = type ;\n<29> item -> dns_question_class = class ;\n<30> item -> ttl = ttl ;\n<31> item -> is_name = is_name != 0 ;\n<32> item -> datalen = 0 ;\n<33> item -> data = NULL ;\n<34> if ( data ) {\n<35> if ( item -> is_name ) {\n<36> if ( ! ( item -> data = strdup ( data ) ) ) {\n<37> free ( item -> name ) ;\n<38> free ( item ) ;\n<39> return - 1 ;\n<41> item -> datalen = ( u16 ) - 1 ;\n<44> if ( ! ( item -> data = malloc ( datalen ) ) ) {\n<45> free ( item -> name ) ;\n<46> free ( item ) ;\n<47> return - 1 ;\n<49> item -> datalen = datalen ;\n<50> memcpy ( item -> data , data , datalen ) ;\n<53> * itemp = item ;\n<54> ++ ( * countp ) ;\n<55> return 0 ;
<1> static int git_pack_config ( const char * k , const char * v , void * cb ) {\n<2> if ( ! strcmp ( k , "pack.window" ) ) {\n<3> window = git_config_int ( k , v ) ;\n<4> return 0 ;\n<6> if ( ! strcmp ( k , "pack.windowmemory" ) ) {\n<7> window_memory_limit = git_config_ulong ( k , v ) ;\n<8> return 0 ;\n<10> if ( ! strcmp ( k , "pack.depth" ) ) {\n<11> depth = git_config_int ( k , v ) ;\n<12> return 0 ;\n<14> if ( ! strcmp ( k , "pack.compression" ) ) {\n<15> int level = git_config_int ( k , v ) ;\n<16> if ( level == - 1 ) level = Z_DEFAULT_COMPRESSION ;\n<18> pack_compression_level = level ;\n<19> pack_compression_seen = 1 ;\n<20> return 0 ;\n<22> if ( ! strcmp ( k , "pack.deltacachesize" ) ) {\n<23> max_delta_cache_size = git_config_int ( k , v ) ;\n<24> return 0 ;\n<26> if ( ! strcmp ( k , "pack.deltacachelimit" ) ) {\n<27> cache_max_small_delta_size = git_config_int ( k , v ) ;\n<28> return 0 ;\n<30> if ( ! strcmp ( k , "pack.writebitmaphashcache" ) ) {\n<31> if ( git_config_bool ( k , v ) ) write_bitmap_options |= BITMAP_OPT_HASH_CACHE ;\n<34> if ( ! strcmp ( k , "pack.usebitmaps" ) ) {\n<35> use_bitmap_index = git_config_bool ( k , v ) ;\n<36> return 0 ;\n<38> if ( ! strcmp ( k , "pack.threads" ) ) {\n<39> delta_search_threads = git_config_int ( k , v ) ;\n<40> if ( delta_search_threads < 0 ) die ( "invalid number of threads specified (%d)" , delta_search_threads ) ;\n<44> if ( ! strcmp ( k , "pack.indexversion" ) ) {\n<45> pack_idx_opts . version = git_config_int ( k , v ) ;\n<47> return 0 ;\n<49> return git_default_config ( k , v , cb ) ;
<1> envlist_setenv(envlist_t *envlist, const char *env)\n<13> if ((envlist == NULL) || (env == NULL))\n<21> if ((eq_sign = strchr(env, '=')) == NULL)\n<23> return (EINVAL);\n<25> envname_len = eq_sign - env + 1;\n<39> for (entry = envlist->el_entries.lh_first; entry != NULL;\n<43> if (strncmp(entry->ev_var, env, envname_len) == 0)\n<51> if (entry != NULL) {\n<53> QLIST_REMOVE(entry, ev_link);\n<55> free((char *)entry->ev_var);\n<57> free(entry);\n<67> if ((entry = malloc(sizeof (*entry))) == NULL)\n<69> return (errno);\n<71> if ((entry->ev_var = strdup(env)) == NULL) {\n<73> free(entry);\n<75> return (errno);\n<79> QLIST_INSERT_HEAD(&envlist->el_entries, entry, ev_link);\n<83> return (0);
<1> static ssize_t nic_receive(VLANClientState *nc, const uint8_t * buf, size_t size)\n<59> } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & BIT(3))) {\n<69> } else if (memcmp(buf, s->conf.macaddr.a, 6) == 0) {       /* !!! */\n<75> TRACE(RXTX, logout("%p received frame for me, len=%zu\n", s, size));\n<77> } else if (memcmp(buf, broadcast_macaddr, 6) == 0) {\n<81> TRACE(RXTX, logout("%p received broadcast, len=%zu\n", s, size));\n<83> rfd_status |= 0x0002;\n<85> } else if (buf[0] & 0x01) {\n<89> TRACE(RXTX, logout("%p received multicast, len=%zu,%s\n", s, size, nic_dump(buf, size)));\n<137> nic_dump(buf, size)));\n<145> if (get_ru_state(s) != ru_ready) {\n<233> cpu_physical_memory_write(s->ru_base + s->ru_offset +
<1> static void output ( FILE * fp , const char * name , const char * value ) {\n<3> len = strlen ( name ) + 1 + strlen ( value ) ;\n<6> if ( ( out_linecount + len + 2 ) > MAXOUTLINE ) {\n<15> fputs ( name , fp ) ;\n<17> fputs ( value , fp ) ;\n<18> out_chars += len ;\n<19> out_linecount += len ;
<1> int test_div ( BIO * bp , BN_CTX * ctx ) {\n<43> if ( ! BN_is_zero ( & d ) ) {\n<44> fprintf ( stderr , "Division test failed!\n" ) ;
<1> static inline void vmsvga_fill_rect(struct vmsvga_state_s *s,\n<11> int width = surface_bytes_per_pixel(surface) * w;\n<37> fst = s->vga.vram_ptr + surface_bytes_per_pixel(surface) * x + bypl * y;\n<61> for (; line > 0; line--) {\n<63> dst += bypl;\n<65> memcpy(dst, fst, width);
<1> static void vmsErrorHandler ( const char * module , const char * fmt , va_list ap ) {\n<2> if ( module != NULL ) fprintf ( stderr , "%s: " , module ) ;\n<3> vfprintf ( stderr , fmt , ap ) ;\n<4> fprintf ( stderr , ".\n" ) ;
<1> av_cold int ffv1_init_slice_contexts(FFV1Context *f)\n<6> for (i = 0; i < f->slice_count; i++) {\n<7> FFV1Context *fs = av_mallocz(sizeof(*fs));\n<8> int sx          = i % f->num_h_slices;\n<9> int sy          = i / f->num_h_slices;\n<10> int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n<11> int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n<12> int sys         = f->avctx->height *  sy      / f->num_v_slices;\n<13> int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n<14> f->slice_context[i] = fs;\n<15> memcpy(fs, f, sizeof(*fs));\n<16> memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n<17> fs->slice_width  = sxe - sxs;\n<18> fs->slice_height = sye - sys;\n<19> fs->slice_x      = sxs;\n<20> fs->slice_y      = sys;\n<21> fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *
<133> if (r == -EIO && !(dev->features & ASSIGNED_DEVICE_PREFER_MSI_MASK) &&\n<153> error_report("Failed to assign irq for \"%s\": %s",\n<155> dev->dev.qdev.id, strerror(-r));
<1> static void test_fetch_column ( ) {\n<4> char c2 [ 20 ] , bc2 [ 20 ] ;\n<16> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<29> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<37> if ( ! opt_silent ) fprintf ( stdout , "\n row 0: %d, %s" , bc1 , bc2 ) ;\n<38> c2 [ 0 ] = '\0' ;\n<39> l2 = 0 ;\n<47> if ( ! opt_silent ) fprintf ( stdout , "\n col 1: %s(%ld)" , c2 , l2 ) ;\n<48> DIE_UNLESS ( strncmp ( c2 , "venu" , 4 ) == 0 && l2 == 4 ) ;\n<49> c2 [ 0 ] = '\0' ;\n<50> l2 = 0 ;\n<53> if ( ! opt_silent ) fprintf ( stdout , "\n col 1: %s(%ld)" , c2 , l2 ) ;\n<54> DIE_UNLESS ( strcmp ( c2 , "venu" ) == 0 && l2 == 4 ) ;\n<55> c1 = 0 ;\n<63> if ( ! opt_silent ) fprintf ( stdout , "\n col 0: %d(%ld)" , c1 , l1 ) ;\n<64> DIE_UNLESS ( c1 == 1 && l1 == 4 ) ;\n<67> if ( ! opt_silent ) fprintf ( stdout , "\n row 1: %d, %s" , bc1 , bc2 ) ;\n<68> c2 [ 0 ] = '\0' ;\n<69> l2 = 0 ;\n<71> my_bind [ 0 ] . buffer = ( void * ) c2 ;\n<77> if ( ! opt_silent ) fprintf ( stdout , "\n col 1: %s(%ld)" , c2 , l2 ) ;\n<78> DIE_UNLESS ( strncmp ( c2 , "mysq" , 4 ) == 0 && l2 == 5 ) ;\n<79> c2 [ 0 ] = '\0' ;\n<80> l2 = 0 ;\n<83> if ( ! opt_silent ) fprintf ( stdout , "\n col 1: %si(%ld)" , c2 , l2 ) ;\n<84> DIE_UNLESS ( strcmp ( c2 , "mysql" ) == 0 && l2 == 5 ) ;\n<85> c1 = 0 ;\n<90> my_bind [ 0 ] . length = & l1 ;\n<93> if ( ! opt_silent ) fprintf ( stdout , "\n col 0: %d(%ld)" , c1 , l1 ) ;\n<94> DIE_UNLESS ( c1 == 2 && l1 == 4 ) ;
<1> matroska_read_header (AVFormatContext    *s,\n<25> if ((res = ebml_read_header(matroska, &doctype, &version)) < 0)\n<29> if ((doctype == NULL) || strcmp(doctype, "matroska")) {\n<31> av_log(matroska->ctx, AV_LOG_ERROR,\n<35> doctype ? doctype : "(none)");\n<37> if (doctype)\n<39> av_free(doctype);\n<41> return AVERROR_NOFMT;\n<45> av_free(doctype);\n<47> if (version > 2) {\n<301> int extradata_offset = 0;\n<303> track = matroska->tracks[i];\n<305> track->stream_index = -1;\n<311> if (track->codec_id == NULL)\n<317> for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n<319> if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n<321> strlen(ff_mkv_codec_tags[j].str))){\n<343> (track->codec_priv_size >= 40) &&\n<345> (track->codec_priv != NULL)) {\n<347> MatroskaVideoTrack *vtrack = (MatroskaVideoTrack *) track;\n<353> vtrack->fourcc = AV_RL32(track->codec_priv + 16);\n<355> codec_id = codec_get_id(codec_bmp_tags, vtrack->fourcc);\n<367> else if (!strcmp(track->codec_id,\n<371> (track->codec_priv_size >= 18) &&\n<373> (track->codec_priv != NULL)) {\n<381> tag = AV_RL16(track->codec_priv);\n<383> codec_id = codec_get_id(codec_wav_tags, tag);\n<391> else if (codec_id == CODEC_ID_AAC && !track->codec_priv_size) {\n<393> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;\n<395> int profile = matroska_aac_profile(track->codec_id);\n<401> if (extradata == NULL)\n<409> if (strstr(track->codec_id, "SBR")) {\n<411> sri = matroska_aac_sri(audiotrack->samplerate);\n<413> extradata[2] = 0x56;\n<415> extradata[3] = 0xE5;\n<417> extradata[4] = 0x80 | (sri<<3);\n<419> extradata_size = 5;\n<423> extradata_size = 2;\n<433> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;\n<469> extradata_offset = 26;\n<471> track->codec_priv_size -= extradata_offset;\n<479> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n<495> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n<501> init_put_byte(&b, track->codec_priv, track->codec_priv_size, 0,\n<523> track->codec_priv_size = 0;\n<529> extradata_offset = 78;\n<531> track->codec_priv_size -= extradata_offset;\n<539> if (codec_id == CODEC_ID_NONE) {\n<551> track->stream_index = matroska->num_streams;\n<555> matroska->num_streams++;\n<557> st = av_new_stream(s, track->stream_index);\n<559> if (st == NULL)\n<571> if (strcmp(track->language, "und"))\n<573> strcpy(st->language, track->language);\n<577> if (track->flags & MATROSKA_TRACK_DEFAULT)\n<585> av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,\n<597> } else if(track->codec_priv && track->codec_priv_size > 0){\n<599> st->codec->extradata = av_malloc(track->codec_priv_size);\n<601> if(st->codec->extradata == NULL)\n<605> st->codec->extradata_size = track->codec_priv_size;\n<607> memcpy(st->codec->extradata,track->codec_priv+extradata_offset,\n<615> if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n<617> MatroskaVideoTrack *videotrack = (MatroskaVideoTrack *)track;\n<649> } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n<651> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n<663> } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {
<1> static int qemuMonitorTextParseBlockJob ( const char * text , const char * device , virDomainBlockJobInfoPtr info ) {\n<4> if ( strstr ( text , "Device '" ) && strstr ( text , "' not found" ) ) {\n<5> qemuReportError ( VIR_ERR_OPERATION_INVALID , "%s" , _ ( "Device not found" ) ) ;\n<6> return - 1 ;\n<8> if ( strstr ( text , "Device '" ) && strstr ( text , "' is in use" ) ) {\n<9> qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( "Device %s in use" ) , device ) ;\n<10> return - 1 ;\n<12> if ( strstr ( text , "has not been activated" ) ) {\n<13> qemuReportError ( VIR_ERR_OPERATION_INVALID , \ _ ( "No active operation on device: %s" ) , device ) ;\n<14> return - 1 ;\n<16> if ( strstr ( text , "No active jobs" ) ) {\n<17> return 0 ;\n<19> if ( strstr ( text , "Operation is not supported" ) ) {\n<20> qemuReportError ( VIR_ERR_OPERATION_INVALID , _ ( "Operation is not supported for device: %s" ) , device ) ;\n<21> return - 1 ;\n<23> if ( STREQ ( text , "" ) ) return 0 ;
<1> static int qdm2_decode_init(AVCodecContext *avctx)\n<97> extradata = avctx->extradata;\n<103> while (extradata_size > 7) {\n<105> if (!memcmp(extradata, "frmaQDM", 7))\n<109> extradata++;\n<111> extradata_size--;\n<117> if (extradata_size < 12) {\n<129> if (memcmp(extradata, "frmaQDM", 7)) {\n<131> av_log(avctx, AV_LOG_ERROR, "invalid headers, QDM? not found\n");\n<133> return -1;\n<139> if (extradata[7] == 'C') {\n<151> extradata += 8;
<1> static void audio_init (void)\n<83> drvname = audio_get_conf_str ("QEMU_AUDIO_DRV", NULL, &def);\n<95> for (i = 0; i < ARRAY_SIZE (drvtab); i++) {\n<97> if (!strcmp (drvname, drvtab[i]->name)) {\n<99> done = !audio_driver_init (s, drvtab[i]);\n<101> found = 1;\n<113> dolog ("Unknown audio driver `%s'\n", drvname);\n<129> done = !audio_driver_init (s, drvtab[i]);
<1> av_cold int ff_dvvideo_init(AVCodecContext *avctx)\n<152> if (avctx->lowres){\n<164> memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);
<1> static void handle_windowevent(SDL_Event *ev)\n<8> memset(&info, 0, sizeof(info));\n<11> dpy_set_ui_info(scon->dcl.con, &info);
<1> static void show ( const char * format , ... ) {\n<3> if ( ! verbose ) return ;\n<4> fprintf ( stderr , "%s: " , PGM ) ;\n<6> vfprintf ( stderr , format , arg_ptr ) ;
<1> static int mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)\n<43> AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL, 0);\n<161> put16(&q, 0xe000 | ts_st->pid);\n<171> switch (st->codec->codec_type) {\n<237> if (st->codec->extradata && st->codec->extradata_size >= 19) {\n<239> if (st->codec->extradata[18] == 0 && st->codec->channels <= 2) {\n<243> *q++ = st->codec->channels;\n<245> } else if (st->codec->extradata[18] == 1 && st->codec->channels <= 8 &&\n<247> st->codec->extradata_size >= 21 + st->codec->channels) {\n<299> if (st->codec->extradata[19] == st->codec->channels - coupled_stream_counts[st->codec->channels] &&\n<301> st->codec->extradata[20] == coupled_stream_counts[st->codec->channels] &&\n<303> memcmp(&st->codec->extradata[21], channel_map_a[st->codec->channels], st->codec->channels) == 0) {\n<305> *q++ = st->codec->channels;\n<307> } else if (st->codec->channels >= 2 && st->codec->extradata[19] == st->codec->channels &&\n<309> st->codec->extradata[20] == 0 &&\n<311> memcmp(&st->codec->extradata[21], channel_map_b[st->codec->channels], st->codec->channels) == 0) {\n<313> *q++ = st->codec->channels | 0x80;\n<329> av_log(s, AV_LOG_ERROR, "Unsupported Opus channel mapping for family %d", st->codec->extradata[18]);\n<335> } else if (st->codec->channels <= 2) {\n<373> for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {\n<375> if (q - data > SECTION_LENGTH - 4) {\n<383> next = strchr(p, ',');\n<385> if (strlen(p) != 3 && (!next || next != p + 3))\n<391> *q++ = *p++;\n<393> *q++ = *p++;\n<395> *q++ = *p++;\n<399> if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)\n<417> *len_ptr += 4;\n<435> const char default_language[] = "und";\n<437> const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;\n<441> if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n<455> while (strlen(language) >= 3) {\n<457> if (sizeof(data) - (q - data) < 8) { /* 8 bytes per DVB subtitle substream data */\n<465> *q++ = *language++;\n<469> *q++ = *language++;\n<473> if (*language != '\0')\n<475> language++;\n<479> if (st->codec->extradata_size - extradata_copied >= 5) {\n<481> *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */\n<483> memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */\n<487> q += 4;\n<497> *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;\n<499> if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {\n<503> memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */\n<507> q += 4;\n<513> put16(&q, 1); /* ancillary_page_id */\n<525> } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {\n<541> while (strlen(language) >= 3 && q - data < sizeof(data) - 6) {\n<543> *q++ = *language++;\n<545> *q++ = *language++;\n<547> *q++ = *language++;\n<551> if (*language != '\0')\n<553> language++;\n<557> if (st->codec->extradata_size - 1 > extradata_copied) {\n<559> memcpy(q, st->codec->extradata + extradata_copied, 2);\n<563> q += 2;
<1> static void virtio_balloon_receive_stats(VirtIODevice *vdev, VirtQueue *vq)\n<61> if (qemu_gettimeofday(&tv) < 0) {\n<63> fprintf(stderr, "warning: %s: failed to get time of day\n", __func__);
<1> static void test_acpi_one(const char *params, test_data *data)\n<89> if (iasl) {\n<91> if (getenv(ACPI_REBUILD_EXPECTED_AML)) {\n<93> dump_aml_files(data, true);\n<97> test_acpi_asl(data);
<1> int stpcifc_service_call(S390CPU *cpu, uint8_t r1, uint64_t fiba, uint8_t ar)\n<45> if (!pbdev) {\n<55> memset(&fib, 0, sizeof(fib));\n<149> if (s390_cpu_virt_mem_write(cpu, fiba, ar, (uint8_t *)&fib, sizeof(fib))) {
<1> static int writev_f(int argc, char **argv)\n<27> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<73> offset = cvtnum(argv[optind]);\n<75> if (offset < 0) {\n<77> printf("non-numeric length argument -- %s\n", argv[optind]);\n<119> if (cnt < 0) {\n<121> printf("writev failed: %s\n", strerror(-cnt));
<1> Entity * EntityInterpretPS ( FILE * ps , int * width ) {\n<3> memset ( & ec , '\0' , sizeof ( ec ) ) ;\n<5> InterpretPS ( ps , NULL , & ec , NULL ) ;\n<6> if ( width != NULL ) * width = ec . width ;
<1> static void build_mc_border ( const uint8_t * src , int src_stride , uint8_t * dst , int dst_stride , int x , int y , int b_w , int b_h , int w , int h ) {\n<2> const uint8_t * ref_row = src - x - y * src_stride ;\n<3> if ( y >= h ) ref_row += ( h - 1 ) * src_stride ;\n<4> else if ( y > 0 ) ref_row += y * src_stride ;\n<7> int left = x < 0 ? - x : 0 ;\n<11> copy = b_w - left - right ;\n<12> if ( left ) memset ( dst , ref_row [ 0 ] , left ) ;\n<13> if ( copy ) memcpy ( dst + left , ref_row + x + left , copy ) ;\n<14> if ( right ) memset ( dst + left + copy , ref_row [ w - 1 ] , right ) ;\n<15> dst += dst_stride ;\n<17> if ( y > 0 && y < h ) ref_row += src_stride ;
<1> static void zisofs_detect_magic ( struct archive_write * a , const void * buff , size_t s ) {\n<16> if ( iso9660 -> zisofs . magic_cnt == 0 && s >= ( size_t ) magic_max ) magic_buff = buff ;\n<18> if ( iso9660 -> zisofs . magic_cnt < magic_max ) {\n<20> l = sizeof ( iso9660 -> zisofs . magic_buffer ) - iso9660 -> zisofs . magic_cnt ;\n<21> if ( l > s ) l = s ;\n<22> memcpy ( iso9660 -> zisofs . magic_buffer + iso9660 -> zisofs . magic_cnt , buff , l ) ;\n<23> iso9660 -> zisofs . magic_cnt += ( int ) l ;\n<24> if ( iso9660 -> zisofs . magic_cnt < magic_max ) return ;\n<29> p = magic_buff ;\n<30> if ( memcmp ( p , zisofs_magic , sizeof ( zisofs_magic ) ) != 0 ) return ;\n<31> p += sizeof ( zisofs_magic ) ;\n<32> uncompressed_size = archive_le32dec ( p ) ;\n<33> header_size = p [ 4 ] ;\n<34> log2_bs = p [ 5 ] ;\n<35> if ( uncompressed_size < 24 || header_size != 4 || log2_bs > 30 || log2_bs < 7 ) return ;
<1> static my_bool get_one_option ( int optid , const struct my_option * opt __attribute__ ( ( unused ) ) , char * argument ) {\n<98> if ( check_param . opt_sort_key >= MI_MAX_KEY ) {\n<99> fprintf ( stderr , "The value of the sort key is bigger than max key: %d.\n" , MI_MAX_KEY ) ;\n<129> if ( ( method = find_type ( argument , & myisam_stats_method_typelib , FIND_TYPE_BASIC ) ) <= 0 ) {\n<130> fprintf ( stderr , "Invalid value of stats_method: %s.\n" , argument ) ;
<1> void usage_exit ( ) {\n<3> fprintf ( stderr , "Usage: %s <options> filename\n\n" "Options:\n" , exec_name ) ;\n<4> arg_show_usage ( stderr , all_args ) ;\n<8> fprintf ( stderr , "\n\t%%w - Frame width" "\n\t%%h - Frame height" "\n\t%%<n> - Frame number, zero padded to <n> places (1..9)" "\n\n Pattern arguments are only supported in conjunction " "with the --yv12 and\n --i420 options. If the -o option is " "not specified, the output will be\n directed to stdout.\n" ) ;\n<9> fprintf ( stderr , "\nIncluded decoders:\n\n" ) ;\n<11> i < get_vpx_decoder_count ( ) ;\n<13> const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ;\n<14> fprintf ( stderr , " %-6s - %s\n" , decoder -> name , vpx_codec_iface_name ( decoder -> codec_interface ( ) ) ) ;
<1> static int dissect_dns_answer ( tvbuff_t * tvb , int offsetx , int dns_data_offset , column_info * cinfo , proto_tree * dns_tree , packet_info * pinfo , gboolean is_mdns ) {\n<19> len = get_dns_name_type_class ( tvb , offsetx , dns_data_offset , & name , & name_len , & dns_type , & dns_class ) ;\n<42> if ( dns_tree != NULL ) {\n<43> name_out = format_text ( name , strlen ( name ) ) ;\n<45> rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , "%s: type %s, class %s" , name_out , type_name , class_name ) ;\n<46> add_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , dns_type , pinfo , is_mdns ) ;\n<49> rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , "%s: type %s" , name_out , type_name ) ;\n<50> add_opt_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , is_mdns ) ;\n<59> switch ( dns_type ) {\n<78> ns_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & ns_name ) ;\n<79> name_out = format_text ( ns_name , strlen ( ns_name ) ) ;\n<81> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<83> proto_item_append_text ( trr , ", ns %s" , name_out ) ;\n<110> cname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & cname ) ;\n<111> name_out = format_text ( cname , strlen ( cname ) ) ;\n<113> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<115> proto_item_append_text ( trr , ", cname %s" , name_out ) ;\n<125> mname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mname ) ;\n<126> name_out = format_text ( mname , strlen ( mname ) ) ;\n<128> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<130> proto_item_append_text ( trr , ", mname %s" , name_out ) ;\n<133> rname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rname ) ;\n<134> name_out = format_text ( rname , strlen ( rname ) ) ;\n<135> proto_tree_add_string ( rr_tree , hf_dns_soa_rname , tvb , cur_offset , rname_len , name_out ) ;\n<250> pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n<251> name_out = format_text ( pname , strlen ( pname ) ) ;\n<253> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<255> proto_item_append_text ( trr , ", %s" , name_out ) ;\n<303> mx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & mx_name ) ;\n<304> name_out = format_text ( mx_name , strlen ( mx_name ) ) ;\n<306> col_append_fstr ( cinfo , COL_INFO , " %u %s" , preference , name_out ) ;\n<308> proto_item_append_text ( trr , ", preference %u, mx %s" , preference , name_out ) ;\n<538> next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n<539> name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n<565> target_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & target ) ;\n<566> name_out = format_text ( target , strlen ( target ) ) ;\n<567> proto_tree_add_string ( rr_tree , hf_dns_srv_target , tvb , cur_offset , target_len , name_out ) ;\n<607> replacement_len = get_dns_name ( tvb , offset , 0 , dns_data_offset , & replacement ) ;\n<608> name_out = format_text ( replacement , strlen ( replacement ) ) ;\n<611> proto_tree_add_string ( rr_tree , hf_dns_naptr_replacement , tvb , offset , replacement_len , name_out ) ;\n<621> kx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & kx_name ) ;\n<622> name_out = format_text ( kx_name , strlen ( kx_name ) ) ;\n<624> col_append_fstr ( cinfo , COL_INFO , " %u %s" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n<626> proto_item_append_text ( trr , ", preference %u, kx %s" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n<674> pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n<677> pname = "" ;\n<680> name_out = format_text ( pname , strlen ( pname ) ) ;\n<683> col_append_fstr ( cinfo , COL_INFO , " %d %s %s" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n<692> proto_tree_add_string ( rr_tree , hf_dns_a6_prefix_name , tvb , a6_offset , pname_len , name_out ) ;\n<694> proto_item_append_text ( trr , ", addr %d %s %s" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n<700> dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n<701> name_out = format_text ( dname , strlen ( dname ) ) ;\n<703> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<705> proto_item_append_text ( trr , ", dname %s" , name_out ) ;\n<934> next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n<935> name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n<1289> dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n<1290> name_out = format_text ( dname , strlen ( dname ) ) ;\n<1291> proto_tree_add_string ( rr_tree , hf_dns_winsr_name_result_domain , tvb , cur_offset , dname_len , name_out ) ;
<1> static int sd_create(const char *filename, QemuOpts *opts,\n<29> memset(tag, 0, sizeof(tag));\n<31> if (strstr(filename, "://")) {\n<33> ret = sd_parse_uri(s, filename, s->name, &snapid, tag);\n<37> ret = parse_vdiname(s, filename, s->name, &snapid, tag);\n<41> if (ret < 0) {\n<57> if (!buf || !strcmp(buf, "off")) {\n<59> prealloc = false;\n<61> } else if (!strcmp(buf, "full")) {\n<63> prealloc = true;\n<67> error_setg(errp, "Invalid preallocation mode: '%s'", buf);\n<69> ret = -EINVAL;\n<77> g_free(buf);\n<79> buf = qemu_opt_get_del(opts, BLOCK_OPT_REDUNDANCY);\n<81> if (buf) {\n<109> if (backing_file) {\n<123> if (!drv || strcmp(drv->protocol_name, "sheepdog") != 0) {\n<125> error_setg(errp, "backing_file must be a sheepdog image");\n<127> ret = -EINVAL;\n<135> bs = NULL;\n<137> ret = bdrv_open(&bs, backing_file, NULL, NULL, BDRV_O_PROTOCOL, NULL,\n<141> if (ret < 0) {
<1> bool sp_grant_privileges ( THD * thd , const char * sp_db , const char * sp_name , bool is_proc ) {\n<14> if ( ( au = find_acl_user ( combo -> host . str = ( char * ) sctx -> host_or_ip , combo -> user . str , FALSE ) ) ) goto found_acl ;\n<15> if ( ( au = find_acl_user ( combo -> host . str = ( char * ) sctx -> host , combo -> user . str , FALSE ) ) ) goto found_acl ;\n<16> if ( ( au = find_acl_user ( combo -> host . str = ( char * ) sctx -> ip , combo -> user . str , FALSE ) ) ) goto found_acl ;\n<17> if ( ( au = find_acl_user ( combo -> host . str = ( char * ) "%" , combo -> user . str , FALSE ) ) ) goto found_acl ;\n<25> combo -> host . length = strlen ( combo -> host . str ) ;\n<26> combo -> user . length = strlen ( combo -> user . str ) ;\n<27> combo -> host . str = thd -> strmake ( combo -> host . str , combo -> host . length ) ;\n<28> combo -> user . str = thd -> strmake ( combo -> user . str , combo -> user . length ) ;
<1> static void import_format ( CDXLVideoContext * c , int linesize , uint8_t * out ) {\n<2> memset ( out , 0 , linesize * c -> avctx -> height ) ;\n<4> case BIT_PLANAR : bitplanar2chunky ( c , linesize , out ) ;\n<6> case BIT_LINE : bitline2chunky ( c , linesize , out ) ;
<1> static int rv34_decode_intra_macroblock ( RV34DecContext * r , int8_t * intra_types ) {\n<5> memset ( r -> avail_cache , 0 , sizeof ( r -> avail_cache ) ) ;\n<6> fill_rectangle ( r -> avail_cache + 6 , 2 , 2 , 4 , 1 , 4 ) ;\n<13> cbp = rv34_decode_intra_mb_header ( r , intra_types ) ;\n<20> rv34_output_i16x16 ( r , intra_types , cbp ) ;\n<23> rv34_output_intra ( r , intra_types , cbp ) ;
<1> static struct URLProtocol *url_find_protocol(const char *filename)\n<9> size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n<13> if (filename[proto_len] != ':' &&\n<15> (filename[proto_len] != ',' || !strchr(filename + proto_len + 1, ':')) ||\n<17> is_dos_path(filename))\n<19> strcpy(proto_str, "file");\n<25> FFMIN(proto_len + 1, sizeof(proto_str)));\n<29> if ((ptr = strchr(proto_str, ',')))\n<31> *ptr = '\0';\n<33> av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n<35> if ((ptr = strchr(proto_nested, '+')))\n<37> *ptr = '\0';\n<41> while (up = ffurl_protocol_next(up)) {\n<43> if (!strcmp(proto_str, up->name))\n<47> if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n<49> !strcmp(proto_nested, up->name))\n<57> return up;
<1> static void ll_find_deltas ( struct object_entry * * list , unsigned list_size , int window , int depth , unsigned * processed ) {\n<5> if ( delta_search_threads <= 1 ) {\n<10> if ( progress > pack_to_stdout ) fprintf ( stderr , "Delta compression using up to %d threads.\n" , delta_search_threads ) ;\n<11> p = xcalloc ( delta_search_threads , sizeof ( * p ) ) ;\n<32> if ( ! p [ i ] . list_size ) continue ;\n<33> pthread_mutex_init ( & p [ i ] . mutex , NULL ) ;\n<34> pthread_cond_init ( & p [ i ] . cond , NULL ) ;\n<35> ret = pthread_create ( & p [ i ] . thread , NULL , threaded_find_deltas , & p [ i ] ) ;\n<36> if ( ret ) die ( "unable to create thread: %s" , strerror ( ret ) ) ;\n<49> i ++ ) if ( ! p [ i ] . working ) target = & p [ i ] ;\n<55> i ++ ) if ( p [ i ] . remaining > 2 * window && ( ! victim || victim -> remaining < p [ i ] . remaining ) ) victim = & p [ i ] ;\n<87> free ( p ) ;
<1> static void test_bug41078 ( void ) {\n<18> memset ( & param , 0 , sizeof ( param ) ) ;\n<23> rc = mysql_stmt_bind_param ( stmt , & param ) ;\n<27> memset ( & result , 0 , sizeof ( result ) ) ;\n<34> rc = mysql_stmt_bind_result ( stmt , & result ) ;\n<40> DIE_UNLESS ( len == sizeof ( param_str ) - 1 && ! strcmp ( str , param_str ) ) ;
<43> static void default_print_section_header ( WriterContext * wctx ) {\n<54> if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "[%s]\n" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;
<1> static void parse_global_config ( struct VpxEncoderConfig * global , char * * argv ) {\n<4> memset ( global , 0 , sizeof ( * global ) ) ;\n<15> if ( ! global -> codec ) die ( "Error: Unrecognized argument (%s) to --codec\n" , arg . val ) ;\n<19> if ( global -> passes < 1 || global -> passes > 2 ) die ( "Error: Invalid number of passes (%d)\n" , global -> passes ) ;\n<23> if ( global -> pass < 1 || global -> pass > 2 ) die ( "Error: Invalid pass selected (%d)\n" , global -> pass ) ;\n<42> validate_positive_rational ( arg . name , & global -> framerate ) ;\n<55> if ( global -> pass > global -> passes ) {\n<56> warn ( "Assuming --pass=%d implies --passes=%d\n" , global -> pass , global -> pass ) ;\n<57> global -> passes = global -> pass ;
<1> TSReturnCode TSMimeHdrFieldAppend ( TSMBuffer bufp , TSMLoc mh_mloc , TSMLoc field_mloc ) {\n<10> MIMEFieldSDKHandle * field_handle = ( MIMEFieldSDKHandle * ) field_mloc ;\n<11> if ( field_handle -> mh == nullptr ) {\n<13> mh_field = mime_field_create ( heap , mh ) ;\n<14> memcpy ( mh_field , field_handle -> field_ptr , sizeof ( MIMEField ) ) ;\n<16> field_handle -> field_ptr = mh_field ;
<1> static int decode_p_mbs(VC9Context *v)\n<81> memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);\n<93> p_cbpcy = v->previous_line_cbpcy+4;
<1> envlist_unsetenv(envlist_t *envlist, const char *env)\n<11> if ((envlist == NULL) || (env == NULL))\n<19> if (strchr(env, '=') != NULL)\n<21> return (EINVAL);\n<33> envname_len = strlen(env);\n<35> for (entry = envlist->el_entries.lh_first; entry != NULL;\n<39> if (strncmp(entry->ev_var, env, envname_len) == 0)\n<45> if (entry != NULL) {\n<47> QLIST_REMOVE(entry, ev_link);\n<49> free((char *)entry->ev_var);\n<51> free(entry);\n<59> return (0);
<1> bool st_set_trace_file(const char *file)\n<9> free(trace_file_name);\n<13> if (!file) {\n<15> if (asprintf(&trace_file_name, CONFIG_TRACE_FILE, getpid()) < 0) {\n<17> trace_file_name = NULL;\n<19> return false;\n<25> if (asprintf(&trace_file_name, "%s", file) < 0) {\n<27> trace_file_name = NULL;\n<29> return false;\n<37> st_set_trace_file_enabled(true);\n<39> return true;
<1> static int archipelago_submit_request(BDRVArchipelagoState *s,\n<29> targetlen = strlen(s->volname);\n<41> ret = xseg_prep_request(s->xseg, req, targetlen, count);\n<53> if (!target) {\n<61> memcpy(target, s->volname, targetlen);\n<91> reqdata->volname = s->volname;
<1> static int read_compressed_image ( Gif_Image * gfi , Gif_Reader * grr , int read_flags ) {\n<18> gfi -> compressed = Gif_NewArray ( uint8_t , gfi -> compressed_len ) ;\n<20> if ( ! gfi -> compressed ) return 0 ;\n<21> memcpy ( gfi -> compressed , & grr -> v [ image_pos ] , gfi -> compressed_len ) ;
<1> int net_client_init(Monitor *mon, const char *device, const char *p)\n<33> if (!strcmp(device, "nic")) {\n<45> int idx = nic_get_free_idx();\n<49> if (check_params(buf, sizeof(buf), nic_params, p) < 0) {\n<59> if (idx == -1 || nb_nics >= MAX_NICS) {\n<69> nd = &nd_table[idx];\n<71> memset(nd, 0, sizeof(*nd));\n<73> macaddr = nd->macaddr;\n<169> if (!strcmp(device, "none")) {\n<171> if (*p != '\0') {\n<473> if (!strcmp(device, "tap")) {\n<475> char ifname[64], chkbuf[64];\n<477> char setup_script[1024], down_script[1024];\n<483> vlan->nb_host_devs++;\n<485> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<513> s = net_tap_fd_init(vlan, device, name, fd);\n<557> s = net_tap_init(vlan, device, name, ifname, setup_script, down_script);\n<585> if (!strcmp(device, "socket")) {\n<587> char chkbuf[64];\n<589> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<617> if (!net_socket_fd_init(vlan, device, name, fd, 1)) {\n<645> ret = net_socket_listen_init(vlan, device, name, buf);\n<665> ret = net_socket_connect_init(vlan, device, name, buf);\n<685> ret = net_socket_mcast_init(vlan, device, name, buf);\n<767> if (!strcmp(device, "dump")) {\n<769> int len = 65536;\n<773> if (get_param_value(buf, sizeof(buf), "len", p) > 0) {\n<779> if (!get_param_value(buf, sizeof(buf), "file", p)) {\n<785> ret = net_dump_init(mon, vlan, device, name, buf, len);\n<789> config_error(mon, "Unknown network device: %s\n", device);\n<791> ret = -1;\n<797> if (ret < 0) {\n<799> config_error(mon, "Could not initialize device '%s'\n", device);
<1> static gchar * rtmpt_get_packet_desc ( tvbuff_t * tvb , guint32 offset , guint32 remain , rtmpt_conv_t * rconv , int cdir , rtmpt_packet_t * tp , gint * deschasopcode ) {\n<48> if ( slen > 0 ) {\n<50> RTMPT_DEBUG ( "got function call '%s'\n" , sFunc ) ;\n<51> if ( strcmp ( sFunc , "connect" ) == 0 ) {\n<52> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 2 , "app" ) ;\n<54> else if ( strcmp ( sFunc , "play" ) == 0 ) {\n<55> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , NULL ) ;\n<57> else if ( strcmp ( sFunc , "play2" ) == 0 ) {\n<58> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , "streamName" ) ;\n<60> else if ( strcmp ( sFunc , "releaseStream" ) == 0 ) {\n<61> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , NULL ) ;\n<63> else if ( strcmp ( sFunc , "FCPublish" ) == 0 ) {\n<64> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , NULL ) ;\n<66> else if ( strcmp ( sFunc , "publish" ) == 0 ) {\n<67> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , NULL ) ;\n<69> else if ( strcmp ( sFunc , "onStatus" ) == 0 ) {\n<70> if ( tp -> cmd == RTMPT_TYPE_COMMAND_AMF0 || tp -> cmd == RTMPT_TYPE_COMMAND_AMF3 ) {\n<77> else if ( strcmp ( sFunc , "onPlayStatus" ) == 0 ) {\n<78> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 1 , "code" ) ;\n<80> else if ( strcmp ( sFunc , "_result" ) == 0 ) {\n<81> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , "code" ) ;\n<82> tp -> isresponse = TRUE ;\n<84> else if ( strcmp ( sFunc , "_error" ) == 0 ) {\n<85> sParam = rtmpt_get_amf_param ( tvb , offset + soff , 3 , "code" ) ;\n<86> tp -> isresponse = TRUE ;\n<97> return wmem_strdup_printf ( wmem_packet_scope ( ) , "%s('%s')" , sFunc , sParam ) ;\n<100> return wmem_strdup_printf ( wmem_packet_scope ( ) , "%s()" , sFunc ) ;
<1> int print_msg_junit_test ( char * code , FILE * fd , char header , char segregationLevel ) {\n<6> payload = ( unsigned char * ) code ;\n<7> memcpy ( & i , code , 2 ) ;\n<8> memcpy ( & j , & code [ MSG_START_IDX ] , 2 ) ;\n<9> memcpy ( & msglen , & code [ MSG_LEN_IDX ] , 2 ) ;\n<10> i = ntohs ( i ) ;\n<11> j = ntohs ( j ) ;\n<12> msglen = ntohs ( msglen ) ;\n<14> fwrite ( code , 1 , j + msglen , fd ) ;\n<19> r = ( i < 100 ) ? 1 : 0 ;\n<36> i ++ ;\n<37> for ( k = i ;\n<38> k < i + ( j * 3 ) ;\n<40> memcpy ( & l , & payload [ k + 1 ] , 2 ) ;\n<41> memcpy ( & m , & payload [ k + 4 ] , 2 ) ;\n<42> l = ntohs ( l ) ;\n<43> m = ntohs ( m ) ;\n<44> if ( header == ( char ) payload [ k ] || ( header == 'U' && ( payload [ k ] == 'f' || payload [ k ] == 't' || payload [ k ] == 'm' || payload [ k ] == 'o' || payload [ k ] == 'p' ) ) ) dump_headers_test ( msg , msglen , & payload [ i + ( j * 3 ) + l + 3 ] , m - l , payload [ k ] , fd , segregationLevel ) ;
<1> int ReconnectToServer ( ArchiveHandle * AH , const char * dbname , const char * username ) {\n<5> if ( ! dbname ) newdbname = PQdb ( AH -> connection ) ;\n<6> else newdbname = dbname ;\n<7> if ( ! username ) newusername = PQuser ( AH -> connection ) ;\n<8> else newusername = username ;\n<9> if ( strcmp ( newdbname , PQdb ( AH -> connection ) ) == 0 && strcmp ( newusername , PQuser ( AH -> connection ) ) == 0 ) return 1 ;\n<10> newConn = _connectDB ( AH , newdbname , newusername ) ;\n<11> set_archive_cancel_info ( AH , newConn ) ;\n<12> PQfinish ( AH -> connection ) ;\n<13> AH -> connection = newConn ;\n<14> return 1 ;
<1> static uint64_t vfio_rom_read(void *opaque, hwaddr addr, unsigned size)\n<5> VFIODevice *vdev = opaque;\n<7> uint64_t val = ((uint64_t)1 << (size * 8)) - 1;\n<24> (addr < vdev->rom_size) ? MIN(size, vdev->rom_size - addr) : 0);\n<36> return val;
<1> static int dissect_dns_query ( tvbuff_t * tvb , int offset , int dns_data_offset , column_info * cinfo , proto_tree * dns_tree , gboolean is_mdns ) {\n<15> len = get_dns_name_type_class ( tvb , offset , dns_data_offset , & name , & name_len , & type , & dns_class ) ;\n<24> name_out = format_text ( name , strlen ( name ) ) ;\n<26> col_append_fstr ( cinfo , COL_INFO , "%s %s" , type_name , name_out ) ;\n<31> if ( dns_tree != NULL ) {\n<32> q_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offset , len , ett_dns_qd , & tq , "%s: type %s, class %s" , name_out , type_name , val_to_str_const ( dns_class , dns_classes , "Unknown" ) ) ;\n<36> proto_tree_add_string ( q_tree , hf_dns_qry_name , tvb , offset , name_len , name ) ;\n<37> tq = proto_tree_add_uint ( q_tree , hf_dns_qry_name_len , tvb , offset , name_len , name_len > 1 ? ( guint32 ) strlen ( name ) : 0 ) ;\n<39> labels = qname_labels_count ( name , name_len ) ;
<1> static int write_f(BlockBackend *blk, int argc, char **argv)\n<113> if (bflag && zflag) {\n<115> printf("-b and -z cannot be specified at the same time\n");\n<123> if ((flags & BDRV_REQ_FUA) && (bflag || cflag)) {\n<125> printf("-f and -b or -c cannot be specified at the same time\n");\n<133> if ((flags & BDRV_REQ_MAY_UNMAP) && !zflag) {\n<135> printf("-u requires -z to be specified\n");\n<143> if (zflag && Pflag) {\n<145> printf("-z and -P cannot be specified at the same time\n");\n<247> if (cnt < 0) {\n<249> printf("write failed: %s\n", strerror(-cnt));
<1> static void dct_error(const struct algo *dct, int test, int is_idct, int speed)\n<11> int64_t sysErr[64], sysErrMax = 0;\n<13> int maxout = 0;\n<15> int blockSumErrMax = 0, blockSumErr;\n<25> err_inf = 0;\n<31> sysErr[i] = 0;\n<155> if (v > err_inf)\n<157> err_inf = v;\n<161> sysErr[i] += block[i] - block1[i];\n<165> if (abs(block[i]) > maxout)\n<167> maxout = abs(block[i]);\n<171> if (blockSumErrMax < blockSumErr)\n<173> blockSumErrMax = blockSumErr;\n<179> sysErrMax = FFMAX(sysErrMax, FFABS(sysErr[i]));\n<183> for (i = 0; i < 64; i++) {\n<185> if (i % 8 == 0)\n<187> printf("\n");\n<189> printf("%7d ", (int) sysErr[i]);\n<193> printf("\n");\n<197> printf("%s %s: err_inf=%d err2=%0.8f syserr=%0.8f maxout=%d blockSumErr=%d\n",\n<201> (double) err2 / NB_ITS / 64.0, (double) sysErrMax / NB_ITS,\n<207> if (!speed)\n<307> printf("%s %s: %0.1f kdct/s\n", is_idct ? "IDCT" : "DCT", dct->name,\n<309> (double) it1 * 1000.0 / (double) ti1);
<1> int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick , my_bool no_copy_stat ) {\n<20> if ( ! ( param -> testflag & T_SILENT ) ) {\n<21> printf ( "- recovering (with sort) MyISAM-table '%s'\n" , name ) ;\n<22> printf ( "Data records: %s\n" , llstr ( start_records , llbuff ) ) ;\n<28> if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> write_buffer_length , WRITE_CACHE , new_header_length , 1 , MYF ( MY_WME | MY_WAIT_IF_FULL ) & param -> myf_rw ) ) ) goto err ;\n<30> info -> opt_flag |= WRITE_CACHE_USED ;\n<41> if ( new_header_length && filecopy ( param , new_file , info -> dfile , 0L , new_header_length , "datafile-header" ) ) goto err ;\n<49> info -> update = ( short ) ( HA_STATE_CHANGED | HA_STATE_ROW_CHANGED ) ;\n<50> mi_drop_all_indexes ( param , info , FALSE ) ;\n<77> rec_per_key_part = param -> rec_per_key_part ;\n<80> rec_per_key_part += sort_param . keyinfo -> keysegs , sort_param . key ++ ) {\n<84> if ( ! mi_is_key_active ( key_map , sort_param . key ) ) {\n<85> memcpy ( ( char * ) rec_per_key_part , ( char * ) ( share -> state . rec_per_key_part + ( uint ) ( rec_per_key_part - param -> rec_per_key_part ) ) , sort_param . keyinfo -> keysegs * sizeof ( * rec_per_key_part ) ) ;\n<89> if ( ( ! ( param -> testflag & T_SILENT ) ) ) printf ( "- Fixing index %d\n" , sort_param . key + 1 ) ;\n<102> info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n<103> info -> state -> empty = 0 ;\n<139> share -> state . state . data_file_length = info -> state -> data_file_length = sort_param . filepos ;\n<147> else info -> state -> data_file_length = sort_param . max_pos ;\n<155> if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n<168> if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n<169> if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) mi_check_print_warning ( param , "Can't change size of indexfile, error: %d" , my_errno ) ;\n<171> if ( start_records != info -> state -> records ) printf ( "Data records: %s\n" , llstr ( info -> state -> records , llbuff ) ) ;\n<175> if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n<185> if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , flags ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n<193> if ( info -> dfile == new_file ) if ( unlikely ( mi_open_datafile ( info , share , name , - 1 ) ) ) param -> retry_repair = 0 ;\n<195> mi_mark_crashed_on_repair ( info ) ;\n<199> my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n<200> my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;
<1> void kadmin_delpol ( int argc , char * argv [ ] ) {\n<4> if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( "-force" , argv [ 1 ] ) ) ) ) {\n<5> fprintf ( stderr , _ ( "usage: delete_policy [-force] policy\n" ) ) ;\n<6> return ;\n<8> if ( argc == 2 ) {\n<9> printf ( _ ( "Are you sure you want to delete the policy \"%s\"? " "(yeso): " ) , argv [ 1 ] ) ;\n<10> fgets ( reply , sizeof ( reply ) , stdin ) ;\n<11> if ( strcmp ( "yes\n" , reply ) ) {\n<12> fprintf ( stderr , _ ( "Policy \"%s\" not deleted.\n" ) , argv [ 1 ] ) ;\n<13> return ;\n<16> retval = kadm5_delete_policy ( handle , argv [ argc - 1 ] ) ;\n<17> if ( retval ) {
<1> static int isofile_hd_cmp_key ( const struct archive_rb_node * n , const void * key ) {\n<3> return ( strcmp ( archive_entry_pathname ( h -> file_list . first -> entry ) , ( const char * ) key ) ) ;
<1> envlist_create(void)\n<9> if ((envlist = malloc(sizeof (*envlist))) == NULL)\n<11> return (NULL);\n<15> QLIST_INIT(&envlist->el_entries);\n<17> envlist->el_count = 0;\n<21> return (envlist);
<1> static inline int padr_bcast ( PCNetState * s , const uint8_t * buf , int size ) {\n<5> struct qemu_ether_header * hdr = ( void * ) buf ;\n<6> int result = ! CSR_DRCVBC ( s ) && ! memcmp ( hdr -> ether_dhost , BCAST , 6 ) ;
<1> TEST_F ( TransportSecurityPersisterTest , PublicKeyHashes ) {\n<9> memset ( sha1 . data ( ) , '1' , sha1 . size ( ) ) ;\n<29> EXPECT_EQ ( 0 , memcmp ( new_domain_state . pkp . spki_hashes [ 0 ] . data ( ) , sha1 . data ( ) , sha1 . size ( ) ) ) ;
<1> int qemuMonitorJSONIOProcess ( qemuMonitorPtr mon , const char * data , size_t len , qemuMonitorMessagePtr msg ) {\n<3> while ( used < len ) {\n<4> char * nl = strstr ( data + used , LINE_ENDING ) ;\n<6> int got = nl - ( data + used ) ;\n<7> char * line = strndup ( data + used , got ) ;\n<8> if ( ! line ) {\n<12> used += got + strlen ( LINE_ENDING ) ;
<1> static MMSSCPacketType get_tcp_server_response(MMSTContext *mmst)\n<9> MMSContext *mms = &mmst->mms;\n<17> if(read_result < 0) {\n<23> read_result, strerror(read_result));\n<55> if(read_result != 4) {\n<63> read_result < 0 ? strerror(read_result) :\n<97> if (read_result != length_remaining) {\n<105> read_result < 0 ? strerror(read_result) :\n<167> mms->remaining_in_len    = length_remaining;\n<169> mms->read_in_ptr         = mms->in_buffer;\n<173> if(read_result != length_remaining) {\n<181> read_result < 0 ? strerror(read_result) :\n<205> if (!p) {\n<213> mms->asf_header = p;\n<219> mms->asf_header_size += mms->remaining_in_len;\n<259> pad_media_packet(mms);
<1> static ssize_t local_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n<3> char *buf, size_t bufsz)\n<41> } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n<45> buffer = rpath(fs_ctx, path);\n<47> tsize = readlink(buffer, buf, bufsz);\n<49> g_free(buffer);\n<53> return tsize;
<1> static int s390x_write_all_elf64_notes(const char *note_name,\n<21> for (nf = note_func; nf->note_contents_func; nf++) {\n<23> memset(&note, 0, sizeof(note));\n<29> strncpy(note.name, note_name, sizeof(note.name));\n<31> (*nf->note_contents_func)(&note, cpu);\n<37> ret = f(&note, note_size, opaque);
<1> static void get_bin_version ( ClusterInfo * cluster ) {\n<2> char cmd [ MAXPGPATH ] , cmd_output [ MAX_STRING ] ;\n<6> if ( ( output = popen ( cmd , "r" ) ) == NULL || fgets ( cmd_output , sizeof ( cmd_output ) , output ) == NULL ) pg_fatal ( "Could not get pg_ctl version data using %s: %s\n" , cmd , getErrorText ( ) ) ;\n<7> pclose ( output ) ;\n<8> if ( strchr ( cmd_output , '\n' ) != NULL ) * strchr ( cmd_output , '\n' ) = '\0' ;\n<9> if ( sscanf ( cmd_output , "%*s %*s %d.%d" , & pre_dot , & post_dot ) != 2 ) pg_fatal ( "could not get version from %s\n" , cmd ) ;\n<10> cluster -> bin_version = ( pre_dot * 100 + post_dot ) * 100 ;
<1> static void mode_list ( struct cpio * cpio ) {\n<22> if ( cpio -> verbose ) list_item_verbose ( cpio , entry ) ;\n<23> else fprintf ( stdout , "%s\n" , archive_entry_pathname ( entry ) ) ;\n<27> if ( ! cpio -> quiet ) {\n<28> int64_t blocks = ( archive_filter_bytes ( a , 0 ) + 511 ) / 512 ;\n<29> fprintf ( stderr , "%lu %s\n" , ( unsigned long ) blocks , blocks == 1 ? "block" : "blocks" ) ;
<1> void evhttp_clear_headers ( struct evkeyvalq * headers ) {\n<4> header != NULL ;\n<6> TAILQ_REMOVE ( headers , header , next ) ;\n<7> free ( header -> key ) ;\n<8> free ( header -> value ) ;\n<9> free ( header ) ;
<1> static void stereo_processing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34)\n<45> if (ps->num_env_old) {\n<47> memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n<49> memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n<51> memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n<53> memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n<55> memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n<57> memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n<59> memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n<61> memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n<83> map_val_20_to_34(H11[0][0]);\n<85> map_val_20_to_34(H11[1][0]);\n<87> map_val_20_to_34(H12[0][0]);\n<89> map_val_20_to_34(H12[1][0]);\n<91> map_val_20_to_34(H21[0][0]);\n<93> map_val_20_to_34(H21[1][0]);\n<95> map_val_20_to_34(H22[0][0]);\n<97> map_val_20_to_34(H22[1][0]);\n<119> map_val_34_to_20(H11[0][0]);\n<121> map_val_34_to_20(H11[1][0]);\n<123> map_val_34_to_20(H12[0][0]);\n<125> map_val_34_to_20(H12[1][0]);\n<127> map_val_34_to_20(H21[0][0]);\n<129> map_val_34_to_20(H21[1][0]);\n<131> map_val_34_to_20(H22[0][0]);\n<133> map_val_34_to_20(H22[1][0]);
<1> static int rtp_new_av_stream(HTTPContext *c,\n<37> if (!st)\n<41> st->codec= avcodec_alloc_context();\n<53> memcpy(st, c->stream->streams[stream_index], sizeof(AVStream));
<1> int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) {\n<11> memcpy ( & caf_file_header , fourcc , 4 ) ;\n<12> if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) {\n<16> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) {\n<20> WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ;\n<21> if ( caf_file_header . mFileVersion != 1 ) {\n<22> error_line ( "%s: can't handle version %d .CAF files!" , infilename , caf_file_header . mFileVersion ) ;\n<37> if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n<41> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n<45> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ;\n<46> if ( debug_logging_mode ) {\n<47> char formatstr [ 5 ] ;\n<48> memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ;\n<49> formatstr [ 4 ] = 0 ;\n<50> error_line ( "format = %s, flags = %x, sampling rate = %g" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ;\n<51> error_line ( "packet = %d bytes and %d frames" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ;\n<54> if ( strncmp ( caf_audio_format . mFormatID , "lpcm" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ;\n<55> else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ;\n<58> else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ;\n<63> config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ;\n<68> if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ;\n<77> if ( caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) || caf_chunk_header . mChunkSize > 1024 ) {\n<82> caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ;\n<83> if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) {\n<85> free ( caf_channel_layout ) ;\n<88> else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) {\n<90> free ( caf_channel_layout ) ;\n<93> WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ;\n<95> if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) {\n<97> free ( caf_channel_layout ) ;\n<100> switch ( caf_channel_layout -> mChannelLayoutTag ) {\n<105> if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) {\n<107> free ( caf_channel_layout ) ;\n<110> if ( num_descriptions >= 256 ) {\n<114> channel_reorder = malloc ( num_descriptions ) ;\n<115> memset ( channel_reorder , - 1 , num_descriptions ) ;\n<116> channel_identities = malloc ( num_descriptions + 1 ) ;\n<118> i < num_descriptions ;\n<129> channel_reorder [ i ] = cindex ++ ;\n<134> ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) {\n<136> if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ;\n<137> else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ;\n<140> channel_identities [ idents ++ ] = 0xff ;\n<142> channel_reorder [ i ] = cindex ++ ;\n<146> ++ i ) if ( channel_reorder [ i ] != i ) break ;\n<147> if ( i == num_descriptions ) {\n<148> free ( channel_reorder ) ;\n<155> if ( ! idents ) {\n<156> free ( channel_identities ) ;\n<159> else channel_identities [ idents ] = 0 ;\n<161> error_line ( "layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ;\n<162> if ( channel_reorder && num_descriptions <= 8 ) {\n<174> if ( debug_logging_mode ) error_line ( "layout_tag = 0x%08x, so using supplied bitmap of 0x%08x" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ;\n<178> ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) {\n<181> if ( layouts [ i ] . mChannelReorder ) {\n<182> channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ;\n<185> if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ;\n<189> if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( "layout_tag 0x%08x not found in table...all channels unassigned" , caf_channel_layout -> mChannelLayoutTag ) ;\n<192> free ( caf_channel_layout ) ;\n<231> uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ;\n<233> if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) {\n<237> buff = malloc ( bytes_to_copy ) ;\n<239> if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) {\n<241> free ( buff ) ;\n<244> free ( buff ) ;\n<248> if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) {\n<252> if ( channel_identities ) free ( channel_identities ) ;\n<253> if ( channel_layout || channel_reorder ) {\n<254> if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) {\n<258> if ( channel_reorder ) free ( channel_reorder ) ;
<1> iscsi_aio_ioctl_cb(struct iscsi_context *iscsi, int status,\n<47> if (status == SCSI_STATUS_CHECK_CONDITION && acb->task->datain.size >= 2) {\n<59> ss = (acb->ioh->mx_sb_len >= acb->ioh->sb_len_wr) ?\n<63> memcpy(acb->ioh->sbp, &acb->task->datain.data[2], ss);
<1> static void test_truncation ( ) {\n<8> rc = mysql_query ( mysql , "drop table if exists t1" ) ;\n<10> stmt_text = "create table t1 (" "i8 tinyint, ui8 tinyint unsigned, " "i16 smallint, i16_1 smallint, " "ui16 smallint unsigned, i32 int, i32_1 int, " "d double, d_1 double, ch char(30), ch_1 char(30), " "tx text, tx_1 text, ch_2 char(30) " ")" ;\n<11> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<14> const char insert_text [ ] = "insert into t1 VALUES (" "-10, " "200, " "32000, " "-32767, " "64000, " "1073741824, " "1073741825, " "123.456, " "-12345678910, " "'111111111111111111111111111111'," "'abcdef', " "'12345 ', " "'12345.67 ', " "'12345.67abc'" ")" ;\n<15> rc = mysql_real_query ( mysql , insert_text , strlen ( insert_text ) ) ;\n<18> stmt_text = "select i8 c1, i8 c2, ui8 c3, i16_1 c4, ui16 c5, " " i16 c6, ui16 c7, i32 c8, i32_1 c9, i32_1 c10, " " d c11, d_1 c12, d_1 c13, ch c14, ch_1 c15, tx c16, " " tx_1 c17, ch_2 c18 " "from t1" ;\n<19> stmt = mysql_stmt_init ( mysql ) ;\n<20> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<21> check_execute ( stmt , rc ) ;\n<25> bind_array = malloc ( sizeof ( MYSQL_BIND ) * bind_count ) ;\n<26> memset ( bind_array , 0 , sizeof ( MYSQL_BIND ) * bind_count ) ;\n<27> for ( my_bind = bind_array ;\n<28> my_bind < bind_array + bind_count ;\n<30> my_bind = bind_array ;\n<31> my_bind -> buffer = malloc ( sizeof ( uint8 ) ) ;\n<34> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<35> my_bind -> buffer = malloc ( sizeof ( uint32 ) ) ;\n<38> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<39> my_bind -> buffer = malloc ( sizeof ( int8 ) ) ;\n<41> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<42> my_bind -> buffer = malloc ( sizeof ( uint16 ) ) ;\n<45> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<46> my_bind -> buffer = malloc ( sizeof ( int16 ) ) ;\n<48> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<49> my_bind -> buffer = malloc ( sizeof ( uint16 ) ) ;\n<52> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<53> my_bind -> buffer = malloc ( sizeof ( int8 ) ) ;\n<56> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<57> my_bind -> buffer = malloc ( sizeof ( float ) ) ;\n<59> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<60> my_bind -> buffer = malloc ( sizeof ( float ) ) ;\n<62> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<63> my_bind -> buffer = malloc ( sizeof ( double ) ) ;\n<65> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<66> my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n<68> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<69> my_bind -> buffer = malloc ( sizeof ( ulonglong ) ) ;\n<72> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<73> my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n<75> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<76> my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n<78> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<79> my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n<81> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<82> my_bind -> buffer = malloc ( sizeof ( longlong ) ) ;\n<84> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<85> my_bind -> buffer = malloc ( sizeof ( double ) ) ;\n<87> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<88> my_bind -> buffer = malloc ( sizeof ( double ) ) ;\n<90> rc = mysql_stmt_bind_result ( stmt , bind_array ) ;\n<94> my_bind = bind_array ;\n<95> DIE_UNLESS ( * my_bind -> error && * ( int8 * ) my_bind -> buffer == - 10 ) ;\n<96> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<97> DIE_UNLESS ( * my_bind -> error && * ( int32 * ) my_bind -> buffer == - 10 ) ;\n<98> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<99> DIE_UNLESS ( * my_bind -> error && * ( uint8 * ) my_bind -> buffer == 200 ) ;\n<100> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<101> DIE_UNLESS ( * my_bind -> error && * ( int16 * ) my_bind -> buffer == - 32767 ) ;\n<102> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<103> DIE_UNLESS ( * my_bind -> error && * ( uint16 * ) my_bind -> buffer == 64000 ) ;\n<104> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<105> DIE_UNLESS ( ! * my_bind -> error && * ( uint16 * ) my_bind -> buffer == 32000 ) ;\n<106> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<107> DIE_UNLESS ( * my_bind -> error && * ( int8 * ) my_bind -> buffer == 0 ) ;\n<108> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<109> DIE_UNLESS ( ! * my_bind -> error && * ( float * ) my_bind -> buffer == 1073741824 ) ;\n<110> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<112> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<113> DIE_UNLESS ( ! * my_bind -> error && * ( double * ) my_bind -> buffer == 1073741825 ) ;\n<114> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<115> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<117> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<118> DIE_UNLESS ( ! * my_bind -> error && * ( longlong * ) my_bind -> buffer == LL ( - 12345678910 ) ) ;\n<119> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<121> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<122> DIE_UNLESS ( * my_bind -> error && * ( longlong * ) my_bind -> buffer == 0 ) ;\n<123> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<124> DIE_UNLESS ( ! * my_bind -> error && * ( longlong * ) my_bind -> buffer == 12345 ) ;\n<125> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<126> DIE_UNLESS ( ! * my_bind -> error && * ( double * ) my_bind -> buffer == 12345.67 ) ;\n<127> DIE_UNLESS ( my_bind ++ < bind_array + bind_count ) ;\n<128> DIE_UNLESS ( * ( double * ) my_bind -> buffer == 12345.67 ) ;\n<131> my_bind < bind_array + bind_count ;\n<132> my_bind ++ ) free ( my_bind -> buffer ) ;\n<133> free ( bind_array ) ;
<1> static void close_detect_launch ( int fd , short what , void * arg ) {\n<6> if ( evhttp_make_request ( evcon , req , EVHTTP_REQ_GET , "/test" ) == - 1 ) {\n<7> fprintf ( stdout , "FAILED\n" ) ;
<1> int spapr_rtas_device_tree_setup(void *fdt, hwaddr rtas_addr,\n<15> if (ret < 0) {\n<17> fprintf(stderr, "Couldn't add RTAS reserve entry: %s\n",\n<19> fdt_strerror(ret));\n<31> if (ret < 0) {\n<33> fprintf(stderr, "Couldn't add linux,rtas-base property: %s\n",\n<35> fdt_strerror(ret));\n<47> if (ret < 0) {\n<49> fprintf(stderr, "Couldn't add linux,rtas-entry property: %s\n",\n<51> fdt_strerror(ret));\n<63> if (ret < 0) {\n<65> fprintf(stderr, "Couldn't add rtas-size property: %s\n",\n<67> fdt_strerror(ret));\n<77> struct rtas_call *call = &rtas_table[i];\n<89> ret = qemu_fdt_setprop_cell(fdt, "/rtas", call->name,\n<93> if (ret < 0) {\n<95> fprintf(stderr, "Couldn't add rtas token for %s: %s\n",\n<97> call->name, fdt_strerror(ret));
<1> static void qtest_process_command(CharDriverState *chr, gchar **words)\n<9> g_assert(words);\n<17> if (qtest_log_fp) {\n<31> for (i = 0; words[i]; i++) {\n<33> fprintf(qtest_log_fp, " %s", words[i]);\n<37> fprintf(qtest_log_fp, "\n");\n<45> if (strcmp(words[0], "irq_intercept_out") == 0\n<47> || strcmp(words[0], "irq_intercept_in") == 0) {\n<55> g_assert(words[1]);\n<57> dev = DEVICE(object_resolve_path(words[1], NULL));\n<59> if (!dev) {\n<139> } else if (strcmp(words[0], "outb") == 0 ||\n<141> strcmp(words[0], "outw") == 0 ||\n<143> strcmp(words[0], "outl") == 0) {\n<151> g_assert(words[1] && words[2]);\n<153> addr = strtoul(words[1], NULL, 0);\n<155> value = strtoul(words[2], NULL, 0);\n<159> if (words[0][3] == 'b') {\n<173> qtest_send_prefix(chr);\n<175> qtest_send(chr, "OK\n");\n<177> } else if (strcmp(words[0], "inb") == 0 ||\n<179> strcmp(words[0], "inw") == 0 ||\n<181> strcmp(words[0], "inl") == 0) {\n<185> uint32_t value = -1U;\n<189> g_assert(words[1]);\n<191> addr = strtoul(words[1], NULL, 0);\n<195> if (words[0][2] == 'b') {\n<209> qtest_send_prefix(chr);\n<211> qtest_send(chr, "OK 0x%04x\n", value);\n<213> } else if (strcmp(words[0], "writeb") == 0 ||\n<215> strcmp(words[0], "writew") == 0 ||\n<217> strcmp(words[0], "writel") == 0 ||\n<219> strcmp(words[0], "writeq") == 0) {\n<227> g_assert(words[1] && words[2]);\n<229> addr = strtoull(words[1], NULL, 0);\n<231> value = strtoull(words[2], NULL, 0);\n<235> if (words[0][5] == 'b') {\n<267> qtest_send_prefix(chr);\n<269> qtest_send(chr, "OK\n");\n<271> } else if (strcmp(words[0], "readb") == 0 ||\n<273> strcmp(words[0], "readw") == 0 ||\n<275> strcmp(words[0], "readl") == 0 ||\n<277> strcmp(words[0], "readq") == 0) {\n<281> uint64_t value = UINT64_C(-1);\n<285> g_assert(words[1]);\n<287> addr = strtoull(words[1], NULL, 0);\n<291> if (words[0][4] == 'b') {\n<323> qtest_send_prefix(chr);\n<327> } else if (strcmp(words[0], "read") == 0) {\n<335> g_assert(words[1] && words[2]);\n<337> addr = strtoull(words[1], NULL, 0);\n<339> len = strtoull(words[2], NULL, 0);\n<343> data = g_malloc(len);\n<345> cpu_physical_memory_read(addr, data, len);\n<349> qtest_send_prefix(chr);\n<351> qtest_send(chr, "OK 0x");\n<353> for (i = 0; i < len; i++) {\n<359> qtest_send(chr, "\n");\n<363> g_free(data);\n<365> } else if (strcmp(words[0], "write") == 0) {\n<375> g_assert(words[1] && words[2] && words[3]);\n<377> addr = strtoull(words[1], NULL, 0);\n<379> len = strtoull(words[2], NULL, 0);\n<383> data_len = strlen(words[3]);\n<385> if (data_len < 3) {\n<423> } else if (qtest_enabled() && strcmp(words[0], "clock_step") == 0) {\n<429> if (words[1]) {\n<439> qtest_clock_warp(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + ns);\n<441> qtest_send_prefix(chr);\n<445> } else if (qtest_enabled() && strcmp(words[0], "clock_set") == 0) {\n<451> g_assert(words[1]);\n<453> ns = strtoll(words[1], NULL, 0);\n<455> qtest_clock_warp(ns);\n<457> qtest_send_prefix(chr);\n<463> qtest_send_prefix(chr);\n<465> qtest_send(chr, "FAIL Unknown command `%s'\n", words[0]);
<1> static int aes_ccm_tls_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n<4> if ( out != in || len < ( EVP_CCM_TLS_EXPLICIT_IV_LEN + ( size_t ) cctx -> M ) ) return - 1 ;\n<5> if ( EVP_CIPHER_CTX_encrypting ( ctx ) ) memcpy ( out , EVP_CIPHER_CTX_buf_noconst ( ctx ) , EVP_CCM_TLS_EXPLICIT_IV_LEN ) ;\n<6> memcpy ( EVP_CIPHER_CTX_iv_noconst ( ctx ) + EVP_CCM_TLS_FIXED_IV_LEN , in , EVP_CCM_TLS_EXPLICIT_IV_LEN ) ;\n<7> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN + cctx -> M ;\n<10> in += EVP_CCM_TLS_EXPLICIT_IV_LEN ;\n<11> out += EVP_CCM_TLS_EXPLICIT_IV_LEN ;\n<15> return len + EVP_CCM_TLS_EXPLICIT_IV_LEN + cctx -> M ;
<1> static void start_frame(AVFilterLink *inlink, AVFilterBufferRef *picref)\n<31> if (outpicref->data[i]) {\n<37> memset(data, 0, FFABS(outpicref->linesize[i]) * h);\n<47> if (priv->pix_desc->flags & PIX_FMT_PAL)\n<49> memcpy(outpicref->data[1], outpicref->data[1], 256*4);
<1> read_f(int argc, char **argv)\n<23> int pattern = 0, pattern_offset = 0, pattern_count = 0;\n<27> while ((c = getopt(argc, argv, "Cl:pP:qs:v")) != EOF) {\n<41> pattern_count = cvtnum(optarg);\n<43> if (pattern_count < 0) {\n<45> printf("non-numeric length argument -- %s\n", optarg);\n<63> pattern = atoi(optarg);\n<77> pattern_offset = cvtnum(optarg);\n<79> if (pattern_offset < 0) {\n<81> printf("non-numeric length argument -- %s\n", optarg);\n<111> offset = cvtnum(argv[optind]);\n<113> if (offset < 0) {\n<115> printf("non-numeric length argument -- %s\n", argv[optind]);\n<125> count = cvtnum(argv[optind]);\n<127> if (count < 0) {\n<129> printf("non-numeric length argument -- %s\n", argv[optind]);\n<147> pattern_count = count - pattern_offset;\n<153> if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n<155> printf("pattern verfication range exceeds end of read data\n");\n<165> if (offset & 0x1ff) {\n<175> if (count & 0x1ff) {\n<197> cnt = do_pread(buf, offset, count, &total);\n<201> cnt = do_read(buf, offset, count, &total);\n<207> if (cnt < 0) {\n<209> printf("read failed: %s\n", strerror(-cnt));\n<217> if (Pflag) {\n<219> void* cmp_buf = malloc(pattern_count);\n<221> memset(cmp_buf, pattern, pattern_count);\n<223> if (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n<225> printf("Pattern verification failed at offset %lld, "\n<229> (long long) offset + pattern_offset, pattern_count);\n<233> free(cmp_buf);
<1> static const char * lookup_name ( struct cpio * cpio , struct name_cache * * name_cache_variable , int ( * lookup_fn ) ( struct cpio * , const char * * , id_t ) , id_t id ) {\n<6> if ( * name_cache_variable == NULL ) {\n<7> * name_cache_variable = malloc ( sizeof ( struct name_cache ) ) ;\n<8> if ( * name_cache_variable == NULL ) lafe_errc ( 1 , ENOMEM , "No more memory" ) ;\n<9> memset ( * name_cache_variable , 0 , sizeof ( struct name_cache ) ) ;\n<12> cache = * name_cache_variable ;\n<15> if ( cache -> cache [ slot ] . name != NULL ) {\n<16> if ( cache -> cache [ slot ] . id == id ) {\n<20> free ( cache -> cache [ slot ] . name ) ;\n<23> if ( lookup_fn ( cpio , & name , id ) == 0 ) {\n<24> if ( name == NULL || name [ 0 ] == '\0' ) {\n<26> name = asnum ;\n<28> cache -> cache [ slot ] . name = strdup ( name ) ;\n<29> if ( cache -> cache [ slot ] . name != NULL ) {
<1> relpRetVal relpTcpAcceptConnReq ( relpTcp_t * * ppThis , int sock , relpSrv_t * pSrv ) {\n<11> int errnosave = errno ;\n<12> if ( iNewSock < 0 ) {\n<13> pSrv -> pEngine -> dbgprint ( "error during accept, sleeping 20ms: %s\n" , strerror ( errnosave ) ) ;
<1> rfbBool rfbProcessFileTransfer ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length ) {\n<23> if ( buffer != NULL ) free ( buffer ) ;\n<28> if ( buffer != NULL ) free ( buffer ) ;\n<42> case rfbFileTransferRequest : if ( ( buffer = rfbProcessFileTransferReadBuffer ( cl , length ) ) == NULL ) return FALSE ;\n<43> if ( ! rfbFilenameTranslate2UNIX ( cl , buffer , filename1 , sizeof ( filename1 ) ) ) goto fail ;\n<45> if ( DB ) rfbLog ( "rfbProcessFileTransfer() rfbFileTransferRequest(\"%s\"->\"%s\") Open: %s fd=%d\n" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? "Failed" : "Success" ) , cl -> fileTransfer . fd ) ;\n<47> if ( fstat ( cl -> fileTransfer . fd , & statbuf ) != 0 ) {\n<52> strftime ( timespec , sizeof ( timespec ) , "%m/%d/%Y %H:%M" , gmtime ( & statbuf . st_ctime ) ) ;\n<53> buffer = realloc ( buffer , length + strlen ( timespec ) + 2 ) ;\n<54> if ( buffer == NULL ) {\n<55> rfbLog ( "rfbProcessFileTransfer() rfbFileTransferRequest: Failed to malloc %d bytes\n" , length + strlen ( timespec ) + 2 ) ;\n<58> strcat ( buffer , "," ) ;\n<59> strcat ( buffer , timespec ) ;\n<60> length = strlen ( buffer ) ;\n<61> if ( DB ) rfbLog ( "rfbProcessFileTransfer() buffer is now: \"%s\"\n" , buffer ) ;\n<65> retval = rfbSendFileTransferMessage ( cl , rfbFileHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : statbuf . st_size ) , length , buffer ) ;\n<67> if ( buffer != NULL ) free ( buffer ) ;\n<80> if ( buffer != NULL ) free ( buffer ) ;\n<96> if ( p != NULL ) {\n<97> * p = '\0' ;\n<98> strncpy ( szFileTime , p + 1 , sizeof ( szFileTime ) ) ;\n<105> if ( buffer != NULL ) free ( buffer ) ;\n<111> if ( DB ) rfbLog ( "rfbProcessFileTransfer() rfbFileTransferOffer(\"%s\"->\"%s\") %s %s fd=%d\n" , buffer , filename1 , ( cl -> fileTransfer . fd == - 1 ? "Failed" : "Success" ) , ( cl -> fileTransfer . fd == - 1 ? strerror ( errno ) : "" ) , cl -> fileTransfer . fd ) ;\n<112> retval = rfbSendFileTransferMessage ( cl , rfbFileAcceptHeader , 0 , ( cl -> fileTransfer . fd == - 1 ? - 1 : 0 ) , length , buffer ) ;\n<113> if ( cl -> fileTransfer . fd == - 1 ) {\n<114> free ( buffer ) ;\n<185> if ( buffer != NULL ) free ( buffer ) ;\n<194> if ( buffer != NULL ) free ( buffer ) ;\n<205> if ( buffer != NULL ) free ( buffer ) ;\n<212> if ( buffer != NULL ) free ( buffer ) ;\n<214> fail : if ( buffer != NULL ) free ( buffer ) ;
<1> int write_command_to_file ( char * cmd ) {\n<9> if ( ! cmd || ! * cmd || strchr ( cmd , '\n' ) ) return ERROR ;\n<10> if ( stat ( command_file , & statbuf ) ) {\n<17> if ( fp == NULL ) {\n<23> if ( use_logging == TRUE ) {\n<24> p = strchr ( cmd , ']' ) ;\n<25> if ( p != NULL ) p += 2 ;\n<26> else p = & cmd [ 0 ] ;\n<27> ip_address = strdup ( getenv ( "REMOTE_ADDR" ) ) ;\n<42> fprintf ( fp , "%s\n" , cmd ) ;\n<43> fflush ( fp ) ;
<1> int WriteTTFFont ( char * fontname , SplineFont * sf , enum fontformat format , int32 * bsizes , enum bitmapformat bf , int flags , EncMap * map , int layer ) {\n<4> if ( strstr ( fontname , "://" ) != NULL ) {\n<5> if ( ( ttf = tmpfile ( ) ) == NULL ) return ( 0 ) ;\n<8> if ( ( ttf = fopen ( fontname , "wb+" ) ) == NULL ) return ( 0 ) ;\n<10> ret = _WriteTTFFont ( ttf , sf , format , bsizes , bf , flags , map , layer ) ;\n<11> if ( strstr ( fontname , "://" ) != NULL && ret ) ret = URLFromFile ( fontname , ttf ) ;\n<12> if ( ret && ( flags & ttf_flag_glyphmap ) ) DumpGlyphToNameMap ( fontname , sf ) ;
<1> static void test_bug11656 ( ) {\n<6> char buf [ 2 ] [ 20 ] ;\n<13> stmt_text = "select distinct test_kind, test_id from t1 " "where server in (?, ?)" ;\n<14> stmt = mysql_stmt_init ( mysql ) ;\n<15> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<16> check_execute ( stmt , rc ) ;\n<19> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<23> i < 2 ;\n<26> my_bind [ i ] . buffer = ( uchar * * ) & buf [ i ] ;\n<27> my_bind [ i ] . buffer_length = strlen ( buf [ i ] ) ;\n<29> mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static int ivr_probe ( AVProbeData * p ) {\n<2> if ( memcmp ( p -> buf , ".R1M\x0\x1\x1" , 7 ) && memcmp ( p -> buf , ".REC" , 4 ) ) return 0 ;\n<3> return AVPROBE_SCORE_MAX ;
<1> void config_remotely ( sockaddr_u * remote_addr ) {\n<5> memset ( & remote_cuckoo , 0 , sizeof ( remote_cuckoo ) ) ;\n<9> ip_file = & remote_cuckoo ;
<1> static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size,\n<7> const uint8_t *buf = avpkt->data;\n<11> AC3DecodeContext *s = avctx->priv_data;\n<25> if (s->input_buffer) {\n<31> memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));\n<33> init_get_bits(&s->gbc, s->input_buffer, buf_size * 8);\n<121> if (av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) {
<1> static cmsBool isabsolutepath ( const char * path ) {\n<2> char ThreeChars [ 4 ] ;\n<3> if ( path == NULL ) return FALSE ;\n<4> if ( path [ 0 ] == 0 ) return FALSE ;\n<5> strncpy ( ThreeChars , path , 3 ) ;\n<7> if ( ThreeChars [ 0 ] == DIR_CHAR ) return TRUE ;
<1> static int dumpcff ( struct alltabs * at , SplineFont * sf , enum fontformat format , FILE * cff ) {\n<3> if ( format == ff_cff ) {\n<5> ret = dumptype2glyphs ( sf , at ) ;\n<9> ret = dumpcidglyphs ( sf , at ) ;\n<10> free ( sf -> glyphs ) ;\n<14> free ( at -> gi . bygid ) ;\n<16> else if ( at -> gi . flags & ps_flag_nocffsugar ) {\n<21> char buffer [ 80 ] ;\n<22> fprintf ( cff , "%%!PS-Adobe-3.0 Resource-FontSet\n" ) ;\n<23> fprintf ( cff , "%%%%DocumentNeedResources:ProcSet (FontSetInit)\n" ) ;\n<24> fprintf ( cff , "%%%%Title: (FontSet/%s)\n" , sf -> fontname ) ;\n<25> fprintf ( cff , "%%%%EndComments\n" ) ;\n<26> fprintf ( cff , "%%%%IncludeResource: ProcSet(FontSetInit)\n" ) ;\n<27> fprintf ( cff , "%%%%BeginResource: FontSet(%s)\n" , sf -> fontname ) ;\n<28> fprintf ( cff , "/FontSetInit /ProcSet findresource begin\n" ) ;\n<30> len = ftell ( at -> cfff ) ;\n<32> sprintf ( buffer , "/%s %ld StartData\n" , sf -> fontname , len ) ;\n<33> fprintf ( cff , "%%%%BeginData: %ld Binary Bytes\n" , ( long ) ( len + strlen ( buffer ) ) ) ;\n<34> fputs ( buffer , cff ) ;\n<35> if ( ! ttfcopyfile ( cff , at -> cfff , ftell ( cff ) , "CFF" ) ) at -> error = true ;\n<36> fprintf ( cff , "\n%%%%EndData\n" ) ;\n<37> fprintf ( cff , "%%%%EndResource\n" ) ;\n<38> fprintf ( cff , "%%%%EOF\n" ) ;
<1> static void probe_group_enter(const char *name, int type)\n<15> if (!octx.prefix || !name) {\n<17> fprintf(stderr, "Out of memory\n");
<1> static void initMMX2HScaler(int dstW, int xInc, uint8_t *funnyCode)\n<123> if((i&3) == 0)\n<137> memcpy(funnyCode + fragmentLength*i/4, fragment, fragmentLength);\n<141> funnyCode[fragmentLength*i/4 + imm8OfPShufW1]=\n<153> if(d<3) funnyCode[fragmentLength*i/4 + 1]= 0x6E;\n<157> funnyCode[fragmentLength*(i+4)/4]= RET;
<1> static int parse_adaptation_sets(AVFormatContext *s)\n<5> WebMDashMuxContext *w = s->priv_data;\n<7> char *p = w->adaptation_sets;\n<13> if (!w->adaptation_sets) {\n<25> while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n<27> if (*p == ' ')\n<31> else if (state == new_set && !strncmp(p, "id=", 3)) {\n<35> if (mem == NULL)\n<47> p += 3; // consume "id="\n<51> while (*p != ',') *q++ = *p++;\n<55> p++;\n<59> } else if (state == parsed_id && !strncmp(p, "streams=", 8)) {\n<61> p += 8; // consume "streams="\n<69> q = p;\n<79> as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);\n<83> if (*q == '\0') break;\n<87> p = ++q;\n<97> return 0;
<1> static cmsBool Read8bitTables ( cmsContext ContextID , cmsIOHANDLER * io , cmsPipeline * lut , int nChannels ) {\n<6> if ( nChannels <= 0 ) return FALSE ;\n<7> memset ( Tables , 0 , sizeof ( Tables ) ) ;\n<14> if ( Tables [ i ] == NULL ) goto Error ;\n<26> if ( ! cmsPipelineInsertStage ( lut , cmsAT_END , cmsStageAllocToneCurves ( ContextID , nChannels , Tables ) ) ) goto Error ;\n<34> if ( Tables [ i ] ) cmsFreeToneCurve ( Tables [ i ] ) ;
<1> static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n<5> uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n<15> if (sscanf(str, fmt, ptr) != 1)\n<17> return -EINVAL;\n<19> return 0;
<1> static char * adb_send_and_read ( socket_handle_t sock , const char * adb_service , char * buffer , int buffer_length , gssize * data_length ) {\n<4> char status [ 4 ] ;\n<6> adb_service_length = strlen ( adb_service ) ;\n<7> result = send ( sock , adb_service , ( int ) adb_service_length , 0 ) ;\n<8> if ( result != ( gssize ) adb_service_length ) {\n<14> while ( used_buffer_length < 4 ) {\n<15> result = recv ( sock , buffer + used_buffer_length , ( int ) ( buffer_length - used_buffer_length ) , 0 ) ;\n<16> if ( result <= 0 ) {\n<22> memcpy ( status , buffer , 4 ) ;\n<23> while ( result > 0 ) {\n<24> result = recv ( sock , buffer + used_buffer_length , ( int ) ( buffer_length - used_buffer_length ) , 0 ) ;\n<25> if ( result < 0 ) {\n<29> else if ( result == 0 ) {\n<32> used_buffer_length += result ;\n<35> if ( memcmp ( status , "OKAY" , 4 ) ) {\n<36> errmsg_print ( "ERROR: Error while receiving by ADB for <%s>" , adb_service ) ;\n<37> if ( data_length ) * data_length = 0 ;\n<38> return NULL ;\n<40> return buffer + 4 ;
<1> static void qemu_tcg_init_cpu_signals ( void ) {\n<4> memset ( & sigact , 0 , sizeof ( sigact ) ) ;\n<6> sigaction ( SIG_IPI , & sigact , NULL ) ;
<1> static void decode(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt,\n<15> if (ret < 0) {\n<17> fprintf(stderr, "Error sending a packet for decoding\n");\n<27> ret = avcodec_receive_frame(dec_ctx, frame);\n<29> if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)\n<33> else if (ret < 0) {\n<35> fprintf(stderr, "Error during decoding\n");\n<43> printf("saving frame %3d\n", dec_ctx->frame_number);\n<53> snprintf(buf, sizeof(buf), filename, dec_ctx->frame_number);
<1> static void socket_sendf(int fd, const char *fmt, va_list ap)\n<11> str = g_strdup_vprintf(fmt, ap);\n<13> size = strlen(str);\n<19> while (offset < size) {\n<25> len = write(fd, str + offset, size - offset);
<1> int ff_v4l2_m2m_codec_init(AVCodecContext *avctx)\n<15> V4L2m2mContext *s = avctx->priv_data;\n<33> if (strncmp(entry->d_name, "video", 5))\n<41> av_log(s->avctx, AV_LOG_DEBUG, "probing device %s\n", node);\n<43> strncpy(s->devname, node, strlen(node) + 1);\n<45> ret = v4l2_probe_driver(s);\n<59> if (ret) {\n<63> memset(s->devname, 0, sizeof(s->devname));\n<73> av_log(s->avctx, AV_LOG_INFO, "Using device %s\n", node);\n<77> return v4l2_configure_contexts(s);
<1> static int dvbsub_parse_clut_segment(AVCodecContext *avctx,\n<61> if (!clut) {\n<63> clut = av_malloc(sizeof(DVBSubCLUT));\n<69> memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n<81> ctx->clut_list = clut;\n<87> if (clut->version != version) {
<1> rfbBool rfbSendTextChatMessage ( rfbClientPtr cl , uint32_t length , char * buffer ) {\n<4> memset ( ( char * ) & tc , 0 , sizeof ( tc ) ) ;\n<5> tc . type = rfbTextChat ;\n<6> tc . length = Swap32IfLE ( length ) ;\n<13> if ( cl -> ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE ) {\n<14> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n<16> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & tc , sz_rfbTextChatMsg ) ;\n<17> cl -> ublen += sz_rfbTextChatMsg ;\n<18> if ( bytesToSend > 0 ) {\n<19> memcpy ( & cl -> updateBuf [ cl -> ublen ] , buffer , bytesToSend ) ;\n<20> cl -> ublen += bytesToSend ;\n<22> rfbStatRecordMessageSent ( cl , rfbTextChat , sz_rfbTextChatMsg + bytesToSend , sz_rfbTextChatMsg + bytesToSend ) ;
<1> static int load ( const char * append_string ) {\n<7> blk = TSIOBufferStart ( append_buffer ) ;\n<10> if ( append_string != nullptr ) {\n<11> TSIOBufferProduce ( append_buffer , strlen ( append_string ) ) ;
<1> int main ( int argc , char * * argv ) {\n<5> MY_INIT ( argv [ 0 ] ) ;\n<57> argument < argc ;\n<59> size_t argument_length = strlen ( argv [ argument ] ) ;\n<60> if ( argument_length > NAME_LEN ) {\n<61> die ( EX_CONSCHECK , "[ERROR] Argument '%s' is too long, it cannot be " "name for any table or database.\n" , argv [ argument ] ) ;\n<65> if ( ! opt_alltspcs && ! opt_notspcs ) dump_tablespaces_for_tables ( * argv , ( argv + 1 ) , ( argc - 1 ) ) ;\n<66> dump_selected_tables ( * argv , ( argv + 1 ) , ( argc - 1 ) ) ;\n<69> if ( ! opt_alltspcs && ! opt_notspcs ) dump_tablespaces_for_databases ( argv ) ;\n<70> dump_databases ( argv ) ;
<1> write_f(int argc, char **argv)\n<25> while ((c = getopt(argc, argv, "CpP:q")) != EOF) {\n<69> offset = cvtnum(argv[optind]);\n<71> if (offset < 0) {\n<73> printf("non-numeric length argument -- %s\n", argv[optind]);\n<83> count = cvtnum(argv[optind]);\n<85> if (count < 0) {\n<87> printf("non-numeric length argument -- %s\n", argv[optind]);\n<97> if (offset & 0x1ff) {\n<109> if (count & 0x1ff) {\n<141> if (cnt < 0) {\n<143> printf("write failed: %s\n", strerror(-cnt));
<1> static int shorten_decode_frame(AVCodecContext *avctx, void *data,\n<9> const uint8_t *buf = avpkt->data;\n<13> ShortenContext *s  = avctx->priv_data;\n<41> s->bitstream = tmp_ptr;\n<51> buf_size       = FFMIN(buf_size, s->max_framesize - s->bitstream_size);\n<57> if (s->bitstream_index + s->bitstream_size + buf_size >\n<61> memmove(s->bitstream, &s->bitstream[s->bitstream_index],\n<69> if (buf)\n<71> memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf,\n<75> buf               = &s->bitstream[s->bitstream_index];\n<77> buf_size         += s->bitstream_size;\n<109> if ((ret = read_header(s)) < 0)\n<193> unsigned blocksize = get_uint(s, av_log2(s->blocksize));\n<353> fix_bitshift(s, s->decoded[channel]);
<1> static int qdm2_parse_packet(AVFormatContext *s, PayloadContext *qdm,\n<29> if (qdm->n_pkts > 0) {\n<37> memset(qdm->len, 0, sizeof(qdm->len));\n<43> if ((res = qdm2_parse_config(qdm, st, ++p, end)) < 0)\n<73> if ((res = qdm2_parse_subpacket(qdm, st, p, end)) < 0)\n<102> if (!qdm->cache || (res = qdm2_restore_block(qdm, st, pkt)) < 0)
<1> static void show_commit ( struct commit * commit , void * data ) {\n<16> if ( info -> show_timestamp ) printf ( "%lu " , commit -> date ) ;\n<18> if ( ! revs -> graph ) fputs ( get_revision_mark ( revs , commit ) , stdout ) ;\n<23> while ( parents ) {\n<24> printf ( " %s" , oid_to_hex ( & parents -> item -> object . oid ) ) ;\n<31> while ( children ) {\n<32> printf ( " %s" , oid_to_hex ( & children -> item -> object . oid ) ) ;\n<36> show_decorations ( revs , commit ) ;\n<39> if ( revs -> verbose_header && get_cached_commit_buffer ( commit , NULL ) ) {\n<49> pretty_print_commit ( & ctx , commit , & buf ) ;\n<74> finish_commit ( commit , data ) ;
<1> static int curl_open(BlockDriverState *bs, const char *filename, int flags)\n<5> BDRVCURLState *s = bs->opaque;\n<29> file = strdup(filename);\n<37> ra = file + strlen(file) - 1;\n<39> while (ra >= file) {\n<53> if (*ra > '9' || *ra < '0') {\n<55> char *opt_start = ra - strlen(RA_OPTSTR) + 1;\n<57> if (opt_start > file &&\n<59> strncmp(opt_start, RA_OPTSTR, strlen(RA_OPTSTR)) == 0) {\n<61> ra_val = ra + 1;\n<63> ra -= strlen(RA_OPTSTR) - 1;\n<87> if ((s->readahead_size & 0x1ff) != 0) {\n<89> fprintf(stderr, "HTTP_READAHEAD_SIZE %zd is not a multiple of 512\n",\n<115> if (!state)\n<129> if (curl_easy_perform(state->curl))\n<143> else if(!s->len)\n<181> fprintf(stderr, "CURL: Error opening file: %s\n", state->errmsg);
<1> static void xml_print_str ( WriterContext * wctx , const char * key , const char * value ) {\n<4> const struct section * section = wctx -> section [ wctx -> level ] ;\n<6> if ( section -> flags & SECTION_FLAG_HAS_VARIABLE_FIELDS ) {\n<8> printf ( "<%s key=\"%s\"" , section -> element_name , xml_escape_str ( & buf , key , wctx ) ) ;\n<10> printf ( " value=\"%s\"/>\n" , xml_escape_str ( & buf , value , wctx ) ) ;\n<13> if ( wctx -> nb_item [ wctx -> level ] ) printf ( " " ) ;\n<14> printf ( "%s=\"%s\"" , key , xml_escape_str ( & buf , value , wctx ) ) ;
<1> static void test_bug1946 ( ) {\n<10> stmt = mysql_simple_prepare ( mysql , query ) ;\n<12> rc = mysql_real_query ( mysql , query , strlen ( query ) ) ;\n<13> DIE_UNLESS ( rc != 0 ) ;\n<14> if ( ! opt_silent ) fprintf ( stdout , "Got error (as expected):\n" ) ;\n<17> rc = mysql_query ( mysql , "DROP TABLE prepare_command" ) ;
<1> static int xface_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n<7> XFaceContext *xface = avctx->priv_data;\n<11> uint8_t bitmap_copy[XFACE_PIXELS];\n<25> if (avctx->width || avctx->height) {\n<27> if (avctx->width != XFACE_WIDTH || avctx->height != XFACE_HEIGHT) {\n<57> xface->bitmap[i++] = (buf[j]>>(7-k))&1;\n<67> } while (i < XFACE_PIXELS);\n<73> memcpy(bitmap_copy, xface->bitmap, XFACE_PIXELS);\n<75> ff_xface_generate_face(xface->bitmap, bitmap_copy);
<1> static size_t curl_size_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n<13> if(sscanf(ptr, "Content-Length: %zd", &fsize) == 1) {\n<15> s->s->len = fsize;
<1> static int flv_write_packet(AVFormatContext *s, int stream_index,\n<3> const uint8_t *buf, int size, int64_t timestamp)\n<15> if (enc->codec_type == CODEC_TYPE_VIDEO) {\n<17> FLVFrame *frame = av_malloc(sizeof(FLVFrame));\n<35> frame->data = av_malloc(size);\n<37> memcpy(frame->data,buf,size);\n<43> InsertSorted(flv,frame);
<1> GList * completion_get_chatnets ( const char * word ) {\n<5> g_return_val_if_fail ( word != NULL , NULL ) ;\n<6> len = strlen ( word ) ;\n<12> if ( g_ascii_strncasecmp ( rec -> name , word , len ) == 0 ) list = g_list_append ( list , g_strdup ( rec -> name ) ) ;
<1> static int mp_decode_frame(AVCodecContext *avctx,\n<9> const uint8_t *buf = avpkt->data;\n<13> MotionPixelsContext *mp = avctx->priv_data;\n<37> av_fast_malloc(&mp->bswapbuf, &mp->bswapbuf_size, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<39> if (!mp->bswapbuf)\n<45> if (buf_size & 3)\n<47> memcpy(mp->bswapbuf + (buf_size & ~3), buf + (buf_size & ~3), buf_size & 3);\n<53> memset(mp->changes_map, 0, avctx->width * avctx->height);\n<61> mp_read_changes_map(mp, &gb, count1, 8, i);\n<63> mp_read_changes_map(mp, &gb, count2, 4, i);\n<85> mp_read_codes_table(mp, &gb);\n<103> mp_decode_frame_helper(mp, &gb);
<1> static void init_dev(tc58128_dev * dev, const char *filename)\n<11> dev->flash_contents = g_malloc0(FLASH_SIZE);\n<13> memset(dev->flash_contents, 0xff, FLASH_SIZE);\n<15> if (!dev->flash_contents) {\n<17> fprintf(stderr, "could not alloc memory for flash\n");\n<27> ret = load_image(filename, dev->flash_contents + 528 * 32);\n<29> if (ret < 0) {\n<31> fprintf(stderr, "ret=%d\n", ret);\n<33> fprintf(stderr, "qemu: could not load flash image %s\n",\n<53> fprintf(stderr, "loaded %d bytes for %s into flash\n", ret,
<1> static int writev_f(BlockBackend *blk, int argc, char **argv)\n<115> if (cnt < 0) {\n<117> printf("writev failed: %s\n", strerror(-cnt));
<1> static void report_progress_end ( ) {\n<2> if ( last_progress_report_length ) {\n<3> printf ( "%*s\r" , last_progress_report_length , "" ) ;
<1> static int set_directory_record ( unsigned char * p , size_t n , struct isoent * isoent , struct iso9660 * iso9660 , enum dir_rec_type t , enum vdd_type vdd_type ) {\n<18> if ( t == DIR_REC_NORMAL && isoent -> identifier != NULL ) fi_len = isoent -> id_len ;\n<19> else fi_len = 1 ;\n<33> bp = p - 1 ;\n<40> bp [ 26 ] = flag ;\n<50> case DIR_REC_NORMAL : if ( isoent -> identifier != NULL ) memcpy ( bp + 34 , isoent -> identifier , fi_len ) ;\n<56> dr_len = 33 + fi_len ;\n<66> if ( iso9660 -> opt . rr && vdd_type != VDD_JOLIET ) dr_len = set_directory_record_rr ( bp , ( int ) dr_len , isoent , iso9660 , t ) ;
<1> int qemu_uuid_parse(const char *str, QemuUUID *uuid)\n<5> unsigned char *uu = &uuid->data[0];\n<11> if (strlen(str) != 36) {\n<13> return -1;\n<19> ret = sscanf(str, UUID_FMT, &uu[0], &uu[1], &uu[2], &uu[3],\n<21> &uu[4], &uu[5], &uu[6], &uu[7], &uu[8], &uu[9],\n<23> &uu[10], &uu[11], &uu[12], &uu[13], &uu[14],\n<25> &uu[15]);\n<29> if (ret != 16) {
<1> static int ogg_read_page(AVFormatContext *s, int *sid)\n<27> ret = avio_read(bc, sync, 4);\n<41> if (sync[sp & 3] == 'O' &&\n<43> sync[(sp + 1) & 3] == 'g' &&\n<45> sync[(sp + 2) & 3] == 'g' && sync[(sp + 3) & 3] == 'S')\n<51> if(!i && bc->seekable && ogg->page_pos > 0) {\n<53> memset(sync, 0, 4);\n<73> sync[sp++ & 3] = c;\n<137> os = ogg->streams + idx;\n<215> if (os->bufsize - os->bufpos < size) {\n<219> if (!nb)\n<223> memcpy(nb, os->buf, os->bufpos);\n<225> av_free(os->buf);\n<227> os->buf = nb;\n<233> ret = avio_read(bc, os->buf + os->bufpos, size);\n<235> if (ret < size)\n<241> os->bufpos += size;\n<249> memset(os->buf + os->bufpos, 0, FF_INPUT_BUFFER_PADDING_SIZE);
<1> static int cng_decode_frame(AVCodecContext *avctx, void *data,\n<5> CNGContext *p = avctx->priv_data;\n<14> memset(p->target_refl_coef, 0, p->order * sizeof(*p->target_refl_coef));\n<16> p->target_refl_coef[i] = (avpkt->data[1 + i] - 127) / 128.0;\n<23> memcpy(p->refl_coef, p->target_refl_coef, p->order * sizeof(*p->refl_coef));\n<25> make_lpc_coefs(p->lpc_coef, p->refl_coef, p->order);\n<35> if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n<38> for (i = 0; i < avctx->frame_size; i++)\n<40> memcpy(p->filter_out, p->filter_out + avctx->frame_size,\n<41> p->order * sizeof(*p->filter_out));
<1> static int dvbsub_parse_clut_segment(AVCodecContext *avctx,\n<65> if (!clut)\n<71> memcpy(clut, &default_clut, sizeof(DVBSubCLUT));\n<83> ctx->clut_list = clut;\n<89> if (clut->version != version) {
<1> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n<11> if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {\n<12> free ( ext_fb_list -> ext_fb [ i ] . data ) ;\n<13> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) ) ;
<1> static int commit_direntries(BDRVVVFATState* s,\n<3> int dir_index, int parent_mapping_index)\n<11> mapping_t* mapping = find_mapping_for_cluster(s, first_cluster);\n<29> DLOG(fprintf(stderr, "commit_direntries for %s, parent_mapping_index %d\n", mapping->path, parent_mapping_index));\n<35> assert(mapping);\n<47> mapping->info.dir.parent_mapping_index = parent_mapping_index;\n<139> array_index(&(s->mapping), mapping));
<1> static void lxc_cgroup_mount_point_free ( struct cgroup_mount_point * mp ) {\n<2> if ( ! mp ) return ;\n<3> free ( mp -> mount_point ) ;\n<4> free ( mp -> mount_prefix ) ;\n<5> free ( mp ) ;
<1> static warc_string_t _warc_rduri ( const char * buf , size_t bsz ) {\n<14> while ( val < eol && ( * val == ' ' || * val == '\t' ) ) ++ val ;\n<15> if ( ( uri = xmemmem ( val , eol - val , "://" , 3U ) ) == NULL ) {\n<23> if ( uri < ( val + 3U ) ) return res ;\n<25> if ( memcmp ( val , "file" , 4U ) == 0 ) {\n<27> else if ( memcmp ( val , "http" , 4U ) == 0 || memcmp ( val , "ftp" , 3U ) == 0 ) {\n<28> while ( uri < eol && * uri ++ != '/' ) ;\n<31> return res ;\n<33> res . str = uri ;\n<34> res . len = eol - uri ;\n<35> return res ;
<1> static void passwd ( struct parse * pcmd , FILE * fp ) {\n<5> if ( info_auth_keyid == 0 ) {\n<6> ( void ) fprintf ( fp , "Keyid must be defined\n" ) ;\n<13> if ( '\0' == pass [ 0 ] ) {\n<14> fprintf ( fp , "Password unchanged\n" ) ;
<1> static int xps_parse_gradient_stops ( xps_document * doc , char * base_uri , fz_xml * node , struct stop * stops , int maxcount ) {\n<10> while ( node && count < maxcount ) {\n<11> if ( ! strcmp ( fz_xml_tag ( node ) , "GradientStop" ) ) {\n<12> char * offset = fz_xml_att ( node , "Offset" ) ;\n<13> char * color = fz_xml_att ( node , "Color" ) ;\n<14> if ( offset && color ) {\n<43> qsort ( stops , count , sizeof ( struct stop ) , cmp_stop ) ;\n<55> if ( before > 0 ) {\n<56> memmove ( stops , stops + before , ( count - before ) * sizeof ( struct stop ) ) ;\n<61> stops [ 1 ] = stops [ 0 ] ;\n<82> if ( stops [ 0 ] . offset > 0 ) {\n<83> memmove ( stops + 1 , stops , count * sizeof ( struct stop ) ) ;\n<84> stops [ 0 ] = stops [ 1 ] ;\n<89> stops [ count ] = stops [ count - 1 ] ;
<1> int udpv6_sendmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len ) {\n<55> if ( up -> pending ) {\n<57> if ( likely ( up -> pending ) ) {\n<68> memset ( & fl , 0 , sizeof ( fl ) ) ;\n<94> if ( msg -> msg_controllen ) {\n<95> opt = & opt_space ;\n<96> memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ;\n<98> err = datagram_send_ctl ( sock_net ( sk ) , msg , & fl , opt , & hlimit , & tclass , & dontfrag ) ;\n<103> if ( ( fl . fl6_flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) {\n<104> flowlabel = fl6_sock_lookup ( sk , fl . fl6_flowlabel ) ;\n<114> if ( ! ipv6_addr_any ( daddr ) ) ipv6_addr_copy ( & fl . fl6_dst , daddr ) ;\n<116> if ( ipv6_addr_any ( & fl . fl6_src ) && ! ipv6_addr_any ( & np -> saddr ) ) ipv6_addr_copy ( & fl . fl6_src , & np -> saddr ) ;\n<120> ipv6_addr_copy ( & final , & fl . fl6_dst ) ;\n<121> ipv6_addr_copy ( & fl . fl6_dst , rt0 -> addr ) ;\n<125> if ( ! fl . oif && ipv6_addr_is_multicast ( & fl . fl6_dst ) ) {\n<129> security_sk_classify_flow ( sk , & fl ) ;\n<130> err = ip6_sk_dst_lookup ( sk , & dst , & fl ) ;\n<132> if ( final_p ) ipv6_addr_copy ( & fl . fl6_dst , final_p ) ;\n<133> err = __xfrm_lookup ( sock_net ( sk ) , & dst , & fl , sk , XFRM_LOOKUP_WAIT ) ;\n<135> if ( err == - EREMOTE ) err = ip6_dst_blackhole ( sk , & dst , & fl ) ;\n<139> if ( ipv6_addr_is_multicast ( & fl . fl6_dst ) ) hlimit = np -> mcast_hops ;\n<156> err = ip6_append_data ( sk , getfrag , msg -> msg_iov , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl , ( struct rt6_info * ) dst , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags , dontfrag ) ;
<1> static void CloseDecoder ( vlc_object_t * p_this ) {\n<3> decoder_sys_t * p_sys = p_dec -> p_sys ;\n<4> if ( p_sys -> iconv_handle != ( vlc_iconv_t ) - 1 ) vlc_iconv_close ( p_sys -> iconv_handle ) ;\n<5> free ( p_sys ) ;
<1> static PyObject * string_repeat ( register PyStringObject * a , register Py_ssize_t n ) {\n<12> size = Py_SIZE ( a ) * n ;\n<24> ( void ) PyObject_INIT_VAR ( op , & PyString_Type , size ) ;\n<27> op -> ob_sval [ size ] = '\0' ;\n<28> if ( Py_SIZE ( a ) == 1 && n > 0 ) {\n<29> memset ( op -> ob_sval , a -> ob_sval [ 0 ] , n ) ;\n<30> return ( PyObject * ) op ;
<1> static inline int parse_command_line(AVFormatContext *s, const char *line,\n<2> int linelen, char *uri, int urisize,\n<3> char *method, int methodsize,\n<6> RTSPState *rt = s->priv_data;\n<8> linept = strchr(line, ' ');\n<9> if (linept - line > methodsize - 1) {\n<13> memcpy(method, line, linept - line);\n<14> method[linept - line] = '\0';\n<15> linept++;\n<16> if (!strcmp(method, "ANNOUNCE"))\n<17> *methodcode = ANNOUNCE;\n<18> else if (!strcmp(method, "OPTIONS"))\n<19> *methodcode = OPTIONS;\n<20> else if (!strcmp(method, "RECORD"))\n<21> *methodcode = RECORD;\n<22> else if (!strcmp(method, "SETUP"))\n<23> *methodcode = SETUP;\n<24> else if (!strcmp(method, "PAUSE"))\n<25> *methodcode = PAUSE;\n<26> else if (!strcmp(method, "TEARDOWN"))\n<27> *methodcode = TEARDOWN;\n<29> *methodcode = UNKNOWN;\n<32> if ((*methodcode != ANNOUNCE) && (*methodcode != OPTIONS)) {\n<38> if ((*methodcode != OPTIONS) && (*methodcode != RECORD)\n<45> if ((*methodcode != PAUSE) && (*methodcode != OPTIONS)\n<55> searchlinept = strchr(linept, ' ');\n<56> if (!searchlinept) {\n<59> if (searchlinept - linept > urisize - 1) {\n<63> memcpy(uri, linept, searchlinept - linept);\n<64> uri[searchlinept - linept] = '\0';\n<65> if (strcmp(rt->control_uri, uri)) {\n<66> char host[128], path[512], auth[128];\n<68> char ctl_host[128], ctl_path[512], ctl_auth[128];\n<70> av_url_split(NULL, 0, auth, sizeof(auth), host, sizeof(host), &port,\n<71> path, sizeof(path), uri);\n<72> av_url_split(NULL, 0, ctl_auth, sizeof(ctl_auth), ctl_host,\n<73> sizeof(ctl_host), &ctl_port, ctl_path, sizeof(ctl_path),\n<74> rt->control_uri);\n<75> if (strcmp(host, ctl_host))\n<76> av_log(s, AV_LOG_INFO, "Host %s differs from expected %s\n",\n<78> if (strcmp(path, ctl_path) && *methodcode != SETUP)\n<79> av_log(s, AV_LOG_WARNING, "WARNING: Path %s differs from expected"\n<81> if (*methodcode == ANNOUNCE) {
<1> int test_mod_exp_mont_consttime ( BIO * bp , BN_CTX * ctx ) {\n<31> if ( ! BN_is_zero ( b ) ) {\n<32> fprintf ( stderr , "Modulo exponentiation test failed!\n" ) ;
<1> static int try_delta ( struct unpacked * trg , struct unpacked * src , unsigned max_depth , unsigned long * mem_usage ) {\n<2> struct object_entry * trg_entry = trg -> entry ;\n<59> if ( ! delta_buf ) return 0 ;\n<60> if ( trg_entry -> delta ) {\n<61> if ( delta_size == trg_entry -> delta_size && src -> depth + 1 >= trg -> depth ) {\n<62> free ( delta_buf ) ;\n<66> free ( trg_entry -> delta_data ) ;\n<72> if ( delta_cacheable ( src_size , trg_size , delta_size ) ) {\n<79> free ( delta_buf ) ;
<1> static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n<3> const uint8_t *src, int width,\n<27> if (l->zeros_rem) {\n<29> count = FFMIN(l->zeros_rem, width - i);\n<31> memset(dst, 0, count);\n<33> l->zeros_rem -= count;\n<35> dst += count;\n<41> while (dst < end) {\n<43> i = 0;\n<47> i++;\n<51> !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n<55> if (zero_run) {\n<59> i += esc_count;\n<61> memcpy(dst, src, i);\n<63> dst += i;\n<65> l->zeros_rem = lag_calc_zero_run(src[i]);\n<69> src += i + 1;\n<75> memcpy(dst, src, i);\n<77> src += i;
<1> static void option_date_format ( const char * fmt ) {\n<2> if ( ! strcmp ( fmt , "raw" ) ) whenspec = WHENSPEC_RAW ;\n<3> else if ( ! strcmp ( fmt , "rfc2822" ) ) whenspec = WHENSPEC_RFC2822 ;\n<4> else if ( ! strcmp ( fmt , "now" ) ) whenspec = WHENSPEC_NOW ;\n<5> else die ( "unknown --date-format argument %s" , fmt ) ;
<1> static void apply_unsharp(      uint8_t *dst, int dst_stride,\n<3> const uint8_t *src, int src_stride,\n<5> int width, int height, FilterParam *fp)\n<9> uint32_t **sc = fp->sc;\n<11> uint32_t sr[(MAX_SIZE * MAX_SIZE) - 1], tmp1, tmp2;\n<25> if (dst_stride == src_stride)\n<27> memcpy(dst, src, src_stride * height);\n<31> for (y = 0; y < height; y++, dst += dst_stride, src += src_stride)\n<33> memcpy(dst, src, width);\n<41> for (y = 0; y < 2 * fp->steps_y; y++)\n<43> memset(sc[y], 0, sizeof(sc[y][0]) * (width + 2 * fp->steps_x));\n<47> for (y = -fp->steps_y; y < height + fp->steps_y; y++) {\n<55> memset(sr, 0, sizeof(sr[0]) * (2 * fp->steps_x - 1));\n<63> tmp2 = sr[z + 0] + tmp1; sr[z + 0] = tmp1;\n<65> tmp1 = sr[z + 1] + tmp2; sr[z + 1] = tmp2;
<1> static int ivi_decode_blocks(GetBitContext *gb, IVIBandDesc *band, IVITile *tile,\n<7> int32_t     prev_dc, trvec[64];\n<61> memset(trvec, 0, num_coeffs*sizeof(trvec[0])); /* zero transform vector */\n<62> memset(col_flags, 0, sizeof(col_flags));      /* zero column flags */\n<95> prev_dc      += trvec[0];\n<97> col_flags[0] |= !!prev_dc;\n<99> band->inv_transform(trvec, band->buf + buf_offs,
<1> PCIDevice *pci_rtl8139_init(PCIBus *bus, NICInfo *nd, int devfn)\n<49> cpu_register_io_memory(0, rtl8139_mmio_read, rtl8139_mmio_write, s);\n<67> memcpy(s->macaddr, nd->macaddr, 6);\n<69> rtl8139_reset(s);\n<71> s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<77> qemu_format_nic_info_str(s->vc, s->macaddr);
<1> static cmsBool Type_MPEclut_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n<9> if ( ! _cmsWriteUInt16Number ( io , ( cmsUInt16Number ) mpe -> OutputChannels ) ) return FALSE ;\n<10> memset ( Dimensions8 , 0 , sizeof ( Dimensions8 ) ) ;\n<14> if ( ! io -> Write ( io , 16 , Dimensions8 ) ) return FALSE ;
<1> static int add_stop_slave ( void ) {\n<2> if ( opt_comments ) fprintf ( md_result_file , "\n--\n-- stop slave statement to make a recovery dump)\n--\n\n" ) ;
<1> static void test_bug13524 ( ) {\n<6> const char * query = "select * from t1" ;\n<16> check_execute ( stmt , rc ) ;\n<17> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<18> check_execute ( stmt , rc ) ;
<1> static int opt_preset(const char *opt, const char *arg)\n<7> char tmp[1000], tmp2[1000], line[1000];\n<11> const char *base[3]= { getenv("HOME"),\n<21> for(i=!base[0]; i<3 && !f; i++){\n<23> snprintf(tmp, sizeof(tmp), "%s/%sffmpeg/%s.ffpreset", base[i], i ? "" : ".", arg);\n<25> f= fopen(tmp, "r");\n<35> snprintf(tmp, sizeof(tmp), "%s/%sffmpeg/%s-%s.ffpreset", base[i],  i ? "" : ".", codec_name, arg);\n<37> f= fopen(tmp, "r");\n<51> if(!f){\n<53> fprintf(stderr, "Preset file not found\n");\n<61> while(!feof(f)){\n<63> int e= fscanf(f, "%999[^\n]\n", line) - 1;\n<65> if(line[0] == '#' && !e)\n<69> e|= sscanf(line, "%999[^=]=%999[^\n]\n", tmp, tmp2) - 2;\n<71> if(e){\n<73> fprintf(stderr, "Preset file invalid\n");\n<79> if(!strcmp(tmp, "acodec")){\n<81> opt_audio_codec(tmp2);\n<83> }else if(!strcmp(tmp, "vcodec")){\n<85> opt_video_codec(tmp2);\n<87> }else if(!strcmp(tmp, "scodec")){\n<89> opt_subtitle_codec(tmp2);\n<93> opt_default(tmp, tmp2);
<1> static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal)\n<53> ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);\n<59> for (i = 1; i < s->threads_number; i++) {\n<61> s->sList[i] = av_malloc(sizeof(HEVCContext));\n<63> memcpy(s->sList[i], s, sizeof(HEVCContext));\n<67> s->sList[i]->HEVClc = s->HEVClcList[i];\n<125> av_log(s->avctx, AV_LOG_ERROR, "entry_point_offset table is corrupted\n");\n<141> s->data = data;\n<145> for (i = 1; i < s->threads_number; i++) {\n<151> memcpy(s->sList[i], s, sizeof(HEVCContext));\n<153> s->sList[i]->HEVClc = s->HEVClcList[i];\n<159> avpriv_atomic_int_set(&s->wpp_err, 0);\n<161> ff_reset_entries(s->avctx);\n<177> s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<7> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<13> if ( ( ret = ff_reget_buffer ( avctx , p ) ) < 0 ) {\n<23> qpeg_decode_intra ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height ) ;\n<26> qpeg_decode_inter ( a , outdata , a -> pic . linesize [ 0 ] , avctx -> width , avctx -> height , delta , ctable , a -> refdata ) ;\n<28> if ( pal ) {\n<30> memcpy ( a -> pal , pal , AVPALETTE_SIZE ) ;\n<32> memcpy ( a -> pic . data [ 1 ] , a -> pal , AVPALETTE_SIZE ) ;
<1> static void search_set_from_hostname ( void ) {\n<4> if ( gethostname ( hostname , sizeof ( hostname ) ) ) return ;\n<5> domainname = strchr ( hostname , '.' ) ;\n<6> if ( ! domainname ) return ;
<1> static void test_bug9478 ( ) {\n<14> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<19> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<27> if ( ! opt_silent && i == 0 ) printf ( "Fetched row: %s\n" , a ) ;\n<32> if ( ! opt_silent && i == 0 ) printf ( "Fetched row: %s\n" , a ) ;\n<41> if ( ! opt_silent && i == 0 ) printf ( "Got error (as expected): %s\n" , mysql_error ( mysql ) ) ;\n<47> if ( ! opt_silent && i == 0 ) printf ( "Fetched row: %s\n" , a ) ;\n<52> if ( ! opt_silent && i == 0 ) printf ( "Got error (as expected): %s\n" , mysql_stmt_error ( stmt ) ) ;\n<66> if ( ! opt_silent && i == 0 ) printf ( "Fetched row: %s\n" , a ) ;\n<70> if ( ! opt_silent && i == 0 ) printf ( "Fetched row: %s\n" , a ) ;\n<77> if ( ! opt_silent && i == 0 ) printf ( "Fetched row: %s\n" , a ) ;\n<82> if ( ! opt_silent && i == 0 ) printf ( "Got error (as expected): %s\n" , mysql_stmt_error ( stmt ) ) ;
<1> int ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries)\n<144> if (st->codec->codec_type==AVMEDIA_TYPE_VIDEO) {\n<188> mov_read_mac_string(c, pb, len, st->codec->codec_name, 32);\n<196> if (!memcmp(st->codec->codec_name, "Planar Y'CbCr 8-bit 4:2:0", 25))\n<198> st->codec->codec_tag=MKTAG('I', '4', '2', '0');
<1> static void report_unavailable_features(FeatureWord w, uint32_t mask)\n<5> FeatureWordInfo *f = &feature_word_info[w];\n<11> for (i = 0; i < 32; ++i) {\n<13> if (1 << i & mask) {\n<17> assert(reg);\n<19> fprintf(stderr, "warning: %s doesn't support requested feature: "
<1> void xmlrpc_send_string ( const char * value ) {\n<5> mowgli_string_t * s = mowgli_string_create ( ) ;\n<9> snprintf ( buf , sizeof buf , "<?xml version=\"1.0\" encoding=\"%s\" ?>\r\n<methodResponse>\r\n<params>\r\n" , xmlrpc . encode ) ;\n<12> snprintf ( buf , sizeof buf , "<?xml version=\"1.0\"?>\r\n<methodResponse>\r\n<params>\r\n" ) ;\n<14> s -> append ( s , buf , strlen ( buf ) ) ;\n<15> ss = " <param>\r\n <value>\r\n <string>" ;\n<16> s -> append ( s , ss , strlen ( ss ) ) ;\n<17> xmlrpc_append_char_encode ( s , value ) ;\n<18> ss = "</string>\r\n </value>\r\n </param>\r\n" ;\n<19> s -> append ( s , ss , strlen ( ss ) ) ;\n<20> ss = "</params>\r\n</methodResponse>" ;\n<21> s -> append ( s , ss , strlen ( ss ) ) ;\n<22> len = s -> pos ;\n<23> if ( xmlrpc . httpheader ) {\n<24> header = xmlrpc_write_header ( len ) ;\n<25> s2 = smalloc ( strlen ( header ) + len + 1 ) ;\n<26> strcpy ( s2 , header ) ;\n<27> memcpy ( s2 + strlen ( header ) , s -> str , len ) ;\n<28> xmlrpc . setbuffer ( s2 , len + strlen ( header ) ) ;\n<29> free ( header ) ;\n<30> free ( s2 ) ;\n<34> xmlrpc . setbuffer ( s -> str , len ) ;\n<36> if ( xmlrpc . encode ) {\n<37> free ( xmlrpc . encode ) ;\n<40> s -> destroy ( s ) ;
<6> if ( render -> info . h264 . slice_count < 1 ) return ;\n<31> memcpy ( render -> info . h264 . scaling_lists_4x4 , h -> pps . scaling_matrix4 , sizeof ( render -> info . h264 . scaling_lists_4x4 ) ) ;\n<32> memcpy ( render -> info . h264 . scaling_lists_8x8 [ 0 ] , h -> pps . scaling_matrix8 [ 0 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;\n<33> memcpy ( render -> info . h264 . scaling_lists_8x8 [ 1 ] , h -> pps . scaling_matrix8 [ 3 ] , sizeof ( render -> info . h264 . scaling_lists_8x8 [ 0 ] ) ) ;
<1> static int ogg_new_stream ( AVFormatContext * s , uint32_t serial ) {\n<11> if ( av_size_mult ( ogg -> nstreams + 1 , sizeof ( * ogg -> streams ) , & size ) < 0 || ! ( os = av_realloc ( ogg -> streams , size ) ) ) return AVERROR ( ENOMEM ) ;\n<13> os = ogg -> streams + idx ;\n<14> memset ( os , 0 , sizeof ( * os ) ) ;\n<17> os -> buf = av_malloc ( os -> bufsize + AV_INPUT_BUFFER_PADDING_SIZE ) ;\n<20> if ( ! os -> buf ) return AVERROR ( ENOMEM ) ;\n<23> av_freep ( & os -> buf ) ;
<1> int av_expr_parse(AVExpr **expr, const char *s,\n<17> char *w = av_malloc(strlen(s) + 1);\n<19> char *wp = w;\n<21> const char *s0 = s;\n<27> if (!w)\n<35> if (!av_isspace(*s++)) *wp++ = s[-1];
<1> static int imc_decode_block ( AVCodecContext * avctx , IMCContext * q , int ch ) {\n<7> IMCChannel * chctx = q -> chctx + ch ;\n<15> if ( stream_format_code & 1 ) {\n<23> i ++ ) chctx -> old_floor [ i ] = 1.0 ;\n<31> if ( stream_format_code & 0x4 ) imc_decode_level_coefficients ( q , chctx -> levlCoeffBuf , chctx -> flcoeffs1 , chctx -> flcoeffs2 ) ;\n<32> else imc_decode_level_coefficients2 ( q , chctx -> levlCoeffBuf , chctx -> old_floor , chctx -> flcoeffs1 , chctx -> flcoeffs2 ) ;\n<33> memcpy ( chctx -> old_floor , chctx -> flcoeffs1 , 32 * sizeof ( float ) ) ;\n<44> memset ( chctx -> bandFlagsBuf , 0 , BANDS * sizeof ( int ) ) ;\n<50> imc_calculate_coeffs ( q , chctx -> flcoeffs1 , chctx -> flcoeffs2 , chctx -> bandWidthT , chctx -> flcoeffs3 , chctx -> flcoeffs5 ) ;\n<75> if ( ( ret = bit_allocation ( q , chctx , stream_format_code , 512 - bitscount - get_bits_count ( & q -> gb ) , flag ) ) < 0 ) {\n<90> imc_get_skip_coeff ( q , chctx ) ;\n<116> imc_adjust_bit_allocation ( q , chctx , summer ) ;\n<123> j ++ ) if ( ! chctx -> skipFlags [ j ] ) chctx -> sumLenArr [ i ] += chctx -> CWlengthT [ j ] ;\n<125> memset ( chctx -> codewords , 0 , sizeof ( chctx -> codewords ) ) ;\n<126> if ( imc_get_coeffs ( q , chctx ) < 0 ) {\n<131> if ( inverse_quant_coeff ( q , chctx , stream_format_code ) < 0 ) {\n<136> memset ( chctx -> skipFlags , 0 , sizeof ( chctx -> skipFlags ) ) ;\n<137> imc_imdct256 ( q , chctx , avctx -> channels ) ;
<1> static const gchar * gst_asf_demux_push_obj ( GstASFDemux * demux , guint32 obj_id ) {\n<4> if ( g_str_has_prefix ( nick , "ASF_OBJ_" ) ) nick += strlen ( "ASF_OBJ_" ) ;\n<6> demux -> objpath = g_strdup ( nick ) ;\n<10> newpath = g_strdup_printf ( "%s/%s" , demux -> objpath , nick ) ;
<1> static int http_parse_request(HTTPContext *c)\n<9> char cmd[32];\n<13> char url[1024], *q;\n<15> char protocol[32];\n<17> char msg[1024];\n<41> if (!strcmp(cmd, "GET"))\n<43> post = 0;\n<45> else if (!strcmp(cmd, "POST"))\n<47> post = 1;\n<51> return -1;\n<55> while (isspace(*p)) p++;\n<57> q = url;\n<59> while (!isspace(*p) && *p != '\0') {\n<69> *q = '\0';\n<73> while (isspace(*p)) p++;\n<75> q = protocol;\n<77> while (!isspace(*p) && *p != '\0') {\n<87> *q = '\0';\n<89> if (strcmp(protocol, "HTTP/1.0") && strcmp(protocol, "HTTP/1.1"))\n<91> return -1;\n<97> p = url;\n<99> if (*p == '/')\n<101> p++;\n<103> filename = p;\n<105> p = strchr(p, '?');\n<107> if (p) {\n<109> strcpy(info, p);\n<111> *p = '\0';\n<121> stream = first_stream;\n<123> while (stream != NULL) {\n<125> if (!strcmp(stream->filename, filename))\n<129> stream = stream->next;\n<133> if (stream == NULL) {\n<135> sprintf(msg, "File '%s' not found", url);\n<141> c->stream = stream;\n<163> strcpy(buf2, p);\n<165> p = buf2 + strlen(p) - 1;\n<187> if (!stream->is_feed) {\n<189> sprintf(msg, "POST command not handled");\n<195> if (http_start_receive_data(c) < 0) {\n<197> sprintf(msg, "could not open feed");\n<221> if (open_input_stream(c, info) < 0) {\n<223> sprintf(msg, "Input stream corresponding to '%s' not found", url);\n<233> q = c->buffer;\n<235> q += sprintf(q, "HTTP/1.0 200 OK\r\n");\n<239> if (!mime_type)\n<241> mime_type = "application/x-octet_stream";\n<243> q += sprintf(q, "Pragma: no-cache\r\n");\n<249> if (!strcmp(c->stream->fmt->name,"asf")) {\n<251> q += sprintf(q, "Server: Cougar 4.1.0.3923\r\nCache-Control: no-cache\r\nPragma: client-id=1234\r\nPragma: features=\"broadcast\"\r\n");\n<253> mime_type = "application/octet-stream";\n<257> q += sprintf(q, "Content-Type: %s\r\n", mime_type);\n<259> q += sprintf(q, "\r\n");\n<269> c->buffer_end = q;\n<279> q = c->buffer;\n<281> q += sprintf(q, "HTTP/1.0 404 Not Found\r\n");\n<283> q += sprintf(q, "Content-type: %s\r\n", "text/html");\n<285> q += sprintf(q, "\r\n");\n<287> q += sprintf(q, "<HTML>\n");\n<289> q += sprintf(q, "<HEAD><TITLE>404 Not Found</TITLE></HEAD>\n");\n<291> q += sprintf(q, "<BODY>%s</BODY>\n", msg);\n<293> q += sprintf(q, "</HTML>\n");\n<301> c->buffer_end = q;
<1> static void dumpcffencoding ( SplineFont * sf , struct alltabs * at ) {\n<42> putshort ( at -> encoding , at -> gn_sid [ sc -> ttf_glyph ] ) ;\n<52> free ( at -> gn_sid ) ;
<1> static int dump_all_databases ( ) {\n<13> if ( mysql_query ( mysql , "SHOW DATABASES" ) || ! ( tableres = mysql_store_result ( mysql ) ) ) {\n<14> fprintf ( stderr , "%s: Error: Couldn't execute 'SHOW DATABASES': %s\n" , my_progname_short , mysql_error ( mysql ) ) ;
<1> void kadmin_cpw ( int argc , char * argv [ ] ) {\n<5> char * canon = NULL , * pwarg = NULL ;\n<8> krb5_key_salt_tuple * ks_tuple = NULL ;\n<10> char * * db_args = NULL ;\n<12> if ( argc < 2 ) {\n<17> argc > 1 ;\n<18> argc -- , argv ++ ) {\n<19> if ( ! strcmp ( "-x" , * argv ) ) {\n<20> argc -- ;\n<21> if ( argc < 1 ) {\n<26> db_args = realloc ( db_args , sizeof ( char * ) * ( db_args_size + 1 ) ) ;\n<27> if ( db_args == NULL ) {\n<28> fprintf ( stderr , _ ( "change_password: Not enough memory\n" ) ) ;\n<31> db_args [ db_args_size - 1 ] = * ++ argv ;\n<32> db_args [ db_args_size ] = NULL ;\n<34> else if ( ! strcmp ( "-pw" , * argv ) ) {\n<35> argc -- ;\n<36> if ( argc < 1 ) {\n<40> pwarg = * ++ argv ;\n<42> else if ( ! strcmp ( "-randkey" , * argv ) ) {\n<43> randkey ++ ;\n<45> else if ( ! strcmp ( "-keepold" , * argv ) ) {\n<46> keepold = TRUE ;\n<48> else if ( ! strcmp ( "-e" , * argv ) ) {\n<49> argc -- ;\n<50> if ( argc < 1 ) {\n<54> retval = krb5_string_to_keysalts ( * ++ argv , ", \t" , ":.-" , 0 , & ks_tuple , & n_ks_tuple ) ;\n<56> com_err ( "change_password" , retval , _ ( "while parsing keysalts %s" ) , * argv ) ;\n<61> cpw_usage ( NULL ) ;\n<65> if ( * argv == NULL ) {\n<75> retval = krb5_unparse_name ( context , princ , & canon ) ;\n<81> if ( keepold || ks_tuple != NULL ) {\n<82> retval = kadm5_chpass_principal_3 ( handle , princ , keepold , n_ks_tuple , ks_tuple , pwarg ) ;\n<87> if ( retval ) {\n<88> com_err ( "change_password" , retval , _ ( "while changing password for \"%s\"." ) , canon ) ;\n<91> printf ( _ ( "Password for \"%s\" changed.\n" ) , canon ) ;\n<94> retval = randkey_princ ( princ , keepold , n_ks_tuple , ks_tuple ) ;\n<95> if ( retval ) {\n<96> com_err ( "change_password" , retval , _ ( "while randomizing key for \"%s\"." ) , canon ) ;\n<99> printf ( _ ( "Key for \"%s\" randomized.\n" ) , canon ) ;\n<104> snprintf ( prompt2 , sizeof ( prompt2 ) , _ ( "Re-enter password for principal \"%s\"" ) , canon ) ;\n<106> if ( retval ) {\n<107> com_err ( "change_password" , retval , _ ( "while reading password for \"%s\"." ) , canon ) ;\n<110> if ( keepold || ks_tuple != NULL ) {\n<111> retval = kadm5_chpass_principal_3 ( handle , princ , keepold , n_ks_tuple , ks_tuple , newpw ) ;\n<116> memset ( newpw , 0 , sizeof ( newpw ) ) ;\n<117> if ( retval ) {\n<118> com_err ( "change_password" , retval , _ ( "while changing password for \"%s\"." ) , canon ) ;\n<121> printf ( _ ( "Password for \"%s\" changed.\n" ) , canon ) ;\n<123> cleanup : free ( canon ) ;\n<124> free ( db_args ) ;\n<126> free ( ks_tuple ) ;
<1> static int mpc7_decode_frame(AVCodecContext * avctx,\n<13> MPCContext *c = avctx->priv_data;\n<31> memset(bands, 0, sizeof(bands));\n<141> memset(c->Q, 0, sizeof(c->Q));\n<149> idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n<153> ff_mpc_dequantize_and_synth(c, mb, data);
<1> static inline void copy(LZOContext *c, int cnt)\n<10> if (cnt > c->in_end - src) {\n<12> cnt       = FFMAX(c->in_end - src, 0);\n<18> if (cnt > c->out_end - dst) {\n<20> cnt       = FFMAX(c->out_end - dst, 0);\n<40> memcpy(dst, src, cnt);\n<42> c->in  = src + cnt;\n<44> c->out = dst + cnt;
<1> int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n<7> if (av_strstart(p, "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &p)) {\n<15> int len = strlen(p) * 6 / 8;\n<17> char *buf = av_mallocz(len);\n<27> av_base64_decode(buf, p, len);
<1> static void av_estimate_timings(AVFormatContext *ic)\n<13> file_size = 0;\n<19> if (file_size < 0)\n<21> file_size = 0;\n<29> if ((!strcmp(ic->iformat->name, "mpeg") ||\n<31> !strcmp(ic->iformat->name, "mpegts")) &&\n<33> file_size && !ic->pb.is_streamed) {\n<37> av_estimate_timings_from_pts(ic);\n<39> } else if (av_has_timings(ic)) {
<1> static int rv34_decode_mv(RV34DecContext *r, int block_type)\n<17> memset(r->dmv, 0, sizeof(r->dmv));
<1> static void musicpal_init(MachineState *machine)\n<53> if (!cpu) {\n<55> fprintf(stderr, "Unable to find CPU definition\n");\n<129> if (flash_size != 8*1024*1024 && flash_size != 16*1024*1024 &&\n<133> fprintf(stderr, "Invalid flash image size\n");
<1> static int svq3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<44> if ( ! s -> last_pic -> f . data [ 0 ] ) {\n<47> if ( ret < 0 ) return ret ;\n<48> memset ( s -> last_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> last_pic -> f . linesize [ 0 ] ) ;\n<49> memset ( s -> last_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 1 ] ) ;\n<50> memset ( s -> last_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> last_pic -> f . linesize [ 2 ] ) ;\n<52> if ( h -> pict_type == AV_PICTURE_TYPE_B && ! s -> next_pic -> f . data [ 0 ] ) {\n<55> if ( ret < 0 ) return ret ;\n<56> memset ( s -> next_pic -> f . data [ 0 ] , 0 , avctx -> height * s -> next_pic -> f . linesize [ 0 ] ) ;\n<57> memset ( s -> next_pic -> f . data [ 1 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 1 ] ) ;\n<58> memset ( s -> next_pic -> f . data [ 2 ] , 0x80 , ( avctx -> height / 2 ) * s -> next_pic -> f . linesize [ 2 ] ) ;\n<123> if ( s -> last_pic -> f . data [ 0 ] || h -> low_delay ) * got_frame = 1 ;
<1> static void ahci_test_identify(AHCIQState *ahci)\n<3> uint16_t buff[256];\n<35> ahci_io(ahci, px, CMD_IDENTIFY, &buff, buffsize);\n<41> string_bswap16(&buff[10], 20);\n<42> rc = memcmp(&buff[10], "testdisk            ", 20);\n<44> string_bswap16(&buff[23], 8);\n<45> rc = memcmp(&buff[23], "version ", 8);
<1> static int debugcon_parse(const char *devname)\n<17> if (!opts) {\n<19> fprintf(stderr, "qemu: already have a debugcon device\n");
<1> static int qemuMonitorTextCommandNotFound ( const char * cmd , const char * reply ) {\n<2> if ( STRPREFIX ( cmd , "info " ) ) {\n<3> if ( strstr ( reply , "info version" ) ) return 1 ;\n<6> if ( strstr ( reply , "unknown command:" ) ) return 1 ;\n<8> return 0 ;
<1> static void pc_init1(ram_addr_t ram_size,\n<161> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<185> if (ret != bios_size) {\n<189> fprintf(stderr, "qemu: could not load PC BIOS '%s'\n", bios_name);\n<357> if (pci_enabled)\n<363> fprintf(stderr, "%s: vmware_vga: no PCI bus\n", __FUNCTION__);\n<437> for(i = 0; i < nb_nics; i++) {\n<439> NICInfo *nd = &nd_table[i];\n<443> if (!pci_enabled || (nd->model && strcmp(nd->model, "ne2k_isa") == 0))\n<445> pc_init_ne2k_isa(nd);\n<449> pci_nic_init_nofail(nd, "e1000", NULL);\n<455> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<457> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static uint64_t *l2_allocate(BlockDriverState *bs, int l1_index)\n<53> l2_table = s->l2_cache + (min_index << s->l2_bits);\n<57> if (old_l2_offset == 0) {\n<61> memset(l2_table, 0, s->l2_size * sizeof(uint64_t));
<1> static BusState *qbus_find(const char *path)\n<9> char elem[128];\n<17> if (path[0] == '/') {\n<21> pos = 0;\n<25> if (sscanf(path, "%127[^/]%n", elem, &len) != 1) {\n<27> assert(!path[0]);\n<29> elem[0] = len = 0;\n<33> bus = qbus_find_recursive(sysbus_get_default(), elem, NULL);\n<51> pos = len;\n<59> assert(path[pos] == '/' || !path[pos]);\n<61> while (path[pos] == '/') {\n<63> pos++;\n<67> if (path[pos] == '\0') {\n<77> if (sscanf(path+pos, "%127[^/]%n", elem, &len) != 1) {\n<79> g_assert_not_reached();\n<81> elem[0] = len = 0;\n<85> pos += len;\n<87> dev = qbus_find_dev(bus, elem);\n<105> assert(path[pos] == '/' || !path[pos]);\n<107> while (path[pos] == '/') {\n<109> pos++;\n<113> if (path[pos] == '\0') {\n<155> if (sscanf(path+pos, "%127[^/]%n", elem, &len) != 1) {\n<157> g_assert_not_reached();\n<159> elem[0] = len = 0;\n<163> pos += len;\n<165> bus = qbus_find_bus(dev, elem);
<1> static int unlock_remote ( struct remote_lock * lock ) {\n<10> curl_setup_http_get ( slot -> curl , lock -> url , DAV_UNLOCK ) ;\n<12> if ( start_active_slot ( slot ) ) {\n<14> if ( results . curl_result == CURLE_OK ) rc = 1 ;\n<15> else fprintf ( stderr , "UNLOCK HTTP error %ld\n" , results . http_code ) ;\n<18> fprintf ( stderr , "Unable to start UNLOCK request\n" ) ;\n<21> if ( repo -> locks == lock ) {\n<25> while ( prev && prev -> next != lock ) prev = prev -> next ;\n<28> free ( lock -> owner ) ;\n<29> free ( lock -> url ) ;\n<30> free ( lock -> token ) ;\n<31> free ( lock ) ;
<1> static int asf_read_packet(AVFormatContext *s, AVPacket *pkt)\n<180> asf_st = asf->asf_st;\n<196> av_log(s, AV_LOG_INFO, "ff asf parser skips: %d - %d     o:%d - %d    %d %d   fl:%d\n",\n<208> av_free_packet(&asf_st->pkt);\n<264> av_new_packet(&asf_st->pkt, asf->packet_obj_size);\n<268> asf_st->pkt.pts = asf->packet_frag_timestamp;\n<270> asf_st->pkt.stream_index = asf->stream_index;\n<288> asf_st->pkt.flags |= PKT_FLAG_KEY;\n<316> if (asf_st->frag_offset == asf_st->pkt.size) {\n<324> char* newdata = av_malloc(asf_st->pkt.size);\n<330> while (offset < asf_st->pkt.size) {\n<332> int off = offset / asf_st->ds_chunk_size;\n<344> asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n<348> offset += asf_st->ds_chunk_size;\n<354> asf_st->pkt.data = newdata;\n<362> memcpy(pkt, &asf_st->pkt, sizeof(AVPacket));
<1> static void ctl_putint ( const char * tag , long ival ) {\n<10> snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , "%ld" , ival ) ;\n<11> cp += strlen ( cp ) ;\n<12> ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;
<1> static struct qcms_modular_transform * qcms_modular_transform_create_mAB ( struct lutmABType * lut ) {\n<8> if ( ! lut -> clut_table ) goto fail ;\n<20> if ( ! transform ) goto fail ;\n<22> clut_length = sizeof ( float ) * pow ( lut -> num_grid_points [ 0 ] , 3 ) * 3 ;\n<23> clut = malloc ( clut_length ) ;\n<24> if ( ! clut ) goto fail ;\n<25> memcpy ( clut , lut -> clut_table , clut_length ) ;\n<26> transform -> r_clut = clut + 0 ;\n<27> transform -> g_clut = clut + 1 ;\n<28> transform -> b_clut = clut + 2 ;\n<43> transform -> matrix = build_mAB_matrix ( lut ) ;
<1> PyObject * PyString_DecodeEscape ( const char * s , Py_ssize_t len , const char * errors , Py_ssize_t unicode , const char * recode_encoding ) {\n<94> if ( ! errors || strcmp ( errors , "strict" ) == 0 ) {\n<98> if ( strcmp ( errors , "replace" ) == 0 ) {\n<101> else if ( strcmp ( errors , "ignore" ) == 0 ) ;
<1> static int qemuMonitorJSONBlockIoThrottleInfo ( virJSONValuePtr result , const char * device , virDomainBlockIoTuneInfoPtr reply ) {\n<25> if ( STRPREFIX ( current_dev , QEMU_DRIVE_HOST_PREFIX ) ) current_dev += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n<26> if ( STREQ ( current_dev , device ) ) continue ;
<1> void fz_colorspace_name_colorant ( fz_context * ctx , fz_colorspace * cs , int i , const char * name ) {\n<7> cs -> colorant [ i ] = fz_strdup ( ctx , name ) ;\n<9> if ( i == 0 ) {\n<10> if ( strcmp ( name , "Cyan" ) == 0 || strcmp ( name , "Magenta" ) == 0 || strcmp ( name , "Yellow" ) == 0 || strcmp ( name , "Black" ) == 0 ) {\n<11> cs -> flags |= FZ_CS_HAS_CMYK ;\n<15> if ( ( cs -> flags & FZ_CS_HAS_CMYK_AND_SPOTS ) != FZ_CS_HAS_CMYK_AND_SPOTS ) {\n<16> if ( strcmp ( name , "Cyan" ) == 0 || strcmp ( name , "Magenta" ) == 0 || strcmp ( name , "Yellow" ) == 0 || strcmp ( name , "Black" ) == 0 ) cs -> flags |= FZ_CS_HAS_CMYK ;\n<17> else cs -> flags |= FZ_CS_HAS_SPOTS ;
<1> static int inet_listen_saddr(InetSocketAddress *saddr,\n<13> char port[33];\n<31> memset(&ai,0, sizeof(ai));\n<33> ai.ai_flags = AI_PASSIVE;\n<37> ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n<41> ai.ai_family = inet_ai_family_from_address(saddr, &err);\n<43> ai.ai_socktype = SOCK_STREAM;\n<57> if (saddr->host == NULL) {\n<65> if (saddr->port != NULL) {\n<67> pstrcpy(port, sizeof(port), saddr->port);\n<71> port[0] = '\0';\n<79> if (port_offset) {\n<83> if (strlen(port) == 0) {\n<85> error_setg(errp, "port not specified");\n<87> return -1;\n<91> if (parse_uint_full(port, &baseport, 10) < 0) {\n<109> snprintf(port, sizeof(port), "%d", (int)baseport + port_offset);\n<113> rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n<115> strlen(port) ? port : NULL, &ai, &res);\n<117> if (rc != 0) {\n<119> error_setg(errp, "address resolution failed for %s:%s: %s",\n<131> for (e = res; e != NULL; e = e->ai_next) {\n<161> rc = try_bind(slisten, saddr, e);\n<239> freeaddrinfo(res);\n<251> g_free(saddr->host);\n<267> freeaddrinfo(res);
<1> static void run_vacuum_command ( PGconn * conn , const char * sql , bool echo , const char * table , const char * progname , bool async ) {\n<4> if ( echo ) printf ( "%s\n" , sql ) ;\n<5> status = PQsendQuery ( conn , sql ) == 1 ;\n<9> if ( table ) fprintf ( stderr , _ ( "%s: vacuuming of table \"%s\" in database \"%s\" failed: %s" ) , progname , table , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;\n<10> else fprintf ( stderr , _ ( "%s: vacuuming of database \"%s\" failed: %s" ) , progname , PQdb ( conn ) , PQerrorMessage ( conn ) ) ;
<1> int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,\n<45> AVPacket tmp = *avpkt;\n<53> if (did_split) {\n<67> FFMIN(avpkt->size - tmp.size, AV_INPUT_BUFFER_PADDING_SIZE));
<1> static kadm5_ret_t add_to_history ( krb5_context context , krb5_kvno hist_kvno , osa_princ_ent_t adb , kadm5_policy_ent_t pol , osa_pw_hist_ent * pw ) {\n<7> if ( adb -> admin_history_kvno != hist_kvno ) {\n<8> free ( adb -> old_keys ) ;\n<9> adb -> old_keys = NULL ;\n<17> if ( adb -> old_keys == NULL ) {\n<18> adb -> old_keys = ( osa_pw_hist_ent * ) malloc ( ( nkeys + 1 ) * sizeof ( osa_pw_hist_ent ) ) ;\n<21> adb -> old_keys = ( osa_pw_hist_ent * ) realloc ( adb -> old_keys , ( nkeys + 1 ) * sizeof ( osa_pw_hist_ent ) ) ;\n<23> if ( adb -> old_keys == NULL ) return ( ENOMEM ) ;\n<24> memset ( & adb -> old_keys [ nkeys ] , 0 , sizeof ( osa_pw_hist_ent ) ) ;\n<31> memset ( & adb -> old_keys [ knext ] , 0 , sizeof ( osa_pw_hist_ent ) ) ;\n<33> else if ( nkeys + 1 > nhist ) {\n<36> tmp = ( osa_pw_hist_ent * ) malloc ( ( nhist - 1 ) * sizeof ( osa_pw_hist_ent ) ) ;\n<37> if ( tmp == NULL ) return ENOMEM ;\n<45> i < nkeys - ( nhist - 1 ) ;\n<48> histp = & adb -> old_keys [ j ] ;\n<52> krb5_free_key_data_contents ( context , & histp -> key_data [ j ] ) ;\n<54> free ( histp -> key_data ) ;\n<56> free ( adb -> old_keys ) ;\n<62> histp = & adb -> old_keys [ knext ] ;\n<65> i ++ ) krb5_free_key_data_contents ( context , & histp -> key_data [ i ] ) ;\n<66> free ( histp -> key_data ) ;
<1> static void policy_mapping_destroy ( x509_policy_mapping_t * mapping ) {\n<4> free ( mapping ) ;
<1> static SlirpState * slirp_lookup ( Monitor * mon , const char * vlan , const char * stack ) {\n<5> if ( ! nc ) {\n<9> if ( strcmp ( nc -> model , "user" ) ) {\n<10> monitor_printf ( mon , "invalid device specified\n" ) ;\n<11> return NULL ;\n<13> return DO_UPCAST ( SlirpState , nc , nc ) ;
<5> fix_dependencies ( AH ) ;\n<21> reduce_dependencies ( AH , next_work_item , NULL ) ;\n<24> if ( AH -> currUser ) free ( AH -> currUser ) ;\n<26> if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n<28> if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;
<1> gcry_sexp_t gcry_sexp_find_token ( const gcry_sexp_t list , const char * tok , size_t toklen ) {\n<5> if ( ! toklen ) toklen = strlen ( tok ) ;\n<7> while ( * p != ST_STOP ) {\n<8> if ( * p == ST_OPEN && p [ 1 ] == ST_DATA ) {\n<10> p += 2 ;\n<11> memcpy ( & n , p , sizeof n ) ;\n<12> p += sizeof n ;\n<13> if ( n == toklen && ! memcmp ( p , tok , toklen ) ) {\n<16> int level = 1 ;\n<17> for ( p += n ;\n<18> level ;\n<20> if ( * p == ST_DATA ) {\n<21> memcpy ( & n , ++ p , sizeof n ) ;\n<22> p += sizeof n + n ;\n<35> n = p - head ;\n<36> newlist = gcry_malloc ( sizeof * newlist + n ) ;\n<37> if ( ! newlist ) {\n<40> d = newlist -> d ;\n<41> memcpy ( d , head , n ) ;\n<42> d += n ;\n<46> p += n ;\n<48> else if ( * p == ST_DATA ) {\n<49> memcpy ( & n , ++ p , sizeof n ) ;\n<51> p += n ;
<1> void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n<13> if (vga_ioport_invalid(s, addr)) {\n<149> s->dac_cache[s->dac_sub_index] = val;\n<151> if (++s->dac_sub_index == 3) {\n<153> memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);
<1> void var_set ( const char * var_name , const char * var_name_end , const char * var_val , const char * var_val_end ) {\n<13> eval_expr ( v , var_val , ( const char * * ) & var_val_end ) ;\n<15> if ( v -> int_dirty ) {\n<16> sprintf ( v -> str_val , "%d" , v -> int_val ) ;\n<18> v -> str_val_len = strlen ( v -> str_val ) ;\n<21> setenv ( v -> name , v -> str_val , 1 ) ;
<1> static int strncat_from_utf8_to_utf8 ( struct archive_string * as , const void * _p , size_t len , struct archive_string_conv * sc ) {\n<8> p = as -> s + as -> length ;\n<19> if ( p + ( s - ss ) > endp ) {\n<21> if ( archive_string_ensure ( as , as -> buffer_length + len + 1 ) == NULL ) return ( - 1 ) ;\n<22> p = as -> s + as -> length ;\n<25> memcpy ( p , ss , s - ss ) ;\n<26> p += s - ss ;\n<42> p += w ;
<1> static void test_nstmts ( ) {\n<13> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<17> i < total_stmts ;\n<18> i ++ ) {\n<19> if ( ! opt_silent ) fprintf ( stdout , "\r stmt: %d" , i ) ;\n<23> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<33> i = 0 ;\n<34> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<38> if ( ! opt_silent ) fprintf ( stdout , "\n total rows: %d" , i ) ;\n<39> DIE_UNLESS ( i == total_stmts ) ;
<1> static int nprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *n_val)\n<13> if (!enc_header || !n_val)\n<21> if (!memcmp(&enc_header[pos], "EKB ", 4))\n<23> pos += 32;\n<27> if (AV_RB32(&enc_header[pos]) != oc->rid)\n<47> av_des_crypt(&av_des, oc->r_val, &enc_header[pos], 2, NULL, 1);\n<51> if (!rprobe(s, enc_header, oc->r_val))
<1> static const gchar * gst_asf_demux_get_gst_tag_from_tag_name ( const gchar * name_utf8 ) {\n<25> if ( name_utf8 == NULL ) {\n<29> out = strlen ( name_utf8 ) ;\n<33> if ( strncmp ( tags [ i ] . asf_name , name_utf8 , out ) == 0 ) {
<1> static size_t save_page_header(RAMState *rs, RAMBlock *block, ram_addr_t offset)\n<9> if (block == rs->last_sent_block) {\n<21> if (!(offset & RAM_SAVE_FLAG_CONTINUE)) {\n<23> len = strlen(block->idstr);\n<25> qemu_put_byte(rs->f, len);\n<27> qemu_put_buffer(rs->f, (uint8_t *)block->idstr, len);\n<31> rs->last_sent_block = block;
<1> static void vc1_decode_p_blocks(VC1Context *v)\n<65> memset(v->cbp_base, 0, sizeof(v->cbp_base[0])*2*s->mb_stride);\n<73> for (; s->mb_x < s->mb_width; s->mb_x++) {\n<81> vc1_decode_p_mb_intfi(v);\n<85> vc1_decode_p_mb_intfr(v);\n<87> else vc1_decode_p_mb(v);\n<91> vc1_apply_p_loop_filter(v);\n<109> memmove(v->cbp_base,      v->cbp,      sizeof(v->cbp_base[0])      * s->mb_stride);\n<111> memmove(v->ttblk_base,    v->ttblk,    sizeof(v->ttblk_base[0])    * s->mb_stride);\n<113> memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride);\n<115> memmove(v->luma_mv_base,  v->luma_mv,  sizeof(v->luma_mv_base[0])  * s->mb_stride);\n<133> vc1_apply_p_loop_filter(v);
<1> static size_t readmoredata ( char * buffer , size_t size , size_t nitems , void * userp ) {\n<3> struct HTTP * http = conn -> data -> req . protop ;\n<4> size_t fullsize = size * nitems ;\n<7> if ( http -> postsize <= ( curl_off_t ) fullsize ) {\n<8> memcpy ( buffer , http -> postdata , ( size_t ) http -> postsize ) ;\n<21> memcpy ( buffer , http -> postdata , fullsize ) ;\n<22> http -> postdata += fullsize ;\n<23> http -> postsize -= fullsize ;\n<24> return fullsize ;
<1> static int get_path_component ( char * name , size_t n , const char * fn ) {\n<4> p = strchr ( fn , '/' ) ;\n<5> if ( p == NULL ) {\n<6> if ( ( l = strlen ( fn ) ) == 0 ) return ( 0 ) ;\n<8> else l = p - fn ;\n<9> if ( l > n - 1 ) return ( - 1 ) ;\n<10> memcpy ( name , fn , l ) ;\n<12> return ( ( int ) l ) ;
<1> static DriveInfo *blockdev_init(QDict *bs_opts,\n<161> if ((buf = qemu_opt_get(opts, "format")) != NULL) {\n<179> if (!drv) {\n<193> memset(&cfg, 0, sizeof(cfg));\n<251> if (!check_throttle_config(&cfg, &error)) {\n<349> if (throttle_enabled(&cfg)) {\n<353> bdrv_set_io_limits(dinfo->bdrv, &cfg);
<1> static int vmd_read_header(AVFormatContext *s,\n<7> VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data;\n<39> if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)\n<57> if (!st)\n<71> st->codec->width = LE_16(&vmd->vmd_header[12]);\n<73> st->codec->height = LE_16(&vmd->vmd_header[14]);\n<81> st->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n<83> memcpy(st->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);\n<89> vmd->sample_rate = LE_16(&vmd->vmd_header[804]);\n<115> LE_16(&vmd->vmd_header[806]);
<1> void kadmin_addpol ( int argc , char * argv [ ] ) {\n<5> memset ( & policy , 0 , sizeof ( policy ) ) ;\n<6> if ( kadmin_parse_policy_args ( argc , argv , & policy , & mask , "add_policy" ) ) {\n<12> retval = kadm5_create_policy ( handle , & policy , mask ) ;\n<14> com_err ( "add_policy" , retval , _ ( "while creating policy \"%s\"." ) , policy . policy ) ;
<1> ram_addr_t ppc4xx_sdram_adjust(ram_addr_t ram_size, int nr_banks,\n<71> if (size_left)\n<73> printf("Truncating memory to %d MiB to fit SDRAM controller limits.\n",\n<75> (int)(ram_size >> 20));
<1> static int handle_connection(HTTPContext *c)\n<43> } else if (len == 0) {\n<57> if ((ptr >= c->buffer + 2 && !memcmp(ptr-2, "\n\n", 2)) ||\n<59> (ptr >= c->buffer + 4 && !memcmp(ptr-4, "\r\n\r\n", 4))) {\n<63> if (c->state == HTTPSTATE_WAIT_REQUEST) {\n<73> if (ret < 0)\n<77> } else if (ptr >= c->buffer_end) {
<1> static int vmdk_add_extent(BlockDriverState *bs,\n<55> if (length < 0) {\n<67> extent = &s->extents[s->num_extents];\n<73> memset(extent, 0, sizeof(VmdkExtent));\n<101> extent->end_sector = (*(extent - 1)).end_sector + extent->sectors;\n<105> extent->end_sector = extent->sectors;\n<109> bs->total_sectors = extent->end_sector;\n<113> *new_extent = extent;
<1> static void bind_date_conv ( uint row_count , my_bool preserveFractions ) {\n<18> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<24> i < ( int ) array_elements ( my_bind ) ;\n<83> if ( ! opt_silent ) fprintf ( stdout , "\n" ) ;\n<85> i < array_elements ( my_bind ) ;\n<86> i ++ ) {\n<87> if ( ! opt_silent ) fprintf ( stdout , "\ntime[%d]: %02d-%02d-%02d %02d:%02d:%02d.%06lu" , i , tm [ i ] . year , tm [ i ] . month , tm [ i ] . day , tm [ i ] . hour , tm [ i ] . minute , tm [ i ] . second , tm [ i ] . second_part ) ;\n<88> DIE_UNLESS ( tm [ i ] . year == 0 || tm [ i ] . year == year + count || ( tm [ i ] . year == now_year && my_bind [ i ] . buffer_type == MYSQL_TYPE_TIME ) ) ;\n<89> DIE_UNLESS ( tm [ i ] . month == 0 || tm [ i ] . month == month + count || ( tm [ i ] . month == now_month && my_bind [ i ] . buffer_type == MYSQL_TYPE_TIME ) ) ;\n<90> DIE_UNLESS ( tm [ i ] . day == 0 || tm [ i ] . day == day + count || ( tm [ i ] . day == now_day && my_bind [ i ] . buffer_type == MYSQL_TYPE_TIME ) ) ;\n<91> DIE_UNLESS ( tm [ i ] . hour == 0 || tm [ i ] . hour == hour + count ) ;\n<92> DIE_UNLESS ( tm [ i ] . minute == 0 || tm [ i ] . minute == minute + count ) ;\n<93> DIE_UNLESS ( tm [ i ] . second == 0 || tm [ i ] . second == sec + count ) ;\n<95> if ( i == 3 ) {\n<103> DIE_UNLESS ( ( tm [ i ] . second_part == 0 ) || tm [ i ] . second_part == second_part + count ) ;
<1> TSReturnCode TSHttpTxnConfigStringSet ( TSHttpTxn txnp , TSOverridableConfigKey conf , const char * value , int length ) {\n<3> if ( length == - 1 ) {\n<4> length = strlen ( value ) ;\n<9> case TS_CONFIG_HTTP_RESPONSE_SERVER_STR : if ( value && length > 0 ) {\n<11> s -> t_state . txn_conf -> proxy_response_server_string_len = length ;\n<18> case TS_CONFIG_HTTP_GLOBAL_USER_AGENT_HEADER : if ( value && length > 0 ) {\n<20> s -> t_state . txn_conf -> global_user_agent_header_size = length ;\n<27> case TS_CONFIG_BODY_FACTORY_TEMPLATE_BASE : if ( value && length > 0 ) {\n<29> s -> t_state . txn_conf -> body_factory_template_base_len = length ;\n<36> case TS_CONFIG_SSL_CERT_FILENAME : if ( value && length > 0 ) {\n<40> case TS_CONFIG_SSL_CERT_FILEPATH : if ( value && length > 0 ) {
<1> static uint64_t get_cluster_offset(BlockDriverState *bs,\n<11> BDRVQcowState *s = bs->opaque;\n<101> l2_table = s->l2_cache + (min_index << s->l2_bits);\n<103> if (new_l2_table) {\n<105> memset(l2_table, 0, s->l2_size * sizeof(uint64_t));\n<107> if (bdrv_pwrite(bs->file, l2_offset, l2_table, s->l2_size * sizeof(uint64_t)) !=\n<197> memset(s->cluster_data + 512, 0x00, 512);
<1> static int file_compare_by_mime_type ( NautilusFile * file_a , NautilusFile * file_b ) {\n<4> mime_type_a = nautilus_file_get_mime_type ( file_a ) ;\n<5> mime_type_b = nautilus_file_get_mime_type ( file_b ) ;\n<6> ret = strcmp ( mime_type_a , mime_type_b ) ;\n<7> g_free ( mime_type_a ) ;\n<8> g_free ( mime_type_b ) ;\n<9> return ret ;
<1> unsigned int dtls_raw_hello_verify_request ( unsigned char * buf , unsigned char * cookie , unsigned char cookie_len ) {\n<7> * ( p ++ ) = ( unsigned char ) cookie_len ;\n<8> memcpy ( p , cookie , cookie_len ) ;\n<9> p += cookie_len ;
<1> static int init_directory(BDRVVVFATState* s,const char* dirname)\n<5> bootsector_t* bootsector=(bootsector_t*)&(s->first_sectors[(s->first_sectors_number-1)*0x200]);\n<13> memset(&(s->first_sectors[0]),0,0x40*0x200);\n<23> s->cluster_size=s->sectors_per_cluster*0x200;\n<25> s->cluster=malloc(s->cluster_size);\n<51> if(read_directory(s,dirname,0))\n<71> init_fat(s);\n<93> for(i=1;i<s->mapping.next;i++) {\n<115> fat_set(s,i,i+1);\n<117> fat_set(s,i,0x7fffffff);\n<123> unsigned int end_cluster=cluster+mapping->end/s->cluster_size;\n<127> if(end_cluster>=s->cluster_count) {\n<129> fprintf(stderr,"Directory does not fit in FAT%d\n",s->fat_type);\n<161> fat_set(s,cluster,cluster+1);\n<163> fat_set(s,cluster,0x7fffffff);\n<183> memcpy(bootsector->name,"QEMU    ",8);\n<225> memcpy(bootsector->u.fat16.volume_label,"QEMU VVFAT ",11);\n<227> memcpy(bootsector->fat_type,(s->fat_type==12?"FAT12   ":s->fat_type==16?"FAT16   ":"FAT32   "),8);
<1> static void test_bug28386 ( ) {\n<14> row = mysql_fetch_row ( result ) ;\n<15> if ( ! strstr ( row [ 0 ] , "TABLE" ) ) {\n<16> mysql_free_result ( result ) ;\n<17> if ( ! opt_silent ) printf ( "Skipping the test since logging to tables is not enabled\n" ) ;\n<18> return ;\n<20> mysql_free_result ( result ) ;\n<21> enable_query_logs ( 1 ) ;\n<22> stmt = mysql_simple_prepare ( mysql , "SELECT ?" ) ;\n<23> check_stmt ( stmt ) ;\n<24> memset ( & bind , 0 , sizeof ( bind ) ) ;\n<25> bind . buffer_type = MYSQL_TYPE_STRING ;\n<26> bind . buffer = ( void * ) hello ;\n<27> bind . buffer_length = sizeof ( hello ) ;\n<28> mysql_stmt_bind_param ( stmt , & bind ) ;\n<29> mysql_stmt_send_long_data ( stmt , 0 , hello , sizeof ( hello ) ) ;\n<30> rc = mysql_stmt_execute ( stmt ) ;\n<31> check_execute ( stmt , rc ) ;\n<32> rc = my_process_stmt_result ( stmt ) ;\n<33> DIE_UNLESS ( rc == 1 ) ;\n<34> rc = mysql_stmt_reset ( stmt ) ;\n<35> check_execute ( stmt , rc ) ;\n<36> rc = mysql_stmt_close ( stmt ) ;\n<37> DIE_UNLESS ( ! rc ) ;\n<38> rc = mysql_query ( mysql , "select * from mysql.general_log where " "command_type='Close stmt' or " "command_type='Reset stmt' or " "command_type='Long Data'" ) ;\n<39> myquery ( rc ) ;\n<40> result = mysql_store_result ( mysql ) ;\n<41> mytest ( result ) ;\n<42> DIE_UNLESS ( mysql_num_rows ( result ) == 3 ) ;\n<43> mysql_free_result ( result ) ;\n<44> restore_query_logs ( ) ;
<1> static void inverse_quant ( int16_t * cur_lsp , int16_t * prev_lsp , uint8_t * lsp_index , int bad_frame ) {\n<13> cur_lsp [ 0 ] = lsp_band0 [ lsp_index [ 0 ] ] [ 0 ] ;\n<14> cur_lsp [ 1 ] = lsp_band0 [ lsp_index [ 0 ] ] [ 1 ] ;\n<15> cur_lsp [ 2 ] = lsp_band0 [ lsp_index [ 0 ] ] [ 2 ] ;\n<16> cur_lsp [ 3 ] = lsp_band1 [ lsp_index [ 1 ] ] [ 0 ] ;\n<17> cur_lsp [ 4 ] = lsp_band1 [ lsp_index [ 1 ] ] [ 1 ] ;\n<18> cur_lsp [ 5 ] = lsp_band1 [ lsp_index [ 1 ] ] [ 2 ] ;\n<19> cur_lsp [ 6 ] = lsp_band2 [ lsp_index [ 2 ] ] [ 0 ] ;\n<20> cur_lsp [ 7 ] = lsp_band2 [ lsp_index [ 2 ] ] [ 1 ] ;\n<21> cur_lsp [ 8 ] = lsp_band2 [ lsp_index [ 2 ] ] [ 2 ] ;\n<22> cur_lsp [ 9 ] = lsp_band2 [ lsp_index [ 2 ] ] [ 3 ] ;\n<26> temp = ( ( prev_lsp [ i ] - dc_lsp [ i ] ) * pred + ( 1 << 14 ) ) >> 15 ;\n<27> cur_lsp [ i ] += dc_lsp [ i ] + temp ;\n<32> cur_lsp [ 0 ] = FFMAX ( cur_lsp [ 0 ] , 0x180 ) ;\n<33> cur_lsp [ LPC_ORDER - 1 ] = FFMIN ( cur_lsp [ LPC_ORDER - 1 ] , 0x7e00 ) ;\n<37> temp = min_dist + cur_lsp [ j - 1 ] - cur_lsp [ j ] ;\n<40> cur_lsp [ j - 1 ] -= temp ;\n<41> cur_lsp [ j ] += temp ;\n<48> temp = cur_lsp [ j - 1 ] + min_dist - cur_lsp [ j ] - 4 ;\n<56> if ( ! stable ) memcpy ( cur_lsp , prev_lsp , LPC_ORDER * sizeof ( * cur_lsp ) ) ;
<1> static void cmv_decode_intra(CmvContext * s, const uint8_t *buf, const uint8_t *buf_end){\n<3> unsigned char *dst = s->frame.data[0];\n<9> for (i=0; i < s->avctx->height && buf+s->avctx->width<=buf_end; i++) {\n<11> memcpy(dst, buf, s->avctx->width);\n<13> dst += s->frame.linesize[0];\n<15> buf += s->avctx->width;
<1> static Item * * find_field_in_group_list ( Item * find_item , ORDER * group_list ) {\n<38> if ( l_db_name && db_name ) {\n<39> if ( strcmp ( l_db_name , db_name ) ) return NULL ;\n<40> ++ cur_match_degree ;\n<45> if ( cur_match_degree > found_match_degree ) {
<1> static int kvm_get_fpu ( X86CPU * cpu ) {\n<2> CPUX86State * env = & cpu -> env ;\n<6> if ( ret < 0 ) {\n<20> memcpy ( env -> fpregs , fpu . fpr , sizeof env -> fpregs ) ;
<1> static void delete_files ( CommonJob * job , GList * files , int * files_skipped ) {\n<11> if ( job_aborted ( job ) ) {\n<15> memset ( & transfer_info , 0 , sizeof ( transfer_info ) ) ;\n<16> report_delete_progress ( job , & source_info , & transfer_info ) ;\n<19> data . transfer_info = & transfer_info ;
<1> static void test_store_result1 ( ) {\n<21> rc = 0 ;\n<22> while ( mysql_stmt_fetch ( stmt ) != MYSQL_NO_DATA ) rc ++ ;\n<23> if ( ! opt_silent ) fprintf ( stdout , "\n total rows: %d" , rc ) ;\n<24> DIE_UNLESS ( rc == 3 ) ;\n<29> rc = 0 ;\n<30> while ( mysql_stmt_fetch ( stmt ) != MYSQL_NO_DATA ) rc ++ ;\n<31> if ( ! opt_silent ) fprintf ( stdout , "\n total rows: %d" , rc ) ;\n<32> DIE_UNLESS ( rc == 3 ) ;
<1> av_cold int ff_MPV_common_init(MpegEncContext *s)\n<15> if (s->encoding && s->avctx->slices)\n<21> if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n<23> s->mb_height = (s->height + 31) / 32 * 2;\n<27> s->mb_height = (s->height + 15) / 16;\n<43> if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {\n<49> max_slices = FFMIN(MAX_THREADS, s->mb_height);\n<73> ff_dct_common_init(s);\n<77> s->flags  = s->avctx->flags;\n<79> s->flags2 = s->avctx->flags2;\n<95> s->codec_tag          = avpriv_toupper4(s->avctx->codec_tag);\n<99> s->stream_codec_tag   = avpriv_toupper4(s->avctx->stream_codec_tag);\n<113> memset(&s->next_picture, 0, sizeof(s->next_picture));\n<115> memset(&s->last_picture, 0, sizeof(s->last_picture));\n<117> memset(&s->current_picture, 0, sizeof(s->current_picture));\n<127> if (s->width && s->height) {\n<129> if (init_context_frame(s))\n<141> s->context_initialized = 1;\n<147> if (s->width && s->height) {\n<151> for (i = 1; i < nb_slices; i++) {\n<153> s->thread_context[i] = av_malloc(sizeof(MpegEncContext));\n<155> memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n<163> if (init_duplicate_context(s->thread_context[i]) < 0)\n<169> (s->mb_height * (i) + nb_slices / 2) / nb_slices;\n<173> (s->mb_height * (i + 1) + nb_slices / 2) / nb_slices;\n<199> ff_MPV_common_end(s);
<1> void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)\n<9> const char *profile = NULL;\n<23> if (!buf || buf_size <= 0)\n<45> profile = av_get_profile_name(p, enc->profile);\n<51> snprintf(buf, buf_size, "%s: %s", codec_type ? codec_type : "unknown",\n<55> buf[0] ^= 'a' ^ 'A'; /* first letter in uppercase */\n<59> if (enc->codec && strcmp(enc->codec->name, codec_name))\n<61> snprintf(buf + strlen(buf), buf_size - strlen(buf), " (%s)", enc->codec->name);\n<65> if (profile)\n<67> snprintf(buf + strlen(buf), buf_size - strlen(buf), " (%s)", profile);\n<75> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<79> enc->refs, enc->refs > 1 ? "s" : "");\n<83> if (enc->codec_tag) {\n<87> av_get_codec_tag_string(tag_buf, sizeof(tag_buf), enc->codec_tag);\n<89> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<97> switch (enc->codec_type) {\n<103> char detail[256] = "(";\n<107> av_strlcat(buf, separator, buf_size);\n<111> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<115> av_get_pix_fmt_name(enc->pix_fmt));\n<121> av_strlcatf(detail, sizeof(detail), "%d bpc, ", enc->bits_per_raw_sample);\n<143> av_strlcatf(detail, sizeof(detail), "%s/%s/%s, ",\n<171> if (strlen(detail) > 1) {\n<173> detail[strlen(detail) - 2] = 0;\n<175> av_strlcatf(buf, buf_size, "%s)", detail);\n<183> if (enc->width) {\n<185> av_strlcat(buf, new_line ? separator : ", ", buf_size);\n<189> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<199> (enc->width != enc->coded_width ||\n<201> enc->height != enc->coded_height))\n<203> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<209> if (enc->sample_aspect_ratio.num) {\n<211> av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n<213> enc->width * enc->sample_aspect_ratio.num,\n<215> enc->height * enc->sample_aspect_ratio.den,\n<219> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<229> if (av_log_get_level() >= AV_LOG_DEBUG) {\n<233> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<237> enc->time_base.num / g, enc->time_base.den / g);\n<243> if (encode) {\n<245> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<251> if (enc->properties & FF_CODEC_PROPERTY_CLOSED_CAPTIONS)\n<253> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<257> if (enc->properties & FF_CODEC_PROPERTY_LOSSLESS)\n<259> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<269> av_strlcat(buf, separator, buf_size);\n<273> if (enc->sample_rate) {\n<275> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<281> av_get_channel_layout_string(buf + strlen(buf), buf_size - strlen(buf), enc->channels, enc->channel_layout);\n<283> if (enc->sample_fmt != AV_SAMPLE_FMT_NONE) {\n<285> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<287> ", %s", av_get_sample_fmt_name(enc->sample_fmt));\n<291> if (   enc->bits_per_raw_sample > 0\n<293> && enc->bits_per_raw_sample != av_get_bytes_per_sample(enc->sample_fmt) * 8)\n<295> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<307> if (g)\n<309> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<313> enc->time_base.num / g, enc->time_base.den / g);\n<321> if (enc->width)\n<323> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<337> if (enc->flags & AV_CODEC_FLAG_PASS1)\n<339> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<343> if (enc->flags & AV_CODEC_FLAG_PASS2)\n<345> snprintf(buf + strlen(buf), buf_size - strlen(buf),\n<351> bitrate = get_bit_rate(enc);
<1> static gcry_err_code_t mgf1 ( unsigned char * output , size_t outlen , unsigned char * seed , size_t seedlen , int algo ) {\n<11> while ( nbytes < outlen ) {\n<21> digest = gcry_md_read ( hd , 0 ) ;\n<22> n = ( outlen - nbytes < dlen ) ? ( outlen - nbytes ) : dlen ;\n<23> memcpy ( output + nbytes , digest , n ) ;\n<24> nbytes += n ;
<1> static int locking_available ( void ) {\n<13> strbuf_addf ( & out_buffer . buf , PROPFIND_SUPPORTEDLOCK_REQUEST , escaped ) ;\n<14> free ( escaped ) ;\n<24> if ( results . curl_result == CURLE_OK ) {\n<27> ctx . name = xcalloc ( 10 , 1 ) ;\n<28> ctx . len = 0 ;\n<29> ctx . cdata = NULL ;\n<30> ctx . userFunc = handle_lockprop_ctx ;\n<31> ctx . userData = & lock_flags ;\n<35> free ( ctx . name ) ;\n<36> if ( result != XML_STATUS_OK ) {\n<37> fprintf ( stderr , "XML error: %s\n" , XML_ErrorString ( XML_GetErrorCode ( parser ) ) ) ;
<1> static gpgme_error_t gpgsm_assuan_simple_command ( assuan_context_t ctx , char * cmd , engine_status_handler_t status_fnc , void * status_fnc_value ) {\n<8> err = assuan_read_line ( ctx , & line , & linelen ) ;\n<10> if ( * line == '#' || ! linelen ) continue ;\n<11> if ( linelen >= 2 && line [ 0 ] == 'O' && line [ 1 ] == 'K' && ( line [ 2 ] == '\0' || line [ 2 ] == ' ' ) ) return 0 ;\n<12> else if ( linelen >= 4 && line [ 0 ] == 'E' && line [ 1 ] == 'R' && line [ 2 ] == 'R' && line [ 3 ] == ' ' ) err = atoi ( & line [ 4 ] ) ;\n<13> else if ( linelen >= 2 && line [ 0 ] == 'S' && line [ 1 ] == ' ' ) {\n<16> rest = strchr ( line + 2 , ' ' ) ;\n<17> if ( ! rest ) rest = line + linelen ;
<1> gx_ttfReader * gx_ttfReader__create ( gs_memory_t * mem ) {\n<3> if ( r != NULL ) {\n<14> memset ( & r -> glyph_data , 0 , sizeof ( r -> glyph_data ) ) ;
<1> static int make_completely_empty(BlockDriverState *bs)\n<5> BDRVQcow2State *s = bs->opaque;\n<65> l1_size2 = (uint64_t)s->l1_size * sizeof(uint64_t);\n<79> if (ret < 0) {\n<85> memset(s->l1_table, 0, l1_size2);\n<222> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
<1> static void mxf_write_partition(AVFormatContext *s, int bodysid,\n<5> const uint8_t *key, int write_metadata)\n<9> MXFContext *mxf = s->priv_data;\n<45> if (!memcmp(key, body_partition_key, 16)) {\n<47> mxf->body_partition_offset =\n<49> av_realloc(mxf->body_partition_offset,\n<51> (mxf->body_partitions_count+1)*\n<53> sizeof(*mxf->body_partition_offset));\n<55> mxf->body_partition_offset[mxf->body_partitions_count++] = partition_offset;\n<63> avio_write(pb, key, 16);\n<83> if (!memcmp(key, body_partition_key, 16) && mxf->body_partitions_count > 1)\n<85> avio_wb64(pb, mxf->body_partition_offset[mxf->body_partitions_count-2]); // PreviousPartition\n<87> else if (!memcmp(key, footer_partition_key, 16) && mxf->body_partitions_count)\n<89> avio_wb64(pb, mxf->body_partition_offset[mxf->body_partitions_count-1]); // PreviousPartition\n<93> avio_wb64(pb, 0);\n<119> if (bodysid && mxf->edit_units_count && mxf->body_partitions_count) {
<1> int qcow2_grow_l1_table(BlockDriverState *bs, int min_size)\n<5> BDRVQcowState *s = bs->opaque;\n<19> if (min_size <= new_l1_size)\n<45> new_l1_table = qemu_mallocz(align_offset(new_l1_size2, 512));\n<47> memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n<59> qemu_free(new_l1_table);\n<71> new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n<73> ret = bdrv_pwrite(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n<101> qemu_free(s->l1_table);
<1> static void ppc_core99_init(MachineState *machine)\n<101> if (cpu == NULL) {\n<103> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<295> if (ppc_boot_device == '\0') {\n<297> fprintf(stderr, "No valid boot device for Mac99 machine\n");
<1> static void pushfogio ( IO * wrapper , FILE * fog ) {\n<2> _IO * io = calloc ( 1 , sizeof ( _IO ) ) ;\n<8> wrapper -> top = io ;
<1> ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n<53> xops = get_xattr_operations(ctx->xops, orig_value);\n<55> if (!xops) {\n<63> if (!value) {\n<65> size += xops->listxattr(ctx, path, orig_value, value, vsize);\n<69> size = xops->listxattr(ctx, path, orig_value, value, vsize);\n<71> if (size < 0) {\n<87> attr_len = strlen(orig_value) + 1;\n<89> parsed_len += attr_len;\n<91> orig_value += attr_len;
<1> int ImagingFliDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n<20> UINT8 * data = ptr + 6 ;\n<23> case 7 : lines = I16 ( data ) ;\n<24> data += 2 ;\n<28> UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n<30> packets = I16 ( data ) ;\n<31> data += 2 ;\n<39> buf = ( UINT8 * ) im -> image [ y ] ;\n<42> buf [ state -> xsize - 1 ] = ( UINT8 ) packets ;\n<44> packets = I16 ( data ) ;\n<45> data += 2 ;\n<50> x += data [ 0 ] ;\n<51> if ( data [ 1 ] >= 128 ) {\n<52> i = 256 - data [ 1 ] ;\n<53> if ( x + i + i > state -> xsize ) break ;\n<57> buf [ x ++ ] = data [ 2 ] ;\n<58> buf [ x ++ ] = data [ 3 ] ;\n<60> data += 2 + 2 ;\n<63> i = 2 * ( int ) data [ 1 ] ;\n<64> if ( x + i > state -> xsize ) break ;\n<65> memcpy ( buf + x , data + 2 , i ) ;\n<66> data += 2 + i ;\n<67> x += i ;\n<77> case 12 : y = I16 ( data ) ;\n<78> ymax = y + I16 ( data + 2 ) ;\n<79> data += 4 ;\n<83> UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n<84> int p , packets = * data ++ ;\n<87> p ++ , x += i ) {\n<88> x += data [ 0 ] ;\n<89> if ( data [ 1 ] & 0x80 ) {\n<90> i = 256 - data [ 1 ] ;\n<91> if ( x + i > state -> xsize ) break ;\n<92> memset ( out + x , data [ 2 ] , i ) ;\n<93> data += 3 ;\n<96> i = data [ 1 ] ;\n<97> if ( x + i > state -> xsize ) break ;\n<98> memcpy ( out + x , data + 2 , i ) ;\n<99> data += i + 2 ;\n<110> y < state -> ysize ;\n<111> y ++ ) memset ( im -> image [ y ] , 0 , state -> xsize ) ;\n<116> UINT8 * out = ( UINT8 * ) im -> image [ y ] ;\n<117> data += 1 ;\n<119> x < state -> xsize ;\n<120> x += i ) {\n<121> if ( data [ 0 ] & 0x80 ) {\n<122> i = 256 - data [ 0 ] ;\n<123> if ( x + i > state -> xsize ) break ;\n<124> memcpy ( out + x , data + 1 , i ) ;\n<125> data += i + 1 ;\n<128> i = data [ 0 ] ;\n<129> if ( x + i > state -> xsize ) break ;\n<130> memset ( out + x , data [ 1 ] , i ) ;\n<131> data += 2 ;\n<134> if ( x != state -> xsize ) {\n<141> y < state -> ysize ;\n<143> UINT8 * buf = ( UINT8 * ) im -> image [ y ] ;\n<144> memcpy ( buf , data , state -> xsize ) ;\n<145> data += state -> xsize ;
<1> int cache_insert(PageCache *cache, uint64_t addr, uint8_t *pdata)\n<19> it = cache_get_by_addr(cache, addr);\n<25> if (!it->it_data) {\n<27> it->it_data = g_try_malloc(cache->page_size);\n<29> if (!it->it_data) {\n<43> memcpy(it->it_data, pdata, cache->page_size);
<1> static void check_get_params ( void ) {\n<4> param = gcry_pk_get_param ( GCRY_PK_ECDSA , sample_key_1_curve ) ;\n<5> if ( ! param ) fail ( "error gerring parameters for `%s'\n" , sample_key_1_curve ) ;\n<7> if ( ! name ) fail ( "get_param: curve name not found for sample_key_1\n" ) ;\n<8> else if ( strcmp ( name , sample_key_1_curve ) ) fail ( "get_param: expected curve name %s but got %s for sample_key_1\n" , sample_key_1_curve , name ) ;\n<10> param = gcry_pk_get_param ( GCRY_PK_ECDSA , sample_key_2_curve ) ;\n<11> if ( ! param ) fail ( "error gerring parameters for `%s'\n" , sample_key_2_curve ) ;\n<13> if ( ! name ) fail ( "get_param: curve name not found for sample_key_2\n" ) ;\n<14> else if ( strcmp ( name , sample_key_2_curve ) ) fail ( "get_param: expected curve name %s but got %s for sample_key_2\n" , sample_key_2_curve , name ) ;
<1> static void render_fragments(Vp3DecodeContext *s,\n<47> output_plane = s->current_frame.data[0];\n<49> last_plane = s->current_frame.data[0];\n<59> output_plane = s->current_frame.data[1];\n<61> last_plane = s->current_frame.data[1];\n<71> output_plane = s->current_frame.data[2];\n<73> last_plane = s->current_frame.data[2];\n<169> for (m = 0; m < 8; m++)\n<173> output_plane + s->all_fragments[i].first_pixel + stride * m,\n<175> last_plane + s->all_fragments[i].first_pixel + stride * m,
<1680> if ( no_of_state_create != 0 ) {\n<1681> memset ( sha1_digest_buf , 0 , STATE_BUFFER_SIZE ) ;
<1> static void test_ps_query_cache ( ) {\n<26> iteration <= TEST_QCACHE_ON_OFF ;\n<35> case TEST_QCACHE_ON_WITH_OTHER_CONN : if ( ! opt_silent ) fprintf ( stdout , "\n Establishing a test connection ..." ) ;\n<36> if ( ! ( lmysql = mysql_client_init ( NULL ) ) ) {\n<37> printf ( "mysql_client_init() failed" ) ;\n<40> if ( ! ( mysql_real_connect ( lmysql , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , 0 ) ) ) {\n<41> printf ( "connection failed" ) ;\n<47> if ( ! opt_silent ) fprintf ( stdout , "OK" ) ;\n<61> memset ( p_bind , 0 , sizeof ( p_bind ) ) ;\n<65> p_bind [ 1 ] . buffer = ( void * ) p_str_data ;\n<66> p_bind [ 1 ] . buffer_length = array_elements ( p_str_data ) ;\n<67> p_bind [ 1 ] . length = & p_str_length ;\n<68> rc = mysql_stmt_bind_param ( stmt , p_bind ) ;\n<71> strmov ( p_str_data , "hh" ) ;\n<72> p_str_length = strlen ( p_str_data ) ;\n<73> memset ( r_bind , 0 , sizeof ( r_bind ) ) ;\n<80> rc = mysql_stmt_bind_result ( stmt , r_bind ) ;\n<96> strmov ( p_str_data , "ii" ) ;\n<97> p_str_length = strlen ( p_str_data ) ;
<1> static void fill_picture_parameters(AVCodecContext *avctx,\n<5> DXVA_PictureParameters *pp)\n<15> memset(pp, 0, sizeof(*pp));\n<67> pp->bPicStructure      |= 0x01;\n<71> pp->bPicStructure      |= 0x02;\n<139> pp->bPicDeblocked           = ((!pp->bPicBackwardPrediction && v->overlap)        << 6) |
<1> static char * fstrndup ( const char * ptr , unsigned long len ) {\n<3> if ( len <= 0 ) return NULL ;\n<5> memcpy ( result , ptr , len ) ;\n<6> return result ;
<1> static int flic_decode_frame_8BPP(AVCodecContext *avctx,\n<5> const uint8_t *buf, int buf_size)\n<9> FlicDecodeContext *s = avctx->priv_data;\n<87> pixels = s->frame.data[0];\n<93> if (buf_size < 16 || buf_size > INT_MAX - (3 * 256 + FF_INPUT_BUFFER_PADDING_SIZE))\n<97> frame_size = AV_RL32(&buf[stream_ptr]);\n<121> chunk_size = AV_RL32(&buf[stream_ptr]);\n<139> chunk_type = AV_RL16(&buf[stream_ptr]);\n<145> switch (chunk_type) {\n<229> if (s->palette[palette_ptr] != entry)\n<233> s->palette[palette_ptr++] = entry;\n<247> compressed_lines = AV_RL16(&buf[stream_ptr]);\n<257> line_packets = AV_RL16(&buf[stream_ptr]);\n<281> pixels[pixel_ptr] = line_packets & 0xff;\n<291> pixel_countdown = s->avctx->width;\n<323> pixels[pixel_ptr++] = palette_idx2;\n<339> pixels[pixel_ptr++] = palette_idx1;\n<363> starting_line = AV_RL16(&buf[stream_ptr]);\n<383> pixel_countdown = s->avctx->width;\n<417> pixels[pixel_ptr++] = palette_idx1;\n<431> pixels[pixel_ptr++] = palette_idx1;\n<459> s->frame.linesize[0] * s->avctx->height);\n<483> pixel_countdown = s->avctx->width;\n<501> pixels[pixel_ptr++] = palette_idx1;\n<527> pixels[pixel_ptr++] = palette_idx1;\n<557> if (chunk_size - 6 != s->avctx->width * s->avctx->height) {\n<565> for (y_ptr = 0; y_ptr < s->frame.linesize[0] * s->avctx->height;\n<573> stream_ptr += s->avctx->width;\n<627> memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);
<1> static int aasc_decode_frame(AVCodecContext *avctx,\n<36> buf      += 4;\n<48> for (i = avctx->height - 1; i >= 0; i--) {\n<50> memcpy(s->frame->data[0] + i * s->frame->linesize[0], buf, avctx->width * 3);\n<52> buf += stride;
<1> static int parse_channel_expressions(AVFilterContext *ctx,\n<27> if (!eval->exprs) {\n<37> if (!strcmp(ctx->filter->name, "aeval")) {\n<39> func1 = aeval_func1;\n<41> func1_names = aeval_func1_names;
<1> static void set_str ( unsigned char * p , const char * s , size_t l , char f , const char * map ) {\n<11> * p ++ = c ;\n<14> if ( l > 0 ) memset ( p , f , l ) ;
<1> static void RestoreOutput ( ArchiveHandle * AH , OutputContext savedContext ) {\n<5> if ( res != 0 ) exit_horribly ( modulename , "could not close output file: %s\n" , strerror ( errno ) ) ;
<1> static int __tipc_nl_compat_dumpit ( struct tipc_nl_compat_cmd_dump * cmd , struct tipc_nl_compat_msg * msg , struct sk_buff * arg ) {\n<7> memset ( & cb , 0 , sizeof ( cb ) ) ;\n<15> len = ( * cmd -> dumpit ) ( buf , & cb ) ;\n<36> if ( * tail != '\0' ) sprintf ( tail - sizeof ( REPLY_TRUNCATED ) - 1 , REPLY_TRUNCATED ) ;
<1> int evhttp_del_cb ( struct evhttp * http , const char * uri ) {\n<3> TAILQ_FOREACH ( http_cb , & http -> callbacks , next ) {\n<4> if ( strcmp ( http_cb -> what , uri ) == 0 ) break ;\n<6> if ( http_cb == NULL ) return ( - 1 ) ;\n<7> TAILQ_REMOVE ( & http -> callbacks , http_cb , next ) ;\n<8> free ( http_cb -> what ) ;\n<9> free ( http_cb ) ;
<1> static void print_var_str ( const char * var , const char * val ) {\n<2> printf ( "%s='%s'\n" , var , val ) ;
<1> static inline int get_hash_algo ( const char * s , size_t n ) {\n<38> hashnames [ i ] . name ;\n<39> i ++ ) {\n<40> if ( strlen ( hashnames [ i ] . name ) == n && ! memcmp ( hashnames [ i ] . name , s , n ) ) break ;\n<45> tmpname = gcry_malloc ( n + 1 ) ;\n<46> if ( ! tmpname ) algo = 0 ;\n<48> memcpy ( tmpname , s , n ) ;\n<50> algo = gcry_md_map_name ( tmpname ) ;
<1> static int patch_hypercalls ( VAPICROMState * s ) {\n<16> cpu_physical_memory_rw ( rom_paddr , rom , s -> rom_size , 0 ) ;\n<18> pos < s -> rom_size - sizeof ( vmcall_pattern ) ;\n<21> pattern = outl_pattern ;\n<27> pattern = vmcall_pattern ;\n<32> if ( memcmp ( rom + pos , pattern , 7 ) == 0 && ( rom [ pos + 7 ] == alternates [ 0 ] || rom [ pos + 7 ] == alternates [ 1 ] ) ) {\n<33> cpu_physical_memory_rw ( rom_paddr + pos + 5 , ( uint8_t * ) patch , 3 , 1 ) ;
<1> sig_handler handle_sigint ( int sig ) {\n<2> char kill_buffer [ 40 ] ;\n<15> sprintf ( kill_buffer , "KILL %s%lu" , ( interrupted_query == 1 ) ? "QUERY " : "" , mysql_thread_id ( & mysql ) ) ;\n<16> if ( verbose ) tee_fprintf ( stdout , "Ctrl-C -- sending \"%s\" to server ...\n" , kill_buffer ) ;\n<17> mysql_real_query ( kill_mysql , kill_buffer , ( uint ) strlen ( kill_buffer ) ) ;
<1> PXA2xxState *pxa270_init(MemoryRegion *address_space,\n<17> if (revision && strncmp(revision, "pxa27", 5)) {\n<19> fprintf(stderr, "Machine requires a PXA27x processor.\n");\n<33> if (s->cpu == NULL) {\n<35> fprintf(stderr, "Unable to find CPU definition\n");\n<99> if (!dinfo) {\n<101> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> static int handle_renames_and_mkdirs(BDRVVVFATState* s)\n<27> commit_t* commit = array_get(&(s->commits), i);\n<35> char* old_path = mapping->path;\n<43> if (rename(old_path, mapping->path))\n<49> if (mapping->mode & MODE_DIRECTORY) {\n<51> int l1 = strlen(mapping->path);\n<53> int l2 = strlen(old_path);\n<55> int diff = l1 - l2;\n<77> if (is_file(d) || (is_directory(d) && !is_dot(d))) {\n<83> int l = strlen(m->path);\n<85> char* new_path = g_malloc(l + diff + 1);\n<89> assert(!strncmp(m->path, mapping->path, l2));\n<93> pstrcpy(new_path, l + diff + 1, mapping->path);\n<95> pstrcpy(new_path + l1, l + diff + 1 - l1,\n<117> free(old_path);\n<139> if (mkdir(commit->path, 0755))\n<151> if (mapping == NULL)\n<175> parent_path_len = strlen(commit->path)\n<177> - strlen(get_basename(commit->path)) - 1;\n<181> mapping_t* m = array_get(&(s->mapping), j);\n<183> if (m->first_mapping_index < 0 && m != mapping &&\n<185> !strncmp(m->path, mapping->path, parent_path_len) &&\n<187> strlen(m->path) == parent_path_len)
<1> static OutputStream *new_video_stream(OptionsContext *o, AVFormatContext *oc, int source_index)\n<45> if (av_parse_ratio(&q, frame_aspect_ratio, 255, 0, NULL) < 0 ||\n<47> q.num <= 0 || q.den <= 0) {\n<181> MATCH_PER_STREAM_OPT(rc_overrides, str, p, oc, st);\n<183> for (i = 0; p; i++) {\n<187> int e = sscanf(p, "%d,%d,%d", &start, &end, &q);\n<189> if (e != 3) {\n<205> video_enc->rc_override[i].start_frame = start;\n<207> video_enc->rc_override[i].end_frame   = end;\n<209> if (q > 0) {\n<211> video_enc->rc_override[i].qscale         = q;\n<221> video_enc->rc_override[i].quality_factor = -q/100.0;\n<225> p = strchr(p, '/');\n<227> if (p) p++;
<1> static void * prplcb_request_action ( const char * title , const char * primary , const char * secondary , int default_action , PurpleAccount * account , const char * who , PurpleConversation * conv , void * user_data , size_t action_count , va_list actions ) {\n<7> i < action_count ;\n<13> if ( strstr ( caption , "Accept" ) || strstr ( caption , "OK" ) ) {\n<14> pqad -> yes = fn ;\n<15> pqad -> yes_i = i ;\n<17> else if ( strstr ( caption , "Reject" ) || strstr ( caption , "Cancel" ) ) {\n<18> pqad -> no = fn ;\n<19> pqad -> no_i = i ;
<1> static int nntp_fetch_lines ( struct NntpData * nntp_data , char * query , size_t qlen , const char * msg , int ( * funct ) ( char * , void * ) , void * data ) {\n<27> if ( ! off && buf [ 0 ] == '.' ) {\n<34> mutt_str_strfcpy ( line + off , p , sizeof ( buf ) ) ;\n<35> if ( chunk >= sizeof ( buf ) ) off += strlen ( p ) ;\n<41> mutt_mem_realloc ( & line , off + sizeof ( buf ) ) ;
<1> static void test_update ( ) {\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<26> length [ 0 ] = sprintf ( szData , "inserted-data" ) ;\n<29> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<41> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<43> my_bind [ 0 ] . buffer = szData ;\n<45> my_bind [ 0 ] . length = & length [ 0 ] ;\n<46> length [ 0 ] = sprintf ( szData , "updated-data" ) ;\n<49> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> void qmp_getfd(const char *fdname, Error **errp)\n<23> if (qemu_isdigit(fdname[0])) {\n<36> QLIST_FOREACH(monfd, &cur_mon->fds, next) {\n<38> if (strcmp(monfd->name, fdname) != 0) {
<1> int kvm_arch_remove_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n<9> if (cpu_memory_rw_debug(cs, bp->pc, t, sizeof(diag_501), 0)) {\n<13> } else if (memcmp(t, diag_501, sizeof(diag_501))) {\n<15> return -EINVAL;\n<17> } else if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n<19> sizeof(diag_501), 1)) {
<1> static int parse_read_interval(const char *interval_spec,\n<11> if (!spec)\n<17> if (!*spec) {\n<31> next = strchr(spec, '%');\n<35> *next++ = 0;\n<81> p = next;\n<156> av_free(spec);
<1> static int rtp_packetize_h264_nal ( sout_stream_id_sys_t * id , const uint8_t * p_data , int i_data , int64_t i_pts , int64_t i_dts , bool b_last , int64_t i_length ) {\n<8> p_data += 3 ;\n<10> if ( i_data <= i_max ) {\n<15> memcpy ( & out -> p_buffer [ 12 ] , p_data , i_data ) ;\n<21> p_data ++ ;\n<24> i < i_count ;\n<26> const int i_payload = __MIN ( i_data , i_max - 2 ) ;\n<30> rtp_packetize_common ( id , out , ( b_last && i_payload == i_data ) , i_pts ) ;\n<33> memcpy ( & out -> p_buffer [ 14 ] , p_data , i_payload ) ;\n<35> i_data -= i_payload ;\n<36> p_data += i_payload ;
<1> static void dropTablespaces ( PGconn * conn ) {\n<5> if ( PQntuples ( res ) > 0 ) fprintf ( OPF , "--\n-- Drop tablespaces\n--\n\n" ) ;\n<14> fprintf ( OPF , "\n\n" ) ;
<1> int main ( int argc , char * * argv ) {\n<2> int frame_cnt = 0 ;\n<16> printf ( "Using %s\n" , vpx_codec_iface_name ( decoder -> codec_interface ( ) ) ) ;\n<24> while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) {\n<26> get_image_md5 ( img , digest ) ;\n<27> print_md5 ( outfile , digest ) ;\n<28> fprintf ( outfile , " img-%dx%d-%04d.i420\n" , img -> d_w , img -> d_h , ++ frame_cnt ) ;\n<31> printf ( "Processed %d frames.\n" , frame_cnt ) ;\n<34> fclose ( outfile ) ;
<1> av_cold int sws_init_context(SwsContext *c, SwsFilter *srcFilter,\n<739> c->chrUPixBuf[i] = c->chrUPixBuf[i + c->vChrBufSize];\n<763> for (i = 0; i < c->vChrBufSize; i++)\n<765> memset(c->chrUPixBuf[i], 64, dst_stride * 2 + 1);
<1> static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n<8> if ( ! kvm_enabled ( ) ) {\n<9> fprintf ( stderr , "The S390 target only works with KVM enabled\n" ) ;\n<35> if ( lduw_phys ( KERN_IMAGE_START ) != 0x0dd0 ) {\n<36> fprintf ( stderr , "Specified image is not an s390 boot image\n" ) ;\n<52> if ( kernel_cmdline ) {\n<53> cpu_physical_memory_rw ( KERN_PARM_AREA , ( uint8_t * ) kernel_cmdline , strlen ( kernel_cmdline ) , 1 ) ;\n<56> i < nb_nics ;\n<58> NICInfo * nd = & nd_table [ i ] ;\n<60> if ( ! nd -> model ) {\n<61> nd -> model = qemu_strdup ( "virtio" ) ;\n<63> if ( strcmp ( nd -> model , "virtio" ) ) {\n<64> fprintf ( stderr , "S390 only supports VirtIO nics\n" ) ;\n<65> exit ( 1 ) ;\n<68> qdev_set_nic_properties ( dev , nd ) ;
<1> static int tscc2_decode_frame(AVCodecContext *avctx, void *data,\n<11> TSCC2Context *c = avctx->priv_data;\n<17> int i, val, len, pos = 0;\n<123> len   = val & 0x3F;\n<125> val >>= 6;\n<127> if (pos + len > num_mb) {\n<135> memset(c->slice_quants + pos, val, len);\n<137> pos += len;
<1> static int daala_header(AVFormatContext *s, int idx)\n<185> memset(st->codec->extradata + cds, 0, AV_INPUT_BUFFER_PADDING_SIZE);
<1> static void stellaris_enet_write(void *opaque, hwaddr offset,\n<115> if ((s->tctl & SE_TCTL_PADEN) && s->tx_frame_len < 60) {\n<117> memset(&s->tx_fifo[s->tx_frame_len], 0, 60 - s->tx_frame_len);
<1> static void test_bug11172 ( ) {\n<14> stmt = mysql_stmt_init ( mysql ) ;\n<15> stmt_text = "SELECT id, hired FROM t1 WHERE hired=?" ;\n<16> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<17> check_execute ( stmt , rc ) ;\n<20> memset ( bind_in , 0 , sizeof ( bind_in ) ) ;\n<21> memset ( bind_out , 0 , sizeof ( bind_out ) ) ;\n<22> memset ( & hired , 0 , sizeof ( hired ) ) ;\n<27> bind_in [ 0 ] . buffer = ( void * ) & hired ;\n<31> bind_out [ 1 ] = bind_in [ 0 ] ;\n<35> rc = mysql_stmt_bind_param ( stmt , bind_in ) ;\n<37> rc = mysql_stmt_bind_result ( stmt , bind_out ) ;\n<42> if ( ! opt_silent ) printf ( "fetched data %d:%d-%d-%d\n" , id , hired . year , hired . month , hired . day ) ;
<1> static gint nlm_msg_res_unmatched_equal ( gconstpointer k1 , gconstpointer k2 ) {\n<2> const nlm_msg_res_unmatched_data * umd1 = ( const nlm_msg_res_unmatched_data * ) k1 ;\n<3> const nlm_msg_res_unmatched_data * umd2 = ( const nlm_msg_res_unmatched_data * ) k2 ;\n<4> if ( umd1 -> cookie_len != umd2 -> cookie_len ) {\n<7> return ( memcmp ( umd1 -> cookie , umd2 -> cookie , umd1 -> cookie_len ) == 0 ) ;
<1> static int SRP_user_pwd_set_sv ( SRP_user_pwd * vinfo , const char * s , const char * v ) {\n<2> unsigned char tmp [ MAX_LEN ] ;\n<4> if ( strlen ( s ) > MAX_LEN || strlen ( v ) > MAX_LEN ) return 0 ;\n<5> len = t_fromb64 ( tmp , v ) ;\n<6> if ( NULL == ( vinfo -> v = BN_bin2bn ( tmp , len , NULL ) ) ) return 0 ;\n<7> len = t_fromb64 ( tmp , s ) ;
<1> static int encrypt_nss ( struct crypto_instance * instance , const unsigned char * buf_in , const size_t buf_in_len , unsigned char * buf_out , size_t * buf_out_len ) {\n<10> if ( ! cipher_to_nss [ instance -> crypto_cipher_type ] ) {\n<11> memcpy ( buf_out , buf_in , buf_in_len ) ;\n<12> * buf_out_len = buf_in_len ;
<1> PXA2xxState *pxa255_init(MemoryRegion *address_space, unsigned int sdram_size)\n<19> if (s->cpu == NULL) {\n<21> fprintf(stderr, "Unable to find CPU definition\n");\n<83> if (!dinfo) {\n<85> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> int mime_mem_print ( const char * src_d , int src_l , char * buf_start , int buf_length , int * buf_index_inout , int * buf_chars_to_skip_inout ) {\n<11> ink_assert ( buf_start != nullptr ) ;\n<12> ink_assert ( src_d != nullptr ) ;\n<20> src_d += * buf_chars_to_skip_inout ;\n<25> if ( copy_l > 0 ) {\n<26> memcpy ( buf_start + * buf_index_inout , src_d , copy_l ) ;\n<27> * buf_index_inout += copy_l ;\n<29> return ( src_l == copy_l ) ;
<1> static int find_newc_header ( struct archive_read * a ) {\n<10> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<11> p = h ;\n<13> if ( memcmp ( "07070" , p , 5 ) == 0 && ( p [ 5 ] == '1' || p [ 5 ] == '2' ) && is_hex ( p , newc_header_size ) ) return ( ARCHIVE_OK ) ;\n<14> while ( p + newc_header_size <= q ) {\n<15> switch ( p [ 5 ] ) {\n<16> case '1' : case '2' : if ( memcmp ( "07070" , p , 5 ) == 0 && is_hex ( p , newc_header_size ) ) {\n<17> skip = p - ( const char * ) h ;\n<18> __archive_read_consume ( a , skip ) ;\n<19> skipped += skip ;\n<20> if ( skipped > 0 ) {\n<26> p += 2 ;\n<28> case '0' : p ++ ;\n<30> default : p += 6 ;\n<34> skip = p - ( const char * ) h ;
<1> static void probe_codec(AVFormatContext *s, AVStream *st, const AVPacket *pkt)\n<7> AVProbeData *pd = &st->probe_data;\n<17> if (pkt) {\n<19> pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n<21> memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n<23> pd->buf_size += pkt->size;\n<25> memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n<41> if(end || av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){
<1> static int fileTest(uint8_t *ref[4], int refStride[4], int w, int h, FILE *fp,\n<13> while (fgets(buf, sizeof(buf), fp)) {\n<19> char srcStr[12];\n<25> char dstStr[12];\n<45> if (ret != 12) {\n<47> srcStr[0] = dstStr[0] = 0;\n<49> ret       = sscanf(buf, "%12s -> %12s\n", srcStr, dstStr);\n<55> srcFormat = av_get_pix_fmt(srcStr);\n<57> dstFormat = av_get_pix_fmt(dstStr);\n<61> if (srcFormat == AV_PIX_FMT_NONE || dstFormat == AV_PIX_FMT_NONE ||\n<65> fprintf(stderr, "malformed input file\n");\n<77> if (ret != 12) {\n<79> printf("%s", buf);\n<99> return 0;
<1> static int rtp_xiph_pack_headers ( size_t room , void * p_extra , size_t i_extra , uint8_t * * p_buffer , size_t * i_buffer , uint8_t * theora_pixel_fmt ) {\n<5> if ( xiph_SplitHeaders ( packet_size , packet , & packet_count , i_extra , p_extra ) ) return VLC_EGENERIC ;\n<9> if ( theora_pixel_fmt != NULL ) {\n<10> if ( packet_size [ 0 ] < 42 ) return VLC_EGENERIC ;\n<25> * i_buffer = room + 1 + length_size [ 0 ] + length_size [ 1 ] + packet_size [ 0 ] + packet_size [ 1 ] + packet_size [ 2 ] ;\n<26> * p_buffer = malloc ( * i_buffer ) ;\n<27> if ( * p_buffer == NULL ) return VLC_ENOMEM ;\n<29> * p ++ = 2 ;\n<35> * p = ( packet_size [ i ] >> ( 7 * ( size - 1 ) ) ) & 0x7f ;\n<36> if ( -- size > 0 ) * p |= 0x80 ;\n<37> p ++ ;\n<41> i < 3 ;\n<43> memcpy ( p , packet [ i ] , packet_size [ i ] ) ;\n<44> p += packet_size [ i ] ;
<1> SPARCCPU *sparc64_cpu_devinit(const char *cpu_model,\n<31> if (cpu == NULL) {\n<33> fprintf(stderr, "Unable to find Sparc CPU definition\n");
<1> static void move_audio(vorbis_enc_context *venc, float **audio, int *samples, int sf_size)\n<21> for (int ch = 0; ch < venc->channels; ch++) {\n<23> const float *input = (float *) cur->extended_data[ch];\n<25> const size_t len  = cur->nb_samples * sizeof(float);\n<27> memcpy(&audio[ch][sf*sf_size], input, len);
<1> static int32_t u_printf_scidbl_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n<7> memcpy ( & scidbl_info , info , sizeof ( u_printf_spec_info ) ) ;\n<11> retVal = u_printf_double_handler ( handler , context , formatBundle , & scidbl_info , args ) ;\n<18> retVal = u_printf_scientific_handler ( handler , context , formatBundle , & scidbl_info , args ) ;\n<33> retVal = u_printf_double_handler ( handler , context , formatBundle , & scidbl_info , args ) ;
<1> void _hb_graphite2_shaper_face_data_destroy ( hb_graphite2_shaper_face_data_t * data ) {\n<3> while ( tlist ) {\n<4> hb_graphite2_tablelist_t * old = tlist ;\n<7> free ( old ) ;\n<9> gr_face_destroy ( data -> grface ) ;\n<10> free ( data ) ;
<1> static int truespeech_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<15> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<19> samples = ( int16_t * ) frame -> data [ 0 ] ;\n<20> memset ( samples , 0 , iterations * 240 * sizeof ( * samples ) ) ;\n<32> truespeech_place_pulses ( c , samples , i ) ;
<1> int is_adx(const unsigned char *buf,size_t bufsize)\n<9> if (buf[0]!=0x80) return 0;\n<13> if (bufsize<offset || memcmp(buf+offset-6,"(c)CRI",6)) return 0;\n<15> return offset;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<68> if ( init_frame ) {\n<69> memset ( c -> pic . data [ 0 ] , 0 , avctx -> height * c -> pic . linesize [ 0 ] ) ;\n<70> memset ( c -> pic . data [ 1 ] , 0x80 , avctx -> height * c -> pic . linesize [ 1 ] / 2 ) ;\n<71> memset ( c -> pic . data [ 2 ] , 0x80 , avctx -> height * c -> pic . linesize [ 2 ] / 2 ) ;\n<75> switch ( comptype ) {\n<87> case NUV_BLACK : memset ( c -> pic . data [ 0 ] , 0 , c -> width * c -> height ) ;\n<88> memset ( c -> pic . data [ 1 ] , 128 , c -> width * c -> height / 4 ) ;\n<89> memset ( c -> pic . data [ 2 ] , 128 , c -> width * c -> height / 4 ) ;
<1> int write_pair ( PyObject * self , buffer_t buffer , const char * name , Py_ssize_t name_length , PyObject * value , unsigned char check_keys , unsigned char uuid_subtype , unsigned char allow_id ) {\n<3> if ( ! allow_id && strcmp ( name , "_id" ) == 0 ) {\n<4> return 1 ;\n<6> type_byte = buffer_save_space ( buffer , 1 ) ;\n<7> if ( type_byte == - 1 ) {\n<11> if ( check_keys && ! check_key_name ( name , name_length ) ) {\n<14> if ( ! buffer_write_bytes ( buffer , name , name_length + 1 ) ) {
<1> static int microdvd_probe(AVProbeData *p)\n<13> if (AV_RB24(ptr) == 0xEFBBBF)\n<15> ptr += 3;  /* skip UTF-8 BOM */\n<19> for (i=0; i<3; i++) {\n<21> if (sscanf(ptr, "{%*d}{}%c",     &c) != 1 &&\n<23> sscanf(ptr, "{%*d}{%*d}%c",  &c) != 1 &&\n<25> sscanf(ptr, "{DEFAULT}{}%c", &c) != 1)\n<27> return 0;\n<29> ptr += strcspn(ptr, "\n") + 1;
<1> int ff_h264_decode_seq_parameter_set(H264Context *h){\n<43> if(sps == NULL)\n<59> memset(sps->scaling_matrix4, 16, sizeof(sps->scaling_matrix4));\n<61> memset(sps->scaling_matrix8, 16, sizeof(sps->scaling_matrix8));\n<89> decode_scaling_matrices(h, sps, NULL, 1, sps->scaling_matrix4, sps->scaling_matrix8);\n<273> if (decode_vui_parameters(h, sps) < 0)\n<323> h->sps_buffers[sps_id]= sps;\n<331> av_free(sps);
<1> static int read_block_types ( AVCodecContext * avctx , GetBitContext * gb , Bundle * b ) {\n<3> int last = 0 ;\n<5> CHECK_READ_VAL ( gb , b , t ) ;\n<11> if ( get_bits1 ( gb ) ) {\n<12> v = get_bits ( gb , 4 ) ;\n<13> memset ( b -> cur_dec , v , t ) ;\n<14> b -> cur_dec += t ;\n<20> last = v ;\n<25> if ( dec_end - b -> cur_dec < run ) return AVERROR_INVALIDDATA ;\n<26> memset ( b -> cur_dec , last , run ) ;\n<27> b -> cur_dec += run ;
<1> static void show_stream_config ( struct stream_state * stream , struct VpxEncoderConfig * global , struct VpxInputContext * input ) {\n<3> fprintf ( stderr , "Codec: %s\n" , vpx_codec_iface_name ( global -> codec -> codec_interface ( ) ) ) ;\n<4> fprintf ( stderr , "Source file: %s File Type: %s Format: %s\n" , input -> filename , file_type_to_string ( input -> file_type ) , image_format_to_string ( input -> fmt ) ) ;
<1> void fw_cfg_add_file(FWCfgState *s,  const char *filename, uint8_t *data,\n<37> for (i = 0; i < index; i++) {\n<39> if (strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {\n<41> trace_fw_cfg_add_file_dupe(s, s->files->f[index].name);\n<43> return;
<1> static void idr_extend_identifier ( struct idrent * wnp , int numsize , int nullsize ) {\n<5> if ( wnp -> noff + numsize != wnp_ext_off ) {\n<6> p = ( unsigned char * ) wnp -> isoent -> identifier ;\n<7> memmove ( p + wnp -> noff + numsize , p + wnp_ext_off , wnp -> isoent -> ext_len + nullsize ) ;
<1> static int vf_open(vf_instance_t *vf, char *args)\n<15> vf->priv = calloc(1, sizeof (struct vf_priv_s));\n<17> vf->priv->skipline = 0;\n<19> vf->priv->scalew = 1;\n<21> vf->priv->scaleh = 2;\n<23> if (args) sscanf(args, "%d:%d:%d", &vf->priv->skipline, &vf->priv->scalew, &vf->priv->scaleh);
<1> int ff_draw_init(FFDrawContext *draw, enum PixelFormat format, unsigned flags)\n<11> int pixelstep[MAX_PLANES] = { 0 };\n<47> if (pixelstep[c->plane] >= 8)\n<55> if ((desc->log2_chroma_w || desc->log2_chroma_h) && nb_planes < 3)\n<59> memset(draw, 0, sizeof(*draw));\n<67> memcpy(draw->pixelstep, pixelstep, sizeof(draw->pixelstep));
<1> static int kvm_put_sregs ( X86CPU * cpu ) {\n<4> memset ( sregs . interrupt_bitmap , 0 , sizeof ( sregs . interrupt_bitmap ) ) ;\n<28> memset ( sregs . idt . padding , 0 , sizeof sregs . idt . padding ) ;\n<31> memset ( sregs . gdt . padding , 0 , sizeof sregs . gdt . padding ) ;\n<39> return kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_SET_SREGS , & sregs ) ;
<1> static int check_principals_line ( struct ssh * ssh , char * cp , const struct sshkey_cert * cert , const char * loc , struct sshauthopt * * authoptsp ) {\n<7> ep = cp + strlen ( cp ) - 1 ;\n<8> while ( ep > cp && ( * ep == '\n' || * ep == ' ' || * ep == '\t' ) ) * ep -- = '\0' ;\n<10> if ( ( ep = strrchr ( cp , ' ' ) ) != NULL || ( ep = strrchr ( cp , '\t' ) ) != NULL ) {\n<15> cp = ep ;\n<23> i < cert -> nprincipals ;\n<25> if ( strcmp ( cp , cert -> principals [ i ] ) != 0 ) continue ;\n<26> debug3 ( "%s: matched principal \"%.100s\"" , loc , cert -> principals [ i ] ) ;\n<27> found = 1 ;
<1> void zipl_load(void)\n<13> memset(sec, FREE_SPACE_FILLER, sizeof(sec));\n<65> memset(sec, FREE_SPACE_FILLER, sizeof(sec));
<1> static void draw_rectangle(unsigned val, uint8_t *dst, int dst_linesize, unsigned segment_width,\n<13> dst += segment_width * (step * x + y * dst_linesize);\n<15> w *= segment_width * step;\n<19> for (i = 0; i < h; i++) {\n<21> memset(dst, val, w);\n<23> dst += dst_linesize;
<1> e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n<37> if (size < sizeof(min_buf)) {\n<39> memcpy(min_buf, buf, size);\n<41> memset(&min_buf[size], 0, sizeof(min_buf) - size);\n<43> buf = min_buf;\n<67> if (!receive_filter(s, buf, size))\n<73> if (vlan_enabled(s) && is_vlan_packet(s, buf)) {\n<77> memmove((uint8_t *)buf + 4, buf, 12);\n<133> pci_dma_write(&s->dev, le64_to_cpu(desc.buffer_addr),\n<135> buf + desc_offset + vlan_offset, copy_size);
<1> static int at1_imdct_block ( AT1SUCtx * su , AT1Ctx * q ) {\n<27> q -> fdsp . vector_fmul_window ( & q -> bands [ band_num ] [ start_pos ] , prev_buf , & su -> spectrum [ 0 ] [ ref_pos + start_pos ] , ff_sine_32 , 16 ) ;\n<32> if ( num_blocks == 1 ) memcpy ( q -> bands [ band_num ] + 32 , & su -> spectrum [ 0 ] [ ref_pos + 16 ] , 240 * sizeof ( float ) ) ;
<1> static int dca_parse_audio_coding_header ( DCAContext * s , int base_channel ) {\n<31> if ( ! base_channel ) memset ( s -> quant_index_huffman , 0 , sizeof ( s -> quant_index_huffman ) ) ;
<1> int main ( int argc , char * * argv ) {\n<3> if ( argc != 2 ) {\n<4> fprintf ( stderr , "One argument, the input filename, must be provided.\n" ) ;
<1> static int qcow2_update_ext_header(BlockDriverState *bs,\n<3> const char *backing_file, const char *backing_fmt)\n<7> size_t backing_file_len = 0;\n<21> if (backing_fmt && !backing_file) {\n<31> if (backing_fmt) {\n<33> ext_backing_fmt.len = cpu_to_be32(strlen(backing_fmt));\n<39> + strlen(backing_fmt) + 7) & ~7);\n<47> if (backing_file) {\n<49> backing_file_len = strlen(backing_file);\n<55> size_t header_size = sizeof(QCowHeader) + backing_file_len\n<73> uint8_t buf[ext_size];\n<75> size_t offset = 0;\n<81> if (backing_file) {\n<83> if (backing_fmt) {\n<87> (sizeof(ext_backing_fmt) + strlen(backing_fmt));\n<91> memcpy(buf + offset, &ext_backing_fmt, sizeof(ext_backing_fmt));\n<93> offset += sizeof(ext_backing_fmt);\n<97> memcpy(buf + offset, backing_fmt, strlen(backing_fmt));\n<99> offset += strlen(backing_fmt);\n<103> memset(buf + offset, 0, padding);\n<105> offset += padding;\n<111> memcpy(buf + offset, backing_file, backing_file_len);\n<133> uint32_t be_backing_file_size = cpu_to_be32(backing_file_len);
<1> static TraceEvent* find_trace_event_by_name(const char *tname)\n<9> if (!tname) {\n<17> for (i = 0; i < NR_TRACE_EVENTS; i++) {\n<19> if (!strcmp(trace_list[i].tp_name, tname)) {\n<21> return &trace_list[i];
<1> static int compress_bidder_init ( struct archive_read_filter * self ) {\n<3> static const size_t out_block_size = 64 * 1024 ;\n<8> state = ( struct private_data * ) calloc ( sizeof ( * state ) , 1 ) ;\n<9> out_block = malloc ( out_block_size ) ;\n<10> if ( state == NULL || out_block == NULL ) {\n<11> free ( out_block ) ;\n<12> free ( state ) ;\n<17> state -> out_block_size = out_block_size ;\n<18> state -> out_block = out_block ;
<1> int xbzrle_decode_buffer(uint8_t *src, int slen, uint8_t *dst, int dlen)\n<9> uint32_t count = 0;\n<27> ret = uleb128_decode_small(src + i, &count);\n<29> if (ret < 0 || (i && !count)) {\n<37> d += count;\n<43> if (d > dlen) {\n<61> ret = uleb128_decode_small(src + i, &count);\n<63> if (ret < 0 || !count) {\n<69> i += ret;\n<75> if (d + count > dlen || i + count > slen) {\n<83> memcpy(dst + d, src + i, count);\n<85> d += count;\n<87> i += count;
<1> test_tls_get_ipaddr(const char *addrstr,\n<15> memset(&hints, 0, sizeof(hints));\n<19> g_assert(getaddrinfo(addrstr, NULL, &hints, &res) == 0);\n<23> *datalen = res->ai_addrlen;\n<27> memcpy(*data, res->ai_addr, *datalen);
<1> static void bastardized_rice_decompress(ALACContext *alac,\n<3> int32_t *output_buffer,\n<105> if (block_size > 0) {\n<115> memset(&output_buffer[output_count+1], 0, block_size * 4);
<1> static EC_GROUP * ec_asn1_parameters2group ( const ECPARAMETERS * params ) {\n<106> if ( ret == NULL ) {\n<112> if ( ! ( ret -> seed = OPENSSL_malloc ( params -> curve -> seed -> length ) ) ) {\n<116> memcpy ( ret -> seed , params -> curve -> seed -> data , params -> curve -> seed -> length ) ;\n<117> ret -> seed_len = params -> curve -> seed -> length ;\n<123> if ( ( point = EC_POINT_new ( ret ) ) == NULL ) goto err ;\n<124> EC_GROUP_set_point_conversion_form ( ret , ( point_conversion_form_t ) ( params -> base -> data [ 0 ] & ~ 0x01 ) ) ;\n<125> if ( ! EC_POINT_oct2point ( ret , point , params -> base -> data , params -> base -> length , NULL ) ) {\n<151> if ( ! EC_GROUP_set_generator ( ret , point , a , b ) ) {\n<157> if ( ret ) EC_GROUP_clear_free ( ret ) ;\n<164> return ( ret ) ;
<1> static float tilt_factor ( float * lpc_n , float * lpc_d ) {\n<6> float * hf = impulse_buffer + LP_FILTER_ORDER ;\n<7> hf [ 0 ] = 1.0 ;\n<8> memcpy ( hf + 1 , lpc_n , sizeof ( float ) * LP_FILTER_ORDER ) ;
<1> METHOD ( stroke_socket_t , destroy , void , private_stroke_socket_t * this ) {\n<2> DESTROY_IF ( this -> service ) ;\n<8> this -> cred -> destroy ( this -> cred ) ;\n<9> this -> ca -> destroy ( this -> ca ) ;\n<10> this -> config -> destroy ( this -> config ) ;\n<11> this -> attribute -> destroy ( this -> attribute ) ;\n<12> this -> handler -> destroy ( this -> handler ) ;\n<13> this -> control -> destroy ( this -> control ) ;\n<14> this -> list -> destroy ( this -> list ) ;\n<15> this -> counter -> destroy ( this -> counter ) ;\n<16> free ( this ) ;
<1> static int handle_cmd(AHCIState *s, int port, int slot)\n<77> ide_state = &s->dev[port].port.ifs[0];\n<91> debug_print_fis(cmd_fis, 0x90);\n<245> if (opts & AHCI_CMD_ATAPI) {\n<247> memcpy(ide_state->io_buffer, &cmd_fis[AHCI_COMMAND_TABLE_ACMD], 0x10);\n<249> debug_print_fis(ide_state->io_buffer, 0x10);
<1> static int qcrypto_cipher_setiv_aes(QCryptoCipher *cipher,\n<3> const uint8_t *iv, size_t niv,\n<11> if (niv != 16) {\n<23> ctxt->state.aes.iv = g_new0(uint8_t, niv);\n<25> memcpy(ctxt->state.aes.iv, iv, niv);\n<27> ctxt->state.aes.niv = niv;
<1> int ff_mov_lang_to_iso639(int code, char *to)\n<27> if (code >= FF_ARRAY_ELEMS(mov_mdhd_language_map))\n<31> if (!mov_mdhd_language_map[code])\n<35> strncpy(to, mov_mdhd_language_map[code], 4);
<1> static int qemuAgentOpenUnix ( const char * monitor , pid_t cpid , bool * inProgress ) {\n<15> if ( virSetCloseExec ( monfd ) < 0 ) {\n<19> memset ( & addr , 0 , sizeof ( addr ) ) ;\n<27> ret = connect ( monfd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ;
<1> int tm_poll ( tm_event_t poll_event , tm_event_t * result_event , int wait , int * tm_errno ) {\n<82> case TM_INIT : nnodes = disrsi ( static_chan , & ret ) ;\n<83> if ( ret != DIS_SUCCESS ) {\n<86> node_table = ( tm_node_id * ) calloc ( nnodes + 1 , sizeof ( tm_node_id ) ) ;\n<87> if ( node_table == NULL ) {\n<151> case TM_GETINFO : ihold = ( struct infohold * ) ep -> e_info ;\n<152> info = disrcs ( static_chan , ( size_t * ) ihold -> info_len , & ret ) ;\n<153> if ( ret != DIS_SUCCESS ) {\n<154> if ( info != NULL ) free ( info ) ;\n<157> memcpy ( ihold -> info , info , MIN ( * ihold -> info_len , ihold -> len ) ) ;\n<158> free ( info ) ;\n<162> if ( ret != DIS_SUCCESS ) {\n<163> if ( info != NULL ) free ( info ) ;\n<166> snprintf ( rhold -> resc , rhold -> len , "%s" , info ) ;\n<167> free ( info ) ;\n<172> tm_poll_done : if ( jobid != NULL ) free ( jobid ) ;\n<179> tm_poll_error : if ( jobid != NULL ) free ( jobid ) ;
<1> static gint64 ascend_seek ( wtap * wth , int * err , gchar * * err_info ) {\n<4> size_t string_level [ ASCEND_MAGIC_STRINGS ] ;\n<7> memset ( & string_level , 0 , sizeof ( string_level ) ) ;\n<15> string_i < ASCEND_MAGIC_STRINGS ;\n<16> string_i ++ ) {\n<17> const gchar * strptr = ascend_magic [ string_i ] . strptr ;\n<18> size_t len = strlen ( strptr ) ;\n<19> if ( byte == * ( strptr + string_level [ string_i ] ) ) {\n<21> if ( string_level [ string_i ] >= len ) {\n<23> if ( cur_off == - 1 ) {\n<27> if ( strcmp ( strptr , ASCEND_DATE ) == 0 ) {\n<28> date_off = cur_off - len ;\n<29> string_level [ string_i ] = 0 ;\n<32> if ( date_off == - 1 ) {\n<38> type = ascend_magic [ string_i ] . type ;\n<50> found : if ( file_seek ( wth -> fh , packet_off , SEEK_SET , err ) == - 1 ) return - 1 ;
<1> static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *insamples)\n<41> if (!outpicref)\n<59> memset(outpicref->data[0], 0, showwaves->h*linesize);\n<69> *(outpicref->data[0] + showwaves->buf_idx + h * linesize) += x;
<1> QEMUSizedBuffer *qsb_create(const uint8_t *buffer, size_t len)\n<53> if (!qsb->iov[i].iov_base) {\n<67> if (buffer) {\n<73> memcpy(qsb->iov[i].iov_base, &buffer[qsb->used], to_copy);\n<75> qsb->used += to_copy;
<1> static void win32_aio_process_completion(QEMUWin32AIOState *s,\n<49> char *p = waiocb->buf;\n<55> for (i = 0; i < qiov->niov; ++i) {\n<57> memcpy(qiov->iov[i].iov_base, p, qiov->iov[i].iov_len);\n<59> p += qiov->iov[i].iov_len;
<1> static int add_metadata_from_side_data(AVCodecContext *avctx, AVFrame *frame)\n<23> while (side_metadata < end) {\n<25> const uint8_t *key = side_metadata;\n<27> const uint8_t *val = side_metadata + strlen(key) + 1;\n<29> int ret = av_dict_set(avpriv_frame_get_metadatap(frame), key, val, 0);\n<31> if (ret < 0)\n<35> side_metadata = val + strlen(val) + 1;
<1> static void process_ls_object ( struct remote_ls_ctx * ls ) {\n<5> if ( ! strcmp ( ls -> path , ls -> dentry_name ) && ( ls -> flags & IS_DIR ) ) {\n<6> remote_dir_exists [ * parent ] = 1 ;\n<7> return ;\n<9> if ( ! skip_prefix ( path , "objects/" , & path ) || get_sha1_hex_from_objpath ( path , sha1 ) ) return ;
<1> static bfd_boolean srec_get_section_contents ( bfd * abfd , asection * section , void * location , file_ptr offset , bfd_size_type count ) {\n<3> if ( offset + count < count || offset + count > section -> size ) {\n<7> if ( section -> used_by_bfd == NULL ) {\n<9> if ( section -> used_by_bfd == NULL ) return FALSE ;\n<10> if ( ! srec_read_section ( abfd , section , ( bfd_byte * ) section -> used_by_bfd ) ) return FALSE ;\n<12> memcpy ( location , ( bfd_byte * ) section -> used_by_bfd + offset , ( size_t ) count ) ;
<1> static void data_destroy_indic ( void * data ) {\n<2> free ( data ) ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<28> uint8_t * dst = pic -> data [ 0 ] ;\n<31> field_size = bytestream_get_le32 ( & buf ) ;\n<36> if ( buf_end - buf < field_size ) {\n<40> if ( field ) dst += pic -> linesize [ 0 ] ;\n<42> i < field_h ;\n<44> memcpy ( dst , buf , avctx -> width * 2 ) ;\n<45> buf += avctx -> width * 2 ;\n<46> dst += pic -> linesize [ 0 ] << 1 ;
<1> static int run_command ( char * cmd , DYNAMIC_STRING * ds_res ) {\n<9> if ( ! ( res_file = popen ( cmd , "r" ) ) ) {\n<13> while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n<14> DBUG_PRINT ( "info" , ( "buf: %s" , buf ) ) ;\n<15> if ( ds_res ) {\n<19> fprintf ( stdout , "%s" , buf ) ;\n<22> error = pclose ( res_file ) ;
<1> int kvm_arch_pre_run(CPUState *env, struct kvm_run *run)\n<16> dprintf("injected interrupt %d\n", irq);\n<17> r = kvm_vcpu_ioctl(env, KVM_INTERRUPT, &irq);\n<18> if (r < 0)\n<19> printf("cpu %d fail inject %x\n", env->cpu_index, irq);
<1> void ff_cavs_filter ( AVSContext * h , enum cavs_mb mb_type ) {\n<2> uint8_t bs [ 8 ] ;\n<8> memcpy ( & h -> top_border_y [ h -> mbx * 16 ] , h -> cy + 15 * h -> l_stride , 16 ) ;\n<9> memcpy ( & h -> top_border_u [ h -> mbx * 10 + 1 ] , h -> cu + 7 * h -> c_stride , 8 ) ;\n<10> memcpy ( & h -> top_border_v [ h -> mbx * 10 + 1 ] , h -> cv + 7 * h -> c_stride , 8 ) ;\n<20> if ( mb_type == I_8X8 ) memset ( bs , 2 , 8 ) ;\n<22> memset ( bs , 0 , 8 ) ;\n<36> if ( AV_RN64 ( bs ) ) {
<1> static Pattern_Prefix_Status like_fixed_prefix ( Const * patt_const , bool case_insensitive , Oid collation , Const * * prefix_const , Selectivity * rest_selec ) {\n<21> if ( typeid != BYTEAOID ) {\n<22> patt = TextDatumGetCString ( patt_const -> constvalue ) ;\n<23> pattlen = strlen ( patt ) ;\n<28> patt = ( char * ) palloc ( pattlen ) ;\n<29> memcpy ( patt , VARDATA ( bstr ) , pattlen ) ;\n<32> match = palloc ( pattlen + 1 ) ;\n<35> pos < pattlen ;\n<37> if ( patt [ pos ] == '%' || patt [ pos ] == '_' ) break ;\n<38> if ( patt [ pos ] == '\\' ) {\n<42> if ( case_insensitive && pattern_char_isalpha ( patt [ pos ] , is_multibyte , locale , locale_is_c ) ) break ;\n<43> match [ match_pos ++ ] = patt [ pos ] ;\n<48> if ( rest_selec != NULL ) * rest_selec = like_selectivity ( & patt [ pos ] , pattlen - pos , case_insensitive ) ;\n<49> pfree ( patt ) ;
<1> static int check_for_block_signature(BlockDriverState *bs, const uint8_t *buf)\n<23> for (i = 0; signatures[i][0] != 0; i++) {\n<25> if (memcmp(buf, signatures[i], 4) == 0) {\n<27> return 1;
<1> unsigned ff_els_decode_unsigned(ElsDecCtx *ctx, ElsUnsignedRung *ur)\n<49> if (!ur->rem_rung_list) {\n<51> ur->rem_rung_list = av_realloc(NULL, RUNG_SPACE);\n<53> if (!ur->rem_rung_list) {\n<61> memset(ur->rem_rung_list, 0, RUNG_SPACE);\n<63> ur->rung_list_size = RUNG_SPACE;\n<77> rung_node = &ur->rem_rung_list[n];\n<83> if (ur->rung_list_size <= (ur->avail_index + 2) * sizeof(ElsRungNode)) {\n<87> ptrdiff_t pos     = rung_node - ur->rem_rung_list;\n<95> if (!ur->rem_rung_list) {\n<97> av_free(ur->rem_rung_list);\n<105> memset((uint8_t *) ur->rem_rung_list + ur->rung_list_size, 0,\n<109> ur->rung_list_size += RUNG_SPACE;\n<123> rung_node = &ur->rem_rung_list[rung_node->next_index + bit];
<1> static void decode_plane(FFV1Context *s, uint8_t *src,\n<23> memset(s->sample_buffer, 0, 2 * (w + 6) * sizeof(*s->sample_buffer));\n<49> decode_line(s, w, sample, plane_index, 8);\n<57> decode_line(s, w, sample, plane_index, s->avctx->bits_per_raw_sample);
<1> int main(int argc, char* argv[])\n<23> if( argc<4 || 2 != sscanf(argv[3], "%dx%d", &w, &h) )\n<27> printf("tiny_ssim <file1.yuv> <file2.yuv> <width>x<height> [<seek>]\n");\n<29> return -1;\n<35> f[0] = fopen(argv[1], "rb");\n<37> f[1] = fopen(argv[2], "rb");\n<39> sscanf(argv[3], "%dx%d", &w, &h);\n<41> frame_size = w*h*3/2;\n<43> for( i=0; i<2; i++ )\n<47> buf[i] = malloc(frame_size);\n<49> plane[i][0] = buf[i];\n<51> plane[i][1] = plane[i][0] + w*h;\n<53> plane[i][2] = plane[i][1] + w*h/4;\n<57> temp = malloc((2*w+12)*sizeof(*temp));\n<59> seek = argc<5 ? 0 : atoi(argv[4]);\n<61> fseek(f[seek<0], seek < 0 ? -seek : seek, SEEK_SET);\n<65> for( frames=0;; frames++ )\n<73> if( fread(buf[0], frame_size, 1, f[0]) != 1) break;\n<75> if( fread(buf[1], frame_size, 1, f[1]) != 1) break;\n<81> ssd_one[i]  = ssd_plane ( plane[0][i], plane[1][i], w*h>>2*!!i );\n<83> ssim_one[i] = ssim_plane( plane[0][i], w>>!!i,\n<85> plane[1][i], w>>!!i,\n<87> w>>!!i, h>>!!i, temp, NULL );\n<97> printf("Frame %d | ", frames);\n<99> print_results(ssd_one, ssim_one, 1, w, h);\n<101> printf("                \r");\n<109> if( !frames ) return 0;\n<113> printf("Total %d frames | ", frames);\n<115> print_results(ssd, ssim, frames, w, h);\n<117> printf("\n");
<1> static uint16_t * build_linear_table ( int length ) {\n<3> uint16_t * output = malloc ( sizeof ( uint16_t ) * length ) ;\n<4> if ( ! output ) return NULL ;
<1> static void do_dma_memory_set(dma_addr_t addr, uint8_t c, dma_addr_t len)\n<7> uint8_t fillbuf[FILLBUF_SIZE];\n<13> memset(fillbuf, c, FILLBUF_SIZE);\n<19> cpu_physical_memory_rw(addr, fillbuf, l, true);
<1> static int sd_parse_uri(BDRVSheepdogState *s, const char *filename,\n<17> if (!uri) {\n<27> if (!strcmp(uri->scheme, "sheepdog")) {\n<29> s->is_unix = false;\n<31> } else if (!strcmp(uri->scheme, "sheepdog+tcp")) {\n<33> s->is_unix = false;\n<35> } else if (!strcmp(uri->scheme, "sheepdog+unix")) {\n<37> s->is_unix = true;\n<41> ret = -EINVAL;\n<49> if (uri->path == NULL || !strcmp(uri->path, "/")) {\n<51> ret = -EINVAL;\n<57> if (g_strlcpy(vdi, uri->path + 1, SD_MAX_VDI_LEN) >= SD_MAX_VDI_LEN) {\n<79> if (s->is_unix) {\n<83> if (uri->server || uri->port || strcmp(qp->p[0].name, "socket")) {\n<85> ret = -EINVAL;\n<91> s->host_spec = g_strdup(qp->p[0].value);\n<107> if (uri->fragment) {\n<133> uri_free(uri);
<1> static int ogg_new_stream(AVFormatContext *s, uint32_t serial, int new_avstream)\n<7> struct ogg *ogg = s->priv_data;\n<9> int idx = ogg->nstreams++;\n<21> memset (ogg->streams + idx, 0, sizeof (*ogg->streams));
<1> void vmxnet_tx_pkt_reset ( struct VmxnetTxPkt * pkt ) {\n<3> if ( ! pkt ) {\n<6> memset ( & pkt -> virt_hdr , 0 , sizeof ( pkt -> virt_hdr ) ) ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<5> DxaDecContext * const c = avctx -> priv_data ;\n<21> c -> pal [ i ] = ( r << 16 ) | ( g << 8 ) | b ;\n<26> if ( ( ret = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) {\n<30> memcpy ( frame -> data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n<32> outptr = frame -> data [ 0 ] ;\n<33> srcptr = c -> decomp_buf ;\n<46> if ( c -> prev . data [ 0 ] ) memcpy ( frame -> data [ 0 ] , c -> prev . data [ 0 ] , frame -> linesize [ 0 ] * avctx -> height ) ;\n<48> memset ( frame -> data [ 0 ] , 0 , frame -> linesize [ 0 ] * avctx -> height ) ;\n<58> if ( compr & 1 ) {\n<60> i < avctx -> width ;\n<61> i ++ ) outptr [ i ] = srcptr [ i ] ^ tmpptr [ i ] ;\n<64> else memcpy ( outptr , srcptr , avctx -> width ) ;\n<65> outptr += stride ;\n<66> srcptr += avctx -> width ;\n<71> decode_13 ( avctx , c , frame -> data [ 0 ] , frame -> linesize [ 0 ] , srcptr , c -> prev . data [ 0 ] ) ;
<1> int vp78_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<12> if (ret < 0)\n<20> if (avctx->skip_frame >= skip_thresh) {\n<22> memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);\n<45> if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n<56> if ((ret = vp8_alloc_frame(s, curframe, referenced)) < 0)\n<76> memset(s->top_nnz, 0, s->mb_width * sizeof(*s->top_nnz));\n<79> if (!s->mb_layout)\n<80> memset(s->macroblocks + s->mb_height * 2 - 1, 0,\n<81> (s->mb_width + 1) * sizeof(*s->macroblocks));\n<82> if (!s->mb_layout && s->keyframe)\n<83> memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width * 4);\n<84> memset(s->ref_count, 0, sizeof(s->ref_count));\n<117> memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);\n<130> memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);
<1> static void * main_malloc1 ( size_t size ) {\n<2> void * r = malloc ( size ) ;\n<3> if ( r == NULL ) {
<1> int main ( int argc , char * * argv ) {\n<29> if ( ( NULL == shellstr ) && ! change_environment ) {\n<30> shellstr = getenv ( "SHELL" ) ;\n<36> if ( NULL == shellstr ) {
<1> static int nextch ( IO * wrapper ) {\n<7> while ( io != NULL ) {\n<8> if ( io -> backedup != EOF ) {\n<13> else if ( io -> ps != NULL ) {\n<14> if ( ( ch = getc ( io -> ps ) ) != EOF ) return ( ch ) ;\n<16> else if ( io -> fog != NULL ) {\n<17> if ( io -> macro != NULL && * io -> macro != '\0' ) return ( * ( io -> macro ++ ) ) ;\n<18> ch = getfoghex ( io ) ;\n<23> else if ( ch != EOF && ch < 200 ) {\n<24> sprintf ( io -> fogbuf , "%d " , ch - 100 ) ;\n<25> io -> macro = io -> fogbuf ;\n<28> else if ( ch != EOF ) {\n<29> sprintf ( io -> fogbuf , "%d %s " , ch - 233 + 17 , io -> fogns ? "2 exch exp 3 1 roll 100 mul add mul" : "100 mul add" ) ;\n<30> io -> macro = io -> fogbuf ;\n<35> if ( ( ch = * ( io -> macro ++ ) ) != '\0' ) return ( ch ) ;\n<36> if ( -- io -> cnt > 0 ) {\n<41> wrapper -> top = io -> prev ;\n<42> if ( io -> isstopped ) wrapper -> endedstopped = true ;\n<43> if ( io -> start != NULL ) free ( io -> start ) ;\n<44> io -> start = NULL ;\n<45> free ( io ) ;\n<46> io = wrapper -> top ;\n<48> return ( EOF ) ;
<1> static int kvm_has_msr_star(CPUState *env)\n<31> if (ret < 0)\n<49> kvm_msr_list->nmsrs = msr_list.nmsrs;\n<51> ret = kvm_ioctl(env->kvm_state, KVM_GET_MSR_INDEX_LIST, kvm_msr_list);\n<59> for (i = 0; i < kvm_msr_list->nmsrs; i++) {\n<75> free(kvm_msr_list);
<1> static int read_directory(BDRVVVFATState* s, int mapping_index)\n<23> DIR* dir=opendir(dirname);\n<65> while((entry=readdir(dir))) {\n<67> unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n<75> int is_dot=!strcmp(entry->d_name,".");\n<77> int is_dotdot=!strcmp(entry->d_name,"..");\n<81> if(first_cluster == 0 && (is_dotdot || is_dot))\n<87> buffer = g_malloc(length);\n<89> snprintf(buffer,length,"%s/%s",dirname,entry->d_name);\n<93> if(stat(buffer,&st)<0) {\n<105> if (!is_dot && !is_dotdot) {\n<107> direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n<115> direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n<119> direntry->ctime=fat_datetime(st.st_ctime,1);\n<121> direntry->cdate=fat_datetime(st.st_ctime,0);\n<123> direntry->adate=fat_datetime(st.st_atime,0);\n<125> direntry->begin_hi=0;\n<127> direntry->mtime=fat_datetime(st.st_mtime,1);\n<129> direntry->mdate=fat_datetime(st.st_mtime,0);\n<141> direntry->begin=0; /* do that later */\n<143> if (st.st_size > 0x7fffffff) {\n<145> fprintf(stderr, "File %s is larger than 2GB\n", buffer);\n<147> g_free(buffer);\n<155> direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n<161> if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n<217> while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n<219> direntry_t* direntry=array_get_next(&(s->directory));\n<221> memset(direntry,0,sizeof(direntry_t));\n<231> if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n<241> memset(array_get(&(s->directory), cur), 0,\n<243> (ROOT_ENTRIES - cur) * sizeof(direntry_t));
<1> int fill_schema_column_privileges ( THD * thd , TABLE_LIST * tables , COND * cond ) {\n<6> bool no_global_access = check_access ( thd , SELECT_ACL , "mysql" , 0 , 1 , 1 , 0 ) ;\n<11> index < column_priv_hash . records ;\n<12> index ++ ) {\n<15> if ( ! ( user = grant_table -> user ) ) user = "" ;\n<17> if ( no_global_access && ( strcmp ( thd -> security_ctx -> priv_user , user ) || my_strcasecmp ( system_charset_info , curr_host , host ) ) ) continue ;\n<18> ulong table_access = grant_table -> cols ;\n<19> if ( table_access != 0 ) {\n<22> strxmov ( buff , "'" , user , "'@'" , host , "'" , NullS ) ;
<1> static void destroy_restrict_node ( restrict_node * my_node ) {\n<2> destroy_address_node ( my_node -> addr ) ;\n<3> destroy_address_node ( my_node -> mask ) ;\n<4> destroy_int_fifo ( my_node -> flags ) ;\n<5> free ( my_node ) ;
<1> static void build_fs_mount_list_from_mtab(FsMountList *mounts, Error **errp)\n<29> while ((ment = getmntent(fp))) {\n<43> if ((ment->mnt_fsname[0] != '/') ||\n<45> (strcmp(ment->mnt_type, "smbfs") == 0) ||\n<47> (strcmp(ment->mnt_type, "cifs") == 0)) {\n<67> mount->devtype = g_strdup(ment->mnt_type);
<1> static int pnm_decode_frame(AVCodecContext *avctx, void *data,\n<27> s->bytestream       = (uint8_t *)buf;\n<33> if ((ret = ff_pnm_decode_header(avctx, s)) < 0)\n<157> ptr      = p->data[0];\n<161> if (s->bytestream + n * avctx->height > s->bytestream_end)\n<223> if (!upgrade)\n<225> memcpy(ptr, s->bytestream, n);\n<231> for (j = 0; j < n; j++)\n<233> ptr[j] = ((s->bytestream[j] & maskval) * f + 64) >> 7;\n<239> for (j = 0; j < n / 2; j++) {\n<249> s->bytestream += n;\n<251> ptr           += linesize;\n<273> ptr      = p->data[0];\n<281> if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end)\n<285> for (i = 0; i < avctx->height; i++) {\n<287> memcpy(ptr, s->bytestream, n);\n<289> s->bytestream += n;\n<291> ptr           += linesize;\n<295> ptr1 = p->data[1];\n<297> ptr2 = p->data[2];\n<299> n >>= 1;\n<303> for (i = 0; i < h; i++) {\n<305> memcpy(ptr1, s->bytestream, n);\n<307> s->bytestream += n;\n<309> memcpy(ptr2, s->bytestream, n);\n<311> s->bytestream += n;\n<313> ptr1 += p->linesize[1];\n<315> ptr2 += p->linesize[2];
<1> void appendPsqlMetaConnect ( PQExpBuffer buf , const char * dbname ) {\n<8> if ( * s == '\n' || * s == '\r' ) {\n<9> fprintf ( stderr , _ ( "database name contains a newline or carriage return: \"%s\"\n" ) , dbname ) ;\n<21> appendConnStrVal ( & connstr , dbname ) ;\n<26> else appendPQExpBufferStr ( buf , fmtId ( dbname ) ) ;
<1> static void init_parse_context(OptionParseContext *octx,\n<13> memset(octx, 0, sizeof(*octx));\n<19> octx->groups    = av_mallocz(sizeof(*octx->groups) * octx->nb_groups);\n<21> if (!octx->groups)\n<27> for (i = 0; i < octx->nb_groups; i++)
<1> static void print_track_chunks(FILE *out, struct Tracks *tracks, int main,\n<3> const char *type)\n<9> struct Track *track = tracks->tracks[main];\n<11> for (i = 0; i < track->chunks; i++) {\n<15> if (tracks->tracks[j]->is_audio == track->is_audio &&\n<17> track->offsets[i].duration != tracks->tracks[j]->offsets[i].duration)\n<19> fprintf(stderr, "Mismatched duration of %s chunk %d in %s and %s\n",
<1> MYSQL_STMT * open_cursor ( const char * query ) {\n<4> MYSQL_STMT * stmt = mysql_stmt_init ( mysql ) ;\n<5> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<6> check_execute ( stmt , rc ) ;
<1> static int planarCopyWrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,\n<3> int srcSliceH, uint8_t* dst[], int dstStride[])\n<11> int length= (plane==0 || plane==3) ? c->srcW  : -((-c->srcW  )>>c->chrDstHSubSample);\n<17> const uint8_t *srcPtr= src[plane];\n<19> uint8_t *dstPtr= dst[plane] + dstStride[plane]*y;\n<23> if (!dst[plane]) continue;\n<29> if (!src[plane] || (plane == 1 && !src[2])) {\n<275> srcPtr  += srcStride[plane]; \\n<319> dstPtr[ j<<1   ] = srcPtr[j];\n<321> dstPtr[(j<<1)+1] = srcPtr[j];\n<325> srcPtr+= srcStride[plane];\n<351> srcStride[plane] > 0 && srcStride[plane] == length) {\n<353> memcpy(dst[plane] + dstStride[plane]*y, src[plane],\n<355> height*dstStride[plane]);\n<361> length*=2;\n<363> for (i=0; i<height; i++) {\n<365> memcpy(dstPtr, srcPtr, length);\n<367> srcPtr+= srcStride[plane];\n<369> dstPtr+= dstStride[plane];
<1> static int bfi_decode_frame(AVCodecContext * avctx, void *data,\n<15> uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n<33> if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n<211> src = bfi->dst;\n<213> dst = bfi->frame.data[0];\n<215> while (height--) {\n<217> memcpy(dst, src, avctx->width);\n<219> src += avctx->width;\n<221> dst += bfi->frame.linesize[0];
<1> void kadmin_delprinc ( int argc , char * argv [ ] ) {\n<4> char * canon = NULL ;\n<6> if ( ! ( argc == 2 || ( argc == 3 && ! strcmp ( "-force" , argv [ 1 ] ) ) ) ) {\n<7> fprintf ( stderr , _ ( "usage: delete_principal [-force] principal\n" ) ) ;\n<8> return ;\n<10> retval = kadmin_parse_name ( argv [ argc - 1 ] , & princ ) ;\n<11> if ( retval ) {\n<15> retval = krb5_unparse_name ( context , princ , & canon ) ;\n<20> if ( argc == 2 ) {\n<21> printf ( _ ( "Are you sure you want to delete the principal \"%s\"? " "(yeso): " ) , canon ) ;\n<22> fgets ( reply , sizeof ( reply ) , stdin ) ;\n<23> if ( strcmp ( "yes\n" , reply ) ) {\n<24> fprintf ( stderr , _ ( "Principal \"%s\" not deleted\n" ) , canon ) ;\n<28> retval = kadm5_delete_principal ( handle , princ ) ;\n<29> if ( retval ) {\n<30> com_err ( "delete_principal" , retval , _ ( "while deleting principal \"%s\"" ) , canon ) ;\n<33> printf ( _ ( "Principal \"%s\" deleted.\n" ) , canon ) ;\n<34> printf ( _ ( "Make sure that you have removed this principal from all ACLs " "before reusing.\n" ) ) ;\n<36> free ( canon ) ;
<1> int ff_h2645_extract_rbsp(const uint8_t *src, int length,\n<19> if (i + 2 < length && src[i + 1] == 0 && src[i + 2] <= 3) {     \\n<95> if (i > 0 && src[i - 1] == 0)\n<107> if (i >= length - 1 && small_padding) { // no escaped 0\n<127> if (!nal->rbsp_buffer)\n<133> dst = nal->rbsp_buffer;\n<137> memcpy(dst, src, i);\n<139> si = di = i;\n<141> while (si + 2 < length) {\n<145> if (src[si + 2] > 3) {\n<147> dst[di++] = src[si++];\n<149> dst[di++] = src[si++];\n<151> } else if (src[si] == 0 && src[si + 1] == 0 && src[si + 2] != 0) {\n<153> if (src[si + 2] == 3) { // escape\n<157> dst[di++] = 0;\n<191> nal->skipped_bytes_pos[nal->skipped_bytes-1] = di - 1;\n<205> dst[di++] = src[si++];\n<211> dst[di++] = src[si++];\n<217> memset(dst + di, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n<221> nal->data = dst;\n<225> nal->raw_data = src;
<1> static void hb_fir_filter ( float * out , const float fir_coef [ HB_FIR_SIZE + 1 ] , float mem [ HB_FIR_SIZE ] , const float * in ) {\n<3> float data [ AMRWB_SFR_SIZE_16k + HB_FIR_SIZE ] ;\n<4> memcpy ( data , mem , HB_FIR_SIZE * sizeof ( float ) ) ;\n<5> memcpy ( data + HB_FIR_SIZE , in , AMRWB_SFR_SIZE_16k * sizeof ( float ) ) ;\n<7> i < AMRWB_SFR_SIZE_16k ;\n<12> j ++ ) out [ i ] += data [ i + j ] * fir_coef [ j ] ;\n<14> memcpy ( mem , data + AMRWB_SFR_SIZE_16k , HB_FIR_SIZE * sizeof ( float ) ) ;
<1> static const uint8_t * read_huffman_tables ( FourXContext * f , const uint8_t * const buf ) {\n<12> memset ( up , - 1 , sizeof ( up ) ) ;\n<67> up [ node ] != - 1 ;\n<68> node = up [ node ] ) {
<1> void mime_field_value_extend_comma_val ( HdrHeap * heap , MIMEHdrImpl * mh , MIMEField * field , int idx , const char * new_piece_str , int new_piece_len ) {\n<8> if ( ( idx < 0 ) || ( idx >= list . count ) ) {\n<12> ink_assert ( cell != nullptr ) ;\n<13> if ( ( cell -> len >= 2 ) && ( cell -> str [ 0 ] == '\"' ) && ( cell -> str [ cell -> len - 1 ] == '\"' ) ) {\n<15> cell -> str += 1 ;\n<16> cell -> len -= 2 ;\n<28> dest = temp_ptr ;\n<30> * dest ++ = '\"' ;\n<32> memcpy ( dest , cell -> str , cell -> len ) ;\n<33> dest += cell -> len ;\n<34> memcpy ( dest , new_piece_str , new_piece_len ) ;\n<35> dest += new_piece_len ;
<1> static bool cgfs_unfreeze ( void * hdata ) {\n<8> if ( ! cgabspath ) return false ;\n<9> ret = do_cgroup_set ( cgabspath , "freezer.state" , "THAWED" ) ;\n<10> free ( cgabspath ) ;
<1> static int noise(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,\n<3> const uint8_t *buf, int buf_size, int keyframe){\n<7> *poutbuf= av_malloc(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<8> memcpy(*poutbuf, buf, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
<1> DeviceState * qdev_device_add ( QemuOpts * opts ) {\n<7> if ( ! driver ) {\n<11> if ( strcmp ( driver , "?" ) == 0 ) {\n<12> char msg [ 256 ] ;\n<13> for ( info = device_info_list ;\n<14> info != NULL ;\n<19> return NULL ;\n<21> info = qdev_find_info ( NULL , driver ) ;\n<22> if ( ! info ) {
<1> void save_and_apply_config_tree ( void ) {\n<5> memcpy ( ptree , & cfgt , sizeof ( * ptree ) ) ;\n<6> memset ( & cfgt , 0 , sizeof ( cfgt ) ) ;\n<7> LINK_TAIL_SLIST ( cfg_tree_history , ptree , link , config_tree ) ;
<1> static void test_explain_bug ( ) {\n<19> if ( ! opt_silent ) fprintf ( stdout , "\n total fields in the result: %d" , mysql_num_fields ( result ) ) ;\n<42> if ( ! opt_silent ) fprintf ( stdout , "\n total fields in the result: %d" , mysql_num_fields ( result ) ) ;
<1> static int do_token_out(USBDevice *s, USBPacket *p)\n<33> if (!(s->setup_buf[0] & USB_DIR_IN)) {\n<35> int len = s->setup_len - s->setup_index;\n<37> if (len > p->len)\n<39> len = p->len;\n<41> memcpy(s->data_buf + s->setup_index, p->data, len);\n<43> s->setup_index += len;\n<49> return len;
<1> void net_client_uninit(NICInfo *nd)\n<11> free((void *)nd->model);
<1> static void pdf_process_Do ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi ) {\n<22> else if ( pdf_name_eq ( ctx , subtype , PDF_NAME_Image ) ) {\n<30> else if ( ! strcmp ( pdf_to_name ( ctx , subtype ) , "PS" ) ) fz_warn ( ctx , "ignoring XObject with subtype PS" ) ;\n<31> else fz_warn ( ctx , "ignoring XObject with unknown subtype: '%s'" , pdf_to_name ( ctx , subtype ) ) ;
<1> int main ( void ) {\n<2> fprintf ( stderr , "libxml was not compiled with thread or catalog support\n" ) ;
<1> static int local_symlink(FsContext *fs_ctx, const char *oldpath,\n<25> if (fd == -1) {\n<33> oldpath_size = strlen(oldpath) + 1;\n<37> write_size = write(fd, (void *)oldpath, oldpath_size);
<1> kadm5_ret_t kadm5_setkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * keyblocks , int n_keys ) {\n<24> ret = make_ks_from_keys ( handle -> context , n_keys , keyblocks , & ks_from_keys ) ;\n<25> if ( ret ) goto done ;\n<26> ret = apply_keysalt_policy ( handle , adb . policy , n_keys , ks_from_keys , NULL , NULL ) ;\n<27> free ( ks_from_keys ) ;\n<53> old_key_data = kdb -> key_data ;\n<59> old_key_data = NULL ;\n<62> if ( kdb -> key_data == NULL ) {\n<66> memset ( kdb -> key_data , 0 , ( n_keys + n_old_keys ) * sizeof ( krb5_key_data ) ) ;\n<71> if ( n_ks_tuple ) {\n<75> if ( ks_tuple [ i ] . ks_enctype != keyblocks [ i ] . enctype ) {\n<80> memset ( & tmp_key_data , 0 , sizeof ( tmp_key_data ) ) ;\n<83> ret = krb5_dbe_encrypt_key_data ( handle -> context , act_mkey , & keyblocks [ i ] , n_ks_tuple ? & keysalt : NULL , kvno + 1 , & tmp_key_data ) ;\n<85> tptr = & kdb -> key_data [ i ] ;\n<86> tptr -> key_data_ver = tmp_key_data . key_data_ver ;\n<87> tptr -> key_data_kvno = tmp_key_data . key_data_kvno ;\n<89> k < tmp_key_data . key_data_ver ;\n<92> tptr -> key_data_length [ k ] = tmp_key_data . key_data_length [ k ] ;\n<94> tptr -> key_data_contents [ k ] = krb5_db_alloc ( handle -> context , NULL , tmp_key_data . key_data_length [ k ] ) ;\n<95> if ( tptr -> key_data_contents [ k ] == NULL ) {\n<98> i1 < tmp_key_data . key_data_ver ;\n<100> if ( tmp_key_data . key_data_contents [ i1 ] ) {\n<101> memset ( tmp_key_data . key_data_contents [ i1 ] , 0 , tmp_key_data . key_data_length [ i1 ] ) ;\n<102> free ( tmp_key_data . key_data_contents [ i1 ] ) ;\n<108> memcpy ( tptr -> key_data_contents [ k ] , tmp_key_data . key_data_contents [ k ] , tmp_key_data . key_data_length [ k ] ) ;\n<109> memset ( tmp_key_data . key_data_contents [ k ] , 0 , tmp_key_data . key_data_length [ k ] ) ;\n<110> free ( tmp_key_data . key_data_contents [ k ] ) ;\n<111> tmp_key_data . key_data_contents [ k ] = NULL ;\n<117> i < n_old_keys ;\n<119> kdb -> key_data [ i + n_keys ] = old_key_data [ i ] ;\n<120> memset ( & old_key_data [ i ] , 0 , sizeof ( krb5_key_data ) ) ;\n<123> if ( old_key_data ) krb5_db_free ( handle -> context , old_key_data ) ;\n<142> if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto done ;\n<144> if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ;\n<146> done : kdb_free_entry ( handle , kdb , & adb ) ;
<1> void ff_ivi_process_empty_tile(AVCodecContext *avctx, IVIBandDesc *band,\n<167> src = band->ref_buf + tile->ypos * band->pitch + tile->xpos;\n<169> dst = band->buf     + tile->ypos * band->pitch + tile->xpos;\n<171> for (y = 0; y < tile->height; y++) {\n<173> memcpy(dst, src, tile->width*sizeof(band->buf[0]));\n<175> src += band->pitch;\n<177> dst += band->pitch;
<1> static ssize_t mp_dacl_listxattr(FsContext *ctx, const char *path,\n<11> if (!value) {\n<19> if (osize < len) {\n<31> memcpy(value, ACL_ACCESS, len);
<1> static void mp_flush ( MPADecodeContext * ctx ) {\n<2> memset ( ctx -> synth_buf , 0 , sizeof ( ctx -> synth_buf ) ) ;
<1> static void name_from_addr ( struct sockaddr * sa , socklen_t salen , char * * phost , char * * pport ) {\n<3> char strport [ NI_MAXSERV ] ;\n<12> if ( ni_result != 0 ) return ;\n<14> * pport = strdup ( strport ) ;
<1> static int entry_to_archive ( struct cpio * cpio , struct archive_entry * entry ) {\n<2> const char * destpath = archive_entry_pathname ( entry ) ;\n<7> if ( cpio -> verbose ) fprintf ( stderr , "%s" , destpath ) ;\n<8> if ( cpio -> dot ) fprintf ( stderr , "." ) ;
<1> static int mmsh_open(URLContext *h, const char *uri, int flags)\n<85> if (err) {\n<99> memset(headers, 0, sizeof(headers));\n<161> dprintf(NULL, "out_buffer is %s", headers);
<1> int inet_dgram_opts(QemuOpts *opts, Error **errp)\n<17> memset(&ai,0, sizeof(ai));\n<19> ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n<21> ai.ai_family = PF_UNSPEC;\n<23> ai.ai_socktype = SOCK_DGRAM;\n<31> if (addr == NULL || strlen(addr) == 0) {\n<33> addr = "localhost";\n<37> if (port == NULL || strlen(port) == 0) {\n<39> error_setg(errp, "remote port not specified");\n<41> return -1;\n<47> if (qemu_opt_get_bool(opts, "ipv4", 0))\n<49> ai.ai_family = PF_INET;\n<51> if (qemu_opt_get_bool(opts, "ipv6", 0))\n<53> ai.ai_family = PF_INET6;\n<57> if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n<71> memset(&ai,0, sizeof(ai));\n<85> if (addr == NULL || strlen(addr) == 0) {\n<87> addr = NULL;\n<91> if (!port || strlen(port) == 0)\n<93> port = "0";\n<97> if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {
<1> static void srec_print_symbol ( bfd * abfd , void * afile , asymbol * symbol , bfd_print_symbol_type how ) {\n<2> FILE * file = ( FILE * ) afile ;\n<3> switch ( how ) {\n<4> case bfd_print_symbol_name : fprintf ( file , "%s" , symbol -> name ) ;\n<6> default : bfd_print_symbol_vandf ( abfd , ( void * ) file , symbol ) ;\n<7> fprintf ( file , " %-5s %s" , symbol -> section -> name , symbol -> name ) ;
<1> static __inline__ int TCM_SET ( void * msg , __u16 cmd , __u16 flags , void * data , __u16 data_len ) {\n<9> if ( data_len && data ) {\n<10> memcpy ( TCM_DATA ( msg ) , data , data_len ) ;\n<11> memset ( TCM_DATA ( msg ) + data_len , 0 , TCM_SPACE ( data_len ) - msg_len ) ;
<1> static uint64_t pxa2xx_ssp_read ( void * opaque , hwaddr addr , unsigned size ) {\n<12> if ( s -> rx_level < 1 ) {\n<13> printf ( "%s: SSP Rx Underrun\n" , __FUNCTION__ ) ;
<1> static void parse_from_commit ( struct branch * b , char * buf , unsigned long size ) {\n<2> if ( ! buf || size < 46 ) die ( "Not a valid commit: %s" , sha1_to_hex ( b -> sha1 ) ) ;\n<3> if ( memcmp ( "tree " , buf , 5 ) || get_sha1_hex ( buf + 5 , b -> branch_tree . versions [ 1 ] . sha1 ) ) die ( "The commit %s is corrupt" , sha1_to_hex ( b -> sha1 ) ) ;
<1> static void vnc_dpy_copy(DisplayChangeListener *dcl,\n<25> src_row += pitch * (h-1);\n<26> dst_row += pitch * (h-1);\n<47> cmp_bytes = s * VNC_SERVER_FB_BYTES;\n<48> if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n<50> memmove(dst_row, src_row, cmp_bytes);\n<55> src_row += pitch - w * VNC_SERVER_FB_BYTES;\n<56> dst_row += pitch - w * VNC_SERVER_FB_BYTES;
<1> static void decode_scaling_list(GetBitContext *gb, uint8_t *factors, int size,\n<3> const uint8_t *jvt_list,\n<5> const uint8_t *fallback_list)\n<13> if (!get_bits1(gb)) /* matrix not written, we use the predicted one */\n<15> memcpy(factors, fallback_list, size * sizeof(uint8_t));\n<25> if (!i && !next) { /* matrix not written, we use the preset one */\n<27> memcpy(factors, jvt_list, size * sizeof(uint8_t));\n<33> last = factors[scan[i]] = next ? next : last;
<1> static int qcow2_write_compressed(BlockDriverState *bs, int64_t sector_num,\n<3> const uint8_t *buf, int nb_sectors)\n<7> BDRVQcowState *s = bs->opaque;\n<37> if (nb_sectors != s->cluster_sectors) {\n<45> if (sector_num + nb_sectors == bs->total_sectors &&\n<49> uint8_t *pad_buf = qemu_blockalign(bs, s->cluster_size);\n<51> memset(pad_buf, 0, s->cluster_size);\n<53> memcpy(pad_buf, buf, nb_sectors * BDRV_SECTOR_SIZE);\n<75> memset(&strm, 0, sizeof(strm));\n<103> ret = deflate(&strm, Z_FINISH);\n<107> deflateEnd(&strm);\n<115> out_len = strm.next_out - out_buf;\n<119> deflateEnd(&strm);
<1> static int flac_probe(AVProbeData *p)\n<11> if(bufptr > end-4 || memcmp(bufptr, "fLaC", 4)) return 0;\n<13> else                                            return AVPROBE_SCORE_MAX/2;
<1> static const char * cmd_argument_separator ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n<3> if ( strlen ( p1 ) != 1 ) {\n<4> return apr_psprintf ( cmd -> pool , "ModSecurity: Invalid argument separator: %s" , p1 ) ;\n<6> dcfg -> argument_separator = p1 [ 0 ] ;\n<7> return NULL ;
<1> static int xen_host_pci_get_value(XenHostPCIDevice *d, const char *name,\n<29> if (fd == -1) {\n<31> XEN_HOST_PCI_LOG("Error: Can't open %s: %s\n", path, strerror(errno));\n<33> return -errno;
<1> int ssl3_read_bytes ( SSL * s , int type , int * recvd_type , unsigned char * buf , int len , int peek ) {\n<88> if ( len <= 0 ) return ( len ) ;\n<91> if ( ( unsigned int ) len - read_bytes > SSL3_RECORD_get_length ( rr ) ) n = SSL3_RECORD_get_length ( rr ) ;\n<92> else n = ( unsigned int ) len - read_bytes ;\n<93> memcpy ( buf , & ( rr -> data [ rr -> off ] ) , n ) ;\n<94> buf += n ;\n<96> SSL3_RECORD_sub_length ( rr , n ) ;\n<104> if ( SSL3_RECORD_get_length ( rr ) == 0 || ( peek && n == SSL3_RECORD_get_length ( rr ) ) ) {\n<108> read_bytes += n ;\n<110> while ( type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs && read_bytes < ( unsigned int ) len ) ;
<1> int archive_mstring_copy_utf8 ( struct archive_mstring * aes , const char * utf8 ) {\n<2> if ( utf8 == NULL ) {\n<8> archive_strncpy ( & ( aes -> aes_utf8 ) , utf8 , strlen ( utf8 ) ) ;\n<9> return ( int ) strlen ( utf8 ) ;
<1> static int rfc2047_encode ( const char * d , size_t dlen , int col , const char * fromcode , const char * charsets , char * * e , size_t * elen , const char * specials ) {\n<13> if ( mutt_ch_convert_string ( & u , fromcode , icode , 0 ) != 0 ) {\n<20> t < ( u + ulen ) ;\n<21> t ++ ) {\n<22> if ( ( * t & 0x80 ) || ( ( * t == '=' ) && ( t [ 1 ] == '?' ) && ( ( t == u ) || HSPACE ( * ( t - 1 ) ) ) ) ) {\n<26> else if ( specials && * t && strchr ( specials , * t ) ) {\n<27> if ( ! s0 ) s0 = t ;\n<28> s1 = t ;\n<33> if ( ! t0 ) {\n<49> if ( t < u ) t = u ;\n<50> if ( t < t0 ) t0 = t ;\n<56> if ( icode ) while ( ( t < ( u + ulen ) ) && CONTINUATION_BYTE ( * t ) ) t ++ ;\n<57> if ( ( try_block ( t0 , t - t0 , icode , tocode , & encoder , & wlen ) == 0 ) && ( ( col + ( t0 - u ) + wlen ) <= ( ENCWORD_LEN_MAX + 1 ) ) ) {\n<64> if ( ! HSPACE ( * t1 ) ) continue ;\n<66> if ( icode ) while ( CONTINUATION_BYTE ( * t ) ) t -- ;\n<67> if ( ( try_block ( t , t1 - t , icode , tocode , & encoder , & wlen ) == 0 ) && ( ( 1 + wlen + ( u + ulen - t1 ) ) <= ( ENCWORD_LEN_MAX + 1 ) ) ) {\n<72> buf = mutt_mem_malloc ( buflen ) ;\n<74> memcpy ( buf , u , t0 - u ) ;\n<75> col += t0 - u ;\n<78> size_t n = choose_block ( t , t1 - t , col , icode , tocode , & encoder , & wlen ) ;\n<79> if ( n == ( t1 - t ) ) {\n<81> n = t1 - t - 1 ;\n<83> if ( ! n ) {\n<86> ( t1 < ( u + ulen ) ) && ! HSPACE ( * t1 ) ;\n<90> n = choose_block ( t , n , col , icode , tocode , & encoder , & wlen ) ;\n<92> const char * line_break = "\n\t" ;\n<93> const int lb_len = 2 ;\n<96> mutt_mem_realloc ( & buf , buflen ) ;\n<98> r = encode_block ( buf + bufpos , t , n , icode , tocode , encoder ) ;\n<100> bufpos += wlen ;\n<101> memcpy ( buf + bufpos , line_break , lb_len ) ;\n<102> bufpos += lb_len ;\n<104> t += n ;\n<107> mutt_mem_realloc ( & buf , buflen + 1 ) ;\n<108> r = encode_block ( buf + bufpos , t , t1 - t , icode , tocode , encoder ) ;\n<110> bufpos += wlen ;\n<111> memcpy ( buf + bufpos , t1 , u + ulen - t1 ) ;\n<115> * e = buf ;
<1> static void dumpspace ( SplineChar * sc , struct glyphinfo * gi ) {\n<5> memset ( & b , 0 , sizeof ( b ) ) ;\n<6> ttfdumpmetrics ( sc , gi , & b ) ;
<1> static void qpeg_decode_inter ( QpegContext * qctx , uint8_t * dst , int stride , int width , int height , int delta , const uint8_t * ctable , uint8_t * refdata ) {\n<7> i < height ;\n<8> i ++ ) memcpy ( refdata + ( i * width ) , dst + ( i * stride ) , width ) ;\n<31> if ( ( me_x + filled < 0 ) || ( me_x + me_w + filled > width ) || ( height - me_y - me_h < 0 ) || ( height - me_y > orig_height ) || ( filled + me_w > width ) || ( height - me_h < 0 ) ) av_log ( NULL , AV_LOG_ERROR , "Bogus motion vector (%i,%i), block size %ix%i at %i,%i\n" , me_x , me_y , me_w , me_h , filled , height ) ;\n<33> me_plane = refdata + ( filled + me_x ) + ( height - me_y ) * width ;\n<55> if ( filled >= width ) {\n<68> if ( filled >= width ) {\n<82> while ( filled >= width ) {\n<94> if ( filled >= width ) {
<1> void hb_font_funcs_destroy ( hb_font_funcs_t * ffuncs ) {\n<2> if ( ! hb_object_destroy ( ffuncs ) ) return ;\n<4> HB_FONT_FUNCS_IMPLEMENT_CALLBACKS # undef HB_FONT_FUNC_IMPLEMENT free ( ffuncs ) ;
<1> static int64_t alloc_refcount_block(BlockDriverState *bs, int64_t cluster_index)\n<5> BDRVQcowState *s = bs->opaque;\n<101> if (cache_refcount_updates) {\n<105> if (ret < 0) {\n<117> uint64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n<119> memset(s->refcount_block_cache, 0, s->cluster_size);\n<137> if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n<153> ret = update_refcount(bs, new_block, s->cluster_size, 1);\n<169> ret = bdrv_pwrite(bs->file, new_block, s->refcount_block_cache,\n<183> if (refcount_table_index < s->refcount_table_size) {\n<303> uint64_t *new_table = qemu_mallocz(table_size * sizeof(uint64_t));\n<315> s->refcount_table_size * sizeof(uint64_t));\n<333> uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n<367> cpu_to_be64s(&new_table[i]);\n<389> cpu_to_be64s(&new_table[i]);\n<425> qemu_free(s->refcount_table);\n<427> s->refcount_table = new_table;\n<461> qemu_free(new_table);
<1> static void z2_init(MachineState *machine)\n<57> if (!dinfo && !qtest_enabled()) {\n<59> fprintf(stderr, "Flash image must be given with the "\n<79> fprintf(stderr, "qemu: Error registering flash memory.\n");
<1> int dtls1_buffer_message ( SSL * s , int is_ccs ) {\n<6> frag = dtls1_hm_fragment_new ( s -> init_num , 0 ) ;\n<7> if ( frag == NULL ) return 0 ;\n<8> memcpy ( frag -> fragment , s -> init_buf -> data , s -> init_num ) ;\n<10> OPENSSL_assert ( s -> d1 -> w_msg_hdr . msg_len + ( ( s -> version == DTLS1_BAD_VER ) ? 3 : DTLS1_CCS_HEADER_LENGTH ) == ( unsigned int ) s -> init_num ) ;\n<13> OPENSSL_assert ( s -> d1 -> w_msg_hdr . msg_len + DTLS1_HM_HEADER_LENGTH == ( unsigned int ) s -> init_num ) ;\n<26> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<29> item = pitem_new ( seq64be , frag ) ;\n<31> dtls1_hm_fragment_free ( frag ) ;
<1> vorbis_comment(AVFormatContext * as, uint8_t *buf, int size)\n<49> if (end - p < s)\n<55> t = p;\n<63> v = memchr(t, '=', s);\n<65> if (!v)\n<71> tl = v - t;\n<73> vl = s - tl - 1;\n<75> v++;\n<79> if (tl && vl) {\n<87> ct = av_malloc(vl + 1);\n<89> if (!tt || !ct) {\n<93> av_freep(&ct);\n<105> tt[j] = toupper(t[j]);\n<111> memcpy(ct, v, vl);\n<113> ct[vl] = 0;\n<117> av_metadata_set(&as->metadata, tt, ct);\n<123> av_freep(&ct);
<1> static gint btatt_dissect_attribute_handle ( guint16 handle , tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , btatt_data_t * att_data ) {\n<9> if ( attribute_handler == NULL ) return 0 ;\n<12> attribute_name = dissector_handle_get_short_name ( attribute_handler ) ;\n<13> if ( strlen ( attribute_name ) > 7 ) {\n<14> uuid . size = 2 ;\n<15> uuid . bt_uuid = ( guint16 ) g_ascii_strtoull ( attribute_name + strlen ( attribute_name ) - 7 , NULL , 16 ) ;\n<16> uuid . data [ 1 ] = uuid . bt_uuid & 0xFF ;\n<17> uuid . data [ 0 ] = ( uuid . bt_uuid >> 8 ) & 0xFF ;\n<20> uuid . size = 2 ;\n<21> uuid . bt_uuid = 0 ;
<1> static vpx_codec_err_t encoder_destroy ( vpx_codec_alg_priv_t * ctx ) {\n<2> free ( ctx -> cx_data ) ;\n<4> vpx_free ( ctx ) ;
<1> static int decode_frame_ilbm(AVCodecContext *avctx,\n<9> IffContext *s = avctx->priv_data;\n<29> if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n<37> } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n<45> if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n<57> if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n<59> memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n<65> uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n<75> } else if (s->ham) { // HAM to PIX_FMT_BGR32\n<77> memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n<79> for(y = 0; y < avctx->height; y++) {\n<81> uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n<83> memset(s->ham_buf, 0, s->planesize * 8);\n<93> decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);\n<97> decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n<109> for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n<111> uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n<113> memcpy(row, buf, FFMIN(raw_width, buf_end - buf));\n<115> buf += raw_width;\n<121> row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);\n<131> for(y = 0; y < avctx->height; y++ ) {\n<133> uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n<135> memset(row, 0, avctx->width);\n<139> decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n<149> for (y = 0; y < avctx->height; y++) {\n<153> memset(s->ham_buf, 0, s->planesize * 8);\n<157> decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);\n<163> decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n<169> for(y = 0; y < avctx->height; y++ ) {\n<171> uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n<173> memset(row, 0, avctx->width << 2);\n<177> decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n<191> for(y = 0; y < avctx->height; y++ ) {\n<193> uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n<195> memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n<197> buf += avctx->width + (avctx->width % 2); // padding if odd\n<203> for (y = 0; y < avctx->height; y++) {\n<207> memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n<209> buf += avctx->width + (avctx->width & 1); // padding if odd\n<211> decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);
<1> err_status_t srtp_unprotect_rtcp ( srtp_t ctx , void * srtcp_hdr , int * pkt_octet_len ) {\n<9> uint8_t tag_copy [ SRTP_MAX_TAG_LEN ] ;\n<55> auth_len = * pkt_octet_len - tag_len ;\n<57> if ( stream -> ekt ) {\n<58> auth_tag -= ekt_octets_after_base_tag ( stream -> ekt ) ;\n<59> memcpy ( tag_copy , auth_tag , tag_len ) ;\n<60> octet_string_set_to_zero ( auth_tag , tag_len ) ;\n<61> auth_tag = tag_copy ;
<1> static int img_map(int argc, char **argv)\n<27> output = NULL;\n<53> if (c == -1) {\n<77> output = optarg;\n<117> if (output && !strcmp(output, "json")) {\n<119> output_format = OFORMAT_JSON;\n<121> } else if (output && !strcmp(output, "human")) {\n<123> output_format = OFORMAT_HUMAN;\n<125> } else if (output) {\n<135> if (qemu_opts_foreach(&qemu_object_opts,\n<159> if (output_format == OFORMAT_HUMAN) {\n<161> printf("%-16s%-16s%-16s%s\n", "Offset", "Length", "Mapped to", "File");\n<193> if (ret < 0) {\n<195> error_report("Could not read file metadata: %s", strerror(-ret));
<1> gcry_error_t gcry_mpi_print ( enum gcry_mpi_format format , unsigned char * buffer , size_t buflen , size_t * nwritten , struct gcry_mpi * a ) {\n<17> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<18> if ( n && ( * tmp & 0x80 ) ) {\n<26> if ( buffer ) {\n<27> unsigned char * s = buffer ;\n<28> if ( extra ) * s ++ = 0 ;\n<29> memcpy ( s , tmp , n - extra ) ;\n<31> gcry_free ( tmp ) ;\n<36> unsigned int n = ( nbits + 7 ) / 8 ;\n<37> if ( buffer && n > len ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n<40> tmp = _gcry_mpi_get_buffer ( a , 0 , & n , NULL ) ;\n<41> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<42> memcpy ( buffer , tmp , n ) ;\n<43> gcry_free ( tmp ) ;\n<45> * nwritten = n ;\n<49> unsigned int n = ( nbits + 7 ) / 8 ;\n<54> unsigned char * s = buffer ;\n<55> s [ 0 ] = nbits >> 8 ;\n<56> s [ 1 ] = nbits ;\n<57> tmp = _gcry_mpi_get_buffer ( a , 0 , & n , NULL ) ;\n<58> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<59> memcpy ( s + 2 , tmp , n ) ;\n<60> gcry_free ( tmp ) ;\n<62> * nwritten = n + 2 ;\n<71> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<72> if ( n && ( * tmp & 0x80 ) ) {\n<80> if ( buffer ) {\n<85> * s ++ = n ;\n<86> if ( extra ) * s ++ = 0 ;\n<87> memcpy ( s , tmp , n - extra ) ;\n<89> gcry_free ( tmp ) ;
<1> static void usage ( int version ) {\n<8> printf ( "Usage: %s [OPTIONS] [database]\n" , my_progname ) ;
<1> static void test_bug12001 ( ) {\n<13> if ( ! ( mysql_local = mysql_client_init ( NULL ) ) ) {\n<14> fprintf ( stdout , "\n mysql_client_init() failed" ) ;\n<17> if ( ! mysql_real_connect ( mysql_local , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , CLIENT_MULTI_STATEMENTS ) ) {\n<18> fprintf ( stdout , "\n mysql_real_connect() failed" ) ;
<1> static void http_complete_write ( int fd , short what , void * arg ) {\n<2> struct bufferevent * bev = arg ;\n<3> const char * http_request = "host\r\n" "Connection: close\r\n" "\r\n" ;\n<4> bufferevent_write ( bev , http_request , strlen ( http_request ) ) ;
<1> void kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr)\n<21> if (mem == NULL) {\n<23> fprintf(stderr, "BUG: %s: invalid parameters\n", __func__);
<1> static struct cgroup_mount_point * lxc_cgroup_find_mount_point ( struct cgroup_hierarchy * hierarchy , const char * group , bool should_be_writable ) {\n<8> mps && * mps ;\n<10> struct cgroup_mount_point * mp = * mps ;\n<11> size_t prefix_len = mp -> mount_prefix ? strlen ( mp -> mount_prefix ) : 0 ;\n<12> if ( prefix_len == 1 && mp -> mount_prefix [ 0 ] == '/' ) prefix_len = 0 ;\n<14> if ( ! prefix_len || ( strncmp ( group , mp -> mount_prefix , prefix_len ) == 0 && ( group [ prefix_len ] == '\0' || group [ prefix_len ] == '/' ) ) ) {
<1> static int wv_get_value(WavpackFrameContext *ctx, GetBitContext *gb, int channel, int *last)\n<17> if((ctx->ch[0].median[0] < 2U) && (ctx->ch[1].median[0] < 2U) && !ctx->zero && !ctx->one){\n<39> if(ctx->zeroes){\n<41> memset(ctx->ch[0].median, 0, sizeof(ctx->ch[0].median));\n<43> memset(ctx->ch[1].median, 0, sizeof(ctx->ch[1].median));
<1> matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n<46> flags = *data++;\n<68> data += 1;\n<83> data += 1;\n<99> n = matroska_ebmlnum_uint(data, size, &num);\n<105> data += n;\n<111> r = matroska_ebmlnum_sint (data, size, &snum);\n<117> data += r;\n<137> MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n<147> for (x=0; x<h/2; x++)\n<148> memcpy(audiotrack->buf+x*2*w+y*cfs,\n<149> data+x*cfs, cfs);\n<151> for (x=0; x<w/sps; x++)\n<152> memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n<158> while (audiotrack->pkt_cnt) {\n<160> av_new_packet(pkt, a);\n<162> + a * (h*w / a - audiotrack->pkt_cnt--), a);\n<165> matroska_queue_packet(matroska, pkt);\n<168> int result, offset = 0, ilen, olen, pkt_size = lace_size[n];\n<169> uint8_t *pkt_data = data;\n<173> offset = matroska->tracks[track]->encoding_settings_len;\n<182> result = lzo1x_decode(pkt_data, &olen, data, &ilen);\n<187> pkt_size -= olen;\n<239> if (av_new_packet(pkt, pkt_size+offset) < 0) {\n<240> av_free(pkt);\n<245> if (offset)\n<246> memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);\n<247> memcpy (pkt->data+offset, pkt_data, pkt_size);\n<254> matroska_queue_packet(matroska, pkt);\n<258> data += lace_size[n];
<1> int register_savevm(const char *idstr,\n<21> if (!se)\n<25> pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n<45> while (*pse != NULL) {\n<47> if (instance_id == -1\n<49> && strcmp(se->idstr, (*pse)->idstr) == 0\n<59> *pse = se;
<1> static int do_execstack ( i_ctx_t * i_ctx_p , bool include_marks , bool include_oparrays , os_ptr op1 ) {\n<14> switch ( r_type ( rq ) ) {\n<21> const char * tname = rq -> value . pstruct ? gs_struct_type_name_string ( gs_object_type ( imemory , rq -> value . pstruct ) ) : "NULL" ;\n<22> make_const_string ( rq , a_readonly | avm_foreign , strlen ( tname ) , ( const byte * ) tname ) ;
<1> static int show_bisect_vars ( struct rev_list_info * info , int reaches , int all ) {\n<11> if ( flags & BISECT_SHOW_ALL ) {\n<13> printf ( "------\n" ) ;
<1> static int mm_start_timer(struct qemu_alarm_timer *t)\n<9> memset(&tc, 0, sizeof(tc));\n<11> timeGetDevCaps(&tc, sizeof(tc));\n<33> if (!mm_timer) {\n<35> fprintf(stderr, "Failed to initialize win32 alarm timer: %ld\n",
<1> DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n<87> if ((buf = qemu_opt_get(opts, "if")) != NULL) {\n<89> for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n<95> error_report("unsupported bus type '%s'", buf);\n<143> if ((buf = qemu_opt_get(opts, "trans")) != NULL) {\n<145> if (!cyls) {\n<155> if (!strcmp(buf, "none"))\n<157> translation = BIOS_ATA_TRANSLATION_NONE;\n<159> else if (!strcmp(buf, "lba"))\n<161> translation = BIOS_ATA_TRANSLATION_LBA;\n<163> else if (!strcmp(buf, "auto"))\n<165> translation = BIOS_ATA_TRANSLATION_AUTO;\n<169> error_report("'%s' invalid translation type", buf);\n<171> return NULL;\n<179> if ((buf = qemu_opt_get(opts, "media")) != NULL) {\n<181> if (!strcmp(buf, "disk")) {\n<183> media = MEDIA_DISK;\n<185> } else if (!strcmp(buf, "cdrom")) {\n<187> if (cyls || secs || heads) {\n<189> error_report("CHS can't be set with media=%s", buf);\n<199> error_report("'%s' invalid media", buf);\n<201> return NULL;\n<209> if ((buf = qemu_opt_get(opts, "discard")) != NULL) {\n<333> if (qemu_opt_get(opts, "boot") != NULL) {\n<335> fprintf(stderr, "qemu-kvm: boot=on|off is deprecated and will be "\n<701> if (ret == -EMEDIUMTYPE) {\n<709> error_report("could not open disk image %s: %s",\n<711> file, strerror(-ret));
<1> static int usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n<45> if (sz > ret)\n<47> sz = ret;\n<49> memcpy(&s->out_buf[s->out_ptr], p->data, sz);\n<51> s->out_ptr += sz;\n<55> if (!is_rndis(s)) {\n<71> if (s->out_ptr < 8 || s->out_ptr < len)\n<87> s->out_ptr -= len;\n<89> memmove(s->out_buf, &s->out_buf[len], s->out_ptr);
<1> static int user_cert_trusted_ca ( struct ssh * ssh , struct passwd * pw , struct sshkey * key , struct sshauthopt * * authoptsp ) {\n<2> char * ca_fp , * principals_file = NULL ;\n<9> if ( ( ca_fp = sshkey_fingerprint ( key -> cert -> signature_key , options . fingerprint_hash , SSH_FP_DEFAULT ) ) == NULL ) return 0 ;\n<11> debug2 ( "%s: CA %s %s is not listed in %s: %s" , __func__ , sshkey_type ( key -> cert -> signature_key ) , ca_fp , options . trusted_user_ca_keys , ssh_err ( r ) ) ;\n<18> use_authorized_principals = principals_file != NULL || options . authorized_principals_command != NULL ;\n<48> verbose ( "Accepted certificate ID \"%s\" (serial %llu) signed by " "%s CA %s via %s" , key -> cert -> key_id , ( unsigned long long ) key -> cert -> serial , sshkey_type ( key -> cert -> signature_key ) , ca_fp , options . trusted_user_ca_keys ) ;\n<57> free ( principals_file ) ;\n<58> free ( ca_fp ) ;
<1> static size_t kex_method_list ( unsigned char * buf , size_t list_strlen , LIBSSH2_COMMON_METHOD * * method ) {\n<3> buf += 4 ;\n<7> while ( * method && ( * method ) -> name ) {\n<8> int mlen = strlen ( ( * method ) -> name ) ;\n<9> memcpy ( buf , ( * method ) -> name , mlen ) ;\n<10> buf += mlen ;\n<11> * ( buf ++ ) = ',' ;
<1> void InitDumpOptions ( DumpOptions * opts ) {\n<2> memset ( opts , 0 , sizeof ( DumpOptions ) ) ;
<1> static void fill_picture_parameters(const AVCodecContext *avctx, AVDXVAContext *ctx, const HEVCContext *h,\n<3> DXVA_PicParams_HEVC *pp)\n<13> memset(pp, 0, sizeof(*pp));\n<41> fill_picture_entry(&pp->CurrPic, ff_dxva2_get_surface_index(avctx, ctx, current_picture->frame), 0);\n<207> memset(&pp->RefPicList, 0xff, sizeof(pp->RefPicList));\n<209> memset(&pp->RefPicSetStCurrBefore, 0xff, sizeof(pp->RefPicSetStCurrBefore));\n<211> memset(&pp->RefPicSetStCurrAfter, 0xff, sizeof(pp->RefPicSetStCurrAfter));\n<213> memset(&pp->RefPicSetLtCurr, 0xff, sizeof(pp->RefPicSetLtCurr));\n<225> fill_picture_entry(&pp->RefPicList[j], ff_dxva2_get_surface_index(avctx, ctx, frame->frame), !!(frame->flags & HEVC_FRAME_FLAG_LONG_REF));\n<241> av_assert0(rpl->nb_refs <= FF_ARRAY_ELEMS(pp->ref_list)); \\n<247> pp->ref_list[k] = get_refpic_index(pp, ff_dxva2_get_surface_index(avctx, ctx, rpl->ref[j]->frame)); \
<1> static int webvtt_read_header(AVFormatContext *s)\n<5> WebVTTContext *webvtt = s->priv_data;\n<81> for (i = 0; p[i] && p[i] != '\n' && p[i] != '\r'; i++) {\n<107> if (*p == '\n')\n<117> if ((ts_start = read_ts(p)) == AV_NOPTS_VALUE)\n<121> if (!(p = strstr(p, "-->")))\n<125> p += 3;\n<127> do p++; while (*p == ' ' || *p == '\t');\n<129> if ((ts_end = read_ts(p)) == AV_NOPTS_VALUE)\n<147> p += settings_len;\n<151> p++;\n<153> if (*p == '\n')\n<155> p++;\n<161> sub = ff_subtitles_queue_insert(&webvtt->q, p, strlen(p), 0);
<1> int EVP_EncryptUpdate ( EVP_CIPHER_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n<27> if ( bl - i > inl ) {\n<28> memcpy ( & ( ctx -> buf [ i ] ) , in , inl ) ;\n<29> ctx -> buf_len += inl ;\n<34> j = bl - i ;\n<35> memcpy ( & ( ctx -> buf [ i ] ) , in , j ) ;\n<36> if ( ! ctx -> cipher -> do_cipher ( ctx , out , ctx -> buf , bl ) ) return 0 ;\n<37> inl -= j ;\n<38> in += j ;\n<47> if ( ! ctx -> cipher -> do_cipher ( ctx , out , in , inl ) ) return 0 ;\n<50> if ( i != 0 ) memcpy ( ctx -> buf , & ( in [ inl ] ) , i ) ;\n<51> ctx -> buf_len = i ;
<1> static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n<3> const uint8_t *key, size_t nkey,\n<13> if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n<27> ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n<29> memcpy(ctxt->state.desrfb.key, key, nkey);\n<31> ctxt->state.desrfb.nkey = nkey;
<1> void archive_string_conversion_free ( struct archive * a ) {\n<11> free ( a -> current_code ) ;
<1> static void add_objects_in_unpacked_packs ( struct rev_info * revs ) {\n<5> memset ( & in_pack , 0 , sizeof ( in_pack ) ) ;\n<13> ALLOC_GROW ( in_pack . array , in_pack . nr + p -> num_objects , in_pack . alloc ) ;\n<19> if ( ! ( o -> flags & OBJECT_ADDED ) ) mark_in_pack_object ( o , p , & in_pack ) ;\n<24> qsort ( in_pack . array , in_pack . nr , sizeof ( in_pack . array [ 0 ] ) , ofscmp ) ;\n<26> i < in_pack . nr ;\n<32> free ( in_pack . array ) ;
<1> static int create_or_remove_cgroup ( bool do_remove , struct cgroup_mount_point * mp , const char * path , int recurse ) {\n<4> if ( ! buf ) return - 1 ;\n<6> if ( recurse ) r = cgroup_rmdir ( buf ) ;\n<7> else r = rmdir ( buf ) ;\n<9> else r = mkdir ( buf , 0777 ) ;\n<11> free ( buf ) ;
<1> static void ff_amf_tag_contents(void *ctx, const uint8_t *data, const uint8_t *data_end)\n<7> char buf[1024];\n<15> switch (*data++) {\n<33> if (data[-1] == AMF_DATA_TYPE_STRING) {\n<35> size = bytestream_get_be16(&data);\n<39> size = bytestream_get_be32(&data);\n<43> size = FFMIN(size, 1023);\n<45> memcpy(buf, data, size);\n<49> av_log(ctx, AV_LOG_DEBUG, " string '%s'\n", buf);\n<61> data += 4;\n<69> int size = bytestream_get_be16(&data);\n<73> memcpy(buf, data, size);\n<75> buf[size] = 0;\n<77> if (!size) {\n<81> data++;\n<87> if (size < 0 || size >= data_end - data)\n<91> data += size;\n<93> av_log(ctx, AV_LOG_DEBUG, "  %s: ", buf);\n<99> if (t < 0 || t >= data_end - data)\n<103> data += t;
<1> static int decode_slice_header(H264Context *h, H264Context *h0){\n<213> for(i = 1; i < s->avctx->thread_count; i++) {\n<217> c = h->thread_context[i] = av_malloc(sizeof(H264Context));\n<219> memcpy(c, h->s.thread_context[i], sizeof(MpegEncContext));\n<221> memset(&c->s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext));\n<223> c->sps = h->sps;\n<225> c->pps = h->pps;\n<227> init_scan_tables(c);\n<229> clone_tables(c, h);
<1> unsigned int srtp_get_version ( ) {\n<2> unsigned int major = 0 , minor = 0 , micro = 0 ;\n<5> parse_rv = sscanf ( SRTP_VERSION , "%u.%u.%u" , & major , & minor , & micro ) ;\n<6> if ( parse_rv != 3 ) {\n<9> rv |= ( major & 0xFF ) << 24 ;\n<10> rv |= ( minor & 0xFF ) << 16 ;\n<11> rv |= micro & 0xFF ;
<1> static void sun4uv_init(MemoryRegion *address_space_mem,\n<3> MachineState *machine,\n<141> sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", machine->ram_size,\n<175> if (machine->kernel_cmdline) {\n<179> strlen(machine->kernel_cmdline) + 1);\n<181> fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);
<1> char * Curl_copy_header_value ( const char * header ) {\n<9> start = header ;\n<10> while ( * start && ISSPACE ( * start ) ) start ++ ;\n<11> end = strchr ( start , '\r' ) ;\n<12> if ( ! end ) end = strchr ( start , '\n' ) ;\n<13> if ( ! end ) end = strchr ( start , '\0' ) ;\n<14> if ( ! end ) return NULL ;\n<15> while ( ( end > start ) && ISSPACE ( * end ) ) end -- ;\n<16> len = end - start + 1 ;\n<17> value = malloc ( len + 1 ) ;\n<18> if ( ! value ) return NULL ;\n<19> memcpy ( value , start , len ) ;\n<21> return value ;
<1> static void tpm_passthrough_cancel_cmd(TPMBackend *tb)\n<29> if (n != 1) {\n<31> error_report("Canceling TPM command failed: %s",\n<33> strerror(errno));
<1> static int CheckCodePointsComment ( IO * wrapper ) {\n<2> char commentbuffer [ 128 ] , * pt ;\n<5> if ( ch != '%' ) {\n<14> if ( strcmp ( commentbuffer , " Use codepoints." ) == 0 ) return ( true ) ;\n<15> return ( false ) ;
<1> static gint detect_version ( wtap * wth , int * err , gchar * * err_info ) {\n<38> msg_payload = log_entry -> msg ;\n<42> msg_payload = log_entry_v2 -> msg ;\n<54> if ( get_priority ( msg_payload [ 0 ] ) == '?' ) continue ;\n<55> msg_part = ( guint8 * ) memchr ( msg_payload , '\0' , payload_length - 1 ) ;\n<56> if ( msg_part == NULL ) continue ;\n<58> msg_len = payload_length - ( msg_part - msg_payload ) ;\n<59> msg_end = ( guint8 * ) memchr ( msg_part , '\0' , msg_len ) ;\n<60> if ( msg_end && ( msg_payload + payload_length - 1 != msg_end ) ) continue ;
<19> switch ( * buf ) {\n<35> case DUL_TYPESCUSCPROLE : role = ( PRV_SCUSCPROLE * ) malloc ( sizeof ( PRV_SCUSCPROLE ) ) ;\n<36> if ( role == NULL ) return EC_MemoryExhausted ;
<1> static int raw_create(const char *filename, QEMUOptionParameter *options)\n<13> while (options && options->name) {\n<15> if (!strcmp(options->name, BLOCK_OPT_SIZE)) {\n<17> total_size = options->value.n / 512;\n<21> options++;
<1> static void cgfs_destroy ( void * hdata ) {\n<3> if ( ! d ) return ;\n<4> free ( d -> name ) ;\n<5> lxc_cgroup_process_info_free_and_remove ( d -> info ) ;\n<6> lxc_cgroup_put_meta ( d -> meta ) ;\n<7> free ( d ) ;
<1> static int h264_decode_frame(AVCodecContext *avctx, void *data,\n<139> if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n<149> buf_index = decode_nal_units(h, buf, buf_size, 0);\n<169> if (avctx->skip_frame >= AVDISCARD_NONREF ||\n<171> buf_size >= 4 && !memcmp("Q264", buf, 4))
<1> static int read_dns ( int fd , int tun_fd , struct query * q ) {\n<10> addrlen = sizeof ( struct sockaddr ) ;\n<13> msg . msg_name = ( caddr_t ) & from ;\n<24> memcpy ( ( struct sockaddr * ) & q -> from , ( struct sockaddr * ) & from , addrlen ) ;\n<25> q -> fromlen = addrlen ;
<1> static void png_filter_row(DSPContext *dsp, uint8_t *dst, int filter_type,\n<3> uint8_t *src, uint8_t *top, int size, int bpp)\n<11> switch(filter_type) {\n<15> memcpy(dst, src, size);\n<21> dsp->diff_bytes(dst, src, src-bpp, size);\n<23> memcpy(dst, src, bpp);
<1> GList * completion_get_targets ( const char * word ) {\n<6> g_return_val_if_fail ( word != NULL , NULL ) ;\n<7> len = strlen ( word ) ;\n<16> if ( len != 0 && g_ascii_strncasecmp ( node -> key , word , len ) != 0 ) continue ;
<1> struct vhost_net *vhost_net_init(VhostNetOptions *options)\n<13> if (!options->net_backend) {\n<15> fprintf(stderr, "vhost-net requires net backend to be setup\n");
<1> REGRESSION_TEST ( SDK_API_TSMimeHdrParse ) ( RegressionTest * test , int , int * pstatus ) {\n<2> const char * parse_string = "field1:field1Value1,field1Value2\r\nfield2:10,-34,45\r\nfield3:field3Value1,23\r\nfield2: 2345, field2Value2\r\n\r\n" ;\n<38> if ( TSMimeHdrCreate ( bufp1 , & mime_hdr_loc1 ) != TS_SUCCESS ) {\n<48> end = parse_string + strlen ( parse_string ) + 1 ;\n<49> if ( ( retval = TSMimeHdrParse ( parser , bufp1 , mime_hdr_loc1 , & start , end ) ) == TS_PARSE_ERROR ) {\n<55> if ( retval == TS_PARSE_DONE ) {\n<56> temp = convert_mime_hdr_to_string ( bufp1 , mime_hdr_loc1 ) ;\n<57> if ( strcmp ( parse_string , temp ) == 0 ) {\n<58> SDK_RPRINT ( test , "TSMimeHdrParse" , "TestCase1" , TC_PASS , "ok" ) ;\n<59> SDK_RPRINT ( test , "TSMimeHdrPrint" , "TestCase1" , TC_PASS , "ok" ) ;\n<60> hdrLength = TSMimeHdrLengthGet ( bufp1 , mime_hdr_loc1 ) ;\n<61> if ( hdrLength == ( int ) strlen ( temp ) ) {\n<62> SDK_RPRINT ( test , "TSMimeHdrLengthGet" , "TestCase1" , TC_PASS , "ok" ) ;\n<63> test_passed_mime_hdr_length_get = true ;\n<66> SDK_RPRINT ( test , "TSMimeHdrLengthGet" , "TestCase1" , TC_FAIL , "Value's Mismatch" ) ;\n<68> test_passed_parse = true ;\n<69> test_passed_mime_hdr_print = true ;\n<72> SDK_RPRINT ( test , "TSMimeHdrParse|TSMimeHdrPrint" , "TestCase1" , TC_FAIL , "Incorrect parsing or incorrect Printing" ) ;\n<73> SDK_RPRINT ( test , "TSMimeHdrLengthGet" , "TestCase1" , TC_FAIL , "Cannot run test as TSMimeHdrParse|TSMimeHdrPrint failed." ) ;\n<75> TSfree ( temp ) ;\n<160> if ( TSMimeHdrCopy ( bufp2 , mime_hdr_loc2 , bufp1 , mime_hdr_loc1 ) == TS_ERROR ) {\n<164> temp = convert_mime_hdr_to_string ( bufp2 , mime_hdr_loc2 ) ;\n<165> if ( strcmp ( parse_string , temp ) == 0 ) {\n<166> SDK_RPRINT ( test , "TSMimeHdrCopy" , "TestCase1" , TC_PASS , "ok" ) ;\n<167> test_passed_mime_hdr_copy = true ;\n<170> SDK_RPRINT ( test , "TSMimeHdrCopy" , "TestCase1" , TC_FAIL , "Value's Mismatch" ) ;\n<172> TSfree ( temp ) ;
<1> static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n<15> char buf[256];\n<25> if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<31> if (!strcmp(buf, "tcp") || buf[0] == '\0') {\n<33> is_udp = 0;\n<35> } else if (!strcmp(buf, "udp")) {\n<37> is_udp = 1;\n<47> if (!legacy_format) {\n<123> error_report("invalid host forwarding rule '%s'", redir_str);\n<125> return -1;
<1> static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)\n<15> if(t == 127){\n<17> memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));
<1> static void network_init(void)\n<9> for(i = 0; i < nb_nics; i++) {\n<11> NICInfo *nd = &nd_table[i];\n<17> if (i == 0 && (!nd->model || strcmp(nd->model, "pcnet") == 0))\n<21> default_devaddr = "0b";\n<25> pci_nic_init(nd, "pcnet", default_devaddr);
<1> static size_t get_internal_buffer ( const gcry_sexp_t list , size_t * r_off ) {\n<10> p ++ ;\n<11> if ( type == ST_DATA ) {\n<12> memcpy ( & n , p , sizeof n ) ;\n<13> p += sizeof n + n ;
<1> BlockDriverAIOCB *win32_aio_submit(BlockDriverState *bs,\n<19> waiocb = qemu_aio_get(&win32_aiocb_info, bs, cb, opaque);\n<51> memset(&waiocb->ov, 0, sizeof(waiocb->ov));\n<67> rc = ReadFile(hfile, waiocb->buf, waiocb->nbytes, NULL, &waiocb->ov);\n<71> rc = WriteFile(hfile, waiocb->buf, waiocb->nbytes, NULL, &waiocb->ov);\n<89> qemu_aio_release(waiocb);
<1> int qemu_v9fs_synth_add_file(V9fsSynthNode *parent, int mode,\n<15> if (!v9fs_synth_fs) {\n<21> if (!name || (strlen(name) >= NAME_MAX)) {\n<23> return EINVAL;\n<27> if (!parent) {\n<35> qemu_mutex_lock(&v9fs_synth_mutex);\n<37> QLIST_FOREACH(tmp, &parent->child, sibling) {\n<39> if (!strcmp(tmp->name, name)) {\n<41> ret = EEXIST;\n<51> mode = ((mode & 0777) | S_IFREG);\n<53> node = g_malloc0(sizeof(V9fsSynthNode));\n<55> node->attr         = &node->actual_attr;\n<57> node->attr->inode  = v9fs_synth_node_count++;\n<59> node->attr->nlink  = 1;\n<61> node->attr->read   = read;\n<63> node->attr->write  = write;\n<65> node->attr->mode   = mode;\n<67> node->private      = arg;\n<69> strncpy(node->name, name, sizeof(node->name));\n<71> QLIST_INSERT_HEAD_RCU(&parent->child, node, sibling);\n<73> ret = 0;\n<77> qemu_mutex_unlock(&v9fs_synth_mutex);\n<79> return ret;
<1> int HandleIoctl ( struct vcache * avc , afs_int32 acom , struct afs_ioctl * adata ) {\n<12> tcell = afs_GetCell ( avc -> f . fid . Cell , READ_LOCK ) ;\n<13> if ( tcell ) {\n<14> i = strlen ( tcell -> cellName ) + 1 ;\n<15> if ( i > adata -> out_size ) {\n<19> AFS_COPYOUT ( tcell -> cellName , adata -> out , i , code ) ;\n<21> afs_PutCell ( tcell , READ_LOCK ) ;
<1> static int match_principals_option ( const char * principal_list , struct sshkey_cert * cert ) {\n<7> if ( ( result = match_list ( cert -> principals [ i ] , principal_list , NULL ) ) != NULL ) {\n<8> debug3 ( "matched principal from key options \"%.100s\"" , result ) ;\n<9> free ( result ) ;
<1> static int qcrypto_ivgen_essiv_calculate(QCryptoIVGen *ivgen,\n<5> uint8_t *iv, size_t niv,\n<15> uint8_t *data = g_new(uint8_t, ndata);\n<19> sector = cpu_to_le64(sector);\n<21> memcpy(data, (uint8_t *)&sector, ndata);\n<23> if (sizeof(sector) < ndata) {\n<25> memset(data + sizeof(sector), 0, ndata - sizeof(sector));\n<49> if (ndata > niv) {\n<51> ndata = niv;\n<55> memcpy(iv, data, ndata);\n<57> if (ndata < niv) {\n<59> memset(iv + ndata, 0, niv - ndata);\n<63> g_free(data);
<1> static char * format_key ( const struct sshkey * key ) {\n<3> xasprintf ( & ret , "%s %s" , sshkey_type ( key ) , fp ) ;\n<4> free ( fp ) ;
<1> static void vacuum_one_database ( const char * dbname , vacuumingOptions * vacopts , int stage , SimpleStringList * tables , const char * host , const char * port , const char * username , enum trivalue prompt_password , int concurrentCons , const char * progname , bool echo , bool quiet ) {\n<24> conn = connectDatabase ( dbname , host , port , username , prompt_password , progname , false , true ) ;\n<26> if ( stage != ANALYZE_NO_STAGE ) printf ( _ ( "%s: processing database \"%s\": %s\n" ) , progname , PQdb ( conn ) , stage_messages [ stage ] ) ;\n<27> else printf ( _ ( "%s: vacuuming database \"%s\"\n" ) , progname , PQdb ( conn ) ) ;\n<54> init_slot ( slots , conn , progname ) ;
<1> static int get_htab_fd(sPAPRMachineState *spapr)\n<15> if (spapr->htab_fd < 0) {\n<17> error_report("Unable to open fd for reading hash table from KVM: %s",\n<19> strerror(errno));
<1> static int idr_ensure_poolsize ( struct archive_write * a , struct idr * idr , int cnt ) {\n<2> if ( idr -> pool_size < cnt ) {\n<7> p = realloc ( idr -> idrent_pool , sizeof ( struct idrent ) * psize ) ;\n<8> if ( p == NULL ) {
<1> static int wma_decode_block(WMADecodeContext *s)\n<313> if (s->channel_coded[ch]) {\n<339> ptr = &s->coefs1[ch][0];\n<343> memset(ptr, 0, s->block_len * sizeof(int16_t));\n<387> ptr += run;\n<667> if (!s->channel_coded[0]) {\n<671> memset(s->coefs[0], 0, sizeof(float) * s->block_len);
<1> static int print_device_sources(AVInputFormat *fmt, AVDictionary *opts)\n<15> if (!fmt || !fmt->priv_class  || !AV_IS_INPUT_DEVICE(fmt->priv_class->category))\n<21> printf("Audo-detected sources for %s:\n", fmt->name);\n<23> if (!fmt->get_device_list) {\n<27> printf("Cannot list sources. Not implemented.\n");\n<41> if ((ret = avformat_open_input(&dev, NULL, fmt, &tmp_opts)) < 0) {\n<43> printf("Cannot open device: %s.\n", fmt->name);\n<51> if ((ret = avdevice_list_devices(dev, &device_list)) < 0) {\n<53> printf("Cannot list sources.\n");\n<61> for (i = 0; i < device_list->nb_devices; i++) {\n<63> printf("%s %s [%s]\n", device_list->default_device == i ? "*" : " ",
<1> static void do_change_vnc(const char *target)\n<5> if (strcmp(target, "passwd") == 0 ||\n<7> strcmp(target, "password") == 0) {\n<9> char password[9];\n<11> monitor_readline("Password: ", 1, password, sizeof(password)-1);\n<13> password[sizeof(password)-1] = '\0';\n<15> if (vnc_display_password(NULL, password) < 0)\n<21> if (vnc_display_open(NULL, target) < 0)
<1> static int swf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n<37> if (tag < 0) {\n<39> fprintf(stderr, "No streaming found in SWF\n");
<1> int av_dict_set(AVDictionary **pm, const char *key, const char *value,\n<69> } else if (oldval && flags & AV_DICT_APPEND) {\n<71> int len = strlen(oldval) + strlen(value) + 1;\n<73> if (!(oldval = av_realloc(oldval, len)))\n<77> av_strlcat(oldval, value, len);
<1> static int vc1_decode_sprites(VC1Context *v, GetBitContext* gb)\n<15> memset(&sd, 0, sizeof(sd));\n<19> ret = vc1_parse_sprites(v, gb, &sd);\n<55> vc1_draw_sprites(v, &sd);
<1> static int analyze(const uint8_t *buf, int size, int packet_size, int *index)\n<5> int stat[TS_MAX_PACKET_SIZE];\n<15> memset(stat, 0, packet_size * sizeof(int));\n<23> stat[x]++;\n<25> if (stat[x] > best_score) {\n<27> best_score = stat[x];
<1> bool DropReplicationSlot ( PGconn * conn , const char * slot_name ) {\n<6> appendPQExpBuffer ( query , "DROP_REPLICATION_SLOT \"%s\"" , slot_name ) ;\n<7> res = PQexec ( conn , query -> data ) ;\n<8> if ( PQresultStatus ( res ) != PGRES_COMMAND_OK ) {\n<9> fprintf ( stderr , _ ( "%s: could not send replication command \"%s\": %s" ) , progname , query -> data , PQerrorMessage ( conn ) ) ;\n<10> destroyPQExpBuffer ( query ) ;\n<14> if ( PQntuples ( res ) != 0 || PQnfields ( res ) != 0 ) {\n<15> fprintf ( stderr , _ ( "%s: could not drop replication slot \"%s\": got %d rows and %d fields, expected %d rows and %d fields\n" ) , progname , slot_name , PQntuples ( res ) , PQnfields ( res ) , 0 , 0 ) ;
<1> static void get_sdr(IPMIBmcSim *ibs,\n<3> uint8_t *cmd, unsigned int cmd_len,\n<5> uint8_t *rsp, unsigned int *rsp_len,\n<27> pos = 0;\n<29> if (sdr_find_entry(&ibs->sdr, cmd[4] | (cmd[5] << 8),\n<45> if (cmd[6] > ipmi_sdr_length(sdrh)) {\n<61> if (cmd[7] == 0xff) {\n<63> cmd[7] = ipmi_sdr_length(sdrh) - cmd[6];\n<69> if ((cmd[7] + *rsp_len) > max_rsp_len) {\n<77> memcpy(rsp + *rsp_len, ibs->sdr.sdr + pos + cmd[6], cmd[7]);\n<79> *rsp_len += cmd[7];
<1> static gpointer writeout_thread(gpointer opaque)\n<61> while (get_trace_record(idx, &recordptr)) {\n<63> unused = fwrite(recordptr, recordptr->length, 1, trace_fp);\n<65> writeout_idx += recordptr->length;\n<67> free(recordptr); /* dont use g_free, can deadlock when traced */
<1> static int test_compress_text ( xd3_stream * stream , uint8_t * encoded , usize_t * encoded_size ) {\n<19> xd3_set_appheader ( stream , test_apphead , ( usize_t ) strlen ( ( char * ) test_apphead ) ) ;
<1> void usb_claim_port(USBDevice *dev, Error **errp)\n<5> USBBus *bus = usb_bus_from_device(dev);\n<15> if (dev->port_path) {\n<17> QTAILQ_FOREACH(port, &bus->free, next) {\n<19> if (strcmp(port->path, dev->port_path) == 0) {\n<27> if (port == NULL) {\n<29> error_setg(errp, "usb port %s (bus %s) not found (in use?)",\n<39> if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), "usb-hub") != 0) {\n<43> usb_create_simple(bus, "usb-hub");\n<61> trace_usb_port_claim(bus->busnr, port->path);\n<73> port->dev = dev;
<1> static int bethsoftvid_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<20> dst = vid -> frame . data [ 0 ] ;\n<33> dst += vid -> frame . linesize [ 0 ] * yoffset ;\n<37> while ( length > remaining ) {\n<39> else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_peek_byte ( & vid -> g ) , remaining ) ;\n<40> length -= remaining ;\n<41> dst += remaining + wrap_to_next_line ;\n<43> if ( dst == frame_end ) goto end ;\n<46> else if ( block_type == VIDEO_I_FRAME ) memset ( dst , bytestream2_get_byte ( & vid -> g ) , length ) ;\n<47> remaining -= length ;\n<48> dst += length ;
<1> static int svq1_encode_plane ( SVQ1Context * s , int plane , unsigned char * src_plane , unsigned char * ref_plane , unsigned char * decoded_plane , int width , int height , int src_stride , int stride ) {\n<7> uint8_t * src = s -> scratchbuf + stride * 16 ;\n<53> s -> m . new_picture . f . data [ 0 ] = src - y * 16 * stride ;\n<56> i < 16 && i + 16 * y < height ;\n<58> memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n<59> for ( x = width ;\n<61> x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n<64> i < 16 && i + 16 * y < 16 * block_height ;\n<65> i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n<84> i < 16 && i + 16 * y < height ;\n<86> memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n<87> for ( x = width ;\n<89> x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n<92> i < 16 && i + 16 * y < 16 * block_height ;\n<93> i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n<123> score [ 0 ] += encode_block ( s , src + 16 * x , NULL , temp , stride , 5 , 64 , lambda , 1 ) ;\n<156> score [ 1 ] += encode_block ( s , src + 16 * x , temp + 16 , decoded , stride , 5 , 64 , lambda , 0 ) ;\n<159> score [ 2 ] = s -> dsp . sse [ 0 ] ( NULL , src + 16 * x , ref , stride , 16 ) ;
<1> static void add_pc_test_cases(void)\n<69> if (g_str_has_suffix(mname, "-1.4") ||\n<71> (strcmp(mname, "pc-1.3") == 0) ||\n<73> (strcmp(mname, "pc-1.2") == 0) ||\n<75> (strcmp(mname, "pc-1.1") == 0) ||\n<77> (strcmp(mname, "pc-1.0") == 0) ||\n<79> (strcmp(mname, "pc-0.15") == 0) ||\n<81> (strcmp(mname, "pc-0.14") == 0) ||\n<83> (strcmp(mname, "pc-0.13") == 0) ||\n<85> (strcmp(mname, "pc-0.12") == 0) ||\n<87> (strcmp(mname, "pc-0.11") == 0) ||\n<89> (strcmp(mname, "pc-0.10") == 0)) {\n<91> path = g_strdup_printf("cpu/%s/init/%ux%ux%u&maxcpus=%u",\n<101> path = g_strdup_printf("cpu/%s/add/%ux%ux%u&maxcpus=%u",
<1> int ff_update_duplicate_context ( MpegEncContext * dst , MpegEncContext * src ) {\n<4> backup_duplicate_context ( & bak , dst ) ;\n<5> memcpy ( dst , src , sizeof ( MpegEncContext ) ) ;\n<6> backup_duplicate_context ( dst , & bak ) ;
<1> int kvm_arch_init ( MachineState * ms , KVMState * s ) {\n<10> if ( ret < 0 ) {\n<14> lm_capable_kernel = strcmp ( utsname . machine , "x86_64" ) == 0 ;\n<27> if ( ret < 0 ) {\n<28> fprintf ( stderr , "e820_add_entry() table is full\n" ) ;
<1> void qemu_tcg_configure(QemuOpts *opts, Error **errp)\n<5> const char *t = qemu_opt_get(opts, "thread");\n<7> if (t) {\n<9> if (strcmp(t, "multi") == 0) {\n<11> if (TCG_OVERSIZED_GUEST) {\n<39> } else if (strcmp(t, "single") == 0) {\n<41> mttcg_enabled = false;\n<45> error_setg(errp, "Invalid 'thread' setting %s", t);
<1> static void dissect_cip_s_supervisor_data ( proto_tree * item_tree , tvbuff_t * tvb , int offset , int item_length , packet_info * pinfo ) {\n<16> if ( ( preq_info != NULL ) && ( preq_info -> ciaData != NULL ) ) {\n<17> memcpy ( & req_data , preq_info -> ciaData , sizeof ( cip_simple_request_info_t ) ) ;
<1> int qemuMonitorTextGetBlockStatsInfo ( qemuMonitorPtr mon , const char * dev_name , long long * rd_req , long long * rd_bytes , long long * rd_total_times , long long * wr_req , long long * wr_bytes , long long * wr_total_times , long long * flush_req , long long * flush_total_times , long long * errs ) {\n<2> char * info = NULL ;\n<6> int devnamelen = strlen ( dev_name ) ;\n<7> if ( qemuMonitorHMPCommand ( mon , "info blockstats" , & info ) < 0 ) {\n<11> if ( strstr ( info , "\ninfo " ) ) {\n<12> qemuReportError ( VIR_ERR_OPERATION_INVALID , "%s" , _ ( "'info blockstats' not supported by this qemu" ) ) ;\n<15> * rd_req = * rd_bytes = - 1 ;\n<16> * wr_req = * wr_bytes = * errs = - 1 ;\n<17> if ( rd_total_times ) * rd_total_times = - 1 ;\n<18> if ( wr_total_times ) * wr_total_times = - 1 ;\n<19> if ( flush_req ) * flush_req = - 1 ;\n<20> if ( flush_total_times ) * flush_total_times = - 1 ;\n<21> p = info ;\n<22> while ( * p ) {\n<23> if ( STRPREFIX ( p , QEMU_DRIVE_HOST_PREFIX ) ) p += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n<24> if ( STREQLEN ( p , dev_name , devnamelen ) && p [ devnamelen ] == ':' && p [ devnamelen + 1 ] == ' ' ) {\n<25> eol = strchr ( p , '\n' ) ;\n<26> if ( ! eol ) eol = p + strlen ( p ) ;\n<27> p += devnamelen + 2 ;\n<28> while ( * p ) {\n<29> if ( STRPREFIX ( p , "rd_bytes=" ) ) {\n<30> p += strlen ( "rd_bytes=" ) ;\n<31> if ( virStrToLong_ll ( p , & dummy , 10 , rd_bytes ) == - 1 ) VIR_DEBUG ( "error reading rd_bytes: %s" , p ) ;\n<33> else if ( STRPREFIX ( p , "wr_bytes=" ) ) {\n<34> p += strlen ( "wr_bytes=" ) ;\n<35> if ( virStrToLong_ll ( p , & dummy , 10 , wr_bytes ) == - 1 ) VIR_DEBUG ( "error reading wr_bytes: %s" , p ) ;\n<37> else if ( STRPREFIX ( p , "rd_operations=" ) ) {\n<38> p += strlen ( "rd_operations=" ) ;\n<39> if ( virStrToLong_ll ( p , & dummy , 10 , rd_req ) == - 1 ) VIR_DEBUG ( "error reading rd_req: %s" , p ) ;\n<41> else if ( STRPREFIX ( p , "wr_operations=" ) ) {\n<42> p += strlen ( "wr_operations=" ) ;\n<43> if ( virStrToLong_ll ( p , & dummy , 10 , wr_req ) == - 1 ) VIR_DEBUG ( "error reading wr_req: %s" , p ) ;\n<45> else if ( rd_total_times && STRPREFIX ( p , "rd_total_times_ns=" ) ) {\n<46> p += strlen ( "rd_total_times_ns=" ) ;\n<47> if ( virStrToLong_ll ( p , & dummy , 10 , rd_total_times ) == - 1 ) VIR_DEBUG ( "error reading rd_total_times: %s" , p ) ;\n<49> else if ( wr_total_times && STRPREFIX ( p , "wr_total_times_ns=" ) ) {\n<50> p += strlen ( "wr_total_times_ns=" ) ;\n<51> if ( virStrToLong_ll ( p , & dummy , 10 , wr_total_times ) == - 1 ) VIR_DEBUG ( "error reading wr_total_times: %s" , p ) ;\n<53> else if ( flush_req && STRPREFIX ( p , "flush_operations=" ) ) {\n<54> p += strlen ( "flush_operations=" ) ;\n<55> if ( virStrToLong_ll ( p , & dummy , 10 , flush_req ) == - 1 ) VIR_DEBUG ( "error reading flush_req: %s" , p ) ;\n<57> else if ( flush_total_times && STRPREFIX ( p , "flush_total_times_ns=" ) ) {\n<58> p += strlen ( "flush_total_times_ns=" ) ;\n<59> if ( virStrToLong_ll ( p , & dummy , 10 , flush_total_times ) == - 1 ) VIR_DEBUG ( "error reading flush_total_times: %s" , p ) ;\n<62> VIR_DEBUG ( "unknown block stat near %s" , p ) ;\n<64> p = strchr ( p , ' ' ) ;\n<65> if ( ! p || p >= eol ) break ;\n<71> p = strchr ( p , '\n' ) ;\n<72> if ( ! p ) break ;\n<75> qemuReportError ( VIR_ERR_INVALID_ARG , _ ( "no stats found for device %s" ) , dev_name ) ;\n<76> cleanup : VIR_FREE ( info ) ;
<1> int test_gf2m_mod_sqr ( BIO * bp , BN_CTX * ctx ) {\n<41> if ( ! BN_is_zero ( d ) ) {\n<42> fprintf ( stderr , "GF(2^m) modular squaring test failed!\n" ) ;
<1> void abort_not_supported_test ( const char * fmt , ... ) {\n<5> fprintf ( stderr , "The test '%s' is not supported by this installation\n" , file_stack -> file_name ) ;\n<6> fprintf ( stderr , "Detected in file %s at line %d\n" , cur_file -> file_name , cur_file -> lineno ) ;\n<8> print_file_stack ( buff , buff + sizeof ( buff ) ) ;\n<9> fprintf ( stderr , "%s" , buff ) ;\n<11> if ( fmt ) {\n<12> fprintf ( stderr , "reason: " ) ;\n<13> vfprintf ( stderr , fmt , args ) ;\n<14> fprintf ( stderr , "\n" ) ;\n<15> fflush ( stderr ) ;
<1> static void ctl_putdata ( const char * dp , unsigned int dlen , int bin ) {\n<13> * datapt ++ = '\n' ;\n<17> * datapt ++ = ' ' ;\n<22> while ( dlen + overhead + datapt > dataend ) {\n<23> currentlen = MIN ( dlen , ( unsigned int ) ( dataend - datapt ) ) ;\n<24> memcpy ( datapt , dp , currentlen ) ;\n<25> datapt += currentlen ;\n<26> dp += currentlen ;\n<27> dlen -= currentlen ;\n<28> datalinelen += currentlen ;\n<31> memcpy ( datapt , dp , dlen ) ;\n<32> datapt += dlen ;\n<33> datalinelen += dlen ;
<1> static int rm_assemble_video_frame(AVFormatContext *s, RMContext *rm, AVPacket *pkt, int len)\n<123> AV_WL32(rm->videobuf - 3 + 8*rm->cur_slice, rm->videobufpos - 8*rm->slices - 1);\n<141> rm->videobuf[0] = rm->cur_slice-1;\n<143> if(av_new_packet(pkt, rm->videobufpos - 8*(rm->slices - rm->cur_slice)) < 0)\n<147> memcpy(pkt->data, rm->videobuf, 1 + 8*rm->cur_slice);\n<149> memcpy(pkt->data + 1 + 8*rm->cur_slice, rm->videobuf + 1 + 8*rm->slices, rm->videobufpos - 1 - 8*rm->slices);
<1> static int quant_psnr8x8_c(MpegEncContext *s, uint8_t *src1,\n<9> int16_t *const bak = temp + 64;\n<21> s->pdsp.diff_pixels(temp, src1, src2, stride);\n<25> memcpy(bak, temp, 64 * sizeof(int16_t));\n<31> s->fast_dct_quantize(s, temp, 0 /* FIXME */, s->qscale, &i);\n<41> sum += (temp[i] - bak[i]) * (temp[i] - bak[i]);
<1> int event_base_once ( struct event_base * base , int fd , short events , void ( * callback ) ( int , short , void * ) , void * arg , const struct timeval * tv ) {\n<5> if ( events & EV_SIGNAL ) return ( - 1 ) ;\n<6> if ( ( eonce = calloc ( 1 , sizeof ( struct event_once ) ) ) == NULL ) return ( - 1 ) ;\n<7> eonce -> cb = callback ;\n<8> eonce -> arg = arg ;\n<9> if ( events == EV_TIMEOUT ) {\n<10> if ( tv == NULL ) {\n<14> evtimer_set ( & eonce -> ev , event_once_cb , eonce ) ;\n<16> else if ( events & ( EV_READ | EV_WRITE ) ) {\n<18> event_set ( & eonce -> ev , fd , events , event_once_cb , eonce ) ;\n<21> free ( eonce ) ;\n<24> res = event_base_set ( base , & eonce -> ev ) ;\n<25> if ( res == 0 ) res = event_add ( & eonce -> ev , tv ) ;\n<26> if ( res != 0 ) {\n<27> free ( eonce ) ;
<1> static char * auto_complete ( CHANNEL_REC * channel , const char * line ) {\n<5> p = strstr ( line , completion_char ) ;\n<6> if ( p == NULL ) return NULL ;\n<7> nick = g_strndup ( line , ( int ) ( p - line ) ) ;
<1> static const char * construct_prompt ( ) {\n<10> switch ( * ++ c ) {\n<25> prompt = connected ? mysql_get_host_info ( & mysql ) : "not_connected" ;\n<26> if ( strstr ( prompt , "Localhost" ) ) processed_prompt . append ( "localhost" ) ;\n<28> const char * end = strcend ( prompt , ' ' ) ;\n<29> processed_prompt . append ( prompt , ( uint ) ( end - prompt ) ) ;\n<39> if ( strstr ( host_info , "memory" ) ) {\n<40> processed_prompt . append ( mysql . host ) ;\n<42> else if ( strstr ( host_info , "TCP/IP" ) || ! mysql . unix_socket ) add_int_to_prompt ( mysql . port ) ;\n<44> char * pos = strrchr ( mysql . unix_socket , '/' ) ;\n<45> processed_prompt . append ( pos ? pos + 1 : mysql . unix_socket ) ;\n<81> dateTime = ctime ( & lclock ) ;\n<82> processed_prompt . append ( strtok ( dateTime , "\n" ) ) ;
<1> void var_set_query_get_value ( struct st_command * command , VAR * var ) {\n<28> DBUG_PRINT ( "info" , ( "col: %s" , ds_col . str ) ) ;\n<52> i < num_fields ;\n<53> i ++ ) {\n<54> if ( strcmp ( fields [ i ] . name , ds_col . str ) == 0 && strlen ( fields [ i ] . name ) == ds_col . length ) {\n<55> col_no = i ;\n<61> report_or_die ( "Could not find column '%s' in the result of '%s'" , ds_col . str , ds_query . str ) ;\n<63> dynstr_free ( & ds_col ) ;\n<68> dynstr_free ( & ds_col ) ;
<1> static void kvm_msr_buf_reset ( X86CPU * cpu ) {\n<2> memset ( cpu -> kvm_msr_buf , 0 , MSR_BUF_SIZE ) ;
<1> static int tiff_unpack_strip(TiffContext *s, uint8_t *dst, int stride,\n<77> if (ssrc + size - src < width)\n<81> if (!s->fill_order) {\n<83> memcpy(dst, src, width);\n<91> dst[i] = ff_reverse[src[i]];\n<95> src += width;\n<101> for (pixels = 0; pixels < width;) {\n<103> code = (int8_t) *src++;\n<107> code++;\n<109> if (pixels + code > width) {\n<119> memcpy(dst + pixels, src, code);\n<121> src    += code;\n<123> pixels += code;\n<127> code = (-code) + 1;\n<129> if (pixels + code > width) {\n<139> c = *src++;\n<141> memset(dst + pixels, c, code);\n<143> pixels += code;\n<153> pixels = ff_lzw_decode(s->lzw, dst, width);\n<169> dst += stride;
<1> static void mode_in ( struct cpio * cpio ) {\n<33> if ( destpath == NULL ) continue ;\n<34> if ( cpio -> verbose ) fprintf ( stderr , "%s\n" , destpath ) ;\n<35> if ( cpio -> dot ) fprintf ( stderr , "." ) ;\n<39> if ( r != ARCHIVE_OK ) {\n<40> fprintf ( stderr , "%s: %s\n" , archive_entry_pathname ( entry ) , archive_error_string ( ext ) ) ;\n<48> if ( cpio -> dot ) fprintf ( stderr , "\n" ) ;\n<52> if ( ! cpio -> quiet ) {\n<53> int64_t blocks = ( archive_filter_bytes ( a , 0 ) + 511 ) / 512 ;\n<54> fprintf ( stderr , "%lu %s\n" , ( unsigned long ) blocks , blocks == 1 ? "block" : "blocks" ) ;
<1> int ff_dca_xll_decode_audio(DCAContext *s, AVFrame *frame)\n<227> if (!params->rice_code_flag[param_index]) {\n<231> if (bits)\n<233> for (j = 0; j < part0; j++)\n<235> sample_buf[j] = get_bits_sm(gb, bits);\n<239> memset(sample_buf, 0, part0 * sizeof(sample_buf[0]));\n<247> if (bits)\n<251> sample_buf[j] = get_bits_sm(gb, bits);\n<255> memset(sample_buf + part0, 0,\n<257> (s->xll_smpl_in_seg - part0) * sizeof(sample_buf[0]));\n<265> for (j = 0; j < part0; j++) {\n<277> sample_buf[j] = (t & 1) ? -(t >> 1) - 1 : (t >> 1);\n<295> (s->xll_smpl_in_seg - part0) * sizeof(sample_buf[0]));\n<321> sample_buf[get_bits(gb, s->xll_log_smpl_in_seg)] = 1;\n<335> sample_buf[j] = (t & 1) ? -(t >> 1) - 1 : (t >> 1);\n<339> sample_buf[j] = get_bits_sm(gb, aux_bits);\n<349> for (i = 0; i < chset->channels; i++) {\n<357> int *prev = history + (in_channel + i) * DCA_XLL_AORDER_MAX;\n<371> sample_buf[j] += sample_buf[j - 1];\n<385> memcpy(prev, sample_buf + s->xll_smpl_in_seg - DCA_XLL_AORDER_MAX,\n<387> DCA_XLL_AORDER_MAX * sizeof(*prev));\n<409> sample_buf[j] += ((int64_t) coeff * prev[j] + 4) >> 3;\n<557> out[j] = ldexpf(sample_buf[j], shift);\n<565> out[j] += ldexpf(sample_buf[j], shift);
<1> static unsigned int dec_addi_acr(DisasContext *dc)\n<7> DIS(fprintf (logfile, "addi.%c $r%u, $r%u, $acr\n",\n<9> memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n<11> cris_cc_mask(dc, 0);
<1> void kadmin_setstring ( int argc , char * argv [ ] ) {\n<3> char * pname , * canon = NULL , * key , * value ;\n<5> if ( argc != 4 ) {\n<6> fprintf ( stderr , _ ( "usage: set_string principal key value\n" ) ) ;\n<13> if ( retval ) {\n<17> retval = krb5_unparse_name ( context , princ , & canon ) ;\n<23> if ( retval ) {\n<24> com_err ( "set_string" , retval , _ ( "while setting attribute on principal \"%s\"" ) , canon ) ;\n<27> printf ( _ ( "Attribute set for principal \"%s\".\n" ) , canon ) ;\n<29> free ( canon ) ;
<1> int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,\n<13> if (buf_size == 0) {\n<15> memset(dummy_buf, 0, sizeof(dummy_buf));\n<16> buf = dummy_buf;
<1> mbfl_string * mbfl_strcut ( mbfl_string * string , mbfl_string * result , int from , int length ) {\n<75> sz = end - start ;\n<76> if ( ( w = ( unsigned char * ) mbfl_calloc ( sz + 8 , sizeof ( unsigned char ) ) ) == NULL ) {\n<79> memcpy ( w , start , sz ) ;\n<81> w [ sz + 1 ] = '\0' ;\n<82> w [ sz + 2 ] = '\0' ;\n<83> w [ sz + 3 ] = '\0' ;\n<84> result -> val = w ;\n<85> result -> len = sz ;
<1> static struct qcms_modular_transform * qcms_modular_transform_alloc ( ) {\n<2> return calloc ( 1 , sizeof ( struct qcms_modular_transform ) ) ;
<1> int main_loop ( int argc , const char * * argv_ ) {\n<163> fn = argv [ 0 ] ;\n<165> infile = strcmp ( fn , "-" ) ? fopen ( fn , "rb" ) : set_binary_mode ( stdin ) ;
<1> static void pdf_run_CS ( fz_context * ctx , pdf_processor * proc , const char * name , fz_colorspace * colorspace ) {\n<4> if ( ! strcmp ( name , "Pattern" ) ) pdf_set_pattern ( ctx , pr , PDF_STROKE , NULL , NULL ) ;\n<5> else pdf_set_colorspace ( ctx , pr , PDF_STROKE , colorspace ) ;
<1> static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n<29> if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n<53> len = strlen(q_ptsname(master_fd)) + 5;\n<55> chr->filename = g_malloc(len);\n<61> fprintf(stderr, "char device redirected to %s\n", q_ptsname(master_fd));
<1> void * jas_realloc ( void * ptr , size_t size ) {\n<3> JAS_DBGLOG ( 101 , ( "jas_realloc(%x, %zu)\n" , ptr , size ) ) ;\n<4> result = realloc ( ptr , size ) ;\n<5> JAS_DBGLOG ( 100 , ( "jas_realloc(%p, %zu) -> %p\n" , ptr , size , result ) ) ;
<1> static void net_socket_send(void *opaque)\n<5> NetSocketState *s = opaque;\n<15> size = recv(s->fd, buf1, sizeof(buf1), 0);\n<17> if (size < 0) {\n<31> qemu_set_fd_handler(s->fd, NULL, NULL, NULL);\n<39> buf = buf1;\n<45> switch(s->state) {\n<49> l = 4 - s->index;\n<51> if (l > size)\n<53> l = size;\n<55> memcpy(s->buf + s->index, buf, l);\n<57> buf += l;\n<59> size -= l;\n<61> s->index += l;\n<79> l = s->packet_len - s->index;\n<81> if (l > size)\n<83> l = size;\n<85> memcpy(s->buf + s->index, buf, l);\n<87> s->index += l;\n<89> buf += l;\n<91> size -= l;\n<95> qemu_send_packet(s->vc, s->buf, s->packet_len);
<1> static int xbm_decode_frame(AVCodecContext *avctx, void *data,\n<19> while (!avctx->width || !avctx->height) {\n<21> char name[256];\n<27> ptr += strcspn(ptr, "#");\n<29> if (sscanf(ptr, "#define %256s %u", name, &number) != 2) {\n<31> av_log(avctx, AV_LOG_ERROR, "Unexpected preprocessor directive\n");\n<33> return AVERROR_INVALIDDATA;\n<39> len = strlen(name);\n<41> if ((len > 6) && !avctx->height && !memcmp(name + len - 7, "_height", 7)) {\n<43> avctx->height = number;\n<45> } else if ((len > 5) && !avctx->width && !memcmp(name + len - 6, "_width", 6)) {\n<47> avctx->width = number;\n<51> av_log(avctx, AV_LOG_ERROR, "Unknown define '%s'\n", name);\n<53> return AVERROR_INVALIDDATA;\n<57> ptr += strcspn(ptr, "\n\r") + 1;
<1> static int mov_write_header(AVFormatContext *s)\n<21> if (s->oformat != NULL) {\n<23> if (!strcmp("3gp", s->oformat->name)) mov->mode = MODE_3GP;\n<25> else if (!strcmp("3g2", s->oformat->name)) mov->mode = MODE_3GP|MODE_3G2;\n<27> else if (!strcmp("mov", s->oformat->name)) mov->mode = MODE_MOV;\n<29> else if (!strcmp("psp", s->oformat->name)) mov->mode = MODE_PSP;\n<31> else if (!strcmp("ipod",s->oformat->name)) mov->mode = MODE_IPOD;\n<33> else if (!strcmp("ismv",s->oformat->name)) mov->mode = MODE_ISM;\n<167> track->enc = st->codec;\n<177> track->tag  = mov_find_codec_tag(s, track);\n<295> avpriv_set_pts_info(st, 64, 1, track->timescale);\n<301> if (st->codec->extradata_size) {\n<305> track->vos_data = av_malloc(track->vos_len);\n<307> memcpy(track->vos_data, st->codec->extradata, track->vos_len);
<1> static int set_pid_priority ( pid_t pid , int policy , int priority , char * message , char * name ) {\n<6> if ( ( sched_setscheduler ( pid , policy , & par ) != 0 ) ) {\n<7> print_error ( stderr , message , pid , name , strerror ( errno ) ) ;
<1> char * Curl_checkProxyheaders ( const struct connectdata * conn , const char * thisheader ) {\n<3> size_t thislen = strlen ( thisheader ) ;\n<8> if ( Curl_raw_nequal ( head -> data , thisheader , thislen ) ) return head -> data ;
<1> static char * xmlrpc_method ( char * buffer ) {\n<4> data = strstr ( buffer , "<methodName>" ) ;\n<5> if ( data ) {\n<6> data += 12 ;\n<7> p = strchr ( data , '<' ) ;\n<8> if ( p == NULL ) return NULL ;\n<9> namelen = p - data ;\n<10> name = smalloc ( namelen + 1 ) ;\n<11> memcpy ( name , data , namelen ) ;\n<13> return name ;
<1> static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n<3> struct usb_hci_out_fifo_s *fifo,\n<9> const uint8_t *data, int len)\n<13> if (fifo->len) {\n<15> memcpy(fifo->data + fifo->len, data, len);\n<17> fifo->len += len;\n<27> } else if (complete(data, len))\n<33> memcpy(fifo->data, data, len);\n<35> fifo->len = len;
<1> static void allocate_system_memory_nonnuma(MemoryRegion *mr, Object *owner,\n<9> if (mem_path) {\n<37> fprintf(stderr, "-mem-path not supported on this host\n");
<1> int ff_h264_decode_mb_cabac(const H264Context *h, H264SliceContext *sl)\n<259> if ((int) (sl->cabac.bytestream_end - ptr) < mb_size)\n<285> memset(h->non_zero_count[mb_xy], 16, 48);
<1> static int mpc7_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<5> MPCContext * c = avctx -> priv_data ;\n<9> Band * bands = c -> bands ;\n<12> memset ( bands , 0 , sizeof ( * bands ) * ( c -> maxbands + 1 ) ) ;\n<31> if ( ! c -> bits ) return AVERROR ( ENOMEM ) ;\n<82> memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n<88> ch ++ ) idx_to_quant ( c , & gb , bands [ i ] . res [ ch ] , c -> Q [ ch ] + off ) ;\n<89> ff_mpc_dequantize_and_synth ( c , mb , ( int16_t * * ) frame -> extended_data , 2 ) ;
<1> int qemuMonitorTextAddPCIHostDevice ( qemuMonitorPtr mon , virDomainDevicePCIAddress * hostAddr , virDomainDevicePCIAddress * guestAddr ) {\n<3> char * reply = NULL ;\n<5> memset ( guestAddr , 0 , sizeof ( * guestAddr ) ) ;\n<10> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<14> if ( strstr ( reply , "invalid type: host" ) ) {\n<15> qemuReportError ( VIR_ERR_OPERATION_INVALID , "%s" , _ ( "PCI device assignment is not supported by this version of qemu" ) ) ;\n<18> if ( qemuMonitorTextParsePciAddReply ( mon , reply , guestAddr ) < 0 ) {\n<24> VIR_FREE ( reply ) ;
<1> static afs_int32 idToName ( struct rx_call * call , idlist * aid , namelist * aname ) {\n<9> if ( size < 0 || size > INT_MAX / PR_MAXNAMELEN ) return PRTOOMANY ;\n<10> aname -> namelist_val = ( prname * ) malloc ( size * PR_MAXNAMELEN ) ;\n<12> if ( aname -> namelist_val == 0 ) return PRNOMEM ;\n<26> code = IDToName ( tt , aid -> idlist_val [ i ] , aname -> namelist_val [ i ] ) ;\n<27> if ( code != PRSUCCESS ) sprintf ( aname -> namelist_val [ i ] , "%d" , aid -> idlist_val [ i ] ) ;\n<28> osi_audit ( PTS_IdToNmEvent , code , AUD_ID , aid -> idlist_val [ i ] , AUD_STR , aname -> namelist_val [ i ] , AUD_END ) ;
<1> static bfd_boolean srec_set_section_contents ( bfd * abfd , sec_ptr section , const void * location , file_ptr offset , bfd_size_type bytes_to_do ) {\n<9> data = ( bfd_byte * ) bfd_alloc ( abfd , bytes_to_do ) ;\n<10> if ( data == NULL ) return FALSE ;\n<11> memcpy ( ( void * ) data , location , ( size_t ) bytes_to_do ) ;
<1> static void http_chunked_cb ( struct evhttp_request * req , void * arg ) {\n<5> struct chunk_req_state * state = malloc ( sizeof ( struct chunk_req_state ) ) ;\n<7> memset ( state , 0 , sizeof ( struct chunk_req_state ) ) ;\n<10> event_once ( - 1 , EV_TIMEOUT , http_chunked_trickle_cb , state , & when ) ;
<1> static int check_pack_inflate ( struct packed_git * p , struct pack_window * * w_curs , off_t offset , off_t len , unsigned long expect ) {\n<5> memset ( & stream , 0 , sizeof ( stream ) ) ;\n<6> git_inflate_init ( & stream ) ;\n<8> in = use_pack ( p , w_curs , offset , & stream . avail_in ) ;\n<12> st = git_inflate ( & stream , Z_FINISH ) ;\n<13> offset += stream . next_in - in ;\n<16> git_inflate_end ( & stream ) ;\n<17> return ( st == Z_STREAM_END && stream . total_out == expect && stream . total_in == len ) ? 0 : - 1 ;
<1> static bfd_boolean srec_write_header ( bfd * abfd ) {\n<2> unsigned int len = strlen ( abfd -> filename ) ;\n<3> if ( len > 40 ) len = 40 ;\n<4> return srec_write_record ( abfd , 0 , ( bfd_vma ) 0 , ( bfd_byte * ) abfd -> filename , ( bfd_byte * ) abfd -> filename + len ) ;
<1> int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res)\n<83> for(i = 0; i < s->refcount_table_size; i++) {\n<95> if (offset & (s->cluster_size - 1)) {\n<97> fprintf(stderr, "ERROR refcount block %d is not "\n<109> if (cluster >= nb_clusters) {\n<111> fprintf(stderr, "ERROR refcount block %d is outside image\n", i);\n<123> inc_refcounts(bs, res, refcount_table, nb_clusters,\n<127> if (refcount_table[cluster] != 1) {\n<129> fprintf(stderr, "ERROR refcount block %d refcount=%d\n",\n<145> for(i = 0; i < nb_clusters; i++) {\n<147> refcount1 = get_refcount(bs, i);\n<149> if (refcount1 < 0) {\n<151> fprintf(stderr, "Can't get refcount for cluster %d: %s\n",\n<153> i, strerror(-refcount1));\n<165> if (refcount1 != refcount2) {\n<167> fprintf(stderr, "%s cluster %d refcount=%d reference=%d\n",\n<169> refcount1 < refcount2 ? "ERROR" : "Leaked",\n<173> if (refcount1 < refcount2) {\n<189> qemu_free(refcount_table);
<1> int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n<13> if (!ff_thread_can_start_frame(avctx)) {\n<259> for(i=0; i<avctx->height; i++)\n<261> memset(s->last_picture_ptr->f->data[0] + s->last_picture_ptr->f->linesize[0]*i,\n<265> for(i=0; i<FF_CEIL_RSHIFT(avctx->height, v_chroma_shift); i++) {\n<267> memset(s->last_picture_ptr->f->data[1] + s->last_picture_ptr->f->linesize[1]*i,\n<269> 0x80, FF_CEIL_RSHIFT(avctx->width, h_chroma_shift));\n<271> memset(s->last_picture_ptr->f->data[2] + s->last_picture_ptr->f->linesize[2]*i,\n<273> 0x80, FF_CEIL_RSHIFT(avctx->width, h_chroma_shift));\n<281> for(i=0; i<avctx->height; i++)\n<283> memset(s->last_picture_ptr->f->data[0] + s->last_picture_ptr->f->linesize[0]*i, 16, avctx->width);
<1> static void init_gain_table(COOKContext *q) {\n<15> memset(&q->gain_copy, 0, sizeof(COOKgain));\n<17> memset(&q->gain_current, 0, sizeof(COOKgain));\n<19> memset(&q->gain_now, 0, sizeof(COOKgain));\n<21> memset(&q->gain_previous, 0, sizeof(COOKgain));
<9> j < i ;\n<10> j ++ ) if ( ! memcmp ( h -> pps . scaling_matrix8 [ j ] , h -> pps . scaling_matrix8 [ i ] , * sizeof ( uint8_t ) ) ) {\n<11> h -> dequant8_coeff [ i ] = h -> dequant8_buffer [ j ] ;\n<22> x ++ ) h -> dequant8_coeff [ i ] [ q ] [ ( x >> 3 ) | ( ( x & 7 ) << 3 ) ] = ( ( uint32_t ) dequant8_coeff_init [ idx ] [ dequant8_coeff_init_scan [ ( ( x >> 1 ) & 12 ) | ( x & 3 ) ] ] * h -> pps . scaling_matrix8 [ i ] [ x ] ) << shift ;
<1> static int get_options ( int * argc , char * * * argv ) {\n<9> if ( my_hash_init ( & ignore_table , charset_info , 16 , 0 , 0 , ( my_hash_get_key ) get_table_key , my_free , 0 ) ) return ( EX_EOM ) ;\n<17> if ( ! path && ( enclosed || opt_enclosed || escaped || lines_terminated || fields_terminated ) ) {\n<18> fprintf ( stderr , "%s: You must use option --tab with --fields-...\n" , my_progname_short ) ;\n<27> if ( opt_single_transaction && opt_lock_all_tables ) {\n<28> fprintf ( stderr , "%s: You can't use --single-transaction and " "--lock-all-tables at the same time.\n" , my_progname_short ) ;\n<36> if ( enclosed && opt_enclosed ) {\n<37> fprintf ( stderr , "%s: You can't use ..enclosed.. and ..optionally-enclosed.. at the same time.\n" , my_progname_short ) ;\n<40> if ( ( opt_databases || opt_alldbs ) && path ) {\n<41> fprintf ( stderr , "%s: --databases or --all-databases can't be used with --tab.\n" , my_progname_short ) ;\n<44> if ( strcmp ( default_charset , charset_info -> csname ) && ! ( charset_info = get_charset_by_csname ( default_charset , MY_CS_PRIMARY , MYF ( MY_WME ) ) ) ) exit ( 1 ) ;
<1> static int convert_to_token ( const unsigned char * src , size_t len , char * dest ) {\n<2> if ( dest ) memcpy ( dest , src , len ) ;\n<3> return len ;
<1> static NetSocketState *net_socket_fd_init_dgram(NetClientState *peer,\n<35> if (getsockname(fd, (struct sockaddr *) &saddr, &saddr_len) == 0) {\n<39> if (saddr.sin_addr.s_addr == 0) {\n<41> fprintf(stderr, "qemu: error: init_dgram: fd=%d unbound, "\n<75> fd, strerror(errno));\n<129> closesocket(fd);
<1> void ntpq_custom_opt_handler ( tOptions * pOptions , tOptDesc * pOptDesc ) {\n<2> switch ( pOptDesc -> optValue ) {\n<3> default : fprintf ( stderr , "ntpq_custom_opt_handler unexpected option '%c' (%d)\n" , pOptDesc -> optValue , pOptDesc -> optValue ) ;
<1> static int leap_file ( FILE * fp ) {\n<2> char buf [ NTP_MAXSTRLEN ] ;\n<7> offset = 0 ;\n<8> leap = 0 ;\n<9> expire = 0 ;\n<11> while ( fgets ( buf , NTP_MAXSTRLEN - 1 , fp ) != NULL ) {\n<12> if ( strlen ( buf ) < 1 ) continue ;\n<13> if ( buf [ 0 ] == '#' ) {\n<14> if ( strlen ( buf ) < 3 ) continue ;\n<15> if ( buf [ 1 ] == '@' || buf [ 1 ] == '$' ) {\n<16> if ( sscanf ( & buf [ 2 ] , "%lu" , & expire ) != 1 ) return ( - 1 ) ;\n<20> if ( sscanf ( buf , "%lu %d" , & leap , & offset ) == 2 ) {\n<21> if ( i ++ != offset ) return ( - 1 ) ;\n<24> if ( i == 10 ) return ( - 1 ) ;\n<25> leap_tai = offset ;\n<26> leap_sec = leap ;\n<27> leap_expire = expire ;
<1> static int lxc_cgroup_set_data ( const char * filename , const char * value , struct cgfs_data * d ) {\n<4> subsystem = alloca ( strlen ( filename ) + 1 ) ;\n<5> strcpy ( subsystem , filename ) ;\n<6> if ( ( p = strchr ( subsystem , '.' ) ) != NULL ) * p = '\0' ;\n<7> path = lxc_cgroup_get_hierarchy_abs_path_data ( subsystem , d ) ;\n<8> if ( path ) {\n<9> ret = do_cgroup_set ( path , filename , value ) ;\n<10> free ( path ) ;
<1> int jbig2_pattern_dictionary ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n<25> GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n<26> if ( GB_stats == NULL ) {\n<30> memset ( GB_stats , 0 , stats_size ) ;\n<32> segment -> result = jbig2_decode_pattern_dict ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , GB_stats ) ;
<6> if ( ! PyArg_ParseTuple ( args , "s" , & service ) ) return NULL ;\n<7> state = ( gss_server_state * ) malloc ( sizeof ( gss_server_state ) ) ;
<1> static void pdf_run_cs ( fz_context * ctx , pdf_processor * proc , const char * name , fz_colorspace * colorspace ) {\n<4> if ( ! strcmp ( name , "Pattern" ) ) pdf_set_pattern ( ctx , pr , PDF_FILL , NULL , NULL ) ;\n<5> else pdf_set_colorspace ( ctx , pr , PDF_FILL , colorspace ) ;
<1> static int plot_spectrum_column(AVFilterLink *inlink, AVFrame *insamples)\n<9> ShowSpectrumContext *s = ctx->priv;\n<21> clear_combine_buffer(s, z);\n<53> for (y = 0; y < s->h; y++) {\n<59> memmove(p, p + 1, s->w - 1);\n<71> for (y = 0; y < s->h; y++) {\n<77> memmove(p + 1, p, s->w - 1);\n<111> for (y = 1; y < s->h; y++) {\n<113> memmove(outpicref->data[plane] + (y-1) * outpicref->linesize[plane],\n<115> outpicref->data[plane] + (y  ) * outpicref->linesize[plane],\n<129> for (y = s->h - 1; y >= 1; y--) {\n<131> memmove(outpicref->data[plane] + (y  ) * outpicref->linesize[plane],\n<133> outpicref->data[plane] + (y-1) * outpicref->linesize[plane],\n<151> for (x = 0; x < s->w; x++) {\n<173> if (s->orientation == VERTICAL && s->xpos >= s->w)
<1> static int is_response_status_relevant ( modsec_rec * msr , int status ) {\n<5> if ( ( msr -> txcfg -> auditlog_relevant_regex == NULL ) || ( msr -> txcfg -> auditlog_relevant_regex == NOT_SET_P ) ) {\n<8> apr_snprintf ( buf , sizeof ( buf ) , "%d" , status ) ;\n<9> rc = msc_regexec ( msr -> txcfg -> auditlog_relevant_regex , buf , strlen ( buf ) , & my_error_msg ) ;
<1> static int nut_write_header(AVFormatContext *s)\n<7> ByteIOContext *bc = &s->pb;\n<15> nut->avf= s;\n<27> put_buffer(bc, ID_STRING, strlen(ID_STRING));\n<29> put_byte(bc, 0);\n<51> put_v(bc, nut->rate_num=1);\n<53> put_v(bc, nut->rate_den=2);\n<55> put_v(bc, nut->short_startcode=0x4EFE79);\n<59> build_frame_code(s);\n<139> update_packetheader(nut, bc, 0, 1);\n<303> update_packetheader(nut, bc, 0, 1);\n<311> put_be64(bc, INFO_STARTCODE);\n<313> put_packetheader(nut, bc, 30+strlen(s->author)+strlen(s->title)+\n<315> strlen(s->comment)+strlen(s->copyright)+strlen(LIBAVFORMAT_IDENT), 1);\n<321> put_v(bc, 9); /* type */\n<323> put_str(bc, s->author);\n<331> put_v(bc, 10); /* type */\n<333> put_str(bc, s->title);\n<341> put_v(bc, 11); /* type */\n<343> put_str(bc, s->comment);\n<351> put_v(bc, 12); /* type */\n<353> put_str(bc, s->copyright);\n<361> put_v(bc, 13); /* type */\n<363> put_str(bc, LIBAVFORMAT_IDENT);\n<369> put_v(bc, 0); /* eof info */\n<371> update_packetheader(nut, bc, 0, 1);
<1> static int glob_in_dir ( const char * pattern , const char * directory , int flags , int ( * errfunc ) ( const char * , int ) , glob_t * pglob , size_t alloca_used ) {\n<2> size_t dirlen = strlen ( directory ) ;\n<20> meta = __glob_pattern_type ( pattern , ! ( flags & GLOB_NOESCAPE ) ) ;\n<24> else if ( meta == 0 ) {\n<30> size_t patlen = strlen ( pattern ) ;\n<31> int alloca_fullname = __libc_use_alloca ( alloca_used + dirlen + 1 + patlen + 1 ) ;\n<33> if ( alloca_fullname ) fullname = alloca_account ( dirlen + 1 + patlen + 1 , alloca_used ) ;\n<35> fullname = malloc ( dirlen + 1 + patlen + 1 ) ;\n<36> if ( fullname == NULL ) return GLOB_NOSPACE ;\n<38> mempcpy ( mempcpy ( mempcpy ( fullname , directory , dirlen ) , "/" , 1 ) , pattern , patlen + 1 ) ;\n<39> if ( ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_stat ) ( fullname , & ust . st ) : __stat64 ( fullname , & ust . st64 ) ) == 0 ) flags |= GLOB_NOCHECK ;\n<40> if ( __builtin_expect ( ! alloca_fullname , 0 ) ) free ( fullname ) ;\n<43> stream = ( __builtin_expect ( flags & GLOB_ALTDIRFUNC , 0 ) ? ( * pglob -> gl_opendir ) ( directory ) : opendir ( directory ) ) ;\n<44> if ( stream == NULL ) {\n<74> if ( fnmatch ( pattern , name , fnm_flags ) == 0 ) {\n<75> if ( ! DIRENT_MIGHT_BE_SYMLINK ( d ) || link_exists_p ( dfd , directory , dirlen , name , pglob , flags ) ) {\n<76> if ( cur == names -> count ) {\n<80> if ( __libc_use_alloca ( alloca_used + size ) ) newnames = names_alloca = alloca_account ( size , alloca_used ) ;\n<81> else if ( ( newnames = malloc ( size ) ) == NULL ) goto memory_error ;\n<82> newnames -> count = count ;\n<83> newnames -> next = names ;\n<84> names = newnames ;\n<85> cur = 0 ;\n<87> len = NAMLEN ( d ) ;\n<88> names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n<89> if ( names -> name [ cur ] == NULL ) goto memory_error ;\n<97> if ( nfound == 0 && ( flags & GLOB_NOCHECK ) ) {\n<98> size_t len = strlen ( pattern ) ;\n<100> names -> name [ cur ] = ( char * ) malloc ( len + 1 ) ;\n<101> if ( names -> name [ cur ] == NULL ) goto memory_error ;\n<102> * ( ( char * ) mempcpy ( names -> name [ cur ++ ] , pattern , len ) ) = '\0' ;\n<105> if ( nfound != 0 ) {\n<108> new_gl_pathv = ( char * * ) realloc ( pglob -> gl_pathv , ( pglob -> gl_pathc + pglob -> gl_offs + nfound + 1 ) * sizeof ( char * ) ) ;\n<109> if ( new_gl_pathv == NULL ) {\n<111> struct globnames * old = names ;\n<112> for ( size_t i = 0 ;\n<113> i < cur ;\n<114> ++ i ) free ( names -> name [ i ] ) ;\n<115> names = names -> next ;\n<116> if ( names == NULL ) {\n<121> if ( old == names_alloca ) names_alloca = names ;\n<122> else free ( old ) ;\n<124> result = GLOB_NOSPACE ;\n<138> if ( old == names_alloca ) names_alloca = names ;\n<139> else free ( old ) ;\n<146> if ( stream != NULL ) {
<1> static int get_frame_stats ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , vpx_fixed_buf_t * stats ) {\n<9> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) {\n<10> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ;\n<11> const size_t pkt_size = pkt -> data . twopass_stats . sz ;\n<12> stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ;\n<13> memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ;\n<14> stats -> sz += pkt_size ;
<1> static void test_opt_reconnect ( ) {\n<5> if ( ! ( lmysql = mysql_client_init ( NULL ) ) ) {\n<9> if ( ! opt_silent ) fprintf ( stdout , "reconnect before mysql_options: %d\n" , lmysql -> reconnect ) ;\n<10> DIE_UNLESS ( lmysql -> reconnect == 0 ) ;\n<11> if ( mysql_options ( lmysql , MYSQL_OPT_RECONNECT , & my_true ) ) {\n<15> if ( ! opt_silent ) fprintf ( stdout , "reconnect after mysql_options: %d\n" , lmysql -> reconnect ) ;\n<16> DIE_UNLESS ( lmysql -> reconnect == 1 ) ;\n<17> if ( ! ( mysql_real_connect ( lmysql , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , 0 ) ) ) {\n<21> if ( ! opt_silent ) fprintf ( stdout , "reconnect after mysql_real_connect: %d\n" , lmysql -> reconnect ) ;\n<22> DIE_UNLESS ( lmysql -> reconnect == 1 ) ;\n<24> if ( ! ( lmysql = mysql_client_init ( NULL ) ) ) {\n<28> if ( ! opt_silent ) fprintf ( stdout , "reconnect before mysql_real_connect: %d\n" , lmysql -> reconnect ) ;\n<29> DIE_UNLESS ( lmysql -> reconnect == 0 ) ;\n<30> if ( ! ( mysql_real_connect ( lmysql , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , 0 ) ) ) {\n<34> if ( ! opt_silent ) fprintf ( stdout , "reconnect after mysql_real_connect: %d\n" , lmysql -> reconnect ) ;\n<35> DIE_UNLESS ( lmysql -> reconnect == 0 ) ;
<1> CURLcode glob_next_url ( char * * globbed , URLGlob * glob ) {\n<15> pat = & glob -> pattern [ glob -> size - 1 - i ] ;\n<16> switch ( pat -> type ) {\n<34> default : printf ( "internal error: invalid pattern type (%d)\n" , ( int ) pat -> type ) ;\n<43> i < glob -> size ;\n<45> pat = & glob -> pattern [ i ] ;\n<46> switch ( pat -> type ) {\n<47> case UPTSet : if ( pat -> content . Set . elements ) {\n<48> len = strlen ( pat -> content . Set . elements [ pat -> content . Set . ptr_s ] ) ;\n<49> snprintf ( buf , buflen , "%s" , pat -> content . Set . elements [ pat -> content . Set . ptr_s ] ) ;\n<50> buf += len ;\n<51> buflen -= len ;\n<60> default : printf ( "internal error: invalid pattern type (%d)\n" , ( int ) pat -> type ) ;\n<65> * globbed = strdup ( glob -> glob_buffer ) ;\n<66> if ( ! * globbed ) return CURLE_OUT_OF_MEMORY ;
<1> static char * primary_key_fields ( const char * table_name ) {\n<5> uint result_length = 0 ;\n<15> if ( ( row = mysql_fetch_row ( res ) ) && atoi ( row [ 1 ] ) == 0 ) {\n<17> quoted_field = quote_name ( row [ 4 ] , buff , 0 ) ;\n<18> result_length += strlen ( quoted_field ) + 1 ;\n<20> while ( ( row = mysql_fetch_row ( res ) ) && atoi ( row [ 3 ] ) > 1 ) ;\n<24> result = my_malloc ( result_length + 10 , MYF ( MY_WME ) ) ;\n<25> if ( ! result ) {\n<26> fprintf ( stderr , "Error: Not enough memory to store ORDER BY clause\n" ) ;
<1> static int fetch_indices ( void ) {\n<3> if ( push_verbosely ) fprintf ( stderr , "Getting pack list\n" ) ;
<1> static int qemuMonitorTextAddUSBDevice ( qemuMonitorPtr mon , const char * addr ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<13> if ( strstr ( reply , "Could not add " ) ) {\n<14> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , _ ( "adding usb device failed" ) ) ;\n<17> ret = 0 ;\n<19> VIR_FREE ( reply ) ;
<1> const char * pkg_writeCharList ( FileStream * s , CharList * l , const char * delim , int32_t quote ) {\n<7> if ( uprv_strlen ( l -> str ) >= 1023 ) {\n<8> fprintf ( stderr , "%s:%d: Internal error, line too long (greater than 1023 chars)\n" , __FILE__ , __LINE__ ) ;
<1> int jbig2_halftone_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n<39> GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n<40> if ( GB_stats == NULL ) {\n<43> memset ( GB_stats , 0 , stats_size ) ;\n<47> jbig2_free ( ctx -> allocator , GB_stats ) ;\n<50> code = jbig2_decode_halftone_region ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , image , GB_stats ) ;
<1> static int save_xbzrle_page(QEMUFile *f, uint8_t **current_data,\n<15> if (!cache_is_cached(XBZRLE.cache, current_addr)) {\n<49> memcpy(XBZRLE.current_buf, *current_data, TARGET_PAGE_SIZE);\n<55> encoded_len = xbzrle_encode_buffer(prev_cached_page, XBZRLE.current_buf,\n<75> if (!last_stage) {\n<77> memcpy(prev_cached_page, *current_data, TARGET_PAGE_SIZE);\n<79> *current_data = prev_cached_page;\n<91> if (!last_stage) {\n<93> memcpy(prev_cached_page, XBZRLE.current_buf, TARGET_PAGE_SIZE);
<1> static void adb_kbd_reset(DeviceState *dev)\n<7> KBDState *s = ADB_KEYBOARD(dev);\n<15> memset(s->data, 0, sizeof(s->data));
<1> int spapr_rtas_register(const char *name, spapr_rtas_fn fn)\n<9> for (i = 0; i < (rtas_next - rtas_table); i++) {\n<11> if (strcmp(name, rtas_table[i].name) == 0) {\n<13> fprintf(stderr, "RTAS call \"%s\" registered twice\n", name);\n<15> exit(1);\n<27> rtas_next->name = name;
<1> size_t WriteStr ( ArchiveHandle * AH , const char * c ) {\n<3> if ( c ) {\n<4> int len = strlen ( c ) ;\n<5> res = WriteInt ( AH , len ) ;\n<6> ( * AH -> WriteBufPtr ) ( AH , c , len ) ;
<1> static void stroke_loglevel ( private_stroke_socket_t * this , stroke_msg_t * msg , FILE * out ) {\n<3> pop_string ( msg , & ( msg -> loglevel . type ) ) ;\n<5> if ( this -> prevent_loglevel_changes ) {\n<7> fprintf ( out , "command not allowed!\n" ) ;\n<10> if ( ! enum_from_name ( debug_names , msg -> loglevel . type , & group ) ) {\n<11> fprintf ( out , "unknown type '%s'!\n" , msg -> loglevel . type ) ;
<1> err_status_t srtp_stream_init_keys ( srtp_stream_ctx_t * srtp , const void * key ) {\n<4> uint8_t tmp_key [ MAX_SRTP_KEY_LEN ] ;\n<20> debug_print ( mod_srtp , "base key len: %d" , rtp_base_key_len ) ;\n<22> debug_print ( mod_srtp , "rtp salt len: %d" , rtp_salt_len ) ;\n<23> memset ( tmp_key , 0x0 , MAX_SRTP_KEY_LEN ) ;\n<24> memcpy ( tmp_key , key , ( rtp_base_key_len + rtp_salt_len ) ) ;\n<25> stat = srtp_kdf_init ( & kdf , AES_ICM , ( const uint8_t * ) tmp_key , kdf_keylen ) ;\n<29> stat = srtp_kdf_generate ( & kdf , label_rtp_encryption , tmp_key , rtp_base_key_len ) ;\n<31> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<34> debug_print ( mod_srtp , "cipher key: %s" , octet_string_hex_string ( tmp_key , rtp_base_key_len ) ) ;\n<38> if ( stat ) {\n<39> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<42> memcpy ( srtp -> salt , tmp_key + rtp_base_key_len , SRTP_AEAD_SALT_LEN ) ;\n<49> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<54> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<60> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<66> stat = srtp_kdf_generate ( & kdf , label_rtcp_encryption , tmp_key , rtcp_base_key_len ) ;\n<68> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<74> if ( stat ) {\n<75> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<78> memcpy ( srtp -> c_salt , tmp_key + rtcp_base_key_len , SRTP_AEAD_SALT_LEN ) ;\n<86> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<91> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<97> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;\n<101> octet_string_set_to_zero ( tmp_key , MAX_SRTP_KEY_LEN ) ;
<1> static int read_block_data ( MLPDecodeContext * m , GetBitContext * gbp , unsigned int substr ) {\n<10> if ( s -> blockpos + s -> blocksize > m -> access_unit_size ) {\n<14> memset ( & m -> bypassed_lsbs [ s -> blockpos ] [ 0 ] , 0 , s -> blocksize * sizeof ( m -> bypassed_lsbs [ 0 ] ) ) ;
<1> static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,\n<15> if (xendev) {\n<39> snprintf(xendev->be, sizeof(xendev->be), "%s/backend/%s/%d/%d",\n<47> free(dom0);
<1> static int remoteStreamHandleWriteData ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n<5> memset ( & rerr , 0 , sizeof rerr ) ;\n<17> remoteDispatchError ( & rerr ) ;\n<18> return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
<1> void av_image_copy(uint8_t *dst_data[4], int dst_linesizes[4],\n<3> const uint8_t *src_data[4], const int src_linesizes[4],\n<19> if (desc->flags & PIX_FMT_PAL) {\n<29> memcpy(dst_data[1], src_data[1], 4*256);
<1> static void test_ushort_bug ( ) {\n<22> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<37> rc = mysql_stmt_bind_result ( stmt , my_bind ) ;\n<41> if ( ! opt_silent ) {\n<42> fprintf ( stdout , "\n ushort : %d (%ld)" , short_value , s_length ) ;\n<43> fprintf ( stdout , "\n ulong : %lu (%ld)" , ( ulong ) long_value , l_length ) ;\n<44> fprintf ( stdout , "\n longlong : %s (%ld)" , llstr ( longlong_value , llbuf ) , ll_length ) ;\n<45> fprintf ( stdout , "\n tinyint : %d (%ld)" , tiny_value , t_length ) ;\n<47> DIE_UNLESS ( short_value == 35999 ) ;\n<48> DIE_UNLESS ( s_length == 2 ) ;\n<50> DIE_UNLESS ( l_length == 4 ) ;\n<52> DIE_UNLESS ( ll_length == 8 ) ;\n<53> DIE_UNLESS ( tiny_value == 200 ) ;\n<54> DIE_UNLESS ( t_length == 1 ) ;
<1> int ff_pca(PCA *pca, double *eigenvector, double *eigenvalue){\n<11> memset(eigenvector, 0, sizeof(double)*n*n);\n<77> double tmp= eigenvector[k + j*n];\n<79> eigenvector[k + j*n]= eigenvector[i + j*n];
<1> static inline bool __ipv6_prefix_equal ( const __be32 * a1 , const __be32 * a2 , unsigned int prefixlen ) {\n<3> pdw = prefixlen >> 5 ;\n<4> if ( pdw && memcmp ( a1 , a2 , pdw << 2 ) ) return false ;\n<5> pbi = prefixlen & 0x1f ;\n<6> if ( pbi && ( ( a1 [ pdw ] ^ a2 [ pdw ] ) & htonl ( ( 0xffffffff ) << ( 32 - pbi ) ) ) ) return false ;
<1> static int load_elf_binary(struct linux_binprm * bprm, struct target_pt_regs * regs,\n<45> char passed_fileno[6];\n<79> if ((elf_ex.e_type != ET_EXEC && elf_ex.e_type != ET_DYN) ||\n<91> elf_phdata = (struct elf_phdr *)malloc(elf_ex.e_phentsize*elf_ex.e_phnum);\n<93> if (elf_phdata == NULL) {\n<101> retval = lseek(bprm->fd, elf_ex.e_phoff, SEEK_SET);\n<113> if (retval < 0) {\n<119> free (elf_phdata);\n<139> elf_ppnt = elf_phdata;\n<153> elf_interpreter = NULL;\n<167> if ( elf_interpreter != NULL )\n<171> free (elf_phdata);\n<173> free(elf_interpreter);\n<193> elf_interpreter = (char *)malloc(elf_ppnt->p_filesz);\n<197> if (elf_interpreter == NULL) {\n<199> free (elf_phdata);\n<209> retval = lseek(bprm->fd, elf_ppnt->p_offset, SEEK_SET);\n<213> retval = read(bprm->fd, elf_interpreter, elf_ppnt->p_filesz);\n<239> if (strcmp(elf_interpreter,"/usr/lib/libc.so.1") == 0 ||\n<241> strcmp(elf_interpreter,"/usr/lib/ld.so.1") == 0) {\n<243> ibcs2_interpreter = 1;\n<257> retval = open(path(elf_interpreter), O_RDONLY);\n<267> perror(elf_interpreter);\n<299> if (retval < 0) {\n<305> free (elf_phdata);\n<307> free(elf_interpreter);\n<317> elf_ppnt++;\n<353> if (!interpreter_type) {\n<355> free(elf_interpreter);\n<357> free(elf_phdata);\n<381> if (interpreter_type == INTERPRETER_AOUT) {\n<383> sprintf(passed_fileno, "%d", bprm->fd);\n<385> passed_p = passed_fileno;\n<399> if (!bprm->p) {\n<401> if (elf_interpreter) {\n<403> free(elf_interpreter);\n<407> free (elf_phdata);\n<409> close(bprm->fd);\n<439> bprm->p = setup_arg_pages(bprm->p, bprm, info);\n<457> for(i = 0, elf_ppnt = elf_phdata; i < elf_ex.e_phnum; i++, elf_ppnt++) {\n<517> error = target_mmap(TARGET_ELF_PAGESTART(load_bias + elf_ppnt->p_vaddr),\n<577> k = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n<615> if (elf_interpreter) {\n<635> free(elf_interpreter);\n<639> if (elf_entry == ~0UL) {\n<641> printf("Unable to load interpreter\n");\n<643> free(elf_phdata);\n<655> free(elf_phdata);\n<661> load_symbols(&elf_ex, bprm->fd);\n<665> if (interpreter_type != INTERPRETER_AOUT) close(bprm->fd);\n<695> if (interpreter_type == INTERPRETER_AOUT)\n<697> info->arg_start += strlen(passed_fileno) + 1;
<1> static hm_fragment * dtls1_hm_fragment_new ( unsigned long frag_len , int reassembly ) {\n<17> if ( bitmask == NULL ) {\n<22> memset ( bitmask , 0 , RSMBLY_BITMASK_SIZE ( frag_len ) ) ;\n<24> frag -> reassembly = bitmask ;
<1> vmstate_get_subsection(const VMStateSubsection *sub, char *idstr)\n<5> while (sub && sub->needed) {\n<7> if (strcmp(idstr, sub->vmsd->name) == 0) {\n<9> return sub->vmsd;\n<13> sub++;
<1> static void ini_print_section_header ( WriterContext * wctx ) {\n<7> if ( ! parent_section ) {\n<8> printf ( "# ffprobe output\n\n" ) ;\n<11> if ( wctx -> nb_item [ wctx -> level - 1 ] ) printf ( "\n" ) ;\n<12> av_bprintf ( buf , "%s" , wctx -> section_pbuf [ wctx -> level - 1 ] . str ) ;\n<14> av_bprintf ( buf , "%s%s" , buf -> str [ 0 ] ? "." : "" , wctx -> section [ wctx -> level ] -> name ) ;\n<17> av_bprintf ( buf , ".%d" , n ) ;\n<20> if ( ! ( section -> flags & ( SECTION_FLAG_IS_ARRAY | SECTION_FLAG_IS_WRAPPER ) ) ) printf ( "[%s]\n" , buf -> str ) ;
<1> void lxc_cgroup_process_info_free_and_remove ( struct cgroup_process_info * info ) {\n<4> if ( ! info ) return ;\n<8> if ( ! mp ) mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ;\n<9> if ( mp ) ( void ) remove_cgroup ( mp , info -> cgroup_path , true ) ;\n<12> pp && * pp ;\n<15> info -> created_paths && pp >= info -> created_paths ;\n<16> -- pp ) {\n<17> free ( * pp ) ;\n<19> free ( info -> created_paths ) ;\n<20> lxc_cgroup_put_meta ( info -> meta_ref ) ;\n<21> free ( info -> cgroup_path ) ;\n<22> free ( info -> cgroup_path_sub ) ;\n<23> free ( info ) ;
<1> static void dumpglyph ( SplineChar * sc , struct glyphinfo * gi ) {\n<9> if ( sc -> layers [ gi -> layer ] . splines == NULL && sc -> layers [ gi -> layer ] . refs == NULL ) {\n<33> bp = malloc ( ptcnt * sizeof ( BasePoint ) ) ;\n<34> fs = malloc ( ptcnt ) ;\n<39> ptcnt = SSAddPoints ( ss , ptcnt , bp , fs ) ;\n<45> dumppointarrays ( gi , bp , fs , ptcnt ) ;\n<47> free ( bp ) ;\n<48> free ( fs ) ;
<1> static void config_setvar ( config_tree * ptree ) {\n<8> my_node != NULL ;\n<10> varlen = strlen ( my_node -> var ) ;\n<11> vallen = strlen ( my_node -> val ) ;\n<12> octets = varlen + vallen + 1 + 1 ;\n<14> snprintf ( str , octets , "%s=%s" , my_node -> var , my_node -> val ) ;\n<17> if ( str != NULL ) free ( str ) ;
<1> static int net_init_nic(QemuOpts *opts, const char *name, VLANState *vlan)\n<15> if (idx == -1 || nb_nics >= MAX_NICS) {\n<25> nd = &nd_table[idx];\n<29> memset(nd, 0, sizeof(*nd));\n<37> if (!nd->netdev) {\n<83> qemu_macaddr_default_if_unset(&nd->macaddr);\n<91> if (nd->nvectors != DEV_NVECTORS_UNSPECIFIED &&\n<93> (nd->nvectors < 0 || nd->nvectors > 0x7ffffff)) {\n<95> error_report("invalid # of vectors: %d", nd->nvectors);
<1> static int handle_metadata(RTMPContext *rt, RTMPPacket *pkt)\n<21> if ((ret = av_reallocp(&rt->flv_data, rt->flv_size)) < 0) {\n<33> p    = rt->flv_data + old_flv_size;\n<43> while (next - pkt->data < pkt->size - RTMP_HEADER) {\n<45> type = bytestream_get_byte(&next);\n<47> size = bytestream_get_be24(&next);\n<49> cts  = bytestream_get_be24(&next);\n<51> cts |= bytestream_get_byte(&next) << 24;\n<61> bytestream_put_byte(&p, type);\n<63> bytestream_put_be24(&p, size);\n<65> bytestream_put_be24(&p, ts);\n<67> bytestream_put_byte(&p, ts >> 24);\n<69> memcpy(p, next, size + 3 + 4);\n<71> next += size + 3 + 4;\n<73> p    += size + 3 + 4;\n<77> memcpy(p, next, RTMP_HEADER);
<1> void virtio_setup_block(struct subchannel_id schid)\n<41> if (run_ccw(schid, CCW_CMD_READ_CONF, &blk_cfg, sizeof(blk_cfg))) {\n<73> if (!virtio_ipl_disk_is_valid()) {\n<77> memset(&blk_cfg, 0, sizeof(blk_cfg));
<1> static int vc1_decode_intra_block(VC1Context *v, DCTELEM block[64], int n, int coded, int mquant, int codingset)\n<151> ac_val2 = ac_val;\n<161> ac_val -= 16;\n<165> ac_val -= 16 * s->block_wrap[n];\n<179> if(coded) {\n<293> memset(ac_val2, 0, 16 * 2);\n<297> if(use_pred) {\n<299> memcpy(ac_val2, ac_val, 8 * 2);\n<309> ac_val2[k] = (ac_val2[k] * q2 * vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<317> if(use_pred) {\n<319> memcpy(ac_val2 + 8, ac_val + 8, 8 * 2);\n<329> ac_val2[k + 8] = (ac_val2[k + 8] * q2 * vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<347> block[k << 3] = ac_val2[k] * scale;\n<359> block[k] = ac_val2[k + 8] * scale;
<1> static void vc1_sprite_flush(AVCodecContext *avctx)\n<27> for (i = 0; i < v->sprite_height>>!!plane; i++)\n<29> memset(f->data[plane] + i * f->linesize[plane],
<1> static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size)\n<13> int delayed_samples = s->delayed_samples;\n<292> for (i = 0; i < s->output_channels; i++) {\n<294> memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float));\n<298> s->redundancy_output[i] + 120,
<1> static int remoteStreamHandleAbort ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n<4> memset ( & rerr , 0 , sizeof rerr ) ;\n<8> if ( msg -> hdr . status == REMOTE_ERROR ) remoteDispatchFormatError ( & rerr , "%s" , _ ( "stream aborted at client request" ) ) ;\n<11> remoteDispatchFormatError ( & rerr , _ ( "stream aborted with unexpected status %d" ) , msg -> hdr . status ) ;\n<13> return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
<1> static void set_VD_bp ( unsigned char * bp , enum VD_type type , unsigned char ver ) {\n<2> bp [ 1 ] = ( unsigned char ) type ;\n<3> memcpy ( bp + 2 , "CD001" , 5 ) ;
<1> int bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,\n<163> if (qdict_size(reopen_state->options)) {\n<173> const char *new = qstring_get_str(new_obj);\n<195> if (!old || strcmp(new, old)) {\n<197> error_setg(errp, "Cannot change the option '%s'", entry->key);\n<199> ret = -EINVAL;\n<205> } while ((entry = qdict_next(reopen_state->options, entry)));
<1> static void test_bug13488 ( ) {\n<6> const char * query = "select * from t1 left join t2 on f1=f2 where f1=1" ;\n<18> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<31> check_execute ( stmt1 , rc ) ;\n<32> rc = mysql_stmt_prepare ( stmt1 , query , strlen ( query ) ) ;\n<33> check_execute ( stmt1 , rc ) ;\n<36> rc = mysql_stmt_bind_result ( stmt1 , my_bind ) ;
<1> static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) {\n<20> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<31> if ( archive_entry_filetype ( entry ) == AE_IFLNK ) {\n<37> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<38> if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) {\n<39> if ( errno == ENOMEM ) {\n<49> if ( namelength == 11 && strcmp ( ( const char * ) h , "TRAILER!!!" ) == 0 ) {\n<50> archive_clear_error ( & a -> archive ) ;\n<51> return ( ARCHIVE_EOF ) ;\n<53> if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) {
<1> static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n<59> if (offset > INT64_MAX - s->cluster_size) {\n<71> if (ret < 0) {\n<79> if (size < 0) {\n<109> if (cluster >= *nb_clusters) {\n<147> fprintf(stderr, "ERROR could not resize image: %s\n",\n<149> strerror(-ret));
<19> if ( intern -> u . dir . sub_path && intern -> u . dir . sub_path [ 0 ] ) {\n<23> subdir -> u . dir . sub_path_len = strlen ( intern -> u . dir . entry . d_name ) ;\n<24> subdir -> u . dir . sub_path = estrndup ( intern -> u . dir . entry . d_name , subdir -> u . dir . sub_path_len ) ;
<1> REGRESSION_TEST ( SDK_API_TSfopen ) ( RegressionTest * test , int , int * pstatus ) {\n<7> char input_buffer [ BUFSIZ ] ;\n<14> char input_file_full_path [ BUFSIZ ] ;\n<39> if ( ! ( write_file = TSfopen ( write_file_name , "w" ) ) ) {\n<48> memset ( input_buffer , '\0' , BUFSIZ ) ;\n<88> wrote = TSfwrite ( write_file , input_buffer , read_amount ) ;\n<151> read = TSfread ( cmp_read_file , cmp_buffer , read_amount ) ;\n<152> if ( read != read_amount ) {\n<169> if ( memcmp ( input_buffer , cmp_buffer , read_amount ) != 0 ) {\n<170> SDK_RPRINT ( test , "TSfread" , "TestCase2" , TC_FAIL , "reading error" ) ;\n<171> * pstatus = REGRESSION_TEST_FAILED ;\n<172> if ( source_read_file != nullptr ) {\n<175> if ( write_file != nullptr ) {\n<178> if ( cmp_read_file != nullptr ) {\n<181> return ;\n<184> SDK_RPRINT ( test , "TSfread" , "TestCase2" , TC_PASS , "ok" ) ;\n<186> if ( unlink ( write_file_name ) != 0 ) {\n<189> TSfclose ( source_read_file ) ;\n<190> SDK_RPRINT ( test , "TSfclose" , "TestCase1" , TC_PASS , "ok" ) ;\n<191> TSfclose ( write_file ) ;\n<192> SDK_RPRINT ( test , "TSfclose" , "TestCase2" , TC_PASS , "ok" ) ;\n<193> * pstatus = REGRESSION_TEST_PASSED ;\n<194> if ( cmp_read_file != nullptr ) {
<1> static AVStream * parse_media_type(AVFormatContext *s, AVStream *st, int sid,\n<13> if (!ff_guidcmp(subtype, mediasubtype_cpfilters_processed) &&\n<55> if (!st)\n<75> if (!memcmp(subtype + 4, (const uint8_t[]){MEDIASUBTYPE_BASE_GUID}, 12)) {\n<77> st->codec->codec_id = ff_wav_codec_get_id(AV_RL32(subtype), st->codec->bits_per_coded_sample);\n<79> } else if (!ff_guidcmp(subtype, mediasubtype_mpeg1payload)) {\n<105> if (!st)\n<133> if (!memcmp(subtype + 4, (const uint8_t[]){MEDIASUBTYPE_BASE_GUID}, 12)) {\n<135> st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, AV_RL32(subtype));\n<139> st->codec->codec_id = ff_codec_guid_get_id(video_guids, subtype);
<1> static void onenand_reset(OneNANDState *s, int cold)\n<5> memset(&s->addr, 0, sizeof(s->addr));\n<17> onenand_intr_update(s);\n<43> if (cold) {\n<47> memset(s->blockwp, ONEN_LOCK_LOCKED, s->blocks);
<1> void vncws_handshake_read(void *opaque)\n<37> if (handshake_end) {\n<43> buffer_advance(&vs->ws_input, handshake_end - vs->ws_input.buffer +\n<45> strlen(WS_HANDSHAKE_END));
<1> static int tree_content_get ( struct tree_entry * root , const char * p , struct tree_entry * leaf , int allow_root ) {\n<10> if ( ! n ) {\n<11> e = root ;\n<18> e = t -> entries [ i ] ;\n<20> if ( ! * slash1 ) goto found_entry ;\n<27> found_entry : memcpy ( leaf , e , sizeof ( * leaf ) ) ;\n<28> if ( e -> tree && is_null_sha1 ( e -> versions [ 1 ] . sha1 ) ) leaf -> tree = dup_tree_content ( e -> tree ) ;
<1> static int dtls1_process_out_of_seq_message ( SSL * s , const struct hm_header_st * msg_hdr , int * ok ) {\n<7> if ( ( msg_hdr -> frag_off + frag_len ) > msg_hdr -> msg_len ) goto err ;\n<8> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<11> item = pqueue_find ( s -> d1 -> buffered_messages , seq64be ) ;\n<13> if ( msg_hdr -> seq <= s -> d1 -> handshake_read_seq || msg_hdr -> seq > s -> d1 -> handshake_read_seq + 10 || item != NULL || ( s -> d1 -> handshake_read_seq == 0 && msg_hdr -> type == SSL3_MT_FINISHED ) ) {\n<22> if ( frag_len != msg_hdr -> msg_len ) return dtls1_reassemble_fragment ( s , msg_hdr , ok ) ;\n<25> if ( frag == NULL ) goto err ;\n<26> memcpy ( & ( frag -> msg_header ) , msg_hdr , sizeof ( * msg_hdr ) ) ;
<1> static void HtmlNPut ( char * * ppsz_html , const char * psz_text , int i_max ) {\n<3> if ( psz_html == NULL ) return ;\n<4> const size_t i_offset = strlen ( psz_html ) ;\n<5> const size_t i_len = strnlen ( psz_text , i_max ) ;\n<6> psz_html = realloc ( psz_html , i_offset + i_len + 1 ) ;\n<7> if ( psz_html != NULL ) {\n<8> memcpy ( psz_html + i_offset , psz_text , i_len ) ;\n<9> psz_html [ i_offset + i_len ] = '\0' ;\n<11> else free ( * ppsz_html ) ;
<1> static int doTest(uint8_t *ref[4], int refStride[4], int w, int h,\n<99> if (!srcContext) {\n<117> if (!dstContext) {\n<135> if (!outContext) {
<1> static void qemu_rdma_dump_id(const char *who, struct ibv_context *verbs)\n<9> if (ibv_query_port(verbs, 1, &port)) {\n<11> fprintf(stderr, "FAILED TO QUERY PORT INFORMATION!\n");\n<19> printf("%s RDMA Device opened: kernel name %s "\n<41> (port.link_layer == IBV_LINK_LAYER_INFINIBAND) ? "Infiniband" :\n<43> ((port.link_layer == IBV_LINK_LAYER_ETHERNET)
<1> void irc_ctcp_recv_dcc ( struct t_irc_server * server , const char * nick , const char * arguments , char * message ) {\n<8> if ( strncmp ( arguments , "SEND " , 5 ) == 0 ) {\n<9> arguments += 5 ;\n<10> while ( arguments [ 0 ] == ' ' ) {\n<11> arguments ++ ;\n<13> dcc_args = strdup ( arguments ) ;\n<14> if ( ! dcc_args ) {\n<23> if ( ! pos_size ) {\n<25> free ( dcc_args ) ;\n<35> if ( ! pos_port ) {\n<37> free ( dcc_args ) ;\n<47> if ( ! pos_addr ) {\n<49> free ( dcc_args ) ;\n<58> filename = irc_ctcp_dcc_filename_without_quotes ( pos_file ) ;\n<79> if ( filename ) free ( filename ) ;\n<80> free ( dcc_args ) ;\n<82> else if ( strncmp ( arguments , "RESUME " , 7 ) == 0 ) {\n<83> arguments += 7 ;\n<84> while ( arguments [ 0 ] == ' ' ) {\n<85> arguments ++ ;\n<87> dcc_args = strdup ( arguments ) ;\n<88> if ( ! dcc_args ) {\n<97> if ( ! pos_start_resume ) {\n<99> free ( dcc_args ) ;\n<109> if ( ! pos_port ) {\n<111> free ( dcc_args ) ;\n<120> filename = irc_ctcp_dcc_filename_without_quotes ( pos_file ) ;\n<136> if ( filename ) free ( filename ) ;\n<137> free ( dcc_args ) ;\n<139> else if ( strncmp ( arguments , "ACCEPT " , 7 ) == 0 ) {\n<140> arguments += 7 ;\n<141> while ( arguments [ 0 ] == ' ' ) {\n<142> arguments ++ ;\n<144> dcc_args = strdup ( arguments ) ;\n<145> if ( ! dcc_args ) {\n<154> if ( ! pos_start_resume ) {\n<156> free ( dcc_args ) ;\n<166> if ( ! pos_port ) {\n<168> free ( dcc_args ) ;\n<177> filename = irc_ctcp_dcc_filename_without_quotes ( pos_file ) ;\n<193> if ( filename ) free ( filename ) ;\n<194> free ( dcc_args ) ;\n<196> else if ( strncmp ( arguments , "CHAT " , 5 ) == 0 ) {\n<197> arguments += 5 ;\n<198> while ( arguments [ 0 ] == ' ' ) {\n<199> arguments ++ ;\n<201> dcc_args = strdup ( arguments ) ;\n<202> if ( ! dcc_args ) {\n<206> pos_file = dcc_args ;\n<207> while ( pos_file [ 0 ] == ' ' ) {\n<208> pos_file ++ ;\n<210> pos_addr = strchr ( pos_file , ' ' ) ;\n<211> if ( ! pos_addr ) {\n<213> free ( dcc_args ) ;\n<217> pos_addr ++ ;\n<218> while ( pos_addr [ 0 ] == ' ' ) {\n<219> pos_addr ++ ;\n<221> pos_port = strchr ( pos_addr , ' ' ) ;\n<222> if ( ! pos_port ) {\n<224> free ( dcc_args ) ;\n<232> if ( weechat_strcasecmp ( pos_file , "chat" ) != 0 ) {\n<234> free ( dcc_args ) ;\n<249> weechat_infolist_new_var_string ( item , "remote_address" , pos_addr ) ;\n<256> free ( dcc_args ) ;
<1> int64 fe_recvint64 ( char * buf ) {\n<5> memcpy ( & h32 , buf , 4 ) ;\n<6> memcpy ( & l32 , buf + 4 , 4 ) ;\n<7> h32 = ntohl ( h32 ) ;\n<8> l32 = ntohl ( l32 ) ;\n<9> result = h32 ;\n<11> result |= l32 ;
<1> static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n<13> if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n<15> return size;\n<21> D(qemu_log("ethlite lost packet %x\n", s->regs[R_RX_CTRL0]));\n<27> D(qemu_log("%s %zd rxbase=%x\n", __func__, size, rxbase));\n<33> memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n<37> s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n<41> eth_pulse_irq(s);\n<48> s->rxbuf ^= s->c_rx_pingpong;\n<50> return size;
<1> static PyObject * getServerPrincipalDetails ( PyObject * self , PyObject * args ) {\n<7> if ( result != NULL ) {\n<8> PyObject * pyresult = Py_BuildValue ( "s" , result ) ;\n<9> free ( result ) ;
<105> if ( oldpic -> data [ 1 ] ) memcpy ( newpic -> data [ 1 ] , oldpic -> data [ 1 ] , 256 * 4 ) ;
<1> CPUState *ppc440ep_init(ram_addr_t *ram_size, PCIBus **pcip,\n<29> if (!env) {\n<31> fprintf(stderr, "Unable to initialize CPU!\n");\n<57> memset(ram_bases, 0, sizeof(ram_bases));\n<59> memset(ram_sizes, 0, sizeof(ram_sizes));\n<61> *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n<97> if (!*pcip)\n<99> printf("couldn't create PCI controller!\n");
<1> static int qio_channel_websock_handshake_read(QIOChannelWebsock *ioc,\n<77> strlen(QIO_CHANNEL_WEBSOCK_HANDSHAKE_END));
<1> int gdev_pdf_get_param ( gx_device * dev , char * Param , void * list ) {\n<6> for ( pi = pdf_param_items ;\n<7> pi -> key != 0 ;\n<8> ++ pi ) {\n<9> if ( strcmp ( pi -> key , Param ) == 0 ) {\n<10> const char * key = pi -> key ;\n<11> const void * pvalue = ( const void * ) ( ( const char * ) pdev + pi -> offset ) ;\n<12> int size = xfer_item_sizes [ pi -> type ] ;\n<14> memcpy ( & typed . value , pvalue , size ) ;\n<15> typed . type = pi -> type ;\n<16> code = ( * plist -> procs -> xmit_typed ) ( plist , key , & typed ) ;\n<17> return code ;\n<20> if ( strcmp ( Param , "CoreDistVersion" ) == 0 ) {\n<21> return ( param_write_int ( plist , "CoreDistVersion" , & CoreDistVersion ) ) ;\n<23> if ( strcmp ( Param , "CompatibilityLevel" ) == 0 ) {\n<24> float f = pdev -> CompatibilityLevel ;\n<25> return ( param_write_float ( plist , "CompatibilityLevel" , & f ) ) ;\n<27> if ( strcmp ( Param , "ForOPDFRead" ) == 0 ) {\n<28> return ( param_write_bool ( plist , "ForOPDFRead" , & pdev -> ForOPDFRead ) ) ;\n<30> if ( ! pdev -> is_ps2write ) {\n<31> if ( strcmp ( Param , "pdfmark" ) == 0 ) {\n<32> return ( param_write_null ( plist , "pdfmark" ) ) ;\n<34> if ( strcmp ( Param , "DSC" ) == 0 ) {\n<35> return ( param_write_null ( plist , "DSC" ) ) ;\n<38> return gdev_psdf_get_param ( dev , Param , list ) ;
<1> static void xml_start_tag ( void * userData , const char * name , const char * * atts ) {\n<2> struct xml_ctx * ctx = ( struct xml_ctx * ) userData ;\n<3> const char * c = strchr ( name , ':' ) ;\n<5> if ( c == NULL ) c = name ;\n<6> else c ++ ;\n<7> old_namelen = strlen ( ctx -> name ) ;\n<8> new_len = old_namelen + strlen ( c ) + 2 ;\n<9> if ( new_len > ctx -> len ) {\n<10> ctx -> name = xrealloc ( ctx -> name , new_len ) ;\n<13> xsnprintf ( ctx -> name + old_namelen , ctx -> len - old_namelen , ".%s" , c ) ;\n<14> free ( ctx -> cdata ) ;\n<16> ctx -> userFunc ( ctx , 0 ) ;
<1> gpg_error_t keydb_search_first ( KEYDB_HANDLE hd ) {\n<4> memset ( & desc , 0 , sizeof desc ) ;\n<6> err = keydb_search ( hd , & desc , 1 , NULL ) ;
<1> static void test_select ( ) {\n<26> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<36> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static int drive_add(const char *file, const char *fmt, ...)\n<11> if (nb_drives_opt >= MAX_DRIVES || index == -1) {\n<13> fprintf(stderr, "qemu: too many drives\n");\n<23> va_start(ap, fmt);\n<29> va_end(ap);
<1> static void check_matching ( void ) {\n<9> if ( ! name ) fail ( "curve name not found for sample_key_1\n" ) ;\n<10> else if ( strcmp ( name , sample_key_1_curve ) ) fail ( "expected curve name %s but got %s for sample_key_1\n" , sample_key_1_curve , name ) ;\n<11> else if ( nbits != sample_key_1_nbits ) fail ( "expected curve size %u but got %u for sample_key_1\n" , sample_key_1_nbits , nbits ) ;\n<16> if ( ! name ) fail ( "curve name not found for sample_key_2\n" ) ;\n<17> else if ( strcmp ( name , sample_key_2_curve ) ) fail ( "expected curve name %s but got %s for sample_key_2\n" , sample_key_2_curve , name ) ;\n<18> else if ( nbits != sample_key_2_nbits ) fail ( "expected curve size %u but got %u for sample_key_2\n" , sample_key_2_nbits , nbits ) ;
<1> int main ( int argc , char * * argv ) {\n<6> if ( argc == 2 && ! strcmp ( argv [ 1 ] , "--to-str" ) ) {\n<7> fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n<8> if ( ! feof ( stdin ) ) fail ( "read error or input too large" ) ;\n<9> fail ( "not yet implemented" ) ;\n<11> else if ( argc == 2 && ! strcmp ( argv [ 1 ] , "--to-der" ) ) {\n<12> fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n<13> if ( ! feof ( stdin ) ) fail ( "read error or input too large" ) ;\n<14> err = ksba_dn_str2der ( inputbuf , & buf , & len ) ;\n<15> fail_if_err ( err ) ;\n<16> fwrite ( buf , len , 1 , stdout ) ;\n<18> else if ( argc == 1 ) {\n<24> fprintf ( stderr , "usage: t-dnparser [--to-str|--to-der]\n" ) ;\n<27> return 0 ;
<1> static int h263_decode_frame(AVCodecContext *avctx,\n<5> UINT8 *buf, int buf_size)\n<41> init_get_bits(&s->gb, s->bitstream_buffer, s->bitstream_buffer_size);\n<45> init_get_bits(&s->gb, buf, buf_size);\n<119> MPV_frame_start(s);\n<155> s->first_gob_line = h263_decode_gob_header(s);\n<173> for(s->mb_x=0; s->mb_x < s->mb_width; s->mb_x++) {\n<225> if (msmpeg4_decode_mb(s, s->block) < 0) {\n<227> fprintf(stderr,"\nError at MB: %d\n", (s->mb_y * s->mb_width) + s->mb_x);\n<235> if (h263_decode_mb(s, s->block) < 0) {\n<237> fprintf(stderr,"\nError at MB: %d\n", (s->mb_y * s->mb_width) + s->mb_x);\n<245> MPV_decode_mb(s, s->block);\n<297> if(msmpeg4_decode_ext_header(s, buf_size) < 0) return -1;\n<307> if(   buf_size - current_pos > 5\n<309> && buf_size - current_pos < BITSTREAM_BUFFER_SIZE){\n<311> memcpy(s->bitstream_buffer, buf + current_pos, buf_size - current_pos);\n<323> MPV_frame_end(s);
<1> static int mjpeg_decode_init(AVCodecContext *avctx)\n<17> memset(&s2, 0, sizeof(MpegEncContext));\n<25> DCT_common_init(&s2);\n<29> s->scantable= s2.intra_scantable;
<1> static void arm_cpu_reset(CPUState *s)\n<9> CPUARMState *env = &cpu->env;\n<17> memset(env, 0, offsetof(CPUARMState, end_reset_fields));\n<43> if (arm_feature(env, ARM_FEATURE_IWMMXT)) {
<1> static void do_video_out(AVFormatContext *s,\n<19> UINT8 *buf = NULL, *buf1 = NULL;\n<49> if (do_deinterlace) {\n<57> size = avpicture_get_size(dec->pix_fmt, dec->width, dec->height);\n<59> buf1 = malloc(size);\n<61> if (!buf1)\n<69> avpicture_fill(picture2, buf1, dec->pix_fmt, dec->width, dec->height);\n<79> free(buf1);\n<81> buf1 = NULL;\n<97> if (enc->pix_fmt != dec->pix_fmt) {\n<105> size = avpicture_get_size(enc->pix_fmt, dec->width, dec->height);\n<107> buf = malloc(size);\n<109> if (!buf)\n<115> avpicture_fill(pict, buf, enc->pix_fmt, dec->width, dec->height);\n<125> fprintf(stderr, "pixel format conversion not handled\n");\n<195> if (buf)\n<197> free(buf);\n<199> if (buf1)\n<201> free(buf1);
<1> static ssize_t sdp_svc_search_attr_get(struct bt_l2cap_sdp_state_s *sdp,\n<37> seqlen = sdp_datalen(&req, &len);\n<49> if (sdp_svc_match(sdp, &req, &seqlen))\n<53> } else if (sdp_svc_match(sdp, &req, &seqlen))\n<63> max = (req[0] << 8) | req[1];\n<65> req += 2;\n<75> if ((*req & ~SDP_DSIZE_MASK) == SDP_DTYPE_SEQ) {\n<77> seqlen = sdp_datalen(&req, &len);\n<89> if (sdp_svc_attr_match(sdp, &req, &seqlen))\n<93> } else if (sdp_svc_attr_match(sdp, &req, &seqlen))\n<107> if (len <= sizeof(int))\n<113> memcpy(&start, req + 1, sizeof(int));\n<137> lst = rsp + 2;\n<141> len = 3 - start;\n<157> if (len >= 0)\n<159> if (len + record->attribute_list[j].len < max) {\n<161> memcpy(lst + len, record->attribute_list[j].pair,\n<165> end = len + record->attribute_list[j].len;\n<169> len += record->attribute_list[j].len;\n<179> lst[seqlen - 3] = SDP_DTYPE_SEQ | SDP_DSIZE_NEXT2;\n<181> lst[seqlen - 2] = (len - seqlen) >> 8;\n<183> lst[seqlen - 1] = (len - seqlen) & 0xff;\n<189> if (len == 3 - start)\n<193> else if (0 >= start) {\n<195> lst[0] = SDP_DTYPE_SEQ | SDP_DSIZE_NEXT2;\n<197> lst[1] = (len + start - 3) >> 8;\n<199> lst[2] = (len + start - 3) & 0xff;\n<211> if (end < len) {\n<213> len = end + start;\n<215> lst[end ++] = sizeof(int);\n<217> memcpy(lst + end, &len, sizeof(int));
<1> void really_die ( const char * msg ) {\n<4> fprintf ( stderr , "%s" , msg ) ;\n<5> fflush ( stderr ) ;
<1> static int opt_new_stream(const char *opt, const char *arg)\n<7> if (nb_output_files <= 0) {\n<9> fprintf(stderr, "At least one output file must be specified\n");\n<19> if      (!strcmp(opt, "newvideo"   )) new_video_stream   (oc);\n<21> else if (!strcmp(opt, "newaudio"   )) new_audio_stream   (oc);\n<23> else if (!strcmp(opt, "newsubtitle")) new_subtitle_stream(oc);\n<25> else av_assert0(0);
<1> static int64_t get_pts(const char **buf, int *duration,\n<3> int32_t *x1, int32_t *y1, int32_t *x2, int32_t *y2)\n<11> for (i=0; i<2; i++) {\n<17> if (sscanf(*buf, "%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d"\n<27> int64_t start = (hh1*3600LL + mm1*60LL + ss1) * 1000LL + ms1;\n<29> int64_t end   = (hh2*3600LL + mm2*60LL + ss2) * 1000LL + ms2;\n<31> *duration = end - start;\n<33> *buf += strcspn(*buf, "\n") + 1;\n<35> return start;\n<39> *buf += strcspn(*buf, "\n") + 1;
<1> int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples)\n<7> short *bufin[2];\n<11> short *buftmp2[2], *buftmp3[2];\n<19> if (s->input_channels == s->output_channels && s->ratio == 1.0 && 0) {\n<23> memcpy(output, input, nb_samples * s->input_channels * sizeof(short));\n<81> input  = s->buffer[0];\n<125> for(i=0; i<s->filter_channels; i++){\n<127> bufin[i]= av_malloc( (nb_samples + s->temp_len) * sizeof(short) );\n<129> memcpy(bufin[i], s->temp[i], s->temp_len * sizeof(short));\n<131> buftmp2[i] = bufin[i] + s->temp_len;\n<153> } else if (s->output_channels >= 2 && s->input_channels == 1) {\n<157> memcpy(buftmp2[0], input, nb_samples*sizeof(short));\n<159> } else if (s->output_channels >= 2) {\n<171> memcpy(buftmp2[0], input, nb_samples*sizeof(short));\n<185> for(i=0;i<s->filter_channels;i++) {\n<193> nb_samples1 = av_resample(s->resample_context, buftmp3[i], bufin[i], &consumed, nb_samples, lenout, is_last);\n<195> s->temp_len= nb_samples - consumed;\n<197> s->temp[i]= av_realloc(s->temp[i], s->temp_len*sizeof(short));\n<199> memcpy(s->temp[i], bufin[i] + consumed, s->temp_len*sizeof(short));\n<249> av_free(bufin[i]);
<1> static int calculate_nss_hash ( struct crypto_instance * instance , const unsigned char * buf , const size_t buf_len , unsigned char * hash ) {\n<23> if ( PK11_DigestFinal ( hash_context , hash_block , & hash_tmp_outlen , hash_block_len [ instance -> crypto_hash_type ] ) != SECSuccess ) {\n<27> memcpy ( hash , hash_block , hash_len [ instance -> crypto_hash_type ] ) ;
<1> static void usage ( ) {\n<3> fprintf ( stderr , "Usage: %s [-v] [-h] [-c] [-s] [-f] [-D] [-u user] " "[-t chrootdir] [-d device] [-m mtu] [-z context] " "[-l ip address to listen on] [-p port] [-n external ip] " "[-b dnsport] [-P password] [-F pidfile] [-i max idle time] " "tunnel_ip[etmask] topdomain\n" , __progname ) ;
<1> static int xen_remove_from_physmap(XenIOState *state,\n<21> if (physmap == NULL) {\n<47> for (i = 0; i < size; i++) {\n<73> if (state->log_for_dirtybit == physmap) {\n<79> free(physmap);
<1> int qcrypto_cipher_setiv(QCryptoCipher *cipher,\n<3> const uint8_t *iv, size_t niv,\n<9> QCryptoCipherNettle *ctx = cipher->opaque;\n<11> if (niv != ctx->niv) {\n<21> memcpy(ctx->iv, iv, niv);
<1> static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n<5> if ( ! tmp || ! * tmp ) {\n<10> if ( strstr ( tmp , "\\" ) ) {\n<11> put_info ( "DELIMITER cannot contain a backslash character" , INFO_ERROR ) ;\n<12> return 0 ;\n<15> strmake_buf ( delimiter , tmp ) ;\n<16> delimiter_length = ( int ) strlen ( delimiter ) ;\n<17> delimiter_str = delimiter ;\n<18> return 0 ;
<1> static void pmt_cb(MpegTSFilter *filter, const uint8_t *section, int section_len)\n<21> char language[4] = {0}; /* initialize to kill warnings */\n<87> st = 0;\n<167> language[1] = get8(&p, desc_end);\n<169> language[2] = get8(&p, desc_end);\n<171> language[3] = 0;\n<187> language[1] = get8(&p, desc_end);\n<189> language[2] = get8(&p, desc_end);\n<191> language[3] = 0;\n<251> st= pes->st;\n<259> st = new_pes_av_stream(pes, 0);\n<283> if (language[0] != 0) {\n<285> memcpy(st->language, language, 4);
<1> static void default_print_section_header ( WriterContext * wctx ) {\n<12> if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "[%s]\n" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;
<1> void bitmap_writer_finish ( struct pack_idx_entry * * index , uint32_t index_nr , const char * filename , uint16_t options ) {\n<10> memcpy ( header . magic , BITMAP_IDX_SIGNATURE , sizeof ( BITMAP_IDX_SIGNATURE ) ) ;\n<15> sha1write ( f , & header , sizeof ( header ) ) ;
<1> void http_post_cb ( struct evhttp_request * req , void * arg ) {\n<4> if ( req -> type != EVHTTP_REQ_POST ) {\n<5> fprintf ( stdout , "FAILED (post type)\n" ) ;\n<8> if ( EVBUFFER_LENGTH ( req -> input_buffer ) != strlen ( POST_DATA ) ) {\n<9> fprintf ( stdout , "FAILED (length: %zu vs %zu)\n" , EVBUFFER_LENGTH ( req -> input_buffer ) , strlen ( POST_DATA ) ) ;\n<12> if ( memcmp ( EVBUFFER_DATA ( req -> input_buffer ) , POST_DATA , strlen ( POST_DATA ) ) ) {\n<13> fprintf ( stdout , "FAILED (data)\n" ) ;\n<14> fprintf ( stdout , "Got :%s\n" , EVBUFFER_DATA ( req -> input_buffer ) ) ;\n<15> fprintf ( stdout , "Want:%s\n" , POST_DATA ) ;\n<16> exit ( 1 ) ;
<1> hb_bool_t _hb_graphite2_shape ( hb_shape_plan_t * shape_plan , hb_font_t * font , hb_buffer_t * buffer , const hb_feature_t * features , unsigned int num_features ) {\n<5> const char * lang = hb_language_to_string ( hb_buffer_get_language ( buffer ) ) ;\n<6> const char * lang_end = lang ? strchr ( lang , '-' ) : NULL ;\n<7> int lang_len = lang_end ? lang_end - lang : - 1 ;
<1> static int read_header(FFV1Context *f)\n<13> memset(state, 128, sizeof(state));\n<21> unsigned v= get_symbol(c, state, 0);\n<267> context_count = read_quant_tables(c, f->quant_table);\n<279> f->slice_count = get_symbol(c, state, 0);\n<331> fs->slice_x      =  get_symbol(c, state, 0)      * f->width ;\n<367> PlaneContext *const p = &fs->plane[i];\n<371> if (f->version == 2) {\n<373> int idx = get_symbol(c, state, 0);\n<375> if (idx > (unsigned)f->quant_table_count) {\n<395> memcpy(p->quant_table, f->quant_table, sizeof(p->quant_table));
<1> SplineChar * PSCharStringToSplines ( uint8 * type1 , int len , struct pscontext * context , struct pschars * subrs , struct pschars * gsubrs , const char * name ) {\n<28> HintMask * counters [ 96 ] ;\n<32> if ( ! is_type2 && context -> instance_count > 1 ) memset ( unblended , 0 , sizeof ( unblended ) ) ;\n<46> if ( ( v = * type1 ++ ) >= 32 ) {\n<47> if ( v <= 246 ) {\n<50> else if ( v <= 250 ) {\n<54> else if ( v <= 254 ) {\n<59> if ( len < 4 ) {\n<891> if ( cp != 0 ) {\n<893> ret -> countermasks = malloc ( cp * sizeof ( HintMask ) ) ;\n<896> i < cp ;\n<898> memcpy ( & ret -> countermasks [ i ] , counters [ i ] , sizeof ( HintMask ) ) ;\n<899> chunkfree ( counters [ i ] , sizeof ( HintMask ) ) ;\n<919> SCGuessHHintInstancesList ( ret , ly_fore ) ;\n<920> SCGuessVHintInstancesList ( ret , ly_fore ) ;\n<923> if ( context -> instance_count == 1 && ! ret -> hconflicts && ! ret -> vconflicts ) SCClearHintMasks ( ret , ly_fore , false ) ;\n<924> HintsRenumber ( ret ) ;\n<925> if ( name != NULL && strcmp ( name , ".notdef" ) != 0 ) ret -> widthset = true ;\n<926> return ( ret ) ;
<1> int send_xmessage_using_uids ( struct proclistlist * pll , char * message ) {\n<4> int * uids = get_userlist ( pll , & num_users ) ;\n<6> lokke < num_users ;\n<8> char xauthpath [ 5000 ] ;\n<9> struct passwd * pass = getpwuid ( uids [ lokke ] ) ;\n<10> sprintf ( xauthpath , "%s/.Xauthority" , pass -> pw_dir ) ;\n<11> if ( send_xmessage ( xauthpath , message ) == 1 ) {\n<12> free ( uids ) ;\n<16> free ( uids ) ;
<1> xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {\n<3> if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {\n<7> memset ( l , 0 , sizeof ( xmlList ) ) ;\n<10> xmlFree ( l ) ;\n<13> l -> sentinel -> next = l -> sentinel ;\n<14> l -> sentinel -> prev = l -> sentinel ;\n<19> return l ;
<1> static void mips_fulong2e_init ( QEMUMachineInitArgs * args ) {\n<26> if ( cpu == NULL ) {\n<27> fprintf ( stderr , "Unable to find CPU definition\n" ) ;\n<53> filename = qemu_find_file ( QEMU_FILE_TYPE_BIOS , bios_name ) ;\n<61> if ( ( bios_size < 0 || bios_size > BIOS_SIZE ) && ! kernel_filename ) {\n<62> fprintf ( stderr , "qemu: Could not load MIPS bios '%s'\n" , bios_name ) ;\n<71> if ( ! isa_bus ) {\n<72> fprintf ( stderr , "vt82c686b_init error\n" ) ;
<1> static CURLcode AddFormDataf ( struct FormData * * formp , curl_off_t * size , const char * fmt , ... ) {\n<4> va_start ( ap , fmt ) ;\n<5> vsnprintf ( s , sizeof ( s ) , fmt , ap ) ;\n<6> va_end ( ap ) ;\n<7> return AddFormData ( formp , FORM_DATA , s , 0 , size ) ;
<11> if ( uwsgi_parse_vars ( wsgi_req ) ) {\n<16> if ( uphp . docroot ) {\n<17> wsgi_req -> document_root = uphp . docroot ;\n<19> else if ( ! wsgi_req -> document_root_len ) {\n<20> wsgi_req -> document_root = uwsgi . cwd ;\n<24> if ( ! uwsgi_expand_path ( wsgi_req -> document_root , wsgi_req -> document_root_len , sanitized_docroot ) ) {\n<28> wsgi_req -> document_root = sanitized_docroot ;\n<30> wsgi_req -> document_root_len = strlen ( wsgi_req -> document_root ) ;
<1> static gboolean logcat_dump_text ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err ) {\n<29> if ( pseudo_header -> logcat . version == 1 ) {\n<31> tag = log_entry -> msg + 1 ;\n<32> msg_pre_skip = 1 + strlen ( tag ) + 1 ;\n<33> msg_begin = log_entry -> msg + msg_pre_skip ;\n<35> else if ( pseudo_header -> logcat . version == 2 ) {\n<37> tag = log_entry_v2 -> msg + 1 ;\n<38> msg_pre_skip = 1 + strlen ( tag ) + 1 ;\n<39> msg_begin = log_entry_v2 -> msg + msg_pre_skip ;\n<45> log = g_strndup ( msg_begin , payload_length - msg_pre_skip ) ;\n<48> log_part = log_next ;\n<49> if ( dumper -> type == DUMP_LONG ) {\n<53> log_next = strchr ( log_part , '\n' ) ;\n<54> if ( log_next != NULL ) {\n<62> buf = logcat_log ( dumper , seconds , milliseconds , pid , tid , priority , tag , log_part ) ;\n<63> if ( ! buf ) {\n<67> length = ( guint32 ) strlen ( buf ) ;\n<68> if ( ! wtap_dump_file_write ( wdh , buf , length , err ) ) {
<1> static int smacker_decode_header_tree(SmackVContext *smk, GetBitContext *gb, int **recodes, int *last, int size)\n<6> VLC vlc[2];\n<21> memset(&vlc[0], 0, sizeof(VLC));\n<22> memset(&vlc[1], 0, sizeof(VLC));\n<53> ctx.v1 = &vlc[0];\n<54> ctx.v2 = &vlc[1];\n<69> free_vlc(&vlc[0]);\n<71> free_vlc(&vlc[1]);
<1> void http_request_empty_done ( struct evhttp_request * req , void * arg ) {\n<2> if ( req -> response_code != HTTP_OK ) {\n<3> fprintf ( stderr , "FAILED\n" ) ;\n<6> if ( evhttp_find_header ( req -> input_headers , "Date" ) == NULL ) {\n<7> fprintf ( stderr , "FAILED\n" ) ;\n<10> if ( evhttp_find_header ( req -> input_headers , "Content-Length" ) == NULL ) {\n<11> fprintf ( stderr , "FAILED\n" ) ;\n<14> if ( strcmp ( evhttp_find_header ( req -> input_headers , "Content-Length" ) , "0" ) ) {\n<15> fprintf ( stderr , "FAILED\n" ) ;\n<16> exit ( 1 ) ;\n<18> if ( EVBUFFER_LENGTH ( req -> input_buffer ) != 0 ) {\n<19> fprintf ( stderr , "FAILED\n" ) ;
<1> int tls1_enc ( SSL * s , SSL3_RECORD * recs , unsigned int n_recs , int send ) {\n<4> unsigned char buf [ SSL_MAX_PIPELINES ] [ EVP_AEAD_TLS1_AAD_LEN ] ;\n<47> ctr < n_recs ;\n<49> memmove ( recs [ ctr ] . data , recs [ ctr ] . input , recs [ ctr ] . length ) ;\n<50> recs [ ctr ] . input = recs [ ctr ] . data ;\n<68> seq = send ? RECORD_LAYER_get_write_sequence ( & s -> rlayer ) : RECORD_LAYER_get_read_sequence ( & s -> rlayer ) ;\n<69> if ( SSL_IS_DTLS ( s ) ) {\n<70> unsigned char dtlsseq [ 9 ] , * p = dtlsseq ;\n<71> s2n ( send ? DTLS_RECORD_LAYER_get_w_epoch ( & s -> rlayer ) : DTLS_RECORD_LAYER_get_r_epoch ( & s -> rlayer ) , p ) ;\n<72> memcpy ( p , & seq [ 2 ] , 6 ) ;\n<73> memcpy ( buf [ ctr ] , dtlsseq , 8 ) ;\n<76> memcpy ( buf [ ctr ] , seq , 8 ) ;\n<80> ++ seq [ i ] ;\n<81> if ( seq [ i ] != 0 ) break ;\n<84> buf [ ctr ] [ 8 ] = recs [ ctr ] . type ;\n<85> buf [ ctr ] [ 9 ] = ( unsigned char ) ( s -> version >> 8 ) ;\n<86> buf [ ctr ] [ 10 ] = ( unsigned char ) ( s -> version ) ;\n<87> buf [ ctr ] [ 11 ] = recs [ ctr ] . length >> 8 ;\n<88> buf [ ctr ] [ 12 ] = recs [ ctr ] . length & 0xff ;\n<89> pad = EVP_CIPHER_CTX_ctrl ( ds , EVP_CTRL_AEAD_TLS1_AAD , EVP_AEAD_TLS1_AAD_LEN , buf [ ctr ] ) ;
<1> static int matroska_parse_tracks(AVFormatContext *s)\n<19> MatroskaTrack *track = &tracks[i];\n<31> int extradata_offset = 0;\n<63> if (!track->codec_id)\n<185> int ret = matroska_decode_buffer(&track->codec_priv.data,\n<205> if (codec_priv != track->codec_priv.data)\n<215> for (j = 0; ff_mkv_codec_tags[j].id != AV_CODEC_ID_NONE; j++) {\n<217> if (!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n<219> strlen(ff_mkv_codec_tags[j].str))) {\n<233> if (!st) {\n<255> if (!strcmp(track->codec_id, "V_MS/VFW/FOURCC") &&\n<257> track->codec_priv.size >= 40               &&\n<259> track->codec_priv.data) {\n<261> track->ms_compat    = 1;\n<263> bit_depth           = AV_RL16(track->codec_priv.data + 14);\n<265> fourcc              = AV_RL32(track->codec_priv.data + 16);\n<267> codec_id            = ff_codec_get_id(ff_codec_bmp_tags,\n<271> if (!codec_id)\n<277> extradata_offset    = 40;\n<279> } else if (!strcmp(track->codec_id, "A_MS/ACM") &&\n<281> track->codec_priv.size >= 14         &&\n<283> track->codec_priv.data) {\n<287> ffio_init_context(&b, track->codec_priv.data,\n<289> track->codec_priv.size,\n<293> ret = ff_get_wav_header(s, &b, st->codecpar, track->codec_priv.size, 0);\n<295> if (ret < 0)\n<303> extradata_offset = FFMIN(track->codec_priv.size, 18);\n<305> } else if (!strcmp(track->codec_id, "A_QUICKTIME")\n<309> && (track->codec_priv.size >= 32)\n<311> && (track->codec_priv.data)) {\n<315> int ret = get_qt_codec(track, &fourcc, &codec_id);\n<317> if (ret < 0)\n<349> } else if (!strcmp(track->codec_id, "V_QUICKTIME") &&\n<351> (track->codec_priv.size >= 21)          &&\n<353> (track->codec_priv.data)) {\n<355> int ret = get_qt_codec(track, &fourcc, &codec_id);\n<357> if (ret < 0)\n<395> } else if (codec_id == AV_CODEC_ID_PCM_S16BE) {\n<419> } else if (codec_id == AV_CODEC_ID_PCM_S16LE) {\n<451> int profile = matroska_aac_profile(track->codec_id);\n<457> if (!extradata)\n<465> if (strstr(track->codec_id, "SBR")) {\n<467> sri            = matroska_aac_sri(track->audio.out_samplerate);\n<469> extradata[2]   = 0x56;\n<471> extradata[3]   = 0xE5;\n<473> extradata[4]   = 0x80 | (sri << 3);\n<475> extradata_size = 5;\n<479> extradata_size = 2;\n<481> } else if (codec_id == AV_CODEC_ID_ALAC && track->codec_priv.size && track->codec_priv.size < INT_MAX - 12 - AV_INPUT_BUFFER_PADDING_SIZE) {\n<495> if (!extradata)\n<499> AV_WB32(extradata, extradata_size);\n<501> memcpy(&extradata[4], "alac", 4);\n<503> AV_WB32(&extradata[8], 0);\n<515> if (!extradata)\n<519> ffio_init_context(&b, extradata, extradata_size, 1,\n<539> av_freep(&extradata);\n<555> if (track->audio.out_samplerate < 0 || track->audio.out_samplerate > INT_MAX)\n<575> extradata_offset = 26;\n<577> } else if (codec_id == AV_CODEC_ID_RA_144) {\n<633> if (!track->audio.buf)\n<657> extradata_offset       = 78;\n<661> } else if (codec_id == AV_CODEC_ID_FLAC && track->codec_priv.size) {\n<663> ret = matroska_parse_flac(s, track, &extradata_offset);\n<665> if (ret < 0)\n<675> track->codec_priv.size -= extradata_offset;\n<679> if (codec_id == AV_CODEC_ID_NONE)\n<687> if (track->time_scale < 0.01)\n<691> avpriv_set_pts_info(st, 64, matroska->time_scale * track->time_scale,\n<693> 1000 * 1000 * 1000);    /* 64 bit pts in ns */\n<699> track->codec_delay_in_track_tb = av_rescale_q(track->codec_delay,\n<701> (AVRational){ 1, 1000000000 },\n<703> st->time_base);\n<707> st->codecpar->codec_id = codec_id;\n<711> if (strcmp(track->language, "und"))\n<713> av_dict_set(&st->metadata, "language", track->language, 0);\n<715> av_dict_set(&st->metadata, "title", track->name, 0);\n<719> if (track->flag_default)\n<723> if (track->flag_forced)\n<729> if (!st->codecpar->extradata) {\n<733> st->codecpar->extradata      = extradata;\n<737> } else if (track->codec_priv.data && track->codec_priv.size > 0) {\n<739> if (ff_alloc_extradata(st->codecpar, track->codec_priv.size))\n<895> ret = mkv_parse_video_color(st, track);\n<901> ret = mkv_parse_video_projection(st, track);\n<951> } else if (codec_id == AV_CODEC_ID_WEBVTT) {\n<957> if (!strcmp(track->codec_id, "D_WEBVTT/CAPTIONS")) {\n<959> st->disposition |= AV_DISPOSITION_CAPTIONS;\n<961> } else if (!strcmp(track->codec_id, "D_WEBVTT/DESCRIPTIONS")) {\n<963> st->disposition |= AV_DISPOSITION_DESCRIPTIONS;\n<965> } else if (!strcmp(track->codec_id, "D_WEBVTT/METADATA")) {\n<967> st->disposition |= AV_DISPOSITION_METADATA;
<1> static void a15_daughterboard_init(const VexpressMachineState *vms,\n<39> if (rsz > (30ULL * 1024 * 1024 * 1024)) {\n<41> fprintf(stderr, "vexpress-a15: cannot model more than 30GB RAM\n");
<1> static void test_bug31669 ( ) {\n<20> memset ( buff , 'a' , sizeof ( buff ) ) ;\n<21> buff [ sizeof ( buff ) - 1 ] = '\0' ;\n<32> memset ( user , 'b' , sizeof ( user ) ) ;\n<34> memset ( buff , 'c' , sizeof ( buff ) ) ;\n<36> strxmov ( query , "GRANT ALL PRIVILEGES ON *.* TO '" , user , "'@'%' IDENTIFIED BY " "'" , buff , "' WITH GRANT OPTION" , NullS ) ;
<1> static void vga_draw_graphic(VGAState *s, int full_update)\n<171> depth = s->get_bpp(s);\n<241> s->cursor_invalidate(s);\n<315> update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n<333> vga_draw_line(s, d, s->vram_ptr + addr, width);\n<337> s->cursor_draw_line(s, d, y);\n<405> memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);
<1> static int oma_read_header(AVFormatContext *s)\n<25> ret = avio_read(s->pb, buf, EA3_HEADER_SIZE);\n<27> if (ret < EA3_HEADER_SIZE)\n<33> if (memcmp(buf, ((const uint8_t[]){'E', 'A', '3'}), 3) ||\n<35> buf[4] != 0 || buf[5] != EA3_HEADER_SIZE) {\n<37> av_log(s, AV_LOG_ERROR, "Couldn't find the EA3 header !\n");\n<39> return AVERROR_INVALIDDATA;\n<45> oc->content_start = avio_tell(s->pb);\n<51> eid = AV_RB16(&buf[6]);\n<53> if (eid != -1 && eid != -128 && decrypt_init(s, extra_meta, buf) < 0) {\n<67> codec_params = AV_RB24(&buf[33]);\n<83> st->codecpar->codec_tag  = buf[32];\n<233> av_log(s, AV_LOG_ERROR, "Unsupported codec %d!\n", buf[32]);
<1> static void nvram_init ( M48t59State * nvram , uint8_t * macaddr , const char * cmdline , const char * boot_devices , ram_addr_t RAM_size , uint32_t kernel_size , int width , int height , int depth , int nvram_machine_id , const char * arch ) {\n<6> memset ( image , '\0' , sizeof ( image ) ) ;\n<8> part_header = ( struct OpenBIOS_nvpart_v1 * ) & image [ start ] ;\n<14> i ++ ) end = OpenBIOS_set_var ( image , end , prom_envs [ i ] ) ;\n<19> part_header = ( struct OpenBIOS_nvpart_v1 * ) & image [ start ] ;\n<24> Sun_init_header ( ( struct Sun_nvram * ) & image [ 0x1fd8 ] , macaddr , nvram_machine_id ) ;
<1> static int block_load(QEMUFile *f, void *opaque, int version_id)\n<27> addr >>= BDRV_SECTOR_BITS;\n<41> device_name[len] = '\0';\n<45> bs = bdrv_find(device_name);\n<47> if (!bs) {\n<49> fprintf(stderr, "Error unknown block device %s\n",\n<77> } else if (flags & BLK_MIG_FLAG_PROGRESS) {\n<79> if (!banner_printed) {\n<81> printf("Receiving block device images\n");\n<93> } else if (!(flags & BLK_MIG_FLAG_EOS)) {\n<95> fprintf(stderr, "Unknown flags\n");
<1> static void vc1_decode_i_blocks_adv ( VC1Context * v ) {\n<30> if ( s -> start_mb_y ) {\n<33> memset ( & s -> coded_block [ s -> block_index [ 0 ] - s -> b8_stride ] , 0 , ( 1 + s -> b8_stride ) * sizeof ( * s -> coded_block ) ) ;
<1> static void dump_hex_printable ( const void * data , size_t len ) {\n<8> while ( len > 0 ) {\n<12> idx < rowlen ;\n<14> uch = * ( cdata ++ ) ;\n<15> printf ( "%02x " , uch ) ;\n<18> idx < 16 ;\n<19> idx ++ ) printf ( " " ) ;\n<22> idx < rowlen ;\n<25> printf ( "%c" , ( isprint ( uch ) ) ? uch : '.' ) ;\n<27> printf ( "\n" ) ;
<1> static int tiff_unpack_fax(TiffContext *s, uint8_t *dst, int stride,\n<3> const uint8_t *src, int size, int width, int lines)\n<17> if (!src2) {\n<29> if (!s->fill_order) {\n<31> memcpy(src2, src, size);\n<35> for (i = 0; i < size; i++)\n<37> src2[i] = ff_reverse[src[i]];\n<41> memset(src2 + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n<43> ret = ff_ccitt_unpack(s->avctx, src2, size, dst, lines, stride,
<1> static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,\n<93> if (ret < 0) {\n<95> fprintf(stderr, "ERROR: Could not read L2 table: %s\n",\n<97> strerror(-ret));\n<177> if (ret < 0) {\n<179> fprintf(stderr, "ERROR: Could not write L2 table; metadata "\n<181> "overlap check failed: %s\n", strerror(-ret));\n<193> if (ret < 0) {\n<195> fprintf(stderr, "ERROR: Could not write L2 table: %s\n",\n<197> strerror(-ret));
<1> static void usbredir_bulk_packet(void *priv, uint32_t id,\n<5> uint8_t *data, int data_len)\n<27> if (!aurb) {\n<29> free(data);\n<55> usbredir_log_data(dev, "bulk data in:", data, data_len);\n<57> if (data_len <= aurb->packet->len) {\n<59> memcpy(aurb->packet->data, data, data_len);\n<75> usb_packet_complete(&dev->dev, aurb->packet);\n<81> free(data);
<1> static int vp9_alloc_frame(AVCodecContext *ctx, VP9Frame *f)\n<17> if (!(f->extradata = av_buffer_allocz(sz * (1 + sizeof(struct VP9mvrefPair))))) {\n<27> f->segmentation_map = f->extradata->data;\n<35> if (s->segmentation.enabled && !s->segmentation.update_map &&\n<39> memcpy(f->segmentation_map, s->frames[LAST_FRAME].segmentation_map, sz);
<1> static int dump_tablespaces_for_databases ( char * * databases ) {\n<7> databases [ i ] != NULL ;\n<10> mysql_real_escape_string ( mysql , db_name_buff , databases [ i ] , ( ulong ) strlen ( databases [ i ] ) ) ;
<1> void evhttp_request_free ( struct evhttp_request * req ) {\n<2> if ( req -> remote_host != NULL ) free ( req -> remote_host ) ;\n<3> if ( req -> uri != NULL ) free ( req -> uri ) ;\n<4> if ( req -> response_code_line != NULL ) free ( req -> response_code_line ) ;\n<5> evhttp_clear_headers ( req -> input_headers ) ;\n<6> free ( req -> input_headers ) ;\n<7> evhttp_clear_headers ( req -> output_headers ) ;\n<8> free ( req -> output_headers ) ;\n<9> if ( req -> input_buffer != NULL ) evbuffer_free ( req -> input_buffer ) ;\n<10> if ( req -> output_buffer != NULL ) evbuffer_free ( req -> output_buffer ) ;\n<11> free ( req ) ;
<1> static char * convert_mime_hdr_to_string ( TSMBuffer bufp , TSMLoc hdr_loc ) {\n<17> output_string = ( char * ) TSmalloc ( total_avail + 1 ) ;\n<18> output_len = 0 ;\n<21> block_start = TSIOBufferBlockReadStart ( block , reader , & block_avail ) ;\n<22> if ( block_avail == 0 ) {\n<25> memcpy ( output_string + output_len , block_start , block_avail ) ;\n<26> output_len += block_avail ;\n<27> TSIOBufferReaderConsume ( reader , block_avail ) ;
<1> static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n<3> uint8_t *dst, int stride, int16_t *block, int *is_p)\n<13> if (get_bits1(gb)) {\n<23> memset(block, 0, sizeof(*block) * 64);\n<43> fic_idct_put(dst, stride, block);
<1> static int mpc8_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<5> MPCContext * c = avctx -> priv_data ;\n<18> if ( keyframe ) {\n<19> memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n<172> ff_mpc_dequantize_and_synth ( c , maxband - 1 , ( int16_t * * ) frame -> extended_data , avctx -> channels ) ;
<1> void vga_reset(void *opaque)\n<5> VGAState *s = (VGAState *) opaque;\n<25> memset(s->sr, '\0', sizeof(s->sr));\n<29> memset(s->gr, '\0', sizeof(s->gr));\n<33> memset(s->ar, '\0', sizeof(s->ar));\n<39> memset(s->cr, '\0', sizeof(s->cr));\n<57> memset(s->dac_cache, '\0', sizeof(s->dac_cache));\n<61> memset(s->palette, '\0', sizeof(s->palette));\n<81> memset(s->font_offsets, '\0', sizeof(s->font_offsets));\n<115> memset(s->invalidated_y_table, '\0', sizeof(s->invalidated_y_table));\n<117> memset(s->last_palette, '\0', sizeof(s->last_palette));\n<119> memset(s->last_ch_attr, '\0', sizeof(s->last_ch_attr));\n<121> switch (vga_retrace_method) {\n<129> memset(&s->retrace_info, 0, sizeof (s->retrace_info));
<1> peer_node * create_peer_node ( int hmode , address_node * addr , attr_val_fifo * options ) {\n<6> my_node = emalloc_zero ( sizeof ( * my_node ) ) ;\n<7> my_node -> peerversion = NTP_VERSION ;\n<8> my_node -> host_mode = hmode ;\n<9> my_node -> addr = addr ;\n<10> while ( options != NULL ) {\n<11> UNLINK_FIFO ( option , * options , link ) ;\n<12> if ( NULL == option ) {\n<13> free ( options ) ;\n<18> case T_Flag : APPEND_G_FIFO ( my_node -> peerflags , option ) ;\n<23> my_node -> minpoll = NTP_MINPOLL ;\n<26> my_node -> minpoll = ( u_char ) option -> value . u ;\n<31> my_node -> maxpoll = NTP_MAXPOLL ;\n<34> my_node -> maxpoll = ( u_char ) option -> value . u ;\n<42> my_node -> ttl = ( u_char ) option -> value . u ;\n<50> my_node -> ttl = ( u_char ) option -> value . u ;\n<58> my_node -> peerkey = ( keyid_t ) option -> value . u ;\n<66> my_node -> peerversion = ( u_char ) option -> value . u ;\n<69> case T_Ident : my_node -> group = option -> value . s ;\n<71> default : msyslog ( LOG_ERR , "Unknown peer/server option token %s" , token_name ( option -> attr ) ) ;\n<74> if ( freenode ) free ( option ) ;\n<76> if ( errflag ) {\n<77> free ( my_node ) ;
<1> static void calc_slice_sizes(VC2EncContext *s)\n<13> for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n<15> SliceArgs *args = &enc_args[s->num_x*slice_y + slice_x];\n<27> memset(args->cache, 0, MAX_QUANT_INDEX*sizeof(*args->cache));
<1> static int hls_append_segment(struct AVFormatContext *s, HLSContext *hls, double duration,\n<21> if ((hls->flags & (HLS_SECOND_LEVEL_SEGMENT_SIZE | HLS_SECOND_LEVEL_SEGMENT_DURATION)) &&\n<23> strlen(hls->current_segment_final_filename_fmt)) {\n<27> av_strlcpy(hls->avf->filename, hls->current_segment_final_filename_fmt, sizeof(hls->avf->filename));\n<117> av_log(hls, AV_LOG_WARNING, "Duplicated segment filename detected: %s\n", filename);\n<205> if ((ret = hls_delete_old_segments(hls)) < 0)
<1> static inline int is_specified_interface ( char * interface , const char * interface_prefix ) {\n<2> return ! strncmp ( interface , interface_prefix , strlen ( interface_prefix ) ) ;
<1> int inet_connect_opts(QemuOpts *opts, bool *in_progress, Error **errp)\n<21> memset(&ai,0, sizeof(ai));\n<45> if (addr == NULL || port == NULL) {\n<47> fprintf(stderr, "inet_connect: host and/or port not specified\n");\n<69> if (0 != (rc = getaddrinfo(addr, port, &ai, &res))) {\n<71> fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port,\n<73> gai_strerror(rc));\n<83> for (e = res; e != NULL; e = e->ai_next) {\n<85> if (getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n<91> fprintf(stderr,"%s: getnameinfo: oops\n", __FUNCTION__);\n<99> if (sock < 0) {\n<101> fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__,\n<103> inet_strfamily(e->ai_family), strerror(errno));\n<157> if (NULL == e->ai_next)\n<159> fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__,\n<161> inet_strfamily(e->ai_family),\n<163> e->ai_canonname, uaddr, uport, strerror(errno));
<5> jas_image_cmpt_destroy ( image -> cmpts_ [ cmptno ] ) ;\n<6> if ( cmptno < image -> numcmpts_ ) {\n<7> memmove ( & image -> cmpts_ [ cmptno ] , & image -> cmpts_ [ cmptno + 1 ] , ( image -> numcmpts_ - 1 - cmptno ) * sizeof ( jas_image_cmpt_t * ) ) ;
<1> static void pdf_process_CS ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi , int stroke ) {\n<2> if ( ! proc -> op_CS || ! proc -> op_cs ) return ;\n<3> if ( ! strcmp ( csi -> name , "Pattern" ) ) {\n<4> if ( stroke ) proc -> op_CS ( ctx , proc , "Pattern" , NULL ) ;\n<9> if ( ! strcmp ( csi -> name , "DeviceGray" ) ) cs = fz_keep_colorspace ( ctx , fz_device_gray ( ctx ) ) ;\n<10> else if ( ! strcmp ( csi -> name , "DeviceRGB" ) ) cs = fz_keep_colorspace ( ctx , fz_device_rgb ( ctx ) ) ;\n<11> else if ( ! strcmp ( csi -> name , "DeviceCMYK" ) ) cs = fz_keep_colorspace ( ctx , fz_device_cmyk ( ctx ) ) ;\n<14> csres = pdf_dict_get ( ctx , csi -> rdb , PDF_NAME_ColorSpace ) ;\n<15> if ( ! csres ) fz_throw ( ctx , FZ_ERROR_SYNTAX , "cannot find ColorSpace dictionary" ) ;\n<16> csobj = pdf_dict_gets ( ctx , csres , csi -> name ) ;\n<17> if ( ! csobj ) fz_throw ( ctx , FZ_ERROR_SYNTAX , "cannot find ColorSpace resource '%s'" , csi -> name ) ;\n<18> cs = pdf_load_colorspace ( ctx , csobj ) ;\n<20> fz_try ( ctx ) {\n<21> if ( stroke ) proc -> op_CS ( ctx , proc , csi -> name , cs ) ;\n<22> else proc -> op_cs ( ctx , proc , csi -> name , cs ) ;\n<24> fz_always ( ctx ) fz_drop_colorspace ( ctx , cs ) ;\n<25> fz_catch ( ctx ) fz_rethrow ( ctx ) ;
<1> static int rtp_packetize_mp4a ( sout_stream_id_sys_t * id , block_t * in ) {\n<4> uint8_t * p_data = in -> p_buffer ;\n<8> i < i_count ;\n<10> int i_payload = __MIN ( i_max , i_data ) ;\n<12> rtp_packetize_common ( id , out , ( ( i == i_count - 1 ) ? 1 : 0 ) , ( in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ) ;\n<13> out -> p_buffer [ 12 ] = 0 ;\n<14> out -> p_buffer [ 13 ] = 2 * 8 ;\n<15> SetWBE ( out -> p_buffer + 14 , ( in -> i_buffer << 3 ) | 0 ) ;\n<16> memcpy ( & out -> p_buffer [ 16 ] , p_data , i_payload ) ;\n<19> rtp_packetize_send ( id , out ) ;\n<20> p_data += i_payload ;\n<21> i_data -= i_payload ;
<1> void xps_parse_matrix_transform ( xps_document * doc , fz_xml * root , fz_matrix * matrix ) {\n<4> if ( ! strcmp ( fz_xml_tag ( root ) , "MatrixTransform" ) ) {\n<5> transform = fz_xml_att ( root , "Matrix" ) ;\n<6> if ( transform ) xps_parse_render_transform ( doc , transform , matrix ) ;
<13> CinVideoContext *cin = avctx->priv_data;\n<21> if (avctx->reget_buffer(avctx, &cin->frame)) {\n<53> cin->palette[i] = bytestream_get_le24(&buf);\n<63> cin->palette[buf[0]] = AV_RL24(buf+1);\n<73> memcpy(cin->frame.data[1], cin->palette, sizeof(cin->palette));\n<97> cin_apply_delta_data(cin->bitmap_table[CIN_PRE_BMP],\n<109> cin_decode_rle(cin->bitmap_table[CIN_INT_BMP], bitmap_frame_size,\n<125> cin_apply_delta_data(cin->bitmap_table[CIN_PRE_BMP],\n<153> cin_apply_delta_data(cin->bitmap_table[CIN_PRE_BMP],\n<163> for (y = 0; y < cin->avctx->height; ++y)\n<165> memcpy(cin->frame.data[0] + (cin->avctx->height - 1 - y) * cin->frame.linesize[0],\n<167> cin->bitmap_table[CIN_CUR_BMP] + y * cin->avctx->width,
<1> static int asf_parse_packet(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt)\n<89> av_assert0(asf_st);\n<164> pal = av_packet_new_side_data(&asf_st->pkt, AV_PKT_DATA_PALETTE,\n<168> if (!pal) {\n<174> memcpy(pal, asf_st->palette, AVPALETTE_SIZE);\n<206> av_dlog(asf, "READ PACKET s:%d  os:%d  o:%d,%d  l:%d   DATA:%p\n",\n<238> if (asf->packet_frag_offset != asf_st->frag_offset && !asf_st->pkt_clean) {\n<240> memset(asf_st->pkt.data + asf_st->frag_offset, 0, asf_st->pkt.size - asf_st->frag_offset);\n<254> if (ret < 0 || asf->packet_frag_offset + ret == 0)\n<260> if (asf_st->ds_span > 1) {\n<268> memset(asf_st->pkt.data + asf->packet_frag_offset + ret, 0,\n<270> asf->packet_frag_size - ret);\n<304> for (i = 0; i < asf_st->pkt.size && !asf_st->pkt.data[i]; i++)\n<328> if (asf_st->pkt.size != asf_st->ds_packet_size * asf_st->ds_span) {\n<346> if (buf) {\n<348> uint8_t *newdata = buf->data;\n<356> while (offset < asf_st->pkt.size) {\n<358> int off = offset / asf_st->ds_chunk_size;\n<372> asf_st->pkt.data + idx * asf_st->ds_chunk_size,\n<376> offset += asf_st->ds_chunk_size;
<1> PXA2xxState * pxa270_init ( MemoryRegion * address_space , unsigned int sdram_size , const char * revision ) {\n<6> if ( revision && strncmp ( revision , "pxa27" , 5 ) ) {\n<7> fprintf ( stderr , "Machine requires a PXA27x processor.\n" ) ;\n<12> if ( s -> cpu == NULL ) {\n<13> fprintf ( stderr , "Unable to find CPU definition\n" ) ;\n<28> if ( ! dinfo ) {\n<29> fprintf ( stderr , "qemu: missing SecureDigital device\n" ) ;
<1> static int testit ( struct test_case_struct * tc ) {\n<15> we = sav_we ;\n<16> printf ( "Test %d (%s): " , ++ tests , tc -> words ) ;\n<19> if ( wordexp ( "pre1 pre2" , & we , tc -> flags & ~ WRDE_APPEND ) != 0 ) {\n<20> printf ( "FAILED setup\n" ) ;\n<24> retval = wordexp ( tc -> words , & we , tc -> flags ) ;\n<25> if ( ( tc -> flags & WRDE_NOCMD ) && ( registered_forks > 0 ) ) {\n<26> printf ( "FAILED fork called for WRDE_NOCMD\n" ) ;\n<30> if ( retval != tc -> retval || ( retval == 0 && we . we_wordc != tc -> wordc ) ) bzzzt = 1 ;\n<31> else if ( retval == 0 ) {\n<39> i < we . we_wordc ;\n<40> ++ i ) if ( we . we_wordv [ i + start_offs ] == NULL || strcmp ( tc -> wordv [ i ] , we . we_wordv [ i + start_offs ] ) != 0 ) {\n<45> if ( bzzzt ) {\n<46> printf ( "FAILED\n" ) ;\n<47> printf ( "Test words: <%s>, need retval %d, wordc %Zd\n" , tc -> words , tc -> retval , tc -> wordc ) ;\n<48> if ( start_offs != 0 ) printf ( "(preceded by %d NULLs)\n" , start_offs ) ;\n<49> printf ( "Got retval %d, wordc %Zd: " , retval , we . we_wordc ) ;\n<50> if ( retval == 0 || retval == WRDE_NOSPACE ) {\n<52> i < we . we_wordc + start_offs ;\n<53> ++ i ) if ( we . we_wordv [ i ] == NULL ) printf ( "NULL " ) ;\n<54> else printf ( "<%s> " , we . we_wordv [ i ] ) ;\n<56> printf ( "\n" ) ;\n<58> else if ( retval != 0 && retval != WRDE_NOSPACE && ( we . we_wordc != sav_we . we_wordc || we . we_wordv != sav_we . we_wordv || we . we_offs != sav_we . we_offs ) ) {\n<60> printf ( "FAILED to restore wordexp_t members\n" ) ;\n<62> else printf ( "OK\n" ) ;\n<63> if ( retval == 0 || retval == WRDE_NOSPACE ) wordfree ( & we ) ;
<1> int dissect_ber_sequence ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * parent_tree , tvbuff_t * tvb , int offset , const ber_sequence_t * seq , gint hf_id , gint ett_id ) {\n<70> while ( offset < end_offset ) {\n<84> offset = get_ber_length ( tvb , offset , & len , & ind_field ) ;\n<149> next_tvb = ber_tvb_new_subset_length ( tvb , offset , len ) ;\n<171> name = hfinfo -> name ;\n<174> name = "unnamed" ;\n<176> if ( tvb_reported_length_remaining ( next_tvb , 0 ) > 3 ) {\n<177> printf ( "SEQUENCE dissect_ber_sequence(%s) calling subdissector offset:%d len:%d %02x:%02x:%02x\n" , name , offset , tvb_reported_length_remaining ( next_tvb , 0 ) , tvb_get_guint8 ( next_tvb , 0 ) , tvb_get_guint8 ( next_tvb , 1 ) , tvb_get_guint8 ( next_tvb , 2 ) ) ;\n<180> printf ( "SEQUENCE dissect_ber_sequence(%s) calling subdissector\n" , name ) ;
<1> xsltDocumentPtr xsltNewDocument ( xsltTransformContextPtr ctxt , xmlDocPtr doc ) {\n<4> if ( cur == NULL ) {\n<8> memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n<13> ctxt -> docList = cur ;\n<16> return ( cur ) ;
<1> int uwsgi_php_init ( void ) {\n<19> if ( uphp . docroot ) {\n<21> uphp . docroot = uwsgi_expand_path ( uphp . docroot , strlen ( uphp . docroot ) , NULL ) ;\n<26> uwsgi_log ( "PHP document root set to %s\n" , uphp . docroot ) ;\n<27> uphp . docroot_len = strlen ( uphp . docroot ) ;
<1> static void palmte_init(MachineState *machine)\n<99> rom_size = get_image_size(option_rom[0].name);\n<101> if (rom_size > flash_size) {\n<103> fprintf(stderr, "%s: ROM image too big (%x > %x)\n",\n<113> rom_size = load_image_targphys(option_rom[0].name, OMAP_CS0_BASE,\n<121> if (rom_size < 0) {\n<133> if (!rom_loaded && !kernel_filename && !qtest_enabled()) {\n<135> fprintf(stderr, "Kernel or ROM image must be specified\n");
<1> static int sql_real_connect ( char * host , char * database , char * user , char * password , uint silent ) {\n<20> char init_command [ 100 ] ;\n<21> sprintf ( init_command , "SET SQL_SAFE_UPDATES=1,SQL_SELECT_LIMIT=%lu,MAX_JOIN_SIZE=%lu" , select_limit , max_join_size ) ;\n<22> mysql_options ( & mysql , MYSQL_INIT_COMMAND , init_command ) ;
<1> static int transcode(AVFormatContext **output_files,\n<25> char error[1024];\n<101> ist->file_index = i;\n<103> ist->index = k;\n<131> if (!os->nb_streams && !(os->oformat->flags & AVFMT_NOSTREAMS)) {\n<133> av_dump_format(output_files[i], i, output_files[i]->filename, 1);\n<135> fprintf(stderr, "Output file #%d does not contain any stream\n", i);\n<147> if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n<149> fprintf(stderr, "Number of stream maps must match number of output streams\n");\n<165> int si = stream_maps[i].stream_index;\n<169> if (fi < 0 || fi > nb_input_files - 1 ||\n<171> si < 0 || si > file_table[fi].nb_streams - 1) {\n<173> fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si);\n<183> si = stream_maps[i].sync_stream_index;\n<185> if (fi < 0 || fi > nb_input_files - 1 ||\n<187> si < 0 || si > file_table[fi].nb_streams - 1) {\n<189> fprintf(stderr,"Could not find sync stream #%d.%d\n", fi, si);\n<291> ost = ost_table[n] = output_streams_for_file[k][i];\n<305> if (ist_table[ost->source_index]->st->codec->codec_type != ost->st->codec->codec_type) {\n<307> int i= ost->file_index;\n<311> fprintf(stderr, "Codec type mismatch for mapping #%d.%d -> #%d.%d\n",\n<403> if (!found) {\n<405> int i= ost->file_index;\n<409> fprintf(stderr, "Could not find input stream matching output stream #%d.%d\n",\n<449> codec = ost->st->codec;\n<451> icodec = ist->st->codec;\n<473> uint64_t extra_size = (uint64_t)icodec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE;\n<513> if (!codec->extradata)\n<517> memcpy(codec->extradata, icodec->extradata, icodec->extradata_size);\n<519> codec->extradata_size= icodec->extradata_size;\n<539> if(audio_volume != 256) {\n<541> fprintf(stderr,"-acodec copy and -vol are incompatible (frames are not decoded)\n");\n<627> if (ost->st->codec->pix_fmt == PIX_FMT_NONE) {\n<629> fprintf(stderr, "Video pixel format is unknown, stream cannot be encoded\n");\n<647> if(avpicture_alloc((AVPicture*)&ost->pict_tmp, codec->pix_fmt,\n<651> fprintf(stderr, "Cannot allocate temp picture, check pix fmt\n");\n<675> if (ost->img_resample_ctx == NULL) {\n<677> fprintf(stderr, "Cannot get resampling context\n");\n<757> f = fopen(logfilename, "wb");\n<759> if (!f) {\n<761> fprintf(stderr, "Cannot write log file '%s' for pass-1 encoding: %s\n", logfilename, strerror(errno));\n<775> if (read_file(logfilename, &logbuffer, &logbuffer_size) < 0) {\n<777> fprintf(stderr, "Error reading log file '%s' for pass-2 encoding\n", logfilename);\n<797> bit_buffer_size= FFMAX(bit_buffer_size, 6*size + 1664);\n<807> bit_buffer = av_malloc(bit_buffer_size);\n<809> if (!bit_buffer) {\n<811> fprintf(stderr, "Cannot allocate %d bytes output buffer\n",\n<833> AVCodecContext *dec = ist_table[ost->source_index]->st->codec;\n<835> if (!codec)\n<839> if (!codec) {\n<841> snprintf(error, sizeof(error), "Encoder (codec id %d) not found for output stream #%d.%d",\n<853> ost->st->codec->subtitle_header = av_malloc(dec->subtitle_header_size);\n<855> if (!ost->st->codec->subtitle_header) {\n<863> memcpy(ost->st->codec->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<865> ost->st->codec->subtitle_header_size = dec->subtitle_header_size;\n<869> if (avcodec_open(ost->st->codec, codec) < 0) {\n<871> snprintf(error, sizeof(error), "Error while opening encoder for output stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height",\n<899> if (!codec)\n<903> if (!codec) {\n<905> snprintf(error, sizeof(error), "Decoder (codec id %d) not found for input stream #%d.%d",\n<915> if (avcodec_open(ist->st->codec, codec) < 0) {\n<917> snprintf(error, sizeof(error), "Error while opening decoder for input stream #%d.%d",\n<973> snprintf(error, sizeof(error), "Invalid %s index %d while processing metadata maps\n",\\n<1087> snprintf(error, sizeof(error), "Invalid input file index %d in chapter mapping.\n", infile);\n<1097> snprintf(error, sizeof(error), "Invalid output file index %d in chapter mapping.\n",outfile);\n<1141> if (av_write_header(os) < 0) {\n<1143> snprintf(error, sizeof(error), "Could not write header for output file #%d (incorrect codec parameters ?)", i);\n<1151> if (strcmp(output_files[i]->oformat->name, "rtp")) {\n<1153> want_sdp = 0;\n<1177> if (verbose >= 0) {\n<1179> fprintf(stderr, "Stream mapping:\n");\n<1181> for(i=0;i<nb_ostreams;i++) {\n<1183> ost = ost_table[i];\n<1195> if (ost->sync_ist != ist_table[ost->source_index])\n<1203> fprintf(stderr, "\n");\n<1211> if (ret) {\n<1213> fprintf(stderr, "%s\n", error);\n<1231> if(verbose >= 0)\n<1233> fprintf(stderr, "Press [q] to stop encoding\n");\n<1299> ist = ist_table[ost->source_index];\n<1301> if(ist->is_past_recording_time || no_packet[ist->file_index])\n<1315> if(input_sync ) file_index = ist->file_index;\n<1323> if(!input_sync) file_index = ist->file_index;\n<1343> if(no_packet_count){\n<1347> memset(no_packet, 0, sizeof(no_packet));\n<1377> no_packet[file_index]=1;\n<1385> if (ret < 0) {\n<1403> memset(no_packet, 0, sizeof(no_packet));\n<1505> if (output_packet(ist, ist_index, ost_table, nb_ostreams, &pkt) < 0) {\n<1509> if (verbose >= 0)\n<1511> fprintf(stderr, "Error while decoding stream #%d.%d\n",\n<1549> output_packet(ist, i, ost_table, nb_ostreams, NULL);\n<1589> avcodec_close(ost->st->codec);\n<1639> av_free(ist);\n<1643> av_free(ist_table);\n<1671> av_freep(&ost->st->codec->subtitle_header);\n<1689> av_free(ost);
<1> static bool restricted_shell ( const char * shell ) {\n<4> while ( ( line = getusershell ( ) ) != NULL ) {\n<5> if ( * line != '#' && ! strcmp ( line , shell ) ) {\n<6> endusershell ( ) ;\n<7> return false ;
<1> static void copy_rules_phase ( apr_pool_t * mp , apr_array_header_t * parent_phase_arr , apr_array_header_t * child_phase_arr , apr_array_header_t * exceptions_arr ) {\n<23> case RULE_EXCEPTION_REMOVE_MSG : if ( ( rule -> actionset != NULL ) && ( rule -> actionset -> msg != NULL ) ) {\n<25> int rc = msc_regexec ( exceptions [ j ] -> param_data , rule -> actionset -> msg , strlen ( rule -> actionset -> msg ) , & my_error_msg ) ;\n<37> c < tarr -> nelts ;\n<39> msre_action * action = ( msre_action * ) telts [ c ] . val ;\n<40> if ( strcmp ( "tag" , action -> metadata -> name ) == 0 ) {\n<41> int rc = msc_regexec ( exceptions [ j ] -> param_data , action -> param , strlen ( action -> param ) , & my_error_msg ) ;\n<42> if ( rc >= 0 ) copy -- ;
<1> static unsigned int mszh_decomp(unsigned char * srcptr, int srclen, unsigned char * destptr, unsigned int destsize)\n<17> while (srclen > 0 && destptr < destptr_end) {\n<21> mask = *srcptr++;\n<33> if (destptr + 4 > destptr_end)\n<37> memcpy(destptr, srcptr, 4);\n<41> destptr += 4;\n<43> srcptr += 4;\n<49> cnt = *srcptr++;\n<63> cnt =  destptr_end - destptr;\n<69> *destptr = *(destptr - ofs);\n<71> destptr++;
<1> static int shorten_decode_frame(AVCodecContext *avctx,\n<9> const uint8_t *buf = avpkt->data;\n<13> ShortenContext *s = avctx->priv_data;\n<23> s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize);\n<29> if(1 && s->max_framesize){//FIXME truncated\n<31> buf_size= FFMIN(buf_size, s->max_framesize - s->bitstream_size);\n<37> if(s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size){\n<41> memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size);\n<47> memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size);\n<49> buf= &s->bitstream[s->bitstream_index];\n<51> buf_size += s->bitstream_size;\n<77> if ((ret = read_header(s)) < 0)\n<141> int blocksize = get_uint(s, av_log2(s->blocksize));\n<261> if ((ret = decode_subframe_lpc(s, channel, residual_size, coffset)) < 0)\n<301> fix_bitshift(s, s->decoded[channel]);
<1> static int vpc_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<43> if (offset == -1) {\n<45> memset(buf, 0, sectors * BDRV_SECTOR_SIZE);\n<67> buf += sectors * BDRV_SECTOR_SIZE;
<1> static inline void vmsvga_update_rect(struct vmsvga_state_s *s,\n<13> int width = s->bypp * w;\n<17> uint8_t *src = s->vram + start;\n<19> uint8_t *dst = s->ds->data + start;\n<23> for (; line > 0; line --, src += bypl, dst += bypl)\n<25> memcpy(dst, src, width);
<1> gcry_error_t gcry_pk_genkey ( gcry_sexp_t * r_key , gcry_sexp_t s_parms ) {\n<45> if ( ! module ) {\n<52> if ( ! algo_name || ! * algo_name ) algo_name = pubkey -> name ;\n<53> pub_elems = pubkey -> elements_pkey ;\n<54> sec_elems = pubkey -> elements_skey ;\n<55> if ( strlen ( sec_elems ) >= DIM ( skey ) ) BUG ( ) ;\n<58> char buf [ 50 ] ;\n<60> s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n<61> if ( ! s || n >= DIM ( buf ) - 1 ) {\n<65> memcpy ( buf , s , n ) ;\n<66> buf [ n ] = 0 ;\n<67> use_e = strtoul ( buf , NULL , 0 ) ;\n<74> char buf [ 50 ] ;\n<76> s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n<77> if ( ! s || n >= DIM ( buf ) - 1 ) {\n<81> memcpy ( buf , s , n ) ;\n<83> nbits = ( unsigned int ) strtoul ( buf , NULL , 0 ) ;\n<91> if ( rc ) goto leave ;\n<97> nelem = strlen ( pub_elems ) + strlen ( sec_elems ) ;\n<101> i ++ ) nelem ++ ;\n<103> nelem_cp = nelem ;\n<104> needed += nelem * 10 ;\n<105> needed += 2 * strlen ( algo_name ) + 300 + 5 ;\n<108> string = p = gcry_malloc ( needed ) ;\n<109> if ( ! string ) {\n<115> p = stpcpy ( p , algo_name ) ;\n<120> * p ++ = pub_elems [ i ] ;\n<135> * p ++ = sec_elems [ i ] ;\n<158> int elem_n = strlen ( pub_elems ) + strlen ( sec_elems ) ;\n<166> i < elem_n ;
<1> static void * init_tls ( void ) {\n<3> if ( GL ( dl_initial_dtv ) != NULL ) return NULL ;\n<5> GL ( dl_tls_dtv_slotinfo_list ) = ( struct dtv_slotinfo_list * ) calloc ( sizeof ( struct dtv_slotinfo_list ) + nelem * sizeof ( struct dtv_slotinfo ) , 1 ) ;
<1> static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){\n<9> pnm_get(s, buf1, sizeof(buf1));\n<11> if (!strcmp(buf1, "P4")) {\n<13> avctx->pix_fmt = PIX_FMT_MONOWHITE;\n<15> } else if (!strcmp(buf1, "P5")) {\n<17> if (avctx->codec_id == CODEC_ID_PGMYUV)\n<25> } else if (!strcmp(buf1, "P6")) {\n<27> avctx->pix_fmt = PIX_FMT_RGB24;\n<29> } else if (!strcmp(buf1, "P7")) {\n<31> w = -1;\n<33> h = -1;\n<35> maxval = -1;\n<37> depth = -1;\n<39> tuple_type[0] = '\0';\n<43> pnm_get(s, buf1, sizeof(buf1));\n<45> if (!strcmp(buf1, "WIDTH")) {\n<47> pnm_get(s, buf1, sizeof(buf1));\n<49> w = strtol(buf1, NULL, 10);\n<51> } else if (!strcmp(buf1, "HEIGHT")) {\n<53> pnm_get(s, buf1, sizeof(buf1));\n<55> h = strtol(buf1, NULL, 10);\n<57> } else if (!strcmp(buf1, "DEPTH")) {\n<59> pnm_get(s, buf1, sizeof(buf1));\n<61> depth = strtol(buf1, NULL, 10);\n<63> } else if (!strcmp(buf1, "MAXVAL")) {\n<65> pnm_get(s, buf1, sizeof(buf1));\n<67> maxval = strtol(buf1, NULL, 10);\n<69> } else if (!strcmp(buf1, "TUPLETYPE")) {\n<71> pnm_get(s, tuple_type, sizeof(tuple_type));\n<73> } else if (!strcmp(buf1, "ENDHDR")) {\n<79> return -1;\n<87> if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\0')\n<123> return -1;\n<127> pnm_get(s, buf1, sizeof(buf1));\n<129> avctx->width = atoi(buf1);\n<131> if (avctx->width <= 0)
<1> static void test_cipher_speed(const void *opaque)\n<25> key = g_new0(uint8_t, nkey);\n<27> memset(key, g_test_rand_int(), nkey);\n<31> iv = g_new0(uint8_t, niv);\n<33> memset(iv, g_test_rand_int(), niv);\n<41> plaintext = g_new0(uint8_t, chunk_size);\n<43> memset(plaintext, g_test_rand_int(), chunk_size);
<1> static void kill_server ( char * prefix , char * pid_file ) {\n<3> int pid , path_size = strlen ( prefix ) + strlen ( pid_file ) + 2 ;\n<4> path = ss_malloc ( path_size ) ;\n<5> snprintf ( path , path_size , "%s/%s" , prefix , pid_file ) ;\n<7> if ( f == NULL ) {\n<14> if ( fscanf ( f , "%d" , & pid ) != EOF ) {\n<15> kill ( pid , SIGTERM ) ;\n<17> fclose ( f ) ;
<1> static int read_header(AVFormatContext *s)\n<19> int bfstm = !strcmp("bfstm", s->iformat->name);\n<55> if (!bfstm) {
<1> MIMEFieldBlockImpl * _mime_field_block_copy ( MIMEFieldBlockImpl * s_fblock , HdrHeap * , HdrHeap * d_heap ) {\n<3> d_fblock = ( MIMEFieldBlockImpl * ) d_heap -> allocate_obj ( sizeof ( MIMEFieldBlockImpl ) , HDR_HEAP_OBJ_FIELD_BLOCK ) ;\n<4> memcpy ( d_fblock , s_fblock , sizeof ( MIMEFieldBlockImpl ) ) ;\n<5> return d_fblock ;
<1> static int vnc_zlib_stop(VncState *vs, int stream_id)\n<49> if (err != Z_OK) {\n<51> fprintf(stderr, "VNC: error initializing zlib\n");\n<93> if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n<95> fprintf(stderr, "VNC: error during zlib compression\n");
<1> void add_codec(FFStream *stream, AVCodecContext *av)\n<15> if (av->bit_rate == 0)\n<17> av->bit_rate = 64000;\n<19> if (av->sample_rate == 0)\n<21> av->sample_rate = 22050;\n<23> if (av->channels == 0)\n<25> av->channels = 1;\n<31> if (av->bit_rate == 0)\n<33> av->bit_rate = 64000;\n<35> if (av->frame_rate == 0)\n<37> av->frame_rate = 5 * FRAME_RATE_BASE;\n<39> if (av->width == 0 || av->height == 0) {\n<41> av->width = 160;\n<43> av->height = 128;\n<49> if (av->bit_rate_tolerance == 0)\n<51> av->bit_rate_tolerance = av->bit_rate / 4;\n<53> if (av->qmin == 0)\n<55> av->qmin = 3;\n<57> if (av->qmax == 0)\n<59> av->qmax = 31;\n<61> if (av->max_qdiff == 0)\n<63> av->max_qdiff = 3;\n<65> av->qcompress = 0.5;\n<67> av->qblur = 0.5;\n<83> if (!st)\n<89> memcpy(&st->codec, av, sizeof(AVCodecContext));
<1> void qmp_block_set_io_throttle(const char *device, int64_t bps, int64_t bps_rd,\n<17> if (!bs) {\n<27> memset(&cfg, 0, sizeof(cfg));\n<65> if (!check_throttle_config(&cfg, errp)) {\n<73> if (!bs->io_limits_enabled && throttle_enabled(&cfg)) {\n<77> } else if (bs->io_limits_enabled && !throttle_enabled(&cfg)) {\n<87> bdrv_set_io_limits(bs, &cfg);
<1> static void test_bug4236 ( ) {\n<7> stmt = mysql_stmt_init ( mysql ) ;\n<8> stmt_text = "SELECT 1" ;\n<9> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<10> check_execute ( stmt , rc ) ;
<1> void virtio_blk_data_plane_start(VirtIOBlockDataPlane *s)\n<33> if (r != 0) {\n<35> fprintf(stderr, "virtio-blk failed to set guest notifier (%d), "\n<51> if (r != 0) {\n<53> fprintf(stderr, "virtio-blk failed to set host notifier (%d)\n", r);
<1> static int select_voice(cst_voice **voice, const char *voice_name, void *log_ctx)\n<9> for (i = 0; i < FF_ARRAY_ELEMS(voice_entries); i++) {\n<11> struct voice_entry *entry = &voice_entries[i];\n<13> if (!strcmp(entry->name, voice_name)) {\n<15> *voice = entry->register_fn(NULL);\n<17> if (!*voice) {\n<35> av_log(log_ctx, AV_LOG_ERROR, "Could not find voice '%s'\n", voice_name);
<1> static void generate_silence(uint8_t* buf, enum AVSampleFormat sample_fmt, size_t size)\n<5> int fill_char = 0x00;\n<9> fill_char = 0x80;\n<11> memset(buf, fill_char, size);
<1> InetSocketAddress *inet_parse(const char *str, Error **errp)\n<9> char host[64];\n<11> char port[33];\n<25> if (str[0] == ':') {\n<31> if (1 != sscanf(str, ":%32[^,]%n", port, &pos)) {\n<33> error_setg(errp, "error parsing port in address '%s'", str);\n<39> } else if (str[0] == '[') {\n<43> if (2 != sscanf(str, "[%64[^]]]:%32[^,]%n", host, port, &pos)) {\n<45> error_setg(errp, "error parsing IPv6 address '%s'", str);\n<51> addr->ipv6 = addr->has_ipv6 = true;\n<57> if (2 != sscanf(str, "%64[^:]:%32[^,]%n", host, port, &pos)) {\n<59> error_setg(errp, "error parsing address '%s'", str);\n<65> if (host[strspn(host, "0123456789.")] == '\0') {\n<67> addr->ipv4 = addr->has_ipv4 = true;\n<75> addr->host = g_strdup(host);\n<77> addr->port = g_strdup(port);\n<83> optstr = str + pos;\n<85> h = strstr(optstr, ",to=");\n<87> if (h) {\n<89> h += 4;\n<91> if (sscanf(h, "%d%n", &to, &pos) != 1 ||\n<93> (h[pos] != '\0' && h[pos] != ',')) {\n<95> error_setg(errp, "error parsing to= argument");\n<101> addr->has_to = true;\n<103> addr->to = to;\n<107> if (strstr(optstr, ",ipv4")) {\n<109> addr->ipv4 = addr->has_ipv4 = true;\n<113> if (strstr(optstr, ",ipv6")) {\n<115> addr->ipv6 = addr->has_ipv6 = true;\n<119> return addr;\n<125> qapi_free_InetSocketAddress(addr);\n<127> return NULL;
<1> static int decorrelate(TAKDecContext *s, int c1, int c2, int length)\n<177> s->residues[i] = *p2++ >> dshift;\n<183> x = FF_ARRAY_ELEMS(s->residues) - filter_order;\n<185> for (; length2 > 0; length2 -= tmp) {\n<193> s->residues[filter_order + i] = *p2++ >> dshift;\n<203> v += s->adsp.scalarproduct_int16(&s->residues[i], s->filter, 16);\n<213> memcpy(s->residues, &s->residues[tmp], 2 * filter_order);
<1> static int qtrle_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> QtrleContext * s = avctx -> priv_data ;\n<28> case 1 : case 33 : qtrle_decode_1bpp ( s , row_ptr , height ) ;\n<30> case 2 : case 34 : qtrle_decode_2n4bpp ( s , row_ptr , height , 2 ) ;\n<33> case 4 : case 36 : qtrle_decode_2n4bpp ( s , row_ptr , height , 4 ) ;\n<36> case 8 : case 40 : qtrle_decode_8bpp ( s , row_ptr , height ) ;\n<39> case 16 : qtrle_decode_16bpp ( s , row_ptr , height ) ;\n<41> case 24 : qtrle_decode_24bpp ( s , row_ptr , height ) ;\n<43> case 32 : qtrle_decode_32bpp ( s , row_ptr , height ) ;\n<48> if ( has_palette ) {\n<49> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<50> if ( pal ) {\n<52> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<54> memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;
<1> static int opus_header(AVFormatContext *avf, int idx)\n<7> struct ogg_stream *os        = &ogg->streams[idx];\n<13> uint8_t *packet              = os->buf + os->pstart;\n<56> if (ff_alloc_extradata(st->codecpar, os->psize))\n<62> memcpy(st->codecpar->extradata, packet, os->psize);\n<82> if (priv->need_comments) {\n<84> if (os->psize < 8 || memcmp(packet, "OpusTags", 8))\n<86> return AVERROR_INVALIDDATA;\n<88> ff_vorbis_stream_comment(avf, st, packet + 8, os->psize - 8);\n<90> priv->need_comments--;\n<92> return 1;
<1> static int decode_block(BinkAudioContext *s, float **out, int use_dct)\n<23> FFTSample *coeffs = out[ch];\n<33> coeffs[0] = av_int2float(get_bits_long(gb, 32)) * s->root;\n<35> coeffs[1] = av_int2float(get_bits_long(gb, 32)) * s->root;\n<43> coeffs[0] = get_float(gb) * s->root;\n<45> coeffs[1] = get_float(gb) * s->root;\n<75> while (i < s->frame_len) {\n<109> if (width == 0) {\n<111> memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n<137> coeffs[i] = -q * coeff;\n<141> coeffs[i] =  q * coeff;\n<145> coeffs[i] = 0.0f;\n<175> for (ch = 0; ch < s->channels; ch++) {\n<187> out[ch][i] = (s->previous[ch][i] * (count - j) +\n<193> memcpy(s->previous[ch], &out[ch][s->frame_len - s->overlap_len],\n<195> s->overlap_len * sizeof(*s->previous[ch]));
<1> static void term_up_char(void)\n<31> if (term_hist_entry >= 0) {\n<37> term_print_cmdline(term_cmd_buf);\n<39> term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
<1> static void test_bug6761 ( void ) {\n<6> stmt_text = "CREATE TABLE t1 (a int, b char(255), c decimal)" ;\n<7> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<9> res = mysql_list_fields ( mysql , "t1" , "%" ) ;\n<12> stmt_text = "DROP TABLE t1" ;\n<13> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static void jpeg_put_comments(MpegEncContext *s)\n<43> if(!(s->flags & CODEC_FLAG_BITEXACT)){\n<53> put_string(p, LIBAVCODEC_IDENT);\n<55> size = strlen(LIBAVCODEC_IDENT)+3;\n<57> ptr[0] = size >> 8;
<1> static void qemu_net_queue_append_iov(NetQueue *queue,\n<37> packet = g_malloc(sizeof(NetPacket) + max_len);\n<45> packet->size = 0;\n<49> for (i = 0; i < iovcnt; i++) {\n<51> size_t len = iov[i].iov_len;\n<55> memcpy(packet->data + packet->size, iov[i].iov_base, len);\n<57> packet->size += len;
<1> static void ram_init ( hwaddr addr , ram_addr_t RAM_size , uint64_t max_mem ) {\n<5> if ( ( uint64_t ) RAM_size > max_mem ) {\n<6> fprintf ( stderr , "qemu: Too much memory for this machine: %d, maximum %d\n" , ( unsigned int ) ( RAM_size / ( 1024 * 1024 ) ) , ( unsigned int ) ( max_mem / ( 1024 * 1024 ) ) ) ;
<1> static void backward_filter ( RA288Context * ractx , float * hist , float * rec , const float * window , float * lpc , const float * tab , int order , int n , int non_rec , int move_size ) {\n<3> do_hybrid_window ( ractx , order , n , non_rec , temp , hist , rec , window ) ;\n<5> memmove ( hist , hist + n , move_size * sizeof ( * hist ) ) ;
<1> int jbig2_decode_halftone_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , Jbig2HalftoneRegionParams * params , const byte * data , const size_t size , Jbig2Image * image , Jbig2ArithCx * GB_stats ) {\n<11> memset ( image -> data , params -> HDEFPIXEL , image -> stride * image -> height ) ;\n<41> jbig2_image_compose ( ctx , image , HPATS -> patterns [ gray_val ] , x , y , params -> op ) ;
<1> static void usbdev_remove ( struct usb_device * udev ) {\n<9> if ( ps -> discsignr ) {\n<10> memset ( & sinfo , 0 , sizeof ( sinfo ) ) ;\n<15> kill_pid_info_as_cred ( ps -> discsignr , & sinfo , ps -> disc_pid , ps -> cred , ps -> secid ) ;
<1> static int tipc_nl_compat_recv ( struct sk_buff * skb , struct genl_info * info ) {\n<8> memset ( & msg , 0 , sizeof ( msg ) ) ;\n<12> msg . net = genl_info_net ( info ) ;\n<25> err = tipc_nl_compat_handle ( & msg ) ;\n<28> send : if ( ! msg . rep ) return err ;\n<30> skb_push ( msg . rep , len ) ;\n<31> rep_nlh = nlmsg_hdr ( msg . rep ) ;\n<32> memcpy ( rep_nlh , info -> nlhdr , len ) ;\n<34> genlmsg_unicast ( msg . net , msg . rep , NETLINK_CB ( skb ) . portid ) ;
<1> static int sd_snapshot_delete(BlockDriverState *bs,\n<41> if (!remove_objects(s)) {\n<49> memset(buf, 0, sizeof(buf));\n<51> memset(snap_tag, 0, sizeof(snap_tag));\n<53> pstrcpy(buf, SD_MAX_VDI_LEN, s->name);\n<83> ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,
<1> static TSReturnCode URLPartSet ( TSMBuffer bufp , TSMLoc obj , const char * value , int length , URLPartSetF url_f ) {\n<10> if ( ! value ) {\n<13> else if ( length < 0 ) {\n<14> length = strlen ( value ) ;
<1> static int refresh_lock ( struct remote_lock * lock ) {\n<14> if ( results . curl_result != CURLE_OK ) {\n<15> fprintf ( stderr , "LOCK HTTP error %ld\n" , results . http_code ) ;
<1> static void decode_band_structure(GetBitContext *gbc, int blk, int eac3,\n<5> const uint8_t *default_band_struct,\n<7> uint8_t *band_struct, int *num_subbands,\n<13> int subbnd, bnd, n_subbands, n_bands, bnd_sz[22];\n<31> } else if (!blk) {\n<37> n_subbands-1);\n<51> if (num_bands || band_sizes ) {\n<55> bnd_sz[0] = ecpl ? 6 : 12;\n<65> bnd_sz[bnd] += subbnd_size;\n<69> bnd_sz[++bnd] = subbnd_size;\n<89> if (band_sizes)\n<91> memcpy(band_sizes, bnd_sz, sizeof(int)*n_bands);
<1> static int vmd_read_header(AVFormatContext *s)\n<5> VmdDemuxContext *vmd = s->priv_data;\n<37> if (avio_read(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)\n<43> if(vmd->vmd_header[24] == 'i' && vmd->vmd_header[25] == 'v' && vmd->vmd_header[26] == '3')\n<55> if (!vst)\n<69> vst->codec->width = AV_RL16(&vmd->vmd_header[12]);\n<71> vst->codec->height = AV_RL16(&vmd->vmd_header[14]);\n<83> vst->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n<85> memcpy(vst->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);\n<91> vmd->sample_rate = AV_RL16(&vmd->vmd_header[804]);\n<125> st->codec->block_align = AV_RL16(&vmd->vmd_header[806]);\n<161> toc_offset = AV_RL32(&vmd->vmd_header[812]);\n<163> vmd->frame_count = AV_RL16(&vmd->vmd_header[6]);\n<165> vmd->frames_per_block = AV_RL16(&vmd->vmd_header[18]);\n<175> sound_buffers = AV_RL16(&vmd->vmd_header[808]);\n<235> avio_read(pb, chunk, BYTES_PER_FRAME_RECORD);\n<239> size = AV_RL32(&chunk[2]);\n<245> switch(type) {\n<249> if (!st) break;\n<259> memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n<283> memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);
<1> static bool host_tsx_blacklisted ( void ) {\n<4> host_vendor_fms ( vendor , & family , & model , & stepping ) ;\n<5> return ! strcmp ( vendor , CPUID_VENDOR_INTEL ) && ( family == 6 ) && ( ( model == 63 && stepping < 4 ) || model == 60 || model == 69 || model == 70 ) ;
<1> static void test_acpi_asl(test_data *data)\n<15> memset(&exp_data, 0, sizeof(exp_data));\n<33> err = load_asl(data->tables, sdt);\n<39> exp_err = load_asl(exp_data.tables, exp_sdt);\n<51> if (g_strcmp0(asl->str, exp_asl->str)) {\n<53> uint32_t signature = cpu_to_le32(exp_sdt->header.signature);\n<81> free_test_data(&exp_data);
<1> static void test_multi_statements ( ) {\n<32> if ( ! ( mysql_local = mysql_client_init ( NULL ) ) ) {\n<33> fprintf ( stdout , "\n mysql_client_init() failed" ) ;\n<36> if ( ! ( mysql_real_connect ( mysql_local , opt_host , opt_user , opt_password , current_db , opt_port , opt_unix_socket , CLIENT_MULTI_STATEMENTS ) ) ) {\n<37> fprintf ( stdout , "\n connection failed(%s)" , mysql_error ( mysql_local ) ) ;\n<44> count < array_elements ( rows ) ;\n<45> count ++ ) {\n<46> if ( ! opt_silent ) fprintf ( stdout , "\n Query %d: " , count ) ;\n<51> else if ( ! opt_silent ) fprintf ( stdout , "OK, %ld row(s) affected, %ld warning(s)\n" , ( ulong ) mysql_affected_rows ( mysql_local ) , ( ulong ) mysql_warning_count ( mysql_local ) ) ;\n<53> if ( rows [ count ] != exp_value ) {\n<54> fprintf ( stderr , "row %d had affected rows: %d, should be %d\n" , count , exp_value , rows [ count ] ) ;\n<57> if ( count != array_elements ( rows ) - 1 ) {\n<58> if ( ! ( rc = mysql_more_results ( mysql_local ) ) ) {\n<59> fprintf ( stdout , "mysql_more_result returned wrong value: %d for row %d\n" , rc , count ) ;
<1> static void parse_command_line ( int argc , const char * * argv_ , AppInput * app_input , SvcContext * svc_ctx , vpx_codec_enc_cfg_t * enc_cfg ) {\n<18> svc_ctx -> spatial_layers = default_spatial_layers ;\n<20> res = vpx_codec_enc_config_default ( vpx_codec_vp9_cx ( ) , enc_cfg , 0 ) ;\n<25> enc_cfg -> g_h = default_height ;\n<26> enc_cfg -> g_timebase . num = default_timebase_num ;\n<27> enc_cfg -> g_timebase . den = default_timebase_den ;\n<30> enc_cfg -> kf_max_dist = default_kf_dist ;\n<32> app_input -> frames_to_code = default_frames_to_code ;\n<33> app_input -> frames_to_skip = default_frames_to_skip ;\n<34> argv = argv_dup ( argc - 1 , argv_ + 1 ) ;\n<40> app_input -> frames_to_code = arg_parse_uint ( & arg ) ;\n<46> enc_cfg -> g_h = arg_parse_uint ( & arg ) ;\n<55> app_input -> frames_to_skip = arg_parse_uint ( & arg ) ;\n<58> svc_ctx -> spatial_layers = arg_parse_uint ( & arg ) ;\n<65> enc_cfg -> kf_max_dist = enc_cfg -> kf_min_dist ;\n<68> snprintf ( string_options , 1024 , "%s scale-factors=%s" , string_options , arg . val ) ;\n<86> snprintf ( string_options , 1024 , "%s min-quantizers=%s" , string_options , arg . val ) ;\n<89> snprintf ( string_options , 1024 , "%s max-quantizers=%s" , string_options , arg . val ) ;\n<101> if ( strlen ( string_options ) > 0 ) vpx_svc_set_options ( svc_ctx , string_options + 1 ) ;\n<103> if ( pass ) {\n<104> fprintf ( stderr , "pass is ignored since there's only one pass\n" ) ;\n<131> if ( enc_cfg -> rc_target_bitrate > 0 ) {\n<133> enc_cfg -> rc_2pass_vbr_minsection_pct = min_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n<136> enc_cfg -> rc_2pass_vbr_maxsection_pct = max_bitrate * 100 / enc_cfg -> rc_target_bitrate ;\n<139> for ( argi = argv ;\n<140> * argi ;\n<141> ++ argi ) if ( argi [ 0 ] [ 0 ] == '-' && strlen ( argi [ 0 ] ) > 1 ) die ( "Error: Unrecognized option %s\n" , * argi ) ;\n<142> if ( argv [ 0 ] == NULL || argv [ 1 ] == 0 ) {\n<147> free ( argv ) ;\n<148> if ( enc_cfg -> g_w < 16 || enc_cfg -> g_w % 2 || enc_cfg -> g_h < 16 || enc_cfg -> g_h % 2 ) die ( "Invalid resolution: %d x %d\n" , enc_cfg -> g_w , enc_cfg -> g_h ) ;\n<149> printf ( "Codec %s\nframes: %d, skip: %d\n" "layers: %d\n" "width %d, height: %d,\n" "num: %d, den: %d, bitrate: %d,\n" "gop size: %d\n" , vpx_codec_iface_name ( vpx_codec_vp9_cx ( ) ) , app_input -> frames_to_code , app_input -> frames_to_skip , svc_ctx -> spatial_layers , enc_cfg -> g_w , enc_cfg -> g_h , enc_cfg -> g_timebase . num , enc_cfg -> g_timebase . den , enc_cfg -> rc_target_bitrate , enc_cfg -> kf_max_dist ) ;
<1> int ff_lpc_calc_coefs(LPCContext *s,\n<79> if (lpc_type == FF_LPC_TYPE_CHOLESKY) {\n<87> memset(var, 0, FFALIGN(MAX_LPC_ORDER+1,4)*sizeof(*var));\n<117> eval= m[(pass-1)&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1);\n<119> eval= (512>>pass) + fabs(eval - var[0]);\n<127> var[j] *= rinv;\n<137> m[pass&1].update_lls(&m[pass&1], var);
<1> static int selinux_setprocattr ( struct task_struct * p , char * name , void * value , size_t size ) {\n<7> if ( current != p ) {\n<10> if ( ! strcmp ( name , "exec" ) ) error = current_has_perm ( p , PROCESS__SETEXEC ) ;\n<11> else if ( ! strcmp ( name , "fscreate" ) ) error = current_has_perm ( p , PROCESS__SETFSCREATE ) ;\n<12> else if ( ! strcmp ( name , "keycreate" ) ) error = current_has_perm ( p , PROCESS__SETKEYCREATE ) ;\n<13> else if ( ! strcmp ( name , "sockcreate" ) ) error = current_has_perm ( p , PROCESS__SETSOCKCREATE ) ;\n<14> else if ( ! strcmp ( name , "current" ) ) error = current_has_perm ( p , PROCESS__SETCURRENT ) ;\n<15> else error = - EINVAL ;\n<17> if ( size && str [ 0 ] && str [ 0 ] != '\n' ) {\n<23> if ( error == - EINVAL && ! strcmp ( name , "fscreate" ) ) {\n<24> if ( ! capable ( CAP_MAC_ADMIN ) ) {\n<37> if ( error ) return error ;\n<40> if ( ! new ) return - ENOMEM ;\n<42> if ( ! strcmp ( name , "exec" ) ) {\n<43> tsec -> exec_sid = sid ;\n<45> else if ( ! strcmp ( name , "fscreate" ) ) {\n<46> tsec -> create_sid = sid ;\n<48> else if ( ! strcmp ( name , "keycreate" ) ) {\n<49> error = may_create_key ( sid , p ) ;\n<50> if ( error ) goto abort_change ;\n<53> else if ( ! strcmp ( name , "sockcreate" ) ) {\n<54> tsec -> sockcreate_sid = sid ;\n<56> else if ( ! strcmp ( name , "current" ) ) {\n<57> error = - EINVAL ;\n<58> if ( sid == 0 ) goto abort_change ;\n<74> error = - EINVAL ;\n<77> commit_creds ( new ) ;\n<78> return size ;\n<79> abort_change : abort_creds ( new ) ;\n<80> return error ;
<1> void archputs ( const char * s , Archive * AH ) {\n<2> WriteData ( AH , s , strlen ( s ) ) ;
<1> kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) {\n<11> if ( entry == NULL ) return EINVAL ;\n<26> ret = get_policy ( handle , entry -> policy , & pol , & have_pol ) ;\n<27> if ( ret ) goto done ;\n<29> if ( adb . policy ) free ( adb . policy ) ;\n<30> adb . policy = strdup ( entry -> policy ) ;\n<42> if ( ( mask & KADM5_POLICY_CLR ) && ( adb . aux_attributes & KADM5_POLICY ) ) {\n<43> free ( adb . policy ) ;\n<77> ret = k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask ) ;\n<79> ret = kdb_put_entry ( handle , kdb , & adb ) ;\n<81> ( void ) k5_kadm5_hook_modify ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask ) ;\n<87> kdb_free_entry ( handle , kdb , & adb ) ;
<1> static struct pathelem *add_entry(struct pathelem *root, const char *name)\n<11> + sizeof(root->entries[0])*root->num_entries);\n<15> root->entries[root->num_entries-1] = new_entry(root->pathname, root, name);
<1> void rtp_parse_close(RTPDemuxContext *s)\n<9> if (!strcmp(ff_rtp_enc_name(s->payload_type), "MP2T")) {\n<11> ff_mpegts_parse_close(s->ts);
<1> static void prom_init(target_phys_addr_t addr, const char *bios_name)\n<35> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<57> if (ret < 0 || ret > PROM_SIZE_MAX) {\n<59> fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name);
<1> static void vga_reset(void *opaque)\n<5> VGAState *s = (VGAState *) opaque;\n<25> memset(s->sr, '\0', sizeof(s->sr));\n<29> memset(s->gr, '\0', sizeof(s->gr));\n<33> memset(s->ar, '\0', sizeof(s->ar));\n<39> memset(s->cr, '\0', sizeof(s->cr));\n<57> memset(s->dac_cache, '\0', sizeof(s->dac_cache));\n<61> memset(s->palette, '\0', sizeof(s->palette));\n<81> memset(s->font_offsets, '\0', sizeof(s->font_offsets));\n<115> memset(s->invalidated_y_table, '\0', sizeof(s->invalidated_y_table));\n<117> memset(s->last_palette, '\0', sizeof(s->last_palette));\n<119> memset(s->last_ch_attr, '\0', sizeof(s->last_ch_attr));\n<121> switch (vga_retrace_method) {\n<129> memset(&s->retrace_info, 0, sizeof (s->retrace_info));
<1> static int mov_write_video_tag(ByteIOContext *pb, MOVTrack* track)\n<7> char compressor_name[32];\n<71> put_be16(pb, 1); /* Frame count (= 1) */\n<75> memset(compressor_name,0,32);\n<77> if (track->enc->codec->name)\n<79> strncpy(compressor_name,track->enc->codec->name,31);\n<81> put_byte(pb, FFMAX(strlen(compressor_name),32) );\n<83> put_buffer(pb, compressor_name, 31);
<1> krb5_error_code krb5_ldap_get_principal ( krb5_context context , krb5_const_principal searchfor , unsigned int flags , krb5_db_entry * * entry_ptr ) {\n<2> char * user = NULL , * filter = NULL , * filtuser = NULL ;\n<5> char * * values = NULL , * * subtree = NULL , * cname = NULL ;\n<25> if ( ( st = krb5_unparse_name ( context , searchfor , & user ) ) != 0 ) goto cleanup ;\n<26> if ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) goto cleanup ;\n<27> filtuser = ldap_filter_correct ( user ) ;\n<28> if ( filtuser == NULL ) {\n<32> princlen = strlen ( FILTER ) + strlen ( filtuser ) + 2 + 1 ;\n<33> if ( ( filter = malloc ( princlen ) ) == NULL ) {\n<34> st = ENOMEM ;\n<38> if ( ( st = krb5_get_subtree_info ( ldap_context , & subtree , & ntrees ) ) != 0 ) goto cleanup ;\n<43> LDAP_SEARCH ( subtree [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes ) ;\n<45> ent != NULL && ! found ;\n<47> if ( ( values = ldap_get_values ( ld , ent , "krbprincipalname" ) ) != NULL ) {\n<50> values [ i ] != NULL ;\n<51> ++ i ) {\n<52> if ( strcmp ( values [ i ] , user ) == 0 ) {\n<53> found = TRUE ;\n<57> ldap_value_free ( values ) ;\n<60> if ( ( values = ldap_get_values ( ld , ent , "krbcanonicalname" ) ) != NULL ) {\n<61> if ( values [ 0 ] && strcmp ( values [ 0 ] , user ) != 0 ) {\n<62> if ( flags & KRB5_KDB_FLAG_ALIAS_OK ) {\n<63> st = krb5_ldap_parse_principal_name ( values [ 0 ] , & cname ) ;\n<65> st = krb5_parse_name ( context , cname , & cprinc ) ;\n<70> ldap_value_free ( values ) ;\n<71> if ( ! found ) continue ;\n<82> entry = NULL ;\n<87> if ( filter ) free ( filter ) ;\n<88> if ( subtree ) {\n<91> -- ntrees ) if ( subtree [ ntrees - 1 ] ) free ( subtree [ ntrees - 1 ] ) ;\n<92> free ( subtree ) ;\n<95> if ( user ) free ( user ) ;\n<96> if ( filtuser ) free ( filtuser ) ;\n<97> if ( cname ) free ( cname ) ;
<1> static inline int wv_unpack_stereo(WavpackFrameContext *s, GetBitContext *gb,\n<3> void *dst_l, void *dst_r, const int type)\n<241> if (last && count < s->samples) {\n<245> memset((uint8_t*)dst_l + count*size, 0, (s->samples-count)*size);\n<247> memset((uint8_t*)dst_r + count*size, 0, (s->samples-count)*size);
<1> int main ( int argc , char * * argv ) {\n<3> if ( argc != 2 ) {\n<4> fprintf ( stderr , "One argument, the input filename, must be provided.\n" ) ;\n<9> fprintf ( stdout , "Processing %s => %s\n" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n<16> if ( ! woff2 : : ConvertTTFToWOFF2 ( input_data , input . size ( ) , output_data , & output_size , params ) ) {\n<17> fprintf ( stderr , "Compression failed.\n" ) ;
<1> static int pfkey_process ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr ) {\n<5> memset ( ext_hdrs , 0 , sizeof ( ext_hdrs ) ) ;\n<6> err = parse_exthdrs ( skb , hdr , ext_hdrs ) ;
<1> void error_setg_errno(Error **errp, int os_errno, const char *fmt, ...)\n<29> if (os_errno != 0) {\n<31> msg = (*errp)->msg;\n<33> (*errp)->msg = g_strdup_printf("%s: %s", msg, strerror(os_errno));\n<35> g_free(msg);
<1> static void qio_channel_websock_handshake_process ( QIOChannelWebsock * ioc , char * buffer , Error * * errp ) {\n<20> if ( ! key ) {\n<43> if ( ! g_str_equal ( version , QIO_CHANNEL_WEBSOCK_SUPPORTED_VERSION ) ) {\n<47> if ( strlen ( key ) != QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN ) {\n<48> error_setg ( errp , "Key length '%zu' was not as expected '%d'" , strlen ( key ) , QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN ) ;\n<51> if ( strcasecmp ( connection , QIO_CHANNEL_WEBSOCK_CONNECTION_UPGRADE ) != 0 ) {\n<59> qio_channel_websock_handshake_send_res_ok ( ioc , key , errp ) ;\n<61> bad_request : qio_channel_websock_handshake_send_res_err ( ioc , QIO_CHANNEL_WEBSOCK_HANDSHAKE_RES_BAD_REQUEST ) ;
<1> aio_write_f(int argc, char **argv)\n<9> struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n<15> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<53> ctx->offset = cvtnum(argv[optind]);\n<55> if (ctx->offset < 0) {\n<57> printf("non-numeric length argument -- %s\n", argv[optind]);\n<67> if (ctx->offset & 0x1ff) {\n<71> (long long)ctx->offset);\n<81> ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n<85> gettimeofday(&ctx->t1, NULL);\n<87> acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,
<1> void stellaris_enet_init(NICInfo *nd, uint32_t base, qemu_irq irq)\n<11> qemu_check_nic_model(nd, "stellaris");\n<17> iomemtype = cpu_register_io_memory(0, stellaris_enet_readfn,\n<25> memcpy(s->macaddr, nd->macaddr, 6);\n<31> s->vc = qemu_new_vlan_client(nd->vlan, nd->model, nd->name,\n<35> qemu_format_nic_info_str(s->vc, s->macaddr);\n<41> stellaris_enet_reset(s);
<1> int xen_pt_msix_init(XenPCIPassthroughState *s, uint32_t base)\n<97> if (fd == -1) {\n<99> rc = -errno;\n<101> XEN_PT_ERR(d, "Can't open /dev/mem: %s\n", strerror(errno));\n<129> if (msix->phys_iomem_base == MAP_FAILED) {\n<131> rc = -errno;\n<133> XEN_PT_ERR(d, "Can't map physical MSI-X table: %s\n", strerror(errno));
<1> static void vga_draw_graphic(VGACommonState *s, int full_update)\n<207> if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n<223> if (sr(s, VGA_SEQ_CLOCK_MODE) & 8) {\n<237> switch(s->get_bpp(s)) {\n<243> full_update |= update_palette256(s);\n<253> full_update |= update_palette256(s);\n<303> s->cursor_invalidate(s);\n<341> vga_sync_dirty_bitmap(s);\n<403> update |= vga_scanline_invalidated(s, y);\n<413> vga_draw_line(s, d, s->vram_ptr + addr, width);\n<417> s->cursor_draw_line(s, d, y);\n<477> memset(s->invalidated_y_table, 0, sizeof(s->invalidated_y_table));
<1> static int sd_snapshot_goto(BlockDriverState *bs, const char *snapshot_id)\n<5> BDRVSheepdogState *s = bs->opaque;\n<17> old_s = g_malloc(sizeof(BDRVSheepdogState));\n<21> memcpy(old_s, s, sizeof(BDRVSheepdogState));\n<39> ret = reload_inode(s, snapid, tag);\n<41> if (ret) {\n<49> ret = sd_create_branch(s);\n<51> if (ret) {\n<59> g_free(old_s);\n<69> memcpy(s, old_s, sizeof(BDRVSheepdogState));\n<71> g_free(old_s);
<1> static void combined_read_cb ( int fd , short event , void * arg ) {\n<6> if ( len == - 1 ) fprintf ( stderr , "%s: read\n" , __func__ ) ;
<25> header_size = decode_mime_header ( ctx , buf ) ;\n<37> if ( ctx -> fr_cur_mode == MODE_SID ) {\n<50> stab_fac = stability_factor ( ctx -> isf_cur , ctx -> isf_past_final ) ;\n<51> ctx -> isf_cur [ LP_ORDER - 1 ] *= 2.0 ;\n<52> ff_acelp_lsf2lspd ( ctx -> isp [ 3 ] , ctx -> isf_cur , LP_ORDER ) ;\n<53> if ( ctx -> first_frame ) {\n<55> memcpy ( ctx -> isp_sub4_past , ctx -> isp [ 3 ] , LP_ORDER * sizeof ( double ) ) ;\n<57> interpolate_isp ( ctx -> isp , ctx -> isp_sub4_past ) ;\n<90> hb_synthesis ( ctx , sub , & ctx -> samples_hb [ LP_ORDER_16k ] , hb_exc , ctx -> isf_cur , ctx -> isf_past_final ) ;\n<96> update_sub_state ( ctx ) ;\n<98> memcpy ( ctx -> isp_sub4_past , ctx -> isp [ 3 ] , LP_ORDER * sizeof ( ctx -> isp [ 3 ] [ 0 ] ) ) ;\n<99> memcpy ( ctx -> isf_past_final , ctx -> isf_cur , LP_ORDER * sizeof ( float ) ) ;
<1> static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n<43> if (avctx->skip_frame >= skip_thresh) {\n<111> if ((ret = vp8_alloc_frame(s, curframe))) {\n<167> if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n<193> memset(s->top_nnz, 0, s->mb_width*sizeof(*s->top_nnz));\n<199> memset(s->macroblocks + s->mb_height*2 - 1, 0, (s->mb_width+1)*sizeof(*s->macroblocks));\n<205> if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {\n<209> memset(s->top_border[1]-1, 127, s->mb_width*sizeof(*s->top_border)+1);\n<213> memset(s->ref_count, 0, sizeof(s->ref_count));\n<215> if (s->keyframe)\n<217> memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width*4);\n<229> for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n<249> memset(mb - 1, 0, sizeof(*mb));   // zero left macroblock\n<251> memset(s->left_nnz, 0, sizeof(s->left_nnz));\n<253> AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED*0x01010101);\n<295> decode_mb_mode(s, mb, mb_x, mb_y, curframe->ref_index[0] + mb_xy,\n<301> prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);\n<307> decode_mb_coeffs(s, c, mb, s->top_nnz[mb_x], s->left_nnz);\n<313> intra_predict(s, dst, mb, mb_x, mb_y);\n<317> inter_predict(s, dst, mb, mb_x, mb_y);\n<321> prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);\n<327> idct_mb(s, dst, mb);\n<331> AV_ZERO64(s->left_nnz);\n<341> s->left_nnz[8]      = 0;\n<353> filter_level_for_mb(s, mb, &s->filter_strength[mb_x]);\n<357> prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);\n<377> filter_mb_row_simple(s, curframe, mb_y);\n<381> filter_mb_row(s, curframe, mb_y);\n<411> memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);
<1> static void sig_message_own_public ( SERVER_REC * server , const char * msg , const char * target , const char * origtarget ) {\n<6> g_return_if_fail ( msg != NULL ) ;\n<9> if ( channel == NULL ) return ;\n<10> p = strchr ( msg , ' ' ) ;\n<11> if ( p != NULL && p != msg ) {\n<12> msgnick = g_strndup ( msg , ( int ) ( p - msg ) ) ;\n<13> nick = nicklist_find ( channel , msgnick ) ;\n<14> if ( nick == NULL && msgnick [ 1 ] != '\0' ) {\n<15> msgnick [ strlen ( msgnick ) - 1 ] = '\0' ;\n<16> nick = nicklist_find ( channel , msgnick ) ;\n<18> g_free ( msgnick ) ;
<1> int pcnet_common_init(DeviceState *dev, PCNetState *s, NetClientInfo *info)\n<17> s->nic = qemu_new_nic(info, &s->conf, object_get_typename(OBJECT(dev)), dev->id, s);\n<19> qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n<35> memcpy(s->prom, s->conf.macaddr.a, 6);\n<73> *(uint16_t *)&s->prom[12] = cpu_to_le16(checksum);
<1> static int scaling_list_data(GetBitContext *gb, AVCodecContext *avctx, ScalingList *sl, HEVCSPS *sps)\n<33> if (matrix_id < delta) {\n<99> sl->sl[size_id][matrix_id][pos] = next_coef;
<1> static void psy_3gpp_analyze_channel(FFPsyContext *ctx, int channel,\n<9> AacPsyChannel *pch  = &pctx->ch[channel];\n<363> memcpy(pch->prev_band, pch->band, sizeof(pch->band));
<1> static int config_connection_request ( struct config_connection * conn , const char * const * args ) {\n<14> else if ( strncmp ( * args , "module=" , 7 ) == 0 ) {\n<15> module = * args + 7 ;\n<16> if ( strcmp ( module , "master" ) == 0 ) is_master = TRUE ;\n<17> array_append ( & modules , & module , 1 ) ;
<1> int av_open_input_file(AVFormatContext **ic_ptr, const char *filename,\n<13> AVProbeData probe_data, *pd = &probe_data;\n<35> fmt = av_probe_input_format(pd, 0);\n<63> for(probe_size= PROBE_BUF_MIN; probe_size<=PROBE_BUF_MAX && !fmt; probe_size<<=1){\n<69> pd->buf= av_realloc(pd->buf, probe_size + AVPROBE_PADDING_SIZE);\n<71> pd->buf_size = get_buffer(pb, pd->buf, probe_size);\n<73> memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n<93> fmt = av_probe_input_format2(pd, 1, &score);
<1> static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n<23> ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n<25> if (ret < 0) {\n<33> if (strcmp(bochs.magic, HEADER_MAGIC) ||\n<35> strcmp(bochs.type, REDOLOG_TYPE) ||\n<37> strcmp(bochs.subtype, GROWING_TYPE) ||\n<39> ((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n<43> error_setg(errp, "Image not in Bochs format");\n<45> return -EINVAL;\n<51> if (le32_to_cpu(bochs.version) == HEADER_V1) {\n<53> memcpy(&header_v1, &bochs, sizeof(bochs));\n<65> s->catalog_size = le32_to_cpu(bochs.extra.redolog.catalog);\n<67> s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n<71> ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n<73> s->catalog_size * 4);\n<75> if (ret < 0) {
<1> static void * jbig2_default_alloc ( Jbig2Allocator * allocator , size_t size ) {\n<2> return malloc ( size ) ;
<1> static void ffmpeg_InitCodec ( decoder_t * p_dec ) {\n<4> if ( ! i_size ) return ;\n<9> if ( ! p ) return ;\n<10> memcpy ( & p [ 0 ] , "SVQ3" , 4 ) ;\n<11> memset ( & p [ 4 ] , 0 , 8 ) ;\n<12> memcpy ( & p [ 12 ] , p_dec -> fmt_in . p_extra , i_size ) ;\n<13> if ( p_sys -> p_context -> extradata_size > 0x5a && strncmp ( ( char * ) & p [ 0x56 ] , "SMI " , 4 ) ) {\n<14> uint8_t * psz = & p [ 0x52 ] ;\n<15> while ( psz < & p [ p_sys -> p_context -> extradata_size - 8 ] ) {\n<16> int i_size = GetDWBE ( psz ) ;\n<20> if ( ! strncmp ( ( char * ) & psz [ 4 ] , "SMI " , 4 ) ) {\n<21> memmove ( & p [ 0x52 ] , psz , & p [ p_sys -> p_context -> extradata_size ] - psz ) ;\n<30> p_sys -> p_context -> extradata = av_malloc ( i_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<31> if ( p_sys -> p_context -> extradata ) {\n<32> memcpy ( p_sys -> p_context -> extradata , p_dec -> fmt_in . p_extra , i_size ) ;\n<33> memset ( p_sys -> p_context -> extradata + i_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;
<1> int test_mod_mul ( BIO * bp , BN_CTX * ctx ) {\n<22> while ( ( l = ERR_get_error ( ) ) ) fprintf ( stderr , "ERROR:%s\n" , ERR_error_string ( l , NULL ) ) ;\n<44> if ( ! BN_is_zero ( b ) ) {\n<45> fprintf ( stderr , "Modulo multiply test failed!\n" ) ;\n<46> ERR_print_errors_fp ( stderr ) ;
<1> static int decode_subframe ( WMAProDecodeCtx * s ) {\n<134> if ( s -> channel [ c ] . transmit_coefs && get_bits_count ( & s -> gb ) < s -> num_saved_bits ) {\n<137> else memset ( s -> channel [ c ] . coeffs , 0 , sizeof ( * s -> channel [ c ] . coeffs ) * subframe_len ) ;\n<149> if ( c == s -> lfe_channel ) memset ( & s -> tmp [ cur_subwoofer_cutoff ] , 0 , sizeof ( * s -> tmp ) * ( subframe_len - cur_subwoofer_cutoff ) ) ;\n<157> s -> fdsp . vector_fmul_scalar ( s -> tmp + start , s -> channel [ c ] . coeffs + start , quant , end - start ) ;\n<159> mdct -> imdct_half ( mdct , s -> channel [ c ] . coeffs , s -> tmp ) ;
<1> static void dumpCreateDB ( PGconn * conn ) {\n<3> char * default_encoding = NULL ;\n<4> char * default_collate = NULL ;\n<5> char * default_ctype = NULL ;\n<8> fprintf ( OPF , "--\n-- Database creation\n--\n\n" ) ;\n<13> if ( ! PQgetisnull ( res , 0 , 0 ) ) default_encoding = pg_strdup ( PQgetvalue ( res , 0 , 0 ) ) ;\n<14> if ( ! PQgetisnull ( res , 0 , 1 ) ) default_collate = pg_strdup ( PQgetvalue ( res , 0 , 1 ) ) ;\n<15> if ( ! PQgetisnull ( res , 0 , 2 ) ) default_ctype = pg_strdup ( PQgetvalue ( res , 0 , 2 ) ) ;\n<29> i < PQntuples ( res ) ;\n<32> char * dbowner = PQgetvalue ( res , i , 1 ) ;\n<33> char * dbencoding = PQgetvalue ( res , i , 2 ) ;\n<34> char * dbcollate = PQgetvalue ( res , i , 3 ) ;\n<35> char * dbctype = PQgetvalue ( res , i , 4 ) ;\n<38> char * dbistemplate = PQgetvalue ( res , i , 7 ) ;\n<39> char * dbacl = PQgetvalue ( res , i , 8 ) ;\n<41> char * dbconnlimit = PQgetvalue ( res , i , 10 ) ;\n<42> char * dbtablespace = PQgetvalue ( res , i , 11 ) ;\n<44> fdbname = pg_strdup ( fmtId ( dbname ) ) ;\n<45> resetPQExpBuffer ( buf ) ;\n<46> if ( strcmp ( dbname , "template1" ) != 0 && strcmp ( dbname , "postgres" ) != 0 ) {\n<47> appendPQExpBuffer ( buf , "CREATE DATABASE %s" , fdbname ) ;\n<48> appendPQExpBufferStr ( buf , " WITH TEMPLATE = template0" ) ;\n<49> if ( strlen ( dbowner ) != 0 ) appendPQExpBuffer ( buf , " OWNER = %s" , fmtId ( dbowner ) ) ;\n<50> if ( default_encoding && strcmp ( dbencoding , default_encoding ) != 0 ) {\n<51> appendPQExpBufferStr ( buf , " ENCODING = " ) ;\n<52> appendStringLiteralConn ( buf , dbencoding , conn ) ;\n<54> if ( default_collate && strcmp ( dbcollate , default_collate ) != 0 ) {\n<55> appendPQExpBufferStr ( buf , " LC_COLLATE = " ) ;\n<56> appendStringLiteralConn ( buf , dbcollate , conn ) ;\n<58> if ( default_ctype && strcmp ( dbctype , default_ctype ) != 0 ) {\n<59> appendPQExpBufferStr ( buf , " LC_CTYPE = " ) ;\n<60> appendStringLiteralConn ( buf , dbctype , conn ) ;\n<62> if ( strcmp ( dbtablespace , "pg_default" ) != 0 && ! no_tablespaces ) appendPQExpBuffer ( buf , " TABLESPACE = %s" , fmtId ( dbtablespace ) ) ;\n<63> if ( strcmp ( dbistemplate , "t" ) == 0 ) appendPQExpBuffer ( buf , " IS_TEMPLATE = true" ) ;\n<64> if ( strcmp ( dbconnlimit , "-1" ) != 0 ) appendPQExpBuffer ( buf , " CONNECTION LIMIT = %s" , dbconnlimit ) ;\n<68> else if ( strcmp ( dbtablespace , "pg_default" ) != 0 && ! no_tablespaces ) {\n<69> if ( strcmp ( dbname , "postgres" ) == 0 ) appendPQExpBuffer ( buf , "\\connect template1\n" ) ;\n<70> else appendPQExpBuffer ( buf , "\\connect postgres\n" ) ;\n<76> appendPQExpBufferStr ( buf , "-- For binary upgrade, set datfrozenxid and datminmxid.\n" ) ;\n<77> appendPQExpBuffer ( buf , "UPDATE pg_catalog.pg_database " "SET datfrozenxid = '%u', datminmxid = '%u' " "WHERE datname = " , dbfrozenxid , dbminmxid ) ;\n<78> appendStringLiteralConn ( buf , dbname , conn ) ;\n<82> if ( ! skip_acls && ! buildACLCommands ( fdbname , NULL , "DATABASE" , dbacl , rdbacl , dbowner , "" , server_version , buf ) ) {\n<83> fprintf ( stderr , _ ( "%s: could not parse ACL list (%s) for database \"%s\"\n" ) , progname , dbacl , fdbname ) ;\n<87> fprintf ( OPF , "%s" , buf -> data ) ;\n<88> if ( server_version >= 70300 ) dumpDatabaseConfig ( conn , dbname ) ;\n<89> free ( fdbname ) ;\n<91> if ( default_encoding ) free ( default_encoding ) ;\n<92> if ( default_collate ) free ( default_collate ) ;\n<93> if ( default_ctype ) free ( default_ctype ) ;\n<95> destroyPQExpBuffer ( buf ) ;\n<96> fprintf ( OPF , "\n\n" ) ;
<1> void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n<9> const char *data = qdict_get_str(qdict, "data");\n<15> size = strlen(data);\n<17> qmp_memchar_write(chardev, size, data, false, 0, &errp);
<1> static uint32_t eepro100_read4(EEPRO100State * s, uint32_t addr)\n<7> if (addr <= sizeof(s->mem) - sizeof(val)) {\n<9> memcpy(&val, &s->mem[addr], sizeof(val));\n<19> TRACE(OTHER, logout("addr=%s val=0x%08x\n", regname(addr), val));\n<31> TRACE(OTHER, logout("addr=%s val=0x%08x\n", regname(addr), val));\n<39> TRACE(OTHER, logout("addr=%s val=0x%08x\n", regname(addr), val));\n<51> logout("addr=%s val=0x%08x\n", regname(addr), val);\n<57> return val;
<1> void mips_malta_init (ram_addr_t ram_size,\n<91> if (!env) {\n<93> fprintf(stderr, "Unable to find CPU definition\n");\n<105> if (ram_size > (256 << 20)) {\n<111> ((unsigned int)ram_size / (1 << 20)));\n<207> filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n<223> if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n<299> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<301> fprintf(stderr, "qemu: too many IDE bus\n");
<1> static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt,\n<63> if(!vidbuf_start)\n<89> if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], 2) != 2) {\n<107> if(!vidbuf_start)\n<115> vidbuf_start[vidbuf_nbytes++] = code;\n<123> vidbuf_start[vidbuf_nbytes++] = avio_r8(pb);\n<127> if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], code) != code) {\n<167> if ((ret = av_new_packet(pkt, vidbuf_nbytes)) < 0)\n<171> memcpy(pkt->data, vidbuf_start, vidbuf_nbytes);\n<173> av_free(vidbuf_start);\n<191> if (vid->palette) {\n<193> uint8_t *pdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n<197> memcpy(pdata, vid->palette, BVID_PALETTE_SIZE);\n<199> av_freep(&vid->palette);
<1> gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,\n<17> if (search_pc && loglevel)\n<19> fprintf (logfile, "search pc %d\n", search_pc);
<1> void proto_registrar_dump_fields ( void ) {\n<36> if ( blurb == NULL ) blurb = "" ;\n<37> else if ( strlen ( blurb ) == 0 ) blurb = "\"\"" ;
<5> ar = ( struct ar * ) ( a -> format -> data ) ;\n<12> if ( * p != '\n' ) goto bad_string_table ;\n<16> if ( p != ar -> strtab + size && * p != '\n' && * p != '`' ) goto bad_string_table ;\n<20> free ( ar -> strtab ) ;
<1> static int gettimerpid ( char * name , int cpu ) {\n<4> if ( name == NULL ) name = & temp [ 0 ] ;\n<5> sprintf ( name , "softirq-timer/%d" , cpu ) ;\n<6> pid = name2pid ( name ) ;\n<7> if ( pid == - 1 ) {\n<8> sprintf ( name , "ksoftirqd/%d" , cpu ) ;\n<9> pid = name2pid ( name ) ;
<1> static int aio_write_f(int argc, char **argv)\n<9> struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));\n<15> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<64> ctx->offset = cvtnum(argv[optind]);\n<66> if (ctx->offset < 0) {\n<68> printf("non-numeric length argument -- %s\n", argv[optind]);\n<79> if (ctx->offset & 0x1ff) {\n<94> ctx->buf = create_iovec(&ctx->qiov, &argv[optind], nr_iov, pattern);\n<98> gettimeofday(&ctx->t1, NULL);\n<100> acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n<104> if (!acb) {\n<106> free(ctx->buf);
<242> for (x = 0; x < avctx->height; x++) {\n<244> memcpy(ptr, buf, target_packet_size*avctx->width);
<1> int ff_hevc_decode_nal_pps(GetBitContext *gb, AVCodecContext *avctx,\n<23> if (!pps)\n<33> if (!pps_buf) {\n<47> nal_size = gb->buffer_end - gb->buffer;\n<57> pps->data_size = sizeof(pps->data);\n<61> pps->data_size = nal_size;\n<65> memcpy(pps->data, gb->buffer, pps->data_size);\n<91> pps_id = get_ue_golomb_long(gb);\n<103> pps->sps_id = get_ue_golomb_long(gb);\n<129> pps->dependent_slice_segments_enabled_flag = get_bits1(gb);\n<131> pps->output_flag_present_flag              = get_bits1(gb);\n<133> pps->num_extra_slice_header_bits           = get_bits(gb, 3);\n<137> pps->sign_data_hiding_flag = get_bits1(gb);\n<141> pps->cabac_init_present_flag = get_bits1(gb);\n<145> pps->num_ref_idx_l0_default_active = get_ue_golomb_long(gb) + 1;\n<147> pps->num_ref_idx_l1_default_active = get_ue_golomb_long(gb) + 1;\n<151> pps->pic_init_qp_minus26 = get_se_golomb(gb);\n<155> pps->constrained_intra_pred_flag = get_bits1(gb);\n<157> pps->transform_skip_enabled_flag = get_bits1(gb);\n<161> pps->cu_qp_delta_enabled_flag = get_bits1(gb);\n<167> pps->diff_cu_qp_delta_depth = get_ue_golomb_long(gb);\n<187> pps->cb_qp_offset = get_se_golomb(gb);\n<201> pps->cr_qp_offset = get_se_golomb(gb);\n<215> pps->pic_slice_level_chroma_qp_offsets_present_flag = get_bits1(gb);\n<219> pps->weighted_pred_flag   = get_bits1(gb);\n<221> pps->weighted_bipred_flag = get_bits1(gb);\n<225> pps->transquant_bypass_enable_flag    = get_bits1(gb);\n<227> pps->tiles_enabled_flag               = get_bits1(gb);\n<229> pps->entropy_coding_sync_enabled_flag = get_bits1(gb);\n<235> pps->num_tile_columns = get_ue_golomb_long(gb) + 1;\n<237> pps->num_tile_rows    = get_ue_golomb_long(gb) + 1;\n<283> pps->uniform_spacing_flag = get_bits1(gb);\n<291> pps->column_width[i] = get_ue_golomb_long(gb) + 1;\n<315> pps->row_height[i] = get_ue_golomb_long(gb) + 1;\n<335> pps->loop_filter_across_tiles_enabled_flag = get_bits1(gb);\n<341> pps->seq_loop_filter_across_slices_enabled_flag = get_bits1(gb);\n<345> pps->deblocking_filter_control_present_flag = get_bits1(gb);\n<349> pps->deblocking_filter_override_enabled_flag = get_bits1(gb);\n<351> pps->disable_dbf                             = get_bits1(gb);\n<355> int beta_offset_div2 = get_se_golomb(gb);\n<357> int tc_offset_div2   = get_se_golomb(gb) ;\n<393> pps->scaling_list_data_present_flag = get_bits1(gb);\n<399> ret = scaling_list_data(gb, avctx, &pps->scaling_list, sps);\n<407> pps->lists_modification_present_flag = get_bits1(gb);\n<409> pps->log2_parallel_merge_level       = get_ue_golomb_long(gb) + 2;\n<425> pps->slice_header_extension_present_flag = get_bits1(gb);\n<429> if (get_bits1(gb)) { // pps_extension_present_flag\n<431> int pps_range_extensions_flag = get_bits1(gb);\n<433> /* int pps_extension_7bits = */ get_bits(gb, 7);\n<437> if ((ret = pps_range_extensions(gb, avctx, pps, sps)) < 0)\n<447> ret = setup_pps(avctx, gb, pps, sps);\n<455> if (get_bits_left(gb) < 0) {\n<459> "Overread PPS by %d bits\n", -get_bits_left(gb));
<1> static int webm_dash_manifest_cues(AVFormatContext *s, int64_t init_range)\n<115> strcpy(buf, "");\n<134> if (i != s->streams[0]->nb_index_entries - 1) {\n<136> strncat(buf, ",", sizeof(char));\n<144> av_dict_set(&s->streams[0]->metadata, CUE_TIMESTAMPS, buf, 0);
<1> static int draw_slice(AVFilterLink *inlink, int y0, int h, int slice_dir)\n<37> } else if (cur_buf->linesize[A] == out_buf->linesize[Y]) {\n<41> memcpy(out_buf->data[Y] + y0 * linesize,\n<43> cur_buf->data[A] + y0 * linesize,\n<45> linesize * h);\n<49> const int linesize = FFMIN(out_buf->linesize[Y], cur_buf->linesize[A]);\n<53> for (y = y0; y < (y0 + h); y++) {\n<55> memcpy(out_buf->data[Y] + y * out_buf->linesize[Y],\n<57> cur_buf->data[A] + y * cur_buf->linesize[A],
<1> static int slirp_smb ( SlirpState * s , const char * exported_dir , struct in_addr vserver_addr ) {\n<7> if ( ! passwd ) {\n<15> if ( access ( exported_dir , R_OK | X_OK ) ) {\n<16> error_report ( "error accessing shared directory '%s': %s" , exported_dir , strerror ( errno ) ) ;\n<25> snprintf ( smb_conf , sizeof ( smb_conf ) , "%s/%s" , s -> smb_dir , "smb.conf" ) ;\n<27> if ( ! f ) {\n<32> fprintf ( f , "[global]\n" "private dir=%s\n" "interfaces=127.0.0.1\n" "bind interfaces only=yes\n" "pid directory=%s\n" "lock directory=%s\n" "state directory=%s\n" "cache directory=%s\n" "ncalrpc dir=%scalrpc\n" "log file=%s/log.smbd\n" "smb passwd file=%s/smbpasswd\n" "security = user\n" "map to guest = Bad User\n" "load printers = no\n" "printing = bsd\n" "disable spoolss = yes\n" "usershare max shares = 0\n" "[qemu]\n" "path=%s\n" "read only=no\n" "guest ok=yes\n" "force user=%s\n" , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , s -> smb_dir , exported_dir , passwd -> pw_name ) ;\n<33> fclose ( f ) ;\n<34> snprintf ( smb_cmdline , sizeof ( smb_cmdline ) , "%s -l %s -s %s" , CONFIG_SMBD_COMMAND , s -> smb_dir , smb_conf ) ;
<1> static int handle_connect_error(URLContext *s, const char *desc)\n<7> char buf[300], *ptr, authmod[15];\n<17> if (!(cptr = strstr(desc, "authmod=adobe")) &&\n<19> !(cptr = strstr(desc, "authmod=llnw"))) {\n<25> return AVERROR_UNKNOWN;\n<29> cptr += strlen("authmod=");\n<31> while (*cptr && *cptr != ' ' && i < sizeof(authmod) - 1)\n<33> authmod[i++] = *cptr++;\n<35> authmod[i] = '\0';\n<39> if (!rt->username[0] || !rt->password[0]) {\n<49> if (strstr(desc, "?reason=authfailed")) {\n<51> av_log(s, AV_LOG_ERROR, "Incorrect username/password\n");\n<53> return AVERROR_UNKNOWN;\n<55> } else if (strstr(desc, "?reason=nosuchuser")) {\n<57> av_log(s, AV_LOG_ERROR, "Incorrect username\n");\n<59> return AVERROR_UNKNOWN;\n<65> if (rt->auth_tried) {\n<79> if (strstr(desc, "code=403 need auth")) {\n<81> snprintf(rt->auth_params, sizeof(rt->auth_params),\n<83> "?authmod=%s&user=%s", authmod, rt->username);\n<85> return 0;\n<91> if (!(cptr = strstr(desc, "?reason=needauth"))) {\n<93> av_log(s, AV_LOG_ERROR, "No auth parameters found\n");\n<95> return AVERROR_UNKNOWN;\n<101> av_strlcpy(buf, cptr + 1, sizeof(buf));\n<103> ptr = buf;\n<107> while (ptr) {\n<109> char *next  = strchr(ptr, '&');\n<111> char *value = strchr(ptr, '=');\n<115> *next++ = '\0';\n<119> *value++ = '\0';\n<121> if (!strcmp(ptr, "user")) {\n<123> user = value;\n<125> } else if (!strcmp(ptr, "salt")) {\n<127> salt = value;\n<129> } else if (!strcmp(ptr, "opaque")) {\n<131> opaque = value;\n<133> } else if (!strcmp(ptr, "challenge")) {\n<135> challenge = value;\n<137> } else if (!strcmp(ptr, "nonce")) {\n<139> nonce = value;\n<143> ptr = next;\n<149> if (!strcmp(authmod, "adobe")) {\n<151> if ((ret = do_adobe_auth(rt, user, salt, opaque, challenge)) < 0)\n<157> if ((ret = do_llnw_auth(rt, user, nonce)) < 0)
<1> static void print_gss_error ( OM_uint32 err_maj , OM_uint32 err_min ) {\n<8> maj_stat = gss_display_status ( & min_stat , err_maj , GSS_C_GSS_CODE , GSS_C_NO_OID , & msg_ctx , & status_string ) ;\n<9> if ( GSS_ERROR ( maj_stat ) ) break ;\n<11> if ( status_len >= sizeof ( buf_maj ) ) status_len = sizeof ( buf_maj ) - 1 ;\n<12> strncpy ( buf_maj , ( char * ) status_string . value , status_len ) ;\n<13> buf_maj [ status_len ] = '\0' ;\n<14> gss_release_buffer ( & min_stat , & status_string ) ;\n<15> maj_stat = gss_display_status ( & min_stat , err_min , GSS_C_MECH_CODE , GSS_C_NULL_OID , & msg_ctx , & status_string ) ;\n<16> if ( ! GSS_ERROR ( maj_stat ) ) {\n<18> if ( status_len >= sizeof ( buf_min ) ) status_len = sizeof ( buf_min ) - 1 ;\n<19> strncpy ( buf_min , ( char * ) status_string . value , status_len ) ;\n<20> buf_min [ status_len ] = '\0' ;\n<25> mutt_debug ( 2 , "((%s:%d )(%s:%d))\n" , buf_maj , err_maj , buf_min , err_min ) ;
<1> void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n<9> memset(&surface, 0, sizeof(surface));\n<39> qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);
<1> int av_image_fill_linesizes ( int linesizes [ 4 ] , enum PixelFormat pix_fmt , int width ) {\n<6> memset ( linesizes , 0 , 4 * sizeof ( linesizes [ 0 ] ) ) ;
<1> static int old_codec37(SANMVideoContext *ctx, int top,\n<53> rotate_bufs(ctx, 1);\n<57> dst  = ((uint8_t*)ctx->frm0) + left + top * stride;\n<73> switch (compr) {\n<85> memset(ctx->frm1, 0, ctx->height * stride);\n<87> memset(ctx->frm2, 0, ctx->height * stride);\n<93> if (rle_decode(ctx, dst, decoded_size))\n<97> memset(ctx->frm1, 0, ctx->frm1_size);\n<99> memset(ctx->frm2, 0, ctx->frm2_size);\n<111> for (i = 0; i < width; i += 4) {\n<151> for (k = 0; k < 4; k++)\n<153> memset(dst + i + k * stride, bytestream2_get_byteu(&ctx->gb), 4);\n<163> t = bytestream2_get_byteu(&ctx->gb);\n<165> for (k = 0; k < 4; k++)\n<167> memset(dst + i + k * stride, t, 4);\n<203> dst  += stride * 4;
<1> static int matroska_parse_tracks ( AVFormatContext * s ) {\n<9> MatroskaTrack * track = & tracks [ i ] ;\n<15> int extradata_offset = 0 ;\n<21> if ( ! track -> codec_id ) continue ;\n<40> int ret = matroska_decode_buffer ( & track -> codec_priv . data , & track -> codec_priv . size , track ) ;\n<46> if ( codec_priv != track -> codec_priv . data ) av_free ( codec_priv ) ;\n<50> ff_mkv_codec_tags [ j ] . id != AV_CODEC_ID_NONE ;\n<52> if ( ! strncmp ( ff_mkv_codec_tags [ j ] . str , track -> codec_id , strlen ( ff_mkv_codec_tags [ j ] . str ) ) ) {\n<58> if ( ! st ) return AVERROR ( ENOMEM ) ;\n<59> if ( ! strcmp ( track -> codec_id , "V_MS/VFW/FOURCC" ) && track -> codec_priv . size >= 40 && track -> codec_priv . data ) {\n<60> track -> ms_compat = 1 ;\n<61> track -> video . fourcc = AV_RL32 ( track -> codec_priv . data + 16 ) ;\n<62> codec_id = ff_codec_get_id ( ff_codec_bmp_tags , track -> video . fourcc ) ;\n<63> extradata_offset = 40 ;\n<65> else if ( ! strcmp ( track -> codec_id , "A_MS/ACM" ) && track -> codec_priv . size >= 14 && track -> codec_priv . data ) {\n<67> ffio_init_context ( & b , track -> codec_priv . data , track -> codec_priv . size , 0 , NULL , NULL , NULL , NULL ) ;\n<68> ret = ff_get_wav_header ( & b , st -> codec , track -> codec_priv . size ) ;\n<69> if ( ret < 0 ) return ret ;\n<71> extradata_offset = FFMIN ( track -> codec_priv . size , 18 ) ;\n<73> else if ( ! strcmp ( track -> codec_id , "V_QUICKTIME" ) && ( track -> codec_priv . size >= 86 ) && ( track -> codec_priv . data ) ) {\n<74> track -> video . fourcc = AV_RL32 ( track -> codec_priv . data ) ;\n<75> codec_id = ff_codec_get_id ( ff_codec_movvideo_tags , track -> video . fourcc ) ;\n<77> else if ( codec_id == AV_CODEC_ID_PCM_S16BE ) {\n<87> else if ( codec_id == AV_CODEC_ID_PCM_S16LE ) {\n<97> else if ( codec_id == AV_CODEC_ID_PCM_F32LE && track -> audio . bitdepth == 64 ) {\n<101> int profile = matroska_aac_profile ( track -> codec_id ) ;\n<104> if ( ! extradata ) return AVERROR ( ENOMEM ) ;\n<107> if ( strstr ( track -> codec_id , "SBR" ) ) {\n<108> sri = matroska_aac_sri ( track -> audio . out_samplerate ) ;\n<109> extradata [ 2 ] = 0x56 ;\n<110> extradata [ 3 ] = 0xE5 ;\n<111> extradata [ 4 ] = 0x80 | ( sri << 3 ) ;\n<112> extradata_size = 5 ;\n<114> else extradata_size = 2 ;\n<116> else if ( codec_id == AV_CODEC_ID_ALAC && track -> codec_priv . size ) {\n<119> if ( ! extradata ) return AVERROR ( ENOMEM ) ;\n<120> AV_WB32 ( extradata , extradata_size ) ;\n<121> memcpy ( & extradata [ 4 ] , "alac" , 4 ) ;\n<122> AV_WB32 ( & extradata [ 8 ] , 0 ) ;\n<123> memcpy ( & extradata [ 12 ] , track -> codec_priv . data , track -> codec_priv . size ) ;\n<128> if ( ! extradata ) return AVERROR ( ENOMEM ) ;\n<129> ffio_init_context ( & b , extradata , extradata_size , 1 , NULL , NULL , NULL , NULL ) ;\n<137> else if ( codec_id == AV_CODEC_ID_RV10 || codec_id == AV_CODEC_ID_RV20 || codec_id == AV_CODEC_ID_RV30 || codec_id == AV_CODEC_ID_RV40 ) {\n<138> extradata_offset = 26 ;\n<140> else if ( codec_id == AV_CODEC_ID_RA_144 ) {\n<146> ffio_init_context ( & b , track -> codec_priv . data , track -> codec_priv . size , 0 , NULL , NULL , NULL , NULL ) ;\n<154> if ( flavor <= 0 || track -> audio . coded_framesize <= 0 || track -> audio . sub_packet_h <= 0 || track -> audio . frame_size <= 0 || track -> audio . sub_packet_size <= 0 ) return AVERROR_INVALIDDATA ;\n<169> extradata_offset = 78 ;\n<172> else if ( codec_id == AV_CODEC_ID_FLAC && track -> codec_priv . size ) {\n<173> ret = matroska_parse_flac ( s , track , & extradata_offset ) ;\n<174> if ( ret < 0 ) return ret ;\n<176> track -> codec_priv . size -= extradata_offset ;\n<177> if ( codec_id == AV_CODEC_ID_NONE ) av_log ( matroska -> ctx , AV_LOG_INFO , "Unknown/unsupported AVCodecID %s.\n" , track -> codec_id ) ;\n<178> if ( track -> time_scale < 0.01 ) track -> time_scale = 1.0 ;\n<179> avpriv_set_pts_info ( st , 64 , matroska -> time_scale * track -> time_scale , 1000 * 1000 * 1000 ) ;\n<180> track -> codec_delay = av_rescale_q ( track -> codec_delay , ( AVRational ) {\n<182> , st -> time_base ) ;\n<183> st -> codec -> codec_id = codec_id ;\n<184> st -> start_time = 0 ;\n<185> if ( strcmp ( track -> language , "und" ) ) av_dict_set ( & st -> metadata , "language" , track -> language , 0 ) ;\n<186> av_dict_set ( & st -> metadata , "title" , track -> name , 0 ) ;\n<187> if ( track -> flag_default ) st -> disposition |= AV_DISPOSITION_DEFAULT ;\n<188> if ( track -> flag_forced ) st -> disposition |= AV_DISPOSITION_FORCED ;\n<189> if ( ! st -> codec -> extradata ) {\n<191> st -> codec -> extradata = extradata ;\n<194> else if ( track -> codec_priv . data && track -> codec_priv . size > 0 ) {\n<196> if ( ! st -> codec -> extradata ) return AVERROR ( ENOMEM ) ;\n<198> memcpy ( st -> codec -> extradata , track -> codec_priv . data + extradata_offset , track -> codec_priv . size ) ;
<1> static int mpeg_decode_postinit(AVCodecContext *avctx)\n<9> uint8_t old_permutation[64];\n<149> if (ret < 0)\n<241> memcpy(old_permutation, s->idsp.idct_permutation, 64 * sizeof(uint8_t));\n<253> quant_matrix_rebuild(s->intra_matrix,        old_permutation, s->idsp.idct_permutation);
<1> static int set_string_number(void *obj, void *target_obj, const AVOption *o, const char *val, void *dst)\n<13> if (sscanf(val, "%d%*1[:/]%d%c", &num, &den, &c) == 2) {\n<15> if ((ret = write_number(obj, o, dst, 1, den, num)) >= 0)\n<27> int i = 0;\n<29> char buf[256];\n<31> int cmd = 0;\n<35> int64_t intnum = 1;\n<39> if (o->type == AV_OPT_TYPE_FLAGS) {\n<43> cmd = *(val++);\n<45> for (; i < sizeof(buf) - 1 && val[i] && val[i] != '+' && val[i] != '-'; i++)\n<47> buf[i] = val[i];\n<57> const AVOption *o_named = av_opt_find(target_obj, buf, o->unit, 0, 0);\n<61> int ci = 0;\n<63> double const_values[64];\n<65> const char * const_names[64];\n<67> if (o_named && o_named->type == AV_OPT_TYPE_CONST)\n<69> d = DEFAULT_NUMVAL(o_named);\n<75> for (o_named = NULL; o_named = av_opt_next(target_obj, o_named); ) {\n<81> !strcmp(o_named->unit, o->unit)) {\n<85> av_log(obj, AV_LOG_ERROR, "const_values array too small for %s\n", o->unit);\n<93> const_values[ci++] = DEFAULT_NUMVAL(o_named);\n<103> const_values[ci++] = DEFAULT_NUMVAL(o);\n<127> res = av_expr_parse_and_eval(&d, i ? buf : val, const_names,\n<133> av_log(obj, AV_LOG_ERROR, "Unable to parse option value \"%s\"\n", val);\n<145> read_number(o, dst, NULL, NULL, &intnum);\n<155> if ((ret = write_number(obj, o, dst, d, 1, 1)) < 0)\n<159> val += i;
<1> static void test_wl4435 ( ) {\n<52> memset ( ps_params , 0 , sizeof ( ps_params ) ) ;\n<97> rc = mysql_stmt_bind_param ( stmt , ps_params ) ;\n<99> exec_counter < 3 ;\n<112> rs_bind = ( MYSQL_BIND * ) malloc ( sizeof ( MYSQL_BIND ) * num_fields ) ;\n<113> memset ( rs_bind , 0 , sizeof ( MYSQL_BIND ) * num_fields ) ;\n<128> switch ( fields [ i ] . type ) {\n<143> default : fprintf ( stderr , "ERROR: unexpected type: %d.\n" , fields [ i ] . type ) ;\n<147> rc = mysql_stmt_bind_result ( stmt , rs_bind ) ;\n<155> i < num_fields ;\n<170> default : printf ( " unexpected type (%d)\n" , rs_bind [ i ] . buffer_type ) ;\n<181> if ( rc > 0 ) {\n<182> printf ( "Error: %s (errno: %d)\n" , mysql_stmt_error ( stmt ) , mysql_stmt_errno ( stmt ) ) ;\n<186> if ( ! mysql -> field_count ) {\n<196> const char * str_koi8r = "\xee\xd5\x2c\x20\xda\xc1\x20\xd2\xd9\xc2\xc1\xcc\xcb\xd5" ;\n<197> const char * str_cp1251 = "\xcd\xf3\x2c\x20\xe7\xe0\x20\xf0\xfb\xe1\xe0\xeb\xea\xf3" ;\n<206> memset ( ps_params , 0 , sizeof ( ps_params ) ) ;\n<209> ps_params [ 0 ] . buffer_length = strlen ( str_koi8r ) ;\n<216> rc = mysql_stmt_bind_param ( stmt , ps_params ) ;\n<222> memset ( rs_bind , 0 , sizeof ( rs_bind ) ) ;\n<231> rc = mysql_stmt_bind_result ( stmt , rs_bind ) ;\n<235> DIE_UNLESS ( o1_length == strlen ( str_cp1251 ) ) ;\n<236> DIE_UNLESS ( o2_length == strlen ( str_koi8r ) ) ;\n<237> DIE_UNLESS ( ! memcmp ( o1_buffer , str_cp1251 , o1_length ) ) ;\n<238> DIE_UNLESS ( ! memcmp ( o2_buffer , str_koi8r , o2_length ) ) ;
<1> static char * get_relative_path ( const char * path ) {\n<2> if ( test_if_hard_path ( path ) && is_prefix ( path , DEFAULT_MYSQL_HOME ) && strcmp ( DEFAULT_MYSQL_HOME , FN_ROOTDIR ) ) {\n<3> path += ( uint ) strlen ( DEFAULT_MYSQL_HOME ) ;\n<4> while ( * path == FN_LIBCHAR || * path == FN_LIBCHAR2 ) path ++ ;\n<6> return ( char * ) path ;
<1> static void decode_mode(AVCodecContext *ctx)\n<27> VP9Block *b = s->b;\n<33> int w4 = FFMIN(s->cols - col, bwh_tab[1][b->bs][0]);\n<35> int h4 = FFMIN(s->rows - row, bwh_tab[1][b->bs][1]), y;\n<43> b->seg_id = 0;\n<71> for (y = 0; y < h4; y++)\n<73> for (x = 0; x < w4; x++)\n<79> b->seg_id = pred;\n<83> memset(&s->above_segpred_ctx[col], 1, w4);\n<85> memset(&s->left_segpred_ctx[row7], 1, h4);\n<89> b->seg_id = vp8_rac_get_tree(&s->c, vp9_segmentation_tree,\n<95> memset(&s->above_segpred_ctx[col], 0, w4);\n<97> memset(&s->left_segpred_ctx[row7], 0, h4);\n<103> uint8_t *segmap = s->frames[CUR_FRAME].segmentation_map;\n<107> for (y = 0; y < h4; y++)\n<109> memset(&segmap[(y + row) * 8 * s->sb_cols + col], b->seg_id, w4);\n<119> if (!b->skip) {\n<123> b->skip = vp56_rac_get_prob(&s->c, s->prob.p.skip[c]);\n<153> c = have_a ? 2 * s->above_intra_ctx[col] :\n<155> have_l ? 2 * s->left_intra_ctx[row7] : 0;\n<169> if ((b->intra || !b->skip) && s->txfmmode == TX_SWITCHABLE) {\n<189> (s->above_txfm_ctx[col] * 2 > max_tx);\n<197> (s->left_txfm_ctx[row7] * 2 > max_tx);\n<209> b->tx = vp56_rac_get_prob(&s->c, s->prob.p.tx32p[c][0]);\n<215> if (b->tx == 2)\n<217> b->tx += vp56_rac_get_prob(&s->c, s->prob.p.tx32p[c][2]);\n<227> b->tx = vp56_rac_get_prob(&s->c, s->prob.p.tx16p[c][0]);\n<231> b->tx += vp56_rac_get_prob(&s->c, s->prob.p.tx16p[c][1]);\n<239> b->tx = vp56_rac_get_prob(&s->c, s->prob.p.tx8p[c]);\n<247> b->tx = TX_4X4;\n<255> b->tx = FFMIN(max_tx, s->txfmmode);\n<263> uint8_t *a = &s->above_mode_ctx[col * 2];\n<265> uint8_t *l = &s->left_mode_ctx[(row7) << 1];\n<269> b->comp = 0;\n<271> if (b->bs > BS_8x8) {\n<305> b->mode[3] = vp8_rac_get_tree(&s->c, vp9_intramode_tree,\n<313> l[1] = a[1] = b->mode[3] = b->mode[2];\n<321> l[1] = a[1] = b->mode[3] = b->mode[1];\n<327> b->mode[0] = vp8_rac_get_tree(&s->c, vp9_intramode_tree,\n<331> b->mode[3] = b->mode[2] = b->mode[1] = b->mode[0];\n<335> memset(a, b->mode[0], bwh_tab[0][b->bs][0]);\n<337> memset(l, b->mode[0], bwh_tab[0][b->bs][1]);\n<347> b->comp = 0;\n<381> b->mode[3] = vp8_rac_get_tree(&s->c, vp9_intramode_tree,\n<389> b->mode[3] = b->mode[2];\n<397> b->mode[3] = b->mode[1];\n<417> b->mode[1] = b->mode[2] = b->mode[3] = b->mode[0];\n<469> b->comp = 0;\n<479> b->comp = s->comppredmode == PRED_COMPREF;\n<493> if (s->above_comp_ctx[col] && s->left_comp_ctx[row7]) {\n<501> s->left_ref_ctx[row7] == s->fixcompref);\n<507> s->above_ref_ctx[col] == s->fixcompref);\n<511> c = (!s->above_intra_ctx[col] &&\n<513> s->above_ref_ctx[col] == s->fixcompref) ^\n<515> (!s->left_intra_ctx[row7] &&\n<525> (!s->above_intra_ctx[col] && s->above_ref_ctx[col] == s->fixcompref);\n<533> (!s->left_intra_ctx[row7] && s->left_ref_ctx[row7] == s->fixcompref);\n<541> b->comp = vp56_rac_get_prob(&s->c, s->prob.p.comp[c]);\n<577> c = 1 + 2 * (s->left_ref_ctx[row7] != s->varcompref[1]);\n<583> c = 1 + 2 * (s->above_ref_ctx[col] != s->varcompref[1]);\n<595> } else if (!s->left_comp_ctx[row7] && !s->above_comp_ctx[col]) {\n<609> } else if (!s->left_comp_ctx[row7]) {\n<623> } else if (!s->above_comp_ctx[col]) {\n<653> c = 4 * (s->above_ref_ctx[col] != s->varcompref[1]);\n<657> c = 3 * (s->above_ref_ctx[col] != s->varcompref[1]);\n<671> c = 4 * (s->left_ref_ctx[row7] != s->varcompref[1]);\n<675> c = 3 * (s->left_ref_ctx[row7] != s->varcompref[1]);\n<697> if (have_a && !s->above_intra_ctx[col]) {\n<699> if (have_l && !s->left_intra_ctx[row7]) {\n<705> c = 1 + (!s->fixcompref || !s->left_ref_ctx[row7] ||\n<707> !s->above_ref_ctx[col]);\n<711> c = (3 * !s->above_ref_ctx[col]) +\n<713> (!s->fixcompref || !s->left_ref_ctx[row7]);\n<719> c = (3 * !s->left_ref_ctx[row7]) +\n<721> (!s->fixcompref || !s->above_ref_ctx[col]);\n<725> c = 2 * !s->left_ref_ctx[row7] + 2 * !s->above_ref_ctx[col];\n<735> c = 1 + (!s->fixcompref || !s->above_ref_ctx[col]);\n<739> c = 4 * (!s->above_ref_ctx[col]);\n<743> } else if (have_l && !s->left_intra_ctx[row7]) {\n<751> c = 1 + (!s->fixcompref || !s->left_ref_ctx[row7]);\n<755> c = 4 * (!s->left_ref_ctx[row7]);\n<791> s->above_ref_ctx[col] == 1);\n<793> } else if (!s->above_ref_ctx[col]) {\n<799> c = 4 * (s->above_ref_ctx[col] == 1);\n<813> s->left_ref_ctx[row7] == 1);\n<815> } else if (!s->left_ref_ctx[row7]) {\n<821> c = 4 * (s->left_ref_ctx[row7] == 1);\n<829> if (s->left_ref_ctx[row7] == s->above_ref_ctx[col]) {\n<833> s->left_ref_ctx[row7] == 1);\n<841> } else if (!s->left_ref_ctx[row7]) {\n<845> s->above_ref_ctx[col] == 1);\n<849> c = 3 * (s->left_ref_ctx[row7] == 1) +\n<851> (s->fixcompref == 1 || s->above_ref_ctx[col] == 1);\n<857> if (!s->above_ref_ctx[col]) {\n<861> s->left_ref_ctx[row7] == 1);\n<865> c = 3 * (s->above_ref_ctx[col] == 1) +\n<867> (s->fixcompref == 1 || s->left_ref_ctx[row7] == 1);\n<871> } else if (!s->above_ref_ctx[col]) {\n<873> if (!s->left_ref_ctx[row7]) {\n<879> c = 4 * (s->left_ref_ctx[row7] == 1);\n<883> } else if (!s->left_ref_ctx[row7]) {\n<885> c = 4 * (s->above_ref_ctx[col] == 1);\n<889> c = 2 * (s->left_ref_ctx[row7] == 1) +\n<891> 2 * (s->above_ref_ctx[col] == 1);\n<899> (!s->above_comp_ctx[col] && !s->above_ref_ctx[col])) {\n<905> c = 3 * (s->fixcompref == 1 || s->above_ref_ctx[col] == 1);\n<909> c = 4 * (s->above_ref_ctx[col] == 1);\n<919> (!s->left_comp_ctx[row7] && !s->left_ref_ctx[row7])) {\n<925> c = 3 * (s->fixcompref == 1 || s->left_ref_ctx[row7] == 1);\n<929> c = 4 * (s->left_ref_ctx[row7] == 1);\n<957> b->mode[0] = b->mode[1] = b->mode[2] = b->mode[3] = ZEROMV;\n<983> b->mode[1] = b->mode[2] = b->mode[3] = b->mode[0];\n<999> if (have_a && s->above_mode_ctx[col] >= NEARESTMV) {\n<1001> if (have_l && s->left_mode_ctx[row7] >= NEARESTMV) {\n<1003> c = s->above_filter_ctx[col] == s->left_filter_ctx[row7] ?\n<1013> } else if (have_l && s->left_mode_ctx[row7] >= NEARESTMV) {\n<1025> b->filter = vp8_rac_get_tree(&s->c, vp9_filter_tree,\n<1033> b->filter = s->filtermode;\n<1097> fill_mv(s, b->mv[3], b->mode[3], 3);\n<1101> b->mode[3] = b->mode[2];\n<1117> b->mode[3] = b->mode[1];\n<1149> memset(&s->above_skip_ctx[col], b->skip, w4);\n<1151> memset(&s->left_skip_ctx[row7], b->skip, h4);\n<1153> memset(&s->above_txfm_ctx[col], b->tx, w4);\n<1155> memset(&s->left_txfm_ctx[row7], b->tx, h4);\n<1157> memset(&s->above_partition_ctx[col], above_ctx[b->bs], w4);\n<1159> memset(&s->left_partition_ctx[row7], left_ctx[b->bs], h4);\n<1161> if (!s->keyframe && !s->intraonly) {\n<1163> memset(&s->above_intra_ctx[col], b->intra, w4);\n<1165> memset(&s->left_intra_ctx[row7], b->intra, h4);\n<1167> memset(&s->above_comp_ctx[col], b->comp, w4);\n<1169> memset(&s->left_comp_ctx[row7], b->comp, h4);\n<1171> memset(&s->above_mode_ctx[col], b->mode[3], w4);\n<1173> memset(&s->left_mode_ctx[row7], b->mode[3], h4);\n<1175> if (s->filtermode == FILTER_SWITCHABLE && !b->intra ) {\n<1177> memset(&s->above_filter_ctx[col], b->filter, w4);\n<1179> memset(&s->left_filter_ctx[row7], b->filter, h4);\n<1213> for (n = 0; n < w4 * 2; n++) {\n<1221> for (n = 0; n < h4 * 2; n++) {\n<1233> if (!b->intra) { // FIXME write 0xff or -1 if intra, so we can use this\n<1237> int vref = b->ref[b->comp ? s->signbias[s->varcompref[0]] : 0];\n<1241> memset(&s->above_ref_ctx[col], vref, w4);\n<1243> memset(&s->left_ref_ctx[row7], vref, h4);\n<1253> for (y = 0; y < h4; y++) {\n<1263> for (x = 0; x < w4; x++) {\n<1273> for (x = 0; x < w4; x++) {\n<1287> for (x = 0; x < w4; x++) {
<1> static char * expand_escapes ( const char * line , SERVER_REC * server , WI_ITEM_REC * item ) {\n<6> ret = ptr = g_malloc ( strlen ( line ) + 1 ) ;\n<9> line ++ ) {\n<11> * ptr ++ = * line ;\n<14> line ++ ;\n<16> * ptr ++ = '\\' ;\n<26> ptr = ret ;\n<30> * ptr ++ = chr ;\n<33> * ptr ++ = '\\' ;\n<38> return ret ;
<1> static void unpack_vectors(Vp3DecodeContext *s, GetBitContext *gb)\n<9> int motion_x[6];\n<11> int motion_y[6];\n<31> if (s->keyframe) {\n<43> memset(motion_x, 0, 6 * sizeof(int));\n<45> memset(motion_y, 0, 6 * sizeof(int));\n<107> motion_x[k] = motion_x[0];\n<109> motion_y[k] = motion_y[0];\n<125> last_motion_x = motion_x[0];\n<127> last_motion_y = motion_y[0];\n<159> motion_x[4] += motion_x[k];\n<161> motion_y[4] += motion_y[k];\n<167> if (motion_x[4] >= 0)\n<169> motion_x[4] = (motion_x[4] + 2) / 4;\n<173> motion_x[4] = (motion_x[4] - 2) / 4;\n<175> motion_x[5] = motion_x[4];\n<179> if (motion_y[4] >= 0)\n<181> motion_y[4] = (motion_y[4] + 2) / 4;\n<185> motion_y[4] = (motion_y[4] - 2) / 4;\n<187> motion_y[5] = motion_y[4];\n<199> last_motion_x = motion_x[3];\n<201> last_motion_y = motion_y[3];\n<217> motion_x[k] = motion_x[0];\n<219> motion_y[k] = motion_y[0];\n<245> motion_x[k] = motion_x[0];\n<247> motion_y[k] = motion_y[0];\n<259> last_motion_x = motion_x[0];\n<261> last_motion_y = motion_y[0];\n<283> s->all_fragments[current_fragment].motion_x = motion_x[k];\n<285> s->all_fragments[current_fragment].motion_x = motion_y[k];\n<287> debug_vectors("    vector %d: fragment %d = (%d, %d)\n",
<1> static int selinux_ismaclabel ( const char * name ) {\n<2> return ( strcmp ( name , XATTR_SELINUX_SUFFIX ) == 0 ) ;
<1> static int read_access_unit(AVCodecContext *avctx, void* data,\n<11> MLPDecodeContext *m = avctx->priv_data;\n<57> if (read_major_sync(m, &gb) < 0)\n<205> for (substr = 0; substr <= m->max_decoded_substream; substr++) {\n<215> memset(m->filter_changed, 0, sizeof(m->filter_changed));\n<229> if (read_restart_header(m, &gb, buf, substr) < 0)\n<243> if (read_decoding_params(m, &gb, substr) < 0)\n<257> if ((ret = read_block_data(m, &gb, substr)) < 0)\n<361> rematrix_channels(m, m->max_decoded_substream);\n<365> if ((ret = output_data(m, m->max_decoded_substream, data, got_frame_ptr)) < 0)
<1> static int evhttp_associate_new_request_with_connection ( struct evhttp_connection * evcon ) {\n<4> if ( ( req = evhttp_request_new ( evhttp_handle_request , http ) ) == NULL ) return ( - 1 ) ;\n<9> if ( ( req -> remote_host = strdup ( evcon -> address ) ) == NULL ) event_err ( 1 , "%s: strdup" , __func__ ) ;\n<11> evhttp_start_read ( evcon ) ;
<1> void xps_parse_color ( xps_document * doc , char * base_uri , char * string , fz_colorspace * * csp , float * samples ) {\n<8> samples [ 0 ] = 1 ;\n<9> samples [ 1 ] = 0 ;\n<10> samples [ 2 ] = 0 ;\n<11> samples [ 3 ] = 0 ;\n<12> if ( string [ 0 ] == '#' ) {\n<13> if ( strlen ( string ) == 9 ) {\n<14> samples [ 0 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n<15> samples [ 1 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n<16> samples [ 2 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n<17> samples [ 3 ] = unhex ( string [ 7 ] ) * 16 + unhex ( string [ 8 ] ) ;\n<20> samples [ 0 ] = 255 ;\n<21> samples [ 1 ] = unhex ( string [ 1 ] ) * 16 + unhex ( string [ 2 ] ) ;\n<22> samples [ 2 ] = unhex ( string [ 3 ] ) * 16 + unhex ( string [ 4 ] ) ;\n<23> samples [ 3 ] = unhex ( string [ 5 ] ) * 16 + unhex ( string [ 6 ] ) ;\n<30> else if ( string [ 0 ] == 's' && string [ 1 ] == 'c' && string [ 2 ] == '#' ) {\n<31> if ( count_commas ( string ) == 2 ) sscanf ( string , "sc#%g,%g,%g" , samples + 1 , samples + 2 , samples + 3 ) ;\n<32> if ( count_commas ( string ) == 3 ) sscanf ( string , "sc#%g,%g,%g,%g" , samples , samples + 1 , samples + 2 , samples + 3 ) ;\n<34> else if ( strstr ( string , "ContextColor " ) == string ) {\n<35> fz_strlcpy ( buf , string , sizeof buf ) ;\n<36> profile = strchr ( buf , ' ' ) ;\n<37> if ( ! profile ) {\n<41> * profile ++ = 0 ;\n<42> p = strchr ( profile , ' ' ) ;\n<43> if ( ! p ) {\n<44> fz_warn ( ctx , "cannot find component values in '%s'" , profile ) ;\n<54> while ( i < n ) {\n<55> samples [ i ++ ] = fz_atof ( p ) ;\n<56> p = strchr ( p , ',' ) ;\n<57> if ( ! p ) break ;\n<59> if ( * p == ' ' ) p ++ ;
<1> static void dump_json_image_info(ImageInfo *info)\n<21> printf("%s\n", qstring_get_str(str));
<1> static int slirp_hostfwd ( SlirpState * s , const char * redir_str , int legacy_format ) {\n<10> char buf [ 256 ] ;\n<14> if ( ! p || get_str_sep ( buf , sizeof ( buf ) , & p , ':' ) < 0 ) {\n<17> if ( ! strcmp ( buf , "tcp" ) || buf [ 0 ] == '\0' ) {\n<18> is_udp = 0 ;\n<20> else if ( ! strcmp ( buf , "udp" ) ) {\n<21> is_udp = 1 ;\n<26> if ( ! legacy_format ) {\n<56> fail_syntax : error_report ( "invalid host forwarding rule '%s'" , redir_str ) ;\n<57> return - 1 ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<90> if ( ( compr & ( ~ TGA_RLE ) ) == TGA_NODATA ) {\n<91> memset ( p -> data [ 0 ] , 0 , p -> linesize [ 0 ] * h ) ;
<1> static void report_usage ( FILE * out , int count , size_t bytes , backtrace_t * bt , bool detailed ) {\n<2> fprintf ( out , "%zu bytes total, %d allocations, %zu bytes average:\n" , bytes , count , bytes / count ) ;\n<3> bt -> log ( bt , out , detailed ) ;
<1> static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) {\n<25> uint8_t block = gifgetbyte ( grr ) ;\n<57> default : if ( ! unknown_block_type ) {\n<58> char buf [ 256 ] ;\n<59> sprintf ( buf , "unknown block type %d at file offset %u" , block , grr -> pos - 1 ) ;\n<60> gif_read_error ( & gfc , 1 , buf ) ;
<1> static void ttc_perfonttables ( struct alltabs * all , int me , int mainpos , enum fontformat format ) {\n<13> memcpy ( at -> head . modtime , main -> head . modtime , sizeof ( at -> head . modtime ) ) ;\n<14> memcpy ( at -> head . createtime , at -> head . modtime , sizeof ( at -> head . modtime ) ) ;\n<65> free ( at -> gi . bygid ) ;
<1> static void parse_content_disposition ( const char * content_disposition , const char * * filename_r ) {\n<6> if ( content_disposition == NULL ) return ;\n<7> rfc822_parser_init ( & parser , ( const unsigned char * ) content_disposition , strlen ( content_disposition ) , NULL ) ;
<1> void stats_config ( int item , const char * invalue ) {\n<11> case STATS_FREQ_FILE : strncpy ( parameter , "STATS_FREQ_FILE" , sizeof ( parameter ) ) ;\n<13> case STATS_LEAP_FILE : strncpy ( parameter , "STATS_LEAP_FILE" , sizeof ( parameter ) ) ;\n<15> case STATS_STATSDIR : strncpy ( parameter , "STATS_STATSDIR" , sizeof ( parameter ) ) ;\n<17> case STATS_PID_FILE : strncpy ( parameter , "STATS_PID_FILE" , sizeof ( parameter ) ) ;\n<19> default : strncpy ( parameter , "UNKNOWN" , sizeof ( parameter ) ) ;\n<23> msyslog ( LOG_ERR , "ExpandEnvironmentStrings(%s) failed: %m\n" , parameter ) ;\n<30> case STATS_FREQ_FILE : if ( ! value || ( len = strlen ( value ) ) == 0 ) break ;\n<31> stats_drift_file = erealloc ( stats_drift_file , len + 1 ) ;\n<32> stats_temp_file = erealloc ( stats_temp_file , len + sizeof ( ".TEMP" ) ) ;\n<33> memcpy ( stats_drift_file , value , ( size_t ) ( len + 1 ) ) ;\n<34> memcpy ( stats_temp_file , value , ( size_t ) len ) ;\n<35> memcpy ( stats_temp_file + len , temp_ext , sizeof ( temp_ext ) ) ;\n<36> if ( ( fp = fopen ( stats_drift_file , "r" ) ) == NULL ) break ;\n<37> if ( fscanf ( fp , "%lf" , & old_drift ) != 1 ) {\n<39> fclose ( fp ) ;\n<42> fclose ( fp ) ;\n<43> loop_config ( LOOP_FREQ , old_drift ) ;
<1> AVEvalExpr * ff_parse(const char *s, const char * const *const_name,\n<13> char w[strlen(s) + 1], * wp = w;\n<19> if (!isspace(*s++)) *wp++ = s[-1];\n<27> p.s= w;
<1> TSReturnCode TSHttpTxnConfigFind ( const char * name , int length , TSOverridableConfigKey * conf , TSRecordDataType * type ) {\n<6> if ( length == - 1 ) {\n<7> length = strlen ( name ) ;\n<10> case 24 : if ( ! strncmp ( name , "proxy.config.srv_enabled" , length ) ) {\n<14> case 28 : if ( ! strncmp ( name , "proxy.config.http.cache.http" , length ) ) {\n<18> case 29 : if ( ! strncmp ( name , "proxy.config.ssl.hsts_max_age" , length ) ) {\n<22> case 31 : if ( ! strncmp ( name , "proxy.config.http.chunking.size" , length ) ) {\n<26> case 33 : if ( ! strncmp ( name , "proxy.config.http.cache.fuzz.time" , length ) ) {\n<34> case 34 : if ( ! strncmp ( name , "proxy.config.http.chunking_enabled" , length ) ) {\n<44> case 35 : switch ( name [ length - 1 ] ) {\n<45> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.range.write" , length ) ) {\n<52> case 'p' : if ( ! strncmp ( name , "proxy.config.http.normalize_ae_gzip" , length ) ) {\n<58> case 36 : switch ( name [ length - 1 ] ) {\n<59> case 'p' : if ( ! strncmp ( name , "proxy.config.http.cache.range.lookup" , length ) ) {\n<63> case 't' : if ( ! strncmp ( name , "proxy.config.net.sock_packet_tos_out" , length ) ) {\n<67> case 'd' : if ( ! strncmp ( name , "proxy.config.http.slow.log.threshold" , length ) ) {\n<73> case 37 : switch ( name [ length - 1 ] ) {\n<74> case 'd' : if ( ! strncmp ( name , "proxy.config.http.redirection_enabled" , length ) ) {\n<78> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.max_stale_age" , length ) ) {\n<92> case 'r' : if ( ! strncmp ( name , "proxy.config.http.response_server_str" , length ) ) {\n<100> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_post_out" , length ) ) {\n<115> case 38 : switch ( name [ length - 1 ] ) {\n<116> case 'd' : if ( ! strncmp ( name , "proxy.config.http.server_tcp_init_cwnd" , length ) ) {\n<124> case 's' : if ( ! strncmp ( name , "proxy.config.http.send_http11_requests" , length ) ) {\n<130> case 39 : switch ( name [ length - 1 ] ) {\n<131> case 'e' : if ( ! strncmp ( name , "proxy.config.body_factory.template_base" , length ) ) {\n<136> case 'm' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_from" , length ) ) {\n<140> case 'n' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_enabled_in" , length ) ) {\n<144> case 's' : if ( ! strncmp ( name , "proxy.config.http.doc_in_cache_skip_dns" , length ) ) {\n<150> case 40 : switch ( name [ length - 1 ] ) {\n<151> case 'd' : if ( ! strncmp ( name , "proxy.config.http.forward_connect_method" , length ) ) {\n<155> case 'e' : if ( ! strncmp ( name , "proxy.config.http.down_server.cache_time" , length ) ) {\n<162> case 'r' : if ( ! strncmp ( name , "proxy.config.url_remap.pristine_host_hdr" , length ) ) {\n<172> case 's' : if ( ! strncmp ( name , "proxy.config.http.origin_max_connections" , length ) ) {\n<185> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_enabled_out" , length ) ) {\n<189> case 'y' : if ( ! strncmp ( name , "proxy.config.http.cache.fuzz.probability" , length ) ) {\n<196> case 41 : switch ( name [ length - 1 ] ) {\n<197> case 'd' : if ( ! strncmp ( name , "proxy.config.http.response_server_enabled" , length ) ) {\n<201> case 'e' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_cookie" , length ) ) {\n<214> case 'r' : if ( ! strncmp ( name , "proxy.config.http.insert_response_via_str" , length ) ) {\n<223> case 42 : switch ( name [ length - 1 ] ) {\n<224> case 'd' : if ( ! strncmp ( name , "proxy.config.http.negative_caching_enabled" , length ) ) {\n<228> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.when_to_revalidate" , length ) ) {\n<235> case 'r' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_referer" , length ) ) {\n<243> case 't' : if ( ! strncmp ( name , "proxy.config.net.sock_recv_buffer_size_out" , length ) ) {\n<258> case 43 : switch ( name [ length - 1 ] ) {\n<259> case 'e' : if ( ! strncmp ( name , "proxy.config.http.negative_caching_lifetime" , length ) ) {\n<263> case 'k' : if ( ! strncmp ( name , "proxy.config.http.default_buffer_water_mark" , length ) ) {\n<267> case 'l' : if ( ! strncmp ( name , "proxy.config.http.cache.cluster_cache_local" , length ) ) {\n<271> case 'r' : if ( ! strncmp ( name , "proxy.config.http.cache.heuristic_lm_factor" , length ) ) {\n<278> case 44 : switch ( name [ length - 1 ] ) {\n<279> case 'p' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_client_ip" , length ) ) {\n<283> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.open_read_retry_time" , length ) ) {\n<289> case 45 : switch ( name [ length - 1 ] ) {\n<290> case 'd' : if ( ! strncmp ( name , "proxy.config.http.down_server.abort_threshold" , length ) ) {\n<297> case 'n' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_authentication" , length ) ) {\n<301> case 't' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_user_agent" , length ) ) {\n<305> case 's' : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_rr_retries" , length ) ) {\n<312> case 'e' : if ( 0 == strncmp ( name , "proxy.config.http.auth_server_session_private" , length ) ) {\n<316> case 'y' : if ( ! strncmp ( name , "proxy.config.http.redirect_use_orig_cache_key" , length ) ) {\n<322> case 46 : switch ( name [ length - 1 ] ) {\n<323> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_client_no_cache" , length ) ) {\n<342> case 'r' : if ( ! strncmp ( name , "proxy.config.http.insert_squid_x_forwarded_for" , length ) ) {\n<346> case 's' : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_max_retries" , length ) ) {\n<353> case 't' : if ( ! strncmp ( name , "proxy.config.http.forward.proxy_auth_to_parent" , length ) ) {\n<357> case 'h' : if ( 0 == strncmp ( name , "proxy.config.http.server_session_sharing.match" , length ) ) {\n<361> case 'n' : if ( ! strncmp ( name , "proxy.config.http.cache.open_write_fail_action" , length ) ) {\n<367> case 47 : switch ( name [ length - 1 ] ) {\n<368> case 'b' : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.mark_down_hostdb" , length ) ) {\n<372> case 'd' : if ( ! strncmp ( name , "proxy.config.http.negative_revalidating_enabled" , length ) ) {\n<376> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.guaranteed_min_lifetime" , length ) ) {\n<383> case 'n' : if ( ! strncmp ( name , "proxy.config.http.transaction_active_timeout_in" , length ) ) {\n<387> case 't' : if ( ! strncmp ( name , "proxy.config.http.post_connect_attempts_timeout" , length ) ) {\n<393> case 48 : switch ( name [ length - 1 ] ) {\n<394> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_client_cc_max_age" , length ) ) {\n<402> case '_' : if ( ! strncmp ( name , "proxy.config.http.transaction_active_timeout_out" , length ) ) {\n<406> case 'e' : if ( ! strncmp ( name , "proxy.config.http.background_fill_active_timeout" , length ) ) {\n<414> case 49 : if ( ! strncmp ( name , "proxy.config.http.attach_server_session_to_client" , length ) ) {\n<418> case 50 : if ( ! strncmp ( name , "proxy.config.http.cache.cache_responses_to_cookies" , length ) ) {\n<422> case 51 : switch ( name [ length - 1 ] ) {\n<423> case 'n' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_no_activity_timeout_in" , length ) ) {\n<427> case 'd' : if ( ! strncmp ( name , "proxy.config.http.post.check.content_length.enabled" , length ) ) {\n<433> case 52 : switch ( name [ length - 1 ] ) {\n<434> case 'c' : if ( ! strncmp ( name , "proxy.config.http.cache.cache_urls_that_look_dynamic" , length ) ) {\n<438> case 'n' : if ( ! strncmp ( name , "proxy.config.http.transaction_no_activity_timeout_in" , length ) ) {\n<442> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_no_activity_timeout_out" , length ) ) {\n<451> case 53 : switch ( name [ length - 1 ] ) {\n<452> case 't' : if ( ! strncmp ( name , "proxy.config.http.transaction_no_activity_timeout_out" , length ) ) {\n<456> case 'd' : if ( ! strncmp ( name , "proxy.config.http.background_fill_completed_threshold" , length ) ) {\n<461> case 's' : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.total_connect_attempts" , length ) ) {\n<467> case 55 : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.connect_attempts_timeout" , length ) ) {\n<471> case 58 : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_max_retries_dead_server" , length ) ) {
<1> static void encode_block(NellyMoserEncodeContext *s, unsigned char *output, int output_size)\n<143> memset(put_bits_ptr(&pb), 0, output + output_size - put_bits_ptr(&pb));
<1> static int w64_read_header(AVFormatContext *s)\n<19> avio_read(pb, guid, 16);\n<21> if (memcmp(guid, ff_w64_guid_riff, 16))\n<28> if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8)\n<33> avio_read(pb, guid, 16);\n<35> if (memcmp(guid, ff_w64_guid_wave, 16)) {\n<37> av_log(s, AV_LOG_ERROR, "could not find wave guid\n");\n<56> while (!avio_feof(pb)) {\n<58> if (avio_read(pb, guid, 16) != 16)\n<64> if (size <= 24 || INT64_MAX - size < avio_tell(pb))\n<69> if (!memcmp(guid, ff_w64_guid_fmt, 16)) {\n<73> ret = ff_get_wav_header(s, pb, st->codecpar, size - 24, 0);\n<75> if (ret < 0)\n<85> } else if (!memcmp(guid, ff_w64_guid_fact, 16)) {\n<91> samples = avio_rl64(pb);\n<93> if (samples > 0)\n<97> } else if (!memcmp(guid, ff_w64_guid_data, 16)) {\n<99> wav->data_end = avio_tell(pb) + size - 24;\n<103> data_ofs = avio_tell(pb);\n<105> if (!(pb->seekable & AVIO_SEEKABLE_NORMAL))\n<113> } else if (!memcmp(guid, ff_w64_guid_summarylist, 16)) {\n<121> start = avio_tell(pb);\n<123> end = start + FFALIGN(size, INT64_C(8)) - 24;\n<125> count = avio_rl32(pb);\n<129> for (i = 0; i < count; i++) {\n<177> avio_skip(pb, FFALIGN(size, INT64_C(8)) - 24);
<1> static uint32_t parse_enumeration(char *str,\n<2> EnumTable *table, uint32_t not_found_value)\n<5> while (table->name != NULL) {\n<6> if (strcmp(table->name, str) == 0) {\n<7> ret = table->value;\n<10> table++;
<1> static void WarnBadInstruction ( gs_font_type42 * pfont , int glyph_index ) {\n<6> if ( ! base_font -> data . warning_bad_instruction ) {\n<7> l = min ( sizeof ( buf ) - 1 , base_font -> font_name . size ) ;\n<8> memcpy ( buf , base_font -> font_name . chars , l ) ;\n<10> if ( glyph_index >= 0 ) emprintf2 ( pfont -> memory , "Failed to interpret TT instructions for glyph index %d of font %s. " "Continue ignoring instructions of the font.\n" , glyph_index , buf ) ;\n<11> else emprintf1 ( pfont -> memory , "Failed to interpret TT instructions in font %s. " "Continue ignoring instructions of the font.\n" , buf ) ;
<1> static int asfrtp_parse_packet(AVFormatContext *s, PayloadContext *asf,\n<35> av_freep(&asf->buf);\n<39> ffio_init_context(pb, buf, len, 0, NULL, NULL, NULL, NULL);\n<73> if (!(mflags & 0x40)) {\n<118> out_len     = avio_close_dyn_buf(asf->pktbuf, &asf->buf);\n<140> int cur_len = start_off + len_off - off;\n<142> int prev_len = out_len;\n<146> asf->buf = av_realloc(asf->buf, out_len);\n<152> FFMIN(cur_len, len - off));
<1> static void openpic_reset(DeviceState *d)\n<41> for (i = 0; i < MAX_CPU; i++) {\n<45> memset(&opp->dst[i].raised, 0, sizeof(IRQ_queue_t));\n<49> memset(&opp->dst[i].servicing, 0, sizeof(IRQ_queue_t));
<1> static inline void save_to_qmem_pingordata ( int userid , struct query * q ) {\n<4> if ( q -> name [ 0 ] == 'P' || q -> name [ 0 ] == 'p' ) {\n<6> char * cp = strchr ( q -> name , '.' ) ;\n<7> if ( cp == NULL ) return ;\n<8> i = b32 -> decode ( cmc , & cmcsize , q -> name + 1 , ( cp - q -> name ) - 1 ) ;\n<13> if ( strlen ( q -> name ) < 5 ) return ;\n<14> for ( i = 0 ;\n<15> i < 4 ;\n<18> save_to_qmem ( users [ userid ] . qmemdata_cmc , users [ userid ] . qmemdata_type , QMEMDATA_LEN , & users [ userid ] . qmemdata_lastfilled , ( void * ) cmc , q -> type ) ;
<1> static int open_output_file(OptionsContext *o, const char *filename)\n<81> if (!strcmp(filename, "-"))\n<83> filename = "pipe:";\n<87> err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);\n<107> file_oformat= oc->oformat;\n<151> if (!strcmp(file_oformat->name, "ffm") &&\n<153> av_strstart(filename, "http:", NULL)) {\n<155> int err = parse_option(o, "metadata", "creation_time=now", options);\n<157> if (err < 0) {\n<169> if (!strcmp(file_oformat->name, "ffm") && !override_ffserver &&\n<171> av_strstart(filename, "http:", NULL)) {\n<179> int err = read_ffserver_streams(o, oc, filename);\n<181> if (err < 0) {\n<189> for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {\n<227> } else if (!o->nb_stream_maps) {\n<391> StreamMap *map = &o->stream_maps[i];\n<415> for (k = 0; k < fg->nb_outputs; k++) {\n<417> AVFilterInOut *out = fg->outputs[k]->out_tmp;\n<419> if (out && !strcmp(out->name, map->linklabel)) {\n<421> ofilter = fg->outputs[k];\n<435> av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist "\n<617> && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6)))\n<659> while ((e = av_dict_get(unused_opts, "", e, AV_DICT_IGNORE_SUFFIX))) {\n<673> if (!option || foption)\n<683> av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for "\n<699> if (!strcmp(e->key, "gop_timecode"))\n<705> av_log(NULL, AV_LOG_WARNING, "Codec AVOption %s (%s) specified for "\n<713> "which was not actually used for any stream.\n", e->key,\n<715> option->help ? option->help : "", nb_output_files - 1, filename);\n<773> if (!(oc->oformat->flags & AVFMT_NOFILE)) {\n<795> } else if (strcmp(oc->oformat->name, "image2")==0 && !av_filename_number_test(filename))\n<797> assert_file_overwrite(filename);\n<951> if (!key || !*p2)\n<959> if (!strcmp(key, "program_num"))\n<961> progid = strtol(p2, NULL, 0);\n<979> if (!p2)\n<989> if (!key) {\n<1009> if (!strcmp(key, "title")) {\n<1011> av_dict_set(&program->metadata, "title", p2, 0);\n<1013> } else if (!strcmp(key, "program_num")) {\n<1015> } else if (!strcmp(key, "st")) {\n<1017> int st_num = strtol(p2, NULL, 0);\n<1019> av_program_add_stream_index(oc, progid, st_num);\n<1023> av_log(NULL, AV_LOG_FATAL, "Unknown program key %s.\n", key);\n<1025> exit_program(1);\n<1037> for (i = 0; i < o->nb_metadata; i++) {\n<1051> val = strchr(o->metadata[i].u.str, '=');\n<1053> if (!val) {\n<1055> av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n",\n<1063> *val++ = 0;\n<1067> if (!strcmp(o->metadata[i].u.str, "creation_time") &&\n<1069> !strcmp(val, "now")) {\n<1071> time_t now = time(0);\n<1075> ptm = localtime_r(&now, &tmbuf);\n<1077> if (ptm) {\n<1097> if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {\n<1099> av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n<1101> if (!strcmp(o->metadata[i].u.str, "rotate")) {\n<1103> ost->rotate_overridden = 1;\n<1161> av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);
<1> static void exynos4210_gic_init(Object *obj)\n<15> const char dist_prefix[] = "exynos4210-gic-alias_dist";\n<17> char cpu_alias_name[sizeof(cpu_prefix) + 3];\n<19> char dist_alias_name[sizeof(cpu_prefix) + 3];\n<61> for (i = 0; i < s->num_cpu; i++) {\n<65> sprintf(cpu_alias_name, "%s%x", cpu_prefix, i);\n<67> memory_region_init_alias(&s->cpu_alias[i], obj,\n<79> EXYNOS4210_EXT_GIC_CPU_GET_OFFSET(i), &s->cpu_alias[i]);\n<85> sprintf(dist_alias_name, "%s%x", dist_prefix, i);\n<87> memory_region_init_alias(&s->dist_alias[i], obj,\n<99> EXYNOS4210_EXT_GIC_DIST_GET_OFFSET(i), &s->dist_alias[i]);
<1> void gcry_sexp_release ( gcry_sexp_t sexp ) {\n<7> p ++ ;\n<8> switch ( type ) {\n<13> memcpy ( & n , p , sizeof n ) ;\n<14> p += sizeof n ;\n<15> p += n ;
<1> afs_int32 WhoIsThis ( struct rx_call * acall , struct ubik_trans * at , afs_int32 * aid ) {\n<18> if ( ( code = rxkad_GetServerInfo ( acall -> conn , NULL , 0 , name , inst , tcell , NULL ) ) ) goto done ;\n<21> strncpy ( vname , name , sizeof ( vname ) ) ;\n<22> if ( ( ilen = strlen ( inst ) ) ) {\n<23> if ( strlen ( vname ) + 1 + ilen >= sizeof ( vname ) ) goto done ;\n<24> strcat ( vname , "." ) ;\n<25> strcat ( vname , inst ) ;\n<27> if ( foreign ) {\n<28> if ( strlen ( vname ) + strlen ( tcell ) + 1 >= sizeof ( vname ) ) goto done ;\n<29> strcat ( vname , "@" ) ;\n<30> strcat ( vname , tcell ) ;\n<32> if ( strcmp ( AUTH_SUPERUSER , vname ) == 0 ) * aid = SYSADMINID ;\n<34> lcstring ( vname , vname , sizeof ( vname ) ) ;\n<35> code = NameToID ( at , vname , aid ) ;
<1> static inline TCGOp *tcg_emit_op(TCGOpcode opc)\n<13> TCGOp *op = &ctx->gen_op_buf[oi];\n<25> memset(op, 0, offsetof(TCGOp, args));\n<35> return op;
<1> static struct object_entry * dereference ( struct object_entry * oe , unsigned char sha1 [ 20 ] ) {\n<7> oe = insert_object ( sha1 ) ;\n<12> switch ( oe -> type ) {\n<18> buf = gfi_unpack_entry ( oe , & size ) ;\n<22> buf = read_sha1_file ( sha1 , & unused , & size ) ;\n<24> if ( ! buf ) die ( "Can't load object %s" , sha1_to_hex ( sha1 ) ) ;\n<25> switch ( oe -> type ) {\n<26> case OBJ_TAG : if ( size < 40 + strlen ( "object " ) || get_sha1_hex ( buf + strlen ( "object " ) , sha1 ) ) die ( "Invalid SHA1 in tag: %s" , command_buf . buf ) ;\n<28> case OBJ_COMMIT : if ( size < 40 + strlen ( "tree " ) || get_sha1_hex ( buf + strlen ( "tree " ) , sha1 ) ) die ( "Invalid SHA1 in commit: %s" , command_buf . buf ) ;\n<30> free ( buf ) ;\n<31> return find_object ( sha1 ) ;
<1> static int ipvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> IpvideoContext * s = avctx -> priv_data ;\n<16> const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n<17> if ( pal ) {\n<19> memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n<22> ipvideo_decode_opcodes ( s , frame ) ;
<1> rfbBool rfbSendNewFBSize ( rfbClientPtr cl , int w , int h ) {\n<3> if ( cl -> ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE ) {\n<4> if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n<8> rect . encoding = Swap32IfLE ( rfbEncodingNewFBSize ) ;\n<13> memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ;\n<14> cl -> ublen += sz_rfbFramebufferUpdateRectHeader ;\n<15> rfbStatRecordEncodingSent ( cl , rfbEncodingNewFBSize , sz_rfbFramebufferUpdateRectHeader , sz_rfbFramebufferUpdateRectHeader ) ;
<1> static inline void vmsvga_cursor_define ( struct vmsvga_state_s * s , struct vmsvga_cursor_definition_s * c ) {\n<20> default : fprintf ( stderr , "%s: unhandled bpp %d, using fallback cursor\n" , __func__ , c -> bpp ) ;
<1> static int openfile(char *name, int flags, int growable)\n<5> if (bs) {\n<7> fprintf(stderr, "file open already, try 'help close'\n");\n<23> if (bdrv_open(bs, name, flags) == -1) {\n<25> fprintf(stderr, "%s: can't open device %s\n", progname, name);\n<39> if (!bs->drv || !bs->drv->protocol_name) {
<1> static void http_highport_test ( void ) {\n<4> fprintf ( stdout , "Testing HTTP Server with high port: " ) ;\n<6> i < 50 ;\n<9> if ( myhttp != NULL ) {\n<10> fprintf ( stdout , "OK\n" ) ;\n<15> fprintf ( stdout , "FAILED\n" ) ;
<1> static size_t kex_method_strlen ( LIBSSH2_COMMON_METHOD * * method ) {\n<2> size_t len = 0 ;\n<6> while ( * method && ( * method ) -> name ) {\n<7> len += strlen ( ( * method ) -> name ) + 1 ;\n<10> return len - 1 ;
<1> static int dxtory_decode_v1_rgb(AVCodecContext *avctx, AVFrame *pic,\n<3> const uint8_t *src, int src_size,\n<35> dst = pic->data[0];\n<37> for (h = 0; h < avctx->height; h++) {\n<39> memcpy(dst, src, avctx->width * bpp);\n<41> src += avctx->width * bpp;\n<43> dst += pic->linesize[0];
<1> static int net_bridge_run_helper(const char *helper, const char *bridge)\n<37> if (pid == 0) {\n<65> if (strrchr(helper, ' ') || strrchr(helper, '\t')) {\n<71> if (strstr(helper, "--br=") == NULL) {\n<73> snprintf(br_buf, sizeof(br_buf), "%s%s", "--br=", bridge);\n<79> snprintf(helper_cmd, sizeof(helper_cmd), "%s %s %s %s",\n<93> *parg++ = NULL;\n<131> } else if (pid > 0) {\n<161> if (fd < 0) {\n<163> fprintf(stderr, "failed to recv file descriptor\n");\n<171> if (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n<179> fprintf(stderr, "failed to launch bridge helper\n");
<1> static afs_int32 addToGroup ( struct rx_call * call , afs_int32 aid , afs_int32 gid , afs_int32 * cid ) {\n<13> if ( code ) return code ;\n<22> memset ( & uentry , 0 , sizeof ( uentry ) ) ;\n<23> code = pr_ReadEntry ( tt , 0 , tempu , & uentry ) ;
<1> void ff_celt_quant_bands(CeltFrame *f, OpusRangeCoder *rc)\n<7> float norm1[2 * 8 * 100];\n<9> float *norm2 = norm1 + 8 * 100;\n<77> if (i == f->start_band + 1) {\n<89> memcpy(&norm1[offset], &norm1[offset - count], count * sizeof(float));\n<93> if (f->channels == 2)\n<95> memcpy(&norm2[offset], &norm2[offset - count], count * sizeof(float));\n<151> norm1[j] = (norm1[j] + norm2[j]) / 2;\n<157> norm_loc1 = effective_lowband != -1 ? norm1 + (effective_lowband << f->size) : NULL;\n<159> norm_loc2 = effective_lowband != -1 ? norm2 + (effective_lowband << f->size) : NULL;\n<175> cm[1] = f->pvq->quant_band(f->pvq, f, rc, i, Y, NULL, band_size, b >> 1,\n<179> norm2 + band_offset, 0, 1.0f,\n<185> cm[0] = f->pvq->quant_band(f->pvq, f, rc, i, X,    Y, band_size, b >> 0,\n<189> norm1 + band_offset, 0, 1.0f,
<1> static bool find_hierarchy_mountpts ( struct cgroup_meta_data * meta_data , char * * kernel_subsystems ) {\n<4> char * line = NULL ;\n<6> char * * tokens = NULL ;\n<13> if ( ! proc_self_mountinfo ) return false ;\n<14> while ( getline ( & line , & sz , proc_self_mountinfo ) != - 1 ) {\n<20> if ( line [ 0 ] && line [ strlen ( line ) - 1 ] == '\n' ) line [ strlen ( line ) - 1 ] = '\0' ;\n<21> for ( i = 0 , line_tok = line ;\n<26> tokens [ i ++ ] = token ;\n<29> j < i && tokens [ j ] ;\n<30> j ++ ) if ( ! strcmp ( tokens [ j ] , "-" ) ) break ;\n<31> if ( j >= i || ! tokens [ j ] ) continue ;\n<32> if ( i != j + 4 ) continue ;\n<33> if ( strcmp ( tokens [ j + 1 ] , "cgroup" ) != 0 ) continue ;\n<34> subsystems = subsystems_from_mount_options ( tokens [ j + 3 ] , kernel_subsystems ) ;\n<35> if ( ! subsystems ) goto out ;\n<45> lxc_free_array ( ( void * * ) subsystems , free ) ;\n<47> if ( r < 0 ) goto out ;\n<48> mount_point = calloc ( 1 , sizeof ( * mount_point ) ) ;\n<49> if ( ! mount_point ) goto out ;\n<50> meta_data -> mount_points [ mount_point_count ++ ] = mount_point ;\n<51> mount_point -> hierarchy = h ;\n<52> mount_point -> mount_point = strdup ( tokens [ 4 ] ) ;\n<53> mount_point -> mount_prefix = strdup ( tokens [ 3 ] ) ;\n<54> if ( ! mount_point -> mount_point || ! mount_point -> mount_prefix ) goto out ;\n<55> mount_point -> read_only = ! lxc_string_in_list ( "rw" , tokens [ 5 ] , ',' ) ;\n<56> if ( ! strcmp ( mount_point -> mount_prefix , "/" ) ) {\n<57> if ( mount_point -> read_only ) {\n<58> if ( ! h -> ro_absolute_mount_point ) h -> ro_absolute_mount_point = mount_point ;\n<61> if ( ! h -> rw_absolute_mount_point ) h -> rw_absolute_mount_point = mount_point ;\n<67> h -> all_mount_points [ k ] = mount_point ;\n<71> free ( tokens ) ;\n<72> free ( line ) ;
<1> static int queue_picture(VideoState *is, AVFrame *src_frame, double pts1, int64_t pos)\n<142> if (is->videoq.abort_request)\n<173> memset(&pict,0,sizeof(AVPicture));\n<211> fprintf(stderr, "Cannot initialize the conversion context\n");
<1> static void send_restrict_entry ( restrict_u * pres , int ipv6 , u_int idx ) {\n<32> switch ( which ) {\n<33> case 0 : snprintf ( tag , sizeof ( tag ) , addr_fmtu , idx ) ;\n<34> pch = stoa ( & addr ) ;\n<35> ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;\n<37> case 1 : snprintf ( tag , sizeof ( tag ) , mask_fmtu , idx ) ;\n<38> pch = stoa ( & mask ) ;\n<39> ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;\n<44> case 3 : snprintf ( tag , sizeof ( tag ) , flags_fmt , idx ) ;\n<48> pch = access_str ;\n<53> pch = buf ;\n<55> ctl_putunqstr ( tag , pch , strlen ( pch ) ) ;
<1> static int oma_read_seek(struct AVFormatContext *s,\n<7> OMAContext *oc = s->priv_data;\n<21> if (err || avio_tell(s->pb) < oc->content_start)\n<25> if ((err = avio_seek(s->pb, -8, SEEK_CUR)) < 0)\n<29> if ((err = avio_read(s->pb, oc->iv, 8)) < 8) {\n<45> memset(oc->iv, 0, 8);
<1> void set_link_completion(ReadLineState *rs, int nb_args, const char *str)\n<9> len = strlen(str);\n<11> readline_set_completion_index(rs, len);\n<29> if (!strncmp(str, name, len)) {\n<39> add_completion_option(rs, str, "on");
<1> static void ehci_advance_async_state(EHCIState *ehci)\n<9> switch(ehci_get_state(ehci, async)) {\n<99> fprintf(stderr, "ehci: Bad asynchronous state %d. "
<1> static void load_elf_image(const char *image_name, int image_fd,\n<5> char bprm_buf[BPRM_BUF_SIZE])\n<23> errmsg = "Invalid ELF image for this architecture";\n<25> if (!elf_check_ident(ehdr)) {\n<33> if (!elf_check_ehdr(ehdr)) {\n<53> if (retval != i) {\n<133> if (load_addr == -1) {\n<147> probe_guest_base(image_name, loaddr, hiaddr);\n<218> struct elf_phdr *eppnt = phdr + i;\n<248> image_fd, eppnt->p_offset - vaddr_po);\n<250> if (error == -1) {\n<320> if (*pinterp_name) {\n<322> errmsg = "Multiple PT_INTERP entries";\n<328> interp_name = malloc(eppnt->p_filesz);\n<330> if (!interp_name) {\n<338> if (eppnt->p_offset + eppnt->p_filesz <= BPRM_BUF_SIZE) {\n<340> memcpy(interp_name, bprm_buf + eppnt->p_offset,\n<350> if (retval != eppnt->p_filesz) {\n<358> if (interp_name[eppnt->p_filesz - 1] != 0) {\n<360> errmsg = "Invalid PT_INTERP entry";\n<366> *pinterp_name = interp_name;\n<402> if (retval >= 0) {\n<404> errmsg = "Incomplete read of file header";\n<412> errmsg = strerror(errno);\n<416> fprintf(stderr, "%s: %s\n", image_name, errmsg);
<1> bool acl_check_host ( const char * host , const char * ip ) {\n<2> if ( allow_all_hosts ) return 0 ;\n<4> if ( ( host && hash_search ( & acl_check_hosts , ( uchar * ) host , strlen ( host ) ) ) || ( ip && hash_search ( & acl_check_hosts , ( uchar * ) ip , strlen ( ip ) ) ) ) {
<1> static void cirrus_init_common(CirrusVGAState * s, int device_id, int is_pci)\n<112> s->real_vram_size = 4096 * 1024;\n<140> s->real_vram_size = 2048 * 1024;\n<154> memset(s->vram_ptr, 0xff, s->real_vram_size);\n<168> cpu_register_io_memory(0, cirrus_linear_read, cirrus_linear_write,\n<180> cpu_register_io_memory(0, cirrus_linear_bitblt_read, cirrus_linear_bitblt_write,\n<190> cpu_register_io_memory(0, cirrus_mmio_read, cirrus_mmio_write, s);\n<196> s->cirrus_addr_mask = s->real_vram_size - 1;\n<214> register_savevm("cirrus_vga", 0, 2, cirrus_vga_save, cirrus_vga_load, s);
<1> static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time)\n<5> char buf[1024];\n<41> if (!is_last_report) {\n<51> if ((cur_time - last_time) < 500000)\n<79> buf[0] = '\0';\n<87> float q = -1;\n<95> q = ost->quality / (float) FF_QP2LAMBDA;\n<99> if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<101> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q);\n<103> av_bprintf(&buf_script, "stream_%d_%d_q=%.1f\n",\n<109> if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<115> frame_number = ost->frame_number;\n<117> fps = t > 1 ? frame_number / t : 0;\n<119> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3.*f q=%3.1f ",\n<121> frame_number, fps < 9.95, fps, q);\n<123> av_bprintf(&buf_script, "frame=%d\n", frame_number);\n<125> av_bprintf(&buf_script, "fps=%.1f\n", fps);\n<127> av_bprintf(&buf_script, "stream_%d_%d_q=%.1f\n",\n<131> if (is_last_report)\n<133> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L");\n<145> for (j = 0; j < 32; j++)\n<147> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log2(qp_histogram[j] + 1)));\n<153> if ((enc->flags & AV_CODEC_FLAG_PSNR) && (ost->pict_type != AV_PICTURE_TYPE_NONE || is_last_report)) {\n<163> char type[3] = { 'Y','U','V' };\n<165> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR=");\n<167> for (j = 0; j < 3; j++) {\n<191> p = psnr(error / scale);\n<193> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[j], p);\n<195> av_bprintf(&buf_script, "stream_%d_%d_psnr_%c=%2.2f\n",\n<197> ost->file_index, ost->index, type[j] | 32, p);\n<203> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum / scale_sum));\n<237> secs %= 60;\n<239> hours = mins / 60;\n<241> mins %= 60;\n<251> if (total_size < 0) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<255> else                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<257> "size=%8.0fkB time=", total_size / 1024.0);\n<259> if (pts < 0)\n<261> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "-");\n<263> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n<267> (100 * us) / AV_TIME_BASE);\n<271> if (bitrate < 0) {\n<273> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),"bitrate=N/A");\n<279> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),"bitrate=%6.1fkbits/s", bitrate);\n<281> av_bprintf(&buf_script, "bitrate=%6.1fkbits/s\n", bitrate);\n<293> av_bprintf(&buf_script, "out_time=%02d:%02d:%02d.%06d\n",\n<299> if (nb_frames_dup || nb_frames_drop)\n<301> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d",\n<305> av_bprintf(&buf_script, "dup_frames=%d\n", nb_frames_dup);\n<307> av_bprintf(&buf_script, "drop_frames=%d\n", nb_frames_drop);\n<311> if (speed < 0) {\n<313> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf)," speed=N/A");\n<319> snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf)," speed=%4.3gx", speed);\n<321> av_bprintf(&buf_script, "speed=%4.3gx\n", speed);\n<329> const char end = is_last_report ? '\n' : '\r';\n<331> if (print_stats==1 && AV_LOG_INFO > av_log_get_level()) {\n<333> fprintf(stderr, "%s    %c", buf, end);\n<337> av_log(NULL, AV_LOG_INFO, "%s    %c", buf, end);\n<341> fflush(stderr);
<1> static int localmom ( void ) {\n<9> if ( local_conn >= 0 ) {\n<12> memset ( & remote , 0 , sizeof ( remote ) ) ;\n<37> if ( connect ( sock , ( struct sockaddr * ) & remote , sizeof ( remote ) ) < 0 ) {
<1> int ff_h2645_packet_split(H2645Packet *pkt, const uint8_t *buf, int length,\n<127> if (pkt->nals_allocated < pkt->nb_nals + 1) {\n<133> if (!tmp)\n<139> pkt->nals = tmp;\n<143> (new_size - pkt->nals_allocated) * sizeof(*tmp));
<1> static int rtp_packetize_jpeg ( sout_stream_id_sys_t * id , block_t * in ) {\n<5> const uint8_t * qtables = NULL ;\n<15> p_data += 2 ;\n<28> qtables = section_body ;\n<57> p_data += 2 + section_size ;\n<76> if ( out == NULL ) return VLC_ENOMEM ;\n<83> * p ++ = h ;\n<88> p += 2 ;\n<94> p += 2 ;\n<96> i < nb_qtables ;\n<98> memcpy ( p , & qtables [ 65 * i + 1 ] , 64 ) ;\n<99> p += 64 ;\n<102> rtp_packetize_common ( id , out , ( i_payload == i_data ) , ( in -> i_pts > VLC_TS_INVALID ? in -> i_pts : in -> i_dts ) ) ;\n<103> memcpy ( p , p_data , i_payload ) ;\n<107> p_data += i_payload ;\n<108> i_data -= i_payload ;\n<109> off += i_payload ;
<1> static BusState * qbus_find_recursive ( BusState * bus , const char * name , const BusInfo * info ) {\n<5> if ( name && ( strcmp ( bus -> name , name ) != 0 ) ) {\n<6> match = 0 ;\n<12> return bus ;\n<16> ret = qbus_find_recursive ( child , name , info ) ;
<1> static void * evport_init ( struct event_base * base ) {\n<4> if ( evutil_getenv ( "EVENT_NOEVPORT" ) ) return ( NULL ) ;\n<5> if ( ! ( evpd = calloc ( 1 , sizeof ( struct evport_data ) ) ) ) return ( NULL ) ;\n<6> if ( ( evpd -> ed_port = port_create ( ) ) == - 1 ) {\n<7> free ( evpd ) ;\n<10> evpd -> ed_fds = calloc ( DEFAULT_NFDS , sizeof ( struct fd_info ) ) ;\n<11> if ( evpd -> ed_fds == NULL ) {\n<12> close ( evpd -> ed_port ) ;\n<13> free ( evpd ) ;\n<21> return ( evpd ) ;
<1> static int decrypt_nss ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n<8> int datalen = * buf_len - SALT_SIZE ;\n<27> if ( PK11_DigestFinal ( decrypt_context , outbuf + tmp1_outlen , & tmp2_outlen , sizeof ( outbuf ) - tmp1_outlen ) != SECSuccess ) {\n<31> outbuf_len = tmp1_outlen + tmp2_outlen ;\n<32> memset ( buf , 0 , * buf_len ) ;\n<33> memcpy ( buf , outbuf , outbuf_len ) ;\n<34> * buf_len = outbuf_len ;
<1> static void nice_time ( double sec , char * buff , bool part_second ) {\n<7> buff = strmov ( buff , tmp > 1 ? " days " : " day " ) ;\n<13> buff = strmov ( buff , tmp > 1 ? " hours " : " hour " ) ;\n<15> if ( sec >= 60.0 ) {\n<17> sec -= 60.0 * tmp ;\n<19> buff = strmov ( buff , " min " ) ;\n<21> if ( part_second ) sprintf ( buff , "%.2f sec" , sec ) ;\n<22> else sprintf ( buff , "%d sec" , ( int ) sec ) ;
<1> void qmp_block_commit(const char *device,\n<75> if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_COMMIT, errp)) {\n<89> if (has_top && top) {\n<91> if (strcmp(bs->filename, top) != 0) {\n<93> top_bs = bdrv_find_backing_image(bs, top);\n<103> error_setg(errp, "Top image file %s not found", top ? top : "NULL");\n<153> if (top_bs == bs) {\n<165> commit_active_start(bs, base_bs, speed, on_error, block_job_cb,\n<171> commit_start(bs, base_bs, top_bs, speed, on_error, block_job_cb, bs,
<1> static void i6300esb_pc_init(PCIBus *pci_bus)\n<11> if (!pci_bus) {\n<13> fprintf(stderr, "wdt_i6300esb: no PCI bus in this machine\n");
<1> static int raw_open_common(BlockDriverState *bs, QDict *options,
<1> static int read_probe(AVProbeData *pd)\n<5> if (pd->buf[0] == 'J' && pd->buf[1] == 'V' && strlen(MAGIC) <= pd->buf_size - 4 &&\n<7> !memcmp(pd->buf + 4, MAGIC, strlen(MAGIC)))
<1> struct instruction * compiler_create_instruction ( struct filter_op * fop ) {\n<3> SAFE_CALLOC ( ins , 1 , sizeof ( struct instruction ) ) ;\n<4> memcpy ( & ins -> fop , fop , sizeof ( struct filter_op ) ) ;
<1> int av_vdpau_bind_context(AVCodecContext *avctx, VdpDevice device,\n<17> if (av_reallocp(&avctx->hwaccel_context, sizeof(*hwctx)))\n<23> hwctx = avctx->hwaccel_context;\n<27> memset(hwctx, 0, sizeof(*hwctx));
<1> static void smc_decode_stream(SmcContext *s)\n<71> memcpy(s->frame.data[1], s->pal, AVPALETTE_SIZE);
<1> static int xmlrpc_split_buf ( char * buffer , char * * * argv ) {\n<8> data = buffer ;\n<10> while ( ( data = strstr ( data , "<value>" ) ) ) {\n<11> data += 7 ;\n<12> nexttag = strchr ( data , '<' ) ;\n<13> if ( nexttag == NULL ) break ;\n<14> nexttag ++ ;\n<15> p = strchr ( nexttag , '>' ) ;\n<16> if ( p == NULL ) break ;\n<18> if ( ! stricmp ( "string" , nexttag ) ) tagtype = 1 ;\n<20> str = p ;\n<21> p = strchr ( str , '<' ) ;\n<22> if ( p == NULL ) break ;\n<28> if ( tagtype == 1 ) ( * argv ) [ ac ++ ] = xmlrpc_decode_string ( str ) ;\n<29> else ( * argv ) [ ac ++ ] = str ;\n<30> data = p ;
<1> static void list_item_verbose ( struct cpio * cpio , struct archive_entry * entry ) {\n<3> char date [ 32 ] ;\n<6> FILE * out = stdout ;\n<13> uname = uids ;\n<15> gname = gids ;\n<19> if ( uname == NULL ) uname = lookup_uname ( cpio , ( uid_t ) archive_entry_uid ( entry ) ) ;\n<21> if ( gname == NULL ) gname = lookup_gname ( cpio , ( uid_t ) archive_entry_gid ( entry ) ) ;\n<24> snprintf ( size , sizeof ( size ) , "%lu,%lu" , ( unsigned long ) archive_entry_rdevmajor ( entry ) , ( unsigned long ) archive_entry_rdevminor ( entry ) ) ;\n<27> strcpy ( size , cpio_i64toa ( archive_entry_size ( entry ) ) ) ;\n<35> fprintf ( out , "%s%3d %-8s %-8s %8s %12s %s" , archive_entry_strmode ( entry ) , archive_entry_nlink ( entry ) , uname , gname , size , date , archive_entry_pathname ( entry ) ) ;\n<36> if ( archive_entry_hardlink ( entry ) ) fprintf ( out , " link to %s" , archive_entry_hardlink ( entry ) ) ;\n<37> else if ( archive_entry_symlink ( entry ) ) fprintf ( out , " -> %s" , archive_entry_symlink ( entry ) ) ;\n<38> fprintf ( out , "\n" ) ;
<1> static int convert_to_string ( const gs_memory_t * mem , os_ptr op1 , os_ptr op ) {\n<4> int code = obj_cvs ( mem , op1 , op -> value . bytes , r_size ( op ) , & len , & pstr ) ;\n<7> case t_oparray : case t_operator : if ( pstr != 0 ) switch ( * pstr ) {\n<8> case '%' : case '.' : case '@' : len = r_size ( op ) ;\n<9> memcpy ( op -> value . bytes , pstr , len ) ;\n<16> r_set_size ( op1 , len ) ;
<1> static ssize_t gunzip(void *dst, size_t dstlen, uint8_t *src,\n<67> if (r != Z_OK) {\n<69> printf ("Error: inflateInit2() returned %d\n", r);\n<85> if (r != Z_OK && r != Z_STREAM_END) {\n<87> printf ("Error: inflate() returned %d\n", r);
<1> static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n<79> if (!region)\n<115> clut_table = clut->clut4;\n<121> clut_table = clut->clut256;\n<129> clut_table = clut->clut16;\n<139> if (!rect->data[1]) {\n<147> memcpy(rect->data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n<151> rect->data[0] = av_malloc(region->buf_size);\n<153> if (!rect->data[0]) {\n<155> av_free(rect->data[1]);\n<163> memcpy(rect->data[0], region->pbuf, region->buf_size);
<1> void RECORD_LAYER_reset_read_sequence ( RECORD_LAYER * rl ) {\n<2> memset ( rl -> read_sequence , 0 , sizeof ( rl -> read_sequence ) ) ;
<1> int main ( int argc , char * * argv ) {\n<5> int frame_count = 0 ;\n<15> memset ( & info , 0 , sizeof ( info ) ) ;\n<32> printf ( "Using %s\n" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ;\n<41> writer = vpx_video_writer_open ( argv [ 5 ] , kContainerIVF , & info ) ;\n<56> encode_frame ( & codec , & raw , frame_count , writer ) ;\n<60> printf ( "\n" ) ;\n<62> printf ( "Processed %d frames.\n" , frame_count ) ;
<1> static inline void xan_wc3_copy_pixel_run ( XanContext * s , AVFrame * frame , int x , int y , int pixel_count , int motion_x , int motion_y ) {\n<9> palette_plane = frame -> data [ 0 ] ;\n<11> if ( ! prev_palette_plane ) prev_palette_plane = palette_plane ;\n<14> curframe_index = y * stride + x ;\n<16> prevframe_index = ( y + motion_y ) * stride + x + motion_x ;\n<18> while ( pixel_count && curframe_index < s -> frame_size && prevframe_index < s -> frame_size ) {\n<19> int count = FFMIN3 ( pixel_count , width - curframe_x , width - prevframe_x ) ;\n<20> memcpy ( palette_plane + curframe_index , prev_palette_plane + prevframe_index , count ) ;\n<21> pixel_count -= count ;\n<22> curframe_index += count ;\n<23> prevframe_index += count ;\n<24> curframe_x += count ;\n<25> prevframe_x += count ;\n<27> curframe_index += line_inc ;\n<31> prevframe_index += line_inc ;
<1> static int fts_build_unstructured_header ( struct fts_mail_build_context * ctx , const struct message_header_line * hdr ) {\n<2> const unsigned char * data = hdr -> full_value ;\n<7> i < hdr -> full_value_len ;\n<8> i ++ ) {\n<9> if ( data [ i ] == '\0' ) {\n<10> if ( buf == NULL ) {\n<11> buf = i_malloc ( hdr -> full_value_len ) ;\n<12> memcpy ( buf , data , i ) ;\n<13> data = buf ;\n<15> buf [ i ] = ' ' ;\n<17> else if ( buf != NULL ) {\n<18> buf [ i ] = data [ i ] ;\n<22> i_free ( buf ) ;
<1> static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val)\n<5> fprintf(stderr, "EHCI doesn't handle 16-bit writes to MMIO\n");
<17> if ( p_block -> i_pts > VLC_TS_INVALID ) {\n<18> mtime_t * p_pts = malloc ( sizeof ( * p_pts ) ) ;\n<21> p_schrobuffer -> tag = schro_tag_new ( p_pts , free ) ;
<1> static void vmdaudio_loadsound(VmdAudioContext *s, unsigned char *data,\n<11> if (silence)\n<13> memset(data, 0, s->block_align * 2);\n<21> if (silence)\n<23> memset(data, 0, s->block_align * 2);
<1> static int dct_quantize_trellis_c ( MpegEncContext * s , int16_t * block , int n , int qscale , int * overflow ) {\n<24> s -> dsp . fdct ( block ) ;\n<25> if ( s -> dct_error_sum ) s -> denoise_dct ( s , block ) ;\n<39> block [ 0 ] = ( block [ 0 ] + ( q >> 1 ) ) / q ;\n<61> int level = block [ j ] * qmat [ j ] ;\n<71> int level = block [ j ] * qmat [ j ] ;\n<93> if ( last_non_zero < start_i ) {\n<94> memset ( block + start_i , 0 , ( 64 - start_i ) * sizeof ( int16_t ) ) ;\n<104> int dct_coeff = FFABS ( block [ scantable [ i ] ] ) ;\n<224> dc = FFABS ( block [ 0 ] ) ;\n<226> memset ( block + start_i , 0 , ( 64 - start_i ) * sizeof ( int16_t ) ) ;
<1> static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n<3> if ( len < 16 ) return ;\n<4> if ( userid < 0 || userid >= created_users ) return ;\n<7> if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;\n<8> if ( debug >= 1 ) {\n<9> fprintf ( stderr , "IN login raw, len %d, from user %d\n" , len , userid ) ;\n<11> login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;\n<12> if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n<14> users [ userid ] . last_pkt = time ( NULL ) ;\n<15> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<16> tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n<17> memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n<18> user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n<19> login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;\n<20> send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;\n<21> users [ userid ] . authenticated_raw = 1 ;
<1> static int fix_paths ( void ) {\n<2> char buff [ FN_REFLEN ] , * pos ;\n<20> my_realpath ( mysql_unpacked_real_data_home , mysql_real_data_home , MYF ( 0 ) ) ;\n<21> mysql_unpacked_real_data_home_len = ( int ) strlen ( mysql_unpacked_real_data_home ) ;\n<22> if ( mysql_unpacked_real_data_home [ mysql_unpacked_real_data_home_len - 1 ] == FN_LIBCHAR ) -- mysql_unpacked_real_data_home_len ;\n<37> if ( * opt_secure_file_priv == 0 ) {\n<42> if ( strlen ( opt_secure_file_priv ) >= FN_REFLEN ) opt_secure_file_priv [ FN_REFLEN - 1 ] = '\0' ;\n<43> if ( my_realpath ( buff , opt_secure_file_priv , 0 ) ) {\n<47> char * secure_file_real_path = ( char * ) my_malloc ( FN_REFLEN , MYF ( MY_FAE ) ) ;
<1> static int PSAddImagemask ( EntityChar * ec , struct psstack * stack , int sp , real transform [ 6 ] , Color fillcol ) {\n<28> data = StringToBytes ( & stack [ sp - 1 ] , & datalen ) ;\n<29> if ( width <= 0 || height <= 0 || ( ( width + 7 ) / 8 ) * height > datalen ) {\n<31> free ( data ) ;\n<41> base = gi -> u . image ;\n<45> i < datalen ;\n<46> ++ i ) data [ i ] ^= 0xff ;\n<48> if ( trans [ 0 ] > 0 && trans [ 3 ] < 0 ) memcpy ( base -> data , data , datalen ) ;\n<51> i < height ;\n<52> ++ i ) memcpy ( base -> data + i * base -> bytes_per_line , data + ( height - i ) * base -> bytes_per_line , base -> bytes_per_line ) ;\n<60> if ( data [ i * base -> bytes_per_line + ( j >> 3 ) ] & ( 0x80 >> ( j & 7 ) ) ) base -> data [ i * base -> bytes_per_line + ( ( width - j - 1 ) >> 3 ) ] |= ( 0x80 >> ( ( width - j - 1 ) & 7 ) ) ;\n<69> if ( data [ i * base -> bytes_per_line + ( j >> 3 ) ] & ( 0x80 >> ( j & 7 ) ) ) base -> data [ ( height - i - 1 ) * base -> bytes_per_line + ( ( width - j - 1 ) >> 3 ) ] |= ( 0x80 >> ( ( width - j - 1 ) & 7 ) ) ;\n<72> free ( data ) ;\n<73> ent = calloc ( 1 , sizeof ( Entity ) ) ;\n<76> memcpy ( ent -> u . image . transform , transform , sizeof ( real [ 6 ] ) ) ;\n<82> ec -> splines = ent ;
<1> void os_set_proc_name(const char *s)\n<31> fprintf(stderr, "Change of process name not supported by your OS\n");
<1> static void decode_band_structure ( GetBitContext * gbc , int blk , int eac3 , int ecpl , int start_subband , int end_subband , const uint8_t * default_band_struct , int * num_bands , uint8_t * band_sizes ) {\n<2> int subbnd , bnd , n_subbands , n_bands = 0 ;\n<3> uint8_t bnd_sz [ 22 ] ;\n<21> if ( num_bands || band_sizes ) {\n<22> n_bands = n_subbands ;\n<23> bnd_sz [ 0 ] = ecpl ? 6 : 12 ;\n<29> n_bands -- ;\n<30> bnd_sz [ bnd ] += subbnd_size ;\n<33> bnd_sz [ ++ bnd ] = subbnd_size ;\n<38> if ( band_sizes ) memcpy ( band_sizes , bnd_sz , n_bands ) ;
<1> static void outputarr ( FILE * fp , char * name , int narr , l_fp * lfp ) {\n<8> for ( i = ( int ) strlen ( name ) ;\n<9> i < 11 ;\n<12> i > 0 ;\n<15> cp = lfptoms ( lfp , 2 ) ;\n<16> len = strlen ( cp ) ;\n<17> if ( len > 7 ) {\n<18> cp [ 7 ] = '\0' ;\n<25> while ( * cp != '\0' ) * bp ++ = * cp ++ ;\n<29> output ( fp , name , buf ) ;
<1> static gcry_err_code_t oaep_decode ( unsigned char * * r_result , size_t * r_resultlen , unsigned int nbits , int algo , gcry_mpi_t value , const unsigned char * label , size_t labellen ) {\n<23> gcry_md_hash_buffer ( algo , lhash , label , labellen ) ;\n<36> if ( ! seed ) {\n<49> n ++ ) seed [ n ] ^= masked_seed [ n ] ;\n<50> if ( mgf1 ( db , db_len , seed , hlen , algo ) ) failed = 1 ;\n<53> n ++ ) db [ n ] ^= masked_db [ n ] ;\n<54> if ( memcmp ( lhash , db , hlen ) ) failed = 1 ;\n<55> for ( n = hlen ;\n<57> n ++ ) if ( db [ n ] == 0x01 ) break ;\n<60> gcry_free ( lhash ) ;\n<62> if ( failed ) {\n<66> n ++ ;\n<67> memmove ( seed , db + n , db_len - n ) ;\n<68> * r_result = seed ;
<1> int qemuMonitorTextInjectNMI ( qemuMonitorPtr mon ) {\n<3> char * reply = NULL ;\n<4> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) goto fail ;\n<5> if ( strstr ( reply , "unknown command" ) != NULL ) {\n<6> VIR_FREE ( reply ) ;\n<7> cmd = "nmi 0" ;\n<8> reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) goto fail ;\n<11> VIR_FREE ( reply ) ;\n<12> return 0 ;
<1> static void test_create_drop ( ) {\n<32> i < 3 ;\n<33> i ++ ) {\n<36> if ( ! opt_silent ) fprintf ( stdout , "created %i\n" , i ) ;\n<43> if ( ! opt_silent ) fprintf ( stdout , "dropped %i\n" , i ) ;\n<46> if ( ! opt_silent ) fprintf ( stdout , "created select %i\n" , i ) ;\n<53> if ( ! opt_silent ) fprintf ( stdout , "dropped %i\n" , i ) ;
<1> ser_write(void *opaque, hwaddr addr,\n<19> switch (addr)\n<51> s->regs[R_INTR] &= ~value;\n<53> D(printf("r_intr=%x\n", s->regs[R_INTR]));
<1> void lance_init(NICInfo *nd, int irq, uint32_t leaddr, uint32_t ledaddr)\n<13> if (!s)\n<29> ledma_io_memory = cpu_register_io_memory(0, ledma_mem_read, ledma_mem_write, s);\n<35> memcpy(s->macaddr, nd->macaddr, 6);\n<39> lance_reset(s);\n<43> s->vc = qemu_new_vlan_client(nd->vlan, lance_receive, s);\n<65> register_savevm("lance", leaddr, 1, lance_save, lance_load, s);\n<67> qemu_register_reset(lance_reset, s);
<1> static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n<145> mov_update_dts_shift(sc, ctts_duration);\n<233> sc->ctts_data = ctts_data;\n<235> if (ctts_index != old_nb_index_entries) {\n<237> memmove(sc->ctts_data + ctts_index + 1, sc->ctts_data + ctts_index,\n<239> sizeof(*sc->ctts_data) * (sc->ctts_count - ctts_index));
<1> static void version ( ) {\n<2> fprintf ( stderr , "iodine IP over DNS tunneling server\n" ) ;\n<3> fprintf ( stderr , "Git version: %s\n" , GITREVISION ) ;
<1> static CharDriverState *qemu_chr_open_pty(const char *id,\n<19> if (master_fd < 0) {\n<39> ret->pty = g_strdup(pty_name);\n<45> fprintf(stderr, "char device redirected to %s (label %s)\n",
<1> void ssl3_cbc_copy_mac ( unsigned char * out , const SSL3_RECORD * rec , unsigned md_size ) {\n<17> rotate_offset = ( div_spoiler + mac_start - scan_start ) % md_size ;\n<18> memset ( rotated_mac , 0 , md_size ) ;\n<25> rotated_mac [ j ++ ] |= b & mac_started & ~ mac_ended ;\n<26> j &= constant_time_lt ( j , md_size ) ;\n<37> rotate_offset = md_size - rotate_offset ;\n<44> j ++ ) out [ j ] |= rotated_mac [ i ] & constant_time_eq_8 ( j , rotate_offset ) ;
<1> int gdev_x_open ( gx_device_X * xdev ) {\n<19> char * dispname = getenv ( "DISPLAY" ) ;\n<20> emprintf1 ( xdev -> memory , "Cannot open X display `%s'.\n" , ( dispname == NULL ? "(null)" : dispname ) ) ;
<1> static void test_function(const TestStruct test_sample)\n<21> if (ret < 0){\n<27> printf("written: %d\n", ret);\n<33> if (ret < 0){\n<39> printf("written: %d\n", ret);\n<41> printf("remaining samples in audio_fifo: %d\n\n", av_audio_fifo_size(afifo));\n<47> if (ret < 0){\n<53> printf("read: %d\n", ret);\n<55> print_audio_bytes(&test_sample, output_data, ret);\n<57> printf("remaining samples in audio_fifo: %d\n\n", av_audio_fifo_size(afifo));\n<71> printf("peek:\n");\n<75> printf("\n");\n<81> printf("peek_at:\n");\n<83> for (i = 0; i < afifo->nb_samples; ++i){\n<85> ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);\n<93> printf("%d:\n", i);\n<99> printf("\n");
<1> static void prepare_dummy_password ( char * buf , size_t sz ) {\n<3> strlcpy ( buf , "6F a[" , sz ) ;\n<4> for ( i = strlen ( buf ) ;\n<5> i < sz - 1 ;
<1> static int parse_object_segment(AVCodecContext *avctx,\n<11> id = bytestream_get_be16(&buf);\n<16> object = &ctx->objects.object[ctx->objects.count++];\n<19> buf += 1;\n<21> sequence_desc = bytestream_get_byte(&buf);\n<24> if (buf_size > object->rle_remaining_len)\n<25> memcpy(object->rle + object->rle_data_len, buf, buf_size);\n<26> object->rle_data_len += buf_size;\n<27> object->rle_remaining_len -= buf_size;\n<42> if (!object->rle)\n<44> memcpy(object->rle, buf, buf_size);
<1> static V9fsSynthNode *v9fs_add_dir_node(V9fsSynthNode *parent, int mode,\n<3> const char *name,\n<17> node = g_malloc0(sizeof(V9fsSynthNode));\n<23> node->attr = attr;\n<29> node->attr = &node->actual_attr;\n<47> strncpy(node->name, name, sizeof(node->name));\n<49> QLIST_INSERT_HEAD_RCU(&parent->child, node, sibling);\n<51> return node;
<1> static direntry_t *create_short_filename(BDRVVVFATState *s,\n<19> char tail[11];\n<23> if (!entry) {\n<29> memset(entry->name, 0x20, sizeof(entry->name));\n<71> entry->name[j++] = v;\n<107> entry->name[8 + (j++)] = v;\n<123> if (entry->name[0] == DIR_KANJI) {\n<125> entry->name[0] = DIR_KANJI_FAKE;\n<135> if (entry->name[j] == ' ') {\n<143> for (i = lossy_conversion ? 1 : 0; i < 999999; i++) {\n<147> if (i > 0) {\n<149> int len = sprintf(tail, "~%d", i);\n<151> memcpy(entry->name + MIN(j, 8 - len), tail, len);\n<157> entry1 < entry; entry1++) {\n<159> if (!is_long_name(entry1) &&\n<161> !memcmp(entry1->name, entry->name, 11)) {\n<169> if (entry1 == entry) {\n<173> return entry;
<1> AVStream *add_av_stream1(FFStream *stream, AVCodecContext *codec)\n<11> if (!fst)\n<17> memcpy(&fst->codec, codec, sizeof(AVCodecContext));
<1> static void test_bug9159 ( ) {\n<4> const char * stmt_text = "select a, b from t1" ;\n<11> stmt = mysql_stmt_init ( mysql ) ;\n<12> mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<13> mysql_stmt_attr_set ( stmt , STMT_ATTR_CURSOR_TYPE , ( const void * ) & type ) ;
<1> static void synth_block_hardcoded ( WMAVoiceContext * s , GetBitContext * gb , int block_idx , int size , const struct frame_type_desc * frame_desc , float * excitation ) {\n<13> memset ( s -> gain_pred_err , 0 , sizeof ( s -> gain_pred_err ) ) ;
<1> static int fake_getaddrinfo ( const char * hostname , struct addrinfo * ai ) {\n<4> if ( hostname ) {\n<6> if ( ! he ) return ( - 1 ) ;\n<11> ai -> ai_addrlen = sizeof ( struct sockaddr_in ) ;\n<12> if ( NULL == ( ai -> ai_addr = malloc ( ai -> ai_addrlen ) ) ) return ( - 1 ) ;\n<13> sa = ( struct sockaddr_in * ) ai -> ai_addr ;\n<14> memset ( sa , 0 , ai -> ai_addrlen ) ;\n<15> if ( he ) {\n<17> memcpy ( & sa -> sin_addr , he -> h_addr_list [ 0 ] , he -> h_length ) ;\n<23> ai -> ai_next = NULL ;\n<24> return ( 0 ) ;
<1> static krb5_error_code asn1_decode_sequence_of_keys ( krb5_data * in , krb5_key_data * * out , krb5_int16 * n_key_data , krb5_kvno * mkvno ) {\n<7> err = accessor . asn1_ldap_decode_sequence_of_keys ( in , & p ) ;\n<8> if ( err ) return err ;\n<10> i < p -> n_key_data ;\n<18> free ( p ) ;
<1> void ff_mpeg_unref_picture ( MpegEncContext * s , Picture * pic ) {\n<2> int off = offsetof ( Picture , mb_mean ) + sizeof ( pic -> mb_mean ) ;\n<3> pic -> tf . f = & pic -> f ;\n<7> memset ( ( uint8_t * ) pic + off , 0 , sizeof ( * pic ) - off ) ;
<1> u_short varfmt ( const char * varname ) {\n<4> n < COUNTOF ( cookedvars ) ;\n<5> n ++ ) if ( ! strcmp ( varname , cookedvars [ n ] . varname ) ) return cookedvars [ n ] . fmt ;
<1> void add_command(const cmdinfo_t *ci)\n<5> cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n<9> qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);
<1> static ssize_t virtio_net_receive ( VLANClientState * nc , const uint8_t * buf , size_t size ) {\n<14> struct iovec sg [ VIRTQUEUE_MAX_SIZE ] ;\n<16> if ( virtqueue_pop ( n -> rx_vq , & elem ) == 0 ) {\n<17> if ( i == 0 ) return - 1 ;\n<25> if ( ! n -> mergeable_rx_bufs && elem . in_sg [ 0 ] . iov_len != guest_hdr_len ) {\n<29> memcpy ( & sg , & elem . in_sg [ 0 ] , sizeof ( sg [ 0 ] ) * elem . in_num ) ;\n<32> offset += receive_header ( n , sg , elem . in_num , buf + offset , size - offset , guest_hdr_len ) ;\n<35> len = iov_from_buf ( sg , elem . in_num , 0 , buf + offset , size - offset ) ;
<1> static void steamdiscover_dissect_body_authrequest ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset , gint bytes_left ) {\n<12> switch ( tag . field_number ) {\n<21> devicename = tvb_get_string_enc ( wmem_packet_scope ( ) , pb . tvb , pb . offset + len , ( gint ) value , ENC_UTF_8 ) ;\n<22> if ( devicename && strlen ( devicename ) ) {\n<23> col_append_fstr ( pinfo -> cinfo , COL_INFO , " from %s" , devicename ) ;
<1> static void ctl_puthex ( const char * tag , u_long uval ) {\n<10> snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , "0x%lx" , uval ) ;\n<11> cp += strlen ( cp ) ;\n<12> ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;
<1> static ACL_USER * find_acl_user ( const char * host , const char * user , my_bool exact ) {\n<3> DBUG_PRINT ( "enter" , ( "host: '%s' user: '%s'" , host , user ) ) ;\n<6> i < acl_users . elements ;\n<9> DBUG_PRINT ( "info" , ( "strcmp('%s','%s'), compare_hostname('%s','%s')," , user , acl_user -> user ? acl_user -> user : "" , host , acl_user -> host . hostname ? acl_user -> host . hostname : "" ) ) ;\n<10> if ( ( ! acl_user -> user && ! user [ 0 ] ) || ( acl_user -> user && ! strcmp ( user , acl_user -> user ) ) ) {\n<11> if ( exact ? ! my_strcasecmp ( system_charset_info , host , acl_user -> host . hostname ? acl_user -> host . hostname : "" ) : compare_hostname ( & acl_user -> host , host , host ) ) {\n<12> DBUG_RETURN ( acl_user ) ;
<1> TSReturnCode TSMimeHdrFieldNameSet ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , const char * name , int length ) {\n<9> if ( length == - 1 ) {\n<10> length = strlen ( name ) ;\n<18> handle -> field_ptr -> name_set ( heap , handle -> mh , name , length ) ;
<1> static void xml_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n<2> if ( wctx -> nb_item [ wctx -> level ] ) printf ( " " ) ;\n<3> printf ( "%s=\"%lld\"" , key , value ) ;
<1> void add_event ( tm_event_t event , tm_node_id node , int type , void * info ) {\n<3> ep = ( event_info * ) calloc ( 1 , sizeof ( event_info ) ) ;\n<4> assert ( ep != NULL ) ;
<1> void *g_realloc(void * mem, size_t n_bytes)\n<7> mem = realloc(mem, n_bytes == 0 ? 1 : n_bytes);\n<9> if (!mem) __coverity_panic__();
<1> static int decode_user_data(MpegEncContext *s, GetBitContext *gb){\n<3> char buf[256];\n<23> buf[i]=0;\n<29> e=sscanf(buf, "DivX%dBuild%d%c", &ver, &build, &last);\n<31> if(e<2)\n<33> e=sscanf(buf, "DivX%db%d%c", &ver, &build, &last);\n<35> if(e>=2){\n<37> s->divx_version= ver;\n<39> s->divx_build= build;\n<41> s->divx_packed= e==3 && last=='p';\n<49> e=sscanf(buf, "FFmpe%*[^b]b%d", &build)+3;\n<51> if(e!=4)\n<53> e=sscanf(buf, "FFmpeg v%d.%d.%d / libavcodec build: %d", &ver, &ver2, &ver3, &build);\n<55> if(e!=4){\n<57> e=sscanf(buf, "Lavc%d.%d.%d", &ver, &ver2, &ver3)+1;\n<59> build= (ver<<16) + (ver2<<8) + ver3;\n<63> if(e!=4){\n<65> if(strcmp(buf, "ffmpeg")==0){\n<67> s->lavc_build= 4600;\n<75> s->lavc_build= build;\n<83> e=sscanf(buf, "XviD%d", &build);\n<85> if(e==1){\n<87> s->xvid_build= build;
<1> static int decode_slice(AVCodecContext *c, void *arg)\n<49> for (i = 0; i < f->plane_count; i++) {\n<51> PlaneContext *psrc = &fssrc->plane[i];\n<53> PlaneContext *pdst = &fsdst->plane[i];\n<57> av_free(pdst->state);\n<59> av_free(pdst->vlc_state);\n<61> memcpy(pdst, psrc, sizeof(*pdst));\n<69> if (fssrc->ac) {\n<71> pdst->state = av_malloc_array(CONTEXT_SIZE,  psrc->context_count);\n<73> memcpy(pdst->state, psrc->state, CONTEXT_SIZE * psrc->context_count);\n<77> pdst->vlc_state = av_malloc_array(sizeof(*pdst->vlc_state), psrc->context_count);\n<79> memcpy(pdst->vlc_state, psrc->vlc_state, sizeof(*pdst->vlc_state) * psrc->context_count);
<1> static void test_bug10214 ( ) {\n<6> len = mysql_real_escape_string ( mysql , out , "a'b\\c" , 5 ) ;\n<7> DIE_UNLESS ( memcmp ( out , "a\\'b\\\\c" , len ) == 0 ) ;\n<10> len = mysql_real_escape_string ( mysql , out , "a'b\\c" , 5 ) ;\n<11> DIE_UNLESS ( memcmp ( out , "a''b\\c" , len ) == 0 ) ;
<1> static void http_chunked_errorcb ( struct bufferevent * bev , short what , void * arg ) {\n<12> if ( done != ALL_DATA_READ ) goto out ;\n<14> if ( header == NULL || strcmp ( header , "chunked" ) ) goto out ;\n<15> header = evhttp_find_header ( req -> input_headers , "Connection" ) ;\n<16> if ( header == NULL || strcmp ( header , "close" ) ) goto out ;\n<17> header = evbuffer_readline ( EVBUFFER_INPUT ( bev ) ) ;\n<18> if ( header == NULL ) goto out ;\n<19> if ( strcmp ( header , "d" ) ) goto out ;\n<20> free ( ( char * ) header ) ;\n<21> if ( strncmp ( ( char * ) EVBUFFER_DATA ( EVBUFFER_INPUT ( bev ) ) , "This is funny" , 13 ) ) goto out ;\n<24> if ( header == NULL ) goto out ;\n<25> if ( strcmp ( header , "12" ) ) goto out ;\n<26> free ( ( char * ) header ) ;\n<27> if ( strncmp ( ( char * ) EVBUFFER_DATA ( EVBUFFER_INPUT ( bev ) ) , "but not hilarious." , 18 ) ) goto out ;\n<30> if ( header == NULL ) goto out ;\n<31> if ( strcmp ( header , "8" ) ) goto out ;\n<32> free ( ( char * ) header ) ;\n<33> if ( strncmp ( ( char * ) EVBUFFER_DATA ( EVBUFFER_INPUT ( bev ) ) , "bwv 1052." , 8 ) ) goto out ;\n<36> if ( header == NULL ) goto out ;\n<37> if ( strcmp ( header , "0" ) ) goto out ;\n<38> free ( ( char * ) header ) ;\n<39> test_ok = 2 ;
<1> void do_exec ( struct st_command * command ) {\n<18> if ( builtin_echo [ 0 ] && strncmp ( cmd , "echo" , 4 ) == 0 ) {\n<19> replace ( & ds_cmd , "echo" , 4 , builtin_echo , strlen ( builtin_echo ) ) ;\n<24> if ( ! ( res_file = my_popen ( & ds_cmd , "r" ) ) ) {\n<34> while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n<35> if ( disable_result_log ) {\n<36> buf [ strlen ( buf ) - 1 ] = 0 ;\n<37> DBUG_PRINT ( "exec_result" , ( "%s" , buf ) ) ;\n<40> replace_dynstr_append ( ds_result , buf ) ;\n<43> error = pclose ( res_file ) ;
<1> static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)\n<27> if (rdma->host == NULL) {\n<57> if (ret) {\n<73> if (rdma->host && strcmp("", rdma->host)) {\n<79> ret = getaddrinfo(rdma->host, port_str, NULL, &res);\n<81> if (ret < 0) {\n<117> ERROR(errp, "migration host and port not specified!");\n<119> ret = -EINVAL;\n<139> rdma_destroy_id(listen_id);\n<143> rdma_destroy_event_channel(rdma->channel);\n<145> rdma->channel = NULL;\n<147> rdma->error_state = ret;\n<149> return ret;
<1> static void test_bug3035 ( ) {\n<14> char longlong_as_string [ 22 ] , ulonglong_as_string [ 22 ] ;\n<33> stmt_text = "DROP TABLE IF EXISTS t1" ;\n<34> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<36> stmt_text = "CREATE TABLE t1 (i8 TINYINT, ui8 TINYINT UNSIGNED, " "i16 SMALLINT, ui16 SMALLINT UNSIGNED, " "i32 INT, ui32 INT UNSIGNED, " "i64 BIGINT, ui64 BIGINT UNSIGNED, " "id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT)" ;\n<37> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<39> memset ( bind_array , 0 , sizeof ( bind_array ) ) ;\n<40> for ( my_bind = bind_array ;\n<41> my_bind < bind_end ;\n<63> stmt = mysql_stmt_init ( mysql ) ;\n<64> check_stmt ( stmt ) ;\n<65> stmt_text = "INSERT INTO t1 (i8, ui8, i16, ui16, i32, ui32, i64, ui64) " "VALUES (?, ?, ?, ?, ?, ?, ?, ?)" ;\n<66> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<67> check_execute ( stmt , rc ) ;\n<68> mysql_stmt_bind_param ( stmt , bind_array ) ;\n<88> check_execute ( stmt , rc ) ;\n<89> stmt_text = "SELECT i8, ui8, i16, ui16, i32, ui32, i64, ui64, ui64, " "cast(ui64 as signed), ui64, cast(ui64 as signed)" "FROM t1 ORDER BY id ASC" ;\n<90> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<91> check_execute ( stmt , rc ) ;\n<118> DIE_UNLESS ( ! strcmp ( longlong_as_string , "0" ) ) ;\n<119> DIE_UNLESS ( ! strcmp ( ulonglong_as_string , "0" ) ) ;\n<121> if ( ! opt_silent ) {\n<122> printf ( "Truncation mask: " ) ;\n<124> my_bind < bind_end ;\n<125> my_bind ++ ) printf ( "%d" , ( int ) my_bind -> error_value ) ;\n<126> printf ( "\n" ) ;\n<140> DIE_UNLESS ( ! strcmp ( longlong_as_string , "-1" ) ) ;\n<141> DIE_UNLESS ( ! strcmp ( ulonglong_as_string , "18446744073709551615" ) ) ;\n<145> stmt_text = "DROP TABLE t1" ;\n<146> mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static gcry_err_code_t pss_verify ( gcry_mpi_t value , gcry_mpi_t encoded , unsigned int nbits , int algo , size_t saltlen ) {\n<20> if ( ! buf ) {\n<26> rc = octet_string_from_mpi ( NULL , mhash , value , hlen ) ;\n<43> mgf1 ( dbmask , emlen - hlen - 1 , h , hlen , algo ) ;\n<51> if ( n != emlen - hlen - saltlen - 2 || em [ n ++ ] != 1 ) {\n<55> salt = em + n ;\n<56> memset ( buf , 0 , 8 ) ;\n<57> memcpy ( buf + 8 , mhash , hlen ) ;\n<58> memcpy ( buf + 8 + hlen , salt , saltlen ) ;\n<59> gcry_md_hash_buffer ( algo , buf , buf , 8 + hlen + saltlen ) ;\n<60> rc = memcmp ( h , buf , hlen ) ? GPG_ERR_BAD_SIGNATURE : GPG_ERR_NO_ERROR ;\n<66> wipememory ( buf , buflen ) ;\n<69> return rc ;
<1> VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf)\n<27> s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK,\n<59> dinfo = drive_get_by_blockdev(s->bs);\n<61> strncpy(s->sn, dinfo->serial, sizeof (s->sn));\n<69> qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n<71> register_savevm(dev, "virtio-blk", virtio_blk_id++, 2,
<1> static int vscsi_send_adapter_info(VSCSIState *s, vscsi_req *req)\n<31> memset(&info, 0, sizeof(info));\n<35> strncpy(info.partition_name, "qemu", sizeof("qemu"));\n<47> rc = spapr_tce_dma_write(&s->vdev, be64_to_cpu(sinfo->buffer),\n<51> if (rc)  {\n<53> fprintf(stderr, "vscsi_send_adapter_info: DMA write failure !\n");
<1> static int getresponse ( int opcode , int associd , u_short * rstatus , int * rsize , const char * * rdata , int timeo ) {\n<4> u_short offsets [ MAXFRAGS + 1 ] ;\n<5> u_short counts [ MAXFRAGS + 1 ] ;\n<27> FD_SET ( sockfd , & fds ) ;\n<33> if ( n == 0 ) {\n<35> if ( timeo ) fprintf ( stderr , "%s: timed out, nothing received\n" , currenthost ) ;\n<38> if ( timeo ) fprintf ( stderr , "%s: timed out with incomplete data\n" , currenthost ) ;\n<39> if ( debug ) {\n<40> fprintf ( stderr , "ERR_INCOMPLETE: Received fragments:\n" ) ;\n<42> f < numfrags ;\n<43> f ++ ) fprintf ( stderr , "%2u: %5d %5d\t%3d octets\n" , ( u_int ) f , offsets [ f ] , offsets [ f ] + counts [ f ] , counts [ f ] ) ;\n<44> fprintf ( stderr , "last fragment %sreceived\n" , ( seenlastfrag ) ? "" : "not " ) ;\n<48> n = recv ( sockfd , ( char * ) & rpkt , sizeof ( rpkt ) , 0 ) ;\n<49> if ( n == - 1 ) {\n<53> if ( debug >= 4 ) {\n<54> printf ( "Response packet:\n" ) ;\n<55> dump_hex_printable ( & rpkt , n ) ;\n<57> if ( n < ( int ) CTL_HEADER_LEN ) {\n<58> if ( debug ) printf ( "Short (%d byte) packet received\n" , n ) ;\n<61> if ( PKT_VERSION ( rpkt . li_vn_mode ) > NTP_VERSION || PKT_VERSION ( rpkt . li_vn_mode ) < NTP_OLDVERSION ) {\n<62> if ( debug ) printf ( "Packet received with version %d\n" , PKT_VERSION ( rpkt . li_vn_mode ) ) ;\n<65> if ( PKT_MODE ( rpkt . li_vn_mode ) != MODE_CONTROL ) {\n<66> if ( debug ) printf ( "Packet received with mode %d\n" , PKT_MODE ( rpkt . li_vn_mode ) ) ;\n<69> if ( ! CTL_ISRESPONSE ( rpkt . r_m_e_op ) ) {\n<70> if ( debug ) printf ( "Received request packet, wanted response\n" ) ;\n<73> if ( ntohs ( rpkt . sequence ) != sequence ) {\n<74> if ( debug ) printf ( "Received sequnce number %d, wanted %d\n" , ntohs ( rpkt . sequence ) , sequence ) ;\n<77> if ( CTL_OP ( rpkt . r_m_e_op ) != opcode ) {\n<78> if ( debug ) printf ( "Received opcode %d, wanted %d (sequence number okay)\n" , CTL_OP ( rpkt . r_m_e_op ) , opcode ) ;\n<81> if ( CTL_ISERROR ( rpkt . r_m_e_op ) ) {\n<87> if ( ntohs ( rpkt . associd ) != associd ) {\n<88> TRACE ( 1 , ( "Association ID %d doesn't match expected %d\n" , ntohs ( rpkt . associd ) , associd ) ) ;\n<91> offset = ntohs ( rpkt . offset ) ;\n<92> count = ntohs ( rpkt . count ) ;\n<98> if ( n < shouldbesize ) {\n<99> printf ( "Response packet claims %u octets payload, above %ld received\n" , count , ( long ) n - CTL_HEADER_LEN ) ;\n<107> maclen = n - shouldbesize ;\n<108> if ( maclen >= ( int ) MIN_MAC_LEN ) {\n<109> printf ( "Packet shows signs of authentication (total %d, data %d, mac %d)\n" , n , shouldbesize , maclen ) ;\n<111> printf ( "%08lx %08lx %08lx %08lx %08lx %08lx\n" , ( u_long ) ntohl ( lpkt [ ( n - maclen ) / sizeof ( u_int32 ) - 3 ] ) , ( u_long ) ntohl ( lpkt [ ( n - maclen ) / sizeof ( u_int32 ) - 2 ] ) , ( u_long ) ntohl ( lpkt [ ( n - maclen ) / sizeof ( u_int32 ) - 1 ] ) , ( u_long ) ntohl ( lpkt [ ( n - maclen ) / sizeof ( u_int32 ) ] ) , ( u_long ) ntohl ( lpkt [ ( n - maclen ) / sizeof ( u_int32 ) + 1 ] ) , ( u_long ) ntohl ( lpkt [ ( n - maclen ) / sizeof ( u_int32 ) + 2 ] ) ) ;\n<112> key = ntohl ( lpkt [ ( n - maclen ) / sizeof ( u_int32 ) ] ) ;\n<113> printf ( "Authenticated with keyid %lu\n" , ( u_long ) key ) ;\n<114> if ( key != 0 && key != info_auth_keyid ) {\n<115> printf ( "We don't know that key\n" ) ;\n<118> if ( authdecrypt ( key , ( u_int32 * ) & rpkt , n - maclen , maclen ) ) {\n<119> printf ( "Auth okay!\n" ) ;\n<122> printf ( "Auth failed!\n" ) ;\n<132> if ( count == 0 && CTL_ISMORE ( rpkt . r_m_e_op ) ) {\n<140> if ( seenlastfrag && ! CTL_ISMORE ( rpkt . r_m_e_op ) ) {\n<150> f < numfrags && offsets [ f ] < offset ;\n<154> if ( f < numfrags && offset == offsets [ f ] ) {\n<155> TRACE ( 1 , ( "duplicate %u octets at %u ignored, prior %u at %u\n" , count , offset , counts [ f ] , offsets [ f ] ) ) ;\n<158> if ( f > 0 && ( offsets [ f - 1 ] + counts [ f - 1 ] ) > offset ) {\n<162> if ( f < numfrags && ( offset + count ) > offsets [ f ] ) {\n<163> TRACE ( 1 , ( "received %u octet frag at %u overlaps with frag at %u\n" , count , offset , offsets [ f ] ) ) ;\n<172> offsets [ f ] = offset ;\n<173> counts [ f ] = count ;\n<175> if ( ! CTL_ISMORE ( rpkt . r_m_e_op ) ) {\n<177> if ( rstatus != 0 ) * rstatus = ntohs ( rpkt . status ) ;\n<179> memcpy ( ( char * ) pktdata + offset , & rpkt . u , count ) ;\n<183> f ++ ) if ( offsets [ f - 1 ] + counts [ f - 1 ] != offsets [ f ] ) break ;
<1> static int decode_i_frame ( FourXContext * f , AVFrame * frame , const uint8_t * buf , int length ) {\n<20> prestream = read_huffman_tables ( f , prestream ) ;\n<27> av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , prestream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<28> if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n<29> f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) prestream , prestream_size / 4 ) ;\n<30> memset ( ( uint8_t * ) f -> bitstream_buffer + prestream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;
<1> int qcow2_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n<5> BDRVQcowState *s = bs->opaque;\n<11> QCowSnapshot sn1, *sn = &sn1;\n<21> memset(sn, 0, sizeof(*sn));\n<95> ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_DEFAULT,\n<107> ret = bdrv_pwrite(bs->file, sn->l1_table_offset, l1_table,\n<147> new_snapshot_list = g_malloc((s->nb_snapshots + 1) * sizeof(QCowSnapshot));\n<149> if (s->snapshots) {\n<153> s->nb_snapshots * sizeof(QCowSnapshot));\n<155> old_snapshot_list = s->snapshots;\n<159> s->snapshots = new_snapshot_list;\n<191> align_offset(sn->vm_state_size, s->cluster_size)\n<217> g_free(sn->id_str);\n<219> g_free(sn->name);
<1> static int cmp_value_string ( const void * v1 , const void * v2 ) {\n<2> const value_string * vs1 = ( const value_string * ) v1 ;\n<3> const value_string * vs2 = ( const value_string * ) v2 ;\n<4> return strcmp ( vs1 -> strptr , vs2 -> strptr ) ;
<1> static const char * passphrase_callback ( struct archive * a , void * _client_data ) {\n<4> if ( cpio -> ppbuff == NULL ) {\n<5> cpio -> ppbuff = malloc ( PPBUFF_SIZE ) ;\n<6> if ( cpio -> ppbuff == NULL ) lafe_errc ( 1 , errno , "Out of memory" ) ;\n<8> return lafe_readpassphrase ( "Enter passphrase:" , cpio -> ppbuff , PPBUFF_SIZE ) ;
<1> void SFDefaultOS2Info ( struct pfminfo * pfminfo , SplineFont * sf , char * fontname ) {\n<4> if ( sf -> pfminfo . pfmset ) {\n<5> if ( pfminfo != & sf -> pfminfo ) * pfminfo = sf -> pfminfo ;\n<6> if ( ! pfminfo -> panose_set ) {\n<8> memset ( & info , 0 , sizeof ( info ) ) ;\n<10> SFDefaultOS2Info ( & info , sf , fontname ) ;\n<12> memcpy ( pfminfo -> panose , info . panose , sizeof ( info . panose ) ) ;\n<17> if ( pfminfo -> hheadset || pfminfo -> vheadset ) hold = * pfminfo ;\n<19> memset ( pfminfo , '\0' , sizeof ( * pfminfo ) ) ;\n<20> SFDefaultOS2Simple ( pfminfo , sf ) ;\n<80> if ( ! pfminfo -> subsuper_set ) SFDefaultOS2SubSuper ( pfminfo , sf -> ascent + sf -> descent , sf -> italicangle ) ;
<1> static TRBCCode xhci_enable_slot ( XHCIState * xhci , unsigned int slotid ) {\n<6> memset ( xhci -> slots [ slotid - 1 ] . eps , 0 , sizeof ( XHCIEPContext * ) * 31 ) ;
<1> static int wma_decode_superframe ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<5> WMACodecContext * s = avctx -> priv_data ;\n<20> init_get_bits ( & s -> gb , buf , buf_size * 8 ) ;\n<42> if ( ( s -> last_superframe_len + ( ( bit_offset + 7 ) >> 3 ) ) > MAX_CODED_SUPERFRAME_SIZE ) goto fail ;\n<43> q = s -> last_superframe + s -> last_superframe_len ;\n<46> * q ++ = ( get_bits ) ( & s -> gb , 8 ) ;\n<50> * q ++ = ( get_bits ) ( & s -> gb , len ) << ( 8 - len ) ;\n<52> memset ( q , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<53> init_get_bits ( & s -> gb , s -> last_superframe , s -> last_superframe_len * 8 + bit_offset ) ;\n<55> if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n<68> if ( wma_decode_frame ( s , samples , samples_offset ) < 0 ) goto fail ;\n<74> len = buf_size - pos ;\n<75> if ( len > MAX_CODED_SUPERFRAME_SIZE || len < 0 ) {\n<80> memcpy ( s -> last_superframe , buf + pos , len ) ;
<1> void do_interrupt (CPUState *env)\n<41> switch (env->exception_index) {\n<121> memset(env->CP0_WatchLo, 0, sizeof(*env->CP0_WatchLo));\n<131> env->CP0_ErrorEPC = exception_resume_pc(env);\n<147> set_hflags_for_handler(env);\n<451> qemu_log("Invalid MIPS exception %d. Exiting\n", env->exception_index);\n<453> printf("Invalid MIPS exception %d. Exiting\n", env->exception_index);\n<459> if (qemu_log_enabled() && env->exception_index != EXCP_EXT_INTERRUPT) {
<1> static void ptvcursor_new_subtree_levels ( ptvcursor_t * ptvc ) {\n<6> DISSECTOR_ASSERT ( pushed_tree != NULL ) ;\n<7> if ( ptvc -> pushed_tree ) memcpy ( pushed_tree , ptvc -> pushed_tree , ptvc -> pushed_tree_max - SUBTREE_ONCE_ALLOCATION_NUMBER ) ;\n<8> ptvc -> pushed_tree = pushed_tree ;
<1> static void free_cache ( struct name_cache * cache ) {\n<3> if ( cache != NULL ) {\n<5> i < cache -> size ;\n<6> i ++ ) free ( cache -> cache [ i ] . name ) ;\n<7> free ( cache ) ;
<1> static int init_input(AVFormatContext *s, const char *filename, AVDictionary **options)\n<7> AVProbeData pd = {filename, NULL, 0};\n<11> if(s->iformat && !strlen(filename))\n<13> return 0;\n<17> if (s->pb) {\n<21> if (!s->iformat)\n<23> return av_probe_input_buffer(s->pb, &s->iformat, filename, s, 0, 0);\n<37> if ( (s->iformat && s->iformat->flags & AVFMT_NOFILE) ||
<1> static void selinux_bprm_committed_creds ( struct linux_binprm * bprm ) {\n<11> if ( IS_ENABLED ( CONFIG_POSIX_TIMERS ) ) {\n<12> memset ( & itimer , 0 , sizeof itimer ) ;\n<15> i ++ ) do_setitimer ( i , & itimer , NULL ) ;
<1> static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n<11> const uint8_t *end, *ptr = avpkt->data;\n<27> while (memcmp(ptr, "/* XPM */\n", 10) && ptr < end - 10)\n<29> ptr++;\n<33> if (ptr >= end) {\n<43> ptr += mod_strcspn(ptr, "\"");\n<49> av_log(avctx, AV_LOG_ERROR, "missing image parameters\n");\n<51> return AVERROR_INVALIDDATA;\n<57> if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n<69> if (cpp <= 0 || cpp >= 5) {\n<71> av_log(avctx, AV_LOG_ERROR, "unsupported/invalid number of chars per pixel: %d\n", cpp);\n<81> for (i = 0; i < cpp; i++)\n<87> if (ncolors <= 0 || ncolors > size) {\n<89> av_log(avctx, AV_LOG_ERROR, "invalid number of colors: %d\n", ncolors);\n<109> ptr += mod_strcspn(ptr, ",") + 1;\n<111> for (i = 0; i < ncolors; i++) {\n<121> if (ptr + cpp > end)\n<127> ptr += cpp;\n<131> ptr = strstr(ptr, "c ");\n<135> ptr += 2;\n<149> if ((ret = ascii2index(index, cpp)) < 0)\n<163> for (i = 0; i < avctx->height; i++) {\n<171> for (j = 0; j < avctx->width; j++) {\n<173> if (ptr + cpp > end)\n<179> if ((ret = ascii2index(ptr, cpp)) < 0)\n<187> ptr += cpp;
<1> static void adx_encode(unsigned char *adx,const short *wav,PREV *prev)\n<51> if (max==0 && min==0) {\n<53> memset(adx,0,18);
<1> static int transcode(OutputFile *output_files,\n<29> if (!(no_packet = av_mallocz(nb_input_files)))\n<35> ret = transcode_init(output_files, nb_output_files, input_files, nb_input_files);\n<45> if(verbose >= 0)\n<47> fprintf(stderr, "Press [q] to stop, [?] for help\n");\n<119> if (key == 'c' || key == 'C'){\n<121> char ret[4096], target[64], cmd[256], arg[256]={0};\n<125> fprintf(stderr, "\nEnter command: <target> <time> <command>[ <argument>]\n");\n<127> if(scanf("%4095[^\n\r]%*c", ret) == 1 && sscanf(ret, "%63[^ ] %lf %255[^ ] %255[^\n]", target, &ts, cmd, arg) >= 3){\n<129> for(i=0;i<nb_output_streams;i++) {\n<137> if(ts<0){\n<139> r= avfilter_graph_send_command(ost->graph, target, cmd, arg, ret, sizeof(ret), key == 'c' ? AVFILTER_CMD_FLAG_ONE : 0);\n<141> fprintf(stderr, "Command reply for %d: %d, %s\n", i, r, ret);\n<145> r= avfilter_graph_queue_command(ost->graph, target, cmd, arg, 0, ts);\n<155> fprintf(stderr, "Parse error\n");\n<161> if (key == 'd' || key == 'D'){\n<163> int debug=0;\n<165> if(key == 'D') {\n<169> if(!debug) debug = 1;\n<171> while(debug & (FF_DEBUG_DCT_COEFF|FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) //unsupported, would just crash\n<173> debug += debug;\n<177> scanf("%d", &debug);\n<181> input_streams[i].st->codec->debug = debug;\n<189> ost->st->codec->debug = debug;\n<195> fprintf(stderr,"debug=%d\n", debug);\n<199> if (key == '?'){\n<247> ist = &input_streams[ost->source_index];\n<249> if (ost->is_past_recording_time || no_packet[ist->file_index] ||\n<265> if(input_sync ) file_index = ist->file_index;\n<273> if(!input_sync) file_index = ist->file_index;\n<293> if(no_packet_count){\n<297> memset(no_packet, 0, nb_input_files);\n<319> no_packet[file_index]=1;\n<327> if (ret < 0) {\n<345> memset(no_packet, 0, nb_input_files);\n<439> if (output_packet(ist, ist_index, output_streams, nb_output_streams, &pkt) < 0) {\n<443> if (verbose >= 0)\n<445> fprintf(stderr, "Error while decoding stream #%d.%d\n",\n<483> output_packet(ist, i, output_streams, nb_output_streams, NULL);\n<565> av_freep(&no_packet);
<1> int kvm_arch_init(KVMState *s)\n<15> if (ret < 0) {\n<25> lm_capable_kernel = strcmp(utsname.machine, "x86_64") == 0;\n<89> if (ret < 0) {\n<91> fprintf(stderr, "e820_add_entry() table is full\n");
<1> int net_slirp_smb ( const char * exported_dir ) {\n<5> if ( legacy_smb_export ) {\n<6> fprintf ( stderr , "-smb given twice\n" ) ;
<1> static void test_acpi_one(const char *params)\n<69> for (off = 0xf0000; off < 0x100000; off += 0x10)\n<81> sig[i] = readb(off + i);\n<87> if (!memcmp(sig, "RSD PTR ", sizeof sig)) {
<1> kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) {\n<12> krb5_key_salt_tuple * new_ks_tuple = NULL ;\n<18> ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ;\n<19> if ( ret ) goto done ;\n<20> if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) {\n<21> if ( keepold ) return KADM5_PROTECT_PRINCIPAL ;\n<26> ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ;\n<60> ret = k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ;\n<63> ( void ) k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ;\n<65> done : free ( new_ks_tuple ) ;
<1> static void * set_bootinfo_tag ( void * addr , uint32_t tag , uint32_t size , void * data ) {\n<6> pos += 4 ;\n<7> memcpy ( pos , data , size ) ;\n<8> pos += size ;
<1> int xen_hvm_init(ram_addr_t *below_4g_mem_size, ram_addr_t *above_4g_mem_size,\n<103> hw_error("get vmport regs pfn returned error %d, rc=%d", errno, rc);\n<119> hw_error("map buffered IO page returned error %d", errno);\n<143> if (rc == -1) {\n<145> fprintf(stderr, "bind interdomain ioctl error %d\n", errno);\n<161> if (rc < 0) {\n<163> fprintf(stderr, "failed to get HVM_PARAM_BUFIOREQ_EVTCHN\n");\n<173> if (rc == -1) {\n<175> fprintf(stderr, "bind interdomain ioctl error %d\n", errno);\n<209> if (xen_be_init() != 0) {\n<211> fprintf(stderr, "%s: xen backend core setup failed\n", __FUNCTION__);
<1> int vp9_set_size_literal ( VP9_COMP * cpi , unsigned int width , unsigned int height ) {\n<2> VP9_COMMON * cm = & cpi -> common ;\n<6> if ( cm -> width * 5 < cpi -> initial_width ) {\n<7> cm -> width = cpi -> initial_width / 5 + 1 ;\n<8> printf ( "Warning: Desired width too small, changed to %d\n" , cm -> width ) ;\n<10> if ( cm -> width > cpi -> initial_width ) {\n<11> cm -> width = cpi -> initial_width ;\n<12> printf ( "Warning: Desired width too large, changed to %d\n" , cm -> width ) ;\n<17> if ( cm -> height * 5 < cpi -> initial_height ) {\n<18> cm -> height = cpi -> initial_height / 5 + 1 ;\n<19> printf ( "Warning: Desired height too small, changed to %d\n" , cm -> height ) ;\n<21> if ( cm -> height > cpi -> initial_height ) {\n<22> cm -> height = cpi -> initial_height ;\n<23> printf ( "Warning: Desired height too large, changed to %d\n" , cm -> height ) ;\n<26> assert ( cm -> width <= cpi -> initial_width ) ;\n<27> assert ( cm -> height <= cpi -> initial_height ) ;
<1> static void test_signal_dealloc ( void ) {\n<4> printf ( "Signal dealloc: " ) ;
<1> static char *getstr8(const uint8_t **pp, const uint8_t *p_end)\n<13> p   = *pp;\n<15> len = get8(&p, p_end);\n<17> if (len < 0)\n<27> if (!str)\n<31> memcpy(str, p, len);\n<35> p  += len;\n<39> return str;
<1> static int svq1_decode_frame(AVCodecContext *avctx, void *data,\n<101> if (!pmv)\n<187> memset(pmv, 0, ((width / 8) + 3) * sizeof(svq1_pmv));\n<257> av_free(pmv);
<1> int dtls1_send_server_hello ( SSL * s ) {\n<7> if ( s -> state == SSL3_ST_SW_SRVR_HELLO_A ) {\n<10> ssl_fill_hello_random ( s , 1 , p , SSL3_RANDOM_SIZE ) ;\n<13> * ( p ++ ) = s -> version & 0xff ;\n<14> memcpy ( p , s -> s3 -> server_random , SSL3_RANDOM_SIZE ) ;\n<15> p += SSL3_RANDOM_SIZE ;\n<18> if ( sl > sizeof s -> session -> session_id ) {\n<22> * ( p ++ ) = sl ;\n<23> memcpy ( p , s -> session -> session_id , sl ) ;\n<24> p += sl ;
<1> static void keytype ( struct parse * pcmd , FILE * fp ) {\n<5> if ( ! pcmd -> nargs ) {\n<6> fprintf ( fp , "keytype is %s with %lu octet digests\n" , keytype_name ( info_auth_keytype ) , ( u_long ) info_auth_hashlen ) ;
<1> static void server_send_summary ( struct client * client , struct config * config ) {\n<17> i < config -> count ;\n<19> memset ( & process , 0 , sizeof ( process ) ) ;\n<20> process . client = client ;\n<23> if ( rule -> summary == NULL ) continue ;\n<26> req_argv = xcalloc ( 4 , sizeof ( char * ) ) ;\n<30> req_argv [ 0 ] = program ;\n<31> req_argv [ 1 ] = rule -> summary ;\n<32> subcommand = rule -> subcommand ;\n<33> if ( strcmp ( subcommand , "ALL" ) == 0 || strcmp ( subcommand , "EMPTY" ) == 0 ) req_argv [ 2 ] = NULL ;\n<34> else req_argv [ 2 ] = subcommand ;\n<35> req_argv [ 3 ] = NULL ;\n<36> process . command = rule -> summary ;\n<37> process . argv = req_argv ;\n<38> process . rule = rule ;\n<39> if ( server_process_run ( & process ) ) {\n<40> if ( client -> protocol == 1 ) if ( evbuffer_add_buffer ( output , process . output ) < 0 ) die ( "internal error: cannot copy data from output buffer" ) ;\n<41> if ( process . status != 0 ) status_all = process . status ;\n<43> free ( req_argv ) ;\n<45> if ( WIFEXITED ( status_all ) ) status_all = ( int ) WEXITSTATUS ( process . status ) ;
<1> void do_get_replace ( struct st_command * command ) {\n<3> char * from = command -> first_argument ;\n<11> if ( ! * from ) die ( "Missing argument in %s" , command -> query ) ;\n<12> start = buff = ( char * ) my_malloc ( strlen ( from ) + 1 , MYF ( MY_WME | MY_FAE ) ) ;\n<14> char * to = buff ;\n<15> to = get_string ( & buff , & from , command ) ;\n<19> to = get_string ( & buff , & from , command ) ;\n<29> my_free ( start ) ;
<1> static int32_t scsi_send_command(SCSIDevice *d, uint32_t tag,\n<63> r = scsi_new_request(d, tag, lun);\n<107> if (r->req.cmd.xfer == 0) {\n<133> if (r->buflen != r->req.cmd.xfer) {\n<139> r->buf = qemu_malloc(r->req.cmd.xfer);\n<141> r->buflen = r->req.cmd.xfer;\n<147> memset(r->buf, 0, r->buflen);
<1> static int tgq_decode_mb(TgqContext *s, AVFrame *frame, int mb_y, int mb_x)\n<9> int8_t dc[6];\n<31> if (mode == 3) {\n<33> memset(dc, bytestream2_get_byte(&s->gb), 4);\n<61> tgq_idct_put_mb_dconly(s, frame, mb_x, mb_y, dc);
<1> static int check_port ( struct manager_ctx * manager , struct server * server ) {\n<5> int * sock_fds = ( int * ) ss_malloc ( fd_count * sizeof ( int ) ) ;\n<6> memset ( sock_fds , 0 , fd_count * sizeof ( int ) ) ;\n<20> if ( sock_fds [ i ] == - 1 || ( both_tcp_udp && sock_fds [ i + manager -> host_num ] == - 1 ) ) {\n<28> if ( sock_fds [ i ] > 0 ) {\n<29> close ( sock_fds [ i ] ) ;\n<32> ss_free ( sock_fds ) ;
<1> static int mpsub_probe(AVProbeData *p)\n<11> while (ptr < ptr_end) {\n<13> if (!memcmp(ptr, "FORMAT=TIME", 11))\n<15> return AVPROBE_SCORE_EXTENSION;\n<17> if (!memcmp(ptr, "FORMAT=", 7))\n<19> return AVPROBE_SCORE_EXTENSION / 3;\n<21> ptr += strcspn(ptr, "\n") + 1;
<1> static void handle_a_request ( int dns_fd , struct query * q , int fakeip ) {\n<4> if ( fakeip ) {\n<5> in_addr_t ip = inet_addr ( "127.0.0.1" ) ;\n<6> memcpy ( & q -> destination . s_addr , & ip , sizeof ( in_addr_t ) ) ;\n<8> else if ( ns_ip != INADDR_ANY ) {\n<9> memcpy ( & q -> destination . s_addr , & ns_ip , sizeof ( in_addr_t ) ) ;\n<11> len = dns_encode_a_response ( buf , sizeof ( buf ) , q ) ;\n<12> if ( len < 1 ) {\n<16> if ( debug >= 2 ) {\n<17> fprintf ( stderr , "TX: client %s, type %d, name %s, %d bytes A reply\n" , format_addr ( & q -> from , q -> fromlen ) , q -> type , q -> name , len ) ;\n<19> if ( sendto ( dns_fd , buf , len , 0 , ( struct sockaddr * ) & q -> from , q -> fromlen ) <= 0 ) {
<1> static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamples)\n<33> if (showwaves->buf_idx == 0 && showwaves->sample_count_mod == 0) {\n<57> memset(outpicref->data[0], 0, showwaves->h*linesize);\n<67> *(outpicref->data[0] + showwaves->buf_idx + h * linesize) += x;
<1> static void event_loop(VideoState *cur_stream)\n<233> thh  = tns / 3600;\n<235> tmm  = (tns % 3600) / 60;\n<237> tss  = (tns % 60);\n<243> hh   = ns / 3600;\n<245> mm   = (ns % 3600) / 60;\n<247> ss   = (ns % 60);\n<249> fprintf(stderr, "Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \n", frac*100,
<1> static int CreateHTTPRangeResponseHeader ( char * ByteRangeSpecifier , off_t FileLength , struct SendInstruction * Instr ) {\n<8> if ( ! ByteRangeSpecifier ) return HTTP_BAD_REQUEST ;\n<9> RangeInput = strdup ( ByteRangeSpecifier ) ;\n<10> if ( ! RangeInput ) return HTTP_INTERNAL_SERVER_ERROR ;\n<11> if ( StrStr ( RangeInput , "bytes" ) == NULL || ( Ptr = StrStr ( RangeInput , "=" ) ) == NULL ) {\n<12> free ( RangeInput ) ;\n<17> if ( FileLength < 0 ) {\n<18> free ( RangeInput ) ;\n<21> if ( GetNextRange ( & Ptr , & FirstByte , & LastByte ) != - 1 ) {\n<22> if ( FileLength < FirstByte ) {\n<23> free ( RangeInput ) ;\n<31> if ( rc < 0 || ( unsigned int ) rc >= sizeof ( Instr -> RangeHeader ) ) {\n<32> free ( RangeInput ) ;\n<40> if ( rc < 0 || ( unsigned int ) rc >= sizeof ( Instr -> RangeHeader ) ) {\n<41> free ( RangeInput ) ;\n<45> else if ( FirstByte == - 1 && LastByte > 0 ) {\n<56> if ( rc < 0 || ( unsigned int ) rc >= sizeof ( Instr -> RangeHeader ) ) {\n<57> free ( RangeInput ) ;\n<62> free ( RangeInput ) ;\n<67> free ( RangeInput ) ;\n<70> free ( RangeInput ) ;
<1> static int vmdk_parent_open(BlockDriverState *bs, const char * filename)\n<17> if (bdrv_pread(s->hd, 0x200, desc, DESC_SIZE) != DESC_SIZE)\n<23> if ((p_name = strstr(desc,"parentFileNameHint")) != 0) {\n<31> p_name += sizeof("parentFileNameHint") + 1;\n<33> if ((end_name = strchr(p_name,'\"')) == 0)\n<35> return -1;\n<39> strncpy(s->hd->backing_file, p_name, end_name - p_name);\n<41> if (stat(s->hd->backing_file, &file_buf) != 0) {\n<55> s->hd->backing_hd = bdrv_new("");\n<57> if (!s->hd->backing_hd) {\n<75> return 0;
<1> qcms_bool compute_precache ( struct curveType * trc , uint8_t * output ) {\n<16> if ( ! inverted ) return false ;\n<17> compute_precache_lut ( output , inverted , inverted_size ) ;\n<18> free ( inverted ) ;\n<32> if ( ! inverted ) return false ;\n<33> compute_precache_lut ( output , inverted , inverted_size ) ;\n<34> free ( inverted ) ;
<1> TEST_F ( TransportSecurityPersisterTest , SerializeData3 ) {\n<3> memset ( fp1 . data ( ) , 0 , fp1 . size ( ) ) ;\n<5> memset ( fp2 . data ( ) , 1 , fp2 . size ( ) ) ;\n<13> memset ( fp1 . data ( ) , 2 , fp1 . size ( ) ) ;\n<14> memset ( fp2 . data ( ) , 3 , fp2 . size ( ) ) ;
<1> static fz_icclink * fz_new_icc_link ( fz_context * ctx , fz_iccprofile * dst , int dst_extras , fz_iccprofile * src , int src_extras , fz_iccprofile * prf , const fz_color_params * rend , int num_bytes , int copy_extras ) {\n<4> if ( memcmp ( src -> md5 , dst -> md5 , 16 ) == 0 && prf == NULL ) {\n<5> link -> is_identity = 1 ;\n<6> return link ;\n<8> fz_try ( ctx ) fz_cmm_init_link ( ctx , link , dst , dst_extras , src , src_extras , prf , rend , 0 , num_bytes , copy_extras ) ;\n<9> fz_catch ( ctx ) {\n<10> fz_free ( ctx , link ) ;\n<11> fz_rethrow ( ctx ) ;\n<13> return link ;
<1> static inline void gen_intermediate_code_internal(CPUARMState *env,\n<9> DisasContext dc1, *dc = &dc1;\n<205> if (dc->pc >= 0xfffffff0 && IS_M(env)) {\n<227> if (bp->pc == dc->pc) {\n<281> tcg_gen_debug_insn_start(dc->pc);\n<289> disas_thumb_insn(env, dc);\n<309> disas_arm_insn(env, dc);\n<325> if (tcg_check_temp_count()) {\n<327> fprintf(stderr, "TCG temporary leak before %08x\n", dc->pc);\n<349> dc->pc < next_page_start &&\n<385> gen_set_condexec(dc);\n<403> gen_set_pc_im(dc->pc);\n<409> gen_set_condexec(dc);\n<443> gen_set_condexec(dc);\n<449> gen_goto_tb(dc, 1, dc->pc);\n<489> gen_set_condexec(dc);\n<491> gen_goto_tb(dc, 1, dc->pc);\n<537> tb->size = dc->pc - pc_start;